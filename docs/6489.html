<html>
<head>
<title>Learning AWS with Localstack and Reactive Kotlin — A stamps and coins implementation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Localstack和Reactive Kotlin学习AWS邮票和硬币实现</h1>
<blockquote>原文：<a href="https://itnext.io/learning-aws-with-localstack-and-reactive-kotlin-a-stamps-and-coins-implementation-d10278f98587?source=collection_archive---------2-----------------------#2021-12-01">https://itnext.io/learning-aws-with-localstack-and-reactive-kotlin-a-stamps-and-coins-implementation-d10278f98587?source=collection_archive---------2-----------------------#2021-12-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/9c5eb9a947cff5d714c0310764d3d03f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ECVDlb31qCJtf6dbB3qoFA.jpeg"/></div></div></figure></div><div class="ab cl kb kc hx kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="im in io ip iq"><p id="472c" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">至少从2002年开始，亚马逊网络服务就已经存在，提供商业上可用的云计算。无论是在概念上还是在物理上，云计算的名称可以追溯到1996年<strong class="kk iu"/>。这是第一份明确提及云计算的文件出现在<strong class="kk iu">康柏</strong>商业计划文件中的地方。如果我们认为<strong class="kk iu">云计算</strong>来自于计算机科学中另一个重要的概念，叫做<strong class="kk iu">分布式计算</strong>，那么我们必须追溯到更远的20世纪60年代<strong class="kk iu"/>才能找到这些概念的真正早期起源。正是在1963年，J. C. R. Licklider分发了一份备忘录，概述了在网络系统中实现实时计算的挑战。利克里德是高级研究计划局(ARPA )信息处理技术办公室(IPTO )的负责人。从这一点开始，现在向前看，我们看到高级研究计划局网络(<strong class="kk iu"> ARPANET </strong>)开始发展，其第一台计算机于1969年<strong class="kk iu">连接，并最终于1970年<strong class="kk iu">建立。计算机科学网络(<strong class="kk iu"> CSNET </strong>)随后在<strong class="kk iu"> 1981 </strong>建立，并导致了<strong class="kk iu"> ARPANET </strong>在大学和科学中心的扩展。国家科学基金会网络(<strong class="kk iu"> NSFNET </strong>)成立于<strong class="kk iu"> 1986 </strong>年，是对<strong class="kk iu"> ARPANET </strong>的补充。ARPANET的扩展和向公众开放导致它于1990年在T42退役，让位于万维网，也就是我们现在所知的互联网。让每个人都可以使用互联网迅速带来了业务增长和商业模式的改变。因此，毫不奇怪，人们开始探索在网上拓展业务的可能性。这导致了1994年<strong class="kk iu">亚马逊<strong class="kk iu">和杰夫·贝索斯</strong>作为一个极其简单的在线书店的诞生。这比1996年<strong class="kk iu">创造云计算这个术语早了两年。因此，在<strong class="kk iu"> 8 </strong>年的时间跨度内，<strong class="kk iu">亚马逊</strong>的工程师们创建了他们第一部分的测试版，这在当时被称为“<strong class="kk iu"><em class="lg">Amazon.com网络服务</em> </strong> <em class="lg">”。</em>该服务允许客户通过<strong class="kk iu"> XML </strong>信封和<strong class="kk iu"> SOAP </strong> web服务连接并获取产品信息。在<strong class="kk iu"> 2000 </strong>，<strong class="kk iu">罗伊·菲尔丁</strong>提交了一篇关于一种叫做表述性状态转移(<strong class="kk iu"> REST </strong>)的新通信协议的博士论文。稍后，它将开始取代使用<strong class="kk iu"> SOAP </strong> ( <strong class="kk iu">简单对象访问协议</strong>)协议，尽管<strong class="kk iu"> SOAP </strong>作为一种被废弃的技术至今仍在大量使用。从<strong class="kk iu"> 2002 </strong>到现在，我们与<strong class="kk iu"> Webservices </strong>和<strong class="kk iu"> AWS </strong>合作的方式发生了进一步的极端变化，就像任何其他<strong class="kk iu">云</strong>提供商一样，已经相当独立地发展，但保持了基本概念的洞察力。比如说。说到在<strong class="kk iu">云中存储文件</strong> , <strong class="kk iu"> AWS </strong>现在提供<strong class="kk iu"> S3 </strong>，自2006年<strong class="kk iu">3月14日</strong>开始提供。自2012年1月<strong class="kk iu">起</strong>一个<strong class="kk iu"> NoSQL </strong>数据库已经可用。<strong class="kk iu"> AWS </strong>，作为一个云系统，在<strong class="kk iu">云</strong>中工作会非常复杂。这主要是因为一旦<strong class="kk iu">免费层</strong>结束，我们就必须为<strong class="kk iu"> AWS </strong>的使用付费，根据我们决定注册的计划，费用可能会波动，并且在很大程度上取决于您作为<strong class="kk iu">系统经理</strong>的选择。这就是<strong class="kk iu"> Localstack </strong>的用武之地，它的第一个版本在GitHub上注册为2016年12月11日<strong class="kk iu"/>。很快，我们现在享受到了云计算的好处，以及一个系统的好处，我们可以像真正的云一样，使用相同的语法、消息格式和配置在本地运行。目前，<strong class="kk iu"> AWS </strong>云服务提供了50多种不同类型的服务，它们似乎都是<strong class="kk iu"> Localstack </strong>设立的目标。</strong></strong></strong></strong></p><p id="dada" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">我想先介绍一下，因为认识到这一点也很重要，尽管我们现在遇到了许多本地系统，但我们必须认识到在本地运行的想法已经过时了。云计算的概念早在1996年<strong class="kk iu">、</strong>就有了，而一些服务，如云存储，如<strong class="kk iu">、</strong>，早在2006年<strong class="kk iu">、</strong>就已经出现了。这意味着所有需要关注性能、资源使用、成本降低、高可用性、弹性、可维护性、容量和反应能力的系统都不应该在本地使用。在最好的情况下，我们可以控制我们在本地所做的一切，而在最糟糕的情况下，我们将无法承担与在本地维护这样一个系统相关的费用。当然，除非我们想为我们的家人、朋友和熟人提供一个私人使用的小型私人网站。那么你很可能不需要任何云计算来支持这个。在本文中，我们将看看我在<a class="ae lh" href="https://github.com/jesperancinha/staco-app" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上创建的一个例子。</p><h1 id="baf3" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">1.为什么要使用Localstack？</h1><p id="780a" class="pw-post-body-paragraph ki kj it kk b kl mg kn ko kp mh kr ks kt mi kv kw kx mj kz la lb mk ld le lf im bi translated">在本文中，我们将探索两个项目，它们使用了<strong class="kk iu"> LocalStack </strong>的3个特性，也可以在<strong class="kk iu"> AWS </strong>中找到。这些是<strong class="kk iu"> S3 </strong> ( <strong class="kk iu">简单存储服务</strong>)、<strong class="kk iu"> DynamoDB </strong>和<strong class="kk iu">参数存储</strong>。</p><p id="528b" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">我选择了这三种技术的用法，并且只选择了这些，因为我写这篇文章的时候想到了已经在使用<strong class="kk iu"> AWS </strong>的人，或者刚刚开始使用它并且正在努力理解它背后的"<strong class="kk iu"><em class="lg"/></strong>"魔法的人。</p><p id="a0a5" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">尤其是在工作中，出于多种原因，按照我们预期的方式使用<strong class="kk iu"> AWS </strong>甚至只是探索它都是一种挑战:</p><ul class=""><li id="5a67" class="ml mm it kk b kl km kp kq kt mn kx mo lb mp lf mq mr ms mt bi translated">您没有权限创建、编写或更改任何内容</li><li id="1278" class="ml mm it kk b kl mu kp mv kt mw kx mx lb my lf mq mr ms mt bi translated">您的系统管理员可能会根据您的期望更改配置或属性</li><li id="9977" class="ml mm it kk b kl mu kp mv kt mw kx mx lb my lf mq mr ms mt bi translated">添加服务、资源并查看它们是如何工作的，这可能意味着增加贵公司的AWS使用成本，而这些成本可能并不包括在内。</li><li id="8351" class="ml mm it kk b kl mu kp mv kt mw kx mx lb my lf mq mr ms mt bi translated">您希望检查性能测试的预演是否有效，并且不希望冒因性能测试实现中的错误而导致不必要的峰值使用的风险。</li><li id="b408" class="ml mm it kk b kl mu kp mv kt mw kx mx lb my lf mq mr ms mt bi translated">你只是想探索，可能还不想将你的电子邮件与AWS帐户相关联，甚至可能永远不会。</li><li id="5100" class="ml mm it kk b kl mu kp mv kt mw kx mx lb my lf mq mr ms mt bi translated">你不希望花时间直接调整云中的东西，而是希望确保在转移到云中之前知道自己在做什么，以便尽可能平稳地完成过渡过程。</li><li id="47e0" class="ml mm it kk b kl mu kp mv kt mw kx mx lb my lf mq mr ms mt bi translated">你想用<strong class="kk iu"> AWS </strong>组件进行集成测试，但不使用真正的组件。本质上，您只是想使用某种虚拟环境，在其中可以使用这些组件或类似的组件。</li><li id="6c1f" class="ml mm it kk b kl mu kp mv kt mw kx mx lb my lf mq mr ms mt bi translated">在你的项目中，所有的事情都是由某个已经离开团队的人替你和你的队友想出来的，而这个人现在已经联系不上了。他们已经设计并创建了供你使用的库，这一切看起来都很完美。除了现在你需要解决一个问题，但你只知道一些属性的工作，但不知道他们如何使用和他们得到应用。</li></ul><h1 id="3b73" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">2.为什么使用DynamoDB</h1><p id="77a2" class="pw-post-body-paragraph ki kj it kk b kl mg kn ko kp mh kr ks kt mi kv kw kx mj kz la lb mk ld le lf im bi translated">多年来，我们已经习惯于思考关于外键、主键以及与实体关系模型相关的所有事物的概念。<strong class="kk iu"> Hibernate </strong>和<strong class="kk iu"> JPA </strong>库，甚至是反应式<strong class="kk iu"> CRUD </strong>库，帮助我们做到这一点。然而，当我们有大量的数据，而这些数据在表之间没有太多的关系时，使用<strong class="kk iu"> ER </strong>模型就变得不那么相关了。它们让一切都变得缓慢，而且很多时候它们并没有被应用到用例中。在<strong class="kk iu">或</strong>模式下，拥有大量数据的数据库表现不佳。我们看到即使我们在后端使用微调<strong class="kk iu"> ORM </strong>(对象关系映射)。有时我们甚至敢于在代码中使用原生查询，因为它给我们一种性能有了很大提高的感觉。如果我们必须提供大量数据，我们可能不需要使用很多关系。这就是<strong class="kk iu"> DynamoDB </strong>的用武之地。其中DynamoDB被提升为具有或导致:</p><ol class=""><li id="9ceb" class="ml mm it kk b kl km kp kq kt mn kx mo lb mp lf mz mr ms mt bi translated">高度可扩展</li><li id="68fa" class="ml mm it kk b kl mu kp mv kt mw kx mx lb my lf mz mr ms mt bi translated">适合OLTP(在线事务处理)</li><li id="5ba4" class="ml mm it kk b kl mu kp mv kt mw kx mx lb my lf mz mr ms mt bi translated">快速读写易于实现</li><li id="1db5" class="ml mm it kk b kl mu kp mv kt mw kx mx lb my lf mz mr ms mt bi translated">自动化高可用性</li><li id="9392" class="ml mm it kk b kl mu kp mv kt mw kx mx lb my lf mz mr ms mt bi translated">操作系统工作量的减少</li><li id="fe36" class="ml mm it kk b kl mu kp mv kt mw kx mx lb my lf mz mr ms mt bi translated">高水平的耐用性</li><li id="a293" class="ml mm it kk b kl mu kp mv kt mw kx mx lb my lf mz mr ms mt bi translated">管理不可预测的高峰负载</li></ol><p id="54ec" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">值得一提的是，<strong class="kk iu"> DynamoDB </strong>在Localstack中是免费的。然而，这使得我的文章也是关于DynamoDB的，这也是事实，我们检索的数据没有任何关系。我们还使用来自大量邮票和硬币的数据来模拟管理大量数据。最终，我们在<strong class="kk iu"> PostgreSQL </strong>和<strong class="kk iu"> DynamoDB </strong>中只得到一个表来服务所有这些数据。由于数据在不规则的时间间隔内不断出现，这也符合我们对DynamoDB的需求。</p><h1 id="33be" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">3.目标</h1><figure class="nb nc nd ne gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi na"><img src="../Images/f153e8fc4d952f7b5dbf206434a62fab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lnEeQqsD1St72iYA8J6Nsg.png"/></div></div><figcaption class="nf ng gj gh gi nh ni bd b be z dk translated">StaCo应用程序概述</figcaption></figure><p id="c683" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">从上面的例子中，我们了解了将要检查的组件、它们的相关代码和配置，最后，我们将检查这在网络环境中是如何工作的。</p><p id="d52a" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">在这一点上，我假设您知道协程如何工作以及协程反应库如何工作的基础知识。</p><p id="3752" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">在图中，我们看到了所有使用的容器的布局。本文中我们重点关注的是“<strong class="kk iu"><em class="lg">【local stack】</em></strong>容器。这就是我上面提到的容器，它模拟了一个真实的AWS云环境。如果你能认出容器内的符号，你可以很容易地认出绿色的<strong class="kk iu">参数库</strong>，蓝色的<strong class="kk iu">发电机DB </strong>，红色的<strong class="kk iu"> S3 </strong>。</p><p id="de6f" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">我们有一个<strong class="kk iu"> PostgreSQL </strong>数据库，它从大量与邮票和硬币相关的数据开始。该项目的第一部分的最终想法是从<strong class="kk iu"> PostgreSQL </strong>加载所有数据，并通过<strong class="kk iu"> Quartz作业</strong>将其传输到<strong class="kk iu"> DynamoDB </strong>。为了让它工作，我们将使用S3作为中介。我们将从<strong class="kk iu"> PostgreSQL </strong>数据库中读取数据，用该数据的所有内容创建一个CSV文件，将其压缩为<strong class="kk iu"> GZip </strong>文件格式，并将该文件发送到S3。一旦完成，另一个任务将从<strong class="kk iu"> S3 </strong>下载文件，处理它们，当完成时，文件将从<strong class="kk iu"> S3 </strong>中删除。在这种情况下，处理意味着解压缩文件并将<strong class="kk iu"> CSV </strong>内容加载到<strong class="kk iu"> DynamoDB </strong>。旧邮票和硬币将被更新，并用它们的<strong class="kk iu">主键</strong> ( <strong class="kk iu">主键</strong>)进行识别</p><p id="2330" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">为了能够访问<strong class="kk iu"> PostgreSQL </strong>并能够登录，我们将使用参数存储来保存我们需要的凭证。我们可以在参数存储中保存几种类型的数据。在这种情况下，我们使用它来保存和访问凭证</p><p id="7926" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">最后，我们希望了解代码在想要在前端可视化分页内容方面有何不同。为此，我们将看看用<strong class="kk iu"> SpringWebFlux </strong>和协程实现的两种不同的服务。一个使用分页直接访问<strong class="kk iu">PostgreSQL</strong>数据库，另一个使用异步客户端直接访问<strong class="kk iu"> DynamoDB </strong>。这两种服务都是以被动的方式实现的。</p><h1 id="d154" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">4.履行</h1><p id="5cae" class="pw-post-body-paragraph ki kj it kk b kl mg kn ko kp mh kr ks kt mi kv kw kx mj kz la lb mk ld le lf im bi translated">换句话说，这个项目的实现就是对这些库的研究:</p><figure class="nb nc nd ne gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nj"><img src="../Images/6ab86c642f879251e0598c66da698cc4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bG2p_91cGusRJQdydc2U5w.png"/></div></div></figure><p id="a4e5" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">这些库是名为AWS SDK for Java V.2的库集合的一部分。</p><p id="8876" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">虽然我们可以使用自动配置来访问AWS，但是我们必须使用手动配置来访问<code class="fe nk nl nm nn b"><strong class="kk iu">Localstack</strong></code>。多亏了V.2，可以手动配置AWS的位置和我们想要使用的凭证。<code class="fe nk nl nm nn b"><strong class="kk iu">Localstack</strong></code>，使用<code class="fe nk nl nm nn b"><strong class="kk iu">test</strong></code>作为凭证来识别在我们的容器中运行的云环境。</p><p id="bd3e" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">代码运行所需的一些配置通过非常小的容器加载到<strong class="kk iu"> Localstack </strong>中，容器运行一些命令。这将在参数存储中为我们的应用程序、PostgreSQL的用户名和密码创建一个bucket、用户名和密码。迪纳摩数据库表将在任何一个使用依赖关系<strong class="kk iu">邮票和硬币公共云</strong>的Spring Boot运行进程中创建</p><p id="94ae" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">在下面，我们将只检查代码。我会详细解释每一个代码。然后我们将看到如何运行演示。我做了一个视频，你可以在下面看看。最后，我们将看看一些直接指向Localstack的<code class="fe nk nl nm nn b"><strong class="kk iu">aws</strong></code>命令，我们将解释返回的结果。</p><figure class="nb nc nd ne gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi no"><img src="../Images/90678a0a4537a741c42c6bfef7a6c93e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3pPJebqD-xkTNTxRR7hFBw.png"/></div></div><figcaption class="nf ng gj gh gi nh ni bd b be z dk translated">在<a class="ae lh" href="https://github.com/jesperancinha/staco-app" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上完成序列图</figcaption></figure><h1 id="abba" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">4.1.参数存储</h1><figure class="nb nc nd ne gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi np"><img src="../Images/6fad02250278df44ba85f201d2f70e6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5F4fsnZ0xyJNboy9biaXLw.png"/></div></div><figcaption class="nf ng gj gh gi nh ni bd b be z dk translated">读取器和加载器域</figcaption></figure><p id="8f0c" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">为了用<strong class="kk iu"> AWS </strong>做任何事情，我们需要意识到我们使用参数存储的可能性非常高。这是因为参数存储正是我们可以讲述我们想要与我们决定运行的服务一起使用的属性的地方。在google上进行搜索，我们可以找到几个关于如何在使用由<strong class="kk iu"> Spring </strong>提供的<strong class="kk iu"> Value </strong> <strong class="kk iu"> Inject </strong>的同时手动实现对参数存储的访问的实现。我更喜欢添加一个<strong class="kk iu">environment postprocessor</strong>作为处理我们属性的最后一个元素。</p><figure class="nb nc nd ne gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nq"><img src="../Images/0ecb8d2ea8e5e691d80e4a584cf5b6b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B2SeIBc3-VfRYyrH7K3WIQ.png"/></div></div></figure><p id="b6fb" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">在这种情况下，我创建了代码，这样我们也可以通过环境变量配置我们的<strong class="kk iu"> Localstack </strong>实例的位置。我们可以将它添加到我们的<strong class="kk iu"> spring.factories </strong>中，以便添加这个<strong class="kk iu">环境后处理器</strong>。这将确保我们能够在AWS中找到所有尚未分配的属性。这是由<strong class="kk iu">参数StorePropertySource </strong>完成的。这是该系统的实际实现。我让<strong class="kk iu"> config </strong>成为一个通用方法，以同样的方式创建实例。因为它们在本文中有共同的特征，所以这样做是有意义的。这样，我们的客户端实例<strong class="kk iu"> SSM </strong>、<strong class="kk iu"> S3、</strong>和<strong class="kk iu"> DynamoDB </strong>将被创建为指向同一个Localstack，我们不必担心额外的实现。</p><figure class="nb nc nd ne gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nq"><img src="../Images/0c78b855ecf345406e25c7f51499257a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T9O-FquTKT4y4hfC0v4gYw.png"/></div></div></figure><p id="5522" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">在我们的实现中，我们将只考虑以反斜杠开头的属性。在现实生活中，在AWS中，SSM参数存储属性通常以<strong class="kk iu"> /aws/ </strong>开始。在我们的例子中，我们正在制作非常定制的东西，所以我们的属性都将从<strong class="kk iu">/config/StaCoLsService/</strong>开始。</p><p id="e23f" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">既然我们理解了这些变化，现在我们可以简单地将这个公共依赖添加到存储库中，在那里我们需要从<strong class="kk iu">参数存储库</strong>中读取属性。</p><h1 id="1df5" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">4.2.S3 —简单存储服务—阅读器</h1><figure class="nb nc nd ne gt ju gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/3a8553186a665d67b77b0a18e36bb4c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:996/format:webp/1*4gebE6_ihAhYbWaa15ejDw.png"/></div><figcaption class="nf ng gj gh gi nh ni bd b be z dk translated">Dynamo数据库加载程序的序列图</figcaption></figure><p id="34d1" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">读取器和装载器作业位于同一个模块中，即模块<strong class="kk iu">邮票和硬币批次</strong>。这个模块本质上是一个独立的Spring Boot进程，确保我们的数据被临时存储在<strong class="kk iu"> S3 </strong>中，然后被下载并发送到<strong class="kk iu"> DynamoDB </strong>。正如我上面提到的，我对所有的Localstack服务使用一个通用的配置方法，假设所有的服务碰巧共享相同的配置:</p><figure class="nb nc nd ne gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ns"><img src="../Images/0317f9df575d3888c2d42c538b0a2636.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ytiMFGjjcBaqOGRjLTJGzA.png"/></div></div></figure><p id="a068" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">我们的作业从<strong class="kk iu"> <em class="lg">执行</em> </strong>点开始，在协程上下文<strong class="kk iu"> <em class="lg"> IO </em> </strong>中启动，然后从数据库中检索所有数据。此时，可能没有必要使用协程，因为不幸的是，为了处理一个文件的所有内容，我们需要阻塞这个过程:</p><figure class="nb nc nd ne gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nq"><img src="../Images/b7ad7d80b2b5d0a783d3e46a8c3d4ad8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nixleHjYEXrgd1U6hV5Q8w.png"/></div></div></figure><p id="42e3" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">列表加载到内存中后，我们现在创建我们的文件。这是事情变得非常困难的地方，取决于你有多少可用的资源。有许多不同的解决方案可以将大量数据处理到不同的文件或分区中，但这超出了本文的范围。让我们假设我们的数据不会超过高数据量的阈值。记住，我们将所有数据转换成一个<strong class="kk iu"> CSV </strong>文件，并将每行记录打印到该文件中。您的文件将保存在系统定义的临时文件夹中。这通常是<strong class="kk iu"> $TMPDIR </strong>。</p><figure class="nb nc nd ne gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nt"><img src="../Images/a5c3315db39e704f7087213f65a9a9bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cKCWGSnSpMPh9HDwCmmhXg.png"/></div></div></figure><p id="269b" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">在这一点上，您可能会认为，假设我们将每个记录写入该文件，这实际上可以在没有阻塞的情况下实现。不幸的是，我们仍然需要<strong class="kk iu"> <em class="lg">引蛇出洞</em> </strong>和<strong class="kk iu"> <em class="lg">接近</em> </strong>我们的作家。同时，另一个解决方案是实现一个订阅者，它将在作业完成后被触发。然而，这样做意味着我们的作业订阅了一个被动的发布者。所有这些技术都可以在这里使用，但这仍然是一个没有任何资源竞争的作业，因此反应性和高性能的范例并不真正适用于这种情况。</p><p id="e7d7" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">然后我们创建一个流。为了将一个文件发送到S3，我们所需要的只是一个给定格式的字节流。我们在这里选择GZIP，但是在S3什么都可以。</p><figure class="nb nc nd ne gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nu"><img src="../Images/a13ef2269d213271ab82fb270616a9e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h7bYsvrPk9Z0ZYkw7M-OqA.png"/></div></div></figure><p id="4b9e" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">还有，我们需要一个桶。我们称我们的桶为“<strong class="kk iu"><em class="lg">stacos-bucke</em></strong>t”。这个特定的存储桶是在演示开始时创建的。我将进一步解释这个桶是如何创建的，但是现在，对我们来说重要的是知道一个不同的过程将创建这个桶。</p><p id="ddd6" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">我们最终获得了流并将文件上传到桶中。</p><figure class="nb nc nd ne gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nv"><img src="../Images/da0bf5ee4df8e9d2ee63baad99cd88a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v4si9XTFrRr2XEzkVi77_A.png"/></div></div></figure><p id="82e8" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">加载过程的第一部分到此结束。我们现在在<strong class="kk iu"> S3 </strong>有了我们的文件，我们准备在另一个任务中下载它，解包并将数据发送到<strong class="kk iu">迪纳摩数据库。</strong></p><h1 id="b3de" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">3.3.迪纳摩DB —加载器</h1><figure class="nb nc nd ne gt ju gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/5884a659678c2126eb62a9ca25c294e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1006/format:webp/1*fapp-H8DKCbDgKJdmklgaw.png"/></div><figcaption class="nf ng gj gh gi nh ni bd b be z dk translated">Dynamo数据库加载程序的序列图</figcaption></figure><p id="9d33" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">为了能够可视化数据，将数据加载到数据库中至关重要。当这样做时，根据我们的算法，我们只需下载所需的文件。我们需要哪些文件？对于我们这个简单的例子，我们把它简化了，所以我们需要所有的。这是通过代码列出它们的一种方式:</p><figure class="nb nc nd ne gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nx"><img src="../Images/957b842da86e8714319ded7ebe6bb541.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*64ZAzKq_PsNuQIQAkPJyMg.png"/></div></div></figure><p id="fcd1" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">有了完整的文件列表，我们就可以遍历所有的文件</p><figure class="nb nc nd ne gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ny"><img src="../Images/eebf33077a53785fea108aed9fe3c947.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YxulVYnajJDQAWha4cmT9w.png"/></div></div></figure><p id="3769" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">对于每次迭代，我们得到一个<strong class="kk iu"> <em class="lg">字节数组</em> </strong>。这只代表我们文件的内容。我们给它一个名字，从它们中读取，并写到<strong class="kk iu"> DynamoDB: </strong></p><figure class="nb nc nd ne gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nz"><img src="../Images/cf5cb5ff521c0e74368cb4d4f41d35ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z5WRVdi_rzcwi7G02Vh0uA.png"/></div></div></figure><p id="b98c" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">您会注意到，在整个代码中，我使用了几个扩展函数，以便在具有相同数据信息的不同类型的对象之间进行转换。在这种情况下，我们希望将CSV文件中接收到的数据转换成一个映射，该映射作为参数被接受给<strong class="kk iu"> DynamoDB </strong>客户端:</p><figure class="nb nc nd ne gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nq"><img src="../Images/431f431376008bccb2c1ca3333703e9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EayjKpfFLsoklDz8Ja7NCQ.png"/></div></div></figure><p id="b585" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">我们进行的转换基于我们如何定义表。在本演示的代码中，该表是以编程方式创建的:</p><figure class="nb nc nd ne gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oa"><img src="../Images/7a5c886e0a84a6b009a9cad7b8f4e0f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3ReIUOMXoiMcRNiOaYi_oA.png"/></div></div></figure><p id="1b35" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">在<strong class="kk iu"> DynamoDB </strong>中创建表格并不简单。对于SQL数据库和许多<strong class="kk iu"> NoSQL </strong>数据库，我们已经习惯了先创建表，然后在开发过程中进行修改的想法。如前所述，DynamoDB 并不真正适合RDBC<strong class="kk iu">连接和SQL </strong>数据库。在这一点上，我们需要知道我们将如何提供我们的数据。正如我们将在本文中进一步看到的，DynamoDB的工作方式值得单独写一篇文章。<strong class="kk iu"> DynamoDB </strong>允许分区配置，查询的工作方式非常不同，我们需要在潜在的查询之前定义我们的模式键，如果我们做得正确，我们将得到一个性能非常好的数据库。然而，这也是本文的题外话。现在让我们记住这样一个想法，我们的模式只有一个键<strong class="kk iu"> ID，</strong>，并且这个键的类型是<strong class="kk iu"><em class="lg">Scala attributetype。</em>年代</strong>。正是在这个ID的基础上，我们将能够进行分页。</p><h1 id="1d06" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">3.4.走向反应式分页</h1><figure class="nb nc nd ne gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ob"><img src="../Images/5e5c4eb53ad3bf655c4f31bfad424672.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AYml_TPtwdFma7i7KxX7JQ.png"/></div></div><figcaption class="nf ng gj gh gi nh ni bd b be z dk translated">演示中所有可能的用户交互案例</figcaption></figure><p id="46ba" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">在这个项目中，我创建了一个看似与本文无关的模块，名为:<strong class="kk iu">邮票和硬币阻塞服务</strong>。在本模块中，我们将通过传统的<strong class="kk iu"> JPA </strong>存储库访问数据库:</p><figure class="nb nc nd ne gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nq"><img src="../Images/82760e38a49fc202f3ed5f75c8705c60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UpH4khWx2wmrPaA5PIjerg.png"/></div></div></figure><p id="e9a1" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">如您所见，通过使用<strong class="kk iu"> Pageable </strong>参数，然后使用<strong class="kk iu"> Page </strong>作为返回参数，可以非常容易地实现分页。有了这些对象，我们可以不断地发送分页的结果请求，并不断地交换当前页面的值、页面的大小以及我们想要过滤的内容。我们也在过滤表中的所有元素。</p><p id="81ad" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">当试图将此翻译到<strong class="kk iu">反应库</strong>并且仍然针对同一个<strong class="kk iu"> PostgreSQL </strong>数据库时，我们可能会开始质疑return参数。<strong class="kk iu">反应式编程</strong>，无论是用协程还是用<strong class="kk iu"> WebFlux </strong>实现，在处理多个返回行时都有很大不同。我们不再返回行。相反，我们返回一个<strong class="kk iu"> Flux </strong>或一个<strong class="kk iu"> Flow </strong>，它们在稍后被处理，从而使服务对更多的请求可用，因此更加<strong class="kk iu">被动</strong>。然而，我们可以使用Pageable still返回与一个页面相关的结果。我们仍然失去了一个宝贵的结果，这就是找到的<strong class="kk iu"> <em class="lg">总行数</em> </strong>:</p><figure class="nb nc nd ne gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oc"><img src="../Images/1990424a4bfb0699e944a05b8ad8284d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fOK1OrhEOXtIgQxX_u8uGQ.png"/></div></div></figure><p id="6e7f" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">所以在这种情况下，我发现让应用程序知道有多少页面的唯一方法是执行另一个计数请求。这个请求只是基于我们最初请求的一个计数。从上面可以看出，两者都请求返回发布者，这意味着两者都以一种被动的方式工作。</p><p id="2211" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">这意味着我实际上是在执行另一个查询，只是为了根据我的搜索标准检查数据库中有多少元素。但是，以这种方式执行分页有一些改进。返回的计数是一个<strong class="kk iu">单声道</strong>，过滤后的结果作为<strong class="kk iu">通量</strong>返回。这些对反应式协同例程实现的争夺者也使得应用程序具有难以置信的反应性。然而，如果我们想使用反应式存储库进行分页等操作，它们似乎不是现成的。我们仍然可以使用<strong class="kk iu"> Pageable </strong>，但是对于一个网站来说。我们确实必须执行两个独立的请求，但是它们没有阻塞，因此有理由期望我们的应用程序变得更有性能。我的观点是，变得被动也意味着变得不那么琐碎。我们越是提升技术来让应用程序尽可能反应性地工作，似乎我们也增加了复杂性。在我继续之前，我只想说这样很好。我们当然不需要把事情复杂化，但是我们所理解的复杂性确实因人而异。我个人更愿意把这种“复杂性”解释为只是一些我们不习惯的新事物。但是继续:</p><p id="51b9" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">同样重要的是，当从一个针对<strong class="kk iu"> PostgreSQL </strong>的反应式存储库转移到一个针对<strong class="kk iu"> DynamoDB </strong>的<strong class="kk iu"> DynamoDB </strong>存储库时会发生什么。例如，保存操作(<strong class="kk iu">创建和更新</strong>)是这样实现的:</p><figure class="nb nc nd ne gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi od"><img src="../Images/565916379369ab290239a37c0eb4c2d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6Cjopq28iknHcbZXWQ3TZQ.png"/></div></div></figure><p id="af26" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">正如我们之前看到的，保存请求的有效负载是键<strong class="kk iu">字符串</strong>值<strong class="kk iu">属性值</strong>的<strong class="kk iu">映射</strong>。这又从客户端使用<strong class="kk iu"> <em class="lg"> putItem </em> </strong>和<strong class="kk iu"><em class="lg">putItem request</em></strong>来执行。让我们思考一下这个问题。每一个对<strong class="kk iu"> <em class="lg"> Localstack </em> </strong>的请求，以及对<strong class="kk iu"> <em class="lg"> AWS </em> </strong>的请求，似乎都依赖于同一个常量构建器模式。<strong class="kk iu"> <em class="lg"> Async </em> </strong>实现使用<strong class="kk iu"> <em class="lg"> Futures </em> </strong>，我们可以很容易地适应<strong class="kk iu"> WebFlux </strong>框架，并且我们可以对它们做出反应请求。这就是为什么我们将<strong class="kk iu">单声道</strong>视为<strong class="kk iu"><em class="lg"/></strong>的包装器。此外，我们应该在这一点上看到，从<strong class="kk iu"><em class="lg"/></strong>的角度来看，<strong class="kk iu"><em class="lg">dynamoDBAsyncClient</em></strong>的工作方式非常相似，正如我们之前看到的<strong class="kk iu"><em class="lg">s3AsyncClient</em></strong>一样。事实上，我们已经在阅读器和加载器中使用了这样的方法。</p><p id="b198" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">这只是对<strong class="kk iu"> <em class="lg">保存</em> </strong>方法如何工作的简短介绍。我们仍然希望将这一点与我们在<strong class="kk iu"> <em class="lg"> DynamodDB </em> </strong>中如何做到这一点进行比较。因为我们本质上只是在做这方面的速成课程，并没有深入到如何搜索、扫描和查询数据的细节，这就是我在这里可以做分页的方法。</p><figure class="nb nc nd ne gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nq"><img src="../Images/44fff8397f55fa94327a71e03e0d319c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VALI66XmYPw9i7EQ4tKaAQ.png"/></div></div></figure><p id="7d16" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">我们可以看到，我们实际上并没有发出传统意义上的分页请求。我们在这里做的是在<strong class="kk iu"> SQL </strong>查询中使用类似于<strong class="kk iu">限制</strong>的东西。我们也没有使用<strong class="kk iu">查询</strong>。<strong class="kk iu">查询</strong>和<strong class="kk iu">扫描</strong>在<strong class="kk iu"> DynamoDB </strong>中是不同的东西。这里的语义非常重要，因为当我们谈论<strong class="kk iu"> DynamoDB </strong>中的<strong class="kk iu">查询</strong>时，我们谈论的是访问和搜索分区中的数据。当我们谈论<strong class="kk iu">扫描</strong>时，我们谈论的是在整个表空间中访问和搜索数据。这意味着在编程层面上，我们可以得到相同的结果，但是执行<strong class="kk iu">扫描</strong>通常比执行<strong class="kk iu">查询</strong>要昂贵得多。我们已经在上面讨论过，云服务器上更多的工作负载意味着更多的计费成本。因此，尽管我坚持避免使用扫描，但我们仍将在本例中使用它来理解为什么我们仅通过创建一个包含所有默认和最小配置的表并仅使用<strong class="kk iu">扫描</strong>而受到如此限制。</p><p id="41cb" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">由于已经提到的原因，我决定在本文中不使用<strong class="kk iu">查询</strong>，我想出了一个解决方案。如果我们只是在我们想要开始我们的页面之前对记录进行第一次扫描会怎么样？然后我们可以像以前一样用<strong class="kk iu">限制</strong>操作限制结果。我们找到了。效率非常低，但在<strong class="kk iu"> DynamoDB </strong>中可以分页:</p><figure class="nb nc nd ne gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oe"><img src="../Images/e941c1f4c3154fc6a327df8045596c6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zblVcafz3D3AGp5Ql2xyKQ.png"/></div></div></figure><p id="8afc" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">不管效率有多低，我们得到了一个我想在这里讨论的概念。还记得我们在上面定义的<strong class="kk iu">模式键</strong>吗？嗯，这个<strong class="kk iu">键，</strong>又名<strong class="kk iu"> ID，</strong>就是我们用来定义<strong class="kk iu"><em class="lg">exclusive startkey</em></strong>的。专属启动键是什么？这是我们开始查询的地方。在这种情况下，我们将从初始查询的最后一个结果元素开始。通过将这些方法链接在一起，并使用<strong class="kk iu"> ID </strong>作为关键字，我们实际上是为每次页码大于1时创建两个查询。</p><p id="bb30" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">我们不需要对第一页进行两次查询，但是使用<strong class="kk iu">扫描</strong>，我们没有太多其他选择。您将在演示中看到这是可行的。然而，我们正在进行两个查询。为了做到这一点，我们必须深入到<strong class="kk iu"><em class="lg">【dynamo db】</em></strong>中的<strong class="kk iu">查询</strong>的世界中，这是一个与本文非常不相干的主题。</p><p id="124d" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">从<strong class="kk iu"> JPA </strong>，穿越<strong class="kk iu">反应</strong> <strong class="kk iu"> CRUD </strong>仓库，最后到达<strong class="kk iu"> DynamoDB </strong>同样令人瞩目的是，技术的发展是如此美丽和伟大。我们的<strong class="kk iu"> DynamoDB </strong>解决方案，尽管在获取数据方面并不完美，但它仍然是反应式的。我们还在用<strong class="kk iu"> Future的</strong>，我们还在用Flux。我们现在使用3个查询，但还没有过滤器。</p><h1 id="2e89" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">4.开始演示</h1><p id="a2a1" class="pw-post-body-paragraph ki kj it kk b kl mg kn ko kp mh kr ks kt mi kv kw kx mj kz la lb mk ld le lf im bi translated">我构建了一个应用程序，一个小的GUI，只是为了测试两个前端面向后端的Spring Boot服务。我已经创建了一个<strong class="kk iu"> Makefile </strong>,它包含了许多执行测试、构建、清理和启动容器的重要命令。我用它来保存对重要命令的引用，同时也使事情变得简单一些。</p><p id="2c78" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">说到这里，让我们用下面的命令一次启动所有的东西:</p><pre class="nb nc nd ne gt of nn og oh aw oi bi"><span id="d881" class="oj lj it nn b gy ok ol l om on">make docker-clean-build-start</span></pre><p id="620b" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">假设一切顺利，您应该在<a class="ae lh" href="http://localhost:8080" rel="noopener ugc nofollow" target="_blank"> http://localhost:8080 </a>上看到这个屏幕:</p><figure class="nb nc nd ne gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oo"><img src="../Images/bac48525ebe071061d23f7bba91c6b49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*98FH0zdjOZ1kM1S9kSoC1A.png"/></div></div><figcaption class="nf ng gj gh gi nh ni bd b be z dk translated">StaCo应用程序GUI</figcaption></figure><p id="e065" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">如果您使用<strong class="kk iu"> admin </strong> / <strong class="kk iu"> admin </strong>登录，并记住这是在参数存储中配置的，您将进入反应式保护应用程序。这个应用程序以一种被动的方式直接通过R2DBC访问Postgres。</p><p id="748e" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">一旦你进入，你会看到这个屏幕</p><figure class="nb nc nd ne gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi op"><img src="../Images/462afba827ae3a0729f064066ac8431c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MzKE8y8WUgAWC21LixjcKw.png"/></div></div><figcaption class="nf ng gj gh gi nh ni bd b be z dk translated">StaCo应用程序对PostgreSQL的被动访问</figcaption></figure><p id="92f2" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">您可以在这里测试我们的过滤器。这就是我们在讨论分页时提到的过滤器:</p><figure class="nb nc nd ne gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oq"><img src="../Images/1a7ff64112c7b449fdab3ea5314dce22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H5Nh-Z_obJCljo7089Uxyw.png"/></div></div><figcaption class="nf ng gj gh gi nh ni bd b be z dk translated">StaCo应用程序过滤了对PostgreSQL的被动访问</figcaption></figure><p id="9da7" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">如果您使用logout按钮返回主屏幕，只需点击Go To DynamoDB，您将看到以下屏幕:</p><figure class="nb nc nd ne gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi or"><img src="../Images/0e8c3143436aff472699cc10d87322ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XRbA2emYak6U-Iotlws4bQ.png"/></div></div><figcaption class="nf ng gj gh gi nh ni bd b be z dk translated">StaCo应用程序过滤对DynamoDB的反应式访问</figcaption></figure><p id="6bae" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">正如我们之前讨论过的，没有过滤器。然而，分页有一种可能的实现方式。这是用我们之前讨论过的算法完成的。</p><p id="e4a2" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">如果您想观看演示并检查我是如何启动容器的，我在YouTube上制作了一个视频，演示了为本文创建的应用程序:</p><figure class="nb nc nd ne gt ju"><div class="bz fp l di"><div class="os ot l"/></div><figcaption class="nf ng gj gh gi nh ni bd b be z dk translated">使用Localstack和Reactive Kotlin学习AWS演示——邮票和硬币实现</figcaption></figure><h1 id="264b" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">5.发出AWS命令</h1><p id="2b20" class="pw-post-body-paragraph ki kj it kk b kl mg kn ko kp mh kr ks kt mi kv kw kx mj kz la lb mk ld le lf im bi translated">如果你有兴趣针对<strong class="kk iu"> Localstack </strong>尝试AWS的命令行，首先需要设置环境变量:<strong class="kk iu"> AWS_ACCESS_KEY_ID </strong>、<strong class="kk iu"> AWS_SECRET_ACCESS_KEY、</strong>和<strong class="kk iu"> AWS_DEFAULT_REGION </strong>。我为此编写了一个脚本，并将它放在项目根目录下的<strong class="kk iu"> bash </strong>文件夹中。</p><p id="e365" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">如果您使用以下命令运行该脚本:</p><pre class="nb nc nd ne gt of nn og oh aw oi bi"><span id="d28b" class="oj lj it nn b gy ok ol l om on">. ./bash/docker-setup.sh</span></pre><p id="cbc0" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">您将拥有所有需要配置的变量。</p><p id="faa8" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">现在，我们可以在运行<strong class="kk iu"> Localstack </strong>的情况下练习下面的命令列表。记住<strong class="kk iu"> Localstack </strong>是在<strong class="kk iu"> Localhost </strong>上运行的。因为我们不需要运行所有的服务来测试<strong class="kk iu"> Localstack </strong>，所以请从根目录运行:</p><pre class="nb nc nd ne gt of nn og oh aw oi bi"><span id="fe66" class="oj lj it nn b gy ok ol l om on">make docker-localstack</span></pre><p id="85c5" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">或者，如果您喜欢手动启动它，您可以这样做:</p><pre class="nb nc nd ne gt of nn og oh aw oi bi"><span id="3811" class="oj lj it nn b gy ok ol l om on">docker-compose rm -svf<br/>docker-compose rm localstack<br/>docker-compose up -d --build --remove-orphans localstack</span></pre><p id="0384" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">在运行了<strong class="kk iu"> Localstack </strong>之后，我们可以试着看看我们得到的结果:</p><figure class="nb nc nd ne gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nq"><img src="../Images/b4894527e849969dae9e4db4e58fa3fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uIwT2B-Y9A21Rbexu3g8xg.png"/></div></div></figure><h1 id="83b9" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">6.通过Web REST服务发送图像</h1><p id="c692" class="pw-post-body-paragraph ki kj it kk b kl mg kn ko kp mh kr ks kt mi kv kw kx mj kz la lb mk ld le lf im bi translated">我们可以讨论的另一件事是如何在服务背后使用DynamoDB。一种方法是通过REST调用和使用字节流来存储我们的邮票和硬币。通过这种方式，我们可以创建标准的抽象，进而使用AWS提供的抽象。我们在<strong class="kk iu">邮票和硬币服务</strong>模块中有这个<strong class="kk iu"><em class="lg">rest controller</em></strong>:</p><figure class="nb nc nd ne gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nq"><img src="../Images/4e39b0eaa4e86825deef121c5cb0e316.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xi5TfHtU7UmMZ0l8Z5ERMQ.png"/></div></div></figure><p id="815c" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">在这种情况下，我使用来自我们已经讨论过的<strong class="kk iu"> s3AsyncClient </strong>的<strong class="kk iu"> <em class="lg"> putObject </em> </strong>请求，以一种被动的方式来实现这一点。在<strong class="kk iu"> <em class="lg">邮票和硬币演示</em> </strong>中，我们可以发送一些示例图片:</p><pre class="nb nc nd ne gt of nn og oh aw oi bi"><span id="4e84" class="oj lj it nn b gy ok ol l om on">curl -v -F "image=@stamp-sample.png" http://localhost:8082/api/staco/ls/images/save/$(uuidgen)</span></pre><p id="7c7a" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">然后我们得到这样的回应:</p><pre class="nb nc nd ne gt of nn og oh aw oi bi"><span id="40ed" class="oj lj it nn b gy ok ol l om on">*   Trying ::1:8082...<br/>* Connected to localhost (::1) port 8082 (#0)<br/>&gt; POST /api/staco/ls/images/save/88D0A1B2-561D-46CB-BB7A-A8381437E8E2 HTTP/1.1<br/>&gt; Host: localhost:8082<br/>&gt; User-Agent: curl/7.71.1<br/>&gt; Accept: */*<br/>&gt; Content-Length: 31250<br/>&gt; Content-Type: multipart/form-data; boundary=------------------------0ee837c95bbe60e3<br/>&gt; <br/>* We are completely uploaded and fine<br/>* Mark bundle as not supporting multiuse<br/>&lt; HTTP/1.1 200 <br/>&lt; Content-Length: 0<br/>&lt; Date: Wed, 01 Dec 2021 19:03:43 GMT<br/>&lt; <br/>* Connection #0 to host localhost left intact</span></pre><p id="4560" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">读到这里，似乎我们的图像已经去了S3。现在让我们列出所有容器:</p><pre class="nb nc nd ne gt of nn og oh aw oi bi"><span id="3274" class="oj lj it nn b gy ok ol l om on">{<br/>    "Buckets": [<br/>        {<br/>            "Name": "images",<br/>            "CreationDate": "2021-12-01T18:39:39.000Z"<br/>        },<br/>        {<br/>            "Name": "stacos",<br/>            "CreationDate": "2021-12-01T18:39:39.000Z"<br/>        }<br/>    ],<br/>    "Owner": {<br/>        "DisplayName": "webfile",<br/>        "ID": "bcaf1ffd86f41161ca5fb16fd081034f"<br/>    }<br/>}</span></pre><p id="7727" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">我们可以看到我们有一个<strong class="kk iu">图像</strong>桶。现在让我们列出其中的对象:</p><pre class="nb nc nd ne gt of nn og oh aw oi bi"><span id="66c7" class="oj lj it nn b gy ok ol l om on">aws s3api list-objects --bucket images</span></pre><p id="f719" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">这个桶里的东西是:</p><pre class="nb nc nd ne gt of nn og oh aw oi bi"><span id="71a7" class="oj lj it nn b gy ok ol l om on">{<br/>    "Contents": [<br/>        {<br/>            "Key": "staco-image-88d0a1b2-561d-46cb-bb7a-a8381437e8e2.png",<br/>            "LastModified": "2021-12-01T19:03:43.000Z",<br/>            "ETag": "\"ed8d3bffef907bd61ed0c29c7696deea\"",<br/>            "Size": 31056,<br/>            "StorageClass": "STANDARD",<br/>            "Owner": {<br/>                "DisplayName": "webfile",<br/>                "ID": "75aa57f09aa0c8caeab4f8c24e99d10f8e7faeebf76c078efc7c6caea54ba06a"<br/>            }<br/>        }<br/>    ]<br/>}</span></pre><p id="1433" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">我们的钥匙的名字是<strong class="kk iu">staco-image-88d0a1b2–561d-46cb-bb7a-a8381437e8e2.png</strong>。我们创造了这把钥匙。让我们下载刚刚上传的图片:</p><pre class="nb nc nd ne gt of nn og oh aw oi bi"><span id="64f5" class="oj lj it nn b gy ok ol l om on">aws s3api get-object --bucket images --key staco-image-88d0a1b2-561d-46cb-bb7a-a8381437e8e2.png download.png</span></pre><p id="1c0d" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">回应是:</p><pre class="nb nc nd ne gt of nn og oh aw oi bi"><span id="26a1" class="oj lj it nn b gy ok ol l om on">{<br/>    "AcceptRanges": "bytes",<br/>    "LastModified": "Wed, 01 Dec 2021 19:03:43 GMT",<br/>    "ContentLength": 31056,<br/>    "ETag": "\"ed8d3bffef907bd61ed0c29c7696deea\"",<br/>    "ContentLanguage": "en-US",<br/>    "ContentType": "application/octet-stream",<br/>    "Metadata": {}<br/>}</span></pre><p id="f4f6" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">如果我们打开结果文件，我们会得到:</p><figure class="nb nc nd ne gt ju gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/007e2daf13d7a679139dcfb685be0dc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/format:webp/1*7Y07_--Qe9Ye0MKcdpbe6g.png"/></div></figure><h1 id="2b2d" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">7.结论</h1><p id="ab90" class="pw-post-body-paragraph ki kj it kk b kl mg kn ko kp mh kr ks kt mi kv kw kx mj kz la lb mk ld le lf im bi translated">在本文中，我们已经看到了一些非常简单的方法，可以使用<strong class="kk iu"> Localstack </strong>来模拟<strong class="kk iu"> AWS </strong>云环境。我们只触及了<strong class="kk iu"> S3 </strong>、<strong class="kk iu"> DynamoDB </strong>和<strong class="kk iu">参数库</strong>的表面。对于一个典型的工程师来说，即使到达表面也是一项复杂的任务，他非常熟悉编程语言的工作方式、架构和设计，并且第一次看到<strong class="kk iu">云</strong>。</p><p id="64e3" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">我认为这是因为<strong class="kk iu">云</strong>就在这里，它不会消失。<strong class="kk iu"> AWS </strong>就在这里，可能永远不会消失。在云中工作和学习可能是一种非常有趣的体验，但也非常昂贵。考虑到关于成本和许可的最常见的原因，它也可能是限制性的。在<strong class="kk iu"> DevSecOps </strong>环境中工作，权限总是一个问题。如果你的团队中有角色明确的成员，很可能你会发现自己在请求<strong class="kk iu">系统管理员</strong>授予你在云环境中执行某些任务的权限。在许多情况下，你只是获得临时许可，而许可的速度往往跟不上你的学习进度。</p><p id="8635" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">正如我们所见，这就是<strong class="kk iu"> Localstack </strong>发挥巨大作用的地方。我们没有非常完整的在线<strong class="kk iu"> AWS </strong>的<strong class="kk iu"> GUI </strong>，但是几乎所有我们可以在远程<strong class="kk iu"> AWS </strong>上做的事情，我们也可以在<strong class="kk iu"> Localstack </strong>上做。这给了我们理解<strong class="kk iu"> AWS </strong>的杠杆，犯错误，改正错误，开发和测试新的想法和概念。<strong class="kk iu"> Localstack </strong>对于<strong class="kk iu"> POC </strong> ( <strong class="kk iu">概念验证</strong>)或者<strong class="kk iu"> MVP </strong> ( <strong class="kk iu">最小可行产品</strong>)来说非常棒。它也是进行集成测试的一个极好的工具。在这个项目中开发了相当多的集成测试。他们都使用<a class="ae lh" href="https://www.testcontainers.org/" rel="noopener ugc nofollow" target="_blank">测试容器</a>作为支撑框架。</p><p id="e631" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">我已经把这个应用程序的所有源代码放到了<a class="ae lh" href="https://github.com/jesperancinha/staco-app" rel="noopener ugc nofollow" target="_blank"> GitHub </a></p><p id="fe06" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">我希望你能像我喜欢写这篇文章一样喜欢它。我尽量让它简洁明了，并省略了许多小细节。</p><p id="02ec" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">我很想听听你的想法，所以请在下面留下你的评论。</p><p id="0d49" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">提前感谢阅读！</p><h1 id="b79e" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">8.参考</h1><div class="ov ow gp gr ox oy"><a href="https://www.alexdebrie.com/posts/dynamodb-filter-expressions/" rel="noopener  ugc nofollow" target="_blank"><div class="oz ab fo"><div class="pa ab pb cl cj pc"><h2 class="bd iu gy z fp pd fr fs pe fu fw is bi translated">何时使用(以及何时不使用)DynamoDB过滤器表达式</h2><div class="pf l"><h3 class="bd b gy z fp pd fr fs pe fu fw dk translated">在过去的几年里，我帮助人们设计他们的DynamoDB表。对许多人来说，这是一场忘却…</h3></div><div class="pg l"><p class="bd b dl z fp pd fr fs pe fu fw dk translated">www.alexdebrie.com</p></div></div><div class="ph l"><div class="pi l pj pk pl ph pm jz oy"/></div></div></a></div><div class="ov ow gp gr ox oy"><a href="https://mediatemple.net/blog/cloud-hosting/brief-history-aws/" rel="noopener  ugc nofollow" target="_blank"><div class="oz ab fo"><div class="pa ab pb cl cj pc"><h2 class="bd iu gy z fp pd fr fs pe fu fw is bi translated">AWS简史-媒体圣殿博客</h2><div class="pf l"><h3 class="bd b gy z fp pd fr fs pe fu fw dk translated">有时候，它会让人觉得1200亿美元的云产业是凭空出现的，似乎是在一夜之间。但是亚马逊…</h3></div><div class="pg l"><p class="bd b dl z fp pd fr fs pe fu fw dk translated">mediatemple.net</p></div></div><div class="ph l"><div class="pn l pj pk pl ph pm jz oy"/></div></div></a></div><div class="ov ow gp gr ox oy"><a href="http://jeff-barr.com/2014/08/19/my-first-12-years-at-amazon-dot-com/" rel="noopener  ugc nofollow" target="_blank"><div class="oz ab fo"><div class="pa ab pb cl cj pc"><h2 class="bd iu gy z fp pd fr fs pe fu fw is bi translated">我在Amazon.com的头12年</h2><div class="pf l"><h3 class="bd b gy z fp pd fr fs pe fu fw dk translated">十二年前的今天，我开车来到西雅图，开始在Amazon.com工作。今天似乎是一个很好的时机来告诉…</h3></div><div class="pg l"><p class="bd b dl z fp pd fr fs pe fu fw dk translated">jeff-barr.com</p></div></div><div class="ph l"><div class="po l pj pk pl ph pm jz oy"/></div></div></a></div><div class="ov ow gp gr ox oy"><a href="https://www.scality.com/solved/the-history-of-cloud-computing/" rel="noopener  ugc nofollow" target="_blank"><div class="oz ab fo"><div class="pa ab pb cl cj pc"><h2 class="bd iu gy z fp pd fr fs pe fu fw is bi translated">云计算的历史-已解决</h2><div class="pf l"><h3 class="bd b gy z fp pd fr fs pe fu fw dk translated">我们生活在无处不在的云计算时代。它提供了灵活性、更低的成本和更好的资源访问…</h3></div><div class="pg l"><p class="bd b dl z fp pd fr fs pe fu fw dk translated">www.scality.com</p></div></div><div class="ph l"><div class="pp l pj pk pl ph pm jz oy"/></div></div></a></div><div class="ov ow gp gr ox oy"><a href="https://www.technologyreview.com/2011/10/31/257406/who-coined-cloud-computing/" rel="noopener  ugc nofollow" target="_blank"><div class="oz ab fo"><div class="pa ab pb cl cj pc"><h2 class="bd iu gy z fp pd fr fs pe fu fw is bi translated">谁创造了云计算？</h2><div class="pf l"><h3 class="bd b gy z fp pd fr fs pe fu fw dk translated">云计算是技术领域最热门的词汇之一。它在互联网上出现了4800万次。但是在…</h3></div><div class="pg l"><p class="bd b dl z fp pd fr fs pe fu fw dk translated">www.technologyreview.com</p></div></div><div class="ph l"><div class="pq l pj pk pl ph pm jz oy"/></div></div></a></div><div class="ov ow gp gr ox oy"><a href="https://www.dynamicsonline.nl/erp-software/wat-is-on-premise-en-wat-is-de-cloud/" rel="noopener  ugc nofollow" target="_blank"><div class="oz ab fo"><div class="pa ab pb cl cj pc"><h2 class="bd iu gy z fp pd fr fs pe fu fw is bi translated">Wat是内部部署的云吗？|动态在线</h2><div class="pf l"><h3 class="bd b gy z fp pd fr fs pe fu fw dk translated">我想要一个ERP系统应用程序，我想在云的前提下…</h3></div><div class="pg l"><p class="bd b dl z fp pd fr fs pe fu fw dk translated">www.dynamicsonline.nl</p></div></div><div class="ph l"><div class="pr l pj pk pl ph pm jz oy"/></div></div></a></div></div></div>    
</body>
</html>