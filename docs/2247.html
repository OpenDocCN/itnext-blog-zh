<html>
<head>
<title>Exploring the Mixin pattern → by code ←</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">探索Mixin模式→按代码</h1>
<blockquote>原文：<a href="https://itnext.io/exploring-the-mixin-pattern-by-code-1dbe5e3124eb?source=collection_archive---------5-----------------------#2019-04-23">https://itnext.io/exploring-the-mixin-pattern-by-code-1dbe5e3124eb?source=collection_archive---------5-----------------------#2019-04-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/199cc1b2eb9c58ebb6c8714c298e542b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O39Zn--h8w2vitCFwkv3EA.png"/></div></div></figure><p id="dbea" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">mixin的概念已经在面向对象的语言中使用了很多年，比如JAVA和C#，流行的css预处理程序Sass和vue.js框架也通过让开发人员使用一个显式的API来支持这种模式，那么Mixin是什么呢？我想看一些例子！</p><p id="778e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">根据维基百科的定义:</p><blockquote class="kw"><p id="38fe" class="kx ky iq bd kz la lb lc ld le lf kv dk translated">Mixin编程是<a class="ae lg" href="https://en.wikipedia.org/wiki/Software_development" rel="noopener ugc nofollow" target="_blank">软件开发</a>的一种风格，其中功能单元在一个类中创建，然后与其他类混合。</p></blockquote><p id="f6ea" class="pw-post-body-paragraph jy jz iq ka b kb lh kd ke kf li kh ki kj lj kl km kn lk kp kq kr ll kt ku kv ij bi translated">换句话说:Mixin让我们有了一种行为构成。</p><p id="abb2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我需要一个导航菜单组件的引用时，我真的对mixin实现产生了怀疑。</p><p id="8ea1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">M <a class="ae lg" href="https://github.com/angular/material2" rel="noopener ugc nofollow" target="_blank"> aterial2 </a>通常是我设计infra组件时的第一个参考，我在查看:<a class="ae lg" href="https://github.com/angular/material2/blob/4f755cf10c383b7e26190d5d1f36caa2a08b137f/src/lib/tabs/tab-nav-bar/tab-nav-bar.ts#L75" rel="noopener ugc nofollow" target="_blank"> MatTabNav </a>类代码时注意到了<strong class="ka ir"> _MatTabNavMixinBase </strong>类，所以我在探索该主题时继续深入研究代码。</p><p id="3f77" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们继续阅读维基百科的定义:</p><blockquote class="kw"><p id="652b" class="kx ky iq bd kz la lb lc ld le lf kv dk translated">mixin类充当父类，包含所需的功能。一个<a class="ae lg" href="https://en.wikipedia.org/wiki/Subclass_(computer_science)" rel="noopener ugc nofollow" target="_blank">子类</a>可以继承或简单地重用这个功能，但不是作为一种专门化的手段。通常，mixin会将期望的功能导出到一个<a class="ae lg" href="https://en.wikipedia.org/wiki/Subclass_(computer_science)" rel="noopener ugc nofollow" target="_blank">子类</a>，而不会创建一个严格的、单一的“是一个”关系。</p></blockquote><p id="9800" class="pw-post-body-paragraph jy jz iq ka b kb lh kd ke kf li kh ki kj lj kl km kn lk kp kq kr ll kt ku kv ij bi translated">我不能真正完全理解一个概念，直到我开始编码，所以下面是我对mixin的实现，很大程度上受有角材料的启发:</p><figure class="lm ln lo lp gt jr"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="9e34" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们看看我的实现是否符合维基百科的定义:</p><p id="fcae" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面的函数创建了<strong class="ka ir"> mixin类</strong>:</p><pre class="lm ln lo lp gt ls lt lu lv aw lw bi"><span id="6b85" class="lx ly iq lt b gy lz ma l mb mc"><strong class="lt ir">const </strong><em class="md">mixinRedAlert </em>= &lt;T <strong class="lt ir">extends </strong>Constructor&lt;<strong class="lt ir">any</strong>&gt;&gt;(base: T) : T  =&gt; {<br/>   <strong class="lt ir">return class extends </strong>base {<br/><br/>      <strong class="lt ir">constructor</strong>(...args: <strong class="lt ir">any</strong>[]) {<br/>         <strong class="lt ir">super</strong>(...args);<br/>      }<br/><br/>      <strong class="lt ir">public </strong>addRedClassToEl(element, c) {<br/>         element.<strong class="lt ir">classList</strong>.add(c)<br/>      }<br/>      <strong class="lt ir">public </strong>removeRedClassToEl(element, c) {<br/>         element.<strong class="lt ir">classList</strong>.remove(c)<br/>      }<br/>   }<br/>}</span></pre><p id="eba3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如我们所看到的，返回的类将包含混合功能。</p><p id="3743" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我将使用<strong class="ka ir"><em class="md">mixinRedAlert</em></strong>函数util来创建mixin类，该类也将具有<strong class="ka ir"> classB </strong>功能。</p><pre class="lm ln lo lp gt ls lt lu lv aw lw bi"><span id="7618" class="lx ly iq lt b gy lz ma l mb mc"><strong class="lt ir">class </strong>classB {<br/>   <strong class="lt ir">constructor</strong>() {}<br/><br/>   <strong class="lt ir">private thing </strong>= <strong class="lt ir">'something'</strong>;<br/><br/>   <strong class="lt ir">public </strong>doSomething() {<br/>      <strong class="lt ir">return this</strong>.<strong class="lt ir">thing</strong>;<br/>   }<br/>}</span><span id="5689" class="lx ly iq lt b gy me ma l mb mc"><strong class="lt ir">const </strong>MixedSomething: GeneralCtor &amp; <strong class="lt ir">typeof </strong>classB = mixinRedAlert(classB);</span></pre><p id="c5e8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我将使用MixedSomething类作为<strong class="ka ir"> classA </strong>父类，我们可以看到它重用了<strong class="ka ir"> classB </strong> doSomething功能，而实际上并不是<strong class="ka ir"> classB的类型！</strong></p><pre class="lm ln lo lp gt ls lt lu lv aw lw bi"><span id="655b" class="lx ly iq lt b gy lz ma l mb mc"><strong class="lt ir">class </strong>classA <strong class="lt ir">extends </strong>MixedSomething {<br/>   <strong class="lt ir">constructor</strong>() {<br/>      <strong class="lt ir">super</strong>();<br/>   }<br/><br/>   <strong class="lt ir">public </strong>useMixinFn() {<br/>      <strong class="lt ir">return this</strong>.doSomething();<br/>   }<br/>}</span></pre><p id="5ebb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如我们所见，classA实例可以访问所有涉及类的公共方法:</p><pre class="lm ln lo lp gt ls lt lu lv aw lw bi"><span id="9fe1" class="lx ly iq lt b gy lz ma l mb mc"><strong class="lt ir">const </strong>instance = <strong class="lt ir">new </strong>classA;<br/><br/>instance.addRedClassToEl(firstDiv, <strong class="lt ir">'alert'</strong>);<br/>instance.addRedClassToEl(secDiv, <strong class="lt ir">'border'</strong>);<br/>instance.doSomething(); <em class="md"><br/></em>instance.useMixinFn();</span></pre><p id="9893" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一般来说，理解与Javascript相关的两个事实是很重要的:</p><ol class=""><li id="2f9d" class="mf mg iq ka b kb kc kf kg kj mh kn mi kr mj kv mk ml mm mn bi translated">class关键字只是语法上的修饰，本质上它只是一个构造函数和原型链接的使用。</li><li id="c256" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated">Mixin类不会持有classB功能的实际“副本”,它持有指向其父类(原型)的链接，父类持有对其父类的引用，依此类推，直到指向null。(继续读取<a class="ae lg" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain" rel="noopener ugc nofollow" target="_blank"> mdn </a>上的原型链)。</li></ol><p id="6a6d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此外，这里有一个使用Angular的mixin示例，它只是用于概念演示——我不建议在实际应用中使用它(UI操作应该通过指令来完成..)但是继续玩代码活模式:)。</p><figure class="lm ln lo lp gt jr"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="9127" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，在这篇文章的结尾，我想说:保持务实，每项工作都有合适的工具，想出最简单的可重用解决方案，并学习更多的技术/模式，以便将来你可以“拿出来”)。</p><p id="b03e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">参考一篇我非常喜欢的关于这个话题的帖子:</p><div class="mt mu gp gr mv mw"><a href="https://medium.com/javascript-scene/functional-mixins-composing-software-ffb66d5e731c" rel="noopener follow" target="_blank"><div class="mx ab fo"><div class="my ab mz cl cj na"><h2 class="bd ir gy z fp nb fr fs nc fu fw ip bi translated">功能混合蛋白</h2><div class="nd l"><h3 class="bd b gy z fp nb fr fs nc fu fw dk translated">编写软件</h3></div><div class="ne l"><p class="bd b dl z fp nb fr fs nc fu fw dk translated">medium.com</p></div></div><div class="nf l"><div class="ng l nh ni nj nf nk jw mw"/></div></div></a></div><p id="01f6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">干杯，</p><p id="a2c0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">利伦。</p></div></div>    
</body>
</html>