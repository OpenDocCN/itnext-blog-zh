<html>
<head>
<title>Kubernetes OWASP Top 10: Insecure Workload Configurations</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes OWASP十大:不安全的工作负载配置</h1>
<blockquote>原文：<a href="https://itnext.io/kubernetes-owasp-top-10-insecure-workload-configurations-60818f0c68db?source=collection_archive---------1-----------------------#2022-08-25">https://itnext.io/kubernetes-owasp-top-10-insecure-workload-configurations-60818f0c68db?source=collection_archive---------1-----------------------#2022-08-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="c689" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">继<a class="ae kl" href="https://medium.com/@scotta01/kubernetes-owasp-top-10-intro-73943be7add2" rel="noopener">关于前10位</a>的概述之后，这是该系列的第一篇，深入探讨了所带来的风险以及减轻风险的方法的一些细节。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/e31f343053c79f6a71dbc64b431f7f7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Aw3ssZDi0d10kilF"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">安托万·佩蒂特维尔在<a class="ae kl" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="d678" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">不安全的工作负载配置</h1><p id="c546" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">首先，不安全的工作负载配置意味着什么？Kubernetes具有极强的可扩展性，在拟定清单时可以设置许多设置。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mf mg l"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">示例部署清单</figcaption></figure><p id="ff27" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这个例子中，连同许多教程和开源项目，它没有解决一些与运行容器相关的更常见的安全风险。securityContext类型，可以在pod级别设置(并应用于pod中的所有容器)，也可以在单个容器级别设置(包括Init和临时容器)。</p><h1 id="50fa" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">安全上下文</h1><p id="7dcd" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">正如您在这个代码示例中看到的，有许多安全设置可以在pod和contaier级别设置。值得注意的是，同时在PodSecurityContext和SecurityContext(容器级别)上设置的值，如果在两个地方都设置，则容器级别将优先，但是，如果在一个地方设置一个设置，而在另一个地方设置另一个设置，则它们都将生效。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="caf4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我不会介绍每一种设置，但会介绍一些更常见的设置，并解释每种设置试图解决的风险。</p><h2 id="5bff" class="mh ld iq bd le mi mj dn li mk ml dp lm jy mm mn lq kc mo mp lu kg mq mr ly ms bi translated">特许的</h2><p id="cfda" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">为了理解这个设置，我们应该先快速入门/提醒一下<a class="ae kl" href="https://man7.org/linux/man-pages/man7/capabilities.7.html" rel="noopener ugc nofollow" target="_blank"> Linux功能</a>。这些是用户可以对Linux主机的内核采取的特权操作的列表。传统上，root (UID 0)是超级用户，能够运行任何命令，而无需检查权限。这些权限被划分到一个功能列表中，这样就可以向非root用户授予更细粒度的访问权限，从而减少了以root用户身份运行进程的需要。特权允许访问主机上的这些内核功能。</p><p id="4839" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">简而言之，拥有特权的容器可以访问底层主机资源和内核，这打破了容器隔离。一个进程实际上很少需要完全特权访问，并且通常不需要特权能力。同样值得注意的是，特权的使用规避了其他安全控制，比如seccomp和apparmor提供的安全控制，或者内置的容器运行时限制。</p><pre class="kn ko kp kq gt mt mu mv mw aw mx bi"><span id="b5f8" class="mh ld iq mu b gy my mz l na nb">privileged: false</span></pre><h2 id="dc1d" class="mh ld iq bd le mi mj dn li mk ml dp lm jy mm mn lq kc mo mp lu kg mq mr ly ms bi translated">能力</h2><p id="e27a" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">如果您确定一个容器确实需要一个特定的syscall，那么您可以设置一个特定的能力，而不是授予完全的特权。</p><p id="ba3d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">nginx web服务器就是一个很好的例子。默认情况下，此映像以root身份运行，因为它需要NET_BIND功能才能绑定到低于1024的端口，即80和443。然而，这使得容器运行在一个超特权状态，能够在容器环境中执行系统调用。我们可以使用capabilities标记来删除所有功能，只授予绝对需要的功能。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mf mg l"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">具有功能集的nginx部署</figcaption></figure><h2 id="84f6" class="mh ld iq bd le mi mj dn li mk ml dp lm jy mm mn lq kc mo mp lu kg mq mr ly ms bi translated">allowPrivilegeEscalation</h2><p id="16c9" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">为了继续使用nginx示例，我们可以进一步改进它。当一个容器启动时，它由一个父进程产生，该父进程具有在部署时授予的权限。在运行时，可以提升子进程的特权，使其比父进程的特权更高。</p><p id="6387" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我将使用sudo的linux命令来实际说明这意味着什么，这是过于简化了，但只是为了说明。</p><p id="d19a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我们打开一个终端时，我们会产生一个进程，通常是一个shell，比如sh、bash、zsh等等。这成为父进程，当我们与外壳交互时，执行二进制文件，如ls、cat、cp等。这些是从父进程派生出来的chid进程，拥有第一个打开外壳的用户的特权。如果用户需要比正常情况下更多的访问权限，通常会利用sudo(<strong class="jp ir">s</strong>super<strong class="jp ir">u</strong>ser<strong class="jp ir">do</strong>)的便利在短时间内将权限提升到root用户。当用户在运行sudo之后在shell中运行一个命令时，他们现在拥有的特权比从中派生命令的父进程更大。</p><p id="611d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">设置allowprivilegescalation:false，阻止这类行为在我们的容器中发生，给它们分配可预测的权限，而不是更多。</p><h2 id="e633" class="mh ld iq bd le mi mj dn li mk ml dp lm jy mm mn lq kc mo mp lu kg mq mr ly ms bi translated"><strong class="ak">运行用户/运行组</strong></h2><p id="3dcf" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">这和罐头上说的差不多。您正在做出决策，以确保容器流程使用的是什么用户或组，并且在部署之前已经定义。如果我们从头开始构建映像，这是一个简单的过程，因为我们可以完全控制堆栈，并且知道哪个用户被配置为运行以及在哪个组中运行。UID和GID可以在安全策略中定义，确保容器不能作为不同的用户或组启动。</p><pre class="kn ko kp kq gt mt mu mv mw aw mx bi"><span id="e022" class="mh ld iq mu b gy my mz l na nb">runAsUser: 1000<br/>runAsGroup: 1001</span></pre><p id="3656" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是，更有可能的是，将使用源自第三方repo(如Docker Hub)的基本映像。理解你所依赖的任何软件，确保它是安全的，并且如你所期望的那样运行，这是一个很好的实践，但是对于容器，这种努力的一部分是知道容器被配置为以什么用户的身份运行。以下是我们可以检查的方法。</p><p id="9134" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> Dockerfile —用户指令</strong></p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="bab2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> Dockerfile —命令</strong></p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="637e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">从容器内</strong></p><p id="1663" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有时这并不明显，所以通常执行图像并运行whoami、id或查看/etc/passwd来获得线索，这取决于图像中的可用内容。</p><p id="227b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用来自基于阿尔卑斯山的图像的id作为例子。</p><pre class="kn ko kp kq gt mt mu mv mw aw mx bi"><span id="b21d" class="mh ld iq mu b gy my mz l na nb">$ id<br/>uid=101(nginx) gid=101(nginx) groups=101(nginx)</span></pre><p id="497b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">值得注意的是，映像用户在特定映像中可能因标签而异，这通常是由于基本的操作系统约定，因此值得检查。</p><h2 id="b091" class="mh ld iq bd le mi mj dn li mk ml dp lm jy mm mn lq kc mo mp lu kg mq mr ly ms bi translated">runAsNonRoot</h2><p id="98a9" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">与runAsUser结合使用，runAsNonRoot可以确保容器不能以Root用户的身份执行。随着映像提供商强化他们提供的基础映像，使用root的理由越来越少。这有助于防止对Dockerfile文件进行任何试图提升权限的修改，因为如果设置了此设置并且容器以root用户身份执行，容器将无法启动。</p><h2 id="f8c0" class="mh ld iq bd le mi mj dn li mk ml dp lm jy mm mn lq kc mo mp lu kg mq mr ly ms bi translated">readOnlyRootFileSystem文件系统</h2><p id="234c" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">容器存在的一个威胁是攻击者能够改变容器中运行的内容，改变设置和配置文件。通过在数据库或外部安装的卷中使用无状态容器和宿主状态，允许容器文件系统是只读的，以确保正在运行的容器不会被篡改。需要对每种映像类型进行测试，以确保没有任何意外写入尝试导致故障。我以前遇到过这种情况，容器试图写入一个设置文件，而不是在启动时，所以错误被记录下来，所以要确保有一个全面的测试机制。</p><h2 id="43c9" class="mh ld iq bd le mi mj dn li mk ml dp lm jy mm mn lq kc mo mp lu kg mq mr ly ms bi translated">影响</h2><p id="e51c" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">如果这些安全上下文设置中的大部分被违反，则后果是Pod将抛出错误并且无法启动，或者错误将在应用程序中开始记录，其中它不能执行预期的功能。</p><p id="a18c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里，当我启动nginx部署时，容器无法创建</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/aa3618d7b0ead92a6191e43577e1b946.png" data-original-src="https://miro.medium.com/v2/resize:fit:1340/format:webp/1*6CdAfQ66_-baKaxI2tAiCQ.png"/></div></figure><p id="3945" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我在一个失败的pod上运行describe，我们可以看到原因，当安全上下文被设置为以非root身份运行时，容器试图以root身份运行</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi nd"><img src="../Images/6b646f5c3048ae7e9f2d3a7271795746.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wkKEw8YJupmWGrAsfuVEtA.png"/></div></div></figure><pre class="kn ko kp kq gt mt mu mv mw aw mx bi"><span id="3a56" class="mh ld iq mu b gy my mz l na nb">kubelet Error: container has runAsNonRoot and image will run as root</span></pre><h2 id="a8a7" class="mh ld iq bd le mi mj dn li mk ml dp lm jy mm mn lq kc mo mp lu kg mq mr ly ms bi translated">摘要</h2><p id="fe1e" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">这绝不是可用于强化的安全环境的详尽列表，更重要的是，防止安全错误配置的门户部署，但是应该提供一个良好的起点。如果你想更深入地了解，请查看<a class="ae kl" href="https://medium.com/@scotta01/kubernetes-owasp-top-10-insecure-workload-configurations-60818f0c68db" rel="noopener"> Kubernetes关于安全环境的文档</a>或查看<a class="ae kl" href="https://owasp.org/www-project-kubernetes-top-ten/" rel="noopener ugc nofollow" target="_blank"> OWASP Top 10 </a>的其余部分。</p></div></div>    
</body>
</html>