<html>
<head>
<title>Magento PWA Studio: What is UPWARD?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Magento PWA工作室:什么是向上？</h1>
<blockquote>原文：<a href="https://itnext.io/magento-pwa-studio-what-is-upward-acf450fbee3e?source=collection_archive---------2-----------------------#2019-04-08">https://itnext.io/magento-pwa-studio-what-is-upward-acf450fbee3e?source=collection_archive---------2-----------------------#2019-04-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/e2e571cbcd8b29aed05e7ddb0d0d4438.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tIp5uRFxl0k0kyOAoskHIw.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">无关，请忽略…</figcaption></figure><p id="fda0" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在过去的几个月里，Magento一直在开发PWA Studio，简而言之，这是一个工具集，用于在Magento 2商店的基础上构建现代渐进式网络应用。</p><p id="db7d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在很大程度上，这些工具已经被其他项目成功地用于生产中，因此PWA Studio建立在它们之上是有意义的，例如:</p><ul class=""><li id="0875" class="lb lc iq ke b kf kg kj kk kn ld kr le kv lf kz lg lh li lj bi translated"><strong class="ke ir"> Peregrine </strong>:基于<em class="lk"> React </em>的UI组件集合，帮助重用常见功能，如路由、渲染页面、产品、价格等。</li><li id="cb59" class="lb lc iq ke b kf ll kj lm kn ln kr lo kv lp kz lg lh li lj bi translated"><strong class="ke ir"> PWA Buildpack: </strong>构建和布局优化工具，它扩展了<em class="lk"> webpack </em>来帮助配置PWA Studio组件并设置本地开发环境。</li><li id="c295" class="lb lc iq ke b kf ll kj lm kn ln kr lo kv lp kz lg lh li lj bi translated"><strong class="ke ir"> Venia </strong>:使用PWA Studio的库构建的核心店面，它使用<em class="lk"> React </em>、<em class="lk"> Redux </em>、<em class="lk"> GraphQL </em>、<em class="lk"> CSS模块</em>等多种技术作为其堆栈的一部分。</li></ul><p id="9c04" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">然而，有些东西并不像其他东西那样广为人知。<strong class="ke ir">向上</strong>是为PWA工作室建造的，所以大多数人没有听说过它是有道理的，但它是最重要的作品之一，事实上我要说它是将其他一切粘合在一起的东西。</p><p id="133d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">但在谈论它是什么之前，重要的是要知道它为什么被制造出来…</p><h1 id="a45e" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">起初</h1><p id="c01e" class="pw-post-body-paragraph kc kd iq ke b kf mo kh ki kj mp kl km kn mq kp kq kr mr kt ku kv ms kx ky kz ij bi translated">早期版本的Venia storefront在前端使用了大致相同的技术堆栈，但它仍然是作为一个常规的Magento 2主题开发的，这不是一个常见的方法，特别是像<a class="ae la" href="https://github.com/DivanteLtd/vue-storefront" rel="noopener ugc nofollow" target="_blank"> Vue Storefront </a>或<a class="ae la" href="https://github.com/deity-io/falcon" rel="noopener ugc nofollow" target="_blank">神的猎鹰</a>这样的类似项目正在走向一个更无头的方法。</p><p id="f2e1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">去除对Magento的这种硬依赖是有意义的，但是仍然需要一些东西来处理两者之间的通信。当然你可以直接处理Magento的API，但是:</p><ul class=""><li id="bf86" class="lb lc iq ke b kf kg kj kk kn ld kr le kv lf kz lg lh li lj bi translated">如果你不得不使用多个API，而不仅仅是Magento的，你如何组织所有这些不同的端点呢？</li><li id="e057" class="lb lc iq ke b kf ll kj lm kn ln kr lo kv lp kz lg lh li lj bi translated">如果您需要扩展或改进任何核心API，该怎么办？如果您需要替换一些端点，是否很容易做到，而且没有很多副作用？</li><li id="13b3" class="lb lc iq ke b kf ll kj lm kn ln kr lo kv lp kz lg lh li lj bi translated">不特定于Magento的第三方API(社交媒体、运费计算、CMS等)如何？您是否需要创建自定义扩展来与它们交互？</li></ul><p id="e80e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这些问题都是由解决的，它有一个单一的位置，请求被发送到那里，并总是以你期望的方式返回数据。</p><h1 id="f7cd" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">那是什么？</h1><p id="afcd" class="pw-post-body-paragraph kc kd iq ke b kf mo kh ki kj mp kl km kn mq kp kq kr mr kt ku kv ms kx ky kz ij bi translated">简而言之:<strong class="ke ir"> UPWARD </strong>是充当PWA和API之间中间层的服务器，它有多种好处，但对我来说，最主要的好处是它有助于将所有API统一在一个地方，因此您不必跟踪多个端点以及如何访问它们。</p><p id="a0dc" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">也许《T4》的幕后策划人詹姆斯·泽特伦可以更好地解释这一点:</p><figure class="mt mu mv mw gt jr"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="f5ba" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">使<strong class="ke ir"> UPWARD </strong>如此独特的是，它本身不是一个服务器，它实际上是一个<em class="lk">规范</em>，描述了当数据以不同方式被请求时，服务器应该如何响应。就像<em class="lk"> GraphQL </em>是一个规范，像<em class="lk"> Apollo </em>和<em class="lk"> Relay </em>这样的库是这个规范的实现一样，<strong class="ke ir"> UPWARD </strong>已经在<a class="ae la" href="https://github.com/magento-research/pwa-studio/tree/develop/packages/upward-js" rel="noopener ugc nofollow" target="_blank"> NodeJS </a>和<a class="ae la" href="https://github.com/magento-research/upward-php" rel="noopener ugc nofollow" target="_blank"> PHP </a>中正式实现，但是没有理由说它不能在其他技术中实现。</p><p id="db15" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">向上</strong>定义服务器行为的方式是通过使用特殊语法的YAML配置文件。这个文件类似于<em class="lk">。htaccess </em>文件是针对Apache服务器的，它们的工作方式并不完全相同，但是我发现这种比较有助于理解这个概念。</p><p id="aa0c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">尽管<strong class="ke ir"> UPWARD </strong>是为PWA Studio设计的，但它是平台不可知的，因此它可以用于任何需要与服务器交互的东西，甚至不一定是PWA！</p><h1 id="bc79" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">它看起来怎么样？</h1><p id="194b" class="pw-post-body-paragraph kc kd iq ke b kf mo kh ki kj mp kl km kn mq kp kq kr mr kt ku kv ms kx ky kz ij bi translated">与许多通常通过例子更容易理解的事情一样，我将展示一些不使用任何框架的用例，因为这使得解释起来更简单，并且不需要任何特殊的工具，但是您可以很容易地将它们适应您选择的JS风格。</p><h1 id="4e6a" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">1.你好世界</h1><p id="30a2" class="pw-post-body-paragraph kc kd iq ke b kf mo kh ki kj mp kl km kn mq kp kq kr mr kt ku kv ms kx ky kz ij bi translated">让我们从创建一个新的节点服务器并安装所需的依赖项开始，对于这些示例，我将使用<code class="fe mz na nb nc b">yarn</code>,但是如果您愿意，也可以随意使用<code class="fe mz na nb nc b">npm</code>:</p><pre class="mt mu mv mw gt nd nc ne nf aw ng bi"><span id="fc18" class="nh lr iq nc b gy ni nj l nk nl">yarn add @magento/upward-js express</span></pre><p id="1b3f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">UPWARD-JS 是建立在<em class="lk"> express </em>之上的，所以我们需要把它安装成一个对等依赖。</p><p id="d533" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在，让我们向package.json文件中的“scripts”块添加一个命令:</p><pre class="mt mu mv mw gt nd nc ne nf aw ng bi"><span id="6eef" class="nh lr iq nc b gy ni nj l nk nl"><em class="lk">"start"</em>: "node server.js"</span></pre><p id="a947" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这将使用我们现在创建的<em class="lk"> server.js </em>文件启动我们的服务器:</p><figure class="mt mu mv mw gt jr"><div class="bz fp l di"><div class="nm my l"/></div></figure><p id="d870" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这是启动<strong class="ke ir"> UPWARD-JS </strong>服务器最简单的方法之一，我们只需要调用带有几个必需参数的<code class="fe mz na nb nc b">createUpwardServer</code>函数。其中大多数都是不言自明的，我们在这里所做的只是使用端口8000创建和绑定一个新的服务器，为调试启用日志记录，并将路径传递给我们的YAML配置文件。</p><figure class="mt mu mv mw gt jr"><div class="bz fp l di"><div class="nm my l"/></div></figure><p id="7e5e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">正如您所看到的，配置文件相当容易阅读(至少目前如此)，<strong class="ke ir"> UPWARD </strong>要求我们至少指定3个属性:服务器<em class="lk">状态</em> <strong class="ke ir"> </strong>代码、<em class="lk">标题</em>和<em class="lk">主体</em>。在本例中，我们将服务器配置为用200响应代码和正文中的HTML文本“Hello World”来响应所有请求。</p><p id="72bc" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">注意“inline”属性让我们直接在配置文件中将值定义为字符串，这在<strong class="ke ir">向上</strong>规范中被称为<em class="lk">解析器</em>，稍后我们将了解更多。</p><p id="20a0" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在，如果我们运行<code class="fe mz na nb nc b">yarn run start</code>并访问<a class="ae la" href="http://localhost:8000" rel="noopener ugc nofollow" target="_blank"> http://localhost:8000 </a>，我们将能够看到我们努力工作的结果:</p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nn"><img src="../Images/4ecd40d9ecddd0c3ead13565a7a9c0f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cLs_XCYigNf_HAzt6CuUjw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">谁需要快递？</figcaption></figure><p id="fb39" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">因为现在所有的URL都将返回相同的“Hello World”字符串，这很有效，但不是很有用。让我们看看如何在现实世界中制造出能真正帮助我们的东西。</p><h1 id="a374" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">2.代理请求</h1><p id="33e0" class="pw-post-body-paragraph kc kd iq ke b kf mo kh ki kj mp kl km kn mq kp kq kr mr kt ku kv ms kx ky kz ij bi translated">现代web应用中最常见的用例之一是与多个API交互，而不是必须跟踪多个端点，我们可以设置我们的<strong class="ke ir">向上</strong>服务器来代理对不同服务的请求，所以我们只需要向它发送请求(再见CORS问题！).</p><p id="bdd0" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">为此，我们需要在我们的YAML配置中开始使用<em class="lk">解析器</em>,<em class="lk">解析器</em>定义获取数据的方式，它由我们的YAML文件中的属性定义。在前面的例子中，我们使用了“内联解析器”,它返回一个字符串，但是对于更复杂的场景，还有许多其他的解析器。</p><p id="3a2c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">假设我们想要查询两个不同的GraphQL APIs，一个用于检索神奇宝贝数据(必须全部捕获！)和另一个用于国家数据。这是两种不同的服务，但我们希望设置它们，以便我们可以使用:</p><ul class=""><li id="f05d" class="lb lc iq ke b kf kg kj kk kn ld kr le kv lf kz lg lh li lj bi translated"><a class="ae la" href="http://localhost:8000/countries/graphql" rel="noopener ugc nofollow" target="_blank">http://localhost:8000/pokemon/graph QL</a>查询一个神奇宝贝API。</li><li id="7ec0" class="lb lc iq ke b kf ll kj lm kn ln kr lo kv lp kz lg lh li lj bi translated"><a class="ae la" href="http://localhost:8000/countries/graphql" rel="noopener ugc nofollow" target="_blank">http://localhost:8000/countries/graph QL</a>查询国家API。</li></ul><p id="8845" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们需要扩展我们的配置文件，如下所示:</p><figure class="mt mu mv mw gt jr"><div class="bz fp l di"><div class="nm my l"/></div></figure><p id="dbc6" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">啊，事情看起来更有趣，我在文件中添加了一些注释，因为它开始变得更像一个流程图。如你所见，状态、标题和正文不再是硬编码的，而是由一个<code class="fe mz na nb nc b">response</code>属性获取，你可以随意命名，但这意味着<strong class="ke ir">向上</strong>将执行这个<code class="fe mz na nb nc b">response</code>来获取它需要的值。让我们按顺序遵循请求流程:</p><p id="207d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir"> #1响应</strong>:该属性使用了一个“条件解析器”，其工作原理与PHP switch语句相同。在这种情况下，我们检查:</p><ol class=""><li id="90aa" class="lb lc iq ke b kf kg kj kk kn ld kr le kv lf kz no lh li lj bi translated">如果URL匹配“/pokemon/graphql”它将使用<code class="fe mz na nb nc b">pokemonGQL</code>解析器，</li><li id="7306" class="lb lc iq ke b kf ll kj lm kn ln kr lo kv lp kz no lh li lj bi translated">如果与“/countries/graphql”匹配，它将使用<code class="fe mz na nb nc b">countriesGQL</code>解析器，</li><li id="7b78" class="lb lc iq ke b kf ll kj lm kn ln kr lo kv lp kz no lh li lj bi translated">否则使用<code class="fe mz na nb nc b">helloWorld</code>解析器。</li></ol><p id="de0b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir"> #2、#3 pokemonGQL/countriesGQL: </strong>这些属性使用“代理解析器”，它们所做的只是设置请求将被代理到的URL，在我们的例子中，我们使用之前使用的“内联解析器”为我们的第三方服务硬编码URL。</p><p id="f21f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir"> #4 helloWorld: </strong>如果URL与前面的任何一个都不匹配，我们将像以前一样返回相同的“helloWorld”字符串，现在我只是将配置移动到它自己的解析器中。</p><p id="e707" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">因为没有其他需要解决的问题<strong class="ke ir">向上</strong>可以最终返回响应，如果一切顺利，我们应该可以访问我们全新的端点:</p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi np"><img src="../Images/7fbdf6fbe9da62e30cf6231517a5addf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*IgXar79I9etNDfUzNibRZw.gif"/></div></div></figure><h1 id="576f" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">3.呈现HTML</h1><p id="63f4" class="pw-post-body-paragraph kc kd iq ke b kf mo kh ki kj mp kl km kn mq kp kq kr mr kt ku kv ms kx ky kz ij bi translated">显示一个“Hello World”字符串性能很好，但不是很有用，所以让我们稍微修改一下，以显示更复杂的HTML标记，并探索其他类型的解析器。</p><p id="5377" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">默认情况下<strong class="ke ir">向上</strong>支持使用Mustache模板系统，它在功能上非常轻量级和基本，但这通常是一件好事，因为它防止我们在模板中混入太多逻辑。如果你想了解更多，请随意阅读官方回购。</p><p id="0eb5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">因此，让我们使用Mustache来显示一些神奇宝贝数据，而不是“Hello World”字符串，这也将是使用“服务解析器”的好机会:</p><figure class="mt mu mv mw gt jr"><div class="bz fp l di"><div class="nm my l"/></div></figure><p id="37a9" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">配置文件的第一部分是相同的，但是在<code class="fe mz na nb nc b">response</code>属性中情况开始变得不同:</p><p id="0446" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir"> #2、#3 pokemonGQL/countriesGQL: </strong>我没有对GraphQL端点进行硬编码，而是将其改为使用环境变量，它们可以通过向<code class="fe mz na nb nc b">createUpwardServer</code>函数传递一个<code class="fe mz na nb nc b">env</code>参数或使用类似<a class="ae la" href="https://www.npmjs.com/package/dotenv" rel="noopener ugc nofollow" target="_blank"> dotenv </a>的库来设置。在任何情况下，这都有助于使我们的配置更加可定制，因为每个环境可以有不同的值。</p><p id="0405" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir"> #4口袋妖怪:</strong>我们现在将使用“口袋妖怪”属性作为默认响应。为此，我们将使用“模板解析器”来渲染带有小胡子模板的身体，这可以在它自己的文件中设置，我们可以将路径传递给它以使事情更有条理。注意这里的<code class="fe mz na nb nc b">provide</code>属性，它定义了我们模板中可用的数据，反过来它也可以是一个解析器，让我们继续深入兔子洞。</p><p id="3741" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir"> #5 pokemonData: </strong>一旦我们更进一步，这将更有意义，因为现在要理解这是调用另一个“pokemonResult”属性。</p><p id="ebdf" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir"> #6 pokemonResult: </strong>“服务解析器”允许我们从GraphQL服务中获取数据，因此我们将使用它来获取神奇宝贝信息。它将<code class="fe mz na nb nc b">url</code>作为端点，将<code class="fe mz na nb nc b">query</code>作为参数，我们现在硬编码为内联参数，以返回皮卡丘的统计数据。如果我们回到之前的“pokemonData”值<code class="fe mz na nb nc b">pokemonResult.data.pokemon</code>，我们可以看到它映射到我们从GraphQL查询中得到的结果:</p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nq"><img src="../Images/e6bcb4fd2bcd0276dfa2ecf15740bb8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BEyOhCUTBoyIdysScEwkAw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">GraphQL响应数据</figcaption></figure><p id="c2ce" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这意味着来自<code class="fe mz na nb nc b">pokemon</code>节点的所有数据现在都可以在我们的Mustache模板中获得:</p><figure class="mt mu mv mw gt jr"><div class="bz fp l di"><div class="nm my l"/></div></figure><p id="c3a7" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这对于服务器端呈现非常有用，一旦执行完所有解析器，内容将从服务器发送。现在，如果我们去我们的<strong class="ke ir">向上</strong>服务器中的任何URL(除了代理的GraphQL服务器),我们应该会看到皮卡丘惊人的统计数据:</p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nr"><img src="../Images/1d22992f827664f33dc010a7d6d8331e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rwp5WEEqu_EZKhTElmUafA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">小胡子模板渲染</figcaption></figure><h1 id="ac20" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">4.使用变量</h1><p id="3000" class="pw-post-body-paragraph kc kd iq ke b kf mo kh ki kj mp kl km kn mq kp kq kr mr kt ku kv ms kx ky kz ij bi translated">如果能够使用URL通过名称获取特定的神奇宝贝统计数据就好了，所以我们就这么做吧。我们将进一步清理配置文件，使其更易于阅读，并向其中添加一些解析器:</p><figure class="mt mu mv mw gt jr"><div class="bz fp l di"><div class="nm my l"/></div></figure><p id="2e63" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">除了一些调整和添加之外，配置基本相同:</p><p id="1829" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir"> #1响应:</strong>这里有一个额外的条件检查，看看我们请求的是favicon还是CSS文件，对于这两种情况，我们都将使用“静态解析器”(#8)，它基本上将文件原样返回到“静态”文件夹中(这里没有魔法)。</p><p id="1718" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir"> #6 pokemonResult: </strong>我们将GraphQL代码移动到它自己的文件中，并用一个<code class="fe mz na nb nc b">query</code>包装它，这样我们可以向它传递变量，然后用属性中的一个<code class="fe mz na nb nc b">variables</code>节点指定它们，该节点指向另一个“条件解析器”。</p><figure class="mt mu mv mw gt jr"><div class="bz fp l di"><div class="nm my l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">带有变量名的GraphQL查询</figcaption></figure><p id="5689" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir"> #7 pokemonName: </strong>正如在#1中一样，我们检查URL是否匹配特定的模式(任何以正斜杠开头的内容)，如果匹配，我们使用特殊的关键字<code class="fe mz na nb nc b">$match.$1</code>返回它，这是将用于上面的GraphQL查询的值。</p><p id="bd40" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在有了一些CSS，我们应该能够通过在URL中传递名称来查看API中可用的所有神奇宝贝的统计数据:</p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi np"><img src="../Images/3b03c91f050d4ffa8bf8a22fa0106fe0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*9TUFTGVCbgyvnOT6_U_Cgw.gif"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">比德吉的<a class="ae la" href="https://codepen.io/Bidji/pen/MYdPwo" rel="noopener ugc nofollow" target="_blank"> Pokedex风格</a>的功劳</figcaption></figure><p id="00e5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如您所见，<strong class="ke ir"> UPWARD </strong>允许我们在几乎不编写任何javascript的情况下实现一些有趣的功能，然而，如果您对NodeJS更熟悉，或者如果您已经有了一个<em class="lk"> express </em>服务器，您也可以将<strong class="ke ir"> UPWARD </strong>用作一个中间件，这样它就可以作为您当前服务器的一个附件，并以一种更加渐进的方式引入，而不是一次性替换<em class="lk"> express </em>。</p><p id="2f87" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">所以你的<code class="fe mz na nb nc b">server.js</code>可能看起来像这样:</p><figure class="mt mu mv mw gt jr"><div class="bz fp l di"><div class="nm my l"/></div></figure><p id="1590" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">然后前往<code class="fe mz na nb nc b">/</code>路线的请求将由<em class="lk">快递</em>送达，其余外包给<strong class="ke ir">上行</strong>。</p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ns"><img src="../Images/0f24f1f9f90848e80c83f59e0ebbb58a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*ixKMgMFF3NS6bMOts25eTg.gif"/></div></div></figure><h1 id="044b" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">概括起来</h1><p id="5bc0" class="pw-post-body-paragraph kc kd iq ke b kf mo kh ki kj mp kl km kn mq kp kq kr mr kt ku kv ms kx ky kz ij bi translated"><strong class="ke ir">向上</strong>可以给我们很多对服务器的控制和定制，而不必直接与<em class="lk"> express </em>或类似的其他技术交互。即使在它的早期，我也惊讶于它能让我们做多少开箱即用的事情，所以我希望它会越来越好。</p><p id="d9e5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果你想自己尝试一下，看看规范的官方Github repo(T28)，我注意到它不是最新的，在大多数情况下，这些例子都没有意义，因为项目一直在快速变化，所以我建议深入研究一下UPWARD JS代码(T30)或Venia实现(T32)，以获得最新和最棒的特性。</p></div><div class="ab cl nt nu hu nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="ij ik il im in"><p id="4e66" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">文章中的所有例子都可以在Github中找到，所以请随意使用它，并提交任何更改或改进。👋🏽</p><div class="oa ob gp gr oc od"><a href="https://github.com/jahvi/upward-examples" rel="noopener  ugc nofollow" target="_blank"><div class="oe ab fo"><div class="of ab og cl cj oh"><h2 class="bd ir gy z fp oi fr fs oj fu fw ip bi translated">Jah VI/upward-示例</h2><div class="ok l"><h3 class="bd b gy z fp oi fr fs oj fu fw dk translated">使用Magento的UPWARD JS服务器的例子。通过创建一个帐户，为jahvi/upward-examples的发展做出贡献…</h3></div><div class="ol l"><p class="bd b dl z fp oi fr fs oj fu fw dk translated">github.com</p></div></div><div class="om l"><div class="on l oo op oq om or jw od"/></div></div></a></div></div></div>    
</body>
</html>