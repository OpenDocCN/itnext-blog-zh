<html>
<head>
<title>LoopBack 4 Database Configuration</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">LoopBack 4数据库配置</h1>
<blockquote>原文：<a href="https://itnext.io/loopback-4-database-configuration-8f085399268?source=collection_archive---------1-----------------------#2018-10-22">https://itnext.io/loopback-4-database-configuration-8f085399268?source=collection_archive---------1-----------------------#2018-10-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="7afe" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">经过StrongLoop和开源社区团队数月的辛勤工作，LoopBack 4<a class="ae ko" href="https://strongloop.com/strongblog/loopback-4-ga" rel="noopener ugc nofollow" target="_blank">最近宣布生产就绪</a>。对于那些不熟悉框架的人，可以查看<a class="ae ko" href="https://loopback.io/doc/en/lb4/Getting-started.html" rel="noopener ugc nofollow" target="_blank">官方文档</a>或者我的【LoopBack 4入门教程。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi kp"><img src="../Images/631678413fb00434c23d09d67d72ed08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0TL45jxVwuC4GVdAcvgH1Q.jpeg"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">回送4</figcaption></figure><p id="ecab" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">除了拥有一个稳定的、生产就绪的框架之外，还需要做一些工作来使我们的应用程序生产就绪，比如设置我们的数据库环境配置。</p><p id="8603" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">LoopBack 3是数据库或数据源配置的标准规范。本文将概述跨多个开发环境(开发、测试和生产)针对数据库配置LoopBack 4应用程序的一些方法。</p><h1 id="6449" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">介绍</h1><p id="0c2e" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">几乎每个web应用程序都需要以某种形式保存数据。LoopBack一直通过提供多个连接器供我们使用，将数据库引擎从应用中抽象出来，比如:MySQL、Postgres和In-memory。LoopBack 4使用LoopBack 3用来向引擎传递配置的相同底层库。然而，项目结构略有不同，如下所述</p><h1 id="7169" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">环回3配置</h1><p id="be57" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">在LoopBack 3中，您将在存储在<em class="mi">服务器</em>文件夹中的<em class="mi"> datasources.json </em>文件中定义一组JSON对象，这允许应用程序获取配置。该文件类似于以下内容:</p><pre class="kq kr ks kt gt mj mk ml mm aw mn bi"><span id="b28a" class="mo lg it mk b gy mp mq l mr ms">{<br/>  "db": {<br/>    "name": "db",<br/>    "connector": "memory"<br/>  }<br/>}</span></pre><p id="5172" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该文件定义了一个名为“<em class="mi"> db </em>的新数据源，它被配置为使用内存数据库连接器。在大多数应用程序中，这非常适合用作模型的默认数据源，因为它消除了首次使用原型时设置数据库服务器的需要。您可以只配置模型来利用“db”数据源，然后继续编写代码。</p><p id="5a09" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">同一个文件夹中的<em class="mi"> model-config.json </em>文件将一个模型连接到一个数据源，如下所示:</p><pre class="kq kr ks kt gt mj mk ml mm aw mn bi"><span id="435e" class="mo lg it mk b gy mp mq l mr ms">{<br/>  "_meta": {<br/>    "sources": [<br/>      "loopback/common/models",<br/>      "loopback/server/models",<br/>      "../common/models",<br/>      "./models"<br/>    ],<br/>    "mixins": [<br/>      "loopback/common/mixins",<br/>      "loopback/server/mixins",<br/>      "../common/mixins",<br/>      "./mixins"<br/>    ]<br/>  },<br/>  "Person": {<br/>    "dataSource": "db",<br/>    "public": false<br/>  },</span><span id="6d35" class="mo lg it mk b gy mt mq l mr ms">  ...</span><span id="bf4a" class="mo lg it mk b gy mt mq l mr ms">}</span></pre><p id="0d7d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一旦您有了应用程序的基础并根据内存中的数据库配置运行，您就可以专注于设置数据库服务器，如MySQL或Postgres，安装正确的连接器，并只需更改<em class="mi"> datasources.json </em>配置，如下所示:</p><pre class="kq kr ks kt gt mj mk ml mm aw mn bi"><span id="0e55" class="mo lg it mk b gy mp mq l mr ms">{<br/>  "db": {<br/>    "name": "db",<br/>    "connector": "mysql",<br/>    "hostname": "localhost",<br/>    "port": 3306,<br/>    "user": "root",<br/>    "password": "root",<br/>    "database": "app_database"<br/>  }<br/>}</span></pre><p id="a53d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这对当地的发展非常有利。但是，当在一个更大的团队或多个环境中工作时，一个JSON配置文件是不够的。LoopBack 3通过允许我们创建特定于环境的数据源文件，解决了特定于环境的配置问题。特定于环境的数据源文件名需要采用某种结构:<em class="mi"> datasources。</em><strong class="js iu"><em class="mi">&lt;&gt;</em></strong><em class="mi">。js </em>。一个包含3个环境的项目将包含以下文件:</p><ul class=""><li id="5623" class="mu mv it js b jt ju jx jy kb mw kf mx kj my kn mz na nb nc bi translated">datasources.json(本地数据库服务器配置)</li><li id="b0e8" class="mu mv it js b jt nd jx ne kb nf kf ng kj nh kn mz na nb nc bi translated">datasources.test.js(测试数据库服务器配置)</li><li id="f540" class="mu mv it js b jt nd jx ne kb nf kf ng kj nh kn mz na nb nc bi translated">datasources.production.js(生产数据库服务器配置)</li></ul><p id="95b7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">配置文件的JavaScript版本给了我们额外的灵活性，因为我们可以通过代码来确定配置。最常见的配置文件会利用系统环境变量。生产数据源配置文件的示例如下:</p><pre class="kq kr ks kt gt mj mk ml mm aw mn bi"><span id="ee4d" class="mo lg it mk b gy mp mq l mr ms">module.exports = {<br/>  db: {<br/>    name: 'db',    <br/>    connector: 'mysql',<br/>    hostname: process.env.DB_HOST,<br/>    port: process.env.DB_PORT,<br/>    user: process.env.DB_USER,<br/>    password: process.env.DB_PASSWORD,<br/>    database: process.env.DB_DATABASE<br/>  }<br/>};</span></pre><p id="caee" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这太棒了，因为它消除了在我们的代码中存储生产凭证的需要。我们可以安全地提交这些配置文件并在服务器上设置配置。</p><p id="858e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">默认情况下，框架将利用NODE_ENV系统环境变量来选择要使用的数据源文件。生产服务器将具有以下环境变量:</p><ul class=""><li id="a96a" class="mu mv it js b jt ju jx jy kb mw kf mx kj my kn mz na nb nc bi translated">节点环境=生产</li><li id="5c32" class="mu mv it js b jt nd jx ne kb nf kf ng kj nh kn mz na nb nc bi translated">DB _ HOST = AWS-rds-MySQL-HOST . example . com</li><li id="9126" class="mu mv it js b jt nd jx ne kb nf kf ng kj nh kn mz na nb nc bi translated">DB_PORT=3306</li><li id="dcdc" class="mu mv it js b jt nd jx ne kb nf kf ng kj nh kn mz na nb nc bi translated">DB _ USER =超级秘密用户</li><li id="d1fc" class="mu mv it js b jt nd jx ne kb nf kf ng kj nh kn mz na nb nc bi translated">DB _ PASSWORD =超级秘密密码</li><li id="c6d0" class="mu mv it js b jt nd jx ne kb nf kf ng kj nh kn mz na nb nc bi translated">数据库=应用数据库</li></ul><h1 id="40f0" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">环回4配置</h1><p id="2384" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">LoopBack 4不再自动读取数据源配置文件。相反，框架让我们决定如何配置我们的应用程序。目前，看起来没有任何文档化的最佳实践方法来设置它。建议的方法概述如下。</p><h2 id="a76b" class="mo lg it bd lh ni nj dn ll nk nl dp lp kb nm nn lt kf no np lx kj nq nr mb ns bi translated">依赖注入</h2><p id="ccde" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">在深入数据库配置之前，我们需要了解LoopBack 4的一个关键概念:<a class="ae ko" href="https://loopback.io/doc/en/lb4/Dependency-injection.html" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu"> <em class="mi">依赖注入</em> </strong> </a>。</p><p id="bba0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">实际上，应用程序可以根据唯一键的映射来注册值。这些值可以包含普通变量或类定义，然后应用程序可以使用它们来为我们处理这些对象的创建，方法是递归遍历所需的依赖项。</p><p id="697c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如，我们可以针对键“foo”注册一个值“bar”。</p><pre class="kq kr ks kt gt mj mk ml mm aw mn bi"><span id="28a0" class="mo lg it mk b gy mp mq l mr ms">this.bind('foo').to('bar');</span></pre><p id="5a39" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在应用程序知道键“foo”包含值“bar”。我们可以在代码的任何地方从应用程序请求这个值。举个例子:</p><pre class="kq kr ks kt gt mj mk ml mm aw mn bi"><span id="530c" class="mo lg it mk b gy mp mq l mr ms">@inject('foo') private foo: string;</span></pre><p id="55d1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">除了将一个值绑定到一个键，我们还可以将一个类绑定到一个键，让应用程序在根据请求实例化对象时递归地找出它的依赖关系。</p><pre class="kq kr ks kt gt mj mk ml mm aw mn bi"><span id="901e" class="mo lg it mk b gy mp mq l mr ms">export class Foo {<br/>  constructor(@inject('bar') private bar: string) {}</span><span id="477c" class="mo lg it mk b gy mt mq l mr ms">  someMethod() {<br/>    return this.bar;<br/>  }<br/>}</span><span id="b596" class="mo lg it mk b gy mt mq l mr ms">...</span><span id="86ee" class="mo lg it mk b gy mt mq l mr ms">this.bind('bar').to('Bar');<br/>this.bind('foo').toClass(Foo);</span></pre><p id="b147" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当我们请求Foo类的实例时，如下所示:</p><pre class="kq kr ks kt gt mj mk ml mm aw mn bi"><span id="bcc7" class="mo lg it mk b gy mp mq l mr ms">@inject('foo') private foo: Foo</span></pre><p id="e379" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">应用程序容器将会看到<em class="mi"> Foo </em>类依赖于<em class="mi">栏</em>的值。它将在依赖容器中查找它，找到它(如果它被绑定)，然后<em class="mi">将它注入到类中。于是，<strong class="js iu"> <em class="mi">依赖注入</em> </strong>。</em></p><h2 id="57c5" class="mo lg it bd lh ni nj dn ll nk nl dp lp kb nm nn lt kf no np lx kj nq nr mb ns bi translated">创建新项目</h2><p id="74fe" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">我们可以使用CLI通过调用以下命令来创建新项目:</p><pre class="kq kr ks kt gt mj mk ml mm aw mn bi"><span id="6d0e" class="mo lg it mk b gy mp mq l mr ms">lb4 app<br/>? <strong class="mk iu">Project name:</strong> my-api<br/>? <strong class="mk iu">Project description:</strong> My API<br/>? <strong class="mk iu">Project root directory:</strong> my-api<br/>? <strong class="mk iu">Application class name:</strong> MyApiApplication<br/>? <strong class="mk iu">Select features to enable in the project</strong> Enable tslint, Enable prettier, Enable mocha, Enable loopbackBuild, Enable vscode, Enable repositories, Enable services</span><span id="5343" class="mo lg it mk b gy mt mq l mr ms">cd ./my-api</span></pre><p id="4e17" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">LoopBack 4向项目添加一个<em class="mi">数据源</em>文件夹。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/0bc381800a96be75d684c501ebb4e538.png" data-original-src="https://miro.medium.com/v2/resize:fit:1196/format:webp/1*GGuZd5jCCD0REeGNBOLmmw.png"/></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">新LoopBack 4项目中的datasources文件夹</figcaption></figure><p id="d8d9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最初，假设这个文件夹被设置为以与LoopBack 3数据源JSON文件相同的方式读取。但是，它实际上只是用于CLI放置新文件的默认文件夹。</p><h2 id="588b" class="mo lg it bd lh ni nj dn ll nk nl dp lp kb nm nn lt kf no np lx kj nq nr mb ns bi translated">使用CLI添加数据源</h2><p id="02c9" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">通过运行以下命令，使用CLI创建新的数据源:</p><pre class="kq kr ks kt gt mj mk ml mm aw mn bi"><span id="1765" class="mo lg it mk b gy mp mq l mr ms">lb4 datasource<br/>? <strong class="mk iu">Datasource name:</strong> db<br/>? <strong class="mk iu">Select the connector for db:</strong> In-memory db (supported by StrongLoop)<br/>? <strong class="mk iu">window.localStorage key to use for persistence (browser only)</strong>:<br/>? <strong class="mk iu">Full path to file for persistence (server only)</strong>:</span><span id="b685" class="mo lg it mk b gy mt mq l mr ms">create src/datasources/db.datasource.json<br/>create src/datasources/db.datasource.ts<br/>update src/datasources/index.ts</span><span id="5367" class="mo lg it mk b gy mt mq l mr ms">Datasource db was created in src/datasources/</span></pre><p id="09da" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您首先会注意到的是，<em class="mi"> db.datasource.json </em>文件与LoopBack 3<em class="mi">data sources . JSON</em>文件完全相同。在CLI向导中，我选择了内存连接器，这是LoopBack 3和LoopBack 4中提供的众多连接器之一。</p><p id="8d7b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">回送数据源系列文件的新成员是<em class="mi">数据源。</em> <strong class="js iu"> <em class="mi"> ts </em> </strong>文件。</p><pre class="kq kr ks kt gt mj mk ml mm aw mn bi"><span id="eabf" class="mo lg it mk b gy mp mq l mr ms">import {inject} from '@loopback/core';<br/>import {juggler} from '@loopback/repository';<br/>import * as config from './db.datasource.json';</span><span id="2ab2" class="mo lg it mk b gy mt mq l mr ms">export class DbDataSource extends juggler.DataSource {<br/>  static dataSourceName = 'db';</span><span id="247d" class="mo lg it mk b gy mt mq l mr ms">  constructor(<br/>    @<strong class="mk iu">inject</strong>('<strong class="mk iu">datasources.config.db</strong>', {optional: true})<br/>    dsConfig: object = config,<br/>  ) {<br/>    super(dsConfig);<br/>  }<br/>}</span></pre><p id="bf7d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该类扩展了一个<em class="mi">杂耍器。DataSource </em> type，与LoopBack 3中使用的类型相同(除了是它的TypeScript定义版本)。它需要LoopBack 3使用的相同的JSON配置结构。在这个版本中，我们需要将配置传递给构造函数的super方法。</p><pre class="kq kr ks kt gt mj mk ml mm aw mn bi"><span id="7cda" class="mo lg it mk b gy mp mq l mr ms">import * as config from './db.datasource.json';</span><span id="456d" class="mo lg it mk b gy mt mq l mr ms">...</span><span id="fb87" class="mo lg it mk b gy mt mq l mr ms">constructor(<br/>  @<strong class="mk iu">inject</strong>('<strong class="mk iu">datasources.config.db</strong>', {optional: true}) <br/>  dsConfig: object = config<br/>)</span><span id="bbf8" class="mo lg it mk b gy mt mq l mr ms">...</span></pre><p id="1f1e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该文件从<em class="mi"> db.datasource.json </em>文件中导入默认配置，并将其作为默认值包含到<em class="mi"> dsConfig </em>构造函数参数中。这意味着，在实例化对象的实例时，我们永远不需要向DbDataSource类的构造函数传递任何东西，除非我们要覆盖它……也许是为了不同的环境(稍后将详细介绍)。</p><p id="05cb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">另一个不熟悉的<em class="mi">注入</em>装饰器允许框架从依赖注入容器<em class="mi">注入</em>参数的值(如果绑定的话)。</p><p id="3b23" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">考虑到这一点，有许多不同的方法来实例化这个新的DataSource类:</p><pre class="kq kr ks kt gt mj mk ml mm aw mn bi"><span id="e7a4" class="mo lg it mk b gy mp mq l mr ms">// 1. With the default configuration from db.datasource.json<br/>let dbDataSource = new DbDataSource();</span><span id="dd42" class="mo lg it mk b gy mt mq l mr ms">// 2. Overwriting the default configuration<br/>let dbDataSource = new DbDataSource({<br/>  name: 'db',    <br/>  connector: 'mysql',<br/>  hostname: process.env.DB_HOST,<br/>  port: process.env.DB_PORT,<br/>  user: process.env.DB_USER,<br/>  password: process.env.DB_PASSWORD,<br/>  database: process.env.DB_DATABASE<br/>});</span></pre><p id="ea71" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们现在有了一个dbDataSource的实例。但是，我们实际上如何使用它呢？我们的新应用程序如何知道我们的数据源？</p><p id="63d9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">与我们可以针对应用程序依赖容器注册(或绑定)值(或类)的方式相同，我们可以将数据源的实例绑定到容器的键。</p><p id="696a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我们的<em class="mi"> application.ts </em>文件中，我们可以利用构造函数中的应用程序绑定函数将我们的实例链接到应用程序:</p><pre class="kq kr ks kt gt mj mk ml mm aw mn bi"><span id="2dd7" class="mo lg it mk b gy mp mq l mr ms">this.<strong class="mk iu">bind</strong>('<strong class="mk iu">datasources.db</strong>').to(new DbDataSource());</span></pre><p id="14a9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">另外，LoopBack 4有一个特殊的函数叫做<em class="mi"> datasource: </em></p><pre class="kq kr ks kt gt mj mk ml mm aw mn bi"><span id="7ba6" class="mo lg it mk b gy mp mq l mr ms">this.<strong class="mk iu">dataSource</strong>(new <strong class="mk iu">DbDataSource</strong>());</span></pre><p id="b6c5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="mi"> datasource </em>函数，基本上包装了一个<em class="mi">this . bind(‘data sources。&lt;数据源名称&gt;’)。</em></p><p id="d33a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">还有最后一种将数据源绑定到应用程序的方法:</p><pre class="kq kr ks kt gt mj mk ml mm aw mn bi"><span id="6528" class="mo lg it mk b gy mp mq l mr ms">this.bind('datasources.config.db').to({<br/>  name: 'db',<br/>  connector: 'mysql',<br/>  hostname: process.env.DB_HOST,<br/>  port: process.env.DB_PORT,<br/>  user: process.env.DB_USER,<br/>  password: process.env.DB_PASSWORD,<br/>  database: process.env.DB_DATABASE,<br/>});<br/>this.bind('datasources.db').toClass(DbDataSource);</span></pre><p id="b1fe" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">上面的代码片段首先将配置绑定到<em class="mi">‘data sources . config . db’</em>依赖键。这个依赖键通过<em class="mi">注入</em>装饰器在DbDataSource类的构造函数中被引用。通过将<em class="mi"> 'datasources.db' </em>键绑定到<strong class="js iu"> <em class="mi">类定义</em></strong>"<em class="mi">db data source "</em>，依赖容器将查找它的所有依赖项，并为我们实例化它。</p><p id="0476" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">既然应用程序的依赖容器知道了我们的数据源，我们可以将它绑定到存储库和模型。</p><p id="bc29" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="mi">注意:在生成存储库之前，您需要先生成一个模型。</em>为此，使用<em class="mi"> lb4型号</em>命令:</p><pre class="kq kr ks kt gt mj mk ml mm aw mn bi"><span id="3f9b" class="mo lg it mk b gy mp mq l mr ms">lb4 model<br/>? <strong class="mk iu">Model class name:</strong> Person<br/>? <strong class="mk iu">Please select the model base class</strong> Entity</span><span id="6ebe" class="mo lg it mk b gy mt mq l mr ms">Let's add a property to Person<br/>Enter an empty property name when done</span><span id="0c60" class="mo lg it mk b gy mt mq l mr ms">? <strong class="mk iu">Enter the property name:</strong> id<br/>? <strong class="mk iu">Property type:</strong> number<br/>? <strong class="mk iu">Is id the ID property?</strong> Yes<br/>? <strong class="mk iu">Is it required?:</strong> Yes<br/>? <strong class="mk iu">Default value [leave blank for none]:</strong></span><span id="42d6" class="mo lg it mk b gy mt mq l mr ms">Let's add another property to Person<br/>Enter an empty property name when done</span><span id="1a1e" class="mo lg it mk b gy mt mq l mr ms">? <strong class="mk iu">Enter the property name:</strong></span><span id="3d77" class="mo lg it mk b gy mt mq l mr ms">create src/models/person.model.ts<br/>update src/models/index.ts</span><span id="415e" class="mo lg it mk b gy mt mq l mr ms">Model Person was created in src/models/</span></pre><p id="9157" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">创建模型之后，让我们将它链接到一个新的存储库。使用<em class="mi"> lb4存储库</em>命令:</p><pre class="kq kr ks kt gt mj mk ml mm aw mn bi"><span id="374e" class="mo lg it mk b gy mp mq l mr ms">lb4 repository<br/>? <strong class="mk iu">Please select the datasource</strong> DbDatasource<br/>? <strong class="mk iu">Select the model(s) you want to generate a repository</strong> Person<br/>? <strong class="mk iu">Please enter the name of the ID property for Person:</strong> id</span><span id="017a" class="mo lg it mk b gy mt mq l mr ms">create src/repositories/person.repository.ts<br/>update src/repositories/index.ts</span><span id="1722" class="mo lg it mk b gy mt mq l mr ms">Repository Person was created in src/repositories/</span></pre><p id="8c2f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一旦您使用了<em class="mi"> lb4 model </em>和<em class="mi"> lb4 repository </em>命令，您应该会得到一个绑定到注入DbDataSource类的模型的存储库:</p><pre class="kq kr ks kt gt mj mk ml mm aw mn bi"><span id="7d6f" class="mo lg it mk b gy mp mq l mr ms">export class PersonRepository extends <strong class="mk iu">DefaultCrudRepository</strong>&lt;<br/>  Person,<br/>  typeof Person.prototype.id<br/>&gt; {<br/>  <br/>  constructor(<br/>    @<strong class="mk iu">inject</strong>('<strong class="mk iu">datasources.db</strong>') dataSource: DbDataSource,<br/>  ) {<br/>    super(<strong class="mk iu">Person</strong>, dataSource);<br/>  }<br/>}</span></pre><p id="bf2d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">注意，PersonRepository构造函数再次使用了<em class="mi"> inject </em> decorator，但是这次它引用了我们之前设置的<em class="mi">‘data sources . db’</em>键。该存储库负责将模型连接到数据源，并提供CRUD(创建、读取、更新和删除)功能，这要归功于我们从其继承的提供的<em class="mi">defaultcruddrepository</em>类。</p><p id="452e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">就像我们将数据源绑定到应用程序一样，我们需要将存储库绑定到应用程序:</p><pre class="kq kr ks kt gt mj mk ml mm aw mn bi"><span id="ab1a" class="mo lg it mk b gy mp mq l mr ms">this.repository(PersonRepository);</span></pre><p id="33fa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">this.repository是this.bind的包装器(' repositories。&lt;  <strong class="js iu"> <em class="mi">【储存库名称】</em></strong><em class="mi">&gt;’)。</em></p><p id="4d47" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">注册后，我们可以使用<em class="mi"> lb4控制器</em>命令为我们搭建一个新的REST控制器，它利用了我们新设置的模型、数据源和存储库:</p><pre class="kq kr ks kt gt mj mk ml mm aw mn bi"><span id="9370" class="mo lg it mk b gy mp mq l mr ms">lb4 controller<br/>? <strong class="mk iu">Controller class name:</strong> People<br/>? <strong class="mk iu">What kind of controller would you like to generate?</strong> REST Controller with CRUD functions<br/>? <strong class="mk iu">What is the name of the model to use with this CRUD repository?</strong> Person<br/>? <strong class="mk iu">What is the name of your CRUD repository?</strong> PersonRepository<br/>? <strong class="mk iu">What is the type of your ID?</strong> number<br/>? <strong class="mk iu">What is the base HTTP path name of the CRUD operations?</strong> /people</span><span id="6853" class="mo lg it mk b gy mt mq l mr ms">create src/controllers/people.controller.ts<br/>update src/controllers/index.ts</span><span id="f724" class="mo lg it mk b gy mt mq l mr ms">Controller People was created in src/controllers/</span></pre><p id="131b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可以使用与我们拥有数据源和存储库相同的方式向应用程序注册控制器。除了利用<em class="mi">库</em>和<em class="mi">控制器</em>函数将我们的类绑定到我们的应用程序，LoopBack自动为我们绑定它们。这可以在应用程序类构造函数中配置:</p><pre class="kq kr ks kt gt mj mk ml mm aw mn bi"><span id="8d90" class="mo lg it mk b gy mp mq l mr ms">this.bootOptions = {<br/>  controllers: {<br/>    // Customize ControllerBooter Conventions here<br/>    dirs: ['controllers'],<br/>    extensions: ['.controller.js'],<br/>    nested: true,<br/>  },<br/>};</span></pre><p id="42db" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这告诉我们的应用程序在controllers文件夹中查找我们所有的控制器，并自动为我们调用<em class="mi"> this.controller </em>。您也可以配置bootOptions <em class="mi"> repository </em>值来对存储库执行相同的操作。</p><p id="0206" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了节省空间，我们不会在这里分析整个控制器文件。将概述重要的部分:</p><pre class="kq kr ks kt gt mj mk ml mm aw mn bi"><span id="c39c" class="mo lg it mk b gy mp mq l mr ms">constructor(<br/>  <strong class="mk iu">@repository</strong>(PersonRepository)<br/>  public personRepository : PersonRepository,<br/>) {}</span></pre><p id="386c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="mi">储存库</em>装饰器包装了<em class="mi">注入</em>装饰器。这与执行以下操作是一样的:</p><pre class="kq kr ks kt gt mj mk ml mm aw mn bi"><span id="2389" class="mo lg it mk b gy mp mq l mr ms">constructor(<br/>  <strong class="mk iu">@inject</strong>('repositories.PersonRepository')<br/>  public personRepository : PersonRepository,<br/>) {}</span></pre><p id="cb68" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，我们可以利用存储库来访问我们配置的数据源中的模型数据。</p><pre class="kq kr ks kt gt mj mk ml mm aw mn bi"><span id="c5ca" class="mo lg it mk b gy mp mq l mr ms">@post('/people', {<br/>  responses: {<br/>    '200': {<br/>      description: 'Person model instance',<br/>      content: {'application/json': {'x-ts-type': Person}},<br/>    },<br/>  },<br/>})<br/>async create(@requestBody() person: Person): Promise&lt;Person&gt; {<br/>  <strong class="mk iu">return await this.personRepository.create(person);</strong><br/>}</span></pre><h1 id="5891" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">结论</h1><p id="3142" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">本文比较了针对LoopBack 3和LoopBack 4应用程序配置数据库数据源之间的差异。除了了解如何配置数据源，我们还了解了如何通过允许系统环境变量设置配置数据来设置各种环境的配置，我们通过node . js<em class="mi">process . env . env _ VARIABLE</em>API访问这些变量。</p></div></div>    
</body>
</html>