<html>
<head>
<title>Git Merge vs Rebase</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Git合并vs Rebase</h1>
<blockquote>原文：<a href="https://itnext.io/git-merge-vs-rebase-938950fb218?source=collection_archive---------0-----------------------#2022-04-11">https://itnext.io/git-merge-vs-rebase-938950fb218?source=collection_archive---------0-----------------------#2022-04-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a447" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">三种类型的合并</h2></div><p id="0442" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">合并是将一个分支中完成的工作添加到另一个分支中。有三种方法可以将一个分支合并到另一个分支:</p><ul class=""><li id="f11b" class="le lf it kk b kl km ko kp kr lg kv lh kz li ld lj lk ll lm bi translated">快进合并，</li><li id="1a96" class="le lf it kk b kl ln ko lo kr lp kv lq kz lr ld lj lk ll lm bi translated">挤压合并，</li><li id="c102" class="le lf it kk b kl ln ko lo kr lp kv lq kz lr ld lj lk ll lm bi translated">和通过创建合并提交进行合并。</li></ul><p id="4e72" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我将第三个选项称为“真正的合并”，以在必要时强调它。</p><h1 id="ddbd" class="ls lt it bd lu lv lw lx ly lz ma mb mc jz md ka me kc mf kd mg kf mh kg mi mj bi translated">TL；速度三角形定位法(dead reckoning)</h1><p id="bebb" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">这篇副标题为“三种合并”的文章主要集中在为是否使用重定基或合并的讨论奠定基础。一篇名为“Git Merge vs Rebase以及在哪里使用它们”的后续文章将涵盖每个工作流的优缺点。</p><figure class="mq mr ms mt gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi mp"><img src="../Images/31ecbaac1e833d0a5a28caf5a25d13b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*klowfpWWorSn0lwAcyut7w.png"/></div></div></figure><h1 id="1bcb" class="ls lt it bd lu lv lw lx ly lz ma mb mc jz md ka me kc mf kd mg kf mh kg mi mj bi translated">快进合并</h1><p id="2329" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">当源分支中只有新的提交时，快进合并只是将这些提交添加到目标分支中。轻松点。</p><h1 id="c3ce" class="ls lt it bd lu lv lw lx ly lz ma mb mc jz md ka me kc mf kd mg kf mh kg mi mj bi translated">重置基础和快进合并</h1><p id="5cea" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">只有当目标分支是源分支的祖先时，快速前进合并才是可能的，但通常不是这样。您已经向您的特性分支添加了2个提交，当您想要将它合并回主特性时，您的同事已经向它添加了4个提交。在这种情况下，我们说特征分支比主分支超前2次提交，滞后4次提交。</p><figure class="mq mr ms mt gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi nb"><img src="../Images/eb8904ecc518e922b6e56042d178f356.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1iB6tg9eAba1KHW6U0KTTg.png"/></div></div></figure><p id="154f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果特征分支落后，则不能执行快速前进合并。为了解决这个问题，我们做了一件叫做“重定基础”的事情。通过将特征分支重新基于主服务器，我们移除新添加的分支提交，用主服务器的当前状态更新分支，然后在主服务器的顶端添加移除提交。</p><pre class="mq mr ms mt gt nc nd ne nf aw ng bi"><span id="bafd" class="nh lt it nd b gy ni nj l nk nl">git checkout feature_branch<br/>git rebase master</span></pre><figure class="mq mr ms mt gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi nm"><img src="../Images/eb5f605dcd735ed30ea7f61bebc9ceee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TJW0G9UQOyl27Z6SBlIfjA.png"/></div></div></figure><p id="f8ea" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在执行rebase之后，特征分支变成提前2次提交，在主分支之后0次提交，因此我们可以执行快进合并。</p><pre class="mq mr ms mt gt nc nd ne nf aw ng bi"><span id="80f5" class="nh lt it nd b gy ni nj l nk nl">git checkout master<br/>git merge --ff-only feature_branch</span></pre><figure class="mq mr ms mt gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi nn"><img src="../Images/88ca836a31eb3501616ee4d9f071374f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uqK7_tuzlLztPf1ogWgkaA.png"/></div></div></figure><h1 id="5762" class="ls lt it bd lu lv lw lx ly lz ma mb mc jz md ka me kc mf kd mg kf mh kg mi mj bi translated">真正的合并</h1><p id="f4fa" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">让我们回到具有特征分支2提前提交和4滞后于主提交的情况。当执行真正的合并时，新的提交被添加到主分支，该主分支包含来自特征分支的所有新的改变。</p><pre class="mq mr ms mt gt nc nd ne nf aw ng bi"><span id="a64b" class="nh lt it nd b gy ni nj l nk nl">git checkout master<br/>git merge feature_branch</span></pre><figure class="mq mr ms mt gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi no"><img src="../Images/18e4820a21705f21c2b2fc93850135ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SHbfMlJb1jeNm8ROofGbNg.png"/></div></div></figure><p id="08d1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">新添加的提交称为“合并提交”。它具有对特征分支的头的引用，以及对其在主分支中的先前提交的引用；这就是为什么我们说合并提交有两个“双亲”。</p><h1 id="e9c7" class="ls lt it bd lu lv lw lx ly lz ma mb mc jz md ka me kc mf kd mg kf mh kg mi mj bi translated">合并与重设基础</h1><p id="c246" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">当我们谈论“合并与重定基础”时，我们是在比较以下两个合并两个分支的工作流:</p><ul class=""><li id="b148" class="le lf it kk b kl km ko kp kr lg kv lh kz li ld lj lk ll lm bi translated">重定基数和快进，</li><li id="edb7" class="le lf it kk b kl ln ko lo kr lp kv lq kz lr ld lj lk ll lm bi translated">或者执行真正的合并。</li></ul><p id="3336" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这两种工作流程之间存在一些差异:</p><ul class=""><li id="b1c4" class="le lf it kk b kl km ko kp kr lg kv lh kz li ld lj lk ll lm bi translated">rebase工作流使git图保持线性，而merge工作流跟踪分支提交。</li><li id="863e" class="le lf it kk b kl ln ko lo kr lp kv lq kz lr ld lj lk ll lm bi translated">如果存在冲突，在前一个工作流中，需要在重新定基阶段解决它们，而在后一个工作流中，需要在合并阶段解决它们(因此，需要将主文件合并到特征分支中，然后将特征分支合并到主文件中)。</li></ul><h1 id="965f" class="ls lt it bd lu lv lw lx ly lz ma mb mc jz md ka me kc mf kd mg kf mh kg mi mj bi translated">挤压合并</h1><p id="926f" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">第三种类型的合并并没有得到太多的关注。挤压合并基本上挤压特征分支上的所有提交(即，将它们打包成一个提交)，并将该提交添加到目标分支。</p><p id="8b87" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">主要区别在于，新创建的提交没有对创建它的分支的引用。所以，这种合并方式和另外两种有相似之处。</p><h1 id="42ab" class="ls lt it bd lu lv lw lx ly lz ma mb mc jz md ka me kc mf kd mg kf mh kg mi mj bi translated">未来的工作</h1><p id="2a43" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">在将于4月18日出版的下一部作品中，将对这两个工作流程进行全面比较。<a class="ae np" href="https://medium.com/subscribe/@aerabi" rel="noopener">订阅</a>,以便在文章发布时获得通知，以及随后的其他每周git内容。</p></div></div>    
</body>
</html>