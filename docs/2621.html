<html>
<head>
<title>Status of JavaScript(ECMAScript): 2019 &amp; beyond.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript(ECMAScript)的现状:2019年及以后。</h1>
<blockquote>原文：<a href="https://itnext.io/status-of-javascript-ecmascript-2019-beyond-5efca6a2d233?source=collection_archive---------0-----------------------#2019-06-26">https://itnext.io/status-of-javascript-ecmascript-2019-beyond-5efca6a2d233?source=collection_archive---------0-----------------------#2019-06-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="893b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">JavaScript继续流行，这是没有必要再提了</p><p id="96c5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">多年来，JavaScript一直是GitHub中最常用的语言，如GitHub报告中的<a class="ae kl" href="https://octoverse.github.com/projects#languages" rel="noopener ugc nofollow" target="_blank">图</a>、<a class="ae kl" href="https://octoverse.github.com/" rel="noopener ugc nofollow" target="_blank"> Octoverse </a>所示。还有Stack Overflow最近的调查，“<a class="ae kl" href="https://insights.stackoverflow.com/survey/2019#technology" rel="noopener ugc nofollow" target="_blank">开发者调查结果2019 </a>，JavaScript被评为最受欢迎的技术。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/93ae63b693424b6138b14cd11ea40805.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*E-qsu6SB4ue9EtCf.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated"><a class="ae kl" href="https://octoverse.github.com/projects#languages" rel="noopener ugc nofollow" target="_blank">GitHub上使用的热门语言</a></figcaption></figure><p id="5e83" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">特别是ECMAScript 2015以及后续的ECMAScript规范，似乎被很多开发者接受，没有太大阻力。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi lc"><img src="../Images/ca2399e235b6abf53df71bc3fd97dd29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1348/format:webp/1*p7PTE_ewD0m_A8NPdApQyg.png"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">“2018年JS状况”调查中的JavaScript风格。</figcaption></figure><p id="5dd0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本文中，我们将了解ECMAScript 2018的主要特性，以及预计将包含在以下规范中的建议，ECMAScript 2019和ECMAScript 2020。</p><blockquote class="ld le lf"><p id="974a" class="jn jo lg jp b jq jr js jt ju jv jw jx lh jz ka kb li kd ke kf lj kh ki kj kk ij bi translated"><strong class="jp ir">切记:</strong> <br/>本文内容以2019年6月为准。根据你阅读的时间，文章的内容和事实可能会有所不同。</p></blockquote><h1 id="dcfa" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">一些变化和新闻</h1><p id="ee12" class="pw-post-body-paragraph jn jo iq jp b jq mi js jt ju mj jw jx jy mk ka kb kc ml ke kf kg mm ki kj kk ij bi translated">虽然它不会直接影响JavaScript的语言方面，但是有一些变化可能会影响间接方面，比如使用环境和生态系统。</p><h2 id="5908" class="mn ll iq bd lm mo mp dn lq mq mr dp lu jy ms mt ly kc mu mv mc kg mw mx mg my bi translated">TC39的变化</h2><p id="779d" class="pw-post-body-paragraph jn jo iq jp b jq mi js jt ju mj jw jx jy mk ka kb kc ml ke kf kg mm ki kj kk ij bi translated">讨论JavaScript标准规范的技术委员会TC39已经决定从2019年开始改变其运行结构。TC39每年举行六次会议，该委员会已经发展到大约40到60人参加会议的地步。</p><p id="cb68" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">过去由董事长和副董事长组成的结构，变成了由三位联席董事长(<a class="ae kl" href="https://github.com/gesa" rel="noopener ugc nofollow" target="_blank">阿基·布劳恩</a> (PayPal)、<a class="ae kl" href="https://github.com/bterlson" rel="noopener ugc nofollow" target="_blank">布莱恩·泰尔森</a>(微软)和<a class="ae kl" href="https://github.com/codehag" rel="noopener ugc nofollow" target="_blank">尤利娅·斯塔策夫</a> (Mozilla)共同负责的横向结构。还在2019年3月开通了官网(<a class="ae kl" href="https://tc39.github.io" rel="noopener ugc nofollow" target="_blank"> https://tc39.github.io </a>)。</p><p id="8c30" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在TC39联席主席Aki Braun撰写的文章《TC39一年(加一点点)》中，可以看到TC39会议的进展和会议的样子。</p><p id="1048" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2018年7月早些时候，npm加入了<a class="ae kl" href="https://www.ecma-international.org/" rel="noopener ugc nofollow" target="_blank"> ECMA国际</a>和TC39(参见“<a class="ae kl" href="https://blog.npmjs.org/post/175722319045/npm-joins-ecma-international-and-tc39" rel="noopener ugc nofollow" target="_blank"> npm加入ECMA国际和TC39 </a>”)。</p><h2 id="f738" class="mn ll iq bd lm mo mp dn lq mq mr dp lu jy ms mt ly kc mu mv mc kg mw mx mg my bi translated">SharedArrayBuffer</h2><p id="3dc2" class="pw-post-body-paragraph jn jo iq jp b jq mi js jt ju mj jw jx jy mk ka kb kc ml ke kf kg mm ki kj kk ij bi translated">由于安全漏洞<a class="ae kl" href="https://meltdownattack.com/" rel="noopener ugc nofollow" target="_blank"> Meltdown和Spectre </a>，浏览器厂商改变了默认设置，从2018年1月5日起禁止使用<a class="ae kl" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer" rel="noopener ugc nofollow" target="_blank"> SharedArrayBuffer </a>对象。</p><p id="0667" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这些设置至今仍在保持，除了Chrome。Chrome从v67开始重新激活，通过<a class="ae kl" href="https://www.chromium.org/Home/chromium-security/site-isolation" rel="noopener ugc nofollow" target="_blank">站点隔离</a>(参见“<a class="ae kl" href="https://bugs.chromium.org/p/chromium/issues/detail?id=821270" rel="noopener ugc nofollow" target="_blank"> Isue 821270:重新启用SharedArrayBuffer + Atomics </a>”)。</p><h2 id="d32f" class="mn ll iq bd lm mo mp dn lq mq mr dp lu jy ms mt ly kc mu mv mc kg mw mx mg my bi translated">MS Edge对铬的采用</h2><p id="3957" class="pw-post-body-paragraph jn jo iq jp b jq mi js jt ju mj jw jx jy mk ka kb kc ml ke kf kg mm ki kj kk ij bi translated">微软在2018年12月6日宣布，它将把浏览器Microsoft Edge过渡到基于Chromium的浏览器，这让许多人感到惊讶(参见“<a class="ae kl" href="https://blogs.windows.com/windowsexperience/2018/12/06/microsoft-edge-making-the-web-better-through-more-open-source-collaboration/" rel="noopener ugc nofollow" target="_blank"> Microsoft Edge:通过更多开源合作制作Webbetter)。</a>))</p><p id="c6f8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在2019年1月29日TC39会议期间与微软举行的<a class="ae kl" href="http://tc39.github.io/tc39-notes/2019-01_jan-29.html#edgechakra-qa-from-microsoft-brian-terlson--kevin-smith" rel="noopener ugc nofollow" target="_blank"> Q &amp; A会议</a>中，披露了以下关于微软Edge Chromium过渡的事实。</p><ul class=""><li id="539a" class="mz na iq jp b jq jr ju jv jy nb kc nc kg nd kk ne nf ng nh bi translated">没有开源旧渲染引擎的计划。</li><li id="3ee5" class="mz na iq jp b jq ni ju nj jy nk kc nl kg nm kk ne nf ng nh bi translated">现有JavaScript引擎<a class="ae kl" href="https://github.com/microsoft/ChakraCore" rel="noopener ugc nofollow" target="_blank"> ChakraCore </a>的更新将继续，但没有长期计划。</li></ul><blockquote class="ld le lf"><p id="6566" class="jn jo lg jp b jq jr js jt ju jv jw jx lh jz ka kb li kd ke kf lj kh ki kj kk ij bi translated">查克拉核心团队成员朱利民评论道:<br/>查克拉核心目前正在浏览器之外的各种项目中使用。因此，尽管微软Edge的方向发生了变化，我们的团队将继续支持ChakraCore(参见“<a class="ae kl" href="https://github.com/Microsoft/ChakraCore/issues/5865" rel="noopener ugc nofollow" target="_blank"> Chromium在微软Edge中的采用和ChakraCore的未来</a>”)。</p></blockquote><p id="baa6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可以从<a class="ae kl" href="https://www.microsoftedgeinsider.com/en-us/download/" rel="noopener ugc nofollow" target="_blank">微软Edge内部渠道</a>网站下载基于chromium的微软Edge(Canary/Dev/Beta版本)。</p><blockquote class="ld le lf"><p id="c443" class="jn jo lg jp b jq jr js jt ju jv jw jx lh jz ka kb li kd ke kf lj kh ki kj kk ij bi translated">在“<a class="ae kl" href="https://github.com/MicrosoftEdge/MSEdge/blob/master/README.md" rel="noopener ugc nofollow" target="_blank">微软Edge和Chromium开源:我们的意图</a>”文章中可以找到将微软Edge转变为基于Chromium的目的和未来计划。</p></blockquote><p id="8c66" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从开发者的角度来看，微软Edge的这种转变可以减轻跨浏览器开发的负担和困难。</p><p id="4e04" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，从网络生态系统的角度来看，一些令人担忧的事情可能会发生。因为这将减少浏览器的多样性。</p><p id="9eb7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你还记得Internet Explorer处于垄断地位的时候，许多网站只针对Internet Explorer，那么基于chromium的浏览器的扩展将不是一件令人愉快的事情。</p><blockquote class="ld le lf"><p id="4169" class="jn jo lg jp b jq jr js jt ju jv jw jx lh jz ka kb li kd ke kf lj kh ki kj kk ij bi translated">对于多样性的担忧，请参见文章“<a class="ae kl" href="https://www.theverge.com/2018/1/4/16805216/google-chrome-only-sites-internet-explorer-6-web-standards" rel="noopener ugc nofollow" target="_blank"> Chrome正在变成新的Internet Explorer 6 </a>”和Mozilla的“<a class="ae kl" href="https://blog.mozilla.org/blog/2018/12/06/goodbye-edge/" rel="noopener ugc nofollow" target="_blank">再见，EdgeHTML </a>”。</p></blockquote><h1 id="be31" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">模块支持</h1><p id="c949" class="pw-post-body-paragraph jn jo iq jp b jq mi js jt ju mj jw jx jy mk ka kb kc ml ke kf kg mm ki kj kk ij bi translated">由于ECMAScript 2015中添加了模块支持，模块现在作为一项基本功能被广泛使用。</p><p id="97fa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们看看动态导入()语法和本机模块支持的覆盖范围和当前状态，以进一步扩展模块的用途。</p><h2 id="3e0e" class="mn ll iq bd lm mo mp dn lq mq mr dp lu jy ms mt ly kc mu mv mc kg mw mx mg my bi translated">动态导入()</h2><p id="c1da" class="pw-post-body-paragraph jn jo iq jp b jq mi js jt ju mj jw jx jy mk ka kb kc ml ke kf kg mm ki kj kk ij bi translated">基于<a class="ae kl" href="https://github.com/tc39/proposal-dynamic-import" rel="noopener ugc nofollow" target="_blank"> import() </a>语法的承诺，会让模块动态加载。该提案在第3阶段停留了一段时间，但最终在2010年6月6日达到了第4阶段，并成为ECMAScript 2020的一部分。</p><ul class=""><li id="8de4" class="mz na iq jp b jq jr ju jv jy nb kc nc kg nd kk ne nf ng nh bi translated">有关import()语法的详细解释，请参见文章“<a class="ae kl" href="https://hacks.mozilla.org/2018/03/es-modules-a-cartoon-deep-dive/" rel="noopener ugc nofollow" target="_blank">ES modules:A cartoon deep-dive</a>”。</li><li id="e837" class="mz na iq jp b jq ni ju nj jy nk kc nl kg nm kk ne nf ng nh bi translated">查看<a class="ae kl" href="https://caniuse.com/#feat=es6-module-dynamic-import" rel="noopener ugc nofollow" target="_blank">caniuse.com</a>的浏览器支持范围。</li></ul><pre class="kn ko kp kq gt nn no np nq aw nr bi"><span id="b661" class="mn ll iq no b gy ns nt l nu nv">import("./myModule.mjs")  <br/>    .then(module =&gt; {<br/>        ...<br/>    });<br/>// using async/await<br/>(async () =&gt; {<br/>    const module = await import("./myModule.mjs");<br/>    ...<br/>})();</span></pre><p id="1994" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从Firefox 60开始，可以通过设置<strong class="jp ir">JavaScript . options . dynamic import</strong>标志来使用import()语法，这在Firefox 67中是默认启用的。</p><p id="f8d7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">微软Edge(不基于chromium)还不支持import()语法，但是当基于chromium的Edge发布时，它应该会得到支持。</p><h2 id="23a7" class="mn ll iq bd lm mo mp dn lq mq mr dp lu jy ms mt ly kc mu mv mc kg mw mx mg my bi translated">本机模块加载</h2><p id="da44" class="pw-post-body-paragraph jn jo iq jp b jq mi js jt ju mj jw jx jy mk ka kb kc ml ke kf kg mm ki kj kk ij bi translated">从2018年5月发布的Firefox 60开始，可以在没有标志的情况下使用本机模块(ESM)(参见“<a class="ae kl" href="https://hacks.mozilla.org/2018/05/firefox-60-modules-and-more/" rel="noopener ugc nofollow" target="_blank"> Firefox 60 —模块和更多</a>”)。2017年9月发布的Node.js 8.5.0在实验上支持ESM。</p><p id="58c1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Node.js中的ESM需要<code class="fe nw nx ny no b">--experimental-modules</code>标志，如下例所示。在这种情况下，CommonJS的' require()'将被禁用以进行模块加载(参见"<a class="ae kl" href="https://github.com/nodejs/modules/blob/master/doc/announcement.md" rel="noopener ugc nofollow" target="_blank">宣布新的实验模块</a>")。</p><pre class="kn ko kp kq gt nn no np nq aw nr bi"><span id="a8da" class="mn ll iq no b gy ns nt l nu nv">node --experimental-modules my-app.mjs</span></pre><p id="13af" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Node.js基金会成立了“<a class="ae kl" href="https://github.com/nodejs/modules" rel="noopener ugc nofollow" target="_blank">模块团队</a>，为ESM提供官方支持。模块团队的工作分为<a class="ae kl" href="https://github.com/nodejs/modules/blob/master/doc/plan-for-new-modules-implementation.md" rel="noopener ugc nofollow" target="_blank"> 4个阶段</a>。</p><ul class=""><li id="2fd3" class="mz na iq jp b jq jr ju jv jy nb kc nc kg nd kk ne nf ng nh bi translated"><strong class="jp ir">阶段0 </strong> <br/>从当前节点分支，但删除了节点8.5.0+ <code class="fe nw nx ny no b">--experimental-modules</code>的大部分实现。</li><li id="b5f5" class="mz na iq jp b jq ni ju nj jy nk kc nl kg nm kk ne nf ng nh bi translated"><strong class="jp ir">第1阶段</strong> <br/>增加了“最小内核”特性，模块工作组认为这些特性可能会出现在任何潜在的新es模块实现中。</li><li id="8bce" class="mz na iq jp b jq ni ju nj jy nk kc nl kg nm kk ne nf ng nh bi translated"><strong class="jp ir">第2阶段</strong> <br/>用足够的功能充实实现，作为一个最小可行的产品，它应该对普通用户有用。</li><li id="53ae" class="mz na iq jp b jq ni ju nj jy nk kc nl kg nm kk ne nf ng nh bi translated"><strong class="jp ir">第三阶段</strong> <br/>改善用户体验，延伸MVP。</li></ul><p id="a888" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这项工作目前正处于第三阶段。</p><h1 id="d196" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">ECMAScript 2018</h1><p id="fb8a" class="pw-post-body-paragraph jn jo iq jp b jq mi js jt ju mj jw jx jy mk ka kb kc ml ke kf kg mm ki kj kk ij bi translated"><a class="ae kl" href="http://www.ecma-international.org/ecma-262/9.0/" rel="noopener ugc nofollow" target="_blank"> ECMAScript 2018 </a>于2018年6月公布。</p><h2 id="38b4" class="mn ll iq bd lm mo mp dn lq mq mr dp lu jy ms mt ly kc mu mv mc kg mw mx mg my bi translated">异步迭代器</h2><p id="c6aa" class="pw-post-body-paragraph jn jo iq jp b jq mi js jt ju mj jw jx jy mk ka kb kc ml ke kf kg mm ki kj kk ij bi translated">异步操作符枚举异步流数据，其操作类似于典型的操作符，并使用一种语法形式<code class="fe nw nx ny no b">for — await — of</code>。异步操作符和普通操作符的区别在于它返回Promise对象。</p><pre class="kn ko kp kq gt nn no np nq aw nr bi"><span id="c6ee" class="mn ll iq no b gy ns nt l nu nv">async function test() {  <br/>    // Regular Iterator<br/>    for (const i of list) ...</span><span id="4104" class="mn ll iq no b gy nz nt l nu nv">// Async Iterator<br/>    for await (const i of asyncList) ...<br/>}</span></pre><p id="29d4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您正在处理异步调用流，您可以创建一个异步操作符工厂。</p><pre class="kn ko kp kq gt nn no np nq aw nr bi"><span id="85f5" class="mn ll iq no b gy ns nt l nu nv">// example from: <a class="ae kl" href="https://jakearchibald.com/2017/async-iterators-and-generators/" rel="noopener ugc nofollow" target="_blank">https://jakearchibald.com/2017/async-iterators-and-generators/</a><br/>async function* asyncRandomNumbers() {<br/>    const url = "<a class="ae kl" href="https://www.random.org/integers/?num=1&amp;min=1&amp;max=100&amp;col=1&amp;base=10&amp;format=plain&amp;rnd=new" rel="noopener ugc nofollow" target="_blank">https://www.random.org/integers/?num=1&amp;min=1&amp;max=100&amp;col=1&amp;base=10&amp;format=plain&amp;rnd=new</a>";</span><span id="1775" class="mn ll iq no b gy nz nt l nu nv">while (true) {<br/>        const response = await fetch(url);<br/>        const text = await response.text();<br/>        yield Number(text);<br/>    }<br/>}</span><span id="cea6" class="mn ll iq no b gy nz nt l nu nv">(async function() {<br/>    let i = 0;</span><span id="e90f" class="mn ll iq no b gy nz nt l nu nv">for await (const number of asyncRandomNumbers()) {<br/>        console.log(++i, "=&gt;", number);<br/>        if (i === 10) break;<br/>    }<br/>})();</span><span id="206a" class="mn ll iq no b gy nz nt l nu nv">// 1 "=&gt;" 65<br/>// 2 "=&gt;" 62<br/>// ...</span></pre><h2 id="018b" class="mn ll iq bd lm mo mp dn lq mq mr dp lu jy ms mt ly kc mu mv mc kg mw mx mg my bi translated">对象静止/扩散属性</h2><p id="7286" class="pw-post-body-paragraph jn jo iq jp b jq mi js jt ju mj jw jx jy mk ka kb kc ml ke kf kg mm ki kj kk ij bi translated">与ECMAScript 2015中的Rest参数和spread运算符规范一样，该提案引入了<a class="ae kl" href="https://github.com/tc39/proposal-object-rest-spread" rel="noopener ugc nofollow" target="_blank">对象析构赋值和对象文字的Spread属性</a>。</p><pre class="kn ko kp kq gt nn no np nq aw nr bi"><span id="fb0a" class="mn ll iq no b gy ns nt l nu nv">// Rest property<br/>let { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 };  <br/>x; // 1  <br/>y; // 2  <br/>z; // { a: 3, b: 4 }</span><span id="dcfe" class="mn ll iq no b gy nz nt l nu nv">// Spread property<br/>let n = { x, y, ...z };  <br/>n; // { x: 1, y: 2, a: 3, b: 4 }</span></pre><h2 id="f1a0" class="mn ll iq bd lm mo mp dn lq mq mr dp lu jy ms mt ly kc mu mv mc kg mw mx mg my bi translated">模板字面语法限制的下降</h2><p id="5a62" class="pw-post-body-paragraph jn jo iq jp b jq mi js jt ju mj jw jx jy mk ka kb kc ml ke kf kg mm ki kj kk ij bi translated">模板文字删除了对转义序列使用的限制(参见“<a class="ae kl" href="https://tc39.github.io/proposal-template-literal-revision/" rel="noopener ugc nofollow" target="_blank">模板文字修订</a>”)。</p><p id="7b5d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">标记模板文字是一个接收模板并返回修改后的字符串的函数。传递给函数的字符串可以是以下类型之一:</p><ul class=""><li id="01a2" class="mz na iq jp b jq jr ju jv jy nb kc nc kg nd kk ne nf ng nh bi translated">熟:转义序列被解释</li><li id="217a" class="mz na iq jp b jq ni ju nj jy nk kc nl kg nm kk ne nf ng nh bi translated">Raw:转义序列是普通文本。<br/>模板字符串中未解释的值由<a class="ae kl" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/raw" rel="noopener ugc nofollow" target="_blank"> String.raw() </a>方法处理。</li></ul><pre class="kn ko kp kq gt nn no np nq aw nr bi"><span id="bda5" class="mn ll iq no b gy ns nt l nu nv">function tagFunc(str, substs) {  <br/>    return str;<br/>}</span><span id="d1a5" class="mn ll iq no b gy nz nt l nu nv">const result = tagFunc`\u{4B}`;  <br/>result;  // ["K"]  <br/>result.raw; // ["\u{4B}"]</span></pre><p id="c444" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以前，如果模板在反斜杠后有一些字符序列，它被视为非法，不会返回原始字符串。</p><ul class=""><li id="0920" class="mz na iq jp b jq jr ju jv jy nb kc nc kg nd kk ne nf ng nh bi translated"><code class="fe nw nx ny no b">\u</code>:统一码(如<code class="fe nw nx ny no b">\u004B</code>)</li><li id="ab31" class="mz na iq jp b jq ni ju nj jy nk kc nl kg nm kk ne nf ng nh bi translated"><code class="fe nw nx ny no b">\x</code>:十六进制(如<code class="fe nw nx ny no b">\x4B</code>)</li><li id="c243" class="mz na iq jp b jq ni ju nj jy nk kc nl kg nm kk ne nf ng nh bi translated"><code class="fe nw nx ny no b">\positive</code>:八进制(如<code class="fe nw nx ny no b">\141</code>)</li></ul><p id="965c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">ECMAScript 2018消除了所有与转义序列相关的语法限制，并以原始形式返回字符串。在这种情况下，解释的值返回<code class="fe nw nx ny no b">undefined</code>。</p><pre class="kn ko kp kq gt nn no np nq aw nr bi"><span id="3a37" class="mn ll iq no b gy ns nt l nu nv">const result = tagFunc`\131`;  <br/>result;  // [undefined]  <br/>result.raw; // ["\131"]</span></pre><blockquote class="ld le lf"><p id="07dc" class="jn jo lg jp b jq jr js jt ju jv jw jx lh jz ka kb li kd ke kf lj kh ki kj kk ij bi translated">请查看“<a class="ae kl" href="http://2ality.com/2016/09/template-literal-revision.html" rel="noopener ugc nofollow" target="_blank"> ES2018:模板文字修订版</a>”以了解有关模板文字中的问题和解决方案的更多信息。</p></blockquote><h2 id="b7da" class="mn ll iq bd lm mo mp dn lq mq mr dp lu jy ms mt ly kc mu mv mc kg mw mx mg my bi translated">承诺.原型.最终</h2><p id="9458" class="pw-post-body-paragraph jn jo iq jp b jq mi js jt ju mj jw jx jy mk ka kb kc ml ke kf kg mm ki kj kk ij bi translated">像<code class="fe nw nx ny no b">try...catch</code>语句的<code class="fe nw nx ny no b">finally</code>语法一样，这个提议为Promise对象引入了相似性用法。</p><p id="d8cd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe nw nx ny no b">finally</code>语法是在最后无条件执行的代码块，不管Promise对象的处理状态(“resolve”或“reject”)。一旦调用了Promise对象，不管结果如何，都将执行这个代码块。</p><pre class="kn ko kp kq gt nn no np nq aw nr bi"><span id="6c5e" class="mn ll iq no b gy ns nt l nu nv">let isLoading = true;</span><span id="8f2c" class="mn ll iq no b gy nz nt l nu nv">fetch("<a class="ae kl" href="https://www.random.org/integers/?num=1&amp;min=1&amp;max=100&amp;col=1&amp;base=10&amp;format=plain&amp;rnd=new" rel="noopener ugc nofollow" target="_blank">https://www.random.org/integers/?num=1&amp;min=1&amp;max=100&amp;col=1&amp;base=10&amp;format=plain&amp;rnd=new</a>")  <br/>.then(function(res) {<br/>    if(res) {<br/>        return res.text();<br/>    }</span><span id="1419" class="mn ll iq no b gy nz nt l nu nv">throw new TypeError("Error");<br/>})<br/>.then(function(text) { /* Success */ })<br/>.catch(function(error) { /* Error */ })<br/>.finally(function() {<br/>    // will be performed regardless success or error<br/>    isLoading = false;<br/>});</span></pre><blockquote class="ld le lf"><p id="5ebe" class="jn jo lg jp b jq jr js jt ju jv jw jx lh jz ka kb li kd ke kf lj kh ki kj kk ij bi translated">从MDN的<a class="ae kl" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/finally" rel="noopener ugc nofollow" target="_blank">promise . prototype . finally</a>文档中查看更多细节。</p></blockquote><h2 id="bd48" class="mn ll iq bd lm mo mp dn lq mq mr dp lu jy ms mt ly kc mu mv mc kg mw mx mg my bi translated">正则表达式</h2><p id="2a55" class="pw-post-body-paragraph jn jo iq jp b jq mi js jt ju mj jw jx jy mk ka kb kc ml ke kf kg mm ki kj kk ij bi translated">增加了几个正则表达式建议。</p><ul class=""><li id="068f" class="mz na iq jp b jq jr ju jv jy nb kc nc kg nd kk ne nf ng nh bi translated"><a class="ae kl" href="http://2ality.com/2017/07/regexp-dotall-flag.html" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> s (dotAll)标志为正则表达式</strong> </a> <strong class="jp ir"> <br/> </strong>的圆点(。)匹配所有字符，但不针对<code class="fe nw nx ny no b">\r</code>也不针对<code class="fe nw nx ny no b">\n</code>。为了解决这个问题，引入了新的<a class="ae kl" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#Advanced_searching_with_flags_2" rel="noopener ugc nofollow" target="_blank">旗</a>T2。</li></ul><pre class="kn ko kp kq gt nn no np nq aw nr bi"><span id="6781" class="mn ll iq no b gy ns nt l nu nv">// previous<br/>/./test("a");  // true<br/>/./.test("\n");  // false</span><span id="7f75" class="mn ll iq no b gy nz nt l nu nv">// dotAll flag<br/>/./<strong class="no ir">s</strong>.test("\n");  // true</span></pre><ul class=""><li id="f67c" class="mz na iq jp b jq jr ju jv jy nb kc nc kg nd kk ne nf ng nh bi translated"><a class="ae kl" href="https://github.com/tc39/proposal-regexp-named-groups" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> RegExp命名捕获组</strong> </a> <br/>提供了命名捕获组的能力。<code class="fe nw nx ny no b">(?<strong class="jp ir">&lt;name&gt;</strong>pattern)</code>，将把<code class="fe nw nx ny no b"><strong class="jp ir">&lt;name&gt;</strong></code>添加到捕获组模式中，然后用这个名字作为引用捕获。</li></ul><pre class="kn ko kp kq gt nn no np nq aw nr bi"><span id="2a4c" class="mn ll iq no b gy ns nt l nu nv">const rx = /(?<strong class="no ir">&lt;year&gt;</strong>[0-9]{4})-(?<strong class="no ir">&lt;month&gt;</strong>[0-9]{2})/;  <br/>const match = rx.exec('2018-03');  <br/>match.groups.<strong class="no ir">year</strong>; // 2018  <br/>match.groups.<strong class="no ir">month</strong>; // 03</span></pre><ul class=""><li id="de30" class="mz na iq jp b jq jr ju jv jy nb kc nc kg nd kk ne nf ng nh bi translated"><a class="ae kl" href="http://2ality.com/2017/05/regexp-lookbehind-assertions.html" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> RegExp Lookbehind断言</strong> </a> <br/>在正则表达式中，特定模式的值后面跟(lookahed)或后面不跟(负look ahed)一个字符串。<br/>相比之下，这一提议提供了寻找特定模式以超前(lookbehind)或不超前(negative lookbehind)的能力。</li></ul><pre class="kn ko kp kq gt nn no np nq aw nr bi"><span id="7030" class="mn ll iq no b gy ns nt l nu nv">// positive lookahead<br/>/aa(?=bb)/.test("aabb"); // true</span><span id="d65e" class="mn ll iq no b gy nz nt l nu nv">// negative lookahead<br/>/aa(?!bb)/.test("aac");  // true</span><span id="df43" class="mn ll iq no b gy nz nt l nu nv">// positive lookbehind<br/>/(?&lt;=aa)bb/.test("aabb");  // true</span><span id="2a2b" class="mn ll iq no b gy nz nt l nu nv">// negative lookbehind<br/>/(?&lt;!=aa)bb/.test("bbbb");  // true</span></pre><ul class=""><li id="a89b" class="mz na iq jp b jq jr ju jv jy nb kc nc kg nd kk ne nf ng nh bi translated"><a class="ae kl" href="https://github.com/tc39/proposal-regexp-unicode-property-escapes" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> RegExp Unicode属性转义</strong> </a> <br/> Unicode属性转义是在设置了<code class="fe nw nx ny no b"><a class="ae kl" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/unicode" rel="noopener ugc nofollow" target="_blank">u</a></code> <a class="ae kl" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/unicode" rel="noopener ugc nofollow" target="_blank">标志</a>的正则表达式中可用的一种新型转义序列。</li></ul><pre class="kn ko kp kq gt nn no np nq aw nr bi"><span id="3414" class="mn ll iq no b gy ns nt l nu nv">/^<strong class="no ir">\p{</strong>White_Space<strong class="no ir">}</strong>+$/<strong class="no ir">u</strong>.test('\t \n\r');  // true /^<strong class="no ir">\p{</strong>Script=Greek<strong class="no ir">}</strong>+$/<strong class="no ir">u</strong>.test('μετά');  // true</span></pre><h1 id="6a9f" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">ECMAScript 2019</h1><p id="e1eb" class="pw-post-body-paragraph jn jo iq jp b jq mi js jt ju mj jw jx jy mk ka kb kc ml ke kf kg mm ki kj kk ij bi translated"><a class="ae kl" href="https://tc39.github.io/ecma262/2019/" rel="noopener ugc nofollow" target="_blank"> ECMAScript 2019 </a>处于候选草稿状态。鉴于之前的发布日期，最终版本预计将于2019年6月左右公布。</p><h2 id="b118" class="mn ll iq bd lm mo mp dn lq mq mr dp lu jy ms mt ly kc mu mv mc kg mw mx mg my bi translated">array . prototype . flat()/array . prototype . flat map()</h2><p id="a6aa" class="pw-post-body-paragraph jn jo iq jp b jq mi js jt ju mj jw jx jy mk ka kb kc ml ke kf kg mm ki kj kk ij bi translated"><a class="ae kl" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/flat" rel="noopener ugc nofollow" target="_blank"> Array.prototype.flat() </a>方法和<a class="ae kl" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/flatMap" rel="noopener ugc nofollow" target="_blank">array . prototype . flat map()</a>方法递归地查找指定深度的子数组元素，并创建一个新数组连接到其中。</p><pre class="kn ko kp kq gt nn no np nq aw nr bi"><span id="6e47" class="mn ll iq no b gy ns nt l nu nv">// Array.prototype.flat<br/>[1, 2, [3, 4]].flat();  // [1, 2, 3, 4]<br/>[1, 2, [3, 4, [5, 6]]].flat(1);  // [1, 2, 3, 4, [5, 6]]</span><span id="e3db" class="mn ll iq no b gy nz nt l nu nv">// Array.prototype.flatMap<br/>[1, 2, 3, 4].map(x =&gt; [x * 2]);  // [[2], [4], [6], [8]]<br/>[1, 2, 3, 4].flatMap(x =&gt; [x * 2]);  // [2, 4, 6, 8]</span></pre><blockquote class="ld le lf"><p id="3ff0" class="jn jo lg jp b jq jr js jt ju jv jw jx lh jz ka kb li kd ke kf lj kh ki kj kk ij bi translated">关于命名的小故事。<strong class="jp ir">平()</strong>:</p><p id="92d2" class="jn jo lg jp b jq jr js jt ju jv jw jx lh jz ka kb li kd ke kf lj kh ki kj kk ij bi translated">最初提议的名称是"。<strong class="jp ir">展平()</strong>”。但是，MoTools(广泛使用的遗留库)已经在同名的'<strong class="jp ir">array . prototype . flatten()'</strong>下提供了类似的功能。若名”。flaten()”按原样被接受，它可能对所有使用MoTools的网站都有问题。</p><p id="e5e1" class="jn jo lg jp b jq jr js jt ju jv jw jx lh jz ka kb li kd ke kf lj kh ki kj kk ij bi translated">为了避免冲突的可能性，<strong class="jp ir">。flatten() </strong>更名为<strong class="jp ir">。</strong>平()。<br/>-1)<a class="ae kl" href="https://github.com/tc39/proposal-flatMap/pull/56" rel="noopener ugc nofollow" target="_blank">的名称。‘smoosh()</a>’是候选人之一。<br/> - 2)也有人建议改变MoTools的flatten()的行为，使其与ECMAScript 2019一样工作(参见“<a class="ae kl" href="https://github.com/mootools/mootools-core/issues/2797" rel="noopener ugc nofollow" target="_blank">更新Array.prototype.flaten以匹配TC39提案</a>”)。但是，这可以让许多不再更新的网站停止工作，比如汤姆·戴尔的推特(他参与了<a class="ae kl" href="https://emberjs.com/" rel="noopener ugc nofollow" target="_blank">恩伯</a>和<a class="ae kl" href="https://github.com/sproutcore/sproutcore" rel="noopener ugc nofollow" target="_blank"> SproutCore </a>的开发)。</p></blockquote><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/565d7b212a81aa91c543110b6cc24a3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1188/format:webp/0*wOQi3akg7tFFyWCv.png"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated"><a class="ae kl" href="https://twitter.com/tomdale/status/971288054966247430" rel="noopener ugc nofollow" target="_blank">https://twitter.com/tomdale/status/971288054966247430</a></figcaption></figure><h2 id="938f" class="mn ll iq bd lm mo mp dn lq mq mr dp lu jy ms mt ly kc mu mv mc kg mw mx mg my bi translated">Object.fromEntries()</h2><p id="c818" class="pw-post-body-paragraph jn jo iq jp b jq mi js jt ju mj jw jx jy mk ka kb kc ml ke kf kg mm ki kj kk ij bi translated"><a class="ae kl" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/fromEntries" rel="noopener ugc nofollow" target="_blank"> Object.fromEntries() </a>，将一列键值对转换成一个对象。</p><pre class="kn ko kp kq gt nn no np nq aw nr bi"><span id="059f" class="mn ll iq no b gy ns nt l nu nv">const entries = new Map([  <br/>    ['foo', 'bar'],<br/>    ['baz', 42]<br/>]);</span><span id="c188" class="mn ll iq no b gy nz nt l nu nv">Object.fromEntries(entries);  // { foo: "bar", baz: 42 }</span></pre><h2 id="80b1" class="mn ll iq bd lm mo mp dn lq mq mr dp lu jy ms mt ly kc mu mv mc kg mw mx mg my bi translated">String.prototype.trimStart() /。特里蒙德()</h2><p id="f21d" class="pw-post-body-paragraph jn jo iq jp b jq mi js jt ju mj jw jx jy mk ka kb kc ml ke kf kg mm ki kj kk ij bi translated">删除开头(<a class="ae kl" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/trimStart" rel="noopener ugc nofollow" target="_blank">string . prototype . trim start()</a>—别名)的空白。trimLeft()')或从末尾(<a class="ae kl" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/trimEnd" rel="noopener ugc nofollow" target="_blank">string . prototype . trimend()</a>—aliased '开始。trimRight()')。</p><pre class="kn ko kp kq gt nn no np nq aw nr bi"><span id="c53b" class="mn ll iq no b gy ns nt l nu nv">const greeting = "   Hello world!   ";</span><span id="495e" class="mn ll iq no b gy nz nt l nu nv">greeting.trimStart();  // "Hello world!   "  <br/>greeting.trimEnd();  // "   Hello world!"</span></pre><h2 id="86cb" class="mn ll iq bd lm mo mp dn lq mq mr dp lu jy ms mt ly kc mu mv mc kg mw mx mg my bi translated">Symbol.prototype .描述属性</h2><p id="0bd9" class="pw-post-body-paragraph jn jo iq jp b jq mi js jt ju mj jw jx jy mk ka kb kc ml ke kf kg mm ki kj kk ij bi translated">Symbol.prototype.description属性返回Symbol对象的可选只读描述。</p><pre class="kn ko kp kq gt nn no np nq aw nr bi"><span id="bb7a" class="mn ll iq no b gy ns nt l nu nv">// will return 'Test Description'<br/>Symbol("Test Description").description;</span></pre><h2 id="156f" class="mn ll iq bd lm mo mp dn lq mq mr dp lu jy ms mt ly kc mu mv mc kg mw mx mg my bi translated">可选catch绑定</h2><p id="83c4" class="pw-post-body-paragraph jn jo iq jp b jq mi js jt ju mj jw jx jy mk ka kb kc ml ke kf kg mm ki kj kk ij bi translated"><a class="ae kl" href="https://github.com/tc39/proposal-optional-catch-binding" rel="noopener ugc nofollow" target="_blank">可选的catch绑定</a>提议，是允许在<code class="fe nw nx ny no b">try...catch</code>语句中的catch语法中不使用参数时省略参数。</p><pre class="kn ko kp kq gt nn no np nq aw nr bi"><span id="61cb" class="mn ll iq no b gy ns nt l nu nv">// Traditional way<br/>try { ··· } catch<strong class="no ir">(e)</strong> { ··· }</span><span id="ba6e" class="mn ll iq no b gy nz nt l nu nv">// Optional catch binding<br/>// if don't need the use of parameter, it can be omitted<br/>try { ··· } catch { ··· }</span></pre><h2 id="1638" class="mn ll iq bd lm mo mp dn lq mq mr dp lu jy ms mt ly kc mu mv mc kg mw mx mg my bi translated">Array .原型. sort()稳定性</h2><p id="ee62" class="pw-post-body-paragraph jn jo iq jp b jq mi js jt ju mj jw jx jy mk ka kb kc ml ke kf kg mm ki kj kk ij bi translated"><a class="ae kl" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort" rel="noopener ugc nofollow" target="_blank"> Array.prototype.sort() </a>方法使用了不稳定的<a class="ae kl" href="https://en.wikipedia.org/wiki/Quicksort" rel="noopener ugc nofollow" target="_blank">快速排序</a>算法，对超过10个元素的数组进行排序。为了确保数组正确对齐，ECMAScript 2019对Array.prototype.short()使用了<a class="ae kl" href="https://en.wikipedia.org/wiki/Timsort" rel="noopener ugc nofollow" target="_blank"> Timsort </a>算法。</p><p id="3179" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该规范目前适用于所有JavaScript引擎。但是，Microsoft Edge with ChakraCore会对包含512个以上元素的数组产生排序错误。</p><p id="823b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面的截图展示了Edge和Firefox上的<a class="ae kl" href="https://mathiasbynens.be/demo/sort-stability-512" rel="noopener ugc nofollow" target="_blank">稳定性测试结果</a>。如你所见，Edge正在失败。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi ob"><img src="../Images/1bd0d974f0a82bb32e1e7ddb1b9d5b07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*F2NAb7ZpChASOBr5.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">稳定性测试结果:(左)微软Edge 17.17134 /(右)火狐66.0.2</figcaption></figure><blockquote class="ld le lf"><p id="b618" class="jn jo lg jp b jq jr js jt ju jv jw jx lh jz ka kb li kd ke kf lj kh ki kj kk ij bi translated">更多详细讨论请参见:“<a class="ae kl" href="https://docs.google.com/presentation/d/1mHvxDciqsAchhjepMZlU5fn1DBvglCXSjDWUEtsPGvI/edit#slide=id.g41da6c5107_0_0" rel="noopener ugc nofollow" target="_blank">数组#排序稳定性</a>”。</p></blockquote><h2 id="5650" class="mn ll iq bd lm mo mp dn lq mq mr dp lu jy ms mt ly kc mu mv mc kg mw mx mg my bi translated">格式良好的JSON.stringify</h2><p id="810e" class="pw-post-body-paragraph jn jo iq jp b jq mi js jt ju mj jw jx jy mk ka kb kc ml ke kf kg mm ki kj kk ij bi translated"><a class="ae kl" href="https://tools.ietf.org/html/rfc8259#section-8.1" rel="noopener ugc nofollow" target="_blank"> RFC 8259 </a>指定要编码为UTF-8格式的JSON文本，用于JSON对象数据交换。但是当使用JSON.stringify()时，一些UTF-16代码(从0xD800到0xDFFFF的字符，被归类为“代理”)没有在UTF-8中编码。</p><p id="fb76" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">ECMAScript 2019返回转义序列，而不是返回无效的Unicode字符串，如下图所示(Edge)。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi oc"><img src="../Images/3a831962c1477d35f274a9f622ab22bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:616/format:webp/0*S22A-Eev27qiL_Ml.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">JSON.stringify()在Edge和Firefox上的结果</figcaption></figure><blockquote class="ld le lf"><p id="28f1" class="jn jo lg jp b jq jr js jt ju jv jw jx lh jz ka kb li kd ke kf lj kh ki kj kk ij bi translated">欲了解更多详情，请查看<a class="ae kl" href="https://github.com/tc39/proposal-well-formed-stringify" rel="noopener ugc nofollow" target="_blank">提案文件</a>。</p></blockquote><h2 id="88dc" class="mn ll iq bd lm mo mp dn lq mq mr dp lu jy ms mt ly kc mu mv mc kg mw mx mg my bi translated">包含JSON</h2><p id="52ed" class="pw-post-body-paragraph jn jo iq jp b jq mi js jt ju mj jw jx jy mk ka kb kc ml ke kf kg mm ki kj kk ij bi translated">ECMAScript声称JSON是<code class="fe nw nx ny no b"><a class="ae kl" href="https://tc39.github.io/ecma262/#sec-json.parse" rel="noopener ugc nofollow" target="_blank">JSON.parse</a></code>中的子集，但这不是<strong class="jp ir">真的</strong>，因为JSON字符串可以包含未转义的U+2028行分隔符和U+2029段落分隔符。</p><p id="7b79" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个提议表明ECMA-262可以扩展，以允许这些字符不破坏JSON成为ECMAScript的子集。</p><pre class="kn ko kp kq gt nn no np nq aw nr bi"><span id="4c3c" class="mn ll iq no b gy ns nt l nu nv">// if ECMA is superset of JSON, these must be true<br/>eval('"\u2028"') === "\u2028"  // true  <br/>eval('"\u2029"') === "\u2029"  // true</span></pre><blockquote class="ld le lf"><p id="6682" class="jn jo lg jp b jq jr js jt ju jv jw jx lh jz ka kb li kd ke kf lj kh ki kj kk ij bi translated">要了解更多细节，请查看提案文档:<a class="ae kl" href="https://github.com/tc39/proposal-json-superset" rel="noopener ugc nofollow" target="_blank">包含JSON(又名JSON ⊂ ECMAScript) </a></p></blockquote><h2 id="22b0" class="mn ll iq bd lm mo mp dn lq mq mr dp lu jy ms mt ly kc mu mv mc kg mw mx mg my bi translated">Function.prototype.toString版本</h2><p id="3ee8" class="pw-post-body-paragraph jn jo iq jp b jq mi js jt ju mj jw jx jy mk ka kb kc ml ke kf kg mm ki kj kk ij bi translated">根据ECMAScript 2016中的定义，<em class="lg"> Function.prototype.toString()的结果会因引擎而异</em>。ECMAScript 2019确保返回定义的原始代码(参见“<a class="ae kl" href="https://tc39.es/Function-prototype-toString-revision/" rel="noopener ugc nofollow" target="_blank">function . prototype . tostring revision</a>”)。</p><p id="e3b0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当返回函数中定义的代码时，ECMAScript 2019使用以下算法返回函数中定义的代码字符串:</p><ul class=""><li id="b9df" class="mz na iq jp b jq jr ju jv jy nb kc nc kg nd kk ne nf ng nh bi translated"><strong class="jp ir">换行符</strong> : <br/> <code class="fe nw nx ny no b">\r\n</code> (Windows)或者<code class="fe nw nx ny no b">\n</code> (macOS)全部返回为Unix风格的<code class="fe nw nx ny no b">\n</code>。</li><li id="7316" class="mz na iq jp b jq ni ju nj jy nk kc nl kg nm kk ne nf ng nh bi translated"><strong class="jp ir">内置函数</strong> : <br/>所有没有通过ECMAScript定义的代码(主要是内置函数)都将作为<code class="fe nw nx ny no b">[native code]</code>返回。</li></ul><pre class="kn ko kp kq gt nn no np nq aw nr bi"><span id="565e" class="mn ll iq no b gy ns nt l nu nv">isNaN.toString();  // "function isNaN() { [native code] }"</span></pre><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi od"><img src="../Images/3bc30fcd6e368b4cd9e0e481bc2a8722.png" data-original-src="https://miro.medium.com/v2/resize:fit:772/format:webp/0*3cnHIRPVm4dM6o2i.png"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">“isNaN.toString()”在不同浏览器中的结果</figcaption></figure><ul class=""><li id="354d" class="mz na iq jp b jq jr ju jv jy nb kc nc kg nd kk ne nf ng nh bi translated"><strong class="jp ir">通过</strong> <code class="fe nw nx ny no b"><strong class="jp ir">Function</strong></code> <strong class="jp ir">和</strong> <code class="fe nw nx ny no b"><strong class="jp ir">GeneratorFunction</strong></code> <strong class="jp ir"> : </strong> <br/>引擎动态创建的函数必须创建适当的源代码并附加到函数上。</li><li id="49af" class="mz na iq jp b jq ni ju nj jy nk kc nl kg nm kk ne nf ng nh bi translated"><strong class="jp ir">其他情况:</strong> <br/>扔个<code class="fe nw nx ny no b">TypeError</code>。</li></ul><blockquote class="ld le lf"><p id="3129" class="jn jo lg jp b jq jr js jt ju jv jw jx lh jz ka kb li kd ke kf lj kh ki kj kk ij bi translated">更多详细信息，请查看:<a class="ae kl" href="http://2ality.com/2016/08/function-prototype-tostring.html" rel="noopener ugc nofollow" target="_blank">ES proposal:function . prototype . tostring revision</a></p></blockquote><h1 id="deea" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">ECMAScript 2020</h1><p id="9299" class="pw-post-body-paragraph jn jo iq jp b jq mi js jt ju mj jw jx jy mk ka kb kc ml ke kf kg mm ki kj kk ij bi translated">截至2019年3月1日，TC39回购主分支更新为指向下一个ECMAScript 2020。(参见<a class="ae kl" href="https://github.com/tc39/ecma262/commit/7a9a9b6b25c115fcda95e943e8875432636f2cfd" rel="noopener ugc nofollow" target="_blank">提交日志</a>)。</p><p id="bc3d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">至此，ECMAScript 2020完成的提案(阶段4)只有<a class="ae kl" href="https://github.com/tc39/String.prototype.matchAll" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir"><em class="lg">string . prototype . matchall()</em></strong></a>和<a class="ae kl" href="https://github.com/tc39/proposal-dynamic-import" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir"><em class="lg">import()</em></strong></a>而已，但随着时间的推移这些列表将包括更多的项目。</p><p id="91e6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="lg">string . prototype . match all()</em>方法的工作方式类似于<em class="lg"> String.prototype.match() </em>。当与<code class="fe nw nx ny no b">g(global)/y(sticky)</code>标志一起使用时，前者返回包含匹配字符串和匹配细节的迭代器。</p><pre class="kn ko kp kq gt nn no np nq aw nr bi"><span id="d38b" class="mn ll iq no b gy ns nt l nu nv">const str = "test1test2";  <br/>const rx = /t(e)(st(\d?))/g;</span><span id="c1e1" class="mn ll iq no b gy nz nt l nu nv">str.match(rx);  // ["test1", "test2"]</span><span id="3921" class="mn ll iq no b gy nz nt l nu nv">for (const match of str.matchAll(rx)) {  <br/>    // 1: ["test1", "e", "st1", "1", index: 0, input: "test1test2"]<br/>    // 2: ["test2", "e", "st2", "2", index: 5, input: "test1test2"]<br/>    match;<br/>}</span></pre><h2 id="ebd7" class="mn ll iq bd lm mo mp dn lq mq mr dp lu jy ms mt ly kc mu mv mc kg mw mx mg my bi translated">一些新的或不完整的建议</h2><p id="3669" class="pw-post-body-paragraph jn jo iq jp b jq mi js jt ju mj jw jx jy mk ka kb kc ml ke kf kg mm ki kj kk ij bi translated">让我们来看看一些有趣的提案还没有到最后阶段。</p><h2 id="f1fa" class="mn ll iq bd lm mo mp dn lq mq mr dp lu jy ms mt ly kc mu mv mc kg mw mx mg my bi translated">globalThis</h2><p id="b6c4" class="pw-post-body-paragraph jn jo iq jp b jq mi js jt ju mj jw jx jy mk ka kb kc ml ke kf kg mm ki kj kk ij bi translated">通常访问顶层对象是通过浏览器环境中的'<strong class="jp ir"> <em class="lg">窗口</em> </strong>'对象。</p><p id="db8a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">随着执行环境的扩展，访问顶层对象的方式也发生了变化。</p><ul class=""><li id="3226" class="mz na iq jp b jq jr ju jv jy nb kc nc kg nd kk ne nf ng nh bi translated">在Node.js环境中，通过'<strong class="jp ir"> <em class="lg">全局</em> </strong>'对象访问顶层对象。</li><li id="2847" class="mz na iq jp b jq ni ju nj jy nk kc nl kg nm kk ne nf ng nh bi translated">在HTML5规范中，有'<em class="lg"> Window </em>和'<strong class="jp ir"> <em class="lg"> WindowProxy </em> </strong>'用于此，而ECMAScript 2015规范中，两个对象以相同的方式访问顶级对象。</li></ul><blockquote class="ld le lf"><p id="70de" class="jn jo lg jp b jq jr js jt ju jv jw jx lh jz ka kb li kd ke kf lj kh ki kj kk ij bi translated">检查窗口和WindowProxy对象之间的差异的“<a class="ae kl" href="https://developer.mozilla.org/en-US/docs/Mozilla/Developer_guide/Inner_and_outer_windows" rel="noopener ugc nofollow" target="_blank">内部和外部窗口</a>”。</p></blockquote><p id="000a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不管环境如何，下面的代码是获取顶级对象(“全局”)引用的最简单的方法。但这种方法导致Chrome应用违反了<em class="lg">内容安全政策(CSP) </em>。(参见“<a class="ae kl" href="https://github.com/paulmillr/es6-shim/issues/301" rel="noopener ugc nofollow" target="_blank">es6-垫片断裂镀铬App CSP </a>”)。</p><pre class="kn ko kp kq gt nn no np nq aw nr bi"><span id="2fcc" class="mn ll iq no b gy ns nt l nu nv"><strong class="no ir">var</strong> global = Function('return this')();</span></pre><p id="eb09" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">众所周知的ES6兼容垫片库，<a class="ae kl" href="https://github.com/paulmillr/es6-shim" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> <em class="lg"> ES6垫片</em> </strong> </a>，使用下面的函数来获取全局对象，这是目前最常用也是最好的方法。</p><pre class="kn ko kp kq gt nn no np nq aw nr bi"><span id="0c8c" class="mn ll iq no b gy ns nt l nu nv">// <a class="ae kl" href="https://github.com/paulmillr/es6-shim/blob/003ee5d15ec1b05ae2ad5ddad3c02fcf8c266e2c/es6-shim.js#L176" rel="noopener ugc nofollow" target="_blank">https://github.com/paulmillr/es6-shim/blob/003ee5d15ec1b05ae2ad5ddad3c02fcf8c266e2c/es6-shim.js#L176</a><br/>var getGlobal = function () {  <br/>    /* global self, window, global */<br/>    // the only reliable means to get the global object is<br/>    // `Function('return this')()`<br/>    // However, this causes CSP violations in Chrome apps.<br/>    if (typeof self !== 'undefined') { return self; }<br/>    if (typeof window !== 'undefined') { return window; }<br/>    if (typeof global !== 'undefined') { return global; }<br/>    throw new Error('unable to locate global object');<br/>};</span></pre><p id="563b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">新提议“globalThis”旨在提供一种进入顶层的方式，摆脱依赖环境的不适。目前停留在“第三阶段”。尚未最终确定，但在Chrome 71和Firefox 65以及Node.js 12中，globalThis对象可以如下使用:</p><pre class="kn ko kp kq gt nn no np nq aw nr bi"><span id="be15" class="mn ll iq no b gy ns nt l nu nv">globalThis.setTimeout;  // window.setTimeout</span></pre><blockquote class="ld le lf"><p id="dfad" class="jn jo lg jp b jq jr js jt ju jv jw jx lh jz ka kb li kd ke kf lj kh ki kj kk ij bi translated">关于'<strong class="jp ir"> globalThis </strong>名称:</p><p id="3fad" class="jn jo lg jp b jq jr js jt ju jv jw jx lh jz ka kb li kd ke kf lj kh ki kj kk ij bi translated">类似于“Array.prototype.flat()”的情况，第一个建议的名称是“global”。但是这个名字的使用，<a class="ae kl" href="https://github.com/tc39/proposal-global/issues/20" rel="noopener ugc nofollow" target="_blank">报破了flickr.com</a>的报道，从而让把名字改成了‘global this’。</p></blockquote><h2 id="5091" class="mn ll iq bd lm mo mp dn lq mq mr dp lu jy ms mt ly kc mu mv mc kg mw mx mg my bi translated">类字段声明</h2><p id="1b94" class="pw-post-body-paragraph jn jo iq jp b jq mi js jt ju mj jw jx jy mk ka kb kc ml ke kf kg mm ki kj kk ij bi translated">从Babel 7 . 1 . 0(2018年9月17日发布)开始可以使用类字段声明。然而，这个提议还没有达到最后阶段，目前停留在“第三阶段”。</p><p id="9ebe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个提议以一种更加直观和简单的方式为类变量引入了声明性语法。</p><p id="b7f7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">初始化<br/> </strong>初始化实例变量是通过构造函数实现的。</p><pre class="kn ko kp kq gt nn no np nq aw nr bi"><span id="de3e" class="mn ll iq no b gy ns nt l nu nv">class MyClass {  <br/>    constructor() {<br/>        this.x = 1;<br/>        this.y = 2;<br/>    }<br/>}</span></pre><p id="695b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用class字段，实例变量可以被定义为下面代码的<code class="fe nw nx ny no b">//Initializer</code>部分，初始化区域在构造函数运行之前运行。</p><pre class="kn ko kp kq gt nn no np nq aw nr bi"><span id="2007" class="mn ll iq no b gy ns nt l nu nv">class MyClass {  <br/>    // Initializer<br/>    x = 1;<br/>    y = 2;<br/>    log = console.log("Initializer");</span><span id="0dff" class="mn ll iq no b gy nz nt l nu nv">    constructor() {<br/>        console.log("Constructor:", this.x, this.y);<br/>    }<br/>}</span><span id="6e14" class="mn ll iq no b gy nz nt l nu nv">new MyClass();  <br/>// Initializer<br/>// Constructor: 1 2</span></pre><p id="27ea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">私有声明<br/>但是这实际上并没有让变量或方法作为私有变量工作(好吧，有一种方法可以让变量或方法作为私有变量工作)。</strong></p><pre class="kn ko kp kq gt nn no np nq aw nr bi"><span id="678f" class="mn ll iq no b gy ns nt l nu nv">function MyClass() {  <br/>    this._x = 1;<br/>    this._y = 2;<br/>}</span><span id="4954" class="mn ll iq no b gy nz nt l nu nv">MyClass.prototype.getX = function() {  <br/>    return this._x;<br/>}</span></pre><p id="f041" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">私有声明器使用数字符号(<strong class="jp ir"> # </strong>)作为前缀来显式声明它是私有的。以' # '开头的变量或方法只能在类块中访问。</p><pre class="kn ko kp kq gt nn no np nq aw nr bi"><span id="537c" class="mn ll iq no b gy ns nt l nu nv">class MyClass {  <br/>    #foo; // private field</span><span id="4a13" class="mn ll iq no b gy nz nt l nu nv">    constructor(foo) {<br/>        this.#foo = foo;<br/>    }</span><span id="a106" class="mn ll iq no b gy nz nt l nu nv">    incFoo() {<br/>        this.#foo++;<br/>    }<br/>}</span></pre><p id="7c42" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">声明和访问<br/> </strong>下面是一个简单的以各种形式声明和访问类字段的例子。</p><pre class="kn ko kp kq gt nn no np nq aw nr bi"><span id="6ebd" class="mn ll iq no b gy ns nt l nu nv">class MyClass {  <br/>    A = 1;  // (a) instance field<br/>    static B = 2;  // (b) static class field<br/>    #C = 3;  // (c) private field</span><span id="5ef8" class="mn ll iq no b gy nz nt l nu nv">    getPrivate() {<br/>        return this.#C;<br/>    }<br/>}</span><span id="2ebc" class="mn ll iq no b gy nz nt l nu nv">new MyClass().A;  // 1<br/>MyClass.B;  // 2<br/>new MyClass().getPrivate();  // 3</span></pre><blockquote class="ld le lf"><p id="ad4e" class="jn jo lg jp b jq jr js jt ju jv jw jx lh jz ka kb li kd ke kf lj kh ki kj kk ij bi translated">查看<a class="ae kl" href="http://2ality.com/2017/07/class-fields.html" rel="noopener ugc nofollow" target="_blank"> ES建议:类别字段</a>了解更多详情。</p></blockquote><h2 id="2324" class="mn ll iq bd lm mo mp dn lq mq mr dp lu jy ms mt ly kc mu mv mc kg mw mx mg my bi translated">内置模块</h2><p id="f406" class="pw-post-body-paragraph jn jo iq jp b jq mi js jt ju mj jw jx jy mk ka kb kc ml ke kf kg mm ki kj kk ij bi translated">当前的“阶段1”内置模块规格与ESM相同。普通ESM的不同之处在于，这些是“<strong class="jp ir">内置</strong>”并随浏览器本身一起分发。</p><p id="9742" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">内置模块，不直接暴露给全局。仅通过导入语法可用。如果浏览器支持内置模块，则这些模块以“<strong class="jp ir"> std: </strong>前缀+模块名导入，如下例所示。在本例中，负载<a class="ae kl" href="https://wicg.github.io/kv-storage/" rel="noopener ugc nofollow" target="_blank"> KV存储模块</a>。</p><pre class="kn ko kp kq gt nn no np nq aw nr bi"><span id="92c0" class="mn ll iq no b gy ns nt l nu nv">import {storage, StorageArea} from "<strong class="no ir">std:</strong>kv-storage";</span></pre><p id="88b5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">KV存储模块和<a class="ae kl" href="https://github.com/WICG/import-maps" rel="noopener ugc nofollow" target="_blank">进口地图提案</a>与内置模块规格密切相关。这两个不是ECMAScript规范的一部分，它们属于WICG(Web孵化器社区组织)。</p><p id="143c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> KV存储模块<br/> </strong> Chrome 74，增加了<a class="ae kl" href="https://developers.google.com/web/updates/2019/03/kv-storage" rel="noopener ugc nofollow" target="_blank">第一个内置模块，KV存储</a>。KV Storage解决了<a class="ae kl" href="https://developer.mozilla.org/ko/docs/Web/API/Window/localStorage" rel="noopener ugc nofollow" target="_blank"> localStorage </a>所具有的<a class="ae kl" href="https://hacks.mozilla.org/2012/03/there-is-no-simple-solution-for-local-storage/" rel="noopener ugc nofollow" target="_blank">性能问题</a>，并且继承了简单API的优点。</p><ul class=""><li id="901d" class="mz na iq jp b jq jr ju jv jy nb kc nc kg nd kk ne nf ng nh bi translated">在Chrome 74中，可以用<code class="fe nw nx ny no b">chrome://flags/#enable-experimental-web-platform-features</code>标志启用KV存储。</li><li id="5cce" class="mz na iq jp b jq ni ju nj jy nk kc nl kg nm kk ne nf ng nh bi translated">参见“<a class="ae kl" href="https://rollup-built-in-modules.glitch.me/" rel="noopener ugc nofollow" target="_blank">内置模块演示</a>”页的KV存储演示。</li></ul><p id="d27f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">KV Storage有类似于<a class="ae kl" href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Map" rel="noopener ugc nofollow" target="_blank">映射对象</a>的API。字符串和可序列化的数据类型可以用作键值。它返回一个承诺或异步迭代器，它们被异步处理。</p><p id="a941" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这两个命名的导出分别是“<strong class="jp ir"> <em class="lg">存储</em> </strong>”和“<strong class="jp ir"> <em class="lg">存储区域</em> </strong>”。</p><ul class=""><li id="7cd5" class="mz na iq jp b jq jr ju jv jy nb kc nc kg nd kk ne nf ng nh bi translated"><strong class="jp ir">存储:</strong> <br/>是<code class="fe nw nx ny no b"><strong class="jp ir">StorageArea</strong></code> <strong class="jp ir"> </strong>类的实例，名称为<code class="fe nw nx ny no b"><strong class="jp ir">default</strong></code>(默认存储数据库为'<strong class="jp ir"> <em class="lg"> kv-storage:默认</em> </strong>')。</li><li id="a4f6" class="mz na iq jp b jq ni ju nj jy nk kc nl kg nm kk ne nf ng nh bi translated"><strong class="jp ir"> StorageArea: </strong> <br/>用于需要额外隔离的情况(如存储数据的第三方库，希望避免与通过默认<code class="fe nw nx ny no b"><strong class="jp ir">storage</strong></code> <strong class="jp ir"> </strong>实例存储的数据冲突)。<code class="fe nw nx ny no b"><strong class="jp ir">StorageArea</strong></code> <strong class="jp ir"> </strong>数据存储在名为<code class="fe nw nx ny no b"><strong class="jp ir">kv-storage:${name}</strong></code>的IndexedDB数据库中，其中name是<code class="fe nw nx ny no b"><strong class="jp ir">StorageArea</strong></code> <strong class="jp ir"> </strong>实例的名称。</li></ul><pre class="kn ko kp kq gt nn no np nq aw nr bi"><span id="54d1" class="mn ll iq no b gy ns nt l nu nv">import {storage} from "std:kv-storage";</span><span id="355e" class="mn ll iq no b gy nz nt l nu nv">const main = <strong class="no ir">async </strong>() =&gt; {  <br/>  const oldPreferences = await storage.get("preferences");</span><span id="9869" class="mn ll iq no b gy nz nt l nu nv">  document.querySelector("form")<br/>    .addEventListener("submit", <strong class="no ir">async </strong>() =&gt; {<br/>       const newPreferences = Object.assign({}, oldPreferences, {<br/>         // Updated preferences go here...<br/>       });</span><span id="cdb3" class="mn ll iq no b gy nz nt l nu nv">       await storage.set("preferences", newPreferences);<br/>  });<br/>};</span><span id="8fbb" class="mn ll iq no b gy nz nt l nu nv">main();</span></pre><p id="4a18" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">导入映射<br/> </strong> <a class="ae kl" href="https://github.com/WICG/import-maps" rel="noopener ugc nofollow" target="_blank">导入映射</a>提议允许控制JavaScript <code class="fe nw nx ny no b">import</code>语句和<code class="fe nw nx ny no b">import()</code>表达式获取哪些URL，并允许在非导入上下文中重用该映射。</p><p id="fa03" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">导入映射为内置模块提供多填充和回退，使其能够将当前不可用的模块标识符映射到URL(参见“<a class="ae kl" href="https://docs.google.com/document/d/1vFQzbmxg9ilpg8CT_P8roEYcpTfZ06Q5N4J9-ZQqqZo/edit" rel="noopener ugc nofollow" target="_blank">导入映射v0.5实现设计文档</a>”)。</p><p id="5f87" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">比如内置模块KV Storage，目前只有Chrome才有。在受支持的浏览器中，您可以无问题地加载，但对于不支持的浏览器，您需要使用KV Storage的load polyfill。</p><p id="e316" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以下示例显示了如何使用导入映射。为模块定义映射，并为导入语句使用键URL值。</p><p id="85fd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在不支持的浏览器中，导入URL被识别并作为普通的导入URL进行处理。如果有支持，它们将根据映射信息流动。</p><pre class="kn ko kp kq gt nn no np nq aw nr bi"><span id="af80" class="mn ll iq no b gy ns nt l nu nv">&lt;!-- The import map is inlined into your page --&gt;  <br/>&lt;script type="importmap"&gt;  <br/>{<br/>  "imports": {<br/>    "<strong class="no ir">/path/to/kv-storage-polyfill.mjs</strong>": [<br/>       "std:kv-storage",  // if has native support<br/>       "/path/to/kv-storage-polyfill.mjs" // otherwise load polyfill<br/>    ]<br/>  }<br/>}<br/>&lt;/script&gt;</span><span id="2a77" class="mn ll iq no b gy nz nt l nu nv">&lt;!-- Then any module scripts with import statements use the above map --&gt;  <br/>&lt;script type="module"&gt;  <br/>  import {storage} from '<strong class="no ir">/path/to/kv-storage-polyfill.mjs</strong>';</span><span id="ad9d" class="mn ll iq no b gy nz nt l nu nv">// Use `storage` ...<br/>&lt;/script&gt;</span></pre><h1 id="32d8" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">关闭</h1><p id="7f4f" class="pw-post-body-paragraph jn jo iq jp b jq mi js jt ju mj jw jx jy mk ka kb kc ml ke kf kg mm ki kj kk ij bi translated">JavaScript仍在不断变化。它证明了多年来它一直是最流行的语言并不是巧合。针对浏览器和Node.js的新ECMAScript版本的覆盖范围也在不断增加，甚至在其完成之前的一些提案中也是如此。</p><ul class=""><li id="6b1f" class="mz na iq jp b jq jr ju jv jy nb kc nc kg nd kk ne nf ng nh bi translated">检查覆盖范围的ECMAScript兼容性表。</li><li id="bb4e" class="mz na iq jp b jq ni ju nj jy nk kc nl kg nm kk ne nf ng nh bi translated">Node.js支持ECMAScript规范的版本如下(参见“<a class="ae kl" href="https://node.green/" rel="noopener ugc nofollow" target="_blank"> Node.js ES2015/ES6、ES2016、ES2017支持</a>”)。<br/>—es 2017:v 9 . 11 . 2<br/>—es 2018:v 10 . 3 . 0<br/>—es 2019:v 12 . 0 . 0</li></ul><p id="a70a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过透明和健壮的标准化过程的持续开发使JavaScript变得可靠和强大。</p><p id="803c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们为所有人继续旅程吧！。</p></div></div>    
</body>
</html>