<html>
<head>
<title>Using Angular 6 Material Auto-complete With Async Data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用带异步数据的角度6材料自动完成</h1>
<blockquote>原文：<a href="https://itnext.io/using-angular-6-material-auto-complete-with-async-data-6d89501c4b79?source=collection_archive---------1-----------------------#2018-06-14">https://itnext.io/using-angular-6-material-auto-complete-with-async-data-6d89501c4b79?source=collection_archive---------1-----------------------#2018-06-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="766f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一个简洁的UX模式是使用一个自动完成组件来帮助<em class="kl">选择已知的选项。<br/>假设我想从存储在服务器中的注册用户列表中选择一个用户，或者..随便输入一个名字就行了。</em></p><h1 id="2f50" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">我们想要达到的目标</h1><p id="26fb" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">我们将使用Angular 6和Angular Material来得到这个:</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div class="gh gi lp"><img src="../Images/12316966300a2a49de0a87b8fd0dfacc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1036/1*156pUKEh0TLifSjC2Sdd5w.gif"/></div></figure><h1 id="cfd2" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">第1部分—从服务器获取选项</h1><p id="c3ce" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">首先让我描述一下我们正在处理的服务器的响应:</p><pre class="lq lr ls lt gt lx ly lz ma aw mb bi"><span id="a70b" class="mc kn iq ly b gy md me l mf mg">{<br/>  total: 5<br/>  results: [<br/>    User(id: 1, name: "Windstorm"),<br/>    ...<br/>  ]<br/>}</span></pre><p id="ab16" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">澄清这一点后，让我们继续讨论如何填充自动完成:</p><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="a094" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们正在创建一个反应式表单，这样我们就可以在输入发生变化后接收到一个可观察的结果。<br/>接下来，我们将从<code class="fe mj mk ml ly b">valueChanges</code>获得的可观察值存储在<code class="fe mj mk ml ly b">filteredUsers</code>中，但前提是我们还对其应用了我们拥有的<code class="fe mj mk ml ly b">search</code>方法(只是一个常规的数据获取服务)，并将其展平，以便管道中的下一个值将是来自服务器的响应。<br/>我们也使用<code class="fe mj mk ml ly b">debounceTime</code>,因为我们不想为输入中每个改变的字母向服务器发出请求。</p><p id="8840" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">注:</strong>我们还没有订阅可观测的。为此我们将使用一个<code class="fe mj mk ml ly b">async</code>管</p><p id="a90d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是放置自动完成选项的html:</p><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="f1a9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mj mk ml ly b">async</code>管道现在将为我们订阅<code class="fe mj mk ml ly b">filteredUsers</code>，然后我们才访问保存我们选项的<code class="fe mj mk ml ly b">results</code>值。</p><p id="e4ba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里是<a class="ae mm" href="https://stackblitz.com/edit/angular-material-autocomplete-async1" rel="noopener ugc nofollow" target="_blank">演示</a></p><h1 id="88ce" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">第2部分—在检索选项时添加微调器</h1><p id="c41e" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">我们只需要添加一个<code class="fe mj mk ml ly b">mat-option</code>在加载时显示。<br/>此外——我们使用<code class="fe mj mk ml ly b">tap</code>和<code class="fe mj mk ml ly b">finalize</code>管道来决定何时显示和隐藏<code class="fe mj mk ml ly b">isLoading</code></p><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="139f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">注意:</strong><code class="fe mj mk ml ly b">finalize</code>必须用于<code class="fe mj mk ml ly b">search</code>方法，因为底层<code class="fe mj mk ml ly b">httpClient</code>在1次发射后完成订阅，而<code class="fe mj mk ml ly b">valueChanges</code>永不结束，所以不会命中<code class="fe mj mk ml ly b">finalize</code></p><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="13f5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里是<a class="ae mm" href="https://stackblitz.com/edit/angular-material-autocomplete-async2" rel="noopener ugc nofollow" target="_blank">演示</a></p><p id="7e80" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就这样。干杯:)</p></div></div>    
</body>
</html>