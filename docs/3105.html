<html>
<head>
<title>Procedural textures with Flutter</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">具有颤动的程序纹理</h1>
<blockquote>原文：<a href="https://itnext.io/procedural-textures-with-flutter-efcf546cd1fc?source=collection_archive---------1-----------------------#2019-10-04">https://itnext.io/procedural-textures-with-flutter-efcf546cd1fc?source=collection_archive---------1-----------------------#2019-10-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="c21d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi kl translated">给软件工程师一个框架/技术，迟早他们会用它来写一个游戏。在这个宇宙中，事情就是这样安排的。给软件工程师一个支持画布般绘图的工具，总有一天你会在上面看到柏林噪声——这是肯定的。</p><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div class="gh gi ku"><img src="../Images/1d8c416ef3acbe979962b4603e0f7aa3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*hn-Mk4fEphq94dzlb4mDgQ.png"/></div></figure><p id="835a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我很幸运地成为这两种说法的受害者，并深入研究了用Flutter编写手机游戏，这是一次疯狂的旅程，有其自身的缺点和优点。沿着这些曲折的曲线，我还遇到了以编程方式生成纹理以在<strong class="jp ir"> dart:ui </strong> <a class="ae lc" href="https://api.flutter.dev/flutter/dart-ui/Canvas-class.html" rel="noopener ugc nofollow" target="_blank">画布</a>上绘制的需要。在这种情况下，成功的算法在复杂性方面与FizzBuzz相差甚远，所以我认为这可能值得记录下来并与其他长笛手分享。事不宜迟，我们开始吧。</p><h1 id="15b5" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated"><strong class="ak"> Skia </strong>支持着色器</h1><p id="bcd1" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">好消息是，我们可以在<a class="ae lc" href="https://github.com/google/skia/blob/master/src/sksl/README" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir">SkSL</strong></a><strong class="jp ir"/>中编写某种<a class="ae lc" href="https://www.khronos.org/opengl/wiki/Fragment_Shader" rel="noopener ugc nofollow" target="_blank">片段着色器</a>(<strong class="jp ir">Skia的</strong>味的<a class="ae lc" href="https://www.shadertoy.com/results?query=&amp;sort=popular&amp;filter=" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> GLSL </strong> </a>)在<strong class="jp ir"> Dart </strong>中以某种方式告诉<strong class="jp ir"> Skia </strong>渲染它。我们完了，绅士们。故事结束。</p><div class="kv kw kx ky gt ab cb"><figure class="mg kz mh mi mj mk ml paragraph-image"><img src="../Images/8ab8f105776aeba04a1bbae806ed57cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:512/format:webp/1*kM--pcFG6DzariDLz60SDw.png"/></figure><figure class="mg kz mh mi mj mk ml paragraph-image"><img src="../Images/38449726510cbe2f84c553f686ada0bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:512/format:webp/1*6qrUrLgFCTLIWIQp7x11tQ.png"/></figure><figure class="mg kz mh mi mj mk ml paragraph-image"><img src="../Images/38449726510cbe2f84c553f686ada0bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:512/format:webp/1*6qrUrLgFCTLIWIQp7x11tQ.png"/><figcaption class="mm mn gj gh gi mo mp bd b be z dk mq di mr ms translated">来自<a class="ae lc" href="https://skia.org/user/api/skpaint_overview" rel="noopener ugc nofollow" target="_blank">skia.org</a>的湍流“着色器”样本。</figcaption></figure></div><p id="3033" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这正是我最初的想法。实际上，<strong class="jp ir"> dart:ui </strong>并没有公开任何API来构建成熟的<strong class="jp ir"> SkSL </strong>着色器。而<a class="ae lc" href="https://api.flutter.dev/flutter/dart-ui/Shader-class.html" rel="noopener ugc nofollow" target="_blank">着色器</a>实例只是一些<a class="ae lc" href="https://github.com/google/skia/tree/master/src/shaders" rel="noopener ugc nofollow" target="_blank">内置<strong class="jp ir"> Skia </strong>着色器</a>的浅层包装器。</p><p id="f304" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">坏消息是，用Flutter在程序上生成图像是不可能的。我们完了，绅士们。故事结束。</p><p id="7a29" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这正是我对这个问题的第二种看法。幸运的是，我错了。</p><h1 id="1548" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">抖动画布和绘制图像</h1><p id="c6c1" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated"><a class="ae lc" href="https://api.flutter.dev/flutter/dart-ui/Canvas-class.html" rel="noopener ugc nofollow" target="_blank"> Canvas </a>有这个方法，<a class="ae lc" href="https://api.flutter.dev/flutter/dart-ui/Canvas/drawImage.html" rel="noopener ugc nofollow" target="_blank"> drawImage </a>，它接受一个<a class="ae lc" href="https://api.flutter.dev/flutter/dart-ui/Image-class.html" rel="noopener ugc nofollow" target="_blank"> Image </a>对象的实例。因此，如果我们能够以某种方式操纵该对象背后的二进制缓冲区，使其包含特定像素的特定颜色，然后在画布上绘制结果图像，我们就完成了。故事结束了？</p><p id="3503" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">还没有。仅仅实例化一个新图像并从<a class="ae lc" href="https://api.flutter.dev/flutter/dart-typed_data/dart-typed_data-library.html" rel="noopener ugc nofollow" target="_blank"> dart:typed_data </a>包中传递一些东西是不可能的。原因是图像是直接从<a class="ae lc" href="https://github.com/flutter/engine" rel="noopener ugc nofollow" target="_blank"> Flutter引擎</a>创建的，它是框架的本地部分，具有对Dart代码的互操作。从Dart端获取图像的唯一方法是使用<a class="ae lc" href="https://api.flutter.dev/flutter/dart-ui/instantiateImageCodec.html" rel="noopener ugc nofollow" target="_blank">instantiadimagecodec</a>实用程序。正如您可能猜到的，它不会立即返回图像，也是异步的。大多数资料建议按以下方式使用它:</p><figure class="kv kw kx ky gt kz"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="1fde" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">哪个是👌，因为它有很好的文档记录，并且完全按照您的预期工作，尽管比您预期的实例化一个图像所需的代码多两行。</p><p id="2d5a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上面的例子缺少一个重要的细节，它没有告诉你<strong class="jp ir">字节数据</strong>来自哪里。在程序纹理生成的情况下，这非常重要，因为我们不是简单地从磁盘或网络读取<em class="mv">原始图像源</em>，而是需要<em class="mv">从头开始在内存中实例化它</em>。编解码器支持的格式有JPEG、PNG、GIF、动画GIF、WebP、动画WebP、BMP和WBMP。如你所见<em class="mv">这里没有原始字节数据</em>。</p><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/c20c01d4ecc004f174a35eca8d78f3fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1180/1*f2sWYzPNN1uNg3Qk_2Om_w.gif"/></div></figure><p id="80fd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">幸运的是，<strong class="jp ir"> BMP </strong>和<em class="mv">差不多</em>像原始字节，对吗？而且大概有一个很好的库可以用Dart生成<strong class="jp ir"> BMP </strong>？长话短说，我已经编写了一个自定义的BMP编码器，并开始在我的项目中使用它，然后才意识到有一种更简单，但文档较少的方法来用<strong class="jp ir"> dart:ui </strong>实例化图像。</p><h1 id="a51f" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">⚡️decodeImageFromPixels ⚡️</h1><p id="14f3" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">有时候，不管你怎么努力，你就是无法在网上找到一些东西。有时候你只是在找一个错误的东西。我也遇到了这种情况，因为我完全专注于Image类中的<a class="ae lc" href="https://api.flutter.dev/flutter/dart-ui/Image-class.html" rel="noopener ugc nofollow" target="_blank">文档，这些文档声明您<em class="mv">必须使用</em><strong class="jp ir">instantiate Image codec</strong>来获取图像实例。但是从字面上看，在<strong class="jp ir">instantiatemagecodec</strong>的源代码下面48行，还有另一个函数，<strong class="jp ir"> decodeImageFromPixels </strong>，这是我纯属运气偶然发现的，这个不受上面列出的格式限制，可以接受原始像素数据。多美啊！</a></p><p id="be45" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有了它，我们已经可以找点乐子了。这是我将在本文剩余部分使用的操场。</p><figure class="kv kw kx ky gt kz"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">生成图像的平台</figcaption></figure><p id="b511" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我向您保证，这个例子比复杂性更长。但结果是，你可以运行<code class="fe mx my mz na b">flutter create texture_generator</code>并与上面的源代码交换<code class="fe mx my mz na b">main.dart</code>的内容。运行时，它看起来像:</p><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/0e84d16f803052b944813125e783a132.png" data-original-src="https://miro.medium.com/v2/resize:fit:774/format:webp/1*ssKBCHfXv6QtVjNnQVTn0w.png"/></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">一些尚未统一的东西</figcaption></figure><p id="4e28" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你们中那些处理过着色器的人会立即意识到这个东西在现实中有多糟糕。它运行在中央处理器上。在移动CPU上。</p><p id="0907" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不太好的原因很简单，GPU的存在就是为了做这样的事情。所以我们上面做的有点不太合适。所以“自行承担风险”<strong class="jp ir">。</strong></p><figure class="kv kw kx ky gt kz"><div class="bz fp l di"><div class="nc mu l"/></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">用CPU渲染(感谢流言终结者)</figcaption></figure><figure class="kv kw kx ky gt kz"><div class="bz fp l di"><div class="nd mu l"/></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">用GPU渲染(感谢流言终结者)</figcaption></figure><p id="087d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">也就是说，让我们开始调整我们的示例，以获得更实用的东西。在着色器工作流中，通常使用单位矢量坐标而不是绝对值进行操作。</p><figure class="kv kw kx ky gt kz"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="28dd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这将被呈现为:</p><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/b74e730205709be86740da74ebcdceae.png" data-original-src="https://miro.medium.com/v2/resize:fit:774/format:webp/1*cr-OhbGsYO85_QlvoMXx-A.png"/></div></figure><p id="e33b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以用以下方式对其进行细微的修改:</p><figure class="kv kw kx ky gt kz"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="b5b2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">而且它已经可以被真正的应用程序使用了。</p><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/1ce0523b5827e1d6b9c7ba8bd2beb634.png" data-original-src="https://miro.medium.com/v2/resize:fit:774/format:webp/1*Bh5xRLqVGxNGO4cyXSrlxQ.png"/></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">带点图案的渐变</figcaption></figure><p id="850e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这种方法的好处是数学上的精确性。因此，如果你需要制作一个像素完美的设计，还能适应所有可能的长宽比和像素密度，这甚至可能是你的一个选择。然而，我们这样做是为了好玩🌕。</p><p id="e8e5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，让我们尝试不同的经典着色器教程:棋盘图案。为了让我们的生活轻松一点，让我们来介绍一个小帮手，将<code class="fe mx my mz na b">Vector3</code>转换成代表<code class="fe mx my mz na b">RGBA</code>颜色的<code class="fe mx my mz na b">int</code>。同类型的<code class="fe mx my mz na b">int</code>，我们在前面的例子中返回，如<code class="fe mx my mz na b">Colors.black.value</code>或<code class="fe mx my mz na b">0xffbada55</code>。</p><figure class="kv kw kx ky gt kz"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="4940" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们的代码看起来更接近你在实际的着色器教程中所能找到的。从棋盘开始，让我们在X轴上画一个渐变。</p><figure class="kv kw kx ky gt kz"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="062d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它将在水平轴上绘制一个从黑到白的平滑渐变。</p><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/a3da6b423dc8328618c8c1e25d4b83af.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*BF-HNi8zXwb79c_D8yg29A.png"/></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">尽可能平滑地用于8位色彩空间</figcaption></figure><p id="690f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下一步是添加一些重复。一个简单的方法是重新映射我们的<code class="fe mx my mz na b">uv</code>向量，这样当运行从<code class="fe mx my mz na b">0</code>到<code class="fe mx my mz na b">Size.width</code>的像素代码时，它会多次重复<code class="fe mx my mz na b">0..1</code>之间的值。实现这一点再简单不过了，感谢数学！</p><figure class="kv kw kx ky gt kz"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="6bbd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个函数将返回<code class="fe mx my mz na b">Vector3</code>的小数部分，所以如果我们在其中传递类似<code class="fe mx my mz na b">uv.xxx</code>的东西，它将返回几乎完全相同的东西。但是，如果我们传递一个<code class="fe mx my mz na b">Vector(1.1, 2.2, 3.3)</code>，它将返回<code class="fe mx my mz na b">Vector3(0.1, 0.2, 0.3)</code>，它将总是有单位大小。</p><p id="389d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以通过以下方式利用它:</p><figure class="kv kw kx ky gt kz"><div class="bz fp l di"><div class="mt mu l"/></div></figure><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi nf"><img src="../Images/f35c668ff1e136bff080503bceb9ea73.png" data-original-src="https://miro.medium.com/v2/resize:fit:860/format:webp/1*8yJcLoskCkjel-ekA5hkmQ.png"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">请不要在你的应用中直接使用这样的模式🙏</figcaption></figure><p id="34fc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们沿着Y轴添加一个重复。为此，我们要缩放单位坐标向量的<code class="fe mx my mz na b">x</code>和<code class="fe mx my mz na b">y</code>分量。我们也为<code class="fe mx my mz na b">Vector2</code>具体介绍一下<code class="fe mx my mz na b">frac2</code>。</p><figure class="kv kw kx ky gt kz"><div class="bz fp l di"><div class="mt mu l"/></div></figure><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/5b785267c38a3a67f6b4c40973a8d3af.png" data-original-src="https://miro.medium.com/v2/resize:fit:866/format:webp/1*BUAcE5iJ-ob_urAtaQ7fTw.png"/></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">里克-莫蒂网格公司</figcaption></figure><p id="7905" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">太好了！但是如果我们想要正方形瓷砖呢？这也很容易，我们可以根据给定的<code class="fe mx my mz na b">Size</code>的长宽比重新缩放我们原来的<code class="fe mx my mz na b">uv</code>。</p><figure class="kv kw kx ky gt kz"><div class="bz fp l di"><div class="mt mu l"/></div></figure><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/752a6d299afb1752c081527d1c4c3ed8.png" data-original-src="https://miro.medium.com/v2/resize:fit:856/format:webp/1*d4AEF9Z3XeP9Z8baVIE0XA.png"/></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">“完美的网格并不存在…🤔"</figcaption></figure><p id="d68c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">尽管已经很酷了，但它还不是棋盘。为了做到这一点，让我们使用我们的<code class="fe mx my mz na b">gridUv</code>坐标。如果<code class="fe mx my mz na b">gridUv</code>代表网格单元的左上或右下四分之一，则返回<code class="fe mx my mz na b">0xffffff</code>和<code class="fe mx my mz na b">0xff000000</code>颜色。</p><figure class="kv kw kx ky gt kz"><div class="bz fp l di"><div class="mt mu l"/></div></figure><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/32a7c44cadcb58aa66dada552acedb70.png" data-original-src="https://miro.medium.com/v2/resize:fit:862/format:webp/1*HfF_rqqBz7Qw5mEqsa21IA.png"/></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">那将是一场漫长的象棋比赛！</figcaption></figure><p id="e6c4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">尽管我们能够在移动设备的屏幕上绘制这种带有抖动的东西很酷，并且可以热重新加载，真正完全控制每个像素，但这种模式本身有点无聊。所以让我们更上一层楼吧！</p><div class="nn no gp gr np nq"><a href="https://en.wikipedia.org/wiki/Truchet_tiles" rel="noopener  ugc nofollow" target="_blank"><div class="nr ab fo"><div class="ns ab nt cl cj nu"><h2 class="bd ir gy z fp nv fr fs nw fu fw ip bi translated">瓷砖</h2><div class="nx l"><h3 class="bd b gy z fp nv fr fs nw fu fw dk translated">在信息可视化和图形设计中，Truchet瓷砖是用图案装饰的方形瓷砖，这些图案不是…</h3></div><div class="ny l"><p class="bd b dl z fp nv fr fs nw fu fw dk translated">en.wikipedia.org</p></div></div><div class="nz l"><div class="oa l ob oc od nz oe la nq"/></div></div></a></div><p id="8ba0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Truchet tiles是网格中基于模式或随机重复的图形片段。就像我们现在做的一样！因此，我们可以稍微增加一点趣味的第一件简单的事情是随机交换网格单元的哪些部分是白色的。</p><figure class="kv kw kx ky gt kz"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="fa8c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们渲染一下，然后…</p><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/e9920aa0e3249541dae7d4b2628e529e.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*RPmnJ24Gz40qmH5A5liKmg.png"/></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">是的，这就是着色器的工作原理。</figcaption></figure><p id="3b79" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们只会听到一堆噪音。这是因为我们的代码是对每个像素单独执行的，我们的<code class="fe mx my mz na b">gridUv</code>抽象仅仅基于输入坐标。</p><p id="3755" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">摆脱这种完全随机性的方法是根据图块索引来决定渲染哪个图块。除此之外，我们还可以对输入应用一些伪随机转换，这样就不会经常重复。</p><figure class="kv kw kx ky gt kz"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="8424" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">看起来<code class="fe mx my mz na b">random2</code>中的数学有点复杂，不清楚它是做什么的。但这正是我们需要的功能。您可以尝试修改它的内容，看看它如何影响我们产生的平铺模式。</p><div class="kv kw kx ky gt ab cb"><figure class="mg kz of mi mj mk ml paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><img src="../Images/36f7bc433397d885964ae49e411c152b.png" data-original-src="https://miro.medium.com/v2/resize:fit:666/format:webp/1*zJQI2ke-iMp_xj0G7MPzjw.png"/></div></figure><figure class="mg kz og mi mj mk ml paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><img src="../Images/73834b200feb744bd37314d9a5a59d62.png" data-original-src="https://miro.medium.com/v2/resize:fit:670/format:webp/1*qyEbbgFv6CkPcns-NuHTjA.png"/></div></figure><figure class="mg kz oh mi mj mk ml paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><img src="../Images/aabaed0af21f63bba6f8aef07a052b12.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*C89h17v7WzPpCKPoXmb8JQ.png"/></div></figure></div><div class="ab cb"><figure class="mg kz oi mi mj mk ml paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><img src="../Images/b1411430e9d4fa4fa674fce8f829cd54.png" data-original-src="https://miro.medium.com/v2/resize:fit:666/format:webp/1*rG67EWW4qlnF98uFPjuooA.png"/></div></figure><figure class="mg kz og mi mj mk ml paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><img src="../Images/8c78752720f5868a1f120193e361333e.png" data-original-src="https://miro.medium.com/v2/resize:fit:670/format:webp/1*9h3QjMqgxmThZCbA-RNOPA.png"/></div></figure><figure class="mg kz oi mi mj mk ml paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><img src="../Images/b0756a7ecb44d31d5b4cfee6146c2c1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:666/format:webp/1*KxzM2Q-GrLlukHxt4_J9bw.png"/></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk mq di mr ms translated">不同random2实现产生的各种模式的一些例子</figcaption></figure></div><p id="05b1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从这里，你可能已经看到，可能性是无穷无尽的。您可以将各种瓷砖填充与各种填充模式相结合，以产生无限数量的纹理。这种伪随机方法的最佳特性之一是它是完全可重复的，因此如果您需要，它在应用程序运行或不同设备之间看起来是相同的。</p><h1 id="a808" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">让我们制造一些噪音</h1><p id="63c6" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">在文章的开始，有一些使用Perlin noise生成的纹理截图。让我们实现这些吧！</p><p id="7cfa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，让我们将<code class="fe mx my mz na b"><a class="ae lc" href="https://pub.dev/packages/fast_noise" rel="noopener ugc nofollow" target="_blank">fast_noise</a></code> lib添加到我们的<code class="fe mx my mz na b">pubspec.yaml</code>中。如果你用的是VSCode，我可以推荐安装<code class="fe mx my mz na b">Pubspec Assist</code>包。使用它，添加一个新的包看起来像这样:</p><pre class="kv kw kx ky gt oj na ok ol aw om bi"><span id="de10" class="on le iq na b gy oo op l oq or">Ctrl + P<br/>pubspec<br/>Enter<br/>Ctrl + Shift + P<br/>Add depe<br/>Enter<br/>fast noise<br/>Enter</span></pre><p id="f90c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这比你实际输入的时间要长得多:)</p><p id="4253" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">安装后，将其导入我们的<code class="fe mx my mz na b">main.dart</code>，我们就可以开始了！</p><p id="e8d0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们以下面的方式修改<code class="fe mx my mz na b">generateImage</code>。因此，它从PerlinNoise generator获取我们像素网格中的颜色，而不是使用<code class="fe mx my mz na b">generatePixel</code>函数。</p><figure class="kv kw kx ky gt kz"><div class="bz fp l di"><div class="mt mu l"/></div></figure><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div class="gh gi os"><img src="../Images/3cf43218ad9f40e6950d167ef4055f06.png" data-original-src="https://miro.medium.com/v2/resize:fit:872/format:webp/1*CxL8gQbCelXGXi5QA0-Ufg.png"/></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">酷炫无尽的柏林虫！</figcaption></figure><p id="6598" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是这些边缘！呃。幸运的是，我们可以通过颜色间的插值相对容易地解决这个问题。因此，我们不是在黑与白之间进行硬切换，而是在两者之间进行一些平滑处理。这个英雄将帮助我们实现那个名为<code class="fe mx my mz na b">smoothStep</code>的目标，并且是我们已经在使用的<code class="fe mx my mz na b">vector_math</code>库的一部分！</p><figure class="kv kw kx ky gt kz"><div class="bz fp l di"><div class="mt mu l"/></div></figure><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/03809acc4f15c9e6744b4d12e6aaf9a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*9OiptwWWoPNB5pDPe1RiDA.png"/></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">思慕雪！</figcaption></figure><h1 id="e781" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">悲伤的部分</h1><p id="6618" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">不幸的是，即使在一台像样的开发人员笔记本电脑上，生成上面的图像也需要几秒钟。这对大多数应用程序来说太多了。所以总的来说，如果你的用例比文章第一部分中的简单模式更复杂，<em class="mv">我不推荐使用这种方法</em>。在<a class="ae lc" href="https://medium.com/@germansaprykin/opengl-with-texture-widget-f919743d25d9" rel="noopener">这篇文章</a>中清晰地描述了实际要遵循的路径。不幸的是，编写运行GPU的实际着色器的能力似乎不会很快为flutteres<a class="ae lc" href="https://github.com/flutter/flutter/issues/30763" rel="noopener ugc nofollow" target="_blank">提供。也就是说，需要更少计算的更简单的用例仍然是相对有用的，可以在应用程序中加入一些精确控制的随机性！</a></p><h1 id="a4f4" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">更新:2021年10月</h1><p id="6d6f" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">看起来颤振引擎可能会在即将发布的版本中获得定制的<a class="ae lc" href="https://github.com/flutter/flutter/issues/58361" rel="noopener ugc nofollow" target="_blank">着色功能</a>🍨！</p></div><div class="ab cl ot ou hu ov" role="separator"><span class="ow bw bk ox oy oz"/><span class="ow bw bk ox oy oz"/><span class="ow bw bk ox oy"/></div><div class="ij ik il im in"><p id="080c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">感谢阅读这篇文章！如果你正在用Flutter编写游戏或者做任何与程序图形生成相关的事情，我很乐意在评论中听到你的项目，或者给我写几行到<a class="ae lc" href="mailto:av@av.codes" rel="noopener ugc nofollow" target="_blank"> av@av.codes </a>。</p></div></div>    
</body>
</html>