# 具有微前端架构的前端应用的可扩展性

> 原文：<https://itnext.io/scalability-of-frontend-applications-with-a-micro-frontends-architecture-2f1b25221bfe?source=collection_archive---------2----------------------->

![](img/143d3bed5e8c2dd85dcba8a04af94571.png)

大家好！

在本文中，我想谈谈从初创公司向成熟公司过渡期间的可伸缩性话题，分享我的想法，并解释一些我们在我工作的组织中使用的技术。

许多不同的文章解释并涵盖了可伸缩性主题，但是我想在本文中澄清一下我所说的可伸缩性的含义:

```
Scalability is the ability of the frontend system to deliver value to end-users in a **faster, reliable, and more straightforward manner** on each live circle of the system
```

一个可伸缩的应用程序应该共享许多原则，但是我想强调其中最重要的一条:关注点和架构设计的分离。

在本文中，我将基于[团队拓扑概念](https://teamtopologies.com/key-concepts)来操作术语，并将团队按照功能分成四组:流对齐团队、支持团队、复杂子系统团队和平台团队。

# 创业公司的时代

我们生活在创业公司的时代。每天都有新的创业公司开业或关闭，企业家们在寻找新的机会，为我们的生活带来新的商业模式。我们可以观察成长和失败的个人和公司。

从公司生命周期的这个阶段的技术角度来看，组织中的技术足够小，容易维护，容易成长，容易给业务带来新的价值。在这个阶段犯错误并不重要，很容易改正。当然，这并不意味着最初的架构不重要，业务需要能够在早期阶段做出架构决策的非常优秀的专家。在组织中使用多团队模型是没有意义的。在这个阶段，一两个开发团队(每个团队 5-10 名成员)已经足够了。我认为在这个阶段有更多的团队是一个组织上的错误。

在这家公司的年龄，从前端的角度来看，最好的方法是使用一个小的单片应用程序。它有许多好处:

*   保持代码简洁，易于使用
*   整体架构很自然，也很容易实现
*   持续集成和部署不会过载

# 巨人的时代

IT 巨头和成熟公司我们就不多说了。我们只需要提到，一个成熟的公司已经有一个运作良好的业务，工作流程，在行业内建立良好，并有多个专注于其职能的工作团队。

在此阶段，一个关键因素是将职能工作分散到专注于 it 的专业团队中，不允许任何特定团队在 it 中涵盖多个职能。

# 将创业公司转变为成熟公司

随着时间的推移，当前端应用程序开始不够灵活以保持与业务相同的速度时，一家初创公司即将达到沸点。

在每个交付周期中，交付新功能和满足业务需求都会被延迟。技术团队给企业的空头承诺还没有意识到环境已经改变。团队仍然认为他们可以在某个特定的日期发布一个新的特性，但是一次又一次的失败。

组织可以增加团队或工程师的数量来满足最重要的需求。不幸的是，在很多情况下，让更多的人加入技术团队不会带来任何价值。流程应该改变。

系统不再可扩展的最常见症状是:

*   系统维护中的困难
*   脆弱的系统，开发人员不知道在特定的变更过程中可能会被破坏，这通常会导致严重的事故
*   过载的持续集成/持续部署过程，此时工程师应该排队交付他们的功能或错误修复
*   不可能在不改变整个系统的情况下从一个技术栈切换到另一个技术栈
*   保持应用程序最新和更新版本的困难
*   当多个团队交付到同一个代码库时，会混淆代码库
*   当没有团队负责代码的维护和改进时，放弃代码
*   团队之间没有明确的责任
*   多功能团队，即流程调整团队正在执行支持功能或平台工作

在过渡时期犯技术错误是非常非常昂贵的。在这个阶段，所有来自启动阶段的错误都变得非常明显。

为了让业务流程继续发展，组织中的技术领导应该调整他们当前的状态。一种流行的解决方案是从单一架构迁移到微服务(在后端技术的情况下)或微前端(在前端技术的情况下)架构。

因为我们在本文中讨论的是前端技术，所以我将继续讨论微前端，而不是微服务。此外，我想放弃微前端架构是好是坏的问题，因为有许多文章和讨论，以及哪个微前端方法是坏还是好。

相反，我想从可伸缩性的角度考虑微前端架构，以及它如何能够解除处于开始构建多团队模型的过渡状态的组织的障碍。

# 微前端架构

## 微前端架构在多团队模式中的优势

```
MicroFrontends an architectural style (pattern) where independently deliverable frontend applications are composed into a greater whole. ([microfrontends.com](https://microfrontends.com/))It is a technique that impacts the organization, providing decoupling between teams, avoiding too much centralization and, that is most important, empowering the teams on taking local decisions and do not depend on other teams.
```

一旦组织能够发现我们之前描述的不可伸缩系统的症状，工程师就可以决定将系统从整体架构转换为微前端架构。同时，它可以为公司带来以下好处:

**代码组织**

微前端架构允许团队将一个单一的应用程序代码库分割成小块代码。每个单独的微前端的源代码会小得多，并且只关注应用程序的一小部分。应该由工程团队决定应用程序的哪一部分应该解耦到微前端。它可以是像页面这样的大部件，也可以是像元素这样的小部件。新的代码组织允许新开发人员花更少的时间学习代码库，并在短时间内开始编写代码。

**团队独立性**

微前端代码库应该是独立的，并且将帮助流对齐的团队选择他们的工作策略和过程。每个团队对应用程序的一个垂直部分拥有完全的所有权，并且可以专攻他们的领域。他们可以停下来担心团队之间的干扰，减少团队之间的协调需求。微前端让你的应用程序遵循基于*康威定律*的团队结构

> 任何设计系统(广义定义的)的组织都会产生一个设计，其结构是组织的沟通结构的复制。
> 
> -梅尔文·康威

用例示例:

如果一个团队想要尝试新的技术(另一个状态管理器，一个新的测试库，等等)。)在 monolith 中，决策应该在处理应用程序的所有团队之间保持一致。这很耗时，最终，它可能不被一些团队所接受。如果团队是独立的，团队的工程师可以决定他们要用什么。这个决定对其他球队没有任何影响。

**发布独立**

采用与微服务相同的方法，微前端负责其部署。它使与流程一致的团队能够独立发布应用程序的各个部分。每个团队可以只部署一小部分，而不是重新部署整个应用程序。它可以授权团队在需要的时候发布，而不需要与其他团队协调或者适应公司范围的发布周期。如果上一次部署出现问题，可以很容易地回滚，而不会影响其他团队的工作。将代码库分割成小块可以减少部署微前端的时间。

**领域驱动架构**

投资微前端的原因之一是允许垂直域名所有权。从整个公司拥有的整体架构转移到多个团队拥有的微服务，帮助公司在不同团队之间扩展开发，并促进后端的所有权。每个与流程一致的团队拥有一个端到端的垂直组件。

**减少测试覆盖面**

与大型应用程序相比，测试更容易覆盖少量代码。它导致了整个系统中更好的测试覆盖率，因为所有代码的小部分都将被测试覆盖。

**使用不同技术和框架的可能性**

微前端的优势之一是不依赖于所选择的技术和框架。找一个专门的团队来做微前端要容易得多。它允许用其他技术替换不合适的技术和框架，以及测试对业务风险小的新技术。

## 微前端架构的基本原理

我将介绍微前端架构应该遵循的最重要的原则，以保持系统的可伸缩性。为此，我们应该引入两个术语:

*   **orchestrator** 是与所有微前端进行协调的父应用程序。在理想情况下，它不包含任何逻辑或业务功能，而只是充当一个操作符
*   **子微前端**是一个域驱动的应用程序，它覆盖了应用程序的任何特定部分

技术团队决定使用哪种微前端方法并不重要，为了保持系统的可扩展性，遵循以下不灵活的要求非常重要:

**孩子和指挥者之间的硬性要求**

*   orchestrator 和儿童应用程序之间几乎没有耦合
*   Orchestrator 应该**而不是**知道子微前端是如何实现的。如果子进程的实现发生了变化，但提供了相同的接口，那么不会有任何问题
*   儿童微前端必须提供一个统一的接口，以包含在 orchestrator 中
*   孩子和指挥者之间所有必要的交流都是通过回调或简单的事件来完成的
*   编排者应该能够决定总是使用子进程的最新版本或者指定一个特定的版本

**儿童微前端之间的硬性要求**

*   儿童微前端之间零耦合。每个孩子应该**不**知道其他微前端，并且**必须能够独立工作**
*   没有从一个微前端到另一个微前端的导入
*   没有共享的状态管理工具(Vuex、Redux)
*   孩子之间共享库是可能的
*   所有 CSS 代码的范围都必须排除重写样式属性

# 微前端架构维护

决定转向微前端架构并不是转型之旅的终点。这将是痛苦和危险的，但同样也是一个有趣的认知过程。很多陷阱就这样等着工程团队。

其中一个问题是整个微前端架构的维护。随着时间的推移，系统可能会计数到数十或数百个微前端，工程团队将面临新的挑战——如何维护所有这些微前端。

## 新微前端游戏攻略

这是工程团队迁移到微前端架构后遇到的第一个问题。如何在不增加复杂性的情况下搭建新的微前端？哪个团队负责创建新的微前端？微前端应该遵循哪些标准？

这些问题以及许多其他问题必须由工程团队来解决，以保持系统的可伸缩性和易维护性。否则，系统会在很短的时间内变得很乱。

我们应该得到解决方案时，每个新的微前端将非常快地创建，并与非常相似的设置，以保持所有微前端之间的一致性。我想到了“传送带”这个词。

有多种方法可以达到这个目的。我想分享一个如何实现它的想法:这个工具可以在几分钟内获取一个模板并创建一个新的微前端。这可能是一个现成的解决方案，如 [cookiecutter](https://github.com/cookiecutter/cookiecutter) 或另一个类似的工具。

## 同步现有的微前端

创建新的微前端是唯一的第一步。随着时间的推移，将会有许多微前端应该与您的基本模板同步。这可能是我们需要它的不同原因:消除漏洞、更新配置、更新其他包的版本等等。

不幸的是，cookiecutter 不允许您将现有项目与模板同步。为了解决这个问题，在我的组织中，我们开发了我们的解决方案，它可以搭建并保持现有微前端的最新状态。

在撰写概念证明项目的过程中，我根据我们在组织中遵循的类似原则创建了我的项目( [mucli](https://github.com/NovoManu/project-cli) )。该项目获取 Github 上的存储库，在其中查找模板，并安装新项目或同步现有项目。它提供的开箱即用功能:

*   模板库中的项目安装和同步。您可以创建自己的模板库，并使用 mucli 进行安装和同步。您的模板库是完全独立的，由您维护。mucli 包只适用于您的模板。
*   用户友好的命令行界面，能够向每个模板添加自定义用户问题。
*   文件中的动态值。可以根据设置或用户交互创建自定义文件。
*   前缀系统。您可以用不同的前缀标记您的文件，以便在同步过程中操作这些文件。
*   可组合模板。从较小的模块中创建一个非常灵活的模板是可能的。

请随时检查并参与 [mucli](https://github.com/NovoManu/project-cli) 项目。在接下来的文章中，我将深入探讨实现细节。

# 结论

在这篇文章中，我分享了我们公司从初创状态向成熟公司转变过程中的想法和决策。

如果您对本文或我的其他文章感兴趣，请随时关注我:

github:【https://github.com/NovoManu 

推特:【https://twitter.com/ManuSEngineer 

这是所有的乡亲。
见下篇。