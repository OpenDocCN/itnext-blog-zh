<html>
<head>
<title>A deep dive into Vue’s reactivity system — Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">深入了解Vue的反应系统—第2部分</h1>
<blockquote>原文：<a href="https://itnext.io/a-deep-dive-into-vues-reactivity-system-part-2-ac678fb631f9?source=collection_archive---------4-----------------------#2020-07-05">https://itnext.io/a-deep-dive-into-vues-reactivity-system-part-2-ac678fb631f9?source=collection_archive---------4-----------------------#2020-07-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="9d2e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本系列的第一部分中，我们讨论了如何通过将数据属性转换为getter/setter并将相关计算存储在捕获的数组中来创建一个原始的反应式系统。在这一部分中，我们将回顾Vue如何应用相同的思想来实现其引擎盖下的反应。</p><p id="0249" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在下面的代码片段中，我们创建了一个Vue实例，它具有三个数据属性，<em class="km">价格、数量和折扣</em>，以及两个计算属性<em class="km">总价</em>和<em class="km">折扣价格。</em>接下来，<em class="km"> </em>我们将实例挂载到id为<em class="km"> app </em>的div，以便在浏览器中呈现页面。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="ks kt l"/></div></figure><p id="00c2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们研究一下当我们使用<a class="ae kl" href="https://github.com/vuejs/vue/blob/dev/src/core/instance/index.js#L8" rel="noopener ugc nofollow" target="_blank">构造函数</a>创建Vue实例时会发生什么。它用选项参数中的所有数据调用Vue原型上定义的<a class="ae kl" href="https://github.com/vuejs/vue/blob/dev/src/core/instance/init.js#L16" rel="noopener ugc nofollow" target="_blank"> _init </a>方法。在我们的例子中，选项对象看起来像这样。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi ku"><img src="../Images/499199e7c69fbd2a9c1b75b30837aa23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t8r8GqtZPnpEcMaZpKYhuQ.png"/></div></div></figure><p id="7cd2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面的代码显示了<em class="km"> _init </em>方法的关键。所有重要的初始化都在这里完成。对于反应性主题，我们将重点关注突出显示的<em class="km"> initState() </em>和<em class="km"> $mount() </em>。</p><pre class="kn ko kp kq gt lb lc ld le aw lf bi"><span id="f49b" class="lg lh iq lc b gy li lj l lk ll">vm._self = vm;<br/>initLifecycle(vm);<br/>initEvents(vm);<br/>initRender(vm);<br/>callHook(vm, 'beforeCreate');<br/>initInjections(vm); // resolve injections before data/props<br/><strong class="lc ir">initState(vm);</strong><br/>initProvide(vm); // resolve provide after data/props<br/>callHook(vm, 'created');<br/>if (vm.$options.el) {<br/>    <strong class="lc ir">vm.$mount(vm.$options.el);</strong></span><span id="5db3" class="lg lh iq lc b gy lm lj l lk ll">}</span></pre><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi ln"><img src="../Images/ebf46b06f545b8f9350eb576ee6b4889.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nO3o2h5llwzP05yGbiqxig.png"/></div></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk translated">Vue数据初始化</figcaption></figure><p id="5366" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以看到<a class="ae kl" href="https://github.com/vuejs/vue/blob/dev/src/core/instance/state.js#L48" rel="noopener ugc nofollow" target="_blank"> <em class="km"> initState </em> </a>调用<a class="ae kl" href="https://github.com/vuejs/vue/blob/dev/src/core/instance/state.js#L112" rel="noopener ugc nofollow" target="_blank"> <em class="km"> initData </em> </a>和<a class="ae kl" href="https://github.com/vuejs/vue/blob/dev/src/core/instance/state.js#L169" rel="noopener ugc nofollow" target="_blank"> <em class="km"> initComputed </em> </a>。<a class="ae kl" href="https://github.com/vuejs/vue/blob/dev/src/core/instance/state.js#L112" rel="noopener ugc nofollow" target="_blank"> <em class="km"> initData </em> </a>的主要目的是<a class="ae kl" href="https://github.com/vuejs/vue/blob/dev/src/core/observer/index.js#L55" rel="noopener ugc nofollow" target="_blank">遍历</a>所有属性(<em class="km">价格、数量和折扣</em>)并为每个属性定义一个反应式getter和setter，稍后将使用它们来收集和通知依赖项。这类似于我们在本文第一部分中讨论的内容。<em class="km"> initData </em>也将每个属性代理给Vue实例，因此它们可以通过<em class="km"> this访问。</em></p><p id="1522" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，<em class="km"/><a class="ae kl" href="https://github.com/vuejs/vue/blob/dev/src/core/instance/state.js#L169" rel="noopener ugc nofollow" target="_blank"><em class="km">init computed</em></a>遍历所有计算的属性，在我们的例子中是<em class="km"> totalPrice </em>和<em class="km">discount price</em>，并为每个属性创建一个<strong class="jp ir"> watcher </strong>实例。我们可以将观察器视为实际计算的封装。观察器的值是计算的结果。观察器可以被创建为懒惰的，在这种情况下，观察器的值不会立即被评估。计算属性观察器被创建为懒惰观察器。</p><p id="3367" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">观察器的关键点是，它包含一个依赖于某些数据属性的计算。在计算观察器时，任何被访问的数据属性都可以收集观察器作为依赖项，并将其存储在本地<a class="ae kl" href="https://github.com/vuejs/vue/blob/dev/src/core/observer/index.js#L163" rel="noopener ugc nofollow" target="_blank"> dep </a>实例中，以便在属性值发生变化时通知它。</p><p id="9eb8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">除了为计算属性创建的所有观察器之外，还为负责呈现页面的计算创建了一个特殊的观察器。从上面的流程可以看出，<strong class="jp ir"> <em class="km">初始化</em> </strong>之后的下一步是<strong class="jp ir"><em class="km"/></strong>进程，解析我们#app标签里面的模板，创建一个render函数，这个函数是一个匿名函数，返回一个虚拟的DOM节点。例如，一个简单标签的渲染函数如下所示:</p><pre class="kn ko kp kq gt lb lc ld le aw lf bi"><span id="6e43" class="lg lh iq lc b gy li lj l lk ll">&gt; Vue.compile("&lt;label&gt;{{price}}&lt;/label&gt;").render.toString()</span><span id="c0b4" class="lg lh iq lc b gy lm lj l lk ll"><br/><strong class="lc ir">"function anonymous( ) { with(this){return _c('label',[_v(_s(price))])} }"</strong></span></pre><p id="0693" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">运行render函数并创建vnode之后的下一步是修补过程，以呈现实际的DOM元素。从render函数创建虚拟DOM (vnode)和从vnode创建实际DOM这两个步骤都封装在一个名为<a class="ae kl" href="https://github.com/vuejs/vue/blob/dev/src/core/instance/lifecycle.js#L189" rel="noopener ugc nofollow" target="_blank"><em class="km">update component</em></a><em class="km"/>的函数中，如下所示。由于<em class="km"> updateComponent </em>是一个依赖于其他数据元素的计算，因此为其创建了一个新的<a class="ae kl" href="https://github.com/vuejs/vue/blob/dev/src/core/instance/lifecycle.js#L197" rel="noopener ugc nofollow" target="_blank"> <em class="km">观察器</em> </a>，称为渲染观察器。</p><pre class="kn ko kp kq gt lb lc ld le aw lf bi"><span id="68a5" class="lg lh iq lc b gy li lj l lk ll"><br/>updateComponent = function () {<br/>   vm._update(vm._render(), hydrating);<br/>};</span><span id="4dad" class="lg lh iq lc b gy lm lj l lk ll">//Create the new watcher for updateComponent function <br/>new Watcher(vm, updateComponent, noop, {<br/>    before: function before () {<br/>        if (vm._isMounted &amp;&amp; !vm._isDestroyed) {<br/>                callHook(vm, 'beforeUpdate');<br/>    }<br/> }<br/>}, true /* isRenderWatcher */);</span></pre><p id="8532" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">渲染观察器被创建为eager，这使得<em class="km"> updateComponent </em>函数立即执行。在这个过程中，它使用我们计算的属性(<em class="km"> totalPrice </em>和<em class="km">discount price</em>)和数据属性(<em class="km"> price </em>和<em class="km"> quantity </em>)的值，因为它们用于呈现我们的DOM。如果您还记得，我们的计算属性观察器被创建为懒惰的，因此在呈现过程中也需要对它们进行评估。由于所有的观察器依次运行(呈现观察器，然后是计算属性观察器)，当数据属性获取器在其评估期间被调用时，它们将作为依赖项被收集。记住一次只能运行一个观察器是很重要的。</p><p id="8ec3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们的示例中，<em class="km"> price </em>数据属性在其依赖列表中有计算属性和呈现观察器，当price的值通过setter发生变化时，所有三个观察器将被通知以特定的顺序再次运行。值得指出的是，render watcher会更新虚拟DOM元素，在打补丁过程中会与旧的虚拟DOM进行比较，只有更改才会应用到实际的DOM中，这使得过程非常高效。</p><h1 id="1a4b" class="ls lh iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">结论</h1><p id="f55f" class="pw-post-body-paragraph jn jo iq jp b jq mp js jt ju mq jw jx jy mr ka kb kc ms ke kf kg mt ki kj kk ij bi translated">在这两部分系列中，我们已经讨论了Vue 2如何在引擎盖下实现其反应性。即将发布的Vue 3版本使用ES6代理对象，而不是getters和setters，这将在下一篇文章中介绍。</p></div></div>    
</body>
</html>