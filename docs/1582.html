<html>
<head>
<title>WebSocket error handling with RxJS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用RxJS处理WebSocket错误</h1>
<blockquote>原文：<a href="https://itnext.io/websocket-error-handling-with-rxjs-17125c6f2159?source=collection_archive---------0-----------------------#2018-11-30">https://itnext.io/websocket-error-handling-with-rxjs-17125c6f2159?source=collection_archive---------0-----------------------#2018-11-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="13b3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我爱RxJS！这篇博文展示了如何使用RxJS websocket客户端在出错时自动重新连接。</p><p id="0468" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">服务器</strong></p><p id="a80d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们创建一个简单的websocket服务器，每10条消息终止一次连接。这是使用<a class="ae kl" href="https://github.com/websockets/ws" rel="noopener ugc nofollow" target="_blank"> ws </a>包的简单节点服务器。</p><pre class="km kn ko kp gt kq kr ks kt aw ku bi"><span id="0f08" class="kv kw iq kr b gy kx ky l kz la">const WebSocket = require('ws');<br/>const wss = new WebSocket.Server({ port: 7777 });<br/><br/>wss.on('connection', function connection(ws) {<br/>  let count = 0;<br/>  ws.on('message', function incoming(message) {<br/>    if (count === 10) {<br/>      ws.terminate();<br/>    } else {<br/>      ws.send(message);<br/>      count++;<br/>    }<br/>  });<br/>});</span></pre><p id="f788" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> RxJS客户端</strong></p><p id="0a03" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以现在是时候看看RxJS提供了什么来处理websockets了。RxJS为我们提供了WebSocket object，它是浏览器提供的w3c兼容webSocket对象的包装器。这是:</p><pre class="km kn ko kp gt kq kr ks kt aw ku bi"><span id="7220" class="kv kw iq kr b gy kx ky l kz la"><a class="ae kl" href="http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#static-method-webSocket" rel="noopener ugc nofollow" target="_blank">webSocket</a>(urlConfigOrSource: string | WebSocketSubjectConfig): <a class="ae kl" href="http://reactivex.io/rxjs/class/es6/observable/dom/WebSocketSubject.js~WebSocketSubject.html" rel="noopener ugc nofollow" target="_blank">WebSocketSubject</a></span></pre><p id="559d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以用一行简单的代码创建websocket连接:</p><pre class="km kn ko kp gt kq kr ks kt aw ku bi"><span id="9ddf" class="kv kw iq kr b gy kx ky l kz la">const subject = <em class="lb">webSocket</em>('ws://localhost:7777');</span></pre><p id="6982" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">创建连接后，为了向服务器发送消息，只需像这样对主题执行next()即可:</p><pre class="km kn ko kp gt kq kr ks kt aw ku bi"><span id="0416" class="kv kw iq kr b gy kx ky l kz la">subject.next('hi there');</span></pre><p id="26c3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要从websocket接收消息，我们可以订阅主题:</p><pre class="km kn ko kp gt kq kr ks kt aw ku bi"><span id="25a3" class="kv kw iq kr b gy kx ky l kz la"><strong class="kr ir">const </strong>subscription = subject<br/>  .asObservable()<br/>  .subscribe(data =&gt; observer.next(data), <br/>             error =&gt; observer.error(error), <br/>             () =&gt; observer.complete());</span></pre><p id="55ce" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以我们有了创建websocket所需的所有块。Observable.create用于将逻辑包装成可观察对象。这里的示例代码还模拟了使用setInterval每秒发送一次消息。</p><pre class="km kn ko kp gt kq kr ks kt aw ku bi"><span id="437c" class="kv kw iq kr b gy kx ky l kz la">const <em class="lb">createWebSocket </em>= uri =&gt; {<br/>  return Observable.<em class="lb">create</em>(observer =&gt; {<br/>    try {<br/>      const subject = <em class="lb">webSocket</em>(uri);<br/><br/>      const handler = <em class="lb">setInterval</em>(() =&gt; {<br/>        subject.next('hi there');<br/>      }, 1000);<br/><br/>      const subscription = subject.asObservable()<br/>        .subscribe(data =&gt; <br/>                  observer.next(data), <br/>                  error =&gt; observer.error(error), <br/>                  () =&gt; observer.complete());<br/><br/>      return () =&gt; {<br/>        <em class="lb">clearInterval</em>(handler);<br/>        if (!subscription.closed) {<br/>          subscription.unsubscribe();<br/>        }<br/>      };<br/>    } catch (error) {<br/>      observer.error(error);<br/>    }<br/>  });<br/>};</span></pre><p id="a5fe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">使用retryWhen的错误处理</strong></p><p id="b26f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在RxJS websocket已经可以使用了。因为这只是一个可观察值，所以我们可以使用任何处理错误的RxJS操作符。<a class="ae kl" href="https://www.learnrxjs.io/operators/error_handling/retrywhen.html" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> retryWhen </strong> </a>对我们来说可能是个不错的选择——在服务器终止websocket连接的情况下，重新尝试打开它。</p><p id="4a80" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是使用websocket observable并用<a class="ae kl" href="https://www.learnrxjs.io/operators/error_handling/retrywhen.html" rel="noopener ugc nofollow" target="_blank"> retryWhen </a>处理错误的代码。</p><pre class="km kn ko kp gt kq kr ks kt aw ku bi"><span id="88ff" class="kv kw iq kr b gy kx ky l kz la"><em class="lb">createWebSocket</em>('ws://localhost:7777')<br/>  .pipe(<br/>    <em class="lb">retryWhen</em>(errors =&gt;<br/>      errors.pipe(<br/>        <em class="lb">tap</em>(err =&gt; {<br/>          <em class="lb">console</em>.error('Got error', err);<br/>        }),<br/>        <em class="lb">delay</em>(1000)<br/>      )<br/>    )<br/>  )<br/>  .subscribe(data =&gt; <em class="lb">console</em>.log(data), err =&gt; <em class="lb">console</em>.error(err));</span></pre></div></div>    
</body>
</html>