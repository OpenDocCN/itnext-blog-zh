<html>
<head>
<title>Make offline-capable Ionic apps with cached observables</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用缓存的可观察数据制作离线离子应用</h1>
<blockquote>原文：<a href="https://itnext.io/make-offline-capable-ionic-apps-with-cached-observables-12d79a3a1e75?source=collection_archive---------0-----------------------#2018-03-28">https://itnext.io/make-offline-capable-ionic-apps-with-cached-observables-12d79a3a1e75?source=collection_archive---------0-----------------------#2018-03-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/1436505aaa3ed1367d1e43f36ac2fae1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6zMKRppZJ_Sgj2undCCdsQ.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">应用应该是在线的，但不应该让用户在离线时束手无策。</figcaption></figure><p id="d598" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">因此，你正在开发下一个大型应用，一切都很好，除了当你的用户离线时，在一个接收信号不稳定的地区，或者一般来说连接很慢。突然，他们的个人资料、消息或任何从你的服务器API加载的应用内内容都非常慢，超时或无法加载。这是一个可怕的用户体验，让你的应用在离线时完全无用。</p><p id="3bb1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在这篇文章中，我们将研究如何缓存Ionic应用程序的可观测数据，以减少延迟，改善用户体验，并使您的应用程序在离线时仍能工作。</p><blockquote class="la"><p id="d6f4" class="lb lc iq bd ld le lf lg lh li lj kz dk translated">如果你只是想尝试一下，你可以在这里克隆示例源代码，然后用<code class="fe lk ll lm ln b">ionic serve</code>:<a class="ae lo" href="https://github.com/westphalen/ionic-offline-example" rel="noopener ugc nofollow" target="_blank">https://github.com/westphalen/ionic-offline-example</a>立即尝试一下</p></blockquote><h2 id="6026" class="lp lq iq bd lr ls lt dn lu lv lw dp lx kn ly lz ma kr mb mc md kv me mf mg mh bi translated">装置</h2><p id="2733" class="pw-post-body-paragraph kc kd iq ke b kf mi kh ki kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz ij bi translated">从启动一个新的离子项目开始。如果你以前没有这样做过，请务必前往IonicFramework.com<a class="ae lo" href="https://ionicframework.com/" rel="noopener ugc nofollow" target="_blank">阅读如何开始。</a></p><pre class="mn mo mp mq gt mr ln ms mt aw mu bi"><span id="203a" class="lp lq iq ln b gy mv mw l mx my">ionic start myOfflineApp</span></pre><p id="b902" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">你将需要两个包来实现这个奇迹，第一个是<code class="fe lk ll lm ln b">@ionic/storage</code>，它需要在应用程序会话之间存储数据，第二个是<code class="fe lk ll lm ln b">ionic-cache-observable</code>，它完成所有的魔法:</p><pre class="mn mo mp mq gt mr ln ms mt aw mu bi"><span id="38db" class="lp lq iq ln b gy mv mw l mx my">npm install --save @ionic/storage ionic-cache-observable</span></pre><p id="f94f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在我们需要在我们的<code class="fe lk ll lm ln b">AppModule</code>中注册模块，例如<code class="fe lk ll lm ln b">src/app/app.module.ts</code>:</p><pre class="mn mo mp mq gt mr ln ms mt aw mu bi"><span id="58a5" class="lp lq iq ln b gy mv mw l mx my">//.........<br/>@NgModule({<br/>  declarations: [<br/>    ...<br/>  ],<br/>  imports: [<br/>    ...<br/>    // Add the cache module<br/>    CacheModule, <br/>    // We will use the HttpClient for our API provider          <br/>    HttpClientModule, <br/>    // Add the storage module<br/>    IonicStorageModule.<em class="mz">forRoot</em>(),<br/>    IonicModule.<em class="mz">forRoot</em>(MyApp),<br/>    ...<br/>  ],<br/>//.........</span></pre><h2 id="9a47" class="lp lq iq bd lr ls na dn lu lv nb dp lx kn nc lz ma kr nd mc md kv ne mf mg mh bi translated">从API加载数据</h2><p id="5471" class="pw-post-body-paragraph kc kd iq ke b kf mi kh ki kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz ij bi translated">现在，如果您已经有了API数据的提供者，请跳过这一节。否则，让我们用来自<a class="ae lo" href="https://jsonplaceholder.typicode.com/" rel="noopener ugc nofollow" target="_blank"> JSONPlaceholder </a>的数据创建一个。</p><pre class="mn mo mp mq gt mr ln ms mt aw mu bi"><span id="1897" class="lp lq iq ln b gy mv mw l mx my">ionic g provider Placeholder</span></pre><p id="d272" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这将在<code class="fe lk ll lm ln b">src/providers/placeholder/placeholder.ts</code>创建您的新提供商。打开它，让我们添加一些API数据:</p><pre class="mn mo mp mq gt mr ln ms mt aw mu bi"><span id="5def" class="lp lq iq ln b gy mv mw l mx my">import { Injectable } from '@angular/common';<br/>import { HttpClient } from '@angular/common/http';</span><span id="3057" class="lp lq iq ln b gy nf mw l mx my">// Remember to import RxJs dependencies.<br/>import { Observable } from 'rxjs/Observable';<br/>import 'rxjs/add/observable/defer';<br/>import 'rxjs/add/operator/delay';</span><span id="4ab7" class="lp lq iq ln b gy nf mw l mx my">// Interface for the data returned by the JSONPlaceholder API<br/>export interface Placeholder {<br/>  userId: number;<br/>  id: number;<br/>  title: string;<br/>  body: string;<br/>}</span><span id="bf90" class="lp lq iq ln b gy nf mw l mx my">@Injectable()<br/>export class PlaceholderProvider {</span><span id="7902" class="lp lq iq ln b gy nf mw l mx my">  constructor(private http: HttpClient) {}</span><span id="8e51" class="lp lq iq ln b gy nf mw l mx my">  public random(): Observable&lt;Placeholder&gt; {<br/>    // Observable.defer makes sure we generate a <br/>    // random number each time the Observable is triggered.<br/>    return Observable.defer(() =&gt; {<br/>      const randIndex = Math.ceil(Math.rand() * 10); // 0-10</span><span id="157f" class="lp lq iq ln b gy nf mw l mx my">      const url = 'https://jsonplaceholder.typicode.com/posts/' <br/>        + randIndex;</span><span id="9c33" class="lp lq iq ln b gy nf mw l mx my">      return this.http.get&lt;Placeholder&gt;(url).delay(1000);<br/>    });<br/>  }</span><span id="da9b" class="lp lq iq ln b gy nf mw l mx my">}</span></pre><p id="0e74" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">好了，我们已经定义了一个接口，它描述了我们期望从API中得到的占位符数据。接下来是我们的随机函数，它从API请求随机数据，模拟我们的应用程序中不断变化的数据。此外，我们实施了一个<code class="fe lk ll lm ln b">1000 ms</code>延迟来模拟慢速连接——这样我们可以更好地看到发生了什么。</p><h2 id="e3f3" class="lp lq iq bd lr ls na dn lu lv nb dp lx kn nc lz ma kr nd mc md kv ne mf mg mh bi translated">在视图中缓存数据</h2><p id="30a2" class="pw-post-body-paragraph kc kd iq ke b kf mi kh ki kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz ij bi translated">到我们想要显示数据的页面上，例如<code class="fe lk ll lm ln b">src/pages/home/home.ts</code>:</p><pre class="mn mo mp mq gt mr ln ms mt aw mu bi"><span id="b13b" class="lp lq iq ln b gy mv mw l mx my">//....................<br/>export class HomePage {</span><span id="ddb7" class="lp lq iq ln b gy nf mw l mx my">  public data$: Observable&lt;Placeholder&gt;;</span><span id="15de" class="lp lq iq ln b gy nf mw l mx my">  constructor(placeholderProvider: PlaceholderProvider,<br/>              cacheService: CacheService) {<br/>    // The data we want to display on the page. <br/>    // This could be a user's profile or his list of todo items.<br/>    const dataObservable = placeholderProvider.random();</span><span id="640b" class="lp lq iq ln b gy nf mw l mx my">    // We register a cache instance, using a unique name <br/>    // so the CacheService will know what data to display next time.<br/>    cacheService.register('home', dataObservable)<br/>      .subscribe((cache) =&gt; {<br/>        this.data = cache.get$;<br/>      });<br/>  }<br/>// ......................</span></pre><p id="2c06" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在我们的页面组件中，我们为API数据注入了<code class="fe lk ll lm ln b">PlaceholderProvider</code>,为之前安装的包注入了<code class="fe lk ll lm ln b">CacheService</code>。然后<em class="mz">使用标识符<code class="fe lk ll lm ln b">'home'</code>向<code class="fe lk ll lm ln b">CacheService</code>注册</em>可观察到的API数据，以便能够识别会话之间的数据。寄存器observable为我们提供了<code class="fe lk ll lm ln b">cache</code>对象，从现在开始代表我们的<code class="fe lk ll lm ln b">Placeholder</code>数据。在这个简单的场景中，我们将把缓存的<code class="fe lk ll lm ln b">get$</code>赋给页面的<code class="fe lk ll lm ln b">data$</code>变量。缓存将自动从我们提供的<code class="fe lk ll lm ln b">dataObservable</code>中提取数据，我们可以在<code class="fe lk ll lm ln b">home.html</code>中显示这些数据:</p><pre class="mn mo mp mq gt mr ln ms mt aw mu bi"><span id="2f3b" class="lp lq iq ln b gy mv mw l mx my">&lt;ion-content&gt;<br/>  &lt;div *ngIf="data$ | async as data"&gt;<br/>    &lt;h1&gt;{{ data.title }}&lt;/h1&gt;<br/>    &lt;p&gt;{{ data.body }}&lt;/p&gt;<br/>  &lt;/div&gt;<br/>&lt;/ion-content&gt;</span></pre><p id="b249" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">当<code class="fe lk ll lm ln b">data$</code>更新时,<code class="fe lk ll lm ln b">async</code>管道将自动更新视图。</p><p id="7a81" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在，使用<code class="fe lk ll lm ln b">ionic serve</code>启动应用程序，或者在您的设备上运行它。当你第一次打开页面的时候，你应该注意到在一个随机的标题和正文从我们的API中出现之前有一秒钟的延迟。现在弹出页面，刷新或重新打开应用程序，看看奇迹发生。当您第二次导航到该页面时，数据或多或少会立即出现，尽管数据应该是随机的，但我们显示的内容与之前完全相同。API从不被调用，所以这些数据甚至可以在离线时显示出来！但是当然，我们不希望一直显示过时的数据。让我们看看如何刷新缓存。</p><h2 id="f84a" class="lp lq iq bd lr ls na dn lu lv nb dp lx kn nc lz ma kr nd mc md kv ne mf mg mh bi translated">刷新缓存数据</h2><p id="fa88" class="pw-post-body-paragraph kc kd iq ke b kf mi kh ki kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz ij bi translated">让我们使用凉爽的<strong class="ke ir">离子清新器</strong>组件制作一个简单的清新功能。返回到您的页面组件，例如<code class="fe lk ll lm ln b">home.ts</code>:</p><pre class="mn mo mp mq gt mr ln ms mt aw mu bi"><span id="e30c" class="lp lq iq ln b gy mv mw l mx my">//....................<br/>export class HomePage {</span><span id="cdce" class="lp lq iq ln b gy nf mw l mx my">  public data$: Observable&lt;Placeholder&gt;;</span><span id="3bc0" class="lp lq iq ln b gy nf mw l mx my">  private cache: Cache&lt;Placeholder&gt;;</span><span id="19bf" class="lp lq iq ln b gy nf mw l mx my">  constructor(placeholderProvider: PlaceholderProvider,<br/>              cacheService: CacheService) {<br/>    const dataObservable = placeholderProvider.random();</span><span id="f4e0" class="lp lq iq ln b gy nf mw l mx my">    cacheService.register('home', dataObservable)<br/>      .subscribe((cache) =&gt; {<br/>        // Save the cache object.<br/>        this.cache = cache;</span><span id="e2a4" class="lp lq iq ln b gy nf mw l mx my">        this.data = this.cache.get$;<br/>      });<br/>  }</span><span id="9366" class="lp lq iq ln b gy nf mw l mx my">  onRefresh(refresher: Refresher): void {<br/>    // Check if the cache has registered.<br/>    if (this.cache) {<br/>      this.cache.refresh().subscribe(() =&gt; {<br/>        // Refresh completed, complete the refresher animation.<br/>        refresher.complete();<br/>      }, (err) =&gt; {<br/>        // Something went wrong! <br/>        // Log the error and cancel refresher animation.<br/>        console.error('Refresh failed!', err);</span><span id="8fd4" class="lp lq iq ln b gy nf mw l mx my">        refresher.cancel();<br/>      });<br/>    } else {<br/>      // Cache is not registered yet, so cancel refresher animation.<br/>      refresher.cancel();<br/>    }<br/>  }<br/>// ......................</span></pre><p id="ddbe" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这里有两件事发生了变化。在构造函数中，我们现在在page类上设置了<code class="fe lk ll lm ln b">cache</code>对象，所以我们可以从第二个变化中访问它，我们新的<code class="fe lk ll lm ln b">onRefresh</code>函数，它从Ionic Refresher组件中获取一个<code class="fe lk ll lm ln b">Refresher</code>参数。在这个函数中，我们简单地在缓存对象上调用refresh，然后通过<code class="fe lk ll lm ln b">refresher</code>相应地更新UI。您不需要担心刷新的数据，因为它会自动推送到<code class="fe lk ll lm ln b">data$</code>。</p><p id="5e05" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在您的页面模板中实现Ionic Refresher组件，例如<code class="fe lk ll lm ln b">home.html</code>:</p><pre class="mn mo mp mq gt mr ln ms mt aw mu bi"><span id="8766" class="lp lq iq ln b gy mv mw l mx my">&lt;ion-content&gt;<br/>  &lt;ion-refresher (ionRefresh)="onRefresh($event)"&gt;<br/>    &lt;ion-refresher-content&gt;&lt;/ion-refresher-content&gt;<br/>  &lt;/ion-refresher&gt;</span><span id="6fe2" class="lp lq iq ln b gy nf mw l mx my">  &lt;div *ngIf="data$ | async as data"&gt;<br/>    &lt;h1&gt;{{ data.title }}&lt;/h1&gt;<br/>    &lt;p&gt;{{ data.body }}&lt;/p&gt;<br/>  &lt;/div&gt;<br/>&lt;/ion-content&gt;</span></pre><p id="ba99" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们在这里所做的只是添加了调用我们的<code class="fe lk ll lm ln b">onRefresh</code>函数的<code class="fe lk ll lm ln b">ion-refresher</code>。</p><p id="7244" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在启动你的应用程序。您应该仍然可以看到之前缓存的数据。执行一次拉至刷新操作，等待大约一秒钟，您应该会看到数据发生了变化！缓存对象在后台调用您注册的可观察对象，并在新数据到达时立即推送。刷新你的应用，最新的内容仍然会加载，直到你再次点击刷新。好吧，但是用户不应该一直拉着刷新。让我们看看自动刷新内容。</p><h2 id="3a22" class="lp lq iq bd lr ls na dn lu lv nb dp lx kn nc lz ma kr nd mc md kv ne mf mg mh bi translated">自动刷新</h2><p id="f7d1" class="pw-post-body-paragraph kc kd iq ke b kf mi kh ki kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz ij bi translated">您可以保留有用的拉至刷新功能，并自动提供刷新的数据。我们只需要改变页面组件中的一些东西，例如:</p><pre class="mn mo mp mq gt mr ln ms mt aw mu bi"><span id="4360" class="lp lq iq ln b gy mv mw l mx my">//....................<br/>constructor(private placeholderProvider: PlaceholderProvider,<br/>            private cacheService: CacheService) {<br/>  // I have moved to ionViewWillEnter.<br/>}</span><span id="b95c" class="lp lq iq ln b gy nf mw l mx my">  ionViewWillEnter() {<br/>    const dataObservable = placeholderProvider.random();</span><span id="f824" class="lp lq iq ln b gy nf mw l mx my">    cacheService.register('home', dataObservable)<br/>      .subscribe((cache) =&gt; {<br/>        this.cache = cache;</span><span id="3b11" class="lp lq iq ln b gy nf mw l mx my">        this.data = this.cache.get$;</span><span id="37ae" class="lp lq iq ln b gy nf mw l mx my">        // Refresh the cache immediately.<br/>        this.cache.refresh().subscribe();<br/>      });<br/>  }</span><span id="fbff" class="lp lq iq ln b gy nf mw l mx my">// .....................</span></pre><p id="da0c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们已经将缓存注册从构造函数转移到了<code class="fe lk ll lm ln b">ionViewWillEnter</code>方法中，每次用户想要打开页面时都会调用这个方法。这包括在视图之间导航，因此即使不关闭或重新加载应用程序，用户也会在每次打开视图时看到刷新的数据。一旦<code class="fe lk ll lm ln b">ionViewWillEnter</code>方法从<code class="fe lk ll lm ln b">cacheService.register</code>中检索到<code class="fe lk ll lm ln b">cache</code>对象，我们马上调用<code class="fe lk ll lm ln b">cache.refresh()</code>。不需要处理订阅，因为我们只想静默刷新数据。</p><p id="2cab" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">试试吧！每次打开页面，您都会立即看到旧数据，但大约一秒钟后，刷新/随机数据会替换缓存的数据。而且还可以拉刷新！不要害怕多次调用<code class="fe lk ll lm ln b">cache.refresh()</code>，因为刷新观察是共享的。因此，即使您的页面已经在后台刷新数据，您的用户也可以安全地进行拉式刷新。</p><h2 id="393a" class="lp lq iq bd lr ls na dn lu lv nb dp lx kn nc lz ma kr nd mc md kv ne mf mg mh bi translated">感谢阅读！</h2><p id="b1fe" class="pw-post-body-paragraph kc kd iq ke b kf mi kh ki kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz ij bi translated">如果这对你有帮助，请鼓掌！此外，如果您有任何问题或反馈，请不要犹豫，留下您的评论。</p><p id="cd80" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在GitHub上阅读更多关于<code class="fe lk ll lm ln b">ionic-cache-observable</code>包及其可能性的信息:<a class="ae lo" href="https://github.com/westphalen/ionic-cache-observable" rel="noopener ugc nofollow" target="_blank">https://github.com/westphalen/ionic-cache-observable</a></p><p id="b49b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">请随意建议新功能或提交改进请求。</p></div></div>    
</body>
</html>