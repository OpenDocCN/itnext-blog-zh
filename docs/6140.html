<html>
<head>
<title>How To Blur Objects in Real-Time With Video and Canvas</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用视频和画布实时模糊对象</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-blur-objects-in-real-time-with-video-and-canvas-898cddc01ae6?source=collection_archive---------2-----------------------#2021-08-31">https://itnext.io/how-to-blur-objects-in-real-time-with-video-and-canvas-898cddc01ae6?source=collection_archive---------2-----------------------#2021-08-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/4aec36884eb947203a9c001d515abfc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gR0d_5b9uAJZrGYiAIYYqQ.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://unsplash.com/@sigmund?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">西格蒙德</a>在<a class="ae kc" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><p id="f7ee" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">保密是现代社会非常重要的一部分。当你在公共场所用手机拍摄视频时，进入画面的人不会总是对此感到高兴。为了防止这种情况，面部被模糊或像素化。</p><p id="ec2f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">今天我想在网上分享这种视频(图像)模糊/像素化的实现。</p><p id="a60e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们所拥有的:</p><ul class=""><li id="fdcf" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">浏览器</li><li id="de3e" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">录像</li><li id="6f66" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">视频的元数据</li><li id="a5bf" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">每一帧的人脸坐标数组(之前使用人脸检测算法获得)</li><li id="fcc2" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">关于JavaScript、Canvas和一些CSS的知识</li></ul><p id="efd5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将分别模糊面部和整个图像，除了面部。</p><p id="0b17" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">看起来是这样的:</p><figure class="lq lr ls lt gt jr gh gi paragraph-image"><div class="gh gi lp"><img src="../Images/47e26ec29dad9dfbd1192aba87c22676.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*V-wYRWPhsTaSnA2ACqGIhQ.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">外部模糊</figcaption></figure><figure class="lq lr ls lt gt jr gh gi paragraph-image"><div class="gh gi lp"><img src="../Images/cc1a21b69e6358d17b1e403db4cde8ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*2Z-ej_burVxomZ0aPi1Q3g.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">内心模糊</figcaption></figure><p id="ddc7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们走吧。</p><h1 id="6cf7" class="lu lv iq bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">如何获取视频的元数据</h1><p id="9b5b" class="pw-post-body-paragraph kd ke iq kf b kg ms ki kj kk mt km kn ko mu kq kr ks mv ku kv kw mw ky kz la ij bi translated">首先，我们需要获取视频的元数据。为此，请访问网站<code class="fe mx my mz na b"><a class="ae kc" href="https://gpac.github.io/mp4box.js/test/filereader.html" rel="noopener ugc nofollow" target="_blank">https://gpac.github.io/mp4box.js/test/filereader.html</a></code>并上传视频。</p><p id="02ff" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">打开<code class="fe mx my mz na b">src/constants/video.ts</code>并更改参数。</p><figure class="lq lr ls lt gt jr"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="6d44" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mx my mz na b">framesCount</code>是在<code class="fe mx my mz na b">Box View -&gt; Tree View-&gt; moov -&gt; trak -&gt;mdia -&gt; minf -&gt; stbl -&gt; stts</code>的<code class="fe mx my mz na b">sample_counts</code></p><figure class="lq lr ls lt gt jr gh gi paragraph-image"><div class="gh gi lp"><img src="../Images/644320438c632326fed0437508525f11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*R-o8xcYD-S3YnlVjno-UfQ.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">如何找到framesCount参数</figcaption></figure><p id="8738" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mx my mz na b">framesDurations</code>是<code class="fe mx my mz na b">Box View -&gt; Tree View-&gt; moov -&gt; trak -&gt;mdia -&gt; minf -&gt; stbl -&gt; stts</code>里的<code class="fe mx my mz na b">sample_deltas</code></p><figure class="lq lr ls lt gt jr gh gi paragraph-image"><div class="gh gi lp"><img src="../Images/fcebb3f0c30464496eba375f34c36d29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*RtqWh6eznDcr_DBbNTL1mQ.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">如何找到框架尺寸参数</figcaption></figure><p id="3f3e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mx my mz na b">timeScale</code>是<code class="fe mx my mz na b">Box View -&gt; Tree View-&gt; moov -&gt; trak -&gt;mdia -&gt; mdhd</code>里的<code class="fe mx my mz na b">timescale</code></p><figure class="lq lr ls lt gt jr gh gi paragraph-image"><div class="gh gi lp"><img src="../Images/d5779230877934bb3f066abc8f6917d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*3rHecoR2jfspQDOJYDiAAQ.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">如何查找时间刻度参数</figcaption></figure><p id="1499" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将需要所有这些元数据来根据视频当前时间正确地确定帧。</p><h1 id="f5d3" class="lu lv iq bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">如何使用视频</h1><p id="d800" class="pw-post-body-paragraph kd ke iq kf b kg ms ki kj kk mt km kn ko mu kq kr ks mv ku kv kw mw ky kz la ij bi translated">我们有视频，我们想播放它，并在上面模糊面孔。但是我们不能只使用一个视频标签，因为我们不能在运行中编辑它，也不能在浏览器中使用它。要做到这一点，你可以在画布上绘制这个视频。</p><p id="02d8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">渲染算法非常简单:</p><ol class=""><li id="51f1" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la nd lh li lj bi translated">创建一个视频元素，并将URL设置为视频</li></ol><figure class="lq lr ls lt gt jr"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="d684" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">2.创建一个画布元素，并将其宽度和高度设置为视频元素，获取其上下文</p><figure class="lq lr ls lt gt jr"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="98ba" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">3.在画布上绘制当前帧</p><figure class="lq lr ls lt gt jr"><div class="bz fp l di"><div class="nb nc l"/></div></figure><blockquote class="ne nf ng"><p id="157f" class="kd ke nh kf b kg kh ki kj kk kl km kn ni kp kq kr nj kt ku kv nk kx ky kz la ij bi translated">*方法<code class="fe mx my mz na b">drawImage</code>接受接口:<code class="fe mx my mz na b">HTMLOrSVGImageElement</code> | <code class="fe mx my mz na b">HTMLVideoElement</code> | <code class="fe mx my mz na b">HTMLCanvasElement</code> | <code class="fe mx my mz na b">ImageBitmap</code> | <code class="fe mx my mz na b">OffscreenCanvas</code>，这就是为什么我们可以传递视频元素，当前帧会自己绘制。</p></blockquote><p id="d561" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">执行这段代码后，我们会看到一个黑色的矩形。这是因为我们的视频当前在时间线0中。要在打开视频时看到图像，你需要做一点黑客。首次渲染视频时，将当前视频时间设定为0.0001。</p><figure class="lq lr ls lt gt jr"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="3e16" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在另一个问题出现了:我们需要在回放时绘制视频帧。</p><p id="5a60" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">可以尝试订阅<code class="fe mx my mz na b">timeupdate</code>活动，但是结果会让你不爽。它每秒被触发4-5次，我们将得到一个幻灯片作为渲染的结果。</p><figure class="lq lr ls lt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nl"><img src="../Images/9cf7fe7c2ba55b9828122c5daeb4ce1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:394/format:webp/1*LKojec6ZY_QNQuT4lrA6vg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">timeupdate事件调用频率</figcaption></figure><p id="09b5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的视频以每秒30帧的速度播放。是的，这不是我们所期望的，让我们进一步尝试。</p><p id="8d83" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用对<code class="fe mx my mz na b">requestAnimationFrame</code>的递归调用，我们可以更频繁地(在最好的情况下每秒60次)调用一个方法来接收视频上的时间并确定帧。</p><figure class="lq lr ls lt gt jr"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="d5ec" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们有了画布上的“玩家”。还有待学习如何模糊面部。</p><p id="33e2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们对模糊的选择:</p><ul class=""><li id="35a4" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">对象内部的高斯模糊</li><li id="d2c4" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">对象外部的高斯模糊</li><li id="88be" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">像素化内部对象</li><li id="6f5e" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">像素化外部对象</li></ul><h1 id="69e2" class="lu lv iq bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated"><strong class="ak">高斯模糊</strong></h1><p id="73c9" class="pw-post-body-paragraph kd ke iq kf b kg ms ki kj kk mt km kn ko mu kq kr ks mv ku kv kw mw ky kz la ij bi translated">为了实现这种情况，我们需要在画布上再画两个画布，并渲染视频帧。一个是模糊整个画布，第二个是根据坐标从模糊的画布中剪切出必要的对象。</p><figure class="lq lr ls lt gt jr gh gi paragraph-image"><div class="gh gi lp"><img src="../Images/6cb6c1f1ae1221151ba3b3247cfd8c58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*56YPsFQ6g4eceG-6DCQo0Q.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">用于模糊对象的带有画布的层</figcaption></figure><p id="513d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">模糊整个图层很容易。要做到这一点，你需要应用一个给定强度的模糊过滤器，在我的实现中，它是30。这里使用亮度是为了增强模糊效果，因为对于明亮的图像，你仍然会看到太多模糊的东西。然后剩下的就是在这块画布上画出我们的视频帧。</p><figure class="lq lr ls lt gt jr"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="c45f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们需要通过坐标来切割我们的对象。我们有每个帧上所有对象的数据(坐标为x，y，高度和宽度，模糊类型)，所以你只需要遍历帧上的所有对象，然后施一点魔法。</p><p id="298e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们形成关于物体所在区域的数据。</p><figure class="lq lr ls lt gt jr"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="97d4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这将是一个长方形，但我们需要一个椭圆形…好吧，好吧，现在一切都将完成。</p><p id="d8c9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">用一点学校知识，我们得到高度和宽度的半径，并找到椭圆的中心。使用<code class="fe mx my mz na b">clip</code>绘制椭圆并约束其绘制区域。</p><p id="d0f8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后一步。<code class="fe mx my mz na b">drawImage</code>方法将根据我们如何模糊(物体内部或外部)来选择不同的图层。如果我们需要模糊物体的外部，我们从视频中获取图像，如果在内部，我们从模糊的画布中获取图像。</p><figure class="lq lr ls lt gt jr"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="ba29" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可能已经注意到，出于某种原因，对象是按<code class="fe mx my mz na b">isBlurOut</code>字段排序的。</p><figure class="lq lr ls lt gt jr"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="086c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是针对当我们在帧上有外部模糊的对象和内部模糊的对象，并且它们在某些区域相交的情况。为了让一个内部模糊的物体覆盖在图像上，我们首先需要绘制所有外部模糊的物体，然后在图像上绘制内部模糊的物体。</p><figure class="lq lr ls lt gt jr gh gi paragraph-image"><div class="gh gi lp"><img src="../Images/79070e3455028bef5f1db0c5c62ea2cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*8D77KVpLCwlsKs-gDiaZXA.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">对象的交集</figcaption></figure><h1 id="c9b5" class="lu lv iq bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">像素化</h1><p id="5a52" class="pw-post-body-paragraph kd ke iq kf b kg ms ki kj kk mt km kn ko mu kq kr ks mv ku kv kw mw ky kz la ij bi translated">像素化会有一点困难。让我们首先考虑对象内部像素化的情况。我们在画布上也有两层渲染视频。但是这里也有一个小黑客。</p><p id="246e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们模糊了整个画布的图层上，现在我们将图像缩小12.5倍并上色。在<code class="fe mx my mz na b">downsizeRatio</code>公式中有一个<code class="fe mx my mz na b">blurIntensity</code>，这样我们可以减小或增加像素大小。</p><figure class="lq lr ls lt gt jr"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="7e23" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们得到以下结果</p><figure class="lq lr ls lt gt jr gh gi paragraph-image"><div class="gh gi lp"><img src="../Images/05c9bd740c242901dd34c7ce798102a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*3pIQgABzXDeCtPhzJLYLNQ.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">缩小图像</figcaption></figure><p id="55f2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，当我们遍历框架中的所有对象时，我们会得到这个结果，因为我们正在以真实大小绘制椭圆，但我们从左上角的小图像中获取图片。结果是我们拉伸它，得到一个像素化的图像。</p><figure class="lq lr ls lt gt jr gh gi paragraph-image"><div class="gh gi lp"><img src="../Images/6c55b965167a75dbc2422b258c5d4f7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*O-ckksIaQp2QJKp75dTnWA.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">获取像素化图像</figcaption></figure><p id="b260" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">太神奇了！</p><figure class="lq lr ls lt gt jr gh gi paragraph-image"><div class="gh gi lp"><img src="../Images/2f6954e494aec599493c1dd90643c7a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*4WTSQuPlmtR7rvPMyqNKXw.png"/></div></figure><p id="b007" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">还需要考虑整个帧的像素化。这是一个相当困难的操作，需要的不仅仅是几行代码。</p><figure class="lq lr ls lt gt jr"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="08a5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你需要从带有渲染视频的画布中获取<code class="fe mx my mz na b">imageData</code>，这将是一个包含图像像素描述的巨大数组。该阵列中的每4个元素描述每个像素的RGBA。</p><figure class="lq lr ls lt gt jr"><div class="bz fp l di"><div class="nb nc l"/></div></figure><figure class="lq lr ls lt gt jr gh gi paragraph-image"><div class="gh gi lp"><img src="../Images/ba5b620b5544af37127156fdef4cc3f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*g-JVLDZZiTyr_RQEQ5skww.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">ImageData数组</figcaption></figure><p id="b81f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这就是为什么像素化整个帧需要很多时间。</p><p id="1566" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但并非所有事情都如此糟糕，我们不需要检查整个阵列。根据<code class="fe mx my mz na b">pixelSize</code>(一个像素的大小，或者换句话说，我们想要将多少个像素合并到一个矩形中)，我们需要遍历这个数组的次数会少得多。</p><p id="224c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">运行每个像素，它是<code class="fe mx my mz na b">pixelSize</code>的倍数，我们使用以下公式计算它在具有图像的RGBA表示的阵列中的位置:</p><figure class="lq lr ls lt gt jr"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="3797" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们通过使用<code class="fe mx my mz na b">pixelSize</code>绘制像素及其颜色，将我们的更改应用到画布上:</p><figure class="lq lr ls lt gt jr"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="2682" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你还记得我们用高斯模糊滤镜使图像变暗吗？所以，忘了这个实现吧:)</p><figure class="lq lr ls lt gt jr"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="a1ca" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们尝试用这个实现像素化时，需要很长时间，一帧需要几秒钟，你可以通过点击<a class="ae kc" href="https://objects-blur-demo.vercel.app" rel="noopener ugc nofollow" target="_blank">演示</a>中的<code class="fe mx my mz na b">Pixelate with canvas filter</code>按钮来检查。</p><p id="5cf8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是我们不会放弃这一点，我们对CSS有一点了解，所以是时候应用它了。</p><figure class="lq lr ls lt gt jr"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="1282" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">已应用:)</p><p id="c019" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以通过点击<code class="fe mx my mz na b">Pixelate with CSS filter</code>按钮在<a class="ae kc" href="https://objects-blur-demo.vercel.app" rel="noopener ugc nofollow" target="_blank">演示</a>中检查结果。它真的会让你大吃一惊。</p><h1 id="0664" class="lu lv iq bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">结论</h1><p id="d924" class="pw-post-body-paragraph kd ke iq kf b kg ms ki kj kk mt km kn ko mu kq kr ks mv ku kv kw mw ky kz la ij bi translated">谢谢你把文章看完。你可以在<a class="ae kc" href="https://github.com/yantsishko/objects-blur-example" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到代码，并查看<a class="ae kc" href="https://objects-blur-demo.vercel.app" rel="noopener ugc nofollow" target="_blank">在线演示</a>。</p><p id="bff9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">没有什么不可能，只是时间问题。</p><p id="7bc0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">P.S .如果有人能告诉我如何在像素化时混合相邻像素的颜色，使其不那么“粗糙”，我将非常感谢。<code class="fe mx my mz na b">OpenCV.js</code>不提供应用程序的开销。</p></div></div>    
</body>
</html>