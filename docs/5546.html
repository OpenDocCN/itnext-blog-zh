<html>
<head>
<title>Running Your Microservices Securely on AKS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在AKS上安全运行您的微服务</h1>
<blockquote>原文：<a href="https://itnext.io/running-your-microservices-securely-on-aks-417a110b2e76?source=collection_archive---------0-----------------------#2021-03-31">https://itnext.io/running-your-microservices-securely-on-aks-417a110b2e76?source=collection_archive---------0-----------------------#2021-03-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="b183" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Azure提供了不同的方式来构建和运行您的微服务，从<a class="ae ko" href="https://docs.microsoft.com/en-us/azure/service-fabric/" rel="noopener ugc nofollow" target="_blank">服务架构</a>到<a class="ae ko" href="https://docs.microsoft.com/en-us/azure/aks/" rel="noopener ugc nofollow" target="_blank"> Azure Kubernetes服务</a>到<a class="ae ko" href="https://docs.microsoft.com/en-us/azure/app-service/" rel="noopener ugc nofollow" target="_blank">应用服务</a>到<a class="ae ko" href="https://azure.microsoft.com/en-au/services/spring-cloud/" rel="noopener ugc nofollow" target="_blank"> Azure Spring云</a>甚至是在Azure上以IAAS模式运行<a class="ae ko" href="https://azuremarketplace.microsoft.com/en-us/marketplace/apps?search=docker%20enterprise&amp;page=1" rel="noopener ugc nofollow" target="_blank"> Docker Enterprise </a>和<a class="ae ko" href="https://azuremarketplace.microsoft.com/en-us/marketplace/apps/mesosphere.dcos?tab=Overview" rel="noopener ugc nofollow" target="_blank">Apache Mesos</a>——计算的选择取决于很多因素，不排除这些服务的亲和力和知识、市场宣传(尤其是在Kubernetes的情况下)、现有服务的兼容性在本文中，我们不会试图比较Azure中的这些计算选项，而是专注于在Azure Kubernetes服务中“安全地”运行您的微服务。为了使它更具可读性，我计划把它分成一系列的步骤和文章。</p><ol class=""><li id="f669" class="kp kq it js b jt ju jx jy kb kr kf ks kj kt kn ku kv kw kx bi translated">在本地创建Spring Boot应用程序并使用Azure SQL数据库</li><li id="61c3" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn ku kv kw kx bi translated">使用Terraform和Azure DevOps在Azure上部署初始基础设施</li><li id="06d8" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn ku kv kw kx bi translated">使用AKS托管Azure AD集成代替群集身份的服务主体，并使用Azure AD Pod身份将托管身份与Pod相关联。</li><li id="3a91" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn ku kv kw kx bi translated">使用Azure Devops管道对接Spring Boot应用并在AKS上部署。</li><li id="f24e" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn ku kv kw kx bi translated">使用KeyVault管理应用程序的机密，而不是使用Base 64编码的kubernetes机密。</li><li id="6679" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn ku kv kw kx bi translated">使用密钥库、Azure SQL和容器注册表的专用链接保护通信b/w PAAS服务和AKS群集。</li><li id="9ae4" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn ku kv kw kx bi translated">使用Azure Policy Add-on for AKS来实施基本治理(无特权pod，仅允许来自特定ACR的映像等。)</li><li id="b2ad" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn ku kv kw kx bi translated">使用Kubernetes网络策略来限制出入流量b/w名称空间或b/w pods &amp; services。</li><li id="eab7" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn ku kv kw kx bi translated">使用带有应用程序网关或前门或API管理的Web应用程序防火墙(WAF)来防范常见的漏洞，如XSS、SQL注入、CSRF攻击等。</li></ol><p id="d6ae" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了保护您的部署，您还可以做许多本系列中没有涉及到的事情，至少在最初是这样的(但是您必须考虑您的用例)</p><ul class=""><li id="73a3" class="kp kq it js b jt ju jx jy kb kr kf ks kj kt kn ld kv kw kx bi translated">使用私有AKS集群并部署Bastion和Jumpbox来访问。然后，您必须使用自托管代理，而不是使用Microsoft托管的Azure DevOps代理来部署到私有AKS集群。</li><li id="f192" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn ld kv kw kx bi translated">使用防火墙(如<a class="ae ko" href="https://docs.microsoft.com/en-us/azure/firewall/overview" rel="noopener ugc nofollow" target="_blank"> Azure Firewall </a>或任何其他NVA)来控制入站&amp;输出过滤，检测&amp;阻止恶意流量——通常，我们建议在典型的中心辐射拓扑中的中心虚拟网络中部署防火墙，该拓扑可以集中控制多个辐射虚拟网络</li><li id="8c9d" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn ld kv kw kx bi translated">Azure机密计算:AKS现在支持运行机密计算节点(使用英特尔SGX处理器)来保护您使用中的数据。详情<a class="ae ko" href="https://docs.microsoft.com/en-us/azure/confidential-computing/confidential-nodes-aks-overview" rel="noopener ugc nofollow" target="_blank">此处</a></li><li id="1a2f" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn ld kv kw kx bi translated">使用<a class="ae ko" href="https://github.com/weaveworks/kured" rel="noopener ugc nofollow" target="_blank"> Kured </a>的节点安全性—管理和维护数据平面节点(虚拟机)是一种共同责任。虽然Azure platform会自动应用操作系统安全补丁，但它不能也不应该重启您的虚拟机(在某些情况下可能需要重启)，因此客户有责任在需要时监控并重启这些节点&amp;。使用像<a class="ae ko" href="https://github.com/weaveworks/kured" rel="noopener ugc nofollow" target="_blank"> Kured </a>这样的开源解决方案真的很有帮助。</li><li id="8709" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn ld kv kw kx bi translated">在DevOps管道中使用容器映像之前，扫描容器映像中的漏洞。或者启用<a class="ae ko" href="https://docs.microsoft.com/en-us/azure/security-center/defender-for-container-registries-introduction" rel="noopener ugc nofollow" target="_blank">Azure Defender for container registries</a>，如果它发现您的图像有问题，会通知您</li></ul></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="5146" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">我们开始吧</h1><blockquote class="mj mk ml"><p id="5711" class="jq jr mm js b jt ju jv jw jx jy jz ka mn kc kd ke mo kg kh ki mp kk kl km kn im bi translated">第一步:本地Spring Boot应用+ Azure SQL</p></blockquote><p id="ce76" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了快速开始，我们将使用<a class="ae ko" href="https://github.com/Azure-Samples/quickstart-spring-data-jdbc-sql-server" rel="noopener ugc nofollow" target="_blank"> Spring Boot SQL快速入门</a>作为起点，为您提供一个在本地运行并在Azure中访问SQL Server的Spring Boot应用。一旦你运行了，让我们进入下一步</p><blockquote class="mj mk ml"><p id="78cc" class="jq jr mm js b jt ju jv jw jx jy jz ka mn kc kd ke mo kg kh ki mp kk kl km kn im bi translated">步骤2:在Azure中部署初始基础设施</p></blockquote><p id="ea0c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们在Azure中的初始基础设施包括</p><ol class=""><li id="07e1" class="kp kq it js b jt ju jx jy kb kr kf ks kj kt kn ku kv kw kx bi translated">只有一个子网来托管我们的AKS集群的虚拟网络(是的，我们随后将在此虚拟网络中添加更多子网)</li><li id="caef" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn ku kv kw kx bi translated">一个非常基本的AKS集群，启用了<a class="ae ko" href="https://docs.microsoft.com/en-us/azure/aks/configure-azure-cni" rel="noopener ugc nofollow" target="_blank"> Azure CNI </a>网络插件，而不是默认的Kubenet插件，并使用<a class="ae ko" href="https://docs.microsoft.com/en-us/azure/aks/managed-aad" rel="noopener ugc nofollow" target="_blank"> AKS管理的Azure AD </a>而不是传统的Azure AD集成和Azure Container registry实例来保存微服务的docker映像。</li><li id="7d73" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn ku kv kw kx bi translated">SQL server、无服务器SQL数据库和用于保存审核日志的存储帐户</li></ol><figure class="mr ms mt mu gt mv gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi mq"><img src="../Images/ad11717a3a855224cde8c17df618f45e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VlqVhKB3SNzH0TyEgayMVw.jpeg"/></div></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk translated">初始部署架构</figcaption></figure><p id="2664" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">创建上述内容的所有terraform代码都位于<a class="ae ko" href="https://github.com/agrajm/spring-boot-aks/tree/master/src/terraform" rel="noopener ugc nofollow" target="_blank">这里</a>。作为最佳实践，我们将使用Azure Storage作为terraform的远程后端来存储Terraform状态。我有一个构建管道，它创建了一个资源组、一个存储帐户和一个保存存储帐户访问密钥的密钥库。这个存储帐户将保存我们的地形状态文件。</p><figure class="mr ms mt mu gt mv"><div class="bz fp l di"><div class="ng nh l"/></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk translated">为Terraform远程后端设置Azure资源</figcaption></figure><p id="6593" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">请注意，此存储帐户<code class="fe ni nj nk nl b">TF_STATE_STORAGE_ACCOUNT_NAME</code>和密钥库<code class="fe ni nj nk nl b">KEYVAULT_NAME</code>与应用程序将使用的不同。如果你需要更多的细节，请参考朱利安的<a class="ae ko" href="https://blog.jcorioland.io/archives/2019/09/09/terraform-microsoft-azure-remote-state-management.html" rel="noopener ugc nofollow" target="_blank">这篇优秀的博客</a>。</p><p id="a77b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我将使用Azure DevOps管道为这个项目建立和发布管道，一切(包括初始基础设施)将通过管道<a class="ae ko" href="https://github.com/agrajm/spring-boot-aks/blob/master/infra-pipeline.yml" rel="noopener ugc nofollow" target="_blank">部署</a>。在使用Azure Devops运行这个简单的Terraform模板时，我学到了一些东西，我想强调一下:</p><ol class=""><li id="bfe8" class="kp kq it js b jt ju jx jy kb kr kf ks kj kt kn ku kv kw kx bi translated"><strong class="js iu">使用AZ CLI任务运行Terraform </strong> <br/>我使用以下代码片段通过Azure CLI任务部署Terraform代码</li></ol><figure class="mr ms mt mu gt mv"><div class="bz fp l di"><div class="ng nh l"/></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk translated">部署Terraform代码的示例AZ CLI任务</figcaption></figure><p id="5a67" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">除了通过<code class="fe ni nj nk nl b">azureSubscription</code>附加服务连接并将<code class="fe ni nj nk nl b">workingDirectory</code>更改为指向包含terraform代码的目录的常规内容之外，还要特别注意</p><ul class=""><li id="8cc0" class="kp kq it js b jt ju jx jy kb kr kf ks kj kt kn ld kv kw kx bi translated"><code class="fe ni nj nk nl b">addSpnToEnvironment: true</code> —这将服务连接的服务主体和键添加到脚本执行环境中，您可以通过<code class="fe ni nj nk nl b">$env:servicePrincipalID</code>、<code class="fe ni nj nk nl b">$env:servicePrincipalKey</code>和<code class="fe ni nj nk nl b">$env:tenantId</code>访问该脚本执行环境，我们在上面的代码片段中使用这些脚本来配置执行Terraform <code class="fe ni nj nk nl b">init/plan/apply/destroy</code>所需的环境变量。</li><li id="b563" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn ld kv kw kx bi translated">terraform <code class="fe ni nj nk nl b">init</code>命令使用远程存储并指定<code class="fe ni nj nk nl b">storage account</code>名称、<code class="fe ni nj nk nl b">container</code>和<code class="fe ni nj nk nl b">key</code>来存储状态。要让terraform能够访问存储帐户，请使用与帐户相关联的访问密钥或SAS令牌。我已经在上面使用的keyvault中存储了存储帐户的访问密钥，但是您也可以在Azure DevOps中使用变量组，并将其与keyvault相关联，以获取机密并使它们作为环境变量可用。</li></ul><p id="c50d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> 2。通过Azure DevOps变量覆盖terraform变量</strong></p><p id="3e9c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，我们已经在terraform代码中使用了一些变量来保存SQL server和SQL数据库名称以及登录详细信息。此外，在我们部署这个terraform代码之前，我们必须为AKS集群管理员创建一个Azure AD组，并将其objectId分配给terraform变量— <code class="fe ni nj nk nl b">aks_admin_group_id</code> —这个AAD组的成员将拥有对我们集群的管理员访问权限。</p><figure class="mr ms mt mu gt mv gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi nm"><img src="../Images/6ad5af16ed8d6260f3594c499439d24f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1080/format:webp/1*qssP0W6FVoCX0Y7hehSvJw.png"/></div></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk translated">Terraform模板中的变量</figcaption></figure><p id="734e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">其中一些值是机密，应该位于密钥库中，而不是作为配置的一部分，所以我在Azure DevOps中创建了一个变量组，将其链接到包含机密值的密钥库</p><figure class="mr ms mt mu gt mv gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi nn"><img src="../Images/e5921479901307184c28d7700377c171.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-JiFYZ8XvMsZ0NmafARDXA.png"/></div></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk translated">secretVariableGroup组持有密钥库中的密钥</figcaption></figure><p id="94db" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">默认情况下，所有的秘密都可以作为任务中的环境变量，所以只需通过将<code class="fe ni nj nk nl b">TF_VAR_</code>附加到变量名来替换变量值，这样，如果您在terraform中的变量被命名为<code class="fe ni nj nk nl b">sql_server_admin_login</code>，您可以通过指定<code class="fe ni nj nk nl b">TF_VAR_sql_server_admin_login</code>来覆盖它，就像我们在执行<code class="fe ni nj nk nl b">terraform plan</code>之前所做的那样</p><figure class="mr ms mt mu gt mv"><div class="bz fp l di"><div class="ng nh l"/></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk translated">将Azure DevOps变量用于Terraform变量</figcaption></figure><p id="af7b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第2–5行用于指定多个变量组(机密和非机密),这对于将变量划分到多个可重用的组中总是有好处的，这些组可以在相关的管道中共享。</p><p id="e478" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第32–37行将这些组中的秘密和变量公开为Terraform变量，遵循我们的约定<code class="fe ni nj nk nl b">TF_VAR_&lt;variable_name&gt;</code>——现在我们可以执行管道的<code class="fe ni nj nk nl b">plan</code>和<code class="fe ni nj nk nl b">apply</code>阶段，并在Azure中部署基础设施。</p><figure class="mr ms mt mu gt mv gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi no"><img src="../Images/e9ac3b3953731a9541fac9cc97a622bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FpmlDUSxbh1J3nTIJKgB_w.png"/></div></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk translated">管道成功部署到Azure</figcaption></figure><p id="dad5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">转到门户网站，确认您的基础架构已经正确部署。</p><blockquote class="mj mk ml"><p id="013e" class="jq jr mm js b jt ju jv jw jx jy jz ka mn kc kd ke mo kg kh ki mp kk kl km kn im bi translated">第三步:对Spring Boot应用程序进行分类</p></blockquote><p id="6ea0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们已经在Azure中有了所需的基础架构，让我们开始向我们的<a class="ae ko" href="https://github.com/agrajm/spring-boot-aks" rel="noopener ugc nofollow" target="_blank">项目</a>添加Dockerfile我们将使用多阶段构建方法和Spring Boot的<a class="ae ko" href="https://spring.io/blog/2020/01/27/creating-docker-images-with-spring-boot-2-3-0-m1" rel="noopener ugc nofollow" target="_blank">分层Jar </a>模式，并在我们的映像中提取不同的层，而不是使用fat jar</p><figure class="mr ms mt mu gt mv"><div class="bz fp l di"><div class="ng nh l"/></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk translated">我们春天的档案</figcaption></figure><p id="4729" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可以使用以下命令在本地测试它</p><pre class="mr ms mt mu gt np nl nq nr aw ns bi"><span id="7ea0" class="nt lm it nl b gy nu nv l nw nx">docker build . -t agrajm/spring-boot-aks:v1.0 </span></pre><p id="7582" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这将在本地构建它，并为您创建一个本地映像，您可以如下运行:</p><pre class="mr ms mt mu gt np nl nq nr aw ns bi"><span id="a9bb" class="nt lm it nl b gy nu nv l nw nx">docker run -it -p8080:8080 \<br/>-e SPRING_DATASOURCE_URL="&lt;Your_DB_Conn_String&gt;" \<br/>-e SPRING_DATASOURCE_USERNAME="&lt;Your_DB_UserName&gt;" \<br/>-e SPRING_DATASOURCE_PASSWORD="&lt;Your_DB_Password&gt;" \<br/>agrajm/spring-boot-aks:v1.0</span></pre><blockquote class="mj mk ml"><p id="0c01" class="jq jr mm js b jt ju jv jw jx jy jz ka mn kc kd ke mo kg kh ki mp kk kl km kn im bi translated">步骤4:部署到AKS —输入kubelogin for DevOps！</p></blockquote><p id="6afc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们首先尝试在本地部署到我们的AKS集群——我们需要首先对其进行身份验证。为此，请键入</p><pre class="mr ms mt mu gt np nl nq nr aw ns bi"><span id="7b16" class="nt lm it nl b gy nu nv l nw nx">az aks get-credentials --resource-group &lt;RG_NAME&gt; --name &lt;AKS_CLUSTER_NAME&gt;</span></pre><p id="c652" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这将创建或更新您的<code class="fe ni nj nk nl b">KUBECONFIG</code>,详细说明如何针对AKS集群进行认证。我的配置目前看起来像</p><figure class="mr ms mt mu gt mv gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi ny"><img src="../Images/f8f99c493613de673105a40b2c2c8aeb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*etVQsnFmRSgmADNMQBfg3w.jpeg"/></div></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk translated">已编辑~/。kube/配置</figcaption></figure><p id="678a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当我试图使用kubectl获取这个集群的节点时</p><figure class="mr ms mt mu gt mv gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi nz"><img src="../Images/6cc813165b3a900f40f3b790764b0af4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Bb6Knn8-yEAynPvmeyhcxw.png"/></div></div></figure><p id="68eb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它要求我使用我的Azure AD实例进行身份验证，因为我们的集群正在使用AKS托管的Azure AD集成——一旦我打开一个新选项卡并执行<code class="fe ni nj nk nl b">devicelogin</code>,并将代码&amp;我的凭据放入其中，它就会向我发出一个临时访问&amp;刷新令牌，该令牌会在同一个<code class="fe ni nj nk nl b">./kube/config</code>中更新，如下所示:</p><figure class="mr ms mt mu gt mv gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi oa"><img src="../Images/40381cdc1a994e761b0ed81deff854ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cVXtEBD1tDsaP8qN4ALwrQ.jpeg"/></div></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk translated">成功登录后访问和刷新令牌</figcaption></figure><p id="dfc7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们可以使用<code class="fe ni nj nk nl b">kubectl apply</code>将我们的应用程序部署到AKS，但是我们必须为我们的Spring Boot应用程序创建部署YAML。让我们使用下面的部署配置</p><figure class="mr ms mt mu gt mv"><div class="bz fp l di"><div class="ng nh l"/></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk translated">Kubernetes的部署</figcaption></figure><p id="d356" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在您已经通过了集群的身份验证，您可以使用<code class="fe ni nj nk nl b">kubectl</code>简单地应用更改</p><pre class="mr ms mt mu gt np nl nq nr aw ns bi"><span id="13de" class="nt lm it nl b gy nu nv l nw nx">kubectl apply -f depoloy/spring-boot-deployment.yaml</span></pre><p id="b902" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这将起作用，因为我当前登录的用户已经是AAD组的一部分，AAD组是AKS的管理组，但这将如何与您的管道一起工作-您无法从您的管道响应<code class="fe ni nj nk nl b">devicelogin</code>挑战-进入<a class="ae ko" href="https://github.com/Azure/kubelogin/" rel="noopener ugc nofollow" target="_blank"> Kubelogin </a>！</p><p id="3514" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">即使使用AAD管理的AKS集群，kubelogin也允许我们使用服务主体或最新版本进行非交互式登录——甚至使用Azure CLI令牌，这使其非常适合在CI/CD场景中使用。我们将使用后一种选择。因此，与我们的Azure CLI关联的服务主体也必须添加到同一个AAD组中，以便能够向群集进行身份验证并向其部署应用程序。</p><p id="2b9e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">此外，由于默认情况下<code class="fe ni nj nk nl b">kubelogin</code>不会安装在我的微软托管构建代理正在使用的最新ubuntu映像上，我必须先安装它，然后才能使用它。使用它的管道代码片段</p><figure class="mr ms mt mu gt mv"><div class="bz fp l di"><div class="ng nh l"/></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk translated">kube login convert-kube config-l azure CLI</figcaption></figure><p id="8b70" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">主命令是<code class="fe ni nj nk nl b">kubelogin convert-kubeconfig -l azurecli</code>，它允许您使用服务主体的底层令牌，该服务主体由Azure CLI任务用于您的管道。您必须将该SP添加到您的AAD组，就像我对AKS Admin AAD组所做的那样</p><figure class="mr ms mt mu gt mv gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi ob"><img src="../Images/a0c165f743450097c6da853d8aa6b663.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C9f4RbVg6c00TjPnoKNkiw.jpeg"/></div></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk translated">将您的部署SP添加到AKS Admin AAD组</figcaption></figure><p id="45aa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，AZDO管道应该能够认证Spring Boot应用程序并将其部署到您的AKS集群。</p><figure class="mr ms mt mu gt mv gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi oc"><img src="../Images/bc20724c2c5f3e72a83c4ea5709fe799.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O7k2ref1PhLYFSqAgvCC4g.png"/></div></div></figure></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="0c8c" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">后续步骤</h1><p id="11de" class="pw-post-body-paragraph jq jr it js b jt od jv jw jx oe jz ka kb of kd ke kf og kh ki kj oh kl km kn im bi translated">到目前为止，我们已经在AKS中部署了一个可以与Azure SQL数据库对话的Spring boot应用程序。但这只是冰山一角，我们需要把我在开始时承诺的所有安全控制措施都放进去——在下一组文章中，我们将继续这一旅程，共同学习如何在AKS上保护您的微服务(Spring Boot等)。直到那时，快乐的黑客！</p></div></div>    
</body>
</html>