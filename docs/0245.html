<html>
<head>
<title>GraphQL API integration tests in a Spring Boot 2.x Kotlin application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Spring Boot 2.x Kotlin应用程序中的GraphQL API集成测试</h1>
<blockquote>原文：<a href="https://itnext.io/graphql-api-integration-tests-in-a-spring-boot-2-x-kotlin-application-5840d3c5d66f?source=collection_archive---------0-----------------------#2018-01-24">https://itnext.io/graphql-api-integration-tests-in-a-spring-boot-2-x-kotlin-application-5840d3c5d66f?source=collection_archive---------0-----------------------#2018-01-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/5b40e77385666bca3c0db808f1c29e59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p_SAJcL95PLcPL7l8qRN3w.png"/></div></div></figure><p id="5d25" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在最近的一个项目中，我们集成了<a class="ae kw" href="https://github.com/graphql-java" rel="noopener ugc nofollow" target="_blank"> graphql-java </a>和<a class="ae kw" href="https://github.com/graphql-java/graphql-java-servlet" rel="noopener ugc nofollow" target="_blank"> graphql-java-servlet </a>，通过HTTP(通过at /graphql)公开了GraphQL API。</p><p id="f1d4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了测试端到端场景，我需要一种简单的方法来…</p><ul class=""><li id="8edf" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv lc ld le lf bi translated">启动后端，公开GraphQL API端点</li><li id="10c2" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">定义测试图查询</li><li id="9723" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">加载测试图SQL查询</li><li id="1c88" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">准备并发送GraphQL HTTP查询</li></ul><p id="7cfd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最重要的是，执行断言(对查询结果和后端状态)。</p><p id="242c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本文中，我假设您已经在使用graphql-java，并使用graphql-java-servlet或等效的方法来公开它。</p><h1 id="b0ae" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">启动后端，公开GraphQL API端点</h1><p id="842c" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">如果你习惯了Spring Boot，那么我就在这里扮演一下“明显队长”,但基本上只需要使用@SpringBootTest:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="2a8b" class="mx lm iq mt b gy my mz l na nb">...<br/>import org.codehaus.jackson.JsonNode<br/>import org.junit.jupiter.api.Assertions.*<br/>import org.junit.jupiter.api.Tag<br/>import org.junit.jupiter.api.Test<br/>import org.junit.jupiter.api.extension.ExtendWith<br/>import org.springframework.beans.factory.annotation.Autowired<br/>import org.springframework.boot.test.context.SpringBootTest<br/>import org.springframework.boot.test.web.client.TestRestTemplate<br/>import org.springframework.http.*<br/>import org.springframework.test.context.junit.jupiter.SpringExtension<br/><br/>@ExtendWith(SpringExtension::class)<br/>@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)<br/>class SomeMutationOrQueryResolverIT : AbstractIntegrationTest() {<br/><br/>    @field:Autowired<br/>    private lateinit var restTemplate: TestRestTemplate<br/><br/>    @field:Autowired<br/>    private lateinit var someRepository: SomeRepository<br/><br/>    @field:Autowired<br/>    private lateinit var graphQLTestUtils: GraphQLTestUtils<br/><br/>    @Test<br/>    fun `create thing should succeed when the input is valid`() {<br/>        ...<br/>    }<em class="nc"><br/></em>}</span></pre><p id="7c8b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请注意上面的内容:</p><ul class=""><li id="c090" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv lc ld le lf bi translated">我们用的是<a class="ae kw" href="https://spring.io/guides/gs/testing-web/" rel="noopener ugc nofollow" target="_blank"> @SpringBootTest。WebEnvironment.RANDOM_PORT </a>。这将启动应用程序，并引导测试后端所需的一切</li><li id="d94f" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">我们正在注入TestRestTemplate(由@SpringBootTest准备),我们将使用它来轻松地与/graphql上公开的GraphQL端点进行交互</li><li id="2efb" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">我们正在注入GraphQLTestUtils(下面将详细介绍)</li></ul><h1 id="b5ec" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">定义测试图查询</h1><p id="c9aa" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">接下来，为了避免在我们的测试类中编写难看的转义字符串或heredoc注释，它们被存储在src/test/resources/graphql下的专用文件中。</p><p id="9da2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，下面是create-thing.graphql:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="5ab8" class="mx lm iq mt b gy my mz l na nb"><strong class="mt ir">mutation </strong>{<br/>    createThing(name: "e", description: "cool") {<br/>        uuid,<br/>        name,<br/>        description<br/>    }<br/>}</span></pre><p id="47b2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将我们的测试查询存储在专用文件中有多种好处:</p><ul class=""><li id="6d8b" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv lc ld le lf bi translated">我们可以在IDE中进行自动完成和验证</li><li id="c3e7" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">没有必要逃避什么</li><li id="37c9" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">更容易维护</li></ul><p id="8ed5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在的问题是“我如何使用这些？”</p><h1 id="69fb" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">加载测试图SQL查询</h1><p id="9c00" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">因为我们使用的是Spring，我们可以很容易地做到这一点。下面是一个简单的测试配置，它将这些公开为可以在任何地方注入的beans:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="bdd1" class="mx lm iq mt b gy my mz l na nb">...<br/><br/>import org.springframework.beans.factory.annotation.Value<br/>import org.springframework.context.annotation.Bean<br/>import org.springframework.context.annotation.Configuration<br/>import org.springframework.core.io.Resource<br/>import org.springframework.util.StreamUtils<br/>import java.nio.charset.StandardCharsets<br/><br/>@Configuration<br/>class GraphQLTestConfiguration {<br/>    @Value("classpath:graphql/query-wrapper.json")<br/>    private lateinit var queryWrapperFile: Resource<br/><br/>    @Value("classpath:graphql/things/create-thing.graphql")<br/>    private lateinit var createThingPayloadFile: Resource<br/><br/>    @Bean<br/>    fun createThingPayload(): String {<br/>        return StreamUtils.copyToString(createThingPayloadFile.<em class="nc">inputStream</em>, StandardCharsets.<em class="nc">UTF_8</em>)<br/>    }<br/><br/>    @Bean<br/>    fun queryWrapper(): String {<br/>        return StreamUtils.copyToString(queryWrapperFile.<em class="nc">inputStream</em>, StandardCharsets.<em class="nc">UTF_8</em>)<br/>    }<br/>}</span></pre><p id="db6d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如您所见，这只是将文件作为资源注入并读取它的问题。我们将在下面进一步讨论“queryWrapper”。</p><p id="06ba" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于上述原因，我们现在可以轻松地在集成测试中插入测试查询:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="e505" class="mx lm iq mt b gy my mz l na nb">@field:Autowired<br/>private lateinit var createThingPayload: String</span></pre><h1 id="6c00" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">准备查询</h1><p id="6d64" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">对于graphql-java(我猜，可能还有其他通过HTTP公开graphql的实现)，发送到端点的GraphQL查询是在POST请求的主体中传递的，在JSON对象的“query”属性中。</p><p id="8006" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请求的正文如下所示:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="f1d2" class="mx lm iq mt b gy my mz l na nb">{<br/>  "query": "__payload__",<br/>  "variables": <strong class="mt ir">null<br/></strong>}</span></pre><p id="2180" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">其中__payload__是GraphQL查询的“JSON转义”版本。</p><p id="e585" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">到目前为止，我们已经有了可以注入到测试中的原始查询。现在我们需要一种简单的方法来构造合适的JSON有效负载。</p><p id="b89c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了方便起见，我将上面的JSON放在一个“query-wrapper.json”文件中，该文件也公开为一个Spring bean(前面显示的cfr配置类)。</p><p id="69dc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，我编写了一个小的实用Spring组件，它提供了一些函数，使逃避GraphQL查询和创建正确的JSON有效负载变得很容易:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="16e1" class="mx lm iq mt b gy my mz l na nb">...<br/>import org.codehaus.jackson.JsonNode<br/>import org.codehaus.jackson.io.JsonStringEncoder<br/>import org.codehaus.jackson.map.ObjectMapper<br/>import org.springframework.beans.factory.annotation.Autowired<br/>import org.springframework.stereotype.Component<br/><br/><em class="nc">/**<br/> * Small utility component for GraphQL tests.<br/> * </em><strong class="mt ir"><em class="nc">@author </em></strong><em class="nc">Sebastien Dubois<br/> */<br/></em>@Component<br/>class GraphQLTestUtils {<br/>    <em class="nc">/**<br/>     * Basic empty GraphQL query.<br/>     */<br/>    </em>@field:Autowired<br/>    private lateinit var queryWrapper: String<br/><br/>    private val jsonStringEncoder = JsonStringEncoder.getInstance()<br/><br/>    <em class="nc">/**<br/>     * Call this method with a valid GraphQL query/mutation String<br/>     * This function will escape it properly and wrap it into a JSON query object<br/>     */<br/>    </em>fun createJsonQuery(graphQL: String): String {<br/>        // <em class="nc">TODO add support for setting variables in the query<br/>        </em>return queryWrapper.<em class="nc">replace</em>("__payload__", escapeQuery(graphQL))<br/>    }<br/><br/>    <em class="nc">/**<br/>     * Clean the given QraphQL query so that it can be embedded in a JSON string.<br/>     */<br/>    </em>fun escapeQuery(graphQL: String): String {<br/>        return jsonStringEncoder.quoteAsString(graphQL).<em class="nc">joinToString</em>("")<br/>    }<br/><br/>    companion object {<br/>        <em class="nc">/**<br/>         * Where to send GraphQL requests<br/>         */<br/>        </em>const val ENDPOINT_LOCATION: String = "/graphql"<br/>    }<br/><br/>    <em class="nc">/**<br/>     * Parse the given payload as a [JsonNode]<br/>     * </em><strong class="mt ir"><em class="nc">@return </em></strong><em class="nc">the payload parsed as JSON<br/>     */<br/>    </em>fun parse(payload: String): JsonNode {<br/>        return ObjectMapper().readTree(payload)<br/>    }<br/>}</span></pre><h1 id="8508" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">发送GraphQL HTTP查询</h1><p id="0c3c" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">有了这些，通过HTTP发送GraphQL查询就非常简单了:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="3488" class="mx lm iq mt b gy my mz l na nb">...<br/>class SomeMutationOrQueryResolverIT : AbstractIntegrationTest() {<br/>    @field:Autowired<br/>    private lateinit var createThingPayload: String<br/><br/>    @field:Autowired<br/>    private lateinit var graphQLTestUtils: GraphQLTestUtils<br/><br/>    @Test<br/>    fun `create thing should succeed when the input is valid`() {<br/>        assertTrue(thingRepository.findAll().isEmpty(), "There should be nothing in the database yet")<br/>        // create the JSON version of the GraphQL query that will be added to the body of the request<br/>        val payload: String =  graphQLTestUtils.createJsonQuery(createSchoolPayload)<br/><br/>        // add the proper Content-Type header<br/>        val headers = HttpHeaders()<br/>        headers.<em class="nc">contentType </em>= MediaType.<em class="nc">APPLICATION_JSON<br/><br/>        </em>// prepare the request<br/>        val httpEntity: HttpEntity&lt;String&gt; = HttpEntity(payload, headers)<br/><br/>        // send the request<br/>        val response: ResponseEntity&lt;String&gt; =<br/>            restTemplate.exchange(GraphQLTestUtils.<em class="nc">ENDPOINT_LOCATION</em>, HttpMethod.<em class="nc">POST</em>, httpEntity, String::class.<em class="nc">java</em>)</span></pre><p id="b867" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里我们只使用Spring提供的TestRestTemplate来通过网络发送请求。</p><p id="873d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了简单起见，我们在这里只是以字符串的形式返回结果。</p><h1 id="1e90" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">执行断言</h1><p id="2c9a" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">要执行简单/基本的断言，您可以使用Jackson解析响应:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="62c3" class="mx lm iq mt b gy my mz l na nb">val response: ResponseEntity&lt;String&gt; =<br/>            restTemplate.exchange(GraphQLTestUtils.<em class="nc">ENDPOINT_LOCATION</em>, HttpMethod.<em class="nc">POST</em>, httpEntity, String::class.<em class="nc">java</em>)</span><span id="7af7" class="mx lm iq mt b gy nd mz l na nb">assertEquals(HttpStatus.<em class="nc">OK</em>, response.<em class="nc">statusCode</em>)<br/><br/>val parsedResponse: JsonNode = graphQLTestUtils.parse(response.<em class="nc">body</em>)<br/>assertNotNull(parsedResponse)<br/>assertNotNull(parsedResponse.get("data"))<br/>assertNotNull(parsedResponse.get("data").get("createSchool"))<br/>assertNotNull(parsedResponse.get("data").get("createSchool").get("uuid"))<br/>assertNull(parsedResponse.get("errors"))<br/><strong class="mt ir"><br/></strong>assertTrue(schoolRepository.findAll().isNotEmpty())</span></pre><p id="79ae" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">事实上，这对于可维护性来说并不好，但这是一个开始。</p><p id="fd73" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对这个想法的一个改进是尝试解析响应，并将其与预期的响应负载进行比较。</p></div></div>    
</body>
</html>