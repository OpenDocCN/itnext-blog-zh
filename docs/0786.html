<html>
<head>
<title>Strict stubs for better dev experience</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">更好的开发体验的严格存根</h1>
<blockquote>原文：<a href="https://itnext.io/strict-stubs-for-better-dev-experience-bb455f733753?source=collection_archive---------3-----------------------#2018-05-29">https://itnext.io/strict-stubs-for-better-dev-experience-bb455f733753?source=collection_archive---------3-----------------------#2018-05-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="05c9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">大多数现代的双测试库创建具有默认行为的存根。现在，如果被测试的代码以不同的方式使用存根，测试将会失败——更重要的是，会出现一个难以解释的错误。严格的存根有助于避免这个问题，从而提供更好的体验。<a class="ae kl" href="https://github.com/alexbepple/testdouble-only-when" rel="noopener ugc nofollow" target="_blank">test double-only——当</a>是与<a class="ae kl" href="https://github.com/testdouble/testdouble.js" rel="noopener ugc nofollow" target="_blank"> testdouble.js </a>一起使用的严格存根的助手时。</p></div><div class="ab cl km kn hu ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ij ik il im in"><h2 id="8868" class="kt ku iq bd kv kw kx dn ky kz la dp lb jy lc ld le kc lf lg lh kg li lj lk ll bi translated">又有什么问题？</h2><p id="486b" class="pw-post-body-paragraph jn jo iq jp b jq lm js jt ju ln jw jx jy lo ka kb kc lp ke kf kg lq ki kj kk ij bi translated">大多数存根都有默认行为。在Java领域，<a class="ae kl" href="http://mockito.org/" rel="noopener ugc nofollow" target="_blank"> Mockito </a>存根返回<em class="lr"> null、false、</em>等。当没有为呼叫排练特定行为时。在JavaScript领域，<a class="ae kl" href="https://github.com/testdouble/testdouble.js" rel="noopener ugc nofollow" target="_blank"> testdouble.js </a>存根和<a class="ae kl" href="http://sinonjs.org/" rel="noopener ugc nofollow" target="_blank"> Sinon </a>存根都返回<em class="lr"> undefined，</em>如果你以未经训练的方式调用它们。</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="4687" class="kt ku iq lx b gy mb mc l md me">import td from 'testdouble'<br/>const stub = td.func()<br/>td.when(stub(0)).thenReturn('foo')<br/>assertThat(stub(0), is('foo'))<br/>assertThat(stub(), is(undefined))</span></pre><p id="7814" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这有时甚至会很方便。然而，通常如果你对返回值做了什么，处理它或者传递它，<em class="lr"> undefined </em>很可能会给你带来问题。</p><p id="aa84" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在下面的示例中，被测试的函数<em class="lr"> (fut) </em>调用不带任何参数的存根，然后对存根的返回值调用<em class="lr"> substring(1) </em>。我们设置断言<em class="lr"> assertThat(fut(stub)，is(' oo ')</em>，假设存根将返回<em class="lr"> foo。然而，它不会，因为，不管出于什么原因，我们以不同的方式排练了它的行为。因此它将返回<em class="lr">未定义的</em>并且我们最终得到一个比其他任何东西都更令人困惑的错误消息，因为它没有指出问题的根本原因:</em></p><blockquote class="mf mg mh"><p id="f95f" class="jn jo lr jp b jq jr js jt ju jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj kk ij bi translated">TypeError:无法读取未定义的属性“substring”</p></blockquote><p id="8d91" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在可执行的术语中:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="b8a9" class="kt ku iq lx b gy mb mc l md me">describe('Problem', () =&gt; {<br/>  it('unrehearsed usage fails late because of the consequences of default stub behavior', () =&gt; {<br/>    const stub = td.function()<br/>    td.when(stub(0)).thenReturn('foo')</span><span id="5fc2" class="kt ku iq lx b gy ml mc l md me">    const fut = (collaborator) =&gt; collaborator().substring(1)</span><span id="8ba8" class="kt ku iq lx b gy ml mc l md me">    assertThat(<br/>      () =&gt; assertThat(fut(stub), is('oo')),<br/>      throws(<br/>        typedError(TypeError, "Cannot read property 'substring' of undefined")<br/>      )<br/>    )<br/>  })<br/>})</span></pre><p id="9e1f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您观察到的错误并不是测试代码行为不当的结果。相反，这个错误是完全不同的事情的结果。—想象你额头发热。你是刚跑完10公里还是因为感冒而发烧？</p><h2 id="9bc5" class="kt ku iq bd kv kw kx dn ky kz la dp lb jy lc ld le kc lf lg lh kg li lj lk ll bi translated">如果存根告诉我们它正以意想不到的方式被使用，这不是很好吗？</h2><p id="ee0b" class="pw-post-body-paragraph jn jo iq jp b jq lm js jt ju ln jw jx jy lo ka kb kc lp ke kf kg lq ki kj kk ij bi translated">进入<a class="ae kl" href="https://github.com/alexbepple/testdouble-only-when" rel="noopener ugc nofollow" target="_blank"> testdouble-only-when </a>。让我们仅使用而不是<em class="lr"> td.when. </em>来排练存根的行为</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="bb2f" class="kt ku iq lx b gy mb mc l md me">import { onlyWhen } from 'testdouble-only-when'<br/>const stub = td.function()<br/>onlyWhen(stub(0)).thenReturn('foo')</span></pre><p id="42aa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，使用排练过的存根的行为与前面一样:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="4495" class="kt ku iq lx b gy mb mc l md me">assertThat(stub(0), is('foo'))</span></pre><p id="0481" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，以不同的方式调用存根，例如<em class="lr"> stub() </em>不再返回<em class="lr"> undefined。</em>现在结果是:</p><blockquote class="mf mg mh"><p id="220c" class="jn jo lr jp b jq jr js jt ju jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj kk ij bi translated">错误:您以意外的方式调用了test double。这个测试double有1个存根和1个调用。</p><p id="c098" class="jn jo lr jp b jq jr js jt ju jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj kk ij bi translated">Stubbings: <br/> —用`( 0)调用时，返回`" foo " `。</p><p id="0e0b" class="jn jo lr jp b jq jr js jt ju jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj kk ij bi translated">调用:<br/> —用`()'调用。<br/>在…</p></blockquote><p id="f401" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">测试很早就失败了，你可以更准确地知道要寻找什么。</p></div><div class="ab cl km kn hu ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ij ik il im in"><p id="f1b0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://github.com/alexbepple/testdouble-only-when" rel="noopener ugc nofollow" target="_blank"> testdouble-only-when </a>几乎可以替代<em class="lr"> td.when(…)。</em>唯一的例外:多次存根。由于testdouble.js存根的定义方式，当您定义多个行为时，<em class="lr"> onlyWhen </em>无法工作。在那些罕见的情况下，你可以使用<em class="lr"> failOnOtherCalls: </em></p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="6f46" class="kt ku iq lx b gy mb mc l md me">import { failOnOtherCalls } from 'testdouble-only-when'<br/>const stub = td.function()<br/>td.when(stub(0)).thenReturn('foo')<br/>td.when(stub(1)).thenReturn('bar')<br/>failOnOtherCalls(stub)</span></pre></div><div class="ab cl km kn hu ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ij ik il im in"><p id="3d92" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">PS:有些人可能还记得，在Mockito流行之前，Java领域的一个主要的双测试库是EasyMock。它的存根在未经练习的情况下会失败。人们必须明确地<a class="ae kl" href="http://easymock.org/user-guide.html#mocking-nice" rel="noopener ugc nofollow" target="_blank">要求EasyMock stub变得更好</a>,这样它才能像其他库中常见的那样表现出默认行为。</p></div><div class="ab cl km kn hu ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ij ik il im in"><p id="cbdb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你愿意，你可以在草稿上阅读这个版本，语法高亮<a class="ae kl" href="https://gist.github.com/alexbepple/2fdfacbaa58bff914a98dd1b96a7d77d" rel="noopener ugc nofollow" target="_blank">作为要点</a> / <a class="ae kl" href="http://alexbepple.roughdraft.io/2fdfacbaa58bff914a98dd1b96a7d77d-stricter-stubs-for-better-dev-experience" rel="noopener ugc nofollow" target="_blank">。</a></p></div></div>    
</body>
</html>