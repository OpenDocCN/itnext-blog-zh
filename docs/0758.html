<html>
<head>
<title>Administering two or more Docker swarm clusters with Portainer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Portainer管理两个或更多Docker集群</h1>
<blockquote>原文：<a href="https://itnext.io/administering-two-or-more-docker-swarm-clusters-with-portainerio-682d01a92b25?source=collection_archive---------2-----------------------#2018-05-22">https://itnext.io/administering-two-or-more-docker-swarm-clusters-with-portainerio-682d01a92b25?source=collection_archive---------2-----------------------#2018-05-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="bcc9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从版本<a class="ae kl" href="https://store.docker.com/community/images/portainer/portainer" rel="noopener ugc nofollow" target="_blank"> 1.17.0 </a>开始，伟大的开源工具<a class="ae kl" href="https://portainer.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir"><em class="km">Portainer</em></strong></a>使用部署在每个节点上的简单<a class="ae kl" href="https://store.docker.com/community/images/portainer/agent" rel="noopener ugc nofollow" target="_blank">代理</a>提供了一种简单的方式来管理您的Swarm集群，默认情况下使用<a class="ae kl" href="https://portainer.readthedocs.io/en/stable/agent.html#deploy-it-as-a-stack" rel="noopener ugc nofollow" target="_blank">安装指南</a>它将没有任何问题地工作。</p><p id="3708" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是如果你想控制两个或更多独立的蜂群，这需要一些调整，这是我们的图表</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi kn"><img src="../Images/e2261838122085653472b3b40a660773.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m6PKNAsUtndW99QUQbpFSA.png"/></div></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">集群和虚拟机</figcaption></figure><p id="dc01" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个部署使用几个栈来实现，首先是用于<strong class="jp ir"> <em class="km"> Portainer </em> </strong>及其本地代理(在同一个集群上运行的代理，DTICs)的栈</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="ld le l"/></div></figure><p id="e27e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上面的堆栈将部署一个服务<strong class="jp ir"> <em class="km"> agent_dtics </em> </strong>，该服务使用<a class="ae kl" href="https://store.docker.com/community/images/portainer/agent" rel="noopener ugc nofollow" target="_blank"> portainer/agent </a>映像，并使用内部DNS Docker条目<strong class="jp ir"> <em class="km"> tasks定位。portainer_agent_dtics，</em> </strong> due以全局模式部署。该代理在群集群的每个节点上运行，使用名为<strong class="jp ir"> <em class="km"> agent_network_dtics，</em> </strong>的覆盖网络相互连接。该网络还用于连接要部署该堆栈，只需在DTICs集群管理器中运行如下命令:</p><pre class="ko kp kq kr gt lf lg lh li aw lj bi"><span id="c868" class="lk ll iq lg b gy lm ln l lo lp"><em class="km">docker stack deploy -c docker-compose.yml portainer</em></span></pre><p id="c8a9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<strong class="jp ir"> <em class="km"> Portainer </em> </strong>实例后面有一个用<strong class="jp ir"> <em class="km"> HAProxy </em> </strong>实现的负载均衡器，这个负载均衡器使用<strong class="jp ir"> <em class="km"> rproxy </em> </strong>网络连接到<strong class="jp ir"> <em class="km"> Portainer </em> </strong>，并使用<strong class="jp ir"> <em class="km"> VIRTUAL_HOST </em> </strong>环境变量定义的URL公开。</p><p id="79ce" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要连接到我们的第二个swarm集群，我们需要执行两个步骤:</p><ul class=""><li id="c76c" class="lq lr iq jp b jq jr ju jv jy ls kc lt kg lu kk lv lw lx ly bi translated">创建一个指向第二个集群的负载平衡器的DNS条目</li><li id="36db" class="lq lr iq jp b jq lz ju ma jy mb kc mc kg md kk lv lw lx ly bi translated">仅在第二个集群上部署代理</li></ul><p id="0c4d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="km"> DNS </em> </strong>条目<strong class="jp ir">agentsdc . exa . unicen . edu . ar</strong>会是这样的:</p><pre class="ko kp kq kr gt lf lg lh li aw lj bi"><span id="4ec9" class="lk ll iq lg b gy lm ln l lo lp"># nslookup agentsdc.exa.unicen.edu.ar<br/>Server: 10.1.1.5<br/>Address: 10.1.1.5#53</span><span id="e330" class="lk ll iq lg b gy me ln l lo lp">Name: agentsdc.exa.unicen.edu.ar<br/>Address: <strong class="lg ir"><em class="km">10.254.0.155</em></strong><br/>Name: agentsdc.exa.unicen.edu.ar<br/>Address: <strong class="lg ir"><em class="km">10.254.0.156</em></strong></span></pre><p id="33b0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这两个IP是DC集群中HAProxy负载均衡器的公共IP</p><p id="4e53" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了在DC集群部署代理，我们定义了这个堆栈:</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="ld le l"/></div></figure><p id="edaa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用以下命令在DC集群的主节点上部署代理:</p><pre class="ko kp kq kr gt lf lg lh li aw lj bi"><span id="54ed" class="lk ll iq lg b gy lm ln l lo lp"><em class="km">docker stack deploy -c </em><strong class="lg ir"><em class="km">portainer-agent-stack.yml</em></strong><em class="km"> </em><strong class="lg ir"><em class="km">portainer_agent</em></strong></span></pre><p id="7931" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">与前一个堆栈一样，所有代理将运行在集群的每个节点上，并使用<strong class="jp ir"> <em class="km"> agent_network_dc </em> </strong>覆盖网络进行互连。</p><p id="cf77" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在DC集群也有一个负载均衡器，<strong class="jp ir"> <em class="km"> HAProxy </em> </strong>将使用在<strong class="jp ir"> <em class="km">虚拟主机</em> </strong>变量和<strong class="jp ir"> <em class="km">服务端口</em> </strong>值定义的URL公开代理服务；<strong class="jp ir"> <em class="km"> HEALTH_CHECK </em> </strong>值是定义一个<strong class="jp ir"> <em class="km"> TLS </em> </strong>通信通道<strong class="jp ir"> <em class="km"> HAProxy </em> </strong>和代理之间的一个诡计。</p><p id="dbd1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，我们需要在Portainer控制台定义DTICs和DC集群的端点，屏幕截图如下:</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi mf"><img src="../Images/99635d378319a9cefc485757cd4dce6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zMI90NhJNYEXHhCMfRwykw.png"/></div></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">DTICs集群端点—与Portainer相同的集群</figcaption></figure><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi mg"><img src="../Images/c91b62dfe97a578f01a3c45cf259f994.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y8xjuhDOyA9Y6TcTUkxIhw.png"/></div></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">DC集群端点</figcaption></figure><p id="9ccd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，我们有一个卫星<strong class="jp ir"> <em class="km"> VM </em> </strong>运行Docker，也可以使用<strong class="jp ir"> <em class="km"> Portainer </em> </strong>进行监控，方法是使用<strong class="jp ir"> <em class="km"> TLS </em> </strong>证书添加它，这里是端点:</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi mg"><img src="../Images/0bd764b094b2ee9db9c025e2a0b87717.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Re3WVGocV1gKrwSO5yocSA.png"/></div></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">使用TLS证书的虚拟机端点</figcaption></figure><p id="6ffb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">仅此而已，<strong class="jp ir"> <em class="km"> Portainer </em> </strong>将管理集成在一个全功能控制台中的所有堆栈、服务、容器和其他相关资源</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi mh"><img src="../Images/167b5675c6018089864df2b243a3521e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x8FLWEFACX0ffVgHrjD-Pg.png"/></div></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">DC集群主控制台</figcaption></figure><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi mi"><img src="../Images/3e6d8bab77f9233fa50f3057fd7e0215.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xj4IkJNNdZ-hYjcn5Ihfog.png"/></div></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">DTICs集群中所有正在运行的停靠站的容器列表</figcaption></figure><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi mj"><img src="../Images/1cf9aea521916b60b07bdd7d546274fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PPCdxUYNHaY9YECSQslI2w.png"/></div></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">在DTICs集群上运行的任何Docker容器的示例容器统计信息</figcaption></figure><p id="d990" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此处为并行堆栈、HAProxy负载平衡器堆栈(rproxy DTICs负载平衡器/ haproxy DC负载平衡器):</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="ld le l"/></div></figure></div></div>    
</body>
</html>