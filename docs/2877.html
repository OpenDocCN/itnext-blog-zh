<html>
<head>
<title>Firebase login functionality from scratch with React + Redux</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用React + Redux从零开始实现Firebase登录功能</h1>
<blockquote>原文：<a href="https://itnext.io/firebase-login-functionality-from-scratch-with-react-redux-2bf316e5820f?source=collection_archive---------0-----------------------#2019-08-20">https://itnext.io/firebase-login-functionality-from-scratch-with-react-redux-2bf316e5820f?source=collection_archive---------0-----------------------#2019-08-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/49a7714b0e4da35ca5ee67e2fde8f0e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EiyT12In4FE0bhEJ4Yiapw.png"/></div></div></figure><div class=""/><p id="eb1f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本教程中，我们将使用React和Redux创建一个带有全功能登录页面的Firebase web应用程序。我们还将创建必要的登录路由，以便拥有一个只有在用户登录后才能访问的受保护路由。</p><p id="aa4e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Firebase提供了一个免费的spark计划，不需要信用卡，因此任何人都可以跟随并设置自己的firebase web应用程序。完整代码链接在底部。这将是你未来应用的很好的开始代码！</p><p id="0338" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我假设您熟悉npm、javascript和React，但很少或没有Redux或Firebase经验。</p><h1 id="af40" class="kw kx jb bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">设置您的Firebase项目。</h1><p id="6190" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">登录到<a class="ae lz" href="https://console.firebase.google.com" rel="noopener ugc nofollow" target="_blank"> Firebase控制台</a>并添加一个新项目。遵循这些步骤，直到您到达项目主屏幕。点击菜单中的认证选项卡，然后点击<strong class="ka jc">设置登录方式</strong>按钮。</p><p id="bcb8" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本教程中，我们将设置<strong class="ka jc">电子邮件/密码</strong>认证方法。单击编辑并打开第一个开关。</p><figure class="mb mc md me gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ma"><img src="../Images/2c55becf3bc4e7ee2d346699e9761fdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Eic5WDLFsO4YMANvcOpW4A.png"/></div></div></figure><p id="1389" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">启用身份验证后，单击<strong class="ka jc">数据库</strong>菜单链接，然后单击云Firestore部分中的创建数据库。</p><p id="2cdc" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了这个项目，我们将建立Firestore。如果您想使用实时数据库，本教程基本上是相同的，因为身份验证是与您选择的数据库分开处理的。</p><figure class="mb mc md me gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/2e00cd3bd0233ffe5cf191375fc1bb0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*55CYu8PDzZOsYlWVfflcJw.png"/></div></div></figure><p id="909b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在测试模式下选择<strong class="ka jc">开始</strong>。</p><figure class="mb mc md me gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mg"><img src="../Images/39c8461025d8c1173beeaeec2a7f66e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j_SChKe1A3bVHumTRrMdYQ.png"/></div></div></figure><p id="ba84" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，为您的数据库主机选择最适合您的项目的位置。多地区选择之一通常是完美的。</p><figure class="mb mc md me gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mh"><img src="../Images/9db81cb4c5b2fe3452fe22cd9f636172.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-uyce5oSG6WaulDrTNJsag.png"/></div></div></figure><p id="c718" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">单击“完成”, firebase将为我们计划要做的事情做好准备。</p></div><div class="ab cl mi mj hu mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ij ik il im in"><h1 id="50ad" class="kw kx jb bd ky kz mp lb lc ld mq lf lg lh mr lj lk ll ms ln lo lp mt lr ls lt bi translated">设置react应用程序。</h1><p id="3ddb" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">首先安装<a class="ae lz" href="https://github.com/facebook/create-react-app" rel="noopener ugc nofollow" target="_blank"> create-react-app </a>。完成后，在您希望应用程序所在的目录中运行以下命令:</p><pre class="mb mc md me gt mu mv mw mx aw my bi"><span id="bebe" class="mz kx jb mv b gy na nb l nc nd">create-react-app your-project-name</span></pre><p id="2cca" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">完成后，让我们确保一切正常。打开在终端/命令行中生成的create-react-app的新项目目录，并运行以下命令:</p><pre class="mb mc md me gt mu mv mw mx aw my bi"><span id="cf69" class="mz kx jb mv b gy na nb l nc nd">npm run start</span></pre><p id="a2c0" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您的浏览器应该会打开，您应该会看到如下所示的页面:</p><figure class="mb mc md me gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ma"><img src="../Images/0eac51f216ce04b3a95974887ab1869c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-c00HCDzX1oj3PbJQB47nw.png"/></div></div></figure><h1 id="8bb3" class="kw kx jb bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">在react应用程序中初始化firebase</h1><p id="44c6" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">运行以下命令安装<a class="ae lz" href="https://github.com/firebase/firebase-tools" rel="noopener ugc nofollow" target="_blank"> firebase-tools </a>。</p><pre class="mb mc md me gt mu mv mw mx aw my bi"><span id="caa0" class="mz kx jb mv b gy na nb l nc nd">npm install -g firebase-tools</span></pre><p id="d727" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">完成后，运行以下命令登录firebase</p><pre class="mb mc md me gt mu mv mw mx aw my bi"><span id="4a99" class="mz kx jb mv b gy na nb l nc nd">firebase login</span></pre><p id="5ae9" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">按照步骤操作。成功登录后，运行以下命令在react-app中初始化firebase(确保您在项目目录中):</p><pre class="mb mc md me gt mu mv mw mx aw my bi"><span id="1a34" class="mz kx jb mv b gy na nb l nc nd">firebase init</span></pre><p id="11eb" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将为这个项目设置主机和firestore，如果你喜欢firebase的实时数据库，请随意选择该选项，因为本教程将对两者都有效，但请确保在选择实时数据库之前设置它。</p><figure class="mb mc md me gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/09cd53650c1c26650dd897a6e1fb8607.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9Xk8tMpPMa8TESgk0Y88dg.png"/></div></div></figure><p id="cc77" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">点击回车键，你应该会看到一个firebase项目列表。选择您之前创建的那个。</p><p id="3b18" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果出现错误，请确保在继续操作之前，按照之前设置Firestore的步骤进行操作。</p><p id="2d50" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">选择Firestore规则和Firestore索引的默认文件名。</p><p id="026c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">选择<strong class="ka jc"> build </strong>作为默认的公共目录，因为这是我们的项目编译的目录。<strong class="ka jc">不选公。</strong></p><figure class="mb mc md me gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mh"><img src="../Images/88faafe982cdb40e48743f0ed777798b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8P7Dm7CXSU1G-n--AKDrFw.png"/></div></div></figure><p id="2388" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">键入<strong class="ka jc"> y </strong>确认这将是一个单页应用程序。</p><p id="60b3" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">键入<strong class="ka jc"> N </strong>拒绝覆盖index.html，因为create-react-app已经给了我们所需要的。</p><p id="e51a" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们确认一下我们是否正确设置了firebase。首先，构建用于部署的react应用程序。</p><pre class="mb mc md me gt mu mv mw mx aw my bi"><span id="6b28" class="mz kx jb mv b gy na nb l nc nd">npm run build</span></pre><p id="47ae" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，运行以下命令来提供应用程序的本地版本，看看如果将它部署到firebase会是什么样子:</p><pre class="mb mc md me gt mu mv mw mx aw my bi"><span id="f0fe" class="mz kx jb mv b gy na nb l nc nd">firebase serve</span></pre><p id="3240" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你应该在<a class="ae lz" href="http://localhost:5000" rel="noopener ugc nofollow" target="_blank"> http://localhost:5000 </a>看到你的react应用。</p><h2 id="7618" class="mz kx jb bd ky ne nf dn lc ng nh dp lg kj ni nj lk kn nk nl lo kr nm nn ls no bi translated">安装必要的软件包。</h2><p id="743e" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">Create-react-app几乎提供了我们需要的所有东西，但我们仍然需要添加一些东西才能开始。</p><p id="2deb" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于<a class="ae lz" href="https://github.com/reduxjs/redux" rel="noopener ugc nofollow" target="_blank"> Redux </a>，让我们运行以下命令:</p><pre class="mb mc md me gt mu mv mw mx aw my bi"><span id="44e6" class="mz kx jb mv b gy na nb l nc nd">npm install redux </span></pre><p id="cfa7" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于<a class="ae lz" href="https://github.com/reduxjs/react-redux" rel="noopener ugc nofollow" target="_blank"> React-Redux </a></p><pre class="mb mc md me gt mu mv mw mx aw my bi"><span id="752b" class="mz kx jb mv b gy na nb l nc nd">npm install react-redux</span></pre><p id="cb47" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们也安装<a class="ae lz" href="https://github.com/reduxjs/redux-thunk" rel="noopener ugc nofollow" target="_blank"> Redux Thunk </a>。它是一个非常有用的中间件，允许您轻松地创建异步操作:</p><pre class="mb mc md me gt mu mv mw mx aw my bi"><span id="1a11" class="mz kx jb mv b gy na nb l nc nd">npm install redux-thunk</span></pre><p id="e373" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于我们的客户端路由，让我们安装<a class="ae lz" href="https://reacttraining.com/react-router/web/guides/quick-start" rel="noopener ugc nofollow" target="_blank">反应路由器</a>。这将允许我们设置我们的登录页面和受保护的登录区域:</p><pre class="mb mc md me gt mu mv mw mx aw my bi"><span id="2082" class="mz kx jb mv b gy na nb l nc nd">npm install react-router-dom</span></pre><p id="6200" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，让我们安装firebase，它允许我们在react应用程序中与firebase进行交互。</p><pre class="mb mc md me gt mu mv mw mx aw my bi"><span id="b8c4" class="mz kx jb mv b gy na nb l nc nd">npm install firebase</span></pre><h2 id="22e8" class="mz kx jb bd ky ne nf dn lc ng nh dp lg kj ni nj lk kn nk nl lo kr nm nn ls no bi translated">为您的项目选择一个UI库(或者不选择)。</h2><p id="a875" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">我将使用<a class="ae lz" href="https://material-ui.com/getting-started/installation/" rel="noopener ugc nofollow" target="_blank">材质Ui </a>，但是你可以随意选择bootstrap或者任何你喜欢的库。我不打算详细介绍样式或基本组件设置。</p><pre class="mb mc md me gt mu mv mw mx aw my bi"><span id="abfd" class="mz kx jb mv b gy na nb l nc nd">npm install @material-ui/core</span></pre><p id="1597" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将以下内容粘贴到您的<strong class="ka jc"> public/index.html </strong>页面的标题中，以获得Roboto字体。</p><pre class="mb mc md me gt mu mv mw mx aw my bi"><span id="bb90" class="mz kx jb mv b gy na nb l nc nd">&lt;link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700&amp;display=swap" /&gt;</span></pre><p id="7b99" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">安装材料图标库:</p><pre class="mb mc md me gt mu mv mw mx aw my bi"><span id="86ca" class="mz kx jb mv b gy na nb l nc nd">npm install @material-ui/icons</span></pre><p id="87b1" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这就是我们的设置！</p></div><div class="ab cl mi mj hu mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ij ik il im in"><h1 id="c7c5" class="kw kx jb bd ky kz mp lb lc ld mq lf lg lh mr lj lk ll ms ln lo lp mt lr ls lt bi translated">设置我们的授权操作。</h1><p id="19b7" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">这是一个很大的设置，但现在我们准备开始编码！我们将开始在我们的<strong class="ka jc"> src </strong>目录中创建三个文件夹:<strong class="ka jc">动作</strong>、<strong class="ka jc">减速器、firebase。</strong></p><p id="1939" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，创建这五个空文件:<strong class="ka jc"> actions/index.js </strong>，<strong class="ka jc"> actions/auth.js </strong>，<strong class="ka jc"> reducers/index.js </strong>，<strong class="ka jc"> reducers/auth.js </strong>，<strong class="ka jc"> firebase/firebase.js </strong>。</p><h2 id="4fdd" class="mz kx jb bd ky ne nf dn lc ng nh dp lg kj ni nj lk kn nk nl lo kr nm nn ls no bi translated">获取我们的firebase配置文件设置。</h2><p id="3872" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">回到<a class="ae lz" href="https://console.firebase.google.com" rel="noopener ugc nofollow" target="_blank">火焰基座控制台</a>并点击顶部的齿轮图标:</p><figure class="mb mc md me gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi np"><img src="../Images/719da27dc3f6a7c80e3e523d46286797.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dZwDCwFr_cMcrvv_6uHWgA.png"/></div></div></figure><p id="5275" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">单击项目设置链接并滚动到底部。然后，让我们将firebase添加到我们的web应用程序中:</p><figure class="mb mc md me gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nq"><img src="../Images/817dbe4cae5c850c99c885d86658896f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cvsrG4m6r7i0s6bVTexRpg.png"/></div></div></figure><p id="f5da" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后将其注册到您的项目中:</p><figure class="mb mc md me gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nr"><img src="../Images/dd0b047021d1350107077b80f054004e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*36NdtBgxsdSiixu0kez1tQ.png"/></div></div></figure><p id="31c8" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">单击注册应用程序后，您可以离开此表单向导，返回到项目设置页面并滚动到底部。你应该看到你的应用程序了。让我们像这样得到<strong class="ka jc">配置</strong>值:</p><figure class="mb mc md me gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nr"><img src="../Images/3f816bbe623400e58df710a3f54fe23d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*50j6R0xuABCzbGZ-XEy5GA.png"/></div></div></figure><p id="8539" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将firebaseConfig变量复制粘贴到<strong class="ka jc"> firebase/firebase.js </strong>中:</p><pre class="mb mc md me gt mu mv mw mx aw my bi"><span id="0aeb" class="mz kx jb mv b gy na nb l nc nd"><strong class="mv jc">const</strong> firebaseConfig = { Your config values }</span></pre><p id="f772" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">添加以下导入内容:</p><pre class="mb mc md me gt mu mv mw mx aw my bi"><span id="e778" class="mz kx jb mv b gy na nb l nc nd"><strong class="mv jc">import</strong> firebase <strong class="mv jc">from</strong> "firebase/app";<br/><strong class="mv jc">import</strong> "firebase/auth";<br/><strong class="mv jc">import</strong> "firebase/firestore";</span></pre><p id="2a35" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，让我们初始化应用程序和数据库，并导出它们以在我们的操作文件中使用:</p><pre class="mb mc md me gt mu mv mw mx aw my bi"><span id="26a5" class="mz kx jb mv b gy na nb l nc nd"><strong class="mv jc">export</strong> <strong class="mv jc">const</strong> myFirebase = firebase.initializeApp(firebaseConfig);<br/><strong class="mv jc">const</strong> baseDb = myFirebase.firestore();<br/><strong class="mv jc">export</strong> <strong class="mv jc">const</strong> db = baseDb;</span></pre><p id="4b4a" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">以下是<strong class="ka jc"> firebase/firebase.js </strong>的完整文件代码:</p><figure class="mb mc md me gt is"><div class="bz fp l di"><div class="ns nt l"/></div></figure><h2 id="22dc" class="mz kx jb bd ky ne nf dn lc ng nh dp lg kj ni nj lk kn nk nl lo kr nm nn ls no bi translated">创造我们的行动。</h2><p id="bead" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">打开<strong class="ka jc"> actions/auth.js </strong>并添加以下导入以获得我们的firebase实例:</p><pre class="mb mc md me gt mu mv mw mx aw my bi"><span id="04b6" class="mz kx jb mv b gy na nb l nc nd"><strong class="mv jc">import</strong> { myFirebase } <strong class="mv jc">from</strong> "../firebase/firebase";</span></pre><p id="69aa" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们需要创建操作来完成以下任务:登录、注销和在页面刷新时重新建立会话。为此，我们应该创建以下动作类型<em class="mf">(随意调整命名)</em>:</p><pre class="mb mc md me gt mu mv mw mx aw my bi"><span id="1131" class="mz kx jb mv b gy na nb l nc nd"><strong class="mv jc">export</strong> <strong class="mv jc">const</strong> LOGIN_REQUEST = "LOGIN_REQUEST";<br/><strong class="mv jc">export</strong> <strong class="mv jc">const</strong> LOGIN_SUCCESS = "LOGIN_SUCCESS";<br/><strong class="mv jc">export</strong> <strong class="mv jc">const</strong> LOGIN_FAILURE = "LOGIN_FAILURE";</span><span id="964e" class="mz kx jb mv b gy nu nb l nc nd"><strong class="mv jc">export</strong> <strong class="mv jc">const</strong> LOGOUT_REQUEST = "LOGOUT_REQUEST";<br/><strong class="mv jc">export</strong> <strong class="mv jc">const</strong> LOGOUT_SUCCESS = "LOGOUT_SUCCESS";<br/><strong class="mv jc">export</strong> <strong class="mv jc">const</strong> LOGOUT_FAILURE = "LOGOUT_FAILURE";</span><span id="b983" class="mz kx jb mv b gy nu nb l nc nd"><strong class="mv jc">export</strong> <strong class="mv jc">const</strong> VERIFY_REQUEST = "VERIFY_REQUEST";<br/><strong class="mv jc">export</strong> <strong class="mv jc">const</strong> VERIFY_SUCCESS = "VERIFY_SUCCESS";</span></pre><p id="61d2" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如您所见，我们已经将每个动作分成三个部分，以跟踪应用程序中的异步状态。我们想知道什么时候发出请求，什么时候请求成功，什么时候请求失败。唯一的例外是验证，因为这不需要失败状态。</p><p id="8094" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我们需要创建返回我们的动作类型和必要参数的函数，我们的reducer将读取这些参数。让我们从登录操作开始。</p><p id="3569" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于请求登录的用户:</p><pre class="mb mc md me gt mu mv mw mx aw my bi"><span id="5ae3" class="mz kx jb mv b gy na nb l nc nd"><strong class="mv jc">const</strong> requestLogin = () =&gt; {<br/>  <strong class="mv jc">return</strong> {<br/>    type: LOGIN_REQUEST<br/>  };<br/>};</span></pre><p id="9348" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于接受firebase用户对象的成功登录:</p><pre class="mb mc md me gt mu mv mw mx aw my bi"><span id="ec7e" class="mz kx jb mv b gy na nb l nc nd"><strong class="mv jc">const</strong> receiveLogin = user =&gt; {<br/>  <strong class="mv jc">return</strong> {<br/>    type: LOGIN_SUCCESS,<br/>    user<br/>  };<br/>};</span></pre><p id="f5d1" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，一个失败的例子:</p><pre class="mb mc md me gt mu mv mw mx aw my bi"><span id="3a47" class="mz kx jb mv b gy na nb l nc nd"><strong class="mv jc">const</strong> loginError = () =&gt; {<br/>  <strong class="mv jc">return</strong> {<br/>    type: LOGIN_FAILURE<br/>  };<br/>};</span></pre><p id="3ea9" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用前面的函数作为模板，为剩下的五个动作类型创建动作函数。所有五个都不接受任何参数。如果你想花额外的时间，一个健壮的应用程序应该在我们的reducer中存储失败消息，这样我们就可以向用户指出发生了什么类型的错误，但是为了使本教程简单，我们将简单地使用一个发生错误时设置的布尔值。</p><p id="0f58" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们可以创建我们的<a class="ae lz" href="https://daveceddia.com/what-is-a-thunk/" rel="noopener ugc nofollow" target="_blank"><strong class="ka jc"><em class="mf">thunks</em></strong></a><strong class="ka jc"><em class="mf"/></strong>，它将与firebase交互来执行我们需要的所有操作。</p><blockquote class="nv"><p id="6fa1" class="nw nx jb bd ny nz oa ob oc od oe kv dk translated">thunk是<em class="of">函数</em>的另一种说法。但它不仅仅是一个旧功能。这是由另一个函数返回的函数的特殊(不常见)名称。</p></blockquote><p id="3eee" class="pw-post-body-paragraph jy jz jb ka b kb og kd ke kf oh kh ki kj oi kl km kn oj kp kq kr ok kt ku kv ij bi translated">我们可以从让用户登录firebase开始。我们将使用firebase<a class="ae lz" href="https://firebase.google.com/docs/reference/js/firebase.auth.Auth.html#signinwithemailandpassword" rel="noopener ugc nofollow" target="_blank"><strong class="ka jc"><em class="mf">signingwithemailandpassword</em></strong></a><strong class="ka jc"><em class="mf"/></strong>功能。我们希望我们的thunk从我们未来的<em class="mf">登录</em>组件接收凭证，并且还接收<em class="mf">分派</em>函数，该函数被传递给我们从组件发起的所有操作:</p><pre class="mb mc md me gt mu mv mw mx aw my bi"><span id="607c" class="mz kx jb mv b gy na nb l nc nd"><strong class="mv jc">export</strong> <strong class="mv jc">const</strong> loginUser = (email, password) =&gt; dispatch =&gt; {}</span></pre><p id="c689" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如你所见，第一个函数将接收我们的用户名和密码，这是我们在创建<em class="mf">登录</em>组件时提供的，并返回一个接收调度函数的函数，当我们在组件中调用该函数时，调度函数会隐式传递该函数。</p><p id="02ff" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们想这样构造我们的<strong class="ka jc"><em class="mf">loginUser()</em></strong>thunk:</p><figure class="mb mc md me gt is"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="e201" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们将代码分解成每一步。首先，我们调度<strong class="ka jc"><em class="mf">request log in()</em></strong>，这将告诉我们的应用程序用户正在登录。然后，我们通过调用<strong class="ka jc"><em class="mf">my firebase . auth()</em></strong>得到我们的firebase auth实例。</p><p id="c6d3" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后我们调用我们想要使用的身份验证方法，在本例中是<strong class="ka jc"><em class="mf">signInWithEmailAndPassword()</em></strong><em class="mf"/>，并传递我们的用户凭证。之后，我们使用一个<strong class="ka jc"> then() </strong>来调度<strong class="ka jc"> <em class="mf"> receiveLogin(user)，当登录成功时，它将被传递给firebase用户对象。</em> </strong>我们传递用户是因为想在redux中存储firebase用户对象，这样我们以后就可以在我们的应用程序中使用它。我们不会在本教程中使用它，但当你在将来要写的动作中开始尝试与Firestore数据库交互时，你会感谢我的！</p><p id="4242" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，我们捕捉发生的任何错误并分派<strong class="ka jc"><em class="mf">loginError()</em></strong><em class="mf"/>，这样我们就可以让我们的用户知道出错了。</p><p id="36b3" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们剩下的两个thunks的构造几乎完全一样，<strong class="ka jc"> <em class="mf"> logoutUser() </em> </strong>调用firebase<a class="ae lz" href="https://firebase.google.com/docs/reference/js/firebase.auth.Auth.html#signout" rel="noopener ugc nofollow" target="_blank"><strong class="ka jc"><em class="mf">sign out()</em></strong></a><strong class="ka jc"><em class="mf"/></strong>方法:</p><figure class="mb mc md me gt is"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="454c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">并且<strong class="ka jc"> <em class="mf"> verifyAuth() </em> </strong>调用firebase<a class="ae lz" href="https://firebase.google.com/docs/reference/js/firebase.auth.Auth.html#onauthstatechanged" rel="noopener ugc nofollow" target="_blank"><strong class="ka jc"><em class="mf">onAuthStateChanged()</em></strong></a><strong class="ka jc"><em class="mf"/></strong>方法，该方法寻找预先存在的用户会话并重新建立它。在我们的例子中，这将在刷新时发生。该方法还会在应用程序运行时设置一个侦听器，以便在用户会话令牌过期时对其进行更改。</p><figure class="mb mc md me gt is"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="310e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以看到，我们还调度了<strong class="ka jc"><em class="mf">receive log in()</em></strong>，这样，如果用户使用预先存在的会话“登录”,我们就可以在reducer中重新填充用户对象。我们检查用户是否为空，因为我们只希望在firebase找到用户会话时让某人登录。</p><p id="f654" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc"> actions/auth.js </strong>到此为止！以下是完整的文件:</p><figure class="mb mc md me gt is"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="7bf4" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们可以设置我们的<strong class="ka jc"> actions/index.js </strong>文件来导出我们刚刚做的一切，以便于导入。</p><p id="4792" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们只需要一句话:</p><pre class="mb mc md me gt mu mv mw mx aw my bi"><span id="6b49" class="mz kx jb mv b gy na nb l nc nd"><strong class="mv jc">export</strong> * <strong class="mv jc">from</strong> "./auth";</span></pre></div><div class="ab cl mi mj hu mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ij ik il im in"><h1 id="ac47" class="kw kx jb bd ky kz mp lb lc ld mq lf lg lh mr lj lk ll ms ln lo lp mt lr ls lt bi translated">安装我们的减速器。</h1><p id="ada0" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">打开<strong class="ka jc"> reducers/auth.js </strong>，从actions导入我们刚刚创建的所有动作类型。reducer接收这些数据，并将其传递给switch语句。</p><pre class="mb mc md me gt mu mv mw mx aw my bi"><span id="f495" class="mz kx jb mv b gy na nb l nc nd"><strong class="mv jc">import</strong> {<br/>  LOGIN_REQUEST,<br/>  LOGIN_SUCCESS,<br/>  LOGIN_FAILURE,<br/>  LOGOUT_REQUEST,<br/>  LOGOUT_SUCCESS,<br/>  LOGOUT_FAILURE,<br/>  VERIFY_REQUEST,<br/>  VERIFY_SUCCESS<br/>} <strong class="mv jc">from</strong> "../actions/";</span></pre><p id="f436" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，我们可以创建我们的reducer函数。我们可以将其构建如下:</p><pre class="mb mc md me gt mu mv mw mx aw my bi"><span id="2ce2" class="mz kx jb mv b gy na nb l nc nd"><strong class="mv jc">export</strong> <strong class="mv jc">default</strong> (state = {}, action) =&gt; {<br/>  <strong class="mv jc">switch</strong> (action.type) {<br/>    <strong class="mv jc">default</strong>:<br/>      return state;<br/>  }<br/>};</span></pre><p id="bbba" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，我们可以为我们需要的所有标志和对象创建一些默认状态:</p><pre class="mb mc md me gt mu mv mw mx aw my bi"><span id="a001" class="mz kx jb mv b gy na nb l nc nd"><strong class="mv jc">export</strong> <strong class="mv jc">default</strong> (<br/>  state = {<br/>    isLoggingIn: <strong class="mv jc">false</strong>,<br/>    isLoggingOut: <strong class="mv jc">false</strong>,<br/>    isVerifying: <strong class="mv jc">false</strong>,<br/>    loginError: <strong class="mv jc">false</strong>,<br/>    logoutError: <strong class="mv jc">false</strong>,<br/>    isAuthenticated: <strong class="mv jc">false</strong>,<br/>    user: {}<br/>  },<br/>  action<br/>) =&gt; {<br/>  <strong class="mv jc">switch</strong> (action.type) {</span></pre><p id="3071" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好了，我们现在可以研究我们的开关盒了。当用户试图登录时，我们希望让我们的应用程序知道，是的，他们正在登录，我们还希望清除之前可能发生的任何错误:</p><pre class="mb mc md me gt mu mv mw mx aw my bi"><span id="6304" class="mz kx jb mv b gy na nb l nc nd"><strong class="mv jc">case</strong> LOGIN_REQUEST:<br/>      <strong class="mv jc">return</strong> {<br/>        ...state,<br/>        isLoggingIn: <strong class="mv jc">true</strong>,<br/>        loginError: <strong class="mv jc">false</strong><br/>      };</span></pre><p id="2d9d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当成功登录时，我们希望告诉我们的应用程序，它不再尝试让用户登录，用户现在已通过身份验证，我们希望存储我们的操作通过的用户:</p><pre class="mb mc md me gt mu mv mw mx aw my bi"><span id="a359" class="mz kx jb mv b gy na nb l nc nd"><strong class="mv jc">case</strong> LOGIN_SUCCESS:<br/>      <strong class="mv jc">return</strong> {<br/>        ...state,<br/>        isLoggingIn: <strong class="mv jc">false</strong>,<br/>        isAuthenticated: <strong class="mv jc">true</strong>,<br/>        user: action.user<br/>      };</span></pre><p id="31c2" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，当登录失败时，我们希望告诉我们的应用程序，它也不再尝试让用户登录，没有用户通过身份验证，并且失败已经发生:</p><pre class="mb mc md me gt mu mv mw mx aw my bi"><span id="3575" class="mz kx jb mv b gy na nb l nc nd"><strong class="mv jc">case</strong> LOGIN_FAILURE:<br/>      <strong class="mv jc">return</strong> {<br/>        ...state,<br/>        isLoggingIn: <strong class="mv jc">false</strong>,<br/>        isAuthenticated: <strong class="mv jc">false</strong>,<br/>        loginError: <strong class="mv jc">true</strong><br/>      };</span></pre><p id="9a14" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">其余五个案例的结构相似。在用下面的代码检查您的工作之前，尝试自己做这些。</p><p id="73be" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">以下是完整的文件:</p><figure class="mb mc md me gt is"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="90ea" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们可以使用redux库中的<strong class="ka jc"><em class="mf">combine reducers()</em></strong>函数创建默认的缩减器。打开<strong class="ka jc"> reducers/index.js </strong>并添加以下导入:</p><pre class="mb mc md me gt mu mv mw mx aw my bi"><span id="682d" class="mz kx jb mv b gy na nb l nc nd"><strong class="mv jc">import</strong> { combineReducers } <strong class="mv jc">from</strong> "redux";</span><span id="4f73" class="mz kx jb mv b gy nu nb l nc nd"><strong class="mv jc">import</strong> auth <strong class="mv jc">from</strong> "./auth";</span></pre><p id="0645" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，调用合并函数。您将在这里添加其他减速器，同时扩展您的应用程序。</p><pre class="mb mc md me gt mu mv mw mx aw my bi"><span id="352e" class="mz kx jb mv b gy na nb l nc nd"><strong class="mv jc">export</strong> <strong class="mv jc">default</strong> combineReducers({ auth });</span></pre><p id="7b1a" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们已经拥有了减速器所需的一切！</p></div><div class="ab cl mi mj hu mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ij ik il im in"><h1 id="5b0d" class="kw kx jb bd ky kz mp lb lc ld mq lf lg lh mr lj lk ll ms ln lo lp mt lr ls lt bi translated">安装我们的Redux管道。</h1><p id="8354" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">所以我们已经创建了我们需要的动作和reducer，现在我们必须向应用程序提供我们的Redux状态。</p><p id="be55" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<strong class="ka jc"> src </strong>文件夹中创建一个名为<strong class="ka jc"> configureStore.js </strong>的新文件</p><p id="2a4f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个文件将初始化我们的商店，设置我们的thunk中间件，调用我们的<strong class="ka jc"> verifyAuth() </strong>动作，并导出我们的函数，以便我们可以将它提供给我们的应用程序的根目录。我们可以从进口开始:</p><pre class="mb mc md me gt mu mv mw mx aw my bi"><span id="7f73" class="mz kx jb mv b gy na nb l nc nd"><strong class="mv jc">import</strong> { applyMiddleware, createStore } <strong class="mv jc">from</strong> "redux";<br/><strong class="mv jc">import</strong> thunkMiddleware <strong class="mv jc">from</strong> "redux-thunk";</span><span id="5758" class="mz kx jb mv b gy nu nb l nc nd"><strong class="mv jc">import</strong> { verifyAuth } <strong class="mv jc">from</strong> "./actions/";<br/><strong class="mv jc">import</strong> rootReducer <strong class="mv jc">from</strong> "./reducers";</span></pre><p id="5f23" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们正在导入我们的<strong class="ka jc"> <em class="mf"> verifyAuth() </em> </strong>动作，以及<strong class="ka jc"><em class="mf">combine reducerss()</em></strong>的输出，它实际上只是一个由我们的reducer的所有状态组成的大对象，但目前我们只有一个。</p><p id="6816" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，我们可以创建并导出将返回已配置存储的函数。</p><pre class="mb mc md me gt mu mv mw mx aw my bi"><span id="0b24" class="mz kx jb mv b gy na nb l nc nd"><strong class="mv jc">export</strong> <strong class="mv jc">default</strong> <strong class="mv jc">function</strong> configureStore(persistedState) {<br/>  <strong class="mv jc">const</strong> store = createStore(<br/>    rootReducer,<br/>    persistedState,<br/>    applyMiddleware(thunkMiddleware)<br/>  );<br/>  store.dispatch(verifyAuth());<br/>  <strong class="mv jc">return</strong> store;<br/>}</span></pre><p id="0d83" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">每次我们的应用程序启动时都会调用该函数，这也发生在用户刷新页面时。我喜欢在这里分派<strong class="ka jc"> <em class="mf"> verifyAuth() </em> </strong>，因为它确保这将是我们的redux store发生的第一件事，如果用户会话存在，它将在应用程序的其余部分加载之前验证我们的用户，这将让我们路由到我们的安全路由，而不会显示我们的登录页面。</p><p id="4664" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<strong class="ka jc"> src </strong>文件夹中创建另一个名为<strong class="ka jc"> Root.js </strong>的文件</p><p id="a3f8" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该组件将为<em class="mf">应用</em>提供我们的商店。我们还将在这里初始化react-router。我们将把实际路线添加到<em class="mf">应用程序中。这些是我们需要的进口商品:</em></p><pre class="mb mc md me gt mu mv mw mx aw my bi"><span id="1e93" class="mz kx jb mv b gy na nb l nc nd"><strong class="mv jc">import</strong> React <strong class="mv jc">from</strong> "react";</span><span id="7c0e" class="mz kx jb mv b gy nu nb l nc nd"><strong class="mv jc">import</strong> { Provider } <strong class="mv jc">from</strong> "react-redux";<br/><strong class="mv jc">import</strong> { BrowserRouter <strong class="mv jc">as</strong> Router } <strong class="mv jc">from</strong> "react-router-dom";</span><span id="2bd1" class="mz kx jb mv b gy nu nb l nc nd"><strong class="mv jc">import</strong> App <strong class="mv jc">from</strong> "./App";<br/><strong class="mv jc">import</strong> configureStore <strong class="mv jc">from</strong> "./configureStore";</span></pre><p id="38a9" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我们需要初始化我们配置的存储。</p><pre class="mb mc md me gt mu mv mw mx aw my bi"><span id="6cdb" class="mz kx jb mv b gy na nb l nc nd"><strong class="mv jc">const</strong> store = configureStore();</span></pre><p id="d455" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，我们需要将该存储提供给应用程序的其余部分，并初始化路由器。</p><pre class="mb mc md me gt mu mv mw mx aw my bi"><span id="aeb5" class="mz kx jb mv b gy na nb l nc nd"><strong class="mv jc">function</strong> Root() {<br/>  <strong class="mv jc">return</strong> (<br/>    &lt;Provider store={store}&gt;<br/>      &lt;Router&gt;<br/>        &lt;App /&gt;<br/>      &lt;/Router&gt;<br/>    &lt;/Provider&gt;<br/>  );<br/>}</span><span id="0fee" class="mz kx jb mv b gy nu nb l nc nd"><strong class="mv jc">export</strong> <strong class="mv jc">default</strong> Root;</span></pre><p id="3dba" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">以下是完整的文件:</p><figure class="mb mc md me gt is"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="b3a0" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">顾名思义，<em class="mf"> Root </em>将是我们app的根组件。现在，create-react-app已经将根组件定义为<em class="mf"> App </em>。要改变这一点，打开<strong class="ka jc"> src/index.js </strong>移除<em class="mf"> App </em>导入并用<em class="mf"> Root </em>替换。您完成的文件应该如下所示:</p><figure class="mb mc md me gt is"><div class="bz fp l di"><div class="ns nt l"/></div></figure></div><div class="ab cl mi mj hu mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ij ik il im in"><h1 id="e534" class="kw kx jb bd ky kz mp lb lc ld mq lf lg lh mr lj lk ll ms ln lo lp mt lr ls lt bi translated">设置我们的路线。</h1><p id="c7ba" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">我们已经在<em class="mf">根</em>中初始化了路由器，但是我们的应用程序仍然没有路由。我们现在可以创建正常的路由，但是我们需要能够创建受保护的路由，这些路由只能在用户登录后才能访问。如果他们没有登录，他们应该被重定向到登录页面。</p><p id="31aa" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<strong class="ka jc"> src </strong>中新建一个名为<strong class="ka jc"> components </strong>的文件夹，并添加三个名为<strong class="ka jc"> ProtectedRoute.js、Home.js、</strong>和<strong class="ka jc"> Login.js </strong>的新文件</p><p id="61e9" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">打开<strong class="ka jc">components/protected route . js</strong>并添加以下导入:</p><pre class="mb mc md me gt mu mv mw mx aw my bi"><span id="bda2" class="mz kx jb mv b gy na nb l nc nd"><strong class="mv jc">import</strong> React <strong class="mv jc">from</strong> "react";<br/><strong class="mv jc">import</strong> { Route, Redirect } <strong class="mv jc">from</strong> "react-router-dom";</span></pre><p id="e563" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后让我们添加组件代码:</p><pre class="mb mc md me gt mu mv mw mx aw my bi"><span id="02cd" class="mz kx jb mv b gy na nb l nc nd"><strong class="mv jc">const</strong> ProtectedRoute = ({<br/>  component: Component,<br/>  isAuthenticated,<br/>  isVerifying,<br/>  ...rest<br/>}) =&gt; (<br/>  &lt;Route<br/>    {...rest}<br/>    render={props =&gt;<br/>      isVerifying ? (<br/>        &lt;div /&gt;<br/>      ) : isAuthenticated ? (<br/>        &lt;Component {...props} /&gt;<br/>      ) : (<br/>        &lt;Redirect<br/>          to={{<br/>            pathname: "/login",<br/>            state: { from: props.location }<br/>          }}<br/>        /&gt;<br/>      )<br/>    }<br/>  /&gt;<br/>);</span><span id="1300" class="mz kx jb mv b gy nu nb l nc nd"><strong class="mv jc">export</strong> <strong class="mv jc">default</strong> ProtectedRoute;</span></pre><p id="c046" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">理解这个组件超出了本教程的范围。泰勒·麦金尼斯在他的网站上创建了一个优秀的<a class="ae lz" href="https://tylermcginnis.com/react-router-protected-routes-authentication/" rel="noopener ugc nofollow" target="_blank">教程，如果你想知道这是如何运作的！</a></p><p id="fe1f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们可以创建我们所有的路线。打开<strong class="ka jc"> App.js </strong>，去掉create-react-app给我们的所有模板代码。我们可以添加以下导入:</p><pre class="mb mc md me gt mu mv mw mx aw my bi"><span id="ec56" class="mz kx jb mv b gy na nb l nc nd"><strong class="mv jc">import</strong> React <strong class="mv jc">from</strong> "react";</span><span id="6fce" class="mz kx jb mv b gy nu nb l nc nd"><strong class="mv jc">import</strong> { Route, Switch } <strong class="mv jc">from</strong> "react-router-dom";<br/><strong class="mv jc">import</strong> { connect } <strong class="mv jc">from</strong> "react-redux";</span><span id="e009" class="mz kx jb mv b gy nu nb l nc nd"><strong class="mv jc">import</strong> ProtectedRoute <strong class="mv jc">from</strong> "./components/ProtectedRoute";<br/><strong class="mv jc">import</strong> Home <strong class="mv jc">from</strong> "./components/Home";<br/><strong class="mv jc">import</strong> Login <strong class="mv jc">from</strong> "./components/Login";</span></pre><p id="b6b3" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如您所看到的，我们已经从react-redux 导入了<a class="ae lz" href="https://react-redux.js.org/api/connect" rel="noopener ugc nofollow" target="_blank"> <strong class="ka jc"> <em class="mf"> connect() </em> </strong>，这让我们可以将组件链接到redux存储，以提取我们需要的数据。为此，我们希望在组件底部定义一个<strong class="ka jc"><em class="mf">mapStateToProps()</em></strong>函数，并将其传递给<strong class="ka jc"> <em class="mf"> connect()。</em>T19】</strong></a></p><p id="2c61" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们这样做:</p><pre class="mb mc md me gt mu mv mw mx aw my bi"><span id="0007" class="mz kx jb mv b gy na nb l nc nd"><strong class="mv jc">function</strong> mapStateToProps(state) {<br/>  <strong class="mv jc">return</strong> {<br/>    isAuthenticated: state.auth.isAuthenticated,<br/>    isVerifying: state.auth.isVerifying<br/>  };<br/>}</span><span id="86e7" class="mz kx jb mv b gy nu nb l nc nd"><strong class="mv jc">export</strong> <strong class="mv jc">default</strong> connect(mapStateToProps)(App);</span></pre><p id="4a73" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们从auth reducer中取出这个组件所需的状态片段，并返回一个映射到组件props的对象。</p><p id="232f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们可以在定义路由的地方添加组件代码，并使用我们的<em class="mf"> ProtectedRoute </em>组件来保护根路由。</p><pre class="mb mc md me gt mu mv mw mx aw my bi"><span id="b369" class="mz kx jb mv b gy na nb l nc nd"><strong class="mv jc">function</strong> App(props) {<br/>  <strong class="mv jc">const</strong> { isAuthenticated, isVerifying } = props;<br/>  <strong class="mv jc">return</strong> (<br/>    &lt;Switch&gt;<br/>      &lt;ProtectedRoute<br/>        exact<br/>        path="/"<br/>        component={Home}<br/>        isAuthenticated={isAuthenticated}<br/>        isVerifying={isVerifying}<br/>      /&gt;<br/>      &lt;Route path="/login" component={Login} /&gt;<br/>    &lt;/Switch&gt;<br/>  );<br/>}</span></pre><p id="9e96" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="mf">开关</em>将只选择这些路线中的一条，我们在技术上不需要它，因为我们没有冲突的路线，但这是一个好的做法，它也将防止您在这里添加可能绕过我们的<em class="mf">保护路线的额外路线。</em>你放在我们的<em class="mf">保护路由</em>下的任何路由，比如说在home组件中，也将自动受到保护，而无需你使用该组件，因为它们是子路由。</p><p id="15ca" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">以下是<strong class="ka jc"> App.js </strong>的完整代码:</p><figure class="mb mc md me gt is"><div class="bz fp l di"><div class="ns nt l"/></div></figure></div><div class="ab cl mi mj hu mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ij ik il im in"><h1 id="a837" class="kw kx jb bd ky kz mp lb lc ld mq lf lg lh mr lj lk ll ms ln lo lp mt lr ls lt bi translated">现在我们可以制作登录页面了。</h1><p id="5443" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">打开<strong class="ka jc"> components/Login.js </strong>，我们就可以开始添加我们的代码了。我将在Material Ui中包含我的代码，但是您可以随意创建这个页面。我们需要它有以下内容:电子邮件和密码的输入，提交按钮，一些redux状态，以及一个用用户名和密码调度我们的<strong class="ka jc"> <em class="mf"> loginUser() </em> </strong>动作的函数。</p><p id="a890" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">无论您选择如何做，这些导入都是必需的:</p><pre class="mb mc md me gt mu mv mw mx aw my bi"><span id="4052" class="mz kx jb mv b gy na nb l nc nd"><strong class="mv jc">import</strong> React, { Component } <strong class="mv jc">from</strong> "react";<br/><strong class="mv jc">import</strong> { connect } <strong class="mv jc">from</strong> "react-redux";<br/><strong class="mv jc">import</strong> { Redirect } <strong class="mv jc">from</strong> "react-router-dom";<br/><strong class="mv jc">import</strong> { loginUser } <strong class="mv jc">from</strong> "../actions";</span></pre><p id="08a7" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后让我们从Redux中获取我们需要的状态:</p><pre class="mb mc md me gt mu mv mw mx aw my bi"><span id="3849" class="mz kx jb mv b gy na nb l nc nd"><strong class="mv jc">function</strong> mapStateToProps(state) {<br/>  <strong class="mv jc">return</strong> {<br/>    isLoggingIn: state.auth.isLoggingIn,<br/>    loginError: state.auth.loginError,<br/>    isAuthenticated: state.auth.isAuthenticated<br/>  };<br/>}<br/><strong class="mv jc">export</strong> <strong class="mv jc">default</strong> connect(mapStateToProps)(Login);</span></pre><p id="b765" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们希望设置一个仅在用户通过身份验证时才呈现的重定向:</p><pre class="mb mc md me gt mu mv mw mx aw my bi"><span id="fdec" class="mz kx jb mv b gy na nb l nc nd"><strong class="mv jc">const</strong> { classes, loginError, isAuthenticated } = this.props;<br/><strong class="mv jc">if</strong> (isAuthenticated) {<br/>   <strong class="mv jc">return</strong> &lt;Redirect to="/" /&gt;;<br/>} <strong class="mv jc">else</strong> {<br/>   <strong class="mv jc">return</strong> ( //Your Login component JSX</span></pre><p id="b911" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，我们希望有一个提交函数来调用我们的redux<strong class="ka jc"><em class="mf">loginUser()</em></strong>动作。</p><pre class="mb mc md me gt mu mv mw mx aw my bi"><span id="29b8" class="mz kx jb mv b gy na nb l nc nd">handleSubmit = () =&gt; {<br/>    <strong class="mv jc">const</strong> { dispatch } = this.props;<br/>    <strong class="mv jc">const</strong> { email, password } = this.state;<br/>    dispatch(loginUser(email, password));<br/>};</span></pre><p id="cdac" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面是我使用Material Ui的<em class="mf">登录</em>组件:</p><figure class="mb mc md me gt is"><div class="bz fp l di"><div class="ns nt l"/></div></figure></div><div class="ab cl mi mj hu mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ij ik il im in"><h1 id="034b" class="kw kx jb bd ky kz mp lb lc ld mq lf lg lh mr lj lk ll ms ln lo lp mt lr ls lt bi translated">最终作品。</h1><p id="cdfa" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">打开<strong class="ka jc"> component/Home.js </strong>，在你的保护区内创建你想要的！我已经创建了一些基本代码，您可以在下面使用它们来测试功能。</p><pre class="mb mc md me gt mu mv mw mx aw my bi"><span id="513b" class="mz kx jb mv b gy na nb l nc nd"><strong class="mv jc">import</strong> React, { Component } <strong class="mv jc">from</strong> "react";<br/><strong class="mv jc">import</strong> { connect } <strong class="mv jc">from</strong> "react-redux";<br/><strong class="mv jc">import</strong> { logoutUser } <strong class="mv jc">from</strong> "../actions";</span><span id="30f9" class="mz kx jb mv b gy nu nb l nc nd"><strong class="mv jc">class</strong> Home <strong class="mv jc">extends</strong> Component {<br/>  handleLogout = () =&gt; {<br/>    <strong class="mv jc">const</strong> { dispatch } = this.props;<br/>    dispatch(logoutUser());<br/>  };<br/>  render() {<br/>    <strong class="mv jc">const</strong> { isLoggingOut, logoutError } = this.props;</span><span id="d459" class="mz kx jb mv b gy nu nb l nc nd">    <strong class="mv jc">return</strong> (<br/>      &lt;div&gt;<br/>        &lt;h1&gt;This is your app's protected area.&lt;/h1&gt;<br/>        &lt;p&gt;Any routes here will also be protected&lt;/p&gt;<br/>        &lt;button onClick={this.handleLogout}&gt;Logout&lt;/button&gt;<br/>        {isLoggingOut <strong class="mv jc">&amp;&amp;</strong> &lt;p&gt;Logging Out....&lt;/p&gt;}<br/>        {logoutError <strong class="mv jc">&amp;&amp;</strong> &lt;p&gt;Error logging out&lt;/p&gt;}<br/>      &lt;/div&gt;<br/>    );<br/>  }<br/>}</span><span id="cb96" class="mz kx jb mv b gy nu nb l nc nd"><strong class="mv jc">function</strong> mapStateToProps(state) {<br/>  <strong class="mv jc">return</strong> {<br/>    isLoggingOut: state.auth.isLoggingOut,<br/>    logoutError: state.auth.logoutError<br/>  };<br/>}</span><span id="95c5" class="mz kx jb mv b gy nu nb l nc nd"><strong class="mv jc">export</strong> <strong class="mv jc">default</strong> connect(mapStateToProps)(Home);</span></pre><p id="d5ce" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">终于到时间了！启动应用程序！</p><pre class="mb mc md me gt mu mv mw mx aw my bi"><span id="caa3" class="mz kx jb mv b gy na nb l nc nd">npm run start</span></pre><p id="7d9a" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为我们使用的是firebase包，firebase将在webpack的开发服务器环境中完美地工作。当应用程序启动时，您应该立即被重定向到/login，并看到您创建的表单。</p><figure class="mb mc md me gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi on"><img src="../Images/d410e40006a6f2ee4aaf679e82aa15c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z1wuwQscAkzg3PkU7FbiJQ.png"/></div></div></figure><p id="3b5d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">尝试登录应该会给你一个错误，因为我们没有在Firebase中添加任何用户。</p><figure class="mb mc md me gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi on"><img src="../Images/d532727a57f5395b216226a489f20b1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iMfa1vN3Ot0TDmAUBs4EmA.png"/></div></div></figure><p id="f27b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">打开<a class="ae lz" href="https://console.firebase.google.com" rel="noopener ugc nofollow" target="_blank"> Firebase控制台</a>，点击菜单中的认证链接。我们想添加一个用户:</p><figure class="mb mc md me gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oo"><img src="../Images/6bf3936aa070b276801db23d8e59673b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W2tBy8o5R4GkFu0UMfElVw.png"/></div></div></figure><p id="13b6" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">添加要测试的用户:</p><figure class="mb mc md me gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oo"><img src="../Images/d4bdd96dbef5d704d338674cc1b25d98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lQ5H6JHgNg9UUfcUwnMtBw.png"/></div></div></figure><p id="1862" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，您可以返回到您的应用程序，并尝试使用您刚刚创建的用户登录！您应该被重定向到应用程序根URL上的我们的<em class="mf">主页</em>组件。</p><figure class="mb mc md me gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi op"><img src="../Images/a383d9413bdfcbfd14e22590d3a87c98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-27jQx8Rg3LRBcobmzpfXw.png"/></div></div></figure><p id="63b2" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">刷新页面也将使您保持登录状态。如果您想知道我们为什么需要verify auth，您可以从<strong class="ka jc"> configureStore.js </strong>中删除<strong class="ka jc"><em class="mf">verify auth()</em></strong>dispatch并尝试刷新页面。您应该被重定向回<em class="mf">登录</em>组件。最后，您可以测试logout按钮，看看我们的<strong class="ka jc"> <em class="mf"> logoutUser() </em> </strong>动作是否工作。您应该被重定向回登录页面。</p><p id="893c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要将您的应用发布到firebase，请确保您的Firestore数据库退出测试模式，方法是编辑您的<strong class="ka jc"> src </strong>目录中<strong class="ka jc"> firestore.rules </strong>中的<strong class="ka jc"> allow </strong>行，如下所示:</p><pre class="mb mc md me gt mu mv mw mx aw my bi"><span id="c444" class="mz kx jb mv b gy na nb l nc nd">allow read, write: if false;</span></pre><p id="0c03" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，要将您的应用发布到firebase，请使用<em class="mf"> npm构建您的应用，运行build </em>并运行以下命令:</p><pre class="mb mc md me gt mu mv mw mx aw my bi"><span id="1241" class="mz kx jb mv b gy na nb l nc nd">firebase deploy</span></pre><p id="056d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您的应用程序现已上线。</p></div><div class="ab cl mi mj hu mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ij ik il im in"><p id="05a4" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">感谢您的关注！在未来的教程中，我计划扩展功能，直到我们最终拥有一个成熟的firebase web应用程序。我希望这能对你有所帮助。这段代码将是任何firebase web应用程序的良好开端。如果您正在分叉，请确保执行本文中的firebase初始化步骤，并在<strong class="ka jc"> firebase/firebase.js </strong>设置您的web应用程序API密钥</p><div class="ip iq gp gr ir oq"><a href="https://github.com/chaseoc/firebase-login-page" rel="noopener  ugc nofollow" target="_blank"><div class="or ab fo"><div class="os ab ot cl cj ou"><h2 class="bd jc gy z fp ov fr fs ow fu fw ja bi translated">chase oc/fire base-登录-页面</h2><div class="ox l"><h3 class="bd b gy z fp ov fr fs ow fu fw dk translated">这个项目是用Create React App引导的。在项目目录中，您可以运行:在…中运行应用程序</h3></div><div class="oy l"><p class="bd b dl z fp ov fr fs ow fu fw dk translated">github.com</p></div></div><div class="oz l"><div class="pa l pb pc pd oz pe ix oq"/></div></div></a></div></div></div>    
</body>
</html>