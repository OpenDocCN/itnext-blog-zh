<html>
<head>
<title>Building a Puzzle Game in Flutter</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Flutter中构建一个益智游戏</h1>
<blockquote>原文：<a href="https://itnext.io/building-a-puzzle-game-in-flutter-41c6c1eee65a?source=collection_archive---------0-----------------------#2020-05-18">https://itnext.io/building-a-puzzle-game-in-flutter-41c6c1eee65a?source=collection_archive---------0-----------------------#2020-05-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="59ce" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何建立一个飞镖和扑2D益智游戏</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7987c65661ef70918c4641a6c5a85561.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*CdOvKHC40DBv6YWM58edkw.gif"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">示例项目的屏幕记录</figcaption></figure><h2 id="0a63" class="ky kz it bd la lb lc dn ld le lf dp lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">介绍</h2><p id="4eb9" class="pw-post-body-paragraph lu lv it lw b lx ly ju lz ma mb jx mc lh md me mf ll mg mh mi lp mj mk ml mm im bi mn translated">lutter是构建跨平台应用的热门选择，它拥有简洁的用户界面、流畅的动画和闪电般的性能。在本文中，我们将回顾一个简单的2D益智游戏在Flutter中的设计和开发，利用几个概念和设计模式，这些概念和模式可以应用于任何需要复杂UI的应用程序。</p><p id="8e7c" class="pw-post-body-paragraph lu lv it lw b lx mw ju lz ma mx jx mc lh my me mf ll mz mh mi lp na mk ml mm im bi translated">为了构建和运行这个项目，需要一个颤振环境。有关安装Flutter的更多信息，请参见安装页面<a class="ae nb" href="https://flutter.dev/docs/get-started/install" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><p id="eb88" class="pw-post-body-paragraph lu lv it lw b lx mw ju lz ma mx jx mc lh my me mf ll mz mh mi lp na mk ml mm im bi translated">如需示例源代码的副本，请查看<a class="ae nb" href="https://github.com/kenreilly/flutter-puzzle-game-demo" rel="noopener ugc nofollow" target="_blank">这份报告</a>。</p></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h2 id="e21b" class="ky kz it bd la lb lc dn ld le lf dp lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">概念</h2><p id="4e21" class="pw-post-body-paragraph lu lv it lw b lx ly ju lz ma mb jx mc lh md me mf ll mg mh mi lp mj mk ml mm im bi translated">在这个简单游戏的设计中使用了几个Flutter UI开发概念，每个概念在游戏状态和图形渲染的整体管理中都扮演着重要的角色。其中包括:</p><ul class=""><li id="5fd5" class="nj nk it lw b lx mw ma mx lh nl ll nm lp nn mm no np nq nr bi translated">基本的Flutter小部件如<a class="ae nb" href="https://api.flutter.dev/flutter/widgets/Container-class.html" rel="noopener ugc nofollow" target="_blank">容器</a>、<a class="ae nb" href="https://api.flutter.dev/flutter/widgets/SizedBox-class.html" rel="noopener ugc nofollow" target="_blank">大小框</a>、<a class="ae nb" href="https://api.flutter.dev/flutter/widgets/Column-class.html" rel="noopener ugc nofollow" target="_blank">列</a>等。</li><li id="cc55" class="nj nk it lw b lx ns ma nt lh nu ll nv lp nw mm no np nq nr bi translated">使用<a class="ae nb" href="https://api.flutter.dev/flutter/animation/AnimationController-class.html" rel="noopener ugc nofollow" target="_blank">动画控制器</a>、<a class="ae nb" href="https://api.flutter.dev/flutter/widgets/AnimatedWidget-class.html" rel="noopener ugc nofollow" target="_blank">动画宽度</a>和<a class="ae nb" href="https://api.flutter.dev/flutter/animation/Tween-class.html" rel="noopener ugc nofollow" target="_blank">补间</a></li><li id="2326" class="nj nk it lw b lx ns ma nt lh nu ll nv lp nw mm no np nq nr bi translated">用<a class="ae nb" href="https://api.flutter.dev/flutter/foundation/ChangeNotifier-class.html" rel="noopener ugc nofollow" target="_blank">change notifier</a>/<a class="ae nb" href="https://pub.dev/documentation/provider/latest/provider/ChangeNotifierProvider-class.html" rel="noopener ugc nofollow" target="_blank">change notifier provider</a>管理状态</li><li id="8949" class="nj nk it lw b lx ns ma nt lh nu ll nv lp nw mm no np nq nr bi translated">处理事件和利用<a class="ae nb" href="https://api.flutter.dev/flutter/dart-async/Stream-class.html" rel="noopener ugc nofollow" target="_blank">流</a> / <a class="ae nb" href="https://api.flutter.dev/flutter/dart-async/StreamController-class.html" rel="noopener ugc nofollow" target="_blank">流控制器</a></li><li id="992c" class="nj nk it lw b lx ns ma nt lh nu ll nv lp nw mm no np nq nr bi translated">使用<a class="ae nb" href="https://api.flutter.dev/flutter/widgets/GestureDetector-class.html" rel="noopener ugc nofollow" target="_blank">手势检测器</a>捕捉和消除手势反弹</li></ul><p id="8418" class="pw-post-body-paragraph lu lv it lw b lx mw ju lz ma mx jx mc lh my me mf ll mz mh mi lp na mk ml mm im bi translated">这个演示游戏结合了这些概念的实现来定义游戏逻辑、状态管理、交互、渲染和动画行为，以一种简单有效的方式，使用干净的设计和最少的源代码。</p></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h2 id="177c" class="ky kz it bd la lb lc dn ld le lf dp lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">概观</h2><p id="3995" class="pw-post-body-paragraph lu lv it lw b lx ly ju lz ma mb jx mc lh md me mf ll mg mh mi lp mj mk ml mm im bi translated">游戏的逻辑包含在五个源文件中，每个源文件都有处理各种任务的特定实现。这些是:</p><ul class=""><li id="fcde" class="nj nk it lw b lx mw ma mx lh nl ll nm lp nn mm no np nq nr bi translated"><strong class="lw iu"> main.dart </strong> : app初始化和顶层UI widget渲染</li><li id="998f" class="nj nk it lw b lx ns ma nt lh nu ll nv lp nw mm no np nq nr bi translated"><strong class="lw iu"> game-board.dart </strong>:手势检测和游戏板渲染</li><li id="969b" class="nj nk it lw b lx ns ma nt lh nu ll nv lp nw mm no np nq nr bi translated"><strong class="lw iu"> game-piece.dart </strong>:游戏棋子模型/渲染/动画</li><li id="c084" class="nj nk it lw b lx ns ma nt lh nu ll nv lp nw mm no np nq nr bi translated"><strong class="lw iu"> controller.dart </strong>:处理回合/更新棋盘/其他游戏逻辑</li><li id="127e" class="nj nk it lw b lx ns ma nt lh nu ll nv lp nw mm no np nq nr bi translated"><strong class="lw iu"> score.dart </strong>:跟踪比分，比分变化时刷新视图</li></ul><p id="9aa4" class="pw-post-body-paragraph lu lv it lw b lx mw ju lz ma mx jx mc lh my me mf ll mz mh mi lp na mk ml mm im bi translated">示例项目的设计很简单，利用前面提到的概念来完成大部分繁重的状态管理、动画和其他任务。游戏棋盘基于游戏棋子在棋盘上的当前x/y位置来呈现游戏棋子。当检测到滑动手势时，进行一次旋转，评估棋盘以确定将棋子移动到哪里以及何时将它们组合成具有更高值的棋子，类似于经典游戏2048。控制器处理棋盘计算，并在每回合刷新棋盘，根据需要更新分数。</p><p id="41d3" class="pw-post-body-paragraph lu lv it lw b lx mw ju lz ma mx jx mc lh my me mf ll mz mh mi lp na mk ml mm im bi translated">每个游戏棋子在棋盘上都有一个x/y位置，以及一个从0到6的值，对应于可见光谱中七种颜色中的每一种。当一个游戏棋子被移动时，它会自动移动到棋盘上的新位置。当一个棋子与一个相同的值发生冲突时，目标棋子被移除，然后移动的棋子被提升并移动到目标位置。</p></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h2 id="1451" class="ky kz it bd la lb lc dn ld le lf dp lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">应用入口点</h2><p id="a87a" class="pw-post-body-paragraph lu lv it lw b lx ly ju lz ma mb jx mc lh md me mf ll mg mh mi lp mj mk ml mm im bi translated">游戏初始化和UI搭建包含在main.dart中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="48b1" class="pw-post-body-paragraph lu lv it lw b lx mw ju lz ma mx jx mc lh my me mf ll mz mh mi lp na mk ml mm im bi translated">main函数首先确保在将方向锁定应用到纵向模式之前初始化Flutter小部件，然后运行应用程序。游戏小部件返回一个带有深色主题UI支架的标准MaterialApp，由一个包含分数视图、游戏板和开始按钮的列组成。这个文件中没有太多内容，因为大部分工作都是在其他组件中完成的。接下来，我们将检查分数视图和游戏板，感受一下设计。</p></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h2 id="72bb" class="ky kz it bd la lb lc dn ld le lf dp lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">游戏分数</h2><p id="b333" class="pw-post-body-paragraph lu lv it lw b lx ly ju lz ma mb jx mc lh md me mf ll mg mh mi lp mj mk ml mm im bi translated">分数类很简单，说明了游戏中使用的一些概念，所以让我们来看看<strong class="lw iu"> score.dart </strong>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="d0ed" class="pw-post-body-paragraph lu lv it lw b lx mw ju lz ma mx jx mc lh my me mf ll mz mh mi lp na mk ml mm im bi translated">游戏分数是用一个独立的模型和视图实现的，模型扩展ChangeNotifier，视图<em class="nz">消耗</em>这个模型，这将允许视图在模型改变时自动更新。这是通过在分值设置器中调用<code class="fe oa ob oc od b">notifyListeners()</code>来完成的，它将通知传播给ChangeNotifierProvider，使小部件用新的分值重新构建自己。</p><p id="548b" class="pw-post-body-paragraph lu lv it lw b lx mw ju lz ma mx jx mc lh my me mf ll mz mh mi lp na mk ml mm im bi translated">这说明了提供者的<a class="ae nb" href="https://flutter.dev/docs/development/data-and-backend/state-mgmt/simple" rel="noopener ugc nofollow" target="_blank">状态管理的一个基本实现，并提供了一种在模型改变状态时更新视图的简洁方法。</a></p><p id="f6b8" class="pw-post-body-paragraph lu lv it lw b lx mw ju lz ma mx jx mc lh my me mf ll mz mh mi lp na mk ml mm im bi translated">Flutter不允许StatelessWidget上的可变属性，也不允许直接访问StatefulWidget的状态，因此这是一个很好的解决方案，可以更新对象的状态，并让它的Widget根据任何需要的条件重新构建。</p></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h2 id="7f8b" class="ky kz it bd la lb lc dn ld le lf dp lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">游戏板</h2><p id="4bdc" class="pw-post-body-paragraph lu lv it lw b lx ly ju lz ma mb jx mc lh md me mf ll mg mh mi lp mj mk ml mm im bi translated">手势处理和棋盘渲染位于<strong class="lw iu">游戏棋盘中。</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="5346" class="pw-post-body-paragraph lu lv it lw b lx mw ju lz ma mx jx mc lh my me mf ll mz mh mi lp na mk ml mm im bi translated">游戏板定义了用于接收用户输入和呈现游戏内容的若干属性和方法。在<code class="fe oa ob oc od b">initState()</code>期间，事件监听器被设置为从控制器接收更新事件，以重新绘制UI。由于Controller类(我们稍后将对此进行研究)只有静态属性，并且不需要实例，因此它使用流来手动通知侦听器，而不需要ChangeNotifier的实例。</p><p id="7034" class="pw-post-body-paragraph lu lv it lw b lx mw ju lz ma mx jx mc lh my me mf ll mz mh mi lp na mk ml mm im bi translated">手势检测器用于捕捉输入，该输入在整个平移事件的过程中进行平均，并在滑动动作完成时提交给控制器，然后为下一个输入手势重置。这可以消除输入的反弹，使控制器更容易理解预期的方向。</p><p id="1044" class="pw-post-body-paragraph lu lv it lw b lx mw ju lz ma mx jx mc lh my me mf ll mz mh mi lp na mk ml mm im bi translated">一个正方形的游戏板被定义为高度和宽度等于设备的宽度，并且游戏棋子被呈现为堆栈的子元素，这将在z轴上一个接一个地堆叠它们。每个游戏棋子的x/y渲染位置是在游戏棋子类内部使用对齐属性来处理的，我们接下来将对此进行研究。</p></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h2 id="9600" class="ky kz it bd la lb lc dn ld le lf dp lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">游戏棋子</h2><p id="cfd1" class="pw-post-body-paragraph lu lv it lw b lx ly ju lz ma mb jx mc lh md me mf ll mg mh mi lp mj mk ml mm im bi translated">处理游戏棋子操作和小部件渲染的类位于<strong class="lw iu"> game-piece.dart </strong>中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="83f3" class="pw-post-body-paragraph lu lv it lw b lx mw ju lz ma mx jx mc lh my me mf ll mz mh mi lp na mk ml mm im bi translated">该文件中的三个主要组件是:</p><ul class=""><li id="4894" class="nj nk it lw b lx mw ma mx lh nl ll nm lp nn mm no np nq nr bi translated">GamePieceModel:管理数据，并在发生变化时通知监听器</li><li id="49c3" class="nj nk it lw b lx ns ma nt lh nu ll nv lp nw mm no np nq nr bi translated">游戏片段视图:渲染一个圆形，当它被移动时会自动移动</li><li id="7e3e" class="nj nk it lw b lx ns ma nt lh nu ll nv lp nw mm no np nq nr bi translated">GamePiece:将GamePieceModel和GamePieceView包装在一个小部件中</li></ul><p id="038e" class="pw-post-body-paragraph lu lv it lw b lx mw ju lz ma mx jx mc lh my me mf ll mz mh mi lp na mk ml mm im bi translated">游戏板渲染一个GamePiece对象列表，每个对象都有一个GamePieceModel支持，同时也驱动GamePieceView的渲染。</p><p id="43ad" class="pw-post-body-paragraph lu lv it lw b lx mw ju lz ma mx jx mc lh my me mf ll mz mh mi lp na mk ml mm im bi translated">每个游戏块直接向游戏板上的父栈呈现一个GamePieceView小部件，并提供<code class="fe oa ob oc od b">get</code>访问器以在必要时暴露底层模型的属性和方法。这使得GamePiece小部件可以作为游戏部件与程序其余部分的接口，简化了对每个部件执行操作的任务。</p><p id="29e0" class="pw-post-body-paragraph lu lv it lw b lx mw ju lz ma mx jx mc lh my me mf ll mz mh mi lp na mk ml mm im bi translated">通过使用Align和FractionalOffset在GamePieceView中完成每个棋子在父堆栈中的定位，在x轴和y轴上将每个棋子偏移棋盘总尺寸的七分之一。</p><p id="28ab" class="pw-post-body-paragraph lu lv it lw b lx mw ju lz ma mx jx mc lh my me mf ll mz mh mi lp na mk ml mm im bi translated">当创建一个游戏棋子时，会传入一个GamePieceModel实例来存储该棋子的位置和值，并从游戏控制器中检索以前的滑动方向，以确定新游戏棋子将从棋盘的哪一侧滑入。</p><p id="ddb8" class="pw-post-body-paragraph lu lv it lw b lx mw ju lz ma mx jx mc lh my me mf ll mz mh mi lp na mk ml mm im bi translated">当棋子移动到一个新位置时，GamePiece中的ChangeNotifierProvider会获取该更改，重新构建小部件并启动控制器，该控制器驱动小部件在屏幕上移动的动画。动画由游戏块状态上的AnimationController驱动，使用<code class="fe oa ob oc od b">TickerProviderStateMixin</code>使其自身与动画控制器同步，该控制器被传递给GamePieceView，并最终传递给它所扩展的AnimatedWidget。GamePieceView的构造函数使用Tween和CurvedAnimation为x和y创建动画值，这将创建从上一个位置到当前位置的动画路径。一旦GamePieceView对象被渲染，先前的位置被设置为当前位置，以防止动画再次运行，直到下一次需要移动棋子。</p></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h2 id="691d" class="ky kz it bd la lb lc dn ld le lf dp lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">控制器</h2><p id="561b" class="pw-post-body-paragraph lu lv it lw b lx ly ju lz ma mb jx mc lh md me mf ll mg mh mi lp mj mk ml mm im bi translated">把所有这些放在一起就是<strong class="lw iu">控制器:</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="dfd9" class="pw-post-body-paragraph lu lv it lw b lx mw ju lz ma mx jx mc lh my me mf ll mz mh mi lp na mk ml mm im bi translated">控制器类执行游戏中的大部分逻辑，包括游戏初始化、输入处理、回合处理和评估。创建了一个随机数生成器和一个<code class="fe oa ob oc od b">List&lt;GamePiece&gt;</code>来存储游戏中的棋子，以及一个<code class="fe oa ob oc od b">Map&lt;Point, GamePiece&gt;</code>来作为方便的x/y查找索引。<code class="fe oa ob oc od b">bus</code>属性提供了Stream和StreamController的实现，以便在回合结束时广播事件。</p><p id="fc43" class="pw-post-body-paragraph lu lv it lw b lx mw ju lz ma mx jx mc lh my me mf ll mz mh mi lp na mk ml mm im bi translated">输入由<code class="fe oa ob oc od b">on</code>方法接收，并通过调用从事件接收的偏移量上的<code class="fe oa ob oc od b">parse</code>转换成<code class="fe oa ob oc od b">Direction</code>。然后对转弯进行评估，并在总线上触发一个更新事件。如果棋盘上的所有49个空格都被占据，游戏重新开始，否则新的棋子被添加到棋盘上，游戏准备好下一步棋。</p><p id="a4f4" class="pw-post-body-paragraph lu lv it lw b lx mw ju lz ma mx jx mc lh my me mf ll mz mh mi lp na mk ml mm im bi translated">回合评估从<code class="fe oa ob oc od b">process</code>方法开始，在该方法中，接收到<code class="fe oa ob oc od b">Direction</code>并使用相应的循环参数调用<code class="fe oa ob oc od b">scan</code>，以评估与滑动方向相反的棋盘。这允许首先处理沿目标向量最远的项目，根据需要合并片段，并为评估中的剩余片段清除一条路径。</p><p id="d628" class="pw-post-body-paragraph lu lv it lw b lx mw ju lz ma mx jx mc lh my me mf ll mz mh mi lp na mk ml mm im bi translated"><code class="fe oa ob oc od b">scan</code>方法采用开始、结束、增量运算和轴。用这些参数构建一个循环，开始扫描棋盘并寻找游戏中的棋子。每个棋子被传入<code class="fe oa ob oc od b">check</code>,它将起点、增量操作、轴和游戏棋子作为输入，并检查棋子的预期路径，根据需要合并或重新定位每个棋子。</p><p id="0ab1" class="pw-post-body-paragraph lu lv it lw b lx mw ju lz ma mx jx mc lh my me mf ll mz mh mi lp na mk ml mm im bi translated">通过首先检查被合并的块是否处于最高可能值来处理合并操作，如果是，则它们都被移除并且奖励分数，否则目标块被移除，并且引入的块被提升并移动到目标位置。</p><p id="d68c" class="pw-post-body-paragraph lu lv it lw b lx mw ju lz ma mx jx mc lh my me mf ll mz mh mi lp na mk ml mm im bi translated">重定位操作只需从索引中删除当前键处的块，调用块上的<code class="fe oa ob oc od b">move</code>来更新它并触发动画，最后将该项放回索引中更新后的x/y位置键处。</p></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/6e399891d50f1197d67766b406b2a349.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*M88sFjxF2fMGfccu12jYag.gif"/></div></div></figure><h2 id="960c" class="ky kz it bd la lb lc dn ld le lf dp lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">结论</h2><p id="588d" class="pw-post-body-paragraph lu lv it lw b lx ly ju lz ma mb jx mc lh md me mf ll mg mh mi lp mj mk ml mm im bi translated">该演示展示了Flutter中可用的一些功能和灵活性，并展示了如何仅使用Flutter SDK和provider包来制作简单的2D游戏，从头开始创建其他一切。</p><p id="8f0c" class="pw-post-body-paragraph lu lv it lw b lx mw ju lz ma mx jx mc lh my me mf ll mz mh mi lp na mk ml mm im bi translated">其中使用的概念可以直接转移到任何类型的Flutter应用程序，这些应用程序需要简单的状态管理、高度交互式的UI、高效的动画和渲染周期，以及未来需要低维护开销的整体干净的架构。</p><p id="e360" class="pw-post-body-paragraph lu lv it lw b lx mw ju lz ma mx jx mc lh my me mf ll mz mh mi lp na mk ml mm im bi translated">请在Medium上关注我，了解更多关于现代软件技术的技术资源，从前端和移动到云、虚拟化和API开发工具。</p><p id="6209" class="pw-post-body-paragraph lu lv it lw b lx mw ju lz ma mx jx mc lh my me mf ll mz mh mi lp na mk ml mm im bi translated">感谢您的阅读，祝您的下一个颤振项目好运！</p><p id="bb42" class="pw-post-body-paragraph lu lv it lw b lx mw ju lz ma mx jx mc lh my me mf ll mz mh mi lp na mk ml mm im bi translated">~ <a class="ae nb" href="https://twitter.com/8_bit_hacker" rel="noopener ugc nofollow" target="_blank"> 8_bit_hacker </a></p></div></div>    
</body>
</html>