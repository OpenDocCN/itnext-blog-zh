<html>
<head>
<title>TypeScript Basics: Understanding The “never” Type</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript基础:了解“从不”类型</h1>
<blockquote>原文：<a href="https://itnext.io/typescript-basics-understanding-the-never-type-3b4bdaa7859c?source=collection_archive---------5-----------------------#2022-02-06">https://itnext.io/typescript-basics-understanding-the-never-type-3b4bdaa7859c?source=collection_archive---------5-----------------------#2022-02-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/97e75b6b94341626fbdbd0875391ed0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ijG31bnqc2IzKgRivvLt4Q.png"/></div></div></figure><p id="1785" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">TypeScript <code class="fe kz la lb lc b">never</code>关键字对许多开发人员来说有点神秘。它有什么作用，什么时候应该使用它？今天我们将深入讨论<code class="fe kz la lb lc b">never</code>关键字，并涵盖您可能遇到它的情况。</p><h1 id="f5fd" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">“从不”的特征</h1><p id="6a5d" class="pw-post-body-paragraph kb kc it kd b ke mb kg kh ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky im bi translated">TypeScript使用<code class="fe kz la lb lc b">never</code>关键字来表示逻辑上不应该发生的情况和控制流。</p><p id="c736" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">实际上，您在工作中不会经常遇到使用<code class="fe kz la lb lc b">never</code>的需要，但是了解它如何有助于TypeScript中的类型安全仍然是很好的。</p><p id="0e9e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们来看看文档是怎么描述的:<code class="fe kz la lb lc b">"The never type is a subtype of, and assignable to, every type; however, no type is a subtype of, or assignable to, never (except never itself)."</code></p><p id="ffeb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">TLDR；你可以将类型为<code class="fe kz la lb lc b">never</code>的变量赋给任何其他变量，但是你不能将其他变量赋给<code class="fe kz la lb lc b">never</code>。让我们来看一个代码示例:</p><pre class="mg mh mi mj gt mk lc ml mm aw mn bi"><span id="fe5a" class="mo le it lc b gy mp mq l mr ms">const throwErrorFunc = () =&gt; { throw new Error(“LOL”) };</span><span id="e719" class="mo le it lc b gy mt mq l mr ms">let neverVar: never = throwErrorFunc()<br/>const myString = “”<br/>const myInt: number = neverVar;<br/>neverVar = myString // Type ‘string’ is not assignable to type ‘never’</span></pre><p id="bd55" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">暂时可以忽略<code class="fe kz la lb lc b">throwErrorFunc</code>。只需知道这是一个用never类型初始化变量的变通方法。</p><p id="4e55" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">从上面的代码中可以看出，我们可以将类型为<code class="fe kz la lb lc b">never</code>的变量<code class="fe kz la lb lc b">neverVar</code>赋给类型为<code class="fe kz la lb lc b">number</code>的变量<code class="fe kz la lb lc b">myInt</code>。但是，我们不能将类型为<code class="fe kz la lb lc b">string</code>的<code class="fe kz la lb lc b">myString</code>变量赋给<code class="fe kz la lb lc b">neverVar</code>。这将导致TypeScript错误。</p><p id="912f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您不能将任何其他类型的变量赋值给<code class="fe kz la lb lc b">never</code>，甚至是类型<code class="fe kz la lb lc b">any</code>的变量。</p><h1 id="9464" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">函数中的“从不”</h1><p id="0314" class="pw-post-body-paragraph kb kc it kd b ke mb kg kh ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky im bi translated">TypeScript使用<code class="fe kz la lb lc b">never</code>作为不会到达其返回端点的函数的返回类型。</p><p id="997b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这主要有两个原因:</p><ul class=""><li id="05d9" class="mu mv it kd b ke kf ki kj km mw kq mx ku my ky mz na nb nc bi translated">该函数抛出错误异常。</li><li id="f70f" class="mu mv it kd b ke nd ki ne km nf kq ng ku nh ky mz na nb nc bi translated">该函数包含一个无限循环。</li></ul><p id="5218" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在我们之前的代码中，您已经看到了“throwErrorFunc”。这是一个抛出异常的函数示例:</p><pre class="mg mh mi mj gt mk lc ml mm aw mn bi"><span id="de07" class="mo le it lc b gy mp mq l mr ms">const throwErrorFunc = () =&gt; {<br/>  throw new Error("LOL")<br/>}; // typescript infers the return type of this function to be 'never'</span></pre><p id="78d2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">另一种情况是，如果有一个无限循环，其中的真值表达式没有任何中断或返回语句:</p><pre class="mg mh mi mj gt mk lc ml mm aw mn bi"><span id="c835" class="mo le it lc b gy mp mq l mr ms">const output = () =&gt; {<br/>  while (true) {<br/>    console.log("This will get annoying quickly");<br/>  }<br/>} // typescript infers the return type of this function to be 'never'</span></pre><p id="3745" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这两种情况下，TypeScript都会推断这些函数的返回类型是<code class="fe kz la lb lc b">never</code>。</p><h1 id="2ec7" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">“从不”和“无效”的区别</h1><p id="3d31" class="pw-post-body-paragraph kb kc it kd b ke mb kg kh ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky im bi translated">那么<code class="fe kz la lb lc b">void</code>型呢？如果我们有<code class="fe kz la lb lc b">void</code>，为什么我们还需要<code class="fe kz la lb lc b">never</code>？</p><p id="7d56" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">never和void的主要区别在于，<code class="fe kz la lb lc b">void</code>类型可以有<code class="fe kz la lb lc b">undefined</code>或<code class="fe kz la lb lc b">null</code>作为值。</p><p id="ef30" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">TypeScript将<code class="fe kz la lb lc b">void</code>用于不返回任何内容的函数。当你没有为你的函数指定返回类型，并且它没有在任何代码路径中返回任何东西时，TypeScript将推断它的返回类型是<code class="fe kz la lb lc b">void</code>。</p><p id="d1ae" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在TypeScript中，<code class="fe kz la lb lc b">void</code>不返回任何东西的函数实际上是在返回<code class="fe kz la lb lc b">undefined</code>。</p><pre class="mg mh mi mj gt mk lc ml mm aw mn bi"><span id="0e36" class="mo le it lc b gy mp mq l mr ms">const functionWithVoidReturnType = () =&gt; {}; // typescript infers the return type of this function to be 'void'<br/>console.log(functionWithVoidReturnType()); // undefined</span></pre><p id="ab7c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然而，我们通常会忽略<code class="fe kz la lb lc b">void</code>函数的返回值。</p><p id="cf30" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里需要注意的另一件事是:根据我们前面提到的<code class="fe kz la lb lc b">never</code>类型的特征，你不能将void赋值给never:</p><pre class="mg mh mi mj gt mk lc ml mm aw mn bi"><span id="4268" class="mo le it lc b gy mp mq l mr ms">const myVoidFunction = () =&gt; {}<br/>neverVar = myVoidFunction() // ERROR: Type 'never' is not assignable to type 'void'</span></pre><h1 id="e6b2" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">“从不”作为可变警卫</h1><p id="d8f3" class="pw-post-body-paragraph kb kc it kd b ke mb kg kh ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky im bi translated">如果变量被一个永远不可能为真的类型保护所限制，它们就可能成为<code class="fe kz la lb lc b">never</code>类型。通常，这表明您的条件逻辑有缺陷。</p><p id="5e90" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们来看一个例子:</p><pre class="mg mh mi mj gt mk lc ml mm aw mn bi"><span id="af49" class="mo le it lc b gy mp mq l mr ms">const unExpectedResult = (myParam: "this" | "that") =&gt; {<br/>    if (myParam === "this") {<br/>    } else if (myParam === "that") {<br/>    } else {<br/>      console.log({ myParam })<br/>    }<br/>  }</span></pre><p id="802d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在上面的例子中，当函数执行到第<code class="fe kz la lb lc b"> console.log({ myParam })</code>行时，<code class="fe kz la lb lc b">myParam</code>的类型将会是<code class="fe kz la lb lc b">never</code>。</p><p id="0dd7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是因为我们将<code class="fe kz la lb lc b">myParam</code>的类型设置为“This”或“that”。因为TypeScript假定这两个是这种情况下唯一可能的选择，所以从逻辑上来说，第三个else语句不应该出现。所以TypeScript将参数类型设置为<code class="fe kz la lb lc b">never</code>。</p><h1 id="04ee" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">彻底的检查</h1><p id="4bdd" class="pw-post-body-paragraph kb kc it kd b ke mb kg kh ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky im bi translated">在实践中，您可能会看到<code class="fe kz la lb lc b">never</code>的一个地方是彻底的检查。详尽的检查对于确保您已经处理了代码中的每一个边缘情况非常有用。</p><p id="b1c0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们来看看如何使用穷举检查为switch语句添加更好的类型安全:</p><pre class="mg mh mi mj gt mk lc ml mm aw mn bi"><span id="4178" class="mo le it lc b gy mp mq l mr ms">type Animal = "cat" | "dog" | "bird"</span><span id="4785" class="mo le it lc b gy mt mq l mr ms">const shouldNotHappen = (animal: never) =&gt; {<br/>    throw new Error("Didn't expect to get here")<br/>  }</span><span id="4ebd" class="mo le it lc b gy mt mq l mr ms">const myPicker = (pet: Animal) =&gt; {<br/>    switch(pet) {<br/>      case "cat": {<br/>        // handle cat<br/>        return<br/>      }<br/>      case "dog": {<br/>      // handle dog<br/>        return<br/>      }<br/>    }<br/>    return shouldNotHappen(pet)<br/>  }</span></pre><p id="15f3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当您添加<code class="fe kz la lb lc b">return shouldNotHappen(pet)</code>时，您应该会立即看到一个错误:</p><figure class="mg mh mi mj gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ni"><img src="../Images/26c7064b75771c965e32a80f3dba8301.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zZpxtn180S2n77trt-1pXA.png"/></div></div></figure><p id="005d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">错误消息通知您忘记在switch语句中包含的情况。这是一种获得编译时安全性并确保在switch语句中处理所有情况的聪明模式。</p><h1 id="31eb" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">结论</h1><p id="4891" class="pw-post-body-paragraph kb kc it kd b ke mb kg kh ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky im bi translated">如您所见，<code class="fe kz la lb lc b">never</code>类型对于特定的事情很有用。大多数时候，这表明您的代码中存在缺陷。但是在某些情况下，比如详尽的检查，它可以是一个很好的工具来帮助你编写更安全的类型脚本代码。</p><p id="f60f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你想获得更多的网络开发、反馈和打字技巧，可以考虑<a class="ae nj" href="https://twitter.com/IskanderSamatov" rel="noopener ugc nofollow" target="_blank">在Twitter上关注我，</a>在那里我分享我学到的东西。<br/>编码快乐！</p></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><p id="36a8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="nr">原载于2022年2月6日https://isamatov.com</em><em class="nr">的</em> <a class="ae nj" href="https://isamatov.com/typescript-understanding-never-type/" rel="noopener ugc nofollow" target="_blank"> <em class="nr">。</em></a></p></div></div>    
</body>
</html>