<html>
<head>
<title>Autoscaling GitLab runners on Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Kubernetes上自动缩放GitLab跑步者</h1>
<blockquote>原文：<a href="https://itnext.io/autoscaling-gitlab-runners-on-kubernetes-cf5739e26c05?source=collection_archive---------1-----------------------#2022-06-12">https://itnext.io/autoscaling-gitlab-runners-on-kubernetes-cf5739e26c05?source=collection_archive---------1-----------------------#2022-06-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="a454" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">语境</h2></div><p id="35c1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有一个Kubernetes集群，上面有GitLab自管理实例和GitLab运行程序。我们每月运行大约3万条管道。我们的大部分工作是用来构建、测试和发布我们的SaaS解决方案。</p><h2 id="f3c6" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">问题</h2><p id="1da8" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">我们最大的问题之一是管理冲刺阶段结束时的充电高峰。在GitLab运行程序数量固定的情况下，不可能满足查询运行程序的所有作业，导致作业失败、超时和挂起的MRs。</p><p id="9977" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我开始深入研究这个问题时，我注意到GitLab文档在我的用例中糟糕透顶。我只是想要一个可用的指标来根据工作的数量来增加/减少跑步者的HPA。社区提出了这个问题<a class="ae lz" href="https://gitlab.com/gitlab-org/gitlab/-/issues/6427" rel="noopener ugc nofollow" target="_blank">在这里</a>和<a class="ae lz" href="https://gitlab.com/gitlab-org/gitlab-runner/-/issues/27061" rel="noopener ugc nofollow" target="_blank">在这里</a>，但是我需要一个实际的解决方案来解决我的问题。</p><p id="1dec" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">在这篇博客中，我将分享我的想法，以帮助您使用HPA (horizontal pod autoscaling)基于作业数量高效地扩展GitLab运行程序</strong>。</p><h2 id="d82e" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">先决条件</h2><p id="5719" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">这里的目标是与观众分享我的研究，以帮助他们实现该机制。</p><p id="8d93" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我假设你有:</p><ul class=""><li id="82c1" class="ma mb iq kh b ki kj kl km ko mc ks md kw me la mf mg mh mi bi translated">关于HPA工作原理、自定义指标、Kubernetes和helm v3的知识</li><li id="393f" class="ma mb iq kh b ki mj kl mk ko ml ks mm kw mn la mf mg mh mi bi translated">一个Kubernetes集群开始运行</li><li id="b166" class="ma mb iq kh b ki mj kl mk ko ml ks mm kw mn la mf mg mh mi bi translated">Gitlab舵图已安装</li><li id="314a" class="ma mb iq kh b ki mj kl mk ko ml ks mm kw mn la mf mg mh mi bi translated">Prometheus操作符(或者只是一个简单的Prometheus实例就可以了):用于从GitLab运行程序中获取指标</li><li id="41c3" class="ma mb iq kh b ki mj kl mk ko ml ks mm kw mn la mf mg mh mi bi translated">Prometheus适配器舵图:用于将Prometheus指标转换为HPA将使用的API对象</li></ul><p id="b487" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下表将让您了解我在本文中使用的版本</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="e769" class="lb lc iq mt b gy mx my l mz na">+---------------------+--------------------+-------------+------------------------------------------------------+<br/>|        name         | helm chart version | app version |                        source                        |<br/>+---------------------+--------------------+-------------+------------------------------------------------------+<br/>| prometheus adapter  |             2.17.0 |  v0.9.0     | <a class="ae lz" href="https://github.com/prometheus-community/helm-charts/" rel="noopener ugc nofollow" target="_blank">https://github.com/prometheus-community/helm-charts/</a> |<br/>| prometheus operator |             22.1.0 |  v0.52.0    | <a class="ae lz" href="https://github.com/prometheus-community/helm-charts/" rel="noopener ugc nofollow" target="_blank">https://github.com/prometheus-community/helm-charts/</a> |<br/>| gitlab              |              4.8.8 |  13.8.8     | <a class="ae lz" href="https://charts.gitlab.io" rel="noopener ugc nofollow" target="_blank">https://charts.gitlab.io</a>                             |<br/>| gitlab-runner       |             0.25.0 |  13.8.0     | <a class="ae lz" href="https://charts.gitlab.io" rel="noopener ugc nofollow" target="_blank">https://charts.gitlab.io</a>                             |<br/>+---------------------+--------------------+-------------+------------------------------------------------------+</span></pre><p id="99e8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于那些需要在他们的家庭实验室中测试设置的人，我推荐使用这个<a class="ae lz" href="https://gitlab.com/tmaczukin-test-projects/runner-helm-stack/-/tree/master/#gitlab-runner-helm-chart-preparation" rel="noopener ugc nofollow" target="_blank"> git库</a>作为参考(设置的版本不相同，但是导致相同的结果)</p><h2 id="6f2c" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">工作流程:</h2><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="fa4d" class="lb lc iq mt b gy mx my l mz na">gitlab runner -&gt; metrics -&gt; prometheus -&gt; prometheus adapter -&gt; hpa -&gt; scaleup/down</span></pre><p id="9b39" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，我们需要理解我们想要实现的机制是如何工作的:</p><ol class=""><li id="dd06" class="ma mb iq kh b ki kj kl km ko mc ks md kw me la nb mg mh mi bi translated">GitLab runner将暴露默认端口上的指标<code class="fe nc nd ne mt b">9252</code></li><li id="961e" class="ma mb iq kh b ki mj kl mk ko ml ks mm kw mn la nb mg mh mi bi translated">Prometheus实例通过使用基于serviceMonitor或podMonitor自定义资源的自动报废来获取指标</li><li id="09b0" class="ma mb iq kh b ki mj kl mk ko ml ks mm kw mn la nb mg mh mi bi translated">Prometheus将用于创建一个新的指标，我们将在以后使用</li><li id="87aa" class="ma mb iq kh b ki mj kl mk ko ml ks mm kw mn la nb mg mh mi bi translated">Prometheus适配器将从Prometheus实例获取指标，并将它们转换为自定义或外部指标。</li><li id="d33f" class="ma mb iq kh b ki mj kl mk ko ml ks mm kw mn la nb mg mh mi bi translated">HPA资源将观察自定义指标，并相应地扩大/缩小规模</li></ol><h2 id="53ff" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">获取指标</h2><p id="8630" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">为了能够动态获取指标，建议将Prometheus运算符与serviceMonitor /podMonitor自定义资源(CRD)一起使用。</p><p id="008f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在ServiceMonitor中，我们指定了Kubernetes标签，操作员可以使用这些标签来识别Kubernetes服务，然后由Kubernetes服务来识别我们希望监控的pod。PodMonitor使用相同的发现策略，但是没有服务发现层。</p><figure class="mo mp mq mr gt ng gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi nf"><img src="../Images/14c9dfa323a429a018ef001865f2dd73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5ciW5ZkuYAprbwuEST0otw.png"/></div></div><figcaption class="nn no gj gh gi np nq bd b be z dk translated">普罗米修斯算子</figcaption></figure><p id="f992" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要了解更多关于Prometheus operator如何工作以及serviceMonitor如何自动发现的信息，请点击<a class="ae lz" href="https://sysdig.com/blog/kubernetes-monitoring-prometheus-operator-part3/" rel="noopener ugc nofollow" target="_blank">此链接</a>。</p><p id="8ab1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们知道了它是如何工作的，让我们实现一个从GitLab runner获取指标的podMonitor。</p><blockquote class="nr ns nt"><p id="a08e" class="kf kg nu kh b ki kj jr kk kl km ju kn nv kp kq kr nw kt ku kv nx kx ky kz la ij bi translated">注意:如果你使用git lab runner helm chart≥<a class="ae lz" href="https://gitlab.com/gitlab-org/charts/gitlab-runner/-/commit/83f766cf29d4762de01b2892adb7fe8a6128fee7" rel="noopener ugc nofollow" target="_blank">0 . 35 . 0</a>就不需要做这个步骤，只需要启用values.yaml中的servicemonitor选项即可。</p></blockquote><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="2216" class="lb lc iq mt b gy mx my l mz na">apiVersion: monitoring.coreos.com/v1<br/>kind: PodMonitor<br/>metadata:<br/>  name: gitlab-runner-build-v2<br/>  labels:<br/>    app: gitlab-runner-buildv2-gitlab-runner<br/>    release: gitlab-runner-buildv2<br/>spec:<br/>  selector:<br/>    matchLabels:<br/>      app: gitlab-runner-buildv2-gitlab-runner<br/>  podMetricsEndpoints:<br/>  - port: metrics</span></pre><p id="ddee" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在你已经创建了pod监视器，你通常在Prometheus中自动拥有目标:</p><figure class="mo mp mq mr gt ng gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/84fd11f614d5c22bdbeea994734e2f63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1172/format:webp/1*IWmVcmA9SsdxTZbMkshlpQ.png"/></div></figure><p id="b2fb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果目标没有出现，请检查:</p><ul class=""><li id="07ef" class="ma mb iq kh b ki kj kl km ko mc ks md kw me la mf mg mh mi bi translated">标签选择器是否与pod的标签匹配</li><li id="1467" class="ma mb iq kh b ki mj kl mk ko ml ks mm kw mn la mf mg mh mi bi translated">端口的名称</li></ul><p id="bdc6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要检查指标是否被废弃，请检查特定于GitLab跑步者的指标之一，例如<code class="fe nc nd ne mt b">gitlab_runner_concurrent</code></p><figure class="mo mp mq mr gt ng gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi nz"><img src="../Images/6e9e0991d21daad8c55656a3e0e8112c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1298/format:webp/1*IY_RpO73KiO9mkfXF6G1CA.png"/></div></div></figure><h2 id="af91" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">选择正确的指标来扩大/缩小跑步者</h2><p id="febf" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">挑战之一是定义HPA中使用的指标。</p><ul class=""><li id="8e8a" class="ma mb iq kh b ki kj kl km ko mc ks md kw me la mf mg mh mi bi translated"><strong class="kh ir">测试1: </strong>基于内存的伸缩&amp; &amp; CPU:这不是一个正确的选择，因为CPU或内存消耗与运行器的任务数量无关。</li><li id="fe29" class="ma mb iq kh b ki mj kl mk ko ml ks mm kw mn la mf mg mh mi bi translated"><strong class="kh ir">测试2: </strong>基于` gitlab_runner_jobs`: (gauge)的缩放，当前运行的构建数。当我开始测试时，我注意到当没有作业运行或挂起时，这个指标消失了，这导致了HPA端的故障。</li></ul><blockquote class="nr ns nt"><p id="20b8" class="kf kg nu kh b ki kj jr kk kl km ju kn nv kp kq kr nw kt ku kv nx kx ky kz la ij bi translated">如果你运行的是gitlab ≥ 14.6，你就不会有这个问题，因为他们引入了“空闲”指标来减少这个错误。<a class="ae lz" href="https://gitlab.com/gitlab-org/gitlab-runner/-/merge_requests/3202" rel="noopener ugc nofollow" target="_blank">参考</a></p></blockquote><p id="3e44" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了有一个全面的指标来提供挂起的作业总数，我创建了一个名为gitlab_runner_jobs_total_build的新的自定义指标，它将对我的所有正在运行的运行者的作业数求和，如果不存在，就将其设置为零。</p><p id="459c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为此，您需要添加一个普罗米修斯规则来创建度量。</p><p id="89ec" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在Prometheus operator中，您可以添加一个规则作为自定义资源定义:</p><p id="73aa" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">(确保定义正确的标签来创建您的自定义指标，例如，我一直在使用”。*gitlab-runner-build。* "过滤我的跑步者)</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="d206" class="lb lc iq mt b gy mx my l mz na">apiVersion: monitoring.coreos.com/v1<br/>kind: PrometheusRule<br/>metadata:<br/>  name: kube-prometheus-stack-build-runner-metrics<br/>  namespace: monitoring<br/>spec:<br/>  groups:<br/>  - name: runners.metrics<br/>    rules:<br/>    - expr: sum(gitlab_runner_jobs{job=~".*gitlab-runner-build.*"}) OR clamp_max(absent(notExists{job=~".*gitlab-runner-build.*"}),0)<br/>      record: gitlab_runner_jobs_build_total<br/>    - expr: gitlab_runner_jobs_build_total/sum(gitlab_runner_concurrent{job=~".*gitlab-runner-build.*"})<br/>      record: gitlab_runner_build_total:concurrent_saturation<br/>    - expr: gitlab_runner_jobs/ on(namespace, pod) gitlab_runner_concurrent<br/>      record: gitlab_runner_jobs:concurrent_saturation</span></pre><blockquote class="nr ns nt"><p id="73cf" class="kf kg nu kh b ki kj jr kk kl km ju kn nv kp kq kr nw kt ku kv nx kx ky kz la ij bi translated">如果您在prometheus classic实例上，您可以直接在配置文件中添加规则</p></blockquote><p id="3904" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你使用普罗米修斯操作员舵图，你可以直接在<a class="ae lz" href="https://github.com/prometheus-community/helm-charts/blob/main/charts/kube-prometheus-stack/values.yaml#L93" rel="noopener ugc nofollow" target="_blank">值中添加<code class="fe nc nd ne mt b">additionalPrometheusRulesMap</code>下的规则。yaml </a></p><p id="fac5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如文件所示，我们添加了3个新指标:</p><ul class=""><li id="5ff6" class="ma mb iq kh b ki kj kl km ko mc ks md kw me la mf mg mh mi bi translated"><strong class="kh ir">git lab _ runner _ jobs _ build _ total:</strong>所有构建运行程序中的构建作业总数</li><li id="280d" class="ma mb iq kh b ki mj kl mk ko ml ks mm kw mn la mf mg mh mi bi translated"><strong class="kh ir">git lab _ runner _ build _ total:concurrent _ saturation:</strong>所有构建运行程序的饱和度</li><li id="6e96" class="ma mb iq kh b ki mj kl mk ko ml ks mm kw mn la mf mg mh mi bi translated"><strong class="kh ir">git lab _ runner _ jobs:concurrent _ saturation:</strong>饱和运行程序的数量</li></ul><p id="0b54" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们开始用<strong class="kh ir">git lab _ runner _ jobs _ build _ total</strong>进行测试时，我们得到了一些不错的结果，但感觉确实是正确的！！</p><p id="0fc5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一些更复杂的事情需要理解:一个GitLab runner pod可以产生多达X个并发的runner，这些runner将为他完成工作并杀死他们自己，你可以在这里了解流程<a class="ae lz" href="https://docs.gitlab.com/runner/executors/kubernetes.html" rel="noopener ugc nofollow" target="_blank"/>。</p><figure class="mo mp mq mr gt ng gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi oa"><img src="../Images/6dfbb63ea5df5370f9a3999b2ce61012.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RzKumKpycr_V_2ZdGhaZyA.png"/></div></div><figcaption class="nn no gj gh gi np nq bd b be z dk translated">GitLab转轮流量</figcaption></figure><p id="4796" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这就是我们定义<strong class="kh ir">git lab _ runner _ build _ total:concurrent _ saturation的原因。</strong>该指标将返回所有跑步者的整体饱和度。</p><p id="fd4d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们做些数学计算:</p><p id="ef58" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您有一个可以运行10个并发作业的运行程序，并且队列中有5个作业，那么该运行程序将有50%的饱和度。</p><p id="16cc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">计算饱和度的规则很简单:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="f448" class="lb lc iq mt b gy mx my l mz na">global_saturation= total number of jobs / total number of concurrent jobs that can be run on all runners</span></pre><p id="c0d6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果饱和度太高，无法缓解饱和跑步者的压力，我们将扩大规模；如果没有饱和度，我们将缩小规模。</p><h2 id="ba0a" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">将外部指标用于HPA</h2><p id="8899" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">既然我们选择了正确的指标，我们需要将它导出到API服务器，以便HPA可以使用它作为扩展的参考。P <a class="ae lz" href="https://github.com/kubernetes-sigs/prometheus-adapter" rel="noopener ugc nofollow" target="_blank"> rometheus适配器</a>将把Prometheus公制转换成可由Kubernetes使用的自定义公制资源。</p><p id="f4c6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下一步是在右侧部分<a class="ae lz" href="https://github.com/prometheus-community/helm-charts/blob/main/charts/prometheus-adapter/values.yaml#L103" rel="noopener ugc nofollow" target="_blank">下方添加一个新的外部指标</a>:</p><figure class="mo mp mq mr gt ng"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="e300" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要测试指标是否可访问，请尝试直接卷曲特定指标的API服务器:</p><figure class="mo mp mq mr gt ng"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="9280" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们现在可以基于该指标在GitLab runner上创建/启用HPA。</p><p id="6c73" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于使用helm chart实现GitLab runners的人员，您只需取消注释HPA <a class="ae lz" href="https://gitlab.com/gitlab-org/charts/gitlab-runner/-/blob/main/values.yaml#L661" rel="noopener ugc nofollow" target="_blank">部分</a>:</p><figure class="mo mp mq mr gt ng"><div class="bz fp l di"><div class="ob oc l"/></div></figure><blockquote class="nr ns nt"><p id="53ab" class="kf kg nu kh b ki kj jr kk kl km ju kn nv kp kq kr nw kt ku kv nx kx ky kz la ij bi translated">gitlab跑步者的默认舵图使用v1/beta1 HPA API。对于更高级的设置，您可以创建自己的HPA。</p></blockquote><h2 id="bc0a" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">测试设置</h2><p id="b777" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">关键时刻到了，我们已经设置了所有需要的组件，让我们测试所选指标的效率。</p><p id="d0ef" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了测试运行程序，我们创建了一个CI，它将产生50个并行作业，睡眠时间为60秒，以加速运行程序的饱和。</p><figure class="mo mp mq mr gt ng"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="b03f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了监控我们系统的行为，我创建了一个Grafana，它将监控多个指标(作业数量、运行者数量、自动缩放状态……)你可以在这里免费下载它</p><blockquote class="nr ns nt"><p id="4491" class="kf kg nu kh b ki kj jr kk kl km ju kn nv kp kq kr nw kt ku kv nx kx ky kz la ij bi translated">对于这个设置，我们有一个运行程序，在k8s上运行10个并发作业</p></blockquote><figure class="mo mp mq mr gt ng"><div class="bz fp l di"><div class="od oc l"/></div></figure><p id="be7d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当作业数量达到10时，流道饱和，这将触发自动缩放器添加更多流道，直到饱和低于阈值。</p><figure class="mo mp mq mr gt ng gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi oe"><img src="../Images/61adbb98b90a734d682c8ebbfe54616d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iDcHb_Kkx-t4LXhNZDHATg.png"/></div></div></figure><p id="41e0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">处理完所有作业后，自动缩放器会将流道缩小到最小。</p><h2 id="5a6e" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">最后的想法</h2><p id="6e89" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">我们已经注意到这个设置非常有趣，并且在解决我们的问题时非常有效。当我进一步推动测试时，我注意到我们在纵向扩展上有延迟。该指标公开了运行者已经确认的作业。因此，只有当我们让一个跑步者饱和时，我们才会扩大规模。</p><p id="f63e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我计划测试的另一个方面是实现一个作业导出器，它将每XX秒调用<a class="ae lz" href="https://docs.gitlab.com/ee/api/jobs.html" rel="noopener ugc nofollow" target="_blank"> Gitlab作业API </a>。该导出器将获取挂起作业的数量，并将其作为普罗米修斯度量导出。从那里我们可以预测，我们将有一个高的充电峰值，并相应地调整我们的跑步者</p></div></div>    
</body>
</html>