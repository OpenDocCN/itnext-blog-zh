<html>
<head>
<title>Stupid Simple Service Mesh — What, When, Why</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">愚蠢的简单服务网格—什么，什么时候，为什么</h1>
<blockquote>原文：<a href="https://itnext.io/stupid-simple-service-mesh-what-when-why-e9be9e5f4d41?source=collection_archive---------0-----------------------#2021-09-29">https://itnext.io/stupid-simple-service-mesh-what-when-why-e9be9e5f4d41?source=collection_archive---------0-----------------------#2021-09-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/98e835adac456ab74c518b877dbb07b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YECeOxlko9KoOJNw8RNm3A.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">艾莉娜·格鲁布尼亚克在<a class="ae kf" href="https://unsplash.com/s/photos/network?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="72a4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最近基于微服务的应用变得非常流行，随着微服务的兴起，<strong class="ki iu">服务网格</strong>的概念也成为一个非常热门的话题。不幸的是，关于这个概念的文章很少，而且大部分都很难理解。</p><p id="36ee" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这篇博客中，我们将尝试<strong class="ki iu">使用“愚蠢简单”的解释</strong>、图表和例子来揭开服务网格概念的神秘面纱，使这个概念对每个人来说更加透明和容易理解。在<strong class="ki iu">的第一篇文章</strong>中，我们将讨论<strong class="ki iu">服务网格的基本构建模块</strong>，并且我们将实现一个<strong class="ki iu">示例应用</strong>来获得每个理论概念的实际示例。在<strong class="ki iu">接下来的文章</strong>中，基于这个示例应用程序，我们将触及更高级的主题，如Kubernetes 中的<strong class="ki iu">服务网格，我们将讨论更多的<strong class="ki iu">高级服务网格实现，如</strong><a class="ae kf" href="https://istio.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ki iu">Istio</strong></a><strong class="ki iu">、</strong> <a class="ae kf" href="https://linkerd.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ki iu"> Linkerd </strong> </a>等。</strong></p><p id="4e25" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要理解<a class="ae kf" href="https://en.wikipedia.org/wiki/Service_mesh" rel="noopener ugc nofollow" target="_blank"> <strong class="ki iu">服务网格</strong> </a>的概念，第一步就是要理解<strong class="ki iu">它解决</strong>什么问题<strong class="ki iu">它如何解决这些问题</strong>。</p><p id="dbaf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">软件架构在短时间内发展了很多，从经典的单片架构到微服务。尽管许多人称赞微服务架构是软件开发的圣杯，但它也带来了一些严峻的挑战。</p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi le"><img src="../Images/471a43faefef993fbb8c5453d9bb588e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*21ePS6MbitaaGW2P1_HzYQ.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">示例应用程序概述</figcaption></figure><p id="be35" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，基于微服务的架构意味着我们有一个<strong class="ki iu">分布式系统。</strong>每个分布式系统都有挑战，比如<em class="lj">透明</em>、<em class="lj">安全</em>、<em class="lj">可扩展性</em>、<em class="lj">故障排除、</em>和<em class="lj">确定问题的根本原因</em>。在单块系统中，我们可以通过跟踪找到失败的根本原因。但是在基于微服务的系统中，每个服务都可以用不同的语言编写，因此跟踪不是一项简单的任务。另一个挑战是<em class="lj">服务对服务的通信。</em>开发人员需要关注<em class="lj">服务发现</em>、<em class="lj">处理连接错误</em>、<em class="lj">检测延迟</em>、<em class="lj">重试逻辑</em>等，而不是关注业务逻辑。将<a class="ae kf" href="https://medium.com/backticks-tildes/the-s-o-l-i-d-principles-in-pictures-b34ce2f1e898" rel="noopener"> <strong class="ki iu">坚实的</strong> </a> <strong class="ki iu"> </strong>原则应用在<strong class="ki iu">架构层面</strong>上，意味着这类网络问题<strong class="ki iu">要抽象掉，不要和业务逻辑</strong>混在一起。这就是为什么我们需要服务网格。</p><h1 id="744b" class="lk ll it bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">入口控制器与API网关和服务网格</h1><p id="e4aa" class="pw-post-body-paragraph kg kh it ki b kj mi kl km kn mj kp kq kr mk kt ku kv ml kx ky kz mm lb lc ld im bi translated">正如我上面提到的，我们需要在一个架构层次上应用<a class="ae kf" href="https://medium.com/backticks-tildes/the-s-o-l-i-d-principles-in-pictures-b34ce2f1e898" rel="noopener"><strong class="ki iu"/></a><strong class="ki iu">坚实的原则。为此，设定入口控制器、API网关和服务网格之间的界限并理解每一个的角色和责任是很重要的。</strong></p><p id="0c77" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在一个愚蠢简单和过于简单的层面上，这些是每个概念的责任:</p><ol class=""><li id="8b92" class="mn mo it ki b kj kk kn ko kr mp kv mq kz mr ld ms mt mu mv bi translated"><a class="ae kf" href="https://www.nginx.com/resources/glossary/kubernetes-ingress-controller/" rel="noopener ugc nofollow" target="_blank"> <strong class="ki iu">入口控制器</strong> </a>:允许<strong class="ki iu">单个IP端口访问集群</strong>的所有服务，因此其主要职责是路径映射、路由和简单的负载均衡，<em class="lj">作为反向代理</em></li><li id="f00f" class="mn mo it ki b kj mw kn mx kr my kv mz kz na ld ms mt mu mv bi translated"><a class="ae kf" href="https://www.redhat.com/en/topics/api/what-does-an-api-gateway-do" rel="noopener ugc nofollow" target="_blank"> <strong class="ki iu"> API网关</strong> </a> : <strong class="ki iu">聚合并抽象掉API</strong>；其他职责包括速率限制、身份验证、安全性、跟踪等。在基于微服务的应用程序中，您需要一种方法来将请求分发到不同的服务，收集来自多个/所有微服务的响应，然后准备发送给调用者的最终响应。这就是API网关应该做的事情。它负责<strong class="ki iu">客户端到服务的通信、</strong> <a class="ae kf" href="https://en.wikipedia.org/wiki/North-south_traffic" rel="noopener ugc nofollow" target="_blank"> <strong class="ki iu">南北交通</strong> </a>。</li><li id="f418" class="mn mo it ki b kj mw kn mx kr my kv mz kz na ld ms mt mu mv bi translated"><a class="ae kf" href="https://www.nginx.com/blog/what-is-a-service-mesh/" rel="noopener ugc nofollow" target="_blank"> <strong class="ki iu">服务网</strong> </a> : <strong class="ki iu"> </strong>负责<strong class="ki iu">服务对服务通信，</strong> <a class="ae kf" href="https://en.wikipedia.org/wiki/East-west_traffic" rel="noopener ugc nofollow" target="_blank"> <strong class="ki iu">东西向流量</strong> </a>。我们将在下一节深入探讨服务网格的概念。</li></ol><p id="3cb2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">服务网格</strong>和<strong class="ki iu"> API网关</strong>具有重叠的功能，如速率限制、安全、服务发现、追踪等。但是他们在不同的层面上工作，解决不同的问题。<strong class="ki iu">服务网格</strong>负责服务之间的<strong class="ki iu">请求流。</strong> <strong class="ki iu"> API网关</strong>负责客户端和服务之间的<strong class="ki iu">请求流，聚合多个服务，创建并向客户端发送最终响应。</strong></p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/cc82989fc3ce2549443c253b602d4177.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/format:webp/1*cTVHijV3i1jAzg62izY43g.jpeg"/></div></figure><p id="342d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">API网关的主要职责是接受来自网络外部的流量，并在网络内部进行分发，而服务网格的主要职责是路由和管理网络内部的流量。它们是互补的概念，一个定义良好的基于微服务的系统应该将它们结合起来，以确保应用程序正常运行和弹性，同时确保您的应用程序易于使用。</p><h1 id="3487" class="lk ll it bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">服务网格解决什么问题？</h1><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nc"><img src="../Images/d0bed0e358a479dd38f5d96dbca7e3a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sjc1PuDdEcGDbpbqqglEvQ.jpeg"/></div></div></figure><p id="c66c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">作为一个过于简化和愚蠢的简单定义，服务网格是一个<strong class="ki iu"> <em class="lj">抽象层，隐藏并分离网络相关逻辑和业务逻辑</em> </strong>。这样，开发人员可以只专注于实现业务逻辑。我们使用位于服务前端的<strong class="ki iu">代理</strong>来实现这个抽象。它会处理所有与网络相关的问题。这允许服务关注真正重要的东西:业务逻辑。在基于微服务的架构中，我们有多个服务，每个服务都有一个代理。<strong class="ki iu">合起来，</strong> <strong class="ki iu">这些<em class="lj">代理被称为服务网格</em> </strong>。</p><p id="8463" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如最佳实践所建议的，<em class="lj">代理和服务应该在不同的容器中</em>，因此每个容器都有一个<strong class="ki iu">单一职责</strong>。在Kubernetes的世界里，代理的容器被实现为一个<a class="ae kf" href="https://www.magalix.com/blog/the-sidecar-pattern" rel="noopener ugc nofollow" target="_blank"> <strong class="ki iu"> sidecar </strong> </a>。这意味着每个服务都有一个包含代理的sidecar。一个单元将包含两个容器:服务和边车。另一种实现是对多个pod使用一个代理。在这种情况下，代理可以实现为一个默认设置。最常见的解决方案是使用边车。就个人而言，我更喜欢sidecars而不是Deamonsets，因为它们尽可能地保持代理的逻辑简单。</p><p id="7431" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有多种服务网状解决方案，包括<a class="ae kf" href="https://istio.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ki iu"/></a><strong class="ki iu"/><a class="ae kf" href="https://linkerd.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ki iu">Linkerd</strong></a><strong class="ki iu"/><a class="ae kf" href="https://www.consul.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ki iu">领事</strong></a><strong class="ki iu"/><a class="ae kf" href="https://konghq.com/kong-mesh/" rel="noopener ugc nofollow" target="_blank"><strong class="ki iu">孔</strong></a><strong class="ki iu"/><a class="ae kf" href="https://cilium.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ki iu">纤毛</strong> </a>。(我们将在后面的文章中讨论这些解决方案。)让我们把重点放在基础知识上，从<a class="ae kf" href="https://www.envoyproxy.io/docs/envoy/latest/intro/what_is_envoy#" rel="noopener ugc nofollow" target="_blank"> <strong class="ki iu">特使</strong> </a>开始理解服务网格的概念。<strong class="ki iu"> </strong>这是一个高性能的代理，并不是服务网格的完整框架或解决方案(在本教程中，<strong class="ki iu">我们将构建自己的服务网格解决方案</strong>)。一些服务网格解决方案在后台使用Envoy(如Istio)，因此在开始使用这些高级解决方案之前，最好先了解底层功能。</p><h1 id="a34a" class="lk ll it bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">理解特使</h1><h2 id="f9b3" class="nd ll it bd lm ne nf dn lq ng nh dp lu kr ni nj ly kv nk nl mc kz nm nn mg no bi translated">入口和出口</h2><figure class="lf lg lh li gt ju gh gi paragraph-image"><div class="gh gi np"><img src="../Images/ab0f88d0181770abd3c381a052e0ddac.png" data-original-src="https://miro.medium.com/v2/resize:fit:502/0*LrWw1W3uq7GNqrfT"/></div></figure><p id="9593" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">简单定义:</strong></p><ul class=""><li id="7a05" class="mn mo it ki b kj kk kn ko kr mp kv mq kz mr ld nq mt mu mv bi translated">任何发送到服务器(服务)的流量都被称为<strong class="ki iu">入口</strong>。</li><li id="03bf" class="mn mo it ki b kj mw kn mx kr my kv mz kz na ld nq mt mu mv bi translated">从服务器(服务)发送的任何流量都被称为<strong class="ki iu">出口</strong>。</li></ul><p id="0eb1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">入口</strong>和<strong class="ki iu">出口</strong>规则应该添加到特使代理的<strong class="ki iu">配置中，所以边车会处理这些。这意味着<em class="lj">到服务<em class="lj">的任何流量</em>将首先到达特使边车。</em>然后<em class="lj">特使代理将流量重定向到真实服务</em>。反之亦然，来自该服务的任何流量将首先到达特使代理，特使使用<a class="ae kf" href="https://avinetworks.com/glossary/service-discovery/#:~:text=Microservices%20service%20discovery%20is%20a,microservices%20architecture%20discovery%20includes%20both%3A&amp;text=a%20central%20server%20(or%20servers,a%20global%20view%20of%20addresses." rel="noopener ugc nofollow" target="_blank">服务发现</a>解析目标服务。通过拦截入站和出站流量，Envoy可以实现服务发现、断路器、速率限制等。</strong></p><h2 id="d98b" class="nd ll it bd lm ne nf dn lq ng nh dp lu kr ni nj ly kv nk nl mc kz nm nn mg no bi translated">特使代理配置文件的结构</h2><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nr"><img src="../Images/a8fd260303783facb390261259a7ad87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mXfe6hgut1JXEXVv"/></div></div></figure><p id="0a79" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">每个特使配置文件都有以下组件:</p><ol class=""><li id="2869" class="mn mo it ki b kj kk kn ko kr mp kv mq kz mr ld ms mt mu mv bi translated"><strong class="ki iu">监听器:</strong>我们在这里配置特使代理监听的IP和端口号</li><li id="6937" class="mn mo it ki b kj mw kn mx kr my kv mz kz na ld ms mt mu mv bi translated"><strong class="ki iu">路由:</strong>接收到的请求将根据规则被路由到一个集群。例如，我们可以使用路径匹配规则和前缀重写规则来选择应该处理特定路径/子域请求的服务。实际上，<strong class="ki iu">路线只是另一种类型的过滤器</strong>，是强制性的。否则，代理不知道将我们的请求路由到哪里。</li><li id="177b" class="mn mo it ki b kj mw kn mx kr my kv mz kz na ld ms mt mu mv bi translated"><strong class="ki iu">过滤器:</strong>过滤器可以被链接起来，用于执行不同的规则，例如速率限制、路由突变、请求操作等。</li><li id="8e26" class="mn mo it ki b kj mw kn mx kr my kv mz kz na ld ms mt mu mv bi translated"><strong class="ki iu">集群:</strong>充当一组逻辑相似的服务的<strong class="ki iu"> </strong>管理器(集群的职责与Kubernetes中的服务相似；它定义了访问服务的方式)，并充当服务之间的负载平衡器。</li><li id="32ee" class="mn mo it ki b kj mw kn mx kr my kv mz kz na ld ms mt mu mv bi translated"><strong class="ki iu">服务/主机:</strong>处理和响应请求的具体服务</li></ol><p id="31d6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下是特使配置文件的示例:</p><figure class="lf lg lh li gt ju"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="85f2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的配置文件转换成下图:</p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nu"><img src="../Images/3afddd310e59ca95f1618d7a3884aab0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*E3G0RdVGvscIOVqI"/></div></div></figure><p id="30c9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该图没有包括所有服务的所有配置文件，但足以理解基本内容。你可以在我的<a class="ae kf" href="https://github.com/CzakoZoltan08/Stupid-Simple-Service-Mesh" rel="noopener ugc nofollow" target="_blank"> <strong class="ki iu">愚蠢简单服务网格库</strong> </a>里找到这段代码。</p><p id="e2c5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如你所看到的，在第10–15行之间，我们为我们的特使代理定义了监听器。因为我们在Docker工作，所以主机是0.0.0.0。</p><p id="2fbe" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">配置完监听器后，在第15–52行之间，我们定义了<strong class="ki iu">过滤器</strong>。为简单起见，我们仅使用基本过滤器<strong class="ki iu">来匹配路线并重写目标路线</strong>。在这种情况下，如果子域是“host:port/nodeJs”，路由器将选择<em class="lj"> nodejs </em>集群，URL将被重写为“host:port/”(这样，对具体服务的请求将不包含/nodesJs部分)。在“host:port/nestJs”的情况下，逻辑也是相同的。如果请求中没有子域，那么请求将被路由到名为<em class="lj"> base </em>的集群，而不使用前缀重写过滤器。</p><p id="7e7a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在第53–89行之间，我们定义了<strong class="ki iu">簇</strong>。<em class="lj">基地</em>集群将有两个服务，选择的负载均衡策略是<em class="lj">循环</em>。其他可用策略可以在 这里找到<a class="ae kf" href="https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/upstream/load_balancing/load_balancers" rel="noopener ugc nofollow" target="_blank"> <strong class="ki iu">。另外两个集群(<em class="lj"> nodejs </em>和<em class="lj"> nestjs </em>)很简单，只有一个服务。</strong></a></p><p id="0a0e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">本教程的<strong class="ki iu">完整代码</strong>可以在我的<a class="ae kf" href="https://github.com/CzakoZoltan08/Stupid-Simple-Service-Mesh" rel="noopener ugc nofollow" target="_blank"> <strong class="ki iu">愚蠢简单服务网格git资源库</strong> </a>中找到。</p><h1 id="5757" class="lk ll it bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">结论</h1><p id="411c" class="pw-post-body-paragraph kg kh it ki b kj mi kl km kn mj kp kq kr mk kt ku kv ml kx ky kz mm lb lc ld im bi translated">在本文中，我们了解了<strong class="ki iu">服务网格的基本概念</strong>。在第一部分中，我们了解了入口控制器、API网关和服务网格之间的<strong class="ki iu">职责和区别。</strong>然后我们讲了什么是<strong class="ki iu">服务网</strong>和<strong class="ki iu">它解决什么问题</strong>。在第二部分中，我们介绍了<a class="ae kf" href="https://www.envoyproxy.io/docs/envoy/latest/intro/what_is_envoy#" rel="noopener ugc nofollow" target="_blank"> <strong class="ki iu">特使</strong> </a>，这是一个高性能且流行的代理，我们用它来构建我们的服务网格示例。我们了解了<strong class="ki iu">特使配置文件的不同部分</strong>和<strong class="ki iu">创建了一个包含五个示例服务</strong>和<strong class="ki iu">前端边缘代理</strong>的服务网格。</p><p id="1f9e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在下一篇文章的<strong class="ki iu">中，我们将看看如何将<strong class="ki iu">服务网格与Kubernetes </strong>一起使用，并将创建一个示例项目，该项目可以作为任何使用微服务</strong>的项目的<strong class="ki iu">起点。</strong></p><p id="4cbe" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要了解更多关于Kubernetes有一个正在进行的<strong class="ki iu"/><a class="ae kf" href="https://czakozoltan08.medium.com/stupid-simple-kubernetes-e509355fba3d" rel="noopener"><strong class="ki iu">愚蠢简单的Kubernetes</strong></a><strong class="ki iu"/>系列。</p><p id="1fde" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一个有趣的正在进行的系列是<strong class="ki iu">《愚蠢简单的AI》</strong>系列。前两篇可以在这里找到:Python中的<a class="ae kf" href="https://towardsdatascience.com/svm-and-kernel-svm-fed02bef1200" rel="noopener" target="_blank"> <strong class="ki iu"> SVM和内核SVM </strong> </a>和<a class="ae kf" href="https://towardsdatascience.com/knn-in-python-835643e2fb53" rel="noopener" target="_blank"><strong class="ki iu">KNN</strong></a>。</p><p id="91f1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">感谢您阅读本文！</strong></p></div><div class="ab cl nv nw hx nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="im in io ip iq"><p id="d236" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">成为媒介上的作家:</strong>【https://czakozoltan08.medium.com/membership】T2</p></div><div class="ab cl nv nw hx nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="im in io ip iq"><p id="bbae" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">我真的很喜欢咖啡，因为它给我精力去写更多的文章。如果你喜欢这篇文章，那么你可以给我买杯咖啡来表达你的欣赏和支持！</strong></p><figure class="lf lg lh li gt ju gh gi paragraph-image"><a href="https://ko-fi.com/zozoczako"><div class="gh gi oc"><img src="../Images/0f03dd542bf76f1125912312a7c936ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*bFjnvelnpwuYa4vfPMGkhA@2x.png"/></div></a></figure></div></div>    
</body>
</html>