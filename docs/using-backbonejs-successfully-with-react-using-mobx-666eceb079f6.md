# 通过 React 成功使用 BackboneJS(使用 MobX)

> 原文：<https://itnext.io/using-backbonejs-successfully-with-react-using-mobx-666eceb079f6?source=collection_archive---------7----------------------->

![](img/0a47390b217dc3de7cff32a82eb885c9.png)

在 Feathr，我们的主要前端应用程序是建立在牵线木偶和脊椎上的。因为我们的很多应用程序都是 CRUD，所以我们的应用程序中有大量的主干模型和集合。我们应用程序的基础围绕着这些模型和集合，所以我们所有的技术决策都必须牢记这一点。当引入一项新技术时，它要么必须与主干网配合良好，要么我们需要重写所有这些模型/集合来迎合这项新技术。大多数公司，无论规模大小，都没有足够的资源来进行繁重的重写，以适应新技术的使用。除非完全必要，否则我尽量避免开出完全重写的处方，而是建议朝着你的目标逐步改变。

我最近开始使用 React 在我们的应用程序中编写一个新特性，我很早就了解到，很难保持用 React 组件构建的视图与主干模型和集合同步。

## 快速复习——使用提线木偶的脊柱

在传统的主干/牵线木偶应用程序中，牵线木偶视图监听从模型和集合传播的事件。通常，您的视图中传递了一个特定的模型和/或集合，您可以监听这些对象上的事件来触发渲染周期。例如:

这个视图接受一个具有`height`和`width`属性的模型。为了让您的视图与您的模型保持同步，您特别将`change:width`和`change:height`列为您在传入的模型上监听的两个事件。当这些发生变化时，它会重新渲染整个视图。

## 使用 Backbone 和 React

在下面的例子中，我从上面重新创建了视图，但是使用 React 功能组件来呈现同一个视图。

一个立即变得明显的问题是，当模型传播事件时，视图将不会重新呈现。然而，这个视图是一个功能组件，可能不需要关心重新呈现——父组件可能会管理它。

如果这个组件需要根据模型的变化重新渲染呢？嗯，看起来应该是这样的:

这种方法有几个问题。其中最大的一个问题是，因为 React 组件不能像木偶`View`一样`listenTo`骨干事件，所以我们在模型上附加事件。这打破了 React 的核心概念之一，即你的视图不应该改变你的状态。

另一个问题是，我们需要明确地选择加入可能影响视图呈现的每一个事件。在上面的例子中，这很简单，但是在一个复杂的例子中，可能很难跟上。

## 尝试使用 Redux 将主干和反应粘合在一起

许多团队/项目已经采用 Redux 作为他们保持 React 视图与状态同步的首选方法。我自己已经在一些项目中使用了 Flux 模式，并且在可能的时候更喜欢使用它。话虽如此，用 Backbone 的 Redux 就是感觉不对。

首先，主干模型是可变的。当你用`react-redux`提供的`connect`函数装饰你的组件时，这真的很伤人。不能简单的从`mapStateToProps`回一个骨干模特，像这样:

如果您在模型上设置`height`或`width`，该模型在内存中仍然是相同的参考。这对于传统的主干应用程序来说非常重要，因为在这个模型上的任何事件都需要持久化。如果 Backbone 像`immutable`一样，在每次模型变异时都创建一个新的实例，这将是一个非常昂贵的交易。这带来的问题是，你的视图将不会正确地重新渲染，因为当视图决定是否需要重新渲染时，它会看到`previousState.model === state.model`而不会正确地重新渲染。

您可以在您的`mapStateToProps`中只传递需要的属性，但是这意味着每次您向您的模型添加一些东西时，您都需要将它添加到这个函数中。随着时间的推移，维护起来会有点麻烦。这也打开了一扇大门，让你的部分状态，你不应该映射到状态，这将导致时髦的和难以调试的错误在未来。

## 进入 MobX，我们问题的解决方案

在有了这些关于 React、Redux 和 Backbone 的问题之后，我开始探索新的选择。我探索的一个解决方案是`mobx`，仅仅经过一点修补，它似乎就能完美地用于我们的用例！

在传统的`mobx` powered React 应用程序中，状态和视图如下所示:

如果在`props`到`RectangleMobx`中传递一个`Rectangle`的实例，当`height`或`width`发生变化时，它会智能更新。

我开始思考“也许我可以使用`mobx`让我的 React 视图与我的主干模型保持同步？”。答案是，可以！看一下这个例子:

在这里，我用`observable`包装了模型的`attributes`，这将属性转换成一个[可观察对象](https://mobx.js.org/refguide/object.html)。现在我只需要在一个`render`函数中解引用一个属性，当模型改变时组件就会重新渲染！

这里唯一值得注意的是，我通过`rectangle.attributes.height`而不是`rectangle.get('height')`来引用属性。我还不确定`rectangle.get('height')`是否会以一种会导致组件重新呈现的方式取消对属性的引用，但这是值得尝试的。

现在，您有了一种简单的迁移方法，即使在已经严重依赖主干网的应用程序中也能做出反应！一如既往，让我知道你在评论中的想法！😃