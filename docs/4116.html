<html>
<head>
<title>Pulumi SDK — Key Concepts</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Pulumi SDK —关键概念</h1>
<blockquote>原文：<a href="https://itnext.io/getting-started-with-pulumi-sdk-22dc0b7ab83f?source=collection_archive---------3-----------------------#2020-04-29">https://itnext.io/getting-started-with-pulumi-sdk-22dc0b7ab83f?source=collection_archive---------3-----------------------#2020-04-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="7d7f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这篇文章是对Pulumi SDK的一些关键概念的总结。如果你也在使用Pulumi，我希望这篇文章的内容对你有用。</p><p id="e87c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最近，我完成了我的第一个<a class="ae ko" href="https://www.pulumi.com/" rel="noopener ugc nofollow" target="_blank"> Pulumi </a>程序，其中我使用Pulumi在Azure上提供一些资源。该程序管理一个具有3个私有子网的虚拟网络、一些通过可用性集分组并连接操作系统磁盘的私有虚拟机、一个L4 <a class="ae ko" href="https://docs.microsoft.com/en-us/azure/load-balancer/load-balancer-overview" rel="noopener ugc nofollow" target="_blank">负载平衡器</a>来处理外部HTTP流量，以及一个<a class="ae ko" href="https://azure.microsoft.com/en-ca/services/azure-bastion" rel="noopener ugc nofollow" target="_blank"> Azure Bastion </a>服务来实现安全的外部SSH访问。</p><p id="6a4c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是我的虚拟网络拓扑的样子:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi kp"><img src="../Images/ca2a49e4a4e9ba0d62ac94dbc086dd86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FdaTSbCRqczhwDpiRTlOdA.png"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">虚拟网络拓扑(<a class="ae ko" href="https://github.com/ihcsim/pulumi-azure" rel="noopener ugc nofollow" target="_blank">https://github.com/ihcsim/pulumi-azure</a>)</figcaption></figure><p id="fb21" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我将这篇文章分为以下几个部分:</p><ul class=""><li id="c264" class="lf lg it js b jt ju jx jy kb lh kf li kj lj kn lk ll lm ln bi translated">使用熟悉的编程语言</li><li id="92bc" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated">我们在哪里存储资源配置</li><li id="de73" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated">了解输入和输出类型</li><li id="9b80" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated">理解应用</li><li id="dea7" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated">单元测试我们的代码</li><li id="53a9" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated">结论</li></ul><h1 id="fb96" class="lt lu it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">使用熟悉的编程语言</h1><p id="ace1" class="pw-post-body-paragraph jq jr it js b jt mr jv jw jx ms jz ka kb mt kd ke kf mu kh ki kj mv kl km kn im bi translated">Pulumi允许我们用我们已经熟悉的编程语言(即Go)来表达我们的资源供应工作流。我们可以利用Go的内置结构，如模块、包、条件、循环、goroutines、通道、错误处理等。编写可读、可测试和可维护的代码。</p><p id="7985" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如，如果我们想要添加一组新的虚拟机，我们可以将新的规范附加到<a class="ae ko" href="https://github.com/ihcsim/pulumi-azure/blob/14845e52639dcb150a1f428cf81d89a99f492da3/Pulumi.dev.yaml#L188-L212" rel="noopener ugc nofollow" target="_blank">现有虚拟机配置</a>中。当前的<a class="ae ko" href="https://github.com/ihcsim/pulumi-azure/blob/14845e52639dcb150a1f428cf81d89a99f492da3/pkg/component/compute/compute.go#L55-L146" rel="noopener ugc nofollow" target="_blank">计算供应逻辑</a>已经知道如何通过Pulumi与Azure <code class="fe mw mx my mz b">compute</code> API交互，以确保新的虚拟机及其依赖关系得到相应的供应。如果需要向构造函数中添加新字段，只需更改一个代码点。如果我们新添加的不正确，虚拟机<a class="ae ko" href="https://github.com/ihcsim/pulumi-azure/blob/14845e52639dcb150a1f428cf81d89a99f492da3/pkg/component/compute/compute_test.go#L14-L91" rel="noopener ugc nofollow" target="_blank">单元测试</a>可以快速发现这些问题。</p><p id="3ff2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以不需要学习新的DSL👍👍！</p><h1 id="4441" class="lt lu it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">我们在哪里存储资源配置</h1><p id="ef40" class="pw-post-body-paragraph jq jr it js b jt mr jv jw jx ms jz ka kb mt kd ke kf mu kh ki kj mv kl km kn im bi translated">许多现有的<a class="ae ko" href="https://github.com/pulumi/examples" rel="noopener ugc nofollow" target="_blank">示例</a>显示了资源配置(例如，子网CIDR、端口号、管理凭证等。)可以内联在<code class="fe mw mx my mz b">main</code>程序中。</p><p id="da8a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如，以下代码片段创建了一个包含两个子网的Azure虚拟网络:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="na nb l"/></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">使用内联配置值创建子网</figcaption></figure><p id="88d0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这种方法的明显局限性是，复制粘贴代码的数量会随着子网数量的增加而增加。此外，机密在代码中以纯文本的形式公开。</p><p id="16a6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">由于程序是用Go编写的，我们可以使用一个简单的<code class="fe mw mx my mz b">for</code>循环来干燥代码:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="na nb l"/></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">干燥子网配置代码</figcaption></figure><p id="1c14" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是第二行的<code class="fe mw mx my mz b">subnetInputs</code>片从何而来？该片的创建将涉及从配置源读取子网配置，无论源在哪里。</p><p id="c7a6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">虽然有一些地方可以作为资源配置源，但是在搜索了Pulumi的文档和<em class="nc"> Slack </em>历史之后，看起来<a class="ae ko" href="https://www.pulumi.com/docs/intro/concepts/stack/" rel="noopener ugc nofollow" target="_blank"> stack </a>配置是一个合理的选择。</p><blockquote class="nd ne nf"><p id="2430" class="jq jr nc js b jt ju jv jw jx jy jz ka ng kc kd ke nh kg kh ki ni kk kl km kn im bi translated">📝栈是一个独立的、可独立配置的Pulumi程序实例。</p></blockquote><p id="fd0f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">可以通过<a class="ae ko" href="https://www.pulumi.com/docs/intro/concepts/config/#config-stack" rel="noopener ugc nofollow" target="_blank"> Pulumi CLI或SDK </a>将新配置添加到堆栈中。此外，<a class="ae ko" href="https://www.pulumi.com/docs/intro/concepts/config/#structured-configuration" rel="noopener ugc nofollow" target="_blank">结构化配置</a>可用于以连贯的方式组织配置。</p><p id="17ae" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如，我们可以以合理的方式构建子网配置，并使用以下命令将它们添加到<code class="fe mw mx my mz b">dev</code>堆栈中:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="na nb l"/></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">将子网配置添加到堆栈</figcaption></figure><blockquote class="nd ne nf"><p id="f65c" class="jq jr nc js b jt ju jv jw jx jy jz ka ng kc kd ke nh kg kh ki ni kk kl km kn im bi translated">📝堆栈的配置存储在Pulumi- <stack>中。yaml文件。</stack></p></blockquote><p id="7f1f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要将堆栈配置读入Pulumi程序，我们可以使用<code class="fe mw mx my mz b"><a class="ae ko" href="https://godoc.org/github.com/pulumi/pulumi/sdk/go/pulumi/config" rel="noopener ugc nofollow" target="_blank">config</a></code> <a class="ae ko" href="https://godoc.org/github.com/pulumi/pulumi/sdk/go/pulumi/config" rel="noopener ugc nofollow" target="_blank">包</a>中的API。<code class="fe mw mx my mz b">pulumi.TryObject()</code>功能可用于水合自定义<code class="fe mw mx my mz b">SubnetInput</code>类型，如下所示:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="na nb l"/></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">使用“pulumi . try object”API来合并SubnetInput对象</figcaption></figure><p id="ea9e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了保护敏感数据，可以通过使用<code class="fe mw mx my mz b">--secret</code>标志将它们标记为机密来加密配置。如果嵌套字段被标记为机密，则整个所属资源配置将被加密。</p><p id="c156" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如，我的<code class="fe mw mx my mz b">OSProfile</code>和<code class="fe mw mx my mz b">OSProfileLinux</code>配置在状态记录中显示为加密的，因为它们的一些<a class="ae ko" href="https://github.com/ihcsim/pulumi-azure/blob/14845e52639dcb150a1f428cf81d89a99f492da3/Pulumi.dev.yaml#L133-L151" rel="noopener ugc nofollow" target="_blank">字段</a>被标记为机密。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi nj"><img src="../Images/018eff3a19e4beaec0468a2b0903c5da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*62P8kxQzMDl7bFALyT6FEg.png"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">Pulumi控制台中显示的加密状态</figcaption></figure><p id="91ad" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，通过将相关部分复制到新堆栈的YAML文件中，将资源配置存储在堆栈中使我们能够在另一个堆栈中重用它们。</p><blockquote class="nd ne nf"><p id="611e" class="jq jr nc js b jt ju jv jw jx jy jz ka ng kc kd ke nh kg kh ki ni kk kl km kn im bi translated">⚠️由于Pulumi使用每个栈的加密密钥来加密秘密，所以不可能在不同的栈中重用秘密。更多信息见本<a class="ae ko" href="https://github.com/pulumi/pulumi/issues/1583" rel="noopener ugc nofollow" target="_blank">问题</a>。</p></blockquote><h1 id="a4a3" class="lt lu it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">了解输入和输出类型</h1><p id="9ca1" class="pw-post-body-paragraph jq jr it js b jt mr jv jw jx ms jz ka kb mt kd ke kf mu kh ki kj mv kl km kn im bi translated"><code class="fe mw mx my mz b"><a class="ae ko" href="https://godoc.org/github.com/pulumi/pulumi/sdk/go/pulumi" rel="noopener ugc nofollow" target="_blank">pulumi</a></code> <a class="ae ko" href="https://godoc.org/github.com/pulumi/pulumi/sdk/go/pulumi" rel="noopener ugc nofollow" target="_blank">包</a>定义了一个非常全面的<code class="fe mw mx my mz b">Input</code>和<code class="fe mw mx my mz b">Output</code>类型列表。对于新用户来说，理解这些类型的正确用法是很重要的。例如，共有17个<code class="fe mw mx my mz b">string</code>相关的<code class="fe mw mx my mz b">Input</code>和<code class="fe mw mx my mz b">Output</code>类型。</p><p id="765b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">看了很多例子后，我想我明白了…🤔</p><p id="42d5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">记住，</p><blockquote class="nd ne nf"><p id="1888" class="jq jr nc js b jt ju jv jw jx jy jz ka ng kc kd ke nh kg kh ki ni kk kl km kn im bi translated">📝<code class="fe mw mx my mz b">Input</code>类型在构造函数中用作创建和更新资源的参数。</p><p id="bf4d" class="jq jr nc js b jt ju jv jw jx jy jz ka ng kc kd ke nh kg kh ki ni kk kl km kn im bi translated">📝<code class="fe mw mx my mz b">Output</code>类型在结构中显示为导出字段，以便程序的其他部分可以使用它们。类似于<a class="ae ko" href="https://en.wikipedia.org/wiki/Futures_and_promises" rel="noopener ugc nofollow" target="_blank">的工作承诺</a>，一旦拥有的资源被完全提供，最初未知的资源属性将变得可用。</p></blockquote><p id="c1d7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">此外，</p><blockquote class="nd ne nf"><p id="da0e" class="jq jr nc js b jt ju jv jw jx jy jz ka ng kc kd ke nh kg kh ki ni kk kl km kn im bi translated">📝<code class="fe mw mx my mz b">Output</code>类型用于建立资源之间的依赖关系。</p></blockquote><p id="b15e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以<code class="fe mw mx my mz b"><a class="ae ko" href="https://godoc.org/github.com/pulumi/pulumi-azure/sdk/go/azure/compute#VirtualMachine" rel="noopener ugc nofollow" target="_blank">compute.VirtualMachine</a></code>类型为例，<code class="fe mw mx my mz b"><a class="ae ko" href="https://godoc.org/github.com/pulumi/pulumi-azure/sdk/go/azure/compute#NewVirtualMachine" rel="noopener ugc nofollow" target="_blank">compute.NewVirtualMachine()</a></code>构造函数接受一个<code class="fe mw mx my mz b"><a class="ae ko" href="https://godoc.org/github.com/pulumi/pulumi-azure/sdk/go/azure/compute#VirtualMachineArgs" rel="noopener ugc nofollow" target="_blank">compute.VirtualMachineArgs</a></code>参数:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="na nb l"/></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">虚拟机构造函数的输入参数</figcaption></figure><p id="5405" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">注意，<code class="fe mw mx my mz b">compute.VirtualMachineArgs</code>结构中的所有字段都是某种形式的<code class="fe mw mx my mz b">Input</code>类型。<strong class="js iu">这些是您提供给构造器以创建虚拟机的输入字段。</strong></p><p id="af3d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们检查<code class="fe mw mx my mz b">compute.VirtualMachine</code>结构，我们可以看到它的所有导出字段都是<code class="fe mw mx my mz b">Output</code>类型:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="na nb l"/></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">虚拟机结构的输出字段</figcaption></figure><p id="663a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这些是输出字段，程序的其他部分可以使用它们来创建下游资源。</p><p id="69ab" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们再深入一点…</p><p id="495d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">请注意，<code class="fe mw mx my mz b">compute.VirtualMachineArgs</code>结构的<code class="fe mw mx my mz b">OsProfile</code>字段属于类型<code class="fe mw mx my mz b">VirtualMachineOsProfilePtrInput</code>类型，这是一个Go接口:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="na nb l"/></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">VirtualMachineOsProfilePtrInput接口</figcaption></figure><p id="9374" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通过搜索<code class="fe mw mx my mz b">compute</code>包文档，发现以下类型实现了<code class="fe mw mx my mz b">compute.VirtualMachineOsProfilePtrInput</code>接口:</p><ul class=""><li id="719f" class="lf lg it js b jt ju jx jy kb lh kf li kj lj kn lk ll lm ln bi translated"><code class="fe mw mx my mz b">compute.VirtualMachineOsProfileArgs</code></li><li id="780d" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated"><code class="fe mw mx my mz b">compute.VirtualMachineOsProfileOutput</code></li><li id="ff8d" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated"><code class="fe mw mx my mz b">compute.VirtualMachineOsProfilePtrOutput</code></li></ul><p id="c4c2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">😱 😱 😱迷惑？其实也没那么糟糕…</p><p id="9921" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">记住，</p><blockquote class="nd ne nf"><p id="3efe" class="jq jr nc js b jt ju jv jw jx jy jz ka ng kc kd ke nh kg kh ki ni kk kl km kn im bi translated">📝一个<code class="fe mw mx my mz b">Args</code>结构由<code class="fe mw mx my mz b">Input</code>字段组成，这些字段是Go接口。<code class="fe mw mx my mz b">Input</code>类型通常由其他<code class="fe mw mx my mz b">Args</code>或<code class="fe mw mx my mz b">Output</code>类型实现。这些字段可以被赋予原始类型的值，如<code class="fe mw mx my mz b">pulumi.String</code>、<code class="fe mw mx my mz b">pulumi.Bool</code>、<code class="fe mw mx my mz b">pulumi.Int</code>等。，或来自其他资源的<code class="fe mw mx my mz b">Output</code>类型。</p></blockquote><p id="01a9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你想知道一个类型的底层类型，查看它的<code class="fe mw mx my mz b">ElementType()</code>方法。举个例子，</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="na nb l"/></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">OSProfile参数和输出ElementType()方法</figcaption></figure><p id="13b3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们将这些知识应用到前面的<code class="fe mw mx my mz b">VirtualMachine</code>和<code class="fe mw mx my mz b">OSProfile</code>例子中:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="na nb l"/></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">使用提供的操作系统配置文件参数创建新的虚拟机</figcaption></figure><p id="9c59" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">由于<code class="fe mw mx my mz b">compute.VirtualMachineOsProfile</code>没有构造函数，我们可以直接创建<code class="fe mw mx my mz b">compute.VirtualMachineOsProfileArgs</code>，并将其传递给<code class="fe mw mx my mz b">compute.VirtualMachineArgs</code>的一个实例。然后，<code class="fe mw mx my mz b">compute.VirtualMachineArgs</code>实例成为传递给<code class="fe mw mx my mz b">NewVirtualMachine()</code>构造函数的参数。</p><p id="193f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果排序很重要，那么可以使用<code class="fe mw mx my mz b">VirtualOsProfileArgs.ToVirtualMachineOsProfileOutput()</code>方法将<code class="fe mw mx my mz b">VirtualOsProfileArgs</code>实例转换成<code class="fe mw mx my mz b">VirtualOsProfileOutput</code>实例。当直接传递给<code class="fe mw mx my mz b">VirtualMachineArgs</code>实例时，<code class="fe mw mx my mz b">VirtualOsProfileOutput</code>在虚拟机和操作系统配置文件资源之间建立依赖关系。</p><p id="e330" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">希望这有助于弄清楚如何使用<code class="fe mw mx my mz b">Input</code>和<code class="fe mw mx my mz b">Output</code>类型。</p><h1 id="2cec" class="lt lu it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">理解应用</h1><p id="38ab" class="pw-post-body-paragraph jq jr it js b jt mr jv jw jx ms jz ka kb mt kd ke kf mu kh ki kj mv kl km kn im bi translated">因为<code class="fe mw mx my mz b">Output</code>的工作像<a class="ae ko" href="https://en.wikipedia.org/wiki/Futures_and_promises" rel="noopener ugc nofollow" target="_blank">承诺</a>，像条件和循环这样的普通结构对它们不起作用。</p><p id="0ce5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">假设我们想从虚拟网络拥有的子网列表中找到一个子网:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="na nb l"/></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">无法迭代子网输出列表</figcaption></figure><p id="5f3d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第21行的<code class="fe mw mx my mz b">for</code>循环不起作用，因为我们不能迭代<code class="fe mw mx my mz b">network.VirtualNetworkSubnetArrayOutput</code>类型。</p><p id="84cf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这就是<code class="fe mw mx my mz b"><a class="ae ko" href="https://godoc.org/github.com/pulumi/pulumi/sdk/go/pulumi#OutputState.Apply" rel="noopener ugc nofollow" target="_blank">OutputState.Apply(applier func(interface{}) (interface{}, error))</a></code>方法及其兄弟方法的用武之地。当相关的<code class="fe mw mx my mz b">Output</code>字段的值可用时，Pulumi将调用<code class="fe mw mx my mz b">applier</code>回调函数。</p><p id="11b6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们想找到逻辑名为<code class="fe mw mx my mz b">subnet-00</code>的子网的ID，我们可以这样做:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="na nb l"/></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">使用OutputState。ApplyString()获取最初未知的子网ID</figcaption></figure><blockquote class="nd ne nf"><p id="9b23" class="jq jr nc js b jt ju jv jw jx jy jz ka ng kc kd ke nh kg kh ki ni kk kl km kn im bi translated">⚠️由<code class="fe mw mx my mz b">OutputState.ApplyString()</code>方法返回的<code class="fe mw mx my mz b">subnetID</code>是<code class="fe mw mx my mz b">pulumi.StringOutput</code>的类型，而不是<code class="fe mw mx my mz b">string</code>。</p></blockquote><p id="c2ee" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mw mx my mz b">applier</code>回调函数可以有以下两种格式之一:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="na nb l"/></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">应用程序函数签名</figcaption></figure><p id="2815" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">类型<code class="fe mw mx my mz b">U</code>必须可从调用<code class="fe mw mx my mz b">applier</code>的<code class="fe mw mx my mz b">Output</code>的<code class="fe mw mx my mz b">ElementType</code>分配。在上例中， <code class="fe mw mx my mz b"><a class="ae ko" href="https://github.com/pulumi/pulumi-azure/blob/a1fe3c6965c7696327847be477acd70e6999b5a9/sdk/go/azure/network/pulumiTypes.go#L10146-L10148" rel="noopener ugc nofollow" target="_blank">virtualNetwork.Subnets</a></code>的<code class="fe mw mx my mz b"><a class="ae ko" href="https://github.com/pulumi/pulumi-azure/blob/a1fe3c6965c7696327847be477acd70e6999b5a9/sdk/go/azure/network/pulumiTypes.go#L10146-L10148" rel="noopener ugc nofollow" target="_blank">ElementType</a></code> <a class="ae ko" href="https://github.com/pulumi/pulumi-azure/blob/a1fe3c6965c7696327847be477acd70e6999b5a9/sdk/go/azure/network/pulumiTypes.go#L10146-L10148" rel="noopener ugc nofollow" target="_blank">是与<code class="fe mw mx my mz b">subnets</code>参数类型相匹配的<code class="fe mw mx my mz b">[]network.VirtualNetworkSubnet</code>。如果我们使用<code class="fe mw mx my mz b">ApplyString()</code>，自然<code class="fe mw mx my mz b">T</code>就是<code class="fe mw mx my mz b">string</code>类型。</a></p><p id="91c9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">关于<code class="fe mw mx my mz b">OutputState.Apply()</code>方法要知道的最后一件事是，它是非阻塞的。查看我的<a class="ae ko" href="https://github.com/ihcsim/pulumi-azure/blob/f641b93d5d77d359581e5d25e2d6d2284f40a8c5/pkg/component/network/network_test.go#L39-L98" rel="noopener ugc nofollow" target="_blank">单元测试</a>，看看我如何利用Go的<code class="fe mw mx my mz b">sync.WaitGroup</code>来确保<code class="fe mw mx my mz b">applier</code>函数在比较测试结果之前返回。</p><h1 id="05d0" class="lt lu it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">单元测试我们的代码</h1><p id="82b5" class="pw-post-body-paragraph jq jr it js b jt mr jv jw jx ms jz ka kb mt kd ke kf mu kh ki kj mv kl km kn im bi translated">这篇文章将总结一个技巧来覆盖由<code class="fe mw mx my mz b">pulumi.WithMocks()</code>函数生成的默认<code class="fe mw mx my mz b">pulumi.RunInfo</code>元数据对象。</p><p id="e371" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有许多<a class="ae ko" href="https://www.pulumi.com/docs/guides/testing/unit/" rel="noopener ugc nofollow" target="_blank">单元测试示例</a>展示了如何通过将<code class="fe mw mx my mz b">pulumi.WithMocks()</code>函数的返回值传递给<code class="fe mw mx my mz b">pulumi.RunErr()</code>函数，用模拟来伪造Pulumi的资源供应逻辑。</p><p id="cbaa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个默认模拟的主要限制是只有少量的元数据被设置。特别是，存储所有堆栈配置的<code class="fe mw mx my mz b">Config</code>映射仍然为空。因为我们所有的资源配置都存储在堆栈中，所以我们需要一种用模拟数据填充<code class="fe mw mx my mz b">Config</code>地图的方法。否则，任何对<code class="fe mw mx my mz b">pulumi.TryObject()</code>函数的调用都会在单元测试中失败。</p><p id="b850" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面的代码片段展示了我们如何使用一个自定义函数来覆盖传递给<code class="fe mw mx my mz b">pulumi.Run()</code>函数的<code class="fe mw mx my mz b">pulumi.RunInfo</code>元数据对象:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="na nb l"/></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">将配置注入RunInfo结构</figcaption></figure><h1 id="3622" class="lt lu it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">结论</h1><p id="fc28" class="pw-post-body-paragraph jq jr it js b jt mr jv jw jx ms jz ka kb mt kd ke kf mu kh ki kj mv kl km kn im bi translated">在这篇文章中，我分享了我使用Pulumi的Go SDK的“入门”经验。我们可以利用熟悉的编程语言在Pulumi程序中表达我们的资源供应工作流。这些语言提供的内置结构帮助我们编写可测试和可维护的代码。第一眼看上去，<code class="fe mw mx my mz b">Input</code>和<code class="fe mw mx my mz b">Output</code>类型的综合列表可能会让人不知所措。要记住的关键是<code class="fe mw mx my mz b">Input</code>类型被用作资源构造函数的参数来创建和更新资源。<code class="fe mw mx my mz b">Output</code>类型确保资源属性最终可供程序的其余部分使用。当一个资源<code class="fe mw mx my mz b">Output</code>在另一个资源构造器中被用作<code class="fe mw mx my mz b">Input</code>时，它在两个资源之间建立了依赖关系。<code class="fe mw mx my mz b">pulumi.Apply()</code>及其所有兄弟函数允许我们操作<code class="fe mw mx my mz b">Output</code>类型的异步原始值。围绕应用程序交付的内容是未来帖子的潜在素材。</p></div></div>    
</body>
</html>