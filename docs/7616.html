<html>
<head>
<title>Raspberry Pi Cluster Emulation With Docker Compose</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Docker Compose进行树莓Pi集群仿真</h1>
<blockquote>原文：<a href="https://itnext.io/raspberry-pi-cluster-emulation-with-docker-compose-2d5583cd645?source=collection_archive---------0-----------------------#2022-11-25">https://itnext.io/raspberry-pi-cluster-emulation-with-docker-compose-2d5583cd645?source=collection_archive---------0-----------------------#2022-11-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="fa7a" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">码头深水潜水</h2><div class=""/><div class=""><h2 id="bb6c" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">不含SD卡</h2></div><h1 id="5f09" class="kr ks it bd kt ku kv kw kx ky kz la lb ki lc kj ld kl le km lf ko lg kp lh li bi translated">TL；速度三角形定位法(dead reckoning)</h1><p id="37ec" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">本指南讨论了使用QEMU、Docker、Docker Compose和Ansible模拟一个简单、可伸缩、完全二进制兼容的Raspberry Pi集群(在云中或其他地方)所需的一切。有关更新的代码和其他细节，请参见GitHub上的<a class="ae mf" href="https://github.com/mrhavens/pidoc" rel="noopener ugc nofollow" target="_blank"> pidoc </a>库。</p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div class="gh gi mg"><img src="../Images/49272232555662fee15b63d880897d01.png" data-original-src="https://miro.medium.com/v2/resize:fit:856/format:webp/1*90FHXuLs1lfWJttIwPLMIw.png"/></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">作者图片</figcaption></figure><h1 id="af15" class="kr ks it bd kt ku kv kw kx ky kz la lb ki lc kj ld kl le km lf ko lg kp lh li bi translated">介绍</h1><p id="11b6" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">Raspberry Pi不再只是一个供学生学习计算的低成本平台，它现在是一个合法的研发平台，用于物联网、网络、分布式系统和软件开发。它甚至在生产环境中被管理性地使用。</p><p id="dba6" class="pw-post-body-paragraph lj lk it ll b lm ms kd lo lp mt kg lr ls mu lu lv lw mv ly lz ma mw mc md me im bi translated">在2012年第一个Raspberry Pi发布后不久，一些公司开始将它们构建成低成本集群，通常是为了研究和测试目的。<a class="ae mf" href="https://www.datastax.com/" rel="noopener ugc nofollow" target="_blank"> DataStax </a>的实习生建立了一个多数据中心，32个节点<a class="ae mf" href="https://cassandra.apache.org/" rel="noopener ugc nofollow" target="_blank"> Cassenda </a>容错演示，配有一个大红色按钮来模拟整个数据中心的故障。David Guill 构建了一个<a class="ae mf" href="https://web.archive.org/web/20180816070042/http://likemagicappears.com/projects/raspberry-pi-cluster/" rel="noopener ugc nofollow" target="_blank"> 40节点的Raspberry Pi集群</a>，这是他的MSCE论文的一部分。<a class="ae mf" href="https://www.balena.io/" rel="noopener ugc nofollow" target="_blank"> Balena </a>，构建了“<a class="ae mf" href="https://www.balena.io/blog/what-would-you-do-with-a-120-raspberry-pi-cluster/" rel="noopener ugc nofollow" target="_blank"> The Beast </a>”，一个120节点的Raspberry Pi集群，用于其在线平台的规模测试。在光谱的极端，甲骨文构建了一个<a class="ae mf" href="https://www.servethehome.com/oracle-shows-1060-raspberry-pi-supercomputer-at-oow/" rel="noopener ugc nofollow" target="_blank"> 1060节点的Raspberry Pi集群</a>，他们在甲骨文全球大会2019上推出了该集群。</p><p id="90ba" class="pw-post-body-paragraph lj lk it ll b lm ms kd lo lp mt kg lr ls mu lu lv lw mv ly lz ma mw mc md me im bi translated">随着Raspberry Pi被应用于从wi-fi扩展器到安全摄像头，甚至更大的集群，其创新仍在继续。虽然这些集群的主要价值在于它们的规模和低成本，但它们的普及使它们成为越来越常见的开发平台。由于Raspberry Pi使用ARM处理器，这可能会给我们这些专门在云中工作的人带来开发问题。虽然存在商业解决方案，但我们将使用托管在Google Compute Engine上的完全开源的堆栈来构建我们自己的仿真集群。</p><h1 id="5618" class="kr ks it bd kt ku kv kw kx ky kz la lb ki lc kj ld kl le km lf ko lg kp lh li bi translated">用例</h1><p id="a575" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">除了从经验中学习之外，将一个仿真的Raspberry Pi编写成Dockerizing使我们能够做三件事。第一，它变成了软件，否则它将是一个没有人需要记住随身携带的纯硬件设备(我总是丢失外围电缆)。第二，它使Docker能够为Pi做Docker在其他方面做得最好的事情:它使软件可移植、易于管理、易于复制。第三，它不占用物理空间。如果我们可以用Docker构建一个树莓Pi，我们就可以构建许多。如果我们能建造很多，我们可以把它们都连接起来。虽然我们可能会遇到一些限制，但这个构建将模拟一个Raspberry Pi 1s集群，该集群在逻辑上等同于一个简单的多节点物理集群。</p><h1 id="97ae" class="kr ks it bd kt ku kv kw kx ky kz la lb ki lc kj ld kl le km lf ko lg kp lh li bi translated">仿真硬件架构</h1><p id="ad02" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">虽然技术上不完全相同，但是我们将使用的仿真软件QEMU提供了一个与Raspberry Pi 1大致兼容的<code class="fe mx my mz na b">ARM-Versatile</code>架构。为了让它能够与Raspbian一起正常工作，对内核进行一些修改是必要的，但对于我们的目的来说，这是可用的更稳定的开源解决方案之一。</p><pre class="mh mi mj mk gt nb na nc bn nd ne bi"><span id="4cb1" class="nf ks it na b be ng nh l ni nj">pi@raspberrypi:~$ cat /proc/cpuinfo <br/>processor       : 0<br/>model name      : ARMv6-compatible processor rev 7 (v6l)<br/>BogoMIPS        : 577.53<br/>Features        : half thumb fastmult vfp edsp java tls<br/>CPU implementer : 0x41<br/>CPU architecture: 7<br/>CPU variant     : 0x0<br/>CPU part        : 0xb76<br/>CPU revision    : 7<br/><br/>Hardware        : ARM-Versatile (Device Tree Support)<br/>Revision        : 0000<br/>Serial          : 0000000000000000</span></pre><p id="4413" class="pw-post-body-paragraph lj lk it ll b lm ms kd lo lp mt kg lr ls mu lu lv lw mv ly lz ma mw mc md me im bi translated">与实际的Raspberry Pi 1相比，它们几乎完全相同:</p><pre class="mh mi mj mk gt nb na nc bn nd ne bi"><span id="3a6e" class="nf ks it na b be ng nh l ni nj">pi@raspberrypi:~ $ cat /proc/cpuinfo<br/>processor	: 0<br/>model name	: ARMv6-compatible processor rev 7 (v6l)<br/>BogoMIPS	: 697.95<br/>Features	: half thumb fastmult vfp edsp java tls <br/>CPU implementer	: 0x41<br/>CPU architecture: 7<br/>CPU variant	: 0x0<br/>CPU part	: 0xb76<br/>CPU revision	: 7<br/><br/>Hardware : BCM2835<br/>Revision : 000d<br/>Serial  : 000000003d9a54c5</span></pre><h1 id="9bc5" class="kr ks it bd kt ku kv kw kx ky kz la lb ki lc kj ld kl le km lf ko lg kp lh li bi translated">背景</h1><h2 id="7544" class="nk ks it bd kt nl nm dn kx nn no dp lb ls np nq ld lw nr ns lf ma nt nu lh iz bi translated">QEMU是什么？</h2><p id="5fb6" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">QEMU 是一个处理器仿真器。它支持许多不同的处理器，但我们唯一感兴趣的是能够毫无困难地运行Raspberry Pi映像的东西。在这种情况下，我们将使用QEMU 4.2.0，它支持ARM11指令集，与Raspberry Pi 1和Zero上的Broadcom BCM2835 (ARM1176JZFS)芯片兼容。我们将在QEMU上使用ARM1176支持，这将允许我们或多或少地模拟一个Raspberry Pi 1。我说或多或少是因为我们仍然需要使用一个定制的Raspbian内核，以便在仿真硬件上引导。QEMU对Pi的支持仍在开发中，所以我们让它在这里工作的方法只是一个聪明的黑客，从CPU利用率的角度来看，它决不会是最优的或高效的。</p><h2 id="a225" class="nk ks it bd kt nl nm dn kx nn no dp lb ls np nq ld lw nr ns lf ma nt nu lh iz bi translated">QEMU特性</h2><p id="231a" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">QEMU支持Docker中的许多相同特性，但是，它可以在没有主机内核驱动程序的情况下运行完整的软件仿真。这意味着它可以在Docker或任何其他虚拟机中运行，而无需主机虚拟化支持。QEMU特性列表非常广泛，学习曲线也非常陡峭。但是，我们在此版本中将重点关注的主要功能是主机端口转发，以便数据可以传递到主机。</p><h2 id="e0ed" class="nk ks it bd kt nl nm dn kx nn no dp lb ls np nq ld lw nr ns lf ma nt nu lh iz bi translated">Dockerized QEMU</h2><p id="8d17" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">Docker的优势之一是它不处理成熟的虚拟化，而是依赖于主机系统的架构。由于我们的主机系统将运行英特尔处理器，我们不能指望Docker自己处理ARM操作。因此，我们将把QEMU放在Docker容器中。由于Docker被设计为以接近本机的性能运行软件，因此运营效率的挑战将来自QEMU本身。另一方面，QEMU完全用软件支持机器架构的仿真。这样做的好处是，它可以在任何虚拟化系统或容器中运行，与其系统架构无关。如果有耐心，我们甚至可以在另一个dockered Raspberry Pi容器中运行一个dockered Raspberry Pi容器。QEMU的缺点是，与其他类型的虚拟化相比，它的性能相对较差。但是，我们可以通过利用QEMU的ARM仿真，同时依赖Docker来处理其他所有事情，从而从两个世界中获益。</p><h2 id="e3e2" class="nk ks it bd kt nl nm dn kx nn no dp lb ls np nq ld lw nr ns lf ma nt nu lh iz bi translated">拉斯比安</h2><p id="bc49" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">基于Debian，<a class="ae mf" href="https://www.raspbian.org/" rel="noopener ugc nofollow" target="_blank"> Raspbian </a>是一个流行的、受到良好支持的Raspberry Pi操作系统，也是该平台最常推荐的操作系统之一。<a class="ae mf" href="https://www.raspberrypi.org/forums/viewforum.php?f=66" rel="noopener ugc nofollow" target="_blank">社区</a>非常活跃，管理良好。</p><h2 id="0433" class="nk ks it bd kt nl nm dn kx nn no dp lb ls np nq ld lw nr ns lf ma nt nu lh iz bi translated">物理树莓Pi速度比较</h2><p id="aa9a" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">以下测试旨在作为比较我们的虚拟化系统的基准。因为我们将模拟单核，所以这些测试只是单核、单线程的，不管架构中包含多少物理内核。</p><h2 id="ccfb" class="nk ks it bd kt nl nm dn kx nn no dp lb ls np nq ld lw nr ns lf ma nt nu lh iz bi translated">树莓Pi 1 2011年1 2月</h2><pre class="mh mi mj mk gt nb na nc bn nd ne bi"><span id="2755" class="nf ks it na b be ng nh l nv nj">Test execution summary:<br/>    total time:                          330.5514s<br/>    total number of events:              10000<br/>    total time taken by event execution: 330.5002<br/>    per-request statistics:<br/>         min:                                 32.92ms<br/>         avg:                                 33.05ms<br/>         max:                                 40.94ms<br/>         approx.  95 percentile:              33.24ms<br/><br/>Threads fairness:<br/>    events (avg/stddev):           10000.0000/0.00<br/>    execution time (avg/stddev):   330.5002/0.00</span></pre><h2 id="09a0" class="nk ks it bd kt nl nm dn kx nn no dp lb ls np nq ld lw nr ns lf ma nt nu lh iz bi translated">树莓Pi 1 A+2014v 1.1</h2><pre class="mh mi mj mk gt nb na nc bn nd ne bi"><span id="d732" class="nf ks it na b be ng nh l nv nj">Test execution summary:<br/>    total time:                          328.7505s<br/>    total number of events:              10000<br/>    total time taken by event execution: 328.6931<br/>    per-request statistics:<br/>         min:                                 32.71ms<br/>         avg:                                 32.87ms<br/>         max:                                 78.93ms<br/>         approx.  95 percentile:              33.03ms<br/><br/>Threads fairness:<br/>    events (avg/stddev):           10000.0000/0.00<br/>    execution time (avg/stddev):   328.6931/0.00</span></pre><h2 id="5cb1" class="nk ks it bd kt nl nm dn kx nn no dp lb ls np nq ld lw nr ns lf ma nt nu lh iz bi translated">树莓派零度W v1.1 2017</h2><pre class="mh mi mj mk gt nb na nc bn nd ne bi"><span id="0cd6" class="nf ks it na b be ng nh l nv nj">Test execution summary:<br/>    total time:                          228.2025s<br/>    total number of events:              10000<br/>    total time taken by event execution: 228.1688<br/>    per-request statistics:<br/>         min:                                 22.76ms<br/>         avg:                                 22.82ms<br/>         max:                                 35.29ms<br/>         approx.  95 percentile:              22.94ms<br/><br/>Threads fairness:<br/>    events (avg/stddev):           10000.0000/0.00<br/>    execution time (avg/stddev):   228.1688/0.00</span></pre><h2 id="8549" class="nk ks it bd kt nl nm dn kx nn no dp lb ls np nq ld lw nr ns lf ma nt nu lh iz bi translated">树莓Pi 2型号B v1.1</h2><pre class="mh mi mj mk gt nb na nc bn nd ne bi"><span id="b26d" class="nf ks it na b be ng nh l nv nj">Test execution summary:<br/>    total time:                          224.9052s<br/>    total number of events:              10000<br/>    total time taken by event execution: 224.8738<br/>    per-request statistics:<br/>         min:                                 22.20ms<br/>         avg:                                 22.49ms<br/>         max:                                 32.85ms<br/>         approx.  95 percentile:              22.81ms<br/><br/>Threads fairness:<br/>    events (avg/stddev):           10000.0000/0.00<br/>    execution time (avg/stddev):   224.8738/0.00</span></pre><h2 id="558b" class="nk ks it bd kt nl nm dn kx nn no dp lb ls np nq ld lw nr ns lf ma nt nu lh iz bi translated">树莓Pi 3型号B v1.2 2015</h2><pre class="mh mi mj mk gt nb na nc bn nd ne bi"><span id="9443" class="nf ks it na b be ng nh l nv nj">Test execution summary:<br/>    total time:                          139.6140s<br/>    total number of events:              10000<br/>    total time taken by event execution: 139.6087<br/>    per-request statistics:<br/>         min:                                 13.94ms<br/>         avg:                                 13.96ms<br/>         max:                                 34.06ms<br/>         approx.  95 percentile:              13.96ms<br/><br/>Threads fairness:<br/>    events (avg/stddev):           10000.0000/0.00<br/>    execution time (avg/stddev):   139.6087/0.00</span></pre><h2 id="cdc2" class="nk ks it bd kt nl nm dn kx nn no dp lb ls np nq ld lw nr ns lf ma nt nu lh iz bi translated">树莓Pi 4 B 2018</h2><pre class="mh mi mj mk gt nb na nc bn nd ne bi"><span id="f448" class="nf ks it na b be ng nh l nv nj">Test execution summary:<br/>    total time:                          92.6405s<br/>    total number of events:              10000<br/>    total time taken by event execution: 92.6338<br/>    per-request statistics:<br/>         min:                                  9.22ms<br/>         avg:                                  9.26ms<br/>         max:                                 23.50ms<br/>         approx.  95 percentile:               9.27ms<br/><br/>Threads fairness:<br/>    events (avg/stddev):           10000.0000/0.00<br/>    execution time (avg/stddev):   92.6338/0.00</span></pre><h1 id="4b5c" class="kr ks it bd kt ku kv kw kx ky kz la lb ki lc kj ld kl le km lf ko lg kp lh li bi translated">项目要求</h1><h2 id="2cb4" class="nk ks it bd kt nl nm dn kx nn no dp lb ls np nq ld lw nr ns lf ma nt nu lh iz bi translated">单一主机规格</h2><p id="f488" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">历史上，QEMU是单线程的，在单个CPU上模拟系统架构的所有内核。虽然情况不再如此，但我们仍将模拟单核的Raspberry Pi。稍后我们将进行一些基准测试，比较每个节点上不同的CPU限制对性能的影响。但是现在，我们将在每个单核节点上使用一个CPU。由于QEMU固有的低效率，它有可能使用大量CPU资源，因此我们最初的三节点集群将从每个节点至少一个CPU的基线开始，留下一个CPU专用于主机以避免性能问题。为此任务选择的虚拟机规格如下。</p><pre class="mh mi mj mk gt nb na nc bn nd ne bi"><span id="3827" class="nf ks it na b be ng nh l nv nj">Cloud Provider: Google Cloud Platform<br/>Instance Type: n1-standard-4<br/>CPUs: 4<br/>Memory: 15GB<br/>Disk: 100GB<br/>Operating System: Ubuntu 18.04 LTS</span></pre><h2 id="2ea8" class="nk ks it bd kt nl nm dn kx nn no dp lb ls np nq ld lw nr ns lf ma nt nu lh iz bi translated">码头工人</h2><p id="02d7" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">安装在主机上，我们还使用默认版本的Docker，它可以在Ubuntu 18.04 LTS的默认apt存储库中找到。</p><pre class="mh mi mj mk gt nb na nc bn nd ne bi"><span id="e067" class="nf ks it na b be ng nh l nv nj"># docker -v<br/>Docker version 18.09.7, build 2d0083d</span></pre><h2 id="f916" class="nk ks it bd kt nl nm dn kx nn no dp lb ls np nq ld lw nr ns lf ma nt nu lh iz bi translated">Docker撰写</h2><pre class="mh mi mj mk gt nb na nc bn nd ne bi"><span id="df58" class="nf ks it na b be ng nh l nv nj"># docker-compose -v<br/>docker-compose version 1.25.0, build 0a186604</span></pre><h2 id="5955" class="nk ks it bd kt nl nm dn kx nn no dp lb ls np nq ld lw nr ns lf ma nt nu lh iz bi translated">Docker Hub Ubuntu图像</h2><pre class="mh mi mj mk gt nb na nc bn nd ne bi"><span id="b958" class="nf ks it na b be ng nh l nv nj">18.04, bionic-20200112, bionic, latest</span></pre><h2 id="fc0a" class="nk ks it bd kt nl nm dn kx nn no dp lb ls np nq ld lw nr ns lf ma nt nu lh iz bi translated">QEMU</h2><p id="3892" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">安装在Docker容器中，我们将使用以下版本的QEMU for ARM:</p><pre class="mh mi mj mk gt nb na nc bn nd ne bi"><span id="8886" class="nf ks it na b be ng nh l nv nj"># qemu-system-arm --version<br/>QEMU emulator version 4.2.0<br/>Copyright (c) 2003-2019 Fabrice Bellard and the QEMU Project developers</span></pre><h2 id="ed0e" class="nk ks it bd kt nl nm dn kx nn no dp lb ls np nq ld lw nr ns lf ma nt nu lh iz bi translated">为Raspbian定制的QEMU内核</h2><p id="e4c8" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">从Docker内部的QEMU加载，我们将使用<a class="ae mf" href="https://github.com/dhruvvyas90" rel="noopener ugc nofollow" target="_blank"> Dhruv Vyas </a>的<a class="ae mf" href="https://github.com/dhruvvyas90/qemu-rpi-kernel" rel="noopener ugc nofollow" target="_blank">编译内核</a>用于Raspbian，它已经被修改为可用于QEMU。</p><h2 id="830a" class="nk ks it bd kt nl nm dn kx nn no dp lb ls np nq ld lw nr ns lf ma nt nu lh iz bi translated">拉斯比简装图像</h2><p id="62c9" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">同样从QEMU启动，我们将使用2019年9月30日的未修改版本的<a class="ae mf" href="https://downloads.raspberrypi.org/raspbian_lite/images/raspbian_lite-2019-09-30/" rel="noopener ugc nofollow" target="_blank"> Raspbian Lite </a>。</p><h2 id="5832" class="nk ks it bd kt nl nm dn kx nn no dp lb ls np nq ld lw nr ns lf ma nt nu lh iz bi translated">期望(Tcl/Tk)</h2><p id="3415" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">Docker容器上安装了以下版本的Expect:</p><pre class="mh mi mj mk gt nb na nc bn nd ne bi"><span id="654d" class="nf ks it na b be ng nh l nv nj"># expect -v<br/>expect version 5.45.4</span></pre><h2 id="de7c" class="nk ks it bd kt nl nm dn kx nn no dp lb ls np nq ld lw nr ns lf ma nt nu lh iz bi translated"><code class="fe mx my mz na b">ssh</code> / <code class="fe mx my mz na b">sshd</code></h2><p id="9340" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">需要在每个Raspbian节点上启用<code class="fe mx my mz na b">sshd</code>，并且应该在主机上启用<code class="fe mx my mz na b">ssh</code>。</p><h2 id="03a4" class="nk ks it bd kt nl nm dn kx nn no dp lb ls np nq ld lw nr ns lf ma nt nu lh iz bi translated">Ansible</h2><p id="4705" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">Ansible的以下版本及其其他依赖项也在使用中:</p><pre class="mh mi mj mk gt nb na nc bn nd ne bi"><span id="4933" class="nf ks it na b be ng nh l nv nj"># ansible --version<br/>ansible 2.5.1<br/>  config file = /etc/ansible/ansible.cfg<br/>  configured module search path = [u'/root/.ansible/plugins/modules', u'/usr/share/ansible/plugins/modules']<br/>  ansible python module location = /usr/lib/python2.7/dist-packages/ansible<br/>  executable location = /usr/bin/ansible<br/>  python version = 2.7.17 (default, Nov  7 2019, 10:07:09) [GCC 7.4.0]</span></pre><h1 id="e541" class="kr ks it bd kt ku kv kw kx ky kz la lb ki lc kj ld kl le km lf ko lg kp lh li bi translated">构建Docker图像</h1><h2 id="071c" class="nk ks it bd kt nl nm dn kx nn no dp lb ls np nq ld lw nr ns lf ma nt nu lh iz bi translated">QEMU构建容器</h2><p id="f3e8" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">我们将从源代码编译QEMU 4.2.0。它将需要所有的支持构建工具，所以为了让我们的应用程序容器尽可能小，我们将使用Docker Hub的Ubuntu 18.04的最小版本为QEMU构建创建一个单独的构建容器。</p><h2 id="bc67" class="nk ks it bd kt nl nm dn kx nn no dp lb ls np nq ld lw nr ns lf ma nt nu lh iz bi translated">QEMU应用程序容器</h2><p id="2e5b" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">一旦QEMU从源代码编译完成，我们将把它转移到app容器中。同样从Docker Hub，我们将使用相同的Ubuntu 18.04最小版本来托管QEMU二进制文件。</p><h1 id="e451" class="kr ks it bd kt ku kv kw kx ky kz la lb ki lc kj ld kl le km lf ko lg kp lh li bi translated">Docker配置</h1><h2 id="e144" class="nk ks it bd kt nl nm dn kx nn no dp lb ls np nq ld lw nr ns lf ma nt nu lh iz bi translated"><code class="fe mx my mz na b">Dockerfile</code></h2><p id="b38e" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">我们将使用下面的Dockerfile文件，它也可以在Github上本指南附带的<a class="ae mf" href="https://github.com/mrhavens/pidoc" rel="noopener ugc nofollow" target="_blank"> pidoc </a>库中找到。下面的每个代码片段构成了docker文件的一部分。感谢<a class="ae mf" href="https://github.com/lukechilds" rel="noopener ugc nofollow" target="_blank">卢克·蔡尔德</a>为<a class="ae mf" href="https://github.com/lukechilds/dockerpi" rel="noopener ugc nofollow" target="_blank"> dockerpi </a>所做的工作。</p><p id="0c7f" class="pw-post-body-paragraph lj lk it ll b lm ms kd lo lp mt kg lr ls mu lu lv lw mv ly lz ma mw mc md me im bi translated"><code class="fe mx my mz na b">qemu-system-arm</code>的构建阶段:</p><pre class="mh mi mj mk gt nb na nc bn nd ne bi"><span id="5652" class="nf ks it na b be ng nh l nv nj">FROM ubuntu AS qemu-system-arm-builder<br/>ARG QEMU_VERSION=4.2.0<br/>ENV QEMU_TARBALL="qemu-${QEMU_VERSION}.tar.xz"<br/>WORKDIR /qemu</span></pre><pre class="nw nb na nx ny aw nz bi"><span id="3075" class="nk ks it na b gy oa ob l ni nj">RUN apt-get update &amp;&amp; \<br/>    apt-get -y install \<br/>                       wget \<br/>                       gpg \<br/>                       pkg-config \<br/>                       python \<br/>                       build-essential \<br/>                       libglib2.0-dev \<br/>                       libpixman-1-dev \<br/>                       libfdt-dev \<br/>                       zlib1g-dev \<br/>                       flex \<br/>                       bison</span></pre><p id="8878" class="pw-post-body-paragraph lj lk it ll b lm ms kd lo lp mt kg lr ls mu lu lv lw mv ly lz ma mw mc md me im bi translated">下载源。</p><pre class="mh mi mj mk gt nb na nc bn nd ne bi"><span id="72cd" class="nf ks it na b be ng nh l nv nj">RUN wget "https://download.qemu.org/${QEMU_TARBALL}"<br/><br/>RUN # Verify signatures...<br/>RUN wget "https://download.qemu.org/${QEMU_TARBALL}.sig"<br/>RUN gpg --keyserver keyserver.ubuntu.com --recv-keys CEACC9E15534EBABB82D3FA03353C9CEF108B584<br/>RUN gpg --verify "${QEMU_TARBALL}.sig" "${QEMU_TARBALL}"</span></pre><p id="6b97" class="pw-post-body-paragraph lj lk it ll b lm ms kd lo lp mt kg lr ls mu lu lv lw mv ly lz ma mw mc md me im bi translated">提取tarball。</p><pre class="mh mi mj mk gt nb na nc bn nd ne bi"><span id="665c" class="nf ks it na b be ng nh l nv nj">RUN tar xvf "${QEMU_TARBALL}"</span></pre><p id="90cc" class="pw-post-body-paragraph lj lk it ll b lm ms kd lo lp mt kg lr ls mu lu lv lw mv ly lz ma mw mc md me im bi translated">构建源代码。</p><pre class="mh mi mj mk gt nb na nc bn nd ne bi"><span id="c920" class="nf ks it na b be ng nh l nv nj">RUN "qemu-${QEMU_VERSION}/configure" --static --target-list=arm-softmmu<br/>RUN make -j$(nproc)<br/>RUN strip "arm-softmmu/qemu-system-arm"</span></pre><p id="a76b" class="pw-post-body-paragraph lj lk it ll b lm ms kd lo lp mt kg lr ls mu lu lv lw mv ly lz ma mw mc md me im bi translated">构建中间pidoc虚拟机应用程序映像。</p><pre class="mh mi mj mk gt nb na nc bn nd ne bi"><span id="b6a8" class="nf ks it na b be ng nh l nv nj">FROM ubuntu as pidoc-vm<br/>ARG RPI_KERNEL_URL="https://github.com/dhruvvyas90/qemu-rpi-kernel/archive/afe411f2c9b04730bcc6b2168cdc9adca224227c.zip"<br/>ARG RPI_KERNEL_CHECKSUM="295a22f1cd49ab51b9e7192103ee7c917624b063cc5ca2e11434164638aad5f4"</span></pre><p id="1794" class="pw-post-body-paragraph lj lk it ll b lm ms kd lo lp mt kg lr ls mu lu lv lw mv ly lz ma mw mc md me im bi translated">将二进制文件从构建容器传输到应用程序容器。</p><pre class="mh mi mj mk gt nb na nc bn nd ne bi"><span id="67dd" class="nf ks it na b be ng nh l nv nj">COPY --from=qemu-system-arm-builder /qemu/arm-softmmu/qemu-system-arm /usr/local/bin/qemu-system-arm</span></pre><p id="b938" class="pw-post-body-paragraph lj lk it ll b lm ms kd lo lp mt kg lr ls mu lu lv lw mv ly lz ma mw mc md me im bi translated">下载修改后的内核并安装。</p><pre class="mh mi mj mk gt nb na nc bn nd ne bi"><span id="d5c3" class="nf ks it na b be ng nh l nv nj">ADD $RPI_KERNEL_URL /tmp/qemu-rpi-kernel.zip</span></pre><pre class="nw nb na nx ny aw nz bi"><span id="a7f2" class="nk ks it na b gy oa ob l ni nj">RUN apt-get update &amp;&amp; \<br/>    apt-get -y install \<br/>                        unzip \<br/>                        expect<br/>RUN cd /tmp &amp;&amp; \<br/>    echo "$RPI_KERNEL_CHECKSUM  qemu-rpi-kernel.zip" | sha256sum -c &amp;&amp; \<br/>    unzip qemu-rpi-kernel.zip &amp;&amp; \<br/>    mkdir -p /root/qemu-rpi-kernel &amp;&amp; \<br/>    cp qemu-rpi-kernel-*/kernel-qemu-4.19.50-buster /root/qemu-rpi-kernel/ &amp;&amp; \<br/>    cp qemu-rpi-kernel-*/versatile-pb.dtb /root/qemu-rpi-kernel/ &amp;&amp; \<br/>    rm -rf /tmp/*</span><span id="aa17" class="nk ks it na b gy oc ob l ni nj">VOLUME /sdcard</span></pre><p id="536b" class="pw-post-body-paragraph lj lk it ll b lm ms kd lo lp mt kg lr ls mu lu lv lw mv ly lz ma mw mc md me im bi translated">然后，我们从主机的主目录中复制入口点脚本。</p><pre class="mh mi mj mk gt nb na nc bn nd ne bi"><span id="9b82" class="nf ks it na b be ng nh l nv nj">ADD ./entrypoint.sh /entrypoint.sh<br/>ENTRYPOINT ["./entrypoint.sh"]</span></pre><p id="434b" class="pw-post-body-paragraph lj lk it ll b lm ms kd lo lp mt kg lr ls mu lu lv lw mv ly lz ma mw mc md me im bi translated">使用加载的Raspbian Lite文件系统构建最终的app pidoc映像。</p><pre class="mh mi mj mk gt nb na nc bn nd ne bi"><span id="3ea2" class="nf ks it na b be ng nh l nv nj">FROM pidoc-vm as pidoc<br/>ARG FILESYSTEM_IMAGE_URL="http://downloads.raspberrypi.org/raspbian_lite/images/raspbian_lite-2019-09-30/2019-09-26-raspbian-buster-lite.zip"<br/>ARG FILESYSTEM_IMAGE_CHECKSUM="a50237c2f718bd8d806b96df5b9d2174ce8b789eda1f03434ed2213bbca6c6ff"<br/><br/>ADD $FILESYSTEM_IMAGE_URL /filesystem.zip<br/>ADD pi_ssh_enable.exp /pi_ssh_enable.exp<br/><br/>RUN echo "$FILESYSTEM_IMAGE_CHECKSUM  /filesystem.zip" | sha256sum -c</span></pre><h2 id="bd4b" class="nk ks it bd kt nl nm dn kx nn no dp lb ls np nq ld lw nr ns lf ma nt nu lh iz bi translated"><code class="fe mx my mz na b">entrypoint.sh</code>文件</h2><p id="9194" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">首先，脚本确定文件系统是否已经下载，如果没有，它下载并解压缩文件系统。</p><pre class="mh mi mj mk gt nb na nc bn nd ne bi"><span id="897d" class="nf ks it na b be ng nh l nv nj">#!/bin/sh<br/><br/>raspi_fs_init() {<br/>  image_path="/sdcard/filesystem.img"<br/>  zip_path="/filesystem.zip"<br/>  <br/>  if [ ! -e $image_path ]; then<br/>    echo "No filesystem detected at ${image_path}!"<br/>    if [ -e $zip_path ]; then<br/>        echo "Extracting fresh filesystem..."<br/>        unzip $zip_path<br/>        mv *.img $image_path<br/>        rm $zip_path<br/>    else<br/>      exit 1<br/>    fi<br/>  fi<br/>}</span></pre><p id="240e" class="pw-post-body-paragraph lj lk it ll b lm ms kd lo lp mt kg lr ls mu lu lv lw mv ly lz ma mw mc md me im bi translated">然后，该脚本检查一个空的<code class="fe mx my mz na b">raspi-init</code>文件，该文件作为一个标记来确定之前是否启动了Expect来在Raspbian上启用ssh。</p><pre class="mh mi mj mk gt nb na nc bn nd ne bi"><span id="d959" class="nf ks it na b be ng nh l nv nj">if [ ! -e /raspi-init ]; then<br/>  touch /raspi-init<br/>  raspi_fs_init<br/>  echo "Initiating Expect..."<br/>  /usr/bin/expect /pi_ssh_enable.exp `hostname -I`<br/>  echo "Expect Ended..."</span></pre><p id="18b0" class="pw-post-body-paragraph lj lk it ll b lm ms kd lo lp mt kg lr ls mu lu lv lw mv ly lz ma mw mc md me im bi translated">如果之前已经启用了Expect，那么我们只需要启动QEMU，而不需要Expect。注意，我们将Raspbian上的端口<code class="fe mx my mz na b">22</code>转发到Docker容器内的端口<code class="fe mx my mz na b">2222</code>。</p><pre class="mh mi mj mk gt nb na nc bn nd ne bi"><span id="730b" class="nf ks it na b be ng nh l nv nj">else<br/>  /usr/local/bin/qemu-system-arm \<br/>        --machine versatilepb \<br/>        --cpu arm1176 \<br/>        --m 256M \<br/>        --hda /sdcard/filesystem.img \<br/>        --net nic \<br/>        --net user,hostfwd=tcp:`hostname -I`:2222-:22 \<br/>        --dtb /root/qemu-rpi-kernel/versatile-pb.dtb \<br/>        --kernel /root/qemu-rpi-kernel/kernel-qemu-4.19.50-buster \<br/>        --append "root=/dev/sda2 panic=1" \<br/>        --no-reboot \<br/>        --display none \<br/>        --serial mon:stdio<br/>fi</span></pre><h2 id="6162" class="nk ks it bd kt nl nm dn kx nn no dp lb ls np nq ld lw nr ns lf ma nt nu lh iz bi translated">在Raspbian上启用SSHD(除了Tcl/Tk方法)</h2><p id="3699" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">QEMU没有一种直接的方法在引导时运行配置脚本。因为Raspbian默认情况下没有启用SSH，所以我们必须自己打开它。我们的选择是手动完成，或者使用某种可以与<code class="fe mx my mz na b">stdio</code>交互的脚本工具。另一种选择是在安装之前定制Raspbian映像。然而，这必须在主机上完成，因为Docker限制了新文件系统的挂载。在任何情况下，为了使这个构建具有最大的可移植性和主机独立性，最简单的方法就是使用一个<a class="ae mf" href="https://en.wikipedia.org/wiki/Expect" rel="noopener ugc nofollow" target="_blank"> Expect </a>脚本，并在构建时将它复制到我们的Docker映像中。</p><h2 id="cb86" class="nk ks it bd kt nl nm dn kx nn no dp lb ls np nq ld lw nr ns lf ma nt nu lh iz bi translated"><code class="fe mx my mz na b">pi_ssh_enable.exp</code>文件</h2><p id="f25e" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">由于未修改的Raspbian映像默认没有可访问的端口，我们将使用Expect与QEMU中的<code class="fe mx my mz na b">stdio</code>进行交互，使用默认用户名和密码登录，并启用<code class="fe mx my mz na b">sshd</code>监听器。</p><pre class="mh mi mj mk gt nb na nc bn nd ne bi"><span id="2ddb" class="nf ks it na b be ng nh l nv nj">#!/usr/bin/expect -f<br/>set ipaddr [lindex $argv 0]<br/>set timeout -1<br/>spawn /usr/local/bin/qemu-system-arm \<br/>  --machine versatilepb \<br/>  --cpu arm1176 \<br/>  --m 256M \<br/>  --hda /sdcard/filesystem.img \<br/>  --net nic \<br/>  --net user,hostfwd=tcp:$ipaddr:2222-:22 \<br/>  --dtb /root/qemu-rpi-kernel/versatile-pb.dtb \<br/>  --kernel /root/qemu-rpi-kernel/kernel-qemu-4.19.50-buster \<br/>  --append "root=/dev/sda2 panic=1" \<br/>  --no-reboot \<br/>  --display none \<br/>  --serial mon:stdio<br/>expect "raspberrypi login:"<br/>send -- "pi\r"<br/>expect "Password:"<br/>send -- "raspberry\r"<br/>expect "pi@raspberrypi:"<br/>send -- "sudo systemctl enable ssh\r"<br/>expect "pi@raspberrypi:"<br/>send -- "sudo systemctl start ssh\r"<br/>expect "pi@raspberrypi:"<br/>expect eof</span></pre><h2 id="743d" class="nk ks it bd kt nl nm dn kx nn no dp lb ls np nq ld lw nr ns lf ma nt nu lh iz bi translated">构建图像</h2><p id="181a" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">在带有<code class="fe mx my mz na b">Dockerfile</code>的文件夹中，我们将构建我们的两个容器。第一个将是我们的构建容器，其中包含编译QEMU的所有依赖项，另一个将是我们运行QEMU的应用程序容器。</p><pre class="mh mi mj mk gt nb na nc bn nd ne bi"><span id="b8ec" class="nf ks it na b be ng nh l nv nj">docker build -t pidoc .</span></pre><h2 id="771c" class="nk ks it bd kt nl nm dn kx nn no dp lb ls np nq ld lw nr ns lf ma nt nu lh iz bi translated">网络转发和故障排除</h2><p id="0e75" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">构建完成后，将其分离出来并遵循日志。</p><pre class="mh mi mj mk gt nb na nc bn nd ne bi"><span id="8b68" class="nf ks it na b be ng nh l nv nj">docker run -itd --name testnode pidoc<br/>docker logs testnode -f</span></pre><p id="cc0c" class="pw-post-body-paragraph lj lk it ll b lm ms kd lo lp mt kg lr ls mu lu lv lw mv ly lz ma mw mc md me im bi translated">Raspbian将自动下载和解压缩，QEMU应该开始从映像启动。</p><p id="18f7" class="pw-post-body-paragraph lj lk it ll b lm ms kd lo lp mt kg lr ls mu lu lv lw mv ly lz ma mw mc md me im bi translated">一旦Raspbian完全启动，Expect应该会自动启用<code class="fe mx my mz na b">sshd</code>。登录docker容器，测试SSH是否可以从容器内部的端口<code class="fe mx my mz na b">2222</code>上到达。</p><pre class="mh mi mj mk gt nb na nc bn nd ne bi"><span id="e48c" class="nf ks it na b be ng nh l nv nj"># docker exec -it testnode bash<br/>root@d4abc2f655e6:/# hostname -I<br/>172.17.0.3<br/>root@d4abc2f655e6:/# cat &lt; /dev/tcp/172.17.0.3/2222<br/>SSH-2.0-OpenSSH_7.9p1 Raspbian-10</span></pre><p id="ceeb" class="pw-post-body-paragraph lj lk it ll b lm ms kd lo lp mt kg lr ls mu lu lv lw mv ly lz ma mw mc md me im bi translated">取消和杀死容器并移除体积。</p><pre class="mh mi mj mk gt nb na nc bn nd ne bi"><span id="c7f8" class="nf ks it na b be ng nh l nv nj">root@d4abc2f655e6:/# exit<br/>exit<br/># docker kill testnode<br/>testnode<br/># docker container rm testnode<br/>testnode</span></pre><h1 id="896d" class="kr ks it bd kt ku kv kw kx ky kz la lb ki lc kj ld kl le km lf ko lg kp lh li bi translated">测试Docker容器</h1><h2 id="0147" class="nk ks it bd kt nl nm dn kx nn no dp lb ls np nq ld lw nr ns lf ma nt nu lh iz bi translated">开始/测试容器</h2><p id="9b79" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">我们需要启动容器进行测试。这主要是为了获得关于QEMU性能的一些直觉，以便我们能够更好地做出关于我们的集群的设计决策。系统应该会干净地出现一些良性警告，这些警告与更一般化的仿真硬件和预期的物理raspberry Pi硬件之间的差异有关。我发现有必要确保QEMU和Docker映像之间的端口转发工作正常，这样我就可以进一步验证Docker映像和主机之间的端口转发工作正常。我们的第一个目标是双转发SSH，这样就可以从主机直接访问QEMU。</p><pre class="mh mi mj mk gt nb na nc bn nd ne bi"><span id="184c" class="nf ks it na b be ng nh l nv nj">docker run -itd -p 127.0.0.1:2222:2222 --name testnode pidoc<br/>docker logs testnode -f</span></pre><p id="a2c8" class="pw-post-body-paragraph lj lk it ll b lm ms kd lo lp mt kg lr ls mu lu lv lw mv ly lz ma mw mc md me im bi translated">一旦系统再次联机，通过使用<code class="fe mx my mz na b">ssh</code>登录到Raspbian来测试主机端口<code class="fe mx my mz na b">2222</code>上的<code class="fe mx my mz na b">sshd</code>:</p><pre class="mh mi mj mk gt nb na nc bn nd ne bi"><span id="106f" class="nf ks it na b be ng nh l nv nj"># ssh pi@localhost -p 2222<br/>The authenticity of host '[localhost]:2222 ([127.0.0.1]:2222)' can't be established.<br/>ECDSA key fingerprint is SHA256:N0oRF23lpDOFjlgYAbml+4v2xnYdyrTmBgaNUjpxnFM.<br/>Are you sure you want to continue connecting (yes/no)? yes<br/>Warning: Permanently added '[localhost]:2222' (ECDSA) to the list of known hosts.<br/>pi@localhost's password:<br/>Linux raspberrypi 4.19.50+ #1 Tue Nov 26 01:49:16 CET 2019 armv6l</span></pre><pre class="nw nb na nx ny aw nz bi"><span id="5cf1" class="nk ks it na b gy oa ob l ni nj">The programs included with the Debian GNU/Linux system are free software;<br/>the exact distribution terms for each program are described in the<br/>individual files in /usr/share/doc/\*/copyright.</span><span id="082f" class="nk ks it na b gy oc ob l ni nj">Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent<br/>permitted by applicable law.<br/>Last login: Tue Jan 21 12:24:59 2020</span><span id="f812" class="nk ks it na b gy oc ob l ni nj">SSH is enabled and the default password for the 'pi' user has not been changed.<br/>This is a security risk - please login as the 'pi' user and type 'passwd' to set a new password.</span><span id="74aa" class="nk ks it na b gy oc ob l ni nj">pi@raspberrypi:~ $</span></pre><h2 id="e620" class="nk ks it bd kt nl nm dn kx nn no dp lb ls np nq ld lw nr ns lf ma nt nu lh iz bi translated">测试部分CPU利用率</h2><p id="dc7b" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">为了运行这个集群，我们使用运行Ubuntu 18.04 LTS版的GCP n1-standard-4实例(4x15)。但是我们现在注意到一旦拉斯边开始做任何事情，QEMU是多么的低效。多个Raspberry Pi实例在空闲时可能会堆叠得很好，但是如果我们希望保持系统的可行性，我们将需要限制每个实例上的CPU利用率，否则一旦有多个节点处于负载之下，系统就会变得不可用。幸运的是，Docker可以为我们处理这些。我们在这个实例上有15GB的ram，所以让我们看看如果我们稍微大胆一点，将6个Raspberry Pi容器放到我们的VM上会发生什么。我们将有一个完整的核心留给主机来管理其他任务，而不会有太大的失败风险。我们可以在以后用Docker Compose来扩展它。</p><p id="c43b" class="pw-post-body-paragraph lj lk it ll b lm ms kd lo lp mt kg lr ls mu lu lv lw mv ly lz ma mw mc md me im bi translated">我们将运行50%和100%的两个测试容器进行基准测试。</p><pre class="mh mi mj mk gt nb na nc bn nd ne bi"><span id="1155" class="nf ks it na b be ng nh l nv nj">docker run -itd --cpus="0.50" -p 127.0.0.1:2250:2222 --name pidoc_50_test pidoc<br/>docker run -itd --cpus="1.00" -p 127.0.0.1:2200:2222 --name pidoc_00_test pidoc</span></pre><p id="9237" class="pw-post-body-paragraph lj lk it ll b lm ms kd lo lp mt kg lr ls mu lu lv lw mv ly lz ma mw mc md me im bi translated">此时，从技术上讲，我们已经有了一个集群。除了手工操作，我们没有其他方法来管理它们。</p><h2 id="6671" class="nk ks it bd kt nl nm dn kx nn no dp lb ls np nq ld lw nr ns lf ma nt nu lh iz bi translated">表演</h2><p id="30a9" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">当一个完整的内核分配以接近物理Raspberry Pi的速度执行时，一个运行50%的实例的运行速度只有这个速度的一半。在某些情况下，这可能是可以管理的，但不是最理想的。根据手头的任务，群集的整体效率可能会提高。但是现在，我们将继续我们最初的3个节点的全核心分配，然后用6个节点进行测试。</p><h2 id="479e" class="nk ks it bd kt nl nm dn kx nn no dp lb ls np nq ld lw nr ns lf ma nt nu lh iz bi translated">单线程基准测试</h2><p id="5cb0" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">可以通过使用以下简单的基准测试来完成测试。</p><p id="5f82" class="pw-post-body-paragraph lj lk it ll b lm ms kd lo lp mt kg lr ls mu lu lv lw mv ly lz ma mw mc md me im bi translated"><strong class="ll jd"> CPU主要测试</strong></p><pre class="mh mi mj mk gt nb na nc bn nd ne bi"><span id="087c" class="nf ks it na b be ng nh l nv nj">sysbench --test=cpu --cpu-max-prime=9999 run</span></pre><p id="0860" class="pw-post-body-paragraph lj lk it ll b lm ms kd lo lp mt kg lr ls mu lu lv lw mv ly lz ma mw mc md me im bi translated"><strong class="ll jd"> CPU整数测试</strong></p><pre class="mh mi mj mk gt nb na nc bn nd ne bi"><span id="7c04" class="nf ks it na b be ng nh l nv nj">time $(i=0; while ((i&lt;9999999)); do ((i++)); done)</span></pre><p id="e43b" class="pw-post-body-paragraph lj lk it ll b lm ms kd lo lp mt kg lr ls mu lu lv lw mv ly lz ma mw mc md me im bi translated"><strong class="ll jd">硬盘读取测试</strong></p><pre class="mh mi mj mk gt nb na nc bn nd ne bi"><span id="da75" class="nf ks it na b be ng nh l nv nj">dd bs=16K count=102400 iflag=direct if=test_data of=/dev/null</span></pre><p id="2f3d" class="pw-post-body-paragraph lj lk it ll b lm ms kd lo lp mt kg lr ls mu lu lv lw mv ly lz ma mw mc md me im bi translated"><strong class="ll jd">硬盘写入测试</strong></p><pre class="mh mi mj mk gt nb na nc bn nd ne bi"><span id="5ba8" class="nf ks it na b be ng nh l nv nj">dd bs=16k count=102400 oflag=direct if=/dev/zero of=test_data</span></pre><h2 id="c52f" class="nk ks it bd kt nl nm dn kx nn no dp lb ls np nq ld lw nr ns lf ma nt nu lh iz bi translated">结果(单线程)</h2><p id="1e00" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">对于本指南，我们将只关注使用<code class="fe mx my mz na b">sysbench</code>的CPU主要测试</p><p id="dbd3" class="pw-post-body-paragraph lj lk it ll b lm ms kd lo lp mt kg lr ls mu lu lv lw mv ly lz ma mw mc md me im bi translated"><strong class="ll jd">主持人</strong></p><pre class="mh mi mj mk gt nb na nc bn nd ne bi"><span id="1a74" class="nf ks it na b be ng nh l nv nj">General statistics:<br/>    total time:                          10.0009s<br/>    total number of events:              9417<br/><br/>Latency (ms):<br/>         min:                                  1.04<br/>         avg:                                  1.06<br/>         max:                                  1.63<br/>         95th percentile:                      1.10<br/>         sum:                               9992.36<br/><br/>Threads fairness:<br/>    events (avg/stddev):           9417.0000/0.00<br/>    execution time (avg/stddev):   9.9924/0.00</span></pre><p id="3814" class="pw-post-body-paragraph lj lk it ll b lm ms kd lo lp mt kg lr ls mu lu lv lw mv ly lz ma mw mc md me im bi translated"><strong class="ll jd">虚拟树莓Pi —限制:100% </strong></p><pre class="mh mi mj mk gt nb na nc bn nd ne bi"><span id="e5a2" class="nf ks it na b be ng nh l nv nj">Test execution summary:<br/>    total time:                          397.8781s<br/>    total number of events:              10000<br/>    total time taken by event execution: 397.4056<br/>    per-request statistics:<br/>         min:                                 38.61ms<br/>         avg:                                 39.74ms<br/>         max:                                 57.15ms<br/>         approx.  95 percentile:              40.92ms<br/><br/>Threads fairness:<br/>    events (avg/stddev):           10000.0000/0.00<br/>    execution time (avg/stddev):   397.4056/0.00</span></pre><p id="b4f5" class="pw-post-body-paragraph lj lk it ll b lm ms kd lo lp mt kg lr ls mu lu lv lw mv ly lz ma mw mc md me im bi translated"><strong class="ll jd">虚拟树莓派—限制:50% </strong></p><pre class="mh mi mj mk gt nb na nc bn nd ne bi"><span id="57f0" class="nf ks it na b be ng nh l nv nj">Test execution summary:<br/>    total time:                          823.8272s<br/>    total number of events:              10000<br/>    total time taken by event execution: 822.9329<br/>    per-request statistics:<br/>         min:                                 38.68ms<br/>         avg:                                 82.29ms<br/>         max:                                184.02ms<br/>         approx.  95 percentile:              94.65ms<br/><br/>Threads fairness:<br/>    events (avg/stddev):           10000.0000/0.00<br/>    execution time (avg/stddev):   822.9329/0.00</span></pre><h1 id="085b" class="kr ks it bd kt ku kv kw kx ky kz la lb ki lc kj ld kl le km lf ko lg kp lh li bi translated">组成集群</h1><h2 id="203e" class="nk ks it bd kt nl nm dn kx nn no dp lb ls np nq ld lw nr ns lf ma nt nu lh iz bi translated">创建<code class="fe mx my mz na b">docker-compose.yml</code>文件</h2><p id="af91" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">我们将使用Docker Compose来创建集群。最初，我们将把它放在三个节点上，以便于管理。一旦我们有了概念验证群集，我们就可以向外扩展。处理这个问题最直接的方法是为每个容器将单独的端口映射到本地主机。我们可以指定在<code class="fe mx my mz na b">docker-compose.yml</code>文件中使用的端口范围，如下所示。</p><pre class="mh mi mj mk gt nb na nc bn nd ne bi"><span id="b6e4" class="nf ks it na b be ng nh l nv nj">version: '3'<br/><br/>services:<br/>  node:<br/>    image: pidoc<br/>    ports:<br/>      - "2201-2203:2222"</span></pre><h2 id="41f6" class="nk ks it bd kt nl nm dn kx nn no dp lb ls np nq ld lw nr ns lf ma nt nu lh iz bi translated">调出集群</h2><p id="c601" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">使用<code class="fe mx my mz na b">docker-compose</code>调出三个节点，使用<code class="fe mx my mz na b">--scale</code>选项。</p><pre class="mh mi mj mk gt nb na nc bn nd ne bi"><span id="1bf4" class="nf ks it na b be ng nh l nv nj">docker-compose up --scale node=3</span></pre><h2 id="9283" class="nk ks it bd kt nl nm dn kx nn no dp lb ls np nq ld lw nr ns lf ma nt nu lh iz bi translated">可变配置</h2><p id="fc2a" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">既然我们已经为集群准备好了所有的基础设施，我们需要管理它。我们可以使用Docker双重连接到QEMU监视器，但是<code class="fe mx my mz na b">ssh</code>更加健壮。既然我们用的是<code class="fe mx my mz na b">ssh</code>，就可以用Ansible。这里提供了几个基本操作:<code class="fe mx my mz na b">update</code>、<code class="fe mx my mz na b">upgrade</code>、<code class="fe mx my mz na b">reboot</code>、<code class="fe mx my mz na b">shutdown</code>。这些可以根据需要扩展，以开发一个更健壮的系统。</p><h2 id="d465" class="nk ks it bd kt nl nm dn kx nn no dp lb ls np nq ld lw nr ns lf ma nt nu lh iz bi translated"><code class="fe mx my mz na b">hosts</code>文件</h2><p id="bbea" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">请注意我们之前在<code class="fe mx my mz na b">docker-compose.yml</code>文件中指定的端口，并相应地编辑您的<code class="fe mx my mz na b">hosts</code>清单。</p><pre class="mh mi mj mk gt nb na nc bn nd ne bi"><span id="1185" class="nf ks it na b be ng nh l nv nj">[all:vars]<br/>ansible_user=pi<br/>ansible_ssh_pass=raspberry<br/>ansible_ssh_extra_args='-o StrictHostKeyChecking=no'<br/><br/>[pidoc-cluster]<br/>node_1.localhost:2201<br/>node_2.localhost:2202<br/>node_3.localhost:2203</span></pre><p id="01e1" class="pw-post-body-paragraph lj lk it ll b lm ms kd lo lp mt kg lr ls mu lu lv lw mv ly lz ma mw mc md me im bi translated">想要更全面的了解Ansible，请阅读<a class="ae mf" href="https://appfleet.com/blog/how-to-install-and-configure-ansible-on-ubuntu-part-1/" rel="noopener ugc nofollow" target="_blank">如何在Ubuntu </a>上安装和配置Ansible。</p><h2 id="6f29" class="nk ks it bd kt nl nm dn kx nn no dp lb ls np nq ld lw nr ns lf ma nt nu lh iz bi translated"><code class="fe mx my mz na b">update.yml</code>文件</h2><pre class="mh mi mj mk gt nb na nc bn nd ne bi"><span id="9ceb" class="nf ks it na b be ng nh l nv nj">---<br/>- name: Apt update Pi...<br/>  hosts: pidoc-cluster<br/>  tasks:<br/>    - name: Update apt cache...<br/>      become: yes<br/>      apt:<br/>        update_cache=yes</span></pre><p id="4ba2" class="pw-post-body-paragraph lj lk it ll b lm ms kd lo lp mt kg lr ls mu lu lv lw mv ly lz ma mw mc md me im bi translated">用法:<code class="fe mx my mz na b">ansible-playbook playbooks/update.yml -i hosts</code></p><h2 id="b05f" class="nk ks it bd kt nl nm dn kx nn no dp lb ls np nq ld lw nr ns lf ma nt nu lh iz bi translated"><code class="fe mx my mz na b">upgrade.yml</code>文件</h2><pre class="mh mi mj mk gt nb na nc bn nd ne bi"><span id="5224" class="nf ks it na b be ng nh l nv nj">---<br/>- name: Upgrade Pi...<br/>  hosts: pidoc-cluster<br/>  gather_facts: no<br/>  tasks:<br/>    - name: Update and upgrade apt packages...<br/>      become: true<br/>      apt:<br/>        upgrade: yes<br/>        update_cache: yes<br/>        cache_valid_time: 86400</span></pre><p id="1ba6" class="pw-post-body-paragraph lj lk it ll b lm ms kd lo lp mt kg lr ls mu lu lv lw mv ly lz ma mw mc md me im bi translated">用法:<code class="fe mx my mz na b">ansible-playbook playbooks/upgrade.yml -i hosts</code></p><h2 id="21fe" class="nk ks it bd kt nl nm dn kx nn no dp lb ls np nq ld lw nr ns lf ma nt nu lh iz bi translated"><code class="fe mx my mz na b">reboot.yml</code>文件</h2><pre class="mh mi mj mk gt nb na nc bn nd ne bi"><span id="1b58" class="nf ks it na b be ng nh l nv nj">---<br/>- name: Reboot Pi...<br/>  hosts: pidoc-cluster<br/>  gather_facts: no<br/>  tasks:<br/>    - name: Reboot Pi...<br/>      shell: shutdown -r now<br/>      async: 0<br/>      poll: 0<br/>      ignore_errors: true<br/>      become: true<br/><br/>- name: Wait for reboot...<br/>      local_action: wait_for host=state=started delay=10<br/>      become: false</span></pre><p id="f69e" class="pw-post-body-paragraph lj lk it ll b lm ms kd lo lp mt kg lr ls mu lu lv lw mv ly lz ma mw mc md me im bi translated">用法:<code class="fe mx my mz na b">ansible-playbook playbooks/reboot.yml -i hosts</code></p><h2 id="1dc1" class="nk ks it bd kt nl nm dn kx nn no dp lb ls np nq ld lw nr ns lf ma nt nu lh iz bi translated"><code class="fe mx my mz na b">shutdown.yml</code>文件</h2><pre class="mh mi mj mk gt nb na nc bn nd ne bi"><span id="13f2" class="nf ks it na b be ng nh l nv nj">---<br/>- name: Shutdown Pi...<br/>  hosts: pidoc-cluster<br/>  gather_facts: no<br/>  tasks:<br/>    - name: 'Shutdown Pi'<br/>      shell: shutdown -h now<br/>      async: 0<br/>      poll: 0<br/>      ignore_errors: true<br/>      become: true<br/><br/>- name: "Wait for shutdown..."<br/>      local_action: wait_for host= state=stopped<br/>      become: false</span></pre><p id="3443" class="pw-post-body-paragraph lj lk it ll b lm ms kd lo lp mt kg lr ls mu lu lv lw mv ly lz ma mw mc md me im bi translated">用法:<code class="fe mx my mz na b">ansible-playbook playbooks/shutdown.yml -i hosts</code></p><h1 id="f0c7" class="kr ks it bd kt ku kv kw kx ky kz la lb ki lc kj ld kl le km lf ko lg kp lh li bi translated">按比例放大</h1><p id="07f9" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">Docker Compose使得在同一台主机上扩展Raspberry Pi容器变得微不足道。通过使用Ansible进行集群管理，通过将端口绑定从localhost更改为可路由的IP地址，还可以非常容易地横向扩展到其他主机。这是我们的例子，有6个节点，而不是3个。</p><h2 id="8e73" class="nk ks it bd kt nl nm dn kx nn no dp lb ls np nq ld lw nr ns lf ma nt nu lh iz bi translated"><code class="fe mx my mz na b">docker-compose.yml</code>文件</h2><pre class="mh mi mj mk gt nb na nc bn nd ne bi"><span id="c783" class="nf ks it na b be ng nh l nv nj">version: '3'<br/><br/>services:<br/>  node:<br/>    image: pidoc<br/>    ports:<br/>      - "2201-2212:2222"<br/>    deploy:<br/>      resources:<br/>        limits:<br/>          cpus: "0.5"</span></pre><h1 id="5482" class="kr ks it bd kt ku kv kw kx ky kz la lb ki lc kj ld kl le km lf ko lg kp lh li bi translated">调出集群</h1><p id="5793" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">我们应该停止使用以前集群中的容器，并在扩展修改后的集群之前删除所有卷。要使用<code class="fe mx my mz na b">docker-compose</code>调出所有6个节点，再次使用<code class="fe mx my mz na b">--scale</code>选项。</p><pre class="mh mi mj mk gt nb na nc bn nd ne bi"><span id="cfe4" class="nf ks it na b be ng nh l nv nj">docker-compose up --scale node=5</span></pre><h1 id="9a25" class="kr ks it bd kt ku kv kw kx ky kz la lb ki lc kj ld kl le km lf ko lg kp lh li bi translated">未来的工作</h1><p id="faa8" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">QEMU的Raspberry Pi仿真仍在开发中。虽然这个项目的配置相对稳定，但还有很大的改进空间。尝试迁移到Raspberry Pi 3仿真将是一个雄心勃勃的下一步。Docker Compose虽然是为单主机构建设计的，但已经足够容易手动或通过Ansible复制到其他主机。但是，它可以很容易地用<a class="ae mf" href="https://appfleet.com/blog/docker-swarm-and-shared-storage-volumes/" rel="noopener ugc nofollow" target="_blank"> Swarm </a>或k8s扩展，使我们能够构建任何规模的模拟Raspberry Pi集群。此外，通过一个或多个端口重定向，可以实施其他控制系统，包括各种节点端点，这取决于目的和应用。</p></div><div class="ab cl od oe hx of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="im in io ip iq"><figure class="mh mi mj mk gt ml gh gi paragraph-image"><a href="https://www.buymeacoffee.com/markrhavens"><div class="gh gi ok"><img src="../Images/c28bc9538d899d922b6e6c14ff24a48a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*MP1bGFIZ9v-tzTbO.png"/></div></a><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">如果你喜欢这篇文章，像你这样的粉丝再给我一杯咖啡，肯定会鼓励我再写一篇这样的文章。顺便来看看，打个招呼，让我知道你对你可能想读的话题的想法。你可能是我需要写一些更棒的东西的灵感火花！</figcaption></figure></div><div class="ab cl od oe hx of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="im in io ip iq"><h1 id="f220" class="kr ks it bd kt ku ol kw kx ky om la lb ki on kj ld kl oo km lf ko op kp lh li bi translated">更新:2022年11月24日</h1><p id="29cf" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated"><em class="oq">在2020年疫情爆发之前，我提出并被委托写下上述的穿越。由</em> <a class="ae mf" href="https://appfleet.com/" rel="noopener ugc nofollow" target="_blank"> <em class="oq"> Appfleet </em> </a> <em class="oq">发布，并于2020年1月21日作为Appfleet博客</em>  <em class="oq">发布</em> <a class="ae mf" href="https://appfleet.com/blog/raspberry-pi-cluster-emulation-with-docker-compose/" rel="noopener ugc nofollow" target="_blank"> <em class="oq">。</em> </a><a class="ae mf" href="https://havdevops.com/Raspberry-Pi-Cluster-Emulation-with-Docker-Compose/" rel="noopener ugc nofollow" target="_blank"> <em class="oq">这个故事的一个版本</em> </a> <em class="oq">也可以在</em><a class="ae mf" href="https://havdevops.com/" rel="noopener ugc nofollow" target="_blank"><em class="oq">my havdoveps博客</em> </a> <em class="oq">上找到。我将上面更新的故事发布到Medium，只做了微小的编辑和格式更改。如果有人发现错误需要我的注意，请不吝赐教。</em></p></div><div class="ab cl od oe hx of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="im in io ip iq"><p id="5dac" class="pw-post-body-paragraph lj lk it ll b lm ms kd lo lp mt kg lr ls mu lu lv lw mv ly lz ma mw mc md me im bi translated">作为Medium的作者， <a class="ae mf" href="https://mark-havens.medium.com/membership" rel="noopener"> <em class="oq">我邀请你成为会员</em> </a> <em class="oq">并获得我的故事集，以及成千上万其他天才作家写的故事。你的会员费直接支持我和你阅读的其他作家，并让你完全接触媒体上的每一个故事。</em></p></div><div class="ab cl od oe hx of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="im in io ip iq"><p id="e485" class="pw-post-body-paragraph lj lk it ll b lm ms kd lo lp mt kg lr ls mu lu lv lw mv ly lz ma mw mc md me im bi translated"><a class="ae mf" href="https://markhavens.us/" rel="noopener ugc nofollow" target="_blank"> <em class="oq">马克·兰道尔·哈文斯</em> </a> <em class="oq">是一位连续创业者和创造者，他从19岁起就开始创业。他是北德克萨斯州最知名的两个创客社区</em> <a class="ae mf" href="https://dallasmakercommunity.org/" rel="noopener ugc nofollow" target="_blank"> <em class="oq">达拉斯创客社区</em> </a> <em class="oq">和</em> <a class="ae mf" href="https://dallasmakerspace.org/" rel="noopener ugc nofollow" target="_blank"> <em class="oq">达拉斯创客空间</em> </a> <em class="oq">的创始人。他拥有科罗拉多技术大学的管理学硕士学位，并获得了德克萨斯大学Rio Grand Valley分校的计算机科学学士学位。为了表彰他在创客社区的工作，他获得了位于阿灵顿的德克萨斯大学的博士奖学金。当马克不从事制造工作或探索生活、文化和技术时，他住在达拉斯的中心郊区——沃斯堡大都会区，探索新的、创新的方式来养活他的母亲和两个孩子。</em></p></div></div>    
</body>
</html>