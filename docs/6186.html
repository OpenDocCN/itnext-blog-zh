<html>
<head>
<title>Distroless Container Debugging on K8s/OpenShift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">K8s/OpenShift上的分布式容器调试</h1>
<blockquote>原文：<a href="https://itnext.io/distroless-container-debugging-on-k8s-openshift-e418fd66fdad?source=collection_archive---------0-----------------------#2021-09-12">https://itnext.io/distroless-container-debugging-on-k8s-openshift-e418fd66fdad?source=collection_archive---------0-----------------------#2021-09-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/cd669e4ecd8e742e8a045f9cd0584e4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*xCM0uVtrGeFTXS7z.jpg"/></div></div></figure><p id="f280" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当人们越来越关注集装箱的安全性时，基于分布式的图像经常被用来减少攻击面。在这些映像中，包管理器、非依赖模块或库，甚至外壳都被剥离，只有应用程序及其所需的依赖项被保留。对于静态链接的可执行文件，例如golang生产的，我们甚至可以使用“scratch”作为基础。</p><p id="3b29" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因此，对漏洞的潜在利用大大减少。但是，另一方面，如果连shell都不可用，只留下应用程序的日志，就很难对应用程序进行故障诊断。</p><p id="2c44" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在本文中，我们将探索不同的选项，通过恢复shell来简化调试。</p><h1 id="7b01" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">应用程序、Dockerfile和YAMLs</h1><p id="1686" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">让我们使用一个玩具hello world HTTP handler golang程序。Dockerfile文件如下所示，</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="c786" class="ml la it mh b gy mm mn l mo mp">FROM golang as builder<br/>WORKDIR /build<br/>COPY ./src /build</span><span id="eb32" class="ml la it mh b gy mq mn l mo mp">RUN go build -o serving *.go</span><span id="8274" class="ml la it mh b gy mq mn l mo mp"><strong class="mh iu">FROM gcr.io/distroless/base</strong><br/>WORKDIR /app<br/>COPY --from=builder /build/serving /app</span><span id="4ea7" class="ml la it mh b gy mq mn l mo mp">ENTRYPOINT ["./serving"]</span></pre><p id="8725" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">构建并推送映像。我的测试环境是OpenShift，使用的是OpenShift的私有注册表。使用以下部署YAML运行应用程序。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="af7f" class="ml la it mh b gy mm mn l mo mp">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: app<br/>  labels:<br/>    app: app<br/>spec:<br/>  replicas: 1<br/>  selector:<br/>    matchLabels:<br/>      app: app<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: app<br/>    spec:<br/>      containers:<br/>      - name: app<br/>        imagePullPolicy: Always<br/>        image: image-registry.openshift-image-registry.svc:5000/debug/k-debug:v1.0<br/>        ports:<br/>        - containerPort: 80</span></pre><p id="bfd5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们对pod做一个<code class="fe mr ms mt mh b">kubectl exec</code>(我用的是OCP)，正如我们所料，我们得到了</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="8b95" class="ml la it mh b gy mm mn l mo mp">$ oc exec -it app-7c66b76bb7-2s9gr -- sh<br/>ERRO[0000] exec failed: container_linux.go:367: starting container process caused: exec: "sh": executable file not found in $PATH<br/>command terminated with exit code 1</span></pre><p id="5c24" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">至此，让我们来探索如何将shell访问添加到pod中。</p><h1 id="c7d6" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">1.发行调试映像</h1><p id="f097" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">GoogleContainerTool提供了一个<code class="fe mr ms mt mh b">:debug</code>图像标签。因此，用:debug标记替换基本映像，当exec进入pod时，重新构建映像将为我们提供一个busybox shell。</p><p id="5ed3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">显然，它只对开发阶段有好处。</p><h1 id="c298" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">2.共享进程命名空间</h1><p id="733b" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">当一个pod启用了进程命名空间共享时，一个容器中的进程可供同一pod中的其他容器使用。</p><p id="e84b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们更新部署YAML文件，</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="f01f" class="ml la it mh b gy mm mn l mo mp">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: app-share-ns<br/>  labels:<br/>    app: app-share-ns<br/>spec:<br/>  replicas: 1<br/>  selector:<br/>    matchLabels:<br/>      app: app-share-ns<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: app-share-ns<br/>    spec:<br/>      <strong class="mh iu">shareProcessNamespace: true</strong><br/>      serviceAccountName: debugger<br/>      containers:<br/>      - name: app-share-ns<br/>        imagePullPolicy: Always<br/>        image: image-registry.openshift-image-registry.svc:5000/debug/k-debug:v1.0<br/>        ports:<br/>        - containerPort: 80<br/>        securityContext:<br/>          runAsUser: 1000</span><span id="2cdf" class="ml la it mh b gy mq mn l mo mp">      - name: shell<br/>        image: ubuntu<br/>        stdin: true<br/>        tty: true<br/>        securityContext:<br/>          runAsUser: 0</span></pre><p id="86a3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将pod选项shareProcessNamespace启用为true。使用ubuntu添加额外的shell容器。因为图像的默认CMD是bash，所以我们将tty和stdin都设置为true。以root用户身份运行该容器。让应用程序容器作为非根用户运行，比如用户id 1000。</p><p id="56fe" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在OpenShift下，默认服务帐户受到安全上下文约束(SCC)的限制。为了能够以不同的用户身份运行，我们创建了一个新的服务帐户，将anyuid SCC分配给它。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="9505" class="ml la it mh b gy mm mn l mo mp">kubectl create sa debugger<br/>oc adm policy add-scc-to-user anyuid -z debugger</span></pre><p id="1773" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">应用YAML后，附加到外壳容器，我们得到了外壳。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="5034" class="ml la it mh b gy mm mn l mo mp">$ kubectl attach -it app-share-ns-76b85f9cb5-zkjpc -c shell<br/>If you don't see a command prompt, try pressing enter.<br/>root@app-share-ns-76b85f9cb5-zkjpc:/#</span></pre><p id="06b6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">用ps -ef列出流程，</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="16d1" class="ml la it mh b gy mm mn l mo mp">UID          PID    PPID  C STIME TTY          TIME CMD<br/>root           1       0  0 10:34 ?        00:00:00 /usr/bin/pod<br/>1000           7       0  0 10:34 ?        00:00:00 ./serving<br/>root          18       0  0 10:34 pts/0    00:00:00 bash<br/>root          44      18  0 10:57 pts/0    00:00:00 ps -ef</span></pre><p id="3c15" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到在PID为7的用户1000下运行的app进程。</p><p id="21db" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们安装netstat工具，我们可以确定应用程序的监听端口在8080上。而部署YAML指定了错误的端口号。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="fa91" class="ml la it mh b gy mm mn l mo mp">netstat -tna<br/>Active Internet connections (servers and established)<br/>Proto Recv-Q Send-Q Local Address           Foreign Address         State<br/>tcp6       0      0 :::8080                 :::*                    LISTEN</span></pre><p id="382b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们甚至可以访问/proc文件系统，这是一个伪文件系统，为进程提供了内核数据结构的接口。例如，我们可以通过符号链接/proc/7/root访问应用程序的文件系统。但是我们不能使用上面的部署YAML来访问它，如下所示，</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="7aca" class="ml la it mh b gy mm mn l mo mp"># cd /proc/7/root<br/>bash: cd: /proc/7/root: Permission denied</span></pre><p id="6481" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了实现访问，我们必须分配SYS_PTRACE Linux功能，以允许shell容器控制其他进程。修改部署外壳容器部分，添加Linux功能，如下所示，</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="c63f" class="ml la it mh b gy mm mn l mo mp">          - name: shell<br/>            image: ubuntu<br/>            stdin: true<br/>            tty: true<br/>            securityContext:<br/>              runAsUser: 0<br/>              <strong class="mh iu">capabilities:<br/>                add:<br/>                - SYS_PTRACE</strong></span></pre><p id="2d9a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">同时，我们必须更新SCC以允许SYS_PTRACE Linux功能。基于默认的anyuid创建新的SCC，</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="88d2" class="ml la it mh b gy mm mn l mo mp">allowHostDirVolumePlugin: false<br/>allowHostIPC: false<br/>allowHostNetwork: false<br/>allowHostPID: false<br/>allowHostPorts: false<br/>allowPrivilegeEscalation: true<br/>allowPrivilegedContainer: false<br/><strong class="mh iu">allowedCapabilities:<br/>- SYS_PTRACE</strong><br/>apiVersion: security.openshift.io/v1<br/>defaultAddCapabilities: null<br/>fsGroup:<br/>  type: RunAsAny<br/>groups:<br/>- system:cluster-admins<br/>kind: SecurityContextConstraints<br/>metadata:<br/>  name: anyuid-ptrace<br/>priority: 10<br/>readOnlyRootFilesystem: false<br/>requiredDropCapabilities:<br/>- MKNOD<br/>runAsUser:<br/>  type: RunAsAny<br/>seLinuxContext:<br/>  type: MustRunAs<br/>supplementalGroups:<br/>  type: RunAsAny<br/>volumes:<br/>- configMap<br/>- downwardAPI<br/>- emptyDir<br/>- persistentVolumeClaim<br/>- projected<br/>- secret</span></pre><p id="eda4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">将新的SCC分配给调试器服务帐户，</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="1a5d" class="ml la it mh b gy mm mn l mo mp">oc adm policy remove-scc-from-user anyuid -z debugger<br/>oc adm policy add-scc-to-user anyuid-ptrace -z debugger</span></pre><p id="8a0a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">重新部署部署，附加到外壳容器。我们现在可以看到这个过程。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="6b2b" class="ml la it mh b gy mm mn l mo mp"># ps -ef <br/>UID          PID    PPID  C STIME TTY          TIME CMD<br/>root           1       0  0 15:39 ?        00:00:00 /usr/bin/pod<br/>1000           8       0  0 15:39 ?        00:00:00 ./serving<br/>root          19       0  0 15:39 pts/0    00:00:00 bash<br/>root          33      19  0 15:45 pts/0    00:00:00 ps -ef</span></pre><p id="0945" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们确认添加了SYS_PTRACE功能。添加<code class="fe mr ms mt mh b">capsh</code>工具。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="0853" class="ml la it mh b gy mm mn l mo mp"># apt update; apt install libcap2-bin</span><span id="a3b9" class="ml la it mh b gy mq mn l mo mp"># cat /proc/self/status | grep Cap<br/>CapInh: 00000000000805fb<br/>CapPrm: 00000000000805fb<br/>CapEff: 00000000000805fb<br/>CapBnd: 00000000000805fb<br/>CapAmb: 0000000000000000</span></pre><p id="a1fc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">解码功能，SYS_PTRACE功能可用。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="964f" class="ml la it mh b gy mm mn l mo mp"># capsh --decode=00000000000805fb<br/>WARNING: libcap needs an update (cap=39 should have a name).<br/>0x00000000000805fb=cap_chown,cap_dac_override,cap_fowner,cap_fsetid,cap_kill,cap_setgid,cap_setuid,cap_setpcap,cap_net_bind_service,<strong class="mh iu">cap_sys_ptrace</strong></span></pre><p id="3667" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，我们可以访问它的文件系统。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="8a39" class="ml la it mh b gy mm mn l mo mp"># cd /proc/8/root<br/># ls<br/>app  bin  boot  busybox  dev  etc  home  lib  lib64  proc  root  run  sbin  sys  tmp  usr  var</span><span id="1788" class="ml la it mh b gy mq mn l mo mp"># ls -lh<br/>total 5.9M<br/>-rwxr-xr-x. 1 root root 5.9M Sep 11 10:32 serving</span></pre><p id="800f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在不更改应用程序容器映像的情况下，共享进程命名空间方法具有对应用程序进行故障排除和调试的完全外壳访问权限。但是，修改部署YAML文件，并更改Pod的安全设置，使得这种方法只适用于测试环境。</p><h1 id="240c" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">3.Kubectl调试</h1><p id="c6ea" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">临时容器是一种特殊类型的容器，它在现有Pod中临时运行，以完成用户启动的操作，如故障排除。与<code class="fe mr ms mt mh b">kubectl debug</code>函数一起，我们可以调试应用程序容器。</p><p id="8365" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">注意这个特性，从Kubernetes v1.22开始，仍然是alpha版本。<em class="mu"> (Alpha发布目标(1.16)，Beta发布目标(1.23)，</em><a class="ae mv" href="https://github.com/kubernetes/enhancements/issues/277" rel="noopener ugc nofollow" target="_blank"><em class="mu">https://github.com/kubernetes/enhancements/issues/277</em></a><em class="mu">)</em></p><p id="40af" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">作为它的阿尔法，我们需要打开它的特征门。对于我的环境，OpenShift容器平台(<em class="mu"> OCP 4.8，K8s v1.21.1 </em>)，创建并应用如下YAML，让OCP支持临时容器。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="74f2" class="ml la it mh b gy mm mn l mo mp">apiVersion: config.openshift.io/v1<br/>kind: FeatureGate<br/>metadata:<br/>  name: cluster<br/>spec:<br/>  customNoUpgrade:<br/>    enabled:<br/>      - EphemeralContainers<br/>  featureSet: CustomNoUpgrade</span></pre><p id="3229" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后，我们可以使用<code class="fe mr ms mt mh b">kubectl debug</code>命令启动一个容器来进行故障排除。注意到<code class="fe mr ms mt mh b">kubectl debug</code>与<code class="fe mr ms mt mh b">oc debug</code>不同。在<code class="fe mr ms mt mh b">oc debug</code>中，相同容器的命令被替换为<code class="fe mr ms mt mh b">/bin/sh,</code>，但对于distroless容器，这不起作用。</p><h2 id="aa00" class="ml la it bd lb mw mx dn lf my mz dp lj km na nb ln kq nc nd lr ku ne nf lv ng bi translated">3.1临时容器</h2><p id="ead8" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">使用<code class="fe mr ms mt mh b">kubectl debug</code>有两种方法。一种方法是使用如下命令在现有pod上创建一个临时容器，</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="65c3" class="ml la it mh b gy mm mn l mo mp">kubectl debug app-654465676b-5pf44 -it --image=ubuntu --target=app</span></pre><p id="a5bc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">请注意目标参数，它将指示容器引擎使用原始容器的进程名称空间创建容器。当您在新的调试器shell中创建进程列表时，pid 1应该是应用程序进程。调试器shell的pid应该是应用程序后面的某个数字。</p><p id="f546" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">遗憾的是，截至目前，OpenShift的底层容器引擎CRI-O还不支持“— target”命令<em class="mu">(</em><a class="ae mv" href="https://github.com/cri-o/cri-o/issues/4790" rel="noopener ugc nofollow" target="_blank"><em class="mu">【https://github.com/cri-o/cri-o/issues/4790</em></a><em class="mu">)。我们在调试外壳中看不到应用程序的进程。</em></p><p id="1efe" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一种方法是在原始pod中启用<code class="fe mr ms mt mh b">shareProcessNamespace: true</code>,然后调试shell可以看到如下所示的进程名称空间。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="834e" class="ml la it mh b gy mm mn l mo mp">$ kubectl debug app-654465676b-hmt8z --image=ubuntu -it --target=app<br/>Defaulting debug container name to debugger-zl9v5.<br/>If you don't see a command prompt, try pressing enter.<br/>root@app-654465676b-hmt8z:/# ps -ef<br/>UID          PID    PPID  C STIME TTY          TIME CMD<br/>root           1       0  0 07:41 ?        00:00:00 /usr/bin/pod<br/>1000640+       8       0  0 07:41 ?        00:00:00 ./serving<br/>root          37       0  0 07:45 pts/0    00:00:00 bash<br/>root          47      37  0 07:48 pts/0    00:00:00 ps -ef</span></pre><h2 id="c0bb" class="ml la it bd lb mw mx dn lf my mz dp lj km na nb ln kq nc nd lr ku ne nf lv ng bi translated">3.2.复制并添加</h2><p id="a6b4" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">除了在临时容器上工作，另一种方法是将pod复制到一个新的pod，同时添加一个调试容器。</p><p id="3ce8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">举个例子，</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="9e42" class="ml la it mh b gy mm mn l mo mp">kubectl debug app-7c66b76bb7-5vvxg -it --image=ubuntu --share-processes --copy-to=app-debug<br/>Defaulting debug container name to debugger-vkwns.<br/>If you don't see a command prompt, try pressing enter.<br/>root@app-debug:/# ps -ef<br/>UID          PID    PPID  C STIME TTY          TIME CMD<br/>root           1       0  0 07:55 ?        00:00:00 /usr/bin/pod<br/>1000640+       7       0  0 07:55 ?        00:00:00 ./serving<br/>root          20       0  0 07:55 pts/0    00:00:00 bash<br/>root          28      20  0 07:55 pts/0    00:00:00 ps -ef</span></pre><p id="14a8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">注意<code class="fe mr ms mt mh b">--share-processes</code>标志，这样我们可以在调试shell中看到进程。</p><p id="be08" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们做一个逃生舱，</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="4f7e" class="ml la it mh b gy mm mn l mo mp">$ oc get pods<br/>NAME                            READY   STATUS    RESTARTS   AGE<br/>app-7c66b76bb7-5vvxg            1/1     Running   0          4m22s<br/>app-debug                       2/2     Running   1          3m2s</span></pre><p id="c220" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">显示了复制的app-debug窗格，注意现在它不再使用临时容器，而是添加了一个普通容器，</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="204e" class="ml la it mh b gy mm mn l mo mp">  - image: ubuntu<br/>    imagePullPolicy: Always<br/>    name: debugger-vkwns<br/>    resources: {}<br/>    securityContext:<br/>      capabilities:<br/>        drop:<br/>        - MKNOD<br/>    stdin: true<br/>    terminationMessagePath: /dev/termination-log<br/>    terminationMessagePolicy: File<br/>    tty: true</span></pre><p id="c965" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">不出所料，由于缺少Linux功能，我们无法访问/proc进程文件系统。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="d3aa" class="ml la it mh b gy mm mn l mo mp">root@app-debug:/# cd /proc/7<br/>root@app-debug:/proc/7# cd root<br/>bash: cd: root: Permission denied</span></pre><p id="5dae" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在当前版本的kubectl debug中，没有办法添加额外的Linux功能。希望这个问题<em class="mu">(</em><a class="ae mv" href="https://github.com/kubernetes/kubernetes/issues/97103" rel="noopener ugc nofollow" target="_blank"><em class="mu">https://github.com/kubernetes/kubernetes/issues/97103</em></a><em class="mu">)</em>解决后，我们能够添加所需的功能。</p><h1 id="b49f" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">摘要</h1><p id="8a4e" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">我们已经研究了在K8s中排除distroless容器故障的不同方法。到目前为止，如果不修改最初的pod定义，它们中没有一个真正适合生产环境使用。</p><p id="f668" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当问题和特性需求结束时，kubectl调试方法似乎更有希望用于生产。</p></div></div>    
</body>
</html>