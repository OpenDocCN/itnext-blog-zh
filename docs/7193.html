<html>
<head>
<title>Temporary Storage for Kubernetes Pods</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes豆荚的临时储存</h1>
<blockquote>原文：<a href="https://itnext.io/temporary-storage-for-kubernetes-pods-f8330ad8db88?source=collection_archive---------1-----------------------#2022-07-11">https://itnext.io/temporary-storage-for-kubernetes-pods-f8330ad8db88?source=collection_archive---------1-----------------------#2022-07-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="8671" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated"><strong class="ak"> <em class="kf">或空目录vs .容器文件系统</em> </strong></h2></div><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div class="gh gi kg"><img src="../Images/b2e4835b05940b6147daaee3fafe5452.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*zZi1DSgvvyLmc706s9R6Rg.jpeg"/></div></figure><p id="800c" class="pw-post-body-paragraph ko kp iq kq b kr ks jr kt ku kv ju kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">Kubernetes应用程序可能需要一些临时存储，在容器停止/移除后可以丢弃这些临时存储。应用程序可能使用FS来存储中间结果、检查进程、下载临时文件、缓存请求结果等等。为此，您可以使用Kubernetes <code class="fe lk ll lm ln b">emptyDir</code>或容器本地存储。</p><h2 id="ecd4" class="lo lp iq bd lq lr ls dn lt lu lv dp lw kx lx ly lz lb ma mb mc lf md me mf mg bi translated">集装箱存储</h2><p id="8def" class="pw-post-body-paragraph ko kp iq kq b kr mh jr kt ku mi ju kw kx mj kz la lb mk ld le lf ml lh li lj ij bi translated">一旦您的容器运行，您已经有了一个与容器映像一起提供的文件系统。这个文件系统是一致的和只读的:每次您启动一个新的容器，您都会在确切的位置获得相同的文件。然而，在容器中并不一定要保持任何东西不变:您可以修改现有文件或创建新文件。这是可能的，因为容器是在带有<a class="ae mm" href="https://en.wikipedia.org/wiki/Copy-on-write" rel="noopener ugc nofollow" target="_blank">写时复制(COW) </a>的<a class="ae mm" href="https://en.wikipedia.org/wiki/UnionFS" rel="noopener ugc nofollow" target="_blank">分层文件系统</a>之上工作的。</p><p id="10f5" class="pw-post-body-paragraph ko kp iq kq b kr ks jr kt ku kv ju kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">正在运行的容器中的任何更改通常会在容器重新启动后丢失。你可以在官方的<a class="ae mm" href="https://docs.docker.com/storage/storagedriver/" rel="noopener ugc nofollow" target="_blank"> docker/storage </a>文档中读到更多关于容器文件系统和实现它的存储驱动的内容。</p><p id="e62b" class="pw-post-body-paragraph ko kp iq kq b kr ks jr kt ku kv ju kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">以上所有内容也适用于包装普通容器的Kubernetes豆荚。如果您需要一点临时存储，您不需要做任何事情:只需启动pod并做您想做的任何事情。</p><p id="6d78" class="pw-post-body-paragraph ko kp iq kq b kr ks jr kt ku kv ju kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">虽然容器的临时存储可能适合用例的子集，但它还具有以下属性:</p><ul class=""><li id="650f" class="mn mo iq kq b kr ks ku kv kx mp lb mq lf mr lj ms mt mu mv bi translated"><strong class="kq ir">容器可写层被绑定到容器的生命周期</strong> —一旦容器消失，可写层也随之消失</li><li id="afbf" class="mn mo iq kq b kr mw ku mx kx my lb mz lf na lj ms mt mu mv bi translated">对于其他进程来说，从这个可写层获取任何东西都可能很棘手</li><li id="4a91" class="mn mo iq kq b kr mw ku mx kx my lb mz lf na lj ms mt mu mv bi translated">为了从容器层创建可用的文件系统，存储驱动程序必须做额外的工作，这有其性能损失</li></ul><p id="c18f" class="pw-post-body-paragraph ko kp iq kq b kr ks jr kt ku kv ju kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">所以接下来是…</p><h2 id="3d54" class="lo lp iq bd lq lr ls dn lt lu lv dp lw kx lx ly lz lb ma mb mc lf md me mf mg bi translated">Kubernetes EmptyDir</h2><p id="bdfa" class="pw-post-body-paragraph ko kp iq kq b kr mh jr kt ku mi ju kw kx mj kz la lb mk ld le lf ml lh li lj ij bi translated">首先，<code class="fe lk ll lm ln b">emptyDir</code>是卷类型之一。当一个Pod被分配到一个节点时，一个<code class="fe lk ll lm ln b">emptyDir</code>卷首先被创建，最初，它是…(你不会相信的！)空的。</p><p id="e714" class="pw-post-body-paragraph ko kp iq kq b kr ks jr kt ku kv ju kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">这种卷类型可以解决上面列出的一些限制:</p><ul class=""><li id="013c" class="mn mo iq kq b kr ks ku kv kx mp lb mq lf mr lj ms mt mu mv bi translated"><code class="fe lk ll lm ln b">emptyDir</code>可以在pod内的所有容器之间共享</li><li id="363b" class="mn mo iq kq b kr mw ku mx kx my lb mz lf na lj ms mt mu mv bi translated"><strong class="kq ir">卷遵循pod生命周期</strong> —它是与Pod一起创建的，只有在Pod被删除后才会被删除。</li><li id="35d1" class="mn mo iq kq b kr mw ku mx kx my lb mz lf na lj ms mt mu mv bi translated">如果容器崩溃(错误、内存不足或任何原因)，它将与其临时可写存储层一起被删除。如果Pod支持容器，kubelet可能会在同一节点上重新创建一个新的容器，但是容器FS将与容器映像中的一样，没有您在那里所做的所有临时更改。但是容器崩溃不会将pod从节点上删除，因此在容器重启后，<code class="fe lk ll lm ln b">emptyDir</code>卷中的数据是安全的。例如，这允许对长时间的计算进行检查点操作，以便从意外故障中恢复。</li><li id="208d" class="mn mo iq kq b kr mw ku mx kx my lb mz lf na lj ms mt mu mv bi translated"><code class="fe lk ll lm ln b">emptyDir</code>是一个Linux原生文件系统，速度更快，并且没有容器存储驱动的损失。</li></ul><p id="23e6" class="pw-post-body-paragraph ko kp iq kq b kr ks jr kt ku kv ju kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">此外，<code class="fe lk ll lm ln b">emptyDir</code>允许你定义最大大小和使用内存作为存储介质。想象一下，所有容器都无限制地写入主机文件系统，因此唯一的流氓容器可以消耗整个磁盘空间，并给所有邻居造成问题。老实说，<code class="fe lk ll lm ln b">sizeLimit</code>并没有完全消除这样的问题，但是它至少可以在一定程度上控制空间的使用。</p><p id="daf8" class="pw-post-body-paragraph ko kp iq kq b kr ks jr kt ku kv ju kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">这里有一份api-reference用于之前提到的<code class="fe lk ll lm ln b">emptyDir</code>参数:</p><blockquote class="nb nc nd"><p id="129d" class="ko kp ne kq b kr ks jr kt ku kv ju kw nf ky kz la ng lc ld le nh lg lh li lj ij bi translated"><code class="fe lk ll lm ln b"><em class="iq">medium</em></code> <em class="iq"> <br/>什么类型的存储介质应该备份这个目录。默认值为“”，表示使用节点的默认介质。必须是空字符串(默认)或内存。更多信息:</em><a class="ae mm" href="https://kubernetes.io/docs/concepts/storage/volumes#emptydir" rel="noopener ugc nofollow" target="_blank"><em class="iq">https://kubernetes . io/docs/concepts/storage/volumes # empty dir</em></a></p><p id="4184" class="ko kp ne kq b kr ks jr kt ku kv ju kw nf ky kz la ng lc ld le nh lg lh li lj ij bi translated"><code class="fe lk ll lm ln b"><em class="iq">sizeLimit</em></code> <em class="iq"> <br/>此EmptyDir卷所需的本地存储总量。大小限制也适用于存储介质。内存介质EmptyDir的最大使用量是此处指定的SizeLimit和pod中所有容器的内存限制总和之间的最小值。默认值为零，这意味着未定义限制。更多信息:</em><a class="ae mm" href="http://kubernetes.io/docs/user-guide/volumes#emptydir" rel="noopener ugc nofollow" target="_blank"><em class="iq">http://kubernetes.io/docs/user-guide/volumes#emptydir</em></a></p></blockquote><h2 id="a7df" class="lo lp iq bd lq lr ls dn lt lu lv dp lw kx lx ly lz lb ma mb mc lf md me mf mg bi translated">如何选择？</h2><p id="e5a9" class="pw-post-body-paragraph ko kp iq kq b kr mh jr kt ku mi ju kw kx mj kz la lb mk ld le lf ml lh li lj ij bi translated">在我看来，如果:</p><ul class=""><li id="5698" class="mn mo iq kq b kr ks ku kv kx mp lb mq lf mr lj ms mt mu mv bi translated">您需要在同一个pod内的容器之间共享文件系统的一部分</li><li id="c7f1" class="mn mo iq kq b kr mw ku mx kx my lb mz lf na lj ms mt mu mv bi translated">应用程序大量使用临时存储，性能至关重要</li><li id="7d71" class="mn mo iq kq b kr mw ku mx kx my lb mz lf na lj ms mt mu mv bi translated">您需要对您的流程进行检查点检查，使其能够经受住意外的容器崩溃</li><li id="ac84" class="mn mo iq kq b kr mw ku mx kx my lb mz lf na lj ms mt mu mv bi translated">您需要控制单个pod可以使用多少磁盘空间</li></ul><p id="4900" class="pw-post-body-paragraph ko kp iq kq b kr ks jr kt ku kv ju kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">在所有其他情况下，什么都不做，坚持使用容器本地可写层。</p></div></div>    
</body>
</html>