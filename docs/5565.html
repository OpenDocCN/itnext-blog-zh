<html>
<head>
<title>How and when to ignore lifecycle changes in Terraform</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何以及何时忽略Terraform中的生命周期变化</h1>
<blockquote>原文：<a href="https://itnext.io/how-and-when-to-ignore-lifecycle-changes-in-terraform-ed5bfb46e7ae?source=collection_archive---------0-----------------------#2021-04-06">https://itnext.io/how-and-when-to-ignore-lifecycle-changes-in-terraform-ed5bfb46e7ae?source=collection_archive---------0-----------------------#2021-04-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/e4cb03ea7e472c0742d14b834a4537a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*swfmlQ2EXdFtX6F_.jpeg"/></div></div></figure><h1 id="d430" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">介绍</h1><p id="29cc" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">Terraform是一个非常有用的工具，用于将<a class="ae lu" href="https://stackify.com/what-is-infrastructure-as-code-how-it-works-best-practices-tutorials/" rel="noopener ugc nofollow" target="_blank">基础设施管理为代码(IaC) </a>，它允许我们通过一种通用语言(<a class="ae lu" href="https://www.terraform.io/docs/language/syntax/configuration.html" rel="noopener ugc nofollow" target="_blank"> HCL </a>或JSON)轻松定义我们想要的状态，然后使用Terraform引擎，解析这个想要的状态，将其与实际状态进行比较，并对我们的环境进行必要的更新。很明显，Terraform的最大好处是这种基于增量的方法，通过这种方法，我们只需更新/创建/销毁最少量的必要内容，并保持我们的环境一致。</p><p id="7daf" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">但是，如果Terraform的工作方式与您预期的不太一样，会发生什么呢？为什么Terraform有时会导致你的环境破坏？更重要的是，你何时/如何告诉Terraform忽略你知道是安全的东西。</p><p id="de63" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">和我所有的博客帖子一样，如果你很急，想要TL；这个博客的博士版本，然后你会发现标题在底部，为您提供方便🙂</p><h1 id="3698" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">这都是关于国家的</h1><p id="6404" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">好的，所以在我们继续之前，我只想确保我们涵盖了Terraform如何工作以及它如何决定做什么(和不做什么)的基础知识。</p><p id="b426" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">简单来说，Terraform是一个基于状态的引擎。当terraform运行时，它首先会查看您想要的内容(期望的状态)并扫描您的云平台中的内容(实际状态)。一旦知道了期望状态和实际状态，Terraform接下来要做的就是计算一个简单的增量:</p><ul class=""><li id="2e58" class="ma mb iq ky b kz lv ld lw lh mc ll md lp me lt mf mg mh mi bi translated">如果某样东西存在于你想要的状态，但不存在于实际状态——<strong class="ky ir">它会被创建</strong>。</li><li id="1538" class="ma mb iq ky b kz mj ld mk lh ml ll mm lp mn lt mf mg mh mi bi translated">如果某个东西存在，并且处于期望状态和实际状态，但是配置不同— <strong class="ky ir">它会得到更新</strong>。</li><li id="84b6" class="ma mb iq ky b kz mj ld mk lh ml ll mm lp mn lt mf mg mh mi bi translated">如果某个东西存在于实际状态，但不在期望状态— <strong class="ky ir">它会被删除</strong>。</li></ul><p id="12f7" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">原则上似乎很简单，对吗？但遗憾的是，有时正是Terraform采用的这种简单的基于状态的机制会给我们带来一些大麻烦。</p><h1 id="36b8" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">什么时候改变不是改变？</h1><p id="31ae" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">好的，让我们假设我们有一个假想的场景，我们编写一些Terraform并部署它:</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/fa54c4329a9a3e5b61c8aef7c6dc9f0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1116/format:webp/1*bvcVU12ObYqQvXZOTIDKFQ.png"/></div></figure><p id="8427" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">这是一个非常简化的图，但是我想表达的意思是，通常你会在<code class="fe mt mu mv mw b">.tf</code>文件中定义你想要的状态。Terraform也知道它上次部署了什么，因为它将这些信息保存在一个<code class="fe mt mu mv mw b">.state</code>文件中。如果这是您的第一次部署，那么该文件将不存在，Terraform会创建它。然后我们的云提供商(Azure)就有了实际的状态——理想状态的真实表现。</p><p id="c26b" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">现在让我们放大这一薄片，并进一步探索。下面是我们的<code class="fe mt mu mv mw b">logicapp.tf</code>文件的一个假设示例:</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="c11a" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">这个HCL理论上将部署我们假设的逻辑应用程序。我添加了一些智能来将Logic应用程序的ARM模板加载到一个本地变量中，然后使用文件的MD5作为模板部署的名称。现在这个文件足够简单了，但是让我们检查第9行:</p><pre class="mp mq mr ms gt mz mw na nb aw nc bi"><span id="81e9" class="nd jz iq mw b gy ne nf l ng nh">tags = ["test"]</span></pre><p id="b0f2" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">那么，我为什么要求你考虑这条线呢？这是因为这个属性很可能是一个潜在的例子，可以手动更改或在Azure中自动设置，而无需Terraform，对此一无所知。</p><h1 id="b7b0" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">我正在经历变化🎶</h1><p id="9f18" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">让我们假设我们已经部署了上面显示的Terraform，并且我们的Logic应用程序已经部署完毕，并且正在按照我们预期的方式工作。接下来是一些自动过程或者说是Azure策略，它给我们的逻辑应用添加了一些标签。<a class="ae lu" href="https://docs.microsoft.com/en-us/azure/azure-resource-manager/management/tag-resources" rel="noopener ugc nofollow" target="_blank">标签</a>只是元数据，所以它们并不真正影响资源本身，但是它们使管理变得更加容易。但是不幸的是，当我们下一次部署代码时会发生什么呢？</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/2e7b550474e538006aa6ab79658bac56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1188/format:webp/1*RoGhYiD7YjNvuEySkV-VwA.png"/></div></figure><p id="d8fe" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">首先发生的是Terraform试图找出我们拥有的和我们想要的之间的差距。记住:我们的本地配置说我们不想要任何标签，但是Azure中资源的状态说它有标签！那么terraform是做什么的呢？</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/3c7c52ebad0195aac2a85e420e832e4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1188/format:webp/1*tzMFqbANK0u2nAe4MQKXLg.png"/></div></figure><p id="35f3" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">原来Terraform会做它认为我们想要的事情。我们说过我们不想要标签，所以它会删除标签。哎呦！</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/672e9f760c3abc46e748246c08e49436.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/0*mD1OqULHREo6nCHC.gif"/></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk translated">Terraform为什么要这么做？！？！？！？！</figcaption></figure><h1 id="3b53" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">这有什么大不了的？！？！？只是标签而已</h1><p id="772c" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">好吧，我承认我上面举的例子很做作，但是当Terraform可能带来的潜在变化更具破坏性时呢？</p><p id="4d8c" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">事实证明，逻辑应用程序及其ARM模板实际上非常复杂。Azure在幕后为我们神奇地处理了许多自动生成的参数。一个主要的例子是当你使用<a class="ae lu" href="https://docs.microsoft.com/en-us/azure/logic-apps/logic-apps-azure-resource-manager-templates-overview#secure-connection-parameters" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">安全连接参数</strong> </a> <strong class="ky ir">时。</strong>在本例中，请考虑以下片段:</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="e8ab" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">取自示例页面的片段<a class="ae lu" href="https://docs.microsoft.com/en-us/azure/logic-apps/logic-apps-azure-resource-manager-templates-overview#secure-connection-parameters" rel="noopener ugc nofollow" target="_blank">显示了安全连接参数如何作为名为<code class="fe mt mu mv mw b">$connections</code>的属性嵌入到ARM中。</a></p><p id="9c2c" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">因此，我们通过Terraform部署了逻辑应用程序，并对模式进行了更新…当我们尝试协调状态时，现在会发生什么？在我们去那里之前，让我们看一下我们的Terraform <code class="fe mt mu mv mw b">tfstate</code>文件:</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="08a1" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">等一下！第20 线<strong class="ky ir">那个<code class="fe mt mu mv mw b">parameters</code>的东西是哪里来的？而且为什么包含设置为空字符串的<code class="fe mt mu mv mw b">$connections</code>？！？！</strong></p><p id="eb54" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">这是Terraform的众多怪癖之一，你使用这项技术的次数越多，就越有可能遇到这种怪癖。记得我之前说过，在部署期间的状态协调步骤中；Terraform将收回它创建的已配置对象的状态，并将它们存储在其状态文件中。为了回答我们的问题，这是我们部署的逻辑应用程序的实际状态表示。无论我们是否要求，这种资源都有一些属性。现在的问题是，我们在Azure中运行的逻辑应用程序需要这些连接才能工作(假设它使用这些连接来连接到另一个服务，如blob store)，但现在我们有一个问题:</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi no"><img src="../Images/209d1c56a32267d0b20f95f70ff1e99d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WyN7bTqGrt6seSTEkRtDNg.png"/></div></div></figure><p id="9833" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">和以前一样，Terraform将协调状态，决定我们不再需要那些<code class="fe mt mu mv mw b">$connections</code>并清除它们…所以突然砰的一声，我们以前工作的逻辑应用程序通过没有我们自己的错误！！！</p><h1 id="e164" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">那么我该如何避免这种情况呢？？？？</h1><p id="3109" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">幸运的是，亲爱的读者，帮助就在眼前，它是一个鲜为人知的Terraform特性，名为“<a class="ae lu" href="https://www.terraform.io/docs/language/meta-arguments/lifecycle.html" rel="noopener ugc nofollow" target="_blank">生命周期元参数</a>”。很吸引人的名字对吗？？？？)</p><p id="9a9f" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">使用这个元参数允许我们以多种方式覆盖Terraform的默认行为，但是我们感兴趣的主要方式是这里的<code class="fe mt mu mv mw b"><a class="ae lu" href="https://www.terraform.io/docs/language/meta-arguments/lifecycle.html#ignore_changes" rel="noopener ugc nofollow" target="_blank">ignore_changes</a></code>属性:</p><blockquote class="np nq nr"><p id="46f8" class="kw kx ns ky b kz lv lb lc ld lw lf lg nt lx lj lk nu ly ln lo nv lz lr ls lt ij bi translated"><code class="fe mt mu mv mw b">ignore_changes</code>功能旨在当创建的资源引用的数据可能在未来发生变化时使用，但不应在创建后影响所述资源。在极少数情况下，远程对象的设置被Terraform之外的进程修改，Terraform将在下次运行时尝试“修复”</p></blockquote><p id="0da5" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">那么这在我们的代码中是什么样子的呢？嗯，如果我们对我们的示例Terraform HCL进行必要的更改，我们应该会得到如下结果:</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="0aab" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">正如您所看到的，通过将<code class="fe mt mu mv mw b">lifecycle</code>参数添加到我们的资源定义中，我们基本上可以防止Terraform对与逻辑应用程序相关的参数或标签进行进一步的更改。你现在可以认为这是“一次且只有一次”的行动。我们第一次执行Terraform <code class="fe mt mu mv mw b">apply</code>动作时，逻辑应用程序被创建，Terraform会给我们想要的东西，并像往常一样更新与逻辑应用程序相关的所有内容，但如果标签或参数发生变化，它们将被忽略。</p><h2 id="e9c2" class="nd jz iq bd ka nw nx dn ke ny nz dp ki lh oa ob km ll oc od kq lp oe of ku og bi translated"><strong class="ak">重要的</strong></h2><p id="140c" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我想在这里明确几点:</p><ol class=""><li id="6b70" class="ma mb iq ky b kz lv ld lw lh mc ll md lp me lt oh mg mh mi bi translated">这里提到的<code class="fe mt mu mv mw b">parameters</code>与传递到ARM模板部署中的并不相同，所以您可以安全地更改它们，它们将被部署。</li><li id="8e9c" class="ma mb iq ky b kz mj ld mk lh ml ll mm lp mn lt oh mg mh mi bi translated"><strong class="ky ir">这不是一个理想的情况</strong>，这似乎是平台行为和一些资源/提供者如何运作之间的一个奇怪的怪癖。</li><li id="af88" class="ma mb iq ky b kz mj ld mk lh ml ll mm lp mn lt oh mg mh mi bi translated">在何时何地使用这个生命周期参数要小心；我强烈建议将它视为防止重大变更的最后手段。</li></ol><h1 id="6530" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">另一个例子</h1><p id="c87c" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">到目前为止，我已经展示了当Terraform意外地让我们的工作基础设施处于崩溃状态时会发生什么。但是，当Terraform可能意外地引起变化，从而导致间歇性停机和性能问题时，会发生什么情况呢？</p><p id="7ce5" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">以下列Terraform HCL为例:</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="f2b5" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">这是我最近参与的一个项目的真实例子。我已经包含了必要的<code class="fe mt mu mv mw b">ignore_changes</code>指令，所以它应该开始给你一个提示，告诉你问题是什么。</p><p id="ffe2" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">上面的配置片段旨在在VNet中提供一些子网，我们需要划分子网的一个东西是一个<a class="ae lu" href="https://docs.microsoft.com/en-gb/azure/container-instances/container-instances-overview" rel="noopener ugc nofollow" target="_blank"> Azure容器实例</a>，它充当一个<a class="ae lu" href="https://docs.microsoft.com/en-us/azure/devops/pipelines/agents/agents?view=azure-devops&amp;tabs=browser#install" rel="noopener ugc nofollow" target="_blank">自托管AzDO构建代理</a>。为了让我们的ACI正确地加入到我们的VNet中，并且有必要的权限访问东西，我们授予它一些<code class="fe mt mu mv mw b">service_delegation</code>属性。</p><p id="c503" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">然而，与我们的逻辑应用程序类似，一旦创建了这个资源，Azure就会在幕后更改这些委托。这意味着，当我们再次运行Terraform部署时，我们的子网每次都会发生变化，从而导致我们的ACI在子网配置更新的短暂时间内失去VNet集成。</p><p id="7f1d" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">这是一个由Terraform进行意外更改而导致的瞬态问题的完美例子，这可能会让我们感到很困惑，因为我们会想为什么我们的构建代理突然告诉我们它无法访问我们的任何网络资源，如存储等。</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/8005e4cb97271c83b6c64ad435e70137.png" data-original-src="https://miro.medium.com/v2/resize:fit:712/0*_xRrBhymuCj1am9v.gif"/></div></figure><h1 id="d256" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">TL；速度三角形定位法(dead reckoning)</h1><ul class=""><li id="9bda" class="ma mb iq ky b kz la ld le lh oj ll ok lp ol lt mf mg mh mi bi translated">有时，虽然不是我们自己的错，Terraform可以破坏我们的基础设施。</li><li id="1eb4" class="ma mb iq ky b kz mj ld mk lh ml ll mm lp mn lt mf mg mh mi bi translated">Terraform尽最大努力协调我们的期望状态和我们的云提供商的实际状态，有时这可能会产生不利影响。</li><li id="c747" class="ma mb iq ky b kz mj ld mk lh ml ll mm lp mn lt mf mg mh mi bi translated">部署资源时，云资源提供商可以在我们不知情的情况下，在幕后添加额外的属性/特性。</li><li id="0def" class="ma mb iq ky b kz mj ld mk lh ml ll mm lp mn lt mf mg mh mi bi translated">这些附加属性/特性中的大部分都是完全良性的，但是其他的可能会影响正常运行的基础架构或开发运维流程。</li><li id="0d00" class="ma mb iq ky b kz mj ld mk lh ml ll mm lp mn lt mf mg mh mi bi translated">当你想让Terraform忽略后续<code class="fe mt mu mv mw b">apply</code>命令之间的变化时，你可以使用<code class="fe mt mu mv mw b">lifecycle</code> <code class="fe mt mu mv mw b">ignore_changes</code>元参数。</li><li id="79e4" class="ma mb iq ky b kz mj ld mk lh ml ll mm lp mn lt mf mg mh mi bi translated"><code class="fe mt mu mv mw b">ignore_changes</code>参数意味着Terraform将在首次部署资源时设置值，然后永远忽略对它的任何更改。</li><li id="21fa" class="ma mb iq ky b kz mj ld mk lh ml ll mm lp mn lt mf mg mh mi bi translated">除了<code class="fe mt mu mv mw b">ignore_changes</code>之外，<code class="fe mt mu mv mw b">lifecycle</code>元参数还有很多有趣的功能，我强烈推荐你尝试一下。</li><li id="bfc6" class="ma mb iq ky b kz mj ld mk lh ml ll mm lp mn lt mf mg mh mi bi translated">检查您的Terraform <code class="fe mt mu mv mw b">plan</code>和<code class="fe mt mu mv mw b">apply</code>输出，查看您是否只更新/更改了您期望看到的内容。</li></ul><h1 id="4bf4" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">进一步阅读</h1><ul class=""><li id="c8b4" class="ma mb iq ky b kz la ld le lh oj ll ok lp ol lt mf mg mh mi bi translated"><a class="ae lu" href="https://stackoverflow.com/questions/55217929/terraform-breaking-azure-logic-app-connections" rel="noopener ugc nofollow" target="_blank"> Terraform破坏Azure Logic应用程序连接—堆栈溢出</a> —这篇Stack Overflow帖子是帮助我发现这个问题和修复的最初线索</li><li id="7afd" class="ma mb iq ky b kz mj ld mk lh ml ll mm lp mn lt mf mg mh mi bi translated"><a class="ae lu" href="https://www.terraform.io/docs/language/meta-arguments/lifecycle.html" rel="noopener ugc nofollow" target="_blank">https://www . terra form . io/docs/language/meta-arguments/life cycle . html</a>—terra form生命周期文档，一个非常好的开始阅读的地方</li><li id="957f" class="ma mb iq ky b kz mj ld mk lh ml ll mm lp mn lt mf mg mh mi bi translated"><a class="ae lu" href="https://docs.microsoft.com/en-us/azure/logic-apps/logic-apps-azure-resource-manager-templates-overview" rel="noopener ugc nofollow" target="_blank">概述— Azure Logic应用的自动化部署—Azure Logic应用| Microsoft文档</a> —如果您计划通过IaC部署Azure Logic应用，那么这是<em class="ns">您需要阅读的页面</em></li></ul></div></div>    
</body>
</html>