<html>
<head>
<title>React — Loading Components Dynamically</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React —动态加载组件</h1>
<blockquote>原文：<a href="https://itnext.io/react-loading-components-dynamically-a9d8549844c4?source=collection_archive---------2-----------------------#2018-06-05">https://itnext.io/react-loading-components-dynamically-a9d8549844c4?source=collection_archive---------2-----------------------#2018-06-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/ae6552b8dd2e9d41649edddde58dcc5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Pim_ZauhEO5s-BOkT3zM8A.jpeg"/></div></div></figure><p id="b1ed" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当您编写React应用程序时，对于大多数项目来说，所有组件都是一次加载的，这是一件好事，因为一旦应用程序在客户端上完全加载，并且您处于离线状态，所有组件都在那里！</p><p id="e07e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一些项目要求模块化架构，用户只加载应用程序的一部分——假设你想为每种类型的用户加载不同的应用程序。多亏了<a class="ae kx" href="https://reactjs.org/docs/code-splitting.html" rel="noopener ugc nofollow" target="_blank"><em class="kw">React Code-Splitting</em></a>和<a class="ae kx" href="https://webpack.js.org/guides/code-splitting/" rel="noopener ugc nofollow" target="_blank"> <em class="kw"> Webpack </em>支持</a>这才能做到。</p><p id="0eeb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里我要展示的例子非常简单，没有考虑复杂的应用架构或服务器端渲染的其他策略，但这是实现模块化架构的一个很好的起点。</p><p id="7a33" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">除了React代码分割和Webpack，参考<a class="ae kx" href="https://www.npmjs.com/package/react-loadable" rel="noopener ugc nofollow" target="_blank"> react-loadable </a>也很重要，因为它非常容易处理代码分割。</p><p id="08d4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是用<strong class="ka ir">react-loaded</strong>定义一个组件的样子:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="0290" class="lh li iq ld b gy lj lk l ll lm">let MyComponent = Loadable({<br/>  loader: () =&gt; import('./MyComponent'),<br/>  loading: () =&gt; &lt;div&gt;Loading...&lt;/div&gt;<br/>});</span></pre><p id="c612" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我写这篇文章的时候，我正在使用CRA 1 . 1 . 4和react-loadable 5.4.0。</p><p id="1552" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面的例子是基于CRA。我只是把标题和主体分成两个独立的部分(见下文)，让最初的应用程序在初始加载时更小更快。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="cac0" class="lh li iq ld b gy lj lk l ll lm">import React, { Component } from 'react';<br/>import Loadable from 'react-loadable';<br/>import './App.css';</span><span id="c9fe" class="lh li iq ld b gy ln lk l ll lm">// Modules configured. This can come from a database...<br/>const available = ['Header', 'Body'];</span><span id="97d3" class="lh li iq ld b gy ln lk l ll lm">class App extends Component {<br/>  state = { modules: [], active: [] };</span><span id="4c42" class="lh li iq ld b gy ln lk l ll lm">  // Toggle module<br/>  toggleModule = (nome) =&gt; {<br/>    const { active } = this.state, modules = [];</span><span id="372f" class="lh li iq ld b gy ln lk l ll lm">    // Add or remove from list<br/>    let i = active.indexOf(nome);<br/>    if (i &gt; -1) active.splice(i, 1);<br/>    else active.push(nome);</span><span id="63a8" class="lh li iq ld b gy ln lk l ll lm">    // Create loadables. THIS IS THE MAGIC!<br/>    active.map(m =&gt; {<br/>      return modules.push(Loadable({<br/>        loader: () =&gt; import('./'+m), // Here can be any component!<br/>        loading: () =&gt; &lt;div&gt;Loading { m }...&lt;/div&gt;,<br/>      }));<br/>    });<br/>    this.setState({ ...this.state, modules, active });<br/>  }</span><span id="ad71" class="lh li iq ld b gy ln lk l ll lm">  render() {<br/>    const { modules, active } = this.state;<br/>    return (<br/>      &lt;div className="App"&gt;</span><span id="cf59" class="lh li iq ld b gy ln lk l ll lm">        { modules.map((item, i) =&gt; {<br/>          let Module = modules[i]<br/>          return &lt;Module key={i} /&gt;<br/>        }) }</span><span id="1f49" class="lh li iq ld b gy ln lk l ll lm">        &lt;ul&gt;<br/>          { available.map((name, i) =&gt; (<br/>            &lt;li key={i}&gt;<br/>              { name }<br/>              &lt;input type="checkbox"<br/>                checked={active.indexOf(name) &gt; -1}<br/>                onClick={e =&gt; this.toggleModule(name)}<br/>              /&gt;<br/>            &lt;/li&gt;<br/>          ))}<br/>        &lt;/ul&gt;<br/>      &lt;/div&gt;<br/>    );<br/>  }<br/>}</span><span id="5db8" class="lh li iq ld b gy ln lk l ll lm">export default App;</span></pre><p id="031a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">出于演示的目的，我将活动组件保持在本地<em class="kw">状态</em>，并且我还呈现了可用组件的列表，以让用户触发<strong class="ka ir">模块化行为</strong>。</p><p id="8d16" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了完成这个例子，下面是<em class="kw"> Header.js </em>:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="2737" class="lh li iq ld b gy lj lk l ll lm">import React from 'react';<br/>import logo from './logo.svg';</span><span id="dba7" class="lh li iq ld b gy ln lk l ll lm">const Header = () =&gt; (<br/>  &lt;header className="App-header"&gt;<br/>    &lt;img src={logo} className="App-logo" alt="logo" /&gt;<br/>    &lt;h1 className="App-title"&gt;Welcome to React&lt;/h1&gt;<br/>  &lt;/header&gt;<br/>)</span><span id="d9e9" class="lh li iq ld b gy ln lk l ll lm">export default Header;</span></pre><p id="7f5d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">…还有Body.js:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="877c" class="lh li iq ld b gy lj lk l ll lm">import React from 'react';</span><span id="77c8" class="lh li iq ld b gy ln lk l ll lm">const Body = () =&gt; (<br/>  &lt;p className="App-intro"&gt;<br/>    To get started, edit &lt;code&gt;src/App.js&lt;/code&gt; and save to reload.<br/>  &lt;/p&gt;<br/>)</span><span id="c441" class="lh li iq ld b gy ln lk l ll lm">export default Body;</span></pre><p id="c1f2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">运行应用程序，并在切换项目时查看您的网络通话。</p><p id="685e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">玩得开心！:)</p></div></div>    
</body>
</html>