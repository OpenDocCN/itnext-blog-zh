<html>
<head>
<title>Predictive offline support for assets you have not used yet</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">对您尚未使用的资产的预测性离线支持</h1>
<blockquote>原文：<a href="https://itnext.io/predictive-offline-support-for-assets-you-have-not-used-yet-aeeccccd3754?source=collection_archive---------3-----------------------#2022-03-28">https://itnext.io/predictive-offline-support-for-assets-you-have-not-used-yet-aeeccccd3754?source=collection_archive---------3-----------------------#2022-03-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="40c2" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">预加载资产，一个服务和应用工作者的爱情故事</h2></div><p id="9a61" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您关心您的应用程序用户接近实时地在不同视图之间导航，那么这篇文章就是为您准备的。</p><h1 id="6f02" class="lb lc iq bd ld le lf lg lh li lj lk ll jw lm jx ln jz lo ka lp kc lq kd lr ls bi translated">内容</h1><ol class=""><li id="1d96" class="lt lu iq kh b ki lv kl lw ko lx ks ly kw lz la ma mb mc md bi translated">介绍</li><li id="3ad0" class="lt lu iq kh b ki me kl mf ko mg ks mh kw mi la ma mb mc md bi translated">演示应用程序</li><li id="fdf3" class="lt lu iq kh b ki me kl mf ko mg ks mh kw mi la ma mb mc md bi translated">远程方法访问</li><li id="d3f5" class="lt lu iq kh b ki me kl mf ko mg ks mh kw mi la ma mb mc md bi translated">爱情故事</li><li id="2bef" class="lt lu iq kh b ki me kl mf ko mg ks mh kw mi la ma mb mc md bi translated">范围界定的困境</li><li id="3639" class="lt lu iq kh b ki me kl mf ko mg ks mh kw mi la ma mb mc md bi translated">JS模块的服务人员</li><li id="322d" class="lt lu iq kh b ki me kl mf ko mg ks mh kw mi la ma mb mc md bi translated">离线支持</li><li id="dbf9" class="lt lu iq kh b ki me kl mf ko mg ks mh kw mi la ma mb mc md bi translated">多页面应用程序</li><li id="29c6" class="lt lu iq kh b ki me kl mf ko mg ks mh kw mi la ma mb mc md bi translated">多窗口应用程序</li><li id="114e" class="lt lu iq kh b ki me kl mf ko mg ks mh kw mi la ma mb mc md bi translated">neo.mjs v4版本</li><li id="74a4" class="lt lu iq kh b ki me kl mf ko mg ks mh kw mi la ma mb mc md bi translated">在线演示</li><li id="3ef6" class="lt lu iq kh b ki me kl mf ko mg ks mh kw mi la ma mb mc md bi translated">最后的想法</li></ol><h1 id="919c" class="lb lc iq bd ld le lf lg lh li lj lk ll jw lm jx ln jz lo ka lp kc lq kd lr ls bi translated">1.介绍</h1><p id="77f3" class="pw-post-body-paragraph kf kg iq kh b ki lv jr kk kl lw ju kn ko mj kq kr ks mk ku kv kw ml ky kz la ij bi translated">虽然<a class="ae mm" href="https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API" rel="noopener ugc nofollow" target="_blank">服务人员</a>已经存在了相当一段时间，但我主要是在移动范围内看到他们。缓存已经加载的资产是一种常见的做法，但是使用后台下载为下一个导航目标获取资产的主题还没有得到应有的关注。</p><h1 id="5058" class="lb lc iq bd ld le lf lg lh li lj lk ll jw lm jx ln jz lo ka lp kc lq kd lr ls bi translated">2.演示应用程序</h1><p id="629e" class="pw-post-body-paragraph kf kg iq kh b ki lv jr kk kl lw ju kn ko mj kq kr ks mk ku kv kw ml ky kz la ij bi translated">我尽最大努力让这个演示应用程序尽可能简单。这个2米长的视频将帮助你快速理解这个想法:</p><figure class="mn mo mp mq gt mr"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="0c9d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">加载初始视图后，我们通过后台下载获取Alice的图像，并将其存储在浏览器缓存中，因为我们假设用户接下来很可能会导航到这里。因为我们确实使用缓存资产以防它们可用，所以我们可以接近实时地切换到目标视图，并且在我们首先禁用我们的互联网连接的情况下它也是有效的。</p><p id="8d76" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">真实世界用例:</strong> <br/>另一个合适的例子是基于web的商店应用程序。假设用户正在查看产品概述页面。使用分析工具或机器学习，你可能已经有了关于最常见的用户旅程的数据，所以你已经知道你的用户下一步最有可能导航到哪里。经过一段时间的延迟后，你现在已经可以为你的x个最受欢迎的产品获取资产了。一旦用户导航到那里，转换将几乎立即发生，因为不需要进一步下载资产。</p><h1 id="fd7f" class="lb lc iq bd ld le lf lg lh li lj lk ll jw lm jx ln jz lo ka lp kc lq kd lr ls bi translated">3.远程方法访问</h1><p id="225b" class="pw-post-body-paragraph kf kg iq kh b ki lv jr kk kl lw ju kn ko mj kq kr ks mk ku kv kw ml ky kz la ij bi translated">为了尽可能方便地与服务人员交流，我们希望能够“直接”触发相关方法:</p><figure class="mn mo mp mq gt mr"><div class="bz fp l di"><div class="mu mt l"/></div></figure><p id="6b46" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">显然，<code class="fe mv mw mx my b">Neo.ServiceWorker</code>既不存在于主线程中，也不存在于应用程序工作线程中。您可以像RPC一样考虑这种技术:</p><div class="mz na gp gr nb nc"><a href="https://en.wikipedia.org/wiki/Remote_procedure_call" rel="noopener  ugc nofollow" target="_blank"><div class="nd ab fo"><div class="ne ab nf cl cj ng"><h2 class="bd ir gy z fp nh fr fs ni fu fw ip bi translated">远程过程调用-维基百科</h2><div class="nj l"><h3 class="bd b gy z fp nh fr fs ni fu fw dk translated">在分布式计算中，远程过程调用(RPC)是指计算机程序使一个过程(子例程)执行…</h3></div><div class="nk l"><p class="bd b dl z fp nh fr fs ni fu fw dk translated">en.wikipedia.org</p></div></div><div class="nl l"><div class="nm l nn no np nl nq nr nc"/></div></div></a></div><p id="57c1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">主要的区别在于，我们不需要(或不想)在等待响应时阻塞线程。</p><p id="df1a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们的服务工作者实现的基类中，我们通过以下方式向特定的目标领域(在本例中为应用工作者)公开方法:</p><figure class="mn mo mp mq gt mr"><div class="bz fp l di"><div class="mu mt l"/></div></figure><p id="32e6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦新页面连接到我们的服务工作者，它将通过post消息接收新的API，并在目标线程中注册名称空间。</p><p id="4173" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">远程方法访问不限于SWs，也适用于专用和共享工作线程以及主线程。</p><p id="50e2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们调用一个远程方法，我们将收到作为承诺的返回值，因为内部post消息链是异步的。你可以把它想象成ajax调用，只是更快一些。</p><p id="25aa" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">目标方法可以选择异步:</p><figure class="mn mo mp mq gt mr"><div class="bz fp l di"><div class="mu mt l"/></div></figure><p id="e7f2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是一个不同的示例，展示了一个将被公开的非异步方法:</p><figure class="mn mo mp mq gt mr"><div class="bz fp l di"><div class="mu mt l"/></div></figure><p id="95e8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请注意，无论如何调用它都将保持异步:</p><p id="a7c1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mv mw mx my b">Neo.main.DomAccess.getBoundingClientRect('myId').then(rect =&gt; {/* do stuff */})</code></p><p id="556c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">可以在这里看一下实现:<br/><a class="ae mm" href="https://github.com/neomjs/neo/blob/dev/src/worker/mixin/RemoteMethodAccess.mjs" rel="noopener ugc nofollow" target="_blank">src/worker/mixin/remotemethodaccess . mjs</a></p><h1 id="faf2" class="lb lc iq bd ld le lf lg lh li lj lk ll jw lm jx ln jz lo ka lp kc lq kd lr ls bi translated">4.爱情故事</h1><p id="0ecf" class="pw-post-body-paragraph kf kg iq kh b ki lv jr kk kl lw ju kn ko mj kq kr ks mk ku kv kw ml ky kz la ij bi translated">想象一下，你需要通过中间的一个人把每一条私人信息传递给你心爱的人。我敢肯定，由于隐私问题和延误，你不会太喜欢它。</p><p id="221a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这同样适用于我们的服务人员和我们的(专用或共享)应用人员之间的沟通。虽然我们可以通过主线程传递post消息，但出于同样的原因，我们希望避免这样做。</p><p id="3cc5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们很幸运，因为MessageChannel API是可用的:</p><div class="mz na gp gr nb nc"><a href="https://developer.mozilla.org/en-US/docs/Web/API/MessageChannel" rel="noopener  ugc nofollow" target="_blank"><div class="nd ab fo"><div class="ne ab nf cl cj ng"><h2 class="bd ir gy z fp nh fr fs ni fu fw ip bi translated">消息通道-Web API | MDN</h2><div class="nj l"><h3 class="bd b gy z fp nh fr fs ni fu fw dk translated">通道消息传递API的MessageChannel接口允许我们创建新的消息通道并发送数据…</h3></div><div class="nk l"><p class="bd b dl z fp nh fr fs ni fu fw dk translated">developer.mozilla.org</p></div></div><div class="nl l"><div class="ns l nn no np nl nq nr nc"/></div></div></a></div><p id="4e2d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们获得新连接时，我们做的第一件事是建立我们的私人频道:</p><figure class="mn mo mp mq gt mr"><div class="bz fp l di"><div class="mu mt l"/></div></figure><p id="1aa2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">服务人员不完全是一夫一妻制的类型(不是评判)，但这一点让他们难以置信的强大，因为他们可以并行控制多个应用程序。</p><p id="0514" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">甚至同一个应用程序的多个实例也可以连接到它。就像和双胞胎约会一样。从我个人经验来看强烈不推荐:)</p><p id="191a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于我们的远程方法访问，这意味着我们可以将方法从一个软件暴露给一个应用程序工作人员，但是另一个方向会有问题，因为我们不能确保到达我们心目中的应用程序。为了处理这个场景，我们需要向所有连接的客户端广播消息。</p><h1 id="36a5" class="lb lc iq bd ld le lf lg lh li lj lk ll jw lm jx ln jz lo ka lp kc lq kd lr ls bi translated">5.范围界定的困境</h1><p id="41e3" class="pw-post-body-paragraph kf kg iq kh b ki lv jr kk kl lw ju kn ko mj kq kr ks mk ku kv kw ml ky kz la ij bi translated">当SW具有范围参数时:</p><div class="mz na gp gr nb nc"><a href="https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API/Using_Service_Workers#registering_your_worker" rel="noopener  ugc nofollow" target="_blank"><div class="nd ab fo"><div class="ne ab nf cl cj ng"><h2 class="bd ir gy z fp nh fr fs ni fu fw ip bi translated">使用服务人员-Web API | MDN</h2><div class="nj l"><h3 class="bd b gy z fp nh fr fs ni fu fw dk translated">本文提供了有关服务人员入门的信息，包括基本架构、注册和管理</h3></div><div class="nk l"><p class="bd b dl z fp nh fr fs ni fu fw dk translated">developer.mozilla.org</p></div></div><div class="nl l"><div class="nt l nn no np nl nq nr nc"/></div></div></a></div><p id="e5bd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此参数限于字符串。这是非常不幸的:如果我们可以传递一组字符串或正则表达式，我们的生活会更容易。</p><p id="a727" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在neo.mjs框架本身内部，我们有以下结构:</p><figure class="mn mo mp mq gt mr gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/b534a3a81aa67de1f0233f03a569b09e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1180/format:webp/1*lN5zreDNOOCK4-72lVRAwQ.png"/></div></figure><p id="f215" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">理论上我们想把我们的软件文件放到根文件夹中，因为我们确实想控制<code class="fe mv mw mx my b">apps</code>和<code class="fe mv mw mx my b">examples</code>文件夹。</p><p id="24d4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，我们也想使用<a class="ae mm" href="https://github.com/webpack/webpack" rel="noopener ugc nofollow" target="_blank"> webpack </a>为我们的<code class="fe mv mw mx my b">dist/development</code>和<code class="fe mv mw mx my b">dist/production</code>文件夹创建缩小版本。这些文件夹必须是我们的开发模式软件版本的限制。遗憾的是，范围黑名单也不可用。</p><p id="3806" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当初始化<code class="fe mv mw mx my b">apps</code>或<code class="fe mv mw mx my b">examples</code>的软件时，传递作用域是可能的，但是我担心这会导致先前实例的注销并导致延迟。还没有经过适当的测试。</p><p id="20ed" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相反，我在两个文件夹中创建了实例:</p><figure class="mn mo mp mq gt mr"><div class="bz fp l di"><div class="mu mt l"/></div></figure><p id="bde6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我没有将<code class="fe mv mw mx my b">apps</code>或<code class="fe mv mw mx my b">examples</code>添加到SW名称空间中，以确保我们的远程API保持不变，并且我们可以轻松地将代码从这些文件夹中的一个复制到另一个，而不会破坏任何东西。</p><p id="5615" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们使用以下内容生成新的工作空间:</p><p id="4cc0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> npx新应用</strong></p><p id="bf94" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们的终端内部，我们将得到以下结构:</p><figure class="mn mo mp mq gt mr gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/9290a3b38e20905b1be9563e6a2e5803.png" data-original-src="https://miro.medium.com/v2/resize:fit:1036/format:webp/1*TMDSu_zxqYs65fe_EUXbCw.png"/></div></figure><p id="ae9c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">SW singleton文件将被放入工作区本身的apps文件夹中，我们的构建过程将获取该文件以生成<code class="fe mv mw mx my b">dist/development</code>和<code class="fe mv mw mx my b">dist/production</code>版本。</p><p id="3de1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样做的原因是这允许我们扩展和覆盖我们的基类。如果您想自己添加更多的远程方法，可以很容易地做到。</p><h1 id="a789" class="lb lc iq bd ld le lf lg lh li lj lk ll jw lm jx ln jz lo ka lp kc lq kd lr ls bi translated">6.JS模块的服务人员</h1><p id="6a4e" class="pw-post-body-paragraph kf kg iq kh b ki lv jr kk kl lw ju kn ko mj kq kr ks mk ku kv kw ml ky kz la ij bi translated">与敬业和共享的员工一样，我们可以使用<code class="fe mv mw mx my b">type: 'module'</code>选项，这是我们的开发模式:</p><figure class="mn mo mp mq gt mr"><div class="bz fp l di"><div class="mu mt l"/></div></figure><p id="16a7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将只延迟加载这个主线程插件，以防您在neo-config.json文件中设置<code class="fe mv mw mx my b">useServiceWorker: true</code>或将<code class="fe mv mw mx my b">ServiceWorker</code>添加到您的<code class="fe mv mw mx my b">mainThreadAddons</code>数组中(或者两者都有)。</p><p id="708e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，这里有一个问题</p><p id="3508" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当你在你的软件文件中改变一个字节的代码(注释也计算在内)时，一个非基于模块的软件将会更新，同样的情况<strong class="kh ir">不</strong>适用于你在你扩展的基类中改变代码的情况。</p><p id="382c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">每次代码更改后，您也需要在扩展类中更改一个字节。我真的希望浏览器供应商能解决这个问题。</p><h1 id="b95a" class="lb lc iq bd ld le lf lg lh li lj lk ll jw lm jx ln jz lo ka lp kc lq kd lr ls bi translated">7.离线支持</h1><p id="4872" class="pw-post-body-paragraph kf kg iq kh b ki lv jr kk kl lw ju kn ko mj kq kr ks mk ku kv kw ml ky kz la ij bi translated">正如你在演示视频中看到的，我们的应用程序可以离线工作。原因很简单:</p><figure class="mn mo mp mq gt mr"><div class="bz fp l di"><div class="mu mt l"/></div></figure><p id="3623" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">→我们正在将<code class="fe mv mw mx my b">dist/production</code>中的每个文件添加到缓存中。</p><p id="5db4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如在第5节中看到的，您可以很容易地在工作区中覆盖缓存路径，以更好地满足您的需求。</p><h1 id="d803" class="lb lc iq bd ld le lf lg lh li lj lk ll jw lm jx ln jz lo ka lp kc lq kd lr ls bi translated">8.多页面应用程序</h1><p id="593f" class="pw-post-body-paragraph kf kg iq kh b ki lv jr kk kl lw ju kn ko mj kq kr ks mk ku kv kw ml ky kz la ij bi translated">服务人员实际上对海洋保护区很有帮助。您可能希望将SW文件放在域的顶层，以便为多个嵌套索引文件启用它。</p><p id="a66f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以轻松地缓存“静态”资产，如图像和CSS文件。</p><p id="c63d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您想缓存像库和框架这样的JavaScript文件，有一个权衡。</p><p id="4c11" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通常，您最有可能使用像webpack这样的构建工具，它会创建包含您的应用程序代码和使用的第三方库的包。</p><p id="7db9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于不同的页面可能使用给定库的不同部分，您需要将其指定为外部依赖项，以确保它将构建到自己的文件中，而不会与您的应用程序相关代码混合在一起。这样，多个入口点可以使用同一个文件，例如托管在CDN上的文件。</p><p id="a89f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里的权衡是，我们将失去每个页面(应用程序)的树摇动方面，因此初始加载时间将增加。但是，从一个页面切换到另一个页面会快得多。</p><h1 id="ef55" class="lb lc iq bd ld le lf lg lh li lj lk ll jw lm jx ln jz lo ka lp kc lq kd lr ls bi translated">9.多窗口应用程序</h1><p id="23d4" class="pw-post-body-paragraph kf kg iq kh b ki lv jr kk kl lw ju kn ko mj kq kr ks mk ku kv kw ml ky kz la ij bi translated">多窗口应用程序实际上非常类似于多页面应用程序。您可能已经看过多窗口covid应用程序演示，我们可以将螺旋的组件树移动到不同的浏览器窗口:</p><figure class="mn mo mp mq gt mr"><div class="bz fp l di"><div class="nx mt l"/></div></figure><p id="a916" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">(两点半左右开始)</p><p id="e141" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们在这里添加一个服务人员，我们将缓存图像，当将DOM添加到新的浏览器窗口时，所有图像将立即显示。</p><p id="549f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于一个多窗口应用程序在一个共享的应用程序工作器中共享所有JavaScript相关的资产，我们的框架唯一需要同步的就是增量CSS更新。这些也已经到位。</p><h1 id="0ed3" class="lb lc iq bd ld le lf lg lh li lj lk ll jw lm jx ln jz lo ka lp kc lq kd lr ls bi translated">10.neo.mjs v4版本</h1><p id="af5f" class="pw-post-body-paragraph kf kg iq kh b ki lv jr kk kl lw ju kn ko mj kq kr ks mk ku kv kw ml ky kz la ij bi translated">第4版的重点是增加服务人员:</p><figure class="mn mo mp mq gt mr gh gi paragraph-image"><div role="button" tabindex="0" class="nz oa di ob bf oc"><div class="gh gi ny"><img src="../Images/7e0c5499adc9f506faace928f1e6a813.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P7Iv-yHVQKSECOtY0WJfDA.png"/></div></div></figure><p id="a93f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如前所述，远程方法访问和特定于软件的构建已经就绪。</p><p id="3e61" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">欢迎您在此添加功能请求(如推送通知):</p><div class="mz na gp gr nb nc"><a href="https://github.com/neomjs/neo/issues" rel="noopener  ugc nofollow" target="_blank"><div class="nd ab fo"><div class="ne ab nf cl cj ng"><h2 class="bd ir gy z fp nh fr fs ni fu fw ip bi translated">问题neomjs/neo</h2><div class="nj l"><h3 class="bd b gy z fp nh fr fs ni fu fw dk translated">关于这个项目有问题吗？注册一个免费的GitHub账户来开一期并联系它的…</h3></div><div class="nk l"><p class="bd b dl z fp nh fr fs ni fu fw dk translated">github.com</p></div></div><div class="nl l"><div class="od l nn no np nl nq nr nc"/></div></div></a></div><p id="f18b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">版本4没有破坏任何其他API。实际上没有。从版本3迁移应该是小菜一碟。</p><p id="b971" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于我们的缓存大小有限，我们可以使用存储API来添加检查:</p><div class="mz na gp gr nb nc"><a href="https://developers.google.com/web/updates/2017/08/estimating-available-storage-space" rel="noopener  ugc nofollow" target="_blank"><div class="nd ab fo"><div class="ne ab nf cl cj ng"><h2 class="bd ir gy z fp nh fr fs ni fu fw ip bi translated">估计可用存储空间| Web | Google开发者</h2><div class="nj l"><h3 class="bd b gy z fp nh fr fs ni fu fw dk translated">navigator.storage.estimate()让你深入了解你的web应用'的存储限制。</h3></div><div class="nk l"><p class="bd b dl z fp nh fr fs ni fu fw dk translated">developers.google.com</p></div></div><div class="nl l"><div class="oe l nn no np nl nq nr nc"/></div></div></a></div><p id="8c92" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对应的一个<code class="fe mv mw mx my b">removeAssets</code>方法已经作为远程方法暴露在应用领域中。也可以随意添加一个功能请求或PR。</p><h1 id="8eac" class="lb lc iq bd ld le lf lg lh li lj lk ll jw lm jx ln jz lo ka lp kc lq kd lr ls bi translated">11.在线演示</h1><p id="928a" class="pw-post-body-paragraph kf kg iq kh b ki lv jr kk kl lw ju kn ko mj kq kr ks mk ku kv kw ml ky kz la ij bi translated">发展模式:<br/>【neo.mjs/examples/preloadingAssets/index.html T2】</p><p id="e0df" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">dist/production:<br/><a class="ae mm" href="https://neomjs.github.io/pages/node_modules/neo.mjs/dist/production/examples/preloadingAssets/index.html" rel="noopener ugc nofollow" target="_blank">neo . mjs/dist/production/examples/preloading assets/index . html</a></p><h1 id="92a5" class="lb lc iq bd ld le lf lg lh li lj lk ll jw lm jx ln jz lo ka lp kc lq kd lr ls bi translated">12.最后的想法</h1><p id="c840" class="pw-post-body-paragraph kf kg iq kh b ki lv jr kk kl lw ju kn ko mj kq kr ks mk ku kv kw ml ky kz la ij bi translated">webkit (Safari)团队现在已经完成了对共享工作者的支持，它应该很快就会进入Safari技术预览版(一旦我可以测试它，我会写一篇博文)。</p><p id="4821" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Firefox团队即将完成对worker范围内JS模块的支持。</p><p id="b20f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦这两个功能都上线，这应该是<a class="ae mm" href="https://github.com/neomjs/neo" rel="noopener ugc nofollow" target="_blank"> neo.mjs </a>项目的黄金时间。</p><p id="b59a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当然，你现在已经可以使用和学习这个框架了。我最强烈的建议是加入Slack频道:</p><div class="mz na gp gr nb nc"><a href="https://join.slack.com/t/neomjs/shared_invite/zt-6c50ueeu-3E1~M4T9xkNnb~M_prEEOA" rel="noopener  ugc nofollow" target="_blank"><div class="nd ab fo"><div class="ne ab nf cl cj ng"><h2 class="bd ir gy z fp nh fr fs ni fu fw ip bi translated">松弛的</h2><div class="nj l"><h3 class="bd b gy z fp nh fr fs ni fu fw dk translated">编辑描述</h3></div><div class="nk l"><p class="bd b dl z fp nh fr fs ni fu fw dk translated">join.slack.com</p></div></div><div class="nl l"><div class="of l nn no np nl nq nr nc"/></div></div></a></div><p id="3eb6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">问候&amp;快乐编码，<br/>托拜厄斯</p></div></div>    
</body>
</html>