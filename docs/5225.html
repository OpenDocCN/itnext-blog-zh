<html>
<head>
<title>Kubernetes with Minikube and your existing Docker Knowledge</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes与Minikube和你现有的码头知识</h1>
<blockquote>原文：<a href="https://itnext.io/kubernetes-with-minikube-and-your-existing-docker-knowledge-ab330f07cba2?source=collection_archive---------4-----------------------#2021-01-15">https://itnext.io/kubernetes-with-minikube-and-your-existing-docker-knowledge-ab330f07cba2?source=collection_archive---------4-----------------------#2021-01-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/0c90ab5266c88f507ed493b4d4cd418b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Sm8Mc94zVdG4ljf0AvanXQ.jpeg"/></div></div></figure><p id="58c1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们假设你已经开发了你的应用程序。这是一个很棒的应用程序，你对输出很满意，现在你需要部署。简单的解决方案。我们去码头吧。为了简单起见，我将展示我在科罗纳疫情期间(当然是在远程办公室工作后的空闲时间)学习node.js和express的过程中构建的一个应用程序。在此处找到源代码:</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="5741" class="lf lg iq lb b gy lh li l lj lk"><a class="ae ll" href="https://github.com/humayun-rashid/covid-19-node-app" rel="noopener ugc nofollow" target="_blank">https://github.com/humayun-rashid/covid-19-node-app</a></span></pre><p id="1ab1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">假设这是你的应用程序，你想把它部署到docker注册中心。事实上，如果你知道一些关于docker的基础知识，这是非常简单的。步骤是:</p><ul class=""><li id="6fd3" class="lm ln iq ka b kb kc kf kg kj lo kn lp kr lq kv lr ls lt lu bi translated">克隆存储库</li><li id="71b4" class="lm ln iq ka b kb lv kf lw kj lx kn ly kr lz kv lr ls lt lu bi translated">创建Dockerfile文件</li><li id="a97b" class="lm ln iq ka b kb lv kf lw kj lx kn ly kr lz kv lr ls lt lu bi translated">构建和标记图像</li><li id="161d" class="lm ln iq ka b kb lv kf lw kj lx kn ly kr lz kv lr ls lt lu bi translated">推送图像</li></ul><h2 id="5a86" class="lf lg iq bd ma mb mc dn md me mf dp mg kj mh mi mj kn mk ml mm kr mn mo mp mq bi translated">克隆</h2><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="627b" class="lf lg iq lb b gy lh li l lj lk">git clone <a class="ae ll" href="https://github.com/humayun-rashid/covid-19-node-app" rel="noopener ugc nofollow" target="_blank">https://github.com/humayun-rashid/covid-19-node-app</a></span></pre><h2 id="e3dd" class="lf lg iq bd ma mb mc dn md me mf dp mg kj mh mi mj kn mk ml mm kr mn mo mp mq bi translated">构建和标记</h2><p id="7382" class="pw-post-body-paragraph jy jz iq ka b kb mr kd ke kf ms kh ki kj mt kl km kn mu kp kq kr mv kt ku kv ij bi translated">在Dockerfile中添加配置，并将其放在同一个app目录中。如果您正在使用我提供的git存储库链接，它已经在那里了。</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="d31c" class="lf lg iq lb b gy lh li l lj lk"># Base Image<br/>FROM node:slim</span><span id="047f" class="lf lg iq lb b gy mw li l lj lk"># Create app directory<br/>WORKDIR /usr/src/app </span><span id="ac0f" class="lf lg iq lb b gy mw li l lj lk"># Install app dependencies<br/># A wildcard is used to ensure both package.json AND package-lock.json are copied<br/># where available (npm@5+)<br/>COPY package*.json ./<br/> <br/>RUN npm install</span><span id="d63d" class="lf lg iq lb b gy mw li l lj lk"># Bundle app source<br/>COPY . . </span><span id="e3a4" class="lf lg iq lb b gy mw li l lj lk">EXPOSE 3000</span><span id="3110" class="lf lg iq lb b gy mw li l lj lk">CMD [ "node", "server.js" ]</span><span id="bceb" class="lf lg iq lb b gy mw li l lj lk">docker build -t covid-19:latest .</span></pre><p id="004d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">docker标签(在斜杠前使用您自己的存储库名称)</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="f476" class="lf lg iq lb b gy lh li l lj lk">docker tag covid-19:latest raahat/covid-19:latest</span></pre><p id="3a2e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">推</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="8508" class="lf lg iq lb b gy lh li l lj lk">docker push raahat/covid-19:latest</span></pre><p id="3039" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它会询问docker用户名和密码。完成了！现在运行它:</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="ff68" class="lf lg iq lb b gy lh li l lj lk">docker run --rm --name covid-19-app -dit -p 3000:3000 raahat/covid-19:latest</span></pre><p id="8565" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">打开浏览器并访问本地主机，验证应用程序是否已启动并正在运行。</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="524f" class="lf lg iq lb b gy lh li l lj lk">http://localhost:3000</span></pre><h2 id="052e" class="lf lg iq bd ma mb mc dn md me mf dp mg kj mh mi mj kn mk ml mm kr mn mo mp mq bi translated">样本项目:新冠肺炎</h2><p id="127f" class="pw-post-body-paragraph jy jz iq ka b kb mr kd ke kf ms kh ki kj mt kl km kn mu kp kq kr mv kt ku kv ij bi translated">对于我们的项目，我将使用我以前的一个项目作为例子。您可以从这里下载:</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="c21f" class="lf lg iq lb b gy lh li l lj lk"><a class="ae ll" href="https://github.com/humayun-rashid/covid-19-node-app" rel="noopener ugc nofollow" target="_blank">https://github.com/humayun-rashid/covid-19-node-app</a></span></pre><p id="02e5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以构建映像并运行，也可以直接从docker注册表运行映像。直接从docker注册表运行映像:</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="9675" class="lf lg iq lb b gy lh li l lj lk">docker run -it --rm --name covid-19 -p 3000:3000 raahat/covid-19:latest</span></pre><p id="c365" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">成功执行后，应该会有以下输出:</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="902d" class="lf lg iq lb b gy lh li l lj lk">Server is running in 3000</span></pre><p id="56b8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您想要构建并运行，那么请转到目录并运行-</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="bc79" class="lf lg iq lb b gy lh li l lj lk">docker build -t covid-19:latest .<br/>docker run -it --rm --name covid-19 -p 3000:3000 covid-19:latest</span></pre><h2 id="699e" class="lf lg iq bd ma mb mc dn md me mf dp mg kj mh mi mj kn mk ml mm kr mn mo mp mq bi translated">Kubernetes部署的步骤</h2><ul class=""><li id="9cc2" class="lm ln iq ka b kb mr kf ms kj mx kn my kr mz kv lr ls lt lu bi translated">创建名称空间</li><li id="9513" class="lm ln iq ka b kb lv kf lw kj lx kn ly kr lz kv lr ls lt lu bi translated">创建部署</li><li id="f052" class="lm ln iq ka b kb lv kf lw kj lx kn ly kr lz kv lr ls lt lu bi translated">规模部署</li><li id="c4ef" class="lm ln iq ka b kb lv kf lw kj lx kn ly kr lz kv lr ls lt lu bi translated">创建服务以公开部署</li><li id="0f88" class="lm ln iq ka b kb lv kf lw kj lx kn ly kr lz kv lr ls lt lu bi translated">配置入口控制器</li><li id="f1e4" class="lm ln iq ka b kb lv kf lw kj lx kn ly kr lz kv lr ls lt lu bi translated">创建入口控制器</li></ul><h2 id="5908" class="lf lg iq bd ma mb mc dn md me mf dp mg kj mh mi mj kn mk ml mm kr mn mo mp mq bi translated">创建名称空间</h2><p id="7420" class="pw-post-body-paragraph jy jz iq ka b kb mr kd ke kf ms kh ki kj mt kl km kn mu kp kq kr mv kt ku kv ij bi translated">可以使用Kubectl CLI创建名称空间。首先，通过以下命令检查可用的名称空间:</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="6c50" class="lf lg iq lb b gy lh li l lj lk">$ kubectl get namespace<br/>or <br/>$ kubectl get ns</span></pre><p id="8f80" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">输出如下所示:</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="36ef" class="lf lg iq lb b gy lh li l lj lk">Output</span></pre><p id="7473" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们使用Kubectl CLI创建一个新的名称空间。我们将把它命名为“发展”。</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="7797" class="lf lg iq lb b gy lh li l lj lk">$ kubectl create namespace development</span></pre><p id="cfa8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它将创建一个新的名称空间。我们将在该名称空间下部署所有内容。如果所有部署都在任何特定的名称空间下，那么处理任何事情都会容易得多。</p><p id="be75" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们已经使用kubectl CLI创建了一个新的名称空间，但这不是标准的生产过程。我们需要使用YAML编写配置文件。运行以下命令，该命令将为当前目录中的命名空间生成YAML配置。</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="a5e8" class="lf lg iq lb b gy lh li l lj lk">$ kubectl create namespace development --dry-run -o yaml &gt; namespace.yaml</span></pre><p id="7db1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，您可以使用以下命令创建名称空间:</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="7845" class="lf lg iq lb b gy lh li l lj lk">$ kubectl apply -f namespace.yaml </span></pre><h2 id="6936" class="lf lg iq bd ma mb mc dn md me mf dp mg kj mh mi mj kn mk ml mm kr mn mo mp mq bi translated">创建Pod</h2><p id="1be1" class="pw-post-body-paragraph jy jz iq ka b kb mr kd ke kf ms kh ki kj mt kl km kn mu kp kq kr mv kt ku kv ij bi translated">一个Pod可以被视为Kubernetes中一个应用程序的单个实例，代表一个部署单元。根据Kubernetes官方网站:</p><blockquote class="na nb nc"><p id="b1ef" class="jy jz nd ka b kb kc kd ke kf kg kh ki ne kk kl km nf ko kp kq ng ks kt ku kv ij bi translated">一个<em class="iq"> Pod </em>是Kubernetes应用程序的基本执行单元——是您创建或部署的Kubernetes对象模型中最小和最简单的单元。一个Pod代表在您的<a class="ae ll" href="https://kubernetes.io/docs/reference/glossary/?all=true#term-cluster" rel="noopener ugc nofollow" target="_blank">集群</a>上运行的进程。</p></blockquote><p id="79b2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要考虑的主要重要因素-</p><ul class=""><li id="1290" class="lm ln iq ka b kb kc kf kg kj lo kn lp kr lq kv lr ls lt lu bi translated">pod能够运行应用程序的容器。</li><li id="6534" class="lm ln iq ka b kb lv kf lw kj lx kn ly kr lz kv lr ls lt lu bi translated">一个pod可以由一个容器组成，也可以由多个容器组成，这些容器相互绑定以共享资源。</li></ul><p id="bdf2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用CLI和YAML创建Pod</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="7784" class="lf lg iq lb b gy lh li l lj lk">$ kubectl run --image=raahat/covid-19 covid-19-app --port=3000 --restart=Never --namespace=development</span></pre><p id="76a1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们试着拿到豆荚:</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="15dc" class="lf lg iq lb b gy lh li l lj lk">kubectl get pods -n development</span><span id="c60b" class="lf lg iq lb b gy mw li l lj lk">NAME           READY   STATUS    RESTARTS   AGE<br/>covid-19-app   1/1     Running   0          31m</span><span id="53f5" class="lf lg iq lb b gy mw li l lj lk">kubectl delete pods covid-19-app -n monitoring</span><span id="dd96" class="lf lg iq lb b gy mw li l lj lk">kubectl port-forward covid-19-app 3000:3000 -n development</span><span id="0e4b" class="lf lg iq lb b gy mw li l lj lk">kubectl get pods -n development<br/>No resources found in development namespace.</span><span id="97f9" class="lf lg iq lb b gy mw li l lj lk">kubectl run --image=raahat/covid-19 covid-19-app --port=3000 --restart=Never --namespace=development --dry-run -o yaml &gt; pod.yaml</span><span id="1bdf" class="lf lg iq lb b gy mw li l lj lk">kubectl create -f pod.yaml</span></pre><h1 id="b770" class="nh lg iq bd ma ni nj nk md nl nm nn mg no np nq mj nr ns nt mm nu nv nw mp nx bi translated">使用CLI和YAML创建部署</h1><p id="4fea" class="pw-post-body-paragraph jy jz iq ka b kb mr kd ke kf ms kh ki kj mt kl km kn mu kp kq kr mv kt ku kv ij bi translated">Kubernetes <a class="ae ll" href="https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/" rel="noopener ugc nofollow" target="_blank">豆荚</a>是凡人。他们出生，当他们死去，他们不会复活。如果您使用<a class="ae ll" href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/" rel="noopener ugc nofollow" target="_blank">部署</a>来运行您的应用程序，它可以动态地创建和销毁pod。</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="f9a9" class="lf lg iq lb b gy lh li l lj lk">kubectl create deployment covid-19 --image=raahat/covid-19 --namespace=development --dry-run=client -o yaml &gt; deployment.yaml</span></pre><p id="364b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">打开deployment.yaml文件，在容器部分中添加端口和容器端口。它应该是这样的:</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="450c" class="lf lg iq lb b gy lh li l lj lk">containers:<br/>- image: raahat/covid-19<br/>  name: covid-19<br/>  ports:<br/>  - containerPort: 3000</span></pre><p id="e78d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在通过以下方式应用它:</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="a1f2" class="lf lg iq lb b gy lh li l lj lk">kubectl apply -f deployment.yaml</span></pre><p id="c40e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">每个Pod都有自己的IP地址，但是，在部署中，某个时刻运行的一组Pod可能与稍后运行该应用程序的一组Pod不同。</p><p id="a54e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这就导致了一个问题:如果某组Pods(称之为“后端”)向集群中的其他Pods(称之为“前端”)提供功能，前端如何发现并跟踪要连接到哪个IP地址，以便前端可以使用工作负载的后端部分？</p><p id="f1cd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于应用程序的某些部分(例如，前端)，您可能希望将服务公开到一个外部IP地址，即您的集群之外。</p><p id="b82d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Kubernetes <code class="fe ny nz oa lb b">ServiceTypes</code>允许你指定你想要什么样的服务。默认为<code class="fe ny nz oa lb b">ClusterIP</code>。</p><p id="0e7f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe ny nz oa lb b">Type</code>价值观及其行为是:</p><ul class=""><li id="e779" class="lm ln iq ka b kb kc kf kg kj lo kn lp kr lq kv lr ls lt lu bi translated"><code class="fe ny nz oa lb b">ClusterIP</code>:公开集群内部IP上的服务。选择该值将使服务只能从集群内部访问。这是默认的<code class="fe ny nz oa lb b">ServiceType</code>。</li><li id="dc12" class="lm ln iq ka b kb lv kf lw kj lx kn ly kr lz kv lr ls lt lu bi translated"><code class="fe ny nz oa lb b"><a class="ae ll" href="https://kubernetes.io/docs/concepts/services-networking/service/#nodeport" rel="noopener ugc nofollow" target="_blank">NodePort</a></code>:在一个静态端口暴露每个节点的IP上的服务(<code class="fe ny nz oa lb b">NodePort</code>)。一个<code class="fe ny nz oa lb b">ClusterIP</code>服务，自动为其创建<code class="fe ny nz oa lb b">NodePort</code>服务路由。您将能够通过请求<code class="fe ny nz oa lb b">&lt;NodeIP&gt;:&lt;NodePort&gt;</code>从集群外部联系<code class="fe ny nz oa lb b">NodePort</code>服务。</li><li id="2c1b" class="lm ln iq ka b kb lv kf lw kj lx kn ly kr lz kv lr ls lt lu bi translated"><code class="fe ny nz oa lb b"><a class="ae ll" href="https://kubernetes.io/docs/concepts/services-networking/service/#loadbalancer" rel="noopener ugc nofollow" target="_blank">LoadBalancer</a></code>:使用云提供商的负载均衡器对外公开服务。外部负载平衡器路由到的<code class="fe ny nz oa lb b">NodePort</code>和<code class="fe ny nz oa lb b">ClusterIP</code>服务是自动创建的。</li></ul><h1 id="37ff" class="nh lg iq bd ma ni nj nk md nl nm nn mg no np nq mj nr ns nt mm nu nv nw mp nx bi translated">公开部署</h1><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="0929" class="lf lg iq lb b gy lh li l lj lk">kubectl expose deployment covid-19 — type=NodePort --port=3000 --namespace=development --dry-run=client -o yaml &gt; service.yaml<br/>kubectl apply -f service.yaml<br/></span></pre><p id="f8d5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">验证服务已创建并且在节点端口上可用:</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="31b4" class="lf lg iq lb b gy lh li l lj lk">kubectl get service -n development<br/>NAME       TYPE       CLUSTER-IP      EXTERNAL-IP   PORT(S)          AGE<br/>covid-19   NodePort   10.105.76.139   &lt;none&gt;        3000:31450/TCP   5s</span></pre><p id="83be" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过节点端口访问服务:</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="7141" class="lf lg iq lb b gy lh li l lj lk">minikube service covid-19 --url -n development<br/><a class="ae ll" href="http://192.168.99.224:31450" rel="noopener ugc nofollow" target="_blank">http://192.168.99.224:31450</a></span></pre><p id="c0f6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果将<code class="fe ny nz oa lb b">type</code>字段设置为<code class="fe ny nz oa lb b">NodePort</code>，Kubernetes控制平面将从<code class="fe ny nz oa lb b">--service-node-port-range</code>标志指定的范围内分配一个端口(默认值:30000-32767)。</p></div></div>    
</body>
</html>