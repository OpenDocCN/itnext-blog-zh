<html>
<head>
<title>Why puma workers constantly hung, and how we fixed by discovering the bug of Ruby v2.5.8 and v2.6.6</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么puma workers经常挂起，以及我们如何通过发现Ruby v2.5.8和v2.6.6的bug来修复</h1>
<blockquote>原文：<a href="https://itnext.io/why-puma-workers-constantly-hung-and-how-we-fixed-by-discovering-the-bug-of-ruby-v2-5-8-and-v2-6-6-7fa0fd0a1958?source=collection_archive---------1-----------------------#2021-04-06">https://itnext.io/why-puma-workers-constantly-hung-and-how-we-fixed-by-discovering-the-bug-of-ruby-v2-5-8-and-v2-6-6-7fa0fd0a1958?source=collection_archive---------1-----------------------#2021-04-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="8142" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<a class="ae kl" href="https://paralleljp.studio.site/" rel="noopener ugc nofollow" target="_blank">生产</a>中运行Rails puma服务器时，我们看到了这样一个事件，即<strong class="jp ir">的一些老工人进程突然被卡住了</strong>，而不管请求的数量或趋势有没有变化。</p><p id="30fb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我找到了根本原因，向上游汇报了。这个问题在Ruby 2.6.0中仍然存在，并且可以追溯到Ruby 2.5.0。如果你只是想要一个bug的概要，请看<a class="ae kl" href="https://bugs.ruby-lang.org/issues/17669" rel="noopener ugc nofollow" target="_blank"> ruby-lang#17669 </a>。</p><h1 id="4c2f" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">发生了什么</h1><p id="b902" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">有一天，我们注意到许多特定用户长期遭受的<code class="fe lp lq lr ls b">ActiveRecord::LockWaitTimeout</code>异常。与此同时，我们的一个puma工作人员报告说没有可用线程的容量，他们的内存逐渐无限膨胀。</p><p id="0f02" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是我们这段时间的数据:</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi lt"><img src="../Images/f36caf788866d1683a3b7fd4463045e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kB7rCM0XpoKHG2AIaddy0A.png"/></div></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">锁等待超时导致的应用程序错误日志</figcaption></figure><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi mj"><img src="../Images/596c6384866609c687ae0eea225820d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*EmmhijVk2W4Y2VaM.png"/></div></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">Puma.stats中无休止的低线程<a class="ae kl" href="https://github.com/puma/puma/blob/0bdfe297906ba110583dc597e33c6a79c22e9798/docs/stats.md#explanation-of-stats" rel="noopener ugc nofollow" target="_blank">pool _ capacity</a></figcaption></figure><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi mk"><img src="../Images/be6034bf389dcd31da357f9eecfdaa95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-k5nqnm1RR0KelAZ5xHXfQ.png"/></div></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">应用程序容器的内存使用膨胀</figcaption></figure><p id="bc49" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最初，我们不确定这些不良观察结果是否相互关联，是否由严重的根本原因引发。在交通拥挤的情况下，每个问题本身实际上都是不可避免的。因此，我们让事情运行了一段时间，并小心谨慎地加强了。</p><h1 id="19fa" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">立即回应</h1><p id="9376" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">首先，为了防止内存溢出，我通过一个从k8s服务分离的操作从负载均衡器中删除了这个应用程序容器。<strong class="jp ir">由于到来的请求没有到达，内存增长也结束了。</strong>到目前为止，一切顺利。</p><pre class="lu lv lw lx gt ml ls mm mn aw mo bi"><span id="6df8" class="mp kn iq ls b gy mq mr l ms mt">❯❯❯ kubectl edit pod api-5c476b576d-vfmgt<br/>spec:<br/>  template:<br/>    metadata:<br/>      labels:<br/>-       app: api<br/>+       app: api-issue-memoryleak</span></pre><p id="cfbc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">另一方面，<code class="fe lp lq lr ls b">ActiveRecord::LockWaitTimeout</code>异常仍在继续。这些问题迫切需要解决，因为对于那些在我们解决之前无法使用我们主要功能的特定用户来说，这是一个至关重要的问题。</p><p id="2b12" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，<strong class="jp ir">我删除了这个有问题的工作进程和线程运行的容器</strong>。很快，例外停止了，一切都变好了😌。</p><pre class="lu lv lw lx gt ml ls mm mn aw mo bi"><span id="261b" class="mp kn iq ls b gy mq mr l ms mt">❯❯❯ kubectl delete pod api-5c476b576d-vfmgt</span></pre><h1 id="9fcb" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">观察</h1><p id="459e" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">在立即修复之后，没有什么重要的东西来研究这是如何发生的，因为我们失去了查看信息快照的机会，比如我们的数据库的事务锁和puma worker进程的核心转储。顺便提一下，我们的puma服务器依赖MySQL 5.7作为主数据库。</p><p id="cc0c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我决定下次类似的问题再次出现时，把它们放在一边。</p><ul class=""><li id="a167" class="mu mv iq jp b jq jr ju jv jy mw kc mx kg my kk mz na nb nc bi translated">提前准备充分测试的指令帮助我尽可能快地执行，没有延迟地修复这个部分中断。虽然您可以找到关于如何查看事务、其持有的锁以及被锁阻塞的其他事务的可靠web资源，<a class="ae kl" href="https://yoheimuta.medium.com/debugging-gke-unprivileged-containers-with-gdb-and-nsenter-3760b50eb03a" rel="noopener">我在生成核心转储和调试运行在GKE集群上的进程</a>时遇到了麻烦。</li></ul><p id="6695" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，我们等待另一次的再次发生，很快就发生了。一开始，我就可以通过参考<code class="fe lp lq lr ls b">information_schema.innodb_trx</code>表来检测长时间运行的事务。</p><ul class=""><li id="9111" class="mu mv iq jp b jq jr ju jv jy mw kc mx kg my kk mz na nb nc bi translated"><code class="fe lp lq lr ls b">SELECT * FROM information_schema.innodb_trx</code></li></ul><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi lt"><img src="../Images/592acefb061b8ed7d1e81f4fadf4033f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kJlineY1h8TLUJ9L8pLceA.png"/></div></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated"><a class="ae kl" href="https://dev.mysql.com/doc/refman/5.7/en/information-schema-innodb-trx-table.html" rel="noopener ugc nofollow" target="_blank">该表提供了当前在</a> <code class="fe lp lq lr ls b"><a class="ae kl" href="https://dev.mysql.com/doc/refman/5.7/en/information-schema-innodb-trx-table.html" rel="noopener ugc nofollow" target="_blank">InnoDB.</a></code>内执行的每个交易的信息</figcaption></figure><p id="92b8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意，它显示了14分钟前开始的两个状态为<code class="fe lp lq lr ls b">RUNNING</code>的事务。我注意到每个<code class="fe lp lq lr ls b">trx_query</code>都是空的。该列表示事务正在执行的SQL语句。这意味着在MySQL已经按时返回结果后，一些Ruby代码没有提交这些事务。</p><p id="3ae8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最重要的是，您需要将<code class="fe lp lq lr ls b">information_schema.innodb_lock_waits</code>表连接在一起，以判断它们是否阻塞了试图获得相同锁的其他事务。</p><ul class=""><li id="c54c" class="mu mv iq jp b jq jr ju jv jy mw kc mx kg my kk mz na nb nc bi translated"><code class="fe lp lq lr ls b"><a class="ae kl" href="https://dev.mysql.com/doc/refman/5.7/en/information-schema-innodb-lock-waits-table.html" rel="noopener ugc nofollow" target="_blank">INNODB_LOCK_WAITS</a></code>表包含每个阻塞的<code class="fe lp lq lr ls b">InnoDB</code>事务的一行或多行，指示它请求的锁和阻塞该请求的任何锁。</li></ul><pre class="lu lv lw lx gt ml ls mm mn aw mo bi"><span id="ebb1" class="mp kn iq ls b gy mq mr l ms mt">SELECT<br/>  r.trx_id waiting_trx_id,<br/>  r.trx_mysql_thread_id waiting_thread,<br/>  r.trx_query waiting_query,<br/>  b.trx_id blocking_trx_id,<br/>  b.trx_mysql_thread_id blocking_thread,<br/>  b.trx_query blocking_query<br/>FROM       information_schema.innodb_lock_waits w<br/>INNER JOIN information_schema.innodb_trx b<br/>  ON b.trx_id = w.blocking_trx_id<br/>INNER JOIN information_schema.innodb_trx r<br/>  ON r.trx_id = w.requesting_trx_id;</span></pre><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi nd"><img src="../Images/6b9fcc587af29c4483dcfff1239511c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-jJ6TO793NrJ1S_eAc6NSw.png"/></div></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated"><a class="ae kl" href="https://dev.mysql.com/doc/refman/5.7/en/innodb-information-schema-examples.html" rel="noopener ugc nofollow" target="_blank">该表提供了关于哪些事务正在等待以及哪些事务正在阻塞它们的信息。</a></figcaption></figure><p id="cd41" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">结果使我确信<strong class="jp ir">这两个事务阻塞了其他四个事务，并触发了</strong> <code class="fe lp lq lr ls b"><strong class="jp ir">ActiveRecord::LockWaitTimeout</strong></code> <strong class="jp ir">异常</strong>。您可以看到<code class="fe lp lq lr ls b">blocking_trx_id</code>的值与长时间运行的事务的值相匹配。</p><p id="de48" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，puma在接收到<code class="fe lp lq lr ls b">TERM</code>信号后写入的访问日志中有一些请求具有异常长的延迟，表现为被卡住。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi ne"><img src="../Images/88be9fecfe984b3bd3256785d9102575.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9B6dynQKf3pkxl8q44y2kw.png"/></div></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">这14个请求持续了1小时50分钟😲</figcaption></figure><p id="2b30" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从前面的观察中考虑所有的事情，我得出结论<strong class="jp ir">Rails请求的意外阻塞是根本问题</strong>。一路上发出的MySQL事务也在拖延并阻塞另一个事务，直到工作线程被终止。</p><h1 id="60ad" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">彪马螺纹悬挂的位置</h1><p id="8cb2" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">为了揭开根本原因的神秘面纱，深入研究一个核心转储，找出线程卡住的地方。以下是如何在GKE生成核心转储。</p><ul class=""><li id="15e7" class="mu mv iq jp b jq jr ju jv jy mw kc mx kg my kk mz na nb nc bi translated">首先，我通过ssh登录到运行puma的计算引擎实例。</li></ul><pre class="lu lv lw lx gt ml ls mm mn aw mo bi"><span id="fa18" class="mp kn iq ls b gy mq mr l ms mt">❯❯❯ gcloud beta compute ssh --zone "asia-northeast1-a" "gke-cluster-n1-standard-8-po-a0cea807-5327" --project "hogehoge"</span></pre><ul class=""><li id="c4ea" class="mu mv iq jp b jq jr ju jv jy mw kc mx kg my kk mz na nb nc bi translated">然后，<code class="fe lp lq lr ls b"><a class="ae kl" href="https://man7.org/linux/man-pages/man1/nsenter.1.html" rel="noopener ugc nofollow" target="_blank">nsenter</a></code>允许您在显示的工作进程(3866) <code class="fe lp lq lr ls b">ps</code>命令的PID指定的Pod名称空间中执行<code class="fe lp lq lr ls b">gdb</code>。在容器中运行<code class="fe lp lq lr ls b">gdb</code>需要输入目标进程的挂载、网络和PID名称空间。</li></ul><pre class="lu lv lw lx gt ml ls mm mn aw mo bi"><span id="69e5" class="mp kn iq ls b gy mq mr l ms mt">$ ps auxf<br/>$ sudo nsenter --mount --net --pid --target 3866 bash</span></pre><ul class=""><li id="1c95" class="mu mv iq jp b jq jr ju jv jy mw kc mx kg my kk mz na nb nc bi translated"><code class="fe lp lq lr ls b"><a class="ae kl" href="https://man7.org/linux/man-pages/man1/gcore.1.html" rel="noopener ugc nofollow" target="_blank">gcore</a></code>生成运行程序的核心文件(PID: 23)。</li></ul><pre class="lu lv lw lx gt ml ls mm mn aw mo bi"><span id="cac2" class="mp kn iq ls b gy mq mr l ms mt">bash-5.0# apk add gdb<br/>bash-5.0# gcore 23</span></pre><ul class=""><li id="cec0" class="mu mv iq jp b jq jr ju jv jy mw kc mx kg my kk mz na nb nc bi translated">最后，我将核心文件从容器复制/下载到我的本地。</li></ul><pre class="lu lv lw lx gt ml ls mm mn aw mo bi"><span id="1211" class="mp kn iq ls b gy mq mr l ms mt">❯❯❯ kubectl cp api-5dcb4b66f8-99nft:/api/core.23 ~/react/tmp/core.23</span></pre><p id="8213" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，要从核心转储中获取线程回溯，请运行以下命令:</p><pre class="lu lv lw lx gt ml ls mm mn aw mo bi"><span id="3b0f" class="mp kn iq ls b gy mq mr l ms mt">bash-5.0# apk add musl-dbg gdb curl<br/>bash-5.0# gdb -silent -nw /usr/local/bin/ruby core.23</span><span id="78bb" class="mp kn iq ls b gy nf mr l ms mt">(gdb) info threads<br/>  Id   Target Id                  Frame<br/>...<br/>  6    LWP 32 "puma 001"          __cp_end () at src/thread/x86_64/syscall_cp.s:29<br/>  7    LWP 33 "puma 002"          __cp_end () at src/thread/x86_64/syscall_cp.s:29<br/>  8    LWP 35 "puma 003"          __cp_end () at src/thread/x86_64/syscall_cp.s:29<br/>  9    LWP 36 "puma 004"          __cp_end () at src/thread/x86_64/syscall_cp.s:29<br/>  10   LWP 37 "puma 005"          __cp_end () at src/thread/x86_64/syscall_cp.s:29<br/>  11   LWP 39 "puma 006"          __cp_end () at src/thread/x86_64/syscall_cp.s:29<br/>  12   LWP 40 "puma 007"          __cp_end () at src/thread/x86_64/syscall_cp.s:29<br/>  13   LWP 41 "puma 008"          __cp_end () at src/thread/x86_64/syscall_cp.s:29<br/>  14   LWP 42 "puma 009"          __cp_end () at src/thread/x86_64/syscall_cp.s:29<br/>  15   LWP 43 "puma 010"          __cp_end () at src/thread/x86_64/syscall_cp.s:29<br/>  16   LWP 44 "puma 011"          __cp_end () at src/thread/x86_64/syscall_cp.s:29<br/>  17   LWP 45 "puma 012"          __cp_end () at src/thread/x86_64/syscall_cp.s:29<br/>  18   LWP 46 "puma 013"          __cp_end () at src/thread/x86_64/syscall_cp.s:29<br/>  19   LWP 47 "puma 014"          __cp_end () at src/thread/x86_64/syscall_cp.s:29<br/>  20   LWP 48 "puma 015"          __cp_end () at src/thread/x86_64/syscall_cp.s:29<br/>...</span></pre><p id="768c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们看到15个puma线程处理请求。这是第一条线索:</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="3a1f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意这是一个<strong class="jp ir"> C级回溯</strong>。虽然这种回溯有助于猜测类似死锁问题的情况，但它似乎没有多少信息来定位根本问题。我们在C级回溯中找不到任何东西的事实表明，Ruby代码层可能就是原因。</p><p id="10ad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以，让我们得到一个<strong class="jp ir"> Ruby级别的回溯</strong>。在此之前，我们需要建立一个<code class="fe lp lq lr ls b"><strong class="jp ir">gdbinit</strong></code>文件来定义一些在Ruby官方库中维护的有用函数。</p><pre class="lu lv lw lx gt ml ls mm mn aw mo bi"><span id="fbf1" class="mp kn iq ls b gy mq mr l ms mt">bash-5.0# apk add curl<br/>bash-5.0# curl -o .gdbinit https://raw.githubusercontent.com/ruby/ruby/ruby_2_5/.gdbinit<br/>bash-5.0# mv .gdbinit /root/</span></pre><p id="7464" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">调用<code class="fe lp lq lr ls b"><strong class="jp ir">rb_ps</strong></code>转储一个Ruby级别的回溯，无论是附加到一个活动进程还是核心文件。</p><pre class="lu lv lw lx gt ml ls mm mn aw mo bi"><span id="5386" class="mp kn iq ls b gy mq mr l ms mt">(gdb) rb_ps<br/>$1 = (rb_vm_t *) 0x7ff149353700<br/>...<br/>* #&lt;Thread:0x56327568dfa0 rb_thread_t:0x56327646b020 native_thread:0x7fd3700dfb20&gt;<br/>147:0x7fd3739ca020 &lt;rb_mutex_lock at thread_sync.c:326&gt;:in `lock'<br/>146:/usr/local/lib/ruby/2.5.0/monitor.rb:192:in `mon_enter'<br/>145:/usr/local/lib/ruby/2.5.0/monitor.rb:233:in `block in mon_synchronize'<br/>144:0x7fd3739c7df0 &lt;rb_thread_s_handle_interrupt at vm_core.h:1622&gt;:in `handle_interrupt'<br/>143:/usr/local/lib/ruby/2.5.0/monitor.rb:233:in `mon_synchronize'<br/>142:/usr/local/lib/ruby/2.5.0/logger.rb:688:in `write'<br/>141:/usr/local/lib/ruby/2.5.0/logger.rb:471:in `add'<br/>140:/cocalero-api/vendor/bundle/ruby/2.5.0/gems/activesupport-6.0.1/lib/active_support/logger_thread_safe_level.rb:53:in `add'<br/>139:/usr/local/lib/ruby/2.5.0/logger.rb:527:in `info'<br/>138:/cocalero-api/vendor/bundle/ruby/2.5.0/gems/activesupport-6.0.1/lib/active_support/log_subscriber.rb:119:in `info'<br/>137:/cocalero-api/vendor/bundle/ruby/2.5.0/gems/activejob-6.0.1/lib/active_job/logging.rb:57:in `enqueue'<br/>...</span></pre><p id="cfcb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我们发现了根本问题:<strong class="jp ir">所有挂起的线程都在等待具有完全相同回溯的监视器/互斥锁</strong>。</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="ng nh l"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated"><a class="ae kl" href="https://github.com/ruby/ruby/blob/ruby_2_5/lib/monitor.rb#L192" rel="noopener ugc nofollow" target="_blank">https://github . com/ruby/ruby/blob/ruby _ 2 _ 5/lib/monitor . Rb # L192</a></figcaption></figure><p id="8fba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">出于某种原因，这把锁从未打开过。我预计线程列表会有一个持有锁的有问题的线程，但实际上，我找不到它。总之，gdb向我们展示了线程挂起的位置，但不是导致这种情况的确切线程<strong class="jp ir">。</strong></p><h1 id="faf9" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">如何缓解这个问题</h1><p id="89ee" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">根据Ruby级回溯，<strong class="jp ir">在MySQL事务期间调用</strong> <code class="fe lp lq lr ls b"><strong class="jp ir">Rails.logger</strong></code> <strong class="jp ir">可以触发</strong> <code class="fe lp lq lr ls b"><strong class="jp ir">ActiveRecord::LockWaitTimeout</strong></code> <strong class="jp ir">异常</strong>，因为被阻塞的线程持有MySQL锁。方法<code class="fe lp lq lr ls b">write</code>建立在<code class="fe lp lq lr ls b">Monitor#synchronize</code>之上，用于保护输出设备周围的竞争条件。</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="ng nh l"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated"><a class="ae kl" href="https://github.com/ruby/ruby/blob/ruby_2_5/lib/logger.rb#L688" rel="noopener ugc nofollow" target="_blank">https://github . com/ruby/ruby/blob/ruby _ 2 _ 5/lib/logger . Rb # L688</a></figcaption></figure><p id="e235" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，我们将Sidekiq作业作为事务中的ActiveRecord回调入队，这个入队实际上需要一个日志记录动作。基本上，在事务期间执行额外的I/O是不安全的操作。</p><p id="b403" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们修复了在提交数据库事务后对作业进行排队，以缓解目前的问题。</p><pre class="lu lv lw lx gt ml ls mm mn aw mo bi"><span id="4db0" class="mp kn iq ls b gy mq mr l ms mt">- after_destroy :delete_session, :enqueue_notification_job<br/>+ after_destroy :delete_session<br/>+ after_destroy_commit :enqueue_notification_job</span></pre><p id="0cd2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，这种缓解可以防止像<code class="fe lp lq lr ls b">ActiveRecord::LockWaitTimeout</code>异常这样的严重错误🎉。一些puma工作人员仍然苦于没有可用的线程。但是这给了我更多的时间去深入调查。</p><h1 id="6720" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">根本原因是什么</h1><p id="6dcf" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">我曾怀疑<code class="fe lp lq lr ls b"><a class="ae kl" href="https://ruby-doc.org/stdlib-2.5.1/libdoc/timeout/rdoc/Timeout.html" rel="noopener ugc nofollow" target="_blank">Timeout.timeout</a></code>是一种棘手的机制，可能会打破必须首先保持一致的内部状态。实际上，这个事件是从我们向<code class="fe lp lq lr ls b">Timeout.timeout</code>引入额外呼叫的那天开始的。</p><ul class=""><li id="290d" class="mu mv iq jp b jq jr ju jv jy mw kc mx kg my kk mz na nb nc bi translated">注意<code class="fe lp lq lr ls b">Timeout.timeout</code>产生了一个专门运行给定块的新线程，如果它在固定的时间内没有完成，通过发送一个异常来强制终止它。</li><li id="d14b" class="mu mv iq jp b jq ni ju nj jy nk kc nl kg nm kk mz na nb nc bi translated"><a class="ae kl" href="https://adamhooper.medium.com/in-ruby-dont-use-timeout-77d9d4e5a001" rel="noopener">正如许多资源所警告的那样</a>，这种行为本质上有可能破坏应用程序级别的状态。然而，Ruby提供了一种实现必须互斥的临界区的方法。就是我们在回溯中提到的<a class="ae kl" href="https://ruby-doc.org/stdlib-2.5.3/libdoc/monitor/rdoc/Monitor.html" rel="noopener ugc nofollow" target="_blank">监视器类</a>。通常，几乎所有可靠的库都依赖于这个类，并适当地保护它们的不变量。然而，我们遇到了一个死锁/竞争条件问题，因此这是我们当时试图解决的棘手问题。</li></ul><pre class="lu lv lw lx gt ml ls mm mn aw mo bi"><span id="e080" class="mp kn iq ls b gy mq mr l ms mt">require 'monitor'<br/><br/>lock = Monitor.new<br/>lock.synchronize do<br/>  <strong class="ls ir"># exclusive access</strong><br/>end</span></pre><p id="29b4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">虽然我确信延长超时时间或停止通话等简单的解决方法可以解决这个问题，但我发现这并不有趣，因此我花了足够的时间进行调查，作为一次学习经历。</p><p id="b6a4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">也就是说，回溯暗示了一种可能性，即<strong class="jp ir">一个获取互斥体的线程突然被终止，因为它没有在超时</strong>内完成。的确，<code class="fe lp lq lr ls b">Timeout::Error</code> exception有一个回溯来显示该块被强制停止的位置。添加一行以打印新的错误日志:</p><pre class="lu lv lw lx gt ml ls mm mn aw mo bi"><span id="7cf8" class="mp kn iq ls b gy mq mr l ms mt">rescue Timeout::Error =&gt; e<br/>+  Rails.logger.error("timeout occured.\n#{e.message}\n#{e.backtrace.join("\n")}")<br/>end</span></pre><p id="09b2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是<code class="fe lp lq lr ls b">e.backtrace</code>的节选:</p><pre class="lu lv lw lx gt ml ls mm mn aw mo bi"><span id="c77e" class="mp kn iq ls b gy mq mr l ms mt">timeout occured.<br/>/usr/local/lib/ruby/2.5.0/monitor.rb:233:in `handle_interrupt' <br/>/usr/local/lib/ruby/2.5.0/monitor.rb:233:in `mon_synchronize' /usr/local/lib/ruby/2.5.0/logger.rb:688:in `write' /usr/local/lib/ruby/2.5.0/logger.rb:471:in `add' /cocalero-api/vendor/bundle/ruby/2.5.0/gems/activesupport-6.0.1/lib/active_support/logger_thread_safe_level.rb:53:in `add' /usr/local/lib/ruby/2.5.0/logger.rb:527:in `info'</span></pre><p id="7b7b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">终于，我们找到了根本原因。<strong class="jp ir">如果</strong> <code class="fe lp lq lr ls b"><strong class="jp ir">Timeout::Error</strong></code> <strong class="jp ir">在</strong> <code class="fe lp lq lr ls b"><strong class="jp ir">begin</strong></code> <strong class="jp ir">块之前线程正在执行时被引发，</strong></p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="ng nh l"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">monitor.rb:233:在“句柄_中断”中</figcaption></figure><p id="80ec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">它破坏了监视器的状态并导致死锁，尽管源代码注释否认了这一点。</strong>表示线程在执行<code class="fe lp lq lr ls b">mon_enter</code>后有可能不调用<code class="fe lp lq lr ls b">mon_exit</code>。这违反了确保线程解锁它之前自己锁定的监视器的不变量。</p><p id="eeb7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是繁殖的方法:</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="ng nh l"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">可复制脚本</figcaption></figure><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="ng nh l"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">结果</figcaption></figure><p id="34ec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我还确认了在对Ruby的<code class="fe lp lq lr ls b">monitor.rb</code>文件应用了下面的补丁后，它再也不会重现了。</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="ng nh l"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">修补程序来修复此问题</figcaption></figure><h1 id="d405" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">如何避免这个bug</h1><p id="dc81" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">将您的Ruby版本升级到2.7.2或3.0.0可以彻底解决这个问题，因为在这些版本中，监视器是用C语言重新实现的。</p><p id="ca1b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">否则，当<code class="fe lp lq lr ls b">Timeout::Error</code>异常发生时，您可以通过简单的方式手动解锁显示器。但它可能过于特殊，无法在生产中采用。下面是示例代码:</p><pre class="lu lv lw lx gt ml ls mm mn aw mo bi"><span id="5cc3" class="mp kn iq ls b gy mq mr l ms mt">rescue Timeout::Error =&gt; e<br/>  logdev = Rails.logger.instance_variable_get(:@logdev)<br/>  if logdev.mon_owned?<br/>    logdev.mon_exit<br/>  end<br/>end</span></pre><h1 id="f462" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">包扎</h1><p id="b710" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">Ruby v2.5.8和v2.6.6有一个bug导致了由<code class="fe lp lq lr ls b">Timeout.timeout</code>触发的死锁。v2.6的上游目前还没定(2021–04–04)。</p><p id="4602" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我通过收集核心转储、阅读Ruby和我们的应用程序中的源代码，以及使用<code class="fe lp lq lr ls b">GDB</code>分析回溯来识别这个bug。</p></div></div>    
</body>
</html>