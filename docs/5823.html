<html>
<head>
<title>GraphQL made simple with React Suspense and Hooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用React悬念和钩子简化了GraphQL</h1>
<blockquote>原文：<a href="https://itnext.io/graphql-made-simple-with-react-suspense-and-hooks-46e16d3f03bb?source=collection_archive---------4-----------------------#2021-06-02">https://itnext.io/graphql-made-simple-with-react-suspense-and-hooks-46e16d3f03bb?source=collection_archive---------4-----------------------#2021-06-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/></div><div class="ab cl jq jr hx js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="im in io ip iq"><figure class="jy jz ka kb gt kc gh gi paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="gh gi jx"><img src="../Images/2c32698a84034ed6ce93e0bfa9bf7cd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TfuL5MXtCrKaprbs0hGzhQ.png"/></div></div></figure><p id="8092" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">虽然仍然被认为是实验性的，React悬念当然值得一试，即使是较小的个人项目。</p><p id="a382" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">悬念有助于以声明的方式控制组件的生命周期，并防止出现竞争情况。</p><p id="00b9" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">使用暂挂和钩子，我们可以编写干净的功能性代码来管理状态，并在获取GraphQL数据时处理错误。</p><h1 id="81fa" class="lh li it bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">反应暂停概述</h1><p id="0222" class="pw-post-body-paragraph kj kk it kl b km mf ko kp kq mg ks kt ku mh kw kx ky mi la lb lc mj le lf lg im bi translated">暂停的一个主要用例是在异步操作期间管理应用程序状态。有了悬念，您可以避免编写烦人的命令式代码，如条件呈现，以及组件内部的try/catch语句。</p><p id="3488" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">另一个众所周知的用例是<a class="ae mk" href="https://developer.mozilla.org/en-US/docs/Glossary/Code_splitting" rel="noopener ugc nofollow" target="_blank">代码分解</a>，但是我们不会在这篇文章中讨论它。</p><p id="675d" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">在一个典型的现代UI中，获取数据时有大量的事情要处理。您必须切换加载器，防止竞争情况，并保持事件的正确顺序。悬念让一切变得无比简单。以下是您通常使用React悬念的方式:</p><figure class="jy jz ka kb gt kc"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="868c" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">你可能已经注意到的一件有趣的事情是，我们在应用程序加载时创建了一个<code class="fe mn mo mp mq b">initialResource</code>对象。那么这个资源到底是什么呢？让我们简单介绍一下资源，它们非常重要。</p><p id="2473" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">资源是暂记异步数据的来源。本质上，资源只是一个拥有<code class="fe mn mo mp mq b">read</code>方法的对象。React Suspense将根据内部工作需要调用该方法。</p><p id="8f5d" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">那么悬念到底对我们有什么作用呢？</p><p id="e0a1" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">注意我们如何调用<code class="fe mn mo mp mq b">resource.user.read()</code>而没有任何安全检查。获取用户信息是一个异步过程，但我们同步使用资源，因为我们知道悬念将负责获取和检查数据。我们需要做的就是用一个<code class="fe mn mo mp mq b">fallback</code>组件提供悬念。</p><p id="ff93" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">这种方法通过消除对安全检查和条件呈现的需要以及防止竞争情况，使我们的应用程序更干净、更健壮。</p><h1 id="f23a" class="lh li it bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">使用GraphQL的悬念</h1><p id="bbd9" class="pw-post-body-paragraph kj kk it kl b km mf ko kp kq mg ks kt ku mh kw kx ky mi la lb lc mj le lf lg im bi translated">我们将构建一个简单的应用程序，使用它们的公共<a class="ae mk" href="https://api.spacex.land/graphql/" rel="noopener ugc nofollow" target="_blank"> GraphQL端点</a>显示SpaceX火箭发射。</p><figure class="jy jz ka kb gt kc gh gi paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="gh gi mr"><img src="../Images/805695587bdd0a11913187a8dbbeb1b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k-doNKJK-WnVcCNug-CHsw.png"/></div></div></figure><p id="0eeb" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">我们将使用<a class="ae mk" href="https://www.apollographql.com/docs/react/" rel="noopener ugc nofollow" target="_blank"> Apollo客户端</a>，因为根据我的经验，它更容易使用。但是您可以使用任何其他GraphQL客户端做同样的事情。</p><h2 id="a3a1" class="ms li it bd lj mt mu dn ln mv mw dp lr ku mx my lv ky mz na lz lc nb nc md nd bi translated">添加apollo客户端</h2><p id="5d33" class="pw-post-body-paragraph kj kk it kl b km mf ko kp kq mg ks kt ku mh kw kx ky mi la lb lc mj le lf lg im bi translated">首先，让我们设置我们的Apollo客户机，我们将使用它来发送查询。</p><figure class="jy jz ka kb gt kc"><div class="bz fp l di"><div class="ml mm l"/></div></figure><h2 id="7477" class="ms li it bd lj mt mu dn ln mv mw dp lr ku mx my lv ky mz na lz lc nb nc md nd bi translated">添加graphql查询</h2><p id="ec44" class="pw-post-body-paragraph kj kk it kl b km mf ko kp kq mg ks kt ku mh kw kx ky mi la lb lc mj le lf lg im bi translated">现在我们将添加获取启动的查询。为了遵循良好的实践，我们将它存储在一个单独的文件中:</p><figure class="jy jz ka kb gt kc"><div class="bz fp l di"><div class="ml mm l"/></div></figure><h2 id="c0eb" class="ms li it bd lj mt mu dn ln mv mw dp lr ku mx my lv ky mz na lz lc nb nc md nd bi translated">工厂功能</h2><p id="decb" class="pw-post-body-paragraph kj kk it kl b km mf ko kp kq mg ks kt ku mh kw kx ky mi la lb lc mj le lf lg im bi translated">这就是悬念发挥作用的地方。让我们创建一个接受GraphQL查询并返回资源的工厂函数:</p><figure class="jy jz ka kb gt kc"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="6f39" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">我们的工厂函数跟踪异步请求的状态和服务器响应。我们还有一个存储GraphQL查询承诺的<code class="fe mn mo mp mq b">suspender</code>。当我们从服务器得到反馈时，我们更新<code class="fe mn mo mp mq b">status</code>和<code class="fe mn mo mp mq b">result</code>变量。</p><p id="ce59" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">所以工厂函数返回一个资源，正如我提到的，资源只是一个带有<code class="fe mn mo mp mq b">read</code>方法的对象。<code class="fe mn mo mp mq b">read</code>方法执行以下操作:</p><ul class=""><li id="661d" class="ne nf it kl b km kn kq kr ku ng ky nh lc ni lg nj nk nl nm bi translated">如果状态是pending，<code class="fe mn mo mp mq b">read</code>抛出<code class="fe mn mo mp mq b">suspender</code>承诺，该Suspense将捕获并显示<code class="fe mn mo mp mq b">fallback</code>组件。</li><li id="9149" class="ne nf it kl b km nn kq no ku np ky nq lc nr lg nj nk nl nm bi translated">如果状态为<code class="fe mn mo mp mq b">completed</code>，则<code class="fe mn mo mp mq b">read</code>返回结果。</li><li id="b942" class="ne nf it kl b km nn kq no ku np ky nq lc nr lg nj nk nl nm bi translated">如果状态为<code class="fe mn mo mp mq b">error</code>，则‘读取<code class="fe mn mo mp mq b">throws the</code>结果’,在这种情况下，这是一个错误实例。信不信由你，那是最复杂的部分。</li></ul><h2 id="fb05" class="ms li it bd lj mt mu dn ln mv mw dp lr ku mx my lv ky mz na lz lc nb nc md nd bi translated">使用API挂钩</h2><p id="a087" class="pw-post-body-paragraph kj kk it kl b km mf ko kp kq mg ks kt ku mh kw kx ky mi la lb lc mj le lf lg im bi translated">严格来说，我们可以直接使用<code class="fe mn mo mp mq b">wrapGraphql</code>而不用把它打包成一个钩子。但是自定义钩子是一个很好的抽象，如果我们决定以后添加东西，比如在发送请求之前检查会话状态或权限，它会很方便。</p><figure class="jy jz ka kb gt kc"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="1072" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated"><code class="fe mn mo mp mq b">useAPI</code>的代码很简单。钩子接受一个查询并使用<code class="fe mn mo mp mq b">wrapGraphql</code>工厂函数返回一个新的资源。</p><p id="0205" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">最后，我们将如何使用它:</p><figure class="jy jz ka kb gt kc"><div class="bz fp l di"><div class="ml mm l"/></div></figure><h1 id="ed77" class="lh li it bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">结论</h1><p id="4da8" class="pw-post-body-paragraph kj kk it kl b km mf ko kp kq mg ks kt ku mh kw kx ky mi la lb lc mj le lf lg im bi translated">顺便提一下:我们对GraphQL客户端使用了Apollo，然而，另一个可以考虑的选择是<a class="ae mk" href="https://relay.dev/docs/" rel="noopener ugc nofollow" target="_blank"> Relay </a>。接力与反应悬念紧密结合，可能是你更好的选择。也就是说，它也更固执己见，我发现阿波罗更容易使用。</p><p id="f39b" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">这个帖子到此为止。我们对GraphQL使用了React Suspense，但是您当然可以对它进行修改，使其适用于任何其他异步源代码。除了处理异步操作，悬念还有更多应用。开始学习的最好地方是官方悬念<a class="ae mk" href="https://reactjs.org/docs/concurrent-mode-suspense.html" rel="noopener ugc nofollow" target="_blank">概述</a>文档。</p><p id="28e4" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">这里有这个教程的<a class="ae mk" href="https://codesandbox.io/s/suspense-hooks-graphql-mx0od" rel="noopener ugc nofollow" target="_blank">代码沙箱</a>的链接。</p></div><div class="ab cl jq jr hx js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="im in io ip iq"><p id="502e" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated"><em class="ns">原载于2021年6月2日</em><a class="ae mk" href="https://isamatov.com/react-suspense-graphql-hooks/" rel="noopener ugc nofollow" target="_blank"><em class="ns">【https://isamatov.com】</em></a><em class="ns">。</em></p></div></div>    
</body>
</html>