<html>
<head>
<title>Migrating to containerd and CRI-O after Dockershim Deprecation in Kubernetes 1.24</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Kubernetes 1.24中Dockershim被弃用后迁移到containerd和CRI-O</h1>
<blockquote>原文：<a href="https://itnext.io/migrating-to-containerd-and-cri-o-after-dockershim-deprecation-in-kubernetes-1-24-5df1c7ff434f?source=collection_archive---------4-----------------------#2022-03-01">https://itnext.io/migrating-to-containerd-and-cri-o-after-dockershim-deprecation-in-kubernetes-1-24-5df1c7ff434f?source=collection_archive---------4-----------------------#2022-03-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/3b52fe89b52a47e3c6639413d588369f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*dy98Jqp5FtHzVNwn.png"/></div></div></figure><p id="e07b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最近，我们已经知道Docker将被Kubernetes弃用！(<a class="ae kw" href="https://kubernetes.io/blog/2021/11/12/are-you-ready-for-dockershim-removal/" rel="noopener ugc nofollow" target="_blank">查看来自Kubernetes </a>的这篇官方文章)所以让我们更深入地讨论一下为什么会这样？</p><h1 id="6a9f" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">为什么从K8s 1.24开始dockershim被弃用？</h1><p id="291e" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">在1.24版本中，Kubernetes将不再支持Docker作为容器运行时。Docker正在被淘汰，取而代之的是使用为Kubernetes构建的容器运行时接口(CRI)的运行时。如果你是Kubernetes的最终用户，你不会注意到太大的区别。这并不意味着Docker已经死了，也不意味着你不能或者不应该把它作为一个开发工具。Docker仍然是一个创建容器的有用工具，由<code class="fe ma mb mc md b">docker build</code>生成的图像可以在您的Kubernetes集群中使用。如果您希望创建集群，您必须进行某些调整以避免集群失败。由于Docker将从K8s 1.24中弃用，您必须转换到其他兼容的容器运行时，如containerd或CRI-O。只需确保您选择的运行时支持Docker守护进程的当前设置(如日志记录)。</p><h1 id="707b" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">为什么听到这个消息的人都吓坏了？</h1><p id="008f" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">考虑了两种环境，这造成了一些混乱。Kubernetes集群中有一个称为容器运行时的组件，负责获取和运行容器映像。尽管Docker是该运行时的流行选择，但它并不打算集成到Kubernetes中，这就产生了问题。</p><h1 id="04df" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">未来会使用Dockerfiles吗？</h1><p id="245d" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">这一修改是为在不同环境中使用Docker的开发人员设计的。Kubernetes集群中的Docker运行时独立于开发Docker安装。Docker在修改之前的所有方面对开发人员来说仍然是有价值的。Docker生成了一个OCI(开放容器倡议)映像，这并不是一个真正针对Docker的映像。Kubernetes将以同样的方式对待任何符合OCI标准的图像，不管它是用什么工具创建的。containerd和CRI-O都能够提取和运行这样的图像。</p><h1 id="c4f1" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">如何从Docker切换到containerd &amp; CRI-O？</h1><p id="9b81" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated"><strong class="ka ir">第一步:警戒线&amp;漏节点</strong></p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="d8e7" class="mm ky iq md b gy mn mo l mp mq">$ kubectl cordon &lt;Node name&gt;<br/>$ kubectl drain &lt;Node Name&gt; --ignore-daemonsets</span></pre><p id="6512" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">第二步:停止服务</strong></p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="a19e" class="mm ky iq md b gy mn mo l mp mq">$ systemctl stop kubelet<br/>$ systemctl stop docker</span></pre><p id="fb25" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">第三步:移除Docker(可选):</strong></p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="0df8" class="mm ky iq md b gy mn mo l mp mq">apt purge docker-ce docker-ce-cli</span></pre><p id="6db2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">运筹学</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="46fb" class="mm ky iq md b gy mn mo l mp mq">yum remove docker-ce docker-ce-cli</span></pre><h1 id="b304" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">从Docker迁移到containerd</h1><p id="63d2" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated"><strong class="ka ir">步骤4:配置containerd </strong></p><p id="b439" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">禁用/etc/containerd/config.toml中的disabled_plugins行来启用CRI接口。</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="ad61" class="mm ky iq md b gy mn mo l mp mq">#disabled_plugins = ["cri"]</span></pre><p id="82cd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意:如果还没有默认的containerd配置文件，您可以创建一个新的:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="e1ec" class="mm ky iq md b gy mn mo l mp mq">containerd config default &gt; /etc/containerd/config.toml</span></pre><p id="3261" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后重新启动containerd:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="e878" class="mm ky iq md b gy mn mo l mp mq">systemctl restart containerd</span></pre><p id="4d82" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">第五步:更改运行时</strong>在/var/lib/kube let/kube ADM-flags . env中添加这两个containerd运行时标志:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="39fa" class="mm ky iq md b gy mn mo l mp mq">--container-runtime=remote <br/>--container-runtimeendpoint=unix:///run/containerd/containerd.sock"</span></pre><p id="99a1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">第六步:现在你可以启动kubelet </strong></p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="e601" class="mm ky iq md b gy mn mo l mp mq">systemctl start kubelet</span></pre><p id="fb19" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">步骤7:测试你的容器运行时</strong></p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="45cc" class="mm ky iq md b gy mn mo l mp mq">kubectl get nodes -o wide</span></pre><p id="8294" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，您可以打开节点:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="ff83" class="mm ky iq md b gy mn mo l mp mq">kubectl uncordon &lt;Node&gt;</span></pre><p id="da63" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你完了！</p><h1 id="3552" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">从Docker迁移到CRI-O</h1><p id="9be9" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated"><strong class="ka ir">第四步:CRI-O库&amp;安装</strong></p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="35c4" class="mm ky iq md b gy mn mo l mp mq">$ add-apt-repository ppa:projectatomic/ppa<br/>$ apt update<br/>$ apt install -y cri-o-1.15</span></pre><p id="bc5d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">第五步:配置CRI-O &amp;内核</strong>创建文件<code class="fe ma mb mc md b">99-kubernetes-crio.conf</code></p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="786b" class="mm ky iq md b gy mn mo l mp mq">vi /etc/sysctl.d/99-kubernetes-crio.conf</span></pre><p id="083a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">并添加以下几行:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="994d" class="mm ky iq md b gy mn mo l mp mq">net.bridge.bridge-nf-call-iptables  = 1<br/>net.ipv4.ip_forward                 = 1<br/>net.bridge.bridge-nf-call-ip6tables = 1</span></pre><p id="9f38" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将更改应用到内核:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="17cd" class="mm ky iq md b gy mn mo l mp mq">sysctl -a</span></pre><p id="2a4f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">验证<code class="fe ma mb mc md b">crio.conf</code>并编辑<code class="fe ma mb mc md b">cri-o</code>以使用Docker注册表</p><p id="d3a6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">打开文件<code class="fe ma mb mc md b">crio.conf</code>:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="6af1" class="mm ky iq md b gy mn mo l mp mq">vim /etc/crio/crio.conf</span></pre><p id="18d1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">检查配置中到conmon的路径是否准确；如果没有，运行命令:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="e73c" class="mm ky iq md b gy mn mo l mp mq">which conmon</span></pre><p id="0e84" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将输出添加到<code class="fe ma mb mc md b">crio.conf</code>文件中</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="d1be" class="mm ky iq md b gy mn mo l mp mq"># Path to the conmon binary, used for monitoring the OCI runtime.<br/>conmon = "/usr/bin/conmon"</span></pre><p id="bc4f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">还要确保“注册表”选项被注释掉</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="80ea" class="mm ky iq md b gy mn mo l mp mq">registries = [<br/>        "quay.io",<br/>        "docker.io",<br/>]</span></pre><p id="833d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">第六步:现在您可以启动CRI-O </strong></p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="fe8e" class="mm ky iq md b gy mn mo l mp mq">$ systemctl enable crio<br/>$ systemctl start crio</span></pre><p id="1629" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">第7步:配置并启动kubelet </strong> Edit <code class="fe ma mb mc md b">vi /etc/default/kubelet</code>，看起来应该是这样的:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="0224" class="mm ky iq md b gy mn mo l mp mq">KUBELET_EXTRA_ARGS=--feature-gates="AllAlpha=false" --container-runtime=remote --cgroup-driver=systemd --container-runtime-endpoint='unix:///var/run/crio/crio.sock' --runtime-request-timeout=5m</span></pre><p id="c695" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后启动kubelet:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="e41c" class="mm ky iq md b gy mn mo l mp mq">systemctl start kubelet</span></pre><p id="a863" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第八步:现在你可以解锁你的节点:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="41fe" class="mm ky iq md b gy mn mo l mp mq">kubectl uncordon &lt;Node&gt;</span></pre><p id="a691" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你完了！</p><h1 id="9344" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">摘要</h1><p id="9fde" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">最后，我想补充一点，Docker被Kubernetes弃用并不意味着你不能使用Docker。这只是意味着Docker不会被用作Kubernetes中的默认引擎，这完全取决于您在选择特定的容器运行时时的需求，因为它们都有自己的优势。</p><p id="8199" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请务必查看Kubernetes的官方文章以了解更多信息(<a class="ae kw" href="https://kubernetes.io/blog/2021/11/12/are-you-ready-for-dockershim-removal/" rel="noopener ugc nofollow" target="_blank">查看此处！</a>)。敬请关注更多此类内容！</p><h1 id="edc7" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">关于KubeSphere</h1><p id="af66" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">KubeSphere是一个基于Kubernetes的开源容器平台，其核心是应用程序。它提供全栈It自动化操作和简化的开发运维工作流。</p><p id="fbf2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kw" href="https://kubesphere.io" rel="noopener ugc nofollow" target="_blank"> KubeSphere </a>提供向导界面和各种企业级的运维功能，包括Kubernetes资源管理、<a class="ae kw" href="https://kubesphere.io/devops/" rel="noopener ugc nofollow" target="_blank"> DevOps (CI/CD) </a>、应用生命周期管理、服务网格、多租户管理、<a class="ae kw" href="https://kubesphere.io/observability/" rel="noopener ugc nofollow" target="_blank">监控</a>、日志记录、警报、通知、存储和网络管理以及GPU支持。有了KubeSphere，企业能够快速建立一个强大且功能丰富的容器平台。</p><p id="d190" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">欲了解更多信息，请访问<a class="ae kw" href="https://kubesphere.io/" rel="noopener ugc nofollow" target="_blank"> https://kubesphere.io </a></p></div></div>    
</body>
</html>