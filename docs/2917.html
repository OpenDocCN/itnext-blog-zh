<html>
<head>
<title>Handling complex form state using React Hooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用React钩子处理复杂的表单状态</h1>
<blockquote>原文：<a href="https://itnext.io/handling-complex-form-state-using-react-hooks-45370515e47?source=collection_archive---------0-----------------------#2019-08-29">https://itnext.io/handling-complex-form-state-using-react-hooks-45370515e47?source=collection_archive---------0-----------------------#2019-08-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="ca20" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一些优点的替代方法</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/be373847515f7929d3fcc30a1b4ba142.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kEPCQNY4dwVyaFuLEwJcNQ.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">大家都上钩了吗？<a class="ae lb" href="https://cdn-media-1.freecodecamp.org/images/1*0MgGEfZfLO91g1Oa2h3ebQ@2x.png" rel="noopener ugc nofollow" target="_blank">形象积分——免费代码营</a></figcaption></figure><p id="5527" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以，距离<strong class="jp ir"> React hooks </strong>发布已经有一段时间了。从表面上看，每个人都为他们着迷。嗯，我明白。因为我也是你们中的一员。钩子让我着迷！</p><p id="7757" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">钩子允许我们创建更小的、可组合的、可重用的、更易管理的React组件。</p><p id="c009" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有时你可能使用钩子来管理表单状态，使用<strong class="jp ir"> useState </strong>或<strong class="jp ir"> useReducer。</strong></p><p id="997a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，让我们考虑一个场景，其中您必须管理一个具有多个表单输入的复杂表单状态，表单输入可以是几种不同的类型，如<em class="lc">文本、数字、日期</em>输入。表单状态甚至可以有嵌套信息，例如，用户的地址信息有自己的子字段，如<em class="lc"> address.addressLine1 </em>、<em class="lc"> address.addressLine2 </em>等。</p><p id="6c13" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">也许你还需要根据当前状态更新表单状态，比如切换按钮。</p><p id="d3ca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，如果您对每个单独的表单字段使用<strong class="jp ir"> useState </strong>，那么您就能够基于当前状态计算新的状态。</p><pre class="km kn ko kp gt ld le lf lg aw lh bi"><span id="211f" class="li lj iq le b gy lk ll l lm ln">const [modalActive, updateModal] = useState(false)<br/>.<br/>.<br/>.<br/>// new state based on previous<br/>updateModal(prev =&gt; !prev)</span></pre><p id="cc56" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是，如果你有太多的单个表单字段，比如100+，(<strong class="jp ir"> YESS！！。我管理着100多个表单字段</strong>，这种方法并不友好。</p><p id="bd5a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">想象一下！！..</p><pre class="km kn ko kp gt ld le lf lg aw lh bi"><span id="cff7" class="li lj iq le b gy lk ll l lm ln">const [firstName, setFirstName] = useState('')<br/>const [middleName, setMiddleName] = useState('')<br/>const [lastName, setLastName] = useState('')<br/>.<br/>.<br/>.<br/>.</span></pre><p id="40d6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">编写不同的使用状态，然后为每个字段使用单独的更新函数是不实际的。</p><p id="7fa1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以，我们的另一个选择是钩子，<strong class="jp ir"> useReducer。</strong></p><p id="2c73" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们看一个例子。</p><pre class="km kn ko kp gt ld le lf lg aw lh bi"><span id="e284" class="li lj iq le b gy lk ll l lm ln">const initialState = {<br/>  firstName: '',<br/>  lastName: ''<br/>};</span><span id="f7d1" class="li lj iq le b gy lo ll l lm ln">function reducer(state, action) {<br/>  switch (action.type) {<br/>    case 'firstName':<br/>      return { firstName: action.payload };<br/>    case 'lastName':<br/>      return { lastName: action.payload };<br/>    default:<br/>      throw new Error();<br/>  }<br/>}</span><span id="6e3f" class="li lj iq le b gy lo ll l lm ln">function Counter() {<br/>  const [state, dispatch] = useReducer(reducer, initialState);</span><span id="04b4" class="li lj iq le b gy lo ll l lm ln">return (<br/>    &lt;&gt;<br/>      &lt;input<br/>        type="text"<br/>        name="firstName"<br/>        placeholder="First Name"<br/>        onChange={(event) =&gt; {<br/>          dispatch({<br/>           type: 'firstName',<br/>           payload: event.target.value<br/>          })<br/>        }}<br/>        value={state.firstName} /&gt;<br/>      &lt;input<br/>        type="text"<br/>        name="lastName"<br/>        placeholder="Last Name"<br/>        onChange={(event) =&gt; {<br/>          dispatch({<br/>           type: 'lastName',<br/>           payload: event.target.value<br/>          })<br/>        }}<br/>        value={state.lastName} /&gt;<br/>   &lt;/&gt;<br/>  );<br/>}</span></pre><p id="456b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">诶！！，不好。</p><p id="38c0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你不可能为reducer中的那些<strong class="jp ir"> n </strong>数量的表单字段编写每个用例。</p><p id="58f5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是<strong class="jp ir"> useReducer </strong>中使用的reducer函数只是一个普通的函数，返回更新后的状态对象。所以，我们可以做得更好。</p><pre class="km kn ko kp gt ld le lf lg aw lh bi"><span id="91e0" class="li lj iq le b gy lk ll l lm ln">function reducer(state, action) {<br/>  // field name and value are retrieved from event.target<br/>  const { name, value } = action<br/>  <br/>  // merge the old and new state<br/>  return { ...state, [name]: value }<br/>}</span></pre><p id="86aa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，这看起来是一个更好更干净的减速器。</p><p id="1b7d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是……这不允许我们在用回调函数调用update函数时根据当前状态计算新的状态。就像我们能做的一样..</p><pre class="km kn ko kp gt ld le lf lg aw lh bi"><span id="1e4e" class="li lj iq le b gy lk ll l lm ln">this.setState((prev) =&gt; ({ isActive: !prev }))</span><span id="c8f3" class="li lj iq le b gy lo ll l lm ln">// or</span><span id="373c" class="li lj iq le b gy lo ll l lm ln">const [modalActive, updateModal] = useState(false)<br/>.<br/>.<br/>.<br/>updateModal(prev =&gt; !prev)</span></pre><p id="861b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，如何更新嵌套状态，如<em class="lc"> address.addressLine1，address.pinCode. </em></p><p id="0baf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好吧！！。关于使用不太理想的方法来管理复杂的表单状态，我们已经讨论了很多。</p><p id="8040" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我向你展示解决方案。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="lp lq l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">哒哒！！</figcaption></figure><p id="2a32" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以，这是处理这种复杂表单场景的完整源代码。</p><p id="29d7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我稍微解释一下减速器(<strong class="jp ir"> enhancedReducer </strong> :P)的功能。</p><p id="da66" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">reducer函数接收两个参数，第一个参数是更新前的当前状态。当您调用<strong class="jp ir"> updateState / dispatch </strong>函数来更新减速器状态时，会自动提供该参数。reducer函数的第二个参数是您用来调用<strong class="jp ir"> updateState </strong>函数的值，它不必是{ type: 'something '，payload: 'something' }形式的典型<em class="lc"> redux操作对象</em>。它可以是任何东西，数字、字符串、对象甚至函数。</p><p id="7a75" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是我们正在利用的。如果<strong class="jp ir"> updateArg </strong>是一个函数，我们用当前状态调用它来计算新的状态。我们从这个函数返回的任何对象都成为我们的新状态。</p><p id="4363" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果updateArg是一个普通的旧Javascript对象，那么有两种情况。</p><p id="01ab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">1- <strong class="jp ir">该对象没有_path和_value属性— </strong>，因此是一个普通的更新对象，就像我们给this.setState的一样。因此，您可以用一个包含您想要更新的状态片段的新对象来调用<strong class="jp ir"> updateState </strong>，它会将其与旧对象合并，并返回新状态。</p><p id="88c1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2- <strong class="jp ir">对象具有_path和_value属性— </strong>当使用具有这两个属性的对象调用updateState函数时。我们将此视为特殊情况，其中<strong class="jp ir"> _path </strong>表示嵌套的字段路径。以字符串形式，例如:“address.pinCode”或表示路径的数组[“address”，“pinCode”]。</p><p id="577a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是，我们如何使用这样的路径表示来更新对象中的嵌套字段呢？。我们使用<strong class="jp ir">lodash’</strong>s<strong class="jp ir">set</strong>方法。它接受两种路径形式作为update和object的有效输入。</p><pre class="km kn ko kp gt ld le lf lg aw lh bi"><span id="f174" class="li lj iq le b gy lk ll l lm ln">set(objectToUpdate, path, newValue)</span><span id="51f7" class="li lj iq le b gy lo ll l lm ln">const state = {<br/>  name: {<br/>   first: '',<br/>   middle: '',<br/>   last: ''<br/>  }<br/>}</span><span id="dac3" class="li lj iq le b gy lo ll l lm ln">// and to update, for eg: first name.<br/>// both ways of path are correct.</span><span id="dd3e" class="li lj iq le b gy lo ll l lm ln">set(state, 'name.first', 'Aditya')<br/>set(state, ['name', 'first'], 'Aditya')</span></pre><p id="e6fd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是，<strong class="jp ir"> set </strong>方法就地改变对象，并且不返回新的副本，但是在React world中，变化检测依赖于<strong class="jp ir">不变性</strong>，一个新的数据副本，在内存中有一个新的位置。</p><p id="dc54" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，为了绕过这一点，我们使用<strong class="jp ir"> immer，</strong>以一种易于使用的形式帮助处理Javascript对象的不变性。</p><pre class="km kn ko kp gt ld le lf lg aw lh bi"><span id="b6c9" class="li lj iq le b gy lk ll l lm ln">import produce from 'immer'</span><span id="47a7" class="li lj iq le b gy lo ll l lm ln">produce(state, draft =&gt; {<br/>  set(draft, _path, _value);<br/>});</span></pre><p id="0012" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">从<strong class="jp ir"> </strong>产生</strong>函数immer <strong class="jp ir"> </strong>将对象作为它的第一个参数，在我们的例子中是当前状态，它的第二个参数是一个函数，它接收对象的<strong class="jp ir">草稿副本</strong>以进行变异，无论您在草稿状态下在这个函数内部修改什么，都是在<strong class="jp ir">副本</strong>上完成的，而不是实际输入对象的<strong class="jp ir">状态</strong>就地完成。然后自动返回<strong class="jp ir">新对象</strong>和<strong class="jp ir">更新后的</strong>数据。</p><p id="4106" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是我们的增强型减速器:D</p><p id="3759" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">仅仅</p><pre class="km kn ko kp gt ld le lf lg aw lh bi"><span id="276a" class="li lj iq le b gy lk ll l lm ln">yarn add lodash immer</span></pre><p id="4419" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">尽情享受吧。</p><p id="ad66" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">gist中的例子可以进一步细化，在<strong class="jp ir"> enhancedReducer </strong>中处理更多的边缘情况，并且可以通过映射表单规范对象来缩短表单字段代码，以动态地创建它，并减少代码重复和其他一些事情。</p><p id="9ee9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有些读者可能对这种方法有不同的看法。所以，我们可以随时讨论。</p><p id="696d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">也许你们中的一些人会有一个问题，如果我们这么想复制<strong class="jp ir"> this.setState </strong>，那么为什么不也有setState第二个参数回调函数，在状态更新后执行一些操作。嗯，这还不够明确！！！。我们将采用先做这个，后做那个的方法。我们将一步一步地告诉代码，如何做某事。而不是简单的告诉它做什么。我会使用<strong class="jp ir"> useEffect </strong>而不是回调函数和how to do方法，因为那是声明性的，<em class="lc">对变化做出反应。</em></p><p id="8dc9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">声明式和命令式，函数式编程是另一个话题，我会在以后分享。</p><p id="6b58" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">资源—</p><div class="lr ls gp gr lt lu"><a href="https://lodash.com/docs/4.17.15#set" rel="noopener  ugc nofollow" target="_blank"><div class="lv ab fo"><div class="lw ab lx cl cj ly"><h2 class="bd ir gy z fp lz fr fs ma fu fw ip bi translated">Lodash文档</h2><div class="mb l"><h3 class="bd b gy z fp lz fr fs ma fu fw dk translated">编辑描述</h3></div><div class="mc l"><p class="bd b dl z fp lz fr fs ma fu fw dk translated">lodash.com</p></div></div></div></a></div><div class="lr ls gp gr lt lu"><a href="https://github.com/immerjs/immer" rel="noopener  ugc nofollow" target="_blank"><div class="lv ab fo"><div class="lw ab lx cl cj ly"><h2 class="bd ir gy z fp lz fr fs ma fu fw ip bi translated">immerjs/immer</h2><div class="mb l"><h3 class="bd b gy z fp lz fr fs ma fu fw dk translated">通过简单地修改“年度突破”的当前树获胜者，创建下一个不可变的状态树…</h3></div><div class="mc l"><p class="bd b dl z fp lz fr fs ma fu fw dk translated">github.com</p></div></div><div class="md l"><div class="me l mf mg mh md mi kv lu"/></div></div></a></div></div></div>    
</body>
</html>