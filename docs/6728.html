<html>
<head>
<title>Vulnerabilities due to XML files processing: XXE in C# applications in theory and in practice</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">XML文件处理中的漏洞:XXE在C#应用中的理论和实践</h1>
<blockquote>原文：<a href="https://itnext.io/vulnerabilities-due-to-xml-files-processing-xxe-in-c-applications-in-theory-and-in-practice-f94912216093?source=collection_archive---------1-----------------------#2022-02-11">https://itnext.io/vulnerabilities-due-to-xml-files-processing-xxe-in-c-applications-in-theory-and-in-practice-f94912216093?source=collection_archive---------1-----------------------#2022-02-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="712a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">简单的XML文件处理是如何变成安全弱点的？部署在您机器上的博客如何会导致数据泄漏？今天我们将找到这些问题的答案，了解XXE是什么以及它看起来是什么样子。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/a24b19fcf8b56a754c911bfdd0b4b67d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*sfWa0Kv-YjXY-Ltp.png"/></div></div></figure><p id="61cc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们开始之前，请注意有几种与XML处理相关的漏洞。最常见的漏洞是XXE、XEE和XPath注入。在这篇文章中，我们考察了XXE。如果你对XEE攻击的本质感兴趣，你可以阅读这篇文章:“<a class="ae kx" href="https://pvs-studio.com/en/blog/posts/csharp/0865/" rel="noopener ugc nofollow" target="_blank">Visual Studio 2022如何耗尽100 GB内存，以及XML炸弹与此有什么关系</a>”。稍后我们将讨论XPath注入。:)</p><h1 id="5c8c" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">什么是XXE？</h1><p id="0a9a" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">XXE (XML外部实体)是应用程序的安全弱点。此攻击的可能来源是由不安全配置的XML解析器处理的受损数据。这种攻击可导致目标机器数据泄露或服务器端请求伪造(SSRF)。</p><p id="8ae2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">XML文件可能包含文档类型定义(<a class="ae kx" href="https://en.wikipedia.org/wiki/Document_type_definition" rel="noopener ugc nofollow" target="_blank"> DTD </a>，它描述了XML文件的结构。DTD允许我们定义和使用XML实体。</p><p id="7605" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它可能看起来像这样:</p><pre class="km kn ko kp gt mb mc md me aw mf bi"><span id="f0d2" class="mg kz iq mc b gy mh mi l mj mk">&lt;?xml version="1.0" encoding="utf-8" ?&gt;<br/>&lt;!DOCTYPE order [<br/>  &lt;!ENTITY myEntity "lol"&gt;<br/>]&gt;<br/>&lt;order&gt;&amp;myEntity;&lt;/order&gt;</span></pre><p id="f419" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这个XML中，我们声明<em class="ml"> myEntity </em>并进一步使用它—<em class="ml">&amp;my entity；</em>。在这种情况下，实体是内部的，并被定义为文字。如果一个XML解析器扩展了这个实体，它会替换掉<em class="ml">&amp;my entity；</em>带实际值— <em class="ml"> lol </em>。此外，一些内部实体可以通过其他实体扩展。XML炸弹可以通过这种方式创建并执行<a class="ae kx" href="https://pvs-studio.com/en/blog/terms/6545/" rel="noopener ugc nofollow" target="_blank"> XEE攻击</a>。</p><p id="6a0f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，实体可以是外部的。他们可以引用一些本地文件或访问外部资源:</p><pre class="km kn ko kp gt mb mc md me aw mf bi"><span id="ec59" class="mg kz iq mc b gy mh mi l mj mk">&lt;!ENTITY myExternalEntity SYSTEM "https://test.com/target.txt"&gt;</span></pre><p id="d995" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是一个XML文件的示例，其中外部实体引用本地文件:</p><pre class="km kn ko kp gt mb mc md me aw mf bi"><span id="f890" class="mg kz iq mc b gy mh mi l mj mk">&lt;?xml version="1.0" encoding="utf-8" ?&gt;<br/>&lt;!DOCTYPE order [<br/>  &lt;!ENTITY myExternalEntity SYSTEM "file:///D:/HelloWorld.cs"&gt;<br/>]&gt;<br/>&lt;order&gt;&amp;myExternalEntity;&lt;/order&gt;</span></pre><p id="5bbb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这种情况下，XML解析器用路径为<em class="ml"> D:/HelloWorld.cs </em>的文件内容替换<em class="ml"> myExternalEntity </em>。当然，如果配置得当的话。</p><p id="523d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">XXE攻击利用了上述特征。</p><p id="368d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里有一个例子。让我们假设有一个应用程序接受XML文件形式的查询，并用相应的ID处理项目。</p><p id="318e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该应用程序使用以下XML文件格式:</p><pre class="km kn ko kp gt mb mc md me aw mf bi"><span id="3ecd" class="mg kz iq mc b gy mh mi l mj mk">&lt;?xml version="1.0" encoding="utf-8" ?&gt;<br/>&lt;order&gt;<br/>  &lt;itemID&gt;62&lt;/itemID&gt;<br/>&lt;/order&gt;</span></pre><p id="38f1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">简化的C#代码:</p><pre class="km kn ko kp gt mb mc md me aw mf bi"><span id="b08c" class="mg kz iq mc b gy mh mi l mj mk"><strong class="mc ir">static</strong> <strong class="mc ir">void</strong> <strong class="mc ir">ProcessItemWithID</strong>(XmlReader reader, <br/>                              String pathToXmlFile)<br/>{<br/>  ....<br/>  <strong class="mc ir">while</strong> (reader.Read())<br/>  {<br/>    <strong class="mc ir">if</strong> (reader.Name == "itemID")<br/>    {<br/>      var itemIdStr = reader.ReadElementContentAsString();<br/>      <strong class="mc ir">if</strong> (<strong class="mc ir">long</strong>.TryParse(itemIdStr, out var itemIdValue))<br/>      {<br/>        <em class="ml">// Process item with the 'itemIdValue' value</em><br/>        Console.WriteLine(<br/>          $"An item with the '{itemIdValue}' ID was processed.");<br/>      }<br/>      <strong class="mc ir">else</strong><br/>      {<br/>        Console.WriteLine(<br/>          $"{itemIdStr} is not valid 'itemID' value.");<br/>      }<br/>    }<br/>  }<br/>}</span></pre><p id="a172" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">逻辑很简单:</p><ul class=""><li id="f70c" class="mm mn iq jp b jq jr ju jv jy mo kc mp kg mq kk mr ms mt mu bi translated">如果ID是一个数字，应用程序将报告相应的项目已被处理；</li><li id="f360" class="mm mn iq jp b jq mv ju mw jy mx kc my kg mz kk mr ms mt mu bi translated">如果ID不是一个数字，应用程序将发出一个错误。</li></ul><p id="c521" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，对于上面的XML文件，应用程序将显示以下行:</p><pre class="km kn ko kp gt mb mc md me aw mf bi"><span id="e941" class="mg kz iq mc b gy mh mi l mj mk">An item with the '62' ID was processed.</span></pre><p id="8f15" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们在ID中插入其他内容而不是数字(例如("<em class="ml"> Hello world </em>")，应用程序会报告一个错误:</p><pre class="km kn ko kp gt mb mc md me aw mf bi"><span id="a892" class="mg kz iq mc b gy mh mi l mj mk">"Hello world" is <strong class="mc ir">not</strong> valid 'itemID' value.</span></pre><p id="9c7d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果XML解析器(<em class="ml">阅读器</em>)处理外部实体，这就是一个安全缺陷。下面是一个可用于危害应用程序的XML文件:</p><pre class="km kn ko kp gt mb mc md me aw mf bi"><span id="3f8e" class="mg kz iq mc b gy mh mi l mj mk">&lt;?xml version="1.0" encoding="utf-8" ?&gt;<br/>&lt;!DOCTYPE order [<br/>  &lt;!ENTITY xxe SYSTEM "file:///D:/MySecrets.txt"&gt;<br/>]&gt;<br/>&lt;order&gt;<br/>  &lt;itemID&gt;&amp;xxe;&lt;/itemID&gt;<br/>&lt;/order&gt;</span></pre><p id="6c2c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这个文件中声明了<em class="ml"> xxe </em>外部实体。当XML解析器处理这个文件时，它用<em class="ml">&amp;xxe；</em>文件的内容沿着路径<em class="ml">D:/my crets . txt</em>。比如<em class="ml">“这是XXE的攻击目标。”</em>。因此，应用程序将显示以下内容:</p><pre class="km kn ko kp gt mb mc md me aw mf bi"><span id="250d" class="mg kz iq mc b gy mh mi l mj mk">"This is an XXE attack target." is <strong class="mc ir">not</strong> valid 'itemID' value.</span></pre><p id="6b98" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，如果出现以下情况，应用程序将容易受到XXE攻击:</p><ul class=""><li id="932a" class="mm mn iq jp b jq jr ju jv jy mo kc mp kg mq kk mr ms mt mu bi translated">开发人员配置XML解析器的方式使其不安全地处理外部实体；</li><li id="6d24" class="mm mn iq jp b jq mv ju mw jy mx kc my kg mz kk mr ms mt mu bi translated">攻击者可以直接/间接将受损数据传递给解析器。</li></ul><p id="519b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果攻击者可以获得实体的值，他们就可以从受损的设备上获取文件内容。这已经很危险了。此外，攻击者可以获得更多关于整个系统的数据，并发现其他安全弱点。</p><p id="78aa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">XXE也可能导致SSRF袭击。黑客可能无权访问某些资源(限制外部用户访问)，但被利用的应用程序可能拥有这些资源。由于XXE允许通过网络发出请求，因此受损的应用程序是对资源保护的破坏。</p><p id="0aec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">谈到XXE的重要性和危险性，这一安全弱点经常在各种标准、top和列举中被提及。</p><p id="06c1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> CWE </strong></p><p id="ff29" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">常见弱点枚举有一个单独的XXE条目:<a class="ae kx" href="https://cwe.mitre.org/data/definitions/611.html" rel="noopener ugc nofollow" target="_blank"> CWE-611:对XML外部实体引用的不当限制</a>。</p><p id="2c9d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">CWE 25强</strong></p><p id="5cfb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每年都会从CWE清单中选出25个最常见和最危险的弱点来编制CWE 25大弱点。</p><p id="f66e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">与2020年相比，XXE在2021年失去了4个位置，但仍保持在第23位。</p><p id="c165" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">奥瓦斯普·ASVS</p><p id="aa7c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kx" href="https://owasp.org/www-project-application-security-verification-standard/" rel="noopener ugc nofollow" target="_blank"> OWASP ASVS </a> <em class="ml"> </em>(应用安全验证标准)<em class="ml"> </em>包含安全开发的需求。它还有一个关于XXE的条目:<em class="ml"> OWASP ASVS 4.0.3 (ID 5.5.2):验证应用程序是否正确地限制XML解析器只使用最严格的配置，并确保禁用不安全的特性，如解析外部实体，以防止XML外部实体(XXE)攻击</em>。</p><p id="ac8c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> OWASP前10名</strong></p><p id="3077" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">OWASP 2017年前10名为XXE设立了一个单独的类别:<a class="ae kx" href="https://owasp.org/www-project-top-ten/2017/A4_2017-XML_External_Entities_(XXE)" rel="noopener ugc nofollow" target="_blank"> A4:2017-XML外部实体(XXE) </a>。在OWASP 2021年前10名中，取消了XXE的独立类别。XXE现在属于<a class="ae kx" href="https://owasp.org/Top10/A05_2021-Security_Misconfiguration/" rel="noopener ugc nofollow" target="_blank">A05:2021-安全误配置</a>。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/3defaa881cdfd29d4ac57991aad99275.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*NyO7weH_ncNWHp5U.png"/></div></div></figure><h1 id="db90" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">C#中的XXE组件</h1><p id="4930" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">正如我上面提到的，XXE至少需要两个组件:一个不安全配置的解析器和这个解析器处理的来自攻击者的数据。</p><h1 id="3f87" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">被污染的数据</h1><p id="939e" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">这里一切都很简单。应用程序有几个地方接受外部数据。它必须被小心地处理——不是所有的人都将应用程序用于其预期目的。</p><p id="227c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这样的应用程序位置是控制台应用程序参数、各种表单字段、查询数据等。首先想到的是控制台输入。</p><pre class="km kn ko kp gt mb mc md me aw mf bi"><span id="1313" class="mg kz iq mc b gy mh mi l mj mk">var taintedVar = Console.ReadLine();</span></pre><p id="999e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们不知道<em class="ml">里面有什么。该变量可能包含预期格式的数据或危及系统安全的字符串。我们不能相信它。</em></p><p id="9a46" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可以在PVS-Studio for C#中的“<a class="ae kx" href="https://pvs-studio.com/en/blog/posts/csharp/0831/" rel="noopener ugc nofollow" target="_blank"> OWASP、漏洞和污点分析”的“污点源”一节中了解更多信息。搅拌，但不要摇动</a>。您还应该怀疑公共访问参数。这些方法中的数据可能安全，也可能不安全。你可以在这里阅读<a class="ae kx" href="https://pvs-studio.com/en/blog/posts/csharp/0835/" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="3772" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">XML解析器</h1><p id="80c3" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">在下列情况下，XML解析器容易受到XXE攻击:</p><ul class=""><li id="b7ba" class="mm mn iq jp b jq jr ju jv jy mo kc mp kg mq kk mr ms mt mu bi translated">它处理DTD</li><li id="6aeb" class="mm mn iq jp b jq mv ju mw jy mx kc my kg mz kk mr ms mt mu bi translated">它使用不安全的<em class="ml"> XmlResolver </em>。</li></ul><p id="2997" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果XML解析器没有对实体的最大大小设置限制(或者大小很大)，这可能会加剧攻击，因为攻击者将能够提取更大量的数据。</p><h2 id="76e6" class="mg kz iq bd la na nb dn le nc nd dp li jy ne nf lm kc ng nh lq kg ni nj lu nk bi translated">配置解析器</h2><p id="8521" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">使用以下属性设置所需的行为:</p><ul class=""><li id="e5fb" class="mm mn iq jp b jq jr ju jv jy mo kc mp kg mq kk mr ms mt mu bi translated"><em class="ml">禁止TD</em>；</li><li id="9bbb" class="mm mn iq jp b jq mv ju mw jy mx kc my kg mz kk mr ms mt mu bi translated"><em class="ml">dtd处理</em>；</li><li id="515d" class="mm mn iq jp b jq mv ju mw jy mx kc my kg mz kk mr ms mt mu bi translated"><em class="ml">XML resolver</em>；</li><li id="e62c" class="mm mn iq jp b jq mv ju mw jy mx kc my kg mz kk mr ms mt mu bi translated"><em class="ml">最大字符数</em>。</li></ul><p id="c119" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一些XML解析器拥有所有这些选项，而另一些则没有。它们的语义不会随着类型的不同而改变。</p><p id="51df" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">禁止td </strong></p><p id="7b7d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="ml">prohibit TDD</em>属性具有<em class="ml">过时</em>属性。现在使用<em class="ml"> DtdProcessing </em>属性代替<em class="ml"> ProhibitDtd </em>。尽管如此，它仍然可以在旧代码中使用。<em class="ml">真值</em>禁止DTD处理，<em class="ml">假值</em> —允许。</p><p id="67aa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">dtd处理</strong></p><p id="76d8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="ml"> DtdProcessing </em>属性<em class="ml">T3】有<em class="ml">系统。Xml.DtdProcessing </em>键入<em class="ml"> </em>并可以取<em class="ml">禁止</em>，<em class="ml">忽略</em>和<em class="ml">解析</em>值:</em></p><ul class=""><li id="845c" class="mm mn iq jp b jq jr ju jv jy mo kc mp kg mq kk mr ms mt mu bi translated"><em class="ml">禁止</em> —禁止DTD处理。如果解析器在处理XML文件时遇到DTD，就会抛出一个<em class="ml"> XmlException </em>类型的异常。</li><li id="98c3" class="mm mn iq jp b jq mv ju mw jy mx kc my kg mz kk mr ms mt mu bi translated"><em class="ml">忽略</em> —解析器只是跳过DTD。</li><li id="b19e" class="mm mn iq jp b jq mv ju mw jy mx kc my kg mz kk mr ms mt mu bi translated"><em class="ml">解析</em> —解析器处理DTD。</li></ul><p id="9215" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你现在大概有问题，我来回答。如果<em class="ml"> ProhibitDtd </em>和<em class="ml"> DtdProcessing </em>属性在代码中同时出现(例如在<em class="ml"> XmlReaderSettings </em>中)，则它们相互关联。因此，如果在一个属性中禁止DTD，而在另一个属性中允许，那么只有最后一个选项集会被应用。:)</p><p id="f436" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> XmlResolver </strong></p><p id="8bc9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="ml"> XmlResolver </em>属性负责用于处理外部实体的对象。最安全的选择—根本没有解析器(<em class="ml"> null </em>值)。在这种情况下，即使启用了DTD处理，外部实体也不会展开。</p><p id="01fd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">最大字符数</strong></p><p id="0f03" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们感兴趣的另一个选择。<em class="ml">maxcharactersfrontities</em>负责实体的最大允许尺寸。该值越大，在XXE攻击中提取的信息就越多。</p><h2 id="8413" class="mg kz iq bd la na nb dn le nc nd dp li jy ne nf lm kc ng nh lq kg ni nj lu nk bi translated">XML解析器类型</h2><p id="cfb9" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">处理XML最常见的标准类型有<em class="ml"> XmlReader </em>、<em class="ml"> XmlTextReader </em>、<em class="ml"> XmlDocument </em>。注意，列表不限于它们。</p><p id="00a5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">同样，解析器的配置是危险的，如果:</p><ul class=""><li id="1c66" class="mm mn iq jp b jq jr ju jv jy mo kc mp kg mq kk mr ms mt mu bi translated">这个解析器处理DTD</li><li id="2e3b" class="mm mn iq jp b jq mv ju mw jy mx kc my kg mz kk mr ms mt mu bi translated">它有一个危险的解析器(例如，<em class="ml"> XmlUrlResolver </em>处于默认状态)。</li></ul><p id="47c9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> XmlReader </strong></p><p id="fe42" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">显式或隐式创建的<em class="ml"> XmlReaderSettings </em>对象配置<em class="ml"> XmlReader </em>的行为。<em class="ml"> XmlReaderSettings </em>类型具有前面列出的所有设置。</p><p id="9469" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">具有危险配置的解析器可能如下所示:</p><pre class="km kn ko kp gt mb mc md me aw mf bi"><span id="4bee" class="mg kz iq mc b gy mh mi l mj mk">var settings = <strong class="mc ir">new</strong> XmlReaderSettings()<br/>{<br/>  DtdProcessing = DtdProcessing.Parse,<br/>  XmlResolver = <strong class="mc ir">new</strong> XmlUrlResolver(),<br/>  MaxCharactersFromEntities = 0<br/>};</span><span id="82dd" class="mg kz iq mc b gy nl mi l mj mk"><strong class="mc ir">using</strong> (var xmlReader <br/>         = XmlReader.Create(xmlFileStringReader, settings))<br/>  ....</span></pre><p id="16f4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这里，开发人员明确允许DTD处理，为外部实体设置了一个解析器，并取消了对它们大小的限制。</p><p id="363f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> XmlTextReader </strong></p><p id="6877" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这种情况下，我们处理的是相同的属性:<em class="ml"> ProhibitDtd </em>，<em class="ml"> DtdProcessing </em>，<em class="ml"> XmlResolver </em>。</p><p id="30ad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一个危险配置的解析器的例子:</p><pre class="km kn ko kp gt mb mc md me aw mf bi"><span id="b610" class="mg kz iq mc b gy mh mi l mj mk"><strong class="mc ir">using</strong> (var xmlTextReader = <strong class="mc ir">new</strong> XmlTextReader(xmlFileStringReader))<br/>{<br/>  xmlTextReader.XmlResolver = <strong class="mc ir">new</strong> XmlUrlResolver();<br/>  xmlTextReader.DtdProcessing = DtdProcessing.Parse;<br/>  ....<br/>}</span></pre><p id="c1ad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">XML文档</strong></p><p id="cde0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<em class="ml"> XmlDocument </em>类型中，我们感兴趣的是<em class="ml"> XmlResolver </em>属性。在这种情况下，危险配置的解析器可能如下所示:</p><pre class="km kn ko kp gt mb mc md me aw mf bi"><span id="51c4" class="mg kz iq mc b gy mh mi l mj mk">XmlDocument xmlDoc = <strong class="mc ir">new</strong> XmlDocument();<br/>xmlDoc.XmlResolver = <strong class="mc ir">new</strong> XmlUrlResolver();</span></pre><p id="0cb9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此配置中的xmlDoc 会扩展外部实体，可视为危险。</p><h2 id="0038" class="mg kz iq bd la na nb dn le nc nd dp li jy ne nf lm kc ng nh lq kg ni nj lu nk bi translated">默认解析器设置</h2><p id="093f" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">上面我们看了显式配置XML解析器的例子。然而，所有列出的类型都有一些默认设置，并且有一些有趣的事情。</p><p id="fd4e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，这些设置因人而异。NET版本。</p><p id="c7a1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">其次，设置因类型而异。例如，默认情况下可以启用或禁用DTD处理。</p><p id="842f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在某些情况下，XML解析器在默认情况下可能具有危险的配置，即使没有显式设置危险的设置。</p><p id="b332" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，我们必须记住不同类型的解析器，不同类型的不同默认设置。NET版本。这是一个很大的信息量，很难记住(尤其是在开始的时候)。</p><p id="6154" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，有时我们不能仅仅通过查看代码来判断XML解析器是否是抗XXE的。例如，在这里:</p><pre class="km kn ko kp gt mb mc md me aw mf bi"><span id="620c" class="mg kz iq mc b gy mh mi l mj mk">XmlDocument doc = <strong class="mc ir">new</strong> XmlDocument();<br/>doc.Load(xmlReader);</span></pre><p id="c797" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不清楚<em class="ml"> doc </em>是否可以处理外部实体——我们需要先知道框架版本。</p><p id="6402" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">“危险”设置的值在之间变化。NET Framework 4.5.1和。NET框架4.5.2。下表显示了。默认情况下，默认设置的. NET版本解析器是抗XXE的，但在. NET版本中却不是。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nm"><img src="../Images/36be64e7c0e24ced4aac5f0ad13c31a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zwuB-w6iUupdSd05ONZTlw.png"/></div></div></figure><p id="943c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">是的，<em class="ml"> XmlReader </em>(通过<em class="ml"> XmlReaderSettings </em>创建)在。NET Framework 4.5.1和更低版本，因为其中禁用了DTD处理。</p><p id="411f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">尽管在新的框架版本中，默认情况下解析器是安全配置的，但是最好的选择是显式地配置必要的设置。是的，会有更多的代码。与此同时，当你把它移植到不同的。NET Framework版本。</p><p id="6abb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">理论完了。接下来我们来看看真正的漏洞。给自己冲杯咖啡，我们走吧！</p><h1 id="9092" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">BlogEngine中的漏洞示例。网</h1><p id="bed4" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">上面，我们分析了XXE的理论组成部分，更具体地谈到了。NET中，从代码的角度观察了该漏洞的不安全组件。现在是练习的时间了。BlogEngine.NET是来帮忙的。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/7f40c533d6770d2403b01bec025439f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*NVDJt07jaGXtFw0o.png"/></div></div></figure><p id="3c71" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">来自该项目的<em class="ml"> </em> <a class="ae kx" href="https://blogengine.io/" rel="noopener ugc nofollow" target="_blank">网站</a>:<em class="ml">blogen ine是一个自2007年以来的开源博客平台。易于定制。许多免费的内置主题、小部件和插件。</em></p><p id="e1a7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该项目的源代码是GitHub 上的<a class="ae kx" href="https://github.com/BlogEngine/BlogEngine.NET" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="d076" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对我们来说，这个项目很有趣，因为在那里发现了3个XXE漏洞。它们在BlogEngine.NET<a class="ae kx" href="https://github.com/BlogEngine/BlogEngine.NET/tree/v3.3.8.0" rel="noopener ugc nofollow" target="_blank">v 3 . 3 . 8 . 0</a>被修复。这意味着我们将使用以前的版本进行实验— <a class="ae kx" href="https://github.com/BlogEngine/BlogEngine.NET/tree/v3.3.7.0" rel="noopener ugc nofollow" target="_blank"> v3.3.7.0 </a>。如果你愿意，你可以很容易地再现所描述的步骤，并看到真正的XXE自己。</p><p id="4e8c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们下载想要的版本— <a class="ae kx" href="https://github.com/BlogEngine/BlogEngine.NET/tree/v3.3.7.0" rel="noopener ugc nofollow" target="_blank"> v3.3.7.0 </a>。建立这个项目应该没有问题——非常简单。我用Visual Studio 2022构建了这个项目。</p><p id="3774" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">项目建好之后，我们来运营。如果一切顺利，我们会看到以下类型的站点:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/4437be4957f7ba173728658c35e65c10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*9lxo2i2FGjLHhZyy.png"/></div></figure><p id="a987" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果该网站在默认情况下对同一网络上的其他机器不可用，我强烈建议您创建它。一点点的配置让“玩”XXE变得更加有趣。</p><p id="1e6a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在搜索漏洞时，您可能会有不同的输入。例如，系统可能会为您提供一个黑盒。然后你必须收集关于系统的信息，寻找对系统的影响点，等等。如果系统代表一个白盒，它会改变实现目标的方法和工具(或者至少扩展它们的列表)。</p><p id="f0ce" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">关于开源项目有一件有趣的事情。似乎每个人都可以使用代码并为其质量/安全性做出贡献。不过<a class="ae kx" href="https://pvs-studio.com/en/blog/posts/cpp/0900/" rel="noopener ugc nofollow" target="_blank">也有一些弊端</a>。另一方面，黑客将有更多的方法来调查代码——因为他们可以访问源代码，他们将很容易找到漏洞。这些漏洞会被报告吗？</p><p id="e92b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个问题没有答案。让我们回到正题。</p><p id="614c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于该项目是开源的，我们将利用这一点。为了搜索漏洞，除了我们自己的知识，我们使用<a class="ae kx" href="https://pvs-studio.com/en/pvs-studio/" rel="noopener ugc nofollow" target="_blank">PVS-Studio</a>——一种搜索错误和安全弱点的解决方案。我们需要一组与安全相关的诊断工具— OWASP。你可以在这里阅读关于开启相应警告<a class="ae kx" href="https://pvs-studio.com/en/docs/manual/6536/" rel="noopener ugc nofollow" target="_blank">的内容。</a></p><p id="145a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在Visual Studio中，您需要在“可检测的错误(C#)”选项卡上为OWASP组设置“显示全部”:扩展&gt; PVS-Studio &gt;选项&gt;可检测的错误(C#)。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi no"><img src="../Images/b15952713274760d1e35c53fc96d88ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*JeoQEKaYKsXjEzsz.png"/></div></div></figure><p id="a1cc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">之后，确保您启用了相应警告的显示。在这种情况下，我们对“高”确定性级别的“OWASP”组感兴趣。因此，你需要点击必要的按钮——它们会被框起来。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi np"><img src="../Images/4e1eb4fd9e3400565f4118fbdb8b1eb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1328/format:webp/0*28AheXJyvsKIlEia.png"/></div></figure><p id="8625" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，运行解决方案分析(Extensions &gt; PVS-Studio &gt; Check &gt; Solution)并等待结果。</p><p id="5940" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用CWE滤波器(记住XXE对应于CWE-611)或OWASP ASVS ID (OWASP ASVS 5.5.2)很容易找到我们感兴趣的东西——3个警告<a class="ae kx" href="https://pvs-studio.com/en/docs/warnings/v5614/" rel="noopener ugc nofollow" target="_blank"> V5614 </a>。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nq"><img src="../Images/52af33332668afdb85144eedda4af539.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*UqDKoQSKGMBmCK4S.png"/></div></div></figure><p id="7d18" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从代码的角度来看，这些错误是相似的。我们将分析最有趣的一个(位于几个方法中)，对于其余的，我将只提供基本信息。</p><p id="a722" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> XMLRPCRequest.cs </strong></p><p id="0c12" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">警告:V5614 [CWE-611，OWASP-5.5.2]方法内部存在潜在的XXE漏洞。不安全的XML解析器用于处理第一个参数“inputXml”中可能被污染的数据。布洛根金。核心XMLRPCRequest.cs 41</p><p id="2d1d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">事实上，分析器指出了3行以使警告更容易理解:一个“危险的”方法调用，污染的源，以及被污染的数据被危险配置的分析器使用的地方。</p><pre class="km kn ko kp gt mb mc md me aw mf bi"><span id="eac1" class="mg kz iq mc b gy mh mi l mj mk"><strong class="mc ir">public</strong> <strong class="mc ir">XMLRPCRequest</strong>(HttpContext input)<br/>{<br/>  var inputXml = ParseRequest(input);</span><span id="09c4" class="mg kz iq mc b gy nl mi l mj mk">  <em class="ml">// LogMetaWeblogCall(inputXml);</em><br/>  <strong class="mc ir">this</strong>.LoadXmlRequest(inputXml); <em class="ml">// Loads Method Call </em><br/>                                 <em class="ml">// and Associated Variables</em><br/>}</span></pre><p id="c7f3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">根据该消息，<em class="ml"> inputXml </em>可能包含被污染的数据(参见<a class="ae kx" href="https://pvs-studio.com/en/blog/terms/6496/" rel="noopener ugc nofollow" target="_blank">污点检查</a>),该数据被<em class="ml"> LoadXmlRequest </em>方法中一个不安全配置的解析器使用。因此，这是一个相当复杂的过程间情况:数据来自一个方法(<em class="ml"> ParseRequest </em>)，然后被传递给另一个使用它的方法(<em class="ml"> LoadXmlRequest </em>)。</p><p id="53a5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们从数据开始——我们需要<em class="ml"> ParseRequest </em>方法的代码。</p><pre class="km kn ko kp gt mb mc md me aw mf bi"><span id="1248" class="mg kz iq mc b gy mh mi l mj mk"><strong class="mc ir">private</strong> <strong class="mc ir">static</strong> string <strong class="mc ir">ParseRequest</strong>(HttpContext context)<br/>{<br/>  var buffer = <strong class="mc ir">new</strong> byte[context.Request.InputStream.Length];</span><span id="a779" class="mg kz iq mc b gy nl mi l mj mk">  context.Request.InputStream.Position = 0;<br/>  context.Request.InputStream.Read(buffer, 0, buffer.Length);</span><span id="b2fc" class="mg kz iq mc b gy nl mi l mj mk">  <strong class="mc ir">return</strong> Encoding.UTF8.GetString(buffer);<br/>}</span></pre><p id="2579" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们在代码中附上污点分布路径，以明确我们在谈论什么。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/cd5cfca270402aa78d0697c10f080f7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*Gj0vx7IUZ8pYhOSt.png"/></div></figure><p id="c6b8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这一切都从<em class="ml">上下文开始。请求具有<em class="ml"> HttpRequest </em>类型的</em>属性。分析器认为它是一个污染源，因为作为查询接收的数据可能会受到危害。</p><p id="f6db" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">提取数据有几种方法，使用流(<em class="ml"> InputStream </em>属性)是其中之一。因此，被污染的数据被传递到<em class="ml">输入流</em></p><p id="7f3e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们称之为<em class="ml">系统。此流的IO.Stream.Read </em>方法。该方法将数据从<em class="ml"> InputStream </em>读入字节数组(<em class="ml"> buffer) </em>。结果，现在<em class="ml">缓冲器</em>也可以包含被污染的数据。</p><p id="4bc6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">之后是<em class="ml">编码。UTF8.GetString </em>方法被调用。它从字节数组(<em class="ml">缓冲区)</em>中构造一个字符串。因为用于创建字符串的源数据被污染，所以字符串也被污染。构造后，字符串从方法返回。</p><p id="a705" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，攻击者可能会损害由<em class="ml"> ParseRequest </em>方法返回的值。至少理论上是这样。</p><p id="77dd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们回到最初的方法:</p><pre class="km kn ko kp gt mb mc md me aw mf bi"><span id="c862" class="mg kz iq mc b gy mh mi l mj mk"><strong class="mc ir">public</strong> <strong class="mc ir">XMLRPCRequest</strong>(HttpContext input)<br/>{<br/>  var inputXml = ParseRequest(input);</span><span id="30b7" class="mg kz iq mc b gy nl mi l mj mk">  <em class="ml">// LogMetaWeblogCall(inputXml);</em><br/>  <strong class="mc ir">this</strong>.LoadXmlRequest(inputXml); <em class="ml">// Loads Method Call </em><br/>                                 <em class="ml">// and Associated Variables</em><br/>}</span></pre><p id="814c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">用<em class="ml"> ParseRequest </em>完成。假设<em class="ml"> inputXml </em>变量可以包含被污染的数据。下一步—分析将<em class="ml"> inputXml </em>作为参数的<em class="ml"> LoadXmlRequest </em>方法。</p><p id="a40e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该方法很长(100+行)，所以这里是缩短的版本。触发分析器的片段被标记。</p><pre class="km kn ko kp gt mb mc md me aw mf bi"><span id="6ac1" class="mg kz iq mc b gy mh mi l mj mk"><strong class="mc ir">private</strong> <strong class="mc ir">void</strong> <strong class="mc ir">LoadXmlRequest</strong>(string xml)<br/>{<br/>  var request = <strong class="mc ir">new</strong> XmlDocument();<br/>  <strong class="mc ir">try</strong><br/>  {<br/>    <strong class="mc ir">if</strong> (!(xml.StartsWith("&lt;?xml") || xml.StartsWith("&lt;method")))<br/>    {<br/>      xml = xml.Substring(xml.IndexOf("&lt;?xml"));<br/>    }</span><span id="6bcb" class="mg kz iq mc b gy nl mi l mj mk">    request.LoadXml(xml);              <em class="ml">// &lt;=</em><br/>  }<br/>  <strong class="mc ir">catch</strong> (Exception ex)<br/>  {<br/>    <strong class="mc ir">throw</strong> <strong class="mc ir">new</strong> <br/>      MetaWeblogException("01", <br/>                          $"Invalid XMLRPC Request.({ex.Message})");<br/>  }<br/>  ....<br/>}</span></pre><p id="9698" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如我们看到的，参数是由一个XML解析器处理的:<em class="ml">请求。LoadXml(xml) </em>。PVS-Studio认为<em class="ml">请求</em>易受XXE攻击。我们的工作就是证明这一点。或者反驳。那么该警告将被标记为<a class="ae kx" href="https://pvs-studio.com/en/blog/terms/6461/" rel="noopener ugc nofollow" target="_blank">误报</a>。这里我们需要本文开头描述的理论。</p><p id="9d9c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="ml">请求</em>引用指向的对象类型是<em class="ml"> XmlDocument </em>。解析器有默认设置，这意味着我们需要找出。网络版。您可以在项目的属性中找到它。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ns"><img src="../Images/f456a43483e618f87f60942fcc3de5bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*fS7zp6gB5qvrUzgA.png"/></div></div></figure><p id="b5f1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们来看文章开头的表格。我们在应用程序中看到。默认情况下，NET Framework 4.5.1和较低版本的<em class="ml"> XmlDocument </em>类型易受XXE攻击。</p><p id="5ca3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">看起来我们具备了潜在XXE的所有条件:</p><ul class=""><li id="9817" class="mm mn iq jp b jq jr ju jv jy mo kc mp kg mq kk mr ms mt mu bi translated">有可以妥协的数据:<em class="ml">parse request</em>-&gt;<em class="ml">input XML</em>-&gt;<em class="ml">XML</em>；</li><li id="12cd" class="mm mn iq jp b jq mv ju mw jy mx kc my kg mz kk mr ms mt mu bi translated">有一个带有危险配置的解析器处理这些数据:<em class="ml"> request。LoadXml(xml) </em>。</li></ul><p id="09da" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">理论上，这是一个XXE，但它仍然是一个潜在的漏洞。我们必须证明攻击是可能的。要做到这一点，我们需要更深入地研究代码。</p><p id="e1b4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们从<em class="ml"> XMLRPCRequest </em>类型的构造函数开始分析。在一个地方叫做:</p><pre class="km kn ko kp gt mb mc md me aw mf bi"><span id="211f" class="mg kz iq mc b gy mh mi l mj mk">internal <strong class="mc ir">class</strong> <strong class="mc ir">MetaWeblogHandler</strong> : IHttpHandler<br/>{<br/>  ....<br/>  <strong class="mc ir">public</strong> <strong class="mc ir">void</strong> <strong class="mc ir">ProcessRequest</strong>(HttpContext context)<br/>  {<br/>    <strong class="mc ir">try</strong><br/>    {<br/>      var rootUrl = Utils.AbsoluteWebRoot.ToString();<br/>                    <br/>      <em class="ml">// context.Request.Url.ToString().Substring(0,   </em><br/>      <em class="ml">// context.Request.Url.ToString().IndexOf("metaweblog.axd"));</em></span><span id="356b" class="mg kz iq mc b gy nl mi l mj mk">      var input = <strong class="mc ir">new</strong> XMLRPCRequest(context); <em class="ml">// &lt;=</em><br/>      ....<br/>     }<br/>     ....<br/>   }<br/>   ....<br/>}</span></pre><p id="1b33" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">是的，我们遇到了一个HTTP处理器。在配置中有一个条目:</p><pre class="km kn ko kp gt mb mc md me aw mf bi"><span id="2f11" class="mg kz iq mc b gy mh mi l mj mk">&lt;add name="MetaWeblog" <br/>     verb="*" <br/>     path="metaweblog.axd" <br/>     type="BlogEngine.Core.API<br/>                     .MetaWeblog.MetaWeblogHandler, BlogEngine.Core" <br/>     resourceType="Unspecified" <br/>     requireAccess="Script" <br/>     preCondition="integratedMode" /&gt;</span></pre><p id="4f6d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们知道了发送请求的地址，并使所需的处理程序工作。让我们试着重现这次袭击。</p><p id="8edc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们需要一个XML文件，用它从部署博客的机器上窃取数据:</p><pre class="km kn ko kp gt mb mc md me aw mf bi"><span id="e2e6" class="mg kz iq mc b gy mh mi l mj mk">&lt;?xml version="1.0"?&gt;<br/>&lt;!DOCTYPE xxe [<br/> &lt;!ENTITY externalEntity SYSTEM <br/>   "file:///C:/Windows/System32/drivers/etc/hosts"&gt;<br/>]&gt;<br/>&lt;xxe&gt;&amp;externalEntity;&lt;/xxe&gt;</span></pre><p id="6746" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果XML解析器处理外部实体，那么代替&amp;<em class="ml">external entity；</em>它应该粘贴<a class="ae kx" href="https://en.wikipedia.org/wiki/Hosts_(file)" rel="noopener ugc nofollow" target="_blank">主机</a>文件的内容。</p><p id="6077" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们发出请求，发送XML，然后看看我们的处理程序如何工作。为了方便起见，将XML保存到一个文件是有意义的(在本例中是— <em class="ml"> xxe.xml </em>)，因此，如果需要，您可以很容易地更改其内容，而无需更改查询命令本身。</p><pre class="km kn ko kp gt mb mc md me aw mf bi"><span id="9c90" class="mg kz iq mc b gy mh mi l mj mk">curl -d "@xxe.xml" -X POST <a class="ae kx" href="http://vasiliev-pc:8081/metaweblog.axd" rel="noopener ugc nofollow" target="_blank">http:<em class="ml">//vasiliev-pc:8081/metaweblog.axd</em></a></span></pre><p id="e735" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，处理程序捕获了我们的请求，并调用了我们之前检查过的<em class="ml"> XMLRPCRequest </em>构造函数。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/2fcdcae70329860e2a5e6e4353c181dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1112/format:webp/0*J6rrS-darFc9n6JJ.png"/></div></figure><p id="8558" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">进入构造函数内部，检查<em class="ml"> inputXml </em>变量中的数据。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/c85543c3c87c5b37d8432c5fbcd352ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1366/format:webp/0*GVEAoPkRZO5qBkmK.png"/></div></figure><p id="a75a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一切都按计划进行——数据被污染了，正如我们假设的那样(也是我们想要的),并作为参数传递给<em class="ml"> LoadXmlRequest </em>方法。让我们进一步观察。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nv"><img src="../Images/b995f52929775e4fdf9c252cafd84810.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*YNmfVuJgtw61DQU_.png"/></div></div></figure><p id="7a75" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于危险的默认设置，解析器完全按照我们的预期工作——它加载了hosts文件的内容。然后执行下面的代码片段:</p><pre class="km kn ko kp gt mb mc md me aw mf bi"><span id="f6f0" class="mg kz iq mc b gy mh mi l mj mk"><em class="ml">// Method name is always first</em><br/><strong class="mc ir">if</strong> (request.DocumentElement != null)<br/>{<br/>  <strong class="mc ir">this</strong>.MethodName = request.DocumentElement.ChildNodes[0].InnerText;<br/>}</span></pre><p id="ee61" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">幸运的是(对于黑客:)，hosts文件的内容将被写入到<em class="ml"> MethodName </em>属性中——这正是我们所需要的。我们需要的下一个代码片段是大的<em class="ml">开关</em>，其中根据方法名执行某些操作:</p><pre class="km kn ko kp gt mb mc md me aw mf bi"><span id="f5c5" class="mg kz iq mc b gy mh mi l mj mk"><strong class="mc ir">switch</strong> (<strong class="mc ir">this</strong>.MethodName)<br/>{<br/>  <strong class="mc ir">case</strong> "metaWeblog.newPost":<br/>    ....<br/>    <strong class="mc ir">break</strong>;<br/>  <strong class="mc ir">case</strong> "metaWeblog.editPost":<br/>    ....<br/>    <strong class="mc ir">break</strong>;<br/>  <strong class="mc ir">case</strong> "metaWeblog.getPost":<br/>    ....<br/>    <strong class="mc ir">break</strong>;<br/>  ....<br/>    <strong class="mc ir">default</strong>:<br/>      <strong class="mc ir">throw</strong> <strong class="mc ir">new</strong> <br/>        MetaWeblogException("02", <br/>                            $"Unknown Method. ({MethodName})");<br/>}</span></pre><p id="96b9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里我们需要<em class="ml">默认的</em>分支，因为没有合适的方法，执行将会到那里。在这个分支中会抛出一个异常。异常的消息将具有映射失败的方法的名称。在我们的例子中，方法的名称是hosts文件的内容。</p><p id="2689" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当抛出异常时，我们返回到处理程序并到达catch部分，在那里报告一个未知的方法:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/abf96db82ac6f883d18ea54bc682a74f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1366/format:webp/0*XciFqQF7Bi_cWZwk.png"/></div></figure><p id="a556" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，对我们最初的要求:</p><pre class="km kn ko kp gt mb mc md me aw mf bi"><span id="6c67" class="mg kz iq mc b gy mh mi l mj mk">curl -d "@xxe.xml" -X POST <a class="ae kx" href="http://vasiliev-pc:8081/metaweblog.axd" rel="noopener ugc nofollow" target="_blank">http:<em class="ml">//vasiliev-pc:8081/metaweblog.axd</em></a></span></pre><p id="7c96" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们得到以下答案:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/63d83f99e44023c068c2a0ad597e51f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1160/format:webp/0*_XG3WeUTHUvCJBMz.png"/></div></figure><p id="0e31" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，我们利用XXE攻击，设法获取了主机文件的内容。我们在部署了博客的机器上得到它。如果我们知道其他文件的位置，我们也可以尝试获取它们的内容。不仅来自被攻击的机器，还来自我们可以访问的网络中的其他机器。这里，在网络请求的背景下，我们也可以谈论SSRF。</p><p id="6d6e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，我们已经从应用程序(代码)和用户(攻击者)的角度看到了XXE。这是一个真实存在的漏洞——<a class="ae kx" href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-14485" rel="noopener ugc nofollow" target="_blank">CVE-2018–14485</a>(<a class="ae kx" href="https://nvd.nist.gov/vuln/detail/CVE-2018-14485" rel="noopener ugc nofollow" target="_blank">这里的</a>是NVD的入口)。</p><p id="b3a0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们应该如何处理漏洞？没错，修好它。提交可以在这里找到<a class="ae kx" href="https://github.com/BlogEngine/BlogEngine.NET/commit/3c61785f6c952e3f8d16eab1bb425e0368ea4a65" rel="noopener ugc nofollow" target="_blank"/>。之后，XML解析器的配置发生了变化，所以现在它不能处理外部实体。为此，将<em class="ml"> XmlResolver </em>属性的值设置为<em class="ml"> null </em>就足够了:</p><pre class="km kn ko kp gt mb mc md me aw mf bi"><span id="1a23" class="mg kz iq mc b gy mh mi l mj mk">var request = <strong class="mc ir">new</strong> XmlDocument() { XmlResolver = null };</span></pre><p id="0d70" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，如果我们尝试获取相同的主机文件，它将不会进入输出。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/7e82cdd5e0a7e5f2e598057969012de5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1160/format:webp/0*zQn52B8UTZkoFlDN.png"/></div></figure><p id="6f26" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">顺便说一下，PVS-Studio知道这种配置的解析器(<em class="ml">XML resolver</em>—<em class="ml">null</em>)不会处理外部实体。因此，分析器不会对固定代码发出警告。</p><p id="c31d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们之前看到的另外两个警告也指向了漏洞。我们不打算分析它们(代码是相似的)，但下面是关于它们的基本信息。</p><p id="b614" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">CVE-2019–10718</strong></p><ul class=""><li id="fa4e" class="mm mn iq jp b jq jr ju jv jy mo kc mp kg mq kk mr ms mt mu bi translated">警告:V5614 [CWE-611，OWASP-5.5.2]潜在的XXE漏洞。不安全的xml解析器“doc”用于处理“XML”变量中可能被污染的数据。PingbackHandler.cs 341</li><li id="65fc" class="mm mn iq jp b jq mv ju mw jy mx kc my kg mz kk mr ms mt mu bi translated">附加信息:<a class="ae kx" href="https://nvd.nist.gov/vuln/detail/CVE-2019-10718" rel="noopener ugc nofollow" target="_blank"> NVD </a>，<a class="ae kx" href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-10718" rel="noopener ugc nofollow" target="_blank"> CVE </a>。</li><li id="05fa" class="mm mn iq jp b jq mv ju mw jy mx kc my kg mz kk mr ms mt mu bi translated">提交并修复:<a class="ae kx" href="https://github.com/BlogEngine/BlogEngine.NET/commit/3c61785f6c952e3f8d16eab1bb425e0368ea4a65" rel="noopener ugc nofollow" target="_blank">链接</a>。</li></ul><p id="59e6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">CVE-2019–11392</strong></p><ul class=""><li id="65bf" class="mm mn iq jp b jq jr ju jv jy mo kc mp kg mq kk mr ms mt mu bi translated">警告:V5614 [CWE-611，OWASP-5.5.2]潜在的XXE漏洞。不安全的XML解析器“doc”用于处理“stream”变量中可能被污染的数据。SyndicationHandler.cs 191</li><li id="3c87" class="mm mn iq jp b jq mv ju mw jy mx kc my kg mz kk mr ms mt mu bi translated">补充信息:<a class="ae kx" href="https://nvd.nist.gov/vuln/detail/CVE-2019-11392" rel="noopener ugc nofollow" target="_blank"> NVD </a>，<a class="ae kx" href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-11392" rel="noopener ugc nofollow" target="_blank"> CVE </a>。</li><li id="f3ec" class="mm mn iq jp b jq mv ju mw jy mx kc my kg mz kk mr ms mt mu bi translated">提交并修复:<a class="ae kx" href="https://github.com/BlogEngine/BlogEngine.NET/commit/4869ca9582c6d8f104190c3df3f14fb51058b481" rel="noopener ugc nofollow" target="_blank">链接</a>。</li></ul><h1 id="f607" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">如何保护代码？</h1><ul class=""><li id="577c" class="mm mn iq jp b jq lw ju lx jy nx kc ny kg nz kk mr ms mt mu bi translated">了解一下问题。由于XML文件的处理而可能出现漏洞的事实可能是一个意外的发现。越多的人知道这个问题越好。</li><li id="b0df" class="mm mn iq jp b jq mv ju mw jy mx kc my kg mz kk mr ms mt mu bi translated">使用较新的框架版本。开发人员努力提高“开箱即用”产品的安全性。在...的情况下。NET，新版本的框架更加安全。</li><li id="e350" class="mm mn iq jp b jq mv ju mw jy mx kc my kg mz kk mr ms mt mu bi translated">显式配置XML解析器的安全设置。如果不需要，禁止处理dtd和外部实体。这最小化了可能的风险(特别是当你复制代码时)，也更清楚地表明了你的意图。如果需要DTD处理，请设置尽可能多的限制。</li><li id="9a17" class="mm mn iq jp b jq mv ju mw jy mx kc my kg mz kk mr ms mt mu bi translated">使用专门的工具搜索安全缺陷:SAST、DAST等。例如，定期使用SAST解决方案将允许您甚至在编写代码的阶段就发现这样的缺陷。对了，你可以试试文章里提到的PVS-Studio，<a class="ae kx" href="https://pvs-studio.com/pvs-studio/try-free/?utm_source=xxe_in_csharp&amp;utm_medium=articles&amp;utm_term=link_try-free" rel="noopener ugc nofollow" target="_blank">这里</a>。</li></ul><h1 id="2fe4" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">结论</h1><p id="d75c" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">现在，您对安全和XXE问题有了更多的了解，并且也知道即使是部署在您机器上的简单博客也可能成为漏洞的来源。</p><p id="64d0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">事实上，XXE的主题更为严肃，当然，还有很多值得挖掘的地方。但是至少知道这个安全缺陷并在基本水平上理解它已经很有用了。</p><p id="1ecd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">普拉莫尼特斯，普拉莫尼特斯。</p><p id="bba5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一如既往，我邀请你<a class="ae kx" href="https://twitter.com/_SergVasiliev_" rel="noopener ugc nofollow" target="_blank">订阅我的Twitter </a>，以免错过任何有趣的事情。</p></div></div>    
</body>
</html>