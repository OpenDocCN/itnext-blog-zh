<html>
<head>
<title>Bun is baking its way towards Node.js compatibility</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Bun正在朝着Node.js兼容性的方向前进</h1>
<blockquote>原文：<a href="https://itnext.io/bun-is-baking-its-way-towards-node-js-compatibility-7d2a997395c0?source=collection_archive---------4-----------------------#2022-08-19">https://itnext.io/bun-is-baking-its-way-towards-node-js-compatibility-7d2a997395c0?source=collection_archive---------4-----------------------#2022-08-19</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="6f3f" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">在某些情况下，Bun比Node.js更快，但仍有许多缺失的功能。</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/62731a37b5844841f9e8ef357a6f7291.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*4Y1iqZSvHRBBzWLu.png"/></div></div></figure><p id="c7b5" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated"><strong class="kx iv">根据早期的Bun测试，从v0.1.8开始，它正在快速改进，但仍然缺少重要的功能。</strong></p></div><div class="ab cl lr ls hy lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="in io ip iq ir"><p id="054b" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">我有兴趣评估Bun与Node.js高度兼容，同时提供非常好的性能的说法。如果是真的，这是非常有吸引力的，因为我们所有人都喜欢以更高的性能运行我们的应用程序。</p><p id="0d8e" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">Bun、Deno和Node.js提供了大致相同的东西，一个JavaScript执行平台，用于服务器或命令行应用程序中的各种非浏览器场景。因为Bun力求Node.js兼容，所以可以立即使用Node.js包生态系统。相比之下，Deno不能这样做，使Bun比Deno更有吸引力。</p><p id="edaf" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">这里的方法是使用复杂的应用程序来测试两件事:</p><ol class=""><li id="37aa" class="ly lz iu kx b ky kz lb lc le ma li mb lm mc lq md me mf mg bi translated">查看Bun是否会执行我的应用程序(AkashaCMS和相关工具)</li><li id="ad8b" class="ly lz iu kx b ky mh lb mi le mj li mk lm ml lq md me mf mg bi translated">它是否会比Node.js有更高的性能</li></ol><p id="5730" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">用一个复杂的应用程序测试Bun的声明，给我们提供了关于何时或是否采用Bun的真实数据。如果两个条件都满足，就没有理由不转Bun了吧？现在，我们很快就会看到，它还没有完全到位。</p><p id="cac1" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">这篇文章写于8月18日。Bun 0.1.8/0.1.9刚刚发布，最近几个版本已经包含了巨大的改进。Bun团队实现了许多缺失的功能，修复了许多分段错误和其他问题。这是前两篇文章的后续，最近的一篇是——<a class="ae mm" href="https://techsparx.com/nodejs/bun/speed-test.html" rel="noopener ugc nofollow" target="_blank">对Bun的性能和与Node.js的兼容性进行更深入的测试</a>。</p><h1 id="8878" class="mn mo iu bd mp mq mr ms mt mu mv mw mx ka my kb mz kd na ke nb kg nc kh nd ne bi translated">内存数据库查询——但是Chokidar不工作</h1><p id="bd0c" class="pw-post-body-paragraph kv kw iu kx b ky nf jv la lb ng jy ld le nh lg lh li ni lk ll lm nj lo lp lq in bi translated">Chokidar非常流行，它支持动态观察目录树的变化(添加、删除或更改文件)。许多应用程序使用它来支持自动重建，AkashaCMS就是为了这个目的而使用它的。</p><p id="5a3e" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">AkashaCMS是一个静态网站生成器，其目的是获取Markdown、CSS、图像和其他文件，并生成包含HTML、CSS等的目录层次结构。它使用Chokidar扫描输入目录。然后，它将有关所有文件的数据存储在内存数据库中，在呈现网站时会不断查询该数据库中的信息。</p><p id="90ce" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">不幸的是，Chokidar不能在Bun上执行，因为<code class="fe nk nl nm nn b">fs.watch</code>没有实现(<a class="ae mm" href="https://github.com/oven-sh/bun/issues/832" rel="noopener ugc nofollow" target="_blank">参见Bun发布队列</a>中的问题832)。提交的问题包括一个简单的应用程序，当在Bun上运行时，错误很明显——不支持:<em class="no"> TypeError: fs.watch不是一个函数。(在' fs.watch(path，options，handleEvent)'中，' fs.watch '未定义)</em></p><p id="bf0e" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">由于无法在Bun上使用Chokidar，我编写了两个测试，加载一个包含大量文件数据的YAML文件，然后运行一些查询。一个测试使用ForerunnerDB，另一个使用LokiJS，这两个测试都是提供类似MongoDB的API的内存数据库。您将在以下位置的存储库中找到这些测试:<a class="ae mm" href="https://github.com/akashacms/akashacms-perftest/tree/master/bench" rel="noopener ugc nofollow" target="_blank">https://github . com/akashacms/akashacms-perf test/tree/master/bench</a></p><pre class="kk kl km kn gu np nn nq nr aw ns bi"><span id="36f1" class="nt mo iu nn b gz nu nv l nw nx">$ node db-forerunner.mjs <br/>cpu: Intel(R) Core(TM) i7-5600U CPU @ 2.60GHz<br/>runtime: node v18.6.0 (x64-linux)<br/><br/>benchmark                                 time (avg)             (min … max)<br/>----------------------------------------------------------------------------<br/>paths                                  82.39 ms/iter  (74.77 ms … 107.53 ms)<br/>random find                             1.56 ms/iter     (1.03 ms … 7.45 ms)<br/>random siblings                          1.4 ms/iter   (594.58 µs … 5.93 ms)<br/>random indexes                          1.78 ms/iter      (1.1 ms … 8.92 ms)<br/>search layouts using find w/ orderBy   80.23 ms/iter    (74.9 ms … 89.96 ms)<br/>search layouts using find              77.05 ms/iter   (71.96 ms … 91.36 ms)<br/><br/>$ bun db-forerunner.mjs <br/><br/>error: Cannot find package "child_process" from "/home/david/Projects/akasharender/akashacms-perftest/bench/node_modules/pem/lib/openssl.js"</span></pre><p id="eadb" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">可惜Bun还是不支持<code class="fe nk nl nm nn b">child_process</code>包。此问题阻碍了大量软件包的运行。Bun团队已经知道了这个问题。</p><p id="c032" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">让我们来讨论一下测试场景:</p><ul class=""><li id="a4af" class="ly lz iu kx b ky kz lb lc le ma li mb lm mc lq ny me mf mg bi translated"><code class="fe nk nl nm nn b">paths</code> -查询每个索引文件的路径名</li><li id="2d01" class="ly lz iu kx b ky mh lb mi le mj li mk lm ml lq ny me mf mg bi translated"><code class="fe nk nl nm nn b">random find</code> -随机选择一个路径名，并获取该文件的数据。</li><li id="16e0" class="ly lz iu kx b ky mh lb mi le mj li mk lm ml lq ny me mf mg bi translated"><code class="fe nk nl nm nn b">random siblings</code> -随机选择一个路径名，并检索同一目录中非所选文件的相关数据。</li><li id="8dbd" class="ly lz iu kx b ky mh lb mi le mj li mk lm ml lq ny me mf mg bi translated"><code class="fe nk nl nm nn b">random indexes</code> -随机选择一个路径名，并检索该目录和每个子目录中文件的相关数据</li><li id="1758" class="ly lz iu kx b ky mh lb mi le mj li mk lm ml lq ny me mf mg bi translated"><code class="fe nk nl nm nn b">search layouts</code> -查找使用给定布局模板的所有文件。一个版本对文件列表进行排序，另一个版本不进行排序。</li></ul><p id="5157" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">使用LokiJS实现了相同的场景:</p><pre class="kk kl km kn gu np nn nq nr aw ns bi"><span id="506d" class="nt mo iu nn b gz nu nv l nw nx">$ node db-lokijs.mjs <br/>cpu: Intel(R) Core(TM) i7-5600U CPU @ 2.60GHz<br/>runtime: node v18.6.0 (x64-linux)<br/><br/>benchmark                  time (avg)             (min … max)<br/>-------------------------------------------------------------<br/>paths                    1.13 ms/iter  (720.57 µs … 11.22 ms)<br/>random find            109.44 µs/iter  (74.62 µs … 876.04 µs)<br/>random siblings            92 µs/iter    (42.86 µs … 5.04 ms)<br/>random indexes         135.56 µs/iter    (112.21 µs … 1.4 ms)<br/>search layouts         281.88 µs/iter   (217.32 µs … 1.45 ms)<br/>search layouts sorted    1.33 ms/iter   (870.96 µs … 2.92 ms)<br/><br/>$ bun db-lokijs.mjs <br/>cpu: Intel(R) Core(TM) i7-5600U CPU @ 2.60GHz<br/>runtime: bun 0.1.8 (x64-linux)<br/><br/>benchmark                  time (avg)             (min … max)<br/>-------------------------------------------------------------<br/>paths                  584.23 µs/iter   (383.01 µs … 2.16 ms)<br/>random find             55.57 µs/iter  (35.71 µs … 794.04 µs)<br/>random siblings        101.52 µs/iter    (41.07 µs … 1.12 ms)<br/>random indexes         122.64 µs/iter   (104.22 µs … 1.34 ms)<br/>search layouts          182.1 µs/iter   (132.24 µs … 1.55 ms)<br/>search layouts sorted    2.55 ms/iter     (1.94 ms … 6.42 ms)</span></pre><p id="5ebe" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">在这种情况下，相同的源文件在Node.js和Bun上执行。</p><p id="a36a" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">首先，LokiJS代码比ForerunnerDB快得多。如此之快，以至于我已经重写了AkashaCMS来使用LokiJS。使用ForerunnerDB实现时，渲染<code class="fe nk nl nm nn b">techsparx.com</code>网站的时间超过30分钟，而使用LokiJS时，时间减少到了5分钟左右。</p><p id="4437" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">其次，请注意，在Bun上执行LokiJS查询要比在Node.js上快得多。这对于未来Bun将提供比Node.js高得多的性能的前景来说是很好的</p><h1 id="c606" class="mn mo iu bd mp mq mr ms mt mu mv mw mx ka my kb mz kd na ke nb kg nc kh nd ne bi translated">更多的模板渲染引擎在Bun上工作</h1><p id="5e2c" class="pw-post-body-paragraph kv kw iu kx b ky nf jv la lb ng jy ld le nh lg lh li ni lk ll lm nj lo lp lq in bi translated">在<a class="ae mm" href="https://techsparx.com/nodejs/bun/speed-test.html" rel="noopener ugc nofollow" target="_blank">早期测试</a>中，当在Mitata下运行时，几个模板引擎触发了分段错误。我向Bun团队报告了这个问题，这些问题和Bun中一长串其他segfault错误一起得到了修复。我很高兴地告诉大家，我测试过的大多数模板引擎现在都运行正常。</p><pre class="kk kl km kn gu np nn nq nr aw ns bi"><span id="af00" class="nt mo iu nn b gz nu nv l nw nx">$ node render-node.mjs <br/>cpu: Intel(R) Core(TM) i7-5600U CPU @ 2.60GHz<br/>runtime: node v18.6.0 (x64-linux)<br/><br/>benchmark                       time (avg)             (min … max)<br/>------------------------------------------------------------------<br/>literal                      136.89 ns/iter (119.73 ns … 711.75 ns)<br/>literal list                 437.11 ns/iter   (381.11 ns … 1.02 µs)<br/>ejs-list                      29.48 µs/iter  (24.32 µs … 474.84 µs)<br/>ejs-list-template              3.02 µs/iter     (2.78 µs … 5.39 µs)<br/>ejs-page                      86.84 µs/iter  (74.43 µs … 548.41 µs)<br/>ejs-page-template              6.59 µs/iter     (6.16 µs … 7.52 µs)<br/>handlebars-join                7.32 µs/iter   (4.88 µs … 506.12 µs)<br/>handlebars-list                6.54 µs/iter   (5.06 µs … 640.28 µs)<br/>handlebars-page               16.47 µs/iter    (13.24 µs … 1.17 ms)<br/>liquid-join                   31.73 µs/iter    (17.05 µs … 5.36 ms)<br/>liquid-list                  113.29 µs/iter    (66.86 µs … 5.47 ms)<br/>liquid-page                   199.1 µs/iter   (140.55 µs … 4.12 ms)<br/>nunjucks-join                 45.17 µs/iter    (24.58 µs … 8.53 ms)<br/>nunjucks-list                 81.83 µs/iter    (55.22 µs … 2.29 ms)<br/>nunjucks-list-template         6.52 µs/iter        (6.08 µs … 8 µs)<br/>nunjucks-page                181.09 µs/iter (154.69 µs … 612.43 µs)<br/>nunjucks-page-template        16.51 µs/iter   (13.8 µs … 533.59 µs)<br/>less-css                       2.57 ms/iter     (1.25 ms … 8.26 ms)<br/>markdown-render-simple        28.44 µs/iter    (18.77 µs … 2.03 ms)<br/>markdown-render-test-suite   182.04 µs/iter   (126.57 µs … 1.24 ms)<br/>asciidoctor-render-test-suite 37.49 ms/iter   (26.14 ms … 86.24 ms)<br/>cheerio-simple                  150 µs/iter   (81.09 µs … 11.31 ms)<br/>cheerio-test-suite           351.85 µs/iter   (238.07 µs … 7.83 ms)<br/><br/>$ bun render-node.mjs <br/>cpu: Intel(R) Core(TM) i7-5600U CPU @ 2.60GHz<br/>runtime: bun 0.1.8 (x64-linux)<br/><br/>benchmark                       time (avg)             (min … max)<br/>------------------------------------------------------------------<br/>literal                     141.16 ns/iter (115.46 ns … 846.57 ns)<br/>literal list                492.97 ns/iter  (434.07 ns … 859.5 ns)<br/>ejs-join                     25.15 µs/iter    (16.64 µs … 5.87 ms)<br/>ejs-list                     42.96 µs/iter    (29.89 µs … 4.14 ms)<br/>ejs-list-template             2.99 µs/iter       (2.8 µs … 3.5 µs)<br/>ejs-page                    123.95 µs/iter    (91.74 µs … 2.66 ms)<br/>ejs-page-template             6.69 µs/iter     (5.75 µs … 1.97 ms)<br/>handlebars-join               4.13 µs/iter     (2.98 µs … 2.49 ms)<br/>handlebars-list               4.59 µs/iter      (3.32 µs … 1.1 ms)<br/>handlebars-page              10.87 µs/iter     (8.14 µs … 1.08 ms)<br/>liquid-join                  36.64 µs/iter    (20.21 µs … 2.48 ms)<br/>liquid-list                 132.03 µs/iter       (85 µs … 1.95 ms)<br/>liquid-page                 230.89 µs/iter   (179.65 µs … 2.46 ms)<br/>nunjucks-join               error: _Loader.call is not a function. (In '_Loader.call(this)', '_Loader.call' is undefined)<br/>...<br/>nunjucks-list               error: _Loader.call is not a function. (In '_Loader.call(this)', '_Loader.call' is undefined)<br/>...<br/>nunjucks-list-template      error: ...<br/>...<br/>nunjucks-page               error: _Loader.call is not a function. (In '_Loader.call(this)', '_Loader.call' is undefined)<br/>...<br/>nunjucks-page-template      error: ...<br/>...<br/>less-css                      2.91 ms/iter     (1.84 ms … 5.87 ms)<br/>markdown-render-simple       38.14 µs/iter    (22.12 µs … 2.16 ms)<br/>markdown-render-test-suite  198.03 µs/iter   (148.47 µs … 1.61 ms)<br/>cheerio-simple               79.21 µs/iter    (51.27 µs … 2.31 ms)<br/>cheerio-test-suite          289.82 µs/iter   (204.11 µs … 1.81 ms)</span></pre><p id="f951" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">这表明Bun现在可以执行每一个模板引擎(我选择测试的那些)而不会触发segfault。为此向面包队致敬。不幸的是，Nunjucks引擎不能在Bun上工作。我已经向努恩朱克斯小组报告了。</p><p id="08c3" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">至于性能，有一系列的结果。有些模板引擎在Bun上比较快，有些比较慢。引人注目的是，Cheerio在Bun上的速度明显更快。AkashaCMS广泛使用Cheerio进行服务器端DOM处理。</p><p id="02c2" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">每个场景名的第一部分是模板引擎:<code class="fe nk nl nm nn b">literal</code>使用JavaScript文字字符串，<code class="fe nk nl nm nn b">ejs</code>使用EJS，<code class="fe nk nl nm nn b">handlebars</code>使用手柄，<code class="fe nk nl nm nn b">liquid</code>使用LiquidJS，<code class="fe nk nl nm nn b">nunjucks</code>使用Nunjucks，<code class="fe nk nl nm nn b">less</code>使用LESSCSS，<code class="fe nk nl nm nn b">markdown</code>使用Markdown-IT，<code class="fe nk nl nm nn b">asciidoctor</code>使用AsciiDoctor，<code class="fe nk nl nm nn b">cheerio</code>使用Cheerio。</p><p id="cb6e" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated"><code class="fe nk nl nm nn b">join</code>和<code class="fe nk nl nm nn b">list</code>场景相对简单，如下所示:</p><pre class="kk kl km kn gu np nn nq nr aw ns bi"><span id="8a3a" class="nt mo iu nn b gz nu nv l nw nx">bench('literal', () =&gt; { return `${people.join(', ')}`; });<br/>bench('literal list', () =&gt; {<br/>    const ret = `<br/>    &lt;ul&gt;<br/>    ${people.map(person =&gt; {<br/>        return `&lt;li&gt;${person}&lt;/li&gt;`<br/>    })}<br/>    &lt;/ul&gt;<br/>`;<br/>    // console.log(ret);<br/>    return ret;<br/>});</span></pre><p id="c4dd" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">你知道在JavaScript中可以嵌套模板字符串吗？我没有，但它在这里。</p><p id="f312" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated"><code class="fe nk nl nm nn b">-page</code>场景稍微复杂一些，旨在模拟构建一个完整的HTML页面。这需要三个单独的模板，其中两个被渲染到第三个中，如下所示:</p><p id="261c" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">这在现实世界中是如何应用的，要考虑服务器端呈现网页是如何组织的。要呈现一个主模板的可能性极小。取而代之的是，会有许多小片段，每个片段都是从一个模板中呈现出来的。每个页面都可以由十几个或者数百个单独的模板渲染组合而成。</p><p id="d7ef" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">这些结果表明:</p><ul class=""><li id="487f" class="ly lz iu kx b ky kz lb lc le ma li mb lm mc lq ny me mf mg bi translated">文字字符串在Bun上比较慢</li><li id="29f0" class="ly lz iu kx b ky mh lb mi le mj li mk lm ml lq ny me mf mg bi translated">EJS在面包上比较慢</li><li id="dff5" class="ly lz iu kx b ky mh lb mi le mj li mk lm ml lq ny me mf mg bi translated">车把在小圆面包上更快</li><li id="0bc5" class="ly lz iu kx b ky mh lb mi le mj li mk lm ml lq ny me mf mg bi translated">液体在面包上速度较慢</li><li id="d9f1" class="ly lz iu kx b ky mh lb mi le mj li mk lm ml lq ny me mf mg bi translated">Nunjucks不处决Bun</li><li id="c00f" class="ly lz iu kx b ky mh lb mi le mj li mk lm ml lq ny me mf mg bi translated">LessCSS在Bun上也差不多</li><li id="4432" class="ly lz iu kx b ky mh lb mi le mj li mk lm ml lq ny me mf mg bi translated">Bun的降价速度较慢</li><li id="19ef" class="ly lz iu kx b ky mh lb mi le mj li mk lm ml lq ny me mf mg bi translated">AsciiDoctor不在Bun上执行</li><li id="09d9" class="ly lz iu kx b ky mh lb mi le mj li mk lm ml lq ny me mf mg bi translated">麦片在面包上更快</li><li id="1021" class="ly lz iu kx b ky mh lb mi le mj li mk lm ml lq ny me mf mg bi translated">正如所料，更复杂的场景需要更多的计算时间</li></ul><p id="1551" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">虽然情况有所改善——Bun现在执行更多的模板引擎——但模板渲染的性能并没有多少提高。</p><p id="0f37" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">AsciiDoctor与Markdown相似，都是表示富文本的简单文本格式。Node.js的AsciiDoctor包是从Ruby代码交叉编译而来的，并且依赖于Opal包。不幸的是，当前版本的asciidor/Opal在Bun上失败了。但是，这在Bun中出现了一个问题，在0.1.8中，以下代码失败:</p><pre class="kk kl km kn gu np nn nq nr aw ns bi"><span id="34f5" class="nt mo iu nn b gz nu nv l nw nx">import { fileURLToPath, pathToFileURL } from 'node:url';<br/>import * as path from 'path';<br/><br/>console.log(import.meta.url);<br/>console.log(fileURLToPath(import.meta.url));<br/><br/>const __asciidoctorDistDir__ = path.dirname(fileURLToPath(import.meta.url))<br/>console.log(__asciidoctorDistDir__);</span></pre><p id="fc21" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">这种代码模式对于在Node.js上模拟ES6模块中的<code class="fe nk nl nm nn b">__filename</code>和<code class="fe nk nl nm nn b">__dirname</code>变量非常重要。问题是<code class="fe nk nl nm nn b">import.meta.url</code>中的<code class="fe nk nl nm nn b">file:</code> URL无法识别。但是，对Bun 0.1.9进行了修复，这个特定的代码现在可以在Bun 0.1.9中工作。</p><p id="9d95" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">对于EJS和努恩朱克斯，我还测试了单独编译模板的好处。换句话说，不使用<code class="fe nk nl nm nn b">ejs.render</code>或<code class="fe nk nl nm nn b">nunjucks.renderString</code>，而是使用<code class="fe nk nl nm nn b">ejs.compile</code>和<code class="fe nk nl nm nn b">nunjucks.compile</code>来产生<code class="fe nk nl nm nn b">template</code>对象。这些是名称中带有<code class="fe nk nl nm nn b">-template</code>的测试用例。从这些结果来看，预编译模板可以获得很大的性能提升，但是在预编译模板上Node.js和Bun之间没有显著的性能差异。</p><h1 id="a583" class="mn mo iu bd mp mq mr ms mt mu mv mw mx ka my kb mz kd na ke nb kg nc kh nd ne bi translated">用Bun复制文件(<code class="fe nk nl nm nn b">fs.copyFile</code>)快多了</h1><p id="6959" class="pw-post-body-paragraph kv kw iu kx b ky nf jv la lb ng jy ld le nh lg lh li ni lk ll lm nj lo lp lq in bi translated">AkashaCMS实现的另一个场景是将文件从<em class="no">资产</em>目录复制到渲染输出目录。这个任务很简单，您生成一个输入文件列表，以及每个文件在输出目录中的位置。然后，您的应用程序使用<code class="fe nk nl nm nn b">fs</code>包中的函数来复制文件。</p><p id="31b8" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">您可以使用<code class="fe nk nl nm nn b">fs.createReadStream</code>和Streams API来复制文件，但是这很复杂。在Node.js 14中增加了<code class="fe nk nl nm nn b">fs.copyFile</code>函数，在Node.js 17中增加了<code class="fe nk nl nm nn b">fs.cp</code>函数。这些就简单多了。</p><p id="bceb" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">因为Chokidar不能在Bun上工作(见上文),所以我们不能以正常的方式读取资产目录层次。我所做的是生成一个JavaScript文件，其中包含一个测试网站中所有资产文件的数组。一个简单的基准测试结果如下:</p><pre class="kk kl km kn gu np nn nq nr aw ns bi"><span id="65f4" class="nt mo iu nn b gz nu nv l nw nx">import * as path from 'path';<br/>import { promises as fsp } from 'fs';<br/>import { assets } from './assets.mjs';<br/>import { bench, run } from "mitata";<br/><br/>bench('copy-assets', async () =&gt; {<br/>    for (let fileInfo of assets) {<br/>        const outdir = path.join('out', fileInfo.mountPoint);<br/>        await fsp.mkdir(outdir, { recursive: true });<br/>        const outfile = path.join('out', fileInfo.vpath);<br/>        await fsp.copyFile(fileInfo.fspath, outfile);<br/>    }<br/>});<br/><br/>try {<br/>    await run({<br/>        percentiles: false<br/>    });<br/>} catch (err) { console.error(err); }</span></pre><p id="3e09" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">以前这段代码会使用<code class="fe nk nl nm nn b">fs-extra</code>包中的<code class="fe nk nl nm nn b">mkdirs</code>和<code class="fe nk nl nm nn b">copy</code>函数。但是，内置函数可以处理这两个步骤。</p><p id="2cab" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">发现的另一个问题是Bun不支持<code class="fe nk nl nm nn b">fs.cp</code>功能:</p><pre class="kk kl km kn gu np nn nq nr aw ns bi"><span id="02d3" class="nt mo iu nn b gz nu nv l nw nx">copy-assets  error: fsp.cp is not a function. (In 'fsp.cp(fileInfo.fspath, outfile)', 'fsp.cp' is undefined)</span></pre><p id="9dc4" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">因此测试使用<code class="fe nk nl nm nn b">fs.copyFile</code>。</p><pre class="kk kl km kn gu np nn nq nr aw ns bi"><span id="d273" class="nt mo iu nn b gz nu nv l nw nx">$ node copy-files.mjs <br/>cpu: Intel(R) Core(TM) i7-5600U CPU @ 2.60GHz<br/>runtime: node v18.6.0 (x64-linux)<br/><br/>benchmark        time (avg)             (min … max)<br/>---------------------------------------------------<br/>copy-assets   46.36 ms/iter  (26.71 ms … 149.28 ms)<br/><br/>$ bun copy-files.mjs <br/>cpu: Intel(R) Core(TM) i7-5600U CPU @ 2.60GHz<br/>runtime: bun 0.1.8 (x64-linux)<br/><br/>benchmark        time (avg)             (min … max)<br/>---------------------------------------------------<br/>copy-assets   10.16 ms/iter    (8.43 ms … 10.88 ms)</span></pre><p id="64ad" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">对于这种复制文件的任务，Bun要比Node.js快得多。</p><h1 id="d2df" class="mn mo iu bd mp mq mr ms mt mu mv mw mx ka my kb mz kd na ke nb kg nc kh nd ne bi translated">丢失的包阻止了许多种类的应用</h1><p id="f41b" class="pw-post-body-paragraph kv kw iu kx b ky nf jv la lb ng jy ld le nh lg lh li ni lk ll lm nj lo lp lq in bi translated">任何包含使用Commander框架的命令行工具的包都会看到以下错误:</p><pre class="kk kl km kn gu np nn nq nr aw ns bi"><span id="488f" class="nt mo iu nn b gz nu nv l nw nx">$ bun node_modules/akasharender/cli.js -- --help<br/><br/>error: Cannot find package "child_process" from "/home/david/Projects/akasharender/akashacms-perftest/node_modules/akasharender/node_modules/commander/index.js"</span></pre><p id="a949" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">Bun团队知道<code class="fe nk nl nm nn b">child_process</code>包不见了，还有其他一些包。这些包被放入Node.js，因此应该放入Bun。</p><p id="1928" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">例如，<code class="fe nk nl nm nn b">forever-agent</code>包使用TLS包，另一个内置包。当然，任何创建HTTPS服务或与之交互的应用程序都将使用TLS包。并且，<code class="fe nk nl nm nn b">cacheable-lookup</code>包加载DNS包失败。任何处理使用域名连接到web服务的应用程序都必须进行DNS查找，并且将被阻止，因为此包不可用。</p><p id="c036" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">Bun团队知道这些问题，我们希望它们能随着时间的推移得到解决。</p><h1 id="0c3e" class="mn mo iu bd mp mq mr ms mt mu mv mw mx ka my kb mz kd na ke nb kg nc kh nd ne bi translated">摘要</h1><p id="11ef" class="pw-post-body-paragraph kv kw iu kx b ky nf jv la lb ng jy ld le nh lg lh li ni lk ll lm nj lo lp lq in bi translated">Bun正在迅速改进，但是现在还存在明显的功能性缺口。许多非常流行的包因为缺少核心包或函数而无法在Bun上执行。</p><p id="eea9" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">本文是使用Bun 0.1.8和0.1.9编写的。</p><p id="e126" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">我们已经在几个重要场景中证明了Bun比Node.js更快。在其他场景中，两者的性能大致相当，在某些情况下Node.js更有优势。Bun在一个完整的应用程序上的表现还有待观察，因为许多缺失的功能块阻止了它。</p><p id="0194" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">到目前为止，Bun非常有趣，但是缺少的特性阻止了在Bun上运行大多数完整的Node.js应用程序。Bun团队还有很多工作要做。</p></div><div class="ab cl lr ls hy lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="in io ip iq ir"><h1 id="8c52" class="mn mo iu bd mp mq nz ms mt mu oa mw mx ka ob kb mz kd oc ke nb kg od kh nd ne bi translated">关于作者</h1><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj oe"><img src="../Images/f88392bf042a1dd3054455f7ffb59dea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*h7GYRQA0L79SYfwo.jpg"/></div></figure><p id="3deb" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated"><a class="ae mm" href="https://davidherron.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="kx iv">大卫·赫伦</strong> </a> <strong class="kx iv"> </strong>:大卫·赫伦是一名作家和软件工程师，专注于技术的明智使用。他对太阳能、风能和电动汽车等清洁能源技术特别感兴趣。David在硅谷从事了近30年的软件工作，从电子邮件系统到视频流，再到Java编程语言，他已经出版了几本关于Node.js编程和电动汽车的书籍。</p></div><div class="ab cl lr ls hy lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="in io ip iq ir"><p id="04ac" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated"><em class="no">最初发表于</em><a class="ae mm" href="https://techsparx.com/nodejs/bun/test-2022-08-12.html" rel="noopener ugc nofollow" target="_blank"><em class="no">https://techsparx.com</em></a><em class="no">。</em></p></div></div>    
</body>
</html>