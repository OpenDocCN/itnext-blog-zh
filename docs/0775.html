<html>
<head>
<title>Reactive Streams and Multithreading</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应流和多线程</h1>
<blockquote>原文：<a href="https://itnext.io/reactive-streams-and-multithreading-efd63b67de9a?source=collection_archive---------1-----------------------#2018-05-27">https://itnext.io/reactive-streams-and-multithreading-efd63b67de9a?source=collection_archive---------1-----------------------#2018-05-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/b6a4278f5a1dbf81a3033c76019aa1ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FKeWXjjRKga0EwXzFPjdGA.jpeg"/></div></div></figure><p id="cc49" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">反应流是非阻塞的、异步的、多线程的、快速的、煮咖啡的……好吧，他们不煮咖啡。然而，其他属性通常与反应流相关联。然而，当开发人员第一次尝试流时，他们经常发现它们是阻塞的、同步的和单线程的。那么这一切只是炒作吗？让我们找出答案。</p><h1 id="ff4b" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">阻塞的溪流</h1><p id="0962" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">第一个简单的例子(使用Spring Reactor和Java)通常是这样的:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="14b9" class="mi kx iq me b gy mj mk l ml mm">source = Flux.<em class="mn">just</em>(1,2);</span><span id="a5b1" class="mi kx iq me b gy mo mk l ml mm">source<br/>   .map(i -&gt; i + ". element: " + i)<br/>   .subscribe(System.<em class="mn">out</em>::println);<br/><br/>System.<em class="mn">out</em>.println("Before or after?");</span><span id="5b63" class="mi kx iq me b gy mo mk l ml mm">// Output:<br/>// 1. element: 1<br/>// 2. element: 2<br/>// Before or after?</span></pre></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><p id="ec26" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以一切似乎都是同步的。要理解为什么我们需要理解流是如何工作的。第一行创建了源流，在本例中，它基于一个数组。第二行添加了一个映射操作，从而创建了一个映射流，一个映射值流。你可能知道，在我们订阅之前什么都不会发生。当我们订阅时，会发生以下情况:</p><ul class=""><li id="237e" class="mw mx iq ka b kb kc kf kg kj my kn mz kr na kv nb nc nd ne bi translated">subscribe方法告诉映射的流它准备好了，并期待值。</li><li id="8608" class="mw mx iq ka b kb nf kf ng kj nh kn ni kr nj kv nb nc nd ne bi translated">映射的流有一个父流，并将订阅请求转发给它。</li><li id="8b6f" class="mw mx iq ka b kb nf kf ng kj nh kn ni kr nj kv nb nc nd ne bi translated">源流没有父流，它立即开始发出值，并一直持续到完成。</li></ul><p id="0900" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所有的事情都发生在同一个线程上。这就是为什么最后一条语句只在流完成后执行。</p><h1 id="4fe0" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">让我们异步进行</h1><p id="9eb8" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">现在让我们用另一个流来代替源程序:一个定时器。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="18f3" class="mi kx iq me b gy mj mk l ml mm">source = Flux.<em class="mn">interval</em>(Duration.<em class="mn">ofSeconds</em>(1))<br/>   .take(2);</span><span id="e11d" class="mi kx iq me b gy mo mk l ml mm">//...</span><span id="3a61" class="mi kx iq me b gy mo mk l ml mm">// Output:<br/>// Before or after?<br/>// 0. element: 0<br/>// 1. element: 1</span></pre><p id="fc92" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以看到，流已经变成了异步的。为什么？因为源流不会立即发出值。所以很明显，源决定了我们的流是同步的还是异步的。</p><p id="60a7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是我们也可以直接影响我们流的线程行为。为了更好地说明，让我们再次改变源流:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="09ee" class="mi kx iq me b gy mj mk l ml mm">source = Flux.&lt;Integer&gt;<em class="mn">create</em>(emitter -&gt; {<br/>    System.<em class="mn">out</em>.println(Thread.<em class="mn">currentThread</em>().getName());<br/>    emitter.next(1);<br/>    emitter.complete();<br/>});</span><span id="26e6" class="mi kx iq me b gy mo mk l ml mm">// ...</span><span id="38d0" class="mi kx iq me b gy mo mk l ml mm">// Output:<br/>// main<br/>// 1. element: 1<br/>// Before or after?</span></pre><p id="a5d5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们现在可以看到源(流)在主线程上运行。现在让我们在源代码后添加publishOn并执行代码:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="687b" class="mi kx iq me b gy mj mk l ml mm">source.publishOn(Schedulers.<em class="mn">single</em>())<br/>// ...</span><span id="37f5" class="mi kx iq me b gy mo mk l ml mm">//Output:<br/>// main<br/>// Before or after?<br/>// 1. element: 1</span></pre><p id="b81d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">起初，一切都和以前一样，但是publishOn确保每个流操作都在另一个线程上运行。这就是为什么最后一个语句打印在值之前。</p><p id="78fb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们尝试一些不同的方法，在订阅之前插入subscribeOn:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="4405" class="mi kx iq me b gy mj mk l ml mm">source.map(i -&gt; i + ". element: " + i)<br/>.subscribeOn(Schedulers.<em class="mn">single</em>())<br/>.subscribe(System.<em class="mn">out</em>::println);</span><span id="641d" class="mi kx iq me b gy mo mk l ml mm">// Output:<br/>// Before or after?<br/>// single-1<br/>// 1. element: 1</span></pre><p id="bb5d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如我们从输出中看到的，现在甚至订阅进程也在另一个线程上运行。我们最终得到了一个真正异步的、非阻塞的流。</p><h1 id="5a90" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">结论</h1><p id="c9ae" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">反应流并不总是异步的。线程行为主要取决于源代码，并且会受到运算符的影响。不过，好的一面是代码保持不变。我们可以对同步和异步流使用相同的编程模型和相同的管道。</p></div></div>    
</body>
</html>