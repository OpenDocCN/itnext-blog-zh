<html>
<head>
<title>Why I’m excited with React Hooks?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么我对React Hooks感到兴奋？</h1>
<blockquote>原文：<a href="https://itnext.io/why-im-excited-with-react-hooks-5a8601ac43f7?source=collection_archive---------4-----------------------#2019-02-11">https://itnext.io/why-im-excited-with-react-hooks-5a8601ac43f7?source=collection_archive---------4-----------------------#2019-02-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/5c43697d0c72157d5342c56c77629769.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LaTU0GpA_arBSXOmuXdwuQ.png"/></div></div></figure><div class=""/><p id="e3d6" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">2月6日React 16.8发布，随着React 16.8的发布，<a class="ae kw" href="https://reactjs.org/docs/hooks-intro.html" rel="noopener ugc nofollow" target="_blank"> React Hooks </a>在稳定版中可用！</p><p id="12cf" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这意味着我们可以开始使用钩子，而不用担心编写不稳定的代码。</p><p id="e953" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面是本帖中代码的一个实例:</p><p id="d07e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kw" href="https://frontarm.com/demoboard/?id=af4f455f-1d30-4823-90a9-b15cfc3e92f9" rel="noopener ugc nofollow" target="_blank">https://frontarm.com/demoboard/?id = af4f 455 f-1d 30-4823-90 a9-b 15 cf C3 e 92 f 9</a></p><h1 id="ec6f" class="kx ky jb bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">但是，什么是钩子呢？</h1><p id="bba9" class="pw-post-body-paragraph jy jz jb ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">钩子是允许您使用功能组件的状态和“生命周期”的函数，这意味着您不需要编写类来构建React组件。</p><p id="8b16" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对我来说，这是令人兴奋的，因为我不喜欢绑定“这个”(你看到我在那里做了什么？).我的意思是，React中的类有点乱(我不是唯一这样认为的人)。大部分时候和“这个”有关。但那是以后的事了。</p><p id="a918" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以你可以在不使用类的情况下访问几乎所有的状态生命周期。但是怎么做呢？</p><h1 id="21b9" class="kx ky jb bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">有哪些钩子可用，它们有什么作用？</h1><p id="795e" class="pw-post-body-paragraph jy jz jb ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">直接从React的页面，我们有这个挂钩列表(<a class="ae kw" href="https://reactjs.org/docs/hooks-reference.html" rel="noopener ugc nofollow" target="_blank">https://reactjs.org/docs/hooks-reference.html</a>)</p><p id="7fe3" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kw" href="https://reactjs.org/docs/hooks-reference.html#basic-hooks" rel="noopener ugc nofollow" target="_blank">基本挂钩</a></p><ul class=""><li id="2405" class="ma mb jb ka b kb kc kf kg kj mc kn md kr me kv mf mg mh mi bi translated"><code class="fe mj mk ml mm b"><a class="ae kw" href="https://reactjs.org/docs/hooks-reference.html#usestate" rel="noopener ugc nofollow" target="_blank">useState</a></code></li><li id="9892" class="ma mb jb ka b kb mn kf mo kj mp kn mq kr mr kv mf mg mh mi bi translated"><code class="fe mj mk ml mm b"><a class="ae kw" href="https://reactjs.org/docs/hooks-reference.html#useeffect" rel="noopener ugc nofollow" target="_blank">useEffect</a></code></li><li id="5f3a" class="ma mb jb ka b kb mn kf mo kj mp kn mq kr mr kv mf mg mh mi bi translated"><code class="fe mj mk ml mm b"><a class="ae kw" href="https://reactjs.org/docs/hooks-reference.html#usecontext" rel="noopener ugc nofollow" target="_blank">useContext</a></code></li></ul><p id="84cf" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kw" href="https://reactjs.org/docs/hooks-reference.html#additional-hooks" rel="noopener ugc nofollow" target="_blank">附加挂钩</a></p><ul class=""><li id="2d87" class="ma mb jb ka b kb kc kf kg kj mc kn md kr me kv mf mg mh mi bi translated"><code class="fe mj mk ml mm b"><a class="ae kw" href="https://reactjs.org/docs/hooks-reference.html#usereducer" rel="noopener ugc nofollow" target="_blank">useReducer</a></code></li><li id="e012" class="ma mb jb ka b kb mn kf mo kj mp kn mq kr mr kv mf mg mh mi bi translated"><code class="fe mj mk ml mm b"><a class="ae kw" href="https://reactjs.org/docs/hooks-reference.html#usecallback" rel="noopener ugc nofollow" target="_blank">useCallback</a></code></li><li id="768f" class="ma mb jb ka b kb mn kf mo kj mp kn mq kr mr kv mf mg mh mi bi translated"><code class="fe mj mk ml mm b"><a class="ae kw" href="https://reactjs.org/docs/hooks-reference.html#usememo" rel="noopener ugc nofollow" target="_blank">useMemo</a></code></li><li id="b691" class="ma mb jb ka b kb mn kf mo kj mp kn mq kr mr kv mf mg mh mi bi translated"><code class="fe mj mk ml mm b"><a class="ae kw" href="https://reactjs.org/docs/hooks-reference.html#useref" rel="noopener ugc nofollow" target="_blank">useRef</a></code></li><li id="e73c" class="ma mb jb ka b kb mn kf mo kj mp kn mq kr mr kv mf mg mh mi bi translated"><code class="fe mj mk ml mm b"><a class="ae kw" href="https://reactjs.org/docs/hooks-reference.html#useimperativehandle" rel="noopener ugc nofollow" target="_blank">useImperativeHandle</a></code></li><li id="c360" class="ma mb jb ka b kb mn kf mo kj mp kn mq kr mr kv mf mg mh mi bi translated"><code class="fe mj mk ml mm b"><a class="ae kw" href="https://reactjs.org/docs/hooks-reference.html#uselayouteffect" rel="noopener ugc nofollow" target="_blank">useLayoutEffect</a></code></li><li id="bc7e" class="ma mb jb ka b kb mn kf mo kj mp kn mq kr mr kv mf mg mh mi bi translated"><code class="fe mj mk ml mm b"><a class="ae kw" href="https://reactjs.org/docs/hooks-reference.html#usedebugvalue" rel="noopener ugc nofollow" target="_blank">useDebugValue</a></code></li></ul><p id="df2f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我将尝试从列表中的前3个元素开始。(一开始我想在4中发布，但是帖子太长了，我会把它分开)</p><h1 id="cddd" class="kx ky jb bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">使用状态挂钩</h1><p id="5012" class="pw-post-body-paragraph jy jz jb ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">这个钩子让你在一个功能组件中有一个内部状态。下面是一个计数器组件与类组件和函数组件的比较。</p><p id="5f48" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们以计数器为例:</p><pre class="ms mt mu mv gt mw mm mx my aw mz bi"><span id="02fe" class="na ky jb mm b gy nb nc l nd ne">import React from 'react'</span><span id="fab5" class="na ky jb mm b gy nf nc l nd ne">export default class Counter extends React.Component {<br/>  constructor (props) {<br/>    super(props)<br/>    this.state = {<br/>      count: props.initialCount || 0<br/>    }<br/>    this.add = this.add.bind(this)<br/>    this.minus = this.minus.bind(this)<br/>    this.reset = this.reset.bind(this)<br/>  }<br/>  add () {<br/>    this.setState((state) =&gt; ({ count: state.count + 1 }))<br/>  }<br/>  minus () {<br/>    this.setState((state) =&gt; ({ count: state.count - 1 }))<br/>  }<br/>  reset () {<br/>    this.setState((state) =&gt; ({ count: 0 }))<br/>  }<br/>  render () {<br/>    return (<br/>      &lt;div className="counter"&gt;<br/>        &lt;span className="counter__count"&gt;{ this.state.count }&lt;/span&gt;<br/>        &lt;button onClick={this.add}&gt;+&lt;/button&gt;<br/>        &lt;button onClick={this.minus}&gt;-&lt;/button&gt;<br/>        &lt;button onClick={this.reset}&gt;Clear&lt;/button&gt;<br/>      &lt;/div&gt;<br/>    )<br/>  }<br/>}</span></pre><p id="7e36" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在相同，但带有使用状态</p><pre class="ms mt mu mv gt mw mm mx my aw mz bi"><span id="63e3" class="na ky jb mm b gy nb nc l nd ne">import React, { useState, useEffect } from 'react'</span><span id="5f46" class="na ky jb mm b gy nf nc l nd ne">export default function CounterUseState (props) {<br/>  const [count, setCount] = useState(props.initialCount || 0)<br/>  const add = () =&gt; { setCount(count + 1) }<br/>  const minus = () =&gt; { setCount(count - 1) }<br/>  const reset = () =&gt; { setCount(0) }<br/>  <br/>  return (<br/>      &lt;div className="counter"&gt;<br/>        &lt;span className="counter__count"&gt;{ count }&lt;/span&gt;<br/>        &lt;button onClick={add}&gt;+&lt;/button&gt;<br/>        &lt;button onClick={minus}&gt;-&lt;/button&gt;<br/>        &lt;button onClick={reset}&gt;Clear&lt;/button&gt;<br/>      &lt;/div&gt;<br/>    )<br/>}</span></pre><p id="584f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们再也没有“这个”了！因此,“状态”更容易使用，处理程序更干净，并且更容易与组件范围之外的函数组合。</p><p id="f1e7" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们如何处理组件的“生命周期”呢？我们将使用<strong class="ka jc">使用效果</strong>挂钩</p><h1 id="4453" class="kx ky jb bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">使用效果挂钩</h1><p id="eedd" class="pw-post-body-paragraph jy jz jb ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">这个钩子接收了两个参数，第一个参数是组件呈现时运行的回调函数，这个回调函数要么在组件第一次呈现时被调用(<strong class="ka jc">componentdimount</strong>)，要么在每次重新呈现时被调用(<strong class="ka jc"> componentDidUpdate </strong>)，第二个参数对此非常重要，因为它决定了您想要“观察”哪些变量或道具的变化。因此使用useEffect将作为<strong class="ka jc">componentid mount</strong>和<strong class="ka jc">componentid update</strong>工作</p><p id="1149" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们如何清除这些影响？在效果中运行的函数应该返回另一个函数，这个函数是在组件被卸载时运行的。神奇！！</p><pre class="ms mt mu mv gt mw mm mx my aw mz bi"><span id="6b7d" class="na ky jb mm b gy nb nc l nd ne">import React, { useState, useEffect } from 'react'</span><span id="50f4" class="na ky jb mm b gy nf nc l nd ne">export default function FunctionalTimer (props) {<br/>  const [count, setCount] = useState(props.initialCount || 0)<br/>  const [running, setRunning] = useState(false)</span><span id="742d" class="na ky jb mm b gy nf nc l nd ne">  const start = () =&gt; setRunning(true)<br/>  const pause = () =&gt; setRunning(false)<br/>  const reset = () =&gt; setCount(0)<br/>  const tick = () =&gt; running &amp;&amp; setTimeout(() =&gt; setCount(count + 1), 1000)<br/>  <br/>  useEffect(() =&gt; {<br/>    tick()<br/>  }, [running, count])</span><span id="4612" class="na ky jb mm b gy nf nc l nd ne">return (<br/>      &lt;div className="counter"&gt;<br/>        &lt;span className="counter__count"&gt;{ count }&lt;/span&gt;<br/>        &lt;button onClick={start}&gt;Start&lt;/button&gt;<br/>        &lt;button onClick={pause}&gt;Pause&lt;/button&gt;<br/>        &lt;button onClick={reset}&gt;Clear&lt;/button&gt;<br/>      &lt;/div&gt;<br/>    )<br/>}</span></pre><p id="7fef" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc"> setTimeout </strong>和<strong class="ka jc"> setInterval </strong>是功能组件纯属性之外的效果。这同样适用于改变组件之外的其他内容，例如，document.title或向非合成事件添加事件侦听器。</p><pre class="ms mt mu mv gt mw mm mx my aw mz bi"><span id="a32a" class="na ky jb mm b gy nb nc l nd ne">import React, { useState, useEffect } from 'react'</span><span id="8c32" class="na ky jb mm b gy nf nc l nd ne">export default function FunctionalTimer (props) {<br/>  const [count, setCount] = useState(props.initialCount || 0)<br/>  const [running, setRunning] = useState(false)</span><span id="01c5" class="na ky jb mm b gy nf nc l nd ne">  const start = () =&gt; setRunning(true)<br/>  const pause = () =&gt; setRunning(false)<br/>  const reset = () =&gt; setCount(0)<br/>  const tick = () =&gt; running &amp;&amp; setTimeout(() =&gt; setCount(count + 1), 1000)<br/>  <br/>  useEffect(() =&gt; {<br/>    tick()<br/>  }, [running, count])<br/>  <br/>  useEffect(() =&gt; {<br/>    document.title = `${count} seconds pass`<br/>  }, [count])</span><span id="20a5" class="na ky jb mm b gy nf nc l nd ne">useEffect(() =&gt; {<br/>    const logOnSizeUpdate = () =&gt; console.log({ count, running })<br/>    window.addEventListener('resize', logOnSizeUpdate)<br/>    return () =&gt; window.removeEventListener('resize', logOnSizeUpdate)</span><span id="e033" class="na ky jb mm b gy nf nc l nd ne">  }, []) // when the array is empty only runs on mount not update</span><span id="1c36" class="na ky jb mm b gy nf nc l nd ne">return (<br/>      &lt;div className="counter"&gt;<br/>        &lt;span className="counter__count"&gt;{ count }&lt;/span&gt;<br/>        &lt;button onClick={start}&gt;Start&lt;/button&gt;<br/>        &lt;button onClick={pause}&gt;Pause&lt;/button&gt;<br/>        &lt;button onClick={reset}&gt;Clear&lt;/button&gt;<br/>      &lt;/div&gt;<br/>    )<br/>}</span></pre><p id="705f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">钩子令人敬畏的能力之一是创建自定义钩子的能力，而自定义钩子只是简单的函数！</p><p id="52b4" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们重写计时器代码，并将所有状态逻辑转移到名为<strong class="ka jc"> useTimer </strong>和<strong class="ka jc"> useSetTitle </strong>的自定义挂钩中</p><pre class="ms mt mu mv gt mw mm mx my aw mz bi"><span id="884e" class="na ky jb mm b gy nb nc l nd ne">import React, { useState, useEffect } from 'react'</span><span id="0ee0" class="na ky jb mm b gy nf nc l nd ne">function useTimer (initialCount = 0, autoStart = false) {<br/>  const [count, setCount] = useState(initialCount)<br/>  const [running, setRunning] = useState(autoStart)</span><span id="9a1f" class="na ky jb mm b gy nf nc l nd ne">const start = () =&gt; setRunning(true)<br/>  const pause = () =&gt; setRunning(false)<br/>  const reset = () =&gt; setCount(0)<br/>  const tick = () =&gt; running &amp;&amp; setTimeout(() =&gt; setCount(count + 1), 1000)<br/>  <br/>  useEffect(() =&gt; {<br/>    tick()<br/>  }, [running, count])<br/>  <br/>  return {<br/>    count,<br/>    running,<br/>    start,<br/>    pause,<br/>    reset<br/>  }<br/>}</span><span id="749b" class="na ky jb mm b gy nf nc l nd ne">function useSetTitle (count) {<br/>  useEffect(() =&gt; {<br/>    document.title = `${count} seconds pass`<br/>  })<br/>}</span><span id="6bcd" class="na ky jb mm b gy nf nc l nd ne">export default function FunctionalTimer (props) {<br/>  const timer = useTimer(props.initialCount, props.autoStart)<br/>  useSetTitle(timer.count)<br/>  <br/>  return (<br/>      &lt;div className="counter"&gt;<br/>        &lt;span className="counter__count"&gt;{ timer.count }&lt;/span&gt;<br/>        &lt;button onClick={timer.start}&gt;Start&lt;/button&gt;<br/>        &lt;button onClick={timer.pause}&gt;Pause&lt;/button&gt;<br/>        &lt;button onClick={timer.reset}&gt;Clear&lt;/button&gt;<br/>      &lt;/div&gt;<br/>    )<br/>}</span></pre><p id="46a2" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这允许我们构建一堆有状态的逻辑，它们存在于钩子中，可以在任何功能组件中使用，使我们能够以更好的方式重用和组合我们的代码。</p><h1 id="9cfe" class="kx ky jb bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">useRef</h1><p id="8322" class="pw-post-body-paragraph jy jz jb ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">这个钩子允许我们在组件渲染之间有一个持久的值。为什么我们需要它，如果你注意到在前面的例子中，时间的工作方式是在下一个计数器改变时设置时间。这样做的问题是，如果我们清除计时器，下次运行的函数，将在清除之前有count的值，因为你需要暂停，清除并重新开始。效果中的函数引用将具有变量被设置时的值。那样的话，我们将需要<strong class="ka jc"> useRef </strong>在组件每次渲染时存储一个回调，以保持计时器的稳定性。</p><pre class="ms mt mu mv gt mw mm mx my aw mz bi"><span id="35f8" class="na ky jb mm b gy nb nc l nd ne">import React, { useState, useEffect, useRef } from 'react'</span><span id="c89a" class="na ky jb mm b gy nf nc l nd ne">function useTimerInterval (initialCount = 0, autoStart = false) {<br/>  const [count, setCount] = useState(initialCount)<br/>  const [running, setRunning] = useState(autoStart)<br/>  const cb = useRef()<br/>  const id = useRef()</span><span id="6ff6" class="na ky jb mm b gy nf nc l nd ne">  const start = () =&gt; setRunning(true)<br/>  const pause = () =&gt; setRunning(false)<br/>  const reset = () =&gt; setCount(0)</span><span id="4903" class="na ky jb mm b gy nf nc l nd ne">  function callback () {<br/>    setCount(count + 1)<br/>  }<br/>  <br/>  // Save the current callback to add right number to the count, every render<br/>  useEffect(() =&gt; {<br/>    cb.current = callback<br/>  })<br/>  <br/>  useEffect(() =&gt; {</span><span id="6a1c" class="na ky jb mm b gy nf nc l nd ne">    // This function will call the cb.current, that was load in the effect before. and will always refer to the correct callback function with the current count value.   <br/>    function tick() {<br/>      cb.current()<br/>    }<br/>    if (running &amp;&amp; !id.current) {<br/>      id.current = setInterval(tick, 1000)<br/>    }<br/>    <br/>    if (!running &amp;&amp; id.current) {<br/>      clearInterval(id.current)<br/>      id.current = null<br/>    }<br/>    return () =&gt; id.current &amp;&amp; clearInterval(id.current)<br/>  }, [running])<br/>  <br/>  return {<br/>    count,<br/>    start,<br/>    pause,<br/>    reset<br/>  }<br/>}</span><span id="487c" class="na ky jb mm b gy nf nc l nd ne">function useSetTitle (count) {<br/>  useEffect(() =&gt; {<br/>    document.title = `${count} seconds pass`<br/>  })<br/>}</span><span id="40cc" class="na ky jb mm b gy nf nc l nd ne">export default function FunctionalTimer (props) {<br/>  const timer = useTimerInterval(props.initialCount, props.autoStart)<br/>  useSetTitle(timer.count)<br/>  <br/>  return (<br/>      &lt;div className="counter"&gt;<br/>        &lt;span className="counter__count"&gt;{ timer.count }&lt;/span&gt;<br/>        &lt;button onClick={timer.start}&gt;Start&lt;/button&gt;<br/>        &lt;button onClick={timer.pause}&gt;Pause&lt;/button&gt;<br/>        &lt;button onClick={timer.reset}&gt;Clear&lt;/button&gt;<br/>      &lt;/div&gt;<br/>    )<br/>}</span></pre><p id="0ea7" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面是本帖中代码的一个实例:</p><div class="ip iq gp gr ir ng"><a href="https://frontarm.com/demoboard/?id=af4f455f-1d30-4823-90a9-b15cfc3e92f9" rel="noopener  ugc nofollow" target="_blank"><div class="nh ab fo"><div class="ni ab nj cl cj nk"><h2 class="bd jc gy z fp nl fr fs nm fu fw ja bi translated">演示板</h2><div class="nn l"><h3 class="bd b gy z fp nl fr fs nm fu fw dk translated">快速创建Javascript和Markdown演示。导入npm上的任何包。</h3></div><div class="no l"><p class="bd b dl z fp nl fr fs nm fu fw dk translated">frontarm.com</p></div></div><div class="np l"><div class="nq l nr ns nt np nu ix ng"/></div></div></a></div><p id="84f4" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">也许你想多了解一下为什么定时器需要持久引用。如果是那样的话本文就深入探讨一下<a class="ae kw" href="https://overreacted.io/making-setinterval-declarative-with-react-hooks/" rel="noopener ugc nofollow" target="_blank">https://overreated . io/making-setinterval-declarative-with-react-hooks/</a></p><p id="21ac" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是一个关于React钩子的基本例子，我推荐看React会议上关于钩子的视频。</p><figure class="ms mt mu mv gt is"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="a533" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我将继续这个关于React钩子与<strong class="ka jc"> useContext </strong>和<strong class="ka jc"> useReducer </strong>的话题，以及我们如何用这两个钩子构建类似Redux的东西。</p><p id="a7f1" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">直到下一个帖子，愿原力与你同在</p></div></div>    
</body>
</html>