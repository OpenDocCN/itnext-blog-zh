<html>
<head>
<title>Matrix Code Animation in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React中的矩阵代码动画</h1>
<blockquote>原文：<a href="https://itnext.io/matrix-code-animation-in-react-96daeee65d3e?source=collection_archive---------2-----------------------#2018-07-13">https://itnext.io/matrix-code-animation-in-react-96daeee65d3e?source=collection_archive---------2-----------------------#2018-07-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="cfdb" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">一个简单的基于React的动画《黑客帝国》三部曲中的代码雨</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/d481f39d8ec6149c045a409ca0ba9158.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9Cqyu3Lx4BKHUZShGe5cuQ.jpeg"/></div></div></figure><p id="29f3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是我的第一篇博文，我想让它与众不同，就像初吻通常不一样。</p><p id="fda7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">自从第一个绿色符号出现在老式屏幕上，我就一直是《黑客帝国》电影的粉丝。这也是我想测试React和push的渲染速度，看看极限在哪里的原因之一。此外，创建自己感兴趣的东西总是很有趣的。比如乐高房子，或者枕头城堡。</p><p id="2034" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我用过的React版本是16，因为我使用的是集合，所以当然是Lodash (v4)</p><p id="c32a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">TL；博士-&gt;如果你像我一样懒，请看这里的完整代码:<a class="ae ln" href="https://github.com/jasofalcon/matrix" rel="noopener ugc nofollow" target="_blank">github.com/jasofalcon/matrix</a></p><h1 id="b611" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">字体部分</h1><p id="91e3" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">首先，我们希望这看起来专业。此外，来自锡安的某个人可能正在阅读这篇文章。我开玩笑的，我知道锡安不是真的。总之，我用过<strong class="kt ir"> <em class="ml">矩阵式字体NFI </em> </strong>，看看这里— <a class="ae ln" href="https://www.dafont.com/matrix-code-nfi.font" rel="noopener ugc nofollow" target="_blank"> matrix-font-nfi </a>。在我看来很像母系。<br/>我做的另一件事是定义应用程序将使用的一组字符，因为字体只为一些字母提供符号。像这样:</p><pre class="kg kh ki kj gt mm mn mo mp aw mq bi"><span id="b92f" class="mr lp iq mn b gy ms mt l mu mv">const chars = [<br/> 'a',<br/> 'b',<br/> 'c',<br/> // ... many more symbols...<br/> '0',<br/> '~',<br/> '!',<br/> '#',<br/> '$'<br/>];</span><span id="693f" class="mr lp iq mn b gy mw mt l mu mv">export default chars;</span></pre><h1 id="3207" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">有趣的部分</h1><p id="e268" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">好吧，安德森先生，让我们吃下红色药丸，潜入可怕的粘液深渊。<br/>app结构相当简单，只有3个组件。<em class="ml">符号</em>、<em class="ml">代码</em>、<strong class="kt ir">、<em class="ml">矩阵</em>、</strong>！<br/>我想让它原子化，所以一个符号组件代表一个单独的字符和与之相连的所有表示逻辑。一个代码组件只不过是一个符号数组，基本上是一行代码。您可以很容易地假设矩阵组件只不过是一组代码组件，也就是符号列表。所以我们有一个符号列表，通过数学定义形成一个……..<strong class="kt ir">矩阵</strong>的符号。</p><h1 id="9ab1" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">标志</h1><p id="ad28" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">一个简单的角色。自然，它包含一个char作为它的状态。</p><pre class="kg kh ki kj gt mm mn mo mp aw mq bi"><span id="4e2f" class="mr lp iq mn b gy ms mt l mu mv">constructor(props) {<br/>    super(props);<br/>    this.state = { char: this.getRandomChar() };<br/>}</span></pre><p id="fe7b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您注意到了一个getRandomChar方法。它只是从我们之前定义的符号列表中获取一个随机字符。</p><pre class="kg kh ki kj gt mm mn mo mp aw mq bi"><span id="c5a0" class="mr lp iq mn b gy ms mt l mu mv">import chars from "../chars/chars";<br/>// ...<br/>getRandomChar() {<br/>  return chars[Math.floor(Math.random() * chars.length)];<br/>}</span></pre><p id="687b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，你可能已经注意到在看电影的时候，一些符号在落在屏幕上的时候会发生变化。更具体地说，最后一个符号(让我们称之为前导符号，或主要符号)总是在变化，其他一些符号也随机变化。也就是说，让我们使主要符号可变，而只有“一些”其他的。</p><pre class="kg kh ki kj gt mm mn mo mp aw mq bi"><span id="fc6e" class="mr lp iq mn b gy ms mt l mu mv">componentWillMount() {<br/>  if (this.props.primary || Math.random() &gt; 0.95) {<br/>    this.makeSymbolDynamic();<br/>  }<br/>}</span><span id="77f3" class="mr lp iq mn b gy mw mt l mu mv">makeSymbolDynamic() {<br/>  setInterval(() =&gt; {<br/>    this.setState({ char: this.getRandomChar() });<br/>  }, 500);<br/>}</span></pre><p id="f57a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这可能会导致一些性能问题，因为我们注册了一个每500毫秒触发一次的处理程序。这就是为什么我们只在符号是主要符号的情况下才这么做，其他符号只占5%。Math.rand返回值介于0和1之间。</p><p id="a8e3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我发现另一个重要的细节是不透明性。每条线到最后都会变淡，所以还有另外一个道具我要发给符号组件，那就是不透明度。这是我们如何渲染一个符号:</p><pre class="kg kh ki kj gt mm mn mo mp aw mq bi"><span id="6d09" class="mr lp iq mn b gy ms mt l mu mv">render() {<br/>    const { primary, opacity } = this.props;<br/>    return (<br/>        &lt;div className={"symbol " + (primary ? "primary" : "")}<br/>          style={{ opacity }} &gt;<br/>            {this.state.char}<br/>        &lt;/div&gt;<br/>    );<br/>}</span></pre><p id="16c9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">只是有一些小的css定义那个<code class="fe mx my mz mn b">primary</code>符号更闪亮一点，就是这样。</p><h1 id="0e2a" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">密码</h1><p id="063f" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">这是我们举重的地方。如前所述，代码组件是符号的集合。我们有几条关于这条线符号的相关信息。它们是位置(x，y)、符号数、过渡(下降)速度和缩放比例(有些更近，有些更远)。</p><pre class="kg kh ki kj gt mm mn mo mp aw mq bi"><span id="96bb" class="mr lp iq mn b gy ms mt l mu mv">constructor(props, state) {<br/>  super(props);</span><span id="a0ca" class="mr lp iq mn b gy mw mt l mu mv">this.state = {<br/>    codeLength: 0,<br/>    yPosition: 0,<br/>    xPosition: 0,<br/>    transition: "",<br/>    transform: ""<br/>  };<br/>}</span></pre><p id="4cb6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在组件安装之前，我们需要设置好一切。这可能看起来有点复杂，但是一旦你单独看每一行，它是非常简单的。顺便说一句，这些值大部分是根据经验计算的。</p><pre class="kg kh ki kj gt mm mn mo mp aw mq bi"><span id="1525" class="mr lp iq mn b gy ms mt l mu mv">const SYMBOL_HEIGHT = 30; // Empirically :)<br/>const SYMBOL_WIDTH = 18;</span><span id="4a5e" class="mr lp iq mn b gy mw mt l mu mv">componentWillMount() {<br/>    // Some lines are zoomed-in, some zoomed-out<br/>    const scaleRatio = _.random(0.8, 1.4); // Empirically chosen numbers</span><span id="3ef3" class="mr lp iq mn b gy mw mt l mu mv">//Min code height is height of screen. No good reason but - why not<br/>    const minCodeHeight = _.round(window.innerHeight / SYMBOL_HEIGHT);<br/>    //This should calculate how much pixels does line take<br/>    const codeLength = _.random(minCodeHeight, minCodeHeight * 2);</span><span id="cdd6" class="mr lp iq mn b gy mw mt l mu mv">//Hacky solution to get the line above top=0 at start (hide it)<br/>    const yPosition = (codeLength + 1) * SYMBOL_HEIGHT * scaleRatio;</span><span id="390e" class="mr lp iq mn b gy mw mt l mu mv">// we don't want to have partially overlaping lines - make columns<br/>    // it basically mean line can only fall in descrete positions<br/>    const stepCount = _.round((window.innerWidth - 20) / SYMBOL_WIDTH);<br/>    const xPosition = _.random(0, stepCount) * SYMBOL_WIDTH;</span><span id="4cb0" class="mr lp iq mn b gy mw mt l mu mv">// we divide by scale ratio because if it is small it is probably far =&gt; thus slower :)<br/>    const transition = ` top linear ${_.random(5, 10) / scaleRatio}s`; //different speed<br/>    const transform = `scale(${scaleRatio})`;</span><span id="2ed5" class="mr lp iq mn b gy mw mt l mu mv">this.setState({ codeLength, yPosition, xPosition, transition, transform });<br/>  }</span></pre><p id="b291" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">接下来我们需要做的是组织秋天。我们不希望所有人都在同一时间倒下，所以对于一条线，我们将设置随机的开始时间。setTimeout确保它将在某个伪随机时间启动</p><pre class="kg kh ki kj gt mm mn mo mp aw mq bi"><span id="0d67" class="mr lp iq mn b gy ms mt l mu mv">componentDidMount() {<br/>  const startTime = _.random(300, 10000); // each starts in different time</span><span id="8067" class="mr lp iq mn b gy mw mt l mu mv">setTimeout(() =&gt; {<br/>    const newHeight = window.innerHeight + this.state.yPosition;<br/>    this.setState({ yPosition: -newHeight }); //must be - b/c of start<br/>  }, startTime);<br/>}</span></pre><p id="a964" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在我们需要做的就是渲染组件。有一个很好的技巧，我们如何为最后5个符号创建不同的不透明外观。</p><pre class="kg kh ki kj gt mm mn mo mp aw mq bi"><span id="d20d" class="mr lp iq mn b gy ms mt l mu mv">render() {<br/>  const code = _.times(this.state.codeLength).map((x, i) =&gt; (<br/>    // Set opacity to small for last 5<br/>    // last one will have least opacity, 5th from last will have almost full<br/>    &lt;Symbol key={i} opacity={i &lt;= 5 ? i / 5 : 1} /&gt;<br/>  ));<br/>  <br/>  const { yPosition, xPosition, transition, transform } = this.state;<br/>  const styles = {<br/>    left: xPosition,<br/>    top: -yPosition,<br/>    transition,<br/>    transform<br/>  };</span><span id="9d5d" class="mr lp iq mn b gy mw mt l mu mv">// here we render list of symbols and one more - primary<br/>  return (<br/>    &lt;div className="code" style={styles}&gt;<br/>    {code}<br/>    &lt;Symbol primary="true" /&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre><h1 id="17ff" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">[数]矩阵</h1><p id="225c" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">别担心，这是最容易的部分。假设我们希望总共有100行。</p><pre class="kg kh ki kj gt mm mn mo mp aw mq bi"><span id="4148" class="mr lp iq mn b gy ms mt l mu mv">const CODE_LINES_COUNT = 100;</span><span id="f4f5" class="mr lp iq mn b gy mw mt l mu mv">render() {<br/>    const codes = _.times(CODE_LINES_COUNT).map((x, i) =&gt; &lt;Code key={i} /&gt;);<br/>    return &lt;div className="Matrix"&gt;{codes}&lt;/div&gt;;<br/>}</span></pre><p id="06a9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这就是你如何得到-&gt; <a class="ae ln" href="https://jasofalcon.github.io/matrix/" rel="noopener ugc nofollow" target="_blank">演示</a></p><h1 id="b17d" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">有趣的事实</h1><p id="946d" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">在测试渲染性能时，发现对于给定的行数(~100)，可能会有一些延迟。然而，我不得不承认，Chrome是唯一一个能够没有任何明显滞后的浏览器。而Safari、Edge甚至新的超高速Firefox都在苦苦挣扎。因此，至少Chrome消耗的内存不是没有用的。</p><p id="f2e2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">感谢你的阅读，如果你喜欢，请分享一些掌声:</strong></p><p id="864f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对于任何类型的反馈，请随意写</p></div></div>    
</body>
</html>