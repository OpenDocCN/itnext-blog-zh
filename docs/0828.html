<html>
<head>
<title>Reusable UI — Web Components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">可重用的用户界面— Web组件</h1>
<blockquote>原文：<a href="https://itnext.io/reusable-ui-web-components-72cbe56b0056?source=collection_archive---------4-----------------------#2018-06-05">https://itnext.io/reusable-ui-web-components-72cbe56b0056?source=collection_archive---------4-----------------------#2018-06-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="ee10" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">代码可重用性是代码速度最重要的事情之一。当构建一个应用程序时，你想把它分成具有不同职责的服务或模块，并在应用程序的几个地方使用它们。例如，当访问数据库或向远程服务器发送请求时，您不希望在代码中的任何地方实现请求过程和格式化。您想要做的是抽象出如何访问数据库以及如何从服务器请求数据的实现细节，并公开一个高级API供消费者使用。我们知道如何用后端服务和业务逻辑代码很好地做到这一点，但是，在前端世界中，等式中缺少了一大块，即表示层——UI。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/bd35d7ceb062916687421ade09510f3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Mn6kKmMnvZ1ualqI"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">哈尔·盖特伍德在<a class="ae lb" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="3ce1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">UI与其他层有些不同。首先，意识到UI需要被分成单元需要时间。回到普通或JQuery时代，html在页面上是平面的，我们使用javascript应用行为，这在当时是最好的事情。它具有某种可重用性，但是该单元没有公开任何高级API。该装置的任何重大改变都需要得到消费者的支持。</p><p id="379f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如今，我们使用框架或库，如Angular、React、Vue、Elm或任何现有的东西。我们使用高级API创建组件，这些组件可以从项目中提取或在模块中创建，因此任何web应用程序都可以重用。实际上不是任何网络应用。只有那些使用相同框架作为组件的人。如果您想将组件暴露给所有框架，您需要将所有内容提取到本机核心层，然后再用特定的框架实现进行包装。核心中的每一个变化都需要反映在所有的实现中。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi lc"><img src="../Images/f4f20e89f9e95f61cceed7200e86bb63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wRc5Tu9otAT4GtYx"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">照片由<a class="ae lb" href="https://unsplash.com/@nate_dumlao?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">内森·杜姆劳</a>在<a class="ae lb" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="43e6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">拯救世界的Web组件。“web组件是一套不同的技术，允许您创建可重复使用的自定义元素，将它们的功能封装在代码的其余部分之外，并在您的Web应用程序中使用它们”——MDN。有了web组件，我们可以用高级API创建可重用的UI，而不用考虑使用它的框架。框架与web组件一起工作，就像它们与常规的本地html元素(如输入和按钮)一起工作一样。</p><p id="1470" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Web组件标准由4部分组成:HTML模板，允许重用较小的HTML部分；HTML导入，允许将HTML部分分成不同的单元；影子DOM，允许隔离组件样式和行为；以及自定义元素，将所有内容打包在一起，并公开高级API。</p><p id="35b1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所有未知元素在DOM树中显示为HTMLUnknownElement类型，没有脚本、样式和结构。要创建一个web组件，我们需要注册一个带有标记名的自定义元素，并实现一个扩展HTMLElement的类，该类将添加脚本、样式和结构。</p><p id="74b1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了注册一个新的定制元素，我们使用customElements API:</p><pre class="km kn ko kp gt ld le lf lg aw lh bi"><span id="25cc" class="li lj iq le b gy lk ll l lm ln">customElements.define(‘word-count’, WordCount);</span></pre><p id="68fe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当使用word-count时，WordCount的一个新实例将被实例化并附加到元素上。WordCount将计算给定的文本属性中的单词数，并显示自定义消息。要显示自定义消息，我们需要创建一个影子DOM来保存消息，然后构建消息本身并将其添加到影子DOM中。</p><p id="b695" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要在自定义元素类contractor中创建影子DOM，请执行以下操作:</p><pre class="km kn ko kp gt ld le lf lg aw lh bi"><span id="b86e" class="li lj iq le b gy lk ll l lm ln">const shadow = this.attachShadow({ mode: ‘open’ });```</span></pre><p id="a02f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了创建初始的HTML结构，我们创建了一个单独的文件，该文件将使用HTML import加载。在该文件中，我们声明了一个要在组件中实例化的HTML模板。DOM查询无法访问HTML模板，并且模板中的脚本将不会运行，直到我们加载模板以保留我们努力实现的封装。在模板中创建了一个style标签，它只影响shadow DOM中的元素。Slot元素充当light DOM的占位符。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="b0c8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在实现中，我们有样式定义、带有两个槽的标题部分(一个命名，另一个不命名)和定制元素。slot标签中的值是默认值—如果使用者不指定任何值，将会显示这些值。</p><p id="4b54" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了使用HTML导入加载HTML文件，我们将添加一个新的链接标签，如下所示:</p><pre class="km kn ko kp gt ld le lf lg aw lh bi"><span id="5625" class="li lj iq le b gy lk ll l lm ln">&lt;link rel=”import” href=”word-count/word-count.html” id=”word-count-link”&gt;</span></pre><p id="e591" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">rel="import "告诉浏览器我们将使用HTML import加载文件。浏览器将以非阻塞的方式下载文件，并确保它不会加载超过一次。要加载文件并使用其内容，我们可以在文件底部添加一段代码，将它添加到文档中，或者我们可以手动加载它并在我们的代码中使用它。我们将手动加载它，因为我们希望保留封装，并且不希望将数据泄漏到全局范围内。</p><p id="ab12" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要加载文件并实例化模板:</p><pre class="km kn ko kp gt ld le lf lg aw lh bi"><span id="4c4d" class="li lj iq le b gy lk ll l lm ln">const shadow = this.attachShadow({ mode: ‘open’ });</span><span id="25ce" class="li lj iq le b gy lq ll l lm ln">const wordCountLink = document.getElementById(‘word-count-link’) as HTMLLinkElement;</span><span id="1f9a" class="li lj iq le b gy lq ll l lm ln">const wordCountFile = wordCountLink.import as any;</span><span id="d34f" class="li lj iq le b gy lq ll l lm ln">const templateWordCount = wordCountFile.getElementById(‘template-word-count’);</span><span id="aff2" class="li lj iq le b gy lq ll l lm ln">shadow.appendChild(document.importNode(templateWordCount.content, true));</span></pre><p id="1fa4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这里，我们创建一个影子DOM，获取link元素，导入文件，查询模板的导入内容，并使用document.importNode实例化模板，这将创建模板的深层副本。</p><p id="392f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了计算给定文本中的字数，我们需要读取文本属性并相应地更改DOM。我们还需要使DOM与文本属性的每次变化保持一致。我们可以使用attributeChangedCallback回调，它将在每次属性改变时触发。attributeChangedCallback是我们可以用于web组件四个生命周期事件之一。其他的有connectedCallback、disconnectedCallback和adoptedCallback。attributeChangedCallback将仅针对我们将在observedAttributes静态属性中声明的属性触发。要访问影子DOM，我们可以使用this.shadowRoot。</p><p id="5002" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是WordCounter的完整实现:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="588c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了把所有的东西组合在一起，我们可以使用任何我们想要的框架。所有的框架和库都能够使用自定义元素和它的API，就像它们处理本地元素一样，比如输入和按钮。例如，这里的text属性是我们的高级API，我们将更改它以影响组件。</p><p id="76de" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用React类和MobX:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="0717" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">变化的基本流程非常简单。当输入字段发生变化时，赋予自定义组件的文本属性也会发生变化。在我们的自定义组件中，因为observedAttributes返回“text”，所以attributeChangedCallback触发并调用updateWordCount来获取。词和。对容器进行字数统计，并用正确的值更新它们的innerText。</p><p id="c671" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Web组件是一个好主意，但并不是一切都是光明的。前端世界最大的问题之一也发生在这里——浏览器支持。并非所有主流浏览器都支持web组件。我们仍然需要加载polyfills来使用它们。此外，polyfills不能填充所有内容。例如，影子DOM封装无法修复，所以我们仍然需要小心自定义样式、脚本和id。未来还在后头。</p><p id="f804" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">编辑:要了解今天如何使用聚合物构建web组件，请阅读我的下一篇文章。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/7df73ca65c8f419e36dbfb5b02a38a4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wAHdS1fqNuB1qP40"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">由<a class="ae lb" href="https://unsplash.com/@provenwong?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Ryan Wong </a>在<a class="ae lb" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure></div></div>    
</body>
</html>