<html>
<head>
<title>Background workers in .NET Core</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">背景工人在。网络核心</h1>
<blockquote>原文：<a href="https://itnext.io/background-workers-in-net-core-api-f6fac7a5477f?source=collection_archive---------0-----------------------#2020-06-11">https://itnext.io/background-workers-in-net-core-api-f6fac7a5477f?source=collection_archive---------0-----------------------#2020-06-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/7d4b923419abf0160bd20a442a085a5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rnwVF2lMnkNpMU99g6Gjmg.jpeg"/></div></div></figure><h1 id="5dd5" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">介绍</h1><p id="0189" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">您是否曾经测试过一个端点，并且您对自己说:“……这个代码很慢”？</p><p id="1068" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">不用担心后台队列和<code class="fe mc md me mf b">202 Accepted</code>都在这里！</p><p id="40a7" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">玩笑归玩笑，有时会发生这样的情况，一个端点必须做很多工作，而用户并不立即需要这些工作的结果，然而，应用程序会被阻止，直到API返回一个响应，导致你<em class="mg">和</em>你的用户不高兴！</p><p id="9fb3" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">对此的解决方案之一是将工作交给后台工作人员，并直接将<code class="fe mc md me mf b">202 Accepted</code>返回给客户端。<br/>这样，他们几乎可以立即看到类似<strong class="lb iu">“我们正在努力”</strong>的消息，并继续使用应用程序。</p><h1 id="be01" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">现实生活中的例子</h1><p id="7398" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">另一个例子，我最近不得不自己处理并通过<em class="mg">后台工作人员</em>解决的，是当用户对某个<em class="mg">实体</em>进行更改时，需要做一点工作来查看<em class="mg">到底是谁通知</em>这个更改(通过<a class="ae mh" href="https://dotnet.microsoft.com/apps/aspnet/signalr" rel="noopener ugc nofollow" target="_blank"> <em class="mg"> SignalR </em> </a>)。这根本不需要花半分钟来找出要通知哪些组，但是可能要花2-3秒来完成这个计算，足以让用户非常恼火。</p><p id="daa4" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">这样做的问题(除了速度慢之外)是，这对最初请求更改的用户来说并不真正有用，他们为什么要关心通知的是谁呢？他们最终不得不多等几秒钟，因为API正忙于通知人们。</p><p id="df9c" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">我解决这个问题的方法如下:</p><figure class="mj mk ml mm gt ju gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/60a7c1489c67a8aef8d931ab9d70518f.png" data-original-src="https://miro.medium.com/v2/resize:fit:922/format:webp/1*_KM98JXbwuSGFciRaesbQQ.png"/></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">表示将一些工作卸载到队列的请求流的图表。</figcaption></figure><p id="4d99" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">在本例中，我们看到客户端发送了一个请求，请求更改书名<strong class="lb iu"> (#1) </strong>。API接收这个请求并更新实体<strong class="lb iu"> (#2) </strong>。<br/>然后，从我们的<a class="ae mh" href="https://docs.microsoft.com/en-us/aspnet/core/mvc/controllers/routing?view=aspnetcore-3.1#action-definition" rel="noopener ugc nofollow" target="_blank">动作</a>，我们<strong class="lb iu">将一个<strong class="lb iu">实体的</strong> <strong class="lb iu"> Id (#3) </strong>入队</strong>。一旦入队，我们返回一个<strong class="lb iu"> 200 OK </strong>给客户端<strong class="lb iu"> (#4) </strong>。</p><p id="138a" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">现在，客户端会收到更新后的实体的响应，并可以继续使用该应用程序。<br/>现在，我们想<em class="mg">通过SignalR通知</em>用户这个变化<em class="mg">。</em></p><p id="30ad" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">后台工作者<strong class="lb iu">是</strong> <strong class="lb iu">每隔X时间</strong>检查一些工作要做。它将使任务出队并开始处理它。<strong class="lb iu"> (#5) </strong></p><h1 id="d919" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">翻译成代码</h1><p id="1820" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">"这一切都很好，但如何转化为一个实际的项目？"，我听到你说。</p><p id="d16c" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">好吧，让我们建立一个简单的例子，它遵循与上图相同的流程。</p><p id="4da3" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">假设我们在<code class="fe mc md me mf b">/books/publish</code>有一个端点，它获取一本书，将其写到数据库，然后通知全世界的每个人这本书已经出版了。<br/>这里肯定有一些繁重的工作要做，我们不希望我们可怜的发布者刚刚按下了“<em class="mg">Submit”</em>就必须等待半个小时才能完成所有这些工作。</p><p id="1d62" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">因此，让我们将这项工作卸载到一个队列中！</p><p id="39fa" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">我们可以通过运行:<br/> <code class="fe mc md me mf b">dotnet new mvc -o BackgroundQueue/</code> <br/>来生成一个示例项目。这将生成一个新的项目，我们可以在其中设置我们的<em class="mg">队列</em>。</p><h2 id="b431" class="mr kc it bd kd ms mt dn kh mu mv dp kl lk mw mx kp lo my mz kt ls na nb kx nc bi translated">队列</h2><p id="c8dd" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">首先，我们将实现一个专门用于这些后台任务的队列。</p><p id="cdfa" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">我们将制作一个接口<code class="fe mc md me mf b">IBackgroundQueue&lt;T&gt;</code>，它可以在我们的应用程序中注入。</p><figure class="mj mk ml mm gt ju"><div class="bz fp l di"><div class="nd ne l"/></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">IBackrgoundQueue <t>接口</t></figcaption></figure><p id="d804" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">随着其实施:</p><figure class="mj mk ml mm gt ju"><div class="bz fp l di"><div class="nd ne l"/></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">背景队列<t>实现</t></figcaption></figure><p id="6068" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">如你所见，这是一个非常简单的实现，只有<code class="fe mc md me mf b">Enqueue</code>和<code class="fe mc md me mf b">Dequeue</code>任务，这对我们来说很好。使用<br/>并发队列&lt; T &gt; 是因为该队列将被多个线程访问，并将为我们提供一些线程安全。</p><p id="aa09" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">我们已经可以将这个<code class="fe mc md me mf b">IBackgroundQueue&lt;T&gt;</code>注册为一个服务，在<code class="fe mc md me mf b">Startup.ConfigureServices</code>内部，其中<code class="fe mc md me mf b">T</code>属于<code class="fe mc md me mf b">Book</code>类型，如下所示:</p><figure class="mj mk ml mm gt ju"><div class="bz fp l di"><div class="nd ne l"/></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">将队列注册为单例队列</figcaption></figure><h2 id="7e7d" class="mr kc it bd kd ms mt dn kh mu mv dp kl lk mw mx kp lo my mz kt ls na nb kx nc bi translated">工人</h2><p id="c8ba" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">为了设置worker，我们可以创建一个继承自<code class="fe mc md me mf b"><a class="ae mh" href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.hosting.backgroundservice?view=dotnet-plat-ext-3.1" rel="noopener ugc nofollow" target="_blank">Microsoft.Extensions.Hosting.BackgroundService</a></code>的新类<code class="fe mc md me mf b">BackgroundWorker</code>。</p><p id="9a72" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">我们使用<code class="fe mc md me mf b">BackgroundService</code>而不是<code class="fe mc md me mf b"><a class="ae mh" href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.hosting.ihostedservice?view=dotnet-plat-ext-3.1" rel="noopener ugc nofollow" target="_blank">IHostedService</a> </code>，因为BackgroundService是继承自<strong class="lb iu"> IHostedService </strong>的<strong class="lb iu">基类</strong>，专门为IHostedService的<strong class="lb iu">长期运行的</strong>实现而设计。</p><p id="b0fb" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">让我们从服务的构造器开始。</p><p id="5119" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">我们将需要:<br/> 1。访问我们包含将要出版的书籍的队列<br/> 2。处理书籍出版的服务。一些日志，只是为了让我们可以看到屏幕上发生的奇迹。</p><figure class="mj mk ml mm gt ju"><div class="bz fp l di"><div class="nd ne l"/></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">工人的构造者</figcaption></figure><p id="da4b" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">这里你可以看到我们想要我们的<code class="fe mc md me mf b">IBackgroundQueue&lt;Book&gt;</code>、一个<code class="fe mc md me mf b">IServiceScopeFactory</code>和一个<code class="fe mc md me mf b">ILogger&lt;BackgroundWorker&gt; </code>被注入。</p><p id="fe7d" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">我们稍后将进入<em class="mg"> IServiceScopeFactory </em>。</p><p id="61a1" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">服务的实际实现将是这样的:</p><ol class=""><li id="1553" class="nf ng it lb b lc lx lg ly lk nh lo ni ls nj lw nk nl nm nn bi translated">进入一个循环，只要<em class="mg">取消</em>没有被请求，该循环就一直运行</li><li id="ddfd" class="nf ng it lb b lc no lg np lk nq lo nr ls ns lw nk nl nm nn bi translated">等待<em class="mg"> n </em>秒，然后检查<em class="mg">队列</em>中是否有图书等待出版。</li><li id="1470" class="nf ng it lb b lc no lg np lk nq lo nr ls ns lw nk nl nm nn bi translated">如果找到了一本书，把它交给<em class="mg">出版服务</em>。</li></ol><p id="1bcf" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">完整worker的实现如下所示:</p><figure class="mj mk ml mm gt ju"><div class="bz fp l di"><div class="nd ne l"/></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">后台工作人员</figcaption></figure><p id="ff8c" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">我们实现了<code class="fe mc md me mf b">ExecuteAsync(CancellationToken)</code>和<code class="fe mc md me mf b">StopAsync(CancellationToken)</code>，其中<em class="mg"> ExecuteAsync </em>简单地调用后台处理循环，而<em class="mg"> StopAsync </em>调用基础方法。<br/> <strong class="lb iu">注:</strong> <em class="mg">主机启动时调用ExecuteAsync </em>，发生<em class="mg">主机关机</em>时调用<em class="mg"> StopAsync </em>。</p><p id="54ec" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">你可能想知道为什么我们调用<code class="fe mc md me mf b">Task.Delay</code>，这是因为如果不进行这个调用，即使只是等待0.1秒，我们也会每隔几纳秒检查一次队列，很可能会导致你的API冻结。当然，这个等待时间可以更长或更短，这取决于您的需要。</p><p id="ddf4" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">在BackgroundProcessing内部，一切都像上面描述的那样发生。除了在<strong class="lb iu">第45行，</strong>我们在using-block内部创建了一个<code class="fe mc md me mf b">IServiceScope</code>。<br/>我们这样做的原因是<code class="fe mc md me mf b">IBookPublisher</code>是一个<em class="mg">作用域服务</em>(每个请求一个实例)，而我们的后台工作者是一个<em class="mg">单体</em>(整个应用程序中一个实例)。例如，BookPublisher使用一个实体框架<em class="mg"> DbContext。</em>在这种情况下，我们希望每次发布图书时都创建一个作用域，以避免我们的DbContext使用陈旧的数据或其他作用域服务可能出现的任何奇怪行为。<br/>当我们调用<code class="fe mc md me mf b">scope.ServiceProvider.GetRequiredService&lt;IBookPublisher&gt;()</code>时，我们不仅创建了一个新的<code class="fe mc md me mf b">IBookPublisher</code>，我们还创建了图书出版商所依赖的所有服务，以及这些服务所依赖的所有服务等等……(自上而下)</p><p id="f31f" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">我们现在可以像这样在<code class="fe mc md me mf b">Startup.cs</code>中添加BackgroundService:</p><figure class="mj mk ml mm gt ju"><div class="bz fp l di"><div class="nd ne l"/></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">将BackgroundWorker注册为托管服务。</figcaption></figure><h2 id="60c4" class="mr kc it bd kd ms mt dn kh mu mv dp kl lk mw mx kp lo my mz kt ls na nb kx nc bi translated">让工人完成工作</h2><p id="f321" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">写完所有这些代码后，我们将想让我们的工人做一些实际的<em class="mg">工作</em>，我们将不得不添加一些书到队列中！</p><p id="24de" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">因此，让我们创建一个端点为<code class="fe mc md me mf b">Publish</code>的<code class="fe mc md me mf b">BooksController</code>，它获取一本书并将其传递给队列！</p><figure class="mj mk ml mm gt ju"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="e875" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">这里有一个非常简单的控制器，它注入我们的<em class="mg">队列</em>，有一个<em class="mg"> HttpPost </em>动作，如上所述。</p><p id="eeab" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">现在，当张贴到队列中时，500毫秒后，工作人员将拿起这本书并出版它！</p><pre class="mj mk ml mm gt nt mf nu nv aw nw bi"><span id="3916" class="mr kc it mf b gy nx ny l nz oa">info: BackgroundWorker is now running in the background.<br/>info: Book found! Starting to process ..<br/>info: Doing heavy publishing logic ...<br/>info: "Background Queues in .NET Core by Jelle Verheyen" has been published!</span></pre><h1 id="c4be" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">结论</h1><p id="fa8e" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">非常感谢你阅读这个故事！如果你喜欢它，请随意给这篇文章鼓掌和/或给我一个关注！<br/>这里 的Github <a class="ae mh" href="https://github.com/jelleverheyen/backgroundqueue-example" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">上有一个资源库，里面有源代码。<br/>克隆:<strong class="lb iu"> <em class="mg"> git克隆</em></strong><a class="ae mh" href="https://github.com/jelleverheyen/backgroundqueue-example.git" rel="noopener ugc nofollow" target="_blank"><strong class="lb iu"><em class="mg">https://github . com/jelleverheyen/background queue-example . git</em></strong></a></strong></a></p><p id="22d6" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">你可以随意看看我的其他故事！</p><ul class=""><li id="4643" class="nf ng it lb b lc lx lg ly lk nh lo ni ls nj lw ob nl nm nn bi translated"><a class="ae mh" href="https://medium.com/faun/continuous-integration-with-net-core-and-gitlab-5cd51161c072" rel="noopener">同<strong class="lb iu">不断融合。NET Core和Gitlab </strong> </a></li><li id="c023" class="nf ng it lb b lc no lg np lk nq lo nr ls ns lw ob nl nm nn bi translated"><a class="ae mh" href="https://medium.com/faun/building-a-docker-image-with-gitlab-ci-and-net-core-8f59681a86c4" rel="noopener"> <strong class="lb iu">用Gitlab CI和构建docker映像。网芯</strong> </a></li><li id="0de2" class="nf ng it lb b lc no lg np lk nq lo nr ls ns lw ob nl nm nn bi translated"><a class="ae mh" href="https://medium.com/@jelleverheyen/automatically-handle-exceptions-in-dotnet-core-api-2090d2e574dd" rel="noopener"> <strong class="lb iu">自动处理异常。NET核心API </strong> </a></li></ul></div></div>    
</body>
</html>