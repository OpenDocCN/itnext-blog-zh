<html>
<head>
<title>Building a Calculator App in Flutter</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Flutter中构建计算器应用程序</h1>
<blockquote>原文：<a href="https://itnext.io/building-a-calculator-app-in-flutter-824254704fe6?source=collection_archive---------0-----------------------#2019-08-21">https://itnext.io/building-a-calculator-app-in-flutter-824254704fe6?source=collection_archive---------0-----------------------#2019-08-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="74f8" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何用Dart和Flutter构建一个简单的计算器app</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/bded180ae0522b817fdbe3c8719666bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Yi-jDdOsVFH_7yHivLoJAQ.gif"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">运行中的计算器的屏幕记录</figcaption></figure><h2 id="452d" class="ky kz it bd la lb lc dn ld le lf dp lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">介绍</h2><p id="d320" class="pw-post-body-paragraph lu lv it lw b lx ly ju lz ma mb jx mc lh md me mf ll mg mh mi lp mj mk ml mm im bi mn translated"><span class="l mo mp mq bm mr ms mt mu mv di">在</span>这篇文章中，我们将看看如何用<a class="ae mw" href="https://dart.dev" rel="noopener ugc nofollow" target="_blank">镖</a>和<a class="ae mw" href="https://flutter.dev" rel="noopener ugc nofollow" target="_blank">扑</a>设计和构建一个简单的计算器应用程序。Dart语言和Flutter SDK中可用的优秀特性为现代开发人员提供了一个快速尝试新想法和构建高性能应用程序的绝佳平台。</p><p id="0fa4" class="pw-post-body-paragraph lu lv it lw b lx mx ju lz ma my jx mc lh mz me mf ll na mh mi lp nb mk ml mm im bi translated">这个基本的计算器应用程序将结合一个简单的用户界面，一些标准的操作和功能，以及显示结果的输出。因此，它是一个很好的入门应用程序，或者是另一个基本应用程序的模板。</p><p id="227a" class="pw-post-body-paragraph lu lv it lw b lx mx ju lz ma my jx mc lh mz me mf ll na mh mi lp nb mk ml mm im bi translated">这个项目的源代码可以在GitHub 的<a class="ae mw" href="https://github.com/kenreilly/flutter-calculator-demo" rel="noopener ugc nofollow" target="_blank">这里找到。</a></p></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h2 id="82dd" class="ky kz it bd la lb lc dn ld le lf dp lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">入门指南</h2><p id="5f59" class="pw-post-body-paragraph lu lv it lw b lx ly ju lz ma mb jx mc lh md me mf ll mg mh mi lp mj mk ml mm im bi translated">此应用程序的项目是使用<code class="fe nj nk nl nm b">flutter create</code>初始化的，没有附加的包或依赖项。所有功能都是通过简单的省道和扑动以一种干净和健壮的方式实现的。</p><p id="814b" class="pw-post-body-paragraph lu lv it lw b lx mx ju lz ma my jx mc lh mz me mf ll na mh mi lp nb mk ml mm im bi translated">利用内置语言和SDK特性，可以使应用架构尽可能保持精简和高效。这意味着更快的项目周转、更快的应用程序二进制文件，以及更少的技术债务。</p><p id="b99a" class="pw-post-body-paragraph lu lv it lw b lx mx ju lz ma my jx mc lh mz me mf ll na mh mi lp nb mk ml mm im bi translated">要构建或创建一个类似的项目，需要以下工具:</p><ul class=""><li id="ad23" class="nn no it lw b lx mx ma my lh np ll nq lp nr mm ns nt nu nv bi translated"><a class="ae mw" href="https://dart.dev/get-dart" rel="noopener ugc nofollow" target="_blank">省道</a></li><li id="80a1" class="nn no it lw b lx nw ma nx lh ny ll nz lp oa mm ns nt nu nv bi translated"><a class="ae mw" href="https://flutter.dev/docs/get-started/install" rel="noopener ugc nofollow" target="_blank">颤振SDK </a></li></ul></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h2 id="8be8" class="ky kz it bd la lb lc dn ld le lf dp lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">应用程序入口点</h2><p id="7d0a" class="pw-post-body-paragraph lu lv it lw b lx ly ju lz ma mb jx mc lh md me mf ll mg mh mi lp mj mk ml mm im bi translated">这个标准颤振项目的应用入口点是<strong class="lw iu"> lib/main.dart </strong>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="820a" class="pw-post-body-paragraph lu lv it lw b lx mx ju lz ma my jx mc lh mz me mf ll na mh mi lp nb mk ml mm im bi translated"><em class="od"> main </em>函数将设备锁定为纵向模式，然后运行主应用程序类<strong class="lw iu"> CalculatorApp </strong>，它构建了一个<a class="ae mw" href="https://www.google.com/search?client=safari&amp;rls=en&amp;q=flutter+materialapp&amp;ie=UTF-8&amp;oe=UTF-8" rel="noopener ugc nofollow" target="_blank"> MaterialApp </a>，其主页被设置为<strong class="lw iu"> Calculator </strong>的一个实例，我们接下来将对此进行研究。</p></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h2 id="95f9" class="ky kz it bd la lb lc dn ld le lf dp lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated"><strong class="ak">计算器类</strong></h2><p id="5ac3" class="pw-post-body-paragraph lu lv it lw b lx ly ju lz ma mb jx mc lh md me mf ll mg mh mi lp mj mk ml mm im bi translated">计算器的主UX在<strong class="lw iu"> lib/calculator.dart: </strong>中定义</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="c5da" class="pw-post-body-paragraph lu lv it lw b lx mx ju lz ma my jx mc lh mz me mf ll na mh mi lp nb mk ml mm im bi translated"><strong class="lw iu">计算器</strong>类是一个<a class="ae mw" href="https://api.flutter.dev/flutter/widgets/StatefulWidget-class.html" rel="noopener ugc nofollow" target="_blank"> StatefulWidget </a>，它为应用程序UI搭建了脚手架。它还将按键转发给<strong class="lw iu">处理器</strong>，同时接收要显示的返回数据。这是通过使用<a class="ae mw" href="https://api.flutter.dev/flutter/dart-async/Stream-class.html" rel="noopener ugc nofollow" target="_blank">流</a>在组件之间传递消息来实现的。</p><p id="498a" class="pw-post-body-paragraph lu lv it lw b lx mx ju lz ma my jx mc lh mz me mf ll na mh mi lp nb mk ml mm im bi translated">通过调用更新的<em class="od"> setState </em>来更新显示输出，其他一切都通过触发<strong class="lw iu">键盘</strong>、<strong class="lw iu">按键控制器</strong>、<strong class="lw iu">计算器</strong>和<strong class="lw iu">处理器</strong>类之间的异步事件数据来进行。这确保了预期的信息流，并有助于防止竞态条件和其他问题。</p><p id="49ec" class="pw-post-body-paragraph lu lv it lw b lx mx ju lz ma my jx mc lh mz me mf ll na mh mi lp nb mk ml mm im bi translated">在<em class="od">构建</em>方法中，按钮大小是通过将屏幕宽度除以按钮数量来计算的，而<strong class="lw iu">显示屏的高度</strong>是通过从设备屏幕高度中减去一个五按钮栏的高度(小键盘的高度)来计算的。</p></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h2 id="cc98" class="ky kz it bd la lb lc dn ld le lf dp lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">显示部件</h2><p id="a36a" class="pw-post-body-paragraph lu lv it lw b lx ly ju lz ma mb jx mc lh md me mf ll mg mh mi lp mj mk ml mm im bi translated">我们要看的下一个文件是计算器显示，<strong class="lw iu"> lib/display.dart </strong>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="709e" class="pw-post-body-paragraph lu lv it lw b lx mx ju lz ma my jx mc lh mz me mf ll na mh mi lp nb mk ml mm im bi translated">Display类是StatelessWidget的基本实现，在构造函数中设置了<em class="od">值</em>和<em class="od">高度</em>。背景设置为线性渐变，并且<em class="od">值</em>在显示屏的右上角显示为文本。</p></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h2 id="f7e9" class="ky kz it bd la lb lc dn ld le lf dp lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">键盘小工具</h2><p id="2755" class="pw-post-body-paragraph lu lv it lw b lx ly ju lz ma mb jx mc lh md me mf ll mg mh mi lp mj mk ml mm im bi translated">接下来是<strong class="lw iu"> lib/key-pad.dart </strong>中的计算器键盘部件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="6432" class="pw-post-body-paragraph lu lv it lw b lx mx ju lz ma my jx mc lh mz me mf ll na mh mi lp nb mk ml mm im bi translated"><strong class="lw iu">小键盘</strong>小部件构建了一个五行四项的列，最后一行只有三项，以允许<code class="fe nj nk nl nm b">0</code>键占用两个空格。这些键在keys类中被明确定义<a class="ae mw" href="https://medium.com/@kennethreilly/coding-with-intention-d1d61f5add20" rel="noopener">并在这里和整个应用程序中被引用。</a></p></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h2 id="e470" class="ky kz it bd la lb lc dn ld le lf dp lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">KeySymbol类</h2><p id="c077" class="pw-post-body-paragraph lu lv it lw b lx ly ju lz ma mb jx mc lh md me mf ll mg mh mi lp mj mk ml mm im bi translated">键盘逻辑背后的第一个概念可在<strong class="lw iu"> lib/key-symbol.dart </strong>中找到:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="36f0" class="pw-post-body-paragraph lu lv it lw b lx mx ju lz ma my jx mc lh mz me mf ll na mh mi lp nb mk ml mm im bi translated"><strong class="lw iu"> KeySymbol </strong>类充当按键符号的包装器，比如<code class="fe nj nk nl nm b">+</code>和<code class="fe nj nk nl nm b">-</code>符号，以及一位数(作为字符串)。在这个类中定义了一个列表，其中哪些键是<em class="od">功能键</em>，哪些是<em class="od">操作键</em>，不同之处在于功能键以某种方式改变计算的状态，而<em class="od">操作键</em>执行数学运算(如除法和乘法)。get访问器<code class="fe nj nk nl nm b"><em class="od">type</em></code> <em class="od"> </em>根据是否在<em class="od"> _functions </em>或<em class="od"> _operators </em>列表中找到自己，返回键的类型是<em class="od">函数</em>、<em class="od">运算符</em>还是<em class="od">整数</em>(如果都不是，则为<em class="od">整数</em>)。</p></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h2 id="ba5c" class="ky kz it bd la lb lc dn ld le lf dp lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">计算器键小部件</h2><p id="1fd7" class="pw-post-body-paragraph lu lv it lw b lx ly ju lz ma mb jx mc lh md me mf ll mg mh mi lp mj mk ml mm im bi translated">现在让我们看看<strong class="lw iu">lib/calculator-key . dart</strong>中的定义:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="d855" class="pw-post-body-paragraph lu lv it lw b lx mx ju lz ma my jx mc lh mz me mf ll na mh mi lp nb mk ml mm im bi translated">该文件中的第一个类是<strong class="lw iu"> Keys </strong>，它是整个应用程序中可用键的列表。键被定义为<strong class="lw iu"> KeySymbol </strong>的实例，它在构造函数中接受键的字符，允许键符号及其对应的对象被定义为常量，这些常量可以在整个应用程序中以面向对象的方式重用。</p><p id="8e03" class="pw-post-body-paragraph lu lv it lw b lx mx ju lz ma my jx mc lh mz me mf ll na mh mi lp nb mk ml mm im bi translated">这个文件中还有一个<strong class="lw iu"> CalculatorKey </strong>类，它是一个无状态的小部件，只接受一个<strong class="lw iu"> KeySymbol </strong>作为它的构造函数。<strong class="lw iu">计算器按键</strong>可以根据其按键类型确定自己的背景颜色和按键宽度。功能键、运算符和整数键有自己的颜色，而零键的宽度是普通键的两倍。</p><p id="c0bd" class="pw-post-body-paragraph lu lv it lw b lx mx ju lz ma my jx mc lh mz me mf ll na mh mi lp nb mk ml mm im bi translated">按键事件通过调用<em class="od"> _fire </em>来处理，它反过来在<strong class="lw iu">按键控制器</strong>上触发事件，按键控制器将事件转发给任何监听其<a class="ae mw" href="https://api.flutter.dev/flutter/dart-async/Stream-class.html" rel="noopener ugc nofollow" target="_blank">流</a>的对象。</p></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h2 id="9191" class="ky kz it bd la lb lc dn ld le lf dp lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">KeyController类</h2><p id="2132" class="pw-post-body-paragraph lu lv it lw b lx ly ju lz ma mb jx mc lh md me mf ll mg mh mi lp mj mk ml mm im bi translated">下一个要检查的文件是<strong class="lw iu"> key-controller.dart: </strong>中的键控制器</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="8410" class="pw-post-body-paragraph lu lv it lw b lx mx ju lz ma my jx mc lh mz me mf ll na mh mi lp nb mk ml mm im bi translated">这个文件中有两个类:</p><ul class=""><li id="1a25" class="nn no it lw b lx mx ma my lh np ll nq lp nr mm ns nt nu nv bi translated"><strong class="lw iu"> KeyEvent ( </strong>包裹了为了方便而按下的<strong class="lw iu">计算器键</strong></li><li id="2ac4" class="nn no it lw b lx nw ma nx lh ny ll nz lp oa mm ns nt nu nv bi translated"><strong class="lw iu">按键控制器</strong>(通过<a class="ae mw" href="https://api.flutter.dev/flutter/dart-async/Stream-class.html" rel="noopener ugc nofollow" target="_blank">流</a>和<strong class="lw iu">按键事件</strong>处理按键事件消息)</li></ul><p id="eb91" class="pw-post-body-paragraph lu lv it lw b lx mx ju lz ma my jx mc lh mz me mf ll na mh mi lp nb mk ml mm im bi translated"><strong class="lw iu"> KeyController </strong>设置了<a class="ae mw" href="https://api.flutter.dev/flutter/dart-async/StreamController-class.html" rel="noopener ugc nofollow" target="_blank"> StreamController </a>的本地实例和对其内部流的引用，并公开了三个方法:</p><ul class=""><li id="4d0b" class="nn no it lw b lx mx ma my lh np ll nq lp nr mm ns nt nu nv bi translated"><em class="od">监听</em>(允许一个对象订阅<strong class="lw iu">按键事件</strong>消息)</li><li id="99ee" class="nn no it lw b lx nw ma nx lh ny ll nz lp oa mm ns nt nu nv bi translated"><em class="od"> fire </em>(允许一个对象向下游发送<strong class="lw iu"> KeyEvent </strong>消息)</li><li id="aff1" class="nn no it lw b lx nw ma nx lh ny ll nz lp oa mm ns nt nu nv bi translated"><em class="od"> dispose </em>(允许应用程序优雅地关闭StreamController)</li></ul><p id="ce39" class="pw-post-body-paragraph lu lv it lw b lx mx ju lz ma my jx mc lh mz me mf ll na mh mi lp nb mk ml mm im bi translated">这说明了<a class="ae mw" href="https://en.wikipedia.org/wiki/Publish–subscribe_pattern" rel="noopener ugc nofollow" target="_blank">发布-订阅模式</a>的一个基本例子，其中对组件如何相互连接的关注对于单个组件本身来说是无关紧要的。通过利用流和控制器，只需添加一个额外的组件，让它简单地监听它需要的信息，然后只在必要时调用setState，根据它所监听的事件流传递的新信息修改它自己的状态。同样，可以删除相同的组件，而不会对应用程序的其余部分产生影响，因为无论有没有额外的侦听器，数据都将正确地流过程序的其余部分。</p><p id="b22e" class="pw-post-body-paragraph lu lv it lw b lx mx ju lz ma my jx mc lh mz me mf ll na mh mi lp nb mk ml mm im bi translated">有关Dart中流的异步事件驱动编程的更多信息，请参见<a class="ae mw" href="https://dart.dev/tutorials/language/streams" rel="noopener ugc nofollow" target="_blank">本文档页面</a>。</p></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h2 id="1d33" class="ky kz it bd la lb lc dn ld le lf dp lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">处理器类</h2><p id="afe7" class="pw-post-body-paragraph lu lv it lw b lx ly ju lz ma mb jx mc lh md me mf ll mg mh mi lp mj mk ml mm im bi translated">最后但并非最不重要的是起重要作用的文件，<strong class="lw iu"> processor.dart </strong>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="b129" class="pw-post-body-paragraph lu lv it lw b lx mx ju lz ma my jx mc lh mz me mf ll na mh mi lp nb mk ml mm im bi translated"><strong class="lw iu">处理器</strong>类是处理键盘交互和执行实际计算的大部分逻辑所在。首先，我们在这个类上有四个用于存储输入和输出变量的基本属性:</p><ul class=""><li id="6c8b" class="nn no it lw b lx mx ma my lh np ll nq lp nr mm ns nt nu nv bi translated"><em class="od">_运算符</em>(保存当前请求的数学运算符)</li><li id="5ef2" class="nn no it lw b lx nw ma nx lh ny ll nz lp oa mm ns nt nu nv bi translated"><em class="od"> _valA </em>(保存运算符左侧的操作数)</li><li id="af2f" class="nn no it lw b lx nw ma nx lh ny ll nz lp oa mm ns nt nu nv bi translated"><em class="od"> _valB </em>(持有运算符右侧的操作数)</li><li id="c314" class="nn no it lw b lx nw ma nx lh ny ll nz lp oa mm ns nt nu nv bi translated"><em class="od">_结果</em>(保存上次计算的结果)</li></ul><p id="3d04" class="pw-post-body-paragraph lu lv it lw b lx mx ju lz ma my jx mc lh mz me mf ll na mh mi lp nb mk ml mm im bi translated">在这个类中还有Stream / StreamController的另一个实现，<strong class="lw iu">计算器</strong>类用它来订阅包含更新显示值的消息。这里的主要区别是用下划线前缀声明了<em class="od"> _fire </em>方法，使其成为这个类的私有方法，这是我们所希望的，因为这是计算实际结果值的唯一地方。还有一个方便的方法<em class="od"> refresh </em>，它触发下游的当前输出值，以便监听组件设置状态和更新视图。该方法是公开的，以允许监听组件请求更新，例如当一些初始化过程完成时。</p><p id="77d6" class="pw-post-body-paragraph lu lv it lw b lx mx ju lz ma my jx mc lh mz me mf ll na mh mi lp nb mk ml mm im bi translated">接下来是两个确定显示内容的访问器属性:</p><ul class=""><li id="1669" class="nn no it lw b lx mx ma my lh np ll nq lp nr mm ns nt nu nv bi translated"><em class="od">_输出</em>(如果不是<code class="fe nj nk nl nm b">null</code>，则返回<em class="od">_结果</em>，否则返回<em class="od">_等式</em>)</li><li id="f8c8" class="nn no it lw b lx nw ma nx lh ny ll nz lp oa mm ns nt nu nv bi translated"><em class="od"> _equation </em>(如果_operator就绪，则返回一个等式，否则返回<em class="od"> _valA </em>)</li></ul><p id="fd11" class="pw-post-body-paragraph lu lv it lw b lx mx ju lz ma my jx mc lh mz me mf ll na mh mi lp nb mk ml mm im bi translated">这种链式访问器的组合提供了一种简单的方法来控制计算器的输出，方法是显示上一次计算的<em class="od"> _result </em>，排队等待求解的计算，或者最左边(也是唯一的)的值，这取决于计算器当前所处的状态。</p><p id="9b3a" class="pw-post-body-paragraph lu lv it lw b lx mx ju lz ma my jx mc lh mz me mf ll na mh mi lp nb mk ml mm im bi translated">这个类还有一个<em class="od"> dispose </em>方法，允许应用程序正常关闭。接下来是处理输入按键事件的四个方法:</p><ul class=""><li id="7f14" class="nn no it lw b lx mx ma my lh np ll nq lp nr mm ns nt nu nv bi translated">过程(根据<strong class="lw iu">按键符号</strong>类型选择下一步行动)</li><li id="081b" class="nn no it lw b lx nw ma nx lh ny ll nz lp oa mm ns nt nu nv bi translated">handleFunction(准备在当前状态下执行一些函数)</li><li id="423a" class="nn no it lw b lx nw ma nx lh ny ll nz lp oa mm ns nt nu nv bi translated">handleOperator(将选择的数学运算符分配给<em class="od">_运算符</em></li><li id="da40" class="nn no it lw b lx nw ma nx lh ny ll nz lp oa mm ns nt nu nv bi translated">handleInteger(将键的数值加到适当的操作数上)</li></ul><p id="144f" class="pw-post-body-paragraph lu lv it lw b lx mx ju lz ma my jx mc lh mz me mf ll na mh mi lp nb mk ml mm im bi translated"><em class="od">进程</em>方法是来自<strong class="lw iu">键控制器</strong>的事件被<strong class="lw iu">计算器</strong>转发的地方。这个方法使用按键符号的类型来选择它是否应该调用一个函数、存储一个操作符或者处理数字输入。</p><p id="db23" class="pw-post-body-paragraph lu lv it lw b lx mx ju lz ma my jx mc lh mz me mf ll na mh mi lp nb mk ml mm im bi translated"><em class="od"> handleFunction </em>方法首先检查左操作数(_valA)是否为‘0’，如果是，则丢弃事件。然后，它通过调用<em class="od"> _condense </em>来检查以确定是否应该将前一个等式的结果存储在最左边的操作数中，以允许输入下一个等式。接下来，基于输入的<strong class="lw iu">按键事件的<strong class="lw iu">按键符号</strong>，</strong>和<strong class="lw iu">按键符号</strong>被转发到适当的功能，随后是<em class="od">刷新</em>，功能映射被用于选择所需的功能。这通常比一个巨大的if-else语句链更简洁，这种表达水平是Dart等现代语言的一个重要特征。</p><p id="88ca" class="pw-post-body-paragraph lu lv it lw b lx mx ju lz ma my jx mc lh mz me mf ll na mh mi lp nb mk ml mm im bi translated">当左操作数为‘0’时，<em class="od"> handleOperator </em>方法也会丢弃事件，并在必要时将先前计算的结果存储在左操作数中。然后将选择的操作符存储在<em class="od">_操作符</em>中，并调用<em class="od">刷新</em>。</p><p id="3a5c" class="pw-post-body-paragraph lu lv it lw b lx mx ju lz ma my jx mc lh mz me mf ll na mh mi lp nb mk ml mm im bi translated"><em class="od"> handleInteger </em>方法接收数字输入，如果没有_operator，则将其附加到左侧操作数值，如果_operator有值，则将其附加到右侧操作数值。当完成时，它还调用一个<em class="od">刷新</em>。</p><p id="fd27" class="pw-post-body-paragraph lu lv it lw b lx mx ju lz ma my jx mc lh mz me mf ll na mh mi lp nb mk ml mm im bi translated">该类中的下一组方法处理来自键盘的函数输入，以修改处理器的状态及其值:</p><ul class=""><li id="8683" class="nn no it lw b lx mx ma my lh np ll nq lp nr mm ns nt nu nv bi translated"><em class="od">_清除</em>(重置计算器并调用<em class="od">刷新</em>)</li><li id="f50d" class="nn no it lw b lx nw ma nx lh ny ll nz lp oa mm ns nt nu nv bi translated"><em class="od"> _sign </em>(翻转当前正在接收输入的操作数的符号)</li><li id="7d77" class="nn no it lw b lx nw ma nx lh ny ll nz lp oa mm ns nt nu nv bi translated"><em class="od">_ percent</em>/<em class="od">calc percent</em>(将当前操作数的值除以100)</li><li id="be7b" class="nn no it lw b lx nw ma nx lh ny ll nz lp oa mm ns nt nu nv bi translated"><em class="od"> _decimal </em>(在当前操作数的末尾追加一个小数点)</li><li id="a345" class="nn no it lw b lx nw ma nx lh ny ll nz lp oa mm ns nt nu nv bi translated"><em class="od">_计算</em>(进行实际计算并将结果存储在<em class="od"> _result </em>中)</li><li id="2d54" class="nn no it lw b lx nw ma nx lh ny ll nz lp oa mm ns nt nu nv bi translated"><em class="od"> _condense </em>(将<em class="od"> _result </em>存储在左操作数中，为更多输入做准备)</li></ul><p id="3af8" class="pw-post-body-paragraph lu lv it lw b lx mx ju lz ma my jx mc lh mz me mf ll na mh mi lp nb mk ml mm im bi translated"><em class="od"> _clear </em>方法只是将计算器重置为零。<em class="od"> _sign </em>方法确定要修改哪个操作数，并在它前面添加或删除一个<code class="fe nj nk nl nm b">-</code>字符。<em class="od"> _percent </em>和<em class="od"> _decimal </em>方法的工作方式基本相同，都是选择正确的操作数并在其上执行各自的任务。</p><p id="73c5" class="pw-post-body-paragraph lu lv it lw b lx mx ju lz ma my jx mc lh mz me mf ll na mh mi lp nb mk ml mm im bi translated"><em class="od"> _calculate </em>方法将在没有运算符或右侧值来执行计算时丢弃事件，否则它将利用函数映射来选择使用哪个公式，计算结果，删除任何不重要的尾随零，将值存储在<em class="od"> _result </em>中，并通过调用<em class="od"> refresh </em>来结束。</p></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h2 id="88d3" class="ky kz it bd la lb lc dn ld le lf dp lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">结论</h2><p id="7bf9" class="pw-post-body-paragraph lu lv it lw b lx ly ju lz ma mb jx mc lh md me mf ll mg mh mi lp mj mk ml mm im bi translated">这就结束了我们对这个计算器应用程序的源代码的检查，它可以在GitHub 上作为模板库<a class="ae mw" href="https://github.com/kenreilly/flutter-calculator-demo" rel="noopener ugc nofollow" target="_blank">获得。</a></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/17866c69c2cb05916845eaa7522fcf43.png" data-original-src="https://miro.medium.com/v2/resize:fit:736/1*oVDt-f-ldcOnkMnc_jdgaQ.gif"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">运行中的应用程序的屏幕录制</figcaption></figure><p id="6a9d" class="pw-post-body-paragraph lu lv it lw b lx mx ju lz ma my jx mc lh mz me mf ll na mh mi lp nb mk ml mm im bi translated">这个简单的计算器只用了几百行代码就实现了，并展示了使用Dart和Flutter构建移动应用程序时可用的表达能力，这些应用程序鼓励干净的设计模式、高效的代码重用、显式类型安全和其他良好的开发习惯。</p><p id="38c5" class="pw-post-body-paragraph lu lv it lw b lx mx ju lz ma my jx mc lh mz me mf ll na mh mi lp nb mk ml mm im bi translated">这些特性使Flutter成为构建高质量移动应用程序的绝佳选择，这些应用程序加载和运行速度快，只使用所需的CPU和RAM，不会意外延迟或挂起，并且由于架构和代码简洁，将来可以轻松更新和维护。</p><p id="3205" class="pw-post-body-paragraph lu lv it lw b lx mx ju lz ma my jx mc lh mz me mf ll na mh mi lp nb mk ml mm im bi translated">感谢阅读这篇文章，祝你的下一个颤振项目好运！</p></div></div>    
</body>
</html>