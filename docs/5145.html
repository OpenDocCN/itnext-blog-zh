<html>
<head>
<title>Terragrunt — Becoming one with its internal behaviors</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">terra grunt——与其内部行为融为一体</h1>
<blockquote>原文：<a href="https://itnext.io/terragrunt-becoming-one-with-its-internal-behaviors-9697b6771928?source=collection_archive---------4-----------------------#2020-12-21">https://itnext.io/terragrunt-becoming-one-with-its-internal-behaviors-9697b6771928?source=collection_archive---------4-----------------------#2020-12-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/f1a5ed7aea06ace52af68d5b7935f5f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*htcJj21mduf0TCOL"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">terra grunt——多功能工具</figcaption></figure><p id="f6e4" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">Terragrunt是Terraform的一个小包装器，增加了大量功能。在我以前的文章中，我关注的是能力和以新颖的方式使用它。</p><ul class=""><li id="059b" class="la lb iq ke b kf kg kj kk kn lc kr ld kv le kz lf lg lh li bi translated"><a class="ae lj" rel="noopener ugc nofollow" target="_blank" href="/terragrunt-the-glue-around-terraform-ae15e2addb66">terra grunt——围绕Terraform的胶水</a></li><li id="66b1" class="la lb iq ke b kf lk kj ll kn lm kr ln kv lo kz lf lg lh li bi translated"><a class="ae lj" rel="noopener ugc nofollow" target="_blank" href="/terragrunt-dynamic-remote-state-management-1467a6992693"> Terragrunt —动态远程状态管理</a></li><li id="115a" class="la lb iq ke b kf lk kj ll kn lm kr ln kv lo kz lf lg lh li bi translated"><a class="ae lj" rel="noopener ugc nofollow" target="_blank" href="/terragrunt-inter-module-dependency-management-36528693acdf"> Terragrunt —模块间依赖管理</a></li><li id="ecba" class="la lb iq ke b kf lk kj ll kn lm kr ln kv lo kz lf lg lh li bi translated"><a class="ae lj" href="https://patrick-picard.medium.com/terragrunt-using-credentials-dynamically-and-azure-multi-subscription-support-fa770506c913" rel="noopener">terra grunt——动态使用凭证和Azure多订阅支持</a></li></ul><p id="0af6" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在本文中，我将重点介绍Terragrunt如何实现这些功能。我分享一些经验教训和如何排除故障。首先，我回顾了一个示例分层配置结构、Terragrunt的操作顺序、缓存、源路径捕获和内容生成。</p><h1 id="3e51" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">地形地貌结构</h1><p id="d32d" class="pw-post-body-paragraph kc kd iq ke b kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ij bi translated">让我们从一个两级分层的Terragrunt配置开始。一个<em class="ms"> terragrunt.hcl </em>在子文件夹中，一个在父文件夹中(如果所有子文件夹<strong class="ke ir">都有<em class="ms"> include </em>指令</strong>，那么这个子文件夹将与其共享)。</p><p id="4c33" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">下面的文件夹结构显示了Terragrunt配置的层次结构</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="f7f2" class="nc lq iq my b gy nd ne l nf ng">├── core-iam<br/>│   └── terragrunt.hcl<br/>├── core-organization<br/>│   └── terragrunt.hcl<br/>├── credentials<br/>│   └── terragrunt.hcl<br/>├── log-analytics<br/>│   └── terragrunt.hcl<br/>└── terragrunt.hcl</span></pre><p id="2eaa" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">让我们从<em class="ms">核心组织/terragrunt.hcl </em>开始:</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="10bf" class="nc lq iq my b gy nd ne l nf ng">dependency "credentials" {<br/>  config_path = "../credentials"<br/>}</span><span id="afa3" class="nc lq iq my b gy nh ne l nf ng">terraform {<br/>  source = "git::ssh://<a class="ae lj" href="mailto:git@github.com" rel="noopener ugc nofollow" target="_blank">git@github.com</a>/xxxxxx/terraform-azurerm-core-organization.git"</span><span id="e695" class="nc lq iq my b gy nh ne l nf ng">extra_arguments "force_subscription" {<br/>    commands = [<br/>      "init",<br/>      "apply",<br/>      "destroy",<br/>      "refresh",<br/>      "import",<br/>      "plan",<br/>      "taint",<br/>      "untaint"<br/>    ]</span><span id="d5de" class="nc lq iq my b gy nh ne l nf ng">env_vars = {<br/>      ARM_TENANT_ID     = dependency.credentials.outputs.tenant_id<br/>      ARM_CLIENT_ID     = dependency.credentials.outputs.client_id<br/>      ARM_CLIENT_SECRET = dependency.credentials.outputs.client_secret</span><span id="79fd" class="nc lq iq my b gy nh ne l nf ng"># Need to force a subscription id when logging in as SPN.<br/>      ARM_SUBSCRIPTION_ID = local.config.management.subscription_id<br/>    }<br/>  }<br/>}</span><span id="a164" class="nc lq iq my b gy nh ne l nf ng">locals {<br/>  config = yamldecode(file(format("%s/config.yaml", get_env("AZ_PIPELINE_CONFIG_PATH"))))<br/>}</span><span id="977c" class="nc lq iq my b gy nh ne l nf ng">inputs = {<br/>  root_management_group_name = local.config.global.root_management_group_name<br/>  connectivity_subscription_ids = [<br/>    for sub in local.config.subscriptions.connectivity : sub.id<br/>  ]</span><span id="6f31" class="nc lq iq my b gy nh ne l nf ng">  # Configuration abbreviated<br/>}</span><span id="f809" class="nc lq iq my b gy nh ne l nf ng">include {<br/>  path = find_in_parent_folders()<br/>}</span></pre><p id="4968" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">以及根文件夹<em class="ms"> terragrunt.hcl </em></p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="053b" class="nc lq iq my b gy nd ne l nf ng">locals {<br/>  rscfg = yamldecode(file(find_in_parent_folders("remote_state.yaml")))<br/>}</span><span id="b1ce" class="nc lq iq my b gy nh ne l nf ng">remote_state {<br/>  backend = "azurerm"<br/>  generate = {<br/>    path      = "backend.tf"<br/>    if_exists = "overwrite"<br/>  }<br/>  config = {<br/>    tenant_id       = local.rscfg.remote_state.tenant_id<br/>    subscription_id = local.rscfg.remote_state.subscription_id</span><span id="da24" class="nc lq iq my b gy nh ne l nf ng"><br/>    resource_group_name  = local.rscfg.remote_state.common.resource_group_name<br/>    storage_account_name = local.rscfg.remote_state.common.storage_account_name<br/>    container_name       = local.rscfg.remote_state.common.container_name</span><span id="8f20" class="nc lq iq my b gy nh ne l nf ng">key = "${path_relative_to_include()}/terraform.tfstate"</span><span id="971c" class="nc lq iq my b gy nh ne l nf ng">snapshot = true</span><span id="75b8" class="nc lq iq my b gy nh ne l nf ng">}<br/>}</span><span id="610d" class="nc lq iq my b gy nh ne l nf ng">generate "provider" {<br/>  path      = "provider.tf"<br/>  if_exists = "overwrite"<br/>  contents  = &lt;&lt;EOF<br/>provider "azurerm" {<br/>  version = "~&gt;2.0"<br/>  features {}<br/>}<br/>EOF<br/>}</span></pre><p id="6ee1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在我们已经有了要使用的配置，让我们来看看Terragrunt是如何工作的。</p><h1 id="ce35" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">操作顺序</h1><p id="acd5" class="pw-post-body-paragraph kc kd iq ke b kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ij bi translated">当您运行任何Terragrunt命令(init、plan、apply、destroy)时，它会执行一系列任务；其中一些取决于配置。为了简单起见，让我们使用<em class="ms"> terragrunt计划</em>作为从<em class="ms"> core-organization/ </em>文件夹中执行的动作。</p><p id="766f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">Terragrunt查看当前文件夹<em class="ms"> terragrunt.hcl </em>并遵循其中的所有说明:</p><ul class=""><li id="71ed" class="la lb iq ke b kf kg kj kk kn lc kr ld kv le kz lf lg lh li bi translated">查看每个<em class="ms">依赖关系</em>，确保它们的状态可用</li><li id="cc12" class="la lb iq ke b kf lk kj ll kn lm kr ln kv lo kz lf lg lh li bi translated">初始化在<em class="ms"> terraform.source </em>中定义的模块。Terragrunt自动初始化模块。不需要先运行<em class="ms"> terragrunt init </em>。在这一步，您将看到一个名为<em class="ms">的隐藏文件夹的创建。terragrunt-cache </em>(稍后会有更多细节)。</li><li id="0596" class="la lb iq ke b kf lk kj ll kn lm kr ln kv lo kz lf lg lh li bi translated">物化包含语句。在这种情况下，我们在父文件夹中搜索一个<em class="ms"> terragrunt.hcl </em>。</li><li id="37fe" class="la lb iq ke b kf lk kj ll kn lm kr ln kv lo kz lf lg lh li bi translated">父配置有一个<em class="ms">远程状态</em>和<em class="ms">生成</em>指令。remote_state被评估并动态生成<em class="ms"> backend.tf </em>。这个文件与其他文件一起保存在terragrunt缓存中。tf文件。类似地生成<em class="ms"> provider.tf </em>。</li><li id="6bfa" class="la lb iq ke b kf lk kj ll kn lm kr ln kv lo kz lf lg lh li bi translated">计算局部变量/输入，并且<em class="ms"> extra_arguments </em>生成环境变量。这些信息被传递给Terraform以部署模块。到目前为止，这都是Terragrunt的魔法，控制权交给了terraform。</li></ul><h1 id="84b1" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">。terragrunt-cache</h1><p id="0d70" class="pw-post-body-paragraph kc kd iq ke b kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ij bi translated">Terragrunt使用缓存作为其工作目录。该文件夹对于故障排除至关重要，并且可能是令人头疼的原因(参见下一节)。</p><p id="fa20" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在缓存中，创建类似guid的路径。当您导航到最低级别时，您会注意到一些有趣的事情。</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="4269" class="nc lq iq my b gy nd ne l nf ng">ls -la .terragrunt-cache/OfnG7YSki89VGJUc7uL4eruVFG4/BoxvdZRzDTvrVMxcmMGN5EdtYOU<br/>total 76<br/>drwxr-xr-x 6 patrick patrick 4096 Dec 21 09:43 .<br/>drwxr-xr-x 3 patrick patrick 4096 Dec 18 22:40 ..<br/>drwxr-xr-x 6 patrick patrick 4096 Dec 18 22:40 .git<br/>-rw-r--r-- 1 patrick patrick   64 Dec 18 22:40 .gitignore<br/>-rw-r--r-- 1 patrick patrick  225 Dec 18 22:40 .pre-commit-config.yaml<br/>drwxr-xr-x 4 patrick patrick 4096 Dec 21 09:43 .terraform<br/>-rw-r--r-- 1 patrick patrick  239 Dec 21 09:43 .terragrunt-module-manifest<br/>-rw-r----- 1 patrick patrick   27 Dec 18 22:40 .terragrunt-source-version<br/>-rw-r--r-- 1 patrick patrick 2656 Dec 18 22:40 README.md<br/>-rw-r--r-- 1 patrick patrick  456 Dec 21 09:43 backend.tf<br/>drwxr-xr-x 4 patrick patrick 4096 Dec 18 22:40 examples<br/>-rw-r--r-- 1 patrick patrick 1216 Dec 18 22:40 locals.tf<br/>-rw-r--r-- 1 patrick patrick 1304 Dec 18 22:40 main.tf<br/>-rw-r--r-- 1 patrick patrick 1472 Dec 18 22:40 output.tf<br/>-rw-r--r-- 1 patrick patrick  106 Dec 21 09:43 provider.tf<br/>-rwxr-xr-x 1 patrick patrick 1775 Dec 21 09:43 terragrunt.hcl<br/>drwxr-xr-x 2 patrick patrick 4096 Dec 18 22:40 tests<br/>-rw-r--r-- 1 patrick patrick 1397 Dec 18 22:40 variables.tf<br/>-rw-r--r-- 1 patrick patrick  629 Dec 18 22:40 variables_naming.tf</span></pre><p id="657b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">该文件夹包含被指令<em class="ms"> terraform.module </em>引用的模块中的文件。在<em class="ms">中。terraform </em>文件夹，存储已初始化的依赖关系。还可以看到我们之前生成的<em class="ms"> backend.tf </em>和<em class="ms"> provider.tf </em>。</p><p id="5f96" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">所以如果你不确定你的<em class="ms">远程状态</em>和<em class="ms">生成</em>指令，看看生成的文件！</p><p id="2784" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果您愿意，您可以导航到此文件夹并进行terraform应用。然而，这些输入是不可用的，因为Terragrunt会动态生成这些输入，并且不会将它们具体化为tfvars。</p><p id="5fbe" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">Terragrunt缓存是一个很好的工具，但有时您会遇到与您的配置不一致的行为。销毁缓存是绝对安全的。terragrunt-cache )并重新运行terragrunt来重新生成它。</p><h1 id="2f9b" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">源路径</h1><p id="0fb3" class="pw-post-body-paragraph kc kd iq ke b kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ij bi translated">在第一个配置中，我们使用一个SSH URL定义了一个模块路径，该路径将再次被复制:</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="c30e" class="nc lq iq my b gy nd ne l nf ng">terraform {<br/>  source = "git::ssh://<a class="ae lj" href="mailto:git@github.com" rel="noopener ugc nofollow" target="_blank">git@github.com</a>/xxxxxx/terraform-azurerm-core-organization.git"</span></pre><p id="4bda" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">Terragrunt支持terraform支持的所有路径类型。然而，有一些行为差异值得注意。远程URL(SSH、Github等)被认为是不可变的。一旦Terragrunt缓存了它，它就不会试图再次检索它。也就是说，最好使用版本控制来使URL可变，并在升级模块时强制重新下载。</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="7ff4" class="nc lq iq my b gy nd ne l nf ng">source = "git::ssh://<a class="ae lj" href="mailto:git@github.com" rel="noopener ugc nofollow" target="_blank">git@github.com</a>/xxxxxx/terraform-azurerm-core-organization.git?ref=1.0.1"</span></pre><p id="4408" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">使用相对路径的模块总是在每次运行时刷新。这在使用您正在修改的相关模块进行本地开发时非常有用。</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="3e9e" class="nc lq iq my b gy nd ne l nf ng">source = "../../..//core-organization"</span></pre><p id="71d5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这种行为在<a class="ae lj" href="https://terragrunt.gruntwork.io/docs/features/keep-your-terraform-code-dry/#important-gotcha-terragrunt-caching" rel="noopener ugc nofollow" target="_blank">中有记录</a>，但经常被掩盖。这让我和我的同行们困惑了很多次。你已经被警告了。</p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ni"><img src="../Images/ed3a1acda528c10b830540acbf173bbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YnLy6bj9rUOaVt5cCYLJfw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">相对URL与远程URL</figcaption></figure><h1 id="b23d" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">生成的内容</h1><p id="3e20" class="pw-post-body-paragraph kc kd iq ke b kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ij bi translated">前面，我们看了一个<em class="ms"> remote_state </em>和<em class="ms"> generate </em>指令。这些通知Terragrunt动态创建文件，并保存在Terragrunt缓存中。</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="810d" class="nc lq iq my b gy nd ne l nf ng">generate "provider" {<br/>  path      = "provider.tf"<br/>  if_exists = "overwrite"<br/>  #......<br/>}</span></pre><p id="1c87" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">使用<em class="ms"> if_exists </em>属性来控制内容生成行为。该属性支持3个选项:</p><ul class=""><li id="3e9f" class="la lb iq ke b kf kg kj kk kn lc kr ld kv le kz lf lg lh li bi translated"><strong class="ke ir">覆盖</strong> —生成文件，如果文件已经存在则覆盖</li><li id="7356" class="la lb iq ke b kf lk kj ll kn lm kr ln kv lo kz lf lg lh li bi translated"><strong class="ke ir">跳过</strong> —生成文件，但保留现有文件(如果有的话)</li><li id="b23a" class="la lb iq ke b kf lk kj ll kn lm kr ln kv lo kz lf lg lh li bi translated"><strong class="ke ir">错误</strong> —如果定义了路径的文件已经存在，则错误退出。</li></ul><p id="f329" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我个人更喜欢<em class="ms">覆盖</em>选项，这样我就可以控制了。当Terragrunt生成一个文件时，它在内容中包含一个散列，这样它就知道内容是否在两次运行之间发生了变化(参见Sig:)</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="3bda" class="nc lq iq my b gy nd ne l nf ng"># Generated by Terragrunt. Sig: nIlQXj57tbuaRZEa<br/>provider "azurerm" {<br/>  version = "~&gt;2.0"<br/>  features {}<br/>}</span></pre><p id="304b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我建议您为提供者和后端配置使用一致的名称。例如，如果某人在远程模块中有一个<em class="ms"> providers.tf </em>，而您生成了<em class="ms"> provider.tf </em>，terraform将抱怨重复配置。</p><h1 id="8b92" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">结论</h1><p id="ce6b" class="pw-post-body-paragraph kc kd iq ke b kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ij bi translated">这篇文章中有很多东西需要解释。我分享了很多你使用Terragrunt一段时间后获得的重要知识花絮。其中很多是我从战争伤疤中学到的！与你所使用的工具融为一体是很重要的。</p><p id="2e6c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我分享了一个示例分层配置，展示了Terragrunt在移交给Terraform之前如何执行其“包装”操作..理解terragrunt缓存对于故障排除非常重要，有助于理解terraform模块源和配置生成的行为。</p><p id="e804" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">尽情享受吧！</p></div></div>    
</body>
</html>