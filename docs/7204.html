<html>
<head>
<title>Unix Commands, Pipes, and Processes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Unix命令、管道和进程</h1>
<blockquote>原文：<a href="https://itnext.io/unix-commands-pipes-and-processes-6e22a5fbf749?source=collection_archive---------0-----------------------#2022-07-14">https://itnext.io/unix-commands-pipes-and-processes-6e22a5fbf749?source=collection_archive---------0-----------------------#2022-07-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d9a7" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何把Unix命令和管道结合起来，管理正在运行的程序？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d64ecbe534c724b2d0078172703c4205.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zb0geNhVdJYKDZpalFXopg.png"/></div></div></figure><p id="9fa7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi lq translated">Unix命令行如此强大的原因在于所有的命令都可以很好地协同工作。您可以将命令链接在一起，以便一个命令的输出成为另一个命令的输入。这里有一个这样做的例子。</p><p id="305d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="lz">下载披萨销售数据，转显示三列销售数据。</em></p><pre class="kj kk kl km gt ma mb mc md aw me bi"><span id="52c2" class="mf mg it mb b gy mh mi l mj mk">❯ RDATASETS=https://vincentarelbundock.github.io/Rdatasets/csv<br/><br/>❯ curl -s $RDATASETS/gt/pizzaplace.csv &gt; pizzaplace.csv<br/><br/>❯ cat pizzaplace.csv | tail -10 | cut -d',' -f6-8 |<br/>           tr ',' '\t' | tr -d '"'<br/>S	classic	12<br/>M	supreme	16.5<br/>L	chicken	20.75<br/>M	chicken	16.75<br/>S	supreme	12.5<br/>L	veggie	17.95<br/>S	classic	12<br/>M	chicken	16.75<br/>L	veggie	20.25<br/>S	chicken	12.75</span></pre><p id="0a11" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这个例子中，我们将命令<code class="fe ml mm mn mb b">cat</code>、<code class="fe ml mm mn mb b">tail</code>、<code class="fe ml mm mn mb b">cut</code>和<code class="fe ml mm mn mb b">tr</code>串在一起产生最终输出。我们将在后面详细介绍这些命令以及它们是如何连接在一起的。我讲这个故事的目的是给你一些处理数据的实用技巧:</p><ul class=""><li id="c07f" class="mo mp it kw b kx ky la lb ld mq lh mr ll ms lp mt mu mv mw bi translated">Unix程序如何通过管道连接在一起</li><li id="f66e" class="mo mp it kw b kx mx la my ld mz lh na ll nb lp mt mu mv mw bi translated">用于验证的散列数据</li><li id="6353" class="mo mp it kw b kx mx la my ld mz lh na ll nb lp mt mu mv mw bi translated">管理正在运行的流程</li><li id="eec8" class="mo mp it kw b kx mx la my ld mz lh na ll nb lp mt mu mv mw bi translated">下载数据并进行处理</li></ul><h1 id="8dbf" class="nc mg it bd nd ne nf ng nh ni nj nk nl jz nm ka nn kc no kd np kf nq kg nr ns bi translated">使用Unix管道</h1><p id="7763" class="pw-post-body-paragraph ku kv it kw b kx nt ju kz la nu jx lc ld nv lf lg lh nw lj lk ll nx ln lo lp im bi translated">Unix shell的大部分功能来自管道的存在。为了理解管道，我们需要理解以下I/O概念:</p><ul class=""><li id="3c00" class="mo mp it kw b kx ky la lb ld mq lh mr ll ms lp mt mu mv mw bi translated"><code class="fe ml mm mn mb b">stdin</code> -标准输入是Unix进程读取字符输入的地方。默认情况下，这将是您的键盘。</li><li id="8090" class="mo mp it kw b kx mx la my ld mz lh na ll nb lp mt mu mv mw bi translated"><code class="fe ml mm mn mb b">stdout</code> -标准输出是Unix进程打印字符的地方。默认情况下，这是您从中启动命令的终端窗口。</li><li id="268a" class="mo mp it kw b kx mx la my ld mz lh na ll nb lp mt mu mv mw bi translated"><code class="fe ml mm mn mb b">stderr</code> -标准错误类似于标准输出，但是是错误信息的输出。将默认为运行命令的终端窗口。</li></ul><p id="4dae" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您可以将这些视为每个Unix进程上的端口或插头。每次在类似Unix的操作系统(如Linux或macOS)中启动一个程序，都会得到一个有一个输入<code class="fe ml mm mn mb b">stdin</code>和两个输出<code class="fe ml mm mn mb b">stdout</code>和<code class="fe ml mm mn mb b">stderr</code>的进程。我们将使用<code class="fe ml mm mn mb b">sha256sum</code>命令进行演示，该命令用于创建输入数据的SHA256散列。哈希对于对下载的文件进行完整性检查非常有用。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl ny"><img src="../Images/f67516bac4ade38df025c1423b09b6d0.png" data-original-src="https://miro.medium.com/v2/format:webp/1*r52vvJQRTfWzMK4ty0_XeA.png"/></div><figcaption class="nz oa gj gh gi ob oc bd b be z dk translated">默认情况下，stdin插入键盘，stdout和stderr连接到屏幕。但是，您可以重定向输入或输出。</figcaption></figure><p id="e5df" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当使用终端模拟器时，例如macOS上的Terminal.app或Linux上的GNOME终端，您的键盘和终端窗口由一个名为<code class="fe ml mm mn mb b">/dev/tty</code>的设备文件表示。我们将首先运行<code class="fe ml mm mn mb b">sha256sum</code>而不进行任何重定向。您键入输入，直到您用Ctrl-D发出传输结束(EOT)信号。</p><pre class="kj kk kl km gt ma mb mc md aw me bi"><span id="9312" class="mf mg it mb b gy mh mi l mj mk">❯ sha256sum<br/>hello world<br/>a948904f2f0f479b8f8197694b30184b0d2ed1c1cd2a1ec0fb85d299a192a447  -</span></pre><p id="6967" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，我们将像第二幅图一样，将<code class="fe ml mm mn mb b">stdout</code>重定向到一个名为<code class="fe ml mm mn mb b">checksum.txt</code>的文件。</p><pre class="kj kk kl km gt ma mb mc md aw me bi"><span id="8273" class="mf mg it mb b gy mh mi l mj mk">❯ sha256sum &gt; checksum.txt<br/>hello world<br/><br/>❯ cat checksum.txt<br/>a948904f2f0f479b8f8197694b30184b0d2ed1c1cd2a1ec0fb85d299a192a447  -</span></pre><p id="37bb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">哈希对于很多事情都很有用。我们可以用它作为原始的密码检查机制。在这种情况下，您必须假装“hello world”是一个没有人知道的秘密密码。如何检查某人是否知道密码？您可以通过使用<code class="fe ml mm mn mb b">--check</code>开关来实现，该开关指示<code class="fe ml mm mn mb b">sha256sum</code>验证输入散列值是否与存储在另一个文件中的值相同。</p><pre class="kj kk kl km gt ma mb mc md aw me bi"><span id="fb23" class="mf mg it mb b gy mh mi l mj mk">❯ sha256sum --check checksum.txt<br/>hello<br/>-: FAILED<br/>sha256sum: WARNING: 1 computed checksum did NOT match<br/><br/>❯ sha256sum --check checksum.txt<br/>hello world<br/>-: OK</span></pre><p id="b4ef" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">请注意，当我没有正确地编写全文时，我们的校验和失败了。这种机制用于验证下载的文件。想象一下，你在一个zip存档中下载了许多千兆字节的数据。你要确保传输中没有错误。允许您下载该文件的网站可以为您提供一个校验和文件，您可以对其进行验证。</p><p id="75e5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">向<code class="fe ml mm mn mb b">sha256sum</code>命令写入输入很麻烦。有了管道，我们可以用另一个进程代替键盘作为输入。在本例中，我们使用<code class="fe ml mm mn mb b">echo</code>命令来提供输入。</p><pre class="kj kk kl km gt ma mb mc md aw me bi"><span id="ae84" class="mf mg it mb b gy mh mi l mj mk">❯ echo foobar | sha256sum<br/>aec070645fe53ee3b3763059376134f058cc337247c978add178b6ccdfb0019f  -</span></pre><p id="3cae" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">使用管道符号<code class="fe ml mm mn mb b">|</code>,我们在概念上连接两个正在运行的shell命令，如下所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl ny"><img src="../Images/04108f88cb5e50a9f74f9e75293270c9.png" data-original-src="https://miro.medium.com/v2/format:webp/1*6tPeLNKjyXsH6vSCrDUE8Q.png"/></div></figure><p id="9e73" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以模仿上传带有校验和的文件的人创建一个带有文本“hello world”的文件，创建它的SHA256散列，然后稍后验证校验和。我们可以将该文件修改为“hello mars”，以证明SHA256哈希已经捕捉到了这一变化并向用户发出了警报。</p><pre class="kj kk kl km gt ma mb mc md aw me bi"><span id="3dd9" class="mf mg it mb b gy mh mi l mj mk"># Create text file with "hello world" message<br/>❯ echo hello world &gt; upload.txt<br/><br/>❯ cat upload.txt | sha256sum &gt; upload.checksum<br/><br/>❯ cat upload.txt | sha256sum --check upload.checksum<br/>-: OK</span></pre><p id="de6f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们修改<code class="fe ml mm mn mb b">upload.txt</code>文件，检查检查SHA265散列是否失败。</p><pre class="kj kk kl km gt ma mb mc md aw me bi"><span id="27d4" class="mf mg it mb b gy mh mi l mj mk">❯ echo hello mars &gt; upload.txt<br/><br/>❯ cat upload.txt | sha256sum --check upload.checksum<br/>-: FAILED<br/>sha256sum: WARNING: 1 computed checksum did NOT match</span></pre><p id="7263" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这些<code class="fe ml mm mn mb b">sha256sum</code>例子中，我故意用笨拙的方式来演示管道和重定向的使用。实际上有更简单的方法来执行散列和散列验证。</p><pre class="kj kk kl km gt ma mb mc md aw me bi"><span id="ac7b" class="mf mg it mb b gy mh mi l mj mk">❯ sha256sum upload.txt &gt; upload.checksum<br/><br/>❯ cat upload.checksum<br/>53d58e94e61b1c2a641dc52b402729f76c3832978e37f7f31ad1286ae32a796e  upload.txt<br/><br/>❯ sha256sum --check upload.checksum<br/>upload.txt: OK</span></pre><h2 id="f3d5" class="mf mg it bd nd od oe dn nh of og dp nl ld oh oi nn lh oj ok np ll ol om nr on bi translated">持久管道和命名管道</h2><p id="23b1" class="pw-post-body-paragraph ku kv it kw b kx nt ju kz la nu jx lc ld nv lf lg lh nw lj lk ll nx ln lo lp im bi translated">到目前为止，我们使用的管道是匿名的和临时的。然而，可以制作带有名称的管道。这种练习强调管道与文件非常相似，但有一些重要区别:</p><blockquote class="oo op oq"><p id="8816" class="ku kv lz kw b kx ky ju kz la lb jx lc or le lf lg os li lj lk ot lm ln lo lp im bi translated">文件通常一次由一个进程读取。管道由一个进程写入，由另一个进程读取。管道不在磁盘上存储数据。写入管道的数据最终存储在内存中。</p></blockquote><p id="bf7b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将使用一个叫做<code class="fe ml mm mn mb b">rev</code>的愚蠢命令来完成这个例子。所有的<code class="fe ml mm mn mb b">rev</code>做的就是逆转你喂它的一切。和<code class="fe ml mm mn mb b">sha256sum</code>一样，你可以不带任何参数地启动它，只需键入文本，直到你用Ctrl-D发出传输结束(EOT)的信号。</p><pre class="kj kk kl km gt ma mb mc md aw me bi"><span id="08f1" class="mf mg it mb b gy mh mi l mj mk">❯ rev<br/>hello<br/>olleh<br/>world<br/>dlrow</span></pre><p id="7026" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">自然，您可以通过重定向<code class="fe ml mm mn mb b">stdin</code>指向一个文件，将数据从一个文件输入到<code class="fe ml mm mn mb b">rev</code>。</p><pre class="kj kk kl km gt ma mb mc md aw me bi"><span id="7294" class="mf mg it mb b gy mh mi l mj mk">❯ cat &gt; hello.txt<br/>hello<br/>world  # Press Ctrl-D<br/><br/>❯ rev &lt; hello.txt<br/>olleh<br/>dlrow</span></pre><p id="5f89" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">从概念上讲，我们已经将这些不同的联系与<code class="fe ml mm mn mb b">rev</code>过程联系起来。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl ny"><img src="../Images/eab9cc55ecf5db93774d14b230cf30a2.png" data-original-src="https://miro.medium.com/v2/format:webp/1*ipbsUhC20odJxOVBiQlsGQ.png"/></div><figcaption class="nz oa gj gh gi ob oc bd b be z dk translated">重定向来自文件的输入</figcaption></figure><p id="d57d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将设置<code class="fe ml mm mn mb b">rev</code>从持久管道中读取数据。因为你推入管道的东西也是你先取出的东西，所以这些管道被称为FIFO管道(先进先出)。我们用<code class="fe ml mm mn mb b">mkfifo</code>命令做一个管道。我们将管道命名为<code class="fe ml mm mn mb b">tube</code>。</p><pre class="kj kk kl km gt ma mb mc md aw me bi"><span id="a5eb" class="mf mg it mb b gy mh mi l mj mk">❯ mkfifo tube<br/><br/>❯ file tube<br/>tube: fifo (named pipe)</span></pre><p id="d73b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个操作在文件系统中创建了一个名为<code class="fe ml mm mn mb b">tube</code>的条目，即使在您重启之后，它也将保留在那里。但是，从命名管道写入和读取的数据从不存储在磁盘上。它完全是在内存中处理的。让我们看看这在实践中是如何实现的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl ny"><img src="../Images/9f1e169a24e1290431f7a01cfd2ab30e.png" data-original-src="https://miro.medium.com/v2/format:webp/1*Jk3GNuOdQE2tsJ_Q9xIHtA.png"/></div><figcaption class="nz oa gj gh gi ob oc bd b be z dk translated">设置命名管道通信</figcaption></figure><p id="60fb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你需要两个终端窗口来完成这项工作。在一个窗口中，你写下<code class="fe ml mm mn mb b">rev &lt; tube</code>，这意味着你试图从命名管道中读取。在另一个窗口中，你写下<code class="fe ml mm mn mb b">cat &gt; tube</code>，这意味着你在键盘上写的任何东西都将被发送到<code class="fe ml mm mn mb b">tube</code>中，并且<code class="fe ml mm mn mb b">rev</code>进程将意识到它可以从电子管中读取。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl ny"><img src="../Images/a133aa7aac356a0960cf6e284286a71f.png" data-original-src="https://miro.medium.com/v2/format:webp/1*fCxzAMWu3s3nfyKRvCJWFg.png"/></div></figure><p id="496c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通常，我们对管道的名称或永久保留它不感兴趣。我们很乐意临时创建一个管道，这样我们就可以轻松地将数据从一个命令传递到另一个命令。</p><pre class="kj kk kl km gt ma mb mc md aw me bi"><span id="d4d7" class="mf mg it mb b gy mh mi l mj mk">❯ echo hello | rev<br/>olleh</span></pre><p id="4969" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">从概念上讲，命名和匿名瞬态管道做同样的事情。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl ny"><img src="../Images/bbe9929fd8565297173b7b755cc4c9b2.png" data-original-src="https://miro.medium.com/v2/format:webp/1*vnibgmWDDM6ay-WQMyrQnQ.png"/></div></figure><p id="0400" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">管道可以以复杂的方式组合，允许我们将许多命令提供的功能链接在一起。让我们看一个将<code class="fe ml mm mn mb b">ls</code>、<code class="fe ml mm mn mb b">head</code>和<code class="fe ml mm mn mb b">sort</code>链接在一起的例子:</p><pre class="kj kk kl km gt ma mb mc md aw me bi"><span id="968d" class="mf mg it mb b gy mh mi l mj mk">❯ touch hotel golf foxtrot echo<br/><br/>❯ ls | head -3<br/>echo<br/>foxtrot<br/>golf<br/><br/>❯ ls | head -3 | sort -r<br/>golf<br/>foxtrot<br/>echo</span></pre><p id="f4ef" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe ml mm mn mb b">head -3</code>命令选择前三行，而<code class="fe ml mm mn mb b">sort -r</code>将反向排序输入。从概念上讲，进程的stdout和stdin通过管道连接，如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl ny"><img src="../Images/351ef118b608d9d1724b14c30a82ddbc.png" data-original-src="https://miro.medium.com/v2/format:webp/1*4KYJkQqihn-39ejt6TFqFw.png"/></div><figcaption class="nz oa gj gh gi ob oc bd b be z dk translated">使用管道将三个命令链接在一起的示例。</figcaption></figure><p id="4537" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将研究一种方法来管理等待从命名管道中读写的多个程序，而不使用多个终端仿真器窗口。</p><h1 id="021e" class="nc mg it bd nd ne nf ng nh ni nj nk nl jz nm ka nn kc no kd np kf nq kg nr ns bi translated">通过作业控制管理多个流程</h1><p id="243e" class="pw-post-body-paragraph ku kv it kw b kx nt ju kz la nu jx lc ld nv lf lg lh nw lj lk ll nx ln lo lp im bi translated">Unix系统提供了在多个多任务进程之间周旋的方法。通常，当您运行一个进程时，您的键盘会一直锁定，直到它完成。这是因为该进程在前台运行。但是，可以将一个进程放在后台。后台进程是您不与之交互的进程。你可以有很多。前台进程是在终端窗口中接收键盘输入的进程。</p><p id="90f2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">作业控制对今天的我们来说不是很有用，因为我们可以打开很多终端窗口。但是，了解这一点是很有用的，因为您有时会远程使用Unix机器。</p><p id="d7d8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这个例子中，我们将有两个作业(进程)同时运行，从名为<code class="fe ml mm mn mb b">hasher</code>和<code class="fe ml mm mn mb b">tube</code>的不同管道中读取数据。让我们制作<code class="fe ml mm mn mb b">hasher</code>烟斗。</p><pre class="kj kk kl km gt ma mb mc md aw me bi"><span id="7084" class="mf mg it mb b gy mh mi l mj mk">❯ mkfifo hasher</span></pre><p id="a27a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，我们尝试从<code class="fe ml mm mn mb b">hasher</code>管道中读取数据。读数会一直阻塞，直到有东西被推进管道。我们按住Ctrl-Z来暂停这个过程:</p><pre class="kj kk kl km gt ma mb mc md aw me bi"><span id="bf4a" class="mf mg it mb b gy mh mi l mj mk">❯ cat hasher | sha256sum<br/>^Z⏎</span></pre><p id="a483" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">暂停的进程不做任何事情。它基本上被搁置了。我们可以使用<code class="fe ml mm mn mb b">jobs</code>命令来查看所有正在运行的作业的状态，看看我们的作业实际上是暂停了。</p><p id="5031" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="lz">注意:下面的提示看起来很搞笑，因为我用的是</em><a class="ae ou" href="https://starship.rs" rel="noopener ugc nofollow" target="_blank"><em class="lz">Starship</em></a><em class="lz">跨平台shell提示。</em></p><pre class="kj kk kl km gt ma mb mc md aw me bi"><span id="6b5e" class="mf mg it mb b gy mh mi l mj mk">✦2 ❯ jobs<br/>Job	Group	State	Command<br/>1	44863	stopped	cat hasher | sha256sum</span></pre><p id="1874" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以同时开始更多的工作。再次注意，我按Ctrl-Z来暂停<code class="fe ml mm mn mb b">rev</code>进程。</p><pre class="kj kk kl km gt ma mb mc md aw me bi"><span id="bd2a" class="mf mg it mb b gy mh mi l mj mk">✦2 ❯ cat tube | rev<br/>^Z⏎</span></pre><p id="72e7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们把一些数据写入这些试管。</p><pre class="kj kk kl km gt ma mb mc md aw me bi"><span id="f35a" class="mf mg it mb b gy mh mi l mj mk">✦4 ❯ echo ABDC &gt; tube<br/><br/>✦4 ❯ echo hello &gt; hasher</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl ny"><img src="../Images/ff5899b0f288ed25c6b14dcbccd87cf1.png" data-original-src="https://miro.medium.com/v2/format:webp/1*vbP_AT9yUfItQMzdRS6aIA.png"/></div><figcaption class="nz oa gj gh gi ob oc bd b be z dk translated">一个作业(进程组)可能处于的不同状态，以及我们如何触发从前台到停止的转换。</figcaption></figure><p id="d047" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这些进程不会暂停。它们将简单地写入管道并退出。我们可以通过运行<code class="fe ml mm mn mb b">jobs</code>来验证这一点，并查看哪些作业仍然存在。</p><pre class="kj kk kl km gt ma mb mc md aw me bi"><span id="cd1a" class="mf mg it mb b gy mh mi l mj mk">✦4 ❯ jobs<br/>Job	Group	State	Command<br/>2	44892	stopped	cat tube | rev<br/>1	44863	stopped	cat hasher | sha256sum</span></pre><p id="1956" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这些作业都没有完成任何工作，因为它们被暂停了。我们可以运行后台<code class="fe ml mm mn mb b">bg</code>命令，该命令在后台恢复列表顶部作业的执行。</p><pre class="kj kk kl km gt ma mb mc md aw me bi"><span id="9420" class="mf mg it mb b gy mh mi l mj mk">✦4 ❯ bg<br/>Send job 2 'cat tube | rev' to background<br/>CDBA</span></pre><p id="87ba" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们打印了<code class="fe ml mm mn mb b">CDBA</code>,这告诉我们作业实际上执行并反转了我们的“ABCD”文本字符串。SHA256哈希器仍然被挂起，所以我们再次调用<code class="fe ml mm mn mb b">bg</code>来启动它。</p><pre class="kj kk kl km gt ma mb mc md aw me bi"><span id="837d" class="mf mg it mb b gy mh mi l mj mk">✦2 ❯ bg<br/>Send job 1 'cat hasher | sha256sum' to background<br/>5891b5b522d5df086d0ff0b110fbd9d21bb4fc7163af34d08286a2e846f6be03  -</span></pre><p id="24c4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们现在可以运行<code class="fe ml mm mn mb b">jobs</code>来查看所有作业都已完成:</p><pre class="kj kk kl km gt ma mb mc md aw me bi"><span id="74a4" class="mf mg it mb b gy mh mi l mj mk">❯ jobs<br/>jobs: There are no jobs<br/>Job 1, 'cat hasher | sha256sum' has ended</span></pre><p id="a59a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以用<code class="fe ml mm mn mb b">fg</code>将作业发送到前台，而不是将作业发送到后台。这只有在工作需要键盘输入时才有意义。如果我们想通过发送Ctrl-C来快速完成任务，这可能会很有用。</p><h2 id="1402" class="mf mg it bd nd od oe dn nh of og dp nl ld oh oi nn lh oj ok np ll ol om nr on bi translated">通过编号或流程ID识别作业</h2><p id="48f8" class="pw-post-body-paragraph ku kv it kw b kx nt ju kz la nu jx lc ld nv lf lg lh nw lj lk ll nx ln lo lp im bi translated">作业是您正在运行和管理的流程。在任何给定的时间，都会有更多的作业在您的系统上运行。因为作业是过程，你可以用它们的<em class="lz">过程ID </em>或简称<strong class="kw iu"> PID </strong>来识别它们。</p><p id="201d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们启动之前的作业来比较PID和作业编号。</p><pre class="kj kk kl km gt ma mb mc md aw me bi"><span id="05cb" class="mf mg it mb b gy mh mi l mj mk">❯ cat tube | rev<br/>^Z⏎<br/><br/>✦2 ❯ cat hasher | sha256sum<br/>^Z⏎</span></pre><p id="6768" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以使用作业列表和进程列表从不同的角度检查我们的作业。</p><pre class="kj kk kl km gt ma mb mc md aw me bi"><span id="38e6" class="mf mg it mb b gy mh mi l mj mk">✦4 ❯ jobs<br/>Job	Group	State	Command<br/>2	45247	stopped	cat hasher | sha256sum<br/>1	45218	stopped	cat tube | rev<br/><br/>✦4 ❯ ps<br/>  PID TTY           TIME CMD<br/>31150 ttys001    0:06.11 -fish<br/>39264 ttys002    0:03.84 -fish<br/>41598 ttys003    0:15.00 -fish<br/>45218 ttys003    0:00.01 cat tube<br/>45219 ttys003    0:00.01 rev<br/>45247 ttys003    0:00.00 cat hasher<br/>45248 ttys003    0:00.00 sha256sum</span></pre><p id="9679" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这种情况下，使用PID更加麻烦，因为我们必须单独终止作业中的单个进程。例如，作业2由进程<code class="fe ml mm mn mb b">cat</code>和<code class="fe ml mm mn mb b">sha256</code>组成。要终止作业，您必须同时终止它们:</p><pre class="kj kk kl km gt ma mb mc md aw me bi"><span id="55e8" class="mf mg it mb b gy mh mi l mj mk">✦4 ❯ kill -9 45247 45248</span></pre><p id="8631" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">PID数字也需要更长的时间来书写和记忆。如果你想终止<code class="fe ml mm mn mb b">rev</code>任务，你可以写<code class="fe ml mm mn mb b">kill %1</code>。为了区分工单编号和PID编号，您需要添加一个百分比<code class="fe ml mm mn mb b">%</code>。这适用于多种环境。我们可以使用它在后台恢复特定的作业:</p><pre class="kj kk kl km gt ma mb mc md aw me bi"><span id="760c" class="mf mg it mb b gy mh mi l mj mk">✦2 ❯ bg %1<br/>Send job 1 'cat tube | rev' to background</span></pre><p id="337c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">作业状态现在表明作业正在运行。</p><pre class="kj kk kl km gt ma mb mc md aw me bi"><span id="8ef0" class="mf mg it mb b gy mh mi l mj mk">✦2 ❯ jobs<br/>Job	Group	State	Command<br/>1	45218	running	cat tube | rev</span></pre><p id="fa1b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">将立即处理推送到命名管道的数据:</p><pre class="kj kk kl km gt ma mb mc md aw me bi"><span id="a95e" class="mf mg it mb b gy mh mi l mj mk">✦2 ❯ echo ABC &gt; tube<br/>CBA<br/><br/>❯ jobs<br/>jobs: There are no jobs<br/>Job 1, 'cat tube | rev' has ended</span></pre><p id="be2d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">既然我们已经了解了基本原理，我们可以深入研究本文开头的更复杂的例子。</p><h1 id="b20d" class="nc mg it bd nd ne nf ng nh ni nj nk nl jz nm ka nn kc no kd np kf nq kg nr ns bi translated">下载和处理数据</h1><p id="f518" class="pw-post-body-paragraph ku kv it kw b kx nt ju kz la nu jx lc ld nv lf lg lh nw lj lk ll nx ln lo lp im bi translated">很多数据处理都是处理表格中的数据。我的许多故事都是关于一段时间内的各种经济发展，这些发展可以用人均GDP、钢铁产量和许多其他东西来衡量。这种数据通常是从经合组织、国际货币基金组织和其他组织下载的，以逗号分隔的ASCII文本中的简单表格(CSV文件)的形式提供。</p><p id="58b5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通常，我们感兴趣的不是它们包含的所有数据，而是一个子集。数据的格式也可能不完全符合我们的要求。</p><p id="a28f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">阅读更多:<a class="ae ou" href="https://erik-engheim.medium.com/analyze-world-data-using-julia-8f9d16c6ac2a" rel="noopener">使用Julia </a>分析世界数据。</p><p id="c4b5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">幸运的是，一个标准的Unix shell包含许多用于获取和处理数据的工具。cURL是一个非常有用的从网上下载数据的工具。虽然您可以自己点击各种下载链接，但您可能需要某种可复制性。假设你写了一篇文章，你想让人们复制你的结果。您可以简单地显示cURL download语句来获取数据，而不是告诉他们如何导航到各种站点来下载数据。您甚至可以将下载语句放在Bash脚本中，并将其签入版本控制系统。</p><p id="b02d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在教学或实验处理数据时，我经常喜欢看<a class="ae ou" href="https://vincentarelbundock.github.io/Rdatasets" rel="noopener ugc nofollow" target="_blank"> RDatasets </a>。这是一个在线回购，任何人都可以使用大量不同的数据集进行实验。这个故事的第一个例子下载了比萨饼数据。</p><p id="9abd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">将长URL放入环境变量中是很常见的。开发人员通常会在shell脚本中这样做。在我的示例中，我将所有<a class="ae ou" href="https://vincentarelbundock.github.io/Rdatasets" rel="noopener ugc nofollow" target="_blank"> RDataset </a> CSV文件的基址存储在<code class="fe ml mm mn mb b">RDATASETS</code>环境变量中，如下所示:</p><pre class="kj kk kl km gt ma mb mc md aw me bi"><span id="f5ed" class="mf mg it mb b gy mh mi l mj mk">❯ RDATASETS=https://vincentarelbundock.github.io/Rdatasets/csv</span></pre><p id="5300" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">实际上，由于我已经使用<a class="ae ou" href="https://fishshell.com" rel="noopener ugc nofollow" target="_blank"> Fish shell </a>十多年了，所以我写这个的方式略有不同(我向任何想要使用简单而强大的shell环境的人推荐Fish):</p><pre class="kj kk kl km gt ma mb mc md aw me bi"><span id="7a03" class="mf mg it mb b gy mh mi l mj mk">❯ set RDATASETS <a class="ae ou" href="https://vincentarelbundock.github.io/Rdatasets/csv" rel="noopener ugc nofollow" target="_blank">https://vincentarelbundock.github.io/Rdatasets/csv</a></span></pre><p id="4042" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当使用cURL时，可能会有各种关于下载速度的输出，您不希望将它们存储在文本文件中。您可以使用静音<code class="fe ml mm mn mb b">-s</code>开关来移除它。</p><pre class="kj kk kl km gt ma mb mc md aw me bi"><span id="bcc5" class="mf mg it mb b gy mh mi l mj mk">❯ curl -s $RDATASETS/gt/pizzaplace.csv &gt; pizzaplace.csv</span></pre><p id="66fb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">cURL可以以多种方式使用，甚至可以从有密码保护或其他形式的身份验证的网站下载数据。<a class="ae ou" href="https://curl.se/docs/manual.html" rel="noopener ugc nofollow" target="_blank"> cURL文档</a>很好地概述了<a class="ae ou" href="https://curl.se/docs/manual.html" rel="noopener ugc nofollow" target="_blank">使用cURL下载数据的各种方式。</a></p><h2 id="55aa" class="mf mg it bd nd od oe dn nh of og dp nl ld oh oi nn lh oj ok np ll ol om nr on bi translated">头和尾</h2><p id="ae38" class="pw-post-body-paragraph ku kv it kw b kx nt ju kz la nu jx lc ld nv lf lg lh nw lj lk ll nx ln lo lp im bi translated">在检查刚下载的数据时，通常会使用<code class="fe ml mm mn mb b">head</code>和<code class="fe ml mm mn mb b">tail</code>等工具来查看部分数据。没有任何参数，每个命令给出10个条目。让我们看看比萨饼销售数据的前10个条目:</p><pre class="kj kk kl km gt ma mb mc md aw me bi"><span id="3beb" class="mf mg it mb b gy mh mi l mj mk">❯ head pizzaplace.csv<br/>"","id","date","time","name","size","type","price"<br/>"1","2015-000001","2015-01-01","11:38:36","hawaiian","M","classic",13.25<br/>"2","2015-000002","2015-01-01","11:57:40","classic_dlx","M","classic",16<br/>"3","2015-000002","2015-01-01","11:57:40","mexicana","M","veggie",16<br/>"4","2015-000002","2015-01-01","11:57:40","thai_ckn","L","chicken",20.75<br/>"5","2015-000002","2015-01-01","11:57:40","five_cheese","L","veggie",18.5<br/>"6","2015-000002","2015-01-01","11:57:40","ital_supr","L","supreme",20.75<br/>"7","2015-000003","2015-01-01","12:12:28","prsc_argla","L","supreme",20.75<br/>"8","2015-000003","2015-01-01","12:12:28","ital_supr","M","supreme",16.5<br/>"9","2015-000004","2015-01-01","12:16:31","ital_supr","M","supreme",16.5</span></pre><h2 id="0034" class="mf mg it bd nd od oe dn nh of og dp nl ld oh oi nn lh oj ok np ll ol om nr on bi translated">tr —翻译字符</h2><p id="c1b1" class="pw-post-body-paragraph ku kv it kw b kx nt ju kz la nu jx lc ld nv lf lg lh nw lj lk ll nx ln lo lp im bi translated">所有的引号使它更难阅读。我们可以用<code class="fe ml mm mn mb b">tr</code>来移除它们。<code class="fe ml mm mn mb b">tr</code>是一个用于替换或删除字符的通用工具。如果你不想翻译一个字符，但删除它，你添加<code class="fe ml mm mn mb b">-d</code>(删除)开关。原则上，您可以编写<code class="fe ml mm mn mb b">tr -d "</code>，但是因为Shell会认为您开始引用某个东西，所以您需要用单引号引用双引号。</p><pre class="kj kk kl km gt ma mb mc md aw me bi"><span id="5fa8" class="mf mg it mb b gy mh mi l mj mk">❯ head pizzaplace.csv | tr -d '"'<br/>,id,date,time,name,size,type,price<br/>1,2015-000001,2015-01-01,11:38:36,hawaiian,M,classic,13.25<br/>2,2015-000002,2015-01-01,11:57:40,classic_dlx,M,classic,16<br/>3,2015-000002,2015-01-01,11:57:40,mexicana,M,veggie,16<br/>4,2015-000002,2015-01-01,11:57:40,thai_ckn,L,chicken,20.75<br/>5,2015-000002,2015-01-01,11:57:40,five_cheese,L,veggie,18.5<br/>6,2015-000002,2015-01-01,11:57:40,ital_supr,L,supreme,20.75<br/>7,2015-000003,2015-01-01,12:12:28,prsc_argla,L,supreme,20.75<br/>8,2015-000003,2015-01-01,12:12:28,ital_supr,M,supreme,16.5<br/>9,2015-000004,2015-01-01,12:16:31,ital_supr,M,supreme,16.5</span></pre><p id="5d19" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我们只对比萨饼的种类、份量和价格感兴趣，那么有很多我们不感兴趣的细节，我们希望删除。</p><h2 id="e012" class="mf mg it bd nd od oe dn nh of og dp nl ld oh oi nn lh oj ok np ll ol om nr on bi translated">剪切-剪切每条线的一部分</h2><p id="b823" class="pw-post-body-paragraph ku kv it kw b kx nt ju kz la nu jx lc ld nv lf lg lh nw lj lk ll nx ln lo lp im bi translated">我们可以使用<code class="fe ml mm mn mb b">cut</code>工具剪切出我们感兴趣的一部分数据。像许多Unix工具一样，它每行处理数据。</p><p id="9173" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您可能已经注意到，数据的第一部分非常有规律。每一列都有相同数量的字符。我们可以通过指定一个字节范围来利用这一点。在字符35处，我们感兴趣的比萨饼数据开始。我怎么知道？只需快速试一试错误。我做了一个大概的猜测，看了看我得到的输出，然后简单地调整了一下。</p><pre class="kj kk kl km gt ma mb mc md aw me bi"><span id="d39f" class="mf mg it mb b gy mh mi l mj mk">❯ head pizzaplace.csv | tr -d '"' | cut -b 35-<br/><br/>hawaiian,M,classic,13.25<br/>classic_dlx,M,classic,16<br/>mexicana,M,veggie,16<br/>thai_ckn,L,chicken,20.75<br/>five_cheese,L,veggie,18.5<br/>ital_supr,L,supreme,20.75<br/>prsc_argla,L,supreme,20.75<br/>ital_supr,M,supreme,16.5<br/>ital_supr,M,supreme,16.5</span></pre><p id="fc9f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您可以使用<code class="fe ml mm mn mb b">-f</code>开关选择想要的列号，而不是按字节计数。然而，这需要用<code class="fe ml mm mn mb b">-d</code>开关指定列分隔符是什么。<code class="fe ml mm mn mb b">-f</code>和<code class="fe ml mm mn mb b">-b</code>开关都接受数字列表，可以用逗号分隔或用破折号连接。您可以有开放或封闭的范围。例如，<code class="fe ml mm mn mb b">-f 3-5</code>表示第三列到第五列，而<code class="fe ml mm mn mb b">-f 5-</code>表示从第五列到最后一列。您可以通过列出感兴趣的单个列来跳过列。<code class="fe ml mm mn mb b">f 2,4,8</code>给出第二、第四和第八列。</p><p id="69e0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以通过指定列来进行基于字节的删减:</p><pre class="kj kk kl km gt ma mb mc md aw me bi"><span id="52c8" class="mf mg it mb b gy mh mi l mj mk">❯ head pizzaplace.csv | tr -d '"' | cut -d , -f 5-<br/>name,size,type,price<br/>hawaiian,M,classic,13.25<br/>classic_dlx,M,classic,16<br/>mexicana,M,veggie,16<br/>thai_ckn,L,chicken,20.75<br/>five_cheese,L,veggie,18.5<br/>ital_supr,L,supreme,20.75<br/>prsc_argla,L,supreme,20.75<br/>ital_supr,M,supreme,16.5<br/>ital_supr,M,supreme,16.5</span></pre><p id="bb7f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以采用最后三列，并添加一个字符转换，将逗号转换为制表符，以生成一个更易于阅读的表格:</p><pre class="kj kk kl km gt ma mb mc md aw me bi"><span id="ceb6" class="mf mg it mb b gy mh mi l mj mk">❯ head pizzaplace.csv | tr -d '"' | cut -d , -f 6- | tr , \t<br/>size	type	price<br/>M	classic	13.25<br/>M	classic	16<br/>M	veggie	16<br/>L	chicken	20.75<br/>L	veggie	18.5<br/>L	supreme	20.75<br/>L	supreme	20.75<br/>M	supreme	16.5<br/>M	supreme	16.5</span></pre><p id="3996" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你想用这个玩更多，你应该检查一下<code class="fe ml mm mn mb b">paste</code>之类的命令。就写<code class="fe ml mm mn mb b">man paste</code>了解更多。</p><h1 id="9e18" class="nc mg it bd nd ne nf ng nh ni nj nk nl jz nm ka nn kc no kd np kf nq kg nr ns bi translated">Sed和Awk呢？</h1><p id="4071" class="pw-post-body-paragraph ku kv it kw b kx nt ju kz la nu jx lc ld nv lf lg lh nw lj lk ll nx ln lo lp im bi translated">有很多比我展示的用于文本处理的工具更强大的Unix工具，比如<code class="fe ml mm mn mb b">sed</code>和<code class="fe ml mm mn mb b">awk</code>。这些几乎没有给出用于逐行处理文本的编程语言。就我个人而言，我从来没有使用过它们，因为我并不真正编写Shell脚本。您可能注意到，在这篇文章中，我没有展示如何用for-loops和if-statement将命令收集到shell脚本中。这是一个深思熟虑的选择。</p><p id="61e3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一旦你需要做的事情变得更加复杂，你最好使用真正的编程语言。但是您可以将shell工具与其他语言结合使用。这是Julia使用CSV包的一个示例，它让您可以加载与DataFrames包相结合的CSV文件，从而可以有效地处理表格数据。</p><p id="175a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您会注意到，我们可以利用已经研究过的Unix命令将数据加载到一个表中。我们需要更长一点的代码来处理所有的命令。</p><pre class="kj kk kl km gt ma mb mc md aw me bi"><span id="78db" class="mf mg it mb b gy mh mi l mj mk"># Need to install CSV and DataFrames packages first<br/>using CSV, DataFrames<br/><br/>job = pipeline(`head pizzaplace.csv`, `tr -d '"'`, `cut -d , -f 6-`);<br/><br/>df = open(job) do io<br/>  DataFrame(CSV.File(io))<br/>end</span></pre><p id="f3c1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在Julia中运行这段代码时，变量<code class="fe ml mm mn mb b">df</code>将显示以下格式良好的数据:</p><pre class="kj kk kl km gt ma mb mc md aw me bi"><span id="2fee" class="mf mg it mb b gy mh mi l mj mk">9×3 DataFrame<br/> Row │ size     type     price<br/>     │ String1  String7  Float64<br/>─────┼───────────────────────────<br/>   1 │ M        classic    13.25<br/>   2 │ M        classic    16.0<br/>   3 │ M        veggie     16.0<br/>   4 │ L        chicken    20.75<br/>   5 │ L        veggie     18.5<br/>   6 │ L        supreme    20.75<br/>   7 │ L        supreme    20.75<br/>   8 │ M        supreme    16.5<br/>   9 │ M        supreme    16.5</span></pre><p id="ca50" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">假设您已经在朱莉娅·REPL环境(read-evaluate-print-loop)中运行了加载代码，那么您可以轻松地运行几个命令来操作这个比萨饼销售表，这比单独在Unix shell中要有效得多。您可以使用<code class="fe ml mm mn mb b">select</code>选择要显示的列，包括重新排列它们。</p><pre class="kj kk kl km gt ma mb mc md aw me bi"><span id="f367" class="mf mg it mb b gy mh mi l mj mk">julia&gt; select(df, :type, :size, :price)<br/>9×3 DataFrame<br/> Row │ type     size     price<br/>     │ String7  String1  Float64<br/>─────┼───────────────────────────<br/>   1 │ classic  M          13.25<br/>   2 │ classic  M          16.0<br/>   3 │ veggie   M          16.0<br/>   4 │ chicken  L          20.75<br/>   5 │ veggie   L          18.5<br/>   6 │ supreme  L          20.75<br/>   7 │ supreme  L          20.75<br/>   8 │ supreme  M          16.5<br/>   9 │ supreme  M          16.5</span></pre><p id="a3e1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以按类型分组，然后通过对价格求和来折叠每个组，以查看我们销售每种类型的披萨赚了多少钱。这种方法很有效，因为Julia可以将数据不仅仅视为文本。Unix工具非常适合处理文本，但不适用于数字数据。</p><pre class="kj kk kl km gt ma mb mc md aw me bi"><span id="d3db" class="mf mg it mb b gy mh mi l mj mk">julia&gt; combine(groupby(df, :type), :price =&gt; sum)<br/>4×2 DataFrame<br/> Row │ type     price_sum<br/>     │ String7  Float64<br/>─────┼────────────────────<br/>   1 │ classic      29.25<br/>   2 │ veggie       34.5<br/>   3 │ chicken      20.75<br/>   4 │ supreme      74.5</span></pre><p id="e057" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我最后一部分的目的不是教你Julia，而是简单地给你一种使用“真正的”编程语言的感觉。我想说的是:</p><blockquote class="ov"><p id="f0ab" class="ow ox it bd oy oz pa pb pc pd pe lp dk translated">使用合适的工具完成工作</p></blockquote><p id="7929" class="pw-post-body-paragraph ku kv it kw b kx pf ju kz la pg jx lc ld ph lf lg lh pi lj lk ll pj ln lo lp im bi translated">Unix命令行很棒，但是我要小心不要让自己太过深入地研究每一个小命令和功能。我过去曾试图这样做，但在我看来并没有得到回报。只要不需要if语句和循环之类的控制逻辑，我觉得Unix shell工具就很好用。保持简单！</p></div></div>    
</body>
</html>