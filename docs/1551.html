<html>
<head>
<title>Enterprise adventures: deployment from on prem into cloud</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">企业冒险:从内部部署到云中</h1>
<blockquote>原文：<a href="https://itnext.io/enterprise-adventures-pt-2-41949f559920?source=collection_archive---------2-----------------------#2018-11-21">https://itnext.io/enterprise-adventures-pt-2-41949f559920?source=collection_archive---------2-----------------------#2018-11-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="cf2c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我在从遗产地到库伯内特天堂的应许之地的旅途中遇到了一个有趣的问题。</p><p id="6bce" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">旧环境中有一个CI基础设施，包括一个git存储库、一个Jenkins构建服务器和一个Nexus工件存储库。</p><p id="11fa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">云中有一个环境，有一个很好的Kubernetes集群，还有一个保存部署描述符的git存储库、一个包含Docker映像的注册表和另一个负责持续部署的Jenkins实例(当然有一些手动步骤)。</p><p id="de55" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">问题是，由于一些非常重要的原因(每个企业中总有一些非常重要的原因让您的生活变得更轻松)，源代码不能被推到云中，这意味着工件是在遗留环境中构建的，并上传到那里的Nexus服务器。</p><p id="b579" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当有人决定这样做时，工件被下载到开发人员的机器上，提交到第二版本控制中，然后上传到云环境中。在那里，Jenkins服务器启动了一个pod (docker，kubectl ),它将从jar文件创建一个docker映像，并将它推送到注册中心，Kubernetes可以从那里访问和部署它。</p><p id="49a8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你必须为网络流量支付额外的费用，因此你不可能每10分钟就下载一次工件——而且速度也会很慢。对于代码来说也是如此，我们不能在每次提交时都进行拉取和构建——这很昂贵。</p><p id="c061" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对我来说，这是非常丑陋和痛苦的——尤其是手动将二进制文件提交到git并对它们进行版本控制，所以我想改变这一点。</p><p id="24e4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">总结:目标不是手动将jar文件签入git，而是同时节省网络流量。</p><h2 id="bd12" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">Sha1来救援</h2><p id="e32d" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">上面这些管道的创建者没有意识到的技巧是，当您创建maven工件并部署它们时，您会在二进制文件中获得一些额外的元数据，请看:</p><pre class="lj lk ll lm gt ln lo lp lq aw lr bi"><span id="02b5" class="kl km iq lo b gy ls lt l lu lv">bnemeth@mash:~/.m2/repository/com/edudoo/sample/1.0-SNAPSHOT$ ls -la<br/>total 104<br/>drwxrwxr-x 2 bnemeth bnemeth  4096 szept 14 15:08 .<br/>drwxrwxr-x 3 bnemeth bnemeth  4096 aug   27 12:46 ..<br/>-rw-rw-r-- 1 bnemeth bnemeth 14345 szept  3 10:51 sample-1.0-20180903.072937-26.jar<br/><strong class="lo ir">-rw-rw-r-- 1 bnemeth bnemeth    40 szept  3 10:51 sample-1.0-20180903.072937-26.jar.sha1</strong><br/>-rw-rw-r-- 1 bnemeth bnemeth  1564 szept  3 10:51 sample-1.0-20180903.072937-26.pom<br/>-rw-rw-r-- 1 bnemeth bnemeth    40 szept  3 10:51 sample-1.0-20180903.072937-26.pom.sha1<br/>-rw-rw-r-- 1 bnemeth bnemeth 14399 szept 14 14:01 sample-1.0-20180914.083257-30.jar<br/><strong class="lo ir">-rw-rw-r-- 1 bnemeth bnemeth    40 szept 14 14:01 sample-1.0-20180914.083257-30.jar.sha1</strong><br/>-rw-rw-r-- 1 bnemeth bnemeth  1157 szept 14 14:01 sample-1.0-20180914.083257-30.pom<br/>-rw-rw-r-- 1 bnemeth bnemeth    40 szept 14 14:01 sample-1.0-20180914.083257-30.pom.sha1<br/>-rw-rw-r-- 1 bnemeth bnemeth 14387 szept 20 14:16 sample-1.0-SNAPSHOT.jar<br/>-rw-rw-r-- 1 bnemeth bnemeth  1157 szept 13 10:23 sample-1.0-SNAPSHOT.pom<br/>-rw-rw-r-- 1 bnemeth bnemeth   720 szept 20 14:16 maven-metadata-local.xml<br/>-rw-rw-r-- 1 bnemeth bnemeth   787 szept 14 15:08 maven-metadata-ply-snapshots.xml<br/>-rw-rw-r-- 1 bnemeth bnemeth    40 szept 14 15:08 maven-metadata-ply-snapshots.xml.sha1<br/>-rw-rw-r-- 1 bnemeth bnemeth   424 szept 20 14:16 _remote.repositories<br/>-rw-rw-r-- 1 bnemeth bnemeth   193 szept 14 15:08 resolver-status.properties</span></pre><p id="1190" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每次jar文件改变时，sha1散列都会改变。</p><p id="4bac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是校验和。</p><p id="3c35" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">而且从Nexus下载最新神器有一个非常简单的方法(格式:Jenkinsfile中的groovy):</p><pre class="lj lk ll lm gt ln lo lp lq aw lr bi"><span id="e8cb" class="kl km iq lo b gy ls lt l lu lv">def downloadJar(String groupId, String artifactId, String version, String folder){<br/>jarUrl="<strong class="lo ir">http://nexus.edudoo.com/service/local/artifact/maven/content?g=${groupId}&amp;a=${artifactId}&amp;v=${version}&amp;r=snapshots&amp;c=exec</strong>"<br/>    sh "<strong class="lo ir">curl \"${jarUrl}\"</strong> &gt; ${folder}/${artifactId}-exec.jar"<br/>}</span></pre><p id="6dd6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过添加限定符，您也可以获得散列文件:</p><pre class="lj lk ll lm gt ln lo lp lq aw lr bi"><span id="38fe" class="kl km iq lo b gy ls lt l lu lv">def downloadHash(String groupId, String artifactId, String version) {<br/>    shaUrl=<strong class="lo ir">"http://nexus.edudoo.com/service/local/artifact/maven/content?g=${groupId}&amp;a=${artifactId}&amp;v=${version}&amp;r=snapshots&amp;c=exec&amp;e=jar.sha1"</strong><br/>    hash=sh(returnStdout: true, script: "<strong class="lo ir">curl \"${shaUrl}\" -s</strong>")<br/>    hash<br/>}</span></pre><p id="c170" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，不用每次都下载jar文件并与之前的文件进行比较，只需下载hash文件并进行比较就足够了！</p><p id="9c50" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">(是的，这与依赖管理工具确定是否下载快照工件的方式相同。)</p><h2 id="3579" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">缓存校验和</h2><p id="4054" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">我们可以像以前一样将sha1文件提交到git中，并总是将最新的sha1与那个sha1进行比较，但这感觉仍然非常可疑——请记住:我们的Jenkins节点是一个Kubernetes pod，因此是无状态的，我们并不真正希望对卷进行修改。</p><p id="c069" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们能把元数据保存在第二个环境中的某个地方就好了…</p><p id="f04b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">确实有办法。而不是仅仅用版本号(这是一种非常过时的跟踪您部署的工件的方式，如果您使用CD的话——再想一想)和经典的<code class="fe lw lx ly lo b">latest</code>(快照！)，为什么不干脆用hash本身来标记呢？这样我们就可以知道Docker工件是否已经从带有sha1标签的jar中构建出来了。</p><p id="064d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要检查这一点，只需:</p><pre class="lj lk ll lm gt ln lo lp lq aw lr bi"><span id="7ab6" class="kl km iq lo b gy ls lt l lu lv">def imageExists(String registryHost, String image, String tag) {<br/>    echo "Checking ${image} in remote repository ${registryHost} for existing ${tag} tag..."<br/>    exists=false<br/>    withCredentials([[$class: 'UsernamePasswordMultiBinding', credentialsId:'ARTIFACTORY_DOCKER_NDC', usernameVariable: 'USER', passwordVariable: 'PASSWD']]) {<br/>        registryResponse=sh(returnStdout: true, script: "<strong class="lo ir">curl --insecure -s -u ${USER}:${PASSWD} \"https://${registryHost}/v2/${image}/tags/list\"</strong>")<br/>        exists=registryResponse.contains(tag)<br/>        echo "Image exists: ${exists}"<br/>    }<br/>    exists<br/>}</span></pre><p id="5199" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有一些认证正在进行，但重点是docker注册中心也有一个端点，使用curl语句返回图像的所有标签。请注意，<em class="lz">registry response . contains(tag)</em>被简化了，在某些情况下，这种检查json对象是否在某处包含特定标记的方法是不正确的，但是我将把这个实现任务留给您(提示:使用<a class="ae ma" href="https://stedolan.github.io/jq/" rel="noopener ugc nofollow" target="_blank"> jq </a>或一些python库)。</p><p id="de29" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">(用工件的提交ID进行标记可能是最好的，但是我们不能访问原始的git，只能访问工件存储库。)</p><p id="34f4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以知道步骤是:</p><ol class=""><li id="c08d" class="mb mc iq jp b jq jr ju jv jy md kc me kg mf kk mg mh mi mj bi translated">从Nexus下载哈希</li><li id="6b85" class="mb mc iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">检查是否存在带有该标签的图像</li><li id="2dbb" class="mb mc iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">如果是，什么也不做</li><li id="070b" class="mb mc iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">如果没有，将jar下载到一个临时目录，构建映像，用hash标记映像，用所有标记推送映像</li></ol><p id="6f96" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们可以一直运行这个作业，如果不是绝对必要，它永远不会下载jar！</p></div></div>    
</body>
</html>