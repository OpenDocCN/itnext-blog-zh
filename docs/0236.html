<html>
<head>
<title>OutSystems 101: Aggregates vs SQL Queries</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">OutSystems 101:聚合与SQL查询</h1>
<blockquote>原文：<a href="https://itnext.io/outsystems-101-aggregates-vs-sql-queries-ec7223f4c496?source=collection_archive---------0-----------------------#2018-01-22">https://itnext.io/outsystems-101-aggregates-vs-sql-queries-ec7223f4c496?source=collection_archive---------0-----------------------#2018-01-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="e537" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当浏览<a class="ae kl" href="https://www.outsystems.com/forums/" rel="noopener ugc nofollow" target="_blank"> OutSystems论坛</a>时，你会看到几个关于同一主题的问题。在本文中，我将描述<strong class="jp ir">如何将一个大的SQL查询转换成一个相当简单的集合</strong>。但首先，让我解释一下不同之处。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/3d2e7fd3bcc6c1b9ffa64286b2e07fec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kaIUKev8EpVxetX3wGRj2w.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">左:SQL查询，右:聚合</figcaption></figure><p id="ee76" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在OutSystems中，有两种方法可以编写一个<a class="ae kl" href="https://success.outsystems.com/Documentation/10/Reference/Data/Handling_Data/Queries" rel="noopener ugc nofollow" target="_blank">查询</a>，通过聚合或者通过SQL查询。</p><p id="de61" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">聚合是首选选项，因为它正在被平台优化。当代码中不需要某个属性时，它不会被添加到聚合的输出中。请允许我提醒您，当在服务器操作中使用聚合时，聚合的输出被分配给操作的输出。优化只是将集合的属性与输出结构进行比较，系统不会检查您最终将在屏幕中使用输出结构的哪些属性。</p><p id="732e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在SQL查询中，您必须自己进行这类验证，如果您不是SQL专家，这可能会导致性能问题。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><a href="https://www.linkit.nl/vacatures?search=outsystems&amp;utm_source=itnext&amp;utm_medium=Medium.com&amp;utm_campaign=article_banner"><div class="gh gi lc"><img src="../Images/5ec70c2c1ec21dad8e721439bed52036.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZcvuE-UGZJ_BSjMoQ7Oftg.png"/></div></a></figure><h1 id="8192" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">什么时候需要使用聚合查询或SQL查询？</h1><p id="5ef5" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated"><strong class="jp ir">聚合</strong>:当您创建一个选择查询来获取一个列表，并且不需要SQL操作符‘IN’、‘EXISTS’、‘ANY’或‘ALL’时。</p><p id="34a1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> SQL查询</strong>:当你创建一个批量操作或者当你需要一个上面提到的SQL操作符时。</p><p id="3abe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有些人会说，UNION也是不能在聚合中使用的运算符之一，但是仔细想想，UNION只不过是一种将两个或更多查询的结果组合成一个结果集的方法。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi mg"><img src="../Images/d3b99ec9e7c4b3ce14211e307e194a81.png" data-original-src="https://miro.medium.com/v2/resize:fit:366/format:webp/1*xKzE_DrlpKCZUbgaleH3-w.png"/></div></figure><p id="d171" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在OutSystems中，您可以使用动作<a class="ae kl" href="https://success.outsystems.com/Documentation/10/Reference/OutSystems_APIs/System_Actions#ListAppendAll" rel="noopener ugc nofollow" target="_blank">lisappendall</a>来组合两个聚合，这使得UNION变得过时。</p><p id="8b21" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我在论坛上找到的一个例子</p><p id="8a2d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以下问题是<a class="ae kl" href="https://www.outsystems.com/forums/discussion/33581/union-in-aggregate/" rel="noopener ugc nofollow" target="_blank">在论坛</a>上发布的。我将解释将该查询转换为聚合所需的步骤。</p><pre class="kn ko kp kq gt mh mi mj mk aw ml bi"><span id="7677" class="mm le iq mi b gy mn mo l mp mq">-- open by me<br/>SELECT<br/>   {SRJournal}.* ,<br/>   {EntityGroup}.[EntityDesc],<br/>   {SRPriority}.[PriorityName],<br/>   {SRStatus}.[Label],<br/>   {User}.[Name],<br/>   Pickup.[Name]<br/>FROM {SRJournal}<br/>   inner join {SRStatus} on {SRStatus}.[Id]={SRJournal}.[StatusId] and {SRStatus}.[Label] in (‘Pending Approval’,’Request For Info’)<br/>   inner join {User} on {User}.[Id]={SRJournal}.[ModifiedBy]<br/>   inner join {User} Pickup on Pickup.[Id]={SRJournal}.[PickUpBy]<br/>   inner join {EntityGroup} on {EntityGroup}.[Id]={SRJournal}.[EntityGroupId]<br/>   inner join {SRPriority} on {SRPriority}.[Id]={SRJournal}.[PriorityId]<br/>where<br/>   {SRJournal}.[ModifiedBy]=@PUserId</span><span id="046c" class="mm le iq mi b gy mr mo l mp mq">union<br/>-- Pending my approval<br/>SELECT <br/>   {SRJournal}.* ,<br/>   {EntityGroup}.[EntityDesc],<br/>   {SRPriority}.[PriorityName],<br/>   {SRStatus}.[Label],<br/>   {User}.[Name],<br/>   Pickup.[Name]<br/>FROM {SRJournal}<br/>   inner join {SRStatus} on {SRStatus}.[Id]={SRJournal}.[StatusId]<br/>and {SRStatus}.[Label] in (‘Pending Approval’)<br/>   inner join {User} on {User}.[Id]={SRJournal}.[ModifiedBy]<br/>   inner join {User} Pickup on Pickup.[Id]={SRJournal}.[PickUpBy]<br/>   inner join {EntityGroup} on {EntityGroup}.[Id]={SRJournal}.[EntityGroupId]<br/>   inner join {SRPriority} on {SRPriority}.[Id]={SRJournal}.[PriorityId]<br/>where<br/>   {SRJournal}.[ApproverId]=@PUserId</span><span id="c69a" class="mm le iq mi b gy mr mo l mp mq">union<br/>-- pending for my process<br/>SELECT<br/>   {SRJournal}.* ,<br/>   {EntityGroup}.[EntityDesc],<br/>   {SRPriority}.[PriorityName],<br/>   {SRStatus}.[Label],<br/>   {User}.[Name],<br/>   Pickup.[Name]<br/>from {SRJournal}<br/>   inner join {SRStatus} on {SRStatus}.[Id]={SRJournal}.[StatusId]<br/>and {SRStatus}.[Label] in (‘Approved’,’In Process’,’Info Ready’)<br/>   inner join {User} on {User}.[Id]={SRJournal}.[ModifiedBy]<br/>   inner join {User} Pickup on Pickup.[Id]={SRJournal}.[PickUpBy]<br/>   inner join {SRPriority} on {SRPriority}.[Id]={SRJournal}.[PriorityId]<br/>   inner join {EntityGroup} on {EntityGroup}.[Id]={SRJournal}.[EntityGroupId]<br/>where<br/>   {SRJournal}.[EntityGroupId] in (<br/>      select {SRUserProfileDtl}.[EntityGroupId]<br/>      from {SRUserProfileDtl} <br/>      where {SRUserProfileDtl}.[UserId]=@PUserId<br/>   )</span></pre><p id="cce3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我看到的第一个问题是使用了注释<code class="fe ms mt mu mi b">-- comment</code>而不是<code class="fe ms mt mu mi b">/* comment */</code>。在这种情况下，问题是OutSystems将查询转换成一行代码，这将当前使用的注释转换成一个完整的注释查询，而不是三个标识不同查询的小注释。此问题仅在编译后发生，测试查询功能将只返回结果集。</p><p id="97f9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第二个问题是这个查询很容易被清理和重写，因为这三个查询几乎是相似的。</p><p id="153a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第三个问题是“IN”运算符。在这种情况下，可以使用“or”运算符将运算符从查询中删除。</p><p id="1526" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我看到的第四个问题是<code class="fe ms mt mu mi b">{SRStatus}.[Label]</code>与硬编码的值相匹配。需要将其更改为<code class="fe ms mt mu mi b">{SRJournal}.[StatusId]</code>，并且应该与静态实体SRStatus中的标识符相匹配。</p><p id="8b9f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第五个阻碍查询转换为聚合的问题是<code class="fe ms mt mu mi b">IN (SELECT x.y FROM x WHERE x.y = z)</code>。最后一个问题可以通过将<code class="fe ms mt mu mi b">{SRUserProfileDtl}</code>添加到连接列表中，并将“GROUP BY”操作符添加到“SELECT”中的所有列来解决。由于<code class="fe ms mt mu mi b">{SRUserProfileDtl}</code>上的“左连接”操作符，这样可以避免添加重复项。</p><p id="a777" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">解决这些问题后，查询将变成:</p><pre class="kn ko kp kq gt mh mi mj mk aw ml bi"><span id="c4c0" class="mm le iq mi b gy mn mo l mp mq">SELECT <br/> {SRJournal}.* ,<br/> {EntityGroup}.[EntityDesc],<br/> {SRPriority}.[PriorityName],<br/> {SRStatus}.[Label],<br/> {User}.[Name],<br/> Pickup.[Name]</span><span id="3f11" class="mm le iq mi b gy mr mo l mp mq">FROM {SRJournal}<br/> INNER JOIN {SRStatus} ON {SRStatus}.[Id] = {SRJournal}.[StatusId]<br/> INNER JOIN {User} ON {User}.[Id] = {SRJournal}.[ModifiedBy]<br/> INNER JOIN {User} Pickup ON Pickup.[Id] = {SRJournal}.[PickUpBy]<br/> INNER JOIN {EntityGroup} ON {EntityGroup}.[Id] = {SRJournal}.[EntityGroupId]<br/> INNER JOIN {SRPriority} ON {SRPriority}.[Id] = {SRJournal}.[PriorityId]<br/> LEFT JOIN {SRUserProfileDtl} ON {SRUserProfileDtl}.[EntityGroupId] = {EntityGroup}.[Id]<br/>WHERE <br/>(<br/> /* OPEN BY ME */<br/> {SRJournal}.[ModifiedBy] = @PUserId AND (<br/>  {SRJournal}.[StatusId] = @PendingApprovalId OR <br/>  {SRJournal}.[StatusId] = @RequestForInformationId<br/> )<br/>) OR (<br/> /* PENDING MY APPROVAL */<br/> {SRJournal}.[ApproverId] = @PUserId AND <br/> {SRJournal}.[StatusId] = @PendingApprovalId<br/>) OR (<br/> /* PENDING FOR MY PROCESS */<br/> (<br/>  {SRUserProfileDtl}.[UserId] = @PUserId<br/> ) AND (<br/>  {SRJournal}.[StatusId] = @ApprovedId OR <br/>  {SRJournal}.[StatusId] = @InProcessId OR <br/>  {SRJournal}.[StatusId] = @InfoReadyId<br/> )<br/>)<br/>GROUP BY<br/> {SRJournal}.* ,<br/> {EntityGroup}.[EntityDesc],<br/> {SRPriority}.[PriorityName],<br/> {SRStatus}.[Label],<br/> {User}.[Name],<br/> Pickup.[Name]</span></pre><p id="bc03" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">既然已经清理并重写了查询，那么将SQL查询转换成聚合就容易多了。</p><p id="c7d6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">聚合将类似于以下内容:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi mv"><img src="../Images/12ea978d0c705ddf82de035119bae73f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ATcGml84jjiD-ja00oy22g.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">“源”标签</figcaption></figure><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi mw"><img src="../Images/0a4c59f2d1b8e496fd44ef163e340b1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Yxoqs6e2p5cidb1nwEcf1g.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">筛选器选项卡表达式</figcaption></figure><p id="d99d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我希望这个简短的解释有助于系统开发人员更经常地使用集合。</p></div></div>    
</body>
</html>