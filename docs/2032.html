<html>
<head>
<title>React Code Splitting in 2019</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">2019年反应代码拆分</h1>
<blockquote>原文：<a href="https://itnext.io/react-code-splitting-in-2019-9a5d2776c502?source=collection_archive---------3-----------------------#2019-03-19">https://itnext.io/react-code-splitting-in-2019-9a5d2776c502?source=collection_archive---------3-----------------------#2019-03-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="f5d0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">都2019年了！每个人都认为他们知道代码分解。所以——让我们仔细检查一下！</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/77312c873eb773ad008c99a380723369.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*45StAVNxh3EOkV3lvFNk5g.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated"><a class="ae lb" href="http://www.pacesettersinitiative.org/broken-pieces/" rel="noopener ugc nofollow" target="_blank">http://www.pacesettersinitiative.org/broken-pieces/</a></figcaption></figure><h1 id="5ef4" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">代码拆分代表什么？</h1><p id="e92d" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">简而言之，代码拆分就是不加载整个元素，而是只加载其中的一部分。当你阅读这个页面时，你不必加载整个网站。当您从数据库中选择单个行时，您不必获取所有数据。<em class="mf">明显的</em>？代码分割也很明显，它不仅仅是关于你的数据，而是你的代码。</p><h1 id="9b36" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">是谁在做代码拆分？</h1><p id="312b" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">反应。懒惰？不，它只是在使用它。代码拆分是在捆绑级别完成的——网络包、包，或者在“本机”esm模块的情况下，只是您的文件系统。代码分割只是文件，你可以“以后”在某个地方加载的文件。</p><h1 id="1f18" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">谁在使用代码分割？</h1><p id="d4fc" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated"><code class="fe mg mh mi mj b">React.lazy</code>正在使用它。只是<strong class="jp ir">使用</strong>你的捆绑器的代码分割。在渲染时调用<code class="fe mg mh mi mj b">import</code>。仅此而已。</p><h1 id="cd98" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">React-loadable是什么意思？</h1><p id="9501" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated"><code class="fe mg mh mi mj b">React.lazy</code>取而代之。并且提供了更多的功能，像<code class="fe mg mh mi mj b">Suspense</code>来控制加载状态。所以——用<code class="fe mg mh mi mj b">React.Lazy</code>代替。</p><blockquote class="mk ml mm"><p id="78ba" class="jn jo mf jp b jq jr js jt ju jv jw jx mn jz ka kb mo kd ke kf mp kh ki kj kk ij bi translated">是的，就这些。感谢您的阅读，祝您愉快。</p></blockquote></div><div class="ab cl mq mr hu ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="ij ik il im in"><h1 id="e0c9" class="lc ld iq bd le lf mx lh li lj my ll lm ln mz lp lq lr na lt lu lv nb lx ly lz bi translated">为什么文章还没写完？</h1><p id="1886" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">嗯……有一些关于React.lazy和代码分割的灰色地带，我忘了说了。</p><h1 id="a3c0" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">灰色区域1–测试</h1><p id="857d" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">测试“React.lazy”并不容易，因为它的<em class="mf">异步特性</em>。<code class="fe mg mh mi mj b">mount(MyLazyComponent)</code>的结果只会是“空”，只要 <code class="fe mg mh mi mj b">MyLazy</code>后面的<code class="fe mg mh mi mj b">Component</code>、<em class="mf">，就是<strong class="jp ir">还没有加载。</strong><strong class="jp ir"/>即使是——<code class="fe mg mh mi mj b">import</code>返回，<code class="fe mg mh mi mj b">lazy</code>接受，<strong class="jp ir">承诺</strong>，总是在<strong class="jp ir">下一个滴答</strong>执行。所以——你永远不会在<strong class="jp ir">当前节拍</strong>中得到分量。这是法律！</em></p><pre class="km kn ko kp gt nc mj nd ne aw nf bi"><span id="bf6c" class="ng ld iq mj b gy nh ni l nj nk">const LazyComponent = lazy(() =&gt; import('/path/to/dynamic/component'));<br/>const Fallback = () =&gt; &lt;div /&gt;;<br/>const SuspenseComponent = () =&gt; (<br/>    &lt;Suspense fallback={&lt;Fallback /&gt;}&gt;<br/>      &lt;LazyComponent /&gt;<br/>    &lt;/Suspense&gt;<br/>);</span><span id="91cf" class="ng ld iq mj b gy nl ni l nj nk">const wrapper = mount(&lt;SuspenseComponent /&gt;)<br/>expect(wrapper.find('Fallback')).to.have.lengthOf(1)<br/>expect(wrapper.find('DynamicComponent')).to.have.lengthOf(0)<br/>// ^ not loaded</span><span id="ba88" class="ng ld iq mj b gy nl ni l nj nk"><strong class="mj ir">await wrapper.waitUntilLazyLoaded()</strong></span><span id="76ee" class="ng ld iq mj b gy nl ni l nj nk">expect(wrapper.find('Fallback')).to.have.lengthOf(0)<br/>expect(wrapper.find('DynamicComponent')).to.have.lengthOf(1)<br/>// ^ loaded!</span></pre><p id="3e3d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">建议的解决方案？你可能不相信，但建议的解决方案是使用<strong class="jp ir">同步标签</strong>。</p><div class="nm nn gp gr no np"><a href="https://github.com/facebook/react/pull/14626" rel="noopener  ugc nofollow" target="_blank"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd ir gy z fp nu fr fs nv fu fw ip bi translated">gaearon Pull请求#14626 facebook/react支持为lazy()同步名称</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">为什么不呢？目前，由于竞争条件(状态设置为“已解决”,但是……,它们会因一个令人困惑的错误而失败</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">github.com</p></div></div><div class="ny l"><div class="nz l oa ob oc ny od kv np"/></div></div></a></div><pre class="km kn ko kp gt nc mj nd ne aw nf bi"><span id="cbae" class="ng ld iq mj b gy nh ni l nj nk">const LazyText = lazy(() =&gt; ({<br/>   <strong class="mj ir">then</strong>(cb) {   <br/>      cb({default: Text});<br/>      // this is "sync" thenable<br/>   },<br/>}));     </span><span id="bc6e" class="ng ld iq mj b gy nl ni l nj nk">const root = ReactTestRenderer.create(<br/>  &lt;Suspense fallback={&lt;Text text="Loading..." /&gt;}&gt;          <br/>     &lt;LazyText text="Hi" /&gt; // this lazy is not very lazy<br/>  &lt;/Suspense&gt;,<br/>);</span></pre><p id="b975" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将导入函数转换成记忆的同步名称并不困难。</p><pre class="km kn ko kp gt nc mj nd ne aw nf bi"><span id="b5ee" class="ng ld iq mj b gy nh ni l nj nk">const syncImport = (importFn) =&gt; {<br/>   let preloaded = undefined;<br/>   const promise = importFn().then(module =&gt; preloaded = module);<br/>   // ^ "auto" import and "cache" promise   </span><span id="b2d9" class="ng ld iq mj b gy nl ni l nj nk">   return () =&gt; preloaded ? { then: () =&gt; preloaded } : promise;<br/>   // ^ return sync thenable then possible<br/>}</span><span id="eb76" class="ng ld iq mj b gy nl ni l nj nk">const lazyImport = isNode ? syncImport : a =&gt; a; <br/>// ^ sync for node, async for browser</span><span id="961c" class="ng ld iq mj b gy nl ni l nj nk">const LazyComponent = React.lazy(lazyImport(() =&gt; import('./file'));</span></pre><h1 id="ceb7" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">灰色区域2–SSR</h1><blockquote class="mk ml mm"><p id="3c0b" class="jn jo mf jp b jq jr js jt ju jv jw jx mn jz ka kb mo kd ke kf mp kh ki kj kk ij bi translated">如果你不需要SSR请继续阅读文章！</p></blockquote><p id="7aae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mg mh mi mj b">React.lazy</code>是SSR友好的。但是它需要<code class="fe mg mh mi mj b">Suspense</code>才能工作，<code class="fe mg mh mi mj b">Suspense</code>是<strong class="jp ir">而不是</strong>服务器端友好的。</p><p id="b043" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有两种解决方案:</p><ul class=""><li id="5e74" class="oe of iq jp b jq jr ju jv jy og kc oh kg oi kk oj ok ol om bi translated">把<code class="fe mg mh mi mj b">Suspense</code>换成<code class="fe mg mh mi mj b">Fragment</code>，只是<strong class="jp ir">模仿</strong>出来。然后-使用改变版本同步<code class="fe mg mh mi mj b">thenable</code>使懒惰也同步。</li></ul><pre class="km kn ko kp gt nc mj nd ne aw nf bi"><span id="399b" class="ng ld iq mj b gy nh ni l nj nk">import React from 'react';</span><span id="03ab" class="ng ld iq mj b gy nl ni l nj nk">const realLazy = React.lazy;<br/>React.lazy = importer =&gt; realLazy(syncImport(importer));<br/>React.Suspense = React.Fragment; // :P</span><span id="0769" class="ng ld iq mj b gy nl ni l nj nk">// ^ React SSR just got fixed.</span></pre><p id="cd82" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是一个很好的选择，但是它对客户端不太友好。为什么？让我们定义第二种可能的解决方案:</p><ul class=""><li id="17e0" class="oe of iq jp b jq jr ju jv jy og kc oh kg oi kk oj ok ol om bi translated"><strong class="jp ir">使用专门的库</strong>来跟踪使用过的脚本、组块和样式，并在客户端加载它们(尤其是样式！)在进行水合反应之前。否则——你会呈现出空洞，而不是代码分离的组件。再一次，你没有加载你刚刚分割的代码，所以你不能渲染任何你将要渲染的东西。</li></ul><h2 id="19aa" class="ng ld iq bd le on oo dn li op oq dp lm jy or os lq kc ot ou lu kg ov ow ly ox bi translated">看看代码分割库</h2><ul class=""><li id="88d1" class="oe of iq jp b jq ma ju mb jy oy kc oz kg pa kk oj ok ol om bi translated"><a class="ae lb" href="https://www.npmjs.com/package/react-universal-component" rel="noopener ugc nofollow" target="_blank">通用组件</a>——最古老且仍可维护的库。它“发明”了代码分割，并教会了Webpack代码分割。</li><li id="2872" class="oe of iq jp b jq pb ju pc jy pd kc pe kg pf kk oj ok ol om bi translated"><a class="ae lb" href="https://www.npmjs.com/package/react-loadable" rel="noopener ugc nofollow" target="_blank">React-loadable</a>–<strong class="jp ir">非常受欢迎，但是没有维护的库。让代码吐槽成为一件流行的事情。问题是封闭的，所以周围没有社区。</strong></li><li id="5cb4" class="oe of iq jp b jq pb ju pc jy pd kc pe kg pf kk oj ok ol om bi translated">可加载组件–一个功能完整的库，使用起来很愉快，拥有最活跃的社区。</li><li id="b014" class="oe of iq jp b jq pb ju pc jy pd kc pe kg pf kk oj ok ol om bi translated"><a class="ae lb" href="https://www.npmjs.com/package/react-imported-component" rel="noopener ugc nofollow" target="_blank">导入组件</a>–单个库，不绑定到Webpack，即能够处理包裹或esm。</li><li id="f2e2" class="oe of iq jp b jq pb ju pc jy pd kc pe kg pf kk oj ok ol om bi translated"><a class="ae lb" href="https://www.npmjs.com/package/react-async-component" rel="noopener ugc nofollow" target="_blank">React-async-component</a>–已经死了的库(但仍然很流行)，它对代码分割、自定义React树遍历和SSR的所有方面都产生了重大影响。</li><li id="5124" class="oe of iq jp b jq pb ju pc jy pd kc pe kg pf kk oj ok ol om bi translated"><em class="mf">另一个库—</em><strong class="jp ir"><em class="mf">有</em> </strong> <em class="mf">许多库，其中许多没有通过Webpack evolution或React 16——我没有在这里列出它们，但是如果你知道一个好的候选库——就给我发邮件。</em></li></ul><h1 id="4dfc" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">选哪个图书馆？</h1><p id="ea5e" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">它很简单——不是反应式加载的——它很难维护，而且已经过时，即使它仍然很流行。<em class="mf">(再次感谢你推广代码分割)</em></p><ul class=""><li id="8a5a" class="oe of iq jp b jq jr ju jv jy og kc oh kg oi kk oj ok ol om bi translated">可加载组件–可能是一个非常好的选择。它写得很好，积极维护，支持开箱即用的一切。支持“全动态导入”，允许你根据给定的道具导入文件，但是<em class="mf">不可类型化</em>。<strong class="jp ir">支持暂停</strong>，所以可以替换<code class="fe mg mh mi mj b">React.lazy</code>。</li><li id="44df" class="oe of iq jp b jq pb ju pc jy pd kc pe kg pf kk oj ok ol om bi translated"><strong class="jp ir">通用组件</strong>——实际上是完全动态导入的“发明者”——只要<strong class="jp ir">他们在Webpack </strong>中实现了它。还有许多其他低层次的东西，像<em class="mf"> css语块、报告语块和其他语块</em>–<strong class="jp ir">他们做到了</strong>。这个库的作者也是webpack团队的成员。我会说——这个库有点硬，有点不太用户友好。可加载组件文档是无与伦比的。如果不使用这个库，那么阅读文档是值得的——有很多细节你应该知道…</li><li id="e21e" class="oe of iq jp b jq pb ju pc jy pd kc pe kg pf kk oj ok ol om bi translated"><strong class="jp ir">React-imported-component</strong>–有点<em class="mf">古怪</em>。它是<em class="mf"> bundler独立的</em>，所以它永远不会坏(没有什么可坏的)，可以与Webpack 5和55一起工作，但是<strong class="jp ir">有一个成本</strong>。不支持完全动态导入，如<code class="fe mg mh mi mj b">React.lazy</code>，因此是可类型化的。另外<strong class="jp ir">支持悬念</strong>。在SSR上使用<code class="fe mg mh mi mj b">synchronous thenables</code>。它也有完全不同的CSS方法，和完美的<strong class="jp ir">流渲染</strong>支持。</li></ul><p id="05c3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">也许解释这个库的“成本”更好——简而言之——它可能会推迟TTI(交互时间)。</p><p id="992b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">SSR期间的“普通”库会将所有使用过的脚本添加到页面主体，并且您将能够<strong class="jp ir">以并行方式</strong>加载所有脚本，并且一旦它们都准备好了，就“水合”您的应用程序。</p><blockquote class="pg"><p id="528a" class="ph pi iq bd pj pk pl pm pn po pp kk dk translated">TTI会是<code class="fe mg mh mi mj b">max(mainTime, chunk1Time, chunk2Time)</code></p></blockquote><p id="1ad8" class="pw-post-body-paragraph jn jo iq jp b jq pq js jt ju pr jw jx jy ps ka kb kc pt ke kf kg pu ki kj kk ij bi translated"><code class="fe mg mh mi mj b">imported</code>是“bunder-independent”，而<strong class="jp ir">不知道</strong>要加载的文件名。因此，它将首先等待主包加载，然后从主包内部调用原来的“<code class="fe mg mh mi mj b">imports</code>”，让<code class="fe mg mh mi mj b">bundler</code>加载块，就像在简单的<code class="fe mg mh mi mj b">React.lazy</code>中一样。这是一个非常可靠的解决方案，但是，你必须先装载主捆扎机。</p><blockquote class="pg"><p id="bf2d" class="ph pi iq bd pj pk pl pm pn po pp kk dk translated">TTI会是<code class="fe mg mh mi mj b">mainTime + max(chunk1Time, chunk2Time)</code></p></blockquote><p id="f5b6" class="pw-post-body-paragraph jn jo iq jp b jq pq js jt ju pr jw jx jy ps ka kb kc pt ke kf kg pu ki kj kk ij bi translated">而且，说实话，^that^可能只比t43慢两倍t44。</p><p id="ec19" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">除了一些实现细节——列出的库在质量或受欢迎程度上没有区别，我们都是好朋友——所以用心挑选一个吧。</p><div class="nm nn gp gr no np"><a href="https://github.com/smooth-code/loadable-components" rel="noopener  ugc nofollow" target="_blank"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd ir gy z fp nu fr fs nv fu fw ip bi translated">平滑代码/可加载组件</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">反应代码分裂使✂️✨.变得容易通过在…上创建帐户，为平滑代码/可加载组件的开发做出贡献</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">github.com</p></div></div><div class="ny l"><div class="pv l oa ob oc ny od kv np"/></div></div></a></div><div class="nm nn gp gr no np"><a href="https://github.com/theKashey/react-imported-component" rel="noopener  ugc nofollow" target="_blank"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd ir gy z fp nu fr fs nv fu fw ip bi translated">kashey/react-导入组件</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">适用于任何延迟组件的独立于Bundler的解决方案，可实现更好的SSR、代码分割和React-Hot-Loader。没有✨…</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">github.com</p></div></div><div class="ny l"><div class="pw l oa ob oc ny od kv np"/></div></div></a></div><div class="nm nn gp gr no np"><a href="https://github.com/faceyspacey/react-universal-component" rel="noopener  ugc nofollow" target="_blank"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd ir gy z fp nu fr fs nv fu fw ip bi translated">面空间/反应通用组件</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">🚀React通用组件的最终答案:同步SSR +代码拆分…</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">github.com</p></div></div><div class="ny l"><div class="px l oa ob oc ny od kv np"/></div></div></a></div><h1 id="8a37" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">灰色区域3–混合渲染</h1><p id="318c" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">SSR是个好东西，但是你知道很难。小项目可能希望有一个SSR——有很多理由需要它——但不想建立和维护它。</p><blockquote class="mk ml mm"><p id="6f4d" class="jn jo mf jp b jq jr js jt ju jv jw jx mn jz ka kb mo kd ke kf mp kh ki kj kk ij bi translated">SSR可能会非常非常难。如果你想快速取胜，试试razzle或Next.js。</p></blockquote><p id="d0d0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，SSR最简单的解决方案，尤其是简单的SPA，应该是<strong class="jp ir">预渲染</strong>。比如在浏览器中打开你的SPA，点击“保存”按钮。比如:</p><ul class=""><li id="9453" class="oe of iq jp b jq jr ju jv jy og kc oh kg oi kk oj ok ol om bi translated"><a class="ae lb" href="https://github.com/stereobooster/react-snap" rel="noopener ugc nofollow" target="_blank"> React-snap </a> —使用<a class="ae lb" href="https://github.com/GoogleChrome/puppeteer" rel="noopener ugc nofollow" target="_blank">木偶师</a>在“浏览器”中渲染你的页面并保存结果</li><li id="a24a" class="oe of iq jp b jq pb ju pc jy pd kc pe kg pf kk oj ok ol om bi translated">Rendertron——做同样的事情，但是以不同的方式(在谷歌云中)。</li></ul><p id="945d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">预渲染是没有“服务器”的“SSR”。是SSR使用客户端。神奇！开箱即用… …但不是为了代码分离。</p><p id="0083" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以——您只需在浏览器中呈现您的页面，保存HTML，并请求加载相同的内容。但是<strong class="jp ir">服务器端特定代码</strong>(收集所有使用过的块)没有被使用，因为<strong class="jp ir">没有服务器</strong>！</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi py"><img src="../Images/01ff08eaaeb4d159e68ad4244e159fd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fGhcQxv_LWICTqlZ5hiKTw.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">反应快照文档</figcaption></figure><p id="96b5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上一部分中，我指出了在收集关于使用的块的信息方面绑定到webpack的库——它们根本不能处理混合渲染。</p><blockquote class="mk ml mm"><p id="7f59" class="jn jo mf jp b jq jr js jt ju jv jw jx mn jz ka kb mo kd ke kf mp kh ki kj kk ij bi translated">react-snap部分支持可加载组件版本2(与当前版本5不兼容)。支持没有了。</p></blockquote><p id="9eb0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">可以处理这种情况，只要它不受捆绑者/一方的约束。所以没有区别——不管是SSR还是Hybrid——它甚至可以在混合模式下工作，但只适用于<code class="fe mg mh mi mj b">react-snap</code>可以提供的混合模式，只要它为<em class="mf">“状态水合”</em>提供一些钩子，而<code class="fe mg mh mi mj b">rendertron</code>只是<em class="mf">渲染一切</em>。</p><blockquote class="mk ml mm"><p id="131d" class="jn jo mf jp b jq jr js jt ju jv jw jx mn jz ka kb mo kd ke kf mp kh ki kj kk ij bi translated">写这篇文章时发现了<code class="fe mg mh mi mj b">react-imported-componen</code>使用react-snap的能力，在 — <a class="ae lb" href="https://github.com/theKashey/react-imported-component/tree/master/examples/hybrid/react-snap" rel="noopener ugc nofollow" target="_blank">见示例</a>之前<strong class="jp ir">并不知道。这很容易。</strong></p></blockquote><p id="fff0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里你不得不使用另一个解决方案，它只是<strong class="jp ir">垂直于</strong>所有其他的库。</p><h2 id="fc14" class="ng ld iq bd le on oo dn li op oq dp lm jy or os lq kc ot ou lu kg ov ow ly ox bi translated">反应预渲染组件</h2><p id="6e67" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">这个库是为<em class="mf">部分水合</em>而创建的，可以部分再水合你的应用，保持其余部分仍然<em class="mf">脱水</em>。它适用于SSR和混合渲染器，没有任何区别。</p><p id="3955" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个想法很简单:</p><ul class=""><li id="74a4" class="oe of iq jp b jq jr ju jv jy og kc oh kg oi kk oj ok ol om bi translated">在SSR期间——渲染组件，用<div/>包装</li><li id="8afb" class="oe of iq jp b jq pb ju pc jy pd kc pe kg pf kk oj ok ol om bi translated">在客户端——找到那个div，使用<code class="fe mg mh mi mj b">innerHTML</code>,直到<code class="fe mg mh mi mj b">Component</code>准备好替换<em class="mf">死的</em> HTML。</li><li id="5ede" class="oe of iq jp b jq pb ju pc jy pd kc pe kg pf kk oj ok ol om bi translated">您不必加载，并等待带有分割组件的块加载到<code class="fe mg mh mi mj b">"NOT render a <em class="mf">white hole</em> instead of it"</code>——使用预先呈现的HTML。你从服务器上得到的代码已经包含了你需要显示的所有HTML。这就是为什么我们必须在<code class="fe mg mh mi mj b">hydrate</code>之前等待所有的块加载——以匹配服务器渲染的HTML。这就是为什么我们可以使用服务器渲染的HTML片段，直到客户端没有准备好。</li></ul><blockquote class="mk ml mm"><p id="c3a4" class="jn jo mf jp b jq jr js jt ju jv jw jx mn jz ka kb mo kd ke kf mp kh ki kj kk ij bi translated">这就是为什么我们必须在hydrate之前等待所有数据块加载完毕，以匹配服务器呈现的HTML。这就是为什么我们可以使用服务器渲染的HTML片段，直到客户端没有准备好——它相当于我们只准备生产的一个。</p></blockquote><pre class="km kn ko kp gt nc mj nd ne aw nf bi"><span id="8ff6" class="ng ld iq mj b gy nh ni l nj nk">import {PrerenderedComponent} from 'react-prerendered-component';</span><span id="012a" class="ng ld iq mj b gy nl ni l nj nk">const importer = memoizeOne(() =&gt; import('./Component'));<br/>// ^ it's very important to keep the "one" promise</span><span id="631c" class="ng ld iq mj b gy nl ni l nj nk">const Component = React.lazy(importer); <br/>// or use any other library with ".prefetch" support<br/>// all libraries has it (more or less)</span><span id="8681" class="ng ld iq mj b gy nl ni l nj nk">const App = () =&gt; (<br/>  &lt;PrerenderedComponent live={importer()}&gt; <br/>   {/* ^ shall return the same promise */ }<br/>    &lt;Component /&gt; <br/>   {/* ^ would be rendered when component goes "live" */ }<br/>  &lt;/PrerenderedComponent&gt;<br/>);</span></pre><p id="c3f4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">还有另一篇关于它的文章，以前写的，没有混合渲染的想法:</p><div class="nm nn gp gr no np"><a href="https://medium.com/@antonkorzunov/react-server-side-code-splitting-made-again-a61f8cbbd64b" rel="noopener follow" target="_blank"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd ir gy z fp nu fr fs nv fu fw ip bi translated">React服务器端代码拆分已完成..又</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">React代码拆分在一年前就成为了一件事。从那时起，我们正在寻找新的方法来代码分割和延迟组件…</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">medium.com</p></div></div><div class="ny l"><div class="pz l oa ob oc ny od kv np"/></div></div></a></div><h1 id="9273" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">TLDR？</h1><ul class=""><li id="82b3" class="oe of iq jp b jq ma ju mb jy oy kc oz kg pa kk oj ok ol om bi translated">不要使用react-loadable，它不会增加任何有价值的价值</li><li id="a36d" class="oe of iq jp b jq pb ju pc jy pd kc pe kg pf kk oj ok ol om bi translated">懒惰是好的，但是太简单了。</li><li id="4bf4" class="oe of iq jp b jq pb ju pc jy pd kc pe kg pf kk oj ok ol om bi translated">SSR是一件很难的事情，你应该知道</li><li id="16ba" class="oe of iq jp b jq pb ju pc jy pd kc pe kg pf kk oj ok ol om bi translated">混合木偶师驱动的渲染是一件事。有时甚至更难的事情。</li></ul><p id="00a1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请将kudos发送至:</p><p id="055e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="qa qb ep" href="https://medium.com/u/2210cd491fe0?source=post_page-----9a5d2776c502--------------------------------" rel="noopener" target="_blank">伯格·格雷格</a> —可加载组件作者</p><p id="720d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Sean Matheson—react-async-component(即使他们有点死)</p><p id="d49f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">詹姆斯·吉尔摩和<a class="qa qb ep" href="https://medium.com/u/9ef1379caffc?source=post_page-----9a5d2776c502--------------------------------" rel="noopener" target="_blank">扎克·杰克森</a>——通用部件的创造者</p><p id="4274" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="qa qb ep" href="https://medium.com/u/742f2d568062?source=post_page-----9a5d2776c502--------------------------------" rel="noopener" target="_blank"> Anton Korzunov </a> —针对react-imported和prerendered组件</p><p id="5ba8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以及所有那些发明新方法和新原则的人，他们使我们的生活有时更容易，有时更困难。</p><blockquote class="pg"><p id="7de4" class="ph pi iq bd pj pk pl pm pn po pp kk dk translated">还在为React高兴懒？</p><p id="f2b8" class="ph pi iq bd pj pk pl pm pn po pp kk dk translated">很酷，但我们必须更深入。</p></blockquote><figure class="qc qd qe qf qg kq"><div class="bz fp l di"><div class="qh qi l"/></div></figure></div></div>    
</body>
</html>