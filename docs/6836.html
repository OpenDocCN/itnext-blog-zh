<html>
<head>
<title>The Rules of Clean and (Mostly) Painless Database Migrations</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">干净和(大部分)无痛的数据库迁移规则</h1>
<blockquote>原文：<a href="https://itnext.io/the-rules-of-clean-and-mostly-painless-migrations-75b8b0dec194?source=collection_archive---------2-----------------------#2022-03-15">https://itnext.io/the-rules-of-clean-and-mostly-painless-migrations-75b8b0dec194?source=collection_archive---------2-----------------------#2022-03-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/3df3724754567f120d8f40135351a610.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*y5rnY1eme7A98hdI"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@kbrembo?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> K B </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="8e8a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le">注意:这是数据库迁移系列文章的第2部分，共2部分。如果您已经知道什么是数据库迁移，以及为什么我们使用它们来管理模式，那么您可以继续阅读第2部分。如果您想了解我们为什么需要迁移以及我们为什么需要针对它们的“规则”，请查看第1部分:“什么是数据库迁移？”</em>T9<em class="le">。</em></p><p id="4222" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下是干净且(大部分)无痛的迁移需要遵循的规则。其中有些比其他的更重要，有些人可能觉得有些没必要。我鼓励你和你的团队讨论这些，并决定你自己的一套通用规则。有一套一致同意的规则会对你的过程有很大的改善。</p><ol class=""><li id="c1b7" class="lf lg it ki b kj kk kn ko kr lh kv li kz lj ld lk ll lm ln bi translated"><strong class="ki iu">所有现有代码在迁移前后都必须工作。</strong>这对于零停机部署非常重要，因为零停机部署是逐步展开的。如果您需要删除列/表或重命名它们等，应该分阶段完成。首先部署可用于新旧模式的代码。然后部署迁移以删除/重命名。然后部署只适用于新模式的代码。通过这种方式，生产应用程序不需要任何停机时间，并且应用程序可以在迁移期间继续运行。</li><li id="0a8a" class="lf lg it ki b kj lo kn lp kr lq kv lr kz ls ld lk ll lm ln bi translated"><strong class="ki iu">在不同的场景中多次测试您的迁移</strong>，以确保它们具有弹性！用最新的数据库测试它们，用空数据库测试它们，用部分更新的数据库测试它们。我建议在您的CI/CD和测试脚本中这样做。一旦自动化，开发人员只需要在他们的本地数据库上进行测试，然后CI将在其他场景中进行验证。</li><li id="1677" class="lf lg it ki b kj lo kn lp kr lq kv lr kz ls ld lk ll lm ln bi translated"><strong class="ki iu">应尽量减少长期运行的锁定迁移，并在美国工作时间之外部署。</strong>如果可能的话，尝试将迁移查询分解成一系列更小的查询，以避免长时间运行的表、行和列的锁。如果迁移有可能锁定表或耗尽资源(如CPU)，请确保在工作时间之外进行部署(并记住不同的美国时区。犹他州的下午7点是阿拉斯加的下午5点，夏威夷的下午3点。犹他州的早上6点是纽约的早上8点)。</li><li id="8fb8" class="lf lg it ki b kj lo kn lp kr lq kv lr kz ls ld lk ll lm ln bi translated"><strong class="ki iu">所有的迁移都应该是幂等的</strong>，这意味着它们可以运行多次而不会失败。如果它们会影响模式上的NOOP，那么它们应该报告成功，而不对模式进行任何更改。` column _存在？`和`表_存在吗？“你最好的朋友在这里吗？</li><li id="cc54" class="lf lg it ki b kj lo kn lp kr lq kv lr kz ls ld lk ll lm ln bi translated"><strong class="ki iu">避免在代码</strong>中使用 <code class="fe lt lu lv lw b">SELECT *</code> <strong class="ki iu">，更喜欢显式请求列。这减少了返回新的(意外的)列而导致代码错误的情况。它还避免了添加新的非常昂贵的列的情况，这会导致数据库发送负担，并且应用程序代码无论如何也不会使用它。</strong></li></ol><h1 id="bde6" class="lx ly it bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">常见操作的步骤</h1><p id="ded4" class="pw-post-body-paragraph kg kh it ki b kj mv kl km kn mw kp kq kr mx kt ku kv my kx ky kz mz lb lc ld im bi translated">随着数据库规模和复杂性的增长，以前不是问题的东西可能会变成问题。以下提示将帮助您安全地迁移现有的大型数据库。</p><p id="2615" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">其中许多步骤需要在不同的迁移/部署中完成。</p><h1 id="8e91" class="lx ly it bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">桌子</h1><h2 id="94ca" class="na ly it bd lz nb nc dn md nd ne dp mh kr nf ng ml kv nh ni mp kz nj nk mt nl bi translated">创建表格</h2><p id="c9e9" class="pw-post-body-paragraph kg kh it ki b kj mv kl km kn mw kp kq kr mx kt ku kv my kx ky kz mz lb lc ld im bi translated">如果新表将有一个指向现有表的外键，您应该分两步进行迁移:</p><ol class=""><li id="4992" class="lf lg it ki b kj kk kn ko kr lh kv li kz lj ld lk ll lm ln bi translated">添加带有外键的表，但不要使其成为必需的</li><li id="aeed" class="lf lg it ki b kj lo kn lp kr lq kv lr kz ls ld lk ll lm ln bi translated">添加要求</li></ol><h2 id="5001" class="na ly it bd lz nb nc dn md nd ne dp mh kr nf ng ml kv nh ni mp kz nj nk mt nl bi translated">删除表格</h2><ol class=""><li id="8b4c" class="lf lg it ki b kj mv kn mw kr nm kv nn kz no ld lk ll lm ln bi translated">删除对表的所有引用(应用程序代码和视图、函数等)并部署</li><li id="8496" class="lf lg it ki b kj lo kn lp kr lq kv lr kz ls ld lk ll lm ln bi translated">做个数据库备份以防万一</li><li id="49cf" class="lf lg it ki b kj lo kn lp kr lq kv lr kz ls ld lk ll lm ln bi translated">删除<em class="le">其他</em>表中对此表的任何外键引用</li><li id="c22b" class="lf lg it ki b kj lo kn lp kr lq kv lr kz ls ld lk ll lm ln bi translated">放下桌子</li></ol><h2 id="3b04" class="na ly it bd lz nb nc dn md nd ne dp mh kr nf ng ml kv nh ni mp kz nj nk mt nl bi translated">重命名表格</h2><p id="a9fb" class="pw-post-body-paragraph kg kh it ki b kj mv kl km kn mw kp kq kr mx kt ku kv my kx ky kz mz lb lc ld im bi translated">尽可能避免这种情况。如果你必须这么做，试着安排一个维护/停工期。但是，您可以通过以下方式在不停机的情况下完成它:</p><ol class=""><li id="9fa0" class="lf lg it ki b kj kk kn ko kr lh kv li kz lj ld lk ll lm ln bi translated">使用正确的名称和与旧表相同的模式创建新表</li><li id="0965" class="lf lg it ki b kj lo kn lp kr lq kv lr kz ls ld lk ll lm ln bi translated">在旧表上创建触发器，以便在插入和更新时更新新表</li><li id="1a12" class="lf lg it ki b kj lo kn lp kr lq kv lr kz ls ld lk ll lm ln bi translated">将所有旧表格行复制到新表格</li><li id="f349" class="lf lg it ki b kj lo kn lp kr lq kv lr kz ls ld lk ll lm ln bi translated">仅使用新表部署应用程序版本</li><li id="7c96" class="lf lg it ki b kj lo kn lp kr lq kv lr kz ls ld lk ll lm ln bi translated">扔掉旧桌子</li></ol><h1 id="55b1" class="lx ly it bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">列</h1><h2 id="2deb" class="na ly it bd lz nb nc dn md nd ne dp mh kr nf ng ml kv nh ni mp kz nj nk mt nl bi translated">添加列</h2><ol class=""><li id="0ee2" class="lf lg it ki b kj mv kn mw kr nm kv nn kz no ld lk ll lm ln bi translated">添加没有默认值且不包含任何约束的列</li><li id="6ac2" class="lf lg it ki b kj lo kn lp kr lq kv lr kz ls ld lk ll lm ln bi translated">回填现有记录中的列值</li><li id="aa9a" class="lf lg it ki b kj lo kn lp kr lq kv lr kz ls ld lk ll lm ln bi translated">如果需要默认值，请在列上设置默认值</li><li id="bd4c" class="lf lg it ki b kj lo kn lp kr lq kv lr kz ls ld lk ll lm ln bi translated">添加您需要的任何约束</li></ol><h2 id="b3d3" class="na ly it bd lz nb nc dn md nd ne dp mh kr nf ng ml kv nh ni mp kz nj nk mt nl bi translated">更改列类型</h2><p id="300c" class="pw-post-body-paragraph kg kh it ki b kj mv kl km kn mw kp kq kr mx kt ku kv my kx ky kz mz lb lc ld im bi translated">如果旧类型对新类型是强制的，您可以就地更改它，但它通常会在此期间获得一个表上的锁，因此要考虑这种影响。最好是:</p><ol class=""><li id="ed8d" class="lf lg it ki b kj kk kn ko kr lh kv li kz lj ld lk ll lm ln bi translated">添加名为“${column}_new”的新列</li><li id="4b4e" class="lf lg it ki b kj lo kn lp kr lq kv lr kz ls ld lk ll lm ln bi translated">设置触发器，以便在插入或更新时将任何旧列值写入新列</li><li id="5786" class="lf lg it ki b kj lo kn lp kr lq kv lr kz ls ld lk ll lm ln bi translated">用旧列中的所有现有值回填新列</li><li id="6363" class="lf lg it ki b kj lo kn lp kr lq kv lr kz ls ld lk ll lm ln bi translated">在事务中，将旧列重命名为“${column}_old”，将新列重命名为“${column}”</li><li id="3e41" class="lf lg it ki b kj lo kn lp kr lq kv lr kz ls ld lk ll lm ln bi translated">删除旧列</li></ol><h2 id="e4f6" class="na ly it bd lz nb nc dn md nd ne dp mh kr nf ng ml kv nh ni mp kz nj nk mt nl bi translated">删除列</h2><ol class=""><li id="75ee" class="lf lg it ki b kj mv kn mw kr nm kv nn kz no ld lk ll lm ln bi translated">删除对该列的所有引用(应用程序代码和视图、函数等)并部署</li><li id="516f" class="lf lg it ki b kj lo kn lp kr lq kv lr kz ls ld lk ll lm ln bi translated">做个数据库备份以防万一</li><li id="ce28" class="lf lg it ki b kj lo kn lp kr lq kv lr kz ls ld lk ll lm ln bi translated">删除该列</li></ol></div></div>    
</body>
</html>