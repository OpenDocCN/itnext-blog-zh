<html>
<head>
<title>Butterfly — A full-featured navigation framework that supports Activity、Fragment、DialogFragment and Compose UI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">butterfly——支持活动、片段、对话片段和组合UI的全功能导航框架</h1>
<blockquote>原文：<a href="https://itnext.io/butterfly-a-full-featured-navigation-framework-that-supports-activity-fragment-and-compose-664882bb125f?source=collection_archive---------3-----------------------#2022-11-22">https://itnext.io/butterfly-a-full-featured-navigation-framework-that-supports-activity-fragment-and-compose-664882bb125f?source=collection_archive---------3-----------------------#2022-11-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/3ed98d8b7909d80c00261e1b9cbd15a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WxGk7Rnktr_rcmEzp0NxTw.jpeg"/></div></div></figure><p id="4c72" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">GitHub:</strong><a class="ae kw" href="https://github.com/ssseasonnn/Butterfly" rel="noopener ugc nofollow" target="_blank">T3】蝴蝶T5】</a></p><p id="603c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">经过漫长的等待，Butterfly终于发布了新版本。此次更新为大家带来了一个全功能的导航框架，不仅支持Activity、Fragment和DialogFragment，还在Compose UI中加入了路由支持。至此，一个统一的路由框架诞生了。它不仅小巧灵活，而且功能强大。Butterfly提供了统一的API。你不需要关心目的地，在哪里。只要提供一个方案，Butterfly就会导航到正确的地方。</p><p id="517e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">不用多说，看看Butterfly支持的特性列表。</p><h1 id="93c2" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">特征表</h1><p id="be16" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">✅ <strong class="ka ir">支持导航活动</strong></p><p id="ff3c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">✅ <strong class="ka ir">支持导航片段</strong></p><p id="cb10" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">✅ <strong class="ka ir">支持导航对话片段</strong></p><p id="8c79" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> ✅支持导航撰写UI </strong></p><p id="2267" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> ✅支持导航行动</strong></p><p id="72fb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> ✅支持导航参数传递和解析</strong></p><p id="53f9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> ✅支持获取导航返回结果</strong></p><p id="add6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> ✅支援导航拦截器</strong></p><p id="9fc1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> ✅支持片段和构造UI backstack </strong></p><p id="b964" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> ✅支持片段和组合UI组管理</strong></p><p id="5de3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> ✅支持分片和组合UI启动模式，如SingleTop和ClearTop </strong></p><p id="3dde" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> ✅支持组件化通信</strong></p><h1 id="d40a" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">导航和参数传递</h1><p id="b0c4" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">眼见为实，耳听为虚。如此强大的功能，很少有它如何工作的例子。让我们来看看基本的导航功能:</p><pre class="ma mb mc md gt me mf mg bn mh mi bi"><span id="6efe" class="mj ky iq mf b be mk ml l mm mn">@Agile("test/activity")<br/>class AgileTestActivity : AppCompatActivity()<br/><br/>@Agile("test/fragment")<br/>class TestFragment : Fragment()<br/><br/>@Agile("test/dialog")<br/>class TestDialogFragment : DialogFragment()<br/><br/><br/>//Navigation<br/>Butterfly.agile("test/xxx").carry()<br/><br/>//Or navigate and get the returned data<br/>Butterfly.agile("test/xxx")<br/>    .carry {<br/>        val result = it.getStringExtra("result")<br/>        binding.tvResult.text = result<br/>    }</span></pre><p id="c967" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如上图，导航就是这么简单。无论目的地是什么，在哪里，只需要一个方案就可以完成路由跳转。方案没有限制。它可以是任何字符串或标准方案，如<strong class="ka ir"> butterfly://home/path </strong>等。</p><p id="82a4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在导航的过程中，参数传递也是必不可少的一部分。蝴蝶提供了两种方式供你选择。一种是拼接方案，比如<strong class="ka ir">测试/活动？paramA=123 &amp; paramB=abc </strong>，即<strong class="ka ir"> paramA </strong>和<strong class="ka ir"> paramB </strong>可以传送到目的地。另一种是通过调用<strong class="ka ir"> params </strong>方法来传递所需数据，比如:</p><pre class="ma mb mc md gt me mf mg bn mh mi bi"><span id="82b7" class="mj ky iq mf b be mk ml l mm mn">//Splicing scheme<br/>Butterfly.agile("test/scheme?a=1&amp;b=2").carry()<br/><br/>//call params<br/>Butterfly.agile("test/scheme?a=1&amp;b=2")<br/>    .params("intValue" to 1)<br/>    .params("booleanValue" to true)<br/>    .params("stringValue" to "test value")<br/>    .carry()</span></pre><p id="d41c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如上图，可以同时进行方案拼接和params方法调用。传递的所有参数都可以在导航目的地获得，params方法可以传递Bundle支持的任何类型的参数。</p><p id="6083" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在目的地接受参数:</p><pre class="ma mb mc md gt me mf mg bn mh mi bi"><span id="5023" class="mj ky iq mf b be mk ml l mm mn">//On the navigation destination page, you can obtain the passed parameter value through the key field of the parameter<br/>@Agile("test/scheme")<br/>class AgileTestActivity : AppCompatActivity() {<br/>    val a by lazy { intent?.getStringExtra("a") ?: "" }<br/>    val b by lazy { intent?.getStringExtra("b") ?: "" }<br/>    val intValue by lazy { intent?.getIntExtra("intValue", 0) ?: 0 }<br/>}<br/><br/>//In addition to manual parameter analysis, Bracer can also be equipped to realize fully automatic parameter analysis<br/>@Agile("test/scheme")<br/>class AgileTestActivity : AppCompatActivity() {<br/>    val a by params&lt;String&gt;()<br/>    val b by params&lt;String&gt;()<br/>    val intValue by params&lt;Int&gt;()<br/>}</span></pre><p id="6746" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">关于护腕的使用细节，请参见Github: <a class="ae kw" href="https://github.com/ssseasonnn/Bracer" rel="noopener ugc nofollow" target="_blank">护腕</a></p><h1 id="9f93" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">撰写导航</h1><p id="972e" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">Compose作为Android新的UI框架异军突起。越来越多的项目正在大量使用Compose，因此迫切需要支持Compose导航。</p><pre class="ma mb mc md gt me mf mg bn mh mi bi"><span id="2f41" class="mj ky iq mf b be mk ml l mm mn">@Agile("test/compose")<br/>@Composable<br/>fun HomeScreen() {<br/>    Box {<br/>        ...<br/>    }<br/>}<br/><br/>//Navigate to the HomeScreen page<br/>Butterfly.agile("test/compose").carry()</span></pre><p id="dc0c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如上所示，Compose的导航与Activity或Fragment的导航完全一致。统一的API使它更容易使用。</p><p id="9c7e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">组合导航中的参数传递和获取与活动或片段中的参数传递和获取几乎相同。传输参数还支持拼接方案和调用参数。要获得参数，只需要向Compose组件添加一个bundle参数，然后就可以通过Bundle参数获得导航中传递的参数。</p><pre class="ma mb mc md gt me mf mg bn mh mi bi"><span id="be1c" class="mj ky iq mf b be mk ml l mm mn">@Agile("test/compose")<br/>@Composable<br/>fun HomeScreen(bundle: Bundle) {<br/>    val a by bundle.params&lt;Int&gt;()<br/>    val b by bundle.params&lt;Int&gt;()<br/>    val booleanValue by bundle.params&lt;Boolean&gt;()<br/><br/>    Box {<br/>        Text(text = a)<br/>    }<br/>}<br/><br/>//Splicing scheme<br/>Butterfly.agile("test/compose?a=1&amp;b=2").carry()<br/><br/>//or call params<br/>Butterfly.agile("test/compose?a=1&amp;b=2")<br/>    .params("intValue" to 1)<br/>    .params("booleanValue" to true)<br/>    .params("stringValue" to "test value")<br/>    .carry()</span></pre><h1 id="9cff" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">路线拦截器</h1><p id="cf58" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">拦截器是一个非常实用的功能，可以提供强大的路由控制功能，如登录检测、AB测试等。Butterfly提供了两种类型的拦截器:全局拦截器和一次性拦截器，可以针对不同的使用场景灵活选择。</p><p id="5947" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，定义拦截器函数:</p><pre class="ma mb mc md gt me mf mg bn mh mi bi"><span id="ff36" class="mj ky iq mf b be mk ml l mm mn">//Custom interceptor<br/>class TestInterceptor : ButterflyInterceptor {<br/>    override fun shouldIntercept(agileRequest: AgileRequest): Boolean {<br/>        //Detect whether interception is required<br/>        return true<br/>    }<br/><br/>    override suspend fun intercept(agileRequest: AgileRequest) {<br/>        //Processing interception logic<br/>        println("intercepting")<br/>        delay(5000)<br/>        println("intercept finish")<br/>    }<br/>}</span></pre><p id="10b3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">配置全局拦截器:</p><pre class="ma mb mc md gt me mf mg bn mh mi bi"><span id="5cba" class="mj ky iq mf b be mk ml l mm mn">//Add a global interceptor<br/>ButterflyCore.addInterceptor(TestInterceptor())<br/><br/>//Skip all global interceptors<br/>Butterfly.agile("test/scheme").skipGlobalInterceptor().carry()</span></pre><p id="74d8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">配置一次性拦截器:</p><pre class="ma mb mc md gt me mf mg bn mh mi bi"><span id="c6d6" class="mj ky iq mf b be mk ml l mm mn">//Only the current navigation uses this interceptor<br/>Butterfly.agile("test/scheme")<br/>    .addInterceptor(TestInterceptor())<br/>    .carry()</span></pre><p id="521a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">拦截器提供了<strong class="ka ir"> suspend </strong>拦截方法，这个方法足够聪明，一看就知道它的长处。👻</p><h1 id="ba4f" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">SingleTop和ClearTop启动模式和backstack</h1><p id="37b8" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">众所周知，Activity支持多种启动模式，其中SingleTop和ClearTop尤为常见。Butterfly将这两种启动模式进行了分片和组合，并提供了统一的API。你只需要调用<strong class="ka ir"> singleTop </strong>或者<strong class="ka ir"> clearTop </strong>就可以了。</p><pre class="ma mb mc md gt me mf mg bn mh mi bi"><span id="991a" class="mj ky iq mf b be mk ml l mm mn">//for Activity<br/>@Agile("test/activity")<br/>class AgileTestActivity : AppCompatActivity()<br/><br/>Butterfly.agile("test/activity")<br/>    .clearTop()              <br/>    // or .singleTop() <br/>    .carry()<br/><br/>//for Fragment<br/>@Agile("test/fragment")<br/>class TestFragment : Fragment()<br/><br/>Butterfly.agile("test/fragment")<br/>    .clearTop()                 <br/>    // or .singleTop()   <br/>    .carry()<br/><br/>//for Compose<br/>@Agile("test/compose")<br/>@Composable<br/>fun HomeScreen() {}<br/><br/>Butterfly.agile("test/compose")<br/>    .clearTop()                 <br/>     // or .singleTop()  <br/>    .carry()</span></pre><p id="ff75" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有了启动模式，后备栈自然是必须的。默认情况下，Butterfly使用回退堆栈来管理活动、片段、对话片段和合成。每次导航到一个目标时，该目标将被添加到回退堆栈中。通过使用<strong class="ka ir">缩回</strong>方法，Butterfly可以回到上一页。</p><pre class="ma mb mc md gt me mf mg bn mh mi bi"><span id="27b7" class="mj ky iq mf b be mk ml l mm mn">//Close the top page and go back to the previous page<br/>Butterfly.retreat()<br/><br/>//Close the top page of the stack, go back to the previous page and return data<br/>Butterfly.retreat("result" to "123")</span></pre><p id="6f64" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于Compose的性质，它不支持<strong class="ka ir"> Back和返回数据</strong>，Compose可以通过重新导航来传递新数据，从而直接刷新页面</p><h1 id="9ef9" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">片段和组合的分组管理</h1><p id="7150" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">除了以栈的形式管理片段和复合，Butterfly还支持以组的形式管理它们。比如APP首页多个标签页对应多个碎片和复合屏时，可以用群组管理来处理这种场景。</p><pre class="ma mb mc md gt me mf mg bn mh mi bi"><span id="607f" class="mj ky iq mf b be mk ml l mm mn">// group fragments<br/>Butterfly.agile("test/fragment1")<br/>    .group("groupName")          <br/>    .carry()<br/><br/>Butterfly.agile("test/fragment2")<br/>    .group("groupName")          <br/>    .carry()<br/><br/>Butterfly.agile("test/fragment3")<br/>    .group("groupName")          <br/>    .carry()<br/><br/><br/>// group composes<br/>Butterfly.agile("test/compose_screen1")<br/>    .group("groupName")          <br/>    .carry()<br/><br/>Butterfly.agile("test/compose_screen2")<br/>    .group("groupName")          <br/>    .carry()<br/><br/>Butterfly.agile("test/compose_screen3")<br/>    .group("groupName")          <br/>    .carry()</span></pre><p id="0d12" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过使用相同的组名，可以在相同的组中管理这些片段或组成屏幕。在同一组中重复导航不会创建实例。</p><h1 id="65e8" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">组件化通信</h1><p id="5e50" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">作为基于组件的路由框架，组件之间的通信也是必不可少的功能。Butterfly不仅支持常规的接口接收，还支持组件之间不相互依赖的直接通信。</p><p id="1866" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用接口sink的形式，首先有一个公共依赖组件，通常是Base或Common，需要通信的两个组件，比如Home和Cart，都依赖于Base或Common，形成如下依赖图:</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mo"><img src="../Images/874e49fb70e0d41d9d9089403ba6ff15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pC8RF8vTOrZlhktw6UWVUw@2x.png"/></div></div></figure><p id="fed3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果Home需要调用Cart中的addToCart方法，首先在Base中定义通信接口:</p><p id="611a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">模块基座:</p><pre class="ma mb mc md gt me mf mg bn mh mi bi"><span id="8cd1" class="mj ky iq mf b be mk ml l mm mn">@Evade<br/>interface CartApi {<br/>    fun addToCart(product: String)<br/>}</span></pre><p id="32a9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后在Cart中创建CartApi的实现:</p><p id="1ccf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">模块推车:</p><pre class="ma mb mc md gt me mf mg bn mh mi bi"><span id="7636" class="mj ky iq mf b be mk ml l mm mn">@EvadeImpl<br/>class CartApiImpl : CartApi {<br/>    override fun addToCart(product: String) {<br/>        // do something<br/>    }<br/>}</span></pre><p id="35de" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后可以在Home中调用CartApi提供的方法:</p><p id="a15c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">模块主页:</p><pre class="ma mb mc md gt me mf mg bn mh mi bi"><span id="55e2" class="mj ky iq mf b be mk ml l mm mn">val cartApi = Butterfly.evade&lt;CartApi&gt;()<br/>cartApi.addToCart("test")</span></pre><p id="c24a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接口接收器是一种很好的交流方式，但是也有一些问题。如果你要通信的组件越来越多，那么就会有越来越多的接口下沉，最终导致Base或者Common的爆炸。因此，除了使用接口接收器形式，Butterfly还提供了组件之间直接通信的能力，而组件之间完全没有任何依赖关系。</p><p id="7d28" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">和前面的结构类似，Home和Cart也需要通信。Home需要调用Cart中的addToCart方法，但这次不需要将接口下沉到Base或Common，只需要在Home中定义通信接口即可:</p><p id="fff3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">模块主页:</p><pre class="ma mb mc md gt me mf mg bn mh mi bi"><span id="b055" class="mj ky iq mf b be mk ml l mm mn">@Evade<br/>interface CartApi {<br/>    fun addToCart(product: String)<br/>}</span></pre><p id="c96e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后在Cart中创建CartApi的实现。由于Home和Cart不直接依赖，Cart的实现类不需要实现Home中的接口，只需要使用与Home中的接口相同的方法名和方法参数即可:</p><p id="b970" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">模块推车:</p><pre class="ma mb mc md gt me mf mg bn mh mi bi"><span id="1591" class="mj ky iq mf b be mk ml l mm mn">// No need to implement CartApi<br/>@EvadeImpl<br/>class CartApiImpl {<br/>    fun addToCart(product: String) {<br/>        // do something<br/>    }<br/>}</span></pre><p id="e13e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后你可以在家里调用卡塔皮的方法:</p><p id="bc9f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">模块主页:</p><pre class="ma mb mc md gt me mf mg bn mh mi bi"><span id="6bf0" class="mj ky iq mf b be mk ml l mm mn">val cartApi = Butterfly.evade&lt;CartApi&gt;()<br/>cartApi.addToCart("test")</span></pre><h1 id="d81d" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">路由表注册和Gradle插件</h1><p id="790a" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">Butterfly将为每个带注释的模块生成一个路由表。命名规则是:Butterfly[模块名]模块</p><p id="8d5b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">手动注册:</p><pre class="ma mb mc md gt me mf mg bn mh mi bi"><span id="ec62" class="mj ky iq mf b be mk ml l mm mn">class DemoApplication : Application() {<br/>    override fun onCreate() {<br/>        super.onCreate()<br/>        //regist<br/>        ButterflyCore.addModule(ButterflyHomeModule())<br/>        ButterflyCore.addModule(ButterflyFooModule())<br/>        ButterflyCore.addModule(ButterflyBarModule())<br/>    }<br/>}</span></pre><p id="865d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">插件自动注册:</p><p id="ae30" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">1.添加插件依赖关系</p><pre class="ma mb mc md gt me mf mg bn mh mi bi"><span id="0247" class="mj ky iq mf b be mk ml l mm mn">//use plugins DSL:<br/>plugins {<br/>    id "io.github.ssseasonnn.butterfly" version "1.0.1"<br/>}<br/><br/>//or use legacy plugin application:<br/>buildscript {<br/>    repositories {<br/>        maven {<br/>            url "https://plugins.gradle.org/m2/"<br/>        }<br/>    }<br/>    dependencies {<br/>        classpath "io.github.ssseasonnn:plugin:1.0.1"<br/>    }<br/>}<br/><br/>//add plugin<br/>apply plugin: "io.github.ssseasonnn.butterfly"</span></pre><p id="c79d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">2.实现您自己的应用程序类</p><pre class="ma mb mc md gt me mf mg bn mh mi bi"><span id="c77c" class="mj ky iq mf b be mk ml l mm mn">class DemoApplication : Application() {<br/>    override fun onCreate() {<br/>        super.onCreate()<br/>    }<br/>}</span></pre><p id="58c9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过插件，Butterfly会自动发现所有的路由模块，并自动注入代码将路由表添加到应用程序中，从而解放双手</p><h1 id="62df" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">结束</h1><p id="7599" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">更多关于Butterfly的细节，请到GitHub: <a class="ae kw" href="https://github.com/ssseasonnn/Butterfly" rel="noopener ugc nofollow" target="_blank"> Butterfly </a></p><p id="de21" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">欢迎感兴趣的朋友提供反馈和建议，谢谢。</p></div></div>    
</body>
</html>