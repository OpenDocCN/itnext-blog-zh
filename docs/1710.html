<html>
<head>
<title>Upgrading to React Hooks: Parcel, Web Animations, and React Hooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">升级到React挂钩:地块、Web动画和React挂钩</h1>
<blockquote>原文：<a href="https://itnext.io/upgrading-to-react-hooks-parcel-web-animations-and-react-hooks-3a3cd044a6b9?source=collection_archive---------4-----------------------#2019-01-08">https://itnext.io/upgrading-to-react-hooks-parcel-web-animations-and-react-hooks-3a3cd044a6b9?source=collection_archive---------4-----------------------#2019-01-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/d0770f79ae8441a079546e0282f263cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JNXG7niZ6gJp7QyilGIm6w.jpeg"/></div></div></figure><p id="5a52" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">主要是为了好玩，我决定使用React钩子将我的一个旧项目升级到React的当前版本。</p><ul class=""><li id="586f" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">项目代码:<a class="ae lf" href="https://github.com/ajcrites/times-tables" rel="noopener ugc nofollow" target="_blank">https://github.com/ajcrites/times-tables</a></li><li id="52c7" class="kw kx iq ka b kb lg kf lh kj li kn lj kr lk kv lb lc ld le bi translated">直播项目:<a class="ae lf" href="https://times-tables.explosionpills.com/" rel="noopener ugc nofollow" target="_blank">https://times-tables.explosionpills.com/</a></li></ul><p id="ad39" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是一个相当简单的React应用程序，可以显示和动画显示一个时间表。它从根本上分为三个组件:维护状态的应用程序容器、可视化本身以及操纵可视化的控件。</p><p id="bdb6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> <em class="ll">更新</em> </strong> <em class="ll">:这篇文章最初是React钩子在alpha时写的，因此有了下面这段。本文中的所有代码都已经过React最新稳定版本的测试(包括钩子)，你可以简单地用</em> <code class="fe lm ln lo lp b"><em class="ll">yarn add react react-dom</em></code> <em class="ll">安装。</em></p><p id="b32a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我的第一步是用钩子更新React的版本。这目前是通过<code class="fe lm ln lo lp b">yarn add --exact react@next react-dom@next</code>完成的，因为钩子仍然在alpha中。注意这里的<code class="fe lm ln lo lp b">--exact</code>是推荐的，因为在你的<code class="fe lm ln lo lp b">package.json</code>里如果你有<code class="fe lm ln lo lp b">"^16.8.0-alpha.1"</code>，yarn/npm可能会安装v16而不是alpha版本。使用<code class="fe lm ln lo lp b">"16.8.0-alpha.1"</code>可以避免这个潜在的陷阱。</p><h1 id="724f" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">使用包裹</h1><p id="134d" class="pw-post-body-paragraph jy jz iq ka b kb mo kd ke kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv ij bi translated">我用Create React App和现在已经过时的<code class="fe lm ln lo lp b">react-scripts-ts</code>创建了这个项目。我所做的一些更改导致应用程序不再编译。很久以来我一直想使用package，所以我硬着头皮更新了我的项目来使用它。</p><p id="a1fa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我被包裹的便利程度所折服。我所要做的就是将<code class="fe lm ln lo lp b">public/index.html</code>移动到<code class="fe lm ln lo lp b">src/index.html</code>，并更新它以包含<code class="fe lm ln lo lp b">&lt;script src="./index.tsx"&gt;</code>。Parcel用<code class="fe lm ln lo lp b">yarn parcel serve src/index.html</code>做了几乎所有的事情。使用类似的<code class="fe lm ln lo lp b">yarn parcel build</code>也适用于生产。除了开发和林挺，我甚至不需要任何特殊的TypeScript配置。</p><p id="dcaf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe lm ln lo lp b">react-scripts</code>现在也支持TypeScript了，不过我还没测试过。如果你还没有尝试过，我会推荐你试试package。它快速方便，几乎不需要配置，内置功能性热重装。我还使用<code class="fe lm ln lo lp b">parcel-plugin-static-files-copy</code>在构建时复制一些静态文件。</p><h1 id="9cd6" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">使用元素动画</h1><p id="dfed" class="pw-post-body-paragraph jy jz iq ka b kb mo kd ke kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv ij bi translated">虽然仍处于试验阶段，但现在已经有JavaScript APIs允许你在DOM元素上调用<code class="fe lm ln lo lp b">.animate</code>来触发动画。与我之前所做的相比，我更喜欢这样做——设置CSS动画，在超时和使用过渡时更新样式。使用<code class="fe lm ln lo lp b">.animate</code> API更干净、更简单、更直接。</p><figure class="mt mu mv mw gt jr"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="28b2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用CSS过渡的之前的<em class="ll">代码可能看起来简单一点，但是注意你必须单独处理后动画过渡。您也可以使用类似于<code class="fe lm ln lo lp b">transitionend</code>事件的东西来设置状态，但是我会发现这几乎和使用超时一样不可靠。</em></p><p id="ef0d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用<code class="fe lm ln lo lp b">.animate</code>的代码一开始可能看起来有点复杂，但那只是因为我们有额外的动画设置来显示持续时间和方向。我更喜欢明确的一组动画关键帧，你可以选择向前和向后动画。等待动画结束也是显式的。在你不得不等待多个动画完成的情况下，这也是很好的选择；否则你将不得不做一些事情，比如管理多个<code class="fe lm ln lo lp b">transitionend</code>，或者选择等待最长的超时。</p><p id="6029" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请注意，部分或全部的web动画API并不是在所有的浏览器中都可用，它仍然是一项实验性的技术。通过<code class="fe lm ln lo lp b">import 'web-animations-js/web-animations-next-lite.min'</code>，polyfill库正好满足了我的需求。根据您的特定需求，该库还有其他聚合填充文件。我强烈推荐。</p><h1 id="8320" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">反应钩</h1><p id="4458" class="pw-post-body-paragraph jy jz iq ka b kb mo kd ke kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv ij bi translated">我的项目的组件层次结构如下:</p><pre class="mt mu mv mw gt mz lp na nb aw nc bi"><span id="8f07" class="nd lr iq lp b gy ne nf l ng nh">&lt;TimesTableApp&gt;<br/>  &lt;TimesTableVisualization /&gt;<br/>  &lt;TimesTableControls /&gt;<br/>  &lt;About /&gt;<br/>&lt;/TimesTableApp&gt;</span></pre><p id="bd76" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">“控件”和“可视化”还有一些子控件，分别用于控件的UI和时间表本身。很难想象我能从我正在使用的组件中获得更多的重用。基本上就是HTML。因此，除了将事物分开一点并试图将相似的事物放在一起之外，我没有在组件层次结构上花太多心思。</p><p id="739e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我所指的<strong class="ka ir">应用状态</strong>包括三个值:</p><ul class=""><li id="7ea6" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">乘法表</li><li id="d933" class="kw kx iq ka b kb lg kf lh kj li kn lj kr lk kv lb lc ld le bi translated">点数</li><li id="e725" class="kw kx iq ka b kb lg kf lh kj li kn lj kr lk kv lb lc ld le bi translated">线条颜色</li></ul><p id="3004" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可以在网站上看到这个时间表是如何工作的，但是“时间表”是显示的时间表的数字(2次表，3次表，4.2次表，等等)。)，“点数”是在可视化上的圆周围有多少个点供乘法表使用，“线颜色”是显示乘法的线的颜色。这是一张gif图片，显示了从2倍到10倍的表格中的50个点，每次一个点。线条颜色每0.5倍表格改变一次。</p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/d231014acd2348af74a33ff867ca5217.png" data-original-src="https://miro.medium.com/v2/resize:fit:700/1*Ow5lcfbzA64eO5-NYDlSLQ.gif"/></div></figure><p id="f587" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这可以使用组件组合来完成——可视化部分和时间表编号、点数和线条颜色的控件都可以位于顶层。旧版本的应用程序将这些值向下钻了一层— <code class="fe lm ln lo lp b">TimesTableApp</code>通过其状态传递这些值，并将操作时间表的方法传递给输入/按钮等使用的控件。</p><p id="2124" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我决定升级到hooks主要是实验性的，但是我也做了一些额外的清理工作。我将一步步回顾我经历的每一个变化。</p><h2 id="ea7f" class="nd lr iq bd ls nj nk dn lw nl nm dp ma kj nn no me kn np nq mi kr nr ns mm nt bi translated">状态和参考</h2><p id="9261" class="pw-post-body-paragraph jy jz iq ka b kb mo kd ke kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv ij bi translated">要更新的最简单的组件是“关于”组件。这主要是静态信息，与应用程序状态无关。唯一有趣的是，它是一个使用我上面展示的web动画来制作动画的模型。</p><p id="88fd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe lm ln lo lp b">useRef</code>与React挂钩真的没有任何不同，比<code class="fe lm ln lo lp b">React.createRef</code>为我的需要在这里。注意，您可以使用<code class="fe lm ln lo lp b">useRef</code>代替<code class="fe lm ln lo lp b">this</code>来维护组件的任何可变值，但是它也可以用于组件的<code class="fe lm ln lo lp b">ref</code>属性。</p><figure class="mt mu mv mw gt jr"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="053a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里更值得注意的变化是<code class="fe lm ln lo lp b">About</code>从类组件变成了功能组件。钩子是用于功能组件的。否则，除了我们不再使用<code class="fe lm ln lo lp b">this.</code>之外，这个<code class="fe lm ln lo lp b">contentRef</code>的用法是一样的。</p><p id="ca79" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们还需要维持我们的状态，<code class="fe lm ln lo lp b">show</code>从早。这仅仅用于确定内容是否正在实际显示。</p><figure class="mt mu mv mw gt jr"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="256a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了清楚起见，上面的例子包括了之前的<code class="fe lm ln lo lp b">useRef</code>。添加的是<code class="fe lm ln lo lp b">useState</code>。对于门外汉来说，状态挂钩可能有点不寻常——尤其是如果你习惯使用<code class="fe lm ln lo lp b">this.state</code>的话，但是我会试着解释它是如何工作的。</p><p id="e796" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe lm ln lo lp b">useState</code>返回一个包含两个值的数组。第一个是当前渲染周期的state属性值。第二个是允许您更新这个状态值的函数。因为在这种情况下我们只有一个值，所以我们不需要像处理<code class="fe lm ln lo lp b">state</code> / <code class="fe lm ln lo lp b">setState</code>那样的对象。相反，<code class="fe lm ln lo lp b">show</code>是布尔值。当我们想要更新它时，我们调用<code class="fe lm ln lo lp b">setShow</code>，一个我们可以随意命名的函数。我坚持传统。</p><p id="2d81" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果这是你第一次在工作中看到<code class="fe lm ln lo lp b">useState</code>，你可能会想:</p><blockquote class="nu nv nw"><p id="6fb9" class="jy jz ll ka b kb kc kd ke kf kg kh ki nx kk kl km ny ko kp kq nz ks kt ku kv ij bi translated"><code class="fe lm ln lo lp b">show</code>怎么更新？</p></blockquote><p id="80be" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">记住<code class="fe lm ln lo lp b">About</code>是一个组件函数。每次收到更新时都会调用它。钩子更新组件的状态——调用<code class="fe lm ln lo lp b">setShow</code>用新的<code class="fe lm ln lo lp b">show</code>值触发更新。当再次调用这个组件函数时，<code class="fe lm ln lo lp b">useState</code>将从更新后的状态返回新的<em class="ll">值，组件将被相应地渲染。<code class="fe lm ln lo lp b">useState</code>的参数是初始渲染时使用的初始值。</em></p><p id="19fb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">调用<code class="fe lm ln lo lp b">setShow</code>更新<code class="fe lm ln lo lp b">show</code>的方式与<code class="fe lm ln lo lp b">this.setState({ show })</code>更新<code class="fe lm ln lo lp b">this.state.show</code>的方式相同。希望这是清楚的。如果没有，您可能想尝试更新您的项目中的一些简单的、有状态的组件来使用<code class="fe lm ln lo lp b">useState</code>来看看它是如何工作的。</p><h2 id="5ab4" class="nd lr iq bd ls nj nk dn lw nl nm dp ma kj nn no me kn np nq mi kr nr ns mm nt bi translated">效果和状态管理</h2><p id="9f73" class="pw-post-body-paragraph jy jz iq ka b kb mo kd ke kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv ij bi translated">更新的下一步是更新时间表可视化本身。这是一个相当简单的组件，完成一些数学运算并绘制到画布上。调整大小时，图形会调整大小以匹配窗口大小，并且它会在时间表编号、点数或线条颜色发生变化时重新绘制。这些都是时间表可视化的支撑。</p><figure class="mt mu mv mw gt jr"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="5406" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">完成钩子更新有几个步骤:</p><ol class=""><li id="7bbe" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv oa lc ld le bi translated">低垂的果实:<code class="fe lm ln lo lp b">useRef</code>而不是<code class="fe lm ln lo lp b">createRef</code></li><li id="9f6a" class="kw kx iq ka b kb lg kf lh kj li kn lj kr lk kv oa lc ld le bi translated">生命周期挂钩(<code class="fe lm ln lo lp b">component...</code>方法)需要替换为<code class="fe lm ln lo lp b">useEffect</code></li><li id="b04e" class="kw kx iq ka b kb lg kf lh kj li kn lj kr lk kv oa lc ld le bi translated">必须像<code class="fe lm ln lo lp b">forceUpdate</code>一样使用<code class="fe lm ln lo lp b">useState</code>来触发重绘。</li></ol><p id="e59e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我发现<code class="fe lm ln lo lp b">useEffect</code>有点难以理解，因为它不是生命周期挂钩的一对一转换。<code class="fe lm ln lo lp b">useEffect</code>钩子通常会在挂载和任何更新时运行。</p><p id="66a2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe lm ln lo lp b">useEffect</code>采取回调处理你的副作用逻辑。你可以选择从这个回调函数中返回一个函数来消除你的副作用。“副作用”可以广义地理解为在组件状态之外的组件中运行的效果。浏览器窗口上的<code class="fe lm ln lo lp b">'resize'</code>事件是副作用的一个理想例子。</p><p id="38ea" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这对我们来说意味着三件事:</p><ol class=""><li id="76b8" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv oa lc ld le bi translated">效果必须设置初始宽度/高度。</li><li id="d4a4" class="kw kx iq ka b kb lg kf lh kj li kn lj kr lk kv oa lc ld le bi translated">一个效果必须在窗口上添加<code class="fe lm ln lo lp b">'resize'</code>事件监听器。</li><li id="3b77" class="kw kx iq ka b kb lg kf lh kj li kn lj kr lk kv oa lc ld le bi translated">效果必须返回一个函数来移除此事件侦听器。</li></ol><p id="67e7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了让<code class="fe lm ln lo lp b">resize</code>事件正常工作，它必须更新一些组件状态来触发渲染…否则，画布将不会被重绘，因为<code class="fe lm ln lo lp b">resize</code>实际上没有更新任何状态或道具。我们可以为此使用任意的<code class="fe lm ln lo lp b">useState</code>。这可能看起来有点奇怪，但你可以认为这是在使用<code class="fe lm ln lo lp b">forceUpdate</code>。</p><p id="7ef8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第一步将是为<code class="fe lm ln lo lp b">useRef</code>更新。</p><figure class="mt mu mv mw gt jr"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="092a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我现在已经停止了大部分的功能。这只是设置了<code class="fe lm ln lo lp b">canvas</code>参考值。</p><p id="ac6e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe lm ln lo lp b">&lt;canvas ref={this.canvasRef}</code>改为<code class="fe lm ln lo lp b">&lt;canvas ref={canvasRef}</code>。否则，处理方式与之前相同。</p><p id="3ced" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">敏锐的读者可能会注意到，我们在顶层(组件函数的作用域)没有类似于<code class="fe lm ln lo lp b">const canvas = canvasRef.current</code>的东西。相反，我们在里面做这个<em class="ll"><code class="fe lm ln lo lp b">redraw</code>。原因是如果我们执行<code class="fe lm ln lo lp b">const canvas = canvasRef.current</code>，那么<code class="fe lm ln lo lp b">canvas</code>永远不会在<code class="fe lm ln lo lp b">redraw</code>方法中被重新计算。它是初始值<code class="fe lm ln lo lp b">canvas</code>附近的一个闭包，因此将被设置为初始值。在我们这里:<code class="fe lm ln lo lp b">null</code>。</em></p><p id="d6d8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">相反，我们需要在任何时候使用<code class="fe lm ln lo lp b">canvasRef.current</code>来访问给定范围内当前渲染周期的<code class="fe lm ln lo lp b">canvasRef</code>。注意，<code class="fe lm ln lo lp b">const canvas = canvasRef.current</code>在我们的<code class="fe lm ln lo lp b">redraw</code>函数内部工作。这是因为只要调用<code class="fe lm ln lo lp b">redraw</code>就会调用<code class="fe lm ln lo lp b">.current</code>。</p><p id="46c1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当画布的宽度/高度改变时，我们可以使用<code class="fe lm ln lo lp b">useState</code>强制更新来重绘画布。如果我们不这样做，画布不会被重画，因为没有状态或道具被更新。在早期的版本中，我已经记录了这个效果的宽度/高度。那也行得通，但是我发现这种方法更简单。</p><figure class="mt mu mv mw gt jr"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="b602" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面的<code class="fe lm ln lo lp b">forceUpdate</code>的参数是TypeScript所必需的，但是它可以是任何东西。调用由<code class="fe lm ln lo lp b">useState</code>返回的set函数将触发渲染。您也可以随意命名这个函数——不一定非得是<code class="fe lm ln lo lp b">forceUpdate</code>。</p><p id="6c16" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这导致了我们对<code class="fe lm ln lo lp b">useEffects</code>的使用，它将对<code class="fe lm ln lo lp b">redraw</code>进行初始调用，以触发画布尺寸的初始绘制，并设置resize事件。当调用<code class="fe lm ln lo lp b">useEffect</code>回调函数时，画布ref已经被设置为<code class="fe lm ln lo lp b">&lt;canvas&gt;</code>。</p><figure class="mt mu mv mw gt jr"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="28a7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这花了我一点时间来理解，但是第一个<code class="fe lm ln lo lp b">useEffect</code>在初始渲染时被调用，然后会因为<code class="fe lm ln lo lp b">redraw()</code>而触发<em class="ll">另一个</em>渲染。然而，我们必须等待画布被绘制以访问ref，这样我们就可以设置它的尺寸，所以第二次渲染是合适的。</p><p id="1da6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe lm ln lo lp b">useEffect</code>的第二个参数用作比较器——如果数组中的值都不变，就不会再次调用<code class="fe lm ln lo lp b">useEffect</code>回调。如果你使用<code class="fe lm ln lo lp b">[]</code>，没有值可以比较，回调只被调用一次(在初始渲染时)。对于<code class="fe lm ln lo lp b">[]</code>没有特殊处理，它只是不会再次运行效果，因为没有比较器值发生变化。在我们的例子中，这是可取的，因为我们只想对画布进行初始调整，只要显示可视化，我们就不需要多次添加/删除窗口侦听器。</p><blockquote class="nu nv nw"><p id="3754" class="jy jz ll ka b kb kc kd ke kf kg kh ki nx kk kl km ny ko kp kq nz ks kt ku kv ij bi translated">听起来可能很奇怪，在我更新的早期版本中，最终由<code class="fe lm ln lo lp b">useEffects</code>完成的与旧值的比较<code class="fe lm ln lo lp b">==</code>花费了太长时间，导致了闪烁。在实际项目中，我省略了条件检查。实际上，连续渲染比进行这种检查更有效。</p></blockquote><h2 id="a378" class="nd lr iq bd ls nj nk dn lw nl nm dp ma kj nn no me kn np nq mi kr nr ns mm nt bi translated">使用上下文</h2><p id="3c4e" class="pw-post-body-paragraph jy jz iq ka b kb mo kd ke kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv ij bi translated">这是我不用钩子也能完成的事情，但是这里有一个方便的<code class="fe lm ln lo lp b">useContext</code>钩子，我可以利用它。</p><p id="ffdb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">与其让<code class="fe lm ln lo lp b">TimesTableApp</code>在同级可视化和控件之间显式传递应用程序状态数据，我认为更简单的方法是拥有一个允许可视化/控件根据需要检索和更新状态属性的上下文。这确实大大简化了事情，但是正如React文档中所建议的，这创建了可视化和控件与上下文的耦合。由于我既没有计划也没有看到如何使这些组件在项目间可重用，我认为这是一个很好的妥协。</p><p id="ffd0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe lm ln lo lp b">TimesTableApp</code>仍然需要管理上下文，所以除了属性本身之外，它还需要更新相应状态属性的方法。</p><figure class="mt mu mv mw gt jr"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="3cff" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe lm ln lo lp b">{} as any</code>用于避免必须在上下文中设置初始值的冗余，而<code class="fe lm ln lo lp b">TimesTableApp</code>用于管理顶级上下文。使用初始值，<code class="fe lm ln lo lp b">{ pointCount: 0, ... }</code>等。也会很好。</p><p id="0d45" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下一步，我想更新控件和可视化来使用上下文。我没有更新<code class="fe lm ln lo lp b">TimesTableApp</code>来使用钩子，而是开始坚持使用<code class="fe lm ln lo lp b">this.state</code>并传递上下文，而不是单个的状态值(时间表、点数和线条颜色)。</p><figure class="mt mu mv mw gt jr"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="9858" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">可视化和控件现在可以使用这些值。乘法表控件有一个“播放”按钮，用于递增乘法表。我们可以用<code class="fe lm ln lo lp b">setTimesTable</code>上下文方法更新时间表。</p><figure class="mt mu mv mw gt jr"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="e3e6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面的<code class="fe lm ln lo lp b">useRef</code>用于跟踪间隔计时器。记住<code class="fe lm ln lo lp b">useRef</code>可以用来跟踪任何可变的值，间隔计时器将在我们再次<code class="fe lm ln lo lp b">play</code>时改变。</p><p id="340c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">希望上面的代码看起来合理，但是我们有一个小问题。如果您还记得我说过的关于<code class="fe lm ln lo lp b">const canvas = canvasRef.current</code>的话，闭包将使用创建闭包时评估的任何值。这意味着<code class="fe lm ln lo lp b">setInterval</code>回调中的<code class="fe lm ln lo lp b">timesTable</code>将始终是初始值(<code class="fe lm ln lo lp b">2</code>，并且乘法表的增量永远不会超过<code class="fe lm ln lo lp b">2.1</code>。</p><p id="8ba2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">相反，当我们需要读取时，我们需要一种方法来访问在<em class="ll">上下文</em>中的<code class="fe lm ln lo lp b">timesTable</code>值。不允许在组件函数范围之外的任何地方使用<code class="fe lm ln lo lp b">useContext</code>，所以我们不能在<code class="fe lm ln lo lp b">setInterval</code>内部使用它。此外，像<code class="fe lm ln lo lp b">const ctx = useContext()</code>和<code class="fe lm ln lo lp b">ctx.timesTable</code>这样做也不起作用，因为<code class="fe lm ln lo lp b">ctx</code>是每次渲染的新对象，而不是对最初创建的对象的引用。</p><p id="5ac1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以从React的<code class="fe lm ln lo lp b">setState</code>中得到提示，允许我们的状态更新函数接受一个提供当前上下文值的回调。为此，我们可以更新<code class="fe lm ln lo lp b">TimesTableApp</code>中现有的<code class="fe lm ln lo lp b">changeValue</code>函数:</p><figure class="mt mu mv mw gt jr"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="f11f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这确保了无论<code class="fe lm ln lo lp b">setInterval</code>回调在哪里被设置，无论何时运行，我们都有正确的时间表值。例如，我们的控件也可以有一个带有<code class="fe lm ln lo lp b">onChange={({ target: { value } } =&gt; setTimesTable(+value)}</code>的输入，所以设置一个值而不是使用回调仍然有效。</p><p id="46b5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们也可以更新可视化来使用上下文而不是道具。这里的变化很小，因为它们都来自同一个来源(应用程序状态),所以这是必要的还是可取的还存在争议。然而，我这样做是为了一致性。</p><figure class="mt mu mv mw gt jr"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="1792" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">简单来说<code class="fe lm ln lo lp b">const props = useContext(TimesTableContext)</code>应该没问题，也可以显式通过道具。我认为这主要取决于个人喜好。</p><h2 id="6abe" class="nd lr iq bd ls nj nk dn lw nl nm dp ma kj nn no me kn np nq mi kr nr ns mm nt bi translated">顶级状态管理</h2><p id="5750" class="pw-post-body-paragraph jy jz iq ka b kb mo kd ke kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv ij bi translated">最后的改动是更新<code class="fe lm ln lo lp b">TimesTableApp</code>使用钩子。这相当简单，因为我们可以从<code class="fe lm ln lo lp b">this.state</code>移动到<code class="fe lm ln lo lp b">useState</code></p><figure class="mt mu mv mw gt jr"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="8b1d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这实际上不是一个简化…除了一些风格上的东西，这正是我把<code class="fe lm ln lo lp b">TimesTableApp</code>改成的。您会注意到不再需要<code class="fe lm ln lo lp b">changeValue</code>函数工厂。相反，<code class="fe lm ln lo lp b">useState</code>中的<code class="fe lm ln lo lp b">set*</code>函数方便地满足了我们的这些需求，因为您也可以向提供当前值的<code class="fe lm ln lo lp b">set*</code>函数传递回调。也就是说，我们仍然可以在controls组件内部使用<code class="fe lm ln lo lp b">setTimesTable</code>而不做任何更改。</p><blockquote class="nu nv nw"><p id="94b8" class="jy jz ll ka b kb kc kd ke kf kg kh ki nx kk kl km ny ko kp kq nz ks kt ku kv ij bi translated">我当前的应用程序在播放时会改变时间表和线条颜色。由于线条颜色依赖于两个当前的上下文值，这导致了用于更新状态的嵌套回调。我认为这有点不靠谱，我更喜欢一种管理多个状态值的机制，尽管这可能只是一个带有值对象的单个<code class="fe lm ln lo lp b">useState</code>，而不是单个的<code class="fe lm ln lo lp b">useState</code>…但这也使得更新单个值变得更加复杂。</p></blockquote><h1 id="a4cf" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">结论</h1><p id="3e78" class="pw-post-body-paragraph jy jz iq ka b kb mo kd ke kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv ij bi translated">包裹、<code class="fe lm ln lo lp b">web-animations-js</code>、React挂钩都很棒。我已经很久没有更新这个项目了，所以我做的一些改变，比如转移到一个React上下文，并不需要钩子来参与。这使得我更难看出对我的代码的一些有争议的改进是严格地来自钩子还是来自我本可以用于React类的另一个范例。</p><p id="2de0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我对钩子很感兴趣，尽管除了创建可重用钩子的潜力之外，我还没有看到使用React类的实质性优势。React团队认为，因为JavaScript中的<code class="fe lm ln lo lp b">this</code>一般来说很难掌握，而且并不是每个想使用React的人都来自面向对象的状态管理背景，所以钩子将降低一些开发人员的入门门槛。这可能是真的，但是我认为它们仍然带来了自己的挑战，比如要求对函数范围有更好的理解。我认为钩子的使用也可能很快变得笨拙……你没有强制的单一状态对象和生命周期，但是你可以用各种方式管理状态、生命周期和范围值。是什么让<code class="fe lm ln lo lp b">const val = useRef()</code>比<code class="fe lm ln lo lp b">this.val</code>好？</p><p id="2d63" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我知道钩子在很大程度上是向后兼容的，所以这可能会限制它们的功能。我不认为钩子能解决任何新的问题，尽管我认为一旦它们被更广泛地采用，这种情况可能会改变。我期待看到使用钩子的改进的和明智的状态管理模式，因为我认为这是他们现在最大的弱点。</p><p id="6dba" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">还有，为什么JavaScript中的比较操作符明显很慢？</p></div></div>    
</body>
</html>