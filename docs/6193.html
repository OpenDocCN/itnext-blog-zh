<html>
<head>
<title>C++20 Concepts — Complete Guide</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C++20概念—完整指南</h1>
<blockquote>原文：<a href="https://itnext.io/c-20-concepts-complete-guide-42c9e009c6bf?source=collection_archive---------0-----------------------#2021-09-15">https://itnext.io/c-20-concepts-complete-guide-42c9e009c6bf?source=collection_archive---------0-----------------------#2021-09-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="081b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">关于C++的一个当之无愧的常见抱怨是编译器错误的低质量。在过去的十年里，GCC和Clang都取得了很大的进步来改善这种情况，但是模板化代码是它们不能真正帮助的一个领域。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/40748eb41cd4b4e91dbf05b29fee9828.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z8nbY6TPwybDLqhQnwnAJg.png"/></div></div></figure><h1 id="8d3a" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">不喜欢int的函数。</h1><p id="9bf1" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">模板化代码的困难在于编译错误实际上发生在实现代码内部。这可能会导致混淆的错误消息。</p><p id="33ee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">举一个简单的例子:</p><pre class="km kn ko kp gt ma mb mc md aw me bi"><span id="07b7" class="mf ky iq mb b gy mg mh l mi mj">#include &lt;string&gt;</span><span id="9c38" class="mf ky iq mb b gy mk mh l mi mj">void function_without_concept(const auto&amp; x) {<br/>    std::string v = x;<br/>}</span><span id="7526" class="mf ky iq mb b gy mk mh l mi mj">int main() {<br/>    function_without_concept(1);<br/>}</span></pre><p id="edc4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该错误是在函数内部报告的，因为这里的无效操作是将<code class="fe ml mm mn mb b">int</code>赋值给<code class="fe ml mm mn mb b">string</code>。</p><pre class="km kn ko kp gt ma mb mc md aw me bi"><span id="b886" class="mf ky iq mb b gy mg mh l mi mj">function_that_doesnt_like_int.cc:4:14: error: no viable conversion from 'const int' to 'std::string' (aka 'basic_string&lt;char&gt;')<br/>        std::string v = x;<br/>                    ^   ~<br/>function_that_doesnt_like_int.cc:8:2: note: in instantiation of function template specialization 'function_without_concept&lt;int&gt;' requested here<br/>        function_without_concept(1);</span><span id="5b12" class="mf ky iq mb b gy mk mh l mi mj">- shortened - </span></pre><p id="6240" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于这样一个浅层次的错误，我们不必深究太多，但我们仍然需要看看实现，以充分理解这个函数只接受可以赋给字符串的类型。</p><h1 id="63aa" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">使用概念</h1><p id="af25" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">因此，让我们来看看如何通过使用概念来改善这种情况。我们将依赖标准库中定义的概念。</p><p id="1937" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有关标准库中预定义概念的完整概述，请查看:</p><ul class=""><li id="bdc4" class="mo mp iq jp b jq jr ju jv jy mq kc mr kg ms kk mt mu mv mw bi translated"><br/>en.cppreference.com/w/cpp/concepts<a class="ae mx" href="https://en.cppreference.com/w/cpp/concepts" rel="noopener ugc nofollow" target="_blank">T2</a></li><li id="1a38" class="mo mp iq jp b jq my ju mz jy na kc nb kg nc kk mt mu mv mw bi translated"><code class="fe ml mm mn mb b">&lt;iterator&gt;</code><br/><a class="ae mx" href="https://en.cppreference.com/w/cpp/iterator#C.2B.2B20_iterator_concepts" rel="noopener ugc nofollow" target="_blank">en . CP preference . com/w/CPP/iterator # c . 2b . 2b 20 _ iterator _ concepts</a><br/><a class="ae mx" href="https://en.cppreference.com/w/cpp/iterator#Algorithm_concepts_and_utilities" rel="noopener ugc nofollow" target="_blank">en . CP preference . com/w/CPP/iterator # Algorithm _ concepts _ and _ utilities</a></li><li id="76bd" class="mo mp iq jp b jq my ju mz jy na kc nb kg nc kk mt mu mv mw bi translated"><br/>en.cppreference.com/w/cpp/ranges#Range_concepts<a class="ae mx" href="https://en.cppreference.com/w/cpp/ranges#Range_concepts" rel="noopener ugc nofollow" target="_blank">T4</a></li></ul><p id="e437" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们从这个简单的函数开始，它需要一个可转换为字符串的参数。</p><pre class="km kn ko kp gt ma mb mc md aw me bi"><span id="99a9" class="mf ky iq mb b gy mg mh l mi mj">#include &lt;string&gt;<br/>#include &lt;concepts&gt;</span><span id="43c8" class="mf ky iq mb b gy mk mh l mi mj">void func_with_auto_inline(const std::convertible_to&lt;std::string&gt; auto&amp; x) {<br/>    std::string v = x;<br/>}</span><span id="6f71" class="mf ky iq mb b gy mk mh l mi mj">int main() {<br/>    func_with_auto_inline(1);<br/>}</span></pre><p id="8e5d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这一次，我们得到了一个更长但也更具描述性的错误。</p><pre class="km kn ko kp gt ma mb mc md aw me bi"><span id="ffcf" class="mf ky iq mb b gy mg mh l mi mj">function_with_concept.cc:9:5: error: no matching function for call to 'func_with_auto_inline'<br/>    func_with_auto_inline(1);<br/>    ^~~~~~~~~~~~~~~~~~~~~</span><span id="1fe7" class="mf ky iq mb b gy mk mh l mi mj">function_with_concept.cc:4:6: note: candidate template ignored: constraints not satisfied [with x:auto = int]<br/>void func_with_auto_inline(const std::convertible_to&lt;std::string&gt; auto&amp; x) {<br/>     ^<br/>function_with_concept.cc:4:39: note: because 'std::convertible_to&lt;int, std::string&gt;' evaluated to false<br/>void func_with_auto_inline(const std::convertible_to&lt;std::string&gt; auto&amp; x) {</span><span id="18c6" class="mf ky iq mb b gy mk mh l mi mj">- shortened -</span></pre><p id="ba7e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最重要的是，我们看到了一个<code class="fe ml mm mn mb b">no matching function for call</code>错误，它解释了为什么重载决策没有考虑我们的函数。</p><p id="c071" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可能会注意到在输出中,<code class="fe ml mm mn mb b">std::convertible_to</code>实际上有两个参数。使用内联语法，第一个参数是从上下文中自动填充的。当考虑所有其他语法变体时，我们可以更清楚地看到这一点:</p><pre class="km kn ko kp gt ma mb mc md aw me bi"><span id="0915" class="mf ky iq mb b gy mg mh l mi mj">void func_with_auto_inline(const std::convertible_to&lt;std::string&gt; auto&amp; x) {<br/>    std::string v = x;<br/>}</span><span id="38d3" class="mf ky iq mb b gy mk mh l mi mj">void func_with_auto_postfix(const auto&amp; x)<br/>    requires std::convertible_to&lt;decltype(x), std::string&gt; {<br/>    std::string v = x;<br/>}</span><span id="a140" class="mf ky iq mb b gy mk mh l mi mj">template &lt;std::convertible_to&lt;std::string&gt; T&gt;<br/>void func_with_template_inline(const T&amp; x) {<br/>    std::string v = x;<br/>}</span><span id="811c" class="mf ky iq mb b gy mk mh l mi mj">template &lt;typename T&gt;<br/>    requires std::convertible_to&lt;T, std::string&gt;<br/>void func_with_template_postfix(const T&amp; x) {<br/>    std::string v = x;<br/>}</span></pre><p id="04ab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当使用inline语法时，我们可以省略第一个参数(使用auto或template)。当使用基于后缀requires的语法时，我们需要通过<code class="fe ml mm mn mb b">decltype</code>或者传入模板参数来提供它。</p><p id="6d5d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">也可以使用逻辑运算符来组合概念。这是一个复杂的函数模板的例子，它接受积分或返回积分的invocable。注意，我们还在一个<code class="fe ml mm mn mb b">constexpr</code>条件语句中使用了一个概念。</p><pre class="km kn ko kp gt ma mb mc md aw me bi"><span id="cf1a" class="mf ky iq mb b gy mg mh l mi mj">#include &lt;string&gt;<br/>#include &lt;concepts&gt;<br/>#include &lt;iostream&gt;</span><span id="759a" class="mf ky iq mb b gy mk mh l mi mj">template &lt;typename T&gt;<br/>    requires std::integral&lt;T&gt; ||<br/>    (std::invocable&lt;T&gt; &amp;&amp;<br/>     std::integral&lt;typename std::invoke_result&lt;T&gt;::type&gt;)<br/>void function(const T&amp; x) {<br/>    if constexpr (std::invocable&lt;T&gt;) {<br/>        std::cout &lt;&lt; "Result of call is " &lt;&lt; x() &lt;&lt; "\n";<br/>    } else {<br/>        std::cout &lt;&lt; "Value is " &lt;&lt; x &lt;&lt; "\n";<br/>    }<br/>}</span><span id="4862" class="mf ky iq mb b gy mk mh l mi mj">int main() {<br/>    function(1); // OK, integral<br/>    function([]() { return 2; }); // OK, invocable, returns integral<br/>    function(2.0); // Fails<br/>}</span></pre><p id="f363" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们开始用像这样的复杂公式来牺牲可读性，所以让我们看看如何编写我们自己的概念。</p><h1 id="cf85" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">写作概念</h1><p id="fc29" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">编写新概念遵循以下语法:</p><pre class="km kn ko kp gt ma mb mc md aw me bi"><span id="f1f5" class="mf ky iq mb b gy mg mh l mi mj">template &lt;typename T&gt;<br/>concept Name = constraint_expression;</span></pre><p id="2688" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">约束表达式可以包含<code class="fe ml mm mn mb b">constexpr</code>布尔表达式、其他概念的合取/析取和<code class="fe ml mm mn mb b">requires</code>块。因此，对于我们之前的例子，我们可以使用C++11类型特征构造一个布尔表达式，或者从C++20标准库概念构造一个复合概念。</p><pre class="km kn ko kp gt ma mb mc md aw me bi"><span id="7668" class="mf ky iq mb b gy mg mh l mi mj">template &lt;typename T&gt;<br/>concept maybe_invokable_integral_v1 = std::is_integral&lt;T&gt;::value ||<br/>    (std::is_invocable&lt;T&gt;::value &amp;&amp;<br/>     std::is_integral&lt;typename std::invoke_result&lt;T&gt;::type&gt;::value);</span><span id="f0f5" class="mf ky iq mb b gy mk mh l mi mj">template &lt;typename T&gt;<br/>concept maybe_invokable_integral_v2 = std::integral&lt;T&gt; ||<br/>    (std::invocable&lt;T&gt; &amp;&amp;<br/>     std::integral&lt;typename std::invoke_result&lt;T&gt;::type&gt;);</span></pre><h2 id="3add" class="mf ky iq bd kz nd ne dn ld nf ng dp lh jy nh ni ll kc nj nk lp kg nl nm lt nn bi translated">需要表达</h2><p id="23fc" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">让我们更深入地研究一下在一个<code class="fe ml mm mn mb b">requires</code>表达式中使用的不同元素。</p><p id="710d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们能做的最简单的测试是测试一个表达式的有效性。在下面的例子中，我们也使用可选的参数列表来生成参数。然后我们可以在表达式中使用这些参数。这里我们测试该类型是否支持二进制加号运算符。</p><pre class="km kn ko kp gt ma mb mc md aw me bi"><span id="73a8" class="mf ky iq mb b gy mg mh l mi mj">template &lt;typename T&gt;<br/>concept addable = requires (T a, T b) {<br/>    a+b;<br/>};</span><span id="2772" class="mf ky iq mb b gy mk mh l mi mj">void function(addable auto x) {}<br/>struct X {};</span><span id="6a05" class="mf ky iq mb b gy mk mh l mi mj">int main() {<br/>    function(1); // OK<br/>    function(X{}); // Fails<br/>}</span></pre><p id="f741" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还可以测试类型有效性。引用的类型可以是模板，因此用于检查替换失败。</p><pre class="km kn ko kp gt ma mb mc md aw me bi"><span id="37fe" class="mf ky iq mb b gy mg mh l mi mj">#include &lt;concepts&gt;</span><span id="883e" class="mf ky iq mb b gy mk mh l mi mj">template &lt;typename T&gt;<br/>concept type_test = requires {<br/>    typename T::ElementType; // ElementType member type must exist<br/>};</span><span id="624f" class="mf ky iq mb b gy mk mh l mi mj">template &lt;std::integral T&gt;<br/>struct S;</span><span id="f9e6" class="mf ky iq mb b gy mk mh l mi mj">template &lt;typename T&gt;<br/>concept template_test = requires {<br/>    typename S&lt;T&gt;; // checks whether S&lt;T&gt; <br/>                   // is a valid template substitution<br/>};</span><span id="d727" class="mf ky iq mb b gy mk mh l mi mj">void function1(type_test auto x) {}<br/>void function2(template_test auto x) {}</span><span id="b3d1" class="mf ky iq mb b gy mk mh l mi mj">struct X { using ElementType = int; };</span><span id="18ea" class="mf ky iq mb b gy mk mh l mi mj">int main() {</span><span id="c57f" class="mf ky iq mb b gy mk mh l mi mj">    function1(X{}); // OK<br/>    function1(1); // Fails </span><span id="4f02" class="mf ky iq mb b gy mk mh l mi mj">    function2(1); // OK<br/>    function2(X{}); // Fails<br/>}</span></pre><p id="f4ef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">复合表达式允许我们约束表达式的结果。</p><pre class="km kn ko kp gt ma mb mc md aw me bi"><span id="5ebd" class="mf ky iq mb b gy mg mh l mi mj">#include &lt;concepts&gt;</span><span id="b3da" class="mf ky iq mb b gy mk mh l mi mj">template &lt;typename T&gt;<br/>concept invoke_integral = requires (T a) {<br/>    { a() } -&gt; std::integral;<br/>};</span><span id="cd94" class="mf ky iq mb b gy mk mh l mi mj">template &lt;invoke_integral T&gt;<br/>void function(const T&amp; f) {};</span><span id="a057" class="mf ky iq mb b gy mk mh l mi mj">int main() {<br/>    function([](){ return 1; }); // OK<br/>    function([](){ return 1.0; }); // Fail: doesn't return integral<br/>    function(1); // Fail: 1() is not a valid expression<br/>}</span></pre><p id="16d7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于复合表达式，我们也可以要求表达式是非抛出的。</p><pre class="km kn ko kp gt ma mb mc md aw me bi"><span id="2a0f" class="mf ky iq mb b gy mg mh l mi mj">template &lt;typename T&gt;<br/>concept assignment_cant_throw = requires (T a, T b) {<br/>    { a = b } noexcept;<br/>};</span><span id="e76f" class="mf ky iq mb b gy mk mh l mi mj">struct X {<br/>    X&amp; operator = (const X&amp; lhs) noexcept { return *this; }<br/>};</span><span id="4b68" class="mf ky iq mb b gy mk mh l mi mj">struct Y {<br/>    Y&amp; operator = (const Y&amp; lhs) { return *this; }<br/>};</span><span id="b26f" class="mf ky iq mb b gy mk mh l mi mj">template &lt;assignment_cant_throw T&gt; struct Test {};</span><span id="3d35" class="mf ky iq mb b gy mk mh l mi mj">int main() {<br/>    Test&lt;X&gt; a; // OK<br/>    Test&lt;Y&gt; b; // Fails<br/>}</span></pre><p id="4513" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，我们可以嵌套<code class="fe ml mm mn mb b">requires</code>表达式。这对于引用其他概念或构建嵌套的<code class="fe ml mm mn mb b">constexpr</code>布尔表达式非常有用。</p><p id="94f9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意，如果您在一个<code class="fe ml mm mn mb b">requires</code>块中列出一个概念，而没有在它前面加上前缀<code class="fe ml mm mn mb b">requires</code>，它将被视为一个表达式，只检查有效性(GCC已经警告过这一点)。</p><pre class="km kn ko kp gt ma mb mc md aw me bi"><span id="fa96" class="mf ky iq mb b gy mg mh l mi mj">template &lt;typename T&gt;<br/>concept x = requires (T a) {<br/>    requires sizeof(a) &gt;= 4;<br/>    requires std::integral&lt;T&gt;;<br/>    std::integral&lt;T&gt;; // probably not what you meant<br/>};</span></pre><h1 id="3c54" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">如何选择专业</h1><p id="2504" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">在前面所有的例子中，我们总是有一个单一的专门化，要么匹配，要么不匹配。概念允许我们提供一组专门化。编译器将首先确定可行的专门化，然后确定具有最具体约束的专门化。</p><p id="c0ce" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了确定哪个约束是最具体的，每个约束都将被展开，直到它成为合取/析取公式中的原子列表。请注意，在这里,<code class="fe ml mm mn mb b">requires</code>表达式被认为是一个原子，无论它有多复杂，如果你想利用这种行为，这意味着组织和编写你的概念。</p><p id="c143" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在下面的例子中，虽然<code class="fe ml mm mn mb b">has_x</code>概念可能看起来是<code class="fe ml mm mn mb b">coord</code>概念的子集，但是，基于扩展规则，这两个约束都是单个原子，并且因为这些原子不相同，所以这两个概念是无序的。</p><pre class="km kn ko kp gt ma mb mc md aw me bi"><span id="00f2" class="mf ky iq mb b gy mg mh l mi mj">template &lt;typename T&gt;<br/>concept has_x = requires (T v) {<br/>    v.x;<br/>};</span><span id="46e0" class="mf ky iq mb b gy mk mh l mi mj">template &lt;typename T&gt;<br/>concept coord = requires (T v) {<br/>    v.x;<br/>    v.y;<br/>};</span><span id="1e4c" class="mf ky iq mb b gy mk mh l mi mj">void function(has_x auto x) {}<br/>void function(coord auto x) {}</span><span id="3fc3" class="mf ky iq mb b gy mk mh l mi mj">struct X {<br/>    int x;<br/>};</span><span id="456d" class="mf ky iq mb b gy mk mh l mi mj">struct Y {<br/>    int x;<br/>    int y;<br/>};</span><span id="c2f2" class="mf ky iq mb b gy mk mh l mi mj">int main() {<br/>    function(X{}); // OK, only one viable candidate<br/>    function(Y{}); // Fails, ambiguous<br/>}</span></pre><p id="44ec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是，可以重写这些概念，使它们具有可比性，并且<code class="fe ml mm mn mb b">coord</code>概念包含<code class="fe ml mm mn mb b">has_x</code>概念。</p><pre class="km kn ko kp gt ma mb mc md aw me bi"><span id="d620" class="mf ky iq mb b gy mg mh l mi mj">template &lt;typename T&gt;<br/>concept has_x = requires (T v) {<br/>    v.x;<br/>};</span><span id="cd98" class="mf ky iq mb b gy mk mh l mi mj">template &lt;typename T&gt;<br/>concept coord = has_x&lt;T&gt; &amp;&amp; requires (T v) {<br/>    v.y;<br/>};</span><span id="9775" class="mf ky iq mb b gy mk mh l mi mj">void function(has_x auto x) {}<br/>void function(coord auto x) {}</span><span id="b3f7" class="mf ky iq mb b gy mk mh l mi mj">struct X {<br/>    int x;<br/>};</span><span id="821c" class="mf ky iq mb b gy mk mh l mi mj">struct Y {<br/>    int x;<br/>    int y;<br/>};</span><span id="b764" class="mf ky iq mb b gy mk mh l mi mj">int main() {<br/>    function(X{}); // OK, only one viable candidate<br/>    function(Y{}); // OK, coord is more specific<br/>}</span></pre><p id="3f75" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，如果你正在设计一个需要利用这种行为的库，在设计你的概念时要小心。</p><p id="2599" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">两个概念A和B的经验法则是:</p><ul class=""><li id="8033" class="mo mp iq jp b jq jr ju jv jy mq kc mr kg ms kk mt mu mv mw bi translated"><code class="fe ml mm mn mb b">A = (X1 ... XN); B = Y &amp;&amp; (X1 ... XN);</code> B被认为比A更具体</li><li id="d4a4" class="mo mp iq jp b jq my ju mz jy na kc nb kg nc kk mt mu mv mw bi translated"><code class="fe ml mm mn mb b">A = (X1 ... XN); B = Y || (X1 ... XN);</code> A被认为比B更具体</li></ul><h1 id="23b3" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">链接和技术说明</h1><p id="24df" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">所有的例子都使用GCC和Clang(2021年9月)的主干版本进行了演示。</p><p id="4e29" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所有代码示例和脚本都可以在:<a class="ae mx" href="https://github.com/HappyCerberus/article-cpp20-concepts" rel="noopener ugc nofollow" target="_blank">https://github.com/HappyCerberus/article-cpp20-concepts</a>获得。</p><h1 id="aea8" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">感谢您的阅读</h1><p id="50bd" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">感谢您阅读这篇文章。你喜欢吗？</p><p id="0236" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我还在YouTube<a class="ae mx" href="https://youtube.com/c/simontoth" rel="noopener ugc nofollow" target="_blank">youtube.com/c/simontoth</a>上发布视频，如果你想聊天，可以在Twitter <a class="ae mx" href="https://twitter.com/SimonToth83" rel="noopener ugc nofollow" target="_blank"> @SimonToth83 </a>或LinkedIn<a class="ae mx" href="https://www.linkedin.com/in/simontoth" rel="noopener ugc nofollow" target="_blank">linkedin.com/in/simontoth</a>上联系我。</p></div></div>    
</body>
</html>