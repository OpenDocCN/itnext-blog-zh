<html>
<head>
<title>Write best performance ListView with Riverpod in Flutter</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Flutter中使用Riverpod编写最佳性能的ListView</h1>
<blockquote>原文：<a href="https://itnext.io/write-best-performance-listviews-with-riverpod-in-flutter-8bf6590ed8b8?source=collection_archive---------0-----------------------#2022-12-18">https://itnext.io/write-best-performance-listviews-with-riverpod-in-flutter-8bf6590ed8b8?source=collection_archive---------0-----------------------#2022-12-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/a3517b2593c05032d88cbc7ab426f540.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Lh0MrNhwNn4WRSaCByTgCw.jpeg"/></div></div></figure><h2 id="7a88" class="jc jd je bd b dl jf jg jh ji jj jk dk jl translated" aria-label="kicker paragraph">Riverpod系列Listview的隐性成本</h2><div class=""/><div class=""><h2 id="7f58" class="pw-subtitle-paragraph ko jn je bd b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dk translated">让你的<code class="fe kk kl km kn b">ListView</code>更上一层楼，避免不必要的应用重建！</h2></div><p id="bb4e" class="pw-post-body-paragraph lg lh je li b lj lk ks ll lm ln kv lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated"><code class="fe kk kl km kn b">ListView</code>是最常用的小工具之一，我们总是以同样的方式使用它，但我们大多数人从来不知道它有隐藏的成本！</p><p id="9198" class="pw-post-body-paragraph lg lh je li b lj lk ks ll lm ln kv lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">这就是为什么，在这个系列中，我将向您展示隐藏的成本以及如何解决这些问题。</p><h1 id="a3dd" class="mc md je bd me mf mg mh mi mj mk ml mm kx mn ky mo la mp lb mq ld mr le ms mt bi translated">例子</h1><figure class="mv mw mx my gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mu"><img src="../Images/c95cf9b7d3c26dce67f8a06d8faeaa0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*V_thTzhGyKEbunQI6k0YLg.gif"/></div></div></figure><p id="f6c0" class="pw-post-body-paragraph lg lh je li b lj lk ks ll lm ln kv lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">该应用程序很简单，我们有一个随机名称的列表，当我们点击一个项目的名称会随机改变。</p><p id="7128" class="pw-post-body-paragraph lg lh je li b lj lk ks ll lm ln kv lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">我将使用<code class="fe kk kl km kn b"><a class="ae mz" href="https://pub.dev/packages/faker" rel="noopener ugc nofollow" target="_blank">faker</a></code>包来获得随机的名字，当然还有<code class="fe kk kl km kn b"><a class="ae mz" href="https://riverpod.dev/" rel="noopener ugc nofollow" target="_blank">riverpod</a></code>来管理状态。</p><figure class="mv mw mx my gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi na"><img src="../Images/91b20244cab9ae3ceaa846e6e56fd9ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4QQYdZdYt4cPHyc073ZzbA.png"/></div></div></figure><p id="689d" class="pw-post-body-paragraph lg lh je li b lj lk ks ll lm ln kv lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">我们有一个<code class="fe kk kl km kn b">StateProvider</code>来获取名单。</p><figure class="mv mw mx my gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nb"><img src="../Images/6d89813084f63c88ceb5f8fb35814ddd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OXQhrGuphyk89P6m0-BMMQ.png"/></div></div></figure><p id="3b11" class="pw-post-body-paragraph lg lh je li b lj lk ks ll lm ln kv lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">我们有一个<code class="fe kk kl km kn b">ListView</code>来显示名字。<br/>据我所知，我们写的大多是那种显示列表的代码。</p><h2 id="35c6" class="nc md je bd me nd ne dn mi nf ng dp mm lp nh ni mo lt nj nk mq lx nl nm ms jk bi translated">但问题到底出在哪里？一切看起来都很棒，对吧？</h2><p id="000e" class="pw-post-body-paragraph lg lh je li b lj nn ks ll lm no kv lo lp np lr ls lt nq lv lw lx nr lz ma mb im bi translated">让我们点击一个项目，看看我们得到的日志！</p><figure class="mv mw mx my gt iv gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/b32a7cf9f61748daf06c07a8a85f2f15.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*qgMnUNU-OHwCA9SRtiJpRw.jpeg"/></div></figure><p id="40ac" class="pw-post-body-paragraph lg lh je li b lj lk ks ll lm ln kv lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">当我们更新一个项目时，整个页面都会重建，它的项目也是如此！那是个相当大的问题，我们从未意识到。</p><h2 id="0051" class="nc md je bd me nd ne dn mi nf ng dp mm lp nh ni mo lt nj nk mq lx nl nm ms jk bi translated">好吧，但是，我们怎样才能防止呢？</h2><figure class="mv mw mx my gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nt"><img src="../Images/4b985d52bea9996ed080aaf18abc1a4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qZAgMHgJ9B2FcEYHKr5g-g.png"/></div></div></figure><blockquote class="nu"><p id="823f" class="nv nw je bd nx ny nz oa ob oc od mb dk translated">“分离部件，分离关注点”</p></blockquote><p id="34cb" class="pw-post-body-paragraph lg lh je li b lj oe ks ll lm of kv lo lp og lr ls lt oh lv lw lx oi lz ma mb im bi translated">首先，分离小部件并使它们成为常量小部件将会隔离它们并防止一些不必要的重建。</p><figure class="mv mw mx my gt iv gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/44e20c703190057d1e0ad64434416768.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*T3oEqlUrZvUCuJCGrDZDXw.jpeg"/></div></figure><p id="4993" class="pw-post-body-paragraph lg lh je li b lj lk ks ll lm ln kv lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">我们已经解决了页面重建的问题，但是,<code class="fe kk kl km kn b">ListView</code>和它的项目仍然在重建</p><h2 id="8317" class="nc md je bd me nd ne dn mi nf ng dp mm lp nh ni mo lt nj nk mq lx nl nm ms jk bi translated">我们现在能做什么？</h2><figure class="mv mw mx my gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oj"><img src="../Images/38545330137637e8cc3f14a0a6045d67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AHEciJu4dQo7DqCGnIIKPw.png"/></div></div></figure><h2 id="cc81" class="nc md je bd me nd ne dn mi nf ng dp mm lp nh ni mo lt nj nk mq lx nl nm ms jk bi translated">Provider.select((state) =&gt; state。ValueToWatch)</h2><p id="5f14" class="pw-post-body-paragraph lg lh je li b lj nn ks ll lm no kv lo lp np lr ls lt nq lv lw lx nr lz ma mb im bi translated">多亏了<code class="fe kk kl km kn b">riverpod</code>，<code class="fe kk kl km kn b">select</code>方法让我们可以过滤看什么。</p><p id="b632" class="pw-post-body-paragraph lg lh je li b lj lk ks ll lm ln kv lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">所以，我们可以只听状态中必要的部分，而忽略其他的变化。</p><p id="2b9e" class="pw-post-body-paragraph lg lh je li b lj lk ks ll lm ln kv lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">比如<code class="fe kk kl km kn b">ListView</code>只关心列表的<code class="fe kk kl km kn b">length</code>，不关心列表本身。</p><pre class="mv mw mx my gt ok kn ol bn om on bi"><span id="fb31" class="oo md je kn b be op oq l or os">// Do not forget<br/>// This one watches all the changes and triggers on every change.<br/>// Even if the length doesn't change.<br/>// because here, we watch the entire list and extract the length later.<br/>ref.watch(_listProvider).length;<br/><br/>// But this one watches only the length of the list.<br/>// It doesn't care about the other changes.<br/>// That's why it won't rebuild as long as length doesn't change<br/>ref.watch(_listProvider.select((e) =&gt; e.length));</span></pre><p id="aa40" class="pw-post-body-paragraph lg lh je li b lj lk ks ll lm ln kv lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">它对物品也有效！</p><pre class="mv mw mx my gt ok kn ol bn om on bi"><span id="1406" class="oo md je kn b be op oq l or os">// watch the list and get the index later<br/>ref.watch(_listProvider)[index];<br/>// watch only its item<br/>ref.watch(_listProvider.select((e) =&gt; e[index]));</span></pre><figure class="mv mw mx my gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ot"><img src="../Images/2707467619d4f24cee4892944dbb5ec8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-aJDT7Lq3Ukmobk95fQ_cA.png"/></div></div></figure><p id="b63a" class="pw-post-body-paragraph lg lh je li b lj lk ks ll lm ln kv lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">每个项目只看自己的项目，即使改变其他的，他们也不在乎。</p><p id="c9e4" class="pw-post-body-paragraph lg lh je li b lj lk ks ll lm ln kv lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">让我们看看新的结果，现在！</p><figure class="mv mw mx my gt iv gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/10f47d6735fb4b812332c257aca199fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:836/format:webp/1*diWllFd_OS42vw2mgnaZMA.jpeg"/></div></figure><p id="3edf" class="pw-post-body-paragraph lg lh je li b lj lk ks ll lm ln kv lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">当我更新一个项目时，只有该项目被更新，而不是其他项目。基本上，每个人都在关注自己的事业。</p><p id="b330" class="pw-post-body-paragraph lg lh je li b lj lk ks ll lm ln kv lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">但是，我们仍然有一个问题。</p><p id="c605" class="pw-post-body-paragraph lg lh je li b lj lk ks ll lm ln kv lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">如果我们在_ListView小部件中有一个状态，并且它不断地更新这个状态，会怎么样？</p><p id="3556" class="pw-post-body-paragraph lg lh je li b lj lk ks ll lm ln kv lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">(我将<code class="fe kk kl km kn b">_ListView</code>转换为<code class="fe kk kl km kn b">StatefulWidget</code>，并定期调用<code class="fe kk kl km kn b">setState</code>方法，向您展示这个问题。在这个场景中是没有意义的，但是我想给你看一个更重要的东西)</p><figure class="mv mw mx my gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ov"><img src="../Images/9a3f9aabefea1e4c48d6f061687b3b20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z_wtZzuk15sLc8WSqtlLyg.png"/></div></div></figure><p id="a74f" class="pw-post-body-paragraph lg lh je li b lj lk ks ll lm ln kv lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">新代码如下所示。<br/>现在让我们打开页面看看结果吧！</p><figure class="mv mw mx my gt iv gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/31041c57cb89d97f4fe628508950cd63.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*8UVKGGzS-o7naV_De0rNAA.jpeg"/></div></figure><p id="a4ae" class="pw-post-body-paragraph lg lh je li b lj lk ks ll lm ln kv lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">正如您所看到的，每次我们调用<code class="fe kk kl km kn b">setState</code>，整个列表和它的条目都会被重新构建。</p><p id="8cdd" class="pw-post-body-paragraph lg lh je li b lj lk ks ll lm ln kv lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">这里的主要问题是<code class="fe kk kl km kn b">_ListItem</code>不是const，因为它需要获取索引才能知道。</p><pre class="mv mw mx my gt ok kn ol bn om on bi"><span id="d8d6" class="oo md je kn b be op oq l or os">itemBuilder: (_, index) {<br/>  return _ListItem(index);<br/>},</span></pre><h2 id="672e" class="nc md je bd me nd ne dn mi nf ng dp mm lp nh ni mo lt nj nk mq lx nl nm ms jk bi translated">但是，我们如何将索引传递给<code class="fe kk kl km kn b">_ListItem</code>来防止这种情况呢？</h2><p id="c135" class="pw-post-body-paragraph lg lh je li b lj nn ks ll lm no kv lo lp np lr ls lt nq lv lw lx nr lz ma mb im bi translated">解决方案是再使用一个提供者。</p><figure class="mv mw mx my gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ow"><img src="../Images/f1711d059895105f2ba764e23a124487.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_P2e87oY5gFReLnM-D4iHA.png"/></div></div></figure><p id="ff43" class="pw-post-body-paragraph lg lh je li b lj lk ks ll lm ln kv lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">我们不想更新用户界面，这就是为什么我们要使用<code class="fe kk kl km kn b">Provider</code>，而不是<code class="fe kk kl km kn b">StateProvider</code>或其他。</p><p id="1cbe" class="pw-post-body-paragraph lg lh je li b lj lk ks ll lm ln kv lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">但是如您所知，Provider只获取一次值。这就是为什么我们需要覆盖每个索引的值。</p><figure class="mv mw mx my gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ox"><img src="../Images/f3cb36e591bee067e6a1296346581a80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9_Qmc-6mkW3m7pWYSJpjTA.png"/></div></div></figure><p id="fe26" class="pw-post-body-paragraph lg lh je li b lj lk ks ll lm ln kv lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated"><code class="fe kk kl km kn b">Riverpod</code>让我们像这样使用<code class="fe kk kl km kn b">ProviderScope</code>来覆盖提供者的值。</p><figure class="mv mw mx my gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ot"><img src="../Images/76c88b67775de59ed6db8c995735c04b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FE8LJgLCkcHKkhX_GMNIlQ.png"/></div></div></figure><p id="cf27" class="pw-post-body-paragraph lg lh je li b lj lk ks ll lm ln kv lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">我们可以像那样简单地阅读索引。</p><p id="420b" class="pw-post-body-paragraph lg lh je li b lj lk ks ll lm ln kv lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">所以过程很简单。</p><ol class=""><li id="cf10" class="oy oz je li b lj lk lm ln lp pa lt pb lx pc mb pd pe pf pg bi translated">从<code class="fe kk kl km kn b">ListView</code>获取索引</li><li id="b2ea" class="oy oz je li b lj ph lm pi lp pj lt pk lx pl mb pd pe pf pg bi translated">将索引分配给<code class="fe kk kl km kn b">indexProvider</code></li><li id="d17a" class="oy oz je li b lj ph lm pi lp pj lt pk lx pl mb pd pe pf pg bi translated">创建<code class="fe kk kl km kn b">_ListItem</code>并从提供者那里获取索引</li><li id="2153" class="oy oz je li b lj ph lm pi lp pj lt pk lx pl mb pd pe pf pg bi translated">转到下一个索引，重复直到结束。</li></ol><p id="8e13" class="pw-post-body-paragraph lg lh je li b lj lk ks ll lm ln kv lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">让我直观地展示一下新的逻辑。</p><figure class="mv mw mx my gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pm"><img src="../Images/be4cb68b32792e5b3d9d2b2501d3b7e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lRNU2zkoZcxhl6qiNTdxEA.jpeg"/></div></div></figure><p id="30ef" class="pw-post-body-paragraph lg lh je li b lj lk ks ll lm ln kv lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">基本上，我们不是将索引直接发送给<code class="fe kk kl km kn b">_ListItem</code>，而是将索引分配给<code class="fe kk kl km kn b">_indexProvider</code>，并在同步呈现<code class="fe kk kl km kn b">ListView</code>的同时从提供者处获取索引。(这不是一个<code class="fe kk kl km kn b">async</code>操作，所以您不必担心分配的索引不正确)</p><blockquote class="pn po pp"><p id="92d4" class="lg lh pq li b lj lk ks ll lm ln kv lo pr lq lr ls ps lu lv lw pt ly lz ma mb im bi translated">注意:当然，我们也可以找到其他的解决方案，比如，为计时器使用另一个提供者，不使用有状态的小部件，但是我想向您展示const小部件有多重要，以及如何优雅地使listitems成为常量</p></blockquote><p id="a381" class="pw-post-body-paragraph lg lh je li b lj lk ks ll lm ln kv lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">让我们看看控制台，再看一次新的结果！</p><figure class="mv mw mx my gt iv gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/a077df828d8fb7ee3ccb7aab72067fde.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*5g-LtlFQJFvU69cyALywIA.jpeg"/></div></figure><p id="0fa3" class="pw-post-body-paragraph lg lh je li b lj lk ks ll lm ln kv lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">正如你所看到的，甚至调用了<code class="fe kk kl km kn b">setState</code>，但是项目并没有在每个<code class="fe kk kl km kn b">build</code>上重新构建，因为<code class="fe kk kl km kn b">const</code>部件只在需要的时候构建它们自己。</p></div><div class="ab cl pu pv hx pw" role="separator"><span class="px bw bk py pz qa"/><span class="px bw bk py pz qa"/><span class="px bw bk py pz"/></div><div class="im in io ip iq"><h2 id="28f2" class="nc md je bd me nd ne dn mi nf ng dp mm lp nh ni mo lt nj nk mq lx nl nm ms jk bi translated">Github项目</h2><p id="ec60" class="pw-post-body-paragraph lg lh je li b lj nn ks ll lm no kv lo lp np lr ls lt nq lv lw lx nr lz ma mb im bi translated">你可以拿到最终的项目，自己去试一试！</p><div class="is it gp gr iu qb"><a href="https://github.com/rei-codes/advanced_list_riverpod" rel="noopener  ugc nofollow" target="_blank"><div class="qc ab fo"><div class="qd ab qe cl cj qf"><h2 class="bd jo gy z fp qg fr fs qh fu fw jn bi translated">GitHub-rei-codes/advanced _ list _ riverpod:使用river pod编写最佳性能的列表视图…</h2><div class="qi l"><h3 class="bd b gy z fp qg fr fs qh fu fw dk translated">一个新的颤振项目。这个项目是颤振应用的起点。一些帮助您入门的资源…</h3></div><div class="qj l"><p class="bd b dl z fp qg fr fs qh fu fw dk translated">github.com</p></div></div><div class="qk l"><div class="ql l qm qn qo qk qp ja qb"/></div></div></a></div></div><div class="ab cl pu pv hx pw" role="separator"><span class="px bw bk py pz qa"/><span class="px bw bk py pz qa"/><span class="px bw bk py pz"/></div><div class="im in io ip iq"><p id="96f6" class="pw-post-body-paragraph lg lh je li b lj lk ks ll lm ln kv lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">这是这个系列的第一部分。强烈推荐您关注我，不要错过下一个主题:))</p><h2 id="ae35" class="nc md je bd me nd ne dn mi nf ng dp mm lp nh ni mo lt nj nk mq lx nl nm ms jk bi translated">第1部分—编写更好的ListViews —当前</h2><p id="1180" class="pw-post-body-paragraph lg lh je li b lj nn ks ll lm no kv lo lp np lr ls lt nq lv lw lx nr lz ma mb im bi translated">第2部分—无缝无限列表—即将推出<br/>第3部分—缓存您的提供商并降低服务器成本<br/>第4部分—您可以向我推荐一个:)</p></div><div class="ab cl pu pv hx pw" role="separator"><span class="px bw bk py pz qa"/><span class="px bw bk py pz qa"/><span class="px bw bk py pz"/></div><div class="im in io ip iq"><h1 id="0983" class="mc md je bd me mf qq mh mi mj qr ml mm kx qs ky mo la qt lb mq ld qu le ms mt bi translated">感谢您的阅读！</h1><p id="db22" class="pw-post-body-paragraph lg lh je li b lj nn ks ll lm no kv lo lp np lr ls lt nq lv lw lx nr lz ma mb im bi translated">请不要忘记点击👏按钮，并有一个飘扬的一天！</p></div></div>    
</body>
</html>