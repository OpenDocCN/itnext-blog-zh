<html>
<head>
<title>What you YAML is what you Get — Using Helm without Tiller</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你所YAML的就是你所得到的——不用舵柄而用舵</h1>
<blockquote>原文：<a href="https://itnext.io/what-you-yaml-is-what-you-get-using-helm-without-tiller-d0eedcd7b1a5?source=collection_archive---------6-----------------------#2018-06-21">https://itnext.io/what-you-yaml-is-what-you-get-using-helm-without-tiller-d0eedcd7b1a5?source=collection_archive---------6-----------------------#2018-06-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="26ef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当开始使用Kubernetes时，学习如何编写清单并将它们带到apiserver通常是第一步。最有可能的是<code class="fe kl km kn ko b">kubectl apply</code>是这个命令。</p><p id="792c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里的好处是，您想要在集群上运行的所有东西都被精确地描述了，并且您可以很容易地检查什么将被发送到apiserver。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><a href="https://www.giantswarm.io/on-demand-webinar-kubernetes-hard-lessons-and-how-to-avoid-them?utm_campaign=Medium%20CTA%20Conversion&amp;utm_source=Kubernetes%20hard%20lessons_Medium&amp;utm_medium=Medium%20CTA&amp;utm_term=Kubernetes%20hard%20lessons"><div class="gh gi kp"><img src="../Images/4c23e20e890737d92efb5744ec5cef3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Up0-kEVp-9bPBwMJozqhSQ.png"/></div></a></figure><p id="8c85" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在享受了理解这是如何工作的快乐之后，复制清单并编辑不同文件上的相同字段以获得稍微调整的部署很快就变得麻烦了。</p><p id="cc62" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最明显的解决方案是模板化，Helm是Kubernetes生态系统中最著名的解决方案。大多数操作指南直接建议你安装集群侧Tiller组件，不幸的是这带来了一点操作开销，更重要的是你还需要注意<a class="ae kx" href="https://github.com/kubernetes/helm/blob/master/docs/securing_installation.md#best-practices-for-securing-helm-and-tiller" rel="noopener ugc nofollow" target="_blank">对Tiller </a>的安全访问，因为它是一个在你的集群中运行的具有完全管理权限的组件。</p><p id="76c2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你想知道实际上什么会被发送到集群，你可以省略Tiller，只在本地使用Helm作为模板，最后使用<code class="fe kl km kn ko b">kubectl apply</code>。</p><p id="02e1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不需要舵柄，大致有三个步骤可以遵循:</p><ol class=""><li id="75af" class="ky kz iq jp b jq jr ju jv jy la kc lb kg lc kk ld le lf lg bi translated">获取图表模板</li><li id="0a4f" class="ky kz iq jp b jq lh ju li jy lj kc lk kg ll kk ld le lf lg bi translated">使用可配置的值呈现模板</li><li id="d97c" class="ky kz iq jp b jq lh ju li jy lj kc lk kg ll kk ld le lf lg bi translated">将结果应用到群集</li></ol><p id="1238" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过这种方式，您可以从社区正在构建的大量维护图表中受益，但同时也拥有应用程序的所有构件。当将它们保存在git repo中时，可以很容易地将新版本的变更与您用来部署在集群上的当前清单进行比较。这种方法现在可能被称为<a class="ae kx" href="https://thenewstack.io/gitops-kubernetes-devops-iteration-focused-declarative-infrastructure/" rel="noopener ugc nofollow" target="_blank">gitop</a>。</p><p id="7e9b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">可能的目录结构如下所示:</p><pre class="kq kr ks kt gt lm ko ln lo aw lp bi"><span id="0ca4" class="lq lr iq ko b gy ls lt l lu lv">kubernetes-deployment/<br/>  charts/<br/>  values/<br/>  manifests/</span></pre><p id="0ece" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于以下步骤，需要在本地安装<a class="ae kx" href="https://github.com/kubernetes/helm/blob/master/docs/install.md#from-the-binary-releases" rel="noopener ugc nofollow" target="_blank"> helm客户端</a>。</p><h1 id="53c9" class="lw lr iq bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">获取图表模板</h1><p id="ea6e" class="pw-post-body-paragraph jn jo iq jp b jq mt js jt ju mu jw jx jy mv ka kb kc mw ke kf kg mx ki kj kk ij bi translated">要获取图表的源代码，需要存储库的url，还需要图表名称和想要的版本:</p><pre class="kq kr ks kt gt lm ko ln lo aw lp bi"><span id="3acc" class="lq lr iq ko b gy ls lt l lu lv">helm fetch \<br/>  --repo https://kubernetes-charts.storage.googleapis.com \<br/>  --untar \<br/>  --untardir ./charts \<br/>  --version 5.5.3 \<br/>    prometheus</span></pre><p id="b746" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此后，可以在<code class="fe kl km kn ko b">./charts/prometheus</code>下检查模板文件。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><a href="https://www.giantswarm.io/on-demand-webinar-kubernetes-hard-lessons-and-how-to-avoid-them?utm_campaign=Medium%20CTA%20Conversion&amp;utm_source=Kubernetes%20hard%20lessons_Medium&amp;utm_medium=Medium%20CTA&amp;utm_term=Kubernetes%20hard%20lessons"><div class="gh gi my"><img src="../Images/3ef8462f8c5043c2475daa2b6bdff075.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rU8OLgxaQhcnaAQ7CBfbXA.jpeg"/></div></a></figure><h1 id="60f2" class="lw lr iq bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">使用可配置的值呈现模板</h1><p id="0a6a" class="pw-post-body-paragraph jn jo iq jp b jq mt js jt ju mu jw jx jy mv ka kb kc mw ke kf kg mx ki kj kk ij bi translated">默认的<code class="fe kl km kn ko b">values.yaml</code>应该被复制到不同的位置进行编辑，这样在更新图表源时就不会被覆盖。</p><pre class="kq kr ks kt gt lm ko ln lo aw lp bi"><span id="9c5b" class="lq lr iq ko b gy ls lt l lu lv">cp ./charts/prometheus/values.yaml \<br/>  ./values/prometheus.yaml</span></pre><p id="4829" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">复制的<code class="fe kl km kn ko b">prometheus.yaml</code>现在可以根据需要进行调整。要使用可能已编辑的值文件从模板源呈现清单，请执行以下操作:</p><pre class="kq kr ks kt gt lm ko ln lo aw lp bi"><span id="0ee7" class="lq lr iq ko b gy ls lt l lu lv">helm template \<br/>  --values ./values/prometheus.yaml \<br/>  --output-dir ./manifests \<br/>    ./charts/prometheus</span></pre><h1 id="58a6" class="lw lr iq bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">将结果应用到群集</h1><p id="d573" class="pw-post-body-paragraph jn jo iq jp b jq mt js jt ju mu jw jx jy mv ka kb kc mw ke kf kg mx ki kj kk ij bi translated">现在，可以彻底检查生成的清单，并最终将其应用于集群:</p><pre class="kq kr ks kt gt lm ko ln lo aw lp bi"><span id="d06c" class="lq lr iq ko b gy ls lt l lu lv">kubectl apply --recursive --filename ./manifests/prometheus</span></pre><h1 id="415e" class="lw lr iq bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">结论</h1><p id="0b33" class="pw-post-body-paragraph jn jo iq jp b jq mt js jt ju mu jw jx jy mv ka kb kc mw ke kf kg mx ki kj kk ij bi translated">只需使用标准的<code class="fe kl km kn ko b">helm</code>命令，我们就可以仔细检查从图表内容到集群上出现的应用程序的整个链条。为了使这些步骤更加简单，我把它们放在一个简单的helm插件中，并命名为<a class="ae kx" href="https://github.com/giantswarm/helm-nomagic" rel="noopener ugc nofollow" target="_blank"> nomagic </a>。</p><h1 id="0854" class="lw lr iq bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">警告</h1><p id="ebe2" class="pw-post-body-paragraph jn jo iq jp b jq mt js jt ju mu jw jx jy mv ka kb kc mw ke kf kg mx ki kj kk ij bi translated">可能有龙。可能是这样的，一个应用程序需要不同种类的相互依赖的资源。例如，应用一个引用了一个<code class="fe kl km kn ko b">ServiceAccount</code>的<code class="fe kl km kn ko b">Deployment</code>将不会工作，直到它出现。作为一种变通方法，可以在<code class="fe kl km kn ko b">manifests/</code>下的服务帐户清单的文件名前加上前缀<code class="fe kl km kn ko b">1-</code>，因为<code class="fe kl km kn ko b">kubectl apply</code>是按字母顺序遍历文件的。这在带舵柄的系统中是不需要的，所以在上游图表中通常不考虑。交替运行<code class="fe kl km kn ko b">kubectl apply</code>两次，在第一次运行中创建所有独立对象。依赖者会在第二次运行后出现。</p><p id="7abf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">显然，你失去了蒂勒本身提供的功能。根据<a class="ae kx" href="https://github.com/kubernetes-helm/community/blob/master/helm-v3/000-helm-v3.md" rel="noopener ugc nofollow" target="_blank"> Helm 3设计方案</a>，这些将由Helm客户自身和可选的<a class="ae kx" href="https://github.com/kubernetes-helm/community/blob/master/helm-v3/008-controller.md" rel="noopener ugc nofollow" target="_blank"> Helm控制器</a>提供。随着Helm 3的发布，不再需要nomagic插件，但它也可能不再起作用，因为插件需要在Lua 中<a class="ae kx" href="https://github.com/kubernetes-helm/community/blob/master/helm-v3/005-plugins.md#lua-plugins" rel="noopener ugc nofollow" target="_blank">实现。所以趁它有用的时候抓住它吧！</a></p><p id="a7e2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请分享您对此的想法，其他警告或改进的想法。</p><p id="256e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一如既往:如果您对Giant Swarm如何在本地或云中运行您的Kubernetes感兴趣<a class="ae kx" href="https://giantswarm.io/" rel="noopener ugc nofollow" target="_blank">请立即联系我们</a>。</p><p id="7656" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">托拜厄斯·布拉德克——支持工程师@ <a class="ae kx" href="https://giantswarm.io/" rel="noopener ugc nofollow" target="_blank">巨型蜂群</a>撰写</p><div class="mz na gp gr nb nc"><a href="https://twitter.com/webwurst" rel="noopener  ugc nofollow" target="_blank"><div class="nd ab fo"><div class="ne ab nf cl cj ng"><h2 class="bd ir gy z fp nh fr fs ni fu fw ip bi translated">webwurst (@webwurst) | Twitter</h2><div class="nj l"><h3 class="bd b gy z fp nh fr fs ni fu fw dk translated">webwurst的最新推文(@webwurst)。兴趣:Kubernetes，Docker，微服务，Python 3，Elasticsearch…</h3></div><div class="nk l"><p class="bd b dl z fp nh fr fs ni fu fw dk translated">twitter.com</p></div></div><div class="nl l"><div class="nm l nn no np nl nq kv nc"/></div></div></a></div></div></div>    
</body>
</html>