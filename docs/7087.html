<html>
<head>
<title>The right way to use PHPicker and retrieve EXIF data without requesting library permissions in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用PHPicker和检索EXIF数据而无需在Swift中请求库权限的正确方法</h1>
<blockquote>原文：<a href="https://itnext.io/the-right-way-to-use-phpicker-and-retrieve-exif-data-without-requesting-library-permissions-in-336c13f87e3f?source=collection_archive---------0-----------------------#2022-06-08">https://itnext.io/the-right-way-to-use-phpicker-and-retrieve-exif-data-without-requesting-library-permissions-in-336c13f87e3f?source=collection_archive---------0-----------------------#2022-06-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="8cf1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这篇短文中，我将概述使用PHPicker的正确方法以及何时不使用PHPicker。这篇文章背后的原因是我在尝试用PHPicker构建一个本地库时遇到的挫折。互联网上的许多文章都在方法上有所限制，没有解决一些核心问题以及PHPicker和iOS权限的问题。</p><p id="e605" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们来谈谈存在的问题。</p><h2 id="0e26" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">PHPicker是什么？</h2><p id="de55" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">从iOS 14开始，PHPicker是系统提供的Picker，它允许您访问用户照片库中的照片和视频。</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi lj"><img src="../Images/e4530528fe066e40fb9f77a54f3138b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JoNgbmOS7EJsOsAQMgPNsQ.jpeg"/></div></div></figure><h2 id="23a0" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">PHPicker和库权限的问题</h2><blockquote class="lv"><p id="3153" class="lw lx iq bd ly lz ma mb mc md me kk dk translated">库权限不应该与PHPicker一起使用。</p></blockquote><p id="6c32" class="pw-post-body-paragraph jn jo iq jp b jq mf js jt ju mg jw jx jy mh ka kb kc mi ke kf kg mj ki kj kk ij bi translated">在使用具有库权限的PHPicker时，存在一些基本的用户体验问题。但是首先，为什么我们要在使用PHPicker时请求库权限呢？</p><p id="4a72" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">互联网上排名最高的文章鼓励您使用PHAsset和PHPicker来获取额外的数据，如exif和结果的位置信息。这样做的问题是，要获取PHAsset，您必须拥有库权限来访问资产，这违背了PHPicker的核心理念:Picker可以在不需要请求权限的情况下使用。</p><p id="e306" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">苹果公司自己甚至建议，你应该只在“必要”时请求许可，但不要详细说明这导致的边缘情况。</p><p id="fa3d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就像我说的…几个小时的挫折，我遇到的所有教程都鼓励你使用PHAsset来获取元数据。没有人建议你用其他方式获得exif元数据，这就是我今天要给你提供的，其他方式…正确的方式。</p><p id="f048" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">除了需要请求权限之外，另一个问题是用户何时选择受限的库访问。这可能会产生一些令人困惑的用户体验问题。PHPicker仍然会显示所有照片(甚至是没有通过有限Picker获得许可的照片),选择一张没有通过有限照片选择对话框获得许可的照片将导致应用程序无法检索⁴.相没有PHAsset，大多数关于如何获取元数据和处理PHPicker结果的教程都有所欠缺。</p><p id="04cf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从用户的角度来看，它看起来像这样:</p><p id="cad5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你的应用程序请求访问用户库<br/> <em class="mk">用户说:“我将只给这个应用程序有限的访问一些照片”</em></p><p id="f13a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您的应用程序打开PHPicker并显示所有照片<br/> <em class="mk">用户说:“哈，我以为我只给了有限的访问权限，哦好吧”</em></p><p id="1191" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">用户选择了一张他们没有给我们访问权限的照片。<br/> <em class="mk">应用程序现在需要什么都不做，或者向用户解释，要检索他们选择的照片的某些元数据，他们必须再次更新他们的权限。</em></p><p id="9f69" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">用户感到困惑。</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi ml"><img src="../Images/cf8f8d16632b6ff7bcb394d22620f12d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7JdA6CQlL72SBq7cl0xxGA.png"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">关于PHPicker的连环漫画</figcaption></figure><p id="5c69" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所有这些问题的发生都是因为我们将库权限与PHPicker结合使用。PHPicker从来不是用来这样使用的。许多教程推荐这种方式，无意中建议在使用PHPicker时使用PHAsset作为提取exif数据的直接方式。将PHAsset与PHPicker一起使用是一种反模式。</p><h2 id="7bc5" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">使用PHPicker的正确方法</h2><p id="f49d" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">为了创建一个易于遵循的指南，让我们从头开始。<br/>您想用一个配置来设置您的PHPicker并展示它:</p><pre class="lk ll lm ln gt mq mr ms mt aw mu bi"><span id="1b63" class="kl km iq mr b gy mv mw l mx my">var configuration = PHPickerConfiguration();<br/>...</span><span id="3cc0" class="kl km iq mr b gy mz mw l mx my">let picker = PHPickerViewController(configuration: configuration);<br/>picker.delegate = self<br/>self.present(picker, animated: true, completion: nil)</span></pre><p id="ca74" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后确保您的类扩展了<em class="mk">PHPickerViewControllerDelegate</em>、<em class="mk">UIAdaptivePresentationControllerDelegate</em>并实现了<em class="mk"> picker() </em>实例方法:</p><pre class="lk ll lm ln gt mq mr ms mt aw mu bi"><span id="8409" class="kl km iq mr b gy mv mw l mx my">class MyPickerClass: PHPickerViewControllerDelegate,         UIAdaptivePresentationControllerDelegate {</span><span id="3b99" class="kl km iq mr b gy mz mw l mx my">   func picker(<br/>     _ picker: PHPickerViewController, <br/>     didFinishPicking results: [PHPickerResult]<br/>   ) {<br/>      // This is where the magic happens 🪄<br/>   }<br/>}</span></pre><p id="b7e1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在在<em class="mk"> picker </em>方法中，我们可以在这里检索资产和元数据。在这一点上，大多数文章要么指导你使用<em class="mk">nsiteprovider</em>(它不需要库权限)，但没有告诉你如何获得exif数据，要么告诉你使用<em class="mk"> PHAsset </em>，这是使用<em class="mk"> PHPicker </em>的错误方式，因为我们需要⁵.的权限</p><blockquote class="lv"><p id="25c7" class="lw lx iq bd ly lz ma mb mc md me kk dk translated">PHAsset不应该与PHPicker一起使用，这不是使用这些API的正确方式</p></blockquote><p id="9a7b" class="pw-post-body-paragraph jn jo iq jp b jq mf js jt ju mg jw jx jy mh ka kb kc mi ke kf kg mj ki kj kk ij bi translated">现在让我们来看看代码。</p><p id="7579" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们希望循环遍历结果并提取NSItemProvider:</p><pre class="lk ll lm ln gt mq mr ms mt aw mu bi"><span id="bf9c" class="kl km iq mr b gy mv mw l mx my">func picker(<br/>  _ picker: PHPickerViewController, <br/>  didFinishPicking results: [PHPickerResult]<br/>) {<br/>  for result in results {<br/>     let itemProvider: NSItemProvider = result.itemProvider;<br/>  }<br/>}</span></pre><p id="2c66" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用<em class="mk"> itemProvider </em>我们现在可以读取对象的类型，并根据它是照片、视频还是其他东西来处理它。有几种方法可以做到这一点，但我发现最好的方法是:</p><pre class="lk ll lm ln gt mq mr ms mt aw mu bi"><span id="0eb0" class="kl km iq mr b gy mv mw l mx my">func picker(_ picker: PHPickerViewController, didFinishPicking results: [PHPickerResult]) {</span><span id="3700" class="kl km iq mr b gy mz mw l mx my">for result in results {<br/>        let itemProvider: NSItemProvider = result.itemProvider;</span><span id="c9ad" class="kl km iq mr b gy mz mw l mx my">if(itemProvider.hasItemConformingToTypeIdentifier(UTType.image.identifier)) {<br/>   // Handle the image here<br/>        } else  if(itemProvider.hasItemConformingToTypeIdentifier(UTType.movie.identifier)) {<br/>          // Handle the video here<br/>        } else {<br/>          // Unsupported asset<br/>        }<br/>    }<br/>}</span></pre><p id="bb73" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦我们知道了资产的类型，我们就可以加载它。在这种情况下，从<em class="mk">nsiteprovider</em>加载资产的最佳方式是<em class="mk"> loadFileRepresentation </em>，它允许我们轻松地访问exif数据。虽然您可以根据自己的需求使用<em class="mk"> loadItem </em>、<em class="mk"> loadFileRepresentation </em>、<em class="mk"> loadObject </em>等。参见<a class="ae na" href="https://developer.apple.com/documentation/foundation/nsitemprovider" rel="noopener ugc nofollow" target="_blank"> NSItemProvider </a>文档。</p><pre class="lk ll lm ln gt mq mr ms mt aw mu bi"><span id="065b" class="kl km iq mr b gy mv mw l mx my">func picker(_ picker: PHPickerViewController, didFinishPicking results: [PHPickerResult]) {</span><span id="2187" class="kl km iq mr b gy mz mw l mx my">for result in results {<br/>        let itemProvider: NSItemProvider = result.itemProvider;</span><span id="df36" class="kl km iq mr b gy mz mw l mx my">if(itemProvider.hasItemConformingToTypeIdentifier(UTType.image.identifier)) {<br/>   itemProvider.loadFileRepresentation(forTypeIdentifier: UTType.image.identifier) { data, error in<br/>    // Now we can get EXIF data<br/>           }<br/>        }<br/>    }<br/>}</span></pre><p id="344a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦我们有了<em class="mk">数据</em>对象，在这种情况下，当在图像上使用<em class="mk">加载文件表示</em>时，它将是类型<em class="mk"> URL </em>。我们可以使用它从资产中加载exif数据:</p><pre class="lk ll lm ln gt mq mr ms mt aw mu bi"><span id="e4ca" class="kl km iq mr b gy mv mw l mx my">if let url = data as? URL {<br/>   let options = [kCGImageSourceShouldCache as String:  kCFBooleanFalse]<br/>   let data = NSData(contentsOf: url)<br/>   let imgSrc = CGImageSourceCreateWithData(data, options as CFDictionary)<br/>   let metadata = CGImageSourceCopyPropertiesAtIndex(imgSrc, 0, options as CFDictionary)<br/>}</span></pre><p id="3151" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">元数据数据对象如下所示(从Xcode控制台拷贝):</p><pre class="lk ll lm ln gt mq mr ms mt aw mu bi"><span id="db6f" class="kl km iq mr b gy mv mw l mx my">ColorModel = RGB;<br/>DPIHeight = 72;<br/>DPIWidth = 72;<br/>Depth = 8;<br/>Orientation = 6;<br/>PixelHeight = 3024;<br/>PixelWidth = 4032;<br/>PrimaryImage = 1;<br/>ProfileName = "Display P3";<br/>"{TIFF}" = {<br/>    DateTime = "2022:05:26 14:28:29";<br/>    HostComputer = "iPhone XR";<br/>    Make = Apple;<br/>    Model = "iPhone XR";<br/>    Orientation = 6;<br/>    ResolutionUnit = 2;<br/>    Software = "15.4.1";<br/>    TileLength = 512;<br/>    TileWidth = 512;<br/>    XResolution = 72;<br/>    YResolution = 72;<br/>},<br/>"{Exif}" = {<br/>    ApertureValue = "1.69599381283836";<br/>    BrightnessValue = "2.126521070833867";<br/>    ColorSpace = 65535;<br/>    CompositeImage = 2;<br/>    DateTimeDigitized = "2022:05:26 14:28:29";<br/>    DateTimeOriginal = "2022:05:26 14:28:29";<br/>    ExifVersion =     (<br/>        2,<br/>        3,<br/>        2<br/>    );<br/>    ExposureBiasValue = 0;<br/>    ExposureMode = 0;<br/>    ExposureProgram = 2;<br/>    ExposureTime = "0.02";<br/>    FNumber = "1.8";<br/>    Flash = 16;<br/>    FocalLenIn35mmFilm = 26;<br/>    FocalLength = "4.25";<br/>    ISOSpeedRatings =     (<br/>        200<br/>    );<br/>    LensMake = Apple;<br/>    LensModel = "iPhone XR back camera 4.25mm f/1.8";<br/>    LensSpecification =     (<br/>        "4.25",<br/>        "4.25",<br/>        "1.8",<br/>        "1.8"<br/>    );<br/>    MeteringMode = 5;<br/>    OffsetTime = "+02:00";<br/>    OffsetTimeDigitized = "+02:00";<br/>    OffsetTimeOriginal = "+02:00";<br/>    PixelXDimension = 4032;<br/>    PixelYDimension = 3024;<br/>    SceneType = 1;<br/>    SensingMethod = 2;<br/>    ShutterSpeedValue = "5.644289064920122";<br/>    SubjectArea =     (<br/>        2013,<br/>        1511,<br/>        2217,<br/>        1330<br/>    );<br/>    SubsecTimeDigitized = 579;<br/>    SubsecTimeOriginal = 579;<br/>    WhiteBalance = 0;<br/>},<br/>"{GPS}" = {<br/>    Altitude = "19.96612929490311";<br/>    AltitudeRef = 0;<br/>    DestBearing = "272.5662841313811";<br/>    DestBearingRef = T;<br/>    HPositioningError = "7.460463890353189";<br/>    ImgDirection = "272.5662841313811";<br/>    ImgDirectionRef = T;<br/>    Latitude = "39.47537";<br/>    LatitudeRef = N;<br/>    Longitude = "0.3831666666666667";<br/>    LongitudeRef = W;<br/>    Speed = 0;<br/>    SpeedRef = K;<br/>},</span></pre><p id="2b86" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，您可以从元数据变量中提取如下属性:</p><pre class="lk ll lm ln gt mq mr ms mt aw mu bi"><span id="9970" class="kl km iq mr b gy mv mw l mx my">metadata[kCGImagePropertyColorModel];<br/>metadata[kCGImagePropertyPixelWidth];<br/>metadata[kCGImagePropertyPixelHeight];</span></pre><p id="3e3a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">很难处理这个对象，所以我创建了一个名为<a class="ae na" href="https://gist.github.com/lukebrandonfarrell/961a6dbc8367f0ac9cabc89b0052d1fe" rel="noopener ugc nofollow" target="_blank"> ExifData </a>的类，你可以用它来处理这个对象，它目前支持来自exif对象的26个值，你可以根据自己的需要扩展这个类。它可以这样使用:</p><pre class="lk ll lm ln gt mq mr ms mt aw mu bi"><span id="0393" class="kl km iq mr b gy mv mw l mx my">let exif = ExifData(data: data);<br/>let exif = ExifData(url: url);</span><span id="fda6" class="kl km iq mr b gy mz mw l mx my">exif.dateTimeDigitized</span></pre><p id="0829" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它支持使用<em class="mk">数据</em>、<em class="mk"> URL </em>或<em class="mk"> UIImage </em>进行初始化，这意味着您可以使用以下方法<em class="mk"> loadItem </em>(将返回一个<em class="mk"> UIImage </em>)、<em class="mk"> loadDataRepresentation </em>(将返回一个<em class="mk">数据</em>对象)和<em class="mk"> loadFileRepresentation </em>(将返回一个<em class="mk"> URL </em>)。</p><p id="39c0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">重要！</strong>需要注意的一点是<em class="mk"> UIImage.pngData() </em>和<em class="mk"> UIImage.jpegData() </em>从这些方法返回的结果<em class="mk"> Data </em>对象中剥离exif数据。因此，如果您使用这些方法进行压缩，请确保在此之前提取exif数据！</p></div><div class="ab cl nb nc hu nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ij ik il im in"><p id="e833" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们做到了！我们有一种方法可以使用<em class="mk"> PHPicker </em>获得资产，并且在不请求许可的情况下检索exif数据。由于<em class="mk"> ExifData </em>类我已经与你分享了接受<em class="mk"> URL </em>、<em class="mk">数据</em>和<em class="mk"> UIImage </em>数据类型，它应该给你在选择之后做你可能想要在图像上执行的其他操作的灵活性，例如压缩和调整大小。这里有一篇关于UIImage的大小调整和压缩的很棒的文章:<a class="ae na" href="https://nshipster.com/image-resizing/" rel="noopener ugc nofollow" target="_blank">图像大小调整技术— NSHipster </a>。</p><h2 id="3202" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">参考</h2><ul class=""><li id="89af" class="ni nj iq jp b jq le ju lf jy nk kc nl kg nm kk nn no np nq bi translated">[1] —苹果开发者文档[苹果开发者文档](<a class="ae na" href="https://developer.apple.com/documentation/photokit/phpickerviewcontroller" rel="noopener ugc nofollow" target="_blank">https://Developer . Apple . com/Documentation/photokit/phpickerviewcontroller</a>)。</li><li id="21cc" class="ni nj iq jp b jq nr ju ns jy nt kc nu kg nv kk nn no np nq bi translated">[2] —建议使用PHPicker的PHAsset的排名靠前的文章:[在SwiftUI中使用PHPicker获取照片元数据—Felix Larsen](<a class="ae na" href="https://www.felixlarsen.com/blog/photo-metadata-phpickerview" rel="noopener ugc nofollow" target="_blank">https://www . Felix Larsen . com/blog/photo-metadata-PHPicker view</a>)。</li><li id="4af6" class="ni nj iq jp b jq nr ju ns jy nt kc nu kg nv kk nn no np nq bi translated">[3] —苹果建议只有在“必要”的情况下才请求许可[见见新的照片拾取器— WWDC20 —视频—苹果开发者](【https://developer.apple.com/videos/play/wwdc2020/10652/? T42】时间=633 )。</li><li id="1a39" class="ni nj iq jp b jq nr ju ns jy nt kc nu kg nv kk nn no np nq bi translated">[4] — PHPicker和权限混淆【对PHPicker的隐私|苹果开发者论坛感到困惑】(<a class="ae na" href="https://developer.apple.com/forums/thread/652819" rel="noopener ugc nofollow" target="_blank">https://developer.apple.com/forums/thread/652819</a>)。</li><li id="b816" class="ni nj iq jp b jq nr ju ns jy nt kc nu kg nv kk nn no np nq bi translated">[5] —关于PHPicker的深度指南(不包括如何提取exif数据)iOS 14中PHPicker的完整指南](<a class="ae na" href="https://www.appcoda.com/phpicker/" rel="noopener ugc nofollow" target="_blank">https://www.appcoda.com/phpicker/</a>)。</li></ul></div></div>    
</body>
</html>