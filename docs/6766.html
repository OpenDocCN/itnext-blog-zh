<html>
<head>
<title>Sorting &amp; partitioning: The 114 C++ algorithms series</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">排序和分区:114 C++算法系列</h1>
<blockquote>原文：<a href="https://itnext.io/sorting-partitioning-the-114-c-algorithms-series-6503ad41cede?source=collection_archive---------2-----------------------#2022-02-21">https://itnext.io/sorting-partitioning-the-114-c-algorithms-series-6503ad41cede?source=collection_archive---------2-----------------------#2022-02-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="61f6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">欢迎阅读本系列的第二篇文章。标准C++库提供了一套高性能的排序、部分排序、分区和选择算法。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/27a36e515502a1ca660a339e5e6faa0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fCxMmAjg9oG4X65Pj9nXgA.png"/></div></div></figure><p id="c2df" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">今天，我们将从std::sort开始讨论字典比较和C++20宇宙飞船操作符。然后我们将讨论标准库中提供的排序、部分排序和划分算法的所有变体。</p><h2 id="ba6c" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">该系列:</h2><ul class=""><li id="fe08" class="lq lr iq jp b jq ls ju lt jy lu kc lv kg lw kk lx ly lz ma bi translated"><a class="ae mb" rel="noopener ugc nofollow" target="_blank" href="/the-114-standard-c-algorithms-introduction-2a75a2df4300">简介</a></li><li id="4b30" class="lq lr iq jp b jq mc ju md jy me kc mf kg mg kk lx ly lz ma bi translated">排序和分区算法</li><li id="8f1e" class="lq lr iq jp b jq mc ju md jy me kc mf kg mg kk lx ly lz ma bi translated"><a class="ae mb" rel="noopener ugc nofollow" target="_blank" href="/divide-conquer-and-sets-the-114-c-algorithms-series-d0085a38046e">对排序或分区范围进行操作的算法</a></li><li id="f7c1" class="lq lr iq jp b jq mc ju md jy me kc mf kg mg kk lx ly lz ma bi translated"><a class="ae mb" rel="noopener ugc nofollow" target="_blank" href="/transformations-the-114-c-algorithms-series-deacdbd4c373">转换算法</a></li><li id="5f59" class="lq lr iq jp b jq mc ju md jy me kc mf kg mg kk lx ly lz ma bi translated"><a class="ae mb" rel="noopener ugc nofollow" target="_blank" href="/left-folds-and-other-reductions-the-114-c-algorithms-series-6195724d324">左侧折叠和其他缩减</a></li><li id="dddd" class="lq lr iq jp b jq mc ju md jy me kc mf kg mg kk lx ly lz ma bi translated"><a class="ae mb" rel="noopener ugc nofollow" target="_blank" href="/generators-copies-and-moves-the-114-c-algorithms-series-1d0774472877">生成器、副本和移动</a></li><li id="6c9c" class="lq lr iq jp b jq mc ju md jy me kc mf kg mg kk lx ly lz ma bi translated"><a class="ae mb" rel="noopener ugc nofollow" target="_blank" href="/heap-and-heap-the-114-c-algorithms-series-1d4215ae9f0d">堆和堆</a></li><li id="a7f8" class="lq lr iq jp b jq mc ju md jy me kc mf kg mg kk lx ly lz ma bi translated"><a class="ae mb" href="https://medium.com/@simontoth/8a6ed951ad40" rel="noopener">搜索和最小值-最大值</a></li><li id="e5ab" class="lq lr iq jp b jq mc ju md jy me kc mf kg mg kk lx ly lz ma bi translated">结论(即将发布)</li></ul><h1 id="358a" class="mh ky iq bd kz mi mj mk lc ml mm mn lf mo mp mq li mr ms mt ll mu mv mw lo mx bi translated">分类</h1><p id="43de" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy my ka kb kc mz ke kf kg na ki kj kk ij bi translated">不出所料，基本的排序算法是std::sort。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nb"><img src="../Images/9febacdb2213f5fa5a98b85b39f8b259.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E_MQ6PZUNcBY0c8A4zKvMg.png"/></div></div></figure><p id="0a2a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">虽然std::sort的实际实现可能有所不同(通常是intro-sort)，但它保证是O(n*logn)比较(从C++11开始)。因此，它只能在随机访问范围内运行。这意味着我们不能将std::sort与std::list一起使用，STD::list确实提供了O(n*logn)排序作为方法。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="0819" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有了C++20，我们可以利用投影按方法或成员进行排序:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="1a2b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这里，我们按照计算值以降序(技术上是非升序)对账户进行排序。<code class="fe ne nf ng nh b">std::greater&lt;&gt;</code>是<code class="fe ne nf ng nh b">std::greater</code>的C++14专门化，它依赖于类型演绎来确定参数类型。在C++14之前，你必须指定类型(在这里是<code class="fe ne nf ng nh b">std::greater&lt;double&gt;()</code>)。</p><h2 id="85b9" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">使您的类型具有可比性</h2><p id="297f" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy my ka kb kc mz ke kf kg na ki kj kk ij bi translated">在示例中，我们对基本语言中具有内在可比性的类型使用std::sort，或者使用投影将自定义类型缩小到double类型。但是，有时您可能希望使您的自定义类型具有可比性。</p><p id="305a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们回到std::sort的要求。它期望一个严格_弱_排序，这意味着比较函子(或者小于运算符)需要是单向的:<em class="ni"> f(a，a) = false </em>，反对称:<em class="ni"> f(a，b) = true = &gt; f(b，a) = false </em>，传递:<em class="ni"> f(a，b) = true &amp; &amp; f(b，c) = true = &gt; f(a，c) = true </em>。</p><p id="bad1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您的特定数据类型没有特定于域的排序方式，那么一个可靠的默认方式就是字典排序。字典顺序也是标准容器提供的顺序。</p></div><div class="ab cl nj nk hu nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="ij ik il im in"><p id="4177" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在C++20中，随着飞船操作符的引入，为你的类型实现比较变得简单多了:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="bb4e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">默认的字典顺序(第13行)是递归的。它首先从对象的基开始，从左到右，深度优先，然后是声明顺序的非静态成员(从左到右，逐个元素地处理数组)。</p><p id="d54b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为spaceship运算符返回的类型是基和成员的通用比较类别类型:strong_ordering、weak_ordering或partial_ordering。</p><h1 id="574a" class="mh ky iq bd kz mi mj mk lc ml mm mn lf mo mp mq li mr ms mt ll mu mv mw lo mx bi translated">字典式比较，字典式比较三种方式</h1><p id="4ee3" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy my ka kb kc mz ke kf kg na ki kj kk ij bi translated">当讨论字典式比较时，我们必须讨论为范围提供这种功能的两种算法。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nq"><img src="../Images/64406b23d433f60bb106c3350ca05f99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0wRQo2LMhHmHD9sCAJknHg.png"/></div></div></figure><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="a01e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如我已经提到的，所有标准容器都通过它们的比较操作符(在C++20之前)或宇宙飞船操作符(从C++20开始)提供字典式比较。手动调用lexicographical _ compare的主要用途是在使用C样式数组时，或者当您想要指定一个自定义元素比较器时:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nc nd l"/></div></figure></div><div class="ab cl nj nk hu nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="ij ik il im in"><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nq"><img src="../Images/b869f54ea1a86355e5796be142652240.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K_nrEoxiPVRMmykD6w-c2A.png"/></div></div></figure><p id="0310" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">字典式比较三路是相当于字典式比较的太空船操作符。它返回strong_ordering、weak_ordering或partial_ordering类型之一(基于提供的函子)。</p><h1 id="9077" class="mh ky iq bd kz mi mj mk lc ml mm mn lf mo mp mq li mr ms mt ll mu mv mw lo mx bi translated">稳定排序</h1><p id="e14a" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy my ka kb kc mz ke kf kg na ki kj kk ij bi translated">std::sort可以自由地重新排列等价元素，这在对已经排序的范围重新排序时是不可取的。std::stable_sort为保持相等元素的相对顺序提供了额外的保证。如果有额外的内存可用，stable_sort保持为O(n*logn)。但如果分配失败，就会退化为O(n*logn*logn)算法。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nb"><img src="../Images/22bc049be45ec9876bafba6afbdb34cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-WE33fADP308Jk-2nBuMBg.png"/></div></div></figure><p id="ce61" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">虽然stable_sort在我们已经按照类型的每个方面进行排序时(例如，通过依赖于字典式比较)并不特别有用，但是当排序基于用户输入时(例如，在UI中按照列进行重新排序)，它经常出现。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nc nd l"/></div></figure><h1 id="4b9f" class="mh ky iq bd kz mi mj mk lc ml mm mn lf mo mp mq li mr ms mt ll mu mv mw lo mx bi translated">is_sorted，is_sorted_until</h1><p id="9867" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy my ka kb kc mz ke kf kg na ki kj kk ij bi translated">为了验证一个范围是否按照提供的谓词排序，我们可以使用is_sorted。默认谓词是std::less。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nq"><img src="../Images/1d4301ec5138fde9ed083eafe14cee33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gsMyM8oEWoDDiuaNd_RcbQ.png"/></div></div></figure><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nc nd l"/></div></figure></div><div class="ab cl nj nk hu nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="ij ik il im in"><p id="9c03" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">或者，我们可以使用is_sorted_until，它将迭代器返回到第一个无序元素。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nr"><img src="../Images/b36d484d1b0b72723cf54a778f672510.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lQ1y4lNdZhl5VW-pvGzPow.png"/></div></div></figure><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nc nd l"/></div></figure><h1 id="5288" class="mh ky iq bd kz mi mj mk lc ml mm mn lf mo mp mq li mr ms mt ll mu mv mw lo mx bi translated">部分排序，部分排序复制</h1><p id="1a30" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy my ka kb kc mz ke kf kg na ki kj kk ij bi translated">通常，我们只对排序顺序中最上面的两个元素感兴趣，这正是部分排序算法所提供的。使用部分排序的好处是运行时间更快——大约为O(n*logk ),其中k是排序的元素数量。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ns"><img src="../Images/ece7220585f818ff3e4bc7aa707366a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ss5asAsECfErQT-5kbCk7w.png"/></div></div></figure><p id="7cb6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用中间迭代器指定要排序的子范围，语义[begin，middle]表示范围的排序部分。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nc nd l"/></div></figure></div><div class="ab cl nj nk hu nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="ij ik il im in"><p id="9b31" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">partial_sort的一个变体是partial_sort_copy，它在处理不可变的源数据时很有优势。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nr"><img src="../Images/a0dc5004fd33bb9444f5d4fc63d5af6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ANVuOKTYXLfmmLeKpmPkmg.png"/></div></div></figure><p id="2f25" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个变体只要求目标范围是可变的和随机访问的。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nc nd l"/></div></figure><h1 id="ced1" class="mh ky iq bd kz mi mj mk lc ml mm mn lf mo mp mq li mr ms mt ll mu mv mw lo mx bi translated">分区，稳定分区，分区副本，已分区</h1><p id="8d8d" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy my ka kb kc mz ke kf kg na ki kj kk ij bi translated">分割算法将一个范围“分割”成两个子范围。首先是满足给定谓词的所有元素，其次是不满足谓词的所有元素。值得注意的是，3路分区是QuickSort的核心构件。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nb"><img src="../Images/39a86221ac72e93bcfe4e08e527b1d4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l3oiZYYM9c6xNQZbVe9lnQ.png"/></div></div></figure><p id="a6b0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们只是对按特定属性分组元素感兴趣，std::partition是解决方案。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="593d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这里，我们将考试结果分为及格和不及格的学生。分区算法返回分区点(第11行)。我们可以使用分割点来处理范围的两个部分(第16行和第19行)。</p></div><div class="ab cl nj nk hu nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="ij ik il im in"><p id="6121" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">与is_sorted类似，我们可以使用is_partitioned检查一个范围是否被分区(根据给定的谓词)。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ns"><img src="../Images/80b88b98494d62f4524b45f6d3735878.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*biWyBOOHjggM1gSMdLQmNA.png"/></div></div></figure><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nc nd l"/></div></figure></div><div class="ab cl nj nk hu nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="ij ik il im in"><p id="0817" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">稳定分区保证它不会改变项目的相对顺序。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nq"><img src="../Images/fc14896b8ecf72312a5b9b146bb39df6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8fONn9KGKKbBh3t7zTE5tA.png"/></div></div></figure><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="b614" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这段代码可能会令人困惑，因为我们用std::identity代替了谓词。但是，请注意，投影的结果是一个布尔值。因此，我们对谓词的所有要求就是转发这个值。</p></div><div class="ab cl nj nk hu nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="ij ik il im in"><p id="b038" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，partition_copy不会对输入范围重新排序，而是将两个分区复制到提供的输出范围。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nq"><img src="../Images/80bf760e66bb2b5de1bc22869aa20579.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EJi5QRNyIlKykQGSFC5AVw.png"/></div></div></figure><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="cb2f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们使用back_inserter适配器来填充这两个向量，而不需要预先分配足够的容量(适配器在内部调用push_back)。</p><h1 id="8e6a" class="mh ky iq bd kz mi mj mk lc ml mm mn lf mo mp mq li mr ms mt ll mu mv mw lo mx bi translated">第n个元素</h1><p id="c5a9" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy my ka kb kc mz ke kf kg na ki kj kk ij bi translated">有时，我们只需要选择一个超出范围的特定元素(例如，选择中值时)。由于O(n*logn)的复杂性，排序(即使是部分排序)可能是多余的。对于O(n)复杂度，我们需要使用一个选择算法，第n _ element就是其中之一。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nr"><img src="../Images/c1eba223c2264f457c14664016d78dcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NU5oDKPk3gvzMAzYGSTnkA.png"/></div></div></figure><p id="1c4d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用中间迭代器指定选取的元素。该算法将对范围进行重新排序，使该元素处于其排序后的位置。而且算法对范围进行了弱划分(中间之前的每个元素≤中间之后的每个元素)。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="dbbc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">根据您的用例，partial_sort有时会比nth_element更快，尽管理论上的复杂性更差。</p><h1 id="52a6" class="mh ky iq bd kz mi mj mk lc ml mm mn lf mo mp mq li mr ms mt ll mu mv mw lo mx bi translated">c标准库:qsort</h1><p id="e99a" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy my ka kb kc mz ke kf kg na ki kj kk ij bi translated">因为C标准库是C++标准库的一部分，所以我们也可以访问qsort。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="67c9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我强烈建议避免使用qsort，因为std::sort和std::ranges::sort在任何情况下都是更好的选择。此外，qsort只对普通的可复制类型有效，即使使用std::sort(如果需要的话)，也能正确地优化memcpy操作。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nc nd l"/></div></figure><h1 id="397f" class="mh ky iq bd kz mi mj mk lc ml mm mn lf mo mp mq li mr ms mt ll mu mv mw lo mx bi translated">感谢您的阅读</h1><p id="433b" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy my ka kb kc mz ke kf kg na ki kj kk ij bi translated">不要忘记关注，这样你就不会错过本系列的其他文章。例如，下一篇文章将讨论对排序或分区范围进行操作的算法。</p><p id="1c3b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我也在YouTube上发布视频。你有问题吗？在<a class="ae mb" href="https://twitter.com/SimonToth83" rel="noopener ugc nofollow" target="_blank">推特</a>或<a class="ae mb" href="https://www.linkedin.com/in/simontoth" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上联系我。</p></div></div>    
</body>
</html>