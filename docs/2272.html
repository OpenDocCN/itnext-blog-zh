<html>
<head>
<title>Phantom props, unnecessary renders and what no one told me about memo()</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">幻影道具，不必要的渲染和没人告诉我的memo()</h1>
<blockquote>原文：<a href="https://itnext.io/phantom-props-unnecessary-renders-and-what-no-one-told-me-about-memo-b34ebbd48c65?source=collection_archive---------0-----------------------#2019-04-28">https://itnext.io/phantom-props-unnecessary-renders-and-what-no-one-told-me-about-memo-b34ebbd48c65?source=collection_archive---------0-----------------------#2019-04-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/bbbfa07aa24e8a7ce8a4261fdf513c53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WYK3euihNQBmFaClZ0hGhA.png"/></div></div></figure><p id="3be2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在读了几篇关于提高你的应用程序性能(或者更确切地说，停止浪费你的资源)的文章后——这是对其他媒体作者的赞扬——我决定在我目前领导的一个工作项目中实施一些最佳实践。我想和你分享一些我一路走来的感悟。</p><h2 id="d5e2" class="kz la it bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated">首先——应用程序是什么样的</h2><p id="9ba7" class="pw-post-body-paragraph kb kc it kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">这是一个包装了更多小应用程序的应用程序，以便重用组件、主题、上下文、实用工具和用于管理不同界面的相同数据的东西——用不同的版本制作不同的应用程序没有意义。因此，它有各种包装布局的嵌套路由。</p><h2 id="2adf" class="kz la it bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated">我做了什么？</h2><ul class=""><li id="13b7" class="lx ly it kd b ke ls ki lt km lz kq ma ku mb ky mc md me mf bi translated">我为子应用程序实现了延迟加载。大多数时候你只会使用其中的一个，所以不延迟加载它是没有意义的。我只在根应用路由器级别这样做。随着应用程序的增长，我可能会将它添加到更多的级别，但目前它还很小。</li><li id="bc85" class="lx ly it kd b ke mg ki mh km mi kq mj ku mk ky mc md me mf bi translated">我在各种组件和包装器中实现了<code class="fe ml mm mn mo b">memo()</code>。我在这个过程中发现了一些问题，我将告诉你所有的问题，这样当它们发生在你身上时，你就知道如何解决它们。</li></ul><h2 id="c61a" class="kz la it bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated">问题是什么？</h2><p id="195e" class="pw-post-body-paragraph kb kc it kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">因为有亲身体验来理解一些事情总是更好，所以我在codesandbox中创建了这个虚拟应用程序。</p><figure class="mp mq mr ms gt ju"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="cf9c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你打开你的控制台，在<strong class="kd iu">成员</strong>和<strong class="kd iu">仪表板</strong>之间切换，你可以看到一个控制台日志，上面写着<code class="fe ml mm mn mo b">Header is being updated</code>，它说每次你切换路线。</p><p id="72f5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为什么呢？</p><p id="0968" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们的头球根本不用任何道具。我不想重新渲染它，在这种情况下永远不会。</p><h1 id="fe7a" class="mv la it bd lb mw mx my le mz na nb lh nc nd ne lk nf ng nh ln ni nj nk lq nl bi translated">React.memo(组件)</h1><p id="5e7a" class="pw-post-body-paragraph kb kc it kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">我猜你们大多数人都听说过memo高阶组件。你把你的<em class="nm">组件</em>包装在里面，它只在组件的道具改变时触发渲染，一切都很好。</p><figure class="mp mq mr ms gt ju gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/d202064668332289d1279534fa211308.png" data-original-src="https://miro.medium.com/v2/resize:fit:1006/format:webp/1*UEH33ktdBWNthnWPcmOQmg.png"/></div><figcaption class="no np gj gh gi nq nr bd b be z dk translated"><a class="ae ns" href="https://imgur.com/gallery/EuorOOj" rel="noopener ugc nofollow" target="_blank">https://imgur.com/gallery/EuorOOj</a></figcaption></figure><p id="6d55" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="nm"> React.memo() </em>做一个粗浅的比较。假设你有一些<code class="fe ml mm mn mo b">MemberList</code>组件，它基于你在远处商店某处的<code class="fe ml mm mn mo b">members</code>阵列进行更新。<code class="fe ml mm mn mo b">MemberList</code>为每个成员对象渲染<code class="fe ml mm mn mo b">MemberRow</code>，并得到它作为道具。</p><p id="713f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">你有10个成员。你加一个新的。你创建了一个新的数组。每个<code class="fe ml mm mn mo b">MemberRow</code>重新渲染，尽管你把它包装在一个<code class="fe ml mm mn mo b">memo()</code>中。浅层比较认为对象是新的——它不关心数据保持不变。它将触发另一个渲染，尽管你只需要为你刚刚添加的成员添加新的<code class="fe ml mm mn mo b">MemberRow</code>，而不需要刷新其他10个<code class="fe ml mm mn mo b">MemberRow</code></p><h1 id="df0e" class="mv la it bd lb mw mx my le mz na nb lh nc nd ne lk nf ng nh ln ni nj nk lq nl bi translated">React.memo(Component，propsAreEqual)</h1><h2 id="0eda" class="kz la it bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated">但是等等，你可以提供第二个参数来React.memo()！</h2><p id="7c2c" class="pw-post-body-paragraph kb kc it kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">这是我在一直阅读的文章中找不到的。所有人都在说<code class="fe ml mm mn mo b">memo()</code>有多棒，但是从来没有展示过任何真实的例子，肤浅的比较有时是不够的。我不得不读了大约4遍文件才真正找到这个，还不算我一直狂吃的文章。</p><div class="nt nu gp gr nv nw"><a href="https://reactjs.org/docs/react-api.html#reactmemo" rel="noopener  ugc nofollow" target="_blank"><div class="nx ab fo"><div class="ny ab nz cl cj oa"><h2 class="bd iu gy z fp ob fr fs oc fu fw is bi translated">反应顶级API -反应</h2><div class="od l"><h3 class="bd b gy z fp ob fr fs oc fu fw dk translated">React是React库的入口点。如果从一个标签加载React，这些顶级API可以在…</h3></div><div class="oe l"><p class="bd b dl z fp ob fr fs oc fu fw dk translated">reactjs.org</p></div></div><div class="of l"><div class="og l oh oi oj of ok jz nw"/></div></div></a></div><pre class="mp mq mr ms gt ol mo om on aw oo bi"><span id="3f2b" class="kz la it mo b gy op oq l or os">function MyComponent(props) {<br/>  /* render using props */<br/>}<br/>function areEqual(prevProps, nextProps) {<br/>  /*<br/>  return true if passing nextProps to render would return<br/>  the same result as passing prevProps to render,<br/>  otherwise return false<br/>  */<br/>}<br/>export default React.memo(MyComponent, areEqual);</span></pre><p id="5597" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">所以你也可以传递一个检查<code class="fe ml mm mn mo b">previousProps</code>和<code class="fe ml mm mn mo b">nextProps</code>的函数。这允许你做另一种比较——例如，如果你想确保你的数据确实匹配，并且不想触发重新渲染，就使用<code class="fe ml mm mn mo b">JSON.stringify()</code>。</p><p id="af85" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="nm">我还为此创建了一个高阶组件，我将在文章结尾展示/链接它。</em></p><p id="f3e4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在让我们从代码沙箱回到我的不断更新的<code class="fe ml mm mn mo b">&lt;Header /&gt;</code>组件。</p><h2 id="ee2c" class="kz la it bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated">把它包在备忘录里一点用都没有</h2><p id="af65" class="pw-post-body-paragraph kb kc it kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">没错，因为我说过，它没有道具。然而，它正在更新。这是为什么呢？</p><p id="ba0b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因为整个布局都在更新。</p><p id="a215" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我把小提琴更新了一点，让我们看看</p><figure class="mp mq mr ms gt ju"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="no np gj gh gi nq nr bd b be z dk translated">观看布局也刷新控制台</figcaption></figure><p id="1d62" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">再次打开您的控制台，然后单击各种路线。我添加了另一个console.log，上面写着<code class="fe ml mm mn mo b">Admin layout is being updated</code>。可以在<code class="fe ml mm mn mo b">views/Admin.js</code>文件中查看。因此，如果整个管理布局在更新，我们的<code class="fe ml mm mn mo b">&lt;Header /&gt;</code>当然也在更新！但是为什么会发生这种情况——我们没有使用任何道具，我们没有改变组件状态，为什么我们要重新渲染？</p><h1 id="24ff" class="mv la it bd lb mw mx my le mz na nb lh nc nd ne lk nf ng nh ln ni nj nk lq nl bi translated">幻影道具</h1><p id="c79e" class="pw-post-body-paragraph kb kc it kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">仅仅因为你没有使用它们，并不意味着它们不存在。在我看来，这是一个设计错误，但我不是在这里给出不想要的意见，我是在这里让应用程序更快地与我得到的东西一起工作。哈🤷🏻</p><p id="e6cd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你检查<code class="fe ml mm mn mo b">index.js</code>文件，你可以看到我们已经嵌套了路线和它们的布局——很像我正在使用的应用程序。</p><pre class="mp mq mr ms gt ol mo om on aw oo bi"><span id="a142" class="kz la it mo b gy op oq l or os"><strong class="mo iu">function </strong>App() {<br/>  <strong class="mo iu">return </strong>(<br/>    &lt;<strong class="mo iu">div</strong>&gt;<br/>      &lt;<strong class="mo iu">Router</strong>&gt;<br/>        &lt;<strong class="mo iu">Switch</strong>&gt;<br/>          &lt;<strong class="mo iu">Redirect from="/" to="/admin" exact </strong>/&gt;<br/>          &lt;<strong class="mo iu">Route path="/admin" component=</strong>{Admin} /&gt;<br/>          &lt;<strong class="mo iu">Route path="/blog" component=</strong>{Blog} /&gt;<br/>        &lt;/<strong class="mo iu">Switch</strong>&gt;<br/>      &lt;/<strong class="mo iu">Router</strong>&gt;<br/>    &lt;/<strong class="mo iu">div</strong>&gt;<br/>  );<br/>}}</span></pre><p id="2fa9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们正在渲染<code class="fe ml mm mn mo b">&lt;Admin /&gt;</code>组件——就是那个对我们大喊<code class="fe ml mm mn mo b">Admin layout is being updated</code>的家伙。因为它是来自<em class="nm"> react-router-dom </em>包的<code class="fe ml mm mn mo b">&lt;Route /&gt;</code>组件，所以它会自动获得<code class="fe ml mm mn mo b">history</code>道具。如果我们在<code class="fe ml mm mn mo b">&lt;Admin /&gt;</code>组件中登录<em class="nm">道具</em>，你就可以自己看到了。</p><figure class="mp mq mr ms gt ju"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="no np gj gh gi nq nr bd b be z dk translated">您可以在管理组件中看到这些属性</figcaption></figure><p id="7896" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">所以基本上——它们在那里，我们没有使用它们，但它们仍然在那里，它们触发渲染。在我的真实项目中，每当我在子应用中点击一条路线时，我的整个布局都会更新。过渡甚至是动画。那是完全没有必要的矫枉过正。</p><h2 id="4067" class="kz la it bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated">memo()它！</h2><p id="ea2f" class="pw-post-body-paragraph kb kc it kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">我想用<code class="fe ml mm mn mo b">memo()</code>。但是也许你们中的一些人已经猜到了——简单的<code class="fe ml mm mn mo b">memo()</code>是行不通的，因为我们的道具当然在变。我们必须利用传递第二个参数的选项来让强大的<code class="fe ml mm mn mo b">memo()</code>屈服于我们的意志。</p><p id="0991" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="nm"> (Danaerys在远处喊:“屈膝！”)</em></p><p id="8a96" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是将<code class="fe ml mm mn mo b">&lt;Admin /&gt;</code>组件包装在一个<code class="fe ml mm mn mo b">withMemo()</code> hoc中的最后一把小提琴，我创建它是为了避免重复渲染。</p><p id="e7ff" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如你所见，<code class="fe ml mm mn mo b">&lt;Admin /&gt;</code>组件和<code class="fe ml mm mn mo b">&lt;Header /&gt;</code>组件都没有被重新渲染。</p><p id="8c56" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">没有必要为此创建高阶组件，您可以在组件中编写<code class="fe ml mm mn mo b">memo()</code>的函数。然而，我发现这更容易，因为我在工作中编写的应用程序中重用了它。</p><figure class="mp mq mr ms gt ju"><div class="bz fp l di"><div class="mt mu l"/></div></figure><h1 id="bf7c" class="mv la it bd lb mw mx my le mz na nb lh nc nd ne lk nf ng nh ln ni nj nk lq nl bi translated">带备忘录(组件，检查过的Props)</h1><p id="e858" class="pw-post-body-paragraph kb kc it kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">这是特设的，它只在某个属性改变时才更新组件。当然可以通过多个道具。它是这样使用的</p><pre class="mp mq mr ms gt ol mo om on aw oo bi"><span id="b357" class="kz la it mo b gy op oq l or os">import React from 'react';<br/>import withMemo from './withMemo';<br/><br/>const MemberRow = ({ member, handleDeleteMember }) =&gt; (<br/>  &lt;div&gt;Hi, this is {member.name} {member.surname}&lt;/div&gt;<br/>);<br/><br/>export default withMemo(MemberRow, ['member']);</span></pre><p id="2741" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在本例中，<code class="fe ml mm mn mo b">&lt;MemberRow /&gt;</code>组件仅在您更改<code class="fe ml mm mn mo b">member</code>属性时更新。它根本不在乎它的另一个道具——<code class="fe ml mm mn mo b">handleDeleteMember</code>——在变。提供一个空的参数数组意味着重新渲染不是基于props，如果你的父组件没有更新，那么使用<code class="fe ml mm mn mo b">[]</code>作为变化参数的<code class="fe ml mm mn mo b">withMemo()</code>中的组件也不应该更新。</p><p id="7083" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你想在小提琴中找到它，它位于<code class="fe ml mm mn mo b">utils/</code>文件夹中。</p><h1 id="2cd7" class="mv la it bd lb mw mx my le mz na nb lh nc nd ne lk nf ng nh ln ni nj nk lq nl bi translated">给每个兴奋的开发者一个小小的警告</h1><p id="dd70" class="pw-post-body-paragraph kb kc it kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">一个我不知道的功能—我想使用它！</p><p id="4fd8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">好吧，随你便，但要小心行事。道具的存在是有原因的——在理想世界中，组件应该只获得它所关心的数据，如果它们发生变化，它们肯定应该触发重新渲染。不要在你的应用程序中到处都做这个检查——你可能会破坏你的渲染，并发现自己处于一个艰难的调试点。</p><p id="6fe2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">大多数情况下，你可以改变一个组件的属性。在我的<code class="fe ml mm mn mo b">&lt;Route /&gt;</code>案例中，我不能，但是我可以一直使用嵌套组件，为路由逻辑保留<code class="fe ml mm mn mo b">Route</code>,并在其中为<code class="fe ml mm mn mo b">Layout</code>逻辑创建一个新组件——这样它就不会有<code class="fe ml mm mn mo b">history</code>属性，也不会被重新渲染(但是<code class="fe ml mm mn mo b">&lt;Route /&gt;</code>组件会)。</p><p id="d385" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">不要对不需要的组件进行昂贵的检查。先考虑建筑。</p><h2 id="e201" class="kz la it bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated">redditors给我的有用笔记</h2><ul class=""><li id="7cdc" class="lx ly it kd b ke ls ki lt km lz kq ma ku mb ky mc md me mf bi translated">来自<code class="fe ml mm mn mo b">react-router-dom</code>的<code class="fe ml mm mn mo b">&lt;Route /&gt;</code>组件有其他使用<code class="fe ml mm mn mo b">component={}</code>属性的渲染选项。如果你想自定义渲染逻辑(比如省略道具)，你可以使用<code class="fe ml mm mn mo b">&lt;Route /&gt;</code>组件的<code class="fe ml mm mn mo b">render={}</code>属性。</li><li id="bea5" class="lx ly it kd b ke mg ki mh km mi kq mj ku mk ky mc md me mf bi translated">使用<code class="fe ml mm mn mo b">useCallback()</code>也能让你的生活更轻松(我希望我能给你这方面的指导，但是我没有实践经验。不过，我会确保很快获得一些！)</li></ul><p id="3135" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">TL；速度三角形定位法(dead reckoning)</p><ul class=""><li id="d585" class="lx ly it kd b ke kf ki kj km ot kq ou ku ov ky mc md me mf bi translated">使用<code class="fe ml mm mn mo b">React.memo()</code>不会解决你所有的问题。确保你使用第二个参数<code class="fe ml mm mn mo b">React.memo(Component, propsAreEqual)</code>来比较前一个和下一个道具——如果你需要调整你的渲染。小心过度使用——试着想想是否有另一种更干净的方法来解决这个问题。最后，你的组件应该只接收它所关心的道具。</li><li id="f8cf" class="lx ly it kd b ke mg ki mh km mi kq mj ku mk ky mc md me mf bi translated">小心幽灵道具——仅仅因为你不用它们，并不意味着它们不在那里。如果它们在那里，你可以确定它们会触发渲染。</li><li id="9acc" class="lx ly it kd b ke mg ki mh km mi kq mj ku mk ky mc md me mf bi translated">智能结构——保持组件较小，且仅用于单一、清晰的目的。如果结构清晰，调试代码就容易多了。你可以注意到，记忆小提琴中的<code class="fe ml mm mn mo b">&lt;Admin /&gt;</code>组件解决了我们所有的问题，我们不需要对<code class="fe ml mm mn mo b">&lt;Header /&gt;</code>组件做任何事情。如果结构不同并且<code class="fe ml mm mn mo b">&lt;Header /&gt;</code>组件位于<code class="fe ml mm mn mo b">&lt;Admin /&gt;</code>组件之外，则必须再次使用<code class="fe ml mm mn mo b">memo()</code>。</li><li id="361c" class="lx ly it kd b ke mg ki mh km mi kq mj ku mk ky mc md me mf bi translated">做代码——自己尝试，拨弄，阅读文章，调试应用程序中发生的事情。最终，这是对你最好的教育。</li><li id="a51b" class="lx ly it kd b ke mg ki mh km mi kq mj ku mk ky mc md me mf bi translated"><a class="ae ns" href="https://github.com/DJanoskova/React-withMemo-" rel="noopener ugc nofollow" target="_blank">与GitHub上的Memo()一起</a></li><li id="902e" class="lx ly it kd b ke mg ki mh km mi kq mj ku mk ky mc md me mf bi translated">一如既往，祝你好运，编码快乐！</li></ul></div></div>    
</body>
</html>