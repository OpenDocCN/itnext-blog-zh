<html>
<head>
<title>Kotlin: Type aliases and inline classes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kotlin:类型别名和内联类</h1>
<blockquote>原文：<a href="https://itnext.io/kotlin-type-aliases-and-inline-classes-ebe9d75f6715?source=collection_archive---------3-----------------------#2019-07-17">https://itnext.io/kotlin-type-aliases-and-inline-classes-ebe9d75f6715?source=collection_archive---------3-----------------------#2019-07-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/f94489588d509306a2896c0ce4ea713f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*iKk7vhoD-K9tnBzk"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@bdchu614?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">布伦丹·丘奇</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="ee06" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi lb translated"><span class="l lc ld le bm lf lg lh li lj di"> T </span>毫无疑问，Kotlin将长期存在，更何况谷歌刚刚在最近的Google I/O 2019上宣布<em class="lk"> Kotlin现在是谷歌Android应用开发的首选语言。</em></p><blockquote class="ll lm ln"><p id="b7eb" class="kd ke lk kf b kg kh ki kj kk kl km kn lo kp kq kr lp kt ku kv lq kx ky kz la ij bi translated">今天我们宣布了另一个重大进展:Android开发将变得越来越优先。许多新的Jetpack APIs和特性将首先在Kotlin中提供。如果你正在开始一个新项目，你应该用Kotlin写它；用Kotlin编写的代码通常意味着更少的代码——需要键入、测试和维护的代码更少。</p></blockquote><div class="lr ls gp gr lt lu"><a href="https://android-developers.googleblog.com/2019/05/google-io-2019-empowering-developers-to-build-experiences-on-Android-Play.html" rel="noopener  ugc nofollow" target="_blank"><div class="lv ab fo"><div class="lw ab lx cl cj ly"><h2 class="bd ir gy z fp lz fr fs ma fu fw ip bi translated">Google I/O 2019:赋能开发者在Android + Play上构建最佳体验</h2><div class="mb l"><h3 class="bd b gy z fp lz fr fs ma fu fw dk translated">很高兴谷歌I/O再次来到我们的后院，与世界各地的Android开发者建立联系。7200……</h3></div><div class="mc l"><p class="bd b dl z fp lz fr fs ma fu fw dk translated">android-developers.googleblog.com</p></div></div><div class="md l"><div class="me l mf mg mh md mi jw lu"/></div></div></a></div></div><div class="ab cl mj mk hu ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ij ik il im in"><p id="b58e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Kotlin是一种现代编程语言，所以今天我们将看到两个很酷的特性:<strong class="kf ir">类型别名</strong>和<strong class="kf ir">内联类</strong>。</p><h1 id="1c3f" class="mq mr iq bd ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn bi translated">键入别名</h1><p id="1aae" class="pw-post-body-paragraph kd ke iq kf b kg no ki kj kk np km kn ko nq kq kr ks nr ku kv kw ns ky kz la ij bi translated">类型别名为您提供了一种为现有类型设置替代名称的好方法。</p><p id="83d9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们都遇到过这样的情况，某个类的名字太长或太复杂。使用类型别名，你可以引入一个不同的更短或更有意义的名字并使用新的名字。</p><p id="fd94" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们想象下面的场景，其中您设置了一对带有用户名和密码的字符串。</p><figure class="nx ny nz oa gt jr"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="f24a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我已经创建了一个实例<code class="fe nt nu nv nw b">Pair</code>,作为用户名和散列密码，然而这并没有给我太多的上下文，也不是很清楚。</p><p id="0fcb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">类似这样的事情不会更好:</p><figure class="nx ny nz oa gt jr"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="fcb1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这为您的代码提供了更好的上下文和可读性。</p><p id="2b4b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">类型别名不引入新类型</strong>。它们相当于相应的基础类型。</p><p id="d4af" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一个可以使用类型别名的好例子是，当你需要在同一个地方使用两个同名但不同包的类时。发生这种情况时，您通常通过第二个类的完全限定类名来引用它。这种情况可以这样绕过:</p><figure class="nx ny nz oa gt jr"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="8510" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">类型别名也可以用来命名函数类型，也可以与函数类型参数名称一起使用。</p><figure class="nx ny nz oa gt jr"><div class="bz fp l di"><div class="ob oc l"/></div></figure></div><div class="ab cl mj mk hu ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ij ik il im in"><h1 id="0018" class="mq mr iq bd ms mt od mv mw mx oe mz na nb of nd ne nf og nh ni nj oh nl nm nn bi translated">内嵌类</h1><p id="6395" class="pw-post-body-paragraph kd ke iq kf b kg no ki kj kk np km kn ko nq kq kr ks nr ku kv kw ns ky kz la ij bi translated">有时，出于业务逻辑或代码可读性的考虑，有必要创建某种类型的包装器，但这会由于额外的堆分配而产生运行时开销。</p><p id="725f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了避免这种情况，在Kotlin 1.3的<strong class="kf ir">内嵌类</strong>中引入了<strong class="kf ir"> ( </strong>实验⚠️feature).这些特殊的类使得这种改进成为可能，因为数据被内联到它的使用中，事实上对象实例化被跳过。</p><p id="ef69" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">内联类必须有一个在主构造函数中初始化的<strong class="kf ir">属性。</strong></p><figure class="nx ny nz oa gt jr"><div class="bz fp l di"><div class="ob oc l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">内联类的声明</figcaption></figure><p id="3893" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如前所述，当您使用内联类时，不会发生实际的实例化。在运行时，内联类的实例将使用这个属性来表示。请看下面的例子:</p><figure class="nx ny nz oa gt jr"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="c0c0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">没有发生类<strong class="kf ir"> <em class="lk">年龄</em> </strong> &amp; <strong class="kf ir"> <em class="lk">身高</em> </strong>的实际实例化，在运行时<em class="lk">年龄用户1 </em>和<em class="lk">身高1 </em>只包含<strong class="kf ir"> <em class="lk"> Int </em> </strong></p><p id="f2a6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像常规类一样，它们也可以有属性和函数，并且可以从接口继承，但是有一些限制:</p><ul class=""><li id="daae" class="oi oj iq kf b kg kh kk kl ko ok ks ol kw om la on oo op oq bi translated">不允许使用<em class="lk"> init </em>块；</li><li id="3cd9" class="oi oj iq kf b kg or kk os ko ot ks ou kw ov la on oo op oq bi translated">属性不能有支持字段；</li><li id="4e00" class="oi oj iq kf b kg or kk os ko ot ks ou kw ov la on oo op oq bi translated">不能参与一个类的层次结构，这意味着它们不允许扩展其他类，它们必须是<strong class="kf ir"> <em class="lk"> final </em> </strong>。</li></ul></div><div class="ab cl mj mk hu ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ij ik il im in"><p id="d94b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你到了这里，你可能会问自己:</p><blockquote class="ow"><p id="3c30" class="ox oy iq bd oz pa pb pc pd pe pf la dk translated">内联类和类型别名不是一样的吗？</p></blockquote><figure class="pg ph pi pj pk jr"><div class="bz fp l di"><div class="pl oc l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">我知道这种痛苦😅</figcaption></figure><p id="c333" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它们看起来非常相似，因为两者似乎都引入了新的类型，并且在运行时都被表示为底层类型。</p><p id="0137" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，它们是不同的</p><ul class=""><li id="6216" class="oi oj iq kf b kg kh kk kl ko ok ks ol kw om la on oo op oq bi translated">内联类引入了一个真正的新类型；</li><li id="5181" class="oi oj iq kf b kg or kk os ko ot ks ou kw ov la on oo op oq bi translated"><em class="lk">类型别名</em>只为一个现有类型引入一个<strong class="kf ir">替换名</strong>(别名)。</li></ul><p id="dce3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于它们仍处于试验阶段，Android Studio会在你使用它们时显示一些警告。可以通过在gradle文件中定义显式编译器标志来禁用警告。</p><figure class="nx ny nz oa gt jr"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="7e6b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以在官方文档中阅读有关类型别名和内联类的更多信息:</p><div class="lr ls gp gr lt lu"><a href="https://kotlinlang.org/docs/reference/type-aliases.html" rel="noopener  ugc nofollow" target="_blank"><div class="lv ab fo"><div class="lw ab lx cl cj ly"><h2 class="bd ir gy z fp lz fr fs ma fu fw ip bi translated">类型别名(从1.1开始)- Kotlin编程语言</h2><div class="mb l"><h3 class="bd b gy z fp lz fr fs ma fu fw dk translated">类型别名不会引入新类型。它们相当于相应的基础类型。当您添加…</h3></div><div class="mc l"><p class="bd b dl z fp lz fr fs ma fu fw dk translated">kotlinlang.org</p></div></div><div class="md l"><div class="pm l mf mg mh md mi jw lu"/></div></div></a></div><div class="lr ls gp gr lt lu"><a href="https://kotlinlang.org/docs/reference/inline-classes.html" rel="noopener  ugc nofollow" target="_blank"><div class="lv ab fo"><div class="lw ab lx cl cj ly"><h2 class="bd ir gy z fp lz fr fs ma fu fw ip bi translated">内联类——kot Lin编程语言</h2><div class="mb l"><h3 class="bd b gy z fp lz fr fs ma fu fw dk translated">Kotlin编译器更倾向于使用底层类型而不是包装器来产生最佳性能和优化的…</h3></div><div class="mc l"><p class="bd b dl z fp lz fr fs ma fu fw dk translated">kotlinlang.org</p></div></div><div class="md l"><div class="pn l mf mg mh md mi jw lu"/></div></div></a></div></div></div>    
</body>
</html>