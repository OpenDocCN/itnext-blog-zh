<html>
<head>
<title>Property Initializers: What, Why, and How to Use It</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">属性初始化器:什么，为什么，以及如何使用它</h1>
<blockquote>原文：<a href="https://itnext.io/property-initializers-what-why-and-how-to-use-it-5615210474a3?source=collection_archive---------1-----------------------#2018-02-09">https://itnext.io/property-initializers-what-why-and-how-to-use-it-5615210474a3?source=collection_archive---------1-----------------------#2018-02-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/1f33e15437c6a26157fbf44619783a29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cFZjAKZUDUaIuCfyH9EvXQ.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">当你不必再为你的方法做任何绑定时的感觉，图片来自<a class="ae kf" href="https://unsplash.com/photos/ROsoCDtkGdo" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></figcaption></figure><p id="3fb1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae kf" href="https://www.linkedin.com/cws/share?url=https%3A%2F%2Fitnext.io%2Fproperty-initializers-what-why-and-how-to-use-it-5615210474a3" rel="noopener ugc nofollow" target="_blank"> <em class="le">点击这里在LinkedIn上分享这篇文章</em> </a></p><p id="a050" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">新的类“属性初始化器”允许您使用常规的ES6类在React组件中定义方法(或任何属性),而不用担心绑定。对，我再说一遍，<strong class="ki iu">无绑定</strong>。其背后的思想是给一个属性分配一个箭头函数，它将像一个普通的方法一样工作，并自动从<a class="ae kf" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions" rel="noopener ugc nofollow" target="_blank">封闭执行上下文</a>的值中绑定<strong class="ki iu"> this </strong>(在本例中是构造函数)。它经常被用来<a class="ae kf" href="https://www.fullstackreact.com/articles/use-property-initializers-for-cleaner-react-components/" rel="noopener ugc nofollow" target="_blank">创建一个更加“干净”的ES6类组件。</a></p><p id="e8e3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这篇文章中，我们将创建一个简单的屏幕，呈现一个用户列表和一个文本输入来过滤列表。</p><p id="f718" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该列表可能包含数百个用户，所以我们不想每次用户输入内容时都进行过滤，因为这可能会导致重新呈现列表时出现性能问题。为了克服这一点，我们可以将过滤器的执行延迟一段时间，实质上是等待用户完成输入(去抖动事件)。很常见的情况，对吧？</p><p id="31a6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这个例子中，我们将看到属性初始化器是如何工作的，与常规的类方法相比有什么不同，优缺点，以及当你面对它的限制时可以做的一些变通方法。</p><p id="6c7e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在此之前，让我们快速看一下如果用普通的React类定义List组件，它会是什么样子。为了简单起见，这个列表只是一个随机名称的数组。</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="52d1" class="lo lp it lk b gy lq lr l ls lt">export default class List extends React.Component {<br/>  constructor() {<br/>    super(...arguments);<br/>    <em class="le">this</em>.state = {<br/>      list: <em class="le">this</em>.props.list,<br/>      searchInput: '',<br/>    };<br/>    <strong class="lk iu"><em class="le">this</em>._handleInputChange = <em class="le">this</em>._handleInputChange.bind(<em class="le">this</em>);<br/>    <em class="le">this</em>._filterList = <em class="le">this</em>._filterList.bind(<em class="le">this</em>);</strong><br/>  }<br/>  componentWillUnmount() {<br/>    if (<em class="le">this</em>._filterTimeout) clearTimeout(<em class="le">this</em>._filterTimeout);<br/>  }<br/>  render() {<br/>    let { searchInput } = this.state;<br/>    return (<br/>      &lt;View style={{ flex: 1 }}&gt;<br/>        &lt;View style={styles.searchContainer}&gt;<br/>          &lt;TextInput<br/>            style={styles.textInput}<br/>            placeholder="Search by name"<br/>            value={searchInput}<br/>           <strong class="lk iu"> onChangeText={this._handleInputChange}</strong><br/>            autoCorrect={false}<br/>          /&gt;<br/>          &lt;Icon name="search" size={26} color="#476DC5" /&gt;<br/>        &lt;/View&gt;<br/>        &lt;ScrollView&gt;<br/>          {this.state.list.map((name, index) =&gt; {<br/>            return (<br/>              &lt;ListItem<br/>                key={index} // please pardon this one<br/>                roundAvatar<br/>                avatar={defaultProfilePicture}<br/>                title={name}<br/>              /&gt;<br/>            );<br/>          })}<br/>        &lt;/ScrollView&gt;<br/>      &lt;/View&gt;<br/>    );<br/>  }<br/><br/>  _handleInputChange(searchInput) {<br/>    this.setState({ searchInput });<br/>    if (this._filterTimeout) {<br/>      clearTimeout(this._filterTimeout);<br/>    }<br/><strong class="lk iu">    this._filterTimeout = setTimeout(this._filterList, 400);</strong><br/>  }<br/><br/>  _filterList() {<br/>    let filterText = this.state.searchInput.toLowerCase();<br/>    let { list } = this.props;<br/>    this.setState({<br/>      list: list.filter(name =&gt;<br/>        name.toLowerCase().includes(filterText),<br/>      ),<br/>    });<br/>  }<br/>}</span></pre><p id="5615" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的示例代码中，我们将过滤后的列表存储在state中，以便在列表发生变化时触发重新呈现。注意，我们需要绑定每个被传递的方法(作为一个属性或回调)，因为将一个方法作为一个参数传递会将它从它的上下文(<code class="fe lu lv lw lk b">this</code>)中“分离”。我们还需要实现一个构造函数来定义初始状态并放置我们所有的绑定，这意味着我们需要调用<code class="fe lu lv lw lk b">super</code>并将所有参数传递给它。</p><p id="e3bc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你可能在网上看到的一些例子将绑定在<code class="fe lu lv lw lk b">render()</code>方法中，而不是构造函数中。这效率稍低，并且需要同样多的样板文件。</p><p id="abac" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这只是一个小例子。想象一个更大的真实世界的组件，你的React类中可能有更多的方法需要绑定。有了这种行为，就很难在整个团队中保持代码的一致性，而且随着代码可读性的降低，与其他开发人员的协作也变得更加困难和容易出错。</p><p id="ff22" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一个小问题是，如果您使用Flow作为代码类型检查器，您可能会意识到使用<code class="fe lu lv lw lk b">super(...arguments)</code>会降低Flow代码覆盖率，因为Flow不知道您传递的参数的形状。更糟糕的是，Flow抱怨<code class="fe lu lv lw lk b">bind</code>行，因为您正在覆盖实例方法。</p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lx"><img src="../Images/b351f279faefe6288716bc8a290cd76e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7U4OTBWiZFiaJXP_koArrA.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">流程不能涵盖参数类型。</figcaption></figure><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ly"><img src="../Images/40315577d802d963f2ad21e9716cc3e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5sEXJVCyEx3x6kh2kCeZ3Q.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">流抱怨是因为我们覆盖了实例方法。</figcaption></figure><p id="1d0e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，让我们看看如何用属性初始化器来实现它！</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="1ec7" class="lo lp it lk b gy lq lr l ls lt">export default class List extends React.Component {<br/>  state = {<br/>    list: this.props.list,<br/>    searchInput: '',<br/>  };<br/><br/>  componentWillUnmount() {<br/>    if (this._filterTimeout) clearTimeout(this._filterTimeout);<br/>  }<br/><br/>  render() {<br/>    let { searchInput, list } = this.state;<br/>    return (<br/>      &lt;View style={{ flex: 1 }}&gt;<br/>        &lt;View style={styles.searchContainer}&gt;<br/>          &lt;TextInput<br/>            style={styles.textInput}<br/>            placeholder="Search by name"<br/>            value={searchInput}<br/>            onChangeText={this._handleInputChange}<br/>            autoCorrect={false}<br/>          /&gt;<br/>          &lt;Icon name="search" size={26} color="#476DC5" /&gt;<br/>        &lt;/View&gt;<br/>        &lt;ScrollView&gt;<br/>          {this.state.list.map((name, index) =&gt; {<br/>            return (<br/>              &lt;ListItem<br/>                key={index}<br/>                roundAvatar<br/>                avatar={defaultProfilePicture}<br/>                title={name}<br/>              /&gt;<br/>            );<br/>          })}<br/>        &lt;/ScrollView&gt;<br/>      &lt;/View&gt;<br/>    );<br/>  }<br/><br/>  <strong class="lk iu">_handleInputChange</strong> = (searchInput) =&gt; {<br/>    this.setState({ searchInput });<br/>    if (this._filterTimeout) {<br/>      clearTimeout(this._filterTimeout);<br/>    }<br/>    this._filterTimeout = setTimeout(this._filterList, 400);<br/>  };<br/><br/>  <strong class="lk iu">_filterList</strong> = () =&gt; {<br/>    let filterText = this.state.searchInput.toLowerCase();<br/>    let { list } = this.props;<br/>    this.setState({<br/>      list: list.filter(name =&gt;<br/>        name.toLowerCase().includes(filterText),<br/>      ),<br/>    });<br/>  };<br/>}</span></pre><p id="6a2b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">看吧！我们不再需要构造函数或绑定:)</p><p id="7aea" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以从中获得一些好处:</p><ul class=""><li id="7500" class="lz ma it ki b kj kk kn ko kr mb kv mc kz md ld me mf mg mh bi translated">没有必要明确地称呼<code class="fe lu lv lw lk b">bind()</code>。<strong class="ki iu"> <em class="le">这个</em> </strong>被正确绑定是因为我们使用了箭头函数语法。</li><li id="995c" class="lz ma it ki b kj mi kn mj kr mk kv ml kz mm ld me mf mg mh bi translated">不需要定义构造函数方法(我们可以在构造函数之外定义初始状态！).</li><li id="b41c" class="lz ma it ki b kj mi kn mj kr mk kv ml kz mm ld me mf mg mh bi translated">如果你愿意，你甚至可以使用属性初始化语法和所有其他的组件生命周期方法。</li></ul><p id="444f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">尽管它能带来巨大的好处，但至少从我的经验来看，它也有一些缺点:</p><h2 id="4a03" class="lo lp it bd mn mo mp dn mq mr ms dp mt kr mu mv mw kv mx my mz kz na nb nc nd bi translated">如果您想在定义状态时使用您的方法，您需要在初始化状态之前初始化<strong class="ak">方法。</strong></h2><p id="b5f6" class="pw-post-body-paragraph kg kh it ki b kj ne kl km kn nf kp kq kr ng kt ku kv nh kx ky kz ni lb lc ld im bi translated">让我们稍微改变一下我们的<code class="fe lu lv lw lk b">_filterList</code>。这个方法将返回一个新的过滤后的数组，而不是调用<code class="fe lu lv lw lk b">setState()</code>。然后，假设你想用字符串' Al '过滤列表，并把它存储为初始状态。如果我们把我们的方法按照如上所示的顺序排列，它将抛出一个错误<code class="fe lu lv lw lk b">this._filterList</code>是未定义的。</p><p id="1103" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果在状态之后初始化方法<em class="le">，在初始化状态时调用方法将不起作用。</em></p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nj"><img src="../Images/4f99b3dd71ec5a6099d07759071193e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fSHP7vb-VPWcL9Wyw_Oxfw.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">如果在state之后初始化方法，则在初始化state时使用方法将不起作用。</figcaption></figure><p id="f7b6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你面对这个用例，你可以把方法放在状态之前，就像这样:</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="80d3" class="lo lp it lk b gy lq lr l ls lt">export default class List extends React.Component {<br/>  // This must go first<br/>  _filterList = (filterText) =&gt; {<br/>    let { list } = this.props;<br/>    return list.filter(name =&gt;<br/>      name.toLowerCase().includes(filterText.toLowerCase()),<br/>    );<br/>  };<br/>  <br/>  state = {<br/>    list: this._filterList('Al'),<br/>    searchInput: 'Al',<br/>  };<br/>  <br/>  ...<br/>}</span></pre><p id="8d90" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是这使得您的实现更加脆弱，更容易出错。如果您团队中的另一个工程师重构了这个类，他们可能会为了代码风格的一致性而重新排序属性/方法。这可能会导致在代码审查中难以发现的错误(还好你有测试，对吧！).<br/> <br/>一个解决方法是回到构造函数方法。</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="1d70" class="lo lp it lk b gy lq lr l ls lt">export default class List extends React.Component {<br/>  <br/>  // This will work as expected.<br/>  constructor() {<br/>    super(...arguments);<br/>    this.state = {<br/>      list: this._filterList('Al'),<br/>      searchInput: 'Al',<br/>    };<br/>  }<br/>  ...<br/>  render() {<br/>    ...<br/>  }<br/>  ...<br/>  _filterList = (filterText) =&gt; {<br/>    let { list } = this.props;<br/>    this.setState({<br/>      list: list.filter(name =&gt;<br/>        name.toLowerCase().includes(filterText.toLowerCase()),<br/>      ),<br/>    });<br/>  };<br/>}</span></pre><p id="5698" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">一个更好的解决方案</strong>是将<code class="fe lu lv lw lk b">filterList()</code>定义为独立的、类外的纯函数。这也使得测试变得容易，因为它没有副作用。</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="9f11" class="lo lp it lk b gy lq lr l ls lt">let filterList = (list, filterText) =&gt; {<br/>  let lowerCasedFilterText = filterText.toLowerCase();<br/>  return list.filter(name =&gt;<br/>    name.toLowerCase().includes(lowerCasedFilterText),<br/>  );<br/>};<br/>export default class List extends React.Component {<br/>  // This will work<br/>  state = {<br/>    list: filterList(this.props.list, 'Al'),<br/>    searchInput: 'Al',<br/>  };<br/>  <br/>  ...<br/>}</span></pre><h2 id="5a59" class="lo lp it bd mn mo mp dn mq mr ms dp mt kr mu mv mw kv mx my mz kz na nb nc nd bi translated">其他一些缺点:</h2><ul class=""><li id="d6fc" class="lz ma it ki b kj ne kn nf kr nk kv nl kz nm ld me mf mg mh bi translated">像这样初始化状态时，不能使用对象析构。你每次都必须打出<code class="fe lu lv lw lk b">this.props.x</code>。</li><li id="6fbf" class="lz ma it ki b kj mi kn mj kr mk kv ml kz mm ld me mf mg mh bi translated">可能会有性能问题(你可以在<a class="ae kf" href="https://medium.com/@nikolalsvk/loosing-bind-this-in-react-8637ebf372cf" rel="noopener">可能的陷阱</a>部分阅读更多)。</li><li id="fecf" class="lz ma it ki b kj mi kn mj kr mk kv ml kz mm ld me mf mg mh bi translated">如果你想使用属性初始化器，你将需要Babel来转换你的代码(但是如果你使用JSX或者其他现代语法/特性，你可能会使用Babel)。</li></ul><p id="80c8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">属性初始化器仍然是JS 中的一个实验性特性，这意味着它还没有被ECMAScript官方标准接受。目前，你需要Babel使用<code class="fe lu lv lw lk b"><a class="ae kf" href="https://babeljs.io/docs/plugins/transform-class-properties/" rel="noopener ugc nofollow" target="_blank">babel-plugin-transform-class-properties</a></code>来传输它。但是这个特性正在成为一个标准，它在JavaScript/React社区中被广泛使用，在许多组织的生产中，你会在网络指南中看到这个模式。</p><h2 id="0602" class="lo lp it bd mn mo mp dn mq mr ms dp mt kr mu mv mw kv mx my mz kz na nb nc nd bi translated">摘要</h2><p id="56d8" class="pw-post-body-paragraph kg kh it ki b kj ne kl km kn nf kp kq kr ng kt ku kv nh kx ky kz ni lb lc ld im bi translated">我们已经看到了属性初始化器在React组件中是如何工作的，并将其与传统的React类(使用构造函数)进行了比较。我认为主要的优势是能够消除使用<code class="fe lu lv lw lk b">bind()</code>的需要，在我看来，这将创建更干净的代码。尽管这种方法可以带来好处，但它仍然有一些问题，您已经看到了我们如何通过一些变通方法来解决每个限制。如果你有我在上面没有提到的其他好处、限制或解决方法，请在下面留下评论！我很乐意向你学习更多:)你可以在这里看到完整的源代码<a class="ae kf" href="https://github.com/AudyOdi/example-property-initializers" rel="noopener ugc nofollow" target="_blank">。</a></p></div></div>    
</body>
</html>