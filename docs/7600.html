<html>
<head>
<title>ByFrost in Development — Releasing the Source Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">开发中的ByFrost发布源代码</h1>
<blockquote>原文：<a href="https://itnext.io/byfrost-in-development-releasing-the-source-code-42508dbaaf6f?source=collection_archive---------3-----------------------#2022-11-19">https://itnext.io/byfrost-in-development-releasing-the-source-code-42508dbaaf6f?source=collection_archive---------3-----------------------#2022-11-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="e270" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">是的，终于到时间了。它工作…有点像。好吧，不完全是。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/b3d5fe25d8054bdecc4a43a99809b8d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vrlQVB5SXaC9OKNIp2f-Mg.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">找到了吗？</figcaption></figure><p id="a736" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你没看错读者！我要公布我和ByFrost到目前为止所做的一切。回购会在文末链接，撑住自己，一塌糊涂。</p><p id="69fb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于这篇文章，我将介绍如何使用已经存在的东西，每一个的学习和缺陷，以及，你猜对了，我将如何在我的第三次尝试(不是第二次，而是第三次)中做得更好。</p><p id="7d3e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">坦率地说，我严重低估了我要做的事情实际上会有多难。</p><p id="bb43" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我决定发布这两个版本中的第一个，因为它比第二个更适合黄金时间，并且是一个很好的“演示”,展示了什么是可能的。至于第三个秘密，我将在接下来的几个月里利用我在这里学到的知识。ByFrost原本是这个项目的第一个组成部分，实际上我希望它是这样，但我认为事情的发展方式，它永远不会工作。尤其是不要先瞄准戈朗。</p><p id="cef1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本文将分为三个部分；对V1和V2的描述，以及我第三次尝试要做的事情。我没有费心去释放V2，因为它现在的状态实在是太悲伤了……事实如此。</p><p id="cb3a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么，让我们开始吧。</p><h1 id="77d1" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">by frost V1——斗志昂扬的失败者</h1><p id="e078" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">这个版本是第一次迭代，是基于我在介绍Byfrost 的最初帖子<a class="ae me" href="https://medium.com/itnext/introducing-byfrost-a-source-code-path-visualizer-2d64002d1f9a" rel="noopener">中制作的发布视频。</a></p><h2 id="6e30" class="mf lc iq bd ld mg mh dn lh mi mj dp ll jy mk ml lp kc mm mn lt kg mo mp lx mq bi translated"><strong class="ak">整体架构</strong></h2><p id="1816" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">这个版本非常天真，只扩展了函数库，引入了像<code class="fe mr ms mt mu b">struct</code>成员和方法这样的东西。</p><p id="1516" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">事情是这样的:考虑下面的代码。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/a5ed58428690e284cd87ba6aa1c59a50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1296/format:webp/1*XG6joeI_9RagNNlGppjUeg.png"/></div></figure><p id="34fe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">V1将扫描<code class="fe mr ms mt mu b">main</code>并盲目地寻找模式<code class="fe mr ms mt mu b">ID</code>(在本例中是<code class="fe mr ms mt mu b">fmt</code>)，然后是<code class="fe mr ms mt mu b">DOT</code> ( <code class="fe mr ms mt mu b">.</code>)，然后在它找到的下一个令牌(在本例中是一个名为<code class="fe mr ms mt mu b">LocalPrintln</code>的ID)上，它将扫描在这个由<code class="fe mr ms mt mu b">fmt</code>指向的目录中检测到的所有包。使用我们当前所在项目的绝对路径，可以建立到这个包的路径；如果到当前Go项目根的绝对路径是<code class="fe mr ms mt mu b">/Users/alyson/newproject</code>，那么到<code class="fe mr ms mt mu b">fmt</code>的路径现在应该是<code class="fe mr ms mt mu b">/Users/alyson/newproject/localprint/fmt</code>。这个目录将被扫描以寻找<code class="fe mr ms mt mu b">func LocalPrintln</code>,然后为它创建一个视图。</p><p id="194c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">非常简单，但是这种方法非常愚蠢。</p><p id="b5ac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">哑但也真的真的快。不需要记住任何结构信息，因此解析就像带有开始和结束索引的读取调用一样简单。我们不需要知道任何事情；不是它的返回类型，不是它的参数，什么都没有。</p><h2 id="2708" class="mf lc iq bd ld mg mh dn lh mi mj dp ll jy mk ml lp kc mm mn lt kg mo mp lx mq bi translated"><strong class="ak">弊端</strong></h2><p id="dd6b" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">对于善于观察的人来说，这可能是显而易见的，但最大的问题是缺乏结构之间的关系知识。这种方法对于像调用方法的数据类型这样的东西并不完全有用，因为那样我们就必须跟踪变量声明和赋值，理解它们是何时被创建和/或销毁的，并理解它们的作用域等等。</p><p id="c007" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">确实是一个非常困难的问题。</p><p id="1bec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我想，这个缺点值得一提的事实是，你甚至不能想到扩展…我想…堆叠的方法调用。如果不彻底检修，像<code class="fe mr ms mt mu b">value.Call().To().Me()</code>这样的东西是不可能被拆包的。不要在意像函数调用作为参数传递给函数这样的事情。</p><p id="c908" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以这导致了第一次对重写的强烈需求，因为我很快发现许多Go程序几乎把方法调用作为他们的面包和黄油。</p><p id="9501" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么，去V2吧</p><h1 id="8b24" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">弗罗斯特·V2——将这个坏的Boi形式化</h1><p id="8f97" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">得出的结论？结构！结构是智能索引的基础。</p><p id="6317" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">随着美化了的文本文件和一个成熟的(不是真正的)编译器的出现而消失了！耶！我现在是一名编译器开发人员。！</p><p id="a6f6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是玩笑归玩笑，我实际上不得不挖掘编译和构造令牌和抽象语法树的错综复杂之处，以一种保存关系信息的方式..</p><p id="7f24" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们看看它是什么样子的，并谈谈我的一些新结构。</p><h2 id="06c1" class="mf lc iq bd ld mg mh dn lh mi mj dp ll jy mk ml lp kc mm mn lt kg mo mp lx mq bi translated">环境</h2><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mw"><img src="../Images/2cfbccb2dab72b672bc70f1aca195a70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_oC8pNq6ctnu_DBZudfPmA.png"/></div></div></figure><p id="2869" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">比我想象的要大得多，但这应该能让我明白我想要的是什么。V2的每个包都有这样的结构:</p><ul class=""><li id="7e32" class="mx my iq jp b jq jr ju jv jy mz kc na kg nb kk nc nd ne nf bi translated">包是包的名称</li><li id="c8d4" class="mx my iq jp b jq ng ju nh jy ni kc nj kg nk kk nc nd ne nf bi translated">包路径是它从根目录开始的绝对路径</li><li id="0422" class="mx my iq jp b jq ng ju nh jy ni kc nj kg nk kk nc nd ne nf bi translated">IDRegistry只是在这个包中快速查找符号，关键字是ID，值是它的类型，以加快搜索速度。所以举例来说，<code class="fe mr ms mt mu b">main</code>的值就是<code class="fe mr ms mt mu b">Function</code>。</li><li id="0d71" class="mx my iq jp b jq ng ju nh jy ni kc nj kg nk kk nc nd ne nf bi translated">ImportList是这个包中所有导入的列表。</li><li id="0c7c" class="mx my iq jp b jq ng ju nh jy ni kc nj kg nk kk nc nd ne nf bi translated">函数是这个包中的所有函数。</li><li id="11d5" class="mx my iq jp b jq ng ju nh jy ni kc nj kg nk kk nc nd ne nf bi translated">Struct是这个包中的所有Struct(Struct Struct有函数成员来支持它们的方法)。</li><li id="9c3e" class="mx my iq jp b jq ng ju nh jy ni kc nj kg nk kk nc nd ne nf bi translated">GlobalVars是这个函数中的所有全局变量。</li></ul><p id="74ec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是V2背后的基本思想。</p><h2 id="9e54" class="mf lc iq bd ld mg mh dn lh mi mj dp ll jy mk ml lp kc mm mn lt kg mo mp lx mq bi translated">缺点是</h2><p id="f578" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">这是迄今为止最好的尝试，可能是最接近这个工具的“正确”版本。它索引了从函数导入到方法的所有内容。我现在认为，我的大部分问题都源于我对Go如何编译缺乏理解。</p><p id="3e57" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不像C从上到下编译(你不能使用任何东西，除非它被声明为<strong class="jp ir">在</strong>之上，这是它在文件中被物理使用的地方，为了老式的优化原因)，Go和许多现代语言都有一个“开放季节”政策，在这里，只要它们存在于某个地方，就可以在任何地方声明和使用。所有的事情，所有的地方，所有的时间/我控制不住自己。</p><p id="3442" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这导致了许多循环和源文件读取，首先读取所有的<code class="fe mr ms mt mu b">type</code>，然后是所有的<code class="fe mr ms mt mu b">functions</code>，然后是所有的<code class="fe mr ms mt mu b">global variables</code>，以确保所有需要的东西在需要时总是可用的。</p><p id="b172" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这样做的一个副作用是，在相当小的项目中，ByFrost可以向您展示一切，但是在大项目中，扫描代码库需要花费很长时间，并且这个工具变得完全不可用，因为它刚刚停止。</p><p id="d1e8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，对这种方法有明显的优化，我只是在事后才想到的，也许在一个方向扫描，当事物被声明时，缓存它们，直到找到它们的定义，等等，但这只是修补了对Go编译的基本误解，我怀疑最终会以某种其他方式或形式将我带回类似的问题。</p><h1 id="becd" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">下一步是什么？ByFrost V3 —(重新)引入By(C？)霜冻</h1><p id="c94b" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">这是前两个版本。代码是一堆垃圾，可能很难理解，但是我想向你们展示我已经做了多少(当然也是为了证明这不是vapourware)。</p><p id="92da" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有编译说明，所以你可以尝试一下。</p><p id="1abd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么，我接下来要做什么？我还在研究ByFrost。我可能会改名字。我决定让它为C工作，也可能用C写。</p><p id="d2d3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我为ByFrost追求的真正目标是在可视化UI中最终获得“永恒的调试”体验。想法是无缝遍历和检查代码的执行，因为它发生了。虽然类似，但我的目标不是二进制分析工具，这将严格用于开发，因为您必须随时准备好您正在检查的源代码。</p><h2 id="88e4" class="mf lc iq bd ld mg mh dn lh mi mj dp ll jy mk ml lp kc mm mn lt kg mo mp lx mq bi translated">围棋入门的大问题是</h2><p id="71dd" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">这是我放弃围棋的一个重要原因，因为它是一门非常复杂的语言。对于我要实现的这种类型的分析，可执行机器码到源代码的直接映射必须是准确的，并且能够相对快速地进行推断。</p><p id="ef41" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">C处于一个美丽的领域，那里有C结构和概念的直接汇编等价构造；简而言之，一个好的C/Assembly程序员可以看着C，并对它的ASM输出有一个非常好的想法(尽管有优化)，反之亦然。</p><h1 id="27bf" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">查看代码库</h1><p id="a9c4" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">所以这就是我要做的。在华盛顿重新开始有点糟糕，但我知道我现在需要做什么。</p><p id="2f59" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">至于如何运行代码；让我们开始吧。</p><h2 id="9b22" class="mf lc iq bd ld mg mh dn lh mi mj dp ll jy mk ml lp kc mm mn lt kg mo mp lx mq bi translated">如何运行Frost</h2><p id="eba9" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">你需要两个终端。</p><h2 id="afda" class="mf lc iq bd ld mg mh dn lh mi mj dp ll jy mk ml lp kc mm mn lt kg mo mp lx mq bi translated">运行后端</h2><p id="a89d" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">这很简单。如果没有函数参数，您将得到以下输出:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nl"><img src="../Images/17605384e343387112d7c8005ef0ecd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5gF4gYTe1Ih7VFEuS1Nikw.png"/></div></div></figure><p id="4a2f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一个执行示例如下所示</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nm"><img src="../Images/62cd2fc491950a70552f66d7972ad3f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bcQeKFCJnf3xjhMmj_YaxQ.png"/></div></div></figure><p id="3a22" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将运行当前项目。</p><h2 id="700e" class="mf lc iq bd ld mg mh dn lh mi mj dp ll jy mk ml lp kc mm mn lt kg mo mp lx mq bi translated"><strong class="ak">注意:你的项目在go.mod文件中的名字必须和它当前所在的目录名相匹配。我懒得做这个动态，因为我懒。</strong></h2><p id="5750" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">然后你会看到一堆我忘记删除的打印输出，我曾经用于调试；忽略这些。</p><p id="cbd5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来转到<code class="fe mr ms mt mu b">web</code>目录，在<code class="fe mr ms mt mu b">byfrost-frontend</code>下，执行以下命令</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/89584c1889dea36ce575148eafbfa354.png" data-original-src="https://miro.medium.com/v2/resize:fit:444/format:webp/1*DdoeCGPKjZiRyZP-1IQUyg.png"/></div></figure><p id="3b0f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，访问<code class="fe mr ms mt mu b">localhost:4200/indexer</code>，你应该会看到一个类似这样的屏幕:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi no"><img src="../Images/d6ea28448f1f18c46e2f8a7e7aebaf75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CZeoUpZhB9_AGWfAMutIsA.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">ByFrostV1的源代码</figcaption></figure><p id="c2b8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，只有用黄色和水蓝色突出显示的名称才能被点击和展开。原生包导入是不可扩展的，只有本地包。</p><p id="e873" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">展开后，点击右侧<code class="fe mr ms mt mu b">Visible</code>下的标签，看看感觉如何。</p><p id="fda2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可以在这里旋转一下:<a class="ae me" href="https://github.com/AlysonBee/ByfrostV1" rel="noopener ugc nofollow" target="_blank">https://github.com/AlysonBee/ByfrostV1</a></p><p id="14ef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">直到拜弗罗斯特回来！</p><p id="21d0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">艾莉森</p></div></div>    
</body>
</html>