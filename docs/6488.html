<html>
<head>
<title>Terraform Resource Creation with Nested Data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用嵌套数据创建地形资源</h1>
<blockquote>原文：<a href="https://itnext.io/terraform-resource-creation-with-nested-data-92af9a9f96ea?source=collection_archive---------1-----------------------#2021-12-01">https://itnext.io/terraform-resource-creation-with-nested-data-92af9a9f96ea?source=collection_archive---------1-----------------------#2021-12-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9d90" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">调查AWS ALB和NLB的客户端IP信息</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/27dbf6a0bf0c9b18cea83c7675b2710b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*auucQHuvlREe9kKUbkbrEw.jpeg"/></div></div></figure><p id="a7fc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在研究AWS ALB和NLB时，我想验证不同类型选项的客户端IP信息。</p><p id="3f54" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我有两个apache web服务器运行在两个EC2实例上。为了调查流量，创建了一个golang程序来转储http请求。使用AWS web控制台创建ALB和NLB没有太大问题。然而，在创建目标群体时，我觉得这是相当繁琐的。</p><p id="4dba" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">首先，对于不同类型的LB，目标群体需要分别具有不同的协议。ALB LB只能注册基于HTTP的目标组，而NLB LB只能注册基于TCP的目标组。其次，每个目标可以是实例的IP或EC2实例本身(忽略其他类型，如labmda或ALB)。因此，我将有2个协议x 2个目标类型x 2个应用程序，8个目标组组合。我需要自动化它。</p><h2 id="118e" class="lq lr it bd ls lt lu dn lv lw lx dp ly ld lz ma mb lh mc md me ll mf mg mh mi bi translated">具有嵌套数据的目标群体的Terraform</h2><p id="8959" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">我们可以将一些地形资源定义如下:</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="a4de" class="lq lr it mp b gy mt mu l mv mw">resource "aws_lb_target_group" "apache-tcp-by-instance" {<br/>  name     = "apache-tcp-by-instance"<br/>  port     = 80<br/>  protocol = "TCP"<br/>  target_type = "instance"<br/>  vpc_id   = data.aws_vpc.default-vpc.id<br/>}</span><span id="c5ea" class="lq lr it mp b gy mx mu l mv mw">resource "aws_lb_target_group" "apache-tcp-by-ip" {<br/>  name        = "apache-tcp-by-ip"<br/>  port        = 80<br/>  protocol    = "TCP"<br/>  target_type = "ip"<br/>  vpc_id      = data.aws_vpc.default-vpc.id<br/>}<br/># repeat for the rest 6 combinations</span></pre><p id="e5d7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我想我重复得太多了。干！</p><p id="71f7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个循环看起来很适合创建那些相似的资源。但是，它不能在资源定义块中执行嵌套循环。我们必须在外面准备数据。这就是<code class="fe my mz na mp b">locals</code>能帮上的忙。</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="ad53" class="lq lr it mp b gy mt mu l mv mw">locals {<br/>  app_name = ["apache", "go"]<br/>  protocols = ["http", "tcp"]<br/>  by = ["instance", "ip"]</span><span id="764f" class="lq lr it mp b gy mx mu l mv mw">  list_of_tg_configs = flatten([<br/>    for app in local.app_name : [<br/>      for protocol in local.protocols: [<br/>        for by in local.by : {<br/>          "app": app,<br/>          "protocol": protocol,<br/>          "by": by,<br/>          "port": app == "apache"? 80 : 8080,<br/>          "key": "${app}-${protocol}-by-${by}"<br/>        }<br/>      ]<br/>    ]<br/>  ])</span></pre><p id="2d12" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们为app_name、protocols和target by方法定义了3个列表。然后，我们嵌套地遍历这3个列表以形成一个dictionary对象，它包含目标组的信息。调用flatten函数来形成一个没有任何其他嵌套列表的字典对象的纯列表。</p><p id="d522" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后可以使用<code class="fe my mz na mp b">for_each</code>创建target_group资源。</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="a254" class="lq lr it mp b gy mt mu l mv mw">resource "aws_lb_target_group" "target-groups" {<br/>  for_each= { <br/>    for tgc in local.list_of_tg_configs : tgc.key =&gt; tgc<br/>  }</span><span id="a984" class="lq lr it mp b gy mx mu l mv mw">  name = each.key</span><span id="a55a" class="lq lr it mp b gy mx mu l mv mw">  port = each.value.port<br/>  protocol = upper(each.value.protocol)<br/>  target_type = each.value.by<br/>  vpc_id = data.aws_vpc.default-vpc.id <br/>}</span></pre><p id="cbac" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">for_each只能接收映射或字符串列表，因此我们使用<code class="fe my mz na mp b">for</code>表达式构建一个映射。请注意，我们已经在locals中创建了一个键字段，可用于映射的键。</p><p id="e13b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一旦创建了<code class="fe my mz na mp b">for_each</code>的映射，就可以使用<code class="fe my mz na mp b">each</code>来引用每个键/值对。资源的属性可以用准备好的数据来定义。注意<code class="fe my mz na mp b">each.value</code>实际上是一个map对象，属性是用这个map的对应键定义的。</p><p id="f7ac" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">资源的结果实际上是一个map对象。例如，稍后可以使用<code class="fe my mz na mp b">aws_lb_target_group.target-groups[key]</code>引用目标组，其中键与<code class="fe my mz na mp b">for_each</code>提供的map对象的键相同。</p><h2 id="e233" class="lq lr it bd ls lt lu dn lv lw lx dp ly ld lz ma mb lh mc md me ll mf mg mh mi bi translated">正在向目标组注册其目标ID</h2><p id="af43" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">在我的测试中，我有两个EC2实例。要将这些目标注册到目标组中，我们需要为每个目标创建一个资源，如下所示:</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="9d21" class="lq lr it mp b gy mt mu l mv mw">resource "aws_lb_target_group_attachment" "tg-resgister" {<br/>  target_group_arn  = arn value of the target group<br/>  target_id         = ip or instance<br/>  port              = 80 or 8080<br/>}</span></pre><p id="8935" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于每个EC2实例或IP和每个目标组，我们将有16个组合。我们需要使它自动化。</p><p id="24ab" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">遵循与目标群体相同的模式，</p><ol class=""><li id="d874" class="nb nc it kw b kx ky la lb ld nd lh ne ll nf lp ng nh ni nj bi translated">在<code class="fe my mz na mp b">locals</code>中，通过使用<code class="fe my mz na mp b">for</code>表达式遍历数据，构建一个具有所有必需属性的地图对象。使用<code class="fe my mz na mp b">flatten</code>获得地图对象列表。</li><li id="d36c" class="nb nc it kw b kx nk la nl ld nm lh nn ll no lp ng nh ni nj bi translated">在资源块中，创建一个供<code class="fe my mz na mp b">for_each</code>使用的地图</li><li id="e28c" class="nb nc it kw b kx nk la nl ld nm lh nn ll no lp ng nh ni nj bi translated">用<code class="fe my mz na mp b">each.value</code>填充资源属性</li></ol><p id="d928" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe my mz na mp b">locals</code>部分如下图所示。</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="7212" class="lq lr it mp b gy mt mu l mv mw">locals {<br/>  # the locals for target group is shown as above, and skipped</span><span id="2b25" class="lq lr it mp b gy mx mu l mv mw">  ec2_instances = {<br/>    "web-server1": aws_instance.web-server1, <br/>    "web-server2": aws_instance.web-server2<br/>  }</span><span id="8b89" class="lq lr it mp b gy mx mu l mv mw">  ec2_for_target_groups = flatten([<br/>    for ec2_name, ec2_inst in local.ec2_instances: [<br/>      for tgc in local.list_of_tg_configs: {<br/>        "id": "${ec2_name}-${tgc.key}",<br/>        "ec2_name": ec2_name,<br/>        "target_group_key": tgc.key,<br/>        "target_id": tgc.by == "ip" ? ec2_inst.private_ip: ec2_inst.id,<br/>        "port": tgc.port<br/>      }<br/>    ]<br/>  ])<br/>}</span></pre><p id="5e0a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有两个EC2实例，为每个实例创建一个映射对象。然后，对于每个实例，遍历前面的目标组配置，用ec2名称和目标组的键设置一个惟一的id字段，获取目标组的键，以便我们可以引用它来获取它的<code class="fe my mz na mp b">arn</code>值，根据target by方法设置目标id，最后设置端口值。</p><p id="0dcd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">创建资源。</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="8008" class="lq lr it mp b gy mt mu l mv mw">resource "aws_lb_target_group_attachment" "tg-resgister" {<br/>  for_each= { <br/>    for ec2_tg in local.ec2_for_target_groups : ec2_tg.id =&gt; ec2_tg<br/>  }</span><span id="81cf" class="lq lr it mp b gy mx mu l mv mw">  target_group_arn  = aws_lb_target_group.target-groups[each.value.target_group_key].arn<br/>  target_id         = each.value.target_id<br/>  port              = each.value.port<br/>}</span></pre><p id="88b7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如前所述，为<code class="fe my mz na mp b">for_each</code>构造一个map对象，然后分别用<code class="fe my mz na mp b">each.value</code>对象的键分配属性。注意，我们使用目标组的密钥来访问它，以获得它的<code class="fe my mz na mp b">arn</code>值。</p><p id="2848" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们准备应用terraform代码。目标组创建的结果如下所示，</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/1ca5a72fd31beeb8b742d82bdd61feb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CJnxk_O6ZgQ8x18cP03sMQ.png"/></div></div></figure><h2 id="c5bf" class="lq lr it bd ls lt lu dn lv lw lx dp ly ld lz ma mb lh mc md me ll mf mg mh mi bi translated">HTTP转储程序</h2><p id="d484" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">玩具golang http处理程序如下所示。它基本上是转储HTTP请求。编译并部署到EC2实例中。</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="fce2" class="lq lr it mp b gy mt mu l mv mw">package main</span><span id="a470" class="lq lr it mp b gy mx mu l mv mw">import (<br/> "fmt"<br/> "log"<br/> "net/http"<br/> "net/http/httputil"<br/> "os"<br/>)</span><span id="06b6" class="lq lr it mp b gy mx mu l mv mw">func greet(w http.ResponseWriter, r *http.Request) {<br/> // set header for no cache<br/> w.Header().Set("Cache-Control", "no-cache, no-store, must-revalidate")<br/> w.Header().Set("Pragma", "no-cache")<br/> w.Header().Set("Expires", "0")</span><span id="0848" class="lq lr it mp b gy mx mu l mv mw"> dump, err := httputil.DumpRequest(r, true)<br/> if err != nil {<br/>  http.Error(w, fmt.Sprint(err), http.StatusInternalServerError)<br/>  return<br/> }</span><span id="6f63" class="lq lr it mp b gy mx mu l mv mw"> fmt.Fprintf(w, "%s", dump)<br/> fmt.Fprintf(w, "Remote Ip:%s\n", r.RemoteAddr)</span><span id="8352" class="lq lr it mp b gy mx mu l mv mw"> hostname, err := os.Hostname()<br/> if err != nil {<br/>  log.Printf("could not get hostname: %v", err)<br/>  return<br/> }</span><span id="c2ce" class="lq lr it mp b gy mx mu l mv mw"> fmt.Fprintf(w, "Served by:%s\n", hostname)</span><span id="f752" class="lq lr it mp b gy mx mu l mv mw">}</span><span id="ac04" class="lq lr it mp b gy mx mu l mv mw">func main() {<br/> http.HandleFunc("/", greet)<br/> http.ListenAndServe(":8080", nil)<br/>}</span></pre><h2 id="2f82" class="lq lr it bd ls lt lu dn lv lw lx dp ly ld lz ma mb lh mc md me ll mf mg mh mi bi translated">白蛋白测试</h2><p id="9a3c" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">创建一个应用程序负载平衡器，添加以下规则来测试远程IP地址。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nq"><img src="../Images/23a03e8c928331fff9ee7dc959108f4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UMurHPzlJamShhdp8XDnRQ.png"/></div></div></figure><p id="02c8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果请求具有HTTP头键/值对<code class="fe my mz na mp b">By=instance</code>，那么流量将被转发到由by-instance目标提供服务的目标组<code class="fe my mz na mp b">go-http-by-instance</code>。否则，它将由by-ip目标提供服务。</p><p id="060c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">运行下面的curl命令，</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="4d53" class="lq lr it mp b gy mt mu l mv mw">&gt; curl my-alb-646133936.us-east-1.elb.amazonaws.com<br/>GET / HTTP/1.1<br/>Host: my-alb-646133936.us-east-1.elb.amazonaws.com<br/>Accept: */*<br/>User-Agent: curl/7.77.0<br/>X-Amzn-Trace-Id: Root=1-61a7084e-2723c0666346a5756090f8ea<br/>X-Forwarded-For: <em class="nr">&lt;my router's ip&gt;</em><br/>X-Forwarded-Port: 80<br/>X-Forwarded-Proto: http</span><span id="85cd" class="lq lr it mp b gy mx mu l mv mw">Remote Ip:172.31.20.133:42560<br/>Served by:ip-172-31-42-226.ec2.internal</span></pre><p id="212a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">并为按实例目标设置标题，</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="31d3" class="lq lr it mp b gy mt mu l mv mw">&gt; curl -H "By: instance" my-alb-646133936.us-east-1.elb.amazonaws.com<br/>GET / HTTP/1.1<br/>Host: my-alb-646133936.us-east-1.elb.amazonaws.com<br/>Accept: */*<br/>By: instance<br/>User-Agent: curl/7.77.0<br/>X-Amzn-Trace-Id: Root=1-61a709b6-4ff011a14a9ee5d7106de8e8<br/>X-Forwarded-For: <em class="nr">&lt;my router's ip&gt;</em><br/>X-Forwarded-Port: 80<br/>X-Forwarded-Proto: http</span><span id="5f0d" class="lq lr it mp b gy mx mu l mv mw">Remote Ip:172.31.20.133:9188<br/>Served by:ip-172-31-17-239.ec2.internal</span></pre><p id="835b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意到对于<code class="fe my mz na mp b">by-ip</code>或<code class="fe my mz na mp b">by-intance</code>目标，HTTP请求的远程IP地址是ALB的私有IP地址。而真正的客户端IP可以参考ALB添加的HTTP头<code class="fe my mz na mp b">X-Forwarded-For</code>。</p><h2 id="0435" class="lq lr it bd ls lt lu dn lv lw lx dp ly ld lz ma mb lh mc md me ll mf mg mh mi bi translated">NLB的测试</h2><p id="413d" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">同时，创建一个网络负载平衡器，分别为端口80和8080按ip和按实例设置目标。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/4cbd8fa318b8aec7daaa5534e6e5404b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dxjZMatrlOZygKxuFV0Bpg.png"/></div></div></figure><p id="a9ac" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">卷曲到端口80以测试by-ip目标，</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="2b04" class="lq lr it mp b gy mt mu l mv mw">&gt; curl my-nlb-912005c41dde1657.elb.us-east-1.amazonaws.com<br/>GET / HTTP/1.1<br/>Host: my-nlb-912005c41dde1657.elb.us-east-1.amazonaws.com<br/>Accept: */*<br/>User-Agent: curl/7.77.0<br/>Remote Ip:172.31.42.114:4187<br/>Served by:ip-172-31-42-226.ec2.internal</span></pre><p id="6167" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Curl到端口8080来测试by-instance方法，</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="ea79" class="lq lr it mp b gy mt mu l mv mw">&gt; curl my-nlb-912005c41dde1657.elb.us-east-1.amazonaws.com:8080<br/>GET / HTTP/1.1<br/>Host: my-nlb-912005c41dde1657.elb.us-east-1.amazonaws.com:8080<br/>Accept: */*<br/>User-Agent: curl/7.77.0</span><span id="3b6b" class="lq lr it mp b gy mx mu l mv mw">Remote Ip:<em class="nr">&lt;my router's ip&gt;</em>:50010<br/>Served by:ip-172-31-17-239.ec2.internal</span></pre><p id="bbce" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以看到，对于NLB，按实例目标反映了真实的客户端IP。NLB没有添加成对的HTTP头键/值。</p></div></div>    
</body>
</html>