<html>
<head>
<title>Improving Zero Downtime on Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">改善Kubernetes的零停机时间</h1>
<blockquote>原文：<a href="https://itnext.io/improving-zero-downtime-on-kubernetes-95e3a2f623ba?source=collection_archive---------4-----------------------#2020-02-06">https://itnext.io/improving-zero-downtime-on-kubernetes-95e3a2f623ba?source=collection_archive---------4-----------------------#2020-02-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="a0bb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">几个月前，我们开始了我上一个项目的一部分工作，着手完成两件事:</p><p id="82ec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> 1。提高我们发布过程的速度<br/> 2。允许我们同时运行应用程序的多个版本</strong></p><p id="2a2b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是我们最初的部署和发布设计的两个限制，所以在分享这篇博客时，我希望学到的教训能够帮助你避免同样的问题。</p><p id="e03c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在进入解决方案之前，我将快速描述一下我们的起点。</p><p id="1655" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">请注意:</strong>这是基础设施的简化视图，我们将仅描述与该解决方案零停机相关的元素。</p><h1 id="b906" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated"><strong class="ak">配置—在</strong>之前</h1><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi lj"><img src="../Images/b2c425a5ce710ffd83602522b0cb9cac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dw-rfLwGPI4Gy1gqU3nbjQ.png"/></div></div></figure><p id="a03d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">设计决策</strong> <br/> —为Web层(应用发布)&amp;应用层(蓝色&amp;绿色)<br/> —应用命名空间(蓝色/绿色)将是不可变的，因此将只包含一个版本<br/> —通过单个头盔图<br/>部署的应用——使用<a class="ae lv" href="https://github.com/kubernetes/ingress-nginx" rel="noopener ugc nofollow" target="_blank"> Nginx入口控制器</a>管理Kubernetes入口资源</p><h1 id="d710" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated"><strong class="ak">此配置的问题</strong></h1><p id="aaa9" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated"><strong class="jp ir"> 1。入口控制器重载导致1秒钟的流量丢失</strong></p><p id="f01b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上图中以红色显示的重定向机制重定向了“蓝色”和“绿色”命名空间之间的实时流量，这意味着更新应用发布中的入口资源，以指向冷蓝色/绿色重定向器服务资源，如下所示。</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi mb"><img src="../Images/56c5604ecc302ea77a670498453d134c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5vUJbIjDzH1pnXQqE-79NA.png"/></div></div></figure><p id="5211" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">更新入口资源以指向新服务意味着入口控制器将需要执行Nginx配置的重新加载，这导致平均<strong class="jp ir">一</strong> <strong class="jp ir">秒</strong>的掉线，导致500错误。(此处可找到这一原因及其他导致重新加载的原因)。</p><p id="3ff9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这意味着，为了执行零停机发布，我们必须从Traffic Manager中删除Region1，在离线时更新它，将其添加回Traffic Manager，并对Region2重复此操作。这导致了这个设置的下一个问题。</p><p id="cb21" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> 2。无法支持多个版本</strong> <br/>应用程序需要能够在两种情况下路由用户流量:</p><ol class=""><li id="c881" class="mc md iq jp b jq jr ju jv jy me kc mf kg mg kk mh mi mj mk bi translated">登录主页的新用户应该被路由到应用程序的最新稳定版本。</li><li id="533e" class="mc md iq jp b jq ml ju mm jy mn kc mo kg mp kk mh mi mj mk bi translated">请求版本特定资产的现有用户会话应该被路由到所请求的版本。</li></ol><p id="2337" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在当前的设计中，我们无法基于所请求的版本进行路由，并且对于两种流量场景只有一个入口流。</p><p id="eee6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这意味着在Region1被更新并重新引入Traffic Manager期间，Region2被清空(通常在5-10分钟之间)，Region2上的现有用户会话将无法路由到Region1上的版本特定资产，从而导致404。</p><p id="25c5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> 3。缓慢的发布过程</strong> <br/>这个设置的最后一个问题是执行一个发布所花费的时间。尽管上述发布过程中唯一的手动步骤是从Traffic Manager中删除/重新添加区域，但在切换到新版本之前等待连接耗尽会大大减慢我们的发布过程，这意味着重定向到一个新的、已经过测试的版本可能需要20分钟。</p><h1 id="2c26" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated"><strong class="ak">搞定</strong></h1><p id="e9ad" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">解决这个问题的计划非常简单，可以总结为三个要点。</p><p id="43b7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> 1。重定向期间无需Nginx入口控制器重新加载。</strong></p><p id="40d8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的重定向问题的根源是Nginx入口控制器重新加载的需要，以及由此导致的1秒停机时间。因此，我们需要确保所有入口资源保持静态，这意味着它们的下游配置在初始配置后不能改变。为此，我们需要找到另一种方法来重定向流量。这就是标签选择器的用武之地。</p><p id="92c0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae lv" href="https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors" rel="noopener ugc nofollow" target="_blank">标签选择器</a>允许我们将流量路由到单个名称空间内的目标pod，而不会导致连接中断。这是在没有流量管理员操作的情况下实现零停机部署的关键。</p><p id="d669" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了促进这一点，我们不得不从蓝/绿名称空间转移到单一的生产名称空间，这意味着我们的不可变发布组件不再是整个名称空间，而是掌舵发布。</p><p id="3d7b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> 2。新的默认入口&amp;服务资源</strong></p><p id="21be" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将引入新的“默认”入口流来处理新的用户流量。该流内的入口资源将保持静态，并且我们将利用标签选择器来实现零停机时间重定向。</p><p id="c578" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> 3。重构入口资源</strong></p><p id="683e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了促进流量路由的第二个用例，我们将利用基于URL <a class="ae lv" href="https://kubernetes.io/docs/concepts/services-networking/ingress/#ingress-rules" rel="noopener ugc nofollow" target="_blank">路径的路由</a>为现有用户会话引入新版本特定的入口流。</p><h1 id="9dac" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated"><strong class="ak">配置—在</strong>之后</h1><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi mq"><img src="../Images/49d95fb9c9c418e1b7a9878533da30be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9NvoqCUM5ftbXDvF_pEx8w.png"/></div></div></figure><p id="9920" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">要点:</strong> <br/> —双区域&amp;交通管理器仍然存在，上面没有显示，因为现在与零停机时间无关。<br/> —单个生产命名空间<br/> —简化设计，没有引用不同命名空间中的资源的服务<br/> —默认入口流(左)处理路由流量登陆服务主页的第一个用例。<br/> —版本特定入口处理路由流量的第二种使用情况，即基于URL路径请求版本特定资产。<br/> —入口资源保持静态，在重定向期间不再更新<br/> —重定向(红色)现在是通过CI作业使用<a class="ae lv" href="https://kubernetes.io/docs/reference/kubectl/cheatsheet/#patching-resources" rel="noopener ugc nofollow" target="_blank"> kubectl patch </a>命令更改标签选择器(如下所示)</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi mr"><img src="../Images/a75af722892de9f364cc3de0e1a05a3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xpqb7UphwaHqzUvtr7tNAA.png"/></div></div></figure><h1 id="79f4" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated"><strong class="ak">结果</strong></h1><p id="f45f" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">1.重定向过程中的手动步骤已被删除<br/> 2。重定向到新版本现在需要不到<strong class="jp ir"> 1秒</strong>的时间，并且没有连接中断<strong class="jp ir">。</strong>(运行该任务的CI作业不到5秒)<br/> 3。新版本可以随时部署到生产命名空间，并在任何实时流量定向到它们之前进行离线测试。<br/> 4。我们能够支持无限数量的并发版本</p></div></div>    
</body>
</html>