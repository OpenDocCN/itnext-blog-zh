<html>
<head>
<title>Pimp your GitLab pipeline permissions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为您的GitLab管道权限拉皮条</h1>
<blockquote>原文：<a href="https://itnext.io/pimp-your-gitlab-pipeline-permissions-ffdd27be5e1d?source=collection_archive---------2-----------------------#2021-03-21">https://itnext.io/pimp-your-gitlab-pipeline-permissions-ffdd27be5e1d?source=collection_archive---------2-----------------------#2021-03-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/d539ed90f061a31536b273a315beb7ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LqmyhCflJl8xDw1f60MANg.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">潘卡杰·帕特尔在<a class="ae kc" href="https://unsplash.com/s/photos/gitlab?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="8c77" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们假设您有一个更改存储库的GitLab CI/CD管道。或者，您可能希望充分利用对GitLab API的访问权限。有哪些选择？</p><h2 id="2ae9" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">选项1:使用个人访问令牌(PAT)</h2><p id="f0e7" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">您可以创建一个<a class="ae kc" href="https://docs.gitlab.com/ee/user/profile/personal_access_tokens.html" rel="noopener ugc nofollow" target="_blank">个人访问令牌</a>，并将其定义为一个定制的环境变量。你可以把它放在<em class="lz">里。gitlab-ci.yml，</em>但是这将是错误的选择，因为您的令牌不受保护。另一个选项是<a class="ae kc" href="https://docs.gitlab.com/ee/ci/variables/#create-a-custom-variable-in-the-ui" rel="noopener ugc nofollow" target="_blank">在UI </a>中定义变量，可以限制使用受保护的分支并屏蔽作业日志中的输出。</p><p id="9cc2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种方法有两个缺点。首先，个人访问令牌是个人的，所有审计跟踪都将绑定到这个特定的用户，隐藏了有效的用户。其次，您的令牌可能会泄露给其他用户。即使您屏蔽了变量，也很容易暴露令牌的内容。</p><p id="5347" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">作为子变体，您可以使用一个<a class="ae kc" href="https://docs.gitlab.com/ee/user/project/settings/project_access_tokens.html" rel="noopener ugc nofollow" target="_blank">项目访问令牌</a>。尽管没有绑定到个人用户，这些令牌仅限于自托管GitLab实例和付费SaaS计划。另外，令牌仍然可能会泄漏。</p><h2 id="fa2f" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">选项2:使用CI作业令牌</h2><p id="4c30" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">GitLab为每个CI作业生成一个令牌，并将其放入一个<a class="ae kc" href="https://docs.gitlab.com/ee/ci/variables/predefined_variables.html" rel="noopener ugc nofollow" target="_blank">预定义变量</a>:</p><blockquote class="ma mb mc"><p id="297a" class="kd ke lz kf b kg kh ki kj kk kl km kn md kp kq kr me kt ku kv mf kx ky kz la ij bi translated"><em class="iq"> CI_JOB_TOKEN: </em>与<a class="ae kc" href="https://docs.gitlab.com/ee/api/README.html#gitlab-cicd-job-token" rel="noopener ugc nofollow" target="_blank">某些API端点</a>进行认证的令牌。只要作业正在运行，令牌就有效。</p></blockquote><p id="9e84" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">出于安全原因，您只允许使用GitLab API的子集，例如从GitLab包或容器注册表中读取、获取作业工件、触发管道以及创建发布。但是，您不能访问存储库或使用API的其他部分。</p><p id="541d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请注意，CI作业令牌与触发管道的用户具有相同的权限，并且令牌在作业结束后过期。</p><p id="9492" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有一个<a class="ae kc" href="https://gitlab.com/groups/gitlab-org/-/epics/3559" rel="noopener ugc nofollow" target="_blank">提议</a>重新设计这个特性，留给我们最后一个选择。</p><h2 id="40a9" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">选项3:利用CI职位JWT</h2><p id="01e3" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">GitLab为每个作业生成另一个令牌，它也是一个预定义的变量:</p><blockquote class="ma mb mc"><p id="1b4e" class="kd ke lz kf b kg kh ki kj kk kl km kn md kp kq kr me kt ku kv mf kx ky kz la ij bi translated"><em class="iq"> CI_JOB_JWT: </em>一个RS256 JSON web token (JWT)，用于与支持JWT认证的第三方系统进行认证，例如<a class="ae kc" href="https://docs.gitlab.com/ee/ci/secrets/index.html" rel="noopener ugc nofollow" target="_blank"> HashiCorp的Vault </a>。</p></blockquote><p id="77a4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不幸的是，GitLab只创建JWT，但是你不能用它进行GitLab的认证。为此，我编写了一个小型GitLab代理(称为GiLP ),它接受对Git和API资源的HTTP请求，支持使用<em class="lz"> CI_JOB_JWT </em>进行身份验证，并使用个人访问令牌代表管道与GitLab进行通信:</p><figure class="mh mi mj mk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mg"><img src="../Images/b8996e20ea6006f698ab71f9020caefa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qqIqONNdbl30NBNOtNzy-w.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">GitLab代理的基本功能(<a class="ae kc" href="https://gitlab.com/johanngyger/gilp" rel="noopener ugc nofollow" target="_blank"> GiLP </a>)</figcaption></figure><p id="6ecb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你可以在这里找到吉尔普的所有细节:<a class="ae kc" href="https://gitlab.com/johanngyger/gilp/" rel="noopener ugc nofollow" target="_blank">https://gitlab.com/johanngyger/gilp</a>。</p><p id="110f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">GiLP的主要优点是PAT不会泄漏。此外，您可以审计对GiLP的所有请求，如果您知道如何对Go进行编程，那么根据您组织的需求调整权限模型是非常容易的。</p><p id="e0b4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">缺点是您必须部署和维护一个单独的组件。GiLP在Google Cloud Run或Azure Container Instances (ACI)上运行得非常好。参见我的另一篇博文<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/automatic-https-with-azure-container-instances-aci-4c4c8b03e8c9">如何为自动HTTPS </a>提供ACI。</p><h2 id="4c28" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">结论</h2><p id="c1a2" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">GitLab管道权限有些痛苦，希望很快能有一个可持续的解决方案。吉尔普同时也是你的朋友！</p></div></div>    
</body>
</html>