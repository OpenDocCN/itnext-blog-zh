<html>
<head>
<title>Efficiently understanding and using Nuxt + Vuex</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">高效理解和使用Nuxt + Vuex</h1>
<blockquote>原文：<a href="https://itnext.io/efficiently-understanding-and-using-nuxt-vuex-7905eb8858d6?source=collection_archive---------0-----------------------#2018-07-28">https://itnext.io/efficiently-understanding-and-using-nuxt-vuex-7905eb8858d6?source=collection_archive---------0-----------------------#2018-07-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="8a8e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="http://nuxtjs.org/" rel="noopener ugc nofollow" target="_blank"> Nuxt.js </a>是一个很棒的框架。我真的很喜欢它在配置方法上的惯例。在JS世界中，这令人耳目一新，并且在开发过程中节省了大量时间。因此，在文档和真实世界的使用上还存在一点差距。不再拖延，让我们深入了解Nuxt和Vuex如何协同工作。</p><h2 id="366f" class="km kn iq bd ko kp kq dn kr ks kt dp ku jy kv kw kx kc ky kz la kg lb lc ld le bi translated">为什么我的应用需要这个？</h2><p id="ae03" class="pw-post-body-paragraph jn jo iq jp b jq lf js jt ju lg jw jx jy lh ka kb kc li ke kf kg lj ki kj kk ij bi translated">函数式编程的一个特点是编写小函数来做好一件事。我们经常在紧迫的截止日期或快速解决热点问题的巨大压力下误入歧途。但在某些时候，这又回来困扰我们，并创造了一个机会，重新审视不再满足其目的的设计。也许在我们的职业生涯中，我们不止一次地发现一个变量变异是另一个事件或函数调用的副作用，是错误的来源？</p><p id="31c8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Vuex提供了处理应用程序状态的单向高速公路。一个外行人的思考方式是说“管理全局变量，不让你直接改变它们”。在这结束的时候，我希望你能掌握所有的知识，大喊“错了！”那句话。</p><p id="9486" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了更清楚地说明这一点，让我们来看一下架构:</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi lk"><img src="../Images/dc1854559ae64e840fc3307b01a53782.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*fBEKli-wnmCzTlkD.png"/></div></div><figcaption class="lw lx gj gh gi ly lz bd b be z dk translated">Vuex工作原理的彩色图表</figcaption></figure><p id="c536" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Vuex是绿色虚线框中的所有内容。您将在下面看到我们的Vuex商店中有一个状态、一个突变和一些动作。当你在Nuxt的<code class="fe ma mb mc md b">store</code>文件夹中创建一个新文件时，这个文件可能会包含一些或所有这些东西。当一个组件正在渲染时，它可以访问Vuex状态，反过来又可以用于该组件运行所需的任何功能。一旦呈现，它可以分派或改变存储，因此导致使用该存储的任何其他内容更新。</p><h2 id="d674" class="km kn iq bd ko kp kq dn kr ks kt dp ku jy kv kw kx kc ky kz la kg lb lc ld le bi translated">模块与单店</h2><p id="abcb" class="pw-post-body-paragraph jn jo iq jp b jq lf js jt ju lg jw jx jy lh ka kb kc li ke kf kg lj ki kj kk ij bi translated">老实说，<a class="ae kl" href="https://nuxtjs.org/guide/vuex-store" rel="noopener ugc nofollow" target="_blank">官方</a>文档对于应该如何配置Vuex非常混乱。我的观点是，如果你有三个以上的API调用或状态管理项来处理模块化方法是必需的。除了在一个Nuxt项目开始时快速地让一些东西工作之外，单一存储方法变得和使用全局变量一样痛苦。</p><p id="0f52" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">知道模块是最好的方法，文档建议在<code class="fe ma mb mc md b">store</code>目录中构建一个<code class="fe ma mb mc md b">index.js</code>文件。除非你打算用一些花哨的插件配置Vuex或者改变它的配置，<code class="fe ma mb mc md b">index.js</code>不应该存在于<code class="fe ma mb mc md b">store</code>文件夹中。相反，每个“小部件”都需要自己的文件。</p><h2 id="27e2" class="km kn iq bd ko kp kq dn kr ks kt dp ku jy kv kw kx kc ky kz la kg lb lc ld le bi translated">状态</h2><p id="f290" class="pw-post-body-paragraph jn jo iq jp b jq lf js jt ju lg jw jx jy lh ka kb kc li ke kf kg lj ki kj kk ij bi translated">State是一个简单的函数，它返回存储在其中的对象。通常我会构建类似于<code class="fe ma mb mc md b">store/cars.js</code>的东西</p><pre class="ll lm ln lo gt me md mf mg aw mh bi"><span id="4c98" class="km kn iq md b gy mi mj l mk ml">export const state = () =&gt; ({<br/>  list: [],<br/>  car: {}<br/>})</span></pre><p id="5cc9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这给了我一个存放我收藏的汽车的地方，以及一个存放“当前”汽车的地方。</p><p id="43a9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在组件html中，你可以使用<code class="fe ma mb mc md b">$state.cars.list</code>访问它，在javascript中通过<code class="fe ma mb mc md b">this.$state.cars.list</code>访问它。如果它是只读的，那就没问题。如果您想在表单中使用它，或者使用v-model，那么它将无法工作。有多讨厌对吧？但是如果你再看一下上面的图片，这实际上很有意义。如果你可以直接改变状态，那么你可以跳过让你程序的其他部分知道它已经改变的部分。为了使用深点符号路径，你需要使用<code class="fe ma mb mc md b">mapState</code>助手。</p><pre class="ll lm ln lo gt me md mf mg aw mh bi"><span id="6b4f" class="km kn iq md b gy mi mj l mk ml">computed: {<br/>  ...mapState({<br/>    cars: state =&gt; state.cars.<strong class="md ir">list</strong>,<br/>    car: state =&gt; state.cars.car<br/>  })<br/>}</span></pre><p id="853f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">尽可能让自己的状态保持平坦是非常重要的。处于某个状态的深度嵌套对象会失去反应性。例如，如果你的州包含类似<code class="fe ma mb mc md b">store.state.cars.car.color</code>的东西，颜色的突变将需要被强制重新加载。最好为单个<code class="fe ma mb mc md b">car </code>制作一个新的商店模块。我倾向于从使用<code class="fe ma mb mc md b">state.things.thing</code>模式开始，然后当我发现我需要在这个东西上做很多操作时，重构到<code class="fe ma mb mc md b">state.thing</code>。然后，您的状态将包含<code class="fe ma mb mc md b">thing</code>的属性，将属性恢复到它们的反应状态。这是因为如果Vuex必须遍历对象键的深层链，那么性能会受到严重影响，并且可能会出现永无止境的循环。</p><h2 id="326e" class="km kn iq bd ko kp kq dn kr ks kt dp ku jy kv kw kx kc ky kz la kg lb lc ld le bi translated">吸气剂</h2><p id="6e41" class="pw-post-body-paragraph jn jo iq jp b jq lf js jt ju lg jw jx jy lh ka kb kc li ke kf kg lj ki kj kk ij bi translated">可以把getters看作是存储的计算属性。它们应该读取模块的当前状态并返回一些东西。它应该给它所期望呈现的东西赋予一些意义。意思是全名非常重要！</p><pre class="ll lm ln lo gt me md mf mg aw mh bi"><span id="714f" class="km kn iq md b gy mi mj l mk ml">totalCars: state =&gt; {<br/>  return state.cars.length<br/>},<br/>blueCars: state =&gt; {<br/>  return state.cars.filter(car =&gt; car.color === "blue")<br/>}</span></pre><p id="504f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Getters在您的视图中始终是只读值。但是，它们可以与计算属性结合使用，并且您可以提供一个自定义设置器:</p><pre class="ll lm ln lo gt me md mf mg aw mh bi"><span id="c3a2" class="km kn iq md b gy mi mj l mk ml">computed: {<br/>  blueCars: {<br/>    get() { return this.$getters['cars/blueCars'] },<br/>    set(car) { this.$store.dispatch('cars/paintBlue', car)<br/>  }<br/>}</span></pre><p id="20a0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">虽然有一个mapGetters助手，但我从来没有对它有很大的需求。大多数情况下，组件会完成这项工作。这并不是说不要使用它，只是更有可能从存储中获取一个值并在组件中修改它。然而，如果多个组件共享读取这些值并需要读取更新，getters是一个很好的选择。</p><h2 id="673c" class="km kn iq bd ko kp kq dn kr ks kt dp ku jy kv kw kx kc ky kz la kg lb lc ld le bi translated">突变</h2><p id="46a6" class="pw-post-body-paragraph jn jo iq jp b jq lf js jt ju lg jw jx jy lh ka kb kc li ke kf kg lj ki kj kk ij bi translated">这就是如何在状态中提交值。你不能直接调用它，因为突变是一个反应事件，我们希望我们的应用程序知道什么时候发生了变化。</p><pre class="ll lm ln lo gt me md mf mg aw mh bi"><span id="d6ee" class="km kn iq md b gy mi mj l mk ml"><strong class="md ir">export const </strong>mutations = {<br/>  set(state, cars) {<br/>    state.list = cars<br/>  },<br/>  add(state, value) {<br/>    <em class="mm">merge</em>(state.list, value)<br/>  },<br/>  remove(state, {car}) {<br/>    state.list.splice(state.list.indexOf(car), 1)<br/>  }, <br/>  setCar(state, car) { state.car = car }<br/>}</span></pre><p id="4793" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有了这个我就可以调用<code class="fe ma mb mc md b">$store.commit(‘cars/set’, [{id: 1, model: "Tacoma", brand: "Toyota"}])</code>等。当您希望用默认值预先填充存储，或者在计算属性中将其用作<code class="fe ma mb mc md b">set</code>处理程序时，这在具有<code class="fe ma mb mc md b">fetch</code>、<code class="fe ma mb mc md b">asyncData</code>和<code class="fe ma mb mc md b">nuxtServerInit</code>函数的组件中非常有用。</p><p id="c9d5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在组件中，您可以使用mapMutations助手快速获取映射到组件的mutator函数调用:</p><pre class="ll lm ln lo gt me md mf mg aw mh bi"><span id="aa14" class="km kn iq md b gy mi mj l mk ml">methods: {<br/>  ...mapMutations({<br/>    setCars: 'cars/set'<br/>  })<br/>}</span></pre><p id="d441" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这意味着在您的组件中，您可以通过<code class="fe ma mb mc md b">this.setCars([{id: 1, model: "Tacoma", brand: "Toyota"}])</code>访问它。</p><p id="c79a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我在上面提到了在<code class="fe ma mb mc md b">state.things.thing</code>到<code class="fe ma mb mc md b">state.thing</code>模块之间移动。在这种情况下，您可能希望设置一个变异函数，可以轻松地将对象键映射到状态。要做到这一点，您需要:</p><pre class="ll lm ln lo gt me md mf mg aw mh bi"><span id="17a1" class="km kn iq md b gy mi mj l mk ml">setCar(state, form) {<br/>  <strong class="md ir">let </strong>keys = Object.keys(form);<br/>  keys.forEach((key) =&gt; state[key] = form[key])<br/>},</span></pre><p id="9f7b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当然，您可以在这里验证您的状态，并防止意外的键污染状态。这完全取决于应用程序要求。</p><p id="bd99" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我想指出的是，改变嵌套很深的值也容易出错，很可能导致Vuex拒绝这种改变。试图变异<code class="fe ma mb mc md b">$store.state.cars.car.tire.brand</code>会告诉你这是不允许的。在这种情况下，最好创建一个处理单个汽车的<code class="fe ma mb mc md b">car.js</code>模块，因此它的状态包含单个汽车实体的属性。试着让你的状态对象尽可能的平坦。使用深度嵌套变异时创建新的存储。</p><h2 id="5ac6" class="km kn iq bd ko kp kq dn kr ks kt dp ku jy kv kw kx kc ky kz la kg lb lc ld le bi translated">行动</h2><p id="4ef1" class="pw-post-body-paragraph jn jo iq jp b jq lf js jt ju lg jw jx jy lh ka kb kc li ke kf kg lj ki kj kk ij bi translated">这些对于应用程序需要的任何异步活动都很有用。特别适用于调用后端服务器，或者需要非阻塞突变时。让我为这两种情况举一个例子。</p><pre class="ll lm ln lo gt me md mf mg aw mh bi"><span id="f105" class="km kn iq md b gy mi mj l mk ml"><strong class="md ir">export const </strong>actions = {<br/>  <strong class="md ir">async </strong>get({commit}) {<br/>    <strong class="md ir">await this</strong>.$axios.get('cars')<br/>      .then((res) =&gt; {<br/>        <strong class="md ir">if </strong>(res.status === 200) {<br/>          commit('set', res.data)<br/>        }<br/>      })<br/>  },<br/>  <strong class="md ir">async </strong>show({commit}, params) {<br/>    <strong class="md ir">await this</strong>.$axios.get(`cars/${params.car_id}`)<br/>      .then((res) =&gt; {<br/>        <strong class="md ir">if </strong>(res.status === 200) {<br/>          commit('setCar', res.data)<br/>        }<br/>      })<br/>  },<br/>  <strong class="md ir">async </strong>set({commit}, car) {<br/>    <strong class="md ir">await </strong>commit('set', car)<br/>  }<br/>}</span></pre><p id="21ef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里我们定义了三个动作，<code class="fe ma mb mc md b">get</code>、<code class="fe ma mb mc md b">show</code>和<code class="fe ma mb mc md b">set</code>。Get将获取我们的整个汽车集合，并在成功时用服务器返回的列表设置商店。显示是一样的，但是我们可以传入查询参数。这对于设置搜索或任何其他需要参数的场景非常有用。Last是对我们之前的突变的添加，一个从上面调用突变“set”的动作。也许我们有一个15，000辆汽车的列表，这导致提交时UI延迟？这样，我们可以为使用承诺或异步/等待调用建立一个成功的未来。</p><h2 id="be58" class="km kn iq bd ko kp kq dn kr ks kt dp ku jy kv kw kx kc ky kz la kg lb lc ld le bi translated">插件</h2><p id="cba8" class="pw-post-body-paragraph jn jo iq jp b jq lf js jt ju lg jw jx jy lh ka kb kc li ke kf kg lj ki kj kk ij bi translated">强烈推荐阅读用于Vuex的<a class="ae kl" href="https://medium.com/js-dojo/5-vuex-plugins-for-your-next-vuejs-project-df9902a70de2" rel="noopener">五大插件</a>。只需创建一个<code class="fe ma mb mc md b">store/index.js</code>，并按照各自配置的建议将其导入。</p><h2 id="ab92" class="km kn iq bd ko kp kq dn kr ks kt dp ku jy kv kw kx kc ky kz la kg lb lc ld le bi translated">严格模式</h2><p id="b265" class="pw-post-body-paragraph jn jo iq jp b jq lf js jt ju lg jw jx jy lh ka kb kc li ke kf kg lj ki kj kk ij bi translated">默认情况下，Nuxt将Vuex配置为在开发中使用严格模式。如果你愿意，可以在<code class="fe ma mb mc md b">store/index.js</code>中禁用它，但这样做是一个<em class="mm">坏主意</em>。关闭它允许突变调用来自任何地方，有效地打破了架构的规则。在生产中它是禁用的，但你已经编写了知道规则没有被破坏的应用程序，所以当vuex不再担心在生产中检查这个问题时，它就成为一个性能提升。</p><p id="0ebd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一个常见的错误是试图使用<code class="fe ma mb mc md b">v-model=”$state.cars.car.color”</code>改变状态，这是行不通的，因为这实际上是值的只读版本。相反，它应该使用计算属性，或者mapState/mapMutations帮助器的组合。</p><h2 id="3ff7" class="km kn iq bd ko kp kq dn kr ks kt dp ku jy kv kw kx kc ky kz la kg lb lc ld le bi translated">回顾</h2><p id="c1ed" class="pw-post-body-paragraph jn jo iq jp b jq lf js jt ju lg jw jx jy lh ka kb kc li ke kf kg lj ki kj kk ij bi translated">我花了一点时间从过去的Javascript代码中改掉一些坏习惯，才真正体会到Vuex给应用程序带来的价值。我觉得不是每个app都需要的东西；相信那是狭隘的。在JS世界中有许多很好的状态管理实现，但是Nuxt已经接受了Vuex，目前它工作得很好。</p><p id="29e4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在用户界面中拥有状态的真实来源可以节省大量开发时间。用对变化的反应、一致的API和强大的插件生态系统来支持它，给了我们一个快速解决问题的工具箱。</p><h2 id="152d" class="km kn iq bd ko kp kq dn kr ks kt dp ku jy kv kw kx kc ky kz la kg lb lc ld le bi translated">在Nuxt中</h2><p id="e9bd" class="pw-post-body-paragraph jn jo iq jp b jq lf js jt ju lg jw jx jy lh ka kb kc li ke kf kg lj ki kj kk ij bi translated">Nuxt在pages中提供了一个<code class="fe ma mb mc md b">fetch</code>方法。这对于在页面呈现之前挂钩操作非常有用。在pages中经常会看到这样的代码块:</p><pre class="ll lm ln lo gt me md mf mg aw mh bi"><span id="48f7" class="km kn iq md b gy mi mj l mk ml"><strong class="md ir">async </strong>fetch({store}) {<br/>  <strong class="md ir">await </strong>store.dispatch("cars/get")<br/>}</span></pre><p id="4544" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这将调用cars模块中的“get”操作，调用后端并将cars状态设置为API响应。</p><h2 id="76d0" class="km kn iq bd ko kp kq dn kr ks kt dp ku jy kv kw kx kc ky kz la kg lb lc ld le bi translated">Vuex助手</h2><p id="3e99" class="pw-post-body-paragraph jn jo iq jp b jq lf js jt ju lg jw jx jy lh ka kb kc li ke kf kg lj ki kj kk ij bi translated">Vuex有映射助手，可以轻松地消除商店的呼叫。不要到处使用<code class="fe ma mb mc md b">$store.state...</code>，使用<code class="fe ma mb mc md b">mapState</code>会更干净。动作、突变和getters也有助手。</p><pre class="ll lm ln lo gt me md mf mg aw mh bi"><span id="6b62" class="km kn iq md b gy mi mj l mk ml">computed: {<br/>  ...mapState({<br/>    cars: state =&gt; state.cars.list<br/>  })<br/>}</span></pre><p id="3b8d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这创建了一个函数调用，让我们引用<code class="fe ma mb mc md b">this.cars</code>而不是<code class="fe ma mb mc md b">this.$store.state.cars.list</code>。很清楚哪个更容易阅读。</p><p id="5167" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe ma mb mc md b">mapGetters</code>使用与<code class="fe ma mb mc md b">mapState</code>完全相同的参数，明显的例外是它不允许突变。Getters是只读的，通常用于格式化数据。</p><p id="9365" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">mapState正在做的事情是这样的:</p><pre class="ll lm ln lo gt me md mf mg aw mh bi"><span id="fc04" class="km kn iq md b gy mi mj l mk ml">computed: {<br/>  cars: {<br/>    get() {<br/>      return this.$store.state.cars.list<br/>    },<br/>    set(val) {<br/>      this.$store.commit('cars/set', val)<br/>    }<br/>  }<br/>}</span></pre><p id="7b2d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这也是一个有用的模式，当您需要执行定制的变化或者任何其他需要的预提交逻辑时。记住，虽然这些函数应该非常短，所以尽量保持get/set中的逻辑最少。</p><p id="6cc6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您还可以使用<code class="fe ma mb mc md b">mapMutations</code>将变异函数拉入模板:</p><pre class="ll lm ln lo gt me md mf mg aw mh bi"><span id="02f1" class="km kn iq md b gy mi mj l mk ml">methods: {<br/>    ...mapMutations('cars', ['set', 'anotherMutation'])<br/>}</span></pre><p id="1d53" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后调用<code class="fe ma mb mc md b">this.set(val)</code>而不是<code class="fe ma mb mc md b">this.$store.commit('cars/set', val)</code></p><h2 id="064d" class="km kn iq bd ko kp kq dn kr ks kt dp ku jy kv kw kx kc ky kz la kg lb lc ld le bi translated">结论</h2><p id="d406" class="pw-post-body-paragraph jn jo iq jp b jq lf js jt ju lg jw jx jy lh ka kb kc li ke kf kg lj ki kj kk ij bi translated">我希望这澄清了很多关于Vuex的细微差别和困惑。用Vue编码是如此重要的一部分，以至于知道如何最大限度地利用它可以提高生产率。</p><p id="4a47" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">编辑:如果你想要更多的软件模式，还有一个<a class="ae kl" rel="noopener ugc nofollow" target="_blank" href="/eating-my-advice-efficiently-improving-on-understanding-and-using-nuxt-vuex-6d00769014a2">跟进</a>。</p><h2 id="fdfd" class="km kn iq bd ko kp kq dn kr ks kt dp ku jy kv kw kx kc ky kz la kg lb lc ld le bi translated">参考:</h2><div class="mn mo gp gr mp mq"><a href="https://vuex.vuejs.org/guide/" rel="noopener  ugc nofollow" target="_blank"><div class="mr ab fo"><div class="ms ab mt cl cj mu"><h2 class="bd ir gy z fp mv fr fs mw fu fw ip bi translated">Vuex |开始使用</h2><div class="mx l"><h3 class="bd b gy z fp mv fr fs mw fu fw dk translated">Vue.js的集中状态管理</h3></div><div class="my l"><p class="bd b dl z fp mv fr fs mw fu fw dk translated">vuex.vuejs.org</p></div></div></div></a></div><div class="mn mo gp gr mp mq"><a href="https://nuxtjs.org/guide/vuex-store" rel="noopener  ugc nofollow" target="_blank"><div class="mr ab fo"><div class="ms ab mt cl cj mu"><h2 class="bd ir gy z fp mv fr fs mw fu fw ip bi translated">Vuex Store - Nuxt.js</h2><div class="mx l"><h3 class="bd b gy z fp mv fr fs mw fu fw dk translated">使用存储来管理状态对于每个大型应用程序都很重要，这就是为什么Nuxt.js在其…</h3></div><div class="my l"><p class="bd b dl z fp mv fr fs mw fu fw dk translated">nuxtjs.org</p></div></div><div class="mz l"><div class="na l nb nc nd mz ne lu mq"/></div></div></a></div><div class="mn mo gp gr mp mq"><a href="https://vuejs.org/v2/guide/instance.html#Instance-Lifecycle-Hooks" rel="noopener  ugc nofollow" target="_blank"><div class="mr ab fo"><div class="ms ab mt cl cj mu"><h2 class="bd ir gy z fp mv fr fs mw fu fw ip bi translated">Vue实例- Vue.js</h2><div class="mx l"><h3 class="bd b gy z fp mv fr fs mw fu fw dk translated">每个Vue应用程序都从创建一个带有Vue函数的新Vue实例开始:尽管没有严格的关联…</h3></div><div class="my l"><p class="bd b dl z fp mv fr fs mw fu fw dk translated">vuejs.org</p></div></div><div class="mz l"><div class="nf l nb nc nd mz ne lu mq"/></div></div></a></div><p id="8092" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意:我写了一篇后续文章，讨论了一些有用的片段和开发应用的设计模式。</p></div></div>    
</body>
</html>