<html>
<head>
<title>Working with the View in Blazor MVVM : functions{} vs code behind vs ViewModel</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Blazor MVVM中使用视图:函数{} vs代码隐藏vs视图模型</h1>
<blockquote>原文：<a href="https://itnext.io/working-with-the-view-in-blazor-mvvm-functions-vs-code-behind-vs-viewmodel-ed3508dba86a?source=collection_archive---------0-----------------------#2019-04-20">https://itnext.io/working-with-the-view-in-blazor-mvvm-functions-vs-code-behind-vs-viewmodel-ed3508dba86a?source=collection_archive---------0-----------------------#2019-04-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/8686cfd665f32462b6a7ba17426b12e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K-wx9Fsh2nXJ6qAiXqz3KA.png"/></div></div></figure><p id="cb7c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是关于在客户端Blazor中使用模型-视图-视图模型模式的一种方法的系列文章的第五篇。如果您想从头开始阅读该系列，第一篇文章位于此处:</p><div class="kw kx gp gr ky kz"><a rel="noopener  ugc nofollow" target="_blank" href="/a-simple-mvvm-implementation-in-client-side-blazor-8c875c365435"><div class="la ab fo"><div class="lb ab lc cl cj ld"><h2 class="bd ir gy z fp le fr fs lf fu fw ip bi translated">客户端Blazor中一个简单的MVVM实现。</h2><div class="lg l"><h3 class="bd b gy z fp le fr fs lf fu fw dk translated">如前所述，我正致力于将我的生产Silverlight应用程序迁移到一个新的平台上。我的…</h3></div><div class="lh l"><p class="bd b dl z fp le fr fs lf fu fw dk translated">itnext.io</p></div></div><div class="li l"><div class="lj l lk ll lm li ln jw kz"/></div></div></a></div><p id="e848" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">本系列的所有源代码都可以在GitHub上获得。代表本文起点的代码包含在ArticleFour分支和4.4版本中。本文结尾的代码将成为ArticleFive分支和4.5版本。所有代码和文章都已更新，可以使用。网芯3预览版4。</p><div class="kw kx gp gr ky kz"><a href="https://github.com/lchendricks/BlazorMVVM" rel="noopener  ugc nofollow" target="_blank"><div class="la ab fo"><div class="lb ab lc cl cj ld"><h2 class="bd ir gy z fp le fr fs lf fu fw ip bi translated">lchendrick s/blazormvm</h2><div class="lg l"><h3 class="bd b gy z fp le fr fs lf fu fw dk translated">一个客户端Blazor MVVM实现。通过在…上创建帐户，为lchendricks/BlazorMVVM的开发做出贡献</h3></div><div class="lh l"><p class="bd b dl z fp le fr fs lf fu fw dk translated">github.com</p></div></div><div class="li l"><div class="lo l lk ll lm li ln jw kz"/></div></div></a></div><h1 id="788c" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">我们为什么要这么做？</h1><p id="eb2d" class="pw-post-body-paragraph jy jz iq ka b kb mn kd ke kf mo kh ki kj mp kl km kn mq kp kq kr mr kt ku kv ij bi translated">自从我开始与Blazor合作并开始使用MVVM构建客户端应用程序以来，我已经不止一次地遇到了几个问题。这些问题是:</p><ul class=""><li id="d09e" class="ms mt iq ka b kb kc kf kg kj mu kn mv kr mw kv mx my mz na bi translated">如何让我的代码离开我的视图？</li><li id="ab2c" class="ms mt iq ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated">当我可以在视图中做任何事情时，为什么我还需要一个视图模型？</li><li id="9d63" class="ms mt iq ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated">为什么我的Blazor应用程序需要MVVM？</li></ul><p id="c0a1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后一个问题可能是最容易回答的。真正简短的答案是“你的应用可能不需要MVVM”。MVVM(或任何设计模式)的使用是视情况而定的，目标是降低应用程序的复杂性。如果在用UI显示数据之前没有转换模型中的任何数据，并且没有在应用程序的多个部分显示相同的数据，那么您可能没有一个好的MVVM用例。MVVM允许你把你的应用程序分解成更小的类，并有明确的职责。如果你的班级在开始的时候已经很小了，而且只有一个单一的责任，那么再把他们分开是没有任何好处的。</p><p id="703d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">也就是说，如果你的代码是合理设计的，你可以从没有MVVM开始，然后用重构引入它。可以做所有事情的单个视图可以被重构为视图和视图模型。该视图模型可以在以后被重构为视图模型和模型。如果您从一开始就关注了这一系列的文章，您会看到我们从FetchData.razor开始，并在四篇文章中从一开始的单一视图重构到有多个孩子的完整MVVM。</p><h1 id="cc1c" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">@functions{}块</h1><p id="3113" class="pw-post-body-paragraph jy jz iq ka b kb mn kd ke kf mo kh ki kj mp kl km kn mq kp kq kr mr kt ku kv ij bi translated">我目前对<code class="fe ng nh ni nj b">@functions{}</code>百感交集。一方面，我觉得视图中不应该有任何代码；应该是UI标记。另一方面，我记不清在过去的20年中有多少次我在研究页面的行为时，意识到我只是在查看视图模型，而需要去查看后面的代码。Blazor仍在预览中，所以暂时我将推迟就此事做出个人决定，并展示与视图交互的两种方式。然而，我要说的是，清楚地理解一些代码应该是视图的一部分，而其他代码属于视图模型是很重要的。</p><p id="01b4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了查看后面的代码，我们将开始构建购物车的结构。这应该为我们提供了一些在视图和视图模型中使用代码的有效例子。开始时，我们需要将物品放入购物车，因此转到<code class="fe ng nh ni nj b">BlazorMVVM.Shared</code>项目并添加一个新类<code class="fe ng nh ni nj b">InventoryItem.cs</code>。用以下代码填充该类:</p><figure class="nk nl nm nn gt jr"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="834e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">虽然数量不多，但对于我们的示例来说已经足够了。接下来，我们将制作一个视图模型。为了证明我之前的观点，我不打算做一个单独的模型，只是把所有东西都放在这里。当我们准备好以后，我们可以重构并提取模型到它自己的类中。创建一个新的类<code class="fe ng nh ni nj b">ShoppingCartViewModel.cs</code>并将下面的代码放入其中。</p><figure class="nk nl nm nn gt jr"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="2afd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以看到，我们构建了一个类，并声明了必要的接口来使用它。我们在类中放了一个<code class="fe ng nh ni nj b">List&lt;InventoryItem&gt;</code>，并使用属性<code class="fe ng nh ni nj b">Cart</code>来访问它。我们还在类中添加了三个方法；一个用于向购物车添加商品，一个用于合计数量和价格，最后一个用于以我的本地货币显示价格(向世界其他地方道歉)。</p><p id="0c19" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">创建ViewModel后，我们可以在<code class="fe ng nh ni nj b">Startup.cs</code>中用每个人现在都应该习惯的语法注册它:</p><pre class="nk nl nm nn gt nq nj nr ns aw nt bi"><span id="4186" class="nu lq iq nj b gy nv nw l nx ny">services.AddTransient&lt;IShoppingCartViewModel, ShoppingCartViewModel&gt;();</span></pre><p id="bb72" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后一步是创建一个视图来绑定和显示我们的购物车。创建一个名为<code class="fe ng nh ni nj b">ShoppingCart.razor</code>的新视图，并粘贴以下代码:</p><figure class="nk nl nm nn gt jr"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="dd78" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，转到<code class="fe ng nh ni nj b">NavMenu.razor</code>并添加一个新部分，让我们可以导航到我们的购物车。</p><figure class="nk nl nm nn gt jr"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="d6b9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有了所有这些，我们可以启动我们的应用程序并查看我们的购物车，但实际上没有什么可看的。让我们添加一个<code class="fe ng nh ni nj b">OnInit()</code>调用到我们的视图中，当页面加载时，这个调用将条目加载到我们的卡片中。我们可以假设这模拟了一个用户带着购物车中的商品离开后回到我们的站点。将此<code class="fe ng nh ni nj b">@functions</code>块添加到视图底部。</p><figure class="nk nl nm nn gt jr"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="0914" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们现在启动我们的应用程序，并导航到我们的购物车，我们将看到几个项目以及总数:</p><figure class="nk nl nm nn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nz"><img src="../Images/549057b24efe8607482857b96403fc8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hYbmgbtGBvNftLshqL5y5A.png"/></div></div></figure><h1 id="1569" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">移到代码后面</h1><p id="16f7" class="pw-post-body-paragraph jy jz iq ka b kb mn kd ke kf mo kh ki kj mp kl km kn mq kp kq kr mr kt ku kv ij bi translated">现在假设设计决策是使用代码隐藏，而不是在视图中使用<code class="fe ng nh ni nj b">@function</code>块。这不是很多工作。基本思想是我们创建一个继承自<code class="fe ng nh ni nj b">ComponentBase</code>的类，然后让视图继承该类。视图可用的所有内容都可以在该类中访问。</p><p id="6c1c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先进入我们的视图文件夹，添加一个新的类<code class="fe ng nh ni nj b">ShoppingCart.razor.cs</code>。Visual Studio将会有所帮助，并将代码嵌套在视图下。我们将有一个与<code class="fe ng nh ni nj b">ShoppingCart</code>冲突的类名称，进入新类并将其重命名为<code class="fe ng nh ni nj b">ShoppingCartBase</code>，并使其继承自<code class="fe ng nh ni nj b">ComponentBase</code>。连接了后面的代码后，我们可以返回视图，让它继承后面的代码。</p><pre class="nk nl nm nn gt nq nj nr ns aw nt bi"><span id="7c11" class="nu lq iq nj b gy nv nw l nx ny">@inherits ShoppingCartBase</span></pre><p id="2acd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有了这些，我们就可以开始将代码从视图中移植到后面的代码中了。首先从视图中删除所有三个using指令，并将它们放在代码的顶部。接下来，删除页面顶部的inject指令，并将其放入后面的代码中。到目前为止，新代码看起来与我们在类中进行的构造函数注入不同。</p><pre class="nk nl nm nn gt nq nj nr ns aw nt bi"><span id="9eba" class="nu lq iq nj b gy nv nw l nx ny">[Inject]</span><span id="5d24" class="nu lq iq nj b gy oa nw l nx ny">public IShoppingCartViewModel ViewModel { get; set; }</span></pre><p id="1fa0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我们在razor视图中使用<code class="fe ng nh ni nj b">@inject</code>时，很难意识到这一点，但我们实际上一直在为视图进行属性注入，而不是构造函数注入。这行代码让我们使用属性注入将ViewModel传递到后面的代码中。</p><p id="954f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后一步是从我们的<code class="fe ng nh ni nj b">@functions</code>中移除<code class="fe ng nh ni nj b">OnInit()</code>方法，并把它放在我们的类后代码中。然后，我们可以从视图中删除该空块。在改变了我们周围的一切之后，现在看起来是这样的:</p><figure class="nk nl nm nn gt jr"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="0123" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">后面的代码是这样的:</p><figure class="nk nl nm nn gt jr"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="e545" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们再次启动应用程序，我们会看到一切仍然正常，我们有一个单独的视图、代码隐藏和视图模型。</p><h1 id="1586" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">代码隐藏与视图模型</h1><p id="ccfa" class="pw-post-body-paragraph jy jz iq ka b kb mn kd ke kf mo kh ki kj mp kl km kn mq kp kq kr mr kt ku kv ij bi translated">所以我们现在有两个不同的类来保存影响我们视图的代码。我们什么时候把代码放在代码后面，什么时候把代码放在视图模型中？</p><p id="082e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">目前，我觉得我们需要使用代码的唯一原因是为了访问视图的生命周期方法。MVVM的每一层都不知道它上面的那一层。模型不知道它被注入的视图模型的任何信息，视图模型也不知道视图的任何信息。如果你需要挂钩到<code class="fe ng nh ni nj b">OnInit</code>、<code class="fe ng nh ni nj b">OnParametersSet</code>、<code class="fe ng nh ni nj b">OnAfterRender</code>或者如果你要调用<code class="fe ng nh ni nj b">BuildRenderTree</code>，你将在后面的代码中工作。</p><p id="27c2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果要格式化数据，可能需要在视图模型中进行。回到ViewModel，看看<code class="fe ng nh ni nj b">DisplayPrice()</code>方法。我们可以像放入ViewModel一样容易地将这段代码放入后面的代码中。然而，如果我们构建一个新的视图并将我们的视图模型绑定到它，而该方法已经在它后面的代码中，那么它将不可用。如果我们走这条路，我们将不得不在新视图中再次复制我们的代码。有了ViewModel中的这个函数，我们每次在整个系统中使用ViewModel时都可以访问它。</p><p id="523a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我觉得将视图绑定到视图模型的正确方法是尽一切可能在razor文件中进行绑定。如果你需要使用<code class="fe ng nh ni nj b">@functions</code>或者后面的代码，试着让它成为一个方法调用来保持分离级别不变。</p><h1 id="7de3" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">包扎</h1><p id="8f3a" class="pw-post-body-paragraph jy jz iq ka b kb mn kd ke kf mo kh ki kj mp kl km kn mq kp kq kr mr kt ku kv ij bi translated">到目前为止，您应该对何时以及如何使用<code class="fe ng nh ni nj b">@functions</code>、代码隐藏和视图模型有了一些好的想法。我要再说一遍，设计模式是指南，做一件事总有不止一种方法。利用这些信息来构建比我们今天所学的例子更好的东西。</p><p id="2a0b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在下一篇文章中，我们计划将多个组件添加到我们的购物车中，并在使用客户端Blazor的MVVM时，检查一个视图中多个组件的行为。</p></div></div>    
</body>
</html>