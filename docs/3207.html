<html>
<head>
<title>Query Nested Data in Postgres using Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Node.js查询Postgres中的嵌套数据</h1>
<blockquote>原文：<a href="https://itnext.io/query-nested-data-in-postgres-using-node-js-35e985368ea4?source=collection_archive---------0-----------------------#2019-10-25">https://itnext.io/query-nested-data-in-postgres-using-node-js-35e985368ea4?source=collection_archive---------0-----------------------#2019-10-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/3882e32fa61c905606f6e5b120220d49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UkM7DdLlg_CmUg6Z62dJSw.jpeg"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">由<a class="ae jg" href="https://unsplash.com/@photosbybeks?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">拍摄的照片由<a class="ae jg" href="https://unsplash.com/s/photos/elephant?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的Beks </a>拍摄</figcaption></figure><div class=""/><p id="baf2" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当构建提供JSON数据的服务器时，无论是使用REST还是GraphQL，我们经常想要查询某个时间，以及它的“孩子”。如果我们不小心，我们可能会以大量低效的查询而告终。幸运的是，Postgres有一些函数允许直接以“JSON”的形式返回复杂的数据结构。这对于node.js来说非常有用，因为它们只是变成了原生的JavaScript对象。</p><h1 id="7cbf" class="le lf jj bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">问题是</h1><p id="c103" class="pw-post-body-paragraph kg kh jj ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">考虑数据库模式:</p><figure class="mi mj mk ml gt iv gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/f42aacb73ead2b9dd8db8095182b9de1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1136/format:webp/1*SB2RgOa-Pndi0gFPAGDY_g.png"/></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">一个包含3个表的数据库模式:“users”、“user_teams”和“teams”。每个用户都有一个由“经理id”字段标识的经理。“用户团队”表链接“用户”和“经理”。</figcaption></figure><p id="687c" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以通过运行以下命令来创建这个数据库模式以及一些示例数据:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="6c92" class="mr lf jj mn b gy ms mt l mu mv"><strong class="mn jk">CREATE TABLE</strong> users (<br/>  user_id <strong class="mn jk">BIGSERIAL NOT NULL PRIMARY KEY</strong>,<br/>  display_name <strong class="mn jk">TEXT NOT NULL</strong>,<br/>  manager_id <strong class="mn jk">BIGINT NULL REFERENCES</strong> users(user_id)<br/>);</span><span id="e82c" class="mr lf jj mn b gy mw mt l mu mv"><strong class="mn jk">CREATE TABLE</strong> teams (<br/>  team_id <strong class="mn jk">BIGSERIAL NOT NULL PRIMARY KEY</strong>,<br/>  display_name <strong class="mn jk">TEXT NOT NULL</strong><br/>);</span><span id="c059" class="mr lf jj mn b gy mw mt l mu mv"><strong class="mn jk">CREATE TABLE</strong> user_teams (<br/>  user_id <strong class="mn jk">BIGINT NOT NULL REFERENCES</strong> users,<br/>  team_id <strong class="mn jk">BIGINT NOT NULL REFERENCES</strong> teams,<br/>  <strong class="mn jk">PRIMARY KEY</strong>(user_id, team_id)<br/>);</span><span id="31a1" class="mr lf jj mn b gy mw mt l mu mv"><strong class="mn jk">INSERT INTO</strong> users<br/>  (user_id, display_name, manager_id)<br/><strong class="mn jk">VALUES</strong><br/>  (1, 'Forbes', NULL), (2, 'John', NULL), (3, 'Joe', 1);</span><span id="f4ae" class="mr lf jj mn b gy mw mt l mu mv"><strong class="mn jk">INSERT</strong> <strong class="mn jk">INTO</strong> teams<br/>  (team_id, display_name)<br/><strong class="mn jk">VALUES</strong><br/>  (1, 'Awesome Team'), (2, 'Team of One');</span><span id="b027" class="mr lf jj mn b gy mw mt l mu mv"><strong class="mn jk">INSERT</strong> <strong class="mn jk">INTO</strong> user_teams<br/>  (user_id, team_id)<br/><strong class="mn jk">VALUES</strong><br/>  (1, 1), (2, 1), (1, 2);</span></pre><p id="172b" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在假设我们想要运行一个查询，如下所示:</p><blockquote class="mx my mz"><p id="500c" class="kg kh na ki b kj kk kl km kn ko kp kq nb ks kt ku nc kw kx ky nd la lb lc ld im bi translated">获取所有用户的列表，并为每个用户获取他们的团队和经理</p></blockquote><p id="fc4c" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们希望输出看起来像这样:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="a02b" class="mr lf jj mn b gy ms mt l mu mv">[<br/>  {<br/>    <strong class="mn jk">"id"</strong>: 1,<br/>    <strong class="mn jk">"display_name"</strong>: "Forbes",<br/>    <strong class="mn jk">"manager"</strong>: null,<br/>    <strong class="mn jk">"teams"</strong>: [<br/>      {<br/>        <strong class="mn jk">"id"</strong>: 1,<br/>        <strong class="mn jk">"display_name"</strong>: "Awesome Team"<br/>      },<br/>      {<br/>        <strong class="mn jk">"id"</strong>: 2,<br/>        <strong class="mn jk">"display_name"</strong>: "Team of One"<br/>      }<br/>    ]<br/>  },<br/>  {<br/>    <strong class="mn jk">"id"</strong>: 2,<br/>    <strong class="mn jk">"display_name"</strong>: "John",<br/>    <strong class="mn jk">"manager"</strong>: null,<br/>    <strong class="mn jk">"teams"</strong>: [<br/>      {<br/>        <strong class="mn jk">"id"</strong>: 1,<br/>        <strong class="mn jk">"display_name"</strong>: "Awesome Team"<br/>      }<br/>    ]<br/>  },<br/>  {<br/>    <strong class="mn jk">"id"</strong>: 3,<br/>    <strong class="mn jk">"display_name"</strong>: "Joe",<br/>    <strong class="mn jk">"manager"</strong>: {<br/>      <strong class="mn jk">"id"</strong>: 1,<br/>      <strong class="mn jk">"display_name"</strong>: "Forbes"<br/>    },<br/>    <strong class="mn jk">"teams"</strong>: []<br/>  }<br/>]</span></pre><h1 id="365d" class="le lf jj bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">最简单的解决方法？</h1><p id="13bc" class="pw-post-body-paragraph kg kh jj ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们有几个选择。我们可以使用node.js递归运行所有查询，使用<code class="fe ne nf ng mn b"><a class="ae jg" href="https://www.atdatabases.org/docs/pg" rel="noopener ugc nofollow" target="_blank">@databases/pg</a></code>合并所有数据:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="5683" class="mr lf jj mn b gy ms mt l mu mv"><strong class="mn jk">const</strong> results = <strong class="mn jk">await</strong> Promise.all(<br/>  (<strong class="mn jk">await</strong> db.query(<br/>    sql`<br/>      <strong class="mn jk">SELECT</strong> u.user_id <strong class="mn jk">AS</strong> id, u.display_name, u.manager_id<br/>      <strong class="mn jk">FROM</strong> users u<br/>    `,<br/>  )).map(<strong class="mn jk">async</strong> ({manager_id, ...user}) =&gt; ({<br/>    ...user,<br/>    manager:<br/>      (<strong class="mn jk">await</strong> db.query(<br/>        sql`<br/>          <strong class="mn jk">SELECT</strong> u.user_id <strong class="mn jk">AS</strong> id, u.display_name<br/>          <strong class="mn jk">FROM</strong> users u<br/>          <strong class="mn jk">WHERE</strong> u.user_id=${manager_id}<br/>        `,<br/>      ))[0] || null,<br/>    teams: <strong class="mn jk">await</strong> db.query(<br/>      sql`<br/>        <strong class="mn jk">SELECT</strong> t.team_id <strong class="mn jk">AS</strong> id, t.display_name<br/>        <strong class="mn jk">FROM</strong> user_teams ut<br/>        <strong class="mn jk">JOIN</strong> teams t <strong class="mn jk">USING</strong> (team_id)<br/>        <strong class="mn jk">WHERE</strong> ut.user_id = ${user.id}<br/>      `,<br/>    ),<br/>  })),<br/>);<br/>console.log(results);</span></pre><p id="0dde" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这很好，只要数据集很小。唯一的问题是我们正在运行<code class="fe ne nf ng mn b">2n + 1</code>查询(其中<code class="fe ne nf ng mn b">n</code>是用户数量)。在获取所有用户之前，我们也不能运行内部查询。这给我们的node.js服务器和Postgres服务器都带来了很多不必要的负载。</p><h1 id="28d5" class="le lf jj bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">选择<code class="fe ne nf ng mn b">ANY</code></h1><p id="8874" class="pw-post-body-paragraph kg kh jj ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">如果您熟悉JavaScript，并对SQL有所了解，您可能会想到通过3个查询来解决这个问题:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="7087" class="mr lf jj mn b gy ms mt l mu mv"><strong class="mn jk">const</strong> users = <strong class="mn jk">await</strong> db.query(<br/>  sql`<br/>    <strong class="mn jk">SELECT</strong> u.user_id <strong class="mn jk">AS</strong> id, u.display_name, u.manager_id<br/>    <strong class="mn jk">FROM</strong> users u<br/>  `,<br/>);</span><span id="51af" class="mr lf jj mn b gy mw mt l mu mv"><strong class="mn jk">const</strong> userTeams = <strong class="mn jk">await</strong> db.query(<br/>  sql`<br/>    <strong class="mn jk">SELECT</strong> t.team_id <strong class="mn jk">AS</strong> id, t.display_name, ut.user_id AS user_id<br/>    <strong class="mn jk">FROM</strong> user_teams ut<br/>    <strong class="mn jk">JOIN</strong> teams t <strong class="mn jk">USING</strong> (team_id)<br/>    <strong class="mn jk">WHERE</strong> ut.user_id = <strong class="mn jk">ANY</strong>(${users.map(u =&gt; u.id)})<br/>  `,<br/>);</span><span id="3233" class="mr lf jj mn b gy mw mt l mu mv"><strong class="mn jk">const</strong> managers = <strong class="mn jk">await</strong> db.query(<br/>  sql`<br/>    <strong class="mn jk">SELECT</strong> u.user_id <strong class="mn jk">AS</strong> id, u.display_name<br/>    <strong class="mn jk">FROM</strong> users u<br/>    <strong class="mn jk">WHERE</strong> u.user_id = <strong class="mn jk">ANY</strong>(${users.map(u =&gt; u.manager_id)})<br/>  `,<br/>);</span></pre><p id="21a2" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这要高效得多，但是我们仍然需要在JavaScript领域做大量的工作来将这些结果组合成想要的嵌套结构。我们已经相当有效地获取了所有数据，但我们仍有大部分工作要做。</p><h1 id="5911" class="le lf jj bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">JSON来救援了！</h1><p id="575a" class="pw-post-body-paragraph kg kh jj ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">如果Postgres可以直接以我们想要的格式返回嵌套数据，那不是很好吗？好消息是，它可以！</p><p id="0213" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，我们需要了解一点数据类型</p><ol class=""><li id="8fb0" class="nh ni jj ki b kj kk kn ko kr nj kv nk kz nl ld nm nn no np bi translated"><code class="fe ne nf ng mn b">Record</code>数据类型，代表一行SQL数据。在顶层，所有的SQL查询都返回一个<code class="fe ne nf ng mn b">Record</code>列表。不幸的是，如果我们尝试返回嵌套的行，这些返回的是笨拙的字符串，很难解码成任何有用的东西。</li><li id="3f94" class="nh ni jj ki b kj nq kn nr kr ns kv nt kz nu ld nm nn no np bi translated"><code class="fe ne nf ng mn b">Array</code>数据类型代表一系列事物，例如JSON对象。</li><li id="ee47" class="nh ni jj ki b kj nq kn nr kr ns kv nt kz nu ld nm nn no np bi translated"><code class="fe ne nf ng mn b">JSON</code>数据类型，代表一个对象或数组。</li></ol><p id="574a" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将使用以下函数来处理所有这些类型:</p><ol class=""><li id="67a1" class="nh ni jj ki b kj kk kn ko kr nj kv nk kz nl ld nm nn no np bi translated"><code class="fe ne nf ng mn b">row_to_json</code>乘<code class="fe ne nf ng mn b">Record</code>返回<code class="fe ne nf ng mn b">JSON</code>。</li><li id="4622" class="nh ni jj ki b kj nq kn nr kr ns kv nt kz nu ld nm nn no np bi translated"><code class="fe ne nf ng mn b">array_agg</code>是一个“聚合函数”。如果您在一个<code class="fe ne nf ng mn b">SELECT</code>查询中使用它，您将得到一个包含一个<code class="fe ne nf ng mn b">Array</code>值的记录，而不是许多每个包含一个值的记录。</li><li id="74ed" class="nh ni jj ki b kj nq kn nr kr ns kv nt kz nu ld nm nn no np bi translated"><code class="fe ne nf ng mn b">array_to_json</code>取一个<code class="fe ne nf ng mn b">Array</code>(例如<code class="fe ne nf ng mn b">array_agg</code>的结果)转换成<code class="fe ne nf ng mn b">JSON</code>。</li><li id="a5a7" class="nh ni jj ki b kj nq kn nr kr ns kv nt kz nu ld nm nn no np bi translated"><code class="fe ne nf ng mn b">coalesce</code>取两个值，如果第一个值是<code class="fe ne nf ng mn b">NULL</code>则取第二个值(将其转换为第一个值的类型)。</li></ol><h2 id="fa73" class="mr lf jj bd lg nv nw dn lk nx ny dp lo kr nz oa ls kv ob oc lw kz od oe ma of bi translated">处理经理字段</h2><p id="95df" class="pw-post-body-paragraph kg kh jj ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">首先是<code class="fe ne nf ng mn b">row_to_json</code>。可以使用只返回一个值的子查询作为SQL中的字段。这里我们需要做的就是将行转换成JSON，这样我们的一个值就可以是一个复杂的对象:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="d3a7" class="mr lf jj mn b gy ms mt l mu mv"><strong class="mn jk">const</strong> results = <strong class="mn jk">await</strong> db.query(<br/>  sql`<br/>    <strong class="mn jk">SELECT</strong><br/>      u.user_id <strong class="mn jk">AS</strong> id,<br/>      u.display_name,<br/>      (<br/>        <strong class="mn jk">SELECT</strong> <em class="na">row_to_json</em>(x) <strong class="mn jk">FROM</strong><br/>        (<br/>          <strong class="mn jk">SELECT</strong> m.user_id <strong class="mn jk">AS</strong> id, m.display_name<br/>          <strong class="mn jk">FROM</strong> users m <strong class="mn jk">WHERE</strong> m.user_id = u.manager_id<br/>        ) x<br/>      ) <strong class="mn jk">AS</strong> manager<br/>    <strong class="mn jk">FROM</strong> users u<br/>  `,<br/>);</span></pre><p id="76e5" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">额外的嵌套是为了让我们可以给我们的记录一个明确的名字<code class="fe ne nf ng mn b">x</code>，并把它传递给<code class="fe ne nf ng mn b">row_to_json</code>。</p><p id="c67d" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以用一个辅助函数来解决这个问题:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="1b21" class="mr lf jj mn b gy ms mt l mu mv"><strong class="mn jk">function</strong> nestQuerySingle(query) {<br/>  <strong class="mn jk">return</strong> sql`<br/>    (<strong class="mn jk">SELECT</strong> <em class="na">row_to_json</em>(x) <strong class="mn jk">FROM</strong> (${query}) x)<br/>  `;<br/>}</span></pre><p id="d8f1" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么我们的查询变成了:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="48ca" class="mr lf jj mn b gy ms mt l mu mv"><strong class="mn jk">const</strong> results = <strong class="mn jk">await</strong> db.query(<br/>  sql`<br/>    <strong class="mn jk">SELECT</strong><br/>      u.user_id <strong class="mn jk">AS</strong> id,<br/>      u.display_name,<br/>      ${nestQuerySingle(<br/>        sql`<br/>          <strong class="mn jk">SELECT</strong> m.user_id <strong class="mn jk">AS</strong> id, m.display_name<br/>          <strong class="mn jk">FROM</strong> users m <strong class="mn jk">WHERE</strong> m.user_id = u.manager_id<br/>        `<br/>      )} <strong class="mn jk">AS</strong> manager<br/>    <strong class="mn jk">FROM</strong> users u<br/>  `,<br/>);</span></pre><blockquote class="mx my mz"><p id="1885" class="kg kh na ki b kj kk kl km kn ko kp kq nb ks kt ku nc kw kx ky nd la lb lc ld im bi translated">注意:如果管理器查询曾经返回多个记录，这将在Postgres中抛出一个错误</p></blockquote><h2 id="e70a" class="mr lf jj bd lg nv nw dn lk nx ny dp lo kr nz oa ls kv ob oc lw kz od oe ma of bi translated">管理团队</h2><p id="da85" class="pw-post-body-paragraph kg kh jj ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">现在我们已经把我们的<code class="fe ne nf ng mn b">Record</code>转换成了<code class="fe ne nf ng mn b">JSON</code>，但是我们需要解决另一个问题来处理团队。问题是一个字段中不能有多个值。这就是<code class="fe ne nf ng mn b">array_agg</code>与<code class="fe ne nf ng mn b">array_to_json</code>和<code class="fe ne nf ng mn b">coalesce</code>一起出现的地方。</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="9a82" class="mr lf jj mn b gy ms mt l mu mv"><strong class="mn jk">const</strong> results = <strong class="mn jk">await</strong> db.query(<br/>  sql`<br/>    <strong class="mn jk">SELECT</strong><br/>      u.user_id <strong class="mn jk">AS</strong> id,<br/>      u.display_name,<br/>      ${nestQuerySingle(<br/>        sql`<br/>          <strong class="mn jk">SELECT</strong> m.user_id <strong class="mn jk">AS</strong> id, m.display_name<br/>          <strong class="mn jk">FROM</strong> users m <strong class="mn jk">WHERE</strong> m.user_id = u.manager_id<br/>        `<br/>      )} <strong class="mn jk">AS</strong> manager,<br/>      <em class="na">coalesce</em>(<br/>        (<br/>          <strong class="mn jk">SELECT</strong> <em class="na">array_to_json</em>(<em class="na">array_agg</em>(<em class="na">row_to_json</em>(x)))<br/>          <strong class="mn jk">FROM</strong> (<br/>            <strong class="mn jk">SELECT</strong> t.team_id <strong class="mn jk">AS</strong> id, t.display_name<br/>            <strong class="mn jk">FROM</strong> user_teams ut<br/>            <strong class="mn jk">JOIN</strong> teams t <strong class="mn jk">USING</strong> (team_id)<br/>            <strong class="mn jk">WHERE</strong> ut.user_id = u.user_id<br/>          ) x<br/>        ),<br/>        '[]'<br/>      ) <strong class="mn jk">AS</strong> teams<br/>    <strong class="mn jk">FROM</strong> users u<br/>  `,<br/>);</span></pre><p id="9e3b" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们使用一个子查询来获取<code class="fe ne nf ng mn b">teams</code>，然后使用<code class="fe ne nf ng mn b">array_to_json(array_agg(row_to_json(x)))</code>将许多记录转换成一个单独的<code class="fe ne nf ng mn b">JSON</code>值。不幸的是，如果没有记录，Postgres将在这里返回<code class="fe ne nf ng mn b">NULL</code>，而不是<code class="fe ne nf ng mn b">[]</code>，所以我们需要使用<code class="fe ne nf ng mn b">coalesce</code>来指定一个默认值。这里默认的字符串<code class="fe ne nf ng mn b">'[]'</code>自动转换为<code class="fe ne nf ng mn b">JSON</code>以匹配<code class="fe ne nf ng mn b">array_to_json</code>的结果类型。</p><p id="d93b" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">又一个助手功能:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="dc23" class="mr lf jj mn b gy ms mt l mu mv"><strong class="mn jk">function</strong> nestQuery(query) {<br/>  <strong class="mn jk">return</strong> sql`<br/>    <em class="na">coalesce</em>(<br/>      (<br/>        <strong class="mn jk">SELECT</strong> <em class="na">array_to_json</em>(<em class="na">array_agg</em>(<em class="na">row_to_json</em>(x)))<br/>        <strong class="mn jk">FROM</strong> (${query}) x<br/>      ),<br/>      '[]'<br/>    )<br/>  `;<br/>}</span></pre><p id="21ec" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还有最后一个问题:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="6e6a" class="mr lf jj mn b gy ms mt l mu mv"><strong class="mn jk">const</strong> results = <strong class="mn jk">await</strong> db.query(<br/>  sql`<br/>    <strong class="mn jk">SELECT</strong><br/>      u.user_id <strong class="mn jk">AS</strong> id,<br/>      u.display_name,<br/>      ${nestQuerySingle(<br/>        sql`<br/>          <strong class="mn jk">SELECT</strong> m.user_id <strong class="mn jk">AS</strong> id, m.display_name<br/>          <strong class="mn jk">FROM</strong> users m <strong class="mn jk">WHERE</strong> m.user_id = u.manager_id<br/>        `<br/>      )} <strong class="mn jk">AS</strong> manager,<br/>      ${nestQuery(<br/>        sql`<br/>          <strong class="mn jk">SELECT</strong> t.team_id <strong class="mn jk">AS</strong> id, t.display_name<br/>          <strong class="mn jk">FROM</strong> user_teams ut<br/>          <strong class="mn jk">JOIN</strong> teams t <strong class="mn jk">USING</strong> (team_id)<br/>          <strong class="mn jk">WHERE</strong> ut.user_id = u.user_id<br/>        `<br/>      )} <strong class="mn jk">AS</strong> teams<br/>    <strong class="mn jk">FROM</strong> users u<br/>  `,<br/>);</span></pre><p id="259b" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这将返回与我们使用嵌套在node.js中的查询的“简单”解决方案完全相同的数据，只是现在嵌套发生在SQL中。这将更具性能，更不用说更易于维护。</p><h1 id="61ef" class="le lf jj bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="4860" class="pw-post-body-paragraph kg kh jj ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">您可能需要一些辅助函数，但是带有<code class="fe ne nf ng mn b"><a class="ae jg" href="https://www.atdatabases.org/docs/pg" rel="noopener ugc nofollow" target="_blank">@databases</a></code>的Postgres非常适合查询嵌套数据结构。如果你喜欢这篇文章，你一定要点击“关注”按钮。很快，我将写一篇关于如何执行递归查询的文章。例如，如果我想在经理层级中让每个人都在我之上(例如，我的经理、他们的经理、他们的经理……等等)，该怎么办？).</p></div></div>    
</body>
</html>