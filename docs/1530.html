<html>
<head>
<title>Make services a natural part of redux architecture</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让服务成为redux架构的自然组成部分</h1>
<blockquote>原文：<a href="https://itnext.io/make-services-a-natural-prt-of-redux-architecture-8a78b6a4b961?source=collection_archive---------0-----------------------#2018-11-17">https://itnext.io/make-services-a-natural-prt-of-redux-architecture-8a78b6a4b961?source=collection_archive---------0-----------------------#2018-11-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="2b40" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我将在这里描述的方法只不过是默认redux架构的一个小小的扩展。尽管它没有给数据流带来太多的变化，但确实做出了有意义的改进。</p><h1 id="43ab" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">我在努力实现什么？</h1><p id="f72d" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">在我使用redux的整个过程中，我一直在努力解决的主要问题是将业务逻辑放在哪里。只要您的应用程序保持简单，您可能根本不会遇到这个问题。对于相对较小的应用程序，Redux实际上做得很好。然而，随着应用程序的增长，事情开始变得有点复杂。</p><p id="6302" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，在动作创建器内部发出异步API请求。这种方法已经足够好了，除非您的API响应必须以某种方式进行解析。或者，让我们说，你得到一个数据，在它被显示之前需要一系列的转换。或者您必须发出一连串http请求来获得您需要的结果。这些迹象表明，是时候开始分离应用程序了。目标是将所有与redux flow无关的东西都移到一个单独的地方。所以我在这里展示的主要目的是定义那个地方。</p><h1 id="83fc" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">服务的理念</h1><p id="d4af" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">动作创建者应该只调度动作。如果它是一个thunk，它应该在某个地方获得数据，然后调度一个动作。动作创建者不必构建URL、发送http请求、处理响应以及人们倾向于放入其中的其他东西。这不是它们的本意。取而代之的是，我提议再加一层，把所有的都包起来。我称之为服务。</p><p id="9476" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">默认的redux数据流如下所示:</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi lo"><img src="../Images/195144d4a2ac1684afb5507a5bc0e6f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:722/format:webp/1*Kyq5MQwIR-oPIrRg1f6UkA.png"/></div><figcaption class="lw lx gj gh gi ly lz bd b be z dk translated">像我们都习惯的那样重复流动</figcaption></figure><p id="408c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我们在那里添加服务时，它看起来是这样的:</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi lo"><img src="../Images/342f0c2e96b568e256da0dc1a14b2e06.png" data-original-src="https://miro.medium.com/v2/resize:fit:722/format:webp/1*wVi15X6XA2cS3KzqDtCnGQ.png"/></div><figcaption class="lw lx gj gh gi ly lz bd b be z dk translated">使用新的服务层扩展Redux流</figcaption></figure><p id="c36f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">变化不是很大，对吗？事实证明这并不像看起来那么简单。</p><h1 id="5f05" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">再加一层需要什么？</h1><p id="35b6" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">这似乎是一项简单的任务。这在一定程度上。您可以将您的逻辑放在其他地方，而不是放在动作创建器中，然后将它导入那里以供进一步使用。</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="ma mb l"/></div><figcaption class="lw lx gj gh gi ly lz bd b be z dk translated">导入服务以在操作创建者内部使用它</figcaption></figure><p id="1f6d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">看起来不错，但是这个动作创建者根本不可测试，因为没有办法模拟服务。</p><p id="642e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这种方法不够好的第二个原因是，您可能需要在使用服务之前对其进行初始化。通常初始化需要一些时间。这个事实本身不允许你再使用这样的方法了。原因如下。</p><p id="1867" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一些服务必须异步配置的事实意味着您必须在某个地方运行配置。做的地方显然是你的应用的入口点。</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="ma mb l"/></div><figcaption class="lw lx gj gh gi ly lz bd b be z dk translated">在入口点文件中配置服务</figcaption></figure><p id="cd2a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您在这里注意到的第一件奇怪的事情是，您从入口点导出内容，这不是一件好事。这里我们忘记的另一件事是<strong class="jp ir"> configureServices </strong>必须是异步的，以便等待所有服务完成。如果您使它异步，您将根本无法导出服务。</p><h2 id="cade" class="mc km iq bd kn md me dn kr mf mg dp kv jy mh mi kz kc mj mk ld kg ml mm lh mn bi translated">那么解决办法是什么呢？</h2><p id="c291" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">让我们一次解决一个问题。如何让动作创建者可测试，并且仍然接受来自外部的服务？我打赌你听说过依赖注入。</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="ma mb l"/></div><figcaption class="lw lx gj gh gi ly lz bd b be z dk translated">src/模块/用户/操作. js</figcaption></figure><p id="b9a1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们看看这里有什么不同。我们不会立即导出动作创建者，相反，我们导出一个函数，该函数作为依赖项接收服务。现在你的动作创建者是完全可测试的。</p><p id="c264" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">尚不清楚您是否需要将您的服务注入reducers。例如，您可能希望用从某个缓存服务中取出的一些数据来填充INITIAL_STATE。你不妨想出另一个例子。</p><p id="2840" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了更加一致，我们也应该为reducers实现相同的DI包装器。</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="ma mb l"/></div><figcaption class="lw lx gj gh gi ly lz bd b be z dk translated">src/modules/user/reducer.js</figcaption></figure><p id="2690" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">只是一个普通的缩减器，但不是导出缩减器本身，而是导出一个返回它的函数。现在是时候看到更大的画面了。</p><h1 id="ef27" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">项目结构</h1><p id="f79b" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">我喜欢它的简约风格。</p><ul class=""><li id="02b2" class="mo mp iq jp b jq jr ju jv jy mq kc mr kg ms kk mt mu mv mw bi translated"><strong class="jp ir">src/组件</strong>。所有视图都存储在那里。</li><li id="dd70" class="mo mp iq jp b jq mx ju my jy mz kc na kg nb kk mt mu mv mw bi translated"><strong class="jp ir"> src/context </strong>。这是一个所有全球可用的东西都是从这里进口的地方。我们稍后会深入探讨这个问题。</li><li id="34c5" class="mo mp iq jp b jq mx ju my jy mz kc na kg nb kk mt mu mv mw bi translated"><strong class="jp ir">src/模块</strong>。所有与redux相关的东西(动作、归约器、选择器等。)</li><li id="86d5" class="mo mp iq jp b jq mx ju my jy mz kc na kg nb kk mt mu mv mw bi translated"><strong class="jp ir">服务资源中心/服务</strong>。一个适合你的商业逻辑的地方。</li></ul><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/f21fda1c456c707807c6486a241f0d9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1148/format:webp/1*pEIrPhf4LIOO5QcowyCEug.png"/></div><figcaption class="lw lx gj gh gi ly lz bd b be z dk translated">项目结构</figcaption></figure><p id="a02f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们看看入口点的内部。</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="ma mb l"/></div><figcaption class="lw lx gj gh gi ly lz bd b be z dk translated">src/index.js</figcaption></figure><p id="1e42" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们等到服务配置好，然后将它们注入模块。作为配置模块的结果，我们得到了redux store，我认为这很有意义。然后，我们呈现应用程序的视图部分。我们还使用动态导入来加载根组件，因为应用程序需要时间来初始化，所以我们必须等到这个过程结束。</p><h1 id="cc2e" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">模块</h1><p id="83c7" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">我喜欢把所有和redux有关的东西直接想成一个模块。这里我们只有一个模块——用户模块。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/8e5042b2b94f2514536c3ecf7468d996.png" data-original-src="https://miro.medium.com/v2/resize:fit:1124/format:webp/1*u8Ou1GvUzKwDJ2f6I6xxbg.png"/></div><figcaption class="lw lx gj gh gi ly lz bd b be z dk translated">模块目录，保存由文件夹划分的所有模块</figcaption></figure><p id="ebfd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如你所见，我创建了一个名为<strong class="jp ir"> user </strong>的文件夹，并将所有与用户相关的redux内容放在那里。由于这些零件彼此紧密相关，我认为将它们存放在一起是一个不错的决定。我不打算解释<strong class="jp ir"> utils </strong>里有什么，或者<strong class="jp ir"> types.js </strong>是干什么用的。我想你们可以自己解决。让我们通过<strong class="jp ir">快速浏览一下<strong class="jp ir"> index.js </strong>内部。</strong></p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="ma mb l"/></div><figcaption class="lw lx gj gh gi ly lz bd b be z dk translated">src/modules/user/index.js</figcaption></figure><p id="44d9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从这里返回的所有东西都是公共API模块。如果您想从外部访问它们，可以在这里添加类型。</p><p id="6195" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们把所有的模块集合在一起，使它们都可以从入口点进行配置(还记得我们在上面是如何调用<strong class="jp ir"> configureModules </strong>的吗)？这就是它的功能。</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="5240" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">暂时忽略“registerActions”部分，我们稍后将回到这个问题。</p><h1 id="743b" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">服务。提取业务逻辑</h1><p id="790e" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">服务是一个附加层，用于保存您的业务逻辑。你可以随意组织你的逻辑。你得到的只是一种机制，使它可以在全球范围内访问。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/9466f1c489c4462383291e75466e674a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1108/format:webp/1*TsBAcTsPMsUKfioMSc7Dtg.png"/></div><figcaption class="lw lx gj gh gi ly lz bd b be z dk translated">src/服务</figcaption></figure><p id="aff5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如我们对模块所做的那样，我们将从入口点调用<strong class="jp ir">配置服务</strong>。下面是这个函数的样子。</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="d8ae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们不打算深入研究这些特定服务的实现，因为我相信从这里很容易理解它们背后的思想。请再次忽略“注册服务”部分。</p><h1 id="a674" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">语境。事情如何全球化？</h1><p id="719e" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">让我们回忆一下入口点代码是什么样子的。</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="a1f9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在一切都要有意义。如果没有，你最好后退几步，再看一遍解释。接下来你要做的是去见登记处。</p><h2 id="a9ad" class="mc km iq bd kn md me dn kr mf mg dp kv jy mh mi kz kc mj mk ld kg ml mm lh mn bi translated">全球注册中心。</h2><p id="097d" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">注册表支持在整个应用程序中访问您的逻辑。我发布了一个实现这个概念的<a class="ae nf" href="https://www.npmjs.com/package/mag-service-registry/v/2.1.1" rel="noopener ugc nofollow" target="_blank"> npm包</a>。这个包将在以后的例子中使用，所以如果您先快速浏览一下会更好。</p><p id="43ba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以这是最难的部分。请慢慢看完这个。</p><p id="90ac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注册表解决了一个特定的问题。它允许将注册过程委托给公开注册内容的地方。听起来像胡言乱语？只是看一看。</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="ma mb l"/></div><figcaption class="lw lx gj gh gi ly lz bd b be z dk translated">src/context/actionRegistry.js</figcaption></figure><p id="d8cc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您创建一个注册表实例。然后你初始化它。因此，您会收到一个函数<strong class="jp ir">popula registry。</strong>这个函数然后被导出，它将被用来注册东西到注册表。</p><blockquote class="ng"><p id="c042" class="nh ni iq bd nj nk nl nm nn no np kk dk translated">所以这里没有注册任何东西，你把它委托给其他地方，但是最终注册的所有东西都可以从这个地方获得。</p></blockquote><p id="787d" class="pw-post-body-paragraph jn jo iq jp b jq nq js jt ju nr jw jx jy ns ka kb kc nt ke kf kg nu ki kj kk ij bi translated">这是服务注册表。字面上是一样的。</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="ma mb l"/></div><figcaption class="lw lx gj gh gi ly lz bd b be z dk translated">src/上下文/serviceRegistry.js</figcaption></figure><p id="f7d1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以这些注册表代表了上下文。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/678c3c9b929a3d41a54afac1773c0bad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1144/format:webp/1*NZBoCBtOKaVJxCKo_EW3BQ.png"/></div><figcaption class="lw lx gj gh gi ly lz bd b be z dk translated">src/上下文文件夹</figcaption></figure><p id="a532" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上下文是一个抽象概念，包含全局可用的所有内容。这是文件夹的索引文件。</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="7bc9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它只是获取注册中心已经公开的所有内容，并将其重新公开。现在，当您的应用程序的任何部分需要访问已经注册的任何内容时，它会从上下文中导入它。</p><p id="5662" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这里，组件导入动作，就像在常规redux流中一样。</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="ma mb l"/></div><figcaption class="lw lx gj gh gi ly lz bd b be z dk translated">用户组件从上下文导入操作</figcaption></figure><p id="8458" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我想我们错过了动作被注册的部分。还记得我在浏览模块时要求忽略这一部分吗？我们回去处理这件事吧。</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="ma mb l"/></div><figcaption class="lw lx gj gh gi ly lz bd b be z dk translated">在src/modules/index.js中注册操作</figcaption></figure><p id="9d6e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您对已配置的每个模块执行操作，并将其放入单个对象中。然后对象被传递给<strong class="jp ir"> registerActions </strong>。让我们看看代码。</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="ma mb l"/></div><figcaption class="lw lx gj gh gi ly lz bd b be z dk translated">src/模块/register.js</figcaption></figure><p id="129a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">PopulateActionRegistry链接到注册表实例。它只是一个包装器，为您提供访问“注册”功能。这是<strong class="jp ir">唯一一个可以注册东西的地方。您永远无法访问注册表实例本身。你可以注册东西(如这里)，或者访问已经注册的东西(如在上下文中)。从来都不是两者兼得。</strong></p><p id="1051" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">服务以同样的方式注册</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="ma mb l"/></div><figcaption class="lw lx gj gh gi ly lz bd b be z dk translated">src/services/register.js</figcaption></figure><h1 id="14b6" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">就是这样。</h1><p id="5cc9" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">我们已经检查了这个架构的所有部分。这是这个结构的样子。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/e644a40ab2075991bb35fd59bcce6911.png" data-original-src="https://miro.medium.com/v2/resize:fit:1148/format:webp/1*SA4NjFd3Rh5aNZ49mDdkmQ.png"/></div></figure><p id="35f0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个项目在<a class="ae nf" href="https://github.com/dprovodnikov/complex-redux-project-architecture" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上有。</p><p id="884a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">感谢您花时间阅读本文。让我知道你的想法。我非常感谢任何反馈。在dp.wireden@gmail.com联系我。</p></div></div>    
</body>
</html>