<html>
<head>
<title>How to migrate from Vue 2.0 to Vue 3.0 Composition API with TS (Part 2: Replace)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用TS从Vue 2.0迁移到Vue 3.0组合API(第2部分:替换)</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-migrate-from-vue-2-0-to-vue-3-0-composition-api-with-ts-part-2-replace-73606fb1b296?source=collection_archive---------1-----------------------#2019-12-22">https://itnext.io/how-to-migrate-from-vue-2-0-to-vue-3-0-composition-api-with-ts-part-2-replace-73606fb1b296?source=collection_archive---------1-----------------------#2019-12-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/5ec9f0183a0854380956eb678c67bca3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7sDKJjnuO9QyjnM7BvfDEA.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">VueFes Japan 2018尤雨溪Vue3.0更新</figcaption></figure><p id="b6bb" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">2019年10月，Vue 3.0 pre-alpha终于发布。所以用Vue 3.0做生产是迟早的事。</p><p id="c8d9" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">为了做好准备，我想分享一下如何从Vue 2.0迁移到Vue 3.0。因为现在大量的Vue用户已经引入了TypeScript，所以本文也使用TypeScript。</p><p id="3870" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">迁移有三个步骤，如下所示。</p><ol class=""><li id="a7dd" class="ld le it kh b ki kj km kn kq lf ku lg ky lh lc li lj lk ll bi translated"><a class="ae lm" href="https://medium.com/@egctoru/how-to-properly-use-vue-3-0-composition-api-with-typescript-b4bb74d2bcd8" rel="noopener">将Vue 3.0注入Vue 2.0 </a></li><li id="1df1" class="ld le it kh b ki ln km lo kq lp ku lq ky lr lc li lj lk ll bi translated"><a class="ae lm" href="https://medium.com/@egctoru/how-to-properly-use-vue-3-0-composition-api-with-typescript-part-2-usage-73606fb1b296" rel="noopener">将Vue 2.0代码替换为Vue 3.0 </a></li><li id="a405" class="ld le it kh b ki ln km lo kq lp ku lq ky lr lc li lj lk ll bi translated"><a class="ae lm" href="https://medium.com/@egctoru/how-to-migrate-from-vue-2-0-to-vue-3-0-composition-api-with-ts-part-3-create-a-global-store-aabdfa45a687" rel="noopener">使用Vue 3.0组合API创建全球商店</a></li></ol><p id="dcc5" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">因为这个话题有点长，我把它分成了3篇文章。本文是第一步的延续。如果您想从特定部分开始，请随意进入页面。</p><h1 id="ffc0" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">将Vue 2.0代码替换为Vue 3.0</h1><p id="4d5f" class="pw-post-body-paragraph kf kg it kh b ki mq kk kl km mr ko kp kq ms ks kt ku mt kw kx ky mu la lb lc im bi translated">您已经在上一篇文章的<a class="ae lm" href="https://medium.com/@egctoru/how-to-migrate-from-vue-2-0-to-vue-3-0-composition-api-with-ts-part-1-integration-b4bb74d2bcd8" rel="noopener">中设置了Vue 3.0合成API！所以让我们逐渐用Vue 3.0取代Vue 2.0代码吧！</a></p><h2 id="4210" class="mv lt it bd lu mw mx dn ly my mz dp mc kq na nb mg ku nc nd mk ky ne nf mo ng bi translated">使用createComponent和setup()而不是Vue.extend</h2><p id="c557" class="pw-post-body-paragraph kf kg it kh b ki mq kk kl km mr ko kp kq ms ks kt ku mt kw kx ky mu la lb lc im bi translated">在Vue 2.0中，“Vue.extend”用于让TypeScript正确推断Vue组件内部的类型。而不是“Vue.extend”，必须使用Vue 3.0中的createComponent进行类型推断。此外，在createComponent内部，应该使用setup函数，这是调用组合函数的入口点。</p><pre class="nh ni nj nk gt nl nm nn no aw np bi"><span id="6ade" class="mv lt it nm b gy nq nr l ns nt">// src/List.vue</span><span id="1d31" class="mv lt it nm b gy nu nr l ns nt">&lt;script lang="ts"&gt;<br/>import { createComponent } from "@vue/composition-api";</span><span id="b6c6" class="mv lt it nm b gy nu nr l ns nt">export default createComponent({<br/>  setup(){<br/>    // DO SOMETHING HERE<br/>  }<br/>})</span></pre><p id="8db7" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">但是当你把Vue.extend替换成createComponent的时候，你的编辑器出现了很多错误，因为在Vue 2.0中createComponent不知道<code class="fe nv nw nx nm b">this</code>。您在终端中有许多编译错误。</p><figure class="nh ni nj nk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ny"><img src="../Images/4c79a5a7ed7b14970cdb6d2af68cc132.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mvmvGb_Xag77uDz2L96Vsg.png"/></div></div></figure><p id="2a4c" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">但是不用担心。这个错误来自Vetur。一切正常。</p><h2 id="01a8" class="mv lt it bd lu mw mx dn ly my mz dp mc kq na nb mg ku nc nd mk ky ne nf mo ng bi translated">用reactive替换Vue 2.0“数据”</h2><p id="73ac" class="pw-post-body-paragraph kf kg it kh b ki mq kk kl km mr ko kp kq ms ks kt ku mt kw kx ky mu la lb lc im bi translated">下一步是替换Vue 2.0的本地状态，<code class="fe nv nw nx nm b">data</code>。这非常简单，使用如下设置函数中的反应。</p><pre class="nh ni nj nk gt nl nm nn no aw np bi"><span id="776e" class="mv lt it nm b gy nq nr l ns nt">// src/List.vue</span><span id="32d7" class="mv lt it nm b gy nu nr l ns nt">&lt;script lang="ts"&gt;<br/>import { FilterByEnum, Data, FilterBy } from "./types/List";<br/>import { createComponent, reactive } from "@vue/composition-api";</span><span id="95d1" class="mv lt it nm b gy nu nr l ns nt">export default createComponent({<br/>  setup(){<br/>    const todoState = reactive&lt;Data&gt;({<br/>      todos: [],<br/>      newTodo: "",<br/>      filterBy: FilterByEnum.ALL<br/>    });<br/>  }<br/>})</span></pre><p id="fe15" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><code class="fe nv nw nx nm b">reactive</code>相当于目前Vue 2.0中的Vue.observable()。从reactive返回的值是一个你喜欢的反应对象。</p><p id="977f" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">实际上，你有不同的API来使变量反应，叫做<code class="fe nv nw nx nm b">ref()</code>。但是函数本身和<code class="fe nv nw nx nm b">reactive()</code>很像。请查看它的官方文档。</p><h2 id="2cf3" class="mv lt it bd lu mw mx dn ly my mz dp mc kq na nb mg ku nc nd mk ky ne nf mo ng bi translated">替换Vue 2.0“方法”！</h2><p id="545d" class="pw-post-body-paragraph kf kg it kh b ki mq kk kl km mr ko kp kq ms ks kt ku mt kw kx ky mu la lb lc im bi translated">Vue2.0中的方法成为setup函数中的简单函数。更容易看到代码。我们先去找托多斯。</p><pre class="nh ni nj nk gt nl nm nn no aw np bi"><span id="b391" class="mv lt it nm b gy nq nr l ns nt">// src/List.vue</span><span id="fdc4" class="mv lt it nm b gy nu nr l ns nt">...<br/>import todos from "../utils/todos";</span><span id="b8ec" class="mv lt it nm b gy nu nr l ns nt">export default createComponent({<br/>  setup(){<br/>    const todoState = reactive&lt;Data&gt;({<br/>      ...<br/>    const init = function(): void {<br/>      getTodos();<br/>    };<br/>    const getTodos = function(): void {<br/>      setTimeout(() =&gt; {<br/>        todoState.todos = [...todos];<br/>    }, 1000);<br/>  }<br/>})</span></pre><p id="6ccf" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">因为不需要使用<code class="fe nv nw nx nm b">this</code>来访问本地状态，所以更简单。</p><p id="9881" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">到目前为止，您已经有了初始化todos的函数。但是你什么时候称之为？是的，您希望在Vue实例被“挂载”时这样做。<br/>当然Vue 3.0有生命周期挂钩。你应该像下面这样使用它。</p><pre class="nh ni nj nk gt nl nm nn no aw np bi"><span id="a9be" class="mv lt it nm b gy nq nr l ns nt">// src/List.vue</span><span id="f858" class="mv lt it nm b gy nu nr l ns nt">...</span><span id="a150" class="mv lt it nm b gy nu nr l ns nt">export default createComponent({<br/>  setup(){<br/>    const todoState = reactive&lt;Data&gt;({<br/>      ...<br/>    onMounted(() =&gt; {<br/>      init();<br/>    });</span><span id="d3e5" class="mv lt it nm b gy nu nr l ns nt">    const init = function(): void {<br/>      getTodos();<br/>    };</span><span id="d5b9" class="mv lt it nm b gy nu nr l ns nt">    const getTodos = function(): void {<br/>      setTimeout(() =&gt; {<br/>        todoState.todos = [...todos];<br/>    }, 1000);<br/>  }<br/>})</span></pre><p id="c8ff" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">您可以将其余方法移至内部设置功能。移动所有方法后，<code class="fe nv nw nx nm b">List.vue</code>就变成了下图这样。</p><pre class="nh ni nj nk gt nl nm nn no aw np bi"><span id="2142" class="mv lt it nm b gy nq nr l ns nt">// src/List.vue</span><span id="a30f" class="mv lt it nm b gy nu nr l ns nt">&lt;script lang="ts"&gt;<br/>import Vue from "vue";<br/>import todos from "../utils/todos";<br/>import { FilterByEnum, Data, FilterBy } from "./types/List";<br/>import { createComponent, reactive, onMounted } from "@vue/composition-api";</span><span id="823c" class="mv lt it nm b gy nu nr l ns nt">export default createComponent({<br/>  setup(props, context) {<br/>    const todoState = reactive&lt;Data&gt;({<br/>      todos: [],<br/>      newTodo: "",<br/>      filterBy: FilterByEnum.ALL<br/>    });</span><span id="695a" class="mv lt it nm b gy nu nr l ns nt">onMounted(() =&gt; {<br/>      init();<br/>    });<br/>    <br/>    const init = function(): void {<br/>      getTodos();<br/>    };<br/>    const getTodos = function(): void {<br/>      setTimeout(() =&gt; {<br/>        todoState.todos = [...todos];<br/>      }, 1000);<br/>    };<br/>    const addTodo = function(): void {<br/>      const newTodo = { name: todoState.newTodo, completed: false };<br/>      todoState.todos = [...todoState.todos, newTodo];<br/>      todoState.newTodo = "";<br/>    };<br/>    const deleteTodo = function(index: number): void {<br/>      todoState.todos = todoState.todos.filter((todo, i) =&gt; i !== index);<br/>    };<br/>    const completeTodo = function(index: number): void {<br/>      todoState.todos[index].completed = true;<br/>    };<br/>    const handleClickFilterBy = function(filterBy: FilterBy): void {<br/>      todoState.filterBy = filterBy;<br/>    };<br/>    const goEditTodo = function(index: number): void {<br/>      context.root.$router.push(`/todos/${index}/edit`);<br/>    };<br/>},</span></pre><p id="88ac" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">你还不知道的一件事是，关于设置、道具和上下文的两个论点。道具很好理解。你可以在设置功能里面得到一个道具。在上下文中，您可以检查许多在Vue 2.0的<code class="fe nv nw nx nm b">this</code>中看到的东西，如<code class="fe nv nw nx nm b">slot</code>、<code class="fe nv nw nx nm b">parent</code>和<code class="fe nv nw nx nm b">root</code>。</p><p id="5c38" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">所以如果想用<code class="fe nv nw nx nm b">$router</code>，可以从<code class="fe nv nw nx nm b">context.root</code>接入。</p><h2 id="4841" class="mv lt it bd lu mw mx dn ly my mz dp mc kq na nb mg ku nc nd mk ky ne nf mo ng bi translated">替换Vue 2.0的“计算值”</h2><p id="ccca" class="pw-post-body-paragraph kf kg it kh b ki mq kk kl km mr ko kp kq ms ks kt ku mt kw kx ky mu la lb lc im bi translated">您已经注意到，Vue2.0代码仅在computed中使用。但是也超级容易更换。</p><pre class="nh ni nj nk gt nl nm nn no aw np bi"><span id="442c" class="mv lt it nm b gy nq nr l ns nt">// src/List.vue</span><span id="7d30" class="mv lt it nm b gy nu nr l ns nt">...</span><span id="c75c" class="mv lt it nm b gy nu nr l ns nt">import { createComponent, reactive, onMounted, computed } from "@vue/composition-api";</span><span id="af40" class="mv lt it nm b gy nu nr l ns nt">export default createComponent({<br/>  setup(props, context) {<br/>    const todoState = reactive&lt;Data&gt;({<br/>      todos: [],<br/>      newTodo: "",<br/>      filterBy: FilterByEnum.ALL<br/>    });</span><span id="0443" class="mv lt it nm b gy nu nr l ns nt">    const filteredTodos = computed(function() {<br/>      return todoState.todos.filter(todo =&gt; {<br/>        if (todoState.filterBy === FilterByEnum.WORKING) {<br/>          return !todo.completed;<br/>        }<br/>        if (todoState.filterBy === FilterByEnum.DONE) {<br/>          return todo.completed;<br/>        }<br/>        return todo;<br/>    });</span><span id="ae40" class="mv lt it nm b gy nu nr l ns nt">    const numOfTodos = computed(function(): number {<br/>      return todoState.todos.filter(todo =&gt; !todo.completed).length;<br/>    });</span><span id="d5e8" class="mv lt it nm b gy nu nr l ns nt">...</span></pre><p id="d53d" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">您可以从<code class="fe nv nw nx nm b">@vue/composition-api</code>导入计算结果。就像方法一样，您可以声明computed的名称并将computed的逻辑传递给computed的参数。就是这样。</p><h2 id="7d6c" class="mv lt it bd lu mw mx dn ly my mz dp mc kq na nb mg ku nc nd mk ky ne nf mo ng bi translated">如果你想在模板中使用变量、方法</h2><p id="a0dd" class="pw-post-body-paragraph kf kg it kh b ki mq kk kl km mr ko kp kq ms ks kt ku mt kw kx ky mu la lb lc im bi translated">到目前为止，您已经将所有Vue 2.0代码替换为Vue 3.0的代码。这个todo应用程序在模板中使用了许多变量和方法，如下所示。</p><ul class=""><li id="1e1c" class="ld le it kh b ki kj km kn kq lf ku lg ky lh lc nz lj lk ll bi translated">状态<br/> -托多斯<br/> -纽多<br/> -过滤</li><li id="2405" class="ld le it kh b ki ln km lo kq lp ku lq ky lr lc nz lj lk ll bi translated">计算的<br/> -过滤的时间<br/> -数量</li><li id="7713" class="ld le it kh b ki ln km lo kq lp ku lq ky lr lc nz lj lk ll bi translated">方法<br/>-add todo<br/>-delete todo<br/>-complete todo<br/>-handleClickFilterBy<br/>-goEditTodo</li></ul><p id="7c49" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">但是如果你想在模板中使用它们，你应该怎么做呢？真的很简单。只需在设置函数中返回您需要的内容。</p><pre class="nh ni nj nk gt nl nm nn no aw np bi"><span id="9dd1" class="mv lt it nm b gy nq nr l ns nt">// src/List.vue</span><span id="7c5b" class="mv lt it nm b gy nu nr l ns nt">// Inside of template, nothing changed.</span><span id="675c" class="mv lt it nm b gy nu nr l ns nt">...</span><span id="7cbe" class="mv lt it nm b gy nu nr l ns nt">import { createComponent, reactive, onMounted, computed, toRefs } from "@vue/composition-api";</span><span id="5ac7" class="mv lt it nm b gy nu nr l ns nt">export default createComponent({<br/>  setup(props, context) {<br/>    ...<br/>    return {<br/>      ...toRefs(todoState),<br/>      filteredTodos,<br/>      numOfTodos,<br/>      addTodo,<br/>      handleClickFilterBy,<br/>      completeTodo,<br/>      goEditTodo,<br/>      deleteTodo<br/>    };<br/>  }<br/>})</span></pre><p id="311e" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">有一点你不知道的是<code class="fe nv nw nx nm b">toRefs</code>。因为当你使用<code class="fe nv nw nx nm b">reactive</code>而不使用<code class="fe nv nw nx nm b">reRefs</code>时，你必须像<code class="fe nv nw nx nm b">todoState.todos</code>、<code class="fe nv nw nx nm b">todoState.filterBy</code>一样在太阳穴内使用。但是还没干！通过<code class="fe nv nw nx nm b">toRefs()</code>和析构，你可以像以前一样使用它们。</p><p id="5cec" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">所以现在，一切正常！</p><h2 id="131f" class="mv lt it bd lu mw mx dn ly my mz dp mc kq na nb mg ku nc nd mk ky ne nf mo ng bi translated">使其可组合</h2><p id="7262" class="pw-post-body-paragraph kf kg it kh b ki mq kk kl km mr ko kp kq ms ks kt ku mt kw kx ky mu la lb lc im bi translated">到目前为止，Vue 3.0是完美的作品。但是你可以重构它。Vue 3.0组合API的主要目的是使代码可组合。这意味着代码应该被分割成小部分，并让它们反复使用。</p><p id="36f9" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">所以让我们来编写todo函数。</p><ol class=""><li id="3897" class="ld le it kh b ki kj km kn kq lf ku lg ky lh lc li lj lk ll bi translated">在导出默认值之外创建一个名为useTodos的函数。</li></ol><pre class="nh ni nj nk gt nl nm nn no aw np bi"><span id="7eb8" class="mv lt it nm b gy nq nr l ns nt">// src/List.vue</span><span id="651a" class="mv lt it nm b gy nu nr l ns nt">...</span><span id="1465" class="mv lt it nm b gy nu nr l ns nt">import { createComponent, reactive, onMounted, computed, toRefs } from "@vue/composition-api";</span><span id="c36e" class="mv lt it nm b gy nu nr l ns nt">export default createComponent({<br/>  setup(props, context) {<br/>    ...<br/>  }<br/>})</span><span id="1ea1" class="mv lt it nm b gy nu nr l ns nt">const useTodos = () =&gt; {}</span></pre><p id="9980" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">2.将设置中的功能和状态复制粘贴到<code class="fe nv nw nx nm b">useTodos</code></p><p id="de29" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">因为<code class="fe nv nw nx nm b">goEditTodo</code>有点不一样，不用动。</p><pre class="nh ni nj nk gt nl nm nn no aw np bi"><span id="a282" class="mv lt it nm b gy nq nr l ns nt">// src/List.vue</span><span id="1412" class="mv lt it nm b gy nu nr l ns nt">...</span><span id="f7e6" class="mv lt it nm b gy nu nr l ns nt">import { createComponent, reactive, onMounted, computed, toRefs } from "@vue/composition-api";</span><span id="950c" class="mv lt it nm b gy nu nr l ns nt">export default createComponent({<br/>  setup(props, context) {<br/>    const goEditTodo = function(index: number): void {<br/>      context.root.$router.push(`/todos/${index}/edit`);<br/>    };<br/>    return {<br/>      goEditTodo<br/>    };<br/>  }<br/>})</span><span id="0886" class="mv lt it nm b gy nu nr l ns nt">const useTodos = () =&gt; {<br/>  const todoState = reactive&lt;Data&gt;({<br/>    todos: [],<br/>    newTodo: "",<br/>    filterBy: FilterByEnum.ALL<br/>  });<br/>  <br/>  ...</span><span id="2e72" class="mv lt it nm b gy nu nr l ns nt">  return {<br/>    ...toRefs(todoState),<br/>    filteredTodos,<br/>    numOfTodos,<br/>    addTodo,<br/>    handleClickFilterBy,<br/>    completeTodo,<br/>    deleteTodo<br/>  }<br/>}</span></pre><p id="b203" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这个<code class="fe nv nw nx nm b">useTodos</code>函数叫做复合函数。</p><p id="20d4" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">3.调用setup里面的<code class="fe nv nw nx nm b">useTodos</code>并使用。</p><pre class="nh ni nj nk gt nl nm nn no aw np bi"><span id="4cb3" class="mv lt it nm b gy nq nr l ns nt">// src/List.vue</span><span id="c9e4" class="mv lt it nm b gy nu nr l ns nt">...</span><span id="6e5f" class="mv lt it nm b gy nu nr l ns nt">import { createComponent, reactive, onMounted, computed, toRefs } from "@vue/composition-api";</span><span id="f6ec" class="mv lt it nm b gy nu nr l ns nt">export default createComponent({<br/>  setup(props, context) {<br/>    const goEditTodo = function(index: number): void {<br/>      context.root.$router.push(`/todos/${index}/edit`);<br/>    };<br/>    <br/>    return {<br/>      ...useTodos(),<br/>      goEditTodo<br/>    };<br/>  }<br/>})</span><span id="555a" class="mv lt it nm b gy nu nr l ns nt">const useTodos = () =&gt; {<br/>  ...</span><span id="4060" class="mv lt it nm b gy nu nr l ns nt">return {<br/>    ...toRefs(todoState),<br/>    filteredTodos,<br/>    numOfTodos,<br/>    addTodo,<br/>    handleClickFilterBy,<br/>    completeTodo,<br/>    deleteTodo<br/>  }<br/>}</span></pre><p id="6359" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">现在它完美地工作了！</p><p id="943b" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">4.将合成功能分离到其他文件中。</p><p id="6780" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">因为复合函数只是一个函数，你可以很容易的把它分离出来。从Linus Borg的演示报告中，那些组合函数被保存到<code class="fe nv nw nx nm b">src/composables/</code>。并且每个组成功能的命名都像下面的<code class="fe nv nw nx nm b">useHoge</code>一样。实际上，类型文件也被移到composables下。</p><pre class="nh ni nj nk gt nl nm nn no aw np bi"><span id="d5d6" class="mv lt it nm b gy nq nr l ns nt">// composables/useTodos.ts<br/>import todos from "../utils/todos";<br/>import { FilterByEnum, Data, FilterBy } from "./types/UseTodos";<br/>import { reactive, onMounted, computed, toRefs } from "@vue/composition-api";</span><span id="3f6c" class="mv lt it nm b gy nu nr l ns nt">export const useTodos = () =&gt; {<br/>  ...<br/>};</span></pre><p id="565b" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">并导入到<code class="fe nv nw nx nm b">List.vue</code>。</p><pre class="nh ni nj nk gt nl nm nn no aw np bi"><span id="6a59" class="mv lt it nm b gy nq nr l ns nt">// src/List.vue<br/>&lt;script lang="ts"&gt;<br/>import Vue from "vue";<br/>import { createComponent } from "@vue/composition-api";<br/>import { useTodos } from "../composables/useTodos";</span><span id="cd33" class="mv lt it nm b gy nu nr l ns nt">export default createComponent({<br/>  setup(props, context) {<br/>    const goEditTodo = function(index: number): void {<br/>      context.root.$router.push(`/todos/${index}/edit`);<br/>    };<br/>    return {<br/>      ...useTodos(),<br/>      goEditTodo<br/>    };<br/>  }<br/>});<br/>&lt;/script&gt;</span></pre><p id="5d0d" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">现在，<code class="fe nv nw nx nm b">List.vue</code>超级干净。使用Compostion API，您可以将逻辑从vue组件中分离出来，vue组件可以更专注于视图。这是Vue 3.0的一大价值。</p><h2 id="534e" class="mv lt it bd lu mw mx dn ly my mz dp mc kq na nb mg ku nc nd mk ky ne nf mo ng bi translated">下一关</h2><p id="861b" class="pw-post-body-paragraph kf kg it kh b ki mq kk kl km mr ko kp kq ms ks kt ku mt kw kx ky mu la lb lc im bi translated">到目前为止，composition函数是在List.vue组件中调用的。如果在Edit.vue中调用相同的构图函数会怎样？组件之间共享状态和功能吗？？</p><p id="2c96" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">答案是“没有”。因为composition函数只是一个函数，你必须用一些东西来全局共享它们。复合功能不是Vuex那样的状态管理。</p><p id="502a" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">但是如果你使用Vue的提供和注入，你可以创建全局存储。因此，下一篇文章将解释如何使用Vue 3.0创建全球商店。</p></div><div class="ab cl oa ob hx oc" role="separator"><span class="od bw bk oe of og"/><span class="od bw bk oe of og"/><span class="od bw bk oe of"/></div><div class="im in io ip iq"><p id="0b08" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在这篇文章中，我解释了如何将Vue 2.0替换为Vue 3.0。但是这篇文章还没有谈到Vue的<code class="fe nv nw nx nm b">global store</code>。我想分享Vue 3.0全球商店的可能性，并努力实现它。</p><ol class=""><li id="1c09" class="ld le it kh b ki kj km kn kq lf ku lg ky lh lc li lj lk ll bi translated"><a class="ae lm" href="https://medium.com/@egctoru/how-to-properly-use-vue-3-0-composition-api-with-typescript-b4bb74d2bcd8" rel="noopener">将Vue 3.0注入Vue 2.0 </a></li><li id="4d72" class="ld le it kh b ki ln km lo kq lp ku lq ky lr lc li lj lk ll bi translated"><a class="ae lm" href="https://medium.com/@egctoru/how-to-properly-use-vue-3-0-composition-api-with-typescript-part-2-usage-73606fb1b296" rel="noopener">将Vue 2.0代码替换为Vue 3.0 </a>(现在在这里！)</li><li id="7acb" class="ld le it kh b ki ln km lo kq lp ku lq ky lr lc li lj lk ll bi translated"><a class="ae lm" href="https://medium.com/@egctoru/how-to-migrate-from-vue-2-0-to-vue-3-0-composition-api-with-ts-part-3-create-a-global-store-aabdfa45a687" rel="noopener">使用Vue 3.0组合API创建全球商店</a></li></ol></div></div>    
</body>
</html>