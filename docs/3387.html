<html>
<head>
<title>Overview Of NATS Streaming</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">NATS流媒体概述</h1>
<blockquote>原文：<a href="https://itnext.io/overview-of-nats-streaming-ea0e80449507?source=collection_archive---------1-----------------------#2019-12-03">https://itnext.io/overview-of-nats-streaming-ea0e80449507?source=collection_archive---------1-----------------------#2019-12-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9184" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用物联网使用案例举例说明</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/11e3047734d724e5dfe222f000294dc9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0PlF8-R6P9kRrUoRGxW_ig.png"/></div></div></figure><p id="a925" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">NATS流媒体，也称为斯坦，在NATS的基础上增加了额外的功能。在本帖中，我们将在一个演示项目中展示其中的一些。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="3b2b" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">温和的介绍</h1><p id="2f2e" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">当允许消息丢失或应用程序自己处理消息传递时，核心NATS是一个很好的解决方案，当我们需要消息持久性并确保没有消息丢失时，NATS流是一个很好的解决方案。例如，如果消费者必须接收不在线时发布的消息，这是一个很好的选择。</p><p id="1436" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">从架构的角度来看，NATS流媒体服务器是NATS的客户端，为NATS增加了持久性、消息重放和持久订阅。NATS流媒体的客户端是通过NATS与NATS流媒体服务器通信的应用程序。以下模式说明了整体架构。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mu"><img src="../Images/dd5777058232f215ac13286393b490cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ti9L2QQ5lz7CI95TwPewRA.png"/></div></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">NATS流—架构概述</figcaption></figure><p id="8e79" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意:NATS流媒体服务器嵌入了NATS服务器，但可以配置为使用现有的NATS服务器/集群</p><p id="2ce1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">正如我们从<a class="ae mz" href="https://docs.nats.io/" rel="noopener ugc nofollow" target="_blank">官方文档</a>中看到的，NATS流媒体在NATS的基础上增加了以下功能:</p><ul class=""><li id="bc9e" class="na nb it kw b kx ky la lb ld nc lh nd ll ne lp nf ng nh ni bi translated">一个增强的消息协议:NATS流媒体的客户端和服务器通过底层的NATS服务器使用<a class="ae mz" href="https://developers.google.com/protocol-buffers/" rel="noopener ugc nofollow" target="_blank">谷歌协议缓冲区</a>交换二进制消息</li><li id="da84" class="na nb it kw b kx nj la nk ld nl lh nm ll nn lp nf ng nh ni bi translated">内存、文件或数据库中的消息持久性</li><li id="ac13" class="na nb it kw b kx nj la nk ld nl lh nm ll nn lp nf ng nh ni bi translated">至少一次传递:发布到NATS流服务器的消息和传递给消费者的消息都被确认</li><li id="77af" class="na nb it kw b kx nj la nk ld nl lh nm ll nn lp nf ng nh ni bi translated">限制发布者在任何给定时间可能拥有的未确认消息数量的可能性</li><li id="e0bd" class="na nb it kw b kx nj la nk ld nl lh nm ll nn lp nf ng nh ni bi translated">可以限制已发送但未确认的消息数量。只要超过此阈值，NATS流就会暂停向订户发送消息</li><li id="4657" class="na nb it kw b kx nj la nk ld nl lh nm ll nn lp nf ng nh ni bi translated">允许新订户重播历史消息</li><li id="45c5" class="na nb it kw b kx nj la nk ld nl lh nm ll nn lp nf ng nh ni bi translated">创建持久的<em class="no">订阅的可能性，该订阅在服务器端跟踪客户端最后确认的消息序列号。对于此持久订阅，使用相同名称重新连接的客户端将被重新传送最早的未确认消息</em></li></ul><p id="020a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">NATS流使用<em class="no">通道</em>的概念来表示有序的消息集合。我们可以把一个通道想象成一个先进先出(FIFO)队列，客户端可以在这个队列中进行发布和消费。</p><h2 id="1281" class="np ly it bd lz nq nr dn md ns nt dp mh ld nu nv mj lh nw nx ml ll ny nz mn oa bi translated">客户订阅的类型</h2><p id="1399" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">订阅频道时，NATS流媒体的客户端可以使用以下订阅类型之一:</p><ul class=""><li id="8eb3" class="na nb it kw b kx ky la lb ld nc lh nd ll ne lp nf ng nh ni bi translated"><strong class="kw iu">常规</strong>订阅在创建时指定其频道位置的位置。例如，它可以指定获取频道历史记录中的所有消息，仅获取给定日期之后的消息……如果应用程序崩溃、断开连接或取消订阅，位置将丢失</li><li id="1551" class="na nb it kw b kx nj la nk ld nl lh nm ll nn lp nf ng nh ni bi translated"><strong class="kw iu">持久</strong>订阅将其位置存储在流媒体服务器中。通道位置通过断开连接来保持，并允许从先前停止的地方恢复消息使用</li><li id="1854" class="na nb it kw b kx nj la nk ld nl lh nm ll nn lp nf ng nh ni bi translated">一个<strong class="kw iu">队列</strong>订阅允许几个订阅者共享同一个频道，服务器将每条消息发送给组中的一个订阅者</li></ul><p id="cef9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于每种类型的订阅，如果订阅者在<em class="no"> ack_wait </em>参数中指定的延迟之前没有确认消息，则消息会自动重新发送(稍后将详细介绍)</p><p id="7001" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在下面的例子中，我们将考虑<em class="no">常规</em>和<em class="no">持久</em>订阅。</p><p id="1cd9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意:NATS流也被称为斯坦，我们将在这篇文章中使用这两个名字</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="1477" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">示例使用案例</h1><p id="e765" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">假设我们有一个物联网应用。位于不同位置的几个物联网设备读取温度信息，并每隔几分钟向应用程序发送一次(附带时间戳)。每个设备都以一个HTTP端点为目标，该端点对应于负责收集、解析和保存每条数据的后端服务。其他服务负责向设备发送TCP消息(重新配置命令、新固件的可用性等)。</p><p id="529d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了增强整个流程，我们决定使用NATS作为我们系统的主干，以确保不同组件之间的通信。换句话说，通过这种新的架构，设备将发布和订阅NATS，而不会直接与后端微服务通信。</p><p id="9550" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于这种新体系结构，主要要求如下:</p><p id="4fae" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">相关数据</strong></p><ul class=""><li id="9275" class="na nb it kw b kx ky la lb ld nc lh nd ll ne lp nf ng nh ni bi translated">设备在"<em class="no">设备上发布消息。ID . events</em>subject(ID是当前设备标识符)并等待来自流服务器的确认<strong class="kw iu">。</strong>此ack确保消息已被NATS流正确接收，但并不表示任何关于向潜在订户交付的信息。发送的消息示例:</li></ul><pre class="kj kk kl km gt ob oc od oe aw of bi"><span id="bb7d" class="np ly it oc b gy og oh l oi oj">{ 'ts': '2019–11–29T23:12:00Z', 'temp': '20.4' }</span></pre><ul class=""><li id="431e" class="na nb it kw b kx ky la lb ld nc lh nd ll ne lp nf ng nh ni bi translated"><em class="no">监听器</em>微服务应该订阅<em class="no">设备。*.事件</em>”因此它接收包含由它订阅的每个设备发送的温度信息的消息</li></ul><p id="f897" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">配置经理</strong></p><ul class=""><li id="8f3a" class="na nb it kw b kx ky la lb ld nc lh nd ll ne lp nf ng nh ni bi translated">负责配置设备的<em class="no">配置管理器</em>微服务在“<em class="no">设备上发布消息。ID.cfg" </em>主题。这些消息中的每一条都包含设备的配置信息。用于将发送频率(设备发送每条消息的间隔秒数)配置为60秒的消息示例:</li></ul><pre class="kj kk kl km gt ob oc od oe aw of bi"><span id="055b" class="np ly it oc b gy og oh l oi oj">{ 'ts': '2019–11–30T02:12:00Z', 'sending_frequency': '60' }</span></pre><ul class=""><li id="f2af" class="na nb it kw b kx ky la lb ld nc lh nd ll ne lp nf ng nh ni bi translated">每个设备都订阅了"<em class="no">设备。ID.cfg </em> " subject (ID是它的实际标识符)在它脱机时接收发送给它的特定消息</li></ul><p id="04d5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">发布经理</strong></p><ul class=""><li id="ef91" class="na nb it kw b kx ky la lb ld nc lh nd ll ne lp nf ng nh ni bi translated">每次有新版本时，<em class="no">发布管理器</em>微服务在“<em class="no">设备.发布”</em>主题上发布消息。发布的消息示例:</li></ul><pre class="kj kk kl km gt ob oc od oe aw of bi"><span id="f121" class="np ly it oc b gy og oh l oi oj">{ 'ts': '2019–11–30T02:12:00Z', 'version': '1.2.0'}</span></pre><ul class=""><li id="a76f" class="na nb it kw b kx ky la lb ld nc lh nd ll ne lp nf ng nh ni bi translated">每个设备订阅“<em class="no"> devices.releases </em>”主题，因此它接收由发布管理器发布的消息。收到每条消息后，设备应下载并安装新固件。在固件安装失败的情况下，我们需要将消息自动重新发送到设备，以便它可以再次尝试安装。</li></ul><p id="fb4f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">除了这些要求之外，我们还需要对通信进行TLS加密，并且每个客户端(设备或服务器端组件)都必须在系统中进行身份验证和授权。在<a class="ae mz" rel="noopener ugc nofollow" target="_blank" href="/secure-pub-sub-with-nats-fcda983d0612">上一篇文章</a>中，我们详细介绍了如何使用TLS运行NATS，并概述了NATS 2.0的authn / authz部分的特性。在这篇文章中，我们将重点关注不同类型订阅的功能部分和设置。</p><p id="ff1c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">由于设备和服务器服务可能不会总是同时在线，并且因为我们需要自动消息重新传递，所以我们将使用NATS流(又名STAN)。</p><p id="07a3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面的模式说明了上面列出的组件。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/072db4ba0243dad904ac360368889d2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p760CB-f2t1sT0yZ85HTKw.png"/></div></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">整体架构-几个发布/订阅在起作用</figcaption></figure><p id="4f6e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在让我们设置不同的组件。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="927c" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated"><strong class="ak">运行NATS流媒体服务器</strong></h1><p id="02e0" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">NATS流媒体服务器是一个GO二进制文件，可以使用以下命令下载(需要先安装<a class="ae mz" href="https://golang.org/dl/" rel="noopener ugc nofollow" target="_blank"> Golang </a>):</p><pre class="kj kk kl km gt ob oc od oe aw of bi"><span id="debb" class="np ly it oc b gy og oh l oi oj">$ go get github.com/nats-io/nats-streaming-server</span></pre><p id="d347" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">使用默认配置启动NATS流服务器非常简单，如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/b35f4e15e297aa43fa04eacc9f75d2bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lwMWtwX1LP_XZL7Ccq0GlA.png"/></div></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">运行NATS流服务器</figcaption></figure><p id="b09d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">注意</strong>:如果我们使用监控选项运行NATS流服务器(例如<em class="no"> -m 8222 </em>)，我们可以访问列出当前NATS客户端的HTTP /connz端点。我们还没有连接到NATS的任何客户，但从下面的截图，我们可以看到3个客户已经在那里。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/dccbc1d168a92909485a3e6a2c7949ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vbu0eyD7Pt-4BuQDJxErDA.png"/></div></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">NATS流媒体服务器创建的NATS客户端</figcaption></figure><p id="856a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这3个客户端(<em class="no">_ NSS-测试-集群-发送</em>、<em class="no">_ NSS-测试-集群-通用_、</em>和<em class="no">_ NSS-测试-集群-确认</em>)都是NATS实现NATS流媒体服务器功能的客户端。请记住，NATS流服务器和NATS流客户端使用底层的NATS服务器进行通信。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="81b2" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">连接NATS流媒体客户端</h1><p id="4418" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">现在让我们设置在我们上面描述的用例中定义的组件。在这个例子中，我们将使用Ruby和Python客户端，但是NATS流客户端也可用于许多其他语言(甚至用于<a class="ae mz" href="https://www.arduino.cc/" rel="noopener ugc nofollow" target="_blank"> Arduino </a>设备)</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/a04c2e3fdf65df68d4759e06b3390b32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6jKiqZbLcFf-TVEvNFGd5Q.png"/></div></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">NATS流媒体客户端支持多种语言</figcaption></figure><h2 id="ed14" class="np ly it bd lz nq nr dn md ns nt dp mh ld nu nv mj lh nw nx ml ll ny nz mn oa bi translated">处理数据</h2><p id="9296" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">让我们从<em class="no">监听器</em>微服务开始，这个监听器从它订阅的一组设备中监听新数据。下面用Python编写的代码片段说明了监听器过程:</p><pre class="kj kk kl km gt ob oc od oe aw of bi"><span id="fecc" class="np ly it oc b gy og oh l oi oj">import asyncio<br/>import signal<br/>import sys<br/>from nats.aio.client import Client as NATS<br/>from stan.aio.client import Client as STAN</span><span id="016d" class="np ly it oc b gy oo oh l oi oj">async def run(loop):<br/>    # Connect to NATS<br/>    nc = NATS()<br/>    await nc.connect(io_loop=loop)</span><span id="230c" class="np ly it oc b gy oo oh l oi oj">    # Start session with NATS Streaming cluster.<br/>    sc = STAN()<br/>    await sc.connect("test-cluster", "<strong class="oc iu">listener-3F45</strong>", nats=nc)</span><span id="23b3" class="np ly it oc b gy oo oh l oi oj">    # Callback called on each message received<br/>    async def cb(msg):<br/>        print("Received (#{}): {}".format(msg.seq, msg.data))<br/>        print("parsed and saved to db !")</span><span id="30e5" class="np ly it oc b gy oo oh l oi oj">    # Subscribe to get messages since last acknowledged<br/>    subject = "<strong class="oc iu">devices.3F45.events</strong>"<br/>    await sc.subscribe(subject, <strong class="oc iu">durable_name="3F45"</strong>, cb=cb)</span><span id="88ff" class="np ly it oc b gy oo oh l oi oj">if __name__ == '__main__':<br/>    loop = asyncio.get_event_loop()<br/>    loop.run_until_complete(run(loop))<br/>    loop.run_forever()</span></pre><p id="ffd9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里需要注意几件重要的事情:</p><ul class=""><li id="09db" class="na nb it kw b kx ky la lb ld nc lh nd ll ne lp nf ng nh ni bi translated">客户端通过指定客户端id ( <strong class="kw iu"> <em class="no">【监听器-3f 45】</em></strong>)连接到NATS流服务器，以在重新连接时识别客户端。此客户端id必须是唯一的，并且不能被几个应用程序同时使用。在这个例子中，监听器显式地订阅来自设备3F45的事件，这个标识符用在client-id中。</li></ul><p id="8f74" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意:为了增强架构，我们可以使用一个<strong class="kw iu">队列</strong>订阅，并使用几个侦听器后端的实例来处理传入的消息。对于这种类型的订阅，重新启动后客户端id不必相同，因此可以自动生成。</p><ul class=""><li id="183e" class="na nb it kw b kx ky la lb ld nc lh nd ll ne lp nf ng nh ni bi translated">在订阅期间，选项“<strong class="kw iu"> durable_name </strong>”被设置为设备ID的值，使得订阅属于类型<strong class="kw iu"> durable </strong>。这意味着频道位置存储在服务器端，并且在客户端断开一段时间的情况下可以被检索</li><li id="0167" class="na nb it kw b kx nj la nk ld nl lh nm ll nn lp nf ng nh ni bi translated"><em class="no">监听器</em>订阅了“<strong class="kw iu"><em class="no">devices . 3F45 . events</em></strong>”主题，因此它将接收设备3f 45发送的关于该主题的事件。</li></ul><p id="2a9b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意:对于长期订阅，不可能使用包含通配符的主题。这将在NATS流媒体的下一个版本Jetstream中得到改变</p><p id="90f5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在让我们考虑ID为<strong class="kw iu"> 3F45 </strong>的设备，它定期从它的一个传感器读取外部温度，并将这些信息发布到NATS流。这可以通过下面这段代码来说明(我的Python知识相当生疏，这段代码可能不是最优化的代码:-)。</p><pre class="kj kk kl km gt ob oc od oe aw of bi"><span id="e459" class="np ly it oc b gy og oh l oi oj">import asyncio<br/>import time<br/>import datetime<br/>import random<br/>import json<br/>import sys<br/>from nats.aio.client import Client as NATS<br/>from stan.aio.client import Client as STAN</span><span id="e1c9" class="np ly it oc b gy oo oh l oi oj">async def main():<br/>    # Connect to NATS<br/>    nc = NATS()<br/>    await nc.connect()</span><span id="b2d0" class="np ly it oc b gy oo oh l oi oj">    # Start session with NATS Streaming cluster.<br/>    sc = STAN()<br/>    await sc.connect("test-cluster", "<strong class="oc iu">device-3F45</strong>", nats=nc)</span><span id="c929" class="np ly it oc b gy oo oh l oi oj">    while True:<br/>        # Get timestamp and dummy temperature<br/>        now = datetime.datetime.utcnow()<br/>        ts = now.strftime("%Y-%m-%dT%H:%M:%ST")<br/>        temp = round(random.uniform(20,25), 2)</span><span id="087a" class="np ly it oc b gy oo oh l oi oj">        # Build message<br/>        msg = json.dumps({'ts': ts, 'temp': temp}).encode()</span><span id="9847" class="np ly it oc b gy oo oh l oi oj">        # Send message and wait for an ACK<br/>        async def cb(ack):<br/>            print("Received ack: {}".format(ack.guid))<br/>        await sc.publish("devices.3F45.events", msg, ack_handler=cb)</span><span id="cc5e" class="np ly it oc b gy oo oh l oi oj">        # Wait before sending next message<br/>        await asyncio.sleep(3)</span><span id="0177" class="np ly it oc b gy oo oh l oi oj">asyncio.run(main())</span></pre><p id="ba2b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里需要注意一些事情:</p><ul class=""><li id="05b7" class="na nb it kw b kx ky la lb ld nc lh nd ll ne lp nf ng nh ni bi translated">客户端使用客户端id <strong class="kw iu"> <em class="no">设备-3F45 </em> </strong>连接到NATS流媒体服务器</li><li id="5a8f" class="na nb it kw b kx nj la nk ld nl lh nm ll nn lp nf ng nh ni bi translated">客户端发布了主题为"<strong class="kw iu"><em class="no">devices . 3f 45 . events</em></strong>"的消息(该消息包含当前时间戳和随机温度)</li></ul><p id="6311" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面的动画演示了以下流程:</p><ul class=""><li id="040e" class="na nb it kw b kx ky la lb ld nc lh nd ll ne lp nf ng nh ni bi translated">监听器微服务正在运行</li><li id="2974" class="na nb it kw b kx nj la nk ld nl lh nm ll nn lp nf ng nh ni bi translated">设备发送常规消息，并接收每个消息的确认(来自STAN)</li><li id="0b18" class="na nb it kw b kx nj la nk ld nl lh nm ll nn lp nf ng nh ni bi translated">侦听器微服务已停止</li><li id="89d5" class="na nb it kw b kx nj la nk ld nl lh nm ll nn lp nf ng nh ni bi translated">该设备持续发送信息</li><li id="8eac" class="na nb it kw b kx nj la nk ld nl lh nm ll nn lp nf ng nh ni bi translated">监听器会重新启动</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/c0e7f204f7db6a8029b2100faefcc1cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*fXwzXrIlIAjgvNoRVQhyew.gif"/></div></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">收听者在持久订阅上接收设备的消息</figcaption></figure><p id="0384" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当侦听器重新联机时，它从序列号#6开始获取设备在脱机时发送的所有消息。使用持久订阅可以确保订阅者不会丢失任何消息，即使它碰巧处于脱机状态。</p><h2 id="46c9" class="np ly it bd lz nq nr dn md ns nt dp mh ld nu nv mj lh nw nx ml ll ny nz mn oa bi translated">处理配置</h2><p id="c3ad" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">让我们模拟一个专门向给定设备发布新配置的微服务。Python代码演示了这个<em class="no">配置管理器</em>服务，它发布了一个关于“<em class="no">设备. 3F45.cfg </em>主题的消息。这个消息是一个JSON对象，包含一个时间戳和<em class="no"> sending_frequency </em>，它将替换设备使用的当前值(默认为3)</p><pre class="kj kk kl km gt ob oc od oe aw of bi"><span id="eb18" class="np ly it oc b gy og oh l oi oj">require 'stan/client'<br/>require 'json'</span><span id="a76b" class="np ly it oc b gy oo oh l oi oj">sc = STAN::Client.new</span><span id="edbc" class="np ly it oc b gy oo oh l oi oj"># Get the sending frequency from a command line parameter<br/>sending_frequency = ARGV[0] || 3</span><span id="d9e7" class="np ly it oc b gy oo oh l oi oj"># Get timestamp<br/>ts = Time.now.utc.strftime('%Y-%m-%dT%H:%M:%SZ')</span><span id="d898" class="np ly it oc b gy oo oh l oi oj"># Customize connection to NATS<br/>opts = { servers: ["nats://127.0.0.1:4222"] }<br/>sc.connect("test-cluster", "configuration-manager", nats: opts)</span><span id="1504" class="np ly it oc b gy oo oh l oi oj"># Publish new configuration to device<br/>msg = {"ts":ts, 'sending_frequency':sending_frequency}<br/>sc.publish("<strong class="oc iu">devices.3F45.cfg</strong>", msg.to_json) do |guid|<br/>  puts "Received ack with guid=#{guid}"<br/>end</span><span id="ea46" class="np ly it oc b gy oo oh l oi oj"># Close connection<br/>sc.close</span></pre><p id="2408" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，让我们修改设备的应用程序代码，使其也订阅在“<em class="no"> device.3F45.cfg </em>”主题上发送给它的配置消息。代码的结构略有修改:定义了两个任务，第一个任务用于事件发送，第二个任务用于处理传入的配置消息。</p><pre class="kj kk kl km gt ob oc od oe aw of bi"><span id="9c2b" class="np ly it oc b gy og oh l oi oj">import asyncio<br/>import time<br/>import datetime<br/>import random<br/>import json<br/>import sys<br/>from nats.aio.client import Client as NATS<br/>from stan.aio.client import Client as STAN</span><span id="b9dc" class="np ly it oc b gy oo oh l oi oj">sending_frequency = 3</span><span id="d050" class="np ly it oc b gy oo oh l oi oj"># Connect to NATS Streaming<br/>nc = NATS()<br/>sc = STAN()</span><span id="a7a9" class="np ly it oc b gy oo oh l oi oj">async def sending_event():<br/>    while True:<br/>      # Get timestamp and dummy temperature<br/>      now = datetime.datetime.utcnow()<br/>      ts = now.strftime("%Y-%m-%dT%H:%M:%ST")<br/>      temp = round(random.uniform(20,25), 2)</span><span id="ddbf" class="np ly it oc b gy oo oh l oi oj">      # Build message<br/>      msg = json.dumps({'ts': ts, 'temp': temp}).encode()</span><span id="8d5e" class="np ly it oc b gy oo oh l oi oj">      # Send message and wait for an ACK<br/>      async def ac(ack):<br/>          print("Received ack: {}".format(ack.guid))<br/>      await sc.publish("devices.3F45.events", msg, ack_handler=ac)</span><span id="5754" class="np ly it oc b gy oo oh l oi oj">      # Wait before sending next message<br/>      await asyncio.sleep(sending_frequency)</span><span id="7c9b" class="np ly it oc b gy oo oh l oi oj">async def handling_cfg():<br/>    # Subscribe to cfg messages from a durable subscription<br/>    async def cb_cfg(msg):<br/>        print("cfg message #{}: {}".format(msg.seq, msg.data))<br/>        data = json.loads(msg.data.decode())<br/>        global sending_frequency<br/>        sending_frequency = int(data['sending_frequency'])</span><span id="640e" class="np ly it oc b gy oo oh l oi oj">    subject = "devices.3F45.cfg"<br/>    await sc.subscribe(subject, durable_name='3F45-cfg', cb=cb_cfg)</span><span id="54cc" class="np ly it oc b gy oo oh l oi oj">async def main():<br/>    # Connect to NATS<br/>    await nc.connect()</span><span id="c013" class="np ly it oc b gy oo oh l oi oj">    # Start session with NATS Streaming cluster.<br/>    await sc.connect("test-cluster", "device-3F45", nats=nc)</span><span id="7753" class="np ly it oc b gy oo oh l oi oj">    # Create additional tasks<br/>    event = asyncio.create_task(sending_event())<br/>    cfg = asyncio.create_task(handling_cfg())<br/>    await event<br/>    await cfg</span><span id="a510" class="np ly it oc b gy oo oh l oi oj">asyncio.run(main())</span></pre><p id="12ea" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当接收到配置消息时，设备提取sending_frequency参数并更新其当前使用的值。</p><p id="e7a1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面的动画演示了以下流程:</p><ul class=""><li id="924c" class="na nb it kw b kx ky la lb ld nc lh nd ll ne lp nf ng nh ni bi translated">设备以默认的结束频率启动(每3秒一条消息)</li><li id="3b2a" class="na nb it kw b kx nj la nk ld nl lh nm ll nn lp nf ng nh ni bi translated">配置管理器进程运行时，它发送一条消息，将发送频率更新为1秒</li><li id="ba47" class="na nb it kw b kx nj la nk ld nl lh nm ll nn lp nf ng nh ni bi translated">设备接收消息并更新其<em class="no">发送频率</em>参数</li><li id="6512" class="na nb it kw b kx nj la nk ld nl lh nm ll nn lp nf ng nh ni bi translated">配置管理器进程再次运行，它发送一条消息，将发送频率更新为5秒</li><li id="dec7" class="na nb it kw b kx nj la nk ld nl lh nm ll nn lp nf ng nh ni bi translated">该设备接收该消息并再次更新其配置</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/06b45869ba02674e8aec118a9af5e983.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*-fpHWBg_qXkQ-PvB7ww0sQ.gif"/></div></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">在持久订阅上接收配置消息的设备</figcaption></figure><h2 id="0cb2" class="np ly it bd lz nq nr dn md ns nt dp mh ld nu nv mj lh nw nx ml ll ny nz mn oa bi translated">处理释放</h2><p id="8243" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">现在让我们模拟一个微服务，用于在有新版本固件可用时提醒设备。固件是整个设备的端应用程序，固件的更新通常是一个更微妙的过程，可能需要相当长的时间。下面的Ruby代码演示了发布管理器，它发布了一个关于“<em class="no"> devices.releases </em>”主题的消息。</p><pre class="kj kk kl km gt ob oc od oe aw of bi"><span id="a531" class="np ly it oc b gy og oh l oi oj">require 'stan/client'</span><span id="aabd" class="np ly it oc b gy oo oh l oi oj"># Get the sending frequency from a command line parameter<br/>version = ARGV[0]</span><span id="dc3f" class="np ly it oc b gy oo oh l oi oj">sc = STAN::Client.new</span><span id="69a3" class="np ly it oc b gy oo oh l oi oj"># Customize connection to NATS<br/>opts = { servers: ["nats://127.0.0.1:4222"] }<br/>sc.connect("test-cluster", "release-manager", nats: opts)</span><span id="806c" class="np ly it oc b gy oo oh l oi oj"># Build message<br/>ts = Time.now.utc.strftime('%Y-%m-%dT%H:%M:%SZ')<br/>msg = {"ts":ts, 'version': version}</span><span id="d4bc" class="np ly it oc b gy oo oh l oi oj"># Publish new release version<br/>sc.publish("devices.releases", msg.to_json) do |guid|<br/>    puts "Received ack with guid=#{guid}"<br/>end</span><span id="7538" class="np ly it oc b gy oo oh l oi oj"># Close connection<br/>sc.close</span></pre><p id="06d8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">可以使用以下命令运行此代码，向所有设备发送固件1.2.0可用的信息:</p><pre class="kj kk kl km gt ob oc od oe aw of bi"><span id="5eaa" class="np ly it oc b gy og oh l oi oj">ruby releases-manager.rb 1.2.0</span></pre><p id="c6d7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">以下是发送的消息示例:</p><pre class="kj kk kl km gt ob oc od oe aw of bi"><span id="22eb" class="np ly it oc b gy og oh l oi oj">{"ts":"2019-11-30T14:50:32Z","version":"1.2.0"}</span></pre><p id="3991" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">设备现在订阅“<em class="no">devices . releases”</em>主题，以便在新固件可用时得到提醒。下面的代码片段是设备代码的更新:</p><pre class="kj kk kl km gt ob oc od oe aw of bi"><span id="db79" class="np ly it oc b gy og oh l oi oj">async def cb_rel(msg):<br/>    print("release message (seq={}): {}".format(msg.seq, msg.data))<br/>    data = json.loads(msg.data.decode())<br/>    version = data['version']<br/>    try:<br/>       print("Getting and installing firmware...")</span><span id="9a7b" class="np ly it oc b gy oo oh l oi oj">       <strong class="oc iu"># Doing the update<br/>       ...</strong></span><span id="0063" class="np ly it oc b gy oo oh l oi oj">       print("Firmware updated !")<br/>       await nc.ack(msg)<br/>    except Exception as error:<br/>       print("Error during update")<br/>       print("Update canceled")<br/>await sc.subscribe("devices.releases", durable_name='releases', cb=cb_rel, manual_acks=True, ack_wait=90)</span></pre><p id="ef59" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">此示例与在“<em class="no">devices . 3f 45 . CFG”</em>主题上完成的订阅非常相似，但由于固件更新是一个更复杂的过程，因此我们的处理方式略有不同。这里有几点需要注意:</p><ul class=""><li id="060e" class="na nb it kw b kx ky la lb ld nc lh nd ll ne lp nf ng nh ni bi translated">在"<em class="no">devices . releases</em>"<em class="no"/>主题上创建一个<strong class="kw iu">持久</strong>订阅，以确保如果设备脱机一段时间，不会丢失任何消息</li><li id="b9fb" class="na nb it kw b kx nj la nk ld nl lh nm ll nn lp nf ng nh ni bi translated">我们设置<em class="no"> ack_wait </em>来指定NATS流服务器等待从设备获得确认的秒数。由于更新过程可能需要一些时间，我们设置了一个高于默认值(30秒)的值。如果在该延迟之前没有收到ack，将尝试新的消息传递</li><li id="880f" class="na nb it kw b kx nj la nk ld nl lh nm ll nn lp nf ng nh ni bi translated">我们将<em class="no"> manual_acks </em>参数设置为<em class="no"> True </em>，以指定将手动发送交付确认。如果更新无误，则消息ack被发送到服务器(指令"<em class="no"> await nc.ack(msg) </em>")。如果更新产生错误，则在<em class="no"> ack_wait中指定的延迟后，不发送ack，触发消息重新发送。</em></li></ul><p id="5dd3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面的动画演示了在更新过程中模拟故障的以下流程</p><ul class=""><li id="5717" class="na nb it kw b kx ky la lb ld nc lh nd ll ne lp nf ng nh ni bi translated">一台设备每隔几秒钟发送一条消息(并收到对每条消息的确认)</li><li id="110e" class="na nb it kw b kx nj la nk ld nl lh nm ll nn lp nf ng nh ni bi translated">当新的1.2.0固件可用时，发布管理器在“<em class="no">设备上发送消息。发布</em></li><li id="7ca0" class="na nb it kw b kx nj la nk ld nl lh nm ll nn lp nf ng nh ni bi translated">设备接收消息，开始固件更新，但是该更新出错，并且不发送确认</li><li id="8177" class="na nb it kw b kx nj la nk ld nl lh nm ll nn lp nf ng nh ni bi translated">由于更新过程会在每次消息传递时引发错误，因此会无限期地重新传递该消息</li></ul><p id="b821" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意:<em class="no"> ack_delay </em>的较低值用于加速流程</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/ccdebf2f8bf728167c2567f5f933fc71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*MRGxnHsMW1NytqfQkK5D7g.gif"/></div></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">由于未发送送达确认，邮件已重新送达</figcaption></figure><p id="bae4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果更新最终顺利完成，并在<em class="no"> ack_wait </em>参数指定的延迟内完成，则调用指令“<em class="no"> await sc.ack(msg) </em>”向服务器发送确认。在这种情况下，不再需要重新传递消息。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="0f80" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">摘要</h1><p id="8200" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">通过对NATS流的基本使用，我希望这篇文章能让你对它的功能有一个大致的了解。Jetstream (NATS流媒体v2)正在路上，技术预览版应该很快就会发布。它的架构与NATS流媒体截然不同，因为所有的流媒体功能都将嵌入NATS本身。这将允许一些伟大的功能，也增加了流媒体处理的额外能力，其中包括:支持无法通过协议缓冲区通信的设备，创建通配符的持久订阅，…一旦有技术预览，下面的帖子将专门用于Jetsteam。</p></div></div>    
</body>
</html>