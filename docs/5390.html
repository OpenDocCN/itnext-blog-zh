<html>
<head>
<title>Exploring An OpenAPI/Swagger First Approach to Serverless Development on AWS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">探索AWS上无服务器开发的OpenAPI/Swagger First方法</h1>
<blockquote>原文：<a href="https://itnext.io/exploring-an-openapi-swagger-first-approach-to-serverless-development-on-aws-d19f0e9ca257?source=collection_archive---------0-----------------------#2021-02-23">https://itnext.io/exploring-an-openapi-swagger-first-approach-to-serverless-development-on-aws-d19f0e9ca257?source=collection_archive---------0-----------------------#2021-02-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/6a9998cf4fd82334602e9221f2eef946.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kKZT9Bw3a4Vr1bFTElA1uA.png"/></div></div></figure><p id="db81" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kw">注意:当我使用大写“S”的“无服务器”一词时，我指的是框架，而当我使用小写“S”的“无服务器”一词时，我指的是整体方法。</em></p><p id="a5f1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">自从AWS在2014年推出Lambda以来，接近零的停机时间、可扩展性和低维护开销使Lambda成为API开发的一个有吸引力的选择。如果你做过任何类型的无服务器开发，有两个框架你很可能听说过，并且可能用于开发无服务器API。那就是由T2 AWS开发的SAM-CLI T3和T4的无服务器框架T5。这些框架共享的是用AWS的API网关(以及其他AWS资源，但今天我们专注于API)构建API的声明性方法。</p><p id="c283" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您使用的是SAM，您的部分配置可能如下所示(顺便说一下，此演示的所有代码可以在<a class="ae kx" href="https://github.com/5t33/serverless-swagger-demo" rel="noopener ugc nofollow" target="_blank">这里</a>找到):</p><figure class="ky kz la lb gt jr"><div class="bz fp l di"><div class="lc ld l"/></div></figure><p id="45ca" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，如果您使用无服务器，它可能看起来像这样:</p><figure class="ky kz la lb gt jr"><div class="bz fp l di"><div class="lc ld l"/></div></figure><p id="f6c4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这些配置使用较少的样板文件集合并简化了API Gateway/Lambda设置。最后，我们有了一个看起来更接近开发人员在构建API时可能习惯的东西:一个端点列表以及它们的方法类型和查询参数。然而，对于使用API Gateway声明API，有一个许多开发人员已经熟悉的替代解决方案:OpenAPI。</p><h1 id="d69f" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">OpenAPI</h1><p id="cfe5" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">如果您曾经使用过OpenAPI(或以前称为Swagger的API规范)，您可能会注意到这些无服务器配置文件看起来与OpenAPI规范非常相似。<a class="ae kx" href="https://swagger.io/" rel="noopener ugc nofollow" target="_blank">OpenAPI的创造者Swagger.io </a>，提供了各种基于open API规范生成API的有用工具，很像Serverless/SAM如何用API Gateway生成API(Wow这可能是“API”用了2句话的时间量的记录)。API Gateway实际上也支持通过OpenAPI规范进行声明。</p><p id="aab8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一个开放的API规范看起来像这样:</p><figure class="ky kz la lb gt jr"><div class="bz fp l di"><div class="lc ld l"/></div></figure><p id="b11b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">看起来很像前面的两个例子，对吗？在这种情况下，多种工具为了类似的目的进化成了类似的格式，这种现象在软件和生物学中都存在(<a class="ae kx" href="https://www.popsci.com/story/animals/why-everything-becomes-crab-meme-carcinization/" rel="noopener ugc nofollow" target="_blank">这就是为什么一切都进化成了螃蟹</a>)。然而，虽然无服务器配置和OpenAPI看起来很相似，但OpenAPI实际上是一种更好的API声明方式。使用OpenAPI，您可以从广泛使用的规范以及内置的交互式文档中受益，除了名为<a class="ae kx" href="https://swagger.io/tools/swagger-editor/" rel="noopener ugc nofollow" target="_blank"> swagger-editor </a>的配置编辑器之外，它还附带了一个名为<a class="ae kx" href="https://swagger.io/tools/swagger-ui/" rel="noopener ugc nofollow" target="_blank"> swagger-ui </a>的类似<a class="ae kx" href="https://www.postman.com/" rel="noopener ugc nofollow" target="_blank"> Postman </a>的运行器(顺便说一下，如果您愿意，您也可以将OpenAPI规范导入Postman)。文档看起来像这样:</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mh"><img src="../Images/f02b6df3ae36f45c67b71eec61e9bd58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f4xYn6VJhr9TCdimKHM-Nw.png"/></div></div></figure><p id="b62c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">编辑器看起来有点像这样:</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mi"><img src="../Images/01affc2974e7d36ffcf41b781f692d93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g2RLwVMfA5DyLF3lMWWLtw.png"/></div></div></figure><p id="bf3b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此外，OpenAPI代码生成的许多实现都支持开箱即用的规范验证。这意味着文档和验证在同一个地方，还有上面概述的漂亮工具。我认为这是一个绝对的胜利。</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/305a101e8b559abc892ca1f1af4d4b62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/1*4dpWG3j2mVttHAyvuGobfg.jpeg"/></div></figure><p id="752d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，考虑到这一点，我将在接下来的几节中探索一种用于无服务器API开发的OpenAPI方法。</p><h1 id="b0c5" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">API设置</h1><h2 id="8f2f" class="mk lf iq bd lg ml mm dn lk mn mo dp lo kj mp mq ls kn mr ms lw kr mt mu ma mv bi translated">无服务器</h2><p id="3d69" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">经过一点试验后，很明显SAM和Serverless在OpenAPI方面都有局限性。Serverless实际上并不完全支持用OpenAPI声明您的API网关。相反，您在无服务器配置中声明OpenAPI规范的一部分以及您的端点(使用<a class="ae kx" href="https://github.com/deliveryhero/serverless-aws-documentation" rel="noopener ugc nofollow" target="_blank">无服务器-AWS-文档</a>插件)，如下所示:</p><pre class="ky kz la lb gt mw mx my mz aw na bi"><span id="8951" class="mk lf iq mx b gy nb nc l nd ne">custom:<br/>  documentation: ${file(serverless.doc.yml):documentation}<br/><br/>functions:<br/>  myFunc:<br/>    events:<br/>      - http:<br/>          path: getStuff<br/>          method: get<br/>          documentation: ${file(serverless.doc.yml):endpoints.myFunc}</span></pre><p id="0991" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">虽然这不是最糟糕的，但它要求您重新声明您的端点，这正是我试图避免的。此外，它实际上并不像API Gateway那样使用无服务器离线在本地验证您的请求。有一个名为<a class="ae kx" href="https://github.com/RafPe/serverless-reqvalidator-plugin#readme" rel="noopener ugc nofollow" target="_blank">serverless-req validator-plugin</a>的包，但是它要求你在server less文件中声明你的验证器，而不是在OpenAPI中，这又一次违背了目的，并且不允许使用swagger工具。</p><h2 id="28a5" class="mk lf iq bd lg ml mm dn lk mn mo dp lo kj mp mq ls kn mr ms lw kr mt mu ma mv bi translated">地对空导弹</h2><p id="3b84" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">SAM更好一点，它允许您用OpenAPI配置简单地声明整个API，就像这样:</p><pre class="ky kz la lb gt mw mx my mz aw na bi"><span id="7594" class="mk lf iq mx b gy nb nc l nd ne">Resources:<br/>  Api:<br/>    Type: AWS::Serverless::Api<br/>    Properties:<br/>      Name:<br/>        Fn::Sub: ${AppName}-api-${Stage}<br/>        StageName: !Ref Stage<br/>        DefinitionBody:<br/>          Fn::Transform:<br/>            Name: AWS::Include<br/>            Parameters:<br/>              Location: swagger.yml</span></pre><p id="3d9a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这也适用于SAM的本地命令<code class="fe nf ng nh mx b">start api</code>。您仍然必须在SAM配置中声明函数，但是没有太多的方法可以绕过它，所以我不认为这是太多的重复工作。然而，SAM并不在本地验证您的输入，正如2018年 发布的这个<em class="kw"> </em> <a class="ae kx" href="https://github.com/aws/aws-sam-cli/issues/364" rel="noopener ugc nofollow" target="_blank"> <em class="kw">所证明的。一旦他们开始考虑，我很高兴这能作为一个特性被包括进来。</em></a></p><p id="ab36" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">无论如何，在这篇文章的剩余部分，我将使用SAM来构建和部署我的API。我希望能够通过编写针对OpenAPI验证器的测试来解决缺少本地验证的问题。考虑到我无论如何都会编写测试来反对我的验证，这没什么大不了的。虽然为了确保我的验证器符合API Gateway(应该是这样，但是谁知道呢)，验收测试将是至关重要的，这也是我会做的事情，但是将这些测试从集成(针对验证器包)转换为验收(针对部署的API)将需要一些逻辑。不管怎样，我们开始吧。</p><h2 id="4fa4" class="mk lf iq bd lg ml mm dn lk mn mo dp lo kj mp mq ls kn mr ms lw kr mt mu ma mv bi translated">OpenAPI配置</h2><figure class="ky kz la lb gt jr"><div class="bz fp l di"><div class="lc ld l"/></div></figure><p id="4384" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这创建了一个名为<code class="fe nf ng nh mx b">/testFunc</code>的端点，它接受一个必需的字符串参数。它还通过<code class="fe nf ng nh mx b">x-amazon-apigateway-request-validator</code>设置请求验证。这种验证通常需要在另一个CloudFormation资源中进行设置。<strong class="ka ir">这里需要注意的一点</strong>是读取<code class="fe nf ng nh mx b">POST</code>的<code class="fe nf ng nh mx b">httpMethod</code>参数和读取<code class="fe nf ng nh mx b">get:</code>的OpenAPI配置方法键之间的差异。这样做的原因是，当使用lambda函数与API Gateway集成时，您必须将POST列为httpMethod，即使端点类型是GET。这不会影响你调用API的方式，只会改变API Gateway与lambda的交互方式。我认为文档会更大声地喊出来，但是你可以在OpenAPI扩展文档的“httpMethod”属性<a class="ae kx" href="https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-swagger-extensions-integration.html" rel="noopener ugc nofollow" target="_blank">和这个</a><a class="ae kx" href="https://docs.aws.amazon.com/apigateway/latest/developerguide/integration-request-basic-setup.html" rel="noopener ugc nofollow" target="_blank">例子</a>中找到它。</p><p id="af52" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">顺便说一下，关于OpenAPI扩展这个话题，<code class="fe nf ng nh mx b">x-amazon-apigateway-request-validator</code>实际上是AWS提供的众多<a class="ae kx" href="https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-swagger-extensions.html" rel="noopener ugc nofollow" target="_blank"> OpenAPI扩展</a>中的一个，用于声明API网关资源或配置，比如<code class="fe nf ng nh mx b">x-amazon-apigateway-any-method-object</code>、<code class="fe nf ng nh mx b">x-amazon-apigateway-auth</code>和<code class="fe nf ng nh mx b">x-amazon-apigateway-cors</code>。这些应该给了你用OpenAPI声明API网关所需要的一切。</p><p id="575c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，SAM配置将使用OpenAPI配置:</p><figure class="ky kz la lb gt jr"><div class="bz fp l di"><div class="lc ld l"/></div></figure><p id="b81c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个SAM配置将设置API和相应的启用X射线跟踪的函数(要了解更多关于X射线的信息，请查看<a class="ae kx" rel="noopener ugc nofollow" target="_blank" href="/a-deep-dive-into-serverless-tracing-with-aws-x-ray-lambda-5ff1821c3c70?source=your_stories_page-------------------------------------">这个深度剖析</a>)。此外，该配置还设置了“MethodSettings”和AccessLogSetting配置值，这两个值分别打开API网关的日志记录并格式化登录到JSON的日志。</p><p id="7e27" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，运行<code class="fe nf ng nh mx b">sam local start-api</code>:</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ni"><img src="../Images/99e7796b3cccc4560dbbf54b72de5231.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0SJrMb8iCmPh6FUrefqmmg.png"/></div></div></figure><p id="3141" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我可以弯曲我的端点:</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nj"><img src="../Images/6b9ec31be1b0bac74b17b58a4d712476.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Dy5dEYOpet_nR3z3WqUZkQ.png"/></div></div></figure><p id="098a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">太好了，有用。这证明我们可以使用OpenAPI配置在本地运行API网关配置，但是，正如您所看到的，请求没有被验证(配置指定了一个名为testQuery的查询参数)。我前面提到的是SAM的一个当前问题，因此需要进行一些测试来填补空白。现在开始部署。</p><h1 id="b529" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">部署</h1><p id="100e" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">要开始这个演示API的部署，运行:</p><pre class="ky kz la lb gt mw mx my mz aw na bi"><span id="e607" class="mk lf iq mx b gy nb nc l nd ne">sam deploy -t sam.yml --guided</span></pre><p id="58a5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">初始部署后，您可以运行不带<code class="fe nf ng nh mx b">--guided</code>标志的命令，假设您选择了将部署配置保存到默认的名为<code class="fe nf ng nh mx b">samconfig.toml</code>的本地文件。</p><p id="d117" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在已经部署了API，您应该能够在AWS中导航到API网关控制台的“dashboard”部分来找到您的端点，然后测试它:</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nk"><img src="../Images/00cdcdd4cbd0ae7d9cccf4d1da4fb1fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aMabCa5bUz2OU-FgDwjLQA.png"/></div></div></figure><p id="8435" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">结果很好。我们可以看到，OpenAPI JSON-schema验证虽然在SAM中本地不可用，但一旦部署，它就可以按预期工作。现在让我们看看，一旦提供了变量，它是否正确地连接到Lambda:</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nl"><img src="../Images/117ceff290c33745adfbcf62ae4863fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XSIt6j_k6Tr8gKQ8Q5waAg.png"/></div></div></figure><p id="3bfc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">哈。这是不对的。让我们来看看可能是什么问题。在控制台中使用API Gateway test选项进行测试后，我看到了以下日志(这些日志是可用的，因为它们是在SAM配置中打开的):</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/0d46ec9b4eb575c8740962a1400e5724.png" data-original-src="https://miro.medium.com/v2/resize:fit:1366/format:webp/1*CLR_pKAtW1sigjD0sHum1A.png"/></div></figure><p id="f22f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">看起来API没有权限与lambda对话。经过一点试验，我注意到了用SAM声明API和用OpenAPI配置声明API之间的重要区别。当与SAM一起部署时，您的lambdas将被提供一个资源策略，看起来像这样:</p><pre class="ky kz la lb gt mw mx my mz aw na bi"><span id="e55b" class="mk lf iq mx b gy nb nc l nd ne">{<br/>  "Version": "2012-10-17",<br/>  "Id": "default",<br/>  "Statement": [<br/>      {<br/>        "Sid": "demo-swagger-sam-TestFunctionTestFucPermissionProd-1LLU5CLKO2NJ0",<br/>        "Effect": "Allow",<br/>        "Principal": {<br/>          "Service": "apigateway.amazonaws.com"<br/>        },<br/>        "Action": "lambda:InvokeFunction",<br/>        "Resource": "arn:aws:lambda:us-east-2:01234567890:function:demo-swagger-sam-test-func-dev",<br/>        "Condition": {<br/>        "ArnLike": {<br/>          "AWS:SourceArn": "arn:aws:execute-api:us-east-2:01234567890:4gic1pfddb/*/GET/testFunc"<br/>        }<br/>      }<br/>    }<br/>  ]<br/>}</span></pre><p id="cfc0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，当使用OpenAPI配置进行部署时，lambda资源策略(位于Lambda控制台的“permissions”选项卡下)是空的。这(再次)得到了open API<a class="ae kx" href="https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-swagger-extensions-integration.html" rel="noopener ugc nofollow" target="_blank">x-Amazon-API gateway-integration</a>扩展文档的认可，在“凭证”部分:</p><p id="9c5a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于基于AWS IAM角色的凭据，请指定适当IAM角色的ARN。<strong class="ka ir">如果未指定，凭证默认为基于资源的权限，这些权限必须手动添加，以允许API访问资源</strong>。有关更多信息，请参见<a class="ae kx" href="https://docs.aws.amazon.com/lambda/latest/dg/intro-permission-model.html#intro-permission-model-access-policy" rel="noopener ugc nofollow" target="_blank">使用资源策略授予权限</a>。”</p><p id="3129" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，我们的选择是要么给每个lambda添加一个资源策略，允许API网关资源调用它们，要么给API网关添加一个执行角色，允许调用我们的每个lambda。我更喜欢第二个选项，因为它将被本地化为一个资源。为此，我将向SAM配置中添加以下IAM角色和策略资源:</p><figure class="ky kz la lb gt jr"><div class="bz fp l di"><div class="lc ld l"/></div></figure><p id="c32d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它将通过x-Amazon-API gateway-integration选项在OpenAPI规范中使用，如下所示:</p><pre class="ky kz la lb gt mw mx my mz aw na bi"><span id="7506" class="mk lf iq mx b gy nb nc l nd ne">x-amazon-apigateway-integration:<br/>  credentials:<br/>    Fn::Sub: ${ApiRole.Arn}</span></pre><p id="9bf9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，在重新部署API并使用预期的查询参数调用测试端点之后，我看到了预期的输出:</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nn"><img src="../Images/f066fdad2cef4d86fe805adb2d58e842.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jmZNP6hHy8eADy_PE4Swtg.png"/></div></div></figure><p id="dd26" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们来看看这个大摇大摆的工具。</p><h1 id="a04b" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">工具作业</h1><h2 id="7a2c" class="mk lf iq bd lg ml mm dn lk mn mo dp lo kj mp mq ls kn mr ms lw kr mt mu ma mv bi translated">招摇的编辑</h2><p id="3f50" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">要运行编辑器，这里有docker映像和npm包<a class="ae kx" href="https://swagger.io/docs/open-source-tools/swagger-editor/" rel="noopener ugc nofollow" target="_blank">的说明。我将使用docker图像。要启动并运行它，请运行以下命令:</a></p><pre class="ky kz la lb gt mw mx my mz aw na bi"><span id="fc94" class="mk lf iq mx b gy nb nc l nd ne">docker run -p 8080:8080 -v $(pwd):/tmp -e SWAGGER_FILE=/tmp/swagger.yml swaggerapi/swagger-editor</span></pre><p id="5985" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个<em class="kw">应该</em>在端口8080上使用我的本地OpenAPI规范(swagger.yml)启动swagger编辑器。</p><p id="0dec" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">祝成功！</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi no"><img src="../Images/a1ca20646b5d9f04dc967d90cc785922.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_phqP446W2LR4RXWIxfgqA.png"/></div></div></figure><p id="1d35" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从上图可以看出，swagger编辑器能够解释OpenAPI配置。而且，它甚至理解API网关扩展:</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi np"><img src="../Images/72b4c486b905853865459f5df1af7c6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p5gqg5W1cat_7BDq2tdq-g.png"/></div></div></figure><p id="f1fd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以这很酷。为了说明这是如何工作的，我将通过UI更新swagger以包含一个新的端点。首先，单击“insert ”,弹出如下下拉菜单:</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/0495ed8b60e50cbd5df1ff8919113da7.png" data-original-src="https://miro.medium.com/v2/resize:fit:848/format:webp/1*HgvsHRDH-hgcpYcicIISOA.png"/></div></figure><p id="b761" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从中选择“添加路径项”，弹出一个对话框:</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nr"><img src="../Images/1cb916361fde69ce4d1fa5e20c73cb70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tAKTmj8tRhd0AuCKRsZ12g.png"/></div></div></figure><p id="f1a0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我可以填写它来插入一个新路径。在这之后，我将能够添加一个操作，信息等。我觉得奇怪的一点是，它没有给我添加任何模式的选项。“components”和“schemas”部分可能必须已经存在才能编辑，这很奇怪，所以我将尝试添加一些随机模式，如下所示:</p><figure class="ky kz la lb gt jr"><div class="bz fp l di"><div class="lc ld l"/></div></figure><p id="8969" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这导致模式在右侧列出:</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ns"><img src="../Images/d1d9b664907498b22b6b9fae59abdbfc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uFeeWQ9HeBlh9-JUZFynOw.png"/></div></div></figure><p id="425b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是仍然没有通过“插入”按钮向OpenAPI规范添加组件和/或模式的选项。这有点烦人，但我可能只是打算手工编辑swagger规范，所以编辑器更像是一个“好东西”。也就是说，看起来<a class="ae kx" href="https://app.swaggerhub.com/" rel="noopener ugc nofollow" target="_blank"> swaggerhub </a>给了你一个不同版本的编辑器，允许添加模式等(你可以看到左边“模式”旁边的小“+”开关):</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nt"><img src="../Images/23b09ab990fc4915724549f24aa1d578.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xq-qCcYQxObDsEvGK_Fa-g.png"/></div></div></figure><p id="78e1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，出于某种原因，您不能使用swaggerhub编辑器添加端点。此外，图像实际上并不允许你保存到你的招摇规格的位置。所以看起来用GUI编辑文档是不可能的，所以从现在开始我将只手动编辑它。</p><p id="5001" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，让我们来看看更重要的一点，大摇大摆的UI:</p><h2 id="25ce" class="mk lf iq bd lg ml mm dn lk mn mo dp lo kj mp mq ls kn mr ms lw kr mt mu ma mv bi translated">Swagger UI</h2><p id="eb0e" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">swagger UI比编辑器更重要一点，因为它将被用作实时文档。因此，与作为本地使用的实用程序启动的编辑器相反，UI将需要与API一起部署。这在本地也有帮助，因为它将运行在同一个端口上，这将避免调用端点时的cors错误(这是可以解决的，但为什么要这么麻烦呢？).</p><p id="7b60" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了部署UI，我将使用<a class="ae kx" href="https://www.npmjs.com/package/express" rel="noopener ugc nofollow" target="_blank"> express </a>以及<a class="ae kx" href="https://www.npmjs.com/package/swagger-ui-express" rel="noopener ugc nofollow" target="_blank"> swagger-ui-express </a>包和<a class="ae kx" href="https://www.npmjs.com/package/@vendia/serverless-express" rel="noopener ugc nofollow" target="_blank">@ vendia/server less-express</a>(这是现已贬值的<a class="ae kx" href="https://www.npmjs.com/package/aws-serverless-express" rel="noopener ugc nofollow" target="_blank"> aws-serverless-express包</a>的新位置)。λ会是这样的:</p><figure class="ky kz la lb gt jr"><div class="bz fp l di"><div class="lc ld l"/></div></figure><p id="bdec" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了添加这个新函数，我将向我的OpenAPi配置添加两个额外的路径:</p><figure class="ky kz la lb gt jr"><div class="bz fp l di"><div class="lc ld l"/></div></figure><p id="3169" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">除了更新swagger配置以包含这个新功能之外:</p><figure class="ky kz la lb gt jr"><div class="bz fp l di"><div class="lc ld l"/></div></figure><p id="5da4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">并添加到ApiRole策略的“资源”部分，以包含两个lambda ARNs:</p><figure class="ky kz la lb gt jr"><div class="bz fp l di"><div class="lc ld l"/></div></figure><p id="7e93" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我可以运行<code class="fe nf ng nh mx b">sam local start-api -t sam.yml</code>并访问<code class="fe nf ng nh mx b">localhost:3000/docs</code>来查看输出:</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nu"><img src="../Images/a7cac0baf62f05e2f2dc3ac833f137cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q0z2Ax0ztmtn8Ns4DncILQ.png"/></div></div></figure><p id="bc62" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了更好地理解这一点，<code class="fe nf ng nh mx b">/docs</code>路径将把请求指向前面讨论过的docs.js lambda函数。然而，第二个选项列在名为<code class="fe nf ng nh mx b">/{proxy+}</code>的<code class="fe nf ng nh mx b">/docs</code>选项下。如果您以前没有看到过<code class="fe nf ng nh mx b">{proxy+}</code>选项，这是一个针对全包路由的特定于API网关的配置(用于代理服务，例如express)。原因是swagger-ui-express中间件实际上服务于一组静态资源，这些资源通过调用“/docs”来重定向。</p><p id="ca03" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如您在网络输出中看到的:</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nv"><img src="../Images/a559004030db20a20a308dd7f00a81e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jc24-4pFgWRVTyDtdPRk5A.png"/></div></div></figure><p id="3b25" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是，由于这个代理选项会将所有请求发送到您的/docs端点，如果它们没有明确地(没有双关的意思)匹配您的API网关的任何其他端点，那么将404 catch-all添加到docs.js将是一个好主意。我的印象是，人们可以像这样设置代理:<code class="fe nf ng nh mx b">/docs/{proxy+}</code>，因此只有沿着某个路径的代理请求(以便API网关可以处理404/403)，但是从测试来看，这似乎实际上是不可能的。</p><p id="0efd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">无论如何，在部署之后，我们应该能够从我们的API中得到同样的东西:</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nw"><img src="../Images/180f788fcd5682a6b2d9acca58d04ebf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s5NtjmM-DWVdIK96UoeoHA.png"/></div></div></figure><p id="8494" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">哎呀。我猜不会。</p><p id="142d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是由于API Gateway和Express的交互作用。API Gateway在API前面加上“/dev”，Express API从“/dev/docs”重定向到“/docs/”来检索静态资产。因为“/dev”不是基本url的一部分，所以浏览器会将“/dev”作为重定向的一部分删除，如下所示:</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nx"><img src="../Images/a27154ded766a2f5c4dc10efa6056880.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qxBCzm0k2imwXr4WXeIV2w.png"/></div></div></figure><p id="4377" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">虽然这很烦人，但实际上这不是一个大问题，因为如果它作为一个真正的API运行，它可能会有一个自定义域名，所以这不会是一个问题。“/docs”重定向将导航到自定义域的基础，它不会在前面加上“dev”。为了解决这个问题，我将在Route53中创建一个快速域，在ACM中创建一个证书，然后将它们添加到SAM API资源配置中，如下所示:</p><pre class="ky kz la lb gt mw mx my mz aw na bi"><span id="1953" class="mk lf iq mx b gy nb nc l nd ne">Domain:<br/>  CertificateArn: arn:aws:acm:us-east-2:0123456789012:certificate/&lt;cert-id&gt;<br/>  DomainName: "serverless-swagger-demo.com"<br/>  Route53:<br/>    DistributionDomainName: serverless-swagger-demo.co<br/>    HostedZoneId: &lt;zone-id&gt;</span></pre><p id="866d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我可以通过新域查看docs端点:</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ny"><img src="../Images/f1ab0848c78d786368472b4cac645cdd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FSxeqXDIhjXMv-7bleQvIA.png"/></div></div></figure><p id="3b2b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你一直跟着做，你会注意到裸域<code class="fe nf ng nh mx b"><a class="ae kx" href="https://serverless-swagger-demo" rel="noopener ugc nofollow" target="_blank">https://</a>your-domain</code>不起作用。不幸的是，您需要实际包含<code class="fe nf ng nh mx b">www.</code>。我确定我要么错误地配置了SAM配置(或者SAM配置不处理它，这不会让我吃惊)，要么我只需要添加一个CNAME来重定向到根<code class="fe nf ng nh mx b">www.</code>记录。然而，这并不是这篇文章的真正目的，所以我不会为此担心。</p><p id="1d78" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">文档发布后，您可以试用您的端点并从UI查看模式:</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nz"><img src="../Images/e7c2002f12c443d3ced247aab99d8d07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7Fd_BsMgT0RO3anqBWtduQ.png"/></div></div></figure><p id="d711" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">作为内务处理的最后一点，值得注意的是，您可能不希望这些文档公开，因此您可能希望使用API Gateway的<a class="ae kx" href="https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-private-apis.html" rel="noopener ugc nofollow" target="_blank">私有API </a>选项。然而，API Gateway不允许只公开API的一部分，所以您的文档必须由单独的API提供。这需要对cors进行一些调整，以便从文档中实际调用您的端点。或者，你可以在你的文档前面放置一个cognito authorizer，就像这篇文章中的<a class="ae kx" href="https://betterdev.blog/serverless-swagger-ui-for-api-gateway/" rel="noopener ugc nofollow" target="_blank">所做的那样(作者决定部署到s3，而不是为SwaggerUI使用API Gateway，但这并没有太大的区别)。</a></p><h1 id="075d" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">测试</h1><p id="766b" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">正如我前面提到的，如果不能用<code class="fe nf ng nh mx b">sam local start-api</code>手动测试验证，那么编写测试来检查验证是否正常工作就显得格外重要。为此，我将针对express OpenAPI验证器插件编写测试(具体来说就是<a class="ae kx" href="https://www.npmjs.com/package/express-openapi-validator" rel="noopener ugc nofollow" target="_blank">这个</a>)并使用<a class="ae kx" href="https://www.npmjs.com/package/supertest" rel="noopener ugc nofollow" target="_blank"> Supertest </a>，就好像我正在集成测试一个常规的express API一样。理论上验证OpenAPI模式只是JSON验证，所以API Gateway和任何验证器包应该返回相同的结果。也就是说，在部署API之后，运行与验收测试相同的测试将有助于确保这一点。</p><p id="f144" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我用<a class="ae kx" href="https://www.npmjs.com/package/jest" rel="noopener ugc nofollow" target="_blank"> Jest </a>快速拼凑的这段代码片段应该能让你大致了解它是如何工作的:</p><figure class="ky kz la lb gt jr"><div class="bz fp l di"><div class="lc ld l"/></div></figure><p id="5230" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如您所看到的，无论请求是针对本地Supertest还是带有Axios的远程API，在“请求”函数中都进行了一些转换，以使输出正常化。通过这种方式，可以使用以下命令将它们作为集成测试在本地运行:</p><pre class="ky kz la lb gt mw mx my mz aw na bi"><span id="2571" class="mk lf iq mx b gy nb nc l nd ne">stage=dev_local jest ./test/integration/* --testTimeout 10000</span></pre><p id="02be" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">或者可以使用以下命令对远程api运行相同的测试作为验收测试:</p><pre class="ky kz la lb gt mw mx my mz aw na bi"><span id="39aa" class="mk lf iq mx b gy nb nc l nd ne">base_url=https://www.serverless-swagger-demo.com stage=dev jest ./test/integration/* --testTimeout 10000</span></pre><p id="4fa5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">像这样:</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oa"><img src="../Images/c0594d1d4eb16fac5a221a302f45d3ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kgTsSqIcUGFCPeFbBoco0w.png"/></div></div></figure><p id="1ed1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我添加了一个包罗万象的“200”响应，但是您可能需要添加额外的选项来模拟您将从实际API收到的响应，例如201、301等。</p><h1 id="8e14" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="3309" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">我希望这篇文章让你考虑用OpenAPI声明你的无服务器API，而不是使用Severless/SAM配置选项。通过添加Swagger UI和API Gateway的内置验证，这似乎是一种很有吸引力的方法。有一些gotchyas，但没有一个看起来不方便，足以阻止我在未来走这条路。一旦SAM CLI实现了验证，编写测试和根据OpenAPI声明进行本地测试将变得更加容易。如果你对这篇文章的内容、无服务器开发或者软件开发有任何疑问，请随时通过linkedin联系我。</p></div></div>    
</body>
</html>