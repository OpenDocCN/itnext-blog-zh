<html>
<head>
<title>Kubernetes Journey — Up and running out of the cloud — Technology Stack</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes之旅—启动并运行云技术堆栈</h1>
<blockquote>原文：<a href="https://itnext.io/kubernetes-journey-up-and-running-out-of-the-cloud-technology-stack-9c472aafac4e?source=collection_archive---------3-----------------------#2019-05-15">https://itnext.io/kubernetes-journey-up-and-running-out-of-the-cloud-technology-stack-9c472aafac4e?source=collection_archive---------3-----------------------#2019-05-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/40db02e621af621aaaff6978db5ed124.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wEJTqa3uwwxZ2k65u4ZnfQ.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">凯文·Ku在<a class="ae kc" href="https://unsplash.com/search/photos/network-architecture?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure></div><div class="ab cl kd ke hu kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ij ik il im in"><p id="328f" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">在本文中，我们将介绍将成为我们技术堆栈一部分的每个组件。我强烈建议您通过参考链接更好地理解每个组件的作用以及它们如何适应我们的架构。</p><p id="8131" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">在<a class="ae kc" href="https://medium.com/@mtvallim/kubernetes-journey-up-and-running-out-of-the-cloud-architecture-overview-e75763b54922" rel="noopener">的上一篇文章</a>中，我们看了一下我们解决方案的架构，并介绍了集群的概念及其最常见的类型。</p><p id="7d06" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">这些文章是我们<a class="ae kc" href="https://medium.com/@mtvallim/kubernetes-journey-up-and-running-out-of-the-cloud-introduction-f04a811c92a5" rel="noopener"> Kubernetes之旅</a>的一部分。我希望您对深入研究如何从云中安装和配置Kubernetes感到兴奋！</p></div><div class="ab cl kd ke hu kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ij ik il im in"><p id="6e44" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">如果你不想等到所有的文章都发表了，又想马上动手，可以随意克隆项目的Github repo。它完全实用，文档也在不断改进:</p><div class="li lj gp gr lk ll"><a href="https://github.com/mvallim/kubernetes-under-the-hood" rel="noopener  ugc nofollow" target="_blank"><div class="lm ab fo"><div class="ln ab lo cl cj lp"><h2 class="bd ir gy z fp lq fr fs lr fu fw ip bi translated">罩下的姆瓦利姆/库伯内特斯</h2><div class="ls l"><h3 class="bd b gy z fp lq fr fs lr fu fw dk translated">本教程是有人计划安装一个Kubernetes集群，并希望了解一切如何配合在一起…</h3></div><div class="lt l"><p class="bd b dl z fp lq fr fs lr fu fw dk translated">github.com</p></div></div><div class="lu l"><div class="lv l lw lx ly lu lz jw ll"/></div></div></a></div></div><div class="ab cl kd ke hu kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ij ik il im in"><h1 id="bfa6" class="ma mb iq bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated">HAProxy</h1><p id="c818" class="pw-post-body-paragraph kk kl iq km b kn my kp kq kr mz kt ku kv na kx ky kz nb lb lc ld nc lf lg lh ij bi translated"><em class="nd">“ha proxy是一款免费、非常快速和可靠的解决方案，为基于TCP和HTTP的应用程序提供高可用性、负载平衡和代理。它特别适用于高流量的网站，并为世界上许多访问量最大的网站提供支持。多年来，它已经成为事实上的标准开源负载平衡器，现在与大多数主流Linux发行版一起提供，并且通常默认部署在云平台中。因为它不做广告，我们只知道它在管理员报告时被使用:-)" </em></p><blockquote class="ne nf ng"><p id="d5d0" class="kk kl nd km b kn ko kp kq kr ks kt ku nh kw kx ky ni la lb lc nj le lf lg lh ij bi translated">参考:<a class="ae kc" href="http://www.haproxy.org/" rel="noopener ugc nofollow" target="_blank">http://www.haproxy.org/</a></p></blockquote><p id="bc8e" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">我们将使用<strong class="km ir"> HAProxy </strong>为<strong class="km ir"> Kubernetes API </strong>创建一个<strong class="km ir">负载平衡器(LB)</strong>——正如我们在<a class="ae kc" href="https://medium.com/@mtvallim/kubernetes-journey-up-and-running-out-of-the-cloud-architecture-overview-e75763b54922" rel="noopener">上一篇文章</a>中提到的。</p><p id="100f" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">让我们想象一个场景:如果我们只有一个<strong class="km ir"> HAProxy </strong>实例执行负载平衡，会发生什么？我们会在我们的架构中引入单点故障(<a class="ae kc" href="https://en.wikipedia.org/wiki/Single_point_of_failure" rel="noopener ugc nofollow" target="_blank"> SPOF </a>)。我的意思是，如果由于任何原因，这个单一的<strong class="km ir"> HAProxy </strong>失败了，我们将完全失去对<strong class="km ir"> Kubernetes API </strong>的访问权。当然，鉴于这个组件对我们的解决方案的重要性，这是我们希望不惜一切代价避免的情况。</p><p id="60da" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">为了解决这个问题，<strong class="km ir"> HAProxy </strong>将成为由<strong class="km ir">浮动IP </strong>驱动的<strong class="km ir">高可用性集群(HA) </strong>的一部分，并且至少配置了两个HAProxy服务，正如在<a class="ae kc" href="https://medium.com/@mtvallim/kubernetes-journey-up-and-running-out-of-the-cloud-architecture-overview-e75763b54922" rel="noopener">上一篇文章</a>中已经介绍的那样。</p><p id="745d" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">总之，我们将为<strong class="km ir">负载平衡</strong>创建一个<strong class="km ir">高可用性集群</strong>。</p><figure class="nl nm nn no gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nk"><img src="../Images/e424b58a50caf044818c148d38e71c0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TTOnuQuHoYLPWW5o1JRslw.png"/></div></div></figure></div><div class="ab cl kd ke hu kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ij ik il im in"><h1 id="fbef" class="ma mb iq bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated">科罗sync</h1><p id="db50" class="pw-post-body-paragraph kk kl iq km b kn my kp kq kr mz kt ku kv na kx ky kz nb lb lc ld nc lf lg lh ij bi translated"><em class="nd">“Corosync集群引擎是一个群组通信系统，具有在应用程序中实现高可用性的附加功能。<br/> Corosync被Apache Qpid和Pacemaker等项目用作高可用性框架。”</em></p><blockquote class="ne nf ng"><p id="bb35" class="kk kl nd km b kn ko kp kq kr ks kt ku nh kw kx ky ni la lb lc nj le lf lg lh ij bi translated">参考:<a class="ae kc" href="https://clusterlabs.org/corosync.html" rel="noopener ugc nofollow" target="_blank">https://clusterlabs.org/corosync.html</a></p></blockquote><p id="1f49" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated"><strong class="km ir"> Corosync </strong>有两个主要目的:<strong class="km ir">保持集群的状态</strong>(知道节点何时加入或离开集群)和<strong class="km ir">向所有集群成员分发消息。</strong></p><h2 id="3aee" class="np mb iq bd mc nq nr dn mg ns nt dp mk kv nu nv mo kz nw nx ms ld ny nz mw oa bi translated">保持集群的状态</h2><p id="8b6d" class="pw-post-body-paragraph kk kl iq km b kn my kp kq kr mz kt ku kv na kx ky kz nb lb lc ld nc lf lg lh ij bi translated"><strong class="km ir">节点加入集群</strong></p><p id="900d" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">要更新集群状态，集群的所有节点都应该安装有<strong class="km ir"> Corosync </strong>，并以相同的方式进行配置。因此，每次包含<strong class="km ir"> Corosync </strong>的节点启动时，想象以下对话发生:</p><ul class=""><li id="5114" class="ob oc iq km b kn ko kr ks kv od kz oe ld of lh og oh oi oj bi translated">新节点发送广播消息说:<em class="nd">“那里有Corosync成员吗？”</em></li><li id="9fe9" class="ob oc iq km b kn ok kr ol kv om kz on ld oo lh og oh oi oj bi translated">网络中现有的<strong class="km ir"> Corosync </strong>实例接收消息并响应:<em class="nd">“我在这里！”</em></li><li id="3473" class="ob oc iq km b kn ok kr ol kv om kz on ld oo lh og oh oi oj bi translated">新节点接收来自这些现有实例的响应，并说:<em class="nd">“你好！我想加入集群。这是我的证件！”</em></li><li id="54ff" class="ob oc iq km b kn ok kr ol kv om kz on ld oo lh og oh oi oj bi translated">现有的<strong class="km ir"> Corosync </strong>实例接收该请求加入消息，评估所接收的凭证(配置),并基于法定人数配置决定新实例是否应该被这个“非常特殊的俱乐部”接受。</li></ul><figure class="nl nm nn no gt jr gh gi paragraph-image"><div class="gh gi op"><img src="../Images/c71ca3622221524709c9eafb6c8cbcdf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*6JppRDIRHdCAvv8o9XRAxg.gif"/></div></figure><p id="9c30" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated"><strong class="km ir">一个节点离开集群</strong></p><p id="cfe2" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">在一个节点加入这个“非常特别的俱乐部”后，它开始了解所有其他节点。同样，所有其他节点都知道新节点，就像它们已经知道所有以前的成员一样。</p><p id="3587" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">为了知道节点何时离开集群，<strong class="km ir"> Corosync </strong>持续监控节点成员的健康状况。为此，想象以下场景:</p><ul class=""><li id="25c8" class="ob oc iq km b kn ko kr ks kv od kz oe ld of lh og oh oi oj bi translated">每个节点都有一个包含所有其他节点地址的列表；</li><li id="5e63" class="ob oc iq km b kn ok kr ol kv om kz on ld oo lh og oh oi oj bi translated">每个节点将与其本地列表中的节点进行交互；</li><li id="bda1" class="ob oc iq km b kn ok kr ol kv om kz on ld oo lh og oh oi oj bi translated">如果由于任何原因，该节点不能与本地列表中的给定节点交互，那么它将认为该节点是不健康的；</li><li id="6560" class="ob oc iq km b kn ok kr ol kv om kz on ld oo lh og oh oi oj bi translated">然后，该节点将咨询所有其他成员，以检查他们如何看到这个潜在的不健康节点。</li><li id="5216" class="ob oc iq km b kn ok kr ol kv om kz on ld oo lh og oh oi oj bi translated">每个节点将有一个投票，从他们的角度来看，该节点是健康的还是不健康的。</li><li id="4f14" class="ob oc iq km b kn ok kr ol kv om kz on ld oo lh og oh oi oj bi translated"><strong class="km ir"> Corosync </strong>然后将根据收到的投票评估法定人数配置，以决定该节点应标记为健康还是不健康。</li><li id="1f42" class="ob oc iq km b kn ok kr ol kv om kz on ld oo lh og oh oi oj bi translated">如果节点被标记为不健康，群集仍会知道它，但在它处于这种状态时不会使用它。</li></ul><figure class="nl nm nn no gt jr gh gi paragraph-image"><div class="gh gi op"><img src="../Images/13d2060861cc555e19f91fce6ff27280.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*z9WJtYobcwp0L6knClRk0w.gif"/></div></figure></div><div class="ab cl kd ke hu kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ij ik il im in"><h1 id="0e68" class="ma mb iq bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated">起搏器</h1><p id="6fb3" class="pw-post-body-paragraph kk kl iq km b kn my kp kq kr mz kt ku kv na kx ky kz nb lb lc ld nc lf lg lh ij bi translated">Pacemaker是一个开源的、高可用性的资源管理器，适用于小型和大型集群</p><blockquote class="ne nf ng"><p id="8279" class="kk kl nd km b kn ko kp kq kr ks kt ku nh kw kx ky ni la lb lc nj le lf lg lh ij bi translated">参考:<a class="ae kc" href="https://clusterlabs.org/pacemaker/" rel="noopener ugc nofollow" target="_blank">https://clusterlabs.org/pacemaker/</a></p></blockquote><blockquote class="oq"><p id="41d0" class="or os iq bd ot ou ov ow ox oy oz lh dk translated">面向Linux平台的权威开源高可用性堆栈构建在Pacemaker集群资源管理器之上。”— LINUX杂志</p></blockquote><p id="f9ff" class="pw-post-body-paragraph kk kl iq km b kn pa kp kq kr pb kt ku kv pc kx ky kz pd lb lc ld pe lf lg lh ij bi translated"><strong class="km ir"> Pacemaker </strong>在由<strong class="km ir"> Corosync </strong>创建和管理的集群中创建和配置资源。</p><p id="3dcb" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">这里<strong class="km ir">起搏器</strong>的主要目的是使我们的<strong class="km ir">装载机平衡器</strong>高度可用<strong class="km ir">。</strong>为此，我们将使用Pacemaker声明一个<strong class="km ir">浮动IP </strong>和一个<strong class="km ir"> HAProxy </strong>资源，这两个资源都将设置在由<strong class="km ir"> Corosync </strong>集群管理的节点中。</p><p id="ced3" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated"><strong class="km ir"> Pacemaker </strong>使用声明式方法。这意味着我们将创建一个配置文件，指定每个节点上应该存在哪些资源，以及这些资源如何相互关联。在我们的例子中，这种关系是<strong class="km ir">浮动IP </strong>和<strong class="km ir"> HAProxy </strong>资源之间的相互依赖关系。这意味着他们相互依赖。如果<strong class="km ir">h proxy</strong>在同一个节点中处于活动状态，则<strong class="km ir">浮动IP </strong>应仅在给定节点中处于活动状态，反之亦然。</p><p id="141e" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">简而言之，当一个节点处于主动模式时，我们希望将<strong class="km ir">浮动IP </strong>和<strong class="km ir"> HAProxy </strong>分配给它并在其上执行，而所有其他节点将处于被动模式，直到该节点或连接到它的资源由于任何原因发生故障。当发生这种情况时，分配给主动节点的资源被“迁移”到(或在其上启动)一个被动节点，在该被动节点上可以满足所有依赖条件。一旦发生这种情况，选定的节点将成为主动节点，而之前的主动节点将转换为被动状态。查看下面的动画:</p><figure class="nl nm nn no gt jr gh gi paragraph-image"><div class="gh gi op"><img src="../Images/1cadba133a863877962b62d88e42f65e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*wNBVXXzIJAIz86avA_sTGQ.gif"/></div></figure></div><div class="ab cl kd ke hu kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ij ik il im in"><h1 id="33d5" class="ma mb iq bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated">dnsmasq</h1><p id="37d1" class="pw-post-body-paragraph kk kl iq km b kn my kp kq kr mz kt ku kv na kx ky kz nb lb lc ld nc lf lg lh ij bi translated"><em class="nd">“DNS masq为小型网络提供网络基础设施:DNS、DHCP、路由器广告和网络引导。它被设计成轻量级的，占用空间小，适用于资源受限的路由器和防火墙。它还被广泛用于智能手机和便携式热点上的网络共享，以及支持虚拟化框架中的虚拟网络。支持的平台包括Linux(带有glibc和uclibc)、Android、*BSD和Mac OS X，Dnsmasq包含在大多数Linux发行版以及FreeBSD、OpenBSD和NetBSD的端口系统中。Dnsmasq提供全面的IPv6支持。</em></p><blockquote class="ne nf ng"><p id="5b16" class="kk kl nd km b kn ko kp kq kr ks kt ku nh kw kx ky ni la lb lc nj le lf lg lh ij bi translated">参考:<a class="ae kc" href="http://thekelleys.org.uk/dnsmasq/doc.html" rel="noopener ugc nofollow" target="_blank">http://thekelleys.org.uk/dnsmasq/doc.html</a></p></blockquote><p id="fbf6" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">我们将使用<strong class="km ir"> dnsmasq </strong>为我们的主机(节点)提供<strong class="km ir"> DNS </strong>和<strong class="km ir"> DHCP </strong>功能。</p><ul class=""><li id="743a" class="ob oc iq km b kn ko kr ks kv od kz oe ld of lh og oh oi oj bi translated"><a class="ae kc" href="https://en.wikipedia.org/wiki/Dynamic_Host_Configuration_Protocol" rel="noopener ugc nofollow" target="_blank"> <strong class="km ir"> DHCP </strong> </a>将负责为每个加入网络的新主机(节点)分配IP地址和网络配置。这消除了为加入网络的每个新主机创建太多设置的需要以及手动这样做的需要。主机向网络 执行<a class="ae kc" href="https://en.wikipedia.org/wiki/Broadcasting_(networking)" rel="noopener ugc nofollow" target="_blank"> <em class="nd">广播，并且<strong class="km ir"> DHCP </strong>服务以所需的设置进行响应。(查看下面的动画)</em></a></li><li id="e17d" class="ob oc iq km b kn ok kr ol kv om kz on ld oo lh og oh oi oj bi translated"><a class="ae kc" href="https://en.wikipedia.org/wiki/Domain_Name_System" rel="noopener ugc nofollow" target="_blank"> <strong class="km ir"> DNS </strong> </a>负责解析我们内部网络以及公共互联网中的域名。</li></ul><p id="4529" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated"><strong class="km ir"> DHCP </strong>和<strong class="km ir"> DNS </strong>将同步工作；也就是说，对于每个加入网络的新主机，<strong class="km ir"> DHCP </strong>使用该主机名到其提供的IP的映射来更新<strong class="km ir"> DNS </strong>服务，因此我们可以通过其名称——而不是其IP——来引用新主机，而不用担心其IP地址。</p><p id="babc" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">作为一个更实际的例子，考虑当我们在云平台(GCP、AWS、Azure等)上创建一个新实例时通常会发生什么。创建的每个新实例都会立即在内部<strong class="km ir"> DNS </strong>中接收IP、DNS解析器、路由和主机名注册。说到底，是<strong class="km ir"> DHCP </strong>，<strong class="km ir"> </strong>连同<strong class="km ir"> DNS </strong>，谁在幕后为我们做这项工作。</p><figure class="nl nm nn no gt jr gh gi paragraph-image"><div class="gh gi op"><img src="../Images/a7ae792945bcaec1a093cd2e0c42be50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*l2GfsD6aug4mBhKJD10xAA.gif"/></div></figure></div><div class="ab cl kd ke hu kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ij ik il im in"><h1 id="f3d2" class="ma mb iq bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated">VirtualBox</h1><p id="9fcf" class="pw-post-body-paragraph kk kl iq km b kn my kp kq kr mz kt ku kv na kx ky kz nb lb lc ld nc lf lg lh ij bi translated"><em class="nd">“VirtualBox是一款功能强大的x86和AMD64/Intel64虚拟化产品，适合企业和家庭使用。VirtualBox不仅是面向企业客户的功能极其丰富、高性能的产品，它还是唯一一个根据GNU通用公共许可证(GPL)第2版条款作为开源软件免费提供的专业解决方案。”</em></p><blockquote class="ne nf ng"><p id="9161" class="kk kl nd km b kn ko kp kq kr ks kt ku nh kw kx ky ni la lb lc nj le lf lg lh ij bi translated">参考:<a class="ae kc" href="https://www.virtualbox.org/" rel="noopener ugc nofollow" target="_blank">https://www.virtualbox.org/</a></p></blockquote><p id="e048" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">好吧，由于我们无法访问实际的裸机服务器，我们将使用<strong class="km ir"> VirtualBox </strong>(一种开源替代产品)来模拟我们数据中心的机器和网络。</p><p id="da43" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">这个技术栈是我们练习这一系列文章中所展示的概念所需要的。</p><figure class="nl nm nn no gt jr gh gi paragraph-image"><div class="gh gi op"><img src="../Images/79b4f18b8469055a7d5cabfeac85b947.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*JofF9RU-HNQVSr1ifBJfMw.png"/></div></figure></div><div class="ab cl kd ke hu kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ij ik il im in"><h1 id="14fa" class="ma mb iq bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated">云初始化</h1><p id="7b0e" class="pw-post-body-paragraph kk kl iq km b kn my kp kq kr mz kt ku kv na kx ky kz nb lb lc ld nc lf lg lh ij bi translated"><em class="nd">“cloud-init是在GPLv3开源许可证和Apache许可证版本2.0下作为自由软件开发和发布的。它最初是为Amazon EC2中Linux的Ubuntu发行版设计的，但现在在每个主流云中的许多Linux和UNIX发行版上都支持它。”</em></p><blockquote class="ne nf ng"><p id="4bb8" class="kk kl nd km b kn ko kp kq kr ks kt ku nh kw kx ky ni la lb lc nj le lf lg lh ij bi translated"><em class="iq">参考:</em><a class="ae kc" href="https://cloud-init.io/" rel="noopener ugc nofollow" target="_blank"><em class="iq">https://cloud-init.io/</em></a></p></blockquote><p id="aaee" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated"><strong class="km ir"> cloud-init </strong>是用于实例初始化的实用程序。它允许在初始化实例时自动配置实例，在几秒钟内快速、轻松地将Linux的通用映像转换为已配置的服务器。</p><p id="df11" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">最新Linux发行版中可用的<strong class="km ir"> cloud-init </strong>实用程序能够执行服务、用户和包的设置。<a class="ae kc" href="https://cloudinit.readthedocs.io/en/latest/topics/examples.html" rel="noopener ugc nofollow" target="_blank"> <strong class="km ir">用户数据</strong> </a>脚本最流行的格式之一是<strong class="km ir">云配置</strong>文件格式。</p><p id="f67f" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated"><strong class="km ir">云配置</strong>文件是由<strong class="km ir">云初始化工具</strong>处理的特殊脚本。它们通常用于在服务器第一次启动时设置服务器。</p><p id="95a7" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">我们可以在下面看到<strong class="km ir"> cloud-init </strong>的动作(<em class="nd">提示:你可以降低视频速度来查看更多细节</em>):</p><figure class="nl nm nn no gt jr"><div class="bz fp l di"><div class="pf pg l"/></div></figure></div><div class="ab cl kd ke hu kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ij ik il im in"><h1 id="503d" class="ma mb iq bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated">LVM</h1><p id="c772" class="pw-post-body-paragraph kk kl iq km b kn my kp kq kr mz kt ku kv na kx ky kz nb lb lc ld nc lf lg lh ij bi translated"><strong class="km ir"><em class="nd">“LVM</em></strong><em class="nd">表示逻辑卷管理器。</em></p><p id="eee7" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated"><strong class="km ir"> <em class="nd">什么是逻辑卷管理？<br/> </em> </strong> <em class="nd">与传统的磁盘和分区视图相比，逻辑卷管理为计算机系统上的磁盘存储提供了更高层次的抽象。这使得系统管理员在为应用程序和用户分配存储时更加灵活。</em></p><p id="0b95" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated"><em class="nd">在逻辑卷管理器的控制下创建的存储卷几乎可以随意调整大小和移动。”</em></p><blockquote class="ne nf ng"><p id="38b8" class="kk kl nd km b kn ko kp kq kr ks kt ku nh kw kx ky ni la lb lc nj le lf lg lh ij bi translated">参考:<a class="ae kc" href="http://tldp.org/HOWTO/LVM-HOWTO/" rel="noopener ugc nofollow" target="_blank">http://tldp.org/HOWTO/LVM-HOWTO/</a></p></blockquote><p id="2e11" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">假设您的公司要租用会议中心。在这些地点举办的会议规模不一，从大型活动如Google I/O和AWS re:Invent到小型活动如年度“你可以想象的任何花哨的会议”都有。</p><p id="2538" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">为了最大限度地利用这些空间，每个场馆基本上都是一个巨大的机库，没有任何固定的空间划分。有了这种配置，您的公司就可以将空间划分成大小不同的更小的插槽。</p><p id="d317" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">例如，想象一下Google I/O。在会议期间，可以配置更大的位置来主持主题演讲，并且在这些会议结束后，可以将空间重新配置成更小的部分来举行活动的其他会议。</p><p id="1228" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">这基本上就是LVM允许我们对磁盘做的事情。LVM允许我们配置我们的服务器，而不必事先知道它们的预期用途。我们不需要知道它们将运行什么服务，也不需要知道这些服务将产生多少数据。它还允许我们实时操作和调整音量，就像上面会议中场地空间分配的例子一样。</p><p id="f58a" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">在我们的具体例子中，由于我们将创建一个虚拟机映像，它将成为许多其他映像(Gateway、HAProxy、Kubernetes主/工作节点和Gluster)的基础，每个服务都有自己的空间需求(在本例中，我们的插槽将是/var、/usr、/tmp、/opt等)，<strong class="km ir"> LVM </strong>将为我们提供根据需要调整分区卷大小的灵活性，而不必提前担心这些细节。</p><figure class="nl nm nn no gt jr gh gi paragraph-image"><div class="gh gi op"><img src="../Images/299f656927795a46b08d68de0650cbbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*nnwYx5tITSu-TtY1IzXIbQ.gif"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">LVM扩展概念在实践中</figcaption></figure></div><div class="ab cl kd ke hu kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ij ik il im in"><h1 id="ad0f" class="ma mb iq bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated">格鲁斯特</h1><p id="4fef" class="pw-post-body-paragraph kk kl iq km b kn my kp kq kr mz kt ku kv na kx ky kz nb lb lc ld nc lf lg lh ij bi translated">“Gluster是一个免费的开源软件可扩展网络文件系统。”</p><blockquote class="ne nf ng"><p id="8410" class="kk kl nd km b kn ko kp kq kr ks kt ku nh kw kx ky ni la lb lc nj le lf lg lh ij bi translated">参考:<a class="ae kc" href="https://www.gluster.org/" rel="noopener ugc nofollow" target="_blank">https://www.gluster.org/</a></p></blockquote><p id="6929" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">你可以在<a class="ae kc" href="https://medium.com/@mtvallim/kubernetes-journey-up-and-running-out-of-the-cloud-architecture-overview-e75763b54922" rel="noopener">上一篇</a>中看到<strong class="km ir"> Gluster </strong>的目的。</p></div><div class="ab cl kd ke hu kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ij ik il im in"><h1 id="2dcb" class="ma mb iq bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated">码头工人</h1><p id="a118" class="pw-post-body-paragraph kk kl iq km b kn my kp kq kr mz kt ku kv na kx ky kz nb lb lc ld nc lf lg lh ij bi translated"><em class="nd"/><strong class="km ir"><em class="nd">Docker</em></strong><em class="nd">是一组互操作的</em> <a class="ae kc" href="https://en.wikipedia.org/wiki/Software-as-a-service" rel="noopener ugc nofollow" target="_blank"> <em class="nd">软件即服务</em> </a> <em class="nd">和</em> <a class="ae kc" href="https://en.wikipedia.org/wiki/Platform-as-a-service" rel="noopener ugc nofollow" target="_blank"> <em class="nd">平台即服务</em> </a> <em class="nd">产品，这些产品采用</em> <a class="ae kc" href="https://en.wikipedia.org/wiki/Operating-system-level_virtualization" rel="noopener ugc nofollow" target="_blank"> <em class="nd">操作系统级虚拟化</em> </a> <em class="nd">来开发和交付标准化软件包内的软件托管容器的软件被称为</em> <strong class="km ir"> <em class="nd"> Docker引擎</em> </strong> <em class="nd">。它于2013年首次启动，由</em> <a class="ae kc" href="https://en.wikipedia.org/wiki/Docker,_Inc." rel="noopener ugc nofollow" target="_blank"> <em class="nd"> Docker，Inc. </em> </a> <em class="nd">开发，该服务有免费和高级两个等级。</em></p><blockquote class="ne nf ng"><p id="9007" class="kk kl nd km b kn ko kp kq kr ks kt ku nh kw kx ky ni la lb lc nj le lf lg lh ij bi translated">参考:<a class="ae kc" href="https://en.wikipedia.org/wiki/Docker_(software)" rel="noopener ugc nofollow" target="_blank">https://en . Wikipedia . org/wiki/Docker _(软件)</a> <br/>参考:<a class="ae kc" href="https://www.docker.com/" rel="noopener ugc nofollow" target="_blank">https://www.docker.com/</a></p></blockquote><p id="979a" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">Docker 最初是基于<a class="ae kc" href="https://linuxcontainers.org/lxc/introduction/" rel="noopener ugc nofollow" target="_blank"> LXC </a>技术开发的，但已经独立。它提供的不仅仅是运行容器:它使创建、构建、上传和控制版本映像变得容易。</p><figure class="nl nm nn no gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nk"><img src="../Images/de8c1523a6ad8fb210442547f5194b3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nTgyNU8b5oJhzq66v-Awmw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">以上是摘自维基百科和<a class="ae kc" href="http://pivotal.io/platform/infographic/moments-in-container-history" rel="noopener ugc nofollow" target="_blank">其他来源</a>的容器历史的简要总结</figcaption></figure><p id="4480" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">这本质上是一种将软件打包成容器格式的方法。但这意味着什么呢？这意味着您的所有软件及其依赖项(如库、配置等)都包含在这个容器中，这使得移植您的应用程序更加容易，而不必担心应用程序部署到的环境中的潜在差异。</p><p id="b997" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">这种方法的一大优点是，您可以在任何其他环境或新机器中启动您的容器，而不会出现意外错误或额外的配置，因为您的应用程序需要的所有东西都打包在同一个容器中。这样，容器的管理就变得:可预测、可重复、不可改变。</p><p id="15c6" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">有些人可能会说，通过虚拟化也可以实现同样的目标。这种假设是正确的，结果实际上是一样的，但这里最大的不同是我们更好地利用了我们的资源。使用容器，我们能够共享我们的操作系统资源，不再需要整个操作系统来托管我们的应用程序。为了更好地理解这个概念，请看下图:</p><figure class="nl nm nn no gt jr gh gi paragraph-image"><div class="gh gi ph"><img src="../Images/24e1ea2babbde3e2ab0377600db7c639.png" data-original-src="https://miro.medium.com/v2/resize:fit:1100/format:webp/1*WjHvb3eI1drSVaEjDgdoVw.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">图片作者:<a class="ae kc" href="https://www.redhat.com/" rel="noopener ugc nofollow" target="_blank">https://www.redhat.com</a></figcaption></figure><p id="34e2" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">所有这些听起来真的很棒，但是当我有一个运行在<strong class="km ir"> Docker </strong>容器上的应用生态系统时会发生什么呢？这使得我们的管理工作非常低效、乏味且容易出错。那是<strong class="km ir">库伯内特斯</strong>加入派对的地方。Kubernetes 是一个开源的容器编排系统，用于自动化应用程序的部署、扩展和管理，能够智能和干净地管理容器。</p></div><div class="ab cl kd ke hu kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ij ik il im in"><h1 id="b3ba" class="ma mb iq bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated">库伯内特斯</h1><p id="8a9c" class="pw-post-body-paragraph kk kl iq km b kn my kp kq kr mz kt ku kv na kx ky kz nb lb lc ld nc lf lg lh ij bi translated"><em class="nd">“Kubernetes(K8s)是一个用于自动化部署、扩展和管理容器化应用的开源系统。”</em></p><blockquote class="ne nf ng"><p id="312e" class="kk kl nd km b kn ko kp kq kr ks kt ku nh kw kx ky ni la lb lc nj le lf lg lh ij bi translated">参考:<a class="ae kc" href="https://kubernetes.io/" rel="noopener ugc nofollow" target="_blank">https://kubernetes.io/</a></p></blockquote><p id="cc5f" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">正如我们在上面看到的，Kubernetes是一个用于自动化应用程序部署、伸缩和管理的开源容器编排系统，能够智能和干净地管理容器。</p><p id="d5fe" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">我们将在本系列的下一篇文章中详细介绍<strong class="km ir"> Kubernetes </strong>的内部原理。</p><figure class="nl nm nn no gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi pi"><img src="../Images/f16792be556ccd738d67397d09688d62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6M-8Y7MTvbEovRGdPRQOdg.jpeg"/></div></div></figure></div><div class="ab cl kd ke hu kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ij ik il im in"><h1 id="2c21" class="ma mb iq bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated">一种自由操作系统</h1><p id="16cd" class="pw-post-body-paragraph kk kl iq km b kn my kp kq kr mz kt ku kv na kx ky kz nb lb lc ld nc lf lg lh ij bi translated">Debian是你电脑的免费操作系统。操作系统是使计算机运行的一组基本程序和实用程序</p><blockquote class="ne nf ng"><p id="ef3d" class="kk kl nd km b kn ko kp kq kr ks kt ku nh kw kx ky ni la lb lc nj le lf lg lh ij bi translated">参考:<a class="ae kc" href="https://www.debian.org/" rel="noopener ugc nofollow" target="_blank">https://www.debian.org/</a></p></blockquote></div><div class="ab cl kd ke hu kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ij ik il im in"><h1 id="fe1c" class="ma mb iq bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated">人的本质</h1><p id="7456" class="pw-post-body-paragraph kk kl iq km b kn my kp kq kr mz kt ku kv na kx ky kz nb lb lc ld nc lf lg lh ij bi translated">Ubuntu是一个开源软件操作系统，它可以运行在桌面、云端以及所有与互联网相连的东西上</p><blockquote class="ne nf ng"><p id="14bd" class="kk kl nd km b kn ko kp kq kr ks kt ku nh kw kx ky ni la lb lc nj le lf lg lh ij bi translated">参考:<a class="ae kc" href="https://www.ubuntu.com/" rel="noopener ugc nofollow" target="_blank">https://www.ubuntu.com/</a></p></blockquote></div><div class="ab cl kd ke hu kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ij ik il im in"><p id="2f26" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">我希望你喜欢这篇文章以及这个系列的其他文章。在下一篇文章中，我们将定义我们的网络拓扑，并为后面的文章打下基础。</p><p id="e7e8" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">不要忘记在下面的评论中留下你的反馈。不断完善这一系列的内容非常重要。</p><p id="64f2" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">我再次强烈推荐您关注我的Medium，这样您就不会错过本系列中发表的任何新文章。如果你错过了这个系列的第一篇文章，你可以在这里查看<a class="ae kc" href="https://medium.com/@mtvallim/kubernetes-journey-up-and-running-out-of-the-cloud-introduction-f04a811c92a5" rel="noopener"/>。</p></div><div class="ab cl kd ke hu kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ij ik il im in"><p id="4669" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">回头见！！</p><p id="bc65" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">再见</p></div></div>    
</body>
</html>