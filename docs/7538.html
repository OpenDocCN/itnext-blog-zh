<html>
<head>
<title>Rely on JavaScript’s Intersection Observer to Execute Code When in View (or Not)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">依靠JavaScript的交集观察器在视图中(或不在视图中)执行代码</h1>
<blockquote>原文：<a href="https://itnext.io/rely-on-javascripts-intersection-observer-to-execute-code-when-in-view-or-not-87a48d77d5a1?source=collection_archive---------1-----------------------#2022-10-27">https://itnext.io/rely-on-javascripts-intersection-observer-to-execute-code-when-in-view-or-not-87a48d77d5a1?source=collection_archive---------1-----------------------#2022-10-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="68bf" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">停止视频播放或动画显示屏幕上的元素——交叉点观察器API非常通用。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/d27f3708db4cc805026d309c59863b10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*z1r_a5SmYNH6g5G0.jpg"/></div></figure><h1 id="31e4" class="kn ko iq bd kp kq kr ks kt ku kv kw kx jw ky jx kz jz la ka lb kc lc kd ld le bi translated">重要的是小事</h1><p id="5e44" class="pw-post-body-paragraph lf lg iq lh b li lj jr lk ll lm ju ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">当我每天处理网站建设业务时，我不禁开始注意到，好网站和伟大网站的区别在于，伟大的网站密切关注小细节。</p><p id="7ef2" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">小页面动画，在表单提交后禁用的按钮，或者当用户滚动到页面的该部分时页面上的元素才显示它们自己。你可能不会立即意识到这种细微之处是为了改善用户体验，但当它消失时，它会变得更加明显:一个即使在你滚动离开后也不会停止播放的视频，一个直到你从失败的提交按钮向上滚动页面时才能看到的错误消息，还有无数这样的小烦恼。</p><p id="84f6" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">最近，我为公司的营销网站建立了一个新的关于我们的页面，在设计师给我的模型中，有一些很酷的动画显示了页面底部的一系列卡片，只有当用户向下滚动足够远才能看到它们时，这些卡片才会滑入视图。它看起来真的很棒，事实证明，现在只需要一点CSS和JavaScript，以及许多其他方便的交互就可以做到这一点。</p><p id="41b2" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated"><strong class="lh ir">今天，我将向您展示JavaScript Intersection Observer API如何根据元素在视口中的可见性轻松控制元素的反应。</strong></p><p id="6519" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">下面是一个视频，展示了在观众到达之前，页面底部的卡片是如何不动起来并滑入视野的:这是一个路口观察者工作的例子。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mg mh l"/></div></figure></div><div class="ab cl mi mj hu mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ij ik il im in"><h1 id="bab0" class="kn ko iq bd kp kq mp ks kt ku mq kw kx jw mr jx kz jz ms ka lb kc mt kd ld le bi translated">交叉观察者</h1><p id="84a2" class="pw-post-body-paragraph lf lg iq lh b li lj jr lk ll lm ju ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">如果您不熟悉的话，<a class="ae mu" href="https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API" rel="noopener ugc nofollow" target="_blank"> <strong class="lh ir">交集观察器API </strong> </a>提供了一种异步观察目标元素与祖先元素或顶级文档视窗交集变化的方法。</p><p id="a744" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">简而言之:它可以判断一个元素是否在视图中，并使事物做出相应的动作。</p><p id="24c8" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">在交叉点观察器出现之前，这种类型的交叉点检测很笨拙，主线程中有许多事件处理程序和循环，可能会导致性能问题和混乱的代码。</p><p id="5840" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">另一方面，创建一个<code class="fe mv mw mx my b">intersectionObserver</code>，并为其分配一个回调函数，每当DOM中的某个特定元素在一个方向或另一个方向上超过阈值时，该函数就会运行。</p><p id="fd54" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">也可以给它一系列可选的<code class="fe mv mw mx my b">options</code>,告诉它何时调用回调函数:</p><ul class=""><li id="e239" class="mz na iq lh b li mb ll mc lo nb ls nc lw nd ma ne nf ng nh bi translated"><code class="fe mv mw mx my b">root</code> -用作检查目标可见性的视口的元素。</li><li id="1e91" class="mz na iq lh b li ni ll nj lo nk ls nl lw nm ma ne nf ng nh bi translated"><code class="fe mv mw mx my b">rootMargin</code>——在计算交集之前，围绕根元素的边界框增长或收缩的一组值。</li><li id="f197" class="mz na iq lh b li ni ll nj lo nk ls nl lw nm ma ne nf ng nh bi translated"><code class="fe mv mw mx my b">threshold</code>——一个数字，表示观察者的回调函数应该在目标可见性的多少百分比上执行。(例如，缺省值0表示只要有一个像素可见，回调就会运行，而1.0表示直到元素的每个像素都可见，才认为超过了阈值)。</li></ul><blockquote class="nn no np"><p id="f524" class="lf lg nq lh b li mb jr lk ll mc ju ln nr md lq lr ns me lu lv nt mf ly lz ma ij bi translated"><em class="iq">关于如何微调和利用交叉点观察器来达到酷的效果，还有很多细微差别，但是我上面提到的应该足以帮助你理解我将要演示的例子。如果你想了解更多，我推荐阅读Mozilla </em>  <em class="iq">的</em> <a class="ae mu" href="https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API" rel="noopener ugc nofollow" target="_blank"> <em class="iq">文档，其中包括一些很棒的代码示例。</em></a></p></blockquote><p id="4445" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">所有这些文字可能还没有完全理解，所以让我们来看一些代码示例，在这些示例中，您可以看到交叉点观察器在工作。</p><h1 id="cce1" class="kn ko iq bd kp kq kr ks kt ku kv kw kx jw ky jx kz jz la ka lb kc lc kd ld le bi translated">交叉点观察器代码示例</h1><p id="b2b3" class="pw-post-body-paragraph lf lg iq lh b li lj jr lk ll lm ju ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">有几个不同的场景，其中交叉点观察器以独特的方式在营销网站上使用，我将向您展示这两个场景，以帮助演示它可以有多灵活。</p><h2 id="a745" class="nu ko iq bd kp nv nw dn kt nx ny dp kx lo nz oa kz ls ob oc lb lw od oe ld of bi translated">仅当用户将看到结果时才运行动画</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi og"><img src="../Images/8df3faf64fa33733a9716f96106de9de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1380/format:webp/0*RFSKA7_4LT31LyL3.png"/></div><figcaption class="oh oi gj gh gi oj ok bd b be z dk translated">一旦用户可以在交叉点观察器的帮助下在屏幕上看到这些卡，这些卡就会滑入视图。</figcaption></figure><p id="6778" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">我将向您展示的第一个示例是我在本博客的介绍中描述的:它在屏幕上显示一系列卡片的动画，但只有当用户向下滚动页面足够远以查看卡片时。</p><blockquote class="nn no np"><p id="a440" class="lf lg nq lh b li mb jr lk ll mc ju ln nr md lq lr ns me lu lv nt mf ly lz ma ij bi translated"><strong class="lh ir"> <em class="iq">注:</em> </strong></p><p id="c298" class="lf lg nq lh b li mb jr lk ll mc ju ln nr md lq lr ns me lu lv nt mf ly lz ma ij bi translated"><em class="iq">我引用的站点代码是用</em><a class="ae mu" href="https://gohugo.io/" rel="noopener ugc nofollow" target="_blank"><em class="iq">Hugo</em></a><em class="iq">编写的，一个流行的、开源的、用go编写的静态站点生成器。像许多SSG一样，它依赖于</em> <a class="ae mu" href="https://gohugo.io/templates/introduction/" rel="noopener ugc nofollow" target="_blank"> <em class="iq">模板</em> </a> <em class="iq">来呈现站点的大部分HTML，为了本文的清晰起见，我用生成的HTML替换了注入模板的Go变量。</em></p></blockquote><p id="b0ca" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">让我们首先看看页面中呈现的三张卡片的HTML和JavaScript。这个代码片段只显示了其中一张卡片，但是对于所有的卡片都是一样的。</p><p id="0fd7" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated"><code class="fe mv mw mx my b">quote-cards.html</code></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="om on di oo bf op"><div class="gh gi ol"><img src="../Images/fb8c65a2b2eb71cb3c6c20e3c7ec9b4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Yebu8rCfpAuXHqfE50M6fg.png"/></div></div></figure><p id="df05" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">代码片段中的HTML概述了<code class="fe mv mw mx my b">card</code>元素和卡片中包含的细节:报价、姓名、被报价人的公司和角色。</p><p id="0186" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">代码片段底部的JavaScript是交叉点观察器发挥作用的地方。首先，创建一个名为<code class="fe mv mw mx my b">quoteCard</code>的变量，指向包围每张卡片的<code class="fe mv mw mx my b">div</code>上的<code class="fe mv mw mx my b">customer-quote-card</code> CSS类。</p><p id="200f" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">然后，用<code class="fe mv mw mx my b">0.7</code>的<code class="fe mv mw mx my b">threshold</code>声明<code class="fe mv mw mx my b">observerOptions</code>变量——这将很快传递给<code class="fe mv mw mx my b">IntersectionObserver</code>对象，并要求至少70%的卡片可见，然后才能动画显示。</p><p id="d97e" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">定义了一个<code class="fe mv mw mx my b">callback()</code>函数，它循环遍历一个项目列表，对于每个项目，如果项目<code class="fe mv mw mx my b"><a class="ae mu" href="https://developer.mozilla.org/en-US/docs/Web/API/IntersectionObserverEntry/isIntersecting" rel="noopener ugc nofollow" target="_blank">isIntersecting</a></code>(一个布尔值，如果目标元素与交集观察者的根相交，则为真)，则<code class="fe mv mw mx my b">animated</code>类被添加到该项目的CSS类中。本质上，这个函数会将CSS类添加到每个卡片上，以触发动画，并在达到<code class="fe mv mw mx my b">isIntersecting</code>阈值时将它们显示在页面上。</p><p id="85fd" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">接下来，一个<code class="fe mv mw mx my b">new IntersectionObserver</code>实例被实例化为<code class="fe mv mw mx my b">quoteCardObserver</code>，并且<code class="fe mv mw mx my b">callback()</code>和<code class="fe mv mw mx my b">observerOptions</code>被传入。</p><p id="f635" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">最后，对于每个<code class="fe mv mw mx my b">quoteCard</code>对象，<code class="fe mv mw mx my b">quoteCardObserver</code>函数被附加到卡片上。</p><p id="a00d" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">随着HTML和JavaScript的建立，是时候添加CSS了(还记得前面提到的<code class="fe mv mw mx my b">animated</code> CSS类吗？)当交叉点观察器的<code class="fe mv mw mx my b">callback()</code>功能触发时，在屏幕上动画显示卡片。</p><p id="8468" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated"><code class="fe mv mw mx my b">about.scss</code></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="om on di oo bf op"><div class="gh gi oq"><img src="../Images/2a1cf9b621d72620d8d211d7c71fcc86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5ng_AuEZ188DN8gWS4hwbg.png"/></div></div></figure><p id="6120" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">在SCSS代码中，<code class="fe mv mw mx my b">card-group</code>类开始时不透明度为0，以隐藏卡片。</p><p id="d8ea" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">创建了<code class="fe mv mw mx my b">animated</code>类，其<code class="fe mv mw mx my b"><a class="ae mu" href="https://developer.mozilla.org/en-US/docs/Web/CSS/animation" rel="noopener ugc nofollow" target="_blank">animation</a></code> <a class="ae mu" href="https://developer.mozilla.org/en-US/docs/Web/CSS/animation" rel="noopener ugc nofollow" target="_blank">属性</a>指定了持续时间为1.5秒的<code class="fe mv mw mx my b">slideLeft</code>关键帧。</p><p id="ad6d" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">除了<code class="fe mv mw mx my b">animation</code>属性之外，<code class="fe mv mw mx my b">animation-delay</code>、<code class="fe mv mw mx my b">animation-fill-mode</code>和<code class="fe mv mw mx my b">opacity</code>也被定义在这个类上。</p><ul class=""><li id="2d2f" class="mz na iq lh b li mb ll mc lo nb ls nc lw nd ma ne nf ng nh bi translated"><code class="fe mv mw mx my b">animation-delay: 0;</code>确保动画立即播放，</li><li id="d132" class="mz na iq lh b li ni ll nj lo nk ls nl lw nm ma ne nf ng nh bi translated"><code class="fe mv mw mx my b">animation-fill-mode: backwards;</code>表示元素一旦应用到目标，就会应用在<code class="fe mv mw mx my b">0%</code>关键帧中定义的值(即，一旦在DOM中渲染，卡片将保持隐藏，不透明度为0)。</li><li id="d01a" class="mz na iq lh b li ni ll nj lo nk ls nl lw nm ma ne nf ng nh bi translated"><code class="fe mv mw mx my b">opacity: 1;</code>一旦<code class="fe mv mw mx my b">slideLeft</code>关键帧动画结束，卡片将在屏幕上100%可见。</li></ul><p id="7820" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">最后但同样重要的是，定义了<code class="fe mv mw mx my b"><a class="ae mu" href="https://developer.mozilla.org/en-US/docs/Web/CSS/@keyframes" rel="noopener ugc nofollow" target="_blank">@keyframes</a></code>动画序列。仅定义了两个关键帧(<code class="fe mv mw mx my b">0%</code>和<code class="fe mv mw mx my b">100%</code>)来指示卡片开始时没有不透明度(<code class="fe mv mw mx my b">opacity: 0;</code>)并且100%离开屏幕向右(<code class="fe mv mw mx my b">transform: translateX(100%);</code>，当它结束时，它们将完全可见(<code class="fe mv mw mx my b">opacity: 1;</code>)并且在屏幕上(<code class="fe mv mw mx my b">transform: translateX(0);</code>)。</p><p id="004c" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">最终，它产生了这样的效果:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mg mh l"/></div></figure><blockquote class="nn no np"><p id="1f84" class="lf lg nq lh b li mb jr lk ll mc ju ln nr md lq lr ns me lu lv nt mf ly lz ma ij bi translated"><strong class="lh ir"> <em class="iq">注:</em> </strong></p><p id="99c5" class="lf lg nq lh b li mb jr lk ll mc ju ln nr md lq lr ns me lu lv nt mf ly lz ma ij bi translated">CSS动画超出了本教程的范围，但是如果想更深入地研究它们，我推荐从这里开始<a class="ae mu" href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Animations/Using_CSS_animations" rel="noopener ugc nofollow" target="_blank"><em class="iq"/></a><em class="iq">——它们非常酷！</em></p></blockquote><p id="ec1a" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">太好了！这是如何使用交叉点观察器来控制动画计时的一个例子，这样用户就可以看到它。现在让我们考虑另一个选择。</p><h2 id="79a4" class="nu ko iq bd kp nv nw dn kt nx ny dp kx lo nz oa kz ls ob oc lb lw od oe ld of bi translated">仅当用户可以看到时播放视频</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi og"><img src="../Images/358e69046e49a8497ef47d2abd563081.png" data-original-src="https://miro.medium.com/v2/resize:fit:1380/format:webp/0*CY7mtyDy4q089_PC.png"/></div><figcaption class="oh oi gj gh gi oj ok bd b be z dk translated">只有当用户看到该视频并单击播放按钮时，该视频才会播放。如果用户通过点击页面上的其他地方来关闭该模式，该模式将隐藏，视频停止播放。</figcaption></figure><p id="e666" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">我要分享的第二个例子是一个视频模态，当模态不可见时，它会停止播放。当单击一个按钮时，模式会接管整个页面，视频播放器位于视窗的中心。如果用户在视频播放的时候点击了视频旁边的某个地方，这个模态就会消失并隐藏起来，视频也会停止播放。这是可能的，因为有了交叉点观测器。</p><p id="74ee" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">让我们来看看实现这一点的代码。</p><p id="e08a" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated"><code class="fe mv mw mx my b">video_modal.html</code></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="om on di oo bf op"><div class="gh gi or"><img src="../Images/09fdc0a15899ba1ca0cf8eb0bc4a1eb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dt9FxKBmQUtIl759wTOeiA.png"/></div></div></figure><p id="fb76" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">在上面的代码中，在HTML中创建了一个视频模型和一个来自YouTube的iframe视频嵌入。</p><p id="670d" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">在其正下方的JavaScript中，定义了一个聚焦于<code class="fe mv mw mx my b">&lt;iframe&gt;</code> HTML元素的<code class="fe mv mw mx my b">iframe</code>变量，并定义了一个<code class="fe mv mw mx my b">ytsrc</code>变量来跟踪iframe的视频源——这将在交叉点观察器的回调中使用。</p><p id="46a1" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">接下来，初始化一个新的交集观察器(<code class="fe mv mw mx my b">observer</code>)，这个观察器的回调函数遍历它接收到的列表<code class="fe mv mw mx my b">entries</code>，如果列表中的第一个<code class="fe mv mw mx my b">entry</code>不是<em class="nq">交集(即视频iframe和viewport不重叠，或者更确切地说，模态对查看器不可见)，iframe的<code class="fe mv mw mx my b">src</code>被设置为空字符串，因此没有视频URL可播放。如果<code class="fe mv mw mx my b">entry</code> <em class="nq">与</em>相交(即视频模态在视口中可见)，则iframe的<code class="fe mv mw mx my b">src</code>被设置为<code class="fe mv mw mx my b">ytsrc</code>变量:实际的YouTube视频URL。</em></p><p id="9e4d" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">最后，新的<code class="fe mv mw mx my b">observer</code>对象被告知观察<code class="fe mv mw mx my b">iframe</code>变量，因此每当<code class="fe mv mw mx my b">iframe</code>在视口中时(例如，当用户点击按钮打开模态时)，它的视频源就是YouTube视频。每当这种情况发生变化时(模态是隐藏的)，视频URL被设置为空字符串。</p><p id="da43" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">这导致当视频模式被取消时，没有视频继续播放。</p><p id="0eaf" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">要了解它是如何工作的，请在打开声音的情况下观看此视频，听听当模态被消除并隐藏时，音频是如何停止的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="c851" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">很有用，是吧？</p></div><div class="ab cl mi mj hu mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ij ik il im in"><h1 id="6094" class="kn ko iq bd kp kq mp ks kt ku mq kw kx jw mr jx kz jz ms ka lb kc mt kd ld le bi translated">结论</h1><p id="4e0b" class="pw-post-body-paragraph lf lg iq lh b li lj jr lk ll lm ju ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">小细节可以创造伟大的用户体验，无论是当用户滚动过它时停止播放的视频，还是只有当用户看到元素时才会发生的动画。</p><p id="2550" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">虽然这些小的交互曾经需要大量额外的代码，并且知道主线程可能被阻塞多长时间，但是交叉点观察器API的引入极大地简化了事情。现在，单个对象允许开发人员指定一个要观察的元素、一个要做某件事的回调函数，甚至可以微调该函数，只在满足某些条件时触发。实际上，它在很多情况下都非常有用。</p><p id="8da0" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">过几周再来看看——我会写更多关于JavaScript、React、IoT或其他与web开发相关的东西。</p><p id="3689" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">如果你想确保你不会错过我写的一篇文章，在这里注册我的时事通讯:<a class="ae mu" href="https://paigeniedringhaus.substack.com/" rel="noopener ugc nofollow" target="_blank">https://paigeniedringhaus.substack.com</a></p><p id="c09d" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">感谢阅读。我希望这个关于如何使用交叉点观察器API的演示能够帮助您在未来的工作中摆脱困境。我知道我真的很欣赏伟大的网站体验，拥有另一个工具来实现它们总是好的。</p></div><div class="ab cl mi mj hu mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ij ik il im in"><h1 id="eaa9" class="kn ko iq bd kp kq mp ks kt ku mq kw kx jw mr jx kz jz ms ka lb kc mt kd ld le bi translated">参考资料和更多资源</h1><ul class=""><li id="f7f2" class="mz na iq lh b li lj ll lm lo os ls ot lw ou ma ne nf ng nh bi translated"><a class="ae mu" href="https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API" rel="noopener ugc nofollow" target="_blank"> MDN文档，交叉点观察器</a></li><li id="5074" class="mz na iq lh b li ni ll nj lo nk ls nl lw nm ma ne nf ng nh bi translated"><a class="ae mu" href="https://developer.mozilla.org/en-US/docs/Web/CSS/animation" rel="noopener ugc nofollow" target="_blank"> MDN文档，CSS动画</a></li></ul></div><div class="ab cl mi mj hu mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ij ik il im in"><p id="f43b" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated"><em class="nq">原载于</em><a class="ae mu" href="https://www.paigeniedringhaus.com/blog/rely-on-java-scripts-intersection-observer-to-execute-code-when-in-view-or-not" rel="noopener ugc nofollow" target="_blank"><em class="nq">https://www.paigeniedringhaus.com</em></a><em class="nq">。</em></p></div></div>    
</body>
</html>