<html>
<head>
<title>The Definitive Guide to Handling GraphQL Errors</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">处理GraphQL错误的权威指南</h1>
<blockquote>原文：<a href="https://itnext.io/the-definitive-guide-to-handling-graphql-errors-e0c58b52b5e1?source=collection_archive---------0-----------------------#2018-03-12">https://itnext.io/the-definitive-guide-to-handling-graphql-errors-e0c58b52b5e1?source=collection_archive---------0-----------------------#2018-03-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/f662d0a16f925e1fbd26a4659d22d0a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zRT0atOgVLyaQa3xYlO54A@2x.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">明白了吗？因为它们是错误...你扔出去，然后接住它们…没关系</figcaption></figure><p id="e35f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><a class="ae la" href="https://www.linkedin.com/cws/share?url=https%3A%2F%2Fitnext.io%2Fthe-definitive-guide-to-handling-graphql-errors-e0c58b52b5e1" rel="noopener ugc nofollow" target="_blank"> <em class="lb">点击这里在LinkedIn上分享这篇文章</em> </a></p><p id="4da6" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">最近，我搞砸了，导致一个客户在使用我们的应用程序时出现白屏。像大多数应用程序一样，我们有一个初始的GraphQL查询来获取大量信息，包括所有通知的列表。其中一个通知引用了数据库中不再存在的字段(哎呀！).结果呢？GraphQL是冠军，它将<code class="fe lc ld le lf b">data</code>和<code class="fe lc ld le lf b">errors</code>都发送给了客户端。但是客户端完全忽略了<code class="fe lc ld le lf b">data</code>,因为它将响应作为错误处理。事后看来，那是相当愚蠢的。这就像一个学生得不到100分就不及格一样。这是不对的。</p><p id="9132" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">GraphQL发送<code class="fe lc ld le lf b">data</code>和<code class="fe lc ld le lf b">errors</code>的能力令人惊叹。这就像和一个真正的人对话:“嘿，马特，这是你想要的结果。除了任务区，我什么都给你了；我去查了一下，你的数据库里没有。”有了这些能力，我们可以在客户端上做一些非常酷的事情！不幸的是，大多数客户端代码归结为:</p><pre class="lg lh li lj gt lk lf ll lm aw ln bi"><span id="2e0e" class="lo lp iq lf b gy lq lr l ls lt">if (result.errors) throw result.errors[0]</span></pre><p id="4c0e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这并不完美，但是如果我们没有抛出错误，那么就不会调用<code class="fe lc ld le lf b">onError</code>处理程序，这就是我将服务器验证错误传播到UI的方式。因此，在编写一个完美的服务器和不接收服务器错误之间选择，我选择了前者——它工作了将近2年！…直到它没有。</p><h1 id="6fc5" class="lu lp iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">识别错误类型</h1><p id="02af" class="pw-post-body-paragraph kc kd iq ke b kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv mv kx ky kz ij bi translated">为了确保我修复了根本原因，我开始研究我们在应用程序中抛出的所有类型的错误，以及其他人处理GraphQL错误的所有方式。在查询GraphQL服务器时，客户端可能会遇到很多错误。无论是查询、变异还是订阅，它们都属于6种类型:</p><ol class=""><li id="48cf" class="mw mx iq ke b kf kg kj kk kn my kr mz kv na kz nb nc nd ne bi translated">服务器问题(5xx HTTP代码，1xxx WebSocket代码)</li><li id="eee9" class="mw mx iq ke b kf nf kj ng kn nh kr ni kv nj kz nb nc nd ne bi translated">客户问题，如速率受限、未授权等。(4xx HTTP代码)</li><li id="8d62" class="mw mx iq ke b kf nf kj ng kn nh kr ni kv nj kz nb nc nd ne bi translated"><code class="fe lc ld le lf b">query</code>缺失/格式不正确</li><li id="70d2" class="mw mx iq ke b kf nf kj ng kn nh kr ni kv nj kz nb nc nd ne bi translated"><code class="fe lc ld le lf b">query</code>没有通过GraphQL内部验证(语法、模式逻辑等。)</li><li id="a152" class="mw mx iq ke b kf nf kj ng kn nh kr ni kv nj kz nb nc nd ne bi translated">用户提供的<code class="fe lc ld le lf b">variables</code>或<code class="fe lc ld le lf b">context</code>不正确，<code class="fe lc ld le lf b">resolve</code> / <code class="fe lc ld le lf b">subscribe</code>函数故意抛出错误(例如，不允许查看请求的用户)</li><li id="7b9c" class="mw mx iq ke b kf nf kj ng kn nh kr ni kv nj kz nb nc nd ne bi translated">在<code class="fe lc ld le lf b">resolve</code> / <code class="fe lc ld le lf b">subscribe</code>函数中出现未被捕获的开发人员错误(例如，编写的数据库查询很差)</li></ol><p id="b9c3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">那么，这些错误中哪些是关键到可以忽略所有数据的呢？数字1-3，因为它们甚至在调用GraphQL之前就出现了。第四，它也调用GraphQL，但是只接收到<code class="fe lc ld le lf b">errors</code>的响应。对于5–6，GraphQL用部分<code class="fe lc ld le lf b">data</code>和一个数组<code class="fe lc ld le lf b">errors</code>来响应。有些人会把类型5和类型2混为一谈，例如，查询“点”的用尽可能会构成HTTP 429(请求太多)。但说到底，最简单的答案是最好的:<strong class="ke ir">如果GraphQL给你一个带有</strong> <code class="fe lc ld le lf b"><strong class="ke ir">data</strong></code> <strong class="ke ir">的结果，即使那个结果包含</strong> <code class="fe lc ld le lf b"><strong class="ke ir">errors</strong></code> <strong class="ke ir">，也不算错误。</strong>没有根据错误类型改变HTTP代码，没有读取<code class="fe lc ld le lf b">errors</code>来决定特定错误有多“严重”,也没有读取<code class="fe lc ld le lf b">data</code>来查看它是否可用。我不在乎结果是不是<code class="fe lc ld le lf b">{data: {foo: null}}</code>。数据就是数据；任何在GraphQL返回后实现的任意空逻辑都是:任意的。</p><p id="d0c1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">按照这个逻辑，错误类型1–4将作为错误发送到客户端，因为没有<code class="fe lc ld le lf b">result.data</code>。但是第5-6类呢？</p><h1 id="68c1" class="lu lp iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">不要故意在GraphQL中抛出错误</h1><p id="5112" class="pw-post-body-paragraph kc kd iq ke b kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv mv kx ky kz ij bi translated">截至2018年3月，无论是<a class="ae la" href="https://github.com/apollographql/apollo-client/issues/3034" rel="noopener ugc nofollow" target="_blank">阿波罗</a> - <a class="ae la" href="https://github.com/apollographql/apollo-client/issues/3000" rel="noopener ugc nofollow" target="_blank">客户端</a> ( <a class="ae la" href="https://github.com/apollographql/apollo-client/issues/2810" rel="noopener ugc nofollow" target="_blank">包括</a> <a class="ae la" href="https://github.com/apollographql/subscriptions-transport-ws/issues/305" rel="noopener ugc nofollow" target="_blank">订阅-传输-ws </a>)还是<a class="ae la" href="https://github.com/facebook/relay/issues/1913" rel="noopener ugc nofollow" target="_blank">中继</a> <a class="ae la" href="https://github.com/facebook/relay/issues/1816#issuecomment-304492071" rel="noopener ugc nofollow" target="_blank">现代</a>在处理错误方面都不完美。Relay的突变API接近于它的<code class="fe lc ld le lf b">onCompleted(result, errors)</code>回调，但是对于查询和订阅来说这是非常缺少的。阿波罗凭借其<code class="fe lc ld le lf b">ErrorPolicy</code>更加灵活；但是这两种方法都没有提供最佳实践，所以我提出了自己的方法:<strong class="ke ir">如果查看者看到了错误，将错误作为一个字段包含在响应有效负载中。</strong>例如，如果有人使用过期的邀请令牌，而你想告诉他们令牌已过期，你的服务器不应该在解析过程中抛出错误。它应该返回包含<code class="fe lc ld le lf b">error</code>字段的正常有效载荷。它可以像字符串一样简单，也可以像您希望的那样复杂:</p><pre class="lg lh li lj gt lk lf ll lm aw ln bi"><span id="93c9" class="lo lp iq lf b gy lq lr l ls lt"><em class="lb">return </em>{<br/>  error: {<br/>    id: '123',<br/>    type: 'expiredToken',<br/>    subType: 'expiredInvitationToken',<br/>    message: 'The invitation has expired, please request a new one',<br/>    title: 'Expired invitation',<br/>    helpText: 'https://yoursite.co/expired-invitation-token',<br/>    language: 'en-US'<br/>  }<br/>}</span></pre><p id="42b0" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">通过在模式中包含错误，生活变得容易多了:</p><ul class=""><li id="f199" class="mw mx iq ke b kf kg kj kk kn my kr mz kv na kz nk nc nd ne bi translated">所有错误在到达客户端之前都会被清理并准备好供查看器使用</li><li id="9464" class="mw mx iq ke b kf nf kj ng kn nh kr ni kv nj kz nk nc nd ne bi translated">您不需要抛出一个stringified对象并在客户端解析它</li><li id="008f" class="mw mx iq ke b kf nf kj ng kn nh kr ni kv nj kz nk nc nd ne bi translated">你不必用22种不同的语言发送同样的错误(你知道你是谁)</li><li id="3b59" class="mw mx iq ke b kf nf kj ng kn nh kr ni kv nj kz nk nc nd ne bi translated">您可以将相同的错误作为面包屑发送到您的错误日志记录服务</li><li id="4253" class="mw mx iq ke b kf nf kj ng kn nh kr ni kv nj kz nk nc nd ne bi translated">最重要的是，<em class="lb">你的GraphQL </em> <code class="fe lc ld le lf b"><em class="lb">errors</em></code> <em class="lb">数组不会包含任何面向用户的错误</em>，这意味着你的UI不会忽略它们！</li></ul><p id="cb82" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">对于突变(和订阅)，这是一个简单的销售。如果你遵循我的订阅混合方法，那就更容易了，因为你的订阅重用了你的突变负载。但是查询呢？现在GraphQL最佳实践中存在一个二分法:变异和订阅返回一个充满类型的有效载荷，但是查询只返回一个类型。以我的错误为例，想象一个请求，其中<code class="fe lc ld le lf b">team</code>成功了，但是<code class="fe lc ld le lf b">notifications</code>失败了:</p><pre class="lg lh li lj gt lk lf ll lm aw ln bi"><span id="936c" class="lo lp iq lf b gy lq lr l ls lt">mainQuery {<br/>  team {  #succeeds<br/>    name<br/>  }<br/>  notifications { #fails<br/>    text<br/>  }<br/>}</span></pre><p id="6fef" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">为了避免丢失部分数据，我们认为整个事情是成功的，但是这样做，我们丢失了错误！怎样才能两者兼得？由于上面列出的原因，我们不能回头抛出错误，但是将每个对象包装成一个有效负载会非常难看:</p><pre class="lg lh li lj gt lk lf ll lm aw ln bi"><span id="a9d0" class="lo lp iq lf b gy lq lr l ls lt">mainQuery {<br/>  teamPayload {<br/>    error {<br/>      message<br/>    }<br/>    team {<br/>      name<br/>    }<br/>  }<br/>  notificationPayload {<br/>    error {<br/>      message<br/>    }<br/>    notifications {<br/>      text<br/>    }<br/>  }<br/>}</span></pre><p id="67de" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">虽然这并不理想，但只有当用户界面需要知道错误时才适用。听起来熟悉吗？它的功能就像React 中的<a class="ae la" href="https://reactjs.org/blog/2017/07/26/error-handling-in-react-16.html" rel="noopener ugc nofollow" target="_blank">错误边界:</a></p><blockquote class="nl nm nn"><p id="723c" class="kc kd lb ke b kf kg kh ki kj kk kl km no ko kp kq np ks kt ku nq kw kx ky kz ij bi translated">错误边界的粒度由您决定。您可以包装顶级路由组件以向用户显示“出错”消息，就像服务器端框架通常处理崩溃一样。您还可以将单个小部件封装在一个错误边界中，以防止它们破坏应用程序的其余部分。</p></blockquote><p id="98bd" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">因此，如果返回一个<code class="fe lc ld le lf b">null</code>或空数组就足够了，那么继续前进；但是将事件发送到您的异常管理器进行跟踪。如果您注意到某个特定的查询片段经常失败，那么您可以使用一个有效负载来包装它，以创建一个伪错误边界。虽然艺术多于科学，但这意味着我对所有GraphQL操作一视同仁，我不会不必要地膨胀我的整个模式。</p><p id="c15e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在说到信任客户端，如果客户端不应该看到它，您的服务器就不应该发送它，这就把我们带到了最后一个处理程序。</p><h1 id="11cf" class="lu lp iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">如何(对客户)隐藏自己的缺点</h1><p id="300e" class="pw-post-body-paragraph kc kd iq ke b kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv mv kx ky kz ij bi translated">还记得过去的美好时光吗？那时<em class="lb">所有</em>的错误都是无意的。如今，玩catch出错比实际玩catch更常见(看看你对v17疯狂承诺的反应)。</p><p id="d702" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在将我们有意抛出的错误重构到我们的响应有效负载中的常规字段后，任何剩余的错误都必须是无意的(即开发人员错误)，这意味着我们应该掩盖我们的踪迹，并用类似于“服务器错误”的模糊内容替换<code class="fe lc ld le lf b">message</code>。在完美的世界中，这些将被捕获、净化，并作为响应中的错误属性返回，但是您永远不会捕获所有的错误(因此您可以停止在try/catch中包装每一个语句)。我们仍然把真正的错误发送给我们的日志服务，这样我们可以在任何人知道它坏了之前修复它，但是客户端永远不会看到它，因为错误可能包括敏感的东西，比如我们在生产中使用的实际数据库查询。除了模糊的<code class="fe lc ld le lf b">message</code>，保留错误的<code class="fe lc ld le lf b">path</code>也是值得的，因为这将帮助我们确定错误发生在哪里。同样，简单是最好的:<strong class="ke ir">对于</strong> <code class="fe lc ld le lf b"><strong class="ke ir">errors</strong></code> <strong class="ke ir">中的每一个错误，发送一个通用的消息和路径到客户端，并附上部分数据。</strong></p><p id="e426" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">一旦结果出现在客户机上，它将被作为一个成功的请求来处理。您甚至可以忽略这些错误，这样就很好了(如果这是一个查询，您可能必须这样做！).然而，如果你想利用它，你仍然可以在任何有<code class="fe lc ld le lf b">errors</code>数组的地方引用它。将所有这些放在一起，这是它在Relay Modern中的样子:</p><pre class="lg lh li lj gt lk lf ll lm aw ln bi"><span id="0b94" class="lo lp iq lf b gy lq lr l ls lt"><em class="lb">// Called for error types 1-4 (5xx, 4xx, missing/invalid query)<br/>const </em>onError = (err) =&gt; {<br/>  <em class="lb">this</em>.setState({err})<br/>}<br/><br/><em class="lb">const </em>onCompleted = (result, errs) =&gt; {<br/>  <em class="lb">// Called for error type 6 (eg unexpected missing DB field)<br/>  const </em>err = errs.find(({path}) =&gt; path.includes('approve'));<br/>  <em class="lb">if </em>(err) {<br/>    onError(err.message);<br/>  }<br/>  <br/>  <em class="lb">// called for error type 5 (eg expired auth token)<br/>  const </em>{approve: {error: {message}}} = result;<br/>  onError(message);<br/>}<br/><br/>commitMutation(env, {mutation, onCompleted, onError})</span></pre><p id="388f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">请记住，这对于突变非常有效，但是查询和订阅会吞下错误，除非它们被抛出，这意味着如果您希望它出现在您的UI中，您最好将它放在您的模式中！</p><h1 id="fd0d" class="lu lp iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">结论</h1><p id="a3db" class="pw-post-body-paragraph kc kd iq ke b kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv mv kx ky kz ij bi translated">TL；博士；医生</p><ul class=""><li id="cdd9" class="mw mx iq ke b kf kg kj kk kn my kr mz kv na kz nk nc nd ne bi translated">如果GraphQL给你<code class="fe lc ld le lf b">results.data</code>，那就不是错误，不要扔在客户端。</li><li id="3d5c" class="mw mx iq ke b kf nf kj ng kn nh kr ni kv nj kz nk nc nd ne bi translated">如果查看器应该看到错误，则将错误作为响应有效负载中的一个字段返回。如果是查询，就做一个响应负载。</li><li id="9f94" class="mw mx iq ke b kf nf kj ng kn nh kr ni kv nj kz nk nc nd ne bi translated">用通用消息替换任何剩余的GraphQL <code class="fe lc ld le lf b">errors</code>,但是不要把它扔到客户端，也不要期望UI总是能够处理它。</li></ul><p id="fee0" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">无论是查询、变异还是订阅，我们确定了请求在返回<em class="lb"/>graph QL响应时可能遇到的6种不同类型的错误。我们提出了<em class="lb"> </em>策略来保证部分数据永远不会被客户端忽略。最后，我们确保查看者总是看到我们希望他们看到的错误(仅此而已！).我们还设法避免了像<code class="fe lc ld le lf b">GraphQLConnectionError</code>这样抛出自定义错误的又深又黑的兔子洞，尽管它们有缺点，但看起来还是很受欢迎。你如何处理错误？这是不是已经是常识了，我只是派对迟到了？让我知道。</p></div></div>    
</body>
</html>