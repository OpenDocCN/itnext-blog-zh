<html>
<head>
<title>How to create Tensorflow 2 Sequence Dataset from scratch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何从头开始创建Tensorflow 2序列数据集</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-create-tensorflow-2-sequence-dataset-from-scratch-aaf9f1903f20?source=collection_archive---------3-----------------------#2019-12-28">https://itnext.io/how-to-create-tensorflow-2-sequence-dataset-from-scratch-aaf9f1903f20?source=collection_archive---------3-----------------------#2019-12-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/c31ed92b6078eafe3a4fdb9bd40a0a2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*aji2C-gJbnWtz6gR.png"/></div></div></figure><h1 id="79df" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">问题是</h1><p id="4d08" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">现代机器学习解决方案需要大量的数据，在处理图像识别/对象检测时肯定是这种情况。因此，我们需要创建越来越复杂的数据集来教授我们的模型。此时，我们无法将全部内容存储在内存中(有时甚至硬盘也会出现问题)，Tensorflow的<strong class="ky ir">数据集</strong>通常无法直接读取该数据集的描述。这就是为什么我们需要创建一个现代的解决方案，使用序列以易于理解的方式处理和预处理大量的数据。</p><blockquote class="lu lv lw"><p id="6cae" class="kw kx lx ky b kz ly lb lc ld lz lf lg ma mb lj lk mc md ln lo me mf lr ls lt ij bi translated"><strong class="ky ir"><em class="iq"/></strong><em class="iq">:</em></p><p id="820a" class="kw kx lx ky b kz ly lb lc ld lz lf lg ma mb lj lk mc md ln lo me mf lr ls lt ij bi translated"><em class="iq">这里有一个代码:</em><a class="ae mg" href="https://gist.github.com/burnpiro/c3835a1f914545f2034f4190b1e83153" rel="noopener ugc nofollow" target="_blank"><em class="iq">https://gist . github . com/burn piro/c 3835 a 1 f 914545 f 2034 f 4190 B1 e 83153</em></a></p><p id="96ff" class="kw kx lx ky b kz ly lb lc ld lz lf lg ma mb lj lk mc md ln lo me mf lr ls lt ij bi translated"><em class="iq">使用序列使数据集可维护且快速。</em></p></blockquote><h1 id="7230" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">顺序是什么？</h1><p id="b6f5" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">根据文件，顺序是:</p><blockquote class="lu lv lw"><p id="dddf" class="kw kx lx ky b kz ly lb lc ld lz lf lg ma mb lj lk mc md ln lo me mf lr ls lt ij bi translated"><strong class="ky ir"> <em class="iq">基对象用于拟合一系列数据，如数据集。</em>T24】</strong></p></blockquote><p id="be6d" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh mb lj lk ll md ln lo lp mf lr ls lt ij bi translated">使用<a class="ae mg" href="https://github.com/tensorflow/tensorflow/blob/r2.0/tensorflow/python/keras/utils/data_utils.py#L331-L406" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">序列类</strong> </a>创建序列对象。最棒的是我们可以扩展它。每个序列必须实现3个方法:</p><ul class=""><li id="394a" class="mh mi iq ky b kz ly ld lz lh mj ll mk lp ml lt mm mn mo mp bi translated"><code class="fe mq mr ms mt b">__getitem__</code> -用于从数据集中提取项目</li><li id="2751" class="mh mi iq ky b kz mu ld mv lh mw ll mx lp my lt mm mn mo mp bi translated"><code class="fe mq mr ms mt b">__len__</code> -返回数据集的长度</li><li id="1f2b" class="mh mi iq ky b kz mu ld mv lh mw ll mx lp my lt mm mn mo mp bi translated"><code class="fe mq mr ms mt b">__init__</code> -初始化我们的数据集(这不是必需的，但我们需要某种初始化)</li></ul><p id="94b3" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh mb lj lk ll md ln lo lp mf lr ls lt ij bi translated">Sequence允许我们创建复杂的数据集，甚至通过实现<code class="fe mq mr ms mt b">on_epoch_end</code>在每个时期结束时修改它们。我们将只关注这三种方法，但是如果你能玩<code class="fe mq mr ms mt b">on_epoch_end</code>。</p><h1 id="c2d8" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">我们的测试数据集</h1><p id="f7b1" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">在我们的例子中，我们将使用更宽的人脸数据集</p><blockquote class="lu lv lw"><p id="f01d" class="kw kx lx ky b kz ly lb lc ld lz lf lg ma mb lj lk mc md ln lo me mf lr ls lt ij bi translated"><em class="iq">指令如何获取数据集是</em> <a class="ae mg" href="https://github.com/burnpiro/tiny-face-detection-tensorflow2#dataset" rel="noopener ugc nofollow" target="_blank"> <em class="iq">这里是</em> </a></p></blockquote><p id="8adc" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh mb lj lk ll md ln lo lp mf lr ls lt ij bi translated">该数据集包含超过32k的图像，重量约为2GB，因此我们并不真的希望一直将它保存在内存中。该数据集用于教导对象检测模型，因此它包含图像上每个面的边界框。</p><h2 id="c123" class="mz jz iq bd ka na nb dn ke nc nd dp ki lh ne nf km ll ng nh kq lp ni nj ku nk bi translated">数据结构</h2><p id="aa23" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">数据集已经被分割成<strong class="ky ir">训练</strong>和<strong class="ky ir">验证</strong>，所以我们不必再做一遍。我们有两个文件夹:<strong class="ky ir"> WIDER_train </strong>和<strong class="ky ir"> WIDER_val </strong>。图像描述存储在<code class="fe mq mr ms mt b">wider_face_train_bbx_gt.txt</code>和<code class="fe mq mr ms mt b">wider_face_val_bbx_gt.txt</code>中。这是其中一张图片的例子</p><figure class="nl nm nn no gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/b7eacd9247bd18e79579d580e63f19db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*3Se8vtjVB3CWsFaI.jpg"/></div></div></figure><p id="6205" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh mb lj lk ll md ln lo lp mf lr ls lt ij bi translated"><code class="fe mq mr ms mt b">.txt</code>文件中的图像描述如下:</p><pre class="nl nm nn no gt np mt nq nr aw ns bi"><span id="0e6d" class="mz jz iq mt b gy nt nu l nv nw">22--Picnic/22_Picnic_Picnic_22_277.jpg <br/>3 <br/>196 410 74 114 1 0 0 0 0 0 <br/>344 404 62 88 1 0 0 0 0 0 <br/>634 222 58 86 1 0 0 0 0 0</span></pre><p id="2e51" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh mb lj lk ll md ln lo lp mf lr ls lt ij bi translated">乍一看可能不清楚，但数据集的自述文件中解释了一切:</p><pre class="nl nm nn no gt np mt nq nr aw ns bi"><span id="e09b" class="mz jz iq mt b gy nt nu l nv nw">File name <br/>Number of bounding box <br/>x1, y1, w, h, blur, expression, illumination, invalid, occlusion, pose</span></pre><p id="2cf3" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh mb lj lk ll md ln lo lp mf lr ls lt ij bi translated">所以我们的图像包含3个盒子。前两个数字是X和Y坐标，后面是框的宽度和高度。在此之后，我们有了更多关于盒子里面的人脸的信息，我们不打算使用这些信息，因为我们的目标只是物体检测(人脸检测),但请随意检查自述文件中的属性描述。</p><h2 id="b1df" class="mz jz iq bd ka na nb dn ke nc nd dp ki lh ne nf km ll ng nh kq lp ni nj ku nk bi translated">模型的输入和输出</h2><p id="fbc4" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">现在，在我们知道了数据集的样子之后，我们需要弄清楚什么是我们的<strong class="ky ir">模型</strong>的输入和输出。</p><blockquote class="lu lv lw"><p id="e186" class="kw kx lx ky b kz ly lb lc ld lz lf lg ma mb lj lk mc md ln lo me mf lr ls lt ij bi translated">如果你愿意，可以跳过这一部分。除了知道模型的输入和输出大小之外，没有必要知道任何东西来构造训练示例。</p><p id="2e41" class="kw kx lx ky b kz ly lb lc ld lz lf lg ma mb lj lk mc md ln lo me mf lr ls lt ij bi translated">输入— <strong class="ky ir"> 224x224x3 </strong></p><p id="b87e" class="kw kx lx ky b kz ly lb lc ld lz lf lg ma mb lj lk mc md ln lo me mf lr ls lt ij bi translated">输出— <strong class="ky ir"> 7x7x5 </strong></p><p id="88a3" class="kw kx lx ky b kz ly lb lc ld lz lf lg ma mb lj lk mc md ln lo me mf lr ls lt ij bi translated">依我看，理解它是有益的，但不是必需的。我选择了这个模型，因为大多数指南都使用回归网络中的简单例子，很难找到复杂例子的解决方案。</p></blockquote><p id="9e37" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh mb lj lk ll md ln lo lp mf lr ls lt ij bi translated">对于这个例子，我们将使用<strong class="ky ir"> MobileNetV2 </strong>(准确地说是<code class="fe mq mr ms mt b">mobilenet_v2_0.75_224</code>)，我们的模型的输入大小为<strong class="ky ir"> 224x224x3 </strong>(宽x高x RGB)。所以我们句子中的每个例子都必须产生这样大小的输入。</p><p id="b58c" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh mb lj lk ll md ln lo lp mf lr ls lt ij bi translated">另一方面，产量完全取决于我们。我们使用MobileNet作为特征提取器，从最后一个Conv层得到输出。我们希望保持7x7网格，并且我们的检测只需要每个网格5个值(因为我们只有一个类)。最终，我们的输出应该看起来像<strong class="ky ir"> 7x7x5 </strong>(网格宽度x网格宽度x类的数量乘以5)。</p><p id="f28e" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh mb lj lk ll md ln lo lp mf lr ls lt ij bi translated">我不打算讨论这个网络是如何工作的，你可以很容易地找到任何关于CNN以及如何使用它们作为对象检测的特征提取器的教程(也许将来会有其他指南)。</p><p id="5751" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh mb lj lk ll md ln lo lp mf lr ls lt ij bi translated">这是我们的模型最后的样子:</p><pre class="nl nm nn no gt np mt nq nr aw ns bi"><span id="554a" class="mz jz iq mt b gy nt nu l nv nw">____________________________________________________________________<br/>Layer (type) Output Shape Param # Connected to ====================================================================<br/>input_1 (InputLayer) [(None, 224, 224, 3) 0 ________________________________________________________________________ ----- Rest of MobileNetV2 ------ ____________________________________________________________________<br/>block_16_project_BN (BatchNorma (None, 7, 7, 240) 960 ____________________________________________________________________<br/>----- Our Layers conected to MobileNet output------ ____________________________________________________________________<br/>conv2d_2 (Conv2D) (None, 7, 7, 5) 1205</span></pre><p id="a516" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh mb lj lk ll md ln lo lp mf lr ls lt ij bi translated">现在应该很清楚，我们的数据集应该生成如下示例:</p><ul class=""><li id="6900" class="mh mi iq ky b kz ly ld lz lh mj ll mk lp ml lt mm mn mo mp bi translated">输入— <strong class="ky ir"> 224x224x3 </strong></li><li id="c493" class="mh mi iq ky b kz mu ld mv lh mw ll mx lp my lt mm mn mo mp bi translated">输出— <strong class="ky ir"> 7x7x5 </strong></li></ul><h1 id="0128" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">扩展序列类</h1><pre class="nl nm nn no gt np mt nq nr aw ns bi"><span id="8811" class="mz jz iq mt b gy nt nu l nv nw"># Data generator boilerplace<br/>class DataGenerator(tf.keras.utils.Sequence):</span><span id="bf71" class="mz jz iq mt b gy nx nu l nv nw">    def __init__(self, file_path, config_path, debug=False):<br/>        # Sequence initialization<br/>        <br/>    def __len__(self):<br/>        # Should return Sequence length</span><span id="6864" class="mz jz iq mt b gy nx nu l nv nw">    def __getitem__(self, idx):<br/>        # Returns preprocessed data</span></pre><h2 id="f368" class="mz jz iq bd ka na nb dn ke nc nd dp ki lh ne nf km ll ng nh kq lp ni nj ku nk bi translated">初始化</h2><p id="af09" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我们需要实现的第一件事是数据初始化。</p><pre class="nl nm nn no gt np mt nq nr aw ns bi"><span id="ff94" class="mz jz iq mt b gy nt nu l nv nw">def __init__(self, file_path, config_path, debug=False):<br/>        # Sequence initialization</span></pre><p id="5d8f" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh mb lj lk ll md ln lo lp mf lr ls lt ij bi translated">因为数据集描述位于两个不同的文件中(一个用于训练，一个用于验证)，所以我们需要传递图像文件夹的路径(<code class="fe mq mr ms mt b">file_path</code>)和数据集规范的路径(<code class="fe mq mr ms mt b">config_path</code>)。<code class="fe mq mr ms mt b">debug</code>选项允许我们在处理数据集时显示附加信息。</p><p id="cb33" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh mb lj lk ll md ln lo lp mf lr ls lt ij bi translated">在<code class="fe mq mr ms mt b">__init__</code>方法中，我们可以访问<code class="fe mq mr ms mt b">self</code>对象。这个对象代表我们的序列，我们想在它上面初始化一些默认值。</p><pre class="nl nm nn no gt np mt nq nr aw ns bi"><span id="e0fb" class="mz jz iq mt b gy nt nu l nv nw">self.boxes = []<br/>self.debug = debug<br/>self.data_path = file_path</span></pre><ul class=""><li id="2e14" class="mh mi iq ky b kz ly ld lz lh mj ll mk lp ml lt mm mn mo mp bi translated"><code class="fe mq mr ms mt b">self.boxes</code>将存储数据集中的所有箱子定义</li><li id="b3e7" class="mh mi iq ky b kz mu ld mv lh mw ll mx lp my lt mm mn mo mp bi translated"><code class="fe mq mr ms mt b">self.debug</code>启用<strong class="ky ir">调试</strong>模式</li><li id="c110" class="mh mi iq ky b kz mu ld mv lh mw ll mx lp my lt mm mn mo mp bi translated"><code class="fe mq mr ms mt b">self.data_path</code>存储图像的路径，供以后处理</li></ul><p id="9870" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh mb lj lk ll md ln lo lp mf lr ls lt ij bi translated">初始化之后，我们需要检查路径是否有效(如果无效，就没有理由创建序列)。</p><pre class="nl nm nn no gt np mt nq nr aw ns bi"><span id="01e3" class="mz jz iq mt b gy nt nu l nv nw">if not os.path.isfile(config_path):<br/>    print("File path {} does not exist. Exiting...".format(config_path))<br/>    sys.exit()<br/><br/>if not os.path.isdir(file_path):<br/>    print("Images folder path {} does not exist. Exiting...".format(file_path))<br/>    sys.exit()</span></pre><p id="c63a" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh mb lj lk ll md ln lo lp mf lr ls lt ij bi translated">当一切正常时，我们可以开始读取配置文件</p><pre class="nl nm nn no gt np mt nq nr aw ns bi"><span id="e2bc" class="mz jz iq mt b gy nt nu l nv nw">with open(config_path) as fp:<br/>    image_name = fp.readline()<br/>    cnt = 1<br/>    while image_name:<br/>        # image_name - relative path to our image<br/>        # in this loop we have to process each image definition</span></pre><p id="12ec" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh mb lj lk ll md ln lo lp mf lr ls lt ij bi translated">我们将逐行读取该文件，但正如您所记得的，该文件是以一种特定的方式构建的:</p><pre class="nl nm nn no gt np mt nq nr aw ns bi"><span id="b2be" class="mz jz iq mt b gy nt nu l nv nw">File name<br/>Number of bounding box<br/>x1, y1, w, h, blur, expression, illumination, invalid, occlusion, pose</span></pre><p id="81b0" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh mb lj lk ll md ln lo lp mf lr ls lt ij bi translated">因此，在读取了<strong class="ky ir">文件名</strong>和<strong class="ky ir">边界框编号</strong>后，我们需要使用该编号来了解要读取多少行作为边界框定义。</p><pre class="nl nm nn no gt np mt nq nr aw ns bi"><span id="b134" class="mz jz iq mt b gy nt nu l nv nw">with open(config_path) as fp:<br/>    image_name = fp.readline()<br/>    cnt = 1<br/>    while image_name:<br/>        num_of_obj = int(fp.readline())<br/>        for i in range(num_of_obj):<br/>            obj_box = fp.readline().split(' ')<br/>            x0, y0, w, h = get_box(obj_box)<br/>            if w == 0:<br/>                # remove boxes with no width<br/>                continue<br/>            if h == 0:<br/>                # remove boxes with no height<br/>                continue<br/>            self.boxes.append((<!-- -->image_name<!-- -->.strip(), x0, y0, w, h))<br/>        <!-- -->image_name<!-- --> = fp.readline()<br/>        cnt += 1</span></pre><p id="8efc" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh mb lj lk ll md ln lo lp mf lr ls lt ij bi translated">我们在<code class="fe mq mr ms mt b">while</code>循环中要做的第一件事是提取有多少个盒子。为此，我们调用<code class="fe mq mr ms mt b">int(tf.readline()</code>，它将下一行的值作为一个整数返回。我们使用这个数字来迭代接下来的<code class="fe mq mr ms mt b">num_of_obj</code>行。每行值由一个空字符串分隔，因此我们必须在处理<code class="fe mq mr ms mt b">obj_box = fp.readline().split(' ')</code>之前分割值。我们感兴趣的是每行的前4个值，但这些值必须是整数。要提取这些值，创建一个辅助函数<code class="fe mq mr ms mt b">get_box</code>更容易:</p><pre class="nl nm nn no gt np mt nq nr aw ns bi"><span id="c42b" class="mz jz iq mt b gy nt nu l nv nw"># Input: [x0, y0, w, h, blur, expression, illumination, invalid, occlusion, pose]<br/># Output: x0, y0, w, h<br/>def get_box(data):<br/>    x0 = int(data[0])<br/>    y0 = int(data[1])<br/>    w = int(data[2])<br/>    h = int(data[3])<br/>    return x0, y0, w, h</span></pre><p id="d71d" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh mb lj lk ll md ln lo lp mf lr ls lt ij bi translated">这个函数接收一个字符串列表，并返回我们需要的4个整数。之后，我们将我们的盒子附加到序列对象<code class="fe mq mr ms mt b">self.boxes.append((image_name.strip(), x0, y0, w, h))</code>并读取下一行。</p><p id="072d" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh mb lj lk ll md ln lo lp mf lr ls lt ij bi translated">一切看起来都很好，我们应该准备好进入下一部分，但是如果我们试图执行这段代码，它将会失败。</p><pre class="nl nm nn no gt np mt nq nr aw ns bi"><span id="80e7" class="mz jz iq mt b gy nt nu l nv nw">ValueError: invalid literal for int( ) with base 10: '0--Parade/0_Parade_Parade_0_630.jpg\n'</span></pre><p id="fdef" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh mb lj lk ll md ln lo lp mf lr ls lt ij bi translated">我们在代码中犯了错误吗？不，我们没有。我们只是没有足够仔细地探索我们的数据集。如果我们跳到我们的<strong class="ky ir">。txt </strong>文件，找到那句话的那一行，刚刚发生的事情就清楚多了。</p><pre class="nl nm nn no gt np mt nq nr aw ns bi"><span id="c215" class="mz jz iq mt b gy nt nu l nv nw">0--Parade/0_Parade_Parade_0_452.jpg<br/>0<br/>0 0 0 0 0 0 0 0 0 0 <br/>0--Parade/0_Parade_Parade_0_630.jpg</span></pre><p id="8339" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh mb lj lk ll md ln lo lp mf lr ls lt ij bi translated">我们没有预料到会有没有脸的图像，因为我们的迭代是如何设计的，所以在阅读完<code class="fe mq mr ms mt b">num_of_obj = 0</code>后不会跳过有零的行。知道我们可以在for循环之后创建一个快速修复:</p><pre class="nl nm nn no gt np mt nq nr aw ns bi"><span id="9b69" class="mz jz iq mt b gy nt nu l nv nw">if num_of_obj == 0:<br/>    obj_box = fp.readline().split(' ')<br/>    x0, y0, w, h = get_box(obj_box)<br/>    self.boxes.append((<!-- -->image_name<!-- -->.strip(), x0, y0, w, h))</span></pre><p id="8cf9" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh mb lj lk ll md ln lo lp mf lr ls lt ij bi translated">这样，当图像上没有人脸时，我们将创建一个空示例。</p><h2 id="f0d3" class="mz jz iq bd ka na nb dn ke nc nd dp ki lh ne nf km ll ng nh kq lp ni nj ku nk bi translated">数据集的返回长度</h2><p id="bfce" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">这应该很容易…但并不容易:)在实现<code class="fe mq mr ms mt b">__len__</code>方法时，我们需要记住训练是分批进行的。因此，我们必须将盒子的数量除以我们的批量大小，并返回它，而不仅仅是数组的长度。</p><pre class="nl nm nn no gt np mt nq nr aw ns bi"><span id="f7d3" class="mz jz iq mt b gy nt nu l nv nw">def __len__(self):<br/>    return math.ceil(len(self.boxes) / cfg.TRAIN.BATCH_SIZE)</span></pre><p id="998b" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh mb lj lk ll md ln lo lp mf lr ls lt ij bi translated">注意，我们使用了一个神秘的配置，叫做<code class="fe mq mr ms mt b">cfg</code>。这只是一个保存我们数据集设置的<code class="fe mq mr ms mt b">EasyDict</code>字典。你现在不用担心它，我会在最后给你看它的定义。现在，假设它存储了所有的配置值。</p><h2 id="3ecc" class="mz jz iq bd ka na nb dn ke nc nd dp ki lh ne nf km ll ng nh kq lp ni nj ku nk bi translated">退回物品</h2><p id="d6dd" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">到目前为止，我们已经成功创建了我们的序列，但我们仍然没有定义如何处理数据集中的图像。序列中的每个框有5个值:</p><ul class=""><li id="307d" class="mh mi iq ky b kz ly ld lz lh mj ll mk lp ml lt mm mn mo mp bi translated">图像路径</li><li id="8951" class="mh mi iq ky b kz mu ld mv lh mw ll mx lp my lt mm mn mo mp bi translated">框中心的x值</li><li id="b36a" class="mh mi iq ky b kz mu ld mv lh mw ll mx lp my lt mm mn mo mp bi translated">框中心的y值</li><li id="c89b" class="mh mi iq ky b kz mu ld mv lh mw ll mx lp my lt mm mn mo mp bi translated">盒子宽度</li><li id="a814" class="mh mi iq ky b kz mu ld mv lh mw ll mx lp my lt mm mn mo mp bi translated">盒子高度</li></ul><p id="2c59" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh mb lj lk ll md ln lo lp mf lr ls lt ij bi translated"><code class="fe mq mr ms mt b">__getitem__(self, idx)</code>方法应该返回两个值(输入，输出)。但是因为我们是成批工作的，这些值将是包含多个图像和相应方框的数组。</p><pre class="nl nm nn no gt np mt nq nr aw ns bi"><span id="9cb3" class="mz jz iq mt b gy nt nu l nv nw">def __getitem__(self, idx):<br/>    boxes = self.boxes[idx * cfg.TRAIN.BATCH_SIZE:(idx + 1) * cfg.TRAIN.BATCH_SIZE]</span></pre><p id="9a60" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh mb lj lk ll md ln lo lp mf lr ls lt ij bi translated">首先，我们必须从给定的<strong class="ky ir"> idx </strong>到<strong class="ky ir"> idx + BATCH_SIZE </strong>中提取盒子定义。因此，如果我们的<strong class="ky ir"> BATCH_SIZE </strong>是<strong class="ky ir"> 16 </strong>并且<strong class="ky ir"> idx </strong>是<strong class="ky ir"> 0 </strong>，那么我们正在处理从<strong class="ky ir"> 0 </strong>到<strong class="ky ir"> 16 </strong>的箱子。</p><p id="8347" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh mb lj lk ll md ln lo lp mf lr ls lt ij bi translated">现在我们必须为输入和输出定义零矩阵</p><pre class="nl nm nn no gt np mt nq nr aw ns bi"><span id="c073" class="mz jz iq mt b gy nt nu l nv nw">batch_images = np.zeros((len(boxes), cfg.NN.INPUT_SIZE, cfg.NN.INPUT_SIZE, 3), dtype=np.float32)<br/>batch_boxes = np.zeros((len(boxes), cfg.NN.GRID_SIZE, cfg.NN.GRID_SIZE, 5), dtype=np.float32)</span></pre><ul class=""><li id="bdd9" class="mh mi iq ky b kz ly ld lz lh mj ll mk lp ml lt mm mn mo mp bi translated"><code class="fe mq mr ms mt b">batch_images</code>包含图像，大小为<strong class="ky ir"> 16x224x224x3 </strong>。</li><li id="b7c0" class="mh mi iq ky b kz mu ld mv lh mw ll mx lp my lt mm mn mo mp bi translated"><code class="fe mq mr ms mt b">batch_boxes</code>包含网格中的预期输出，大小为<strong class="ky ir"> 16x7x7x5 </strong>。</li></ul><p id="6498" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh mb lj lk ll md ln lo lp mf lr ls lt ij bi translated">现在我们必须迭代我们的批处理并处理每个例子。</p><pre class="nl nm nn no gt np mt nq nr aw ns bi"><span id="c1bb" class="mz jz iq mt b gy nt nu l nv nw">for i, row in enumerate(boxes):<br/>    path, x0, y0, w, h = row</span></pre><p id="2707" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh mb lj lk ll md ln lo lp mf lr ls lt ij bi translated">首先，我们必须从图像路径创建一个输入。为此，我们将使用<code class="fe mq mr ms mt b">tf.keras.preprocessing.image.load_img</code>。</p><pre class="nl nm nn no gt np mt nq nr aw ns bi"><span id="ad11" class="mz jz iq mt b gy nt nu l nv nw">proc_image = tf.keras.preprocessing.image.load_img(self.data_path + path)<br/><br/>image_width = proc_image.width<br/>image_height = proc_image.height<br/><br/>proc_image = tf.keras.preprocessing.image.load_img(self.data_path + path,<br/>                                               target_size=(cfg.NN.INPUT_SIZE, cfg.NN.INPUT_SIZE))<br/><br/>proc_image = tf.keras.preprocessing.image.img_to_array(proc_image)<br/>proc_image = np.expand_dims(proc_image, axis=0)<br/>proc_image - tf.keras.applications.mobilenet_v2.preprocess_input(proc_image)<br/><br/>batch_images[i] = proc_image</span></pre><p id="7d11" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh mb lj lk ll md ln lo lp mf lr ls lt ij bi translated">对于每个图像，我们需要提取原始的宽度和高度，以便能够缩放盒子的x0，y0，w，h。这就是为什么我们调用这个方法两次(第二次将<code class="fe mq mr ms mt b">target_size</code>设置为<strong class="ky ir"> 224x224 </strong>)。最后，我们处理后的图像存储在<code class="fe mq mr ms mt b">batch_images</code>中。</p><p id="78ba" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh mb lj lk ll md ln lo lp mf lr ls lt ij bi translated">接下来，我们必须处理盒子的位置和大小。原始值是整数，代表原始图像上的一个点。我们需要做的是将它们换算成<strong class="ky ir"> &lt; 0，1 &gt; </strong>值。这就是为什么我们需要原图中的<code class="fe mq mr ms mt b">image_width</code>和<code class="fe mq mr ms mt b">image_height</code>。</p><pre class="nl nm nn no gt np mt nq nr aw ns bi"><span id="2e0d" class="mz jz iq mt b gy nt nu l nv nw">    image_width = proc_image.width<br/>    image_height = proc_image.height<br/><br/>    # make sure none of the points is out of image border<br/>    x0 = max(x0, 0)<br/>    y0 = max(y0, 0)<br/><br/>    x0 = min(x0, image_width)<br/>    y0 = min(y0, image_height)<br/><br/>    x_c = (cfg.NN.GRID_SIZE / image_width) * x0<br/>    y_c = (cfg.NN.GRID_SIZE / image_height) * y0<br/><br/>    floor_y = math.floor(y_c)  # handle case when x i on the corner<br/>    floor_x = math.floor(x_c)  # handle case when y i on the corner<br/><br/>    batch_boxes[i, floor_y, floor_x, 0] = h / image_height<br/>    batch_boxes[i, floor_y, floor_x, 1] = w / image_width<br/>    batch_boxes[i, floor_y, floor_x, 2] = y_c - floor_y<br/>    batch_boxes[i, floor_y, floor_x, 3] = x_c - floor_x<br/>    batch_boxes[i, floor_y, floor_x, 4] = 1</span></pre><p id="c977" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh mb lj lk ll md ln lo lp mf lr ls lt ij bi translated">这部分应用额外的验证来确保我们的点位于图像内部。除了我们计算那个点相对于它所在的网格单元的位置。</p><figure class="nl nm nn no gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/47ac3582bd6e77610e6e669abe692aa4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*fPfxf7-o9iISsE97.png"/></div></div></figure><p id="7c87" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh mb lj lk ll md ln lo lp mf lr ls lt ij bi translated">此点的默认值可能是:</p><ul class=""><li id="3000" class="mh mi iq ky b kz ly ld lz lh mj ll mk lp ml lt mm mn mo mp bi translated">x = 0.35(相对于左上角)</li><li id="07ba" class="mh mi iq ky b kz mu ld mv lh mw ll mx lp my lt mm mn mo mp bi translated">y = 0.35(相对于左上角)</li></ul><p id="8e29" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh mb lj lk ll md ln lo lp mf lr ls lt ij bi translated">但是我们的输出需要相对于网格单元(包含点的单元)的位置。因为新的坐标如下:</p><ul class=""><li id="b399" class="mh mi iq ky b kz ly ld lz lh mj ll mk lp ml lt mm mn mo mp bi translated">x = 0.5(相对于单元格左上角)</li><li id="b7f6" class="mh mi iq ky b kz mu ld mv lh mw ll mx lp my lt mm mn mo mp bi translated">y = 0.5(相对于单元格左上角)</li></ul><p id="3117" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh mb lj lk ll md ln lo lp mf lr ls lt ij bi translated">最后，我们将这些值保存在第I个输出和3x3网格单元中(其余的保持为零)。请注意，盒子的<strong class="ky ir">宽度</strong>和<strong class="ky ir">高度</strong>仍然按比例缩放到完整图像。</p><p id="73bb" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh mb lj lk ll md ln lo lp mf lr ls lt ij bi translated">在我们处理完批处理中的所有例子后，我们只需要返回两个数组</p><pre class="nl nm nn no gt np mt nq nr aw ns bi"><span id="6759" class="mz jz iq mt b gy nt nu l nv nw">return batch_images, batch_boxes</span></pre><p id="d981" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh mb lj lk ll md ln lo lp mf lr ls lt ij bi translated">要使用我们的生成器，只需创建它的一个实例并传递正确的路径</p><pre class="nl nm nn no gt np mt nq nr aw ns bi"><span id="8f0a" class="mz jz iq mt b gy nt nu l nv nw">train_datagen = DataGenerator(file_path=cfg.TRAIN.DATA_PATH, config_path=cfg.TRAIN.ANNOTATION_PATH)<br/>val_generator = DataGenerator(file_path=cfg.TEST.DATA_PATH, config_path=cfg.TEST.ANNOTATION_PATH, debug=False)</span></pre><p id="7760" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh mb lj lk ll md ln lo lp mf lr ls lt ij bi translated">现在我们可以将数据用于训练</p><pre class="nl nm nn no gt np mt nq nr aw ns bi"><span id="a846" class="mz jz iq mt b gy nt nu l nv nw">model.fit_generator(generator=train_datagen,<br/>                        epochs=cfg.TRAIN.EPOCHS,<br/>                        callbacks=[# your callbacks for TF],<br/>                        shuffle=True,<br/>                        verbose=1)</span></pre><p id="8839" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh mb lj lk ll md ln lo lp mf lr ls lt ij bi translated">以下是<strong class="ky ir">数据生成器</strong>类的完整代码:<a class="ae mg" href="https://gist.github.com/burnpiro/c3835a1f914545f2034f4190b1e83153" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/burn piro/c 3835 a 1 f 914545 f 2034 f 4190 B1 e 83153</a></p><h1 id="ccd1" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">摘要</h1><p id="e7ac" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">如果您正在处理复杂的数据集(或非常大的数据集)，那么考虑序列并为数据生成创建自己的序列类是一个好主意。它高效(开箱即用的多线程)且易于维护，尤其是在与工程师和版本控制团队合作时。</p><p id="7853" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh mb lj lk ll md ln lo lp mf lr ls lt ij bi translated">这段代码只是一个例子，您的实现可能看起来有所不同。一切都取决于特定的问题和数据集的结构，但我认为在类内定义数据处理比使用Tensorflow指南中的类似C的方法要容易得多。</p><p id="0a82" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh mb lj lk ll md ln lo lp mf lr ls lt ij bi translated">新年快乐，2020年再见！！！</p></div><div class="ab cl ny nz hu oa" role="separator"><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od"/></div><div class="ij ik il im in"><p id="da56" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh mb lj lk ll md ln lo lp mf lr ls lt ij bi translated"><em class="lx">最初发布于</em><a class="ae mg" href="https://erdem.pl/2019/12/how-to-create-tensorflow-2-sequence-dataset-from-scratch" rel="noopener ugc nofollow" target="_blank"><em class="lx">https://erdem . pl</em></a><em class="lx">。</em></p></div></div>    
</body>
</html>