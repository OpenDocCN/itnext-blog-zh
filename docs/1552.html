<html>
<head>
<title>Password Reset Emails In Your React App Made Easy with Nodemailer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Nodemailer简化React应用程序中的密码重置电子邮件</h1>
<blockquote>原文：<a href="https://itnext.io/password-reset-emails-in-your-react-app-made-easy-with-nodemailer-bb27968310d7?source=collection_archive---------0-----------------------#2018-11-22">https://itnext.io/password-reset-emails-in-your-react-app-made-easy-with-nodemailer-bb27968310d7?source=collection_archive---------0-----------------------#2018-11-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><h1 id="be1e" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">在JavaScript应用程序中重置密码并不复杂</h1><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/f86581419119d30c65958cf9aef939ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LlYcAoiR_1FakdL5FmTxRw.png"/></div></div></figure><h2 id="0775" class="la jr it bd js lb lc dn jw ld le dp ka lf lg lh ke li lj lk ki ll lm ln km lo bi translated"><strong class="ak">MERN应用程序中的密码重置</strong></h2><p id="705a" class="pw-post-body-paragraph lp lq it lr b ls lt lu lv lw lx ly lz lf ma mb mc li md me mf ll mg mh mi mj im bi mk translated"><span class="l ml mm mn bm mo mp mq mr ms di"> B </span>在我真正尝试为我的MERN应用程序内置一个基于电子邮件的密码重置功能之前，我认为这会更难做到。根据我之前听到的一切，在JavaScript应用程序中发送电子邮件是痛苦的，但我仍然想尝试一下。</p><p id="0eb0" class="pw-post-body-paragraph lp lq it lr b ls mt lu lv lw mu ly lz lf mv mb mc li mw me mf ll mx mh mi mj im bi translated">几个月来，为了磨练我的全部JavaScript技能，我一直在慢慢构建并添加一个用户注册服务<a class="ae my" href="https://github.com/paigen11/mysql-registration-passport" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="ce7f" class="pw-post-body-paragraph lp lq it lr b ls mt lu lv lw mu ly lz lf mv mb mc li mw me mf ll mx mh mi mj im bi translated">首先，我用React前端、Express / Node.js后端和Docker支持的MySQL数据库构建了它。我使用了一个<code class="fe mz na nb nc b">docker-compose.yml</code>来用一个命令启动整个应用程序(如果你想了解更多关于我使用Docker进行开发的信息，你可以看看这篇<a class="ae my" href="https://medium.com/@paigen11/using-docker-docker-compose-to-improve-your-full-stack-application-development-1e41280748f4" rel="noopener">博文</a>)。</p><p id="cdec" class="pw-post-body-paragraph lp lq it lr b ls mt lu lv lw mu ly lz lf mv mb mc li mw me mf ll mx mh mi mj im bi translated">在我完成这项工作后，我使用Passport.js和JSON Web token(jwt)向应用程序添加了授权。如果你好奇的话，你可以在这里读到那个<a class="ae my" rel="noopener ugc nofollow" target="_blank" href="/implementing-json-web-tokens-passport-js-in-a-javascript-application-with-react-b86b1f313436">的乐趣(痛苦)。这花了我一段时间——我遇到了一堆路障和障碍，多次让我止步不前。但是，一旦问题在我的大脑中扎根，我的勇气和我无法放弃它的能力占了上风，我找到了它并继续前进。</a></p><p id="f17f" class="pw-post-body-paragraph lp lq it lr b ls mt lu lv lw mu ly lz lf mv mb mc li mw me mf ll mx mh mi mj im bi translated">当我决定通过电子邮件发送密码重置链接时(就像真实的网站一样，包括我在内的用户不可避免地会忘记他们的密码)，我想我会更加痛苦。这太简单了，尽管几乎每个网站都有这个功能。但我错了。我很高兴我是。</p><h2 id="5574" class="la jr it bd js lb lc dn jw ld le dp ka lf lg lh ke li lj lk ki ll lm ln km lo bi translated">node mailer——神奇的子弹</h2><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/631ef1d6e5528f26e105b32ab8bcce9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:486/format:webp/1*srax5uIJJj_5mUkCtEI8xQ.png"/></div></figure><p id="4da6" class="pw-post-body-paragraph lp lq it lr b ls mt lu lv lw mu ly lz lf mv mb mc li mw me mf ll mx mh mi mj im bi translated">当我开始在谷歌上寻找我的密码重置功能的解决方案时，我看到了一些推荐<a class="ae my" href="https://nodemailer.com/about/" rel="noopener ugc nofollow" target="_blank"> Nodemailer </a>的文章。</p><p id="1643" class="pw-post-body-paragraph lp lq it lr b ls mt lu lv lw mu ly lz lf mv mb mc li mw me mf ll mx mh mi mj im bi translated">当我访问该网站时，我读到的第一行是:</p><blockquote class="ne nf ng"><p id="13cd" class="lp lq nh lr b ls mt lu lv lw mu ly lz ni mv mb mc nj mw me mf nk mx mh mi mj im bi translated">Nodemailer是Node.js应用程序的一个模块，可以轻松发送电子邮件。该项目始于2010年，当时没有发送电子邮件的合理选项，今天它是大多数Node.js用户默认采用的解决方案。—节点邮件程序</p></blockquote><p id="2877" class="pw-post-body-paragraph lp lq it lr b ls mt lu lv lw mu ly lz lf mv mb mc li mw me mf ll mx mh mi mj im bi translated">你知道吗？这不是开玩笑。易如反掌不会错太多。</p><p id="3a16" class="pw-post-body-paragraph lp lq it lr b ls mt lu lv lw mu ly lz lf mv mb mc li mw me mf ll mx mh mi mj im bi translated">当然，在我开始之前，我做了更多的调查，以确保我对一项像样的技术抱有信心，我在<a class="ae my" href="https://www.npmjs.com/package/nodemailer" rel="noopener ugc nofollow" target="_blank"> NPM </a>和<a class="ae my" href="https://github.com/nodemailer/nodemailer" rel="noopener ugc nofollow" target="_blank"> Github </a>上看到的东西让我放心。</p><p id="32b6" class="pw-post-body-paragraph lp lq it lr b ls mt lu lv lw mu ly lz lf mv mb mc li mw me mf ll mx mh mi mj im bi translated">节点邮件程序具有:</p><ul class=""><li id="5d58" class="nl nm it lr b ls mt lw mu lf nn li no ll np mj nq nr ns nt bi translated">来自NPM的每周下载超过615，000次，</li><li id="cf14" class="nl nm it lr b ls nu lw nv lf nw li nx ll ny mj nq nr ns nt bi translated">Github上超过10，000颗星星，</li><li id="bfd8" class="nl nm it lr b ls nu lw nv lf nw li nx ll ny mj nq nr ns nt bi translated">迄今为止发行了206次，</li><li id="a85c" class="nl nm it lr b ls nu lw nv lf nw li nx ll ny mj nq nr ns nt bi translated">超过2500个依赖包，</li><li id="4bf9" class="nl nm it lr b ls nu lw nv lf nw li nx ll ny mj nq nr ns nt bi translated">自2010年以来，它一直以某种形式或时尚存在。</li></ul><p id="7699" class="pw-post-body-paragraph lp lq it lr b ls mt lu lv lw mu ly lz lf mv mb mc li mw me mf ll mx mh mi mj im bi translated">好吧，这似乎足够让我在自己的项目中尝试一下。</p><h2 id="7f36" class="la jr it bd js lb lc dn jw ld le dp ka lf lg lh ke li lj lk ki ll lm ln km lo bi translated">在我的代码中实现Nodemailer(前端和后端)</h2><p id="7b58" class="pw-post-body-paragraph lp lq it lr b ls lt lu lv lw lx ly lz lf ma mb mc li md me mf ll mg mh mi mj im bi translated">我的密码重置不需要任何花哨的东西，只需要:</p><ul class=""><li id="af75" class="nl nm it lr b ls mt lw mu lf nn li no ll np mj nq nr ns nt bi translated">一种向用户地址发送电子邮件的方式，</li><li id="5b9a" class="nl nm it lr b ls nu lw nv lf nw li nx ll ny mj nq nr ns nt bi translated">该电子邮件将包含一个链接，将他们重定向到我的网站上的一个受保护的页面，他们可以在那里重置密码，</li><li id="712e" class="nl nm it lr b ls nu lw nv lf nw li nx ll ny mj nq nr ns nt bi translated">然后他们可以使用新密码登录。</li><li id="72c9" class="nl nm it lr b ls nu lw nv lf nw li nx ll ny mj nq nr ns nt bi translated">我还希望密码重置链接在一段时间后过期，以获得更好的安全性。</li></ul><p id="c75d" class="pw-post-body-paragraph lp lq it lr b ls mt lu lv lw mu ly lz lf mv mb mc li mw me mf ll mx mh mi mj im bi translated">我是这样做的。</p><h2 id="d27b" class="la jr it bd js lb lc dn jw ld le dp ka lf lg lh ke li lj lk ki ll lm ln km lo bi translated">前端代码(客户端文件夹)—发送重置电子邮件</h2><p id="6ed1" class="pw-post-body-paragraph lp lq it lr b ls lt lu lv lw lx ly lz lf ma mb mc li md me mf ll mg mh mi mj im bi translated">我将首先从React代码开始，因为我必须有一个页面，用户可以在其中输入他们的电子邮件地址并发送带有重置链接的电子邮件。</p><p id="c0a2" class="pw-post-body-paragraph lp lq it lr b ls mt lu lv lw mu ly lz lf mv mb mc li mw me mf ll mx mh mi mj im bi translated"><code class="fe mz na nb nc b"><strong class="lr iu">ForgotPassword.js</strong></code></p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nz"><img src="../Images/ab3ca25640d3d179a21dc94f64db1af0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r9V8XUjaYw-QBnLqv4kPiA.png"/></div></div></figure><p id="42cc" class="pw-post-body-paragraph lp lq it lr b ls mt lu lv lw mu ly lz lf mv mb mc li mw me mf ll mx mh mi mj im bi translated">好吧，我知道这是一个很大的截图，但我会分解它(我在VS代码中使用了<a class="ae my" href="https://github.com/octref/polacode" rel="noopener ugc nofollow" target="_blank"> Polacode </a>扩展来制作这个漂亮的截图，仅供参考)。如果你想复制/粘贴实际代码，你可以在这里看到整个回购<a class="ae my" href="https://github.com/paigen11/mysql-registration-passport" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="6920" class="pw-post-body-paragraph lp lq it lr b ls mt lu lv lw mu ly lz lf mv mb mc li mw me mf ll mx mh mi mj im bi translated">这里你真正应该关注的是组件的<code class="fe mz na nb nc b">sendEmail</code>函数和<code class="fe mz na nb nc b">render</code>方法。剩下的只是设置初始状态和变量，以及按钮和元素的样式。</p><p id="30df" class="pw-post-body-paragraph lp lq it lr b ls mt lu lv lw mu ly lz lf mv mb mc li mw me mf ll mx mh mi mj im bi translated"><strong class="lr iu">渲染方法</strong></p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nz"><img src="../Images/656498b16b8c987b68b40b9bb1d5c8f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xVFpFa-557DJ89nyW8kC6A.png"/></div></div></figure><p id="5484" class="pw-post-body-paragraph lp lq it lr b ls mt lu lv lw mu ly lz lf mv mb mc li mw me mf ll mx mh mi mj im bi translated">注意在<code class="fe mz na nb nc b">render</code>方法中，我有一个简单的输入框供用户输入他/她的电子邮件地址，还有一个提交按钮，当点击时会触发<code class="fe mz na nb nc b">this.sendEmail()</code>功能。除此之外，我还内置了一点错误和成功处理功能，它基于用户是否没有输入电子邮件，服务器是否回复电子邮件已成功发送，或者它不是一个可识别的地址。</p><p id="ee77" class="pw-post-body-paragraph lp lq it lr b ls mt lu lv lw mu ly lz lf mv mb mc li mw me mf ll mx mh mi mj im bi translated"><strong class="lr iu">发送邮件功能</strong></p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nz"><img src="../Images/eba4b02e5d276ef8ff5faf825fcdb053.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QFsQudnZUkRdd3PEZdH_fQ.png"/></div></div></figure><p id="c60c" class="pw-post-body-paragraph lp lq it lr b ls mt lu lv lw mu ly lz lf mv mb mc li mw me mf ll mx mh mi mj im bi translated">对于我所有的HTTP请求，我使用的是<a class="ae my" href="https://www.npmjs.com/package/axios" rel="noopener ugc nofollow" target="_blank"> Axios </a>库，这使得AJAX调用服务器变得非常容易，在我看来，甚至比内置的<code class="fe mz na nb nc b">fetch()</code> web API更容易。</p><p id="6c90" class="pw-post-body-paragraph lp lq it lr b ls mt lu lv lw mu ly lz lf mv mb mc li mw me mf ll mx mh mi mj im bi translated">当用户输入他们的电子邮件时，我向服务器发出POST请求，并等待响应。如果找不到电子邮件地址，我可以告诉用户他们输入错误，或者如果他们是新用户，他们可以进入注册页面并创建一个帐户，如果该地址与我的数据库中的地址匹配，他们将返回一条成功消息，说明密码重置链接已发送到他们的电子邮件地址。</p><p id="c1a9" class="pw-post-body-paragraph lp lq it lr b ls mt lu lv lw mu ly lz lf mv mb mc li mw me mf ll mx mh mi mj im bi translated">现在让我们转到后端代码。</p><h2 id="7076" class="la jr it bd js lb lc dn jw ld le dp ka lf lg lh ke li lj lk ki ll lm ln km lo bi translated">后端代码(API文件夹)—发送重置电子邮件</h2><p id="a704" class="pw-post-body-paragraph lp lq it lr b ls lt lu lv lw lx ly lz lf ma mb mc li md me mf ll mg mh mi mj im bi translated"><code class="fe mz na nb nc b"><strong class="lr iu">forgotPassword.js</strong></code></p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oa"><img src="../Images/429d584ee3ff41146808fcc59c1366d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-gpBC4Re3ZeqCrd9_DwwJg.png"/></div></div></figure><p id="6cf9" class="pw-post-body-paragraph lp lq it lr b ls mt lu lv lw mu ly lz lf mv mb mc li mw me mf ll mx mh mi mj im bi translated">后端代码稍微复杂一些。这就是Nodemailer发挥作用的地方。</p><p id="6a10" class="pw-post-body-paragraph lp lq it lr b ls mt lu lv lw mu ly lz lf mv mb mc li mw me mf ll mx mh mi mj im bi translated">当用户使用他们输入的电子邮件地址点击后端的<code class="fe mz na nb nc b">forgotPassword</code>路线时，Sequelize做的第一件事就是检查我的数据库中是否存在该电子邮件。如果它不存在，用户会得到通知，他们可能输入错误，如果它确实存在，那么一系列其他事件就会开始。</p><p id="8dc1" class="pw-post-body-paragraph lp lq it lr b ls mt lu lv lw mu ly lz lf mv mb mc li mw me mf ll mx mh mi mj im bi translated">接下来的步骤没有一个是非常困难的，只是一开始把它们连接在一起有点棘手。</p><p id="f7bb" class="pw-post-body-paragraph lp lq it lr b ls mt lu lv lw mu ly lz lf mv mb mc li mw me mf ll mx mh mi mj im bi translated"><strong class="lr iu">步骤1:生成令牌</strong></p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ob"><img src="../Images/2a78a36133f29e7ca5554fbe0a37e637.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WB1CE9-HxjkbUXMuKX5gkA.png"/></div></div></figure><p id="1616" class="pw-post-body-paragraph lp lq it lr b ls mt lu lv lw mu ly lz lf mv mb mc li mw me mf ll mx mh mi mj im bi translated">确认电子邮件附加到数据库中的用户后，第一步是生成一个可以附加到用户帐户的令牌，并设置该令牌的有效时间限制。</p><p id="1d89" class="pw-post-body-paragraph lp lq it lr b ls mt lu lv lw mu ly lz lf mv mb mc li mw me mf ll mx mh mi mj im bi translated">Node.js有一个名为<a class="ae my" href="https://nodejs.org/api/crypto.html#crypto_crypto" rel="noopener ugc nofollow" target="_blank"> Crypto </a>的内置模块，它提供加密功能，这是一种奇特的说法，我可以使用命令<code class="fe mz na nb nc b">crypto.randomBytes(20).toString('hex');</code>轻松生成唯一的哈希令牌。然后，我将新令牌保存到数据库中我的用户的概要文件中，列名为<code class="fe mz na nb nc b">resetPasswordToken</code>。我还为令牌的有效期设置了时间戳。我把我的设为发送链接后一小时内有效— <code class="fe mz na nb nc b">Date.now() + 3600000</code>。</p><p id="f1a2" class="pw-post-body-paragraph lp lq it lr b ls mt lu lv lw mu ly lz lf mv mb mc li mw me mf ll mx mh mi mj im bi translated"><strong class="lr iu">步骤2:创建节点邮件传输</strong></p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ob"><img src="../Images/fa04f1c8e46f41015039b02603930b8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*41dtjCfN-OV3HLpRvnSCKA.png"/></div></div></figure><p id="b90c" class="pw-post-body-paragraph lp lq it lr b ls mt lu lv lw mu ly lz lf mv mb mc li mw me mf ll mx mh mi mj im bi translated">接下来，我创建了<code class="fe mz na nb nc b">transporter</code>，它实际上是发送密码重置电子邮件链接的帐户。</p><p id="bed3" class="pw-post-body-paragraph lp lq it lr b ls mt lu lv lw mu ly lz lf mv mb mc li mw me mf ll mx mh mi mj im bi translated">我选择使用Gmail，因为我个人使用Gmail，我创建了一个新的虚拟帐户来发送电子邮件。因为我不想把这个账户的凭证给任何人，所以我把凭证放在一个包含在我的<code class="fe mz na nb nc b">.gitignore</code>中的<code class="fe mz na nb nc b">.env</code>文件中，这样它就不会被提交给Github或其他任何地方。</p><p id="8f13" class="pw-post-body-paragraph lp lq it lr b ls mt lu lv lw mu ly lz lf mv mb mc li mw me mf ll mx mh mi mj im bi translated">NPM包<code class="fe mz na nb nc b"><a class="ae my" href="https://www.npmjs.com/package/dotenv" rel="noopener ugc nofollow" target="_blank">dotenv</a></code>用于读取文件内容，并插入电子邮件地址和密码，供Nodemailer的<code class="fe mz na nb nc b">createTransport</code>函数读取。</p><p id="d3a4" class="pw-post-body-paragraph lp lq it lr b ls mt lu lv lw mu ly lz lf mv mb mc li mw me mf ll mx mh mi mj im bi translated"><strong class="lr iu">第三步:创建邮件选项</strong></p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oc"><img src="../Images/d68ba9369ea66dbc98d842ef7071db1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GSXm2RvmB2cccXRTF2J8GA.png"/></div></div></figure><p id="cf94" class="pw-post-body-paragraph lp lq it lr b ls mt lu lv lw mu ly lz lf mv mb mc li mw me mf ll mx mh mi mj im bi translated">第三步是创建用户将会看到的电子邮件模板(Nodemailer称之为<code class="fe mz na nb nc b">mailOptions</code>)(这也是他们从前端输入传递的经过验证的电子邮件地址被使用的地方)。</p><p id="457c" class="pw-post-body-paragraph lp lq it lr b ls mt lu lv lw mu ly lz lf mv mb mc li mw me mf ll mx mh mi mj im bi translated">有很多第三方库可以用来制作好看的电子邮件来搭配Nodemailer模块，但是我只想要一个基本的电子邮件，所以我自己做了这个。</p><p id="a553" class="pw-post-body-paragraph lp lq it lr b ls mt lu lv lw mu ly lz lf mv mb mc li mw me mf ll mx mh mi mj im bi translated">它包含<code class="fe mz na nb nc b">from</code>电子邮件地址(mySqlDemoEmail@gmail.com，对我来说)，用户的电子邮件放在<code class="fe mz na nb nc b">to</code>框中，<code class="fe mz na nb nc b">subject</code>行是重置密码链接，而<code class="fe mz na nb nc b">text</code>是一个简单的字符串，包含一些信息和网站的URL重置路径，包括我之前创建的令牌，附加在末尾。这将允许我验证用户是谁，他们说，当他们点击链接，并前往该网站重置他们的密码。</p><p id="1ef5" class="pw-post-body-paragraph lp lq it lr b ls mt lu lv lw mu ly lz lf mv mb mc li mw me mf ll mx mh mi mj im bi translated"><strong class="lr iu">第四步:发送邮件</strong></p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi od"><img src="../Images/fe2a6fd096323686faa09bd11d569709.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_w-0XM0OV5DLmylhmOh5vg.png"/></div></div></figure><p id="1be0" class="pw-post-body-paragraph lp lq it lr b ls mt lu lv lw mu ly lz lf mv mb mc li mw me mf ll mx mh mi mj im bi translated">这个文件的最后一步实际上是把我创建的片段放在一起:即<code class="fe mz na nb nc b">transporter</code>、<code class="fe mz na nb nc b">mailOptions</code>、<code class="fe mz na nb nc b">token</code>并使用Nodemailer的<code class="fe mz na nb nc b">sendMail()</code>函数。如果成功，我将得到一个200响应，然后用它来触发对客户端的成功调用，如果失败，我将记录错误以查看哪里出错了。</p><h2 id="a0ef" class="la jr it bd js lb lc dn jw ld le dp ka lf lg lh ke li lj lk ki ll lm ln km lo bi translated">启用Gmail发送重置电子邮件</h2><p id="1cdf" class="pw-post-body-paragraph lp lq it lr b ls lt lu lv lw lx ly lz lf ma mb mc li md me mf ll mg mh mi mj im bi translated">至少在使用Gmail时，在设置发送所有电子邮件的传送器电子邮件时，需要注意一个额外的问题。</p><p id="ff97" class="pw-post-body-paragraph lp lq it lr b ls mt lu lv lw mu ly lz lf mv mb mc li mw me mf ll mx mh mi mj im bi translated">为了能够从一个帐户发送电子邮件，必须禁用两步验证，并且必须将标题为“允许不太安全的应用程序”的设置切换到打开。见下面截图。要做到这一点，我去我的设置<a class="ae my" href="https://myaccount.google.com/lesssecureapps" rel="noopener ugc nofollow" target="_blank">这里</a>，并打开它。</p><p id="d732" class="pw-post-body-paragraph lp lq it lr b ls mt lu lv lw mu ly lz lf mv mb mc li mw me mf ll mx mh mi mj im bi translated">现在，我可以毫无问题地发送重置电子邮件。如果您遇到问题，请查看Nodemailer的常见问题以获得更多帮助。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oe"><img src="../Images/c268397639c8273fb4983225ef8f91ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R-Ee6gv6v__lBvP0bcuHZg.png"/></div></div><figcaption class="of og gj gh gi oh oi bd b be z dk translated">这是您应该看到的屏幕，您可以在这里打开不太安全的应用程序。又多了一个使用虚拟邮箱账户而不是真正的Gmail账户的理由。</figcaption></figure><h2 id="f923" class="la jr it bd js lb lc dn jw ld le dp ka lf lg lh ke li lj lk ki ll lm ln km lo bi translated">前端代码—更新密码屏幕</h2><p id="6eed" class="pw-post-body-paragraph lp lq it lr b ls lt lu lv lw lx ly lz lf ma mb mc li md me mf ll mg mh mi mj im bi translated">很好，现在用户应该会在他们的收件箱里收到类似这样的重置邮件。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oj"><img src="../Images/5cc2e5f4e91a9dd2f42877c0da60efba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B-_8dljYLsa7ewl22-1Udg.png"/></div></div><figcaption class="of og gj gh gi oh oi bd b be z dk translated">这是一封简单的电子邮件，但它做了我需要它做的事情。</figcaption></figure><p id="2e84" class="pw-post-body-paragraph lp lq it lr b ls mt lu lv lw mu ly lz lf mv mb mc li mw me mf ll mx mh mi mj im bi translated">如果你注意到，第三行是一个到我的网站(在本地端口3031上运行)的链接，到另一个名为“Reset”的页面，后面是我在步骤1中用Node.js <code class="fe mz na nb nc b">crypto</code>模块生成的散列令牌。</p><p id="adab" class="pw-post-body-paragraph lp lq it lr b ls mt lu lv lw mu ly lz lf mv mb mc li mw me mf ll mx mh mi mj im bi translated">当用户点击这个链接时，他们会被定向到应用程序中一个名为“密码重置屏幕”的新页面，只有使用有效的令牌才能访问该页面。如果令牌已过期或无效，用户将看到一个错误屏幕，其中包含返回主页或尝试发送新密码重置电子邮件的链接。</p><p id="174d" class="pw-post-body-paragraph lp lq it lr b ls mt lu lv lw mu ly lz lf mv mb mc li mw me mf ll mx mh mi mj im bi translated">这是重置屏幕的反应代码。</p><p id="84a4" class="pw-post-body-paragraph lp lq it lr b ls mt lu lv lw mu ly lz lf mv mb mc li mw me mf ll mx mh mi mj im bi translated"><code class="fe mz na nb nc b"><strong class="lr iu">ResetPassword.js</strong></code></p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ok"><img src="../Images/c8d55eebdd8fd21f420d9585bb830fd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Gia0EtrP3EWK9NT5TjAtlw.png"/></div></div></figure><p id="d9af" class="pw-post-body-paragraph lp lq it lr b ls mt lu lv lw mu ly lz lf mv mb mc li mw me mf ll mx mh mi mj im bi translated">这是这个组件的三个主要部分，它们起着举足轻重的作用。</p><p id="1c10" class="pw-post-body-paragraph lp lq it lr b ls mt lu lv lw mu ly lz lf mv mb mc li mw me mf ll mx mh mi mj im bi translated"><strong class="lr iu">初始组件安装生命周期方法</strong></p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ol"><img src="../Images/02ee0cbf50ca8df9d003f73ead9e3bad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ArzihAeJ6jv95v-dGMyeBQ.png"/></div></div></figure><p id="3358" class="pw-post-body-paragraph lp lq it lr b ls mt lu lv lw mu ly lz lf mv mb mc li mw me mf ll mx mh mi mj im bi translated">该方法在到达页面时立即触发。它从URL查询参数中提取令牌，并将其传递回服务器的<code class="fe mz na nb nc b">reset</code>路由，以验证令牌是否合法。</p><p id="8980" class="pw-post-body-paragraph lp lq it lr b ls mt lu lv lw mu ly lz lf mv mb mc li mw me mf ll mx mh mi mj im bi translated">然后，服务器要么回答“a-ok”，这个令牌是有效的并且与用户相关联，要么回答“no”，这个令牌由于某种原因不再有用。</p><p id="f793" class="pw-post-body-paragraph lp lq it lr b ls mt lu lv lw mu ly lz lf mv mb mc li mw me mf ll mx mh mi mj im bi translated"><strong class="lr iu">更新密码功能</strong></p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ob"><img src="../Images/51a51c1f1e5d829451ebb184d389cbf8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iJgW4i4pBn18lCMGLfWlhQ.png"/></div></div></figure><p id="dc9f" class="pw-post-body-paragraph lp lq it lr b ls mt lu lv lw mu ly lz lf mv mb mc li mw me mf ll mx mh mi mj im bi translated">这是当用户通过身份验证并被允许重置密码时将触发的函数。它还访问服务器上一个名为<code class="fe mz na nb nc b">updatePasswordViaEmail</code>的特定路径(我这样做是因为我为用户提供了一个单独的路径来在登录应用程序时更新他们的密码)，一旦更新的密码被保存到数据库，一个成功消息响应将被发送回客户端。</p><p id="90dc" class="pw-post-body-paragraph lp lq it lr b ls mt lu lv lw mu ly lz lf mv mb mc li mw me mf ll mx mh mi mj im bi translated"><strong class="lr iu">渲染方法</strong></p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ol"><img src="../Images/02a45c3df99e2062147fffaf8fa37b28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wmFa05AS8CE-pYLzhOwKpg.png"/></div></div></figure><p id="5014" class="pw-post-body-paragraph lp lq it lr b ls mt lu lv lw mu ly lz lf mv mb mc li mw me mf ll mx mh mi mj im bi translated">这个组件的最后一块，就是<code class="fe mz na nb nc b">render</code>法。最初，在验证令牌的有效性时，会显示<code class="fe mz na nb nc b">loading</code>消息。</p><p id="7868" class="pw-post-body-paragraph lp lq it lr b ls mt lu lv lw mu ly lz lf mv mb mc li mw me mf ll mx mh mi mj im bi translated">如果链接以某种方式无效，屏幕上会显示<code class="fe mz na nb nc b">error</code>消息，其中包含返回主屏幕或忘记密码页面的链接。</p><p id="2662" class="pw-post-body-paragraph lp lq it lr b ls mt lu lv lw mu ly lz lf mv mb mc li mw me mf ll mx mh mi mj im bi translated">如果用户被授权重置他们的密码，他们将获得附加了<code class="fe mz na nb nc b">updatePassword()</code>功能的新密码输入，一旦服务器成功更新密码，boolean<code class="fe mz na nb nc b">updated</code>将被设置为true，同时显示<code class="fe mz na nb nc b">Your password has been successfully reset...</code>消息和登录按钮。</p><h2 id="0a9a" class="la jr it bd js lb lc dn jw ld le dp ka lf lg lh ke li lj lk ki ll lm ln km lo bi translated">后端代码—重置密码和更新密码</h2><p id="e766" class="pw-post-body-paragraph lp lq it lr b ls lt lu lv lw lx ly lz lf ma mb mc li md me mf ll mg mh mi mj im bi translated">好的，我现在在最后冲刺阶段。这里是您需要的服务器端的最后两条路线。这些对应于我刚刚在客户端React <code class="fe mz na nb nc b">ResetPassword.js</code>组件中走过的两个方法。</p><p id="c8f3" class="pw-post-body-paragraph lp lq it lr b ls mt lu lv lw mu ly lz lf mv mb mc li mw me mf ll mx mh mi mj im bi translated"><code class="fe mz na nb nc b"><strong class="lr iu">resetPassword.js</strong></code></p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ol"><img src="../Images/ffae90514600071a469919cc4127c6d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wrTzgtWpXLeDyut3JDFw2g.png"/></div></div></figure><p id="5a6d" class="pw-post-body-paragraph lp lq it lr b ls mt lu lv lw mu ly lz lf mv mb mc li mw me mf ll mx mh mi mj im bi translated">这是在客户端的<code class="fe mz na nb nc b">componentDidMount</code>生命周期方法中调用的路线。它检查从链接的查询参数和日期时间戳传递的<code class="fe mz na nb nc b">resetPasswordToken</code>,以确保一切正常。</p><p id="2320" class="pw-post-body-paragraph lp lq it lr b ls mt lu lv lw mu ly lz lf mv mb mc li mw me mf ll mx mh mi mj im bi translated">你会注意到<code class="fe mz na nb nc b">resetPasswordExpires</code>参数有一个奇怪的<code class="fe mz na nb nc b">$gt: Date.now()</code>参数。这是一个<a class="ae my" href="http://docs.sequelizejs.com/manual/tutorial/querying.html#operators-aliases" rel="noopener ugc nofollow" target="_blank">操作符别名比较器</a>，这个<a class="ae my" href="http://docs.sequelizejs.com/" rel="noopener ugc nofollow" target="_blank">序列器</a>允许我使用，所有的<code class="fe mz na nb nc b">$gt:</code>代表“大于”它所比较的任何东西。在这种情况下，它将当前时间与发送重置密码电子邮件时保存到数据库中的过期时间戳进行比较，以确保在电子邮件发送后不到一小时就重置了密码。</p><p id="c783" class="pw-post-body-paragraph lp lq it lr b ls mt lu lv lw mu ly lz lf mv mb mc li mw me mf ll mx mh mi mj im bi translated">只要这两个参数对该用户都有效，就会向客户端发送一个成功的响应，用户就可以继续重置密码。</p><p id="b165" class="pw-post-body-paragraph lp lq it lr b ls mt lu lv lw mu ly lz lf mv mb mc li mw me mf ll mx mh mi mj im bi translated"><code class="fe mz na nb nc b"><strong class="lr iu">updatePasswordViaEmail.js</strong></code></p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi om"><img src="../Images/0106da603a68cca471fbc6c65857beb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9DsfHUnYVyRXoCJt7S7bFA.png"/></div></div></figure><p id="bbd7" class="pw-post-body-paragraph lp lq it lr b ls mt lu lv lw mu ly lz lf mv mb mc li mw me mf ll mx mh mi mj im bi translated">这是当用户提交他/她的密码进行更新时调用的第二个途径。</p><p id="6735" class="pw-post-body-paragraph lp lq it lr b ls mt lu lv lw mu ly lz lf mv mb mc li mw me mf ll mx mh mi mj im bi translated">我再次在数据库中找到用户(<code class="fe mz na nb nc b">username</code>从上面的<code class="fe mz na nb nc b">reset</code>路径传递回客户端，并保持在应用程序的状态，直到更新函数被调用)，我使用我的<code class="fe mz na nb nc b">bcrypt</code>模块散列新密码(就像我的Passport.js中间件在新用户最初被写入数据库时所做的那样)，用新散列更新数据库中该用户的<code class="fe mz na nb nc b">password</code>,并将<code class="fe mz na nb nc b">resetPasswordToken</code>和<code class="fe mz na nb nc b">resetPasswordExpires</code>列都设置回null，因此同一个链接不能被使用多次。</p><p id="83e2" class="pw-post-body-paragraph lp lq it lr b ls mt lu lv lw mu ly lz lf mv mb mc li mw me mf ll mx mh mi mj im bi translated">一旦完成，服务器就向客户机发回一个带有成功消息的200响应，<code class="fe mz na nb nc b">Password updated</code>。</p><p id="9c17" class="pw-post-body-paragraph lp lq it lr b ls mt lu lv lw mu ly lz lf mv mb mc li mw me mf ll mx mh mi mj im bi translated">您已经通过电子邮件成功重置了用户密码。不太难。</p><h2 id="f7b8" class="la jr it bd js lb lc dn jw ld le dp ka lf lg lh ke li lj lk ki ll lm ln km lo bi translated">结论</h2><p id="2b06" class="pw-post-body-paragraph lp lq it lr b ls lt lu lv lw lx ly lz lf ma mb mc li md me mf ll mg mh mi mj im bi translated">乍一看，通过电子邮件链接重置用户密码似乎有点令人生畏。但是Nodemailer有助于简化一个主要因素(电子邮件)。完成后，只需在服务器端发送几条路由，在客户端输入内容，就可以为用户更新密码。</p><p id="03ad" class="pw-post-body-paragraph lp lq it lr b ls mt lu lv lw mu ly lz lf mv mb mc li mw me mf ll mx mh mi mj im bi translated">过几周再来看看，我会写关于使用Puppeteer和headless Chrome进行端到端测试或其他与web开发相关的东西，所以请关注我，这样你就不会错过了。</p><p id="9855" class="pw-post-body-paragraph lp lq it lr b ls mt lu lv lw mu ly lz lf mv mb mc li mw me mf ll mx mh mi mj im bi translated">如果你想确保你不会错过我写的一篇文章，在这里注册我的时事通讯:<a class="ae my" href="https://paigeniedringhaus.substack.com/" rel="noopener ugc nofollow" target="_blank">https://paigeniedringhaus.substack.com</a></p><p id="84f8" class="pw-post-body-paragraph lp lq it lr b ls mt lu lv lw mu ly lz lf mv mb mc li mw me mf ll mx mh mi mj im bi translated">感谢您的阅读，我希望这能让您了解如何使用Nodemailer为MERN应用程序发送密码重置电子邮件。非常感谢鼓掌和分享！</p><p id="b497" class="pw-post-body-paragraph lp lq it lr b ls mt lu lv lw mu ly lz lf mv mb mc li mw me mf ll mx mh mi mj im bi translated"><strong class="lr iu">如果你喜欢读这篇文章，你可能也会喜欢我的其他一些博客:</strong></p><ul class=""><li id="0216" class="nl nm it lr b ls mt lw mu lf nn li no ll np mj nq nr ns nt bi translated"><a class="ae my" rel="noopener ugc nofollow" target="_blank" href="/the-absolute-easiest-way-to-debug-node-js-with-vscode-2e02ef5b1bad">调试Node.js最简单的方法——用VS代码</a></li><li id="523f" class="nl nm it lr b ls nu lw nv lf nw li nx ll ny mj nq nr ns nt bi translated"><a class="ae my" rel="noopener ugc nofollow" target="_blank" href="/implementing-json-web-tokens-passport-js-in-a-javascript-application-with-react-b86b1f313436">用React </a>在JavaScript应用程序中实现JSON Web令牌&amp; Passport.js</li><li id="1b5a" class="nl nm it lr b ls nu lw nv lf nw li nx ll ny mj nq nr ns nt bi translated"><a class="ae my" href="https://medium.com/@paigen11/sequelize-the-orm-for-sql-databases-with-nodejs-daa7c6d5aca3" rel="noopener"> Sequelize:类似于Mongoose，但不是SQL </a></li></ul></div><div class="ab cl on oo hx op" role="separator"><span class="oq bw bk or os ot"/><span class="oq bw bk or os ot"/><span class="oq bw bk or os"/></div><div class="im in io ip iq"><p id="8702" class="pw-post-body-paragraph lp lq it lr b ls mt lu lv lw mu ly lz lf mv mb mc li mw me mf ll mx mh mi mj im bi translated"><strong class="lr iu">参考资料和更多资源:</strong></p><ul class=""><li id="ce08" class="nl nm it lr b ls mt lw mu lf nn li no ll np mj nq nr ns nt bi translated">node mailer:<a class="ae my" href="https://nodemailer.com/about/" rel="noopener ugc nofollow" target="_blank">https://nodemailer.com/about/</a></li><li id="b3f7" class="nl nm it lr b ls nu lw nv lf nw li nx ll ny mj nq nr ns nt bi translated">Nodemailer，Github:<a class="ae my" href="https://github.com/nodemailer/nodemailer" rel="noopener ugc nofollow" target="_blank">https://github.com/nodemailer/nodemailer</a></li><li id="ec32" class="nl nm it lr b ls nu lw nv lf nw li nx ll ny mj nq nr ns nt bi translated">https://www.npmjs.com/package/nodemailer，NPM: <a class="ae my" href="https://www.npmjs.com/package/nodemailer" rel="noopener ugc nofollow" target="_blank"/></li><li id="0336" class="nl nm it lr b ls nu lw nv lf nw li nx ll ny mj nq nr ns nt bi translated">带有节点邮件程序回购的MERN应用:<a class="ae my" href="https://github.com/paigen11/mysql-registration-passport" rel="noopener ugc nofollow" target="_blank">https://github.com/paigen11/mysql-registration-passport</a></li></ul></div></div>    
</body>
</html>