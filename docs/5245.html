<html>
<head>
<title>Kubernetes StatefulSet Initialization with Unique Configs per Pod</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes使用每个Pod的唯一配置进行状态集初始化</h1>
<blockquote>原文：<a href="https://itnext.io/kubernetes-statefulset-initialization-with-unique-configs-per-pod-7e02c01ada65?source=collection_archive---------0-----------------------#2021-01-22">https://itnext.io/kubernetes-statefulset-initialization-with-unique-configs-per-pod-7e02c01ada65?source=collection_archive---------0-----------------------#2021-01-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="31e5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如何为有状态应用程序的每个pod安装唯一的配置(例如，如何为主数据库pod和从数据库pod安装单独的配置)</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/da3358f7c659870e66fc85170076e362.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*uaXVsEPT0_fn0_jC"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">由<a class="ae le" href="https://unsplash.com/@flowforfrank?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">费伦茨·阿尔马西</a>在<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><p id="4953" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Kubernetes中的StatefulSets用于管理需要以下一项或多项功能的有状态应用程序:</p><ul class=""><li id="9fd8" class="lf lg it js b jt ju jx jy kb lh kf li kj lj kn lk ll lm ln bi translated">稳定、唯一的网络标识符</li><li id="9179" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated">稳定、持久的存储</li><li id="e3ec" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated">有序、优雅的部署和扩展</li><li id="ffa8" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated">有序的自动滚动更新</li></ul><p id="54ad" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">实际上，StatefulSets最常用于在Kubernetes上部署数据库(例如MySQL、PostgreSQL、Redis、Elasticsearch)。Kubernetes的声明性使得运行复制的有状态应用程序变得很容易。例如，如果您需要为一个数据库运行多个只读副本，可以使用StatefulSets为每个副本装载相同的配置。</p><p id="6de5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是，当您需要在StatefulSet集群中的每个pod上运行不同的配置时，会发生什么呢？一个常见的场景是当您需要区分主节点(读写)和从节点(只读)时。这可以通过为主节点和从节点创建单独的StatefulSet来解决。如果你需要一个更复杂的设置呢？可能状态集运行一些分布式分类帐网络，并且每个状态集具有不同的角色(例如以太坊的完整节点、轻型节点和归档节点)。这可以扩展到这样的场景，其中具有相同角色的不同状态集pod可能具有不同的许可方案或数据同步需求，这取决于网络拓扑(例如，pod-0可能需要将其所有数据与外部数据库同步，而pod-1只能读取数据的子集并写入消息队列)。</p><p id="1c07" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">目前，Kubernetes没有提供一个简单的解决方案来支持上述用例。有一种观点认为，具有如此不同配置需求的每个StatefulSet应该被视为单独的部署，但是我希望有一种方法将具有不同角色的stateful set集群分组，并轻松地对它们进行扩展。</p><h1 id="5fe0" class="lt lu it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">利用普通性</h1><p id="1350" class="pw-post-body-paragraph jq jr it js b jt mr jv jw jx ms jz ka kb mt kd ke kf mu kh ki kj mv kl km kn im bi translated">用唯一的配置初始化每个StatefulSet pod的一种变通方法是利用initContainers和pod的普通性。Kubernetes为每个StatefulSet pod分配一个唯一的网络标识，该标识具有序号索引(从0到N-1个副本)、<code class="fe mw mx my mz b">$statefulsetName-$ordinal</code>形式的网络ID和稳定存储(即PersistentVolume)。由此，我们可以从网络ID中提取每个pod的序号索引，并使用initContainer有选择地加载每个pod的相应配置。</p><p id="1da3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个想法源于Kubernetes运行一个复制的MySQL数据库的例子:</p><div class="na nb gp gr nc nd"><a href="https://kubernetes.io/docs/tasks/run-application/run-replicated-stateful-application/" rel="noopener  ugc nofollow" target="_blank"><div class="ne ab fo"><div class="nf ab ng cl cj nh"><h2 class="bd iu gy z fp ni fr fs nj fu fw is bi translated">运行复制的有状态应用程序</h2><div class="nk l"><h3 class="bd b gy z fp ni fr fs nj fu fw dk translated">本页显示如何使用StatefulSet控制器运行复制的有状态应用程序。这个应用程序是一个…</h3></div><div class="nl l"><p class="bd b dl z fp ni fr fs nj fu fw dk translated">kubernetes.io</p></div></div><div class="nm l"><div class="nn l no np nq nm nr ky nd"/></div></div></a></div><p id="ede7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本例中，创建了一个配置映射来指定主pod和副本pod的配置:</p><pre class="kp kq kr ks gt ns mz nt nu aw nv bi"><span id="1434" class="nw lu it mz b gy nx ny l nz oa"><strong class="mz iu">apiVersion</strong>: v1<br/><strong class="mz iu">kind</strong>: ConfigMap<br/><strong class="mz iu">metadata</strong>:<br/>  <strong class="mz iu">name</strong>: mysql<br/>  <strong class="mz iu">labels</strong>:<br/>    <strong class="mz iu">app</strong>: mysql<br/><strong class="mz iu">data</strong>:<br/>  <strong class="mz iu">primary.cnf</strong>: |<em class="ob"><br/>    # Apply this config only on the primary.<br/>    [mysqld]<br/>    log-bin</em>    <br/>  <strong class="mz iu">replica.cnf</strong>: |<em class="ob"><br/>    # Apply this config only on replicas.<br/>    [mysqld]<br/>    super-read-only</em></span></pre><p id="aec6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后在StatefulSet定义中，使用initContainer提取序号索引，如果是pod-0，则复制到<code class="fe mw mx my mz b">primary.cnf</code>,如果不是，则使用<code class="fe mw mx my mz b">replica.cnf</code>:</p><pre class="kp kq kr ks gt ns mz nt nu aw nv bi"><span id="bb2d" class="nw lu it mz b gy nx ny l nz oa"><strong class="mz iu">apiVersion</strong>: apps/v1<br/><strong class="mz iu">kind</strong>: StatefulSet<br/><strong class="mz iu">metadata</strong>:<br/>  <strong class="mz iu">name</strong>: mysql<br/><strong class="mz iu">spec</strong>:<br/>  <strong class="mz iu">selector</strong>:<br/>    <strong class="mz iu">matchLabels</strong>:<br/>      <strong class="mz iu">app</strong>: mysql<br/>  <strong class="mz iu">serviceName</strong>: mysql<br/>  <strong class="mz iu">replicas</strong>: 3<br/>  <strong class="mz iu">template</strong>:<br/>    <strong class="mz iu">metadata</strong>:<br/>      <strong class="mz iu">labels</strong>:<br/>        <strong class="mz iu">app</strong>: mysql<br/>    <strong class="mz iu">spec</strong>:<br/>      <strong class="mz iu">initContainers</strong>:<br/>      - <strong class="mz iu">name</strong>: init-mysql<br/>        <strong class="mz iu">image</strong>: mysql:5.7<br/>        <strong class="mz iu">command</strong>:<br/>        - bash<br/>        - "-c"<br/>        - |<em class="ob"><br/>          set -ex<br/>          # Generate mysql server-id from pod ordinal index.<br/>          [[ `hostname` =~ -([0-9]+)$ ]] || exit 1<br/>          ordinal=${BASH_REMATCH[1]}<br/>          echo [mysqld] &gt; /mnt/conf.d/server-id.cnf<br/>          # Add an offset to avoid reserved server-id=0 value.<br/>          echo server-id=$((100 + $ordinal)) &gt;&gt; /mnt/conf.d/server-id.cnf<br/>          # Copy appropriate conf.d files from config-map to emptyDir.<br/>          if [[ $ordinal -eq 0 ]]; then<br/>            cp /mnt/config-map/primary.cnf /mnt/conf.d/<br/>          else<br/>            cp /mnt/config-map/replica.cnf /mnt/conf.d/<br/>          fi</em>          <br/>        <strong class="mz iu">volumeMounts</strong>:<br/>        - <strong class="mz iu">name</strong>: conf<br/>          <strong class="mz iu">mountPath</strong>: /mnt/conf.d<br/>        - <strong class="mz iu">name</strong>: config-map<br/>          <strong class="mz iu">mountPath</strong>: /mnt/config-map<br/>[...]<br/>      <strong class="mz iu">volumes</strong>:<br/>      - <strong class="mz iu">name</strong>: conf<br/>        <strong class="mz iu">emptyDir</strong>: {}<br/>      - <strong class="mz iu">name</strong>: config-map<br/>        <strong class="mz iu">configMap</strong>:<br/>          <strong class="mz iu">name</strong>: mysql</span></pre><p id="3ac0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里的核心思想是安装包含各种pod的所有配置的单个ConfigMap，并基于序号索引，将每个pod的特定配置复制到主容器使用的emptyDir卷。</p><h1 id="1452" class="lt lu it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">GitOps友好的方法</h1><p id="d720" class="pw-post-body-paragraph jq jr it js b jt mr jv jw jx ms jz ka kb mt kd ke kf mu kh ki kj mv kl km kn im bi translated">虽然上面的解决方案非常有效，但是有时将所有的配置组合到一个配置图中是不可行的。不同的团队可能负责维护不同的配置，或者您只是喜欢将配置组织到不同的目录中。</p><p id="8b6e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们来看一个具有以下结构的样本舵图表库:</p><pre class="kp kq kr ks gt ns mz nt nu aw nv bi"><span id="0656" class="nw lu it mz b gy nx ny l nz oa">my-awesome-chart<br/>├── Chart.yaml<br/>├── config<br/>│   ├── node-0<br/>│   │   ├── postgres.conf<br/>│   │   └── httpSettings<br/>│   └── node-1<br/>│       ├── nodeid.dat<br/>│       └── application.conf<br/>├── templates<br/>│   └── configmap.yaml<br/>└── values.yaml</span></pre><p id="47b2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们希望为每个目录生成一个配置映射:</p><pre class="kp kq kr ks gt ns mz nt nu aw nv bi"><span id="b01b" class="nw lu it mz b gy nx ny l nz oa">apiVersion: v1<br/>kind: ConfigMap<br/>metadata:<br/>  name: node-0<br/>data:<br/>  <!-- -->postgres.conf<!-- -->: ...<br/>  httpSettings: ...<br/>  <br/>---<br/>apiVersion: v1<br/>kind: ConfigMap<br/>metadata:<br/>  name: node-1<br/>data:<br/>  <!-- -->nodeid.dat<!-- -->: node-1<br/>  <!-- -->application.conf<!-- -->: ...</span></pre><p id="a8b3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了遍历每个配置目录，我们需要使用glob模式<code class="fe mw mx my mz b">config/**</code>，并且每个目录只处理一次。为此，我们可以使用dict来跟踪已经创建的配置图:</p><pre class="kp kq kr ks gt ns mz nt nu aw nv bi"><span id="5dff" class="nw lu it mz b gy nx ny l nz oa">{{- $processedDict := dict -}}<br/>{{- range $path, $bytes := .Files.Glob "config/**" }}<br/>{{- $name := base (dir $path) }}<br/>{{- if not (hasKey $processedDict $name) -}}<br/>{{ $_ := set $processedDict $name "true" }}<br/>apiVersion: v1<br/>kind: ConfigMap<br/>metadata:<br/>    name: {{ $name }}<br/>data:<br/>{{ ($.Files.Glob (printf "config/%s/*" $name)).AsConfig | indent 2 }}<br/>---<br/>{{- end }}<br/>{{- end }}</span></pre><p id="dafe" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后，配置映射将产生两个配置映射，称为<code class="fe mw mx my mz b">node-0</code>和<code class="fe mw mx my mz b">node-1</code>。</p><p id="bd8a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，在我们的initContainer中，我们可以使用range函数挂载不同的配置图:</p><pre class="kp kq kr ks gt ns mz nt nu aw nv bi"><span id="4bfb" class="nw lu it mz b gy nx ny l nz oa">volumeMounts:<br/>{{ range $i, $e := until (int .Values.replicaCount) }}<br/>- name: node-{{ $i }}<br/>  mountPath: /tmp/node-{{ $i }}<br/>{{ end }}</span></pre><p id="5859" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后，在initContainer中，我们可以使用序号索引来复制每个pod的所有配置:</p><pre class="kp kq kr ks gt ns mz nt nu aw nv bi"><span id="b34e" class="nw lu it mz b gy nx ny l nz oa">SET_INDEX=${HOSTNAME##*-};<br/>echo "Starting initializing for node $SET_INDEX";</span><span id="d10d" class="nw lu it mz b gy oc ny l nz oa">cp /tmp/node-${SET_INDEX}/* /network/conf;</span></pre><p id="1ca9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您在掌舵图之外创建配置图，那么您也可以利用此模式来使用现有的配置图，并将它们加载到特定的pod上。</p><h1 id="0b8c" class="lt lu it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">最后的想法</h1><p id="9163" class="pw-post-body-paragraph jq jr it js b jt mr jv jw jx ms jz ka kb mt kd ke kf mu kh ki kj mv kl km kn im bi translated">目前在Kubernetes上管理StatefulSets不像运行可以水平伸缩的无状态应用程序那么容易。然而，StatefulSet API提供了强大的方法来利用普通性来配置您的pod，以接收独特的配置并在运行时承担不同的角色。因为Kubernetes为状态集提供了有序、优雅的部署和扩展，所以这也可以用于留出具有较小索引的单元来初始化网络并促进顺序部署。对于高级用例，RollingUpdates可以配置分区，以便只更新序号大于或等于分区的pod，而不更新其他pod。</p></div></div>    
</body>
</html>