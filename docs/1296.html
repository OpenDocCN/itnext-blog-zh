<html>
<head>
<title>Host ASP.NET Core Application as a Windows Service</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将ASP.NET核心应用程序托管为Windows服务</h1>
<blockquote>原文：<a href="https://itnext.io/host-asp-net-core-application-as-a-windows-service-306f638ca9e6?source=collection_archive---------3-----------------------#2018-09-02">https://itnext.io/host-asp-net-core-application-as-a-windows-service-306f638ca9e6?source=collection_archive---------3-----------------------#2018-09-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="bd51" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">。NET Core 2.1里面有很多很酷的东西。大卫·福勒(David Fowler)不久前在推特上发布了一系列关于这个版本中隐藏的宝石的消息，其中一个真正引起我注意的是在Windows服务中托管ASP.NET核心应用的<a class="ae kl" href="https://twitter.com/davidfowl/status/1004233944085118976" rel="noopener ugc nofollow" target="_blank">能力</a>。这篇文章将介绍如何创建一个新的ASP.NET核心应用程序，然后对其进行必要的修改，使其作为Windows服务运行。我从官方<a class="ae kl" href="https://docs.microsoft.com/en-us/aspnet/core/host-and-deploy/windows-service?view=aspnetcore-2.1" rel="noopener ugc nofollow" target="_blank">文件</a>中获取了大部分我需要的信息。</p><h2 id="d7a3" class="km kn iq bd ko kp kq dn kr ks kt dp ku jy kv kw kx kc ky kz la kg lb lc ld le bi translated">项目创建</h2><p id="af4c" class="pw-post-body-paragraph jn jo iq jp b jq lf js jt ju lg jw jx jy lh ka kb kc li ke kf kg lj ki kj kk ij bi translated">我们将使用。NET CLI来创建项目，但是如果您愿意，也可以使用Visual Studio。在要创建项目的目录中打开命令提示符，并运行以下命令。</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="ab9d" class="km kn iq lp b gy lt lu l lv lw">dotnet new razor --no-https<br/>dotnet new sln<br/>dotnet sln add WindowsServiceHosted.csproj</span></pre><p id="f986" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在Visual Studio中打开新的解决方案。</p><h2 id="a5e5" class="km kn iq bd ko kp kq dn kr ks kt dp ku jy kv kw kx kc ky kz la kg lb lc ld le bi translated">项目文件更改</h2><p id="aea6" class="pw-post-body-paragraph jn jo iq jp b jq lf js jt ju lg jw jx jy lh ka kb kc li ke kf kg lj ki kj kk ij bi translated">右键单击您的项目字段并选择<strong class="jp ir">编辑</strong>。</p><figure class="lk ll lm ln gt ly gh gi paragraph-image"><div class="gh gi lx"><img src="../Images/34cd5b78a7f15e33164e34c3a0355b37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1226/format:webp/0*CPV1wmOSsQg4wbUm.png"/></div></figure><p id="fd0a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第一步是添加一个<a class="ae kl" href="https://docs.microsoft.com/en-us/dotnet/core/rid-catalog" rel="noopener ugc nofollow" target="_blank">运行时标识符</a>。文档使用的是<strong class="jp ir"> win7-x64 </strong>，所以我们将使用相同的。我确实尝试过使用<strong class="jp ir"> win </strong>和<strong class="jp ir"> win7 </strong>，但是它们无法工作，因为没有与它们相关联的特定运行时。在同一步骤中，我们将添加对<a class="ae kl" href="https://www.nuget.org/packages/Microsoft.AspNetCore.Hosting.WindowsServices/" rel="noopener ugc nofollow" target="_blank">微软的引用。AspNetCore . hosting . window services</a>n获取包。</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="47c6" class="km kn iq lp b gy lt lu l lv lw">Before:<br/>&lt;Project Sdk="Microsoft.NET.Sdk.Web"&gt;<br/><br/>  &lt;PropertyGroup&gt;<br/>    &lt;TargetFramework&gt;netcoreapp2.1&lt;/TargetFramework&gt;<br/>  &lt;/PropertyGroup&gt;<br/><br/>  &lt;ItemGroup&gt;<br/>    &lt;PackageReference Include="Microsoft.AspNetCore.App" /&gt;<br/>  &lt;/ItemGroup&gt;<br/><br/>&lt;/Project&gt;<br/><br/>After:<br/>&lt;Project Sdk="Microsoft.NET.Sdk.Web"&gt;<br/><br/>  &lt;PropertyGroup&gt;<br/>    &lt;TargetFramework&gt;netcoreapp2.1&lt;/TargetFramework&gt;<br/>    &lt;RuntimeIdentifier&gt;win7-x64&lt;/RuntimeIdentifier&gt;<br/>  &lt;/PropertyGroup&gt;<br/><br/>  &lt;ItemGroup&gt;<br/>    &lt;PackageReference Include="Microsoft.AspNetCore.App" /&gt;<br/>    &lt;PackageReference Include="Microsoft.AspNetCore.Hosting.WindowsServices" Version="2.1.1" /&gt;<br/>  &lt;/ItemGroup&gt;<br/><br/>&lt;/Project&gt;</span></pre><h2 id="c3eb" class="km kn iq bd ko kp kq dn kr ks kt dp ku jy kv kw kx kc ky kz la kg lb lc ld le bi translated">程序类别更改</h2><p id="9378" class="pw-post-body-paragraph jn jo iq jp b jq lf js jt ju lg jw jx jy lh ka kb kc li ke kf kg lj ki kj kk ij bi translated">打开项目的程序类。在Main函数中，Web主机上的Run call需要改为RunAsService。</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="e201" class="km kn iq lp b gy lt lu l lv lw">Before:<br/>CreateWebHostBuilder(args).Build().Run();<br/><br/>After:<br/>CreateWebHostBuilder(args).Build().RunAsService();</span></pre><p id="df80" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，在CreateWebHostBuilder函数中，我们需要将内容根目录更改为应用程序的目录。我们使用Process类来提取文件名，并使用它来获取进程正在运行的目录。</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="d3ba" class="km kn iq lp b gy lt lu l lv lw">Before:<br/>public static IWebHostBuilder CreateWebHostBuilder(string[] args) =&gt;<br/>    WebHost.CreateDefaultBuilder(args)<br/>        .UseStartup&lt;Startup&gt;();<br/><br/>After:<br/>public static IWebHostBuilder CreateWebHostBuilder(string[] args) =&gt;<br/>    WebHost.CreateDefaultBuilder(args)<br/>        .UseContentRoot(Path<br/>                        .GetDirectoryName(Process<br/>                                          .GetCurrentProcess()<br/>                                          .MainModule<br/>                                          .FileName))<br/>        .UseStartup&lt;Startup&gt;();</span></pre><h2 id="ebfc" class="km kn iq bd ko kp kq dn kr ks kt dp ku jy kv kw kx kc ky kz la kg lb lc ld le bi translated">出版</h2><p id="2634" class="pw-post-body-paragraph jn jo iq jp b jq lf js jt ju lg jw jx jy lh ka kb kc li ke kf kg lj ki kj kk ij bi translated">在核心之前的版本中，本可以跳过这一步，但对于。从项目中获取可以安装的实际exe文件的唯一方法是发布应用程序。您可以使用。NET CLI或Visual Studio来发布应用程序。我将使用以下内容。NET CLI命令从与项目文件相同的目录运行。</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="6f1e" class="km kn iq lp b gy lt lu l lv lw">dotnet publish</span></pre><p id="a66c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为我没有指定一个配置值，所以这个项目是在debug中构建的，并在<strong class="jp ir">bin \ Debug \ netcoreapp2.1 \ win 7-x64 \ publish</strong>目录中结束。</p><h2 id="1e69" class="km kn iq bd ko kp kq dn kr ks kt dp ku jy kv kw kx kc ky kz la kg lb lc ld le bi translated">装置</h2><p id="2a01" class="pw-post-body-paragraph jn jo iq jp b jq lf js jt ju lg jw jx jy lh ka kb kc li ke kf kg lj ki kj kk ij bi translated">在管理模式下打开命令提示符，并运行以下命令来创建windows服务。<strong class="jp ir"> binPath </strong>需要是exe的完整路径，否则即使成功创建，服务也无法启动。</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="2d4c" class="km kn iq lp b gy lt lu l lv lw">sc create WindowsServiceHosted binPath= "C:\WindowsServiceHosted\bin\Debug\netcoreapp2.1\win7-x64\publish\WindowsServiceHosted.exe"</span></pre><p id="c07b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">另外，注意在<strong class="jp ir"> binPath= </strong>之后和exe名称之前的空格是必需的。</p><h2 id="569b" class="km kn iq bd ko kp kq dn kr ks kt dp ku jy kv kw kx kc ky kz la kg lb lc ld le bi translated">服务管理</h2><p id="6685" class="pw-post-body-paragraph jn jo iq jp b jq lf js jt ju lg jw jx jy lh ka kb kc li ke kf kg lj ki kj kk ij bi translated">现在服务已经安装完毕，运行下面的命令来启动它。</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="bda2" class="km kn iq lp b gy lt lu l lv lw">sc start WindowsServiceHosted</span></pre><p id="8c29" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">服务启动后，你可以打开浏览器，进入<a class="ae kl" href="http://localhost:5000/" rel="noopener ugc nofollow" target="_blank"> http://localhost:5000/ </a>，查看你的应用程序运行情况。</p><p id="de5a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要检查服务的状态，请使用以下命令。</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="2d68" class="km kn iq lp b gy lt lu l lv lw">sc query WindowsServiceHosted</span></pre><p id="8377" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要停止服务，请使用以下命令。</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="aac5" class="km kn iq lp b gy lt lu l lv lw">sc stop WindowsServiceHosted</span></pre><p id="7676" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，使用下面的命令卸载您的服务。</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="de45" class="km kn iq lp b gy lt lu l lv lw">sc delete WindowsServiceHosted</span></pre><h2 id="3f5b" class="km kn iq bd ko kp kq dn kr ks kt dp ku jy kv kw kx kc ky kz la kg lb lc ld le bi translated">排除故障</h2><p id="c6f9" class="pw-post-body-paragraph jn jo iq jp b jq lf js jt ju lg jw jx jy lh ka kb kc li ke kf kg lj ki kj kk ij bi translated">虽然可以调试Windows服务，但这是一件痛苦的事情。幸运的是，如果应用程序是在调试模式下运行的，文档会引导我们正常运行应用程序，但是这确实需要对程序类进行更多的修改。</p><p id="db23" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，将CreateWebHostBuilder更改回其原始状态。</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="9294" class="km kn iq lp b gy lt lu l lv lw">public static IWebHostBuilder CreateWebHostBuilder(string[] args) =&gt;<br/>    WebHost.CreateDefaultBuilder(args)<br/>        .UseStartup&lt;Startup&gt;();</span></pre><p id="8025" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，在Main函数中，我们必须决定我们是否作为服务运行，如果是，切换我们如何启动应用程序。</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="b1c3" class="km kn iq lp b gy lt lu l lv lw">public static void Main(string[] args)<br/>{<br/>    var runAsService = !Debugger.IsAttached;<br/>    var builder = CreateWebHostBuilder(args);<br/><br/>    if (runAsService)<br/>    {<br/>        builder.UseContentRoot(Path<br/>                               .GetDirectoryName(Process<br/>                                                 .GetCurrentProcess()<br/>                                                 .MainModule.FileName));<br/>    }<br/><br/>    var host = builder.Build();<br/><br/>    if (runAsService)<br/>    {<br/>        host.RunAsService();<br/>    }<br/>    else<br/>    {<br/>        host.Run();<br/>    }<br/>}</span></pre><p id="57a3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于这个例子，我们将只在没有附加调试器的情况下作为服务运行。您可以看到其余的代码是如何使用这个runAsService布尔值在服务所需的设置和普通web应用程序主机的设置之间进行转换的。</p><h2 id="4107" class="km kn iq bd ko kp kq dn kr ks kt dp ku jy kv kw kx kc ky kz la kg lb lc ld le bi translated">包扎</h2><p id="ef01" class="pw-post-body-paragraph jn jo iq jp b jq lf js jt ju lg jw jx jy lh ka kb kc li ke kf kg lj ki kj kk ij bi translated">我很高兴能够以窗口服务的形式托管ASP.NET核心应用。这似乎是一个我遇到的比人们想象的要多得多的案例。</p><p id="a383" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我希望看到简化Windows服务的东西，比如为。NET Core 2.1 ( <a class="ae kl" href="https://github.com/Topshelf/Topshelf/issues/455" rel="noopener ugc nofollow" target="_blank">这个</a>问题有与2.1相关的所有问题的链接，如果你想查看进度的话)。这将是很好的。NET核心Windows服务，支持级别与以前版本的. NET相同。</p></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><p id="3081" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mi">最初发表于</em> <a class="ae kl" href="https://elanderson.net/2018/09/host-asp-net-core-application-as-a-windows-service/" rel="noopener ugc nofollow" target="_blank"> <em class="mi">埃里克·安德森</em> </a> <em class="mi">。</em></p></div></div>    
</body>
</html>