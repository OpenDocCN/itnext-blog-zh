<html>
<head>
<title>Journey Of A Microservice Application In The Kubernetes World</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes世界的微服务应用之旅</h1>
<blockquote>原文：<a href="https://itnext.io/journey-of-a-microservice-application-in-the-kubernetes-world-bdfe795532ef?source=collection_archive---------3-----------------------#2022-09-06">https://itnext.io/journey-of-a-microservice-application-in-the-kubernetes-world-bdfe795532ef?source=collection_archive---------3-----------------------#2022-09-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="afe4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">webhooks.app演示</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/59ce769d4a75d32af5a8e197d0601487.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bs-ffySGNYxsYmI6CyZsrQ.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@thematthoward?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">马特·霍华德</a>在<a class="ae ky" href="https://unsplash.com/s/photos/journey?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><h2 id="da52" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">TL；速度三角形定位法(dead reckoning)</h2><p id="3413" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated"><a class="ae ky" href="https://webhooks.app" rel="noopener ugc nofollow" target="_blank"> webhooks.app </a>是遵循微服务架构的开源应用。它的目的是为演示提供一个webhook端点。在这一系列文章中，我将介绍这个应用程序以及我使用(并将使用)的几个步骤，让它在Kubernetes集群中运行。</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h2 id="eab4" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">关于这个系列</h2><p id="e842" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">本系列将分为以下几篇文章，详细介绍webhooks应用程序的用途:它的架构，如何在本地和Kubernetes集群上部署它，以及它所依赖的各种项目。其他文章可能会添加到写作时想到的主题中。</p><ul class=""><li id="c2a3" class="mv mw it lx b ly mx mb my li mz lm na lq nb mn nc nd ne nf bi translated">webhooks.app的演示(当前文章)</li><li id="36b8" class="mv mw it lx b ly ng mb nh li ni lm nj lq nk mn nc nd ne nf bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/journey-of-a-microservice-application-in-the-kubernetes-world-3c2a9e701e9f">使用Helm </a>在Kubernetes上运行应用程序</li><li id="c4d6" class="mv mw it lx b ly ng mb nh li ni lm nj lq nk mn nc nd ne nf bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/journey-of-a-microservice-application-in-the-kubernetes-world-e800579f0be3">在Civo Kubernetes集群上运行应用</a></li><li id="8822" class="mv mw it lx b ly ng mb nh li ni lm nj lq nk mn nc nd ne nf bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/journey-of-a-microservice-application-in-the-kubernetes-world-d9493b19edff">使用GitOps和ArgoCD进行连续部署</a></li><li id="e7e0" class="mv mw it lx b ly ng mb nh li ni lm nj lq nk mn nc nd ne nf bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/journey-of-a-microservice-application-in-the-kubernetes-world-876f72ce1681">使用Loki堆栈的可观察性</a></li><li id="2cab" class="mv mw it lx b ly ng mb nh li ni lm nj lq nk mn nc nd ne nf bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/journey-of-a-microservice-application-in-the-kubernetes-world-e2f6475ddde1">使用Acorn定义应用</a></li><li id="a179" class="mv mw it lx b ly ng mb nh li ni lm nj lq nk mn nc nd ne nf bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/journey-of-a-microservice-application-in-the-kubernetes-world-6abd625c60fe">安全注意事项:安全相关工具</a></li><li id="7bea" class="mv mw it lx b ly ng mb nh li ni lm nj lq nk mn nc nd ne nf bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/journey-of-a-microservice-application-in-the-kubernetes-world-eb0fb52e1bf0">安全考虑:修复错误配置</a></li><li id="3c61" class="mv mw it lx b ly ng mb nh li ni lm nj lq nk mn nc nd ne nf bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/journey-of-a-microservice-application-in-the-kubernetes-world-f760cba7600f">安全考虑:政策执行</a></li><li id="24c3" class="mv mw it lx b ly ng mb nh li ni lm nj lq nk mn nc nd ne nf bi translated">安全考虑:漏洞扫描(即将推出)</li></ul></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h2 id="c4d8" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">关于申请</h2><p id="2f21" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated"><a class="ae ky" href="https://webhooks.app" rel="noopener ugc nofollow" target="_blank"> webhooks.app </a>是一个应用程序，其目的是提供始终在线的安全webhook端点(基本上是一个等待从HTTP POST请求接收json有效负载的服务器)。Webhook是应用程序相互通信的一种方式，通常以json有效载荷的形式交换信息。</p><p id="3563" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li nl mf mg lm nm mi mj lq nn ml mm mn im bi translated">让我们考虑下面的例子:我们有一个<a class="ae ky" href="https://goharbor.io" rel="noopener ugc nofollow" target="_blank">港</a>的容器注册中心，并希望在每次有新图像被推送到给定项目时得到通知。Harbor允许指定一个webhook (url和认证令牌),并在每次推送新图像时向该webhook发送一个json有效负载。</p><div class="kj kk kl km gt ab cb"><figure class="no kn np nq nr ns nt paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/f7e7ecf1babf2429b31982b8a5002593.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*Qs-sJ1t9MoUWdkUUTJ1RMw.png"/></div></figure><figure class="no kn np nq nr ns nt paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/704170f1a7a0b9af503a231aea73aa80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*8_GLPwRV1M_B8VUQLbpmZQ.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk nu di nv nw translated">指定webhook，这样Harbor将在每次新图像被推送到api项目时向该webhook发送一个有效负载</figcaption></figure></div><p id="e385" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li nl mf mg lm nm mi mj lq nn ml mm mn im bi translated">注意事项:</p><ul class=""><li id="0a2f" class="mv mw it lx b ly mx mb my li mz lm na lq nb mn nc nd ne nf bi translated">许多其他注册中心允许使用webhooks与外部系统通信(您也可以在Docker Hub仓库中使用它)</li><li id="2d91" class="mv mw it lx b ly ng mb nh li ni lm nj lq nk mn nc nd ne nf bi translated">Harbor还可以为其他类型的事件(图像扫描的结果、超出配额等)向webhook端点发送有效负载</li></ul><p id="b292" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li nl mf mg lm nm mi mj lq nn ml mm mn im bi translated">为了说明这一点，我们可以标记一个虚拟图像，并将其发送到港口登记处:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="265d" class="kz la it ny b gy oc od l oe of">$ docker login -u admin harbor.techwhale.io<br/>$ docker image pull nginx:1.20<br/>$ docker image tag nginx:1.20 harbor.techwhale.io/api/pong:2.0<br/>$ docker image push harbor.techwhale.io/api/pong:2.0</span></pre><p id="eaf5" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li nl mf mg lm nm mi mj lq nn ml mm mn im bi translated">我们立刻在webhooks.app的仪表盘上看到Harbor发送的有效载荷内容:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/0b182acd76fc61315b96b7cb59b16dae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U7TieZKtW2-RXNKkugzlCQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">webhook端点接收的json负载的内容</figcaption></figure><p id="177c" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li nl mf mg lm nm mi mj lq nn ml mm mn im bi translated">webhooks.app只允许您查看传入负载内部的内容，而不会以任何方式处理负载。这对于演示非常有用，因此我们可以检查有效负载的内容，这是开发实际处理该有效负载的服务器之前的第一步。</p><p id="8d27" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li nl mf mg lm nm mi mj lq nn ml mm mn im bi translated">如果你想了解更多关于webhooks的概念，我推荐<a class="ae ky" href="https://www.getvero.com/resources/webhooks/" rel="noopener ugc nofollow" target="_blank">这篇很棒的文章</a>。</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h2 id="f28e" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">整体架构</h2><p id="cbf5" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">该应用托管在GitLab的<a class="ae ky" href="https://gitlab.com/web-hook" rel="noopener ugc nofollow" target="_blank"> web-hook组</a>中。每个微服务都有自己的存储库:</p><ul class=""><li id="e51e" class="mv mw it lx b ly mx mb my li mz lm na lq nb mn nc nd ne nf bi translated">web-hook :包含应用程序细节的元存储库，比如在本地运行它的方式，以及如果你可以贡献的话的说明</li><li id="c1e0" class="mv mw it lx b ly ng mb nh li ni lm nj lq nk mn nc nd ne nf bi translated"><strong class="lx iu"> www </strong>:嗯……前端web</li><li id="9a54" class="mv mw it lx b ly ng mb nh li ni lm nj lq nk mn nc nd ne nf bi translated"><strong class="lx iu"> api </strong>:处理数据并与底层数据库通信的微服务</li><li id="e469" class="mv mw it lx b ly ng mb nh li ni lm nj lq nk mn nc nd ne nf bi translated"><strong class="lx iu"> ws </strong> : websocket服务器，确保每次应用程序接收到新的有效负载时，前端都会实时更新</li></ul><p id="6d9a" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li nl mf mg lm nm mi mj lq nn ml mm mn im bi translated">除了这些微服务之外，还使用了其他组件:</p><ul class=""><li id="3cb0" class="mv mw it lx b ly mx mb my li mz lm na lq nb mn nc nd ne nf bi translated">NATS消息代理</li><li id="20dd" class="mv mw it lx b ly ng mb nh li ni lm nj lq nk mn nc nd ne nf bi translated">MongoDB数据库</li><li id="2aef" class="mv mw it lx b ly ng mb nh li ni lm nj lq nk mn nc nd ne nf bi translated">应用程序前面的Traefik反向代理</li></ul><p id="fdc8" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li nl mf mg lm nm mi mj lq nn ml mm mn im bi translated">下面的模式说明了应用程序的体系结构:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/3a977a7932d80f216608f0c00891c92f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1266/format:webp/1*nl0lkSZ68akJntJ5GgPnrQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">应用程序的架构</figcaption></figure><p id="1082" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li nl mf mg lm nm mi mj lq nn ml mm mn im bi translated">基本上:</p><ul class=""><li id="d597" class="mv mw it lx b ly mx mb my li mz lm na lq nb mn nc nd ne nf bi translated">Traefik向外部世界公开api和web前端</li><li id="2188" class="mv mw it lx b ly ng mb nh li ni lm nj lq nk mn nc nd ne nf bi translated">每次有效载荷被发送到api，它被保存在数据库中，并在NATS的一个专门的主题上发布</li><li id="91e4" class="mv mw it lx b ly ng mb nh li ni lm nj lq nk mn nc nd ne nf bi translated">websocket服务器接收来自NATS的消息，并通过websocket将更新发送给浏览器</li></ul><p id="338c" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li nl mf mg lm nm mi mj lq nn ml mm mn im bi translated">注意:体系结构中使用NATS来分离api和ws组件。它允许建立一个发布/订阅系统，<strong class="lx iu"> api </strong>是NATS的发布者，而<strong class="lx iu"> ws </strong>是NATS的订阅者:api发送的消息由ws接收。如果需要，以后可以很容易地添加额外的订户。</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h2 id="d5e2" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">每个微服务的简单CI设置</h2><p id="3e45" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">在<strong class="lx iu"> api </strong>、<strong class="lx iu"> www </strong>和<strong class="lx iu"> ws </strong>中的每个库都包含一个. gitlab-ci.yml文件，该文件定义了在git推送时触发的动作。例如，文件<a class="ae ky" href="https://gitlab.com/web-hook/api/-/blob/main/.gitlab-ci.yml" rel="noopener ugc nofollow" target="_blank">https://gitlab.com/web-hook/api/-/blob/main/.gitlab-ci.yml</a>定义了<strong class="lx iu"> api </strong>的CI(持续集成)管道。当新代码被推送到api存储库的主分支时，会发生以下动作:</p><ul class=""><li id="4213" class="mv mw it lx b ly mx mb my li mz lm na lq nb mn nc nd ne nf bi translated">创建了一个新标签(遵循SemVer格式)</li><li id="6c47" class="mv mw it lx b ly ng mb nh li ni lm nj lq nk mn nc nd ne nf bi translated">使用这个标签构建并标记一个新的容器图像</li><li id="a309" class="mv mw it lx b ly ng mb nh li ni lm nj lq nk mn nc nd ne nf bi translated">用这个标签更新配置存储库(在下一篇专门讨论GitOps方法的文章中有更多相关内容)</li></ul><p id="4391" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li nl mf mg lm nm mi mj lq nn ml mm mn im bi translated">因此，CI的主要结果是创建一个新的映像，这个映像托管在微服务存储库的容器注册表中。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/d2f4db6d5ccb23fdd4d8c655a9df04ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9YigfjPACxNnvWYnaclnPQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">已经为api微服务构建的容器映像的历史</figcaption></figure></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h2 id="6941" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">用Docker Compose在本地运行它</h2><p id="6b4e" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">在<a class="ae ky" href="https://gitlab.com/web-hook/web-hook" rel="noopener ugc nofollow" target="_blank"> web-hook库</a>中，你可以找到在本地运行整个项目的所有指令。下面详细介绍了如何使用Docker Compose在容器中运行应用程序。</p><p id="6c2e" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li nl mf mg lm nm mi mj lq nn ml mm mn im bi translated">首先在新文件夹中克隆存储库</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="79b7" class="kz la it ny b gy oc od l oe of">mkdir webhooks &amp;&amp; cd webhooks<br/>for repo in www api ws web-hook; do<br/>  git clone git@gitlab.com:web-hook/$repo.git<br/>done</span></pre><p id="a192" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li nl mf mg lm nm mi mj lq nn ml mm mn im bi translated">接下来，使用web-hook存储库中的docker-compose.yml文件运行应用程序:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="5acc" class="kz la it ny b gy oc od l oe of">cd web-hook<br/>docker compose up</span></pre><p id="997e" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li nl mf mg lm nm mi mj lq nn ml mm mn im bi translated">几秒钟后，您可以访问应用程序，将您的web浏览器指向本地主机，并单击底部的<strong class="lx iu"> Get my webhook </strong>按钮获得您自己的webhook端点。</p><div class="kj kk kl km gt ab cb"><figure class="no kn oj nq nr ns nt paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/28504585110ffa7451e2a00e1f543050.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*6xocgJU9VECGJGDRKKsU0A.png"/></div></figure><figure class="no kn oj nq nr ns nt paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/dbff553cbba5c87b6cc78bd4a0e1cdc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Duq02qfxCvtLoJjqc85Nkg.png"/></div></figure><figure class="no kn oj nq nr ns nt paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/17ed6dcd700cc4928dbdda97f9d32f5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Kuk6Asi0O3s8UyJW_g4QZg.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk ok di ol nw translated">访问应用程序并获得自己的webhook端点(url和身份验证令牌)</figcaption></figure></div><p id="50d6" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li nl mf mg lm nm mi mj lq nn ml mm mn im bi translated">让我们跳到仪表板上:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/e8068109013656f527370a0c1d1c794e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*frREepSr1AbMbTaFPIy0dQ.png"/></div></div></figure><p id="cbc5" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li nl mf mg lm nm mi mj lq nn ml mm mn im bi translated">在那里，您有一个curl sample命令，可以用来从命令行直接发送有效负载:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="6678" class="kz la it ny b gy oc od l oe of">$ curl -XPOST -H "Authorization: Bearer 7227a2c2ebdbc267438e7ece2bdd0a" <a class="ae ky" href="http://localhost/data" rel="noopener ugc nofollow" target="_blank">http://localhost/data</a> -d '{"ok": "hello"}' -H 'Content-Type: application/json'</span></pre><p id="3746" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li nl mf mg lm nm mi mj lq nn ml mm mn im bi translated">仪表板将实时更新有效负载的内容:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/63a20b6df611a1d4f3fab16af08ad0ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XUSH-InLM6CbJC0krh0Yqg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">仪表板中收到的有效负载</figcaption></figure></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><p id="d956" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li nl mf mg lm nm mi mj lq nn ml mm mn im bi translated">在下一篇文章中，我们将在本地Kubernetes集群上部署webhooks应用程序。</p></div></div>    
</body>
</html>