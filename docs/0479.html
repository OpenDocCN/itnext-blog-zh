<html>
<head>
<title>Asynchronicity in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的异步性</h1>
<blockquote>原文：<a href="https://itnext.io/asynchronicity-in-javascript-93abb3a3f81b?source=collection_archive---------3-----------------------#2018-03-15">https://itnext.io/asynchronicity-in-javascript-93abb3a3f81b?source=collection_archive---------3-----------------------#2018-03-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div class="gh gi io"><img src="../Images/234e52a54cab14df45f16394a68e6d2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vsXoOtC2IxCvr4Rov0xAXg.jpeg"/></div><figcaption class="iv iw gj gh gi ix iy bd b be z dk translated">图像可能受版权保护</figcaption></figure><div class=""/><h1 id="8eea" class="jy jz jb bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">前言</h1><p id="1362" class="pw-post-body-paragraph kw kx jb ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">为了对JS异步性有一个基本的了解，你可以在<a class="ae lu" href="https://github.com/n0ruSh/the-art-of-reading/issues/1" rel="noopener ugc nofollow" target="_blank">深入了解JS异步性</a>。如果没有对异步性(例如事件循环、事件队列等)的深刻理解，setTimeout/setInterval、ajax在浏览器、节点IO中的应用将不会走得很远。).</p><h1 id="f43a" class="jy jz jb bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">空谈是廉价的，给我看看代码</h1><p id="e019" class="pw-post-body-paragraph kw kx jb ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">假设我们有一个包含文件名列表的数组。我们希望依次读取这些文件，直到成功检索到一个文件。比如，如果数组是['a.txt '，' b.txt']，我们先读取<em class="lv"> a.txt </em>，如果读取成功，我们返回<em class="lv"> a.txt </em>的文件内容。否则我们继续读<em class="lv"> b.txt </em>。为了读取文件，Nodes提供了两个API，一个是sync <a class="ae lu" href="https://nodejs.org/api/fs.html#fs_fs_readfilesync_path_options" rel="noopener ugc nofollow" target="_blank"> readFileSync </a>，另一个是async <a class="ae lu" href="https://nodejs.org/api/fs.html#fs_fs_readfile_path_options_callback" rel="noopener ugc nofollow" target="_blank"> readFile </a>。</p><p id="9b59" class="pw-post-body-paragraph kw kx jb ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">现在假设我们有两个文件:<em class="lv"> a.txt </em>(其内容也是<em class="lv"> a.txt </em>)和<em class="lv"> b.txt </em>(其内容也是<em class="lv"> b.txt </em>)。</p><p id="0e1e" class="pw-post-body-paragraph kw kx jb ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">同步解决方案非常简单:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="9d7f" class="mk jz jb mg b gy ml mm l mn mo">let fs = require('fs'),<br/>    path = require('path');</span><span id="4495" class="mk jz jb mg b gy mp mm l mn mo">function readOneSync(files) {<br/>    for(let i = 0, len = files.length; i &lt; len; i++) {<br/>        try {<br/>            return fs.readFileSync(path.join(__dirname, files[i]), 'utf8');<br/>        } catch(e) {<br/>            //ignore<br/>        }<br/>    }<br/>    // all fail, throw an exception<br/>    throw new Error('all fail');<br/>}</span><span id="b014" class="mk jz jb mg b gy mp mm l mn mo">console.log(readOneSync(['a.txt', 'b.txt'])); //a.txt<br/>console.log(readOneSync(['filenotexist', 'b.txt'])); //b.txt</span></pre><p id="5774" class="pw-post-body-paragraph kw kx jb ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">同步读取的主要问题是它会阻塞主线程和事件队列的循环。如果读取需要很长时间才能完成，特别是当文件很大时，程序会变得不活跃。异步读取可以有效地避免这个问题。我们需要注意的只是处理文件读取的顺序(即在前面的<em class="lv"> readFile </em>调用的回调中读取下一个文件)。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="7dd9" class="mk jz jb mg b gy ml mm l mn mo">let fs = require('fs'),<br/>    path = require('path');</span><span id="bc29" class="mk jz jb mg b gy mp mm l mn mo">function readOne(files, cb) {<br/>    function next(index) {<br/>        let fileName = files[index];<br/>        fs.readFile(path.join(__dirname, fileName), 'utf8', (err, data) =&gt; {<br/>            if(err) {<br/>                return next(index + 1); // if fail, read next file<br/>            } else {<br/>                return cb(data); // use cb to output the result<br/>            }<br/>        });<br/>    }<br/>    next(0);<br/>}</span><span id="c42f" class="mk jz jb mg b gy mp mm l mn mo">readOne(['a.txt', 'b.txt'], console.log); //a.txt<br/>readOne(['filenotexist', 'b.txt'], console.log); //b.txt</span></pre><p id="11c1" class="pw-post-body-paragraph kw kx jb ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">异步解决方案需要接受另一个参数(即<em class="lv"> cb </em>)来处理结果。它还定义了一个<em class="lv"> next </em>方法来递归读取下一个文件。</p><h1 id="a37b" class="jy jz jb bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">同时激发多个异步请求。</h1><p id="d293" class="pw-post-body-paragraph kw kx jb ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">假设我们有一个包含文件名列表的数组，我们的目标是同时读取文件，如果所有读取都成功，就返回所有文件内容。如果其中任何一个失败，则调用失败的回调。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="40c9" class="mk jz jb mg b gy ml mm l mn mo">let fs = require('fs'),<br/>    path = require('path');</span><span id="52f1" class="mk jz jb mg b gy mp mm l mn mo">function readAllV1(files, onsuccess, onfail) {<br/>    let result = [];<br/>    files.forEach(file =&gt; {<br/>        fs.readFile(path.join(__dirname, file), 'utf8', (err, data) =&gt; {<br/>            if(err) {<br/>                onfail(err);<br/>            } else {<br/>                result.push(data);<br/>                if(result.length === files.length) {<br/>                    onsuccess(result);<br/>                }<br/>            }<br/>        });<br/>    });<br/>}</span><span id="38ac" class="mk jz jb mg b gy mp mm l mn mo">readAllV1(['a.txt', 'b.txt'], console.log, console.log);</span></pre><p id="b39d" class="pw-post-body-paragraph kw kx jb ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">上面的实现有一个明显的问题:结果中<em class="lv">文件内容的顺序与<em class="lv">文件</em>中的顺序不匹配。所有读取操作都是异步的，因此当读取完成时，回调被插入到事件队列中。假设<em class="lv">文件</em>为['a.txt '，【b.txt']，则<em class="lv"> a.txt </em>和<em class="lv"> b.txt </em>的文件大小分别为100M和10kb。当我们同时异步读取这两个文件时，<em class="lv"> b.txt </em>的读取将在<em class="lv"> a.txt </em>之前完成，因此<em class="lv"> b.txt </em>的回调将在事件队列中<em class="lv"> a.txt </em>的回调之前。最终的<em class="lv">结果</em>将会是[${content of <em class="lv"> b.txt </em> }，${content of <em class="lv"> a.txt </em> }]。如果我们希望<em class="lv">结果</em>中文件内容的顺序遵循<em class="lv">文件</em>中文件名的顺序，我们可以对我们的实现做一个小的修改:</em></p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="014f" class="mk jz jb mg b gy ml mm l mn mo">let fs = require('fs'),<br/>    path = require('path');</span><span id="faf7" class="mk jz jb mg b gy mp mm l mn mo">function readAllV2(files, onsuccess, onfail) {<br/>    let result = [];<br/>    files.forEach((file, index) =&gt; {<br/>        fs.readFile(path.join(__dirname, file), 'utf8', (err, data) =&gt; {<br/>            if(err) {<br/>                onfail(err);<br/>            } else {<br/>                result[index] = data;<br/>                if(result.length === files.length) {<br/>                    onsuccess(result);<br/>                }<br/>            }<br/>        });<br/>    });<br/>}</span><span id="cd63" class="mk jz jb mg b gy mp mm l mn mo">readAllV2(['a.txt', 'b.txt'], console.log, console.log); //结果不确定性</span></pre><p id="314a" class="pw-post-body-paragraph kw kx jb ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">乍一看好像很管用，但是！</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="b66e" class="mk jz jb mg b gy ml mm l mn mo">let arr = [];<br/>arr[1] = 'a';<br/>console.log(arr.length); //2</span></pre><p id="94d1" class="pw-post-body-paragraph kw kx jb ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">基于<em class="lv"> readAllV2 </em>的实现，如果读取<em class="lv"> b.txt </em>在<em class="lv"> a.txt </em>之前完成，那么我们设置result[1]= $ { content of<em class="lv">b . txt</em>}，导致<em class="lv">result . length = = = files . length</em>为真。在这种情况下，我们调用成功回调来终止函数，而没有得到<em class="lv"> a.txt </em>的结果。因此，我们不能简单地依靠<em class="lv"> result.length </em>作为补充指标。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="319a" class="mk jz jb mg b gy ml mm l mn mo">let fs = require('fs'),<br/>    path = require('path');</span><span id="83b1" class="mk jz jb mg b gy mp mm l mn mo">function readAllV3(files, onsuccess, onfail) {<br/>    let result = [], counter = 0;<br/>    files.forEach((file, index) =&gt; {<br/>        fs.readFile(path.join(__dirname, file), 'utf8', (err, data) =&gt; {<br/>            if(err) {<br/>                onfail(err);<br/>            } else {<br/>                result[index] = data;<br/>                counter++;<br/>                if(counter === files.length) {<br/>                    onsuccess(result);<br/>                }<br/>            }<br/>        });<br/>    });<br/>}</span><span id="1def" class="mk jz jb mg b gy mp mm l mn mo">readAllV3(['a.txt', 'b.txt'], console.log, console.log); //[ 'a.txt', 'b.txt' ]</span></pre><p id="6dca" class="pw-post-body-paragraph kw kx jb ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">如果你对承诺有点熟悉，你可能知道有一个<a class="ae lu" href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Promise/all" rel="noopener ugc nofollow" target="_blank">的承诺方法，它做完全一样的事情。</a></p><h1 id="624e" class="jy jz jb bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">让你的界面一致</h1><p id="e4c7" class="pw-post-body-paragraph kw kx jb ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">让我们实现具有缓存功能的自定义读取文件方法。如果缓存可用于文件，我们只需返回缓存。否则，我们读取文件并设置缓存。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="24cf" class="mk jz jb mg b gy ml mm l mn mo">let fs = require('fs'),<br/>    path = require('path'),<br/>    cache = {};</span><span id="ae16" class="mk jz jb mg b gy mp mm l mn mo">function readWithCacheV1(file, onsuccess, onfail) {<br/>    if(cache[file]) {<br/>        onsuccess(cache[file]);<br/>    } else {<br/>       fs.readFile(path.join(__dirname, file), 'utf8', (err, data) =&gt; {<br/>           if(err) {<br/>               onfail(err);<br/>           } else {<br/>               cache[file] = data;<br/>               onsuccess(data);<br/>           }<br/>       });<br/>    }<br/>}</span></pre><p id="8dfb" class="pw-post-body-paragraph kw kx jb ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">让我们深入了解一下:</p><ul class=""><li id="a799" class="mq mr jb ky b kz lw ld lx lh ms ll mt lp mu lt mv mw mx my bi translated">当缓存可用时，我们调用<em class="lv">on success</em><strong class="ky jc">SYNCHRONOUS</strong></li></ul><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="2c5a" class="mk jz jb mg b gy ml mm l mn mo">cache['a.txt'] = 'hello'; //mock cache data<br/>readWithCacheV1('a.txt', console.log);//synchronous, completes before going into next call.<br/>console.log('after you');</span><span id="1cc7" class="mk jz jb mg b gy mp mm l mn mo">//console output:<br/>hello<br/>after you</span></pre><ul class=""><li id="2852" class="mq mr jb ky b kz lw ld lx lh ms ll mt lp mu lt mv mw mx my bi translated">当缓存不可用时，由于<em class="lv"> readFile </em>的异步性，它是<strong class="ky jc">异步</strong></li></ul><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="566a" class="mk jz jb mg b gy ml mm l mn mo">readWithCacheV1('a.txt', console.log);<br/>console.log('after you');</span><span id="307d" class="mk jz jb mg b gy mp mm l mn mo">//console output:<br/>after you<br/>hello</span></pre><p id="e87e" class="pw-post-body-paragraph kw kx jb ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">这种不一致性通常会导致难以跟踪和调试的隐藏错误。我们可以改进解决方案，使其行为一致。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="ff66" class="mk jz jb mg b gy ml mm l mn mo">let fs = require('fs'),<br/>    path = require('path'),<br/>    cache = {};</span><span id="e00c" class="mk jz jb mg b gy mp mm l mn mo">function readWithCacheV2(file, onsuccess, onfail) {<br/>    if(cache[file]) {<br/>        setTimeout(onsuccess.bind(null, cache[file]),0);<br/>    } else {<br/>       fs.readFile(path.join(__dirname, file), 'utf8', (err, data) =&gt; {<br/>           if(err) {<br/>               onfail(err);<br/>           } else {<br/>               cache[file] = data;<br/>               onsuccess(data);<br/>           }<br/>       });<br/>    }<br/>}</span></pre><p id="2555" class="pw-post-body-paragraph kw kx jb ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">让我们重新审视两个用例:</p><ul class=""><li id="1216" class="mq mr jb ky b kz lw ld lx lh ms ll mt lp mu lt mv mw mx my bi translated">有缓存可用`` JavaScript cache[' a . txt ']= ' hello '；readWithCacheV2('a.txt '，console . log)；console . log(' after you ')；</li></ul><p id="62d8" class="pw-post-body-paragraph kw kx jb ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">//控制台输出:你好</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="6a30" class="mk jz jb mg b gy ml mm l mn mo">* without cache</span><span id="cd09" class="mk jz jb mg b gy mp mm l mn mo">```javascript<br/>readWithCacheV2('a.txt', console.log);<br/>console.log('after you');</span><span id="2e36" class="mk jz jb mg b gy mp mm l mn mo">//console output:<br/>after you<br/>hello</span></pre><h1 id="8f39" class="jy jz jb bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">参考</h1><ul class=""><li id="0410" class="mq mr jb ky b kz la ld le lh mz ll na lp nb lt mv mw mx my bi translated"><a class="ae lu" href="https://www.amazon.com/Effective-JavaScript-Specific-Software-Development/dp/0321812182/ref=sr_1_3?s=books&amp;ie=UTF8&amp;qid=1521248523&amp;sr=1-3&amp;keywords=Effective+JavaScript" rel="noopener ugc nofollow" target="_blank">有效的JavaScript </a></li></ul><h1 id="ea25" class="jy jz jb bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">代码示例</h1><ul class=""><li id="3238" class="mq mr jb ky b kz la ld le lh mz ll na lp nb lt mv mw mx my bi translated"><a class="ae lu" href="https://github.com/n0ruSh/the-art-of-reading/tree/master/javascript/Effective%20Javascript" rel="noopener ugc nofollow" target="_blank">有效的JavaSript示例代码</a></li></ul><h1 id="f8b6" class="jy jz jb bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">通知；注意</h1><ul class=""><li id="36ff" class="mq mr jb ky b kz la ld le lh mz ll na lp nb lt mv mw mx my bi translated">如果您想了解最新的新闻/文章，请点击<a class="ae lu" href="https://github.com/n0ruSh/the-art-of-reading" rel="noopener ugc nofollow" target="_blank">【观看】</a>订阅。</li></ul></div></div>    
</body>
</html>