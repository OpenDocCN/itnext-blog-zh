<html>
<head>
<title>Performance Tracking in React Native</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React Native中的性能跟踪</h1>
<blockquote>原文：<a href="https://itnext.io/react-native-profiler-43d131130c5c?source=collection_archive---------3-----------------------#2018-11-19">https://itnext.io/react-native-profiler-43d131130c5c?source=collection_archive---------3-----------------------#2018-11-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/315c6b72b88268d44319ad411d4b534f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EvaER3e7FcT3ivkQsMUTYg.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">尼克·雷诺兹在<a class="ae kc" href="https://unsplash.com/search/photos/fast?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="2857" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">更新:</strong>关于React Profiler API和设置，请遵循官方文档:<a class="ae kc" href="https://reactjs.org/docs/profiler.html" rel="noopener ugc nofollow" target="_blank">https://reactjs.org/docs/profiler.html</a>。请注意，<strong class="kf ir">稳定的</strong>分析器是在<strong class="kf ir">React Native</strong><a class="ae kc" href="https://github.com/react-native-community/releases/blob/master/CHANGELOG.md#0610" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir">0 . 61 . 0</strong></a><strong class="kf ir"/>(<a class="ae kc" href="https://github.com/facebook/react/releases/tag/v16.9.0" rel="noopener ugc nofollow" target="_blank">React-16 . 9 . 0</a>)中发布的</p><h1 id="f87f" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">动机</h1><p id="4326" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">每当我致力于优化某个组件以使其性能更好时，我都希望看到度量的结果，最好是来自用户的结果。</p><p id="cd3e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不幸的是，在React Native的早期版本中，我只能在自己的设备或模拟器上测量性能。</p><p id="a36b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在最近的React Native v57版本中，我发现了一个不错的重要组件:</p><blockquote class="me"><p id="2858" class="mf mg iq bd mh mi mj mk ml mm mn la dk translated"><profiler id="{“ProfileComponent”}" onrender="{this.onRender}"/></p></blockquote><p id="aa17" class="pw-post-body-paragraph kd ke iq kf b kg mo ki kj kk mp km kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">剖析器组件将为所有包装组件提供用户度量。</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="b7c6" class="nc lc iq my b gy nd ne l nf ng">&lt;Profiler id={"ProfileComponent"} onRender={this.onRender}&gt;<br/>  &lt;View&gt;<br/>   &lt;Text&gt;Hi&lt;/Text&gt;<br/>  &lt;/View&gt;<br/>&lt;/Profiler&gt;</span></pre><p id="ecfa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">关于这个组件最好的部分不是容易看到我们组件的度量，而是我们可以在<strong class="kf ir">生产</strong>中使用它！</p><figure class="mt mu mv mw gt jr"><div class="bz fp l di"><div class="nh ni l"/></div></figure><blockquote class="nj nk nl"><p id="15e0" class="kd ke nm kf b kg kh ki kj kk kl km kn nn kp kq kr no kt ku kv np kx ky kz la ij bi translated">请注意，目前的分析器组件还不稳定。</p></blockquote><p id="980e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们从实现<strong class="kf ir">分析器</strong>和<strong class="kf ir"> Firebase性能工具的简单示例开始。</strong></p><h1 id="051c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><strong class="ak">要求👈</strong></h1><ul class=""><li id="7e2f" class="nq nr iq kf b kg lz kk ma ko ns ks nt kw nu la nv nw nx ny bi translated">反应本土<strong class="kf ir"> ^0.57.3🔪</strong>(从0.56开始也有可能，但还没测试过)</li><li id="27e8" class="nq nr iq kf b kg nz kk oa ko ob ks oc kw od la nv nw nx ny bi translated">弹出的React本地项目</li><li id="97bd" class="nq nr iq kf b kg nz kk oa ko ob ks oc kw od la nv nw nx ny bi translated">记录指标的工具(即:<a class="ae kc" href="https://rnfirebase.io/docs/v5.x.x/perf-mon/example" rel="noopener ugc nofollow" target="_blank"> Firebase性能工具</a></li></ul><h1 id="3efd" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">简单实现🤓</h1><h2 id="c0da" class="nc lc iq bd ld oe of dn lh og oh dp ll ko oi oj lp ks ok ol lt kw om on lx oo bi translated"><strong class="ak"> 1。为react-dom/profiler添加别名</strong></h2><p id="f1dc" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">为了在生产环境中进行概要分析，我们需要在<code class="fe op oq or my b">.babelrc</code>文件中添加<code class="fe op oq or my b">react-dom/profiler</code>和<code class="fe op oq or my b">scheduler/tracing</code>的别名。</p><p id="6006" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们编辑文件之前，我们需要安装这个包<code class="fe op oq or my b">babel-plugin-module-resolver</code>，它给我们带来了别名功能。</p><p id="fe5f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe op oq or my b">yarn add -D babel-plugin-module-resolver</code></p><p id="3d88" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦我们安装了babel插件，我们就像这样修改<code class="fe op oq or my b">.babelrc</code>:</p><figure class="mt mu mv mw gt jr"><div class="bz fp l di"><div class="os ni l"/></div></figure><h2 id="d8fb" class="nc lc iq bd ld oe of dn lh og oh dp ll ko oi oj lp ks ok ol lt kw om on lx oo bi translated">2.添加探查器组件</h2><p id="a40c" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们将从<code class="fe op oq or my b">React</code>导入<code class="fe op oq or my b">unstable_Profiler</code>，并创建一个别名以使我们的代码更具可读性。</p><p id="a9c1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">实现Profiler本身非常简单。只需包装您想要测量的代码的任何部分。</p><p id="fcfe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后一步是用<code class="fe op oq or my b">logMeasurement</code>函数监听<code class="fe op oq or my b">onRender</code>回调和console.log指标。正如您所看到的，函数是异步的，这部分是为了稍后实现Firebase性能。</p><figure class="mt mu mv mw gt jr"><div class="bz fp l di"><div class="os ni l"/></div></figure><p id="9436" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是<code class="fe op oq or my b">onRender</code>函数将返回的内容的快速概述:</p><ul class=""><li id="bf5f" class="nq nr iq kf b kg kh kk kl ko ot ks ou kw ov la nv nw nx ny bi translated"><code class="fe op oq or my b">id: string</code> -被测量的<code class="fe op oq or my b">Profiler</code>标签的<code class="fe op oq or my b">id</code>值。</li><li id="b720" class="nq nr iq kf b kg nz kk oa ko ob ks oc kw od la nv nw nx ny bi translated"><code class="fe op oq or my b">phase: “mount" | “update"</code> -识别该组件是否由于<code class="fe op oq or my b">state</code>或<code class="fe op oq or my b">props</code>的变化而被安装或重新渲染。</li><li id="a6aa" class="nq nr iq kf b kg nz kk oa ko ob ks oc kw od la nv nw nx ny bi translated"><code class="fe op oq or my b">actualDuration: number</code> -最近一次“挂载”或“更新”渲染花费在渲染<code class="fe op oq or my b">Profiler</code>及其后代上的时间。</li><li id="5b71" class="nq nr iq kf b kg nz kk oa ko ob ks oc kw od la nv nw nx ny bi translated"><code class="fe op oq or my b">baseDuration: number</code>-<code class="fe op oq or my b">Profiler</code>树中每个单独组件最近<code class="fe op oq or my b">render</code>时间的持续时间。</li></ul><blockquote class="nj nk nl"><p id="52e7" class="kd ke nm kf b kg kh ki kj kk kl km kn nn kp kq kr no kt ku kv np kx ky kz la ij bi translated">📖更多详情请咨询官方<a class="ae kc" href="https://github.com/bvaughn/rfcs/blob/profiler/text/0000-profiler.md" rel="noopener ugc nofollow" target="_blank">侧写员RFCS</a></p></blockquote><h1 id="36cc" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">添加性能监控</h1><p id="fabb" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">为了记录分析器指标，我选择了Firebase性能工具(<a class="ae kc" href="https://github.com/invertase/react-native-firebase" rel="noopener ugc nofollow" target="_blank">通过转化酶包</a>在RN中实现)</p><p id="eef9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我把最后的代码放在前面，所以我可以单独检查每个部分。</p><figure class="mt mu mv mw gt jr"><div class="bz fp l di"><div class="os ni l"/></div></figure><p id="140c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于我在<code class="fe op oq or my b">componentDidMount</code>中初始化跟踪，我必须在变量<code class="fe op oq or my b">initialMount</code>和<code class="fe op oq or my b">initialUpdates</code>中缓存初始渲染的值。然后记录这些数据(第21、22行)。</p><p id="b53e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我还使用<code class="fe op oq or my b">traceStarted</code>变量来跟踪跟踪是否已经开始。Firebase性能工具的当前实现是异步的。好消息是，在即将发布的版本中，perf工具应该变得同步(我会关注那些<a class="ae kc" href="https://rnfirebase.io/docs/v5.x.x/release-notes" rel="noopener ugc nofollow" target="_blank">发布说明</a>)</p><p id="b7ec" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了使这个例子非常简单，我只记录挂载时间<code class="fe op oq or my b">initialMount</code>(如果组件重新挂载，它将记录最后一次挂载)和计数器<code class="fe op oq or my b">updates</code>测量组件重新渲染的次数。</p><blockquote class="nj nk nl"><p id="e1e8" class="kd ke nm kf b kg kh ki kj kk kl km kn nn kp kq kr no kt ku kv np kx ky kz la ij bi translated">我们能够记录的另一件事是每次重新渲染需要多长时间。可能性几乎是无限的🤩</p></blockquote></div><div class="ab cl ow ox hu oy" role="separator"><span class="oz bw bk pa pb pc"/><span class="oz bw bk pa pb pc"/><span class="oz bw bk pa pb"/></div><div class="ij ik il im in"><p id="740a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过这个简单的方法，我们可以将性能跟踪添加到我们最重要的组件中。</p><p id="13c4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了提高代码的可重用性，我们可以为Profiler创建自己的HOC组件，并包含所有附加的逻辑。</p><h1 id="fef9" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">我应该在生产中使用它吗？🙇‍</h1><p id="31c7" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">在写这篇文章的时候，这是一个相当棘手的问题。因为整个特性仍然被标记为不稳定，并且React没有使用异步渲染。</p><p id="fc27" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在生产中使用profiler时，我们可以预料到一些小的缺点。让我们仔细看看我最关心的两个问题。</p><p id="0615" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先是Profiler会给我们的组件增加多少额外的提交时间，其次我们可能想看看我们的包大小会增加多少。</p><h2 id="aea9" class="nc lc iq bd ld oe of dn lh og oh dp ll ko oi oj lp ks ok ol lt kw om on lx oo bi translated"><strong class="ak">Profiler适合生产吗？</strong></h2><figure class="mt mu mv mw gt jr"><div class="bz fp l di"><div class="pd ni l"/></div></figure><p id="9ef0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要回答这个问题，我们可以尝试使用<a class="ae kc" href="https://github.com/facebook/react-devtools" rel="noopener ugc nofollow" target="_blank">React Developer Tools Profiler</a>来测量添加<code class="fe op oq or my b">&lt;Profiler&gt;</code>组件之前/之后的影响。</p><p id="8f3c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我的测试用例由<code class="fe op oq or my b">FlatList</code>和渲染10倍的<code class="fe op oq or my b">native-base</code> <code class="fe op oq or my b">&lt;Card /&gt;</code>组件组成。</p><p id="bdc6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">出于测试目的，我创建了两个组件。用相同的代码。唯一的区别是在<code class="fe op oq or my b">&lt;ProfilerComponent /&gt;</code>上增加了一个<code class="fe op oq or my b">&lt;Profiler /&gt;</code>组件。</p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi pe"><img src="../Images/03bc751a63bb5ac59323d06d363abf7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A9CWnxICp9fTGBdC4Hbtbw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">一次测试运行的真实数据示例</figcaption></figure><p id="e960" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦我为每个组件运行这个测试10次，我得到了组件的AVG提交时间。</p><ul class=""><li id="f6c0" class="nq nr iq kf b kg kh kk kl ko ot ks ou kw ov la nv nw nx ny bi translated">提交时间<strong class="kf ir">与</strong>分析器:<strong class="kf ir">174毫秒</strong></li><li id="65a8" class="nq nr iq kf b kg nz kk oa ko ob ks oc kw od la nv nw nx ny bi translated">提交时间<strong class="kf ir">没有</strong>分析器:<strong class="kf ir">166毫秒</strong></li></ul><p id="bc4c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以看到，分析器组件增加了大约5%的额外提交时间。</p><p id="9849" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个结果出乎我的意料。</p><h2 id="b4bb" class="nc lc iq bd ld oe of dn lh og oh dp ll ko oi oj lp ks ok ol lt kw om on lx oo bi translated"><strong class="ak">捆尺寸</strong></h2><p id="f8fe" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">由于React本机渲染器是从上游repo同步的，所以最好总是根据RN版本检查实际大小。</p><p id="60ed" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最新渲染器:</p><ul class=""><li id="971c" class="nq nr iq kf b kg kh kk kl ko ot ks ou kw ov la nv nw nx ny bi translated"><a class="ae kc" href="https://github.com/facebook/react-native/blob/master/Libraries/Renderer/implementations/ReactNativeRenderer-prod.js" rel="noopener ugc nofollow" target="_blank">ReactNativeRenderer-prod . js</a></li><li id="9564" class="nq nr iq kf b kg nz kk oa ko ob ks oc kw od la nv nw nx ny bi translated"><a class="ae kc" href="https://github.com/facebook/react-native/blob/master/Libraries/Renderer/implementations/ReactNativeRenderer-profiling.js" rel="noopener ugc nofollow" target="_blank">ReactNativeRenderer-profiling . js</a></li></ul><p id="0072" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在撰写本文时，产品渲染器的包大小比较为<strong class="kf ir"> 260kB </strong>，概要渲染器的包大小比较为<strong class="kf ir"> 272kB </strong>。这几乎没有增加额外的包大小，即使相对较小的RN应用程序也只有几兆字节的代码。</p><h2 id="6a2b" class="nc lc iq bd ld oe of dn lh og oh dp ll ko oi oj lp ks ok ol lt kw om on lx oo bi translated"><strong class="ak">结论</strong></h2><p id="0a2f" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">基于这两个结果，我会毫不犹豫地在生产中使用Profiler。</p><p id="41d7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">唯一需要记住的是，过度使用Profiler将不可避免地导致性能下降。</p><blockquote class="me"><p id="fdc9" class="mf mg iq bd mh mi mj mk ml mm mn la dk translated">快乐的侧写时间！🎄</p></blockquote><h1 id="9755" class="lb lc iq bd ld le lf lg lh li lj lk ll lm pf lo lp lq pg ls lt lu ph lw lx ly bi translated">资源</h1><p id="d9b8" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我用来收集有关Profiler信息的所有资源:</p><ul class=""><li id="dd9f" class="nq nr iq kf b kg kh kk kl ko ot ks ou kw ov la nv nw nx ny bi translated"><a class="ae kc" href="https://github.com/bvaughn/rfcs/blob/profiler/text/0000-profiler.md" rel="noopener ugc nofollow" target="_blank">侧写员RFCS </a></li><li id="2bb5" class="nq nr iq kf b kg nz kk oa ko ob ks oc kw od la nv nw nx ny bi translated"><a class="ae kc" href="https://gist.github.com/bvaughn/25e6233aeb1b4f0cdb8d8366e54a3977#profiling-in-production" rel="noopener ugc nofollow" target="_blank">如何在生产中启用性能分析</a></li><li id="0300" class="nq nr iq kf b kg nz kk oa ko ob ks oc kw od la nv nw nx ny bi translated"><a class="ae kc" href="https://github.com/facebook/react/pull/12745/files" rel="noopener ugc nofollow" target="_blank">将分析器投入使用的拉请求🤓</a></li></ul></div><div class="ab cl ow ox hu oy" role="separator"><span class="oz bw bk pa pb pc"/><span class="oz bw bk pa pb pc"/><span class="oz bw bk pa pb"/></div><div class="ij ik il im in"><blockquote class="me"><p id="873d" class="mf mg iq bd mh mi mj mk ml mm mn la dk translated">你有什么想法？如果你觉得这篇文章有用，别忘了分享并给予一些赞扬！❤️️️️️</p></blockquote></div></div>    
</body>
</html>