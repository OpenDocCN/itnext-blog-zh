<html>
<head>
<title>How to migrate AMD to ES modules</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何将AMD迁移到ES模块</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-migrate-amd-to-es-modules-1107395a150c?source=collection_archive---------3-----------------------#2022-09-03">https://itnext.io/how-to-migrate-amd-to-es-modules-1107395a150c?source=collection_archive---------3-----------------------#2022-09-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="22fb" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">永远忘记AMD吧，再也没有使用AMD的好理由了</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c2740d17515e95e487cbe820aa05e7f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uasx9rPL_94-0s86kuVPYQ.png"/></div></div></figure><p id="69b5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">AMD模块曾经很受欢迎。许多网络应用程序和网站都是使用AMD模块开发的。但是最近ES模块已经明显超过了传统的AMD模块。</p><p id="34e4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当时，AMD模块最吸引人的特性是，与CommonJS模块不同，它们可以在浏览器中运行，无需额外的预处理。开发过程中的构建步骤需要时间，并且会使调试变得复杂。ES模块也不需要被转换和捆绑以在浏览器中执行。与AMD相比，ES模块具有额外的有用功能。加载顺序定义明确，加载过程中的错误消息更能提供信息。循环依赖是我最喜欢的特性。循环依赖允许快速修复和重构代码，同时保持应用程序的功能。基于承诺的动态导入只允许在需要的时候加载代码。<a class="ae lq" href="https://javascript.plainenglish.io/what-is-better-preloading-or-caching-javascript-modules-246d3573e6ad?source=your_stories_page-------------------------------------&amp;gi=36a8fcb5236b" rel="noopener ugc nofollow" target="_blank">预加载和缓存模块使得绑定变得可有可无，至少在企业应用中是如此。</a>与Rollup捆绑比与Webpack捆绑AMD模块更容易。</p><p id="fbc3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">ES模块唯一的相对限制是它们还不支持HTML模板的导入。<a class="ae lq" href="https://marian-caikovski.medium.com/how-to-import-html-template-file-into-javascript-module-265746167974" rel="noopener">所以现在可以用顶层</a> <code class="fe lr ls lt lu b"><a class="ae lq" href="https://marian-caikovski.medium.com/how-to-import-html-template-file-into-javascript-module-265746167974" rel="noopener">await</a></code>加载文本文件。</p><h1 id="e81e" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">如何从AMD迁移到ES模块</h1><p id="4f31" class="pw-post-body-paragraph ku kv it kw b kx mn ju kz la mo jx lc ld mp lf lg lh mq lj lk ll mr ln lo lp im bi translated">直到最近，我还维护着几个前端由几百个AMD模块组成的应用程序。为了简化他们的开发，我最近将应用程序转换成了ES模块。除了具有复杂条件动态导入的少数模块，转换非常简单——将<code class="fe lr ls lt lu b">define()</code>参数转换为<code class="fe lr ls lt lu b">import</code>语句，并将函数中的<code class="fe lr ls lt lu b">return</code>替换为<code class="fe lr ls lt lu b">export default</code>。事实上，ES模块中存在<code class="fe lr ls lt lu b">export default</code>的主要原因是为了便于从AMD移植。</p><p id="971c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了在很大程度上自动化转换，我开发了一个简单的基于<em class="ms"> Nodejs </em>的工具。这个应用程序依赖于一个JavaScript解析器库<em class="ms"> acorn </em>(如果你从未使用过JavaScript解析器，你可能会有兴趣看看它们是做什么的<a class="ae lq" href="https://astexplorer.net/" rel="noopener ugc nofollow" target="_blank">https://astexplorer.net/</a>)。</p><p id="8a65" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我不打算再使用我的工具，因为我没有更多的应用程序要迁移。但也许我的工具或它的碎片对其他人可能有用。</p><p id="604a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了说明该工具的功能，下面我展示了在该工具的详尽测试用例中使用的输入和预期输出的彩色图片。</p><h1 id="879d" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">定义模块的许多方法</h1><p id="9ff0" class="pw-post-body-paragraph ku kv it kw b kx mn ju kz la mo jx lc ld mp lf lg lh mq lj lk ll mr ln lo lp im bi translated">在<code class="fe lr ls lt lu b">define()</code>函数中定义了一个AMD模块。通常<code class="fe lr ls lt lu b">define()</code>接收一个带有模块路径的数组和一个接收列出的模块并返回一个模块的函数。</p><h2 id="4687" class="mt lw it bd lx mu mv dn mb mw mx dp mf ld my mz mh lh na nb mj ll nc nd ml ne bi translated">用依赖数组和函数定义()</h2><p id="eb3d" class="pw-post-body-paragraph ku kv it kw b kx mn ju kz la mo jx lc ld mp lf lg lh mq lj lk ll mr ln lo lp im bi translated">每个依赖路径连同定义函数的相应参数成为一个<code class="fe lr ls lt lu b">import</code>语句。功能的<code class="fe lr ls lt lu b">return</code>变为<code class="fe lr ls lt lu b">export default</code>。<code class="fe lr ls lt lu b">define()</code>被移除。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/f5e832a5f9ad84b5b39b5ec4625a44aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*whjnIA9IQfNjwK38RpXOhw.png"/></div></div></figure><h2 id="2a84" class="mt lw it bd lx mu mv dn mb mw mx dp mf ld my mz mh lh na nb mj ll nc nd ml ne bi translated">define()加载一个HTML模板</h2><p id="e488" class="pw-post-body-paragraph ku kv it kw b kx mn ju kz la mo jx lc ld mp lf lg lh mq lj lk ll mr ln lo lp im bi translated"><em class="ms"> RequireJS </em>允许使用<em class="ms"> text.js </em>插件加载文本依赖。<a class="ae lq" href="https://marian-caikovski.medium.com/how-to-import-json-into-javascript-module-json-modules-e6721e19a314" rel="noopener"> ES模块支持导入JSON</a>，但尚不支持导入HTML。一个HTML模板可以被加载到一个带有顶层<code class="fe lr ls lt lu b">await</code>的ES模块中。我在之前的一篇文章中详细介绍了这种方法。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/689e5a62de8f7af8c2b218467f33dad6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r0qvk-Wq9doo-_FTL53Jjw.png"/></div></div></figure><h2 id="f210" class="mt lw it bd lx mu mv dn mb mw mx dp mf ld my mz mh lh na nb mj ll nc nd ml ne bi translated">使用依赖数组和不带return语句的函数定义()</h2><p id="7ff2" class="pw-post-body-paragraph ku kv it kw b kx mn ju kz la mo jx lc ld mp lf lg lh mq lj lk ll mr ln lo lp im bi translated">生成的ES模块没有导出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/1ac325ebf2491af1ba54ecddbf0e3d13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IZMFnLYqh8BkHzn2OrMWnw.png"/></div></div></figure><h2 id="a4a5" class="mt lw it bd lx mu mv dn mb mw mx dp mf ld my mz mh lh na nb mj ll nc nd ml ne bi translated">用不带参数的函数定义()</h2><p id="53da" class="pw-post-body-paragraph ku kv it kw b kx mn ju kz la mo jx lc ld mp lf lg lh mq lj lk ll mr ln lo lp im bi translated">因为源AMD模块没有依赖性，所以产生的es模块没有<code class="fe lr ls lt lu b">import</code></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ni"><img src="../Images/23f6b1d235cda8ad228434d22e42bb02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5H6AQLqubJPMTLVitKAl5Q.png"/></div></div></figure><h2 id="1efd" class="mt lw it bd lx mu mv dn mb mw mx dp mf ld my mz mh lh na nb mj ll nc nd ml ne bi translated">用不带return语句的函数定义()</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/45f94d7b89850524fa25eec96f52ea8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aO7T-U5o5E0w0cWlfxlJAg.png"/></div></div></figure><h2 id="76dc" class="mt lw it bd lx mu mv dn mb mw mx dp mf ld my mz mh lh na nb mj ll nc nd ml ne bi translated">用对象定义()</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/f09509e1d1fa6acb2c95007906974615.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rd8eY_8V9VX_RSO4e2HlOg.png"/></div></div></figure><h1 id="4d4e" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">处理要求js()</h1><p id="e8ca" class="pw-post-body-paragraph ku kv it kw b kx mn ju kz la mo jx lc ld mp lf lg lh mq lj lk ll mr ln lo lp im bi translated">与<code class="fe lr ls lt lu b">define()</code>不同的是，<code class="fe lr ls lt lu b">requirejs()</code>不创建模块，它通常在<em class="ms"> main.js </em>中用来加载定义好的模块并启动应用程序。</p><h2 id="09e7" class="mt lw it bd lx mu mv dn mb mw mx dp mf ld my mz mh lh na nb mj ll nc nd ml ne bi translated">带有依赖数组和函数的requirejs()</h2><p id="1914" class="pw-post-body-paragraph ku kv it kw b kx mn ju kz la mo jx lc ld mp lf lg lh mq lj lk ll mr ln lo lp im bi translated">它被视为带有不带<code class="fe lr ls lt lu b">return</code>语句的函数的<code class="fe lr ls lt lu b">define()</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nl"><img src="../Images/5b5c4d52d866f686cd6f22cca90ab25a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y0mmbpGaF-XfB0Gkleqdkw.png"/></div></div></figure><h2 id="1fab" class="mt lw it bd lx mu mv dn mb mw mx dp mf ld my mz mh lh na nb mj ll nc nd ml ne bi translated">嵌套的requirejs()</h2><p id="a344" class="pw-post-body-paragraph ku kv it kw b kx mn ju kz la mo jx lc ld mp lf lg lh mq lj lk ll mr ln lo lp im bi translated">鉴于<code class="fe lr ls lt lu b">define()</code>不能嵌套，<code class="fe lr ls lt lu b">requirejs()</code>可以在<code class="fe lr ls lt lu b">requirejs()</code>或<code class="fe lr ls lt lu b">define()</code>内。嵌套的<code class="fe lr ls lt lu b">requirejs()</code>用于条件导入的条件内部。但是使用<code class="fe lr ls lt lu b">requirejs()</code>的动态导入相对较少，而且可能很复杂，所以手动精确处理它们比编写一个可靠的代码转换成动态导入更容易。我的工具只是用功能等同的<code class="fe lr ls lt lu b">import()</code>替换了嵌套的<code class="fe lr ls lt lu b">requirejs()</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nm"><img src="../Images/3aefef044ade02cd696fb4991ce484cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z2WITlzEw364R6rpmsWXiQ.png"/></div></div></figure><p id="07d7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果requirejs()嵌套在define()中，结果相同。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/b3a903dd2950609249910135619935eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bhTyW6O2ukfp0K4JQpvA3Q.png"/></div></div></figure><h1 id="a748" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">快速迁移</h1><p id="98c3" class="pw-post-body-paragraph ku kv it kw b kx mn ju kz la mo jx lc ld mp lf lg lh mq lj lk ll mr ln lo lp im bi translated">手续很快。它包括几个快速步骤:</p><ul class=""><li id="7e33" class="no np it kw b kx ky la lb ld nq lh nr ll ns lp nt nu nv nw bi translated">在迁移之前，将任何未提交的更改提交到本地<em class="ms"> git </em>存储库。使用git 你可以欣赏到该工具带来的所有变化。</li><li id="370b" class="no np it kw b kx nx la ny ld nz lh oa ll ob lp nt nu nv nw bi translated">打开命令行，转到包含该工具的文件夹并安装依赖项:<code class="fe lr ls lt lu b">npm install</code></li><li id="e6d1" class="no np it kw b kx nx la ny ld nz lh oa ll ob lp nt nu nv nw bi translated">通过执行指定包含AMD模块的文件夹的命令来启动该工具。该工具转换<em class="ms"> *。js </em>父文件夹上所有子文件夹中的文件:<code class="fe lr ls lt lu b">node main.js path/to/folder/with/js-files</code></li><li id="62af" class="no np it kw b kx nx la ny ld nz lh oa ll ob lp nt nu nv nw bi translated">现在传递给<code class="fe lr ls lt lu b">requirejs.config()</code>的对象的<code class="fe lr ls lt lu b">paths</code>对象应该被转换成HTML文件中的导入映射，通常是<em class="ms">index.html</em>，加载JavaScript代码。必须调整<code class="fe lr ls lt lu b">paths</code>中列出的文件夹和模块的URL，例如以<em class="ms"> js/ </em>为前缀，因为在导入映射中，URL与包含导入映射的文件相关。如果你从未使用过导入地图，请阅读<a class="ae lq" href="https://marian-caikovski.medium.com/remapping-javascript-module-names-with-import-maps-bd2bad121c1d" rel="noopener">一篇关于导入地图的帖子</a>。</li><li id="c0bd" class="no np it kw b kx nx la ny ld nz lh oa ll ob lp nt nu nv nw bi translated">尝试启动转换后的应用程序。如果失败，您可以在控制台中看到原因。首先，应用程序可能会因为导入映射中未正确定义的模块说明符而失败。但是在导入映射中进行了几次调整后，应用程序将开始工作。除了格式化之外，大多数转换后的模块不需要任何额外的手动后处理。</li><li id="f118" class="no np it kw b kx nx la ny ld nz lh oa ll ob lp nt nu nv nw bi translated">如果源应用程序有任何基于<code class="fe lr ls lt lu b">requirejs()</code>的导入，检查它们并调整自动转换的代码。</li></ul><h2 id="1b11" class="mt lw it bd lx mu mv dn mb mw mx dp mf ld my mz mh lh na nb mj ll nc nd ml ne bi translated">刻痕</h2><p id="b701" class="pw-post-body-paragraph ku kv it kw b kx mn ju kz la mo jx lc ld mp lf lg lh mq lj lk ll mr ln lo lp im bi translated">转换后的代码未格式化。它可以通过运行一个额外的库来格式化，但我个人更喜欢在转换后清楚地看到哪些文件没有被我编辑。当我修改代码时，我总是格式化它。</p></div><div class="ab cl oc od hx oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="im in io ip iq"><p id="5dc5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">将基于AMD的JavaScript代码移植到ES模块的工具可以从<a class="ae lq" href="https://github.com/marianc000/amdToEsm" rel="noopener ugc nofollow" target="_blank">https://github.com/marianc000/amdToEsm</a>下载</p></div></div>    
</body>
</html>