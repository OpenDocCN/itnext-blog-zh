<html>
<head>
<title>Hack the GNOME Shell — Create Extensions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">破解GNOME Shell——创建扩展</h1>
<blockquote>原文：<a href="https://itnext.io/hacking-the-gnome-shell-create-extensions-ef3e4ecac325?source=collection_archive---------5-----------------------#2022-10-17">https://itnext.io/hacking-the-gnome-shell-create-extensions-ef3e4ecac325?source=collection_archive---------5-----------------------#2022-10-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="02bb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">创建自己的GNOME Shell扩展(<em class="kl"> GSE </em>)非常简单。只需按照官方的<a class="ae km" href="https://wiki.gnome.org/Projects/GnomeShell/Extensions" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">指南</strong> </a> <strong class="jp ir"> </strong>去做，你就会有一个大约50行代码的工作<em class="kl"> GSE </em>。有许多视频、教程和文章可以进一步帮助您入门。本文希望您已经阅读了这些指南。</p><p id="5671" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">开发一个<em class="kl"> GSE，</em>不是典型的编码体验。如果您真的想修改Shell，特别是在行为方面，通常有必要将您自己的代码注入到Shell本身中。然后就变成了软件黑客的练习。</p><h1 id="5b4d" class="kn ko iq bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">为什么我创建我的第一个扩展——MAC OS和GNOME 40</h1><p id="3e37" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">我成为macOS的用户已经有一段时间了。我喜欢它的桌面，干净简约的主题，整洁的外观。在应用和窗口中导航，尤其是使用触控板手势，感觉非常自然。</p><p id="09a1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我永久地切换到使用Gnome的Linux时，我发现Gnome桌面可能是最接近T21体验的东西。Gnome 40在性能和功能上是如此的飞跃，以至于它可以吸引那些愿意尝试的新用户。</p><p id="0c6e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，Gnome 40版本也对桌面应该是什么样子非常固执己见。它将dash、应用列表、应用搜索、工作区切换器合并成一个大的<em class="kl">概览</em>。在macOS上，它们分别作为dock、launch pad、workspaces和Spotlight存在。每一个都有相似但仍可区分的功能。Windows 11遵循类似的模式。</p><p id="a587" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">概述</em>对*我*来说，是我个人更喜欢的干净、简约和整洁的反义词。更糟糕的是，每次首次登录时都会显示<em class="kl">概览</em>。我个人希望迎接我的是漂亮的壁纸。就像我希望我的眼睛糖果dash图标总是在桌面上可见，而不是隐藏在<em class="kl">概览</em>中。</p><p id="11a8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我说<em class="kl">非常固执己见</em>，因为没有简单的方法通过设置应用程序来改变这些。另一个不可更改的设置是三指滑动手势。虽然以前4个手指滑动可以切换工作空间，3个手指滑动可以映射到四处移动的窗口，但现在不再是这样了。</p><p id="dd4c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">谢天谢地，Gnome外壳仍然很容易修改。这就是我的Gnome shell黑客行为开始的地方——让它适合我的个人品味。</p><h1 id="f22c" class="kn ko iq bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">我的第一个模型</h1><p id="c314" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">我的第一个Gnome shell修改不是一个扩展，而是一个黑客。制作黑客遵循与制作扩展相同的第一步。</p><h1 id="4c0c" class="kn ko iq bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">第一步</h1><p id="d401" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">指南没有告诉你的是，生成扩展后最重要的步骤是<a class="ae km" href="https://github.com/gnome/gnome-shell" rel="noopener ugc nofollow" target="_blank">下载整个<em class="kl"> Gnome shell </em> source </a>。</p><p id="e0c0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们试图改变任何事情之前，我们必须知道我们在处理什么。因此，浏览一下<em class="kl"> Gnome shell </em>代码。从指南中我们已经知道扩展是用JavaScript编码的。现在，我们将发现外壳本身也几乎完全是用JavaScript编写的，或者至少可以从JavaScript访问。而且源代码组织得非常好。而明智的文件命名如<em class="kl"> dash.js、panel.js、appFavorites.js </em>会很快带领我们走向正确的方向。</p><h1 id="0a41" class="kn ko iq bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">四指滑动</h1><p id="ff34" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">第一个也是最容易修改的行为是手势——将3个手指变成4个手指来切换工作空间。SwipeTracker.js似乎是非常明显的候选文件。我们将立即找到下面的行:</p><pre class="lq lr ls lt gt lu lv lw lx aw ly bi"><span id="c978" class="lz ko iq lv b gy ma mb l mc md"><strong class="lv ir">const</strong> GESTURE_FINGER_COUNT = 3</span></pre><p id="503f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">常量</em>？不仅没有Gnome设置来将3改为4——这在以前是可用的— <em class="kl"> Gnome 40 </em>现在也很难通过硬编码手指数设置的扩展来修改它。</p><h1 id="c8a4" class="kn ko iq bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">黑客</h1><p id="a3d0" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">在以前的Gnome版本<em class="kl">中，swipeTracker.js </em>可以从系统文件中获得，你只需编辑代码就可以了。</p><p id="2b6d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，目前,<em class="kl"> Gnome shell </em>的JavaScript代码是作为资源嵌入到系统库<em class="kl"> libgnome-shell.so </em>中的。</p><p id="22fb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第一黑:用十六进制编辑器编辑库，找到文本<em class="kl">“const GESTURE _ FINGER _ COUNT = 3</em>”，将3改为4。重启linux就大功告成了。通过改变外壳库中的单个字符，我们现在有了一个4指手势工作区切换器。</p><p id="8a08" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我写了一个简单的<a class="ae km" href="https://github.com/icedman/gnome-shell-hammer/blob/master/shell/swipe3to4.py" rel="noopener ugc nofollow" target="_blank"> python脚本</a>来简化这个过程。</p><p id="4874" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">虽然这种方法对于个人消费来说已经足够好了，但它显然不是扩展外壳的推荐方式。手动编辑系统文件是一场迟早会发生的灾难。此外，每当我们更新操作系统和Gnome时，我们必须不断地修补库。</p><p id="8886" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用常规扩展可以实现同样的行为吗？</p><h1 id="a7ad" class="kn ko iq bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">猴子补丁</h1><p id="3a5a" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">Monkey patching是在<strong class="jp ir"> <em class="kl">运行时</em> </strong>修改一段代码行为的术语。用JavaScript很容易做到。</p><h2 id="491a" class="lz ko iq bd kp me mf dn kt mg mh dp kx jy mi mj lb kc mk ml lf kg mm mn lj mo bi translated">变量</h2><p id="2429" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">想象一下，如果手势_手指_计数不是一个<em class="kl">常量</em>声明。而是<em class="kl"> SwipeTracker </em>类的成员变量。编辑变量如下:</p><pre class="lq lr ls lt gt lu lv lw lx aw ly bi"><span id="20da" class="lz ko iq lv b gy ma mb l mc md">class MyExtension {<br/>  enable() {<br/>     SwipeTracker.gesture_finger_count = 4;<br/>  }</span><span id="06be" class="lz ko iq lv b gy mp mb l mc md">  disable () {<br/>     SwipeTracker.gesture_finger_count = 3;<br/>  }<br/>}</span></pre><p id="3411" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个简单的扩展就可以达到我们的目的。然而，事实并非如此。GESTURE_FINGER_COUNT不是成员变量，它被设置为不可访问和不可编辑。</p><p id="93d3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将不得不研究使用手势_手指_计数变量的修补函数。</p><h2 id="dc28" class="lz ko iq bd kp me mf dn kt mg mh dp kx jy mi mj lb kc mk ml lf kg mm mn lj mo bi translated">功能</h2><p id="61c3" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">修补功能可以用类似的方式完成。例如:</p><p id="0380" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl"> Main.overview.setMessage </em>是Shell中弹出通知消息的函数。我们可以通过将<em class="kl"> setMessage </em>指向我们自己的空函数来修改这种行为，如下所示:</p><pre class="lq lr ls lt gt lu lv lw lx aw ly bi"><span id="6c06" class="lz ko iq lv b gy ma mb l mc md">Main.overview.setMessage = () =&gt; {}</span></pre><p id="0b84" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这有效地使所有通知消息静音。</p><p id="e5bf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">猴子补丁函数和变量是修改<em class="kl"> Gnome外壳</em>的简单方法。</p><h1 id="044e" class="kn ko iq bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">信号</h1><p id="9697" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">修改Shell行为的另一种流行方式是监听和响应系统事件。</p><p id="715c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">几个外壳组件<em class="kl">发出</em>事件。例如，每当触摸板被访问时，<em class="kl"> global.stage </em>对象发出一个<em class="kl">capture-event::touchpad</em>事件。想要被通知该事件的其他组件将订阅或<em class="kl">连接</em>与<em class="kl">全局阶段</em></p><pre class="lq lr ls lt gt lu lv lw lx aw ly bi"><span id="d4c8" class="lz ko iq lv b gy ma mb l mc md">global.stage.connectObject('capture-event::touchpad', MyFunction, MyObject);</span></pre><p id="ee48" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以通过在特定事件被触发或发出时调用我们的代码来添加新的功能和效果。我发现很难找到Gnome shell的所有对象和事件的文档。但是在源代码中快速搜索<em class="kl"> emit </em>调用会让我们知道可以订阅什么。我用过的一些事件:</p><pre class="lq lr ls lt gt lu lv lw lx aw ly bi"><span id="41e5" class="lz ko iq lv b gy ma mb l mc md">'notify::focus-window'<br/>'in-fullscreen-changed'<br/>'icon-theme-changed'</span></pre><p id="f14c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们调用<em class="kl"> disconnectObject </em>来取消订阅。</p><h1 id="44e7" class="kn ko iq bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">扩展</h1><p id="c39f" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated"><em class="kl"> SwipeTracker </em>订阅<em class="kl"> global.stage </em>对象的功能，特别是通过监听<em class="kl"> capture-event::touchpad。</em></p><p id="6e36" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将猴子补丁<em class="kl"> SwipeTracker </em>或者更准确地说是使用<em class="kl"> SwipeTracker </em>的Shell组件。以下这些物体是值得注意的。</p><pre class="lq lr ls lt gt lu lv lw lx aw ly bi"><span id="3f31" class="lz ko iq lv b gy ma mb l mc md">Main.overview._swipeTracker._touchpadGesture;<br/>Main.wm._workspaceAnimation._swipeTracker._touchpadGesture;<br/>Main.overview._overview._controls._workspacesDisplay._swipeTracker._touchpadGesture;</span></pre><p id="2da9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">其中每一个都有一个<em class="kl"> _handleEvent </em>，每当触摸板事件被触发时都会被调用。</p><p id="8318" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们从<em class="kl"> global.stage </em>中取消订阅对象，以便不再调用<em class="kl"> _handleEvent </em>。</p><pre class="lq lr ls lt gt lu lv lw lx aw ly bi"><span id="ea2f" class="lz ko iq lv b gy ma mb l mc md">global.stage.disconnectObject(Main.overview._swipeTracker._touchpadGesture);</span><span id="5649" class="lz ko iq lv b gy mp mb l mc md">global.stage.connectObject('capture-event::touchpad', MY_OWN_HANDLE_EVENT, Main.overview._swipeTracker._touchpadGesture);</span></pre><p id="3249" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后我们重新订阅，这次传递我们自己的事件处理程序MY_OWN_HANDLE_EVENT。我们自己的代码将调用并返回原始<em class="kl"> _handleEvent的结果。</em>通过这种方式，外壳的行为尽可能接近以前。</p><pre class="lq lr ls lt gt lu lv lw lx aw ly bi"><span id="3f99" class="lz ko iq lv b gy ma mb l mc md">function MY_OWN_HANDLE_EVENT(actor, event) {</span><span id="68b4" class="lz ko iq lv b gy mp mb l mc md">  // do our magic here before passing through<br/>  // perhaps we want to modify the event object</span><span id="c7c0" class="lz ko iq lv b gy mp mb l mc md">  // Call the original handler<br/>  return _handleEvent(actor, event);<br/>}</span></pre><h2 id="7cfb" class="lz ko iq bd kp me mf dn kt mg mh dp kx jy mi mj lb kc mk ml lf kg mm mn lj mo bi translated">我们的魔法</h2><p id="4043" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated"><em class="kl"> _handleEvent </em>函数将接收一个<em class="kl">事件</em>对象作为其参数之一。这个事件对象包含触摸板事件的细节，并有一个名副其实的函数<em class="kl">get _ touchpad _ gesture _ finger _ count。</em></p><p id="13f1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将猴子补丁<em class="kl">事件</em>对象因此:</p><pre class="lq lr ls lt gt lu lv lw lx aw ly bi"><span id="c20a" class="lz ko iq lv b gy ma mb l mc md">(actor, event) =&gt; {</span><span id="de4c" class="lz ko iq lv b gy mp mb l mc md">// save the original function<br/>event._original_get_touchpad_gesture_finger_count = event.get_touchpad_gesture_finger_count;</span><span id="4c01" class="lz ko iq lv b gy mp mb l mc md">event.get_touchpad_gesture_finger_count<em class="kl"> = () =&gt; {<br/>  if (event.</em>_original_get_touchpad_gesture_finger_count() == 4) {<br/>     return 3;<br/>  }<br/>  return 0;<br/><em class="kl">}</em></span><span id="b172" class="lz ko iq lv b gy mp mb l mc md">// call the original handler with a modified event<br/>return _handleEvent(actor, event);</span></pre><p id="2434" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上面的代码只是在事件对象被传递给订阅者之前对其进行了修改。当检测到4个手指触摸时，<em class="kl">事件</em>对象的函数<em class="kl">get _ touchpad _ gesture _ finger _ count</em>将返回3而不是4。随后的代码将收到3个手指计数，并相应地采取行动。一个非常简单的技巧。</p><p id="48b5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当猴子修补函数时，通常会保存原始函数。以便在必要时仍然可以调用它。当我们的扩展被禁用时，这也给了我们恢复修补函数的能力。</p><p id="fd99" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们现在有了第一个有用的GSE。</p><h1 id="0494" class="kn ko iq bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">你脑海中的问题</h1><p id="d10f" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated"><em class="kl">我是如何了解Main、Main.overview、global、global.stage所有这些类和对象的？</em></p><p id="76cc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">—通过阅读<em class="kl"> Gnome shell </em>源代码。这一点怎么强调都不为过。你现在是黑客了。Gnome 让你不必对任何东西进行逆向工程。从源代码中发现你的入口点，然后开始破解。</p><p id="85b4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，如果你彻底通读了指南，你会了解到<em class="kl">窥镜</em>。这是一个不可或缺的工具。这是一个JavaScript控制台。请阅读官方指南。目前只有这个— <em class="kl"> Alt-Fn-F2，</em>并在运行命令框上键入<strong class="jp ir"> <em class="kl"> lg </em> </strong>。</p><h1 id="0187" class="kn ko iq bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">启动动画概述</h1><p id="4692" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">我之前提到过，我个人希望看到我的桌面和漂亮的壁纸，而不是登录时看到的<em class="kl">概览</em>。一个简单的猴子补丁可以处理这种情况。</p><p id="6c11" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl"> Overview </em>对象在<em class="kl"> overview.js. </em>中定义，它<em class="kl"> </em>具有函数<em class="kl"> runStartupAnimation。我们这样修补它:</em></p><pre class="lq lr ls lt gt lu lv lw lx aw ly bi"><span id="b7ac" class="lz ko iq lv b gy ma mb l mc md">Main.overview.runStartupAnimation = (callback) =&gt; {<br/>  // execute the callback immediately and return<br/>  callback();<br/>}</span></pre><h1 id="1104" class="kn ko iq bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">回顾</h1><p id="9fb4" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">所以我们有两个示例扩展，安抚我个人对Gnome的两个默认行为的厌恶，<a class="ae km" href="https://github.com/icedman/swap-finger-gestures-3-4" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> 4手指工作区切换器</strong> </a>和<a class="ae km" href="https://github.com/icedman/suppress-startup-animation" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">抑制启动概览动画</strong> </a> <strong class="jp ir">。</strong></p><p id="edbf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">总之，要创建自己的Gnome Shell扩展:</p><ol class=""><li id="43b8" class="mq mr iq jp b jq jr ju jv jy ms kc mt kg mu kk mv mw mx my bi translated">遵循指南并根据模板生成</li><li id="f0f0" class="mq mr iq jp b jq mz ju na jy nb kc nc kg nd kk mv mw mx my bi translated">下载Gnome Shell源代码并研究它</li><li id="5eef" class="mq mr iq jp b jq mz ju na jy nb kc nc kg nd kk mv mw mx my bi translated">学习猴子补丁</li><li id="6192" class="mq mr iq jp b jq mz ju na jy nb kc nc kg nd kk mv mw mx my bi translated">学习信号</li></ol><h1 id="3e95" class="kn ko iq bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">接下来是什么— Dash2Dock Lite</h1><p id="8c94" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">我也提到我个人希望我的Dash或Dock应用程序图标总是显示在桌面上。这不仅是一个眼睛糖果，它也是功能提供快速访问我最喜欢的应用程序。</p><p id="bb01" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一个叫做Dash-to-Dock的扩展为我们做了这件事。它将仪表板从<em class="kl">概览</em>中取出，并将其停靠在桌面上。<em class="kl"> Gnome 40的发布，</em>却打破了延续。在那段时间里，有人怀疑开发人员是否愿意更新和继续维护这个扩展。</p><p id="0cb3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了填补空白，我创建了自己的扩展，名为<a class="ae km" href="http://github.com/icedman/dash2dock-lite" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir">dash 2 dock Lite</strong></a><strong class="jp ir">。它的功能远少于成熟但已损坏的Dash to Dock。但是它有一些让它更有趣的功能。—它有像macOS dock一样的动画。</strong></p><figure class="lq lr ls lt gt nf gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi ne"><img src="../Images/6e61ef986ccb19514677b47ce13b5033.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vgvdF6ASvQutBMobFjFtww.png"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">动画码头！</figcaption></figure><p id="f372" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae km" href="http://github.com/icedman/dash2dock-lite" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir">dash 2 dock Lite</strong></a><strong class="jp ir"/>扩展最初是个人使用。自从我发表以来，我收到了许多功能请求。我注意到他们中的一些人认为这个扩展可能已经超过了“Lite”这个词。</p><p id="cf9f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它有一个动画模拟时钟，动态日历，垃圾桶，智能隐藏等——大部分前macOS用户希望从Dock得到的功能。你应该尝试一下。尽管这个扩展仍然需要大量的测试——并且我会感谢bug报告。</p><p id="d8ae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我的下一篇文章将记录我从制作D2DL扩展中学到的东西:动画、性能、调试、样式表、自定义绘图、现代偏好窗口。</p></div></div>    
</body>
</html>