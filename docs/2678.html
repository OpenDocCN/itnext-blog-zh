<html>
<head>
<title>Adding security layers to your App on OpenShift — Part 3: Secret Management with Vault</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在OpenShift上向您的应用添加安全层—第3部分:使用Vault进行秘密管理</h1>
<blockquote>原文：<a href="https://itnext.io/adding-security-layers-to-your-app-on-openshift-part-3-secret-management-with-vault-8efd4ec29ec4?source=collection_archive---------5-----------------------#2019-07-09">https://itnext.io/adding-security-layers-to-your-app-on-openshift-part-3-secret-management-with-vault-8efd4ec29ec4?source=collection_archive---------5-----------------------#2019-07-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="2363" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">今天，保护你的应用程序是必须的，但是如果你没有在一开始就考虑它，那么在不修改代码的情况下引入它是很困难的。幸运的是，像<a class="ae kl" href="http://kubernetes.io" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>这样的容器和平台带来的新的云原生模式提供了简单的方法来解决安全问题，而无需接触代码。</p><p id="4dd6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">谈到安全，人们大多会想到两个话题:信息和通信管理。他们自然不会想到机密管理部分——通常会最大程度地减少敏感数据向组织中不同应用程序和人员的蔓延或泄露。他们倾向于认为秘密管理不是一个问题；然而，他们远不知道如何有效地创建、存储、更新和撤销它们。</p><p id="4b0e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来的两个部分是关于增强我们传统的在应用程序中管理秘密的方式。我们将了解如何配置我们的应用程序部署，以使用外部秘密管理解决方案，如<a class="ae kl" href="http://vaultproject.io" rel="noopener ugc nofollow" target="_blank"> Hashicorp Vault </a>。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/df35c157e270a1c0f816ec85451cbb40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G8vhpRTtWMGE_r7ik3fEuQ.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">第3部分—添加用于秘密管理的保险库</figcaption></figure><p id="7855" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="lc">这篇文章是一个更大的系列文章的一部分，讲述如何给现有的应用程序增加安全层。目前公布的其他部分有:</em></p><ul class=""><li id="f3c8" class="ld le iq jp b jq jr ju jv jy lf kc lg kg lh kk li lj lk ll bi translated"><a class="ae kl" href="https://medium.com/@lbroudoux/adding-security-layers-to-your-app-on-openshift-part-1-deployment-and-tls-ingress-9ef752835599" rel="noopener"> <em class="lc">第1部分—部署和TLS入口</em> </a></li><li id="0a37" class="ld le iq jp b jq lm ju ln jy lo kc lp kg lq kk li lj lk ll bi translated"><a class="ae kl" href="https://medium.com/@lbroudoux/adding-security-layers-to-your-app-on-openshift-part-2-8320018bcdd1" rel="noopener"> <em class="lc">第二部分——使用Keycloak </em> </a>进行认证和授权</li><li id="5b40" class="ld le iq jp b jq lm ju ln jy lo kc lp kg lq kk li lj lk ll bi translated"><em class="lc">第三部分——金库的秘密管理(本帖)</em></li><li id="bc3f" class="ld le iq jp b jq lm ju ln jy lo kc lp kg lq kk li lj lk ll bi translated"><a class="ae kl" href="https://medium.com/@lbroudoux/adding-security-layers-to-your-app-on-openshift-part-4-dynamic-secrets-with-vault-b5fe1fc7709b" rel="noopener"> <em class="lc">第4部分——带保险库的动态秘密</em> </a></li><li id="8a71" class="ld le iq jp b jq lm ju ln jy lo kc lp kg lq kk li lj lk ll bi translated"><a class="ae kl" href="https://medium.com/@lbroudoux/adding-security-layers-to-your-app-on-openshift-part-5-mutual-tls-with-istio-a8800c2e4df4" rel="noopener"> <em class="lc">第5部分—与Istio的相互TLS</em></a></li><li id="bf73" class="ld le iq jp b jq lm ju ln jy lo kc lp kg lq kk li lj lk ll bi translated"><a class="ae kl" href="https://medium.com/@lbroudoux/adding-security-layers-to-your-app-on-openshift-part-6-pki-as-a-service-with-vault-and-cert-e6dbbe7028c7" rel="noopener"> <em class="lc">第6部分— PKI即服务，带保险库和证书管理器</em> </a></li></ul><h1 id="cca1" class="lr ls iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">我们想在这部分实现什么？</h1><p id="9b9a" class="pw-post-body-paragraph jn jo iq jp b jq mp js jt ju mq jw jx jy mr ka kb kc ms ke kf kg mt ki kj kk ij bi translated">Hashicorp Vault是用于保护敏感数据和管理机密的开源解决方案。在组织中使用Vault可以有多种用途。它可以用于:将应用程序机密存储到密钥/值存储、API密钥或基础设施令牌以及AWS IAM凭证、数据库凭证等凭证中……它还可以用作<a class="ae kl" href="https://en.wikipedia.org/wiki/Public_key_infrastructure" rel="noopener ugc nofollow" target="_blank"> PKI </a>即服务。</p><p id="4e80" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这一部分中，我们将看到如何使用Vault来存储秘密，比如我们之前在连接MongoDB的<code class="fe mu mv mw mx b">fruits-catalog</code>应用程序中使用的凭证。虽然Kubernetes提供了秘密管理功能，但社区倾向于认为Vault是一个增强的解决方案，因为它提供了:</p><ul class=""><li id="6656" class="ld le iq jp b jq jr ju jv jy lf kc lg kg lh kk li lj lk ll bi translated">在Kubernetes集群和传统应用程序之间管理秘密的中心位置，</li><li id="f387" class="ld le iq jp b jq lm ju ln jy lo kc lp kg lq kk li lj lk ll bi translated">更好的加密选项和认证选项来访问秘密。</li></ul><p id="3f50" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Vault提供了许多集成方法——从API到CLI，使用另一种哈希公司的技术<a class="ae kl" href="https://github.com/hashicorp/consul-template" rel="noopener ugc nofollow" target="_blank">Consul Template</a>——以及许多身份验证方法。</p><p id="981f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本文中，我们将使用它的API将Vault集成到我们的架构中。然而，我们将通过使用Kubernetes身份验证方法来验证我们的API调用，从而以适当的方式做到这一点。因此，我们将在我们的容器平台上部署Vault，并使它们集成应用程序启动流程，如下所述:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi my"><img src="../Images/9859363cf912dfe3112d14f4effaaa47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5cZdD6FPs8qIL8KAmoJRrQ.png"/></div></div></figure><p id="7e08" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这一部分的目标是转变我们的架构，以便我们获得相关要点:</p><ol class=""><li id="55ec" class="ld le iq jp b jq jr ju jv jy lf kc lg kg lh kk mz lj lk ll bi translated">我们将获得一个由Kubernetes颁发的特定令牌——以及相关的证书——在启动时注入到我们的应用程序Pod中，</li><li id="70d6" class="ld le iq jp b jq lm ju ln jy lo kc lp kg lq kk mz lj lk ll bi translated">从一个名为<code class="fe mu mv mw mx b">vault-init</code>的<a class="ae kl" href="https://kubernetes.io/docs/concepts/workloads/pods/init-containers/" rel="noopener ugc nofollow" target="_blank"> Init容器</a>中，也运行在我们的Pod中，我们将使用这个特定的令牌对Vault进行身份验证调用，</li><li id="53ba" class="ld le iq jp b jq lm ju ln jy lo kc lp kg lq kk mz lj lk ll bi translated">Vault将能够根据Kubernetes APIs检查这个调用的有效性。如果成功，Vault将允许应用程序访问存储在Vault中的机密，</li><li id="3015" class="ld le iq jp b jq lm ju ln jy lo kc lp kg lq kk mz lj lk ll bi translated">最后，从Vault中检索到的秘密将通过一个共享文件系统提供给我们的主Spring Boot容器:一个配置文件将在<code class="fe mu mv mw mx b">/deployment/config</code>上创建，这样在这个文件中找到的值将覆盖来自部署配置的值。</li></ol><p id="a64d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">轻松点。？好吧，让我们看看如何实现这一点…</p><h1 id="13b5" class="lr ls iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">如何应用？</h1><p id="7905" class="pw-post-body-paragraph jn jo iq jp b jq mp js jt ju mq jw jx jy mr ka kb kc ms ke kf kg mt ki kj kk ij bi translated">如果您已经阅读了本系列的第一部分，那么您可能已经克隆了包含所有资源和资产的<a class="ae kl" href="https://github.com/lbroudoux/secured-fruits-catalog-k8s" rel="noopener ugc nofollow" target="_blank"> my GitHub repository </a>。如果没有，我敦促你这样做；-)从笔记本电脑上的克隆中，切换到<code class="fe mu mv mw mx b">master</code>分支。</p><p id="65cb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">转换的第一步是在我们的Kubernetes/ OpenShift项目中部署一个Vault实例。我们将使用存储库的<code class="fe mu mv mw mx b">/k8s</code>文件夹中的资源来完成这项工作。</p><pre class="kn ko kp kq gt na mx nb nc aw nd bi"><span id="5c36" class="ne ls iq mx b gy nf ng l nh ni"># First allow anyuid for vault container<br/>$ oc adm policy add-scc-to-user anyuid -z vault-sa -n fruits-catalog</span><span id="6599" class="ne ls iq mx b gy nj ng l nh ni">$ oc apply -f k8s/vault-deployment.yml -n fruits-catalog<br/>serviceaccount "vault-sa" created<br/>configmap "vault-config" created<br/>persistentvolumeclaim "vault-file-backend" created<br/>deployment "vault" created<br/>service "vault" created</span><span id="ee8d" class="ne ls iq mx b gy nj ng l nh ni">$ oc create route passthrough vault --port=8200 --service=vault -n fruits-catalog<br/>route "vault" created</span></pre><p id="2415" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">几分钟后，一个新的<code class="fe mu mv mw mx b">vault</code>分离舱将会启动并运行。出于演示目的，我们使用一个简单的Vault文件后端。一个更加复杂的生产就绪的设置将引入<a class="ae kl" href="https://www.consul.io/" rel="noopener ugc nofollow" target="_blank">consult</a>作为后端。</p><p id="72b6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们有了一个到保险库的路由，我们必须用它来初始化保险库。初始化为我们提供了一个解封密钥和一个root登录，我们可以用它来使我们的应用程序可以使用这个保险库。为此，您需要从<a class="ae kl" href="https://www.vaultproject.io/downloads.html" rel="noopener ugc nofollow" target="_blank">这里</a>下载的<code class="fe mu mv mw mx b">vault</code> CLI工具。</p><pre class="kn ko kp kq gt na mx nb nc aw nd bi"><span id="3f64" class="ne ls iq mx b gy nf ng l nh ni">$ export VAULT_ADDR=https://`oc get route -n fruits-catalog | grep -m1 vault | awk '{print $2}'`</span><span id="4cc5" class="ne ls iq mx b gy nj ng l nh ni">$ vault operator init -tls-skip-verify -key-shares=1 -key-threshold=1</span><span id="7430" class="ne ls iq mx b gy nj ng l nh ni">Unseal Key 1: R4gbzVocDqIVgKbnW4dbVUWy64uOoOjYCmTeGlpTAoM=</span><span id="3a97" class="ne ls iq mx b gy nj ng l nh ni">Initial Root Token: s.7JTtKLlFzOwfJ7xdbX6qhNpx</span><span id="a559" class="ne ls iq mx b gy nj ng l nh ni">Vault initialized with 1 key shares and a key threshold of 1. Please securely distribute the key shares printed above. When the Vault is re-sealed, restarted, or stopped, you must supply at least 1 of these keys to unseal it before it can start servicing requests.</span><span id="23a1" class="ne ls iq mx b gy nj ng l nh ni">Vault does not store the generated master key. Without at least 1 key to reconstruct the master key, Vault will remain permanently sealed!</span><span id="e5d4" class="ne ls iq mx b gy nj ng l nh ni">It is possible to generate new unseal keys, provided you have a quorum of existing unseal keys shares. See "vault operator rekey" for more information.</span><span id="2a61" class="ne ls iq mx b gy nj ng l nh ni">$ vault operator unseal -tls-skip-verify R4gbzVocDqIVgKbnW4dbVUWy64uOoOjYCmTeGlpTAoM= </span><span id="8166" class="ne ls iq mx b gy nj ng l nh ni">Key             Value<br/>---             -----<br/>Seal Type       shamir<br/>Initialized     true<br/>Sealed          false<br/>Total Shares    1<br/>Threshold       1<br/>Version         1.0.2<br/>Cluster Name    vault-cluster-5f2dcac0<br/>Cluster ID      2faea050-2fb7-fbfc-a9be-980e185d7344<br/>HA Enabled      false</span><span id="6581" class="ne ls iq mx b gy nj ng l nh ni">$ vault login -tls-skip-verify s.7JTtKLlFzOwfJ7xdbX6qhNpx</span><span id="12d4" class="ne ls iq mx b gy nj ng l nh ni">Success! You are now authenticated. The token information displayed below is already stored in the token helper. You do NOT need to run "vault login" again. Future Vault requests will automatically use this token.</span><span id="bf95" class="ne ls iq mx b gy nj ng l nh ni">Key                  Value<br/>---                  -----<br/>token                s.7JTtKLlFzOwfJ7xdbX6qhNpx<br/>token_accessor       rEstTDjmcS4404EC0onzeLwT<br/>token_duration       ∞<br/>token_renewable      false<br/>token_policies       ["root"]<br/>identity_policies    []<br/>policies             ["root"]</span></pre><p id="82ae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">保险库现在准备接收新的秘密。默认的<code class="fe mu mv mw mx b">secret</code>后端仅在开发模式下可用，我们需要启用它。然后，您可以开始将MongoDB秘密放入新的密钥中。可以使用路径或树形组织来指定保险库密码，这里我们创建的是<code class="fe mu mv mw mx b">secret/fruit-catalog-mongodb</code>密码:</p><pre class="kn ko kp kq gt na mx nb nc aw nd bi"><span id="3a27" class="ne ls iq mx b gy nf ng l nh ni">$ vault secrets enable -tls-skip-verify -version=1 -path=secret/ kv<br/>Success! Enabled the kv secrets engine at: secret/</span><span id="2933" class="ne ls iq mx b gy nj ng l nh ni">$ vault kv put -tls-skip-verify secret/fruit-catalog-mongodb user=$(oc get secret/mongodb -o jsonpath="{.data.database-user}" | base64 -D)</span><span id="0b92" class="ne ls iq mx b gy nj ng l nh ni">$ vault kv put -tls-skip-verify secret/fruit-catalog-mongodb password=$(oc get secret/mongodb -o jsonpath="{.data.database-password}" | base64 -D)</span></pre><p id="d12b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可以通过再读一遍这个秘密来检查所有的东西是否到位。</p><pre class="kn ko kp kq gt na mx nb nc aw nd bi"><span id="1419" class="ne ls iq mx b gy nf ng l nh ni">$ vault kv get -tls-skip-verify secret/fruit-catalog-mongodb<br/>====== Data ======<br/>Key         Value<br/>---         -----<br/>password    wwsPHR4gDorXgQ2a<br/>user        userEVY</span></pre><p id="958d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在在OpenShift端，我们将创建一个新的<code class="fe mu mv mw mx b">ServiceAccount</code>，它将负责执行<code class="fe mu mv mw mx b">fruits-catalog</code> pod。对于这个服务帐户，我们必须添加使用Kubernetes进行身份验证的能力。这意味着我们应该应用<code class="fe mu mv mw mx b">system:auth-delegator</code>集群角色。</p><pre class="kn ko kp kq gt na mx nb nc aw nd bi"><span id="fcc6" class="ne ls iq mx b gy nf ng l nh ni">$ oc create sa fruits-catalog-vault -n fruits-catalog<br/>$ oc adm policy add-cluster-role-to-user system:auth-delegator -z fruits-catalog-vault -n fruits-catalog</span></pre><p id="8135" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们把所有重要的部分都准备好了！现在，我们必须检索服务帐户的不同部分，以便在vault上配置Kubernetes身份验证方法:</p><pre class="kn ko kp kq gt na mx nb nc aw nd bi"><span id="8e84" class="ne ls iq mx b gy nf ng l nh ni">$ export SA_TOKEN=$(oc get sa/fruits-catalog-vault -o yaml | grep fruits-catalog-vault-token | awk '{print $3}')</span><span id="c58b" class="ne ls iq mx b gy nj ng l nh ni">$ export SA_JWT_TOKEN=$(oc get secret $SA_TOKEN -o jsonpath="{.data.token}" | base64 --decode; echo)<br/>$ export SA_CA_CRT=$(oc get secret $SA_TOKEN -o jsonpath="{.data['ca\.crt']}" | base64 --decode; echo)</span><span id="6511" class="ne ls iq mx b gy nj ng l nh ni">$ vault auth enable -tls-skip-verify kubernetes<br/>Success! Enabled kubernetes auth method at: kubernetes/</span><span id="cfe7" class="ne ls iq mx b gy nj ng l nh ni">$ vault write -tls-skip-verify auth/kubernetes/config \<br/>  token_reviewer_jwt="$SA_JWT_TOKEN" \<br/>  kubernetes_host="$(oc whoami --show-server)" \<br/>  kubernetes_ca_cert="$SA_CA_CRT"<br/>Success! Data written to: auth/kubernetes/config</span></pre><p id="4a67" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还需要在Vault中创建一个策略，允许读取包含我们的MongoDB凭证的秘密。现在，我们以管理员身份登录，但我们的服务帐户并非如此。然后，这个策略需要关联到服务帐户和Kubernetes名称空间。这就是以下两个命令的意义所在:</p><pre class="kn ko kp kq gt na mx nb nc aw nd bi"><span id="0994" class="ne ls iq mx b gy nf ng l nh ni">$ vault policy write -tls-skip-verify fruit-catalog-policy-static ./k8s/fruit-catalog-policy-static.hcl<br/>Success! Uploaded policy: fruit-catalog-policy-static</span><span id="56e3" class="ne ls iq mx b gy nj ng l nh ni">$ vault write -tls-skip-verify auth/kubernetes/role/fruits-catalog \<br/>  bound_service_account_names=fruits-catalog-vault \<br/>  bound_service_account_namespaces=fruits-catalog \<br/>  policies=fruit-catalog-policy-static \<br/>  ttl=24h<br/>Success! Data written to: auth/kubernetes/role/fruits-catalog</span></pre><p id="f2fc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，只需用包含<code class="fe mu mv mw mx b">vault-init</code> Init容器的新容器替换OpenShift中现有的<code class="fe mu mv mw mx b">Deployment</code>。我们一会儿会谈到这个容器的确切作用。只是不要忘记在那之前用你的值替换我的值，使用一些垃圾的<code class="fe mu mv mw mx b">sed</code>命令；-)</p><pre class="kn ko kp kq gt na mx nb nc aw nd bi"><span id="8ceb" class="ne ls iq mx b gy nf ng l nh ni">$ export VAULT_ROUTE=$(oc get route/vault -n fruits-catalog | grep vault | awk '{print $2}')<br/>$ export KEYCLOAK_ROUTE=$(oc get route/keycloak -n fruits-catalog | grep keycloak | awk '{print $2}')</span><span id="3699" class="ne ls iq mx b gy nj ng l nh ni">$ sed -i '' 's=vault-fruits-catalog.apps.144.76.24.92.nip.io='"$VAULT_ROUTE"'=' k8s/fruits-catalog-static-secret-deployment.yml<br/>$ sed -i '' 's=keycloak-fruits-catalog.apps.144.76.24.92.nip.io='"$KEYCLOAK_ROUTE"'=' k8s/fruits-catalog-static-secret-deployment.yml</span><span id="f4e8" class="ne ls iq mx b gy nj ng l nh ni">$ oc replace -f k8s/fruits-catalog-static-secret-deployment.yml</span></pre><blockquote class="nk nl nm"><p id="d238" class="jn jo lc jp b jq jr js jt ju jv jw jx nn jz ka kb no kd ke kf np kh ki kj kk ij bi translated">我们在这里配置部署的方式很难理解——一切都是“手动”进行的。虽然检查以了解细节很有趣，但现在有一种更简单的方法可以做到这一点。我使用新的Vault Agent Injector发布了对那个的<a class="ae kl" href="https://medium.com/@lbroudoux/adding-security-layers-to-your-app-on-openshift-update-welcome-vault-agent-injector-46cab161c366" rel="noopener">更新。</a></p></blockquote><h1 id="f395" class="lr ls iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">检查它是否按预期工作</h1><p id="722c" class="pw-post-body-paragraph jn jo iq jp b jq mp js jt ju mq jw jx jy mr ka kb kc ms ke kf kg mt ki kj kk ij bi translated">当然，您可以使用<code class="fe mu mv mw mx b">fruits-catalog</code>路线的URL打开一个浏览器窗口，并检查应用程序是否按预期运行——即。您可以查看您之前创建的成果。但是，对配置的某些部分进行检查和/或故障排除会很有用。</p><p id="abe5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们可以验证是否能够回读我们之前存储在保险库中的秘密值:</p><pre class="kn ko kp kq gt na mx nb nc aw nd bi"><span id="de78" class="ne ls iq mx b gy nf ng l nh ni">$ vault read secret/fruit-catalog-mongodb<br/>Key                 Value<br/>---                 -----<br/>refresh_interval    168h<br/>password            wwsPHR4gDorXgQ2a<br/>user                userEVY</span></pre><p id="9fb3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦使用设置期间提供的初始根令牌登录，我们还应该能够通过Vault UI检查一切是否就绪。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi nq"><img src="../Images/941074bbd5444b082774deed6d9b5e5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L17s9_R1HtLOP1U2OKcPvw.png"/></div></div></figure><p id="6726" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">还记得在架构演示中，我们谈到了<code class="fe mu mv mw mx b">vault-init</code> Init容器吗？你可能想看看我们之前申请的<code class="fe mu mv mw mx b"><a class="ae kl" href="https://github.com/lbroudoux/secured-fruits-catalog-k8s/blob/master/k8s/fruits-catalog-static-secret-deployment.yml" rel="noopener ugc nofollow" target="_blank">Deployment</a></code>。你会看到这个容器使用了一个极简的<a class="ae kl" href="https://www.redhat.com/en/blog/introducing-red-hat-universal-base-image" rel="noopener ugc nofollow" target="_blank">Red Hat Universal Base Image</a>，它刚刚用<a class="ae kl" href="https://stedolan.github.io/jq/" rel="noopener ugc nofollow" target="_blank"> jq </a>工具进行了增强。你可以在我的一个GitHubrepo上找到这个图像定义。</p><p id="ead9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，查看并尝试在主容器上重放这个Init容器正在做什么可能是有用的。因此，您可以使用SSH通过以下命令登录到容器:</p><pre class="kn ko kp kq gt na mx nb nc aw nd bi"><span id="fcb3" class="ne ls iq mx b gy nf ng l nh ni">$ oc rsh -c spring-boot $(oc get pods | grep fruits-catalog | grep Running | awk '{print $1}')</span></pre><p id="e00f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后尝试<code class="fe mu mv mw mx b">vault-init</code>容器发出的不同命令，使用服务帐户令牌连接到Vault，检索Vault令牌，查询<code class="fe mu mv mw mx b">secret/fruit-catalog-mongodb</code>机密，然后使其可用于应用程序:</p><pre class="kn ko kp kq gt na mx nb nc aw nd bi"><span id="43a3" class="ne ls iq mx b gy nf ng l nh ni">OCP_TOKEN=$(cat /var/run/secrets/kubernetes.io/serviceaccount/token);</span><span id="6e0f" class="ne ls iq mx b gy nj ng l nh ni">curl -k --request POST --data '{"jwt": "'"$OCP_TOKEN"'", "role": "fruits-catalog"}' https://vault-fruits-catalog.apps.x.x.x.x.nip.io/v1/auth/kubernetes/login | jq -j '.auth.client_token' &gt; /etc/vault/token;</span><span id="916d" class="ne ls iq mx b gy nj ng l nh ni">X_VAULT_TOKEN=$(cat /etc/vault/token);</span><span id="d5cd" class="ne ls iq mx b gy nj ng l nh ni">curl -k --header "X-Vault-Token: $X_VAULT_TOKEN" https://vault-fruits-catalog.apps.x.x.x.x.nip.io/v1/secret/fruit-catalog-mongodb &gt; /etc/app/creds.json;</span><span id="c25d" class="ne ls iq mx b gy nj ng l nh ni">echo "spring.data.mongodb.uri=mongodb://$(jq -j '.data.user' /etc/app/creds.json):$(jq -j '.data.password' /etc/app/creds.json)@mongodb/sampledb" &gt; /etc/app/application.properties;</span><span id="e83f" class="ne ls iq mx b gy nj ng l nh ni">cp /etc/app/application.properties /deployments/config/application.properties</span></pre><h1 id="d400" class="lr ls iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">结论和下一步</h1><p id="dbae" class="pw-post-body-paragraph jn jo iq jp b jq mp js jt ju mq jw jx jy mr ka kb kc ms ke kf kg mt ki kj kk ij bi translated">在第三部分中，我们看到了如何使用云原生模式(如Init容器、Kubernetes服务帐户认证和容器间的卷共享)来集成外部系统(如Hashicorp Vault)。此外，这种集成是在不修改应用程序源代码的情况下完成的。</p><p id="4fd7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在考虑保护您的应用程序时，秘密管理应该是一个真正的问题。凭证泄漏和传播肯定会导致安全问题和数据泄漏，但它肯定会带来关于治理策略实施的不确定性，以及当人们想要更新或撤销访问规则时的恐惧。</p><p id="3435" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们已经看到，Vault是一个强大的工具，可以集中管理敏感数据。它还可以很容易地部署到Kubernetes / OpenShift上，并为验证部署在平台上的应用程序提供本地集成。我们已经看到，Vault可以用于数据库凭据，但同样的机制也可以应用于任何敏感数据。</p><p id="5d3f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本系列的下一部分中，我们将了解Vault与一些数据库技术(如MongoDB)的高级集成，并了解如何使用它来动态生成我们的凭证。</p></div></div>    
</body>
</html>