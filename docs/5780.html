<html>
<head>
<title>C++ scripting alternatives: easy-to-bind-in-C++ scripting</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C++脚本替代方案:易于绑定的C++脚本</h1>
<blockquote>原文：<a href="https://itnext.io/c-scripting-alternatives-easy-to-bind-scripting-binding-chaiscript-and-wren-into-a-small-game-174c86b0ecd7?source=collection_archive---------0-----------------------#2021-05-24">https://itnext.io/c-scripting-alternatives-easy-to-bind-scripting-binding-chaiscript-and-wren-into-a-small-game-174c86b0ecd7?source=collection_archive---------0-----------------------#2021-05-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><h1 id="2891" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">将ChaiScript和Wren绑定到一个小游戏中</h1><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/a3247350dd7161e1cb3b8343694bcac9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OZh9rLHi2oD-d-hJkfipRA.jpeg"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated"><a class="ae lb" href="https://unsplash.com/@casparrubin" rel="noopener ugc nofollow" target="_blank">卡斯帕鲁宾</a>在<a class="ae lb" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="49c6" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">大家好，</p><p id="414d" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">由于我一直在尝试一些脚本语言来编写一个小游戏，并积累了一些经验，我想在这里分享我的经验，希望有人可以找到有用的。</p><p id="b019" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">本文关注的是相对容易与C++绑定的脚本API，无论是本地绑定还是与助手库绑定。</p><p id="0f78" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">为了编写一个小型纸牌游戏的脚本，我尝试并测试了将c++ API暴露给外语。</p><h2 id="45d4" class="ma jo iq bd jp mb mc dn jt md me dp jx ln mf mg kb lr mh mi kf lv mj mk kj ml bi translated">为什么要编写脚本？</h2><p id="0a24" class="pw-post-body-paragraph lc ld iq le b lf mm lh li lj mn ll lm ln mo lp lq lr mp lt lu lv mq lx ly lz ij bi translated">对于不熟悉脚本的人:脚本通常用于加速你自己程序的开发。</p><p id="7207" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">这可能非常有效，因为除了消除(显式)编译步骤之外，您还可以用一种更简单易用的语言对其中的逻辑进行编码。</p><p id="405a" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">记住这一点，通过消除编译步骤，脚本可以大大加快编辑-编译-调试的迭代。想想你对代码所做的任何改变+重新编译，但是去掉了编译步骤。事情变得几乎是瞬间的。</p><h1 id="7829" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">游戏</h1><p id="bf70" class="pw-post-body-paragraph lc ld iq le b lf mm lh li lj mn ll lm ln mo lp lq lr mp lt lu lv mq lx ly lz ij bi translated">该游戏是一个联网的4人游戏，其中每个玩家轮流玩他们手中的一张牌，并且牌一直玩到该副牌被完全用完。</p><p id="3981" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">这是一种叫做<a class="ae lb" href="https://es.wikipedia.org/wiki/Gui%C3%B1ote" rel="noopener ugc nofollow" target="_blank">guinote</a>的游戏，在西班牙的一些地区很流行。它有许多变体，如Brisca、Tute等，尽管这对于我将在文章中解释的内容并不十分重要。</p><p id="796b" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">这篇文章的目的是分享我绑定C++ API并将其公开到脚本语言中的经验。</p><p id="07f4" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">免责声明:请记住，我不是绑定API方面的专家，因此我可能会忽略一些知识。</p><h1 id="2d4b" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">关于引擎架构的相关要点(用于绑定目的)</h1><p id="29c7" class="pw-post-body-paragraph lc ld iq le b lf mm lh li lj mn ll lm ln mo lp lq lr mp lt lu lv mq lx ly lz ij bi translated">游戏由一个加载屏幕的控制器组成。<strong class="le ir">每个屏幕由一个控制屏幕逻辑的脚本</strong>代表。</p><p id="fb70" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">该脚本使用游戏视图和游戏模型，除了一些网络API(通过<a class="ae lb" href="https://capnproto.org/" rel="noopener ugc nofollow" target="_blank"> Capnproto </a>编写)，如果我有实力写一篇关于它的文章，请继续关注！)</p><p id="6d60" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">游戏的C++端通过一个控制器进入一个屏幕，在那个时候，它加载屏幕并把控制权交给脚本引擎。</p><p id="f761" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">虚拟机是在加载屏幕之前创建的，从那里开始，脚本负责处理。</p><p id="35b2" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">脚本完成后，会返回几个字符串:</p><ol class=""><li id="9b46" class="mr ms iq le b lf lg lj lk ln mt lr mu lv mv lz mw mx my mz bi translated">要加载的下一个屏幕</li><li id="eb09" class="mr ms iq le b lf na lj nb ln nc lr nd lv ne lz mw mx my mz bi translated">下一个屏幕的参数(相当于C++中main中的argv)</li></ol><p id="bc58" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">控制在返回后返回到C++端。为了使脚本正常工作，一些额外的数据通过环境作为全局数据公开:基本上是运行时配置和记录器，它们对脚本引擎是可用的。</p><p id="778a" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">当一个屏幕结束时，虚拟机被销毁。这样，在屏幕运行之间没有状态保持活动。这也使我的调试更容易，等等。</p><p id="e548" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">基本上，我想加速我的屏幕代码逻辑编写。</p><p id="742e" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">从脚本的角度来看，这意味着:</p><ol class=""><li id="80a9" class="mr ms iq le b lf lg lj lk ln mt lr mu lv mv lz mw mx my mz bi translated">能够在运行时从文件中加载脚本(开发时)</li><li id="dd85" class="mr ms iq le b lf na lj nb ln nc lr nd lv ne lz mw mx my mz bi translated">能够从内存中加载脚本(在最终的二进制文件中嵌入代码时)</li><li id="744f" class="mr ms iq le b lf na lj nb ln nc lr nd lv ne lz mw mx my mz bi translated">能够向脚本主函数传递参数。</li><li id="d0b3" class="mr ms iq le b lf na lj nb ln nc lr nd lv ne lz mw mx my mz bi translated">除了使用之外，C++类型必须在脚本端被构造/销毁</li><li id="7cc2" class="mr ms iq le b lf na lj nb ln nc lr nd lv ne lz mw mx my mz bi translated">C++端已经存在的全局数据必须暴露给脚本环境。</li></ol><p id="e6d7" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">可以把这些脚本中的一个想象成一个程序，它本身可以获得输入参数，并且有一些环境(例如，log、config)。它就像C++、Java、C#等中的main。它执行一些操作，然后将信息返回给控制器，以便控制器知道下一步要加载哪个屏幕。</p></div><div class="ab cl nf ng hu nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ij ik il im in"><h1 id="f4c8" class="jn jo iq bd jp jq nm js jt ju nn jw jx jy no ka kb kc np ke kf kg nq ki kj kk bi translated">候选人脚本</h1><p id="f8d7" class="pw-post-body-paragraph lc ld iq le b lf mm lh li lj mn ll lm ln mo lp lq lr mp lt lu lv mq lx ly lz ij bi translated">我想选择一种尽可能满足以下要求的脚本语言:</p><ol class=""><li id="99e2" class="mr ms iq le b lf lg lj lk ln mt lr mu lv mv lz mw mx my mz bi translated"><strong class="le ir">易绑定C++ </strong>。我不想一直反对集成，也不想浪费大量时间来纠正它。这大概是最重要的一点。</li><li id="9303" class="mr ms iq le b lf na lj nb ln nc lr nd lv ne lz mw mx my mz bi translated"><strong class="le ir">对轻量级并发的支持</strong>是一个非常大的优势，几乎和绑定的便利性一样重要。</li><li id="21cf" class="mr ms iq le b lf na lj nb ln nc lr nd lv ne lz mw mx my mz bi translated">它<strong class="le ir">不可能是Python </strong>，因为根据我的信息，它可能<strong class="le ir">很难移植到Web Assembly </strong>上，所以我直接丢弃了它。</li><li id="4c44" class="mr ms iq le b lf na lj nb ln nc lr nd lv ne lz mw mx my mz bi translated">熟悉:与标准实践相比，它不应该看起来太怪异:像javascript-ey、C-like或pythonic这样的东西是可以的。除了语法，语义也不应该奇怪。</li><li id="fd37" class="mr ms iq le b lf na lj nb ln nc lr nd lv ne lz mw mx my mz bi translated">比起静态类型，我更喜欢动态类型，因为静态类型会降低编码速度:当类型和重构变得更加严格时，它会让你考虑类型。</li><li id="d004" class="mr ms iq le b lf na lj nb ln nc lr nd lv ne lz mw mx my mz bi translated">从一个公开的C++函数中绑定语言回调是一个很好的优势。如果它能开箱即用，那太好了。否则，这应该很容易实现。</li><li id="189a" class="mr ms iq le b lf na lj nb ln nc lr nd lv ne lz mw mx my mz bi translated">性能不重要。我不需要它。</li></ol><h2 id="0b70" class="ma jo iq bd jp mb mc dn jt md me dp jx ln mf mg kb lr mh mi kf lv mj mk kj ml bi translated">考虑的语言</h2><ul class=""><li id="87fe" class="mr ms iq le b lf mm lj mn ln nr lr ns lv nt lz nu mx my mz bi translated"><a class="ae lb" href="https://www.lua.org/" rel="noopener ugc nofollow" target="_blank">卢阿</a> + <a class="ae lb" href="https://github.com/ThePhD/sol2" rel="noopener ugc nofollow" target="_blank">索尔2 </a>。因为3它被丢弃了。它有不熟悉的语法，但更糟糕的是，不熟悉的语义:没有类，使用表，从1开始索引和其他奇怪的东西，就像能够用错误数量的参数调用函数并在途中返回nil。此外，对哈希表和数组都使用表。它很强大，不要误解我，Lua支持很好的并发性。因为上面提到的事情，这不是我想要的。</li><li id="c76c" class="mr ms iq le b lf na lj nb ln nc lr nd lv ne lz nu mx my mz bi translated"><a class="ae lb" href="http://www.squirrel-lang.org/" rel="noopener ugc nofollow" target="_blank">松鼠</a>。语言看起来真的很好。但因为1而被丢弃。支持更好绑定的项目看起来并不完整。它支持良好的并发性，看起来很像C++/Lua的混合体。但是更接近C++(基于类)</li><li id="04b9" class="mr ms iq le b lf na lj nb ln nc lr nd lv ne lz nu mx my mz bi translated"><a class="ae lb" href="https://www.angelcode.com/angelscript/" rel="noopener ugc nofollow" target="_blank">天使脚本</a>。这个是静态类型的，但是我真的想不出如何在不打扰的情况下绑定它。</li><li id="f912" class="mr ms iq le b lf na lj nb ln nc lr nd lv ne lz nu mx my mz bi translated"><a class="ae lb" href="https://chaiscript.com/" rel="noopener ugc nofollow" target="_blank">楷书</a>。从所有的列表中，这是唯一一个被设计成与C++绑定的。这降低了创建绑定的障碍。在这方面，它提供了，尽管有非常好的C++绑定到最初的纯C脚本语言，接近ChaiScript。我会说，它是一种javascript风格的脚本语言，但是有自己的东西。不好的一面是…继续读。</li><li id="d8ab" class="mr ms iq le b lf na lj nb ln nc lr nd lv ne lz nu mx my mz bi translated"><a class="ae lb" href="https://wren.io/" rel="noopener ugc nofollow" target="_blank">鹪鹩</a> + <a class="ae lb" href="https://github.com/matusnovak/wrenbind17" rel="noopener ugc nofollow" target="_blank">鹪鹩17 </a>。在所有的列表中，我认为这个和Squirrel在脚本方面最接近我的理想，因为它们都支持良好的并发性，而且看起来非常自然，用起来也不奇怪。此外，Wren文档不是很大，但相当不错，IMHO。我可以很容易地找到脚本语言支持的API，并理解特性是如何工作的。感谢wrenbind17，它让我尝试绑定C++变得可行。没有它，这是不可能的。</li></ul><p id="ffeb" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">在这个列表中，我最终选择了ChaiScript，因为它很容易绑定。</p></div><div class="ab cl nf ng hu nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ij ik il im in"><h1 id="0d4c" class="jn jo iq bd jp jq nm js jt ju nn jw jx jy no ka kb kc np ke kf kg nq ki kj kk bi translated">功能概述</h1><h2 id="666f" class="ma jo iq bd jp mb mc dn jt md me dp jx ln mf mg kb lr mh mi kf lv mj mk kj ml bi translated">柴书</h2><p id="6ae5" class="pw-post-body-paragraph lc ld iq le b lf mm lh li lj mn ll lm ln mo lp lq lr mp lt lu lv mq lx ly lz ij bi translated">Chaiscript具有(大致)以下特性:</p><ul class=""><li id="8ed7" class="mr ms iq le b lf lg lj lk ln mt lr mu lv mv lz nu mx my mz bi translated">正如广告宣传的那样，开箱即可轻松装订。只要您告诉ChaiScript这种关系，ChaiScript将足够智能，知道您何时实例化某个基类的派生类，甚至知道如何调用仅派生的方法。基本的API就是调用<em class="nv">chai . add(fun | const _ var | base _ cass…)。如果你调用一个和你的类一样的函数，它就变成了一个构造函数。只要不想克隆东西，就不需要注册复制构造函数。也可以使用lambdas或free函数，并注册为类的实例方法，只要签名匹配。</em></li></ul><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nw nx l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">在ChaiScript中公开C++类型</figcaption></figure><ul class=""><li id="67c3" class="mr ms iq le b lf lg lj lk ln mt lr mu lv mv lz nu mx my mz bi translated">自由函数(类型是可选的，将被选中):</li></ul><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nw nx l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">ChaiScript中的自由函数</figcaption></figure><ul class=""><li id="3084" class="mr ms iq le b lf lg lj lk ln mt lr mu lv mv lz nu mx my mz bi translated">带防护装置的功能</li></ul><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nw nx l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">ChaiScript中的函数保护</figcaption></figure><ul class=""><li id="93eb" class="mr ms iq le b lf lg lj lk ln mt lr mu lv mv lz nu mx my mz bi translated">与C++异常处理集成的异常处理:在ChaiScript中捕捉C++异常！甚至你自己的不是从异常中派生的类型也可以被捕获。</li></ul><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nw nx l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">ChaiScript中的异常处理</figcaption></figure><ul class=""><li id="a2bd" class="mr ms iq le b lf lg lj lk ln mt lr mu lv mv lz nu mx my mz bi translated">类支持数据和函数，但不支持静态函数(因为有免费的函数！)</li></ul><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nw nx l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">ChaiScript中的类示例。不允许使用静态函数，因为可以使用自由函数。</figcaption></figure><ul class=""><li id="ddea" class="mr ms iq le b lf lg lj lk ln mt lr mu lv mv lz nu mx my mz bi translated">类是非常动态的，不像Wren。它支持通过<em class="nv">方法_缺失</em> (a-la-Ruby)动态调度不存在的函数。这个类将获得一些Json字符串，并通过<em class="nv"> myjson.varx.vary.varz </em>访问它。虽然效率不是很高，但它确实有效，并且说明了不存在的函数的动态对象访问的重要性:</li></ul><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nw nx l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">纯ChaiScript中的动态Json类实现。您可以通过method_missing委托来访问Json字段</figcaption></figure><ul class=""><li id="2df1" class="mr ms iq le b lf lg lj lk ln mt lr mu lv mv lz nu mx my mz bi translated">可以公开自己的向量类型(std::vector <mytype>实例化)。我想对Wren来说也是如此，但我目前还不需要它。</mytype></li><li id="22ce" class="mr ms iq le b lf na lj nb ln nc lr nd lv ne lz nu mx my mz bi translated">通过std::function &lt;&gt;进行函数回调！！老实说，据我所知，这在C++的脚本绑定中是独一无二的，它只适用于ChaiScript。这意味着你可以拥有这个:</li></ul><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nw nx l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">将C++中带有std::function参数的函数暴露给ChaiScript接受Chaiscript lambdas和函数</figcaption></figure><ul class=""><li id="2d39" class="mr ms iq le b lf lg lj lk ln mt lr mu lv mv lz nu mx my mz bi translated">语言控制流支持基于范围的<em class="nv"> for </em>循环、<em class="nv"> while </em>、<em class="nv"> if </em>以及类似的C++中熟悉的东西</li></ul><h2 id="08fa" class="ma jo iq bd jp mb mc dn jt md me dp jx ln mf mg kb lr mh mi kf lv mj mk kj ml bi translated">鹪鹩</h2><p id="b8d8" class="pw-post-body-paragraph lc ld iq le b lf mm lh li lj mn ll lm ln mo lp lq lr mp lt lu lv mq lx ly lz ij bi translated">Wren 通过栈式协程支持类、静态函数、令人惊讶的控制流和良好的并发性，并有一个清晰的迭代器协议。</p><p id="b3ae" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">它还支持具有易用语法的列表和词典。您可以从C++端和语言中重载操作符，就像在ChaiScript中一样。它支持范围和过滤，转换等。通过序列。我发现它比ChaiScript更精致一些。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nw nx l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">简单的Wren类示例</figcaption></figure><p id="af75" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">下面我想重点介绍一下Wren和ChaiScript之间的区别。</p><ol class=""><li id="b7df" class="mr ms iq le b lf lg lj lk ln mt lr mu lv mv lz mw mx my mz bi translated">Wren更像是基于类的，因为你也可以通过变量使用自由函数，但是你有静态函数。据我所知，自由函数是不可能从C++中暴露出来的。</li><li id="cecc" class="mr ms iq le b lf na lj nb ln nc lr nd lv ne lz mw mx my mz bi translated">当你返回一个基类的时候，继承在Wren中并不是现成的，尽管这里有一个技巧<a class="ae lb" href="https://matusnovak.github.io/wrenbind17/tutorial/custom_types/#68-inheritance" rel="noopener ugc nofollow" target="_blank"/></li><li id="4bff" class="mr ms iq le b lf na lj nb ln nc lr nd lv ne lz mw mx my mz bi translated">在我看来，模块化和如何导入在Wren中更好，尽管我不确定它们是否等价。</li><li id="3f7c" class="mr ms iq le b lf na lj nb ln nc lr nd lv ne lz mw mx my mz bi translated">它支持arity重载，但不支持函数守护a-la ChaiScript。我不确定ChaiScript是否支持重载。</li><li id="9448" class="mr ms iq le b lf na lj nb ln nc lr nd lv ne lz mw mx my mz bi translated">Wren <strong class="le ir">通过光纤支持完整的协程</strong>。</li><li id="64f4" class="mr ms iq le b lf na lj nb ln nc lr nd lv ne lz mw mx my mz bi translated">绑定Wren的最初方式是通过C API。它很快(在运行时)等等，但使用起来很糟糕:让绑定对我来说可行的是<a class="ae lb" href="https://github.com/matusnovak/wrenbind17" rel="noopener ugc nofollow" target="_blank"> wrenbind17 </a></li><li id="52d4" class="mr ms iq le b lf na lj nb ln nc lr nd lv ne lz mw mx my mz bi translated">在Wren中你不能直接从C++中使用<em class="nv"> std::function &lt; &gt; </em>。这迫使在C++中使用一些包装类。</li><li id="1ce0" class="mr ms iq le b lf na lj nb ln nc lr nd lv ne lz mw mx my mz bi translated">公开全局变量(下面脚本中的Env是一个全局变量)并不像它应该的那样简单。为了设置一个全局变量，我使用了一个技巧，即发出代码并从纯Wren代码中获取一个静态函数集的类，它将公开一个C++端变量。</li><li id="de7b" class="mr ms iq le b lf na lj nb ln nc lr nd lv ne lz mw mx my mz bi translated">在Wren中，你只能公开一个构造函数。这通常不是问题。但是，不能公开不可复制类型的构造函数。它会失败。解决方法是创建一个返回<em class="nv">STD::shared _ ptr&lt;your type&gt;</em>的C++函数，并在Wren中将其公开为静态函数。</li><li id="a22b" class="mr ms iq le b lf na lj nb ln nc lr nd lv ne lz mw mx my mz bi translated">异常处理没有像ChaiScript中那样集成</li><li id="c77d" class="mr ms iq le b lf na lj nb ln nc lr nd lv ne lz mw mx my mz bi translated">Wren类不是动态的(但是具有更快的查找速度):方法/字段是在加载代码时确定的。</li></ol><p id="93d7" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">下面是鹪鹩的味道。我认为代码是不言自明的</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nw nx l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">雷恩游戏菜单屏幕</figcaption></figure><p id="5692" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">这就是我如何在Wren端公开C++端状态，即一个类实例。我花了一段时间才找到不使用静态变量的方法。这达到了目的:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nw nx l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">通过一个技巧从C++公开Wren中的现有状态</figcaption></figure><h1 id="3b05" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">ChaiScript和Wren中的问题</h1><ul class=""><li id="deba" class="mr ms iq le b lf mm lj mn ln nr lr ns lv nt lz nu mx my mz bi translated">在Wren中，你需要一个可复制构造的类型来通过构造函数公开。不过，本文中解释了一个变通方法。</li><li id="9a9a" class="mr ms iq le b lf na lj nb ln nc lr nd lv ne lz nu mx my mz bi translated">在Wren中，将状态从C++暴露给Wren并不是显而易见的(本文中也有记录)</li><li id="1f9f" class="mr ms iq le b lf na lj nb ln nc lr nd lv ne lz nu mx my mz bi translated">在ChaiScript中，一旦你设置了变量的类型，如果你试图分配一个不同的无关类型，它将抛出。但是第一次可以设置一个未定义的。这将失败:</li></ul><pre class="km kn ko kp gt ny nz oa ob aw oc bi"><span id="7154" class="ma jo iq nz b gy od oe l of og">auto vec = []<br/>vec.push_back(MyClass()) // Works<br/>vec[0] = 5 // Fails</span><span id="42f8" class="ma jo iq nz b gy oh oe l of og">var aVar // is_var_undefined() == true<br/>aVar = Mytype() // It works, now aVar has MyType()<br/>aVar = 3 // Fails</span></pre><ul class=""><li id="7470" class="mr ms iq le b lf lg lj lk ln mt lr mu lv mv lz nu mx my mz bi translated">在ChaiScript中，带有或不带有全局变量的顶级变量表现不同。例如，在lambdas中捕捉时要小心。全球不需要。</li><li id="485c" class="mr ms iq le b lf na lj nb ln nc lr nd lv ne lz nu mx my mz bi translated">在ChaiScript C++中，暴露的变量和在ChaiScript中创建的类的行为略有不同。例如:</li></ul><pre class="km kn ko kp gt ny nz oa ob aw oc bi"><span id="b6ac" class="ma jo iq nz b gy od oe l of og">v = CppExposedClass() //Call copy constructor<br/>w = PureChaiClass() // no copy constructor called!</span><span id="b383" class="ma jo iq nz b gy oh oe l of og">v := CppExposedClass() // No copy constructor called, used :=</span></pre><ul class=""><li id="4a42" class="mr ms iq le b lf lg lj lk ln mt lr mu lv mv lz nu mx my mz bi translated">在ChaiScript中，按值捕获vs引用不是太明显。有时它似乎试图复制，有时它不。有时候我最终会做这样的事情:</li></ul><pre class="km kn ko kp gt ny nz oa ob aw oc bi"><span id="3834" class="ma jo iq nz b gy od oe l of og">// Uses reference semantics for C++-side classes. In ChaiScript</span><span id="d043" class="ma jo iq nz b gy oh oe l of og">// classes you always avoid the copy constructor<br/>var v := something</span><span id="460b" class="ma jo iq nz b gy oh oe l of og">// These two are equivalent:<br/>var &amp; v = something</span><span id="4c84" class="ma jo iq nz b gy oh oe l of og">auto &amp; v = something<br/></span><span id="b78e" class="ma jo iq nz b gy oh oe l of og">var lmbda = [v]() { ...} // No copy in capture for sure</span></pre><ul class=""><li id="7c1d" class="mr ms iq le b lf lg lj lk ln mt lr mu lv mv lz nu mx my mz bi translated">在Wren中，您可以创建自由函数，但是没有非可变样式的语法AFAIK，并且您不能直接调用via():</li></ul><pre class="km kn ko kp gt ny nz oa ob aw oc bi"><span id="7387" class="ma jo iq nz b gy od oe l of og">var f = Fn.new {<br/>    ....<br/>}</span><span id="3999" class="ma jo iq nz b gy oh oe l of og">// This fails, you cannot call it</span><span id="1d10" class="ma jo iq nz b gy oh oe l of og">f()</span><span id="5eec" class="ma jo iq nz b gy oh oe l of og">//Use explicit syntax<br/>f.call()</span></pre></div><div class="ab cl nf ng hu nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ij ik il im in"><h1 id="6d71" class="jn jo iq bd jp jq nm js jt ju nn jw jx jy no ka kb kc np ke kf kg nq ki kj kk bi translated">开发工作流程</h1><p id="bdd1" class="pw-post-body-paragraph lc ld iq le b lf mm lh li lj mn ll lm ln mo lp lq lr mp lt lu lv mq lx ly lz ij bi translated">Wren和ChaiScript都做了他们宣传的事情。虽然我发现了一些基本的差异，依我拙见，强烈支持任。</p><ol class=""><li id="c2cb" class="mr ms iq le b lf lg lj lk ln mt lr mu lv mv lz mw mx my mz bi translated">在ChaiScript中，如果你得到一个错误，<strong class="le ir">你得不到</strong>，至少在默认情况下，<strong class="le ir">错误的位置</strong>。这使得<strong class="le ir">调试非常困难</strong>，以至于会耗尽你的生产力。</li><li id="3653" class="mr ms iq le b lf na lj nb ln nc lr nd lv ne lz mw mx my mz bi translated">另一方面，从ChaiScript公开代码稍微容易一些，并且集成了异常。</li><li id="f312" class="mr ms iq le b lf na lj nb ln nc lr nd lv ne lz mw mx my mz bi translated">在Wren中，错误的位置一目了然。</li><li id="e753" class="mr ms iq le b lf na lj nb ln nc lr nd lv ne lz mw mx my mz bi translated">Wren中的<strong class="le ir">并发真的很不错</strong>。</li></ol><h1 id="f605" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">结论</h1><p id="8e13" class="pw-post-body-paragraph lc ld iq le b lf mm lh li lj mn ll lm ln mo lp lq lr mp lt lu lv mq lx ly lz ij bi translated">我认为两者都是有用的工具，但是区别在于3。和4与1相比。用楷书。对我来说，这破坏了相当多的经验。</p><p id="8290" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">在ChaiScript中，很难跟踪代码崩溃的地方，所以我必须用日志消息填充所有部分。在雷恩，我根本不需要它。</p><p id="8b4d" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">此外，ChaiScript中缺乏并发性使得代码充满了回调，我不得不在不支持协程的情况下在C++端生成任务。这使得代码流变得不自然、反向和基于回调。我记得，这也产生了一些问题，因为我必须处理回调代码，否则它会崩溃。但是我现在不确定。</p><p id="38a1" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">在Wren中，如果你看到代码清单，你会发现它看起来很自然，很容易理解。该代码对应于游戏菜单屏幕。</p><p id="6312" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">假设ChaiScript修复了行号错误，如果我打算利用并发性，我仍然会选择Wren，因为我的情况就是这样。</p><p id="6267" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">但是，如果您需要大量带有回调的代码，ChaiScript可以为您节省一些现成的样板文件，因为它不需要回调包装，它通过<em class="nv"> std::function &lt; &gt; </em>完全集成。此外，ChaiScript支持异常。</p><p id="5f9c" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">总而言之，如果ChaiScript修复了行号位置，并且您不打算利用并发性，我可以推荐这两种方法。此外，据我目前所知，如果速度是一个问题，ChaiScript应该比Wren慢得多。</p><p id="cc30" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">但是考虑到事情的现状和现实情况，我认为Wren比ChaiScript更适合生产:它比ChaiScript更快(如果这是一个问题的话),它使用纯解释而不是字节码，它支持并发性，并显示错误发生的位置。</p><p id="ca9e" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">感谢阅读！</p></div></div>    
</body>
</html>