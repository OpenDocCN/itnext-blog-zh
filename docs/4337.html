<html>
<head>
<title>Autoscaling apps on Kubernetes with the Horizontal Pod Autoscaler</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用水平Pod自动缩放器在Kubernetes上自动缩放应用程序</h1>
<blockquote>原文：<a href="https://itnext.io/autoscaling-apps-on-kubernetes-with-the-horizontal-pod-autoscaler-798750ab7847?source=collection_archive---------1-----------------------#2020-06-10">https://itnext.io/autoscaling-apps-on-kubernetes-with-the-horizontal-pod-autoscaler-798750ab7847?source=collection_archive---------1-----------------------#2020-06-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="6cb3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">本文高度概括了Kubernetes中的水平Pod自动缩放器(HPA)的工作原理和使用方法。</p><blockquote class="ko kp kq"><p id="75a3" class="jq jr kr js b jt ju jv jw jx jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kn im bi translated">这篇文章的前一个版本已经发表在<a class="ae kv" href="https://learnk8s.io/autoscaling-apps-kubernetes" rel="noopener ugc nofollow" target="_blank"> learnk8s.io </a>上。</p></blockquote><h1 id="8b60" class="kw kx it bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">内容</h1><ol class=""><li id="6c72" class="lu lv it js b jt lw jx lx kb ly kf lz kj ma kn mb mc md me bi translated"><a class="ae kv" href="#bdb0" rel="noopener ugc nofollow">T3】简介T5】</a></li><li id="b9bf" class="lu lv it js b jt mf jx mg kb mh kf mi kj mj kn mb mc md me bi translated"><a class="ae kv" href="#cefc" rel="noopener ugc nofollow"><strong class="js iu">Kubernetes</strong></a>中不同类型的自动缩放</li><li id="1be5" class="lu lv it js b jt mf jx mg kb mh kf mi kj mj kn mb mc md me bi translated"><a class="ae kv" href="#3417" rel="noopener ugc nofollow"> <strong class="js iu">什么是水平Pod自动缩放器？</strong>T13】</a></li><li id="0d38" class="lu lv it js b jt mf jx mg kb mh kf mi kj mj kn mb mc md me bi translated"><a class="ae kv" href="#67ab" rel="noopener ugc nofollow"> <strong class="js iu">水平Pod自动缩放器是如何配置的？</strong> </a></li><li id="4e6a" class="lu lv it js b jt mf jx mg kb mh kf mi kj mj kn mb mc md me bi translated"><a class="ae kv" href="#f8ca" rel="noopener ugc nofollow"> <strong class="js iu">应用指标是如何获得的？</strong> </a></li><li id="9848" class="lu lv it js b jt mf jx mg kb mh kf mi kj mj kn mb mc md me bi translated"><a class="ae kv" href="#5927" rel="noopener ugc nofollow"> <strong class="js iu">把一切放在一起</strong> </a></li></ol><h1 id="bdb0" class="kw kx it bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">介绍</h1><p id="16dc" class="pw-post-body-paragraph jq jr it js b jt lw jv jw jx lx jz ka kb mk kd ke kf ml kh ki kj mm kl km kn im bi translated">部署具有静态配置数量副本的无状态应用程序不是最佳选择。</p><p id="dd06" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">流量模式可能会快速变化，应用程序应该能够适应它们:</p><ul class=""><li id="83bb" class="lu lv it js b jt ju jx jy kb mn kf mo kj mp kn mq mc md me bi translated">当请求率增加时，应用程序应该扩展(即增加副本的数量)以保持响应速度。</li><li id="8dc8" class="lu lv it js b jt mf jx mg kb mh kf mi kj mj kn mq mc md me bi translated">当请求率下降时，应用程序应该缩小规模(即减少副本的数量)以避免浪费资源。</li></ul><blockquote class="ko kp kq"><p id="66b1" class="jq jr kr js b jt ju jv jw jx jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kn im bi translated">在水平缩放的上下文中，向上缩放也称为“向外缩放”，向下缩放也称为“向内缩放”。这与垂直缩放形成对比(见下文)，垂直缩放仅使用术语“放大”和“缩小”。</p></blockquote><p id="20bb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通过水平Pod自动缩放器(HPA)，Kubernetes以上述方式为自动缩放应用程序提供了出色的支持。</p><h1 id="cefc" class="kw kx it bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">Kubernetes中不同类型的自动缩放</h1><p id="9d49" class="pw-post-body-paragraph jq jr it js b jt lw jv jw jx lx jz ka kb mk kd ke kf ml kh ki kj mm kl km kn im bi translated">首先，为了消除任何误解，让我们澄清一下Kubernetes中术语“自动缩放”的用法。</p><p id="7959" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Kubernetes包括几个自动缩放功能:</p><ul class=""><li id="c6d0" class="lu lv it js b jt ju jx jy kb mn kf mo kj mp kn mq mc md me bi translated"><a class="ae kv" href="https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu">水平窗格自动缩放(HPA) </strong> </a> <strong class="js iu"> : </strong>调整应用程序的副本窗格数量(水平缩放)</li><li id="8e06" class="lu lv it js b jt mf jx mg kb mh kf mi kj mj kn mq mc md me bi translated"><a class="ae kv" href="https://github.com/kubernetes/autoscaler/tree/master/vertical-pod-autoscaler" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu">垂直窗格自动缩放器(VPA) </strong> </a> <strong class="js iu"> : </strong>调整应用程序容器的资源请求和限制(垂直缩放)</li><li id="ddd6" class="lu lv it js b jt mf jx mg kb mh kf mi kj mj kn mq mc md me bi translated"><a class="ae kv" href="https://github.com/kubernetes/autoscaler/tree/master/cluster-autoscaler" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu">集群自动缩放</strong> </a> <strong class="js iu"> : </strong>调整集群的节点数量</li></ul><p id="c787" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这些自动缩放器彼此完全独立，它们都使用不同的概念和机制。</p><p id="9f06" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="kr">本文专门讨论水平Pod自动缩放器。</em></p><h1 id="3417" class="kw kx it bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">什么是水平吊舱自动缩放器？</h1><p id="cb37" class="pw-post-body-paragraph jq jr it js b jt lw jv jw jx lx jz ka kb mk kd ke kf ml kh ki kj mm kl km kn im bi translated"><a class="ae kv" href="https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/" rel="noopener ugc nofollow" target="_blank">Horizontal Pod auto scaler(HPA)</a>是一个内置的Kubernetes功能，允许根据一个或多个默认或用户定义的指标水平扩展应用程序。</p><blockquote class="ko kp kq"><p id="eb06" class="jq jr kr js b jt ju jv jw jx jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kn im bi translated">水平缩放意味着增加和减少副本的数量。垂直扩展意味着增加和减少单个副本的计算资源。</p></blockquote><p id="5781" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">从技术上讲，HPA是一个<a class="ae kv" href="https://kubernetes.io/docs/concepts/architecture/controller/" rel="noopener ugc nofollow" target="_blank"> Kubernetes控制器</a>，它跟踪并由<a class="ae kv" href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#horizontalpodautoscaler-v1-autoscaling" rel="noopener ugc nofollow" target="_blank"><em class="kr">HorizontalPodAutoscaler</em></a>资源配置。</p><p id="885b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">HPA持续监控关于应用的一个或多个指标，并调整该应用的副本数量，以使指标尽可能接近指定的目标值。</p><blockquote class="ko kp kq"><p id="9b9c" class="jq jr kr js b jt ju jv jw jx jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kn im bi translated">HPA可以使用一个<code class="fe mr ms mt mu b">scale</code>子资源来扩展所有这些Kubernetes资源，其中包括<a class="ae kv" href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#deployment-v1-apps" rel="noopener ugc nofollow" target="_blank">部署</a>、<a class="ae kv" href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#statefulset-v1-apps" rel="noopener ugc nofollow" target="_blank">状态集</a>和<a class="ae kv" href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#replicaset-v1-apps" rel="noopener ugc nofollow" target="_blank">复制集</a>。</p></blockquote><p id="6866" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">HPA执行的控制循环如下:</p><figure class="mw mx my mz gt na gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi mv"><img src="../Images/52104aae2a03a68c5d9ceb2ba965a8b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QcDywVkcCD1AeLYKsxXFQg.png"/></div></div></figure><p id="0c98" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">控制循环的步骤是:</p><ol class=""><li id="0e07" class="lu lv it js b jt ju jx jy kb mn kf mo kj mp kn mb mc md me bi translated"><strong class="js iu">查询扩展指标</strong></li><li id="8b29" class="lu lv it js b jt mf jx mg kb mh kf mi kj mj kn mb mc md me bi translated"><strong class="js iu">计算所需的副本数量</strong></li><li id="7b9d" class="lu lv it js b jt mf jx mg kb mh kf mi kj mj kn mb mc md me bi translated"><strong class="js iu">将应用扩展到所需的副本数量</strong></li></ol><blockquote class="ko kp kq"><p id="70c9" class="jq jr kr js b jt ju jv jw jx jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kn im bi translated">默认情况下，该控制循环每隔<a class="ae kv" href="https://github.com/kubernetes/kubernetes/blob/master/pkg/controller/podautoscaler/config/v1alpha1/defaults.go#L42" rel="noopener ugc nofollow" target="_blank"> 15秒</a>执行一次。</p></blockquote><p id="ce85" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所需副本数量的计算基于扩展指标和用户为这些指标提供的目标值。</p><p id="03b5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在控制循环的每次迭代中，HPA都会计算一个副本计数，使度量的测量值尽可能接近目标值。</p><p id="9314" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如，假设扩展指标是应用程序所有副本单元中每秒收到的平均请求数(req/sec ):</p><ul class=""><li id="2231" class="lu lv it js b jt ju jx jy kb mn kf mo kj mp kn mq mc md me bi translated">如果目标值为10 req/sec，当前值为20 req/sec，则app过载，HPA必须<em class="kr">按比例增加</em>app(即增加副本数量)以使度量<em class="kr">减少</em>并更接近目标值。</li><li id="6fb5" class="lu lv it js b jt mf jx mg kb mh kf mi kj mj kn mq mc md me bi translated">如果目标值为10 req/sec，当前值为2 req/sec，则app未得到充分利用，HPA必须<em class="kr">缩小</em>app(即减少副本数量)以使指标<em class="kr">增加</em>并更接近目标值。</li></ul><p id="2397" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">计算所需副本数量的算法基于以下公式:</p><pre class="mw mx my mz gt nh mu ni nj aw nk bi"><span id="8f16" class="nl kx it mu b gy nm nn l no np"><strong class="mu iu">X = N * (c/t)</strong></span></pre><p id="6a00" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">其中:</p><ul class=""><li id="d2da" class="lu lv it js b jt ju jx jy kb mn kf mo kj mp kn mq mc md me bi translated"><code class="fe mr ms mt mu b">X</code>是所需的副本数量</li><li id="35ca" class="lu lv it js b jt mf jx mg kb mh kf mi kj mj kn mq mc md me bi translated"><code class="fe mr ms mt mu b">N</code>是当前的副本数量</li><li id="0551" class="lu lv it js b jt mf jx mg kb mh kf mi kj mj kn mq mc md me bi translated"><code class="fe mr ms mt mu b">c</code>是缩放指标的当前值</li><li id="cff7" class="lu lv it js b jt mf jx mg kb mh kf mi kj mj kn mq mc md me bi translated"><code class="fe mr ms mt mu b">t</code>是缩放指标的目标值</li></ul><blockquote class="ko kp kq"><p id="81d7" class="jq jr kr js b jt ju jv jw jx jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kn im bi translated">你可以在Kubernetes文档中找到关于HPA算法的细节。</p></blockquote><p id="7fe7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这就是HPA的高级工作方式，现在我们来看看它是如何配置的。</p><h1 id="67ab" class="kw kx it bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">水平Pod自动缩放器是如何配置的？</h1><p id="e9b9" class="pw-post-body-paragraph jq jr it js b jt lw jv jw jx lx jz ka kb mk kd ke kf ml kh ki kj mm kl km kn im bi translated">HPA的配置是通过<a class="ae kv" href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.15/#horizontalpodautoscaler-v2beta2-autoscaling" rel="noopener ugc nofollow" target="_blank"><em class="kr">HorizontalPodAutoscaler</em></a>资源完成的。</p><p id="53fb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一个<em class="kr">HorizontalPodAutoscaler</em>资源允许您指定以下信息:</p><ol class=""><li id="5542" class="lu lv it js b jt ju jx jy kb mn kf mo kj mp kn mb mc md me bi translated"><strong class="js iu">规模化应用(如<em class="kr">部署</em> ) </strong></li><li id="ec38" class="lu lv it js b jt mf jx mg kb mh kf mi kj mj kn mb mc md me bi translated"><strong class="js iu">允许的最小和最大副本数量</strong></li><li id="c2d8" class="lu lv it js b jt mf jx mg kb mh kf mi kj mj kn mb mc md me bi translated"><strong class="js iu">缩放指标</strong></li><li id="be20" class="lu lv it js b jt mf jx mg kb mh kf mi kj mj kn mb mc md me bi translated"><strong class="js iu">缩放指标的目标值</strong></li></ol><p id="d1ae" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一旦您创建了<em class="kr">HorizontalPodAutoscaler</em>资源，HPA就会启动并开始根据您提供的参数监控和自动缩放应用程序。</p><p id="ed03" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面是一个例子<em class="kr">HorizontalPodAutoscaler</em>资源:</p><pre class="mw mx my mz gt nh mu ni nj aw nk bi"><span id="c436" class="nl kx it mu b gy nm nn l no np">apiVersion: autoscaling/v2beta2<br/>kind: HorizontalPodAutoscaler<br/>metadata:<br/>  name: myhpa<br/>spec:<br/>  scaleTargetRef:<br/>    apiVersion: apps/v1<br/>    kind: Deployment<br/>    name: myapp<br/>  minReplicas: 1<br/>  maxReplicas: 10<br/>  metrics:<br/>    - type: Pods<br/>      pods:<br/>        metric:<br/>          name: myapp_requests_per_second<br/>        target:<br/>          type: AverageValue<br/>          averageValue: 50</span></pre><blockquote class="ko kp kq"><p id="7102" class="jq jr kr js b jt ju jv jw jx jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kn im bi translated">存在不同版本的HorizontalPodAutoscaler资源，它们的清单结构不同。上面的例子是版本<code class="fe mr ms mt mu b">v2beta2</code>，在我写这篇文章的时候是最新的版本。</p></blockquote><p id="4734" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">上面的示例<em class="kr">HorizontalPodAutoscaler</em>资源包括以下信息:</p><ol class=""><li id="7cc0" class="lu lv it js b jt ju jx jy kb mn kf mo kj mp kn mb mc md me bi translated">自动缩放(缩放目标)的应用程序是一个名为<code class="fe mr ms mt mu b">myapp</code>的<em class="kr">部署</em></li><li id="73c1" class="lu lv it js b jt mf jx mg kb mh kf mi kj mj kn mb mc md me bi translated">副本的最小和最大数量分别为1和10</li><li id="4a7e" class="lu lv it js b jt mf jx mg kb mh kf mi kj mj kn mb mc md me bi translated">缩放度量被称为<code class="fe mr ms mt mu b">myapp_requests_per_second</code></li><li id="f036" class="lu lv it js b jt mf jx mg kb mh kf mi kj mj kn mb mc md me bi translated">缩放指标的目标值是50</li></ol><p id="31a8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这意味着，HPA将通过尝试保持应用程序所有单元的<code class="fe mr ms mt mu b">myapp_requests_per_second</code>指标的平均值尽可能接近50，在1到10个副本之间自动缩放<code class="fe mr ms mt mu b">myapp</code> <em class="kr">部署</em>。</p><p id="d35f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，拼图中仍然缺少一大块。</p><p id="748f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="kr">什么是</em> <code class="fe mr ms mt mu b"><em class="kr">myapp_requests_per_second</em></code> <em class="kr">公制，它来自哪里？</em></p><h1 id="f8ca" class="kw kx it bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">如何获得应用程序指标？</h1><p id="5acb" class="pw-post-body-paragraph jq jr it js b jt lw jv jw jx lx jz ka kb mk kd ke kf ml kh ki kj mm kl km kn im bi translated">HPA如何获得<em class="kr">HorizontalPodAutoscaler</em>资源中指定的指标？</p><p id="8fe1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">事实证明，HPA从指标API查询这些指标(反过来，用于自动扩展的任何应用程序指标都必须通过指标API公开):</p><figure class="mw mx my mz gt na gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi mv"><img src="../Images/76b066a11fe0acc916589fd6c021fffb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XfY0fZZbCI6yMoEsDAaE-A.png"/></div></div></figure><p id="bc4e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">度量API是Kubernetes集群中的一个中心位置，不同类型的度量可以在这里向不同类型的客户端公开HPA就是这些客户端之一。</p><p id="6d4c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有三种不同的指标API，旨在为不同类型的指标提供服务:</p><figure class="mw mx my mz gt na gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi nq"><img src="../Images/e9166e9685c20c23b7f01b00a0bcc61f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3XnFO03QTs785WBMYICnIg.png"/></div></div></figure><ul class=""><li id="4af5" class="lu lv it js b jt ju jx jy kb mn kf mo kj mp kn mq mc md me bi translated"><a class="ae kv" href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/instrumentation/resource-metrics-api.md" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu">资源指标API </strong> </a>提供预定义的pod和节点的资源使用指标(目前支持CPU和内存使用)。</li><li id="940b" class="lu lv it js b jt mf jx mg kb mh kf mi kj mj kn mq mc md me bi translated"><a class="ae kv" href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/instrumentation/custom-metrics-api.md" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu">自定义指标API </strong> </a>提供用户指定的自定义指标，这些指标与集群中的Kubernetes对象相关联。</li><li id="dd74" class="lu lv it js b jt mf jx mg kb mh kf mi kj mj kn mq mc md me bi translated"><a class="ae kv" href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/instrumentation/external-metrics-api.md" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu">外部指标API </strong> </a>提供用户定义的自定义指标，这些指标<em class="kr">不</em>与集群中的任何Kubernetes对象相关联(这些指标可能来自集群外部的服务，例如云服务)。</li></ul><p id="679b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">从技术角度来看，度量API是<a class="ae kv" href="https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/" rel="noopener ugc nofollow" target="_blank"> Kubernetes扩展API</a>。这意味着，它们是Kubernetes核心API的扩展，可以通过Kubernetes API服务器访问。</p><p id="8f95" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">API服务器上这些指标API的端点路径是:</p><ul class=""><li id="7d7a" class="lu lv it js b jt ju jx jy kb mn kf mo kj mp kn mq mc md me bi translated"><code class="fe mr ms mt mu b">/apis/metrics.k8s.io/v1beta1/</code>对于资源度量API</li><li id="0ca5" class="lu lv it js b jt mf jx mg kb mh kf mi kj mj kn mq mc md me bi translated"><code class="fe mr ms mt mu b">/apis/custom.metrics.k8s.io/v1beta1/</code>对于自定义指标API</li><li id="7936" class="lu lv it js b jt mf jx mg kb mh kf mi kj mj kn mq mc md me bi translated"><code class="fe mr ms mt mu b">/apis/external.metrics.k8s.io/v1beta1/</code>对于外部指标API</li></ul><blockquote class="ko kp kq"><p id="d65b" class="jq jr kr js b jt ju jv jw jx jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kn im bi translated">默认情况下，Kubernetes集群中没有启用度量API。它们必须通过安装适当的扩展API服务器来显式启用(见下文)。</p></blockquote><p id="201d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">上例中的<code class="fe mr ms mt mu b">myapp_requests_per_second</code>指标是一个用户定义的指标，它与Pod相关联(其含义是Pod当前每秒接收的请求数)。</p><p id="4fb3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这意味着<code class="fe mr ms mt mu b">myapp_requests_per_second</code>指标必须通过定制的指标API来提供。</p><p id="b269" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="kr">但是这个指标是如何进入定制指标API的呢？</em></p><p id="59e7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">答案是，您必须通过定制的度量API来安排收集、处理和提供这个度量的事情。</p><p id="1427" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为此，您必须首先启用自定义指标API。</p><p id="55ba" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">启用指标API是通过在集群中安装一个提供这个特定指标API的<strong class="js iu">指标API服务器</strong>来完成的:</p><ul class=""><li id="4cdf" class="lu lv it js b jt ju jx jy kb mn kf mo kj mp kn mq mc md me bi translated">对于<strong class="js iu">资源度量API </strong>，有一个名为<a class="ae kv" href="https://github.com/kubernetes-sigs/metrics-server" rel="noopener ugc nofollow" target="_blank">度量服务器</a>的官方度量API服务器。</li><li id="3356" class="lu lv it js b jt mf jx mg kb mh kf mi kj mj kn mq mc md me bi translated">对于<strong class="js iu">自定义指标API </strong>和<strong class="js iu">外部指标API </strong>，存在各种第三方指标API服务器。其中最受欢迎的大概就是<a class="ae kv" href="https://github.com/DirectXMan12/k8s-prometheus-adapter" rel="noopener ugc nofollow" target="_blank">普罗米修斯适配器</a>。</li></ul><blockquote class="ko kp kq"><p id="1fd5" class="jq jr kr js b jt ju jv jw jx jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kn im bi translated">度量API可以相互独立地启用。例如，您可以启用资源指标API，而不启用其他两个指标API。</p></blockquote><p id="a0db" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">度量API服务器通过度量API提供度量，但是它通常不从度量源收集原始度量数据。这项工作由另一个称为<strong class="js iu">指标收集器</strong>的组件来完成(这个<strong class="js iu"> </strong>可以在集群内部或外部运行):</p><ul class=""><li id="f73f" class="lu lv it js b jt ju jx jy kb mn kf mo kj mp kn mq mc md me bi translated">对于<strong class="js iu">资源度量API </strong>，默认的度量收集器是<a class="ae kv" href="https://github.com/google/cadvisor" rel="noopener ugc nofollow" target="_blank"> cAdvisor </a>，它被编译到kubelet中，因此默认情况下在每个Kubernetes集群中运行。它收集节点上所有容器以及整个节点的资源使用度量(如CPU和内存)。</li><li id="f779" class="lu lv it js b jt mf jx mg kb mh kf mi kj mj kn mq mc md me bi translated">对于<strong class="js iu">自定义指标API </strong>和<strong class="js iu">外部指标API </strong>，可以使用各种第三方指标收集器。最流行的可能是<a class="ae kv" href="https://prometheus.io/" rel="noopener ugc nofollow" target="_blank"> Prometheus </a>，但也可以使用其他通用指标收集系统，如Datadog或Google Stackdriver。</li></ul><blockquote class="ko kp kq"><p id="0e2f" class="jq jr kr js b jt ju jv jw jx jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kn im bi translated">指标收集器和指标API服务器形成了一个集成的“指标管道”,它们必须能够相互通信。大多数指标收集系统(如Prometheus)都有一个相关的指标API服务器(如Prometheus Adapter)，它们应该相互配合使用。</p></blockquote><p id="0c69" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">启用了所有三个指标API的典型设置如下所示:</p><figure class="mw mx my mz gt na gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi nr"><img src="../Images/70e06c6cf4e483bca5e55fc345a152c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LTRHK89pqcYaP2-pzfSYvQ.png"/></div></div></figure><p id="880e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该设置使用一个由cAdvisor和metrics Server组成的Metrics管道用于资源Metrics API(官方默认设置)，另一个由Prometheus和Prometheus适配器组成的Metrics管道用于自定义Metrics API和外部Metrics API。</p><blockquote class="ko kp kq"><p id="d05b" class="jq jr kr js b jt ju jv jw jx jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kn im bi translated">需要注意的是，在vanilla Kubernetes集群中，默认情况下不会安装这些组件(除了cAdvisor)。如果您想要利用metrics APIs(例如，使用HPA自动扩展应用程序)，您必须适当地安装和配置它们。</p></blockquote><p id="320d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">回到<code class="fe mr ms mt mu b">myapp_requests_per_second</code>指标，这个示例场景中的情况如下:</p><ul class=""><li id="ff43" class="lu lv it js b jt ju jx jy kb mn kf mo kj mp kn mq mc md me bi translated">普罗米修斯从属于<code class="fe mr ms mt mu b">myapp</code> <em class="kr">部署的吊舱中收集度量数据。</em></li><li id="8e1b" class="lu lv it js b jt mf jx mg kb mh kf mi kj mj kn mq mc md me bi translated">Prometheus Adapter从Prometheus获取收集的指标数据，并通过自定义指标API将其作为名为<code class="fe mr ms mt mu b">myapp_requests_per_second</code>的指标。</li><li id="44d6" class="lu lv it js b jt mf jx mg kb mh kf mi kj mj kn mq mc md me bi translated">HPA从自定义指标API查询<code class="fe mr ms mt mu b">myapp_requests_per_second</code>指标，并使用它来自动缩放<code class="fe mr ms mt mu b">myapp</code> <em class="kr">部署。</em></li></ul><blockquote class="ko kp kq"><p id="19d2" class="jq jr kr js b jt ju jv jw jx jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kn im bi translated">如何配置度量收集器(如Prometheus)来收集特定的度量，以及如何配置度量API服务器(如Prometheus Adapter)来公开特定的度量，这与所使用的度量收集器和度量API服务器解决方案高度相关。详情可在相应的文档中找到(例如<a class="ae kv" href="https://prometheus.io/docs/prometheus/latest/configuration/configuration/" rel="noopener ugc nofollow" target="_blank"> Prometheus </a>和<a class="ae kv" href="https://github.com/DirectXMan12/k8s-prometheus-adapter/blob/master/docs/config.md" rel="noopener ugc nofollow" target="_blank"> Prometheus适配器</a>的文档)。</p></blockquote><p id="6af4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这相当复杂，所以让我们通过一个例子来概括一下。</p><h1 id="5927" class="kw kx it bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">把所有东西放在一起</h1><p id="47df" class="pw-post-body-paragraph jq jr it js b jt lw jv jw jx lx jz ka kb mk kd ke kf ml kh ki kj mm kl km kn im bi translated">为了更好地了解如何协同工作，让我们来看一下根据应用程序pod每秒接收的平均请求数，使用HPA自动扩展应用程序的具体步骤。</p><p id="f0bf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面假设集群还没有启用指标API，要自动伸缩的应用程序是名为<code class="fe mr ms mt mu b">myapp</code>的<em class="kr">部署</em>，要自动伸缩的指标称为<code class="fe mr ms mt mu b">myapp_requests_per_second</code>，并且要使用基于Prometheus的自定义指标管道(如上所示)。</p><p id="277a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你要做的是:</p><ol class=""><li id="c88f" class="lu lv it js b jt ju jx jy kb mn kf mo kj mp kn mb mc md me bi translated">检测应用程序以收集原始指标数据(如收到的请求总数)，并将其以Prometheus格式公开，以便Prometheus可以收集这些数据。这通常通过使用<a class="ae kv" href="https://prometheus.io/docs/instrumenting/clientlibs/" rel="noopener ugc nofollow" target="_blank"> Prometheus客户端库</a>来完成。</li><li id="d128" class="lu lv it js b jt mf jx mg kb mh kf mi kj mj kn mb mc md me bi translated">在集群中安装<a class="ae kv" href="https://prometheus.io/" rel="noopener ugc nofollow" target="_blank"> Prometheus </a>(理论上也可能在集群外运行)并配置它收集app公开的度量数据。配置Prometheus收集特定指标是通过所谓的<a class="ae kv" href="https://prometheus.io/docs/prometheus/latest/configuration/configuration/" rel="noopener ugc nofollow" target="_blank">Prometheus“scrape config”</a>文件完成的。</li><li id="6964" class="lu lv it js b jt mf jx mg kb mh kf mi kj mj kn mb mc md me bi translated">在集群中安装<a class="ae kv" href="https://github.com/DirectXMan12/k8s-prometheus-adapter" rel="noopener ugc nofollow" target="_blank"> Prometheus适配器</a>并配置它定期查询从Prometheus收集的指标数据，将其转换为名为<code class="fe mr ms mt mu b">myapp_requests_per_second</code>的指标，并通过自定义指标API公开。使用<a class="ae kv" href="https://github.com/DirectXMan12/k8s-prometheus-adapter/blob/master/docs/config.md" rel="noopener ugc nofollow" target="_blank"> Prometheus适配器配置文件</a>配置Prometheus适配器。</li><li id="81a2" class="lu lv it js b jt mf jx mg kb mh kf mi kj mj kn mb mc md me bi translated">在集群中创建一个<em class="kr">HorizontalPodAutoscaler</em>资源，该资源根据名为<code class="fe mr ms mt mu b">myapp_requests_per_second</code>(由定制度量API公开)的度量和一些目标值(比如50)来定义名为<code class="fe mr ms mt mu b">myapp</code>的部署。为此，您可以重用本文前面显示的资源。</li></ol><p id="665f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">就这样——一旦创建了<em class="kr">HorizontalPodAutoscaler</em>, HPA将开始通过自定义指标API监控指定的指标，并适当地自动缩放您的应用程序。</p><p id="ccf9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="kr">您可以往后靠，并对您的应用始终适应当前需求充满信心。</em></p><p id="46c8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">将这些知识付诸实践仍然需要大量的工作。特别是，配置Prometheus和Prometheus Adapter有许多特殊的细节，以便以正确的方式收集和公开正确的指标。</p><p id="467a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果时间允许，我将在以后的文章中提供一个完整的、实用的、一步一步进行设置的演练。</p><p id="9a9e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你对此感兴趣，请在评论中告诉我！</p></div></div>    
</body>
</html>