<html>
<head>
<title>Flutter : Everything about Stack..</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">颤振:关于栈的一切..</h1>
<blockquote>原文：<a href="https://itnext.io/flutter-everything-about-stack-48fe809874e9?source=collection_archive---------1-----------------------#2020-05-05">https://itnext.io/flutter-everything-about-stack-48fe809874e9?source=collection_archive---------1-----------------------#2020-05-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/a6e8636b96ce046856f8933c31756bb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cmRMHcY568UJLj-qID6DZg.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">照片由<a class="ae jd" href="https://unsplash.com/@thoughtcatalog?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">思想目录</a>在<a class="ae jd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><div class=""/><div class=""><h2 id="8f9f" class="pw-subtitle-paragraph kd jf jg bd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dk translated">一站深潜..</h2></div><p id="7f2d" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi lr translated"><span class="l ls lt lu bm lv lw lx ly lz di">一个</span>堆栈窗口小部件包含一个窗口小部件列表，它把它们一个放在另一个上面。因此，在渲染时，它会从底部到顶部渲染它们。</p><p id="615e" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">堆栈的大小取决于其子部件。堆栈大小将与它的一个子堆栈占用的最大大小相同。</p><p id="4aeb" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">首先，让我们总结理论部分，就像我们一直被教导的那样。之后会用一个例子来演示。</p><figure class="ma mb mc md gt is"><div class="bz fp l di"><div class="me mf l"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">来源|<a class="ae jd" href="https://giphy.com/" rel="noopener ugc nofollow" target="_blank">giphy.com</a></figcaption></figure></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><blockquote class="mn mo mp"><p id="1b00" class="kv kw mq kx b ky kz kh la lb lc kk ld mr lf lg lh ms lj lk ll mt ln lo lp lq ij bi translated">堆栈小部件的每个成员要么是<em class="jg">定位的</em>要么是<em class="jg">非定位的。</em></p></blockquote><h2 id="2bfc" class="mu mv jg bd mw mx my dn mz na nb dp nc le nd ne nf li ng nh ni lm nj nk nl nm bi translated">定位的小部件:</h2><p id="c23e" class="pw-post-body-paragraph kv kw jg kx b ky nn kh la lb no kk ld le np lg lh li nq lk ll lm nr lo lp lq ij bi translated">用定位的小部件包装的堆栈的子级。</p><p id="ca66" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">它使用参数组合——垂直(顶部、底部、高度)和水平(左侧、右侧和宽度)来定位堆栈中的小部件。</p><p id="15fb" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">注:如果没有定位部件，对齐部件用于定位堆栈的成员。</p><h2 id="f5b0" class="mu mv jg bd mw mx my dn mz na nb dp nc le nd ne nf li ng nh ni lm nj nk nl nm bi translated"><strong class="ak">非定位微件:</strong></h2><p id="f34e" class="pw-post-body-paragraph kv kw jg kx b ky nn kh la lb no kk ld le np lg lh li nq lk ll lm nr lo lp lq ij bi translated">如果堆栈的成员没有用Align或Positioned小部件包装，那么它被认为是非定位小部件。</p><p id="df66" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">根据堆栈的对齐属性，未定位的小部件最终会出现在屏幕上。默认情况下，在屏幕的左上角。</p><p id="0150" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jh">够了，来举例说明吧。</strong></p><pre class="ma mb mc md gt ns nt nu nv aw nw bi"><span id="572e" class="mu mv jg nt b gy nx ny l nz oa">Stack(</span><span id="355b" class="mu mv jg nt b gy ob ny l nz oa">  alignment: Alignment.topLeft,</span><span id="be5d" class="mu mv jg nt b gy ob ny l nz oa">  children: &lt;Widget&gt;[</span><span id="b3d3" class="mu mv jg nt b gy ob ny l nz oa">    Positioned(<br/>      top: 100,<br/>      left: 100,<br/>      child: Container(<br/>        height: 300,<br/>        width: 300,<br/>        child: Center(child: Text('Positioned')),<br/>        color: Colors.amber,<br/>      ),<br/>    ),</span><span id="90bf" class="mu mv jg nt b gy ob ny l nz oa">    Align(<br/>      alignment: Alignment.topRight,<br/>      child: Container(<br/>        height: 200,<br/>        width: 200,<br/>        child: Center(child: Text('Aligned')),<br/>        color: Colors.brown,<br/>      ),<br/>    ),</span><span id="6d8e" class="mu mv jg nt b gy ob ny l nz oa">    Container(<br/>      height: 100,<br/>      width: 100,<br/>      child: Center(child: Text('Non-Positioned')),<br/>        color: Colors.cyan,<br/>    ),<br/>  ],<br/>)</span></pre><p id="5528" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">结果会是…</p><figure class="ma mb mc md gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oc"><img src="../Images/d7385b2b2dedd95b13780eb9f2bb068f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fgQIrLPqkTr5PsXia8IjhA.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">与子成员堆叠</figcaption></figure><p id="3a69" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">那很简单…！！没错。等等，总会有更多的…</p><p id="db75" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">有几种方法可以使用定位部件。</p><blockquote class="mn mo mp"><p id="72f4" class="kv kw mq kx b ky kz kh la lb lc kk ld mr lf lg lh ms lj lk ll mt ln lo lp lq ij bi translated"><strong class="kx jh"><em class="jg">. fill():</em></strong></p></blockquote><ul class=""><li id="927d" class="od oe jg kx b ky kz lb lc le of li og lm oh lq oi oj ok ol bi translated">它填充整个屏幕，因为属性-左，上，右，下默认设置为0.0。尽管可以覆盖这些属性。</li></ul><blockquote class="mn mo mp"><p id="a07b" class="kv kw mq kx b ky kz kh la lb lc kk ld mr lf lg lh ms lj lk ll mt ln lo lp lq ij bi translated"><strong class="kx jh"><em class="jg">posted . from rect():</em></strong></p></blockquote><ul class=""><li id="7a41" class="od oe jg kx b ky kz lb lc le of li og lm oh lq oi oj ok ol bi translated">它使用指定Rect中的值创建一个定位的对象。</li></ul><blockquote class="mn mo mp"><p id="fab9" class="kv kw mq kx b ky kz kh la lb lc kk ld mr lf lg lh ms lj lk ll mt ln lo lp lq ij bi translated"><strong class="kx jh"><em class="jg">positioned . from relative竖立():</em> </strong></p></blockquote><ul class=""><li id="59e4" class="od oe jg kx b ky kz lb lc le of li og lm oh lq oi oj ok ol bi translated">它用指定的relative verter中的值创建一个定位的对象。</li></ul><p id="5466" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在我们已经了解了堆栈的基本知识，接下来让我们更深入地了解堆栈的参数。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="59b5" class="om mv jg bd mw on oo op mz oq or os nc km ot kn nf kp ou kq ni ks ov kt nl ow bi translated"><strong class="ak">堆栈的参数:</strong></h1><pre class="ma mb mc md gt ns nt nu nv aw nw bi"><span id="9854" class="mu mv jg nt b gy nx ny l nz oa">Stack({<br/>  this.alignment = Alignment.topCenter,<br/>  this.textDirection,<br/>  this.fit = StackFit.loose,<br/>  this.overflow = Overflow.clip,<br/>  List&lt;Widget&gt; children = const &lt;Widget&gt;[],<br/>})</span></pre><p id="35c6" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了更好地理解，我在我们用来说明Stack的同一个例子中演示了这些参数。</p><blockquote class="mn mo mp"><p id="af53" class="kv kw mq kx b ky kz kh la lb lc kk ld mr lf lg lh ms lj lk ll mt ln lo lp lq ij bi translated"><strong class="kx jh"> <em class="jg">对齐:</em> </strong></p></blockquote><ul class=""><li id="f315" class="od oe jg kx b ky kz lb lc le of li og lm oh lq oi oj ok ol bi translated">它基本上决定了堆栈中可用的非定位小部件的位置。</li></ul><pre class="ma mb mc md gt ns nt nu nv aw nw bi"><span id="358f" class="mu mv jg nt b gy nx ny l nz oa">Stack(<br/>  alignment: Alignment.topCenter, // Center of Top<br/>  children: &lt;Widget&gt;[....</span></pre><blockquote class="mn mo mp"><p id="773c" class="kv kw mq kx b ky kz kh la lb lc kk ld mr lf lg lh ms lj lk ll mt ln lo lp lq ij bi translated"><strong class="kx jh"> <em class="jg">文本方向:</em> </strong></p></blockquote><ul class=""><li id="a3ed" class="od oe jg kx b ky kz lb lc le of li og lm oh lq oi oj ok ol bi translated">你可以改变文本的方向，是从左到右(LTR)还是从右到左(RTL)。这在使用多种语言时变得非常方便。</li></ul><pre class="ma mb mc md gt ns nt nu nv aw nw bi"><span id="80ee" class="mu mv jg nt b gy nx ny l nz oa">Stack(<br/>  textDirection: TextDirection.rtl, // Right to Left<br/>  children: &lt;Widget&gt;[....</span></pre><blockquote class="mn mo mp"><p id="b4cb" class="kv kw mq kx b ky kz kh la lb lc kk ld mr lf lg lh ms lj lk ll mt ln lo lp lq ij bi translated"><strong class="kx jh"> <em class="jg">契合:</em> </strong></p></blockquote><ul class=""><li id="a94b" class="od oe jg kx b ky kz lb lc le of li og lm oh lq oi oj ok ol bi translated">它决定了堆栈中可用的非定位部件的大小。</li></ul><p id="bb60" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jh"> StackFit.loose : </strong>如果300*400的约束从其父堆栈传递到堆栈，那么堆栈的未定位子堆栈可以具有从0到300的任何宽度和从0到400的任何高度。</p><p id="1a94" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jh"> StackFit.expand : </strong>如果300*400的约束从其父堆栈传递到堆栈，则堆栈的未定位子堆栈将具有最高的宽度(即300)和最高的高度(即400)。</p><p id="ab47" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jh"> StackFit.passthrough : </strong>对于未定位的子元素，从其父元素传递到堆栈的约束将保持不变。</p><pre class="ma mb mc md gt ns nt nu nv aw nw bi"><span id="248a" class="mu mv jg nt b gy nx ny l nz oa">Stack(<br/>  fit: StackFit.loose,<br/>  children: &lt;Widget&gt;[....</span></pre><blockquote class="mn mo mp"><p id="af81" class="kv kw mq kx b ky kz kh la lb lc kk ld mr lf lg lh ms lj lk ll mt ln lo lp lq ij bi translated"><strong class="kx jh">溢出:溢出:</strong></p></blockquote><ul class=""><li id="7625" class="od oe jg kx b ky kz lb lc le of li og lm oh lq oi oj ok ol bi translated">管理子部件的溢出内容是应该被剪切，还是保持原样，即可见。</li></ul><pre class="ma mb mc md gt ns nt nu nv aw nw bi"><span id="8290" class="mu mv jg nt b gy nx ny l nz oa">Stack(<br/>  overflow: Overflow.clip, // Clip the Content...<br/>  children: &lt;Widget&gt;[....</span></pre><p id="6d74" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">每个参数的演示将如下所示…</p><figure class="ma mb mc md gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/982550172b1c5fbc7b6cdb7f2fbe668a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TLf7wmOdajVhfsLTzp5ZlA.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">堆栈的参数能做什么</figcaption></figure></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="3f34" class="om mv jg bd mw on oo op mz oq or os nc km ot kn nf kp ou kq ni ks ov kt nl ow bi translated">源代码</h1><p id="489b" class="pw-post-body-paragraph kv kw jg kx b ky nn kh la lb no kk ld le np lg lh li nq lk ll lm nr lo lp lq ij bi translated">点击这里查看Github <a class="ae jd" href="https://gist.github.com/parth2107/4dc513b67425b2f9e67d5b96552bf7ec" rel="noopener ugc nofollow" target="_blank">的源代码</a></p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="c8b8" class="om mv jg bd mw on oo op mz oq or os nc km ot kn nf kp ou kq ni ks ov kt nl ow bi translated">摘要</h1><p id="4b12" class="pw-post-body-paragraph kv kw jg kx b ky nn kh la lb no kk ld le np lg lh li nq lk ll lm nr lo lp lq ij bi translated">在本文中，我们已经深入了解了一些概念，以理解Stack和它的参数在Flutter中是如何的方便。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="b8bf" class="om mv jg bd mw on oo op mz oq or os nc km ot kn nf kp ou kq ni ks ov kt nl ow bi translated">参考</h1><p id="ebad" class="pw-post-body-paragraph kv kw jg kx b ky nn kh la lb no kk ld le np lg lh li nq lk ll lm nr lo lp lq ij bi translated"><a class="ae jd" href="https://api.flutter.dev/flutter/widgets/Stack-class.html" rel="noopener ugc nofollow" target="_blank">颤振腹板</a></p></div></div>    
</body>
</html>