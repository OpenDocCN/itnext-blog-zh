<html>
<head>
<title>Azure DevOps yaml Pipeline Recipes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Azure DevOps yaml管道配方</h1>
<blockquote>原文：<a href="https://itnext.io/azure-devops-yaml-pipeline-recipes-578b5eda3e76?source=collection_archive---------2-----------------------#2020-02-13">https://itnext.io/azure-devops-yaml-pipeline-recipes-578b5eda3e76?source=collection_archive---------2-----------------------#2020-02-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="4e6e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第1部分:简介和创建NuGet包</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/efa0c643da8e62de66d6589f568fb01c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*46n9HUKEYegyqad1snLe_w.jpeg"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">来源:https://pxhere.com/en/photo/925035</figcaption></figure><h1 id="96d5" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">介绍</h1><p id="21e2" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">在我们的团队中，我们相当广泛地使用Azure DevOps。我们管理着相当多的项目，大多数都有持续集成和部署设置。我们使用了Azure DevOps管道的许多功能，从Azure Artifacts Nuget包到本地代理，以在发布和本地部署期间运行本地工具。</p><p id="fa39" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">自从引入yaml管道定义以来，我们已经开始在小项目上使用它们，但是等待它们变得更加成熟，以便将我们最重要的项目迁移到那个新的定义。我们利用这次迁移的机会重新设计了管道，并利用了“旧”UI风格构建的改进。例如，我们使用多阶段来更好地将构建从不同级别的发布中分离出来。</p><p id="34ef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这一系列文章中，我想描述一些我们的方法，我们如何为每一种类型的项目定义我们的构建。</p><h1 id="780f" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">Yaml管道</h1><p id="758e" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">关于如何设置yml管道，我不会讲太多细节。您应该已经对如何创建和配置新的yml管道有了基本的了解。如果你在开始时需要帮助，请访问<a class="ae lb" href="https://docs.microsoft.com/en-us/azure/devops/pipelines/get-started/pipelines-get-started?view=azure-devops" rel="noopener ugc nofollow" target="_blank"> Azure Pipelines文档</a>。</p><p id="8816" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">与旧的基于“UI”的管道相比，Yaml管道有很多优点。最突出的是，由于它们是存储库的一部分，它们是简单的源代码，与应用程序代码的其余部分一起。如果源代码中的变化要求管道发生变化，您可以在同一个提交/分支中完成。它可以是拉请求的一部分，甚至可以在拉请求期间执行更改。</p><h1 id="b982" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">。Net库来获取包</h1><p id="4043" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">现在让我们讨论我们的第一个食谱。我们有很多。Net类库项目，我们将它们转换成NuGet包以包含在我们的主应用程序中。</p><h2 id="da2b" class="mf ld iq bd le mg mh dn li mi mj dp lm jy mk ml lq kc mm mn lu kg mo mp ly mq bi translated">代码</h2><p id="516e" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">我的介绍可能已经让我失去了一半的读者，所以让我们开门见山吧。下面是代码，我将在后面详细解释。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mr ms l"/></div></figure><h2 id="55db" class="mf ld iq bd le mg mh dn li mi mj dp lm jy mk ml lq kc mm mn lu kg mo mp ly mq bi translated">使用模板</h2><p id="cc78" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">迁移到Yaml管道的一个缺点是我们失去了“任务组”。顾名思义，任务组允许创建一组可以在多个管道中使用的任务，并且可以使用变量来设置属性。这样，我们可以在这些任务组中保存配方，在多个管道中使用它们，如果需要更改，我们可以在所有管道中同时进行。</p><p id="45ba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">补救的一个方法是使用模板将yaml管道文件分成多个文件。</p><p id="a1d2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">模板并不复杂，它们是一个简单的yaml文件，您可以将它添加到您的“普通”yaml管道文件(或子文件夹)中，该文件将定义作业定义的“步骤”部分。</p><p id="7b83" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用和定义使用模板的管道的示例</p><pre class="km kn ko kp gt mt mu mv mw aw mx bi"><span id="fc7b" class="mf ld iq mu b gy my mz l na nb">azure-pipeline.yml</span><span id="1d07" class="mf ld iq mu b gy nc mz l na nb">jobs:<br/>- job: demo build<br/>  displayName: 'Build project'<br/>  steps:<br/>  - template: build-steps.yml</span><span id="ec45" class="mf ld iq mu b gy nc mz l na nb"><br/>build-steps.yml</span><span id="6a51" class="mf ld iq mu b gy nc mz l na nb">steps:<br/>- checkout: self<br/>  clean: true<br/>  lfs: true</span><span id="86e0" class="mf ld iq mu b gy nc mz l na nb">- task: DotNetCoreCLI@2<br/>  displayName: 'NuGet Restore'<br/>  inputs:<br/>    command: restore<br/>    projects: '**/*.csproj'</span><span id="7047" class="mf ld iq mu b gy nc mz l na nb">- task: DotNetCoreCLI@2<br/>  displayName: Build all projects<br/>  inputs:<br/>    projects: '**/*.csproj'<br/>    arguments: '--configuration $(buildConfiguration) --no-restore'</span></pre><p id="d48c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在不同项目之间共享步骤的一种方法是将“公共的”构建模板存储在存储库中，并使用git子模块将公共模板包含到所有项目中。</p><h2 id="e89b" class="mf ld iq bd le mg mh dn li mi mj dp lm jy mk ml lq kc mm mn lu kg mo mp ly mq bi translated">版本控制</h2><p id="7d2f" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">对于那些包，我们使用<a class="ae lb" href="https://guides.github.com/introduction/flow/" rel="noopener ugc nofollow" target="_blank"> GitHub流</a>并进行自动版本控制。简单地说，这意味着存储库的<em class="nd">主</em>分支被锁定，我们授权使用PR将工作推给它。分支上的工作要么是新特性，要么是错误修复。我们这样做是为了通过代码评审不断改进我们的代码。</p><p id="7609" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当PR通过并且代码被合并到master时，我们自动创建一个beta版本。一旦我们对我们的版本有了信心，想要创建一个新的官方版本，我们就在master上创建一个标签，它触发一个新的构建并发布主版本。</p><p id="6d4c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了自动化版本管理，我们使用<a class="ae lb" href="https://gitversion.net/docs/" rel="noopener ugc nofollow" target="_blank"> GitVersion </a>。它是一个工具，根据当前检出的git分支的当前状态和一组可重写的规则，可以计算版本号。它可以从<a class="ae lb" href="https://marketplace.visualstudio.com/items?itemName=gittools.usegitversion" rel="noopener ugc nofollow" target="_blank"> Visual Studio Marketplace </a>安装。它添加了一个GitVersion任务，该任务将运行计算并创建一系列包含不同“样式”版本的环境变量。然后，这些环境变量可用于构建步骤或更新程序集版本。</p><h2 id="706c" class="mf ld iq bd le mg mh dn li mi mj dp lm jy mk ml lq kc mm mn lu kg mo mp ly mq bi translated">更新程序集版本</h2><p id="f344" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">GitVersion支持更新AssemblyInfo文件，但方式非常有限。它不支持修改现在存储在“新”csproj文件中的程序集信息。</p><p id="a78e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了克服这个问题，我们使用另一个DevOps扩展，称为<a class="ae lb" href="https://marketplace.visualstudio.com/items?itemName=bleddynrichards.Assembly-Info-Task&amp;targetId=81fedd7b-ac69-4753-8129-f37a56066d21&amp;utm_source=vstsproduct&amp;utm_medium=ExtHubManageList" rel="noopener ugc nofollow" target="_blank">assembly Info</a>。它提供了两个任务，一个用于Net Framework(带有AssemblyInfo文件),一个用于新的Net core / standard项目。</p><p id="5e4d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您只需在管道中添加任务，并使用GitVersion的环境变量来修改文件信息或程序集信息。正如您在示例中看到的，我对<code class="fe ne nf ng mu b">VersionNumber</code>和<code class="fe ne nf ng mu b">FileVersionNumber</code>使用了<code class="fe ne nf ng mu b">$(GitVersion.AssemblySemVer)</code>变量，但是<code class="fe ne nf ng mu b">$(GitVersion.InformationalVersion)</code>包含了信息版本的git提交的SHA1。</p><h2 id="bf9d" class="mf ld iq bd le mg mh dn li mi mj dp lm jy mk ml lq kc mm mn lu kg mo mp ly mq bi translated">构建项目</h2><p id="144a" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">构建过程非常标准，只需调用nuget restore，然后进行构建。我使用通配符一次恢复/构建所有的csproj。</p><h2 id="8f18" class="mf ld iq bd le mg mh dn li mi mj dp lm jy mk ml lq kc mm mn lu kg mo mp ly mq bi translated">发布构建二进制文件</h2><p id="06fb" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">神器有两种用途。首先，它们可以在构建结果页面上下载。这允许我们检查构建阶段是否设置正确。第二个用途是它们将在第二个阶段，即部署阶段被自动下载。</p><p id="b1cf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我正在将编译后的二进制文件复制到工件暂存目录中。这是完全可选的，您也可以忽略它，只发布nupkg文件。我喜欢在工件中复制二进制文件，因为这有助于确保构建按预期工作。</p><h2 id="fbc7" class="mf ld iq bd le mg mh dn li mi mj dp lm jy mk ml lq kc mm mn lu kg mo mp ly mq bi translated">创建nuget包并发布</h2><p id="d5bc" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">最后，我使用。Net Core CLI任务来打包项目，并将其直接复制到工件暂存目录的子目录中。我还将<code class="fe ne nf ng mu b">versionEnvVar</code>参数设置为<code class="fe ne nf ng mu b">GitVersion.NuGetVersionV2</code>环境变量，使其版本与nuget版本控制方案兼容。</p><p id="f5d0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，我使用<code class="fe ne nf ng mu b">PublishBuildArtifacts</code>步骤将两个文件夹作为工件发布。</p><h2 id="c84b" class="mf ld iq bd le mg mh dn li mi mj dp lm jy mk ml lq kc mm mn lu kg mo mp ly mq bi translated">部署</h2><p id="8fa4" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">部署阶段被配置为仅在<code class="fe ne nf ng mu b">build_pack</code>阶段成功且触发管道的提交在主分支上时触发。</p><p id="8d47" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它有一个单独的步骤，一个使用<code class="fe ne nf ng mu b">push</code>命令的<code class="fe ne nf ng mu b">NuGetCommand</code>将所有<code class="fe ne nf ng mu b">.nupkg</code>文件推入一个内部feed。</p><p id="4069" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">显然，对于公共NuGet包，您可能想要添加其他步骤或其他部署，例如基于一个标签来部署在公共NuGet提要上。</p><h1 id="e7fe" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">结论</h1><p id="4da0" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">如你所见，使用Azure DevOps pipeline来自动化NuGet包的部署相当容易。使用GitVersion还允许自动化版本号。使用模板也是简化在多个项目中重用同一部分管道的好方法。</p><p id="ffa3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在下一部分中，我们将看到一个使用WiX构建桌面应用程序、创建和部署安装程序的方法。</p><p id="f383" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您有任何问题、意见或改进，请随时添加评论。</p></div></div>    
</body>
</html>