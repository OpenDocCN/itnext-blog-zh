<html>
<head>
<title>React: Components &amp; Props</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应:组件和道具</h1>
<blockquote>原文：<a href="https://itnext.io/react-components-props-db1db95c04c8?source=collection_archive---------6-----------------------#2019-05-09">https://itnext.io/react-components-props-db1db95c04c8?source=collection_archive---------6-----------------------#2019-05-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/88137e129edb50d589dc2372b47c4ee3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cIZ31fOlLIFm5Q-m5nW5Rw.png"/></div></div></figure><p id="7fe9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">React中的组件是独立的、可重用的UI片段。一个典型的网页可能由导航栏、内容区和页脚组成。在React中，我们将这些区域创建为组件(而组件又可能由其他组件组成！).它节省了代码重复&amp;正如我们将看到的，允许巨大的灵活性。</p><p id="82e1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">另一种看待组件的方式类似于JavaScript函数。它们接收的不是参数，而是“道具”，然后返回React元素来构建我们在屏幕上看到的东西！</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><p id="25fc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">🤓<em class="lg">想了解最新的网站开发信息吗？</em> <br/>🚀想要将最新的新闻直接发送到您的收件箱吗？<br/>🎉加入一个不断壮大的设计师&amp;开发者社区！</p><p id="9aa1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">在这里订阅我的简讯→</strong><a class="ae lh" href="https://easeout.eo.page/" rel="noopener ugc nofollow" target="_blank"><strong class="kd iu">https://ease out . EO . page</strong></a></p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="6b02" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">成分</h1><p id="4bcd" class="pw-post-body-paragraph kb kc it kd b ke mg kg kh ki mh kk kl km mi ko kp kq mj ks kt ku mk kw kx ky im bi translated">事实上，在React中，一切都是组件！即使是标准的HTML标签也是组件，它们是内置的，是默认添加的。</p><p id="f763" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们来看一个例子:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="1827" class="mu lj it mq b gy mv mw l mx my">import React from 'react'<br/>import ReactDOM from 'react-dom'</span><span id="c531" class="mu lj it mq b gy mz mw l mx my">ReactDOM.render(&lt;h1&gt;I'm a component!&lt;/h1&gt;, document.getElementById('myapp'))</span></pre><p id="d3ec" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里我们使用JSX将<code class="fe na nb nc mq b">&lt;h1&gt;I'm a component!&lt;/h1&gt;</code>插入到id为<code class="fe na nb nc mq b">myapp</code>的元素中。我们的<code class="fe na nb nc mq b">h1</code>被认为是一个组件，感谢<code class="fe na nb nc mq b">React.DOM</code>，事实上所有的HTML标签也是如此。你可以通过在浏览器控制台输入<code class="fe na nb nc mq b">React.DOM</code>来查看它们。</p><h1 id="0152" class="li lj it bd lk ll nd ln lo lp ne lr ls lt nf lv lw lx ng lz ma mb nh md me mf bi translated">构建自定义组件</h1><p id="be88" class="pw-post-body-paragraph kb kc it kd b ke mg kg kh ki mh kk kl km mi ko kp kq mj ks kt ku mk kw kx ky im bi translated">这很好，但是我们如何构建自己的组件呢？这是我们的React超越，它让我们能够通过组合我们自己的自定义组件来构建UI。</p><p id="7f24" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以用两种方式定义组件，现在让我们来看看每种方式:</p><h2 id="76e5" class="mu lj it bd lk ni nj dn lo nk nl dp ls km nm nn lw kq no np ma ku nq nr me ns bi translated"><strong class="ak">功能组件</strong></h2><p id="35d5" class="pw-post-body-paragraph kb kc it kd b ke mg kg kh ki mh kk kl km mi ko kp kq mj ks kt ku mk kw kx ky im bi translated">函数组件实际上只是JavaScript函数:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="4980" class="mu lj it mq b gy mv mw l mx my">function Greeting(props) {<br/>  return &lt;h1&gt;Hello, {props.username}!&lt;/h1&gt;;<br/>}</span></pre><p id="418f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使这个函数成为React组件的是，它接受“props”(或属性)作为带有数据的参数，然后返回React元素。</p><h2 id="2587" class="mu lj it bd lk ni nj dn lo nk nl dp ls km nm nn lw kq no np ma ku nq nr me ns bi translated">类别组件</h2><p id="2631" class="pw-post-body-paragraph kb kc it kd b ke mg kg kh ki mh kk kl km mi ko kp kq mj ks kt ku mk kw kx ky im bi translated">ES6类也可以用来创建组件:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="efce" class="mu lj it mq b gy mv mw l mx my">class Greeting extends React.Component {<br/>  render() {<br/>    return &lt;h1&gt;Hello, {this.props.username}!&lt;/h1&gt;;<br/>  }<br/>}</span></pre><p id="5dde" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们上面的两个代码示例是等价的——并且是创建组件的完全有效的方法。</p><p id="2936" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">直到最近，在React世界中，我们更频繁地使用类组件——因为类组件允许用它们自己的状态来定义组件(我将在下一篇文章中讨论状态！).</p><p id="a202" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然而，随着React Hooks的出现，功能组件现在比以前强大得多，我们可能会看到这种趋势切换回来。</p><p id="c6ed" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">钩子超出了本文的范围！所以让我们继续组件和道具..</p><h1 id="c5db" class="li lj it bd lk ll nd ln lo lp ne lr ls lt nf lv lw lx ng lz ma mb nh md me mf bi translated">渲染组件</h1><p id="983e" class="pw-post-body-paragraph kb kc it kd b ke mg kg kh ki mh kk kl km mi ko kp kq mj ks kt ku mk kw kx ky im bi translated">我们可以呈现表示DOM标签的元素:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="b3b1" class="mu lj it mq b gy mv mw l mx my">const element = &lt;div /&gt;;</span></pre><p id="5799" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们还可以使用用户定义的组件来呈现我们的元素:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="ede9" class="mu lj it mq b gy mv mw l mx my">const element = &lt;Greet username="Bruce" /&gt;;</span></pre><p id="bdb1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当元素包含用户定义的组件时，它会将JSX属性作为对象传递给组件。在反应中这个物体就是我们所说的“道具”。</p><h1 id="0670" class="li lj it bd lk ll nd ln lo lp ne lr ls lt nf lv lw lx ng lz ma mb nh md me mf bi translated">小道具</h1><p id="574a" class="pw-post-body-paragraph kb kc it kd b ke mg kg kh ki mh kk kl km mi ko kp kq mj ks kt ku mk kw kx ky im bi translated">所以“道具”是我们的组件获得属性的方式。</p><p id="a6d8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们来看看实际情况:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="9eaa" class="mu lj it mq b gy mv mw l mx my">function Greeting(props) {<br/>  return &lt;h1&gt;Hello, {props.username}!&lt;/h1&gt;;<br/>}</span><span id="5b9e" class="mu lj it mq b gy mz mw l mx my">const element = &lt;Greet username="Bruce" /&gt;;</span><span id="8c7d" class="mu lj it mq b gy mz mw l mx my">ReactDOM.render(<br/>  element,<br/>  document.getElementById('root')<br/>);</span></pre><p id="9048" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这段代码将呈现“你好，布鲁斯！”在页面上。</p><p id="cf55" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里发生了什么事？</p><ul class=""><li id="254e" class="nt nu it kd b ke kf ki kj km nv kq nw ku nx ky ny nz oa ob bi translated">用<code class="fe na nb nc mq b">&lt;Greet username="Bruce" /&gt;</code>元素调用<code class="fe na nb nc mq b">ReactDOM.render()</code>。</li><li id="dd0e" class="nt nu it kd b ke oc ki od km oe kq of ku og ky ny nz oa ob bi translated">React调用以<code class="fe na nb nc mq b">{name: 'Bruce'}</code>为道具的<code class="fe na nb nc mq b">Greet</code>组件。</li><li id="eac4" class="nt nu it kd b ke oc ki od km oe kq of ku og ky ny nz oa ob bi translated">我们的<code class="fe na nb nc mq b">Greet</code>组件返回一个<code class="fe na nb nc mq b">&lt;h1&gt;Hello, Bruce!&lt;/h1&gt;</code>元素作为结果。</li><li id="c19c" class="nt nu it kd b ke oc ki od km oe kq of ku og ky ny nz oa ob bi translated">React DOM更新DOM以匹配<code class="fe na nb nc mq b">&lt;h1&gt;Hello, Bruce!&lt;/h1&gt;</code>。</li></ul><p id="71e5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="lg">注意:</em>始终以大写字母开始组件名称！因为React将以小写字母开头的组件视为DOM标签。</p><h1 id="7332" class="li lj it bd lk ll nd ln lo lp ne lr ls lt nf lv lw lx ng lz ma mb nh md me mf bi translated">功能组件中的道具</h1><p id="f125" class="pw-post-body-paragraph kb kc it kd b ke mg kg kh ki mh kk kl km mi ko kp kq mj ks kt ku mk kw kx ky im bi translated">应该注意的是，当处理有多个子组件的组件时(见下面的<code class="fe na nb nc mq b">h1</code>和<code class="fe na nb nc mq b">p</code>)，每个子组件都从父组件获得道具。</p><p id="961e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当使用一个函数组件时，props是所有被传递的东西，它们可以通过添加<code class="fe na nb nc mq b">props</code>作为函数参数来获得:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="bb09" class="mu lj it mq b gy mv mw l mx my">const BlogPostInfo = props =&gt; {<br/>  return (<br/>    &lt;div&gt;<br/>      &lt;h1&gt;{props.title}&lt;/h1&gt;<br/>      &lt;p&gt;{props.description}&lt;/p&gt;<br/>    &lt;/div&gt;<br/>  )<br/>}</span></pre><h1 id="bdbf" class="li lj it bd lk ll nd ln lo lp ne lr ls lt nf lv lw lx ng lz ma mb nh md me mf bi translated">类组件中的道具</h1><p id="2910" class="pw-post-body-paragraph kb kc it kd b ke mg kg kh ki mh kk kl km mi ko kp kq mj ks kt ku mk kw kx ky im bi translated">在类组件中，默认情况下会传递属性。它们可以作为组件实例中的<code class="fe na nb nc mq b">this.props</code>来访问。</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="0937" class="mu lj it mq b gy mv mw l mx my">import React, { Component } from 'react'</span><span id="b176" class="mu lj it mq b gy mz mw l mx my">class BlogPostInfo extends Component {<br/>  render() {<br/>    return (<br/>      &lt;div&gt;<br/>        &lt;h1&gt;{this.props.title}&lt;/h1&gt;<br/>        &lt;p&gt;{this.props.description}&lt;/p&gt;<br/>      &lt;/div&gt;<br/>    )<br/>  }<br/>}</span></pre><p id="3244" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">将属性传递给子组件是在应用程序中传递值的一种很好的方式。组件要么保存数据(有状态)，要么通过它们的props接收数据。</p><h1 id="45c0" class="li lj it bd lk ll nd ln lo lp ne lr ls lt nf lv lw lx ng lz ma mb nh md me mf bi translated">额外学分…</h1><p id="b51d" class="pw-post-body-paragraph kb kc it kd b ke mg kg kh ki mh kk kl km mi ko kp kq mj ks kt ku mk kw kx ky im bi translated">现在我们知道了如何在组件中使用道具。让我们来看看我们可能会遇到的一些更常见的任务:</p><h2 id="4033" class="mu lj it bd lk ni nj dn lo nk nl dp ls km nm nn lw kq no np ma ku nq nr me ns bi translated">属性默认值</h2><p id="2df0" class="pw-post-body-paragraph kb kc it kd b ke mg kg kh ki mh kk kl km mi ko kp kq mj ks kt ku mk kw kx ky im bi translated">如果组件初始化时缺少任何值，我们需要提供一个默认值。可以指定默认值，如下所示:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="b14b" class="mu lj it mq b gy mv mw l mx my">BlogPostInfo.propTypes = {<br/>  title: PropTypes.string,<br/>  description: PropTypes.string<br/>}</span><span id="f794" class="mu lj it mq b gy mz mw l mx my">BlogPostInfo.defaultProps = {<br/>  title: '',<br/>  description: ''<br/>}</span></pre><h2 id="8c34" class="mu lj it bd lk ni nj dn lo nk nl dp ls km nm nn lw kq no np ma ku nq nr me ns bi translated">传递道具</h2><p id="7f8d" class="pw-post-body-paragraph kb kc it kd b ke mg kg kh ki mh kk kl km mi ko kp kq mj ks kt ku mk kw kx ky im bi translated">当我们初始化一个组件时，我们像这样传递我们的属性:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="89a1" class="mu lj it mq b gy mv mw l mx my">const desc = 'My blog post description'<br/><br/>&lt;BlogPostInfo title="My blog post title" description={desc} /&gt;</span></pre><p id="874b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们正在处理字符串，我们可以把我们的道具作为一个字符串传入(就像我们上面的‘title’一样)。否则，我们使用变量，正如我们将上述描述设置为<code class="fe na nb nc mq b">desc</code>一样。</p><h2 id="ca14" class="mu lj it bd lk ni nj dn lo nk nl dp ls km nm nn lw kq no np ma ku nq nr me ns bi translated">“儿童”道具</h2><p id="5507" class="pw-post-body-paragraph kb kc it kd b ke mg kg kh ki mh kk kl km mi ko kp kq mj ks kt ku mk kw kx ky im bi translated"><code class="fe na nb nc mq b">children</code>道具与常规略有不同。它包含在组件的<code class="fe na nb nc mq b">body</code>中传递的任何值，例如:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="3bd9" class="mu lj it mq b gy mv mw l mx my">&lt;BlogPostInfo title="My blog post title" description="{desc}"&gt;<br/>  More words<br/>&lt;/BlogPostInfo&gt;</span></pre><p id="d125" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在本例中，在<code class="fe na nb nc mq b">BlogPostInfo</code>中，我们可以通过<code class="fe na nb nc mq b">this.props.children</code>访问“更多单词”。</p><h2 id="6b93" class="mu lj it bd lk ni nj dn lo nk nl dp ls km nm nn lw kq no np ma ku nq nr me ns bi translated">组件中的组件</h2><p id="f0ef" class="pw-post-body-paragraph kb kc it kd b ke mg kg kh ki mh kk kl km mi ko kp kq mj ks kt ku mk kw kx ky im bi translated">组件可以在其输出中包含其他组件。</p><p id="2955" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">创建一个<code class="fe na nb nc mq b">MyApp</code>组件完全没问题，它可以多次呈现<code class="fe na nb nc mq b">Greet</code>:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="2c02" class="mu lj it mq b gy mv mw l mx my">function Greet(props) {<br/>  return &lt;h1&gt;Hello, {props.username}!&lt;/h1&gt;;<br/>}</span><span id="ac9c" class="mu lj it mq b gy mz mw l mx my">function MyApp() {<br/>  return (<br/>    &lt;div&gt;<br/>      &lt;Greet name="Bruce" /&gt;<br/>      &lt;Greet name="Bethany" /&gt;<br/>      &lt;Greet name="Bilbo" /&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span><span id="9f0c" class="mu lj it mq b gy mz mw l mx my">ReactDOM.render(<br/>  &lt;MyApp /&gt;,<br/>  document.getElementById('root')<br/>);</span></pre><h2 id="50cb" class="mu lj it bd lk ni nj dn lo nk nl dp ls km nm nn lw kq no np ma ku nq nr me ns bi translated">道具是只读的！</h2><p id="c599" class="pw-post-body-paragraph kb kc it kd b ke mg kg kh ki mh kk kl km mi ko kp kq mj ks kt ku mk kw kx ky im bi translated">不管你的组件是声明为函数还是类组件，它永远不能修改自己的props。请参见以下示例:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="bd78" class="mu lj it mq b gy mv mw l mx my">function sum(a, b) {<br/>  return a + b;<br/>}</span></pre><p id="df4b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是一个“纯”函数，因为它不试图改变它的输入，并且对于相同的输入总是返回相同的结果。</p><p id="d02c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">“不纯”函数是指改变其自身输入的函数:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="009d" class="mu lj it mq b gy mv mw l mx my">function withdraw(account, amount) {<br/>  account.total -= amount;<br/>}</span></pre><p id="8478" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">反应过来，这是一个大忌！每一个组件都必须像一个纯函数一样工作。</p><p id="5f50" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我的下一篇文章将讨论React中的“状态”。有了状态，我们的组件能够改变它们的输出以响应触发器，比如用户动作或网络响应——而不违反这条规则。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><p id="8ba6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"> <em class="lg">你准备好让你的JavaScript技能更上一层楼了吗？</em> </strong> <em class="lg">今天就开始用我的新电子书吧！无论你是想学习你的第一行代码，还是想扩展你的知识面并真正学习基础知识..</em><a class="ae lh" href="https://gum.co/mastering-javascript" rel="noopener ugc nofollow" target="_blank"><em class="lg">JavaScript掌握完全指南</em> </a> <em class="lg">带你从零到英雄！</em></p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oh"><img src="../Images/dde515044536421c6c999650977f80c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1fUokZkbKj-qlRPVN_Txrg.png"/></div></div><figcaption class="oi oj gj gh gi ok ol bd b be z dk translated"><em class="om">现已上市！👉</em><a class="ae lh" href="https://gum.co/mastering-javascript" rel="noopener ugc nofollow" target="_blank">https://gum.co/mastering-javascript</a></figcaption></figure><h1 id="b7a1" class="li lj it bd lk ll nd ln lo lp ne lr ls lt nf lv lw lx ng lz ma mb nh md me mf bi translated">结论</h1><p id="e826" class="pw-post-body-paragraph kb kc it kd b ke mg kg kh ki mh kk kl km mi ko kp kq mj ks kt ku mk kw kx ky im bi translated">我们走吧！我们已经介绍了构建组件的基础知识，以及如何将它们融入React应用程序的整体结构。我们还看到了如何使用属性来赋予组件属性。我们已经看了一些在使用组件和道具时可能会遇到的常见任务。</p><p id="48ef" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我希望这篇文章对你有用！你可以在Medium上<a class="ae lh" href="https://medium.com/@timothyrobards" rel="noopener">关注我</a>。我也在<a class="ae lh" href="https://twitter.com/easeoutco" rel="noopener ugc nofollow" target="_blank">推特</a>上。欢迎在下面的评论中留下任何问题。我很乐意帮忙！</p><h1 id="a0f9" class="li lj it bd lk ll nd ln lo lp ne lr ls lt nf lv lw lx ng lz ma mb nh md me mf bi translated">关于我的一点点..</h1><p id="72d3" class="pw-post-body-paragraph kb kc it kd b ke mg kg kh ki mh kk kl km mi ko kp kq mj ks kt ku mk kw kx ky im bi translated">嘿，我是提姆！👋我是一名开发人员、技术作家和作家。如果你想看我所有的教程，可以在我的个人博客上找到。</p><p id="50a2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我目前正在撰写我的<a class="ae lh" href="http://www.easeout.co/freelance" rel="noopener ugc nofollow" target="_blank">自由职业完整指南</a>。坏消息是它还不可用！但是如果这是你可能感兴趣的东西，你可以<a class="ae lh" href="https://easeout.eo.page/news" rel="noopener ugc nofollow" target="_blank">注册，当它可用的时候会通知你👍</a></p><p id="71dc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">感谢阅读🎉</p></div></div>    
</body>
</html>