<html>
<head>
<title>Bare-metal Kubernetes with Kubeadm, NGINX ingress controller and HAProxy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带Kubeadm、NGINX入口控制器和HAProxy的裸机Kubernetes</h1>
<blockquote>原文：<a href="https://itnext.io/bare-metal-kubernetes-with-kubeadm-nginx-ingress-controller-and-haproxy-bb0a7ef29d4e?source=collection_archive---------0-----------------------#2021-02-02">https://itnext.io/bare-metal-kubernetes-with-kubeadm-nginx-ingress-controller-and-haproxy-bb0a7ef29d4e?source=collection_archive---------0-----------------------#2021-02-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/b97b8885fcdadde567a21f38c5c2c6dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*phWwscV6aRCycLfvoQfdnQ.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">图片由<a class="ae kf" href="https://pixabay.com/users/thorstenf-7677369/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=4197733" rel="noopener ugc nofollow" target="_blank">托尔斯滕·弗伦泽尔</a>从<a class="ae kf" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=4197733" rel="noopener ugc nofollow" target="_blank">皮克斯拜</a>拍摄</figcaption></figure><p id="81fc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是我关于设置“裸机”Kubernetes (k8s)集群的一些笔记。我将裸机放在双引号中，因为我实际上使用了AWS EC2实例，但只是作为普通的虚拟机，目标是能够在任何云或内部基础架构中部署此场景，而不依赖于k8s云服务，如EKS、AKS或GKE。我选择了<a class="ae kf" href="https://kubernetes.io/docs/reference/setup-tools/kubeadm/" rel="noopener ugc nofollow" target="_blank"> Kubeadm </a>作为Kubernetes集群部署工具，因为它是官方Kubernetes项目的一部分。</p><p id="c398" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这种设置的总体架构是:</p><ul class=""><li id="970c" class="le lf it ki b kj kk kn ko kr lg kv lh kz li ld lj lk ll lm bi translated">HAProxy运行在专用EC2实例上，充当负载平衡器和从Kubernetes公开的端点DNS名称的TLS终端</li><li id="2452" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">默认的HAProxy后端由3个k8s节点IP地址组成，每个地址的端口对应于nginx入口控制器HTTP节点端口</li><li id="a661" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">NGINX入口控制器作为NodePort类型的服务安装在k8s集群中</li><li id="2b9b" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">基于NFS的自定义k8s存储类</li><li id="007a" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">舵图安装时启用入口</li></ul><p id="8cb2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu"> Kubeadm设置</strong></p><p id="fc13" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我首先提供了3个运行Ubuntu 20.04的EC2实例，一个作为k8s主节点，另外两个作为k8s工作节点。然后，我在所有3个实例上运行以下脚本。它设置一些与网络相关的系统变量，安装containerd等先决条件(我想避免Docker，因为Kubernetes放弃了对Docker的支持)，然后安装kubeadm、kubelet和kubectl，将这三个都固定到版本1.19.7(如果没有指定版本，将安装最新的k8s 1.20，这有点太新，一些工具仍然不太支持):</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="330f" class="mb mc it lx b gy md me l mf mg">cat &lt;&lt;EOF | sudo tee /etc/modules-load.d/containerd.conf</span><span id="a091" class="mb mc it lx b gy mh me l mf mg">overlay</span><span id="1e10" class="mb mc it lx b gy mh me l mf mg">br_netfilter</span><span id="4525" class="mb mc it lx b gy mh me l mf mg">EOF</span><span id="d7fa" class="mb mc it lx b gy mh me l mf mg">sudo modprobe overlay</span><span id="c750" class="mb mc it lx b gy mh me l mf mg">sudo modprobe br_netfilter</span><span id="9a43" class="mb mc it lx b gy mh me l mf mg">cat &lt;&lt;EOF | sudo tee /etc/sysctl.d/99-kubernetes-cri.conf</span><span id="f4de" class="mb mc it lx b gy mh me l mf mg">net.bridge.bridge-nf-call-iptables  = 1</span><span id="7da0" class="mb mc it lx b gy mh me l mf mg">net.ipv4.ip_forward                 = 1</span><span id="df4c" class="mb mc it lx b gy mh me l mf mg">net.bridge.bridge-nf-call-ip6tables = 1</span><span id="d161" class="mb mc it lx b gy mh me l mf mg">EOF</span><span id="bc8b" class="mb mc it lx b gy mh me l mf mg">sudo sysctl --system</span><span id="b2e0" class="mb mc it lx b gy mh me l mf mg">sudo apt-get update &amp;&amp; sudo apt-get install -y containerd</span><span id="9246" class="mb mc it lx b gy mh me l mf mg">sudo mkdir -p /etc/containerd</span><span id="eec5" class="mb mc it lx b gy mh me l mf mg">sudo containerd config default | sudo tee /etc/containerd/config.toml</span><span id="3b75" class="mb mc it lx b gy mh me l mf mg">sudo systemctl restart containerd</span><span id="62c3" class="mb mc it lx b gy mh me l mf mg">sudo apt-get update &amp;&amp; sudo apt-get install -y apt-transport-https curl</span><span id="f171" class="mb mc it lx b gy mh me l mf mg">curl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg | sudo apt-key add -</span><span id="df38" class="mb mc it lx b gy mh me l mf mg">cat &lt;&lt;EOF | sudo tee /etc/apt/sources.list.d/kubernetes.list</span><span id="1eda" class="mb mc it lx b gy mh me l mf mg">deb https://apt.kubernetes.io/ kubernetes-xenial main</span><span id="d186" class="mb mc it lx b gy mh me l mf mg">EOF</span><span id="abef" class="mb mc it lx b gy mh me l mf mg">sudo apt-get update</span><span id="fe4b" class="mb mc it lx b gy mh me l mf mg">sudo apt-get install -y kubelet=1.19.7-00 kubeadm=1.19.7-00 kubectl=1.19.7-00</span><span id="21bb" class="mb mc it lx b gy mh me l mf mg">sudo apt-mark hold kubelet kubeadm kubectl</span></pre><p id="38f4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在主节点上，我运行:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="9bb8" class="mb mc it lx b gy md me l mf mg"># kubeadm init</span></pre><p id="af7c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">并写下了我将需要在工作节点上运行的<code class="fe mi mj mk lx b">kubeadm join</code>命令。在加入工作节点之前，我还在主节点上安装了<a class="ae kf" href="https://docs.projectcalico.org/getting-started/kubernetes/self-managed-onprem/onpremises" rel="noopener ugc nofollow" target="_blank"> Calico </a>网络覆盖:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="4ea1" class="mb mc it lx b gy md me l mf mg"># export KUBECONFIG=/etc/kubernetes/admin.conf<br/># curl https://docs.projectcalico.org/manifests/calico.yaml -O<br/># kubectl apply -f calico.yaml</span></pre><p id="ba3f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我还取消了主节点，这样我就可以在其上运行常规的pod:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="4e76" class="mb mc it lx b gy md me l mf mg"># kubectl taint nodes --all node-role.kubernetes.io/master-</span></pre><p id="7bba" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此时，我已经准备好将工作节点连接到主节点。我在每个worker节点上运行了一个类似于下面的命令(这个命令是从主节点上的<em class="ml"> kubeadm init </em>输出粘贴过来的):</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="2b2e" class="mb mc it lx b gy md me l mf mg"># kubeadm join MASTER_NODE_IP_ADDRESS:6443 --token TOKEN --discovery-token-ca-cert-hash sha256:CA-CERT-HASH</span></pre><p id="d031" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我将文件<code class="fe mi mj mk lx b">/etc/kubernetes/admin.conf</code>从主节点传输到我的客户端笔记本电脑，并为其设置KUBECONFIG变量。然后，我能够对Kubeadm集群运行<code class="fe mi mj mk lx b">kubectl</code>命令。</p><p id="dfd8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu"> NGINX入口控制器设置</strong></p><p id="4b1a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我在本地机器上下载了最新的<a class="ae kf" href="https://kubernetes.github.io/ingress-nginx/deploy/baremetal/" rel="noopener ugc nofollow" target="_blank"> NGINX入口控制器</a> k8s部署清单:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="2c0a" class="mb mc it lx b gy md me l mf mg">$ wget https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v0.43.0/deploy/static/provider/baremetal/deploy.yaml</span></pre><p id="658b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我创建了一个名为<code class="fe mi mj mk lx b">ingress-nginx</code>的k8s名称空间</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="e8f5" class="mb mc it lx b gy md me l mf mg">$ kubectl create ns ingress-nginx</span></pre><p id="268e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我编辑了<code class="fe mi mj mk lx b">deploy.yaml</code>文件并将<code class="fe mi mj mk lx b">service</code>类型指定为<code class="fe mi mj mk lx b">NodePort</code>，然后在<code class="fe mi mj mk lx b">ingress-nginx</code>名称空间中应用清单:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="5ad5" class="mb mc it lx b gy md me l mf mg">$ kubectl apply -f deploy.yaml</span></pre><p id="47e1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果部署成功，您应该会看到类型为<code class="fe mi mj mk lx b">NodePort</code>的<code class="fe mi mj mk lx b">ingress-nginx-controller</code>服务:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="5863" class="mb mc it lx b gy md me l mf mg">$ kubectl get services -n ingress-nginx</span><span id="f355" class="mb mc it lx b gy mh me l mf mg">NAME                                 TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)                      AGE</span><span id="ae06" class="mb mc it lx b gy mh me l mf mg">ingress-nginx-controller             NodePort    10.104.246.104   &lt;none&gt;        80:32012/TCP,443:30572/TCP   52m</span><span id="ed22" class="mb mc it lx b gy mh me l mf mg">ingress-nginx-controller-admission   ClusterIP   10.101.12.34     &lt;none&gt;        443/TCP                      52m</span></pre><p id="af5b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里的大问题是如何进一步将入口控制器暴露给外界。如果我们要使用云服务，如EKS、AKS或GKE，很容易声明NGINX入口控制器服务属于<code class="fe mi mj mk lx b">LoadBalancer</code>类型，然后依靠云提供商为其创建本地负载平衡器。在裸机场景中，我们需要另一种解决方案。</p><p id="4502" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一个出现在<a class="ae kf" href="https://kubernetes.github.io/ingress-nginx/deploy/baremetal/#a-pure-software-solution-metallb" rel="noopener ugc nofollow" target="_blank"> NGINX入口控制器文档</a>中的解决方案是使用<a class="ae kf" href="https://metallb.universe.tf/" rel="noopener ugc nofollow" target="_blank"> MetalLB </a>。但是，MetalLB有自己的要求，这些要求依赖于AWS中不容易提供的操作系统和网络功能。我试着在EC2实例上运行的Kubeadm集群中安装它，但遇到了错误。事实上，MetalLB的<a class="ae kf" href="https://metallb.universe.tf/installation/clouds/" rel="noopener ugc nofollow" target="_blank">云兼容性</a>矩阵建议在AWS环境中使用EKS。如果我需要在纯裸机本地环境中运行Kubernetes，并且能够控制我使用的操作系统和网络，我会尝试使用MetalLB。</p><p id="a21d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以继续在端点中使用NodePort值，这些端点由通过NGINX入口控制器创建的入口对象公开(在上面我的服务片段中，这些端口对于http流量是32012，对于https流量是30572)。这相当难看，所以我找到的解决方案是在k8s集群前面安装HAProxy(在NGINX ingress控制器文档中称为"<a class="ae kf" href="https://kubernetes.github.io/ingress-nginx/deploy/baremetal/#using-a-self-provisioned-edge" rel="noopener ugc nofollow" target="_blank">自配置边缘</a>"场景)，并使用端口32012将后端映射到三个k8s节点。细节继续往下。</p><p id="e488" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">总部位于NFS的Kubernetes存储类设置</strong></p><p id="9bfa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在云环境中，我们认为理所当然的另一件事是云提供商在Kubernetes请求时自动创建的永久卷。在AWS中，默认情况下，这些卷是EBS卷。在裸机环境中，我们需要创建特定的存储类别来处理这种自动配置。我发现的一个解决方案是在我的k8s集群中使用<a class="ae kf" href="https://github.com/kubernetes-sigs/nfs-subdir-external-provisioner" rel="noopener ugc nofollow" target="_blank"> NFS客户端供应器</a>，并将其配置为自动创建通过我设置的NFS服务器提供服务的NFS卷。</p><p id="1a7b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了简单起见，我将k8s主节点配置为NFS服务器。</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="15b3" class="mb mc it lx b gy md me l mf mg"># apt install -y nfs-kernel-server</span></pre><p id="41aa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我在<code class="fe mi mj mk lx b">/etc/exports</code>文件中声明了一个名为<code class="fe mi mj mk lx b">nfs-export</code>的卷，并通过运行<code class="fe mi mj mk lx b">exportfs -a</code>将其导出:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="25cd" class="mb mc it lx b gy md me l mf mg"># cat /etc/exports<br/>/nfs-export               10.0.0.0/8(rw,sync,no_root_squash,no_subtree_check)</span><span id="72f7" class="mb mc it lx b gy mh me l mf mg"># exportfs -a</span><span id="f0bc" class="mb mc it lx b gy mh me l mf mg"># exportfs</span><span id="4e4f" class="mb mc it lx b gy mh me l mf mg">/nfs-export    10.0.0.0/8</span></pre><p id="32d0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我还必须在k8s工作节点上安装NFS客户端包:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="76cc" class="mb mc it lx b gy md me l mf mg"># apt install -y nfs-common</span></pre><p id="2cda" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我克隆了<code class="fe mi mj mk lx b">nfs-subdir-external-provisioner</code> Git repo，其中包含NFS客户端供应器的helm图表:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="ddd9" class="mb mc it lx b gy md me l mf mg">$ git clone https://github.com/kubernetes-sigs/nfs-subdir-external-provisioner.git</span></pre><p id="f1f2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我编辑了文件<em class="ml">nfs-subdir-external-provisioner/deploy/helm/values . YAML</em>，指定了NFS服务器IP和导出路径，以及新存储类的名称<code class="fe mi mj mk lx b">nfs-client</code>:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="9353" class="mb mc it lx b gy md me l mf mg">nfs:</span><span id="e4e8" class="mb mc it lx b gy mh me l mf mg">  server: IP_OF_MASTER_NODE</span><span id="a9e1" class="mb mc it lx b gy mh me l mf mg">  path: /nfs-export</span><span id="1b5d" class="mb mc it lx b gy mh me l mf mg">storageClass:</span><span id="406b" class="mb mc it lx b gy mh me l mf mg">  create: true</span><span id="e2c9" class="mb mc it lx b gy mh me l mf mg">  name: nfs-client</span></pre><p id="3a7b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我用<a class="ae kf" href="https://helm.sh/docs/intro/install/" rel="noopener ugc nofollow" target="_blank"> helm v3 CLI </a>安装了helm图表:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="0675" class="mb mc it lx b gy md me l mf mg">$ helm install nfs-subdir-external-provisioner \</span><span id="cbed" class="mb mc it lx b gy mh me l mf mg">--namespace default \</span><span id="013b" class="mb mc it lx b gy mh me l mf mg">./nfs-subdir-external-provisioner/deploy/helm</span></pre><p id="45ec" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此时，我能够看到新的<code class="fe mi mj mk lx b">nfs-client</code>存储类:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="08e2" class="mb mc it lx b gy md me l mf mg">$ kubectl get storageclass</span><span id="8cb5" class="mb mc it lx b gy mh me l mf mg">NAME         PROVISIONER                            RECLAIMPOLICY   VOLUMEBINDINGMODE   ALLOWVOLUMEEXPANSION   AGE</span><span id="9b16" class="mb mc it lx b gy mh me l mf mg">nfs-client   cluster.local/nfs-client-provisioner   Delete          Immediate           true                   34s</span></pre><p id="2177" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要使用这个存储类，需要在k8s集群中安装的舵图的<code class="fe mi mj mk lx b">values.yaml</code>文件中指定它的名称。大多数图表都有一个<code class="fe mi mj mk lx b">persistence</code>部分，其中可以指定<code class="fe mi mj mk lx b">storageClass</code>的名称(在本例中为<code class="fe mi mj mk lx b">nfs-client</code>)。</p><p id="a447" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">入口启用的舵图设置</strong></p><p id="c2fc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我将给出一个非常简单的安装<a class="ae kf" href="https://www.drone.io/" rel="noopener ugc nofollow" target="_blank">无人机</a> CI/CD工具舵图的例子。</p><p id="6057" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我从官方无人机报告中克隆了无人机舵图:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="c4ca" class="mb mc it lx b gy md me l mf mg">$ git clone <a class="ae kf" href="https://github.com/drone/charts" rel="noopener ugc nofollow" target="_blank">https://github.com/drone/charts</a> drone-charts</span></pre><p id="4f5f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我编辑了<code class="fe mi mj mk lx b">drone-charts/charts/drone/values.yaml</code>并设定:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="0e73" class="mb mc it lx b gy md me l mf mg">service:</span><span id="4e6e" class="mb mc it lx b gy mh me l mf mg">  type: NodePort</span><span id="7e27" class="mb mc it lx b gy mh me l mf mg">ingress:</span><span id="7774" class="mb mc it lx b gy mh me l mf mg">  enabled: true</span><span id="78c3" class="mb mc it lx b gy mh me l mf mg">  annotations:</span><span id="ab43" class="mb mc it lx b gy mh me l mf mg">    kubernetes.io/ingress.class: nginx</span><span id="2589" class="mb mc it lx b gy mh me l mf mg">  hosts:</span><span id="5f2e" class="mb mc it lx b gy mh me l mf mg">  - host: drone.mydomain.com</span><span id="fb81" class="mb mc it lx b gy mh me l mf mg">    paths:</span><span id="9384" class="mb mc it lx b gy mh me l mf mg">      - "/"</span><span id="3b0d" class="mb mc it lx b gy mh me l mf mg">persistentVolume:</span><span id="64cd" class="mb mc it lx b gy mh me l mf mg">  storageClass: nfs-client</span><span id="4df9" class="mb mc it lx b gy mh me l mf mg">env:</span><span id="a04c" class="mb mc it lx b gy mh me l mf mg">  DRONE_SERVER_HOST: "drone.mydomain.com"</span><span id="f358" class="mb mc it lx b gy mh me l mf mg">  DRONE_SERVER_PROTO: https</span></pre><p id="fb22" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">服务类型需要是<code class="fe mi mj mk lx b">NodePort</code>，以便NGINX入口控制器可以正确地创建<code class="fe mi mj mk lx b">Ingress</code>对象。我没有为舵图设置SSL/TLS，但我仍然将外部URL指定为<a class="ae kf" href="https://drone.mydomain.com" rel="noopener ugc nofollow" target="_blank">https://drone.mydomain.com</a>，因为它将由HAProxy处理。</p><p id="e4d4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我创建了一个<code class="fe mi mj mk lx b">drone</code>名称空间，并在其中安装了无人机图表:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="613c" class="mb mc it lx b gy md me l mf mg">$ kubectl create namespace drone<br/>$ helm install drone -n drone ./<!-- -->drone-charts/charts/drone</span></pre><p id="71ec" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果一切顺利，您现在应该在<code class="fe mi mj mk lx b">drone</code>名称空间中看到一个<code class="fe mi mj mk lx b">Ingress</code>对象:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="89b1" class="mb mc it lx b gy md me l mf mg">$ kubectl get ingress -ndrone</span><span id="ae81" class="mb mc it lx b gy mh me l mf mg">NAME    CLASS    HOSTS               ADDRESS        PORTS   AGE</span><span id="4d97" class="mb mc it lx b gy mh me l mf mg">drone   &lt;none&gt;   drone.mydomain.com   NODE-IP-ADDRESS  80      61s</span></pre><p id="a078" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mi mj mk lx b">ADDRESS</code>字段将包含k8s节点之一的IP地址。<code class="fe mi mj mk lx b">drone</code>服务在端口80上运行，但是NGINX入口控制器会在<code class="fe mi mj mk lx b">NodePort</code> 32012上暴露它。</p><p id="7262" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu"> HAProxy负载平衡器设置</strong></p><p id="79c6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">本例中剩下要做的就是在NGINX入口控制器前面设置HAProxy作为边缘负载平衡器。我还获得了一个用于<code class="fe mi mj mk lx b">*.mydomain.com</code>的SSL证书，并将证书文件、CA包和私钥(按照这个顺序)组合到一个名为<code class="fe mi mj mk lx b">/etc/haproxy/haproxy-ssl-cert.pem</code>的PEM文件中，然后我在HAProxy配置文件中指定了这个文件。</p><p id="915e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我提供了一个运行Ubuntu 20.04的EC2实例，并通过以下方式安装了HAProxy:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="fde5" class="mb mc it lx b gy md me l mf mg">$ sudo apt install -y haproxy</span><span id="c237" class="mb mc it lx b gy mh me l mf mg">$ haproxy -v</span><span id="2e0a" class="mb mc it lx b gy mh me l mf mg">HA-Proxy version 2.0.13-2ubuntu0.1 2020/09/08 - https://haproxy.org/</span></pre><p id="42e8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我编辑了<code class="fe mi mj mk lx b">/etc/haproxy/haproxy.cfg</code>并在默认情况下已经包含的<code class="fe mi mj mk lx b">global</code>和<code class="fe mi mj mk lx b">default</code>部分下添加了以下行:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="ad8e" class="mb mc it lx b gy md me l mf mg">frontend front_nginx_ingress_controller</span><span id="f024" class="mb mc it lx b gy mh me l mf mg">  bind LOCAL-IP-OF-HAPROXY-EC2-INSTANCE:80</span><span id="18b4" class="mb mc it lx b gy mh me l mf mg">  bind LOCAL-IP-OF-HAPROXY-EC2-INSTANCE:443 ssl crt /etc/haproxy/haproxy-ssl-cert.pem</span><span id="c127" class="mb mc it lx b gy mh me l mf mg">  http-request redirect scheme https unless { ssl_fc }</span><span id="0b76" class="mb mc it lx b gy mh me l mf mg">  default_backend nginx_ingress_controller_service</span><span id="47ee" class="mb mc it lx b gy mh me l mf mg">backend nginx_ingress_controller_service</span><span id="6493" class="mb mc it lx b gy mh me l mf mg">  balance roundrobin</span><span id="df37" class="mb mc it lx b gy mh me l mf mg">  server k8s-node1 IP-OF-K8S-NODE1:32012 check port 32012</span><span id="64af" class="mb mc it lx b gy mh me l mf mg">  server k8s-node2 IP-OF-K8S-NODE2:32012 check port 32012</span><span id="f9c1" class="mb mc it lx b gy mh me l mf mg">  server k8s-node3 IP-OF-K8S-NODE3:32012 check port 32012</span></pre><p id="4688" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的行告诉HAProxy使用我提到的证书进行SSL/TLS终止，将传入的http流量重定向到https，并使用循环算法在3个k8s节点的IP地址之间进行负载平衡，使用<code class="fe mi mj mk lx b">32012</code>作为端口号，这与NGINX入口控制器公开的http <code class="fe mi mj mk lx b">NodePort</code>的值完全相同(您还需要修改k8s节点的EC2安全组，以允许该端口上来自HAProxy EC2实例的传入流量)。</p><p id="cf5b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我重启了haproxy服务:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="59e3" class="mb mc it lx b gy md me l mf mg">$ sudo service haproxy restart</span></pre><p id="5a81" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此时，我能够在浏览器中点击https://drone.mydomain.com的<a class="ae kf" href="https://drone.mydomain.com" rel="noopener ugc nofollow" target="_blank">并看到正确的证书和正确的无人机登录页面。流量流向为:浏览器- &gt; HAProxy前端- &gt; k8s节点- &gt; nginx入口控制器- &gt;入口对象- &gt;运行在端口80上的无人机服务- &gt;无人机pod</a></p><p id="2ba2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这就是了。一种端到端设置，用于公开运行在具有外部DNS名称和SSL/TLS的裸机节点上的kubernetes服务。像往常一样，HAProxy拯救了这一天(它从2008年开始拯救我的培根！).</p><p id="bed0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">注意</strong>:为了更加安全，您可以安装启用了TLS的helm charts(即使使用自签名证书)，然后配置HAProxy使用nginx控制器https <code class="fe mi mj mk lx b">NodePort</code>值向后端k8s节点IP地址发送流量，在我的示例中该值为30572。</p><p id="6fe9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">更新</strong>:我在kubeadm k8s集群中部署的一些服务实际上需要https流量，所以我继续重新配置HAProxy，将https流量发送到后端节点，指定<code class="fe mi mj mk lx b">verify none</code>，因为我不需要在目标k8s节点上验证SSL证书，在这种情况下，它是一个自签名的NGINX入口控制器证书。以下是<code class="fe mi mj mk lx b">haproxy.cfg</code>中更新后的<code class="fe mi mj mk lx b">backend</code>部分:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="a135" class="mb mc it lx b gy md me l mf mg">backend nginx_ingress_controller_service</span><span id="c784" class="mb mc it lx b gy mh me l mf mg">  balance roundrobin</span><span id="db73" class="mb mc it lx b gy mh me l mf mg">  server k8s-node1 IP-OF-K8S-NODE1:30572 ssl check port 30572 verify none</span><span id="f5ec" class="mb mc it lx b gy mh me l mf mg">  server k8s-node2 IP-OF-K8S-NODE2:30572 ssl check port 30572 verify none</span><span id="adc8" class="mb mc it lx b gy mh me l mf mg">  server k8s-node3 IP-OF-K8S-NODE3:30572 ssl check port 30572 verify none</span></pre></div></div>    
</body>
</html>