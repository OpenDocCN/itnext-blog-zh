<html>
<head>
<title>Checking out Angular’s CDK portals</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">查看Angular的CDK门户网站</h1>
<blockquote>原文：<a href="https://itnext.io/checking-out-angulars-cdk-portals-d34bfd8a5647?source=collection_archive---------1-----------------------#2019-05-29">https://itnext.io/checking-out-angulars-cdk-portals-d34bfd8a5647?source=collection_archive---------1-----------------------#2019-05-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/829935138be9bc1d343dd47d9e3180ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T4Q9pFy-cTZzKPbZ5nuhZw.jpeg"/></div></div></figure><p id="95f6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">作为前端开发人员，我们有一大套工具来用不同的方法创建UI组件(目的是在考虑性能、可读性等的基础上选择最好的一个)..)</p><p id="7f5b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当使用框架开发时(至于2019年，我们仍然使用框架，目前我更喜欢Angular..)我们有一套抽象概念，我们应该以某种方式使用这些抽象概念，以便在不滥用框架的情况下最大限度地利用框架——换句话说，遵循它的“最佳实践”。</p><p id="b9a6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在Angular中，当你想在某个地方动态地渲染一个组件或模板时，你有几种方法可以做到:</p><ul class=""><li id="42a2" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">以编程方式使用ComponentFactoryResolver服务:</li></ul><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="7247" class="lo lp iq lk b gy lq lr l ls lt"><strong class="lk ir">const factory </strong>= <strong class="lk ir">this</strong>.resolver.resolveComponentFactory(NewAwesomComponent);<br/><strong class="lk ir">this</strong>.<strong class="lk ir">componentRef </strong>= <strong class="lk ir">this</strong>.viewContainerRef.createComponent(factory);</span></pre><ul class=""><li id="9eb7" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">通过使用<strong class="ka ir">* ngcomponentfoutlet</strong>或<strong class="ka ir">* ngtemplatefoutlet</strong>结构指令</li><li id="cd13" class="kw kx iq ka b kb lu kf lv kj lw kn lx kr ly kv lb lc ld le bi translated">**通过使用<strong class="ka ir"> &lt; ng-content &gt; </strong>将内容投影到另一个主机(不完全是动态的，但它将在另一个主机中呈现，而不是在它注册的地方，所以请注意，它不会咬你)。</li></ul><p id="bf43" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">每当我使用* <strong class="ka ir"> ngComponentOutlet，</strong>我不得不将我想要动态呈现的组件导入托管组件的事实感觉有点不对，托管组件意识到它必须呈现的动态组件，因此它们变成了耦合。</p><h1 id="9e26" class="lz lp iq bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">救援门户:</h1><p id="d18d" class="pw-post-body-paragraph jy jz iq ka b kb mw kd ke kf mx kh ki kj my kl km kn mz kp kq kr na kt ku kv ij bi translated">如果我只希望我的主机组件有一个占位符/槽，我可以在其中呈现另一个组件，而不需要从主机模板显式导入和引用它，该怎么办？</p><blockquote class="nb nc nd"><p id="bb12" class="jy jz ne ka b kb kc kd ke kf kg kh ki nf kk kl km ng ko kp kq nh ks kt ku kv ij bi translated">“利用平台”(lol)</p></blockquote><p id="3910" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Angular的组件开发工具包——目前，我看不出有任何理由不在我的项目中使用它，Angular的人在维护它方面做得很好，它很容易使用，很快提供了一组内置于我欣赏的<a class="ae ni" href="https://github.com/angular/components/blob/master/CODING_STANDARDS.md" rel="noopener ugc nofollow" target="_blank">编码标准</a>中的UI组件。</p><p id="371d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当传送门出现的时候，我在哪里？闭上眼睛，因为使用ComponentFactoryResolver是如此有趣…</p><p id="2fc3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">门户的官方定义是:</p><blockquote class="nb nc nd"><p id="a772" class="jy jz ne ka b kb kc kd ke kf kg kh ki nf kk kl km ng ko kp kq nh ks kt ku kv ij bi translated">一个<code class="fe nj nk nl lk b">Portal</code>是一个UI，它可以被动态地呈现到页面上的一个空位上。</p></blockquote><p id="5f4c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">(类似于WC <a class="ae ni" href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/slot" rel="noopener ugc nofollow" target="_blank"> slot </a>元素的概念，只是可移植视图不是新的DOM树)。</p><p id="a569" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它非常简单，让我们看看它的使用情况:</p><figure class="lf lg lh li gt jr"><div class="bz fp l di"><div class="nm nn l"/></div></figure><h1 id="1887" class="lz lp iq bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">示例说明:</h1><p id="d1ca" class="pw-post-body-paragraph jy jz iq ka b kb mw kd ke kf mx kh ki kj my kl km kn mz kp kq kr na kt ku kv ij bi translated">我创建了一个简单的标签栏菜单，在菜单下放置了一个<foo>组件。当用户选择一个选项卡时，其相关的视图部分组件将出现在foo组件内<strong class="ka ir">:</strong></foo></p><p id="6bea" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">应用程序</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="8e75" class="lo lp iq lk b gy lq lr l ls lt">&lt;app-nav-menu *ngFor=<strong class="lk ir">"let section of sections"</strong>&gt;<br/>   &lt;button (<em class="ne">click</em>)=<strong class="lk ir">"setSelected(section)"</strong>&gt; {{section}}&lt;/button&gt;<br/>&lt;/app-nav-menu&gt;<br/>&lt;hr&gt;<br/>&lt;app-foo&gt;&lt;/app-foo&gt;</span></pre><p id="741c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">foo.html</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="08dd" class="lo lp iq lk b gy lq lr l ls lt">&lt;div <strong class="lk ir">class</strong>=<strong class="lk ir">"app-foo"</strong>&gt;<br/>   &lt;p&gt; Im foo and I like <em class="ne">it </em>&lt;/p&gt;<br/>   &lt;div id=<strong class="lk ir">"nav-view-slot"</strong>&gt;&lt;/div&gt;<br/>&lt;/div&gt;</span></pre><p id="18e1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">门户API公开了一个<a class="ae ni" href="https://material.angular.io/cdk/portal/api#CdkPortal" rel="noopener ugc nofollow" target="_blank"> CdkPortal </a>指令和一个<a class="ae ni" href="https://material.angular.io/cdk/portal/api#DomPortalOutlet" rel="noopener ugc nofollow" target="_blank"> DomPortalOutlet </a>类</p><blockquote class="no"><p id="52d2" class="np nq iq bd nr ns nt nu nv nw nx kv dk translated"><a class="ae ni" href="https://material.angular.io/cdk/portal/api#DomPortalOutlet" rel="noopener ugc nofollow" target="_blank"> DomPortalOutlet </a>:一个PortalOutlet，用于将门户附加到Angular应用程序上下文之外的任意DOM元素。</p><p id="f193" class="np nq iq bd nr ns nt nu nv nw nx kv dk translated"><a class="ae ni" href="https://material.angular.io/cdk/portal/api#CdkPortal" rel="noopener ugc nofollow" target="_blank">CDK portal</a>:a<code class="fe nj nk nl lk b">TemplatePortal</code>的指令版本。因为指令<em class="ny">是</em>一个TemplatePortal，指令实例本身可以附加到一个主机上，支持门户的声明性使用。</p></blockquote><p id="700d" class="pw-post-body-paragraph jy jz iq ka b kb nz kd ke kf oa kh ki kj ob kl km kn oc kp kq kr od kt ku kv ij bi translated">基于Nir Kaufman 在AngularNYC的一次演讲，我创建了下面的组件，他们的用法如下:(复制的比实际创建的多…)。</p><figure class="lf lg lh li gt jr"><div class="bz fp l di"><div class="og nn l"/></div></figure><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="8fd9" class="lo lp iq lk b gy lq lr l ls lt">&lt;ng-container *cdkPortal&gt;<br/>   &lt;ng-content&gt;&lt;/ng-content&gt;<br/>&lt;/ng-container&gt;</span></pre><p id="0c4b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这实际上是一个伟大的演讲！真的很有趣，我真的建议观看它，以更好地掌握门户网站的使用。</p><figure class="lf lg lh li gt jr"><div class="bz fp l di"><div class="oh nn l"/></div></figure></div></div>    
</body>
</html>