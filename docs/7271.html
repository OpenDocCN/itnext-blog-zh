<html>
<head>
<title>Application Architecture for Microservices: Sidecar Pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">微服务的应用架构:Sidecar模式</h1>
<blockquote>原文：<a href="https://itnext.io/application-architecture-for-microservices-sidecar-pattern-c5c0074e8f1d?source=collection_archive---------0-----------------------#2022-08-07">https://itnext.io/application-architecture-for-microservices-sidecar-pattern-c5c0074e8f1d?source=collection_archive---------0-----------------------#2022-08-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="f135" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的微服务应用架构应该是什么样的？</p><p id="ea03" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们一起来看看我们如何使用sidecar来解决跨领域的问题，例如授权、缓存、配置秘密管理和可观察性。</p></div><div class="ab cl kl km hu kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="ij ik il im in"><h1 id="623e" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">贯穿各领域的问题</h1><p id="b12d" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">让我们从解释横切关注点开始。</p><p id="ae1b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">应用程序的不同层需要应用程序业务代码之外的一些需求。</p><p id="e659" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如日志记录、配置、缓存、授权、可观察性…</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div class="gh gi lv"><img src="../Images/d25ed338a5276a32c6b505dc2909ee2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1136/format:webp/0*7oVHDbVUsuXW4d5K.png"/></div></figure><h1 id="d974" class="ks kt iq bd ku kv md kx ky kz me lb lc ld mf lf lg lh mg lj lk ll mh ln lo lp bi translated">传统发展</h1><p id="ba1d" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">传统的方法是在我们的开发服务中编码和使用所有这些工具。如果我们用同一种语言编写不同的服务，我们可以在服务之间共享这些代码，并在服务之间将它们用作包/库。</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/0473b9caa384da9cac7a4692bf7f779a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/0*aMesffqde8aXipbt.png"/></div></figure><p id="d29c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么什么是糟糕的情况呢？</p><p id="90d0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在用多种语言编写服务的环境中，这些需求必须用每种语言重新实现。</p><p id="39bc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">想象一下，你(或你的团队)用不同的语言一遍又一遍地编写相同的功能…</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/901eae993abb5d708f33c3703a21c9ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/0*XOEKmHiJCgI67gQv.png"/></div></figure><p id="6997" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这种情况下有没有解决方案，而不是写同样的代码？</p><p id="c79e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先想到的是为那些需求编写单独的API服务。</p><p id="f95b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么这是正确的解决方案吗？</p><p id="25b0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">能遇到什么问题？</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/38c47e79b8f8d6598bd4e53474d543a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/0*Spb2pO8QGl7Kp_dc.png"/></div></figure><p id="97c8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当消费者服务数量增加时，如何扩展这些共享服务？</p><p id="73a0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将应用程序代码移动到另一个通过网络访问的服务会导致应用程序的网络延迟。这会减慢我们的应用程序。</p><p id="159d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么，如果您不想用不同的语言重写相同的故事，或者面临网络延迟，您会怎么做呢？</p><p id="35da" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">答</strong>:我们会用边车模式。</p></div><div class="ab cl kl km hu kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="ij ik il im in"><h1 id="422e" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">边车模式</h1><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi mj"><img src="../Images/3258176b3dfec331e94b55a6f1d45164.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*jxKVw7WwXls3IDTv.png"/></div></div></figure><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/c0523639e2412e843d075060f079a5e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/0*vNpRaSq3ND-dueR1.png"/></div></figure><p id="363e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个边车是什么？</p><p id="ea1c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以在Kubernetes上运行多个容器。我们可以把运行在主应用程序容器旁边的容器称为sidecars。</p><p id="1639" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这些附加功能可以用一种语言开发，然后我们可以将它们“注入”到我们的应用程序中。我们用Go语言开发我们的sidecars，并将它们注入到微服务中。</p><p id="cbf2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个“<strong class="jp ir">注入</strong>操作是由Kubernetes基于一个名为<strong class="jp ir">的动态接纳Webhook </strong>的概念执行的。详情我会在文末留下源码链接。</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/0db4f6fb40263311e388be7dea304f02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/0*mnMhBUnNxYDwEDW3.png"/></div></figure><p id="4849" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当一个pod升级时，附加的边斗也会随之升级。</p><p id="fab4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，由于专门为跨边柜共享的pod创建的网络接口，网络延迟可以忽略，因为它是在本地主机上。</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/e9a2663424bc0253875cfe0ecfba31ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/0*c1DVXnKzhsBAzDOu.png"/></div></figure><p id="8b21" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">用边车还能做什么？</p><ul class=""><li id="c527" class="mo mp iq jp b jq jr ju jv jy mq kc mr kg ms kk mt mu mv mw bi translated">Pod网络配置</li><li id="a571" class="mo mp iq jp b jq mx ju my jy mz kc na kg nb kk mt mu mv mw bi translated">Pod网络请求/响应可以被中断/操纵</li><li id="7302" class="mo mp iq jp b jq mx ju my jy mz kc na kg nb kk mt mu mv mw bi translated">可以制作服务网格</li><li id="c966" class="mo mp iq jp b jq mx ju my jy mz kc na kg nb kk mt mu mv mw bi translated">微服务运行时实现可以完成</li></ul><p id="de61" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，Istio服务网可以作为边车使用。pod的整个网络控制由作为侧车的传入istio-proxy接管，并且可以操纵传入和传出的请求/响应。</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi nc"><img src="../Images/7cc82f1f7c748cb2c80b35ca2e61c3e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*XgBA7Dw8KUFzeVs4.png"/></div></div></figure><p id="d757" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">可以写各种网络规则。当整个网络通过istio-proxy sidecar时，所有网络进程都有度量数据，我们可以可视化微服务内部服务调用。</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/b1e345c86b2737abeee06c00601688a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1388/format:webp/0*zjQL9s9aHfQ39ihB.png"/></div></figure><p id="17de" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我想在这里完成我的帖子。我们带您快速了解一下边车方法。下一篇文章再见。</p></div><div class="ab cl kl km hu kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="ij ik il im in"><h2 id="3dec" class="ne kt iq bd ku nf ng dn ky nh ni dp lc jy nj nk lg kc nl nm lk kg nn no lo np bi translated"><strong class="ak">资源</strong></h2><div class="nq nr gp gr ns nt"><a href="https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/" rel="noopener  ugc nofollow" target="_blank"><div class="nu ab fo"><div class="nv ab nw cl cj nx"><h2 class="bd ir gy z fp ny fr fs nz fu fw ip bi translated">动态接纳控制</h2><div class="oa l"><h3 class="bd b gy z fp ny fr fs nz fu fw dk translated">除了编译好的许可插件，许可插件可以被开发成扩展并作为webhooks运行…</h3></div><div class="ob l"><p class="bd b dl z fp ny fr fs nz fu fw dk translated">kubernetes.io</p></div></div><div class="oc l"><div class="od l oe of og oc oh mb nt"/></div></div></a></div><div class="nq nr gp gr ns nt"><a href="https://betterprogramming.pub/understanding-kubernetes-multi-container-pod-patterns-577f74690aee" rel="noopener  ugc nofollow" target="_blank"><div class="nu ab fo"><div class="nv ab nw cl cj nx"><h2 class="bd ir gy z fp ny fr fs nz fu fw ip bi translated">了解Kubernetes多容器Pod模式</h2><div class="oa l"><h3 class="bd b gy z fp ny fr fs nz fu fw dk translated">Sidecar、Ambassador和Adapter模式指南，并附有实践示例</h3></div><div class="ob l"><p class="bd b dl z fp ny fr fs nz fu fw dk translated">better编程. pub</p></div></div><div class="oc l"><div class="oi l oe of og oc oh mb nt"/></div></div></a></div><div class="nq nr gp gr ns nt"><a href="https://istio.io/" rel="noopener  ugc nofollow" target="_blank"><div class="nu ab fo"><div class="nv ab nw cl cj nx"><h2 class="bd ir gy z fp ny fr fs nz fu fw ip bi translated">伊斯迪奥</h2><div class="oa l"><h3 class="bd b gy z fp ny fr fs nz fu fw dk translated">一个可观察性、深度安全性和管理的服务网格，可加快部署周期。</h3></div><div class="ob l"><p class="bd b dl z fp ny fr fs nz fu fw dk translated">istio.io</p></div></div><div class="oc l"><div class="oj l oe of og oc oh mb nt"/></div></div></a></div></div><div class="ab cl kl km hu kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="ij ik il im in"><h2 id="7ac3" class="ne kt iq bd ku nf ng dn ky nh ni dp lc jy nj nk lg kc nl nm lk kg nn no lo np bi translated">让我们连接</h2><p id="6b05" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated"><a class="ae ok" href="https://twitter.com/mstrYoda_" rel="noopener ugc nofollow" target="_blank">推特</a><br/>T5】Github</p><p id="bb66" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">可以在Github上支持我:<a class="ae ok" href="https://github.com/sponsors/mstrYoda/" rel="noopener ugc nofollow" target="_blank">在Github上支持mstrYoda</a></p></div></div>    
</body>
</html>