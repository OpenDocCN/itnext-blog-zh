<html>
<head>
<title>On gRPC Load Balancing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">gRPC负载均衡研究</h1>
<blockquote>原文：<a href="https://itnext.io/on-grpc-load-balancing-683257c5b7b3?source=collection_archive---------1-----------------------#2019-02-21">https://itnext.io/on-grpc-load-balancing-683257c5b7b3?source=collection_archive---------1-----------------------#2019-02-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="8fe7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">继William在Kubernetes without Tears  上发表了关于<a class="ae ko" href="https://kubernetes.io/blog/2018/11/07/grpc-load-balancing-on-kubernetes-without-tears/" rel="noopener ugc nofollow" target="_blank"> <em class="kp"> gRPC负载均衡的帖子之后，我开始有兴趣了解实现gRPC负载均衡实际需要做多少工作。</em></a></p><p id="9d91" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这篇文章中，我想与你分享我所学到的关于使用<a class="ae ko" href="https://godoc.org/google.golang.org/grpc" rel="noopener ugc nofollow" target="_blank"> gRPC-Go </a> <code class="fe kq kr ks kt b"><a class="ae ko" href="https://godoc.org/google.golang.org/grpc/balancer" rel="noopener ugc nofollow" target="_blank">balancer</a></code>和<code class="fe kq kr ks kt b"><a class="ae ko" href="https://godoc.org/google.golang.org/grpc/resolver" rel="noopener ugc nofollow" target="_blank">resolver</a></code>包来实现简单的客户端循环负载均衡。然后，我将展示如何使用Linkerd 2自动对gRPC流量进行负载平衡，而无需更改任何应用程序代码或部署额外的负载平衡器。</p><p id="ced0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我已经在我的<a class="ae ko" href="https://github.com/ihcsim/routeguide" rel="noopener ugc nofollow" target="_blank"> GitHub repo </a>上发布了这篇文章中使用的代码。gRPC应用程序经过以下测试:</p><ul class=""><li id="16b1" class="ku kv it js b jt ju jx jy kb kw kf kx kj ky kn kz la lb lc bi translated">去1.11.5</li><li id="1b98" class="ku kv it js b jt ld jx le kb lf kf lg kj lh kn kz la lb lc bi translated">议定书3.6.1</li><li id="544f" class="ku kv it js b jt ld jx le kb lf kf lg kj lh kn kz la lb lc bi translated">gRPC 1.18</li></ul><h1 id="29c5" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">它是如何工作的</h1><p id="236e" class="pw-post-body-paragraph jq jr it js b jt mg jv jw jx mh jz ka kb mi kd ke kf mj kh ki kj mk kl km kn im bi translated">让我们探索gRPC客户端负载平衡工作所需的两个主要组件；<a class="ae ko" href="https://github.com/grpc/grpc/blob/master/doc/naming.md" rel="noopener ugc nofollow" target="_blank">名称解析器</a>和<a class="ae ko" href="https://github.com/grpc/grpc/blob/master/doc/load-balancing.md" rel="noopener ugc nofollow" target="_blank">负载平衡策略</a>。</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi ml"><img src="../Images/8158bac8fda9b25289939eaa08ef4a4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xgv7HwMIXeERfCWZ3lKweg.png"/></div></div></figure><h2 id="d01a" class="mx lj it bd lk my mz dn lo na nb dp ls kb nc nd lw kf ne nf ma kj ng nh me ni bi translated">名字解析</h2><p id="881a" class="pw-post-body-paragraph jq jr it js b jt mg jv jw jx mh jz ka kb mi kd ke kf mj kh ki kj mk kl km kn im bi translated">当gRPC客户机想要与gRPC服务器进行交互时，它首先尝试通过向解析器发出名称解析请求来解析服务器名称。解析器返回已解析的IP地址列表。每个IP地址都与一个指示器相关联，用于确定它是后端地址还是负载平衡器地址。此外，还会返回一个<a class="ae ko" href="https://github.com/grpc/grpc/blob/master/doc/service_config.md" rel="noopener ugc nofollow" target="_blank">服务配置</a>对象，其中包含有关使用哪个负载平衡策略的信息。</p><p id="1a7d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">默认情况下，gRPC使用<code class="fe kq kr ks kt b">dns</code>作为它的默认名称系统。</p><p id="4227" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">出于代码演示的目的，让我们使用<code class="fe kq kr ks kt b">manual</code>解析器。在客户端应用程序代码中，我们可以像这样创建和注册解析器:</p><pre class="mm mn mo mp gt nj kt nk nl aw nm bi"><span id="efe2" class="mx lj it kt b gy nn no l np nq">// create a manual.Resolver with a random scheme<br/>resolver, _ := manual.GenerateAndRegisterManualResolver()</span><span id="fde0" class="mx lj it kt b gy nr no l np nq">// define the initial list of addresses<br/>resolver.InitialAddrs([]resolver.Address{<br/>  resolver.Address{Addr:"10.0.0.10", Type: resolver.Backend},<br/>  resolver.Address{Addr:"10.0.0.11", Type: resolver.Backend},<br/>  resolver.Address{Addr:"10.0.0.12", Type: resolver.Backend},<br/>})</span><span id="1f6a" class="mx lj it kt b gy nr no l np nq">// set the default name resolution scheme to that of the resolver<br/>resolver.SetDefaultScheme(resolver.Scheme())</span></pre><ol class=""><li id="d787" class="ku kv it js b jt ju jx jy kb kw kf kx kj ky kn ns la lb lc bi translated"><code class="fe kq kr ks kt b">manual.GenerateAndRegisterManualResolver()</code>方法返回一个<code class="fe kq kr ks kt b">manual.Resolver</code>类型的解析器。这个解析器是用随机命名方案创建的。由于解析的IP地址是手动添加的(在步骤2中)，所以这个解析器的方案是什么并不重要。</li><li id="ffbc" class="ku kv it js b jt ld jx le kb lf kf lg kj lh kn ns la lb lc bi translated"><code class="fe kq kr ks kt b">manual.InitialAddrs()</code>方法允许我们注册一个用于命名解析的地址列表。</li><li id="e8da" class="ku kv it js b jt ld jx le kb lf kf lg kj lh kn ns la lb lc bi translated">最后，<code class="fe kq kr ks kt b">resolver.SetDefaultScheme()</code>方法用于将应用程序的默认命名解析方案设置为新解析器的方案。</li></ol><p id="e6b9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有了这个，每当客户端需要解析服务器名称时，解析器将总是返回这些(<strong class="js iu">并且只返回这些</strong>)注册的地址。</p><h2 id="44db" class="mx lj it bd lk my mz dn lo na nb dp ls kb nc nd lw kf ne nf ma kj ng nh me ni bi translated">负载平衡策略</h2><p id="f53e" class="pw-post-body-paragraph jq jr it js b jt mg jv jw jx mh jz ka kb mi kd ke kf mj kh ki kj mk kl km kn im bi translated">第二个组件是负载平衡策略。gRPC-Go库中的两个内置策略是<code class="fe kq kr ks kt b">roundrobin</code>和<code class="fe kq kr ks kt b">grpclb</code>策略。<code class="fe kq kr ks kt b">grpclb </code>策略通常与像<a class="ae ko" href="https://github.com/bsm/grpclb" rel="noopener ugc nofollow" target="_blank">这样的外部负载平衡器一起使用。还有一个<code class="fe kq kr ks kt b"><a class="ae ko" href="https://godoc.org/google.golang.org/grpc/balancer/base" rel="noopener ugc nofollow" target="_blank">base</a></code>策略，通常用于构建更复杂的拣选算法。</a></p><p id="d72e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于解析器返回的每个非负载平衡器地址，负载平衡策略创建一个到该地址的新子连接。然后，该策略返回一个选取器，该选取器为客户端提供一个接口，以检索用于进行RPC调用的子连接。</p><p id="0bd1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以下代码片段显示了如何通过将客户端循环负载平衡策略指定为<code class="fe kq kr ks kt b">grpc.DialOption</code>来启用它:</p><pre class="mm mn mo mp gt nj kt nk nl aw nm bi"><span id="c0db" class="mx lj it kt b gy nn no l np nq">opts := []grpc.DialOption{<br/>  grpc.WithBalancerName(roundrobin.Name)),<br/>  // ....<br/>}<br/>conn, err := grpc.Dial(serverAddr, opts...)</span></pre><h1 id="38f3" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">运行应用程序</h1><p id="1d72" class="pw-post-body-paragraph jq jr it js b jt mg jv jw jx mh jz ka kb mi kd ke kf mj kh ki kj mk kl km kn im bi translated">本例中使用的gRPC服务器和客户端应用程序基于<a class="ae ko" href="https://grpc.io/docs/tutorials/basic/go.html" rel="noopener ugc nofollow" target="_blank"> gRPC Basic - Go </a>页面上的<code class="fe kq kr ks kt b">routeguide</code>示例，并做了以下修改:</p><ul class=""><li id="1448" class="ku kv it js b jt ju jx jy kb kw kf kx kj ky kn kz la lb lc bi translated">服务器实现健康检查，并使用拦截器来模拟错误响应。</li><li id="f9b0" class="ku kv it js b jt ld jx le kb lf kf lg kj lh kn kz la lb lc bi translated">客户端可以在<code class="fe kq kr ks kt b">firehose</code>或<code class="fe kq kr ks kt b">repeat-N</code>模式下启动。<code class="fe kq kr ks kt b">firehose</code>模式导致客户端在一个无限循环中向所有4个API发出随机调用。<code class="fe kq kr ks kt b">repeat-N</code>模式更适合需要更多控制和可预测性的测试，通过向预先选择的API发出N个调用，然后终止。</li></ul><p id="fa95" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">可以使用<code class="fe kq kr ks kt b">make server</code>目标来启动服务器。</p><pre class="mm mn mo mp gt nj kt nk nl aw nm bi"><span id="1c64" class="mx lj it kt b gy nn no l np nq">$ make server <br/>go build -o ./cmd/server/server ./cmd/server/ <br/>./cmd/server/server -port=8080 -fault-percent=0.3 <br/>2019/02/20 20:08:49 [main] fault percentage: 30% <br/>2019/02/20 20:08:49 [main] hostname: orca:8080</span></pre><p id="9311" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通过运行以下命令，在不进行负载平衡的情况下启动客户端:</p><pre class="mm mn mo mp gt nj kt nk nl aw nm bi"><span id="dda2" class="mx lj it kt b gy nn no l np nq">$ ENABLE_LOAD_BALANCING=false make client<br/>go build -o ./cmd/client/client ./cmd/client/ <br/>./cmd/client/client \ <br/>        -server=:8080 \ <br/>        -timeout=20s \ <br/>        -mode=REPEATN \ <br/>        -api=GetFeature \ <br/>        -n=15 \ <br/>        -enable-load-balancing=false \ <br/>        -server-ipv4=127.0.0.1:8080,127.0.0.1:8081,127.0.0.1:8082<br/>2019/02/18 20:35:35 [main] connecting to server at :8080 <br/>2019/02/18 20:35:35 [main] running in REPEATN mode <br/>2019/02/18 20:35:35 [main] calling getfeature 15 times <br/>2019/02/18 20:35:35 [GetFeature] (req) latitude:402133926 longitude:-743613249 <br/>2019/02/18 20:35:35 [GetFeature] (resp) (<strong class="kt iu">server=orca:8080</strong>) location:&lt;latitude:402133926 longitude:-743613249 &gt; <br/>2019/02/18 20:35:38 [GetFeature] (req) latitude:411349992 longitude:-743694161 <br/>2019/02/18 20:35:38 [GetFeature] (resp) (<strong class="kt iu">server=orca:8080</strong>) location:&lt;latitude:411349992 longitude:-743694161 &gt; <br/>2019/02/18 20:35:41 [GetFeature] (req) latitude:416855156 longitude:-744420597 <br/>...</span></pre><p id="bda1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">默认情况下，客户端被配置为调用<code class="fe kq kr ks kt b">GetFeature</code> API 15次。从客户端日志中注意到，所有响应都来自<code class="fe kq kr ks kt b">orca:8080</code>。</p><p id="b6b3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在在端口8081和8082上再启动两个服务器实例:</p><pre class="mm mn mo mp gt nj kt nk nl aw nm bi"><span id="784b" class="mx lj it kt b gy nn no l np nq">$ SERVER_PORT=8081 make server &amp;<br/>$ SERVER_PORT=8082 make server &amp;</span></pre><p id="e010" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在启用负载平衡的情况下重新启动客户端:</p><pre class="mm mn mo mp gt nj kt nk nl aw nm bi"><span id="8e74" class="mx lj it kt b gy nn no l np nq">$ make client<br/>go build -o ./cmd/client/client ./cmd/client/ <br/>./cmd/client/client \ <br/>        -server=:8080 \ <br/>        -timeout=20s \ <br/>        -mode=REPEATN \ <br/>        -api=GetFeature \ <br/>        -n=15 \ <br/>        -enable-load-balancing=true \ <br/>        -server-ipv4=127.0.0.1:8080,127.0.0.1:8081,127.0.0.1:8082<br/>2019/02/18 20:58:07 [main] load balancing scheme: round_robin <br/>2019/02/18 20:58:07 [main] resolver type: manual <br/>2019/02/18 20:58:07 [main] connecting to server at :8080 <br/>2019/02/18 20:58:07 [main] running in REPEATN mode <br/>2019/02/18 20:58:07 [main] calling getfeature 15 times <br/>2019/02/18 20:58:07 [GetFeature] (req) latitude:402133926 longitude:-743613249 <br/>2019/02/18 20:58:07 [GetFeature] (resp) (<strong class="kt iu">server=orca:8081</strong>) location:&lt;latitude:402133926 longitude:-743613249 &gt; <br/>2019/02/18 20:58:10 [GetFeature] (req) latitude:411349992 longitude:-743694161 <br/>2019/02/18 20:58:10 [GetFeature] (resp) (<strong class="kt iu">server=orca:8082</strong>) location:&lt;latitude:411349992 longitude:-743694161 &gt; <br/>2019/02/18 20:58:13 [GetFeature] (req) latitude:416855156 longitude:-744420597 <br/>2019/02/18 20:58:13 [GetFeature] (resp) (<strong class="kt iu">server=orca:8080</strong>) name:"103-271 Tempaloni Road, Ellenville, NY 12428, USA" location:&lt;latitude:416855156 longitude:-744420597 &gt; <br/>2019/02/18 20:58:16 [GetFeature] (req) latitude:409146138 longitude:-746188906 <br/>2019/02/18 20:58:16 [GetFeature] (resp) (<strong class="kt iu">server=orca:8081</strong>) name:"Berkshire Valley Management Area Trail, Jefferson, NJ, USA" location:&lt;latitude:409146138 longitude:-746188906 &gt; <br/>...</span></pre><p id="c74f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以看到响应是从<code class="fe kq kr ks kt b">orca:8080</code>、<code class="fe kq kr ks kt b">orca:8081</code>和<code class="fe kq kr ks kt b">orca:8082</code>返回的。</p><p id="bbda" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">太好了！看起来我们的客户端循环负载平衡在本地主机上工作👍 👍 🎈 🎈。</p><h1 id="4414" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">在Kubernetes</h1><p id="2dd0" class="pw-post-body-paragraph jq jr it js b jt mg jv jw jx mh jz ka kb mi kd ke kf mj kh ki kj mk kl km kn im bi translated">我们试着在Kubernetes上运行一下。<a class="ae ko" href="https://github.com/ihcsim/routeguide/blob/master/k8s-server.yaml" rel="noopener ugc nofollow" target="_blank"> k8s-server.yaml </a>和<a class="ae ko" href="https://github.com/ihcsim/routeguide/blob/master/k8s-client.yaml" rel="noopener ugc nofollow" target="_blank"> k8s.client.yaml </a>清单文件将部署3个gRPC服务器副本和一个gRPC客户端。服务器和客户机都从它们的配置图中读取它们的配置。</p><p id="2674" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">默认情况下，客户端被配置为使用<code class="fe kq kr ks kt b">dns</code>解析器类型。我们将无法使用<code class="fe kq kr ks kt b">manual</code>解析器类型，因为我们事先不知道服务器的pod IP。我们也没有一个监视器来监视pod的IP地址。</p><p id="a900" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以下是客户端的默认配置:</p><pre class="mm mn mo mp gt nj kt nk nl aw nm bi"><span id="730a" class="mx lj it kt b gy nn no l np nq">kind: ConfigMap<br/>apiVersion: v1<br/>metadata:<br/>  name: rg-client-config<br/>  labels:<br/>    app: rg-client<br/>data:<br/>  SERVER_HOST: rg-server.default.svc.cluster.local<br/>  SERVER_PORT: "80"<br/>  GRPC_TIMEOUT: 60s<br/>  MODE: repeatn<br/>  MAX_REPEAT: "20"<br/>  REMOTE_API: GetFeature<br/>  ENABLE_LOAD_BALANCING: "true"<br/>  RESOLVER_TYPE: dns</span></pre><p id="d190" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要将服务器和客户机部署到Kubernetes集群，运行:</p><pre class="mm mn mo mp gt nj kt nk nl aw nm bi"><span id="78d7" class="mx lj it kt b gy nn no l np nq">$ make deploy</span></pre><p id="107d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">客户端日志显示所有响应都是从一个(而不是所有)服务器实例返回的。这令人失望，但并不奇怪😦。</p><pre class="mm mn mo mp gt nj kt nk nl aw nm bi"><span id="6afb" class="mx lj it kt b gy nn no l np nq">$ kubectl logs -f rg-client <br/>2019/02/20 05:27:21 [main] load balancing scheme: round_robin <br/>2019/02/20 05:27:21 [main] resolver type: dns <br/>2019/02/20 05:27:21 [main] connecting to server at rg-server.default.svc.cluster.local:80 <br/>2019/02/20 05:27:21 [main] running in repeatn mode <br/>2019/02/20 05:27:21 [main] calling GetFeature 20 times <br/>2019/02/20 05:27:21 [GetFeature] (req) latitude:402133926 longitude:-743613249 <br/>2019/02/20 05:27:21 [GetFeature] (resp) (<strong class="kt iu">server=rg-server-6c49b4dcf5-c7bxm:80</strong>) location:&lt;latitude:402133926 longitude:-743613249 &gt; <br/>2019/02/20 05:27:24 [GetFeature] (req) latitude:410873075 longitude:-744459023 <br/>2019/02/20 05:27:24 [GetFeature] (resp) (<strong class="kt iu">server=rg-server-6c49b4dcf5-c7bxm:80</strong>) name:"Clinton Road, West Milford, NJ 07480, USA" location:&lt;latitude:410873075 longitude:-744459023 &gt; <br/>2019/02/20 05:27:27 [GetFeature] (req) latitude:414777405 longitude:-740615601 <br/>2019/02/20 05:27:27 [GetFeature] (resp) (<strong class="kt iu">server=rg-server-6c49b4dcf5-c7bxm:80</strong>) location:&lt;latitude:414777405 longitude:-740615601 &gt; <br/>2019/02/20 05:27:30 [GetFeature] (req) latitude:415301720 longitude:-748416257 <br/>2019/02/20 05:27:30 [GetFeature] (resp) (<strong class="kt iu">server=rg-server-6c49b4dcf5-c7bxm:80</strong>) name:"282 Lakeview Drive Road, Highland Lake, NY 12743, USA" location:&lt;latitude:415301720 longitude:-748416257<br/> &gt; <br/>....</span></pre><h1 id="67b8" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">使用Linkerd 2</h1><p id="30c7" class="pw-post-body-paragraph jq jr it js b jt mg jv jw jx mh jz ka kb mi kd ke kf mj kh ki kj mk kl km kn im bi translated">让我们安装Linkerd 2，并使用它来启用自动gRPC负载平衡和(作为额外奖励)TLS加密连接。</p><p id="244c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">安装Linkerd控制平面:</p><pre class="mm mn mo mp gt nj kt nk nl aw nm bi"><span id="f0f9" class="mx lj it kt b gy nn no l np nq">$ linkerd install --tls=optional | kubectl apply -f - </span></pre><p id="36c8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通过更新客户端配置图来禁用客户端循环负载平衡:</p><pre class="mm mn mo mp gt nj kt nk nl aw nm bi"><span id="52b6" class="mx lj it kt b gy nn no l np nq">kind: ConfigMap<br/>apiVersion: v1<br/>metadata:<br/>  name: rg-client-config<br/>  labels:<br/>    app: rg-client<br/>data:<br/>  SERVER_HOST: rg-server.default.svc.cluster.local<br/>  SERVER_PORT: "80"<br/>  GRPC_TIMEOUT: 60s<br/>  MODE: repeatn<br/>  MAX_REPEAT: "20"<br/>  REMOTE_API: GetFeature<br/>  <strong class="kt iu">ENABLE_LOAD_BALANCING: "false"</strong><br/>  RESOLVER_TYPE: dns</span></pre><p id="9bbd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">网格化并部署服务器和客户端:</p><pre class="mm mn mo mp gt nj kt nk nl aw nm bi"><span id="e4ed" class="mx lj it kt b gy nn no l np nq">$ linkerd inject --tls=optional k8s-server.yaml | kubectl apply -f -<br/>$ linkerd inject --tls=optional k8s-client.yaml | kubectl apply -f -</span></pre><p id="7d59" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在查看客户端日志，我们可以看到所有3台服务器都返回了响应。</p><pre class="mm mn mo mp gt nj kt nk nl aw nm bi"><span id="c28e" class="mx lj it kt b gy nn no l np nq">$ kubectl logs -f rg-client rg-client <br/>2019/02/20 05:50:21 [main] connecting to server at rg-server.default.svc.cluster.local:80 <br/>2019/02/20 05:50:21 [main] running in repeatn mode <br/>2019/02/20 05:50:21 [main] calling GetFeature 20 times <br/>2019/02/20 05:50:21 [GetFeature] (req) latitude:402133926 longitude:-743613249 <br/>2019/02/20 05:50:21 [GetFeature] (resp) (<strong class="kt iu">server=rg-server-b7b84d954-fh9q2:80</strong>) location:&lt;latitude:402133926 longitude:-743613249 &gt; <br/>2019/02/20 05:50:24 [GetFeature] (req) latitude:410873075 longitude:-744459023 <br/>2019/02/20 05:50:24 [GetFeature] (resp) (<strong class="kt iu">server=rg-server-b7b84d954-9ttc7:80</strong>) name:"Clinton Road, West Milford, NJ 07480, USA" location:&lt;latitude:410873075 longitude:-744459023 &gt; <br/>2019/02/20 05:50:27 [GetFeature] (req) latitude:414777405 longitude:-740615601 <br/>2019/02/20 05:50:27 [GetFeature] (resp) (<strong class="kt iu">server=rg-server-b7b84d954-s2vx5:80</strong>) location:&lt;latitude:414777405 longitude:-740615601 &gt; <br/>2019/02/20 05:50:30 [GetFeature] (req) latitude:415301720 longitude:-748416257 <br/>2019/02/20 05:50:30 [GetFeature] (resp) (<strong class="kt iu">server=rg-server-b7b84d954-fh9q2:80</strong>) name:"282 Lakeview Drive Road, Highland Lake, NY 12743, USA" location:&lt;latitude:415301720 longitude:-748416257 <br/>&gt; <br/>2019/02/20 05:50:33 [GetFeature] (req) latitude:402647019 longitude:-747071791 <br/>2019/02/20 05:50:33 [GetFeature] (resp) (<strong class="kt iu">server=rg-server-b7b84d954-fh9q2:80</strong>) name:"330 Evelyn Avenue, Hamilton Township, NJ 08619, USA" location:&lt;latitude:402647019 longitude:-747071791 &gt; <br/>2019/02/20 05:50:36 [GetFeature] (req) latitude:405957808 longitude:-743255336 <br/>2019/02/20 05:50:36 [GetFeature] (resp) (<strong class="kt iu">server=rg-server-b7b84d954-fh9q2:80</strong>) name:"82-104 Amherst Avenue, Colonia, NJ 07067, USA" location:&lt;latitude:405957808 longitude:-743255336 &gt; <br/>....</span></pre><p id="28b4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">查看Linkerd仪表板，请注意:</p><ul class=""><li id="5767" class="ku kv it js b jt ju jx jy kb kw kf kx kj ky kn kz la lb lc bi translated">TLS自动启用。</li><li id="8729" class="ku kv it js b jt ld jx le kb lf kf lg kj lh kn kz la lb lc bi translated">可以观察到由注入故障引起的请求失败。</li></ul><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi nt"><img src="../Images/3fa78d334ed069838dd65beceac2e4a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*63ftOhbRRgS7nbefd6wOYg.png"/></div></div><figcaption class="nu nv gj gh gi nw nx bd b be z dk translated">屏幕截图gRPC客户端和服务器副本之间的流量摘要</figcaption></figure><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi ny"><img src="../Images/ebbc9ac8576d33b53c70a6472cfa1b41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Wtb5k3xYDKiEETxhlQvNEA.png"/></div></div><figcaption class="nu nv gj gh gi nw nx bd b be z dk translated">截图2:每台服务器的成功率和每秒请求数</figcaption></figure><p id="0b2e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">简单吧？😄</p><h1 id="2003" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">结论</h1><p id="1e47" class="pw-post-body-paragraph jq jr it js b jt mg jv jw jx mh jz ka kb mi kd ke kf mj kh ki kj mk kl km kn im bi translated">我们研究了如何使用gRPC-Go <code class="fe kq kr ks kt b">balancer</code>和<code class="fe kq kr ks kt b">resolver</code>包实现客户端循环负载平衡。虽然没有很多代码要写，但我确实花了一些时间来弄清楚不同的部分是如何组合在一起的。</p><p id="311c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们看到了<code class="fe kq kr ks kt b">dns</code>域名系统如何在Kubernetes上不起作用，因为Kubernetes的默认内部负载平衡工作在L4级别。gRPC是L7协议。</p><p id="9045" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后，我们将Linkerd 2部署到集群中。使用<code class="fe kq kr ks kt b">linkerd inject</code>命令，我们能够将gRPC服务器和客户机结合起来，实现自动gRPC负载平衡和TLS。我们这样做没有改变应用程序代码，额外的YAML文件，也没有部署外部负载平衡器。</p><h1 id="25d9" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">脚注</h1><p id="d788" class="pw-post-body-paragraph jq jr it js b jt mg jv jw jx mh jz ka kb mi kd ke kf mj kh ki kj mk kl km kn im bi translated">[1]https://grpc.io/blog/loadbalancing<a class="ae ko" href="https://grpc.io/blog/loadbalancing" rel="noopener ugc nofollow" target="_blank"/></p><p id="0fdf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">[2]<a class="ae ko" href="https://github.com/grpc/grpc/blob/master/doc/load-balancing.md#workflow" rel="noopener ugc nofollow" target="_blank">https://github . com/grpc/grpc/blob/master/doc/load-balancing . MD # workflow</a></p></div></div>    
</body>
</html>