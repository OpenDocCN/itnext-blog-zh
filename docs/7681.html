<html>
<head>
<title>Mastering Injectable Services: A Comprehensive Guide</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">掌握注射服务:综合指南</h1>
<blockquote>原文：<a href="https://itnext.io/mastering-injectable-services-a-comprehensive-guide-6c2c0f5f48a2?source=collection_archive---------1-----------------------#2022-12-19">https://itnext.io/mastering-injectable-services-a-comprehensive-guide-6c2c0f5f48a2?source=collection_archive---------1-----------------------#2022-12-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/f7d99bd82fef89d71d1c3800171d2943.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vEMB3yhy0c5-x1oTP4i80Q.png"/></div></div></figure><p id="75a1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在Angular中，<code class="fe kw kx ky kz b">@Injectable</code> decorator用于创建服务，这些服务可以通过Angular的依赖注入系统提供给其他组件。然后，这些服务可以将依赖注入系统<em class="la"> (DI) </em>提供的其他服务注入到它们的类中。</p><p id="8d76" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要声明一个可注入的服务，我们只需在类的顶部添加装饰器:</p><pre class="lb lc ld le gt lf kz lg bn lh li bi"><span id="7279" class="lj lk iq kz b be ll lm l ln lo">@Injectable()<br/>class MyService {<br/>}</span></pre><p id="b0fe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，仅仅添加<code class="fe kw kx ky kz b">@Injectable</code>装饰器并不能在Angular的DI系统中自动提供该服务。让我们探索Angular中提供服务的各种方式。</p><h1 id="2dbb" class="lp lk iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">provided in:“root”与在引导提供程序阵列中提供服务。</h1><blockquote class="mm mn mo"><p id="b377" class="jy jz la ka b kb kc kd ke kf kg kh ki mp kk kl km mq ko kp kq mr ks kt ku kv ij bi translated">对于仍在使用NgModule的开发人员来说，位于<code class="fe kw kx ky kz b">main.ts</code>中的引导提供者数组类似于您的<code class="fe kw kx ky kz b">AppModule</code>中的提供者数组。</p></blockquote><p id="dc9c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这两个场景中，我们的服务都是单例的，这意味着在我们的整个应用程序中只有一个服务实例。我们可以在任何地方注入相同的实例。</p><p id="f31a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">主要区别在于Angular如何以及在哪里捆绑我们的服务。我们将在5个场景中设想这一点。</p><ul class=""><li id="863b" class="ms mt iq ka b kb kc kf kg kj mu kn mv kr mw kv mx my mz na bi translated">服务未使用的引导提供程序阵列</li><li id="7134" class="ms mt iq ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated">在一个组件中使用服务的引导提供程序阵列</li><li id="98f1" class="ms mt iq ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated">向“root”提供未使用的服务</li><li id="26a9" class="ms mt iq ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated">为“根”提供在一个组件中使用的服务</li><li id="7604" class="ms mt iq ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated">为“根”提供在多个组件中使用的服务</li></ul><p id="b9ae" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">出于演示的目的，我们创建了3个组件<code class="fe kw kx ky kz b">AppComponent</code>、<code class="fe kw kx ky kz b">FooComponent</code>和<code class="fe kw kx ky kz b">BarComponent</code>。<code class="fe kw kx ky kz b">FooComponent</code>和<code class="fe kw kx ky kz b">BarComponent</code>懒加载在路线导航上。Angular将创建3个不同的包，我们将使用<a class="ae ng" href="https://www.npmjs.com/package/source-map-explorer" rel="noopener ugc nofollow" target="_blank"><em class="la">source-map-explorer</em></a><em class="la"/>来查看哪个包<code class="fe kw kx ky kz b">MyService</code>在其中。</p><pre class="lb lc ld le gt lf kz lg bn lh li bi"><span id="f2f3" class="lj lk iq kz b be ll lm l ln lo">export const routes: Routes = [<br/>  {<br/>    path: 'foo',<br/>    loadComponent: () =&gt; import('./foo.component').then((x) =&gt; x.FooComponent),<br/>  },<br/>  {<br/>    path: 'bar',<br/>    loadComponent: () =&gt; import('./bar.component').then((x) =&gt; x.BarComponent),<br/>  },<br/>];</span></pre><p id="d2bf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">目标是可视化Angular编译器如何动摇我们的服务。</p><blockquote class="mm mn mo"><p id="ae50" class="jy jz la ka b kb kc kd ke kf kg kh ki mp kk kl km mq ko kp kq mr ks kt ku kv ij bi translated"><strong class="ka ir">树摇动</strong>是从一个包中移除死代码以将其大小减到最小的过程。</p></blockquote><h2 id="8528" class="nh lk iq bd lq ni nj dn lu nk nl dp ly kj nm nn mc kn no np mg kr nq nr mk ns bi translated">1-在引导提供程序阵列中提供服务，即使它未被使用</h2><p id="65be" class="pw-post-body-paragraph jy jz iq ka b kb nt kd ke kf nu kh ki kj nv kl km kn nw kp kq kr nx kt ku kv ij bi translated">让我们从在我们的引导应用程序提供者阵列中提供服务开始。<em class="la">(我们的服务不会被使用)</em></p><pre class="lb lc ld le gt lf kz lg bn lh li bi"><span id="6f14" class="lj lk iq kz b be ll lm l ln lo">bootstrapApplication(AppComponent, {<br/>  providers: [<br/>    MyService, <br/>    provideRouter(routes)<br/>  ],<br/>});</span></pre><p id="0390" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要使用<em class="la"> source-map-explorer </em>，我们需要通过构建我们的应用程序来创建我们的sourceMap文件:</p><pre class="lb lc ld le gt lf kz lg bn lh li bi"><span id="c29b" class="lj lk iq kz b be ll lm l ln lo">ng build -c development</span></pre><figure class="lb lc ld le gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ny"><img src="../Images/985295999fd87cb46ef336bc4ef8953c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zM3SzuioBewKBCxzpfmGhQ.png"/></div></div></figure><p id="c19e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以看到我们构建的结果，它显示Angular为web应用程序创建了两个惰性块和一个经典构建块。我们的重点将放在两个懒惰块和<code class="fe kw kx ky kz b">main.js</code></p><p id="ee78" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们用<em class="la"> source-map-explorer </em>更近距离地观察我们的包:</p><pre class="lb lc ld le gt lf kz lg bn lh li bi"><span id="c85f" class="lj lk iq kz b be ll lm l ln lo">source-map-explorer ./dist/[my-application-name]/*.js</span></pre><figure class="lb lc ld le gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nz"><img src="../Images/b1ca3d05c60340c5bad432eabbe0fcaa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jzq-zesQSFHGS5yTs0vikA.png"/></div></div></figure><p id="4627" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以看到，我们的服务嵌入在我们的主包中，即使该服务未被使用。这导致了用户将下载但从不使用的代码。</p><h2 id="e459" class="nh lk iq bd lq ni nj dn lu nk nl dp ly kj nm nn mc kn no np mg kr nq nr mk ns bi translated">2-在引导提供者阵列中提供服务，并在一个延迟加载的组件中使用该服务</h2><p id="bbcf" class="pw-post-body-paragraph jy jz iq ka b kb nt kd ke kf nu kh ki kj nv kl km kn nw kp kq kr nx kt ku kv ij bi translated">我们得到和以前一样的结果。该服务被捆绑在我们的主捆绑包中，即使我们只在一个惰性加载的组件中使用它。</p><h2 id="2765" class="nh lk iq bd lq ni nj dn lu nk nl dp ly kj nm nn mc kn no np mg kr nq nr mk ns bi translated">3-为“根”提供未使用的服务</h2><p id="cab5" class="pw-post-body-paragraph jy jz iq ka b kb nt kd ke kf nu kh ki kj nv kl km kn nw kp kq kr nx kt ku kv ij bi translated">我们可以使用<code class="fe kw kx ky kz b">@Injectable</code>装饰器中的<code class="fe kw kx ky kz b">ProvidedIn</code>属性来指定哪个注入器将提供我们的服务..</p><pre class="lb lc ld le gt lf kz lg bn lh li bi"><span id="ce57" class="lj lk iq kz b be ll lm l ln lo">@Injectable({ providedIn: 'root' })<br/>export class MyService {}</span></pre><p id="cc54" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">设置<code class="fe kw kx ky kz b">providedIn: 'root'</code>将在应用程序的根级别提供我们的服务。这可能看起来与前面的例子相似，但是Angular编译器能够根据注入的位置来改变我们的服务。</p><figure class="lb lc ld le gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oa"><img src="../Images/9e133f43d66f0edab2c2b56bc0fe7ef9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2AvY-8knqYC1jQkEPafdZA.png"/></div></div></figure><p id="a7d8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们将这个构建结果与前一个进行比较，我们可以看到<code class="fe kw kx ky kz b">main.js</code>包从1018B下降到874B，而<code class="fe kw kx ky kz b">bar.js</code>和<code class="fe kw kx ky kz b">foo.js</code>包没有变化。由于没有注入<code class="fe kw kx ky kz b">MyService</code>，Angular编译器没有将它包含在任何包中。</p><h2 id="c041" class="nh lk iq bd lq ni nj dn lu nk nl dp ly kj nm nn mc kn no np mg kr nq nr mk ns bi translated">4-为“根”提供在一个组件中使用的服务</h2><p id="907c" class="pw-post-body-paragraph jy jz iq ka b kb nt kd ke kf nu kh ki kj nv kl km kn nw kp kq kr nx kt ku kv ij bi translated">让我们在<code class="fe kw kx ky kz b">BarComponent</code>中注入我们的服务，然后重新运行我们的构建。</p><pre class="lb lc ld le gt lf kz lg bn lh li bi"><span id="a103" class="lj lk iq kz b be ll lm l ln lo">@Component({<br/>  selector: 'app-bar',<br/>  standalone: true,<br/>  imports: [],<br/>  template: `bar`,<br/>})<br/>export class BarComponent {<br/>    service = inject(MyService)<br/>}</span></pre><figure class="lb lc ld le gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ob"><img src="../Images/3c77c766802b7a54962c17180cf6a1e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WF_48ReJnzSSgm2u1-fQiQ.png"/></div></div></figure><p id="6530" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以看到<code class="fe kw kx ky kz b">bar.js</code> bundle的大小增加了，说明由于<code class="fe kw kx ky kz b">MyService</code>只被<code class="fe kw kx ky kz b">BarComponent</code>使用，编译器已经把服务和组件捆绑在一起了。</p><p id="2fab" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们也可以用<em class="la">地图资源管理器</em>来可视化它。</p><figure class="lb lc ld le gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oc"><img src="../Images/b7b89d59d4ab6d6e607d25e1e69beeb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qeGtN3rE-y4nUUK8qIMWyQ.png"/></div></div></figure><h2 id="9965" class="nh lk iq bd lq ni nj dn lu nk nl dp ly kj nm nn mc kn no np mg kr nq nr mk ns bi translated">5-为“根”提供在多个惰性加载组件中使用的服务</h2><p id="09f9" class="pw-post-body-paragraph jy jz iq ka b kb nt kd ke kf nu kh ki kj nv kl km kn nw kp kq kr nx kt ku kv ij bi translated">如果我们在多个延迟加载的组件中使用我们的服务会发生什么。让我们也在<code class="fe kw kx ky kz b">FooComponent</code>中注入服务。</p><figure class="lb lc ld le gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi od"><img src="../Images/d7a133e588e38d2e76bb6a8b94730256.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BBQmkGb5KMPl5iVUFYd2iA.png"/></div></div></figure><p id="64ef" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Angular已经创建了第三个块<code class="fe kw kx ky kz b">common.js</code>，其中包含了我们的服务。这确保了没有重复的代码。在我们的应用程序中调用的第一个组件将下载<code class="fe kw kx ky kz b">common.js</code>。</p><blockquote class="mm mn mo"><p id="81ce" class="jy jz la ka b kb kc kd ke kf kg kh ki mp kk kl km mq ko kp kq mr ks kt ku kv ij bi translated">块大小有点大，因为我们现在在编译的js文件中添加了构造函数声明。</p></blockquote><h2 id="4157" class="nh lk iq bd lq ni nj dn lu nk nl dp ly kj nm nn mc kn no np mg kr nq nr mk ns bi translated"><strong class="ak">结论:</strong></h2><p id="8933" class="pw-post-body-paragraph jy jz iq ka b kb nt kd ke kf nu kh ki kj nv kl km kn nw kp kq kr nx kt ku kv ij bi translated">对于每个单例服务，总是使用<code class="fe kw kx ky kz b">ProvidedIn: 'root'</code>。更容易维护，Angular编译器在幕后做了一项了不起的工作，以最佳方式树摇我们的包。</p><h1 id="34d2" class="lp lk iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">非单一服务</h1><p id="af03" class="pw-post-body-paragraph jy jz iq ka b kb nt kd ke kf nu kh ki kj nv kl km kn nw kp kq kr nx kt ku kv ij bi translated">如果我们想要同一个服务的多个实例，我们必须将<code class="fe kw kx ky kz b">ProvidedIn</code>属性设置为未定义的<em class="la">(或者移除它)</em>，并在组件<code class="fe kw kx ky kz b">providers</code>数组中提供服务。</p><pre class="lb lc ld le gt lf kz lg bn lh li bi"><span id="868f" class="lj lk iq kz b be ll lm l ln lo">@Component({<br/>  selector: 'app-bar',<br/>  standalone: true,<br/>  imports: [],<br/>  providers: [MyService], // provide a service<br/>  template: `bar`,<br/>})<br/>export class BarComponent {<br/>  service = inject(MyService)<br/>}</span></pre><p id="9873" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的服务实例现在连接到了组件的生命周期。当我们的组件被实例化或销毁时，我们的服务也将被实例化或销毁。如果创建了两个组件，那么就会创建两个单独的<code class="fe kw kx ky kz b">MyService</code>实例。</p><h2 id="d89b" class="nh lk iq bd lq ni nj dn lu nk nl dp ly kj nm nn mc kn no np mg kr nq nr mk ns bi translated">小挑战:</h2><p id="4e29" class="pw-post-body-paragraph jy jz iq ka b kb nt kd ke kf nu kh ki kj nv kl km kn nw kp kq kr nx kt ku kv ij bi translated"><strong class="ka ir">挑战1: </strong></p><pre class="lb lc ld le gt lf kz lg bn lh li bi"><span id="6ce8" class="lj lk iq kz b be ll lm l ln lo">@Injectable()<br/>export class MyService {<br/>  title = 'No Title';<br/><br/>  setTitle = (title: string) =&gt; (this.title = title);<br/>}<br/><br/>@Component({<br/>  selector: 'child',<br/>  standalone: true,<br/>  template: `&lt;div&gt;{{ myService.title }}&lt;/div&gt;`,<br/>})<br/>export class ChildComponent {<br/>  myService = inject(MyService);<br/>}<br/><br/>@Component({<br/>  selector: 'parent',<br/>  standalone: true,<br/>  imports: [ChildComponent],<br/>  providers: [MyService],<br/>  template: `&lt;child&gt;&lt;/child&gt;`,<br/>})<br/>export class ParentComponent {<br/>  myService = inject(MyService).setTitle('Parent Title');<br/>}</span></pre><p id="b3cb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">问题:</strong>你的屏幕上会显示什么？</p><p id="422a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">解:</strong>父题</p><p id="8447" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">解释:</strong>如果我们在父组件的<code class="fe kw kx ky kz b">providers</code>数组中声明服务，那么它的所有子组件都将获得服务的相同实例。这对于在一组组件之间共享信息非常有用。</p><p id="e043" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">挑战二:</strong></p><pre class="lb lc ld le gt lf kz lg bn lh li bi"><span id="cd64" class="lj lk iq kz b be ll lm l ln lo">@Injectable()<br/>export class MyService {<br/>  title = 'No Title';<br/><br/>  setTitle = (title: string) =&gt; (this.title = title);<br/>}<br/><br/>@Component({<br/>  selector: 'child',<br/>  standalone: true,<br/>  providers: [MyService], // provide MyService in child component<br/>  template: `&lt;div&gt;{{ myService.title }}&lt;/div&gt;`,<br/>})<br/>export class ChildComponent {<br/>  myService = inject(MyService);<br/>}<br/><br/>@Component({<br/>  selector: 'parent',<br/>  standalone: true,<br/>  imports: [ChildComponent],<br/>  providers: [MyService],<br/>  template: `&lt;child&gt;&lt;/child&gt;`,<br/>})<br/>export class ParentComponent {<br/>  myService = inject(MyService).setTitle('Parent Title');<br/>}</span></pre><p id="0715" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">问题:你的屏幕上会显示什么？</p><p id="c9bd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">解决方案:</strong>没有标题</p><p id="9c49" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">解释:</strong>如果我们在父组件和子组件中都提供了<code class="fe kw kx ky kz b">MyService</code>，那么<code class="fe kw kx ky kz b">MyService</code>将会有两个不同的实例。<em class="la">(我将在另一篇文章中更详细地解释DI是如何工作的)</em></p><h1 id="53a6" class="lp lk iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">提供内部路由提供程序数组</h1><p id="16a0" class="pw-post-body-paragraph jy jz iq ka b kb nt kd ke kf nu kh ki kj nv kl km kn nw kp kq kr nx kt ku kv ij bi translated">另一种提供服务的方式是在route的<code class="fe kw kx ky kz b">providers</code>数组中。</p><blockquote class="mm mn mo"><p id="6e1f" class="jy jz la ka b kb kc kd ke kf kg kh ki mp kk kl km mq ko kp kq mr ks kt ku kv ij bi translated">这类似于在惰性加载的NgModule中提供它。</p></blockquote><pre class="lb lc ld le gt lf kz lg bn lh li bi"><span id="4ecc" class="lj lk iq kz b be ll lm l ln lo">export const routes: Routes = [<br/>  {<br/>    path: 'bar',<br/>    providers: [MyService],<br/>    loadChildren: () =&gt; import('./child/routes').then((r) =&gt; r.childRoutes),<br/>  },<br/>  {<br/>    path: 'foo',<br/>    loadComponent: () =&gt; import('./foo.component').then((x) =&gt; x.FooComponent),<br/>  },<br/>];</span></pre><p id="235e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">其中<code class="fe kw kx ky kz b">childRoutes</code>是路由的子集。</p><pre class="lb lc ld le gt lf kz lg bn lh li bi"><span id="5265" class="lj lk iq kz b be ll lm l ln lo">export const childRoutes: Routes = [<br/>  { path: '', pathMatch: 'full', redirectTo: 'bar-1' },<br/>  {<br/>    path: 'bar-1',<br/>    loadComponent: () =&gt;<br/>      import('./bar-child-1.component').then((x) =&gt; x.BarChild1Component),<br/>  },<br/>  {<br/>    path: 'bar-2',<br/>    loadComponent: () =&gt;<br/>      import('./bar-child-2.component').then((x) =&gt; x.BarChild2Component),<br/>  },<br/>];</span></pre><p id="5a62" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这种行为可能有点令人困惑。当我们第一次导航到<code class="fe kw kx ky kz b">bar-child</code>路线中的一条路线时，<code class="fe kw kx ky kz b">MyService</code>将被实例化。如果我们离开，服务不会被破坏。如果我们导航回该路由，该服务将不会被再次实例化，这意味着在内存中将只有一个<code class="fe kw kx ky kz b">MyService</code>实例。</p><p id="9644" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，不是该路线的子组件的其他组件将不能访问<code class="fe kw kx ky kz b">MyService</code>。</p><p id="2900" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在构建时，<code class="fe kw kx ky kz b">MyService</code>将位于<code class="fe kw kx ky kz b">main.js</code>内部。<em class="la">(而不是在我认为它会在的一个懒惰加载的块中)。</em>请注意，<em class="la"> </em>这与在父组件或子组件中提供<code class="fe kw kx ky kz b">MyService</code>不同，在父组件或子组件中，它将与那些组件一起被实例化和销毁。</p><figure class="lb lc ld le gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oe"><img src="../Images/cb00b4fc1d25b0497b3204c89ec8dda3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LrCsdiVaJYqPNLrv7I6yRQ.png"/></div></div></figure><figure class="lb lc ld le gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi of"><img src="../Images/a80034f4a56623304abf976c3be700b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wj4fNxTXkMHelOdx4ByUSQ.png"/></div></div></figure></div><div class="ab cl og oh hu oi" role="separator"><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol"/></div><div class="ij ik il im in"><p id="4e62" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">额外提示:</strong>如果我们想要创建一个在导航到特定路线时被实例化并在导航离开时被销毁的服务，我们可以将前面两个部分中所学的内容结合起来。</p><p id="4ff5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要销毁服务，需要在组件装饰器中提供服务。但是要在路线导航上实例化它，必须在路线级别提供服务。解决方案是创建一个父组件来保存我们服务的实例。</p><pre class="lb lc ld le gt lf kz lg bn lh li bi"><span id="d161" class="lj lk iq kz b be ll lm l ln lo">{<br/>  path: 'bar',<br/>  loadComponent: () =&gt;<br/>    import('./my-service.component').then((x) =&gt; x.MyServiceComponent),<br/>  loadChildren: () =&gt; import('./child/routes').then((r) =&gt; r.childRoutes),<br/>},</span></pre><pre class="on lf kz lg bn lh li bi"><span id="8a7d" class="lj lk iq kz b be ll lm l ln lo">@Component({<br/>  standalone: true,<br/>  imports: [RouterOutlet],<br/>  providers: [MyService],<br/>  template: `&lt;router-outlet&gt;&lt;/router-outlet&gt;`,<br/>})<br/>export class MyServiceComponent {}</span></pre><p id="6b95" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这个例子中，<code class="fe kw kx ky kz b">MyServiceComponent</code>被提供了一个<code class="fe kw kx ky kz b">MyService</code>的实例。当我们导航到<code class="fe kw kx ky kz b">bar</code>时，子组件被创建，它将被提供相同的<code class="fe kw kx ky kz b">MyService</code>实例。当我们离开时，子组件被销毁，<code class="fe kw kx ky kz b">MyService</code>的实例也将被销毁。</p></div><div class="ab cl og oh hu oi" role="separator"><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol"/></div><div class="ij ik il im in"><p id="9fe6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">本文到此为止！您现在应该掌握并优化Angular中的注入服务。</p><p id="0284" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你觉得这篇文章有用，请考虑支持我的工作，为它鼓掌👏👏帮助它接触到更广泛的受众。非常感谢你的支持。</p><p id="0f5f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我希望你学到了新的角度概念。你可以在<a class="ae ng" href="https://medium.com/@thomas.laforge" rel="noopener"> Medium </a>、<a class="ae ng" href="https://twitter.com/laforge_toma" rel="noopener ugc nofollow" target="_blank"> Twitter </a>或者<a class="ae ng" href="https://github.com/tomalaforge" rel="noopener ugc nofollow" target="_blank"> Github </a>上找到我。如果你有更多的问题，不要犹豫来找我</p><blockquote class="oo"><p id="7464" class="op oq iq bd or os ot ou ov ow ox kv dk translated"><em class="oy">👉而如果你想加速你的角度学习之旅，快来看看</em> <a class="ae ng" href="https://github.com/tomalaforge/angular-challenges" rel="noopener ugc nofollow" target="_blank"> <em class="oy">角度挑战</em> </a> <em class="oy">。</em></p></blockquote></div></div>    
</body>
</html>