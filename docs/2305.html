<html>
<head>
<title>Writing scalable Typescript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编写可伸缩的类型脚本</h1>
<blockquote>原文：<a href="https://itnext.io/writing-scalable-typescript-e62e1f24a013?source=collection_archive---------1-----------------------#2019-05-04">https://itnext.io/writing-scalable-typescript-e62e1f24a013?source=collection_archive---------1-----------------------#2019-05-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="34f7" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">让我们详细探讨如何编写干净、安全的企业级类型脚本代码</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/909e7dbb5dda2b6df4bf43a014151da5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xxzCZ_x7oeKlq_NRTw6GeA.jpeg"/></div></div></figure><p id="e753" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在我们开始之前，我想给出我的“可伸缩代码”清单；在本文中，键入脚本代码:</p><ul class=""><li id="6368" class="ln lo iq kt b ku kv kx ky la lp le lq li lr lm ls lt lu lv bi translated">它是干净的、格式良好的、可读的代码</li><li id="bd0a" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">它是精心设计的、一致的和可预测的</li><li id="7347" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">它很容易扩展</li><li id="25a4" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">最后但并非最不重要的是，它是无bug的</li></ul><p id="59a8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">自从引入以来，Typescript凭借其工具和强大的静态分析帮助我们解决了Javascript生态系统中的一些最大问题。</p><p id="9705" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然而，根据我的经验，许多团队只利用了Typescript提供给我们的一小部分特性。</p><p id="b37c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">有人认为:</p><ul class=""><li id="41f3" class="ln lo iq kt b ku kv kx ky la lp le lq li lr lm ls lt lu lv bi translated">这很费时间</li><li id="18e0" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">键入我们的代码不会减少它的错误</li><li id="8c77" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">初级开发者入门越来越难</li></ul><p id="9fb7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我不是来证明他们是错的。因为事实是，他们可能是对的。</p><p id="3cf7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是Typescript并不一定是可怕的，在我看来，正确使用它编写代码在很大程度上超过了上面提到的缺点。</p><p id="afe4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这篇文章中，我想讨论和探索最好的工具和实践，让<strong class="kt ir">让Typescript值得我们花时间</strong>。</p><h1 id="3695" class="mb mc iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">使用棉绒和格式化程序</h1><p id="5da1" class="pw-post-body-paragraph kr ks iq kt b ku mt jr kw kx mu ju kz la mv lc ld le mw lg lh li mx lk ll lm ij bi translated">如上所述，我们希望我们的类型脚本代码是干净的、格式良好的和可读的。</p><p id="7920" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在我以前的文章中的一篇<a class="ae my" rel="noopener ugc nofollow" target="_blank" href="/enforce-your-team-coding-style-with-prettier-and-tslint-9faac5016ce7">中，我写了一篇关于设置<em class="mz">beautiful</em>和<em class="mz"> TsLint </em>的指南，以便让我们的代码在整个团队中保持一致。由于我可能重复得太多了，所以我不会太详细地解释为什么以及如何设置这些工具。</a></p><p id="61e1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">相反，我想把重点放在使用这些工具给你的团队带来的好处上。</p><p id="e0b9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">无论你使用的是EsLint、TsLint、Prettier还是所有这些工具，我都不会过分强调为我们的代码库提供一致性对于一个高效团队的生产力来说是最有影响力的事情之一。</p><p id="133a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">熟悉的代码库:</p><ul class=""><li id="b819" class="ln lo iq kt b ku kv kx ky la lp le lq li lr lm ls lt lu lv bi translated">更容易阅读和使用</li><li id="244d" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">更容易理解和开始使用</li><li id="56ad" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">更容易修改</li><li id="d539" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">更容易复习</li><li id="4f0a" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">减少团队内部的摩擦</li></ul><p id="b8ce" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">任何在这个行业工作足够长时间的人都非常清楚最后一点有多重要。</p><p id="fff7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对于一个企业来说，同事之间的摩擦和误解比糟糕的代码更糟糕，比错误更糟糕。</p><p id="3cb0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">程序员碰巧非常关心格式。</p><p id="910c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">通过将花费在代码评审、会议和电话讨论上的时间减到最少，我们使业务更有效率。</p><p id="1d3f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">花在检查分号位置上的时间被用来检查代码的业务逻辑是否正确，或者函数的性能是否最佳。这就是代码审查应该做的。</p><blockquote class="na"><p id="8881" class="nb nc iq bd nd ne nf ng nh ni nj lm dk translated">快乐的团队是高效的团队。保持你的打字稿整洁。</p></blockquote><h1 id="cce0" class="mb mc iq bd md me mf mg mh mi mj mk ml jw nk jx mn jz nl ka mp kc nm kd mr ms bi translated">使用严格的编译器选项</h1><p id="5fc4" class="pw-post-body-paragraph kr ks iq kt b ku mt jr kw kx mu ju kz la mv lc ld le mw lg lh li mx lk ll lm ij bi translated">Typescript最大的好处之一来自于启用它的严格模式编译器。为了启用严格模式，您只需要更改位于您的<code class="fe nn no np nq b"><em class="mz">tsconfig.json</em></code> <em class="mz"> : </em>中的编译器选项文件</p><pre class="kg kh ki kj gt nr nq ns nt aw nu bi"><span id="fc38" class="nv mc iq nq b gy nw nx l ny nz">"compilerOptions": {<br/>    ... // more<br/>    "strict": true<br/>}</span></pre><p id="8aec" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">通过启用此选项，所有其他严格选项也将默认启用。</p><h2 id="c9b8" class="nv mc iq bd md oa ob dn mh oc od dp ml la oe of mn le og oh mp li oi oj mr ok bi translated">严格的空检查</h2><p id="b8e1" class="pw-post-body-paragraph kr ks iq kt b ku mt jr kw kx mu ju kz la mv lc ld le mw lg lh li mx lk ll lm ij bi translated">严格的编译器将帮助我们捕捉运行时可能发生的错误。</p><p id="9443" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在我看来,<code class="fe nn no np nq b"><em class="mz">strictNullChecks</em></code>是让你的编译器帮助你防止这种错误的最重要的选择。</p><p id="8033" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">结合正确键入，当我们试图访问可能的<code class="fe nn no np nq b">null</code>或<code class="fe nn no np nq b">undefined</code>值时，该选项将警告我们。</p><p id="6c63" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这可能是我们的应用程序中运行时错误的最常见原因之一，我们最终可以获得帮助来尽可能地避免它们。</p><p id="f787" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果您在阅读本文之前已经是一名超过2小时的Javascript开发人员，那么您可能已经在您的控制台上看到了这个消息:</p><blockquote class="ol om on"><p id="ebd2" class="kr ks mz kt b ku kv jr kw kx ky ju kz oo lb lc ld op lf lg lh oq lj lk ll lm ij bi translated"><em class="iq">未捕获的类型错误:无法读取未定义的属性“property”</em></p></blockquote><p id="da02" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">哦，我有。<strong class="kt ir">千次</strong>。</p><p id="571c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是…最近没那么多了，多亏了打字稿。</p><p id="7c78" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">那么<code class="fe nn no np nq b"><em class="mz">strictNullChecks</em></code>到底如何帮助我们呢？</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi or"><img src="../Images/ddff0d10fd677a79ba0732bf9d8f423e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SuRzMd87h2lH9tqgyNKj_w.png"/></div></div></figure><p id="fb8e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们来分解一下这个例子:</p><ul class=""><li id="437a" class="ln lo iq kt b ku kv kx ky la lp le lq li lr lm ls lt lu lv bi translated">我们有一些布尔叫做<code class="fe nn no np nq b"><em class="mz">x</em></code></li><li id="5008" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">我们有一个声明的函数<code class="fe nn no np nq b"><em class="mz">logger</em></code></li><li id="a155" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">我们想用一个叫做<code class="fe nn no np nq b"><em class="mz">msg</em></code> <em class="mz"> </em>的变量来调用<code class="fe nn no np nq b"><em class="mz">logger</em></code>，这个变量也可能是未定义的</li></ul><p id="c55e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">编译器正确而温和地让我知道，如果<em class="mz"> logger </em>接受我作为字符串输入的参数，那么我只能传递一个唯一且始终是字符串的参数。</p><p id="b8d2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果我将<em class="mz">记录器的消息</em>参数<em class="mz"> </em>输入为字符串，那么我就不能调用字符串的方法。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi os"><img src="../Images/d1c2d3ee910ac666a4854b924b81ad59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kQLu2mtugqhAWYJpM61JiQ.png"/></div></div></figure><p id="471a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这些例子看起来微不足道，而且极其简单，但是在专业代码库中发现类似的情况却非常普遍。</p><p id="7460" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">好的一面是，<em class="mz"> strictNullChecks </em>在更多人为的场景中帮助了我们。</p><h1 id="26a9" class="mb mc iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">打得好，经常打</h1><h2 id="570e" class="nv mc iq bd md oa ob dn mh oc od dp ml la oe of mn le og oh mp li oi oj mr ok bi translated">诚实打字</h2><p id="853b" class="pw-post-body-paragraph kr ks iq kt b ku mt jr kw kx mu ju kz la mv lc ld le mw lg lh li mx lk ll lm ij bi translated">你们中的一些人可能会想,“诚实”这个词是因为我有限的英语技能还是有更多的原因。什么是诚实打字？</p><ul class=""><li id="0f6a" class="ln lo iq kt b ku kv kx ky la lp le lq li lr lm ls lt lu lv bi translated">假设我们有一个后端API，它返回一个金融产品的价格对象</li><li id="54b0" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">并非所有回复都包含<em class="mz">要价</em>或<em class="mz">出价</em></li></ul><pre class="kg kh ki kj gt nr nq ns nt aw nu bi"><span id="92f6" class="nv mc iq nq b gy nw nx l ny nz">{<br/>    "correlationId": "123",<br/>    "askPrice": 1213.45,<br/>    "bidPrice": undefined<br/>}</span></pre><p id="1811" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们为此创建一个Typescript接口:</p><pre class="kg kh ki kj gt nr nq ns nt aw nu bi"><span id="8aa0" class="nv mc iq nq b gy nw nx l ny nz">interface Price {<br/>    correlationId: string;<br/>    askPrice: number;<br/>    bidPrice: number;<br/>}</span></pre><p id="c715" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对吗？当然不是。</p><p id="f59f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我听说过程序员不完全键入可空值的几个原因:</p><blockquote class="ol om on"><p id="6b42" class="kr ks mz kt b ku kv jr kw kx ky ju kz oo lb lc ld op lf lg lh oq lj lk ll lm ij bi translated">我很懒，编译器会抱怨</p><p id="9224" class="kr ks mz kt b ku kv jr kw kx ky ju kz oo lb lc ld op lf lg lh oq lj lk ll lm ij bi translated">98%的情况下它不是未定义的</p><p id="9f97" class="kr ks mz kt b ku kv jr kw kx ky ju kz oo lb lc ld op lf lg lh oq lj lk ll lm ij bi translated">“我不知道那有什么用”</p></blockquote><p id="ac0b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们想告诉编译器<code class="fe nn no np nq b">askPrice</code>和<code class="fe nn no np nq b">bidPrice</code>可能是<code class="fe nn no np nq b">undefined</code>。因此，当我们试图访问这些属性而没有检查类型或者它们是否预先存在时，编译器会警告我们。</p><pre class="kg kh ki kj gt nr nq ns nt aw nu bi"><span id="4ba5" class="nv mc iq nq b gy nw nx l ny nz">interface Price {<br/>    correlationId: string;<br/>    askPrice?: number;<br/>    bidPrice?: number;<br/>}</span><span id="0f91" class="nv mc iq nq b gy ot nx l ny nz">// or</span><span id="3945" class="nv mc iq nq b gy ot nx l ny nz">interface Price {<br/>    correlationId: string;<br/>    askPrice: number | undefined;<br/>    bidPrice: number | undefined;<br/>}</span></pre><p id="8cb3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这意味着<strong class="kt ir">编译器帮助我们避免运行时错误</strong>当那2%的时候发生。</p><p id="0e9f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">诚实的类型化还有助于我们的新同事或我们库的用户完全理解应用程序的领域实体。</p><p id="9ac0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">从字面上看，没有理由不将客户端实体完全严格地类型化为后端实体。</p><h2 id="ecdf" class="nv mc iq bd md oa ob dn mh oc od dp ml la oe of mn le og oh mp li oi oj mr ok bi translated">没有隐含的任何</h2><p id="dd94" class="pw-post-body-paragraph kr ks iq kt b ku mt jr kw kx mu ju kz la mv lc ld le mw lg lh li mx lk ll lm ij bi translated">正如我们在上一段中看到的，诚实和严格的类型在确保我们的代码以正确的方式运行方面起着重要的作用。</p><p id="1ec2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">诚实输入与选项<em class="mz">无插入相关。</em></p><p id="3eeb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们考虑下面的片段:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ou"><img src="../Images/5c296b8304a8f1beb324d3be87866c2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q5cL6jF2ICpRbWkPKWhpFw.png"/></div></div></figure><p id="5418" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">编译器不知道<code class="fe nn no np nq b">x</code>和<code class="fe nn no np nq b">y</code>是什么，在某些情况下，它自己也搞不清楚。</p><blockquote class="na"><p id="6891" class="nb nc iq bd nd ne nf ng nh ni nj lm dk translated">不要偷懒，把你的代码打出来。</p></blockquote><p id="d765" class="pw-post-body-paragraph kr ks iq kt b ku ov jr kw kx ow ju kz la ox lc ld le oy lg lh li oz lk ll lm ij bi translated">有些情况下，编译器不需要我们显式添加类型就能判断出来，但是在这些情况下，您需要考虑添加类型是增加还是降低了代码的可读性。</p><h1 id="03ce" class="mb mc iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">干净的打字稿代码</h1><h2 id="4c0b" class="nv mc iq bd md oa ob dn mh oc od dp ml la oe of mn le og oh mp li oi oj mr ok bi translated">使用可预测的命名约定</h2><p id="cadc" class="pw-post-body-paragraph kr ks iq kt b ku mt jr kw kx mu ju kz la mv lc ld le mw lg lh li mx lk ll lm ij bi translated">虽然linters和formatters在确保我们代码库的一致性方面是很好的盟友，但有些事情他们仍然无能为力:命名。</p><p id="9afb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">使用您团队能够理解的可预测的命名约定是确保整洁、一致和清晰的基础。</p><p id="7552" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">考虑下面的片段，这是我经常遇到的场景:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pa"><img src="../Images/f4a4e82c65bce085c1c23c65eb6500fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jAvSp7tyXSfZmhe_ZNzE-Q.png"/></div></div></figure><p id="7787" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">显然，<strong class="kt ir">我不是说命名很容易</strong>。不是的。</p><p id="c919" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是如果你遵循最基本的原则，你仍然领先于许多人。我想建议的一些事情是:</p><ul class=""><li id="11e2" class="ln lo iq kt b ku kv kx ky la lp le lq li lr lm ls lt lu lv bi translated">如果你的方法不返回任何东西，不要在它前面加上前缀<em class="mz"> get </em></li><li id="ff12" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">如果你的方法返回一些东西，不要在前面加上<em class="mz"> set </em></li><li id="aea6" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">理想情况下，不要用同样的方法设置和获取…</li><li id="e604" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">如果你的方法返回一个布尔值，考虑在它前面加上<em class="mz"> is </em>或者<em class="mz">should(is thingvisible，shouldShowError，等等)。)</em></li><li id="f893" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">不要用变量的类型来命名变量</li><li id="eb81" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">如果您使用的DSL来自不同的库或框架，请遵循它们的约定。例如，如果你用<em class="mz"> RxJS </em>声明一个可观察对象，确保在它后面加上美元符号($)</li></ul><h2 id="cf31" class="nv mc iq bd md oa ob dn mh oc od dp ml la oe of mn le og oh mp li oi oj mr ok bi translated">使用别名</h2><p id="789c" class="pw-post-body-paragraph kr ks iq kt b ku mt jr kw kx mu ju kz la mv lc ld le mw lg lh li mx lk ll lm ij bi translated">老实说，没有人喜欢在我们的类型脚本代码中到处看到相对导入。使用Typescript中的路径别名功能是使导入更好、更短的一个好方法。</p><p id="0e69" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">别名是如何工作的？</p><p id="7f45" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们在<code class="fe nn no np nq b">tsconfig.json</code>中定义了<code class="fe nn no np nq b">paths</code>配置。请参见下面的示例:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pb"><img src="../Images/c5602acc88e55fc7004e83d17d6cd64b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_1zVUzTV4cmAwS_p8Ki9fw.png"/></div></div></figure><p id="ae08" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后，我可以从<code class="fe nn no np nq b">@core/interfaces</code>访问我的所有界面，从<code class="fe nn no np nq b">enums.</code>访问我的所有枚举</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pc"><img src="../Images/2b645055a5c492b89764d5586dfba60c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_VwO_1qoi2i1aoU0mTfaVw.png"/></div></div></figure><h2 id="e9b4" class="nv mc iq bd md oa ob dn mh oc od dp ml la oe of mn le og oh mp li oi oj mr ok bi translated">喜欢垂直阅读</h2><p id="63ac" class="pw-post-body-paragraph kr ks iq kt b ku mt jr kw kx mu ju kz la mv lc ld le mw lg lh li mx lk ll lm ij bi translated">不是每个人都同意我的观点，但我非常相信这会影响代码的整体可读性。</p><p id="acbf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我喜欢将我的代码行保持在80到120列之间，这取决于我的团队对此的看法。但我倾向于将其设置为80。</p><p id="deb1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们来看看我的一个项目片段的不同之处。在下图中，水平长度设置为120。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pd"><img src="../Images/8ce9d8a78cef0a42fa1bdc3f42f394d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HuZwRELp053NnZV_wWChEA.png"/></div></div></figure><p id="7599" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在下一个示例中，它被设置为80。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pe"><img src="../Images/f1734fc1a4c588dfda543c0e3e1fafef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bAg9o5s4LXTRnYLE0zUnjw.png"/></div></div></figure><p id="08d1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你说哪个更容易阅读和修改？</p><blockquote class="ol om on"><p id="aa29" class="kr ks mz kt b ku kv jr kw kx ky ju kz oo lb lc ld op lf lg lh oq lj lk ll lm ij bi translated">💡<strong class="kt ir">专业提示</strong>:使用beauty为你自动换行</p></blockquote><h2 id="8195" class="nv mc iq bd md oa ob dn mh oc od dp ml la oe of mn le og oh mp li oi oj mr ok bi translated">箭头功能很酷，但不要滥用它们</h2><p id="bc96" class="pw-post-body-paragraph kr ks iq kt b ku mt jr kw kx mu ju kz la mv lc ld le mw lg lh li mx lk ll lm ij bi translated">我喜欢箭头函数。我也经常使用它们。但我不时看到他们被虐待。</p><p id="3ce7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">箭头函数非常适合小的表达式，但是对于更长更复杂的表达式，我宁愿创建一个函数块。</p><p id="ea0d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">有时我会看到非常复杂的表达式，只是为了使用一个箭头函数。</p><p id="91e6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们来看看一个长表达式和一个单行的箭头函数之间的区别:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pf"><img src="../Images/921342eb50bd0389fc64368f6c0e506d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SX0FtvRe_HRsUAWcMTBs6g.png"/></div></div></figure><p id="cb5a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">和带有块的箭头函数:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pg"><img src="../Images/5d4a629fd1e4318467be750b0cbd719c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EzXx8gQCcuhglxaQl2vAbQ.png"/></div></div></figure><p id="55b7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">仍然使用箭头函数并将表达式放在下一行是完全可能的，但是当我碰巧重构代码时，我觉得这会增加复杂性，例如，如果我需要在表达式中添加一个变量。</p><p id="4b09" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你用一个箭头函数来包装它，这是非常好的，确保这段代码不会很快被修改。</p><h2 id="b67e" class="nv mc iq bd md oa ob dn mh oc od dp ml la oe of mn le og oh mp li oi oj mr ok bi translated">使用逻辑间距</h2><p id="5573" class="pw-post-body-paragraph kr ks iq kt b ku mt jr kw kx mu ju kz la mv lc ld le mw lg lh li mx lk ll lm ij bi translated">就像在Medium中一样，空白虽然不太多，但会影响可读性。</p><p id="8a5e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们的代码也是如此:我们希望在有意义的地方增加间距。</p><p id="8030" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">有些代码感觉就像一堵没有任何逻辑分隔的文本墙。这不是一个简单的任务，因为每个人对它的感觉可能不同，而且很大程度上可能取决于每个人的偏好。</p><p id="2459" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我认为添加空格有两个主要原因:</p><ul class=""><li id="e6b1" class="ln lo iq kt b ku kv kx ky la lp le lq li lr lm ls lt lu lv bi translated">逻辑原因，因为它涉及到我们代码背后的逻辑</li><li id="4437" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">设计原因，因为它关系到代码的易读性</li></ul><p id="be42" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我不会谈论它背后的设计原因，因为这感觉太主观了。就我个人而言，我只是试着遵循这些简单的准则:</p><ul class=""><li id="4a53" class="ln lo iq kt b ku kv kx ky la lp le lq li lr lm ls lt lu lv bi translated">逻辑分组变量声明</li><li id="b74a" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">在返回语句和函数体之间保留一个空格</li></ul><p id="b218" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果我们用两组不同的常量构建两个不同的对象，我们很可能想要在它们之间添加一个空格。例如:</p><pre class="kg kh ki kj gt nr nq ns nt aw nu bi"><span id="f601" class="nv mc iq nq b gy nw nx l ny nz">const name = "..";<br/>const surname = "..";<br/>const player = { name, surname };</span><span id="b1b2" class="nv mc iq nq b gy ot nx l ny nz">// logical break<br/>const teamName = "..";<br/>const teamId = "..";<br/>const team = { teamName, teamId };</span><span id="af0c" class="nv mc iq nq b gy ot nx l ny nz">return { player, team };</span></pre><h2 id="d86e" class="nv mc iq bd md oa ob dn mh oc od dp ml la oe of mn le og oh mp li oi oj mr ok bi translated">分解复杂的表达式</h2><p id="16d5" class="pw-post-body-paragraph kr ks iq kt b ku mt jr kw kx mu ju kz la mv lc ld le mw lg lh li mx lk ll lm ij bi translated">在我们的代码中，很容易出现各种又长又复杂的表达式。</p><p id="5a68" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我建议将长表达式分解成变量组和独立的方法。</p><ul class=""><li id="c217" class="ln lo iq kt b ku kv kx ky la lp le lq li lr lm ls lt lu lv bi translated">如果一个条件有2或3个以上的表达式，您应该考虑将其分解</li><li id="3a53" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">如果条件包含神奇的字符串和数字，您应该考虑将表达式提取到一个方法中</li></ul><p id="1651" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们看一个场景，我们有两个可能未定义的对象，我相信你每天都会看到:</p><pre class="kg kh ki kj gt nr nq ns nt aw nu bi"><span id="b8f5" class="nv mc iq nq b gy nw nx l ny nz">execute() {<br/>    if (price &amp;&amp; price.canExecute &amp;&amp; user &amp;&amp; user.hasPermissions &amp;&amp; service.status === 1) {<br/>    return priceService.execute(price);<br/>    }<br/>}</span></pre><p id="396a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">可能是我视力不好，但我看不懂那个！让我们来重构一下:</p><pre class="kg kh ki kj gt nr nq ns nt aw nu bi"><span id="ca0c" class="nv mc iq nq b gy nw nx l ny nz">execute() {<br/>    const STATUS_CODE_UP = 1;<br/>    const isServiceDown = service.status !== STATUS_CODE_UP;</span><span id="dfa5" class="nv mc iq nq b gy ot nx l ny nz">if (isServiceDown) {<br/>        return;<br/>    }</span><span id="6ad0" class="nv mc iq nq b gy ot nx l ny nz">if (!price.canExecute || !user.hasPermissions) {<br/>        return;<br/>    }</span><span id="7caa" class="nv mc iq nq b gy ot nx l ny nz">return priceService.execute(price);<br/>}</span></pre><p id="fa9a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">好吧，我可以读这个，但现在只是觉得太长了。让我们再次重构:</p><pre class="kg kh ki kj gt nr nq ns nt aw nu bi"><span id="574d" class="nv mc iq nq b gy nw nx l ny nz">const STATUS_CODE_UP = 1; // ideally imported from another file</span><span id="1eb1" class="nv mc iq nq b gy ot nx l ny nz">get isServiceUp() {<br/>    return service.status === STATUS_CODE_UP;<br/>}</span><span id="863d" class="nv mc iq nq b gy ot nx l ny nz">get canExecute() {<br/>    if (!price || !user) {<br/>        return;<br/>    }</span><span id="a5a7" class="nv mc iq nq b gy ot nx l ny nz">return price.canExecute &amp;&amp; user.hasPermissions;<br/>}</span><span id="5a43" class="nv mc iq nq b gy ot nx l ny nz">execute() {<br/>   const canExecute = this.isServiceUp &amp;&amp; this.canExecute;<br/>   return canExecute &amp;&amp; priceService.execute(price);<br/>}</span></pre><p id="abad" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">那感觉好多了！</p><h1 id="cb4a" class="mb mc iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">外卖食品</h1><ul class=""><li id="6ba2" class="ln lo iq kt b ku mt kx mu la ph le pi li pj lm ls lt lu lv bi translated">Lint并格式化你的代码</li><li id="431d" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">对你的代码要严谨，启用<code class="fe nn no np nq b">strict</code>模式</li><li id="4fa1" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">打得好，经常打。不要用<em class="mz"> any、</em>用泛型和<em class="mz">未知的</em>代替</li><li id="f37c" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">遵循行业标准，确保您的代码尽可能具有可读性</li></ul><p id="688f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="mz">如果你喜欢这篇文章，请关注我的</em> <a class="ae my" href="https://medium.com/@.gc" rel="noopener"> <em class="mz"> Medium </em> </a> <em class="mz">或</em><a class="ae my" href="https://twitter.com/home" rel="noopener ugc nofollow" target="_blank"><em class="mz">Twitter</em></a><em class="mz">以获取更多关于Angular、RxJS、Typescript等的文章！</em></p></div><div class="ab cl pk pl hu pm" role="separator"><span class="pn bw bk po pp pq"/><span class="pn bw bk po pp pq"/><span class="pn bw bk po pp"/></div><div class="ij ik il im in"><p id="29c4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="mz">原载于</em><a class="ae my" href="https://frontend.consulting/writing-scalable-typescript" rel="noopener ugc nofollow" target="_blank"><em class="mz">https://frontend . consulting</em></a><em class="mz">。</em></p></div></div>    
</body>
</html>