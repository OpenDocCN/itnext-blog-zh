<html>
<head>
<title>Use a Vuex Store with Typing in TypeScript: A Solution Compatible with the Vue 3 Composition API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Vuex存储并在TypeScript中键入:与Vue 3组合API兼容的解决方案</h1>
<blockquote>原文：<a href="https://itnext.io/use-a-vuex-store-with-typing-in-typescript-without-decorators-or-boilerplate-57732d175ff3?source=collection_archive---------1-----------------------#2019-10-13">https://itnext.io/use-a-vuex-store-with-typing-in-typescript-without-decorators-or-boilerplate-57732d175ff3?source=collection_archive---------1-----------------------#2019-10-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/d14977ed5cc15cc3f5825dfac4dddaaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H8qkp80OAMAKF-AeFdbOGQ.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">感谢<a class="ae kc" href="https://www.goodfreephotos.com/south-africa/cape-town/long-beach-landscape-in-capetown-south-africa.jpg.php" rel="noopener ugc nofollow" target="_blank">好的免费照片</a>。</figcaption></figure><p id="5a75" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我发现了一种在TypeScript中使用Vuex存储而不丢失键入的方法。它不需要类，所以它兼容Vue 3和composition API。</p><h1 id="1727" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用完全类型化的轻量级包装器</h1><p id="2bf9" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">在运行时，库direct-vuex将在每个getters、突变和动作周围创建一个包装器。我们可以在商店实现之外使用它们。</p><p id="9130" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以与其写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="6382" class="mn lc iq mj b gy mo mp l mq mr">store.dispatch("myAction", myPayload);</span></pre><p id="24e4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">…我们写道:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="58b1" class="mn lc iq mj b gy mo mp l mq mr">store.dispatch.myAction(myPayload);</span></pre><p id="a145" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者，不写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="bbe8" class="mn lc iq mj b gy mo mp l mq mr">store.dispatch("myModule/myAction", myPayload);</span></pre><p id="1a5d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">…我们写道:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="e3b1" class="mn lc iq mj b gy mo mp l mq mr">store.dispatch.myModule.myAction(myPayload);</span></pre><p id="bbfb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Getters和mutations的访问方式相同:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="9f41" class="mn lc iq mj b gy mo mp l mq mr">store.getters.myModule.myGetter;<br/>store.commit.myModule.myMutation(myPayload);<!-- --> </span></pre><p id="2ff7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">TypeScript可以正确推断这些包装的类型。</p><h1 id="328d" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">如何创建直营店</h1><p id="7d57" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">商店可以像往常一样实现。这里有一个模块:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="240e" class="mn lc iq mj b gy mo mp l mq mr"><em class="ms">// module1.ts</em></span><span id="137d" class="mn lc iq mj b gy mt mp l mq mr">export interface Module1State {<br/>  name: null | string<br/>}</span><span id="7fec" class="mn lc iq mj b gy mt mp l mq mr">export default {<br/>  namespaced: true as true,<br/>  state: {<br/>    name: null<br/>  } as Module1State,<br/>  getters: {<br/>    message: state =&gt; `Hello, ${state.name}!`<br/>  },<br/>  mutations: {<br/>    SET_NAME(state, newName: string) {<br/>      state.name = newName<br/>    },<br/>  },<br/>  actions: {<br/>    async loadName({ commit }, payload: { id: string }) {<br/>      const name = `Name-${payload.id}` <em class="ms">// load it from somewhere</em><br/>      commit("SET_NAME", name)<br/>      return { name }<br/>    },<br/>  }<br/>}</span></pre><p id="3756" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">无论如何，一个小细节:当我们用老方法编写商店代码时，唯一的一件小事是必须声明<code class="fe mu mv mw mj b">namespaced: true as true</code>。Direct-vuex需要知道<code class="fe mu mv mw mj b">namespaced</code>的字面类型(类型<code class="fe mu mv mw mj b">true</code>或者<code class="fe mu mv mw mj b">false</code>而不是<code class="fe mu mv mw mj b">boolean</code>)。</p><p id="cfc6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我们可以使用direct-vuex创建商店。</p><p id="06e8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，将direct-vuex添加到Vue应用程序:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="8599" class="mn lc iq mj b gy mo mp l mq mr">npm install direct-vuex</span></pre><p id="93ea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，创建商店:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="bfc8" class="mn lc iq mj b gy mo mp l mq mr"><em class="ms">// store.ts<br/></em>import Vue from "vue"<br/>import Vuex from "vuex"<br/>import { createDirectStore } from "direct-vuex"<br/>import module1 from "./module1"</span><span id="0819" class="mn lc iq mj b gy mt mp l mq mr">Vue.use(Vuex)</span><span id="a854" class="mn lc iq mj b gy mt mp l mq mr">const { store, rootActionContext, moduleActionContext } = createDirectStore({<br/>  modules: {<br/>    module1<br/>  }<br/>})</span><span id="25a3" class="mn lc iq mj b gy mt mp l mq mr"><em class="ms">// Export the direct-store instead of the classic Vuex store.</em><br/>export default store</span><span id="eb29" class="mn lc iq mj b gy mt mp l mq mr"><em class="ms">// The following exports will be used to enable types in the</em><br/><em class="ms">// implementation of actions.</em><br/>export { rootActionContext, moduleActionContext }</span><span id="6d5f" class="mn lc iq mj b gy mt mp l mq mr"><em class="ms">// The following lines enable types in the injected store '$store'.</em><br/>export type AppStore = typeof store<br/>declare module "vuex" {<br/>  interface Store&lt;S&gt; {<br/>    direct: AppStore<br/>  }<br/>}</span></pre><p id="59df" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">与您通常的代码相比，<code class="fe mu mv mw mj b">new Vuex.Store(options)</code>被替换为<code class="fe mu mv mw mj b">createDirectStore(options)</code>。事实上，<code class="fe mu mv mw mj b">createDirectStore()</code>函数只是简单地为您调用<code class="fe mu mv mw mj b">new Vuex.Store()</code>，然后返回一个带有包装器的直接商店和一个围绕经典Vuex商店的良好类型。</p><p id="9a91" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们从模块<code class="fe mu mv mw mj b">vuex</code>中用我们的良好类型的直接存储来扩充类型<code class="fe mu mv mw mj b">Store</code>。</p><p id="ed9b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">就是这样！</p><p id="79ae" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">direct-vuex提供的存储已经包含了所有类型良好的状态、getters、突变和动作。</p><h1 id="df65" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用直营店</h1><p id="8f4d" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">经典的Vuex商店仍然可以通过<code class="fe mu mv mw mj b">store.original</code>属性访问。我们需要它来初始化Vue应用程序:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="1e13" class="mn lc iq mj b gy mo mp l mq mr">import Vue from "vue"<br/>import store from "./store"<br/>import App from "./App.vue"</span><span id="e362" class="mn lc iq mj b gy mt mp l mq mr">new Vue({<br/>  store: store.original, <em class="ms">// Inject the classic Vuex store</em><br/>  render: h =&gt; h(App),<br/>}).$mount("#app")</span></pre><p id="5588" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注入的店还是经典的Vuex店。但是它有一个<code class="fe mu mv mw mj b">direct</code>属性，包含我们的良好类型存储。我们可以使用它，或者直接在每个需要它的组件中导入存储:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="e66c" class="mn lc iq mj b gy mo mp l mq mr">import store from "./store";<br/>// or: const store = this.$store.direct;</span><span id="f758" class="mn lc iq mj b gy mt mp l mq mr">async function test() {<br/>  store.state.otherModule <em class="ms">// Error.</em></span><span id="642c" class="mn lc iq mj b gy mt mp l mq mr">  store.state.module1.name <em class="ms">// Ok, type is 'string | null'.</em><br/>  store.state.module1.otherProp <em class="ms">// Error.</em></span><span id="84b2" class="mn lc iq mj b gy mt mp l mq mr">  store.getters.module1.message <em class="ms">// Ok, type is 'string'.</em><br/>  store.getters.module1.otherProp <em class="ms">// Error.</em></span><span id="092b" class="mn lc iq mj b gy mt mp l mq mr">  store.commit.module1.SET_NAME("abc") <em class="ms">// Ok.</em><br/>  store.commit.module1.SET_NAME(123) <em class="ms">// Error.</em><br/>  store.commit.module1.OTHER_PROP(123) <em class="ms">// Error.</em></span><span id="4f8c" class="mn lc iq mj b gy mt mp l mq mr">  const result = await store.dispatch.module1.loadName({ id: "12" })<br/>                 <em class="ms">// Ok, result type is: '{ name: string }'</em><br/>  store.dispatch.module1.loadName({ otherPayload: "12" }) <em class="ms">// Error</em><br/>}</span></pre><p id="cda1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如你所见，不再有<code class="fe mu mv mw mj b">any</code>。整个存储区的类型都是正确的，这得益于IDE中的自动完成功能。</p><p id="29b0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意，direct-vuex不是vuex的重写，而只是一个非常轻量级的包装器。所以，你所知道的关于Vuex的一切仍然适用，因为它仍然是Vuex在地下工作。如果您愿意，您可以通过注入的<code class="fe mu mv mw mj b">this.$store</code>或<code class="fe mu mv mw mj b">store.original</code>同时使用底层的Vuex存储。</p><h1 id="d468" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用Direct-vuex编写商店的实现</h1><p id="38fb" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">这是<a class="ae kc" href="https://github.com/paleo/direct-vuex#implement-a-vuex-store-with-typed-helpers" rel="noopener ugc nofollow" target="_blank">的文件</a>。</p><p id="11df" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">希望这个小图书馆能有所帮助。</p></div></div>    
</body>
</html>