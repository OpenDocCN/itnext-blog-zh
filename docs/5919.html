<html>
<head>
<title>11 Actions Everyone can Do to Improve Their Cloud Native Security Posture</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">每个人都可以采取的11项行动来改善他们的云原生安全状况</h1>
<blockquote>原文：<a href="https://itnext.io/11-actions-everyone-can-implement-to-improve-your-cloud-native-security-posture-9bd7a0d26ec5?source=collection_archive---------4-----------------------#2021-06-29">https://itnext.io/11-actions-everyone-can-implement-to-improve-your-cloud-native-security-posture-9bd7a0d26ec5?source=collection_archive---------4-----------------------#2021-06-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="eeb5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如何保护您的中小型云基础架构</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/522a4883ae3b2cb8ee152f2f66427e54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BNCwYYU4ICC5jDr6"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">由<a class="ae lb" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae lb" href="https://unsplash.com/@chuttersnap?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> CHUTTERSNAP </a>拍摄</figcaption></figure><p id="997e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">设置:</strong>您在一个中小型组织中维护着一个中小型Kubernetes集群，有几个应用程序，几乎没有专用的开发运维/SRE资源。那么，从哪里开始保护这些API、pod和容器呢？这里有11个捕捉低挂水果的动作，提高你的Kubernetes安全姿态。他们没有排名，但有些可能会参考其他人。</p><h1 id="dbfa" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">1.创建资产清单</h1><p id="d7aa" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">“如果你不知道你有什么，你怎么捍卫它？”</p><p id="d2f2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">更新资产清单对于跟踪组织中的资产至关重要。这至少应该是组织使用和维护的不同软件组件的列表、当前版本、它们是现成的、定制的还是定制的、在哪里可以找到它们(例如，到文档、存储库等的链接)。).</p><p id="c8e1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这对于分布式系统尤其重要，在分布式系统中，软件组件作为容器化的工作负载分布在多个微服务上。理想情况下，资产清单还应该包含给定组件通信的服务、它使用的API等的概述。</p><p id="5782" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Anchore Syft是一个CLI工具和Golang库，用于从容器映像和文件系统生成软件材料清单(SBOM)。Syft支持来自多个生态系统的包和库，如APK、DEB、RPM、Ruby Bundles、Python Wheel/Egg/requirements . txt、JavaScript NPM/Yarn、Java JAR/EAR/WAR、Jenkins plugins JPI/HPI、Go模块等。，以及像Alpine、BusyBox、RedHat和Debian/Ubuntu这样的Linux发行版:<a class="ae lb" href="https://github.com/anchore/syft" rel="noopener ugc nofollow" target="_blank">https://github.com/anchore/syft</a></p><h1 id="c338" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">2.创建一个威胁模型</h1><p id="2bbe" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">一般来说，威胁建模允许您识别威胁，了解每个威胁的影响，并为它们制定缓解策略。目标是突出您的IT生态系统中的风险。</p><p id="7cc2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在Kubernetes中，你会想要描绘出不同的组件交互(api-server，etcd，kubelet，kube-proxy，等等)。)因为这些在默认情况下不一定是安全的。</p><p id="5f3b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不同的威胁参与者将具有不同的能力，从广义上讲，我们将最终用户、内部攻击者和特权攻击者区分开来。终端用户通常从群集外部连接到某个入口，而内部攻击者在群集内部拥有一些有限的(不一定是root权限)访问权限:例如，pod中的外壳。另一方面，有特权的攻击者可以访问api-server(想想kubectl和sysadmin特权)。</p><p id="c782" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对您的基础架构和应用程序进行威胁建模。在Kubernetes中，一个应用程序可能在多个名称空间的多个pods中有多个组件，因此在应用程序级别上规划风险也很重要。如果攻击者设法逃离一个pod并访问底层节点，该节点上的其他pod也将可见并很容易受到危害。</p><p id="a7c4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您不会发现威胁模型中的所有内容，但它会让您对生态系统中的风险有一个总体了解，并为它们提供一个缓解策略。</p><p id="c028" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">威胁建模有多种详细的框架。例如，参见微软的STRIDE框架或Tony UcedaVélez和Marco M. Morana的关于PASTA(攻击模拟和威胁分析过程)威胁建模的书:<a class="ae lb" href="https://www.amazon.com/Risk-Centric-Threat-Modeling-Simulation/dp/0470500964" rel="noopener ugc nofollow" target="_blank">“以风险为中心的威胁建模:攻击模拟和威胁分析过程。”</a></p><h1 id="c1ef" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">3.将基础设施用作代码(IaC)</h1><p id="b470" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">使用人类可读和机器可使用的模板文件来调配和管理云资源。在较小的环境中，您可能会满足于使用Gitlab的一键式Kubernetes集成在CI/CD管道内部或外部提供一个集群并安装带有<code class="fe mf mg mh mi b">kubectl apply -f resource.yaml</code>的实用程序。</p><p id="84c6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这种方法中，您会失去很多可见性。IaC设置为不同的基础设施相关资源*及其设置*提供了清晰的参考。您不必查看web控制台或依赖kubectl来处理“所有事情”它也比“点击操作”方法更加稳定和安全。如果您在web控制台中更改了错误的设置，将会损坏东西。IaC为您提供了一个更加健壮的工作流，尤其是在与VCS(例如Git)结合使用时。当谈到集群强化时，我们希望对于不同的配置有一个真实的来源。如果您设置了名称空间、策略、访问控制、安全机制等。，有了IaC，你总是知道它的当前配置和版本存在于什么地方。</p><p id="9cb1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">IaC会在您的工作流中产生开销，但是ROI是巨大的，尤其是在保护您的云生态系统时。</p><h1 id="4693" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">4使用名称空间对工作负载进行逻辑隔离</h1><p id="b400" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">使用名称空间来加强应用程序的逻辑隔离。通过将应用程序隔离在各自的名称空间中，我们可以通过预定义的规则(网络策略)来管理通信</p><h1 id="941e" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">4.1资源配额</h1><p id="1ded" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">资源配额可以应用于资源和命名空间级别。资源配额提供了限制在给定命名空间(或给定应用程序)中可以请求的资源总数(CPU/内存)的约束。这对于阻止加密挖掘攻击至关重要，在加密挖掘攻击中，攻击者消耗集群资源来挖掘加密货币，或者限制内存泄漏的后果以及应用程序可能出现的其他性能问题。</p><h1 id="dae9" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">5使用基于角色的访问控制(RBAC)</h1><p id="8f38" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">在Kubernetes中实现“最小特权原则”的第一步是使用RBAC。RBAC是一种基于授予用户或组的角色来管理对API和资源的访问的模型。RBAC建立在角色和角色绑定的基础上，其中角色是权限的集合，而角色绑定将权限与主题相关联。</p><p id="6447" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以下代码片段描述了一个Kubernetes角色，用Terraform的配置语言HCL编写。开发人员角色有两种不同的规则，一组是他们可以做任何事情的资源，另一组是他们只能读取的资源。</p><pre class="km kn ko kp gt mj mi mk ml aw mm bi"><span id="8cbb" class="mn ld iq mi b gy mo mp l mq mr">resource "kubernetes_cluster_role" "dev" {</span><span id="979c" class="mn ld iq mi b gy ms mp l mq mr">  metadata {</span><span id="ea59" class="mn ld iq mi b gy ms mp l mq mr">    name = "developer"</span><span id="c60f" class="mn ld iq mi b gy ms mp l mq mr">  }</span><span id="3b42" class="mn ld iq mi b gy ms mp l mq mr">  rule {</span><span id="fa5a" class="mn ld iq mi b gy ms mp l mq mr">    api_groups = ["*"]</span><span id="6de2" class="mn ld iq mi b gy ms mp l mq mr">    resources = var.rbac_developer_allowed_resources</span><span id="7c3a" class="mn ld iq mi b gy ms mp l mq mr">    verbs = ["*"]</span><span id="2884" class="mn ld iq mi b gy ms mp l mq mr">  }</span><span id="084d" class="mn ld iq mi b gy ms mp l mq mr">  rule {</span><span id="0a96" class="mn ld iq mi b gy ms mp l mq mr">    api_groups = ["*"]</span><span id="e21c" class="mn ld iq mi b gy ms mp l mq mr">    resources = var.rbac_developer_readonly_resources</span><span id="2ada" class="mn ld iq mi b gy ms mp l mq mr">    verbs = ["get", "list", "watch"]</span><span id="cf0f" class="mn ld iq mi b gy ms mp l mq mr">  }</span><span id="1a45" class="mn ld iq mi b gy ms mp l mq mr">}</span></pre><p id="bb8e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">集群角色只是一个全局角色(为所有名称空间定义一次)，而我们更喜欢在每个名称空间级别上保留角色绑定本身:</p><pre class="km kn ko kp gt mj mi mk ml aw mm bi"><span id="67e8" class="mn ld iq mi b gy mo mp l mq mr">resource "kubernetes_role_binding" "developer_binding" {</span><span id="b6c0" class="mn ld iq mi b gy ms mp l mq mr">  metadata {</span><span id="eff2" class="mn ld iq mi b gy ms mp l mq mr">    name = "developer-binding"</span><span id="f054" class="mn ld iq mi b gy ms mp l mq mr">    namespace = "namespace0"</span><span id="5bba" class="mn ld iq mi b gy ms mp l mq mr">  }</span><span id="1150" class="mn ld iq mi b gy ms mp l mq mr">  role_ref {</span><span id="89f2" class="mn ld iq mi b gy ms mp l mq mr">    api_group = "rbac.authorization.k8s.io"</span><span id="87e4" class="mn ld iq mi b gy ms mp l mq mr">    kind = "ClusterRole"</span><span id="72d8" class="mn ld iq mi b gy ms mp l mq mr">    name = "developer"</span><span id="8b8d" class="mn ld iq mi b gy ms mp l mq mr">  }</span><span id="6661" class="mn ld iq mi b gy ms mp l mq mr">  subject {</span><span id="2106" class="mn ld iq mi b gy ms mp l mq mr">    kind = "User"</span><span id="f516" class="mn ld iq mi b gy ms mp l mq mr">    name = "Martin"</span><span id="c9ae" class="mn ld iq mi b gy ms mp l mq mr">    api_group = "rbac.authorization.k8s.io"</span><span id="c9e5" class="mn ld iq mi b gy ms mp l mq mr">  }</span><span id="c629" class="mn ld iq mi b gy ms mp l mq mr">}</span></pre><p id="9d5f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这为用户“Martin”提供了名称空间“namespace0”中开发人员角色的权限。这意味着该用户不能访问其他名称空间中的任何资源。除非在这些命名空间中也创建了RoleBinding。</p><p id="fffc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Kubernetes支持各种主题，LDAP，Keycloak等。</p><p id="da11" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">链接:</p><ul class=""><li id="5512" class="mt mu iq jp b jq jr ju jv jy mv kc mw kg mx kk my mz na nb bi translated"><a class="ae lb" href="https://kubernetes.io/docs/reference/access-authn-authz/rbac/" rel="noopener ugc nofollow" target="_blank"> kubernetes文档</a></li><li id="3153" class="mt mu iq jp b jq nc ju nd jy ne kc nf kg ng kk my mz na nb bi translated"><a class="ae lb" href="https://registry.terraform.io/providers/hashicorp/kubernetes/latest/docs/resources/role" rel="noopener ugc nofollow" target="_blank">地形上的RBAC</a></li></ul><h1 id="fb31" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">6.实施网络策略</h1><p id="ac45" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">网络策略允许您指定允许哪些命名空间中的哪些pod或IP相互通信以及通过哪些端口通信。您的网络插件需要支持网络策略资源。</p><p id="671c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">网络策略可用于在IP和端口级别(OSI第3层和第4层)管理入口和出口。我建议至少使用出口策略。如果一个pod遭到破坏，攻击者只能通过网络策略中明确定义的端口向这些组件发送出站流量。虽然您应该同时使用入口和出口，但我们通常没有对入口流量的不同来源和端口的完整概述。明确定义允许这个pod与哪些应用程序对话要容易得多。</p><p id="af20" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">网络政策可能会让人不知所措，但这里有一些很棒的资源可供参考:</p><ul class=""><li id="517c" class="mt mu iq jp b jq jr ju jv jy mv kc mw kg mx kk my mz na nb bi translated">等值网在线netpol编辑:【https://editor.cilium.io/ T4】</li><li id="8ba3" class="mt mu iq jp b jq nc ju nd jy ne kc nf kg ng kk my mz na nb bi translated">Ahmet Alp Balkan的github repo of reference netpols，载有实际例子和解释清楚的理论:<a class="ae lb" href="https://github.com/ahmetb/kubernetes-network-policy-recipes" rel="noopener ugc nofollow" target="_blank">https://github.com/ahmetb/kubernetes-network-policy-recipes</a></li></ul><p id="e34b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">注意:</strong> Kubernetes将总是选择可能的最宽松的权限集(包括入口和出口)。如果同一个pod存在两个规则，“允许所有内容”和“允许访问特定IP”，那么Kubernetes将对它们进行and运算，这样pod就由“允许所有内容和允许访问特定IP”来管理。因此，您必须确保默认策略必须拒绝所有内容，然后其他规则必须开放特定的端口、名称空间和IP范围。</p><h1 id="4cde" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">7.保护好你的集装箱</h1><p id="ca58" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">保护您的容器运行时应该是您的首要任务之一，因为不安全的容器是极好的攻击媒介。</p><p id="5dc1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">容器应该总是以它们需要的最少特权运行。如果容器中的进程以root用户权限运行，则该容器在主机本身上也将具有root用户权限。因此，容器应该作为非根用户运行。这里的另一个陷阱是使用<code class="fe mf mg mh mi b">--privileged</code>标志以root身份运行整个容器。</p><pre class="km kn ko kp gt mj mi mk ml aw mm bi"><span id="de61" class="mn ld iq mi b gy mo mp l mq mr">apiVersion: v1</span><span id="731a" class="mn ld iq mi b gy ms mp l mq mr">kind: Pod</span><span id="8f8c" class="mn ld iq mi b gy ms mp l mq mr">metadata:</span><span id="275f" class="mn ld iq mi b gy ms mp l mq mr">  name: pod-security-context-demo</span><span id="e0d6" class="mn ld iq mi b gy ms mp l mq mr">spec:</span><span id="d50a" class="mn ld iq mi b gy ms mp l mq mr">  securityContext:</span><span id="d39e" class="mn ld iq mi b gy ms mp l mq mr">    runAsUser: 1000</span><span id="0320" class="mn ld iq mi b gy ms mp l mq mr">  containers:</span><span id="6998" class="mn ld iq mi b gy ms mp l mq mr">  - name: pod</span><span id="4c6a" class="mn ld iq mi b gy ms mp l mq mr">    image: busybox</span><span id="1dda" class="mn ld iq mi b gy ms mp l mq mr">    command: [ "sh", "-c", "sleep 1h" ]</span><span id="bcb3" class="mn ld iq mi b gy ms mp l mq mr">    securityContext:</span><span id="aae6" class="mn ld iq mi b gy ms mp l mq mr">      allowPrivilegeEscalation: false</span></pre><p id="7473" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当然，有些容器有特定的需求，要求它们以提升的权限运行。尽管如此，如果不尽可能多地放弃特权，就不应该以特权身份运行容器。PodSecurityContext对象(在SecurityContext字段中设置)是一种更好的方法，它可以查看是否可以使用addCapabilities参数为容器提供所需的最低权限。记住还要将allowPrivilegeEscalation设置为“false”。大部分强化工作可以在pod规范/部署中完成。</p><p id="2e8f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">容器应该是不可变的。通常，没有什么可以阻止一个正在运行的容器将额外的软件下载到它的文件系统中。攻击者可以利用这一点来安装恶意软件，并使用容器作为攻击的矛头。通过利用只读文件系统，可执行代码只在构建时添加到容器中，而不是在运行时安装，使得容器<em class="nh">不可变</em>。如果容器需要对本地存储进行写访问，可以根据需要为这些操作添加一个临时文件系统。</p><p id="c1eb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">安全配置文件应该用来限制容器在功能和权限方面可以做什么。虽然应该为每个应用程序定制安全配置文件，但这会带来大量开销和维护。推荐使用默认的Docker seccomp和AppArmor配置文件，因为它们引入了一些通用功能和防护栏，而不会对应用程序造成过多干扰。默认的docker seccomp配置文件阻塞了大约300个对Linux内核的系统调用中的40多个，而不会对绝大多数容器化的应用程序产生负面影响。如果您的Kubernetes节点支持SELinux，这也应该被认为是启用的。</p><p id="04b1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最大限度地减少容器映像的内容，从而在容器受损时减少攻击面。理想情况下，容器应该只包含应用程序运行所需的包和依赖项。考虑通过使用临时构建的“发行版”基础映像来精简容器映像，因为这些映像只包含应用程序及其运行时依赖项，而不包含软件包管理器、shells或其他在完整的Linux发行版中常见的实用程序。</p><p id="578e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">参见Liz Rice的书:集装箱安全</p><p id="aeee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae lb" href="https://kubernetes.io/docs/tasks/configure-pod-container/security-context/" rel="noopener ugc nofollow" target="_blank">https://kubernetes . io/docs/tasks/configure-pod-container/security-context/</a></p><h1 id="618f" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">8.设置安全扫描</h1><p id="5040" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">在现代环境中，自动安全扫描是“强制性的”。恶意软件大量存在，并且大多数工具易于添加，引入的开销很小。至少，您应该在容器上运行漏洞扫描和依赖扫描。除此之外，您应该有一个工具来检测源代码中的凭证，或者SAST/DAST工具，如Sonarqube或OWASP Zap基线扫描。</p><h1 id="cdab" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">图像扫描</h1><p id="192d" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">图像扫描可以作为识别漏洞和违反最佳实践/内部策略的一种方式。通常，我们可以区分内嵌扫描、在CI/CD管道中运行安全扫描工具和注册表扫描。注册表扫描是扫描存储在容器注册表中的图像的过程，而不是在构建时。这个特性内置于容器注册中心和大多数公共云中。有许多容器图像扫描工具，但像Clair或Anchore这样的开源工具有丰富的插件解决方案，如Jenkins插件和Github操作。例如参见<a class="ae lb" href="https://github.com/marketplace/actions/anchore-container-scan" rel="noopener ugc nofollow" target="_blank">https://github . com/market place/actions/anchore-container-scan</a>。</p><p id="f5c8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">其他资源:</p><ul class=""><li id="f32c" class="mt mu iq jp b jq jr ju jv jy mv kc mw kg mx kk my mz na nb bi translated"><a class="ae lb" href="https://sysdig.com/blog/image-scanning-best-practices/" rel="noopener ugc nofollow" target="_blank"> sysdig图像扫描最佳实践</a></li></ul><h1 id="8e97" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">依赖性扫描</h1><p id="ac7a" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">现代软件项目有许多依赖，它们的依赖有依赖(看看你，NPM)。随着有毒的NPM包裹等供应链攻击变得越来越普遍，执行依赖性扫描的需求变得突出。检查<a class="ae lb" href="https://snyk.io/" rel="noopener ugc nofollow" target="_blank"> Snyk </a>(商业)或<a class="ae lb" href="https://owasp.org/www-project-dependency-check/" rel="noopener ugc nofollow" target="_blank"> OWASP依赖检查</a>(免费)。传统上，OWASP项目在NPM软件包上表现不佳，并使用NVD数据作为威胁情报的唯一来源，而Snyk，一个商业产品，也从其他来源获取威胁情报。</p><h1 id="53de" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">9.使用准入控制器</h1><p id="075e" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">准入控制器是Kubernetes——本地组件，允许我们定义允许在集群中运行什么。你可以用Webhooks编写自己的准入控制器，或者使用例如<a class="ae lb" href="https://www.openpolicyagent.org/" rel="noopener ugc nofollow" target="_blank"> OpenPolicyAgent </a>。</p><p id="92cb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">OPA是一个“策略即代码”框架，允许您实施定制策略，例如要求白名单中的主机名，或者确保同一名称空间中没有两个入口资源具有相同的主机名。OPA gatekeeper是一个准入控制器，您可以使用它来验证从自定义策略到PodSecurityContexts的所有内容。网守库有一组广泛的策略示例。</p><p id="41c0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">另请参见:</p><ul class=""><li id="2e06" class="mt mu iq jp b jq jr ju jv jy mv kc mw kg mx kk my mz na nb bi translated"><a class="ae lb" href="https://sysdig.com/blog/image-scanning-admission-controller/" rel="noopener ugc nofollow" target="_blank">通过准入控制器上的图像扫描屏蔽您的Kubernetes运行时</a></li></ul><h1 id="d857" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">10.启用审核日志记录</h1><p id="766c" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">审计日志跟踪谁在何时做了什么。根据<a class="ae lb" href="https://kubernetes.io/docs/tasks/debug-application-cluster/audit/" rel="noopener ugc nofollow" target="_blank"> Kubernetes文档</a>，审计日志允许集群管理员回答以下问题:</p><ul class=""><li id="d719" class="mt mu iq jp b jq jr ju jv jy mv kc mw kg mx kk my mz na nb bi translated">发生了什么事？</li><li id="62ad" class="mt mu iq jp b jq nc ju nd jy ne kc nf kg ng kk my mz na nb bi translated">什么时候发生的？</li><li id="99f2" class="mt mu iq jp b jq nc ju nd jy ne kc nf kg ng kk my mz na nb bi translated">是谁发起的？</li><li id="df74" class="mt mu iq jp b jq nc ju nd jy ne kc nf kg ng kk my mz na nb bi translated">它发生在什么地方？</li><li id="5bf9" class="mt mu iq jp b jq nc ju nd jy ne kc nf kg ng kk my mz na nb bi translated">在哪里观察到的？</li><li id="e3ec" class="mt mu iq jp b jq nc ju nd jy ne kc nf kg ng kk my mz na nb bi translated">它是从哪里发起的？</li><li id="597e" class="mt mu iq jp b jq nc ju nd jy ne kc nf kg ng kk my mz na nb bi translated">它要去哪里？</li></ul><p id="56b7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要在集群中启用审计日志记录，您必须定义一个审计策略。记录事件后，会将其与设置事件审核级别的规则列表进行比较:</p><ul class=""><li id="09fc" class="mt mu iq jp b jq jr ju jv jy mv kc mw kg mx kk my mz na nb bi translated">无—不记录符合此规则的事件。</li><li id="32c6" class="mt mu iq jp b jq nc ju nd jy ne kc nf kg ng kk my mz na nb bi translated">元数据—日志请求元数据(请求用户、时间戳、资源、动词等)。)而不是请求或响应主体。</li><li id="9242" class="mt mu iq jp b jq nc ju nd jy ne kc nf kg ng kk my mz na nb bi translated">请求—记录事件元数据和请求正文，但不记录响应正文。这不适用于非资源请求。</li><li id="ba6a" class="mt mu iq jp b jq nc ju nd jy ne kc nf kg ng kk my mz na nb bi translated">RequestResponse —记录事件元数据、请求和响应正文。这不适用于非资源请求。</li></ul><p id="351b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是摘自Sysdig的默认审计策略脚本:</p><pre class="km kn ko kp gt mj mi mk ml aw mm bi"><span id="1dba" class="mn ld iq mi b gy mo mp l mq mr">apiVersion: audit.k8s.io/v1beta1 # This is required.</span><span id="9095" class="mn ld iq mi b gy ms mp l mq mr">kind: Policy</span><span id="d718" class="mn ld iq mi b gy ms mp l mq mr"># Don't generate audit events for all requests in RequestReceived stage.</span><span id="a6cd" class="mn ld iq mi b gy ms mp l mq mr">omitStages:</span><span id="2ecb" class="mn ld iq mi b gy ms mp l mq mr">  - "RequestReceived"</span><span id="086e" class="mn ld iq mi b gy ms mp l mq mr">rules:</span><span id="2acb" class="mn ld iq mi b gy ms mp l mq mr">  <em class="nh"># Log "pods/log", "pods/status" at Metadata level</em></span><span id="533c" class="mn ld iq mi b gy ms mp l mq mr">  - level: Metadata</span><span id="9dc1" class="mn ld iq mi b gy ms mp l mq mr">    resources:</span><span id="e4fb" class="mn ld iq mi b gy ms mp l mq mr">    - group: ""</span><span id="a36a" class="mn ld iq mi b gy ms mp l mq mr">      resources: ["pods/log", "pods/status"]</span><span id="0b81" class="mn ld iq mi b gy ms mp l mq mr"> <em class="nh"># Log the request body of configmap changes in kube-system.</em></span><span id="b5b2" class="mn ld iq mi b gy ms mp l mq mr">  - level: Request</span><span id="1da8" class="mn ld iq mi b gy ms mp l mq mr">    resources:</span><span id="c609" class="mn ld iq mi b gy ms mp l mq mr">    - group: "" <em class="nh"># core API group</em></span><span id="71ac" class="mn ld iq mi b gy ms mp l mq mr">      resources: ["configmaps"]</span><span id="6eab" class="mn ld iq mi b gy ms mp l mq mr">    <em class="nh"># This rule only applies to resources in the "kube-system" namespace.</em></span><span id="abcb" class="mn ld iq mi b gy ms mp l mq mr">    <em class="nh"># The empty string "" can be used to select non-namespaced resources.</em></span><span id="4d5e" class="mn ld iq mi b gy ms mp l mq mr">    namespaces: ["kube-system"]</span><span id="44a1" class="mn ld iq mi b gy ms mp l mq mr">  <em class="nh"># A catch-all rule to log all other requests at the Metadata level.</em></span><span id="9be2" class="mn ld iq mi b gy ms mp l mq mr">  - level: Metadata</span><span id="014e" class="mn ld iq mi b gy ms mp l mq mr">    <em class="nh"># Long-running requests like watches that fall under this rule will not</em></span><span id="c582" class="mn ld iq mi b gy ms mp l mq mr">    <em class="nh"># generate an audit event in RequestReceived.</em></span><span id="4273" class="mn ld iq mi b gy ms mp l mq mr">    omitStages:</span><span id="fcd4" class="mn ld iq mi b gy ms mp l mq mr">      - "RequestReceived"</span></pre><p id="be4b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如本例所示，您可以将审核级别指定到不同资源上的特定动词。该策略将首先从顶部评估事件，并从第一个匹配的规则设置事件的审核级别。在底部，所有其他事件都记录在元数据级别(除了<code class="fe mf mg mh mi b">omitStages</code>中的请求)。请注意，审计事件需要记录在某个地方或由审计接收器处理。大多数公共云提供商提供的托管Kubernetes产品都启用了审计日志。</p><h1 id="683d" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">10.1 Falco异常检测</h1><p id="27ec" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated"><a class="ae lb" href="https://falco.org/" rel="noopener ugc nofollow" target="_blank"> Falco </a>是一款开源的Kubernetes威胁检测引擎。Falco检测运行时的意外应用程序行为，并就此发出警报。默认规则集已经相当广泛了，但是还可以创建自定义规则和例外，以更好地反映您的应用程序。Falco引擎将检测并警告你任何事情，从一个意外的系统调用到一个pod突然产生一个外壳。</p><p id="0647" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Falco可以设置为审计事件接收器，通过Falco引擎处理审计事件。这对于捕获审计事件中的异常非常有用，而不仅仅是将日志保存在文件中，保存时间为建议的六个月。因为据说要花六个月的时间才能发现漏洞。通过Falco exporter或Falco sidekick等支持应用程序，Falco可以将其事件导出到Prometheus、Splunk、Grafana、Logstash ++或通过slack、电子邮件、短信等发送通知。多个可以组合使用。</p><h1 id="bbb8" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">11.设置有效的监控</h1><p id="ad60" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">在理想情况下，当观察到的行为与预期不符时，您可以使用日志进行调试和审计，使用指标进行应用程序监控和警告。确保充分覆盖业务关键型应用程序，以便能够及早检测到异常行为。如果你使用的是<a class="ae lb" href="https://github.com/prometheus-community/helm-charts/tree/main/charts/kube-prometheus-stack" rel="noopener ugc nofollow" target="_blank">普罗米修斯堆栈</a>，记住一个没有相应警告的Grafana面板是没有意义的。我们大多数人不会坐在那里看着仪表盘，等着事故发生。</p><h1 id="0265" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">结论</h1><p id="ab00" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">向Kubernetes的转变、其他云原生技术和容器的主流采用，让基础架构安全面临挑战，因为我们正在脱离传统基础架构安全的概念，被迫适应新的攻击面。通过在基于Kubernetes的生态系统中实现这些操作，攻击面被极大地最小化，而不必购买昂贵的安全解决方案或引入不必要的复杂性。但是请记住，基础设施安全只能带你走这么远。您仍然需要保护应用程序本身！</p><p id="8bf3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您想了解更多关于这些概念的知识，我强烈推荐Kaizhe Huang和Pranjal Jumde的书<a class="ae lb" href="https://www.packtpub.com/product/learn-kubernetes-security/9781839216503" rel="noopener ugc nofollow" target="_blank"> Learn Kubernetes Security </a>。</p></div></div>    
</body>
</html>