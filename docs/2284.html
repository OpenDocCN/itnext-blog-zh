<html>
<head>
<title>Why you’ll love Typescript’s ReadonlyArray</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么你会喜欢Typescript的ReadonlyArray</h1>
<blockquote>原文：<a href="https://itnext.io/why-youll-love-typescript-s-readonlyarray-9d7f09971e4a?source=collection_archive---------3-----------------------#2019-04-30">https://itnext.io/why-youll-love-typescript-s-readonlyarray-9d7f09971e4a?source=collection_archive---------3-----------------------#2019-04-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="650c" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">Typescript的新3.4版本为ReadonlyArrays引入了新的语法</h2></div><figure class="kf kg kh ki gt kj gh gi paragraph-image"><div class="ab gu cl kk"><img src="../Images/b4aa7eaded5e94d59b0f9920736413d0.png" data-original-src="https://miro.medium.com/v2/format:webp/1*E4fL_rwjpkvWwqHXEHi7eg.png"/></div></figure><p id="03ea" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">如果你像我一样也相信一切都应该是不可变的，你会很高兴看到Typescript 3.4带来了什么。</p><figure class="kf kg kh ki gt kj"><div class="bz fp l di"><div class="lj lk l"/></div></figure><p id="2ecb" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">虽然这个版本的所有内容看起来都很棒，但最吸引我注意的是引入了使用<em class="lp"> readonly </em>关键字引用类型<code class="fe ll lm ln lo b">ReadonlyArray</code>，这有助于我们在编译时在数组上调用会导致变异的方法时防止数组变异，因为这仍然是我在Javascript代码中看到的最常见的错误之一。</p><h1 id="4af6" class="lq lr iq bd ls lt lu lv lw lx ly lz ma jw mb jx mc jz md ka me kc mf kd mg mh bi translated">突变是不好的</h1><p id="f028" class="pw-post-body-paragraph kn ko iq kp b kq mi jr ks kt mj ju kv kw mk ky kz la ml lc ld le mm lg lh li ij bi translated">这只是Redux当初如此受欢迎的众多原因之一。突变会在我们的代码中引起各种各样的问题，而且它们也是很难追踪的bug。</p><p id="8bcf" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我在Angular团队中经常看到这种情况:一个数组被传递给一个组件，子组件碰巧对这个数组进行排序:会发生什么呢？数组变异会一直传播到父代。</p><p id="c474" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">考虑下面的片段:</p><ul class=""><li id="4155" class="mn mo iq kp b kq kr kt ku kw mp la mq le mr li ms mt mu mv bi translated">我们有一个声明数字数组的父组件</li><li id="829d" class="mn mo iq kp b kq mw kt mx kw my la mz le na li ms mt mu mv bi translated">我们有一个子组件，它从父组件获取输入并调用方法<code class="fe ll lm ln lo b">reverse()</code></li><li id="393d" class="mn mo iq kp b kq mw kt mx kw my la mz le na li ms mt mu mv bi translated">结果:两个数组都发生了变异！</li></ul><figure class="kf kg kh ki gt kj gh gi paragraph-image"><div class="ab gu cl kk"><img src="../Images/cc0773585b64cb878baea033ff4b2f26.png" data-original-src="https://miro.medium.com/v2/format:webp/1*ZP_eeKmaHEbcYPWBtARfgA.png"/></div></figure><figure class="kf kg kh ki gt kj gh gi paragraph-image"><div class="ab gu cl kk"><img src="../Images/2e9ae5a8cf15282a5e656b75149d0d79.png" data-original-src="https://miro.medium.com/v2/format:webp/1*D-HsVFalib8C2Y2piN99JA.png"/></div></figure><p id="ab20" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在我的职业生涯中，这些错误花费了我很多时间，通常是我犯的错误。</p><p id="e28d" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">但是最近，这些是我为已经存在的代码修复的错误，因为我终于学会了如何<strong class="kp ir">永远不要改变一个对象或数组</strong>。</p><p id="2b01" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">问题是，有时候还是会发生。</p><h1 id="e3b4" class="lq lr iq bd ls lt lu lv lw lx ly lz ma jw mb jx mc jz md ka me kc mf kd mg mh bi translated">ReadonlyArray来拯救</h1><p id="c8cc" class="pw-post-body-paragraph kn ko iq kp b kq mi jr ks kt mj ju kv kw mk ky kz la ml lc ld le mm lg lh li ij bi translated">Typescript的<code class="fe ll lm ln lo b">ReadonlyArray</code>如何帮助我们减少这类错误？查看下图:</p><figure class="kf kg kh ki gt kj gh gi paragraph-image"><div class="ab gu cl kk"><img src="../Images/6cc09a08c903aee9941750d13ff4077c.png" data-original-src="https://miro.medium.com/v2/format:webp/1*tQN4h0mG5UOuXrFmATysaQ.png"/></div></figure><p id="7147" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">如你所见，编译器警告我们有一个错误，因为接口<code class="fe ll lm ln lo b">ReadonlyArray</code>不包含方法<code class="fe ll lm ln lo b">reverse</code>🎉</p><p id="48f7" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">虽然听起来很奇怪，但我喜欢被告知我犯了一个错误。这就是我如此喜欢打字稿的原因。</p><p id="a35c" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">由于Typescript 3.4中引入的新语法，我们可以将前面的示例编写如下:</p><pre class="kf kg kh ki gt nb lo nc nd aw ne bi"><span id="0a79" class="nf lr iq lo b gy ng nh l ni nj"><em class="lp">// Component metadata</em><br/><em class="lp">export class </em>SortedNumbersComponent {<br/>    <em class="lp">private </em>_numbers: <em class="lp">readonly number</em>[];<br/><br/>    @Input() <em class="lp">set </em>numbers(numbers: <em class="lp">readonly number</em>[]) {<br/>        <em class="lp">this</em>._numbers = numbers.reverse(); // error<br/>    }<br/><br/>    <em class="lp">get </em>numbers() {<br/>        <em class="lp">return this</em>._numbers;<br/>    }<br/>}</span></pre><p id="7211" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">让我们看看编译器告诉我们关于只读数组的不同操作:</p><figure class="kf kg kh ki gt kj gh gi paragraph-image"><div class="ab gu cl kk"><img src="../Images/d37542f5bf03a46772746bd1260f1a8d.png" data-original-src="https://miro.medium.com/v2/format:webp/1*gpRDv-jSUP43mMprl-k8ng.png"/></div></figure><p id="02c4" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">如您所见，反转、排序、拼接、推送都是改变数组的方法——所以我们最好避免使用它们。</p><p id="08c3" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">其他方法，如<code class="fe ll lm ln lo b">filter</code>、<code class="fe ll lm ln lo b">concat</code>、<code class="fe ll lm ln lo b">reduce</code>等。是不可变的，应该总是首选的。</p><p id="6745" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">帮你未来的自己，或者有一天会捡起你的代码的任何人一个小忙:使用<code class="fe ll lm ln lo b">Readonly</code>。</p><p id="efc9" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">关键字<code class="fe ll lm ln lo b">readonly</code>将不能防止由于重新分配而导致的突变，所以您仍然需要注意这些情况。</p><p id="922f" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">编辑:文章被编辑以纠正一些关于ReadonlyArray实际发布时间和措辞的错误。</p></div><div class="ab cl nk nl hu nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="ij ik il im in"><p id="e4be" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><em class="lp">最初发布于</em><a class="ae nr" href="https://frontend.consulting/why-youll-love-typescripts-readonly-array" rel="noopener ugc nofollow" target="_blank"><em class="lp">https://frontend . consulting</em></a><em class="lp">。</em></p></div></div>    
</body>
</html>