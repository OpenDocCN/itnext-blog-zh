<html>
<head>
<title>Vue Suspense Implementation in Action</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Vue暂挂实施在行动</h1>
<blockquote>原文：<a href="https://itnext.io/vue-suspense-implementation-in-action-3c12cc930e95?source=collection_archive---------0-----------------------#2020-02-27">https://itnext.io/vue-suspense-implementation-in-action-3c12cc930e95?source=collection_archive---------0-----------------------#2020-02-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="8769" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated"><strong class="ak">在本文中，我们将介绍基于活跃RFC和vue-next存储库分析的Vue 3暂记功能。</strong></h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/87a7327051795faaf1ce5e2116a3424e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MdFF32Bwebs8BdR7eHZwjg.png"/></div></div></figure><h1 id="b0eb" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">悬念是什么？</h1><p id="031a" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">悬念是一个组件，它呈现一个后备内容，而不是我们的组件，直到满足所需的条件。条件通常是异步操作发生在我们的组件<em class="mf">设置</em>函数内部。在Vue 2中，我们使用了声明性的渲染方法、数据和计算属性。而是在Vue 3中使用了Composition API，它向我们介绍了setup方法，该方法允许我们使用computed()、watchers()或onMounted()等函数来挂钩不同的组件属性。</p><h1 id="bf47" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated"><strong class="ak">为什么悬念有用？</strong></h1><p id="20d2" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">悬念通常用于在等待某种异步组件解决时显示回退内容。在某些情况下，我们希望组件一直等到获取数据(通常是在异步API调用中)，我们可以使用组合API创建一个异步组件。</p><p id="9604" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">这里有一些悬念可以派上用场的用例。</p><ul class=""><li id="2d74" class="ml mm iq ll b lm mg lp mh ls mn lw mo ma mp me mq mr ms mt bi translated">在内容到达之前显示加载器。</li><li id="7c77" class="ml mm iq ll b lm mu lp mv ls mw lw mx ma my me mq mr ms mt bi translated">显示占位符内容。</li><li id="21bc" class="ml mm iq ll b lm mu lp mv ls mw lw mx ma my me mq mr ms mt bi translated">处理延迟加载的图像。</li></ul><p id="eae4" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">在Vue 2 options API中，我们有一些指令帮助我们实现相同的功能，例如使用<em class="mf"> v-if、v-show或v-else </em>来检查我们的数据是否已经加载。随着当前的变化，我们不必担心跟踪我们是否已经收到数据来呈现相应的内容。</p><p id="71d2" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated"><strong class="ll ir">说够了！让我们开始编码… </strong></p><p id="79df" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">在实现Vue悬念的示例代码中，我们将对github服务器进行API调用，并获取我的个人Github配置文件的一些个人数据。在这个过程中，我们将向用户展示某种加载动画，以在获取过程中显示一些回退内容。</p><p id="2e4d" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">在我们开始之前，我更喜欢使用Vue和Typescript。因此，让我们在终端中使用下面的命令来准备我们的设置。</p><p id="295a" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated"><code class="fe mz na nb nc b">vue create vueSuspense-demo</code></p><p id="b650" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">使用终端中的上述命令，我们将获得我们项目的所有项目脚手架。让我们继续添加Vue-下一个版本的Vue 3。</p><p id="44ff" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated"><code class="fe mz na nb nc b">vue add vue-next</code></p><p id="21f5" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">使用上面的命令，我们将Vue 3 alpha添加到我们的开发依赖项中。现在，让我们将<a class="ae nd" href="https://github.com/axios/axios" rel="noopener ugc nofollow" target="_blank"> axios </a>添加到我们的项目中，以发出一些API请求。最后我们的<em class="mf"> package.json </em>看起来如下:</p><pre class="kg kh ki kj gt ne nc nf ng aw nh bi"><span id="58bb" class="ni ks iq nc b gy nj nk l nl nm">{<br/>  "name": "suspense-demo",<br/>  "version": "0.1.0",<br/>  "private": true,<br/>  "scripts": {<br/>    "serve": "vue-cli-service serve",<br/>    "build": "vue-cli-service build",<br/>    "lint": "vue-cli-service lint"<br/>  },<br/>  "dependencies": {<br/>    "axios": "^0.19.2",<br/>    "core-js": "^3.6.4",<br/>    "vue": "^3.0.0-alpha.4"<br/>  },<br/>  "devDependencies": {<br/>    "@vue/cli-plugin-babel": "^4.2.0",<br/>    "@vue/cli-plugin-eslint": "^4.2.0",<br/>    "@vue/cli-service": "^4.2.0",<br/>    "@vue/compiler-sfc": "^3.0.0-alpha.4",<br/>    "babel-eslint": "^10.0.3",<br/>    "eslint": "^6.7.2",<br/>    "eslint-plugin-vue": "^6.1.2",<br/>    "vue-cli-plugin-vue-next": "^0.0.4",<br/>    "vue-template-compiler": "^2.6.11"<br/>  },<br/>  "eslintConfig": {<br/>    "root": true,<br/>    "env": {<br/>      "node": true<br/>    },<br/>    "extends": [<br/>      "plugin:vue/essential",<br/>      "eslint:recommended"<br/>    ],<br/>    "parserOptions": {<br/>      "parser": "babel-eslint"<br/>    },<br/>    "rules": {}<br/>  },<br/>  "browserslist": [<br/>    "&gt; 1%",<br/>    "last 2 versions"<br/>  ]<br/>}</span></pre><p id="3ad5" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">所有初始项目和<em class="mf">包</em>已经全部设置完毕。在这里的代码中，我们将伪造一个API调用，并在一段延迟时间后向用户发送一些关于我自己的信息。我们将制作一个新组件，名称为<em class="mf"> Home.vue </em>。在文件内部，我们将在<em class="mf">设置方法</em>中有一些异步操作，比如从外部来源获取数据，但我们将伪造它。让我们为它创建一个函数。</p><pre class="kg kh ki kj gt ne nc nf ng aw nh bi"><span id="fcb5" class="ni ks iq nc b gy nj nk l nl nm">async setup() {<br/>const userInfo = await fetchUser();<br/>return { userInfo };<br/>}</span></pre><p id="3ec9" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">我们这里使用的是一个在Vue composition API中引入的设置方法。与此同时，我们不会向用户显示组件，而是在获取组件时显示一些指示器。这是我们将悬念得心应手得多的地方。</p><p id="b926" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">现在让我们假装一个延迟的API调用。我们将把下面这段代码写到我们的文件中。</p><pre class="kg kh ki kj gt ne nc nf ng aw nh bi"><span id="3da9" class="ni ks iq nc b gy nj nk l nl nm">async function fetchUser() {<br/>await timeout(4000);<br/> return {<br/> name: "Ishan Manandhar",<br/> github: "https://github.com/ishan-me",<br/> twitter: "https://twitter.com/ishan02016",<br/> dribbble: "https://dribbble.com/ishan-manandhar"<br/> };<br/>}</span></pre><p id="c6b5" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">我们在函数中返回了一个对象，在返回对象时会有一些延迟。我们发送给<em class="mf"> timeout()的参数是4秒钟。</em>让我们也为它制作函数。</p><pre class="kg kh ki kj gt ne nc nf ng aw nh bi"><span id="b893" class="ni ks iq nc b gy nj nk l nl nm">function timeout(ms) {<br/>return new Promise(resolve =&gt; setTimeout(resolve, ms));<br/>}</span></pre><p id="f3fc" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">在上面的函数中，我们添加了一个可以解决动作的承诺，ms作为额外的回调传递给函数。我们将移动到我们的主<em class="mf"> app.js </em>文件，在那里我们将使用悬念。我们将把我们的<em class="mf"> Home.vue </em>组件包装在<em class="mf">一个悬念</em>标签<em class="mf">中。</em>我们还将添加一些回退，直到组件中的异步操作从上述承诺中解决。我们将向用户展示的后备是加载程序。代码现在看起来像这样。</p><pre class="kg kh ki kj gt ne nc nf ng aw nh bi"><span id="b871" class="ni ks iq nc b gy nj nk l nl nm">&lt;div id="app"&gt;<br/>    &lt;h2&gt;Vue 3 with Suspense Demo&lt;/h2&gt;<br/>    &lt;div v-if="error"&gt;{{error}}&lt;/div&gt;<br/>    &lt;div v-else&gt;<br/>        &lt;Suspense&gt;<br/>            &lt;template #default&gt;<br/>                &lt;Home&gt;&lt;/Home&gt;<br/>            &lt;/template&gt;<br/>            &lt;template #fallback&gt;<br/>                &lt;div class="myLoader"&gt;<br/>                    &lt;div&gt;&lt;/div&gt;<br/>                    &lt;div&gt;&lt;/div&gt;<br/>                    &lt;div&gt;&lt;/div&gt;<br/>                    &lt;div&gt;&lt;/div&gt;<br/>                    &lt;div&gt;&lt;/div&gt;<br/>                    &lt;div&gt;&lt;/div&gt;<br/>                    &lt;div&gt;&lt;/div&gt;<br/>                    &lt;div&gt;&lt;/div&gt;<br/>                &lt;/div&gt;<br/>            &lt;/template&gt;<br/>        &lt;/Suspense&gt;<br/>    &lt;/div&gt;<br/>&lt;/div&gt;</span></pre><p id="3daf" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">现在有了这些代码，我们就可以用<em class="mf"> Vue悬念</em>来伪造我们的API调用了。让我们添加一个<em class="mf">error captured</em>life cycle钩子，以防我们在API调用过程中遇到错误。我们捕获错误，将其传递给error属性，并显示error而不是我们的回退内容。</p><pre class="kg kh ki kj gt ne nc nf ng aw nh bi"><span id="888a" class="ni ks iq nc b gy nj nk l nl nm">import { onErrorCaptured, ref } from "vue";</span><span id="f224" class="ni ks iq nc b gy nn nk l nl nm">setup() {<br/>const error = ref(null);<br/>onErrorCaptured(e =&gt; {<br/> error.value = e;<br/> return true;<br/> });<br/>return { error };<br/>},</span></pre><p id="d807" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">现在我们有代码工作了。悬念对于我们这样的Vue开发者来说真的是得心应手。我们不需要有条件地渲染组件，我们可以只使用悬念照顾我们。</p><p id="e957" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">而且，我这里有我的工作代码库<a class="ae nd" href="https://github.com/ishan-me/vueSuspense-demo" rel="noopener ugc nofollow" target="_blank"> <strong class="ll ir">链接</strong> </a>。你可以找到这篇文章的代码。我希望你喜欢这篇文章，并且你足够舒适地使用Vue3的下一个主要版本。</p><p id="7ff7" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">— — — — — — —编码快乐！— — —- — — — —- —</p></div></div>    
</body>
</html>