<html>
<head>
<title>Use System.IO.Pipelines and System.Threading.Channels APIs to Boost Performance</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用系统。管道和系统。线程化。引导API提高性能</h1>
<blockquote>原文：<a href="https://itnext.io/use-system-io-pipelines-and-system-threading-channels-apis-to-boost-performance-832d7ab7c719?source=collection_archive---------0-----------------------#2020-09-20">https://itnext.io/use-system-io-pipelines-and-system-threading-channels-apis-to-boost-performance-832d7ab7c719?source=collection_archive---------0-----------------------#2020-09-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="9901" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何使用系统。管道和系统。线程化。引导API加速处理</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/c7fe459bf7658a43a8b8db39161abafb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c1szTL0yaZwcsmLkcMcHRA.png"/></div></div></figure><p id="a218" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这篇文章是我之前系列文章的延续:<a class="ae ln" href="https://medium.com/@joni2nja/evaluating-readline-using-system-io-pipelines-performance-in-c-part-2-b9d22c95254b" rel="noopener"> <strong class="kt ir">评估“ReadLine使用系统”。IO.Pipelines“性能在C# </strong> </a>。</p><p id="af81" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当我写那些帖子时，我需要处理一个巨大的文本文件(几十万行)，逐行读取、解析和转换，然后最终将它们保存为文本文件。是的，这将导致大量文件被创建！</p><p id="e0b3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我能够使用前一篇文章中描述的<code class="fe lo lp lq lr b">System.IO.Pipelines</code>API来加快读取时间。结果呢？处理时间快了10分钟！🚀</p><p id="d84d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我本可以就此打住。但我没有。我回忆了一下街区里新来的小孩:<code class="fe lo lp lq lr b">System.Threading.Channels</code>。参见Stephen Toub的精彩帖子<a class="ae ln" href="https://devblogs.microsoft.com/dotnet/an-introduction-to-system-threading-channels/" rel="noopener ugc nofollow" target="_blank">“系统介绍。Threading.Channels" </a>了解更多信息。</p><div class="ls lt gp gr lu lv"><a href="https://devblogs.microsoft.com/dotnet/an-introduction-to-system-threading-channels/" rel="noopener  ugc nofollow" target="_blank"><div class="lw ab fo"><div class="lx ab ly cl cj lz"><h2 class="bd ir gy z fp ma fr fs mb fu fw ip bi translated">系统介绍。线程.通道|。网络博客</h2><div class="mc l"><h3 class="bd b gy z fp ma fr fs mb fu fw dk translated">“生产者/消费者”问题无处不在，在我们生活的方方面面。一个线厨师在快餐店，切片…</h3></div><div class="md l"><p class="bd b dl z fp ma fr fs mb fu fw dk translated">devblogs.microsoft.com</p></div></div><div class="me l"><div class="mf l mg mh mi me mj kp lv"/></div></div></a></div><p id="1b55" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">把逐行读取想象成<em class="mk">生产者</em>，把行处理部分想象成<em class="mk">消费者</em>。这个想法是，使用<code class="fe lo lp lq lr b">System.IO.Pipelines</code>尽可能快地生产并消耗它——并发地分散工作负载，<em class="mk">异步地</em>，而不像<code class="fe lo lp lq lr b">BlockingCollection</code>那样阻塞。</p></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><blockquote class="ms mt mu"><p id="0bc9" class="kr ks mk kt b ku kv jr kw kx ky ju kz mv lb lc ld mw lf lg lh mx lj lk ll lm ij bi translated">BlockingCollection涉及阻塞；没有基于任务的API来异步执行工作。通道是关于异步的；没有同步阻塞的API。</p></blockquote><p id="3536" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">好了，说够了。给我看看代码！</p></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="d16d" class="my mz iq bd na nb nc nd ne nf ng nh ni jw nj jx nk jz nl ka nm kc nn kd no np bi translated">基本实现</h1><p id="0be7" class="pw-post-body-paragraph kr ks iq kt b ku nq jr kw kx nr ju kz la ns lc ld le nt lg lh li nu lk ll lm ij bi translated">让我们从基础实现开始(即在使用<code class="fe lo lp lq lr b">System.Threading.Channels</code>API之前)；代码只是简单地将每个行处理方法添加到列表<code class="fe lo lp lq lr b">Task</code>和列表<code class="fe lo lp lq lr b">await</code>中。</p><p id="906f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="mk">请注意，本文中的代码会因基准测试的目的而稍作调整；尽可能地删除不相关的部分。</em></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="a2d8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们可以看到，随着我们处理该行，任务列表不断增长。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nx"><img src="../Images/316d4ec609fc435269ee68adf66adc92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vqRDgV3owQsxYIlGrxOP9A.png"/></div></div><figcaption class="ny nz gj gh gi oa ob bd b be z dk translated">任务列表</figcaption></figure></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="2318" class="my mz iq bd na nb nc nd ne nf ng nh ni jw nj jx nk jz nl ka nm kc nn kd no np bi translated">频道撰稿人(制片人)</h1><p id="bfc2" class="pw-post-body-paragraph kr ks iq kt b ku nq jr kw kx nr ju kz la ns lc ld le nt lg lh li nu lk ll lm ij bi translated">这是制片人的部分。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="b990" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了帮助快速发现变化，下面是不同之处:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oc"><img src="../Images/a26fe4183bf2e4682dc5999095513e3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XqKqYNIRkYBpZsijHz-6dg.png"/></div></div><figcaption class="ny nz gj gh gi oa ob bd b be z dk translated">基础实施与渠道实施</figcaption></figure><p id="c979" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">应该很容易发现不同之处。</p></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="146a" class="my mz iq bd na nb nc nd ne nf ng nh ni jw nj jx nk jz nl ka nm kc nn kd no np bi translated">频道阅读器(消费者)</h1><p id="825a" class="pw-post-body-paragraph kr ks iq kt b ku nq jr kw kx nr ju kz la ns lc ld le nt lg lh li nu lk ll lm ij bi translated">最后是消费者部分。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="2525" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里我定义了3个通道阅读器，并将<code class="fe lo lp lq lr b">SingleReader</code>设置为<code class="fe lo lp lq lr b">false</code>(通过评估<code class="fe lo lp lq lr b">ChannelReaderCount == 1</code>)。这样，我们将有3个消费者同时处理生产线。</p><p id="187a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这可以从Visual Studio并行堆栈窗口中观察到。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi od"><img src="../Images/2e725266c1459dd55f579b4a3c5a914f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WC0B2fsBGmeucKLnaPwzzg.png"/></div></div><figcaption class="ny nz gj gh gi oa ob bd b be z dk translated">并行堆栈窗口</figcaption></figure><p id="ab8d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">调整该值并进行测量，直到获得最佳性能。从小处开始，增加数值，直到你到达一个会给你带来较慢结果的点；这是你有太多活动<code class="fe lo lp lq lr b">Task</code>资源的地方，可能有太多的上下文切换。</p></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="fa9e" class="my mz iq bd na nb nc nd ne nf ng nh ni jw nj jx nk jz nl ka nm kc nn kd no np bi translated">基准结果</h1><p id="5526" class="pw-post-body-paragraph kr ks iq kt b ku nq jr kw kx nr ju kz la ns lc ld le nt lg lh li nu lk ll lm ij bi translated">好，让我们看看基准测试的结果。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oe"><img src="../Images/98f32bf198abef5648bcae6a9f0c7fc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tsJZld13exelfpVHGeXfQw.png"/></div></div></figure><p id="0b86" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">哇。几乎快了两倍！</strong>🚀🚀🚀</p><p id="2520" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">以下是要点版本:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="7814" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是基准测试的结果。我的案子怎么办？嗯，我又节省了10分钟，所以总共快了大约20分钟！</p><h1 id="1c0b" class="my mz iq bd na nb of nd ne nf og nh ni jw oh jx nk jz oi ka nm kc oj kd no np bi translated">源代码</h1><p id="7aba" class="pw-post-body-paragraph kr ks iq kt b ku nq jr kw kx nr ju kz la ns lc ld le nt lg lh li nu lk ll lm ij bi translated">你可以在我的<a class="ae ln" href="https://github.com/jo-ninja/ReadLinesBenchmarks" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>，分支:<em class="mk"> pipelines-and-channels中找到源代码。</em></p><h1 id="b50f" class="my mz iq bd na nb of nd ne nf og nh ni jw oh jx nk jz oi ka nm kc oj kd no np bi translated">结论</h1><p id="614c" class="pw-post-body-paragraph kr ks iq kt b ku nq jr kw kx nr ju kz la ns lc ld le nt lg lh li nu lk ll lm ij bi translated">如果您有包含成千上万行要处理的大型文本文件，可以考虑使用<code class="fe lo lp lq lr b">System.IO.Pipelines</code>来读取和解析这些行，并将其与<code class="fe lo lp lq lr b">System.Threading.Channels</code>API结合起来，以并发、异步地分散工作负载。</p></div></div>    
</body>
</html>