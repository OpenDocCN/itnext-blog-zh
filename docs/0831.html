<html>
<head>
<title>Using BackboneJS successfully with React (using MobX)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过React成功使用BackboneJS(使用MobX)</h1>
<blockquote>原文：<a href="https://itnext.io/using-backbonejs-successfully-with-react-using-mobx-666eceb079f6?source=collection_archive---------7-----------------------#2018-06-05">https://itnext.io/using-backbonejs-successfully-with-react-using-mobx-666eceb079f6?source=collection_archive---------7-----------------------#2018-06-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/0a47390b217dc3de7cff32a82eb885c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/format:webp/1*Pkdk0fjrA2U-HMMpXoQ1HA.png"/></div></figure><p id="e10b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在Feathr，我们的主要前端应用程序是建立在牵线木偶和脊椎上的。因为我们的很多应用程序都是CRUD，所以我们的应用程序中有大量的主干模型和集合。我们应用程序的基础围绕着这些模型和集合，所以我们所有的技术决策都必须牢记这一点。当引入一项新技术时，它要么必须与主干网配合良好，要么我们需要重写所有这些模型/集合来迎合这项新技术。大多数公司，无论规模大小，都没有足够的资源来进行繁重的重写，以适应新技术的使用。除非完全必要，否则我尽量避免开出完全重写的处方，而是建议朝着你的目标逐步改变。</p><p id="97b6" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我最近开始使用React在我们的应用程序中编写一个新特性，我很早就了解到，很难保持用React组件构建的视图与主干模型和集合同步。</p><h2 id="9d9b" class="ks kt iq bd ku kv kw dn kx ky kz dp la kf lb lc ld kj le lf lg kn lh li lj lk bi translated">快速复习——使用提线木偶的脊柱</h2><p id="7d10" class="pw-post-body-paragraph ju jv iq jw b jx ll jz ka kb lm kd ke kf ln kh ki kj lo kl km kn lp kp kq kr ij bi translated">在传统的主干/牵线木偶应用程序中，牵线木偶视图监听从模型和集合传播的事件。通常，您的视图中传递了一个特定的模型和/或集合，您可以监听这些对象上的事件来触发渲染周期。例如:</p><figure class="lq lr ls lt gt jr"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="7713" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这个视图接受一个具有<code class="fe lw lx ly lz b">height</code>和<code class="fe lw lx ly lz b">width</code>属性的模型。为了让您的视图与您的模型保持同步，您特别将<code class="fe lw lx ly lz b">change:width</code>和<code class="fe lw lx ly lz b">change:height</code>列为您在传入的模型上监听的两个事件。当这些发生变化时，它会重新渲染整个视图。</p><h2 id="7cef" class="ks kt iq bd ku kv kw dn kx ky kz dp la kf lb lc ld kj le lf lg kn lh li lj lk bi translated">使用Backbone和React</h2><p id="039b" class="pw-post-body-paragraph ju jv iq jw b jx ll jz ka kb lm kd ke kf ln kh ki kj lo kl km kn lp kp kq kr ij bi translated">在下面的例子中，我从上面重新创建了视图，但是使用React功能组件来呈现同一个视图。</p><figure class="lq lr ls lt gt jr"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="647d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">一个立即变得明显的问题是，当模型传播事件时，视图将不会重新呈现。然而，这个视图是一个功能组件，可能不需要关心重新呈现——父组件可能会管理它。</p><p id="ad8f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果这个组件需要根据模型的变化重新渲染呢？嗯，看起来应该是这样的:</p><figure class="lq lr ls lt gt jr"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="dcee" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这种方法有几个问题。其中最大的一个问题是，因为React组件不能像木偶<code class="fe lw lx ly lz b">View</code>一样<code class="fe lw lx ly lz b">listenTo</code>骨干事件，所以我们在模型上附加事件。这打破了React的核心概念之一，即你的视图不应该改变你的状态。</p><p id="34e8" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">另一个问题是，我们需要明确地选择加入可能影响视图呈现的每一个事件。在上面的例子中，这很简单，但是在一个复杂的例子中，可能很难跟上。</p><h2 id="3df6" class="ks kt iq bd ku kv kw dn kx ky kz dp la kf lb lc ld kj le lf lg kn lh li lj lk bi translated">尝试使用Redux将主干和反应粘合在一起</h2><p id="df6b" class="pw-post-body-paragraph ju jv iq jw b jx ll jz ka kb lm kd ke kf ln kh ki kj lo kl km kn lp kp kq kr ij bi translated">许多团队/项目已经采用Redux作为他们保持React视图与状态同步的首选方法。我自己已经在一些项目中使用了Flux模式，并且在可能的时候更喜欢使用它。话虽如此，用Backbone的Redux就是感觉不对。</p><p id="376b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">首先，主干模型是可变的。当你用<code class="fe lw lx ly lz b">react-redux</code>提供的<code class="fe lw lx ly lz b">connect</code>函数装饰你的组件时，这真的很伤人。不能简单的从<code class="fe lw lx ly lz b">mapStateToProps</code>回一个骨干模特，像这样:</p><figure class="lq lr ls lt gt jr"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="7bcb" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果您在模型上设置<code class="fe lw lx ly lz b">height</code>或<code class="fe lw lx ly lz b">width</code>，该模型在内存中仍然是相同的参考。这对于传统的主干应用程序来说非常重要，因为在这个模型上的任何事件都需要持久化。如果Backbone像<code class="fe lw lx ly lz b">immutable</code>一样，在每次模型变异时都创建一个新的实例，这将是一个非常昂贵的交易。这带来的问题是，你的视图将不会正确地重新渲染，因为当视图决定是否需要重新渲染时，它会看到<code class="fe lw lx ly lz b">previousState.model === state.model</code>而不会正确地重新渲染。</p><p id="37c3" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">您可以在您的<code class="fe lw lx ly lz b">mapStateToProps</code>中只传递需要的属性，但是这意味着每次您向您的模型添加一些东西时，您都需要将它添加到这个函数中。随着时间的推移，维护起来会有点麻烦。这也打开了一扇大门，让你的部分状态，你不应该映射到状态，这将导致时髦的和难以调试的错误在未来。</p><h2 id="e656" class="ks kt iq bd ku kv kw dn kx ky kz dp la kf lb lc ld kj le lf lg kn lh li lj lk bi translated">进入MobX，我们问题的解决方案</h2><p id="cc47" class="pw-post-body-paragraph ju jv iq jw b jx ll jz ka kb lm kd ke kf ln kh ki kj lo kl km kn lp kp kq kr ij bi translated">在有了这些关于React、Redux和Backbone的问题之后，我开始探索新的选择。我探索的一个解决方案是<code class="fe lw lx ly lz b">mobx</code>，仅仅经过一点修补，它似乎就能完美地用于我们的用例！</p><p id="ce03" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在传统的<code class="fe lw lx ly lz b">mobx</code> powered React应用程序中，状态和视图如下所示:</p><figure class="lq lr ls lt gt jr"><div class="bz fp l di"><div class="lu lv l"/></div></figure><figure class="lq lr ls lt gt jr"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="937e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果在<code class="fe lw lx ly lz b">props</code>到<code class="fe lw lx ly lz b">RectangleMobx</code>中传递一个<code class="fe lw lx ly lz b">Rectangle</code>的实例，当<code class="fe lw lx ly lz b">height</code>或<code class="fe lw lx ly lz b">width</code>发生变化时，它会智能更新。</p><p id="7ca0" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我开始思考“也许我可以使用<code class="fe lw lx ly lz b">mobx</code>让我的React视图与我的主干模型保持同步？”。答案是，可以！看一下这个例子:</p><figure class="lq lr ls lt gt jr"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="dad8" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在这里，我用<code class="fe lw lx ly lz b">observable</code>包装了模型的<code class="fe lw lx ly lz b">attributes</code>，这将属性转换成一个<a class="ae ma" href="https://mobx.js.org/refguide/object.html" rel="noopener ugc nofollow" target="_blank">可观察对象</a>。现在我只需要在一个<code class="fe lw lx ly lz b">render</code>函数中解引用一个属性，当模型改变时组件就会重新渲染！</p><figure class="lq lr ls lt gt jr"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="3863" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这里唯一值得注意的是，我通过<code class="fe lw lx ly lz b">rectangle.attributes.height</code>而不是<code class="fe lw lx ly lz b">rectangle.get('height')</code>来引用属性。我还不确定<code class="fe lw lx ly lz b">rectangle.get('height')</code>是否会以一种会导致组件重新呈现的方式取消对属性的引用，但这是值得尝试的。</p><p id="8b9b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在，您有了一种简单的迁移方法，即使在已经严重依赖主干网的应用程序中也能做出反应！一如既往，让我知道你在评论中的想法！😃</p></div></div>    
</body>
</html>