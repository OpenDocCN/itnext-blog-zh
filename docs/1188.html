<html>
<head>
<title>Machine Learning in Node.js With TensorFlow.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用TensorFlow.js在Node.js中进行机器学习</h1>
<blockquote>原文：<a href="https://itnext.io/machine-learning-in-node-js-with-tensorflow-js-2588fc2d0cd0?source=collection_archive---------7-----------------------#2018-08-07">https://itnext.io/machine-learning-in-node-js-with-tensorflow-js-2588fc2d0cd0?source=collection_archive---------7-----------------------#2018-08-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="a6de" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://js.tensorflow.org/" rel="noopener ugc nofollow" target="_blank"> TensorFlow.js </a>是流行的开源库的新版本，它为JavaScript带来了深度学习。开发人员现在可以使用<a class="ae kl" href="https://js.tensorflow.org/api/0.12.0/" rel="noopener ugc nofollow" target="_blank">高级库API </a>来定义、训练和运行机器学习模型。</p><p id="cd70" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://github.com/tensorflow/tfjs-models/" rel="noopener ugc nofollow" target="_blank">预先训练的模型</a>意味着开发人员现在可以轻松地执行复杂的任务，如<a class="ae kl" href="https://emojiscavengerhunt.withgoogle.com/" rel="noopener ugc nofollow" target="_blank">视觉识别</a>、<a class="ae kl" href="https://magenta.tensorflow.org/demos/performance_rnn/index.html#2%7C2,0,1,0,1,1,0,1,0,1,0,1%7C1,1,1,1,1,1,1,1,1,1,1,1%7C1,1,1,1,1,1,1,1,1,1,1,1%7Cfalse" rel="noopener ugc nofollow" target="_blank">生成音乐</a>或<a class="ae kl" href="https://storage.googleapis.com/tfjs-models/demos/posenet/camera.html" rel="noopener ugc nofollow" target="_blank">检测人类姿势</a>只需几行JavaScript。</p><p id="25d0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">作为web浏览器的前端库，最近的更新增加了对Node.js的实验性支持，这使得TensorFlow.js可以在后端JavaScript应用程序中使用，而不必使用Python。</p><p id="abd4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="km">读到关于这个库的内容，我想用一个简单的任务来测试一下……</em>🧐</p><blockquote class="kn ko kp"><p id="1cc0" class="jn jo km jp b jq jr js jt ju jv jw jx kq jz ka kb kr kd ke kf ks kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="iq">使用TensorFlow.js从Node.js </em> </strong>使用JavaScript对图像进行视觉识别</p></blockquote><p id="9e94" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不幸的是，提供的大多数<a class="ae kl" href="https://js.tensorflow.org/#getting-started" rel="noopener ugc nofollow" target="_blank">文档</a>和<a class="ae kl" href="https://js.tensorflow.org/tutorials/webcam-transfer-learning.html" rel="noopener ugc nofollow" target="_blank">示例代码</a>都在浏览器中使用这个库。<a class="ae kl" href="https://github.com/tensorflow/tfjs-models/tree/master/mobilenet" rel="noopener ugc nofollow" target="_blank">为简化加载和使用预训练模型而提供的项目实用程序</a>尚未扩展Node.js支持。完成这项工作的最终结果是我花了很多时间阅读库的Typescript源文件。👎</p><p id="85d3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，经过几天的黑客，我设法得到了<a class="ae kl" href="https://gist.github.com/jthomas/145610bdeda2638d94fab9a397eb1f1d" rel="noopener ugc nofollow" target="_blank">这个完成的</a>！万岁！🤩🤩🤩</p><p id="c60e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在深入研究代码之前，让我们先来概述一下不同的TensorFlow库。</p></div><div class="ab cl kt ku hu kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ij ik il im in"><h1 id="5497" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">张量流</h1><p id="5420" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated"><a class="ae kl" href="https://www.tensorflow.org/" rel="noopener ugc nofollow" target="_blank"> TensorFlow </a>是一个面向机器学习应用的开源软件库。TensorFlow可用于实现神经网络和其他深度学习算法。</p><p id="b81c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">TensorFlow于2015年11月由谷歌发布，最初是一个<a class="ae kl" href="https://www.tensorflow.org/api_docs/python/" rel="noopener ugc nofollow" target="_blank"> Python库</a>。它使用基于CPU或GPU的计算来训练和评估机器学习模型。该库最初被设计为运行在具有昂贵GPU的高性能服务器上。</p><p id="3b2f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最近的更新扩展了该软件，使其可以在移动设备和网络浏览器等资源受限的环境中运行。</p><h1 id="c6ca" class="la lb iq bd lc ld md lf lg lh me lj lk ll mf ln lo lp mg lr ls lt mh lv lw lx bi translated">TensorFlow Lite</h1><p id="f46a" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated"><a class="ae kl" href="https://www.tensorflow.org/mobile/tflite/" rel="noopener ugc nofollow" target="_blank">面向移动和嵌入式设备的轻量级版本库Tensorflow Lite </a>于2017年5月发布。这伴随着一系列新的预训练深度学习模型，用于视觉识别任务，称为<a class="ae kl" href="https://ai.googleblog.com/2017/06/mobilenets-open-source-models-for.html" rel="noopener ugc nofollow" target="_blank"> MobileNet </a>。MobileNet模型设计用于在资源受限的环境中高效工作，如移动设备。</p><h1 id="575a" class="la lb iq bd lc ld md lf lg lh me lj lk ll mf ln lo lp mg lr ls lt mh lv lw lx bi translated">TensorFlow.js</h1><p id="b613" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">继Tensorflow Lite之后，<a class="ae kl" href="https://medium.com/tensorflow/introducing-tensorflow-js-machine-learning-in-javascript-bf3eab376db" rel="noopener"> TensorFlow.js </a>于2018年3月公布。这个版本的库被设计为在浏览器中运行，构建在一个名为<a class="ae kl" href="https://twitter.com/deeplearnjs" rel="noopener ugc nofollow" target="_blank"> deeplearn.js </a>的早期项目上。WebGL提供了对库的GPU访问。开发人员使用JavaScript API来训练、加载和运行模型。</p><p id="e55f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">TensorFlow.js最近被扩展为在Node.js上运行，使用了一个名为<code class="fe mi mj mk ml b">tfjs-node</code>的<a class="ae kl" href="https://github.com/tensorflow/tfjs-node" rel="noopener ugc nofollow" target="_blank">扩展库</a>。</p><p id="dd80" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Node.js扩展是一个alpha版本，仍在积极开发中。</p><h2 id="97b6" class="mm lb iq bd lc mn mo dn lg mp mq dp lk jy mr ms lo kc mt mu ls kg mv mw lw mx bi translated">将现有模型导入TensorFlow.js</h2><p id="2c22" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">可以使用TensorFlow.js库执行现有的TensorFlow和Keras模型。模型需要在执行前使用此工具转换成新的格式<a class="ae kl" href="https://github.com/tensorflow/tfjs-converter" rel="noopener ugc nofollow" target="_blank">。Github </a>上提供了用于图像分类、姿态检测和k近邻的预训练和转换模型<a class="ae kl" href="https://github.com/tensorflow/tfjs-models" rel="noopener ugc nofollow" target="_blank">。</a></p></div><div class="ab cl kt ku hu kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ij ik il im in"><h1 id="0fb6" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">在Node.js中使用TensorFlow.js</h1><h2 id="5552" class="mm lb iq bd lc mn mo dn lg mp mq dp lk jy mr ms lo kc mt mu ls kg mv mw lw mx bi translated">安装TensorFlow库</h2><p id="05a2" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">TensorFlow.js可以从<a class="ae kl" href="https://www.npmjs.com/" rel="noopener ugc nofollow" target="_blank"> NPM注册表</a>安装。</p><pre class="my mz na nb gt nc ml nd ne aw nf bi"><span id="aec6" class="mm lb iq ml b gy ng nh l ni nj">npm install @tensorflow/tfjs @tensorflow/tfjs-node<br/>// or... <br/>npm install @tensorflow/tfjs @tensorflow/tfjs-node-gpu</span></pre><p id="bbcf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这两个Node.js扩展都使用将按需编译的本机依赖项。</p><h2 id="6d34" class="mm lb iq bd lc mn mo dn lg mp mq dp lk jy mr ms lo kc mt mu ls kg mv mw lw mx bi translated">加载TensorFlow库</h2><p id="b102" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">TensorFlow的<a class="ae kl" href="https://js.tensorflow.org/api/0.12.0/" rel="noopener ugc nofollow" target="_blank"> JavaScript API </a>从核心库暴露出来。启用Node.js支持的扩展模块不公开额外的API。</p><pre class="my mz na nb gt nc ml nd ne aw nf bi"><span id="1faf" class="mm lb iq ml b gy ng nh l ni nj">const tf = require('@tensorflow/tfjs')<br/>// Load the binding (CPU computation)<br/>require('@tensorflow/tfjs-node')<br/>// Or load the binding (GPU computation)<br/>require('@tensorflow/tfjs-node-gpu')</span></pre><h2 id="bc33" class="mm lb iq bd lc mn mo dn lg mp mq dp lk jy mr ms lo kc mt mu ls kg mv mw lw mx bi translated">加载张量流模型</h2><p id="1b18" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">TensorFlow.js提供了一个<a class="ae kl" href="https://github.com/tensorflow/tfjs-models" rel="noopener ugc nofollow" target="_blank"> NPM库</a> ( <code class="fe mi mj mk ml b">tfjs-models</code>)，以方便加载预先训练好的&amp;转换模型，用于<a class="ae kl" href="https://github.com/tensorflow/tfjs-models/tree/master/mobilenet" rel="noopener ugc nofollow" target="_blank">图像分类</a>、<a class="ae kl" href="https://github.com/tensorflow/tfjs-models/tree/master/posenet" rel="noopener ugc nofollow" target="_blank">姿态检测</a>和<a class="ae kl" href="https://github.com/tensorflow/tfjs-models/tree/master/knn-classifier" rel="noopener ugc nofollow" target="_blank"> k近邻</a>。</p><p id="7987" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">用于图像分类的<a class="ae kl" href="https://github.com/tensorflow/tfjs-models/tree/master/mobilenet" rel="noopener ugc nofollow" target="_blank"> MobileNet模型</a>是一个深度神经网络，被训练用于<a class="ae kl" href="https://github.com/tensorflow/tfjs-models/blob/master/mobilenet/src/imagenet_classes.ts" rel="noopener ugc nofollow" target="_blank">识别1000个不同的类别</a>。</p><p id="ecea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在项目的自述文件中，下面的<a class="ae kl" href="https://github.com/tensorflow/tfjs-models/tree/master/mobilenet#via-npm" rel="noopener ugc nofollow" target="_blank">示例代码</a>用于加载模型。</p><pre class="my mz na nb gt nc ml nd ne aw nf bi"><span id="c95a" class="mm lb iq ml b gy ng nh l ni nj">import * as mobilenet from '@tensorflow-models/mobilenet';<br/>// Load the model.<br/>const model = await mobilenet.load();</span></pre><p id="3e87" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">我遇到的第一个挑战是，这在Node.js上不起作用。</strong></p><p id="03d6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mi mj mk ml b">Error: browserHTTPRequest is not supported outside the web browser.</code></p><p id="d03b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">查看<a class="ae kl" href="https://github.com/tensorflow/tfjs-models/blob/master/mobilenet/src/index.ts#L27" rel="noopener ugc nofollow" target="_blank">源代码</a>,<code class="fe mi mj mk ml b">mobilenet</code>库是底层<code class="fe mi mj mk ml b">tf.Model</code>类的包装器。当调用<code class="fe mi mj mk ml b">load()</code>方法时，它会自动从外部HTTP地址下载正确的模型文件，并实例化TensorFlow模型。</p><p id="6d30" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Node.js扩展尚不支持动态检索模型的HTTP请求。相反，必须从文件系统中手动加载模型。</p><p id="5b82" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="km">在阅读了库的源代码后，我设法创建了一个解决方案……</em></p><h2 id="c675" class="mm lb iq bd lc mn mo dn lg mp mq dp lk jy mr ms lo kc mt mu ls kg mv mw lw mx bi translated">从文件系统加载模型</h2><p id="1726" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">如果手工创建了<code class="fe mi mj mk ml b">MobileNet</code>类，那么包含模型HTTP地址的自动生成的<code class="fe mi mj mk ml b">path</code>变量可以用本地文件系统路径覆盖，而不是调用模块的<code class="fe mi mj mk ml b">load</code>方法。完成这些后，调用类实例上的<code class="fe mi mj mk ml b">load</code>方法将触发<a class="ae kl" href="https://js.tensorflow.org/tutorials/model-save-load.html" rel="noopener ugc nofollow" target="_blank">文件系统加载器类</a>，而不是尝试使用基于浏览器的HTTP加载器。</p><pre class="my mz na nb gt nc ml nd ne aw nf bi"><span id="79ff" class="mm lb iq ml b gy ng nh l ni nj">const path = "mobilenet/model.json"<br/>const mn = new mobilenet.MobileNet(1, 1);<br/>mn.path = `file://${path}`<br/>await mn.load()</span></pre><p id="27f7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">厉害，管用！</strong></p><p id="68e6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="km">但是模型文件是怎么来的呢？</em></p></div><div class="ab cl kt ku hu kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ij ik il im in"><h1 id="6f21" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">MobileNet型号</h1><p id="fee4" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">TensorFlow.js的模型由两种文件类型组成，一种是存储在JSON中的模型配置文件，另一种是二进制格式的模型权重。模型权重通常被分割成多个文件，以便浏览器更好地缓存。</p><p id="aedd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">查看MobileNet型号的<a class="ae kl" href="https://github.com/tensorflow/tfjs-models/blob/master/mobilenet/src/index.ts#L68-L76" rel="noopener ugc nofollow" target="_blank">自动加载代码</a>，型号配置和重量碎片从该地址的公共存储桶中检索。</p><pre class="my mz na nb gt nc ml nd ne aw nf bi"><span id="4084" class="mm lb iq ml b gy ng nh l ni nj"><a class="ae kl" href="https://storage.googleapis.com/tfjs-models/tfjs/mobilenet_v${version}_${alpha}_${size}/" rel="noopener ugc nofollow" target="_blank">https://storage.googleapis.com/tfjs-models/tfjs/mobilenet_v${version}_${alpha}_${size}/</a></span></pre><p id="094d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">URL中的模板参数指此处列出的<a class="ae kl" href="https://github.com/tensorflow/models/blob/master/research/slim/nets/mobilenet_v1.md#pre-trained-models" rel="noopener ugc nofollow" target="_blank">型号版本。每个版本的分类准确度结果也显示在该页面上。</a></p><p id="7235" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="km">根据</em> <a class="ae kl" href="https://github.com/tensorflow/tfjs-models/blob/master/mobilenet/src/index.ts#L36" rel="noopener ugc nofollow" target="_blank"> <em class="km">源代码</em> </a> <em class="km">，使用</em> <code class="fe mi mj mk ml b"><em class="km">tensorflow-models/mobilenet</em></code> <em class="km">库只能加载MobileNet v1机型。</em></p><p id="f1fd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">HTTP检索代码从这个位置加载<code class="fe mi mj mk ml b">model.json</code>文件，然后递归地获取所有引用的模型权重碎片。这些文件的格式是<code class="fe mi mj mk ml b">groupX-shard1of1</code>。</p><h2 id="7dad" class="mm lb iq bd lc mn mo dn lg mp mq dp lk jy mr ms lo kc mt mu ls kg mv mw lw mx bi translated">手动下载模型</h2><p id="dcea" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">通过检索模型配置文件、解析出引用的权重文件并手动下载每个权重文件，可以将所有模型文件保存到文件系统中。</p><p id="7d76" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我想使用alpha值为1.0、图像大小为224像素的MobileNet V1模块。这给了我模型配置文件的<a class="ae kl" href="https://storage.googleapis.com/tfjs-models/tfjs/mobilenet_v1_1.0_224/model.json" rel="noopener ugc nofollow" target="_blank">以下URL </a>。</p><p id="9ce0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mi mj mk ml b"><a class="ae kl" href="https://storage.googleapis.com/tfjs-models/tfjs/mobilenet_v1_1.0_224/model.json" rel="noopener ugc nofollow" target="_blank">https://storage.googleapis.com/tfjs-models/tfjs/mobilenet_v1_1.0_224/model.json</a></code></p><p id="65f5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦这个文件被下载到本地，我就可以使用<code class="fe mi mj mk ml b"><a class="ae kl" href="https://stedolan.github.io/jq/" rel="noopener ugc nofollow" target="_blank">jq</a></code> <a class="ae kl" href="https://stedolan.github.io/jq/" rel="noopener ugc nofollow" target="_blank">工具</a>来解析所有的权重文件名。</p><pre class="my mz na nb gt nc ml nd ne aw nf bi"><span id="9bed" class="mm lb iq ml b gy ng nh l ni nj">$ cat model.json | jq -r ".weightsManifest[].paths[0]"<br/>group1-shard1of1<br/>group2-shard1of1<br/>group3-shard1of1<br/>...</span></pre><p id="5230" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用<code class="fe mi mj mk ml b">sed</code>工具，我可以用HTTP URL作为这些名称的前缀，为每个权重文件生成URL。</p><pre class="my mz na nb gt nc ml nd ne aw nf bi"><span id="bce9" class="mm lb iq ml b gy ng nh l ni nj">$ cat model.json | jq -r ".weightsManifest[].paths[0]" | sed 's/^/https:\/\/storage.googleapis.com\/tfjs-models\/tfjs\/mobilenet_v1_1.0_224\//'</span><span id="a26b" class="mm lb iq ml b gy nk nh l ni nj">https://storage.googleapis.com/tfjs-models/tfjs/mobilenet_v1_1.0_224/group1-shard1of1<br/>https://storage.googleapis.com/tfjs-models/tfjs/mobilenet_v1_1.0_224/group2-shard1of1<br/>https://storage.googleapis.com/tfjs-models/tfjs/mobilenet_v1_1.0_224/group3-shard1of1<br/>...</span></pre><p id="1430" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用<code class="fe mi mj mk ml b">parallel</code>和<code class="fe mi mj mk ml b">curl</code>命令，我可以将所有这些文件下载到我的本地目录。</p><pre class="my mz na nb gt nc ml nd ne aw nf bi"><span id="790a" class="mm lb iq ml b gy ng nh l ni nj">cat model.json | jq -r ".weightsManifest[].paths[0]" | sed 's/^/https:\/\/storage.googleapis.com\/tfjs-models\/tfjs\/mobilenet_v1_1.0_224\//' | parallel curl -O</span></pre><h1 id="bf13" class="la lb iq bd lc ld md lf lg lh me lj lk ll mf ln lo lp mg lr ls lt mh lv lw lx bi translated">图像分类</h1><p id="fa9c" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated"><a class="ae kl" href="https://github.com/tensorflow/tfjs-models/tree/master/mobilenet#via-npm" rel="noopener ugc nofollow" target="_blank">本示例代码</a>由TensorFlow.js提供，用于演示返回图像的分类。</p><pre class="my mz na nb gt nc ml nd ne aw nf bi"><span id="989e" class="mm lb iq ml b gy ng nh l ni nj">const img = document.getElementById('img');<br/>// Classify the image.<br/>const predictions = await model.classify(img);</span></pre><p id="9fc2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">由于缺少DOM，这在Node.js上不起作用。</strong></p><p id="b3bd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mi mj mk ml b">classify</code> <a class="ae kl" href="https://github.com/tensorflow/tfjs-models/blob/master/mobilenet/src/index.ts#L143-L155" rel="noopener ugc nofollow" target="_blank">方法</a>接受大量的DOM元素(<code class="fe mi mj mk ml b">canvas</code>、<code class="fe mi mj mk ml b">video</code>、<code class="fe mi mj mk ml b">image</code>)，并将自动从这些元素中检索图像字节并将其转换成一个<code class="fe mi mj mk ml b"><a class="ae kl" href="https://js.tensorflow.org/api/latest/index.html#tensor3d" rel="noopener ugc nofollow" target="_blank">tf.Tensor3D</a></code> <a class="ae kl" href="https://js.tensorflow.org/api/latest/index.html#tensor3d" rel="noopener ugc nofollow" target="_blank">类</a>，作为模型的输入。或者，可以直接传递<code class="fe mi mj mk ml b">tf.Tensor3D</code>输入。</p><p id="fefc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">比起尝试使用外部包来模拟Node.js中的DOM元素，我发现手动构造</strong> <code class="fe mi mj mk ml b"><strong class="jp ir">tf.Tensor3D</strong></code> <strong class="jp ir">更容易。</strong></p><h2 id="1eed" class="mm lb iq bd lc mn mo dn lg mp mq dp lk jy mr ms lo kc mt mu ls kg mv mw lw mx bi translated">从图像生成张量3D</h2><p id="b198" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">阅读用于将DOM元素转换为Tensor3D类的方法的<a class="ae kl" href="https://github.com/tensorflow/tfjs-core/blob/master/src/kernels/backend_cpu.ts#L126-L140" rel="noopener ugc nofollow" target="_blank">源代码</a>，以下输入参数用于生成Tensor3D类。</p><pre class="my mz na nb gt nc ml nd ne aw nf bi"><span id="865f" class="mm lb iq ml b gy ng nh l ni nj">const values = new Int32Array(image.height * image.width * numChannels);<br/>// fill pixels with pixel channel bytes from image<br/>const outShape = [image.height, image.width, numChannels];<br/>const input = tf.tensor3d(values, outShape, 'int32');</span></pre><p id="ed95" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mi mj mk ml b">pixels</code>是(Int32Array)类型的2D数组，包含每个像素的通道值的顺序列表。<code class="fe mi mj mk ml b">numChannels</code>是每个像素通道值的数量。</p><h2 id="01d0" class="mm lb iq bd lc mn mo dn lg mp mq dp lk jy mr ms lo kc mt mu ls kg mv mw lw mx bi translated">为JPEGs创建输入值</h2><p id="504a" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated"><code class="fe mi mj mk ml b"><a class="ae kl" href="https://www.npmjs.com/package/jpeg-js" rel="noopener ugc nofollow" target="_blank">jpeg-js</a></code> <a class="ae kl" href="https://www.npmjs.com/package/jpeg-js" rel="noopener ugc nofollow" target="_blank">库</a>是Node.js的纯javascript JPEG编码器和解码器。使用该库可以提取每个像素的RGB值。</p><pre class="my mz na nb gt nc ml nd ne aw nf bi"><span id="3042" class="mm lb iq ml b gy ng nh l ni nj">const pixels = jpeg.decode(buffer, true);</span></pre><p id="6860" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这将为每个像素(<code class="fe mi mj mk ml b">width * height</code>)返回具有四个通道值(<code class="fe mi mj mk ml b">RGBA</code>)的<code class="fe mi mj mk ml b">Uint8Array</code>。MobileNet模型仅使用三个颜色通道(<code class="fe mi mj mk ml b">RGB</code>)进行分类，忽略alpha通道。此代码将四通道数组转换为正确的三通道版本。</p><pre class="my mz na nb gt nc ml nd ne aw nf bi"><span id="f885" class="mm lb iq ml b gy ng nh l ni nj">const numChannels = 3;<br/>const numPixels = image.width * image.height;<br/>const values = new Int32Array(numPixels * numChannels);<br/><br/>for (let i = 0; i &lt; numPixels; i++) {<br/>  for (let channel = 0; channel &lt; numChannels; ++channel) {<br/>    values[i * numChannels + channel] = pixels[i * 4 + channel];<br/>  }<br/>}</span></pre><h2 id="d11e" class="mm lb iq bd lc mn mo dn lg mp mq dp lk jy mr ms lo kc mt mu ls kg mv mw lw mx bi translated">MobileNet模型输入要求</h2><p id="21ea" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">正在使用的<a class="ae kl" href="https://github.com/tensorflow/models/blob/master/research/slim/nets/mobilenet_v1.md#mobilenet_v1" rel="noopener ugc nofollow" target="_blank"> MobileNet模型</a>对宽和高224像素的图像进行分类。对于三个通道的每个像素值，输入张量必须包含介于-1和1之间的浮点值。</p><p id="ea5d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不同尺寸图像的输入值需要在分类前重新调整大小。此外，来自JPEG解码器的像素值在范围<em class="km">0–255</em>内，而不是<em class="km"> -1到1 </em>。这些值也需要在分类前进行转换。</p><p id="311c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> TensorFlow.js有库方法来使这个过程变得更容易，但是对我们来说幸运的是，</strong> <code class="fe mi mj mk ml b"><strong class="jp ir">tfjs-models/mobilenet</strong></code> <strong class="jp ir">库</strong> <a class="ae kl" href="https://github.com/tensorflow/tfjs-models/blob/master/mobilenet/src/index.ts#L103-L114" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">自动处理</strong> </a> <strong class="jp ir">这个问题！</strong>👍</p><p id="d07a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">开发人员可以将类型为<code class="fe mi mj mk ml b">int32</code>和不同维度的Tensor3D输入传递给<code class="fe mi mj mk ml b">classify</code>方法，它会在分类之前将输入转换为正确的格式。也就是说没事可做…超级🕺🕺🕺.</p><h2 id="2ec0" class="mm lb iq bd lc mn mo dn lg mp mq dp lk jy mr ms lo kc mt mu ls kg mv mw lw mx bi translated">获得预测</h2><p id="ccb7" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">Tensorflow中的MobileNet模型经过训练，可以识别来自<a class="ae kl" href="http://image-net.org/" rel="noopener ugc nofollow" target="_blank"> ImageNet </a>数据集中<a class="ae kl" href="https://github.com/tensorflow/tfjs-models/blob/master/mobilenet/src/imagenet_classes.ts" rel="noopener ugc nofollow" target="_blank">前1000个类</a>的实体。模型输出这些实体中的每一个在被分类的图像中的概率。</p><p id="7672" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="km">在</em> <a class="ae kl" href="https://github.com/tensorflow/tfjs-models/blob/master/mobilenet/src/imagenet_classes.ts" rel="noopener ugc nofollow" target="_blank"> <em class="km">这个文件</em> </a> <em class="km">中可以找到正在使用的模型的训练类的完整列表。</em></p><p id="42b1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mi mj mk ml b">tfjs-models/mobilenet</code>库在<code class="fe mi mj mk ml b">MobileNet</code>类上公开了一个<code class="fe mi mj mk ml b">classify</code>方法，从图像输入中返回概率最高的前X个类。</p><pre class="my mz na nb gt nc ml nd ne aw nf bi"><span id="9c7b" class="mm lb iq ml b gy ng nh l ni nj">const predictions = await mn_model.classify(input, 10);</span></pre><p id="7cf1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mi mj mk ml b">predictions</code>是X个类别和概率的数组，格式如下。</p><pre class="my mz na nb gt nc ml nd ne aw nf bi"><span id="61a0" class="mm lb iq ml b gy ng nh l ni nj">{  className: 'panda',  probability: 0.9993536472320557 }</span></pre></div><div class="ab cl kt ku hu kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ij ik il im in"><h1 id="c8a5" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">例子</h1><p id="5bcc" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">学习了如何在Node.js上使用TensorFlow.js库和MobileNet模型之后，<a class="ae kl" href="https://gist.github.com/jthomas/145610bdeda2638d94fab9a397eb1f1d" rel="noopener ugc nofollow" target="_blank">这个脚本</a>将对作为命令行参数给出的图像进行分类。</p><h1 id="0edb" class="la lb iq bd lc ld md lf lg lh me lj lk ll mf ln lo lp mg lr ls lt mh lv lw lx bi translated">源代码</h1><ul class=""><li id="cefe" class="nl nm iq jp b jq ly ju lz jy nn kc no kg np kk nq nr ns nt bi translated">将这个脚本文件和包描述符保存到本地文件。</li></ul><h1 id="dab1" class="la lb iq bd lc ld md lf lg lh me lj lk ll mf ln lo lp mg lr ls lt mh lv lw lx bi translated">测试它</h1><ul class=""><li id="0cc1" class="nl nm iq jp b jq ly ju lz jy nn kc no kg np kk nq nr ns nt bi translated">按照上面的说明将模型文件下载到一个<code class="fe mi mj mk ml b">mobilenet</code>目录下。</li><li id="5c2c" class="nl nm iq jp b jq nu ju nv jy nw kc nx kg ny kk nq nr ns nt bi translated">使用NPM安装项目依赖项</li><li id="81d5" class="nl nm iq jp b jq nu ju nv jy nw kc nx kg ny kk nq nr ns nt bi translated">下载一个样本JPEG文件进行分类</li></ul><pre class="my mz na nb gt nc ml nd ne aw nf bi"><span id="3597" class="mm lb iq ml b gy ng nh l ni nj">wget http://bit.ly/2JYSal9 -O panda.jpg</span></pre><figure class="my mz na nb gt oa gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/c2324451ad931312a207502de28653c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1392/0*f5N7Zb2Rglk7M1G1.JPG"/></div></figure><ul class=""><li id="371c" class="nl nm iq jp b jq jr ju jv jy od kc oe kg of kk nq nr ns nt bi translated">使用模型文件和输入图像作为参数运行脚本。</li></ul><pre class="my mz na nb gt nc ml nd ne aw nf bi"><span id="6a9c" class="mm lb iq ml b gy ng nh l ni nj">node script.js mobilenet/model.json panda.jpg</span></pre><p id="3809" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">如果一切正常，下面的输出应该会打印到控制台。</strong></p><pre class="my mz na nb gt nc ml nd ne aw nf bi"><span id="f9e0" class="mm lb iq ml b gy ng nh l ni nj">classification results: [ {  className: 'giant panda, panda, panda bear, coon bear',  probability: 0.9993536472320557 } ]</span></pre><p id="a991" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该图像以99.93%的概率被正确分类为包含熊猫！🐼🐼🐼</p></div><div class="ab cl kt ku hu kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ij ik il im in"><h1 id="67e3" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">结论</h1><p id="00ce" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">TensorFlow.js为JavaScript开发者带来了深度学习的力量。通过TensorFlow.js库使用预先训练的模型，可以用最少的工作和代码轻松扩展JavaScript应用程序，完成复杂的机器学习任务。</p><p id="2c37" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">TensorFlow.js已经作为基于浏览器的库发布，现在已经扩展到在Node.js上工作，尽管并非所有的工具和实用程序都支持新的运行时。经过几天的研究，我能够使用MobileNet模型库对本地文件中的图像进行视觉识别。</p><p id="2882" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让它在Node.js运行时工作意味着我现在开始下一个想法……让它在一个无服务器函数中运行！很快回来阅读我与TensorFlow.js的下一次冒险。👋</p></div><div class="ab cl kt ku hu kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ij ik il im in"><p id="327d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="km">原载于2018年8月7日</em><a class="ae kl" href="http://jamesthom.as/blog/2018/08/07/machine-learning-in-node-dot-js-with-tensorflow-dot-js/" rel="noopener ugc nofollow" target="_blank"><em class="km">jamesthom . as</em></a><em class="km">。</em></p></div></div>    
</body>
</html>