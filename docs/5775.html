<html>
<head>
<title>How to use two types across assemblies with the same fully-qualified type names in C#</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在C#中跨具有相同完全限定类型名的程序集使用两种类型</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-use-two-types-across-assemblies-with-the-same-fully-qualified-type-names-in-c-38ce4c902c2?source=collection_archive---------0-----------------------#2021-05-23">https://itnext.io/how-to-use-two-types-across-assemblies-with-the-same-fully-qualified-type-names-in-c-38ce4c902c2?source=collection_archive---------0-----------------------#2021-05-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/de2dce69230b053bf7565860c6cf467a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l8Un2KlQXVuY_jy7R53vBw.jpeg"/></div></div></figure><div class=""/><p id="03dc" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我最近面临一个相当棘手的挑战。我的应用程序引用了两个项目，这两个项目都公开了具有相同名称和相同命名空间的特定类型。</p><p id="aa1a" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">该设置的大致轮廓如下:</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="eb87" class="li lj je le b gy lk ll l lm ln">CommandLine<br/>   - Program.cs</span><span id="bee8" class="li lj je le b gy lo ll l lm ln">DepOne<br/>    - MyType.cs (Namespace: Dep)</span><span id="23e8" class="li lj je le b gy lo ll l lm ln">DepTwo<br/>    - MyType.cs (Namespace: Dep)</span></pre><p id="eb3f" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">所以现在让我们试着使用它。在我们的命令行项目中，我们像这样使用类型:</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="1e5f" class="li lj je le b gy lk ll l lm ln">using Dep;</span><span id="7cf3" class="li lj je le b gy lo ll l lm ln">namespace CommandLine<br/>{<br/>    public class Program<br/>    {<br/>        public static void Main(string[] args)<br/>        {<br/>            var instanceOne = new MyType();<br/>            var instanceTwo = new MyType();<br/>            ...<br/>        }<br/>    }<br/>}</span></pre><p id="6de2" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">嗯，这不太管用:</p><figure class="kz la lb lc gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi lp"><img src="../Images/ef808c8ca51078346ddcf581980f05b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ujI8uu6BQr7OdMjyXEWX1g.png"/></div></div></figure><p id="f4bc" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们的命令行项目引用了DepOne和DepTwo，并且都在同一个名称空间中提供了类型<em class="lq"> MyType </em>。</p><p id="f7ba" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">通常的方法肯定是修复名称空间，给两个<em class="lq"> MyType </em>类一个合适的、可区分的名称空间。</p><p id="a5eb" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">不过，如果这样不行，我们也不算倒霉！</p><h1 id="80a0" class="lr lj je bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">救援的外部别名！</h1><p id="5139" class="pw-post-body-paragraph kb kc je kd b ke mo kg kh ki mp kk kl km mq ko kp kq mr ks kt ku ms kw kx ky im bi translated">对于这种情况，我们可以利用一个非常奇特的特性:Extern alias(<a class="ae mt" href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/extern-alias" rel="noopener ugc nofollow" target="_blank">https://docs . Microsoft . com/en-us/dot net/cs harp/language-reference/keywords/Extern-alias</a>)。</p><p id="92e3" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这将为编译器创建一个别名，以便能够消除这两种类型，即使使用相同的完全限定类型名。</p><p id="94e0" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">遗憾的是文档有点差，最近一次更新是在2015年。我们可以这样使用它:</p><figure class="kz la lb lc gt iv gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/40fe0ea012d58c59d8a31f0c83193d0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:740/format:webp/1*DCTtmeJt_O31KZJxdu2TeA.png"/></div></figure><p id="437d" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果您使用的是Visual Studio，设置extern别名非常容易。只需右键单击您引用的两个(或多个)项目中各自的依赖项，然后单击Properties。</p><figure class="kz la lb lc gt iv gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/7e0529bc2389dfb8815d7f73a50419ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:744/format:webp/1*xirPB20hGm6XBXwhbQqYhA.png"/></div></figure><p id="460a" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，在打开的属性中，我们可以设置一个任意的别名，以便稍后在代码中使用。</p><p id="7a52" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">可悲的是，如果你不使用VS，MS文档没有说明这样做的方法。然而，这很简单。这是。添加别名后的csproj:</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="ed0a" class="li lj je le b gy lk ll l lm ln">&lt;Project Sdk="Microsoft.NET.Sdk"&gt;<br/>    &lt;PropertyGroup&gt;<br/>        &lt;OutputType&gt;Exe&lt;/OutputType&gt;<br/>        &lt;TargetFramework&gt;net5.0&lt;/TargetFramework&gt;<br/>    &lt;/PropertyGroup&gt;<br/>    &lt;ItemGroup&gt;<br/>        &lt;ProjectReference Include="..\DepOne\DepOne.csproj"&gt;<br/>            &lt;Aliases&gt;DepOneAlias&lt;/Aliases&gt;<br/>        &lt;/ProjectReference&gt;<br/>        &lt;ProjectReference Include="..\DepTwo\DepTwo.csproj"&gt;<br/>            &lt;Aliases&gt;DepTwoAlias&lt;/Aliases&gt;<br/>        &lt;/ProjectReference&gt;<br/>    &lt;/ItemGroup&gt;<br/>&lt;/Project&gt;</span></pre><p id="77ab" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如您所见，我们所需要的只是分别带有所需名称的<em class="lq"> &lt;别名&gt; </em>标签。</p><p id="7dc7" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">太好了。所以现在让我们使用它。我们现在需要做的就是用我们刚刚定义的别名向源文件添加一个外部别名。然后我们可以使用范围解析操作符来使用这些别名:</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="0bf3" class="li lj je le b gy lk ll l lm ln">extern alias DepOneAlias;<br/>extern alias DepTwoAlias;</span><span id="3fc1" class="li lj je le b gy lo ll l lm ln">namespace CommandLine<br/>{<br/>    public class Program<br/>    {<br/>        public static void Main(string[] args)<br/>        {<br/>            var instanceOne = new DepOneAlias::Dep.MyType();<br/>            var instanceTwo = new DepTwoAlias::Dep.MyType();<br/>            ...<br/>        }<br/>    }<br/>}</span></pre><p id="01d0" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">开始了。现在我们的代码可以编译了，我们已经成功地使用了两个具有相同完全限定类型名的类型。</p><p id="11a4" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">虽然这是一个你自己的代码可能永远也不会用到的奇特特性，但是在处理大量的NuGet包时，这种情况绝对有可能发生。想象一下在一个. Net Framework项目中工作，该项目可能引用相同功能的. Net Framework和. Net标准实现。碰撞绝对不是不寻常的。</p><p id="95e1" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">所以，正如我提到的——更多的是一种“奇异”的东西，但是当你需要它的时候，知道这一点是非常好的！</p></div></div>    
</body>
</html>