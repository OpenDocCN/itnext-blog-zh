<html>
<head>
<title>Module Oriented Architecture — Part 3: Modules and Routing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向模块的体系结构第3部分:模块和路由</h1>
<blockquote>原文：<a href="https://itnext.io/module-oriented-architecture-part-3-modules-and-routing-241b06439a9f?source=collection_archive---------8-----------------------#2018-05-15">https://itnext.io/module-oriented-architecture-part-3-modules-and-routing-241b06439a9f?source=collection_archive---------8-----------------------#2018-05-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="fa11" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">刷新你的记忆:</p><div class="kl km gp gr kn ko"><a href="https://medium.com/@poksi/module-oriented-architecture-part-2-routing-and-modules-2437e6a292e7" rel="noopener follow" target="_blank"><div class="kp ab fo"><div class="kq ab kr cl cj ks"><h2 class="bd ir gy z fp kt fr fs ku fu fw ip bi translated">面向模块的体系结构第2部分:路由和模块</h2><div class="kv l"><h3 class="bd b gy z fp kt fr fs ku fu fw dk translated">刷新你的记忆:</h3></div><div class="kw l"><p class="bd b dl z fp kt fr fs ku fu fw dk translated">medium.com</p></div></div><div class="kx l"><div class="ky l kz la lb kx lc ld ko"/></div></div></a></div><h1 id="1a50" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">模块布线</h1><p id="5cf1" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">它在<code class="fe mh mi mj mk b">ModuleRouting</code>协议中定义得非常简单。它的作用主要是从ModuleType类中获取路由任务，只让它们负责充当模块功能的网关。另一方面，模块路由器将把对模块的<code class="fe mh mi mj mk b">open</code>调用路由到用<code class="fe mh mi mj mk b">path</code>参数定义的适当功能。</p><h1 id="b577" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">登录模块路由器</h1><p id="22e2" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">让我们先来看看第一个<code class="fe mh mi mj mk b">LoginModuleRouter</code>:</p><figure class="ml mm mn mo gt mp"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="258d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们先来关注一下<code class="fe mh mi mj mk b">ApplicationServices</code> <code class="fe mh mi mj mk b">pay</code>调用中使用的<code class="fe mh mi mj mk b">case “/payment-token”</code>。我们这里有一个对<code class="fe mh mi mj mk b">LoginInteractor</code>的简单调用(将在后面介绍)并在其回调中返回<code class="fe mh mi mj mk b">token</code>参数。然后，令牌从交互器返回到<code class="fe mh mi mj mk b">LoginModule</code>回调，交互器将令牌返回到代表动作<code class="fe mh mi mj mk b"> /payment-token</code>结果的<code class="fe mh mi mj mk b">ApplicationServices</code>回调。</p><p id="2ab9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您还可以看到，我们已经在<code class="fe mh mi mj mk b">enum LoginModuleParameters: String</code>中正式确定了潜在参数。</p><p id="d57f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们看看<code class="fe mh mi mj mk b">LoginInteractor</code>:</p><figure class="ml mm mn mo gt mp"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="8aa0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如你所见，这几乎是我们对交互类的期望。我们不会深入讨论<code class="fe mh mi mj mk b">MockInteractorService</code>类的细节，因为它与我们的案例无关，但是，在本系列下一章的末尾，您会在整个存储库中看到完整的代码。</p><h1 id="dcaa" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">支付模块路由器</h1><p id="968e" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">你可以想象，那一个和<code class="fe mh mi mj mk b">LoginModuleRouter</code>非常相似，所以我把两个类放在同一个要点里:</p><figure class="ml mm mn mo gt mp"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="2042" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">同样，我们不会为<code class="fe mh mi mj mk b">MockPaymentsNetworkService</code>而烦恼。我们可以看到这个故事非常简单，我们只需通过<code class="fe mh mi mj mk b">token</code>和<code class="fe mh mi mj mk b">amount</code>就可以成功执行交易。</p><h1 id="1948" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">类图</h1><p id="60a5" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">我想现在我们可以用一个合适的类图来结束第一次旅程，以便更好地表示体系结构:</p><figure class="ml mm mn mo gt mp gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi ms"><img src="../Images/ee2c3a1cddd516a6509e057739e089cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rFhEU4gaGgGzMmoygJpPbw.png"/></div></div></figure><p id="fe61" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下一章将处理不同种类的模块。不符合<code class="fe mh mi mj mk b">ModuleType</code>的。</p><div class="kl km gp gr kn ko"><a href="https://medium.com/@poksi/module-oriented-architecture-part-4-non-conforming-modules-9c18ec2d2180" rel="noopener follow" target="_blank"><div class="kp ab fo"><div class="kq ab kr cl cj ks"><h2 class="bd ir gy z fp kt fr fs ku fu fw ip bi translated">面向模块的体系结构第4部分:非一致性模块</h2><div class="kv l"><h3 class="bd b gy z fp kt fr fs ku fu fw dk translated">刷新你的记忆:</h3></div><div class="kw l"><p class="bd b dl z fp kt fr fs ku fu fw dk translated">medium.com</p></div></div></div></a></div></div></div>    
</body>
</html>