<html>
<head>
<title>The best frontend development strategies in 2022</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">2022年最佳前端发展策略</h1>
<blockquote>原文：<a href="https://itnext.io/the-best-frontend-development-strategies-in-2022-cb02dd7aa48b?source=collection_archive---------0-----------------------#2021-08-20">https://itnext.io/the-best-frontend-development-strategies-in-2022-cb02dd7aa48b?source=collection_archive---------0-----------------------#2021-08-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="4b5e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这篇文章是有挑战性的，两极分化的，发人深省的。它涵盖了许多你很可能不知道的新鲜内容和想法。</p><h1 id="b419" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">内容</h1><ol class=""><li id="8b91" class="lj lk iq jp b jq ll ju lm jy ln kc lo kg lp kk lq lr ls lt bi translated">介绍</li><li id="6c9e" class="lj lk iq jp b jq lu ju lv jy lw kc lx kg ly kk lq lr ls lt bi translated">电脑或智能手机上有多少个内核？</li><li id="b8e6" class="lj lk iq jp b jq lu ju lv jy lw kc lx kg ly kk lq lr ls lt bi translated">一个浏览器用几个核心？</li><li id="abb6" class="lj lk iq jp b jq lu ju lv jy lw kc lx kg ly kk lq lr ls lt bi translated">Web Workers API</li><li id="5f67" class="lj lk iq jp b jq lu ju lv jy lw kc lx kg ly kk lq lr ls lt bi translated">“应用工作者是主要参与者”的范例</li><li id="1e08" class="lj lk iq jp b jq lu ju lv jy lw kc lx kg ly kk lq lr ls lt bi translated">工人可以访问DOM吗？</li><li id="df5a" class="lj lk iq jp b jq lu ju lv jy lw kc lx kg ly kk lq lr ls lt bi translated">工人可以访问DOM有例外吗？</li><li id="4f99" class="lj lk iq jp b jq lu ju lv jy lw kc lx kg ly kk lq lr ls lt bi translated">如何聪明的创建虚拟DOM？</li><li id="4e39" class="lj lk iq jp b jq lu ju lv jy lw kc lx kg ly kk lq lr ls lt bi translated">UI开发可以直接发生在浏览器内部吗？</li><li id="f0e5" class="lj lk iq jp b jq lu ju lv jy lw kc lx kg ly kk lq lr ls lt bi translated">TypeScript有前途吗？</li><li id="7ecc" class="lj lk iq jp b jq lu ju lv jy lw kc lx kg ly kk lq lr ls lt bi translated">React有什么问题？</li><li id="af81" class="lj lk iq jp b jq lu ju lv jy lw kc lx kg ly kk lq lr ls lt bi translated">多窗口应用程序</li><li id="a4e6" class="lj lk iq jp b jq lu ju lv jy lw kc lx kg ly kk lq lr ls lt bi translated">我们需要自己实施工人设置吗？</li><li id="51e3" class="lj lk iq jp b jq lu ju lv jy lw kc lx kg ly kk lq lr ls lt bi translated">最后的想法</li><li id="1c07" class="lj lk iq jp b jq lu ju lv jy lw kc lx kg ly kk lq lr ls lt bi translated">【更新】如何入门？</li></ol><h1 id="1149" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">1.介绍</h1><p id="0079" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">我将尽力创建一系列相互关联的逻辑论证，您可以根据这些论证了解前端开发应该如何工作。</p><p id="76c8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我还会尽量保持这篇博文的简洁，这样“非开发者”也能大部分关注它。</p><h1 id="ad16" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">2.电脑或智能手机上有多少个内核？</h1><p id="e870" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">你们都见过这样的CPU图片:</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div class="gh gi mc"><img src="../Images/f11edf35ce616a91c357a99a9eff64d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:294/format:webp/1*TSaSPmcPsgve1qWvCpipsg.png"/></div></figure><p id="9cdc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，如果你使用的是苹果电脑，你可以点击左上角的苹果图标，然后点击“关于这台苹果电脑”，它会显示如下内容:</p><pre class="md me mf mg gt mk ml mm mn aw mo bi"><span id="f4ef" class="mp km iq ml b gy mq mr l ms mt">Processor 3,2 GHz 8-Core Intel Xeon W</span></pre><p id="624c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一部iPhone有6个内核。</p><p id="99b0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">TL-BR:每台电脑或智能手机都有几个可用的内核。</p><p id="1bee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这意味着您可以并行运行多个线程。</p><p id="ce03" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你会用一个引擎缸造一辆车吗？</p><p id="2c97" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你的答案是:“当然不是！那会慢很多！”，那么你应该仔细阅读这篇文章。</p><h1 id="4892" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">3.一个浏览器用几个核？</h1><p id="1108" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">就其本身而言，一个浏览器的每个标签/窗口将只使用<strong class="jp ir">一个</strong>内核。</p><p id="fe53" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">含义:您的Angular或React应用程序如下所示:</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/7cb431cb5ff3c096a14d17d929775a2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:918/format:webp/1*kbMLSNJaiIyZK4SWlndLXA.png"/></div></figure><p id="9315" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">应用程序中运行的JavaScript任务越多，速度就越慢。最糟糕的情况是一个完全的UI冻结，你的<strong class="jp ir">一个</strong>核心是100%,而所有其他核心完全空闲。</p><p id="c7e5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是<strong class="jp ir">根本不是</strong>可扩展的。</p><p id="536b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mv">[旁注]如果你正在创建简单、小型且相当静态的网站或应用程序，这个设置就足够了。</em></p><h1 id="4152" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">4.Web Workers API</h1><div class="mw mx gp gr my mz"><a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API" rel="noopener  ugc nofollow" target="_blank"><div class="na ab fo"><div class="nb ab nc cl cj nd"><h2 class="bd ir gy z fp ne fr fs nf fu fw ip bi translated">Web Workers API-Web API | MDN</h2><div class="ng l"><h3 class="bd b gy z fp ne fr fs nf fu fw dk translated">Web Workers使得在独立于主执行线程的后台线程中运行脚本操作成为可能…</h3></div><div class="nh l"><p class="bd b dl z fp ne fr fs nf fu fw dk translated">developer.mozilla.org</p></div></div><div class="ni l"><div class="nj l nk nl nm ni nn mi mz"/></div></div></a></div><blockquote class="no np nq"><p id="8ad9" class="jn jo mv jp b jq jr js jt ju jv jw jx nr jz ka kb ns kd ke kf nt kh ki kj kk ij bi translated"><strong class="jp ir"> Web Workers </strong>使得在独立于Web应用程序主执行线程的后台线程中运行脚本操作成为可能。这样做的好处是繁重的处理可以在一个单独的线程中执行，允许主线程(通常是UI)运行而不会被阻塞/减慢。</p></blockquote><div class="mw mx gp gr my mz"><a href="https://en.wikipedia.org/wiki/Web_worker" rel="noopener  ugc nofollow" target="_blank"><div class="na ab fo"><div class="nb ab nc cl cj nd"><h2 class="bd ir gy z fp ne fr fs nf fu fw ip bi translated">网络工作者-维基百科</h2><div class="ng l"><h3 class="bd b gy z fp ne fr fs nf fu fw dk translated">编辑描述</h3></div><div class="nh l"><p class="bd b dl z fp ne fr fs nf fu fw dk translated">en.wikipedia.org</p></div></div><div class="ni l"><div class="nu l nk nl nm ni nn mi mz"/></div></div></a></div><blockquote class="no np nq"><p id="a698" class="jn jo mv jp b jq jr js jt ju jv jw jx nr jz ka kb ns kd ke kf nt kh ki kj kk ij bi translated">W3C和WHATWG将web workers设想为长期运行的脚本，不会被响应点击或其他用户交互的脚本中断。让这样的工作人员不被用户活动打断应该允许网页在后台运行长时间任务的同时保持响应。</p><p id="065f" class="jn jo mv jp b jq jr js jt ju jv jw jx nr jz ka kb ns kd ke kf nt kh ki kj kk ij bi translated">workers最简单的用途是在不中断用户界面的情况下执行计算量很大的任务。</p></blockquote><p id="8985" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，通过使用workers，我们实际上可以并行使用多个内核，结束这个可扩展性噩梦。</p><p id="0866" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让下面的引用真正深入人心:</p><blockquote class="no np nq"><p id="cdcc" class="jn jo mv jp b jq jr js jt ju jv jw jx nr jz ka kb ns kd ke kf nt kh ki kj kk ij bi translated">workers最简单的用途是在不中断用户界面的情况下执行计算量很大的任务。</p></blockquote><p id="46d4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这引出了一个问题:</p><p id="cf03" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">“最贵的任务是什么？”</p><p id="e824" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">答案很简单:UI框架或库本身，以及我们用它构建的应用程序。</p><p id="e161" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就引出了一个想法:让我们把所有能做的事情都从主线程中移走，这样这个线程就可以专注于它想要做的事情:操纵DOM。</p><p id="b80c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你的应用程序不再在main中运行，就不会有任何东西会减慢或阻塞你的UI或造成内存泄漏。</p><p id="9edc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这一思想导致了以下概念:</p><h1 id="e683" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">5.应用程序工作人员是主要参与者范例</h1><p id="ec95" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">为了解决这个性能瓶颈，我们希望让主线程尽可能空闲，以便它们可以完全专注于渲染/动态操作DOM:</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/0bdcd6bd3f039b70a03cfdb02ba56b71.png" data-original-src="https://miro.medium.com/v2/resize:fit:884/format:webp/1*urYhWPpaFQu8CEJFolIREw.png"/></div></figure><p id="5492" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在可能发生的最糟糕的情况是，您的应用程序工作人员将会变慢，并且这个核心以100%的速度运行。不过这不会影响你的UI(渲染线程→ main)。</p><p id="39ff" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">单页应用程序(spa)的最佳解决方案可能是这样的:</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="nx ny di nz bf oa"><div class="gh gi nw"><img src="../Images/96ef3d303e22eaa8672ec908da913353.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GQEbjjK_ORkFNOLklWfRRA.png"/></div></div></figure><p id="70f7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了防止应用程序工作器处理太多的逻辑，我们可以选择使用虚拟DOM工作器，并计算状态转换之间的增量更新。对于有一个非常空闲的应用程序工作器的应用程序，您可以直接在应用程序工作器中运行虚拟DOM引擎。</p><p id="78f7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们也可以使用数据工作者。如果我们有一个远程数据存储，并希望在本地对数据进行排序/分组/过滤，这些计算可以在那里进行。</p><p id="71a7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这篇博客文章介绍了如何在保持相同API的同时使工人的使用成为可选的:</p><div class="mw mx gp gr my mz"><a rel="noopener  ugc nofollow" target="_blank" href="/javascript-development-making-a-web-worker-optional-f23a13490b28"><div class="na ab fo"><div class="nb ab nc cl cj nd"><h2 class="bd ir gy z fp ne fr fs nf fu fw ip bi translated">JavaScript开发:让Web Worker成为可选的</h2><div class="ng l"><h3 class="bd b gy z fp ne fr fs nf fu fw dk translated">如果你有很多JavaScript相关的逻辑运行在一个主线程或者一个Web Worker中，这是非常有意义的…</h3></div><div class="nh l"><p class="bd b dl z fp ne fr fs nf fu fw dk translated">itnext.io</p></div></div><div class="ni l"><div class="ob l nk nl nm ni nn mi mz"/></div></div></a></div><h1 id="96ef" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">6.工人可以访问DOM吗？</h1><p id="24f6" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">在<a class="ae oc" href="https://developer.mozilla.org/en-US/docs/Web/API/WorkerGlobalScope" rel="noopener ugc nofollow" target="_blank">工作全局范围内</a>、<code class="fe od oe of ml b">window</code>和<code class="fe od oe of ml b">window.document</code>未定义。</p><p id="7575" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">意思是:你不能直接访问真正的DOM。</p><p id="3e65" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以，我们基本上有两个选择。</p><p id="2d10" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">选项1是在worker中重新创建整个DOM API。在我看来，这是个坏主意。工人们没有意识到DOM是有原因的，并且有大量的逻辑经常改变。DOM OPs变成了异步的，如果你按顺序触发了很多，就会导致大量的工人后消息。唯一的好处是你可以像以前一样继续写你的应用，这是值得怀疑的。稍后我将介绍如何做得更好。</p><p id="9ab9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">实际上有一个项目就是这样做的:</p><div class="mw mx gp gr my mz"><a href="https://github.com/ampproject/worker-dom" rel="noopener  ugc nofollow" target="_blank"><div class="na ab fo"><div class="nb ab nc cl cj nd"><h2 class="bd ir gy z fp ne fr fs nf fu fw ip bi translated">GitHub - ampproject/worker-dom:同样的DOM API和框架，但是在Web Worker中。</h2><div class="ng l"><h3 class="bd b gy z fp ne fr fs nf fu fw dk translated">相同的DOM API和框架，但是在Web Worker中。- GitHub - ampproject/worker-dom:相同的DOM API和…</h3></div><div class="nh l"><p class="bd b dl z fp ne fr fs nf fu fw dk translated">github.com</p></div></div><div class="ni l"><div class="og l nk nl nm ni nn mi mz"/></div></div></a></div><p id="85b7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">更聪明的方法是选项2:坚持工人不应该知道真正的DOM的概念。</p><p id="be6b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这使得使用虚拟DOM成为绝对必要的。</p><p id="3223" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在社交媒体上阅读，我看到类似“vdom不好！”相当频繁。</p><p id="dd88" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这根本不是真的。这很大程度上取决于它是如何实现的。</p><p id="c614" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Angular和React中的主要障碍是基于xml或JSX的模板。这些人需要转换成我们可以使用的数据结构。</p><p id="bd90" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">JavaScript既不快速也不适合解析字符串。</p><p id="8067" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">解析模板非常昂贵，以至于服务器端呈现(SSR)再次流行起来。20年前我去过T2，创建了一个基于PHP的CMS，它可以生成html输出文件。</p><p id="301a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可能会说，如今有了可以处理更多客户端连接的云，但是<a class="ae oc" href="https://en.wikipedia.org/wiki/Rich_client" rel="noopener ugc nofollow" target="_blank">富/胖/胖客户端</a>的概念仍然完全有意义。</p><h1 id="7a35" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">7.工人可以访问DOM有例外吗？</h1><p id="9927" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">实际上有一个:</p><div class="mw mx gp gr my mz"><a href="https://developer.mozilla.org/en-US/docs/Web/API/OffscreenCanvas" rel="noopener  ugc nofollow" target="_blank"><div class="na ab fo"><div class="nb ab nc cl cj nd"><h2 class="bd ir gy z fp ne fr fs nf fu fw ip bi translated">屏幕外画布-Web API | MDN</h2><div class="ng l"><h3 class="bd b gy z fp ne fr fs nf fu fw dk translated">OffscreenCanvas接口提供了一个可以在屏幕外呈现的画布。它在窗口和中均可用…</h3></div><div class="nh l"><p class="bd b dl z fp ne fr fs nf fu fw dk translated">developer.mozilla.org</p></div></div><div class="ni l"><div class="oh l nk nl nm ni nn mi mz"/></div></div></a></div><p id="3ac6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">工人可以获得画布DOM节点的所有权。</p><p id="38c0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这在Chromium中已经很好地工作了，Safari (Webkit)和Firefox正在积极地实现它。可能还需要6个月，所以这是2022年的话题。</p><p id="fdd0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可能注意到了最终工人设置<br/> →画布工人中的黄色方框。如果你想深入了解这一点:</p><div class="mw mx gp gr my mz"><a rel="noopener  ugc nofollow" target="_blank" href="/rendering-3d-offscreen-getting-max-performance-using-canvas-workers-88c207cbcdc2"><div class="na ab fo"><div class="nb ab nc cl cj nd"><h2 class="bd ir gy z fp ne fr fs nf fu fw ip bi translated">在屏幕外渲染3d:使用canvas workers获得最佳性能</h2><div class="ng l"><h3 class="bd b gy z fp ne fr fs nf fu fw dk translated">OffscreenCanvas Web API使我们能够将画布DOM元素的所有权转移到workers中。</h3></div><div class="nh l"><p class="bd b dl z fp ne fr fs nf fu fw dk translated">itnext.io</p></div></div><div class="ni l"><div class="oi l nk nl nm ni nn mi mz"/></div></div></a></div><h1 id="f693" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">8.如何聪明的创建虚拟DOM？</h1><p id="453a" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">虽然JavaScript不擅长解析字符串，但它擅长处理嵌套的对象/数组结构。这种格式有一个您最熟悉的名字:<a class="ae oc" href="https://www.json.org/json-en.html" rel="noopener ugc nofollow" target="_blank"> JSON </a>。</p><p id="c06e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们坚持使用基于JSON的vdom语法，就不需要在用户界面中一遍又一遍地进行昂贵的模板解析，甚至不需要将这一部分移到构建步骤中。</p><p id="2820" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这肯定是在某种程度上类似于直接使用JSX输出。</p><p id="5ae4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果做得好，虚拟DOM中没有变量、if/else语句、绑定、方法、循环或任何类型的逻辑。你永远不会看到有1000+行代码的模板(看Angular)。</p><p id="1c12" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用编程方法，您将在它应该在的地方使用逻辑:JavaScript内部。例如，在创建列表时，您可以首先创建一个框架vdom，一旦加载了数据存储，就可以遍历记录并动态创建新的虚拟dom节点。</p><p id="a6a5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个概念允许我们在运行时从根本上改变组件的vdom。是的，在安装组件之前和之后更改组件的vdom的工作方式完全相同。</p><p id="b3ee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">实现无限滚动或其他高级功能变得很容易。</p><p id="b209" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以在这里找到更多信息:</p><div class="mw mx gp gr my mz"><a href="https://medium.com/dataseries/your-benefits-of-working-with-json-based-virtual-dom-7318a983da9e" rel="noopener follow" target="_blank"><div class="na ab fo"><div class="nb ab nc cl cj nd"><h2 class="bd ir gy z fp ne fr fs nf fu fw ip bi translated">使用基于JSON的虚拟DOM的好处</h2><div class="ng l"><h3 class="bd b gy z fp ne fr fs nf fu fw dk translated">许多以前的同事和朋友找到我，问我:“你是如何做到如此高效和快速的……</h3></div><div class="nh l"><p class="bd b dl z fp ne fr fs nf fu fw dk translated">medium.com</p></div></div><div class="ni l"><div class="oj l nk nl nm ni nn mi mz"/></div></div></a></div><div class="mw mx gp gr my mz"><a rel="noopener  ugc nofollow" target="_blank" href="/new-formatting-concept-for-json-based-virtual-dom-ee52acc5e04a"><div class="na ab fo"><div class="nb ab nc cl cj nd"><h2 class="bd ir gy z fp ne fr fs nf fu fw ip bi translated">基于JSON的虚拟DOM的新格式化概念</h2><div class="ng l"><h3 class="bd b gy z fp ne fr fs nf fu fw dk translated">当我在2001年(jQuery之前→ 2006年)第一次钻研Javascript时，有这样一个概念:</h3></div><div class="nh l"><p class="bd b dl z fp ne fr fs nf fu fw dk translated">itnext.io</p></div></div><div class="ni l"><div class="ok l nk nl nm ni nn mi mz"/></div></div></a></div><p id="9a2c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">虽然编程方法对低级vdom操作有意义，但我们肯定更喜欢使用声明性方法来创建我们的应用。</p><p id="1430" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了实现这两个目标，我们唯一需要做的就是在vdom之上添加一个声明性的抽象层:一个组件树。</p><p id="74fd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">意思是:在创建组件类时，您将只使用vdom。对于创建应用程序，你可以坚持使用组件树。</p><h1 id="a705" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">9.UI开发可以直接发生在浏览器内部吗？</h1><p id="f0e0" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">当React在5到8年前开始流行时，浏览器在支持最新ECMAScript特性方面的情况很糟糕。</p><p id="2159" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，不支持类(ES6)或JS模块。</p><p id="931a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这一点上，将UI开发转移到节点是完全有意义的。</p><p id="8bb8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">意思是:你可以使用最新的语言特性，并以一个构建步骤为代价，将你的代码编译/转换成浏览器能够理解的Javascript。</p><p id="52e7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">浏览器厂商在追赶方面做得很好。今天，许多闪亮的新功能都可以直接使用，大多数第三阶段的提议都可以立即实现。</p><p id="22d0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在worker范围内，JS模块在Chromium内工作良好。Webkit (Safari)也完成了实现，但是仍然局限于Safari技术预览版。Mozilla(火狐)正在积极推动。</p><p id="b78a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们完全可以假设2022年全面支持就绪。</p><p id="b9d4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">构建步骤是昂贵的，并且对于UI库或框架的开发模式应该不再需要。</p><p id="37d7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">优势显而易见:</p><ol class=""><li id="4f73" class="lj lk iq jp b jq jr ju jv jy ol kc om kg on kk lq lr ls lt bi translated">JavaScript是浏览器引擎唯一理解的编程语言。</li><li id="45d6" class="lj lk iq jp b jq lu ju lv jy lw kc lx kg ly kk lq lr ls lt bi translated">用浏览器无法理解的方式写JS感觉就是不对。</li><li id="021f" class="lj lk iq jp b jq lu ju lv jy lw kc lx kg ly kk lq lr ls lt bi translated">通过将UI开发带回到浏览器中，我们可以调试我们的真实代码，而不需要任何构建/编译或者使用源代码图。</li><li id="2498" class="lj lk iq jp b jq lu ju lv jy lw kc lx kg ly kk lq lr ls lt bi translated">我们不需要热模块更换。</li></ol><p id="df5f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">尤其是创建和调试代码将再次变得有趣，因为我们可以确保没有外部因素导致错误。</p><p id="767f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">创建<code class="fe od oe of ml b">dist/production</code>输出仍然需要像<a class="ae oc" href="https://github.com/webpack/webpack" rel="noopener ugc nofollow" target="_blank"> webpack </a>这样的工具。然而，它们将是构建工具，而不是运行时环境。</p><p id="a8e6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从节点到节点的转换将进一步推动这一点。普通人迟早会灭绝。一旦deno有了一个包管理器，越来越多的包将使用一种可以在浏览器中运行的语法(例如，不使用裸模块说明符→使用无效路径和没有文件扩展名的导入)。</p><h1 id="af5a" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">10.TypeScript有前途吗？</h1><p id="05ba" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">这可能是本文中最有争议的部分。JS社区分成了两半:一些人喜欢使用TS，而另一些人拒绝接触它。期待讨论。</p><p id="5573" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我的看法:</p><p id="9f7e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，当在node中开发ui并且有一个必需的构建/编译步骤时，使用TS就可以了。</p><p id="7ab5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦UI开发回到浏览器中，这将会彻底改变。</p><p id="20e5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你会仅仅为了使用TS而建立一个完整的构建步骤吗？</p><p id="7fd0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这一点上，它变得太昂贵了。</p><p id="2494" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">事实是:TS是<strong class="jp ir">而不是</strong>一个网络标准。目前还没有在浏览器中实现它的计划。</p><p id="357b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">历史已经多次明确地告诉我们，不基于web标准的基于Web的技术会发生什么:它们会在某个时候消失。Silverlight女士就是一个完美的例子。</p><p id="659a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一般来说，类型检查是件好事。主要问题是Angular和React不使用基于JSDoc的注释，这使得ide在编写代码时会给你警告。</p><p id="acc2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">实际上，甚至有可能使用基于JSDoc的注释来“伪造”TS:</p><div class="mw mx gp gr my mz"><a href="https://goulet.dev/posts/how-to-write-ts-interfaces-in-jsdoc/" rel="noopener  ugc nofollow" target="_blank"><div class="na ab fo"><div class="nb ab nc cl cj nd"><h2 class="bd ir gy z fp ne fr fs nf fu fw ip bi translated">如何在JSDoc注释中编写TypeScript接口</h2><div class="ng l"><h3 class="bd b gy z fp ne fr fs nf fu fw dk translated">我喜欢不用任何构建步骤就能编写web应用程序，非常简单。js文件。但是我仍然喜欢类型检查…</h3></div><div class="nh l"><p class="bd b dl z fp ne fr fs nf fu fw dk translated">goulet.dev</p></div></div><div class="ni l"><div class="oo l nk nl nm ni nn mi mz"/></div></div></a></div><p id="5295" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这绝对是一种选择，也是我们可以讨论的事情。</p><p id="697d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您真的想在编程语言中直接进行类型检查，并且不关心构建步骤，那么<a class="ae oc" href="https://dart.dev/" rel="noopener ugc nofollow" target="_blank"> Dart2 </a>不是更好的选择吗？</p><p id="f812" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Dart2完全支持workers，所以我们也可以在那里运行workers设置。手机的优势包括AOT汇编。</p><h1 id="66c2" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">11.React有什么问题？</h1><p id="3b8a" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">公平地说:在React之前有JQuery。当React变得流行时，这是一个很大的改进，React是第一个让虚拟DOM流行起来的库。</p><p id="3c1d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么，2022年我们为什么要<strong class="jp ir">而不是</strong>使用React呢？</p><ol class=""><li id="6de0" class="lj lk iq jp b jq jr ju jv jy ol kc om kg on kk lq lr ls lt bi translated">React在主线程内部运行。</li><li id="2ac1" class="lj lk iq jp b jq lu ju lv jy lw kc lx kg ly kk lq lr ls lt bi translated">React代码库基于CommonJS →如果没有构建步骤，它就不能在浏览器中运行。</li><li id="2347" class="lj lk iq jp b jq lu ju lv jy lw kc lx kg ly kk lq lr ls lt bi translated">没有JSDoc注释。</li><li id="07b1" class="lj lk iq jp b jq lu ju lv jy lw kc lx kg ly kk lq lr ls lt bi translated">解析JSX模板非常昂贵。甚至有像<a class="ae oc" href="https://github.com/sveltejs/svelte" rel="noopener ugc nofollow" target="_blank">svelite</a>这样的编译器将它移到服务器端。</li><li id="c92c" class="lj lk iq jp b jq lu ju lv jy lw kc lx kg ly kk lq lr ls lt bi translated">React不公开核心。所有东西都扩展组件，这毫无意义。</li><li id="db3d" class="lj lk iq jp b jq lu ju lv jy lw kc lx kg ly kk lq lr ls lt bi translated">国家管理毫无理由地太难了。</li><li id="dd28" class="lj lk iq jp b jq lu ju lv jy lw kc lx kg ly kk lq lr ls lt bi translated"><code class="fe od oe of ml b">render()</code>的方法肯定是有问题的。</li></ol><p id="352b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我更深入地解释一下这个:防止状态变化触发<code class="fe od oe of ml b">render</code>肯定很复杂。如果一个React组件包含子组件(在<code class="fe od oe of ml b">render()</code>中的定制标签)，新的实例将会被创建，以防你不小心使用<code class="fe od oe of ml b">keys</code>。</p><p id="9a01" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">重新创建组件实例使函数式编程变得流行，因为创建类实例的频率超过必要的频率是不高效的，并且您自己的组件实现中的内存泄漏会造成伤害。</p><p id="5963" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你有很多影响物品位置的道具，你需要在你的JSX中加入一些逻辑。</p><p id="b8b5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">React只是一个库，不是框架。意思是:组件几乎就是所有的东西。没有逻辑层次链，如:</p><pre class="md me mf mg gt mk ml mm mn aw mo bi"><span id="d1c0" class="mp km iq ml b gy mq mr l ms mt">core.Base -&gt; component.Base -&gt; button.Base -&gt; tab.header.Button</span></pre><p id="d7a9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦<code class="fe od oe of ml b">render()</code>的疯狂被解决，你就可以为你想创建的任何东西挑选最合适的基类。例如，容器具有vdom对象，该对象包含对其子项目的vdom对象的引用。然后，我们可以更改子组件的vdom，而无需重新创建基于JS的实例。</p><p id="5499" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这一点上，状态管理变得微不足道，我们甚至不需要钩子。尤其是在确保最多1次调用vdom引擎的同时更改许多配置是非常关键的。</p><h1 id="f74f" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">12.多窗口应用程序</h1><p id="2f5d" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">将workers设置切换为使用SharedWorkers可以进一步增强这个概念:</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="nx ny di nz bf oa"><div class="gh gi op"><img src="../Images/34fb95d828f4487dcc81c955b1c8af4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*22xCgzKj-PKkj6GJ6op5gQ.png"/></div></div></figure><p id="7805" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这使我们能够跨不同的浏览器窗口移动整个组件树，同时保持它们的JS实例不变。</p><p id="e24a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">无需后端的多窗口状态管理。</p><p id="a784" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">跨窗口拖放是可能的。</p><p id="a2d7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">博客里有几篇文章介绍了细节。</p><h1 id="5004" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">13.我们需要自己实施工人设置吗？</h1><p id="c890" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">靠你自己实现所有提到的想法可能需要几年时间。</p><p id="be5f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你很幸运，我已经帮你做了。生态系统内超过12，000次提交，完全由麻省理工学院许可:</p><div class="mw mx gp gr my mz"><a href="https://github.com/neomjs/neo" rel="noopener  ugc nofollow" target="_blank"><div class="na ab fo"><div class="nb ab nc cl cj nd"><h2 class="bd ir gy z fp ne fr fs nf fu fw ip bi translated">GitHub - neomjs/neo:应用工人驱动的前端框架</h2><div class="ng l"><h3 class="bd b gy z fp ne fr fs nf fu fw dk translated">neo.mjs使您能够使用一个以上的CPU创建可扩展的高性能应用程序。不需要照顾一个…</h3></div><div class="nh l"><p class="bd b dl z fp ne fr fs nf fu fw dk translated">github.com</p></div></div><div class="ni l"><div class="oq l nk nl nm ni nn mi mz"/></div></div></a></div><p id="11af" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这包括一个远程方法访问API，它使您能够通过promises(消息传递之上的抽象层)直接调用不同workers或main中的方法。</p><p id="117f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">大量的组件已经就位，还有控制器、视图模型、应用程序和其他实用程序类。</p><p id="d4fb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你不需要任何第三方库来支持像MVVM，Observable和许多其他的架构设计模式。</p><p id="69b7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">特别是状态管理非常容易(提示:一个类配置系统)。</p><p id="35b1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">许多演示应用和例子正等着你去探索，40+篇博文:<a class="ae oc" href="https://neomjs.github.io/pages/" rel="noopener ugc nofollow" target="_blank">https://neomjs.github.io/pages/</a></p><p id="ecb2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">CLI是高级的:您可以用一行代码创建一个新的应用程序(工作区):<code class="fe od oe of ml b">npx neo-app</code>。我们甚至获得了跨应用程序的分割块，因此在一个页面上放置多个应用程序几乎没有开销。</p><h1 id="452d" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">14.最后的想法</h1><p id="e7f5" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">你实际上不必等到2022年，你现在就可以使用这些想法让你的前端开发达到下一个水平。一些公司和开发人员已经在这么做了，并且正在利用他们的领先优势将新技术转化为商业优势:</p><div class="mw mx gp gr my mz"><a rel="noopener  ugc nofollow" target="_blank" href="/neo-mjs-nominated-for-the-most-exciting-use-of-technology-cd5983debc7b"><div class="na ab fo"><div class="nb ab nc cl cj nd"><h2 class="bd ir gy z fp ne fr fs nf fu fw ip bi translated">neo.mjs获得“最令人兴奋的技术应用”提名</h2><div class="ng l"><h3 class="bd b gy z fp ne fr fs nf fu fw dk translated">JavaScript开源奖励计划2021内幕。</h3></div><div class="nh l"><p class="bd b dl z fp ne fr fs nf fu fw dk translated">itnext.io</p></div></div><div class="ni l"><div class="or l nk nl nm ni nn mi mz"/></div></div></a></div><p id="5a42" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">大多数开发者仍然不知道<a class="ae oc" href="https://github.com/neomjs/neo" rel="noopener ugc nofollow" target="_blank"> neo.mjs </a>项目的存在，这是一个遗憾。</p><p id="a146" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">我很乐意看到有人证明我在这些概念上是错的！</strong></p><p id="f782" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为此，您需要创建第一个基于neo的概念验证应用程序。</p><p id="bfd7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这种情况下，我很乐意审查您的代码。</p><p id="bb24" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于运行时的动态DOM操作，neo是最快的选择。尤其是对于大型复杂的应用程序。</p><p id="67ac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">欢迎您加入project Slack频道:</p><div class="mw mx gp gr my mz"><a href="https://join.slack.com/t/neomjs/shared_invite/zt-6c50ueeu-3E1~M4T9xkNnb~M_prEEOA" rel="noopener  ugc nofollow" target="_blank"><div class="na ab fo"><div class="nb ab nc cl cj nd"><h2 class="bd ir gy z fp ne fr fs nf fu fw ip bi translated">在Slack上加入neo.mjs</h2><div class="ng l"><h3 class="bd b gy z fp ne fr fs nf fu fw dk translated">我们知道切换浏览器很麻烦，但是我们希望你的Slack体验是快速、安全和最好的…</h3></div><div class="nh l"><p class="bd b dl z fp ne fr fs nf fu fw dk translated">join.slack.com</p></div></div><div class="ni l"><div class="os l nk nl nm ni nn mi mz"/></div></div></a></div><p id="d1ae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">问候并快乐编码，<br/>托拜厄斯</p><p id="9c69" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">附注:今年九月将会有一些大的改变，这也对我的个人状况有好的影响。</p><h1 id="981b" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">15.【更新】如何入门？</h1><p id="d1ff" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">我刚刚创建了一个关于如何使用这项技术构建应用程序的教程:</p><div class="mw mx gp gr my mz"><a href="https://tobiasuhlig.medium.com/define-a-web-4-0-app-to-be-multi-threaded-9c495c0d0ef9" rel="noopener follow" target="_blank"><div class="na ab fo"><div class="nb ab nc cl cj nd"><h2 class="bd ir gy z fp ne fr fs nf fu fw ip bi translated">将web 4.0应用定义为多线程</h2><div class="ng l"><h3 class="bd b gy z fp ne fr fs nf fu fw dk translated">通过学习创造一个视觉上令人惊叹和闪电般快速的下一代，将你的技能提升到一个全新的水平…</h3></div><div class="nh l"><p class="bd b dl z fp ne fr fs nf fu fw dk translated">tobiasuhlig.medium.com</p></div></div><div class="ni l"><div class="ot l nk nl nm ni nn mi mz"/></div></div></a></div><h1 id="4ae0" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">预览图像</h1><p id="ab69" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">想法是:“行动”对“反应”，无论如何angular不在讨论范围之内。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/232f8a57566d8dfe07fe21451c33941b.png" data-original-src="https://miro.medium.com/v2/resize:fit:926/format:webp/1*lY3X0V8UUvy7WmEAB2RT7g.png"/></div></figure></div></div>    
</body>
</html>