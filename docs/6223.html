<html>
<head>
<title>Cashing with Caching</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">缓存兑现</h1>
<blockquote>原文：<a href="https://itnext.io/cashing-with-caching-b839d8c13d24?source=collection_archive---------3-----------------------#2021-09-22">https://itnext.io/cashing-with-caching-b839d8c13d24?source=collection_archive---------3-----------------------#2021-09-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="cbb3" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">了解如何利用缓存使您的外部系统应用程序比以往性能更好，并保护您的后端免受高流量负载的影响。此外，我们将分享一些您应该避免的陷阱和一些帮助您更有效地使用缓存的技巧。</p></div><div class="ab cl km kn hu ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ij ik il im in"><h1 id="ea34" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">基础知识</h1><h2 id="b625" class="lr ku iq bd kv ls lt dn kz lu lv dp ld jz lw lx lh kd ly lz ll kh ma mb lp mc bi translated">定义</h2><p id="8c7e" class="pw-post-body-paragraph jo jp iq jq b jr md jt ju jv me jx jy jz mf kb kc kd mg kf kg kh mh kj kk kl ij bi translated">缓存是将数据存储在临时存储器(<em class="mi">又名</em>缓存)中的过程。从临时存储而不是原始存储(服务器、数据库、外部方等)获取数据。)将减少执行时间，并且将为网络节省额外流量的负担。</p><h2 id="b15d" class="lr ku iq bd kv ls lt dn kz lu lv dp ld jz lw lx lh kd ly lz ll kh ma mb lp mc bi translated">例子</h2><p id="8035" class="pw-post-body-paragraph jo jp iq jq b jr md jt ju jv me jx jy jz mf kb kc kd mg kf kg kh mh kj kk kl ij bi translated">这种技术最常见的情况之一是浏览器缓存，CSS和JavaScript文件在第一次获取后被缓存。这就是为什么第二次打开一个网站比第一次快得多的原因，这也是为什么一段时间后你的浏览器存储增长相当大的原因。</p><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/e1377911c46d5f15851d3a62067d0e47.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*7TRI-h2ZORhmw-s9gh0Sgw.jpeg"/></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">浏览器缓存</figcaption></figure><p id="380e" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">缓存的另一个例子是服务器端缓存，以避免不必要的数据库或外部存储的往返。</p><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/790bdf61155564e4a20085b6d813a7b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1068/format:webp/0*LWWuyBkBFp7A6-fC.png"/></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">服务器端缓存</figcaption></figure><h2 id="48ca" class="lr ku iq bd kv ls lt dn kz lu lv dp ld jz lw lx lh kd ly lz ll kh ma mb lp mc bi translated">何时使用</h2><p id="9de1" class="pw-post-body-paragraph jo jp iq jq b jr md jt ju jv me jx jy jz mf kb kc kd mg kf kg kh mh kj kk kl ij bi translated">我的信息接近静态吗？装起来重吗？通常这些问题会让您首先想到缓存。<br/>经常需要、加载量大且很少改变的信息是缓存的理想选择。如果数据很少使用，那么缓存实际上并没有优化任何东西，或者如果数据经常更改，存储在缓存中的副本将会不断地过时。在这种情况下，<em class="mi">治</em>会比<em class="mi">病</em>更糟糕。</p><p id="ec68" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">诀窍是识别在高使用率和信息改变所需的时间间隔之间有良好平衡的使用案例，或者对于这些使用案例，信息过时是可以接受的。</p><h1 id="5ed4" class="kt ku iq bd kv kw mw ky kz la mx lc ld le my lg lh li mz lk ll lm na lo lp lq bi translated">如何在外部系统中应用它</h1><p id="b53b" class="pw-post-body-paragraph jo jp iq jq b jr md jt ju jv me jx jy jz mf kb kc kd mg kf kg kh mh kj kk kl ij bi translated">出于本文的目的，我们将只考虑反应式和移动应用程序，我们将更多地关注服务器端缓存，以及使用它会产生巨大差异的常见场景。</p><p id="96cb" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">使用OutSystems平台，您可以从两个方面充分利用缓存:</p><p id="9f74" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated"><strong class="jq ir">客户端</strong>(这也给了你的应用程序离线的能力)</p><ul class=""><li id="b112" class="nb nc iq jq b jr js jv jw jz nd kd ne kh nf kl ng nh ni nj bi translated"><a class="ae nk" href="https://success.outsystems.com/Documentation/11/Reference/OutSystems_Language/Data/Handling_Data/Client_Variable" rel="noopener ugc nofollow" target="_blank"> <strong class="jq ir">客户端变量</strong></a>——存储在浏览器中，这些通常用于缓存配置或应用上下文数据。不要用它们来存储敏感或机密信息。</li><li id="74ec" class="nb nc iq jq b jr nl jv nm jz nn kd no kh np kl ng nh ni nj bi translated"><a class="ae nk" href="https://success.outsystems.com/Documentation/Best_Practices/Architecture/Mobile_Data_Layer" rel="noopener ugc nofollow" target="_blank"> <strong class="jq ir">本地存储</strong> </a> -仅适用于移动应用，它允许您将本地信息表存储在设备中，以通过避免服务器端调用来提高性能。</li></ul><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="nr ns di nt bf nu"><div class="gh gi nq"><img src="../Images/b9b029005e653d090b5e74f9a1dce7da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hhH_isg5MVTVOE9fSyqpbw.png"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">外部系统中的客户端变量和本地存储实体</figcaption></figure><p id="0930" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated"><strong class="jq ir">服务器端</strong>(持续时间设定为分钟)</p><ul class=""><li id="a4bd" class="nb nc iq jq b jr js jv jw jz nd kd ne kh nf kl ng nh ni nj bi translated"><strong class="jq ir">服务器动作</strong></li><li id="628f" class="nb nc iq jq b jr nl jv nm jz nn kd no kh np kl ng nh ni nj bi translated"><strong class="jq ir">查询</strong></li></ul><p id="4c8b" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">正确使用时，服务器端缓存将保护您的后端，避免大量不必要的数据库往返，并产生更高性能的应用程序，但也将支持更高的流量峰值。</p><p id="a27d" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">缓存查询或服务器操作的分钟数不能以编程方式设置，也不能在运行时更改。</p><p id="8ba2" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">在拥有大量数据和大量处理信息的场景中，<a class="ae nk" href="https://success.outsystems.com/Documentation/Best_Practices/Performance_and_Monitoring/Optimize_Data_For_Your_Use_Cases_Using_Hot_Cache" rel="noopener ugc nofollow" target="_blank">多层缓存</a>是一个很好的选择，但你需要考虑到它会与你的业务需求建立紧密的联系。</p><h1 id="05de" class="kt ku iq bd kv kw mw ky kz la mx lc ld le my lg lh li mz lk ll lm na lo lp lq bi translated">服务器端缓存——工作原理</h1><p id="5adb" class="pw-post-body-paragraph jo jp iq jq b jr md jt ju jv me jx jy jz mf kb kc kd mg kf kg kh mh kj kk kl ij bi translated">理解缓存如何工作以及它是如何失效的，对于定义适当的缓存策略和防止意外行为非常重要。<br/>当您缓存一个动作或查询时，服务器端将首先检查是否缓存了该动作的结果和输入参数值的<strong class="jq ir">。例如，如果您缓存了一个操作以返回给定雇员id的雇员详细信息，那么最终您将拥有一个针对每个雇员的缓存条目，并且缓存存储受限于服务器上的可用内存。</strong></p><p id="752c" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">如果发生以下事件之一，元素的缓存结果将变得无效，并且其(原始)流将再次执行:</p><ul class=""><li id="a08b" class="nb nc iq jq b jr js jv jw jz nd kd ne kh nf kl ng nh ni nj bi translated"><strong class="jq ir">缓存过期</strong>——基于在缓存的元素上指定的分钟数</li><li id="af45" class="nb nc iq jq b jr nl jv nm jz nn kd no kh np kl ng nh ni nj bi translated"><strong class="jq ir">不同的输入参数</strong> -如上所述</li><li id="bd48" class="nb nc iq jq b jr nl jv nm jz nn kd no kh np kl ng nh ni nj bi translated"><strong class="jq ir">当缓存元素的生产者模块发布时</strong> -缓存对整个模块无效</li><li id="9620" class="nb nc iq jq b jr nl jv nm jz nn kd no kh np kl ng nh ni nj bi translated"><strong class="jq ir">当站点属性的值改变时(在与缓存元素相同的模块中)</strong> -缓存随后对整个模块无效。这就是为什么您应该避免以编程方式更新站点属性的原因之一。</li><li id="790f" class="nb nc iq jq b jr nl jv nm jz nn kd no kh np kl ng nh ni nj bi translated"><strong class="jq ir">当来自<em class="mi">系统</em>的<em class="mi">espace invalidatecache</em>/<em class="mi">TenantInvalidateCache</em>动作运行</strong>时——在这种情况下，模块/租户的缓存将失效。</li></ul><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/45104b0fbb8d640d30690938635b781e.png" data-original-src="https://miro.medium.com/v2/resize:fit:480/format:webp/1*YFMQKWMaZ2XLEMvxRoIdEA.png"/></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated"><strong class="bd kv">无效缓存</strong>在外部系统中以编程方式使用的动作</figcaption></figure><p id="ebe9" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">请务必注意，缓存存储在服务器级别，这意味着当有多个前端服务器时，它的效率会降低。</p><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/7d8f18c484e0d8469fd9ca2fe4ac5b06.png" data-original-src="https://miro.medium.com/v2/resize:fit:772/format:webp/1*PZqvIHnEKyg5X9QaWg8shA.png"/></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">具有3台服务器的基础架构示例，每台服务器都有其本地缓存</figcaption></figure><p id="c7e3" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">在OutSystems 11中，缓存失效服务是负责通过发布-订阅机制通知前端服务器缓存的值不是最新的，迫使它们在需要时获取新值的OutSystems组件(在这里阅读更多信息<a class="ae nk" href="https://success.outsystems.com/Support/Enterprise_Customers/Maintenance_and_Operations/Cache_Invalidation_in_OutSystems_11" rel="noopener ugc nofollow" target="_blank"/>)。</p><h1 id="353c" class="kt ku iq bd kv kw mw ky kz la mx lc ld le my lg lh li mz lk ll lm na lo lp lq bi translated">缓存类型和示例</h1><p id="ae6e" class="pw-post-body-paragraph jo jp iq jq b jr md jt ju jv me jx jy jz mf kb kc kd mg kf kg kh mh kj kk kl ij bi translated">如前所述，当数据请求量和过时(不可接受)所需的时间之间达到良好平衡时，缓存就有了意义。这样，我们可以定义两种类型的缓存:</p><h2 id="4ddb" class="lr ku iq bd kv ls lt dn kz lu lv dp ld jz lw lx lh kd ly lz ll kh ma mb lp mc bi translated">长缓存</h2><p id="4239" class="pw-post-body-paragraph jo jp iq jq b jr md jt ju jv me jx jy jz mf kb kc kd mg kf kg kh mh kj kk kl ij bi translated">用于提高性能，长缓存适用于很少更改的数据，如配置或查找操作。一个很好的例子是客户关系管理，你可以注册你的公司客户和他们的联系方式。您很可能需要在应用程序的几个地方的下拉列表中显示您的客户名称，我们知道这不会经常改变。在这种情况下，缓存它们并使其无效将是一个很好的选择，例如，每当您有一个新的客户机时。<br/>对于这个例子，假设客户机列表每天被请求1k次，每10天注册一个新客户机。这意味着，通过在这种情况下应用缓存，您将保护您的数据库免受10k次调用- 1 *服务器数(当缓存对每个前端服务器无效时对数据库的第一次调用)。</p><h2 id="2f5c" class="lr ku iq bd kv ls lt dn kz lu lv dp ld jz lw lx lh kd ly lz ll kh ma mb lp mc bi translated"><strong class="ak">短缓存</strong></h2><p id="6b19" class="pw-post-body-paragraph jo jp iq jq b jr md jt ju jv me jx jy jz mf kb kc kd mg kf kg kh mh kj kk kl ij bi translated">短缓存用于防止高流量峰值，适用于经常被请求的数据，并且从业务角度来看，可以接受在短时间内过时的数据。例如，如果你去OutSystems Forge主页，你会看到一个包含6个最新Forge组件的部分。该部分需要随时更新吗？实时更新是否会增加价值？一个新的forge组件要花5分钟才能在这里展示出来，这难道不是可以接受的吗？假设OutSystems Forge主页每秒被访问10次，缓存该查询5分钟将避免对数据库的5 * 60 * 5=1，5k次调用(- 1 *前端服务器数，当缓存过期时)。顺便说一句，同样的方法可以应用到同一页面的可信和受支持的应用程序部分，性能会进一步提高。</p><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="nr ns di nt bf nu"><div class="gh gi nx"><img src="../Images/7c7d096d9bc158196d572c350d94bf93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1388/format:webp/1*mRB7Aa9VuzmMbou_XF9gSw.png"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">OutSystems Forge主页包括最新应用和<em class="jn">支持和信任的应用</em>的部分</figcaption></figure><p id="84a3" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">另一个经典的例子是上传一个Excel表，您需要根据标签查找id，以便在关系数据库实体中创建带有正确外键的记录。在许多情况下，标签与选项很少的域表相关。缓存查找查询几分钟应该足够了，通过显著减少到数据库的往返次数，可以大大加快这个过程。</p><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="nr ns di nt bf nu"><div class="gh gi ny"><img src="../Images/36c77d92f628f83596d0a6253f23501c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7hU4NHTNYqeOI6q7-LO-Sw.png"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">导入雇员数据并缓存查找查询以从标签中获取外键的示例</figcaption></figure><h1 id="accd" class="kt ku iq bd kv kw mw ky kz la mx lc ld le my lg lh li mz lk ll lm na lo lp lq bi translated">提示和陷阱</h1><p id="7f10" class="pw-post-body-paragraph jo jp iq jq b jr md jt ju jv me jx jy jz mf kb kc kd mg kf kg kh mh kj kk kl ij bi translated">在使用缓存机制来确保应用程序可伸缩并调整到产生最高性能的几年后，人们注意到了一些常见的缺陷以及制定一些指导原则的重要性:</p><ul class=""><li id="e67f" class="nb nc iq jq b jr js jv jw jz nd kd ne kh nf kl ng nh ni nj bi translated"><strong class="jq ir">不要忘记使缓存失效</strong>——在长缓存场景中，您可能希望尽可能长时间地缓存数据，直到发生变化。不要忘记通过使用上面提到的失效缓存操作或者通过改变输入参数(如版本号)来使缓存失效。</li><li id="2e91" class="nb nc iq jq b jr nl jv nm jz nn kd no kh np kl ng nh ni nj bi translated"><strong class="jq ir">小心带缓存的多语言静态实体</strong>——当你查询一个静态实体时，结果会自动翻译成当时定义的语言环境，当然前提是你有翻译。缓存查询时，翻译后结果也会被缓存。这意味着当您用不同的语言请求相同的结果时，您将得到第一次请求的原始语言的结果。这里的方法是用一个查询缓存一个动作，并添加locale作为输入参数，以保证不同的locale会有不同的结果。</li><li id="63b6" class="nb nc iq jq b jr nl jv nm jz nn kd no kh np kl ng nh ni nj bi translated"><strong class="jq ir">让业务部门参与进来，为您的用例调整正确的缓存刷新率</strong>——对于短缓存场景，作为一名开发人员，您希望尽可能长时间地缓存数据，业务部门将帮助您找到数据可以过期多长时间，以及性能和满足需求之间的正确平衡。</li><li id="6985" class="nb nc iq jq b jr nl jv nm jz nn kd no kh np kl ng nh ni nj bi translated"><strong class="jq ir">在缓存的动作</strong> <strong class="jq ir">名称上弄清楚它们是被缓存的</strong>——当你在外部系统中读取一个逻辑流时，考虑这一点更容易。这比你想象的更常见，忘记使缓存失效，花几个小时调试你的应用程序，却不知道为什么你会得到一个过时的结果。例如，添加一个像<em class="mi"> _cache </em>这样的后缀是使缓存的动作/查询可见的一种方式。</li><li id="6660" class="nb nc iq jq b jr nl jv nm jz nn kd no kh np kl ng nh ni nj bi translated"><strong class="jq ir">明智地使用高速缓存</strong> -高速缓存占用资源(例如内存)，并且这些资源不是无限的，因此高速缓存一切不是解决方案。毕竟，权力越大，责任越大。</li></ul><h1 id="ec05" class="kt ku iq bd kv kw mw ky kz la mx lc ld le my lg lh li mz lk ll lm na lo lp lq bi translated">结论</h1><p id="57c9" class="pw-post-body-paragraph jo jp iq jq b jr md jt ju jv me jx jy jz mf kb kc kd mg kf kg kh mh kj kk kl ij bi translated">缓存通过将常用应用程序数据存储在内存中，为其提供了高吞吐量和低延迟的访问，随着流量的增长，缓存变得越来越重要。在OutSystems中，这一原则没有什么不同，缓存理所当然地被认为是<a class="ae nk" href="https://success.outsystems.com/Documentation/Best_Practices/Performance_and_Monitoring/Performance_Best_Practices_-_User_Interface#Cache.2C_baby.2C_cache!" rel="noopener ugc nofollow" target="_blank">性能最佳实践</a>。</p><p id="18ad" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">作为一种可以大大提高应用程序性能和可扩展性的技术，知道何时以及如何使用是最大化收益和避免意外行为的关键。<br/>我认为缓存也应该成为架构师/技术负责人/开发人员的思维方式和方法的一部分，以挑战业务需求并确定应该应用缓存的情况，从而正确设计高性能的解决方案和可伸缩的架构。</p></div></div>    
</body>
</html>