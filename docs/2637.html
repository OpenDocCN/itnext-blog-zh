<html>
<head>
<title>PHP: Serializing an unserializing the simple way</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">PHP:序列化和非序列化的简单方法</h1>
<blockquote>原文：<a href="https://itnext.io/php-serializing-an-unserializing-the-simple-way-da25c0d9340d?source=collection_archive---------0-----------------------#2019-07-01">https://itnext.io/php-serializing-an-unserializing-the-simple-way-da25c0d9340d?source=collection_archive---------0-----------------------#2019-07-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2e72" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">PHP开发人员讨厌这样！</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2d4d6211b7c85e9a4177d988ac911833.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gc9hr5nULdhop56g"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@fatasuir9?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">吉斯‍ ‍ </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="4a66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">保存一个类的实例的一个棘手之处是序列化。对于那些不知道这到底是什么的人来说，这个概念非常简单:你可以用字符串<strong class="lb iu">表示一个类的实例，这样你就可以在任何地方存储，然后从同一个字符串中恢复这个实例。</strong></p><p id="ad7a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您使用方法<code class="fe lv lw lx ly b">serialize($instance)</code>和<code class="fe lv lw lx ly b">unserialize($string)</code>时，这是在PHP中通过分别使用类实例和类字符串表示自动完成的:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="937d" class="md me it ly b gy mf mg l mh mi">$car = new Car(new OilEngine());</span><span id="bcec" class="md me it ly b gy mj mg l mh mi">FileHandler::set('class.txt', serialize($car));</span><span id="c7ba" class="md me it ly b gy mj mg l mh mi">$sameCar = unserialize(FileHandler::get('class.txt'));</span></pre><p id="e71a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这对于存储实例以便以后检索非常有用，比如在文件、数据库、内存存储(比如redis或memcached)中，或者任何接受文本的东西中。</p><p id="ec1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，将一个用户类实例及其属性保存到一个会话中，这样在下一个请求中检索到它之后，我们就可以恢复同一个用户实例，而不必将其从数据库中取出。嘿，这只是一个例子。</p><h1 id="3a7f" class="mk me it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">处理序列化的旧方法</h1><p id="2ad0" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">在PHP 5.1之前，处理类序列化的唯一方式是使用方法<code class="fe lv lw lx ly b">__sleep()</code>和<code class="fe lv lw lx ly b">__wakeup()</code>。</p><p id="a372" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在将实例传递给PHP的默认序列化进程之前，第一个必须返回一个必须序列化的属性数组，以及其他深度“清理”。另一个将在类未序列化后被调用，这将允许您修改当前实例来恢复已经丢失的<em class="ng"/>。</p><p id="f0a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简单？一点也不。此外，使用<em class="ng">默认</em>序列化时有一些注意事项:</p><ul class=""><li id="5b2a" class="nh ni it lb b lc ld lf lg li nj lm nk lq nl lu nm nn no np bi translated">这个字符串乍一看很难理解，因为PHP使用了一种奇怪的编码来保持类的形状。</li><li id="16b1" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated">您必须考虑到类实例的属性也是可序列化的或不可序列化的，并且有一个在非序列化时恢复它们的解决方法。</li></ul><p id="1a82" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如你所看到的，它们似乎适得其反，令人困惑，但是自从PHP 5.1以来，没有必要再考虑它们了，因为有更好的方法来处理序列化。</p><h1 id="0428" class="mk me it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">欢迎序列化！</h1><p id="35b4" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">PHP有一个方便的接口叫做<a class="ae ky" href="https://www.php.net/manual/en/class.serializable.php" rel="noopener ugc nofollow" target="_blank"> Serializable </a>。这包含了两个你必须设置的方法，叫做<code class="fe lv lw lx ly b">serialize()</code>和<code class="fe lv lw lx ly b">unserialize()</code>，它们在不破坏向后兼容性的情况下替换了旧的调用。</p><p id="6350" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它们几乎不言自明，但无论如何，要点如下:</p><ul class=""><li id="aa0a" class="nh ni it lb b lc ld lf lg li nj lm nk lq nl lu nm nn no np bi translated"><code class="fe lv lw lx ly b">serialize()</code>在类被序列化时被调用。它的目的是将类的一个<strong class="lb iu">字符串表示传递给PHP。例如，我们可以返回一个JSON编码的属性列表。类名会自动附加上返回的字符串——如果没有后者，PHP就不知道以后要去序列化哪个类。</strong></li><li id="3bde" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated">当字符串被反序列化为相应的类时，调用<code class="fe lv lw lx ly b">unserialize()</code>。PHP将检查序列化字符串中的类名，将字符串传递给该方法，并设置类实例需要的任何内容。</li></ul><p id="072b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">乍看之下,<code class="fe lv lw lx ly b">unserialize()</code>方法很难理解，但绝非易事。<a class="ae ky" href="https://www.php.net/manual/en/serializable.unserialize.php" rel="noopener ugc nofollow" target="_blank">正如文档中所说的</a>，这个方法的作用就像一个“构造函数”，这意味着这个类将被实例化，绕过<code class="fe lv lw lx ly b">__construct()</code>方法。如果您需要在<code class="fe lv lw lx ly b">_contruct()</code>中设置一些依赖项，unserialize方法将不得不手动寻找它们，或者(最好)在序列化完成时设置它们:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="19dd" class="md me it ly b gy mf mg l mh mi">$car = unserialize(FileHandler::get('class.txt'));</span><span id="88f3" class="md me it ly b gy mj mg l mh mi">$car-&gt;setWheels(new Wheels());<br/>$car-&gt;setPaintJob(new PaintJob('red'));</span></pre><p id="98a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于设置依赖关系，一个好的方法是在<code class="fe lv lw lx ly b">ReflectionClass</code>的<code class="fe lv lw lx ly b"><a class="ae ky" href="https://www.php.net/manual/en/reflectionclass.getconstructor.php" rel="noopener ugc nofollow" target="_blank">getConstructor()</a></code>和<code class="fe lv lw lx ly b">ReflectionMethod</code>的<code class="fe lv lw lx ly b"><a class="ae ky" href="https://www.php.net/manual/en/reflectionfunctionabstract.getparameters.php" rel="noopener ugc nofollow" target="_blank">getParameters()</a></code>的帮助下，在未序列化的类实例上使用setters，如果你需要更高级和模块化的东西。</p><p id="f4e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是我们正在进步。来连载点什么吧。</p><h1 id="4873" class="mk me it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">序列化和取消序列化汽车</h1><p id="576d" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">你不会下载一辆车？还没有，但是我们可以把它保存在一个文件里。简单浏览一下这个“Car”类，你会注意到它需要一个引擎，我们提供了一个<em class="ng"> PHP 7.4风格的</em>属性来设置颜色，并且它已经设置了序列化方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="3035" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当它序列化时，它将作为JSON来做。在该字符串中，我们将放入引擎类名(如果引擎已启动)和颜色。</p><p id="8a25" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当它<em class="ng">解序列化</em>时，我们将解码JSON字符串。我们将根据给定的类名创建一个新的引擎，放置颜色，如果引擎已经启动，就启动它。</p><p id="a93a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们用实际行动来检验一下。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="f161" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后<em class="ng">瞧</em>。不需要在代码中做奇怪的sh*t来保存一个类实例。见鬼，你甚至可以把它们存到u盘里，然后在另一台电脑上反序列化。技术！</p><blockquote class="nx ny nz"><p id="5892" class="kz la ng lb b lc ld ju le lf lg jx lh oa lj lk ll ob ln lo lp oc lr ls lt lu im bi translated">建议:您不能序列化闭包，主要是因为这些闭包在类之外有上下文。这就像收到一张要支付的账单，却不知道该支付给谁。但是…如果你需要那个功能，<a class="ae ky" href="https://github.com/jeremeamia/super_closure" rel="noopener ugc nofollow" target="_blank">super close包</a>可能适合你。</p></blockquote></div></div>    
</body>
</html>