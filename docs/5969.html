<html>
<head>
<title>How to use Redis and Lua Scripts in a C# ASP.NET Core Microservice Architecture</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在C # ASP.NET核心微服务架构中使用Redis和Lua脚本</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-use-redis-and-lua-scripts-in-a-c-asp-net-core-microservice-architecture-e12dc8846707?source=collection_archive---------0-----------------------#2021-07-15">https://itnext.io/how-to-use-redis-and-lua-scripts-in-a-c-asp-net-core-microservice-architecture-e12dc8846707?source=collection_archive---------0-----------------------#2021-07-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="808c" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用StackExchange。Redis并在Docker中运行Redis来缓存一个可伸缩的C#应用程序的聚合数据库数据</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/432ff8610332ceceb68d1195bb74a5a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aO2_ixUXznFFlGZoWuUtnw.png"/></div></div></figure><p id="4997" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> Redis有许多很棒的用例</strong>，比如会话或整页<strong class="kt ir">缓存</strong>、<strong class="kt ir">队列</strong>、<strong class="kt ir">发布/订阅</strong>和<strong class="kt ir">排行榜/计数</strong>等。可用于您的应用和微服务架构。</p><p id="a2c6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在本文中，我将向您展示如何使用<a class="ae ln" href="https://stackexchange.github.io/StackExchange.Redis/" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> StackExchange。ASP.NET核心</strong>中的Redis</a>和<strong class="kt ir">访问Docker </strong>中运行的<strong class="kt ir"> Redis服务器。</strong></p><p id="62bf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><a class="ae ln" rel="noopener ugc nofollow" target="_blank" href="/how-to-use-database-sharding-and-scale-an-asp-net-core-microservice-architecture-22c24916590f"> <strong class="kt ir">示例应用</strong> </a> <strong class="kt ir">让用户按类别</strong>写文章。它使用Redis<strong class="kt ir">缓存顶级类别和用户的聚合数据</strong>，而<strong class="kt ir">数据库存储项目/行数据作为“真实来源”</strong>。</p><p id="25a1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">本文从一个<strong class="kt ir">简单的第一个用例</strong>开始，然后通过Lua脚本和<strong class="kt ir">收件箱模式</strong>推进到一个更加复杂的用例<strong class="kt ir">。</strong></p><h2 id="fda3" class="lo lp iq bd lq lr ls dn lt lu lv dp lw la lx ly lz le ma mb mc li md me mf mg bi translated">内容</h2><ol class=""><li id="5f63" class="mh mi iq kt b ku mj kx mk la ml le mm li mn lm mo mp mq mr bi translated">在Docker中设置Redis并准备。网络核心项目</li><li id="3d1f" class="mh mi iq kt b ku ms kx mt la mu le mv li mw lm mo mp mq mr bi translated">实施顶级类别</li><li id="1a52" class="mh mi iq kt b ku ms kx mt la mu le mv li mw lm mo mp mq mr bi translated">顶级用户、收件箱模式和原子性的Lua脚本</li><li id="2a8f" class="mh mi iq kt b ku ms kx mt la mu le mv li mw lm mo mp mq mr bi translated">最后的想法和展望</li></ol></div><div class="ab cl mx my hu mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="ij ik il im in"><h1 id="2f53" class="ne lp iq bd lq nf ng nh lt ni nj nk lw jw nl jx lz jz nm ka mc kc nn kd mf no bi translated">1.在Docker中设置Redis并准备。网络核心项目</h1><p id="109a" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la np lc ld le nq lg lh li nr lk ll lm ij bi translated"><strong class="kt ir">安装</strong> <a class="ae ln" href="https://hub.docker.com/editions/community/docker-ce-desktop-windows" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> Docker桌面</strong> </a></p><p id="2a9a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">创建Redis容器:</p><pre class="kg kh ki kj gt ns nt nu nv aw nw bi"><span id="3480" class="lo lp iq nt b gy nx ny l nz oa">C:\dev&gt;docker run --name redis -d redis</span></pre><p id="2139" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">使用</strong> <a class="ae ln" href="https://visualstudio.microsoft.com/en/vs/community/" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> Visual Studio社区</strong> </a>(是免费的)配合ASP.NET和web开发工作量。用EntityFramework打开一个ASP.NET Core 5 Web API项目。</p><p id="eb04" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">安装以下NuGet包</strong>:</p><ul class=""><li id="798c" class="mh mi iq kt b ku kv kx ky la ob le oc li od lm oe mp mq mr bi translated">微软。实体框架工作核心工具</li><li id="d63b" class="mh mi iq kt b ku ms kx mt la mu le mv li mw lm oe mp mq mr bi translated">StackExchange。雷迪斯</li></ul><p id="9f77" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">创建以下实体:</strong></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="of og l"/></div></figure></div><div class="ab cl mx my hu mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="ij ik il im in"><h1 id="0869" class="ne lp iq bd lq nf ng nh lt ni nj nk lw jw nl jx lz jz nm ka mc kc nn kd mf no bi translated">2.实施顶级类别</h1><h2 id="49f2" class="lo lp iq bd lq lr ls dn lt lu lv dp lw la lx ly lz le ma mb mc li md me mf mg bi translated">添加热门类别</h2><p id="c118" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la np lc ld le nq lg lh li nr lk ll lm ij bi translated">插入新帖子时，增加类别的数量。</p><ul class=""><li id="0820" class="mh mi iq kt b ku kv kx ky la ob le oc li od lm oe mp mq mr bi translated">第1行:连接一个Redis复用器</li><li id="a1cf" class="mh mi iq kt b ku ms kx mt la mu le mv li mw lm oe mp mq mr bi translated">第7–11行:插入文章并更新事务中的类别计数</li><li id="6cec" class="mh mi iq kt b ku ms kx mt la mu le mv li mw lm oe mp mq mr bi translated">第13–15行:读取类别的最新计数，并添加/更新Redis <a class="ae ln" href="https://redislabs.com/ebook/part-2-core-concepts/chapter-3-commands-in-redis/3-5-sorted-sets/" rel="noopener ugc nofollow" target="_blank">排序集</a>"<em class="oh">categories by post count</em>中的条目</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="of og l"/></div></figure><blockquote class="oi oj ok"><p id="65f2" class="kr ks oh kt b ku kv jr kw kx ky ju kz ol lb lc ld om lf lg lh on lj lk ll lm ij bi translated"><a class="ae ln" href="https://redis.io/commands/ZADD" rel="noopener ugc nofollow" target="_blank"> ZADD </a>命令有一个可选的<em class="iq"> GT </em>参数:该值只有在大于当前值时才会更新。这防止了另一个线程也增加和更新计数的竞争情况。</p></blockquote><h2 id="2cb8" class="lo lp iq bd lq lr ls dn lt lu lv dp lw la lx ly lz le ma mb mc li md me mf mg bi translated">阅读热门类别</h2><p id="c5b7" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la np lc ld le nq lg lh li nr lk ll lm ij bi translated"><em class="oh">SortedSetRangeByRankWithScore</em>是Redis <a class="ae ln" href="https://redis.io/commands/zrange" rel="noopener ugc nofollow" target="_blank"> ZRANGE </a>命令的包装器。它读取类别和计数。使用<em class="oh">开始</em>和<em class="oh">结束</em>参数进行分页。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="of og l"/></div></figure></div><div class="ab cl mx my hu mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="ij ik il im in"><h1 id="a9a6" class="ne lp iq bd lq nf ng nh lt ni nj nk lw jw nl jx lz jz nm ka mc kc nn kd mf no bi translated">3.顶级用户、收件箱模式和原子性的Lua脚本</h1><p id="ab7c" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la np lc ld le nq lg lh li nr lk ll lm ij bi translated">对于用户，我将向您展示如何计算Redis而不是DB中的帖子数。这例如在用户的帖子分散在所有碎片上的碎片化环境中是需要的。</p><h2 id="0612" class="lo lp iq bd lq lr ls dn lt lu lv dp lw la lx ly lz le ma mb mc li md me mf mg bi translated">使用Lua脚本自动添加帖子</h2><p id="2f16" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la np lc ld le nq lg lh li nr lk ll lm ij bi translated">方法向Redis发送新的帖子。它使用inbox模式和一个<a class="ae ln" href="https://redislabs.com/ebook/part-3-next-steps/chapter-11-scripting-redis-with-lua/" rel="noopener ugc nofollow" target="_blank"> Lua脚本</a>来使操作“等幂”。</p><p id="fb8b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="oh">延伸阅读:</em> <a class="ae ln" href="https://event-driven.io/en/outbox_inbox_patterns_and_delivery_guarantees_explained/" rel="noopener ugc nofollow" target="_blank"> <em class="oh">发件箱、收件箱模式和投递保证解释</em> </a></p><ul class=""><li id="6099" class="mh mi iq kt b ku kv kx ky la ob le oc li od lm oe mp mq mr bi translated">第3–8行:准备Lua脚本</li><li id="c783" class="mh mi iq kt b ku ms kx mt la mu le mv li mw lm oe mp mq mr bi translated">第13行:从Redis中读取最后发送的文章ID</li><li id="a1e0" class="mh mi iq kt b ku ms kx mt la mu le mv li mw lm oe mp mq mr bi translated">第15行:从数据库加载未发送的帖子</li><li id="300c" class="mh mi iq kt b ku ms kx mt la mu le mv li mw lm oe mp mq mr bi translated">第17–21行:执行Lua脚本向用户添加文章</li><li id="90d1" class="mh mi iq kt b ku ms kx mt la mu le mv li mw lm oe mp mq mr bi translated">第22行:在<em class="oh"> UsersByPostCount </em>中设置用户的文章数</li><li id="d34b" class="mh mi iq kt b ku ms kx mt la mu le mv li mw lm oe mp mq mr bi translated">第25行:在所有操作完成后更新最后发送的ID</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="b3ee" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Lua脚本试图将文章ID和时间戳添加到用户的<em class="oh"> PostsByTimestamp </em>排序集合中。</p><p id="b894" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果可以添加密钥，它还会增加用户的<em class="oh">后计数</em>。该脚本使ZADD和ZINCRBY命令成为原子命令。如果文章ID已经存在，它返回现有的<em class="oh">文章编号</em>。</p><blockquote class="oi oj ok"><p id="6491" class="kr ks oh kt b ku kv jr kw kx ky ju kz ol lb lc ld om lf lg lh on lj lk ll lm ij bi translated">每个用户需要一个额外的计数器，以便所有的关键参数映射到同一个<a class="ae ln" href="https://redislabs.com/blog/redis-clustering-best-practices-with-keys/" rel="noopener ugc nofollow" target="_blank"> Redis散列标签</a>。因此会放在同一个Redis片上。键“{User:5}:PostsByTimestamp”中的花括号是Redis散列标签的符号。</p></blockquote><h2 id="6d25" class="lo lp iq bd lq lr ls dn lt lu lv dp lw la lx ly lz le ma mb mc li md me mf mg bi translated">阅读顶级用户</h2><p id="71be" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la np lc ld le nq lg lh li nr lk ll lm ij bi translated">使用<em class="oh">SortedSetRangeByRankWithScore</em>读取顶级用户的id。然后读名字:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="of og l"/></div></figure></div><div class="ab cl mx my hu mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="ij ik il im in"><h1 id="9045" class="ne lp iq bd lq nf ng nh lt ni nj nk lw jw nl jx lz jz nm ka mc kc nn kd mf no bi translated">4.最后的想法和展望</h1><p id="6039" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la np lc ld le nq lg lh li nr lk ll lm ij bi translated">你用了<strong class="kt ir"> StackExchange。Redis从C# </strong>访问Redis。如果您想<strong class="kt ir">通过redis-cli手动访问Redis</strong>或者想要<strong class="kt ir">关于示例数据模型和用例</strong>的更多信息，请参见<a class="ae ln" rel="noopener ugc nofollow" target="_blank" href="/how-to-cache-aggregated-data-with-redis-and-lua-scripts-for-a-scaled-microservice-architecture-2b791289e911">我以前的文章</a>。</p><p id="618c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">本文中的代码主要关注与Redis相关的部分。代码的<strong class="kt ir">基础可以在我的关于数据库分片的文章</strong> <a class="ae ln" rel="noopener ugc nofollow" target="_blank" href="/how-to-use-database-sharding-and-scale-an-asp-net-core-microservice-architecture-22c24916590f"> <strong class="kt ir">的解决方案中找到，如果你想构建和运行服务的话。</strong></a></p><p id="8d86" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在您的应用程序中使用Redis还有许多其他的用例！</p><p id="9043" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果您有任何问题、想法或建议，请联系我。</p></div></div>    
</body>
</html>