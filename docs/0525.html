<html>
<head>
<title>Lazy-loading images with React and Semantic UI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用React和语义UI延迟加载图像</h1>
<blockquote>原文：<a href="https://itnext.io/lazy-loading-images-with-react-and-semantic-ui-28a780bb3b3a?source=collection_archive---------5-----------------------#2018-03-25">https://itnext.io/lazy-loading-images-with-react-and-semantic-ui-28a780bb3b3a?source=collection_archive---------5-----------------------#2018-03-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/f21c77eca0d8f1f9f85ad575f1add49f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*0nazvTCXxL1AHOSs.png"/></div></div></figure><div class=""/><p id="7bb9" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">图片构成了网站内容的大部分，因此在页面加载时间中起着很大的作用。这对于像现在大多数登陆页面一样的单页面网站来说尤其成问题。这个问题的解决方案是<em class="kw">延迟加载图像</em>，即文件夹下的图像<em class="kw">稍后异步加载。延迟加载有两种主要方式:</em></p><ol class=""><li id="db0e" class="kx ky jb ka b kb kc kf kg kj kz kn la kr lb kv lc ld le lf bi translated">延迟加载图像，直到上述文件夹内容被加载，然后加载所有图像</li><li id="926a" class="kx ky jb ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">延迟加载图像，直到它出现在用户的视窗中</li></ol><p id="5c81" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用<a class="ae ll" href="https://semantic-ui.com/behaviors/visibility.html#lazy-loading-images" rel="noopener ugc nofollow" target="_blank">语义UI </a>，当图像在视窗中时，延迟加载图像真的很容易:改为将图像<code class="fe lm ln lo lp b">src</code>定义为<code class="fe lm ln lo lp b">data-src</code>，然后给图像附加一个可见性处理程序:</p><pre class="lq lr ls lt gt lu lp lv lw aw lx bi"><span id="3e9c" class="ly lz jb lp b gy ma mb l mc md">$('.demo.items .image img')<br/>  .visibility({<br/>    type       : 'image',<br/>    transition : 'fade in',<br/>    duration   : 1000<br/>  })<br/>;</span></pre><p id="7dc8" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用React和它的<a class="ae ll" href="https://react.semantic-ui.com" rel="noopener ugc nofollow" target="_blank"> React语义UI端口</a>延迟加载图像有点不同，因为我们不会使用<code class="fe lm ln lo lp b">jQuery</code>，而是使用React组件。我们可以创建一个<code class="fe lm ln lo lp b">LazyImage</code> React组件，当图像在视口中时加载它。为此，我们使用了<code class="fe lm ln lo lp b">Visibility</code>组件，当组件的顶部边缘在视口中时，它有一个回调函数:</p><pre class="lq lr ls lt gt lu lp lv lw aw lx bi"><span id="d2b6" class="ly lz jb lp b gy ma mb l mc md">import PropTypes from 'prop-types'<br/>import { Visibility, Image, Loader } from 'semantic-ui-react'<br/><br/>export default class LazyImage extends React.Component {<br/>    static propTypes = {<br/>        src: PropTypes.string.isRequired,<br/>        size: PropTypes.string,<br/>    }<br/><br/>    static defaultProps = {<br/>        size: `medium`,<br/>    }<br/><br/>    state = {<br/>        show: false,<br/>    }<br/><br/>    showImage = () =&gt; {<br/>        this.setState({<br/>            show: true,<br/>        })<br/>    }<br/><br/>    render() {<br/>        const { size } = this.props<br/>        if (!this.state.show) {<br/>            return (<br/>                &lt;Visibility as="span" onTopVisible={this.showImage}&gt;<br/>                    &lt;Loader active inline="centered" size={size} /&gt;<br/>                &lt;/Visibility&gt;<br/>            )<br/>        }<br/>        return &lt;Image {...this.props} /&gt;<br/>    }<br/>}</span></pre><p id="0b8d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">用法与<a class="ae ll" href="https://react.semantic-ui.com/elements/image" rel="noopener ugc nofollow" target="_blank">语义UI React的图像</a>组件完全相同，我们只是将<code class="fe lm ln lo lp b">props</code>转发给它:</p><pre class="lq lr ls lt gt lu lp lv lw aw lx bi"><span id="d030" class="ly lz jb lp b gy ma mb l mc md">&lt;LazyImage<br/>    src="https://source.unsplash.com/random/400x300"<br/>    size="mini"<br/>    rounded<br/>/&gt;</span></pre><p id="ef33" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果图像不在视窗中，我们渲染一个<code class="fe lm ln lo lp b">Loader</code>。你可能想知道为什么我们要这样做，因为如果图像不在视窗中，根据定义<em class="kw">它是不可见的</em>，我们渲染什么作为它的占位符并不重要。这在理论上是正确的，但是我注意到当图像在初始视口中并且使用服务器端渲染时，你仍然可以看到一个<code class="fe lm ln lo lp b">Loader</code>。服务器将为<code class="fe lm ln lo lp b">Loader</code>提供服务，这需要几分之一秒的时间，直到应用程序被重新水合并且<code class="fe lm ln lo lp b">Visibility</code>处理程序被连接。</p></div><div class="ab cl me mf hu mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="ij ik il im in"><p id="5f78" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最初发布于<a class="ae ll" href="https://cmichel.io/lazy-load-images-with-react/" rel="noopener ugc nofollow" target="_blank"> cmichel.io </a></p><figure class="lq lr ls lt gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ml"><img src="../Images/768704985b255b46ede868ea1a9d8a24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mI2XW-Jvcx53djFW.gif"/></div></div></figure></div></div>    
</body>
</html>