<html>
<head>
<title>In-Depth Look at TypeScript Generics: Part 1 — Intro to Generics</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">深入了解TypeScript泛型:第1部分——泛型介绍</h1>
<blockquote>原文：<a href="https://itnext.io/in-depth-look-at-typescript-generics-part-1-intro-to-generics-7ddc72dcfcea?source=collection_archive---------6-----------------------#2022-02-14">https://itnext.io/in-depth-look-at-typescript-generics-part-1-intro-to-generics-7ddc72dcfcea?source=collection_archive---------6-----------------------#2022-02-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/9d9d02e182b7a686688c921d4a132219.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3w7kThmftKkSFjpDM6GyqA.png"/></div></div></figure><p id="aff8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这个由两部分组成的系列中，我们将深入了解TypeScript泛型。这第一篇文章将让你对泛型及其工作原理有一个基本的了解。在后面的文章中，我们将讨论高级推理和条件类型。</p><p id="f9e6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">所以，事不宜迟，我们开始吧！</p><h1 id="549d" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">为什么我们需要泛型？</h1><p id="1e75" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">使用泛型可以让我们编写一个类型安全的代码，它可以处理各种各样的原语和对象。</p><p id="b453" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果没有泛型，我们将不得不为我们想要处理的每一种可能的数据组合创建一种新的类型。使用泛型，我们可以编写一次函数或方法，然后针对不同类型的输入重用它。</p><p id="8145" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这听起来很棒，但是TypeScript泛型实际上是什么样子的呢？让我们来看看语法。</p><h1 id="91bf" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">通用语法</h1><p id="83da" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">TypeScript使用尖括号<code class="fe mc md me mf b">&lt;&gt;</code>和类型符号<code class="fe mc md me mf b">T</code>来表示通用语法。在您的客户端代码中，TypeScript将用您传递的类型替换类型<code class="fe mc md me mf b">T</code>。如果我们看一个例子，这将更有意义:</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="4576" class="mo la it mf b gy mp mq l mr ms">function identifyType &lt;T&gt;(target: T) {<br/>  console.log("Type of target is", typeof target);<br/>}</span><span id="0e8e" class="mo la it mf b gy mt mq l mr ms">identifyType("LOL") // "Type of target is", "string"<br/>identifyType({word: "LOL"}) // Type of target is", "object"</span></pre><p id="883d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">上面代码中的函数接受一个泛型类型的参数<code class="fe mc md me mf b">T</code>。然后使用<code class="fe mc md me mf b">typeof</code>操作符将参数的类型打印到控制台。</p><p id="636c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在第一个调用中，我们传入一个字符串，在第二个调用中，我们传入一个对象。因为它是通用的，所以这个函数可以处理任何数据，并且在两种情况下都能成功执行。</p><p id="953b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">类和接口也可以使用泛型:</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="6638" class="mo la it mf b gy mp mq l mr ms">class Identifier&lt;T&gt; {<br/>  seed: T;<br/>  constructor(public newSeed: T) {<br/>    this.seed = newSeed;<br/>  }</span><span id="1afa" class="mo la it mf b gy mt mq l mr ms">identifyType&lt;T&gt;(target: T) {<br/>    console.log("Type of target is", typeof target);<br/>  }<br/>}</span></pre><p id="365d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里我们用构造函数和<code class="fe mc md me mf b">identifyType</code>方法定义了一个泛型类。<code class="fe mc md me mf b">identifyType</code>方法接受的参数类型必须与提供给构造函数的<code class="fe mc md me mf b">newSeed </code>参数相匹配。</p><p id="7245" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">换句话说，如果您将一个字符串传递给构造函数，<code class="fe mc md me mf b">identifyType</code>将只接受字符串作为参数。</p><p id="62ba" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">旁注:你没有<em class="mu">有</em>来使用<code class="fe mc md me mf b">T</code>来表示泛型。<code class="fe mc md me mf b">T</code>只是TypeScript中常用的约定。</p><p id="fadc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">默认情况下，TypeScript试图根据参数推断类型，但是您可以使用括号语法<code class="fe mc md me mf b">&lt;&gt;</code>使用显式类型转换来强制指定类型:</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="53fd" class="mo la it mf b gy mp mq l mr ms">identifyType&lt;string&gt;(1); // Argument of type 'number' is not assignable to parameter of type 'string'</span></pre><p id="5ecc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在本例中，函数<code class="fe mc md me mf b">identifyType</code>需要一个字符串类型的参数，但收到的是一个数字。由于这种不匹配，TypeScript将产生错误。</p><h1 id="3f81" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">约束类型</h1><p id="edba" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">通常，我们希望限制<code class="fe mc md me mf b">T</code>的类型，以限制我们的通用代码接受的类型。我们可以使用<code class="fe mc md me mf b">extends</code>关键字来实现。</p><p id="5657" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">假设我们想限制<code class="fe mc md me mf b">identifyType</code>函数只接受字符串和数字。我们会这样做:</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="26b4" class="mo la it mf b gy mp mq l mr ms">function identifyType&lt;T extends string | number&gt;(target: T) {<br/>    console.log("Type of target is", typeof target);<br/>  }</span><span id="a8c1" class="mo la it mf b gy mt mq l mr ms">identifyType(true) // Argument of type 'boolean' is not assignable to parameter of type 'string | number'</span></pre><p id="73ba" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用<code class="fe mc md me mf b">extends</code>关键字，我们可以告诉TypeScript我们的函数或类应该接受哪些类型。在我们的例子中，<code class="fe mc md me mf b">identifyType</code>只接受字符串或数字。当我们试图传递一个布尔值时，函数会产生一个错误。</p><h1 id="f2c0" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">使用T型</h1><p id="3b4c" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">泛型代码只能引用任何类型的t所共有的对象的函数或属性。换句话说，你不能访问任何特定类型的特定内容。您只能访问我们指定的所有泛型类型中的方法和属性。</p><p id="7217" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">例如，如果我们有一个被约束为两种类型的泛型类型，我们只能使用同时存在于这两种类型中的函数和属性:</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="0d1f" class="mo la it mf b gy mp mq l mr ms">type birdGenerator = {<br/>  generate: () =&gt; any[]<br/>  birds: any[]<br/>}</span><span id="8d41" class="mo la it mf b gy mt mq l mr ms">type ponyGenerator = {<br/>  generate: () =&gt; any[]<br/>  ponies: any[]<br/>}</span><span id="cd38" class="mo la it mf b gy mt mq l mr ms">function generateAnimal&lt;T extends birdGenerator | ponyGenerator&gt; (generator: T) {<br/>  generator.generate()<br/>  generator.birds // ERROR: Property 'birds' does not exist on type 'ponyGenerator'.<br/>}</span></pre><p id="6c30" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在上面的例子中，如果试图访问我们的<code class="fe mc md me mf b">generateAnimal</code>函数中的<code class="fe mc md me mf b">birds</code>属性，我们会得到一个错误。然而，我们可以毫无问题地访问<code class="fe mc md me mf b">generate</code>方法，因为它同时存在于<code class="fe mc md me mf b">birdGenerator</code>和<code class="fe mc md me mf b">ponyGenerator</code>类型中。</p><h1 id="686f" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">通用约束</h1><p id="6be0" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">您可以用另一个泛型类型构造一个泛型类型。一种方法是使用<code class="fe mc md me mf b">keyof</code>关键字。</p><p id="fdc7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">关键字<code class="fe mc md me mf b">keyof</code>用于根据另一个类型的关键字生成一个新类型。</p><p id="0749" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以使用它来确保我们只能指定存在于我们的通用对象中的键，就像这样:</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="bf31" class="mo la it mf b gy mp mq l mr ms">function getPropertyValue&lt;T, B extends keyof T&gt; (target: T, key: B) {<br/>  return target[key];<br/>}</span><span id="fcd1" class="mo la it mf b gy mt mq l mr ms">const myObj = {<br/>  id: "0",<br/>  name: "John Doe",<br/>  age: 19<br/>}</span><span id="ea55" class="mo la it mf b gy mt mq l mr ms">getPropertyValue(myObj, "id")<br/>getPropertyValue(myObj, SSN) // ERROR: Cannot find name 'SSN'.</span></pre><p id="bbd8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里我们使用<code class="fe mc md me mf b">keyof</code>关键字创建一个新类型，并限制<code class="fe mc md me mf b">getPropertyValue</code>函数第二个参数的可能值。现在它只接受与<code class="fe mc md me mf b">myObj</code>对象中的键相匹配的字符串。</p><h1 id="38ed" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">结论</h1><p id="a0e4" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">在本文中，我们讨论了TypeScript泛型的基础。我们研究了如何使用泛型来约束代码接受的类型，并探索了使用泛型对象时的一些可用特性。</p><p id="efb7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你想获得更多的网络开发、反馈和打字技巧，可以考虑<a class="ae mv" href="https://twitter.com/IskanderSamatov" rel="noopener ugc nofollow" target="_blank">在Twitter上关注我，</a>在那里我分享我学到的东西。<br/>快乐编码！</p></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><p id="4202" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="mu">原载于2022年2月14日</em><a class="ae mv" href="https://isamatov.com/typescript-generics-in-depth-basics/" rel="noopener ugc nofollow" target="_blank"><em class="mu">https://isamatov.com</em></a><em class="mu">。</em></p></div></div>    
</body>
</html>