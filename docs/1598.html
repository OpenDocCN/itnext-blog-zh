<html>
<head>
<title>Kubernetes and the underpinnings of Multi-cloud 2.0</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes和多重云2.0的基础</h1>
<blockquote>原文：<a href="https://itnext.io/kubernetes-and-the-underpinnings-of-multi-cloud-2-0-1c7aca50c46f?source=collection_archive---------5-----------------------#2018-12-06">https://itnext.io/kubernetes-and-the-underpinnings-of-multi-cloud-2-0-1c7aca50c46f?source=collection_archive---------5-----------------------#2018-12-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="db0f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">企业的云计算之旅可以大致分为两个阶段。Multi-cloud 1.0 —将<strong class="jp ir">工作负载分布在不同云上的能力是重点，Multi-cloud 2.0 —跨云转移/重新创建</strong>工作负载的能力很重要。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi kl"><img src="../Images/50a673fbdad9d39be289e9a41b69b01b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1330/format:webp/1*v61my2n6-vsJAvRcv609hg.png"/></div></figure><p id="174b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在多重云1.0阶段，云代理和多重云供应器，如<a class="ae kt" href="https://www.terraform.io/" rel="noopener ugc nofollow" target="_blank"> Terraform </a>提供了在多重云中<strong class="jp ir">分配</strong>企业工作负载的能力。我们现在看到了多云1.0工具的进步，特别关注容器化的工作负载，正如在最近的一些公告中看到的那样——微软的<a class="ae kt" href="https://open.microsoft.com/2018/12/04/announcing-cnab-cloud-agnostic-format-packaging-running-distributed-applications/" rel="noopener ugc nofollow" target="_blank">CNAB+Docker</a>、<a class="ae kt" href="https://blog.upbound.io/introducing-crossplane-open-source-multicloud-control-plane/" rel="noopener ugc nofollow" target="_blank">交叉平面</a>、Kubernetes的<a class="ae kt" href="https://github.com/kubernetes/enhancements/blob/master/keps/sig-apps/0032-portable-service-definitions.md" rel="noopener ugc nofollow" target="_blank">可移植服务定义</a>。</p><p id="36f4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">随着Kubernetes作为私有云和公共云中事实上的CaaS层被广泛采用，multi-cloud 2.0阶段有望实现跨多个云无缝转移/重新创建工作负载的能力。为此，一个关键要求是工作负载和底层云之间不应有任何绑定。实现这一点的最简单方法是在您的应用中不使用云提供商的托管服务，例如<a class="ae kt" href="https://aws.amazon.com/rds/" rel="noopener ugc nofollow" target="_blank"> AWS RDS </a>、<a class="ae kt" href="https://cloud.google.com/sql/" rel="noopener ugc nofollow" target="_blank"> Google CloudSQL </a>。你最好坚持使用你需要的平台元素的容器化版本，比如你选择的数据库的容器化版本，负载平衡器的容器化版本，等等。本质上，通过为您的整个应用平台堆栈创建微服务架构。</p><p id="a095" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">为多云2.0创建应用平台的挑战</strong></p><p id="4e7f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦我们出于可移植性的原因决定使用平台元素的容器化版本，我们就会面对这样一个事实:管理这种元素的复杂生命周期并不容易。Kubernetes社区已经认识到了这个挑战，特别是对于有状态平台元素，引入了<a class="ae kt" href="https://coreos.com/operators/" rel="noopener ugc nofollow" target="_blank">操作符</a>的概念。如今，许多社区运营商正在为各种平台元素创建，如MySQL、Kafka、Redis、Spark等。(Kubernetes运营商的<a class="ae kt" href="https://github.com/search?q=Kubernetes+Operator" rel="noopener ugc nofollow" target="_blank"> 350+ GitHub库</a>)。</p><p id="d498" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">像<a class="ae kt" href="https://github.com/operator-framework/operator-lifecycle-manager" rel="noopener ugc nofollow" target="_blank"> OLM </a>、<a class="ae kt" href="https://docs.helm.sh/developing_charts/#defining-a-crd-with-the-crd-install-hook" rel="noopener ugc nofollow" target="_blank">Helm with installation support</a>、<a class="ae kt" href="https://github.com/kubernetes-sigs/application" rel="noopener ugc nofollow" target="_blank"> Application CRD </a>、<a class="ae kt" href="https://github.com/operator-framework/helm-app-operator-kit" rel="noopener ugc nofollow" target="_blank"> helm-app-operator-kit </a>这样的工具解决了采用操作符的部分问题，例如——简化操作符安装和管理(OLM)的过程，使CRD成为Helm release的一部分(Helm with support)，使用Kubernetes本机对象定义应用元数据和创建应用程序(Application CRD)，为现有的Helm图表创建操作符(helm-app-operator-kit)。最终，我们相信这些方法将汇聚成通过Helm安装操作员的标准方式。</p><p id="1f7e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">今天的用户正在寻找可用于容器化平台元素的社区运营商，并考虑使用它们来构建他们的应用平台栈。然而，这种自组装不同运营商的“定制平台即服务”的方法面临以下挑战:</p><ol class=""><li id="eafb" class="ku kv iq jp b jq jr ju jv jy kw kc kx kg ky kk kz la lb lc bi translated">建造这种DIY包的过程既复杂又耗时。</li><li id="4134" class="ku kv iq jp b jq ld ju le jy lf kc lg kg lh kk kz la lb lc bi translated">不同运营商的DIY平台缺乏一致性，因为它们是由不同的供应商开发的。</li><li id="76ef" class="ku kv iq jp b jq ld ju le jy lf kc lg kg lh kk kz la lb lc bi translated">应用程序开发人员在创建他们的应用程序平台YAMLs时也不容易使用运营商引入的定制资源，因为对于新添加的定制资源、其支持的可配置性、功能性等没有集中的文档。此外，没有简单的方法来调试定制资源实例中的问题。</li></ol><p id="7de2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在CloudARK，我们正在开发<a class="ae kt" href="https://github.com/cloud-ark/kubeplus" rel="noopener ugc nofollow" target="_blank"> KubePlus Platform Kit </a>来应对这些挑战，并使用所需的社区运营商简化创建定制平台的流程。</p><p id="7e63" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> KubePlus平台套件</strong></p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi kl"><img src="../Images/1297d1b886440097922a5723a3b46ff7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1330/format:webp/1*TFFO9SSTfhFEagHMZk1OGw.png"/></div></figure><p id="110b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">KubePlus的设计考虑了3个用户角色。</p><p id="88c0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">1.操作符开发人员—开发操作符并将其打包为舵图。为了在构建和包装运营商方面实现一致性，我们制定了<a class="ae kt" href="https://github.com/cloud-ark/kubeplus/blob/master/Guidelines.md" rel="noopener ugc nofollow" target="_blank">运营商发展指南</a>。</p><p id="67d9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2.集群管理员/ DevOps工程师—使用kubectl通过操作员导航图URL部署一个或多个操作员。</p><p id="7402" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">3.应用开发人员—通过部署的运营商发现可用的定制资源，并创建使用所需定制资源的应用平台。</p><p id="9c3b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">平台代码:</strong></p><p id="5f61" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">KubePlus Platform Kit是一个现代化的多云平台即服务层，无需引入任何新的CLI即可构建定制的平台即服务。它利用标准的Kubernetes接口— <em class="li"> kubectl </em>和Kubernetes YAMLs来提供PaaS体验。受基础设施即代码的启发，即代码系统使用声明性定义来确保过程中的可共享性和可重复性。在基于KubePlus的定制PaaS的情况下，使用基于Kubernetes YAML的定义来实现平台化流程。因此得名<a class="ae kt" href="https://cloudark.io/platform-as-code" rel="noopener ugc nofollow" target="_blank">平台代码</a>。</p><p id="836e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">结论:</strong></p><p id="67e4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们相信，Kubernetes的广泛采用将使多云2.0阶段成为可能，届时真正的跨云应用程序可移植性将成为可能。为了充分利用这一点，应用程序工作负载需要与底层云分离。在Kubernetes上为这种多云2.0愿景创建应用平台存在独特的挑战。我们讨论了<a class="ae kt" href="https://github.com/cloud-ark/kubeplus" rel="noopener ugc nofollow" target="_blank"> KubePlus Platform Kit </a>如何通过一种独特的平台即代码方法来帮助解决这些挑战，这种方法提供了一种可组合、可重复和可共享的方式来创建应用平台。</p><p id="8511" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kt" href="https://cloudark.io/" rel="noopener ugc nofollow" target="_blank"> www.cloudark.io </a></p></div></div>    
</body>
</html>