<html>
<head>
<title>Migrate your app to Android Oreo</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将您的应用迁移到Android Oreo</h1>
<blockquote>原文：<a href="https://itnext.io/migrate-your-app-to-android-oreo-e0fa794b1d21?source=collection_archive---------4-----------------------#2018-05-22">https://itnext.io/migrate-your-app-to-android-oreo-e0fa794b1d21?source=collection_archive---------4-----------------------#2018-05-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="a1d8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在接下来的几个月里，所有Android开发者都将迎来新的变化。谷歌将确保Google Play中所有应用程序的最佳性能，因此出于这一目的，将迫使Android开发者将其应用程序定位于Android Oreo。</p><p id="6aff" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在Google I/0 2018期间，宣布从2018年8月起，开发者上传到Google Play的所有新应用都必须针对Android Oreo (8.0)。从2018年11月开始，该要求也将影响现有应用的更新。</p><p id="5ec0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">关于这种迁移，我们必须记住的变化是:</p><ol class=""><li id="157a" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated">服务—背景限制</li><li id="afe5" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated"><a class="ae kz" rel="noopener ugc nofollow" target="_blank" href="/migrate-your-app-to-android-oreo-part-2-broadcastreceivers-3f1f12f764fc">广播接收机</a></li><li id="2700" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated"><a class="ae kz" rel="noopener ugc nofollow" target="_blank" href="/migrate-your-app-to-android-oreo-part-3-notifications-b59d7c6313f9">通知</a></li><li id="b1a3" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">运行时权限</li><li id="5f2e" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">警告</li><li id="8567" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">Firebase云消息传递(截止日期:2019年4月)</li></ol><figure class="lb lc ld le gt lf gh gi paragraph-image"><div class="gh gi la"><img src="../Images/e1f7c75b1ae61ee491348d77ba9217bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*eS9JYmFCbc6e8w_wKzZbTg.jpeg"/></div></figure><h1 id="490b" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated"><strong class="ak"> 1。服务—背景限制</strong></h1><p id="e40d" class="pw-post-body-paragraph jn jo iq jp b jq mg js jt ju mh jw jx jy mi ka kb kc mj ke kf kg mk ki kj kk ij bi translated">这不是一个新问题。它是在Android Oreo发布时推出的，但由于采用率低，许多Android开发者尚未将Android Oreo作为目标。(2018年5月5%左右—<a class="ae kz" href="https://developer.android.com/about/dashboards/" rel="noopener ugc nofollow" target="_blank">https://developer.android.com/about/dashboards/</a>)</p><p id="0ba4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以通过以下链接了解这些限制背后的动机的更多详情:</p><div class="ml mm gp gr mn mo"><a href="https://developer.android.com/about/versions/oreo/background" rel="noopener  ugc nofollow" target="_blank"><div class="mp ab fo"><div class="mq ab mr cl cj ms"><h2 class="bd ir gy z fp mt fr fs mu fu fw ip bi translated">后台执行限制| Android开发者</h2><div class="mv l"><h3 class="bd b gy z fp mt fr fs mu fu fw dk translated">针对Android 8.0或更高版本的应用程序的新后台限制。</h3></div><div class="mw l"><p class="bd b dl z fp mt fr fs mu fu fw dk translated">developer.android.com</p></div></div><div class="mx l"><div class="my l mz na nb mx nc lg mo"/></div></div></a></div><p id="39b8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们必须面对的第一个变化是，如果我们的应用程序不在前台(如果我们的应用程序在前台，我们可以调用方法“startService()”)，我们<strong class="jp ir">不</strong>被允许调用<strong class="jp ir">“startService()”</strong>在后台进行一些工作(位置更新，同步数据…)。在这种情况下，当我们调用startService时，将会抛出一个异常<strong class="jp ir"> IllegalStateException </strong>。</p><p id="0150" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">相反，我们将使用“<strong class="jp ir">startForegroundService()</strong>”。我们有大约5秒的时间来显示一个通知，告诉用户我们正在后台进行一些操作。这些通知将在我们的服务运行时生效，并在服务结束时消失。</p><figure class="lb lc ld le gt lf gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/356a6ef711f338f7b21209a83e210fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:850/format:webp/1*xw99FymC2ntbKKnxkbpB_A.png"/></div><figcaption class="ne nf gj gh gi ng nh bd b be z dk translated">通知用户我们正在后台工作</figcaption></figure><p id="cf95" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，在我们的服务中，我们必须做的第一件事是显示通知:</p><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="946a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">另一点。如果我们需要在后台启动一项服务，而应用程序不在前台(例如:收到推送通知后)，系统会显示如下内容:</p><figure class="lb lc ld le gt lf gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/b1c68ce6b4bef137e3fd272c7b12de18.png" data-original-src="https://miro.medium.com/v2/resize:fit:850/format:webp/1*8qpPCAEMPilSF7SvHw1BqQ.png"/></div></figure><p id="2b1b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">和另一个场景一样，当工作完成时，通知会消失。</p><p id="51b1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">✋ <strong class="jp ir">重要的</strong> ✋</p><ol class=""><li id="6923" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated"><strong class="jp ir">尽快隐藏通知</strong>👀</li></ol><p id="44cb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们希望我们的<strong class="jp ir">通知</strong>尽快被<strong class="jp ir">隐藏</strong>，我们必须调用“<em class="nk">stop foreground(true)；”</em>服务结束时<em class="nk">。</em>打这个电话，当服务结束时，通知会消失。如果我们不这样做，通知将在状态栏中保留一段时间，直到系统让它消失。</p><p id="192f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> 2。避免通知声音</strong>🔊</p><p id="ec6e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们必须记住的另一个问题是<strong class="jp ir">通知会发出声音</strong>，因此根据我们分配给通知的优先级，当服务启动时，我们可能会对通知声音感到惊讶。所以这不是我们想要的行为，为了解决这个问题<strong class="jp ir">我们必须给我们的通知分配低优先级</strong>。我们不能分配较低的优先级，如果我们这样做，系统会在启动服务时使应用程序崩溃。</p><pre class="lb lc ld le gt nl nm nn no aw np bi"><span id="b558" class="nq lj iq nm b gy nr ns l nt nu">val channel = NotificationChannel(channelId,          BuildConfig.NOTIFICATION_CHANNEL_SILENT_NAME, NotificationManager.IMPORTANCE_LOW)</span></pre><p id="685d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们建议只为静默通知创建一个通知通道，这样我们可以避免用声音提醒用户，而其他通知将继续正常运行。</p><p id="6ed0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以在此处检查通知<a class="ae kz" href="https://developer.android.com/training/notify-user/channels" rel="noopener ugc nofollow" target="_blank">的所有优先级。</a></p><p id="04df" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有了所有这些限制，谷歌想要的是确保开发者在推出一项服务之前在后台研究它是否是最好的方式。通过这种方式，您将获得更好的用户体验和更好的设备性能。</p><h1 id="c21e" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated"><strong class="ak">意向服务→工作意向服务</strong></h1><p id="64d5" class="pw-post-body-paragraph jn jo iq jp b jq mg js jt ju mh jw jx jy mi ka kb kc mj ke kf kg mk ki kj kk ij bi translated">直到现在，当我们想要启动一个意图服务来在后台运行一些长时间的操作时，我们称之为“startService()”,但是从现在开始，就像我们以前说的那样，它不再被允许了。</p><p id="2c34" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以我们要做的改变很容易。我们所有的意向服务看起来都是这样的:</p><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="454a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们必须从<strong class="jp ir"> JobIntentService </strong>扩展。JobIntentService类似于服务，但是它将工作排入兼容Android目标上的JobScheduler。</p><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="7364" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦我们有了JobIntentService，要在后台执行这个操作，我们必须做如下所示的事情:</p><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="5b37" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">并且不要忘记更新您的AndroidManifest.xml，表明该服务是绑定作业服务。</p><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="7a33" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来的帖子试图理解我们在应用程序中针对Android Oreo所做的其他改变。</p><p id="a269" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我希望这篇文章对你有用，如果你发现有什么不对的地方，不要犹豫，告诉我们。</p><h2 id="2561" class="nq lj iq bd lk nv nw dn lo nx ny dp ls jy nz oa lw kc ob oc ma kg od oe me of bi translated"><strong class="ak">有趣的链接</strong></h2><p id="11bb" class="pw-post-body-paragraph jn jo iq jp b jq mg js jt ju mh jw jx jy mi ka kb kc mj ke kf kg mk ki kj kk ij bi translated"><a class="ae kz" href="https://medium.com/exploring-android/exploring-background-execution-limits-on-android-oreo-ab384762a66c" rel="noopener">https://medium . com/exploring-Android/exploring-background-execution-limits-on-Android-Oreo-ab 384762 a66c</a></p><p id="1822" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kz" href="https://android.jlelse.eu/keep-those-background-services-working-when-targeting-android-oreo-sdk-26-cbf6cc2bdb7f" rel="noopener ugc nofollow" target="_blank">https://Android . JL else . eu/keep-these-background-services-working-when-targeting-Android-Oreo-SDK-26-CBF 6 cc 2 BDB 7 f</a></p><p id="982d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">号外:</strong>这个视频以一种简单的方式展示了我们在接下来的几个月里针对Android Oreo和更高版本必须完成的所有改变。</p><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="og nj l"/></div></figure></div></div>    
</body>
</html>