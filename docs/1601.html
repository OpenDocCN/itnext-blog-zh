<html>
<head>
<title>Getting Started Using Puppeteer &amp; Headless Chrome for End-to-End Testing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">开始使用Puppeteer &amp; Headless Chrome进行端到端测试</h1>
<blockquote>原文：<a href="https://itnext.io/getting-started-using-puppeteer-headless-chrome-for-end-to-end-testing-8487718e4d97?source=collection_archive---------0-----------------------#2018-12-08">https://itnext.io/getting-started-using-puppeteer-headless-chrome-for-end-to-end-testing-8487718e4d97?source=collection_archive---------0-----------------------#2018-12-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><h1 id="d722" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated"><strong class="ak">以及关于将木偶师集成到你的笑话测试中的简单介绍</strong></h1><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/28405678e9d350006ae68156ea53907f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5sRPA7J84-OBkz_R0JYBIA.png"/></div></div></figure><h2 id="227f" class="kx jo iq bd jp ky kz dn jt la lb dp jx lc ld le kb lf lg lh kf li lj lk kj ll bi translated"><strong class="ak">这篇文章的灵感来源</strong></h2><p id="ce33" class="pw-post-body-paragraph lm ln iq lo b lp lq lr ls lt lu lv lw lc lx ly lz lf ma mb mc li md me mf mg ij bi mh translated"><span class="l mi mj mk bm ml mm mn mo mp di"> T </span>他写博客的灵感来自于我在<a class="ae mq" href="http://connect.tech/" rel="noopener ugc nofollow" target="_blank"> Connect上看到的一个演讲。今年在亚特兰大召开的Tech </a>会议，主题是:“使用Puppeteer编写在浏览器上运行的端到端测试”。</p><p id="819c" class="pw-post-body-paragraph lm ln iq lo b lp mr lr ls lt ms lv lw lc mt ly lz lf mu mb mc li mv me mf mg ij bi translated">演讲者Taylor Krusen做了一个关于木偶师和headless Chrome的精彩演讲，并结合使用它们将端到端测试提升到了一个新的水平。我过去曾简要地研究过Puppeteer，但是因为我找不到任何关于如何开始使用它的好例子，所以我选择了使用<a class="ae mq" href="https://www.cypress.io/" rel="noopener ugc nofollow" target="_blank"> Cypress.io </a>来满足我的测试需求。</p><p id="cd82" class="pw-post-body-paragraph lm ln iq lo b lp mr lr ls lt ms lv lw lc mt ly lz lf mu mb mc li mv me mf mg ij bi translated">不过，在演讲之后，我受到启发，给了puppet er另一个机会，我更进一步，弄清楚如何运行puppet er以及如何将其与Jest一起使用，Jest是最常与React相关联的测试框架。我想分享这一点，希望能帮助其他人开始使用他们自己的应用测试套件。</p><h2 id="f5f2" class="kx jo iq bd jp ky kz dn jt la lb dp jx lc ld le kb lf lg lh kf li lj lk kj ll bi translated"><strong class="ak">什么是端到端测试&amp;为什么它很重要</strong></h2><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/6339f9c8ef9c4f4ce50c44c1e1a16e12.png" data-original-src="https://miro.medium.com/v2/resize:fit:762/format:webp/1*tteoPtCeGoBGUpvr_gKDbg.png"/></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">按照Google的定义，端到端测试构成了测试金字塔中最小的一部分，但它们仍然是其中至关重要的一部分。</figcaption></figure><p id="3918" class="pw-post-body-paragraph lm ln iq lo b lp mr lr ls lt ms lv lw lc mt ly lz lf mu mb mc li mv me mf mg ij bi translated">在我深入<em class="nb">如何</em> <strong class="lo ir"> </strong>使用Puppeteer进行端到端测试之前，我认为有必要简要解释一下它是什么以及为什么它对当今的web开发如此重要。</p><p id="6aae" class="pw-post-body-paragraph lm ln iq lo b lp mr lr ls lt ms lv lw lc mt ly lz lf mu mb mc li mv me mf mg ij bi translated"><a class="ae mq" href="https://www.techopedia.com/definition/7035/end-to-end-test" rel="noopener ugc nofollow" target="_blank"> Techopedia </a>给出了端到端测试的良好定义:</p><blockquote class="nc nd ne"><p id="9c1b" class="lm ln nb lo b lp mr lr ls lt ms lv lw nf mt ly lz ng mu mb mc nh mv me mf mg ij bi translated">端到端测试是一种用于测试应用程序的流程是否从头到尾都按照设计执行的方法。执行端到端测试的目的是识别系统依赖性，并确保正确的信息在各种系统组件和系统之间传递。</p></blockquote><p id="9610" class="pw-post-body-paragraph lm ln iq lo b lp mr lr ls lt ms lv lw lc mt ly lz lf mu mb mc li mv me mf mg ij bi translated">本质上，端到端测试以自动化的方式复制了用户在与应用程序或浏览器交互时可以做的事情。这样做是为了确保应用程序按预期正常工作。</p><p id="ccde" class="pw-post-body-paragraph lm ln iq lo b lp mr lr ls lt ms lv lw lc mt ly lz lf mu mb mc li mv me mf mg ij bi translated">随着web应用程序变得越来越复杂，功能越来越全面，每当应用程序准备部署新功能时，人工QA团队就越来越难以跟上测试每一项功能。创建端到端测试框架是为了将检查功能的负担(和重复的任务)从人的手中拿走，并让机器(它可以比实际用户移动得更快，并且每次都精确地复制测试)承担更多的负载。</p><p id="473a" class="pw-post-body-paragraph lm ln iq lo b lp mr lr ls lt ms lv lw lc mt ly lz lf mu mb mc li mv me mf mg ij bi translated">最终，作为开发人员，我们仍然要确保我们的应用程序按照我们期望的方式工作，但是测试帮助我们更好地确保我们没有在代码中引入新的错误或损害现有的功能，这就是为什么它如此重要。</p><h2 id="f8dd" class="kx jo iq bd jp ky kz dn jt la lb dp jx lc ld le kb lf lg lh kf li lj lk kj ll bi translated"><strong class="ak">什么是无头铬&amp;木偶师</strong></h2><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ni"><img src="../Images/8f3b5ba304c9e5d74dd87c9a62d24e12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FDqQBGawRMhs4H9wFwEx-Q.png"/></div></div></figure><p id="b960" class="pw-post-body-paragraph lm ln iq lo b lp mr lr ls lt ms lv lw lc mt ly lz lf mu mb mc li mv me mf mg ij bi translated">接下来要讲的是无头Chrome和木偶师到底是什么，为什么它们总是捆绑在一起？</p><p id="6288" class="pw-post-body-paragraph lm ln iq lo b lp mr lr ls lt ms lv lw lc mt ly lz lf mu mb mc li mv me mf mg ij bi translated">木偶师的<a class="ae mq" href="https://github.com/GoogleChrome/puppeteer" rel="noopener ugc nofollow" target="_blank"> Github </a>和<a class="ae mq" href="https://www.npmjs.com/package/puppeteer" rel="noopener ugc nofollow" target="_blank"> NPM </a>页面很好地解释了木偶师到底是什么:</p><blockquote class="nc nd ne"><p id="ae6b" class="lm ln nb lo b lp mr lr ls lt ms lv lw nf mt ly lz ng mu mb mc nh mv me mf mg ij bi translated">Puppeteer是一个节点库，它提供了一个高级API来控制Chrome或通过<a class="ae mq" href="https://chromedevtools.github.io/devtools-protocol/" rel="noopener ugc nofollow" target="_blank"> DevTools协议</a>的Chrome。</p></blockquote><p id="1447" class="pw-post-body-paragraph lm ln iq lo b lp mr lr ls lt ms lv lw lc mt ly lz lf mu mb mc li mv me mf mg ij bi translated">它接着说，Puppeteer默认运行headless Chrome或Chrome实例，这就是为什么它们总是被一前一后地提到。</p><blockquote class="nc nd ne"><p id="2ae3" class="lm ln nb lo b lp mr lr ls lt ms lv lw nf mt ly lz ng mu mb mc nh mv me mf mg ij bi translated">大多数你可以在浏览器中手动完成的事情都可以使用木偶师来完成！</p></blockquote><p id="c9c5" class="pw-post-body-paragraph lm ln iq lo b lp mr lr ls lt ms lv lw lc mt ly lz lf mu mb mc li mv me mf mg ij bi translated">木偶师是由谷歌Chrome DevTools团队为Chrome开发的，以帮助进一步自动化/无头浏览器测试，并让我们其他人不那么痛苦。</p><p id="6ebb" class="pw-post-body-paragraph lm ln iq lo b lp mr lr ls lt ms lv lw lc mt ly lz lf mu mb mc li mv me mf mg ij bi translated">最大的缺点是，木偶师只能与铬。我很幸运地在我们的用户只使用Chrome的应用程序上工作，这使得Puppeteer成为端到端测试的一个非常好的选择，但如果用户群在其浏览器偏好上更加多样化，那么看看其他测试框架可能是明智的，如<a class="ae mq" href="https://www.cypress.io/" rel="noopener ugc nofollow" target="_blank"> Cypress.io </a>、<a class="ae mq" href="https://testcafe.devexpress.com/" rel="noopener ugc nofollow" target="_blank"> TestCafe </a>或<a class="ae mq" href="https://www.seleniumhq.org/projects/webdriver/" rel="noopener ugc nofollow" target="_blank"> Selenium Web Driver </a>。</p><p id="76cd" class="pw-post-body-paragraph lm ln iq lo b lp mr lr ls lt ms lv lw lc mt ly lz lf mu mb mc li mv me mf mg ij bi translated">但今天，至少，我可以谈谈木偶师。</p><h2 id="d2b6" class="kx jo iq bd jp ky kz dn jt la lb dp jx lc ld le kb lf lg lh kf li lj lk kj ll bi translated"><strong class="ak">木偶师示例</strong></h2><p id="0603" class="pw-post-body-paragraph lm ln iq lo b lp lq lr ls lt lu lv lw lc lx ly lz lf ma mb mc li md me mf mg ij bi translated">现在是时候着手让木偶师运行起来了。</p><p id="0a01" class="pw-post-body-paragraph lm ln iq lo b lp mr lr ls lt ms lv lw lc mt ly lz lf mu mb mc li mv me mf mg ij bi translated">开始使用木偶戏实际上非常简单——只需键入<code class="fe nj nk nl nm b">npm i puppeteer</code>,您就可以开始了。是的，真的很简单。之所以这么简单，是因为Chrome DevTools团队方便地将每个版本的Puppeteer与一个版本的Chromium(无头Chrome部分)打包在一起，保证可以一起运行。</p><p id="eabd" class="pw-post-body-paragraph lm ln iq lo b lp mr lr ls lt ms lv lw lc mt ly lz lf mu mb mc li mv me mf mg ij bi translated"><strong class="lo ir">请注意:</strong>puppeter至少需要版本6.4.0的节点，但下面的示例使用的是仅版本7.6.0或更高版本支持的async/await。如你所知。</p><p id="4232" class="pw-post-body-paragraph lm ln iq lo b lp mr lr ls lt ms lv lw lc mt ly lz lf mu mb mc li mv me mf mg ij bi translated">让我们来看看木偶师可以自动化什么。</p><p id="53fc" class="pw-post-body-paragraph lm ln iq lo b lp mr lr ls lt ms lv lw lc mt ly lz lf mu mb mc li mv me mf mg ij bi translated">如果你想自己玩这些例子，你可以在这里下载我的Github repo<a class="ae mq" href="https://github.com/paigen11/puppeteer-and-jest-example" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="2b8e" class="pw-post-body-paragraph lm ln iq lo b lp mr lr ls lt ms lv lw lc mt ly lz lf mu mb mc li mv me mf mg ij bi translated"><strong class="lo ir">截图一个页面— </strong> <code class="fe nj nk nl nm b"><strong class="lo ir">saveFileExample.js</strong></code></p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nn"><img src="../Images/ec3285cd95f583af4e727e3f3212fae4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o3ARQh0wb9Cia9eaZtwO2w.png"/></div></div></figure><p id="0ba7" class="pw-post-body-paragraph lm ln iq lo b lp mr lr ls lt ms lv lw lc mt ly lz lf mu mb mc li mv me mf mg ij bi translated">正如你在所有这些脚本中看到的，只要<code class="fe nj nk nl nm b">puppeteer</code>被导入到文件的顶部，它就可以运行了，所有打包的方法以及像<code class="fe nj nk nl nm b">newPage()</code>和<code class="fe nj nk nl nm b">browser</code>这样的木偶师都可以立即为你所用。</p><p id="3324" class="pw-post-body-paragraph lm ln iq lo b lp mr lr ls lt ms lv lw lc mt ly lz lf mu mb mc li mv me mf mg ij bi translated">第一个示例脚本转到Google主页，拍摄页面照片，并将其保存到名为“google.png”的repo内的. png文件中。</p><p id="a0ae" class="pw-post-body-paragraph lm ln iq lo b lp mr lr ls lt ms lv lw lc mt ly lz lf mu mb mc li mv me mf mg ij bi translated">代码非常简单明了。首先，启动一个无头Chrome浏览器，打开一个新页面，该页面的URL设置为Google，为子孙后代拍摄一个屏幕截图，然后关闭浏览器。整个事情是干净的、优雅的、异步的，并且包装在一个life(<a class="ae mq" href="https://developer.mozilla.org/en-US/docs/Glossary/IIFE" rel="noopener ugc nofollow" target="_blank">立即调用函数表达式</a>)中，所以一旦脚本被调用，函数就运行。</p><p id="66a7" class="pw-post-body-paragraph lm ln iq lo b lp mr lr ls lt ms lv lw lc mt ly lz lf mu mb mc li mv me mf mg ij bi translated"><strong class="lo ir">创建PDF—</strong>T4】</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi no"><img src="../Images/97ed78d8b2341f3b3b8d27a8be18bb43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ms8HX8ySY45IWwQeNr86xA.png"/></div></div></figure><p id="dbc2" class="pw-post-body-paragraph lm ln iq lo b lp mr lr ls lt ms lv lw lc mt ly lz lf mu mb mc li mv me mf mg ij bi translated">第二个木偶师示例访问一个网站(有趣的零售网站，在本例中是ThinkGeek ),并将它访问的网站页面制作成PDF。</p><p id="56f6" class="pw-post-body-paragraph lm ln iq lo b lp mr lr ls lt ms lv lw lc mt ly lz lf mu mb mc li mv me mf mg ij bi translated">与第一个脚本类似，这个脚本设置了木偶师，创建了一个新的浏览器页面，访问ThinkGeek的网站，然后使用<code class="fe nj nk nl nm b">page.pdf()</code>方法制作整个页面的PDF。该PDF再次以“thinkGeek.pdf”的名称保存到项目文件夹中。很简单。</p><p id="d774" class="pw-post-body-paragraph lm ln iq lo b lp mr lr ls lt ms lv lw lc mt ly lz lf mu mb mc li mv me mf mg ij bi translated"><strong class="lo ir">谷歌什么的— </strong> <code class="fe nj nk nl nm b"><strong class="lo ir">searchGoogle.js</strong></code></p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi np"><img src="../Images/5253ef3ae095354c36b3e5b0500fe9c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hOu5CF_mgimpZOrZJ-Y2Cg.png"/></div></div></figure><p id="4605" class="pw-post-body-paragraph lm ln iq lo b lp mr lr ls lt ms lv lw lc mt ly lz lf mu mb mc li mv me mf mg ij bi translated">第三个例子可能更像是在端到端测试中测试的东西——它自动化了谷歌搜索(并在无头模式下截图以确认搜索成功)。</p><p id="eefd" class="pw-post-body-paragraph lm ln iq lo b lp mr lr ls lt ms lv lw lc mt ly lz lf mu mb mc li mv me mf mg ij bi translated">在这个脚本中，Puppeteer启动一个新的浏览器页面，它转到Google，等待搜索框和搜索按钮可见，并在输入中键入“cookies ”,然后等待页面导航到cookies搜索结果，并在最后关闭浏览器之前截屏。</p><p id="a78e" class="pw-post-body-paragraph lm ln iq lo b lp mr lr ls lt ms lv lw lc mt ly lz lf mu mb mc li mv me mf mg ij bi translated">这就是全部了。要了解更多关于木偶师的功能，我建议查看他们非常详尽的<a class="ae mq" href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md" rel="noopener ugc nofollow" target="_blank">文档</a>——那里有大量的信息和功能可以发掘。</p><h2 id="d29d" class="kx jo iq bd jp ky kz dn jt la lb dp jx lc ld le kb lf lg lh kf li lj lk kj ll bi translated"><strong class="ak">调试木偶师</strong></h2><p id="bfe4" class="pw-post-body-paragraph lm ln iq lo b lp lq lr ls lt lu lv lw lc lx ly lz lf ma mb mc li md me mf mg ij bi translated">现在，Puppeteer正在运行，我想调用一些内置于其中的很棒的工具来减少调试的痛苦。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nq"><img src="../Images/55eeea64fee701f3998d3efd2de390c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lR6BKfiOq4xZYCBMAPfSyw.png"/></div></div></figure><p id="d5e0" class="pw-post-body-paragraph lm ln iq lo b lp mr lr ls lt ms lv lw lc mt ly lz lf mu mb mc li mv me mf mg ij bi translated"><strong class="lo ir">关闭无头模式</strong></p><p id="65ff" class="pw-post-body-paragraph lm ln iq lo b lp mr lr ls lt ms lv lw lc mt ly lz lf mu mb mc li mv me mf mg ij bi translated">第一个(也是最明显的一个)是如何关闭Chrome的无头模式；这意味着您可以看到自动浏览器打开，并尝试完成为其设置的步骤。</p><p id="c282" class="pw-post-body-paragraph lm ln iq lo b lp mr lr ls lt ms lv lw lc mt ly lz lf mu mb mc li mv me mf mg ij bi translated">这不在话下。在启动木偶师的脚本中(这几乎是脚本运行时发生的第一件事)，只需添加下面一行:<code class="fe nj nk nl nm b">puppeteer.launch({headless: false});</code></p><p id="aa35" class="pw-post-body-paragraph lm ln iq lo b lp mr lr ls lt ms lv lw lc mt ly lz lf mu mb mc li mv me mf mg ij bi translated"><strong class="lo ir">启用SlowMo </strong></p><p id="1c5e" class="pw-post-body-paragraph lm ln iq lo b lp mr lr ls lt ms lv lw lc mt ly lz lf mu mb mc li mv me mf mg ij bi translated">SlowMo就像它听起来的那样，它减慢了木偶师的操作速度，所以正常人可以看到正在发生的事情。它可以在相同的命令中实例化，其中headless对于Puppeteer设置为false<code class="fe nj nk nl nm b">puppeteer.launch()</code>命令。只需加上<code class="fe nj nk nl nm b">puppeteer.launch({slowMo: 500})</code>或者你想让动作慢下来的毫秒数。</p><p id="816f" class="pw-post-body-paragraph lm ln iq lo b lp mr lr ls lt ms lv lw lc mt ly lz lf mu mb mc li mv me mf mg ij bi translated"><strong class="lo ir">自动打开开发工具面板</strong></p><p id="4356" class="pw-post-body-paragraph lm ln iq lo b lp mr lr ls lt ms lv lw lc mt ly lz lf mu mb mc li mv me mf mg ij bi translated">我的第三个调试技巧是如何告诉木偶师是否用每个标签自动打开Chrome DevTools面板。因此，如果需要，您可以在自动化测试运行中捕捉记录到控制台的内容。</p><p id="b5cc" class="pw-post-body-paragraph lm ln iq lo b lp mr lr ls lt ms lv lw lc mt ly lz lf mu mb mc li mv me mf mg ij bi translated">再一次，在启动木偶的初始命令中，添加<code class="fe nj nk nl nm b">puppeteer.launch({headless: false, devtools: true});</code>来打开一个DevTools面板。</p><p id="6af8" class="pw-post-body-paragraph lm ln iq lo b lp mr lr ls lt ms lv lw lc mt ly lz lf mu mb mc li mv me mf mg ij bi translated"><strong class="lo ir">注意:</strong>如果该选项为<code class="fe nj nk nl nm b">true</code>，则<code class="fe nj nk nl nm b">headless</code>选项将被设置为<code class="fe nj nk nl nm b">false</code>。</p><p id="a832" class="pw-post-body-paragraph lm ln iq lo b lp mr lr ls lt ms lv lw lc mt ly lz lf mu mb mc li mv me mf mg ij bi translated">您甚至可以通过简单地将<code class="fe nj nk nl nm b">page.exposeFunction()</code>中的这个方法组合起来，将无头Chrome浏览器中的事件<code class="fe nj nk nl nm b">console.log</code>输出到您自己的终端。在木偶脚本中定义了<code class="fe nj nk nl nm b">page</code>对象后，您可以:</p><p id="aefa" class="pw-post-body-paragraph lm ln iq lo b lp mr lr ls lt ms lv lw lc mt ly lz lf mu mb mc li mv me mf mg ij bi translated"><code class="fe nj nk nl nm b">page.on(‘console’, msg =&gt; console.log(`Page Console: ${msg.text()}`));</code></p><p id="9282" class="pw-post-body-paragraph lm ln iq lo b lp mr lr ls lt ms lv lw lc mt ly lz lf mu mb mc li mv me mf mg ij bi translated">捕捉来自<code class="fe nj nk nl nm b">console.logs</code>的消息。</p><p id="ed90" class="pw-post-body-paragraph lm ln iq lo b lp mr lr ls lt ms lv lw lc mt ly lz lf mu mb mc li mv me mf mg ij bi translated">这应该有助于你像专业人士一样调试你的傀儡无头Chrome实例和测试。</p><h2 id="d3c6" class="kx jo iq bd jp ky kz dn jt la lb dp jx lc ld le kb lf lg lh kf li lj lk kj ll bi translated">木偶师更酷的特点</h2><p id="8a89" class="pw-post-body-paragraph lm ln iq lo b lp lq lr ls lt lu lv lw lc lx ly lz lf ma mb mc li md me mf mg ij bi translated">除了调试木偶师，我想指出它提供的一些更酷的特性。如果你有兴趣了解他们中的任何一个，我建议查看他们的<a class="ae mq" href="https://www.npmjs.com/package/puppeteer" rel="noopener ugc nofollow" target="_blank"> NPM页面</a>了解更多信息。</p><p id="b2d6" class="pw-post-body-paragraph lm ln iq lo b lp mr lr ls lt ms lv lw lc mt ly lz lf mu mb mc li mv me mf mg ij bi translated">木偶师可以:</p><ul class=""><li id="358d" class="nr ns iq lo b lp mr lt ms lc nt lf nu li nv mg nw nx ny nz bi translated">运行在Docker容器或无服务器环境中，</li><li id="8b28" class="nr ns iq lo b lp oa lt ob lc oc lf od li oe mg nw nx ny nz bi translated">拦截网络请求，</li><li id="7f4f" class="nr ns iq lo b lp oa lt ob lc oc lf od li oe mg nw nx ny nz bi translated">捕获性能信息，</li><li id="8419" class="nr ns iq lo b lp oa lt ob lc oc lf od li oe mg nw nx ny nz bi translated">测试Chrome扩展，</li><li id="b15f" class="nr ns iq lo b lp oa lt ob lc oc lf od li oe mg nw nx ny nz bi translated">运行页面中的代码，并且</li><li id="c33f" class="nr ns iq lo b lp oa lt ob lc oc lf od li oe mg nw nx ny nz bi translated">在移动设备上模拟Chrome</li></ul><p id="5486" class="pw-post-body-paragraph lm ln iq lo b lp mr lr ls lt ms lv lw lc mt ly lz lf mu mb mc li mv me mf mg ij bi translated">它还有很多其他有用的用途。这个团队真的想让它在很多方面对开发者有用。</p><h2 id="41d7" class="kx jo iq bd jp ky kz dn jt la lb dp jx lc ld le kb lf lg lh kf li lj lk kj ll bi translated"><strong class="ak">奖励:反应&amp;笑话&amp;木偶师</strong></h2><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi of"><img src="../Images/1be74e5e998c3aee1df4f1543ccfb8e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WQLENaIDJA9l00aERp-_Qw.png"/></div></div></figure><p id="2200" class="pw-post-body-paragraph lm ln iq lo b lp mr lr ls lt ms lv lw lc mt ly lz lf mu mb mc li mv me mf mg ij bi translated">如果我没有简要提及如何将木偶师集成到带有Jest测试的React项目中，那将是我的失职。React是我目前选择的JavaScript框架(对许多JS开发人员来说似乎也是如此)，所以我使用这两者创建了一个快速设置和测试脚本，也包含在我的示例Github repo <a class="ae mq" href="https://github.com/paigen11/puppeteer-and-jest-example" rel="noopener ugc nofollow" target="_blank">这里的</a>中。</p><p id="d6c4" class="pw-post-body-paragraph lm ln iq lo b lp mr lr ls lt ms lv lw lc mt ly lz lf mu mb mc li mv me mf mg ij bi translated"><strong class="lo ir">笑话配置&amp;木偶师</strong></p><p id="26a9" class="pw-post-body-paragraph lm ln iq lo b lp mr lr ls lt ms lv lw lc mt ly lz lf mu mb mc li mv me mf mg ij bi translated">Jest有一些非常有用的<a class="ae mq" href="https://jestjs.io/docs/en/puppeteer" rel="noopener ugc nofollow" target="_blank">文档</a>来顺利地将Puppeteer集成到它自己的测试框架中，甚至还有一个名为<code class="fe nj nk nl nm b">jest-puppeteer</code>的完整的NPM包来帮助这个过程。以下是安装和配置Jest和木偶师的内容。</p><pre class="km kn ko kp gt og nm oh oi aw oj bi"><span id="2df6" class="kx jo iq nm b gy ok ol l om on">npm install --save-dev jest-puppeteer puppeteer jest</span></pre><p id="534d" class="pw-post-body-paragraph lm ln iq lo b lp mr lr ls lt ms lv lw lc mt ly lz lf mu mb mc li mv me mf mg ij bi translated">一旦所有的东西都安装好了，你可以配置你的Jest配置文件、Webpack文件或者你的<code class="fe nj nk nl nm b">package.json</code>文件，让Jest知道木偶师已经准备好了。以下是我在<code class="fe nj nk nl nm b">package.json</code>中是如何做到的。</p><p id="c55a" class="pw-post-body-paragraph lm ln iq lo b lp mr lr ls lt ms lv lw lc mt ly lz lf mu mb mc li mv me mf mg ij bi translated">就在文件中的<code class="fe nj nk nl nm b">scripts</code>上方，我添加了这个片段，在<code class="fe nj nk nl nm b">scripts</code>内部，我包含了一个<code class="fe nj nk nl nm b">test</code>命令，它只运行Jest。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi oo"><img src="../Images/b4878ea707008d774d4c37eaaf4d901e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FdkpAAGt0P60sw-A-diNPg.png"/></div></div></figure><p id="02eb" class="pw-post-body-paragraph lm ln iq lo b lp mr lr ls lt ms lv lw lc mt ly lz lf mu mb mc li mv me mf mg ij bi translated">现在，我准备好编写测试了。</p><p id="7a45" class="pw-post-body-paragraph lm ln iq lo b lp mr lr ls lt ms lv lw lc mt ly lz lf mu mb mc li mv me mf mg ij bi translated"><strong class="lo ir"> Jest &amp;木偶师测试— </strong> <code class="fe nj nk nl nm b"><strong class="lo ir">google.test.js</strong></code></p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nq"><img src="../Images/f6390aac6c37087905784501dbab9a3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fVz72TYJ54ZTvhQwIT5UKQ.png"/></div></div></figure><p id="2758" class="pw-post-body-paragraph lm ln iq lo b lp mr lr ls lt ms lv lw lc mt ly lz lf mu mb mc li mv me mf mg ij bi translated">如果您以前曾经编写过Jest测试，那么语法应该看起来很熟悉。由于我没有完整的React项目作为我的示例回购的一部分，我将使用这个简单的示例测试，Jest应该在加载后转到Google主页并在该页面上找到文本“Google”。</p><p id="833f" class="pw-post-body-paragraph lm ln iq lo b lp mr lr ls lt ms lv lw lc mt ly lz lf mu mb mc li mv me mf mg ij bi translated">在我的repo中，我设置了NPM脚本，以便在<code class="fe nj nk nl nm b">npm run test</code>进入终端时运行<code class="fe nj nk nl nm b">jest</code>命令。默认情况下，Jest会查找任何带有<code class="fe nj nk nl nm b">*.test.js</code>语法的文件，并尝试运行这些文件。当它找到我的名为<code class="fe nj nk nl nm b">google.test.js</code>的测试文件时，它运行它(没有标题，除非我另外指定)并将测试结果记录到控制台，就像这样。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi op"><img src="../Images/ebbc58492f2b9b649473883ec741238e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cQP-YDsvXOPb9AxxwgCXqQ.png"/></div></div></figure><p id="68d3" class="pw-post-body-paragraph lm ln iq lo b lp mr lr ls lt ms lv lw lc mt ly lz lf mu mb mc li mv me mf mg ij bi translated">如果测试失败，您可以像平常一样进行调试(如果您需要查看出了什么问题，甚至可以打开自动化的Chrome浏览器)，如果没有，您的计算机屏幕可以免于测试，因为您的端到端测试仍然在后台运行。</p><p id="ce7b" class="pw-post-body-paragraph lm ln iq lo b lp mr lr ls lt ms lv lw lc mt ly lz lf mu mb mc li mv me mf mg ij bi translated">太棒了。这看起来并不难，不是吗？</p><h2 id="5e36" class="kx jo iq bd jp ky kz dn jt la lb dp jx lc ld le kb lf lg lh kf li lj lk kj ll bi translated">结论</h2><p id="2b06" class="pw-post-body-paragraph lm ln iq lo b lp lq lr ls lt lu lv lw lc lx ly lz lf ma mb mc li md me mf mg ij bi translated">Puppeteer是Google DevTools团队开发的一个强大的工具，它使得无头的、自动化的浏览器测试在各个方面都更加容易。开始时需要的配置更少，语法更有意义，它的用途远远超出了开发期间测试web应用程序的范围。同样，集成到React应用程序中来自动运行Jest测试也很容易。</p><p id="03ad" class="pw-post-body-paragraph lm ln iq lo b lp mr lr ls lt ms lv lw lc mt ly lz lf mu mb mc li mv me mf mg ij bi translated">过几周再来看看，我会写一些与web开发相关的东西，所以请关注我，这样你就不会错过了。</p><p id="84f8" class="pw-post-body-paragraph lm ln iq lo b lp mr lr ls lt ms lv lw lc mt ly lz lf mu mb mc li mv me mf mg ij bi translated">感谢您的阅读，我希望这能让您了解如何开始使用Puppeteer进行自己的端到端测试，并与React和Jest测试集成。非常感谢鼓掌和分享！</p><p id="b497" class="pw-post-body-paragraph lm ln iq lo b lp mr lr ls lt ms lv lw lc mt ly lz lf mu mb mc li mv me mf mg ij bi translated">如果你喜欢读这篇文章，你可能也会喜欢我的其他一些博客:</p><ul class=""><li id="0216" class="nr ns iq lo b lp mr lt ms lc nt lf nu li nv mg nw nx ny nz bi translated"><a class="ae mq" rel="noopener ugc nofollow" target="_blank" href="/the-absolute-easiest-way-to-debug-node-js-with-vscode-2e02ef5b1bad">调试Node.js最简单的方法——用VS代码</a></li><li id="523f" class="nr ns iq lo b lp oa lt ob lc oc lf od li oe mg nw nx ny nz bi translated"><a class="ae mq" rel="noopener ugc nofollow" target="_blank" href="/implementing-json-web-tokens-passport-js-in-a-javascript-application-with-react-b86b1f313436">用React </a>在JavaScript应用中实现JSON Web令牌&amp; Passport.js</li><li id="1b5a" class="nr ns iq lo b lp oa lt ob lc oc lf od li oe mg nw nx ny nz bi translated"><a class="ae mq" rel="noopener ugc nofollow" target="_blank" href="/using-node-js-to-read-really-really-large-files-pt-1-d2057fe76b33">使用Node.js读取非常非常大的数据集&amp;文件(Pt 1) </a></li></ul></div><div class="ab cl oq or hu os" role="separator"><span class="ot bw bk ou ov ow"/><span class="ot bw bk ou ov ow"/><span class="ot bw bk ou ov"/></div><div class="ij ik il im in"><p id="8702" class="pw-post-body-paragraph lm ln iq lo b lp mr lr ls lt ms lv lw lc mt ly lz lf mu mb mc li mv me mf mg ij bi translated"><strong class="lo ir">参考资料和更多资源:</strong></p><ul class=""><li id="3a99" class="nr ns iq lo b lp mr lt ms lc nt lf nu li nv mg nw nx ny nz bi translated">木偶师Jest Sample Repo，Github:<a class="ae mq" href="https://github.com/paigen11/puppeteer-and-jest-example" rel="noopener ugc nofollow" target="_blank">https://github.com/paigen11/puppeteer-and-jest-example</a></li><li id="ce08" class="nr ns iq lo b lp oa lt ob lc oc lf od li oe mg nw nx ny nz bi translated">端到端测试，Techopedia:<a class="ae mq" href="https://www.techopedia.com/definition/7035/end-to-end-test" rel="noopener ugc nofollow" target="_blank">https://www.techopedia.com/definition/7035/end-to-end-test</a></li><li id="6d73" class="nr ns iq lo b lp oa lt ob lc oc lf od li oe mg nw nx ny nz bi translated">https://www.npmjs.com/package/puppeteer</li><li id="4777" class="nr ns iq lo b lp oa lt ob lc oc lf od li oe mg nw nx ny nz bi translated">Github木偶师:<a class="ae mq" href="https://github.com/GoogleChrome/puppeteer" rel="noopener ugc nofollow" target="_blank">https://github.com/GoogleChrome/puppeteer</a></li><li id="8550" class="nr ns iq lo b lp oa lt ob lc oc lf od li oe mg nw nx ny nz bi translated">木偶师API文档，Github:<a class="ae mq" href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md" rel="noopener ugc nofollow" target="_blank">https://Github . com/Google chrome/木偶师/blob/master/docs/api.md </a></li><li id="d718" class="nr ns iq lo b lp oa lt ob lc oc lf od li oe mg nw nx ny nz bi translated">与木偶师的玩笑:<a class="ae mq" href="https://jestjs.io/docs/en/puppeteer" rel="noopener ugc nofollow" target="_blank">https://jestjs.io/docs/en/puppeteer</a></li></ul></div></div>    
</body>
</html>