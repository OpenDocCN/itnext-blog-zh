<html>
<head>
<title>Accuracy with React Memorization</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应记忆的准确性</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-use-memorization-in-react-applications-8ba3f11b2984?source=collection_archive---------2-----------------------#2022-12-14">https://itnext.io/how-to-use-memorization-in-react-applications-8ba3f11b2984?source=collection_archive---------2-----------------------#2022-12-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f6ba" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何在react应用程序中使用备忘录</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/8db4f77b837e8caf976d29ffb34282d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*En9Q6nqimpgFtXkLSw0ksg.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">感谢来自<a class="ae kv" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank">unsplash.com</a>的<a class="ae kv" href="https://unsplash.com/@fahrulazmi" rel="noopener ugc nofollow" target="_blank">法鲁拉米</a>的图片</figcaption></figure><p id="2ec1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">返回已经存储的数据的想法并不新鲜，但是理解它是如何工作的对于所有开发人员来说都是非常重要的。</p><p id="bb71" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">备忘录是内存，开发技术有助于优化昂贵函数的计算过程。记忆的使用是一个非常重要的实践，并被作为发展的关键知识。React有很好的记忆工具。但是它是如何工作的，为什么它很重要，以及如何使用它？让我们在这篇文章中用实际例子来详细了解一下。</p><h1 id="22a4" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">什么是识记？</h1><p id="b777" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">记忆是刚刚有了存储的功能。闭包有助于存储数据，并通过键从那里获取数据以获得结果。非常简单的想法:键和值。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mp"><img src="../Images/3752596ab6e98bfd3619d2753ed1469f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lbqQWV61LN5p2QzFSGdR6A.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">记忆图式</figcaption></figure><p id="65b6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设我们有一个函数，它有两个参数，结果是这两个参数的和。我们该怎么办？我们将把它作为参数传递给memo函数。</p><p id="351d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用下面的函数，我们将创建一个<code class="fe mq mr ms mt b">memory</code>属性作为一个空对象，然后返回一个需要参数的新函数。我们将使用这些参数作为存储和返回记忆函数结果的密钥。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">记忆功能</figcaption></figure><p id="a726" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以看到，在对记忆的函数进行其他调用之后，有一种情况，我们基于字符串参数中的键来检查现有的结果。如果结果已经存在，我们只返回结果本身。</p><h1 id="581c" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">怎么用？</h1><p id="e8d7" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">首先，让我们在函数中放一些<code class="fe mq mr ms mt b">console.log</code>来更好地理解状态变化。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">结果日志</figcaption></figure><p id="0d23" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们为memo创建一个函数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">备忘录功能</figcaption></figure><p id="e47c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">记住它并多次重复使用该函数，并检查记住的函数实际被调用了多少次。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">来自记忆功能的日志</figcaption></figure><p id="f6ce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们创建了记忆的函数并调用了<code class="fe mq mr ms mt b">console.log</code>五次，但是在三次调用中传递了相同的参数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">记忆功能的结果</figcaption></figure><p id="73ba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">记忆的函数将只被调用三次，因为如果结果已经知道，则不需要再次调用该函数，在这种情况下，结果将从内存中返回。</p><h1 id="7785" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">应用于反应组件</h1><p id="0de5" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">如果我们将此应用于react组件，会发生什么？</p><p id="37ea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们在React应用程序中创建一个非常简单的组件，使用<code class="fe mq mr ms mt b">yarn create vite</code>而不使用<code class="fe mq mr ms mt b">React.StrictMode</code>。</p><p id="855f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">严格模式不是我们的目标。它只是为了突出继承的API的潜在问题而进行额外的渲染，例如，一些导入的组件。我们不会使用任何库。相反，我们将关注渲染过程。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">钥匙控制台</figcaption></figure><p id="0db6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们将另一个<code class="fe mq mr ms mt b">console.log</code>放到我们的<code class="fe mq mr ms mt b">memorize</code>函数中，然后运行这个应用程序。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">块组件</figcaption></figure><p id="c4b8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后使用<code class="fe mq mr ms mt b">memorize</code>函数记住我们的<code class="fe mq mr ms mt b">Block</code>组件:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">记忆块</figcaption></figure><p id="1a13" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们试着多次使用同一个<code class="fe mq mr ms mt b">MemorizedBlock</code>组件，以确保<code class="fe mq mr ms mt b">Block</code>只被调用一次。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">反应应用程序</figcaption></figure><p id="df54" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们来看看<code class="fe mq mr ms mt b">console.log</code>的结果:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">记忆反应成分的结果</figcaption></figure><p id="2cb6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以看到<code class="fe mq mr ms mt b">MemorizedBlock</code>被使用了很多次，但是所有时间的结果都是一样的，这意味着我们只计算了一次。其他迭代来自内存。React提供了同样的记忆功能。</p><h2 id="a1b6" class="mw lt iq bd lu mx my dn ly mz na dp mc lf nb nc me lj nd ne mg ln nf ng mi nh bi translated">React .备忘录</h2><p id="44f8" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">现在，让我们创建更多的组件，以便使用所有这些组件，并检查更新了什么以及在什么时间更新的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">成分</figcaption></figure><p id="6093" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在每一个组件里，我们放上<code class="fe mq mr ms mt b">console.log</code>，为了看看都渲染了什么。最后，总结我们应用程序中的所有内容:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">应用</figcaption></figure><p id="0e89" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">运行应用程序，您会在控制台中看到以下输出:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">控制台中的输出</figcaption></figure><p id="b439" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，如果您点击按钮，您将看到所有组件都将被渲染。为什么会这样？因为那些组件(功能)其实并没有记住。让我们将<code class="fe mq mr ms mt b">Footer</code>包装到<code class="fe mq mr ms mt b">React.memo</code>，以便存储属性，并像前面所描述的那样，只从内存中计算存储的结果。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">页脚</figcaption></figure><p id="97e7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">再次渲染应用程序，你可以看到点击按钮后只有两个组件<code class="fe mq mr ms mt b">Header</code>和<code class="fe mq mr ms mt b">Content</code>被更新，除了<code class="fe mq mr ms mt b">Footer</code>，因为<code class="fe mq mr ms mt b">Footer</code>在道具上没有变化。让我们对<code class="fe mq mr ms mt b">Content</code>组件做同样的事情。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">满足于备忘录</figcaption></figure><p id="aa79" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">点击按钮后，你会发现只重新渲染<code class="fe mq mr ms mt b">Header</code>，因为<code class="fe mq mr ms mt b">Header</code>没有被记忆。但是如你所见，我们在<code class="fe mq mr ms mt b">Content</code>中获得了一些值，它没有被重新呈现，因为值总是相同的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">内容组件的值</figcaption></figure><p id="1e2c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果检查文件<code class="fe mq mr ms mt b">react.development.js</code>中的<code class="fe mq mr ms mt b">memo</code>功能，将会出现该功能:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">React开发文件中的备忘录</figcaption></figure><p id="c6f4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">并且通过以下条件进行比较:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">React开发文件中的比较函数</figcaption></figure><p id="5ff1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它与<code class="fe mq mr ms mt b">memo</code>函数的附加参数中的两个<code class="fe mq mr ms mt b">prevProps</code>和<code class="fe mq mr ms mt b">nextProps</code>参数一起工作，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">道具比较的用法</figcaption></figure><p id="2f68" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，您可以针对组件更新微调props比较。现在向内容添加以下值:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">内容值</figcaption></figure><p id="5250" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">并记住<code class="fe mq mr ms mt b">Header</code>组件:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">备忘录标题</figcaption></figure><p id="bf2d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在点击按钮后，你发现只有<code class="fe mq mr ms mt b">Content</code>被渲染。这是因为<code class="fe mq mr ms mt b">setCount</code>的功能与<code class="fe mq mr ms mt b">useState</code>相同，反应过来关心它。但是，如果我们将为句柄状态创建自己的函数，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">带有函数处理程序的应用程序</figcaption></figure><p id="3d54" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">并更新props中函数的<code class="fe mq mr ms mt b">Header</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">从props更新函数的标题组件</figcaption></figure><p id="da43" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过更新状态，组件<code class="fe mq mr ms mt b">Header</code>和<code class="fe mq mr ms mt b">Content</code>也更新。这是因为函数<code class="fe mq mr ms mt b">setCountHandler</code>有一个<a class="ae kv" href="https://en.wikipedia.org/wiki/Referential_integrity" rel="noopener ugc nofollow" target="_blank">参照完整性</a>问题。为了对函数有相同的引用，让我们进入下一部分。</p><h2 id="7dd0" class="mw lt iq bd lu mx my dn ly mz na dp mc lf nb nc me lj nd ne mg ln nf ng mi nh bi translated">使用回调</h2><p id="7594" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">为了解决引用完整性问题，React有一个特殊的钩子— <code class="fe mq mr ms mt b">useCallback</code>。让我们将处理程序更新为</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">useCallback的用法</figcaption></figure><p id="9149" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在只更新<code class="fe mq mr ms mt b">Content</code>，因为对于<code class="fe mq mr ms mt b">setCountHandler</code>参考相同的。但是如果提供给依赖项的空对象是这样的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">useCallback的依赖关系</figcaption></figure><p id="6a9e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个问题会再次出现，因为每个对象在每次渲染时都有不同的引用。要解决这个问题，让我们转到以下部分。</p><h2 id="d6fa" class="mw lt iq bd lu mx my dn ly mz na dp mc lf nb nc me lj nd ne mg ln nf ng mi nh bi translated">使用备忘录</h2><p id="6cde" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">这个钩子解决了带有引用的值的问题。从字面上看，它返回记忆的值。钩子也依赖于更新规则。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">使用备忘录的用法</figcaption></figure><p id="dbd5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mq mr ms mt b">useMemo</code>和<code class="fe mq mr ms mt b">useCallback</code>的区别在于<code class="fe mq mr ms mt b">useMemo</code>返回记忆值，而<code class="fe mq mr ms mt b">useCallback</code>返回记忆功能。例如，如果您像这样向<code class="fe mq mr ms mt b">Context</code>提供值:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">内容的价值</figcaption></figure><p id="0ad1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">即使有静态计数值，组件也会保持更新。在这种情况下，<code class="fe mq mr ms mt b">useMemo</code>也将有助于解决那个问题。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">使用备忘录中的值</figcaption></figure><p id="f801" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在数值被存储起来，点击按钮后没有任何反应，因为数值总是相同的。如果在<code class="fe mq mr ms mt b">useMemo</code>钩子中使用状态<code class="fe mq mr ms mt b">count</code>会发生什么？</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">useMemo中来自useState的值</figcaption></figure><p id="baf6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">更新之后，什么都不会改变，状态<code class="fe mq mr ms mt b">Content</code>也不会更新。这是因为没有提供依赖关系<code class="fe mq mr ms mt b">useMemo</code>来更新该值。要解决这个问题，请将count from state添加到dependency:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">更新了useMemo的相关性</figcaption></figure><p id="5ef0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在一切正常。相关性更新<code class="fe mq mr ms mt b">useMemo</code>校正，并且值更新更新<code class="fe mq mr ms mt b">Content</code>组件。</p></div><div class="ab cl ni nj hu nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="ij ik il im in"><h2 id="cee9" class="mw lt iq bd lu mx my dn ly mz na dp mc lf nb nc me lj nd ne mg ln nf ng mi nh bi translated">结论</h2><p id="879d" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">请记住，记忆不应该发生在轻，简单的功能。如果没有昂贵的计算，问题不大。只有对于繁重的功能，如果保持记忆和避免昂贵的不必要的重新计算是公平的。</p><h1 id="128c" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">资源</h1><ul class=""><li id="34fe" class="np nq iq ky b kz mk lc ml lf nr lj ns ln nt lr nu nv nw nx bi translated"><code class="fe mq mr ms mt b">React.<strong class="ky ir">memo</strong></code>:<a class="ae kv" href="https://reactjs.org/docs/react-api.html#reactmemo" rel="noopener ugc nofollow" target="_blank">https://reactjs.org/docs/react-api.html#reactmemo</a></li><li id="9613" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi translated"><code class="fe mq mr ms mt b">React.<strong class="ky ir">useCallback</strong></code>:<a class="ae kv" href="https://reactjs.org/docs/hooks-reference.html#usecallback" rel="noopener ugc nofollow" target="_blank">https://reactjs.org/docs/hooks-reference.html#usecallback</a></li><li id="4980" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi translated"><code class="fe mq mr ms mt b">React.<strong class="ky ir">useMemo</strong></code><strong class="ky ir">:</strong><a class="ae kv" href="https://reactjs.org/docs/hooks-reference.html#usememo" rel="noopener ugc nofollow" target="_blank">https://reactjs.org/docs/hooks-reference.html#usememo</a></li></ul></div></div>    
</body>
</html>