<html>
<head>
<title>Clear defensive programming with Go using Verifier library</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用验证器库通过Go清除防御性编程</h1>
<blockquote>原文：<a href="https://itnext.io/clear-defensive-programming-with-go-using-verifier-library-6f648810b453?source=collection_archive---------3-----------------------#2018-08-02">https://itnext.io/clear-defensive-programming-with-go-using-verifier-library-6f648810b453?source=collection_archive---------3-----------------------#2018-08-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="41fc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一些软件对可用性、安全性或保密性的要求比通常的更高。在这样的项目中，人们经常实践务实的偏执狂和被称为<a class="ae kl" href="https://en.wikipedia.org/wiki/Defensive_programming" rel="noopener ugc nofollow" target="_blank">防御性编程</a>的编码风格。</p><p id="5063" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这种方法背后的思想是，即使在意外的情况下，您的代码也应该以一致和可预测的方式运行。在实践中，你将防御不可能的事情，因为当外部世界发生变化时，事情变得可能:新人加入团队，代码进入维护，依赖性升级……实际上，当涉及到错误时，人类使任何事情都成为可能。</p><p id="ae94" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">吉姆·伯德<a class="ae kl" href="https://dzone.com/articles/defensive-programming-just" rel="noopener ugc nofollow" target="_blank">已经收集了</a>一套关于如何在你的代码库中使用防御性编程的规则:</p><ol class=""><li id="a375" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk kr ks kt ku bi translated">保护你的代码免受来自外<em class="kv">的无效数据，无论你决定</em>外<em class="kv">在哪里。外部系统、文件或来自模块/组件外部的任何调用。建立“信任边界”——边界外的一切都是危险的，边界内的一切都是安全的。在路障代码中，验证所有输入数据。</em></li><li id="4305" class="km kn iq jp b jq kw ju kx jy ky kc kz kg la kk kr ks kt ku bi translated">检查坏数据后，决定如何处理它。防御性编程不是吞下错误或隐藏错误。选择处理坏数据的策略:返回一个错误并马上停止(fast fail)，返回一个中性值，代入数据值……确保策略清晰一致。</li><li id="e99b" class="km kn iq jp b jq kw ju kx jy ky kc kz kg la kk kr ks kt ku bi translated">不要假设代码之外的函数调用或方法调用会像宣传的那样工作。确保您理解并测试了外部API和库的错误处理。</li><li id="d847" class="km kn iq jp b jq kw ju kx jy ky kc kz kg la kk kr ks kt ku bi translated">使用断言来记录假设并强调“不可能”的情况。这在长期由不同的人维护的大型系统中，或者在高可靠性代码中尤其重要。</li><li id="91b6" class="km kn iq jp b jq kw ju kx jy ky kc kz kg la kk kr ks kt ku bi translated">智能地添加诊断代码、日志记录和跟踪，以帮助解释运行时发生了什么，尤其是当您遇到问题时。</li><li id="f06c" class="km kn iq jp b jq kw ju kx jy ky kc kz kg la kk kr ks kt ku bi translated">标准化错误处理。决定如何处理“正常错误”或“预期错误”和警告，并始终如一地完成所有这些工作。</li></ol></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><p id="8dd2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这样的规则确实有效，可以帮助人们制作可靠的软件，但是当你使用这些方法时，你的代码会很快变得一团糟。有时候很难区分验证码和底层业务逻辑。查看在执行转移之前执行的一系列验证:</p><figure class="li lj lk ll gt lm"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="37ca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我想我们都同意，这些线是重复的，甚至在某种程度上容易出错。错误处理容易出错😏。但是我们可以使用<a class="ae kl" href="https://github.com/storozhukBM/verifier" rel="noopener ugc nofollow" target="_blank">验证器</a>库使它变得更好:</p><figure class="li lj lk ll gt lm"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="5bc9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://github.com/storozhukBM/verifier" rel="noopener ugc nofollow" target="_blank">验证器</a>建立在Rob Pike在Go博客<a class="ae kl" href="https://blog.golang.org/errors-are-values" rel="noopener ugc nofollow" target="_blank">中描述的错误处理模式之上，错误是值</a>。这个图书馆是透明的，非个人化的。它不是来为你处理错误的。它不会强迫你采用任何错误处理风格，你将处于控制之中，并决定什么对你的项目更好。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><p id="4b86" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你想了解更多，请访问<a class="ae kl" href="https://github.com/storozhukBM/verifier" rel="noopener ugc nofollow" target="_blank"> Github </a>页面。<br/>你也可以在这里探讨更多关于<a class="ae kl" href="http://wiki.c2.com/?DefensiveProgramming" rel="noopener ugc nofollow" target="_blank">防守</a>和<a class="ae kl" href="http://wiki.c2.com/?OffensiveProgramming" rel="noopener ugc nofollow" target="_blank">进攻</a>编程<a class="ae kl" href="http://wiki.c2.com/?OffensiveDefensiveProgramming" rel="noopener ugc nofollow" target="_blank">的想法。</a></p><figure class="li lj lk ll gt lm gh gi paragraph-image"><div class="gh gi lp"><img src="../Images/9a296f15cdb96659038418f18cc42811.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/1*0FWcZIRDnVcmb74W0JEUVQ.gif"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">不可能的魔方由<a class="ae kl" href="https://www.reddit.com/user/NotSaccade" rel="noopener ugc nofollow" target="_blank"><strong class="bd lw">NotSaccade</strong></a><strong class="bd lw"/>from<a class="ae kl" href="https://www.reddit.com/r/blender/comments/7kuzve/impossible_cube/" rel="noopener ugc nofollow" target="_blank">Reddit</a></figcaption></figure></div></div>    
</body>
</html>