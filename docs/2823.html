<html>
<head>
<title>Optimizing Django REST Framework performance with django-auto-prefetching</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Django-自动预取优化Django REST框架性能</h1>
<blockquote>原文：<a href="https://itnext.io/optimizing-django-rest-framework-performance-with-django-auto-prefetching-c70ce316463e?source=collection_archive---------3-----------------------#2019-08-09">https://itnext.io/optimizing-django-rest-framework-performance-with-django-auto-prefetching-c70ce316463e?source=collection_archive---------3-----------------------#2019-08-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="477c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">tldr:django-auto-prefetching是一个在使用django-rest-framework时，通过使用</em> <code class="fe km kn ko kp b"><em class="kl">prefetch_related</em></code> <em class="kl">和</em> <code class="fe km kn ko kp b"><em class="kl">select_related</em></code> <em class="kl">从数据库中提取正确对象来自动优化您的端点的库。你可以在</em><a class="ae kq" href="https://pypi.org/project/django-auto-prefetching/" rel="noopener ugc nofollow" target="_blank"><em class="kl">PyPI</em></a><em class="kl">和</em> <a class="ae kq" href="https://github.com/GeeWee/django-auto-prefetching" rel="noopener ugc nofollow" target="_blank"> <em class="kl"> Github </em> </a>上找到</p><h1 id="e57c" class="kr ks iq bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">Django REST框架和n+1问题</h1><p id="059c" class="pw-post-body-paragraph jn jo iq jp b jq lp js jt ju lq jw jx jy lr ka kb kc ls ke kf kg lt ki kj kk ij bi translated">Django REST框架(DRF)是一个快速构建健壮REST API的框架。然而，当获取具有嵌套关系的模型时，我们会遇到性能问题。DRF变得<em class="kl">迟钝</em>。</p><p id="3e8a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这不是因为DRF本身，而是因为n+1问题。当我们有了一个模型，比如说<code class="fe km kn ko kp b">ItalianChef</code>有了类似<code class="fe km kn ko kp b">FavouriteDish</code>的关系，我们希望获取所有意大利厨师及其相应的最喜爱的菜肴。这意味着我们可能会进行大量的查询，因为DRF首先会获取所有的厨师，然后为每个厨师分别获取他们最喜欢的菜肴。这意味着，如果有20个厨师，我们将最终为喜爱的菜肴进行20次单独的数据库调用。</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="7801" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Django对这个问题有一个内置的解决方案，<code class="fe km kn ko kp b">select_related</code>和<code class="fe km kn ko kp b">prefetch_related</code>，它告诉ORM你需要什么相关的对象。这意味着我们可以只做一个，而不是做一堆数据库调用。</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="b1e5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，这有两个问题——很难准确跟踪最终将遍历什么关系，手动编写<code class="fe km kn ko kp b">select_related</code>和<code class="fe km kn ko kp b">prefetch_related</code>调用非常耗时，更不用说在其他地方的代码发生变化时保持它们的更新了。</p><h1 id="6387" class="kr ks iq bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">django简介——自动预取</h1><p id="3da5" class="pw-post-body-paragraph jn jo iq jp b jq lp js jt ju lq jw jx jy lr ka kb kc ls ke kf kg lt ki kj kk ij bi translated">这个库的目标是尽可能轻松地确保您不会因为n+1问题而遇到性能问题。我们从小规模开始，为DRF序列化程序自动预取。</p><h1 id="cba2" class="kr ks iq bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">它是做什么的？</h1><p id="593c" class="pw-post-body-paragraph jn jo iq jp b jq lp js jt ju lq jw jx jy lr ka kb kc ls ke kf kg lt ki kj kk ij bi translated">Django-auto-prefetching有一个ModelViewSet mixin，它查看任何给定序列化程序使用的字段，并自动计算正确的<code class="fe km kn ko kp b">select_related</code>和<code class="fe km kn ko kp b">prefetch_related</code>调用。</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="118a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这意味着一行代码就是您的许多视图所需要的全部优化！</p><h1 id="87c4" class="kr ks iq bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">生产准备好了吗？</h1><p id="e167" class="pw-post-body-paragraph jn jo iq jp b jq lp js jt ju lq jw jx jy lr ka kb kc ls ke kf kg lt ki kj kk ij bi translated">django-自动预取正在丹麦初创公司<a class="ae kq" href="https://www.reccoon.dk/" rel="noopener ugc nofollow" target="_blank"> reccoon </a>内部使用，在Django代码库中大约有20k行代码。我们有许多未优化的端点，我们已经看到，仅仅通过从AutoPrefetchMixin继承我们的视图集，我们的整个API的响应时间就普遍加快了30–40%</p><h1 id="8380" class="kr ks iq bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">下一步是什么？</h1><p id="9055" class="pw-post-body-paragraph jn jo iq jp b jq lp js jt ju lq jw jx jy lr ka kb kc ls ke kf kg lt ki kj kk ij bi translated">我认为在自动预取方面还有很多改进，而且我认为它有可能解决Django的很多痛点。通过更多的工程努力，应该可以追踪来自特定<code class="fe km kn ko kp b">QuerySet</code>的模型的生命周期，并自动预取所需的相关对象。它可能永远不会完美，但Django在许多方面都非常聪明，我们仍然手写这一部分似乎很疯狂。</p><p id="f249" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">自己去试试<code class="fe km kn ko kp b">django-auto-prefetching</code>吧。你可以在<a class="ae kq" href="https://pypi.org/project/django-auto-prefetching/" rel="noopener ugc nofollow" target="_blank"> PyPI </a>上找到它，并确保在<a class="ae kq" href="https://github.com/GeeWee/django-auto-prefetching" rel="noopener ugc nofollow" target="_blank"> Github </a>上报告你发现的任何问题</p></div></div>    
</body>
</html>