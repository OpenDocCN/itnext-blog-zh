<html>
<head>
<title>Creating a Inheritable Staking contract in Solidity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在实体中创建可继承的标桩合同</h1>
<blockquote>原文：<a href="https://itnext.io/creating-a-inheritable-staking-contract-in-solidity-7804ae2d7a32?source=collection_archive---------0-----------------------#2021-08-03">https://itnext.io/creating-a-inheritable-staking-contract-in-solidity-7804ae2d7a32?source=collection_archive---------0-----------------------#2021-08-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/4ae80a4ff2c14b8626bd9fdf97be0072.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*beNNk4dNgWcVyjA6L7uWJg.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">珀西·博尔默拍摄的图片</figcaption></figure><p id="e201" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">本文是四部分系列的第二部分。</p><ol class=""><li id="2b93" class="lf lg it kj b kk kl ko kp ks lh kw li la lj le lk ll lm ln bi translated"><a class="ae lo" href="https://medium.com/@percybolmer1/building-a-decentralized-application-with-bep-20-contract-in-solidity-d2c066447aa6" rel="noopener"> <strong class="kj iu">【在Solidity中用BEP-20契约构建一个去中心化的应用】</strong> </a> —这篇文章将帮助你理解Solidity的基础知识</li><li id="fee4" class="lf lg it kj b kk lp ko lq ks lr kw ls la lt le lk ll lm ln bi translated"><strong class="kj iu">【在实体中创建可继承的赌注契约】</strong> —第二篇文章，我们将介绍更高级的实体物品，并实现赌注和奖励</li><li id="efdb" class="lf lg it kj b kk lp ko lq ks lr kw ls la lt le lk ll lm ln bi translated"><a class="ae lo" href="https://medium.com/@percybolmer1/using-a-smart-contract-in-an-web-application-78432ed68527" rel="noopener"> <strong class="kj iu">【在Web应用中使用智能合约】</strong> </a> —本系列的第三篇文章，我们将学习如何使用元掩码通过Web应用连接到区块链</li><li id="6ee3" class="lf lg it kj b kk lp ko lq ks lr kw ls la lt le lk ll lm ln bi translated"><a class="ae lo" href="https://medium.com/@percybolmer1/deploying-smart-contracts-to-binance-smart-chain-with-truffle-c57a7d1eb6ed" rel="noopener"> <strong class="kj iu">【将智能合约部署到币安松露智能连锁店】</strong> </a> —第四篇也是最后一篇文章，我们将学习如何将智能合约部署到真实网络中</li></ol><p id="0ce2" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">在第一部分中，我们介绍了如何设置开发环境来开发定制的BEP20令牌。在这篇文章中，我们将添加标记的令牌。</p><p id="deef" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">如果你没有第一篇文章的完整代码，你可以在这里找到。</p><h2 id="b2e7" class="lu lv it bd lw lx ly dn lz ma mb dp mc ks md me mf kw mg mh mi la mj mk ml mm bi translated">什么是赌注？</h2><p id="c4f9" class="pw-post-body-paragraph kh ki it kj b kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la mr lc ld le im bi translated">赌注是指你将代币投入网络，并因此获得报酬。之所以鼓励下注，是因为有一个术语叫做赌注证明。把它看作是挖掘，但不是运行GPU来计算东西，而是通过在网络中存储令牌来挖掘。你可以在这里 阅读详细解释<a class="ae lo" href="https://academy.binance.com/en/articles/what-is-staking" rel="noopener ugc nofollow" target="_blank"> <em class="ms">。</em></a></p><p id="bdfa" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">在本文中，我们将通过继承另一个契约来添加Staking。</p><h2 id="e818" class="lu lv it bd lw lx ly dn lz ma mb dp mc ks md me mf kw mg mh mi la mj mk ml mm bi translated"><strong class="ak">介绍令牌的赌注</strong></h2><p id="c30f" class="pw-post-body-paragraph kh ki it kj b kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la mr lc ld le im bi translated">是时候让我们的DevToken变得更酷一些，增加一些功能了。目前，这只是一个简单的象征，我们真的不能做太多。让我们添加下注令牌并从中获得奖励的功能。</p><p id="db2a" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">让我们首先创建一个可以由DevToken继承的新的智能契约。创建一个名为<strong class="kj iu"> contracts/Stakable.sol的文件。</strong>我们将从编写一个空合同开始，并在进行过程中向其中添加项目。这样，我们就可以深入了解每个部分的实际功能。</p><figure class="mt mu mv mw gt ju"><div class="bz fp l di"><div class="mx my l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">可押记—我们的可押记合约的空模板</figcaption></figure><p id="d7d2" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">在继续之前，将可赌注契约继承到DevToken中，并确保我们可以编译。</p><p id="8cd1" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">打开<strong class="kj iu"> contracts/DevToken.sol </strong>并确保更新合同声明以继承可维护合同，我们还需要导入可维护合同。</p><figure class="mt mu mv mw gt ju"><div class="bz fp l di"><div class="mx my l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">DevToken —继承可拥有的和可堆叠的契约</figcaption></figure><pre class="mt mu mv mw gt mz na nb nc aw nd bi"><span id="75be" class="lu lv it na b gy ne nf l ng nh">truffle compile // Compile to make sure everything is correct</span></pre><p id="378c" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">希望一切编译顺利，否则修复错误，然后让我们开始建立我们的打桩机制。</p><p id="a649" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">我们需要做的第一件事是创建所有我们需要的结构。我们将使用一个<strong class="kj iu">映射</strong>来跟踪账户的股份指数。solidity中的<strong class="kj iu">映射</strong>有点像大多数语言中的哈希映射。它可用于将唯一地址映射到一个值。一个很好的分解可以从Doug Crescenzi 在他的<a class="ae lo" href="https://medium.com/upstate-interactive/mappings-in-solidity-explained-in-under-two-minutes-ecba88aff96e" rel="noopener">帖子</a>中找到。我们将使这个映射成为一个<strong class="kj iu">内部</strong>修饰符，这意味着映射只能从契约内部访问。</p><p id="e1c4" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">我们创建的映射实际上将只保存一个数组的索引引用。这个数组将包含我们所有的利益相关者。我们为什么这样做将很快得到解释。</p><p id="225e" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">我们将保存赌注的信息，包括赌注是何时下的、金额是多少以及是谁下的。还要注意，我们有一个赌注事件，每当下注时都会触发该事件。如果您对事件不确定，请回到本系列的第一篇文章。</p><figure class="mt mu mv mw gt ju"><div class="bz fp l di"><div class="mx my l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">可打桩——我们需要开始打桩的所有结构</figcaption></figure><p id="6adc" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">我们将从添加新的利益相关者的方法开始。该方法将在利益相关者数组中添加一个空白空间，并将新的利益相关者值赋给它。然后它将返回使用过的索引，这个索引是利益相关者的个人索引，其中存储了他/她的所有股份。这个索引可以使用staker的地址来检索。这就是为什么我们使用map 来存储索引，然后通过该索引来检索涉众的<strong class="kj iu">原因。这会节省我们的时间，因为在数组中通过索引查找用户比遍历整个数组要便宜得多。</strong></p><figure class="mt mu mv mw gt ju"><div class="bz fp l di"><div class="mx my l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">可标注—添加利益相关者并绘制他们的地图</figcaption></figure><p id="6400" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">现在我们可以添加新的利益相关者了，让我们添加一个Stake函数，这样我们就可以开始测试它了。这里唯一需要学习的新东西是<strong class="kj iu"> require </strong>关键字。Require用于进行条件检查。如果不满足该条件，呼叫将被拒绝，并显示一条错误消息。所以我们要确保赌注不是0。</p><figure class="mt mu mv mw gt ju"><div class="bz fp l di"><div class="mx my l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">可下注——一种增加新的利益相关者并推动他们下注的方法</figcaption></figure><p id="3325" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">如果你一直在关注，你可能会注意到一件奇怪的事情。如果没有，没关系，我会说出来。</p><p id="1197" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">你有没有想到<strong class="kj iu">股份法并没有修改任何账户</strong>的余额？你有没有注意到_stake方法有一个<strong class="kj iu">内部</strong>修改器？这意味着这个函数不允许在契约之外被调用。</p><p id="e325" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">这不是bug！这是因为该协定将被继承到DevToken协定中。可维护契约不知道继承它的契约的内部工作方式，所以这需要在父契约中实现。让我们打开<strong class="kj iu"> contracts/DevToken.sol </strong>并公开这个函数，并添加一些烧录和编写一些单元测试来确保它能够工作。</p><figure class="mt mu mv mw gt ju"><div class="bz fp l di"><div class="mx my l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">DevToken — Stake是公共的，公开了internal _stake</figcaption></figure><p id="5838" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">DevTokens stake将增加一些要求，如发送方余额必须大于赌注金额。这在可赌注契约中是做不到的，因为它不知道赌注者的平衡。<br/>我们还会下注，然后从下注者账户中烧掉相同的金额。</p><p id="b626" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">让我们测试一下，确保它能正常工作。</p><p id="a60b" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">我已经创建了一个名为<strong class="kj iu"> tests/Stakeable.js </strong>的新文件，它将包含与Stakeable契约相关的测试。</p><p id="a012" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">现在，这也是事件变得令人兴奋的地方。我们实际上可以监听javascript中的事件(如果您想为您的令牌创建一个网站，这会很有帮助)。我们将利用事件来执行我们的测试。我们将触发stakes，然后查看触发的事件，并确保其中的数据是正确的。请记住，我们只在成功的赌注上触发事件。</p><p id="b258" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">为了帮助我们进行单元测试，truffle有一个有用的javascript库，叫做<strong class="kj iu"> truffle-assertions </strong>。如果您按照第一步操作，您应该已经安装了它，但是如果没有，请尝试安装这些</p><pre class="mt mu mv mw gt mz na nb nc aw nd bi"><span id="f15b" class="lu lv it na b gy ne nf l ng nh">npm install chai<br/>npm install truffle-assertions</span></pre><p id="5cef" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">Truffle断言允许我们从区块链上执行的函数中获取响应，并轻松断言该调用发出的事件。</p><pre class="mt mu mv mw gt mz na nb nc aw nd bi"><span id="bae2" class="lu lv it na b gy ne nf l ng nh">truffleAssert.eventEmitted(ReturnedTransaction,"EventName",(ev) =&gt; {</span><span id="66b9" class="lu lv it na b gy ni nf l ng nh">Your custom callback logic with assertion, ev is your event<br/>},</span><span id="2aba" class="lu lv it na b gy ni nf l ng nh">"The error message to trigger if assertion faileed");</span></pre><p id="9d06" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">上例中的ev项包含我们在事件中发送的信息，并且可以被断言。让我们试一试，先做一个简单的测试。</p><p id="1036" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">我们将做一个简单的测试来标记，然后断言标记的事件，并检查信息是否正确。</p><figure class="mt mu mv mw gt ju"><div class="bz fp l di"><div class="mx my l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">stakable . js——简单的第一次测试，以确保它的工作</figcaption></figure><p id="f98f" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">运行测试并确保其正常工作，纠正出现的任何问题。</p><pre class="mt mu mv mw gt mz na nb nc aw nd bi"><span id="1350" class="lu lv it na b gy ne nf l ng nh">truffle test</span></pre><p id="6ea1" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">让我们进一步增加赌注100x2测试，实际赌注两次。</p><figure class="mt mu mv mw gt ju"><div class="bz fp l di"><div class="mx my l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">Stakeable.js —在Staking100x2测试中添加第二个桩</figcaption></figure><p id="aa19" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">我们还将添加一个测试，以确保利益相关者的索引分配正确，因此将在帐户1上建立一个赌注，索引现在应该是2。</p><figure class="mt mu mv mw gt ju"><div class="bz fp l di"><div class="mx my l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">Stakeable.js —新的利益相关者应该得到一个新的索引</figcaption></figure><h2 id="e3e2" class="lu lv it bd lw lx ly dn lz ma mb dp mc ks md me mf kw mg mh mi la mj mk ml mm bi translated">查看区块链的赌注</h2><p id="934e" class="pw-post-body-paragraph kh ki it kj b kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la mr lc ld le im bi translated">在我们继续之前，让我们尝试使用Ganache来检查事务。</p><p id="4729" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">在truffle控制台中执行一个stake，并使用Ganache来监控发出的事件。</p><pre class="mt mu mv mw gt mz na nb nc aw nd bi"><span id="2a48" class="lu lv it na b gy ne nf l ng nh">truffle migrate<br/>truffle console<br/>devToken = await DevToken.deployed(); // await contract to be deployed</span><span id="ed9d" class="lu lv it na b gy ni nf l ng nh">let accounts = await web3.eth.getAccounts() // Grab all accounts<br/>await devToken.stake(100, {from: accounts[0]}) // Stake 100 from owner</span></pre><p id="ebac" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">stake命令的输出将是事务，查看它可以很好地了解正在发生的事情。还要记住，由于以太坊的性质，每个动作都有一个气体成本。</p><p id="4522" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">打开Ganache并转到Events选项卡，您应该能够显示自我们迁移以来网络上发生的所有事件。</p><figure class="mt mu mv mw gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nj"><img src="../Images/c8fb9c60be7b6352512013870e3c59fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LRiSaZNIaNdZXWHWf9PkSw.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">我们创作的木桩事件正在加纳切展出</figcaption></figure><figure class="mt mu mv mw gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nk"><img src="../Images/afeb719b1626ddba5e2a6cba84d25a1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tv_5dFtsmMlaKz8QtuWr7w.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">关于我们的赌注事件的细节</figcaption></figure><h2 id="a8a6" class="lu lv it bd lw lx ly dn lz ma mb dp mc ks md me mf kw mg mh mi la mj mk ml mm bi translated">奖励利益相关者并允许退出</h2><p id="bb1f" class="pw-post-body-paragraph kh ki it kj b kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la mr lc ld le im bi translated">既然我们的合同允许入股，是时候开始实施某种入股奖励制度了。</p><p id="a505" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">让我们添加一个函数，该函数允许我们在<strong class="kj iu"> contracts/DevToken.sol </strong>中提取赌注。该函数必须验证我们提取的金额没有超过我们下注的金额，并且它应该将下注的令牌返回到所有者的地址。</p><p id="c605" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">我将它命名为withdrawStake，它将是一个公共函数，因为我们希望允许从智能合约外部调用它。这里就不解释细节了，因为基本上就是一个Stake的翻版但是反过来了。</p><figure class="mt mu mv mw gt ju"><div class="bz fp l di"><div class="mx my l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">dev token——withdraw stake将收回股份并铸造新的代币</figcaption></figure><p id="2c59" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">withdrawStake调用了<strong class="kj iu">内部方法_withdrawStake </strong>，所以让我们跳到<strong class="kj iu"> contracts/Stakeable.sol </strong>并创建它。</p><p id="e456" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">进行并实施一个奖励系统，根据赌注的持续时间增加用户的奖励。由于持续时间不同，用户的每一笔赌注都会得到不同的回报，我认为这很公平。</p><p id="74b1" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">我们将实施一个奖励系统，将奖励用户每小时0.01%的赌注。因此，让我们首先创建一个包含我们的报酬率的变量。请注意，通常在编程中，我会乘以0.01，但由于我们不允许小数，我们需要使用反转的数学选项和除法。0.01的反义词是除以1000。</p><p id="7b33" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">用户将获得奖励，每小时的股份一直存在，我们会给他们每小时0.1%的奖励。让我们在文件的顶部创建一个变量，这样我们就可以控制报酬率。</p><figure class="mt mu mv mw gt ju"><div class="bz fp l di"><div class="mx my l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">可下注——奖励率设定为0.1%</figcaption></figure><p id="70c1" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">我们将首先创建一个名为<strong class="kj iu"> calculateStakeReward的必要函数。</strong>该函数的主要目的是计算风险承担者因其努力而应获得的报酬。<strong class="kj iu">计算赌注回报</strong>将接受赌注，并根据赌注生效的时间计算其有权获得的回报。该函数将是<strong class="kj iu">内部的</strong>，即只允许从契约内部访问。它也将有<strong class="kj iu">视图</strong>修改器，因为它不会以任何方式影响状态。</p><p id="050b" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">该算法将如下</p><ul class=""><li id="b85e" class="lf lg it kj b kk kl ko kp ks lh kw li la lj le nl ll lm ln bi translated">通过block.timestamp计算持续时间—赌注的时间，这将返回秒</li><li id="1a31" class="lf lg it kj b kk lp ko lq ks lr kw ls la lt le nl ll lm ln bi translated">除以1小时(3600秒的坚固性内部变量)</li><li id="e66b" class="lf lg it kj b kk lp ko lq ks lr kw ls la lt le nl ll lm ln bi translated">乘以赌注金额</li><li id="39eb" class="lf lg it kj b kk lp ko lq ks lr kw ls la lt le nl ll lm ln bi translated">除以每小时报酬率。</li></ul><figure class="mt mu mv mw gt ju"><div class="bz fp l di"><div class="mx my l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">stakeable . sol——根据小时费率计算奖励</figcaption></figure><p id="7c7b" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">既然我们已经能够计算赌注的回报，让我们实现_withdrawStake。该功能将查找一个利益相关者，根据发送者，要求提款金额少于赌注金额。<br/>任何空的木桩也会被<strong class="kj iu">删除</strong>。删除是清理区块链资源的一种方式，也是很重要的，因为你实际上将为释放的存储退还天然气。<strong class="kj iu"> Delete </strong>接受具有指定索引的数组，并使该给定索引中的所有值无效。<strong class="kj iu">它没有删除索引，这很重要，因为我们使用数组的顺序作为ID。</strong>删除很重要，不仅是为了清理垃圾，也是为了退一些气。</p><p id="7266" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">这里有一点对我们来说是新的，那就是<strong class="kj iu">内存</strong>关键字。这意味着我们将暂时存储数据，在这里阅读更多信息<a class="ae lo" href="https://www.geeksforgeeks.org/storage-vs-memory-in-solidity/" rel="noopener ugc nofollow" target="_blank">。</a></p><figure class="mt mu mv mw gt ju"><div class="bz fp l di"><div class="mx my l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">可下注——如果没有归零，撤回赌注会重置计时器</figcaption></figure><p id="342c" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">我们现在将在DevToken中添加一个withdrawStake来公开这个函数，因为它有一个内部修饰符。可赌注契约不知道什么契约将继承它，它能做的最好的事情是返回奖励金额，继承人将负责实际铸造这些代币。这个函数应该可以从区块链外部调用，并且有一个<strong class="kj iu"> public </strong>修饰符。</p><figure class="mt mu mv mw gt ju"><div class="bz fp l di"><div class="mx my l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">DevToken — withdrawStake调用内部函数并生成令牌</figcaption></figure><p id="6c01" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">我们将很快测试我们的新功能，但为了使它更容易，我们将添加一种方法来检查帐户是否有任何股份。</p><p id="83c7" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">让我们创建一个新的结构，它总结了一个帐户上的所有赌注。该结构将进入可堆栈协定内部。</p><figure class="mt mu mv mw gt ju"><div class="bz fp l di"><div class="mx my l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">可下注——下注摘要保存有关帐户赌注的数据</figcaption></figure><p id="dc75" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">在我们开始总结之前，让我们也更新一下Stake，以保存关于可以获得多大奖励的数据。</p><figure class="mt mu mv mw gt ju"><div class="bz fp l di"><div class="mx my l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">可下注——增加了可下注字段，显示有更大的奖励</figcaption></figure><p id="947f" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">因为我们修改了Stake结构，所以它的所有新初始化都必须改变，幸运的是我们在_stake函数中只有on。只需向新的Stake添加一个输入参数，在我们的例子中，claimable应该从0开始。</p><figure class="mt mu mv mw gt ju"><div class="bz fp l di"><div class="mx my l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">Stakable — _stake函数初始化一个stake，将0加到输入中</figcaption></figure><p id="e436" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">现在让我们创建一个名为<strong class="kj iu"> hasStake的函数。</strong>它将有两个修饰符，<br/> <strong class="kj iu"> public </strong>，因为它允许在区块链之外执行，以及<strong class="kj iu"> view </strong>，因为它不修改区块链中的值。该函数将返回存储在<strong class="kj iu">内存中的StakingSummary结构。</strong>内存是仅在函数运行时可用的可靠存储类型，是一种存储数据的廉价方式。</p><p id="640e" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">我们的函数将获取帐户的所有赌注，并遍历所有赌注，计算它们当前的奖励。</p><figure class="mt mu mv mw gt ju"><div class="bz fp l di"><div class="mx my l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">可下注—允许帐户查看他们的赌注</figcaption></figure><p id="a7f9" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">现在是我们测试取款并确保奖励的计算是正确的时候了。</p><h2 id="3a33" class="lu lv it bd lw lx ly dn lz ma mb dp mc ks md me mf kw mg mh mi la mj mk ml mm bi translated">块菌试验期间的快进时间</h2><p id="db38" class="pw-post-body-paragraph kh ki it kj b kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la mr lc ld le im bi translated">现在我们已经有了函数并需要测试它们，我们将注意到一个更棘手的部分。我们不希望测试等待一个小时才注意到奖励是否正确支付(或者至少我不希望如此)。我们需要某种方式来实际快进区块链的时间，谢天谢地，我们可以使用一些。</p><p id="f276" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">我们将借用安迪·瓦特的一个技巧，他写了一篇关于如何在松露测试中快进加纳切区块链的文章。简而言之，ganache接受允许我们更改时间的呼叫。</p><p id="7741" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">其中一个是<strong class="kj iu"> evm_increaseTime </strong>，它增加了区块时间，但是时间不会改变，直到区块被开采。因此还必须调用<strong class="kj iu"> evm_mine </strong>。</p><p id="2b21" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">在测试文件夹中，创建一个名为<strong class="kj iu"> helpers的文件夹。Andy有几个函数使得这些动作在测试中变得非常简单。创建一个名为<strong class="kj iu">trufflestesthelpers . js</strong>的文件，并将以下要点复制到其中。记得阅读这个文件，这样你就能在一定程度上理解正在发生的事情，(尽管，在第一阶段它可能不太重要)，最后，一定要阅读安迪的文章。</strong></p><figure class="mt mu mv mw gt ju"><div class="bz fp l di"><div class="mx my l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">Andy watt的一个小助手函数，我们可以在其中快进块时间。</figcaption></figure><p id="a944" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">首先在文件<strong class="kj iu">顶部的<strong class="kj iu"> Staking.js </strong>中导入助手函数。</strong></p><pre class="mt mu mv mw gt mz na nb nc aw nd bi"><span id="98d0" class="lu lv it na b gy ne nf l ng nh">const helper = require("./helpers/truffleTestHelpers");</span></pre><h2 id="2ecd" class="lu lv it bd lw lx ly dn lz ma mb dp mc ks md me mf kw mg mh mi la mj mk ml mm bi translated">单元测试锁定和撤销</h2><p id="d41e" class="pw-post-body-paragraph kh ki it kj b kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la mr lc ld le im bi translated">我们终于准备好实现对stake功能和撤销的单元测试了。</p><p id="159f" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">我们将在Stakeable.js中工作，但是我们将逐个测试，因为它是一大块代码。</p><p id="60a2" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">第一个测试很简单，只是检查我们不能撤回超过最初的赌注。</p><figure class="mt mu mv mw gt ju"><div class="bz fp l di"><div class="mx my l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">Stakable.js —确保撤回不超过原始股份的单元测试</figcaption></figure><p id="8725" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">下一个是单元测试，以确保撤销有效。我们将看看退出是否真的如预期的那样有效，我们将从一个赌注中退出50个代币。我们还将确保使用我们创建的新摘要更新金额。请记住，stake是在这个测试之前的单元测试中执行的，这不是最好的解决方案，请尝试实现一个新的Stake并使用它。</p><figure class="mt mu mv mw gt ju"><div class="bz fp l di"><div class="mx my l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">Stakeable.js —从赌注中提取代币。</figcaption></figure><p id="e5ba" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">现在，让我们添加一个测试，再次从赌注中提取50个代币，(最初的赌注金额是100)。这意味着木桩应该被移走，因为它现在是空的。检查我们将核实股份中的相关账户是否设置为空账户，实际情况是:</p><blockquote class="nm nn no"><p id="dcf1" class="kh ki ms kj b kk kl km kn ko kp kq kr np kt ku kv nq kx ky kz nr lb lc ld le im bi translated">0x 000000000000000000000000000000000000000000</p></blockquote><figure class="mt mu mv mw gt ju"><div class="bz fp l di"><div class="mx my l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">Stakeable.js —移除木桩应该有效</figcaption></figure><p id="c63f" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">现在是时候做一些更高级的测试了。我们将需要利用我们之前创建的助手来快进时间。这将用于确保奖励计算正确。</p><figure class="mt mu mv mw gt ju"><div class="bz fp l di"><div class="mx my l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">Stakeable.js —通过快进时间计算奖励</figcaption></figure><p id="d712" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">最终测试将用于确保利益相关者在提取金额时得到正确的回报，并且在每次提取后，赌注将重置可索赔计数器。</p><figure class="mt mu mv mw gt ju"><div class="bz fp l di"><div class="mx my l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">stakeable . js——验证奖励是否正确发放</figcaption></figure><p id="2a7e" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">确保触发测试，以便您知道它们正在工作。</p><pre class="mt mu mv mw gt mz na nb nc aw nd bi"><span id="eaa6" class="lu lv it na b gy ne nf l ng nh">truffle test</span></pre></div><div class="ab cl ns nt hx nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="im in io ip iq"><h2 id="4210" class="lu lv it bd lw lx ly dn lz ma mb dp mc ks md me mf kw mg mh mi la mj mk ml mm bi translated">第二条的结论</h2><p id="0b7c" class="pw-post-body-paragraph kh ki it kj b kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la mr lc ld le im bi translated">第二篇文章到此结束。本系列还有两篇文章，您可以在我的<a class="ae lo" href="https://github.com/percybolmer/DevToken/tree/stakeable" rel="noopener ugc nofollow" target="_blank">库的stakeable分支中找到完整的代码。</a></p><p id="818b" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">我们已经介绍了以下内容</p><ul class=""><li id="6d2f" class="lf lg it kj b kk kl ko kp ks lh kw li la lj le nl ll lm ln bi translated">什么是打桩</li><li id="a598" class="lf lg it kj b kk lp ko lq ks lr kw ls la lt le nl ll lm ln bi translated">如何实现简单的锁定</li><li id="36d6" class="lf lg it kj b kk lp ko lq ks lr kw ls la lt le nl ll lm ln bi translated">奖励赌注</li><li id="9424" class="lf lg it kj b kk lp ko lq ks lr kw ls la lt le nl ll lm ln bi translated">为我们的代码编写单元测试</li></ul><p id="d565" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">《T2》的第三篇文章将讲述在web应用中使用<strong class="kj iu">智能合同。</strong></p><p id="794f" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">我希望你喜欢它，如果有任何问题，请随时联系我们。</p></div></div>    
</body>
</html>