<html>
<head>
<title>Setting up webpack for SSR with Vue — SSR with Vue and webpack from scratch (2/3)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为带Vue的SSR设置webpack—带Vue的SSR和web pack从头开始(2/3)</h1>
<blockquote>原文：<a href="https://itnext.io/setting-up-webpack-for-ssr-with-vue-b6ff9125d359?source=collection_archive---------8-----------------------#2018-06-05">https://itnext.io/setting-up-webpack-for-ssr-with-vue-b6ff9125d359?source=collection_archive---------8-----------------------#2018-06-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/9d1168ed9abe7d1c13f77e4cfc8cce1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DFwa2s9rNO04SL2xzGm-MQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">Vue + Webpack |图片来自npmjs</figcaption></figure><p id="eecd" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在本文中，我将继续我上一篇文章中的<a class="ae la" href="https://medium.com/@lachlanmiller_52885/webpack-config-from-scratch-for-vue-a422672fc04c" rel="noopener">工作，在那里我为Vue从头开始设置了一个webpack配置。我现在将添加对服务器端渲染的支持，用<code class="fe lb lc ld le b">vue-server-renderer</code>。</a></p><p id="9b2f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">服务器端呈现是服务器使用Node.js动态构建应用程序的HTML，然后在响应中发回新呈现的HTML。这与客户端呈现相反，在客户端呈现中，webpack捆绑的JavaScript对于客户端是原样的，在客户端由浏览器JavaScript引擎处理。这两种方法都有好处，本文不会讨论。</p><p id="c8bb" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">源代码可以在这里找到<a class="ae la" href="https://github.com/lmiller1990/webpack-simple-vue/tree/add_server_rendering" rel="noopener ugc nofollow" target="_blank">。</a></p></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><figure class="ln lo lp lq gt jr gh gi paragraph-image"><a href="http://vuejs-course.com/"><div class="gh gi lm"><img src="../Images/8860e8ef1f39967845929ca6a9e3821a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g_RGGAoqizZjbVse93Z4TQ.png"/></div></a><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">来看看我的<a class="ae la" href="https://vuejs-course.com/" rel="noopener ugc nofollow" target="_blank"> Vue.js 3课程</a>！我们涵盖了组合API、类型脚本、单元测试、Vuex和Vue路由器。</figcaption></figure></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><h2 id="a3f8" class="lr ls iq bd lt lu lv dn lw lx ly dp lz kn ma mb mc kr md me mf kv mg mh mi mj bi translated">拆分<code class="fe lb lc ld le b">webpack.config.js</code></h2><p id="badd" class="pw-post-body-paragraph kc kd iq ke b kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz ij bi translated">根据应用程序是呈现在服务器上还是客户端上，需要不同的webpack配置。我们希望两者都支持——对于开发来说，<code class="fe lb lc ld le b">webpack-dev-server</code>是一个强大的工具，它将处理和渲染委托给客户端。在生产中，我们将在服务器上渲染。许多webpack配置可以共享，比如<code class="fe lb lc ld le b">module</code>，我们在这里声明了<code class="fe lb lc ld le b">loaders</code>。为非唯一webpack设置创建一个文件夹和两个新文件:</p><figure class="ln lo lp lq gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="e72f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">当前<code class="fe lb lc ld le b">webpack.config.js</code>包含四个属性:</p><ol class=""><li id="685c" class="mr ms iq ke b kf kg kj kk kn mt kr mu kv mv kz mw mx my mz bi translated">进入</li><li id="a174" class="mr ms iq ke b kf na kj nb kn nc kr nd kv ne kz mw mx my mz bi translated">组件</li><li id="6905" class="mr ms iq ke b kf na kj nb kn nc kr nd kv ne kz mw mx my mz bi translated">插件</li><li id="19d7" class="mr ms iq ke b kf na kj nb kn nc kr nd kv ne kz mw mx my mz bi translated">开发服务器</li></ol><p id="1fbc" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe lb lc ld le b">module</code>包含<code class="fe lb lc ld le b">.vue</code>文件的加载规则，这是服务器和客户端渲染都需要的。其余的属性在客户端渲染中将是唯一的，因此将它们移动到<code class="fe lb lc ld le b">config/client.js</code>:</p><figure class="ln lo lp lq gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="8234" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在<code class="fe lb lc ld le b">config/server.js</code>中添加一个最小设置:</p><figure class="ln lo lp lq gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="93cc" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">同样，将<code class="fe lb lc ld le b">template.html</code>移入<code class="fe lb lc ld le b">config</code>:</p><figure class="ln lo lp lq gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="164c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">并更新<code class="fe lb lc ld le b">webpack.config.js</code>:</p><pre class="ln lo lp lq gt nf le ng nh aw ni bi"><span id="2b7e" class="lr ls iq le b gy nj nk l nl nm">const server = require("./config/server")<br/>const client = require("./config/client")</span><span id="f455" class="lr ls iq le b gy nn nk l nl nm">module.exports = {<br/>  // ...<br/>  plugins: client.plugins.concat(VueLoaderPlugin())</span><span id="abed" class="lr ls iq le b gy nn nk l nl nm">  // ... <br/>}</span></pre><p id="9447" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">应该还在工作。</p><h1 id="9759" class="no ls iq bd lt np nq nr lw ns nt nu lz nv nw nx mc ny nz oa mf ob oc od mi oe bi translated">添加<code class="fe lb lc ld le b">webpack-merge</code></h1><p id="a86b" class="pw-post-body-paragraph kc kd iq ke b kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz ij bi translated">现在<code class="fe lb lc ld le b">webpack.config.js</code>有些重复。我们必须通过键入以下内容来加入基本配置和客户端</p><figure class="ln lo lp lq gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="e938" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">当我们添加一些服务器配置时，它将看起来像这样:</p><figure class="ln lo lp lq gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="f417" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这很快就变得令人困惑。有一个更好的方法:<code class="fe lb lc ld le b">webpack-merge</code>，它将为我们处理合并。</p><figure class="ln lo lp lq gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="8325" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在使用<code class="fe lb lc ld le b">webpack-merge</code>来清理<code class="fe lb lc ld le b">webpack.config.js</code>:</p><figure class="ln lo lp lq gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="ec3c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在<code class="fe lb lc ld le b">module.exports</code>返回一个函数。Webpack检查从<code class="fe lb lc ld le b">webpack,config.js</code>导出的函数是否存在，如果存在，用<code class="fe lb lc ld le b">mode</code>参数调用它。奇怪的是，<code class="fe lb lc ld le b">mode</code>对应于<code class="fe lb lc ld le b">--env</code>参数，而不是<code class="fe lb lc ld le b">--mode</code>，所以更新<code class="fe lb lc ld le b">package.json</code>中的<code class="fe lb lc ld le b">scripts</code>部分:</p><figure class="ln lo lp lq gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="a987" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe lb lc ld le b">npm run dev</code>应该还能正常工作。如果您访问<code class="fe lb lc ld le b">localhost:8080</code>，检查页面的源代码(不使用devtools，实际的页面源代码)，您应该会看到:</p><figure class="ln lo lp lq gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="96e2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">注意<code class="fe lb lc ld le b">msg</code>，<code class="fe lb lc ld le b">Hello</code>没有出现在这里——那是因为它是在<em class="of">客户端</em>上渲染的。在服务器上呈现时，我们将看到不同的页面源。</p><h1 id="b810" class="no ls iq bd lt np nq nr lw ns nt nu lz nv nw nx mc ny nz oa mf ob oc od mi oe bi translated">服务器端<code class="fe lb lc ld le b">entry</code></h1><p id="d910" class="pw-post-body-paragraph kc kd iq ke b kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz ij bi translated">服务器呈现包将使用不同的入口点。为它创建一个文件:</p><figure class="ln lo lp lq gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="55f0" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这个函数将创建我们想要渲染的Vue应用程序。添加以下代码:</p><figure class="ln lo lp lq gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="c7f4" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">眼熟吗？类似于<code class="fe lb lc ld le b">src/index.js</code>中的代码。看一看:</p><figure class="ln lo lp lq gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="7abc" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">区别是<code class="fe lb lc ld le b">document.addEventListener...</code>。Node.js中没有其他Web APIs，这就是为什么我们需要两个不同的呈现器。重构<code class="fe lb lc ld le b">src/index.js</code>:</p><figure class="ln lo lp lq gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="c7b5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">最后，更新<code class="fe lb lc ld le b">config/server.js</code>以使用<code class="fe lb lc ld le b">create-app</code>:</p><pre class="ln lo lp lq gt nf le ng nh aw ni bi"><span id="f775" class="lr ls iq le b gy nj nk l nl nm">// ...<br/>module.exports = {<br/>  entry: "../src/create-app"<br/>}</span></pre><p id="fb82" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">让我们用<code class="fe lb lc ld le b">npm run build</code>尝试新的生产配置。</p><figure class="ln lo lp lq gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="c0f5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">看起来不错。让我们看看是否可以在Node.js环境中使用该模块:</p><figure class="ln lo lp lq gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="3520" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们有麻烦了。</p><h1 id="a904" class="no ls iq bd lt np nq nr lw ns nt nu lz nv nw nx mc ny nz oa mf ob oc od mi oe bi translated"><code class="fe lb lc ld le b">output.library</code>和<code class="fe lb lc ld le b">output.libraryTarget</code></h1><p id="d25a" class="pw-post-body-paragraph kc kd iq ke b kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz ij bi translated">我们需要在<code class="fe lb lc ld le b">config/server.js</code>中设置一些<code class="fe lb lc ld le b">output</code>选项。<code class="fe lb lc ld le b">output</code>的文档在这里是<a class="ae la" href="https://webpack.js.org/configuration/output/" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="bdfa" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们对<code class="fe lb lc ld le b">library</code>和<code class="fe lb lc ld le b">libraryTarget</code>感兴趣。默认值为:</p><figure class="ln lo lp lq gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="9ed4" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe lb lc ld le b">var</code>意味着webpack会将我们的导出分配给<code class="fe lb lc ld le b">var</code>，这些导出被附加到<code class="fe lb lc ld le b">window</code>对象上，以便在浏览器(UMD)中使用。然而，因为<code class="fe lb lc ld le b">library</code>没有定义，所以webpack什么也不做。虽然变量没有被赋值，但是在<code class="fe lb lc ld le b">src/index.js</code>中我们会这样做:</p><figure class="ln lo lp lq gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="14e4" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">所以Vue应用还是挂载的。要了解这些选项及其作用，请运行</p><figure class="ln lo lp lq gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="bcbc" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">并尝试添加以下内容:</p><figure class="ln lo lp lq gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="342f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">并运行<code class="fe lb lc ld le b">npm run build</code>。让我们比较一下这两者:</p><figure class="ln lo lp lq gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="e688" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在我们的包被分配给一个名为<code class="fe lb lc ld le b">Bundle</code>的变量。如果需要，点<code class="fe lb lc ld le b">cd dist &amp;&amp; python -m SimpleHTTPServer</code>，然后在浏览器控制台中查看:</p><figure class="ln lo lp lq gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="5a6a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们希望在Node.js环境中执行。我们我们需要瞄准<code class="fe lb lc ld le b">commonjs2</code>。更新<code class="fe lb lc ld le b">config/server.js</code>:</p><figure class="ln lo lp lq gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="57aa" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">并运行<code class="fe lb lc ld le b">npm run build</code>。让我们再次用<code class="fe lb lc ld le b">diff dist/main.js dist/main_2.js</code>比较输出</p><figure class="ln lo lp lq gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="91f7" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">看起来不错！现在我们有了<code class="fe lb lc ld le b">module.exports</code>。我们可以使用节点:</p><figure class="ln lo lp lq gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="5802" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">还有其他东西可以传递给<code class="fe lb lc ld le b">library</code>和<code class="fe lb lc ld le b">libraryTarget</code>——在<a class="ae la" href="https://webpack.js.org/configuration/output/" rel="noopener ugc nofollow" target="_blank">文档</a>中找到更多信息。</p><h1 id="8f62" class="no ls iq bd lt np nq nr lw ns nt nu lz nv nw nx mc ny nz oa mf ob oc od mi oe bi translated">添加服务器(快速)</h1><p id="3eed" class="pw-post-body-paragraph kc kd iq ke b kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz ij bi translated">既然我们有了在服务器上创建Vue应用程序的方法，我们需要以某种方式服务它。要了解这一点，最简单的方法是使用express服务器。我个人更喜欢Rails，并将在以后的文章中深入探讨。</p><p id="f285" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">反正加上<code class="fe lb lc ld le b">express</code>，和<code class="fe lb lc ld le b">vue-server-renderer</code></p><figure class="ln lo lp lq gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="ece3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">用<code class="fe lb lc ld le b">touch src/server.js</code>为服务器代码创建一个文件。</p><figure class="ln lo lp lq gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="5f65" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这里有两个有趣的部分:</p><figure class="ln lo lp lq gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="97ee" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">它实例化服务器呈现器实例；</p><figure class="ln lo lp lq gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="6e8a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">它获取我们的应用程序，对其进行渲染，并以字符串形式返回标记。剩下的工作就是向用户提供标记。更多关于Vue服务器渲染器的信息在<a class="ae la" href="https://ssr.vuejs.org/guide/#rendering-a-vue-instance" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><p id="fed5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们可以通过跑步来尝试:</p><figure class="ln lo lp lq gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="3d47" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果一切正常，你现在可以访问<code class="fe lb lc ld le b">localhost:8000</code>了，你应该会看到同样的问候信息。但是，使用devtools检查元素会显示:</p><figure class="ln lo lp lq gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="0b98" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">指示它是在服务器上呈现的。让我们比较一下页面源代码和客户端呈现的源代码，如前面所示:</p><h1 id="0779" class="no ls iq bd lt np nq nr lw ns nt nu lz nv nw nx mc ny nz oa mf ob oc od mi oe bi translated">客户端渲染:</h1><figure class="ln lo lp lq gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><h1 id="8dbb" class="no ls iq bd lt np nq nr lw ns nt nu lz nv nw nx mc ny nz oa mf ob oc od mi oe bi translated">服务器渲染:</h1><figure class="ln lo lp lq gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="e96d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">通知<code class="fe lb lc ld le b">&lt;div app&gt;</code>哪里都没显示？当我们使用服务器渲染器生成标记时，它被替换，因此所提供的只是实际的标记。我们将在未来添加一个正确的<code class="fe lb lc ld le b">html</code>模板供服务器端渲染器使用。</p><h1 id="3731" class="no ls iq bd lt np nq nr lw ns nt nu lz nv nw nx mc ny nz oa mf ob oc od mi oe bi translated">结论</h1><p id="0c1a" class="pw-post-body-paragraph kc kd iq ke b kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz ij bi translated">在本文中，我们介绍了:</p><ul class=""><li id="f356" class="mr ms iq ke b kf kg kj kk kn mt kr mu kv mv kz og mx my mz bi translated">webpack可以针对的不同环境</li><li id="4126" class="mr ms iq ke b kf na kj nb kn nc kr nd kv ne kz og mx my mz bi translated">如何使用<code class="fe lb lc ld le b">webpack-merge</code></li><li id="fb1f" class="mr ms iq ke b kf na kj nb kn nc kr nd kv ne kz og mx my mz bi translated">如何使用<code class="fe lb lc ld le b">library</code>和<code class="fe lb lc ld le b">libraryTarget</code></li><li id="2466" class="mr ms iq ke b kf na kj nb kn nc kr nd kv ne kz og mx my mz bi translated">在服务器和客户端之间重构和共享代码</li></ul><h1 id="6d53" class="no ls iq bd lt np nq nr lw ns nt nu lz nv nw nx mc ny nz oa mf ob oc od mi oe bi translated">改进</h1><p id="1c93" class="pw-post-body-paragraph kc kd iq ke b kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz ij bi translated">还有许多改进，我们将在未来进行介绍，例如:</p><ul class=""><li id="bf3d" class="mr ms iq ke b kf kg kj kk kn mt kr mu kv mv kz og mx my mz bi translated">在服务器上水合应用程序(使用一些动态数据如用户id的服务器渲染)</li><li id="cede" class="mr ms iq ke b kf na kj nb kn nc kr nd kv ne kz og mx my mz bi translated">路由(客户端和服务器)</li><li id="564d" class="mr ms iq ke b kf na kj nb kn nc kr nd kv ne kz og mx my mz bi translated">使用ES6语法，像Node.js中的<code class="fe lb lc ld le b">import</code>和<code class="fe lb lc ld le b">export</code>用babel</li></ul><p id="4b39" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">源代码可以在<a class="ae la" href="https://github.com/lmiller1990/webpack-simple-vue/tree/add_server_rendering" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><p id="52d7" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="of">原载于</em> <a class="ae la" href="https://lmiller1990.github.io/electic/posts/server_side_rendering_with_vue.html" rel="noopener ugc nofollow" target="_blank"> <em class="of">拉克伦·米勒的个人博客</em> </a> <em class="of">。</em></p></div></div>    
</body>
</html>