<html>
<head>
<title>ES generators for making application side effects</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用于产生应用程序副作用的ES生成器</h1>
<blockquote>原文：<a href="https://itnext.io/es-generators-for-making-application-side-effects-b0a0a55ca87f?source=collection_archive---------2-----------------------#2017-09-25">https://itnext.io/es-generators-for-making-application-side-effects-b0a0a55ca87f?source=collection_archive---------2-----------------------#2017-09-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/8aa4224d79b0806a9deb3618c5e99739.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mWDKAOlJVdWdi9ATlrimvw.png"/></div></div></figure><p id="3e7f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">发电机简介</strong></p><p id="4ae1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">生成器是一种新型的函数，有一天会出现在ES标准中。生成器与简单的函数非常相似，但有一些额外的特性:它们的执行可以被挂起，它们可以将执行的中间结果传递给外部环境，您可以将一些外部结果传递给内部，或者事件抛出一些错误，您的函数将继续处理这样的结果或错误。</p><p id="cf05" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了创建新的生成器，我们使用了新的函数生成器语法<strong class="ka ir"> function*。当你第一次运行这样的函数时，它不会立即执行它的主体，而只是返回生成器的具体实例。创建语法如下所示</strong></p><figure class="kw kx ky kz gt jr"><div class="bz fp l di"><div class="la lb l"/></div></figure><p id="cf0f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">创建生成器后，它会保持初始状态。使用发电机的关键方法是<code class="fe lc ld le lf b">.next</code>启动发电机，并继续直到遇到第一个<code class="fe lc ld le lf b">yield</code>操作员。此时，生成器暂停其状态，并返回定义的值，该值在向外部函数范围让步后保持不变。在我们的示例中，我们只是创建新的生成器，并尝试获得第一个产出值:</p><figure class="kw kx ky kz gt jr"><div class="bz fp l di"><div class="la lb l"/></div></figure><p id="9ed4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们的例子中,<code class="fe lc ld le lf b">firstNumber</code>得到<code class="fe lc ld le lf b">10</code>,之后生成器暂停执行，直到我们下次使用<code class="fe lc ld le lf b">numbers.next()</code>。接下来的两次执行也是如此，我们得到值<code class="fe lc ld le lf b">20</code>和<code class="fe lc ld le lf b">30</code>。</p><p id="26b6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是问题来了，<strong class="ka ir">什么时候停止执行</strong>？是否有一些标志来表示生成器不再需要返回什么？是的。如你所见，每次它都返回类似于<code class="fe lc ld le lf b">{value: ..., done: ...}</code>的对象。这就是我们的答案。最后一次执行将看起来像:</p><figure class="kw kx ky kz gt jr"><div class="bz fp l di"><div class="la lb l"/></div></figure><p id="c689" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们需要的标志是返回对象的属性<code class="fe lc ld le lf b">done</code>，最后它的值是<code class="fe lc ld le lf b">true</code>。每个下一个<code class="fe lc ld le lf b">.next</code>调用都会引发错误并返回<code class="fe lc ld le lf b">{value: undefined, done: true}</code>对象。</p><p id="4ef3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">没有替代方法可以重置已创建生成器的状态。目前唯一的方法就是创建新的实例。</p><p id="92e4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">双向数据流和抛出错误</strong></p><p id="4855" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请考虑下一个例子</p><figure class="kw kx ky kz gt jr"><div class="bz fp l di"><div class="la lb l"/></div></figure><p id="64fe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在第一次<code class="fe lc ld le lf b">.next</code>调用时，我们用问题文本获取返回值，并将其保存在<code class="fe lc ld le lf b">questionText</code>变量下的外部作用域中。秒内<code class="fe lc ld le lf b">.next</code>叫我们通过<code class="fe lc ld le lf b">name</code>论证内情。该参数作为yield表达式的结果返回，并保存在生成器中他的<code class="fe lc ld le lf b">name</code>变量下，我们可以在代码中进一步移动并合成返回值<code class="fe lc ld le lf b">Hello ${name}</code>时操作他。</p><p id="2ab0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是你不仅可以传入值，还可以传入错误。你可以用<code class="fe lc ld le lf b">.throw</code>方法来做。这将使用<code class="fe lc ld le lf b">yield</code>在线调用发生器内部的异常。用里面的<code class="fe lc ld le lf b">try{} catch{}</code>块就可以轻松抓到(下面的例子(1))。在点(2)上，它应该调用示例中的<code class="fe lc ld le lf b">alert</code>。</p><figure class="kw kx ky kz gt jr"><div class="bz fp l di"><div class="la lb l"/></div></figure><p id="baa1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你没有在生成器中捕获它，异常将会在生成器外的堆栈中冒泡，并且如果在生成器外也没有捕获阻塞，就会用<code class="fe lc ld le lf b">unhandled exception</code>使你的脚本崩溃。</p><p id="72e7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">发电机迭代</strong></p><p id="c5f1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以轻松地迭代生成器，因为它们是可迭代的对象(方法<code class="fe lc ld le lf b">.next</code>对我们这么说)。</p><figure class="kw kx ky kz gt jr"><div class="bz fp l di"><div class="la lb l"/></div></figure><p id="ea2f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如你可能已经提到的，<code class="fe lc ld le lf b">for..of</code>结构并没有为我们返回最后一个值。这是一个特殊的情况，对于迭代，我们需要用<code class="fe lc ld le lf b">while</code>来使用自己的实现，或者对于最后一种情况，只需用<code class="fe lc ld le lf b">yield</code>替换<code class="fe lc ld le lf b">return</code>即可。</p><p id="7fc6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以轻松地创建无限的生成器，并将它们用作一些数据的生成器，就像您的生成器主体中的<code class="fe lc ld le lf b">while(true) { yield Math.random(); }</code>一样(但是要小心，并始终保持一些逻辑来停止您的迭代)。</p><p id="ea05" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">发电机的组成</strong></p><p id="8b38" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">每个生成器也可以包含子生成器。为此，包含了特殊的语法。让我们看一下例子:</p><figure class="kw kx ky kz gt jr"><div class="bz fp l di"><div class="la lb l"/></div></figure><p id="3594" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这种形式的<code class="fe lc ld le lf b">yield*</code>只能在另一个生成器内部使用，并将执行委托给内部生成器。即使内部生成器产生无限的数据链，这样的组合也能工作。</p><p id="0ebd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">副作用和带有生成器的平面异步代码</strong></p><p id="c286" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用生成器的主要领域之一是构建扁平的异步代码链。其主要概念是:</p><ul class=""><li id="01d1" class="lg lh iq ka b kb kc kf kg kj li kn lj kr lk kv ll lm ln lo bi translated"><code class="fe lc ld le lf b">yield</code>应该回报承诺；</li><li id="0f30" class="lg lh iq ka b kb lp kf lq kj lr kn ls kr lt kv ll lm ln lo bi translated">发电机应配备称为<strong class="ka ir">管理器</strong>的特殊外部功能。这位经理打电话给<code class="fe lc ld le lf b">generator.next</code>，每次都得到新的承诺。解析承诺后，值通过下一个<code class="fe lc ld le lf b">generator.next</code>调用传递回生成器。</li><li id="6b4a" class="lg lh iq ka b kb lp kf lq kj lr kn ls kr lt kv ll lm ln lo bi translated">使用<code class="fe lc ld le lf b">{done: true}</code>生成器的最后一个生成值，管理器将其作为整个逻辑链的结果值进行处理。</li></ul><p id="6f9b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们考虑下一个例子:</p><figure class="kw kx ky kz gt jr"><div class="bz fp l di"><div class="la lb l"/></div></figure><p id="f08e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里<code class="fe lc ld le lf b">asyncResult</code>将在所有产量迭代完成后收集一个结果值。但是让我们一步一步来:</p><ul class=""><li id="5636" class="lg lh iq ka b kb kc kf kg kj li kn lj kr lk kv ll lm ln lo bi translated"><code class="fe lc ld le lf b">manager</code>函数获取生成器实例作为参数</li><li id="d3ba" class="lg lh iq ka b kb lp kf lq kj lr kn ls kr lt kv ll lm ln lo bi translated">在管理器调用<code class="fe lc ld le lf b">.next</code>方法获得<code class="fe lc ld le lf b">currentOrganization</code>请求承诺之后，如果不是生成器中的最后一个产出，则<code class="fe lc ld le lf b">next.done !== true</code>管理器等待承诺解析</li><li id="6131" class="lg lh iq ka b kb lp kf lq kj lr kn ls kr lt kv ll lm ln lo bi translated">在promise解析后，它调用generator并将解析的数据作为第二个参数传递。该数据将被存储为yield返回值。</li><li id="1a87" class="lg lh iq ka b kb lp kf lq kj lr kn ls kr lt kv ll lm ln lo bi translated">生成器唤醒并继续运行其代码，直到下一个yield运算符。</li><li id="2eb0" class="lg lh iq ka b kb lp kf lq kj lr kn ls kr lt kv ll lm ln lo bi translated">最后一个调用将把<code class="fe lc ld le lf b">next.done === true</code>返回给manager，这是一个写<code class="fe lc ld le lf b">next.value</code>作为最终结果的标志。</li></ul><p id="e0dc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">后文字</strong></p><p id="ea12" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这种方法有助于有效地构建异步请求链，并有助于避免回调地狱和承诺嵌套地狱。</p><p id="3c4b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有一些图书馆在幕后使用这种方法。其中之一是<strong class="ka ir"> co. </strong>你可以在<a class="ae lu" href="https://github.com/tj/co" rel="noopener ugc nofollow" target="_blank">官方页面</a>上阅读更多关于实现的信息。</p><p id="cc9e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第二个库更适合那些使用redux单一商店概念解决方案的人。它被称为<strong class="ka ir">传奇</strong>。用于管理应用程序副作用的出色解决方案，更易于管理，执行效率更高，测试简单，更擅长处理故障。更多信息你可以从<a class="ae lu" href="https://github.com/redux-saga/redux-saga" rel="noopener ugc nofollow" target="_blank">官方页面</a>找到。</p></div></div>    
</body>
</html>