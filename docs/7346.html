<html>
<head>
<title>Async/Await — What Happens Under The Hood</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">异步/等待—幕后发生了什么</h1>
<blockquote>原文：<a href="https://itnext.io/async-await-what-happens-under-the-hood-eef1de0dd881?source=collection_archive---------0-----------------------#2022-08-29">https://itnext.io/async-await-what-happens-under-the-hood-eef1de0dd881?source=collection_archive---------0-----------------------#2022-08-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/51cc971ea34d846d43169a9fb1ccfc60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uC96CTurDHCuGSZMUM3-MQ.jpeg"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated"><a class="ae jd" href="https://br.freepik.com/fotos-gratis/mao-de-mecanico-verificando-e-consertando-um-carro-quebrado-na-garagem-de-servico_10521910.htm#query=car%20engine%20broken&amp;position=1&amp;from_view=search" rel="noopener ugc nofollow" target="_blank">Freepik上standret的图片</a></figcaption></figure><div class=""/><p id="cc40" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用Async/Await很简单，但是这两个关键字隐藏了很多东西。为了充分理解它是如何工作的，我们必须浏览一堆概念，其中一些有点模糊，但我希望能够揭示任务、线程和并发性背后的奥秘。拿起你的咖啡，跟我来。</p><h1 id="c934" class="lb lc jg bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><strong class="ak">并发不是并行</strong></h1><p id="cdd2" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">这两个主题经常被混淆，但它们是完全不同的，理解它们的区别对我们的主题是至关重要的。让我们来探究一下这些概念之间的区别。</p><p id="192f" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">想象一下，你有一个非常复杂的方程，可以分成两个小部分，你需要写一个程序来求解这个方程。因为方程可以分解，所以等待第1部分完成来触发第2部分的计算是没有意义的。在理想世界中，正确的做法应该是同时计算它们。但这只有在您拥有一个以上内核的处理器时才有可能，原因如下。</p><p id="e278" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">操作系统有我们所说的任务调度器。任务调度器的职责是为每个进程提供CPU时间。</p><p id="0602" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">进程是正在执行的程序的一个实例，每个进程被细分为线程。线程是将由调度器在给定时间执行的一组指令/代码。</p><p id="688b" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当时的处理器只有一个内核，但一切似乎都在同时运行，这怎么可能呢？问题是，任务调度器在分配时间方面非常有效，时间片非常非常短，所以看起来一切都是并行运行的，但事实并非如此，它只是以非常快的速度一个接一个地运行。</p><p id="392d" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好吧，我说每一片时间真的很短。如果我的指令集没有在这段时间内完成，会发生什么？</p><p id="719f" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">线程挂起，CPU时间给下一个。</p><p id="ce66" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当发生这种情况时，可能需要释放CPU缓存中分配的一些变量，以便为这个新线程的变量提供空间，这会导致开销。</p><p id="f7ac" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">进程越多，这个操作发生的次数就越多。这就是当你有很多程序在运行，而只有一个内核来处理所有事情时，计算机变慢的原因之一。</p><p id="df31" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通常用于管理所有这些事情的算法称为循环法，而让另一个线程执行的过程称为上下文切换。</p><p id="56b9" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">回到我们的计算，如果我们有一个单核处理器，即使我们将计算分成两个线程，正如我们看到的，它们仍然会按顺序执行。对于真正的并行，你需要有一个以上的内核，这样每个内核就可以同时独立地执行代码(真正的)。</p><p id="311e" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我解释了所有这些关于并行性的东西，以便弄清楚:<strong class="kf jh">并发性不同于并行性，</strong>它们可以一起使用，但远不是一回事。并行性是指在同一时间做多件事情，而并发性是指在别人做你正在等待的事情时，你在做别的事情。</p><p id="fa64" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们想象一下，我们有一台单核计算机，运行我们构建的C#程序，这个程序由一个带有简单UI的文本文件阅读器组成。</p><p id="5955" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们启动程序。当这种情况发生时，直到我们输入一些东西，程序是空闲的，因为我们没有执行任何东西，现在我们输入值。键入的动作需要代码活动来显示我们在输入字段中键入了什么，所以在那个线程中有代码正在执行。现在，我们单击打开文件，操作系统将查找该文件，并向我们提供需要解析并显示在屏幕上的内容(以字节为单位)。</p><p id="e18f" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">假设我们使用同步操作系统调用，我们将会得到类似下图的结果。</p><figure class="mf mg mh mi gt is gh gi paragraph-image"><div class="gh gi me"><img src="../Images/ebe74059c0b98c8ef030b31ac28dabc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1392/format:webp/1*JclXSmj4zzvQqYOgJpYHhQ.png"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">CPU不会等待您的处理完成，它将继续循环过程，但我们的线程不会处理任何其他事情，直到我们获得内容的返回。</figcaption></figure><p id="2aeb" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请注意，当操作系统从磁盘读取数据时，我们的线程仍在运行，但事实上，没有代码被执行，因为我们只是在等待操作系统返回内容。线程被锁定了，我们在这段CPU时间里什么也没做，不是很好吗？事实上，这是最糟糕的。我们的程序将对任何类型的输入(键盘或鼠标)完全没有反应，因为我们的线程正在等待响应，不能做任何其他事情。就像你看着等着水烧开，然后什么都不做，直到它发生。</p><p id="6cef" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们使用异步计算，我们将得到下图</p><figure class="mf mg mh mi gt is gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/f3520a20474eb6e20ccbb8b2e9a012cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1388/format:webp/1*apkJse6nSO6WbQCxYpioeQ.png"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">现在，我们的线程可以自由地处理其他事情，而不会得到操作系统的响应</figcaption></figure><p id="554b" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">事情是这样的:我们请求文件的内容，当操作系统正在寻找它时，我们释放负责调用的线程来做其他事情。当操作系统获得所有数据时，会调用一个回调，代码将继续执行，文本将显示出来。这种方法将使UI具有响应性，因为线程可以在等待操作系统响应的同时处理键盘输入或鼠标移动。</p><p id="af62" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们称之为异步是因为当我们等待某事发生时，我们可以做另一件事。每当我们执行一个不受cpu限制的进程时，使用异步编程是一个好主意。</p><p id="50a8" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们深入了解异步是如何工作的之前，让我们再多谈一点线程，更具体地说是线程池。</p><h1 id="67f3" class="lb lc jg bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><strong class="ak">线程池</strong></h1><p id="2ec8" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">一般来说，在. NET进程中，线程的数量与可用的处理器内核数量直接相关，简单的一对一关系。但是如果。NET认为系统需要更多的线程才能运行良好，它将自己创建更多的线程，这些线程将成为线程池的一部分。</p><p id="e313" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">ThreadPool是一个长期存在的线程集合，可用于执行任务。将这些线程放在长期集合中的原因是为了使重用这些线程成为可能。</p><p id="d6f7" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当属于一个线程的任务完成时，这个线程被再次放入线程池，以便在将来的执行中重用</p><p id="4e94" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">创建一个线程是一项计算开销很大的任务，它们也需要几兆的内存，所以大量的线程和少量的线程一样糟糕，你还记得上下文切换过程吗？大量的线程相当于大量的上下文切换。这就是为什么依赖知道如何调优这些东西的线程池引擎总是好的，而不是显式地创建许多线程并期望最好的结果。</p><p id="395b" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">考虑一个WebAPI，如果我们的web服务器只有两个内核，我们将有两个线程，但是如果我们有两个请求正在运行，并且第三个请求被触发，会发生什么呢？。NET会注意到我们的两个线程都很忙，并将创建另一个线程来处理请求。如果我们使用异步编程，这两个线程被完全阻塞的几率会低得多，因为最耗时的进程通常与I/O相关，并且I/O操作不再阻塞现有的线程。</p><p id="55b0" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你可能会说，现在大多数计算机都有很多内核，通过在这些内核之间分配处理任务，它们可以处理很重的负载。实际上，它们非常强大，但是最近，我们开始越来越多地使用一种几乎依赖于单核环境的技术:容器。容器往往是单核的，在这种情况下，拥有一个大小合适的线程池是必不可少的，这使得异步编程对于应用程序的良好运行至关重要。</p><p id="7e67" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们已经了解了线程和线程池，是时候了解任务了</p><h1 id="be50" class="lb lc jg bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><strong class="ak">任务</strong></h1><p id="d0ce" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">基本上，我们可以把任务看作是要执行的一项工作。</p><p id="2362" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">想象一下，我们有一个部门，你和你的一个朋友负责去档案室为管理档案室的人申请一个特定的文件。你有一个主管，他与那些客户交谈，满足需求，并把它交给你。</p><p id="aa74" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">客户1到了。你的主管与客户交谈，获得他们的要求，填写正式要求，当他看到你和你的朋友都在角落里时，他随机选择你们中的一个去档案室拿他需要的东西。</p><p id="faf4" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个场景中，我们有以下内容。</p><ul class=""><li id="3064" class="mk ml jg kf b kg kh kk kl ko mm ks mn kw mo la mp mq mr ms bi translated">客户端是一段要求一些数据(I/O)的代码</li><li id="7f26" class="mk ml jg kf b kg mt kk mu ko mv ks mw kw mx la mp mq mr ms bi translated">管理程序是线程池，它管理线程并分派要完成的工作(任务)。</li><li id="6bbe" class="mk ml jg kf b kg mt kk mu ko mv ks mw kw mx la mp mq mr ms bi translated">线索是你和你的朋友。你们是努力工作的人，是会完成既定任务的人。</li><li id="1457" class="mk ml jg kf b kg mt kk mu ko mv ks mw kw mx la mp mq mr ms bi translated">任务是将由线程(您)执行的一项工作。在这种情况下，去档案部门询问负责文件的人。</li></ul><p id="5ee4" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好的一面是，线程池可以接收一堆任务，当线程可用时，任务将被分派。如果线程池有很多任务未完成，可以创建一个新的工人来加入您的团队并提高性能，但只有在值得的情况下，雇佣(创建一个新线程)才是昂贵的:)</p><p id="8310" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当你从归档部门回来时，你不只是带着文档回来，你还带着你的任务需求回来。在这个需求中，您有一些数据，比如任务的ID及其状态。附加到这个需求的是这个任务的结果，在这种情况下，是一个文档(如果没有找到，则没有文档)。这就是为什么Task有一个泛型参数，它总是返回一个Task of something(如果你期望方法返回值的话)。对于您在存档部门的研究，这是一项任务<document>。</document></p><p id="cf79" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在你把文件还给你的客户了。你所要做的就是在等候室打电话给他，因为你的客户请求了一个异步任务，它不会呆在柜台等你去拿他的文件。很快，我们将发现如何打电话给你的客户来传达他们的要求，下一位，请。</p><p id="394a" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们也有了任务，是时候理解异步代码的工作流程了。</p><h1 id="900c" class="lb lc jg bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><strong class="ak">进入异步</strong></h1><p id="1dde" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">让我们看看你执行的任务的内容</p><figure class="mf mg mh mi gt is gh gi paragraph-image"><div class="gh gi my"><img src="../Images/3c4d6efdd234fe03c082be900b7906c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1026/format:webp/1*ccAR__km5dnqROywPcAF0g.png"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">异步方法的响应总是一项任务</figcaption></figure><p id="10eb" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如我们所看到的，该方法不返回字符串，而是返回一个带有可能包含内容的字符串的任务。</p><p id="91a9" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您使用VisualStudio Intellisense或其他类型的自动完成或提示功能，您将看到两个返回结果字符串的方法:<code class="fe mz na nb nc b">.Wait()</code>和<code class="fe mz na nb nc b">.Result()</code>。不要使用这些方法，它们是阻塞方法，您的代码不会异步运行。</p><p id="4058" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您以异步方式执行您的工作，而归档负责人在寻找文档，您可以返回并获取一个新任务，以交付给归档部门的另一个人。使用<code class="fe mz na nb nc b">.Wait()</code>或<code class="fe mz na nb nc b">.Result()</code>意味着你要等待这个人查看整个文档，直到他找到(或找不到)文档并把它还给你。</p><p id="6535" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们看看异步运行的方法。</p><figure class="mf mg mh mi gt is"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="d751" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mz na nb nc b">ContinueWith()</code>方法接收一个<code class="fe mz na nb nc b">Action&lt;Task&lt;string&gt;&gt;</code>，它将在任务完成时被触发，也就是说，当你带着正式的需求和文档回来时。</p><p id="b056" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是如果找不到文档会怎么样呢？在这种情况下，您的客户机将收到一个空响应，因为这段代码不处理异常。要处理它们，您必须手动实现它。</p><figure class="mf mg mh mi gt is"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="2407" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好吧！现在我们可以工作了，但是代码很糟糕。14行读一个文件？不会吧。</p><p id="b7c1" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这就是为什么C#团队在C# 5中实现了<code class="fe mz na nb nc b">async/await</code>关键字。在下面的例子中，我们不再只是打印结果，我们实际上得到它并返回它。使用旧的异步方式来制作这样的东西真的很难，因为我们会遇到很多同步问题。使用新的做事方式，我们的代码会变成这样。</p><figure class="mf mg mh mi gt is"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="3d29" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好多了，对吧？注意，方法签名从<code class="fe mz na nb nc b">public Task&lt;string&gt;</code>变成了<code class="fe mz na nb nc b">public <strong class="kf jh">async </strong>Task&lt;string&gt;</code>，现在在<code class="fe mz na nb nc b">return</code>语句后面有了<code class="fe mz na nb nc b">await</code>关键字。为什么会这样？因为现在引擎盖下发生了很多事情，这就是我们现在将要看到的。</p><h1 id="4985" class="lb lc jg bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">异步/等待—打开发动机罩</h1><p id="13cf" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">这里我将使用一个名为ILSpy的反编译器。这个工具可以读取IL代码，并使它对我们来说更具可读性。</p><p id="ce5b" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是这段代码的同步版本</p><p id="775c" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这</p><figure class="mf mg mh mi gt is"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="74d2" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">变成了这个</p><figure class="mf mg mh mi gt is"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="8511" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样的事情。没有区别。</p><p id="2541" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们来看看异步版本。</p><p id="77cc" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这</p><figure class="mf mg mh mi gt is"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="ade7" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">变成了这个</p><figure class="mf mg mh mi gt is"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="f901" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">哇！我们的方法变成了一个结构？是的，它变成了一个结构体，里面充满了东西。</p><p id="f040" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们深究一下，了解一下到底发生了什么</p><p id="05e0" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，注意你的结构实现了<code class="fe mz na nb nc b">IAsyncStateMachine</code>接口，该接口公开了两个方法<code class="fe mz na nb nc b">MoveNext()</code>和<code class="fe mz na nb nc b">SetStateMachine</code>。我们很快会谈到那些方法，但是首先，我们需要描述什么是状态机。</p><p id="2e78" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">状态机是一种表示逻辑电路及其状态的数学模型，它被事件静音，可以按一定的顺序从一种状态进入另一种状态。</p><p id="b1f5" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里的状态机用于设置任务的状态。</p><ul class=""><li id="b8d2" class="mk ml jg kf b kg kh kk kl ko mm ks mn kw mo la mp mq mr ms bi translated">第9行我们声明了一个TaskAwaiter <t>属性，该属性将保存一个表示等待任务结束的对象。<em class="nf">注意，这是在结构根级别声明的。</em></t></li><li id="4ce1" class="mk ml jg kf b kg mt kk mu ko mv ks mw kw mx la mp mq mr ms bi translated">第69行:我们创建一个新的状态机。</li><li id="149f" class="mk ml jg kf b kg mt kk mu ko mv ks mw kw mx la mp mq mr ms bi translated">第70行:表示返回任务的异步方法的构建器。还为结果提供了一个参数。请注意，泛型参数与您的任务结果类型相同。</li><li id="9fa4" class="mk ml jg kf b kg mt kk mu ko mv ks mw kw mx la mp mq mr ms bi translated">第71行:我们将它的状态属性设置为<code class="fe mz na nb nc b">-1 (Created)</code>。这个数字将决定任务是否完成</li><li id="341c" class="mk ml jg kf b kg mt kk mu ko mv ks mw kw mx la mp mq mr ms bi translated">第72行:这个<code class="fe mz na nb nc b">Start()</code>方法将调用我们的<code class="fe mz na nb nc b">MoveNext()</code>方法，该方法将实际运行我们的代码。</li><li id="0428" class="mk ml jg kf b kg mt kk mu ko mv ks mw kw mx la mp mq mr ms bi translated">第13行:将<code class="fe mz na nb nc b">num</code>变量设置为我们的状态机状态，这里是<code class="fe mz na nb nc b">-1 (Created)</code></li><li id="dea3" class="mk ml jg kf b kg mt kk mu ko mv ks mw kw mx la mp mq mr ms bi translated">第17行:我们声明一个TaskAwaiter <t>属性，该属性将保存一个对象，该对象表示等待任务结束。它和第9行是一样的，但是现在它是一个方法级变量</t></li><li id="9961" class="mk ml jg kf b kg mt kk mu ko mv ks mw kw mx la mp mq mr ms bi translated">第18行:我们检查<code class="fe mz na nb nc b">num</code>和<code class="fe mz na nb nc b">0 (Awaiting)</code>是否不同。开始时，它总是不同的，因为我们在第71行声明它为<code class="fe mz na nb nc b">-1 (Created)</code>。<code class="fe mz na nb nc b">if</code>语句中的这个块将触发我们的异步代码。</li><li id="742f" class="mk ml jg kf b kg mt kk mu ko mv ks mw kw mx la mp mq mr ms bi translated">第20行:我们触发了read file语句，并将其属性赋予了<code class="fe mz na nb nc b">awaiter</code>变量。</li><li id="c8c3" class="mk ml jg kf b kg mt kk mu ko mv ks mw kw mx la mp mq mr ms bi translated">第21行:我们立即检查任务是否已经完成。如果要做的工作执行得非常快，那么它将自动转到第35行，并将我们的结果变量设置为该任务的结果</li><li id="35ed" class="mk ml jg kf b kg mt kk mu ko mv ks mw kw mx la mp mq mr ms bi translated">第44行:我们用操作的结果设置状态机结果内容。</li><li id="1011" class="mk ml jg kf b kg mt kk mu ko mv ks mw kw mx la mp mq mr ms bi translated">第73行:获取构建器的内容并返回已执行的任务。如果事情执行得很快，我们在这里完成了我们的执行。</li><li id="8049" class="mk ml jg kf b kg mt kk mu ko mv ks mw kw mx la mp mq mr ms bi translated">第23行:如果任务没有完成，那么我们将状态设置为<code class="fe mz na nb nc b">0 (Awaiting)</code>，很快你就会明白为什么了。</li><li id="9e92" class="mk ml jg kf b kg mt kk mu ko mv ks mw kw mx la mp mq mr ms bi translated">第24行:我们将<code class="fe mz na nb nc b">awaiter</code>局部变量归属于<code class="fe mz na nb nc b">&lt;u&gt;__1</code>变量。这很重要，因为下一步。</li><li id="f529" class="mk ml jg kf b kg mt kk mu ko mv ks mw kw mx la mp mq mr ms bi translated">第25行:调用了<code class="fe mz na nb nc b">AwaitUnsafeOnCompleted</code>方法。这里我们有一点要谈。</li></ul><p id="e117" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意，该方法接收两个参数<code class="fe mz na nb nc b">awaiter</code>和结构本身。注意它们是通过引用传递的，为什么？因为两者都是结构，而结构都是值类型。这意味着，当我们将这些属性传递给另一个方法时，必须复制它们的整个值，因为这些是大对象，这可能会影响性能，所以它们通过引用传递，以避免在这方面出现任何问题。<code class="fe mz na nb nc b">AwaitUnsafeOnCompleted</code>也需要访问同一个实例才能继续。</p><p id="cee8" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦异步操作完成，方法将负责调用我们的方法。这就是为什么我们将<code class="fe mz na nb nc b">this</code>作为第二个参数传递，它还会将<code class="fe mz na nb nc b">awaiter</code>状态更改为<code class="fe mz na nb nc b">Completed</code>。</p><p id="c061" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在操作已经完成，再次调用了<code class="fe mz na nb nc b">MoveNext()</code>。现在，第18行的<code class="fe mz na nb nc b">if</code>将不被满足，因为我们在上一次调用中将这个值设置为第23行的<code class="fe mz na nb nc b">0 (Awaiting)</code>。代码将直接转到第29行。</p><ul class=""><li id="08e9" class="mk ml jg kf b kg kh kk kl ko mm ks mn kw mo la mp mq mr ms bi translated">第31行:我们将内部变量<code class="fe mz na nb nc b">awaiter</code>设置为操作的结果</li><li id="876f" class="mk ml jg kf b kg mt kk mu ko mv ks mw kw mx la mp mq mr ms bi translated">第32行:我们重置了<code class="fe mz na nb nc b">&lt;&gt;u__1</code>变量，它最终会有一个值，但是任务属性将为空。</li><li id="8123" class="mk ml jg kf b kg mt kk mu ko mv ks mw kw mx la mp mq mr ms bi translated">第33行:我们将状态机的状态重置为初始值。</li><li id="6665" class="mk ml jg kf b kg mt kk mu ko mv ks mw kw mx la mp mq mr ms bi translated">第37行:如果发生了异常，我们将处理它。我们将状态设置为<code class="fe mz na nb nc b">-2 (Completed)</code>并设置异常，然后我们返回而不设置结果。</li><li id="252f" class="mk ml jg kf b kg mt kk mu ko mv ks mw kw mx la mp mq mr ms bi translated">第43行:我们将状态设置为<code class="fe mz na nb nc b">-2 (Completed).</code></li><li id="0810" class="mk ml jg kf b kg mt kk mu ko mv ks mw kw mx la mp mq mr ms bi translated">第44行:我们用操作的结果设置状态机构建器的内容。</li><li id="6f7d" class="mk ml jg kf b kg mt kk mu ko mv ks mw kw mx la mp mq mr ms bi translated">第73行:获取构建器的内容并返回已执行的任务</li></ul><h1 id="fb6a" class="lb lc jg bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><strong class="ak">包装东西</strong></h1><p id="6795" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">任务、线程和线程池是真正值得理解的主题，它们是如何工作的，以便能够改进您的代码，特别是线程，在线程中，一个简单的错误可能会导致具有巨大性能问题和难以维护的代码。</p><p id="42fd" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一方面，Async/await不需要太多的专业知识，也不需要对其内部机制有深入的了解，但是这里面隐藏了很多东西。我们简要了解了它是如何工作的，但是还有很多事情要做，如果你想的话，我可以写第二部分，深入研究异步齿轮</p><p id="3d4c" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你有关于这个主题的问题，请留下评论，我会尽力回答你。</p><p id="72b7" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下期文章再见:)</p></div></div>    
</body>
</html>