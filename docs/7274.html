<html>
<head>
<title>Snake game on C++ in the reactive programming way</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应式编程方式下的C++贪吃蛇游戏</h1>
<blockquote>原文：<a href="https://itnext.io/snake-game-on-c-in-the-reactive-programming-way-19310a73923a?source=collection_archive---------0-----------------------#2022-08-08">https://itnext.io/snake-game-on-c-in-the-reactive-programming-way-19310a73923a?source=collection_archive---------0-----------------------#2022-08-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="c6e7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">大家好，欢迎来到现代C++和反应式编程的世界=)</p><p id="e0d9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">今天，我们将通过SFML和反应式编程范式(在<a class="ae kl" href="https://github.com/victimsnino/ReactivePlusPlus" rel="noopener ugc nofollow" target="_blank"> ReactivePlusPlus </a>库的帮助下)创建一个简单的贪吃蛇游戏。(如果你不熟悉反应式编程，从这篇<a class="ae kl" href="https://medium.com/@victimsnino/what-is-actually-reactive-programming-in-modern-c-part-1-base-929355ac2901?source=friends_link&amp;sk=59986e68b0688469c65ca0c757bbfd89" rel="noopener">文章</a>或任何其他资源开始，因为这篇文章没有详细描述操作符，而是使用了它们。)</p><p id="7138" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">注</strong>:最终结果可以在<a class="ae kl" href="https://github.com/victimsnino/ReactivePlusPlus/tree/main/src/samples/sfml/snake" rel="noopener ugc nofollow" target="_blank"> github </a>上找到。灵感来自<a class="ae kl" href="https://blog.thoughtram.io/rxjs/2017/08/24/taming-snakes-with-reactive-streams.html" rel="noopener ugc nofollow" target="_blank">用反应流驯服蛇</a> (RxJs实现)</p><p id="b919" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">剧透:-) </strong></p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi km"><img src="../Images/f243ff4e10140edb4b75e08fbb7b62ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:670/1*0Pg0xltAozQPsyypYW3XEA.gif"/></div></figure><p id="dc83" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们需要做两件重要的事情:</p><ol class=""><li id="d220" class="ku kv iq jp b jq jr ju jv jy kw kc kx kg ky kk kz la lb lc bi translated">创建一个渲染游戏的窗口</li><li id="5d9b" class="ku kv iq jp b jq ld ju le jy lf kc lg kg lh kk kz la lb lc bi translated">从此窗口处理事件。</li></ol><p id="9268" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第一点非常简单，所以让我们来探讨第二点:</p><h1 id="b555" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">处理事件</h1><p id="8355" class="pw-post-body-paragraph jn jo iq jp b jq mg js jt ju mh jw jx jy mi ka kb kc mj ke kf kg mk ki kj kk ij bi translated">大多数图形库使用<strong class="jp ir">事件</strong>来通知用户代码关于窗口产生的一些事件。例如，请求关闭窗口的事件、鼠标移动、按键等。因此，这是任何游戏逻辑的主要部分——以某种方式处理事件。因此，在大多数情况下，主游戏循环如下所示:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="89ef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">简而言之，可以用下一种方式来描述:</p><ul class=""><li id="11c9" class="ku kv iq jp b jq jr ju jv jy kw kc kx kg ky kk mn la lb lc bi translated">outer while——这是一个帧循环——每次循环结束时，我们将渲染内容显示到显示器上→生成一个新的帧</li><li id="ffc6" class="ku kv iq jp b jq ld ju le jy lf kc lg kg lh kk mn la lb lc bi translated">在循环内部，首先，我们处理事件以对用户的输入做出反应，例如，对关闭应用程序的请求做出反应</li><li id="21ff" class="ku kv iq jp b jq ld ju le jy lf kc lg kg lh kk mn la lb lc bi translated">然后我们需要画出整个场景</li><li id="d319" class="ku kv iq jp b jq ld ju le jy lf kc lg kg lh kk mn la lb lc bi translated">将内容显示到窗口(并完成框架)</li><li id="1df2" class="ku kv iq jp b jq ld ju le jy lf kc lg kg lh kk mn la lb lc bi translated">清除下一帧的窗口内容(将与下一个“显示”一起显示)==开始新的一帧</li></ul><p id="736d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这种方法也以完美的方式依赖于反应式编程范式。因此，让我们创建一个可观察对象，它将把从窗口获得的事件与当前事件一起发出。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="b3aa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们来详细了解一下。我们创建了全局<code class="fe mo mp mq mr b">run_loop </code>调度器，它是我们游戏的“主游戏循环”调度器，用来调度主循环的动作。然后我们创建一个observable，它使用这个调度器提交一个递归任务来发送一个关于新帧的事件，然后从窗口发送任何就绪事件并结束。然后，我们创建这样一个可观察对象，并将其发布给多个订户的多播值。</p><p id="1c1d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，我们需要显示窗口，直到用户请求关闭应用程序。在此之前，我们需要处理来自<code class="fe mo mp mq mr b">run_loop</code>的事件:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="5d5f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里我们订阅我们的可观察事件，只取“关闭”事件，取1个事件，当这样的事件发生时关闭窗口。由于我们只接受1个事件，第一个事件后<code class="fe mo mp mq mr b">root_subscription</code>将被取消订阅。因此，我们可以使用它作为应用程序是否仍然活动的指示器，如果它是真的，我们可以从我们的运行循环中调度事件。</p><p id="ad5e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以，基地“主游戏循环”准备好了，我们可以前进了。</p><p id="af73" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们添加代码来清除窗口并在窗口中显示新内容。我们可以用下面的方法来做:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="3d3f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们的窗口正在清除和显示每一帧！酷！现在我们可以开始实现与我们的蛇相关的主要游戏逻辑了！</p><h1 id="e08a" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">核心游戏逻辑</h1><p id="da66" class="pw-post-body-paragraph jn jo iq jp b jq mg js jt ju mh jw jx jy mi ka kb kc mj ke kf kg mk ki kj kk ij bi translated">Sooo…接下来我们需要实现什么？</p><ol class=""><li id="d06a" class="ku kv iq jp b jq jr ju jv jy kw kc kx kg ky kk kz la lb lc bi translated">键盘事件的处理</li><li id="1379" class="ku kv iq jp b jq ld ju le jy lf kc lg kg lh kk kz la lb lc bi translated">基于键盘事件的蛇身运动</li><li id="0255" class="ku kv iq jp b jq ld ju le jy lf kc lg kg lh kk kz la lb lc bi translated">展示蛇</li><li id="4738" class="ku kv iq jp b jq ld ju le jy lf kc lg kg lh kk kz la lb lc bi translated">苹果的产卵，展示它们</li><li id="cd99" class="ku kv iq jp b jq ld ju le jy lf kc lg kg lh kk kz la lb lc bi translated">如果苹果被吃了，蛇就会长大</li></ol><p id="44ba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们来落实这几点吧！会很有趣的！=)</p><h2 id="3c76" class="ms lj iq bd lk mt mu dn lo mv mw dp ls jy mx my lw kc mz na ma kg nb nc me nd bi translated">键盘事件</h2><p id="4666" class="pw-post-body-paragraph jn jo iq jp b jq mg js jt ju mh jw jx jy mi ka kb kc mj ke kf kg mk ki kj kk ij bi translated">键盘事件用于选择蛇的移动方向。只有几个键负责这个。因此，我们需要过滤掉所有不感兴趣的事件和按键，并将这些事件转换为snake方向。让我们从选择键盘事件开始:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="4649" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，我们可以观察到<code class="fe mo mp mq mr b">sf::Event::KeyEvent</code>，它会通知我们新的键盘事件(而且仅仅是关于它们！).现在我们需要将关键事件转换成我们未来蛇的方向。可以通过以下方式完成:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="b1e7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这里，我们检查它是否是一个“原始”按键事件(没有按下任何修饰键),并且仅当它对我们的按键感兴趣时才映射到方向。由于我们的蛇必须移动，即使没有任何键被按下，我们强迫它从<code class="fe mo mp mq mr b">initial_direction</code>开始。</p><p id="0a18" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们继续前进，实现与蛇的运动相关的核心逻辑！</p><h2 id="824c" class="ms lj iq bd lk mt mu dn lo mv mw dp ls jy mx my lw kc mz na ma kg nb nc me nd bi translated">蛇形运动</h2><p id="1844" class="pw-post-body-paragraph jn jo iq jp b jq mg js jt ju mh jw jx jy mi ka kb kc mj ke kf kg mk ki kj kk ij bi translated">一般来说，蛇的移动逻辑是这样的:每隔一段时间，我们需要按照最后选择的方向移动蛇的身体。来实施吧！</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="1cdf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里我们做我们上面讨论的所有事情=)每隔200毫秒，我们采用通过键盘事件获得的最后一个方向，根据snake规则更新这个方向(下一个方向不能与上一个方向相反)，并“向前”移动snake身体。可观察的将做它直到蛇吃自己。我觉得看起来好简单好理解。=)</p><p id="0ae9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们准备展示我们的蛇！</p><h2 id="036d" class="ms lj iq bd lk mt mu dn lo mv mw dp ls jy mx my lw kc mz na ma kg nb nc me nd bi translated">画蛇</h2><p id="4aab" class="pw-post-body-paragraph jn jo iq jp b jq mg js jt ju mh jw jx jy mi ka kb kc mj ke kf kg mk ki kj kk ij bi translated">为了正确显示对象，我们需要在每一帧上绘制它们。这意味着我们的行动取决于当前的潮流。在这个过程中，我们需要在最后一个位置画蛇。所以，让我们以下面的方式来制作我们的“游戏逻辑函数”:它将返回可绘制对象的可观察值，然后调用者将对此做一些事情(在我们的例子中显示到窗口)。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="9932" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，我们只需将坐标向量转换为可绘制对象的可观察值，并将它们显示在窗口中。由于每一个新的帧，我们将提供新的对象的可观察性，我们使用<code class="fe mo mp mq mr b">switch_on_next</code>来改变可绘制对象的底层来源。</p><p id="3190" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这时，我们有了可以根据按键移动甚至吃掉自己的蛇(在这种情况下，游戏只是“停止”)。让我们给我们的蛇加点食物吧！=)</p><h2 id="85ba" class="ms lj iq bd lk mt mu dn lo mv mw dp ls jy mx my lw kc mz na ma kg nb nc me nd bi translated">生成苹果</h2><p id="3735" class="pw-post-body-paragraph jn jo iq jp b jq mg js jt ju mh jw jx jy mi ka kb kc mj ke kf kg mk ki kj kk ij bi translated">怎样才能生成苹果？我们可以用哪个事件来做这件事？我觉得应该是蛇位！为什么？因为当蛇和我们的苹果相交时，我们需要重新生成苹果的位置，让蛇变长。所以，让我们开始吧！</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="afe8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后我们需要以某种方式把我们的苹果拉到窗口。为此，我们需要将它添加到我们的<code class="fe mo mp mq mr b">drawable_objects</code>可观测值中。我们稍微修改一下。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="361e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">哇！现在我们有了苹果，蛇甚至可以吃它！但是蛇的长度不变。让我们修理它！</p><h2 id="2928" class="ms lj iq bd lk mt mu dn lo mv mw dp ls jy mx my lw kc mz na ma kg nb nc me nd bi translated">让蛇变长</h2><p id="3fae" class="pw-post-body-paragraph jn jo iq jp b jq mg js jt ju mh jw jx jy mi ka kb kc mj ke kf kg mk ki kj kk ij bi translated">我们如何确定何时应该增加蛇的尺寸？有很多可能的方法，但最简单的是next:当苹果的位置改变时，我们可以增加蛇的大小，因为只有当蛇吃它时才会发生这种情况。好的，但是我们需要做什么来改变蛇的大小呢？我们需要给可观察到的生成蛇的身体添加关于大小的信息。我们可以借助学科来做！Snake body将订阅它以获取关于大小变化的事件，而apple position observable将向主题发送事件<strong class="jp ir">。来实施吧！</strong></p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="e1b6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以，我们对<code class="fe mo mp mq mr b">move_snake</code>做了一点改变，使用蛇的长度，如果需要的话增加它的长度。现在我们的蛇吃苹果就长！太神奇了！</p><p id="c440" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，我们用反应式编程的方式实现了一个简单的游戏。很可能，从代码点的大小来看，它不是最简单的解决方案，但至少它是可以理解的，并且是线性的:我们构建对事件做出反应的数据流，没有复杂的分支/循环逻辑，整个游戏逻辑是线性的。游戏最后的“核心”逻辑功能是:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="ml mm l"/></div></figure><h2 id="32ee" class="ms lj iq bd lk mt mu dn lo mv mw dp ls jy mx my lw kc mz na ma kg nb nc me nd bi translated">最终结果:</h2><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi km"><img src="../Images/f243ff4e10140edb4b75e08fbb7b62ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:670/1*0Pg0xltAozQPsyypYW3XEA.gif"/></div></figure><p id="82a8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这都是为了今天！下一篇文章再见！=)</p></div></div>    
</body>
</html>