<html>
<head>
<title>Fitness Validation For Your Kubernetes Apps: Policy As Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes应用程序的适用性验证:政策即代码</h1>
<blockquote>原文：<a href="https://itnext.io/fitness-validation-for-your-kubernetes-apps-policy-as-code-7fad698e7dec?source=collection_archive---------8-----------------------#2020-06-21">https://itnext.io/fitness-validation-for-your-kubernetes-apps-policy-as-code-7fad698e7dec?source=collection_archive---------8-----------------------#2020-06-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/84e0112403f1d105af3b27955b9a75a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dd6a31uLVAXTmCSHb_3GpA.png"/></div></div></figure><div class=""/><div class=""><h2 id="533d" class="pw-subtitle-paragraph jy ja jb bd b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp dk translated">实践编码之旅，实现“策略即代码”,并根据集群策略验证您的Kubernetes应用程序的适用性。</h2></div><figure class="kq kr ks kt gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/245a103cbdbf2e9e2f44457fa0c621a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hUTYheOLRVFj4sTE7beu1Q.png"/></div></div></figure><p id="213d" class="pw-post-body-paragraph ku kv jb kw b kx ky kc kz la lb kf lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi lq translated">“策略作为代码”是一种想法，我们试图通过将策略作为代码来表达，使策略的生成和验证处于源代码控制之下。</p><h2 id="4e58" class="lz ma jb bd mb mc md dn me mf mg dp mh ld mi mj mk lh ml mm mn ll mo mp mq mr bi translated">为什么策略是代码？</h2><p id="15f7" class="pw-post-body-paragraph ku kv jb kw b kx ms kc kz la mt kf lc ld mu lf lg lh mv lj lk ll mw ln lo lp ij bi translated">我们管理和组织应用程序的策略随着不断变化的业务和技术环境而不断发展。为了应对增长机会、竞争、团队成熟度、技术中断、新的工程实践、法规遵从性和安全威胁，形势正在发生变化。</p><blockquote class="mx my mz"><p id="fec8" class="ku kv na kw b kx ky kc kz la lb kf lc nb le lf lg nc li lj lk nd lm ln lo lp ij bi translated">一般来说，当一个应用程序或基础设施被创建为一个全新的工作时，我们会很好地计划和实现策略。但是随着手动策略治理的时间推移，它会逐渐衰退。</p></blockquote><p id="84f8" class="pw-post-body-paragraph ku kv jb kw b kx ky kc kz la lb kf lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">这些策略是授权规则、网络策略、体系结构特征、最佳实践和操作问题的组合。这些策略由不同的利益相关者贡献和验证，如开发人员、操作人员、安全工程师、架构师和产品所有者。由许多利益相关者贡献和验证的多维策略使得保持生产生态系统与不断发展的策略同步变得非常困难</p><blockquote class="mx my mz"><p id="d1da" class="ku kv na kw b kx ky kc kz la lb kf lc nb le lf lg nc li lj lk nd lm ln lo lp ij bi translated">由于这种高速的变化和协作需求，策略继承了我们管理应用程序代码的许多需求。这引发了将策略作为代码进行管理的需求。</p></blockquote><p id="2060" class="pw-post-body-paragraph ku kv jb kw b kx ky kc kz la lb kf lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">一旦我们开始将策略作为代码来管理，这将带来很多好处。下面列出了其中的一些。</p><ul class=""><li id="f049" class="ne nf jb kw b kx ky la lb ld ng lh nh ll ni lp nj nk nl nm bi translated">易于协作</li><li id="5f6e" class="ne nf jb kw b kx nn la no ld np lh nq ll nr lp nj nk nl nm bi translated">可共享和重复使用</li><li id="dc81" class="ne nf jb kw b kx nn la no ld np lh nq ll nr lp nj nk nl nm bi translated">可审计</li><li id="588c" class="ne nf jb kw b kx nn la no ld np lh nq ll nr lp nj nk nl nm bi translated">可重复且可靠</li><li id="d0d2" class="ne nf jb kw b kx nn la no ld np lh nq ll nr lp nj nk nl nm bi translated">还原和回滚</li><li id="7cfa" class="ne nf jb kw b kx nn la no ld np lh nq ll nr lp nj nk nl nm bi translated">易于调试</li><li id="f6f9" class="ne nf jb kw b kx nn la no ld np lh nq ll nr lp nj nk nl nm bi translated">自动化治理</li></ul><p id="be10" class="pw-post-body-paragraph ku kv jb kw b kx ky kc kz la lb kf lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">本文集中讨论使用“开放策略代理”对部署在Kubernetes中的应用程序进行策略验证。如果你对政策代作代码感兴趣，可以看看《<a class="ae ns" rel="noopener ugc nofollow" target="_blank" href="/helm-is-not-enough-you-also-need-kustomize-82bae896816e"> <strong class="kw jc"> <em class="na">掌舵还不够，还需要草创</em> </strong> </a>》一文。</p><p id="6323" class="pw-post-body-paragraph ku kv jb kw b kx ky kc kz la lb kf lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><strong class="kw jc">什么是“开放式保单代理”？</strong></p><p id="3807" class="pw-post-body-paragraph ku kv jb kw b kx ky kc kz la lb kf lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">开放策略代理(OPA)是一个通用的开源策略引擎，可以帮助在整个堆栈中实施策略。我们可以将OPA用于</p><ul class=""><li id="ca62" class="ne nf jb kw b kx ky la lb ld ng lh nh ll ni lp nj nk nl nm bi translated">在微服务API中实施授权</li><li id="f34e" class="ne nf jb kw b kx nn la no ld np lh nq ll nr lp nj nk nl nm bi translated">验证Kubernetes YAML的完整性</li><li id="80a4" class="ne nf jb kw b kx nn la no ld np lh nq ll nr lp nj nk nl nm bi translated">以基础设施为代码的策略验证(平台、交叉平面)</li><li id="ef2d" class="ne nf jb kw b kx nn la no ld np lh nq ll nr lp nj nk nl nm bi translated">对docker应用访问控制</li><li id="a1ab" class="ne nf jb kw b kx nn la no ld np lh nq ll nr lp nj nk nl nm bi translated">在Linux机器中应用访问控制</li></ul><p id="7f51" class="pw-post-body-paragraph ku kv jb kw b kx ky kc kz la lb kf lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">由于结构简单，OPA能够适应不同的堆栈。OPA公开了JSON API，将策略查询作为输入，将策略决策作为响应。在OPA中，策略是用一种特定于领域的语言编写的，这种语言被称为减压阀。OPA还有一个内存中的数据存储，用于保存决策所需的数据。</p><blockquote class="mx my mz"><p id="fc6f" class="ku kv na kw b kx ky kc kz la lb kf lc nb le lf lg nc li lj lk nd lm ln lo lp ij bi translated">我们所要做的就是1)编写减压阀策略，2)填充决策支持库，以及3)开始进行策略查询。</p></blockquote><figure class="kq kr ks kt gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nt"><img src="../Images/20074b9d2d97515e653da56964f829e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f6JgmctGzdtTtY05F3Vf6g.png"/></div></div></figure><p id="1757" class="pw-post-body-paragraph ku kv jb kw b kx ky kc kz la lb kf lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">OPA可以与更多的生态系统集成，在这里 阅读关于这些集成的更多信息<a class="ae ns" href="https://www.openpolicyagent.org/docs/latest/ecosystem/" rel="noopener ugc nofollow" target="_blank"> <strong class="kw jc">。</strong></a></p><h2 id="1a3a" class="lz ma jb bd mb mc md dn me mf mg dp mh ld mi mj mk lh ml mm mn ll mo mp mq mr bi translated">看门人:Kubernetes OPA集成</h2><blockquote class="mx my mz"><p id="28a0" class="ku kv na kw b kx ky kc kz la lb kf lc nb le lf lg nc li lj lk nd lm ln lo lp ij bi translated">看门人作为准入控制器webhook集成到kubernetes中。每当创建、更新或删除资源时，它们都会执行rego策略来验证和授权更改。</p></blockquote><p id="09d5" class="pw-post-body-paragraph ku kv jb kw b kx ky kc kz la lb kf lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">准入控制器在ETCD持久化之前，但在经过身份验证和授权之后，拦截所有对Kubernetes API服务器的请求。有两种类型的接纳控制器1)确认接纳控制器2)突变接纳控制器。虽然验证准入控制器可用于策略验证，但变异准入可用于策略生成。</p><blockquote class="mx my mz"><p id="5521" class="ku kv na kw b kx ky kc kz la lb kf lc nb le lf lg nc li lj lk nd lm ln lo lp ij bi translated">网守目前只有验证准入控制器和审计实现。变异准入控制器计划在未来实施。</p></blockquote><p id="e825" class="pw-post-body-paragraph ku kv jb kw b kx ky kc kz la lb kf lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">审计功能是一种查看违反策略的列表的方法，在没有网守的情况下(在创建策略约束之前或网守关闭时)创建的现有Kubernetes资源中。本文将重点介绍Gatekeeper v3.0版。需要注意的是，3.0版的工作方式不同于旧版本。让我们来看看gatekeeper是如何融入Kubernetes架构的。</p><figure class="kq kr ks kt gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/c6bb0208dc9f2a7f1cf38c3869ff3f82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2HWANip9mc_RCiHGr3CM9g.png"/></div></div></figure><p id="983c" class="pw-post-body-paragraph ku kv jb kw b kx ky kc kz la lb kf lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">乍一看，这可能看起来很复杂。理解下面的几个概念会让你明白。</p><h2 id="589a" class="lz ma jb bd mb mc md dn me mf mg dp mh ld mi mj mk lh ml mm mn ll mo mp mq mr bi translated"><strong class="ak">策略模板&amp;策略约束CRDs </strong></h2><p id="8c70" class="pw-post-body-paragraph ku kv jb kw b kx ms kc kz la mt kf lc ld mu lf lg lh mv lj lk ll mw ln lo lp ij bi translated">策略约束是一个客户资源定义(CRDs ),由集群操作者用来定义一组规则，在添加/删除/修改Kubernetes资源之前需要满足这些规则。如果你不知道什么是CRD，它们是用你自己的定制对象来扩展Kubernetes的一种方式。当您需要Kubernetes以外的本地对象时，如pod、部署、Secret、Ingress等。我们选择CRDs。在这里阅读更多关于CRDs<a class="ae ns" href="https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/" rel="noopener ugc nofollow" target="_blank"><strong class="kw jc"><em class="na"/></strong></a><strong class="kw jc"><em class="na">。下面是一个策略约束的例子，我们声明性地指定我们应该在所有k8s命名空间资源上有一个名为“owner”的标签。</em></strong></p><pre class="kq kr ks kt gt nu nv nw nx aw ny bi"><span id="fff5" class="lz ma jb nv b gy nz oa l ob oc"><strong class="nv jc">apiVersion</strong>: constraints.gatekeeper.sh/v1beta1<br/><strong class="nv jc">kind</strong>: K8sRequiredLabels<br/><strong class="nv jc">metadata</strong>:<br/>  <strong class="nv jc">name</strong>: ns-must-have-owner<br/><strong class="nv jc">spec</strong>:<br/>  <strong class="nv jc">match</strong>:<br/>    <strong class="nv jc">kinds</strong>:<br/>      - <strong class="nv jc">apiGroups</strong>: [""]<br/>        <strong class="nv jc">kinds</strong>: ["Namespace"]<br/>  <strong class="nv jc">parameters</strong>:<br/>    <strong class="nv jc">labels</strong>: ["owner"]</span></pre><blockquote class="mx my mz"><p id="48f3" class="ku kv na kw b kx ky kc kz la lb kf lc nb le lf lg nc li lj lk nd lm ln lo lp ij bi translated">策略约束不是一个独立的单元，它依赖于策略模板CRD。策略模板定义了要为策略约束执行的减压阀规则和策略约束CRD的模式。</p></blockquote><p id="6a2e" class="pw-post-body-paragraph ku kv jb kw b kx ky kc kz la lb kf lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">策略模板可以在整个组织和更广泛的生态系统中共享和重用。Gatekeeper在library文件夹中有一组重复使用的策略模板。在此  处编写新的<a class="ae ns" href="https://github.com/open-policy-agent/gatekeeper/tree/master/library" rel="noopener ugc nofollow" target="_blank"> <strong class="kw jc"> <em class="na">策略模板之前，先寻找一个适合您需要的策略模板。一旦我们在集群中安装了模板CRDs，集群操作者就可以开始添加与模板中定义的模式相匹配的约束。查看上面给定约束的策略模板。</em></strong></a></p><pre class="kq kr ks kt gt nu nv nw nx aw ny bi"><span id="033f" class="lz ma jb nv b gy nz oa l ob oc"><strong class="nv jc">apiVersion</strong>: templates.gatekeeper.sh/v1beta1<br/><strong class="nv jc">kind</strong>: ConstraintTemplate<br/><strong class="nv jc">metadata</strong>:<br/>  <strong class="nv jc">name</strong>: k8srequiredlabels<br/><strong class="nv jc">spec</strong>:<br/>  <strong class="nv jc">crd</strong>:<br/>    <strong class="nv jc">spec</strong>:<br/>      <strong class="nv jc">names</strong>:<br/>        <strong class="nv jc">kind</strong>: K8sRequiredLabels<br/>      <strong class="nv jc">validation</strong>:<br/>        <strong class="nv jc">openAPIV3Schema</strong>:<br/>          <strong class="nv jc">properties</strong>:<br/>            <strong class="nv jc">labels</strong>:<br/>              <strong class="nv jc">type</strong>: array<br/>              <strong class="nv jc">items</strong>: string<br/>  <strong class="nv jc">targets</strong>:<br/>    - <strong class="nv jc">target</strong>: admission.k8s.gatekeeper.sh<br/>      <strong class="nv jc">rego</strong>: <em class="na">|<br/>        package k8srequiredlabels</em><br/><br/>        deny[{<strong class="nv jc">"msg": msg, "details": {"missing_labels": </strong>missing}}] {<br/>          provided := {label | input.review.object.metadata.labels[label]}<br/>          required := {label | label := input.parameters.labels[_]}<br/>          missing := required - provided<br/>          count(missing) &gt; 0<br/>          msg := sprintf("you must provide labels: %v", [missing])<br/>        }</span></pre><p id="0187" class="pw-post-body-paragraph ku kv jb kw b kx ky kc kz la lb kf lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">这里解释了上述策略模板和策略约束YAML的一些重要组件。</p><ul class=""><li id="5536" class="ne nf jb kw b kx ky la lb ld ng lh nh ll ni lp nj nk nl nm bi translated"><em class="na">" spec . crd . spec . names . kind "</em>策略模板YAML是定义名称的策略约束CRD的模式定义。</li><li id="86ec" class="ne nf jb kw b kx nn la no ld np lh nq ll nr lp nj nk nl nm bi translated"><em class="na">" spec . crd . spec . validation . open apiv 3 schema . properties "</em>策略模板YAML是策略约束CRD的输入参数模式。</li><li id="67e6" class="ne nf jb kw b kx nn la no ld np lh nq ll nr lp nj nk nl nm bi translated">在策略模板YAML中，标签是定义为策略约束CRD规范的唯一属性。在策略约束中，YAML字符串数组“<code class="fe od oe of nv b">["owner"]</code>”是“<em class="na">规格参数标签</em>”的输入。</li><li id="7bc7" class="ne nf jb kw b kx nn la no ld np lh nq ll nr lp nj nk nl nm bi translated">策略约束中的“<em class="na">spec . match . kinds</em>”YAML定义了应该对其应用策略约束的Kubernetes资源列表。</li><li id="6ea9" class="ne nf jb kw b kx nn la no ld np lh nq ll nr lp nj nk nl nm bi translated">最后，策略模板YAML的“spec.target.rego”将保存实际的减压阀代码，这些代码将在我们运行策略约束时执行。</li></ul><h2 id="6792" class="lz ma jb bd mb mc md dn me mf mg dp mh ld mi mj mk lh ml mm mn ll mo mp mq mr bi translated">减压阀的一些基本知识</h2><p id="0d70" class="pw-post-body-paragraph ku kv jb kw b kx ms kc kz la mt kf lc ld mu lf lg lh mv lj lk ll mw ln lo lp ij bi translated">学习rego本身就是一个很大的话题。在这个博客中，我们将学习一些工作所需的基础知识。</p><p id="be0f" class="pw-post-body-paragraph ku kv jb kw b kx ky kc kz la lb kf lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">提示1: 我们可以在rego部分定义许多规则。规则块的语法如下所示</p><pre class="kq kr ks kt gt nu nv nw nx aw ny bi"><span id="fa3f" class="lz ma jb nv b gy nz oa l ob oc">rule_header[return_values]{<br/>rule_body<br/>}</span></pre><p id="4a4f" class="pw-post-body-paragraph ku kv jb kw b kx ky kc kz la lb kf lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">在上面的例子中</p><ul class=""><li id="28c4" class="ne nf jb kw b kx ky la lb ld ng lh nh ll ni lp nj nk nl nm bi translated">拒绝—是规则标题</li><li id="7260" class="ne nf jb kw b kx nn la no ld np lh nq ll nr lp nj nk nl nm bi translated">{"msg": msg，" details ":{ " missing _ labels ":missing } }-是返回值</li><li id="3c4c" class="ne nf jb kw b kx nn la no ld np lh nq ll nr lp nj nk nl nm bi translated">“{}”中的所有内容都是规则体</li></ul><p id="efb5" class="pw-post-body-paragraph ku kv jb kw b kx ky kc kz la lb kf lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><strong class="kw jc">提示2: </strong>每当看到“<code class="fe od oe of nv b">input.</code>”，都是指传递给rego块的输入参数。在这个例子中“<code class="fe od oe of nv b">input.review.object.metadata.labels</code>”指的是被审查的来自即将到来的YAML的标签。“<code class="fe od oe of nv b">input.review.object.</code>”引用传入的YAML，“<code class="fe od oe of nv b">metadata.labels</code>”通过遍历访问传入的YAML内部的标签对象。<code class="fe od oe of nv b">input.parameters.</code>"在rego块中引用了我们在策略约束中定义的输入参数。</p><p id="3fee" class="pw-post-body-paragraph ku kv jb kw b kx ky kc kz la lb kf lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><strong class="kw jc">提示3: </strong>每当我们提到<code class="fe od oe of nv b">data.</code>，就意味着我们正在访问存储在OPA内存中的数据，以用于决策支持。为了能够以“<code class="fe od oe of nv b">data.</code>”的形式访问一些数据，您应该首先在OPA中同步这些数据。为什么以及你将如何去做将会在博客的最后讨论。</p><p id="13ba" class="pw-post-body-paragraph ku kv jb kw b kx ky kc kz la lb kf lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><strong class="kw jc">提示4: </strong>规则体中的所有语句都作为“与”逻辑运算执行。这意味着一旦其中一个表达式逻辑输出false，执行就会中断，表明整个块失败。</p><pre class="kq kr ks kt gt nu nv nw nx aw ny bi"><span id="15bb" class="lz ma jb nv b gy nz oa l ob oc">expression-1 AND expression-2 AND ... AND expression-N</span></pre><p id="d048" class="pw-post-body-paragraph ku kv jb kw b kx ky kc kz la lb kf lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">技巧5: 我们应该将编写规则视为防御性编程。当执行中途返回“false”时，它将没有返回值，因此没有可用于拒绝资源添加的信息。</p><pre class="kq kr ks kt gt nu nv nw nx aw ny bi"><span id="b7ae" class="lz ma jb nv b gy nz oa l ob oc"># When the count of missing labels is greater than zero the execution continues as the output is true<br/># When the count of missing labels is not greater than zero the execution breaks to return and admits the resource into the cluster</span><span id="af38" class="lz ma jb nv b gy og oa l ob oc">count(missing) &gt; 0</span></pre><p id="97ab" class="pw-post-body-paragraph ku kv jb kw b kx ky kc kz la lb kf lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><strong class="kw jc">提示6: </strong>当你在寻找“或”逻辑运算时我们应该使用多个规则块。在规则块之间应用“或”逻辑运算。这意味着当我们有多个规则块时，所有的规则都将被执行，直到其中一个规则块执行到最后返回一些值并且资源接纳失败。</p><pre class="kq kr ks kt gt nu nv nw nx aw ny bi"><span id="23d0" class="lz ma jb nv b gy nz oa l ob oc">rule_header1[return_values1]{<br/>rule_body1<br/>}<br/>rule_header2[return_values2]{<br/>rule_body2<br/>}</span></pre><p id="1ac4" class="pw-post-body-paragraph ku kv jb kw b kx ky kc kz la lb kf lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><strong class="kw jc">技巧7: </strong>有很多内置函数可以帮助我们编写快速规则块。上面代码中的“计数”就是一个例子。在  这里寻找你需要的<a class="ae ns" href="https://www.openpolicyagent.org/docs/latest/policy-reference/#built-in-functions" rel="noopener ugc nofollow" target="_blank"> <strong class="kw jc"> <em class="na">功能。你可以用下面的语法构建你自己的函数。</em></strong></a></p><pre class="kq kr ks kt gt nu nv nw nx aw ny bi"><span id="f2d2" class="lz ma jb nv b gy nz oa l ob oc">function_name(parameters) = return {<br/>function_body<br/>}</span></pre><p id="4d64" class="pw-post-body-paragraph ku kv jb kw b kx ky kc kz la lb kf lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">与其他编程语言一样，Rogo还有更多功能(数组、导入、循环、字典、虚拟文档、正则表达式等)。如果你愿意深潜，这里详细预排的是<a class="ae ns" href="https://www.openpolicyagent.org/docs/latest/#rego" rel="noopener ugc nofollow" target="_blank"><strong class="kw jc"><em class="na"/></strong></a>。</p><h2 id="bbc3" class="lz ma jb bd mb mc md dn me mf mg dp mh ld mi mj mk lh ml mm mn ll mo mp mq mr bi translated">观察和复制</h2><figure class="kq kr ks kt gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/b99a126e3062db38224c7072900bcc11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SW7ox556TDaaQLpWYw2cTA.png"/></div></div></figure><p id="638b" class="pw-post-body-paragraph ku kv jb kw b kx ky kc kz la lb kf lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">有时，我们需要访问现有资源的详细信息来做出决策。这种情况的一个典型例子是具有唯一的入口端点。为此，我们应该能够从集群访问现有的入口资源。这在技术上可以使用同步资源来实现，同步资源可以选择性地观察数据并将数据从ETCD复制到OPA内存空间中。复制后，可以在策略rego中使用“<code class="fe od oe of nv b">data.</code>”访问这些数据。下面的YAML中描述了复制对象、复制入口和Pod的示例。</p><pre class="kq kr ks kt gt nu nv nw nx aw ny bi"><span id="a6ac" class="lz ma jb nv b gy nz oa l ob oc"><strong class="nv jc">apiVersion</strong>: config.gatekeeper.sh/v1alpha1<br/><strong class="nv jc">kind</strong>: Config<br/><strong class="nv jc">metadata</strong>:<br/>  <strong class="nv jc">name</strong>: config<br/>  <strong class="nv jc">namespace</strong>: "gatekeeper-system"<br/><strong class="nv jc">spec</strong>:<br/>  <strong class="nv jc">sync</strong>:<br/>    <strong class="nv jc">syncOnly</strong>:<br/>      - <strong class="nv jc">group</strong>: ""<br/>        <strong class="nv jc">version</strong>: "networking.k8s.io/v1beta1"<br/>        <strong class="nv jc">kind</strong>: "Ingress<br/>      - <strong class="nv jc">group</strong>: ""<br/>        <strong class="nv jc">version</strong>: "v1"<br/>        <strong class="nv jc">kind</strong>: "Pod"</span></pre><h2 id="e827" class="lz ma jb bd mb mc md dn me mf mg dp mh ld mi mj mk lh ml mm mn ll mo mp mq mr bi translated">审计</h2><p id="e74f" class="pw-post-body-paragraph ku kv jb kw b kx ms kc kz la mt kf lc ld mu lf lg lh mv lj lk ll mw ln lo lp ij bi translated">网关守护设备准入控制器是一个webhook，当我们添加/编辑/删除资源时，它可能会关闭。这可能会导致非标准资源进入集群。此外，我们可能会遇到这样的情况:在应用约束之前，集群中就已经存在大量的非标准资源。我们需要一种机制来识别集群中的这些非标准资源，这就是看门人的审计功能。审计功能是对集群中现有资源的定期验证，并通过将它们作为违规附加到策略约束CRD的状态字段来引起我们的注意。</p><pre class="kq kr ks kt gt nu nv nw nx aw ny bi"><span id="6bef" class="lz ma jb nv b gy nz oa l ob oc"><strong class="nv jc">apiVersion</strong>: constraints.gatekeeper.sh/v1beta1<br/><strong class="nv jc">kind</strong>: K8sRequiredLabels<br/><strong class="nv jc">metadata</strong>:<br/>  <strong class="nv jc">name</strong>: ns-must-have-owner<br/><strong class="nv jc">spec</strong>:<br/>  <strong class="nv jc">match</strong>:<br/>    <strong class="nv jc">kinds</strong>:<br/>      - <strong class="nv jc">apiGroups</strong>: [""]<br/>        <strong class="nv jc">kinds</strong>: ["Namespace"]<br/>  <strong class="nv jc">parameters</strong>:<br/>    <strong class="nv jc">labels</strong>: ["owner"]<br/><strong class="nv jc">status</strong>:<br/>  <strong class="nv jc">auditTimestamp</strong>: "2019-08-06T01:46:13Z"<br/>  <strong class="nv jc">byPod</strong>:<br/>  - <strong class="nv jc">enforced</strong>: <strong class="nv jc">true</strong><br/>    <strong class="nv jc">id</strong>: gatekeeper-controller-manager-0<br/>  <strong class="nv jc">violations</strong>:<br/>  - <strong class="nv jc">enforcementAction</strong>: deny<br/>    <strong class="nv jc">kind</strong>: Namespace<br/>    <strong class="nv jc">message: 'you must provide labels</strong>: {"owner"}'<br/>    name: default</span></pre><h2 id="5eb0" class="lz ma jb bd mb mc md dn me mf mg dp mh ld mi mj mk lh ml mm mn ll mo mp mq mr bi translated">结论</h2><p id="1de1" class="pw-post-body-paragraph ku kv jb kw b kx ms kc kz la mt kf lc ld mu lf lg lh mv lj lk ll mw ln lo lp ij bi translated">我们开始看到，作为代码的策略越来越受欢迎，它已经在infoQ 2020架构趋势的创新者象限中占据了一席之地。OPA是CNCF认可的通用策略引擎，这使得学习OPA成为DevOps工程师的一项很好的技能🏄。</p><p id="1f2e" class="pw-post-body-paragraph ku kv jb kw b kx ky kc kz la lb kf lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">在即将发表的文章《✋.》中再见</p></div></div>    
</body>
</html>