<html>
<head>
<title>Converting Rails 5 model relationships</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">转换Rails 5模型关系</h1>
<blockquote>原文：<a href="https://itnext.io/converting-rails-5-model-relationships-ae370eb763b7?source=collection_archive---------3-----------------------#2019-09-05">https://itnext.io/converting-rails-5-model-relationships-ae370eb763b7?source=collection_archive---------3-----------------------#2019-09-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/7b3844ebc3e1e16a3ded98eaa26032b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nOZZaLuo8PsWRnJbqmxEVg.png"/></div></div></figure><p id="64f3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是如此普遍，我很惊讶，它在文件中是不正确的。</p><h2 id="c252" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">从一对多到多对多</h2><p id="1e51" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">假设您希望用户属于一家公司，但是您的客户告诉您，“哦，是的，我们有这些在不止一个地方工作的人。”</p><p id="b77f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这些模型有一些像这样的Ruby代码:</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="4f34" class="kw kx iq lz b gy md me l mf mg"><strong class="lz ir">class <em class="mh">User </em></strong>&lt; <strong class="lz ir"><em class="mh">ApplicationRecord<br/>  </em></strong><em class="mh">belongs_to </em><strong class="lz ir">:company<br/>end<br/><br/>class <em class="mh">Company </em></strong>&lt; <strong class="lz ir"><em class="mh">ApplicationRecord<br/>  </em></strong><em class="mh">has_many </em><strong class="lz ir">:users<br/>end</strong></span></pre><p id="1ae9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">事实证明重构非常简单。</p><p id="6399" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">生成一个迁移，目标是为公司和用户创建一个新的连接表，从<code class="fe mi mj mk lz b">Users</code>表中迁移现有的<code class="fe mi mj mk lz b">company_id</code>数据，然后相应地更新Rails模型。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="209b" class="kw kx iq lz b gy md me l mf mg"><strong class="lz ir">class <em class="mh">AddCompanyUsers </em></strong>&lt; <strong class="lz ir"><em class="mh">ActiveRecord</em></strong>::<strong class="lz ir"><em class="mh">Migration</em></strong>[5.2]<br/>  <strong class="lz ir">def </strong><em class="mh">change<br/>    create_join_table </em><strong class="lz ir">:companies</strong>, <strong class="lz ir">:users do </strong>|<em class="mh">t</em>|<br/>      <em class="mh">t</em>.index <strong class="lz ir">%i[company_id user_id]</strong>, <strong class="lz ir">unique</strong>: <strong class="lz ir">true<br/>    end<br/>    </strong><em class="mh"># migrate users to new table<br/>    </em>up_only <strong class="lz ir">do<br/>      <em class="mh">User</em></strong>.all.each <strong class="lz ir">do </strong>|<em class="mh">u</em>|<br/>        <strong class="lz ir">unless </strong><em class="mh">u</em>.company_id.nil?<br/>          <em class="mh">u</em>.update(<strong class="lz ir">companies</strong>: [<strong class="lz ir"><em class="mh">Company</em></strong>.<em class="mh">find</em>(<em class="mh">u</em>.company_id)])<br/>        <strong class="lz ir">end<br/>      end<br/>      </strong><em class="mh"># drop company_id from users<br/>      remove_column </em><strong class="lz ir">:users</strong>, <strong class="lz ir">:company_id<br/>    end<br/>  end<br/>end</strong></span></pre><p id="90f8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">其中一个重要的标志是<code class="fe mi mj mk lz b">unique: true</code>,因为它清除了表两端的连接表中的任何重复。这样，一个用户可以属于许多公司，但每个公司只能有一个用户。</p><p id="a3a6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">更新模型以支持它们之间的多对多关系:</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="8bc4" class="kw kx iq lz b gy md me l mf mg"><strong class="lz ir">class <em class="mh">User </em></strong>&lt; <strong class="lz ir"><em class="mh">ApplicationRecord<br/>  </em></strong><em class="mh">has_and_belongs_to_many </em><strong class="lz ir">:companies<br/>end<br/><br/>class <em class="mh">Company </em></strong>&lt; <strong class="lz ir"><em class="mh">ApplicationRecord<br/>  </em></strong><em class="mh">has_and_belongs_to_many </em><strong class="lz ir">:users<br/>end</strong></span></pre><p id="afcc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后一步是运行迁移:</p><p id="527e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mi mj mk lz b">rails db:migrate</code></p><p id="ad7d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这将负责基础，但现在控制器需要处理新的信息。以前我们只允许一个<code class="fe mi mj mk lz b">company_id</code>参数，然后直接在他们的行中设置用户的公司。但是现在我们有了一个公司id数组(或者一个用户id数组)来接受我们的参数。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="21d0" class="kw kx iq lz b gy md me l mf mg"><strong class="lz ir">class <em class="mh">UserController </em></strong>&lt; <strong class="lz ir"><em class="mh">ApplicationController<br/>  </em>def </strong><em class="mh">update<br/>    # woop no changes probably<br/>  </em><strong class="lz ir">end<br/><br/>  def </strong><em class="mh">user_params<br/>    # How it was<br/>    </em>params.<em class="mh">require</em>(<strong class="lz ir">:user</strong>).permit(<strong class="lz ir">:name</strong>, <strong class="lz ir">company_ids</strong>: [])<br/>  <strong class="lz ir">end<br/>end</strong></span></pre><p id="a9fc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在只需在您的UI中设置company_id，并将它们与您的其他参数一起发送。Rails会处理剩下的部分。</p><h2 id="f72e" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">从多对多到一对多</h2><p id="03aa" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">除非连接表会对性能产生重大影响，否则就让它成为多对多连接吧，这种情况不太可能发生。这种变化可能需要抛出一个客户想要的选择，他们会知道哪一个是该保留的。</p><p id="ac87" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这与上面的相反，但是我们希望保留旧的连接表一段时间，迁移只选择数组中的第一个值作为新列值的默认值。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="7ac6" class="kw kx iq lz b gy md me l mf mg"><strong class="lz ir">class <em class="mh">AddCompanyIdToUsers </em></strong>&lt; <strong class="lz ir"><em class="mh">ActiveRecord</em></strong>::<strong class="lz ir"><em class="mh">Migration</em></strong>[5.2]<br/>  <strong class="lz ir">def </strong><em class="mh">change<br/>    add_column </em><strong class="lz ir">:company_id</strong>, <strong class="lz ir">:users</strong>, <strong class="lz ir">optional</strong>: <strong class="lz ir">true <br/>    <br/>    </strong><em class="mh"># migrate users to new table<br/>    </em>up_only <strong class="lz ir">do<br/>      <em class="mh">User</em></strong>.all.each <strong class="lz ir">do </strong>|<em class="mh">u</em>|<br/>        <em class="mh">u</em>.update(<strong class="lz ir">company</strong>: user.companies.first)<br/>      <strong class="lz ir">end<br/>    end<br/>  end<br/>end</strong></span></pre><p id="bdca" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">那么您的模型将会更新如下:</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="4c83" class="kw kx iq lz b gy md me l mf mg"><strong class="lz ir">class <em class="mh">User </em></strong>&lt; <strong class="lz ir"><em class="mh">ApplicationRecord<br/>  </em></strong><em class="mh">belongs_to </em><strong class="lz ir">:company</strong>, <strong class="lz ir">optional</strong>: <strong class="lz ir">true<br/>end<br/><br/>class <em class="mh">Company </em></strong>&lt; <strong class="lz ir"><em class="mh">ApplicationRecord<br/>  </em></strong><em class="mh">has_many </em><strong class="lz ir">:users<br/>end</strong></span></pre><p id="fcf6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">可选性在这里很重要，因为在一段时间内，应用程序有两个成员身份的真实来源，但我们接受我们发现的第一个值可能是正确的。UI需要通过<code class="fe mi mj mk lz b">company_ids</code>停止更新，并开始接受<code class="fe mi mj mk lz b">user.company_id</code>是正确的值。所有真正的重构都将发生在那里。</p><p id="e58b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">想要我覆盖更多迁移路径吗？对Rails有疑问吗？在下面留言，我会更新文章。</p><p id="46fe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">干杯！</p></div></div>    
</body>
</html>