<html>
<head>
<title>Bluebird’s Bad-Practice Docs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">蓝鸟的不良行为记录</h1>
<blockquote>原文：<a href="https://itnext.io/bluebirds-bad-practice-docs-f9cc94b1af9?source=collection_archive---------3-----------------------#2019-03-03">https://itnext.io/bluebirds-bad-practice-docs-f9cc94b1af9?source=collection_archive---------3-----------------------#2019-03-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/f38947cf2a8d98adc4f755ba8249c231.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*AD6SOZ9rfOJz4dFx"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">照片由<a class="ae jd" href="https://unsplash.com/@bgauzere?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Benoit Gauzere </a>在<a class="ae jd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><div class=""/><div class=""><h2 id="31ae" class="pw-subtitle-paragraph kd jf jg bd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dk translated">Node.js开发人员使用的糟糕的最佳实践</h2></div><p id="ff02" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="lr">这篇文章颇有争议。我知道。我发表这篇文章是希望能让这个行业朝着积极的方向发展，但是我知道总有磨合期或者完全错误的可能性。</em></p><p id="1c8a" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">有很多promise库，但是到目前为止，最流行的，也可能是您将在产品中实际看到的，是Bluebird。这是一个很棒的promise库，有很多特性，但是有一个很大的缺陷。</p><h1 id="0061" class="ls lt jg bd lu lv lw lx ly lz ma mb mc km md kn me kp mf kq mg ks mh kt mi mj bi translated">名称又能代表什么呢</h1><p id="b378" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">不是作为<code class="fe mp mq mr ms b">Bluebird</code>导入的，官方文档和常用的是这样命名<code class="fe mp mq mr ms b">Promise</code>:</p><pre class="mt mu mv mw gt mx ms my mz aw na bi"><span id="5196" class="nb lt jg ms b gy nc nd l ne nf">const Promise = require('bluebird')</span><span id="59d8" class="nb lt jg ms b gy ng nd l ne nf">// or</span><span id="202e" class="nb lt jg ms b gy ng nd l ne nf">import Promise from 'bluebird'</span></pre><p id="d573" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是因为蓝鸟实际上早在承诺出现在JavaScript之前就出现了。虽然将它作为<code class="fe mp mq mr ms b">Promise</code>导入可以让你编写和你一直做的一样的承诺代码以及一些额外的东西，但这可能会让其他开发者非常困惑，因为不是所有的承诺都是蓝鸟承诺。</p><p id="cf9c" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">例如，如果你导入另一个使用承诺的库，它们就不是蓝鸟承诺。还有，如果你用<code class="fe mp mq mr ms b">fetch</code>那些也不会是蓝鸟的承诺。最后，如果你创建了自己的承诺，但忘记在应用程序的其他地方导入蓝鸟，那些<em class="lr">也</em>不会是蓝鸟承诺。</p><h2 id="0a43" class="nb lt jg bd lu nh ni dn ly nj nk dp mc le nl nm me li nn no mg lm np nq mi nr bi translated">覆盖所有的东西！</h2><p id="82ec" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">解决办法是用蓝鸟覆盖全球承诺。我反对这样做有很多原因，但其中之一是突然之间你的整个应用程序的JavaScript版本不再遵循规范。这是另一个会给你的项目带来新进展的事情，你必须解释清楚。</p><p id="d33d" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在重写JavaScript全局变量的过程中，还会遇到很多其他问题。在我看来，很难在使用和不使用蓝鸟的项目之间进行上下文切换。另一个是切换库的能力。一旦你把自己和蓝鸟绑在一起，你就被它缠住了。如果它有很大的安全漏洞呢？如果想用RxJS代替呢？你不能围绕它写作，而是强迫自己把它用在任何事情上。</p><h2 id="1e64" class="nb lt jg bd lu nh ni dn ly nj nk dp mc le nl nm me li nn no mg lm np nq mi nr bi translated">爱你的邻居(6个月后就是你)</h2><p id="b06b" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">我可能听起来很奇怪，因为今天很多人都这样使用蓝鸟，但从我的个人经验来看，我不建议这样做。一旦行业发生变化，你的应用程序现在使用传统技术，你就要为变化做好准备。</p><p id="c0b6" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这都是维护的问题。在某种程度上，用老方法(或者真的是错误的方法)做事会让雇佣新开发人员的成本更高。根据我的经验，当你要求开发人员处理遗留代码时，他们会希望这是暂时的，或者很快就会重写。</p><p id="1451" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">虽然您可能不希望同时使用本机实现和Bluebird，但我的建议是总是在您希望使用它的地方导入Bluebird，并总是将导入的库命名为<code class="fe mp mq mr ms b">Bluebird</code>，以向所有开发人员发出“我正在使用Bluebird promise库”的信号。</p><p id="eb6c" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">有了这样的改变，其他开发人员就不必每次在一个文件中时都猜测或不断检查Bluebird是否被导入到每个文件中。这样，你总是知道你有什么样的承诺。现在，您的应用程序可以随着时间的推移轻松维护和重构，而不用担心这个迫在眉睫的蓝鸟问题。</p><h1 id="2d7a" class="ls lt jg bd lu lv lw lx ly lz ma mb mc km md kn me kp mf kq mg ks mh kt mi mj bi translated">许诺</h1><p id="f3fc" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">像RxJS中的<code class="fe mp mq mr ms b">bindCallback</code>一样，您可以使用<code class="fe mp mq mr ms b">Promise.promisify</code>在承诺中自动包装回调函数。我在家里的灯光控制器软件的第一个版本中使用了这种方法，因为每当我想使用时，将回调转换为承诺会很累。</p><p id="5b39" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">另一方面，我不建议使用<code class="fe mp mq mr ms b">Promise.promisifyAll</code>。我知道它有它的用途，但是它改变了你给它的对象，我喜欢明确地说明这些事情，特别是因为现在你把你的常规库绑定到了蓝鸟上。我不喜欢改变Node.js库或者你的浏览器的<code class="fe mp mq mr ms b">window</code>对象，因为开发人员不会知道到底发生了什么。</p><h2 id="9bf6" class="nb lt jg bd lu nh ni dn ly nj nk dp mc le nl nm me li nn no mg lm np nq mi nr bi translated">我能有所有的问题吗？</h2><p id="5eb0" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">例如，开发人员可能会导入<code class="fe mp mq mr ms b">fs</code>原生Node.js库，却发现每个函数都有一个自定义的promisified async版本，该版本返回一个承诺而不是接受一个回调，并且代码库中没有任何内容与官方Node.js文档匹配。这是混淆视听的好方法。</p><p id="d012" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在承诺的版本后面加上“async”会使它更加混乱，因为从技术上来说<code class="fe mp mq mr ms b">fs.readFile</code>已经是异步的了，但是现在有了<code class="fe mp mq mr ms b">fs.readFileAsync</code>也是异步的，但是明确地承诺了。为什么不是<code class="fe mp mq mr ms b">fs.readFilePromisified</code>？太久了？也许你不应该变异<code class="fe mp mq mr ms b">fs</code>。</p><p id="ac36" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">换一种方式来说，现在有两种完全不同的方式来调用本地库上的函数。您不是将这些调用包装在您自己的实用程序文件中(这也有它的缺点)，而是依靠代码审查，可能是林挺规则，以及口碑来确保开发人员使用首选的方法。</p><p id="64f9" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">否则，您将拥有一个包含各种编码风格的大型代码库。总是留给下一个接手的开发人员一个头痛的问题，他想知道为什么这里是一种方式，而在另一个地方是完全不同的方式。</p><p id="f8d5" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果你在过去的20年里曾经使用过JavaScript，你会遇到同样的事情导致你的噩梦(你甚至可以覆盖<code class="fe mp mq mr ms b">undefined</code>)，并且在React流行起来的时候，它被羞愧地淘汰了。蓝鸟早于这种变化，但最新的文件也没有警告它；事实上，他们鼓励这样做。</p><p id="85c3" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">像这样改变图书馆和全球价值观是《T2》之后的活遗产。这是将您的项目与单个库捆绑在一起的好方法。</p><h1 id="8b2b" class="ls lt jg bd lu lv lw lx ly lz ma mb mc km md kn me kp mf kq mg ks mh kt mi mj bi translated">结论</h1><p id="bfb2" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">我知道这是有争议的。我希望使用蓝鸟的开发者有他们自己的恐怖故事，但事实是，我可能会得到很多负面反馈。如果你在我的评估中发现了缺陷，<strong class="kx jh">我鼓励你提供反馈</strong>，这样我就知道下次写文章时应该改进什么。</p><h1 id="cb04" class="ls lt jg bd lu lv lw lx ly lz ma mb mc km md kn me kp mf kq mg ks mh kt mi mj bi translated">更多阅读</h1><p id="40ee" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">如果你喜欢你所读的，请查看我关于类似的令人大开眼界的主题的其他文章:</p><ul class=""><li id="e1de" class="ns nt jg kx b ky kz lb lc le nu li nv lm nw lq nx ny nz oa bi translated"><a class="ae jd" rel="noopener ugc nofollow" target="_blank" href="/redux-observable-without-redux-ff4a2b5a4b39">无冗余的冗余可观察</a></li><li id="d2d2" class="ns nt jg kx b ky ob lb oc le od li oe lm of lq nx ny nz oa bi translated"><a class="ae jd" rel="noopener ugc nofollow" target="_blank" href="/feature-flags-be-truly-agile-820ff50294c">特性标志:真正敏捷</a></li><li id="f767" class="ns nt jg kx b ky ob lb oc le od li oe lm of lq nx ny nz oa bi translated"><a class="ae jd" rel="noopener ugc nofollow" target="_blank" href="/an-emoji-lovers-guide-to-functional-programming-part-1-241d8d4c9223">用食物表情符号制作便便</a></li><li id="86a2" class="ns nt jg kx b ky ob lb oc le od li oe lm of lq nx ny nz oa bi translated"><a class="ae jd" rel="noopener ugc nofollow" target="_blank" href="/using-transducers-to-speed-up-javascript-arrays-92677d000096">使用转换器加速JavaScript数组</a></li></ul></div></div>    
</body>
</html>