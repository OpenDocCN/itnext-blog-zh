<html>
<head>
<title>What to expect from Typescript 4.0 and more.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">对Typescript 4.0和更多版本的期待。</h1>
<blockquote>原文：<a href="https://itnext.io/what-is-new-in-typescript-4-0-and-more-6c5fa72fa1db?source=collection_archive---------2-----------------------#2020-08-21">https://itnext.io/what-is-new-in-typescript-4-0-and-more-6c5fa72fa1db?source=collection_archive---------2-----------------------#2020-08-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7a4b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">您应该开始使用的高级功能和技术。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/470841f620ba1799f4b868b3f78dfed0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sT_C_RJSm7C55mdsOwtgxQ.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/s/photos/timelapse?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae ky" href="https://unsplash.com/@ffstop?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Fotis Fotopoulos </a>拍摄</figcaption></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><p id="e6df" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">无论你是否在2020年使用Typescript，有一个不可否认的事实，那就是这种语言正在稳步发展和快速进化，为我们的应用程序带来了更多的便利和坚实的基础，而不必牺牲他们的可维护性。在写这篇文章的时候，这种语言已经有12，125，535的周下载量来自npmjs.com的T4。为了让你对这些数字有更全面的了解，React的周下载量为7，671，193次。</p><p id="23ae" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">此外，对最受喜爱的语言Stack Overflow的年度调查显示，今年Typescript上升了一个位置，取代了Python，获得了银牌，只让位于这个类别中的Rust。同样为了便于比较，在同一调查中，JavaScript今年排在第十位。</p><p id="b18e" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">我希望，如果您还在考虑是否应该深入研究Typescript，这几行文字已经说服了您。<br/>闲话少说，让我给你一个概述，看看你能从这篇文章中得到什么:</p><ul class=""><li id="1823" class="mc md it li b lj lk lm ln lp me lt mf lx mg mb mh mi mj mk bi translated">语言中的新内容和即将出现的内容。</li><li id="33c2" class="mc md it li b lj ml lm mm lp mn lt mo lx mp mb mh mi mj mk bi translated">最近一些有用的模式和实用程序的例子，可能不太为人所知，但肯定非常方便。</li></ul><h1 id="a1c0" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">让我们开始吧，Typescript有什么新特性？</h1><p id="92e1" class="pw-post-body-paragraph lg lh it li b lj ni ju ll lm nj jx lo lp nk lr ls lt nl lv lw lx nm lz ma mb im bi translated">最近，打字领域发生了很多事情。就在几天前，Typescript <a class="ae ky" href="https://www.typescriptlang.org/" rel="noopener ugc nofollow" target="_blank">主页</a>焕然一新，拥有更广泛、结构更好的文档，更新了TS playground，以及(我最喜欢的部分)所有可以在tsconfig文件中使用的标志的专用部分，其中有详细的解释和示例参考，您可以在这里找到<a class="ae ky" href="https://www.typescriptlang.org/tsconfig" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="b423" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">如果您正在使用Typescript，我强烈建议您花几分钟时间熟悉一下这个新网站。如果你正在考虑是否要从这门语言开始，这是一个更好的快速浏览文档的理由。</p><p id="19d1" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">除了完美的网站之外，4.0版本的发布候选也被公布了。在这里，你可以找到<a class="ae ky" href="https://devblogs.microsoft.com/typescript/announcing-typescript-4-0-rc/" rel="noopener ugc nofollow" target="_blank">的新功能和附加功能的完整列表。在接下来的几行中，我将尝试涵盖它最有趣的部分。</a></p><h2 id="d76f" class="nn mr it bd ms no np dn mw nq nr dp na lp ns nt nc lt nu nv ne lx nw nx ng ny bi translated">元组不再需要古怪而繁琐地键入</h2><p id="7abe" class="pw-post-body-paragraph lg lh it li b lj ni ju ll lm nj jx lo lp nk lr ls lt nl lv lw lx nm lz ma mb im bi translated">元组可以用一个现在可以扩展的通用元素来表示，这对于类型来说更加方便，因为我们不再需要预先知道实际的类型结构。</p><p id="125b" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">这将是一个有效的语法:</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="7d98" class="nn mr it oa b gy oe of l og oh">const returnTuple = (arg: Array&lt;unknown&gt;):[string, ...T]</span></pre><p id="a535" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">此外，我们现在可以将元素分散并放置在元组中的任何位置，例如:</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="ad0d" class="nn mr it oa b gy oe of l og oh">const returnTuple = (arg: Array&lt;unknown&gt;):[...T, string, ...R]</span></pre><p id="d7ad" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">或者换句话说，要扩展的元素不必再位于最后一个位置。在添加之前，如果我们试图扩展一个不是元组中最后一个的元素，我们会看到这个编译错误消息</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="c611" class="nn mr it oa b gy oe of l og oh"><strong class="oa iu">A rest element must be last in a tuple type.</strong></span></pre><p id="9a9e" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">tuple类型体验的另一个很好的补充是，我们现在可以在每个位置标记tuple元素。这里要记住的一点是，如果我们决定将标签附加到元组元素，那么元组的所有成员也应该有标签。</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="aa0d" class="nn mr it oa b gy oe of l og oh">type UserInput = [email: string, password: string]</span></pre><p id="6c35" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">Typescript 4.0带来了一些很好的文本编辑器改进，主要集中在VS代码上。<a class="ae ky" href="https://devblogs.microsoft.com/typescript/announcing-typescript-4-0-rc/#editor-improvements" rel="noopener ugc nofollow" target="_blank">这里的</a>是新版本即将推出的新增功能的完整列表。特别引起我注意的是可选链接的重构选项，这也是对Typescript的一个相当新的补充。</p><p id="e971" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">这个例子直接来自Typescript文档:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/10477f81fc4b4beb4f3852f0dde93adf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*oeNDud4egEasvOCwTeAhVA.gif"/></div></figure><p id="e25a" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">酷吧？😊关于VS代码的另一篮子好东西，请查看我的文章:</p><div class="oj ok gp gr ol om"><a href="https://medium.com/better-programming/how-to-configure-vs-code-like-a-pro-782d2d718586" rel="noopener follow" target="_blank"><div class="on ab fo"><div class="oo ab op cl cj oq"><h2 class="bd iu gy z fp or fr fs os fu fw is bi translated">如何像专业人士一样配置VS代码</h2><div class="ot l"><h3 class="bd b gy z fp or fr fs os fu fw dk translated">VS代码生产率的终极指南</h3></div><div class="ou l"><p class="bd b dl z fp or fr fs os fu fw dk translated">medium.com</p></div></div><div class="ov l"><div class="ow l ox oy oz ov pa ks om"/></div></div></a></div><h1 id="86a3" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">您之前承诺的那些有用的实用程序和模式呢？</h1><p id="9230" class="pw-post-body-paragraph lg lh it li b lj ni ju ll lm nj jx lo lp nk lr ls lt nl lv lw lx nm lz ma mb im bi translated">除了语言中新的和即将到来的改进，让我分享一些实用类型的帮助器和模式，你可能会觉得有趣和有用。</p><h2 id="91cc" class="nn mr it bd ms no np dn mw nq nr dp na lp ns nt nc lt nu nv ne lx nw nx ng ny bi translated"><code class="fe pb pc pd oa b">Record&lt;Keys,Type&gt;</code></h2><blockquote class="pe pf pg"><p id="1535" class="lg lh ph li b lj lk ju ll lm ln jx lo pi lq lr ls pj lu lv lw pk ly lz ma mb im bi translated">用类型<code class="fe pb pc pd oa b">Type</code>的一组属性<code class="fe pb pc pd oa b">Keys</code>构造一个类型。该实用工具可用于将一种类型的属性映射到另一种类型。</p></blockquote><p id="775e" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">或者换句话说，当我们想要更严格地键入任何对象(如数据结构)中的键时，Record实用程序类型特别有用。</p><p id="2ad5" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">这里有一个简单的例子来说明我们如何利用它:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pl"><img src="../Images/8e03ef9e97650c301af8a9ec5e73164d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ibHknleRgzo6yoMC03EgtA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">记录类型简单示例</figcaption></figure><p id="5468" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">当然，如果有必要，我们可以利用Record utility中的第二个参数来进一步扩展我们的类型签名:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pm"><img src="../Images/b6840215bc134e41152f50875479bb80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fnyuGCaPZ2QuzFqhzCo-mA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">记录类型示例扩展</figcaption></figure><h2 id="6ddc" class="nn mr it bd ms no np dn mw nq nr dp na lp ns nt nc lt nu nv ne lx nw nx ng ny bi translated"><strong class="ak">偏&lt;型&gt;型</strong></h2><blockquote class="pe pf pg"><p id="5752" class="lg lh ph li b lj lk ju ll lm ln jx lo pi lq lr ls pj lu lv lw pk ly lz ma mb im bi translated">构造一个类型，将<code class="fe pb pc pd oa b">Type</code>的所有属性设置为可选。该实用程序将返回一个表示给定类型的所有子集的类型。</p></blockquote><p id="0ada" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">当您处理动态数据并且响应包含您期望的类型数据集中的部分信息时，或者您只想部分使用给定的类型时(正如该实用程序的名称所暗示的那样)，这非常有用。下面的例子展示了第二种情况:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pn"><img src="../Images/48838e0bd8e45dbdc09c67963408e5ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bp0-m6tW1PcT4m0f_Q5ogg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">部分公用事业类型示例</figcaption></figure><p id="b69c" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">在这个例子中，我们有一个UserDataType接口，它保存了树的属性——名称、电子邮件和密码。接下来，我们将该接口分配给来自<strong class="li iu"> getUser </strong>函数的参数。通常，如果我们省略了<code class="fe pb pc pd oa b">Partial</code>的使用，Typescript编译器会抱怨我们没有传递足够的属性，但是由于我们利用了<strong class="li iu">部分&lt;类型&gt;类型</strong>类型实用程序，Typescript很高兴，因此我们也很高兴。</p><p id="2833" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">这个用例的另一种方法是用Typescript中全局可用的另一个实用程序类型来转换UserDataType <br/>。</p><h2 id="097b" class="nn mr it bd ms no np dn mw nq nr dp na lp ns nt nc lt nu nv ne lx nw nx ng ny bi translated"><code class="fe pb pc pd oa b">Pick&lt;Type, Keys&gt;</code></h2><blockquote class="pe pf pg"><p id="bf64" class="lg lh ph li b lj lk ju ll lm ln jx lo pi lq lr ls pj lu lv lw pk ly lz ma mb im bi translated">通过从<code class="fe pb pc pd oa b">Type</code>中选取属性集<code class="fe pb pc pd oa b">Keys</code>来构造类型。</p></blockquote><p id="c767" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">使用该语言提供的这一特性，我们前面的示例将如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi po"><img src="../Images/1ac714ccbc2b26f710269d3ccb91cf4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Je3m8t4cKKaz6eSv_onKuw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">选择实用程序类型</figcaption></figure><p id="181e" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">这里我们定义了一个新的类型UserPublicDataType，我们现在用它来定义用户参数数据类型的形状。</p><p id="11c1" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">我们可以采用另一种非常相似的方法来满足传递给用户参数的变量的类型需求，那就是使用实用程序类型:</p><h2 id="e85e" class="nn mr it bd ms no np dn mw nq nr dp na lp ns nt nc lt nu nv ne lx nw nx ng ny bi translated"><code class="fe pb pc pd oa b">Omit&lt;Type, Keys&gt;</code></h2><blockquote class="pe pf pg"><p id="ba0c" class="lg lh ph li b lj lk ju ll lm ln jx lo pi lq lr ls pj lu lv lw pk ly lz ma mb im bi translated">通过从<code class="fe pb pc pd oa b">Type</code>中选取所有属性，然后移除<code class="fe pb pc pd oa b">Keys</code>来构造一个类型。</p></blockquote><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pp"><img src="../Images/d6b79a583abe29b618de8ce0d80cdde3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Hb0KodKg0Myptzp81U8c_w.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">省略实用程序类型示例</figcaption></figure><p id="d0a3" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">有更多的实用程序助手可以使我们的生活更容易转换和塑造我们的数据类型。如果您感兴趣，请查看文档并了解更多信息<a class="ae ky" href="https://www.typescriptlang.org/docs/handbook/utility-types.html" rel="noopener ugc nofollow" target="_blank">点击此处</a>。</p><p id="8376" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">在本文的最后一部分，我想强调一种特别聪明的方法，Typescript可以从类型保护检查中检测和拾取正确的类型结构。</p><h2 id="42fe" class="nn mr it bd ms no np dn mw nq nr dp na lp ns nt nc lt nu nv ne lx nw nx ng ny bi translated">防护类型</h2><blockquote class="pe pf pg"><p id="7745" class="lg lh ph li b lj lk ju ll lm ln jx lo pi lq lr ls pj lu lv lw pk ly lz ma mb im bi translated">类型保护是一些执行运行时检查的表达式，它保证类型在某个范围内。</p></blockquote><p id="8be8" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">通常在谓词表达式中使用类型保护来帮助我们确定表达式是否满足某个标准。<br/>有一些不同类型的安全检查可供我们使用，在这里找到所有这些检查。</p><p id="3324" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">接下来的例子有望澄清到底什么是类型保护，以及我们如何利用这种模式。</p><p id="5c2f" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">这次让我们一步一步来，让一切变得非常简单。</p><p id="20dc" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">首先，让我们假设我们必须处理两组非常接近的数据类型，但是我们需要一种方法来区分它们。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pq"><img src="../Images/08fe1d4c3c96ce8122ac9530ae066136.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cllMIA4Uf_TS8YXCz3JnYg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">定义类型</figcaption></figure><p id="dc8a" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">让我们想象一下，我们正在从一个外部数据源获取一个数据，<br/>,由于某种原因，数据集可以是User类型或者Person类型。<br/>获取数据后，我们需要将其传递给一个子组件，该子组件必须打印出接收到的数据。</p><p id="7e5d" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">这里的问题现在应该很明显了，我们如何确定我们实际收到的是哪种数据类型并打印出正确的属性？<br/>型守卫前来救援，在我们的if检查中使用操作符中的<strong class="li iu">将解决我们的类型问题。</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pr"><img src="../Images/3fab1e3dd6cef2311cec762c8d2107bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y44R3TGI4kS0huFfgzPnEQ.png"/></div></div></figure><p id="e58a" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">Typescript足够智能，可以检测我们传递给函数的数据是否包含User类型的name属性或Person类型的firstname属性，因此函数总是可以返回正确的问候消息。</p><h2 id="3745" class="nn mr it bd ms no np dn mw nq nr dp na lp ns nt nc lt nu nv ne lx nw nx ng ny bi translated">最后的话</h2><p id="6a0a" class="pw-post-body-paragraph lg lh it li b lj ni ju ll lm nj jx lo lp nk lr ls lt nl lv lw lx nm lz ma mb im bi translated">好了，这就是我现在的观点，真的希望你会发现这篇文章很有用，它会让你的打字体验更好。</p><p id="911f" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">享受快乐的黑客生涯！👨‍💻⌨️👩‍💻</p></div></div>    
</body>
</html>