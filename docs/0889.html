<html>
<head>
<title>Kubernetes: Readiness Probe</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes:就绪探测</h1>
<blockquote>原文：<a href="https://itnext.io/kubernetes-readiness-probe-83f8a06d33d3?source=collection_archive---------5-----------------------#2018-06-13">https://itnext.io/kubernetes-readiness-probe-83f8a06d33d3?source=collection_archive---------5-----------------------#2018-06-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="6476" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果对这个特性有任何疑问，我写这篇文章是为了说明这不是一个可选的特性，而是一个必须实现的特性。好吧，一切都是可选的，但是如果您希望您的Kubernetes集群按照您想要的方式运行，那么您最好实现一个就绪探测器。最棒的是，这是一个相当容易添加到代码中的特性。对于准备就绪探测，我们需要将代码添加到Pod YAML文件和运行在Docker容器中的应用程序代码中。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi kl"><img src="../Images/c91a2004b335018f83c57b744f233a8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*rAt1jPpKFnf7y_jRQrBzWg.gif"/></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">准备好了。</figcaption></figure><h1 id="bd77" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">为什么我们要添加准备就绪探测器？</h1><p id="2a8f" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">现在我们已经有了在必要时自动扩展的<a class="ae ma" href="https://medium.com/@jonbcampos/kubernetes-horizontal-pod-scaling-190e95c258f5" rel="noopener">单元，我们的集群将在它认为合适的时候添加单元。一旦添加了一个单元，群集就需要来自该单元的信息，该单元已准备好开始将流量路由到该单元。现在，如果您的微服务需要在准备就绪之前完成配置查找或其他一些过程，那么您需要让Kubernetes知道它应该何时开始将请求路由到Pod。如果您跳过准备就绪探测，并且您的Pod立即获得路由到它的流量，并且您的Pod被确定为不健康，那么Kubernetes将继续重新启动您的Pod。这是个可怕的消息。相反，我们可以做一些简单的事情，添加一个</a><a class="ae ma" href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-probes/#define-readiness-probes" rel="noopener ugc nofollow" target="_blank">就绪探测器</a>。</p><p id="80a5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mb">如果你没有通读甚至没有读过本系列</em>  <em class="mb">的第一部分</em> <a class="ae ma" href="https://medium.com/@jonbcampos/kubernetes-day-one-30a80b5dcb29" rel="noopener"> <em class="mb">，你可能会感到困惑，对代码在哪里或者之前做了什么有疑问。记住这里假设你正在使用</em></a><a class="ae ma" href="https://cloud.google.com/" rel="noopener ugc nofollow" target="_blank"><em class="mb">GCP</em></a><em class="mb">和</em><a class="ae ma" href="https://cloud.google.com/kubernetes-engine/" rel="noopener ugc nofollow" target="_blank"><em class="mb">GKE</em></a><em class="mb">。我将始终提供代码和如何测试代码是按预期工作。</em></p><div class="mc md gp gr me mf"><a href="https://medium.com/@jonbcampos/kubernetes-day-one-30a80b5dcb29" rel="noopener follow" target="_blank"><div class="mg ab fo"><div class="mh ab mi cl cj mj"><h2 class="bd ir gy z fp mk fr fs ml fu fw ip bi translated">Kubernetes:第一天</h2><div class="mm l"><h3 class="bd b gy z fp mk fr fs ml fu fw dk translated">这是Kubernetes帖子的必选步骤之一。如果你对Kubernetes感兴趣，你可能已经读过100本了…</h3></div><div class="mn l"><p class="bd b dl z fp mk fr fs ml fu fw dk translated">medium.com</p></div></div><div class="mo l"><div class="mp l mq mr ms mo mt kr mf"/></div></div></a></div><h1 id="46e6" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">服务码</h1><p id="63f0" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">对于我的例子，代码很简单…非常简单。它基本上不做任何事情，接受开始返回200个响应。我相信您可以想办法调用其他服务，并在用200 response进行响应之前设置一个状态。</p><pre class="km kn ko kp gt mu mv mw mx aw my bi"><span id="bc98" class="mz ky iq mv b gy na nb l nc nd">app.use('/readiness', function (req, res, next) {<br/>    res.status(200).json({ ready: true });<br/>});</span></pre><p id="8724" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从我之前提供的<a class="ae ma" href="https://github.com/jonbcampos/kubernetes-series/blob/master/partone/app.js#L29-L31" rel="noopener ugc nofollow" target="_blank">申请代码</a>中。</p><h2 id="9bdc" class="mz ky iq bd kz ne nf dn ld ng nh dp lh jy ni nj ll kc nk nl lp kg nm nn lt no bi translated">我必须使用HTTP请求吗？</h2><p id="5738" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">不。在Pod定义中，您可以使用HTTP请求(可能是最简单的选项)，也可以设置TCP探测，甚至运行命令脚本来验证您的Pod正在运行。你有很多选择，我只喜欢最简单的一个。</p><h1 id="ef20" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">Pod定义</h1><p id="4614" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">对Pod定义的更改非常小，只需一会儿就能完成。我们只需要说明在哪里以及如何测试我们的吊舱的准备状态。我在代码中添加了注释，以显示所有可以定制探针的地方。</p><pre class="km kn ko kp gt mu mv mw mx aw my bi"><span id="1a9d" class="mz ky iq mv b gy na nb l nc nd"># the readiness probe details<br/><strong class="mv ir">readinessProbe:</strong><br/>  <strong class="mv ir">httpGet:</strong> # make an HTTP request<br/>    <strong class="mv ir">port: 8080</strong> # port to use<br/>    <strong class="mv ir">path: /readiness</strong> # endpoint to hit<br/>    <strong class="mv ir">scheme: HTTP</strong> # or HTTPS<br/>  <strong class="mv ir">initialDelaySeconds: 3</strong> # how long to wait before checking<br/>  <strong class="mv ir">periodSeconds: 3</strong> # how long to wait between checks<br/>  <strong class="mv ir">successThreshold: 1</strong> # how many successes to hit before accepting<br/>  <strong class="mv ir">failureThreshold: 1</strong> # how many failures to accept before failing<br/>  <strong class="mv ir">timeoutSeconds: 1</strong> # how long to wait for a response</span></pre><p id="4374" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">根据我之前提供的<a class="ae ma" href="https://github.com/jonbcampos/kubernetes-series/blob/master/partone/k8s/deployment.yaml#L29-L39" rel="noopener ugc nofollow" target="_blank">Pod/部署定义</a>。</p><h1 id="7a98" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">后续步骤</h1><p id="7805" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">在我的第一篇文章中，我承诺过这些细节可能会很短。这是一篇我已经知道会很短但很重要的文章。如果你刚刚进入Kubernetes，还没有看到准备就绪探针，或者也许这是一个你认为不重要的特性，它是重要的和必要的。在发布之前把这个添加到你的默认清单中——即使它不是Kubernetes提供的最性感的特性。</p></div><div class="ab cl np nq hu nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="ij ik il im in"><h1 id="15d7" class="kx ky iq bd kz la nw lc ld le nx lg lh li ny lk ll lm nz lo lp lq oa ls lt lu bi translated">本系列的其他文章</h1><div class="mc md gp gr me mf"><a href="https://medium.com/@jonbcampos/kubernetes-day-one-30a80b5dcb29" rel="noopener follow" target="_blank"><div class="mg ab fo"><div class="mh ab mi cl cj mj"><h2 class="bd ir gy z fp mk fr fs ml fu fw ip bi translated">Kubernetes:第一天</h2><div class="mm l"><h3 class="bd b gy z fp mk fr fs ml fu fw dk translated">这是Kubernetes帖子的必选步骤之一。如果你对Kubernetes感兴趣，你可能已经读过100本了…</h3></div><div class="mn l"><p class="bd b dl z fp mk fr fs ml fu fw dk translated">medium.com</p></div></div><div class="mo l"><div class="mp l mq mr ms mo mt kr mf"/></div></div></a></div><div class="mc md gp gr me mf"><a href="https://medium.com/@jonbcampos/kubernetes-horizontal-pod-scaling-190e95c258f5" rel="noopener follow" target="_blank"><div class="mg ab fo"><div class="mh ab mi cl cj mj"><h2 class="bd ir gy z fp mk fr fs ml fu fw ip bi translated">Kubernetes:水平Pod缩放</h2><div class="mm l"><h3 class="bd b gy z fp mk fr fs ml fu fw dk translated">通过Pod自动扩展，您的Kubernetes集群可以监控现有Pod的负载，并确定我们是否需要更多…</h3></div><div class="mn l"><p class="bd b dl z fp mk fr fs ml fu fw dk translated">medium.com</p></div></div><div class="mo l"><div class="ob l mq mr ms mo mt kr mf"/></div></div></a></div><div class="mc md gp gr me mf"><a href="https://medium.com/@jonbcampos/kubernetes-cluster-autoscaler-f1948a0f686d" rel="noopener follow" target="_blank"><div class="mg ab fo"><div class="mh ab mi cl cj mj"><h2 class="bd ir gy z fp mk fr fs ml fu fw ip bi translated">Kubernetes:集群自动缩放</h2><div class="mm l"><h3 class="bd b gy z fp mk fr fs ml fu fw dk translated">自动缩放是Kubernetes的一个巨大的(并且已经上市的)特性。当你的网站/应用程序/应用程序接口/项目变得越来越大时，洪水…</h3></div><div class="mn l"><p class="bd b dl z fp mk fr fs ml fu fw dk translated">medium.com</p></div></div><div class="mo l"><div class="oc l mq mr ms mo mt kr mf"/></div></div></a></div></div><div class="ab cl np nq hu nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="ij ik il im in"><p id="66db" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae ma" href="http://jonbcampos.com/" rel="noopener ugc nofollow" target="_blank"> Jonathan Campos </a>是一个狂热的开发者，喜欢学习新事物。我相信我们应该不断学习、成长和失败。我总是开发社区的支持者，并且总是愿意提供帮助。因此，如果你对这个故事有任何问题或意见，请在下面提出。在<a class="ae ma" href="https://www.linkedin.com/in/jonbcampos/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>或<a class="ae ma" href="https://twitter.com/jonbcampos" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上与我联系，并提及这个故事。</p></div></div>    
</body>
</html>