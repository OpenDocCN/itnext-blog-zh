<html>
<head>
<title>Introducing Bliz.js 0.2.0</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Bliz.js 0.2.0简介</h1>
<blockquote>原文：<a href="https://itnext.io/introducing-bliz-js-0-2-0-6df3b1666e9d?source=collection_archive---------9-----------------------#2018-05-30">https://itnext.io/introducing-bliz-js-0-2-0-6df3b1666e9d?source=collection_archive---------9-----------------------#2018-05-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="e7c5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">用于编写web服务器的快速声明式框架，没有taradiddles。</p><p id="0032" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae km" href="https://github.com/yuraxdrumz/Bliz" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> Bliz </strong> </a>支持HTTP服务器、带Socket.io的实时服务器和带远程模式拼接的GraphQL服务器。</p><h1 id="169a" class="kn ko iq bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated"><strong class="ak">问题</strong></h1><p id="5574" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">起初，我想了解像express.js和koa.js这样流行的web服务器框架是如何工作的，在这个过程中，我意识到我可以创建一些东西，让我自己和我的公司编写web服务器变得更加容易，特别是使用Graphql。如果你有时在一家超过500人的公司工作，你会知道融入新的想法、架构风格和语言是很难的，因为，坦率地说，没有人有时间，所以我想，为什么不把Node的本地http模块、socket.io和graphql工具包装成一些声明性的和易于使用的东西，这样当人们看到它时就不会害怕，我可以以某种方式推动我们的公司达到甚至更好的实践和有点类似的代码库。</p><h1 id="bcbc" class="kn ko iq bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">解决方案</h1><p id="c6de" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated"><a class="ae km" href="https://github.com/yuraxdrumz/Bliz" rel="noopener ugc nofollow" target="_blank"> Bliz.js </a>是一个框架，它允许您立即创建HTTP/Socket.io/GraphQL服务器，并且没有额外的依赖性。</p><p id="ab20" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您不必考虑为什么应该使用这个或那个包，您可以专注于编写您的服务器，Bliz将在幕后为您处理引导和创建一切。所有这些都包含在可链接的函数和增强模块化的编码风格中。</p><p id="5484" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个图书馆不是:</p><ol class=""><li id="4ee6" class="lq lr iq jp b jq jr ju jv jy ls kc lt kg lu kk lv lw lx ly bi translated">它在它的纸尿裤里(0.2.0版本)，所以在1.0.0版本发布之前，我不建议在生产中使用它(我希望它会很快出现)。支持将不胜感激！</li><li id="61dc" class="lq lr iq jp b jq lz ju ma jy mb kc mc kg md kk lv lw lx ly bi translated">它没有渲染引擎或类似的东西，它纯粹是用来创建Restful/realtime/graphql API的。也许以后会改变。</li></ol><p id="b88d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们来看几个GraphQL服务器的例子。注意，为了使用Bliz，您必须了解GraphQL是如何工作的。你可以在这里阅读更多关于GraphQL <a class="ae km" href="https://graphql.org/learn/" rel="noopener ugc nofollow" target="_blank">的内容。关于Bliz的http/socket.io服务器的例子，请查看Github的自述文件。</a></p><p id="c531" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将创建一个简单的带有订阅和突变的食品递送fetcher graphql API。我们的送货车将按楼层划分。以下是流程的概述</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi me"><img src="../Images/69a725932eef616487eb4e45fe33ab15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r8epkdYXm-sb9ETluYnxzQ.png"/></div></div></figure><p id="e333" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">结构看起来会像这样</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/2fa3072c8f4e93beb6c6980f89cc3b10.png" data-original-src="https://miro.medium.com/v2/resize:fit:384/format:webp/1*1fkZVTIpWxEIlY-kAMu5nw.png"/></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">文件夹结构</figcaption></figure><p id="1677" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的Schema.js有一个带有几个字段的餐馆类型。</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/5821f98b9a8d0d8887992773af3adc4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1016/format:webp/1*LM3pQ5DeMcZPjgEqcqik7Q.png"/></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">schema.js</figcaption></figure><p id="5760" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们像一个常规的GraphQL模式一样定义我们的模式，不要介意重写<a class="ae km" href="https://graphql.org/learn/queries/#directives" rel="noopener ugc nofollow" target="_blank">指令</a>，一旦文档准备好，就会有一个关于如何将它们添加到您的项目的好例子。</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/f6b30cd6801d532d981f2c6a711566f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1358/format:webp/1*PmH5TGjR5jZXtvDCRVFfWg.png"/></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">resolver.js</figcaption></figure><p id="bcbb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的Resolvers.js文件具有标准查询，该查询根据我们经过的楼层返回餐馆。餐馆对象有自己的字段解析器，以防您需要定制字段格式，最后我们有变异和订阅。</p><p id="fe6a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意Bliz为变异和订阅注入了pubsub和withFilter辅助函数。注入的pubsub是一个本地事件发射器，尽管您可以添加自己的pubsub实现，如Redis pubsub，只要它实现了<a class="ae km" href="https://scotch.io/tutorials/getting-started-with-asynchronous-iterators-and-generators" rel="noopener ugc nofollow" target="_blank"> AsyncIterator </a>。</p><p id="fee8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们只需发布一个关于突变的事件，并在订阅中订阅它，就这样:)</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/ae0279257dd0430bc062a5f09f74c6bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1270/format:webp/1*1VolQa7879qdUE7sfma74w.png"/></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">餐厅索引. js</figcaption></figure><p id="901e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的Restaurant-index.js结合了我们的模式和解析器，请注意我们是如何将主应用程序传递给它的。这种写作风格使你所有的代码模块化，更易测试。</p><p id="57e2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们在这里声明我们的查询、变异和订阅。这样我们就知道在API中处理餐馆时使用什么模式、什么解析器以及会发生什么。</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div class="gh gi my"><img src="../Images/4d59137be28a0fc587b6a33eb851a9cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1138/format:webp/1*McljZ5NFlD2Xpl-S6Lvx5Q.png"/></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">主索引. js</figcaption></figure><p id="c350" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的主index.js只是通过一个工厂函数创建了一个新的Bliz实例。注意我们链接了pretty print()——这个函数打印所有的web socket事件(如果你有注册的话)和所有的http路由(如果你有http服务器的话)。Bliz有很多可用的选项和配置，一旦完成，所有的东西都会在文档中。</p><p id="febe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们注册了我们的餐馆模式，我们有一个graphql服务器在端口4000上运行，带有graphiql playground和ws://localhost:4000/subscriptions，自动提供一些实时的好处。</p><h1 id="0511" class="kn ko iq bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">Bliz微服务</h1><p id="b773" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">Bliz允许您立即创建像上面的餐馆服务这样的微服务，这要感谢幕后的GraphQL模式拼接。让我们看看如何创建一个网关来将所有这些微服务合并为一个。</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi mz"><img src="../Images/011cd68e2787ad24842187d7d453f058.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JcveW-mH1fGHzxPiPxoE2w.png"/></div></div></figure><p id="3488" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">假设我们有两个服务在运行，我们如何查询这两个服务并从客户端抽象出来？我们简单地称Bliz的registerRemoteGraphQlSchemas。</p><p id="7066" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在你在这两个服务上的所有东西都将通过网关传递，包括订阅。</p><h1 id="1fdd" class="kn ko iq bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">结论</h1><p id="6d5b" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">我们让人们用不同的风格和软件包编写不同的软件。后来我们看到<a class="ae km" href="https://github.com/yuraxdrumz/Bliz" rel="noopener ugc nofollow" target="_blank"> Bliz </a>允许在很短的时间内创建各种API，没有依赖性，也没有太多代码。所有后者对于人们快速开始编写软件是至关重要的，我希望Bliz将有助于创建更容易和更易维护的API。</p><h1 id="f80f" class="kn ko iq bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">附言</h1><p id="20a4" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">使用Bliz有许多测试要写，文档要创建，更改要做，项目要构建。所有的贡献都将受到欢迎，我希望我们能一起创造一些惊人的东西。请随意克隆项目，并提交带有修复/想法/特性的pull请求。</p></div></div>    
</body>
</html>