<html>
<head>
<title>Scalable state management for Flutter apps with Stacked architecture</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">具有堆叠架构的Flutter应用的可扩展状态管理</h1>
<blockquote>原文：<a href="https://itnext.io/scalable-state-management-on-flutter-using-stacked-architecture-ac2a5d419eaa?source=collection_archive---------2-----------------------#2022-01-12">https://itnext.io/scalable-state-management-on-flutter-using-stacked-architecture-ac2a5d419eaa?source=collection_archive---------2-----------------------#2022-01-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/0f000fe8bb0ebe66792986cf886983b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DGfAFtqhjeya7SWNRSJuWw.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">来源:Unsplash | <a class="ae kc" href="https://unsplash.com/photos/VurHDpO4VYI" rel="noopener ugc nofollow" target="_blank">链接</a></figcaption></figure><h1 id="955c" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">介绍</h1><p id="11c3" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">你好。今天，我想分享一个关于使用Flutter进行状态管理的简单指南，在这种情况下，如何以一种可伸缩和干净的方式在多个小部件之间共享状态。</p><p id="40fc" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">简而言之，如何在不同的窗口小部件上用相同的值同时调用setState()函数，而不会在代码✨.中造成混乱</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi me"><img src="../Images/c40a55eb02ec238deca5428b04fea065.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ovtIE517GalPguSb6K9Gyw.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">来源:Unsplash | <a class="ae kc" href="https://unsplash.com/photos/4h0HqC3K4-c" rel="noopener ugc nofollow" target="_blank">链接</a></figcaption></figure><h1 id="fda6" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">一些方法</h1><h2 id="a1c0" class="mj ke iq bd kf mk ml dn kj mm mn dp kn lm mo mp kr lq mq mr kv lu ms mt kz mu bi translated">回调注入</h2><p id="5127" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">一种简单的方法是从父部件向子部件发送回调。由于Flutter应用程序只是一个小部件树，在某些时候两个小部件总是有一个共同的父部件，在那里你可以用<em class="mv"> setState() </em>调用创建一个函数，并通过构造函数参数注入回调。</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="68f6" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">但是这种方法根本不可伸缩，并且总是会产生副作用，因为我们失去了对状态的一点控制。</p><h2 id="0cf0" class="mj ke iq bd kf mk ml dn kj mm mn dp kn lm mo mp kr lq mq mr kv lu ms mt kz mu bi translated">带有ValueNotifier的全局变量</h2><p id="7e41" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">众所周知，当涉及到代码时，全局变量几乎从来都不是一个好主意，你不希望从应用程序的任何地方访问变量，因为这使得代码耦合，并且对于项目的新开发人员来说难以维护和理解。</p><p id="ad9c" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">尤其是当正在讨论的全局变量可以更新和重新呈现应用程序UI时。</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="mw mx l"/></div></figure><h2 id="163a" class="mj ke iq bd kf mk ml dn kj mm mn dp kn lm mo mp kr lq mq mr kv lu ms mt kz mu bi translated">继承的小部件</h2><p id="f882" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">这是Flutter团队提供的开箱即用的标准方法，继承的小部件方法的问题是，它需要大量的样板代码来设置，有时特定情况下的实现会变得非常困难。</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="mw mx l"/></div></figure><h2 id="1c37" class="mj ke iq bd kf mk ml dn kj mm mn dp kn lm mo mp kr lq mq mr kv lu ms mt kz mu bi translated">国家管理图书馆</h2><p id="ac3e" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">这是标准的方式，也是大多数应用程序的归宿。在这种情况下，我们可以使用应用程序的上下文跨多个小部件管理应用程序的状态，这方面的一些例子是<em class="mv"> Provider </em>和<em class="mv"> Bloc </em>库，它们都被社区广泛使用和推荐。</p><p id="aea8" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">但是，即使它们非常标准，这些方法仍然存在问题，其中之一是没有解决每个状态管理场景的标准方法，它们提供了工具，但是“<em class="mv">如何</em>”取决于开发人员，对我来说，这导致了大型应用程序中的不一致性，特别是当应用程序由大型团队开发时。</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">使用提供程序库的状态管理示例。</figcaption></figure><h1 id="8d98" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">堆叠架构</h1><p id="4d73" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">一旦我们理解了其他方法的优缺点，我想介绍一个我发现的非常好的方法，通过使用<strong class="ld ir">堆叠架构</strong>来保持代码的高质量、整洁和可伸缩性。</p><p id="4419" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">该架构基于MVVM架构模式，其中每个<em class="mv"> V </em> <strong class="ld ir"> <em class="mv">视图</em> </strong>都有其对应的<em class="mv"> V </em> <strong class="ld ir"> <em class="mv">视图模型</em> </strong>，视图的唯一职责是显示UI，视图模型的职责是处理逻辑、状态管理和服务与API的交互。</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">请注意，即使我们使用的是无状态小部件，UI仍然是反应式的。</figcaption></figure><h2 id="5e0b" class="mj ke iq bd kf mk ml dn kj mm mn dp kn lm mo mp kr lq mq mr kv lu ms mt kz mu bi translated">状态管理</h2><p id="9c29" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">该架构中的状态管理是基于提供者的，通过使用来自<em class="mv"> Viewmodel </em>类的<em class="mv"> notifyListeners() </em>函数来更新视图的状态并重建UI，但是状态仍然只更新其对应的<em class="mv">视图</em>的UI(参见前面的代码示例)。</p><p id="67de" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">由于<em class="mv">视图-视图模型</em>是一对一的关系(每个<em class="mv">视图</em>可以与一个并且只有一个<em class="mv">视图模型</em>交互，反之亦然)，我们不能为两个不同的<em class="mv">视图</em>共享同一个<em class="mv">视图模型</em>，但是我们能做的是使用<strong class="ld ir"><em class="mv"/></strong>反应服务在<em class="mv">视图模型</em>之间创建一个连接点。</p><p id="9957" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">一个<strong class="ld ir"/></p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="mw mx l"/></div></figure><h1 id="3d44" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">结论</h1><p id="0388" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">当我编码时，我是可伸缩性、整洁性和简单性的忠实粉丝，对我来说，堆叠架构提供了最好的方式来实现跨所有应用程序的状态管理，照顾到所有这些特性。</p><p id="11ea" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">如果你是一个即将开始一个大项目的Flutter开发者，并且你喜欢学习新的方法来解决老问题，我真的鼓励你尝试这个架构。我保证你不会后悔的😄。</p></div></div>    
</body>
</html>