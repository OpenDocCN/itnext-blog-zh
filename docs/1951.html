<html>
<head>
<title>NodeJS logging made right</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">NodeJS日志记录正确</h1>
<blockquote>原文：<a href="https://itnext.io/nodejs-logging-made-right-117a19e8b4ce?source=collection_archive---------0-----------------------#2019-03-01">https://itnext.io/nodejs-logging-made-right-117a19e8b4ce?source=collection_archive---------0-----------------------#2019-03-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/f7b7a90427b7472671ef5f889a42814b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*McTrR6jBQNwwBxHV6Ehy7Q.jpeg"/></div></div></figure><p id="8944" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">&gt;我现在有了一个闪亮的新博客。阅读这篇文章，了解https://blog.goncharov.page/nodejs-logging-made-right的最新动态</p><p id="a97e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当你考虑登录NodeJS的时候，最困扰你的是什么？如果你问我，我会说缺乏创建跟踪id的行业标准。在本文中，我们将概述如何创建这些跟踪id(这意味着我们将简要研究延续本地存储(也称为<a class="ae kw" href="https://github.com/jeff-lewis/cls-hooked" rel="noopener ugc nofollow" target="_blank"> CLS </a>如何工作)，并深入探讨如何利用<a class="ae kw" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy" rel="noopener ugc nofollow" target="_blank">代理</a>使其与任何日志记录器一起工作。</p><h1 id="9b1c" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">为什么NodeJS中的每个请求都有一个跟踪ID甚至是一个问题？</h1><p id="6d34" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">在使用多线程并为每个请求产生一个新线程的平台上。有一种东西叫做<a class="ae kw" href="https://en.wikipedia.org/wiki/Thread-local_storage" rel="noopener ugc nofollow" target="_blank">线程本地存储，也称为TLS </a>，它允许在一个线程内保存任何任意数据。如果您有一个本地API来完成这项工作，那么为每个请求生成一个随机ID是非常简单的，将它放在TLS中，稍后在您的控制器或服务中使用它。NodeJS是怎么回事？如您所知，NodeJS是一个单线程平台(不再是真的，因为我们现在有工人，但这不会改变大局)，这使得TLS过时了。NodeJS不是操作不同的线程，而是在同一个线程中运行不同的回调函数(如果你感兴趣，NodeJS中有一个关于事件循环的<a class="ae kw" href="https://jsblog.insiderattack.net/event-loop-and-the-big-picture-nodejs-event-loop-part-1-1cb67a182810" rel="noopener ugc nofollow" target="_blank">系列文章</a>), NodeJS为我们提供了一种方法来唯一地识别这些回调函数并追踪它们之间的关系。</p><p id="fbef" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">回到过去(v0.11.11 ),我们有<a class="ae kw" href="https://nodejs.org/docs/v0.11.11/api/process.html#process_async_listeners" rel="noopener ugc nofollow" target="_blank"> addAsyncListener </a>,它允许我们跟踪异步事件。基于它<a class="ae kw" href="https://github.com/othiym23" rel="noopener ugc nofollow" target="_blank"> Forrest Norvell </a>构建了<a class="ae kw" href="https://github.com/othiym23/node-continuation-local-storage" rel="noopener ugc nofollow" target="_blank">延续本地存储的第一个实现，又名CLS </a>。我们不打算讨论CLS的实现，因为作为开发者，我们在v0.12中已经去掉了这个API。</p><p id="1d71" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在NodeJS 8之前，我们没有正式的方法来连接NodeJS的异步事件处理。最后，NodeJS 8通过<a class="ae kw" href="https://nodejs.org/docs/latest-v11.x/api/async_hooks.html" rel="noopener ugc nofollow" target="_blank"> async_hooks </a>赋予了我们失去的能力(如果你想更好地理解async_hooks，看看<a class="ae kw" rel="noopener ugc nofollow" target="_blank" href="/a-pragmatic-overview-of-async-hooks-api-in-node-js-e514b31460e9">这篇文章</a>)。这就把我们带到了现代的基于async_hooks的CLS实现——<a class="ae kw" href="https://github.com/Jeff-Lewis/cls-hooked" rel="noopener ugc nofollow" target="_blank">cls-hooked</a>。</p><h1 id="1bf9" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">CLS概述</h1><p id="5f65" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">以下是CLS工作原理的简化流程:</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ma"><img src="../Images/39e9391720d55f1b73edde35017ac2af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PPk_uEmQFVKO16byHpwnXA.jpeg"/></div></div></figure><p id="fb99" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们一步一步地分解它:</p><ol class=""><li id="560a" class="mf mg iq ka b kb kc kf kg kj mh kn mi kr mj kv mk ml mm mn bi translated">比方说，我们有一个典型的web服务器。首先，我们必须创建一个CLS命名空间。在我们应用程序的整个生命周期中一次。</li><li id="30a5" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated">其次，我们必须配置一个中间件，为每个请求创建一个新的CLS上下文。为了简单起见，让我们假设这个中间件只是一个回调函数，在接收到一个新请求时被调用。</li><li id="9036" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated">所以当一个新的请求到达时，我们调用回调函数。</li><li id="46fa" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated">在该函数中，我们创建一个新的CLS上下文(方法之一是使用<a class="ae kw" href="https://github.com/jeff-lewis/cls-hooked#namespaceruncallback" rel="noopener ugc nofollow" target="_blank">运行</a> API调用)。</li><li id="9231" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated">此时，CLS通过<a class="ae kw" href="https://nodejs.org/api/async_hooks.html#async_hooks_async_hooks_executionasyncid" rel="noopener ugc nofollow" target="_blank">当前执行ID </a>将新的上下文放入上下文映射中。</li><li id="23f1" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated">每个CLS命名空间都有<code class="fe mt mu mv mw b">active</code>属性。在这个阶段，CLS将<code class="fe mt mu mv mw b">active</code>分配给上下文。</li><li id="0a0c" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated">在上下文内部，我们调用一个异步资源，比方说，我们从数据库请求一些数据。我们向该调用传递一个回调，该调用将在对数据库的请求完成后运行。</li><li id="220f" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated"><a class="ae kw" href="https://nodejs.org/api/async_hooks.html#async_hooks_init_asyncid_type_triggerasyncid_resource" rel="noopener ugc nofollow" target="_blank"> init </a>为新的异步操作触发异步挂钩。它通过async ID将当前上下文添加到上下文映射中(将其视为新异步操作的标识符)。现在在这个映射中，我们两个id指向同一个上下文。</li><li id="07b4" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated">因为我们在第一个回调函数中没有更多的逻辑，所以它退出了，有效地结束了我们的第一个异步操作。</li><li id="697e" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated"><a class="ae kw" href="https://nodejs.org/api/async_hooks.html#async_hooks_after_asyncid" rel="noopener ugc nofollow" target="_blank">在</a>第一次回调触发异步挂钩之后。它将名称空间上的活动上下文设置为<code class="fe mt mu mv mw b">undefined</code>(这并不总是正确的，因为我们可能有多个嵌套上下文，但对于最简单的情况来说，这是正确的)。</li><li id="31cb" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated"><a class="ae kw" href="https://nodejs.org/api/async_hooks.html#async_hooks_destroy_asyncid" rel="noopener ugc nofollow" target="_blank">消灭</a>钩子第一次操作被发射。它通过上下文的异步ID(与第一次回调的当前执行ID相同)从上下文映射中删除上下文。</li><li id="f329" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated">对数据库的请求已经完成，我们的第二次回调即将被触发。</li><li id="c0fb" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated">此时<a class="ae kw" href="https://nodejs.org/api/async_hooks.html#async_hooks_before_asyncid" rel="noopener ugc nofollow" target="_blank">在</a>异步挂钩进场之前。它的当前执行ID与第二个操作(数据库请求)的异步ID相同。它将名称空间的<code class="fe mt mu mv mw b">active</code>属性设置为通过其当前执行ID找到的上下文。这是我们之前创造的环境。</li><li id="e618" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated">现在我们进行第二次回调。在里面运行一些业务逻辑。在该函数中，我们可以通过键<a class="ae kw" href="https://github.com/jeff-lewis/cls-hooked#namespacegetkey" rel="noopener ugc nofollow" target="_blank">从CLS中获取任何值，它将返回在我们之前创建的上下文中通过键找到的任何值。</a></li><li id="7c4f" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated">假设函数返回的请求处理结束。</li><li id="9ac9" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated"><a class="ae kw" href="https://nodejs.org/api/async_hooks.html#async_hooks_after_asyncid" rel="noopener ugc nofollow" target="_blank">在</a>之后，第二次回调触发异步挂钩。它将名称空间上的活动上下文设置为<code class="fe mt mu mv mw b">undefined</code>。</li><li id="ebc6" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated"><code class="fe mt mu mv mw b">destroy</code>钩子在第二次异步操作时被触发。它通过异步ID从上下文映射中删除我们的上下文，使其完全为空。</li><li id="d48e" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated">由于我们不再持有对上下文对象的任何引用，我们的垃圾收集器释放与之相关的内存。</li></ol><p id="22d9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是在引擎盖下发生的事情的简化版本，然而它涵盖了所有主要步骤。如果你想深入了解，你可以看一下<a class="ae kw" href="https://github.com/Jeff-Lewis/cls-hooked/blob/master/context.js" rel="noopener ugc nofollow" target="_blank">源代码</a>。不到500行。</p><h1 id="5bdb" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">生成跟踪id</h1><p id="b189" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">所以，一旦我们对CLS有了全面的了解，让我们想想如何利用它为我们自己谋福利。我们可以做的一件事是创建一个中间件，它将每个请求包装在一个上下文中，生成一个随机标识符，并通过键<code class="fe mt mu mv mw b">traceID</code>将其放入CLS。后来，在我们数不清的控制器和服务中，我们可以从CLS那里得到那个标识符。</p><p id="6254" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于<a class="ae kw" href="https://github.com/expressjs/express" rel="noopener ugc nofollow" target="_blank"> express </a>来说，这个中间件可能是这样的:</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="c326" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后在我们的控制器中，我们可以得到如下生成的跟踪ID:</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="2520" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">除非我们将这个跟踪ID添加到日志中，否则它没有多大用处。</p><p id="fc25" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们把它加到我们的<a class="ae kw" href="https://github.com/winstonjs/winston" rel="noopener ugc nofollow" target="_blank">温斯顿</a>里。</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="5bef" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好吧，如果所有的记录器都支持函数形式的格式化程序(他们中的许多人没有这么做是有原因的),那么这篇文章就不会存在了。那么，如何给我心爱的<a class="ae kw" href="https://github.com/pinojs/pino" rel="noopener ugc nofollow" target="_blank"> pino </a>添加一个跟踪ID呢？<a class="ae kw" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy" rel="noopener ugc nofollow" target="_blank">代理</a>来救援了！</p><h1 id="b4f7" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">结合代理和CLS</h1><p id="b16a" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">代理是一个包装原始对象的对象，允许我们在某些情况下覆盖它的行为。这些情况的列表(它们实际上被称为陷阱)是有限的，你可以在这里看一下整个集合<a class="ae kw" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy#Methods_of_the_handler_object" rel="noopener ugc nofollow" target="_blank">，但是我们只对陷阱</a><a class="ae kw" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/get" rel="noopener ugc nofollow" target="_blank">得到</a>感兴趣。它为我们提供了拦截财产访问的能力。这意味着如果我们有一个对象<code class="fe mt mu mv mw b">const a = { prop: 1 }</code>并把它包装在一个代理中，用<code class="fe mt mu mv mw b">get</code> trap我们可以为<code class="fe mt mu mv mw b">a.prop</code>返回任何我们想要的东西。</p><p id="842a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，我们的想法是为每个请求生成一个随机的跟踪ID，并用这个跟踪ID创建一个<a class="ae kw" href="https://github.com/pinojs/pino/blob/master/docs/child-loggers.md" rel="noopener ugc nofollow" target="_blank">子pino logger </a>，并把它放在CLS中。然后，我们可以用一个代理包装我们的原始日志记录器，如果找到一个，它会将所有日志记录请求重定向到CLS的子日志记录器，否则继续使用原始日志记录器。</p><p id="74ed" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这种情况下，我们的代理可能如下所示:</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="1b10" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的中间件会变成这样:</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="8814" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以像这样使用记录器:</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mx my l"/></div></figure><h1 id="8490" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated"><a class="ae kw" href="https://github.com/keenondrums/cls-proxify" rel="noopener ugc nofollow" target="_blank"> cls-proxify </a></h1><p id="44d6" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">基于上述想法，一个名为cls-proxify 的小型库被创建。它集成了<a class="ae kw" href="https://github.com/expressjs/express" rel="noopener ugc nofollow" target="_blank"> express </a>、<a class="ae kw" href="https://github.com/koajs/koa" rel="noopener ugc nofollow" target="_blank"> koa </a>和<a class="ae kw" href="https://github.com/fastify/fastify" rel="noopener ugc nofollow" target="_blank"> fastify </a>开箱即用。它不仅将<code class="fe mt mu mv mw b">get</code>陷印应用于原始对象，还将<a class="ae kw" href="https://github.com/keenondrums/cls-proxify#does-it-work-only-for-loggers" rel="noopener ugc nofollow" target="_blank">陷印应用于许多其他对象</a>。所以有无数可能的应用。您可以代理函数调用、类构造，几乎任何事情！你只会被你的想象力所限制！<a class="ae kw" href="https://github.com/keenondrums/cls-proxify#live-demos" rel="noopener ugc nofollow" target="_blank">看看现场演示如何将它与pino和fastify、pino和express配合使用</a>。</p><p id="bbf4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">希望你已经找到了对你的项目有用的东西。请随时将您的反馈传达给我！我非常感谢任何批评和问题。</p><p id="9763" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请在<a class="ae kw" href="https://twitter.com/ai_goncharov" rel="noopener ugc nofollow" target="_blank"> Twitter </a>或<a class="ae kw" href="https://www.linkedin.com/in/aigoncharov/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上关注我，继续关注新文章！订阅我的<a class="ae kw" href="https://blog.goncharov.page/" rel="noopener ugc nofollow" target="_blank">简讯</a>或者<a class="ae kw" href="https://blog.goncharov.page/rss.xml" rel="noopener ugc nofollow" target="_blank"> RSS </a>。如果你有任何问题，给我发一封<a class="ae kw" href="mailto:andrey@goncharov.page" rel="noopener ugc nofollow" target="_blank">电子邮件</a>。</p></div></div>    
</body>
</html>