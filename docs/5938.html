<html>
<head>
<title>Upgrading Swift HTTP APIs to the Next Level using Postie</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Postie将Swift HTTP APIs升级到下一个级别</h1>
<blockquote>原文：<a href="https://itnext.io/upgrading-swift-http-apis-to-the-next-level-using-postie-942ec33f7a24?source=collection_archive---------2-----------------------#2021-07-05">https://itnext.io/upgrading-swift-http-apis-to-the-next-level-using-postie-942ec33f7a24?source=collection_archive---------2-----------------------#2021-07-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="1bb8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在Swift中定义HTTP APIs还不完善(还？).大多数iOS和macOS应用程序都使用它们来与远程数据端点通信。根据不同的边缘情况，编写和验证请求、发送请求、解析响应曾经是一件很麻烦的事情…你可能认为现在有很多框架可以解决这种复杂性…</p><p id="961a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">…但是有了<a class="ae ko" href="https://github.com/kula-app/Postie/" rel="noopener ugc nofollow" target="_blank"> Postie </a>你可以进一步提升你的能力！</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi kp"><img src="../Images/6b5c485a7c506db920d0444c676c2939.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RVRtUduVLVgrpaIFQVtffw.jpeg"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">下一级Swift HTTP API包</figcaption></figure><h2 id="02c6" class="lf lg it bd lh li lj dn lk ll lm dp ln kb lo lp lq kf lr ls lt kj lu lv lw lx bi translated">现有的解决方案很笨重</h2><p id="9b26" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">那么，我们目前最先进的技术有什么问题呢？</p><p id="84a2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最受欢迎的Swift网络框架是<a class="ae ko" href="https://github.com/Alamofire/Alamofire" rel="noopener ugc nofollow" target="_blank"> Alamofire </a>，它在GitHub上获得了<strong class="js iu"> 36.000+ </strong>颗星。自2014年首次发布以来，它已经有了很长的改进、重构和扩展历史。</p><p id="18c8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">不幸的是，如此长的历史最终会导致代码膨胀，您可能不需要框架中包含的所有特性。<br/>几年前，我很高兴能有一个帮助使用<code class="fe md me mf mg b">URLSession</code>的库，并带走了JSON解析，这一切都发生在<code class="fe md me mf mg b">JSONDecoder</code>发布之前。<br/>今天我们不再需要它了，因为使用内置特性处理响应变得非常简单。</p><h2 id="dc9a" class="lf lg it bd lh li lj dn lk ll lm dp ln kb lo lp lq kf lr ls lt kj lu lv lw lx bi translated">OpenAPI定义</h2><p id="f9dc" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">为了开始解释Postie的核心概念，让我们回顾一下关于API定义的知识。</p><p id="5d2f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最初称为Swagger API定义的<a class="ae ko" href="https://swagger.io/specification/" rel="noopener ugc nofollow" target="_blank"> OpenAPI规范</a>是当今API定义的通用标准。请看这个来自<a class="ae ko" href="https://editor.swagger.io/" rel="noopener ugc nofollow" target="_blank"> Petstore示例</a>的片段，包括一个下订单的端点:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="mh mi l"/></div></figure><ol class=""><li id="55a8" class="mj mk it js b jt ju jx jy kb ml kf mm kj mn kn mo mp mq mr bi translated">定义的<code class="fe md me mf mg b">host</code>被用作我们需要发送HTTP请求的URL中的域</li><li id="3bdd" class="mj mk it js b jt ms jx mt kb mu kf mv kj mw kn mo mp mq mr bi translated"><code class="fe md me mf mg b">basePath</code>是一个路径前缀，在API版本控制中很常见，因为它允许在同一台主机上有多个API</li><li id="3808" class="mj mk it js b jt ms jx mt kb mu kf mv kj mw kn mo mp mq mr bi translated">在<code class="fe md me mf mg b">paths</code>中，我们定义我们的资源路径。<code class="fe md me mf mg b">/store/order</code>是静态的，但是<code class="fe md me mf mg b">/pet/{petId}</code>需要设置一个路径参数<code class="fe md me mf mg b">petId</code>，需要用某个标识符来替换。</li><li id="00d0" class="mj mk it js b jt ms jx mt kb mu kf mv kj mw kn mo mp mq mr bi translated"><code class="fe md me mf mg b">/store/order</code>端点在主体中需要一个参数，该参数必须是模式为<code class="fe md me mf mg b">Order</code>的对象。这是在<code class="fe md me mf mg b">definitions</code>一节中宣布的。</li><li id="cb52" class="mj mk it js b jt ms jx mt kb mu kf mv kj mw kn mo mp mq mr bi translated"><code class="fe md me mf mg b">/store/order</code>返回一个状态码<code class="fe md me mf mg b">200</code>，在响应体中有另一个<code class="fe md me mf mg b">Order</code>对象，或者如果验证失败，返回状态码<code class="fe md me mf mg b">400</code>，而不是在响应体中有一个<code class="fe md me mf mg b">Error</code>对象。</li><li id="ada3" class="mj mk it js b jt ms jx mt kb mu kf mv kj mw kn mo mp mq mr bi translated"><code class="fe md me mf mg b">Order</code>对象包含多个不同类型的字段，包括<code class="fe md me mf mg b">int64</code>、<code class="fe md me mf mg b">int32</code>、<code class="fe md me mf mg b">date-time</code>字符串甚至字符串枚举。</li></ol><p id="b474" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如您所见，请求和响应定义得非常好。不幸的是，这个端点带来了一些警告，因为在实现过程中我们需要考虑一些边缘情况:</p><ol class=""><li id="3178" class="mj mk it js b jt ju jx jy kb ml kf mm kj mn kn mo mp mq mr bi translated">响应正文模式因状态代码而异</li><li id="1d80" class="mj mk it js b jt ms jx mt kb mu kf mv kj mw kn mo mp mq mr bi translated">请求正文参数是必需的，不应缺失。</li><li id="0663" class="mj mk it js b jt ms jx mt kb mu kf mv kj mw kn mo mp mq mr bi translated">请求URL可能需要参数(比如<code class="fe md me mf mg b">petId</code>)，甚至可能需要特定的类型(比如<code class="fe md me mf mg b">UUID</code>)。</li></ol><blockquote class="mx my mz"><p id="03e9" class="jq jr na js b jt ju jv jw jx jy jz ka nb kc kd ke nc kg kh ki nd kk kl km kn im bi translated">另一个话题是认证，这不是我在这篇文章中讨论的。存在许多不同的认证机制，包括HTTP Basic(用户名+密码)、API密钥和OAuth令牌。所有这些都需要以不同的方式处理，因此对于这个介绍来说太多了。</p></blockquote><p id="407c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在你知道我们面临什么样的挑战了。那么，我们如何利用Swift的力量来帮助我们定义结构良好的API代码呢？</p><h1 id="a0ac" class="ne lg it bd lh nf ng nh lk ni nj nk ln nl nm nn lq no np nq lt nr ns nt lw nu bi translated">介绍帖子</h1><p id="bd70" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated"><a class="ae ko" href="https://github.com/philprime/Postie" rel="noopener ugc nofollow" target="_blank"> Postie </a>是我们新的Swift包，它负责将我们的API请求类型转换成<code class="fe md me mf mg b">URLRequest</code>对象，将它们发送到端点，接收<code class="fe md me mf mg b">URLResponse</code>并将其转换回我们定义的API响应类型。</p><p id="d176" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Swift编译器及其强大的类型范例允许我们负责所有的数据结构管理。<br/>从高层次的角度来看，主要概念结合Swift 5.1的属性包装器，使用了已经内置的创建自定义<code class="fe md me mf mg b">Encoder</code>和<code class="fe md me mf mg b">Decoder</code>的选项。</p><p id="fa3c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">听起来很复杂，但幸运的是，您不必担心Postie的魔力是如何工作的，相反，您只需定义您的API🎉</p><p id="cc05" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">像往常一样，这个例子更容易理解，所以让我们从一个简单的HTTP请求开始，请求我们的<code class="fe md me mf mg b">/store/order</code>端点:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="463b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以看到这个请求包括一个HTTP方法、URL路径、一个带有远程域的<code class="fe md me mf mg b">Host</code>头、一个声明我们正在发送的数据类型的<code class="fe md me mf mg b">Content-Type</code>头，以及主体中的实际JSON数据。此外，我们还定义了一个<code class="fe md me mf mg b">Accept</code>头，它告诉远程端点我们想要接收什么类型的数据(也是JSON)。</p><p id="a763" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">那么如何使用Postie来声明这个请求呢？</p><h2 id="1527" class="lf lg it bd lh li lj dn lk ll lm dp ln kb lo lp lq kf lr ls lt kj lu lv lw lx bi translated">定义API请求</h2><p id="2d72" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">我们从最简单的方法开始，然后添加更多的信息。</p><p id="ac5e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">创建以下请求:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="686e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们使用<code class="fe md me mf mg b">@RequestHTTPMethod</code>属性包装器将默认的HTTP方法<code class="fe md me mf mg b">GET</code>更改为<code class="fe md me mf mg b">POST</code>。</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="9386" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我们需要使用<code class="fe md me mf mg b">@RequestPath</code>属性包装器定义资源路径。</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="6809" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">注意:</strong>如前所述，我们<em class="na">而不是</em>向请求路径添加前缀<code class="fe md me mf mg b">v2</code>，因为请求类型本身与实际的远程主机没有关联。相反，我们必须用HTTP客户端定义主机URL和前缀:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="c8de" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我们需要添加请求体。从HTTP请求中我们知道</p><ol class=""><li id="5274" class="mj mk it js b jt ju jx jy kb ml kf mm kj mn kn mo mp mq mr bi translated">该对象被定义为一个<code class="fe md me mf mg b">Order</code>结构</li><li id="2714" class="mj mk it js b jt ms jx mt kb mu kf mv kj mw kn mo mp mq mr bi translated">它需要是一个JSON对象</li></ol><p id="b5e4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了解决第二个要求，将<code class="fe md me mf mg b">CreateStoreOrder</code>的类型从<code class="fe md me mf mg b">Request</code>改为<code class="fe md me mf mg b">JSONRequest</code>。这将指示Postie的编码逻辑，请求体应该转换为JSONdata，并且需要设置头<code class="fe md me mf mg b">Content-Type: application/json</code>。</p><p id="0eef" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这也是Swift编译器支持我们的一个很好的例子。在更改请求类型之后，它要求我们立即修改请求以添加属性<code class="fe md me mf mg b">body</code>。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi nv"><img src="../Images/e4fad3ef13a5c23e1b0b985708c3194a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*raBKjGIaIN_m2UOGv7FzVg.png"/></div></div></figure><p id="03f0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">声明一个必须实现<code class="fe md me mf mg b">Encodable</code>模式的结构<code class="fe md me mf mg b">Body</code>,就万事俱备了。</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="b04d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们可以修改<code class="fe md me mf mg b">Body</code>使其具有与我们的<code class="fe md me mf mg b">Order</code>模式相同的结构，但是我们定义了一个<code class="fe md me mf mg b">Definitions</code>结构，这样我们就可以重用它。</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="9d1e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">太好了！我们已经完成了请求类型的声明🎉</p><h2 id="c44c" class="lf lg it bd lh li lj dn lk ll lm dp ln kb lo lp lq kf lr ls lt kj lu lv lw lx bi translated">定义API响应</h2><p id="e4a3" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">是时候定义我们的响应类型了，所以看一下预期的HTTP响应:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="4acd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它主要包含响应状态代码、响应头和主体数据。</p><p id="940c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要从响应中访问任何信息，相关联的类型<code class="fe md me mf mg b">Response</code>需要变成实际的<code class="fe md me mf mg b">struct</code>。我们之前使用了<code class="fe md me mf mg b">EmptyResponse</code>，这是一个方便的类型别名，用于以下内容:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="5fbe" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第一步，我们要读取响应状态代码。使用包装器<code class="fe md me mf mg b">@ResponseStatusCode</code>添加一个属性。</p><blockquote class="mx my mz"><p id="9dbd" class="jq jr na js b jt ju jv jw jx jy jz ka nb kc kd ke nc kg kh ki nd kk kl km kn im bi translated"><strong class="js iu">注:</strong> <em class="it">您可以随意命名属性。如果协议没有要求(例如</em> <code class="fe md me mf mg b"><em class="it">body</em></code> <em class="it">)，只有属性包装器是相关的。</em></p></blockquote><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="3c1f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当解码响应时，Postie现在将找到<code class="fe md me mf mg b">statusCode</code>属性，并看到它应该用实际的HTTP响应代码进行设置。</p><p id="8a00" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在定义响应体之前，让我们快速回顾一下OpenAPI的定义:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="76c7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">看起来我们需要定义两个响应，它们根据响应代码的不同而不同。这也是Postie中内置的，因为您不仅可以定义一个<code class="fe md me mf mg b">@ResponseBody</code>，还可以定义一个<code class="fe md me mf mg b">@ResponseErrorBody</code>属性，该属性仅在状态代码介于400和499之间时才会被填充。</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="7ab4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了让这个代码片段工作，我们需要更改<code class="fe md me mf mg b">Defintions.Order</code>类型，不仅要实现<code class="fe md me mf mg b">Encodable</code>协议，还要实现<code class="fe md me mf mg b">Decodable</code>协议。此外，我们需要定义<code class="fe md me mf mg b">Definitions.Error</code>，这一点应该很清楚。</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="ef00" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在最后一步，我们再次需要指出Postie的解码逻辑，以期待一个JSON请求体，这是通过将类型<code class="fe md me mf mg b">Order</code>的<code class="fe md me mf mg b">Decodable</code>协议改为<code class="fe md me mf mg b">JSONDecodable</code>来完成的(对于<code class="fe md me mf mg b">Error</code>也是如此)。</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="bf28" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">干得好！让我们拍拍自己的背，我们的API定义已经准备好了💪🏼</p><h2 id="ea11" class="lf lg it bd lh li lj dn lk ll lm dp ln kb lo lp lq kf lr ls lt kj lu lv lw lx bi translated">发送请求</h2><p id="e44c" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">使用请求定义很容易。你所要做的就是创建一个对象<code class="fe md me mf mg b">CreateStoreOrder</code>并使用我们之前声明的<code class="fe md me mf mg b">HTTPAPIClient</code>发送它。</p><blockquote class="mx my mz"><p id="a12c" class="jq jr na js b jt ju jv jw jx jy jz ka nb kc kd ke nc kg kh ki nd kk kl km kn im bi translated"><strong class="js iu">注:</strong> Postie使用异步事件框架<a class="ae ko" href="https://developer.apple.com/documentation/combine" rel="noopener ugc nofollow" target="_blank">结合</a>进行通信。因为它使用底层的<code class="fe md me mf mg b">URLSession</code>，其他的异步模式也是可能的(如果需要的话)。</p></blockquote><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="955f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">由于我们的<code class="fe md me mf mg b">CreateStoreOrder</code>有一个关联的<code class="fe md me mf mg b">Response</code>类型，我们不必再次定义预期的响应类型，也不必担心它的解析逻辑。</p><p id="d04f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">从现在开始，我们简单地<strong class="js iu">使用</strong>我们的API。</p><h1 id="fa36" class="ne lg it bd lh nf ng nh lk ni nj nk ln nl nm nn lq no np nq lt nr ns nt lw nu bi translated">更多功能</h1><p id="fc6f" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">还有更多可用的特性，但我无法在本文中一一介绍。强烈建议您查看大量的<a class="ae ko" href="https://github.com/kula-app/Postie/" rel="noopener ugc nofollow" target="_blank">自述指南</a>来查看完整的特性集。</p><p id="fcd5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">只是让你看一下还有什么可用的:</p><ul class=""><li id="0475" class="mj mk it js b jt ju jx jy kb ml kf mm kj mn kn nw mp mq mr bi translated"><code class="fe md me mf mg b">@RequestHeader</code>定义请求头</li><li id="7829" class="mj mk it js b jt ms jx mt kb mu kf mv kj mw kn nw mp mq mr bi translated"><code class="fe md me mf mg b">@ReponseHeader</code>从响应中读取特定标题</li><li id="0280" class="mj mk it js b jt ms jx mt kb mu kf mv kj mw kn nw mp mq mr bi translated"><code class="fe md me mf mg b">@QueryItem</code>向请求URL查询添加键入的字段</li><li id="8005" class="mj mk it js b jt ms jx mt kb mu kf mv kj mw kn nw mp mq mr bi translated"><code class="fe md me mf mg b">@RequestPathParameter</code>在URL中设置类型化参数(例如我们示例中的<code class="fe md me mf mg b">petId</code>)</li></ul><p id="7e95" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">…以及更多！</p><h1 id="b1fa" class="ne lg it bd lh nf ng nh lk ni nj nk ln nl nm nn lq no np nq lt nr ns nt lw nu bi translated">那么，有什么不同呢？</h1><p id="ec75" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">你可能想知道为什么我们认为Postie不同于其他框架/包。</p><p id="a59f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我前面提到过，其他框架很笨重，包含许多特性，大多数用户都没有使用过。由于Postie最终也会随着它的特性集而增长，我们的对策是保持内核的精简，可能实现多包方法，并且在定义API时需要尽可能少的信息。</p><p id="5ae7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们使用属性包装器的方法正好实现了这一点。其他框架要求在发送请求时将额外的头或值作为函数参数传递，但是Postie坚持使用面向对象的方法:</p><blockquote class="nx"><p id="5a01" class="ny nz it bd oa ob oc od oe of og kn dk translated">请求是一个单一的数据对象，它包含接收预期响应的所有相关信息。</p></blockquote><h1 id="34c0" class="ne lg it bd lh nf ng nh lk ni nj nk ln nl oh nn lq no oi nq lt nr oj nt lw nu bi translated">路线图</h1><p id="6586" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">Postie最终将发展成为一个成熟的HTTP框架，负责所有的数据转换和需求验证。主要目标是拥有一个面向对象的<code class="fe md me mf mg b">Request-Response</code>模式，这允许开发者更少地担心<em class="na">如何</em>使用API，而是<em class="na">用它做什么。</em></p><p id="50bb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在撰写本文时，Postie支持JSON和表单URL编码的数据，但我们也计划在未来支持XML。</p><p id="57e5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">随着Swift 5.5中async-await的出现，当前基于组合的发送逻辑将得到扩展。如果需要，我们还将包括传统风格的回调。</p><p id="3f14" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">其他想法包括一个<a class="ae ko" href="https://github.com/SwiftGen/SwiftGen" rel="noopener ugc nofollow" target="_blank"> Swiftgen </a>模板，用于自动将OpenAPI规范直接转换成随时可用的Postie请求定义。</p><p id="256d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">尽管该软件包仍在积极开发中，但我们将在<a class="ae ko" href="https://www.techprimate.com/" rel="noopener ugc nofollow" target="_blank"> techprimate </a>上将其用于生产应用，并验证其用途，最终将其升级到版本1.0.0</p><h1 id="57f6" class="ne lg it bd lh nf ng nh lk ni nj nk ln nl nm nn lq no np nq lt nr ns nt lw nu bi translated">结论和贡献</h1><p id="583b" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">遵循<a class="ae ko" href="https://github.com/kula-app/Postie/" rel="noopener ugc nofollow" target="_blank">库</a>并提交您的特性请求。它是作为一个开源项目开始的，并且应该一直保持下去，这样我们就可以互相受益。发现了窃听器？<a class="ae ko" href="https://github.com/kula-app/Postie/issues/new" rel="noopener ugc nofollow" target="_blank">让我们知道吧！</a></p><p id="4368" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我也很想听听你对这个项目的看法。在推特<a class="ae ko" href="https://twitter.com/philprimes" rel="noopener ugc nofollow" target="_blank">上关注我</a>,随时留下你的想法。<br/>也结账<a class="ae ko" href="philpri.me/blog" rel="noopener ugc nofollow" target="_blank">我的其他文章</a>。你有具体的话题想让我说吗？让我知道！😃</p></div></div>    
</body>
</html>