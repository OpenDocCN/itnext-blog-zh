<html>
<head>
<title>How you can abort Fetch() request on a flight…</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在飞行中中止Fetch()请求…</h1>
<blockquote>原文：<a href="https://itnext.io/how-you-can-abort-fetch-request-on-a-flight-830a639b9b92?source=collection_archive---------0-----------------------#2019-05-24">https://itnext.io/how-you-can-abort-fetch-request-on-a-flight-830a639b9b92?source=collection_archive---------0-----------------------#2019-05-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/a9810507375c0b9187275ca0c695047d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xNew92eHE-XLTWc7"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@jessysmith?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">鞠波·史密斯</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="ffb6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">每个前端开发者都一直在用<strong class="kf ir"> REST API </strong>。流程非常清楚——如果你需要来自服务器的一些数据，你只需要用<strong class="kf ir"> XHR请求</strong>获取它。尽管Ajax不是一项新技术，但有些特性我最近才发现，所以我决定分享它们。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><p id="2e82" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我相信如今最流行的从服务器获取数据的方式之一，是更确切的<strong class="kf ir"/><a class="ae kc" href="https://github.com/axios/axios" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir">axios</strong></a>，承诺基于库获取数据，或者原生浏览器<a class="ae kc" href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">获取</strong> </a> <strong class="kf ir"> API </strong>。</p><p id="a22f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> Axios </strong>有内置的<strong class="kf ir"> cancel() </strong>方法，该方法让您有机会中止尚未解决或拒绝的请求。因此，如果您的项目依赖项中有Axios，您可以开始使用它。这是<a class="ae kc" href="https://github.com/axios/axios/blob/master/README.md#cancellation" rel="noopener ugc nofollow" target="_blank">链接</a>到它的文档。</p><p id="e130" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是那些使用本机<strong class="kf ir"> fetch API、</strong>的开发者应该怎么做呢，因为它已经内置于现代浏览器中，不会增加包的大小或任何你使用它的理由。</p><p id="7e3c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我之前不知道的是，你也可以使用新的<a class="ae kc" href="https://developer.mozilla.org/en-US/docs/Web/API/AbortController" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir">abort controller</strong></a><strong class="kf ir">API来取消请求。</strong>所以让我们来看一些直接从Mozila MDN使用它的代码示例。</p><figure class="li lj lk ll gt jr"><div class="bz fp l di"><div class="lm ln l"/></div></figure><p id="0d6f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们看看这段代码中发生了什么。所以在第一行，我们创建了一个<strong class="kf ir"> AbortController </strong>的实例。然后在第二行，我们从它那里得到一个<strong class="kf ir">信号</strong>，然后我们使用它将这个控制器绑定到特定的请求，方法是将它添加到第四行的<strong class="kf ir"> fetch() </strong> params。所以现在我们可以调用<code class="fe lo lp lq lr b">controller.abort()</code>方法来取消我们的请求，见第13行。</p><p id="fd64" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">注意:</strong>如果您取消请求，您的承诺将被拒绝，您将进入<code class="fe lo lp lq lr b">catch()</code>错误处理程序。我们将进一步讨论如何检测取消的请求，以分离错误处理和取消的请求逻辑。</p><p id="108c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">尽管这段代码大约有11行，但它仍然很长，而且我们确实喜欢将这些低级代码隐藏到一些更具语义和直觉的抽象中，如<code class="fe lo lp lq lr b">getGithubUser()</code>或<code class="fe lo lp lq lr b">fetchVideo()</code>。</p><p id="c7f6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通常我们的<code class="fe lo lp lq lr b">getGithubUser()</code>函数看起来像这样:</p><figure class="li lj lk ll gt jr"><div class="bz fp l di"><div class="lm ln l"/></div></figure><p id="9c67" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以它已经封装了一些逻辑，你可以看到它有Github api的url，并且预置了参数。所以也许我们也可以把我们的<strong class="kf ir">人工控制器</strong>放在这里？</p><figure class="li lj lk ll gt jr"><div class="bz fp l di"><div class="lm ln l"/></div></figure><p id="83d8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如你所见，我们已经创建了一个<strong class="kf ir"> AbortController </strong>的实例，提取了它在第4行的信号，并将其传递给第7行的fetch。</p><p id="b64f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，我们不能中止这个请求，因为我们没有任何访问<code class="fe lo lp lq lr b">controller.abort()</code>方法的权限，因为实例没有返回。我们可以修复它:</p><figure class="li lj lk ll gt jr"><div class="bz fp l di"><div class="lm ln l"/></div></figure><p id="14af" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以现在我们返回我们的<code class="fe lo lp lq lr b">promise</code>和<code class="fe lo lp lq lr b">controller.abort()</code>函数。</p><p id="048c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">注意:</strong>要注意的重要事情是用<code class="fe lo lp lq lr b">.bind()</code>方法绑定上下文，因为否则你将无法在你的客户端代码中使用<code class="fe lo lp lq lr b">abort()</code>函数。</p><p id="319f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是如何在您的客户端代码中使用它，如下所示:</p><figure class="li lj lk ll gt jr"><div class="bz fp l di"><div class="lm ln l"/></div></figure><p id="d553" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这看起来漂亮多了，但我仍然不满意这个解决方案。我们仍然在每个抽象函数中重复<strong class="kf ir"> AbortController </strong>代码。</p><p id="0c53" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，让我们通过将我们的<strong class="kf ir"> AbortController </strong>和<strong class="kf ir"> fetch API </strong>代码提取到一些可以处理它的公共抽象中来改进这一点。</p><figure class="li lj lk ll gt jr"><div class="bz fp l di"><div class="lm ln l"/></div></figure><p id="8edf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">哇，看起来变化很大。事实上，这看起来不像我们以前拥有的。我们的<code class="fe lo lp lq lr b">getGithubUser()</code>功能现在在哪里？别担心，跟着我，我们会找到的。现在让我们讨论一下上面的代码是怎么回事。</p><p id="cb2b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们创建了一个新的函数来保存所有的<strong class="kf ir"> AbortController </strong>逻辑。它看起来与我们之前的<code class="fe lo lp lq lr b">getGithubUser()</code>函数非常相似，但是它与Github url或预定义的获取参数无关。我是故意这么做的，这是我们所有其他抽象都会用到的通用函数。</p><p id="50c2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的<code class="fe lo lp lq lr b">fetchData()</code>函数接收两个参数:</p><ul class=""><li id="ba4b" class="ls lt iq kf b kg kh kk kl ko lu ks lv kw lw la lx ly lz ma bi translated">全球资源定位器(Uniform Resource Locator)</li><li id="39ed" class="ls lt iq kf b kg mb kk mc ko md ks me kw mf la lx ly lz ma bi translated">参数</li></ul><p id="8d4f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">基本上这两个非常相似，你通常会传递给<code class="fe lo lp lq lr b">fetch()</code>，事实上我们在第11行传递。然而，我们不仅传递收到的<code class="fe lo lp lq lr b">params</code>参数，还在第8行添加了<code class="fe lo lp lq lr b">controller.signal</code>。然后我们返回Promise和我们的<code class="fe lo lp lq lr b">abort()</code>函数，现在它将工作，因为我们在第16行绑定了它的上下文。</p><p id="fa4b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以在客户端代码中使用这个特殊的示例，如下所示:</p><figure class="li lj lk ll gt jr"><div class="bz fp l di"><div class="lm ln l"/></div></figure><p id="e879" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">再问一次，我们的<code class="fe lo lp lq lr b">getGithubUser()</code>函数在客户端代码中如此容易使用，它是怎么回事？正如您在第5行看到的，我们将用户名硬编码到url中，这也不好。</p><p id="478e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以现在让我们使用我们常用的<code class="fe lo lp lq lr b">fetchData()</code>函数来创建我们的<code class="fe lo lp lq lr b">getGithubUser()</code>，它将获得参数<code class="fe lo lp lq lr b">userName</code>，能够中止它的请求，并且不需要用户处理任何参数，如果他/她不想的话。</p><figure class="li lj lk ll gt jr"><div class="bz fp l di"><div class="lm ln l"/></div></figure><p id="c7b6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以这里是我们最终版本的<code class="fe lo lp lq lr b">getGithubUser()</code>函数。首先要注意的是我们在第1行导入了<code class="fe lo lp lq lr b">fetchData()</code>函数。现在我们的<code class="fe lo lp lq lr b">getGithubUser()</code>变成了高阶函数，它将返回对<code class="fe lo lp lq lr b">fetchData()</code>的调用，但是带有固定的参数。这意味着我们可以将Github url封装在我们的函数中，因此客户端代码甚至不需要考虑它，它所要做的就是通过<code class="fe lo lp lq lr b">userName</code>。我们也可以在这个函数中隐藏默认的获取参数，如第4行所示。更酷的是，如果需要，客户端代码仍然可以扩展params。</p><p id="fcfd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，在我们的客户端代码中，我们可以像这样轻松地使用我们的函数:</p><figure class="li lj lk ll gt jr"><div class="bz fp l di"><div class="lm ln l"/></div></figure><p id="d1b1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">注意:</strong>记住我已经答应告诉你如何检测被取消的请求，所以在这里的第8行你可以看到如何处理<strong class="kf ir">“abor terror”。</strong></p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><p id="28e2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在单页应用程序中，我们可以从这种模式中获益并提高性能。例如，每个从服务器获取数据的组件可能会在请求完成之前被卸载。当用户更改路由时，路由器组件重新呈现另一个不再包含我们组件的页面。因此，在<strong class="kf ir"> componentWillUnmount() </strong>方法中中止请求可能是个好主意，在这个方法中，您保存了所有组件清理登录。</p><p id="f18f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">原来如此。我将感谢你分享你自己在中止请求时的用例，以及你对此的想法。</p><p id="52c1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于那些不想复制和摆弄代码的人来说。这里是一个带有小演示的<a class="ae kc" href="https://codesandbox.io/embed/patient-firefly-wy7qjz6mnl" rel="noopener ugc nofollow" target="_blank">链接</a>到codesandbox，带有<strong class="kf ir"> &lt;用户/ &gt; </strong>组件，该组件获取Github用户，但是如果组件在请求仍在处理时被卸载，则取消请求。</p><p id="6646" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">附言</strong>我建议您使用网络选项卡将连接限制为慢速3G，这样您就有时间通过点击“切换”按钮来取消请求。</p></div></div>    
</body>
</html>