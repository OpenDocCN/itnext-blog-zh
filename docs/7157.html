<html>
<head>
<title>Schedule Image Displaying In Glance Widget With Work Manager API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用工作管理器API在Glance小部件中安排图像显示</h1>
<blockquote>原文：<a href="https://itnext.io/schedule-image-displaying-in-glance-widget-with-work-manager-api-cc474ed8571c?source=collection_archive---------1-----------------------#2022-06-30">https://itnext.io/schedule-image-displaying-in-glance-widget-with-work-manager-api-cc474ed8571c?source=collection_archive---------1-----------------------#2022-06-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/1f5181f7d470a503b84ee7e67c83aadb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*puxM9pd6frlzR-nY8k96iw.jpeg"/></div></div></figure><p id="5fac" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> Glance </strong>加速创建不同表面的应用小部件，如主屏幕、键盘等。因为它提供了一些API来帮助我们构建<strong class="ka ir"> Jetpack Compose风格的小部件。</strong></p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="dd60" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">先决条件🤔</h1><p id="c13d" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">在阅读本文之前，您至少需要熟悉一些概念。</p><ul class=""><li id="5639" class="mg mh iq ka b kb kc kf kg kj mi kn mj kr mk kv ml mm mn mo bi translated"><strong class="ka ir">喷气背包作曲</strong></li><li id="5746" class="mg mh iq ka b kb mp kf mq kj mr kn ms kr mt kv ml mm mn mo bi translated"><strong class="ka ir">首选项数据存储</strong></li><li id="453a" class="mg mh iq ka b kb mp kf mq kj mr kn ms kr mt kv ml mm mn mo bi translated"><strong class="ka ir">改装</strong></li><li id="b1ae" class="mg mh iq ka b kb mp kf mq kj mr kn ms kr mt kv ml mm mn mo bi translated"><strong class="ka ir">视图模型</strong></li><li id="93b2" class="mg mh iq ka b kb mp kf mq kj mr kn ms kr mt kv ml mm mn mo bi translated"><strong class="ka ir">工作经理</strong></li></ul></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="ae1d" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">项目设置😃</h1><p id="d45f" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">现在让我们开始编码，创建一个新项目，并在<strong class="ka ir"> build.gradle </strong>(模块)中添加以下依赖项</p><blockquote class="mu mv mw"><p id="cf5c" class="jy jz mx ka b kb kc kd ke kf kg kh ki my kk kl km mz ko kp kq na ks kt ku kv ij bi translated">旁注:源代码可以在文章末尾找到。</p></blockquote><figure class="nb nc nd ne gt jr"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="9979" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们忘记之前，在AndroidManifest.xml文件中添加internet权限。</p><pre class="nb nc nd ne gt nh ni nj nk aw nl bi"><span id="5f35" class="nm le iq ni b gy nn no l np nq">&lt;uses-permission android:name="android.permission.INTERNET" /&gt;</span></pre></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><p id="c010" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，我们将创建一个简单的小部件，看看我们如何构建一个，然后我们将它与<strong class="ka ir"> WorkManager </strong>连接，开始调度。</p><p id="155f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要创建一个小部件，我们需要做以下工作:</p><ul class=""><li id="6bf3" class="mg mh iq ka b kb kc kf kg kj mi kn mj kr mk kv ml mm mn mo bi translated">创建一个继承自<strong class="ka ir"> GlanceAppWidget </strong>的类</li><li id="c8b2" class="mg mh iq ka b kb mp kf mq kj mr kn ms kr mt kv ml mm mn mo bi translated">创建一个从<strong class="ka ir">GlanceAppWidgetReceiver</strong>继承的接收器类</li><li id="b3b8" class="mg mh iq ka b kb mp kf mq kj mr kn ms kr mt kv ml mm mn mo bi translated">注册我们的接收器并提供我们的部件元数据。</li></ul><figure class="nb nc nd ne gt jr"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="021d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一旦你实现了<strong class="ka ir"> GlanceAppWidget </strong>，你就需要覆盖一个叫做<strong class="ka ir"> Content </strong>的可组合函数，在这里你可以编写你的小部件UI看起来是什么样子。这里我使用Image composable来显示来自drawable资源的图像。值得一提的是，我们在<strong class="ka ir">内容</strong> composable中使用的大多数与Jetpack compose相关的代码都是从<strong class="ka ir"> androidx.glance </strong>中导入的。你还会注意到，我们为可合成的图像使用了一个<strong class="ka ir"> ImageProvider </strong>，而不是普通可合成函数中的painter(<strong class="ka ir">painter resource</strong>)以及修改器，这里我们使用了一个<strong class="ka ir"> GlanceModifier </strong>而不是普通的合成修改器。</p><figure class="nb nc nd ne gt jr"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="44fb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">创建小部件接收器后，您必须通过实现属性<strong class="ka ir"> glanceAppWidget </strong>将接收器连接到小部件。</p><pre class="nb nc nd ne gt nh ni nj nk aw nl bi"><span id="3b1b" class="nm le iq ni b gy nn no l np nq">&lt;receiver<br/>    android:name=".extra.RemoteWidgetReceiver"<br/>    android:enabled="true"<br/>    android:exported="false"&gt;<br/><br/>    &lt;intent-filter&gt;<br/>        &lt;action android:name="android.appwidget.action.APPWIDGET_UPDATE" /&gt;<br/>    &lt;/intent-filter&gt;<br/><br/>    &lt;meta-data<br/>        android:name="android.appwidget.provider"<br/>        android:resource="@xml/widget_provider" /&gt;<br/><br/>&lt;/receiver&gt;</span></pre><p id="a15a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，在您的AndoirdManifest.xml文件中，在您的<strong class="ka ir">应用程序</strong>标签中注册您的接收器，并为小部件添加意图过滤器和元数据。</p><p id="9861" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">虽然我们的小部件是用compose编写的，但是我们需要创建一些XML文件，比如小部件最初的样子以及与小部件相关的一些属性和配置。所有这些配置都存储在<strong class="ka ir"> widget_provider.xml </strong>文件中。</p><figure class="nb nc nd ne gt jr"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="bf14" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如你在widget_provider.xml中看到的，我们定义了一些关于我们的小部件的信息。在我们解释这些属性之前，这里是文件<strong class="ka ir">widget _ initial _ layout . XML</strong>的代码</p><figure class="nb nc nd ne gt jr"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="f825" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在下图中，我们可以看到这些属性是如何使用的。</p><figure class="nb nc nd ne gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nr"><img src="../Images/1115f9697e230910cfa3f96a356a2b5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N1Vi5HTZKng38LLQsaOy2A.jpeg"/></div></div><figcaption class="ns nt gj gh gi nu nv bd b be z dk translated">图1</figcaption></figure><figure class="nb nc nd ne gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nw"><img src="../Images/d6f9305c9c9be356e15df1cd412524a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aVVfiQfCEJeiA_BDDyqlPg.jpeg"/></div></div><figcaption class="ns nt gj gh gi nu nv bd b be z dk translated">图2</figcaption></figure><p id="5787" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您还可以在这里查看appwidget-provider <a class="ae nx" href="https://developer.android.com/guide/topics/appwidgets" rel="noopener ugc nofollow" target="_blank">的所有可能属性。现在让我们运行应用程序，看看我们目前的结果。</a></p><figure class="nb nc nd ne gt jr gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/e403603008803daa5068ee76f59de0e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/1*MfbqZDtBJuqUJJaj3oPaWw.gif"/></div></figure></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><p id="1105" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">了解了如何设置小部件之后，是时候学习如何为小部件安排图像了。值得一提的是，glance widget使用<strong class="ka ir">偏好数据存储库</strong>来保存数据。</p><p id="c4f1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们要做的就是让用户选择一个类别，根据这个选择，我们将每15分钟获得一个随机图像，并在小部件中显示它。</p><figure class="nb nc nd ne gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nz"><img src="../Images/86b8400f915dfcc17e0c884be64c2cd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k7Hi-BDw-5ztvh7dO879oQ.jpeg"/></div></div><figcaption class="ns nt gj gh gi nu nv bd b be z dk translated">调度过程</figcaption></figure><p id="ff01" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们从层次结构的底层(数据)开始编写程序</p><figure class="nb nc nd ne gt jr"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="af07" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">两个函数，一个用于获取图像对象，另一个用于从图像对象获取图像原始字节。</p><figure class="nb nc nd ne gt jr"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="5a5c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的首选项数据存储类，用于获取和设置首选项中的用户类别索引。</p><p id="31e7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在检查我们的工人类之前，让我们看看我们的<strong class="ka ir"> MainScreenViewModel </strong>类。</p><figure class="nb nc nd ne gt jr"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="f0eb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们在viewModel实例化上监视对我们的首选项的更改，并且在每次更新时，我们调用<strong class="ka ir"> setWork </strong>函数开始调度我们的RemoteImageWorker类，使其每15分钟运行一次。此外，我们为我们的工作人员设置了一个限制，即网络是让工作人员入队所必需的。最后，我们还将初始数据传递给worker类，这是我们首选类别的索引。</p><figure class="nb nc nd ne gt jr"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="103f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有太多事情发生了吗？完全相反，在glance中，我们既没有来自coil的rememberAsyncImagePainter，也没有来自glide的rememberGlidePainter或其他任何库，所以我们必须自己处理图像url。在我的方法中，我们从视图模型中获得了<strong class="ka ir">输入数据</strong>(类别)。然后我们查询API以根据我们的类别获得一个随机的图像对象，然后我们从<strong class="ka ir"> regular </strong>属性下载该图像，该属性保存了一个具有常规大小的图像的url。最后，我们将图像字节写入一个文件，并从任何旧的调度中清除任何以前的图像。一旦我们完成了这个过程，我们调用<strong class="ka ir">updateremoteimagwidget</strong>函数并传递图像文件的路径来查询从<strong class="ka ir"> RemoteWidget </strong>派生的每个小部件，并更新小部件首选项中的图像文件路径。最后，更新小部件的每个实例状态，这将使小部件重新加载一个新的图像文件。</p><p id="517d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们应该对我们的小部件做一些修改，以反映来自工人的那些更新</p><figure class="nb nc nd ne gt jr"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="c066" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> currentState </strong> inline函数允许我们检索包含我们在小部件首选项中保存的数据的状态。正如我们已经看到的，glance小部件使用首选项数据存储来保存数据。因此，我们从worker类提交的对<strong class="ka ir"> filePathString </strong>的每一次修改都会导致用新路径和新图像对我们的小部件进行<strong class="ka ir">重组</strong>。</p><p id="6230" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一旦你选择了小部件并开始拖动它，你在<strong class="ka ir"> Content </strong>函数中看到的所有代码都会被执行。因此，我们的worker类中的所有更新功能仅适用于附加到表面的小部件。但是，如果我们在没有任何小部件的情况下第一次运行应用程序，会发生什么呢？是的，图像被下载了，但是<strong class="ka ir"> filePathString </strong>是空的，因为小部件的数据存储文件仅在小部件被创建时产生。因此，我创建了一个简单的函数来从文件路径中检索位图，如果文件路径为空(这只会在我们第一次添加小部件时发生),我们就从fileDir加载jpg文件。</p><p id="e263" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">每次创建同一小部件的实例时，都会创建一个新的数据存储文件。想象一下，如果我们有一个小部件，然后我们试图添加一个新的，第一个会得到图像，但第二个不会。为此，我们创建了<strong class="ka ir">CustomGlanceStateDefinition</strong>来向小部件的每个实例传递相同的数据存储文件。<strong class="ka ir">CustomGlanceStateDefinition</strong>的代码可能是一个样板文件，所以当您想要将相同的数据存储文件传递给每个小部件时，您总是需要相同的代码。只是不要忘记覆盖<strong class="ka ir"> stateDefinition </strong>属性，并传递您的<strong class="ka ir">customglancestatediation。</strong></p><p id="a96b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，您可以在<strong class="ka ir"> GlanceAppWidget </strong>构造函数中看到，它采用了一个可选参数，即小部件错误状态的XML布局，当设置小部件时出现错误时，该布局就会出现。</p><p id="503d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们看一眼我们的结果(明白了吗？😁).根据我们的类别，小工具图像每15分钟改变一次，或者一旦我们改变类别。</p><figure class="nb nc nd ne gt jr gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/f6ba15c2670578fd9a10e1b6be735872.png" data-original-src="https://miro.medium.com/v2/resize:fit:736/1*9axQ4d71IS_LiCWQaUxswA.gif"/></div><figcaption class="ns nt gj gh gi nu nv bd b be z dk translated">决赛成绩</figcaption></figure><p id="5b3b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">本文到此为止，下面是完整的<a class="ae nx" href="https://github.com/Astroa7m/RemoteWidget" rel="noopener ugc nofollow" target="_blank">源代码</a>。如果你喜欢它，别忘了给知识库一个star⭐和掌声👏🏻对于这篇文章。</p></div></div>    
</body>
</html>