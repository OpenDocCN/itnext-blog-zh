<html>
<head>
<title>Creating your first Node.js REST API with Nest and Typescript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Nest和Typescript创建第一个Node.js REST API</h1>
<blockquote>原文：<a href="https://itnext.io/creating-your-first-node-js-rest-api-with-nest-and-typescript-84863db9da13?source=collection_archive---------6-----------------------#2019-06-17">https://itnext.io/creating-your-first-node-js-rest-api-with-nest-and-typescript-84863db9da13?source=collection_archive---------6-----------------------#2019-06-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="179f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<a class="ae kl" href="https://twitter.com/chris_noring" rel="noopener ugc nofollow" target="_blank">推特</a>上关注我，很乐意接受您对主题或改进的建议/Chris</p><blockquote class="km kn ko"><p id="2327" class="jn jo kp jp b jq jr js jt ju jv jw jx kq jz ka kb kr kd ke kf ks kh ki kj kk ij bi translated"><em class="iq">一个渐进式Node.js框架，用于构建高效、可靠、可伸缩的服务器端应用。</em></p></blockquote><p id="311c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本文中，我们将看看Nest库。一个让编写API成为真正美好体验的库。如果你来自Angular世界，你肯定会认识到你所使用的概念，一个伟大的CLI，当然还有Typescript的伟大用法。</p><p id="aa39" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，它不是有棱角的，但非常接近，以最好的方式。</p><p id="5f14" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本文是Nest系列的一部分，因为我们不可能在一篇文章中涵盖所有内容。</p><p id="0f02" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将涵盖以下内容:</p><ul class=""><li id="243b" class="kt ku iq jp b jq jr ju jv jy kv kc kw kg kx kk ky kz la lb bi translated"><strong class="jp ir">为什么选择Nest </strong>，让我们来看看<em class="kp">的卖点</em>以及让Nest成为你下一个API的绝佳选择的特性</li><li id="0230" class="kt ku iq jp b jq lc ju ld jy le kc lf kg lg kk ky kz la lb bi translated"><strong class="jp ir">您的第一个CRUD项目——涵盖基础知识</strong>,让我们搭建一个项目并检查基本结构</li></ul><h1 id="0f7a" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">为什么要筑巢</h1><p id="1618" class="pw-post-body-paragraph jn jo iq jp b jq mf js jt ju mg jw jx jy mh ka kb kc mi ke kf kg mj ki kj kk ij bi translated">让我们看看<a class="ae kl" href="https://nestjs.com" rel="noopener ugc nofollow" target="_blank">主页</a>上的销售宣传</p><ul class=""><li id="0870" class="kt ku iq jp b jq jr ju jv jy kv kc kw kg kx kk ky kz la lb bi translated"><strong class="jp ir">可扩展</strong>，由于模块化架构，允许使用任何其他库</li><li id="5fe2" class="kt ku iq jp b jq lc ju ld jy le kc lf kg lg kk ky kz la lb bi translated"><strong class="jp ir">多功能</strong>，一个适应性强的生态系统，适用于各种服务器端应用</li><li id="8c60" class="kt ku iq jp b jq lc ju ld jy le kc lf kg lg kk ky kz la lb bi translated"><strong class="jp ir">渐进式</strong>，利用最新的JavaScript特性、设计模式和成熟的解决方案</li></ul><blockquote class="km kn ko"><p id="2caa" class="jn jo kp jp b jq jr js jt ju jv jw jx kq jz ka kb kr kd ke kf ks kh ki kj kk ij bi translated">好的，这听起来很棒，但是给我一些我可以用让我的同事惊叹的东西</p></blockquote><p id="eadc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它完全支持TypeScript，但是如果您愿意，也可以使用纯JavaScript。</p><p id="4970" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它使用底层的库<code class="fe mk ml mm mn b">Express</code>和<code class="fe mk ml mm mn b">Fastify</code>，但是如果需要的话也可以公开它们的API。</p><blockquote class="km kn ko"><p id="cf2b" class="jn jo kp jp b jq jr js jt ju jv jw jx kq jz ka kb kr kd ke kf ks kh ki kj kk ij bi translated"><em class="iq">听起来很有趣，多告诉我一些</em></p></blockquote><p id="c95f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它附带了一个CLI，因此您可以搭建项目以及添加工件。</p><p id="ccf7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最重要的是，你可以用Jest轻松地编写单元测试和E2E测试，还可以用它轻松地构建GraphQL APIs</p><blockquote class="km kn ko"><p id="16e5" class="jn jo kp jp b jq jr js jt ju jv jw jx kq jz ka kb kr kd ke kf ks kh ki kj kk ij bi translated">别说了，你在瞎编</p></blockquote><p id="3de4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">真的没有，看看这个<a class="ae kl" href="https://docs.nestjs.com/graphql/quick-start" rel="noopener ugc nofollow" target="_blank"> Nest和GraphQL </a></p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/505c2f5306c1f9cb6ed3f3245d8eb0ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/0*JxkCJ3akNykgWA4e.gif"/></div></figure><h1 id="fdd2" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">资源</h1><p id="98d9" class="pw-post-body-paragraph jn jo iq jp b jq mf js jt ju mg jw jx jy mh ka kb kc mi ke kf kg mj ki kj kk ij bi translated">我们将在本文中提到一些很棒的资源。如果你错过了我们提到的链接，在这里。</p><ul class=""><li id="45a8" class="kt ku iq jp b jq jr ju jv jy kv kc kw kg kx kk ky kz la lb bi translated">官方文档页面是一个很好的开始。它涵盖了从基础到食谱的所有内容</li><li id="424b" class="kt ku iq jp b jq lc ju ld jy le kc lf kg lg kk ky kz la lb bi translated"><a class="ae kl" href="https://docs.nestjs.com/first-steps" rel="noopener ugc nofollow" target="_blank">概述部分</a>整个概述部分是试图理解核心概念的好读物，您还可以使用CLI来搭建项目</li><li id="1a10" class="kt ku iq jp b jq lc ju ld jy le kc lf kg lg kk ky kz la lb bi translated">食谱里面有很多好的食谱。从如何使用不同的ORM到设置Swagger(顺便说一句，这非常简单)</li></ul><h1 id="02fc" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">你的第一个项目——涵盖基础知识</h1><p id="d8e4" class="pw-post-body-paragraph jn jo iq jp b jq mf js jt ju mg jw jx jy mh ka kb kc mi ke kf kg mj ki kj kk ij bi translated">那好吧。我们开始吧。在我们开始创建我们的第一个项目之前，我们需要CLI来创建和运行我们的项目和许多其他东西。我们可以使用以下命令轻松安装CLI:</p><p id="b171" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来我们需要资助一个项目。接下来让我们开始吧:</p><p id="bb32" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以用自己选择的项目名称替换<code class="fe mk ml mm mn b">hello-world</code>。</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi mw"><img src="../Images/25969f32dc13c17165123309ef179961.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*6qHqrdYpH0diL8_J.png"/></div></div></figure><p id="4c81" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好吧，我们有很多文件。从上面的图片来看，我们似乎已经用<code class="fe mk ml mm mn b">package.json</code>完成了一个Node.js项目，用Jest进行了一些测试，当然还有一堆看起来像是Nest特有的工件，比如<em class="kp">控制器</em>、<em class="kp">模块</em>和<em class="kp">服务</em>。让我们仔细看看脚手架工程:</p><h1 id="96b2" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">它是如何工作的？</h1><p id="7b6e" class="pw-post-body-paragraph jn jo iq jp b jq mf js jt ju mg jw jx jy mh ka kb kc mi ke kf kg mj ki kj kk ij bi translated">在运行我们刚刚搭建的项目之前，让我们先仔细看看，以便理解生命周期。首先让我们看看<code class="fe mk ml mm mn b">main.ts</code>。这是我们应用程序的入口。更具体地说，是<code class="fe mk ml mm mn b">bootstrap()</code>方法通过运行代码来启动一切:</p><pre class="mp mq mr ms gt nb mn nc nd aw ne bi"><span id="1694" class="nf li iq mn b gy ng nh l ni nj">// main.ts<br/><br/>const app = await NestFactory.create(AppModule);<br/>await app.listen(3000);</span></pre><p id="aa98" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好的，所以<code class="fe mk ml mm mn b">NestFactory</code>调用实例化<code class="fe mk ml mm mn b">AppModule</code>的<code class="fe mk ml mm mn b">create()</code>，我们得到一个<code class="fe mk ml mm mn b">app</code>实例，它似乎在端口<code class="fe mk ml mm mn b">3000</code>上监听。让我们去<code class="fe mk ml mm mn b">AppModule</code>看看那里会发生什么:</p><pre class="mp mq mr ms gt nb mn nc nd aw ne bi"><span id="943d" class="nf li iq mn b gy ng nh l ni nj">//app.module.ts<br/><br/>@Module({<br/>  imports: [],<br/>  controllers: [AppController],<br/>  providers: [AppService],<br/>})<br/>export class AppModule {}</span></pre><p id="5237" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好的，我们似乎有一个由<code class="fe mk ml mm mn b">@Module</code>装饰器装饰的类<code class="fe mk ml mm mn b">AppModule</code>，它指定了一个控制器<code class="fe mk ml mm mn b">AppController</code>和一个被归类为提供者<code class="fe mk ml mm mn b">AppService</code>的东西。</p><blockquote class="km kn ko"><p id="6cc3" class="jn jo kp jp b jq jr js jt ju jv jw jx kq jz ka kb kr kd ke kf ks kh ki kj kk ij bi translated">所有这些是如何工作的？</p></blockquote><p id="0716" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">控制器<code class="fe mk ml mm mn b">AppController</code>响应路由请求，让我们看看它是如何设置的:</p><pre class="mp mq mr ms gt nb mn nc nd aw ne bi"><span id="4c8e" class="nf li iq mn b gy ng nh l ni nj">// app.controller.ts<br/><br/>@Controller()<br/>export class AppController {<br/>  constructor(private readonly appService: AppService) {}<br/><br/>  @Get()<br/>  getHello(): string {<br/>    return this.appService.getHello();<br/>  }<br/>}</span></pre><p id="8937" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">装饰器<code class="fe mk ml mm mn b">@Get()</code>确保我们将某个GET请求映射到我们类的某个方法。在这种情况下，默认路由<code class="fe mk ml mm mn b">/</code>将使用方法<code class="fe mk ml mm mn b">getHello()</code>进行响应，该方法又调用<code class="fe mk ml mm mn b">appService.getHello()</code>。让我们来看看<code class="fe mk ml mm mn b">app.service.ts</code>:</p><pre class="mp mq mr ms gt nb mn nc nd aw ne bi"><span id="b1b4" class="nf li iq mn b gy ng nh l ni nj">// app.service.ts<br/><br/>import { Injectable } from '@nestjs/common';<br/><br/>@Injectable()<br/>export class AppService {<br/>  getHello(): string {<br/>    return 'Hello World!';<br/>  }<br/>}</span></pre><p id="6e2a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这似乎是一个非常简单的类，有一个返回字符串的方法<code class="fe mk ml mm mn b">getHello()</code>。</p><p id="a54c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，让我们回到<code class="fe mk ml mm mn b">app.controller.ts</code>。</p><p id="e817" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从图中我们可以看到<code class="fe mk ml mm mn b">appService</code>是这样被注入到<code class="fe mk ml mm mn b">AppController</code>的构造函数中的:</p><pre class="mp mq mr ms gt nb mn nc nd aw ne bi"><span id="0742" class="nf li iq mn b gy ng nh l ni nj">// excerpt from app.controller.ts<br/><br/>constructor(private readonly appService: AppService) {}</span></pre><blockquote class="km kn ko"><p id="f36a" class="jn jo kp jp b jq jr js jt ju jv jw jx kq jz ka kb kr kd ke kf ks kh ki kj kk ij bi translated"><em class="iq">它怎么知道怎么做呢？</em></p></blockquote><p id="50d3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里有两个答案:</p><ol class=""><li id="a995" class="kt ku iq jp b jq jr ju jv jy kv kc kw kg kx kk nk kz la lb bi translated">如果您将<code class="fe mk ml mm mn b">Injectable()</code>装饰器添加到任何服务中，这意味着它可以被注入到其他工件中，比如控制器或服务。</li><li id="4e36" class="kt ku iq jp b jq lc ju ld jy le kc lf kg lg kk nk kz la lb bi translated">这就把我们带到了第二步。我们需要将所述服务添加到模块的<code class="fe mk ml mm mn b">providers</code>数组中，以使DI机制工作。</li></ol><blockquote class="km kn ko"><p id="c0b4" class="jn jo kp jp b jq jr js jt ju jv jw jx kq jz ka kb kr kd ke kf ks kh ki kj kk ij bi translated">哦？</p></blockquote><p id="7bc4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">是的，让我们试着通过添加新路线的动作来巩固这种理解。但在此之前，让我们开始这个项目，并证明它像我们所说的那样工作:</p><pre class="mp mq mr ms gt nb mn nc nd aw ne bi"><span id="f258" class="nf li iq mn b gy ng nh l ni nj">npm start</span></pre><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi mw"><img src="../Images/7e0e264c6265d0b2e595cf4d703189bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*CLG4yzq-8vrIoc34.png"/></div></div></figure><p id="ad82" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，让我们来看看浏览器:</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/440e7f670baafef163201c0e596add65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1148/format:webp/0*hsrh4PCZCOPoGIUE.png"/></div></figure><h1 id="19cf" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">添加路线</h1><p id="b918" class="pw-post-body-paragraph jn jo iq jp b jq mf js jt ju mg jw jx jy mh ka kb kc mi ke kf kg mj ki kj kk ij bi translated">我们刚刚学会了搭建一个项目，也学会了运行同样的项目。我们认为我们已经对概念<em class="kp">模块</em>、<em class="kp">控制器</em>和<em class="kp">服务</em>有了很好的理解，但是没有什么比添加一条新的路线和添加我们需要的所有工件更能巩固这些知识了。我们将执行以下操作:</p><p id="b3ba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将创建一条新路线<code class="fe mk ml mm mn b">/products</code>，为此，我们需要执行以下步骤</p><ol class=""><li id="525f" class="kt ku iq jp b jq jr ju jv jy kv kc kw kg kx kk nk kz la lb bi translated">添加新服务</li><li id="fa77" class="kt ku iq jp b jq lc ju ld jy le kc lf kg lg kk nk kz la lb bi translated">添加一个新的控制器并注入我们的服务</li><li id="3544" class="kt ku iq jp b jq lc ju ld jy le kc lf kg lg kk nk kz la lb bi translated">给去离子装置通电</li><li id="c640" class="kt ku iq jp b jq lc ju ld jy le kc lf kg lg kk nk kz la lb bi translated">运行我们的应用程序并确保一切正常。</li></ol><p id="ec2e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们要做的第一件事是学习如何正确地使用Nest项目。现在我们运行<code class="fe mk ml mm mn b">npm start</code>，它编译了我们的类型脚本代码，并在端口<code class="fe mk ml mm mn b">3000</code>托管了我们的应用程序，但是在开发过程中，我们可能想要一些可以监听变化并自动编译的东西。为此，让我们转而运行命令<code class="fe mk ml mm mn b">npm run start:dev</code>，该命令监听更改并在需要时重新编译。</p><pre class="mp mq mr ms gt nb mn nc nd aw ne bi"><span id="972b" class="nf li iq mn b gy ng nh l ni nj">npm run start:dev</span></pre><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi mw"><img src="../Images/80a08ec1a881838f73a2ebf13cded080.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*OjFy-2kiI9Se6EDH.png"/></div></div></figure><p id="ebea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意，在我们开始使用上面的命令之前，让我们搭建所有需要的文件，然后我们可以运行上面的命令来处理特定的代码文件，我们希望我们的更改能够反映出来。</p><h2 id="f8b8" class="nf li iq bd lj nm nn dn ln no np dp lr jy nq nr lv kc ns nt lz kg nu nv md nw bi translated">创建服务</h2><p id="6759" class="pw-post-body-paragraph jn jo iq jp b jq mf js jt ju mg jw jx jy mh ka kb kc mi ke kf kg mj ki kj kk ij bi translated">让我们创造我们的产品和服务。现在，让数据成为静态的，我们可以稍后再考虑添加HTTP调用。让我们用新的方式做事情，使用命令行界面</p><pre class="mp mq mr ms gt nb mn nc nd aw ne bi"><span id="f15d" class="nf li iq mn b gy ng nh l ni nj">nest generate service products</span></pre><p id="6de9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">或者更简短的版本</p><pre class="mp mq mr ms gt nb mn nc nd aw ne bi"><span id="e7bc" class="nf li iq mn b gy ng nh l ni nj">nest g s products</span></pre><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi mw"><img src="../Images/22c71bf89bc82c64c98dac1c753504af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Ieq23ixHIS9MmytI.png"/></div></div></figure><p id="64a1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好了，打开文件<code class="fe mk ml mm mn b">products/products.service.ts</code>。它应该是这样的:</p><pre class="mp mq mr ms gt nb mn nc nd aw ne bi"><span id="0109" class="nf li iq mn b gy ng nh l ni nj">import { Injectable } from '@nestjs/common';<br/><br/><br/>@Injectable()<br/>export class ProductsService {}</span></pre><p id="681f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在添加方法<code class="fe mk ml mm mn b">getProducts()</code>,看起来像这样:</p><pre class="mp mq mr ms gt nb mn nc nd aw ne bi"><span id="1a49" class="nf li iq mn b gy ng nh l ni nj">import { Injectable } from '@nestjs/common';<br/><br/><br/>@Injectable()<br/>export class ProductsService {<br/>  getProducts() {<br/>    return [{<br/>      id: 1,<br/>      name: 'A SPA app'<br/>    },<br/>    {<br/>      id: 2,<br/>      name: 'A Nest API'<br/>    }]<br/>  }<br/>}</span></pre><h2 id="85df" class="nf li iq bd lj nm nn dn ln no np dp lr jy nq nr lv kc ns nt lz kg nu nv md nw bi translated">添加控制器</h2><p id="1ce2" class="pw-post-body-paragraph jn jo iq jp b jq mf js jt ju mg jw jx jy mh ka kb kc mi ke kf kg mj ki kj kk ij bi translated">创建控制器的时间到了，接下来让我们开始吧。再次我们只是CLI，就像这样:</p><pre class="mp mq mr ms gt nb mn nc nd aw ne bi"><span id="b5d3" class="nf li iq mn b gy ng nh l ni nj">nest generate controller products</span></pre><p id="8ff3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">或者，更简短的版本</p><pre class="mp mq mr ms gt nb mn nc nd aw ne bi"><span id="54f5" class="nf li iq mn b gy ng nh l ni nj">nest g co products</span></pre><p id="d44a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">打开<code class="fe mk ml mm mn b">products/products.controller</code>:</p><pre class="mp mq mr ms gt nb mn nc nd aw ne bi"><span id="eacb" class="nf li iq mn b gy ng nh l ni nj">import { Controller } from '@nestjs/common';<br/><br/>@Controller('products')<br/>export class ProductsController {}</span></pre><p id="b7af" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下一步是添加一个方法<code class="fe mk ml mm mn b">getProducts()</code>，并确保我们调用我们的服务，当然，我们不要忘记用<code class="fe mk ml mm mn b">@Get()</code>装饰器来装饰它。</p><p id="75ba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您的代码现在应该如下所示:</p><pre class="mp mq mr ms gt nb mn nc nd aw ne bi"><span id="da2c" class="nf li iq mn b gy ng nh l ni nj">import { Controller, Get } from '@nestjs/common';<br/>import { ProductsService } from './products.service';<br/><br/>@Controller('products')<br/>export class ProductsController {<br/>  constructor(private productsService: ProductsService) {}<br/><br/>  @Get()<br/>  getProducts() {<br/>    return this.productsService.getProducts();<br/>  }<br/>}</span></pre><p id="1f70" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们试试这个:</p><pre class="mp mq mr ms gt nb mn nc nd aw ne bi"><span id="4c8a" class="nf li iq mn b gy ng nh l ni nj">npm run start:dev</span></pre><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi mw"><img src="../Images/ff566f1f77a11f7be0720b4cf64ecc4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*58upiLjNPsKCwLzs.png"/></div></div></figure><p id="d60c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上面我们可以看到我们的<code class="fe mk ml mm mn b">/products</code>路线似乎是如何被添加的，并且<code class="fe mk ml mm mn b">ProductsController</code>将响应该路线上的任何请求。但是这怎么可能，我们没有做任何事情来连接DI，是吗？</p><p id="0294" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">再来看<code class="fe mk ml mm mn b">app.module.ts</code>:</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi mw"><img src="../Images/8f903f8ade2cb1ede07dc51d91f96695.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*tBB4suVsx3I6Ul1J.png"/></div></div></figure><p id="1960" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从上面我们可以看到<code class="fe mk ml mm mn b">ProductsController</code>和<code class="fe mk ml mm mn b">ProductsService</code>都被分别添加到了<code class="fe mk ml mm mn b">controllers</code>和<code class="fe mk ml mm mn b">providers</code>中。当我们生成控制器和服务时，CLI为我们添加了它。</p><p id="4417" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们几乎忘记了在浏览器中运行我们的应用的一些东西，所以让我们这样做:</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi mw"><img src="../Images/2a40f6942a5f01b517e34c3b635042fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*wv8zAGbnHKdAUNqV.png"/></div></div></figure><p id="de85" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，CLI是强大的，它不仅可以创建必要的文件，还可以进行一些连接，但如果您不使用CLI，请知道您需要做什么。</p><h1 id="26ce" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">添加剩余的CRUD路线</h1><p id="ef94" class="pw-post-body-paragraph jn jo iq jp b jq mf js jt ju mg jw jx jy mh ka kb kc mi ke kf kg mj ki kj kk ij bi translated">好的，所以我们增加了一条路线来支持<code class="fe mk ml mm mn b">/products</code>路线。众所周知，虽然我们需要更多的路线，如<code class="fe mk ml mm mn b">POST</code>、<code class="fe mk ml mm mn b">PUT</code>、<code class="fe mk ml mm mn b">DELETE</code>和<em class="kp">通配符</em>路线等。</p><blockquote class="km kn ko"><p id="aa6d" class="jn jo kp jp b jq jr js jt ju jv jw jx kq jz ka kb kr kd ke kf ks kh ki kj kk ij bi translated">我们如何添加那些？</p></blockquote><p id="49eb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">很简单，我们只需要为每个人创建方法，并添加decorators来支持它，就像这样:</p><pre class="mp mq mr ms gt nb mn nc nd aw ne bi"><span id="61f8" class="nf li iq mn b gy ng nh l ni nj">// products.controller.ts<br/><br/>import { Controller, Get, Param, Post, Body, Put, Delete } from '@nestjs/common';<br/>import { ProductsService } from './products.service';<br/><br/>interface ProductDto {<br/>  id: string;<br/>  name: string;<br/>}<br/><br/>@Controller('products')<br/>export class ProductsController {<br/>  constructor(private productsService: ProductsService) {}<br/><br/>  @Get()<br/>  getProducts() {<br/>    return this.productsService.getProducts();<br/>  }<br/><br/>  @Get(':id') <br/>  getProduct(@Param() params) {<br/>    console.log('get a single product', params.id);<br/>    return this.productsService.getProducts().filter(p =&gt; p.id == params.id);<br/>  }<br/><br/>  @Post()<br/>  createProduct(@Body() product: ProductDto) {<br/>    console.log('create product', product);<br/>    this.productsService.createProduct(product);<br/>  }<br/><br/>  @Put()<br/>  updateProduct(@Body() product: ProductDto) {<br/>    console.log('update product', product);<br/>    this.productsService.updateProduct(product);<br/>  }<br/><br/>  @Delete()<br/>  deleteProduct(@Body() product: ProductDto) {<br/>    console.log('delete product', product.id);<br/>    this.productsService.deleteProduct(product.id);<br/>  }<br/>}</span></pre><p id="6cb0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">而<code class="fe mk ml mm mn b">products.service.ts</code>现在看起来是这样的:</p><pre class="mp mq mr ms gt nb mn nc nd aw ne bi"><span id="ea3b" class="nf li iq mn b gy ng nh l ni nj">import { Injectable } from '@nestjs/common';<br/><br/>@Injectable()<br/>export class ProductsService {<br/>  products = [{<br/>    id: 1,<br/>    name: 'A SPA app'<br/>  },<br/>  {<br/>    id: 2,<br/>    name: 'A Nest API'<br/>  }];<br/><br/>  getProducts() {<br/>    return this.products;<br/>  }<br/><br/>  createProduct(product) {<br/>    this.products = [...this.products, {...product}];<br/>  }<br/><br/>  updateProduct(product) {<br/>    this.products = this.products.map(p =&gt; {<br/>      if (p.id == product.id) {<br/>        return { ...product};<br/>      }<br/>      return p;<br/>    });<br/>  }<br/><br/>  deleteProduct(id) {<br/>    this.products = this.products.filter(p =&gt; p.id != id);<br/>  }<br/>}</span></pre><h1 id="1c9b" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">摘要</h1><p id="0ade" class="pw-post-body-paragraph jn jo iq jp b jq mf js jt ju mg jw jx jy mh ka kb kc mi ke kf kg mj ki kj kk ij bi translated">希望您现在已经意识到了Nest的良好结构，以及创建API、读取查询参数和主体以支持完整的CRUD API是多么容易。我们还引入了CLI，它在生成您需要的代码方面是您最好的朋友，并确保您不需要考虑如何连接。</p><p id="361f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们的下一部分，我们将看看如何测试我们的代码，这是一个真正幸福的体验。敬请关注。</p></div><div class="ab cl nx ny hu nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="ij ik il im in"><p id="54ee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kp">原载于2019年6月17日</em><a class="ae kl" href="https://dev.to/softchris/nest-creating-a-rest-api-has-never-felt-so-good-4i1" rel="noopener ugc nofollow" target="_blank"><em class="kp">https://dev . to</em></a><em class="kp">。</em></p></div></div>    
</body>
</html>