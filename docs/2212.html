<html>
<head>
<title/>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1/>
<blockquote>原文：<a href="https://itnext.io/error-handling-with-async-await-in-js-26c3f20bc06a?source=collection_archive---------0-----------------------#2019-04-17">https://itnext.io/error-handling-with-async-await-in-js-26c3f20bc06a?source=collection_archive---------0-----------------------#2019-04-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/8407388e7c60d4ee39b828c0a9561deb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Aih9FwHjvM6AEL1aBh6W2g.png"/></div></div></figure><p id="a210" class="pw-post-body-paragraph iz ja jb jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx ij bi translated"><em class="jy">(同时发表于</em> <a class="ae jz" href="https://blog.segersian.com/2019/04/17/error-handling-async-await/" rel="noopener ugc nofollow" target="_blank"> <em class="jy">我的博客</em> </a> <em class="jy"> ) </em></p><h1 id="c485" class="ka kb jb bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">用JS中的Async/Await处理错误</h1><p id="da29" class="pw-post-body-paragraph iz ja jb jc b jd ky jf jg jh kz jj jk jl la jn jo jp lb jr js jt lc jv jw jx ij bi translated">这将是一篇小文章，基于我在代码审查和与其他开发人员的讨论中发现的一些问题。本文更侧重于JS开发新手。</p></div><div class="ab cl ld le hu lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="ij ik il im in"><h1 id="d4f1" class="ka kb jb bd kc kd lk kf kg kh ll kj kk kl lm kn ko kp ln kr ks kt lo kv kw kx bi translated"><strong class="ak">简单的试抓</strong></h1><p id="6365" class="pw-post-body-paragraph iz ja jb jc b jd ky jf jg jh kz jj jk jl la jn jo jp lb jr js jt lc jv jw jx ij bi translated">让我们从简单的<code class="fe lp lq lr ls b">try...catch</code>例子开始。</p><figure class="lt lu lv lw gt is"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="cafc" class="pw-post-body-paragraph iz ja jb jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx ij bi translated">这正如预期的那样工作，我们调用函数<code class="fe lp lq lr ls b">thisThrows()</code>，它抛出一个常规错误，我们捕捉它，记录错误，并可选地在<code class="fe lp lq lr ls b">finally</code>块中运行一些代码。这里没有火箭科学。</p><h1 id="1078" class="ka kb jb bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated"><strong class="ak">带有拒绝承诺的试捕</strong></h1><p id="3333" class="pw-post-body-paragraph iz ja jb jc b jd ky jf jg jh kz jj jk jl la jn jo jp lb jr js jt lc jv jw jx ij bi translated">现在我们修改<code class="fe lp lq lr ls b">thisThrows()</code>，这样它实际上拒绝了一个承诺，而不是一个常规错误。为了简单起见，我将制作<code class="fe lp lq lr ls b">thisThrows()</code>函数<code class="fe lp lq lr ls b">async</code>。记住一个<code class="fe lp lq lr ls b">async</code>函数<strong class="jc lz">总是</strong>返回一个承诺:</p><ul class=""><li id="cf00" class="ma mb jb jc b jd je jh ji jl mc jp md jt me jx mf mg mh mi bi translated">当没有定义return语句，或者return语句没有值时，它返回一个解析承诺，相当于<code class="fe lp lq lr ls b">return Promise.Resolve()</code>。</li><li id="0286" class="ma mb jb jc b jd mj jh mk jl ml jp mm jt mn jx mf mg mh mi bi translated">当return语句定义了一个值时，它将返回一个带有给定返回值的解析承诺，相当于<code class="fe lp lq lr ls b">return Promise.Resolve("My return String")</code></li><li id="f6d3" class="ma mb jb jc b jd mj jh mk jl ml jp mm jt mn jx mf mg mh mi bi translated">当抛出一个错误时，一个被拒绝的承诺会和抛出的错误一起返回，相当于<code class="fe lp lq lr ls b">return Promise.Reject(error)</code>。</li></ul><figure class="lt lu lv lw gt is"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="1e69" class="pw-post-body-paragraph iz ja jb jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx ij bi translated">现在我们有了经典的问题，<code class="fe lp lq lr ls b">thisThrows</code>返回一个拒绝的承诺，所以常规的<code class="fe lp lq lr ls b">try...catch</code>不能捕捉错误。由于<code class="fe lp lq lr ls b">thisThrows()</code>是<code class="fe lp lq lr ls b">async</code>，所以当我们调用它时，它调度一个promise，代码不会等待，所以先执行<code class="fe lp lq lr ls b">finally</code>块，然后执行promise，然后拒绝。所以我们没有任何代码来处理这个被拒绝的承诺。</p><p id="6597" class="pw-post-body-paragraph iz ja jb jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx ij bi translated">我们可以用两种方式处理这个问题:</p><ul class=""><li id="445c" class="ma mb jb jc b jd je jh ji jl mc jp md jt me jx mf mg mh mi bi translated">我们在<code class="fe lp lq lr ls b">async</code>函数中调用<code class="fe lp lq lr ls b">thisThrows()</code>，在<code class="fe lp lq lr ls b">thisThrows()</code>函数中调用<code class="fe lp lq lr ls b">await</code>。</li><li id="8402" class="ma mb jb jc b jd mj jh mk jl ml jp mm jt mn jx mf mg mh mi bi translated">我们用一个<code class="fe lp lq lr ls b">.catch()</code>调用来链接<code class="fe lp lq lr ls b">thisThrows()</code>函数调用。</li></ul><p id="84f6" class="pw-post-body-paragraph iz ja jb jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx ij bi translated">第一个解决方案如下所示:</p><figure class="lt lu lv lw gt is"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="0ac9" class="pw-post-body-paragraph iz ja jb jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx ij bi translated">第二个是:</p><figure class="lt lu lv lw gt is"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="087c" class="pw-post-body-paragraph iz ja jb jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx ij bi translated">两种解决方案都很好，但是第一种更容易推理(至少在我个人看来)。</p></div><div class="ab cl ld le hu lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="ij ik il im in"><h1 id="0527" class="ka kb jb bd kc kd lk kf kg kh ll kj kk kl lm kn ko kp ln kr ks kt lo kv kw kx bi translated">警告</h1><p id="5e02" class="pw-post-body-paragraph iz ja jb jc b jd ky jf jg jh kz jj jk jl la jn jo jp lb jr js jt lc jv jw jx ij bi translated">我们看了有错误和没有错误的简单错误处理。现在让我们来看看一些特殊情况。</p><h2 id="de4a" class="mo kb jb bd kc mp mq dn kg mr ms dp kk jl mt mu ko jp mv mw ks jt mx my kw mz bi translated">从异步函数返回</h2><p id="4e1f" class="pw-post-body-paragraph iz ja jb jc b jd ky jf jg jh kz jj jk jl la jn jo jp lb jr js jt lc jv jw jx ij bi translated">先来个脑筋急转弯，下面这段代码会怎么样？</p><figure class="lt lu lv lw gt is"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="9772" class="pw-post-body-paragraph iz ja jb jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx ij bi translated">起初，我们可能期望输出是:</p><pre class="lt lu lv lw gt na ls nb nc aw nd bi"><span id="d6a6" class="mo kb jb ls b gy ne nf l ng nh">We do cleanup here<br/>Nothing Found</span></pre><p id="7f1f" class="pw-post-body-paragraph iz ja jb jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx ij bi translated">但是，我们却得到了一个<code class="fe lp lq lr ls b">UnhandledPromiseRejection</code>！但是为什么呢？让我们单步执行代码:</p><ul class=""><li id="5397" class="ma mb jb jc b jd je jh ji jl mc jp md jt me jx mf mg mh mi bi translated"><code class="fe lp lq lr ls b">thisThrows()</code>是一种<code class="fe lp lq lr ls b">async</code>方法</li><li id="8819" class="ma mb jb jc b jd mj jh mk jl ml jp mm jt mn jx mf mg mh mi bi translated">我们在<code class="fe lp lq lr ls b">thisThrows()</code>抛出一个错误</li><li id="d2a7" class="ma mb jb jc b jd mj jh mk jl ml jp mm jt mn jx mf mg mh mi bi translated">当<code class="fe lp lq lr ls b">thisThrows()</code>为<code class="fe lp lq lr ls b">async</code>时，抛出的错误作为拒绝的承诺从函数返回。</li><li id="4edc" class="ma mb jb jc b jd mj jh mk jl ml jp mm jt mn jx mf mg mh mi bi translated">我们用<code class="fe lp lq lr ls b">return</code>语句返回<code class="fe lp lq lr ls b">myFunctionThatCatches()</code>中拒绝的承诺。</li><li id="044e" class="ma mb jb jc b jd mj jh mk jl ml jp mm jt mn jx mf mg mh mi bi translated">我们被拒绝的承诺达到了<code class="fe lp lq lr ls b">await</code>关键词。<code class="fe lp lq lr ls b">await</code>关键字发现承诺以“拒绝”状态解决，并将错误作为未处理的承诺拒绝进行传播。</li></ul><p id="8caa" class="pw-post-body-paragraph iz ja jb jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx ij bi translated">基于我们的代码是如何构造的，我们的错误悄悄越过了我们的<code class="fe lp lq lr ls b">try...catch</code>块，并在调用树中进一步向下传播。不好！</p><p id="67ee" class="pw-post-body-paragraph iz ja jb jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx ij bi translated">我们通过在return语句中使用<code class="fe lp lq lr ls b">await</code>关键字来解决这个问题。</p><figure class="lt lu lv lw gt is"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="4abd" class="pw-post-body-paragraph iz ja jb jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx ij bi translated">现在我们的<code class="fe lp lq lr ls b">try..catch</code>按预期工作。现在第<code class="fe lp lq lr ls b">7</code>行的<code class="fe lp lq lr ls b">await</code>关键字将首先等待返回的<code class="fe lp lq lr ls b">thisThrows()</code>承诺，如果该承诺拒绝，错误将传播到第<code class="fe lp lq lr ls b">8</code>行的<code class="fe lp lq lr ls b">catch</code>块。问题解决了！</p><h2 id="32f6" class="mo kb jb bd kc mp mq dn kg mr ms dp kk jl mt mu ko jp mv mw ks jt mx my kw mz bi translated">重置堆栈跟踪</h2><p id="2774" class="pw-post-body-paragraph iz ja jb jc b jd ky jf jg jh kz jj jk jl la jn jo jp lb jr js jt lc jv jw jx ij bi translated">如何处理这些用例将因具体情况而异，请确保意识到这个常见错误，然后决定它是否与您相关。</p><p id="9981" class="pw-post-body-paragraph iz ja jb jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx ij bi translated">在代码中，人们捕捉到一个错误并将其包装在一个新的错误中，这种情况并不少见，如下面的代码片段所示:</p><figure class="lt lu lv lw gt is"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="61b9" class="pw-post-body-paragraph iz ja jb jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx ij bi translated">请注意，我们的堆栈跟踪只从我们捕获原始异常的地方开始。当我们在第<code class="fe lp lq lr ls b">2</code>行创建一个错误并在第<code class="fe lp lq lr ls b">9</code>行捕获它时，我们会丢失原始的堆栈跟踪，因为我们现在创建了一个类型为<code class="fe lp lq lr ls b">TypeError</code>的新错误，并且只保留原始的错误消息(有时我们甚至不这样做)。</p><p id="85f8" class="pw-post-body-paragraph iz ja jb jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx ij bi translated">想象一下,<code class="fe lp lq lr ls b">thisThrows()</code>函数中有更多的逻辑，并且在该函数中的某个地方抛出了一个错误，我们不会在我们记录的堆栈跟踪中看到问题的根源，因为我们创建了一个新的错误，这将构建一个全新的堆栈跟踪。如果我们只是重新抛出我们原来的错误，我们就不会有这个问题:</p><figure class="lt lu lv lw gt is"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="32b0" class="pw-post-body-paragraph iz ja jb jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx ij bi translated">请注意，堆栈跟踪现在指向实际错误的来源，位于我们脚本的第<code class="fe lp lq lr ls b">2</code>行。</p><p id="a654" class="pw-post-body-paragraph iz ja jb jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx ij bi translated">在处理错误时，意识到这个问题很重要。有时这可能是可取的，但通常这混淆了问题的根源，使得很难调试问题的根源。如果您为包装错误创建了自己的自定义错误，请确保跟踪原始堆栈跟踪，这样调试就不会变成一场噩梦。</p></div><div class="ab cl ld le hu lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="ij ik il im in"><h1 id="06cb" class="ka kb jb bd kc kd lk kf kg kh ll kj kk kl lm kn ko kp ln kr ks kt lo kv kw kx bi translated">摘要</h1><ul class=""><li id="57b9" class="ma mb jb jc b jd ky jh kz jl ni jp nj jt nk jx mf mg mh mi bi translated">我们可以使用<code class="fe lp lq lr ls b">try...catch</code>进行同步编码。</li><li id="0337" class="ma mb jb jc b jd mj jh mk jl ml jp mm jt mn jx mf mg mh mi bi translated">我们可以使用<code class="fe lp lq lr ls b">try...catch</code>(结合<code class="fe lp lq lr ls b">async</code>函数)和<code class="fe lp lq lr ls b">.catch()</code>方法来处理异步代码的错误。</li><li id="bec1" class="ma mb jb jc b jd mj jh mk jl ml jp mm jt mn jx mf mg mh mi bi translated">当在一个<code class="fe lp lq lr ls b">try</code>块中返回一个承诺时，如果你想让<code class="fe lp lq lr ls b">try...catch</code>块捕捉错误，确保<code class="fe lp lq lr ls b">await</code>它。</li><li id="a39c" class="ma mb jb jc b jd mj jh mk jl ml jp mm jt mn jx mf mg mh mi bi translated">请注意，在包装错误并重新引发时，您会丢失错误来源的堆栈跟踪。</li></ul></div><div class="ab cl ld le hu lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="ij ik il im in"><p id="adad" class="pw-post-body-paragraph iz ja jb jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx ij bi translated">如果你喜欢这篇文章，给我一个👏给出反馈或者在评论中留下一些建设性的反馈。你可能也会喜欢我的一些其他文章:</p><div class="ip iq gp gr ir nl"><a href="https://medium.com/@segersian/javascript-things-newbies-should-know-e04bab10449f" rel="noopener follow" target="_blank"><div class="nm ab fo"><div class="nn ab no cl cj np"><h2 class="bd lz gy z fp nq fr fs nr fu fw ns bi translated">JavaScript:新手应该知道的事情</h2><div class="nt l"><h3 class="bd b gy z fp nq fr fs nr fu fw dk translated">了解更多关于JavaScript生态系统的核心概念。</h3></div><div class="nu l"><p class="bd b dl z fp nq fr fs nr fu fw dk translated">medium.com</p></div></div><div class="nv l"><div class="nw l nx ny nz nv oa ix nl"/></div></div></a></div><div class="ip iq gp gr ir nl"><a href="https://medium.com/@segersian/a-developer-introduction-to-the-cloud-91012abbaed4" rel="noopener follow" target="_blank"><div class="nm ab fo"><div class="nn ab no cl cj np"><h2 class="bd lz gy z fp nq fr fs nr fu fw ns bi translated">开发人员对云的介绍</h2><div class="nt l"><h3 class="bd b gy z fp nq fr fs nr fu fw dk translated">了解和区分云供应商及其众多产品的快速指南。</h3></div><div class="nu l"><p class="bd b dl z fp nq fr fs nr fu fw dk translated">medium.com</p></div></div><div class="nv l"><div class="ob l nx ny nz nv oa ix nl"/></div></div></a></div><div class="ip iq gp gr ir nl"><a href="https://medium.com/@segersian/howto-async-generators-in-nodejs-c7f0851f9c02" rel="noopener follow" target="_blank"><div class="nm ab fo"><div class="nn ab no cl cj np"><h2 class="bd lz gy z fp nq fr fs nr fu fw ns bi translated">how to:NodeJS中的异步生成器</h2><div class="nt l"><h3 class="bd b gy z fp nq fr fs nr fu fw dk translated">如何使用新的ES2018功能，如异步发生器功能和for-async-of循环。</h3></div><div class="nu l"><p class="bd b dl z fp nq fr fs nr fu fw dk translated">medium.com</p></div></div><div class="nv l"><div class="oc l nx ny nz nv oa ix nl"/></div></div></a></div></div></div>    
</body>
</html>