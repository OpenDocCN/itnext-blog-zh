<html>
<head>
<title>A developer-first layout engine for web</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一个开发者优先的web布局引擎</h1>
<blockquote>原文：<a href="https://itnext.io/first-of-all-this-article-has-a-bit-of-a-headline-and-i-apologize-to-the-readers-c7f6e66952af?source=collection_archive---------5-----------------------#2021-04-27">https://itnext.io/first-of-all-this-article-has-a-bit-of-a-headline-and-i-apologize-to-the-readers-c7f6e66952af?source=collection_archive---------5-----------------------#2021-04-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/3294ca2a7b32e2e023e62b0ec89d2638.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9tzSfXFHIKr00l_MeV13NA.png"/></div></div></figure><p id="7ff5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，这篇文章有点标题，我向读者道歉。这篇文章的标题是布局引擎。但我建议你一定要看这篇标题党文章，看完一定会有所收获。</p><h1 id="1003" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">为什么要写这篇文章？</h1><p id="b5c1" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">前几天，我发布了我的一个前端开源项目，名为:<a class="ae lz" href="https://github.com/forsigner/fower" rel="noopener ugc nofollow" target="_blank"> Fower </a>。很多用户问我Fower和Tailwindcss有什么区别？我的回答是，福勒也有同样的哲学——功利第一。其实效用至上理念的CSS框架早就有了，比如:<a class="ae lz" href="https://acss.io/" rel="noopener ugc nofollow" target="_blank"> ACSS </a>、<a class="ae lz" href="https://tachyons.io/" rel="noopener ugc nofollow" target="_blank"> Tachyons </a>。</p><p id="872a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Fower和Tailwindcss最大的区别之一就是Fower提供了一个非常好用的布局工具:Fower Layout toolkit，这也是我写这篇文章的原因。下面我将详细分享开发Fower布局的初衷及其设计思路。</p><h1 id="66b6" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">Web布局历史记录</h1><p id="dd30" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">让我们简单回顾一下网页布局的历史。在Web布局的整个演变过程中，我们经历了无布局、表格布局、定位布局、浮动布局、Flexbox布局、网格布局。<br/>这里就不细说各种布局的特点和优缺点了。我只说一下我个人的观点和结论:现阶段考虑功能性、易用性、浏览器兼容性等。，使用Flexbox布局是最好的选择。有兴趣了解更多的人可以看看下面这篇文章。</p><ul class=""><li id="02ba" class="ma mb iq ka b kb kc kf kg kj mc kn md kr me kv mf mg mh mi bi translated"><a class="ae lz" href="http://grid-layout.com/history.html" rel="noopener ugc nofollow" target="_blank">网页布局历史</a></li><li id="7897" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated"><a class="ae lz" href="https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Flexbox" rel="noopener ugc nofollow" target="_blank">柔性盒</a></li><li id="3c8b" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated"><a class="ae lz" href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Grid_Layout" rel="noopener ugc nofollow" target="_blank"> CSS网格布局</a></li></ul><h1 id="228e" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">布局的核心</h1><p id="c287" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">在我看来，布局的核心是处理容器和物品在某个方向(x，y)上的空间关系。这里有四个基本要素:容器、元素、方向和空间关系。其实这也是flexbox布局的核心。几乎所有flexbox布局的概念和用法都是围绕这四个元素开发的。当我们得到一个设计草图时，如果我们能快速识别出其中的容器和元素，并明确它们的空间关系，我们就能快速构建界面。</p><h1 id="3d57" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">草图和图中的布局</h1><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/93df81f0cc9520ff8f76d51c2caef89d.png" data-original-src="https://miro.medium.com/v2/resize:fit:932/0*mxU8SisAUWDrU2Ub"/></div></figure><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/28d68e402dd408b7908b33c3c2c29352.png" data-original-src="https://miro.medium.com/v2/resize:fit:932/0*W30vR8G6_8v1p61V"/></div></figure><p id="07df" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Figma和Sketch是两个非常知名的设计软件。我们可以看到，他们在处理元素空间关系时一贯使用非常生动的指令:上对齐、右对齐、下对齐、左对齐、基于空间对齐。这也是最直观的方式。</p><h1 id="9c86" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">Swift UI和Flutter中的布局</h1><p id="1ac6" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">现在我们来看两个现代UI解决方案:Swift UI和Flutter，它们是如何处理UI布局的。</p><p id="91dd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在Swift UI中，我们可以看到HStack、VStack、aligment、space等关键词。我们发现Swift UI也是围绕四个元素开发的:容器、元素、方向和空间关系:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="ddf9" class="my kx iq mu b gy mz na l nb nc">struct ContentView: View {<br/>    var body: some View {<br/>        HStack(alignment: .top) {<br/>            VStack {<br/>                CalendarView()<br/>                Spacer()<br/>            }<br/>            VStack(alignment: .leading) {<br/>                Text("Event title").font(.title)<br/>                Text("Location")<br/>            }<br/>            Spacer()<br/>        }.padding()<br/>    }<br/>}</span></pre><p id="68d6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在Flutter中，我们可以看到行、列、对齐和空间等关键字。我们发现颤振也是围绕容器、元素、方向和空间关系这四个要素展开的:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="550f" class="my kx iq mu b gy mz na l nb nc">Row(<br/>  mainAxisAlignment: MainAxisAlignment.spaceEvenly,<br/>  children: [<br/>    Image.asset('images/pic1.jpg'),<br/>    Image.asset('images/pic2.jpg'),<br/>    Image.asset('images/pic3.jpg'),<br/>  ],<br/>);</span><span id="11a9" class="my kx iq mu b gy nd na l nb nc">Column(<br/>  mainAxisAlignment: MainAxisAlignment.spaceEvenly,<br/>  children: [<br/>    Image.asset('images/pic1.jpg'),<br/>    Image.asset('images/pic2.jpg'),<br/>    Image.asset('images/pic3.jpg'),<br/>  ],<br/>);</span></pre><p id="8a78" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们发现Swift UI和Flutter的布局理念与Flexbox布局非常相似。此外，我们发现他们的布局代码直接附加在容器和元素上，不像传统的Web，样式代码需要分离到单个CSS文件中。Fower和Swift UI和Fluter使用相似的概念，风格是容器和元素的一部分，这也是现代UI开发的选择</p><p id="3cb9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一些参考资料:</p><ul class=""><li id="6d84" class="ma mb iq ka b kb kc kf kg kj mc kn md kr me kv mf mg mh mi bi translated"><a class="ae lz" href="https://www.swiftbysundell.com/articles/swiftui-layout-system-guide-part-1/" rel="noopener ugc nofollow" target="_blank">https://www . swiftbysundell . com/articles/swift ui-layout-system-guide-part-1/</a></li><li id="168d" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated"><a class="ae lz" href="https://flutter.dev/docs/development/ui/layout" rel="noopener ugc nofollow" target="_blank">https://flutter.dev/docs/development/ui/layout</a></li></ul><h1 id="0da2" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">Flexbox布局的缺点</h1><p id="4be5" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">上面提到了设计软件和现代UI框架的布局方法。它们与Flexbox布局概念非常相似。Flexbox布局的缺点是什么？</p><p id="761b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">虽然Flexbox很优秀，但对我来说，它有一个最大的缺点，那就是它不是开发者优先的。Flexbox布局不够好用，开发者体验不够好。</p><p id="d89e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Flexbox有许多概念:主轴、横轴、方向、对齐项目、对齐内容、伸缩开始、伸缩结束、伸缩中心等。最大的问题是当主轴方向发生变化时，<code class="fe ne nf ng mu b">align-items</code>、<code class="fe ne nf ng mu b">justify-content</code>等属性使得UI的呈现非常不符合人的直觉。尤其是对于不经常写UI的我(经常需要写后端，做杂等。)，每隔一段时间，我可能会忘记<code class="fe ne nf ng mu b">align-items</code>、<code class="fe ne nf ng mu b">justify-content</code>的用法。</p><h1 id="795f" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">我的理想布局(设计方案)</h1><p id="ce8a" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">上面我们讲了Flexbox布局的缺点:不是开发者优先。</p><p id="f539" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我理想中的布局方式应该和现代设计软件一样好用。我们只需要关注布局的四个要素:容器、元素、方向、空间关系。用法是找到容器和元素，设置元素在容器中的方向，然后设置空间关系。</p><p id="89a9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里的核心是如何表达空间关系。我觉得最直观的表达方式就是设计软件。我把这种表达方式抽象为:toCenter，to centex，toCenterY，toTop，toRight，toBottom，toLeft，toBetween，toAround，toEvenly。</p><ul class=""><li id="c9db" class="ma mb iq ka b kb kc kf kg kj mc kn md kr me kv mf mg mh mi bi translated">要居中，使子元素居中对齐，请参见<a class="ae lz" href="https://fower.vercel.app/docs/to-center" rel="noopener ugc nofollow" target="_blank">在线演示</a></li><li id="5330" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated">使子元素水平居中对齐，参见<a class="ae lz" href="https://fower.vercel.app/docs/to-center-x" rel="noopener ugc nofollow" target="_blank">在线演示</a></li><li id="639f" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated">要使子元素垂直居中对齐，请参见<a class="ae lz" href="https://fower.vercel.app/docs/to-center-y" rel="noopener ugc nofollow" target="_blank">在线演示</a></li><li id="75b6" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated">顶部，使子元素向左对齐，参见<a class="ae lz" href="https://fower.vercel.app/docs/to-left" rel="noopener ugc nofollow" target="_blank">在线演示</a></li><li id="a1c6" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated">向右，使子元素向右对齐，参见<a class="ae lz" href="https://fower.vercel.app/docs/to-right" rel="noopener ugc nofollow" target="_blank">在线演示</a></li><li id="669e" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated">底部，使子元素与底部对齐，参见<a class="ae lz" href="https://fower.vercel.app/docs/to-bottom" rel="noopener ugc nofollow" target="_blank">在线演示</a></li><li id="43ad" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated">向左，使子元素向左对齐，参见<a class="ae lz" href="https://fower.vercel.app/docs/to-left" rel="noopener ugc nofollow" target="_blank">在线演示</a></li><li id="1e08" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated">要使子元素之间有间隔，请参见<a class="ae lz" href="https://fower.vercel.app/docs/to-between" rel="noopener ugc nofollow" target="_blank">在线演示</a></li><li id="948e" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated">甚至，使子元素空间均匀，参见<a class="ae lz" href="https://fower.vercel.app/docs/to-evenly" rel="noopener ugc nofollow" target="_blank">在线演示</a></li><li id="47ba" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated">为圆，使儿童元素周围的空间，见<a class="ae lz" href="https://fower.vercel.app/docs/to-around" rel="noopener ugc nofollow" target="_blank">在线演示</a></li></ul><p id="0fe0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">不管你的容器是水平的(行)还是垂直的(列)，这些指令的表达式比如toRight和toBottom都会符合你的视觉习惯。</p><p id="d476" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为什么这种抽象的表达方式更好？我认为有几个优点:</p><ul class=""><li id="65dc" class="ma mb iq ka b kb kc kf kg kj mc kn md kr me kv mf mg mh mi bi translated">更符合人的直觉。你只需要记得按照方向来处理空间关系就可以了，比如:toRight，toBotom等。没有比这更符合人类直觉的了。另一个好处是，你的记忆负担会变得很小。</li><li id="131f" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated">更少的代码，更好的可维护性，更高的开发效率</li></ul><p id="d41e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我理想的写代码方式(伪代码):</p><p id="a4ef" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">1.下面的代码会自动将容器中的元素水平和垂直居中，容器方向默认为row，所以可以省略:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="a1b4" class="my kx iq mu b gy mz na l nb nc">&lt;Container toCenter&gt;<br/>  &lt;ItemA /&gt;<br/>&lt;/Container&gt;</span></pre><p id="0e5a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">效果如下:</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nh"><img src="../Images/6455d7c0278e89bd5b94162fd5405ef9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*89U-mL7fRbZoCL_R"/></div></div></figure><p id="a305" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">2.下面的代码将把三个元素A、B、C在容器中右对齐。容器默认为row，因此可以省略:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="8eb9" class="my kx iq mu b gy mz na l nb nc">&lt;Container toRight&gt;<br/>  &lt;ItemA /&gt;<br/>  &lt;ItemB /&gt;<br/>  &lt;ItemC /&gt;<br/>&lt;/Container&gt;</span></pre><p id="5033" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">效果如下:</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nh"><img src="../Images/8ea66c009031d7d69ec343d1d6927b71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2pUX4F7I5l_DQZ0I"/></div></div></figure><p id="c064" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">3.下面的代码将使两个元素A和B在容器中向右对齐。这次我们声明column，所以元素是垂直排列的:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="d82e" class="my kx iq mu b gy mz na l nb nc">&lt;Container column toRight&gt;<br/>  &lt;ItemA /&gt;<br/>  &lt;ItemB /&gt;<br/>&lt;/Container&gt;</span></pre><p id="9acd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">效果如下:</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nh"><img src="../Images/8db4a4e50b574a6bdb1f270230df59ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*z8d1b04xgJMvR7Ia"/></div></div></figure><p id="6ba9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">4.使用成分:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="56f6" class="my kx iq mu b gy mz na l nb nc">&lt;Container toBetween toCenterY&gt;<br/>  &lt;ItemA /&gt;<br/>  &lt;ItemB /&gt;<br/>  &lt;ItemC /&gt;<br/>&lt;/Container&gt;</span></pre><p id="cc95" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">效果如下:</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nh"><img src="../Images/55c778a1adf358467d3ed8d61e3d4125.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*09w99HM0GhM9LviP"/></div></div></figure><p id="18cf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里只是四个伪代码的例子。事实上，您可以使用“toLeft”、“toRight”和其他指令来实现大多数UI布局。</p><p id="1903" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面，我们抽象了空间关系的表达式，并将指令应用于容器。让我们来看看一个布局效果，你会如何用代码来构建它？</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nh"><img src="../Images/440b7e1f8c954ac7c059c9408c5f06ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*R2R6lDX1lQAqbW21"/></div></div></figure><p id="692e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我来说说我的理想方案，伪代码如下:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="b783" class="my kx iq mu b gy mz na l nb nc">&lt;Container toBetween toCenterY&gt;<br/>  &lt;ItemA /&gt;<br/>  &lt;ItemB selfBottom /&gt;<br/>  &lt;ItemC /&gt;<br/>&lt;/Container&gt;</span></pre><p id="016d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里我们抽象出另一种类型的指令:selfTop，selfRight，selfBottom，selfLeft，selfStretch。这些指令可以作用于元素，单独控制元素的对齐。</p><p id="4bb5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以我们有一些作用于元素的指令:</p><ul class=""><li id="8ea7" class="ma mb iq ka b kb kc kf kg kj mc kn md kr me kv mf mg mh mi bi translated">selfTop，使元素靠上对齐</li><li id="98c6" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated">selfRight，使元素靠右对齐</li><li id="5455" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated">selfBottom，使元素靠下对齐</li><li id="0e84" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated">selfLeft，使元素左对齐</li><li id="b6b4" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated">自拉伸，使元素自动拉伸</li></ul><p id="7e6a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，总结我们的布局工具设计计划:</p><ul class=""><li id="3a29" class="ma mb iq ka b kb kc kf kg kj mc kn md kr me kv mf mg mh mi bi translated">容器方向控制指令，使用row，column，如果没有声明，默认为row</li><li id="b824" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated">内部元素的容器对齐指令:toCenter、to centex、toCenterY、toTop、toRight、toBottom、toLeft、toBetween、toAround、toEvenly，这些指令可用于控制子元素的对齐，与行和列方向无关</li><li id="e4d4" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated">元素自对齐指令:selfTop、selfRight、selfBottom、selfLeft、selfStretch。这些指令分别控制元素本身的对齐方式</li><li id="239a" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated">当使用任何容器指令时，flexbox布局将自动触发，无需手动设置<code class="fe ne nf ng mu b">display: flex;</code></li></ul><p id="a4cd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">以上4个设计理念是我个人的理想布局。</p><h1 id="025e" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">前布局</h1><p id="d419" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">回到我们的标题:开发者第一的网页布局引擎。其实flex layout不能称之为布局引擎，那么它是什么呢？也许我们称之为布局工具包会更恰当。</p><p id="cc3e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里的布局引擎指的是:<a class="ae lz" href="https://fower.vercel.app/docs/fower-layout-introduction" rel="noopener ugc nofollow" target="_blank"> Fower layout toolkit </a>，一个基于flexbox的布局工具。</p><p id="fcf5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Fower layout最大的特点就是开发者至上，使用起来非常简单，符合人的直觉。</p><p id="41f6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">关于更详细的Fower布局信息，可以看看官方文档的介绍:<a class="ae lz" href="https://fower.vercel.app/docs/fower-layout-introduction" rel="noopener ugc nofollow" target="_blank"> Fower布局介绍</a></p></div></div>    
</body>
</html>