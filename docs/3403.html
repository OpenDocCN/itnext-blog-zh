<html>
<head>
<title>Do More With Less JavaScript — Clean &amp; Simple Shorthand</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用更少的JavaScript做更多的事——简洁明了的简写</h1>
<blockquote>原文：<a href="https://itnext.io/do-more-with-less-javascript-clean-simple-shorthand-d10b245f1338?source=collection_archive---------0-----------------------#2019-12-07">https://itnext.io/do-more-with-less-javascript-clean-simple-shorthand-d10b245f1338?source=collection_archive---------0-----------------------#2019-12-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="e194" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">清理您的JAVASCRIPT</h2><div class=""/><div class=""><h2 id="b92a" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">我们不要把事情复杂化。使用普通JavaScript表达式的简写替代方法提高可读性。</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/8e093fe1d32e76801a7475acf9b87f01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AVxEwuCL0DgCnlNL3PZ-jg.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">您正在编写肮脏、混乱的代码(影响您代码库的每一个区域)。</figcaption></figure><h1 id="0186" class="lh li it bd lj lk ll lm ln lo lp lq lr ki ls kj lt kl lu km lv ko lw kp lx ly bi translated">与认知超载作斗争</h1><p id="683d" class="pw-post-body-paragraph lz ma it mb b mc md kd me mf mg kg mh mi mj mk ml mm mn mo mp mq mr ms mt mu im bi translated">编写干净的代码并不仅仅意味着用更漂亮的格式，遵循最佳实践，或者留下一些好的注释，给你的代码实际上正在发生的事情一些线索。它包括为那些愿意阅读、试图理解和使用你的代码的人写代码，并带有一定的<strong class="mb jd">同理心</strong>。这可能意味着选择<strong class="mb jd">替代方法</strong>或<strong class="mb jd">工具</strong>，根据<strong class="mb jd">如何适应其环境</strong>来实现相同的目标。</p><h2 id="d08d" class="mv li it bd lj mw mx dn ln my mz dp lr mi na nb lt mm nc nd lv mq ne nf lx iz bi translated">问自己一些问题</h2><ul class=""><li id="0390" class="ng nh it mb b mc md mf mg mi ni mm nj mq nk mu nl nm nn no bi translated">清楚发生了什么吗？(你努力实现的目标)</li><li id="b16c" class="ng nh it mb b mc np mf nq mi nr mm ns mq nt mu nl nm nn no bi translated"><strong class="mb jd">读起来是不是让人望而生畏？</strong>(好像你要再喝点咖啡)</li><li id="8711" class="ng nh it mb b mc np mf nq mi nr mm ns mq nt mu nl nm nn no bi translated">你有没有让它看起来比实际更复杂？(你是不是工程过度了)</li></ul><blockquote class="nu"><p id="6e9e" class="nv nw it bd nx ny nz oa ob oc od mu dk translated">干净的代码减少了认知负荷，更有效地传达了意图，并减少了跟上逻辑所需的时间，以<strong class="ak">扩展</strong>、<strong class="ak">改进</strong>或<strong class="ak">添加</strong>到功能中。</p></blockquote><h2 id="ac30" class="mv li it bd lj mw oe dn ln my of dp lr mi og nb lt mm oh nd lv mq oi nf lx iz bi translated">改变你的习惯</h2><p id="2e65" class="pw-post-body-paragraph lz ma it mb b mc md kd me mf mg kg mh mi mj mk ml mm mn mo mp mq mr ms mt mu im bi translated">有时候，你写的代码是完美的<strong class="mb jd">有效的</strong>、<strong class="mb jd">可用的</strong>和<strong class="mb jd">有点可读的</strong>，但是你可能绕过了解决问题的道路。也许那是因为你还没有努力开始使用<a class="ae oj" href="http://es6-features.org/#Constants" rel="noopener ugc nofollow" target="_blank"> <strong class="mb jd">更新的语法</strong> </a>，或者你还停留在你的工作方式和你的<strong class="mb jd">思维过程中。</strong></p><p id="ff77" class="pw-post-body-paragraph lz ma it mb b mc ok kd me mf ol kg mh mi om mk ml mm on mo mp mq oo ms mt mu im bi translated">也许是时候通过创造新习惯来改变你的习惯了。用解决相同问题的简写替代方案来代替它们。这需要不断地问自己问题，直到你习惯了新的方法。</p><p id="0573" class="pw-post-body-paragraph lz ma it mb b mc ok kd me mf ol kg mh mi om mk ml mm on mo mp mq oo ms mt mu im bi translated">将要讨论的速记表达式有其局限性。它们<strong class="mb jd">并不总是正确的选择</strong>，就像任何工具一样。<strong class="mb jd">然而</strong>，它们是有效的语言特性&amp;语法。</p><p id="76b4" class="pw-post-body-paragraph lz ma it mb b mc ok kd me mf ol kg mh mi om mk ml mm on mo mp mq oo ms mt mu im bi translated">你可能对使用的一些代码有强烈的感觉。如果是这样的话，我想听听！</p><blockquote class="op oq or"><p id="4b6f" class="lz ma os mb b mc ok kd me mf ol kg mh ot om mk ml ou on mo mp ov oo ms mt mu im bi translated">如果你有一个<strong class="mb jd">配置良好的</strong> <a class="ae oj" href="https://eslint.org" rel="noopener ugc nofollow" target="_blank"> <strong class="mb jd"> linter </strong> </a>那么你可以<strong class="mb jd">包含</strong> <a class="ae oj" href="https://www.npmjs.com/package/eslint-config-airbnb" rel="noopener ugc nofollow" target="_blank"> <strong class="mb jd">规则</strong> </a>来帮助你用<strong class="mb jd">首选语法</strong>进行编写。</p></blockquote><p id="6d48" class="pw-post-body-paragraph lz ma it mb b mc ok kd me mf ol kg mh mi om mk ml mm on mo mp mq oo ms mt mu im bi translated">让我们从一个简单的开始</p><h1 id="6ce2" class="lh li it bd lj lk ll lm ln lo lp lq lr ki ls kj lt kl lu km lv ko lw kp lx ly bi translated">简化您的真实性检查</h1><h2 id="11f0" class="mv li it bd lj mw mx dn ln my mz dp lr mi na nb lt mm nc nd lv mq ne nf lx iz bi translated">充分发挥“真实”的潜力</h2><p id="b3fb" class="pw-post-body-paragraph lz ma it mb b mc md kd me mf mg kg mh mi mj mk ml mm mn mo mp mq mr ms mt mu im bi translated">不用使用复杂的<code class="fe ow ox oy oz b">if</code>条件来检查一个值是否是真的，你可以简单地<strong class="mb jd">使用变量本身作为条件</strong>。然而，你需要知道真值背后的逻辑。</p><ul class=""><li id="5031" class="ng nh it mb b mc ok mf ol mi pa mm pb mq pc mu nl nm nn no bi translated">将评估为<strong class="mb jd">真值</strong>，如果不是<code class="fe ow ox oy oz b">false</code>、<code class="fe ow ox oy oz b">0</code>、<code class="fe ow ox oy oz b">0n</code>、<code class="fe ow ox oy oz b">""</code>、<code class="fe ow ox oy oz b">null</code>、<code class="fe ow ox oy oz b">undefined</code>和<code class="fe ow ox oy oz b">NaN</code>。</li></ul><h2 id="2482" class="mv li it bd lj mw mx dn ln my mz dp lr mi na nb lt mm nc nd lv mq ne nf lx iz bi translated">以前</h2><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pd pe l"/></div></figure><h2 id="9dc1" class="mv li it bd lj mw mx dn ln my mz dp lr mi na nb lt mm nc nd lv mq ne nf lx iz bi translated">在...之后</h2><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pd pe l"/></div></figure><h1 id="4f97" class="lh li it bd lj lk ll lm ln lo lp lq lr ki ls kj lt kl lu km lv ko lw kp lx ly bi translated">三元运算符</h1><h2 id="1f0a" class="mv li it bd lj mw mx dn ln my mz dp lr mi na nb lt mm nc nd lv mq ne nf lx iz bi translated">停止使用这么多if-else语句</h2><p id="b8c6" class="pw-post-body-paragraph lz ma it mb b mc md kd me mf mg kg mh mi mj mk ml mm mn mo mp mq mr ms mt mu im bi translated"><a class="ae oj" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Conditional_Operator" rel="noopener ugc nofollow" target="_blank">三元运算符</a>经常被用作<strong class="mb jd"> if语句</strong>的快捷方式。简单来说就是<strong class="mb jd">问一个问题</strong>(条件)，如果答案是<strong class="mb jd">是</strong>(真)或<strong class="mb jd">否</strong>(假)，你就执行一些代码。</p><p id="9e49" class="pw-post-body-paragraph lz ma it mb b mc ok kd me mf ol kg mh mi om mk ml mm on mo mp mq oo ms mt mu im bi translated">因此，<strong class="mb jd">语句有三个部分</strong>:要求值的<strong class="mb jd">条件</strong>、真值表达式<strong class="mb jd">和假值表达式</strong>。</p><pre class="ks kt ku kv gt pf oz pg ph aw pi bi"><span id="1bf6" class="mv li it oz b gy pj pk l pl pm">condition ? exprIfTrue : exprIfFalse</span></pre><h2 id="c46b" class="mv li it bd lj mw mx dn ln my mz dp lr mi na nb lt mm nc nd lv mq ne nf lx iz bi translated">以前</h2><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pd pe l"/></div></figure><h2 id="0202" class="mv li it bd lj mw mx dn ln my mz dp lr mi na nb lt mm nc nd lv mq ne nf lx iz bi translated">在...之后</h2><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pd pe l"/></div></figure><h2 id="8d5f" class="mv li it bd lj mw mx dn ln my mz dp lr mi na nb lt mm nc nd lv mq ne nf lx iz bi translated">当三元运算符变得混乱时</h2><p id="599a" class="pw-post-body-paragraph lz ma it mb b mc md kd me mf mg kg mh mi mj mk ml mm mn mo mp mq mr ms mt mu im bi translated">对于单个表达式，建议使用三元运算符<strong class="mb jd">。您可以使用它们来执行基于条件的代码:<code class="fe ow ox oy oz b">condition ? executeThis() : executeOther()</code>或分配给变量<code class="fe ow ox oy oz b">const num = condition ? 3 : 5;</code>。</strong></p><p id="b97d" class="pw-post-body-paragraph lz ma it mb b mc ok kd me mf ol kg mh mi om mk ml mm on mo mp mq oo ms mt mu im bi translated">当<strong class="mb jd">在一个表达式中引入多个三元运算符</strong>时，就会变得<strong class="mb jd">混乱</strong>。比如说…</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pd pe l"/></div></figure><p id="9016" class="pw-post-body-paragraph lz ma it mb b mc ok kd me mf ol kg mh mi om mk ml mm on mo mp mq oo ms mt mu im bi translated">乍看之下，这种逻辑可能并不清晰，但你希望它清晰！为了你<strong class="mb jd">未来的自己</strong>和你<strong class="mb jd">的同行</strong>。</p><p id="bda5" class="pw-post-body-paragraph lz ma it mb b mc ok kd me mf ol kg mh mi om mk ml mm on mo mp mq oo ms mt mu im bi translated">当意图开始变得不清楚时，你应该<strong class="mb jd">将它们</strong>分解成单个语句或者使用<strong class="mb jd"> if-else </strong>语句。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pd pe l"/></div></figure><h2 id="4333" class="mv li it bd lj mw mx dn ln my mz dp lr mi na nb lt mm nc nd lv mq ne nf lx iz bi translated">奖金(省略‘else’)</h2><p id="96a0" class="pw-post-body-paragraph lz ma it mb b mc md kd me mf mg kg mh mi mj mk ml mm mn mo mp mq mr ms mt mu im bi translated">正如你从上面的<strong class="mb jd"> if-else，</strong>你可以在<code class="fe ow ox oy oz b">if</code>语句中省略else if<code class="fe ow ox oy oz b">return</code>。<code class="fe ow ox oy oz b">return</code>将导致函数提前返回，使<code class="fe ow ox oy oz b">else</code>成为多余的(因此，逻辑不需要它来按预期工作)。</p><h1 id="91fb" class="lh li it bd lj lk ll lm ln lo lp lq lr ki ls kj lt kl lu km lv ko lw kp lx ly bi translated">短路评估</h1><h2 id="3551" class="mv li it bd lj mw mx dn ln my mz dp lr mi na nb lt mm nc nd lv mq ne nf lx iz bi translated">(变量赋值真的需要if-else吗)</h2><p id="eddc" class="pw-post-body-paragraph lz ma it mb b mc md kd me mf mg kg mh mi mj mk ml mm mn mo mp mq mr ms mt mu im bi translated"><a class="ae oj" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_Operators" rel="noopener ugc nofollow" target="_blank">短路评估</a>是一个条件，除了<strong class="mb jd">优先级</strong>之外，所使用的<strong class="mb jd">逻辑运算符</strong>决定语句是否应该提前返回值(短路)。它允许你阻止<strong class="mb jd">不必要的代码执行。</strong></p><ul class=""><li id="40ae" class="ng nh it mb b mc ok mf ol mi pa mm pb mq pc mu nl nm nn no bi translated"><code class="fe ow ox oy oz b">(some falsy expression) &amp;&amp; <em class="os">expr</em></code>被短路评估到<strong class="mb jd"> falsy </strong>表达式；</li><li id="f383" class="ng nh it mb b mc np mf nq mi nr mm ns mq nt mu nl nm nn no bi translated"><code class="fe ow ox oy oz b">(some truthy expression) || <em class="os">expr</em></code>被短路评估为<strong class="mb jd">真值</strong>表达式。</li></ul><h2 id="c6ef" class="mv li it bd lj mw mx dn ln my mz dp lr mi na nb lt mm nc nd lv mq ne nf lx iz bi translated">以前</h2><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pd pe l"/></div></figure><h2 id="e8cb" class="mv li it bd lj mw mx dn ln my mz dp lr mi na nb lt mm nc nd lv mq ne nf lx iz bi translated">在...之后</h2><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pd pe l"/></div></figure><h2 id="7342" class="mv li it bd lj mw mx dn ln my mz dp lr mi na nb lt mm nc nd lv mq ne nf lx iz bi translated">额外收获:非布尔值</h2><p id="6152" class="pw-post-body-paragraph lz ma it mb b mc md kd me mf mg kg mh mi mj mk ml mm mn mo mp mq mr ms mt mu im bi translated">短路评估，当与<strong class="mb jd">非布尔值</strong>一起使用时，可以返回非布尔值。</p><ul class=""><li id="8c06" class="ng nh it mb b mc ok mf ol mi pa mm pb mq pc mu nl nm nn no bi translated">&amp;&amp;操作员短路到第一个错误值<strong class="mb jd">值</strong></li><li id="c415" class="ng nh it mb b mc np mf nq mi nr mm ns mq nt mu nl nm nn no bi translated">||操作员短路至第一真值<strong class="mb jd">值</strong></li></ul><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pd pe l"/></div></figure><p id="98d2" class="pw-post-body-paragraph lz ma it mb b mc ok kd me mf ol kg mh mi om mk ml mm on mo mp mq oo ms mt mu im bi translated">然而，要小心引入复杂性。当您引入<strong class="mb jd">多个</strong>逻辑运算符时，您就开始<strong class="mb jd">牺牲短路评估</strong>的好处了。这是滋生<strong class="mb jd">简单得令人恼火的</strong>(但容易被忽略)错误的温床。</p><p id="82fa" class="pw-post-body-paragraph lz ma it mb b mc ok kd me mf ol kg mh mi om mk ml mm on mo mp mq oo ms mt mu im bi translated">这是由于<a class="ae oj" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence" rel="noopener ugc nofollow" target="_blank"> <strong class="mb jd">运算符优先于</strong> </a>。值得注意的是，由于<strong class="mb jd">优先于</strong>，将首先计算<code class="fe ow ox oy oz b">&amp;&amp;</code>，除非<strong class="mb jd">将单独的逻辑运算符条件放在括号</strong>中。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pd pe l"/></div></figure><h1 id="8226" class="lh li it bd lj lk ll lm ln lo lp lq lr ki ls kj lt kl lu km lv ko lw kp lx ly bi translated">箭头功能</h1><p id="3ffd" class="pw-post-body-paragraph lz ma it mb b mc md kd me mf mg kg mh mi mj mk ml mm mn mo mp mq mr ms mt mu im bi translated">一个<a class="ae oj" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_Operators" rel="noopener ugc nofollow" target="_blank"> <strong class="mb jd">箭头函数表达式</strong> </a>是一个常规函数的<strong class="mb jd">语法紧凑替代</strong>。它没有自己与<code class="fe ow ox oy oz b">this</code>、<code class="fe ow ox oy oz b">arguments</code>、<code class="fe ow ox oy oz b">super</code>或<code class="fe ow ox oy oz b">new.target</code>的绑定。</p><p id="8f21" class="pw-post-body-paragraph lz ma it mb b mc ok kd me mf ol kg mh mi om mk ml mm on mo mp mq oo ms mt mu im bi translated">使用箭头函数使得我们的代码<strong class="mb jd">更加简洁</strong>，<strong class="mb jd">简化了</strong>和<code class="fe ow ox oy oz b">this</code>的作用域。</p><h2 id="9c94" class="mv li it bd lj mw mx dn ln my mz dp lr mi na nb lt mm nc nd lv mq ne nf lx iz bi translated">以前</h2><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pd pe l"/></div></figure><h2 id="904c" class="mv li it bd lj mw mx dn ln my mz dp lr mi na nb lt mm nc nd lv mq ne nf lx iz bi translated">在...之后</h2><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pd pe l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">带参数和不带参数的箭头函数的多种用法</figcaption></figure><h1 id="416b" class="lh li it bd lj lk ll lm ln lo lp lq lr ki ls kj lt kl lu km lv ko lw kp lx ly bi translated">环</h1><h2 id="10c8" class="mv li it bd lj mw mx dn ln my mz dp lr mi na nb lt mm nc nd lv mq ne nf lx iz bi translated">使用<code class="fe ow ox oy oz b">forEach</code> <a class="ae oj" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach" rel="noopener ugc nofollow" target="_blank">阵列原型法</a></h2><p id="250f" class="pw-post-body-paragraph lz ma it mb b mc md kd me mf mg kg mh mi mj mk ml mm mn mo mp mq mr ms mt mu im bi translated">它允许你<strong class="mb jd">迭代元素</strong>并一次操作一个。通过<strong class="mb jd">回调</strong>参数提供对每个元素的操作。它看起来更干净，也更容易推断出意图。</p><h2 id="a8d0" class="mv li it bd lj mw mx dn ln my mz dp lr mi na nb lt mm nc nd lv mq ne nf lx iz bi translated">以前</h2><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pd pe l"/></div></figure><h2 id="279a" class="mv li it bd lj mw mx dn ln my mz dp lr mi na nb lt mm nc nd lv mq ne nf lx iz bi translated">在...之后</h2><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pd pe l"/></div></figure><p id="fd87" class="pw-post-body-paragraph lz ma it mb b mc ok kd me mf ol kg mh mi om mk ml mm on mo mp mq oo ms mt mu im bi translated"><strong class="mb jd">然而</strong>的一个缺点是，你<strong class="mb jd">不能提前终止</strong> <code class="fe ow ox oy oz b"><strong class="mb jd">forEach</strong></code> <strong class="mb jd">执行</strong>，就像你可以用常规<code class="fe ow ox oy oz b">for..of</code>语句一样。如果你需要提前终止的可能性，那么这个<strong class="mb jd">不是正确的工具</strong>。</p><blockquote class="op oq or"><p id="a774" class="lz ma os mb b mc ok kd me mf ol kg mh ot om mk ml ou on mo mp ov oo ms mt mu im bi translated">与其他for循环相比，<code class="fe ow ox oy oz b">forEach()</code>的性能可能会有所不同。测试表明<code class="fe ow ox oy oz b"><a class="ae oj" href="https://github.com/dg92/Performance-Analysis-JS" rel="noopener ugc nofollow" target="_blank">forEach</a></code> <a class="ae oj" href="https://github.com/dg92/Performance-Analysis-JS" rel="noopener ugc nofollow" target="_blank">明显比</a>慢，但是对于简单的任务，应该没有真正的性能问题。</p></blockquote><h1 id="e190" class="lh li it bd lj lk ll lm ln lo lp lq lr ki ls kj lt kl lu km lv ko lw kp lx ly bi translated">传播算子</h1><p id="8b50" class="pw-post-body-paragraph lz ma it mb b mc md kd me mf mg kg mh mi mj mk ml mm mn mo mp mq mr ms mt mu im bi translated"><a class="ae oj" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax" rel="noopener ugc nofollow" target="_blank">扩展操作符</a>允许iterable在有<strong class="mb jd">零个或多个参数</strong>的地方扩展，比如<strong class="mb jd">数组</strong>中的元素或者<strong class="mb jd">对象</strong>的键值对。</p><h2 id="3f07" class="mv li it bd lj mw mx dn ln my mz dp lr mi na nb lt mm nc nd lv mq ne nf lx iz bi translated">以前</h2><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pd pe l"/></div></figure><h2 id="6f43" class="mv li it bd lj mw mx dn ln my mz dp lr mi na nb lt mm nc nd lv mq ne nf lx iz bi translated">在...之后</h2><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pd pe l"/></div></figure><h1 id="9777" class="lh li it bd lj lk ll lm ln lo lp lq lr ki ls kj lt kl lu km lv ko lw kp lx ly bi translated">Rest运算符</h1><p id="a53d" class="pw-post-body-paragraph lz ma it mb b mc md kd me mf mg kg mh mi mj mk ml mm mn mo mp mq mr ms mt mu im bi translated"><a class="ae oj" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters" rel="noopener ugc nofollow" target="_blank">rest操作符</a>允许不确定数量的参数，表示为一个数组。</p><h2 id="294e" class="mv li it bd lj mw mx dn ln my mz dp lr mi na nb lt mm nc nd lv mq ne nf lx iz bi translated">以前</h2><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pd pe l"/></div></figure><h2 id="2fe9" class="mv li it bd lj mw mx dn ln my mz dp lr mi na nb lt mm nc nd lv mq ne nf lx iz bi translated">在...之后</h2><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pd pe l"/></div></figure><h1 id="ff64" class="lh li it bd lj lk ll lm ln lo lp lq lr ki ls kj lt kl lu km lv ko lw kp lx ly bi translated">默认对象值(使用扩散)</h1><p id="1f44" class="pw-post-body-paragraph lz ma it mb b mc md kd me mf mg kg mh mi mj mk ml mm mn mo mp mq mr ms mt mu im bi translated">当给对象赋值时，有时你想检查它们是否<strong class="mb jd">真</strong>(已经定义并且不为空等)。</p><p id="2e6f" class="pw-post-body-paragraph lz ma it mb b mc ok kd me mf ol kg mh mi om mk ml mm on mo mp mq oo ms mt mu im bi translated">如果它们是假的，你可能想用T21回到默认值。您可以使用<strong class="mb jd">扩展操作符实现这一点。</strong>第二次扩展具有<strong class="mb jd">覆盖已经定义的对象值</strong>的能力，否则保留<code class="fe ow ox oy oz b">defaultValues</code>。</p><p id="8217" class="pw-post-body-paragraph lz ma it mb b mc ok kd me mf ol kg mh mi om mk ml mm on mo mp mq oo ms mt mu im bi translated">因此，默认值被用作第一个扩展的<strong class="mb jd">，以便第二个扩展<strong class="mb jd">覆盖第一个</strong>。</strong></p><h2 id="b623" class="mv li it bd lj mw mx dn ln my mz dp lr mi na nb lt mm nc nd lv mq ne nf lx iz bi translated">以前</h2><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pd pe l"/></div></figure><h2 id="a51c" class="mv li it bd lj mw mx dn ln my mz dp lr mi na nb lt mm nc nd lv mq ne nf lx iz bi translated">在...之后</h2><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pd pe l"/></div></figure><h1 id="deb1" class="lh li it bd lj lk ll lm ln lo lp lq lr ki ls kj lt kl lu km lv ko lw kp lx ly bi translated">倒计时时</h1><p id="898a" class="pw-post-body-paragraph lz ma it mb b mc md kd me mf mg kg mh mi mj mk ml mm mn mo mp mq mr ms mt mu im bi translated">这只是一个简单的for循环i <strong class="mb jd">的替换，遍历一个iterable的每个索引</strong>。使用具有递减值<code class="fe ow ox oy oz b">val--</code>的<code class="fe ow ox oy oz b">while</code>循环将<strong class="mb jd">倒计数到零</strong>(其本身为假)以结束循环。</p><p id="9988" class="pw-post-body-paragraph lz ma it mb b mc ok kd me mf ol kg mh mi om mk ml mm on mo mp mq oo ms mt mu im bi translated">看起来<strong class="mb jd">更清晰</strong>(对我来说)和<strong class="mb jd">容易理解</strong>你正在迭代的东西乍一看。</p><h2 id="c76d" class="mv li it bd lj mw mx dn ln my mz dp lr mi na nb lt mm nc nd lv mq ne nf lx iz bi translated">以前</h2><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pd pe l"/></div></figure><h2 id="4018" class="mv li it bd lj mw mx dn ln my mz dp lr mi na nb lt mm nc nd lv mq ne nf lx iz bi translated">在...之后</h2><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pd pe l"/></div></figure><blockquote class="nu"><p id="0285" class="nv nw it bd nx ny nz oa ob oc od mu dk translated">在javascript中找到while循环的用法很不错(我不怎么用它们)。</p></blockquote><h1 id="cbeb" class="lh li it bd lj lk ll lm ln lo lp lq lr ki pn kj lt kl po km lv ko pp kp lx ly bi translated">按位非运算符</h1><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pq"><img src="../Images/87d0cb42cab12e008a71d781d079e913.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/1*-Qj0Tj1tJNbeeuIn7gDGcw.jpeg"/></div></figure><h2 id="e53e" class="mv li it bd lj mw mx dn ln my mz dp lr mi na nb lt mm nc nd lv mq ne nf lx iz bi translated">检查值是否在数组中</h2><p id="11f4" class="pw-post-body-paragraph lz ma it mb b mc md kd me mf mg kg mh mi mj mk ml mm mn mo mp mq mr ms mt mu im bi translated"><strong class="mb jd">位非</strong>运算符可与<code class="fe ow ox oy oz b">indexOf</code>语句一起使用，以<strong class="mb jd">检查值是否存在于<code class="fe ow ox oy oz b">Array</code>或<code class="fe ow ox oy oz b">String</code>中的</strong>。</p><p id="ad68" class="pw-post-body-paragraph lz ma it mb b mc ok kd me mf ol kg mh mi om mk ml mm on mo mp mq oo ms mt mu im bi translated">我们通常会检查<code class="fe ow ox oy oz b">indexOf</code>操作的返回值是否大于<code class="fe ow ox oy oz b">-1</code>，如果<code class="fe ow ox oy oz b">indexOf</code>返回<strong class="mb jd"> 0或更高，波形符<code class="fe ow ox oy oz b">~</code>将返回true。</strong></p><blockquote class="nu"><p id="9857" class="nv nw it bd nx ny pr ps pt pu pv mu dk translated">按位非背后的逻辑是<code class="fe ow ox oy oz b">~n == -(n+1)</code>。</p></blockquote><h2 id="8659" class="mv li it bd lj mw oe dn ln my of dp lr mi og nb lt mm oh nd lv mq oi nf lx iz bi translated">以前</h2><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pd pe l"/></div></figure><h2 id="7395" class="mv li it bd lj mw mx dn ln my mz dp lr mi na nb lt mm nc nd lv mq ne nf lx iz bi translated">在...之后</h2><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pd pe l"/></div></figure><p id="5264" class="pw-post-body-paragraph lz ma it mb b mc ok kd me mf ol kg mh mi om mk ml mm on mo mp mq oo ms mt mu im bi translated">这种更简单的语法也可以用<code class="fe ow ox oy oz b">Array.prototype.find</code>和<code class="fe ow ox oy oz b">Array.prototype.includes</code>来实现。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pd pe l"/></div></figure><h1 id="e04a" class="lh li it bd lj lk ll lm ln lo lp lq lr ki ls kj lt kl lu km lv ko lw kp lx ly bi translated">自调用匿名函数(IIFE)</h1><p id="4427" class="pw-post-body-paragraph lz ma it mb b mc md kd me mf mg kg mh mi mj mk ml mm mn mo mp mq mr ms mt mu im bi translated">当存在我们希望在浏览器解析时立即执行<strong class="mb jd">的代码时，和/或如果我们不想让<strong class="mb jd">用<strong class="mb jd">冲突变量</strong> s污染名称空间</strong>时，我们将使用<code class="fe ow ox oy oz b">IIFE</code>(立即调用的函数表达式)。它本质上引入了另一个作用域。</strong></p><p id="69c4" class="pw-post-body-paragraph lz ma it mb b mc ok kd me mf ol kg mh mi om mk ml mm on mo mp mq oo ms mt mu im bi translated">如果您需要在声明一个函数后立即执行它，这是非常有用的。它将<strong class="mb jd">中的声明+执行组合成一个简洁的表达式。</strong></p><h2 id="fe29" class="mv li it bd lj mw mx dn ln my mz dp lr mi na nb lt mm nc nd lv mq ne nf lx iz bi translated">以前</h2><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pd pe l"/></div></figure><h2 id="40ca" class="mv li it bd lj mw mx dn ln my mz dp lr mi na nb lt mm nc nd lv mq ne nf lx iz bi translated">在...之后</h2><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pd pe l"/></div></figure><p id="53ba" class="pw-post-body-paragraph lz ma it mb b mc ok kd me mf ol kg mh mi om mk ml mm on mo mp mq oo ms mt mu im bi translated">您可以使用<strong class="mb jd">任意</strong> <a class="ae oj" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_Operators#Unary" rel="noopener ugc nofollow" target="_blank"> <strong class="mb jd">一元运算符</strong> </a>代替<code class="fe ow ox oy oz b">!</code>自行执行一个函数。</p><blockquote class="nu"><p id="d758" class="nv nw it bd nx ny pr ps pt pu pv mu dk translated"><strong class="ak"> <em class="pw">一元运算符包括+、-、</em> </strong> <strong class="ak"> <em class="pw"> ~ </em> </strong></p></blockquote><figure class="px py pz qa qb kw"><div class="bz fp l di"><div class="pd pe l"/></div></figure><h2 id="4163" class="mv li it bd lj mw mx dn ln my mz dp lr mi na nb lt mm nc nd lv mq ne nf lx iz bi translated">要记住的重要一点</h2><p id="2cb4" class="pw-post-body-paragraph lz ma it mb b mc md kd me mf mg kg mh mi mj mk ml mm mn mo mp mq mr ms mt mu im bi translated">这些简写表达意在使代码<strong class="mb jd">更简单</strong>和<strong class="mb jd">更清晰</strong>。</p><p id="45bd" class="pw-post-body-paragraph lz ma it mb b mc ok kd me mf ol kg mh mi om mk ml mm on mo mp mq oo ms mt mu im bi translated">因此，将多个速记表达式一起使用是反作用于和<strong class="mb jd">初衷</strong>的。</p><h2 id="00e1" class="mv li it bd lj mw mx dn ln my mz dp lr mi na nb lt mm nc nd lv mq ne nf lx iz bi translated">一些其他资源，以进一步你的速记游戏</h2><div class="qc qd gp gr qe qf"><a href="https://www.sitepoint.com/shorthand-javascript-techniques/" rel="noopener  ugc nofollow" target="_blank"><div class="qg ab fo"><div class="qh ab qi cl cj qj"><h2 class="bd jd gy z fp qk fr fs ql fu fw jc bi translated">25+ JavaScript速记编码技术- SitePoint</h2><div class="qm l"><h3 class="bd b gy z fp qk fr fs ql fu fw dk translated">这确实是任何JavaScript开发人员的必读之作。我写了这本速记JavaScript编码指南…</h3></div><div class="qn l"><p class="bd b dl z fp qk fr fs ql fu fw dk translated">www.sitepoint.com</p></div></div><div class="qo l"><div class="qp l qq qr qs qo qt lb qf"/></div></div></a></div><div class="qc qd gp gr qe qf"><a href="http://es6-features.org/#Constants" rel="noopener  ugc nofollow" target="_blank"><div class="qg ab fo"><div class="qh ab qi cl cj qj"><h2 class="bd jd gy z fp qk fr fs ql fu fw jc bi translated">ECMAScript 6:新功能:概述和比较</h2><div class="qm l"><h3 class="bd b gy z fp qk fr fs ql fu fw dk translated">编辑描述</h3></div><div class="qn l"><p class="bd b dl z fp qk fr fs ql fu fw dk translated">es6-features.org</p></div></div></div></a></div><h1 id="73de" class="lh li it bd lj lk ll lm ln lo lp lq lr ki ls kj lt kl lu km lv ko lw kp lx ly bi translated">请随意指出我错过的任何东西。任何问题，我都会尽力帮忙！</h1></div></div>    
</body>
</html>