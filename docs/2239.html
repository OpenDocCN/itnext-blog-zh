<html>
<head>
<title>A Story of Phoenix LiveView: Writing a CRUD Application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Phoenix LiveView的故事:编写CRUD应用程序</h1>
<blockquote>原文：<a href="https://itnext.io/a-story-of-phoenix-liveview-writing-a-crud-application-d938e52894d4?source=collection_archive---------0-----------------------#2019-04-22">https://itnext.io/a-story-of-phoenix-liveview-writing-a-crud-application-d938e52894d4?source=collection_archive---------0-----------------------#2019-04-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="6e4f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Phoenix LiveView是Elixir/Phoenix生态系统中一个令人兴奋的新成员。在本文中，我将概述Phoenix LiveView及其一些显著的特性，然后是一个使用Phoenix Framework 1.4和LiveView开发的CRUD应用程序示例。</p><h1 id="7565" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated"><strong class="ak">什么是凤凰LiveView？</strong></h1><p id="ac61" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">正如文章<a class="ae lo" href="https://dockyard.com/blog/2018/12/12/phoenix-liveview-interactive-real-time-apps-no-need-to-write-javascript" rel="noopener ugc nofollow" target="_blank">中所描述的，这里</a>—“<em class="lp">Phoenix live view是一个令人兴奋的新库，它通过服务器渲染的HTML实现丰富的实时用户体验。LiveView驱动的应用程序在服务器上是有状态的，通过WebSockets进行双向通信，与JavaScript替代方案相比，提供了一个大大简化的编程模型。</em></p><p id="e8d6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你不喜欢Javascript或者不想写太多的Javascript，Phoenix LiveView提供了一个可行的，而且在我看来更好的替代方案，可以用服务器渲染的HTML编写实时应用程序。</p><h1 id="23bd" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">Phoenix LiveView的显著特点:</h1><p id="2e76" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">你可以在Phoenix LiveView上阅读许多文章，感受一下它在互联网上的能力，但总的来说—</p><ul class=""><li id="5ed5" class="lq lr iq jp b jq jr ju jv jy ls kc lt kg lu kk lv lw lx ly bi translated">LiveView提供了更简单的编程模型，用于使用服务器呈现的HTML编写实时交互式web应用程序</li><li id="b776" class="lq lr iq jp b jq lz ju ma jy mb kc mc kg md kk lv lw lx ly bi translated">LiveView连接过程如下—</li></ul><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div class="gh gi me"><img src="../Images/aacaf1fff697c5406224b03dbf6c7c83.png" data-original-src="https://miro.medium.com/v2/resize:fit:748/format:webp/1*XKiMJuCpZwrrG7SR4BM3QQ.png"/></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">来源:<a class="ae lo" href="https://elixirschool.com/blog/phoenix-live-view/" rel="noopener ugc nofollow" target="_blank">https://elixirschool.com/blog/phoenix-live-view/</a></figcaption></figure><p id="50d4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是一个两步连接过程——</p><p id="ad24" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上图中的步骤1、2、3表示无状态连接，其中整个静态和动态HTML内容从服务器发送到浏览器并呈现。</p><p id="8084" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">步骤4，5通过WebSocket建立一个有状态连接，然后只为动态改变的内容发送更新。<strong class="jp ir">live eex</strong>(joséValim)用于计算已更改的零件，仅将最少量的更新零件发送至浏览器。</p><p id="a366" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你想更多地了解这在内部是如何发生的，请查看这里的<a class="ae lo" href="https://dockyard.com/blog/2018/12/12/phoenix-liveview-interactive-real-time-apps-no-need-to-write-javascript" rel="noopener ugc nofollow" target="_blank">和这里的</a>和<a class="ae lo" href="https://www.youtube.com/watch?feature=youtu.be&amp;v=8xJzHq8ru0M&amp;app=desktop" rel="noopener ugc nofollow" target="_blank">以获取详细信息。</a></p><ul class=""><li id="4ed4" class="lq lr iq jp b jq jr ju jv jy ls kc lt kg lu kk lv lw lx ly bi translated">然而，客户端应用程序不会像本文<a class="ae lo" href="https://dockyard.com/blog/2018/12/12/phoenix-liveview-interactive-real-time-apps-no-need-to-write-javascript" rel="noopener ugc nofollow" target="_blank">中提到的那样消失，特别是当你需要离线能力的时候。</a></li></ul><h1 id="47c8" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">使用LiveView开发CRUD应用程序:</h1><p id="bc6b" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">在本节中，我将介绍一个使用LiveView开发的CRUD应用程序示例。示例应用程序摘自Phoenix LiveView示例存储库，这里是<a class="ae lo" href="https://github.com/chrismccord/phoenix_live_view_example" rel="noopener ugc nofollow" target="_blank">https://github.com/chrismccord/phoenix_live_view_example</a>，但是为了适合本文，对其进行了简化和调整。您可以在上面的github资源库中找到许多其他使用LiveView的示例。</p><p id="c0b9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="lp">完整的应用代码可以在我的github这里找到—</em></strong><a class="ae lo" href="https://github.com/imeraj/Phoenix_Playground/tree/master/1.4/user_liveview" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir"><em class="lp">https://github . com/imeraj/Phoenix _ Playground/tree/master/1.4/user _ live view</em></strong></a></p><h2 id="c317" class="mq km iq bd kn mr ms dn kr mt mu dp kv jy mv mw kz kc mx my ld kg mz na lh nb bi translated">应用概述:</h2><p id="92b2" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">该应用程序是一个简单的CRUD应用程序，具有一个<strong class="jp ir">用户</strong>模式、一些模式验证，以及一些操作——添加新用户、列出用户、显示用户、更新用户和删除用户。我添加了必要的代码来使用LiveView执行实时验证。</p><h2 id="5363" class="mq km iq bd kn mr ms dn kr mt mu dp kv jy mv mw kz kc mx my ld kg mz na lh nb bi translated"><strong class="ak">第一步</strong>:生成Phoenix应用</h2><p id="8175" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">使用下面的命令用mysql数据库生成一个Phoenix应用程序—</p><blockquote class="nc nd ne"><p id="ce0e" class="jn jo lp jp b jq jr js jt ju jv jw jx nf jz ka kb ng kd ke kf nh kh ki kj kk ij bi translated">mix phx.new user_liveview —数据库mysql</p></blockquote><h2 id="599d" class="mq km iq bd kn mr ms dn kr mt mu dp kv jy mv mw kz kc mx my ld kg mz na lh nb bi translated"><strong class="ak">步骤2:定义模式并添加验证</strong></h2><p id="d137" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">使用下面的命令定义一个用户模式</p><blockquote class="nc nd ne"><p id="e61f" class="jn jo lp jp b jq jr js jt ju jv jw jx nf jz ka kb ng kd ke kf nh kh ki kj kk ij bi translated">混合phx.gen.html帐户用户用户名:字符串电子邮件:字符串电话号码:字符串</p></blockquote><p id="c0d2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">带有验证的生成的<strong class="jp ir">用户</strong>模式如下所示—</p><pre class="mf mg mh mi gt ni nj nk nl aw nm bi"><span id="bcc2" class="mq km iq nj b gy nn no l np nq">defmodule UserLiveview.Accounts.User do<br/>  use Ecto.Schema<br/>  import Ecto.Changeset<br/><br/>  schema "users" do<br/>    field :email, :string<br/>    field :name, :string<br/>    field :phone_number, :string<br/><br/>    timestamps()<br/>  end<br/><br/>  @phone ~r/^(\+\d{1,2}\s)?\(?\d{3}\)?[\s.-]\d{3}[\s.-]\d{4}$/<br/>  @email ~r/\A[\w+\-.]+@[a-z\d\-.]+\.[a-z]+\z/i<br/><br/>  @doc false<br/>  def changeset(user, attrs) do<br/>    user<br/>    |&gt; cast(attrs, [:name, :email, :phone_number])<br/>    |&gt; validate_required([:name, :email, :phone_number])<br/>    |&gt; validate_format(:name, ~r/^[a-zA-Z0-9_]*$/,<br/>      message: "only letters, numbers, and underscores please"<br/>    )<br/>    |&gt; validate_length(:name, max: 12)<br/>    |&gt; validate_format(:email, @email, message: "must be a valid email address")<br/>    |&gt; validate_format(:phone_number, @phone, message: "must be a valid number")<br/>    |&gt; unique_constraint(:email)<br/>  end<br/>end</span></pre><h2 id="008b" class="mq km iq bd kn mr ms dn kr mt mu dp kv jy mv mw kz kc mx my ld kg mz na lh nb bi translated">第三步:集成Phoenix LiveView</h2><ul class=""><li id="7e8c" class="lq lr iq jp b jq lj ju lk jy nr kc ns kg nt kk lv lw lx ly bi translated">在<strong class="jp ir"> mix.exs </strong>中:在依赖关系下添加—</li></ul><p id="4829" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">{:phoenix_live_view，github:" phoenix framework/phoenix _ live _ view " }</p><ul class=""><li id="930b" class="lq lr iq jp b jq jr ju jv jy ls kc lt kg lu kk lv lw lx ly bi translated">在<strong class="jp ir"> config.exs </strong>中；添加以下签名盐—</li></ul><pre class="mf mg mh mi gt ni nj nk nl aw nm bi"><span id="bd48" class="mq km iq nj b gy nn no l np nq"># Configures the endpoint<br/>config :user_liveview, UserLiveviewWeb.Endpoint,<br/>  url: [host: "localhost"],<br/>  secret_key_base: "jUaYyObybTnU5twQ7xzNA2+cFLkHyNY/I+FMe7wqh8sguXdKryceqWXT+zTrm4yI",<br/>  render_errors: [view: UserLiveviewWeb.ErrorView, accepts: ~w(html json)],<br/>  pubsub: [name: UserLiveview.PubSub, adapter: Phoenix.PubSub.PG2],<br/>  <strong class="nj ir">live_view: [<br/>    signing_salt: "KK4ly8HdzOmhsB+2itWau5xYDIPW8ctk"<br/>  ]</strong></span></pre><ul class=""><li id="b043" class="lq lr iq jp b jq jr ju jv jy ls kc lt kg lu kk lv lw lx ly bi translated">在<strong class="jp ir"> router.ex </strong>中:在:fetch_flash后添加LiveView flash插件—</li></ul><pre class="mf mg mh mi gt ni nj nk nl aw nm bi"><span id="8c89" class="mq km iq nj b gy nn no l np nq">pipeline :browser do<br/>    plug :accepts, ["html"]<br/>    plug :fetch_session<br/>    plug :fetch_flash<br/>    <strong class="nj ir">plug Phoenix.LiveView.Flash</strong><br/>    plug :protect_from_forgery<br/>    plug :put_secure_browser_headers<br/>  end</span></pre><ul class=""><li id="a63a" class="lq lr iq jp b jq jr ju jv jy ls kc lt kg lu kk lv lw lx ly bi translated">在<strong class="jp ir"> user_liveview_web.ex: </strong>下面添加导入—</li></ul><pre class="mf mg mh mi gt ni nj nk nl aw nm bi"><span id="269a" class="mq km iq nj b gy nn no l np nq">def view do<br/>    quote do<br/>      use Phoenix.View,<br/>        root: "lib/user_liveview_web/templates",<br/>        namespace: UserLiveviewWeb<br/><br/>      # Import convenience functions from controllers<br/>      import Phoenix.Controller, only: [get_flash: 1, get_flash: 2, view_module: 1]<br/><br/>      <strong class="nj ir">import Phoenix.LiveView, only: [live_render: 2, live_render: 3]</strong><br/><br/>      # Use all HTML functionality (forms, tags, etc)<br/>      use Phoenix.HTML<br/><br/>      import UserLiveviewWeb.ErrorHelpers<br/>      import UserLiveviewWeb.Gettext<br/>      alias UserLiveviewWeb.Router.Helpers, as: Routes<br/>    end<br/>  end<br/><br/>  def router do<br/>    quote do<br/>      use Phoenix.Router<br/>      import Plug.Conn<br/>      import Phoenix.Controller<br/><br/>      <strong class="nj ir">import Phoenix.LiveView.Router</strong><br/>    end<br/>  end</span></pre><ul class=""><li id="42c0" class="lq lr iq jp b jq jr ju jv jy ls kc lt kg lu kk lv lw lx ly bi translated">在<strong class="jp ir"> endpoint.ex </strong>中:添加LiveView socket信息—</li></ul><pre class="mf mg mh mi gt ni nj nk nl aw nm bi"><span id="55f7" class="mq km iq nj b gy nn no l np nq">defmodule UserLiveviewWeb.Endpoint do<br/>  use Phoenix.Endpoint, otp_app: :user_liveview<br/><br/>  <strong class="nj ir">socket "/live", Phoenix.LiveView.Socket</strong><br/><br/>  ...<br/>end</span></pre><ul class=""><li id="1a9e" class="lq lr iq jp b jq jr ju jv jy ls kc lt kg lu kk lv lw lx ly bi translated">在<strong class="jp ir"> package.json </strong>中:添加LiveView NPM依赖项—</li></ul><pre class="mf mg mh mi gt ni nj nk nl aw nm bi"><span id="f6ce" class="mq km iq nj b gy nn no l np nq">"dependencies": {<br/>    "phoenix": "file:../deps/phoenix",<br/>    "phoenix_html": "file:../deps/phoenix_html",<br/>   <strong class="nj ir"> "phoenix_live_view": "file:../deps/phoenix_live_view"</strong><br/>  },</span></pre><p id="384f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">用于安装NPM依赖项— <strong class="jp ir"> cd资产&amp; &amp; npm安装</strong></p><ul class=""><li id="8ce6" class="lq lr iq jp b jq jr ju jv jy ls kc lt kg lu kk lv lw lx ly bi translated">在<strong class="jp ir"> app.js </strong>中:增加LiveView socket的连接能力—</li></ul><pre class="mf mg mh mi gt ni nj nk nl aw nm bi"><span id="522d" class="mq km iq nj b gy nn no l np nq">import LiveSocket from "phoenix_live_view"<br/><br/>let liveSocket = new LiveSocket("/live")<br/>liveSocket.connect()</span></pre><ul class=""><li id="2a2d" class="lq lr iq jp b jq jr ju jv jy ls kc lt kg lu kk lv lw lx ly bi translated">在<strong class="jp ir"> dev.exs </strong>中:添加动态页面重新加载支持—</li></ul><pre class="mf mg mh mi gt ni nj nk nl aw nm bi"><span id="78c1" class="mq km iq nj b gy nn no l np nq">config :user_liveview, UserLiveviewWeb.Endpoint,<br/>  live_reload: [<br/>    patterns: [<br/>      ~r{priv/static/.*(js|css|png|jpeg|jpg|gif|svg)$},<br/>      ~r{priv/gettext/.*(po)$},<br/>      ~r{lib/user_liveview_web/views/.*(ex)$},<br/>      ~r{lib/user_liveview_web/templates/.*(eex)$},<br/>     <strong class="nj ir"> ~r{lib/user_liveview_web/live/.*(ex)$}</strong><br/>    ]<br/>  ]</span></pre><ul class=""><li id="e3a2" class="lq lr iq jp b jq jr ju jv jy ls kc lt kg lu kk lv lw lx ly bi translated">在<strong class="jp ir"> app.css </strong>中:添加(可选)LiveView CSS —</li></ul><pre class="mf mg mh mi gt ni nj nk nl aw nm bi"><span id="ad2f" class="mq km iq nj b gy nn no l np nq">@import "../../deps/phoenix_live_view/assets/css/live_view.css";</span></pre><p id="62d7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这个阶段，LiveView与应用程序的集成已经完成。</p><p id="426d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">LiveView代码将驻留在—<strong class="jp ir">lib/user _ live view _ web/live</strong>文件夹下。因为它不存在，所以需要创建它。</p><h2 id="6655" class="mq km iq bd kn mr ms dn kr mt mu dp kv jy mv mw kz kc mx my ld kg mz na lh nb bi translated"><strong class="ak">第四步:添加LiveView路线</strong></h2><p id="ff60" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">修改<strong class="jp ir"> router.ex </strong>并指定路线如下—</p><pre class="mf mg mh mi gt ni nj nk nl aw nm bi"><span id="609d" class="mq km iq nj b gy nn no l np nq">scope "/", UserLiveviewWeb do<br/>    pipe_through :browser<br/><br/>    <strong class="nj ir">live "/", UserLive.Index<br/>    live "/users", UserLive.Index<br/>    live "/users/new", UserLive.New<br/>    live "/users/:id", UserLive.Show<br/>    live "/users/:id/edit", UserLive.Edit</strong><br/>  end</span></pre><h2 id="fb29" class="mq km iq bd kn mr ms dn kr mt mu dp kv jy mv mw kz kc mx my ld kg mz na lh nb bi translated">步骤5:添加必要的LiveView代码</h2><p id="62fc" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">在<strong class="jp ir"> live/user </strong>目录下，添加edit.ex、index.ex、new.ex和show . ex(<a class="ae lo" href="https://github.com/imeraj/Phoenix_Playground/tree/master/1.4/user_liveview/lib/user_liveview_web/live/user" rel="noopener ugc nofollow" target="_blank">https://github . com/imeraj/Phoenix _ Playground/tree/master/1.4/user _ live view/lib/user _ live view _ web/live/user</a></p><p id="28d5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<strong class="jp ir">模板/用户</strong>目录下，添加必要的LiveView模板(带扩展名。leex) — edit.html.leex，form.html.leex，index.html.leex，new.html.leex，show . html . leex(<a class="ae lo" href="https://github.com/imeraj/Phoenix_Playground/tree/master/1.4/user_liveview/lib/user_liveview_web/templates/user" rel="noopener ugc nofollow" target="_blank">https://github . com/imeraj/Phoenix _ Playground/tree/master/1.4/user _ live view/lib/user _ live view _ web/templates/user</a>)</p><p id="9d92" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">更新<strong class="jp ir"> user_view.ex </strong>如下—</p><pre class="mf mg mh mi gt ni nj nk nl aw nm bi"><span id="eaf8" class="mq km iq nj b gy nn no l np nq">defmodule UserLiveviewWeb.UserView do<br/>  use UserLiveviewWeb, :view<br/><br/>  <strong class="nj ir">alias UserLiveviewWeb.UserLive</strong><br/>end</span></pre><p id="f7a8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在此阶段，使用以下命令运行应用程序—</p><ul class=""><li id="2943" class="lq lr iq jp b jq jr ju jv jy ls kc lt kg lu kk lv lw lx ly bi translated">混合deps.get</li><li id="2c49" class="lq lr iq jp b jq lz ju ma jy mb kc mc kg md kk lv lw lx ly bi translated">混合环境设置</li><li id="753b" class="lq lr iq jp b jq lz ju ma jy mb kc mc kg md kk lv lw lx ly bi translated">mix phx.server</li></ul><p id="77f0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">启动您的浏览器，点击localhost:4000，您应该会看到下面的屏幕。如果您打开了浏览器的WebInspector，您应该会看到一个加入事件(到LiveView WebSocket ),如下图右侧所示</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="nv nw di nx bf ny"><div class="gh gi nu"><img src="../Images/c220ca4907694d38ee0f32b4caded1f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZpcvAWn8ElYdgUHGvwmofg.png"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">应用程序主页</figcaption></figure><h2 id="57c6" class="mq km iq bd kn mr ms dn kr mt mu dp kv jy mv mw kz kc mx my ld kg mz na lh nb bi translated">应用程序流和代码演练</h2><p id="310b" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">在这一节中，我将解释应用程序流和代码演练。我将只解释带有验证部分代码的新用户创建。在这个解释之后，剩下的代码应该很容易理解。</p><p id="5f74" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们创建新用户的途径是—</p><blockquote class="nc nd ne"><p id="bdaf" class="jn jo lp jp b jq jr js jt ju jv jw jx nf jz ka kb ng kd ke kf nh kh ki kj kk ij bi translated">live "/用户/新建"，UserLive。新的</p></blockquote><p id="2e2c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦我们在主页上点击“<strong class="jp ir">新用户</strong>”或输入路由—<strong class="jp ir">localhost:4000/users/New</strong>，我们应该会看到下面的屏幕—</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="nv nw di nx bf ny"><div class="gh gi nz"><img src="../Images/f2df968859fa49d3dd9b46c9cb9dd0f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HBaiKfbKjywTqVR9gad80w.png"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">新用户创建屏幕</figcaption></figure><p id="5156" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里发生的是—</p><ul class=""><li id="0810" class="lq lr iq jp b jq jr ju jv jy ls kc lt kg lu kk lv lw lx ly bi translated"><strong class="jp ir"> mount </strong>函数后跟<strong class="jp ir"> new.ex </strong>中的<strong class="jp ir"> render </strong>被调用——</li></ul><pre class="mf mg mh mi gt ni nj nk nl aw nm bi"><span id="f666" class="mq km iq nj b gy nn no l np nq">defmodule UserLiveviewWeb.UserLive.New do<br/>  use Phoenix.LiveView<br/><br/>  alias UserLiveviewWeb.UserLive<br/>  alias UserLiveviewWeb.UserView<br/>  alias UserLiveviewWeb.Router.Helpers, as: Routes<br/>  alias UserLiveview.Accounts<br/>  alias UserLiveview.Accounts.User<br/><br/>  <strong class="nj ir">def mount(_session, socket) do</strong><br/>    {:ok,<br/>     assign(socket, %{<br/>       changeset: Accounts.change_user(%User{})<br/>     })}<br/>  end<br/><br/>  <strong class="nj ir">def render(assigns), do: UserView.render("new.html", assigns)<br/></strong><br/>  def handle_event("validate", %{"user" =&gt; params}, socket) do<br/>    changeset =<br/>      %User{}<br/>      |&gt; Accounts.change_user(params)<br/>      |&gt; Map.put(:action, :insert)<br/><br/>    {:noreply, assign(socket, changeset: changeset)}<br/>  end<br/><br/>  def handle_event("save", %{"user" =&gt; user_params}, socket) do<br/>    case Accounts.create_user(user_params) do<br/>      {:ok, user} -&gt;<br/>        {:stop,<br/>         socket<br/>         |&gt; put_flash(:info, "User created successfully.")<br/>         |&gt; redirect(to: Routes.live_path(socket, UserLive.Show, user))}<br/><br/>      {:error, %Ecto.Changeset{} = changeset} -&gt;<br/>        {:noreply, assign(socket, changeset: changeset)}<br/>    end<br/>  end<br/>end</span></pre><p id="410b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">渲染</strong>函数渲染模板<strong class="jp ir">new.html</strong>，本质上是渲染<strong class="jp ir">form.html</strong>—</p><pre class="mf mg mh mi gt ni nj nk nl aw nm bi"><span id="e652" class="mq km iq nj b gy nn no l np nq">&lt;%= f = form_for @changeset, "#", [phx_change: :validate, phx_submit: :save] %&gt;<br/>  &lt;%= label f, :name %&gt;<br/>  &lt;%= text_input f, :name %&gt;<br/>  &lt;%= error_tag f, :name %&gt;<br/><br/>  &lt;%= label f, :email %&gt;<br/>  &lt;%= text_input f, :email %&gt;<br/>  &lt;%= error_tag f, :email %&gt;<br/><br/>  &lt;%= label f, :phone_number %&gt;<br/>  &lt;%= text_input f, :phone_number %&gt;<br/>  &lt;%= error_tag f, :phone_number %&gt;<br/><br/>  &lt;div&gt;<br/>    &lt;%= submit "Save", phx_disable_with: "Saving..." %&gt;<br/>  &lt;/div&gt;<br/>&lt;/form&gt;</span></pre><p id="0554" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个表单生成两个事件——</p><ol class=""><li id="31bd" class="lq lr iq jp b jq jr ju jv jy ls kc lt kg lu kk oa lw lx ly bi translated">:<strong class="jp ir">验证</strong> —由于<strong class="jp ir"> phx_change </strong>无论何时检测到任何字段中的任何变化</li><li id="6e4c" class="lq lr iq jp b jq lz ju ma jy mb kc mc kg md kk oa lw lx ly bi translated">:<strong class="jp ir">保存</strong> —由于点击“保存”按钮时<strong class="jp ir"> phx_submit </strong></li></ol><p id="f471" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每个事件都会导致对<strong class="jp ir"> new.ex </strong>中<strong class="jp ir"> handle_event </strong>的相应调用</p><pre class="mf mg mh mi gt ni nj nk nl aw nm bi"><span id="0642" class="mq km iq nj b gy nn no l np nq">def handle_event("<strong class="nj ir">validate</strong>", %{"user" =&gt; params}, socket) do<br/>    changeset =<br/>      %User{}<br/>      |&gt; Accounts.change_user(params)<br/>      |&gt; Map.put(:action, :insert)<br/><br/>    {:noreply, assign(socket, changeset: changeset)}<br/>  end<br/><br/>  def handle_event("<strong class="nj ir">save</strong>", %{"user" =&gt; user_params}, socket) do<br/>    case Accounts.create_user(user_params) do<br/>      {:ok, user} -&gt;<br/>        {:stop,<br/>         socket<br/>         |&gt; put_flash(:info, "User created successfully.")<br/>         |&gt; redirect(to: Routes.live_path(socket, UserLive.Show, user))}<br/><br/>      {:error, %Ecto.Changeset{} = changeset} -&gt;<br/>        {:noreply, assign(socket, changeset: changeset)}<br/>    end<br/>  end<br/>end</span></pre><p id="5d06" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为我们输入的每个字符都会导致一个服务器端的<strong class="jp ir">验证</strong>事件，如果任何验证失败，我们可以通过<strong class="jp ir">变更集</strong>在UI中立即得到错误消息。</p><p id="276c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我们在所有验证通过后点击<strong class="jp ir">保存</strong>按钮，相应的用户被创建并保存在DB中。</p><p id="4ac0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一些验证失败的截图—</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="nv nw di nx bf ny"><div class="gh gi nz"><img src="../Images/84c00e7b15e3a71cc99c4cabb59898df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4trvd-HwVIRixB4QdFqWKA.png"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">名称验证失败</figcaption></figure><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="nv nw di nx bf ny"><div class="gh gi ob"><img src="../Images/4d746344c95a2ea626f4f6ab9dcd24f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v4AkgWi_6AfUR9-8BM_Jrg.png"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">电子邮件验证失败</figcaption></figure><p id="0213" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果所有验证都通过，点击“保存”按钮后，应出现以下屏幕—</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="nv nw di nx bf ny"><div class="gh gi oc"><img src="../Images/8950b8c4cee1f93eab569fedde92dd87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*82lye_l2SOguxPYIPp00Vw.png"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">验证通过，用户已创建</figcaption></figure><p id="cb96" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于其余的路线，流程基本相同，在这一点上应该是可以理解的。如果你遇到新的LiveView相关函数/符号，这些文档可能会派上用场——<a class="ae lo" href="https://github.com/phoenixframework/phoenix_live_view/blob/master/lib/phoenix_live_view.ex" rel="noopener ugc nofollow" target="_blank">https://github . com/phoenix framework/phoenix _ live _ view/blob/master/lib/phoenix _ live _ view . ex</a>，<a class="ae lo" href="https://github.com/phoenixframework/phoenix_live_view/blob/master/assets/js/phoenix_live_view.js" rel="noopener ugc nofollow" target="_blank">https://github . com/phoenix framework/phoenix _ live _ view/blob/master/assets/js/phoenix _ live _ view . js</a></p><p id="41b3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我希望这篇文章为感兴趣的读者澄清了Phoenix LiveView，并为一些读者提供了一个起点。希望这将鼓励更多的开发者关注Phoenix LiveView，并提出有趣的用例。</p><h1 id="7cae" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">参考资料:</h1><ol class=""><li id="c8d6" class="lq lr iq jp b jq lj ju lk jy nr kc ns kg nt kk oa lw lx ly bi translated"><a class="ae lo" href="https://dockyard.com/blog/2018/12/12/phoenix-liveview-interactive-real-time-apps-no-need-to-write-javascript" rel="noopener ugc nofollow" target="_blank">https://dock yard . com/blog/2018/12/12/phoenix-live view-interactive-real-time-apps-no-need-to-write-JavaScript</a></li><li id="213a" class="lq lr iq jp b jq lz ju ma jy mb kc mc kg md kk oa lw lx ly bi translated"><a class="ae lo" href="https://www.youtube.com/watch?feature=youtu.be&amp;v=8xJzHq8ru0M&amp;app=desktop" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?feature=youtu.be&amp;v = 8 xjzhq 8 ru 0m&amp;app =桌面</a></li><li id="a759" class="lq lr iq jp b jq lz ju ma jy mb kc mc kg md kk oa lw lx ly bi translated"><a class="ae lo" href="https://elixirschool.com/blog/phoenix-live-view/" rel="noopener ugc nofollow" target="_blank">https://elixirschool.com/blog/phoenix-live-view/</a></li></ol><p id="f83b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="lp">如需更多详细和深入的未来技术帖子，请关注我这里或上</em><a class="ae lo" href="https://twitter.com/meraj_enigma" rel="noopener ugc nofollow" target="_blank"><em class="lp">Twitter</em></a><em class="lp">。</em></p></div></div>    
</body>
</html>