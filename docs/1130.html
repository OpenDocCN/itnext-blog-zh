<html>
<head>
<title>Setting up “push to deploy” Kubernetes workflow with Github and Keel</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Github和Keel设置“推送部署”Kubernetes工作流</h1>
<blockquote>原文：<a href="https://itnext.io/setting-up-push-to-deploy-kubernetes-workflow-with-github-and-keel-43173d996587?source=collection_archive---------3-----------------------#2018-07-26">https://itnext.io/setting-up-push-to-deploy-kubernetes-workflow-with-github-and-keel-43173d996587?source=collection_archive---------3-----------------------#2018-07-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="faf8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本教程中，我们将配置几个工具来实现Git推送上的Kubernetes自动更新。这个工作流程在为Kubernetes开发应用程序时非常有用。对于产品，我建议使用标记方法，标记发布将触发映像构建，而Keel更新策略将增加版本。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/4769d94238b197272f6f27c583e9c6c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*BZj4M6pvdfDuDF3k.png"/></div></div></figure><p id="c64e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦工作流准备就绪，主分支的任何推送(或来自开发/功能分支的合并请求)都将更新您在Kubernetes中运行的应用程序。</p><p id="001d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本教程中，我们将使用:</p><ul class=""><li id="76e9" class="kx ky iq jp b jq jr ju jv jy kz kc la kg lb kk lc ld le lf bi translated"><a class="ae lg" href="https://github.com/kubernetes/minikube#what-is-minikube" rel="noopener ugc nofollow" target="_blank"> Minikube </a> —我们在当地开发Kubernetes环境。Mac用户可以在Kubernetes的支持下免费使用Docker for Mac，效果很好！</li><li id="9cf6" class="kx ky iq jp b jq lh ju li jy lj kc lk kg ll kk lc ld le lf bi translated">GitHub——我们将在这里存储我们的代码</li><li id="e025" class="kx ky iq jp b jq lh ju li jy lj kc lk kg ll kk lc ld le lf bi translated">Docker hub——我们的Docker图像将在这里构建和存储</li><li id="c0e0" class="kx ky iq jp b jq lh ju li jy lj kc lk kg ll kk lc ld le lf bi translated">Webhook中继——将公共web hook中继到我们内部的Kubernetes环境，这样我们就不必将Keel暴露给公共互联网</li></ul></div><div class="ab cl lm ln hu lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="ij ik il im in"><h1 id="4933" class="lt lu iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">TL；速度三角形定位法(dead reckoning)</h1><ol class=""><li id="7bf7" class="kx ky iq jp b jq mr ju ms jy mt kc mu kg mv kk mw ld le lf bi translated">按下GitHub开始在DockerHub中自动构建</li><li id="6a59" class="kx ky iq jp b jq lh ju li jy lj kc lk kg ll kk mw ld le lf bi translated">当DockerHub完成构建时，通过webhook中继向Keel发送一个Webhook</li><li id="5a92" class="kx ky iq jp b jq lh ju li jy lj kc lk kg ll kk mw ld le lf bi translated">Keel会找到使用该映像的任何受影响的工作负载，并更新它们。</li></ol><p id="ce76" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">优点:</p><ul class=""><li id="a1d9" class="kx ky iq jp b jq jr ju jv jy kz kc la kg lb kk lc ld le lf bi translated">易于设置，尽管这个指南看起来很长，但它只是一个虚拟应用程序的许多截图和代码片段。</li><li id="71e3" class="kx ky iq jp b jq lh ju li jy lj kc lk kg ll kk lc ld le lf bi translated">没有对任何云提供商工具的锁定(我使用Google Cloud builder而不是DockerHub自动构建，因为它更快)</li><li id="b034" class="kx ky iq jp b jq lh ju li jy lj kc lk kg ll kk lc ld le lf bi translated">轻量级基础设施——不需要运行像Spinnaker这样会让你的钱包化为灰烬的东西，Keel使用大约12-20MB的RAM，几乎没有CPU。</li><li id="c524" class="kx ky iq jp b jq lh ju li jy lj kc lk kg ll kk lc ld le lf bi translated">一旦成立，将为您服务多年。我已经使用这个设置一年多了，通过它发布了大约250个版本，从来没有让你失望过。</li></ul></div><div class="ab cl lm ln hu lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="ij ik il im in"><h1 id="a699" class="lt lu iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">设置GitHub存储库</h1><p id="fed0" class="pw-post-body-paragraph jn jo iq jp b jq mr js jt ju ms jw jx jy mx ka kb kc my ke kf kg mz ki kj kk ij bi translated">首先，让我们建立我们的版本控制系统。让我们为我们的示例应用程序创建一个本地repo，并将其推送到我们的GitHub存储库。</p><p id="5714" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的示例应用非常非常简单:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="2938" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">提交您的代码并推送到远程:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/5668556081f55c668668f64a415c72f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:930/format:webp/0*R8Czpcre8L0omsgC.png"/></div></figure></div><div class="ab cl lm ln hu lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="ij ik il im in"><h1 id="78f5" class="lt lu iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">配置Webhook中继转发</h1><p id="ae74" class="pw-post-body-paragraph jn jo iq jp b jq mr js jt ju ms jw jx jy mx ka kb kc my ke kf kg mz ki kj kk ij bi translated">在这一步中，我们将配置Webhook中继来转发我们内部Kubernetes环境的DockerHub webhooks。这在本地Kubernetes集群上开发时特别有用，因为从公共服务接收webhooks可能稍微复杂一些。</p><p id="5c1f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们准备配置:</p><pre class="km kn ko kp gt nd ne nf ng aw nh bi"><span id="94db" class="ni lu iq ne b gy nj nk l nl nm">$ relay forward -b dockerhub — no-agent <a class="ae lg" href="http://localhost:9300" rel="noopener ugc nofollow" target="_blank">http://localhost:9300</a><br/>Forwarding configuration created: <br/>https://my.webhookrelay.com/v1/webhooks/b968afa1-b737-4385-bc0f-473dbc2007b4 -&gt; <a class="ae lg" href="http://localhost:9300" rel="noopener ugc nofollow" target="_blank">http://localhost:9300</a><br/>In order to start receiving webhooks — start an agent: ‘relay forward’</span></pre><p id="801f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在下一步配置DockerHub webhooks时，我们将需要这个长URL。</p></div><div class="ab cl lm ln hu lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="ij ik il im in"><h1 id="ec96" class="lt lu iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">配置DockerHub(代码库+ webhook)</h1><p id="46fb" class="pw-post-body-paragraph jn jo iq jp b jq mr js jt ju ms jw jx jy mx ka kb kc my ke kf kg mz ki kj kk ij bi translated">现在，我们需要告诉DockerHub在每次GitHub推送到主分支时构建一个新的映像。首先，转到<a class="ae lg" href="https://cloud.docker.com/" rel="noopener ugc nofollow" target="_blank">https://cloud.docker.com</a>，然后转到<code class="fe nn no np ne b">Repositories</code>并点击<code class="fe nn no np ne b">Create</code>按钮。一旦你创建了资源库，将它链接到你的GitHub账户，然后点击<code class="fe nn no np ne b">Configure Automated Builds</code>:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nq"><img src="../Images/6b7fb589656a50e5805f83283496e26b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*fi8F7Mf8PxxZk_qT.png"/></div></div></figure><p id="71c6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">选择您的GitHub存储库并创建一个触发器，它将:</p><ul class=""><li id="8579" class="kx ky iq jp b jq jr ju jv jy kz kc la kg lb kk lc ld le lf bi translated">对<code class="fe nn no np ne b">master</code>分支上的变化做出反应</li><li id="484f" class="kx ky iq jp b jq lh ju li jy lj kc lk kg ll kk lc ld le lf bi translated">将图像标记为<code class="fe nn no np ne b">latest</code></li></ul><p id="9a3a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">确保<code class="fe nn no np ne b">autobuild</code>已打开，并点击“保存并构建”。你将准备好你的第一张照片。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nr"><img src="../Images/2f3a8d87f9f4c056f95da36b954229bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*mo6cEf0SDcjZiV4U.png"/></div></div></figure><p id="13ed" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，我们将需要通过Webhook中继设置DockerHub webhooks到Keel。出于某种原因，这种配置在https://cloud.docker.com的<a class="ae lg" href="https://cloud.docker.com/" rel="noopener ugc nofollow" target="_blank">上不可用，我们必须去https://hub.docker.com的</a><a class="ae lg" href="https://hub.docker.com/" rel="noopener ugc nofollow" target="_blank"/>:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ns"><img src="../Images/775467c998e7776ad7b93d4b85e4a1ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*wdRejbhbtpEFgx_M.png"/></div></div></figure><h1 id="4f9f" class="lt lu iq bd lv lw nt ly lz ma nu mc md me nv mg mh mi nw mk ml mm nx mo mp mq bi translated">部署Keel和你的应用</h1><p id="7281" class="pw-post-body-paragraph jn jo iq jp b jq mr js jt ju ms jw jx jy mx ka kb kc my ke kf kg mz ki kj kk ij bi translated">首先，我们需要用Webhook Relay sidecar部署Keel。这是一次性的事情，之后当您向Kubernetes环境添加更多应用程序时，您不需要重复这一步。</p><p id="1cb3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Webhook中继守护程序需要身份验证详细信息才能连接。我们可以使用<code class="fe nn no np ne b">relay</code> CLI来配置并将secret插入到我们的Kubernetes环境中:</p><pre class="km kn ko kp gt nd ne nf ng aw nh bi"><span id="561a" class="ni lu iq ne b gy nj nk l nl nm">kubectl create namespace keel</span></pre><p id="4bce" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，让我们创造一个秘密:</p><pre class="km kn ko kp gt nd ne nf ng aw nh bi"><span id="f459" class="ni lu iq ne b gy nj nk l nl nm">relay ingress secret --name webhookrelay-credentials --namespace keel</span></pre></div><div class="ab cl lm ln hu lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="ij ik il im in"><h2 id="9a7e" class="ni lu iq bd lv ny nz dn lz oa ob dp md jy oc od mh kc oe of ml kg og oh mp oi bi translated">展开龙骨</h2><p id="189e" class="pw-post-body-paragraph jn jo iq jp b jq mr js jt ju ms jw jx jy mx ka kb kc my ke kf kg mz ki kj kk ij bi translated">现在，如果您的群集启用了RBAC，请使用此模板(如果您使用的是Minikube，则默认情况下它应该是启用的):</p><pre class="km kn ko kp gt nd ne nf ng aw nh bi"><span id="e506" class="ni lu iq ne b gy nj nk l nl nm">kubectl create -f <a class="ae lg" href="https://raw.githubusercontent.com/keel-hq/keel/master/deployment/deployment-rbac-whr-sidecar.yaml" rel="noopener ugc nofollow" target="_blank">https://raw.githubusercontent.com/keel-hq/keel/master/deployment/deployment-rbac-whr-sidecar.yaml</a></span></pre><p id="8750" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果集群中没有RBAC，请使用:</p><pre class="km kn ko kp gt nd ne nf ng aw nh bi"><span id="62d5" class="ni lu iq ne b gy nj nk l nl nm">kubectl create -f <a class="ae lg" href="https://raw.githubusercontent.com/keel-hq/keel/master/deployment/deployment-norbac-whr-sidecar.yaml" rel="noopener ugc nofollow" target="_blank">https://raw.githubusercontent.com/keel-hq/keel/master/deployment/deployment-norbac-whr-sidecar.yaml</a></span></pre><blockquote class="oj ok ol"><p id="6ff3" class="jn jo om jp b jq jr js jt ju jv jw jx on jz ka kb oo kd ke kf op kh ki kj kk ij bi translated"><em class="iq">提示:可以随意在本地保存部署清单，并添加Slack或其他聊天提供者通知、批准等内容。为了简单起见，我们在本教程中省略了这些步骤。</em></p></blockquote><p id="5979" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，当我们创建它时，Kubernetes应该对现有的名称空间有所抱怨，但这是意料之中的:</p><pre class="km kn ko kp gt nd ne nf ng aw nh bi"><span id="eb04" class="ni lu iq ne b gy nj nk l nl nm">$ kubectl create -f <a class="ae lg" href="https://raw.githubusercontent.com/keel-hq/keel/master/deployment/deployment-rbac-whr-sidecar.yaml" rel="noopener ugc nofollow" target="_blank">https://raw.githubusercontent.com/keel-hq/keel/master/deployment/deployment-rbac-whr-sidecar.yaml</a><br/>serviceaccount “keel” created<br/>clusterrolebinding.rbac.authorization.k8s.io “keel-clusterrole-binding” created<br/>clusterrole.rbac.authorization.k8s.io “keel-clusterrole” created<br/>deployment.extensions “keel” created<br/>Error from server (AlreadyExists): error when creating “https://raw.githubusercontent.com/keel-hq/keel/master/deployment/deployment-rbac-whr-sidecar.yaml": namespaces “keel” already exists<br/>$ kubectl get pods -n keel<br/>NAME READY STATUS RESTARTS AGE<br/>keel-f8b5959cc-jrgcd 2/2 Running 0 8s</span></pre></div><div class="ab cl lm ln hu lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="ij ik il im in"><h2 id="9acb" class="ni lu iq bd lv ny nz dn lz oa ob dp md jy oc od mh kc oe of ml kg og oh mp oi bi translated">部署您的应用</h2><p id="6b3c" class="pw-post-body-paragraph jn jo iq jp b jq mr js jt ju ms jw jx jy mx ka kb kc my ke kf kg mz ki kj kk ij bi translated">现在，我们需要创建应用程序的部署文件:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="7e02" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将其另存为<code class="fe nn no np ne b">deployment.yaml</code>并通过kubectl创建它:</p><pre class="km kn ko kp gt nd ne nf ng aw nh bi"><span id="7b15" class="ni lu iq ne b gy nj nk l nl nm">kubectl create -f deployment.yaml</span></pre><p id="e5d4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">检查它是否正在运行:</p><pre class="km kn ko kp gt nd ne nf ng aw nh bi"><span id="7126" class="ni lu iq ne b gy nj nk l nl nm">$ kubectl get pods<br/>NAME READY STATUS RESTARTS AGE<br/>pushwf-8476855f97-nw4st 1/1 Running 0 1m<br/>$ kubectl logs pushwf-8476855f97-nw4st<br/>App is starting, version: v0</span></pre><p id="1d41" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，将您的Go程序的版本字符串更新为<code class="fe nn no np ne b">v1</code>:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="66f4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">提交和推送。一两分钟后(取决于DockerHub构建图像的速度),我们的应用程序应该会更新。因为它使用webhooks，所以更新应该是即时的。</p><p id="d3af" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您访问Webhook中继<code class="fe nn no np ne b">dockerhub</code> bucket的页面，它应该显示中继的webhook:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi oq"><img src="../Images/5137a818e21a1a832416634927f0f31f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*M4O1w9vW1S83ePn2.png"/></div></div></figure><p id="65fc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们检查一下我们的部署部署历史:</p><pre class="km kn ko kp gt nd ne nf ng aw nh bi"><span id="480f" class="ni lu iq ne b gy nj nk l nl nm">$ kubectl rollout history deployment/pushwf<br/>deployments “pushwf”<br/>REVISION CHANGE-CAUSE<br/>1 &lt;none&gt;<br/>2 keel automated update, version latest -&gt; latest</span></pre><p id="402c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">和日志，只是为了确保我们的应用程序运行的是最新的代码:</p><pre class="km kn ko kp gt nd ne nf ng aw nh bi"><span id="02d1" class="ni lu iq ne b gy nj nk l nl nm">$ kubectl get pods<br/>NAME READY STATUS RESTARTS AGE<br/>pushwf-74c574f9cf-l6lq2 1/1 Running 0 4m<br/>$ kubectl logs pushwf-74c574f9cf-l6lq2<br/>App is starting, version: v1</span></pre></div><div class="ab cl lm ln hu lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="ij ik il im in"><h1 id="8423" class="lt lu iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">结论</h1><p id="b3c1" class="pw-post-body-paragraph jn jo iq jp b jq mr js jt ju ms jw jx jy mx ka kb kc my ke kf kg mz ki kj kk ij bi translated">虽然设置Keel和Webhook中继会占用您宝贵的几分钟时间，但它会节省大量的时间。您不仅可以根据策略获得应用程序的即时更新，还可以确保不会错误地更新错误的群集或环境。当然，您甚至不需要使用<code class="fe nn no np ne b">kubectl</code>来更新您的应用程序。</p><p id="1f68" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦在集群中设置了Keel，就可以管理许多(所有)应用程序。当您将下一个应用程序添加到集群时，只需指定策略并将DockerHub webhook指向同一个webhook中继端点。Keel会根据webhook有效载荷筛选出相关部署，并进行更新。</p><p id="cdda" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你有任何问题或者发现本教程的某些部分不正确，请在Keel的资源库<a class="ae lg" href="https://github.com/keel-hq/keel/issues" rel="noopener ugc nofollow" target="_blank">这里</a>提出问题</p></div><div class="ab cl lm ln hu lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="ij ik il im in"><p id="cdf2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="om">最初发表于</em> <a class="ae lg" href="https://keel.sh/v1/examples/push-to-deploy.html" rel="noopener ugc nofollow" target="_blank"> <em class="om"> keel.sh </em> </a> <em class="om">。</em></p></div></div>    
</body>
</html>