# 分享编程知识，而不是信息

> 原文：<https://itnext.io/share-programming-knowledge-not-information-87e89cb35af1?source=collection_archive---------0----------------------->

## 不要制造工作做得很好的假象。

![](img/6cb050744f39ac35c78592793b5a9316.png)

这幅画来自安德烈·马丁斯·德·巴罗斯，一位梦幻般的现实主义艺术家。它展示了一堆有组织的书，创造了一个老年人阅读另一本书的视觉错觉。

你已经开始维护一个新项目。您创建了一些测试，它们通过了您的本地开发环境。然后，您将代码部署到生产环境中，结果测试失败，并显示一条消息“找不到 env var SOME_SERVICE_KEY”。

嗯 env 变量存在于您的本地机器中，并且所有其他测试都通过了。管道应该以与本地相同的方式运行。为什么你刚写的测试不行？

你问一些高级开发人员，他们异口同声地说:

> 您必须将测试文件从 test.spec.js 重命名为 test.integration.js，这将修复错误。

你回到代码，重命名文件，提交，推向生产，一切都很好。下一次当你写一个测试，你想访问一些环境变量时，你要遵循指导方针，把文件命名为`*.integration.js`，这样你就不会再遇到这个问题了。

然而，下一个开发者可能不知道这个文件名约定。下一个开发人员可能会问你和你问高级开发人员一样的问题。您决定在开发人员的入职流程中记录这些信息:

> **小心文件名**
> 
> 如果您想要访问测试环境变量，您必须将测试文件重命名为 test.integration.js。否则，管道将失败，但是测试将在您的本地机器上工作。

每个人都很开心。干得好！滴答。

> 记录信息，以便下一个开发人员知道系统是如何工作的。这样，他们就不会犯同样的错误。

想象另一个场景。

你已经开始维护一个新项目。您创建了一些测试，它们通过了您的本地开发环境。然后，您将代码部署到生产环境中，结果测试失败，并显示一条消息“找不到 env var SOME_SERVICE_KEY”。

嗯 env 变量存在于您的本地机器中，并且所有其他测试都通过了。管道应该以与本地相同的方式运行。为什么你刚写的测试不行？

你问几个高级开发人员，其中一个告诉你:

> 让我们坐在一起，看看它是如何工作的:
> 
> 1.我们用 CircleCI。
> 
> 2.当它下载项目时，CircleCI 运行文件`*.circleci/config.yml*`。
> 
> 3.CircleCI 文件中的一个命令是`*npm test*`。
> 
> 4.`*npm test*`是`*npm test:spec*`和`*npm test:integration*`的别名。
> 
> 5.命令`*npm test:integration*`是`*. ./dev-environment.sh && mocha 'src/**/*.integration.js'*`的别名，它运行所有带有`*integration*`后缀的测试。
> 
> 6.`*./dev-environment.sh*`文件包含所有环境变量的值。其中一个变量是“某个服务密钥”。
> 
> 7.在生产中，我们使用弹性豆茎。“SOME_SERVICE_KEY”变量包含生产值。在本地开发中，“SOME_SERVICE_KEY”包括测试键的值。
> 
> 8.错误“找不到 env var”出现在 CircleCI 中但在本地开发中有效的原因是，您创建的测试正在读取“SOME_SERVICE_KEY”，但您的文件名称是`**.spec.js*`，因此它通过`*npm run test:spec*`运行，这是一个运行时不注入`*. ./dev-environment.sh*`的命令。
> 
> 9.为什么？我们将依赖环境的测试，比如数据库凭证和第三方 API 密钥，与不依赖环境的测试分开。我们称它们为**规范**和**集成**。
> 
> 10.为什么？我们这样做是为了防止将确定性测试与那些其结果会受到特定环境副作用影响的测试相混淆。环境可能配置错误，这并不意味着测试有问题，而是环境有问题。我们希望确保大多数测试都属于不会因为环境状态而失败的类别。我们希望更加确信我们已经了解了一个主要的逻辑问题，而不是我们忘记了在我们的开发机器中配置一些软件。

所以你从他们的解释中得出结论，你必须将文件从`test.spec.js`重命名为`test.integration.js`。

你回到代码，重命名文件，提交，推向生产，一切都很好。下一次当您编写一个想要访问环境变量的测试时，您将该文件命名为`*.integration.js`，并且您再也不会遇到这个问题。

然而，下一个开发者可能不知道这个文件名约定。下一个开发人员可能会问你和你问高级开发人员一样的问题。您决定在开发人员的入职流程中记录这些信息:

> **测试惯例**
> 
> 我们将依赖于环境的测试，比如数据库、环境变量和第三方服务调用，与不依赖于环境的测试分开。我们称之为 **Spec (*.spec.js)** 和**Integration(* . Integration . js)**。
> 
> […]

在第二个例子中，他们一起查看代码并遵循代码的每一步。当更有经验的开发人员走过时，他们开始记得为什么团队以这种方式编写代码。如果没有了解更深的人的帮助，仅仅靠自己阅读代码是无法获得这些知识的。

> 记录这些知识，以便下一个开发人员理解为什么系统以这种方式工作。这样，他们就不会犯类似的错误。

学术界长期以来一直在争论什么是信息，什么是知识。他们唯一认同的是信息是知识的子集。对于这个帖子来说，给出“信息”就是告诉它如何工作的最小量(the how)；提供“知识”就是说围绕结果的原因，并用它为什么起作用的原因(为什么)来补充信息。

以下是每种情况的权衡:

通过文本或文字传递信息更容易。但是，在没有咨询原始信息来源的情况下，它不会帮助接收者解决未来的其他类似问题。

当代码中出现错误时，开发人员必须再次向高级人员询问类似的模式。开发人员已经失去了对模式给出反馈的能力，并且可能帮助组织将它们变得更好。他们只知道让它工作所需的最低限度，而不知道为什么它会这样工作。

单靠文字或单词传递**知识**更难。从原始来源传递知识比传递信息需要更大的努力。这就是为什么高级开发人员提议让[和](https://fagnerbrack.com/pair-programming-8cfbf2dc4d00)坐在一起，一步一步地展示它是如何工作的以及为什么工作。

下一次，开发者就不用在代码里找学长要类似的模式了。例如，他们可能自己发现，如果他们在`ui-tests`文件夹上创建一个新的 UI 测试，它将自动在 CircleCI 上运行。他们可以自己学习，因为他们现在对事物的工作方式和原因有了更广泛的理解。

> 像大多数编程一样，这是短期和长期的权衡。

虽然从局外人的角度来看，两者的结果是一样的，但它们远不是一样的。虽然有人可能会抱怨高级开发人员花费太多时间帮助新开发人员，但另一个人可能会抱怨少数高级人员是瓶颈，所以其他开发人员需要对系统有广泛的理解。当你分享知识时，[投资回报](https://www.investopedia.com/terms/r/returnoninvestment.asp)是值得的。

下次有人向你求助时，不要只给他们一点信息。这只会让你成为同龄人中的新维基百科。你给自己发了一张护照，让组织提升你到[你的无能级别](https://en.wikipedia.org/wiki/Peter_principle)。

下次你面临问题时，不要仅仅满足于一条信息。只有当你意识到人们为什么会这样做，包括周围的原因和影响，并改进某件事情时，你才能产生影响。

鼓励团队所有成员之间的知识共享，而不是信息共享。如果你做到了，那么你就拥有了一个高绩效的组织。

多分享知识，少分享信息。

现在你知道了。

如果你的团队从我关于这篇文章或我正在进行的任何其他项目的谈话和/或问答中受益，请在`contact at fagnermartins.com`给我写信。

**相关阅读:**

*   [guru99.com——信息与知识:主要区别](https://www.guru99.com/information-vs-knowledge-difference.html)
*   Braf，Ewa (2002)，知识还是信息——什么造成了差异？人类、技术和组织研究中心
    (CMTO)。瑞典林雪平大学 VITS 研究小组
*   [达曼·奥拉夫，医学博士，SM (2019)。数据、信息、证据和知识:健康信息学和数据科学提案。在线公共健康信息。2018;10(3): e224。](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC6435353/)
*   [彼得·诺尔，作为理论大厦的编程。](https://pages.cs.wisc.edu/~remzi/Naur.pdf)(感谢 Reddit 上的 [Yord13](https://www.reddit.com/user/Yord13/) 指出这篇论文，强烈推荐阅读)

感谢阅读。如果你有一些反馈，请在推特上联系我。