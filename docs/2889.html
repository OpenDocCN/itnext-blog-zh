<html>
<head>
<title>Mutual Auto-Unseal Two Vault clusters in Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">相互自动解封Kubernetes中的两个保险库集群</h1>
<blockquote>原文：<a href="https://itnext.io/mutual-auto-unseal-two-vault-clusters-in-kubernetes-465516da98f8?source=collection_archive---------0-----------------------#2019-08-23">https://itnext.io/mutual-auto-unseal-two-vault-clusters-in-kubernetes-465516da98f8?source=collection_archive---------0-----------------------#2019-08-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="9c00" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">相互自动解封Kubernetes中的两个保险库集群</p><h2 id="fe33" class="ko kp it bd kq kr ks dn kt ku kv dp kw kb kx ky kz kf la lb lc kj ld le lf lg bi translated">介绍</h2><p id="0fe2" class="pw-post-body-paragraph jq jr it js b jt lh jv jw jx li jz ka kb lj kd ke kf lk kh ki kj ll kl km kn im bi translated">当我将<a class="ae lm" href="https://learn.hashicorp.com/vault/" rel="noopener ugc nofollow" target="_blank"> Vault </a>部署到Kubernetes时，我意识到拥有自动解封功能对Vault集群实现真正的高可用性非常重要。</p><p id="2c69" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我以前的文章“Kubernetes中的高可用性Vault cluster”(<a class="ae lm" href="https://medium.com/@liejuntao001/highly-available-vault-cluster-in-kubernetes-e406f07569a6" rel="noopener">链接</a>)中，即使我已经尽力使Vault cluster尽可能地高可用性，在没有自动解封的情况下，Vault cluster也可以容忍部分pods故障，但无法承受整个集群的重新启动。</p><p id="6200" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><a class="ae lm" rel="noopener ugc nofollow" target="_blank" href="/hashicorp-vault-on-kubernetes-with-auto-unseal-b7e64edbe63e"> <em class="ln">这篇文章</em> </a>很好地解释了为什么和如何。对我来说，问题是我没有“AWS KMS服务”可以使用，或者任何类似的云供应商安全服务，因为我在自我管理的云供应商上运行Kubernetes(<a class="ae lm" href="https://medium.com/@liejuntao001/create-highly-available-kubernetes-cluster-with-minimal-dependencies-c45f5b34e9d2?source=friends_link&amp;sk=cb2aa36f5c61f2d59211664e75f29946" rel="noopener"><em class="ln">本文</em> </a>解释了我的设置)。</p><p id="3a66" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Vault版本<a class="ae lm" href="https://www.hashicorp.com/blog/vault-1-1" rel="noopener ugc nofollow" target="_blank"> 1.1 </a>新增支持“中转自动解封”，即使用第二个Vault集群B自动解封集群a。</p><p id="1c3f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里的想法是，部署2个存储集群A和B，并设置它们为彼此自动解封。</p><p id="d448" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果存储区群集A和B本身都具有高可用性，则在任何pod崩溃/更新的情况下，新的pod可以从另一个群集自动解封。两个集群的所有吊舱同时停机的可能性应该非常小。</p><p id="03a8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本文中，我在同一个Kubernetes集群中部署了两个vault集群，命名为“Vault”和“vault-unlock”，位于两个名称空间中。在实际生产环境中，我会建议在两个Kubernetes集群中部署它们的更健壮的方法。</p><p id="2332" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面是示意图。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi lo"><img src="../Images/0f8ac75d65023618b5b2a613c31c25d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jO73wdVjbB4mxF786vyyaA.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">体系结构</figcaption></figure><p id="eb29" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ln">2020年1月9日更新</em></p><blockquote class="me mf mg"><p id="48e6" class="jq jr ln js b jt ju jv jw jx jy jz ka mh kc kd ke mi kg kh ki mj kk kl km kn im bi translated"><em class="it"> Vault使用Consul集群作为存储后端。为了保证安全/稳定，我在</em> <a class="ae lm" href="https://medium.com/swlh/consul-in-kubernetes-pushing-to-production-223506bbe8db" rel="noopener"> <em class="it">这篇文章</em> </a> <em class="it">中分享了我最近在Kubernetes中运行Consul进行生产的经验。</em></p></blockquote><h2 id="b2a1" class="ko kp it bd kq kr ks dn kt ku kv dp kw kb kx ky kz kf la lb lc kj ld le lf lg bi translated">本文中使用的来源</h2><pre class="lp lq lr ls gt mk ml mm mn aw mo bi"><span id="f455" class="ko kp it ml b gy mp mq l mr ms"><a class="ae lm" href="https://github.com/liejuntao001/vault-mutual-auto-unseal" rel="noopener ugc nofollow" target="_blank">github link</a></span></pre><h2 id="c6cb" class="ko kp it bd kq kr ks dn kt ku kv dp kw kb kx ky kz kf la lb lc kj ld le lf lg bi translated">先决条件</h2><ul class=""><li id="5a3e" class="mt mu it js b jt lh jx li kb mv kf mw kj mx kn my mz na nb bi translated">高可用性Kubernetes集群(<a class="ae lm" href="https://medium.com/@liejuntao001/create-highly-available-kubernetes-cluster-with-minimal-dependencies-c45f5b34e9d2" rel="noopener">示例</a>)</li></ul><h2 id="3ba1" class="ko kp it bd kq kr ks dn kt ku kv dp kw kb kx ky kz kf la lb lc kj ld le lf lg bi translated">部署2个存储集群</h2><p id="d36f" class="pw-post-body-paragraph jq jr it js b jt lh jv jw jx li jz ka kb lj kd ke kf lk kh ki kj ll kl km kn im bi translated">第一个集群被命名为“vault”，位于源代码文件夹“vault”中。此集群用于外部服务，因此它有一个入口规则。</p><p id="7a30" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">遵循这里描述的<a class="ae lm" href="https://medium.com/@liejuntao001/highly-available-vault-cluster-in-kubernetes-e406f07569a6" rel="noopener"><em class="ln"/></a><em class="ln"/>或类似如下的步骤。</p><p id="bd7b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第二个群集被命名为“vault-unlock”，位于源代码文件夹“vault2”中。<br/>该集群<strong class="js iu">专用于</strong>自动解封目的。</p><p id="3a26" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">基本上，这与创建第一个集群的步骤相同，只是“vault-unlock”命名空间中的所有内容，没有入口。</p><p id="8bd7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">检查源代码中的README.md文件，了解以下命令。</p><pre class="lp lq lr ls gt mk ml mm mn aw mo bi"><span id="47f7" class="ko kp it ml b gy mp mq l mr ms"># create namespace<br/>$ kubectl apply -f vault2/vault_namespace.yml</span><span id="3709" class="ko kp it ml b gy nc mq l mr ms"># go to ca folder<br/>$ cd ca</span><span id="c5d9" class="ko kp it ml b gy nc mq l mr ms"># create certs<br/>$ cfssl gencert \<br/>    -ca=ca.pem \<br/>    -ca-key=ca-key.pem \<br/>    -config=config/ca-config.json \<br/>    -profile=default \<br/>    config/vault-unlock-csr.json | cfssljson -bare vault-unlock</span><span id="9c67" class="ko kp it ml b gy nc mq l mr ms"># it's important to use the same GOSSIP_ENCRYPTION_KEY as first cluster<br/>$ kubectl -n vault-unlock create secret generic vault \<br/>    --from-literal="gossip-encryption-key=${GOSSIP_ENCRYPTION_KEY}" \<br/>    --from-file=ca.pem \<br/>    --from-file=vault-unlock.pem \<br/>    --from-file=vault-unlock-key.pem \<br/>    --from-file=vault-client.pem \<br/>    --from-file=vault-client-key.pem</span><span id="b673" class="ko kp it ml b gy nc mq l mr ms"># go to vault2 folder<br/>$ cd vault2<br/>$ kubectl -n vault-unlock create configmap vault --from-file=config/vault.json</span><span id="8fdd" class="ko kp it ml b gy nc mq l mr ms"># now deploy<br/>$ kubectl apply -f .</span><span id="71fe" class="ko kp it ml b gy nc mq l mr ms"># init and unseal<br/>$ vault operator init</span><span id="1771" class="ko kp it ml b gy nc mq l mr ms">$ vault operator unseal</span><span id="0c21" class="ko kp it ml b gy nc mq l mr ms">$ vault status<br/>Key             Value<br/>---             -----<br/>Seal Type       shamir<br/>Initialized     true<br/>Sealed          false<br/>Total Shares    5<br/>Threshold       3<br/>Version         1.1.3<br/>Cluster Name    vault-cluster-98e11b27<br/>Cluster ID      3804aaeb-8f62-ca79-4e34-f2cad7dfd062<br/>HA Enabled      true<br/>HA Cluster      <a class="ae lm" href="https://10.0.210.129:8201" rel="noopener ugc nofollow" target="_blank">https://10.0.210.129:8201</a><br/>HA Mode         active</span></pre><p id="c35f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">部署完成后，consul UI如下所示</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi nd"><img src="../Images/54a309c38396403147e93eb89a1ef655.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Imt1cYgm14PHkrUpKH3n-w.png"/></div></div></figure><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi ne"><img src="../Images/e4bf440a7cd8eccb352dca846d7b4390.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GZtRoxH9b34cg21kaZwk8w.png"/></div></div></figure><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi nd"><img src="../Images/644713994b268ffbbaf9f4462dcc5863.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lFY0SaZ1eS0m2dTY0btDtQ.png"/></div></div></figure><p id="81ef" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">可以通过公共地址访问Vault UI</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi nf"><img src="../Images/b387442fdfc9437951a3047e3830b390.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rTsLeJeLtnWMjm77EzhLKQ.png"/></div></div></figure><h1 id="0809" class="ng kp it bd kq nh ni nj kt nk nl nm kw nn no np kz nq nr ns lc nt nu nv lf nw bi translated">前半部分—使用群集存储库自动解封存储库-解锁</h1><p id="c4da" class="pw-post-body-paragraph jq jr it js b jt lh jv jw jx li jz ka kb lj kd ke kf lk kh ki kj ll kl km kn im bi translated">我按照<a class="ae lm" href="https://learn.hashicorp.com/vault/operations/autounseal-transit" rel="noopener ugc nofollow" target="_blank"> <em class="ln">公文</em> </a>的指示。</p><p id="3425" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">前提条件</strong></p><p id="83ad" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">群集“保险存储”已完全解封并正常工作</p><p id="1208" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">集群“保险库”中的操作</strong></p><pre class="lp lq lr ls gt mk ml mm mn aw mo bi"><span id="8aaf" class="ko kp it ml b gy mp mq l mr ms"># connect to "vault" cluster<br/>$ kubectl -n vault port-forward svc/vault 8200 &amp;</span><span id="3a27" class="ko kp it ml b gy nc mq l mr ms"># below commands need root token</span><span id="fea1" class="ko kp it ml b gy nc mq l mr ms">$ vault login<br/>Token (will be hidden):</span><span id="6bc7" class="ko kp it ml b gy nc mq l mr ms"># enable audit, logs into container console <br/>$ vault audit enable file file_path=stdout<br/>Success! Enabled the file audit device at: file/</span><span id="4c3c" class="ko kp it ml b gy nc mq l mr ms"># enable transit engine<br/>$ vault secrets enable transit</span><span id="2284" class="ko kp it ml b gy nc mq l mr ms"># create key "autounseal"<br/>$ vault write -f transit/keys/autounseal<br/>Success! Data written to: transit/keys/autounseal</span><span id="3056" class="ko kp it ml b gy nc mq l mr ms"># create autounseal policy, content from official doc<br/>$ vault policy write autounseal autounseal.hcl<br/>Success! Uploaded policy: autounseal</span><span id="ebdd" class="ko kp it ml b gy nc mq l mr ms"># create a token with the policy, it's wrapped in wrapping_token<br/>$ vault token create -policy="autounseal" -wrap-ttl=120<br/>Key                              Value<br/>---                              -----<br/>wrapping_token:                  s.AO55UYmKpT4TmPVn2AZ0UkNT<br/>wrapping_accessor:               7N3PtIwhuAtjJZ2GvA9RM0iV<br/>wrapping_token_ttl:              2m<br/>wrapping_token_creation_time:    2019-06-25 19:24:46.345501602 +0000 UTC<br/>wrapping_token_creation_path:    auth/token/create<br/>wrapped_accessor:                B8kWfoLfXYOAxFI2P2TIduaI</span><span id="03fd" class="ko kp it ml b gy nc mq l mr ms"># get the token from wrapping_token<br/># as previous command shows, the wrapping_token is only valid for 120 seconds<br/>$ VAULT_TOKEN="s.AO55UYmKpT4TmPVn2AZ0UkNT" vault unwrap<br/>Key                  Value<br/>---                  -----<br/>token                s.LvLFn4InVdIorAFS5E9j6xd3<br/>token_accessor       KST0fJN4xMd2Yaztrmya8SNx<br/>token_duration       768h<br/>token_renewable      true<br/>token_policies       ["autounseal" "default"]<br/>identity_policies    []<br/>policies             ["autounseal" "default"]</span><span id="e420" class="ko kp it ml b gy nc mq l mr ms"># this is the token to be used in next step<br/>token                s.LvLFn4InVdIorAFS5E9j6xd3</span></pre><p id="6dda" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">集群“保险库解锁”中的操作</strong></p><p id="9914" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在源代码中，将vault2/config/vault.json复制为vault 2/config/vault _ auto启封. json，并附加“seal”配置。</p><p id="c006" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面是我的例子，详细参考<a class="ae lm" href="https://www.vaultproject.io/docs/configuration/seal/transit.html" rel="noopener ugc nofollow" target="_blank"> <em class="ln"> doc </em> </a> <em class="ln">。填写上一步得到的令牌。</em></p><pre class="lp lq lr ls gt mk ml mm mn aw mo bi"><span id="dc9b" class="ko kp it ml b gy mp mq l mr ms">"seal": {<br/>    "transit": {<br/>      "address": "<a class="ae lm" href="https://vault.vault.svc.cluster.local:8200" rel="noopener ugc nofollow" target="_blank">https://vault.vault.svc.cluster.local:8200</a>",<br/>      "token": "this_is_token_to_access_vault",<br/>      "disable_renewal":"false",<br/>      "key_name": "autounseal",<br/>      "mount_path": "transit/",<br/>      "tls_skip_verify": "false",<br/>      "tls_server_name": "vault",<br/>      "tls_ca_file": "/etc/tls/ca.pem",<br/>      "tls_client_cert": "/etc/tls/vault-unlock.pem",<br/>      "tls_client_key": "/etc/tls/vault-unlock-key.pem"<br/>    }<br/>  },</span></pre><p id="5009" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用文件“vault _ auto启封. json”中的内容重新创建配置映射“vault ”,但仍将其命名为“vault.json ”,以供pod使用。</p><pre class="lp lq lr ls gt mk ml mm mn aw mo bi"><span id="fc45" class="ko kp it ml b gy mp mq l mr ms">kubectl -n vault-unlock create configmap vault --from-file=vault.json=config/vault_autounseal.json -o yaml --dry-run | kubectl replace -f -</span></pre><p id="d6dc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">重新创建保管库解锁部署。具有自动解封配置的日志如下所示:</p><pre class="lp lq lr ls gt mk ml mm mn aw mo bi"><span id="bbf8" class="ko kp it ml b gy mp mq l mr ms"># Do below in source code vault2/<br/>$ kubectl delete -f vault_deployment.yml<br/>$ kubectl apply -f vault_deployment.yml<br/>$ kubectl -n vault-unlock logs -f vault-544d44df85-6pmvf -c<br/> vault<br/>==&gt; Vault server configuration:</span><span id="12bf" class="ko kp it ml b gy nc mq l mr ms">Seal Type: transit<br/>         Transit Address: <a class="ae lm" href="https://vault.vault.svc.cluster.local:8200" rel="noopener ugc nofollow" target="_blank">https://vault.vault.svc.cluster.local:8200</a><br/>        Transit Key Name: autounseal<br/>      Transit Mount Path: transit/<br/>             Api Address: <a class="ae lm" href="https://vault.vault-unlock.svc.cluster.local:8200" rel="noopener ugc nofollow" target="_blank">https://vault.vault-unlock.svc.cluster.local:8200</a><br/>                     Cgo: disabled<br/>         Cluster Address: <a class="ae lm" href="https://10.0.181.115:8201" rel="noopener ugc nofollow" target="_blank">https://10.0.181.115:8201</a><br/>              Listener 1: tcp (addr: "[::]:8200", cluster address: "[::]:8201", max_request_duration: "1m30s", max_request_size: "33554432", tls: "enabled")<br/>               Log Level: info<br/>                   Mlock: supported: true, enabled: true<br/>                 Storage: consul (HA available)<br/>                 Version: Vault v1.1.3<br/>             Version Sha: 9bc820f700f83a7c4bcab54c5323735a581b34eb</span><span id="c928" class="ko kp it ml b gy nc mq l mr ms">2019-06-25T19:51:54.065Z [WARN]  core: entering seal migration mode; Vault will not automatically unseal even if using an autoseal: from_barrier_type=shamir to_barrier_type=transit<br/>==&gt; Vault server started! Log data will stream in below:</span></pre><p id="5b7c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，“保险存储-解锁”群集处于“密封迁移模式”。</p><p id="093c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">进行海豹迁徙</p><pre class="lp lq lr ls gt mk ml mm mn aw mo bi"><span id="ffd3" class="ko kp it ml b gy mp mq l mr ms"># connect to "vault-unlock" cluster<br/>$ kubectl -n vault-unlock port-forward vault-544d44df85-6pmvf 8200 &amp;</span><span id="db38" class="ko kp it ml b gy nc mq l mr ms"># below means seal migration in progress<br/>$ vault status<br/>Key                           Value<br/>---                           -----<br/>Recovery Seal Type            shamir<br/>Initialized                   true<br/>Sealed                        true<br/>Total Recovery Shares         5<br/>Threshold                     3<br/>Unseal Progress               0/3<br/>Unseal Nonce                  n/a<br/>Seal Migration in Progress    true<br/>Version                       1.1.3<br/>HA Enabled                    true</span><span id="fd44" class="ko kp it ml b gy nc mq l mr ms"># do seal migration<br/>$ vault operator unseal -migrate<br/>Unseal Key (will be hidden):</span><span id="ac38" class="ko kp it ml b gy nc mq l mr ms"># Repeat until unsealed<br/>$ vault status<br/>Key                      Value<br/>---                      -----<br/>Recovery Seal Type       shamir<br/>Initialized              true<br/>Sealed                   false<br/>Total Recovery Shares    5<br/>Threshold                3<br/>Version                  1.1.3<br/>Cluster Name             vault-cluster-c6f60ee0<br/>Cluster ID               a152257b-813d-9eb3-57ea-f7d0683f0b1c<br/>HA Enabled               true<br/>HA Cluster               <a class="ae lm" href="https://10.0.181.115:8201" rel="noopener ugc nofollow" target="_blank">https://10.0.181.115:8201</a><br/>HA Mode                  active</span></pre><p id="7ff5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">只有一个舱需要海豹迁移。</p><p id="1786" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在重新启动vault-unlock集群。“保险库-解锁”的所有窗格都将自动解封。日志如下所示:</p><pre class="lp lq lr ls gt mk ml mm mn aw mo bi"><span id="9ab3" class="ko kp it ml b gy mp mq l mr ms"># Do below in source code vault2/<br/>$ kubectl delete -f vault_deployment.yml<br/>$ kubectl apply -f vault_deployment.yml</span><span id="db30" class="ko kp it ml b gy nc mq l mr ms">$ kubectl -n vault-unlock logs -f vault-544d44df85-7877s -c<br/> vault<br/>==&gt; Vault server configuration:</span><span id="0848" class="ko kp it ml b gy nc mq l mr ms">Seal Type: transit<br/>         Transit Address: <a class="ae lm" href="https://vault.vault.svc.cluster.local:8200" rel="noopener ugc nofollow" target="_blank">https://vault.vault.svc.cluster.local:8200</a><br/>        Transit Key Name: autounseal<br/>      Transit Mount Path: transit/<br/>             Api Address: <a class="ae lm" href="https://vault.vault-unlock.svc.cluster.local:8200" rel="noopener ugc nofollow" target="_blank">https://vault.vault-unlock.svc.cluster.local:8200</a><br/>                     Cgo: disabled<br/>         Cluster Address: <a class="ae lm" href="https://10.0.181.70:8201" rel="noopener ugc nofollow" target="_blank">https://10.0.181.70:8201</a><br/>              Listener 1: tcp (addr: "[::]:8200", cluster address: "[::]:8201", max_request_duration: "1m30s", max_request_size: "33554432", tls: "enabled")<br/>               Log Level: info<br/>                   Mlock: supported: true, enabled: true<br/>                 Storage: consul (HA available)<br/>                 Version: Vault v1.1.3<br/>             Version Sha: 9bc820f700f83a7c4bcab54c5323735a581b34eb</span><span id="afa3" class="ko kp it ml b gy nc mq l mr ms">==&gt; Vault server started! Log data will stream in below:</span><span id="bcd5" class="ko kp it ml b gy nc mq l mr ms">2019-06-25T20:01:28.680Z [INFO]  core: stored unseal keys supported, attempting fetch<br/>2019-06-25T20:01:28.702Z [INFO]  core: vault is unsealed<br/>2019-06-25T20:01:28.702Z [INFO]  core.cluster-listener: starting listener: listener_address=[::]:8201<br/>2019-06-25T20:01:28.702Z [INFO]  core.cluster-listener: serving cluster requests: cluster_listen_address=[::]:8201<br/>2019-06-25T20:01:28.703Z [INFO]  core: entering standby mode<br/>2019-06-25T20:01:28.706Z [INFO]  core: unsealed with stored keys: stored_keys_used=1<br/>2019-06-25T20:01:28.736Z [INFO]  core: acquired lock, enabling active operation<br/>2019-06-25T20:01:28.781Z [INFO]  core: post-unseal setup starting<br/>2019-06-25T20:01:28.784Z [INFO]  core: loaded wrapping token key<br/>2019-06-25T20:01:28.784Z [INFO]  core: successfully setup plugin catalog: plugin-directory=<br/>2019-06-25T20:01:28.788Z [INFO]  core: successfully mounted backend: type=system path=sys/<br/>2019-06-25T20:01:28.788Z [INFO]  core: successfully mounted backend: type=identity path=identity/<br/>2019-06-25T20:01:28.789Z [INFO]  core: successfully mounted backend: type=cubbyhole path=cubbyhole/<br/>2019-06-25T20:01:28.811Z [INFO]  core: successfully enabled credential backend: type=token path=token/<br/>2019-06-25T20:01:28.811Z [INFO]  core: restoring leases<br/>2019-06-25T20:01:28.811Z [INFO]  rollback: starting rollback manager<br/>2019-06-25T20:01:28.813Z [INFO]  expiration: lease restore complete<br/>2019-06-25T20:01:28.816Z [INFO]  identity: entities restored<br/>2019-06-25T20:01:28.821Z [INFO]  identity: groups restored<br/>2019-06-25T20:01:28.822Z [INFO]  core: post-unseal setup complete</span></pre><p id="f568" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，集群“保险库解锁”具有“自动解封”功能。</p><h1 id="0ba4" class="ng kp it bd kq nh ni nj kt nk nl nm kw nn no np kz nq nr ns lc nt nu nv lf nw bi translated">后半部分—使用群集存储区解锁来自动解封存储区</h1><p id="cc01" class="pw-post-body-paragraph jq jr it js b jt lh jv jw jx li jz ka kb lj kd ke kf lk kh ki kj ll kl km kn im bi translated">基本上，这和上半场是一样的。</p><p id="3a1c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">请记住哪个集群正在运行…尤其是在“重新创建”部署这一步，请确保源文件夹是正确的。</p><p id="8736" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我建议在步骤中经常备份consul集群。参见<a class="ae lm" href="https://www.consul.io/docs/commands/snapshot.html" rel="noopener ugc nofollow" target="_blank"> <em class="ln"> doc </em> </a>。</p><h2 id="8731" class="ko kp it bd kq kr ks dn kt ku kv dp kw kb kx ky kz kf la lb lc kj ld le lf lg bi translated">完成了吗？</h2><p id="7ec0" class="pw-post-body-paragraph jq jr it js b jt lh jv jw jx li jz ka kb lj kd ke kf lk kh ki kj ll kl km kn im bi translated">在两个vault集群切换到“自动解封”模式后，切记不要同时销毁两个部署。如果至少有一个存储区盒处于“未密封”模式，它们最终都会被解除密封。</p><h2 id="4a28" class="ko kp it bd kq kr ks dn kt ku kv dp kw kb kx ky kz kf la lb lc kj ld le lf lg bi translated">故障排除:</h2><ul class=""><li id="7928" class="mt mu it js b jt lh jx li kb mv kf mw kj mx kn my mz na nb bi translated">尝试进行密封迁移时出错</li></ul><pre class="lp lq lr ls gt mk ml mm mn aw mo bi"><span id="2e4d" class="ko kp it ml b gy mp mq l mr ms">$ vault operator unseal -migrate<br/>Unseal Key (will be hidden):<br/>Error unsealing: Error making API request.</span><span id="ab41" class="ko kp it ml b gy nc mq l mr ms">URL: PUT <a class="ae lm" href="https://127.0.0.1:8200/v1/sys/unseal" rel="noopener ugc nofollow" target="_blank">https://127.0.0.1:8200/v1/sys/unseal</a><br/>Code: 400. Errors:</span><span id="edcf" class="ko kp it ml b gy nc mq l mr ms">* 'migrate' parameter set true in JSON body when not in seal migration mode</span></pre><p id="de85" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是因为Configmap vault仍然包含config/vault.json中的内容。用config/vault _ auto启封. json中的内容替换它</p><ul class=""><li id="9b1b" class="mt mu it js b jt ju jx jy kb nx kf ny kj nz kn my mz na nb bi translated">启用运输印章“客户端tls验证”时出错</li></ul><pre class="lp lq lr ls gt mk ml mm mn aw mo bi"><span id="54dc" class="ko kp it ml b gy mp mq l mr ms"># vault container could not start<br/>$ kubectl -n vault-unlock get pod<br/>NAME                     READY   STATUS    RESTARTS   AGE<br/>vault-6d5fff8bd8-6d5dr   1/2     Error     1          12s<br/>vault-6d5fff8bd8-cmfjt   1/2     Error     1          12s<br/>vault-6d5fff8bd8-kzn9l   1/2     Running   1          12s</span><span id="ed6c" class="ko kp it ml b gy nc mq l mr ms">$ kubectl -n vault-unlock logs -f vault-6d5fff8bd8-6d5dr -c vaul<br/>t<br/>Error parsing Seal configuration: Put <a class="ae lm" href="https://vault.vault.svc.cluster.local:8200/v1/transit/encrypt/autounseal" rel="noopener ugc nofollow" target="_blank">https://vault.vault.svc.cluster.local:8200/v1/transit/encrypt/autounseal</a>: x509: certificate signed by unknown authority</span></pre><p id="79b8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个问题困扰了我很长时间…甚至在我相信我已经正确设置了“密封”配置的所有参数之后。</p><p id="1632" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通过将“tls_skip_verify”设置为“true ”,可以很容易地使其工作，并且这可能是可以的，因为这里两个Vault集群都在同一个Kubernetes集群内。</p><p id="3c8b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是，如果两个不同的Kubernetes群集中有两个Vault群，则必须进行TLS验证。</p><pre class="lp lq lr ls gt mk ml mm mn aw mo bi"><span id="bae3" class="ko kp it ml b gy mp mq l mr ms">      "tls_skip_verify": "false",<br/>      "tls_server_name": "vault",<br/>      "tls_ca_file": "/etc/tls/ca.pem",<br/>      "tls_client_cert": "/etc/tls/vault-unlock.pem",<br/>      "tls_client_key": "/etc/tls/vault-unlock-key.pem"</span></pre><p id="e471" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如错误所示，问题一定出在证书上。经过多次尝试，我找到了目前的解决方案，就是在vault_deployment.yml中设置VAULT_CACERT</p><pre class="lp lq lr ls gt mk ml mm mn aw mo bi"><span id="23a1" class="ko kp it ml b gy mp mq l mr ms">        env:<br/>          - name: VAULT_CACERT<br/>            value: "/etc/tls/ca.pem"</span></pre><h2 id="305c" class="ko kp it bd kq kr ks dn kt ku kv dp kw kb kx ky kz kf la lb lc kj ld le lf lg bi translated">内心平静的测试</h2><p id="7741" class="pw-post-body-paragraph jq jr it js b jt lh jv jw jx li jz ka kb lj kd ke kf lk kh ki kj ll kl km kn im bi translated">因此，这两个存储区群集现在可以相互“自动解封”。目的是获得高度可用的存储库服务。</p><p id="6341" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">从用户的角度来看，我设置测试来检查保险库状态<strong class="js iu">每1秒</strong>用<a class="ae lm" href="https://github.com/hunterlong/statping" rel="noopener ugc nofollow" target="_blank">统计</a>如下。它从互联网到Kubernetes的入口控制器，再到Vault集群，检查Vault的健康状况。</p><p id="0e32" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">关于设置的更多细节在我的文章“在重启期间测量和提高Kubernetes集群的高可用性”(<a class="ae lm" href="https://medium.com/@liejuntao001/how-to-reboot-highly-available-kubernetes-cluster-5a9df4daecf" rel="noopener">链接</a>)中。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi oa"><img src="../Images/602db8085c891f8799131ff3a587d6e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Knpe1TlCHv-jJgr_tDLwDA.png"/></div></div></figure><ul class=""><li id="7652" class="mt mu it js b jt ju jx jy kb nx kf ny kj nz kn my mz na nb bi translated">滚动更新部署</li></ul><p id="25a7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如本文中的<a class="ae lm" href="https://medium.com/@liejuntao001/highly-available-vault-cluster-in-kubernetes-e406f07569a6" rel="noopener">所述，vault部署结合了“RollingUpdate”、“livenessProbe”、“readinessProbe”、“lifecycle-preStop”和“PodDisruptionBudget”。它确保在更新期间，3个pod中只有一个终止，并且新创建的pod必须进入“未密封”状态，以便进行下一次pod更新。</a></p><p id="87cc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我撰写本文时对vault部署进行的许多更新中，检测到了<strong class="js iu"> 0 </strong>故障。</p><ul class=""><li id="b650" class="mt mu it js b jt ju jx jy kb nx kf ny kj nz kn my mz na nb bi translated">主机直接重启</li></ul><p id="0d24" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在写这篇文章的时候，我得到了云提供商的一次性主机维护。两台机器停机20分钟，一台有haproxy，另一台有主节点，入口控制器也在那里。在这种情况下，statping记录了4个<strong class="js iu">故障。</strong></p><ul class=""><li id="7518" class="mt mu it js b jt ju jx jy kb nx kf ny kj nz kn my mz na nb bi translated">整个Kubernetes集群重新启动</li></ul><p id="0f56" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我使用本文<a class="ae lm" href="https://medium.com/@liejuntao001/how-to-reboot-highly-available-kubernetes-cluster-5a9df4daecf" rel="noopener">和<em class="ln">中描述的方法来测试维护重启场景。我按顺序重启Kubernetes集群的所有节点，例如:</em></a></p><pre class="lp lq lr ls gt mk ml mm mn aw mo bi"><span id="aca0" class="ko kp it ml b gy mp mq l mr ms">192.168.3.122 haproxy1.example.com haproxy1<br/>192.168.2.17 haproxy2.example.com haproxy2<br/>192.168.4.114 master1.example.com master1<br/>192.168.5.58 master2.example.com master2<br/>192.168.1.203 master3.example.com master3<br/>192.168.3.72 worker1.example.com worker1<br/>192.168.5.67 worker2.example.com worker2<br/>192.168.7.180 worker3.example.com worker3</span></pre><p id="6052" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于每个节点，首先清空pod，重新启动，等待它恢复，最后“解锁”节点。</p><p id="1ae7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这个测试中，statping总是记录大约50次故障，每个重启周期大约有<strong class="js iu">2–6</strong>次故障。我花了很长时间试图找到解决办法。我试过了<a class="ae lm" href="https://blog.gruntwork.io/zero-downtime-server-updates-for-your-kubernetes-cluster-902009df5b33" rel="noopener ugc nofollow" target="_blank">这篇文章</a>里的方法，但是没用。这里讨论的<a class="ae lm" href="https://groups.google.com/forum/#!topic/vault-tool/q-QbKku8ad4" rel="noopener ugc nofollow" target="_blank"><em class="ln"/></a><em class="ln"/>解释了保险库不是为零停机时间设计的。当活动存储节点关闭时，备用存储节点接管需要时间。</p><p id="f06a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，在源代码中，我尽我所能，对于集装箱保险库，延迟6秒，对于集装箱领事-保险库-代理，延迟6秒，然后调用“领事离开”。请让我知道是否可以做任何改进。</p><pre class="lp lq lr ls gt mk ml mm mn aw mo bi"><span id="e5e8" class="ko kp it ml b gy mp mq l mr ms"># container vault<br/>        lifecycle:<br/>          preStop:<br/>            exec:<br/>              command: [<br/>                "sh", "-c",<br/>                # Introduce a delay to the shutdown sequence to wait for the<br/>                # pod eviction event to propagate.<br/>                "sleep 6",<br/>              ]</span><span id="7fb5" class="ko kp it ml b gy nc mq l mr ms">...<br/># container consul-vault-agent</span><span id="3a99" class="ko kp it ml b gy nc mq l mr ms">        lifecycle:<br/>          preStop:<br/>            exec:<br/>              command: [<br/>                "sh", "-c",<br/>                # shutdown vault first, then shutdown consul agent<br/>                "sleep 6 &amp;&amp; consul leave"<br/>              ]</span></pre><blockquote class="me mf mg"><p id="a2e8" class="jq jr ln js b jt ju jv jw jx jy jz ka mh kc kd ke mi kg kh ki mj kk kl km kn im bi translated">2020年1月31日更新</p><p id="d8b0" class="jq jr ln js b jt ju jv jw jx jy jz ka mh kc kd ke mi kg kh ki mj kk kl km kn im bi translated">我想更新一下，在实现了高可用的Consul集群之后，Vault的可用性得到了极大的提高。阅读<a class="ae lm" href="https://medium.com/swlh/consul-in-kubernetes-pushing-to-production-223506bbe8db" rel="noopener">这篇文章</a>。</p><p id="6b8c" class="jq jr ln js b jt ju jv jw jx jy jz ka mh kc kd ke mi kg kh ki mj kk kl km kn im bi translated">在我最近的两次“<a class="ae lm" href="https://medium.com/@liejuntao001/how-to-reboot-highly-available-kubernetes-cluster-5a9df4daecf" rel="noopener">整个集群重启</a>”中，分别检测到0和1个错误。</p></blockquote><h1 id="8e7d" class="ng kp it bd kq nh ni nj kt nk nl nm kw nn no np kz nq nr ns lc nt nu nv lf nw bi translated">最坏的情况—死锁</h1><p id="878e" class="pw-post-body-paragraph jq jr it js b jt lh jv jw jx li jz ka kb lj kd ke kf lk kh ki kj ll kl km kn im bi translated">如果两个存储区群集同时死亡会怎样？我曾经不小心破坏了领事的部署。虽然我可以在不丢失数据的情况下带回领事，但两个保险库集群都无法解封。</p><p id="6090" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi">—</p><p id="0edb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">更新</strong>:我发现了另一个肯定会让金库集群崩溃的案例。由于Vault依赖Consul作为存储后端，因此如果Consul群集关闭，例如Consul进入没有领导者的状态，则Vault群集将进入所有密封状态。</p><p id="0e7d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，确保Consul集群的高可用性非常重要。我更新了consul_statefulset.yml添加了livenessProbe。当领事集群需要滚动更新时，我发现领事集群和金库集群都很好。</p><p id="ea2b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是，如果所有工作节点同时重新启动服务器，存储集群将进入死锁状态。这必须避免。</p><p id="6705" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi">—</p><p id="1920" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">不幸的是，我找不到恢复的方法，因为两个集群永远处于密封模式…我希望在这种情况下，保险库可以用所有的恢复密钥解封，但不确定这是否可能。(一个相关岗位<a class="ae lm" href="https://groups.google.com/forum/#!searchin/vault-tool/lost$20kms%7Csort:date/vault-tool/-gdDm-KRlxw/b-dLs_JMBQAJ" rel="noopener ugc nofollow" target="_blank">此处</a>)</p><pre class="lp lq lr ls gt mk ml mm mn aw mo bi"><span id="a4fb" class="ko kp it ml b gy mp mq l mr ms">$ kubectl get pod --all-namespaces -l app=vault<br/>NAMESPACE      NAME                            READY   STATUS    RESTARTS   AGE<br/>vault-unlock   vault-unlock-5fc9c7cdd7-22cl4   1/2     Running   10         5h6m<br/>vault-unlock   vault-unlock-5fc9c7cdd7-pclv8   1/2     Running   11         38h<br/>vault-unlock   vault-unlock-5fc9c7cdd7-v6pvx   1/2     Running   11         38h<br/>vault          vault-5fc9c7cdd7-62qb6          1/2     Running   11         38h<br/>vault          vault-5fc9c7cdd7-gnfdj          1/2     Running   10         5h6m<br/>vault          vault-5fc9c7cdd7-nb8n7          1/2     Running   11         38h</span></pre><p id="e2f1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以这一次，我别无选择，只能重建2个存储集群。</p><h2 id="958d" class="ko kp it bd kq kr ks dn kt ku kv dp kw kb kx ky kz kf la lb lc kj ld le lf lg bi translated">死锁的解决方案</h2><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi ob"><img src="../Images/dea8c043317f2eb973376ff5323485d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fkH0uYbFmYCcl2efaGnw8Q.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">带备份的相互自动密封</figcaption></figure><p id="3c1d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如何从理论上应该很少但有可能发生的死锁中恢复过来(而且是由于人为失误发生的)？</p><p id="fdcd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里的问题是，两个存储库集群在解封方面相互依赖。我们必须打破这种依赖性，例如，应该有一个存储区群集处于“手动”解封模式。</p><p id="cf5f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如图所示，我的想法是在第二个Kubernetes集群中创建一个“手动解封”的Vault集群。当处于“手动解封”模式时，此“手动解封”保管库群集与“保管库解锁”具有相同的内容。</p><p id="4775" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">高级步骤:</strong></p><p id="bd69" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">主<em class="ln">主</em>主</strong></p><ol class=""><li id="7830" class="mt mu it js b jt ju jx jy kb nx kf ny kj nz kn oc mz na nb bi translated">初始化“咨询”集群</li><li id="a510" class="mt mu it js b jt od jx oe kb of kf og kj oh kn oc mz na nb bi translated">初始化“存储库”集群</li><li id="768a" class="mt mu it js b jt od jx oe kb of kf og kj oh kn oc mz na nb bi translated">初始化“保险库解锁”群集</li><li id="908a" class="mt mu it js b jt od jx oe kb of kf og kj oh kn oc mz na nb bi translated">借助“保险存储-解锁”群集，将“保险存储”群集切换到自动解封模式</li></ol><p id="4d10" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> <em class="ln">助手库伯星团</em> </strong></p><ol class=""><li id="b125" class="mt mu it js b jt ju jx jy kb nx kf ny kj nz kn oc mz na nb bi translated">创建“咨询反馈”集群</li><li id="db21" class="mt mu it js b jt od jx oe kb of kf og kj oh kn oc mz na nb bi translated">拍摄主群集的“consul”内容的快照，并恢复到“consul-back”群集。仅保留“保险库-解锁”K/V目录</li><li id="628f" class="mt mu it js b jt od jx oe kb of kf og kj oh kn oc mz na nb bi translated">创建“保险库-解锁”集群，因为内容与主集群中的“保险库-解锁”相同，所以可以使用相同的解封密钥来解封</li><li id="ca0e" class="mt mu it js b jt od jx oe kb of kf og kj oh kn oc mz na nb bi translated">将helper Kubernetes中的“vault-unlock”保持在这种“手动解封”模式下，因此它总是可以手动解封，并且它有一个备份的传输密钥来解封主群集中的“vault”</li></ol><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi oi"><img src="../Images/83b054e2ee57c0e2ba7746b7280de60f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8Ul9J8U-IzWUL4Op8G8IeQ.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">执政官-回到助手库伯内特星团</figcaption></figure><p id="49df" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> <em class="ln">主库本星团</em> </strong></p><p id="a789" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">1.在“保险库”群集的帮助下，将“保险库解锁”切换到自动解封模式</p><h2 id="9ed5" class="ko kp it bd kq kr ks dn kt ku kv dp kw kb kx ky kz kf la lb lc kj ld le lf lg bi translated"><strong class="ak">死锁时</strong></h2><ol class=""><li id="5e0a" class="mt mu it js b jt lh jx li kb mv kf mw kj mx kn oc mz na nb bi translated">确保helper Kubernetes集群中的“vault-unlock”集群未密封且可访问</li><li id="f22f" class="mt mu it js b jt od jx oe kb of kf og kj oh kn oc mz na nb bi translated">从主Kubernetes中删除“保险库”部署，在助手Kubernetes中“保险库-解锁”的帮助下切换到使用“紧急解封”</li></ol><pre class="lp lq lr ls gt mk ml mm mn aw mo bi"><span id="67b1" class="ko kp it ml b gy mp mq l mr ms">kubectl -n vault create configmap vault --from-file=vault.json=config/vault_emergency.json -o yaml --dry-run | kubectl replace -f -</span></pre><p id="0b6f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">3.“vault”群集解封后，在主Kubernetes中重新创建“vault-unlock”群集，它将由主Kubernetes中的“vault”群集“自动解封”。</p><p id="c425" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">4.将“保险库”集群切换到使用主Kubernetes中的“保险库解锁”作为“自动解封”</p><pre class="lp lq lr ls gt mk ml mm mn aw mo bi"><span id="5c15" class="ko kp it ml b gy mp mq l mr ms">kubectl -n vault create configmap vault --from-file=vault.json=config/vault_autounseal.json -o yaml --dry-run | kubectl replace -f -</span></pre><p id="eb91" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ln"> Todo </em>:找出主Kubernetes“vault”集群和辅助Kubernetes“vault-unlock”集群之间的TLS通信。当前TLS验证被跳过。</p><p id="e306" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ln">更新:</em>其实我发现做TLS验证超级简单。作为帮助者，Kubernetes通过URL<a class="ae lm" href="https://vault.backup.example.com," rel="noopener ugc nofollow" target="_blank">https://vault.backup.example.com，</a>在Trafik Ingress上提供保险库服务，它使用的是加密证书。</p><p id="356c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以只需注释掉“vault”集群的vault_deployment.yml中的2行代码</p><pre class="lp lq lr ls gt mk ml mm mn aw mo bi"><span id="8c4f" class="ko kp it ml b gy mp mq l mr ms">          #- name: VAULT_CACERT<br/>          #  value: "/etc/tls/ca.pem"</span></pre><p id="ad7c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">日志:</p><pre class="lp lq lr ls gt mk ml mm mn aw mo bi"><span id="8bb2" class="ko kp it ml b gy mp mq l mr ms">$ kubectl -n vault logs -f vault-6df998bb7c-5q7g8 -c vault<br/>==&gt; Vault server configuration:</span><span id="934f" class="ko kp it ml b gy nc mq l mr ms">Seal Type: transit<br/>         Transit Address: <a class="ae lm" href="https://vault.k8s.cnhi.tech" rel="noopener ugc nofollow" target="_blank">https://vault.b</a>ackup.example.com<br/>        Transit Key Name: autounseal<br/>      Transit Mount Path: transit/<br/>             Api Address: <a class="ae lm" href="https://vault.vault.svc.cluster.local:8200" rel="noopener ugc nofollow" target="_blank">https://vault.vault.svc.cluster.local:8200</a><br/>                     Cgo: disabled<br/>         Cluster Address: <a class="ae lm" href="https://10.0.181.79:8201" rel="noopener ugc nofollow" target="_blank">https://10.0.181.79:8201</a><br/>              Listener 1: tcp (addr: "[::]:8200", cluster address: "[::]:8201", max_request_duration: "1m30s", max_request_size: "33554432", tls: "enabled")<br/>               Log Level: INFO<br/>                   Mlock: supported: true, enabled: true<br/>                 Storage: consul (HA available)<br/>                 Version: Vault v1.1.3<br/>             Version Sha: 9bc820f700f83a7c4bcab54c5323735a581b34eb</span><span id="3120" class="ko kp it ml b gy nc mq l mr ms">==&gt; Vault server started! Log data will stream in below:</span><span id="6b23" class="ko kp it ml b gy nc mq l mr ms">2019-07-03T04:38:10.435Z [INFO]  core: stored unseal keys supported, attempting fetch<br/>2019-07-03T04:38:10.466Z [INFO]  core: vault is unsealed<br/>2019-07-03T04:38:10.466Z [INFO]  core.cluster-listener: starting listener: listener_address=[::]:8201<br/>2019-07-03T04:38:10.466Z [INFO]  core.cluster-listener: serving cluster requests: cluster_listen_address=[::]:8201<br/>2019-07-03T04:38:10.466Z [INFO]  core: entering standby mode<br/>2019-07-03T04:38:10.469Z [INFO]  core: unsealed with stored keys: stored_keys_used=1</span></pre><h2 id="86e2" class="ko kp it bd kq kr ks dn kt ku kv dp kw kb kx ky kz kf la lb lc kj ld le lf lg bi translated">自动解封令牌刷新</h2><p id="feb0" class="pw-post-body-paragraph jq jr it js b jt lh jv jw jx li jz ka kb lj kd ke kf lk kh ki kj ll kl km kn im bi translated">一个月后，我发现自动解封无法工作。尝试从另一个保险库解封时，得到“403许可被拒绝”。</p><p id="6029" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是因为我们依赖带有“自动解封”策略的令牌来完成工作。记住上面的步骤:</p><pre class="lp lq lr ls gt mk ml mm mn aw mo bi"><span id="88e6" class="ko kp it ml b gy mp mq l mr ms"># create a token with the policy, it's wrapped in wrapping_token<br/>$ vault token create -policy="autounseal" -wrap-ttl=120<br/>Key                              Value<br/>---                              -----<br/>wrapping_token:                  s.AO55UYmKpT4TmPVn2AZ0UkNT<br/>wrapping_accessor:               7N3PtIwhuAtjJZ2GvA9RM0iV<br/>wrapping_token_ttl:              2m<br/>wrapping_token_creation_time:    2019-06-25 19:24:46.345501602 +0000 UTC<br/>wrapping_token_creation_path:    auth/token/create<br/>wrapped_accessor:                B8kWfoLfXYOAxFI2P2TIduaI</span><span id="e8c8" class="ko kp it ml b gy nc mq l mr ms"># get the token from wrapping_token<br/># as previous command shows, the wrapping_token is only valid for 120 seconds<br/>$ VAULT_TOKEN="s.AO55UYmKpT4TmPVn2AZ0UkNT" vault unwrap<br/>Key                  Value<br/>---                  -----<br/>token                <strong class="ml iu">s.LvLFn4InVdIorAFS5E9j6xd3</strong><br/>token_accessor       KST0fJN4xMd2Yaztrmya8SNx<br/>token_duration       <strong class="ml iu">768h</strong><br/>token_renewable      true<br/>token_policies       ["autounseal" "default"]<br/>identity_policies    []<br/>policies             ["autounseal" "default"]</span><span id="ab6b" class="ko kp it ml b gy nc mq l mr ms"># this is the token to be used in next step<br/>token                s.LvLFn4InVdIorAFS5E9j6xd3</span></pre><p id="5340" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">进行自动解封的令牌将在768小时后过期，例如32天。由于我们使用config map(vault _ auto启封. json)中的令牌，令牌过期后无法访问remote。</p><p id="d696" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在“vault _启封. json”中，即使“disable_renewal”被定义为“false”，令牌仍然过期。我的理解是，如果令牌在32天内完全未使用，则不会发生“续订”，例如，在该时间段内，不会发生“自动解封”。</p><pre class="lp lq lr ls gt mk ml mm mn aw mo bi"><span id="5075" class="ko kp it ml b gy mp mq l mr ms">"seal": {<br/>    "transit": {<br/>      "address": "<a class="ae lm" href="https://vault.vault-unlock.svc.cluster.local:8200" rel="noopener ugc nofollow" target="_blank">https://vault.vault-unlock.svc.cluster.local:8200</a>",<br/>      "token": "this_is_token_to_access_vault-unlock",<br/>      "disable_renewal":"false",</span></pre><p id="435b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要解决这个问题，可能有几种方法</p><ul class=""><li id="bbfd" class="mt mu it js b jt ju jx jy kb nx kf ny kj nz kn my mz na nb bi translated">扩展令牌的TTL</li><li id="4efa" class="mt mu it js b jt od jx oe kb of kf og kj oh kn my mz na nb bi translated">定期续订令牌</li><li id="cbc5" class="mt mu it js b jt od jx oe kb of kf og kj oh kn my mz na nb bi translated">定期重新生成令牌并更新配置图</li></ul><h2 id="496a" class="ko kp it bd kq kr ks dn kt ku kv dp kw kb kx ky kz kf la lb lc kj ld le lf lg bi translated">摘要</h2><p id="48b5" class="pw-post-body-paragraph jq jr it js b jt lh jv jw jx li jz ka kb lj kd ke kf lk kh ki kj ll kl km kn im bi translated">在本文中，我描述了创建高可用性Vault service的方法。为了实现这个目标，我设置了两个Vault集群来实现相互自动解封。其中一个是向外部用户提供保险库服务，另一个是专门做“解锁”工作。为了避免在极端情况下可能发生的死锁，第三个存储库集群充当“解锁”存储库的备份。</p><p id="fcbc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所有源代码在<a class="ae lm" href="https://github.com/liejuntao001/vault-mutual-auto-unseal" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu"> <em class="ln"> github </em> </strong> </a>共享。</p><h2 id="fcf2" class="ko kp it bd kq kr ks dn kt ku kv dp kw kb kx ky kz kf la lb lc kj ld le lf lg bi translated">感谢阅读。</h2><h2 id="c919" class="ko kp it bd kq kr ks dn kt ku kv dp kw kb kx ky kz kf la lb lc kj ld le lf lg bi translated">参考:</h2><p id="31e2" class="pw-post-body-paragraph jq jr it js b jt lh jv jw jx li jz ka kb lj kd ke kf lk kh ki kj ll kl km kn im bi translated"><a class="ae lm" href="https://learn.hashicorp.com/vault/operations/autounseal-transit" rel="noopener ugc nofollow" target="_blank">使用传输机密引擎自动解封</a></p><p id="58c0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><a class="ae lm" href="https://www.vaultproject.io/docs/configuration/seal/transit.html" rel="noopener ugc nofollow" target="_blank">运输密封配置</a></p><p id="72b9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><a class="ae lm" href="https://www.vaultproject.io/docs/configuration/index.html" rel="noopener ugc nofollow" target="_blank"> vault服务器配置</a></p><p id="0e05" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><a class="ae lm" href="https://www.vaultproject.io/docs/configuration/listener/tcp.html" rel="noopener ugc nofollow" target="_blank"> tcp监听器配置</a></p><blockquote class="me mf mg"><p id="eda5" class="jq jr ln js b jt ju jv jw jx jy jz ka mh kc kd ke mi kg kh ki mj kk kl km kn im bi translated"><strong class="js iu">2020年1月31日更新</strong></p></blockquote><p id="fa6a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">感谢大家的掌声和回应。我想添加更多关于死锁的细节，关于导致死锁的可能场景和摆脱死锁的方法。</p><p id="9498" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">相互自动解封背后的想法是，如果我们在两个Vault集群中至少有一个解封的Vault实例，则两个Vault集群都可以恢复到完全解封的状态。</p><p id="a84d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果没有未密封的实例，死锁将100%确定发生。</p><p id="f504" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">到目前为止，我已经看到了这些导致死锁的场景:</strong></p><ul class=""><li id="3202" class="mt mu it js b jt ju jx jy kb nx kf ny kj nz kn my mz na nb bi translated">Kubernetes集群下降</li></ul><p id="2eea" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在单个主Kubernetes集群中，重新启动主主机会导致Vault集群完全密封。</p><p id="f118" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">解决方案:如果vault和vault-unlock都在同一个Kubernetes集群中，请对多个主服务器使用HA Kubernetes。或者，将vault和vault-lock放在单独的Kubernetes集群中。避免同时在两个Kubernetes集群上进行危险的操作。</p><ul class=""><li id="2360" class="mt mu it js b jt ju jx jy kb nx kf ny kj nz kn my mz na nb bi translated">领事集群被摧毁</li></ul><p id="305b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">由于意外或任何原因，当执政官集群关闭时，依赖它的金库也关闭。</p><p id="65a8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">解决方案:对保险库和保险库解锁使用单独的Consul集群。不要使用与演示中相同的Consul集群。</p><ul class=""><li id="048a" class="mt mu it js b jt ju jx jy kb nx kf ny kj nz kn my mz na nb bi translated">领事失去了集群领导权</li></ul><p id="d4a3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于几秒钟内失去领导权，有些人是可以容忍的。我不确定它有多长。</p><p id="271d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">解决方案:使Consul集群高度可用。在这里阅读我的文章<a class="ae lm" href="https://medium.com/swlh/consul-in-kubernetes-pushing-to-production-223506bbe8db" rel="noopener">。</a></p><ul class=""><li id="c9e5" class="mt mu it js b jt ju jx jy kb nx kf ny kj nz kn my mz na nb bi translated">服务于保险库/领事的主机同时停机</li></ul><p id="7922" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">可能有很多原因。我曾经使用Terraform来调整主机的大小，但它们同时关闭了…</p><p id="8057" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">解决方案:这取决于基础设施。尝试所有方法来避免主机同时停机。</p><p id="4f32" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这些解决方案对于避免死锁和实现高可用性保险存储服务都很重要。</p><p id="6abe" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">在死锁的情况下，是否可以使用替代的解封方法？</strong></p><p id="284d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">启封的过程是使用各种方法向保险库提供主密钥。保管库需要主密钥来恢复其加密密钥。然后使用加密密钥解密其数据。</p><p id="a260" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">提供主密钥的方法有:</p><ul class=""><li id="5bb1" class="mt mu it js b jt ju jx jy kb nx kf ny kj nz kn my mz na nb bi translated">“保险库操作员初始化”中的几个解封密钥。</li><li id="c06e" class="mt mu it js b jt od jx oe kb of kf og kj oh kn my mz na nb bi translated">这里列出的<a class="ae lm" href="https://www.vaultproject.io/docs/configuration/seal/index.html" rel="noopener ugc nofollow" target="_blank">的自动解封方法</a>，来自外部可信服务，或者‘中转’，来自另一个可信保险库。</li></ul><p id="a9bd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个问题其实是这样的，如果保险库集群目前使用的是解封方法A，那么在被密封的情况下，有没有可能用方法B解封？</p><p id="7712" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">从我的理解来说，这是不可能的。当然哈希公司有最终决定权。</p><p id="c698" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是因为方法A是当前提供主密钥的唯一方法，是唯一的信任根。</p><p id="5b2d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果当前的解封方法是“Vault transit ”,则加密密钥将由transit secret engine中的密钥加密。和“几把解封钥匙”总结的不是一把。</p><p id="d38a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">只有在保险库解封后，才能改变“解封方式”，如“<a class="ae lm" href="https://www.vaultproject.io/docs/concepts/seal/#seal-migration" rel="noopener ugc nofollow" target="_blank">封存迁移</a>”所示，要改变“解封方式”，命令是“保险库操作员解封-迁移”。</p><p id="0999" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我不清楚是否可以在两种自动解封方法之间更改解封方法，例如，“金库中转-&gt; HSM Pkcs11”，而不通过“金库中转-&gt;沙米尔-&gt; HSM”。如果有人感兴趣，请尝试让我知道。</p><p id="d3cc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">死锁解决方案</strong></p><p id="1c6a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以我的结论是，目前从死锁中恢复的唯一方法是使用完全相同的“解封方法”，使用完全相同的密钥。</p><p id="a45e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">除非Hashicorp提供了一种方法来导出存储在“解封方法”中的原始密钥，并允许将其提供给Vault。但这看起来是一个超级不安全的想法。</p><p id="ea4d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">或者考虑这个问题，当保险库的“解封方法A”不可能时，如何解封？</p><p id="48d2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">像在<a class="ae lm" href="https://groups.google.com/forum/#!searchin/vault-tool/lost$20kms%7Csort:date/vault-tool/-gdDm-KRlxw/b-dLs_JMBQAJ" rel="noopener ugc nofollow" target="_blank">这个讨论</a>中，如果GCP·KMS的解封钥匙丢失，如何解封金库，本案中GCP·KMS的“解封方法”在哪里？</p><p id="4888" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">和其他事情一样，解决方案是有一个备份。对于不同的提供商，备份方法可能会有所不同。</p><blockquote class="me mf mg"><p id="0305" class="jq jr ln js b jt ju jv jw jx jy jz ka mh kc kd ke mi kg kh ki mj kk kl km kn im bi translated">2020年3月8日更新</p></blockquote><p id="aae0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我想说谢谢你的反馈。一位读者提醒我通过<a class="ae lm" href="https://www.vaultproject.io/api-docs/secret/transit/#backup-key" rel="noopener ugc nofollow" target="_blank"> API </a>备份传输密钥的方法。</p><p id="34e8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我试了一下，这是备份/恢复传输密钥的方法。</p><pre class="lp lq lr ls gt mk ml mm mn aw mo bi"><span id="7c1f" class="ko kp it ml b gy mp mq l mr ms"># Create a transit key<br/>$ vault write -f transit/keys/transit_test<br/>Success! Data written to: transit/keys/transit_test</span><span id="d412" class="ko kp it ml b gy nc mq l mr ms"># Read transit key<br/>$ vault read transit/keys/transit_test<br/>Handling connection for 8200<br/>Key                       Value<br/>---                       -----<br/>allow_plaintext_backup    <strong class="ml iu">false</strong><br/>deletion_allowed          <strong class="ml iu">false</strong><br/>derived                   false<br/>exportable                <strong class="ml iu">false</strong><br/>name                      transit_test</span><span id="64d3" class="ko kp it ml b gy nc mq l mr ms"># To allow backup, change the key configuration<br/>$ vault write transit/keys/transit_test/config exportable=true<br/>$ vault write transit/keys/transit_test/config allow_plaintext_backup=true</span><span id="f299" class="ko kp it ml b gy nc mq l mr ms"># Check the config again<br/>$ vault read transit/keys/transit_test<br/>Key                       Value<br/>---                       -----<br/>allow_plaintext_backup    <strong class="ml iu">true</strong><br/>deletion_allowed          false<br/>derived                   false<br/>exportable                <strong class="ml iu">true</strong><br/>name                      transit_test</span><span id="3e23" class="ko kp it ml b gy nc mq l mr ms"># Now do backup<br/>$ vault read transit/backup/transit_test<br/>Key       Value<br/>---       -----<br/>backup    eyJwb2xpY3kiO......VeryLooooongStrinng</span><span id="f412" class="ko kp it ml b gy nc mq l mr ms"># After backup, the key has a mark as "it has been backuped"<br/>$ vault read transit/keys/transit_test<br/>Key                       Value<br/>---                       -----<br/>backup_info               map[time:2020-03-08T06:27:13.859635651Z version:1]</span><span id="9de3" class="ko kp it ml b gy nc mq l mr ms"># Do restore<br/>$ vault write transit/restore/transit_restore <a class="ae lm" href="http://twitter.com/transit_test" rel="noopener ugc nofollow" target="_blank">@transit_test</a>.json</span><span id="b9c7" class="ko kp it ml b gy nc mq l mr ms"># The restored key has a mark as "it is restored"<br/>$ vault read transit/keys/transit_restore<br/>Key                       Value<br/>---                       -----<br/>allow_plaintext_backup    true<br/>backup_info               map[time:2020-03-08T06:27:13.859635651Z version:1]<br/>deletion_allowed          false<br/>derived                   false<br/>exportable                true<br/>name                      transit_restore<br/>restore_info              map[time:2020-03-08T06:42:45.174879348Z version:1]</span></pre><p id="9a59" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我认为这可能是一种备用方法。发生死锁时，创建一个新的Vault实例，并将密钥恢复到其中。然后将“紧急解封”指向新金库，解除死锁。需要考虑的事项:</p><ul class=""><li id="8241" class="mt mu it js b jt ju jx jy kb nx kf ny kj nz kn my mz na nb bi translated">为了备份，我们必须修改密钥的配置“exportable”和“allow_plaintext_backup”。一旦设置为真，就不能再设置为假。并且恢复的密钥继承了这些配置，这两个配置更改的安全含义是什么？</li><li id="5e15" class="mt mu it js b jt od jx oe kb of kf og kj oh kn my mz na nb bi translated">如何保护备份密钥值？如果备份被泄露，会有什么安全隐患？</li></ul><p id="2560" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我目前没有答案。</p><blockquote class="me mf mg"><p id="9a09" class="jq jr ln js b jt ju jv jw jx jy jz ka mh kc kd ke mi kg kh ki mj kk kl km kn im bi translated">2021年3月24日更新</p></blockquote><p id="4b05" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我要报告的是，这个解决方案在生产Kubernetes集群中已经被证明非常稳定。在过去的1年多时间里，死锁从未发生。我每隔几周就进行一次常规的集群重启(这里描述了<a class="ae lm" href="https://liejuntao001.medium.com/how-to-reboot-highly-available-kubernetes-cluster-5a9df4daecf" rel="noopener"/>)。对于每个重新启动周期，外部监视器工具可以检测到0(大部分)到1个存储区错误。</p></div></div>    
</body>
</html>