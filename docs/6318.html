<html>
<head>
<title>Simplify catching uncaughtException, unhandledRejection, and multipleResolves in Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">简化捕捉Node.js中的uncaughtException、unhandledRejection和multipleResolves</h1>
<blockquote>原文：<a href="https://itnext.io/simplify-catching-uncaughtexception-unhandledrejection-and-multipleresolves-in-node-js-a02f3fa74e8e?source=collection_archive---------0-----------------------#2021-10-16">https://itnext.io/simplify-catching-uncaughtexception-unhandledrejection-and-multipleresolves-in-node-js-a02f3fa74e8e?source=collection_archive---------0-----------------------#2021-10-16</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><p id="fbbf" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">您看不到的错误会腐蚀应用程序内部，可能会导致将来的麻烦</p><figure class="kq kr ks kt gu ku gi gj paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gi gj kp"><img src="../Images/3de3adabcd58b45d77af447d2f8e7e94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ZTi7P4L6k4onuMX2.jpg"/></div></div><figcaption class="lb lc gk gi gj ld le bd b be z dk translated">作者图片</figcaption></figure><p id="47fe" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated"><strong class="jt iv">当Node.js增加了本地承诺和异步/等待支持时，<em class="lf">进程</em>对象获得了一些错误事件，通知程序关于未处理或未捕获的错误情况。处理这样的错误很重要，但是当然我们有时会忽略为每一种可能的错误情况设置错误处理程序。这些事件处理程序的主要目的是让我们知道我们未能捕捉到的程序错误。Node.js提供了缺省的错误处理程序，但还有些不足。<em class="lf">记录流程错误</em>有助于解决这些问题。</strong></p><p id="b811" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">如果一棵树在森林里倒下了，但是没有人在旁边听到，真的有声音吗？是的，当然有声音，有鸟和其他动物听到它，但没有人在那里记录事件。同样，如果Node.js程序生成了一个错误，但是程序中没有任何东西可以捕捉或处理该错误，那么错误通知就不会出现。因为负责的人没有得到通知，这个人就不能纠正代码，应用程序中就潜伏着危险。</p><p id="a56f" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">在Node.js中有几个由<code class="fe lg lh li lj b">process</code>对象生成的事件，用于通知程序没有处理的错误。任何未处理的异常，任何未处理的承诺拒绝，或任何其他未处理的错误，都意味着错误处理代码在某个地方丢失了。为了捕捉未处理的异常或未处理的承诺拒绝，编码人员需要知道在<code class="fe lg lh li lj b">process</code>对象上添加相应的事件处理程序。更复杂的是，未处理的错误可能会悄无声息地消失在以太中，让编码人员对程序中潜伏的问题一无所知。</p><p id="ce10" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">未处理错误的当前事件列表包括:</p><figure class="kq kr ks kt gu ku gi gj paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gi gj lk"><img src="../Images/fd89e896afe9805fafab7fdae13e1fc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LVHxLiSJJoEfx3DvSn5Gqw.png"/></div></div><figcaption class="lb lc gk gi gj ld le bd b be z dk translated">作者图片</figcaption></figure><p id="8a38" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">对于其中的每一个，我们可以参考Node.js <code class="fe lg lh li lj b">process</code>包文档，了解通知API，并编写如下的处理函数:</p><pre class="kq kr ks kt gu ll lj lm ln aw lo bi"><span id="94ec" class="lp lq iu lj b gz lr ls l lt lu">process.on('unhandledRejection', (reason, promise) =&gt; {<br/> <!-- --> // .. handle the error<br/>});</span></pre><p id="acb9" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">但是，我们总是记得这样做吗？我们总是记得捕捉每一个错误吗？当一个新的Node.js版本添加了一个新的未处理的错误事件时，我们还记得在程序中添加处理程序吗？</p><p id="74ef" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">一个解决方案是使用安装每个错误处理程序的包。自己需要写一个也没那么难。但是在npm资源库中有一个预烘焙包值得您关注:<a class="ae lv" href="https://www.npmjs.com/package/log-process-errors" rel="noopener ugc nofollow" target="_blank"> log-process-errors </a></p><p id="f103" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">其特点包括:</p><ul class=""><li id="2905" class="lw lx iu jt b ju jv jy jz kc ly kg lz kk ma ko mb mc md me bi translated">处理所有这样的错误条件——如果添加了新的错误条件，这个包肯定也会被更新以处理它们</li><li id="d5e6" class="lw lx iu jt b ju mf jy mg kc mh kg mi kk mj ko mb mc md me bi translated">一个API，您可以使用它将信息定向到日志服务</li><li id="d4ca" class="lw lx iu jt b ju mf jy mg kc mh kg mi kk mj ko mb mc md me bi translated">自定义错误指示的处理方式</li><li id="6c34" class="lw lx iu jt b ju mf jy mg kc mh kg mi kk mj ko mb mc md me bi translated">漂亮的印刷错误使他们更容易阅读和看到</li><li id="08ba" class="lw lx iu jt b ju mf jy mg kc mh kg mi kk mj ko mb mc md me bi translated">包括通常不打印错误的堆栈跟踪</li></ul><p id="57ef" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">这是一个相对容易安装和使用的软件包。唯一的疑虑是随之而来的支持包的数量，以及在<code class="fe lg lh li lj b">node_modules</code>中产生的足迹。</p><h1 id="e4b0" class="mk lq iu bd ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng bi translated">设置Node.js项目以使用<code class="fe lg lh li lj b">log-process-errors</code></h1><p id="d0a2" class="pw-post-body-paragraph jr js iu jt b ju nh jw jx jy ni ka kb kc nj ke kf kg nk ki kj kk nl km kn ko in bi translated">对于这个例子，让我们创建一个空白项目并编写几个简单的脚本。</p><p id="005e" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">这会生成一个简单的带有所有默认值的<code class="fe lg lh li lj b">package.json</code>。</p><pre class="kq kr ks kt gu ll lj lm ln aw lo bi"><span id="a622" class="lp lq iu lj b gz lr ls l lt lu">$ npm install log-process-errors --save<br/>npm notice created a lockfile as package-lock.json. You should commit this file.<br/>npm WARN capture-errors@1.0 .0 No description<br/>npm WARN capture-errors@1.0 .0 No repository field. </span><span id="1416" class="lp lq iu lj b gz nm ls l lt lu">+ log-process-errors@7.0 .1 added 34 packages from 64 contributors and audited 34 packages in 9.871s </span><span id="30e1" class="lp lq iu lj b gz nm ls l lt lu">7 packages are looking for funding <br/>run `npm fund` for details </span><span id="a632" class="lp lq iu lj b gz nm ls l lt lu">found 0 vulnerabilities</span></pre><p id="8f57" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">这将安装软件包。请注意，它添加了34个附属包。</p><h1 id="3292" class="mk lq iu bd ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng bi translated">简单示例—未捕获的异常</h1><p id="f819" class="pw-post-body-paragraph jr js iu jt b ju nh jw jx jy ni ka kb kc nj ke kf kg nk ki kj kk nl km kn ko in bi translated">让我们从最简单的开始，一个未被捕获的异常。在这种情况下，您的代码会抛出一个错误，并且有一条路径可以让该异常到达事件循环。沿着这条路径的某个地方，您的代码应该已经捕获了异常，但是它没有。</p><p id="62b1" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">我们来试试一个超简单的例子。创建一个名为<code class="fe lg lh li lj b">ex1.mjs</code>的文件，其中包含:</p><pre class="kq kr ks kt gu ll lj lm ln aw lo bi"><span id="7c57" class="lp lq iu lj b gz lr ls l lt lu">import logProcessErrors from 'log-process-errors' logProcessErrors({});</span><span id="6fcd" class="lp lq iu lj b gz nm ls l lt lu">throw new Error('Something bad happened');</span></pre><p id="38ee" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">重要的是要知道<code class="fe lg lh li lj b">log-process-errors</code>只出口一个ES6模块。我们的例子将被写成ES6模块。要了解如何从CommonJS模块中使用ES6模块，请参见:<a class="ae lv" href="https://techsparx.com/nodejs/esnext/esmodules-from-commonjs.html" rel="noopener ugc nofollow" target="_blank">在Node.js CommonJS模块中加载ES6模块</a></p><p id="2300" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">说完这些，让我们来检查一下代码。</p><p id="dc60" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated"><code class="fe lg lh li lj b">logProcessErrors</code>功能设置<code class="fe lg lh li lj b">log-process-errors</code>模块。它需要一个<em class="lf">选项</em>对象，我们可以用它来定制行为。现在让我们保留默认值。</p><p id="b424" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">要生成一个未捕获的异常，我们只需抛出一个。运行程序我们得到这个:</p><figure class="kq kr ks kt gu ku gi gj paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gi gj nn"><img src="../Images/4da68ae73689b47036ba8a260d7cb962.png" data-original-src="https://miro.medium.com/v2/resize:fit:1352/format:webp/0*GJkmbLDQsr0k2DU3.jpg"/></div></div><figcaption class="lb lc gk gi gj ld le bd b be z dk translated">作者图片</figcaption></figure><p id="cb8c" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">我们有一个错误，有用的堆栈跟踪，和颜色。这看起来比默认的错误消息要好。为了便于比较，创建另一个名为<code class="fe lg lh li lj b">ex2.mjs</code>的文件，其中只包含<code class="fe lg lh li lj b">throw new Exception</code>语句。运行它，我们得到这个:</p><figure class="kq kr ks kt gu ku gi gj paragraph-image"><div class="gi gj no"><img src="../Images/b74f2933bb5708f56300ba0fef2c5305.png" data-original-src="https://miro.medium.com/v2/resize:fit:1354/format:webp/0*MGmmM3N-Xky3Wi1-.jpg"/></div><figcaption class="lb lc gk gi gj ld le bd b be z dk translated">作者图片</figcaption></figure><p id="8cbb" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">这在很大程度上是相同的错误，尽管我发现自己对它为什么显示语法感到困惑。但是最大的问题是，如果您的应用程序打印大量输出，您更可能看到这些消息中的哪一个？默认的错误消息会淹没在其他通知的海洋中吗？改进的彩色错误会突出来并被看到吗？</p><p id="c694" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">如果这个例子过于琐碎，请尝试另一个可以命名为<code class="fe lg lh li lj b">fs1.mjs</code>的例子:</p><pre class="kq kr ks kt gu ll lj lm ln aw lo bi"><span id="9da4" class="lp lq iu lj b gz lr ls l lt lu">import fs from 'fs/promises'; <br/>import logProcessErrors from 'log-process-errors' </span><span id="82f6" class="lp lq iu lj b gz nm ls l lt lu">logProcessErrors({});</span><span id="5e0b" class="lp lq iu lj b gz nm ls l lt lu">await fs.unlink('unknown-file.txt');</span></pre><p id="154e" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">Node.js现在支持在ES6模块中顶级使用<code class="fe lg lh li lj b">await</code>关键字:<a class="ae lv" href="https://techsparx.com/nodejs/async/top-level-async.html" rel="noopener ugc nofollow" target="_blank"> Node.js脚本编写者:顶级异步/等待现在可用</a>因此，ES6模块是编写简单脚本的首选，因为您可以自由使用<code class="fe lg lh li lj b">await</code>来处理异步。</p><p id="3d85" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">无论如何，只要该文件不存在，<code class="fe lg lh li lj b">fs.unlink</code>调用就会抛出异常。</p><figure class="kq kr ks kt gu ku gi gj paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gi gj np"><img src="../Images/3974a08331a099e9aae57673ebb7bcf6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*qn3RBiZcn70qT6KY.jpg"/></div></div><figcaption class="lb lc gk gi gj ld le bd b be z dk translated">作者图片</figcaption></figure><p id="b284" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">非常好。不清楚为什么没有堆栈跟踪。</p><h1 id="b96a" class="mk lq iu bd ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng bi translated">未处理的承诺拒绝</h1><p id="b1a2" class="pw-post-body-paragraph jr js iu jt b ju nh jw jx jy ni ka kb kc nj ke kf kg nk ki kj kk nl km kn ko in bi translated">下一个场景是关于如果一个承诺被拒绝会发生什么，但是没有什么能捕捉到拒绝。那就好比申请工作，被那家公司拒绝，然后看不到拒绝通知。</p><p id="338d" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">当我们生成一个承诺时，<code class="fe lg lh li lj b">async/await</code>的存在有些模糊，因为它们现在在<code class="fe lg lh li lj b">await</code>关键字中被自动处理。让我们从一个明确的承诺开始，创建一个名为<code class="fe lg lh li lj b">unhandled.mjs</code>的文件:</p><pre class="kq kr ks kt gu ll lj lm ln aw lo bi"><span id="3aab" class="lp lq iu lj b gz lr ls l lt lu">import logProcessErrors from 'log-process-errors'<br/>logProcessErrors({});</span><span id="b5ed" class="lp lq iu lj b gz nm ls l lt lu">const promise = Promise.reject(new Error('Something bad happened'));</span></pre><p id="f71e" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">这明确地创建了一个处于<em class="lf">拒绝</em>状态的承诺。更常见的模式是:</p><pre class="kq kr ks kt gu ll lj lm ln aw lo bi"><span id="2452" class="lp lq iu lj b gz lr ls l lt lu">const promise = new Promise((resolve, reject) =&gt; {<br/>     // .. do something<br/>     // .. upon detecting an error:<br/>     if (errorCaught) reject(new Error('Something bad hapened'));<br/>});</span></pre><p id="7aa8" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">无论如何，让我们运行<code class="fe lg lh li lj b">unhandled.mjs</code>示例:</p><figure class="kq kr ks kt gu ku gi gj paragraph-image"><div class="gi gj nq"><img src="../Images/1ff13234c98c2f9c33eb95e13e478add.png" data-original-src="https://miro.medium.com/v2/resize:fit:1388/format:webp/0*8Rx8eJNIbclwWLg9.jpg"/></div><figcaption class="lb lc gk gi gj ld le bd b be z dk translated">作者图片</figcaption></figure><p id="e35b" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">我们得到了<code class="fe lg lh li lj b">unhandledRejection</code>错误。如果我们加上<code class="fe lg lh li lj b">await Promise.reject</code>，那么它就变成了一个<code class="fe lg lh li lj b">uncaughtException</code>错误。如果我们取消对<code class="fe lg lh li lj b">promise.catch</code>的注释，错误会悄悄地消失。</p><p id="703e" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">但是，这是人为的，所以让我们尝试一些更真实的东西。假设您忘记了<code class="fe lg lh li lj b">fs1</code>示例中的<code class="fe lg lh li lj b">await</code>关键字？创建包含此内容的<code class="fe lg lh li lj b">fs2.mjs</code>:</p><pre class="kq kr ks kt gu ll lj lm ln aw lo bi"><span id="f7ae" class="lp lq iu lj b gz lr ls l lt lu">import fs from 'fs/promises'; <br/>import logProcessErrors from 'log-process-errors' <br/>logProcessErrors({});</span><span id="f72c" class="lp lq iu lj b gz nm ls l lt lu">fs.unlink('unknown-file.txt');</span></pre><p id="2a4b" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">因为<code class="fe lg lh li lj b">fs.unlink</code>在这种情况下返回一个承诺，所以我们需要处理承诺来查看状态。在最初的例子中，<code class="fe lg lh li lj b">await</code>关键字就是这么做的。我们知道这会导致拒绝，所以让我们看看会发生什么:</p><figure class="kq kr ks kt gu ku gi gj paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gi gj nr"><img src="../Images/e6c05b05b9f4664b0596040809dcc424.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*1uituoJIHFPyQFcf.jpg"/></div></div><figcaption class="lb lc gk gi gj ld le bd b be z dk translated">作者图片</figcaption></figure><p id="eedc" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">对于<code class="fe lg lh li lj b">fs1</code>,我们得到<code class="fe lg lh li lj b">uncaughtException</code>,因为<code class="fe lg lh li lj b">await</code>关键字捕获了被拒绝的承诺。有了<code class="fe lg lh li lj b">fs2</code>，我们反而得到了<code class="fe lg lh li lj b">uncaughtRejection</code>，因为我们忘记了等待承诺。</p><h1 id="93b3" class="mk lq iu bd ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng bi translated">多重承诺解决方案</h1><p id="0885" class="pw-post-body-paragraph jr js iu jt b ju nh jw jx jy ni ka kb kc nj ke kf kg nk ki kj kk nl km kn ko in bi translated">下一个错误有点难以理解，但它归结为一个Promise对象，其中<code class="fe lg lh li lj b">resolve</code>或<code class="fe lg lh li lj b">reject</code>回调被调用了不止一次。规则是每个承诺对象最多调用<code class="fe lg lh li lj b">resolve</code>或<code class="fe lg lh li lj b">reject</code>一次，多次调用都是错误的。确切地说，<code class="fe lg lh li lj b">multipleResolves</code>是在什么时候发出的:</p><ul class=""><li id="78ae" class="lw lx iu jt b ju jv jy jz kc ly kg lz kk ma ko mb mc md me bi translated">解决了不止一次。</li><li id="8356" class="lw lx iu jt b ju mf jy mg kc mh kg mi kk mj ko mb mc md me bi translated">不止一次被拒。</li><li id="fdcf" class="lw lx iu jt b ju mf jy mg kc mh kg mi kk mj ko mb mc md me bi translated">解决后拒绝。</li><li id="522c" class="lw lx iu jt b ju mf jy mg kc mh kg mi kk mj ko mb mc md me bi translated">拒绝后解决。</li></ul><p id="596d" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">创建一个名为<code class="fe lg lh li lj b">multi-resolve.mjs</code>的文件，其中包含:</p><pre class="kq kr ks kt gu ll lj lm ln aw lo bi"><span id="d2ae" class="lp lq iu lj b gz lr ls l lt lu">import logProcessErrors from 'log-process-errors'<br/>logProcessErrors({});</span><span id="49ca" class="lp lq iu lj b gz nm ls l lt lu">await new Promise((resolve, reject) =&gt; {<br/>    resolve();<br/>    reject(new Error('Something bad happened')); <br/>});</span></pre><p id="c10b" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">这是人为的，所以让我们考虑一下这在现实生活中是如何发生的。由承诺包装的回调函数的一个典型错误是不能正确地确保<code class="fe lg lh li lj b">resolve</code>和/或<code class="fe lg lh li lj b">reject</code>只被调用一次。尝试将<code class="fe lg lh li lj b">multi-resolve.mjs</code>的结尾改为:</p><pre class="kq kr ks kt gu ll lj lm ln aw lo bi"><span id="6258" class="lp lq iu lj b gz lr ls l lt lu">import fs from 'fs';<br/>...</span><span id="2bc2" class="lp lq iu lj b gz nm ls l lt lu">/* await new Promise((resolve, reject) =&gt; {<br/>     resolve();<br/>     reject(new Error('Something bad happened'));<br/>});<br/>*/</span><span id="f3f7" class="lp lq iu lj b gz nm ls l lt lu">await new Promise((resolve, reject) =&gt; {<br/>     fs.unlink('does-not-exist.txt', err =&gt; {<br/>         if (err) reject(err);<br/>         resolve();<br/>     });<br/>});</span></pre><p id="a2bb" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">在本例中，我们导入了<code class="fe lg lh li lj b">fs</code>包的非承诺版本。这意味着我们有一个回调函数要处理，为了使用关键字<code class="fe lg lh li lj b">await</code>我们需要生成一个承诺作为包装器，如下所示。因此...按照编写的代码，如果有错误会发生什么？<code class="fe lg lh li lj b">reject</code>和<code class="fe lg lh li lj b">resolve</code>不是都被调用了吗？</p><figure class="kq kr ks kt gu ku gi gj paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gi gj nr"><img src="../Images/b4d04cd58e3417edba8c8bb575aa6e2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*xViJQiqMtMZ9igWK.jpg"/></div></div><figcaption class="lb lc gk gi gj ld le bd b be z dk translated">作者图片</figcaption></figure><p id="4736" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">事实上，我们得到的警告是，应许既被拒绝，又被解决。我们还得到一个<code class="fe lg lh li lj b">uncaughtException</code>,因为这个代码不处理上面讨论的错误。</p><p id="4f82" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">显然，最好将该包装器编写为:</p><pre class="kq kr ks kt gu ll lj lm ln aw lo bi"><span id="eb36" class="lp lq iu lj b gz lr ls l lt lu">await new Promise((resolve, reject) =&gt; {<br/>     fs.unlink('does-not-exist.txt', err =&gt; {<br/>         if (err) {<br/>             reject(err);<br/>         } else {<br/>             resolve();<br/>         }<br/>     });<br/>});</span></pre><p id="6f7c" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">但第一个是容易犯的错误。而且，无论如何，<code class="fe lg lh li lj b">async/await</code>实现要干净无数倍，所以建议尽可能使用它。</p><h1 id="1fce" class="mk lq iu bd ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng bi translated">回调中未捕获的错误</h1><p id="cf41" class="pw-post-body-paragraph jr js iu jt b ju nh jw jx jy ni ka kb kc nj ke kf kg nk ki kj kk nl km kn ko in bi translated">最后要讨论的问题不是由<code class="fe lg lh li lj b">process</code>对象发出的错误事件。相反，这是发生在我的应用程序中的一个场景，它促使我对此进行研究。我在一个事件处理程序中遇到了一个错误情况，我对此一无所知。</p><p id="fabc" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">看一个例子，创建一个名为<code class="fe lg lh li lj b">event-handler.mjs</code>的文件，包含:</p><pre class="kq kr ks kt gu ll lj lm ln aw lo bi"><span id="1009" class="lp lq iu lj b gz lr ls l lt lu">import EventEmitter from 'events';<br/>import logProcessErrors from 'log-process-errors'</span><span id="82cb" class="lp lq iu lj b gz nm ls l lt lu">logProcessErrors({});</span><span id="6f9b" class="lp lq iu lj b gz nm ls l lt lu">const emitter = new EventEmitter();<br/>emitter.on('crash', () =&gt; {<br/>   throw new Error('Something bad happened');<br/>});</span><span id="1408" class="lp lq iu lj b gz nm ls l lt lu">emitter.emit('crash');</span></pre><p id="c759" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">Node.js平台中的许多对象都使用了<code class="fe lg lh li lj b">EventEmitter</code>类。例如，HTTPServer和HTTPClient是EventEmitter的。API说使用<code class="fe lg lh li lj b">.on('event-name'...)</code>来监听事件，然后在实现内部<code class="fe lg lh li lj b">.emit('event-name')</code>触发事件。但是EventEmitter的一个很大的缺点是事件的发起者没有收到任何关于事件处理程序是成功还是失败或者是否完成的通知。</p><p id="f7ac" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">在我的应用程序中，我必须捕捉错误，并创建一种机制，以一种有用的方式暴露错误。但是第一步是知道错误正在发生。</p><p id="1cf6" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">在本例中，我们创建了一个虚拟的<code class="fe lg lh li lj b">EventEmitter</code>，并为一个<code class="fe lg lh li lj b">crash</code>事件定义了一个处理程序。在处理程序内部，我们生成一个异常。这模拟了事件处理程序中发生错误的情况。</p><figure class="kq kr ks kt gu ku gi gj paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gi gj ns"><img src="../Images/9d9d51d469bb561a6bdf4f29b5ba1958.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*xtrW_A79Q0hHl8PK.jpg"/></div></div><figcaption class="lb lc gk gi gj ld le bd b be z dk translated">作者图片</figcaption></figure><p id="ac1c" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">好了，错误被发现了。</p><h1 id="0550" class="mk lq iu bd ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng bi translated"><code class="fe lg lh li lj b">log-process-errors</code>的选项对象</h1><p id="3418" class="pw-post-body-paragraph jr js iu jt b ju nh jw jx jy ni ka kb kc nj ke kf kg nk ki kj kk nl km kn ko in bi translated">这个包使用一个选项对象来定制它的行为。</p><p id="14c7" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">对于到目前为止的每个例子，我们都使用了一个空对象。<code class="fe lg lh li lj b">log-process-errors</code>选项对象让我们:</p><ul class=""><li id="0ea7" class="lw lx iu jt b ju jv jy jz kc ly kg lz kk ma ko mb mc md me bi translated">指定一个函数来处理日志记录</li><li id="15c1" class="lw lx iu jt b ju mf jy mg kc mh kg mi kk mj ko mb mc md me bi translated">指定每种事件的日志记录级别</li><li id="381c" class="lw lx iu jt b ju mf jy mg kc mh kg mi kk mj ko mb mc md me bi translated">指定在出现某种错误时是否退出</li><li id="1f69" class="lw lx iu jt b ju mf jy mg kc mh kg mi kk mj ko mb mc md me bi translated">指定在某些类型的错误上失败，用于测试工具目的</li><li id="7841" class="lw lx iu jt b ju mf jy mg kc mh kg mi kk mj ko mb mc md me bi translated">指定是否在输出中使用颜色</li></ul><p id="33ac" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">要尝试这样做，将<code class="fe lg lh li lj b">multi-resolve.mjs</code>复制为<code class="fe lg lh li lj b">options.mjs</code>，并进行如下更改:</p><pre class="kq kr ks kt gu ll lj lm ln aw lo bi"><span id="6bd2" class="lp lq iu lj b gz lr ls l lt lu">logProcessErrors({<br/>     log: function(error, level, originalError) {<br/>         console.error(`ERROR ${level}  `, originalError, error);<br/>     },<br/>     level: {<br/>        warning: 'warn', multipleResolves: 'info', default: 'error'<br/>     },<br/>     colors: false<br/>});</span></pre><p id="dc10" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">其他一切保持原样，因为我们有兴趣尝试不同的选项。</p><p id="8df4" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">我们在实际应用程序中使用的<code class="fe lg lh li lj b">log</code>函数会将信息发送给日志服务。但是，这个函数让我们检查可记录事件提供的数据，即<em class="lf">记录级别</em>、初始<em class="lf">错误和生成的错误。</em></p><p id="7cf2" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated"><code class="fe lg lh li lj b">level</code>选项让我们描述用于特定种类错误的日志记录级别。</p><p id="4903" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated"><code class="fe lg lh li lj b">colors</code>选项表示是否在输出中使用颜色。您可能正在记录一个颜色没有意义的文件。</p><figure class="kq kr ks kt gu ku gi gj paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gi gj nt"><img src="../Images/caf54dc5ff0edde4bff193c9273ed03f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*67GyEFTc-ATNjo7P.jpg"/></div></div><figcaption class="lb lc gk gi gj ld le bd b be z dk translated">作者图片</figcaption></figure><p id="bc23" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">我们看到输出的格式已经改变，例如，我们没有堆栈跟踪。也没有颜色编码。如果您更改<code class="fe lg lh li lj b">level</code>和<code class="fe lg lh li lj b">colors</code>字段中的设置，您可以改变这种情况。例如，将<code class="fe lg lh li lj b">colors</code>设置为真，然后将<code class="fe lg lh li lj b">multipleResolves</code>设置为<code class="fe lg lh li lj b">warn</code>，您会看到它被颜色编码为黄色。</p><h1 id="499c" class="mk lq iu bd ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng bi translated">摘要</h1><p id="eced" class="pw-post-body-paragraph jr js iu jt b ju nh jw jx jy ni ka kb kc nj ke kf kg nk ki kj kk nl km kn ko in bi translated"><code class="fe lg lh li lj b">log-process-errors</code>包通过自动通知我们可能会忽略的错误来帮助我们改进我们的应用程序。可能会发生没有在我们面前出现的错误，让未解决的错误在我们的应用程序中恶化。这可能就像没人听到的森林中倒下的那棵树。</p><p id="1b08" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">许多年来，没有人听说森林在哭泣，因为不再有典型的降雨。在加利福尼亚，树木的衰弱使得小蠹虫猖獗，杀死了一亿棵树。现在，加州每年都有越来越大的野火，造成大范围的破坏，并在我们的城市上空喷出大量有毒的烟雾。</p><p id="fa14" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">这种遗漏错误条件的模式不仅影响我们的应用程序，还影响我们生活的物理世界。</p></div><div class="ab cl nu nv hy nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="in io ip iq ir"><p id="4d8f" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated"><em class="lf">原载于【https://techsparx.com】<a class="ae lv" href="https://techsparx.com/nodejs/howto/error-handling.html" rel="noopener ugc nofollow" target="_blank"><em class="lf"/></a><em class="lf">。</em></em></p></div></div>    
</body>
</html>