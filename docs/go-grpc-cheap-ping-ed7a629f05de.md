# 去 gRPC 便宜乒

> 原文：<https://itnext.io/go-grpc-cheap-ping-ed7a629f05de?source=collection_archive---------5----------------------->

**简介**

在本文中，我们将使用一个廉价的 ping 应用程序来探索 gRPC，基本上我们将执行 ping 操作，并测量消息在报告给终端之前到达服务器并返回所需的时间。你可以在这里找到源代码[。](https://github.com/kainlite/grpc-ping)

**Protobuf**

您可能已经知道 gRPC 使用[协议缓冲区](https://developers.google.com/protocol-buffers/)序列化数据，我们将创建一个[一元 RPC](https://grpc.io/docs/guides/concepts/) ，如下所示。

有了这个文件，我们正在定义一个能够发送单个`PingRequest`和获得单个`PingResponse`的服务，我们有一个`Data`字段，它可以来回移动，以便通过网络发送一些字节(即使我们并不真的关心这个，但它在性能测试中可能是重要或关键的)。

**生成代码**

为了能够使用 protobuf，我们需要为我们正在编写的应用程序生成代码，在这种情况下，对于 golang，命令应该是这样的:

这将为我们提供服务的定义以及携带我们定义为消息的数据所需的结构。

**客户端**

客户端在这里完成了大部分工作，正如你所看到的，你可以提供两个参数，一个指向另一个主机:port，另一个发送你喜欢的字符串，然后它测量发送和接收消息所花费的时间，并把它打印到屏幕上，与 linux 中实际的`ping`命令类似。

**服务器**

该服务器仅仅是一个 echo 服务器，因为它会发送回你发送给它的任何东西，并记录到控制台，默认情况下，它会监听端口`50000`。

**测试它**

**常规 ping**

**客户端**

这是我们在测试终端时会看到的。正如你所看到的，初始连接花费了更多的时间，但之后的往返时间是非常一致的(当然，我们的廉价 ping 不包括错误，数据包丢失等)。

**服务器**

服务器只是回显并记录通过网络接收到的内容。

**成交单据**

正如你所看到的，gRPC 非常快，并且简化了你需要做的一切，例如，为了有一个高效的消息系统或微服务之间的通信，它也很容易为你喜欢的任何语言生成样板文件，并且有一个每个人都必须同意的公共接口。

# 正误表

如果您发现任何错误或有任何建议，请给我发消息，以便解决问题。

此外，您可以在这里查看源代码和[生成代码](https://github.com/kainlite/kainlite.github.io)和[源代码](https://github.com/kainlite/blog)的变化

*原载于*[*https://tech squad . rocks*](https://techsquad.rocks/blog/go_grpc_cheap_ping/)*。*