<html>
<head>
<title>Adding security layers to your App on OpenShift — Part 4: Dynamic secrets with Vault</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在OpenShift上向您的应用添加安全层—第4部分:使用Vault的动态秘密</h1>
<blockquote>原文：<a href="https://itnext.io/adding-security-layers-to-your-app-on-openshift-part-4-dynamic-secrets-with-vault-b5fe1fc7709b?source=collection_archive---------1-----------------------#2019-07-11">https://itnext.io/adding-security-layers-to-your-app-on-openshift-part-4-dynamic-secrets-with-vault-b5fe1fc7709b?source=collection_archive---------1-----------------------#2019-07-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="c1a6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">今天，保护你的应用程序是必须的，但是如果你没有在一开始就考虑它，那么在不修改代码的情况下引入它是很困难的。幸运的是，像<a class="ae kl" href="http://kubernetes.io" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>这样的容器和平台带来的新的云原生模式提供了简单的方法来解决安全问题，而无需接触代码。</p><p id="9094" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本系列的前一部分中，我们已经看到了如何将<a class="ae kl" href="https://www.vaultproject.io/" rel="noopener ugc nofollow" target="_blank"> Hashicorp Vault </a>轻松部署到<a class="ae kl" href="http://www.kubernetes.io" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>上，并从托管在同一平台上的<code class="fe km kn ko kp b">fruits-catalog </code>应用程序中使用。这次我们将使用一个叫做<a class="ae kl" href="https://learn.hashicorp.com/vault/getting-started/dynamic-secrets" rel="noopener ugc nofollow" target="_blank">动态秘密</a>的高级功能。根据保险库网站:</p><blockquote class="kq kr ks"><p id="64a9" class="jn jo kt jp b jq jr js jt ju jv jw jx ku jz ka kb kv kd ke kf kw kh ki kj kk ij bi translated">动态机密是短暂的，当它们被访问时以编程方式生成，并且直到它们被读取时才存在，从而降低了有人窃取它们或另一个客户端使用相同机密的风险。动态机密可以在使用后立即撤销，从而最大限度地缩短机密的生命周期。</p></blockquote><p id="0922" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将添加这个动态秘密特性来访问我们的MongoDB数据库。这一部分是前一部分的直接延续，估计你已经读过了。</p><figure class="ky kz la lb gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi kx"><img src="../Images/9fd8d4b85278bfbd66e12fc3d4129ff1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SAaJ8W2lHEDcZvTm5sbNcg.png"/></div></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk translated">第4部分—在MongoDB中使用Vault动态秘密</figcaption></figure><p id="093d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这篇文章是一个更大的系列文章的一部分，讲述了如何给现有的应用程序增加安全层。目前公布的其他部分有:</p><ul class=""><li id="f3c8" class="ln lo iq jp b jq jr ju jv jy lp kc lq kg lr kk ls lt lu lv bi translated"><a class="ae kl" href="https://medium.com/@lbroudoux/adding-security-layers-to-your-app-on-openshift-part-1-deployment-and-tls-ingress-9ef752835599" rel="noopener"> <em class="kt">第1部分—部署和TLS入口</em> </a></li><li id="0a37" class="ln lo iq jp b jq lw ju lx jy ly kc lz kg ma kk ls lt lu lv bi translated"><a class="ae kl" href="https://medium.com/@lbroudoux/adding-security-layers-to-your-app-on-openshift-part-2-8320018bcdd1" rel="noopener"> <em class="kt">第二部分——使用Keycloak的认证和授权</em> </a></li><li id="5b40" class="ln lo iq jp b jq lw ju lx jy ly kc lz kg ma kk ls lt lu lv bi translated"><a class="ae kl" href="https://medium.com/@lbroudoux/adding-security-layers-to-your-app-on-openshift-part-3-secret-management-with-vault-8efd4ec29ec4" rel="noopener"> <em class="kt">第三部分——金库的秘密管理</em> </a></li><li id="bc3f" class="ln lo iq jp b jq lw ju lx jy ly kc lz kg ma kk ls lt lu lv bi translated"><em class="kt">第四部分——带金库的动态秘密(本帖)</em></li><li id="8a71" class="ln lo iq jp b jq lw ju lx jy ly kc lz kg ma kk ls lt lu lv bi translated"><a class="ae kl" href="https://medium.com/@lbroudoux/adding-security-layers-to-your-app-on-openshift-part-5-mutual-tls-with-istio-a8800c2e4df4" rel="noopener"> <em class="kt">第5部分——与Istio </em> </a>的相互TLS</li><li id="01aa" class="ln lo iq jp b jq lw ju lx jy ly kc lz kg ma kk ls lt lu lv bi translated"><a class="ae kl" href="https://medium.com/@lbroudoux/adding-security-layers-to-your-app-on-openshift-part-6-pki-as-a-service-with-vault-and-cert-e6dbbe7028c7" rel="noopener"> <em class="kt">第6部分—使用保管库和证书管理器的PKI服务</em> </a></li></ul><h1 id="cca1" class="mb mc iq bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">我们想在这部分实现什么？</h1><p id="efa7" class="pw-post-body-paragraph jn jo iq jp b jq mz js jt ju na jw jx jy nb ka kb kc nc ke kf kg nd ki kj kk ij bi translated">因此，在这一部分中，我们将重用和重新配置已经安装的Vault实例，以便它能够在应用程序pod启动时为MongoDB生成动态机密。这里需要注意的重要一点是，将为每个pod生成一个新的不同的动态秘密！因此，如果您需要扩展您的应用程序，添加新的<code class="fe km kn ko kp b">fruits-catalog</code> pod副本，Vault将为每个实例创建新的秘密。</p><p id="b077" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是我们的应用程序架构的新模式:</p><figure class="ky kz la lb gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi ne"><img src="../Images/484bb6d02fc2202138af640e30b7937a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xWKkhqtpVNMxBEFKcUIydA.png"/></div></div></figure><p id="6e6e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个架构转换之后的新流程将向我们在本系列第3部分中开始的步骤添加新的动态秘密生成步骤。总而言之，从新应用程序盒的初始化开始:</p><ol class=""><li id="55ec" class="ln lo iq jp b jq jr ju jv jy lp kc lq kg lr kk nf lt lu lv bi translated">我们将获得一个由Kubernetes颁发的特定令牌——以及相关的证书——在启动时注入到我们的应用程序Pod中，</li><li id="70d6" class="ln lo iq jp b jq lw ju lx jy ly kc lz kg ma kk nf lt lu lv bi translated">从一个名为<code class="fe km kn ko kp b">vault-init</code>的<a class="ae kl" href="https://kubernetes.io/docs/concepts/workloads/pods/init-containers/" rel="noopener ugc nofollow" target="_blank"> Init容器</a>中，也运行在我们的Pod中，我们将使用这个特定的令牌对Vault进行身份验证调用，</li><li id="53ba" class="ln lo iq jp b jq lw ju lx jy ly kc lz kg ma kk nf lt lu lv bi translated">Vault将能够根据Kubernetes APIs检查这个调用的有效性，</li><li id="41db" class="ln lo iq jp b jq lw ju lx jy ly kc lz kg ma kk nf lt lu lv bi translated">如果成功，Vault现在将使用其内部秘密连接到MongoDB数据库，并创建一个新的用户/密码对。这一对(由租约在保险库端标识)将被发送到具有租约标识符的init容器，</li><li id="3015" class="ln lo iq jp b jq lw ju lx jy ly kc lz kg ma kk nf lt lu lv bi translated">然后，从Vault中检索到的秘密将通过一个共享文件系统提供给我们的主Spring Boot容器:一个配置文件将在<code class="fe km kn ko kp b">/deployment/config</code>上创建，租约标识符也将存储在本地。我们的主容器现在应该可以启动了，</li><li id="feeb" class="ln lo iq jp b jq lw ju lx jy ly kc lz kg ma kk nf lt lu lv bi translated">但是Vault提供的租约应该定期更新…为此我们现在有一个名为<code class="fe km kn ko kp b">vault-lease-refresher</code>的<a class="ae kl" href="https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/#understanding-pods" rel="noopener ugc nofollow" target="_blank">边车容器</a>来为我们处理这个任务…直到我们的pod死亡，</li><li id="7a87" class="ln lo iq jp b jq lw ju lx jy ly kc lz kg ma kk nf lt lu lv bi translated">当我们的pod将死亡时(由于异常或按比例缩小的决定)，由于有一个<a class="ae kl" href="https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks" rel="noopener ugc nofollow" target="_blank">预停止钩</a>，也将调用<code class="fe km kn ko kp b">vault-lease-refresher</code>。最后一次调用将负责撤销Vault端的租约，并销毁MongoDB端的用户/密码对。</li></ol><p id="a64d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">轻松点。？好吧，让我们看看如何实现这一点…</p><h1 id="13b5" class="mb mc iq bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">如何应用？</h1><p id="0946" class="pw-post-body-paragraph jn jo iq jp b jq mz js jt ju na jw jx jy nb ka kb kc nc ke kf kg nd ki kj kk ij bi translated">如果您已经阅读了本系列的第一部分，那么您可能已经克隆了包含所有资源和资产的<a class="ae kl" href="https://github.com/lbroudoux/secured-fruits-catalog-k8s" rel="noopener ugc nofollow" target="_blank"> my GitHub repository </a>。如果没有，我敦促你这样做；-)从您笔记本电脑上的克隆中，切换到<code class="fe km kn ko kp b">master</code>分支。</p><p id="c3ce" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于这第四部分，第一步将是激活称为<code class="fe km kn ko kp b">database</code>的金库机密引擎。在这个引擎中，我们将为我们的基础创建一个新的配置，以便将连接设置馈送到数据库的Vault。注意，因为我们和数据库在同一个Kubernetes名称空间中，所以我们可以使用简短的<code class="fe km kn ko kp b">mongodb.fruits-catalog.svc.cluster.local</code>符号。最后，我们必须为我们的数据库创建一个新的角色；此角色将描述新租赁的生存时间以及应该用于发布该租赁的声明:</p><pre class="ky kz la lb gt ng kp nh ni aw nj bi"><span id="cb5a" class="nk mc iq kp b gy nl nm l nn no">$ vault secrets enable -tls-skip-verify database<br/>Success! Enabled the database secrets engine at: database/</span><span id="5d0a" class="nk mc iq kp b gy np nm l nn no">$ vault write -tls-skip-verify database/config/fruit-catalog-mongodb \<br/>   plugin_name=mongodb-database-plugin \<br/>   allowed_roles="fruit-catalog-role" \<br/>   connection_url="mongodb://{{username}}:{{password}}@mongodb.fruits-catalog.svc.cluster.local:27017/admin" \<br/>   username="admin" \<br/>   password="$(oc get secret/mongodb -o jsonpath="{.data.database-admin-password}" | base64 -D )"<br/>Success! Data written to: database/roles/fruit-catalog-mongodb</span><span id="f49f" class="nk mc iq kp b gy np nm l nn no">$ vault write -tls-skip-verify database/roles/fruit-catalog-role \<br/>   db_name=fruit-catalog-mongodb \<br/>   creation_statements='{ "db": "sampledb", "roles": [{"role": "readWrite", "db": "sampledb"}] }' \<br/>   default_ttl="1h" \<br/>   max_ttl="24h" \<br/>   revocation_statements='{ "db": "sampledb" }'<br/>Success! Data written to: database/roles/fruit-catalog-role</span></pre><p id="af6d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用Vault CLI或贵由还可以轻松检查我们刚刚创建的资源的配置:</p><pre class="ky kz la lb gt ng kp nh ni aw nj bi"><span id="7f0e" class="nk mc iq kp b gy nl nm l nn no">$ vault read -tls-skip-verify database/config/fruit-catalog-mongodb<br/>Key                                   Value<br/>---                                   -----<br/>allowed_roles                         [fruit-catalog-role]<br/>connection_details                    map[connection_url:mongodb://{{username}}:{{password}}@mongodb.fruits-catalog.svc.cluster.local:27017/admin username:admin]<br/>plugin_name                           mongodb-database-plugin<br/>root_credentials_rotate_statements    []</span><span id="2a74" class="nk mc iq kp b gy np nm l nn no">$ vault read -tls-skip-verify database/roles/fruit-catalog-role<br/>Key                      Value<br/>---                      -----<br/>creation_statements      [{ "db": "sampledb", "roles": [{"role": "readWrite", "db": "sampledb"}] }]<br/>db_name                  fruit-catalog-mongodb<br/>default_ttl              1h<br/>max_ttl                  24h<br/>renew_statements         []<br/>revocation_statements    [{ "db": "sampledb" }]<br/>rollback_statements      []</span></pre><p id="c6da" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">与前一部分处理静态机密一样，我们需要在Vault中创建一个策略，允许读取MongoDB的动态机密。使用Vault CLI时，我们以管理员身份登录，但我们的服务帐户并非如此。在前面的部分中，我们已经激活了Kubernetes身份验证方法，这个策略还需要关联到服务帐户和Kubernetes名称空间。这就是以下两个命令的意义所在:</p><pre class="ky kz la lb gt ng kp nh ni aw nj bi"><span id="a801" class="nk mc iq kp b gy nl nm l nn no">$ vault policy write -tls-skip-verify fruit-catalog-policy-dynamic ./k8s/fruit-catalog-policy-dynamic.hcl<br/>Success! Uploaded policy: fruit-catalog-policy-static</span><span id="6d23" class="nk mc iq kp b gy np nm l nn no">$ vault write -tls-skip-verify auth/kubernetes/role/fruits-catalog \<br/>   bound_service_account_names=fruits-catalog-vault \<br/>   bound_service_account_namespaces=fruits-catalog \<br/>   policies=fruit-catalog-policy-static,fruit-catalog-policy-dynamic \<br/>   ttl=24h<br/>Success! Data written to: auth/kubernetes/role/fruits-catalog</span></pre><p id="cc6a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，只需用一个包含<code class="fe km kn ko kp b">vault-init</code> Init容器和<code class="fe km kn ko kp b">vault-lease-refresher</code> Sidecar容器的新容器替换OpenShift中现有的<code class="fe km kn ko kp b">Deployment</code>。只是不要忘记在那之前用你的值替换我的路由值，使用一些无用的<code class="fe km kn ko kp b">sed</code>命令；-)</p><pre class="ky kz la lb gt ng kp nh ni aw nj bi"><span id="4770" class="nk mc iq kp b gy nl nm l nn no">$ export VAULT_ROUTE=$(oc get route/vault -n fruits-catalog | grep vault | awk '{print $2}')<br/>$ export KEYCLOAK_ROUTE=$(oc get route/keycloak -n fruits-catalog | grep keycloak | awk '{print $2}')</span><span id="3699" class="nk mc iq kp b gy np nm l nn no">$ sed -i '' 's=vault-fruits-catalog.apps.144.76.24.92.nip.io='"$VAULT_ROUTE"'=' k8s/fruits-catalog-dynamic-secret-deployment.yml<br/>$ sed -i '' 's=keycloak-fruits-catalog.apps.144.76.24.92.nip.io='"$KEYCLOAK_ROUTE"'=' k8s/fruits-catalog-dynamic-secret-deployment.yml</span><span id="f4e8" class="nk mc iq kp b gy np nm l nn no">$ oc replace -f k8s/fruits-catalog-dynamic-secret-deployment.yml</span></pre><blockquote class="kq kr ks"><p id="82a0" class="jn jo kt jp b jq jr js jt ju jv jw jx ku jz ka kb kv kd ke kf kw kh ki kj kk ij bi translated">我们在这里配置部署的方式很难理解——一切都是“手动”进行的。虽然检查以了解细节很有趣，但现在有一种更简单的方法可以做到这一点。我在那个上发布了一个<a class="ae kl" href="https://medium.com/@lbroudoux/adding-security-layers-to-your-app-on-openshift-update-welcome-vault-agent-injector-46cab161c366" rel="noopener">更新，使用了新的保险库代理注入器。</a></p></blockquote><h1 id="f395" class="mb mc iq bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">检查它是否按预期工作</h1><p id="beb6" class="pw-post-body-paragraph jn jo iq jp b jq mz js jt ju na jw jx jy nb ka kb kc nc ke kf kg nd ki kj kk ij bi translated">当检查它是否工作时，首先要做的显然是使用<code class="fe km kn ko kp b">fruits-catalog</code>路径的URL打开一个浏览器，检查应用程序是否还在工作。但是如果你想/需要深潜，这里有一些其他的检查。</p><p id="8adf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们可以使用以下命令从Vault本身重新读取每个配置项:</p><pre class="ky kz la lb gt ng kp nh ni aw nj bi"><span id="7d55" class="nk mc iq kp b gy nl nm l nn no">$ vault read -format json database/creds/fruit-catalog-role<br/>{<br/>  "request_id": "d48cea61-18b1-b34e-67ea-eea1850fb3cf",<br/>  "lease_id": "database/creds/fruit-catalog-role/3bxsRmUzwtUu2r1m6q2zJLTM",<br/>  "lease_duration": 3600,<br/>  "renewable": true,<br/>  "data": {<br/>    "password": "A1a-hQUdn9qxGdSk0qpK",<br/>    "username": "v-root-fruit-catalog-r-Oy05HvQHmZ0tu3LFZ8Lp-1560953738"<br/>  },<br/>  "warnings": null<br/>}</span><span id="8a1c" class="nk mc iq kp b gy np nm l nn no">$ vault lease renew database/creds/fruit-catalog-role/3bxsRmUzwtUu2r1m6q2zJLTM<br/>Key                Value<br/>---                -----<br/>lease_id           database/creds/fruit-catalog-role/3bxsRmUzwtUu2r1m6q2zJLTM<br/>lease_duration     1h<br/>lease_renewable    true</span><span id="af57" class="nk mc iq kp b gy np nm l nn no">$ vault lease revoke database/creds/fruit-catalog-role/3bxsRmUzwtUu2r1m6q2zJLTM<br/>All revocation operations queued successfully!</span></pre><p id="12b9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，我们可以看一下<code class="fe km kn ko kp b">fruits-catalog</code>吊舱部署，并检查我们是否一切就绪。以下是OpenShift web控制台的屏幕截图，显示了:</p><ul class=""><li id="3fac" class="ln lo iq jp b jq jr ju jv jy lp kc lq kg lr kk ls lt lu lv bi translated">我们已经成功完成了一个初始化容器。我们还可以访问这个<code class="fe km kn ko kp b">vault-init</code>容器发出的命令，</li><li id="728a" class="ln lo iq jp b jq lw ju lx jy ly kc lz kg ma kk ls lt lu lv bi translated">我们已经有了第一个名为<code class="fe km kn ko kp b">vault-lease-refresher</code>的容器，并且仍然可以访问后一个容器发出的命令。稍后会有更多的介绍，</li><li id="d422" class="ln lo iq jp b jq lw ju lx jy ly kc lz kg ma kk ls lt lu lv bi translated">我们最终得到了第二个也是主要的容器，它是我们的应用程序，使用由Init容器编写的<code class="fe km kn ko kp b">application.properties</code>配置。</li></ul><figure class="ky kz la lb gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi nq"><img src="../Images/8a31b08d02e1598bfedb78adb7048d1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WjOAQHKLdOoSej7PYCQzcw.png"/></div></div></figure><p id="ed27" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">需要注意的两件重要事情是<code class="fe km kn ko kp b">vault-lease-refresher</code>容器使用的命令。正如在关于<code class="fe km kn ko kp b">vault-init </code>容器的前一篇文章中所解释的，这个容器使用了一个极简的<a class="ae kl" href="https://www.redhat.com/en/blog/introducing-red-hat-universal-base-image" rel="noopener ugc nofollow" target="_blank">Red Hat Universal Base Image</a>，它刚刚用<a class="ae kl" href="https://stedolan.github.io/jq/" rel="noopener ugc nofollow" target="_blank"> jq </a>工具进行了增强。当查看<a class="ae kl" href="https://github.com/lbroudoux/secured-fruits-catalog-k8s/blob/master/k8s/fruits-catalog-dynamic-secret-deployment.yml#L61" rel="noopener ugc nofollow" target="_blank">部署</a>的YAML时，您首先会发现这个命令是一个用bash shell编写的无限循环，它定期调用我们的Vault实例上的适当API来刷新租约:</p><pre class="ky kz la lb gt ng kp nh ni aw nj bi"><span id="f1c9" class="nk mc iq kp b gy nl nm l nn no">X_VAULT_TOKEN=$(cat /etc/vault/token);<br/>VAULT_LEASE_ID=$(cat /etc/app/creds.json | jq -j '.lease_id');</span><span id="c277" class="nk mc iq kp b gy np nm l nn no">while true; do<br/>  curl -k -s --request PUT --header "X-Vault-Token: $X_VAULT_TOKEN" --data '{"lease_id": "'"$VAULT_LEASE_ID"'", "increment": 3600}' <a class="ae kl" href="https://vault-fruits-catalog.apps.144.76.24.92.nip.io/v1/sys/leases/renew;" rel="noopener ugc nofollow" target="_blank">https://vault-fruits-catalog.apps.x.x.x.x.nip.io/v1/sys/leases/renew;</a><br/>  echo 'Waiting for 360 sec before renewing lease'<br/>  sleep 360;<br/>done</span></pre><p id="e714" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第二个需要注意的命令是使用<a class="ae kl" href="https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks" rel="noopener ugc nofollow" target="_blank">预停止生命周期挂钩</a>删除Pod时调用的命令。这里，我们再次调用一个Vault API来使用租约Id撤销所使用的机密:</p><pre class="ky kz la lb gt ng kp nh ni aw nj bi"><span id="c16d" class="nk mc iq kp b gy nl nm l nn no">X_VAULT_TOKEN=$(cat /etc/vault/token);<br/>VAULT_LEASE_ID=$(cat /etc/app/creds.json | jq -j '.lease_id');</span><span id="51f1" class="nk mc iq kp b gy np nm l nn no">curl -k --request PUT --header "X-Vault-Token: $X_VAULT_TOKEN" --data '{"lease_id": "'"$VAULT_LEASE_ID"'"}' https://vault-fruits-catalog.apps.x.x.x.x.nip.io/v1/sys/leases/revoke;</span></pre><p id="272b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">检查这种动态行为的一个简单演示是为MongoDB数据库连接一个图形客户端，并在您扩大或缩小<code class="fe km kn ko kp b">fruits-catalog</code>部署时实时查看用户和秘密的出现和消失。例如，您可以使用管理员凭证使用机器人3T 连接到MongoDB实例。为此，您可能希望CLI的<code class="fe km kn ko kp b">port-forward</code>特性带有类似<code class="fe km kn ko kp b">oc port-forward mongodb-1-t85wm 56866:27017 -n fruits-catalog</code>的命令</p><figure class="ky kz la lb gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi nr"><img src="../Images/88e280831e34533136dc3d3a46acb41d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9N5ZCd9M82FtcrMPcUoOQQ.png"/></div></div></figure><p id="949e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后连接本地端口并检查<code class="fe km kn ko kp b">system.users</code>集合，根据pods副本的数量查看<code class="fe km kn ko kp b">sampledb</code>数据库上的用户数量；-)</p><h1 id="d400" class="mb mc iq bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">结论和下一步</h1><p id="8b3e" class="pw-post-body-paragraph jn jo iq jp b jq mz js jt ju na jw jx jy nb ka kb kc nc ke kf kg nd ki kj kk ij bi translated">我们已经在第四部分中看到，如何让Hashicorp <a class="ae kl" href="http://vaultproject.io/" rel="noopener ugc nofollow" target="_blank"> Vault </a>为我们管理数据库凭证！由于上一篇文章演示了Vault的一般秘密管理，我们在这里看到了通过其专用引擎与数据库的高级集成。</p><p id="e4fb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这种集成非常强大，因为您不再需要存储、分发和管理应用程序的数据库凭据！使用带有生命周期挂钩的<a class="ae kl" href="https://kubernetes.io/docs/concepts/workloads/pods/init-containers/" rel="noopener ugc nofollow" target="_blank"> Init </a>和<a class="ae kl" href="https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/#understanding-pods" rel="noopener ugc nofollow" target="_blank"> Sidecar </a>容器，您现在就拥有了短暂的凭证，它的生命周期就是pod的生命周期。Pods通过Kubernetes集成，使用与其自己的服务帐户相关联的证书进行Vault身份验证。更好的是:我们没有接触应用程序代码；-)</p><p id="96a9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在想象一下这个功能的强大之处，再加上数据库端的审计日志……由于用户名包含pod标识符，我们现在能够准确地知道哪个副本在数据库上完成了哪个操作……继续讨论这个问题可能会很有趣，我们将在下一篇文章中切换到另一个主题，讨论零信任网络和集群内传输安全性。敬请期待！</p></div></div>    
</body>
</html>