<html>
<head>
<title>Understanding Docker by Creating our Own</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过创建我们自己的Docker来了解它</h1>
<blockquote>原文：<a href="https://itnext.io/linux-container-from-scratch-339c3ba0411d?source=collection_archive---------2-----------------------#2019-06-14">https://itnext.io/linux-container-from-scratch-339c3ba0411d?source=collection_archive---------2-----------------------#2019-06-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/d3c01a611be858e8f6115fdba379dc7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RzRYMOizXX1YGo1JBXX19w.jpeg"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">图片取自<a class="ae jd" href="https://theloadstar.com/wp-content/uploads/%c2%a9-Binkski-containers_9754977.jpg" rel="noopener ugc nofollow" target="_blank">此处</a></figcaption></figure><div class=""/></div><div class="ab cl kd ke hu kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ij ik il im in"><p id="d578" class="pw-post-body-paragraph kk kl jg km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">让我们假设我们有一个网上商店，里面有一些你在<em class="li">亚马逊网络服务</em>或者<em class="li">谷歌云平台</em>上托管的服务器。当只有少数人访问我们的网站时，我们不想花很多钱，但是我们的网站可能在一年中传播几次(假设在<a class="ae jd" href="https://www.adweek.com/digital/5-digital-stats-that-sum-up-cyber-monday-and-black-friday/" rel="noopener ugc nofollow" target="_blank">黑色星期五</a>)，在这个访问高峰期，我们应该为我们的网站购买多少额外的资源？</p><p id="4bb5" class="pw-post-body-paragraph kk kl jg km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">如果你熟悉这些云技术，你应该已经知道它们有自动扩展选项，但是它是如何工作的呢？也许他们使用<strong class="km jh">虚拟机，但是他们配置/复制速度很慢</strong>，并且实际上花费了大量的递归来实现所有的硬件虚拟化，等等。所以这可能是用<a class="ae jd" href="https://www.docker.com/resources/what-container" rel="noopener ugc nofollow" target="_blank">容器</a>完成的，它们更轻、更快，也更容易<a class="ae jd" href="https://www.infoworld.com/article/3268073/kubernetes/what-is-kubernetes-container-orchestration-explained.html" rel="noopener ugc nofollow" target="_blank">管理</a>。</p><p id="b209" class="pw-post-body-paragraph kk kl jg km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated"><strong class="km jh">TL；容器是一种将程序与其所在的真实系统隔离开来的方式。它依赖于提供隔离并让我们管理资源的linux特性。在这篇文章中，我们将尝试理解它是如何工作的，同时创建我们的容器化程序。</strong></p></div><div class="ab cl kd ke hu kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ij ik il im in"><h1 id="e25f" class="lj lk jg bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">范围和前提条件</h1><p id="f7cf" class="pw-post-body-paragraph kk kl jg km b kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld ml lf lg lh ij bi translated">在本文中，我们将展示创建容器化程序<a class="ae jd" href="https://github.com/joseims/doqueru-kun/" rel="noopener ugc nofollow" target="_blank"> doqueru-kun </a>的步骤。不幸的是，我花了很多时间来写这篇文章，所以主题之间可能会有一些不一致的地方，如果你发现了，请告诉我。</p><p id="2f17" class="pw-post-body-paragraph kk kl jg km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">我们将介绍我们将使用的linux名称空间，并展示如何将它与系统的其他部分隔离开来，但是你可能会发现(正如我们所做的一样)<a class="ae jd" href="https://www.youtube.com/watch?v=-YnMr1lj4Z8" rel="noopener ugc nofollow" target="_blank"> LiveOverflow的方法</a>更具娱乐性。</p><p id="1f3d" class="pw-post-body-paragraph kk kl jg km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">我们选择用C/C++实现来直接调用系统调用，而不像某些语言或库那样进行抽象。通过这种方式，我们了解了很多关于linux实现的一些名称空间和系统调用。</p><p id="c0b2" class="pw-post-body-paragraph kk kl jg km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">可以做很多事情来隔离一个系统。在本文中，我们处理的是:<strong class="km jh">进程</strong>、<strong class="km jh">主机名</strong>、<strong class="km jh">文件系统</strong>的隔离。</p><p id="e9fc" class="pw-post-body-paragraph kk kl jg km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">我们是<strong class="km jh">而不是</strong>处理隔离/绑定:<strong class="km jh">网络</strong>、<strong class="km jh"> cpu使用率</strong>、<strong class="km jh">内存使用率</strong>、<strong class="km jh">使用率</strong>、<strong class="km jh"> I/O速率</strong>限制、<strong class="km jh">磁盘使用率</strong>等。但是大多数界限可以通过使用cgroups来控制。我们已经在doqueru-kun中使用了cgroup，所以也许我以后会发布关于它们的内容。</p><blockquote class="mm mn mo"><p id="ec42" class="kk kl li km b kn ko kp kq kr ks kt ku mp kw kx ky mq la lb lc mr le lf lg lh ij bi translated">注意:网络隔离是一个我们正在讨论如何处理的问题。如果你对此有什么意见，请在我们的git上发表。</p></blockquote></div><div class="ab cl kd ke hu kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ij ik il im in"><h1 id="a220" class="lj lk jg bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">叉子()</h1><p id="e07a" class="pw-post-body-paragraph kk kl jg km b kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld ml lf lg lh ij bi translated"><strong class="km jh"> fork </strong>和<strong class="km jh"> exec </strong>是<em class="li">进程</em> genesis中最重要的<a class="ae jd" href="https://en.wikipedia.org/wiki/System_call" rel="noopener ugc nofollow" target="_blank">系统调用</a>(简称syscall)。</p><figure class="mt mu mv mw gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ms"><img src="../Images/7a0f9e38eeacd1cd356dab67e892488a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_tlfv5LZ9X3Wy5FcheGd2A.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated"><strong class="bd ll"> Linux程序员手册</strong>上的叉子(2)</figcaption></figure><p id="049f" class="pw-post-body-paragraph kk kl jg km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated"><strong class="km jh"> fork() </strong>:它创建了一个新的进程，这个进程将<em class="li">成为他的调用者</em>的形象和肖像，它将在调用者程序调用fork()之后的那个点开始运行完全相同的代码。对这个新流程进行了非常小的修改，对我们来说重要的是它有自己的PID，并且他的调用者将作为他的父流程关联(因此，它是父流程的一个子流程)。</p><p id="e4f7" class="pw-post-body-paragraph kk kl jg km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">只有这一点不同，我们可以使用相同的代码编写两个不同的程序:</p><figure class="mt mu mv mw gt is gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/0602d2e5b3c6342032c55a0e8f7143ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/format:webp/1*upDePEw-SUh1rG87OKr_BQ.png"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated"><strong class="bd ll"> fork() </strong>示例用法</figcaption></figure><p id="4a69" class="pw-post-body-paragraph kk kl jg km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">在关闭这个程序之前，我们可以用<strong class="km jh"> ps fc </strong>来可视化我们的进程的层次结构，它会显示我们的程序有另一个同名的，是他的孩子。</p><figure class="mt mu mv mw gt is gh gi paragraph-image"><div class="gh gi my"><img src="../Images/221532a47f5387a37eb491237703f3c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:700/format:webp/1*Z8_mnqzcssUPqqNqmUaS-g.png"/></div></figure><p id="888f" class="pw-post-body-paragraph kk kl jg km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">记住这些知识，把图像放在一边，您可以猜测bash也在调用<strong class="km jh"> fork() </strong>来启动一个新的进程。但是如果程序的实际代码不在bash的代码中，那怎么可能呢？</p><h1 id="6dba" class="lj lk jg bd ll lm mz lo lp lq na ls lt lu nb lw lx ly nc ma mb mc nd me mf mg bi translated">执行()</h1><figure class="mt mu mv mw gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ne"><img src="../Images/d2b892f72f89a6c6999eb2c38864849d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*063kE_GkQ_GqxQbyWkg-XQ.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated"><strong class="bd ll"> Linux程序员手册</strong>上的exec(3)</figcaption></figure><p id="58a6" class="pw-post-body-paragraph kk kl jg km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">当<strong class="km jh">分支</strong>被调用一次并返回两次时(子级上的<strong class="km jh"> 0 </strong>和父级上的<strong class="km jh">子级PID</strong>)<strong class="km jh">exec</strong>实际上返回不止一次(实际上，如果发生错误，两者都返回一次)。</p><p id="0aed" class="pw-post-body-paragraph kk kl jg km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">它只是将调用进程的执行代码替换为指定的可执行代码。</p><blockquote class="mm mn mo"><p id="1d4e" class="kk kl li km b kn ko kp kq kr ks kt ku mp kw kx ky mq la lb lc mr le lf lg lh ij bi translated">注意:<strong class="km jh"> exec </strong>是一系列函数，它们以不同的方式或用不同的参数做同样的事情，所以我们将从这个项目中使用<strong class="km jh"> execvp </strong>。<strong class="km jh"> execvp </strong>需要一个带有可执行文件路径的字符串和一个指向参数的指针。</p></blockquote><p id="1955" class="pw-post-body-paragraph kk kl jg km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">为了快速测试并使事情有所进展，让我们创建一个名为test.cpp的文件，它只打印dies之前的进程PID，让我们将它编译到<strong class="km jh">test.exe</strong>，我们将使用这个文件来检查我们开发容器的进度。</p><p id="619d" class="pw-post-body-paragraph kk kl jg km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">在清理了一些代码之后，我们有了一个程序，它调用另一个程序(听起来制作一个终端应该不是很难)，然后把自己变成同一个程序。</p><figure class="mt mu mv mw gt is gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/4ba1e35368d4973f1c7ff3ce45f08e45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1264/1*rMNjThZGsHW1yhst9sqEEA.gif"/></div></figure><p id="17c2" class="pw-post-body-paragraph kk kl jg km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">所以，现在我们知道如何用<strong class="km jh"> fork() </strong>和<strong class="km jh"> exec() </strong>来创建另一个程序。我们编写的这个程序将成为我们的容器，我们在里面调用的每个程序都不会影响我们真正的系统。</p></div><div class="ab cl kd ke hu kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ij ik il im in"><h1 id="07f2" class="lj lk jg bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">防御性编程</h1><p id="4b1b" class="pw-post-body-paragraph kk kl jg km b kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld ml lf lg lh ij bi translated">有了<a class="ae jd" href="https://github.com/joseims/doqueru-kun/blob/master/steps/exec.cpp" rel="noopener ugc nofollow" target="_blank">我们当前的程序</a>我们可以通过传递他的位置来运行任何可执行文件，因此我们可以运行<strong class="km jh"> /bin/bash </strong>并执行几个命令和乱搞(键入<strong class="km jh">退出</strong>或按下<strong class="km jh"> CTRL+D </strong>来关闭它)。</p><p id="67bf" class="pw-post-body-paragraph kk kl jg km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">但是在程序内部，我们仍然在我们真实的系统中，所以无论发生什么仍然会反映在我们的系统中，这就是为什么我们需要在每一步都小心谨慎。</p><blockquote class="mm mn mo"><p id="92de" class="kk kl li km b kn ko kp kq kr ks kt ku mp kw kx ky mq la lb lc mr le lf lg lh ij bi translated">举一个真实的例子:在我们以多种方式隔离了进程之后，在某个时刻我们将从系统中完全替换掉我们的<strong class="km jh">"/</strong>，这不会影响真实的工作空间。如果这个过程中的任何一步没有奏效，我们必须在下一步之前知道。</p></blockquote><p id="707a" class="pw-post-body-paragraph kk kl jg km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">Linux提供了一个名为<strong class="km jh"> &lt; errno.h &gt; </strong>的头文件，我们调用的所有syscall都有一种方法来判断是否出错。一般情况下，如果有错误会返回-1，我们可以在<strong class="km jh"> errno </strong>中查看错误代码。</p><p id="24b5" class="pw-post-body-paragraph kk kl jg km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">所以，在编写了一些C宏和我们自己的assert() 之后，在我们调用我们调用的任何syscall之后，让我们断言一切都在按预期工作，然后继续。</p></div><div class="ab cl kd ke hu kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ij ik il im in"><h1 id="7b9c" class="lj lk jg bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">取消共享()和命名空间</h1><p id="d306" class="pw-post-body-paragraph kk kl jg km b kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld ml lf lg lh ij bi translated">在<a class="ae jd" href="https://linux.die.net/man/2/unshare" rel="noopener ugc nofollow" target="_blank"> unshare的手册页</a>中，我们有一个不可共享名称空间的列表(我们可以在<a class="ae jd" href="https://linux.die.net/man/2/clone" rel="noopener ugc nofollow" target="_blank"> clone的手册页</a>中读到关于名称空间的内容)。现在让我们继续使用UTS、PID和MNT名称空间。</p><ul class=""><li id="afe4" class="ng nh jg km b kn ko kr ks kv ni kz nj ld nk lh nl nm nn no bi translated"><strong class="km jh">【UNIX分时】</strong>:这个名称空间隔离了我们可以从<a class="ae jd" href="https://linux.die.net/man/2/uname" rel="noopener ugc nofollow" target="_blank"> uname </a> syscall中获取的属性，比如操作系统的名称、版本、用户和域名等。</li><li id="bbab" class="ng nh jg km b kn np kr nq kv nr kz ns ld nt lh nl nm nn no bi translated"><strong class="km jh"> PID(进程ID) </strong>:这个隔离了PID树，那个我们用ps -auxf可视化的，[剧透]这将是一个非常有趣的[/剧透]。</li><li id="1cc0" class="ng nh jg km b kn np kr nq kv nr kz ns ld nt lh nl nm nn no bi translated"><strong class="km jh"> MNT(挂载)</strong>:所以我们也有了一个包含所有挂载点的名称空间，酷。事实上，我以前并不太关心它，直到我发现有多少linux机制依赖于它…我会更深入地谈论它，但我们不要本末倒置。</li></ul><h1 id="af08" class="lj lk jg bd ll lm mz lo lp lq na ls lt lu nb lw lx ly nc ma mb mc nd me mf mg bi translated"><strong class="ak"> UTS命名空间</strong></h1><p id="8f37" class="pw-post-body-paragraph kk kl jg km b kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld ml lf lg lh ij bi translated">如上所述，<strong class="km jh"> UTS名称空间</strong>隔离了一些属性。这是一个非常简单的名称空间，它将帮助我们更深入地研究linux文档和程序员手册。</p><p id="c8be" class="pw-post-body-paragraph kk kl jg km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">让我们通过在容器中创建一个新的UTS来探索我们能做些什么。克隆人的手册上提到了<strong class="km jh"> CLONE_NEWUTS </strong>标志，以及<strong class="km jh"> sethostname() </strong>函数。在这一节的最后，还提到只有<strong class="km jh"> CAP_SYS_ADMIN </strong>才能创建一个新的UTS。我们还不熟悉这个命令，所以我们将讨论每个关键字。</p><p id="f1e2" class="pw-post-body-paragraph kk kl jg km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated"><strong class="km jh"> clone() </strong> syscall有许多标志，用于创建能够隔离其名称空间的进程，这些标志也在<strong class="km jh"> unshare() </strong> syscall中使用，<strong class="km jh"> CLONE_NEWUTS </strong>就是其中之一。这些标志是整数，其中每一位都有不同的含义，因此我们可以对标志进行按位“或”运算来组合它们。</p><p id="80a7" class="pw-post-body-paragraph kk kl jg km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated"><strong class="km jh"> sethostname() </strong>只是一个改变处理器主机名的系统调用(类似于hostname命令)，我们将用它来设置我们容器的主机名。我们可以通过<strong class="km jh"> uname -n </strong>命令或<strong class="km jh"> gethostname() </strong>函数来实现这一点。</p><figure class="mt mu mv mw gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nu"><img src="../Images/6f92612263e8c2a33e750ac35f39c27e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eqIG_gjk0cgEMQjT45M26A.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">创建新的UTS名称空间并将主机名设置为“doqueru”的函数。</figcaption></figure><p id="e5fa" class="pw-post-body-paragraph kk kl jg km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">因此，在我们的程序上添加这个小函数，我们隔离了真正的UTS命名空间。如果它内部的任何进程改变了它的某些东西，它不会对我们的计算机产生影响。</p><p id="e6d6" class="pw-post-body-paragraph kk kl jg km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">但是…如果您尝试像以前一样运行代码，您会得到一个<strong class="km jh"> EPERM </strong>错误。这就是<strong class="km jh"> CAP_SYS_ADMIN </strong>需求警告我们的，从现在开始需要用sudo特权调用我们的程序。</p><figure class="mt mu mv mw gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nv"><img src="../Images/4a2c37763eaf86bd1d3eac608bc5a85f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*VjNPpBjOSXp7vzN_3fHRdQ.gif"/></div></div></figure><blockquote class="mm mn mo"><p id="3a50" class="kk kl li km b kn ko kp kq kr ks kt ku mp kw kx ky mq la lb lc mr le lf lg lh ij bi translated">提示:如果您在运行syscall时遇到这样的错误，最好在syscall的手册页中查找错误的参考资料。在<strong class="km jh"> man 2 unshare </strong>上寻找错误部分，你会发现如果“调用进程没有这个操作所需的特权”就会抛出EPERM错误。使用<strong class="km jh"> errno </strong>终端命令查看错误的名称或描述也可能对您有所帮助。</p></blockquote><h1 id="41a0" class="lj lk jg bd ll lm mz lo lp lq na ls lt lu nb lw lx ly nc ma mb mc nd me mf mg bi translated">PID命名空间</h1><p id="3aa7" class="pw-post-body-paragraph kk kl jg km b kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld ml lf lg lh ij bi translated">在我们的容器中，我们仍然可以访问所有其他进程，并可以与它们交互，通过使用它们的PID创建文件描述符或向它们发送信号(例如使用<a class="ae jd" href="https://linux.die.net/man/3/kill" rel="noopener ugc nofollow" target="_blank"> kill </a>)。现在我们将通过创建一个新的PID名称空间来避免这样的事情。</p><p id="2167" class="pw-post-body-paragraph kk kl jg km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">操纵linux的进程树可能很棘手，但是在阅读了<a class="ae jd" href="http://man7.org/linux/man-pages/man7/pid_namespaces.7.html" rel="noopener ugc nofollow" target="_blank">文档</a>之后，看起来非常聪明和简单。</p><p id="d8fc" class="pw-post-body-paragraph kk kl jg km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">每个进程都必须有一个父进程，因此我们有一个进程树，其根是PID为1的进程(让我们忘记PID为0的进程)。根被称为<strong class="km jh"> init </strong>并且在PID名称空间上有一个特殊的角色:这个进程将采用所有孤儿进程(当他的父进程在他们之前结束时发生),并且对于创建新进程的操作是必不可少的。如果它死了，那么就不能创建任何进程，所有命名空间的进程都将随着内核发送的<strong class="km jh"> SIGKILL </strong>信号而结束。</p><p id="e6ae" class="pw-post-body-paragraph kk kl jg km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">当使用<strong class="km jh"> CLONE_NEWPID </strong>标志取消共享时，调用进程将保留在其当前名称空间中，但是在<strong class="km jh">取消共享</strong>后创建的其子进程将进入新的<strong class="km jh"> PID名称空间</strong>。</p><figure class="mt mu mv mw gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nw"><img src="../Images/839d131d565df3a30b58b909752cc932.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*5ZLMZxTeMT0jTjLzT3BXTQ.gif"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">过程树及其非共享可视化</figcaption></figure><p id="6104" class="pw-post-body-paragraph kk kl jg km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">在上面的<em class="li"> gif </em>中，我们可以看到带有<strong class="km jh"> PID名称空间</strong>非共享的进程(底部终端)无法从外部看到进程，但是整个名称空间从父进程的<strong class="km jh"> PID名称空间</strong>(顶部终端)中是可见的。同样值得注意的是，相同的进程在不同的名称空间中使用不同的PID。我在<strong class="km jh"> unshare </strong>命令中使用了<em class="li"> mount-proc </em>参数，这个unshare<strong class="km jh">mount namespace</strong>并在<strong class="km jh"> /proc </strong>中挂载<em class="li">procf</em>，我们将到达那里。</p><p id="58d9" class="pw-post-body-paragraph kk kl jg km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">返回代码:我们将需要调用<strong class="km jh">unshare(CLONE _ new uts | CLONE _ NEWPID)</strong>来组合这些标志。在这之后，我们的第一个孩子可以是我们作为参数得到的可执行文件，但是这将是<strong class="km jh"> init </strong>进程，我们不应该相信任意代码来承担这个责任。如果我们在<strong class="km jh">分叉</strong>之前<strong class="km jh">取消共享</strong>，那么我们的fork()已经产生了<strong class="km jh"> init </strong>。然后，让我们在我们的"<strong class="km jh"> init </strong>中调用fork+exec来保存它，并让它等待所有子进程死亡(我们已经在<strong class="km jh"> main </strong>函数上用<strong class="km jh"> wait </strong> syscall完成了这一点)。</p><h1 id="43dc" class="lj lk jg bd ll lm mz lo lp lq na ls lt lu nb lw lx ly nc ma mb mc nd me mf mg bi translated">MNT命名空间</h1><p id="1b71" class="pw-post-body-paragraph kk kl jg km b kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld ml lf lg lh ij bi translated">挂载名称空间是一种链接设备、文件系统和目录的方式，我们可以从文件系统访问它们。坐骑实际上很棘手，但主要是这个。</p><p id="0509" class="pw-post-body-paragraph kk kl jg km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">所以现在我们已经学到了足够的东西，可以直截了当了，对吗？我们应该在<strong class="km jh"> unshare </strong>上添加<strong class="km jh"> CLONE_NEWNS </strong>标志(是的，他们没想到将来会有更多的名称空间),这样就很好了。难道我们不是吗？</p><figure class="mt mu mv mw gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nx"><img src="../Images/9279b15406ef361743620ea3d039848c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*dtqmZtHgor1Oq8m9D_04cg.gif"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">安装在共享子树上</figcaption></figure><p id="eddb" class="pw-post-body-paragraph kk kl jg km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">哦，我们使用mount在<strong class="km jh">中创建了一个到<strong class="km jh"> / </strong>的链接。/link </strong>目录，但是当我们退出容器时，链接仍然存在。这里的问题是，即使不共享，我们的<a class="ae jd" href="http://man7.org/linux/man-pages/man7/mount_namespaces.7.html#SHARED_SUBTREES" rel="noopener ugc nofollow" target="_blank">子树也是共享的</a>。我们应该用<strong class="km jh"> MS_REC </strong>和<strong class="km jh"> MS_PRIVATE </strong>标志使它们成为私有挂载。</p><figure class="mt mu mv mw gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nx"><img src="../Images/053caa0c8155afcf52f010d6f1cce1a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*OLhDO0B4ZcAbUVVlqQJpbw.gif"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">安装在私有子树上</figcaption></figure><p id="4193" class="pw-post-body-paragraph kk kl jg km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">很好，继续前进。您可能已经读过PID名称空间的手册说:</p><blockquote class="mm mn mo"><p id="551b" class="kk kl li km b kn ko kp kq kr ks kt ku mp kw kx ky mq la lb lc mr le lf lg lh ij bi translated">创建新的PID命名空间后，子进程可以更改其根目录，并在<em class="jg"> /proc </em>处装载新的procfs实例，以便<a class="ae jd" href="http://man7.org/linux/man-pages/man1/ps.1.html" rel="noopener ugc nofollow" target="_blank"> ps(1) </a>等工具正常工作。</p></blockquote><p id="465a" class="pw-post-body-paragraph kk kl jg km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">我们需要这个挂载不影响我们的主系统，我们已经完成了，所以我们已经可以这样做了(在新的PID名称空间内)，但是不要用<strong class="km jh"> chroot </strong>来改变root，让我们用我们的最终boss: El Pivoto-Rooterino来做一些过度工程。</p><h1 id="4a6b" class="lj lk jg bd ll lm mz lo lp lq na ls lt lu nb lw lx ly nc ma mb mc nd me mf mg bi translated">枢轴根</h1><p id="9a0a" class="pw-post-body-paragraph kk kl jg km b kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld ml lf lg lh ij bi translated">当然，我们有同样目的的chroot东西，但是那太容易了(而且不安全！).我们当时的选择是使用pivot_root()系统调用，我们为此后悔了很长时间，直到我们用尽了所有的信息来源，最终做出了一个可以正常工作的代码！在你看到代码和我们的解释后，我们希望这对你来说是小菜一碟，因为我们真的很难了解关于这个程序的信息。</p><figure class="mt mu mv mw gt is gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/96b1c08b2ba48e09dc8dfe5dd855980d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1262/format:webp/1*iwod40PpSY5HqCULD22vhg.png"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated"><strong class="bd ll">男人2枢轴_根</strong>的入口</figcaption></figure><p id="79e4" class="pw-post-body-paragraph kk kl jg km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">首先，pivot_root的签名是<strong class="km jh">int pivot _ root(const char * new_root，const char *put_old) </strong>，但是它没有包装器，所以我们应该称它为<strong class="km jh"> syscall(SYS_pivot_root，new _ root，put_old) </strong>。</p><p id="56a8" class="pw-post-body-paragraph kk kl jg km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated"><strong class="km jh"> new_root </strong>和<strong class="km jh"> put_old </strong>的前置条件:它们必须是目录，不能在当前<strong class="km jh"> / </strong>的同一个文件系统中，<strong class="km jh"> put_old </strong>必须在<strong class="km jh"> new_root </strong>之下。</p><p id="5ff7" class="pw-post-body-paragraph kk kl jg km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated"><strong class="km jh">支点生根:</strong></p><ul class=""><li id="fcd3" class="ng nh jg km b kn ko kr ks kv ni kz nj ld nk lh nl nm nn no bi translated">我们将下载一个小的linux (Alpine是我们的选择，也是Docker的选择)并把它解压到我们的<strong class="km jh"> new_root </strong></li><li id="9991" class="ng nh jg km b kn np kr nq kv nr kz ns ld nt lh nl nm nn no bi translated">我们将使<strong class="km jh"> new_root </strong>成为新文件系统的挂载点(这是通过绑定挂载文件夹本身来完成的)</li><li id="4d49" class="ng nh jg km b kn np kr nq kv nr kz ns ld nt lh nl nm nn no bi translated">之后，让我们在<strong class="km jh"> new_root </strong>内部的某个地方创建<strong class="km jh"> put_old </strong></li><li id="dcc5" class="ng nh jg km b kn np kr nq kv nr kz ns ld nt lh nl nm nn no bi translated">我们现在可以<strong class="km jh"> pivot_root(new_root，put_old) </strong></li><li id="72ce" class="ng nh jg km b kn np kr nq kv nr kz ns ld nt lh nl nm nn no bi translated">让我们把脚本精确地由<strong class="km jh"> chdir </strong>变成<strong class="km jh"> / </strong></li><li id="6f71" class="ng nh jg km b kn np kr nq kv nr kz ns ld nt lh nl nm nn no bi translated">最后，我们将懒惰地卸载(用<strong class="km jh">MNT _分离</strong>)put _ old目录，这样就没有办法从容器限制的文件系统中逃脱。</li></ul><figure class="mt mu mv mw gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nx"><img src="../Images/575d6b8ec3eac4e84716f67a53c90024.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*B6ksHAhecsFSrD1YVsoSuA.gif"/></div></div></figure><p id="6e27" class="pw-post-body-paragraph kk kl jg km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">就是这样。这个序列现在看起来似乎很琐碎，但是我们在尝试中失败了很多，有些失败实际上是因为我们挂载的文件系统不是私有的，并且使用<strong class="km jh"> mount </strong>的语义乍看起来并不琐碎。</p></div><div class="ab cl kd ke hu kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ij ik il im in"><p id="ed5a" class="pw-post-body-paragraph kk kl jg km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">感谢您的阅读(或阅读意图),欢迎在<a class="ae jd" href="https://github.com/joseims/doqueru-kun/" rel="noopener ugc nofollow" target="_blank"> github </a>与我们一起投稿，如果您发现本文中有错误，请联系我。</p></div><div class="ab cl kd ke hu kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ij ik il im in"><p id="fa1e" class="pw-post-body-paragraph kk kl jg km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">2020年2月26日编辑: <a class="ae jd" href="https://youtu.be/sHp0Q3rvamk" rel="noopener ugc nofollow" target="_blank"> LiveOverflow刚刚发布了一个视频</a>提到了这篇文章。我强烈推荐他的这个系列的教育内容，但我也很高兴和自豪，所以这个推荐也有点儿<em class="li">炫耀</em>。</p></div></div>    
</body>
</html>