<html>
<head>
<title>After Using Helm for 2 Years in Production, Now Helm3</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在生产中使用Helm两年后，现在Helm3</h1>
<blockquote>原文：<a href="https://itnext.io/after-using-helm-for-2-years-in-production-now-helm3-38461a2d8047?source=collection_archive---------2-----------------------#2019-12-22">https://itnext.io/after-using-helm-for-2-years-in-production-now-helm3-38461a2d8047?source=collection_archive---------2-----------------------#2019-12-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/243779f12475f6bf1878a5bfe99ee7eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rxnOWtHGcdbn-c33hlXjjA.png"/></div></div></figure><p id="1de7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">自从开始将<a class="ae kw" href="https://www.pagevamp.com" rel="noopener ugc nofollow" target="_blank"> Pagevamp的</a>服务迁移到Google Cloud——GKE上的Kubernetes，我们就成为了<a class="ae kw" href="https://helm.sh/" rel="noopener ugc nofollow" target="_blank"> Helm </a>的粉丝，因为它提供了简单和方便。我们研究的另一个选项是<a class="ae kw" href="https://www.spinnaker.io/" rel="noopener ugc nofollow" target="_blank"> Spinnaker </a>，它在基础设施代码(IaC)方面还不太成熟，我们当时不想使用blackbox。此外，spinnaker的资源消耗很高，我们主要关心的问题之一是通过从Rackspace上基于虚拟机的服务迁移到GCP来降低成本。</p><p id="7f14" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们讨论一下我们如何使用Helm，我们所做的黑客攻击，面临的问题，以及Helm3在上下文中有什么不同。</p><h2 id="15fe" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">1.Kubernetes清单的清晰定义</h2><p id="5387" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">Helm无疑是管理Kubernetes资源清单文件的强大工具，如部署、服务、配置映射、机密等等。我们不需要为每个新服务从头开始重新编写清单，而是更新基于服务的不同变量。这提高了开发人员的工作效率，并大大降低了运营开销。由于定义是简单的yaml和模板，学习曲线并不太难。对于任何熟悉Kubernetes资源通过清单的一般定义的人来说，可以创建一个舵图并开始工作。</p><h2 id="dace" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">2.简易模板</h2><p id="4cd2" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">Helm使用的Go模板具有丰富的模板功能，无论是添加引用值、格式化缩进、大小写转换还是更多。制作一个结合了动态和静态变量的值是如此的方便。</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="6e28" class="kx ky iq ma b gy me mf l mg mh">ENVIRONMENT: {{ .Values.ENVIRONMENT | quote }}<br/>value: {{ include "mytpl" . | lower | quote }}<br/>DB_DATABASE: {{ .Values.segment }}staging</span></pre><h2 id="0d83" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">3.在几秒钟内创建多个分段</h2><p id="7e3a" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">我们希望创建整个堆栈的多个部分，以便工程团队可以在他们自己的部分测试测试代码。比如，nepal.example.com，nepal-api.example.com，everest.example.com等等。</p><p id="c402" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一个问题是，我们不仅需要使这些网址动态一样，nepal.example.com应该打电话到nepal-api.example.com和everest.example.com应该使用everest-api.example.com。我们仅仅通过定义一个模板就能够实现这一点:</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="f810" class="kx ky iq ma b gy me mf l mg mh">{{- define "segmentdot" -}}<br/>{{- if .Values.segment -}}<br/>{{ default "" .Values.segment }}.<br/>{{- end -}}<br/>{{- end -}}</span><span id="1477" class="kx ky iq ma b gy mi mf l mg mh">{{- define "segmentdash" -}}<br/>{{- if .Values.segment -}}<br/>{{ default "" .Values.segment }}-<br/>{{- end -}}<br/>{{- end -}}</span></pre><p id="d3a4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后在configmap上添加模板化变量:</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="3dd9" class="kx ky iq ma b gy me mf l mg mh">APP_URL: <a class="ae kw" rel="noopener ugc nofollow" target="_blank" href="/{{">https://{{</a> {{ .Values.segment }} }}.example.com<br/>API_URL: <a class="ae kw" rel="noopener ugc nofollow" target="_blank" href="/{{">https://{{</a> template "segmentdash" . }}api.example.com<br/>EXTRA_VARIABLE: <a class="ae kw" rel="noopener ugc nofollow" target="_blank" href="/{{">https://{{</a> template "segmentdot" . }}example.com</span><span id="83b0" class="kx ky iq ma b gy mi mf l mg mh">DB_DATABASE: {{ .Values.segment }}staging</span></pre><p id="8d0f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，我们可以通过安装相同的图表来创建一个全新的服务部分。</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="b7a6" class="kx ky iq ma b gy me mf l mg mh">helm install --name nepal-service /path/to/chart --set segment=nepal</span></pre><h2 id="447c" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">4.谷歌云存储作为图表存储</h2><p id="5a3c" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">为了使部署过程无状态，我们选择GCS bucket来存储所有服务的导航图。这样，我们不仅可以处理访问权限，而且不用担心维护部署服务器。甚至，我们可以仅通过引用图表路径来部署舵图表。</p><p id="ac5f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，明智的建议之一是选择任何持久存储服务，如S3，GCS。也有插件可以让这些桶成为舵毂。</p><h2 id="174e" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated"><strong class="ak"> 5。基础设施代码</strong></h2><figure class="lv lw lx ly gt jr gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/eb02c256b75b72395599c31639b5d071.png" data-original-src="https://miro.medium.com/v2/resize:fit:590/format:webp/1*-Knd63-3GgUkFkPw1DkMng.png"/></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">舵，docker和撰写文件的Git结构</figcaption></figure><p id="02a2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们对待基础设施上的每一个变化就像对待源代码控制上的应用服务代码一样，这样每一个变化都可以被跟踪，我们可以知道我们部署的确切状态以及我们的服务是如何运行的。通过使用Docker已经简化了路径，此外使用helm无疑使它更加透明。我们在<br/>“helm”文件夹内的同一个存储库中保存helm chart，任何配置更改、环境变量的添加/删除都将在分支上进行，并通过我们的slack bot命令进行升级。</p><h2 id="ba6b" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">6.独立掌控基础设施的变化</h2><p id="e864" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">入口、负载平衡器、SSL证书、Istio虚拟服务和路由等基础架构配置的变化并不频繁。因此，在单独的舵图上维护这些配置使维护变得容易并减少出错的机会。</p><h1 id="e3d9" class="mo ky iq bd kz mp mq mr lc ms mt mu lf mv mw mx li my mz na ll nb nc nd lo ne bi translated">挑战和头盔3如何解决</h1><h2 id="b700" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">1.安全和访问控制</h2><p id="9b1c" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">在Helm 2中，我们需要为tiller创建ServiceAccount和Role，它们需要有足够的权限在tiller使用Kube API执行集群内更新时对部署进行更改。在使用tiller时，不可能给用户选择性的访问权限，因为任何能与tiller交谈的人都可以进行任何更改或发布。因此很难根据需求来维护权限。</p><figure class="lv lw lx ly gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nf"><img src="../Images/a9410e337be52ad5491fdf0f2e80c8ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mldw9hCs3lNCmM3I701BLw.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">赫尔姆建筑公司——img src:developer.ibm.com</figcaption></figure><p id="768e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是头盔3完全改变了架构。移除tiller后，我们从本地运行的helm命令直接与Kube API服务器交互。因此，对任何Kubernetes资源的访问与运行<code class="fe ng nh ni ma b">kubectl</code>相同，并且基于<code class="fe ng nh ni ma b">kubeconfig</code>文件。我们甚至不需要用<code class="fe ng nh ni ma b">helm init</code>安装头盔。</p><h2 id="fa10" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">2.发布历史(计数和安全性)</h2><p id="b37a" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">默认情况下，helm 2会保留每个版本的无限历史，这些版本曾经对我们的系统产生过非常坏的影响。甚至<code class="fe ng nh ni ma b">helm ls</code>用了20多秒才显示安装好的图表。我们认为EKS的API服务器可能有问题，所以联系了支持团队来解决性能缓慢的问题。在他们说，磁盘I/O在主机上很高，并查看舵柄舱的日志后，我们发现舵柄有问题。</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="d134" class="kx ky iq ma b gy me mf l mg mh">kubectl --namespace=kube-system get cm -l OWNER=TILLER| wc -l</span></pre><p id="3997" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有超过3万个发布历史。为了快速清理，我们要么删除已安装的图表并重新安装，要么删除发布版本。此外，历史以平面文本的形式存储在helm installed命名空间(kube-system)中的configmap中。</p><p id="5984" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">仅仅通过用<code class="fe ng nh ni ma b">helm init — upgrade — history-max=5 — service-account tiller</code>重新初始化舵柄对现有的海图没有任何帮助，但必须清理历史，这需要几个小时。</p><p id="f34b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是随着Helm 3的引入，默认情况下只有10个发布历史被保留，它们作为Kubernetes的秘密而存在。此外，我们可以选择保持每个图表的历史计数。</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="d0fb" class="kx ky iq ma b gy me mf l mg mh">helm3 upgrade prometheus prometheus/ --history-max 20</span></pre><p id="02bf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们也可以通过删除图表来保存历史</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="35ab" class="kx ky iq ma b gy me mf l mg mh">helm3 uninstall --keep-history</span></pre><h2 id="848f" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">3.分蘖去除松开资源和版本不匹配</h2><p id="3fc7" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">当有大量的发布历史时，一个新的更新可能会使tiller消耗计算资源以及磁盘i/o，这可能会成为瓶颈，但Helm 3已经解决了这个问题。</p><p id="0c30" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在版本方面，头盔2曾经有客户端和服务器。</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="3c9e" class="kx ky iq ma b gy me mf l mg mh">$ helm version<br/>Client: &amp;version.Version{SemVer:"v2.16.1", GitCommit:"bbdfe5e7803a12bbdf97e94cd847859890cf4050", GitTreeState:"clean"}</span><span id="3714" class="kx ky iq ma b gy mi mf l mg mh">Server: &amp;version.Version{SemVer:"v2.16.1", GitCommit:"bbdfe5e7803a12bbdf97e94cd847859890cf4050", GitTreeState:"clean"}</span></pre><p id="da20" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，当任何用户更新服务器版本时，所有的客户端都需要相应地升级版本。随着Helm 3的推出，这已经成为过去的趋势。它在版本3上没有客户机-服务器模型。在运行helm命令的机器上只有客户端和它。</p><p id="1248" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">暂时就这样了。如果你有任何关于Helm使用和迁移到v3的有趣的事情要分享，请随意分享。将在另一篇文章中更新从v2到v3的迁移过程。</p><p id="a740" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<a class="ae kw" href="https://twitter.com/dwdRAJU" rel="noopener ugc nofollow" target="_blank"> twitter </a>和<a class="ae kw" href="https://www.linkedin.com/in/dwdraju/" rel="noopener ugc nofollow" target="_blank"> linkedin </a>上与我联系。</p></div></div>    
</body>
</html>