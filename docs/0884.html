<html>
<head>
<title>Running integration tests in Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Kubernetes中运行集成测试</h1>
<blockquote>原文：<a href="https://itnext.io/running-integration-tests-with-kubernetes-ae0fb71e207b?source=collection_archive---------0-----------------------#2018-06-13">https://itnext.io/running-integration-tests-with-kubernetes-ae0fb71e207b?source=collection_archive---------0-----------------------#2018-06-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="095a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Linux容器改变了我们运行、构建和管理应用程序的方式。随着越来越多的和<a class="ae kl" href="https://www.microsoft.com/en-us/cloud-platform/containers" rel="noopener ugc nofollow" target="_blank">平台成为<em class="km">云原生平台，</em>容器在每个企业的基础设施中扮演着越来越重要的角色。Kubernetes是目前最知名的容器管理解决方案，无论它们运行在私有、公共还是混合云中。</a></p><p id="2d2a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有了容器应用平台，我们可以动态地创建一个完整的环境来运行一个任务，这个任务后来被丢弃了。在之前的一篇文章中，我们介绍了如何在容器中运行<a class="ae kl" href="https://medium.com/@bszeti/running-jenkins-builds-in-containers-458e90ff2a7b" rel="noopener">构建和单元测试。现在，让我们看看如何通过启动多个容器来运行集成测试，以提供一个完整的测试环境。</a></p><blockquote class="kn ko kp"><p id="28d5" class="jn jo km jp b jq jr js jt ju jv jw jx kq jz ka kb kr kd ke kf ks kh ki kj kk ij bi translated">注意:这篇文章是<a class="ae kl" href="https://medium.com/@bszeti/running-jenkins-builds-in-containers-458e90ff2a7b" rel="noopener">在容器中运行Jenkins构建</a>的后续文章，所以建议先快速浏览一下那篇文章，以便熟悉解决方案的基本原理。</p></blockquote><p id="6920" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">假设我们有一个后端应用程序，它依赖于其他服务，如数据库、消息代理或web服务。在单元测试期间，我们尝试使用嵌入式解决方案或者简单地模拟这些端点，以确保不需要网络连接。这要求我们的代码根据测试的范围进行修改。</p><p id="e7cb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">集成测试的目的是验证应用程序如何与整个解决方案堆栈的其他部分一起工作。提供服务不仅仅取决于我们的代码库。整体解决方案是模块的混合(例如，具有存储过程的数据库、消息代理、具有服务器端脚本的分布式缓存)，这些模块必须以正确的方式连接在一起，以提供预期的功能。这只能通过实际运行所有这些部分，并且不在我们的应用程序中启用“测试模式”来测试。</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi kt"><img src="../Images/8398fda3bd9662e0d852309e05fd5675.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vfjeCoTwdSNhwS8BWCrTqQ.png"/></div></div></figure><blockquote class="kn ko kp"><p id="8679" class="jn jo km jp b jq jr js jt ju jv jw jx kq jz ka kb kr kd ke kf ks kh ki kj kk ij bi translated">“单元测试<em class="iq">”</em>“集成测试<em class="iq">”</em>是否是<a class="ae kl" href="https://martinfowler.com/articles/microservice-testing/" rel="noopener ugc nofollow" target="_blank">这个案例</a>中的正确术语值得商榷。为了简单起见，我将那些在“一个进程内”运行的没有任何外部依赖的测试称为“单元测试<em class="iq">”</em>，而那些在“生产模式”下运行应用程序的测试称为“集成测试<em class="iq">”</em>。</p></blockquote><p id="473c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为这样的测试维护一个静态环境可能很麻烦，而且浪费资源，这正是动态容器的短暂特性派上用场的地方。</p><blockquote class="kn ko kp"><p id="fa5d" class="jn jo km jp b jq jr js jt ju jv jw jx kq jz ka kb kr kd ke kf ks kh ki kj kk ij bi translated">这篇文章的代码可以在https://github.com/bszeti/kubernetes-integration-test<a class="ae kl" href="https://github.com/bszeti/kubernetes-integration-test" rel="noopener ugc nofollow" target="_blank">找到</a></p><p id="941a" class="jn jo km jp b jq jr js jt ju jv jw jx kq jz ka kb kr kd ke kf ks kh ki kj kk ij bi translated">它包含一个示例<a class="ae kl" href="https://www.redhat.com/en/technologies/jboss-middleware/fuse" rel="noopener ugc nofollow" target="_blank"> Red Hat Fuse 7 </a>应用程序(<em class="iq"> /app-users </em>)，该应用程序从<a class="ae kl" href="https://www.redhat.com/en/technologies/jboss-middleware/amq" rel="noopener ugc nofollow" target="_blank"> AQM </a>获取消息，从MariaDB查询数据，并调用REST api。repo还包含集成测试项目(<em class="iq"> /integration-test </em>)和本文中解释的不同Jenkinsfiles。</p><p id="77db" class="jn jo km jp b jq jr js jt ju jv jw jx kq jz ka kb kr kd ke kf ks kh ki kj kk ij bi translated">在组合这个例子时使用的版本:<br/> -红帽CDK 3.4版<br/>-open shift 3.9版<br/>-Kubernetes 1.9版<br/>-Jenkins images 3.9版<br/>-Jenkins Kubernetes-插件1.7版</p></blockquote><h2 id="2f85" class="lf lg iq bd lh li lj dn lk ll lm dp ln jy lo lp lq kc lr ls lt kg lu lv lw lx bi translated">每次都是新的开始</h2><p id="91b4" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">我们希望通过集成测试实现以下目标:</p><ul class=""><li id="28d2" class="md me iq jp b jq jr ju jv jy mf kc mg kg mh kk mi mj mk ml bi translated">开始测试我们的应用程序的生产就绪包。</li><li id="cc5c" class="md me iq jp b jq mm ju mn jy mo kc mp kg mq kk mi mj mk ml bi translated">启动所需的所有依赖系统的实例。</li><li id="a901" class="md me iq jp b jq mm ju mn jy mo kc mp kg mq kk mi mj mk ml bi translated">运行仅通过公共服务端点与应用程序交互的测试。</li><li id="b10b" class="md me iq jp b jq mm ju mn jy mo kc mp kg mq kk mi mj mk ml bi translated">在两次执行之间没有什么是持久的，所以我们不必担心恢复初始状态。</li><li id="3e30" class="md me iq jp b jq mm ju mn jy mo kc mp kg mq kk mi mj mk ml bi translated">资源仅在测试执行期间分配。</li></ul><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi mr"><img src="../Images/860caaabba793c5abba07da5ce846b24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z9KpT2LpMWvJSSVEQ8bAHg.png"/></div></div></figure><p id="9b1b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">解决方案基于<a class="ae kl" href="https://jenkins.io/" rel="noopener ugc nofollow" target="_blank"> Jenkins </a>和<a class="ae kl" href="https://github.com/jenkinsci/kubernetes-plugin" rel="noopener ugc nofollow" target="_blank">T28】Jenkins-kubernetes-pluginT30。Jenkins可以在不同的</a><a class="ae kl" href="https://wiki.jenkins.io/display/JENKINS/Distributed+builds" rel="noopener ugc nofollow" target="_blank">代理节点</a>上运行任务，而插件使得在Kubernetes上动态创建这些节点成为可能。代理节点仅在任务执行时创建，之后会被删除。</p><p id="7569" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们需要首先定义代理节点pod模板。OpenShift的<a class="ae kl" href="https://access.redhat.com/containers/?tab=overview#/registry.access.redhat.com/openshift3/jenkins-2-rhel7" rel="noopener ugc nofollow" target="_blank"> jenkins-master </a>映像带有用于<em class="km"> maven </em>和<em class="km"> nodejs </em>构建的<a class="ae kl" href="https://github.com/openshift/jenkins/blob/master/2/contrib/jenkins/kube-slave-common.sh" rel="noopener ugc nofollow" target="_blank">预定义pod模板</a>，管理员可以将这种“静态”pod模板添加到插件配置中。</p><p id="e6f5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">幸运的是，如果我们使用<a class="ae kl" href="https://jenkins.io/doc/book/pipeline/syntax/" rel="noopener ugc nofollow" target="_blank"> Jenkins pipeline </a>，也可以在项目中直接为代理节点定义pod模板。这显然是一种更灵活的方式，因为整个执行环境可以由开发团队用代码来维护。让我们看一个例子:</p><figure class="ku kv kw kx gt ky"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="2a59" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个管道将创建所有的容器，这些容器在同一个pod中运行给定的Docker映像。这意味着容器将共享<em class="km"> localhost </em>接口，因此服务可以访问彼此的端口(但是我们必须考虑端口绑定冲突)。这是OpenShift web控制台中运行窗格的外观:</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi mu"><img src="../Images/f7518c1a8590336b992d6e28ebc31e62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lgyzyfq8fIif8pqcudyvpg.png"/></div></div></figure><p id="efa9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这些图像由它们的Docker url设置(这里不支持OpenShift图像流)，因此集群必须访问这些注册表。在上面的例子中，我们之前在同一个Kubernetes集群中构建了应用程序的映像，现在从内部注册表中提取它:<em class="km">172 . 30 . 1 . 1(docker-registry . default . SVC)</em>。这个映像实际上是我们的发布包，可以部署到开发、测试或生产环境中。它从一个<a class="ae kl" href="https://github.com/bszeti/kubernetes-integration-test/blob/master/app-users/src/main/resources/application-k8sit.properties" rel="noopener ugc nofollow" target="_blank"> <em class="km"> k8sit </em> </a>应用程序属性概要文件开始，其中连接URL指向<em class="km"> 127.0.0.1。</em></p><blockquote class="kn ko kp"><p id="de89" class="jn jo km jp b jq jr js jt ju jv jw jx kq jz ka kb kr kd ke kf ks kh ki kj kk ij bi translated">考虑运行java进程的容器的内存使用是很重要的。java的当前版本(v1.8，v1.9)默认忽略了<a class="ae kl" href="https://docs.openshift.com/container-platform/3.9/dev_guide/application_memory_sizing.html#sizing-openjdk" rel="noopener ugc nofollow" target="_blank">容器内存</a>的限制，并设置了更高的堆大小。3.9版<a class="ae kl" href="https://access.redhat.com/containers/?tab=overview#/search/jenkins%2520slave" rel="noopener ugc nofollow" target="_blank"> jenkins-slave镜像</a>通过<a class="ae kl" href="https://docs.openshift.com/container-platform/3.9/using_images/other_images/jenkins.html#jenkins-environment-variables" rel="noopener ugc nofollow" target="_blank">环境变量</a>支持内存限制，比早期版本好得多。设置<em class="iq">JNLP _最大_堆_上限_MB=64 </em>足以让我们在512MiB的限制下运行maven任务。</p></blockquote><p id="8ca9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">pod内的所有容器都有一个共享的<em class="km">空目录</em>卷，安装在<em class="km"> /home/jenkins </em>(默认<em class="km"> workingDir </em>)。Jenkins代理使用它在容器中运行管道步骤脚本，这是我们检查集成测试存储库的地方。这也是执行这些步骤的当前控制器，除非它们在<em class="km"> dir('relative_dir') </em>块中。以上示例的管道步骤如下:</p><figure class="ku kv kw kx gt ky"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="be34" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">管道步骤在<em class="km"> jnlp </em>容器上运行，除非它们在<em class="km">容器(' container_name') </em>块内:</p><ul class=""><li id="0a8c" class="md me iq jp b jq jr ju jv jy mf kc mg kg mh kk mi mj mk ml bi translated">首先，我们检查集成项目的源代码。在这种情况下，它位于回购协议中的<em class="km">集成测试</em>子目录中。</li><li id="c378" class="md me iq jp b jq mm ju mn jy mo kc mp kg mq kk mi mj mk ml bi translated">我们有<em class="km"> sql/setup.sh </em>脚本来创建表并在数据库中加载测试数据。它需要<em class="km"> mysql </em>工具，所以必须在<em class="km"> mariadb </em>容器中运行。</li><li id="4d77" class="md me iq jp b jq mm ju mn jy mo kc mp kg mq kk mi mj mk ml bi translated">我们的应用程序(<em class="km"> app-users </em>)调用了一个Rest API。我们没有启动这个服务的映像，所以我们使用<a class="ae kl" href="http://mock-server.com/" rel="noopener ugc nofollow" target="_blank"> MockServer </a>来启动http端点。它是由<em class="km"> mockserver/setup.sh. </em>配置的</li><li id="eac4" class="md me iq jp b jq mm ju mn jy mo kc mp kg mq kk mi mj mk ml bi translated">集成测试是用Java和Junit编写的，由Maven执行。它可能是任何其他东西—这只是我们熟悉的堆栈。</li></ul><p id="35f0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<a class="ae kl" href="https://v1-9.docs.kubernetes.io/docs/reference/generated/kubernetes-api/v1.9/#pod-v1-core" rel="noopener ugc nofollow" target="_blank"> Kubernetes resource </a> api之后的<a class="ae kl" href="https://github.com/jenkinsci/kubernetes-plugin#pod-and-container-template-configuration" rel="noopener ugc nofollow" target="_blank"> podTemplate </a>和<a class="ae kl" href="https://github.com/jenkinsci/kubernetes-plugin#container-configuration" rel="noopener ugc nofollow" target="_blank"> containerTemplate </a>有大量的配置参数，只是略有不同。例如，环境变量既可以在容器级别定义，也可以在pod级别定义。可以将卷添加到pod，但是它们被装载到每个容器的同一个<em class="km">装载路径:</em></p><pre class="ku kv kw kx gt mv mw mx my aw mz bi"><span id="a817" class="lf lg iq mw b gy na nb l nc nd">podTemplate(...<br/>  containers: [...], <br/>  volumes:[<br/>      configMapVolume(mountPath: '/etc/myconfig', <br/>        configMapName: 'my-settings'),<br/>      persistentVolumeClaim(mountPath: '/home/jenkins/myvolume', <br/>        claimName:'myclaim')<br/>      ],<br/>  envVars: [<br/>     envVar(key: 'ENV_NAME', value: 'my-k8sit')<br/>   ]<br/>)</span></pre><h2 id="1faa" class="lf lg iq bd lh li lj dn lk ll lm dp ln jy lo lp lq kc lr ls lt kg lu lv lw lx bi translated">听起来很容易，但是…</h2><p id="d2cd" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">在同一个pod中运行多个容器是连接它们的好方法，但是如果我们的容器有不同用户id的入口点，我们可能会遇到一个问题。Docker映像曾经以根用户<em class="km">的身份运行进程，但是由于<a class="ae kl" href="https://opensource.com/business/14/7/docker-security-selinux" rel="noopener ugc nofollow" target="_blank">安全问题</a>，不建议在生产环境中使用，因此许多映像切换到非根用户。不幸的是，不同的映像可能使用不同的<em class="km">uid</em>(docker file中的用户)，如果它们使用相同的卷，这可能会导致文件权限问题。</em></p><p id="eab6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这种情况下，冲突的来源是<em class="km"> workingDir </em>卷(<em class="km">/home/Jenkins/workspace/</em>)上的Jenkins工作区。这用于管道执行和保存每个容器中的步骤输出。如果我们在<em class="km">容器(…) </em>块中有步骤，并且这个映像中的<em class="km"> uid </em>与<em class="km"> jnlp </em>容器中的不同(非根),我们将得到以下错误:</p><pre class="ku kv kw kx gt mv mw mx my aw mz bi"><span id="da8e" class="lf lg iq mw b gy na nb l nc nd">touch: cannot touch '/home/jenkins/workspace/k8sit-basic/integration-test@tmp/durable-aa8f5204/jenkins-log.txt': Permission denied</span></pre><p id="33e0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们来看看我们的例子中使用的图像中的<em class="km">用户</em>:</p><ul class=""><li id="8ce1" class="md me iq jp b jq jr ju jv jy mf kc mg kg mh kk mi mj mk ml bi translated">詹金斯-slave-maven  : uid 1001，guid 0</li><li id="15fb" class="md me iq jp b jq mm ju mn jy mo kc mp kg mq kk mi mj mk ml bi translated">mariadb  : uid 27，guid 27</li><li id="ddff" class="md me iq jp b jq mm ju mn jy mo kc mp kg mq kk mi mj mk ml bi translated">amq  : uid 185，guid 0</li><li id="0630" class="md me iq jp b jq mm ju mn jy mo kc mp kg mq kk mi mj mk ml bi translated"><a class="ae kl" href="https://github.com/jamesdbloom/mockserver/blob/master/docker/Dockerfile" rel="noopener ugc nofollow" target="_blank"> mockserver </a> : uid 0，guid 0(需要<a class="ae kl" href="https://blog.openshift.com/understanding-service-accounts-sccs/" rel="noopener ugc nofollow" target="_blank"> <em class="km"> anyuid </em> </a>)</li><li id="a1c0" class="md me iq jp b jq mm ju mn jy mo kc mp kg mq kk mi mj mk ml bi translated"><a class="ae kl" href="https://github.com/fabric8io-images/s2i/blob/master/java/images/rhel/Dockerfile" rel="noopener ugc nofollow" target="_blank">fuse-Java-open shift</a>:uid 185，guid 0</li></ul><p id="4795" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="km"> jnlp </em>容器中默认的<em class="km"> umask </em>是0022，所以uid为185和uid为27的容器中的步骤会遇到权限问题。解决方法是更改<em class="km"> jnlp </em>容器中的默认<em class="km"> umask </em>，以便任何<em class="km"> uid: </em>都可以访问<em class="km">工作区</em></p><figure class="ku kv kw kx gt ky"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="1816" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在运行集成测试之前，查看首先构建应用程序和Docker映像的整个Jenkins file:<a class="ae kl" href="https://github.com/bszeti/kubernetes-integration-test/blob/master/Jenkinsfile" rel="noopener ugc nofollow" target="_blank">kubernetes-integration-test/Jenkins file</a></p><blockquote class="kn ko kp"><p id="ddf9" class="jn jo km jp b jq jr js jt ju jv jw jx kq jz ka kb kr kd ke kf ks kh ki kj kk ij bi translated">在这些例子中，集成测试在<em class="iq"> jnlp </em>容器上运行，因为我们为我们的测试项目选择了Java和Maven，并且<a class="ae kl" href="https://access.redhat.com/containers/?tab=overview#/registry.access.redhat.com/openshift3/jenkins-slave-maven-rhel7" rel="noopener ugc nofollow" target="_blank"><em class="iq">Jenkins-slave-Maven</em></a>映像可以执行它。这当然不是强制性的，我们可以使用<a class="ae kl" href="https://access.redhat.com/containers/?tab=overview#/registry.access.redhat.com/openshift3/jenkins-slave-base-rhel7" rel="noopener ugc nofollow" target="_blank"><em class="iq">Jenkins-slave-base</em></a>镜像作为<em class="iq"> jnlp </em>并有一个单独的容器来执行测试。请看一个例子，我们有意将<em class="iq"> jnlp </em>分开，并为maven使用另一个容器:<a class="ae kl" href="https://github.com/bszeti/kubernetes-integration-test/blob/master/Jenkinsfile-jnlp-base" rel="noopener ugc nofollow" target="_blank">kubernetes-integration-test/Jenkins file-jnlp-base</a></p></blockquote><h2 id="e167" class="lf lg iq bd lh li lj dn lk ll lm dp ln jy lo lp lq kc lr ls lt kg lu lv lw lx bi translated">Yaml模板</h2><p id="2e3f" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">podTemplate和containerTemplate定义支持许多配置，但是它们缺少一些参数。例如:</p><ul class=""><li id="fd00" class="md me iq jp b jq jr ju jv jy mf kc mg kg mh kk mi mj mk ml bi translated">无法从ConfigMap分配环境变量，只能从Secret分配。</li><li id="0e4e" class="md me iq jp b jq mm ju mn jy mo kc mp kg mq kk mi mj mk ml bi translated">无法为容器设置就绪探测器。Kubernetes报告说，如果没有它们，pod会在启动容器后立即运行。Jenkins将在流程实际准备好接受请求之前开始执行这些步骤。这可能会由于比赛条件而导致失败。这些示例管道通常工作正常，因为<em class="km"> checkout scm </em>为容器启动提供了足够的时间。当然一个<a class="ae kl" href="https://jenkins.io/doc/pipeline/steps/workflow-basic-steps/#code-sleep-code-sleep" rel="noopener ugc nofollow" target="_blank"> <em class="km">睡眠</em> </a>是有帮助的，但是定义就绪探测器才是正确的方法。</li></ul><p id="7bd8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">作为最终的解决方案，kubernetes-plugin (v1.5+)中的podTemplate()增加了一个<em class="km"> yaml </em>参数。它支持完整的Kubernetes Pod <a class="ae kl" href="https://v1-9.docs.kubernetes.io/docs/reference/generated/kubernetes-api/v1.9/#pod-v1-core" rel="noopener ugc nofollow" target="_blank">资源定义</a>，因此我们可以为Pod定义任何配置:</p><figure class="ku kv kw kx gt ky"><div class="bz fp l di"><div class="ms mt l"/></div></figure><blockquote class="kn ko kp"><p id="1f46" class="jn jo km jp b jq jr js jt ju jv jw jx kq jz ka kb kr kd ke kf ks kh ki kj kk ij bi translated">确保更新Jenkins中的Kubernetes插件(到1.5以上)，否则yaml参数会被忽略。</p></blockquote><p id="5979" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Yaml定义和其他podTemplate参数应该以某种方式合并，但是只使用其中一个不容易出错。在管道中定义yaml内联可能很难理解，请看这个从<a class="ae kl" href="https://github.com/bszeti/kubernetes-integration-test/blob/master/pod.yaml" rel="noopener ugc nofollow" target="_blank">文件</a>:<a class="ae kl" href="https://github.com/bszeti/kubernetes-integration-test/blob/master/Jenkinsfile-yaml" rel="noopener ugc nofollow" target="_blank">kubernetes-integration-test/Jenkins file-YAML</a>中加载它的例子</p><h2 id="8252" class="lf lg iq bd lh li lj dn lk ll lm dp ln jy lo lp lq kc lr ls lt kg lu lv lw lx bi translated">声明性管道语法</h2><p id="bc25" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">上面所有的示例管道都使用了<a class="ae kl" href="https://jenkins.io/doc/book/pipeline/syntax/#scripted-pipeline" rel="noopener ugc nofollow" target="_blank"> <em class="km">脚本管道</em> </a>语法，这实际上是一个带有<a class="ae kl" href="https://jenkins.io/doc/pipeline/steps/" rel="noopener ugc nofollow" target="_blank">管道步骤</a>的groovy脚本。<a class="ae kl" href="https://jenkins.io/doc/book/pipeline/syntax/#declarative-pipeline" rel="noopener ugc nofollow" target="_blank"> <em class="km">声明管道</em> </a> <em class="km"> </em>语法是一种新的方法，通过提供较少的灵活性和不允许“groovy hacks”来在脚本上实施更多的结构。这会产生更干净的代码，但是在复杂的情况下，您可能必须切换回脚本语法。</p><p id="05a0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在声明性管道中，kubernetes-plugin (v1.7+) <a class="ae kl" href="https://github.com/jenkinsci/kubernetes-plugin#declarative-pipeline" rel="noopener ugc nofollow" target="_blank">只支持yaml </a>定义来定义pod:</p><figure class="ku kv kw kx gt ky"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="1d28" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">也可以为每个阶段设置不同的代理，如:<br/><a class="ae kl" href="https://github.com/bszeti/kubernetes-integration-test/blob/master/Jenkinsfile-declarative" rel="noopener ugc nofollow" target="_blank">kubernetes-integration-test/Jenkins file-declarative</a></p><h2 id="9f99" class="lf lg iq bd lh li lj dn lk ll lm dp ln jy lo lp lq kc lr ls lt kg lu lv lw lx bi translated">在Minishift上试试</h2><p id="04ae" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">如果您想尝试上述解决方案，您需要访问Kubernetes集群。在Red Hat，我们使用<a class="ae kl" href="https://www.redhat.com/en/technologies/cloud-computing/openshift" rel="noopener ugc nofollow" target="_blank"> OpenShift </a>，这是k8s的企业版。有几种方法可以访问完整规模的集群:</p><ul class=""><li id="9339" class="md me iq jp b jq jr ju jv jy mf kc mg kg mh kk mi mj mk ml bi translated"><a class="ae kl" href="https://www.openshift.com/products/container-platform/" rel="noopener ugc nofollow" target="_blank">在您自己的基础设施上开放移位容器平台</a></li><li id="d317" class="md me iq jp b jq mm ju mn jy mo kc mp kg mq kk mi mj mk ml bi translated"><a class="ae kl" href="https://www.openshift.com/products/dedicated/" rel="noopener ugc nofollow" target="_blank"> OpenShift专用</a>集群托管在公共云上</li><li id="0605" class="md me iq jp b jq mm ju mn jy mo kc mp kg mq kk mi mj mk ml bi translated"><a class="ae kl" href="https://www.openshift.com/products/online/" rel="noopener ugc nofollow" target="_blank"> OpenShift Online </a>按需公共环境</li></ul><p id="5ab3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">还可以在本地机器上运行一个小型的单节点集群，这可能是最简单的尝试方式。让我们看看如何设置<a class="ae kl" href="https://developers.redhat.com/products/cdk/" rel="noopener ugc nofollow" target="_blank">红帽CDK </a>(或<a class="ae kl" href="https://kubernetes.io/docs/getting-started-guides/minikube/" rel="noopener ugc nofollow" target="_blank">迷你库贝</a>)来运行我们的测试。</p><p id="7298" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下载后，<a class="ae kl" href="https://access.redhat.com/documentation/en-us/red_hat_container_development_kit/3.4/html/getting_started_guide/index" rel="noopener ugc nofollow" target="_blank">准备</a>Minishift环境:</p><ul class=""><li id="b249" class="md me iq jp b jq jr ju jv jy mf kc mg kg mh kk mi mj mk ml bi translated">运行设置:<br/> <code class="fe ne nf ng mw b">minishift setup-cdk</code></li><li id="e533" class="md me iq jp b jq mm ju mn jy mo kc mp kg mq kk mi mj mk ml bi translated">将内部Docker注册表设置为不安全:<br/> <code class="fe ne nf ng mw b">minishift config set insecure-registry 172.30.0.0/16<br/></code>这是必需的，因为kubernetes-plugin直接从非https的内部注册表中提取图像。</li><li id="8c65" class="md me iq jp b jq mm ju mn jy mo kc mp kg mq kk mi mj mk ml bi translated">启动Minishift虚拟机(使用你的免费<a class="ae kl" href="https://developers.redhat.com/register/" rel="noopener ugc nofollow" target="_blank">红帽账号</a> ): <br/> <code class="fe ne nf ng mw b">minishift --username me@mymail.com --password ... --memory 4GB start</code></li><li id="22ae" class="md me iq jp b jq mm ju mn jy mo kc mp kg mq kk mi mj mk ml bi translated">记下控制台url，或者您可以通过:<br/> <code class="fe ne nf ng mw b">minishift console --url</code>获得它</li><li id="a28b" class="md me iq jp b jq mm ju mn jy mo kc mp kg mq kk mi mj mk ml bi translated">添加oc工具到<br/>路径:<code class="fe ne nf ng mw b">eval $(minishift oc-env)</code></li><li id="6b29" class="md me iq jp b jq mm ju mn jy mo kc mp kg mq kk mi mj mk ml bi translated">登录open shift API(admin/admin):<br/><code class="fe ne nf ng mw b">oc login <a class="ae kl" href="https://192.168.42.84:8443" rel="noopener ugc nofollow" target="_blank">https://192.168.42.84:8443</a></code></li></ul><p id="9fbd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用可用模板在集群内启动一个Jenkins主服务器:<br/> <code class="fe ne nf ng mw b">oc new-app --template=jenkins-persistent -p MEMORY_LIMIT=1024Mi</code></p><p id="174c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦Jenkins启动，它应该可以通过模板创建的路由使用，例如(<em class="km">https://Jenkins-my project . 192 . 168 . 42 . 84 . nip . io)</em>。登录与OpenShift (admin/admin)集成。</p><p id="1865" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">创建一个新的<em class="km">管道</em>项目，该项目从指向具有<a class="ae kl" href="https://github.com/bszeti/kubernetes-integration-test/blob/master/Jenkinsfile" rel="noopener ugc nofollow" target="_blank"> <em class="km"> Jenkinsfile </em> </a>的<em class="km"> Git </em>库(例如<a class="ae kl" href="https://github.com/bszeti/kubernetes-integration-test.git" rel="noopener ugc nofollow" target="_blank">https://github.com/bszeti/kubernetes-integration-test.git</a>)的SCM 获取<em class="km">管道脚本来执行。然后简单的<em class="km">现在建</em>。</em></p><p id="9bc1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第一次运行需要更长时间，因为图像是从Docker注册表下载的。如果一切顺利，我们可以在Jenkins build的<em class="km">控制台输出</em>上看到测试执行。可以在OpenShift控制台上的<em class="km"> My Project / pods下看到动态创建的Pods。</em></p><p id="6923" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果出现问题，请尝试通过以下方式进行调查:</p><ul class=""><li id="5639" class="md me iq jp b jq jr ju jv jy mf kc mg kg mh kk mi mj mk ml bi translated">Jenkins构建输出</li><li id="eacc" class="md me iq jp b jq mm ju mn jy mo kc mp kg mq kk mi mj mk ml bi translated">詹金斯主吊舱日志</li><li id="ea23" class="md me iq jp b jq mm ju mn jy mo kc mp kg mq kk mi mj mk ml bi translated">Jenkins kubernetes-插件配置</li><li id="3427" class="md me iq jp b jq mm ju mn jy mo kc mp kg mq kk mi mj mk ml bi translated">创建pod的事件(<em class="km"> maven </em>或<em class="km">集成测试</em></li><li id="bbd6" class="md me iq jp b jq mm ju mn jy mo kc mp kg mq kk mi mj mk ml bi translated">已创建窗格的日志</li></ul><p id="b97e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您想让额外的执行更快，您可以使用一个卷作为本地maven存储库，这样maven就不必每次都下载依赖项。创建一个PersistentVolumeClaim:</p><pre class="ku kv kw kx gt mv mw mx my aw mz bi"><span id="4a0a" class="lf lg iq mw b gy na nb l nc nd"># oc create -f - &lt;&lt;EOF<br/>kind: PersistentVolumeClaim<br/>apiVersion: v1<br/>metadata:<br/>  name: mavenlocalrepo<br/>spec:<br/>  accessModes:<br/>    - ReadWriteOnce<br/>  resources:<br/>    requests:<br/>      storage: 10Gi<br/>EOF</span></pre><p id="96d2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将该卷添加到podTemplate(以及可选的kubernetes-plugin中的<em class="km"> maven </em>模板)。参见<a class="ae kl" href="https://github.com/bszeti/kubernetes-integration-test/blob/master/Jenkinsfile-mavenlocalrepo" rel="noopener ugc nofollow" target="_blank">kubernetes-integration-test/Jenkins file-mavenlocalrepo</a>:</p><pre class="ku kv kw kx gt mv mw mx my aw mz bi"><span id="1706" class="lf lg iq mw b gy na nb l nc nd">volumes: [ <br/>  persistentVolumeClaim( mountPath: '/home/jenkins/.m2/repository', <br/>    claimName: 'mavenlocalrepo') <br/>]</span></pre><blockquote class="kn ko kp"><p id="7ad4" class="jn jo km jp b jq jr js jt ju jv jw jx kq jz ka kb kr kd ke kf ks kh ki kj kk ij bi translated">注意:Maven本地存储库声称是“非线程安全的”,不应该被多个构建同时使用。我们在这里使用ReadWriteOnce声明，它一次只能装载到一个pod。</p></blockquote><p id="485f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">jenkins-2-rhel7:v3.9 镜像安装了kubernetes-plugin v1.2。要运行<a class="ae kl" href="https://github.com/bszeti/kubernetes-integration-test/blob/master/Jenkinsfile-declarative" rel="noopener ugc nofollow" target="_blank">Jenkins file-declarative</a>和<a class="ae kl" href="https://github.com/bszeti/kubernetes-integration-test/blob/master/Jenkinsfile-yaml" rel="noopener ugc nofollow" target="_blank"> Jenkinsfile-yaml </a>示例，您需要将Jenkins中的插件更新到v1.7+。</p><p id="1f37" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要在停止Minishift后完全清除，请删除<em class="km"> ~/。微移</em>目录。</p><h2 id="dc1d" class="lf lg iq bd lh li lj dn lk ll lm dp ln jy lo lp lq kc lr ls lt kg lu lv lw lx bi translated">限制</h2><p id="b268" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">我还想在这里提到上述解决方案的某些方面。每个项目都是不同的，因此了解这些因素对您的影响非常重要:</p><ul class=""><li id="c5c4" class="md me iq jp b jq jr ju jv jy mf kc mg kg mh kk mi mj mk ml bi translated">使用<em class="km">Jenkins-kubernetes-plugin</em>创建测试环境独立于集成测试本身。测试可以用任何语言编写，可以用任何测试框架执行——这是一项巨大的能力，但也是一项重大的责任。</li><li id="ba5e" class="md me iq jp b jq mm ju mn jy mo kc mp kg mq kk mi mj mk ml bi translated">整个测试pod在测试执行之前创建，之后关闭。这里没有提供在测试执行期间管理容器的解决方案。可以用不同的pod模板将您的测试划分到不同的阶段，但是这会增加很多复杂性。</li><li id="3a2b" class="md me iq jp b jq mm ju mn jy mo kc mp kg mq kk mi mj mk ml bi translated">容器在第一个管道步骤执行之前启动。来自集成测试项目的文件在那时是不可访问的，所以我们不能运行准备脚本或者为那些过程提供配置文件。</li><li id="b889" class="md me iq jp b jq mm ju mn jy mo kc mp kg mq kk mi mj mk ml bi translated">所有容器都属于同一个pod，因此它们必须在同一个节点上运行。如果我们需要许多容器，而pod需要太多资源，则可能没有节点可用于运行pod。</li><li id="f77f" class="md me iq jp b jq mm ju mn jy mo kc mp kg mq kk mi mj mk ml bi translated">集成测试环境的规模应该保持在较低的水平。尽管可以在一个pod内启动多个微服务并运行端到端测试，但是所需容器的数量会迅速增加。这种环境也不是测试高可用性和可伸缩性需求的理想环境。</li><li id="5eb4" class="md me iq jp b jq mm ju mn jy mo kc mp kg mq kk mi mj mk ml bi translated">每次执行都会重新创建测试pod，但是很明显，容器的状态仍然会在运行期间保持不变。这意味着单独的测试用例并不是相互独立的。如果需要的话，在它们之间做一些清理是测试项目的责任。</li></ul><h2 id="4c47" class="lf lg iq bd lh li lj dn lk ll lm dp ln jy lo lp lq kc lr ls lt kg lu lv lw lx bi translated">摘要</h2><p id="afa7" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">通过使用Jenkins pipeline和kubernetes-plugin，在由代码动态创建的环境中运行集成测试相对容易。我们只需要一个Kubernetes集群和一些容器经验。幸运的是，越来越多的平台在公共注册中心之一提供官方Docker图像。最坏的情况是我们必须自己造一些。准备管道和集成测试的忙碌回报很快，特别是当我们想要在应用程序的生命周期中尝试不同的配置或依赖版本升级时。</p><p id="d8c7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">测试愉快！</p><blockquote class="kn ko kp"><p id="0279" class="jn jo km jp b jq jr js jt ju jv jw jx kq jz ka kb kr kd ke kf ks kh ki kj kk ij bi translated">感谢<a class="nh ni ep" href="https://medium.com/u/5cf86c655e2a?source=post_page-----ae0fb71e207b--------------------------------" rel="noopener" target="_blank">戴维·约翰斯顿</a>的贡献。</p></blockquote></div></div>    
</body>
</html>