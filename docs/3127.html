<html>
<head>
<title>📦 React-Imported-Component v6</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">📦反应导入组件v6</h1>
<blockquote>原文：<a href="https://itnext.io/react-imported-component-v6-430a51ed8186?source=collection_archive---------3-----------------------#2019-10-08">https://itnext.io/react-imported-component-v6-430a51ed8186?source=collection_archive---------3-----------------------#2019-10-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="0ded" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">React-imported-component v6是第一个带有暴露的<strong class="jp ir"> hooks API </strong>的代码拆分库，也是第一个<strong class="jp ir"> Create-React-App兼容的</strong>库，这要感谢babel <strong class="jp ir">宏</strong>的支持。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/1139367752f69cb9ceff35d403bb3133.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ppLu4Wd4vysfIW9Lz_yYQA.jpeg"/></div></div></figure><p id="6e4c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这艘船上有你可能需要的一切:先进的，简单的API，<strong class="jp ir">服务器端渲染</strong>支持，加载优化，可以处理任何情况。下面是对比表:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kx"><img src="../Images/eb45c4e038dd77b3617b338f5f7136d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*nMk2WocAbDyif-C_.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">功能对照表</figcaption></figure><p id="b05d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">准备好了吗？跳进来！</p><div class="lc ld gp gr le lf"><a href="https://github.com/theKashey/react-imported-component" rel="noopener  ugc nofollow" target="_blank"><div class="lg ab fo"><div class="lh ab li cl cj lj"><h2 class="bd ir gy z fp lk fr fs ll fu fw ip bi translated">kashey/react-导入组件</h2><div class="lm l"><h3 class="bd b gy z fp lk fr fs ll fu fw dk translated">它真的永远不会让你失望。一切都归功于你的bundler。阅读有关此表显示的内容的更多信息关键…</h3></div><div class="ln l"><p class="bd b dl z fp lk fr fs ll fu fw dk translated">github.com</p></div></div><div class="lo l"><div class="lp l lq lr ls lo lt kv lf"/></div></div></a></div><h1 id="bbbb" class="lu lv iq bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">使用进口挂钩</h1><p id="a4a3" class="pw-post-body-paragraph jn jo iq jp b jq ms js jt ju mt jw jx jy mu ka kb kc mv ke kf kg mw ki kj kk ij bi translated">懒加载不仅仅是关于<code class="fe mx my mz na b">React.lazy</code>和<code class="fe mx my mz na b">Components</code>——在任何变体的背后，除了一个动态的<code class="fe mx my mz na b">import</code>，它能够加载绝对的一切。您所需要的是一个适当的“反应集成”来管理加载状态。</p><pre class="km kn ko kp gt nb na nc nd aw ne bi"><span id="9861" class="nf lv iq na b gy ng nh l ni nj">// a STATIC table with imports<br/>const languages = {<br/>  'en': () =&gt; import('./i18n/en'), // it's probably a json...<br/>  'de': () =&gt; import('./i18n/de'),<br/>}<br/>// just a helper function<br/>const pickLanguage = (lng) =&gt; languages[lng];<br/>// your component</span><span id="36cb" class="nf lv iq na b gy nk nh l ni nj">const MyI18nProvider = ({lng, children}) =&gt; {<br/>  // let's pick and provide correct import function for our language<br/>  const {<br/>   imported: messages = {} // defaulting to empty object<br/>  } = useImported(pickLanguage(lng));</span><span id="a0c3" class="nf lv iq na b gy nk nh l ni nj">  // set messages to the Provider<br/>  return &lt;I18nProvider value={messages}&gt;{children}&lt;/I18nProvider&gt;<br/>}</span></pre><p id="937d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">仅此而已。一旦呈现了这个组件，所需的语言将被导入并提供给上下文。您可以选择如何处理加载状态——通过设置一个<code class="fe mx my mz na b">default</code>值，抛出到最近的<code class="fe mx my mz na b">Suspense</code>，或者显示其他内容。这是个圈套——你想干什么就干什么。</p><p id="ca0f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mx my mz na b">useImported</code>可以加载你想要的任何东西，任何其他由<code class="fe mx my mz na b">react-imported-component</code>公开的API都建立在它的基础上。</p><h1 id="967a" class="lu lv iq bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">导入模块和导入模块</h1><p id="2f19" class="pw-post-body-paragraph jn jo iq jp b jq ms js jt ju mt jw jx jy mu ka kb kc mv ke kf kg mw ki kj kk ij bi translated"><code class="fe mx my mz na b">useImported</code>并不总是最佳选择，有时更具<em class="nl">宣示性的</em>可能更好。你知道，声明式是我们喜欢的反应。<br/>于是，就有了一个助手，通过react <strong class="jp ir">渲染道具</strong>接口导入你想要的任何东西。对于大多数人来说，这种模式更好地被称为<a class="ae nm" href="https://www.smooth-code.com/open-source/loadable-components/docs/library-splitting/" rel="noopener ugc nofollow" target="_blank"> loadable.lib </a>(然而它最初是为导入而引入的)</p><pre class="km kn ko kp gt nb na nc nd aw ne bi"><span id="f76d" class="nf lv iq na b gy ng nh l ni nj">import {importedModule, ImportedModule} from 'react-imported-component';</span><span id="98b3" class="nf lv iq na b gy nk nh l ni nj">// you can use it to codesplit and  use `momentjs`, no offence :)<br/>const Moment = importedModule(() =&gt; import('moment'));</span><span id="83d5" class="nf lv iq na b gy nk nh l ni nj">&lt;Moment fallback="long time ago"&gt;<br/>  {(momentjs /* default imports are auto-imported*/) =&gt; momentjs(date).fromNow()}<br/>&lt;/Moment&gt;</span><span id="9bcc" class="nf lv iq na b gy nk nh l ni nj">// or, again, translations</span><span id="1991" class="nf lv iq na b gy nk nh l ni nj">&lt;ImportedModule<br/> import={() =&gt; import('./i18n/en')}<br/> // fallback="..." // will throw to the Suspense boundary without fallback provided<br/>&gt;<br/> {(messages) =&gt; &lt;I18nProvider value={messages}&gt;{children}&lt;/I18nProvider&gt; }<br/>&lt;/ImportedModule&gt;</span></pre><h1 id="c163" class="lu lv iq bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">进口又懒</h1><p id="6da0" class="pw-post-body-paragraph jn jo iq jp b jq ms js jt ju mt jw jx jy mu ka kb kc mv ke kf kg mw ki kj kk ij bi translated">还有两个“通用”API—<code class="fe mx my mz na b">imported</code>和<code class="fe mx my mz na b">lazy</code>。<br/>其中<code class="fe mx my mz na b">lazy</code> -嘎嘎叫的像个<code class="fe mx my mz na b">React.lazy</code>，<strong class="jp ir">是</strong>懒于生产，而<code class="fe mx my mz na b">imported</code>是，嗯，用兼容代码拆分库<em class="nl">第一代</em>的API导入的老货。</p><pre class="km kn ko kp gt nb na nc nd aw ne bi"><span id="7111" class="nf lv iq na b gy ng nh l ni nj">const Component = importedComponent( () =&gt; import('./Component'), {<br/>  LoadingComponent: Spinner, // what to display during the loading<br/>  ErrorComponent: FatalError // what to display in case of error<br/>});</span><span id="6edd" class="nf lv iq na b gy nk nh l ni nj">Component.preload(); // force preload</span><span id="b79f" class="nf lv iq na b gy nk nh l ni nj">// render it<br/>&lt;Component... /&gt;</span></pre><h1 id="ef66" class="lu lv iq bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">额外的东西</h1><h1 id="7473" class="lu lv iq bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">创建React应用支持</h1><p id="e528" class="pw-post-body-paragraph jn jo iq jp b jq ms js jt ju mt jw jx jy mu ka kb kc mv ke kf kg mw ki kj kk ij bi translated">关于CRA，你应该知道三件事:</p><ul class=""><li id="d331" class="nn no iq jp b jq jr ju jv jy np kc nq kg nr kk ns nt nu nv bi translated">很难改变项目的配置，我们鼓励你不要这样做</li><li id="8ac7" class="nn no iq jp b jq nw ju nx jy ny kc nz kg oa kk ns nt nu nv bi translated">它支持SSR或预渲染</li><li id="22be" class="nn no iq jp b jq nw ju nx jy ny kc nz kg oa kk ns nt nu nv bi translated">这使得更好的代码分割变得有点复杂</li></ul><p id="5440" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，尽管其他SSR友好的代码分解解决方案需要<strong class="jp ir"> babel </strong>和<strong class="jp ir"> webpack </strong>插件才能工作，但<code class="fe mx my mz na b">react-imported-component</code>不需要webpack中的任何东西，它是独立于bundler的，并提供了一个<strong class="jp ir"> babel宏</strong>，这是CRA唯一开箱即用的东西。</p><p id="9066" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就用<code class="fe mx my mz na b">react-imported-component/macro</code>，收工</p><pre class="km kn ko kp gt nb na nc nd aw ne bi"><span id="4f30" class="nf lv iq na b gy ng nh l ni nj">import {imported} from "react-imported-component/macro";</span><span id="4041" class="nf lv iq na b gy nk nh l ni nj">imported(()=&gt;import('./aGoodDay'));</span></pre><p id="f4d3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在任何其他情况下也可以随意使用宏——它们比babel插件使用起来要方便得多，并且会使您的代码更具可移植性和可重用性。</p><h1 id="428b" class="lu lv iq bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">联邦独立</h1><p id="54b4" class="pw-post-body-paragraph jn jo iq jp b jq ms js jt ju mt jw jx jy mu ka kb kc mv ke kf kg mw ki kj kk ij bi translated">这又意味着3件不同的事情:</p><ul class=""><li id="35bf" class="nn no iq jp b jq jr ju jv jy np kc nq kg nr kk ns nt nu nv bi translated">它与<strong class="jp ir">包裹捆绑器兼容</strong>，或汇总，或系统js。你用哪个捆扎机并不重要——他们可以一起玩。</li><li id="3e7f" class="nn no iq jp b jq nw ju nx jy ny kc nz kg oa kk ns nt nu nv bi translated">它是<a class="ae nm" href="https://github.com/stereobooster/react-snap" rel="noopener ugc nofollow" target="_blank">反应式快照</a>兼容的。“使用追踪”从未停止，在一个无头浏览器中呈现你的页面后，你可能会问它——“你需要再次呈现相同的哪些块”，并得到一个列表。(有关详细信息，请阅读react-snap文档)。</li><li id="9e74" class="nn no iq jp b jq nw ju nx jy ny kc nz kg oa kk ns nt nu nv bi translated">它与非托管的【真实T2】一起工作。我的意思是未受污染的es进口，你可能会使用真正的ESM模块。基本没关系。</li><li id="c5c3" class="nn no iq jp b jq nw ju nx jy ny kc nz kg oa kk ns nt nu nv bi translated">它<strong class="jp ir">不如其他具有更深bunlder集成的代码分割解决方案有效，因此它们可以在SSR期间刷新使用过的块。正如我所说——的确如此。</strong></li></ul><h1 id="ed11" class="lu lv iq bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">正在加载业务流程</h1><p id="a6d6" class="pw-post-body-paragraph jn jo iq jp b jq ms js jt ju mt jw jx jy mu ka kb kc mv ke kf kg mw ki kj kk ij bi translated">让脚本再水合更快的第一个方法是让加载过程更高效。<code class="fe mx my mz na b">imported-component</code>提供了一个独立的入口点- <code class="fe mx my mz na b">/boot</code>在主脚本评估之前启动初始化过程，因此加载延迟脚本有点“早”。一个伟大的解决方案，为CRA或包裹，在那里你可能不知道真实的名字块文件(没有额外的插件安装)内联到HTML。</p><pre class="km kn ko kp gt nb na nc nd aw ne bi"><span id="1afc" class="nf lv iq na b gy ng nh l ni nj">import "../async-requires";<br/>import {injectLoadableTracker} from "react-imported-component/boot";<br/>// ^ just 1kb</span><span id="1d19" class="nf lv iq na b gy nk nh l ni nj">// injects runtime<br/>injectLoadableTracker('importedMarks');<br/></span><span id="ca47" class="nf lv iq na b gy nk nh l ni nj">// give browser a tick to kick off script loading<br/>Promise.resolve().then(() =&gt;<br/>  Promise.resolve().then(() =&gt; { <br/>    // the rest of your application<br/>    // imported with a little "pause"<br/>    require('./main')<br/>  })<br/>);</span></pre><p id="f7bc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这很简单，有趣的是——你的js被解析，被评估，但是<strong class="jp ir">没有完全执行</strong>。然后<code class="fe mx my mz na b">imported</code>将触发加载呈现页面所需的块，然后您的应用程序将继续执行。</p><p id="bd77" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我提供两个lighthouse快照(4x减速，3Mb JS包)来解释这个想法:</p><ul class=""><li id="7837" class="nn no iq jp b jq jr ju jv jy np kc nq kg nr kk ns nt nu nv bi translated">在“双重承诺”中要求<code class="fe mx my mz na b">main</code>，如上例所示</li></ul><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kx"><img src="../Images/7e91219e92b559e28bb98ceeb1a8b525.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zIv77nLt31FZzRI02rRS9Q.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">3500毫秒加载脚本</figcaption></figure><ul class=""><li id="07d5" class="nn no iq jp b jq jr ju jv jy np kc nq kg nr kk ns nt nu nv bi translated">在承诺中不需要<code class="fe mx my mz na b">main</code>，就像上面的例子一样(只是把它移到了<code class="fe mx my mz na b">catch</code>，所以它没有被执行。但是，所有代码仍然在包中)</li></ul><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kx"><img src="../Images/78de2d783b9b1dea915ba013e79cdc38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*oegh9_oVT2f_-SUh.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">更快的解析和评估，这是相同的脚本！</figcaption></figure><p id="25ad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以——我们需要4200毫秒来解析和执行整个脚本，而只需要400毫秒就可以到达“初始块”(别忘了我们说的是x6减速)。这就给了3800秒来加载其他所需的块。免费的。</p><p id="7291" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里有一个火焰图来解释这种巨大的差异。这是一个“第一”，左边部分是“最初的大块”，右边是“双重承诺”。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kx"><img src="../Images/b18e8d4bae77469975d3f73827d2ec35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*nyBhxIEBudf3sRZn.png"/></div></div></figure><p id="fea1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意左边的小“时间盒”,右边是给浏览器的微任务“T1 ”,用来启动网络内容。</p><p id="5750" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在给浏览器一些时间来做它的工作，并开始处理新的请求后，执行继续，这里是“第一”和“第二”块。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kx"><img src="../Images/02d08e9303e04e760fbfd2b8c3815ee0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*DF4SYe3EfeeMKoPT.png"/></div></div></figure><blockquote class="ob oc od"><p id="6b27" class="jn jo nl jp b jq jr js jt ju jv jw jx oe jz ka kb of kd ke kf og kh ki kj kk ij bi translated">注意第一个“时间盒”有多小</p></blockquote><p id="624b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这使得所有这些事情，比如脚本预加载和预取，变得不那么重要了——有了它们会更好，但即使没有它们,<em class="nl">也不会太差。因此，你可能有良好的SSR与CRA开箱即用。或者良好的CRS，通过一些预测和预加载。</em></p><p id="7c01" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果不好，那就更好…</p><h1 id="d0d0" class="lu lv iq bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">深度Webpack集成</h1><p id="b826" class="pw-post-body-paragraph jn jo iq jp b jq ms js jt ju mt jw jx jy mu ka kb kc mv ke kf kg mw ki kj kk ij bi translated">然而，最好的结果需要更细粒度的方法。v6的另一个变化——一个单独的webpack集成包——将会有所帮助。名字很明显:</p><div class="lc ld gp gr le lf"><a href="https://github.com/theKashey/webpack-imported" rel="noopener  ugc nofollow" target="_blank"><div class="lg ab fo"><div class="lh ab li cl cj lj"><h2 class="bd ir gy z fp lk fr fs ll fu fw ip bi translated">kashey/web pack-已导入</h2><div class="lm l"><h3 class="bd b gy z fp lk fr fs ll fu fw dk translated">我们会以正确的方式进口你们的屁股。📝stats-web pack-插件和💩webpack-flush-chunks有宝宝了！这将…</h3></div><div class="ln l"><p class="bd b dl z fp lk fr fs ll fu fw dk translated">github.com</p></div></div></div></a></div><p id="26c7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一个用于收集数据的webpack插件和一个服务器端API，包括(可选的)React绑定，用于处理开箱即用的一切。</p><pre class="km kn ko kp gt nb na nc nd aw ne bi"><span id="8ec5" class="nf lv iq na b gy ng nh l ni nj">import importedData from 'build/imported.json';</span><span id="ae04" class="nf lv iq na b gy nk nh l ni nj">&lt;WebpackImport<br/>   stats={importedData}<br/>   chunks={getMarkedChunks(marks)}<br/>   publicPath={importedData.config.publicPath}<br/>   crossOrigin={CDN_ANONYMOUS}<br/>/&gt;</span></pre><h1 id="2a57" class="lu lv iq bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">半铸钢ˌ钢性铸铁(Cast Semi-Steel)</h1><p id="be24" class="pw-post-body-paragraph jn jo iq jp b jq ms js jt ju mt jw jx jy mu ka kb kc mv ke kf kg mw ki kj kk ij bi translated">CSS也以最好的方式处理——用<strong class="jp ir">关键风格提取</strong>为普通的CSS文件开箱即用。</p><div class="lc ld gp gr le lf"><a href="https://github.com/theKashey/used-styles" rel="noopener  ugc nofollow" target="_blank"><div class="lg ab fo"><div class="lh ab li cl cj lj"><h2 class="bd ir gy z fp lk fr fs ll fu fw ip bi translated">时尚/旧风格</h2><div class="lm l"><h3 class="bd b gy z fp lk fr fs ll fu fw dk translated">获取所有你用来渲染页面的样式。捆绑器和框架独立的CSS部分的SSR友好的代码…</h3></div><div class="ln l"><p class="bd b dl z fp lk fr fs ll fu fw dk translated">github.com</p></div></div><div class="lo l"><div class="oh l lq lr ls lo lt kv lf"/></div></div></a></div><p id="0ecb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上面所有的库都一起测试过，他们一起玩得很好。</p><h1 id="6abf" class="lu lv iq bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">流动</h1><p id="9474" class="pw-post-body-paragraph jn jo iq jp b jq ms js jt ju mt jw jx jy mu ka kb kc mv ke kf kg mw ki kj kk ij bi translated">所有使用的库都有流友好的API，并且能够提供你正在寻找的最好的TTFB。</p><h1 id="219a" class="lu lv iq bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">为什么为什么为什么</h1><p id="faa8" class="pw-post-body-paragraph jn jo iq jp b jq ms js jt ju mt jw jx jy mu ka kb kc mv ke kf kg mw ki kj kk ij bi translated">如果你在寻找为什么要进行代码拆分，拆分什么，何时进行代码拆分，以及如何优化JS或CSS交付的答案。</p><div class="lc ld gp gr le lf"><a href="https://dev.to/thekashey/code-splitting-what-when-and-why-59op" rel="noopener  ugc nofollow" target="_blank"><div class="lg ab fo"><div class="lh ab li cl cj lj"><h2 class="bd ir gy z fp lk fr fs ll fu fw ip bi translated">✂️电码化-什么，什么时候，为什么</h2><div class="lm l"><h3 class="bd b gy z fp lk fr fs ll fu fw dk translated">什么？字面上是一个“什么”，一个“东西”，通常是一个组件。你还想要什么？什么时候？很难…</h3></div><div class="ln l"><p class="bd b dl z fp lk fr fs ll fu fw dk translated">开发到</p></div></div><div class="lo l"><div class="oi l lq lr ls lo lt kv lf"/></div></div></a></div><div class="lc ld gp gr le lf"><a href="https://dev.to/thekashey/optimising-js-delivery-4h6l" rel="noopener  ugc nofollow" target="_blank"><div class="lg ab fo"><div class="lh ab li cl cj lj"><h2 class="bd ir gy z fp lk fr fs ll fu fw ip bi translated">🛳优化JS交付</h2><div class="lm l"><h3 class="bd b gy z fp lk fr fs ll fu fw dk translated">从底层脚本交付系统中获得最大收益</h3></div><div class="ln l"><p class="bd b dl z fp lk fr fs ll fu fw dk translated">开发到</p></div></div><div class="lo l"><div class="oj l lq lr ls lo lt kv lf"/></div></div></a></div><div class="lc ld gp gr le lf"><a href="https://dev.to/thekashey/optimising-css-delivery-57eh" rel="noopener  ugc nofollow" target="_blank"><div class="lg ab fo"><div class="lh ab li cl cj lj"><h2 class="bd ir gy z fp lk fr fs ll fu fw ip bi translated">🎨优化CSS交付</h2><div class="lm l"><h3 class="bd b gy z fp lk fr fs ll fu fw dk translated">如果我告诉你——交付JS是一个超级简单的任务，而交付CSS是非常非常复杂的……</h3></div><div class="ln l"><p class="bd b dl z fp lk fr fs ll fu fw dk translated">开发到</p></div></div><div class="lo l"><div class="ok l lq lr ls lo lt kv lf"/></div></div></a></div><h1 id="cd31" class="lu lv iq bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">结论</h1><ul class=""><li id="d70a" class="nn no iq jp b jq ms ju mt jy ol kc om kg on kk ns nt nu nv bi translated">钩子API</li><li id="0d94" class="nn no iq jp b jq nw ju nx jy ny kc nz kg oa kk ns nt nu nv bi translated">加载模块</li><li id="2ca9" class="nn no iq jp b jq nw ju nx jy ny kc nz kg oa kk ns nt nu nv bi translated">加载组件</li><li id="15ad" class="nn no iq jp b jq nw ju nx jy ny kc nz kg oa kk ns nt nu nv bi translated">使用服务器端跟踪</li><li id="ea7a" class="nn no iq jp b jq nw ju nx jy ny kc nz kg oa kk ns nt nu nv bi translated">babel宏支持</li><li id="a245" class="nn no iq jp b jq nw ju nx jy ny kc nz kg oa kk ns nt nu nv bi translated">不绑定到webpack，但是支持更深入的浏览器集成</li><li id="39c2" class="nn no iq jp b jq nw ju nx jy ny kc nz kg oa kk ns nt nu nv bi translated">专为您打造！</li></ul><p id="3c02" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">👉<a class="ae nm" href="https://github.com/theKashey/react-imported-component" rel="noopener ugc nofollow" target="_blank">https://github.com/theKashey/react-imported-component</a></p></div></div>    
</body>
</html>