<html>
<head>
<title>RxJS operators: retry vs repeat?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">RxJS运算符:重试还是重复？</h1>
<blockquote>原文：<a href="https://itnext.io/rxjs-operators-retry-vs-repeat-26028ca1744a?source=collection_archive---------7-----------------------#2019-05-30">https://itnext.io/rxjs-operators-retry-vs-repeat-26028ca1744a?source=collection_archive---------7-----------------------#2019-05-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><blockquote class="jn"><p id="1b72" class="jo jp iq bd jq jr js jt ju jv jw jx dk translated">那么RxJS中重试和重复的区别是什么？学习这两个操作符的简洁用例有助于您更好地理解它们。</p></blockquote><figure class="jz ka kb kc kd ke gh gi paragraph-image"><div role="button" tabindex="0" class="kf kg di kh bf ki"><div class="gh gi jy"><img src="../Images/b649e9bae5cdfa092a6dfad3cf150d23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RBROoyxJP89gdUU55hTeyQ.jpeg"/></div></div><figcaption class="kl km gj gh gi kn ko bd b be z dk translated">Elle Florio的一个镜头</figcaption></figure><h1 id="fde5" class="kq kr iq bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">介绍</h1><p id="3749" class="pw-post-body-paragraph lo lp iq lq b lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk jx ij bi translated">几年前，当我刚开始学习RxJS时，我不太明白为什么RxJS中有两个操作符用于重复逻辑。不仅我可能有这样的疑问，所以在本文中，我将回顾<strong class="lq ir">重试</strong>和<strong class="lq ir">重复</strong>操作符以及它们可能的用例。</p><h1 id="def8" class="kq kr iq bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">重试…还是重复？</h1><p id="4af8" class="pw-post-body-paragraph lo lp iq lq b lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk jx ij bi translated">在RxJS中，<strong class="lq ir"> repeat </strong>和<strong class="lq ir"> retry </strong>操作符都允许您有条件地重新订阅它们所应用到的终止源可观察对象。<br/>两者都使源可观测序列将被重新启动。</p><p id="2f50" class="pw-post-body-paragraph lo lp iq lq b lr ml lt lu lv mm lx ly lz mn mb mc md mo mf mg mh mp mj mk jx ij bi translated">主要区别是</p><p id="a73f" class="pw-post-body-paragraph lo lp iq lq b lr ml lt lu lv mm lx ly lz mn mb mc md mo mf mg mh mp mj mk jx ij bi translated"><strong class="lq ir">重复</strong> —收到onComplete()时重新订阅，但不是错误。<br/> <strong class="lq ir">重试</strong> —收到onError()时重新订阅。</p><p id="2a8f" class="pw-post-body-paragraph lo lp iq lq b lr ml lt lu lv mm lx ly lz mn mb mc md mo mf mg mh mp mj mk jx ij bi translated">就可能的用例而言:</p><blockquote class="mq mr ms"><p id="c7e5" class="lo lp mt lq b lr ml lt lu lv mm lx ly mu mn mb mc mv mo mf mg mw mp mj mk jx ij bi translated"><em class="iq">如果你想重复成功的数据提取，使用</em> <strong class="lq ir"> <em class="iq">重复</em> </strong> <em class="iq">。<br/>如果您想在可观察对象中重复失败的数据提取—使用</em> <strong class="lq ir"> <em class="iq">重试</em> </strong> <em class="iq">。</em></p></blockquote><p id="25d6" class="pw-post-body-paragraph lo lp iq lq b lr ml lt lu lv mm lx ly lz mn mb mc md mo mf mg mh mp mj mk jx ij bi translated">现在，让我们通过示例详细了解一下它们。</p><h1 id="eaa7" class="kq kr iq bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">重试</h1><blockquote class="mq mr ms"><p id="7871" class="lo lp mt lq b lr ml lt lu lv mm lx ly mu mn mb mc mv mo mf mg mw mp mj mk jx ij bi translated"><strong class="lq ir"> <em class="iq">【重试次数】</em> </strong></p></blockquote><p id="07a6" class="pw-post-body-paragraph lo lp iq lq b lr ml lt lu lv mm lx ly lz mn mb mc md mo mf mg mh mp mj mk jx ij bi translated">它返回反映源可观测值的可观测值，但有一个错误。<br/>如果源可观察调用出错，该方法将重新订阅为源可观察，最多有<em class="mt">次</em>次重新订阅</p><p id="8d03" class="pw-post-body-paragraph lo lp iq lq b lr ml lt lu lv mm lx ly lz mn mb mc md mo mf mg mh mp mj mk jx ij bi translated"><strong class="lq ir">计数</strong> —失败前重试事件的次数。默认值为-1。</p><figure class="my mz na nb gt ke gh gi paragraph-image"><div role="button" tabindex="0" class="kf kg di kh bf ki"><div class="gh gi mx"><img src="../Images/d2c25844533da0223ce74c075786f5bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XaU8bdHtry0ZAWdSnG1FmA.png"/></div></div><figcaption class="kl km gj gh gi kn ko bd b be z dk translated"><strong class="bd ks">重试</strong>大理石图</figcaption></figure><p id="b103" class="pw-post-body-paragraph lo lp iq lq b lr ml lt lu lv mm lx ly lz mn mb mc md mo mf mg mh mp mj mk jx ij bi translated">这是一个处理不稳定网络连接的普通JS示例。我们进行可观察包装的Ajax调用并使用重试操作符。如果第一次ajax调用返回错误，重试操作符将再次执行Ajax请求三次。<br/>如果其中一次尝试成功，它将为下一次用户回拨提供数据。<br/>如果另外三次尝试都失败，则错误将通过错误回调处理程序传播给订户。</p><figure class="my mz na nb gt ke"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="3a79" class="pw-post-body-paragraph lo lp iq lq b lr ml lt lu lv mm lx ly lz mn mb mc md mo mf mg mh mp mj mk jx ij bi translated">让我们试着在<a class="ae kp" href="https://codepen.io/kievsash/pen/zXevvo?editors=0010" rel="noopener ugc nofollow" target="_blank">代码笔</a>中运行它。</p><p id="a070" class="pw-post-body-paragraph lo lp iq lq b lr ml lt lu lv mm lx ly lz mn mb mc md mo mf mg mh mp mj mk jx ij bi translated">正如您所看到的，我们有一个失败的请求和4次重试尝试(它们都失败了，因为出于学习目的，我们试图到达不存在的url)。</p><figure class="my mz na nb gt ke gh gi paragraph-image"><div role="button" tabindex="0" class="kf kg di kh bf ki"><div class="gh gi ne"><img src="../Images/a7abd65fc1179cba32ad8bb3b492dbb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Mac8JrNoEdfeS6ZAvWyx5g.png"/></div></div></figure><h1 id="cf18" class="kq kr iq bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">总结一下:</h1><ol class=""><li id="3e2f" class="nf ng iq lq b lr ls lv lw lz nh md ni mh nj jx nk nl nm nn bi translated"><strong class="lq ir">重试</strong>返回镜像源可观察对象的可观察对象。</li><li id="5ba8" class="nf ng iq lq b lr no lv np lz nq md nr mh ns jx nk nl nm nn bi translated">如果源可观察调用出错，该方法将重新订阅源可观察(重复运行源序列)，最多可重新订阅count param值。</li><li id="aebb" class="nf ng iq lq b lr no lv np lz nq md nr mh ns jx nk nl nm nn bi translated">如果其中一次重试运行成功，事件数据将提供给订户的下一个回调处理程序。如果所有重试运行都失败—错误将传播到onError处理程序。</li><li id="a246" class="nf ng iq lq b lr no lv np lz nq md nr mh ns jx nk nl nm nn bi translated">一个可能的用例— ajax失败的请求重试。</li></ol><h1 id="59b6" class="kq kr iq bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">重复</h1><blockquote class="mq mr ms"><p id="e014" class="lo lp mt lq b lr ml lt lu lv mm lx ly mu mn mb mc mv mo mf mg mw mp mj mk jx ij bi translated"><strong class="lq ir"> <em class="iq">【重复计数】</em> </strong></p></blockquote><p id="bca8" class="pw-post-body-paragraph lo lp iq lq b lr ml lt lu lv mm lx ly lz mn mb mc md mo mf mg mh mp mj mk jx ij bi translated">返回一个可观察对象，该可观察对象最多重复源可观察对象发出的项目流<em class="mt">计数</em>次。</p><p id="5417" class="pw-post-body-paragraph lo lp iq lq b lr ml lt lu lv mm lx ly lz mn mb mc md mo mf mg mh mp mj mk jx ij bi translated"><strong class="lq ir">计数</strong> —源可观测项目重复的次数，计数为0将产生空可观测项目。默认值为-1。</p><figure class="my mz na nb gt ke gh gi paragraph-image"><div role="button" tabindex="0" class="kf kg di kh bf ki"><div class="gh gi mx"><img src="../Images/3653d9cccd2631a8cc1fd9e5a498ff8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-icF-MiGQQGaD2xNQVQSTQ.png"/></div></div><figcaption class="kl km gj gh gi kn ko bd b be z dk translated"><strong class="bd ks">重复</strong>大理石图</figcaption></figure><p id="58d1" class="pw-post-body-paragraph lo lp iq lq b lr ml lt lu lv mm lx ly lz mn mb mc md mo mf mg mh mp mj mk jx ij bi translated">看看这个例子:</p><figure class="my mz na nb gt ke gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/d0404a96b7f8cff52007e494d1e15fe1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*Deec6l5BgainBkr_.png"/></div></figure><p id="b143" class="pw-post-body-paragraph lo lp iq lq b lr ml lt lu lv mm lx ly lz mn mb mc md mo mf mg mh mp mj mk jx ij bi translated">我们提取源序列并运行两次。<br/>注意<em class="mt">重复</em>操作员将初始运行视为第一次运行。</p><p id="f255" class="pw-post-body-paragraph lo lp iq lq b lr ml lt lu lv mm lx ly lz mn mb mc md mo mf mg mh mp mj mk jx ij bi translated">现在让我们来看看更复杂的用例——比方说，我们有一个后端，但它不是一次带来所有数据，而是按页带来。因此，让我们实现从后端获取特定数量的分页数据部分:</p><figure class="my mz na nb gt ke"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="1180" class="pw-post-body-paragraph lo lp iq lq b lr ml lt lu lv mm lx ly lz mn mb mc md mo mf mg mh mp mj mk jx ij bi translated">在我描述这段代码之前——注意我们在RxJS的<strong class="lq ir"> defer </strong>函数中包装了源可观察对象。每次当<em class="mt"> repeat </em> operator重新运行source observable时——<em class="mt">defer</em>将为其工厂函数提供资金——因此我们的url将具有更新的计数器值。你可以在这里阅读更多关于<em class="mt">推迟</em>T21</p><p id="c063" class="pw-post-body-paragraph lo lp iq lq b lr ml lt lu lv mm lx ly lz mn mb mc md mo mf mg mh mp mj mk jx ij bi translated">现在让我们观察它是如何工作的:</p><ol class=""><li id="2279" class="nf ng iq lq b lr ml lv mm lz nu md nv mh nw jx nk nl nm nn bi translated">当我们订阅时，source第一次调用page = 0(计数器变量)。</li><li id="c68c" class="nf ng iq lq b lr no lv np lz nq md nr mh ns jx nk nl nm nn bi translated">成功获取数据后，我们将数据发送给订阅者。然后源可观察性完成—因此<em class="mt">重复</em>开始工作—并重新运行源—在我们的例子中是<em class="mt">延迟</em>功能。</li><li id="be5e" class="nf ng iq lq b lr no lv np lz nq md nr mh ns jx nk nl nm nn bi translated">Defer函数调用其工厂函数，并返回带有新计数器值的ajax observable。所以现在我们用page = 1请求API。</li><li id="c7dd" class="nf ng iq lq b lr no lv np lz nq md nr mh ns jx nk nl nm nn bi translated">新的数据页也被发送给订阅者。</li></ol><p id="20c5" class="pw-post-body-paragraph lo lp iq lq b lr ml lt lu lv mm lx ly lz mn mb mc md mo mf mg mh mp mj mk jx ij bi translated">您可以尝试在<a class="ae kp" href="https://codepen.io/kievsash/pen/EJrKoj?editors=0010" rel="noopener ugc nofollow" target="_blank"> codepen </a>中运行这段代码。</p><h1 id="0b94" class="kq kr iq bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">总结一下:</h1><ol class=""><li id="1dd1" class="nf ng iq lq b lr ls lv lw lz nh md ni mh nj jx nk nl nm nn bi translated"><strong class="lq ir"> repeat </strong>返回一个可观察对象，它重复源可观察对象发出的项目流最多<em class="mt"> count </em>次。</li><li id="558f" class="nf ng iq lq b lr no lv np lz nq md nr mh ns jx nk nl nm nn bi translated"><strong class="lq ir"> count </strong> param —源可观察项目重复的次数，计数为0将产生空可观察项目。与retry-repeat运算符不同，它将初始源$ run视为第一次尝试，因此该源将被重复(count-1)次。</li><li id="8abd" class="nf ng iq lq b lr no lv np lz nq md nr mh ns jx nk nl nm nn bi translated"><strong class="lq ir">重复</strong> —从源序列接收到onComplete()时重新订阅，但不是错误。</li><li id="493f" class="nf ng iq lq b lr no lv np lz nq md nr mh ns jx nk nl nm nn bi translated">如果您需要源可观测值以不同的参数重复——使用RxJS延迟函数。</li></ol><h1 id="0858" class="kq kr iq bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">我们能一起使用它们吗？</h1><p id="c220" class="pw-post-body-paragraph lo lp iq lq b lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk jx ij bi translated">我们可以用这两个<strong class="lq ir">重试</strong>和<strong class="lq ir">重复</strong>吗？<br/>肯定是的！如果您想要重复源请求，并在其中一个重复调用失败时重试—您可以使用两个运算符。</p><p id="36a7" class="pw-post-body-paragraph lo lp iq lq b lr ml lt lu lv mm lx ly lz mn mb mc md mo mf mg mh mp mj mk jx ij bi translated">在这个例子中，我们用<strong class="lq ir"> repeat </strong>操作符请求分页信息两次。如果某些请求失败，重试将重新运行它。</p><figure class="my mz na nb gt ke"><div class="bz fp l di"><div class="nc nd l"/></div></figure><h1 id="91d7" class="kq kr iq bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">retryWhen和repeatWhen</h1><p id="d952" class="pw-post-body-paragraph lo lp iq lq b lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk jx ij bi translated">当我第一次看到<strong class="lq ir"> retry </strong>和<strong class="lq ir"> repeat </strong>操作符的例子时，我的想法是——我能在重试ajax调用之间增加一些延迟吗？<br/>这是运算符<strong class="lq ir"> <em class="mt"> retryWhen </em> </strong>和<strong class="lq ir"> <em class="mt"> repeatWhen </em> </strong>发挥作用的时候——不过这是另一篇文章的主题——<a class="ae kp" href="https://twitter.com/El_Extremal" rel="noopener ugc nofollow" target="_blank">让我们保持联系</a>！</p><figure class="my mz na nb gt ke gh gi paragraph-image"><a href="http://eepurl.com/gHF0av"><div class="gh gi nx"><img src="../Images/e39daa364c50029b206bdc057d2b3487.png" data-original-src="https://miro.medium.com/v2/resize:fit:1188/format:webp/1*33AyiLH06Tzu-9KxL1hZjg.png"/></div></a></figure><h1 id="bfce" class="kq kr iq bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">其他链接:</h1><ol class=""><li id="5946" class="nf ng iq lq b lr ls lv lw lz nh md ni mh nj jx nk nl nm nn bi translated"><a class="ae kp" href="https://blog.angularindepth.com/rxjs-repeat-operator-beginner-necromancer-guide-391a3b2ad3ad" rel="noopener ugc nofollow" target="_blank">RxJS‘重复’操作者——初级死灵法师指南</a>。</li><li id="7e9a" class="nf ng iq lq b lr no lv np lz nq md nr mh ns jx nk nl nm nn bi translated"><a class="ae kp" href="https://medium.com/@alexanderposhtaruk/rx-js-replywhen-use-case-in-iframe-d-angular-spa-d86d35d3bce8" rel="noopener"> Rx。iframe-d Angular SPA中的JS retryWhen用例</a></li></ol></div><div class="ab cl ny nz hu oa" role="separator"><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od"/></div><div class="ij ik il im in"><blockquote class="jn"><p id="a3d0" class="jo jp iq bd jq jr of og oh oi oj jx dk translated"><em class="ok">Packtpub.com和我准备了一整套</em> <a class="ae kp" href="https://www.packtpub.com/web-development/hands-rxjs-web-development-video" rel="noopener ugc nofollow" target="_blank"> <em class="ok"> RxJS课程</em> </a> <em class="ok">，还有许多其他细节，告诉你如何用这个神奇的库解决你的日常开发任务。它对初学者来说可能很有趣，但也包含高级主题。看一看！</em></p></blockquote></div><div class="ab cl ny nz hu oa" role="separator"><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od"/></div><div class="ij ik il im in"><p id="6539" class="pw-post-body-paragraph lo lp iq lq b lr ml lt lu lv mm lx ly lz mn mb mc md mo mf mg mh mp mj mk jx ij bi translated"><em class="mt">原发布于</em><a class="ae kp" href="https://dev.to/oleksandr/rxjs-operators-retry-vs-repeat-5gn" rel="noopener ugc nofollow" target="_blank"><em class="mt">https://dev . to</em></a><em class="mt">。</em></p><p id="8f0b" class="pw-post-body-paragraph lo lp iq lq b lr ml lt lu lv mm lx ly lz mn mb mc md mo mf mg mh mp mj mk jx ij bi translated"><em class="mt">你喜欢这篇文章吗？</em> <a class="ae kp" href="https://clicktotweet.com/az3L1" rel="noopener ugc nofollow" target="_blank"> <strong class="lq ir"> <em class="mt">发微博</em> </strong> </a> <em class="mt">关注我</em> <a class="ae kp" href="https://twitter.com/El_Extremal" rel="noopener ugc nofollow" target="_blank"> <strong class="lq ir"> <em class="mt">发微博</em></strong></a><strong class="lq ir"><em class="mt"/></strong>🤓<em class="mt">！</em></p></div></div>    
</body>
</html>