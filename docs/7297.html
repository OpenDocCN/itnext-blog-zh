<html>
<head>
<title>Concurrent Programming: why synchronizing data access is not enough</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">并发编程:为什么同步数据访问是不够的</h1>
<blockquote>原文：<a href="https://itnext.io/concurrent-programming-why-synchronizing-data-access-is-not-enough-3b74e999ef7d?source=collection_archive---------1-----------------------#2022-08-13">https://itnext.io/concurrent-programming-why-synchronizing-data-access-is-not-enough-3b74e999ef7d?source=collection_archive---------1-----------------------#2022-08-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="1827" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">同步数据访问解决了并发编程的许多挑战。如果正确实现，您可以确保一次只允许一个工作流处理代码的共享部分。</p><p id="7494" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">另一方面，一个常见的问题是忘记原始数据(变量、属性/字段、对象等。)并不是唯一需要同步访问的数据。</p><h1 id="8ae3" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">陷阱</h1><p id="aabb" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">由于共享对象而检索或计算的数据可能会在您使用它隐藏微妙的错误之前被不同的线程/进程无效。例如，对于互斥体，只要您希望由于共享数据而做出的任何决定保持有效，就应该保持对共享数据的锁定。</p><blockquote class="lo"><p id="fe8a" class="lp lq iq bd lr ls lt lu lv lw lx kk dk translated">一旦释放了独占锁，由于共享数据而检索或计算的所有内容都可能不再有效</p></blockquote><h2 id="ea45" class="ly km iq bd kn lz ma dn kr mb mc dp kv jy md me kz kc mf mg ld kg mh mi lh mj bi translated">方案</h2><blockquote class="mk ml mm"><p id="9a36" class="jn jo mn jp b jq jr js jt ju jv jw jx mo jz ka kb mp kd ke kf mq kh ki kj kk ij bi translated">下面的代码展示了一个关于这个问题的虚拟例子，以及如何在带有<em class="iq">互斥</em> 的<a class="ae mr" href="https://gobyexample.com/mutexes" rel="noopener ugc nofollow" target="_blank"> <em class="iq"> Golang </em>中重现这个问题，但是你可能会在带有<em class="iq">同步方法</em>的<em class="iq"> Java </em>中遇到同样的问题。</a></p></blockquote><p id="533f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让五个Goroutines同时增加一个计数器会导致不同步的问题。使用互斥体，您可以强制一次只有一个Gorouting来作用于计数器值，并保护自己免受意外行为的影响。</p><figure class="mt mu mv mw gt mx gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi ms"><img src="../Images/ad8059b8b7c56751601096852a18bb73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hafqG_2z2t40Va5DB_L7ug.png"/></div></div></figure><p id="7264" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">另一方面，即使数据访问总是与互斥体同步，您也不能依赖任何检索到的信息来检查计数器的值。</p><p id="8c2b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦你释放了互斥体，任何由于数据而做出的决定现在都是过时的和误导的。</p><figure class="mt mu mv mw gt mx gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi ne"><img src="../Images/b853d9210bdaf148c83942ecac199ae6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4dVaZPK1KRRsLEF5WiBCYg.png"/></div></div></figure><p id="5d4e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">即使没有其他的Goroutine可以直接访问<code class="fe nf ng nh ni b">okToIncrease</code>，也有可能该变量在计算后立即无效。</p><pre class="mt mu mv mw gt nj ni nk nl aw nm bi"><span id="f0b1" class="ly km iq ni b gy nn no l np nq"><strong class="ni ir">if </strong>okToIncrease := d.isSafeToIncrease(); okToIncrease{<br/>   d.increase()<br/>}</span></pre><p id="4cad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，即使方法<code class="fe nf ng nh ni b">isSafeToIncrease</code>和<code class="fe nf ng nh ni b">increase</code>都利用互斥体来访问计数器，只要您进入<code class="fe nf ng nh ni b">if</code>语句，Goroutine就可能被暂停，当恢复时，您就面临溢出的风险。</p><p id="9e14" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是因为锁定机制是在错误的级别实现的，忽略了数据是如何被使用的，并且我们应该“锁定”我们做出的决定。</p><h1 id="6cd2" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">代码</h1><blockquote class="mk ml mm"><p id="4c3d" class="jn jo mn jp b jq jr js jt ju jv jw jx mo jz ka kb mp kd ke kf mq kh ki kj kk ij bi translated">你可以在这里查看代码示例<a class="ae mr" href="https://github.com/paologallinaharbur/concurrency" rel="noopener ugc nofollow" target="_blank"/></p></blockquote><p id="1ee0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如具有带有互斥体的共享计数器，以同步来自不同例程的访问:</p><pre class="mt mu mv mw gt nj ni nk nl aw nm bi"><span id="27aa" class="ly km iq ni b gy nn no l np nq"><strong class="ni ir">const <em class="mn">maxCounter </em></strong>= 10<br/><br/><strong class="ni ir">type </strong>data <strong class="ni ir">struct </strong>{<br/>   m       sync.Mutex<br/>   counter int<br/>}<br/><br/><strong class="ni ir">func </strong>(d *data) isSafeToIncrease() bool {<br/>   d.m.Lock()<br/>   <strong class="ni ir">defer </strong>d.m.Unlock()<br/><br/>   <strong class="ni ir">return </strong>d.counter &lt; <strong class="ni ir"><em class="mn">maxCounter<br/></em></strong>}<br/><br/><strong class="ni ir">func </strong>(d *data) increase() {<br/>   d.m.Lock()<br/>   <strong class="ni ir">defer </strong>d.m.Unlock()<br/><br/>   d.counter += 1<br/>}</span></pre><p id="0260" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以测试计数器，并注意到一切似乎都在按预期工作。计数器的值似乎尊重<code class="fe nf ng nh ni b">maxCounter</code>，不会发生溢出。</p><pre class="mt mu mv mw gt nj ni nk nl aw nm bi"><span id="756d" class="ly km iq ni b gy nn no l np nq"><strong class="ni ir">func </strong>TestExample(t *testing.T) {</span><span id="492e" class="ly km iq ni b gy nr no l np nq">   d := &amp;data{<br/>      m: sync.Mutex{},<br/>   }<br/><br/>   wg := &amp;sync.WaitGroup{}<br/><br/>   wg.Add(2)<br/>   <strong class="ni ir">go </strong>increaseNTimes(wg, d, 10)<br/>   <strong class="ni ir">go </strong>increaseNTimes(wg, d, 10)<br/>   wg.Wait()<br/><br/>   require.Equal(t, <strong class="ni ir"><em class="mn">maxCounter</em></strong>, d.getCounter())<br/>}</span><span id="5ea2" class="ly km iq ni b gy nr no l np nq"><strong class="ni ir">func </strong>increaseNTimes(wg *sync.WaitGroup, d *data, n int) {<br/>   <strong class="ni ir">defer </strong>wg.Done()<br/><br/>   <strong class="ni ir">for </strong>i := 0; i &lt; n; i++ {<br/>      <strong class="ni ir">if </strong>d.isSafeToIncrease() {<br/>         d.increase()<br/>      }<br/><br/>   }<br/>   <strong class="ni ir">return<br/></strong>}</span></pre><p id="98ca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，如果我们运行相同的测试1000次，我们可以看到平均有1%的时间失败。这是一个必须发现的错误，因为这是一个只在最后一次迭代中才会发生的数据竞争。拥有更高的<em class="mn"> maxCounter将进一步减少bug的出现。</em></p><pre class="mt mu mv mw gt nj ni nk nl aw nm bi"><span id="c41e" class="ly km iq ni b gy nn no l np nq"><strong class="ni ir">func </strong>TestExample1000Times(t *testing.T) {<br/>   <strong class="ni ir">for </strong>i := 0; i &lt; 1000; i++ {<br/>      t.Run(fmt.Sprint(i), TestExample)<br/>   }<br/>}</span></pre><figure class="mt mu mv mw gt mx gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi ns"><img src="../Images/c8d96a3813460d0250a9531f7fcccd71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DSMRtTILSweBZsDtr6qZ8g.png"/></div></div><figcaption class="nt nu gj gh gi nv nw bd b be z dk translated">1000次执行中有10次失败并导致计数器溢出</figcaption></figure><p id="d805" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这种情况下，解决方案是显而易见的，但在大型代码库中，如果不锁定大部分代码，发现和修复bug可能会更加复杂。</p><pre class="mt mu mv mw gt nj ni nk nl aw nm bi"><span id="9da2" class="ly km iq ni b gy nn no l np nq">d.m.Lock()<br/><strong class="ni ir">defer </strong>d.m.Unlock()<br/><br/><strong class="ni ir">if </strong>d.counter &lt; <strong class="ni ir"><em class="mn">maxCounter </em></strong>{<br/>   d.counter += 1<br/>}</span></pre><p id="a35a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">【https://www.youtube.com/watch?v=oV9rvDllKEg】T2</p><h2 id="e05a" class="ly km iq bd kn lz nx dn kr mb ny dp kv jy nz me kz kc oa mg ld kg ob mi lh mj bi translated">外卖食品</h2><p id="4cb5" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">在一个大而复杂的代码库中，发现它可能是一个棘手的问题。<br/>要意识到这一点，特别是当你重构减少方法的大小以尊重SRP(单一责任原则)时，你可能会试图过度减少互斥体的范围。<br/>我回顾了几个结构完美、设计良好的代码挑战，但仍然存在这样的问题。</p><ul class=""><li id="f8b7" class="oc od iq jp b jq jr ju jv jy oe kc of kg og kk oh oi oj ok bi translated">原始数据(变量、属性/字段、对象等)不是唯一需要同步访问的数据。</li><li id="bbeb" class="oc od iq jp b jq ol ju om jy on kc oo kg op kk oh oi oj ok bi translated">一旦释放了独占锁，由于共享数据而检索或计算的所有内容都可能不再有效</li></ul></div></div>    
</body>
</html>