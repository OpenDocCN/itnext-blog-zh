<html>
<head>
<title>How I Debug my Python Projects — Part 1: Raising Exceptions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我如何调试我的Python项目——第1部分:引发异常</h1>
<blockquote>原文：<a href="https://itnext.io/how-i-debug-my-python-projects-part-1-raising-exceptions-6bcb07673010?source=collection_archive---------3-----------------------#2020-03-16">https://itnext.io/how-i-debug-my-python-projects-part-1-raising-exceptions-6bcb07673010?source=collection_archive---------3-----------------------#2020-03-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/a828ea653be92b806b0b353cfca091f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_3yQeisnXy3bxMNCAZx2EQ.jpeg"/></div></div></figure><p id="fb6c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我先引用埃德格·迪克斯特拉的一段话</p><blockquote class="kw kx ky"><p id="ea0b" class="jy jz kz ka b kb kc kd ke kf kg kh ki la kk kl km lb ko kp kq lc ks kt ku kv ij bi translated">如果调试是去除软件缺陷的过程，那么编程就必须是把缺陷放进去的过程</p></blockquote><p id="21fd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我的职业生涯中，我参与了许多python项目；大型、小型和中型项目。起初这并不容易，因为我相信一个好的程序员应该能够写出没有错误的代码。然而，我后来明白，最好的学习方法是犯错误，尝试，敢于和从结果中学习。我将在这里引用尼古拉斯·尼葛洛庞帝的一段话</p><blockquote class="kw kx ky"><p id="129c" class="jy jz kz ka b kb kc kd ke kf kg kh ki la kk kl km lb ko kp kq lc ks kt ku kv ij bi translated">编程让你思考问题，在调试的时候你学习学习</p></blockquote><p id="5059" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">以下是我在调试python项目时使用的技术:</p><ul class=""><li id="0bad" class="ld le iq ka b kb kc kf kg kj lf kn lg kr lh kv li lj lk ll bi translated">引发异常</li><li id="bb4d" class="ld le iq ka b kb lm kf ln kj lo kn lp kr lq kv li lj lk ll bi translated">断言</li><li id="1f17" class="ld le iq ka b kb lm kf ln kj lo kn lp kr lq kv li lj lk ll bi translated">Python日志模块</li><li id="2f57" class="ld le iq ka b kb lm kf ln kj lo kn lp kr lq kv li lj lk ll bi translated">Python调试器模块</li><li id="2e84" class="ld le iq ka b kb lm kf ln kj lo kn lp kr lq kv li lj lk ll bi translated">Python Jupyter笔记本</li></ul><p id="dbf7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本文中，我将向您介绍第一种技术— <strong class="ka ir">引发异常</strong></p><h1 id="ec8b" class="lr ls iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">引发异常</h1><p id="f240" class="pw-post-body-paragraph jy jz iq ka b kb mp kd ke kf mq kh ki kj mr kl km kn ms kp kq kr mt kt ku kv ij bi translated">当程序在执行过程中遇到错误时，就会引发异常。它们扰乱了程序的正常流程，通常会突然终止程序。异常由raise语句引发。在代码中，raise语句由以下内容组成:</p><ul class=""><li id="f362" class="ld le iq ka b kb kc kf kg kj lf kn lg kr lh kv li lj lk ll bi translated">raise关键字</li><li id="670a" class="ld le iq ka b kb lm kf ln kj lo kn lp kr lq kv li lj lk ll bi translated">对Exception()函数的调用</li><li id="30a4" class="ld le iq ka b kb lm kf ln kj lo kn lp kr lq kv li lj lk ll bi translated">一个字符串，其中包含传递给Exception()函数的有用的错误消息。</li></ul><p id="2dfc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，如果您在交互式shell中输入以下代码</p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="14f7" class="nd ls iq mz b gy ne nf l ng nh">raise Exception(“The error message goes here”)</span></pre><p id="5236" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您将得到下面的<strong class="ka ir">回溯</strong>:</p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="0d29" class="nd ls iq mz b gy ne nf l ng nh">Traceback (most recent call last):<br/>  File "&lt;stdin&gt;", line 1, in &lt;module&gt;<br/>Exception: The error message goes here</span></pre><blockquote class="kw kx ky"><p id="b4a2" class="jy jz kz ka b kb kc kd ke kf kg kh ki la kk kl km lb ko kp kq lc ks kt ku kv ij bi translated"><strong class="ka ir">回溯</strong>包括错误消息、导致错误的行的行号以及导致错误的函数调用序列。这个调用序列称为调用堆栈。</p></blockquote><p id="25f2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果没有<code class="fe ni nj nk mz b">try</code>和<code class="fe ni nj nk mz b">except</code>以及可选的<code class="fe ni nj nk mz b">else</code>来覆盖引发异常的raise语句，程序就会崩溃并显示异常错误消息。</p><h2 id="7b78" class="nd ls iq bd lt nl nm dn lx nn no dp mb kj np nq mf kn nr ns mj kr nt nu mn nv bi translated">我如何使用异常来调试代码</h2><p id="10d7" class="pw-post-body-paragraph jy jz iq ka b kb mp kd ke kf mq kh ki kj mr kl km kn ms kp kq kr mt kt ku kv ij bi translated">那么我如何使用异常来调试我的代码呢？非常好的问题。这个想法是，我检查我的代码，并检测任何可能在未来发生的潜在错误，并尽早提出这些错误。通过这种方式，我可以在错误造成很大损害并变得难以发现之前处理它们。</p><p id="b841" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我将根据我在编码时遇到的常见异常错误进行解释。</p><blockquote class="kw kx ky"><p id="a099" class="jy jz kz ka b kb kc kd ke kf kg kh ki la kk kl km lb ko kp kq lc ks kt ku kv ij bi translated">值得注意的是，异常通常被认为是用户错误。例如，每当用户输入不正确的数据或由于错误数据导致计算失败时，通常会引发异常。在大多数情况下，会处理这些异常，并提示用户输入正确的值。但在其他情况下，没有处理，程序被允许崩溃</p></blockquote><h2 id="aa50" class="nd ls iq bd lt nl nm dn lx nn no dp mb kj np nq mf kn nr ns mj kr nt nu mn nv bi translated"><strong class="ak">索引错误</strong></h2><blockquote class="kw kx ky"><p id="7c8d" class="jy jz kz ka b kb kc kd ke kf kg kh ki la kk kl km lb ko kp kq lc ks kt ku kv ij bi translated">当您试图对超出允许边界的列表、元组或字符串进行索引时引发</p></blockquote><p id="4886" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果在我的程序中，我知道我将处理索引一个列表，并且说在索引列表之前将发生的计算是复杂的并且将花费大量的时间。如果发生了<code class="fe ni nj nk mz b">IndexError</code>异常，我不想等到这个计算发生后再接收它。我要做的是，确保我要用的索引在这个范围内。让我们考虑下面的代码</p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="0263" class="nd ls iq mz b gy ne nf l ng nh">def compute_get_index(index, arr):<br/>    # Do some complex computations on the array <br/>    # that may take a lot of time<br/>    return arr[index]</span><span id="e8f2" class="nd ls iq mz b gy nw nf l ng nh">compute_get_index(8, [3,2,9])</span></pre><p id="05e4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我运行上面的函数，由于索引<code class="fe ni nj nk mz b">8</code>超出范围，程序将引发<code class="fe ni nj nk mz b">indexError</code>异常。令人不安的是，复杂的计算将在错误出现之前首先执行。因此，为了尽早发现这个错误，我将检查以确保索引在范围内。如果没有，我会抛出一个好消息作为异常。通过这种方式，我们得到了错误，并且枯燥的复杂计算不再执行</p><figure class="mu mv mw mx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nx"><img src="../Images/c639cf142d23df6112fe86e68c478fb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e504uIDRiG8BNQPWwC7ZGA.png"/></div></div></figure><h2 id="d82d" class="nd ls iq bd lt nl nm dn lx nn no dp mb kj np nq mf kn nr ns mj kr nt nu mn nv bi translated"><strong class="ak">按键错误</strong></h2><blockquote class="kw kx ky"><p id="0b7e" class="jy jz kz ka b kb kc kd ke kf kg kh ki la kk kl km lb ko kp kq lc ks kt ku kv ij bi translated">当您试图访问字典中不存在的键值时引发。</p></blockquote><p id="6c80" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">与上述<code class="fe ni nj nk mz b">IndexError</code>中的原理相同。假设您知道您将通过键访问字典，并且您不确定从用户输入或计算中获得的键是否确实在字典中。我处理这个问题的方法是，首先检查以确保它是字典中的一个键。如果不是，我会提前抛出一个<code class="fe ni nj nk mz b">KeyError</code>异常并处理它，而不是让我的代码运行到最后因为同样的错误而失败</p><figure class="mu mv mw mx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ny"><img src="../Images/eb4be7c17c4849a28f15a4bfb7596fba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*91vDpxHK1SWvtX5sLYHGMA.png"/></div></div></figure><h2 id="e2f7" class="nd ls iq bd lt nl nm dn lx nn no dp mb kj np nq mf kn nr ns mj kr nt nu mn nv bi translated">属性错误</h2><blockquote class="kw kx ky"><p id="c615" class="jy jz kz ka b kb kc kd ke kf kg kh ki la kk kl km lb ko kp kq lc ks kt ku kv ij bi translated">当进行无效的属性引用或属性赋值失败时引发</p></blockquote><p id="a5d1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这也是很常见的情况。有时，我会从None对象中调用`<code class="fe ni nj nk mz b">append</code>'方法。或者列表中的“<code class="fe ni nj nk mz b">get</code>”方法。发生这种情况是因为有时我所期望的函数或进程的输出实际上并不是这样。为了调试它，我确保检查了有问题的对象是否具有该属性。如果没有，我会提前抛出<code class="fe ni nj nk mz b">AttributeError</code>异常，处理它并继续前进。</p><figure class="mu mv mw mx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nz"><img src="../Images/ba29cba10f8489a1b0b12b0d1fb24d94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FGEgiNuqLS5kI5cb8sp3Fw.png"/></div></div></figure><p id="b6a6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从上面的代码可以看出，我希望我的对象<code class="fe ni nj nk mz b">d</code>具有属性<code class="fe ni nj nk mz b">append</code>。对于第二种情况，在我执行复杂的计算之前，我希望我的对象<code class="fe ni nj nk mz b">d</code>是一个<code class="fe ni nj nk mz b">list</code>。</p><h2 id="1114" class="nd ls iq bd lt nl nm dn lx nn no dp mb kj np nq mf kn nr ns mj kr nt nu mn nv bi translated">值错误</h2><blockquote class="kw kx ky"><p id="d9a7" class="jy jz kz ka b kb kc kd ke kf kg kh ki la kk kl km lb ko kp kq lc ks kt ku kv ij bi translated">当函数收到正确类型的参数但值不合适时引发</p></blockquote><p id="038f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个例外在很多数学运算中都会出现。例如，在数学模块方法<code class="fe ni nj nk mz b">math.sqrt()</code>中(负数的平方根引发<code class="fe ni nj nk mz b">ValueError</code>异常)。如果一个函数只适用于特定范围的值，那么当收到的参数不满足特定范围时，抛出一个<code class="fe ni nj nk mz b">ValueError</code>是合理的。</p><p id="6f02" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，如果我知道我的函数只对某个范围内的值起作用，我会确保在开始冗长乏味的复杂运算之前检查该值，这样我就能及早发现它，处理它并继续前进。</p><p id="7250" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">以下面的函数为例。我知道我的复杂运算只适用于正值。所以我要做的是检查，确保在运算中使用的值是正的。如果没有，我抛出异常，避免运行明显会失败的复杂操作，修复问题并继续前进。</p><figure class="mu mv mw mx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oa"><img src="../Images/e3891f3cecfa69aa6c21cdacb0af5433.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8L4MeRicE_6EP1E8-2P1eQ.png"/></div></div></figure><h1 id="0429" class="lr ls iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">我如何构建我的自定义异常类</h1><p id="2b6c" class="pw-post-body-paragraph jy jz iq ka b kb mp kd ke kf mq kh ki kj mr kl km kn ms kp kq kr mt kt ku kv ij bi translated">在调试期间，我们可以处理许多其他情况，例如:</p><ul class=""><li id="b5eb" class="ld le iq ka b kb kc kf kg kj lf kn lg kr lh kv li lj lk ll bi translated"><strong class="ka ir">零除法错误</strong> — <code class="fe ni nj nk mz b">raised when you try to divide by zero</code></li><li id="eb69" class="ld le iq ka b kb lm kf ln kj lo kn lp kr lq kv li lj lk ll bi translated"><strong class="ka ir">io错误</strong>——<code class="fe ni nj nk mz b">raised when an I/O operation fails for an I/O-related reason</code></li><li id="5a24" class="ld le iq ka b kb lm kf ln kj lo kn lp kr lq kv li lj lk ll bi translated"><strong class="ka ir">文件存在错误</strong> — <code class="fe ni nj nk mz b">raised when trying to create a file or directory which already exists.</code></li><li id="e845" class="ld le iq ka b kb lm kf ln kj lo kn lp kr lq kv li lj lk ll bi translated"><strong class="ka ir"> IsADirectoryError </strong> — <code class="fe ni nj nk mz b">raised when a file operation is requested on a directory</code></li><li id="1d7f" class="ld le iq ka b kb lm kf ln kj lo kn lp kr lq kv li lj lk ll bi translated"><strong class="ka ir">notdirectoryerror</strong>—<code class="fe ni nj nk mz b"> raised when a directory operation is requested on something which is not a directory.</code></li></ul><p id="2441" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在进入代码的更复杂部分之前，我使用所有这些来确保我的代码按预期工作。</p><p id="281d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在许多情况下，您可能找不到与您想要在代码中应用的约束类型相匹配的内置异常。在这种情况下，您可以创建满足您需求的自定义例外。</p><p id="6d52" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">假设您想要检查并确保某个特定值大于10。当然，你可以使用<code class="fe ni nj nk mz b">ValueError</code>，但是如果你想通过给它一个特定的和唯一的名字比如<code class="fe ni nj nk mz b">ValueSmallerThanTenError</code>来定制错误，那该怎么办呢？这就是我如何创建我的自定义异常类</p><ul class=""><li id="f764" class="ld le iq ka b kb kc kf kg kj lf kn lg kr lh kv li lj lk ll bi translated">我从基类开始。这是<a class="ae ob" href="https://docs.python.org/3/tutorial/errors.html#user-defined-exceptions" rel="noopener ugc nofollow" target="_blank">例外文件</a>说的</li></ul><blockquote class="kw kx ky"><p id="84d8" class="jy jz kz ka b kb kc kd ke kf kg kh ki la kk kl km lb ko kp kq lc ks kt ku kv ij bi translated">当创建一个可能引发几个不同错误的模块时，通常的做法是为该模块定义的异常创建一个基类，并创建该基类的子类，以便为不同的错误条件创建特定的异常类</p></blockquote><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="3cb9" class="nd ls iq mz b gy ne nf l ng nh">class MyException(Exception):<br/>    """Base class exceptions for this module"""<br/>    def __init__(self, msg):<br/>            self.msg = msg</span><span id="3551" class="nd ls iq mz b gy nw nf l ng nh">    def __str__(self):<br/>        return "{}".format(self.msg)</span></pre><p id="a0e4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我的基本异常有一个<code class="fe ni nj nk mz b">__init__()</code>方法，它接收引发的消息。它还有<code class="fe ni nj nk mz b">__str__()</code>方法，因为当引发一个异常时，我们同时创建一个异常实例并打印它。</p><ul class=""><li id="3c90" class="ld le iq ka b kb kc kf kg kj lf kn lg kr lh kv li lj lk ll bi translated">然后，我创建继承基类的不同异常类来处理特定的错误。</li></ul><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="a018" class="nd ls iq mz b gy ne nf l ng nh">class ValueSmallerThanTenError(MyException):<br/>    def __init__(self, msg="ValueSmallerThanTenError occured"):<br/>        super().__init__(msg)</span></pre><p id="9cab" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们测试我们的定制异常类</p><figure class="mu mv mw mx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oc"><img src="../Images/beb2992e0d44206d12d87d92e2430b77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*prLB_4quAb93PchvFW4wEw.png"/></div></div></figure><h1 id="cd9e" class="lr ls iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">结论</h1><p id="4770" class="pw-post-body-paragraph jy jz iq ka b kb mp kd ke kf mq kh ki kj mr kl km kn ms kp kq kr mt kt ku kv ij bi translated">这些是我使用异常来调试代码的方法。这可能是错误的方法，或者可能有人有更好的方法来使用异常调试python项目。请在评论中分享你的想法。</p><p id="004c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我的下一篇文章中，我将向您展示如何使用断言来调试我的代码。<strong class="ka ir">我希望你喜欢阅读我的文章，并发现它很有帮助。</strong></p></div></div>    
</body>
</html>