<html>
<head>
<title>Kubernetes API Priority and Fairness</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes API优先级和公平性</h1>
<blockquote>原文：<a href="https://itnext.io/kubernetes-api-priority-and-fairness-b1ef2b8a26a2?source=collection_archive---------3-----------------------#2021-01-24">https://itnext.io/kubernetes-api-priority-and-fairness-b1ef2b8a26a2?source=collection_archive---------3-----------------------#2021-01-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="eb84" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi ko translated"><span class="l kp kq kr bm ks kt ku kv kw di"> T </span>他的帖子是关于新的Kubernetes <a class="ae kx" href="https://kubernetes.io/docs/concepts/cluster-administration/flow-control/" rel="noopener ugc nofollow" target="_blank"> API优先级和公平性</a> (APF)特性。我将与您分享我所学到的知识，并向您展示如何定义策略来对Kubernetes API服务器的入站请求进行优先级排序和节流。然后，我还将介绍一些指标和调试端点，您可以使用它们来确定APF是否影响了您的控制器。</p><p id="9a57" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">🆕<em class="ky">在Kubernetes 1.20中默认启用APF，作为beta特性。对于早期版本的Kubernetes，可以通过</em> <code class="fe kz la lb lc b">APIPriorityAndFairness </code> <em class="ky">特性门</em> <a class="ae kx" href="https://kubernetes.io/docs/concepts/cluster-administration/flow-control/#enabling-disabling-api-priority-and-fairness" rel="noopener ugc nofollow" target="_blank"> <em class="ky">启用</em> </a> <em class="ky">。</em></p><h1 id="1767" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">什么是APF</h1><p id="f987" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">在APF之前，API服务器使用<code class="fe kz la lb lc b">--max-requests-inflight</code>和<code class="fe kz la lb lc b">--max-mutating-requests-inflight</code>命令行标志来调节入站请求的数量。这个实现对请求的唯一区别是请求是否是变异的。例如，它们无法确保优先级较低的流量不会淹没关键流量，如<a class="ae kx" href="https://github.com/kubernetes/kubernetes/issues/77723" rel="noopener ugc nofollow" target="_blank">本期示例</a>中所述。</p><p id="f2be" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">APF提供了一种流量控制机制，以确保API服务器能够在保证公平性的同时抑制请求。它允许平台所有者定义API级策略，将入站请求分类为不同的<em class="ky">优先级</em>和<em class="ky">流</em>。</p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi mg"><img src="../Images/333c69ab1ce8cb8b1ace69543c7ff6ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CnA0mm2IGbsmnEdMCCgrIA.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">通过流量和优先级管理请求</figcaption></figure><p id="fe39" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一般来说，所有传入的请求都根据一组<em class="ky">流模式</em>进行评估。每个请求将与一个流模式相匹配，该模式将请求分配到一个<em class="ky">优先级</em>。当某个优先级的请求被抑制时，其他优先级的请求不受影响。</p><p id="8fea" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了进一步加强优先级请求之间的公平性，匹配流模式将请求与<em class="ky">流</em>相关联，其中来自相同源的请求被分配相同的<em class="ky">流区分符</em>。</p><p id="1ee0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这些流中，不能立即执行的请求将使用<a class="ae kx" href="https://aws.amazon.com/blogs/architecture/shuffle-sharding-massive-and-magical-fault-isolation/" rel="noopener ugc nofollow" target="_blank">混洗分片</a>进行排队，这是一种常用于隔离工作负载以提高容错能力的技术<a class="ae kx" href="https://aws.amazon.com/builders-library/workload-isolation-using-shuffle-sharding/#What_is_shuffle_sharding.3F" rel="noopener ugc nofollow" target="_blank">。当有足够的容量可用时，使用一个</a><a class="ae kx" href="https://en.wikipedia.org/wiki/Fair_queuing" rel="noopener ugc nofollow" target="_blank">公平排队</a>算法来使流中的请求出列。</p><h1 id="5348" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">了解流模式和优先级配置</h1><p id="084f" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">🛠️ ️ <em class="ky">本节使用的命令通过Kubernetes 1.19测试，使用</em> <a class="ae kx" href="https://kind.sigs.k8s.io/" rel="noopener ugc nofollow" target="_blank"> <em class="ky">种类</em></a><em class="ky">v 0 . 9 . 0 .</em><code class="fe kz la lb lc b"><a class="ae kx" href="https://mikefarah.gitbook.io/yq/" rel="noopener ugc nofollow" target="_blank"><em class="ky">yq</em></a></code><em class="ky">v 4 . 3 . 1创建，用于过滤YAML输出以提高可读性。</em></p><p id="8e4f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">️️🛠️ <em class="ky">普罗米修斯操作员使用</em> <a class="ae kx" href="https://github.com/prometheus-operator/kube-prometheus" rel="noopener ugc nofollow" target="_blank"> <em class="ky">部署kube-普罗米修斯</em></a><em class="ky">0.7版本。查看kube-prometheus </em> <a class="ae kx" href="https://github.com/prometheus-operator/kube-prometheus#access-the-dashboards" rel="noopener ugc nofollow" target="_blank"> <em class="ky">自述文件</em> </a> <em class="ky">，了解如何通过端口转发访问prometheus控制台。</em></p><p id="847e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在创建我们自己的<code class="fe kz la lb lc b">FlowSchema</code>和<code class="fe kz la lb lc b">PriorityLevelConfiguration</code>资源之前，让我们使用默认的概念来回顾一些重要的概念:</p><figure class="mh mi mj mk gt ml"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">默认流模式列表</figcaption></figure><p id="0f10" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以<code class="fe kz la lb lc b">system-leader-election</code>流模式为例，它的<code class="fe kz la lb lc b">.spec</code>如下所示:</p><figure class="mh mi mj mk gt ml"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">“系统-领导者-选举”流程图的规格</figcaption></figure><p id="f9f9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe kz la lb lc b">rules</code>描述了用于识别匹配请求的标准列表。当且仅当以下情况时，流模式匹配请求:</p><ul class=""><li id="d8fd" class="my mz it js b jt ju jx jy kb na kf nb kj nc kn nd ne nf ng bi translated">至少有一个<code class="fe kz la lb lc b">subjects</code>与发出请求的主题相匹配，并且</li><li id="36ba" class="my mz it js b jt nh jx ni kb nj kf nk kj nl kn nd ne nf ng bi translated">它的<code class="fe kz la lb lc b">resourceRules</code>或<code class="fe kz la lb lc b">nonResourceRules</code>中至少有一个与被请求的动词和(非)资源匹配</li></ul><p id="da06" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe kz la lb lc b">distinguishedMethod</code>定义了如何计算流识别符:</p><ul class=""><li id="302f" class="my mz it js b jt ju jx jy kb na kf nb kj nc kn nd ne nf ng bi translated"><code class="fe kz la lb lc b">ByUser</code>来自同一个<code class="fe kz la lb lc b">subject</code>的请求被分组到同一个流中，这样用户就不会互相淹没</li><li id="eba2" class="my mz it js b jt nh jx ni kb nj kf nk kj nl kn nd ne nf ng bi translated"><code class="fe kz la lb lc b">ByNamespace</code>来自同一个名称空间的请求被分组到同一个流中，这样一个名称空间中的工作负载就不会淹没其他名称空间中的工作负载</li><li id="1fe7" class="my mz it js b jt nh jx ni kb nj kf nk kj nl kn nd ne nf ng bi translated">一个空字符串，其中所有请求都被分组到一个流中</li></ul><p id="114e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当匹配请求时，具有较低<code class="fe kz la lb lc b">matchingPrecedence</code>的流模式比具有较高<code class="fe kz la lb lc b">matchingPrecendence</code>的流模式具有更高的优先级。</p><p id="32d8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe kz la lb lc b">priorityLevelConfiguration</code>是指指定流量控制属性的优先级配置资源。</p><p id="9320" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们检查一下<code class="fe kz la lb lc b">leader-election</code>优先级配置的<code class="fe kz la lb lc b">.spec</code>:</p><figure class="mh mi mj mk gt ml"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">“领导者选举”优先级配置的规格</figcaption></figure><p id="60aa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe kz la lb lc b">limited.assuredConcurrencyShares</code>定义了用于计算<em class="ky">保证并发值的<em class="ky">并发份额</em>。</em><a class="ae kx" href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.20/#limitedprioritylevelconfiguration-v1beta1-flowcontrol-apiserver-k8s-io" rel="noopener ugc nofollow" target="_blank">Kubernetes API文档</a>提供了关于如何计算<em class="ky">保证并发值</em>的更多信息。</p><p id="cdaa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要查看每个优先级的计算并发限制，请查看<code class="fe kz la lb lc b">apiserver_flowcontrol_request_concurrenty_limit</code>指标:</p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi nm"><img src="../Images/49f5a0cd47335aaf360fdae78cd28c5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aTUP3AtyKG8Vntu6ge0uDg.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">所有优先级的并发限制</figcaption></figure><p id="084d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe kz la lb lc b">limited.assuredConcurrencyShares</code>的值与<code class="fe kz la lb lc b">apiserver_flowcontrol_request_concurrency_limit</code>指标的值相关联，增加优先级的并发份额将增加其并发限制。由于API服务器的总并发限制是由所有优先级共享的，因此增加一个优先级的限制将会减少其他优先级的限制。</p><p id="7161" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe kz la lb lc b">limited.limitResponse</code>定义了处理不能立即执行的请求的策略。<code class="fe kz la lb lc b">limit.limitResponse.type</code>支持两个值:</p><ul class=""><li id="440e" class="my mz it js b jt ju jx jy kb na kf nb kj nc kn nd ne nf ng bi translated"><code class="fe kz la lb lc b">Queue</code>请求在哪里排队</li><li id="ecd2" class="my mz it js b jt nh jx ni kb nj kf nk kj nl kn nd ne nf ng bi translated"><code class="fe kz la lb lc b">Reject</code>当请求因HTTP 429错误而被丢弃时</li></ul><p id="b6a4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用<code class="fe kz la lb lc b">Queue</code>限制响应类型，可以通过调整<code class="fe kz la lb lc b">limited.limitResponse.queuing</code>的属性来进一步配置排队行为。APF <a class="ae kx" href="https://kubernetes.io/docs/concepts/cluster-administration/flow-control/#prioritylevelconfiguration" rel="noopener ugc nofollow" target="_blank">文档</a>和<a class="ae kx" href="https://github.com/kubernetes/enhancements/tree/master/keps/sig-api-machinery/1040-priority-and-fairness#assignment-to-a-queue" rel="noopener ugc nofollow" target="_blank">提案</a>提供了关于改变<code class="fe kz la lb lc b">queues</code>、<code class="fe kz la lb lc b">queueLengthLimit</code>和<code class="fe kz la lb lc b">handSize</code>值的影响的更多信息。</p><p id="0d12" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在下一节中，我们将研究如何确定哪个模式与我们的请求相匹配。</p><h1 id="eabd" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">确定匹配的流模式</h1><p id="fd27" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">确定哪个流模式匹配我们的请求的最快方法是检查来自API服务器的两个APF响应头<code class="fe kz la lb lc b">X-Kubernetes-PF-FlowSchema-UID</code>和<code class="fe kz la lb lc b">X-Kubernetes-PF-PriorityLevel-UID</code>。它们向我们展示了匹配流模式的uid和优先级配置:</p><figure class="mh mi mj mk gt ml"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">确定匹配的流模式和优先级</figcaption></figure><p id="3d40" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在上面的例子中，我的<code class="fe kz la lb lc b">GET</code> pods请求与<code class="fe kz la lb lc b">exempt</code>流模式和同名的优先级配置相匹配。</p><p id="a087" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了理解这个流模式对我的请求的影响，让我们检查一下它的<code class="fe kz la lb lc b">.spec</code>:</p><figure class="mh mi mj mk gt ml"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">“豁免”流模式和优先级的规格</figcaption></figure><p id="ce6f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">请注意<code class="fe kz la lb lc b">exempt</code>流模式:</p><ol class=""><li id="7ded" class="my mz it js b jt ju jx jy kb na kf nb kj nc kn nn ne nf ng bi translated">具有最高优先级，其<code class="fe kz la lb lc b">matchingPrecedence</code>设置为1</li><li id="1cb8" class="my mz it js b jt nh jx ni kb nj kf nk kj nl kn nn ne nf ng bi translated">匹配来自<code class="fe kz la lb lc b">system:masters</code>组的请求</li></ol><p id="9764" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">此外，<code class="fe kz la lb lc b">exempt</code>优先级配置将其<code class="fe kz la lb lc b">type</code>设置为<code class="fe kz la lb lc b">Exempt</code>，没有任何队列配置。</p><p id="9c9d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所有这些都是有意义的，因为我的kubectl是使用我的cluster-admin kubeconfig凭证进行身份验证的，该凭证与<code class="fe kz la lb lc b">system:masters</code>组相关联。来自<code class="fe kz la lb lc b">system:masters</code>组的请求被认为是关键流量，它们不受流量控制，并由<code class="fe kz la lb lc b">exempt</code>流模式根据其<code class="fe kz la lb lc b">exempt</code>优先级配置立即调度。</p><p id="c494" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">好了，我想我们现在已经准备好试验我们自己的流模式和优先级配置了🤘。</p><h1 id="035a" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">创建定制流模式和优先级</h1><p id="8e61" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">让我们首先创建一个具有3个服务帐户的<code class="fe kz la lb lc b">demo</code>名称空间，即<code class="fe kz la lb lc b">podlister-0</code>、<code class="fe kz la lb lc b">podlister-1.</code>和<code class="fe kz la lb lc b">podlister-2</code>，并具有从<code class="fe kz la lb lc b">demo</code>名称空间访问<code class="fe kz la lb lc b">LIST</code>和<code class="fe kz la lb lc b">GET</code>pod的权限:</p><figure class="mh mi mj mk gt ml"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">创建“演示”命名空间、其服务帐户和所需的RBAC</figcaption></figure><p id="5b8f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后，我们将创建一个自定义流模式来管理来自这3个服务帐户的请求:</p><figure class="mh mi mj mk gt ml"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">部署restrict-pod-lister流模式和优先级配置</figcaption></figure><p id="b7f6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在<code class="fe kz la lb lc b">restrict-pod-lister</code>优先级中使用的唯一非缺省值是队列的大小(<code class="fe kz la lb lc b">spec.limited.limitResponse.queuing.queueLengthLimit</code>)，它被设置为5个请求。这将有助于更快地触发节流效应。</p><p id="afa9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用<code class="fe kz la lb lc b">kubectl --as</code>选项，我们可以<a class="ae kx" href="https://kubernetes.io/docs/reference/access-authn-authz/authentication/#user-impersonation" rel="noopener ugc nofollow" target="_blank">模拟</a>服务帐户向<code class="fe kz la lb lc b">LIST</code> pods端点发送请求:</p><figure class="mh mi mj mk gt ml"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">发送带有用户模拟的列表窗格请求</figcaption></figure><p id="c209" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">太好了！我们的请求按照预期由<code class="fe kz la lb lc b">restrict-pod-lister</code>流模式和优先级进行匹配👍。</p><h1 id="d9f1" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">检查APF指标</h1><p id="3296" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">在本节中，我们将通过将一个自定义控制器部署到<code class="fe kz la lb lc b">demo</code>名称空间来模拟API服务器的一些流量，作为3个不同的<code class="fe kz la lb lc b">Deployment</code>。每个部署使用我们之前创建的3个服务帐户之一:</p><figure class="mh mi mj mk gt ml"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">部署自定义控制器</figcaption></figure><p id="e647" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">控制器使用Go的<code class="fe kz la lb lc b"><a class="ae kx" href="https://golang.org/pkg/time/#Tick" rel="noopener ugc nofollow" target="_blank">time.Tick()</a></code>函数向API服务器的<code class="fe kz la lb lc b">LIST</code> pod端点发送连续流量，以检索<code class="fe kz la lb lc b">demo</code>名称空间中的所有pod。源代码可在<a class="ae kx" href="https://github.com/ihcsim/controllers/blob/master/podlister/main.go" rel="noopener ugc nofollow" target="_blank">这里</a>获得。</p><p id="e610" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">切换到Prometheus控制台，让我们使用<code class="fe kz la lb lc b">apiserver_flowcontrol_dispatched_requests_total</code>指标来检索我们的流模式匹配的请求总数:</p><pre class="mh mi mj mk gt no lc np nq aw nr bi"><span id="8ad4" class="ns le it lc b gy nt nu l nv nw">apiserver_flowcontrol_dispatched_requests_total{job=”apiserver”,flowSchema=”restrict-pod-lister”}</span></pre><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi nx"><img src="../Images/f81cd1dc58301d78c4c2dcc59164cc92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W5E_I_WwdiZTU0q0KEBd3A.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">我们的流模式匹配的请求总数</figcaption></figure><p id="0de9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">正如对反向量的预期，我们观察到其速率总和呈上升趋势:</p><pre class="mh mi mj mk gt no lc np nq aw nr bi"><span id="15b1" class="ns le it lc b gy nt nu l nv nw">sum(rate(apiserver_flowcontrol_dispatched_requests_total{job="apiserver",flowSchema="restrict-pod-lister"}[15m])) by (flowSchema)</span></pre><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi ny"><img src="../Images/af57fe269e4c59f274704743ceb68bfe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5aSd5htIWlGoO_9hjsj-nQ.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">已调度请求速率总和的上升趋势</figcaption></figure><p id="e6ce" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe kz la lb lc b">apiserver_flowcontrol_current_inqueue_requests</code>指标显示了队列中等待的请求数量。<code class="fe kz la lb lc b">0</code>值表示我们的队列当前是空的:</p><pre class="mh mi mj mk gt no lc np nq aw nr bi"><span id="b524" class="ns le it lc b gy nt nu l nv nw">apiserver_flowcontrol_current_inqueue_requests{job="apiserver",flowSchema="restrict-pod-lister"}</span></pre><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi nz"><img src="../Images/9e94b3409b259b7792b9ea5c7fafe409.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dSrbWG5NuLzYEIQEFdZ9mQ.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">在我们的队列中等待的请求数</figcaption></figure><p id="1f3a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">更重要的是，被拒绝的请求数量也是<code class="fe kz la lb lc b">0</code>，如<code class="fe kz la lb lc b">apiserver_flowcontrol_rejected_requests_total</code>指标所示:</p><pre class="mh mi mj mk gt no lc np nq aw nr bi"><span id="a986" class="ns le it lc b gy nt nu l nv nw">apiserver_flowcontrol_rejected_requests_total{job="apiserver",flowSchema="restrict-pod-lister"}</span></pre><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi oa"><img src="../Images/1d4b87cb4f874c6534828ee2d51f6f62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NqDNIU_Vvhdcll3S_TJjsg.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">被我们的流模式拒绝的请求数</figcaption></figure><p id="19f2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe kz la lb lc b">apiserver_flowcontrol_request_execution_seconds</code>指标提供了对队列中的请求执行时间的洞察:</p><pre class="mh mi mj mk gt no lc np nq aw nr bi"><span id="8056" class="ns le it lc b gy nt nu l nv nw">histogram_quantile(0.99, sum(rate(apiserver_flowcontrol_request_execution_seconds_bucket{job="apiserver",flowSchema="restrict-pod-lister"}[15m])) by (le,flowSchema))</span></pre><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi ob"><img src="../Images/57c5d2b55bb5ea2ac4f8d0f176abfb65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sil-H0A4_OkOnOjWS1geGA.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">我们队列中请求执行时间的p99(秒)</figcaption></figure><p id="82fd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这个特定的测试运行中，我们队列中请求执行时间的p99大约是0.02秒。</p><p id="76bc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">相反，<code class="fe kz la lb lc b">apiserver_flowcontrol_request_wait_duration_seconds</code>指标显示了请求在队列中花费的时间:</p><pre class="mh mi mj mk gt no lc np nq aw nr bi"><span id="2913" class="ns le it lc b gy nt nu l nv nw">histogram_quantile(0.99, sum(rate(apiserver_flowcontrol_request_wait_duration_seconds_bucket{job="apiserver",flowSchema="restrict-pod-lister"}[15m])) by (le,flowSchema))</span></pre><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi oc"><img src="../Images/24788dafa2cb64618c9ded3ecddc2123.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o7SZVnibtXpGUiyUDyEDMg.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">我们队列中请求等待持续时间(秒)的p99</figcaption></figure><p id="149b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个测试运行的请求等待持续时间p99大约是4.95毫秒。稍后我们将再次讨论这两个指标，看看它们如何影响我们的客户端上下文超时。</p><p id="afb1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们添加更多的副本来增加流量，以激活排队效应:</p><figure class="mh mi mj mk gt ml"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">增加自定义控制器副本的数量</figcaption></figure><p id="89d6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当我们的队列饱和时，被拒绝的请求数量开始增加。<code class="fe kz la lb lc b">reason</code>标签告诉我们这些请求被拒绝的原因(即<code class="fe kz la lb lc b">queue-full</code>或<code class="fe kz la lb lc b">timeout</code>):</p><pre class="mh mi mj mk gt no lc np nq aw nr bi"><span id="0699" class="ns le it lc b gy nt nu l nv nw">sum(rate(apiserver_flowcontrol_rejected_requests_total{job="apiserver",flowSchema="restrict-pod-lister"}[15m])) by (flowSchema,reason)</span></pre><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi od"><img src="../Images/6181ef43dae4f4b23b3782a79540c0f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LT4XmJbPl6fBI5QweBX9ig.png"/></div></div></figure><p id="ad80" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在控制器的日志中也可以看到节流消息:</p><figure class="mh mi mj mk gt ml"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">来自自定义控制器的节流日志</figcaption></figure><p id="b4eb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">请求<strong class="js iu">等待</strong>持续时间(<code class="fe kz la lb lc b">apiserver_flowcontrol_request_wait_duration_seconds</code>)的p99在4.0到7.5秒之间徘徊。</p><p id="17d4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">p99请求<strong class="js iu">执行</strong>的时间(<code class="fe kz la lb lc b">apiserver_flowcontrol_request_execution_seconds</code>)约为0.96秒。</p><p id="9e61" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们用小于队列等待持续时间的<a class="ae kx" href="https://golang.org/pkg/context/#WithTimeout" rel="noopener ugc nofollow" target="_blank">上下文超时</a>来更新控制器，我们将开始在日志中看到一些<code class="fe kz la lb lc b">context deadline exceeded</code>错误:</p><figure class="mh mi mj mk gt ml"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">带有“超出上下文截止时间”错误的控制器日志</figcaption></figure><p id="bb11" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，如果您开始在控制器的日志中看到许多<code class="fe kz la lb lc b">context deadline exceeded</code>错误，您现在知道如何使用APF指标和调试端点来确定APF是否限制了您的请求。</p><p id="ebe3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这些是我发现非常有用的指标。还有其他APF指标在本文中没有涉及。查看<a class="ae kx" href="https://kubernetes.io/docs/concepts/cluster-administration/flow-control/#metrics" rel="noopener ugc nofollow" target="_blank"> APF文档</a>获取完整列表。</p><h1 id="f3fa" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">检查调试端点</h1><p id="8833" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">除了度量之外，APF还公开了一些调试端点，这些端点提供了对队列和请求状况的进一步了解。</p><p id="73a3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe kz la lb lc b">/debug/api_priority_and_fairness/dump_priority_levels</code>端点告诉我们优先级中<code class="fe kz la lb lc b">executing</code>和<code class="fe kz la lb lc b">waiting</code>请求的总数:</p><figure class="mh mi mj mk gt ml"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">调试端点显示了我们的优先级队列的情况</figcaption></figure><p id="e00a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">运行这个命令时，我们的队列中有70个<code class="fe kz la lb lc b">waiting</code>和29个<code class="fe kz la lb lc b">executing</code>请求。</p><p id="da22" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe kz la lb lc b">/debug/api_priority_and_fairness/dump_queues</code>端点为我们的流模式中的每个队列提供了进一步的可见性:</p><figure class="mh mi mj mk gt ml"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">调试端点显示了优先级中每个队列的情况</figcaption></figure><p id="8c76" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了可读性，上面的输出被截断了。注意，输出中显示的队列数量等于优先级的值<code class="fe kz la lb lc b">spec.limited.limitResponse.queuing.queues</code>。</p><p id="6420" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，<code class="fe kz la lb lc b">/debug/api_priority_and_fairness/dump_requests</code>端点告诉我们分配给每个请求的流区分符，以及关于请求的<code class="fe kz la lb lc b">subject</code>的信息:</p><figure class="mh mi mj mk gt ml"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">显示请求信息的调试端点</figcaption></figure><h1 id="553a" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">从节流效应中恢复</h1><p id="b230" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">如果我们将控制器缩小到0个副本，随着API服务器从节流效应中恢复，被拒绝的请求数量将逐渐减少:</p><figure class="mh mi mj mk gt ml"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">缩小定制控制器副本</figcaption></figure><pre class="mh mi mj mk gt no lc np nq aw nr bi"><span id="37fb" class="ns le it lc b gy nt nu l nv nw">sum(rate(apiserver_flowcontrol_rejected_requests_total{job="apiserver",flowSchema="restrict-pod-lister"}[15m])) by (flowSchema,reason)</span></pre><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi oc"><img src="../Images/98e5eaaef2e46d62cd1e45e16b9fb070.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nfWxbJ3APa6fTZx9H6CpFA.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">在恢复过程中，被拒绝的请求数量会减少</figcaption></figure><h1 id="f9c7" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">结论</h1><p id="ecfa" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">在这篇文章中，我向您展示了如何创建定制的<code class="fe kz la lb lc b">FlowSchema</code>和<code class="fe kz la lb lc b">PriorityLevelConfiguration</code>资源来管理API服务器的入站流量。我们检查了这些资源的规格。</p><p id="4d52" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用自定义控制器来模拟到API服务器的恶意流量，我们能够使用不同的APF指标和调试端点来深入了解队列和请求。</p><p id="0727" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们还研究了这样一个场景，由于长时间的队列等待，在API服务器处理完我们的请求之前，我们的客户端上下文截止时间超时了。</p><p id="d6b7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">流模式提供了其他配置，例如拒绝入站流量而不是对其进行排队，以及通过名称空间而不是用户来调节入站流量，所有这些都将留给读者练习。</p></div></div>    
</body>
</html>