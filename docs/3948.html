<html>
<head>
<title>Azure DevOps Pipelines: Reusable YAML</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Azure DevOps管道:可重复使用的YAML</h1>
<blockquote>原文：<a href="https://itnext.io/azure-devops-pipelines-reusable-yaml-3cdf61e393aa?source=collection_archive---------2-----------------------#2020-03-30">https://itnext.io/azure-devops-pipelines-reusable-yaml-3cdf61e393aa?source=collection_archive---------2-----------------------#2020-03-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="4567" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这篇文章中，我们将重构我们的示例Azure DevOps管道，将一些冗余的YAML移到一个新文件中，并替换主YAML文件中的冗余部分。这篇文章将建立在前几篇文章中创建的Azure DevOps项目之上。如果您刚刚加入这个系列，请查看以前的帖子，了解项目的进展情况。</p><p id="e2c5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://elanderson.net/2020/02/getting-started-with-azure-devops/" rel="noopener ugc nofollow" target="_blank">Azure devo PS入门</a><br/><a class="ae kl" href="https://elanderson.net/2020/03/pipeline-creation-in-azure-devops/" rel="noopener ugc nofollow" target="_blank">Azure devo PS中的管道创建</a> <br/> <a class="ae kl" href="https://elanderson.net/2020/03/azure-devops-publish-asp-net-core/" rel="noopener ugc nofollow" target="_blank"> Azure DevOps为ASP.NET核心发布工件</a> <br/> <a class="ae kl" href="https://elanderson.net/2020/03/azure-devops-pipelines-multiple-jobs-in-yaml/" rel="noopener ugc nofollow" target="_blank"> Azure DevOps管道:YAML的多个作业</a></p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi km"><img src="../Images/11abb65ef9066ac7c664fda61927d1e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/0*pDUHHd1HAY9uFH89.png"/></div></figure><h2 id="2788" class="ku kv iq bd kw kx ky dn kz la lb dp lc jy ld le lf kc lg lh li kg lj lk ll lm bi translated">从YAML开始</h2><p id="e1e3" class="pw-post-body-paragraph jn jo iq jp b jq ln js jt ju lo jw jx jy lp ka kb kc lq ke kf kg lr ki kj kk ij bi translated">下面是我们当前管道的YAML，它使用两个不同的作业构建两个不同的web应用程序。查看这两个作业，您会注意到它们都有相同的步骤。步骤上唯一的区别是构建哪个项目(WebApp1.csproj或WebApp2.csproj)以及用什么来调用发布的工件(WebApp1或WebApp2)。在开发应用程序时，我们绝不会容忍这种程度的重复，这同样适用于我们的管道。</p><pre class="kn ko kp kq gt ls lt lu lv aw lw bi"><span id="5187" class="ku kv iq lt b gy lx ly l lz ma">trigger: none<br/><br/>variables:<br/>  buildConfiguration: 'Release'<br/><br/>jobs:<br/>- job: WebApp1<br/>  displayName: 'Build WebApp1'<br/>  pool:<br/>    vmImage: 'ubuntu-latest'<br/><br/>  steps:<br/>  - task: UseDotNet@2<br/>    displayName: 'Use .NET 3.1.x'<br/>    inputs:<br/>      packageType: 'sdk'<br/>      version: '3.1.x'<br/><br/>  - task: DotNetCoreCLI@2<br/>    displayName: 'Build'<br/>    inputs:<br/>      command: 'build'<br/>      projects: '**/WebApp1.csproj'<br/>      arguments: '--configuration $(buildConfiguration)' <br/>  <br/>  - task: DotNetCoreCLI@2<br/>    displayName: 'Publish Application'<br/>    inputs:<br/>      command: 'publish'<br/>      publishWebProjects: false<br/>      projects: '**/WebApp1.csproj'<br/>      arguments: '--configuration $(buildConfiguration) --output $(Build.ArtifactStagingDirectory)'<br/><br/>  - task: PublishPipelineArtifact@1<br/>    displayName: 'Publish Artifacts'<br/>    inputs:<br/>      targetPath: '$(Build.ArtifactStagingDirectory)'<br/>      artifact: 'WebApp1'<br/>      publishLocation: 'pipeline'<br/><br/>- job: WebApp2<br/>  displayName: 'Build WebApp2'<br/>  pool:<br/>    vmImage: 'ubuntu-latest'<br/><br/>  steps:<br/>  - task: UseDotNet@2<br/>    displayName: 'Use .NET 3.1.x'<br/>    inputs:<br/>      packageType: 'sdk'<br/>      version: '3.1.x'<br/><br/>  - task: DotNetCoreCLI@2<br/>    displayName: 'Build'<br/>    inputs:<br/>      command: 'build'<br/>      projects: '**/WebApp2.csproj'<br/>      arguments: '--configuration $(buildConfiguration)' <br/>  <br/>  - task: DotNetCoreCLI@2<br/>    displayName: 'Publish Application'<br/>    inputs:<br/>      command: 'publish'<br/>      publishWebProjects: false<br/>      projects: '**/WebApp2.csproj'<br/>      arguments: '--configuration $(buildConfiguration) --output $(Build.ArtifactStagingDirectory)'<br/><br/>  - task: PublishPipelineArtifact@1<br/>    displayName: 'Publish Artifacts'<br/>    inputs:<br/>      targetPath: '$(Build.ArtifactStagingDirectory)'<br/>      artifact: 'WebApp2'<br/>      publishLocation: 'pipeline'</span></pre><h2 id="ff25" class="ku kv iq bd kw kx ky dn kz la lb dp lc jy ld le lf kc lg lh li kg lj lk ll lm bi translated">添加新文件</h2><p id="154d" class="pw-post-body-paragraph jn jo iq jp b jq ln js jt ju lo jw jx jy lp ka kb kc lq ke kf kg lr ki kj kk ij bi translated">为了解决上面的重复问题，我们需要从上面获取共享的步骤，并将它们移动到可以重用的地方。我们将使用Azure DevOps网站逐步完成这些步骤，并直接提交到主分支，但是这些相同的步骤可以在本地执行，也可以在任何分支的web上执行。首先，从网站的Repos部分，我们需要添加一个新文件，方法是在我们希望添加文件的级别单击三个点。在这种情况下，我们将添加到回购的根目录，但相同的选项在任何文件夹上都可用。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi mb"><img src="../Images/ba36668cadd42a1160f0a3c7749c3955.png" data-original-src="https://miro.medium.com/v2/resize:fit:1098/format:webp/0*m_AlmJeVAvyjvSes.png"/></div></figure><p id="f35f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一个对话框将显示您可以输入新文件名<strong class="jp ir">的位置，在这种情况下，我们将使用build.yml。接下来，点击<strong class="jp ir">创建</strong>继续。</strong></p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi mc"><img src="../Images/612b8bfc859c02c68cefa02d40e7baf2.png" data-original-src="https://miro.medium.com/v2/resize:fit:912/format:webp/0*i8HhW5WpMo8vAxLX.png"/></div></figure><h2 id="c1b5" class="ku kv iq bd kw kx ky dn kz la lb dp lc jy ld le lf kc lg lh li kg lj lk ll lm bi translated">共享YAML</h2><p id="f7a8" class="pw-post-body-paragraph jn jo iq jp b jq ln js jt ju lo jw jx jy lp ka kb kc lq ke kf kg lr ki kj kk ij bi translated">现在我们有了一个新文件，我们可以开始构建新的YAML，它将处理原始作业中的重复步骤。我们要做的第一件事是定义一组可以调用这组步骤的<strong class="jp ir">参数</strong>。我们将使用它来传递构建什么项目，使用哪个构建配置，以及发布的工件的名称。下面是我们参数的定义。</p><pre class="kn ko kp kq gt ls lt lu lv aw lw bi"><span id="3d95" class="ku kv iq lt b gy lx ly l lz ma">parameters:<br/>- name: buildConfiguration<br/>  type: string<br/>  default: 'Release'<br/>- name: project<br/>  type: string<br/>  default: ''<br/>- name: artifactName<br/>  type: string<br/>  default: ''</span></pre><p id="34fd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，我们可以使用<strong class="jp ir"> ${{ parameterName }} </strong>语法在文件的其余部分使用这些参数。注意，使用<strong class="jp ir"> $(variableName) </strong>语法也可以使用任何管道变量。下面的YAML代码在参数行中显示了这两种类型。</p><pre class="kn ko kp kq gt ls lt lu lv aw lw bi"><span id="2a9f" class="ku kv iq lt b gy lx ly l lz ma">- task: DotNetCoreCLI@2<br/>  displayName: 'Publish Application'<br/>  inputs:<br/>    command: 'publish'<br/>    publishWebProjects: false<br/>    projects: '**/${{ parameters.project }}'<br/>    arguments: '--configuration ${{ parameters.buildConfiguration }} --output $(Build.ArtifactStagingDirectory)'</span></pre><p id="e80d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">虽然您可以使用管道变量，但我建议通过参数传递您需要的所有值，原因与我们在进行一般编程时尽量避免使用全局变量相同。我在这里使用两者来显示每一个的用法。以下是我们新档案中的完整YAML。</p><pre class="kn ko kp kq gt ls lt lu lv aw lw bi"><span id="aca0" class="ku kv iq lt b gy lx ly l lz ma">parameters:<br/>- name: buildConfiguration<br/>  type: string<br/>  default: 'Release'<br/>- name: project<br/>  type: string<br/>  default: ''<br/>- name: artifactName<br/>  type: string<br/>  default: ''<br/><br/>steps:<br/>  - task: UseDotNet@2<br/>    displayName: 'Use .NET 3.1.x'<br/>    inputs:<br/>      packageType: 'sdk'<br/>      version: '3.1.x'<br/><br/>  - task: DotNetCoreCLI@2<br/>    displayName: 'Build'<br/>    inputs:<br/>      command: 'build'<br/>      projects: '**/${{ parameters.project }}'<br/>      arguments: '--configuration ${{ parameters.buildConfiguration }}' <br/>  <br/>  - task: DotNetCoreCLI@2<br/>    displayName: 'Publish Application'<br/>    inputs:<br/>      command: 'publish'<br/>      publishWebProjects: false<br/>      projects: '**/${{ parameters.project }}'<br/>      arguments: '--configuration ${{ parameters.buildConfiguration }} --output $(Build.ArtifactStagingDirectory)'<br/><br/>  - task: PublishPipelineArtifact@1<br/>    displayName: 'Publish Artifacts'<br/>    inputs:<br/>      targetPath: '$(Build.ArtifactStagingDirectory)'<br/>      artifact: ${{ parameters.artifactName }}<br/>      publishLocation: 'pipeline'</span></pre><p id="f805" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，提交对新文件的更改。</p><h2 id="8178" class="ku kv iq bd kw kx ky dn kz la lb dp lc jy ld le lf kc lg lh li kg lj lk ll lm bi translated">使用共享YAML</h2><p id="d4c4" class="pw-post-body-paragraph jn jo iq jp b jq ln js jt ju lo jw jx jy lp ka kb kc lq ke kf kg lr ki kj kk ij bi translated">并不是说我们在两个构建作业之间有相同的YAML，我们可以切换回我们的主YAML文件，在示例中的<strong class="jp ir"> azure-pipelines.yml </strong>，并删除我们想要替换的步骤。虽然这两个作业都有一个steps部分，但是我们在其中留下的惟一东西是对我们的另一个YAML文件的模板调用，对于这个示例来说是<strong class="jp ir"> build.yml </strong>，它传递参数来运行另一个文件。下面是生成的YAML文件，突出显示了对两个作业中共享文件的调用。</p><pre class="kn ko kp kq gt ls lt lu lv aw lw bi"><span id="5012" class="ku kv iq lt b gy lx ly l lz ma">trigger: none<br/><br/>variables:<br/>  buildConfiguration: 'Release'<br/><br/>jobs:<br/>- job: WebApp1<br/>  displayName: 'Build WebApp1'<br/>  pool:<br/>    vmImage: 'ubuntu-latest'<br/><br/>  steps:<br/>  - template: build.yml<br/>    parameters:<br/>      buildConFiguration: $(buildConfiguration)<br/>      project: WebApp1.csproj<br/>      artifactName: WebApp1<br/><br/>- job: WebApp2<br/>  displayName: 'Build WebApp2'<br/>  pool:<br/>    vmImage: 'ubuntu-latest'<br/><br/>  steps:<br/>  - template: build.yml<br/>    parameters:<br/>      buildConFiguration: $(buildConfiguration)<br/>      project: WebApp2.csproj<br/>      artifactName: WebApp2</span></pre><h2 id="1cfe" class="ku kv iq bd kw kx ky dn kz la lb dp lc jy ld le lf kc lg lh li kg lj lk ll lm bi translated">包扎</h2><p id="6263" class="pw-post-body-paragraph jn jo iq jp b jq ln js jt ju lo jw jx jy lp ka kb kc lq ke kf kg lr ki kj kk ij bi translated">能够从您的YAML文件中删除重复应该有助于提高您的管道的可维护性。我知道示例没有显示出来，但是模板只是一个步骤，您可以在它之前或之后有其他步骤，就像您处理正常任务一样。</p></div><div class="ab cl md me hu mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ij ik il im in"><p id="320f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mk">最初发表于</em> <a class="ae kl" href="https://elanderson.net/2020/03/azure-devops-pipelines-reuseable-yaml/" rel="noopener ugc nofollow" target="_blank"> <em class="mk">埃里克·安德森</em> </a> <em class="mk">。</em></p></div></div>    
</body>
</html>