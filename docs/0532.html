<html>
<head>
<title>Interactive SVG made easy using React &amp; TypeScript &amp; HOC</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用React &amp; TypeScript &amp; HOC简化交互式SVG</h1>
<blockquote>原文：<a href="https://itnext.io/interactive-svg-made-easy-using-react-typescript-hoc-4dcc1ad9e918?source=collection_archive---------5-----------------------#2018-03-26">https://itnext.io/interactive-svg-made-easy-using-react-typescript-hoc-4dcc1ad9e918?source=collection_archive---------5-----------------------#2018-03-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/1882b802a135ccd11af3e0c57c81d3aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DZ8n_tufDBKzYzOilagDAQ.jpeg"/></div></div></figure><p id="a76f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">TL；正如我在<a class="ae kw" href="https://medium.com/@yofujimo/enlighten-your-react-components-with-hocs-from-recompose-47519f76d851" rel="noopener">上一篇文章</a>中所写的，简单的&amp;无状态React组件可以使用高阶组件(hoc)转换成交互式组件。<br/>在本文中，我将展示一个使用React &amp; TypeScript的交互式SVG示例。如果您想先尝试一下，请转到CodePen示例。</p><h1 id="8443" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">拖动的状态管理</h1><p id="51eb" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">我们并不认为它是日常的，但是鼠标拖动是一种状态转换。当你拖动一个文件时，首先你要指向该文件，然后按下鼠标按钮，然后移动光标到目的地，最后释放按钮。</p><p id="83f8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个顺序可以描述如下。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="6161" class="mj ky iq mf b gy mk ml l mm mn">MouseDown -&gt; MouseMove -&gt; ... -&gt; MouseMove -&gt; MouseUp</span></pre><p id="d6b9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在整个序列中，应该通过将当前位置反映到UI组件来指示它。</p><p id="4442" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这就是管理拖动的状态。</p><ul class=""><li id="0022" class="mo mp iq ka b kb kc kf kg kj mq kn mr kr ms kv mt mu mv mw bi translated"><strong class="ka ir"> isDown </strong>:鼠标按钮按下时为真。</li><li id="ea3e" class="mo mp iq ka b kb mx kf my kj mz kn na kr nb kv mt mu mv mw bi translated"><strong class="ka ir"> posX/posY </strong>:父SVG元素中的组件位置。</li><li id="5964" class="mo mp iq ka b kb mx kf my kj mz kn na kr nb kv mt mu mv mw bi translated"><strong class="ka ir"> screenX/screenY </strong>:屏幕坐标中拖动开始的位置。</li></ul><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="b39c" class="mj ky iq mf b gy mk ml l mm mn">interface DraggableState {<br/>  isDown: boolean;<br/>  posX: number;<br/>  posY: number;<br/>  screenX: number;<br/>  screenY: number;<br/>}</span></pre><h1 id="5144" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">onMouseDown</h1><p id="be26" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">当此事件被触发时，状态应该保持初始屏幕位置。因为鼠标运动与屏幕坐标相关，所以从<a class="ae kw" href="https://reactjs.org/docs/events.html#mouse-events" rel="noopener ugc nofollow" target="_blank"> MouseEvent </a>中检索screenX和screenY属性是最健壮的方法之一。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="0590" class="mj ky iq mf b gy mk ml l mm mn">    onMouseDown: (state: DraggableState) =&gt; (e: MouseEvent) =&gt; {<br/>      return {<br/>        ...state,<br/>        isDown: true,<br/>        screenX: e.screenX,<br/>        screenY: e.screenY<br/>      }<br/>    },</span></pre><h1 id="4cbc" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">onMouseMove</h1><p id="e791" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">onMouseDown之后，每次触发此事件时都应更新组件位置。新位置可以从屏幕位置的差值计算出来。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="3b84" class="mj ky iq mf b gy mk ml l mm mn">    onMouseMove: (state: DraggableState) =&gt; (e: MouseEvent) =&gt; {<br/>      if (!state.isDown) {<br/>        return { ...state }<br/>      }<br/>      const shiftX = e.screenX - state.screenX;<br/>      const shiftY = e.screenY - state.screenY;</span><span id="64eb" class="mj ky iq mf b gy nc ml l mm mn">      return {<br/>        ...state,<br/>        posX: state.posX + shiftX,<br/>        posY: state.posY + shiftY,<br/>        screenX: e.screenX,<br/>        screenY: e.screenY,<br/>      };<br/>    },</span></pre><p id="13fb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意:如果鼠标光标移动得太快，MouseMove事件可能会发送到封装组件。</p><h1 id="0841" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">onMouseUp</h1><p id="1782" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">该事件用于完成拖动并重置状态。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="ddeb" class="mj ky iq mf b gy mk ml l mm mn">    onMouseUp: (state: DraggableState, props: DraggableProps) =&gt; (e: MouseEvent) =&gt; {<br/>      return { ...state, isDown: false, screenX: 0, screenY: 0 }<br/>    },</span></pre><h1 id="1cd7" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">CodePen示例</h1><p id="d6d8" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">这里有一个例子。尝试拖动彩色圆圈。</p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="8761" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意，通过预先应用<em class="nf">enhancementwithdragable</em>，每个圆具有不同的状态。</p><h1 id="086f" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">结论</h1><p id="e41f" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">即使在web应用程序中，UI交互也需要各种状态管理。通过使用React &amp; HOCs，SVG标记和状态管理被清晰地分开，并可以以直观的方式结合起来。</p></div></div>    
</body>
</html>