<html>
<head>
<title>Multi-Segment Distributed Storage for Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes的多段分布式存储</h1>
<blockquote>原文：<a href="https://itnext.io/multi-segment-distributed-storage-for-kubernetes-aa9163dad735?source=collection_archive---------2-----------------------#2019-03-23">https://itnext.io/multi-segment-distributed-storage-for-kubernetes-aa9163dad735?source=collection_archive---------2-----------------------#2019-03-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="afeb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">与参与<a class="ae ko" href="http://www.calit2.net/newsroom/article.php?id=2910" rel="noopener ugc nofollow" target="_blank"> Calit2 </a>项目的一组研究人员合作，帮助我们确定了一个有趣的EdgeFS用例，该用例在单个Kubernetes集群内和跨大洲的高吞吐量高延迟网络后端上进行延伸。</p><p id="9275" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">长距离高吞吐量数据传输的挑战是一个老问题，科学界，如<a class="ae ko" href="https://cenic.org/" rel="noopener ugc nofollow" target="_blank"> Cenic </a>，已经解决了这个问题。然而，在研究人员之间共享数据，即使是通过专用的DMZ，也是一项超级复杂的任务，数据管理是一项真正的痛苦。</p><p id="83bb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">跨地理位置的延迟很高，即使使用光纤主干也是如此，因此扩展单个存储命名空间不会很有效。</p><p id="07c3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">数据集是分布式的，有些数据集可能非常大。数据拷贝会分散数据，带来安全控制挑战和内容一致性不确定性。好消息是，在大多数情况下，并不是所有数据集都需要一次性访问。</p><p id="d121" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，我们认为EdgeFS在这里可以有所帮助。</p><p id="3226" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">什么是EdgeFS？这是<a class="ae ko" href="https://rook.io/docs/rook/master/edgefs-storage.html" rel="noopener ugc nofollow" target="_blank"> CNCF Rook项目的新存储提供商。</a>虽然它是一个横向扩展存储集群，但它仍然可以在所谓的“solo”模式下运行，这是一种单节点Docker容器，能够随着部署的增长而横向扩展，只需连接更多节点和/或地理上分散的集群段即可。</p><p id="6be7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Kubernetes的好处是，通过提供内置的名称空间隔离，可以很容易地在同一个Kubernetes集群中实现分段。下图显示了EdgeFS段如何在地理上分布，从而在这样的集群中提供全局存储命名空间:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi kp"><img src="../Images/0d6b99aadc6e9b2fa00295ced8286743.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J45yH1SudF0vuHUu85sLCA.png"/></div></div></figure><p id="75b6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">每个EdgeFS段可以在作为专用名称空间的同一个Kubernets集群内运行，也可以跨Kubernets集群运行。</p><p id="8df3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">段间网关链路(ISGW)可用于多种使用情形:</p><ul class=""><li id="d584" class="lb lc it js b jt ju jx jy kb ld kf le kj lf kn lg lh li lj bi translated">以主-主、主-从方式双向连接两个段；</li><li id="3410" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn lg lh li lj bi translated">连接双向星形拓扑中的段，其中中心段将重新分布订阅的数据集；</li><li id="79c8" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn lg lh li lj bi translated">以双向环形拓扑连接分段，其中任何分段的修改将扩展到相邻分段，并最终扩展到所有链接的分段；</li><li id="8b9d" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn lg lh li lj bi translated">支持远程访问完全复制的数据集；</li><li id="e165" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn lg lh li lj bi translated">启用对仅元数据复制数据集的远程访问，数据块按需获取(数据块被缓存，对象可以被转换为持久的)；</li><li id="2402" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn lg lh li lj bi translated">启用远程收集段，本地数据将在一段短时间后被删除，同时保留在目标位置。</li></ul><p id="5ff0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当配置为在同一个Kubernetes集群中运行时，每个EdgeFS段将使用自己的Kubernetes名称空间，这是本文关注的用例。</p><h1 id="edd1" class="lp lq it bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">我们开始吧！</h1><p id="d256" class="pw-post-body-paragraph jq jr it js b jt mn jv jw jx mo jz ka kb mp kd ke kf mq kh ki kj mr kl km kn im bi translated">使用Rook EdgeFS操作器，我们可以在同一个Kubernetes集群安装中配置2个以上的段。当Kubernetes节点跨越多个区域，并且跨区域延迟可能很高，或者链路可能暂时离线时，这可能很有用。</p><p id="63ab" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">可以建立EdgeFS ISGW链接，以确保每个存储桶的所有数据段保持一致的同步。</p><p id="45c3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">每个细分市场必须有自己的区域子名称空间，对于区域租户及其用户是本地的。例如，在<code class="fe ms mt mu mv b">efscli</code>中可以看到同一个全局名称空间的两个同步段，如下所示:</p><pre class="kq kr ks kt gt mw mv mx my aw mz bi"><span id="e0ca" class="na lq it mv b gy nb nc l nd ne"># efscli cluster list<br/>SanFrancisco<br/>NewYork<br/><br/># efscli tenant list SanFrancisco<br/>Biology<br/>MedicalSupply<br/><br/># efscli tenant list NewYork<br/>Marketing<br/>Finance</span></pre><h1 id="98cc" class="lp lq it bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">配置段</h1><p id="52f6" class="pw-post-body-paragraph jq jr it js b jt mn jv jw jx mo jz ka kb mp kd ke kf mq kh ki kj mr kl km kn im bi translated">确保每个段都按照自己的Kubernetes名称空间进行配置。为此，复制cluster.yaml CRD文件，并修改以下所有内容:</p><ul class=""><li id="edf0" class="lb lc it js b jt ju jx jy kb ld kf le kj lf kn lg lh li lj bi translated">命名空间名称</li><li id="dc63" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn lg lh li lj bi translated">PodSecurityPolicy元数据名称</li><li id="91be" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn lg lh li lj bi translated">集群角色元数据名称</li><li id="a505" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn lg lh li lj bi translated">ClusterRoleBinding system-psp和cluster-psp元数据名称和roleRef</li><li id="1613" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn lg lh li lj bi translated">命名空间元数据</li></ul><p id="8046" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">创建新的集群CRD，并观察它将在自己的名称空间中创建。注意过滤节点和设备选择器。节点的设备不能在命名空间之间共享。</p><p id="0e67" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最终结果可能是这样的:</p><pre class="kq kr ks kt gt mw mv mx my aw mz bi"><span id="ca30" class="na lq it mv b gy nb nc l nd ne"># kubectl get svc -n rook-edgefs-sanfrancisco<br/>NAME<br/>rook-edgefs-mgr<br/>rook-edgefs-restapi<br/>rook-edgefs-target<br/>rook-edgefs-ui<br/># kubectl get svc -n rook-edgefs-newyork<br/>NAME<br/>rook-edgefs-mgr<br/>rook-edgefs-restapi<br/>rook-edgefs-target<br/>rook-edgefs-ui<br/></span></pre><p id="d9b6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">其中每个集群段都有自己的管理端点，并且由同一个Rook Operator实例控制。</p><h1 id="18f1" class="lp lq it bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">配置服务</h1><p id="4d08" class="pw-post-body-paragraph jq jr it js b jt mn jv jw jx mo jz ka kb mp kd ke kf mq kh ki kj mr kl km kn im bi translated">在新段的所有EdgeFS目标启动并运行后，验证EdgeFS UI可以访问，并且可以创建服务CRD。在创建服务时，它会自动获取Kubernetes操作名称空间，并将其提供给CRD的元数据。</p><p id="7574" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">类似地，如果您喜欢通过CLI操作集群段，您可以使用neadm管理命令:<code class="fe ms mt mu mv b">neadm service enable|disable NAME</code>，这将使用相同的REST API调用创建/删除CRD，类似于GUI。</p><p id="4352" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，另一种方法是按照<a class="ae ko" href="https://rook.github.io/docs/rook/master/edgefs-storage.html" rel="noopener ugc nofollow" target="_blank"> Rook文档网站</a>上的说明手动准备CRD YAML文件，并指定目标Kubernetes名称空间。</p><h1 id="8444" class="lp lq it bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">配置CSI置备程序</h1><p id="4cf5" class="pw-post-body-paragraph jq jr it js b jt mn jv jw jx mo jz ka kb mp kd ke kf mq kh ki kj mr kl km kn im bi translated">在撰写本文时，CSI拓扑感知仍处于测试状态，因此EdgeFS CSI驱动程序还不支持它:<a class="ae ko" href="https://kubernetes-csi.github.io/docs/topology.html" rel="noopener ugc nofollow" target="_blank"> CSI拓扑感知</a>。</p><p id="92dd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是，在最新版本的EdgeFS CSI provisioner中，已经完成了启用多分段使用的工作，下面是实现方法。</p><ul class=""><li id="15fd" class="lb lc it js b jt ju jx jy kb ld kf le kj lf kn lg lh li lj bi translated">编辑配置密码文件并添加:</li></ul><pre class="kq kr ks kt gt mw mv mx my aw mz bi"><span id="626a" class="na lq it mv b gy nb nc l nd ne">k8sEdgefsNamespaces: [“rook-edgefs-sanfrancisco”, “rook-edgefs-newyork”]<br/></span></pre><ul class=""><li id="c9e5" class="lb lc it js b jt ju jx jy kb ld kf le kj lf kn lg lh li lj bi translated">对于动态调配的卷，在存储类YAML文件中，添加段的名称和段的EdgeFS服务名称:</li></ul><pre class="kq kr ks kt gt mw mv mx my aw mz bi"><span id="8319" class="na lq it mv b gy nb nc l nd ne">...<br/>parameters:<br/>  segment: rook-edgefs-sanfrancisco<br/>  service: nfs01<br/>...</span></pre><ul class=""><li id="6c63" class="lb lc it js b jt ju jx jy kb ld kf le kj lf kn lg lh li lj bi translated">计划新Pod时，请确保卷中指定了段的命名空间和EdgeFS服务名称:</li></ul><pre class="kq kr ks kt gt mw mv mx my aw mz bi"><span id="e962" class="na lq it mv b gy nb nc l nd ne">...<br/>volumeHandle: sanfrancisco:nfs01@cluster/tenant/bucket<br/>...</span></pre><p id="54a3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通过以上设置，EdgeFS CSI provisioner的单个实例可以处理拓扑感知PV/PVC编排，因此创建NFS或CSI的请求可以重定向到指定区域。</p><h1 id="41ba" class="lp lq it bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">摘要</h1><p id="15a4" class="pw-post-body-paragraph jq jr it js b jt mn jv jw jx mo jz ka kb mp kd ke kf mq kh ki kj mr kl km kn im bi translated">虽然我的一般建议是使用联合Kubernetes集群，但我不得不承认单集群平面网络有其优势，如管理简化、轻量级名称空间隔离以及不需要额外的联合复制复杂性。</p><p id="8e8c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有了EdgeFS，跨区域数据访问可以通过Rook Operator和CSI Provisioner轻松设置并与Kubernetes紧密集成。</p><p id="d93a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一旦设置完成，Kubernetes PVs就可以跨数据段浮动，而不需要额外的数据管理复杂性。只需在不同的段中重新调度Pod，重新指向同步的存储桶并立即访问数据集。</p><p id="6a65" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">即使数据更改尚未完全同步，EdgeFS也能保证本地同步读取的一致性。通过利用仅元数据同步功能，可以以极快的速度分发一致的数据集，然后可以按需获取数据块。</p><p id="9b16" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">今天就试试吧！</p><p id="379a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在<a class="ae ko" href="http://edgefs.io" rel="noopener ugc nofollow" target="_blank"> EdgeFS </a>和<a class="ae ko" href="http://rook.io/docs/rook/master/edgefs-storage.html" rel="noopener ugc nofollow" target="_blank"> Rook </a>社区关注我们！</p></div></div>    
</body>
</html>