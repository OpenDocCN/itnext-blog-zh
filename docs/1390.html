<html>
<head>
<title>Language awards: war of codes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">语言奖:代码之战</h1>
<blockquote>原文：<a href="https://itnext.io/language-awards-war-of-codes-d751eb386184?source=collection_archive---------3-----------------------#2018-10-02">https://itnext.io/language-awards-war-of-codes-d751eb386184?source=collection_archive---------3-----------------------#2018-10-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="a0ac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">哪种语言最适合你？TS，Javascript，Go，Java，Py，C#让我们深入了解一下！</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/e00d87c563628a61831f299e21eebd24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w5msDVay2Nm3_UfzlgqlWw.png"/></div></div></figure><p id="516c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在最初的TS与Go比较之后的一段时间，我认为我应该重新进行语言比较，以做一些更大的事情，我想更深入和更广泛地进行比较，找出一些难点，比较语法和功能以及生态系统，并在混合中加入更多的语言，以查看新语言与旧语言的对比情况。为什么不在一个大的表格里比较所有的东西，看看谁得分最高？好的。它会很乱，你可能不喜欢我的评分，但我保证我会努力做到公平；)</p><p id="87a1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">TL；博士:</strong>考虑一下下表，在评论中随意一决雌雄:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kx"><img src="../Images/242226a049c17f7bce6395679a3b818d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pnCAVZp10-knPHM-SgxnrQ.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">我的语言对比成绩</figcaption></figure><p id="0b91" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">既然你已经得到了你的剧透，让我们继续比较。我不会深入Java / C# / Py <strong class="jp ir">并行</strong>代码示例，因为我想在这方面重点关注TS &amp; Go，但是这样的示例并不难找到。</p><h1 id="7d63" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">资源消耗</h1><h2 id="b80a" class="ma ld iq bd le mb mc dn li md me dp lm jy mf mg lq kc mh mi lu kg mj mk ly ml bi translated">内存占用</h2><p id="a9b2" class="pw-post-body-paragraph jn jo iq jp b jq mm js jt ju mn jw jx jy mo ka kb kc mp ke kf kg mq ki kj kk ij bi translated">当使用不同的语言时，内存利用率会有很大的不同，这乍听起来可能令人惊讶，因为您可能会认为代码应该用完大约算法所需的内存，但是由于数据可以在内存语言中以许多不同的方式表示，所以基本库实现在内存使用方面会有很大的不同。例如:对象可以表示为指针网络(C#/Java)、顺序结构(Go)或哈希映射(JS)。</p><p id="88ff" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面的图表显示了不同代码任务期间的内存消耗，引入了850MB的临界值以保留图形细节，防止过度缩放。净核心绩效。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/fbe466bbbc61ce78beb15b3b3341cb52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1308/format:webp/1*9A-eFhYC4cKQ1UnuvnK95A.png"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">内存基准(数据:基准游戏)</figcaption></figure><p id="263f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当谈到<strong class="jp ir">垃圾收集</strong>语言时，<strong class="jp ir"> Golang是你最好的内存利用</strong>，这也可以在基准中看到<a class="ae ms" href="https://benchmarksgame-team.pages.debian.net/benchmarksgame/faster/go-node.html" rel="noopener ugc nofollow" target="_blank">:</a></p><ul class=""><li id="5799" class="mt mu iq jp b jq jr ju jv jy mv kc mw kg mx kk my mz na nb bi translated"><strong class="jp ir">内存顺序结构</strong>:与大多数语言(包括JS)相比，Go没有类，只有结构。这意味着Golang对象被鼓励更像二进制数据块，而不是指针树，我说“鼓励”是因为如果你愿意，你可以在Go中的任何事情上使用指针。</li><li id="0f8b" class="mt mu iq jp b jq nc ju nd jy ne kc nf kg ng kk my mz na nb bi translated"><strong class="jp ir">纯代码编译</strong> vs链接(动态&amp;静态)意味着不需要加载整个*。dll/*。sa/*。js文件加载到内存中进行一些函数调用，考虑使用lodash，加载和使用了多少代码行。</li><li id="e612" class="mt mu iq jp b jq nc ju nd jy ne kc nf kg ng kk my mz na nb bi translated"><strong class="jp ir">强类型</strong>:精确控制内存使用，例如int16只使用16位。</li><li id="63f2" class="mt mu iq jp b jq nc ju nd jy ne kc nf kg ng kk my mz na nb bi translated"><strong class="jp ir">无继承</strong> : Golang不需要虚拟表，这意味着你减少了几乎所有创建对象的开销，因为在Java/C#中继承是标准。</li><li id="8be4" class="mt mu iq jp b jq nc ju nd jy ne kc nf kg ng kk my mz na nb bi translated"><strong class="jp ir">多线程</strong>:使用JS，你将需要创建新的进程，以利用额外的CPU内核，这意味着你要加载基类和库代码的副本。</li></ul><h2 id="8491" class="ma ld iq bd le mb mc dn li md me dp lm jy mf mg lq kc mh mi lu kg mj mk ly ml bi translated">CPU利用率</h2><p id="1d23" class="pw-post-body-paragraph jn jo iq jp b jq mm js jt ju mn jw jx jy mo ka kb kc mp ke kf kg mq ki kj kk ij bi translated">我们程序员都有一个爱好，就是问哪种语言更擅长挤出汁液，我也不例外。每学完一门新语言，我总会想:“这一门是不是比前几门快多了？”，在这个类别中挑选一个明确的赢家将永远是一个骗局，但我可以就此事提供一些想法。</p><p id="243a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以求助于<a class="ae ms" href="https://benchmarksgame-team.pages.debian.net/benchmarksgame/faster/go-node.html" rel="noopener ugc nofollow" target="_blank">基准</a>，它向我们展示了Golang最有可能胜过JS，这并不奇怪，因为可以使用更多的内核，但是当它与<a class="ae ms" href="https://benchmarksgame-team.pages.debian.net/benchmarksgame/faster/go.html" rel="noopener ugc nofollow" target="_blank"> Java </a> &amp; C#相比时，情况就不同了。</p><p id="d320" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面的图表显示了完成不同基准测试的时间，我必须引入90秒的截止时间，以避免python时间冲刷掉更重要的结果。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/1c5314bbb3f3012b191291ba83793aa9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1282/format:webp/1*P6nLzF0tOjMuN5ElmkGctg.png"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">CPU基准(数据:基准游戏)</figcaption></figure><p id="3cc5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我知道基准是“人造的”，统计是骗人的，X没有查gcc-go等等。我对此事的想法是，像生活中的大多数事情一样，这是一种权衡。Golang面向服务器，它有一个快速的单代GC，牺牲对象创建/删除速度来实现亚毫秒级的“停止世界”暂停，这意味着服务将会很快，并且没有奇怪的GC hickups，如<a class="ae ms" href="https://www.techempower.com/benchmarks/#section=data-r16&amp;hw=ph&amp;test=fortune" rel="noopener ugc nofollow" target="_blank">服务器基准</a>所示，其中go-fasthttp在307个中排名第4，而nodeJS排名第77，而java出现在第3，vert.x还不是编写Java服务器的流行方法，undertow排名第19，要找到jetty需要下到第77</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ni"><img src="../Images/07aa5c0b6bc887de892db69e92d3c45a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-P-xNKQ2btz0nrlhHgMruw.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">来源:<a class="ae ms" href="https://www.techempower.com/benchmarks" rel="noopener ugc nofollow" target="_blank">techempower.com/benchmarks</a></figcaption></figure><p id="0135" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Golang中的这种GC策略也意味着，当创建<strong class="jp ir">大量</strong>短期实例时，Golang将会变慢，如<a class="ae ms" href="https://benchmarksgame-team.pages.debian.net/benchmarksgame/performance/binarytrees.html" rel="noopener ugc nofollow" target="_blank"> bin-tree基准测试</a>所示，其中创建了大量节点来构建大型树结构:Golang比C慢11倍，而C#。netCore (3.1倍)，Java(慢3.4倍)，NodeJS (9.2倍)。这个问题的证据可以在<a class="ae ms" href="https://blog.kowalczyk.info/article/u5o7/speeding-up-go-with-custom-allocators.html" rel="noopener ugc nofollow" target="_blank">这里</a>看到，通过使用自定义分配，避免了垃圾收集，从而修复了性能问题，我不相信大多数正常的用例会产生类似的情况，所以Golang应该可以处理您的服务器工作流。</p><p id="f8ac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在大多数情况下，代码实现细节比任何语言细节对真实世界的性能更重要，但如果你想挑剔(我们确实如此)，Golang是高性能代码的可靠赌注，因为它在10个基准测试中获得了5个第一，4个第一，1个第一。</p><h2 id="3662" class="ma ld iq bd le mb mc dn li md me dp lm jy mf mg lq kc mh mi lu kg mj mk ly ml bi translated"><strong class="ak">异步&amp;并行编程</strong></h2><p id="c627" class="pw-post-body-paragraph jn jo iq jp b jq mm js jt ju mn jw jx jy mo ka kb kc mp ke kf kg mq ki kj kk ij bi translated"><strong class="jp ir"> Java:旧的线程池范例，</strong>使用操作系统线程，允许自我管理和一些池功能，提供同步原语，如互斥和信号量，以及对函数的同步访问。Async IO是在最近的版本中引入的，但是Java缺乏一些现代的方法，这些方法应该使这个混乱的领域易于实现，并使您远离线程泄漏、死锁和许多其他并行编码的恐惧。</p><p id="151e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> C# </strong> : <strong class="jp ir">一些很好的同步和并行方法，有时有点混乱<br/> </strong> C#拥有所有可以提供的并行方法，操作系统线程、线程池、同步原语和高级同步对象以及任务调度(TPL)，但这并不十分直接:任务可以通过使用continueWith， 这为代码的并行执行提供了更方便的方法，但任务抢占并不总是由框架来处理，因此http请求仍然可以占用OS线程，直到超时或收到响应，为了确保异步，应该使用较新的http客户端的async/await方法，这意味着您的代码的其余部分也应该是异步的…正确的用法并不像应该的那样清楚或简单，因为框架中有许多不同的async &amp;并行选项。 对于异步编程，我们有Async/Await功能，当您不将它与需要同步UI线程的胖客户端混合时，它工作得很好。正如你所理解的，C#非常努力地给我们提供一切…但是它缺乏事后诸葛亮从头开始构建的平滑度。</p><p id="ed66" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> TS:简单、无并行、始终异步代码<br/> </strong> NodeJS采用JS方法，其中有一个线程用于处理JS命令，并将所有IO工作卸载到由操作系统管理的异步IO线程，以执行与磁盘/网络的任何事务。主线程由任务队列管理，这意味着最终在NodeJS进程中任何时候都只有一个JS命令被处理。这意味着您的代码总是异步的，消除了解决同步代码和粘性异步代码的问题，这些代码往往会以其异步的方式感染所有相邻的代码。</p><p id="1e2e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我第一次听说这种“单线程”操作模式时，我感到非常惊讶，因为服务器都是高效地使用所有内核来最大化每秒处理的呼叫。但是如果你把它想得更长远一点，一些著名的数据库在很长一段时间内使用多进程架构，所以如果每个进程的开销不大，那么拥有一个好的“每个进程单线程”管理方案是有意义的，NodeJS成功地提供了这一点。</p><p id="3847" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">缺点是你的代码完全是以异步方式编写的，回调和承诺都有一个学习曲线，使用async/await要好得多，但你仍然需要记住你的代码是暂停的，并相应地计划。</p><p id="f643" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> go:并行供电，同步代码直到被请求<br/> </strong> Golang让您对并行和异步流有了更多的控制，您可能会认为以前的语言如java/C#已经是这样了，但是当您看到一百万个GO例程可以同时运行而不影响系统性能时，您会意识到这里有一些新的东西(我刚才谈到的自动抢占)……<br/>GO routine不是线程<a class="ae ms" href="https://codeburst.io/why-goroutines-are-not-lightweight-threads-7c460c1f155f" rel="noopener" target="_blank">它们只占用2k个堆栈并保存在GO的托管内存池中，因此创建它们和go还为您提供了作为生产者-消费者队列的通道，用于将go例程联系在一起，并为大多数同步问题提供了简化的解决方案，引导您远离那些讨厌的同步灾难。</a></p><p id="f8d4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">谈过权力之后，我们仍然应该想到简单；在golang中，编写sync很简单，但当进行async时，有一个学习曲线，你需要考虑“Go方式”:如何正确地创建Go例程，传递通道，执行select语句，并检查例程在完成后是否正确关闭。简而言之，尽管Golang拥有优越的并行设施，但你仍然不希望将异步/并行代码设计留给你最弱的程序员。</p><p id="6996" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">看看这个展示Golang力量的很酷的例子:</p><pre class="km kn ko kp gt nj nk nl nm aw nn bi"><span id="3c11" class="ma ld iq nk b gy no np l nq nr"><strong class="nk ir">100K-long goroutine chain: (~600 Milisecs on my machine)</strong></span><span id="832d" class="ma ld iq nk b gy ns np l nq nr">package main<br/>import "fmt"</span><span id="a02a" class="ma ld iq nk b gy ns np l nq nr">func f(left, right chan int) { left &lt;- 1 + &lt;-right }</span><span id="027e" class="ma ld iq nk b gy ns np l nq nr">func main() {<br/>  leftmost := make(chan int);<br/>  var left, right chan int = nil, leftmost;<br/>  for i:= 0; i&lt; 100000; i++ {<br/>    left, right = right, make(chan int);<br/>    go f(left, right);<br/>  }<br/>  right &lt;- 0;  // bang!<br/>  x := &lt;-leftmost;  // wait for completion<br/>  fmt.Println(x);   // 1000000<br/>}</span></pre><h1 id="b8d9" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">代码编写经验</h1><h2 id="efcb" class="ma ld iq bd le mb mc dn li md me dp lm jy mf mg lq kc mh mi lu kg mj mk ly ml bi translated">序列化</h2><p id="73b7" class="pw-post-body-paragraph jn jo iq jp b jq mm js jt ju mn jw jx jy mo ka kb kc mp ke kf kg mq ki kj kk ij bi translated">TS中的序列化支持只使用JS，具有定义接口的额外能力，这些接口概述了序列化的对象，允许容易的代码完成支持。这是迄今为止我在任何语言中体验过的最简单的序列化。GO序列化支持也不错，但是它需要定义和填充结构以及一些序列化符号来指示json字段名，或者使用Goalng的未知类型“interface{}”:</p><ul class=""><li id="6eb6" class="mt mu iq jp b jq jr ju jv jy mv kc mw kg mx kk my mz na nb bi translated"><strong class="jp ir">map[string]interface { }</strong>//未知类型的地图</li><li id="eace" class="mt mu iq jp b jq nc ju nd jy ne kc nf kg ng kk my mz na nb bi translated"><strong class="jp ir">【接口】</strong>//一个未知类型的数组</li></ul><pre class="km kn ko kp gt nj nk nl nm aw nn bi"><span id="ca1a" class="ma ld iq nk b gy no np l nq nr"><strong class="nk ir">Using Object Definitions:</strong></span><span id="78bd" class="ma ld iq nk b gy ns np l nq nr"><strong class="nk ir">TS:<br/></strong>class ChildStruct {<br/>    Text: string;<br/>    SomeField: string;<br/>}<br/>class SomeStruct {<br/>    isAFoo: boolean;<br/>    someField: string;<br/>    children Array&lt;ChildStruct&gt;;<br/>}<br/>var p0 = new <!-- -->SomeStruct<!-- -->(true, "blah", [{"aa","bb"},{"cc","dd"}]);<br/>var s = JSON.stringify(p0);</span><span id="605b" class="ma ld iq nk b gy ns np l nq nr"><strong class="nk ir">GO:</strong><br/>type ChildStruct struct {<br/> Text     string         `json:"text,omitempty"`<br/> SomeField string        `json:"someField,omitempty"`<br/>}<br/>type SomeStruct struct {<br/>   IsAFoo   bool           `json:"isAFoo"`<br/>   Text     string         `json:"text,omitempty"`<br/>   Children []*ChildStruct `json:"children,omitempty"`<br/>}</span><span id="b7b3" class="ma ld iq nk b gy ns np l nq nr">jstr, _ := json.Marshal(SomeStruct{<br/>    IsAFoo: true,<br/>    Text: "blah",<br/>    Children: []*ChildStruct{<br/>        &amp;ChildStruct{<br/>            Text:      "aa",<br/>            SomeField: "bb",<br/>        },<br/>        &amp;ChildStruct{<br/>            Text:      "cc",<br/>            SomeField: "dd",<br/>        },<br/>    },<br/>})</span><span id="20d0" class="ma ld iq nk b gy ns np l nq nr"><strong class="nk ir">Inline Serialization:</strong></span><span id="e0e2" class="ma ld iq nk b gy ns np l nq nr"><strong class="nk ir">TS:<br/></strong>let obj= {<br/>    "isAFoo": true,<br/>    "text":   "blah",<br/>    "children": [<br/>       {<br/>            "text": "aa",<br/>            "someField": "bb",<br/>        },<br/>        {<br/>            "text": "cc",<br/>            "someField": "dd",<br/>        },<br/>    ],<br/>}<br/>let str = JSON.serialize(ob);</span><span id="73f3" class="ma ld iq nk b gy ns np l nq nr"><strong class="nk ir">GO:</strong><br/>obj := map[string]interface{}{<br/>    "isAFoo": true,<br/>    "text":   "blah",<br/>    "children": []interface{}{<br/>        map[string]interface{}{<br/>            "text": "aa",<br/>            "someField": "bb",<br/>        },<br/>        map[string]interface{}{<br/>            "text": "cc",<br/>            "someField": "dd",<br/>        },<br/>    },<br/>}</span><span id="28d4" class="ma ld iq nk b gy ns np l nq nr">jstr, _ := json.Marshal(obj)</span></pre><p id="0e75" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但这是真正强打字的代价。</p><h2 id="43a2" class="ma ld iq bd le mb mc dn li md me dp lm jy mf mg lq kc mh mi lu kg mj mk ly ml bi translated">网络协议操作:</h2><p id="0210" class="pw-post-body-paragraph jn jo iq jp b jq mm js jt ju mn jw jx jy mo ka kb kc mp ke kf kg mq ki kj kk ij bi translated"><strong class="jp ir"> JS </strong>拥有创建服务器&amp;代理的所有标准机制，因此在大多数情况下，如REST服务、Websockets &amp;您运行的工厂代理这就足够了，但当需要改变低级http服务器调用或创建一些特殊的协议适配时，基本库不允许足够的控制，您最终会求助于黑客&amp;变通办法。</p><p id="9872" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Go是深度协议编程的自然选择，因为它提供了极大的灵活性。在http处理中，它提供了一种劫持底层TCP通道的方法，它是简单的io。读取器/写入器接口允许完全控制，没有流的抽象。我对这种机制唯一的不满是，由于某种原因，http基本库直接使用缓冲io，而不仅仅是实现io.reader。</p><h2 id="4522" class="ma ld iq bd le mb mc dn li md me dp lm jy mf mg lq kc mh mi lu kg mj mk ly ml bi translated">本机集成:</h2><p id="cf4e" class="pw-post-body-paragraph jn jo iq jp b jq mm js jt ju mn jw jx jy mo ka kb kc mp ke kf kg mq ki kj kk ij bi translated">JavaScript/TS 不会让你在这方面走得太远，通常只是调用一些二进制可执行文件，这些文件是你在几个操作系统版本中与模块打包在一起的，总会有Gyp，但我绝不会推荐它。</p><p id="9f25" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="nt"> Go </em>有几种机制，包括:</p><ul class=""><li id="14a4" class="mt mu iq jp b jq jr ju jv jy mv kc mw kg mx kk my mz na nb bi translated">不安全的Go代码</li><li id="851e" class="mt mu iq jp b jq nc ju nd jy ne kc nf kg ng kk my mz na nb bi translated">CGo:在注释中编写c语言，然后编译(也可以包括cpp或ObjectiveC语法和文件)</li><li id="9078" class="mt mu iq jp b jq nc ju nd jy ne kc nf kg ng kk my mz na nb bi translated">“syscall”模块内置于语言中，在加载和调用windows dlls时非常方便。</li></ul><p id="0022" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于编写跨平台的边缘案例，我更喜欢Golang，但如果你问我，大多数时候我会选择cmdline集成(一个小的exe来完成这项工作),并坚持为我的大部分解决方案使用100%的跨操作系统代码，为一些小的卫星二进制文件使用100%的本地代码进行一些本地操作(这里不讨论移动，这完全是另一回事)。</p><h2 id="dc03" class="ma ld iq bd le mb mc dn li md me dp lm jy mf mg lq kc mh mi lu kg mj mk ly ml bi translated">错误处理:</h2><p id="e503" class="pw-post-body-paragraph jn jo iq jp b jq mm js jt ju mn jw jx jy mo ka kb kc mp ke kf kg mq ki kj kk ij bi translated"><strong class="jp ir"> Java/C#/Python </strong>:通过异常处理错误，在这些语言中，大多数错误，下至基本库，都被视为异常，包括像“找不到文件”这样的琐碎事情，Java是迄今为止最糟糕的，迫使程序员声明哪些异常可以抛出，这就引出了一个问题:“如果你期望它们，为什么它们被称为<strong class="jp ir">异常</strong>？”…</p><p id="a80f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<strong class="jp ir"> JS/TS </strong>中的错误处理取决于你是否使用了承诺，如果没有，那么错误通常作为回调参数返回，对于承诺错误，它们与异常处理非常相似，我们可以说错误通常是通过应用程序抛出的，除非被显式处理。此外，像大多数以前的语言一样，空值或未定义的值容易产生臭名昭著的空指针错误，这通常占代码错误的90%。</p><p id="eb16" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在Golang中，错误有点不同，尽管存在异常机制(称为恐慌)，但不鼓励这样做。框架库很少会死机，而且从来不会出现在常规的东西上，相反，有一个<strong class="jp ir"> err </strong>返回值需要你的注意，即使只是用下划线“_”来忽略它。</p><p id="107c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过将接收器对象传递给函数(在大多数语言中接收器= the " <strong class="jp ir"> this" object </strong>，有时在JS中也是如此)，可以减少空指针错误，因此在运行函数之前可以在接收器上进行空检查，这意味着foo。RunMe()不必自动抛出“foo未定义”错误。</p><h2 id="4ef8" class="ma ld iq bd le mb mc dn li md me dp lm jy mf mg lq kc mh mi lu kg mj mk ly ml bi translated">代码清洁度:</h2><p id="a2d6" class="pw-post-body-paragraph jn jo iq jp b jq mm js jt ju mn jw jx jy mo ka kb kc mp ke kf kg mq ki kj kk ij bi translated">我们讨论的大多数语言都是C语法，因此有些相似，JS、TS、Java、C#语法在编码时感觉是一样的。python和Go都打破了传统，Python力求更好的可读性，而Go则追求简化的语言和更好的性能。</p><p id="ff86" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Go是一种经过深思熟虑的语言，但它有时会在基本情况下强制执行较长的代码，从而妨碍了流畅的代码编写:</p><ul class=""><li id="856c" class="mt mu iq jp b jq jr ju jv jy mv kc mw kg mx kk my mz na nb bi translated">比特运算(Go中没有三元运算符)</li></ul><pre class="km kn ko kp gt nj nk nl nm aw nn bi"><span id="dc11" class="ma ld iq nk b gy no np l nq nr"><strong class="nk ir">JS/TS (+Java/C#): </strong><br/>res = (aa%2 == 0)?"even":"odd";</span><span id="1aae" class="ma ld iq nk b gy ns np l nq nr"><strong class="nk ir">Py3:<br/></strong>res = "even" if (aa%2 == 0)  else "odd"</span><span id="149c" class="ma ld iq nk b gy ns np l nq nr"><strong class="nk ir">Go:</strong><br/>var res string<br/>if aa%2 == 0 {<br/>    res = "even"<br/>}<br/>res = "odd"</span></pre><ul class=""><li id="99d4" class="mt mu iq jp b jq jr ju jv jy mv kc mw kg mx kk my mz na nb bi translated">基本字符串操作</li></ul><pre class="km kn ko kp gt nj nk nl nm aw nn bi"><span id="555f" class="ma ld iq nk b gy no np l nq nr"><strong class="nk ir">JS/TS (similarly Java/C#):<br/></strong>("stUff"+1).toLowerCase().startsWith("stu");</span><span id="0a7f" class="ma ld iq nk b gy ns np l nq nr"><strong class="nk ir">Py3:<br/></strong>("stUff"+str(1)).lower().startswith("stu")</span><span id="fef9" class="ma ld iq nk b gy ns np l nq nr"><strong class="nk ir">Go:<br/></strong>strings.HasPrefix(strings.ToLower("stUff")+strconv.Itoa(1),"stu")</span></pre><ul class=""><li id="f251" class="mt mu iq jp b jq jr ju jv jy mv kc mw kg mx kk my mz na nb bi translated">追加到数组</li></ul><pre class="km kn ko kp gt nj nk nl nm aw nn bi"><span id="9322" class="ma ld iq nk b gy no np l nq nr"><strong class="nk ir">JS/TS:<br/></strong>arr.push("Hola");</span><span id="78ac" class="ma ld iq nk b gy ns np l nq nr"><strong class="nk ir">Py3</strong>:<br/>arr.append("Hola");</span><span id="530a" class="ma ld iq nk b gy ns np l nq nr"><strong class="nk ir">Go:<br/></strong>arr=append(<!-- -->arr,"Hola"<!-- -->)</span></pre><h1 id="e07f" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated"><strong class="ak">生态系统(工具、开发运维&amp;社区)</strong>:</h1><h2 id="21ab" class="ma ld iq bd le mb mc dn li md me dp lm jy mf mg lq kc mh mi lu kg mj mk ly ml bi translated"><strong class="ak">模块&amp;副管理</strong></h2><p id="2ce2" class="pw-post-body-paragraph jn jo iq jp b jq mm js jt ju mn jw jx jy mo ka kb kc mp ke kf kg mq ki kj kk ij bi translated">Java  : Maven/Gradel:很好的dep管理，但是下载需要很长时间，并且当它失败时很难理解。</p><p id="8501" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> C# </strong> : Nuget还可以，但绝对没有其他社区组件生态系统丰富。</p><p id="2d5b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> Python </strong> : Pip比大多数版本好得多，但是Py 2.7和3之间的混淆，以及大多数人使用virtual-env来避免冲突的事实，表明它并不完美。</p><p id="1517" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> TS/JS: </strong>在我看来，NPM是目前市场上最好的包管理器&amp;模块库，它处理深度依赖树、多个依赖版本、语义版本化和收缩包装，以实现深度依赖版本的稳定性，并拥有本地dep库和全局dep代理的解决方案。这既是一件好事也是一件坏事，因为它创造了一个生态系统，在这个生态系统中，导入一个依赖项可以将50个或更多的子依赖项拖到您的项目中。</p><p id="8688" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Golang有一种非常新颖的依赖方法，它使用git repos获得所有依赖项作为代码，并在最后编译一切，这种方法解决了编译语言的几个典型问题:依赖链接和操作系统特定的二进制格式。但是当继续构建企业级项目时，它也产生了模块版本化、不同版本的依赖性重复等问题。有大量不同的社区项目试图定义处理这个问题的正确方法，还有一些官方项目。目前有两个官方工具和一个正在开发中的工具:</p><ul class=""><li id="5145" class="mt mu iq jp b jq jr ju jv jy mv kc mw kg mx kk my mz na nb bi translated"><strong class="jp ir"> go get </strong>:获得依赖关系的内置工具，没有版本控制的解决方案，不能与TFS/stash/其他非github git服务器一起工作，(但是如果你真的想让它工作，有一个<a class="ae ms" href="http://ppanyukov.github.io/2017/02/01/golang-with-vsts-repos.html" rel="noopener ugc nofollow" target="_blank"> hack </a></li><li id="da9c" class="mt mu iq jp b jq nc ju nd jy ne kc nf kg ng kk my mz na nb bi translated"><a class="ae ms" href="https://github.com/golang/dep" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> dep </strong> </a>:自我定义为go 1.9+的“官方实验”，并通过保留一个文件来提供一些问题的解决方案，该文件映射您的代码导入的版本并将它们锁定到相应git repos中的特定提交。</li><li id="1737" class="mt mu iq jp b jq nc ju nd jy ne kc nf kg ng kk my mz na nb bi translated"><a class="ae ms" href="https://github.com/golang/go/wiki/vgo#current-state" rel="noopener ugc nofollow" target="_blank"/></li></ul><p id="d327" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">简而言之，Golang的CI/CD故事仍在发展，您采用的任何工具链都可能在不久的将来被修改，但我们应该记住，就在几年前，许多打字工具(如打字)也是如此。</p><h2 id="fee6" class="ma ld iq bd le mb mc dn li md me dp lm jy mf mg lq kc mh mi lu kg mj mk ly ml bi translated"><strong class="ak">部署、二进制大小、签名、混淆</strong></h2><p id="9221" class="pw-post-body-paragraph jn jo iq jp b jq mm js jt ju mn jw jx jy mo ka kb kc mp ke kf kg mq ki kj kk ij bi translated">NodeJS二进制文件只是JS代码的一个缝合堆，包括你递归导入的所有依赖项。对于一个中等规模的项目来说，它通常可以达到300Mb甚至更多。</p><p id="f7bd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是Go真正闪耀的地方:</p><ul class=""><li id="648c" class="mt mu iq jp b jq jr ju jv jy mv kc mw kg mx kk my mz na nb bi translated">二进制文件是独立的，特定于操作系统，一切都是可移植的，只需下载并运行即可。</li><li id="d0b6" class="mt mu iq jp b jq nc ju nd jy ne kc nf kg ng kk my mz na nb bi translated">可以对本机二进制文件进行签名，签名将在运行它们时由操作系统进行验证。</li><li id="d2f5" class="mt mu iq jp b jq nc ju nd jy ne kc nf kg ng kk my mz na nb bi translated">二进制文件很难理解，即使与cpp二进制文件相比也是如此，因为它们增加了垃圾收集机制来混淆IDA调试/破解。</li></ul><h2 id="f64d" class="ma ld iq bd le mb mc dn li md me dp lm jy mf mg lq kc mh mi lu kg mj mk ly ml bi translated">调试/ IDE环境</h2><p id="49c4" class="pw-post-body-paragraph jn jo iq jp b jq mm js jt ju mn jw jx jy mo ka kb kc mp ke kf kg mq ki kj kk ij bi translated">我们都习惯于由专业人员精心调整的非常高级的调试器环境，这适用于JS / TS，以及C#、Java和我编写的大多数其他语言，<strong class="jp ir"> C# </strong>在VsCode中拥有最好的微软支持&amp; VStudio，具有闪亮的功能，如编辑并继续，支持在调试时移动指令指针，以及jetbrains resharper的高级重构支持。<strong class="jp ir"> Java </strong>显然拥有最多的ide，<strong class="jp ir"> JavaScript </strong>拥有一些最好的支持，以及Jetbrains支持和VsCode，以及各种编辑器和浏览器内调试。<strong class="jp ir"> Typescript </strong>在JS支持map文件的地方支持调试，同时也有很好的VsCode支持和IntelliJ/WebStorm支持。</p><p id="1f02" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Python没有太多的IDE选择，许多使用高级文本编辑器，它有很好的VsCode支持和PyCharm/IntelliJ，但是它没有这里的其他语言那么多的选项和深度集成。</p><p id="bb3b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> Golang </strong>调试尚未完善。delve调试器在大约6个多月前才达到1.0的状态<a class="ae ms" href="https://github.com/derekparker/delve/releases/tag/v1.0.0" rel="noopener ugc nofollow" target="_blank"/>，它还没有完全的特性和调整。IDE环境也在迎头赶上:<strong class="jp ir"> VSCode </strong>有基本的Go支持，但它在进行基本的重构(如重命名变量)时遇到了麻烦，在控制台或观察器中没有函数调用支持，在调试时没有新的断点设置，并且对变量引用树和大型数组的可见性有限。Goland / IntelliJ 插件更好，据说有谷歌的支持，快速重构，更快的响应时间和更好的变量可见性，但这是一个付费选项。</p><h1 id="1f26" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">底线是:</h1><p id="2bae" class="pw-post-body-paragraph jn jo iq jp b jq mm js jt ju mn jw jx jy mo ka kb kc mp ke kf kg mq ki kj kk ij bi translated">虽然C#和Java显然受到了遗留代码驱动的惰性的推动，但TS、Py和Go在这里是有原因的，NodeJS/TS在一些类别中胜出，如:"<strong class="jp ir">最快的上市时间</strong>"和"<strong class="jp ir">最佳工具链</strong>"，Python胜出"<strong class="jp ir">最容易的集合操作和数字处理</strong>，这解释了它在DataSciense中的受欢迎程度，Golang会认为:"<strong class="jp ir">最佳内存消耗</strong>"，<strong class="jp ir">在压力下保持稳定</strong>"和<strong class="jp ir">Golang是一个比NodeJS更强大的平台，允许更多的篡改协议通道的能力，并以相对简化的方式运用并行计算的力量，大多数高级程序员都会喜欢使用它，尽管一般的开发人员可能更喜欢JS。</strong></p><p id="8f44" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对我来说，Golang带我回到了“one exe”是一个有价值的目标的时代，最专业的软件是极其便携的，紧密包装和防篡改的。我喜欢这一点…不知何故，我仍然认为有些类型的软件应该带着闪亮的硬壳出厂，而不是作为一堆一千个松散连接的部件，在正确组装时运行良好。</p></div></div>    
</body>
</html>