<html>
<head>
<title>Batch Processing Large Data Sets with Spring Boot and Spring Batch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Spring Boot和Spring批处理大数据集</h1>
<blockquote>原文：<a href="https://itnext.io/batch-processing-large-data-sets-with-spring-boot-and-spring-batch-80b8f8c2411e?source=collection_archive---------0-----------------------#2019-07-22">https://itnext.io/batch-processing-large-data-sets-with-spring-boot-and-spring-batch-80b8f8c2411e?source=collection_archive---------0-----------------------#2019-07-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="6ba3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">数据的批处理是处理大量数据的有效方式，其中数据被收集、处理，然后产生批处理结果。批处理可以应用在许多用例中。批处理的一个常见用例是将大量的平面、CSV或JSON文件转换成结构化格式，以便于进一步处理。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ko"><img src="../Images/bace86e396e11e2a38668b06d898f218.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*AuuygyQOYhHm0lBFjDNzuA.png"/></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">Spring Boot和春季批次</figcaption></figure><p id="d7f9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本文中，我将使用Spring的一个项目Spring Batch来演示批处理。Spring Batch提供了在批处理作业中处理大量数据的功能。这包括日志记录、事务管理、作业重启(如果作业未完成)、作业跳过、作业处理统计和资源管理。</p><p id="8d46" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们简单地看看Spring Batch是如何工作的。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="gh gi la"><img src="../Images/bff7a6fc3ec78f84baba4a4df2edfcb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UCnovgP2EMCx5jqXBbOSsg.png"/></div></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">春季批次概述</figcaption></figure><p id="963d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一个<em class="lf">步骤</em>是一个对象，它封装了一个作业的连续阶段，并保存了定义和控制处理的所有必要信息。它将所有信息委托给一个作业来执行它的任务。</p><p id="fb2b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Spring Batch使用面向块的处理方式，一次读取一个数据，并创建将在事务中写出的<em class="lf">块</em>。项目由<em class="lf">项目阅读器</em>读取，并传递到<em class="lf">项目处理器</em>，然后一旦项目准备好，就由<em class="lf">项目写入器</em>写出。作业存储库将用于在项目处理期间定期存储步骤执行。</p><p id="d8d1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们开始编码吧。</p><h1 id="e660" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">设置项目</h1><p id="081b" class="pw-post-body-paragraph jq jr it js b jt me jv jw jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn im bi translated">创建一个示例Spring Boot应用程序。这是我的示例项目结构。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/ade1b9a95cf63f8ecf0b01d65f1ca3dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/1*QhcNsdqIQKtAv60HjXlJ5A.png"/></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">项目结构</figcaption></figure><p id="4175" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本文中，我将使用代表放电电容压降的样本数据。我们将从CSV文件中读取这些数据，并将其写入内存中的数据库，即H2。</p><p id="a01c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">将所需的依赖项添加到<em class="lf"> pom.xml. </em></p><pre class="kp kq kr ks gt mk ml mm mn aw mo bi"><span id="23cd" class="mp lh it ml b gy mq mr l ms mt">&lt;dependency&gt;<br/>            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br/>            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;<br/>        &lt;/dependency&gt;<br/>        &lt;dependency&gt;<br/>            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br/>            &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;<br/>        &lt;/dependency&gt;<br/>        &lt;dependency&gt;<br/>            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br/>            &lt;artifactId&gt;spring-boot-starter-batch&lt;/artifactId&gt;<br/>        &lt;/dependency&gt;<br/>        &lt;dependency&gt;<br/>            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br/>            &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;<br/>        &lt;/dependency&gt;<br/>        &lt;dependency&gt;<br/>            &lt;groupId&gt;com.h2database&lt;/groupId&gt;<br/>            &lt;artifactId&gt;h2&lt;/artifactId&gt;<br/>            &lt;scope&gt;runtime&lt;/scope&gt;<br/>        &lt;/dependency&gt;<br/>        &lt;dependency&gt;<br/>            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;<br/>            &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;<br/>        &lt;/dependency&gt;</span></pre><p id="4da7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">CSV文件<em class="lf"> Volts.csv </em>包含两个字段<em class="lf"> volt </em>和<em class="lf"> time。</em>让我们创建一个名为<em class="lf">电压</em>的JPA实体。请注意，这个实体仅用于示例。它不是生产就绪代码。</p><pre class="kp kq kr ks gt mk ml mm mn aw mo bi"><span id="632e" class="mp lh it ml b gy mq mr l ms mt">package com.techshard.batch.dao.entity;</span><span id="4521" class="mp lh it ml b gy mu mr l ms mt">import javax.persistence.*;<br/>import javax.validation.constraints.NotNull;<br/>import java.math.BigDecimal;</span><span id="ecdf" class="mp lh it ml b gy mu mr l ms mt">@Entity<br/>public class Voltage {</span><span id="1caa" class="mp lh it ml b gy mu mr l ms mt">    @Id<br/>    @Column (name = "ID", nullable = false)<br/>    @GeneratedValue (strategy = GenerationType.IDENTITY)<br/>    private long id;</span><span id="36d4" class="mp lh it ml b gy mu mr l ms mt">    @NotNull<br/>    @Column (name = "volt", precision = 10, scale = 4, nullable = false)<br/>    private BigDecimal volt;</span><span id="bf50" class="mp lh it ml b gy mu mr l ms mt">    @NotNull<br/>    @Column (name = "time", nullable = false)<br/>    private double time;</span><span id="d00f" class="mp lh it ml b gy mu mr l ms mt">    public Voltage() {<br/>    }</span><span id="a421" class="mp lh it ml b gy mu mr l ms mt">    public Voltage(final BigDecimal volt, final double time) {<br/>        this.volt = volt;<br/>        this.time = time;<br/>    }</span><span id="64d0" class="mp lh it ml b gy mu mr l ms mt">    public long getId(){<br/>        return id;<br/>    }</span><span id="0b32" class="mp lh it ml b gy mu mr l ms mt">    public BigDecimal getVolt(){<br/>        return volt;<br/>    }</span><span id="a7d4" class="mp lh it ml b gy mu mr l ms mt">    public void setVolt(final BigDecimal volt){<br/>        this.volt = volt;<br/>    }</span><span id="2f12" class="mp lh it ml b gy mu mr l ms mt">    public double getTime(){<br/>        return time;<br/>    }</span><span id="a54b" class="mp lh it ml b gy mu mr l ms mt">    public void setTime(final double time){<br/>        this.time = time;<br/>    }<br/>}</span></pre><h1 id="5341" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">批量配置</h1><p id="dd85" class="pw-post-body-paragraph jq jr it js b jt me jv jw jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn im bi translated">让我们创建一个批处理配置类:</p><pre class="kp kq kr ks gt mk ml mm mn aw mo bi"><span id="5293" class="mp lh it ml b gy mq mr l ms mt">@Configuration<br/>@EnableBatchProcessing<br/>public class BatchConfiguration {<br/>}</span></pre><p id="8aa8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">@EnableBatchProcessing 启用Spring批处理特性，并为在@Configuration类中设置批处理作业提供基本配置。</p><p id="3ca1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们需要在上面的类中包含两个组件。</p><pre class="kp kq kr ks gt mk ml mm mn aw mo bi"><span id="8cf6" class="mp lh it ml b gy mq mr l ms mt">    @Autowired<br/>    public JobBuilderFactory jobBuilderFactory;</span><span id="a0ad" class="mp lh it ml b gy mu mr l ms mt">    @Autowired<br/>    public StepBuilderFactory stepBuilderFactory;</span></pre><p id="b37d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="lf"> JobBuilderFactory </em>创建一个作业生成器。使用<em class="lf"> StepBuilderFactory </em>，Spring Batch将创建一个步骤构建器，并初始化它的作业存储库和事务管理器。</p><h1 id="92ea" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">配置ItemReader</h1><p id="4309" class="pw-post-body-paragraph jq jr it js b jt me jv jw jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn im bi translated">我们现在将为我们的模型<em class="lf">电压</em>定义<em class="lf"> ItemReader </em>接口，它将用于从CSV文件中读取数据。</p><pre class="kp kq kr ks gt mk ml mm mn aw mo bi"><span id="0e8a" class="mp lh it ml b gy mq mr l ms mt">@Bean<br/>    public FlatFileItemReader&lt;Voltage&gt; reader() {<br/>        return new FlatFileItemReaderBuilder&lt;Voltage&gt;()<br/>                .name("voltItemReader")<br/>                .resource(new ClassPathResource("Volts.csv"))<br/>                .delimited()<br/>                .names(new String[]{"volt", "time"})<br/>                .lineMapper(lineMapper())<br/>                .fieldSetMapper(new BeanWrapperFieldSetMapper&lt;Voltage&gt;() {{<br/>                    setTargetType(Voltage.class);<br/>                }})<br/>                .build();<br/>    }</span></pre><p id="fab6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里，我们正在创建模型<em class="lf">电压的FlatFileItemReaderBuilder。</em></p><p id="d5bb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="lf">名称</em>—<em class="lf">阅读器的名称</em></p><p id="6af9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="lf">资源</em> —指定要读取的资源文件的路径。</p><p id="cd70" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="lf"> delimited — </em>构建分隔符号化器。</p><p id="b9e3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="lf">名称— </em>传递要读取的字段</p><p id="4963" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="lf"> lineMapper </em> —将行从文件映射到域对象的接口。</p><p id="5964" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="lf"> fieldSetMapper — </em>将从字段集中获取的数据映射到对象的接口。</p><p id="023c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">注意，我们已经通过了上面的custom <em class="lf"> lineMapper() </em>。让我们来定义这个bean。</p><pre class="kp kq kr ks gt mk ml mm mn aw mo bi"><span id="c672" class="mp lh it ml b gy mq mr l ms mt">@Bean<br/>    public LineMapper&lt;Voltage&gt; lineMapper() {</span><span id="0aa0" class="mp lh it ml b gy mu mr l ms mt">        final DefaultLineMapper&lt;Voltage&gt; defaultLineMapper = new DefaultLineMapper&lt;&gt;();<br/>        final DelimitedLineTokenizer lineTokenizer = new DelimitedLineTokenizer();<br/>        lineTokenizer.setDelimiter(";");<br/>        lineTokenizer.setStrict(false);<br/>        lineTokenizer.setNames(new String[] {"volt","time"});</span><span id="af4f" class="mp lh it ml b gy mu mr l ms mt">        final VoltageFieldSetMapper fieldSetMapper = new VoltageFieldSetMapper();<br/>        defaultLineMapper.setLineTokenizer(lineTokenizer);<br/>        defaultLineMapper.setFieldSetMapper(fieldSetMapper);</span><span id="519c" class="mp lh it ml b gy mu mr l ms mt">        return defaultLineMapper;<br/>    }</span></pre><p id="505b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在自定义<em class="lf"> lineMapper </em>中，我们可以指定从CSV文件中读取的分隔符，也用于将字符串值读入数据库特定数据类型。<em class="lf"> VoltageFieldSetMapper </em>定义如下:</p><pre class="kp kq kr ks gt mk ml mm mn aw mo bi"><span id="38a4" class="mp lh it ml b gy mq mr l ms mt">package com.techshard.batch.configuration;</span><span id="c9fc" class="mp lh it ml b gy mu mr l ms mt">import com.techshard.batch.dao.entity.Voltage;<br/>import org.springframework.batch.item.file.mapping.FieldSetMapper;<br/>import org.springframework.batch.item.file.transform.FieldSet;<br/>import org.springframework.stereotype.Component;</span><span id="8871" class="mp lh it ml b gy mu mr l ms mt">@Component<br/>public class VoltageFieldSetMapper implements FieldSetMapper&lt;Voltage&gt; {</span><span id="f1ba" class="mp lh it ml b gy mu mr l ms mt">    @Override<br/>    public Voltage mapFieldSet(FieldSet fieldSet) {<br/>        final Voltage voltage = new Voltage();</span><span id="223b" class="mp lh it ml b gy mu mr l ms mt">        voltage.setVolt(fieldSet.readBigDecimal("volt"));<br/>        voltage.setTime(fieldSet.readDouble("time"));<br/>        return voltage;</span><span id="4ab2" class="mp lh it ml b gy mu mr l ms mt">    }<br/>}</span></pre><h1 id="550f" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">正在配置项目处理器</h1><p id="667c" class="pw-post-body-paragraph jq jr it js b jt me jv jw jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn im bi translated">我们将按如下方式定义批处理配置中的处理器:</p><pre class="kp kq kr ks gt mk ml mm mn aw mo bi"><span id="661b" class="mp lh it ml b gy mq mr l ms mt">    @Bean<br/>    public VoltageProcessor processor() {<br/>        return new VoltageProcessor();<br/>    }</span></pre><p id="f5e4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们定义了一个定制处理器<em class="lf"> VoltageProcessor。</em>一旦数据被读取，该处理器用于处理数据，如数据转换、应用业务逻辑等。这只是一个例子。这种定制处理器并不总是必需的。它可以根据您的应用需求进行定义。</p><pre class="kp kq kr ks gt mk ml mm mn aw mo bi"><span id="4486" class="mp lh it ml b gy mq mr l ms mt">package com.techshard.batch.configuration;</span><span id="745c" class="mp lh it ml b gy mu mr l ms mt">import com.techshard.batch.dao.entity.Voltage;</span><span id="7b67" class="mp lh it ml b gy mu mr l ms mt">import org.springframework.batch.item.ItemProcessor;</span><span id="54a5" class="mp lh it ml b gy mu mr l ms mt">import java.math.BigDecimal;</span><span id="8486" class="mp lh it ml b gy mu mr l ms mt">public class VoltageProcessor implements ItemProcessor&lt;Voltage, Voltage&gt;{</span><span id="0a6e" class="mp lh it ml b gy mu mr l ms mt">    @Override<br/>    public Voltage process(final Voltage voltage) {<br/>        final BigDecimal volt = voltage.getVolt();<br/>        final double time = voltage.getTime();</span><span id="8ab9" class="mp lh it ml b gy mu mr l ms mt">        final Voltage processedVoltage = new Voltage();<br/>        processedVoltage.setVolt(volt);<br/>        processedVoltage.setTime(time);<br/>        return processedVoltage;<br/>    }<br/>}</span></pre><h1 id="5ad2" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">项目作者</h1><p id="b422" class="pw-post-body-paragraph jq jr it js b jt me jv jw jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn im bi translated">一旦数据被处理，数据需要按照我们的要求存储在数据库中。我们将定义一个<em class="lf"> JdbcBatchWriter </em>来将数据插入数据库表。还有JPA特有的<em class="lf"> JpaItemWriter </em>，可以和<em class="lf"> EntityManager </em>一起使用。</p><pre class="kp kq kr ks gt mk ml mm mn aw mo bi"><span id="de72" class="mp lh it ml b gy mq mr l ms mt">@Bean<br/>    public JdbcBatchItemWriter&lt;Voltage&gt; writer(final DataSource dataSource) {<br/>        return new JdbcBatchItemWriterBuilder&lt;Voltage&gt;()<br/>                .itemSqlParameterSourceProvider(new BeanPropertyItemSqlParameterSourceProvider&lt;&gt;())<br/>                .sql("INSERT INTO voltage (volt, time) VALUES (:volt, :time)")<br/>                .dataSource(dataSource)<br/>                .build();<br/>    }</span></pre><h1 id="bff5" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">作业和步骤配置</h1><p id="d219" class="pw-post-body-paragraph jq jr it js b jt me jv jw jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn im bi translated">我们现在将定义一个<em class="lf">步骤</em>，它将包含一个读取器、处理器和写入器，就像我们需要一个StepBuilderFactory一样，它将用于注入我们的Job()方法。</p><pre class="kp kq kr ks gt mk ml mm mn aw mo bi"><span id="8b1b" class="mp lh it ml b gy mq mr l ms mt">    @Bean<br/>    public Step step1(JdbcBatchItemWriter&lt;Voltage&gt; writer) {<br/>        return stepBuilderFactory.get("step1")<br/>                .&lt;Voltage, Voltage&gt; chunk(10)<br/>                .reader(reader())<br/>                .processor(processor())<br/>                .writer(writer)<br/>                .build();<br/>    }</span></pre><p id="6f10" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里，<em class="lf">步骤1 </em>只是我们可以定义的<em class="lf">步骤</em>的一个名称。我们也可以在<em class="lf">步骤</em>配置中指定块大小。</p><p id="4803" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，作业定义如下:</p><pre class="kp kq kr ks gt mk ml mm mn aw mo bi"><span id="6c42" class="mp lh it ml b gy mq mr l ms mt">@Bean<br/>    public Job importVoltageJob(NotificationListener listener, Step step1) {<br/>        return jobBuilderFactory.get("importVoltageJob")<br/>                .incrementer(new RunIdIncrementer())<br/>                .listener(listener)<br/>                .flow(step1)<br/>                .end()<br/>                .build();<br/>    }</span></pre><p id="3158" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">注意，我们已经传递了<em class="lf"> NotificationListener </em>，它扩展了Spring Batch的<em class="lf">JobExecutionListenerSupport</em>。它可以在作业执行之前或之后记录结果。这里，我们只定义了<em class="lf"> afterJob()。JobExecutionListenerSupport</em>还提供了<em class="lf"> beforeJob() </em>来记录作业执行前的任何信息。</p><pre class="kp kq kr ks gt mk ml mm mn aw mo bi"><span id="93c2" class="mp lh it ml b gy mq mr l ms mt">package com.techshard.batch.configuration;<br/><br/>import com.techshard.batch.dao.entity.Voltage;<br/>import org.slf4j.Logger;<br/>import org.slf4j.LoggerFactory;<br/>import org.springframework.batch.core.BatchStatus;<br/>import org.springframework.batch.core.JobExecution;<br/>import org.springframework.batch.core.listener.JobExecutionListenerSupport;<br/>import org.springframework.beans.factory.annotation.Autowired;<br/>import org.springframework.jdbc.core.JdbcTemplate;<br/>import org.springframework.stereotype.Component;<br/><br/>@Component<br/>public class NotificationListener extends JobExecutionListenerSupport{<br/><br/>    private static final Logger LOGGER = LoggerFactory.getLogger(NotificationListener.class);<br/><br/>    private final JdbcTemplate jdbcTemplate;<br/><br/>    @Autowired<br/>    public NotificationListener(final JdbcTemplate jdbcTemplate) {<br/>        this.jdbcTemplate = jdbcTemplate;<br/>    }<br/><br/>    @Override<br/>    public void afterJob(final JobExecution jobExecution) {<br/>        if(jobExecution.getStatus() == BatchStatus.COMPLETED) {<br/>            LOGGER.info("!!! JOB FINISHED! Time to verify the results");<br/><br/>            jdbcTemplate.query("SELECT volt, time FROM voltage",<br/>                    (rs, row) -&gt; new Voltage(<br/>                            rs.getBigDecimal(1),<br/>                            rs.getDouble(2))<br/>            ).forEach(voltage -&gt; LOGGER.info("Found &lt;" + voltage + "&gt; in the database."));<br/>        }<br/>    }<br/>}</span></pre><p id="2602" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在运行应用程序之前，我们将在application.properties中启用H2(内存中)控制台</p><pre class="kp kq kr ks gt mk ml mm mn aw mo bi"><span id="01b2" class="mp lh it ml b gy mq mr l ms mt">spring.datasource.url=jdbc:h2:mem:batchdb<br/>spring.datasource.driverClassName=org.h2.Driver<br/>spring.datasource.username=sa<br/>spring.datasource.password=password<br/>spring.jpa.database-platform=org.hibernate.dialect.H2Dialect<br/>spring.h2.console.enabled=true</span></pre><p id="0cfd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">此外，我还使用Spring AOP配置了Aspect来测量批处理执行所花费的时间。</p><pre class="kp kq kr ks gt mk ml mm mn aw mo bi"><span id="3b68" class="mp lh it ml b gy mq mr l ms mt">package com.techshard.batch;<br/><br/>import org.aspectj.lang.ProceedingJoinPoint;<br/>import org.aspectj.lang.annotation.Around;<br/>import org.aspectj.lang.annotation.Aspect;<br/>import org.aspectj.lang.reflect.MethodSignature;<br/>import org.slf4j.Logger;<br/>import org.slf4j.LoggerFactory;<br/>import org.springframework.stereotype.Component;<br/><br/>@Aspect<br/>@Component<br/>public class TracePerformanceAspect {<br/><br/>    private final Logger logger = LoggerFactory.getLogger(TracePerformanceAspect.class);<br/><br/>    @Around ("execution(* com.techshard..*.*(..)))")<br/>    public Object logTracePerformanceAspect(ProceedingJoinPoint joinPoint) throws Throwable {<br/><br/>        MethodSignature methodSignature = (MethodSignature) joinPoint.getSignature();<br/><br/>        //Get intercepted method details<br/>        String className = methodSignature.getDeclaringType().getSimpleName();<br/>        String methodName = methodSignature.getName();<br/><br/>        long start = System.currentTimeMillis();<br/><br/>        Object result = joinPoint.proceed();<br/>        long end = System.currentTimeMillis();<br/><br/>        //Log method execution time<br/>        logger.info("Execution time of " + className + "." + methodName + " :: " + (end - start) + " ms");<br/><br/>        return result;<br/>    }<br/>}</span></pre><h1 id="e381" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">运行应用程序</h1><p id="5e1b" class="pw-post-body-paragraph jq jr it js b jt me jv jw jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn im bi translated">运行Spring Boot应用程序。一旦应用程序启动，使用链接<a class="ae mv" href="http://localhost:8080/h2-console/" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/H2-console/</a>登录到H2控制台。然后，您将看到如下登录屏幕。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="gh gi mw"><img src="../Images/ed7b0a0bd4c48cdd7b5df3d676a73eca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7QAGfLPD-sWL6J_20FCfZQ.png"/></div></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">H2控制台登录屏幕</figcaption></figure><p id="ba9f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一旦我们登录，我们将能够看到表<em class="lf">电压</em>和所有由Spring Batch创建的表。在这些表中，我们将找到关于作业执行的所有细节，比如作业名称、状态、id等等。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/e75225d31ffc4177bef2d9fcefeb3043.png" data-original-src="https://miro.medium.com/v2/resize:fit:1112/format:webp/1*l7kF5L_5rd9ian_cs65g-A.png"/></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">H2数据库</figcaption></figure><h1 id="2da4" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">结论</h1><p id="f487" class="pw-post-body-paragraph jq jr it js b jt me jv jw jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn im bi translated">本文只是大体上触及了Spring Batch的皮毛。本文中使用的示例不是生产就绪代码。您可以根据项目要求定义作业配置。我希望你喜欢这篇文章。如果你有任何意见或建议，请告诉我。</p><p id="2d5f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">完整的代码可以在我的<a class="ae mv" href="https://github.com/swathisprasad/batch-processing-large-datasets-spring" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>中找到。</p><p id="c353" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">【Techshard.com】本文原载于<a class="ae mv" href="https://techshard.com/2019/07/22/batch-processing-large-data-sets-with-spring-boot-and-spring-batch/" rel="noopener ugc nofollow" target="_blank"><em class="lf"/></a><em class="lf">。</em></p></div></div>    
</body>
</html>