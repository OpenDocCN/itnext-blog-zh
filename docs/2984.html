<html>
<head>
<title>Getting Started with Clojure</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Clojure入门</h1>
<blockquote>原文：<a href="https://itnext.io/getting-started-with-clojure-e8f207ff8eab?source=collection_archive---------1-----------------------#2019-09-11">https://itnext.io/getting-started-with-clojure-e8f207ff8eab?source=collection_archive---------1-----------------------#2019-09-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ea3f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何用Clojure构建简单的REST API</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/07d140beb9b0b052e658528b477a7839.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hBoQLWpkQzwce-U18Bcrug.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://clojure.org" rel="noopener ugc nofollow" target="_blank"> Clojure </a></figcaption></figure><h2 id="94b8" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">介绍</h2><p id="8b18" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi mo translated"><span class="l mp mq mr bm ms mt mu mv mw di"> W </span>今天的电子商务服务范围很广，从一个数据库中有几个表的基本API，到支持数亿用户的大规模系统，有大量的代码库和毫秒级的响应时间。根据手头的任务，现代开发人员有各种各样的工具可供选择，有几十种流行的语言和框架可供使用，每种语言和框架都有自己独特的解决特定问题的方式。</p><p id="2475" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li mz mf mg lm na mi mj lq nb ml mm mn im bi translated">在这些语言中，Clojure是一种越来越流行的针对JVM、微软CLR、JavaScript引擎和其他平台的<a class="ae ky" href="https://en.wikipedia.org/wiki/Lisp_(programming_language)" rel="noopener ugc nofollow" target="_blank"> Lisp </a>方言。Lisp已经存在了令人难以置信的60年，是在麻省理工学院开发的，用于实现λ演算。Clojure通过利用预先存在的运行时(如JVM)和添加优秀的特性(如线程安全的并发数据类型和<a class="ae ky" href="https://clojure.org/reference/java_interop" rel="noopener ugc nofollow" target="_blank"> Java VM互操作</a>)来构建Lisp。</p><p id="a130" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li mz mf mg lm na mi mj lq nb ml mm mn im bi translated">在本文中，我们将了解如何使用Clojure和PostgreSQL实现JSON REST API，以存储一组名为<em class="nc">名为</em>、<em class="nc">昵称为</em>和<em class="nc">职业为</em>的<em class="nc">朋友</em>，并从数据库中检索朋友列表。</p><p id="df82" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li mz mf mg lm na mi mj lq nb ml mm mn im bi translated">GitHub 上的<a class="ae ky" href="https://github.com/kenreilly/clojure-example" rel="noopener ugc nofollow" target="_blank">提供了该项目的源代码副本。</a></p></div><div class="ab cl nd ne hx nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="im in io ip iq"><h2 id="f162" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">概观</h2><p id="e271" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">Clojure是一种<a class="ae ky" href="https://en.wikipedia.org/wiki/Functional_programming" rel="noopener ugc nofollow" target="_blank">函数式编程</a> (FP)语言，它有一种有趣而强大的语法，从过程化或面向对象的思维方式来看，这种语法可能看起来很陌生。FP是<a class="ae ky" href="https://en.wikipedia.org/wiki/Declarative_programming" rel="noopener ugc nofollow" target="_blank">声明性的</a>，意味着代码是根据<em class="nc">完成什么</em>而不是<em class="nc">如何完成来定义的。</em></p><p id="672e" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li mz mf mg lm na mi mj lq nb ml mm mn im bi translated">这反映了FP是如何直接从数学领域进化而来的，产生了一种高度纯净和强大的语言，它通过阻止状态的改变(可变性)来减少副作用。</p><p id="d5fa" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li mz mf mg lm na mi mj lq nb ml mm mn im bi translated">本文将关注于启动和运行API的实践方面，因此我们将从设置一个环境和用项目配置变量检查默认的<code class="fe nk nl nm nn b">.env.development</code>文件开始。</p></div><div class="ab cl nd ne hx nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="im in io ip iq"><h2 id="8280" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">配置</h2><p id="576a" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">要运行此项目，需要以下设置:</p><ul class=""><li id="5e8d" class="no np it lx b ly mx mb my li nq lm nr lq ns mn nt nu nv nw bi translated">Clojure(带brew: <code class="fe nk nl nm nn b">brew install clojure</code>)</li><li id="827a" class="no np it lx b ly nx mb ny li nz lm oa lq ob mn nt nu nv nw bi translated"><a class="ae ky" href="https://leiningen.org/#install" rel="noopener ugc nofollow" target="_blank">雷宁根</a>(带酿造:<code class="fe nk nl nm nn b">brew install leinengen</code>)</li><li id="003a" class="no np it lx b ly nx mb ny li nz lm oa lq ob mn nt nu nv nw bi translated"><a class="ae ky" href="https://www.postgresql.org/download/" rel="noopener ugc nofollow" target="_blank"> PostgreSQL </a></li></ul><p id="0dd2" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li mz mf mg lm na mi mj lq nb ml mm mn im bi translated">要初始化数据库，运行命令<code class="fe nk nl nm nn b">$ ./db_create.sh</code>，这将创建数据库<code class="fe nk nl nm nn b">clojure_pg_example</code>和<code class="fe nk nl nm nn b">friends</code>表。数据库连接信息以及API将服务的端口包含在文件<strong class="lx iu"> .env.development </strong>中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="21e9" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li mz mf mg lm na mi mj lq nb ml mm mn im bi translated">该文件将被<a class="ae ky" href="https://github.com/LynxEyes/dotenv.clj" rel="noopener ugc nofollow" target="_blank"> dotenv </a>包用来初始化本地开发的环境变量，允许该项目按照<a class="ae ky" href="https://12factor.net" rel="noopener ugc nofollow" target="_blank"> 12因子app原则</a>的<a class="ae ky" href="https://12factor.net/config" rel="noopener ugc nofollow" target="_blank">因子III(配置)</a>进行部署。</p></div><div class="ab cl nd ne hx nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="im in io ip iq"><h2 id="fb6d" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">项目定义</h2><p id="ae20" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">项目配置包含在<strong class="lx iu"> project.clj </strong>中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="8300" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li mz mf mg lm na mi mj lq nb ml mm mn im bi translated">除了标准项目名称、描述和其他信息之外，该文件中还定义了项目依赖关系。添加了用于设置HTTP服务器、处理JSON、加载环境变量、连接到数据库和其他日常任务的包。</p><p id="8365" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li mz mf mg lm na mi mj lq nb ml mm mn im bi translated">一个额外的概要文件<code class="fe nk nl nm nn b">:dev {:main clojure-example.core/-dev-main}</code>被添加到<code class="fe nk nl nm nn b">:profiles</code>中，这将导致我们的应用程序在开发时运行<code class="fe nk nl nm nn b">-dev-main</code>功能，而不是<code class="fe nk nl nm nn b">-main</code>。这在设置像自动热重装这样的特性时会很有用，我们稍后将对此进行研究。</p></div><div class="ab cl nd ne hx nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="im in io ip iq"><h2 id="9c35" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">应用入口点</h2><p id="d6d5" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">程序执行开始于<strong class="lx iu">src/clo jure _ example/core . clj</strong>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="d4aa" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li mz mf mg lm na mi mj lq nb ml mm mn im bi translated">文件的顶部用<code class="fe nk nl nm nn b">ns</code>定义了名称空间，并通过将库传递给<code class="fe nk nl nm nn b">:require</code>来导入要使用的库，包括为路由端点设置HTTP服务器和处理函数所需的库。</p><p id="afdf" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li mz mf mg lm na mi mj lq nb ml mm mn im bi translated">名副其实的<code class="fe nk nl nm nn b">defroutes</code>宏定义了API路由:</p><ul class=""><li id="446f" class="no np it lx b ly mx mb my li nq lm nr lq ns mn nt nu nv nw bi translated"><code class="fe nk nl nm nn b">GET /</code>(回显请求)</li><li id="c379" class="no np it lx b ly nx mb ny li nz lm oa lq ob mn nt nu nv nw bi translated"><code class="fe nk nl nm nn b">GET /friends</code>(从数据库中检索朋友记录列表)</li><li id="c2a8" class="no np it lx b ly nx mb ny li nz lm oa lq ob mn nt nu nv nw bi translated"><code class="fe nk nl nm nn b">POST /friends</code>(在数据库中存储朋友记录)</li></ul><p id="5d7f" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li mz mf mg lm na mi mj lq nb ml mm mn im bi translated">两个函数<code class="fe nk nl nm nn b">-main</code>和<code class="fe nk nl nm nn b">-dev-main</code>是应用程序可用的入口点函数，具体取决于应用程序是运行在生产模式还是开发模式。在<code class="fe nk nl nm nn b">-dev-main</code>中，函数<code class="fe nk nl nm nn b">wrap-reload</code>用于将API函数包装在一个监视处理程序中，该处理程序将热重装对API使用的磁盘上的源文件所做的任何更改。这非常有用，在构建和测试应用程序时可以节省大量时间。除此之外，入口点函数是相同的，使用默认的中间件<a class="ae ky" href="https://github.com/ring-clojure/ring-defaults" rel="noopener ugc nofollow" target="_blank">包装<code class="fe nk nl nm nn b">app-routes</code>，使用默认的中间件</a>创建API，然后将这些函数包装在JSON包装器中，用于解析请求体和格式化响应输出。接下来，我们将检查路由处理程序。</p></div><div class="ab cl nd ne hx nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="im in io ip iq"><h2 id="9d50" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">路线处理程序</h2><p id="e0d9" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">路由处理函数在<strong class="lx iu">src/clo jure _ example/lib/routes . clj</strong>中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="b337" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li mz mf mg lm na mi mj lq nb ml mm mn im bi translated">在这个文件中，有三个函数对应于前一个文件中定义的三个<code class="fe nk nl nm nn b">app-routes</code>:</p><ul class=""><li id="06e6" class="no np it lx b ly mx mb my li nq lm nr lq ns mn nt nu nv nw bi translated"><code class="fe nk nl nm nn b">echo-route</code>(逐字回显请求对象)</li><li id="4306" class="no np it lx b ly nx mb ny li nz lm oa lq ob mn nt nu nv nw bi translated"><code class="fe nk nl nm nn b">get-friends-route</code>(简称<code class="fe nk nl nm nn b">api/get-friends</code>)</li><li id="62be" class="no np it lx b ly nx mb ny li nz lm oa lq ob mn nt nu nv nw bi translated"><code class="fe nk nl nm nn b">add-friend-route</code>(用JSON请求参数调用<code class="fe nk nl nm nn b">api/add-friend</code></li></ul><p id="221c" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li mz mf mg lm na mi mj lq nb ml mm mn im bi translated">从这里很容易看出Clojure的干净语法是如何让你的代码整洁易读的<em class="nc">(一旦你(弄清楚(所有括号)))</em>。</p></div><div class="ab cl nd ne hx nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="im in io ip iq"><h2 id="ebe2" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">内部API</h2><p id="feae" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">API逻辑本身包含在<strong class="lx iu">src/clo jure _ example/lib/API . clj</strong>中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="0cfe" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li mz mf mg lm na mi mj lq nb ml mm mn im bi translated">第一个函数<code class="fe nk nl nm nn b">get-friends</code>不接受任何参数，只是使用表名<code class="fe nk nl nm nn b">:friends</code>和关键字数组<em class="nc"> id、姓名、昵称和职业</em>调用<code class="fe nk nl nm nn b">db/select</code>作为查询返回的字段。</p><p id="fb28" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li mz mf mg lm na mi mj lq nb ml mm mn im bi translated">第二个函数<code class="fe nk nl nm nn b">add-friend</code>带有朋友<code class="fe nk nl nm nn b">id</code>和其他数据的结果对象被返回，由路由处理器作为响应发送。</p></div><div class="ab cl nd ne hx nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="im in io ip iq"><h2 id="10da" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">数据库层</h2><p id="bf63" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">我们示例项目中的最后一个文件是<strong class="lx iu">src/clo jure _ example/lib/db . clj</strong>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="56e7" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li mz mf mg lm na mi mj lq nb ml mm mn im bi translated">这个文件导入了<em class="nc"> dotenv </em>来访问环境变量以及<em class="nc"> JDBC </em>，我们将使用它们与PostgreSQL实例进行通信。使用<code class="fe nk nl nm nn b">-db</code>定义来定义连接，使用连接信息的环境变量。</p><p id="8077" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li mz mf mg lm na mi mj lq nb ml mm mn im bi translated"><code class="fe nk nl nm nn b">concat-fields</code>实用函数使用<code class="fe nk nl nm nn b">clojure.string/join</code>将数组中的元素与<code class="fe nk nl nm nn b">,</code>分隔符连接在一起，用于将参数打包成逗号分隔的字符串，以便在SQL查询中使用。</p><p id="4ede" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li mz mf mg lm na mi mj lq nb ml mm mn im bi translated"><code class="fe nk nl nm nn b">insert</code>函数调用<code class="fe nk nl nm nn b">jdbc/insert</code>，传入目标<code class="fe nk nl nm nn b">:table</code>和要插入的<code class="fe nk nl nm nn b">record</code>。result对象将被包装在一个数组中，因此使用<code class="fe nk nl nm nn b">first</code>函数从一个项目数组中提取结果，然后将结果返回给路由处理程序，作为JSON响应发送回去。</p><p id="550b" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li mz mf mg lm na mi mj lq nb ml mm mn im bi translated"><code class="fe nk nl nm nn b">select</code>函数调用具有<code class="fe nk nl nm nn b">:table</code>名称的<code class="fe nk nl nm nn b">jdbc/query</code>和由select语句组成的SQL查询，该语句从指定的<code class="fe nk nl nm nn b">:table</code>请求<code class="fe nk nl nm nn b">fields</code>(使用上述<code class="fe nk nl nm nn b">concat-fields</code>函数对其进行SQL格式化)并将结果记录列表返回给路由处理器，以便作为JSON响应发送回客户端。</p></div><div class="ab cl nd ne hx nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="im in io ip iq"><h2 id="f7d5" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">试车</h2><p id="1617" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">为了测试API，使用<code class="fe nk nl nm nn b">lien run server</code>运行服务器，它将检索所需的依赖项并打印一条消息，说明服务器正在环境文件中指定的端口上运行。为了方便起见，实用程序脚本<code class="fe nk nl nm nn b">./post.sh</code>已经作为一个简单的curl包装器提供:</p><pre class="kj kk kl km gt oe nn of og aw oh bi"><span id="894f" class="kz la it nn b gy oi oj l ok ol">$ ./post.sh '{"name":"Sam","nickname":"X","occupation":"ninja"}'</span></pre><p id="7511" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li mz mf mg lm na mi mj lq nb ml mm mn im bi translated">这将返回一个包含所提供数据的结果对象，以及一个<code class="fe nk nl nm nn b">id</code>和一个创建时间戳，验证我们的POST操作成功完成。要检索以前添加的朋友列表:</p><pre class="kj kk kl km gt oe nn of og aw oh bi"><span id="d079" class="kz la it nn b gy oi oj l ok ol">$ curl localhost:3000/friends</span></pre><p id="1900" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li mz mf mg lm na mi mj lq nb ml mm mn im bi translated">这将返回一个JSON格式的对象数组，其中包含前面描述的数据库查询中请求的三个字段<em class="nc"> name、nickname和description，</em>。</p></div><div class="ab cl nd ne hx nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="im in io ip iq"><h2 id="f060" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">结论</h2><p id="e535" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">Clojure有一个有点陡峭的学习曲线，因为它在数学中有着不可饶恕的根基，但是如果使用得当，最终的程序是持久的、易于维护的，并且具有难以置信的速度和响应能力。根据堆栈溢出报告的<a class="ae ky" href="https://insights.stackoverflow.com/survey/2019?utm_source=so-owned&amp;utm_medium=announcement-banner&amp;utm_campaign=dev-survey-2019#top-paying-technologies" rel="noopener ugc nofollow" target="_blank">显示，不重启JVM就能动态加载和运行新代码的能力只是这种语言的一个强大功能，这也恰好要求从2019年起<em class="nc">比任何其他语言</em>更高的工资。</a></p><p id="e211" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li mz mf mg lm na mi mj lq nb ml mm mn im bi translated">本文展示了如何用Clojure快速组装一个简单的云就绪REST API和PostgreSQL数据库，只需几行干净、可靠的代码。</p><p id="a11c" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li mz mf mg lm na mi mj lq nb ml mm mn im bi translated">感谢您的阅读，祝您的下一个项目好运！</p></div><div class="ab cl nd ne hx nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="im in io ip iq"><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/177af51917436dca9914886774e83f54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*amNboRaeHoTZd6mc1bj2Qw.gif"/></div></div></figure></div><div class="ab cl nd ne hx nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="im in io ip iq"><blockquote class="on"><p id="163c" class="oo op it bd oq or os ot ou ov ow mn dk translated">肯尼斯·雷利(<a class="ae ky" href="https://twitter.com/8_bit_hacker" rel="noopener ugc nofollow" target="_blank"> 8_bit_hacker </a>)是<a class="ae ky" href="https://lvl-up.tech/" rel="noopener ugc nofollow" target="_blank"> LevelUP </a>的CTO</p></blockquote></div></div>    
</body>
</html>