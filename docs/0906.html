<html>
<head>
<title>Functional DevOps with Scala and Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Scala和Kubernetes的函数式开发</h1>
<blockquote>原文：<a href="https://itnext.io/functional-devops-with-scala-a-kubernetes-3d7c91bca72f?source=collection_archive---------3-----------------------#2018-06-15">https://itnext.io/functional-devops-with-scala-a-kubernetes-3d7c91bca72f?source=collection_archive---------3-----------------------#2018-06-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><h1 id="7c6b" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">语境</h1><p id="060b" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">作为一名函数式后端开发人员，我总是对<strong class="kn ir"> DevOps </strong>如何远离所有<strong class="kn ir">函数式编程范例</strong>感到惊讶。很明显，后端在这个领域是领先的，我们已经看到了用Scala将它引入前端的成功尝试。JS，那为什么不是DevOps呢？</p><p id="cd1b" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">一般来说，DevOps是关于使用通过声明性配置(YAML、XML……)配置的工具，如果工具中有缺口，我们用一些命令性脚本(Bash、Python……)来弥补。</p><p id="c7db" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">但是如果我们用<strong class="kn ir"> Scala </strong>做所有的事情呢？我们可以使用库来代替工具，以<strong class="kn ir">函数式编程</strong>风格(声明式)配置，库的缺口也可以用<strong class="kn ir"> Scala </strong>编写(如果足够通用，以后可以提取为库)。你听起来很熟悉吗？事实上，这正是我们在开发中一直在做的事情，编写我们的解决方案，并使用库来解决常见的问题，避免一次又一次地重复发明轮子。</p><p id="b53d" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">因此，让我们尝试一些新的东西，用我们在应用程序中使用的相同的函数式编程方法来部署我们的服务。</p><h1 id="cf98" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">用例</h1><p id="b691" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">为了简单起见，在这个故事中，我们将把我们想要部署的系统的架构简化到最小。</p><p id="0e9a" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">因此，我们的系统将简单地由一个<strong class="kn ir">后端API </strong>和一个<strong class="kn ir">数据库</strong>组成:</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi lo"><img src="../Images/a1d8eeb1991dd910544dc0aeae4e97bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v_tGCRgh2sOqLhV8PLIaJg.png"/></div></div></figure><p id="a0fd" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">这里需要注意几点:</p><ul class=""><li id="4fa4" class="ma mb iq kn b ko lj ks lk kw mc la md le me li mf mg mh mi bi translated"><strong class="kn ir">后端API </strong>将是一个可以从web访问的无状态服务。</li><li id="6b2e" class="ma mb iq kn b ko mj ks mk kw ml la mm le mn li mf mg mh mi bi translated"><strong class="kn ir">数据库</strong>将是有状态的，在这个例子中，我们假设它是Elasticsearch。</li></ul><p id="a655" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">了解这里的业务用例并不重要，除了这个系统必须在快速迭代中交付到产品中。</p><p id="431a" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">我想第一个问题是<strong class="kn ir">我们将在哪里运行我们的应用程序？</strong></p><h1 id="9bec" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">库伯内特斯</h1><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/c2b958eee55f6c8471a913fda088e044.png" data-original-src="https://miro.medium.com/v2/resize:fit:472/format:webp/1*mqtqc0H_fSs6kngjUYj4LA.png"/></div></figure><blockquote class="mp mq mr"><p id="72dd" class="kl km ms kn b ko lj kq kr ks lk ku kv mt ll ky kz mu lm lc ld mv ln lg lh li ij bi translated">Kubernetes是一个开源系统，用于跨多个主机管理<a class="ae mw" href="https://kubernetes.io/docs/concepts/overview/what-is-kubernetes/" rel="noopener ugc nofollow" target="_blank">容器化应用</a>；为应用程序的部署、维护和扩展提供基本机制。<br/>来源:<a class="ae mw" href="https://github.com/kubernetes/kubernetes" rel="noopener ugc nofollow" target="_blank">https://github.com/kubernetes/kubernetes</a></p></blockquote><p id="1684" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">这听起来像是一个运行我们的应用程序而不需要关心底层硬件的好解决方案。Kubernetes为我们提供了这种抽象，开发者只需构建他们应用程序的容器，然后将它们交给Kubernetes集群，该集群将负责在任何有计算能力的地方运行它们。</p><p id="5e57" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">我们不打算在这里深入探究Kubernetes是如何工作的，但是作为一名开发人员，理解一些高级概念是很重要的，这些概念在<a class="ae mw" href="https://kubernetes.io/docs/concepts/" rel="noopener ugc nofollow" target="_blank">https://kubernetes.io/docs/concepts/</a>上有很好的记录。</p><p id="c93d" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">好了，现在你可能想知道<strong class="kn ir">我们将如何在Kubernetes上部署</strong>？</p><h1 id="ca6a" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">奥克斯特拉</h1><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/22e6fe52a1797ff7a49e56710d2d23d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:500/format:webp/1*5NCoWe6eF5bKGmBuQ62SGQ.png"/></div></figure><blockquote class="mp mq mr"><p id="365f" class="kl km ms kn b ko lj kq kr ks lk ku kv mt ll ky kz mu lm lc ld mv ln lg lh li ij bi translated">Orkestra是一个开源的持续集成/持续部署服务器，作为一个库运行在<a class="ae mw" href="https://kubernetes.io/" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>上。<br/>它利用Kubernetes的概念，如作业或秘密，以及配置为<a class="ae mw" href="https://scala-lang.org/" rel="noopener ugc nofollow" target="_blank"> Scala </a>中的代码，以充分利用编译时类型安全性以及与Scala或Java库的兼容性。<br/>来源:<a class="ae mw" href="https://orkestra.tech" rel="noopener ugc nofollow" target="_blank">https://orestra . tech</a></p></blockquote><p id="c6ca" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">这听起来像是我们想要的用例。我们感兴趣的关键特性是:</p><ul class=""><li id="d2e3" class="ma mb iq kn b ko lj ks lk kw mc la md le me li mf mg mh mi bi translated">我们是<strong class="kn ir">功能性</strong>开发者，被它相对于不安全的Yaml、Python或Groovy代码的优势所折服。所以这里很完美，因为配置是在<strong class="kn ir"> Scala </strong>中。</li><li id="f1cc" class="ma mb iq kn b ko mj ks mk kw ml la mm le mn li mf mg mh mi bi translated">使用Scala/Java库是可扩展的。</li><li id="7fc8" class="ma mb iq kn b ko mj ks mk kw ml la mm le mn li mf mg mh mi bi translated">它运行在Kubernetes上，因此我们可以通过使用托管的Kubernetes集群(如GKE或EKS)来减少运营管理。此外，我们可以将集群上剩余的计算能力重新用于开发运维任务。</li><li id="3830" class="ma mb iq kn b ko mj ks mk kw ml la mm le mn li mf mg mh mi bi translated">这是<strong class="kn ir">高度可用的</strong>，并不是说我们期待一个内部工具100%的正常运行时间，但它使操作维护成为可能，而不影响工具在工作时间的使用。</li><li id="bb8f" class="ma mb iq kn b ko mj ks mk kw ml la mm le mn li mf mg mh mi bi translated">它是完全可伸缩的，所以如果底层的Kubernetes集群足够大，我们可以并行运行许多作业。</li></ul><h1 id="38aa" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">连续累计</h1><p id="1f04" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">持续集成相当容易，有很多工具可以做到这一点，比如Travis、CircleCI、GitLabCI、Jenkins等等。</p><p id="f31f" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">我们想要的可能是对每一个<strong class="kn ir">拉请求</strong>执行一次完整的编译、测试、一些linter(比如Scalafix、Scalafmt ),并且可能检查贡献者许可协议是否已经签署。在任何情况下，这应该是几个命令的问题。</p><p id="529d" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">当然，Orkestra可以对pull请求运行这些检查。让我们看一下代码。请记住，您可以随时在https://orkestra.tech 上获得更多关于Orkestra的文档。</p><p id="ac18" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">我们首先需要定义一个执行检查的作业:</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="b200" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">这是我们第一次定义工作，所以让我们花点时间来一步一步地了解这里发生了什么:</p><ul class=""><li id="dfbe" class="ma mb iq kn b ko lj ks lk kw mc la md le me li mf mg mh mi bi translated">我们定义了一个代表UI的<code class="fe na nb nc nd b"><strong class="kn ir">board</strong></code>。有不同类型的板，但我们在这里将使用<code class="fe na nb nc nd b"><strong class="kn ir">JoabBoard</strong></code> <em class="ms"> </em>。<br/>在<code class="fe na nb nc nd b">JoabBoard</code>中，我们定义了这个任务将要执行的函数的签名，这里是<code class="fe na nb nc nd b">GitRef =&gt; Unit</code>。<br/>我们需要给显示器一个唯一的ID和一个好听的名字。<br/>最后，我们给出了参数表单的UI元素。这里只有一个名字好听的<code class="fe na nb nc nd b">Input[GitRef]</code>供展示。</li><li id="faac" class="ma mb iq kn b ko mj ks mk kw ml la mm le mn li mf mg mh mi bi translated">然后，我们定义一个负责执行工作负载的<code class="fe na nb nc nd b"><strong class="kn ir">job</strong></code>。<br/>A<code class="fe na nb nc nd b">Job</code>需要引用<code class="fe na nb nc nd b">JobBoard</code>所以我们传递它。有趣的事情开始了！我们传递当PR被更新时将被执行的函数。因为这是DevOps，我们将经常处理文件和目录。为了以引用透明的方式做到这一点，我们有一个类型为<code class="fe na nb nc nd b">Directory</code>的上下文对象，它知道我们在哪个目录中，这就是<code class="fe na nb nc nd b">workDir</code>所要做的。当然我们不想到处传递这个参数，所以我们把它隐式化。<br/><code class="fe na nb nc nd b">gitRef</code>是用户通过板卡中的参数表单给出的参数值。<br/><code class="fe na nb nc nd b">Github.statusUpdated</code>是一个帮助函数，它将让Github知道测试何时开始以及测试是否失败。它还负责为您检查git ref并移入git目录。最后，我们执行一个shell命令来运行测试。</li></ul><p id="19ad" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">现在我们已经定义了作业，我们需要创建Orkestra服务器，向它注册作业并配置GitHub Pull请求挂钩:</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="my mz l"/></div></figure><ul class=""><li id="4cac" class="ma mb iq kn b ko lj ks lk kw mc la md le me li mf mg mh mi bi translated">我们通过扩展<code class="fe na nb nc nd b">OrkestraServer</code>来创建Orkestra服务器，这迫使我们实现<code class="fe na nb nc nd b">board</code>(UI)和<em class="ms">作业</em>(可触发的作业)。</li><li id="4676" class="ma mb iq kn b ko mj ks mk kw ml la mm le mn li mf mg mh mi bi translated"><code class="fe na nb nc nd b">board</code>现在只是PullRequestChecks板的文件夹。</li><li id="c6b5" class="ma mb iq kn b ko mj ks mk kw ml la mm le mn li mf mg mh mi bi translated"><code class="fe na nb nc nd b">jobs</code>将只包含<code class="fe na nb nc nd b">PullRequestChecks</code>任务。</li><li id="9948" class="ma mb iq kn b ko mj ks mk kw ml la mm le mn li mf mg mh mi bi translated">然后我们需要配置Pull请求Github挂钩。</li></ul><p id="fa13" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">好了，让我们看看用户界面，看看它有多漂亮:</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi ne"><img src="../Images/01295fed3c28166a7fb2d8c43b80d40d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*H_Rbk-c4AlGzaQV4GTyOZw.gif"/></div></div></figure><p id="9b84" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">持续集成非常简单，但是现在我们有了这么好的代码，我们必须在某个地方运行它！</p><p id="37e7" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">这就产生了一些问题，如:</p><ul class=""><li id="f2ed" class="ma mb iq kn b ko lj ks lk kw mc la md le me li mf mg mh mi bi translated"><strong class="kn ir">我们将部署什么</strong>？(我们的应用程序、数据库？…)</li><li id="b617" class="ma mb iq kn b ko mj ks mk kw ml la mm le mn li mf mg mh mi bi translated"><strong class="kn ir">哪里有</strong>？(Kubernetes？AWS托管服务？GCP管理服务？…)</li><li id="ba12" class="ma mb iq kn b ko mj ks mk kw ml la mm le mn li mf mg mh mi bi translated"><strong class="kn ir">如何</strong>？(Docker？好吃吗？…)</li><li id="74f3" class="ma mb iq kn b ko mj ks mk kw ml la mm le mn li mf mg mh mi bi translated"><strong class="kn ir">配置</strong>？(自动缩放？，秘密？环境？…)</li><li id="93c9" class="ma mb iq kn b ko mj ks mk kw ml la mm le mn li mf mg mh mi bi translated"><strong class="kn ir">额外任务</strong>？(运行迁移、在环境之间复制数据、切换负载平衡器……)</li></ul><p id="49be" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">在这里，我不认为Travis、CircleCI、GitLabCI、Jenkins…对CI之外的任何东西都很好，因为它只在Git pushes上运行一堆迭代命令，这对于简单的任务来说是可以的，但一旦你不得不做更多的事情，就非常困难了。</p><p id="b5a8" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">对此问题的通常解决方案是结合其他技术，如Ansible、Chef、Terraform…来处理硬件/软件供应和部署逻辑，我们将从上述CI之一运行这些逻辑。</p><p id="fa17" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">我不太喜欢这个解决方案，因为它引入了许多技术，因此增加了复杂性。另外，这些技术与我们这些函数式开发人员所习惯的函数式编程相去甚远。</p><p id="69a9" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">对于我们的示例，让我们回答上面的一些问题:</p><ul class=""><li id="8501" class="ma mb iq kn b ko lj ks lk kw mc la md le me li mf mg mh mi bi translated"><strong class="kn ir">什么？</strong>我们知道我们将不得不部署我们的后端和一个弹性搜索数据库。</li><li id="24e6" class="ma mb iq kn b ko mj ks mk kw ml la mm le mn li mf mg mh mi bi translated"><strong class="kn ir">哪里？</strong>我们说过我们将使用Kubernetes来运行我们所有的服务。</li><li id="7ddc" class="ma mb iq kn b ko mj ks mk kw ml la mm le mn li mf mg mh mi bi translated"><strong class="kn ir">如何？</strong>由于我们将使用Kubernetes，因此将使用Docker图像。</li><li id="829e" class="ma mb iq kn b ko mj ks mk kw ml la mm le mn li mf mg mh mi bi translated"><strong class="kn ir">配置？</strong>我们可能想要多个环境，例如能够测试新版本而不影响生产用户。</li></ul><h1 id="4e4c" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">环境</h1><p id="94a9" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在进行任何部署之前，我们可能需要一个部署服务的环境，正如我们刚刚看到的，实际上有多个环境:</p><ul class=""><li id="2666" class="ma mb iq kn b ko lj ks lk kw mc la md le me li mf mg mh mi bi translated"><strong class="kn ir"> Staging </strong>:我们将持续部署主分支机构。</li><li id="6965" class="ma mb iq kn b ko mj ks mk kw ml la mm le mn li mf mg mh mi bi translated">生产:我们将在哪里部署版本，我们确信他们正在进行测试。我们的最终用户将使用这一环境，因此它需要一直保持运行！</li></ul><p id="361f" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">在这些环境中，部署的最低要求是:</p><ul class=""><li id="0e40" class="ma mb iq kn b ko lj ks lk kw mc la md le me li mf mg mh mi bi translated">一个Kubernetes <strong class="kn ir">名称空间</strong></li><li id="4173" class="ma mb iq kn b ko mj ks mk kw ml la mm le mn li mf mg mh mi bi translated">一个<strong class="kn ir">数据库</strong></li></ul><p id="8ed6" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">所以让我们写一个创造环境的作业:</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="my mz l"/></div></figure><ul class=""><li id="deb4" class="ma mb iq kn b ko lj ks lk kw mc la md le me li mf mg mh mi bi translated">注意，现在我们运行的函数是<code class="fe na nb nc nd b"><strong class="kn ir">String =&gt; Unit</strong></code>，因此我们使用一个<code class="fe na nb nc nd b">Input[String]</code>。</li><li id="013d" class="ma mb iq kn b ko mj ks mk kw ml la mm le mn li mf mg mh mi bi translated">作业的核心现在运行2个<code class="fe na nb nc nd b">Futures</code>，一个创建<strong class="kn ir">名称空间，</strong>另一个用于<strong class="kn ir">部署我们的数据库</strong> Elasticsearch，它等待结果。</li></ul><p id="7603" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">我们需要登记这份新工作。这是我们之前创建的<code class="fe na nb nc nd b">Orkestra</code>的新版本:</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="my mz l"/></div></figure><h1 id="3273" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">持续部署</h1><p id="9d2c" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我们创建了我们的环境，现在我们需要<strong class="kn ir">在这些环境上部署</strong>我们的后端工件。让我们写这个作业:</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="3bf3" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">我们可能还需要一个任务，让<strong class="kn ir">发布</strong>工件:</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="122f" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">让我们也创建一个由<strong class="kn ir">直接发布和部署</strong>的任务，这样如果我们想从源代码部署，我们只需要做一个动作:</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="f558" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">同样，我们需要更新<code class="fe na nb nc nd b">Orkestra</code>对象来注册我们的新任务。同时，我们可以添加一个GitHub挂钩，用于将主分支自动部署到staging:</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="my mz l"/></div></figure><ul class=""><li id="8732" class="ma mb iq kn b ko lj ks lk kw mc la md le me li mf mg mh mi bi translated">请注意，只要主分支被更新，我们就使用一个<code class="fe na nb nc nd b">BranchTrigger</code>来触发<code class="fe na nb nc nd b">PublishAndDeploy</code>作业。</li></ul><p id="5f1e" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">太好了，我们现在有了一个最小可行CI/CD！</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi ne"><img src="../Images/fcd99d15f7fe1452ae39ab96603be071.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*t21QWQqHNmEJYAqBYxFNjg.gif"/></div></div></figure><h1 id="a84a" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">额外工作</h1><p id="2aaf" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">这种架构已经给我们带来了一些重复性的任务，我们必须不时地去做。</p><p id="7f36" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">其中之一是将数据子集从生产环境复制到登台环境。我们可能希望用来自生产的新的真实世界的数据来覆盖所有的暂存数据，比如每周。</p><p id="b2f3" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">让我们编写这个复制数据作业:</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="7179" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">用Scala编写这项工作的好处是，如果你的后端是用JVM语言(Java、Scala、Groovy……)编写的，你可以发布它的一个jar，使Orkestra项目依赖于它并直接调用函数。在这个例子中，我们假设<code class="fe na nb nc nd b">copyData()</code>是后端代码中定义的一个函数。</p><p id="4268" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">同样，不要忘记登记工作和董事会。我们将添加一个Cron触发器，以便该作业在每周一上午5点(开发人员工作时间之外)运行，这样我们就可以用新数据开始一周的工作:</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="my mz l"/></div></figure><h1 id="ec82" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">松散集成</h1><p id="a6bc" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">你现在可能会想，这东西很酷(或者不酷？)但是我习惯于在其他配置项上有大量的插件，这里仅举一个例子:一个Slack integration，它在staging或prod上完成部署时发送消息，以便团队中的每个人都知道。</p><p id="1841" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">记住我们在这里写的是普通的Scala，因此我们可以依赖任何库。更确切地说，我们可以访问所有Maven central。你知道Maven central有多少图书馆吗？肯定有人用Scala写了Slack客户端！</p><p id="5584" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">宾果:<a class="ae mw" href="https://github.com/gilbertw1/slack-scala-client" rel="noopener ugc nofollow" target="_blank">https://github.com/gilbertw1/slack-scala-client</a><br/>我不会在这里介绍这个库的用法，但我认为它在回购协议中有很好的记录。</p><h1 id="297e" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">结论</h1><p id="ffd9" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">这个故事通过一个简化的例子展示了我们如何将函数式编程用于DevOps目的，以及它带来的所有好处。</p><p id="bf9a" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">我们设置了一个CI来检查我们的拉取请求，创建了一些作业来创建和部署我们的架构，甚至还为其他任务创建了一些作业。所有这些都是用一种技术完成的:Scala/Orkestra，然而可能性是无穷的，因为我们可以使用Scala和Java生态系统中的库。</p><p id="c32c" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">别忘了在Github上查看完整代码，评论，分叉和改进:</p><div class="nf ng gp gr nh ni"><a href="https://github.com/OrkestraCD/demo" rel="noopener  ugc nofollow" target="_blank"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd ir gy z fp nn fr fs no fu fw ip bi translated">orkstracd/演示</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">完成配置项和CD的Orkestra设置。</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">github.com</p></div></div><div class="nr l"><div class="ns l nt nu nv nr nw ly ni"/></div></div></a></div><p id="9dbb" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">Orkestra的文件:</p><div class="nf ng gp gr nh ni"><a href="https://orkestra.tech" rel="noopener  ugc nofollow" target="_blank"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd ir gy z fp nn fr fs no fu fw ip bi translated">奥克斯特拉</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">使用Scala和Kubernetes的函数式开发</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">orkestra.tech</p></div></div><div class="nr l"><div class="nx l nt nu nv nr nw ly ni"/></div></div></a></div><p id="4b2c" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">欢迎在Twitter上关注我:</p><div class="nf ng gp gr nh ni"><a href="https://twitter.com/JoanG38" rel="noopener  ugc nofollow" target="_blank"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd ir gy z fp nn fr fs no fu fw ip bi translated">琼·戈雅(@JoanG38) |推特</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">Joan Goyeau的最新推文(@JoanG38)。与斯卡拉、卡夫卡和库伯内特一起创作。英国伦敦</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">twitter.com</p></div></div><div class="nr l"><div class="ny l nt nu nv nr nw ly ni"/></div></div></a></div><p id="e2bd" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">我还想特别感谢<a class="ae mw" href="https://drivetribe.com" rel="noopener ugc nofollow" target="_blank"> DriveTribe </a>，他们启动了整个项目，现在正在全面使用Orkestra。</p></div></div>    
</body>
</html>