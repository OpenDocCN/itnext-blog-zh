<html>
<head>
<title>Signing Software The Easy Way with Sigstore and Cosign</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Sigstore和Cosign轻松签署软件</h1>
<blockquote>原文：<a href="https://itnext.io/signing-software-the-easy-way-with-sigstore-and-cosign-cccc51bd65f1?source=collection_archive---------3-----------------------#2021-09-01">https://itnext.io/signing-software-the-easy-way-with-sigstore-and-cosign-cccc51bd65f1?source=collection_archive---------3-----------------------#2021-09-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a35e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">sigstore项目和cosign CLI签名软件工件的实用指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/03b87c869c5609e3bbc197bc98962dc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p23OawDcvNRueAw-Mgpg4w.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@_miltiadis_?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Miltiadis frakkidis</a>在<a class="ae ky" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="25ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对软件工件进行签名有许多明显的好处，比如代码完整性或开发人员(作者)身份验证。然而，它经常被忽视，创造了一个适合供应链攻击的软件。人们不愿意签署他们的代码的原因之一是现有的工具——如PGP——对用户不太友好，并且需要广泛的安全和/或密码学知识。</p><p id="660c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于有了<em class="lv"> sigstore </em>和它的<code class="fe lw lx ly lz b">cosign</code> CLI，签署软件变得很容易！在本文中，我们将了解<code class="fe lw lx ly lz b">cosign</code>如何工作以及如何与其他sigstore组件(<code class="fe lw lx ly lz b">fulcio</code>和<code class="fe lw lx ly lz b">rekor</code>)集成。更重要的是，我们将学习如何使用它以简单的方式对容器映像进行签名，无论有没有密钥，以及我们如何使用它来验证生成的签名和签名软件的完整性。</p><p id="c2de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">注意:这是我上一篇文章</em> <a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/sigstore-a-solution-to-software-supply-chain-security-35bc96bddad5"> <em class="lv"> Sigstore:软件供应链安全解决方案</em> </a> <em class="lv">的后续文章，解释了什么是Sigstore及其组件如何工作。</em></p><h1 id="5b5d" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">安装</h1><p id="ea0d" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">在我们签署任何东西之前，我们首先需要sigstore的每个组件的所有CLI工具，即<code class="fe lw lx ly lz b">cosign</code>、<code class="fe lw lx ly lz b">fulcio</code>和<code class="fe lw lx ly lz b">rekor</code>。第一个是<code class="fe lw lx ly lz b">cosign</code>，我们实际上需要它来签署任何东西，它可以作为二进制文件或Docker镜像安装。对于第一个选项，从<a class="ae ky" href="https://github.com/sigstore/cosign/releases/tag/v1.0.0" rel="noopener ugc nofollow" target="_blank">发布页面</a>下载适当的二进制文件，并将其放在您的<code class="fe lw lx ly lz b">$PATH</code>中。此外，考虑到我们正在处理安全工具，建议验证二进制文件的真实性和完整性。您可以使用发布页面上显示的命令来完成此操作。</p><p id="7386" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你更喜欢使用Docker图像，那么你可以使用如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="0ad1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于第二个组件——<code class="fe lw lx ly lz b">fulcio</code>——我们不需要安装任何东西，因为我们将使用<code class="fe lw lx ly lz b">fulcio</code>的公共实例。公益服务在<a class="ae ky" href="https://fulcio.sigstore.dev/api/v1" rel="noopener ugc nofollow" target="_blank">https://fulcio.sigstore.dev/api/v1</a>有，API文档可以在<a class="ae ky" href="https://sigstore.dev/swagger/?urls.primaryName=Fulcio" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="9b8b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，还有<code class="fe lw lx ly lz b">rekor</code>及其名为<code class="fe lw lx ly lz b">rekor-cli</code>的命令行界面。与<code class="fe lw lx ly lz b">fulcio</code>一样，我们不需要安装<code class="fe lw lx ly lz b">rekor</code>，因为它可以在<a class="ae ky" href="https://rekor.sigstore.dev" rel="noopener ugc nofollow" target="_blank">https://rekor . sigstore . dev</a>以及这里的<a class="ae ky" href="https://sigstore.dev/swagger/?urls.primaryName=Rekor" rel="noopener ugc nofollow" target="_blank">Swagger定义</a>中找到。</p><p id="7f2a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，我们希望安装CLI，以便与<code class="fe lw lx ly lz b">rekor</code>服务器进行交互。二进制文件可以在GitHub <a class="ae ky" href="https://github.com/sigstore/rekor/releases" rel="noopener ugc nofollow" target="_blank">发布页面</a>中找到。如果您在linux上，您可以使用以下内容:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="cf5b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，正如在<code class="fe lw lx ly lz b">cosign</code>中提到的，你应该小心使用什么样的二进制文件。因此，您可能希望使用这里概述的过程<a class="ae ky" href="https://github.com/sigstore/rekor/blob/main/release-verify.md" rel="noopener ugc nofollow" target="_blank">来验证<code class="fe lw lx ly lz b">rekor-cli</code>二进制。</a></p><h1 id="95e6" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">艰难的道路</h1><p id="6a48" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">所有的工具都准备好了，我们可以开始签署工件了。为了更好地理解隐藏的东西，我们将首先尝试用<em class="lv">【艰难的方式】</em>——也就是说，不用所有花哨的工具。</p><p id="7d36" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先我们需要一件艺术品。在本演示中，我们将使用通过以下<code class="fe lw lx ly lz b">Dockerfile</code>创建的<em class="lv">“hello world”</em>Docker图像:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="37fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，我们不能签署图像本身，而是签署其摘要:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="234d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们需要一个短暂的密钥对来签署摘要。为此我们可以使用<code class="fe lw lx ly lz b">cosign</code>命令，但考虑到这是<em class="lv"/>“硬路”，我们直接使用<code class="fe lw lx ly lz b">openssl</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="3477" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们已经准备好签名，同时我们还可以验证签名:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="4aca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们用我们的私钥签署了工件，我们想要有一个证据证明我们是真正做这件事的人。为此，我们需要来自<code class="fe lw lx ly lz b">fulcio</code>的代码签名证书。要获得它，我们必须向OIDC提供商认证以获得一个ID令牌，作为我们对<code class="fe lw lx ly lz b">fulcio</code>的身份证明。</p><p id="5102" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">之后，我们签署我们的电子邮件地址，我们用来认证使用以前使用的私钥。我们这样做是为了证明我们在签名时拥有私钥。</p><p id="e17b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们向<code class="fe lw lx ly lz b">fulcio</code>请求代码签名证书，给它ID令牌作为授权形式，签名的电子邮件地址和我们的公钥:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="1ab0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种<em class="lv">“硬方式”</em>方法的一个问题是，模拟ID令牌的认证和检索实际上并不可行。因此，在上面的代码片段中，这一步被省略了，我们直接跳到向<code class="fe lw lx ly lz b">fulcio</code>提交所有内容。</p><p id="30a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者，您也可以完全跳过与<code class="fe lw lx ly lz b">fulcio</code>的交互，而使用您的公钥。这种方法显示在<a class="ae ky" href="https://github.com/sigstore/rekor/blob/main/types.md#pkixx509" rel="noopener ugc nofollow" target="_blank">https://github . com/sigstore/rekor/blob/main/types . MD # PK ix509</a>中。</p><p id="514c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们可以继续将记录上传到透明度日志(<code class="fe lw lx ly lz b">rekor</code>)。这里我们展示了带有公钥的选项和来自<code class="fe lw lx ly lz b">fulcio</code>的签名证书。当使用来自<code class="fe lw lx ly lz b">fulcio</code>的证书时，我们也可以删除密钥对，因为我们不再需要它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="8cd0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了上传之外，我们还可以检查透明日志中的记录。上面的代码片段同时使用了<code class="fe lw lx ly lz b">rekor-cli</code>和<code class="fe lw lx ly lz b">curl</code>来直接访问公共API。</p><p id="edcf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">剩下要做的就是将签名上传到注册表，与容器图像一起存储:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="233c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就是这样。我们已经签署了我们的图像，并将其记录添加到透明日志中。这种方法是可行的，但是可能没有人愿意每天都这样做，所以让我们看看合适的工具如何使这变得简单。</p><h1 id="da66" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">简单的方法</h1><p id="832f" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated"><em class="lv">“艰难之路”</em>其实并不难，但是如果我们使用提供的工具，就会变得容易得多:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="445a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要做的就是生成一个密钥对，然后对工件进行签名。签名后，<code class="fe lw lx ly lz b">cosign</code>自动将签名上传到图像所在的注册中心。在上面的例子中，我们选择不上传签名，只将它保存到一个文件中，因为我们在前面的部分已经签名了。如果我们后来决定上传它，那么我们可以用如上所示的<code class="fe lw lx ly lz b">cosign attach</code>来做。</p><p id="38d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样值得指出的是，到目前为止(<code class="fe lw lx ly lz b">cosign</code>版本<code class="fe lw lx ly lz b">1.0</code>)，上面的代码片段不会将数据上传到<code class="fe lw lx ly lz b">rekor</code>透明日志，为了使其工作，我们需要设置<code class="fe lw lx ly lz b">COSIGN_EXPERIMENTAL=1</code>，例如<code class="fe lw lx ly lz b">COSIGN_EXPERIMENTAL=1 cosign sign -key cosign.key ...</code>。</p><p id="4cf3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据您的用例和工作流，也有其他方法使用<code class="fe lw lx ly lz b">cosign</code>来签署工件。这些在GitHub的<a class="ae ky" href="https://github.com/sigstore/cosign/blob/main/USAGE.md" rel="noopener ugc nofollow" target="_blank">使用页面</a>中有详细描述。</p><h1 id="1713" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">“无钥匙”</h1><p id="a9b3" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">比简单方法更简单的是使用<em class="lv">“keyless”</em>方法，其中只使用临时密钥，这意味着您不需要生成和维护自己的密钥:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="c558" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们所需要做的就是在<code class="fe lw lx ly lz b">COSIGN_EXPERIMENTAL</code>设置为<code class="fe lw lx ly lz b">1</code>的情况下运行<code class="fe lw lx ly lz b">cosign sign</code>，同时省略<code class="fe lw lx ly lz b">-key</code>参数。在上面的例子中，我们还指定了OIDC提供者的端点，<code class="fe lw lx ly lz b">fulcio</code>服务器和<code class="fe lw lx ly lz b">rekor</code>服务器——这些是sigstore提供的公益服务的默认值，因此可以省略它们，但是为了清楚起见，在这里显示它们是为了突出显示哪些服务正在被访问/使用。您也可以用自己的实例来替换它们——如果您想在防火墙后运行所有的东西，这是有意义的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mz"><img src="../Images/c48b0485379c61fb327053ae288e88e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qurm4tyBRYXKK3kGWgT1rQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">Docker Hub图像和签名</figcaption></figure><h1 id="a4bb" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">核实一切</h1><p id="29d5" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">既然我们以所有可能的方式签署了工件，我们也应该尝试验证它，否则签署它还有什么意义，对吗？</p><p id="6352" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先让我们来看看签约图像摘要的输出结果<em class="lv">【辛苦】</em>。为此，我们可以使用<code class="fe lw lx ly lz b">rekor-cli</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="6de1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们有两种情况——如果我们用我们的公钥对工件签名，那么我们在验证时使用它。另一方面，如果我们使用由<code class="fe lw lx ly lz b">fulcio</code>提供的签名证书，我们将使用它来代替公钥。</p><p id="ce3d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来是使用<code class="fe lw lx ly lz b">cosign</code>的验证，它适用于使用密钥的基本签名。我们需要做的就是运行<code class="fe lw lx ly lz b">cosign verify</code>，提供密钥和图像URL:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="f90d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，对于无键方法——我们可以做本质上与上面相同的事情，但是我们需要添加实验标记，并且我们可以跳过关键参数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><h1 id="5c9d" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">结束语</h1><p id="7b37" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">在本文中，我试图概述和解释使用sigstore，更具体地说是<code class="fe lw lx ly lz b">cosign</code>来签署容器图像的基本用例和方法。然而，<code class="fe lw lx ly lz b">cosign</code>有更多的选项和特性可能对你有用，比如使用其他类型的工件，使用硬件令牌或者签署<code class="fe lw lx ly lz b">git</code>提交，所以我鼓励你尝试一下这个工具，看看你还能把它用在什么地方。这些选项中有很多都在精心编写的使用文档<a class="ae ky" href="https://github.com/sigstore/cosign/blob/main/USAGE.md" rel="noopener ugc nofollow" target="_blank">中有所描述，所以请务必也查看一下。</a></p><p id="9c71" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，如果你想更深入地挖掘，你可以查看<a class="ae ky" href="https://github.com/lukehinds/sigstore-the-hard-way" rel="noopener ugc nofollow" target="_blank">“sigstore the hard way”</a>，这是一个从头开始设置一切的指南——包括<code class="fe lw lx ly lz b">fulcio</code> CA和<code class="fe lw lx ly lz b">rekor</code>透明日志服务器。</p></div><div class="ab cl na nb hx nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="im in io ip iq"><p id="cde9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">本文最初发布于</em><a class="ae ky" href="https://martinheinz.dev/blog/56?utm_source=medium&amp;utm_medium=referral&amp;utm_campaign=blog_post_56" rel="noopener ugc nofollow" target="_blank"><em class="lv">martinheinz . dev</em></a></p><div class="nh ni gp gr nj nk"><a rel="noopener  ugc nofollow" target="_blank" href="/building-docker-images-the-proper-way-3c9807524582"><div class="nl ab fo"><div class="nm ab nn cl cj no"><h2 class="bd iu gy z fp np fr fs nq fu fw is bi translated">以正确的方式构建Docker图像</h2><div class="nr l"><h3 class="bd b gy z fp np fr fs nq fu fw dk translated">让我们优化Docker构建，以创建更小、更安全的Docker映像，只需普通构建的一小部分…</h3></div><div class="ns l"><p class="bd b dl z fp np fr fs nq fu fw dk translated">itnext.io</p></div></div><div class="nt l"><div class="nu l nv nw nx nt ny ks nk"/></div></div></a></div><div class="nh ni gp gr nj nk"><a rel="noopener  ugc nofollow" target="_blank" href="/hardening-docker-and-kubernetes-with-seccomp-a88b1b4e2111"><div class="nl ab fo"><div class="nm ab nn cl cj no"><h2 class="bd iu gy z fp np fr fs nq fu fw is bi translated">用seccomp强化Docker和Kubernetes</h2><div class="nr l"><h3 class="bd b gy z fp np fr fs nq fu fw dk translated">您的容器可能不像您想象的那样安全，但是seccomp配置文件可以帮助您解决这个问题…</h3></div><div class="ns l"><p class="bd b dl z fp np fr fs nq fu fw dk translated">itnext.io</p></div></div><div class="nt l"><div class="nz l nv nw nx nt ny ks nk"/></div></div></a></div><div class="nh ni gp gr nj nk"><a href="https://towardsdatascience.com/analyzing-docker-image-security-ed5cf7e93751" rel="noopener follow" target="_blank"><div class="nl ab fo"><div class="nm ab nn cl cj no"><h2 class="bd iu gy z fp np fr fs nq fu fw is bi translated">分析Docker图像安全性</h2><div class="nr l"><h3 class="bd b gy z fp np fr fs nq fu fw dk translated">码头集装箱远没有你想象的那么安全…</h3></div><div class="ns l"><p class="bd b dl z fp np fr fs nq fu fw dk translated">towardsdatascience.com</p></div></div><div class="nt l"><div class="oa l nv nw nx nt ny ks nk"/></div></div></a></div></div></div>    
</body>
</html>