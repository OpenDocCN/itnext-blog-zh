<html>
<head>
<title>7 Recommended ESLint Rules for React TypeScript Project</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React TypeScript项目的推荐ESLint规则</h1>
<blockquote>原文：<a href="https://itnext.io/7-recommended-eslint-rules-for-react-typescript-project-1a22b011b4b5?source=collection_archive---------1-----------------------#2022-09-18">https://itnext.io/7-recommended-eslint-rules-for-react-typescript-project-1a22b011b4b5?source=collection_archive---------1-----------------------#2022-09-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/653069a400390397e64dec66202d8f04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*wPkJWpI-_ccTEvhiB1zIOQ.gif"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">gif:仅用于类型导入的自动格式</figcaption></figure><p id="1323" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">ESLint和beauty的组合太惊艳了。它不仅大大减少了格式化时间，还节省了你的大脑CPU。此外，如果你们是团队合作，会减少复习压力。</p><p id="a857" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">通常情况下，你可以根据预设设置ESLint和pretty，比如<a class="ae ld" href="https://github.com/airbnb/javascript" rel="noopener ugc nofollow" target="_blank"> Airbnb </a>、<a class="ae ld" href="https://github.com/google/eslint-config-google" rel="noopener ugc nofollow" target="_blank">谷歌</a>和<a class="ae ld" href="https://github.com/standard/standard" rel="noopener ugc nofollow" target="_blank">标准</a>。但是因为他们的预置不是为你自己的项目定制的，所以还有改进的空间。</p><p id="1395" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">因此，本文介绍了7个推荐的ESLint配置，它们对您的React TypeScript项目有很大的影响！</p><p id="ee7b" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如果你没有设置ESLint和更漂亮，请随意参考我以前的文章。</p><div class="le lf gp gr lg lh"><a rel="noopener  ugc nofollow" target="_blank" href="/auto-format-with-eslint-and-prettier-for-react-typescript-project-6526a9d44f81"><div class="li ab fo"><div class="lj ab lk cl cj ll"><h2 class="bd iu gy z fp lm fr fs ln fu fw is bi translated">React TypeScript项目的ESLint和更漂亮的自动格式</h2><div class="lo l"><h3 class="bd b gy z fp lm fr fs ln fu fw dk translated">自动格式化是DX的一大改进。它节省了您的开发时间，并大大提高了您的生产力…</h3></div><div class="lp l"><p class="bd b dl z fp lm fr fs ln fu fw dk translated">itnext.io</p></div></div><div class="lq l"><div class="lr l ls lt lu lq lv jz lh"/></div></div></a></div><h1 id="e783" class="lw lx it bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">1.箭体样式</h1><p id="a2b7" class="pw-post-body-paragraph kf kg it kh b ki mu kk kl km mv ko kp kq mw ks kt ku mx kw kx ky my la lb lc im bi translated">虽然<a class="ae ld" href="https://eslint.org/docs/latest/rules/arrow-body-style" rel="noopener ugc nofollow" target="_blank">箭体样式</a>是一个非常简单的规则，但是当你编写代码时，它会产生巨大的影响。它的推荐设置是<code class="fe mz na nb nc b">"arrow-body-style": ["error", "as-needed"]</code>，强制您删除不必要的返回，如下所示。</p><pre class="nd ne nf ng gt nh nc ni nj aw nk bi"><span id="df1d" class="nl lx it nc b gy nm nn l no np">// "arrow-body-style": ["error", "as-needed"],</span><span id="6bdb" class="nl lx it nc b gy nq nn l no np">// Incorrect<br/>let foo = () =&gt; {<br/>    return 0;<br/>};</span><span id="4def" class="nl lx it nc b gy nq nn l no np">// Correct<br/>let foo = () =&gt; 0</span></pre><figure class="nd ne nf ng gt ju gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/49fe7a4ff81219f160c9ad6a08aaf8a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1192/1*68W-Pyx2NeacK5Se6u-7aw.gif"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">gif:箭头体样式的自动格式</figcaption></figure><h1 id="30e3" class="lw lx it bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">2.反应/自动关闭-comp</h1><p id="9fa6" class="pw-post-body-paragraph kf kg it kh b ki mu kk kl km mv ko kp kq mw ks kt ku mx kw kx ky my la lb lc im bi translated"><a class="ae ld" href="https://github.com/jsx-eslint/eslint-plugin-react/blob/master/docs/rules/self-closing-comp.md" rel="noopener ugc nofollow" target="_blank">反应/自关闭-压缩</a>类似于箭体式。虽然它很简单，但它减少了大量的时间，因为有太多的机会来写自我封闭的JSX。</p><p id="e747" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">推荐设置为<code class="fe mz na nb nc b">react/self-closing-comp: ["error", { "component": true, "html": true }]</code></p><pre class="nd ne nf ng gt nh nc ni nj aw nk bi"><span id="ba4b" class="nl lx it nc b gy nm nn l no np">// "<!-- -->react/self-closing-comp": [<br/>//   "error", { <br/>//     "component": true,<br/>//     "html": true<br/>//   }<br/>// ]</span><span id="5772" class="nl lx it nc b gy nq nn l no np">// Incorrect<br/>&lt;Hello name="John"&gt;&lt;/Hello&gt;;<br/>&lt;div className="content"&gt;&lt;/div&gt;;</span><span id="9883" class="nl lx it nc b gy nq nn l no np">// Correct<br/>&lt;Hello name="John" /&gt;<br/>&lt;div className="content" /&gt;</span></pre><p id="56ea" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><code class="fe mz na nb nc b">"component": true</code>强迫你写一个带有自结束标签的自定义组件。此外，<code class="fe mz na nb nc b">"html": true</code>将普通html标签改为自结束标签。</p><figure class="nd ne nf ng gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ns"><img src="../Images/67710f662581053fa397095b4e098d35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*dw9mI3vB0UDcbxpPPFmkew.gif"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">gif:自动关闭排版格式</figcaption></figure><h1 id="b1b4" class="lw lx it bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">3.自动修复/无未使用变量</h1><p id="6f5b" class="pw-post-body-paragraph kf kg it kh b ki mu kk kl km mv ko kp kq mw ks kt ku mx kw kx ky my la lb lc im bi translated">这源于ESLint的<a class="ae ld" href="https://eslint.org/docs/latest/rules/no-unused-vars" rel="noopener ugc nofollow" target="_blank"> no-unused-vars </a>规则。尽管原始的no-unused-vars不会自动格式化，我还是推荐使用<a class="ae ld" href="https://github.com/aladdin-add/eslint-plugin/tree/master/packages/autofix" rel="noopener ugc nofollow" target="_blank"> eslint-plugin-autofix </a>。它会自动格式化。</p><pre class="nd ne nf ng gt nh nc ni nj aw nk bi"><span id="ff7d" class="nl lx it nc b gy nm nn l no np">$ yarn add -D eslint-plugin-autofix</span></pre><p id="1408" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">之后就可以作为ESLint插件添加了。</p><pre class="nd ne nf ng gt nh nc ni nj aw nk bi"><span id="3236" class="nl lx it nc b gy nm nn l no np">{<br/>  "plugins": ["react", "@typescript-eslint", "autofix"],<br/>  "rules": {<br/>    ...<br/>  }<br/>}</span></pre><p id="62fc" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">现在，你可以使用定义no-unused-vars规则，如下所示！</p><pre class="nd ne nf ng gt nh nc ni nj aw nk bi"><span id="38f4" class="nl lx it nc b gy nm nn l no np">// "autofix/no-unused-vars": [<br/>//   "error",<br/>//   {<br/>//     "argsIgnorePattern": "^_",<br/>//     "ignoreRestSiblings": true,<br/>//     "destructuredArrayIgnorePattern": "^_"<br/>//   }<br/>//  ]</span><span id="5543" class="nl lx it nc b gy nq nn l no np">// Incorrect<br/>function foo(x, y) {<br/>    return x + 1;<br/>}<br/>foo();</span><span id="9435" class="nl lx it nc b gy nq nn l no np">var { foo, ...coords } = data;</span><span id="d042" class="nl lx it nc b gy nq nn l no np">const [a, b] = ["a", "b"];<br/>console.log(b);</span><span id="e854" class="nl lx it nc b gy nq nn l no np">// Correct<br/>function foo(x, _y) {<br/>    return x + 1;<br/>}<br/>foo();</span><span id="298b" class="nl lx it nc b gy nq nn l no np">var { foo, ...coords } = data;</span><span id="76c6" class="nl lx it nc b gy nq nn l no np">const [_a, b] = ["a", "b"];<br/>console.log(b);</span></pre><p id="352d" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如果只是添加<code class="fe mz na nb nc b">autofix/no-used-vars: "error"</code>，所有未使用的变量都显示lint错误。但是，有时您希望定义未使用的变量来显示一些意图。所以我推荐用<code class="fe mz na nb nc b">argsIgnorePattern: "^_"</code>。带有<code class="fe mz na nb nc b">_</code>前缀，允许使用。</p><p id="d998" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><code class="fe mz na nb nc b">ignoreRestSiblings</code>选项<code class="fe mz na nb nc b">destructuredArrayIgnorePattern</code>是bit case特有的规则。</p><p id="1221" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">有时你可以使用rest属性从对象中删除一个键，如下所示。在这种情况下，您可能不再使用已删除的密钥。使用<code class="fe mz na nb nc b">ignoreRestSiblings</code>，您可以忽略从移除的键。</p><pre class="nd ne nf ng gt nh nc ni nj aw nk bi"><span id="3cb7" class="nl lx it nc b gy nm nn l no np">const obj = { first: "John", last: "Lennon", age: 30 };<br/>const { age, ...name } = obj;  // remove age from obj</span><span id="ba60" class="nl lx it nc b gy nq nn l no np">// =&gt; prevent age from ESLint error</span></pre><p id="1c12" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">类似的ESLint错误发生在数组析构中。使用数组析构时，可能不会使用第一个析构的元素。使用<code class="fe mz na nb nc b">destructuredArrayIgnorePattern: "^_"</code>，可以防止ESLint错误。</p><pre class="nd ne nf ng gt nh nc ni nj aw nk bi"><span id="3244" class="nl lx it nc b gy nm nn l no np">const [_A, B, C] = Promise.all([fetchA, fetchB, fetchC]);</span><span id="6ae6" class="nl lx it nc b gy nq nn l no np">console.log(B, C);</span><span id="2ab9" class="nl lx it nc b gy nq nn l no np">// =&gt; prevent A from ESLint error</span></pre><h1 id="1dd1" class="lw lx it bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">4.@ typescript-eslint/consistent-type-imports</h1><p id="dc21" class="pw-post-body-paragraph kf kg it kh b ki mu kk kl km mv ko kp kq mw ks kt ku mx kw kx ky my la lb lc im bi translated">当您导入TypeScript类型时，建议使用<a class="ae ld" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-8.html#type-only-imports-and-export" rel="noopener ugc nofollow" target="_blank"> type only import </a>以获得更好的性能。但是正确使用normal和type only import让我很困扰。</p><pre class="nd ne nf ng gt nh nc ni nj aw nk bi"><span id="a6ab" class="nl lx it nc b gy nm nn l no np">import { useEffect } from "react;<br/>import type { FC } from "react;</span></pre><p id="4bf0" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">所以是时候使用<a class="ae ld" href="https://github.com/typescript-eslint/typescript-eslint/blob/main/packages/eslint-plugin/docs/rules/consistent-type-imports.md" rel="noopener ugc nofollow" target="_blank">@ typescript-eslint/consistent-type-imports</a>了。它会自动检测导入的模块是否为类型，并根据需要进行格式化。</p><pre class="nd ne nf ng gt nh nc ni nj aw nk bi"><span id="7871" class="nl lx it nc b gy nm nn l no np">// "@typescript-eslint/consistent-type-imports": [<br/>//   "error",<br/>//   {<br/>//     "prefer": "type-imports",<br/>//   }   <br/>// ],</span><span id="9cd0" class="nl lx it nc b gy nq nn l no np">// Incorrect<br/>import { useEffect, FC } from "react";</span><span id="ccb8" class="nl lx it nc b gy nq nn l no np">// Correct<br/>import { useEffect } from "react";<br/>import type { FC } from "react";</span></pre><figure class="nd ne nf ng gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/653069a400390397e64dec66202d8f04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*wPkJWpI-_ccTEvhiB1zIOQ.gif"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">gif:仅用于类型导入的自动格式</figcaption></figure><h1 id="f8f6" class="lw lx it bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">5.进口/订购</h1><p id="5424" class="pw-post-body-paragraph kf kg it kh b ki mu kk kl km mv ko kp kq mw ks kt ku mx kw kx ky my la lb lc im bi translated">其实我最喜欢<a class="ae ld" href="https://github.com/import-js/eslint-plugin-import/blob/main/docs/rules/order.md" rel="noopener ugc nofollow" target="_blank">进口/订单</a>规则。因为有这么多的进口，自己组织进口订单总共浪费了很多时间。所以是时候用自动格式了！</p><pre class="nd ne nf ng gt nh nc ni nj aw nk bi"><span id="3b7a" class="nl lx it nc b gy nm nn l no np">// "import/order": [<br/>//   "error",<br/>//   {        <br/>//     "groups": [<br/>//       "builtin",<br/>//       "external",<br/>//       "parent",<br/>//       "sibling",<br/>//       "index",<br/>//       "object",   <br/>//       "type"<br/>//     ],<br/>//     "pathGroups": [<br/>//       {<br/>//         "pattern": "@/**/**",<br/>//         "group": "parent",<br/>//         "position": "before"<br/>//       }<br/>//     ],<br/>//     "alphabetize": { "order": "asc" }<br/>//   }<br/>// ],</span></pre><p id="6c2d" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">规则本身有点复杂。<code class="fe mz na nb nc b">groups</code>键定义模块类型之间的实际顺序。上面的配置命令在外部包(如<code class="fe mz na nb nc b">react</code>)之前在模块(如<code class="fe mz na nb nc b">path</code>)中构建节点。如果你想知道每组的详细情况，请查看<a class="ae ld" href="https://github.com/import-js/eslint-plugin-import/blob/main/docs/rules/order.md#importorder-enforce-a-convention-in-module-import-order" rel="noopener ugc nofollow" target="_blank">正式文件</a>。</p><p id="9f73" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><code class="fe mz na nb nc b">pathGroups</code>创建自定义群组。我经常为导入别名定义它。</p><pre class="nd ne nf ng gt nh nc ni nj aw nk bi"><span id="d412" class="nl lx it nc b gy nm nn l no np">// import alias<br/>import foo from "../../src/path/to/foo"; // not readable<br/>import foo from "@/src/path/to/foo";  // using import alias</span></pre><p id="4c9a" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">通过<code class="fe mz na nb nc b">pathGroups</code>设置，使用导入别名的模块在<code class="fe mz na nb nc b">parent</code>之前排序。</p><p id="7fef" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><code class="fe mz na nb nc b">alphabetize</code>指同一模块的订单。<code class="fe mz na nb nc b">react</code>是在<code class="fe mz na nb nc b">vue</code>之前点的(当然不会发生)。</p><h1 id="d99c" class="lw lx it bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">6.非限制进口</h1><p id="444b" class="pw-post-body-paragraph kf kg it kh b ki mu kk kl km mv ko kp kq mw ks kt ku mx kw kx ky my la lb lc im bi translated">就像我上面说的，导入别名很有帮助。我希望你们已经用过了。一旦引入导入别名，您可能希望禁止使用相对导入。所以是时候设置<a class="ae ld" href="https://eslint.org/docs/latest/rules/no-restricted-imports" rel="noopener ugc nofollow" target="_blank">非限制进口</a>了。</p><pre class="nd ne nf ng gt nh nc ni nj aw nk bi"><span id="e18c" class="nl lx it nc b gy nm nn l no np">// "no-restricted-imports": [<br/>//   "error",<br/>//   { <br/>//     "patterns": ["../"] <br/>//   }<br/>// ],</span></pre><p id="b65c" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">它限制通过相对路径导入父模块。另一方面，它允许通过相对路径导入子模块。这是一种偏好。如果想禁止任何相对路径，只需在<code class="fe mz na nb nc b">patterns</code>中添加<code class="fe mz na nb nc b">./</code>即可。</p><figure class="nd ne nf ng gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nt"><img src="../Images/87c13f8712dcee7f08bb0d8dba406211.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dSKiyX5RvKWkFMYMPt0wfA.png"/></div></div></figure><p id="7831" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">实际上，它不会自动格式化，因为ESLint不知道您的自定义导入别名。所以应该是手工完成。</p><h1 id="ed81" class="lw lx it bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">7.反应-钩子/详尽-deps</h1><p id="9d0d" class="pw-post-body-paragraph kf kg it kh b ki mu kk kl km mv ko kp kq mw ks kt ku mx kw kx ky my la lb lc im bi translated">React Hook需要定义依赖关系来检测内部逻辑何时应该运行。但是如果React Hook中有复杂的逻辑，就很难精确地写出所有的依赖关系。所以我使用<a class="ae ld" href="https://github.com/facebook/react/tree/main/packages/eslint-plugin-react-hooks#eslint-plugin-react-hooks" rel="noopener ugc nofollow" target="_blank">react-hooks/exhaustive-deps</a>来检测缺失的依赖项。</p><p id="b7cd" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">要使用react-hooks ESLint规则，您需要添加react-hooks包作为插件。如果还没做，请设置。</p><pre class="nd ne nf ng gt nh nc ni nj aw nk bi"><span id="aa39" class="nl lx it nc b gy nm nn l no np">// .eslintrcjson<br/>{<br/>  "plugins": [<br/>    "react",<br/>    "@typescript-eslint",<br/>    "autofix",<br/>    "react-hooks"<br/>  ],<br/>}</span></pre><p id="1112" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">规则本身很简单。就像下面这样加一行。</p><pre class="nd ne nf ng gt nh nc ni nj aw nk bi"><span id="809b" class="nl lx it nc b gy nm nn l no np">// "react-hooks/exhaustive-deps": "error"</span></pre><figure class="nd ne nf ng gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nu"><img src="../Images/b7fb66975e1d8697ad2633cf802d4e57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*akwDSHzVYSz6Gi8gmuxO-A.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">图:详尽的deps错误</figcaption></figure></div><div class="ab cl nv nw hx nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="im in io ip iq"><p id="504b" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">本文解释了为TypeScript React项目推荐的7个ESLint规则。虽然变化很小，但它会加快你未来很长一段时间的发展。</p><h1 id="e389" class="lw lx it bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">参考</h1><ul class=""><li id="2578" class="oc od it kh b ki mu km mv kq oe ku of ky og lc oh oi oj ok bi translated"><a class="ae ld" href="https://eslint.org/" rel="noopener ugc nofollow" target="_blank"> ESLint </a></li><li id="7911" class="oc od it kh b ki ol km om kq on ku oo ky op lc oh oi oj ok bi translated"><a class="ae ld" href="https://github.com/airbnb/javascript" rel="noopener ugc nofollow" target="_blank"> Airbnb </a>预置</li><li id="0d35" class="oc od it kh b ki ol km om kq on ku oo ky op lc oh oi oj ok bi translated"><a class="ae ld" href="https://github.com/google/eslint-config-google" rel="noopener ugc nofollow" target="_blank">谷歌</a>预置</li><li id="2a4d" class="oc od it kh b ki ol km om kq on ku oo ky op lc oh oi oj ok bi translated"><a class="ae ld" href="https://github.com/standard/standard" rel="noopener ugc nofollow" target="_blank">标准</a>预设</li><li id="52b1" class="oc od it kh b ki ol km om kq on ku oo ky op lc oh oi oj ok bi translated"><a class="ae ld" href="https://www.typescriptlang.org/" rel="noopener ugc nofollow" target="_blank">打字稿</a></li></ul></div></div>    
</body>
</html>