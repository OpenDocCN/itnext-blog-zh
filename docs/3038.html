<html>
<head>
<title>GraphQL fragment-based approach to building your components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建组件的基于片段的方法</h1>
<blockquote>原文：<a href="https://itnext.io/graphql-fragment-based-approach-to-building-your-components-798647d011a5?source=collection_archive---------3-----------------------#2019-09-19">https://itnext.io/graphql-fragment-based-approach-to-building-your-components-798647d011a5?source=collection_archive---------3-----------------------#2019-09-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="6fe6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当您开始在客户机上使用GraphQL并且您的代码库增长时，您可能会发现自己一次又一次地编写相同的查询。有时在查询中甚至会有死字段，因为很难跟踪组件树中使用了什么。通过这种重复，您会遇到一些我们将在本文中尝试回答的问题:</p><ul class=""><li id="293c" class="ko kp it js b jt ju jx jy kb kq kf kr kj ks kn kt ku kv kw bi translated">如何保持组件和GraphQL查询的可伸缩性和整洁？</li><li id="af91" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated">如何避免查询中的超取和死代码？</li><li id="30ee" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated">如何获得您需要的所有数据并且不遗漏任何内容？</li><li id="354c" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated">我应该在查询中放入什么，在片段中放入什么？</li></ul><p id="5d69" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们所有的现代web应用程序都由顶层和底层组件组成。大多数组件都有自己的数据依赖关系，我们应该以某种方式将它们正确地组合到一个查询中。</p><p id="f36c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">GraphQL有一个很好的特性可以重用部分查询代码— <a class="ae lc" href="https://graphql.org/learn/queries/#fragments" rel="noopener ugc nofollow" target="_blank">片段</a>。基于这个特性，我们将构建我们的组件和查询。</p><p id="8f20" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将以一个简单的博客帖子为例。看起来会是这样的:</p><figure class="le lf lg lh gt li gh gi paragraph-image"><div class="gh gi ld"><img src="../Images/9f56e540f337ea0ba158b41d131d7f69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1006/format:webp/1*sx-oNJnE4fX1f1xLaYcTAw.png"/></div></figure><p id="1baf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面是该页面的一个简短的GraphQL模式:</p><figure class="le lf lg lh gt li"><div class="bz fp l di"><div class="ll lm l"/></div></figure><p id="43ab" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，让我们计划查询来获取该页面的所有数据。我们的查询可能是这样的:</p><figure class="le lf lg lh gt li"><div class="bz fp l di"><div class="ll lm l"/></div></figure><p id="d3c0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们将尝试把这个查询分成更小的部分，并检查特定组件需要什么数据。</p><p id="4ba0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们从<em class="ln"> UserInfo </em>组件开始。在那里，我们需要有一个用户名和头像。基于此，我们可以创建一个片段来指定该组件所需的数据。</p><figure class="le lf lg lh gt li"><div class="bz fp l di"><div class="ll lm l"/></div></figure><p id="a280" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个片段是根据Relay Modern常用的约定来调用的:<strong class="js iu"><em class="ln">component name _ propName</em></strong>。尽管在Relay Modern中，是有意通过Relay Compat机制来编译查询，但我仍然发现这种方法有助于保持片段名称的一致和清晰。因为你总是知道这个碎片属于什么组件，属于什么道具。</p><p id="d33a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">好了，我们已经完成了<em class="ln"> UserInfo </em>组件，我们可以上一层到使用该组件的地方——Comment<em class="ln">Comment</em><strong class="js iu"/>组件。</p><p id="f9aa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该组件呈现评论文本和作者的简短信息。它的片段可能如下所示:</p><figure class="le lf lg lh gt li"><div class="bz fp l di"><div class="ll lm l"/></div></figure><p id="0349" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">好了，让我们进一步移动到<em class="ln">注释</em> <strong class="js iu"> </strong>组件。该组件需要每个<em class="ln">评论</em> <strong class="js iu"> </strong>组件的所有数据，此外还需要每个评论项的id。基于此，它的片段可能看起来像:</p><figure class="le lf lg lh gt li"><div class="bz fp l di"><div class="ll lm l"/></div></figure><p id="2edf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可以注意到，<em class="ln">注释</em>组件并不关心在<em class="ln">注释</em>组件中使用的数据。如果子组件中的某些东西发生了变化，那么这个片段就不需要任何变化。由于这种方法，我们为组件创建了数据依赖关系。</p><p id="ce99" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们通过完成剩余的组件和片段来多练习一下。那么还剩下什么呢？<em class="ln">帖子</em>和<em class="ln">帖子页</em>组件<em class="ln">。</em></p><p id="a5ef" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们的<em class="ln">帖子</em>需要<em class="ln"> </em>有帖子内容和作者。对于作者，我们将使用用于<em class="ln">评论</em>组件的相同组件，由于这种方法，我们不需要再次指定<em class="ln"> UserInfo </em>所需的所有字段<em class="ln">。我们可以重用UserInfo_user </em>片段。</p><figure class="le lf lg lh gt li"><div class="bz fp l di"><div class="ll lm l"/></div></figure><p id="2798" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，我们可以将所有这些片段组合到查询中:</p><figure class="le lf lg lh gt li"><div class="bz fp l di"><div class="ll lm l"/></div></figure><p id="9ccb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">注意，我们没有将任何帖子字段直接包含到<em class="ln"> PostPageQuery </em>中，因为我们没有在<em class="ln"> PostPage </em>组件中使用它们。如果我们需要一些，我们可以很容易地将其添加到查询中。唯一要记住的是，我们通过片段或查询在同一个组件级别上指定所有必需的字段。</p><h1 id="a0e9" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">结论</h1><p id="1dae" class="pw-post-body-paragraph jq jr it js b jt mm jv jw jx mn jz ka kb mo kd ke kf mp kh ki kj mq kl km kn im bi translated">这种基于片段的方法将有助于跟踪您的查询，因为您的所有字段都在确切使用它们的地方被提及。您可以安全地删除片段树中每一层的数据字段，因为片段只负责组件需要的数据。此外，您不必担心不同的片段名称必须是描述性的。</p><p id="c494" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">给这种基于片段的方法一个机会，您将看到GraphQL是如何与您的组件很好地协同工作的。</p></div></div>    
</body>
</html>