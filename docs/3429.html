<html>
<head>
<title>Distributed Tracing in your Kibana with Node.JS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Node在您的Kibana中进行分布式跟踪。射流研究…</h1>
<blockquote>原文：<a href="https://itnext.io/distributed-tracing-in-your-kibana-with-nodejs-610c9f07b4b4?source=collection_archive---------0-----------------------#2019-12-14">https://itnext.io/distributed-tracing-in-your-kibana-with-nodejs-610c9f07b4b4?source=collection_archive---------0-----------------------#2019-12-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="f72e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">分布式跟踪是一种用于分析和监控应用程序的方法，尤其是那些使用微服务架构构建的应用程序。分布式跟踪有助于查明故障发生的位置以及导致低性能的原因。此外，它可以用来可视化和理解微服务之间的通信，而无需额外的文档(这通常很快就会过时)。</p><p id="621b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在很长一段时间里有两个主要选项可供选择，它们是<a class="ae kl" href="https://zipkin.io/" rel="noopener ugc nofollow" target="_blank">齐普金</a>和<a class="ae kl" href="https://www.jaegertracing.io/" rel="noopener ugc nofollow" target="_blank">耶格</a>。但是在弹性堆栈中有一只相对较新的野兽叫做<a class="ae kl" href="https://www.elastic.co/products/apm" rel="noopener ugc nofollow" target="_blank"> APM </a>。通过使用Elastic APM，可以在Elasticsearch中存储分布式跟踪信息，并在Kibana中将其可视化。如果你已经使用了Elasticsearch和Kibana来记录日志，这是非常有用的，因为它打开了一个现成的解决方案来链接日志和你的跟踪信息。您不必再在系统之间跳转来关联您的日志和跟踪。</p><h1 id="8b18" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">高层架构</h1><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi lk"><img src="../Images/29732d5d7a25e265a5a7fffe49e5a948.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U_MDO4q-A0xz9V1e3Vjusw.png"/></div></div><figcaption class="lw lx gj gh gi ly lz bd b be z dk translated">图像取自<a class="ae kl" href="https://www.elastic.co/guide/en/apm/get-started/current/images/apm-architecture-cloud.png" rel="noopener ugc nofollow" target="_blank"> APM文档</a></figcaption></figure><p id="b08b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> APM代理</strong></p><p id="cb66" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">APM代理实际上是您的服务的一部分，它收集跟踪数据并将其发送到APM服务器。Elastic team已经为最流行的编程语言(例如Go、Node)创建了一堆代理。JS，。NET、Java等)。受支持代理和相应文档的完整列表可在<a class="ae kl" href="https://www.elastic.co/guide/en/apm/agent/index.html" rel="noopener ugc nofollow" target="_blank"> APM文档</a>中找到。</p><p id="252a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> APM服务器</strong></p><p id="dfb8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">APM服务器负责处理来自代理的请求。它执行验证、安全扫描、创建有效文档并将其存储到弹性搜索索引中。</p><p id="bc0e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">弹性搜索</strong></p><p id="e9fa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它是分布式搜索和分析引擎。简单地说，你可以把它当作一种数据库。</p><p id="2ef1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">基巴纳</strong></p><p id="ae88" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">与Elasticsearch配合使用的丰富可视化平台。</p><h1 id="a47d" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">将APM代理添加到节点。JS服务</h1><p id="b9da" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">将APM代理添加到您现有的服务中非常容易，并且只需要最少的更改。</p><p id="f169" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，它应该被添加到一个应用程序。</p><pre class="ll lm ln lo gt mf mg mh mi aw mj bi"><span id="e2dc" class="mk kn iq mg b gy ml mm l mn mo">npm install elastic-apm-node --save</span></pre><p id="9c71" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下一步是添加并启动代理。</p><pre class="ll lm ln lo gt mf mg mh mi aw mj bi"><span id="3054" class="mk kn iq mg b gy ml mm l mn mo">const apm = require('elastic-apm-node').start({<br/>  serviceName: 'my-awesome-service',<br/>  serverUrl: 'http://localhost:8200',<br/>})</span></pre><p id="dc09" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里最重要的是，它应该是你在应用中要求的第一个模块(详情见下文)。节点。启动期间的JS APM代理工具库。它包装节点。JS核心服务和安装的外部库能够自动启动、配置和结束事务和跨度。可以在<a class="ae kl" href="https://github.com/elastic/apm-agent-nodejs/tree/v3.3.0/lib/instrumentation/modules" rel="noopener ugc nofollow" target="_blank"> elastic-apm-node库</a>和官方<a class="ae kl" href="https://www.elastic.co/guide/en/apm/agent/nodejs/current/supported-technologies.html" rel="noopener ugc nofollow" target="_blank">文档</a>中找到插装模块的列表。作为开发人员，您实际上可以通过将<a class="ae kl" href="https://github.com/elastic/apm-agent-nodejs/tree/v3.3.0/lib/instrumentation/modules" rel="noopener ugc nofollow" target="_blank"><em class="mp">disable instrumentation</em>配置</a>传递给代理来禁用任何特定模块的插装，甚至可以通过<a class="ae kl" href="https://www.elastic.co/guide/en/apm/agent/nodejs/3.x/configuration.html#instrument" rel="noopener ugc nofollow" target="_blank"><em class="mp">instrument</em></a><em class="mp"/>属性完全禁用插装。</p><p id="4cc6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">APM代理已经启动并正在运行。它为传入的HTTP请求启动和完成事务，为出站请求、外部存储调用创建跨度，将相应的HTTP头传递给下一个服务(上下文传播)等，而无需服务开发人员提供任何额外的显式代码行。</p><p id="c446" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我宁愿提一下<em class="mp">开始</em>功能可能包括<a class="ae kl" href="https://www.elastic.co/guide/en/apm/agent/nodejs/2.x/configuration.htmlhttps://www.elastic.co/guide/en/apm/agent/nodejs/2.x/configuration.html" rel="noopener ugc nofollow" target="_blank">吨设置</a>。因此，对代理进行细粒度的配置是可能的。来自Elastic的人们通过提供相当灵活的方法在配置方面做得很好。所以可以通过代码使用全局设置、环境变量和配置。设置在<a class="ae kl" href="https://github.com/elastic/apm-agent-nodejs/blob/v3.3.0/lib/config.js#L212-L218" rel="noopener ugc nofollow" target="_blank">中应用，优先级如下</a>:</p><ul class=""><li id="9b01" class="mq mr iq jp b jq jr ju jv jy ms kc mt kg mu kk mv mw mx my bi translated">通过环境变量传递的选项— <strong class="jp ir">最高优先级</strong></li><li id="2fc0" class="mq mr iq jp b jq mz ju na jy nb kc nc kg nd kk mv mw mx my bi translated">传递给<em class="mp"> agent.start()的选项</em></li><li id="be73" class="mq mr iq jp b jq mz ju na jy nb kc nc kg nd kk mv mw mx my bi translated">全局配置文件中的选项</li><li id="cfe0" class="mq mr iq jp b jq mz ju na jy nb kc nc kg nd kk mv mw mx my bi translated">默认选项—最低优先级</li></ul><p id="4c01" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">回到凝视APM代理。有一句话是这样的:</p><h1 id="7534" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">APM代理使用建议</h1><p id="3250" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">这些建议是基于我个人对Node的体验。JS弹性APM剂。</p><p id="aa77" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">检查交易和跨度明细</strong></p><p id="1a44" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果打开了检测，那么准备好查看代理收集的数据。例如，APM代理存储入站HTTP请求的请求头和请求体。它还根据您的请求对象等中的信息添加当前用户信息。存在以下问题:</p><ol class=""><li id="f515" class="mq mr iq jp b jq jr ju jv jy ms kc mt kg mu kk ne mw mx my bi translated">存储无谓的信息会增加弹性搜索的内存消耗</li><li id="ee62" class="mq mr iq jp b jq mz ju na jy nb kc nc kg nd kk ne mw mx my bi translated">存储敏感信息。令牌和其他敏感信息通常是通过头传递的。(幸运的是，90%的情况下APM服务器会删除此类信息)</li><li id="1a5f" class="mq mr iq jp b jq mz ju na jy nb kc nc kg nd kk ne mw mx my bi translated">代理将用户id、名称和电子邮件添加到事务中，如果它能够在请求对象中找到这些信息的话。例如，您的应用程序使用passport，passport将用户信息存储在<em class="mp"> request.user，</em>中。因此，如果没有明确指定用户，APM代理将从请求中获取值。存储这样的信息可能是GDPR的问题</li></ol><p id="4d0c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">使用标签和海关</strong></p><p id="bc60" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有可能向交易和跨度添加附加信息。它们是标签和习俗。它们之间的主要区别是标签是索引的(可搜索的)，而海关不是。</p><p id="2a3d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">标签示例:</p><ul class=""><li id="4f49" class="mq mr iq jp b jq jr ju jv jy ms kc mt kg mu kk mv mw mx my bi translated">系统在跟踪前已经有一个关联id ( <a class="ae kl" href="https://medium.com/@evgeni.kisel/add-correlation-id-in-node-js-applications-fde759eed5e3" rel="noopener">如何添加关联id </a>)。因此，correlation id是添加到所有事务中的一个很好的标签。</li><li id="68ea" class="mq mr iq jp b jq mz ju na jy nb kc nc kg nd kk mv mw mx my bi translated">蓝绿色，金丝雀释放。信息也可以存储在标签中，以区分不同类型的服务。甚至可以使用APM代理中的<a class="ae kl" href="https://github.com/nodejs/node/issues/22360" rel="noopener ugc nofollow" target="_blank">全局标签设置</a>来设置这种标签。</li></ul><p id="32a0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">海关的例子:</p><ul class=""><li id="c35a" class="mq mr iq jp b jq jr ju jv jy ms kc mt kg mu kk mv mw mx my bi translated">存储与上下文相关的信息，这些信息在搜索过程中没有任何意义，但通过提供一些特定于应用程序的上下文来帮助分析。</li></ul><p id="22c7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">处理多集群环境</strong></p><p id="234f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果有多个集群(例如，针对特定客户或特定位置的独立集群)，那么可以肯定的是，应该在交易中跟踪关于集群的信息，以便能够根据该数据进行过滤。实际上有两种方法可以跟踪这些数据。</p><ul class=""><li id="6181" class="mq mr iq jp b jq jr ju jv jy ms kc mt kg mu kk mv mw mx my bi translated">第一个选项是通过标签设置集群名称。使用这种方法，在Kibana的服务页面上，每个服务只有一个记录。</li></ul><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi nf"><img src="../Images/f4b8296524caa2a28289b59b6f8b1023.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ee-3NiKWtizcvq0r_-q8Gg.png"/></div></div></figure><ul class=""><li id="7ae4" class="mq mr iq jp b jq jr ju jv jy ms kc mt kg mu kk mv mw mx my bi translated">第二个选项是通过<a class="ae kl" href="https://www.elastic.co/guide/en/apm/agent/nodejs/current/configuration.html#environment" rel="noopener ugc nofollow" target="_blank">环境</a>代理参数设置集群名称。在这种情况下，您可以很容易地在Kibana中按环境进行过滤。所有页面上都有一个专用的快速过滤器。</li></ul><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi ng"><img src="../Images/d73d2737862fa4b0779254f2f1105d8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ffcRY0J0ooOz9GGVGOvAzw.png"/></div></div></figure><p id="dbf4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">检查资源消耗</strong></p><p id="33f9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当采用跟踪时，确保它是在没有抽样事务的情况下进行测试的。内存消耗可能会增加。就我个人而言，我有过几次内存泄漏，幸运的是很快就被修复了。</p><p id="1e7b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">支持采样率快速切换</strong></p><p id="9b3b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">实际上，让跟踪一直处于全功率状态是没有意义的。在直接性能研究期间，通常以全功率使能。其余时间，它应该以10-20%的功率工作，以减少弹性搜索的无谓负载。10–20%的功耗让您可以创建报告，并对系统的性能和问题有一个高层次的认识。</p><p id="a78b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不幸的是没有“深度采样”/“采样传播”。这意味着如果有两个服务<em class="mp">服务A </em>和<em class="mp">服务B </em>并且一个调用另一个，并且两者都配置了采样速率，则采样分别应用于每个服务。这样做的副作用是，可能有<em class="mp"> ServiceA </em>事务，但没有任何<em class="mp"> ServiceB </em>事务，反之亦然。IMHO的最佳情况是，如果根事务被持久化，那么它应该强制所有子事务被持久化，如果根事务没有被持久化，那么所有子事务也不应该被持久化。我称之为抽样传播。</p><p id="08b2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">用跟踪信息丰富日志记录</strong></p><p id="fc49" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了能够将日志记录和跟踪数据关联起来，需要用包括以下一个或多个字段的跟踪信息来丰富日志记录:</p><ul class=""><li id="ce1b" class="mq mr iq jp b jq jr ju jv jy ms kc mt kg mu kk mv mw mx my bi translated"><em class="mp"> transaction.id </em></li><li id="be5d" class="mq mr iq jp b jq mz ju na jy nb kc nc kg nd kk mv mw mx my bi translated"><em class="mp"> trace.id </em></li><li id="fbbb" class="mq mr iq jp b jq mz ju na jy nb kc nc kg nd kk mv mw mx my bi translated"><em class="mp"> span.id </em></li></ul><p id="4140" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">代理提供API来为currentation事务<em class="mp"> apm.currentTraceIds. </em>获取这些值，唯一的事情是将它们注入特定的记录器。</p><p id="45e4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，将<em class="mp"> trace.id </em>和<em class="mp"> transaction.id </em>添加到响应头中是有意义的。</p><p id="a238" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">注意风俗习惯</strong></p><p id="20d2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">大部分仪器通过<a class="ae kl" href="https://nodejs.org/api/async_hooks.html" rel="noopener ugc nofollow" target="_blank">异步挂钩</a>工作。所以请记住，由于V8的问题，插装对于使用自定义名称的库(例如，mongoose使用自己的开箱即用的承诺)不起作用。关于这个问题的更多细节可以在这里找到:</p><ul class=""><li id="25ff" class="mq mr iq jp b jq jr ju jv jy ms kc mt kg mu kk mv mw mx my bi translated"><a class="ae kl" href="https://github.com/elastic/apm-agent-nodejs/issues/1550" rel="noopener ugc nofollow" target="_blank">https://github.com/elastic/apm-agent-nodejs/issues/1550</a></li><li id="dcf8" class="mq mr iq jp b jq mz ju na jy nb kc nc kg nd kk mv mw mx my bi translated"><a class="ae kl" href="https://github.com/nodejs/node/issues/22360" rel="noopener ugc nofollow" target="_blank">https://github.com/nodejs/node/issues/22360</a></li></ul><p id="fdba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">猫鼬怎么修？</p><ul class=""><li id="3340" class="mq mr iq jp b jq jr ju jv jy ms kc mt kg mu kk mv mw mx my bi translated">首先，需要将内置承诺注册为mongoose的默认承诺</li></ul><pre class="ll lm ln lo gt mf mg mh mi aw mj bi"><span id="0ee2" class="mk kn iq mg b gy ml mm l mn mo">mongoose.Promise = global.Promise;</span></pre><ul class=""><li id="9a13" class="mq mr iq jp b jq jr ju jv jy ms kc mt kg mu kk mv mw mx my bi translated">使用<code class="fe nh ni nj mg b">exec()</code>运行数据库操作</li></ul><pre class="ll lm ln lo gt mf mg mh mi aw mj bi"><span id="a2f8" class="mk kn iq mg b gy ml mm l mn mo">async function getDataNotTrackedByAPM() {<br/>    const result = await Model.find();<br/>    result result;<br/>}</span><span id="7d1a" class="mk kn iq mg b gy nk mm l mn mo">async function getData() {<br/>    const result = await Model.find().exec();<br/>    result result;<br/>}</span></pre><p id="c00c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如何确保代码中没有使用自定义名称？我有一个相当肮脏的方法，但它有助于迁移相当大的代码库(但它需要良好的测试覆盖)。</p><pre class="ll lm ln lo gt mf mg mh mi aw mj bi"><span id="144c" class="mk kn iq mg b gy ml mm l mn mo">if (<em class="mp">process</em>.env.NODE_ENV !== `production`) {<br/>    mongoose.Query.prototype.then = function() {<br/>        throw new <em class="mp">Error</em>(<br/>            `use exec() because requests cannot be tracked by APM Agent`,<br/>        );<br/>    };<br/>}</span></pre><h1 id="aa26" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">配置本地开发环境</h1><p id="7440" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">使用docker可以轻松配置本地开发环境。它只需要两个文件和docker:</p><ul class=""><li id="a2f1" class="mq mr iq jp b jq jr ju jv jy ms kc mt kg mu kk mv mw mx my bi translated">apm-server.yml</li></ul><pre class="ll lm ln lo gt mf mg mh mi aw mj bi"><span id="55a9" class="mk kn iq mg b gy ml mm l mn mo">apm-server:<br/>  host:<br/>    "0.0.0.0:8200"<br/><br/>output.elasticsearch:<br/>  hosts:<br/>    ["elasticsearch:9200"]</span></pre><ul class=""><li id="9161" class="mq mr iq jp b jq jr ju jv jy ms kc mt kg mu kk mv mw mx my bi translated">docker-compose.yml</li></ul><pre class="ll lm ln lo gt mf mg mh mi aw mj bi"><span id="84e4" class="mk kn iq mg b gy ml mm l mn mo">version: "3"<br/>services:<br/>  elasticsearch:<br/>    image: docker.elastic.co/elasticsearch/elasticsearch:7.4.0<br/>    ports:<br/>      - 9200:9200<br/>      - 9300:9300<br/>    environment:<br/>      - discovery.type=single-node<br/><br/>  apm-server:<br/>    image: docker.elastic.co/apm/apm-server:7.4.0<br/>    depends_on:<br/>      - elasticsearch<br/>    environment:<br/>      - output.elasticsearch.hosts=["elasticsearch:9200"]<br/>    volumes:<br/>      - "./apm-server.yml:/usr/share/apm-server/apm-server.yml:ro"<br/>    ports:<br/>      - 8200:8200<br/><br/>  kibana:<br/>    image: docker.elastic.co/kibana/kibana:7.4.0<br/>    depends_on:<br/>      - elasticsearch<br/>    ports:<br/>      - 5601:5601<br/>    environment:<br/>      - ELASTICSEARCH_HOSTS=http://elasticsearch:9200</span></pre><p id="719c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了能够使用分布式跟踪，应该运行docker-compose。然后通过<a class="ae kl" href="http://localhost:5601" rel="noopener ugc nofollow" target="_blank">http://localhost:5601</a>URL打开Kibana，找到APM选项卡，按照设置说明进行操作。</p><p id="71af" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是一些简单的例子:</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi nl"><img src="../Images/e2e81a92b305793e0c44f3d4ef803bd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YSz1fwjhplId-pL_8C0lwA.png"/></div></div></figure><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi nm"><img src="../Images/58d1bc1cf451e7d0def1e4e89bb16274.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iiBOemM2tuoEIiZ_yNy5hw.png"/></div></div></figure><h1 id="d389" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">结论</h1><p id="600c" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">弹性APM解决方案非常合适，并且可以很容易地采用，因为已经实现的APM代理具有各种各样的“魔力”,可以最大限度地减少所需的服务开发人员工作量。如果已经有了Kibana，这种解决方案还消除了添加额外可视化资源的不必要步骤。</p><p id="bb95" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有用的链接:</p><ul class=""><li id="f8e3" class="mq mr iq jp b jq jr ju jv jy ms kc mt kg mu kk mv mw mx my bi translated">https://www.elastic.co/products/apm<a class="ae kl" href="https://www.elastic.co/products/apm" rel="noopener ugc nofollow" target="_blank"/></li><li id="6454" class="mq mr iq jp b jq mz ju na jy nb kc nc kg nd kk mv mw mx my bi translated"><a class="ae kl" href="https://www.elastic.co/guide/en/apm/get-started/current/index.html" rel="noopener ugc nofollow" target="_blank">https://www . elastic . co/guide/en/APM/get-started/current/index . html</a></li><li id="7847" class="mq mr iq jp b jq mz ju na jy nb kc nc kg nd kk mv mw mx my bi translated"><a class="ae kl" href="https://www.elastic.co/guide/en/apm/agent/nodejs/index.html" rel="noopener ugc nofollow" target="_blank">https://www.elastic.co/guide/en/apm/agent/nodejs/index.html</a></li><li id="9f8c" class="mq mr iq jp b jq mz ju na jy nb kc nc kg nd kk mv mw mx my bi translated"><a class="ae kl" href="https://www.npmjs.com/package/elastic-apm-node" rel="noopener ugc nofollow" target="_blank">https://www.npmjs.com/package/elastic-apm-node</a></li><li id="1aa0" class="mq mr iq jp b jq mz ju na jy nb kc nc kg nd kk mv mw mx my bi translated"><a class="ae kl" href="https://nodejs.org/api/async_hooks.html" rel="noopener ugc nofollow" target="_blank">https://nodejs.org/api/async_hooks.html</a></li><li id="e9ee" class="mq mr iq jp b jq mz ju na jy nb kc nc kg nd kk mv mw mx my bi translated"><a class="ae kl" href="https://medium.com/autodesk-tlv/async-hooks-a-whole-new-world-of-opportunities-a1a6daf1990a" rel="noopener">https://medium . com/Autodesk-TLV/async-hooks-a-whole-new-world-of-opportunities-a1 a6 daf 1990 a</a></li></ul></div></div>    
</body>
</html>