<html>
<head>
<title>How to create a custom static website generator in 170 lines of code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用170行代码创建一个定制的静态网站生成器</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-create-a-custom-static-website-generator-in-170-lines-of-code-461082d6d349?source=collection_archive---------4-----------------------#2022-10-10">https://itnext.io/how-to-create-a-custom-static-website-generator-in-170-lines-of-code-461082d6d349?source=collection_archive---------4-----------------------#2022-10-10</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><h2 id="1100" class="is it iu bd b dl iv iw ix iy iz ja dk jb translated" aria-label="kicker paragraph">静态网站生成</h2><div class=""/><div class=""><h2 id="49f1" class="pw-subtitle-paragraph ka jd iu bd b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dk translated"><strong class="ak"> Live rebuild，rendering Markdown和AsciiDoctor，多个模板引擎，几行代码。</strong></h2></div><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj ks"><img src="../Images/c9396247b5990f52ae8009d1efaa58ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Wj51IYEbne36Tvx1.png"/></div></div><figcaption class="le lf gk gi gj lg lh bd b be z dk translated">作者图片</figcaption></figure><p id="7941" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">本教程展示了如何用少量代码创建一个简单的静态网站生成器，运行在Node.js上。在我的理解中，<em class="me">静态网站生成器</em>是为网站生成HTML、CSS、JavaScript等文件的应用。结果是一个目录层次结构，可以上传到一个简单的web服务器，比如Apache，而不需要在服务器端执行任何动态操作。我这样说是因为其他人可能有不同的定义。</p><p id="d95d" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">我们讨论的是一个名为GuideCMS的演示应用程序，用于<code class="fe mf mg mh mi b">@akashacms/renderers</code>包。它包含在渲染器包存储库中，并支持以下功能:</p><ul class=""><li id="247f" class="mj mk iu lk b ll lm lo lp lr ml lv mm lz mn md mo mp mq mr bi translated">当文件发生更改时，实时重建内容</li><li id="a77b" class="mj mk iu lk b ll ms lo mt lr mu lv mv lz mw md mo mp mq mr bi translated">呈现Markdown或AsciiDoctor内容文件</li><li id="b3be" class="mj mk iu lk b ll ms lo mt lr mu lv mv lz mw md mo mp mq mr bi translated">向CSS呈现较少的文件</li><li id="27e6" class="mj mk iu lk b ll ms lo mt lr mu lv mv lz mw md mo mp mq mr bi translated">多种格式的渲染模板，如EJS和努乔克</li></ul><p id="0a99" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">显然，要在170行代码中完成所有这些工作，需要依赖一些外部包。关键是AkashaCMS的两个子模块。一，</p><p id="3fdb" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated"><code class="fe mf mg mh mi b"><a class="ae mx" href="https://npmjs.com/package/@akashacms/stacked-dirs" rel="noopener ugc nofollow" target="_blank">@akashacms/stacked-dirs</a></code>，处理目录层次结构的实时重新扫描。另一个，<code class="fe mf mg mh mi b"><a class="ae mx" href="https://npmjs.com/package/@akashacms/renderers" rel="noopener ugc nofollow" target="_blank">@akashacms/renderers</a></code>，使用几个模板引擎渲染文件。</p><p id="c028" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">GuideCMS源代码位于GitHub的</p><p id="b0ee" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated"><code class="fe mf mg mh mi b"><a class="ae mx" href="https://github.com/akashacms/rendering-engines/tree/main/guidecms" rel="noopener ugc nofollow" target="_blank">@akashacms/renderers</a></code> <a class="ae mx" href="https://github.com/akashacms/rendering-engines/tree/main/guidecms" rel="noopener ugc nofollow" target="_blank">储存库</a>，寻找<code class="fe mf mg mh mi b">guidecms.mjs</code>。它有几个用途:</p><ul class=""><li id="0d40" class="mj mk iu lk b ll lm lo lp lr ml lv mm lz mn md mo mp mq mr bi translated">演示如何创建一个定制的静态网站生成器，直接满足您的需求。</li><li id="2cd8" class="mj mk iu lk b ll ms lo mt lr mu lv mv lz mw md mo mp mq mr bi translated">展示如何使用<code class="fe mf mg mh mi b">@akashacms/renderers</code>和<code class="fe mf mg mh mi b">@akashacms/stacked-dirs</code></li><li id="9f86" class="mj mk iu lk b ll ms lo mt lr mu lv mv lz mw md mo mp mq mr bi translated">充当这些包的真实测试</li><li id="68cd" class="mj mk iu lk b ll ms lo mt lr mu lv mv lz mw md mo mp mq mr bi translated">处理格式化<code class="fe mf mg mh mi b"><a class="ae mx" href="https://akashacms.github.io/rendering-engines/index.html" rel="noopener ugc nofollow" target="_blank">@akashacms/renderers</a></code> <a class="ae mx" href="https://akashacms.github.io/rendering-engines/index.html" rel="noopener ugc nofollow" target="_blank">在线文档</a></li></ul><p id="e7cb" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">刚刚命名的包，以及它们使用的包，为静态网站生成器提供了良好的基础。事实上，它们是<a class="ae mx" href="https://akashacms.com/" rel="noopener ugc nofollow" target="_blank"> AkashaCMS </a>的核心。虽然这些包是为AkashaCMS设计的，但它们被设计成可以在其他项目中重用，GuideCMS也证明了这一点。</p><h1 id="0947" class="my mz iu bd na nb nc nd ne nf ng nh ni kj nj kk nk km nl kn nm kp nn kq no np bi translated"><code class="fe mf mg mh mi b">@akashacms/stacked-dirs</code>和<code class="fe mf mg mh mi b">@akashacms/renderers</code>概述</h1><p id="51fc" class="pw-post-body-paragraph li lj iu lk b ll nq ke ln lo nr kh lq lr ns lt lu lv nt lx ly lz nu mb mc md in bi translated">在我们开始之前，让我们简单讨论一下这两个包是做什么的。</p><p id="996e" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">堆叠目录(<code class="fe mf mg mh mi b">@akashacms/stacked-dirs</code>)在AkashaCMS中用于处理输入目录的潜在复杂配置，同时也处理已更改输入文件的实时重建。为了支持实时重建，该包使用Chokidar来监控输入文件，并在文件被更改或删除时发送事件。</p><p id="de57" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">管理网站内容时，您可能会合并来自多个来源的内容。在AkashaCMS中，决定支持将多个输入目录映射到一个虚拟文件系统中，并允许每个目录潜在地位于该文件系统中的不同点。例如，您可能有映射到<code class="fe mf mg mh mi b">/marketing</code>、<code class="fe mf mg mh mi b">/support</code>、<code class="fe mf mg mh mi b">/api</code>和<code class="fe mf mg mh mi b">/blog</code>的目录，每个目录由不同的人管理。堆叠目录包就是为处理这种情况而设计的。</p><p id="de4f" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">Renderers ( <code class="fe mf mg mh mi b">@akashacms/renderers</code>)是一个封装了几个渲染引擎的包。这些大多是流行的模板引擎。其概念是拥有一种格式的对象，该对象被呈现为另一种格式，以便在网站上使用。例如，对于呈现为CSS的更易于实现的样式表，LESS受支持；对于HTML呈现，Markdown和AsciiDoctor都受支持作为文档格式；对于页面布局，几个模板引擎都受支持。</p><p id="1df1" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">因此，堆叠目录包扫描输入文件，发送关于新的、改变的或删除的文件的通知，而渲染器包处理渲染输入文件以便在网站上使用。</p><h1 id="c8e4" class="my mz iu bd na nb nc nd ne nf ng nh ni kj nj kk nk km nl kn nm kp nn kq no np bi translated">CMS项目的配置</h1><p id="c510" class="pw-post-body-paragraph li lj iu lk b ll nq ke ln lo nr kh lq lr ns lt lu lv nt lx ly lz nu mb mc md in bi translated">GuideCMS示例工具使用YAML格式的配置文件。我们用它来声明输入目录和在渲染模板中使用的元数据值。元数据的一个用途是携带CSS和JavaScript文件的路径名，然后由页面布局模板代码呈现。</p><p id="3d80" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">配置文件示例:</p><pre class="kt ku kv kw gu nv mi nw nx aw ny bi"><span id="44c6" class="nz mz iu mi b gz oa ob l oc od"><em class="me">batchmode:</em> false<br/><br/><em class="me">dirs:</em><br/>    <em class="me">documents:</em><br/>        - <em class="me">mounted:</em> documents<br/>          <em class="me">mountPoint:</em> /<br/>        - <em class="me">mounted:</em> node_modules/bootstrap/dist<br/>          <em class="me">mountPoint:</em> /vendor/bootstrap<br/>    <em class="me">output:</em> ./out<br/>    <em class="me">layout:</em> ./layouts<br/>    <em class="me">partial:</em> ./partials<br/><br/><em class="me">metadata:</em><br/>    <em class="me">stylesheets:</em><br/>        - style.css<br/>        - vendor/bootstrap/css/bootstrap.css<br/>        - https://unpkg.com/@highlightjs/cdn-assets@11.6.0/styles/default.min.css<br/>    <em class="me">jsbottom:</em><br/>        # The .bundle.js version includes Popper<br/>        - vendor/bootstrap/js/bootstrap.bundle.js<br/>        - https://unpkg.com/@highlightjs/cdn-assets@11.6.0/highlight.min.js</span></pre><p id="3bb3" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated"><em class="me">文档</em>下有两个目录，第一个目录包含网站内容。第二个包含Bootstrap v5发行版，它被简单地复制到渲染输出目录中。在<em class="me">元数据</em>下，我们看到两个值，每个值都是一个数组，包含要在网站HTML中呈现的URL，以引用CSS或JavaScript文件。</p><p id="5a6d" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">在GuideCMS源代码中，<code class="fe mf mg mh mi b">js-yaml</code>包用于解析配置文件。然后使用以下代码将这些值存储在全局变量中:</p><pre class="kt ku kv kw gu nv mi nw nx aw ny bi"><span id="7ccc" class="nz mz iu mi b gz oa ob l oc od">const batchmode = cfg.batchmode;<br/>const docsDirectories = cfg.dirs.documents;<br/>const renderedOutput = cfg.dirs.output;<br/>const layoutsDir = cfg.dirs.layout;<br/>const partialsDir = cfg.dirs.partial;<br/>const metadata = cfg.metadata;</span></pre><p id="81d8" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">这些值将在GuideCMS的其余部分中使用。</p><h1 id="14e7" class="my mz iu bd na nb nc nd ne nf ng nh ni kj nj kk nk km nl kn nm kp nn kq no np bi translated">初始化堆叠目录</h1><p id="4266" class="pw-post-body-paragraph li lj iu lk b ll nq ke ln lo nr kh lq lr ns lt lu lv nt lx ly lz nu mb mc md in bi translated">请记住，使用<code class="fe mf mg mh mi b">@akashacms/stacked-dirs</code>的应用程序接收它要监视的目录中文件更改的事件。</p><pre class="kt ku kv kw gu nv mi nw nx aw ny bi"><span id="5f9f" class="nz mz iu mi b gz oa ob l oc od">const docsWatcher = new DirsWatcher('documents');<br/><br/>docsWatcher.on('ready', async (name) =&gt; {<br/>    console.log(`documents ready ${name}`);<br/>    if (batchmode) await close();<br/>})<br/>.on('change', async (name, info) =&gt; {<br/>    console.log(`documents change ${name} ${info.vpath}` /*, info */);<br/>    try {<br/>        await render(info);<br/>    } catch (err) {<br/>        console.error(`documents change ERROR `, err.stack);<br/>    }<br/>})<br/>.on('add', async (name, info) =&gt; {<br/>    console.log(`documents add ${name} ${info.vpath}` /*, info */);<br/>    try {<br/>        await render(info);<br/>    } catch (err) {<br/>        console.error(`documents add ERROR `, err.stack);<br/>    }<br/>})<br/>.on('unlink', async (name, info) =&gt; {<br/>    console.log(`documents unlink ${name} ${info.vpath}`, info);<br/>    // TODO Convert the path into a path within renderedOutput<br/>    try {<br/>        await fsp.unlink(path.join(renderedOutput, renderedPath(info.vpath)));<br/>    } catch (err) {<br/>        console.error(`documents unlink ERROR `, err.stack);<br/>    }<br/>});<br/><br/>docsWatcher.watch(docsDirectories);<br/><br/>async function close() {<br/>    await docsWatcher.close();<br/>}</span></pre><p id="7900" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">我们已经创建了一个<code class="fe mf mg mh mi b">DirsWatcher</code>实例来监视<code class="fe mf mg mh mi b">documents</code>数组中列出的目录。该代码监视四个事件，并对每个事件采取适当的措施。当需要关闭脚本时，调用<code class="fe mf mg mh mi b">close</code>函数，这将导致DirsWatcher停止监听事件，从而导致Node.js事件循环退出，从而导致脚本退出。</p><p id="4e15" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">对于<code class="fe mf mg mh mi b">change</code>和<code class="fe mf mg mh mi b">add</code>事件，调用<code class="fe mf mg mh mi b">render</code>函数。该函数通过呈现内容文件，然后将该内容呈现到页面布局模板中来处理页面布局。但是，在此之前，我们必须讨论如何初始化渲染器包。</p><h1 id="ce22" class="my mz iu bd na nb nc nd ne nf ng nh ni kj nj kk nk km nl kn nm kp nn kq no np bi translated">初始化渲染器包</h1><p id="5630" class="pw-post-body-paragraph li lj iu lk b ll nq ke ln lo nr kh lq lr ns lt lu lv nt lx ly lz nu mb mc md in bi translated">为使GuideCMS成为CMS，它必须呈现网站中使用的文件。使用堆叠的Dirs包，GuideCMS接收输入文件列表。对于每个输入文件，都会调用<code class="fe mf mg mh mi b">render</code>函数，该函数使用Renderers包来转换这些文件，以便在网站上使用。</p><p id="67e8" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">这要求我们初始化渲染器包。</p><pre class="kt ku kv kw gu nv mi nw nx aw ny bi"><span id="2fde" class="nz mz iu mi b gz oa ob l oc od">const renderers = new Renderers.Configuration({<br/>    <em class="me">partialDirs</em>: partialsDir ? [ partialsDir ] : undefined,<br/>    <em class="me">layoutDirs</em>: layoutsDir ? [ layoutsDir ] : undefined<br/>});</span></pre><p id="2af0" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated"><code class="fe mf mg mh mi b">renderers</code>对象将包含GuideCMS中使用的渲染器配置。</p><p id="63d8" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">配置类可以从传递给构造函数的对象初始化，如下所示。在本例中，我们传入一个partials目录和一个layouts目录。API支持每种目录类型的数组，但是在这里我们只需要一个。可以通过几种设置其他配置值的方法来配置或重新配置软件包。</p><p id="5e2d" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">Renderers包支持渲染Markdown和AsciiDoctor文档。对于Markdown，有一个很好的默认配置，但是我们也可以进行定制。</p><pre class="kt ku kv kw gu nv mi nw nx aw ny bi"><span id="4976" class="nz mz iu mi b gz oa ob l oc od">import { createRequire } from 'node:module';<br/>const require = createRequire(import.meta.url);<br/><br/>const rendererMarkdown = renderers.findRendererName('.html.md');<br/><br/>rendererMarkdown.configuration({<br/>    <em class="me">html</em>:         true,     // Enable html tags in source<br/>    <em class="me">xhtmlOut</em>:     false,    // Use '/' to close single tags (&lt;br /&gt;)<br/>    <em class="me">breaks</em>:       false,    // Convert '\n' in paragraphs into &lt;br&gt;<br/>    <em class="me">linkify</em>:      true,     // Autoconvert url-like texts to links<br/>    <em class="me">typographer</em>:  false,    // Enable smartypants and other sweet transforms<br/>})<br/>.use(require('markdown-it-highlightjs'), { <em class="me">auto</em>: true, <em class="me">code</em>: true, <em class="me">inline</em>: true })<br/>.use(require('markdown-it-expand-tabs'), { <em class="me">tabWidth</em>: 4 });</span></pre><p id="9234" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">这是降价呈现器的可选配置。因为渲染器包指南使用了许多代码片段，所以突出显示语法对它们很有用。此配置使用突出显示添加了语法突出显示。JS包。</p><p id="94d3" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">另一个细节是<code class="fe mf mg mh mi b">createRequire</code>函数。因为GuideCMS是ES6模块，所以CommonJS <code class="fe mf mg mh mi b">require</code>功能不可用。已经确定Markdown-IT插件必须使用<code class="fe mf mg mh mi b">require</code>加载。<code class="fe mf mg mh mi b">createRequire</code>函数生成一个<code class="fe mf mg mh mi b">require</code>函数，让我们在需要时使用<code class="fe mf mg mh mi b">require</code>。</p><p id="20be" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated"><code class="fe mf mg mh mi b">findRendererName</code>检索MarkdownRenderer实例。虽然大多数渲染器不需要额外的配置，但是这个渲染器支持两个配置选项。首先，<code class="fe mf mg mh mi b">configuration</code>方法传入一个Markdown-IT配置对象。其次，<code class="fe mf mg mh mi b">use</code>方法允许使用Markdown-IT插件。</p><p id="e569" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">前面显示的GuideCMS配置文件加载CSS和JS以使用Highlight.JS。添加<code class="fe mf mg mh mi b">markdown-it-highlightjs</code>插件会导致Markdown渲染器发出标记以进行高亮显示。</p><h1 id="18af" class="my mz iu bd na nb nc nd ne nf ng nh ni kj nj kk nk km nl kn nm kp nn kq no np bi translated">处理页面布局的渲染函数</h1><p id="32a1" class="pw-post-body-paragraph li lj iu lk b ll nq ke ln lo nr kh lq lr ns lt lu lv nt lx ly lz nu mb mc md in bi translated">我们现在可以看看<code class="fe mf mg mh mi b">render</code>函数。对于这个函数，我们支持两个阶段的过程，其中应用程序呈现内容文件，然后它可以将内容呈现到页面布局模板中。</p><pre class="kt ku kv kw gu nv mi nw nx aw ny bi"><span id="23ed" class="nz mz iu mi b gz oa ob l oc od">async function render(info) {<br/><br/>    // Read file content<br/>    // Find the renderer<br/>    // Ask the renderer to parse metadata<br/>    // render content<br/>    // If the metadata includes a layout<br/>    //     read the layout file<br/>    //     duplicate the previous metadata<br/>    //     add rendered content to new metadata<br/>    //     render<br/>    // Write rendered content to a file <br/>    // whose name is computed from input file<br/><br/>    const renderer = renderers.findRendererPath(info.vpath);<br/>    if (!renderer) {<br/>        const copyTo = path.join(renderedOutput, info.vpath);<br/>        console.log(`COPY ${info.vpath} to ${copyTo}`);<br/>        await fsp.mkdir(path.dirname(copyTo), { <em class="me">recursive</em>: true });<br/>        await fsp.copyFile(info.fspath, copyTo);<br/>        return;<br/>    }<br/>    // Create RenderingContext object<br/>    let context = {<br/>        <em class="me">fspath</em>: info.fspath,<br/>        <em class="me">content</em>: await fsp.readFile(info.fspath, 'utf-8')<br/>    };<br/>    context = renderer.parseMetadata(context);<br/>    if (context.metadata) {<br/>        context.metadata = copyMetadataProperties(context.metadata, metadata);<br/>        context.metadata.partial = async (fname, metadata) =&gt; {<br/>            return renderers.partial(fname, metadata);<br/>        };<br/>        context.metadata.partialSync = (fname, metadata) =&gt; {<br/>            // console.log(`partialSync ${renderers.partialSync} ${fname}`);<br/>            return renderers.partialSync(fname, metadata);<br/>        };<br/>    }<br/>    // console.log(`vpath ${info.vpath}`, context);<br/>    let rendered;<br/>    try {<br/>        rendered = await renderer.render(context);<br/>    } catch (err) {<br/>        throw new Error(`Failed to render ${info.vpath} because ${err}`);<br/>    }<br/><br/>    // console.log(`rendered`, rendered);<br/><br/>    let layoutRendered;<br/>    if (!context.metadata || !context.metadata.layout) {<br/>        layoutRendered = rendered;<br/>    } else {<br/>        const layoutFN = await renderers.findLayout(context.metadata.layout);<br/>        let layoutContext = {<br/>            <em class="me">fspath</em>: layoutFN,<br/>            <em class="me">content</em>: await fsp.readFile(layoutFN, 'utf-8'),<br/>            <em class="me">metadata</em>: copyMetadataProperties({}, context.metadata)<br/>        };<br/>        layoutContext.metadata = copyMetadataProperties(<br/>            layoutContext.metadata, metadata<br/>        );<br/>        delete layoutContext.metadata.layout;<br/>        layoutContext.metadata.content = rendered;<br/>        const layoutRenderer = renderers.findRendererPath(layoutFN);<br/>        // console.log(`layout context `, layoutContext);<br/>        try {<br/>            layoutRendered = await layoutRenderer.render(layoutContext);<br/>        } catch (err) {<br/>            throw new Error(`Failed to render ${layoutFN} with ${info.vpath} because ${err}`);<br/>        }<br/>    }<br/>    <br/>    const renderTo = path.join(renderedOutput, renderer.filePath(info.vpath));<br/>    await fsp.mkdir(path.dirname(renderTo), { <em class="me">recursive</em>: true });<br/>    console.log(`RENDER ${info.vpath} ==&gt; ${renderTo}`);<br/>    await fsp.writeFile(renderTo, layoutRendered, 'utf-8');<br/>}</span></pre><p id="c897" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated"><code class="fe mf mg mh mi b">info</code>对象来自Stacked Dirs包，它支持将几个目录组合成一个虚拟文件系统。更多详细信息，请参见<a class="ae mx" href="https://akashacms.com/news/2021/06/stacked-dirs.html" rel="noopener ugc nofollow" target="_blank">堆叠目录-静态网站生成器的目录/文件监视器</a>。这个对象包含几个描述文件的字段，但是这段代码只使用了两个。<code class="fe mf mg mh mi b">info.vpath</code>字段是<code class="fe mf mg mh mi b">documents</code>目录层次中的虚拟路径名。<code class="fe mf mg mh mi b">info.fspath</code>字段是文件系统中的绝对路径名。</p><p id="66fa" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated"><code class="fe mf mg mh mi b">findRendererPath</code>方法基于路径名定位正确的渲染器。每个渲染器实例使用一个或多个正则表达式来匹配路径名。例如，以<code class="fe mf mg mh mi b">.html.ejs</code>结尾的路径名表示该文件将作为EJS模板处理，它生成HTML输出，并且输出文件名的扩展名为<code class="fe mf mg mh mi b">.html</code>。同样，<code class="fe mf mg mh mi b">.html.njk</code>说这个文件是一个Nunjucks模板，产生HTML输出，文件名的扩展名是<code class="fe mf mg mh mi b">.html</code>。</p><p id="e773" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">如果找不到渲染器，那么应该将文件复制到输出目录中。输出目录的根目录在<code class="fe mf mg mh mi b">renderedOutput</code>中，因此使用<code class="fe mf mg mh mi b">info.vpath</code>用<code class="fe mf mg mh mi b">path.join</code>计算完整路径名。</p><p id="746d" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">接下来，代码创建一个RenderingContext对象。Renderer类中的几个方法使用该对象来保存与一个呈现事务相关的数据。</p><p id="88b1" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated"><code class="fe mf mg mh mi b">RenderingContext</code>类型是这样定义的:</p><pre class="kt ku kv kw gu nv mi nw nx aw ny bi"><span id="8bed" class="nz mz iu mi b gz oa ob l oc od">export type RenderingContext = {<br/>    fspath?: string;  // Pathname that can be given to template engines for error messages<br/>    <em class="me">content</em>: string;  // Content to render<br/>    body?: string;    // Content body after parsing frontmatter<br/>    <em class="me">metadata</em>: any;    // Data to be used for satisfying variables in templates<br/>};</span></pre><p id="a842" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">正如你所看到的，这是一个简单的对象，具有可感知的字段。这个函数以输入文件的绝对路径名开始对象，以及它的内容。</p><p id="c4bf" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">如果渲染器支持文件中的元数据，那么<code class="fe mf mg mh mi b">parseMetadata</code>将解析出输入文件中的任何数据。大多数渲染器都支持YAML frontmatter，它的结构是这样的:</p><pre class="kt ku kv kw gu nv mi nw nx aw ny bi"><span id="c221" class="nz mz iu mi b gz oa ob l oc od">---<br/>title: Page title goes here<br/>layout: layout-template-file-name.html.ejs<br/>---</span><span id="7e8f" class="nz mz iu mi b gz oe ob l oc od">Input content body</span></pre><p id="9bf6" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">第一部分位于<code class="fe mf mg mh mi b">---</code>行之间，是头版头条，采用YAML格式。如果需要，您可以使用YAML的全部功能。文件的剩余部分被分配给<code class="fe mf mg mh mi b">body</code>，而frontmatter块的解析形式被分配给<code class="fe mf mg mh mi b">metadata</code>。</p><p id="27ce" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">此时<code class="fe mf mg mh mi b">context</code>应该在所有四个字段中都有数据。</p><p id="6d5e" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated"><code class="fe mf mg mh mi b">copyMetadataProperties</code>用于将附加值复制到元数据对象中。它被定义为:</p><pre class="kt ku kv kw gu nv mi nw nx aw ny bi"><span id="8d27" class="nz mz iu mi b gz oa ob l oc od">function copyMetadataProperties(data, metadata) {<br/>    try {<br/>        for (const prop in metadata) {<br/>            if (!(prop in data)) data[prop] = metadata[prop];<br/>        }<br/>        return data;<br/>    } catch (err) {<br/>        throw new Error(`Failed to copy metadata because ${err}`);<br/>    }<br/>}</span></pre><p id="bbd2" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">因为元数据可以在配置文件中声明，所以代码需要将文件中的元数据与全局元数据合并。</p><p id="5d4a" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">我们还为<code class="fe mf mg mh mi b">context.metadata</code>增加了两个功能，<code class="fe mf mg mh mi b">partial</code>和<code class="fe mf mg mh mi b">partialSync</code>。这些函数支持呈现部分模板，这允许我们创建可以在页面布局之间轻松重用的web内容片段。</p><p id="121b" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated"><code class="fe mf mg mh mi b">render</code>方法将<code class="fe mf mg mh mi b">context</code>中的数据渲染成渲染器支持的输出数据。还有一个<code class="fe mf mg mh mi b">renderSync</code>方法，在执行被同步约束时使用。</p><p id="4585" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">这就完成了第一个渲染阶段。一个典型的例子是，Markdown内容已经呈现为HTML，但是HTML需要嵌入到网站使用的页面布局中。在这种情况下，使用第二渲染阶段。在其他情况下，例如将较小的文件呈现为CSS，则没有元数据，也没有第二个呈现阶段。</p><p id="7534" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">仅当元数据中指定了布局模板时，才执行第二阶段。</p><p id="3b17" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated"><code class="fe mf mg mh mi b">findLayout</code>方法在布局目录中搜索匹配的模板。然后为第二阶段构造RenderingContext对象。</p><p id="8a08" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">在这种情况下，元数据是通过将输入文件中的元数据副本与全局元数据合并而创建的。在该元数据中，<code class="fe mf mg mh mi b">layout</code>字段被删除，因为不再需要它，第一阶段呈现的内容被指定为<code class="fe mf mg mh mi b">content</code>字段。</p><p id="fa96" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">布局模板必须将<code class="fe mf mg mh mi b">content</code>变量插入指定位置。</p><p id="3cf1" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">调用<code class="fe mf mg mh mi b">findRendererPath</code>方法来检索用于布局模板的渲染器。然后代码将模板呈现到<code class="fe mf mg mh mi b">layoutRendered</code>变量中。</p><p id="91e7" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">最后，我们到达函数的底部，在这里，呈现的内容被写入输出文件。这次输出文件名的计算略有不同。Renderer方法<code class="fe mf mg mh mi b">filePath</code>告诉我们用于输入文件名的路径名。</p><h1 id="b465" class="my mz iu bd na nb nc nd ne nf ng nh ni kj nj kk nk km nl kn nm kp nn kq no np bi translated">简单页面布局模板</h1><p id="1a7b" class="pw-post-body-paragraph li lj iu lk b ll nq ke ln lo nr kh lq lr ns lt lu lv nt lx ly lz nu mb mc md in bi translated">在上一节中，我们讨论了在呈现的第二阶段使用页面布局模板。每个网站都会在每个页面上使用相同或相似的页面结构。第二个渲染阶段让我们为此定义一个或多个布局模板。</p><p id="6659" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">这是一个使用Nunjucks模板语法的简单示例:</p><pre class="kt ku kv kw gu nv mi nw nx aw ny bi"><span id="9464" class="nz mz iu mi b gz oa ob l oc od">&lt;html&gt;<br/>    &lt;head&gt;<br/>        &lt;title&gt;{{ title | escape }}&lt;/title&gt;<br/>        {% for style in stylesheets %}<br/>        &lt;link <em class="me">rel</em>="stylesheet" <em class="me">type</em>="text/css" <em class="me">href</em>="{{ style | escape }}"/&gt;<br/>        {% endfor %}<br/>    &lt;/head&gt;<br/>    &lt;body&gt;<br/>        &lt;h1&gt;{{ title | escape }}&lt;/h1&gt;<br/>        &lt;article&gt;<br/>            {{ content }}<br/>        &lt;/article&gt;</span><span id="3d20" class="nz mz iu mi b gz oe ob l oc od">        {% for js in jsbottom %}<br/>        &lt;script <em class="me">src</em>="{{ js | escape }}"&gt;&lt;/script&gt;<br/>        {% endfor %}</span><span id="1d74" class="nz mz iu mi b gz oe ob l oc od">        &lt;script&gt;<br/>            try {<br/>                hljs.initHighlightingOnLoad();<br/>            } catch (err) { }<br/>        &lt;/script&gt;<br/>    &lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="156b" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">记住，在第一呈现阶段中呈现的内容被分配给在第二呈现阶段中提供的元数据的<code class="fe mf mg mh mi b">content</code>变量。在这个模板中，您可以看到<code class="fe mf mg mh mi b">content</code>变量被呈现在<code class="fe mf mg mh mi b">&lt;article&gt;</code>标记的主体中。</p><p id="3b91" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">对于<code class="fe mf mg mh mi b">stylesheets</code>和<code class="fe mf mg mh mi b">jsbottom</code>中的数组，标签引用CSS或JavaScript文件进行渲染。还有一个硬编码的JavaScript片段对HighlightJS很有用。</p><p id="c797" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">另一个版本是:</p><pre class="kt ku kv kw gu nv mi nw nx aw ny bi"><span id="6626" class="nz mz iu mi b gz oa ob l oc od">&lt;html&gt;<br/>    &lt;head&gt;<br/>        &lt;meta <em class="me">charset</em>="utf-8"&gt;<br/>        &lt;meta <em class="me">name</em>="viewport" <em class="me">content</em>="width=device-width, initial-scale=1"&gt;<br/>        &lt;title&gt;{{ title | escape }}&lt;/title&gt;<br/>        {{ partialSync('stylesheets.html.njk', {<br/>            stylesheets: stylesheets<br/>        }) }}<br/>        {{ partialSync('jshead.html.njk', {<br/>            jshead: jshead<br/>        }) }}<br/>    &lt;/head&gt;<br/>    &lt;body&gt;<br/>        &lt;head <em class="me">class</em>="container-fluid"&gt;<br/>        &lt;h1&gt;{{ title | escape }}&lt;/h1&gt;<br/>        &lt;/head&gt;<br/>        &lt;div <em class="me">class</em>="container-md"&gt;<br/>            &lt;div <em class="me">class</em>="row"&gt;<br/>                &lt;article <em class="me">class</em>="col"&gt;<br/>                    {{ content }}<br/>                &lt;/article&gt;<br/>                &lt;section <em class="me">class</em>="col-2"&gt;<br/>                    {{ partialSync('sidebar.html') }}<br/>                    {# {% include 'sidebar.html' %} #}<br/>                &lt;/section&gt;<br/>            &lt;/div&gt;<br/>        &lt;/div&gt;</span><span id="cbdc" class="nz mz iu mi b gz oe ob l oc od">        {% include 'footer.html' %}<br/>        <br/>        {% include 'jsbottom.njk' %}<br/>        {% include 'hljs-init.html' %}<br/>    &lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="3188" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">这个版本将一些HTML片段推送到部分模板。因此，在一个有多个页面布局的复杂网站上，我们可以很容易地在页面之间重用这些片段。<code class="fe mf mg mh mi b">partialSync</code>函数由Renderers包提供，而<code class="fe mf mg mh mi b">include</code>标记由Nunjucks提供。</p><p id="72c9" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">因为这是一个Nunjucks模板，我们确保使用<code class="fe mf mg mh mi b">escape</code>过滤器对内容进行安全编码。</p><p id="7ef8" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">记住GuideCMS是为Renderers包的文档网站创建的。该页面布局模板使用Bootstrap v5类来格式化一个移动响应多列布局，带有一个好看的导航侧边栏。实现需要安装引导代码，将URL添加到<code class="fe mf mg mh mi b">stylesheets</code>和<code class="fe mf mg mh mi b">jsbottom</code>数组，以及对布局模板做更多的工作。</p><h1 id="f7bb" class="my mz iu bd na nb nc nd ne nf ng nh ni kj nj kk nk km nl kn nm kp nn kq no np bi translated">写作内容</h1><p id="0b57" class="pw-post-body-paragraph li lj iu lk b ll nq ke ln lo nr kh lq lr ns lt lu lv nt lx ly lz nu mb mc md in bi translated">我们已经看到了GuideCMS是如何工作的，现在让我们开始使用它。</p><p id="fbaf" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">请记住，在<a class="ae mx" href="https://github.com/akashacms/rendering-engines" rel="noopener ugc nofollow" target="_blank"/><code class="fe mf mg mh mi b"><a class="ae mx" href="https://github.com/akashacms/rendering-engines" rel="noopener ugc nofollow" target="_blank">@akashacms/renderers</a></code><a class="ae mx" href="https://github.com/akashacms/rendering-engines" rel="noopener ugc nofollow" target="_blank">存储库</a>中，<code class="fe mf mg mh mi b">guide</code>目录是一个使用GuideCMS构建的网站的工作示例。就此而言，它可能是唯一一个使用GuideCMS构建的网站。</p><p id="1542" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">GuideCMS的<em class="me">架构</em>(如果允许我们使用这样一个庄严的词的话)是有三套目录:<em class="me">文档</em>、<em class="me">布局</em>和<em class="me">局部</em>。第一个目录包含文档，即呈现在网站页面上的信息。第二个包含页面布局模板，最后一个包含部分模板。该体系结构允许每种类型的目录有多个实例。</p><p id="8b34" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">编写内容的第一步是创建一个或多个页面布局模板。您可能会发现创建一些部分模板对于简洁的布局模板以及在布局模板之间共享代码非常有用。创建好模板后，是时候写一些文档了。</p><p id="5449" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated"><em class="me">文档</em>目录对应于要在渲染输出目录中创建的文件。记住,<code class="fe mf mg mh mi b">renderTo</code>路径是用这行代码创建的:</p><pre class="kt ku kv kw gu nv mi nw nx aw ny bi"><span id="94ca" class="nz mz iu mi b gz oa ob l oc od">const renderTo = path.join(renderedOutput, renderer.filePath(info.vpath));</span></pre><p id="534d" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">因此，文件<code class="fe mf mg mh mi b">documents/history/romania/vlad-tsepes.html.md</code>将呈现给<code class="fe mf mg mh mi b">out/history/romania/vlad-tsepes.html</code>。</p><p id="0af6" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">这里有一个小问题，即<em class="me">文档</em>目录可以安装在虚拟目录层次结构中的位置。示例配置文件显示了这样一个例子，因为我们需要在网站上包含引导程序发行版和我们的渲染文档。</p><pre class="kt ku kv kw gu nv mi nw nx aw ny bi"><span id="3d56" class="nz mz iu mi b gz oa ob l oc od"><em class="me">documents:</em><br/>    - <em class="me">mounted:</em> documents<br/>      <em class="me">mountPoint:</em> /<br/>    - <em class="me">mounted:</em> node_modules/bootstrap/dist<br/>      <em class="me">mountPoint:</em> /vendor/bootstrap</span></pre><p id="bc58" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated"><code class="fe mf mg mh mi b">documents</code>目录的渲染内容出现在渲染输出目录的根目录下。对于引导包来说，<code class="fe mf mg mh mi b">dist</code>目录包含了部署在网站上的CSS和JavaScript文件，这些文件出现在<code class="fe mf mg mh mi b">/vendor/bootstrap</code>目录中。</p><p id="f588" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated"><code class="fe mf mg mh mi b">render</code>功能只是复制不需要渲染的文件。引导程序分发目录仅包含<code class="fe mf mg mh mi b">.css</code>和<code class="fe mf mg mh mi b">.js</code>文件，这些文件不可渲染，因此被复制到所需位置。</p><p id="97ea" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated"><code class="fe mf mg mh mi b">documents</code>目录倾向于包含<code class="fe mf mg mh mi b">.html.md</code> (Markdown)、<code class="fe mf mg mh mi b">.html.adoc</code>(asciidor)或<code class="fe mf mg mh mi b">.css.less</code> (LESS)文件，每个文件都必须被渲染。</p><p id="f474" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">降价内容文件的格式是:</p><pre class="kt ku kv kw gu nv mi nw nx aw ny bi"><span id="aa2c" class="nz mz iu mi b gz oa ob l oc od">---<br/>title: Metadata test for Markdown<br/>layout: foo.html.ejs<br/>hello: world<br/>---</span><span id="d0be" class="nz mz iu mi b gz oe ob l oc od"># This is an H1 header</span><span id="1923" class="nz mz iu mi b gz oe ob l oc od">Hello, World!</span></pre><p id="e810" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">第一部分在<code class="fe mf mg mh mi b">---</code>行之间，是前面的内容，包含前面描述的元数据。在这种情况下，有一个<code class="fe mf mg mh mi b">title</code>、<code class="fe mf mg mh mi b">layout</code>和一个名为<code class="fe mf mg mh mi b">hello</code>的额外值。您的应用程序可以在frontmatter中使用它想要的任何数据。</p><p id="1668" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">参考我们之前讨论的代码，呈现的结果将如下所示:</p><pre class="kt ku kv kw gu nv mi nw nx aw ny bi"><span id="f352" class="nz mz iu mi b gz oa ob l oc od">&lt;h1&gt;THis is an H1 header&lt;/h1&gt;<br/>&lt;p&gt;Hello, World!&lt;/p&gt;</span></pre><p id="83b6" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">并且，会有元数据对象。然后这两个将被转换成<code class="fe mf mg mh mi b">layoutContext</code>，并使用<code class="fe mf mg mh mi b">foo.html.ejs</code>模板呈现内容。</p><h1 id="7991" class="my mz iu bd na nb nc nd ne nf ng nh ni kj nj kk nk km nl kn nm kp nn kq no np bi translated">以动态观察模式和批处理模式运行GuideCMS</h1><p id="5274" class="pw-post-body-paragraph li lj iu lk b ll nq ke ln lo nr kh lq lr ns lt lu lv nt lx ly lz nu mb mc md in bi translated">GuideCMS支持两种操作模式:<em class="me">批量</em>和<em class="me">动态</em>。在后者中，它将响应任何文件更改，并重新呈现已更改的文件。在批处理模式下，它将渲染所有文件并立即退出。</p><p id="67f0" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">模式由以下配置文件值决定:</p><pre class="kt ku kv kw gu nv mi nw nx aw ny bi"><span id="ee8c" class="nz mz iu mi b gz oa ob l oc od"><em class="me">batchmode:</em> false</span></pre><p id="0b3d" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">将其更改为<code class="fe mf mg mh mi b">true</code>以获得批处理模式。</p><p id="1197" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">在指南目录中，有一个<code class="fe mf mg mh mi b">package.json</code>包含这个:</p><pre class="kt ku kv kw gu nv mi nw nx aw ny bi"><span id="c77d" class="nz mz iu mi b gz oa ob l oc od"><em class="me">"scripts"</em>: {<br/>    <em class="me">"watch"</em>: "npm-run-all --parallel watcher preview",<br/>    <em class="me">"preview"</em>: "live-server out",<br/>    <em class="me">"watcher"</em>: "node ../guidecms/guidecms.mjs cfg.yml",<br/>    <em class="me">"build"</em>: "node ../guidecms/guidecms.mjs cfg-batch.yml",<br/>    <em class="me">"publish"</em>: "npx gh-pages -d out"<br/>},</span></pre><p id="f71c" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated"><code class="fe mf mg mh mi b">watch</code>脚本启动两个并行运行的程序。<code class="fe mf mg mh mi b">preview</code>脚本监视呈现的输出目录，注意变化，并动态地重新加载任何打开页面的浏览器窗口。<code class="fe mf mg mh mi b">watcher</code>脚本以动态模式启动GuideCMS，自动重建任何更改的页面。当页面发生变化时，<code class="fe mf mg mh mi b">live-server</code>会注意到变化并自动重新加载网页。</p><p id="8447" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated"><code class="fe mf mg mh mi b">build</code>脚本以批处理方式构建站点，并在所有文件构建完成后退出。</p><p id="0a73" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated"><code class="fe mf mg mh mi b">publish</code>脚本处理将构建的站点发布到GitHub页面。</p><p id="5aa6" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">另一种发布方法是像这样使用<code class="fe mf mg mh mi b">rsync</code>:</p><pre class="kt ku kv kw gu nv mi nw nx aw ny bi"><span id="ee61" class="nz mz iu mi b gz oa ob l oc od"><em class="me">"deploy"</em>: "cd out &amp;&amp; rsync --archive --delete --verbose ./ user@example.com:path-name/",</span></pre><p id="653d" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">因为它生成静态的HTML/CSS/JS网站，GuideCMS(和AkashaCMS)支持部署到简单的web服务器。</p><p id="f58c" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">这些脚本使得使用GuideCMS编写内容变得非常容易。这个<code class="fe mf mg mh mi b">watch</code>脚本在连接到实时预览服务器的站点上打开一个浏览器标签。在类似Visual Studio代码的编辑器中，您可以编写Markdown内容。每次保存更改时，浏览器选项卡会快速重新加载。它几乎与WYSIWYG编辑器一样好，但是您正在编写Markdown，结果可以很容易地存储在Git存储库中。</p><h1 id="1d71" class="my mz iu bd na nb nc nd ne nf ng nh ni kj nj kk nk km nl kn nm kp nn kq no np bi translated">摘要</h1><p id="4235" class="pw-post-body-paragraph li lj iu lk b ll nq ke ln lo nr kh lq lr ns lt lu lv nt lx ly lz nu mb mc md in bi translated">GuideCMS旨在演示如何使用这些软件包。这是一个概念证明，人们可以很容易地实现一个相对强大的静态网站生成器。</p><p id="1b25" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">当然，GuideCMS缺少了很多东西，因为只有这么多东西可以塞进几百行代码中。例如，AkashaCMS构建在相同的两个组件之上，并具有许多其他功能。</p><p id="de3c" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated"><code class="fe mf mg mh mi b">@akashacms/stacked-dirs</code>包提供了文件系统中文件变化的动态事件，同时允许将相当复杂的重叠目录层次结构装入虚拟文件系统。<code class="fe mf mg mh mi b">@akashacms/renderers</code>包封装了几个有用的模板引擎和其他web开发工具。很容易创建渲染器实现来支持其他引擎或工具。很容易将这些包集成到一个应用程序中，并添加其他逻辑来适应您设想的任何应用程序。</p></div><div class="ab cl of og hy oh" role="separator"><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok"/></div><div class="in io ip iq ir"><p id="f56f" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">原载于<a class="ae mx" href="https://akashacms.com/news/2022/09/renderers-package.html" rel="noopener ugc nofollow" target="_blank"><em class="me">akashacms.com</em></a></p></div><div class="ab cl of og hy oh" role="separator"><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok"/></div><div class="in io ip iq ir"><h2 id="f2c2" class="nz mz iu bd na om on dn ne oo op dp ni lr oq or nk lv os ot nm lz ou ov no ja bi translated">关于作者</h2><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div class="gi gj ow"><img src="../Images/fb1d9bee83141a0d32e84d6660d1e35a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*uewJRZW9zketSxZB.jpg"/></div></figure><p id="a07d" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated"><a class="ae mx" href="https://davidherron.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="lk je">大卫·赫伦</strong> </a> <strong class="lk je"> </strong>:大卫·赫伦是一名作家和软件工程师，专注于技术的明智使用。他对太阳能、风能和电动汽车等清洁能源技术特别感兴趣。David在硅谷从事了近30年的软件工作，从电子邮件系统到视频流，再到Java编程语言，他已经出版了几本关于Node.js编程和电动汽车的书籍。</p></div></div>    
</body>
</html>