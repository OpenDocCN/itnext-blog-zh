<html>
<head>
<title>How To Debug Node JS Inside Docker?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Docker内部调试节点JS？</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-debug-node-js-inside-docker-8f9be8abdbb4?source=collection_archive---------1-----------------------#2022-05-04">https://itnext.io/how-to-debug-node-js-inside-docker-8f9be8abdbb4?source=collection_archive---------1-----------------------#2022-05-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4e6d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">调试docker容器</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/e47c1a6c10020f287cd25f3e8f88bf8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/1*Wqu1OOwZW3DwA8XHI28Qqw.jpeg"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">在docker中调试node.js</figcaption></figure><h1 id="b661" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">什么是调试器？</h1><p id="18ae" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">对于任何开发人员来说，调试器都是最好的朋友。用调试器很容易发现软件中的错误。</p><p id="78a6" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">可以添加一个断点来暂停执行。其次，还可以在断点处添加逻辑来暂停执行。例如，考虑一个有1000次迭代的<code class="fe mn mo mp mq b">for</code>循环。当迭代计数达到100以上时，执行应该停止。为此，在<code class="fe mn mo mp mq b">for</code>循环上放置一个断点。接下来，添加当迭代次数超过100时停止执行的逻辑。</p><p id="6b85" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">除了暂停程序，调试器还显示内存分配。例如，暂停执行将显示在任何给定点消耗的内存。</p><h1 id="f096" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">什么是远程调试器？</h1><p id="dd37" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">调试通常在本地主机上完成。远程做就叫远程调试:)。也就是说，如果你调试运行在远程主机上的软件，这叫做远程调试。这是有帮助的，原因有很多。</p><p id="8847" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">首先，人们可以在本地调试软件。考虑一个软件在云上的场景。它可以部署在开发、UAT或生产环境中。现在问题发生在云上，而不是本地主机上。在这种情况下，连接到云并将调试器附加到进程会非常有帮助。人们可以一行一行地执行软件来评估问题并修复它。</p><p id="54b6" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">其次，当软件在容器中运行时，远程调试也很有用。假设一个项目正在Docker内部运行。人们不能直接运行项目并通过调试器连接到它。相反，docker容器应该公开它的容器端口。其次，远程调试器需要配置来连接docker容器内部的项目。</p><p id="7b51" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">Docker有助于创建可移植的容器，这些容器可以快速、轻松地部署在各种机器上。这些容器可以在您的Windows、Mac和Linux上本地运行。此外，像AWS或Azure这样的主流云系统也支持开箱即用。如果你想学习更多的Docker基础知识，并且需要Docker CLI的备忘单，<a class="ae mr" href="https://betterprogramming.pub/a-beginners-cheat-sheet-for-docker-f5024fd6c17f" rel="noopener ugc nofollow" target="_blank">这里的</a>是一篇关于它的介绍性文章。</p><p id="78bb" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">在本文中，我们将设置一个NodeJS项目在docker容器中运行。我们还将为项目设置一个远程调试。</p><p id="fd95" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">如果你喜欢这篇文章，请<a class="ae mr" href="https://arjav-dave.medium.com/" rel="noopener">关注我</a>，并在我的个人资料中查看其他如此精彩的文章。</p><h1 id="455d" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">设置项目</h1><h1 id="d7be" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">先决条件</h1><p id="169d" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">在我们继续之前，系统应该已经安装了docker桌面和VS代码。除此之外，没有其他要求。</p><p id="3e68" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">对于那些仓促的，我已经把源代码作为一个资源库。你可以点击查看<a class="ae mr" href="https://github.com/shenanigan/docker-node-debug" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="2ef2" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">创建项目文件</h1><p id="e680" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">我们将创建一个非常简单的express Node JS项目。在打开一个特定的URL时，它将简单地返回一个静态JSON字符串。为此，我们将创建一个名为<code class="fe mn mo mp mq b">server.js</code>的文件，这是我们项目的入口点。</p><p id="4fa0" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">用以下内容创建一个<code class="fe mn mo mp mq b">server.js</code>文件:</p><pre class="kj kk kl km gt ms mq mt mu aw mv bi"><span id="a365" class="mw kv it mq b gy mx my l mz na">const server = require("express")();<br/>server.listen(3000, async () =&gt; { });<br/>server.get("/node-app", async (_, response) =&gt; {<br/>    response.json({ "node": "app" });<br/>});</span></pre><p id="a6fa" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><code class="fe mn mo mp mq b">server.js</code>文件说明<code class="fe mn mo mp mq b">display {“node”: “app”}</code>在浏览器中打开<code class="fe mn mo mp mq b"><a class="ae mr" href="http://localhost:3000/node-app" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/node-app</a></code>网址。</p><p id="51be" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">其次，我们需要一个<code class="fe mn mo mp mq b">package.json</code>文件来配置项目并添加依赖项。为此，创建一个包含以下内容的<code class="fe mn mo mp mq b">package.json</code>文件:</p><pre class="kj kk kl km gt ms mq mt mu aw mv bi"><span id="b08d" class="mw kv it mq b gy mx my l mz na">{<br/>    "name": "node-app",<br/>    "dependencies": {<br/>        "express": "^4.17.1"<br/>    }<br/>}</span></pre><p id="aa31" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">运行<code class="fe mn mo mp mq b">npm install </code>命令在本地安装依赖项。这将在项目目录中创建一个<code class="fe mn mo mp mq b">node_modules</code>。</p><p id="d51f" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">即使我们将在一个容器中运行项目，也需要安装依赖项。这是必需的，因为我们将把当前的项目目录映射到一个容器项目目录。下面解释了如何这样做:</p><h1 id="7f02" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">作为Docker容器运行</h1><p id="c9a9" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">需要一个docker文件来作为docker容器运行项目。创建一个包含以下内容的Dockerfile文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="2932" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">这里，项目被设置为作为一个简单的节点服务器运行，不允许任何断点。容器将在容器内的节点目录外运行项目。<a class="ae mr" href="https://nodemon.io/" rel="noopener ugc nofollow" target="_blank"> nodemon </a>全局安装在容器中。需要它来观察目录中的任何文件变化。下面详细解释。</p><p id="bc8f" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">只有在部署到生产时才需要<code class="fe mn mo mp mq b">RUN npm install</code>命令。我们将使用Docker Compose将容器的<code class="fe mn mo mp mq b">/node</code>目录映射到本地主机上的当前项目目录(下一节)。但是当应用程序部署在容器上时，它需要自己安装依赖项。</p><h1 id="fcb9" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">Docker忽略</h1><p id="26c1" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">Docker ignore特性与git ignore非常相似。<code class="fe mn mo mp mq b">.gitignore</code>不跟踪其中提到的文件或文件夹。同样，我们也不希望在容器中复制不必要的文件，这样会占用空间。</p><p id="c108" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">在我们的例子中，我们不想将<code class="fe mn mo mp mq b">node_modules</code>文件夹复制到容器中。为此，在项目目录中创建一个包含以下内容的<code class="fe mn mo mp mq b">.dockerignore</code>文件:</p><pre class="kj kk kl km gt ms mq mt mu aw mv bi"><span id="2268" class="mw kv it mq b gy mx my l mz na">node_modules/</span></pre><h1 id="8a34" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">Docker撰写</h1><p id="ee72" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">Docker Compose是用一个命令构建和运行Docker容器的非常有用的方法。同时运行多个容器也很有帮助。这是我们使用docker compose而不是plain docker的原因之一。要了解更多关于docker compose和如何运行多个容器的信息，请访问文章<a class="ae mr" href="https://betterprogramming.pub/run-multiple-containers-with-docker-compose-9297957f7a3c" rel="noopener ugc nofollow" target="_blank">使用Docker Compose运行多个容器</a>。</p><p id="e2f5" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">现在，让我们创建一个<code class="fe mn mo mp mq b">docker-compose.yml</code>文件来添加更多的配置。创建docker-compose.yml文件后，将以下内容添加到该文件中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">docker-compose.yml</figcaption></figure><p id="3a39" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">下面逐点解释<code class="fe mn mo mp mq b">docker-compose.yml</code>文件。</p><ol class=""><li id="d0af" class="nd ne it lo b lp mi ls mj lv nf lz ng md nh mh ni nj nk nl bi translated">指向我们当前构建项目的目录。</li><li id="fc2d" class="nd ne it lo b lp nm ls nn lv no lz np md nq mh ni nj nk nl bi translated">使用nodemon运行项目，因为如果本地目录中有任何更改，我们希望使用更改在docker中重新启动项目。Nodemon 是一个实用程序，它将监视源代码中的任何变化，并自动重启服务器。</li><li id="e8f6" class="nd ne it lo b lp nm ls nn lv no lz np md nq mh ni nj nk nl bi translated">使用<a class="ae mr" href="https://docs.docker.com/storage/volumes/" rel="noopener ugc nofollow" target="_blank">卷</a>将我们当前的目录绑定到<code class="fe mn mo mp mq b">/node</code>目录。</li><li id="83e5" class="nd ne it lo b lp nm ls nn lv no lz np md nq mh ni nj nk nl bi translated">除了公开和绑定服务器的3000端口之外，还要公开9229端口以附加调试器。</li></ol><blockquote class="nr ns nt"><p id="e504" class="lm ln nu lo b lp mi ju lr ls mj jx lu nv mk lx ly nw ml mb mc nx mm mf mg mh im bi translated">U <!-- --> se以上docker-compose.yml文件仅供调试使用。</p></blockquote><p id="ed44" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">上面的<code class="fe mn mo mp mq b">docker-compose.yml</code>暴露了调试口。此外，它还监视容器内的任何文件更改(这是不会发生的)。最后，它将容器的体积映射到项目目录。</p><p id="76b1" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">对于生产，创建一个包含以下内容的新文件<code class="fe mn mo mp mq b">docker-compose-prod.yml</code>:</p><pre class="kj kk kl km gt ms mq mt mu aw mv bi"><span id="fe0a" class="mw kv it mq b gy mx my l mz na">version: '3.4'<br/>services:<br/>  node-app:<br/>    build: .<br/>    command: node /node/server.js 3000<br/>    ports:<br/>      - "3000:3000"</span></pre><p id="639d" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">它只是运行项目并公开<code class="fe mn mo mp mq b">3000</code>端口。我们使用多个docker合成文件来管理不同的环境。查看下面的运行项目部分，了解如何基于不同的docker合成文件运行项目。</p><p id="7dce" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">在运行项目之前，我们仍然需要配置调试器以连接到容器。</p><h1 id="9713" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">配置远程调试器</h1><p id="e308" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">首先，检查您的项目中是否创建了<code class="fe mn mo mp mq b">launch.json</code>文件。<code class="fe mn mo mp mq b">launch.json</code>定义了我们可以运行调试的不同类型的配置。如果没有创建，请访问VS代码左侧的运行和调试选项卡，如下图所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nz oa di ob bf oc"><div class="gh gi ny"><img src="../Images/f4f55ec68e7968236defb9b83b11cc5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*PYQh2E_SpeRCGGEk.png"/></div></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">运行和调试选项卡</figcaption></figure><p id="e03b" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">点击文本，创建一个<code class="fe mn mo mp mq b">launch.json</code>文件。在您继续之前，它会询问应用程序的类型。选择Node.js。它将在您的项目中创建一个新的<code class="fe mn mo mp mq b">launch.json</code>文件，并添加一个默认的Node.js配置。</p><p id="8581" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">因为我们不打算在本地运行节点应用程序，所以继续删除那个配置。相反，用以下内容替换<code class="fe mn mo mp mq b">launch.json</code>文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="5320" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">添加的配置非常简单明了。基本上，我们要求调试器连接到端口号为<code class="fe mn mo mp mq b">9229</code>的远程主机。我们还要求调试器在与主机断开连接时重新启动。默认情况下，调试器尝试在<code class="fe mn mo mp mq b"><a class="ae mr" href="http://localhost:9229/" rel="noopener ugc nofollow" target="_blank">http://localhost:9229/</a></code>连接。但是项目托管在docker的<code class="fe mn mo mp mq b">/node</code>目录中。为了映射<code class="fe mn mo mp mq b">/node</code>，使用了<code class="fe mn mo mp mq b">remoteRoot</code>属性。</p><h1 id="ee77" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">运行项目</h1><p id="e915" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">差不多就是这样！现在，如果您运行<code class="fe mn mo mp mq b">docker compose up</code>，您的项目将开始运行。第一次运行时，它将下载node slim SDK的一些层，然后在docker容器中安装nodemon。但是，后续运行会快得多。运行<code class="fe mn mo mp mq b">docker compose up</code>将在您的终端中显示以下输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nz oa di ob bf oc"><div class="gh gi od"><img src="../Images/4ee9ceaee6c4c0b3f3aa216ff8e30f84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Ku-qs2fVGA4pIE9E.png"/></div></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">码头工人排版</figcaption></figure><p id="192c" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">为了附加调试器，从运行和调试选项卡运行Docker:附加到节点任务。调试器现在将附加到docker容器的<code class="fe mn mo mp mq b">/node</code>目录中。接下来，在您的<code class="fe mn mo mp mq b">server.js</code>文件的第4行放置一个断点，即<code class="fe mn mo mp mq b">response.json({ “super”: “app1” });</code>。最后，打开你的浏览器，点击<code class="fe mn mo mp mq b"><a class="ae mr" href="http://localhost:3000." rel="noopener ugc nofollow" target="_blank">http://localhost:3000</a></code> <a class="ae mr" href="http://localhost:3000." rel="noopener ugc nofollow" target="_blank">。</a>断点将被命中，执行将停止。</p><p id="ee0f" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">对于生产，我们需要使用1文件。为此，我们需要在docker命令中提到文件名。执行以下命令，像在生产环境中一样运行项目:</p><pre class="kj kk kl km gt ms mq mt mu aw mv bi"><span id="5422" class="mw kv it mq b gy mx my l mz na">docker compose -f docker-compose-prod.yml up</span></pre><p id="3a2f" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">使用上面的命令，调试器不能附加到容器，因为我们没有公开任何调试点。</p><h1 id="1c44" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">源代码</h1><p id="2c07" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">这里是我们创建的项目的最终源代码的链接。</p><h1 id="6863" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">结论</h1><p id="ac9e" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">调试是开发中最好的事情之一。当我们能够远程调试时，这是最棒的。远程调试使我们不仅可以连接到运行在云上的代码，还可以连接到本地运行的docker容器。</p><p id="319b" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">我希望你喜欢这篇文章。请随意查看我的其他文章:</p><ul class=""><li id="7337" class="nd ne it lo b lp mi ls mj lv nf lz ng md nh mh oe nj nk nl bi translated"><a class="ae mr" href="https://betterprogramming.pub/a-beginners-cheat-sheet-for-docker-f5024fd6c17f" rel="noopener ugc nofollow" target="_blank"> Docker:简介和备忘单</a></li><li id="41f0" class="nd ne it lo b lp nm ls nn lv no lz np md nq mh oe nj nk nl bi translated"><a class="ae mr" href="https://betterprogramming.pub/run-multiple-containers-with-docker-compose-9297957f7a3c" rel="noopener ugc nofollow" target="_blank">用Docker编写运行多个容器</a></li><li id="32cd" class="nd ne it lo b lp nm ls nn lv no lz np md nq mh oe nj nk nl bi translated"><a class="ae mr" href="https://www.daveops.co.in/post/how-to-setup-ci-cd-pipelines-for-android-with-azure-devops" rel="noopener ugc nofollow" target="_blank">使用Azure管道为Android设置CI/CD</a></li></ul></div></div>    
</body>
</html>