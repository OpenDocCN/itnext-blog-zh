<html>
<head>
<title>Stop re-solving the problems of fetching and managing your API data in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">停止在React中重新解决获取和管理API数据的问题</h1>
<blockquote>原文：<a href="https://itnext.io/stop-re-solving-the-problems-of-fetching-and-managing-your-api-data-in-react-44e425a92ff8?source=collection_archive---------1-----------------------#2018-08-31">https://itnext.io/stop-re-solving-the-problems-of-fetching-and-managing-your-api-data-in-react-44e425a92ff8?source=collection_archive---------1-----------------------#2018-08-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="45fc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请允许我向您介绍<a class="ae kl" href="https://github.com/DigitalGlobe/jetset/" rel="noopener ugc nofollow" target="_blank"> Jetset </a>，这是一个库，它承诺将您所有的前端RESTful API逻辑抽象成简单、直观和可重用的模块。</p></div><div class="ab cl km kn hu ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ij ik il im in"><h1 id="2408" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">问题</h1><ol class=""><li id="bdad" class="lr ls iq jp b jq lt ju lu jy lv kc lw kg lx kk ly lz ma mb bi translated">已经<a class="ae kl" href="https://loopback.io/" rel="noopener ugc nofollow" target="_blank">做了一些</a> <a class="ae kl" href="http://jsonapi.org/" rel="noopener ugc nofollow" target="_blank">工作</a>来标准化后端的API，但是前端开发人员继续解决并再次解决获取数据、缓存数据或以其他方式最小化重新获取以及管理相关UI状态的问题。</li></ol><ul class=""><li id="4c0f" class="lr ls iq jp b jq jr ju jv jy mc kc md kg me kk mf lz ma mb bi translated">为了从API请求数据，你使用superagent、fetch、同构-fetch、XMLHttpRequest、oboe和/或这些之上的抽象吗？</li><li id="bb81" class="lr ls iq jp b jq mg ju mh jy mi kc mj kg mk kk mf lz ma mb bi translated">对于API数据缓存和状态管理，你使用Redux，React组件状态，Flux，其他？</li><li id="d04d" class="lr ls iq jp b jq mg ju mh jy mi kc mj kg mk kk mf lz ma mb bi translated">你会乐观地更新你的UI吗？如果是，您使用什么模式来恢复数据和更新UI？</li></ul><p id="5e25" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2.GraphQL + Relay和类似的解决方案最终显示了巨大的发展前景，但是a)配置可能非常复杂且不直观，b)不是每个人现在或很快都会转换现有的API，以及c)许多API需要支持许多不同类型的客户端，其中一些可能不太容易与GraphQL一起工作。在未来很长一段时间内，REST将是实现API的常用方法。</p><h1 id="8ded" class="kt ku iq bd kv kw ml ky kz la mm lc ld le mn lg lh li mo lk ll lm mp lo lp lq bi translated">一个解决方案</h1><figure class="mr ms mt mu gt mv gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi mq"><img src="../Images/3db266f8c124b7d8f3a9eff33f0e92e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3-pA30ixjubKo22EHf1yhQ.png"/></div></div></figure><p id="e8ff" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用<a class="ae kl" href="https://github.com/DigitalGlobe/jetset/" rel="noopener ugc nofollow" target="_blank">喷射装置</a>。它抽象出了所有的获取、缓存和状态管理细节。它以安全和优化的方式将API数据直接注入到组件中，这样您就可以专注于构建视图。</p><p id="6ee7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">几乎不需要任何配置，就可以获得给定资源的<code class="fe nc nd ne nf b">create(), list(), get(), update(), and delete()</code>,作为道具直接传递给组件。例如:</p><pre class="mr ms mt mu gt ng nf nh ni aw nj bi"><span id="b02f" class="nk ku iq nf b gy nl nm l nn no">import { apiDecorator } from 'jetset';</span><span id="efd5" class="nk ku iq nf b gy np nm l nn no">const Api = apiDecorator({<br/>  url: 'http://domain.com/api',<br/>  users: '/users'<br/>})</span><span id="bd2d" class="nk ku iq nf b gy np nm l nn no">const MyComponent = Api( props =&gt; {<br/>  const users = props.users.list();<br/>  return (<br/>    &lt;div&gt;<br/>      { users.data.map(({ data: user }) =&gt; &lt;div&gt;{ user.fullName }&lt;/div&gt; )}<br/>    &lt;/div&gt;<br/>  )<br/>})</span></pre><p id="0c37" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里我们有一个高阶组件，它将您的url和资源转换成props，这些props公开了获取、缓存和呈现数据的方法。</p><p id="4681" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意，我们在渲染时调用了<code class="fe nc nd ne nf b">list()</code> <strong class="jp ir">。第一次被调用时，它实际上触发了一次提取并缓存了数据，这样在随后的渲染中，它只是从缓存中读取数据，而不是再次提取。您不需要自己设置获取或触发操作或管理任何状态。尽管如果你需要的话，有很多方法可以连接到获取生命周期的不同阶段。更多信息见下文和<a class="ae kl" href="https://github.com/DigitalGlobe/jetset/blob/master/docs/index.md" rel="noopener ugc nofollow" target="_blank">文档</a>。</strong></p><p id="0f56" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">默认情况下，所有CRUD操作都捆绑在一起:</p><pre class="mr ms mt mu gt ng nf nh ni aw nj bi"><span id="f69f" class="nk ku iq nf b gy nl nm l nn no">export default Api(({ users }) =&gt;<br/>  &lt;div&gt;<br/>    { users.list().data.map( user =&gt; (<br/>      &lt;div&gt;<br/>        &lt;span&gt;{ user.data.name }&lt;/span&gt;<br/><br/>        &lt;button onClick={() =&gt; user.update({ name: 'Pat' }) }&gt;Rename to Pat&lt;/button&gt;<br/><br/>        &lt;button onClick={ user.delete }&gt;Delete&lt;/button&gt;<br/><br/>        &lt;button onClick={() =&gt; users.get( user.data.id ) }&gt;Get detail&lt;/button&gt;<br/>      &lt;/div&gt;<br/>    ))}<br/><br/>    &lt;button onClick={() =&gt; users.create({ name: 'Chris' }) }&gt;Create user named Chris&lt;/button&gt;<br/>  &lt;/div&gt;<br/>)</span></pre><p id="2abe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">指示提取状态的关键帧助手:</p><pre class="mr ms mt mu gt ng nf nh ni aw nj bi"><span id="4c5e" class="nk ku iq nf b gy nl nm l nn no">const users = props.users.list();</span><span id="2552" class="nk ku iq nf b gy np nm l nn no">users.isPending ?<br/>  &lt;span&gt;Loading...&lt;/span&gt; :</span><span id="5867" class="nk ku iq nf b gy np nm l nn no">users.error ?<br/>  &lt;span&gt;Error: {list.error.message}&lt;/span&gt; :</span><span id="9cb9" class="nk ku iq nf b gy np nm l nn no">&lt;div&gt;<br/>  { users.data.map( user =&gt; &lt;div&gt;{ user.data.name }&lt;/div&gt; ) }<br/>&lt;/div&gt;</span></pre><p id="df7e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">除了标准的创建、列表、获取、删除之外，定制您的路线:</p><pre class="mr ms mt mu gt ng nf nh ni aw nj bi"><span id="d339" class="nk ku iq nf b gy nl nm l nn no">const routes = {<br/>  default: '/users',<br/>  onError: error =&gt; localStorage.removeItem('some_token')<br/>  getUserAlbums: id =&gt; ({ method: 'get', route: `/users/${id}/albums`, usesCache: true })<br/>}<br/><br/>&lt;Api ... users={{ routes }}&gt;</span></pre><p id="a849" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">还有更多！更多信息见<a class="ae kl" href="https://github.com/DigitalGlobe/jetset" rel="noopener ugc nofollow" target="_blank">https://github.com/DigitalGlobe/jetset</a>及其<a class="ae kl" href="https://github.com/DigitalGlobe/jetset/blob/master/docs/index.md" rel="noopener ugc nofollow" target="_blank">更详细文件</a>。</p></div></div>    
</body>
</html>