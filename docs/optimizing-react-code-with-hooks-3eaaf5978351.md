# React 挂钩:优化性能

> 原文：<https://itnext.io/optimizing-react-code-with-hooks-3eaaf5978351?source=collection_archive---------1----------------------->

![](img/425e6319924037072c7abc4c6d77ea98.png)

如果你已经使用 React 钩子有一段时间了，你可能已经爱上它们了。几乎所有的开发人员现在都在使用它们，并尽可能地将基于类的组件变成功能组件。这很好，也是 React 团队所提倡的。功能性组件很容易理解，并且在您的代码库中需要的锅炉板代码要少得多。

如果您已经使用 React 有一段时间了，那么您会很清楚这样一个事实，即在生产中，开发人员会尽可能地优化他们的组件。组件不应该被不必要的渲染，所以在基于类的组件中，生命周期方法，比如“shouldComponentUpdate()”被用来检查状态的变化。如果状态发生了变化，那么 React 会重新渲染组件，否则就保持不变。

# React 中重新渲染的工作方式

在 React 中，当父组件重新呈现时，其所有子组件都会重新呈现(如果没有为子组件实现优化)。可以通过多种方式触发组件重新渲染，其中几种方式是:

1.  组件状态的变化
2.  组件属性的变化

现在，当你所有的组件都是功能组件时，会发生什么呢？记住，这里没有生命周期方法或钩子来帮助你。还是有？

![](img/06c733ced941dbe9e23d8390d82d88d4.png)

让我们看一个具有某种状态的功能组件的例子，由于其状态的改变而重新呈现。

这个功能组件有一些`state`(计数器)，点击一个按钮，用户就可以改变它。还要注意`formatCounter()`方法，我们很快就会谈到它。

让我们一步一步来。

当用户点击按钮时，我们调用`setCounter()`方法，该方法将使用新的`counter`状态重新呈现组件。在功能组件中，重新渲染意味着整个功能将再次运行。

1.  因此，从顶部开始运行`useState()`方法。由于钩子的固有特性，这将返回更新的`counter`和缓存的`setCounter()`方法。
2.  接下来，`formatCounter()`功能将被添加到内存中。
3.  最后，返回一些 JSX。但是在`<button/>`上，有一个`onClick()`处理程序，是一个箭头函数。这个函数也将被添加到内存中。

每次组件重新渲染时，所有这些步骤都会发生。作为一个好的开发者，你不能允许这样。您需要以某种方式缓存`formatCounter()`和`onClick()`方法，这样它们就不会在每次重新渲染时被添加到内存中。

# 天真的解决方案

![](img/8bebb69f565711c2ff9140966f12b1db.png)

因此，首先想到的可能是将`formatCounter()`和`onClick()`处理程序移出组件。这样，这些函数只需创建一次。

让我们现在做那件事。

`formatCounter()`函数很容易提取。它不依赖于任何特定于组件的变量或方法。

然而对于`onClick()`方法来说，情况并非如此。这要看`setCounter()`的方法了！

这个方法没有简单的提取方法。所以它需要存在于组件*和*中，它需要被缓存，这样它就不会在每次重新渲染时被添加到内存中。

# useCallback()

类似于`useState()` React 提供了一个名为`useCallback()`的钩子。这个名字一开始可能会令人困惑(对我来说也是如此)，但是它的本质是接受一个函数和一个包含变量和/或函数的依赖数组。如果变量或函数在依赖数组中的标识改变了(浅层检查)，你将得到一个新的函数，否则你将得到一个缓存的函数。

当这个组件重新渲染时，`onClick()`和`formatCounter()`都不再进入内存，这很好。

现在，如果您对这个组件进行性能测试，优化与未优化，您会看到一个非常小的差异。然而，在现实生活中的项目，有巨大的组件树，它变得至关重要的缓存事件处理程序和功能，使重新渲染尽可能快。

假设一个组件在树中有 15 个组件。如果这个组件由于状态变化或属性变化而重新呈现，那么这 15 个组件中所有未优化的函数和事件处理程序都将被再次添加到内存中。这取决于特定的情况，当用户在屏幕上打字或点击时，可能会产生抖动或口吃。简而言之，未优化的函数越积越多。

![](img/50d153534e58d82f4936099d68eda928.png)

# 旁白:依赖数组

如果您知道依赖数组及其工作原理，那么继续下一节。

关于依赖数组，你需要知道的是，如果数组中任何变量/函数/数组/对象的*标识*发生变化，你会得到新的东西。在`useCallback()`钩子的情况下，你将得到一个新的函数，函数中的所有东西，变量/函数/数组/对象，都将被重新初始化。

如果你提供一个空数组，你将总是收到钩子第一次运行时缓存的相同内容。

使用正确的依赖关系至关重要。React 上的人发布了一个 linter，它会让你知道你是否遗漏了什么或者添加了一些不必要的东西。就是这里:[eslint-plugin-react-hooks](https://www.npmjs.com/package/eslint-plugin-react-hooks)。

如果您使用的是新版本的 [create-react-app](https://github.com/facebook/create-react-app/) (版本 [3.0.0](https://github.com/facebook/create-react-app/releases/tag/v3.0.0) 和更高版本),那么这是预安装的

但是根据一般的经验，如果在你提供给这些优化钩子的东西里面有一些变量/函数/对象/数组(在`useCallback()`是函数的情况下),那么*需要*是最新的值，那么你需要提供它作为一个依赖。后面有一个例子说明了这一点！

# 还有其他优化吗？

有时候，当你初始化对象，数组，和/或做一些同步的繁重工作(解析，数学计算)时，你也想优化它。在每次重新渲染时，你可以告诉 React 只在某些情况下做初始化/繁重的工作。

React 提供了另一个类似于`useCallback()`的钩子，叫做`useMemo()`。它不是采用回调函数，而是采用返回某个值的普通函数。你应该总是从这个函数返回一些东西。

> *如果你发现自己没有从这个函数返回任何东西，你可能想要使用* `*useCallback()*` *来代替。*

经过一些练习，这两种钩子之间的区别变得很明显。

在上面的例子中，`arrayOfNames`是一个数组，它在组件每次重新渲染时被初始化。在这个简单的例子中，简单的解决方案是将初始化从组件中移出。然而，如果初始化依赖于组件本身，你应该使用`useMemo()`钩子并以这种方式优化它。现在我们还是用`useMemo()`吧。

现在让我们考虑一个例子，其中初始化*依赖于组件本身。*

这个例子的有趣之处在于变量`someRandomObject`完全依赖于`state`。如果状态改变，那么这个对象*将*改变。

对于眼尖的人来说，这个组件正在接受一个名为`text`的道具，这个道具正在被归还的 JSX 中使用。

现在想象一下，由于某种原因，道具`text`改变了。会发生什么？

组件会重新渲染，对吗？`someRandomObject`会怎么样？

是的，你猜对了。它会被重新初始化并添加到内存中。但是一定要这样吗？我们需要重新初始化它吗？当然不是。让我们使用`useMemo()`钩子来优化它。

给你。你的`someRandomObject`变量现在已经优化好了，可以使用了。哦，但是等等...

如果状态改变(通过点击按钮)，你认为优化后的*`someRandomObject`会反映正确的值吗？*

*![](img/f931fe2de173648391c9ec4b039bcfbb.png)*

*不，不会的。*

*为什么？*

> **如果在你提供给这些优化钩子的东西里面有一些变量/函数/对象/数组，*需要*成为最新的值，那么你需要把它作为一个依赖项来提供。**

*为了让我的`someRandomObject`正确，我需要`state`变量的最新值。如果我不提供`state`变量作为依赖项，`someRandomObject`将始终是:*

*这是第一次在`state`变量被初始化为`true`后初始化该变量。之后就再也不会变了。*

*在这种情况下，我们希望它在`state`变量改变时更新。因此，我们只提供`state`作为依赖项，一切都很好。*

*所以现在如果组件因为除了调用`setState()`函数之外的任何原因而更新(因为这是`state`可以改变的唯一时间)，那么`someRandomObject`将总是返回缓存的值，并且它不会每次都被添加到内存中，就像属性`text`改变时一样。*

# *裁决*

*我希望您现在已经了解了`useCallback()`和`useMemo()`的重要性，何时使用它们，如何处理依赖数组，以及何时从组件本身中取出东西。*

*我也邀请你做一个心理练习，想想这些优化是必要的可能场景。这将帮助你获得视角，并帮助你理解这些挂钩的好处。*

*在你离开之前给你一个警告，不要过早的优化，因为这是所有错误的根源。首先，尽可能用最简单的方式编写组件。确保所有的测试都在运行，并且组件按预期工作。只有这样，才能继续优化。从基本的开始。*

*优化组件中的事件处理程序和初始化。看看你能否从组件中取出一些东西。*

*优化应该是一个迭代的过程。*

*优化→检查
优化→检查
优化→检查
。
。
。*

*感谢阅读，我希望这给你们带来了价值。我很乐意听到你的评论和你可能不同意的事情。*

# *更新:*

*我在 Reddit 上得到一些反馈，“这篇文章没有很好地解释这实际上何时提高了性能，何时损害了性能以及过早优化的代码可读性”。*

*我明白为什么有些人会这样，我想详细说明一下这一点，因为它非常重要:)*

> *每一行代码都是有代价的。尝试在不进行任何优化的情况下编写代码，然后在必要的地方开始优化。*

*例如，在用户正在输入域中键入某些内容，而屏幕的某些其他部分需要绘画/更新的情况下。这对于简单的渲染来说可能不是问题，但是如果有很多工作要做，那么最好对它们进行优化。*

*在我们公司，我确保我们不会优化任何组件，直到出现问题，或者如果我们认为引入的功能可能会影响渲染时间。*

*人们倾向于过度优化和预优化。
我邀请你去看看
[https://react training . com/blog/react-inline-functions-and-performance](https://reacttraining.com/blog/react-inline-functions-and-performance)
，Ryan Florence 在这里谈到过早优化。*

*优化挂钩会占用内存。例如，它实例化一个依赖数组，然后在每次呈现时检查依赖数组中的内容是否发生了变化。这些都是正在做的工作。*

*因此，作为开发人员，你必须决定优化挂钩的成本是高还是低。*

*干杯！*