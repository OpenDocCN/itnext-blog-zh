<html>
<head>
<title>Understanding Basic Kubernetes Concepts II — Using Deployments To Manage Your Services Declaratively</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解基本的Kubernetes概念II——使用部署以声明方式管理您的服务</h1>
<blockquote>原文：<a href="https://itnext.io/understanding-basic-kubernetes-concepts-ii-using-deployments-to-manage-your-services-fa2b53310b0e?source=collection_archive---------4-----------------------#2020-07-13">https://itnext.io/understanding-basic-kubernetes-concepts-ii-using-deployments-to-manage-your-services-fa2b53310b0e?source=collection_archive---------4-----------------------#2020-07-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><a href="http://www.giantswarm.io"><div class="gh gi jn"><img src="../Images/32c9166eaf4ea29c6590af2813c4372f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9fi2oC6yvWrx-7f5uai25g.jpeg"/></div></a></figure><p id="6d41" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><em class="ks">这篇文章是一系列关于Kubernetes基本概念的博客文章中的第二篇。在第一篇中，我</em> <a class="ae kt" href="https://blog.giantswarm.io/understanding-basic-kubernetes-concepts-i-introduction-to-pods-labels-replicas/" rel="noopener ugc nofollow" target="_blank"> <em class="ks">解释了pod、标签和副本集</em> </a> <em class="ks">的概念。在本帖中，我们将讨论部署。第三篇文章</em> <a class="ae kt" href="https://blog.giantswarm.io/basic-kubernetes-concepts-iii-services-give-abstraction/" rel="noopener ugc nofollow" target="_blank"> <em class="ks">解释了服务概念</em> </a> <em class="ks">，第四篇文章我们来看看</em> <a class="ae kt" href="https://blog.giantswarm.io/understanding-basic-kubernetes-concepts-iv-secrets-and-configmaps/" rel="noopener ugc nofollow" target="_blank"> <em class="ks">秘密和配置图</em> </a> <em class="ks">。在第五篇也是最后一篇文章中，我们将讨论</em> <a class="ae kt" href="https://blog.giantswarm.io/understanding-basic-kubernetes-concepts-v-daemon-sets-and-jobs/" rel="noopener ugc nofollow" target="_blank"> <em class="ks">守护进程集和</em> </a> <em class="ks">任务集。</em></p><p id="92b1" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">你可能听过(或读过)我以前说过，在Kubernetes社区，有时很难找到做事情的最佳方式。在服务/应用程序部署方面，这导致人们使用pod手动部署容器，然后在顶部添加复制控制器以保持其活动并扩展它们，然后在某个时候使用<code class="fe ku kv kw kx b">kubectl rolling-update</code>进行更新。这至少在某种程度上是管理软件的必要形式。它通常涉及手工工作/命令，如果你在一个团队中工作的话，可能会非常不透明。</p><p id="fcbc" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">因此，在Kubernetes 1.2中添加了声明性的<em class="ks">部署</em>对象。然而，环顾四周，很少有资源提到它以及为什么应该使用它。当然，它包含在<a class="ae kt" href="https://kubernetes.io/docs/user-guide/deployments/" rel="noopener ugc nofollow" target="_blank">官方文件</a>中，并且在4月1日有一篇关于它的很好的<a class="ae kt" href="http://blog.kubernetes.io/2016/04/using-deployment-objects-with.html" rel="noopener ugc nofollow" target="_blank">博客文章</a>(也许人们认为这是一个笑话)，但是我没有看到很多人使用它，甚至更少在他们的博客文章和例子中明确提到它。所以我想写一篇小文章，谈谈为什么我认为你应该使用部署。</p><p id="9b22" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><em class="ks">旁注:在撰写本文时，大多数Kubernetes安装的系统服务或插件(如DNS、Dashboard、Metrics)仍然部署有复制控制器，但一些</em> <a class="ae kt" href="https://github.com/kubernetes/kubernetes/tree/master/cluster/addons" rel="noopener ugc nofollow" target="_blank"> <em class="ks">官方插件</em> </a> <em class="ks">已经被转移到部署中。监控已经完成了迁移，我们几天前刚刚合并了一个PR，将仪表板迁移到部署。在Giant Swarm上，所有这些系统服务已经作为部署运行。</em></p><h1 id="0515" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">陈述性方式与命令性方式</h1><p id="5757" class="pw-post-body-paragraph ju jv iq jw b jx lw jz ka kb lx kd ke kf ly kh ki kj lz kl km kn ma kp kq kr ij bi translated">部署的主要论点是在部署和管理软件的声明性和命令性方式之间的一般性争论。它不仅适用于应用程序级别，也适用于基础设施级别(但这是另一篇文章要考虑的)。<em class="ks">注意:如果您已经确信声明式管理是一条可行之路，那么您可以跳过这一章，直接进入下面的Kubernetes部署概念。</em></p><h1 id="c82d" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">必要的方式</h1><p id="466e" class="pw-post-body-paragraph ju jv iq jw b jx lw jz ka kb lx kd ke kf ly kh ki kj lz kl km kn ma kp kq kr ij bi translated">命令式的方法通常是你用来尝试一些事情并得到一个工作系统的方法。你手动调整它，在某一点上它是你喜欢的。然而，如果您继续使用这种命令式风格来部署和管理您的软件，您将会遇到几个问题(即使您自动化了这些步骤)。</p><ul class=""><li id="dbb6" class="mb mc iq jw b jx jy kb kc kf md kj me kn mf kr mg mh mi mj bi translated">如果您想知道最后部署了什么，您只能求助于检查当前部署的版本，这不一定是计划部署的版本。</li><li id="86df" class="mb mc iq jw b jx mk kb ml kf mm kj mn kn mo kr mg mh mi mj bi translated">如果您手动更改某些内容，其他人可能会覆盖您的更改，或者它们可能会被恢复。例如，因为您只手动启动了新的pod，而没有更改复制控制器。</li><li id="bca5" class="mb mc iq jw b jx mk kb ml kf mm kj mn kn mo kr mg mh mi mj bi translated">跟踪一个服务是如何随着时间的推移而发展的是很困难的，需要在某个地方单独记录。这在团队工作中尤为重要。</li><li id="d822" class="mb mc iq jw b jx mk kb ml kf mm kj mn kn mo kr mg mh mi mj bi translated">您需要几个命令来使一个服务达到期望的状态。即使这些步骤实现了自动化，当在不同的环境中运行时，它们也可能导致不同的结果。</li></ul><h1 id="80a4" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">陈述的方式</h1><p id="327e" class="pw-post-body-paragraph ju jv iq jw b jx lw jz ka kb lx kd ke kf ly kh ki kj lz kl km kn ma kp kq kr ij bi translated">另一方面，声明性的方法是你在生产中实际部署和管理软件或者与连续交付管道集成时应该想到的方法。你可能以前尝试过命令式的方法，但是一旦你知道它应该是什么样子，你就坐下来，通过把它写成一个声明式的定义来“使它正式化”。这就避免了上述问题，甚至带来了一些额外的好处。</p><ul class=""><li id="6691" class="mb mc iq jw b jx jy kb kc kf md kj me kn mf kr mg mh mi mj bi translated">它让你思考并计划你希望事情运行后的样子(计划状态)。</li><li id="b9a1" class="mb mc iq jw b jx mk kb ml kf mm kj mn kn mo kr mg mh mi mj bi translated">它描述的是运行时事情应该是什么样子，而不是达到目的所需的步骤(定义期望的状态，而不是过程)。</li><li id="774c" class="mb mc iq jw b jx mk kb ml kf mm kj mn kn mo kr mg mh mi mj bi translated">通过跟踪(或版本化)声明性定义，可以很容易地记录变更，这使得团队中的工作和交流更容易(但对于单个开发人员来说也是一种好的/干净的方法)。</li></ul><figure class="mq mr ms mt gt jr gh gi paragraph-image"><a href="https://www.giantswarm.io/guide-cloud-native-stack?utm_campaign=Blog%20CTA%20Conversion&amp;utm_source=Cloud%20native%20stack%20guide_Blog&amp;utm_medium=Blog%20CTA&amp;utm_term=cloud%20native%20stack%20guide"><div class="gh gi mp"><img src="../Images/bc0006a78be67725ad94f93830d17bdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*c-qxeyEWU0fNHZa5.jpg"/></div></a></figure><h1 id="e628" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">在Kubernetes的部署</h1><p id="ab70" class="pw-post-body-paragraph ju jv iq jw b jx lw jz ka kb lx kd ke kf ly kh ki kj lz kl km kn ma kp kq kr ij bi translated">如上所述，部署资源是相当新的，仍然没有被广泛使用。然而，目前它是我们在Kubernetes中部署和管理软件的最好的原语，所以理解它的作用和用途是很重要的。</p><p id="63ae" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在部署之前，有复制控制器，它管理pod并确保一定数量的pod在运行。现在，随着部署的进行，我们转向副本集，这基本上是下一代复制控制器。只是这次我们不管理它们，而是由我们定义的部署来管理它们。因此，这个链如下所示:部署-&gt;副本集-&gt; Pod。我们只需要解决第一个问题。</p><p id="26da" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">除了复制控制器(或<a class="ae kt" href="https://blog.giantswarm.io/understanding-basic-kubernetes-concepts-i-introduction-to-pods-labels-replicas/" rel="noopener ugc nofollow" target="_blank">副本集</a>)提供的功能之外，部署还为您提供了对用于部署的更新策略的声明式控制。这取代了旧的<code class="fe ku kv kw kx b">kubectl rolling-update</code>更新方式，但在定义<code class="fe ku kv kw kx b">maxSurge</code>和<code class="fe ku kv kw kx b">maxUnavailable</code>方面提供了相同的灵活性，即允许多少额外的和多少不可用的pod。在部署中定义这一点使您能够“一次使用多次”，这在团队工作或管理大量部署时更有帮助。</p><p id="a478" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">部署会为您管理更新。他们甚至去检查正在推出的新版本是否正常工作，如果不正常，就停止推出。</p><p id="0711" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">您还可以定义一个等待时间(<code class="fe ku kv kw kx b">minReadySeconds</code>)，在认为一个pod可用之前，它需要在没有任何容器崩溃的情况下准备好，这也有助于防止“坏的更新”，并为某些容器提供更多的时间来准备流量。</p><p id="513d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">您可以进一步使用部署的更新/修订功能来同时部署部署的多个修订。这支持蓝/绿部署或金丝雀释放策略。</p><p id="275c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">此外，部署会保留修订的历史记录(在回滚情况下使用)以及事件日志(可用于审计部署的发布和更改)。</p><h1 id="fbb9" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">部署入门</h1><p id="20b0" class="pw-post-body-paragraph ju jv iq jw b jx lw jz ka kb lx kd ke kf ly kh ki kj lz kl km kn ma kp kq kr ij bi translated">阅读所有关于部署的很酷的东西，您可能想亲自看看。</p><p id="7e74" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">由于部署(以及它们的副本集)是复制控制器的一种继承者，因此很容易将您已经拥有的复制控制器更改为部署。你只需要改变:</p><p id="1af5" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">到</p><p id="2204" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">并且在<code class="fe ku kv kw kx b">selector:</code>行之后添加包含<code class="fe ku kv kw kx b">matchLabels:</code>的一行(在实际的选择器之前，不要忘记修复缩进)，因为部署资源支持<a class="ae kt" href="https://kubernetes.io/docs/user-guide/labels/#resources-that-support-set-based-requirements" rel="noopener ugc nofollow" target="_blank">基于集合的标签需求</a>。</p><p id="e8b7" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这将为您提供一个可行的部署。由于部署比其前身具有更多功能，因此还有一些您尚未定义的字段。幸运的是，这些字段在创建时会自动填充默认值。</p><p id="c774" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">然而，正如我们在上面了解到的，当部署到不同的集群时，这可能会导致不同的结果。有时这可能是有意的，但如果不是，您可以看看在使用<code class="fe ku kv kw kx b">kubectl edit deployment &lt;deployment name&gt;</code>将部署应用到集群时得到了什么，然后将它(部分)复制回您的清单。</p><p id="c460" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">然而，正确的方法应该是通过阅读<a class="ae kt" href="https://kubernetes.io/docs/user-guide/deployments/" rel="noopener ugc nofollow" target="_blank">关于部署的官方文档</a>来学习部署的正确用法，然后编写一个适合您的清单。(您仍然可以从“翻译”您现有的复制控制器清单开始)。Kubernetes在4月8日发布的博客文章也是一个很好的阅读材料，它用一个很好的例子展示了更新和回滚的工作方式。</p><p id="9519" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">享受探索部署的乐趣，并期待下一篇基本概念帖子！</p><p id="54bc" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">由<a class="ae kt" href="https://twitter.com/puja108" rel="noopener ugc nofollow" target="_blank"> Puja Abbassi </a>撰写:<strong class="jw ir"> </strong>开发者拥护者@ <a class="ae kt" href="https://twitter.com/giantswarm" rel="noopener ugc nofollow" target="_blank">巨型蜂群</a></p></div></div>    
</body>
</html>