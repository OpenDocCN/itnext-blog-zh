<html>
<head>
<title>Storage DApp using Solidity and IPFS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用可靠性和IPFS的存储DApp</h1>
<blockquote>原文：<a href="https://itnext.io/storage-dapp-using-solidity-and-ipfs-62cf371b77dc?source=collection_archive---------0-----------------------#2022-04-14">https://itnext.io/storage-dapp-using-solidity-and-ipfs-62cf371b77dc?source=collection_archive---------0-----------------------#2022-04-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="3323" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">想象一下一个分散式存储应用程序，我们彼此共享磁盘，中间没有任何服务器。现在想象一下，这个分散式应用程序中的每个文件都可以很容易地共享，并且只需一个简单的散列就可以找到。听起来很有希望，对吗？这是一个正在进行的项目，我将解释它是如何工作的。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/81c73249d41e5dbb034f3d77a0e39a80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VT4Q4jlzBpZzA0D7"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">由<a class="ae lc" href="https://unsplash.com/@theshubhamdhage?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Shubham Dhage </a>在<a class="ae lc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="ccb2" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">介绍</h1><blockquote class="mb mc md"><p id="d7f6" class="jn jo kl jp b jq jr js jt ju jv jw jx me jz ka kb mf kd ke kf mg kh ki kj kk ij bi translated">TL；DR:你可以从<a class="ae lc" href="https://github.com/MCarlomagno/persssist" rel="noopener ugc nofollow" target="_blank"> <em class="iq"> G </em> ithub库</a>访问代码(并留下一个星号<em class="iq">😉</em>)。</p></blockquote><p id="58a1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这一切都是从一个问题开始的，当我试图找出如何在不丢失dApp定义的情况下在dApp中存储大文件时，这个问题出现了。如果应用程序将文件存储在一个集中的存储服务中，那么应用程序就不再是分散的了。</p><p id="bb5d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以经过一番研究，我找到了一个令人震惊的解决方案:<a class="ae lc" href="https://ipfs.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir">IPFS</strong></a><strong class="jp ir"/>🤯。</p><h2 id="0b2b" class="mh le iq bd lf mi mj dn lj mk ml dp ln jy mm mn lr kc mo mp lv kg mq mr lz ms bi translated">IPFS的一段话</h2><p id="bb79" class="pw-post-body-paragraph jn jo iq jp b jq mt js jt ju mu jw jx jy mv ka kb kc mw ke kf kg mx ki kj kk ij bi translated">IPFS是一个<strong class="jp ir"> <em class="kl">对等超媒体协议</em> </strong>，意思是跨计算机共享媒体的协议。通过使用这个协议，你可以很容易地建立p2p网络，在节点间共享信息(其中一个节点可以是你的计算机)。</p><p id="2f8f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">幸运的是，存在一个用于访问该协议并与之交互的高级Javascript包，这意味着您可以构建一个前端应用程序，使用您的计算机作为一个节点，通过网络共享和访问文件。我猜你已经知道这个应用程序是如何工作的了😉。</p><p id="89ad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但接下来的问题是如何组织文件、用户，以分散的方式引用文件元数据，并创建普遍可访问的信息。这就是区块链和智能合约来帮助我们的地方。</p><h2 id="e795" class="mh le iq bd lf mi mj dn lj mk ml dp ln jy mm mn lr kc mo mp lv kg mq mr lz ms bi translated">智能合同</h2><p id="7fc7" class="pw-post-body-paragraph jn jo iq jp b jq mt js jt ju mu jw jx jy mv ka kb kc mw ke kf kg mx ki kj kk ij bi translated">智能合同是一个简单的程序，通过在区块链网络中运行交易的地址来标识。我不打算深究这个概念，但简而言之，我们可以将智能合约作为一个微型数据库，因为它们具有不可改变的性质。</p><h1 id="5e49" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">构建应用程序</h1><h2 id="a2bc" class="mh le iq bd lf mi mj dn lj mk ml dp ln jy mm mn lr kc mo mp lv kg mq mr lz ms bi translated">创建可靠的智能合同</h2><p id="de1a" class="pw-post-body-paragraph jn jo iq jp b jq mt js jt ju mu jw jx jy mv ka kb kc mw ke kf kg mx ki kj kk ij bi translated">第一部分包括创建一个关于Solidity语言的智能合同，用于存储上传到应用程序的文件信息。我们将保存关于它们的一般信息，如文件名、类型、大小等。</p><p id="5966" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如你所见，代码非常简洁直接，我们只有三个变量，一个函数，一个事件和一个表示系统中一个文件的结构。代码是不言自明的，但是为了更好地理解，我添加了一些注释。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="my mz l"/></div></figure><h2 id="1607" class="mh le iq bd lf mi mj dn lj mk ml dp ln jy mm mn lr kc mo mp lv kg mq mr lz ms bi translated">使用Truffle和Ganache的智能合约部署</h2><p id="d59e" class="pw-post-body-paragraph jn jo iq jp b jq mt js jt ju mu jw jx jy mv ka kb kc mw ke kf kg mx ki kj kk ij bi translated">调试和测试智能合约的最方便程序员的方式是使用本地开发环境，如<a class="ae lc" href="https://trufflesuite.com/" rel="noopener ugc nofollow" target="_blank"> Truffle </a>来轻松地为我们的项目创建良好的管道。</p><p id="807e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">调试智能合同的另一个非常重要的工具是<a class="ae lc" href="https://trufflesuite.com/ganache/" rel="noopener ugc nofollow" target="_blank">Ganache</a>(Truffle套件的一部分)，这是一个本地区块链，你可以运行它来部署和调试你的合同，它们提供了一组开箱即用的帐户和配置，有足够的以太来做你在项目中想要做的几乎任何事情。</p><p id="2524" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以下一步是在我们的项目上设置truffle，因为这样我们可以简单地用npm安装它。</p><pre class="kn ko kp kq gt na nb nc nd aw ne bi"><span id="43ab" class="mh le iq nb b gy nf ng l nh ni">npm install -g truffle</span></pre><p id="8bf8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后你可以用你想要的任何框架/库创建你的前端项目，在我的例子中是next js。一旦你创建了它，你就可以在它上面初始化一个truffle环境，把控制台放在项目的根文件夹中，输入:</p><pre class="kn ko kp kq gt na nb nc nd aw ne bi"><span id="64f5" class="mh le iq nb b gy nf ng l nh ni">truffle init</span></pre><p id="e7d1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这将为你的项目创建一个基本的配置，在其他文件中会创建一个<em class="kl"> truffle-config.js </em>，这个文件在项目期间会特别重要。</p><blockquote class="mb mc md"><p id="b27a" class="jn jo kl jp b jq jr js jt ju jv jw jx me jz ka kb mf kd ke kf mg kh ki kj kk ij bi translated">你可以在这里查看项目配置<a class="ae lc" href="https://github.com/MCarlomagno/persssist/blob/main/truffle-config.js" rel="noopener ugc nofollow" target="_blank">。</a></p></blockquote><p id="8120" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了在项目中实际设置我们的智能合约，我们应该运行一个迁移，您可以按照<a class="ae lc" href="https://trufflesuite.com/docs/truffle/getting-started/running-migrations/" rel="noopener ugc nofollow" target="_blank">这些步骤</a>来完成。</p><h2 id="11d3" class="mh le iq bd lf mi mj dn lj mk ml dp ln jy mm mn lr kc mo mp lv kg mq mr lz ms bi translated">测试合同</h2><p id="3549" class="pw-post-body-paragraph jn jo iq jp b jq mt js jt ju mu jw jx jy mv ka kb kc mw ke kf kg mx ki kj kk ij bi translated">这一部分是智能合约开发中最重要的实践之一，智能合约应该尽可能好地进行测试，以便放心地部署它。由于智能契约的本质是不可变的，部署一个有缺陷的契约的成本是非常高的。</p><p id="a6e6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了测试合约，松露配有摩卡和茶，这使得测试变得容易得多。</p><p id="f31b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们来看一些智能合约测试的基本例子，你可以在这个测试文件中看到全套的测试。</p><p id="a852" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">测试合同部署正确:</strong></p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="8b52" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">测试上传有效文件:</strong></p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="my mz l"/></div></figure><h2 id="d5ca" class="mh le iq bd lf mi mj dn lj mk ml dp ln jy mm mn lr kc mo mp lv kg mq mr lz ms bi translated">使用元掩码验证</h2><p id="90e3" class="pw-post-body-paragraph jn jo iq jp b jq mt js jt ju mu jw jx jy mv ka kb kc mw ke kf kg mx ki kj kk ij bi translated">一旦我们完成了应用程序的基本配置，我们就可以开始使用元掩码进行用户身份验证，为此，我们有一个js API来连接应用程序和扩展，而不需要任何库。</p><p id="5c9a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了创造流畅的用户体验，我们可以创建一种方法，在存在现有帐户时自动连接。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="c0fa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">另一种强制请求的方法是打开元掩码弹出窗口进行身份验证。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="my mz l"/></div></figure><h2 id="2504" class="mh le iq bd lf mi mj dn lj mk ml dp ln jy mm mn lr kc mo mp lv kg mq mr lz ms bi translated">用智能合同连接前端</h2><p id="ba08" class="pw-post-body-paragraph jn jo iq jp b jq mt js jt ju mu jw jx jy mv ka kb kc mw ke kf kg mx ki kj kk ij bi translated">在这个阶段，我们已经有了一个与元掩码扩展连接的前端应用程序和一个与Ganache一起运行的智能契约，现在我们需要找到一种方法以API的形式与Solidity契约进行交互。</p><p id="5425" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为此，我们将需要一些库，如<a class="ae lc" href="https://web3js.readthedocs.io/en/v1.7.3/" rel="noopener ugc nofollow" target="_blank"> Web3.js </a>或<a class="ae lc" href="https://docs.ethers.io/v5/" rel="noopener ugc nofollow" target="_blank"> Ethers.js </a>。我选择了Web3.js。</p><p id="ba72" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">导入web3并创建合同对象</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="my mz l"/></div></figure><blockquote class="mb mc md"><p id="d5c6" class="jn jo kl jp b jq jr js jt ju jv jw jx me jz ka kb mf kd ke kf mg kh ki kj kk ij bi translated">注意:有一个特殊的文件叫做‘Persssist’，这就是<strong class="jp ir"> abi </strong>。JSON格式的智能契约表示，作为Javascript和Solidity之间的接口。</p></blockquote><h2 id="d7f9" class="mh le iq bd lf mi mj dn lj mk ml dp ln jy mm mn lr kc mo mp lv kg mq mr lz ms bi translated">将智能合同与IPFS连接</h2><p id="61d3" class="pw-post-body-paragraph jn jo iq jp b jq mt js jt ju mu jw jx jy mv ka kb kc mw ke kf kg mx ki kj kk ij bi translated">一旦我们有了合同对象，我们就可以开始使用IPFS上传文件。这里的技巧是，我们可以使用唯一的路径引用IPFS的文件，该路径作为在IPFS文件系统中创建的每个文件的Id。</p><p id="d3f5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">处于智能合同状态的每个文件都将引用IPFS文件系统中的一个路径，通过这种方式在合同和存储系统之间创建一个可靠的连接。</p><p id="a858" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">中间唯一的元素是为每个用户在本地浏览器上运行的前端应用程序，这样就创建了一个分散的存储应用程序。</p><h2 id="96bb" class="mh le iq bd lf mi mj dn lj mk ml dp ln jy mm mn lr kc mo mp lv kg mq mr lz ms bi translated">上传文件</h2><p id="a723" class="pw-post-body-paragraph jn jo iq jp b jq mt js jt ju mu jw jx jy mv ka kb kc mw ke kf kg mx ki kj kk ij bi translated">该任务由2个步骤组成:</p><ol class=""><li id="e725" class="nj nk iq jp b jq jr ju jv jy nl kc nm kg nn kk no np nq nr bi translated">上传文件到IPFS获得其唯一的路径。</li><li id="3897" class="nj nk iq jp b jq ns ju nt jy nu kc nv kg nw kk no np nq nr bi translated">使用结果在智能合同中创建文件记录。</li></ol><p id="dbd9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先我们创建IPFS连接，这不是每次用户上传文件都需要的，但是我在这个函数中这样做只是为了让它更清晰。</p><p id="2fc3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，我们只使用缓冲区和文件类型上传文件，结果我们获得了IPFS文件系统上的文件路径。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="9d12" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第二步是将文件信息实际存储在智能合约中，以便将来轻松下载该文件。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="my mz l"/></div></figure><h2 id="8602" class="mh le iq bd lf mi mj dn lj mk ml dp ln jy mm mn lr kc mo mp lv kg mq mr lz ms bi translated">获取和下载文件</h2><p id="ad5c" class="pw-post-body-paragraph jn jo iq jp b jq mt js jt ju mu jw jx jy mv ka kb kc mw ke kf kg mx ki kj kk ij bi translated">对于这一步，我们将做相反的过程。我们需要获取存储在智能合约中的文件，然后使用惟一的路径从IPFS文件系统下载文件。</p><p id="c092" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了创建一个用户友好的交互，我们可以获取所有的文件，只下载用户选择的文件。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="f711" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在用户选择一个文件进行下载后，我们可以开始下载过程。这是最困难的部分之一，因为IPFS只下载压缩格式的文件，所以我们需要做一些变通来获得正确的文件格式，在这种情况下通过添加<strong class="jp ir"> untar </strong>库。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="my mz l"/></div></figure><h1 id="fa3f" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">结论</h1><p id="7524" class="pw-post-body-paragraph jn jo iq jp b jq mt js jt ju mu jw jx jy mv ka kb kc mw ke kf kg mx ki kj kk ij bi translated">分散式应用程序是增强互联网用户和web 2.0开发者能力的绝佳机会。不需要在两个人中间有什么东西来创建一个可信的和流畅的交互，这只是(我希望)我们在不久的将来将拥有的去中心化互联网的无限例子之一。</p><p id="a1ba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你在这里，我相信你和我一样热爱编程，所以我强烈建议你检查代码，如果你敢，贡献并从中做出更大更好的东西。非常感谢你的阅读！</p><blockquote class="mb mc md"><p id="18ea" class="jn jo kl jp b jq jr js jt ju jv jw jx me jz ka kb mf kd ke kf mg kh ki kj kk ij bi translated">注意:你可以从<a class="ae lc" href="https://github.com/MCarlomagno/persssist" rel="noopener ugc nofollow" target="_blank"> <em class="iq"> G </em> ithub库</a>访问代码(并留下一个星号<em class="iq">😉</em>)。</p></blockquote></div></div>    
</body>
</html>