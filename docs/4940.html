<html>
<head>
<title>Designing Restful APIs using an API-First Approach — Contract Test</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用API优先的方法设计Restful APIs契约测试</h1>
<blockquote>原文：<a href="https://itnext.io/designing-restful-apis-using-an-api-first-approach-contract-test-34bde79603dd?source=collection_archive---------3-----------------------#2020-10-29">https://itnext.io/designing-restful-apis-using-an-api-first-approach-contract-test-34bde79603dd?source=collection_archive---------3-----------------------#2020-10-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="12d1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">几天前，我写了“<em class="kl">使用API优先的方法设计Restful APIs】系列文章的第二部分，我真的建议你看看第二篇文章，了解一下<a class="ae km" href="https://medium.com/@nicolastakashi/designing-apis-using-an-api-first-approach-mock-server-78ddbd9993f5" rel="noopener"> OpenAPI如何帮助你在不写任何代码的情况下拥有一个MockServer】。</a></em></p><p id="ffbb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">今天我们将讨论契约测试，以及如何确保API实现符合提议的设计。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi kn"><img src="../Images/5b4f14aff8f0775150068ce41dc51e62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Hid-3l5I5so6PifSyX2FwA.jpeg"/></div></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">照片由<a class="ae km" href="https://unsplash.com/@monty_a?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">蒙蒂艾伦</a>在<a class="ae km" href="https://unsplash.com/s/photos/backwards?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="b674" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我们谈论API时，我们谈论的是契约定义，因此我们必须记住，在API可用之后，定义的契约必须得到API提供者的支持。</p><p id="5506" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">即使在API可用之后，它仍在不断发展，API生命周期中最大的挑战之一就是API的发展。因为有时，业务需求变化如此之大，以至于当前的合同不能满足新的需求，需要一个突破性的改变。</p><h1 id="e23d" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">😈突破性变化——万恶之源</h1><p id="a62a" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">正如我经常说的那样，API是契约定义，我们不能违反契约而没有任何不良后果。</p><p id="1a0c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当一个新的功能打破了契约的当前状态时，如果你不能很好地管理它，你的客户就会有问题，在你的API发布后，他们的客户就会被打破。</p><p id="e4f3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，为了在API开发期间获得快速反馈，您必须知道一个变更是否引入了突破性的变更。</p><h1 id="53ab" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">🧪可能的方法</h1><p id="c71f" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">有几种可能的方法可以帮助您获得关于重大变更的快速反馈。</p><h2 id="8a17" class="mg le iq bd lf mh mi dn lj mj mk dp ln jy ml mm lr kc mn mo lv kg mp mq lz mr bi translated">单元测试</h2><p id="a16c" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">针对您的API运行单元测试将会让您知道契约何时被破坏，因为您的测试将会开始失败。</p><p id="de7f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是一个非常容易开始的策略，而且几乎所有的应用程序都已经有了单元测试套件，在订单方面，这种方法很容易被绕过，因为开发人员只需修复测试就可以成功并继续前进。</p><h2 id="bc60" class="mg le iq bd lf mh mi dn lj mj mk dp ln jy ml mm lr kc mn mo lv kg mp mq lz mr bi translated">API版本控制</h2><p id="7ea5" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">为每个新版本创建一个新版本的API，保留旧版本，直到您的客户迁移到新版本。</p><p id="457d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们知道API版本化是一个最佳实践，但是如果你为你的API创建一个新版本，毫无疑问，这将很快变得混乱，并且你将很难将所有的版本保持在一起。</p><h2 id="5787" class="mg le iq bd lf mh mi dn lj mj mk dp ln jy ml mm lr kc mn mo lv kg mp mq lz mr bi translated">合同测试</h2><p id="ef3a" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">检查API设计期间设计的内容和开发的内容之间的差异，在持续集成管道中运行它将为我们提供快速的反馈，这是一种非常灵活和有效的方法。</p><h2 id="55a0" class="mg le iq bd lf mh mi dn lj mj mk dp ln jy ml mm lr kc mn mo lv kg mp mq lz mr bi translated">我应该使用什么方法？</h2><p id="7464" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">如果我们看一下前两个选项，我们可以发现明显的缺点，要么是流程旁路，要么是可维护的问题。</p><p id="b441" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将契约测试与其他两种方法进行比较，我们可以看到，开发人员无法在不对原始OpenAPI文档进行更改的情况下绕过该过程，这种更改必须为您的团队以及(如果可能的话)API利益相关者进行审核。</p><p id="45b9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它更容易自动化，并提供对什么正在下降以及为什么会失败的清晰理解。</p><h1 id="76c4" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">🤖合同测试实现</h1><p id="599d" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">如上所述，契约测试似乎是检测构建时突破性变化的最佳解决方案，为了在本期杂志中帮助我们，让我们使用一个名为<code class="fe ms mt mu mv b">openapi-diff</code>的工具，这是一个npm包，它比较两个OpenApi文档并查找删除或添加的内容。</p><p id="c5d5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">OpenAPI-diff将更改分为两组，<strong class="jp ir">突发更改</strong>和<strong class="jp ir">平滑更改，</strong>让我们来看一些例子:</p><p id="43b8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">突破性变化</strong></p><ul class=""><li id="c314" class="mw mx iq jp b jq jr ju jv jy my kc mz kg na kk nb nc nd ne bi translated">删除路径或参数</li><li id="ee5d" class="mw mx iq jp b jq nf ju ng jy nh kc ni kg nj kk nb nc nd ne bi translated">重命名路径或参数</li><li id="da65" class="mw mx iq jp b jq nf ju ng jy nh kc ni kg nj kk nb nc nd ne bi translated">添加必需的参数</li><li id="de13" class="mw mx iq jp b jq nf ju ng jy nh kc ni kg nj kk nb nc nd ne bi translated">修改响应项目</li></ul><p id="e30c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">平滑变化</strong></p><ul class=""><li id="1abb" class="mw mx iq jp b jq jr ju jv jy my kc mz kg na kk nb nc nd ne bi translated">添加路径或参数</li><li id="f0f3" class="mw mx iq jp b jq nf ju ng jy nh kc ni kg nj kk nb nc nd ne bi translated">添加响应项目</li><li id="c2fb" class="mw mx iq jp b jq nf ju ng jy nh kc ni kg nj kk nb nc nd ne bi translated">添加或更新描述</li></ul><p id="19d6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">安装<code class="fe ms mt mu mv b">openapi-diff</code>太简单了，你只需要运行下面的一个命令。</p><pre class="ko kp kq kr gt nk mv nl nm aw nn bi"><span id="5cbe" class="mg le iq mv b gy no np l nq nr">// using npm<br/>npm install openapi-diff</span><span id="8e31" class="mg le iq mv b gy ns np l nq nr">// using yarn<br/>yarn add openapi-diff</span></pre><h2 id="5fc4" class="mg le iq bd lf mh mi dn lj mj mk dp ln jy ml mm lr kc mn mo lv kg mp mq lz mr bi translated">测试什么？</h2><p id="444f" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">也许你是在问自己，但是我们将通过差异来检查什么。</p><p id="380e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们继续下一步之前，一个非常重要的步骤是提取由您的代码生成的<code class="fe ms mt mu mv b">swagger.json</code>，这将取决于您用来编写应用程序的平台。</p><p id="3678" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这篇博文中，我将使用一个ASP.NET核心API，它将位于本系列文章所使用的同一个存储库中。</p><p id="c615" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了简单起见，我不会展示如何在ASP.NET核心项目中设置Swashbuckle，但是如果你想知道如何正确地做，请在下面评论，我可以写一篇关于这个设置的帖子。</p><h2 id="234b" class="mg le iq bd lf mh mi dn lj mj mk dp ln jy ml mm lr kc mn mo lv kg mp mq lz mr bi translated">ASP。NET Core和Swashbuckle CLI</h2><p id="d331" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">既然你已经在你的ASP.NET核心项目中配置了Swashbuckle，你可以安装一个名为<code class="fe ms mt mu mv b">Swashbuckle.AspNetCore.Cli</code>的Dotnet工具，这是一个非常简单的工具，它使用项目DLL提取<code class="fe ms mt mu mv b">swagger.json</code>，如果你想了解这个工具的更多信息，请查看<a class="ae km" href="https://github.com/domaindrivendev/Swashbuckle.AspNetCore#swashbuckleaspnetcorecli" rel="noopener ugc nofollow" target="_blank"> Github文档</a>。</p><p id="39b4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">按照官方文档中的描述安装工具后，只需运行下面的命令。</p><pre class="ko kp kq kr gt nk mv nl nm aw nn bi"><span id="28d3" class="mg le iq mv b gy no np l nq nr">swagger tofile --yaml --output ./bin/swagger.yaml ./api/TodoApp.Api/bin/Debug/netcoreapp3.1/TodoApp.Api.dll v1</span></pre><p id="f0db" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上面的命令将提取<code class="fe ms mt mu mv b">swagger.json</code>并将其转换为<code class="fe ms mt mu mv b">YAML</code>文件，这个文件看起来像我们在API设计过程中编写的OpenAPI文件。</p><h2 id="ca63" class="mg le iq bd lf mh mi dn lj mj mk dp ln jy ml mm lr kc mn mo lv kg mp mq lz mr bi translated">OpenAPI-Diff的实际应用</h2><p id="6f91" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">现在我们已经有了设计好的OpenAPI文档和通过代码生成的OpenAPI文档，是时候比较这些文件并检查输出了。</p><p id="f008" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">只需运行上面的命令，让我们看到控制台输出。</p><pre class="ko kp kq kr gt nk mv nl nm aw nn bi"><span id="8dd4" class="mg le iq mv b gy no np l nq nr">openapi-diff ./bin/api.yaml ./bin/swagger.yaml</span></pre><h2 id="9a75" class="mg le iq bd lf mh mi dn lj mj mk dp ln jy ml mm lr kc mn mo lv kg mp mq lz mr bi translated">没有变化</h2><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/0d1d305abfa76dc3e0b468e5955609a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:988/format:webp/1*qCgK3ixXuyscckx2LecV-g.png"/></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">OpenAPI差异—未检测到任何更改</figcaption></figure><h2 id="e98a" class="mg le iq bd lf mh mi dn lj mj mk dp ln jy ml mm lr kc mn mo lv kg mp mq lz mr bi translated">随着变化</h2><p id="5cbb" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">我只是对代码做了一些修改，向<code class="fe ms mt mu mv b">GET /tasks</code>端点添加了一个新的查询字符串参数，并从<code class="fe ms mt mu mv b">GET /tasks/{id}</code>端点删除了状态代码，我们可以看到下面的输出。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi nu"><img src="../Images/caa2fd0663a1f104f8306bb9fc921cd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0aSENlMgc0W_uWWo7AjkGg.png"/></div></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">OpenAPI差异—检测到重大更改</figcaption></figure><p id="e604" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如您在上面看到的，查询字符串参数中的更改没有被记录，但是删除状态代码的更改被检测为重大更改。</p><p id="6018" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，您只需将OpenAPI Diff添加到您的API管道中，就可以在每次有人更改API实现并将其推送到您的存储库时检测可能的重大更改。</p><p id="ef54" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这种策略允许开发人员在他们的本地机器上运行相同的脚本，避免管道中断，具有快速失败验证。</p><h1 id="956c" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">🏁结论</h1><p id="301b" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">在我看来，避免中断更改是API生命周期中最困难的任务，在大多数情况下，它与设计会话相关，如果我们关注设计的寿命，并尝试理解API旨在解决的领域中可能的极限情况，我们就可以在新的业务需求出现时减少中断API合同的必要性。</p><p id="883c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了让突破性的变化在你的控制之下，契约测试策略可以帮助我们快速反馈，并让我们安全地打破契约，为你的API的客户制造问题。</p><p id="5be5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通常每个代码都会在<a class="ae km" href="https://github.com/nicolastakashi/todoapp-openapidocuments" rel="noopener ugc nofollow" target="_blank"> Github库</a>中更新，你可以把它作为这篇文章的补充。</p><p id="ad4a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我知道你认为这个策略怎么样？你已经知道了吗？</p><p id="1a9a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面评论一下，大家分享一下经验吧。希望你喜欢，再见。</p></div></div>    
</body>
</html>