<html>
<head>
<title>Kadane’s Algorithm — Identify Pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">卡丹算法——识别模式</h1>
<blockquote>原文：<a href="https://itnext.io/kadanes-algorithm-identify-pattern-12d96ea3de24?source=collection_archive---------1-----------------------#2022-06-16">https://itnext.io/kadanes-algorithm-identify-pattern-12d96ea3de24?source=collection_archive---------1-----------------------#2022-06-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><h1 id="d163" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">介绍</h1><p id="9f3d" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">卡丹的算法是解决<strong class="kn ir"> O(n) </strong>中问题的一种不可靠的方法。基本的推论是基于动态规划的概念。在动态编程中，思想是在通过一个过程迭代时尽可能多地使用以前的学习。每当最大子阵列问题的名称出现时，就会使用Kadane的算法。它遍历给定的数组<em class="lj"> arr[1…从左到右。在第I步中，它计算结束于<em class="lj"> i </em>的具有最大和的子阵列。</em></p><blockquote class="lk ll lm"><p id="0932" class="kl km lj kn b ko ln kq kr ks lo ku kv lp lq ky kz lr ls lc ld lt lu lg lh li ij bi translated">将<strong class="kn ir"> Mi </strong>定义为结束于索引<strong class="kn ir"> i </strong>且包含索引<strong class="kn ir">0</strong><strong class="kn ir">≤I≤n1</strong>的最大连续和。然后我们有<strong class="kn ir"> M0 = A[0] </strong>和<strong class="kn ir">Mi = max(Mi 1+A[I]，A[i]) </strong>。</p></blockquote><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="gh gi lv"><img src="../Images/62e26dcc2bdfde14267bfef9673c775b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EL8Q8GOqCPl0sne-m-KdSw.png"/></div></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk translated">图1:使用Kadane算法的子阵列的最大和</figcaption></figure><h2 id="752e" class="ml jo iq bd jp mm mn dn jt mo mp dp jx kw mq mr kb la ms mt kf le mu mv kj mw bi translated">伪代码</h2><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="gh gi mx"><img src="../Images/798af0bdade099946fe17349ab79b0c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I330gsdTQevJ_sbJVyDzEQ.png"/></div></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk translated">图Kadane算法的伪代码</figcaption></figure><h2 id="afdf" class="ml jo iq bd jp mm mn dn jt mo mp dp jx kw mq mr kb la ms mt kf le mu mv kj mw bi translated">识别Kadane问题的关键字或术语</h2><p id="c222" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">以下关键词或术语将会出现或需要从给定的问题陈述中识别:</p><ul class=""><li id="77a2" class="my mz iq kn b ko ln ks lo kw na la nb le nc li nd ne nf ng bi translated">连续子阵列</li><li id="2887" class="my mz iq kn b ko nh ks ni kw nj la nk le nl li nd ne nf ng bi translated">最大子阵列</li><li id="2998" class="my mz iq kn b ko nh ks ni kw nj la nk le nl li nd ne nf ng bi translated">连续递增子阵列</li><li id="0835" class="my mz iq kn b ko nh ks ni kw nj la nk le nl li nd ne nf ng bi translated">子序列和</li></ul><p id="60a7" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lq ky kz la ls lc ld le lu lg lh li ij bi translated">示例:</p><p id="92cb" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lq ky kz la ls lc ld le lu lg lh li ij bi translated"><em class="lj">求邻接子阵列的最大和。</em></p><h1 id="e614" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">基于Kadane算法的问题及解决方案</h1><p id="282c" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">使用Kadane算法可以解决许多问题。</p><h2 id="6954" class="ml jo iq bd jp mm mn dn jt mo mp dp jx kw mq mr kb la ms mt kf le mu mv kj mw bi translated">最大子阵列/最大连续子阵列总和</h2><p id="95e2" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">给定一个整数数组，找到具有最大和的连续子数组(至少包含一个数字)，并返回其和<em class="lj">。</em></p><p id="8d36" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lq ky kz la ls lc ld le lu lg lh li ij bi translated">一个<strong class="kn ir">子数组</strong>是一个数组的<strong class="kn ir">连续</strong>部分。</p><pre class="lw lx ly lz gt nm nn no np aw nq bi"><span id="9ca7" class="ml jo iq nn b gy nr ns l nt nu"><strong class="nn ir">Input:</strong> nums = [-2,1,-3,4,-1,2,1,-5,4]<br/><strong class="nn ir">Output:</strong> 6<br/><strong class="nn ir">Explanation:</strong> [4,-1,2,1] has the largest sum = 6.</span></pre><p id="4567" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lq ky kz la ls lc ld le lu lg lh li ij bi translated"><strong class="kn ir">解决方案</strong></p><pre class="lw lx ly lz gt nm nn no np aw nq bi"><span id="df60" class="ml jo iq nn b gy nr ns l nt nu">def getLargestSum(nums):<br/>    maxSoFar = float('-inf')<br/>    maxEndingHere = 0<br/>    <br/>    for i in range(len(nums)):<br/>        maxEndingHere += nums[i]<br/>        <br/>        if (maxSoFar &lt; maxEndingHere):<br/>            maxSoFar = maxEndingHere<br/>        <br/>        if (maxEndingHere &lt; 0):<br/>            maxEndingHere = 0<br/>            <br/>    return maxSoFar</span><span id="5f80" class="ml jo iq nn b gy nv ns l nt nu"># Execution</span><span id="f8f3" class="ml jo iq nn b gy nv ns l nt nu">nums = [-2,1,-3,4,-1,2,1,-5,4]<br/>getLargestSum(nums)</span></pre><h2 id="c358" class="ml jo iq bd jp mm mn dn jt mo mp dp jx kw mq mr kb la ms mt kf le mu mv kj mw bi translated">二进制字符串中0和1的最大差值</h2><p id="6801" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">给定一个二进制串<strong class="kn ir">0</strong>和<strong class="kn ir">1</strong>。任务是找出在<strong class="kn ir">0</strong>的数目和1的数目之间具有最大差值的子串的长度(0的数目<strong class="kn ir">0的数目</strong>—1的数目)。在所有<strong class="kn ir">1</strong>打印-1的情况下。</p><pre class="lw lx ly lz gt nm nn no np aw nq bi"><span id="170c" class="ml jo iq nn b gy nr ns l nt nu"><strong class="nn ir">Input :</strong> S = "11000010001"<br/><strong class="nn ir">Output :</strong> 6<br/>From index 2 to index 9, there are 7<br/>0s and 1 1s, so number of 0s - number<br/>of 1s is 6.</span></pre><p id="ed3f" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lq ky kz la ls lc ld le lu lg lh li ij bi translated"><strong class="kn ir">解决方案</strong></p><pre class="lw lx ly lz gt nm nn no np aw nq bi"><span id="6d90" class="ml jo iq nn b gy nr ns l nt nu">def getMaxDifference(s):<br/>    maxSoFar = float('-inf')<br/>    maxEndingHere = 0<br/>    <br/>    for i in range(len(s)):<br/>        if s[i] == '0':<br/>            maxEndingHere += 1<br/>        else:<br/>            maxEndingHere -= 1<br/>        <br/>        if maxSoFar &lt; maxEndingHere:<br/>            maxSoFar = maxEndingHere<br/>        <br/>        if maxEndingHere &lt; 0:<br/>            maxEndingHere = 0<br/>    <br/>    return maxSoFar</span><span id="474e" class="ml jo iq nn b gy nv ns l nt nu">s = "11000010001"<br/>getMaxDifference(s)</span></pre><h2 id="ef7a" class="ml jo iq bd jp mm mn dn jt mo mp dp jx kw mq mr kb la ms mt kf le mu mv kj mw bi translated">最大和圆形子阵列</h2><p id="4de9" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">给定一个长度为<code class="fe nw nx ny nn b">n</code>的<strong class="kn ir">循环整数数组</strong> <code class="fe nw nx ny nn b">nums</code>，返回<em class="lj">一个非空</em> <strong class="kn ir"> <em class="lj">子数组</em></strong><em class="lj"><code class="fe nw nx ny nn b">nums</code>的最大可能和。</em></p><p id="e921" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lq ky kz la ls lc ld le lu lg lh li ij bi translated">一个<strong class="kn ir">循环数组</strong>意味着数组的末尾连接到数组的开头。形式上，<code class="fe nw nx ny nn b">nums[i]</code>的下一个元素是<code class="fe nw nx ny nn b">nums[(i + 1) % n]</code>,<code class="fe nw nx ny nn b">nums[i]</code>的前一个元素是<code class="fe nw nx ny nn b">nums[(i - 1 + n) % n]</code>。</p><p id="c4ee" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lq ky kz la ls lc ld le lu lg lh li ij bi translated">一个<strong class="kn ir">子数组</strong>最多只能包含一次固定缓存<code class="fe nw nx ny nn b">nums</code>的每个元素。形式上，对于一个子阵<code class="fe nw nx ny nn b">nums[i], nums[i + 1], ..., nums[j]</code>，不存在<code class="fe nw nx ny nn b">i &lt;= k1</code>、<code class="fe nw nx ny nn b">k2 &lt;= j</code>与<code class="fe nw nx ny nn b">k1 % n == k2 % n</code>。</p><pre class="lw lx ly lz gt nm nn no np aw nq bi"><span id="5804" class="ml jo iq nn b gy nr ns l nt nu"><strong class="nn ir">Input:</strong> nums = [1,-2,3,-2]<br/><strong class="nn ir">Output:</strong> 3<br/><strong class="nn ir">Explanation:</strong> Subarray [3] has maximum sum 3.</span></pre><p id="5aa4" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lq ky kz la ls lc ld le lu lg lh li ij bi translated"><strong class="kn ir">解决方案</strong></p><pre class="lw lx ly lz gt nm nn no np aw nq bi"><span id="5410" class="ml jo iq nn b gy nr ns l nt nu">class Solution(object):<br/>    def maxSubarraySumCircular(self, nums):<br/>        """<br/>        :type nums: List[int]<br/>        :rtype: int<br/>        """<br/>        n = len(nums)<br/>        if n == 0:<br/>            return 0<br/>        <br/>        # If the list contains all negative values, return the maximum element<br/>        maximum = max(nums)<br/>        if maximum &lt; 0:<br/>            return maximum<br/>        <br/>        # Make all elements negative in the list<br/>        for i in range(len(nums)):<br/>            nums[i] = -nums[i]<br/>            <br/>        negativeMaxSum = self.kadane(nums)<br/>        <br/>        # Restore the list<br/>        for i in range(len(nums)):<br/>            nums[i] = -nums[i]<br/>        <br/>        return max(self.kadane(nums), sum(nums) + negativeMaxSum)<br/>            <br/>    def kadane(self, nums):<br/>        maxSoFar = 0<br/>        maxEndingHere = 0<br/>        <br/>        for i in range(len(nums)):<br/>            maxEndingHere += nums[i]<br/>            <br/>            if maxSoFar &lt; maxEndingHere:<br/>                maxSoFar = maxEndingHere<br/>                <br/>            if maxEndingHere  &lt; 0:<br/>                maxEndingHere = 0<br/>        <br/>        return maxSoFar</span></pre><h2 id="054b" class="ml jo iq bd jp mm mn dn jt mo mp dp jx kw mq mr kb la ms mt kf le mu mv kj mw bi translated">最小和连续子阵列</h2><p id="1d7a" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">给定包含<strong class="kn ir"> n </strong>个整数的数组。问题是找到具有最小和的相邻子阵列的元素的和。</p><pre class="lw lx ly lz gt nm nn no np aw nq bi"><span id="c922" class="ml jo iq nn b gy nr ns l nt nu"><strong class="nn ir">Input </strong>: nums = [3, -4, 2, -3, -1, 7, -5]<br/><strong class="nn ir">Output </strong>: -6</span><span id="009a" class="ml jo iq nn b gy nv ns l nt nu"><strong class="nn ir">Explanation:</strong><br/>Subarray is [<strong class="nn ir">-4, 2, -3, -1]</strong> = -6</span></pre><p id="5046" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lq ky kz la ls lc ld le lu lg lh li ij bi translated"><strong class="kn ir">解决方案</strong></p><pre class="lw lx ly lz gt nm nn no np aw nq bi"><span id="f129" class="ml jo iq nn b gy nr ns l nt nu">def getSmallestSum(nums):<br/>    minEndingHere = float('inf')<br/>    minSoFar = float('inf')<br/>    <br/>    for i in range(len(nums)):<br/>        if minEndingHere &lt;= 0:<br/>            minEndingHere += nums[i]<br/>        else:<br/>            minEndingHere = nums[i]<br/>        <br/>        if minSoFar &gt; minEndingHere:<br/>            minSoFar = minEndingHere<br/>    <br/>    return minSoFar</span><span id="2921" class="ml jo iq nn b gy nv ns l nt nu"># Execution<br/>nums = [3, -4, 2, -3, -1, 7, -5]<br/>getSmallestSum(nums)</span></pre><h2 id="799c" class="ml jo iq bd jp mm mn dn jt mo mp dp jx kw mq mr kb la ms mt kf le mu mv kj mw bi translated">最大和连续递增子阵列</h2><p id="10c7" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">给定n个正整数的数组。问题是在O(n)时间复杂度内找到一个连续递增子阵列的最大和。</p><pre class="lw lx ly lz gt nm nn no np aw nq bi"><span id="4e82" class="ml jo iq nn b gy nr ns l nt nu"><strong class="nn ir">Input </strong>: nums = [2, 1, 4, 7, 3, 6]<br/><strong class="nn ir">Output </strong>: 12</span><span id="1d10" class="ml jo iq nn b gy nv ns l nt nu"><strong class="nn ir">Explanation:</strong><br/>Contiguous Increasing subarray [1, 4, 7] = 12</span></pre><p id="8344" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lq ky kz la ls lc ld le lu lg lh li ij bi translated"><strong class="kn ir">解决方案</strong></p><pre class="lw lx ly lz gt nm nn no np aw nq bi"><span id="8336" class="ml jo iq nn b gy nr ns l nt nu">def getLargestSum(nums):<br/>    n = len(nums)<br/>    maxSoFar = float('-inf')<br/>    maxEndingHere = 0<br/>    <br/>    for i in range(n):<br/>        maxEndingHere = nums[i]<br/>        <br/>        while ((i + 1) &lt; n and (nums[i+1] &gt; nums[i])):<br/>            maxEndingHere += nums[i+1]<br/>            i += 1<br/>        <br/>        if maxEndingHere &gt; maxSoFar:<br/>            maxSoFar = maxEndingHere<br/>    <br/>    return maxSoFar</span><span id="30b6" class="ml jo iq nn b gy nv ns l nt nu"># Execution<br/>nums = [1, 1, 4, 7, 3, 6]<br/>getLargestSum(nums)</span></pre><h2 id="4990" class="ml jo iq bd jp mm mn dn jt mo mp dp jx kw mq mr kb la ms mt kf le mu mv kj mw bi translated">最大乘积子阵列</h2><p id="b2e6" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">给定一个整数数组，在数组中找到一个具有最大乘积的连续非空子数组，并返回乘积<em class="lj">。</em></p><p id="0afc" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lq ky kz la ls lc ld le lu lg lh li ij bi translated">测试用例的生成是为了让答案符合一个32位的整数。</p><p id="d0eb" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lq ky kz la ls lc ld le lu lg lh li ij bi translated">一个<strong class="kn ir">子数组</strong>是该数组的一个连续子序列。</p><pre class="lw lx ly lz gt nm nn no np aw nq bi"><span id="8ed0" class="ml jo iq nn b gy nr ns l nt nu"><strong class="nn ir">Input:</strong> nums = [2,3,-2,4]<br/><strong class="nn ir">Output:</strong> 6<br/><strong class="nn ir">Explanation:</strong> [2,3] has the largest product 6.</span></pre><p id="b5d2" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lq ky kz la ls lc ld le lu lg lh li ij bi translated"><strong class="kn ir">解决方案</strong></p><pre class="lw lx ly lz gt nm nn no np aw nq bi"><span id="c1fa" class="ml jo iq nn b gy nr ns l nt nu">class Solution(object):<br/>    def maxProduct(self, nums):<br/>        """<br/>        :type nums: List[int]<br/>        :rtype: int<br/>        """<br/>        maxVal = 1<br/>        minVal = 1<br/>        maxProd = float('-inf')<br/>        <br/>        for n in nums:<br/>            maxVal, minVal = max(maxVal * n, minVal * n, n), min(minVal * n, maxVal * n, n)<br/>            maxProd = max(maxProd, maxVal, minVal) <br/>            <br/>        return maxProd</span></pre><h2 id="90fd" class="ml jo iq bd jp mm mn dn jt mo mp dp jx kw mq mr kb la ms mt kf le mu mv kj mw bi translated">只有非负元素的最大和连续子阵列</h2><p id="53fc" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">给定一个整数数组，任务是找到非负元素的最大和连续子数组，并返回其和。</p><pre class="lw lx ly lz gt nm nn no np aw nq bi"><span id="6c6f" class="ml jo iq nn b gy nr ns l nt nu"><strong class="nn ir">Input: </strong>nums = [1, 4, -3, 9, 5, -6]<br/><strong class="nn ir">Output:</strong> 14 <br/><strong class="nn ir">Explanation:</strong> <br/>Subarray [9, 5] is the subarray having maximum sum with all non-negative elements.</span></pre><p id="bc2f" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lq ky kz la ls lc ld le lu lg lh li ij bi translated"><strong class="kn ir">解决方案</strong></p><pre class="lw lx ly lz gt nm nn no np aw nq bi"><span id="89ce" class="ml jo iq nn b gy nr ns l nt nu">def getLargestSum(nums):<br/>    n = len(nums)<br/>    maxSoFar = float('-inf')<br/>    maxEndingHere = 0<br/>    s = 0<br/>    <br/>    for i in range(n):<br/>        if nums[i] &lt; 0:<br/>            maxEndingHere = 0<br/>        else:<br/>            maxEndingHere += nums[i]<br/>        <br/>        if maxSoFar &lt; maxEndingHere:<br/>            maxSoFar = maxEndingHere<br/>    <br/>    return maxSoFar</span><span id="c1f8" class="ml jo iq nn b gy nv ns l nt nu"># Execute<br/>nums = [1, 4, -3, 9, 5, -6]<br/>getLargestSum(nums)</span></pre><h2 id="aac3" class="ml jo iq bd jp mm mn dn jt mo mp dp jx kw mq mr kb la ms mt kf le mu mv kj mw bi translated">具有唯一元素的最大和连续子阵列</h2><p id="4413" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">给定一个由<strong class="kn ir"> N </strong>个正整数组成的数组，任务是在所有具有唯一元素的子数组中找出具有最大和的子数组，并打印其和。</p><pre class="lw lx ly lz gt nm nn no np aw nq bi"><span id="68a8" class="ml jo iq nn b gy nr ns l nt nu"><strong class="nn ir">Input</strong> nums = [1, 2, 3, 3, 4, 5, 2, 1]<br/><strong class="nn ir">Output:</strong> 15<br/><strong class="nn ir">Explanation:</strong><br/>The subarray having maximum sum with distinct element is [3, 4, 5, 2, 1].<br/>Therefore, sum is = 3 + 4 + 5 + 2 + 1 = 15</span></pre><p id="050a" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lq ky kz la ls lc ld le lu lg lh li ij bi translated"><strong class="kn ir">解决方案</strong></p><pre class="lw lx ly lz gt nm nn no np aw nq bi"><span id="a503" class="ml jo iq nn b gy nr ns l nt nu">def getLargestSum(nums):<br/>    d = {}<br/>    maxSoFar = float('-inf')<br/>    maxEndingHere = 0<br/>    <br/>    for i in range(len(nums)):<br/>        if nums[i] not in d:<br/>            maxEndingHere += nums[i]<br/>            d[nums[i]] = 1<br/>            <br/>            if maxEndingHere &gt; maxSoFar:<br/>                maxSoFar = maxEndingHere<br/>            <br/>            if maxEndingHere &lt; 0:<br/>                maxEndingHere = 0<br/>                <br/>    return maxSoFar</span><span id="5831" class="ml jo iq nn b gy nv ns l nt nu"># Execution</span><span id="d36e" class="ml jo iq nn b gy nv ns l nt nu">nums = [ 1, 2, 3, 1, 5 ]<br/>getLargestSum(nums)</span></pre><h2 id="0dee" class="ml jo iq bd jp mm mn dn jt mo mp dp jx kw mq mr kb la ms mt kf le mu mv kj mw bi translated">最大交替子序列和</h2><p id="038f" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">一个<strong class="kn ir"> 0索引</strong>数组的<strong class="kn ir">交替和</strong>被定义为在<strong class="kn ir">偶数</strong>索引<strong class="kn ir">处元素的<strong class="kn ir">和</strong>减去在<strong class="kn ir">奇数</strong>索引处元素的<strong class="kn ir">和</strong>。</strong></p><ul class=""><li id="3a39" class="my mz iq kn b ko ln ks lo kw na la nb le nc li nd ne nf ng bi translated">比如<code class="fe nw nx ny nn b">[4,2,5,3]</code>的交替和是<code class="fe nw nx ny nn b">(4 + 5) - (2 + 3) = 4</code>。</li></ul><p id="02e1" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lq ky kz la ls lc ld le lu lg lh li ij bi translated">给定一个数组<code class="fe nw nx ny nn b">nums</code>，返回 <code class="fe nw nx ny nn b">nums</code> <em class="lj">任意子序列的</em> <strong class="kn ir"> <em class="lj">最大交替和</em> </strong> <em class="lj">(在</em> <strong class="kn ir"> <em class="lj">之后重新索引</em> </strong> <em class="lj">子序列的元素)</em>。</p><p id="cf5b" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lq ky kz la ls lc ld le lu lg lh li ij bi translated">数组的<strong class="kn ir">子序列</strong>是通过删除一些元素(可能一个都没有)而不改变剩余元素的相对顺序，从原始数组生成的新数组。例如，<code class="fe nw nx ny nn b">[2,7,4]</code>是<code class="fe nw nx ny nn b">[4,2,3,7,2,1,4]</code>(带下划线的元素)的子序列，而<code class="fe nw nx ny nn b">[2,4,2]</code>不是。</p><pre class="lw lx ly lz gt nm nn no np aw nq bi"><span id="aeb4" class="ml jo iq nn b gy nr ns l nt nu"><strong class="nn ir">Input:</strong> nums = [4,2,5,3]<br/><strong class="nn ir">Output:</strong> 7<br/><strong class="nn ir">Explanation:</strong> It is optimal to choose the subsequence [4,2,5] with alternating sum (4 + 5) - 2 = 7.</span></pre><p id="81a2" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lq ky kz la ls lc ld le lu lg lh li ij bi translated"><strong class="kn ir">解决方案</strong></p><pre class="lw lx ly lz gt nm nn no np aw nq bi"><span id="94a7" class="ml jo iq nn b gy nr ns l nt nu">class Solution(object):<br/>    def maxAlternatingSum(self, nums):<br/>        """<br/>        :type nums: List[int]<br/>        :rtype: int<br/>        """<br/>        dpEven, dpOdd = 0, -float('inf')                                                                 <br/>        for num in nums:<br/>            dpEven, dpOdd = max(dpEven, dpOdd-num), max(dpOdd, dpEven+num, num)                          <br/>        return max(dpEven, dpOdd)</span></pre><h2 id="caf7" class="ml jo iq bd jp mm mn dn jt mo mp dp jx kw mq mr kb la ms mt kf le mu mv kj mw bi translated">买卖股票的最佳时机</h2><p id="f50a" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">给你一个数组<code class="fe nw nx ny nn b">prices</code>，其中<code class="fe nw nx ny nn b">prices[i]</code>是给定股票在<code class="fe nw nx ny nn b">ith</code>日的价格。</p><p id="cac6" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lq ky kz la ls lc ld le lu lg lh li ij bi translated">你想通过选择一个<strong class="kn ir">单日</strong>买入一只股票，并选择未来的<strong class="kn ir">不同日</strong>卖出该股票，从而实现利润最大化。</p><p id="4cc1" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lq ky kz la ls lc ld le lu lg lh li ij bi translated">返回<em class="lj">你从这笔交易中可以获得的最大利润</em>。如果你不能获得任何利润，返回<code class="fe nw nx ny nn b">0</code>。</p><pre class="lw lx ly lz gt nm nn no np aw nq bi"><span id="28cf" class="ml jo iq nn b gy nr ns l nt nu"><strong class="nn ir">Input:</strong> prices = [7,1,5,3,6,4]<br/><strong class="nn ir">Output:</strong> 5</span><span id="df48" class="ml jo iq nn b gy nv ns l nt nu"><strong class="nn ir">Explanation:</strong> Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.<br/>Note that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.</span></pre><p id="348d" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lq ky kz la ls lc ld le lu lg lh li ij bi translated"><strong class="kn ir">解决方案</strong></p><pre class="lw lx ly lz gt nm nn no np aw nq bi"><span id="d197" class="ml jo iq nn b gy nr ns l nt nu">class Solution(object):<br/>    def maxProfit(self, prices):<br/>        """<br/>        :type prices: List[int]<br/>        :rtype: int<br/>        """<br/>        maxSoFar = 0<br/>        maxEndingHere = 0<br/>        <br/>        for i in range(1, len(prices)):<br/>            maxEndingHere += prices[i] - prices[i-1]<br/>            <br/>            if maxEndingHere &lt; 0:<br/>                maxEndingHere = 0<br/>            <br/>            if maxSoFar &lt; maxEndingHere:<br/>                maxSoFar = maxEndingHere<br/>        <br/>        return maxSoFar</span></pre><h2 id="2254" class="ml jo iq bd jp mm mn dn jt mo mp dp jx kw mq mr kb la ms mt kf le mu mv kj mw bi translated">递增元素之间的最大差异</h2><p id="af98" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">给定一个大小为<code class="fe nw nx ny nn b">n</code>的<strong class="kn ir"> 0索引的</strong>整数数组<code class="fe nw nx ny nn b">nums</code>，求<code class="fe nw nx ny nn b">nums[i]</code>和<code class="fe nw nx ny nn b">nums[j]</code>(即<code class="fe nw nx ny nn b">nums[j] - nums[i]</code>)之间的<strong class="kn ir">最大差值</strong>，使得<code class="fe nw nx ny nn b">0 &lt;= i &lt; j &lt; n</code>和<code class="fe nw nx ny nn b">nums[i] &lt; nums[j]</code>。</p><p id="cbb2" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lq ky kz la ls lc ld le lu lg lh li ij bi translated">返回<em class="lj"/><strong class="kn ir"><em class="lj">最大差值</em> </strong> <em class="lj">。</em>如果没有此<code class="fe nw nx ny nn b">i</code>和<code class="fe nw nx ny nn b">j</code>则返回<code class="fe nw nx ny nn b">-1</code>。</p><pre class="lw lx ly lz gt nm nn no np aw nq bi"><span id="eea3" class="ml jo iq nn b gy nr ns l nt nu"><strong class="nn ir">Input:</strong> nums = [7,<strong class="nn ir">1</strong>,<strong class="nn ir">5</strong>,4]<br/><strong class="nn ir">Output:</strong> 4<br/><strong class="nn ir">Explanation:</strong><br/>The maximum difference occurs with i = 1 and j = 2, nums[j] - nums[i] = 5 - 1 = 4.<br/>Note that with i = 1 and j = 0, the difference nums[j] - nums[i] = 7 - 1 = 6, but i &gt; j, so it is not valid.</span></pre><p id="63c8" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lq ky kz la ls lc ld le lu lg lh li ij bi translated"><strong class="kn ir">解决方案</strong></p><pre class="lw lx ly lz gt nm nn no np aw nq bi"><span id="8690" class="ml jo iq nn b gy nr ns l nt nu">class Solution(object):<br/>    def maximumDifference(self, nums):<br/>        """<br/>        :type nums: List[int]<br/>        :rtype: int<br/>        """<br/>        numSoFar = nums[0]<br/>        maxDifference = 0<br/>        <br/>        for i in range(1, len(nums)):<br/>            maxDifference = max(maxDifference, nums[i] - numSoFar)<br/>            numSoFar = min(numSoFar, nums[i])<br/>        <br/>        if maxDifference == 0:<br/>            return -1<br/>        <br/>        return maxDifference</span></pre><h1 id="fb4e" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">时间复杂度</h1><p id="33b2" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">Kadane的算法在<strong class="kn ir"> O(n) </strong>时间内解决问题。如果不使用Kadane的算法来解决这类问题，那么它的复杂度将是<strong class="kn ir"> O(n的平方)。</strong></p><h1 id="1f97" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">结论</h1><p id="5260" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">Kadane的算法是一种迭代动态规划算法。它通过使用在先前位置的最大和子阵列结束来计算在特定位置的最大和子阵列结束。</p></div></div>    
</body>
</html>