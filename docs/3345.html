<html>
<head>
<title>Streaming SQL in Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js中的流SQL</h1>
<blockquote>原文：<a href="https://itnext.io/streaming-sql-in-node-js-eb419c5bd27e?source=collection_archive---------3-----------------------#2019-11-26">https://itnext.io/streaming-sql-in-node-js-eb419c5bd27e?source=collection_archive---------3-----------------------#2019-11-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/bf1e52b9211f5d67a97e3f42122746f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Luc9Lnb3S0L0RPeuEJ0ghg.jpeg"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">亨德里克·科内利森在<a class="ae jg" href="https://unsplash.com/s/photos/stream?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><div class=""/><p id="1d9a" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有时，您需要一种方法来查看数据库表中的每一行，并对其执行一些操作。</p><p id="e0b3" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">总的来说，SQL数据库非常擅长处理大量数据。我不认为可以夸张地说，我见过的大多数使用Hadoop的公司，只要给他们的Postgres/MySQL服务器添加一个索引或一些RAM就会更好。您可以在SQL中进行惊人的过滤和聚合。有时这些强大的操作不支持您需要的东西，有时您会希望处理node.js中的每一行</p><h1 id="0c79" class="le lf jj bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">异步迭代</h1><p id="d57b" class="pw-post-body-paragraph kg kh jj ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">想象以下场景:</p><ul class=""><li id="45d6" class="mh mi jj ki b kj kk kn ko kr mj kv mk kz ml ld mm mn mo mp bi translated">我们有一个数据库，其中包含大量来自Twitter的推文id。至少几十万。</li><li id="3b57" class="mh mi jj ki b kj mq kn mr kr ms kv mt kz mu ld mm mn mo mp bi translated">我们想请求Twitter上每条推文的点赞数</li><li id="8341" class="mh mi jj ki b kj mq kn mr kr ms kv mt kz mu ld mm mn mo mp bi translated">我们将此作为后台作业进行处理，不想占用太多内存。</li></ul><p id="8abc" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将希望对查询结果进行流式处理，以便从SQL中获取行。这个例子同样适用，不管你是对Postgres使用<code class="fe mv mw mx my b"><a class="ae jg" href="https://www.atdatabases.org/docs/pg.html" rel="noopener ugc nofollow" target="_blank">@databases/pg</a></code>，对MySQL使用<code class="fe mv mw mx my b"><a class="ae jg" href="https://www.atdatabases.org/docs/mysql.html" rel="noopener ugc nofollow" target="_blank">@databases/mysql</a></code>，还是对SQLite使用<code class="fe mv mw mx my b"><a class="ae jg" href="https://www.atdatabases.org/docs/sqlite.html" rel="noopener ugc nofollow" target="_blank">@databases/sqlite</a></code>:</p><pre class="mz na nb nc gt nd my ne nf aw ng bi"><span id="0504" class="nh lf jj my b gy ni nj l nk nl">// replace this with your db of choice<br/><strong class="my jk">import</strong> connect, {sql} <strong class="my jk">from</strong> <em class="nm">'@databases/pg'</em>;</span><span id="9043" class="nh lf jj my b gy nn nj l nk nl"><strong class="my jk">const</strong> db = connect();</span><span id="37cf" class="nh lf jj my b gy nn nj l nk nl"><strong class="my jk">export</strong> <strong class="my jk">default</strong> <strong class="my jk">async</strong> <strong class="my jk">function</strong> updateTweets() {<br/>  <strong class="my jk">const</strong> tweets = db.queryStream(<br/>    sql`<strong class="my jk">SELECT</strong> id, likes <strong class="my jk">FROM</strong> tweets;`<br/>  );<br/>  <strong class="my jk">for</strong> <strong class="my jk">await</strong> (<strong class="my jk">const</strong> tweet <strong class="my jk">of</strong> tweets) {<br/>    <strong class="my jk">const</strong> likes = <strong class="my jk">await</strong> getLikes(tweet.id);<br/>    <strong class="my jk">if</strong> (likes !== tweet.likes) {<br/>      <strong class="my jk">await</strong> db.query(<br/>        sql`<br/>          <strong class="my jk">UPDATE</strong> tweets<br/>          <strong class="my jk">SET</strong> likes = ${likes}<br/>          <strong class="my jk">WHERE</strong> id = ${tweet.id};<br/>        `<br/>      );<br/>    }<br/>  }<br/>}</span></pre><p id="1baf" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这将需要一个非常新的node版本，或者像babel这样的transpiler，以便支持异步迭代器提议。它将从我们的数据库中传输推文，在它开始告诉数据库减慢数据发送速度之前，允许缓冲一些推文。一旦我们收到一条推文，并完成了之前对推文的处理，我们就可以开始处理它。</p><h1 id="0a60" class="le lf jj bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">Node.js流</h1><p id="c25d" class="pw-post-body-paragraph kg kh jj ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">假设您需要将一个非常大的数据库表导出到一个CSV文件中，以便在其他系统中进行处理，例如一个分析工具，或者导入到一个会计包中。您可以等到获取了所有记录，但是一旦数据可用，就开始向客户端发送数据会更有效。如果他们是通过(相对)较慢的互联网连接下载的话，这一点尤其正确。</p><p id="7174" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个例子同样适用，不管你是用<code class="fe mv mw mx my b"><a class="ae jg" href="https://www.atdatabases.org/docs/pg.html" rel="noopener ugc nofollow" target="_blank">@databases/pg</a></code>写Postgres，还是用<code class="fe mv mw mx my b"><a class="ae jg" href="https://www.atdatabases.org/docs/mysql.html" rel="noopener ugc nofollow" target="_blank">@databases/mysql</a></code>写MySQL。它目前不支持SQLite。</p><pre class="mz na nb nc gt nd my ne nf aw ng bi"><span id="9b18" class="nh lf jj my b gy ni nj l nk nl">// replace this with your db of choice<br/><strong class="my jk">import</strong> connect, {sql} <strong class="my jk">from</strong> <em class="nm">'@databases/pg'</em>;<br/><strong class="my jk">import</strong> {Map} <strong class="my jk">from</strong> <em class="nm">'barrage'</em>;<strong class="my jk"><br/>import</strong> stringify <strong class="my jk">from</strong> <em class="nm">'csv-stringify'</em>;</span><span id="6f2d" class="nh lf jj my b gy nn nj l nk nl"><strong class="my jk">const</strong> db = connect();</span><span id="f6a6" class="nh lf jj my b gy nn nj l nk nl"><strong class="my jk">export default function</strong> getTweetsCSV() {<br/>  <strong class="my jk">const</strong> tweets = db.queryNodeStream(<br/>    sql`<strong class="my jk">SELECT</strong> id, likes <strong class="my jk">FROM</strong> tweets;`<br/>  );<br/>  <strong class="my jk">const</strong> map = <strong class="my jk">new</strong> Map(tweet =&gt; [tweet.id, tweet.likes]);<br/>  <strong class="my jk">const</strong> stringifier = stringify();<br/>  stringifier.write([<em class="nm">'Tweet ID'</em>, <em class="nm">'Likes'</em>]);<br/>  tweets.pipe(map).pipe(stringifier);<br/>  tweets.on(<em class="nm">'error'</em>, e =&gt; stringifier.emit(<em class="nm">'error'</em>, e);<br/>  map.on(<em class="nm">'error'</em>, e =&gt; stringifier.emit(<em class="nm">'error'</em>, e);<br/>  <strong class="my jk">return</strong> stringifier;<br/>}</span></pre><p id="d050" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里我们请求所有tweets作为node.js对象流。然后，我们将该流通过管道传输到一个<code class="fe mv mw mx my b">Map</code>流中，该流接受每一行，表示为一个对象，并以数组的形式返回该行。最后，我们将这个映射流通过管道传输到csv-stringifier流，该流为每一行接收一个数组，并输出一个csv文件。如果客户端支持gzip，我们可以进一步将流传输到<code class="fe mv mw mx my b">createGzip</code>。</p><h1 id="e62e" class="le lf jj bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="fcb6" class="pw-post-body-paragraph kg kh jj ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">这两种流选项都增加了很多灵活性。</p><ul class=""><li id="4165" class="mh mi jj ki b kj kk kn ko kr mj kv mk kz ml ld mm mn mo mp bi translated">99%的时候，你不想要流媒体。这使得您的代码更难理解，并且大多数时候您不需要将整个表拉下来进行处理。只需筛选出你感兴趣的几行，然后一气呵成地进行处理。</li><li id="57a8" class="mh mi jj ki b kj mq kn mr kr ms kv mt kz mu ld mm mn mo mp bi translated">当您想要对大型表中的每一行应用一个有副作用的操作时，使用异步迭代器方法(即<code class="fe mv mw mx my b">.queryStream</code>)</li><li id="c125" class="mh mi jj ki b kj mq kn mr kr ms kv mt kz mu ld mm mn mo mp bi translated">当您想要将大型表中的每一行序列化为字符串/二进制格式时，请使用节点流方法(即<code class="fe mv mw mx my b">.queryNodeStream</code>)。</li></ul><figure class="mz na nb nc gt iv"><div class="bz fp l di"><div class="no np l"/></div></figure></div></div>    
</body>
</html>