<html>
<head>
<title>Building a game with TypeScript. Input system 1/3</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用TypeScript构建游戏。输入系统1/3</h1>
<blockquote>原文：<a href="https://itnext.io/building-a-game-with-typescript-input-system-1-3-46d0b3dd7662?source=collection_archive---------6-----------------------#2020-12-17">https://itnext.io/building-a-game-with-typescript-input-system-1-3-46d0b3dd7662?source=collection_archive---------6-----------------------#2020-12-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="f54f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">《T4》系列教程的第五章讲述了如何用类型脚本和本地浏览器API从头开始构建游戏</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/4d0e47a1b3418261f9c3104e8c98d092.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cTvohHkywdqRXolzehJSag.jpeg"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated"><a class="ae kl" href="https://www.freepik.com/vectors/design" rel="noopener ugc nofollow" target="_blank">由www.freepik.com自由派创作的设计向量</a></figcaption></figure><p id="0b06" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你好。欢迎来到“用TypeScript构建游戏”系列教程的第五章！在这里，我们学习如何使用原生浏览器API、普通类型脚本、测试驱动开发和可靠的设计模式来构建一个简单的回合制游戏。</p><p id="6f15" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们花了<a class="ae kl" href="https://levelup.gitconnected.com/building-a-game-with-typescript-colors-and-layers-337b0e4d71f?sk=45ea8fe1af4d87bbd4b1b12b43c4557b" rel="noopener ugc nofollow" target="_blank">最后一章</a>来讨论<code class="fe lc ld le lf b">Ships</code>:我们学习了如何利用我们的小<code class="fe lc ld le lf b">Render system</code>来绘制它们，讨论了冲突和团队，介绍了几个助手，比如<code class="fe lc ld le lf b">Color</code>和<code class="fe lc ld le lf b">Fleet</code>。</p><p id="573c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但到目前为止，这个游戏相当…死气沉沉。当然，我们渲染了相当多的元素，但是我们的玩家没有办法与游戏互动。是时候修复这个不幸的疏忽了！在第五章“输入系统”中，我们将建立一个简单的系统，让玩家有机会与游戏交流。您可以在这里找到本系列的其他章节:</p><ul class=""><li id="bd9c" class="lg lh iq jp b jq jr ju jv jy li kc lj kg lk kk ll lm ln lo bi translated"><a class="ae kl" href="https://medium.com/@gregsolo/gamedev-patterns-and-algorithms-in-action-with-typescript-d29b913858e" rel="noopener">简介</a></li><li id="cfdb" class="lg lh iq jp b jq lp ju lq jy lr kc ls kg lt kk ll lm ln lo bi translated"><a class="ae kl" href="https://medium.com/@gregsolo/entity-component-system-in-action-with-typescript-f498ca82a08e" rel="noopener">第一章实体和部件</a></li><li id="601a" class="lg lh iq jp b jq lp ju lq jy lr kc ls kg lt kk ll lm ln lo bi translated">第二章。游戏循环(<a class="ae kl" href="https://medium.com/@gregsolo/gamedev-patterns-and-algorithms-with-typescript-game-loop-part-1-2-699919bb9b71" rel="noopener">第一部分</a>，<a class="ae kl" href="https://medium.com/@gregsolo/gamedev-patterns-and-algorithms-in-action-with-typescript-game-loop-2-2-c0d57a8e5ec2" rel="noopener">第二部分</a>)</li><li id="1ecb" class="lg lh iq jp b jq lp ju lq jy lr kc ls kg lt kk ll lm ln lo bi translated">第三章。绘制网格(<a class="ae kl" href="https://medium.com/@gregsolo/building-a-game-with-typescript-drawing-grid-1-5-aaf68797a0bb" rel="noopener">第一部分</a>、<a class="ae kl" href="https://medium.com/javascript-in-plain-english/building-a-game-with-typescript-drawing-grid-2-5-206555719490" rel="noopener">第二部分</a>、<a class="ae kl" href="https://medium.com/@gregsolo/building-a-game-with-typescript-drawing-grid-3-5-1fb94211c4aa" rel="noopener">第三部分</a>、<a class="ae kl" href="https://medium.com/@gregsolo/building-a-game-with-typescript-iii-drawing-grid-4-5-398af1dd638d" rel="noopener">第四部分</a>、<a class="ae kl" href="https://medium.com/@gregsolo/building-a-game-with-typescript-drawing-grid-5-5-49454917b3af" rel="noopener">第五部分</a>)</li><li id="33f8" class="lg lh iq jp b jq lp ju lq jy lr kc ls kg lt kk ll lm ln lo bi translated">第四章。船舶(<a class="ae kl" href="https://medium.com/@gregsolo/building-a-game-with-typescript-colors-and-layers-337b0e4d71f" rel="noopener">第一部分</a>、<a class="ae kl" href="https://medium.com/@gregsolo/building-a-game-with-typescript-team-and-fleet-f223d39e9248" rel="noopener">第二部分</a>、<a class="ae kl" href="https://medium.com/@gregsolo/building-a-game-with-typescript-drawing-ship-14e6c19caa38" rel="noopener">第三部分</a>、<a class="ae kl" href="https://gregsolo.medium.com/building-a-game-with-typescript-ship-and-locomotion-4f5969675993" rel="noopener">第四部分</a>)</li><li id="ec0a" class="lg lh iq jp b jq lp ju lq jy lr kc ls kg lt kk ll lm ln lo bi translated">第五章输入系统(第一部分，<a class="ae kl" href="https://gregsolo.medium.com/building-a-game-with-typescript-input-system-2-3-cd419e36027c" rel="noopener">第二部分</a>，<a class="ae kl" href="https://gregsolo.medium.com/building-a-game-with-typescript-input-system-3-3-8492552579f1" rel="noopener">第三部分</a></li><li id="19d4" class="lg lh iq jp b jq lp ju lq jy lr kc ls kg lt kk ll lm ln lo bi translated">第六章。寻路和移动(<a class="ae kl" href="https://blog.gregsolo.me/articles/building-a-game-with-typescript-pathfinding-and-movement-17-introduction" rel="noopener ugc nofollow" target="_blank">第一部分</a>、<a class="ae kl" href="https://blog.gregsolo.me/articles/building-a-game-with-typescript-pathfinding-and-movement-27-highlighting-locomotion-range" rel="noopener ugc nofollow" target="_blank">第二部分</a>、<a class="ae kl" href="https://blog.gregsolo.me/articles/building-a-game-with-typescript-pathfinding-and-movement-37-graph-and-priority-queue" rel="noopener ugc nofollow" target="_blank">第三部分</a>、<a class="ae kl" href="https://blog.gregsolo.me/articles/building-a-game-with-typescript-pathfinding-and-movement-47-pathfinder" rel="noopener ugc nofollow" target="_blank">第四部分</a>、<a class="ae kl" href="https://blog.gregsolo.me/articles/building-a-game-with-typescript-pathfinding-and-movement-57-finding-the-path" rel="noopener ugc nofollow" target="_blank">第五部分</a>、<a class="ae kl" href="https://blog.gregsolo.me/articles/building-a-game-with-typescript-pathfinding-and-movement-6-instant-locomotion" rel="noopener ugc nofollow" target="_blank">第六部分</a>、<a class="ae kl" href="https://blog.gregsolo.me/articles/pathfinding-and-movement-7-animated-locomotion" rel="noopener ugc nofollow" target="_blank">第七部分</a>)</li><li id="dd68" class="lg lh iq jp b jq lp ju lq jy lr kc ls kg lt kk ll lm ln lo bi translated">第七章。玛奇纳州</li><li id="0682" class="lg lh iq jp b jq lp ju lq jy lr kc ls kg lt kk ll lm ln lo bi translated">第八章。攻击系统:生命和伤害</li><li id="6aa5" class="lg lh iq jp b jq lp ju lq jy lr kc ls kg lt kk ll lm ln lo bi translated">第九章。比赛的输赢</li><li id="5213" class="lg lh iq jp b jq lp ju lq jy lr kc ls kg lt kk ll lm ln lo bi translated">第十章敌人AI</li></ul><blockquote class="lu lv lw"><p id="817d" class="jn jo lx jp b jq jr js jt ju jv jw jx ly jz ka kb lz kd ke kf ma kh ki kj kk ij bi translated">随意切换到<a class="ae kl" href="https://github.com/soloschenko-grigoriy/gamedev-patterns-ts" rel="noopener ugc nofollow" target="_blank">库</a>的<code class="fe lc ld le lf b">ship-4</code>分支。它包含了前几篇文章的工作成果，是这篇文章的一个很好的起点。</p></blockquote></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><h1 id="1754" class="mi mj iq bd mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf bi translated">目录</h1><ol class=""><li id="0378" class="lg lh iq jp b jq ng ju nh jy ni kc nj kg nk kk nl lm ln lo bi translated">“活动”节点</li><li id="a63a" class="lg lh iq jp b jq lp ju lq jy lr kc ls kg lt kk nl lm ln lo bi translated">收听事件</li><li id="4ef2" class="lg lh iq jp b jq lp ju lq jy lr kc ls kg lt kk nl lm ln lo bi translated">节点，居住者</li><li id="fe70" class="lg lh iq jp b jq lp ju lq jy lr kc ls kg lt kk nl lm ln lo bi translated">点击点</li><li id="e419" class="lg lh iq jp b jq lp ju lq jy lr kc ls kg lt kk nl lm ln lo bi translated">全球和本地</li><li id="3b63" class="lg lh iq jp b jq lp ju lq jy lr kc ls kg lt kk nl lm ln lo bi translated">结论</li></ol></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><h1 id="4c78" class="mi mj iq bd mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf bi translated">“活动”节点</h1><p id="1530" class="pw-post-body-paragraph jn jo iq jp b jq ng js jt ju nh jw jx jy nm ka kb kc nn ke kf kg no ki kj kk ij bi translated">当然，玩家可能有各种各样的方式与游戏互动。但是首先，玩家应该能够通过点击这个节点将当前活动的<code class="fe lc ld le lf b">Ship</code>移动到一个特定的<code class="fe lc ld le lf b">Node</code>。这是我们游戏的核心玩法:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi np"><img src="../Images/51c91fcc5688359637ee64565ce3d316.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*twb3OLuV9kKGUE9umFWhsw.gif"/></div></figure><p id="e609" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，这个功能背后的大量逻辑已经超出了本章的范围，比如哪个<code class="fe lc ld le lf b">Ship</code>被认为是<em class="lx">活动的</em>，哪个<code class="fe lc ld le lf b">Node</code>可以根据<code class="fe lc ld le lf b">Ship</code>运动的<em class="lx">范围</em>来点击，<code class="fe lc ld le lf b">Ships</code>的渐进动画运动等等。我们将在以后的文章中讨论这些主题，现在，我们的重点是交互的实际情况。换句话说，我们将构建一个系统，它可以通知游戏的不同部分玩家点击了什么。我们不关心击键或手势或几乎任何其他类型的输入，因为这里的核心游戏是关于点击东西。</p><p id="60a3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了确认我们的<em class="lx">输入系统</em>工作正常，让我们使用游戏的一个过于简化的部分版本。让我们假设点击<code class="fe lc ld le lf b">Node</code>就可以激活它。根据不同的状态，<code class="fe lc ld le lf b">Node</code>会有不同的颜色:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/36055e9b61be8bf2a20db02865d2512c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1100/1*MmAqoXFoZyBDWZX1fap4qg.gif"/></div></figure><p id="4cc7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">再次对于这一章，我们忽略了很多事情:<em class="lx">玩家</em>是否真的点击了<code class="fe lc ld le lf b">Node</code>，<em class="lx">到底<code class="fe lc ld le lf b">Node</code>应该如何反应</em>等等。我们只要一点击<code class="fe lc ld le lf b">Node</code>就高亮显示它。</p><p id="ae79" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了实现这一点，我们可以从引入<code class="fe lc ld le lf b">Node</code>实体的<code class="fe lc ld le lf b">IsActive</code>属性开始。这是一个临时的解决方案，我们将在以后的章节中去掉它:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="7574" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，让我们为<code class="fe lc ld le lf b">Node</code>的活动和非活动状态设置专用颜色:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="100f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，我们来教<code class="fe lc ld le lf b">NodeDrawComponent</code>尊重这种状态:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="ff40" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当然，我们应该更新测试来反映这些变化:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="ff0f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此时，我们的代码应该通过<code class="fe lc ld le lf b">npm start</code>成功编译，并且所有测试应该通过<code class="fe lc ld le lf b">npm t</code>:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi nt"><img src="../Images/44a8ebed7a688bcb1a8b4114c21d1d86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V3DtsOpJ-P0OC5KLd7xcjQ.png"/></div></div></figure><p id="95ba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，游戏必须有一种方法来识别哪个特定的<code class="fe lc ld le lf b">Node</code>被点击了。还有什么更简单的？让我们给<code class="fe lc ld le lf b">Node</code>添加一个好的旧事件监听器，然后就完事了！</p></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><h1 id="52a7" class="mi mj iq bd mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf bi translated">收听事件</h1><p id="6a31" class="pw-post-body-paragraph jn jo iq jp b jq ng js jt ju nh jw jx jy nm ka kb kc nn ke kf kg no ki kj kk ij bi translated">不幸的是，这并不容易。<code class="fe lc ld le lf b">addEventListener</code>处理DOM节点。但是，如果您还记得的话，在<code class="fe lc ld le lf b">canvas</code>中没有DOM元素。在绘制完元素后，它会立即失去对绘制元素的跟踪。这很好，因为它允许浏览器不在内存中保存所有这些圆形和矩形的信息。但对我们来说不幸的是，这意味着我们必须找到一种手动跟踪事件的方法。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi nu"><img src="../Images/c13afe65ae85115a1a2fb43d1a4d6209.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1CYAr1Ij2POWyloQmxmEcQ.jpeg"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated"><a class="ae kl" href="https://www.freepik.com/vectors/music" rel="noopener ugc nofollow" target="_blank">rawpixel.com——www.freepik.com</a>创造的音乐向量</figcaption></figure><p id="a875" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">希望我们不必重建整个事件系统。正如我提到的，游戏只关注“点击”事件，我们可以忽略其他的输入。然而，没有DOM我们怎么能听点击呢？</p><p id="dade" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们把这个问题分成两部分。首先，我们必须<em class="lx">跟踪</em>对游戏特定元素的点击:例如<code class="fe lc ld le lf b">Ship</code>或<code class="fe lc ld le lf b">Node</code>。其次，我们需要一种方法来<em class="lx">通知</em>这些点击发生的元素。我们不关心元素如何对事件做出反应，那是元素本身的责任。</p><p id="5e5e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要跟踪玩家点击特定元素的事实，我们需要知道:</p><p id="0859" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">a)点击点:点击时鼠标的“位置”</p><p id="8d37" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">b)任何元件的位置。</p><p id="9918" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果点击点在某个元素所占据的区域之内，那么可以安全地假设点击是在这个元素上进行的。z-space也有一个复杂之处(一些元素可能在另一个元素的后面，这意味着用户不可能点击它们)，但是为了游戏的目的，我们可以忽略这个细微差别。</p></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><h1 id="073f" class="mi mj iq bd mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf bi translated">节点，居住者</h1><p id="115f" class="pw-post-body-paragraph jn jo iq jp b jq ng js jt ju nh jw jx jy nm ka kb kc nn ke kf kg no ki kj kk ij bi translated">我们的<code class="fe lc ld le lf b">Node</code>实体有<code class="fe lc ld le lf b">Start</code>和<code class="fe lc ld le lf b">End</code>属性，存储关于<code class="fe lc ld le lf b">Node</code>位置的信息。如果点击点出现在<code class="fe lc ld le lf b">Start</code>和<code class="fe lc ld le lf b">End</code>之间的矩形内，这意味着玩家点击了这个<code class="fe lc ld le lf b">Node</code>。我们可以定义一个助手方法来稍微缓解一下:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="b7a3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">方法<code class="fe lc ld le lf b">Occupies</code>简单地检查所提供的点是否确实在这个特定<code class="fe lc ld le lf b">Node</code>的区域内。让我们用测试快速覆盖它:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="3cdd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">还记得我们定义这个测试<code class="fe lc ld le lf b">Node</code>从点<code class="fe lc ld le lf b">(1, 2)</code>开始到<code class="fe lc ld le lf b">(5, 6)</code>结束吗？因此，自然地，点<code class="fe lc ld le lf b">(6, 2)</code>和<code class="fe lc ld le lf b">(3, 7)</code>应该在<code class="fe lc ld le lf b">Node</code>区域之外，而<code class="fe lc ld le lf b">(3, 2)</code>应该在内部。</p><p id="ca56" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此时，我们的代码应该通过<code class="fe lc ld le lf b">npm start</code>成功编译，并且所有测试应该通过<code class="fe lc ld le lf b">npm t</code>:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi nv"><img src="../Images/53243188dd08d102a4710eeb4bdd70a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7oV3NRTdqidjcyZXILseMw.png"/></div></div></figure></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><h1 id="58b2" class="mi mj iq bd mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf bi translated">点击点</h1><p id="e9fd" class="pw-post-body-paragraph jn jo iq jp b jq ng js jt ju nh jw jx jy nm ka kb kc nn ke kf kg no ki kj kk ij bi translated">但是我们如何识别实际的点击点呢？嗯，即使<code class="fe lc ld le lf b">canvas</code>没有DOM节点的概念，我们仍然可以利用一个漂亮的DOM事件系统。我们可以监听顶层DOM元素的事件:<em class="lx"> body </em>，而不是等待游戏中每个元素的事件。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi nu"><img src="../Images/9e1eab39ec17495340c558c679f30aeb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LGl_zTLl6eCEkl7odwNH4Q.jpeg"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated"><a class="ae kl" href="https://www.freepik.com/vectors/arrow" rel="noopener ugc nofollow" target="_blank">宏向量www.freepik.com创建的箭头向量</a></figcaption></figure><p id="79be" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这将有效地给我们一个机制，当<em class="lx">任何</em>点击发生时，我们将得到通知。然后，我们可以通过比较点击时鼠标的位置与<code class="fe lc ld le lf b">Nodes</code>、<code class="fe lc ld le lf b">Ships</code>或任何其他元素占据的区域，来定位玩家点击的确切位置。幸运的是，浏览器很好地为我们提供了在<code class="fe lc ld le lf b">MouseEvent</code>中访问这个点的方法，这是鼠标事件的<code class="fe lc ld le lf b">addEventListener</code>回调的一个参数。</p><p id="a154" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，我们可以从在<code class="fe lc ld le lf b">Node</code>实体中添加一个事件监听器开始:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="d1b1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦<code class="fe lc ld le lf b">Node</code>醒来，它就开始监听页面上的所有点击。但是它只关心那些发生在被<code class="fe lc ld le lf b">Node</code>占据的区域内的事件:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="4634" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里我们从<code class="fe lc ld le lf b">MouseEvent</code>获得一个点击点，并检查它是否确实在<code class="fe lc ld le lf b">Node</code>边界内。如果是这样，我们就激活这个<code class="fe lc ld le lf b">Node</code>。</p><p id="7609" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">做得好！然而，当您在浏览器中启动游戏并尝试点击任何<code class="fe lc ld le lf b">Node</code>时，您可能会注意到有些东西不对劲:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/42b646b9b5594790da4f8c695e9f38df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1056/1*MrHi93-JvVaUG7PaqOOnuQ.gif"/></div></figure><p id="d151" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">出于某种原因，游戏突出显示了任意的<code class="fe lc ld le lf b">Node</code>而不是我们点击的那个。点击点是这种不可靠行为的罪魁祸首。</p><p id="4f7c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您还记得，我们将元素<code class="fe lc ld le lf b">Nodes</code>和<code class="fe lc ld le lf b">Ships</code>的位置设置为相对于<code class="fe lc ld le lf b">canvas</code>的的<em class="lx">。换句话说，它是一个<em class="lx">局部</em>坐标，而<code class="fe lc ld le lf b">MouseEvent</code>给我们一个<em class="lx">全局</em>坐标。<em class="lx">全局坐标系</em>从浏览器的左上角开始。我们的<em class="lx">局部坐标系</em>从<code class="fe lc ld le lf b">canvas</code>开始的地方开始。<code class="fe lc ld le lf b">canvas</code>和浏览器边缘之间的偏移越大，<code class="fe lc ld le lf b">e.clientX</code>和<code class="fe lc ld le lf b">e.clientY</code>就变得越不相关。</em></p></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><h1 id="ca1e" class="mi mj iq bd mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf bi translated">全球和本地</h1><p id="8541" class="pw-post-body-paragraph jn jo iq jp b jq ng js jt ju nh jw jx jy nm ka kb kc nn ke kf kg no ki kj kk ij bi translated">我们需要的是一种方法来<em class="lx">转换</em>一个全局的点击点，使其与我们的局部坐标系对齐:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="dec3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">计算是琐碎的:我们仅仅考虑<em class="lx">这个</em> <code class="fe lc ld le lf b">canvas</code>从浏览器左上角的偏移量，考虑滚动。如果提供的全局点远离<code class="fe lc ld le lf b">canvas</code>，我们返回<code class="fe lc ld le lf b">null</code>。</p><blockquote class="lu lv lw"><p id="f2e7" class="jn jo lx jp b jq jr js jt ju jv jw jx ly jz ka kb lz kd ke kf ma kh ki kj kk ij bi translated">注意，由于我们有多个画布层，这些计算对特定的画布有效。但是因为我们所有的层都从同一点开始，所以我们是安全的。</p></blockquote><p id="a606" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当然，我们应该用测试来覆盖这个功能。我们可以模仿<code class="fe lc ld le lf b">getBoundingClientRect</code>来伪造<code class="fe lc ld le lf b">canvas</code>的位置，有效地假装它在全球坐标系中从<code class="fe lc ld le lf b">(20,20)</code>开始到<code class="fe lc ld le lf b">(500,500)</code>结束:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="04eb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们有两个案例要测试。首先，如果提供的<code class="fe lc ld le lf b">point</code>不在<code class="fe lc ld le lf b">canvas</code>边界内，我们必须确保我们的方法返回<code class="fe lc ld le lf b">null</code>:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="93bb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">其次，我们可以检查<em class="lx">全局</em>点是否成功转换为<em class="lx">局部</em>系统:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="a0a0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此时，我们的代码应该成功地用<code class="fe lc ld le lf b">npm start</code>编译，并且所有的测试应该通过<code class="fe lc ld le lf b">npm t</code>:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi nx"><img src="../Images/89980771ead131af6db02e45a32aaf2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u-9tnOM8AoNSwCmpdv_7lw.png"/></div></div></figure><p id="d8a2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，我们可以应用<code class="fe lc ld le lf b">CalcLocalPointFrom</code>来变换点击点:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="37d8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在<code class="fe lc ld le lf b">Nodes</code>应该被正确突出显示，不管<code class="fe lc ld le lf b">canvas</code>的偏移量有多大:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/0c6429d15479729bf0065d7dc6fe49f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1046/1*jgT0G71dzzXcUohF2p7AUQ.gif"/></div></figure></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><h1 id="37bc" class="mi mj iq bd mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf bi translated">结论</h1><p id="65b2" class="pw-post-body-paragraph jn jo iq jp b jq ng js jt ju nh jw jx jy nm ka kb kc nn ke kf kg no ki kj kk ij bi translated">干得好！我们为我们的小“输入系统”做了第一轮“脏”代码。大量的问题仍然没有答案。我们正在收听每一个<code class="fe lc ld le lf b">Node</code>的事件。这意味着，我们对同一事件反应36次(这是我们现在拥有的<code class="fe lc ld le lf b">Nodes</code>的数量)？有没有更好的办法？</p><p id="0e55" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，如果我们有其他可点击的东西，而不仅仅是可点击的东西呢？我们必须为每个我们想要点击的元素重复我们刚刚在<code class="fe lc ld le lf b">Awake</code>中写的代码吗？我们将在下次开始回答所有这些问题<a class="ae kl" href="https://gregsolo.medium.com/building-a-game-with-typescript-input-system-2-3-cd419e36027c" rel="noopener">。到时候见！</a></p><p id="b94a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我真的很想听听你的想法！如果你有任何<strong class="jp ir">的评论</strong>、<strong class="jp ir">的建议</strong>、<strong class="jp ir">的问题</strong>，或者任何其他<strong class="jp ir">的反馈</strong>，不要犹豫给我发私信或者在下面留下评论！如果你喜欢这个系列，<strong class="jp ir">请与他人分享</strong>。它真的帮助我继续努力。感谢您的阅读，我们下次再见！</p></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><p id="8b6d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="lx">这是系列教程</em> <strong class="jp ir"> <em class="lx">用TypeScript </em> </strong> <em class="lx">构建游戏中的第五章“输入系统”。其他章节可在这里:</em></p><ul class=""><li id="dfb2" class="lg lh iq jp b jq jr ju jv jy li kc lj kg lk kk ll lm ln lo bi translated"><a class="ae kl" href="https://medium.com/@gregsolo/gamedev-patterns-and-algorithms-in-action-with-typescript-d29b913858e" rel="noopener">简介</a></li><li id="aa2c" class="lg lh iq jp b jq lp ju lq jy lr kc ls kg lt kk ll lm ln lo bi translated"><a class="ae kl" href="https://medium.com/@gregsolo/entity-component-system-in-action-with-typescript-f498ca82a08e" rel="noopener">第一章实体和组件</a></li><li id="827f" class="lg lh iq jp b jq lp ju lq jy lr kc ls kg lt kk ll lm ln lo bi translated">第二章。游戏循环(<a class="ae kl" href="https://medium.com/@gregsolo/gamedev-patterns-and-algorithms-with-typescript-game-loop-part-1-2-699919bb9b71" rel="noopener">第一部分</a>，<a class="ae kl" href="https://medium.com/@gregsolo/gamedev-patterns-and-algorithms-in-action-with-typescript-game-loop-2-2-c0d57a8e5ec2" rel="noopener">第二部分</a>)</li><li id="4031" class="lg lh iq jp b jq lp ju lq jy lr kc ls kg lt kk ll lm ln lo bi translated">第三章。绘制网格(<a class="ae kl" href="https://medium.com/@gregsolo/building-a-game-with-typescript-drawing-grid-1-5-aaf68797a0bb" rel="noopener">第1部分</a>、<a class="ae kl" href="https://medium.com/javascript-in-plain-english/building-a-game-with-typescript-drawing-grid-2-5-206555719490" rel="noopener">第2部分</a>、<a class="ae kl" href="https://medium.com/@gregsolo/building-a-game-with-typescript-drawing-grid-3-5-1fb94211c4aa" rel="noopener">第3部分</a>、<a class="ae kl" href="https://medium.com/@gregsolo/building-a-game-with-typescript-iii-drawing-grid-4-5-398af1dd638d" rel="noopener">第4部分</a>、<a class="ae kl" href="https://medium.com/@gregsolo/building-a-game-with-typescript-drawing-grid-5-5-49454917b3af" rel="noopener">第5部分</a>)</li><li id="078e" class="lg lh iq jp b jq lp ju lq jy lr kc ls kg lt kk ll lm ln lo bi translated">第四章。舰船(<a class="ae kl" href="https://medium.com/@gregsolo/building-a-game-with-typescript-colors-and-layers-337b0e4d71f" rel="noopener">第一部分</a>、<a class="ae kl" href="https://medium.com/@gregsolo/building-a-game-with-typescript-team-and-fleet-f223d39e9248" rel="noopener">第二部分</a>、<a class="ae kl" href="https://medium.com/@gregsolo/building-a-game-with-typescript-drawing-ship-14e6c19caa38" rel="noopener">第三部分</a>、<a class="ae kl" href="https://gregsolo.medium.com/building-a-game-with-typescript-ship-and-locomotion-4f5969675993" rel="noopener">第四部分</a>)</li><li id="f586" class="lg lh iq jp b jq lp ju lq jy lr kc ls kg lt kk ll lm ln lo bi translated">第五章输入系统(第一部分，<a class="ae kl" href="https://gregsolo.medium.com/building-a-game-with-typescript-input-system-2-3-cd419e36027c" rel="noopener">第二部分</a>，<a class="ae kl" href="https://gregsolo.medium.com/building-a-game-with-typescript-input-system-3-3-8492552579f1" rel="noopener">第三部分</a></li><li id="f453" class="lg lh iq jp b jq lp ju lq jy lr kc ls kg lt kk ll lm ln lo bi translated">第六章。寻路和移动(<a class="ae kl" href="https://blog.gregsolo.me/articles/building-a-game-with-typescript-pathfinding-and-movement-17-introduction" rel="noopener ugc nofollow" target="_blank">第一部分</a>、<a class="ae kl" href="https://blog.gregsolo.me/articles/building-a-game-with-typescript-pathfinding-and-movement-27-highlighting-locomotion-range" rel="noopener ugc nofollow" target="_blank">第二部分</a>、<a class="ae kl" href="https://blog.gregsolo.me/articles/building-a-game-with-typescript-pathfinding-and-movement-37-graph-and-priority-queue" rel="noopener ugc nofollow" target="_blank">第三部分</a>、<a class="ae kl" href="https://blog.gregsolo.me/articles/building-a-game-with-typescript-pathfinding-and-movement-47-pathfinder" rel="noopener ugc nofollow" target="_blank">第四部分</a>、<a class="ae kl" href="https://blog.gregsolo.me/articles/building-a-game-with-typescript-pathfinding-and-movement-57-finding-the-path" rel="noopener ugc nofollow" target="_blank">第五部分</a>、<a class="ae kl" href="https://blog.gregsolo.me/articles/building-a-game-with-typescript-pathfinding-and-movement-6-instant-locomotion" rel="noopener ugc nofollow" target="_blank">第六部分</a>、<a class="ae kl" href="https://blog.gregsolo.me/articles/pathfinding-and-movement-7-animated-locomotion" rel="noopener ugc nofollow" target="_blank">第七部分</a>)</li><li id="b561" class="lg lh iq jp b jq lp ju lq jy lr kc ls kg lt kk ll lm ln lo bi translated">第七章。玛奇纳州</li><li id="21c2" class="lg lh iq jp b jq lp ju lq jy lr kc ls kg lt kk ll lm ln lo bi translated">第八章。攻击系统:生命和伤害</li><li id="1062" class="lg lh iq jp b jq lp ju lq jy lr kc ls kg lt kk ll lm ln lo bi translated">第九章。比赛的输赢</li><li id="0efe" class="lg lh iq jp b jq lp ju lq jy lr kc ls kg lt kk ll lm ln lo bi translated">第十章敌人AI</li></ul></div></div>    
</body>
</html>