<html>
<head>
<title>Coding the 5 Basic RESTful actions for JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为JavaScript编写5个基本的RESTful动作</h1>
<blockquote>原文：<a href="https://itnext.io/coding-the-5-basic-restful-actions-for-javascript-c25279483e4f?source=collection_archive---------6-----------------------#2018-06-14">https://itnext.io/coding-the-5-basic-restful-actions-for-javascript-c25279483e4f?source=collection_archive---------6-----------------------#2018-06-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/c17fa74291a409663be4b50473fd0351.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7nSQObbqsoKZmjtMHAhDXA.jpeg"/></div></div></figure><p id="aa5d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">RESTful 模式很棒，它简化了我们的API和网站，让开发者不再试图用他们的URL耍花招。然而，对于程序员来说，如何将它应用到前端通常是很困难的。这看起来太多了，但是通过分解，我们会发现这是从数据库中获取数据的最佳方式。</p><h1 id="d868" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">前端的休息甚至比后端更简单</h1><p id="9ddc" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">本质上，休息很简单。你想显示所有的东西，显示一个东西，制作一个东西，更新一个东西，或者销毁一个东西。您通常还需要显示用于创建和更新的表单，所以这是另外两条途径。但是对于JavaScript，尤其是一个单页应用程序，我们真的不需要担心这两个，我们只需要坚持做真正工作的五个。</p><h1 id="d3e5" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">设置和概述</h1><p id="504b" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">我们会做5个方法:<code class="fe ma mb mc md b">getAll()</code>、<code class="fe ma mb mc md b">getOne()</code>、<code class="fe ma mb mc md b">create()</code>、<code class="fe ma mb mc md b">update()</code>，当然还有大家最喜欢的<code class="fe ma mb mc md b">destroy()</code>。我将假设您有一个基本的服务器可以使用，并且对<a class="ae me" href="https://developers.google.com/web/updates/2015/03/introduction-to-fetch" rel="noopener ugc nofollow" target="_blank"> fetch </a>有相当好的理解。如果你没有，这里有我的文章<a class="ae me" href="https://medium.com/@mikecronin92/using-json-server-to-create-a-restful-server-in-5-seconds-78b85ccf832b" rel="noopener">关于使用</a><a class="ae me" href="https://github.com/typicode/json-server" rel="noopener ugc nofollow" target="_blank"> JSON服务器</a>快速设置一个假的本地RESTful服务器，还有另一篇<a class="ae me" rel="noopener ugc nofollow" target="_blank" href="/that-data-looks-so-fetching-on-you-understanding-the-js-fetch-api-880eae0c8d25">关于使用</a>T5。或者就用谷歌吧，这是个自由的国度，活一点。</p><p id="bf1d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将启动的应用程序只是一个简单的任务列表。我们的数据库将有一个任务列表。我们不会实际显示或设计或显示我们的任务，我们现在只是在控制台上玩玩。我们现在也不会担心错误处理。</p><h1 id="3a4c" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">有一种方法可以让他们都</h1><p id="5c81" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">这是我们最简单的方法，但却非常重要。它的工作是显示你的数据库中的一切。这是:</p><pre class="mf mg mh mi gt mj md mk ml aw mm bi"><span id="b7f1" class="mn ky iq md b gy mo mp l mq mr">function getAll() {<br/>  return fetch("<a class="ae me" href="http://localhost:3000/tasks" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/tasks</a>")<br/>    .then((response) =&gt; response.json())<br/>}</span></pre><p id="1f02" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们正在返回我们得到的任何东西，因为我们实际上想在函数之外使用这个值。然后，我们从数据库中获取REST索引路由，这将返回一个解析的承诺，其值是一个<a class="ae me" href="https://developer.mozilla.org/en-US/docs/Web/API/Response" rel="noopener ugc nofollow" target="_blank">响应对象</a>。为了实际获取数据，我们使用<code class="fe ma mb mc md b">json()</code>响应方法返回一个JSON对象。记住，我们<em class="kw">正在</em>返回最终值，当箭头函数只有一行长时，它们有一个隐式返回。</p><p id="e033" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这或多或少是所有方法的模式。我们将获取一个响应对象，然后用JSON对象作为值返回一个解析的承诺。我们的代码稍后可以通过简单地附加另一个<code class="fe ma mb mc md b">then()</code>来处理这个问题，比如:<code class="fe ma mb mc md b">getAll().then( /* work with our JSON object*/)</code></p><h1 id="9cb0" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">现在只拿一个</h1><p id="decc" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">好的，这是我们所有的任务，但是如果我们只想要一个呢？基本上是一样的:</p><pre class="mf mg mh mi gt mj md mk ml aw mm bi"><span id="f14d" class="mn ky iq md b gy mo mp l mq mr">function getOne(id) {<br/>  return fetch("<a class="ae me" href="http://localhost:3000/tasks" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/tasks</a>/" + id)<br/>    .then((response) =&gt; response.json())<br/>}</span></pre><p id="db56" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">唯一的实际变化是url，我们传入的id将引导我们到那个资源的路由。但是等等，这段代码还没干；我们的基本url，"<a class="ae me" href="http://localhost:3000/tasks" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/tasks</a>"与上一个相同，为什么我们不把它放在变量中呢？</p><pre class="mf mg mh mi gt mj md mk ml aw mm bi"><span id="5c16" class="mn ky iq md b gy mo mp l mq mr">const baseUrl = "<a class="ae me" href="http://localhost:3000/tasks" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/tasks</a>"</span><span id="6df4" class="mn ky iq md b gy ms mp l mq mr">function getAll() {<br/>  return fetch(baseUrl)<br/>    .then((response) =&gt; response.json())<br/>}</span><span id="3dda" class="mn ky iq md b gy ms mp l mq mr">function getOne(id) {<br/>  return fetch(`${baseUrl}/${id}`)<br/>    .then((response) =&gt; response.json())<br/>}</span></pre><p id="3e4e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">很好。</p><h1 id="ead9" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">下一个:摧毁</h1><p id="c849" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">沿着链条向上，我们来到了<code class="fe ma mb mc md b">destroy()</code>。现在，我们的fetch不仅仅是从数据库中检索数据，它实际上将删除数据。为此，我们必须在我们的<code class="fe ma mb mc md b">fetch()</code>中发送一些设置和我们的url:</p><pre class="mf mg mh mi gt mj md mk ml aw mm bi"><span id="9265" class="mn ky iq md b gy mo mp l mq mr">function destroy(id) {<br/>  let options = { method: 'DELETE' }<br/>  return fetch(`${baseUrl}/${id}`, options)<br/>    .then((response) =&gt; response.json())<br/>}</span></pre><p id="f3c5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个options对象填充的是可选参数<code class="fe ma mb mc md b">init</code>，但是称它为<code class="fe ma mb mc md b">options</code>会让我们做的事情更清楚一点。我们有一些获取设置的选项，我们正在决定它们是什么。当涉及到<code class="fe ma mb mc md b">destroy()</code>时，我们必须告诉<code class="fe ma mb mc md b">fetch()</code>不要使用GET的默认http方法，而是使用DELETE，这样我们的服务器将实际删除该url上的资源。</p><h1 id="75db" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">差不多完成了:让我们创建一个</h1><p id="56cf" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">再次提升一层复杂性，对于<code class="fe ma mb mc md b">create()</code>，我们现在必须在选项中发送头部和主体:</p><pre class="mf mg mh mi gt mj md mk ml aw mm bi"><span id="bd3e" class="mn ky iq md b gy mo mp l mq mr">function create(data) {<br/>  let options = {<br/>    method: 'POST',<br/>    headers: {<br/>      'Content-Type': 'application/json'<br/>    },<br/>    body: JSON.stringify(data)<br/>  }<br/>  return fetch(baseUrl, options)<br/>    .then((response) =&gt; response.json())<br/>}</span></pre><p id="7779" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">发送body的原因很简单:它是我们想要存储在db中的实际数据。然而，在我们发送它之前，我们必须将其字符串化。请记住，我们只能发送和接收字符串，解析数据取决于两端的程序。</p><p id="c555" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了帮助服务器解析它，我们附加了一个嵌套的<code class="fe ma mb mc md b">headers</code>对象。服务器会得到一个字符串，它需要请求中的头来告诉它正在查看什么类型的数据。十有八九是JSON，所以我们使用<code class="fe ma mb mc md b">‘Content-Type’: ‘application/json’</code>。</p><p id="0753" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可能还想知道，如果我们只是向数据库发送一些东西，为什么我们还会返回任何东西。虽然在控制台中查看在数据库中创建了什么对象很有帮助，但它主要用于(最终)呈现我们的页面。通过返回新创建的对象，我们可以将该单个元素添加到我们的页面中，而不是试图获取整个新的任务列表来获取它末尾的新任务列表。</p><h1 id="5b44" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">最后一次:更新</h1><p id="692a" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">要更新我们的一项任务，我们需要它的id以及一个包含更新数据的新机构:</p><pre class="mf mg mh mi gt mj md mk ml aw mm bi"><span id="bd82" class="mn ky iq md b gy mo mp l mq mr">function update(id,data) {<br/>  let options = {<br/>    method: 'PATCH',<br/>    headers: {<br/>      'Content-Type': 'application/json'<br/>    },<br/>    body: JSON.stringify(data)<br/>  };<br/>  return fetch(`${baseUrl}/${id}`, options)<br/>    .then((response) =&gt; response.json())<br/>}</span></pre><p id="834f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里需要警告的是，虽然我们的其他http动词不必都是大写的，但是为了避免与<a class="ae me" href="https://frontendian.co/cors" rel="noopener ugc nofollow" target="_blank"> CORS </a>相关的问题，您应该总是将PATCH放在大写的位置。<code class="fe ma mb mc md b">update()</code>基本上与<code class="fe ma mb mc md b">create()</code>相同，我们只是获取一个特定资源的url，而不是<code class="fe ma mb mc md b">baseUrl</code>。同样，我们正在返回新编辑的对象，所以最终将能够很好地渲染它。</p><h1 id="9d25" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">随机应变。适应。去拿。</h1><p id="858c" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">所以所有这些功能都很好，但是还有一个步骤<em class="kw">你可以</em>去做。从技术上讲，我们刚刚制造了一种叫做<em class="kw">适配器</em>的东西。本质上，我们使用这段代码作为前端和后端之间的<em class="kw">适配器</em>。就像当你想在苹果手机上使用普通的耳机时，为了把数据传到耳朵里，你需要一个适配器。但与苹果手机适配器不同的是，我们的代码并不是一个明显的现金攫取。</p><p id="fe83" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此外，较大的项目可能有不止一个适配器，所以最好以某种方式封装这些函数，然后将它们放入自己的文件中。该文件被称为adapter.js，或者称为特定的适配器，就像taskadapter.js一样。对于封装，我个人更喜欢将它们全部扔进一个对象中，这样当我在整个代码中使用这些方法时，就可以清楚这些方法属于哪个对象。我们最终的适配器看起来有点像:</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="cf1c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">(您会注意到，我还构建了一个助手函数<code class="fe ma mb mc md b">toJSON()</code>，所以我不必一直重复我自己，但是它做了完全相同的事情)</p><p id="a7dc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">就在那里！使用RESTful数据库需要的基本模式。如果有什么事情看起来令人困惑，只要继续在控制台上玩，我知道你会明白的。</p><p id="af4e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">快乐编码每个人，</p><p id="6624" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">迈克</p></div></div>    
</body>
</html>