<html>
<head>
<title>Understanding Virtual Destinations in ActiveMQ with an Example</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过示例了解ActiveMQ中的虚拟目的地</h1>
<blockquote>原文：<a href="https://itnext.io/understanding-virtual-destinations-in-activemq-with-an-example-cc814e8613d7?source=collection_archive---------0-----------------------#2022-11-09">https://itnext.io/understanding-virtual-destinations-in-activemq-with-an-example-cc814e8613d7?source=collection_archive---------0-----------------------#2022-11-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="3248" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">虚拟目的地允许我们创建映射到一个或多个物理目的地的逻辑目的地。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/80397e7ab5ee1930a86755d1a91ed7a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c1TQLU235lnYHNhGSvChMQ.png"/></div></div></figure><p id="a36f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">虚拟目的地是逻辑目的地，是映射到一个或多个物理目的地的队列或主题的组合。它提供了松散耦合的消息传递配置，尤其是在应用程序运行在多个实例上时。</p><p id="40be" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本文中，我们将借助一个简单的Spring Boot应用程序来看看虚拟目的地如何在ActiveMQ中工作。</p><h2 id="7385" class="la lb it bd lc ld le dn lf lg lh dp li kb lj lk ll kf lm ln lo kj lp lq lr ls bi translated">先决条件</h2><p id="a063" class="pw-post-body-paragraph jq jr it js b jt lt jv jw jx lu jz ka kb lv kd ke kf lw kh ki kj lx kl km kn im bi translated">从官方<a class="ae ly" href="https://activemq.apache.org/download" rel="noopener ugc nofollow" target="_blank">网站</a>下载安装程序安装Apache ActiveMQ。在各种操作系统上安装ActiveMQ的指南在<a class="ae ly" href="https://activemq.apache.org/getting-started" rel="noopener ugc nofollow" target="_blank">这里</a>描述。</p><p id="7f4b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">创建一个简单的Spring Boot应用程序，并在pom.xml中添加以下依赖项。</p><pre class="kp kq kr ks gt lz ma mb mc aw md bi"><span id="8035" class="la lb it ma b gy me mf l mg mh">&lt;dependency&gt;<br/>  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br/>  &lt;artifactId&gt;spring-boot-starter-activemq&lt;/artifactId&gt;<br/>&lt;/dependency&gt;</span></pre><h2 id="610d" class="la lb it bd lc ld le dn lf lg lh dp li kb lj lk ll kf lm ln lo kj lp lq lr ls bi translated">虚拟话题</h2><p id="6c77" class="pw-post-body-paragraph jq jr it js b jt lt jv jw jx lu jz ka kb lv kd ke kf lw kh ki kj lx kl km kn im bi translated">虚拟主题的概念是生产者以通常的JMS方式发送到一个主题，但是这个主题是虚拟的。听众可以从他们自己的队列或者通过逻辑主题订阅来消费。</p><p id="5294" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">ActiveMQ会将主题中的每条消息复制到消费者队列中。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mi"><img src="../Images/d836cbe686fe600cfd0c695af00c118a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LRHku1b-bzK3SPVrcydtnw.png"/></div></div><figcaption class="mj mk gj gh gi ml mm bd b be z dk translated">虚拟主题和队列</figcaption></figure><h2 id="1d83" class="la lb it bd lc ld le dn lf lg lh dp li kb lj lk ll kf lm ln lo kj lp lq lr ls bi translated">JMS生成器</h2><p id="7994" class="pw-post-body-paragraph jq jr it js b jt lt jv jw jx lu jz ka kb lv kd ke kf lw kh ki kj lx kl km kn im bi translated">我们将编写一个简单的生成器，它将创建一个虚拟主题并发布关于该主题的消息。</p><pre class="kp kq kr ks gt lz ma mb mc aw md bi"><span id="eec6" class="la lb it ma b gy me mf l mg mh">@Component<br/>public class JMSProducer {<br/><br/>    private final JmsTemplate jmsTemplate;<br/><br/>    public JMSProducer(final JmsTemplate jmsTemplate) {<br/>        this.jmsTemplate = jmsTemplate;<br/>    }<br/><br/>    public void createVirtualTopicAndPublishMessage() {<br/>        jmsTemplate.convertAndSend(new ActiveMQTopic("VirtualTopic.medium"), "Test virtual topic");<br/>    }<br/><br/>}</span></pre><p id="bb32" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">请注意，主题名称是“VirtualTopic.medium”。ActiveMQ中虚拟主题的默认命名约定以前缀“VirtualTopic”开始。&gt;".但是，我们可以通过在ActiveMQ代理配置中进行配置来自定义这些名称。</p><h2 id="95f2" class="la lb it bd lc ld le dn lf lg lh dp li kb lj lk ll kf lm ln lo kj lp lq lr ls bi translated">JMS消费者</h2><p id="beb6" class="pw-post-body-paragraph jq jr it js b jt lt jv jw jx lu jz ka kb lv kd ke kf lw kh ki kj lx kl km kn im bi translated">我们现在要编写一个消费者来监听队列，以接收将在虚拟主题上发布的消息。</p><pre class="kp kq kr ks gt lz ma mb mc aw md bi"><span id="f64d" class="la lb it ma b gy me mf l mg mh">@Component<br/>public class JMSConsumer {<br/>    private static final Logger <em class="mn">LOGGER </em>= LoggerFactory.<em class="mn">getLogger</em>(JMSConsumer.class);<br/><br/>    @JmsListener(destination = "Consumer.app.VirtualTopic.medium")<br/>    public void readMessage(final TextMessage message) {<br/>        <em class="mn">LOGGER</em>.info("Received message {}", message);<br/>    }<br/><br/>}</span></pre><p id="bc34" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">队列名称按照约定命名为“消费者”。[clientName].VirtualTopic . &gt;”，这是与虚拟主题相关联的队列的默认约定。</p><p id="02d3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在虚拟主题“VirtualTopic.medium”上发布的任何消息都将被复制到队列“consumer . app . virtual topic . medium”中。</p><h2 id="1545" class="la lb it bd lc ld le dn lf lg lh dp li kb lj lk ll kf lm ln lo kj lp lq lr ls bi translated">测试示例应用程序</h2><p id="1223" class="pw-post-body-paragraph jq jr it js b jt lt jv jw jx lu jz ka kb lv kd ke kf lw kh ki kj lx kl km kn im bi translated">让我们编写一个简单的命令行运行程序类，它将用于在应用程序启动时发布消息。</p><pre class="kp kq kr ks gt lz ma mb mc aw md bi"><span id="d7ae" class="la lb it ma b gy me mf l mg mh">@Component<br/>public class AppCommandLineRunner implements CommandLineRunner {<br/><br/>    private final JMSProducer jmsProducer;<br/><br/>    public AppCommandLineRunner(final JMSProducer jmsProducer) {<br/>        this.jmsProducer = jmsProducer;<br/>    }<br/><br/>    @Override<br/>    public void run(String... args) {<br/>        jmsProducer.createVirtualTopicAndPublishMessage();<br/>    }<br/>}</span></pre><p id="7245" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">运行应用程序，我们将看到在ActiveMQ控制台中创建了主题和队列。我们可以通过<a class="ae ly" href="http://localhost:8161/admin/index.jsp" rel="noopener ugc nofollow" target="_blank">http://localhost:8161/admin/index . JSP</a>导航到ActiveMQ控制台。</p><p id="df69" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们应该能够在topics视图中看到虚拟主题。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mo"><img src="../Images/90deb2568bee7118fbe62fcdf40f8dc7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_jlyWJKKNPaJCrHe8TntbQ.png"/></div></div><figcaption class="mj mk gj gh gi ml mm bd b be z dk translated">主题</figcaption></figure><p id="dfa0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们还将在queues视图中看到该队列。如果应用程序已经成功运行，那么我们将看到一条消息正在入队和出队。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mp"><img src="../Images/f0adadb9da10bd5802784fef9c46583c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hxn8MFK24oFNtdCQ_KSo4A.png"/></div></div><figcaption class="mj mk gj gh gi ml mm bd b be z dk translated">行列</figcaption></figure><h2 id="40e1" class="la lb it bd lc ld le dn lf lg lh dp li kb lj lk ll kf lm ln lo kj lp lq lr ls bi translated">自定义配置</h2><p id="8bdd" class="pw-post-body-paragraph jq jr it js b jt lt jv jw jx lu jz ka kb lv kd ke kf lw kh ki kj lx kl km kn im bi translated">正如我前面提到的，命名约定可以通过代理配置进行定制。这可以通过修改activemq.xml文件来完成。</p><p id="d128" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它不仅允许您自定义名称，还允许您打开默认情况下禁用的选择器感知。选择器感知可用于选择性地将消息转发到不同的目的地。</p><pre class="kp kq kr ks gt lz ma mb mc aw md bi"><span id="f80b" class="la lb it ma b gy me mf l mg mh">&lt;destinationInterceptors&gt; <br/>  &lt;virtualDestinationInterceptor&gt; <br/>    &lt;virtualDestinations&gt; <br/>      &lt;virtualTopic name="&gt;" prefix="VirtualTopicConsumers.*." selectorAware="false"/&gt;   <br/>    &lt;/virtualDestinations&gt;<br/>  &lt;/virtualDestinationInterceptor&gt; <br/>&lt;/destinationInterceptors&gt;</span></pre><h2 id="113e" class="la lb it bd lc ld le dn lf lg lh dp li kb lj lk ll kf lm ln lo kj lp lq lr ls bi translated">结论</h2><p id="920f" class="pw-post-body-paragraph jq jr it js b jt lt jv jw jx lu jz ka kb lv kd ke kf lw kh ki kj lx kl km kn im bi translated">我们可以使用虚拟主题添加任意多的消费者，而无需修改ActiveMQ代理配置。</p><p id="7918" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我希望这篇文章能帮助你了解虚拟目的地。在<a class="ae ly" href="https://activemq.apache.org/virtual-destinations" rel="noopener ugc nofollow" target="_blank">https://activemq.apache.org/virtual-destinations</a>阅读更多内容。</p></div></div>    
</body>
</html>