<html>
<head>
<title>Implementing YOLO v3 in Tensorflow (TF-Slim)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Tensorflow (TF-Slim)中实现YOLO v3</h1>
<blockquote>原文：<a href="https://itnext.io/implementing-yolo-v3-in-tensorflow-tf-slim-c3c55ff59dbe?source=collection_archive---------0-----------------------#2018-06-03">https://itnext.io/implementing-yolo-v3-in-tensorflow-tf-slim-c3c55ff59dbe?source=collection_archive---------0-----------------------#2018-06-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/></div><div class="ab cl jn jo hu jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ij ik il im in"><h1 id="c325" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">关于作者:</h1><p id="50ce" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><em class="lq">我是</em> <a class="ae lr" href="http://www.impeccable.ai?utm_campaign=Medium&amp;utm_source=medium&amp;utm_medium=link&amp;utm_term=yolov3" rel="noopener ugc nofollow" target="_blank"> <strong class="ku ir"> <em class="lq">无可挑剔的联合创始人兼CEO。AI </em> </strong> </a> <em class="lq">。我以前的经历包括为微软工作，作为ML工程师处理AI/ML问题。</em></p><p id="3659" class="pw-post-body-paragraph ks kt iq ku b kv ls kx ky kz lt lb lc ld lu lf lg lh lv lj lk ll lw ln lo lp ij bi translated"><em class="lq">在无可挑剔。人工智能我们正在建立一个人工智能开发平台(它也有一个笔记本的空间！)来帮助开发AI产品的团队更快地工作，更好地协作。我们采用横向方法，提供“智能助手”工具，并提供最大的灵活性。我们知道我们的客户——他们领域的专家——确切地知道该做什么和如何做。</em></p></div><div class="ab cl jn jo hu jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ij ik il im in"><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi lx"><img src="../Images/49b0709f53e9ef5049eb4f0b457680ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K8TxuJZvtgGTNY07gtQzyw.jpeg"/></div></div><figcaption class="mj mk gj gh gi ml mm bd b be z dk translated">带有检测对象的演示图像。</figcaption></figure><p id="5074" class="pw-post-body-paragraph ks kt iq ku b kv ls kx ky kz lt lb lc ld lu lf lg lh lv lj lk ll lw ln lo lp ij bi translated">我想分享我的代码以及我在实现它时遇到的一些问题的解决方案。</p><p id="662a" class="pw-post-body-paragraph ks kt iq ku b kv ls kx ky kz lt lb lc ld lu lf lg lh lv lj lk ll lw ln lo lp ij bi translated">我不会过多关注与实现无关的方面。我假设你熟悉CNN的，对象检测，YOLO v3架构等。以及Tensorflow和TF-Slim框架。如果没有，从相应的论文/教程入手可能会更好。我不会解释每一行是做什么的，而是给出工作代码，解释我偶然发现的一些问题。</p><p id="fdd1" class="pw-post-body-paragraph ks kt iq ku b kv ls kx ky kz lt lb lc ld lu lf lg lh lv lj lk ll lw ln lo lp ij bi translated">运行这个检测器所需的所有代码和一些演示可以在我的GitHub <a class="ae lr" href="https://github.com/mystic123/tensorflow-yolo-v3" rel="noopener ugc nofollow" target="_blank"> repo </a>中找到。我在Ubuntu 16.04、Tensorflow 1.8.0和CUDA 9.0上进行了测试。</p><p id="ab1e" class="pw-post-body-paragraph ks kt iq ku b kv ls kx ky kz lt lb lc ld lu lf lg lh lv lj lk ll lw ln lo lp ij bi translated">该职位的组织结构如下:</p><ol class=""><li id="fbee" class="mn mo iq ku b kv ls kz lt ld mp lh mq ll mr lp ms mt mu mv bi translated">设置</li><li id="dba0" class="mn mo iq ku b kv mw kz mx ld my lh mz ll na lp ms mt mu mv bi translated">Darknet-53层的实现</li><li id="5a9f" class="mn mo iq ku b kv mw kz mx ld my lh mz ll na lp ms mt mu mv bi translated">YOLO v3检测层的实现</li><li id="3c53" class="mn mo iq ku b kv mw kz mx ld my lh mz ll na lp ms mt mu mv bi translated">转换预先训练的可可重量</li><li id="b8ee" class="mn mo iq ku b kv mw kz mx ld my lh mz ll na lp ms mt mu mv bi translated">后处理算法的实现</li><li id="a992" class="mn mo iq ku b kv mw kz mx ld my lh mz ll na lp ms mt mu mv bi translated">摘要</li></ol></div><div class="ab cl jn jo hu jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ij ik il im in"><h1 id="3dc0" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">1.设置</h1><p id="c5ee" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">我想以类似于Tensorflow <code class="fe nb nc nd ne b">models</code> <a class="ae lr" href="https://github.com/tensorflow/models" rel="noopener ugc nofollow" target="_blank">存储库</a>的方式组织代码。我使用TF-Slim，因为它让我们定义公共参数，如激活函数、批处理规范化参数等。作为全局变量，这使得定义神经网络更快。</p><p id="b3c4" class="pw-post-body-paragraph ks kt iq ku b kv ls kx ky kz lt lb lc ld lu lf lg lh lv lj lk ll lw ln lo lp ij bi translated">我们从<code class="fe nb nc nd ne b">yolo_v3.py</code>文件开始，在这里我们将放置初始化网络的函数以及加载预训练权重的函数。</p><figure class="ly lz ma mb gt mc"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="6557" class="pw-post-body-paragraph ks kt iq ku b kv ls kx ky kz lt lb lc ld lu lf lg lh lv lj lk ll lw ln lo lp ij bi translated">在文件顶部的某个地方添加必要的常量(由YOLO的作者调整)。</p><pre class="ly lz ma mb gt nh ne ni nj aw nk bi"><span id="10df" class="nl jv iq ne b gy nm nn l no np">_BATCH_NORM_DECAY = 0.9<br/>_BATCH_NORM_EPSILON = 1e-05<br/>_LEAKY_RELU = 0.1</span></pre><p id="c8c7" class="pw-post-body-paragraph ks kt iq ku b kv ls kx ky kz lt lb lc ld lu lf lg lh lv lj lk ll lw ln lo lp ij bi translated">YOLO v3将输入归一化到范围0内..1.检测器中的大多数层在卷积后立即进行批量归一化，没有偏差并使用泄漏ReLU激活。定义一个小参数范围来处理这种情况是很方便的。在不使用BN和LReLU的层中，我们需要隐式地定义它。</p><pre class="ly lz ma mb gt nh ne ni nj aw nk bi"><span id="5370" class="nl jv iq ne b gy nm nn l no np"># transpose the inputs to NCHW<br/>if data_format == 'NCHW':<br/>    inputs = tf.transpose(inputs, [0, 3, 1, 2])<br/><br/># normalize values to range [0..1]<br/>inputs = inputs / 255<br/><br/># set batch norm params<br/>batch_norm_params = {<br/>    'decay': _BATCH_NORM_DECAY,<br/>    'epsilon': _BATCH_NORM_EPSILON,<br/>    'scale': True,<br/>    'is_training': is_training,<br/>    'fused': None,  # Use fused batch norm if possible.<br/>}<br/><br/># Set activation_fn and parameters for conv2d, batch_norm.<br/>with slim.arg_scope([slim.conv2d, slim.batch_norm, _fixed_padding], data_format=data_format, reuse=reuse):<br/>    with slim.arg_scope([slim.conv2d], normalizer_fn=slim.batch_norm, normalizer_params=batch_norm_params,<br/>                        biases_initializer=None, activation_fn=lambda x: tf.nn.leaky_relu(x, alpha=_LEAKY_RELU)):<br/>        with tf.variable_scope('darknet-53'):<br/>            inputs = darknet53(inputs)</span></pre><p id="0b5c" class="pw-post-body-paragraph ks kt iq ku b kv ls kx ky kz lt lb lc ld lu lf lg lh lv lj lk ll lw ln lo lp ij bi translated">我们现在准备定义暗网-53层。</p></div><div class="ab cl jn jo hu jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ij ik il im in"><h1 id="251e" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">2.Darknet-53层的实现。</h1><p id="18cb" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">在YOLO v3论文中，作者提出了称为Darknet-53的新的、更深层次的特征提取器架构。顾名思义，它包含53个卷积层，每个卷积层后面都有批量标准化层和泄漏ReLU激活。缩减像素采样是由conv图层通过<code class="fe nb nc nd ne b">stride=2</code>完成的。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/67451c325c390d428960b72b9c6edf82.png" data-original-src="https://miro.medium.com/v2/resize:fit:792/format:webp/1*_dsvGlCE0-HfvGBcpdxoUg.png"/></div><figcaption class="mj mk gj gh gi ml mm bd b be z dk translated">资料来源:YOLO v3纸</figcaption></figure><p id="62f8" class="pw-post-body-paragraph ks kt iq ku b kv ls kx ky kz lt lb lc ld lu lf lg lh lv lj lk ll lw ln lo lp ij bi translated">在我们定义卷积层之前，我们必须认识到作者的实现使用固定填充，与输入大小无关。为了实现相同的行为，我们可以使用下面的函数(我稍微修改了代码，在这里找到了<a class="ae lr" href="https://github.com/tensorflow/models/blob/master/official/resnet/resnet_model.py" rel="noopener ugc nofollow" target="_blank"/>)。</p><pre class="ly lz ma mb gt nh ne ni nj aw nk bi"><span id="e63e" class="nl jv iq ne b gy nm nn l no np">@tf.contrib.framework.add_arg_scope<br/>def _fixed_padding(inputs, kernel_size, *args, mode='CONSTANT', **kwargs):<br/>    <em class="lq">"""<br/>    Pads the input along the spatial dimensions independently of input size.<br/><br/>    Args:<br/>      inputs: A tensor of size [batch, channels, height_in, width_in] or<br/>        [batch, height_in, width_in, channels] depending on data_format.<br/>      kernel_size: The kernel to be used in the conv2d or max_pool2d operation.<br/>                   Should be a positive integer.<br/>      data_format: The input format ('NHWC' or 'NCHW').<br/>      mode: The mode for tf.pad.<br/><br/>    Returns:<br/>      A tensor with the same format as the input with the data either intact<br/>      (if kernel_size == 1) or padded (if kernel_size &gt; 1).<br/>    """<br/>    </em>pad_total = kernel_size - 1<br/>    pad_beg = pad_total // 2<br/>    pad_end = pad_total - pad_beg<br/><br/>    if kwargs['data_format'] == 'NCHW':<br/>        padded_inputs = tf.pad(inputs, [[0, 0], [0, 0],<br/>                                        [pad_beg, pad_end], [pad_beg, pad_end]], mode=mode)<br/>    else:<br/>        padded_inputs = tf.pad(inputs, [[0, 0], [pad_beg, pad_end],<br/>                                        [pad_beg, pad_end], [0, 0]], mode=mode)<br/>    return padded_inputs</span></pre><p id="9910" class="pw-post-body-paragraph ks kt iq ku b kv ls kx ky kz lt lb lc ld lu lf lg lh lv lj lk ll lw ln lo lp ij bi translated"><code class="fe nb nc nd ne b">_fixed_padding</code>沿高度和宽度尺寸输入适当数量的0(当<code class="fe nb nc nd ne b">mode='CONSTANT'</code>时)。我们稍后也会用到<code class="fe nb nc nd ne b">mode='SYMMETRIC'</code>。</p><p id="517c" class="pw-post-body-paragraph ks kt iq ku b kv ls kx ky kz lt lb lc ld lu lf lg lh lv lj lk ll lw ln lo lp ij bi translated">现在我们可以定义<code class="fe nb nc nd ne b">_conv2d_fixed_padding</code>函数了:</p><pre class="ly lz ma mb gt nh ne ni nj aw nk bi"><span id="dc4b" class="nl jv iq ne b gy nm nn l no np">def _conv2d_fixed_padding(inputs, filters, kernel_size, strides=1):<br/>    if strides &gt; 1:<br/>        inputs = _fixed_padding(inputs, kernel_size)<br/>    inputs = slim.conv2d(inputs, filters, kernel_size, stride=strides, padding=('SAME' if strides == 1 else 'VALID'))<br/>    return inputs</span></pre><p id="5b38" class="pw-post-body-paragraph ks kt iq ku b kv ls kx ky kz lt lb lc ld lu lf lg lh lv lj lk ll lw ln lo lp ij bi translated">Darknet-53模型是由一些具有2个conv层和快捷方式连接的块构建而成，然后是下采样层。为了避免样板代码，我们定义了<code class="fe nb nc nd ne b">_darknet_block</code>函数:</p><pre class="ly lz ma mb gt nh ne ni nj aw nk bi"><span id="8263" class="nl jv iq ne b gy nm nn l no np">def _darknet53_block(inputs, filters):<br/>    shortcut = inputs<br/>    inputs = _conv2d_fixed_padding(inputs, filters, 1)<br/>    inputs = _conv2d_fixed_padding(inputs, filters * 2, 3)<br/><br/>    inputs = inputs + shortcut<br/>    return inputs</span></pre><p id="1c42" class="pw-post-body-paragraph ks kt iq ku b kv ls kx ky kz lt lb lc ld lu lf lg lh lv lj lk ll lw ln lo lp ij bi translated">最后，我们有了Darknet-53模型所需的所有构件:</p><pre class="ly lz ma mb gt nh ne ni nj aw nk bi"><span id="04a5" class="nl jv iq ne b gy nm nn l no np">def darknet53(inputs):<br/>    <em class="lq">"""<br/>    Builds Darknet-53 model.<br/>    """<br/>    </em>inputs = _conv2d_fixed_padding(inputs, 32, 3)<br/>    inputs = _conv2d_fixed_padding(inputs, 64, 3, strides=2)<br/>    inputs = _darknet53_block(inputs, 32)<br/>    inputs = _conv2d_fixed_padding(inputs, 128, 3, strides=2)<br/><br/>    for i in range(2):<br/>        inputs = _darknet53_block(inputs, 64)<br/><br/>    inputs = _conv2d_fixed_padding(inputs, 256, 3, strides=2)<br/><br/>    for i in range(8):<br/>        inputs = _darknet53_block(inputs, 128)<br/><br/>    inputs = _conv2d_fixed_padding(inputs, 512, 3, strides=2)<br/><br/>    for i in range(8):<br/>        inputs = _darknet53_block(inputs, 256)<br/><br/>    inputs = _conv2d_fixed_padding(inputs, 1024, 3, strides=2)<br/><br/>    for i in range(4):<br/>        inputs = _darknet53_block(inputs, 512)<br/><br/>    return inputs</span></pre><p id="5d8b" class="pw-post-body-paragraph ks kt iq ku b kv ls kx ky kz lt lb lc ld lu lf lg lh lv lj lk ll lw ln lo lp ij bi translated">本来最后一个块之后还有global avg pool layer和softmax，但是YOLO v3都不用(所以实际上我们是52层而不是53层；) )</p></div><div class="ab cl jn jo hu jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ij ik il im in"><h1 id="8637" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">3.YOLO v3检测层的实现。</h1><p id="8735" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">由Darknet-53提取的特征被导向检测层。检测模块由分组在块中的一定数量的conv层、上采样层和具有线性激活函数的3个conv层构成，在3个不同的尺度上进行检测。先说写辅助函数<code class="fe nb nc nd ne b">_yolo_block</code>:</p><pre class="ly lz ma mb gt nh ne ni nj aw nk bi"><span id="9cc4" class="nl jv iq ne b gy nm nn l no np">def _yolo_block(inputs, filters):<br/>    inputs = _conv2d_fixed_padding(inputs, filters, 1)<br/>    inputs = _conv2d_fixed_padding(inputs, filters * 2, 3)<br/>    inputs = _conv2d_fixed_padding(inputs, filters, 1)<br/>    inputs = _conv2d_fixed_padding(inputs, filters * 2, 3)<br/>    inputs = _conv2d_fixed_padding(inputs, filters, 1)<br/>    route = inputs<br/>    inputs = _conv2d_fixed_padding(inputs, filters * 2, 3)<br/>    return route, inputs</span></pre><p id="ca46" class="pw-post-body-paragraph ks kt iq ku b kv ls kx ky kz lt lb lc ld lu lf lg lh lv lj lk ll lw ln lo lp ij bi translated">来自块中第5层的激活然后被路由到另一个conv层并被上采样，而来自第6层的激活被传送到<code class="fe nb nc nd ne b">_detection_layer</code>，我们现在要定义它:</p><pre class="ly lz ma mb gt nh ne ni nj aw nk bi"><span id="ea83" class="nl jv iq ne b gy nm nn l no np">def _detection_layer(inputs, num_classes, anchors, img_size, data_format):<br/>    num_anchors = len(anchors)<br/>    predictions = slim.conv2d(inputs, num_anchors * (5 + num_classes), 1, stride=1, normalizer_fn=None,<br/>                              activation_fn=None, biases_initializer=tf.zeros_initializer())<br/><br/>    shape = predictions.get_shape().as_list()<br/>    grid_size = _get_size(shape, data_format)<br/>    dim = grid_size[0] * grid_size[1]<br/>    bbox_attrs = 5 + num_classes<br/><br/>    if data_format == 'NCHW':<br/>        predictions = tf.reshape(predictions, [-1, num_anchors * bbox_attrs, dim])<br/>        predictions = tf.transpose(predictions, [0, 2, 1])<br/><br/>    predictions = tf.reshape(predictions, [-1, num_anchors * dim, bbox_attrs])<br/><br/>    stride = (img_size[0] // grid_size[0], img_size[1] // grid_size[1])<br/><br/>    anchors = [(a[0] / stride[0], a[1] / stride[1]) for a in anchors]<br/><br/>    box_centers, box_sizes, confidence, classes = tf.split(predictions, [2, 2, 1, num_classes], axis=-1)<br/><br/>    box_centers = tf.nn.sigmoid(box_centers)<br/>    confidence = tf.nn.sigmoid(confidence)<br/><br/>    grid_x = tf.range(grid_size[0], dtype=tf.float32)<br/>    grid_y = tf.range(grid_size[1], dtype=tf.float32)<br/>    a, b = tf.meshgrid(grid_x, grid_y)<br/><br/>    x_offset = tf.reshape(a, (-1, 1))<br/>    y_offset = tf.reshape(b, (-1, 1))<br/><br/>    x_y_offset = tf.concat([x_offset, y_offset], axis=-1)<br/>    x_y_offset = tf.reshape(tf.tile(x_y_offset, [1, num_anchors]), [1, -1, 2])<br/><br/>    box_centers = box_centers + x_y_offset<br/>    box_centers = box_centers * stride<br/><br/>    anchors = tf.tile(anchors, [dim, 1])<br/>    box_sizes = tf.exp(box_sizes) * anchors<br/>    box_sizes = box_sizes * stride<br/><br/>    detections = tf.concat([box_centers, box_sizes, confidence], axis=-1)<br/><br/>    classes = tf.nn.sigmoid(classes)<br/>    predictions = tf.concat([detections, classes], axis=-1)<br/>    return predictions</span></pre><p id="63f2" class="pw-post-body-paragraph ks kt iq ku b kv ls kx ky kz lt lb lc ld lu lf lg lh lv lj lk ll lw ln lo lp ij bi translated">该层根据以下等式转换原始预测。因为每个尺度上的YOLO v3检测不同大小和纵横比的对象，所以传递<code class="fe nb nc nd ne b">anchors</code>参数，该参数是每个尺度的3元组(高度、宽度)的列表。锚需要为数据集定制(在本教程中，我们将为COCO数据集使用锚)。只需将这个常量添加到<code class="fe nb nc nd ne b">yolo_v3.py</code>文件的顶部。</p><pre class="ly lz ma mb gt nh ne ni nj aw nk bi"><span id="5523" class="nl jv iq ne b gy nm nn l no np">_ANCHORS = [(10, 13), (16, 30), (33, 23), (30, 61), (62, 45), (59, 119), (116, 90), (156, 198), (373, 326)]</span></pre><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/ff9c8dc7a0ce3f667468d64936ab9a57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/format:webp/1*Dx_VzLT94QoZAAyWbmC57A.png"/></div><figcaption class="mj mk gj gh gi ml mm bd b be z dk translated">资料来源:YOLO v3纸</figcaption></figure><p id="28c1" class="pw-post-body-paragraph ks kt iq ku b kv ls kx ky kz lt lb lc ld lu lf lg lh lv lj lk ll lw ln lo lp ij bi translated">我们需要一个小的助手函数<code class="fe nb nc nd ne b">_get_size</code>，它返回输入的高度和宽度:</p><pre class="ly lz ma mb gt nh ne ni nj aw nk bi"><span id="5dd0" class="nl jv iq ne b gy nm nn l no np">def _get_size(shape, data_format):<br/>    if len(shape) == 4:<br/>        shape = shape[1:]<br/>    return shape[1:3] if data_format == 'NCHW' else shape[0:2]</span></pre><p id="825a" class="pw-post-body-paragraph ks kt iq ku b kv ls kx ky kz lt lb lc ld lu lf lg lh lv lj lk ll lw ln lo lp ij bi translated">如前所述，我们需要实现YOLO v3的最后一个构件是上采样层。YOLO检测器使用双线性上采样方法。为什么不能直接用Tensorflow API的标准<code class="fe nb nc nd ne b">tf.image.resize_bilinear</code>方法？原因是，到今天为止(TF 1 . 8 . 0版本)，所有的上采样方式都使用<em class="lq">常量</em> pad模式。YOLO作者报告和PyTorch中的标准填充方法是<em class="lq">边缘</em>(填充模式的良好比较可在此处找到<a class="ae lr" href="http://scikit-image.org/docs/dev/auto_examples/transform/plot_edge_modes.html" rel="noopener ugc nofollow" target="_blank">)。这一微小的差异对检测有重大影响(并花费了我几个小时的调试时间)。</a></p><p id="128b" class="pw-post-body-paragraph ks kt iq ku b kv ls kx ky kz lt lb lc ld lu lf lg lh lv lj lk ll lw ln lo lp ij bi translated">为了解决这个问题，我们将用1个像素和<code class="fe nb nc nd ne b">mode='SYMMETRIC'</code>手动填充输入，这相当于<em class="lq">边缘</em>模式。</p><pre class="ly lz ma mb gt nh ne ni nj aw nk bi"><span id="d9c3" class="nl jv iq ne b gy nm nn l no np"># we just need to pad with one pixel, so we set kernel_size = 3<br/>inputs = _fixed_padding(inputs, 3, 'NHWC', mode='SYMMETRIC')</span></pre><p id="c98f" class="pw-post-body-paragraph ks kt iq ku b kv ls kx ky kz lt lb lc ld lu lf lg lh lv lj lk ll lw ln lo lp ij bi translated">整个<code class="fe nb nc nd ne b">_upsample</code>功能代码看起来如下:</p><pre class="ly lz ma mb gt nh ne ni nj aw nk bi"><span id="0615" class="nl jv iq ne b gy nm nn l no np">def _upsample(inputs, out_shape, data_format='NCHW'):<br/>    # we need to pad with one pixel, so we set kernel_size = 3<br/>    inputs = _fixed_padding(inputs, 3, mode='SYMMETRIC')<br/><br/>    # tf.image.resize_bilinear accepts input in format NHWC<br/>    if data_format == 'NCHW':<br/>        inputs = tf.transpose(inputs, [0, 2, 3, 1])<br/><br/>    if data_format == 'NCHW':<br/>        height = out_shape[3]<br/>        width = out_shape[2]<br/>    else:<br/>        height = out_shape[2]<br/>        width = out_shape[1]<br/><br/>    # we padded with 1 pixel from each side and upsample by factor of 2, so new dimensions will be<br/>    # greater by 4 pixels after interpolation<br/>    new_height = height + 4<br/>    new_width = width + 4<br/><br/>    inputs = tf.image.resize_bilinear(inputs, (new_height, new_width))<br/><br/>    # trim back to desired size<br/>    inputs = inputs[:, 2:-2, 2:-2, :]<br/><br/>    # back to NCHW if needed<br/>    if data_format == 'NCHW':<br/>        inputs = tf.transpose(inputs, [0, 3, 1, 2])<br/><br/>    inputs = tf.identity(inputs, name='upsampled')<br/>    return inputs</span></pre><p id="9379" class="pw-post-body-paragraph ks kt iq ku b kv ls kx ky kz lt lb lc ld lu lf lg lh lv lj lk ll lw ln lo lp ij bi translated">更新:感谢<a class="ae lr" href="https://www.linkedin.com/in/srikanth-vidapanakal-7463b18/" rel="noopener ugc nofollow" target="_blank"> Srikanth Vidapanakal </a>，我查了一下darknet的源代码，发现上采样的方法是最近邻，不是双线性。我们不再需要填充图像了。更新的代码已经在我的回购中可用。</p><p id="85d6" class="pw-post-body-paragraph ks kt iq ku b kv ls kx ky kz lt lb lc ld lu lf lg lh lv lj lk ll lw ln lo lp ij bi translated">固定<code class="fe nb nc nd ne b">_upsample</code>功能代码如下:</p><pre class="ly lz ma mb gt nh ne ni nj aw nk bi"><span id="4dcc" class="nl jv iq ne b gy nm nn l no np">def _upsample(inputs, out_shape, data_format='NCHW'):<br/>    # tf.image.resize_nearest_neighbor accepts input in format NHWC<br/>    if data_format == 'NCHW':<br/>        inputs = tf.transpose(inputs, [0, 2, 3, 1])<br/><br/>    if data_format == 'NCHW':<br/>        new_height = out_shape[3]<br/>        new_width = out_shape[2]<br/>    else:<br/>        new_height = out_shape[2]<br/>        new_width = out_shape[1]<br/><br/>    inputs = tf.image.resize_nearest_neighbor(inputs, (new_height, new_width))<br/><br/>    # back to NCHW if needed<br/>    if data_format == 'NCHW':<br/>        inputs = tf.transpose(inputs, [0, 3, 1, 2])<br/><br/>    inputs = tf.identity(inputs, name='upsampled')<br/>    return inputs</span></pre><p id="50e2" class="pw-post-body-paragraph ks kt iq ku b kv ls kx ky kz lt lb lc ld lu lf lg lh lv lj lk ll lw ln lo lp ij bi translated">上采样激活沿着通道轴与来自Darknet-53层的激活连接。这就是为什么我们需要回到<code class="fe nb nc nd ne b">darknet53</code>功能，在第四和第五下采样层之前返回conv层的激活。</p><pre class="ly lz ma mb gt nh ne ni nj aw nk bi"><span id="9f60" class="nl jv iq ne b gy nm nn l no np">def darknet53(inputs):<br/>    <em class="lq">"""<br/>    Builds Darknet-53 model.<br/>    """<br/>    </em>inputs = _conv2d_fixed_padding(inputs, 32, 3)<br/>    inputs = _conv2d_fixed_padding(inputs, 64, 3, strides=2)<br/>    inputs = _darknet53_block(inputs, 32)<br/>    inputs = _conv2d_fixed_padding(inputs, 128, 3, strides=2)<br/><br/>    for i in range(2):<br/>        inputs = _darknet53_block(inputs, 64)<br/><br/>    inputs = _conv2d_fixed_padding(inputs, 256, 3, strides=2)<br/><br/>    for i in range(8):<br/>        inputs = _darknet53_block(inputs, 128)<br/><br/>    route1 = inputs<br/>    inputs = _conv2d_fixed_padding(inputs, 512, 3, strides=2)<br/><br/>    for i in range(8):<br/>        inputs = _darknet53_block(inputs, 256)<br/><br/>    route2 = inputs<br/>    inputs = _conv2d_fixed_padding(inputs, 1024, 3, strides=2)<br/><br/>    for i in range(4):<br/>        inputs = _darknet53_block(inputs, 512)<br/><br/>    return route1, route2, inputs</span></pre><p id="7345" class="pw-post-body-paragraph ks kt iq ku b kv ls kx ky kz lt lb lc ld lu lf lg lh lv lj lk ll lw ln lo lp ij bi translated">现在我们准备定义检测器模块。让我们回到<code class="fe nb nc nd ne b">yolo_v3</code>函数，在slim arg作用域下添加以下几行:</p><pre class="ly lz ma mb gt nh ne ni nj aw nk bi"><span id="31b8" class="nl jv iq ne b gy nm nn l no np">with tf.variable_scope('darknet-53'):<br/>    route_1, route_2, inputs = darknet53(inputs)<br/><br/>with tf.variable_scope('yolo-v3'):<br/>    route, inputs = _yolo_block(inputs, 512)<br/>    detect_1 = _detection_layer(inputs, num_classes, _ANCHORS[6:9], img_size, data_format)<br/>    detect_1 = tf.identity(detect_1, name='detect_1')<br/><br/>    inputs = _conv2d_fixed_padding(route, 256, 1)<br/>    upsample_size = route_2.get_shape().as_list()<br/>    inputs = _upsample(inputs, upsample_size, data_format)<br/>    inputs = tf.concat([inputs, route_2], axis=1 if data_format == 'NCHW' else 3)<br/><br/>    route, inputs = _yolo_block(inputs, 256)<br/><br/>    detect_2 = _detection_layer(inputs, num_classes, _ANCHORS[3:6], img_size, data_format)<br/>    detect_2 = tf.identity(detect_2, name='detect_2')<br/><br/>    inputs = _conv2d_fixed_padding(route, 128, 1)<br/>    upsample_size = route_1.get_shape().as_list()<br/>    inputs = _upsample(inputs, upsample_size, data_format)<br/>    inputs = tf.concat([inputs, route_1], axis=1 if data_format == 'NCHW' else 3)<br/><br/>    _, inputs = _yolo_block(inputs, 128)<br/><br/>    detect_3 = _detection_layer(inputs, num_classes, _ANCHORS[0:3], img_size, data_format)<br/>    detect_3 = tf.identity(detect_3, name='detect_3')<br/><br/>    detections = tf.concat([detect_1, detect_2, detect_3], axis=1)<br/>    return detections</span></pre></div><div class="ab cl jn jo hu jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ij ik il im in"><h1 id="ecc6" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">4.转换预先训练的可可重量</h1><p id="e0de" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">我们定义了探测器的结构。要使用它，我们必须要么在我们自己的数据集上训练它，要么使用预训练的权重。COCO数据集上预先训练的重量可供公众使用。我们可以使用以下命令下载它:</p><pre class="ly lz ma mb gt nh ne ni nj aw nk bi"><span id="52f7" class="nl jv iq ne b gy nm nn l no np">wget <a class="ae lr" href="https://pjreddie.com/media/files/yolov3.weights" rel="noopener ugc nofollow" target="_blank">https://pjreddie.com/media/files/yolov3.weights</a></span></pre><p id="f817" class="pw-post-body-paragraph ks kt iq ku b kv ls kx ky kz lt lb lc ld lu lf lg lh lv lj lk ll lw ln lo lp ij bi translated">这个二进制文件的结构如下:</p><p id="0251" class="pw-post-body-paragraph ks kt iq ku b kv ls kx ky kz lt lb lc ld lu lf lg lh lv lj lk ll lw ln lo lp ij bi translated">前3个int32值是头信息:主版本号、次版本号、subversion号，后面是int64值:训练时网络看到的图像数。在它们之后，有62 001 757个float32值，它们是每个conv和批规范层的权重。重要的是要记住，它们是以行主格式保存的，这与Tensorflow(列主)使用的格式相反。</p><h2 id="4cf8" class="nl jv iq bd jw ns nt dn ka nu nv dp ke ld nw nx ki lh ny nz km ll oa ob kq oc bi translated">那么，我们应该如何从这个文件中读取权重呢？</h2><p id="414a" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">我们从第一层conv开始。大多数卷积层紧接着批标准化层。在这种情况下，我们需要先读取批范数层的4* <code class="fe nb nc nd ne b">num_filters</code>权值:gamma，beta，移动均值和移动方差，然后是conv层的<code class="fe nb nc nd ne b">kernel_size[0] * kernel_size[1] * num_filters * input_channels</code>权值。</p><p id="14fa" class="pw-post-body-paragraph ks kt iq ku b kv ls kx ky kz lt lb lc ld lu lf lg lh lv lj lk ll lw ln lo lp ij bi translated">在相反的情况下，当conv层后面没有批范数层时，我们需要读取<code class="fe nb nc nd ne b">num_filters</code>偏差权重，而不是读取批范数参数。</p><p id="16b4" class="pw-post-body-paragraph ks kt iq ku b kv ls kx ky kz lt lb lc ld lu lf lg lh lv lj lk ll lw ln lo lp ij bi translated">下面开始写<code class="fe nb nc nd ne b">load_weights</code>函数的代码。它有两个参数:图中变量的列表和二进制文件的名称。</p><p id="3df4" class="pw-post-body-paragraph ks kt iq ku b kv ls kx ky kz lt lb lc ld lu lf lg lh lv lj lk ll lw ln lo lp ij bi translated">我们从打开文件开始，跳过前5个int32值，并将其他所有内容作为列表读取:</p><pre class="ly lz ma mb gt nh ne ni nj aw nk bi"><span id="c10e" class="nl jv iq ne b gy nm nn l no np">def load_weights(var_list, weights_file):<br/>    with open(weights_file, "rb") as fp:<br/>        _ = np.fromfile(fp, dtype=np.int32, count=5)<br/><br/>        weights = np.fromfile(fp, dtype=np.float32)</span></pre><p id="5010" class="pw-post-body-paragraph ks kt iq ku b kv ls kx ky kz lt lb lc ld lu lf lg lh lv lj lk ll lw ln lo lp ij bi translated">然后我们将使用两个指针，第一个遍历变量列表<code class="fe nb nc nd ne b">var_list</code>，第二个遍历加载了变量的列表<code class="fe nb nc nd ne b">weights</code>。我们需要检查当前处理的层之后的层的类型，并读取适当数量的值。在代码中，<code class="fe nb nc nd ne b">i</code>将在<code class="fe nb nc nd ne b">var_list</code>上迭代，而<code class="fe nb nc nd ne b">ptr</code>将在<code class="fe nb nc nd ne b">weights</code>上迭代。我们将返回一个<code class="fe nb nc nd ne b">tf.assign</code>操作列表。我简单地通过比较图层的名称来检查图层的类型。(我承认有点丑，但是我不知道有什么更好的做法。这种方法似乎对我有用。)</p><pre class="ly lz ma mb gt nh ne ni nj aw nk bi"><span id="efa2" class="nl jv iq ne b gy nm nn l no np">ptr = 0<br/>i = 0<br/>assign_ops = []<br/>while i &lt; len(var_list) - 1:<br/>    var1 = var_list[i]<br/>    var2 = var_list[i + 1]<br/>    # do something only if we process conv layer<br/>    if 'Conv' in var1.name.split('/')[-2]:<br/>        # check type of next layer<br/>        if 'BatchNorm' in var2.name.split('/')[-2]:<br/>            # load batch norm params<br/>            gamma, beta, mean, var = var_list[i + 1:i + 5]<br/>            batch_norm_vars = [beta, gamma, mean, var]<br/>            for var in batch_norm_vars:<br/>                shape = var.shape.as_list()<br/>                num_params = np.prod(shape)<br/>                var_weights = weights[ptr:ptr + num_params].reshape(shape)<br/>                ptr += num_params<br/>                assign_ops.append(tf.assign(var, var_weights, validate_shape=True))<br/><br/>            # we move the pointer by 4, because we loaded 4 variables<br/>            i += 4<br/>        elif 'Conv' in var2.name.split('/')[-2]:<br/>            # load biases<br/>            bias = var2<br/>            bias_shape = bias.shape.as_list()<br/>            bias_params = np.prod(bias_shape)<br/>            bias_weights = weights[ptr:ptr + bias_params].reshape(bias_shape)<br/>            ptr += bias_params<br/>            assign_ops.append(tf.assign(bias, bias_weights, validate_shape=True))<br/><br/>            # we loaded 2 variables<br/>            i += 1<br/>        # we can load weights of conv layer<br/>        shape = var1.shape.as_list()<br/>        num_params = np.prod(shape)<br/><br/>        var_weights = weights[ptr:ptr + num_params].reshape((shape[3], shape[2], shape[0], shape[1]))<br/>        # remember to transpose to column-major<br/>        var_weights = np.transpose(var_weights, (2, 3, 1, 0))<br/>        ptr += num_params<br/>        assign_ops.append(tf.assign(var1, var_weights, validate_shape=True))<br/>        i += 1</span><span id="45a9" class="nl jv iq ne b gy od nn l no np">return assign_ops</span></pre><p id="36c1" class="pw-post-body-paragraph ks kt iq ku b kv ls kx ky kz lt lb lc ld lu lf lg lh lv lj lk ll lw ln lo lp ij bi translated">就是这样！现在，我们可以通过执行如下代码行来恢复模型的权重:</p><pre class="ly lz ma mb gt nh ne ni nj aw nk bi"><span id="0ade" class="nl jv iq ne b gy nm nn l no np">with tf.variable_scope('model'):<br/>    model = yolo_v3(inputs, 80)</span><span id="1762" class="nl jv iq ne b gy od nn l no np">model_vars = tf.global_variables(scope='model')<br/>assign_ops = load_variables(model_vars, 'yolov3.weights')</span><span id="8298" class="nl jv iq ne b gy od nn l no np">sess = tf.Session()<br/>sess.run(assign_ops)</span></pre><p id="5767" class="pw-post-body-paragraph ks kt iq ku b kv ls kx ky kz lt lb lc ld lu lf lg lh lv lj lk ll lw ln lo lp ij bi translated">对于将来的使用，使用tf.train.Saver导出权重并从检查点加载可能会容易得多。</p></div><div class="ab cl jn jo hu jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ij ik il im in"><h1 id="d7a8" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">5.后处理算法的实现</h1><p id="042d" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">我们的模型返回一个形状张量:</p><pre class="ly lz ma mb gt nh ne ni nj aw nk bi"><span id="6a62" class="nl jv iq ne b gy nm nn l no np">batch_size x 10647 x (num_classes + 5 bounding box attrs)</span></pre><p id="4a7a" class="pw-post-body-paragraph ks kt iq ku b kv ls kx ky kz lt lb lc ld lu lf lg lh lv lj lk ll lw ln lo lp ij bi translated">数字10647等于总和507 +2028 + 8112，这是在每种尺度上检测到的可能物体的数量。描述边界框属性的5个值代表<code class="fe nb nc nd ne b">center_x, center_y, width, height</code>。在大多数情况下，处理两个点的坐标更容易:左上和右下。让我们将检测器的输出转换成这种格式。</p><p id="4fb2" class="pw-post-body-paragraph ks kt iq ku b kv ls kx ky kz lt lb lc ld lu lf lg lh lv lj lk ll lw ln lo lp ij bi translated">这个函数非常简单:</p><pre class="ly lz ma mb gt nh ne ni nj aw nk bi"><span id="57df" class="nl jv iq ne b gy nm nn l no np">def detections_boxes(detections):<br/>    center_x, center_y, width, height, attrs = tf.split(detections, [1, 1, 1, 1, -1], axis=-1)<br/>    w2 = width / 2<br/>    h2 = height / 2<br/>    x0 = center_x - w2<br/>    y0 = center_y - h2<br/>    x1 = center_x + w2<br/>    y1 = center_y + h2<br/><br/>    boxes = tf.concat([x0, y0, x1, y1], axis=-1)<br/>    detections = tf.concat([boxes, attrs], axis=-1)<br/>    return detections</span></pre><p id="0680" class="pw-post-body-paragraph ks kt iq ku b kv ls kx ky kz lt lb lc ld lu lf lg lh lv lj lk ll lw ln lo lp ij bi translated">我们的探测器通常会多次探测到同一物体(中心和大小略有不同)。在大多数情况下，我们不想保留所有这些仅相差少量像素的检测。这个问题的标准解决方案是非最大抑制。此处提供了该方法的详细描述<a class="ae lr" href="https://www.coursera.org/learn/convolutional-neural-networks/lecture/dvrjH/non-max-suppression" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="8667" class="pw-post-body-paragraph ks kt iq ku b kv ls kx ky kz lt lb lc ld lu lf lg lh lv lj lk ll lw ln lo lp ij bi translated">我们为什么不用Tensorflow API的<code class="fe nb nc nd ne b">tf.image.non_max_suppression</code>函数呢？有两个主要原因。首先，在我看来，每个类执行NMS要好得多，因为我们可能会遇到这样的情况，两个不同类的对象高度重叠，全局NMS将抑制其中一个盒子。第二，有人在抱怨这个功能慢，因为还没有优化。</p><p id="daa3" class="pw-post-body-paragraph ks kt iq ku b kv ls kx ky kz lt lb lc ld lu lf lg lh lv lj lk ll lw ln lo lp ij bi translated">让我们实现NMS算法。首先，我们需要一个函数来计算两个边界框的IoU(交集/并集):</p><pre class="ly lz ma mb gt nh ne ni nj aw nk bi"><span id="78fe" class="nl jv iq ne b gy nm nn l no np">def _iou(box1, box2):<br/>    b1_x0, b1_y0, b1_x1, b1_y1 = box1<br/>    b2_x0, b2_y0, b2_x1, b2_y1 = box2<br/><br/>    int_x0 = max(b1_x0, b2_x0)<br/>    int_y0 = max(b1_y0, b2_y0)<br/>    int_x1 = min(b1_x1, b2_x1)<br/>    int_y1 = min(b1_y1, b2_y1)<br/><br/>    int_area = (int_x1 - int_x0) * (int_y1 - int_y0)<br/><br/>    b1_area = (b1_x1 - b1_x0) * (b1_y1 - b1_y0)<br/>    b2_area = (b2_x1 - b2_x0) * (b2_y1 - b2_y0)<br/><br/>    iou = int_area / (b1_area + b2_area - int_area + 1e-05)<br/>    return iou</span></pre><p id="85e3" class="pw-post-body-paragraph ks kt iq ku b kv ls kx ky kz lt lb lc ld lu lf lg lh lv lj lk ll lw ln lo lp ij bi translated">现在我们可以写<code class="fe nb nc nd ne b">non_max_suppression</code>函数的代码了。我使用NumPy库进行快速向量运算。</p><pre class="ly lz ma mb gt nh ne ni nj aw nk bi"><span id="b630" class="nl jv iq ne b gy nm nn l no np">def non_max_suppression(predictions_with_boxes, confidence_threshold, iou_threshold=0.4):<br/>    <em class="lq">"""<br/>    Applies Non-max suppression to prediction boxes.<br/><br/>    </em><strong class="ne ir"><em class="lq">:param</em></strong><em class="lq"> predictions_with_boxes: 3D numpy array, first 4 values in 3rd dimension are bbox attrs, 5th is confidence<br/>    </em><strong class="ne ir"><em class="lq">:param</em></strong><em class="lq"> confidence_threshold: the threshold for deciding if prediction is valid<br/>    </em><strong class="ne ir"><em class="lq">:param</em></strong><em class="lq"> iou_threshold: the threshold for deciding if two boxes overlap<br/>    </em><strong class="ne ir"><em class="lq">:return</em></strong><em class="lq">: dict: class -&gt; [(box, score)]<br/>    """</em></span></pre><p id="1ba4" class="pw-post-body-paragraph ks kt iq ku b kv ls kx ky kz lt lb lc ld lu lf lg lh lv lj lk ll lw ln lo lp ij bi translated">它需要3个参数:YOLO v3检测器的输出、置信度阈值和IoU阈值。该函数的主体如下所示:</p><pre class="ly lz ma mb gt nh ne ni nj aw nk bi"><span id="f97a" class="nl jv iq ne b gy nm nn l no np">conf_mask = np.expand_dims((predictions_with_boxes[:, :, 4] &gt; confidence_threshold), -1)<br/>predictions = predictions_with_boxes * conf_mask<br/><br/>result = {}<br/>for i, image_pred in enumerate(predictions):<br/>    shape = image_pred.shape<br/>    non_zero_idxs = np.nonzero(image_pred)<br/>    image_pred = image_pred[non_zero_idxs]<br/>    image_pred = image_pred.reshape(-1, shape[-1])<br/><br/>    bbox_attrs = image_pred[:, :5]<br/>    classes = image_pred[:, 5:]<br/>    classes = np.argmax(classes, axis=-1)<br/><br/>    unique_classes = list(set(classes.reshape(-1)))<br/><br/>    for cls in unique_classes:<br/>        cls_mask = classes == cls<br/>        cls_boxes = bbox_attrs[np.nonzero(cls_mask)]<br/>        cls_boxes = cls_boxes[cls_boxes[:, -1].argsort()[::-1]]<br/>        cls_scores = cls_boxes[:, -1]<br/>        cls_boxes = cls_boxes[:, :-1]<br/><br/>        while len(cls_boxes) &gt; 0:<br/>            box = cls_boxes[0]<br/>            score = cls_scores[0]<br/>            if not cls in result:<br/>                result[cls] = []<br/>            result[cls].append((box, score))<br/>            cls_boxes = cls_boxes[1:]<br/>            ious = np.array([_iou(box, x) for x in cls_boxes])<br/>            iou_mask = ious &lt; iou_threshold<br/>            cls_boxes = cls_boxes[np.nonzero(iou_mask)]<br/>            cls_scores = cls_scores[np.nonzero(iou_mask)]<br/><br/>return result</span></pre><p id="7e99" class="pw-post-body-paragraph ks kt iq ku b kv ls kx ky kz lt lb lc ld lu lf lg lh lv lj lk ll lw ln lo lp ij bi translated">差不多就是这样。我们实现了YOLO v3工作所需的所有功能。</p></div><div class="ab cl jn jo hu jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ij ik il im in"><h1 id="6cb8" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">6.摘要</h1><p id="e9b9" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">在教程<a class="ae lr" href="https://github.com/mystic123/tensorflow-yolo-v3" rel="noopener ugc nofollow" target="_blank"> repo </a>中你可以找到运行检测的代码和一些演示脚本。检测机支持NHWC和NCHW两种数据格式，因此您可以轻松选择哪种格式在您的机器上运行更快。</p><p id="4599" class="pw-post-body-paragraph ks kt iq ku b kv ls kx ky kz lt lb lc ld lu lf lg lh lv lj lk ll lw ln lo lp ij bi translated">如果你有任何问题，请不要犹豫与我联系。</p><p id="4a86" class="pw-post-body-paragraph ks kt iq ku b kv ls kx ky kz lt lb lc ld lu lf lg lh lv lj lk ll lw ln lo lp ij bi translated">我计划撰写本教程的下一部分，在其中我将展示如何在自定义数据集上训练(微调)YOLO v3。</p><p id="dd77" class="pw-post-body-paragraph ks kt iq ku b kv ls kx ky kz lt lb lc ld lu lf lg lh lv lj lk ll lw ln lo lp ij bi translated">感谢阅读。请通过鼓掌和/或分享让我知道你是否喜欢它！:)</p></div></div>    
</body>
</html>