<html>
<head>
<title>Logging on the Cheap</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">廉价伐木</h1>
<blockquote>原文：<a href="https://itnext.io/logging-on-the-cheap-568674fa6387?source=collection_archive---------4-----------------------#2020-01-16">https://itnext.io/logging-on-the-cheap-568674fa6387?source=collection_archive---------4-----------------------#2020-01-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/d38e5b83dfc609b35e81783a3891e316.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*B3OQU784-sR9Rc7p"/></div></div></figure><div class=""/><div class=""><h2 id="e134" class="pw-subtitle-paragraph kb jd je bd b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks dk translated">JVM的超低开销日志记录</h2></div><blockquote class="kt ku kv"><p id="97e6" class="kw kx ky kz b la lb kf lc ld le ki lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">记录还是不记录？</p></blockquote><p id="2966" class="pw-post-body-paragraph kw kx je kz b la lb kf lc ld le ki lf lt lh li lj lu ll lm ln lv lp lq lr ls im bi translated">编写新代码是应用程序开发中相对较小的一部分。软件工程师生活中的很大一部分涉及到支持和维护现有的系统。首先，这需要正确的洞察力——理解系统到底在做什么，特别是当这不是你(和你的客户)所期望的时候。日志记录、跟踪、远程调试和应用程序性能监控对于达到舒适操作和支持现代应用程序套件所需的可观察性水平至关重要。</p><p id="ab8c" class="pw-post-body-paragraph kw kx je kz b la lb kf lc ld le ki lf lt lh li lj lu ll lm ln lv lp lq lr ls im bi translated">在构建传统的应用程序时，是否应该记录某个操作的问题很少会引起激烈的争论。(所谓“常规的”，我们指的是大多数电子商务应用程序，它们具有相当常规的非功能性需求，涉及吞吐量、延迟、可用性等等。)偶尔，我们会遇到一类打破这种模式的应用程序。有时，传统系统的特定模块可能会受到非常严格的性能约束。一个应用程序可能在一个严格的循环中执行一个昂贵的计算，或者可能需要在一个严格的时间框架内做出响应(平均而言)。这些应用程序的侵入性检测改变了它们的计时行为——即使是简单的日志调用也会带来开销，这可能会对客户体验产生重大影响。在这些场景中，本文开头提出的问题是——<em class="ky">记录还是不记录？</em>——成为真正的争论点。你会为了可观察性而牺牲极限性能吗，或者性能是令人垂涎的赚钱机器，让所有其他关注都相形见绌吗？</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="76b9" class="md me je bd mf mg mh mi mj mk ml mm mn kk mo kl mp kn mq ko mr kq ms kr mt mu bi translated">介绍Zerolog？</h1><p id="67ed" class="pw-post-body-paragraph kw kx je kz b la mv kf lc ld mw ki lf lt mx li lj lu my lm ln lv mz lq lr ls im bi translated">本文将探索<a class="ae na" href="https://github.com/obsidiandynamics/zerolog" rel="noopener ugc nofollow" target="_blank"> Zerolog </a>(缩写为Zlg)——一种用于性能敏感型Java应用程序的超低开销日志记录外观。Zlg的目标有两个—</p><ol class=""><li id="705c" class="nb nc je kz b la lb ld le lt nd lu ne lv nf ls ng nh ni nj bi translated"><strong class="kz jf">抑制日志记录的超低开销。</strong>换句话说，当该级别的日志记录被禁用时，调用日志方法的成本可以忽略不计。此外，有可能以这样一种方式调用Zlg来将这些成本降低到绝对零。</li><li id="fe7c" class="nb nc je kz b la nk ld nl lt nm lu nn lv no ls ng nh ni nj bi translated"><strong class="kz jf">不妥协的代码覆盖率。</strong>日志记录的抑制不应该影响语句和分支覆盖度量。日志条目和其他任何语句一样，如果值得编写，就值得测试。</li></ol><p id="3fc9" class="pw-post-body-paragraph kw kx je kz b la lb kf lc ld le ki lf lt lh li lj lu ll lm ln lv lp lq lr ls im bi translated">总的来说，这些目标使得Zlg适合在超高性能、低延迟应用程序和高保证环境中使用。</p><h1 id="d19b" class="md me je bd mf mg np mi mj mk nq mm mn kk nr kl mp kn ns ko mr kq nt kr mt mu bi translated">有多快？</h1><p id="e93a" class="pw-post-body-paragraph kw kx je kz b la mv kf lc ld mw ki lf lt mx li lj lu my lm ln lv mz lq lr ls im bi translated">这篇文章值得我花费时间吗？当然，日志库和外观已经被优化到极致。值得考虑另一种选择吗？</p><p id="93bc" class="pw-post-body-paragraph kw kx je kz b la lb kf lc ld le ki lf lt lh li lj lu ll lm ln lv lp lq lr ls im bi translated">这些都是合理的问题。在抑制日志记录的情况下，在一个<a class="ae na" href="https://ark.intel.com/products/75122/Intel-Core-i7-4770-Processor-8M-Cache-up-to-3_90-GHz" rel="noopener ugc nofollow" target="_blank">i7–4770 has well</a>CPU上进行的JMH基准测试比较了Zlg与一些主要日志记录程序的每次调用损失。四个原语被传递给每个日志记录器进行格式化，这是一个典型日志条目的合理表示。</p><figure class="nv nw nx ny gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nu"><img src="../Images/174e1868a1d2142bd7a42493bb1d9bbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:906/format:webp/0*1mL2vBq6vKIqnGYd.png"/></div></div><figcaption class="nz oa gj gh gi ob oc bd b be z dk translated">性能比较</figcaption></figure><blockquote class="kt ku kv"><p id="d67d" class="kw kx ky kz b la lb kf lc ld le ki lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated"><strong class="kz jf"> <em class="je">注:</em> </strong> <em class="je">运行是在CentOS 7上进行的，运行JDK 10。要复制，运行</em> <code class="fe od oe of og b"><em class="je">./gradlew launch -Dlauncher.class=AllBenchmarks</em></code> <em class="je">。</em></p></blockquote><p id="a93f" class="pw-post-body-paragraph kw kx je kz b la lb kf lc ld le ki lf lt lh li lj lu ll lm ln lv lp lq lr ls im bi translated">请稍等片刻，在我们深入探讨之前，先澄清一些事情。当代的日志门面和图书馆(如SLF4J和Log4j 2.x)非常棒。对于99%的传统应用程序来说，它们已经足够了，这些应用程序每秒处理数百或数千件事情，通常响应时间为毫秒级。坦率地说，在当代微服务架构中，网络调用和I/O的数量远远超过了日志调用和任何其他低级工具。从工程的角度来看，生活在毫秒的世界里却提取纳秒级的性能无异于自残。所以不，这篇文章并不适合所有人，甚至不适合大多数人。</p><h1 id="483e" class="md me je bd mf mg np mi mj mk nq mm mn kk nr kl mp kn ns ko mr kq nt kr mt mu bi translated">我能在哪里找到它？</h1><p id="ea7c" class="pw-post-body-paragraph kw kx je kz b la mv kf lc ld mw ki lf lt mx li lj lu my lm ln lv mz lq lr ls im bi translated">Zerolog是一个开源(BSD许可)的Java 8项目，托管在GitHub上。</p><div class="is it gp gr iu oh"><a href="https://github.com/obsidiandynamics/zerolog" rel="noopener  ugc nofollow" target="_blank"><div class="oi ab fo"><div class="oj ab ok cl cj ol"><h2 class="bd jf gy z fp om fr fs on fu fw jd bi translated">obsidiandynamics/zerolog</h2><div class="oo l"><h3 class="bd b gy z fp om fr fs on fu fw dk translated">面向性能敏感型应用的低开销日志记录外观。Zerolog(缩写为Zlg)是一个日志外观…</h3></div><div class="op l"><p class="bd b dl z fp om fr fs on fu fw dk translated">github.com</p></div></div><div class="oq l"><div class="or l os ot ou oq ov ja oh"/></div></div></a></div><h1 id="4e40" class="md me je bd mf mg np mi mj mk nq mm mn kk nr kl mp kn ns ko mr kq nt kr mt mu bi translated">入门指南</h1><h2 id="7b78" class="ow me je bd mf ox oy dn mj oz pa dp mn lt pb pc mp lu pd pe mr lv pf pg mt ph bi translated">属国</h2><p id="482a" class="pw-post-body-paragraph kw kx je kz b la mv kf lc ld mw ki lf lt mx li lj lu my lm ln lv mz lq lr ls im bi translated">Gradle构建托管在JCenter上。将下面的代码片段添加到您的构建文件中，用本自述文件顶部下载标记上显示的版本替换<code class="fe od oe of og b">x.y.z</code>。</p><pre class="nv nw nx ny gt pi og pj pk aw pl bi"><span id="a963" class="ow me je og b gy pm pn l po pp">compile "com.obsidiandynamics.zerolog:zerolog-core:x.y.z"<br/>compile "com.obsidiandynamics.zerolog:&lt;binding&gt;:x.y.z"</span></pre><p id="6472" class="pw-post-body-paragraph kw kx je kz b la lb kf lc ld le ki lf lt lh li lj lu ll lm ln lv lp lq lr ls im bi translated">您需要<code class="fe od oe of og b">zerolog-core</code>模块，通常还需要一个绑定模块。目前唯一支持的Zlg绑定是<code class="fe od oe of og b">zerolog-slf4j17</code>，它应该可以与任何具有SLF4J 1.7.x绑定的日志记录器一起工作。(这涵盖了所有主要的伐木工。)例如，要将Zlg与Log4j 1.2.17一起使用，请在您的<code class="fe od oe of og b">build.gradle</code>中添加以下内容(适当替换<code class="fe od oe of og b">x.y.z</code>)。</p><pre class="nv nw nx ny gt pi og pj pk aw pl bi"><span id="740e" class="ow me je og b gy pm pn l po pp">compile "com.obsidiandynamics.zerolog:zerolog-core:x.y.z"<br/>compile "com.obsidiandynamics.zerolog:zerolog-slf4j17:x.y.z"<br/>runtime "org.slf4j:slf4j-api:1.7.25"<br/>runtime "org.slf4j:slf4j-log4j12:1.7.25"<br/>runtime "log4j:log4j:1.2.17"</span></pre><blockquote class="kt ku kv"><p id="bb82" class="kw kx ky kz b la lb kf lc ld le ki lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated"><strong class="kz jf"> <em class="je">注意:</em> </strong> <em class="je"> </em> <code class="fe od oe of og b"><em class="je">zerolog-slf4j17</em></code> <em class="je">不声明特定的</em> <code class="fe od oe of og b"><em class="je">slf4j-api</em></code> <em class="je">版本Maven依赖，允许您在项目中提名任何二进制兼容的SLF4J API版本。结果是，您必须在您的构建文件中显式包含</em> <code class="fe od oe of og b"><em class="je">slf4j-api</em></code> <em class="je">版本。这可以归入</em> <code class="fe od oe of og b"><em class="je">runtime</em></code> <em class="je">配置(除非你需要在应用程序中直接使用SLF4J，和Zlg一起)。</em></p></blockquote><h1 id="9965" class="md me je bd mf mg np mi mj mk nq mm mn kk nr kl mp kn ns ko mr kq nt kr mt mu bi translated">记录</h1><p id="1105" class="pw-post-body-paragraph kw kx je kz b la mv kf lc ld mw ki lf lt mx li lj lu my lm ln lv mz lq lr ls im bi translated">获得一个logger实例与SLF4J没有太大区别。通常，首先从工厂获得一个命名的记录器实例，然后将其分配给一个实例或一个静态字段，如下所示。</p><pre class="nv nw nx ny gt pi og pj pk aw pl bi"><span id="2b00" class="ow me je og b gy pm pn l po pp">public final class SysOutLoggingSample {<br/>  private static final Zlg zlg = Zlg.forDeclaringClass().get();  <br/>  <br/>  public static void open(String address, <br/>                          int port, double timeoutSeconds) {<br/>    zlg.i("Hello world");<br/>    zlg.i("Pi is %.2f", z -&gt; z.arg(Math.PI));<br/>    zlg.i("Connecting to %s:%d [timeout: %.1f sec]", <br/>          z -&gt; z.arg(address).arg(port).arg(timeoutSeconds));    <br/>    try {<br/>      openSocket(address, port, timeoutSeconds);<br/>    } catch (IOException e) {<br/>      zlg.w("Error connecting to %s:%d", <br/>            z -&gt; z.arg(address).arg(port).tag("I/O").threw(e));<br/>    }<br/>  }<br/>}</span></pre><p id="a478" class="pw-post-body-paragraph kw kx je kz b la lb kf lc ld le ki lf lt lh li lj lu ll lm ln lv lp lq lr ls im bi translated">一些需要注意的重要事项:</p><ul class=""><li id="129e" class="nb nc je kz b la lb ld le lt nd lu ne lv nf ls pq nh ni nj bi translated">记录器是一个<code class="fe od oe of og b">Zlg</code>实例，为一个特定的类(使用<code class="fe od oe of og b">forClass()</code>)或一个任意的名字(使用<code class="fe od oe of og b">forName()</code>)创建。</li><li id="00ad" class="nb nc je kz b la nk ld nl lt nm lu nn lv no ls pq nh ni nj bi translated">调用<code class="fe od oe of og b">forDeclaringClass()</code>是<code class="fe od oe of og b">forClass(TheDeclaringClass.class)</code>的简写等价物，其中<code class="fe od oe of og b">TheDeclaringClass</code>是声明记录器的类的名称。</li><li id="3406" class="nb nc je kz b la nk ld nl lt nm lu nn lv no ls pq nh ni nj bi translated">按照惯例，我们将记录器分配给一个名为<code class="fe od oe of og b">zlg</code>的字段。</li><li id="19a5" class="nb nc je kz b la nk ld nl lt nm lu nn lv no ls pq nh ni nj bi translated">日志记录是通过一个流畅的链调用的，从指定强制格式字符串的日志级别(缩写为第一个字母)开始，后面是任何可选参数(原语或对象类型)、可选标记和可选异常。</li><li id="c37f" class="nb nc je kz b la nk ld nl lt nm lu nn lv no ls pq nh ni nj bi translated">格式字符串是<code class="fe od oe of og b">printf</code>风格的，不像其他大多数记录器使用<code class="fe od oe of og b">{}</code> (stash)符号。</li></ul><h2 id="93b0" class="ow me je bd mf ox oy dn mj oz pa dp mn lt pb pc mp lu pd pe mr lv pf pg mt ph bi translated">懒惰参数</h2><p id="83f1" class="pw-post-body-paragraph kw kx je kz b la mv kf lc ld mw ki lf lt mx li lj lu my lm ln lv mz lq lr ls im bi translated">当值<em class="ky">已经</em>可用并且可以按原样提供给记录器时，链式args模式工作良好。如果需要进一步的工作来制定参数，则日志隐藏不会阻止对这些表达式进行求值。例如，下面的调用将调用<code class="fe od oe of og b">List</code>上的<code class="fe od oe of og b">size()</code>方法，而不管日志记录是启用还是取消。换句话说，不管怎样，你都要付出代价。</p><pre class="nv nw nx ny gt pi og pj pk aw pl bi"><span id="f827" class="ow me je og b gy pm pn l po pp">final List&lt;Integer&gt; numbers = Arrays.asList(5, 6, 7, 8);<br/>zlg.i("The list %s has %d elements", <br/>      z -&gt; z.arg(numbers).arg(numbers.size()).tag("list"));</span></pre><h2 id="c9ff" class="ow me je bd mf ox oy dn mj oz pa dp mn lt pb pc mp lu pd pe mr lv pf pg mt ph bi translated">供应商</h2><p id="e136" class="pw-post-body-paragraph kw kx je kz b la mv kf lc ld mw ki lf lt mx li lj lu my lm ln lv mz lq lr ls im bi translated">为了避免不必要的参数评估，Zlg支持FP风格的供应商和转换。(FP代表<em class="ky">功能编程</em>。)上面的例子可以重写，使用方法引用通过getter方法引用提供原始值。</p><pre class="nv nw nx ny gt pi og pj pk aw pl bi"><span id="e104" class="ow me je og b gy pm pn l po pp">zlg.i("The list %s has %d elements", <br/>      z -&gt; z.arg(numbers).arg(numbers::size).tag("list"));</span></pre><p id="2bb5" class="pw-post-body-paragraph kw kx je kz b la lb kf lc ld le ki lf lt lh li lj lu ll lm ln lv lp lq lr ls im bi translated">通过简单地将<code class="fe od oe of og b">list.size()</code>改为<code class="fe od oe of og b">list::size</code>,我们避免了潜在的多余方法调用。我们的建议是总是偏爱方法引用而不是lambda风格的闭包。这种方式<em class="ky">不会编写新代码</em>，对代码覆盖率没有影响。</p><h2 id="8ec4" class="ow me je bd mf ox oy dn mj oz pa dp mn lt pb pc mp lu pd pe mr lv pf pg mt ph bi translated">转换</h2><p id="ad94" class="pw-post-body-paragraph kw kx je kz b la mv kf lc ld mw ki lf lt mx li lj lu my lm ln lv mz lq lr ls im bi translated">通常我们不会奢侈地调用一个对象上的单个无参数方法来获得一个好的、日志友好的表示。Zlg提供了一种方便的方法，将延迟求值的转换提取到一个单独的静态方法中，只需要一个参数——要转换的对象。</p><p id="05b1" class="pw-post-body-paragraph kw kx je kz b la lb kf lc ld le ki lf lt lh li lj lu ll lm ln lv lp lq lr ls im bi translated">在下一个示例中，我们将从人员列表中搜索一个人的姓名。如果找不到名字，我们希望记录列表的内容，但不透露人们的姓氏。正在讨论的转换是一个静态的<code class="fe od oe of og b">tokeniseSurnames()</code>函数，接受一组<code class="fe od oe of og b">Name</code>对象。为了附加转换，我们使用<code class="fe od oe of og b">Args.map(Supplier, Function)</code>实用程序方法，提供原始(未转换的)值引用和转换方法引用。剩下的就是Zlg的问题了。</p><pre class="nv nw nx ny gt pi og pj pk aw pl bi"><span id="7a95" class="ow me je og b gy pm pn l po pp">private static final Zlg zlg = Zlg.forDeclaringClass().get();public static final class Name {<br/>  final String forename;<br/>  final String surname;  Name(String forename, String surname) {<br/>    this.forename = forename;<br/>    this.surname = surname;<br/>  }<br/>}</span><span id="ee6d" class="ow me je og b gy pr pn l po pp">public static void logWithTransform() {<br/>  final List&lt;Name&gt; hackers = <br/>      Arrays.asList(new Name("Kevin", "Flynn"), <br/>                    new Name("Thomas", "Anderson"), <br/>                    new Name("Angela", "Bennett"));<br/>  final String surnameToFind = "Smith";  </span><span id="3d6a" class="ow me je og b gy pr pn l po pp">  if (! hackers.stream()<br/>      .anyMatch(n -&gt; n.surname.contains(surnameToFind))) {<br/>    zlg.i("%s not found among %s", <br/>          z -&gt; z<br/>          .arg(surnameToFind)<br/>          .arg(Args.map(Args.ref(hackers), <br/>                        LazyLogSample::tokeniseSurnames)));<br/>  }<br/>}</span><span id="510e" class="ow me je og b gy pr pn l po pp">static List&lt;String&gt; tokeniseSurnames(Collection&lt;Name&gt; names) {<br/>  return names<br/>     .stream()<br/>     .map(n -&gt; n.forename + " " + <br/>          n.surname.replaceAll(".", "X")).collect(toList());<br/>}</span></pre><p id="c415" class="pw-post-body-paragraph kw kx je kz b la lb kf lc ld le ki lf lt lh li lj lu ll lm ln lv lp lq lr ls im bi translated">被转换的值本身可以被延迟检索。下面的例子使用自定义的<code class="fe od oe of og b">DateFormat</code>打印当前时间；<code class="fe od oe of og b">Date</code>对象被有条件地实例化。</p><pre class="nv nw nx ny gt pi og pj pk aw pl bi"><span id="3abb" class="ow me je og b gy pm pn l po pp">private static final Zlg zlg = Zlg.forDeclaringClass().get();public </span><span id="94fe" class="ow me je og b gy pr pn l po pp">static void logWithSupplierAndTransform() {<br/>  zlg.i("The current time is %s", <br/>        z -&gt; z.arg(Args.map(Date::new, LazyLogSample::formatDate)));<br/>}</span><span id="e2d6" class="ow me je og b gy pr pn l po pp">private static String formatDate(Date date) {<br/>  return new SimpleDateFormat("MMM dd HH:mm:ss").format(date);<br/>}</span></pre><p id="10d5" class="pw-post-body-paragraph kw kx je kz b la lb kf lc ld le ki lf lt lh li lj lu ll lm ln lv lp lq lr ls im bi translated">关于转换和提供者，有一点需要注意:它们和其他代码一样，应该进行相应的单元测试。您可能有一个有问题的转换，并且由于它的懒惰评估，当测试包含日志指令的代码时(如果日志被禁止)没有发现它。因为转换和提供者是简单的、单一责任的“纯”功能，对它们进行单元测试应该是简单明了的。</p><h2 id="9b92" class="ow me je bd mf ox oy dn mj oz pa dp mn lt pb pc mp lu pd pe mr lv pf pg mt ph bi translated">标签</h2><p id="ea08" class="pw-post-body-paragraph kw kx je kz b la mv kf lc ld mw ki lf lt mx li lj lu my lm ln lv mz lq lr ls im bi translated">Zlg增加了一个<em class="ky">标签</em>的概念——一个可选的字符串值，可以用来修饰一个日志条目。在SLF4J，标记相当于标记，为日志输出添加了另一个维度。</p><h2 id="c5a6" class="ow me je bd mf ox oy dn mj oz pa dp mn lt pb pc mp lu pd pe mr lv pf pg mt ph bi translated">日志级别</h2><p id="1dce" class="pw-post-body-paragraph kw kx je kz b la mv kf lc ld mw ki lf lt mx li lj lu my lm ln lv mz lq lr ls im bi translated">Zlg日志级别与SLF4J(和大多数其他日志程序)相当一致。Zlg引入了一个新的日志级别——<code class="fe od oe of og b">LogLevel.CONF</code>——逻辑上位于<code class="fe od oe of og b">DEBUG</code>和<code class="fe od oe of og b">INFO</code>之间。<code class="fe od oe of og b">CONF</code>是从JUL ( <code class="fe od oe of og b">java.util.logging</code>)借用来的，用于记录初始化和配置参数，在应用程序向用户提供各种配置选项时非常有用。</p><blockquote class="kt ku kv"><p id="6d72" class="kw kx ky kz b la lb kf lc ld le ki lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated"><strong class="kz jf"> <em class="je">注:</em> </strong> <em class="je"> </em> <code class="fe od oe of og b"><em class="je">CONF</em></code> <em class="je">是规范地映射到那些不支持</em> <code class="fe od oe of og b"><em class="je">CONF</em></code> <em class="je">的记录器中的</em> <code class="fe od oe of og b"><em class="je">INFO</em></code> <em class="je">。</em></p></blockquote><p id="5778" class="pw-post-body-paragraph kw kx je kz b la lb kf lc ld le ki lf lt lh li lj lu ll lm ln lv lp lq lr ls im bi translated">内置日志级别从低到高依次为:<code class="fe od oe of og b">TRACE</code>、<code class="fe od oe of og b">DEBUG</code>、<code class="fe od oe of og b">CONF</code>、<code class="fe od oe of og b">INFO</code>、<code class="fe od oe of og b">WARN</code>、<code class="fe od oe of og b">ERROR</code>、<code class="fe od oe of og b">OFF</code>。</p><p id="83eb" class="pw-post-body-paragraph kw kx je kz b la lb kf lc ld le ki lf lt lh li lj lu ll lm ln lv lp lq lr ls im bi translated"><code class="fe od oe of og b">OFF</code>不是合法的日志级别，因为它不能用于从应用程序代码输出日志条目；它被方便地用于抑制——所有级别中的最高级别。</p><h1 id="e3bc" class="md me je bd mf mg np mi mj mk nq mm mn kk nr kl mp kn ns ko mr kq nt kr mt mu bi translated">配置</h1><h2 id="bdbc" class="ow me je bd mf ox oy dn mj oz pa dp mn lt pb pc mp lu pd pe mr lv pf pg mt ph bi translated">粘合剂</h2><p id="d597" class="pw-post-body-paragraph kw kx je kz b la mv kf lc ld mw ki lf lt mx li lj lu my lm ln lv mz lq lr ls im bi translated">作为一个外观，Zlg将所有日志调用委托给一个实际的日志记录器——一个<code class="fe od oe of og b">LogService</code>的实现。默认情况下，Zlg预打包了一个非常基本的‘故障保护’<code class="fe od oe of og b">SysOutLogService</code>，它以固定格式将条目打印到<code class="fe od oe of og b">System.out</code>。下面的例子。</p><pre class="nv nw nx ny gt pi og pj pk aw pl bi"><span id="c929" class="ow me je og b gy pm pn l po pp"><strong class="og jf">21:18:11.771 INF [main]</strong> SysOutLoggingSample.open:20: Connecting to github.com:80 [timeout: 30.0 sec]<br/><strong class="og jf">21:18:11.773 WRN [main]</strong> <strong class="og jf">[I/O]</strong> SysOutLoggingSample.open:25: Error connecting to github.com:80</span></pre><p id="c6c4" class="pw-post-body-paragraph kw kx je kz b la lb kf lc ld le ki lf lt lh li lj lu ll lm ln lv lp lq lr ls im bi translated">Zlg使用Java的<a class="ae na" href="https://docs.oracle.com/javase/tutorial/ext/basics/spi.html" rel="noopener ugc nofollow" target="_blank"> SPI </a>插件机制检测已安装的绑定。默认情况下，只要在类路径中包含一个绑定，Zlg就会切换到新的绑定。</p><h2 id="6903" class="ow me je bd mf ox oy dn mj oz pa dp mn lt pb pc mp lu pd pe mr lv pf pg mt ph bi translated">记录器配置</h2><p id="ec45" class="pw-post-body-paragraph kw kx je kz b la mv kf lc ld mw ki lf lt mx li lj lu my lm ln lv mz lq lr ls im bi translated">像SLF4J一样，Zlg在日志配置管理方面基本上不插手，将配置细节留给绑定的日志实现。例如，Log4j 1.2的配置将通过<code class="fe od oe of og b">log4j.properties</code>完成；Zlg对此保持完全不可知论。</p><h2 id="4a8a" class="ow me je bd mf ox oy dn mj oz pa dp mn lt pb pc mp lu pd pe mr lv pf pg mt ph bi translated">使用<code class="fe od oe of og b">zlg.properties</code>的基线配置</h2><p id="6238" class="pw-post-body-paragraph kw kx je kz b la mv kf lc ld mw ki lf lt mx li lj lu my lm ln lv mz lq lr ls im bi translated">Zlg通过从类路径中读取可选的<code class="fe od oe of og b">zlg.properties</code>文件来支持<em class="ky">基线</em>配置。基线配置包括可选属性列表。例如，它指定基本日志级别(低于该级别，所有日志记录都被禁用)，并且可以覆盖默认绑定。下面是一个<code class="fe od oe of og b">zlg.properties</code>的例子。</p><pre class="nv nw nx ny gt pi og pj pk aw pl bi"><span id="8e4c" class="ow me je og b gy pm pn l po pp">zlg.base.level=CONF<br/>zlg.log.service=com.obsidiandynamics.zerolog.SysOutLogService</span></pre><p id="be51" class="pw-post-body-paragraph kw kx je kz b la lb kf lc ld le ki lf lt lh li lj lu ll lm ln lv lp lq lr ls im bi translated"><code class="fe od oe of og b">zlg.base.level</code>属性指定最低启用日志级别(不考虑绑定日志记录器可能允许的级别)。默认值是<code class="fe od oe of og b">CONF</code>，这意味着除非基线改变，<code class="fe od oe of og b">TRACE</code>和<code class="fe od oe of og b">DEBUG</code>条目将被忽略。选择<code class="fe od oe of og b">CONF</code>作为默认级别最接近典型的生产配置。</p><h2 id="1f91" class="ow me je bd mf ox oy dn mj oz pa dp mn lt pb pc mp lu pd pe mr lv pf pg mt ph bi translated">改变<code class="fe od oe of og b">zlg.properties</code>的位置</h2><p id="bd5f" class="pw-post-body-paragraph kw kx je kz b la mv kf lc ld mw ki lf lt mx li lj lu my lm ln lv mz lq lr ls im bi translated">通过设置<code class="fe od oe of og b">zlg.default.config.uri</code>系统属性可以覆盖<code class="fe od oe of og b">zlg.properties</code>的默认位置。默认的URI是<code class="fe od oe of og b">cp://zlg.properties</code>，<code class="fe od oe of og b">cp://</code>表示“类路径”。或者，可以用<code class="fe od oe of og b">file://</code>方案指定文件系统位置。</p><p id="9173" class="pw-post-body-paragraph kw kx je kz b la lb kf lc ld le ki lf lt lh li lj lu ll lm ln lv lp lq lr ls im bi translated">当覆盖默认文件位置时，理想情况下，<code class="fe od oe of og b">zlg.default.config.uri</code>属性应该作为一个<code class="fe od oe of og b">-D...</code> JVM参数传入，以确保日志子系统在初始使用前被正确引导。</p><h2 id="5049" class="ow me je bd mf ox oy dn mj oz pa dp mn lt pb pc mp lu pd pe mr lv pf pg mt ph bi translated">直列配置</h2><p id="dadc" class="pw-post-body-paragraph kw kx je kz b la mv kf lc ld mw ki lf lt mx li lj lu my lm ln lv mz lq lr ls im bi translated">除了<code class="fe od oe of og b">zlg.properties</code>之外，Zlg还支持获取记录器时的内嵌配置:</p><pre class="nv nw nx ny gt pi og pj pk aw pl bi"><span id="6a47" class="ow me je og b gy pm pn l po pp">final Zlg zlg = Zlg<br/>    .forDeclaringClass()<br/>    .withConfigService(new </span><span id="e230" class="ow me je og b gy pr pn l po pp">LogConfig().withBaseLevel(LogLevel.TRACE))<br/>    .get();</span></pre><p id="9856" class="pw-post-body-paragraph kw kx je kz b la lb kf lc ld le ki lf lt lh li lj lu ll lm ln lv lp lq lr ls im bi translated">内嵌配置优先，覆盖任何系统默认值或由<code class="fe od oe of og b">zlg.properties</code>提供的值。因此，如果您希望在对所有其他类使用SLF4J绑定的同时，强制某个特定类作为特例登录到控制台，您可以这样做:</p><pre class="nv nw nx ny gt pi og pj pk aw pl bi"><span id="0a78" class="ow me je og b gy pm pn l po pp">final Zlg zlg = Zlg<br/>    .forDeclaringClass()<br/>    .withConfigService(new LogConfig()<br/>                       .withBaseLevel(LogLevel.TRACE)<br/>                       .withLogService(new SysOutLogService()))<br/>    .get();</span></pre><h1 id="4cf5" class="md me je bd mf mg np mi mj mk nq mm mn kk nr kl mp kn ns ko mr kq nt kr mt mu bi translated">Zerolog为什么这么快？</h1><p id="aa68" class="pw-post-body-paragraph kw kx je kz b la mv kf lc ld mw ki lf lt mx li lj lu my lm ln lv mz lq lr ls im bi translated">一个更好的问题可能是:<em class="ky">为什么典型的伐木工人和伐木外观这么慢？</em>一个典型的SLF4J语句(其他伐木工大多都在同一条船上)看起来像这样:</p><pre class="nv nw nx ny gt pi og pj pk aw pl bi"><span id="3899" class="ow me je og b gy pm pn l po pp">logger.trace("float: {}, double: {}, int: {}, long: {}", <br/>             f, d, i, l);</span></pre><p id="c93a" class="pw-post-body-paragraph kw kx je kz b la lb kf lc ld le ki lf lt lh li lj lu ll lm ln lv lp lq lr ls im bi translated">这种方法有三个问题，每一个都是很大的性能消耗。</p><ol class=""><li id="08ca" class="nb nc je kz b la lb ld le lt nd lu ne lv nf ls ng nh ni nj bi translated"><strong class="kz jf">使用varargs传递参数。</strong>通常，除了两到四个(取决于API设计者的慷慨程度)格式化参数之外，记录器将提供一个基于varargs的API来容纳任意数量的参数。Varargs只是语法糖；性能影响是数组分配的影响。此外，在优化之前进行的任何转义分析都会得出这样的结论:数组的使用可能会超出方法调用的范围，因此堆栈分配将是不可能的——一个完整的堆分配将随之而来。</li><li id="69d3" class="nb nc je kz b la nk ld nl lt nm lu nn lv no ls ng nh ni nj bi translated"><strong class="kz jf">原始类型的拳击。</strong>格式化参数要么是<code class="fe od oe of og b">Object</code>类型，要么是<code class="fe od oe of og b">Object</code>的vararg数组。将原语传递给API将导致自动装箱。autobox缓存通常非常小；只有相对少量的原始人被拘留。即使是内部原语也仍然需要分支、偏移运算和数组查找来解析。(参见<code class="fe od oe of og b">Integer.valueOf(int)</code>了解JDK是如何实施的。)。)</li><li id="927b" class="nb nc je kz b la nk ld nl lt nm lu nn lv no ls ng nh ni nj bi translated"><strong class="kz jf">垃圾收集。</strong>这是#1和#2的进一步症状；varargs和(非强制)自动装箱最终都会在堆上分配对象，而不管日志记录是启用还是取消(除非伴随有“guard”分支)；当从紧循环中进行日志记录时，分配率特别高。这会对应用程序吞吐量和延迟产生负面影响。</li></ol><p id="2db1" class="pw-post-body-paragraph kw kx je kz b la lb kf lc ld le ki lf lt lh li lj lu ll lm ln lv lp lq lr ls im bi translated">要解决<em class="ky"> #1 </em>和<em class="ky"> #2 </em>(随后是<em class="ky"> #3 </em>)的问题，使用传统的SLF4J风格的API将意味着为Java的八个原始类型中的每一个提供适当类型的参数，以及为变量arity提供<code class="fe od oe of og b">Object</code>。假设可以有任意数量的混合原语和对象类型，以任意组合，那么用相关数据类型的所有可能组合来制作一个单一的接口就是参数域的arity的指数函数。有了四个参数，每个级别将有6，561个不同的重载方法。这将需要某种形式的代码生成来实现，并且肯定会扼杀任何IDE自动完成功能。如果有七个参数，这个数字大约是两千万(跨越五个日志级别)。</p><p id="81b9" class="pw-post-body-paragraph kw kx je kz b la lb kf lc ld le ki lf lt lh li lj lu ll lm ln lv lp lq lr ls im bi translated">Zlg通过将原语一次一个地累积到<code class="fe od oe of og b">Zlg.LogChain</code>的实例中来解决上述问题。<code class="fe od oe of og b">LogChain</code> API为Java的八种原始类型中的每一种都有一个<code class="fe od oe of og b">arg()</code>方法，还有<code class="fe od oe of og b">Object</code>。通过使用流畅的链接模式，并一次处理一个参数，Zlg用一个微小的接口绕过了arity问题。当日志被禁止时，原语永远不会被装箱，数组永远不会被分配——因此Zlg的对象分配率为零，对GC的影响也为零。(这已经通过GC分析和禁用GC运行得到了验证。)</p><p id="ef77" class="pw-post-body-paragraph kw kx je kz b la lb kf lc ld le ki lf lt lh li lj lu ll lm ln lv lp lq lr ls im bi translated">作为进一步的优化，Zlg采用的接口驱动的反向依赖设计使它能够在断定已经为所请求的级别禁用了日志记录时，立即用一个<code class="fe od oe of og b">NopLogChain</code>替换它的有状态累加器日志链。因为<code class="fe od oe of og b">NopLogChain</code>实现是一个预实例化的单例，没有操作方法，也没有共享字段，所以需要进行积极的优化。使用大量格式化参数进行的基准测试表明，每个附加参数的增量成本约为0.03-0.05 ns。</p><h1 id="bb36" class="md me je bd mf mg np mi mj mk nq mm mn kk nr kl mp kn ns ko mr kq nt kr mt mu bi translated">模仿和代码覆盖率</h1><p id="9330" class="pw-post-body-paragraph kw kx je kz b la mv kf lc ld mw ki lf lt mx li lj lu my lm ln lv mz lq lr ls im bi translated">如前所述，Zlg的主要目标之一是在不损害代码覆盖率的情况下显著降低日志开销<em class="ky">。我们认识到关于代码覆盖的更广泛的哲学争论:<em class="ky">什么代码应该/不应该被覆盖？覆盖率指标有用吗？这场辩论已经达到了宗教的程度。因此，我们的目的不是说服您达到一些任意的代码覆盖目标。我们要说的是:如果您认为日志语句的准确性是应用程序正确性的基础，因此愿意投入时间和资源来确保其有效性，那么Zlg使这成为可能。仅此而已；覆盖或不覆盖— <em class="ky">选择权完全在你</em>。</em></em></p><figure class="nv nw nx ny gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ps"><img src="../Images/ee1fa97451940d01ba76de6ecd201b31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*gspCWyrB5TA9Xh7e.jpg"/></div></div></figure><p id="3c40" class="pw-post-body-paragraph kw kx je kz b la lb kf lc ld le ki lf lt lh li lj lu ll lm ln lv lp lq lr ls im bi translated">Zlg的设计很大程度上是接口驱动的，以简化模拟和测试，这本身允许我们用100%的指令和分支覆盖来维护Zlg。即使有了接口，使用模仿框架(比如Mockito)感觉也不太适合流畅风格的链接——有太多的方法需要模仿，验证需要有深度意识。(这可能是流畅链接唯一的实际缺点。)</p><p id="4b63" class="pw-post-body-paragraph kw kx je kz b la lb kf lc ld le ki lf lt lh li lj lu ll lm ln lv lp lq lr ls im bi translated">长话短说，推荐嘲讽Zlg的方式是用<code class="fe od oe of og b">MockLogTarget</code>。下面的例子。</p><pre class="nv nw nx ny gt pi og pj pk aw pl bi"><span id="6c9a" class="ow me je og b gy pm pn l po pp">// sink for our mock logs<br/>final MockLogTarget target = new MockLogTarget();</span><span id="e688" class="ow me je og b gy pr pn l po pp">// pipe logs to a mock target<br/>final Zlg zlg = target.logger();</span><span id="0aa8" class="ow me je og b gy pr pn l po pp">// do some logging...<br/>zlg.t("Pi is %.2f", z -&gt; z.arg(Math.PI).tag("math"));<br/>zlg.d("Euler's number is %.2f", z -&gt; z.arg(Math.E).tag("math"));<br/>zlg.c("Avogadro constant is %.3e", <br/>      z -&gt; z.arg(6.02214086e23).tag("chemistry"));<br/>zlg.w("An I/O error has occurred", <br/>      z -&gt; z.threw(new FileNotFoundException()));</span><span id="f20d" class="ow me je og b gy pr pn l po pp">// find entries tagged with 'math'<br/>final List&lt;Entry&gt; math = target.entries().tagged("math").list();<br/>System.out.println(math);</span><span id="914a" class="ow me je og b gy pr pn l po pp">// find entries at or above debug<br/>final List&lt;Entry&gt; debugAndAbove = <br/>    target.entries().forLevelAndAbove(LogLevel.DEBUG).list();<br/>System.out.println(debugAndAbove);</span><span id="b228" class="ow me je og b gy pr pn l po pp">// find entries containing an IOException (or subclass thereof)<br/>final List&lt;Entry&gt; withException = <br/>    target.entries().withException(IOException.class).list();<br/>System.out.println(withException);</span><span id="c639" class="ow me je og b gy pr pn l po pp">// count number of entries containing the substring 'is'<br/>System.out.println("Entries containing 'is': " + <br/>                   target.entries().containing("is").count());</span><span id="fe2f" class="ow me je og b gy pr pn l po pp">// assert that only one entry contained an exception<br/>target.entries().withThrowable().assertCount(1);</span><span id="6a2a" class="ow me je og b gy pr pn l po pp">// of all the tagged entries, assert that at most two <br/>// weren't tagged 'chemistry'<br/>target.entries().tagged().not()<br/>    .tagged("chemistry").assertCountAtMost(2);</span></pre><blockquote class="kt ku kv"><p id="97b8" class="kw kx ky kz b la lb kf lc ld le ki lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated"><strong class="kz jf"> <em class="je">注:</em> </strong> <em class="je">如果你需要的只是一个无操作的记录器来静默任何潜在输出，并且不在乎嘲讽流畅的调用链，那么用</em> <code class="fe od oe of og b"><em class="je">Zlg.nop()</em></code> <em class="je">就可以获得一个静默的记录器。</em></p></blockquote><h2 id="f992" class="ow me je bd mf ox oy dn mj oz pa dp mn lt pb pc mp lu pd pe mr lv pf pg mt ph bi translated">可以用Mockito来嘲讽Zlg吗？</h2><p id="46f5" class="pw-post-body-paragraph kw kx je kz b la mv kf lc ld mw ki lf lt mx li lj lu my lm ln lv mz lq lr ls im bi translated">虽然Mockito在内部用于测试Zlg的采光，但建议将<code class="fe od oe of og b">MockLogTarget</code>专门用于记录器的任何应用程序级模拟。如果你真的必须使用一个模仿框架，这里有一个用Mockito 2.18模仿日志链各个部分的例子:</p><pre class="nv nw nx ny gt pi og pj pk aw pl bi"><span id="3fd8" class="ow me je og b gy pm pn l po pp">final Zlg zlg = mock(Zlg.class, Answers.CALLS_REAL_METHODS);<br/>final LogChain logChain = mock(LogChain.class, <br/>                               Answers.CALLS_REAL_METHODS);<br/>when(logChain.format(any())).thenReturn(logChain);<br/>when(logChain.arg(anyDouble())).thenReturn(logChain);<br/>when(zlg.level(anyInt())).thenReturn(logChain);</span><span id="636f" class="ow me je og b gy pr pn l po pp">zlg.t("the value of Pi is %.2f", z -&gt; z.arg(Math.PI));</span><span id="c0a8" class="ow me je og b gy pr pn l po pp">verify(logChain).format(contains("the value of Pi"));<br/>verify(logChain).arg(eq(Math.PI));<br/>verify(logChain).flush();</span></pre><h1 id="0c3c" class="md me je bd mf mg np mi mj mk nq mm mn kk nr kl mp kn ns ko mr kq nt kr mt mu bi translated">零开销日志记录</h1><p id="6c9e" class="pw-post-body-paragraph kw kx je kz b la mv kf lc ld mw ki lf lt mx li lj lu my lm ln lv mz lq lr ls im bi translated">在本文的开始，我们承诺Zlg能够提供真正的零开销配置，前提是它以特定的方式使用。但是这个选项并不是没有妥协的——零开销的配置将会牺牲代码覆盖率。</p><figure class="nv nw nx ny gt iv gh gi paragraph-image"><div class="gh gi pt"><img src="../Images/7111f70120031c407081cdfd7a897ff7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1302/format:webp/0*8iYofAk8yypCuxM-.jpg"/></div></figure><p id="1eed" class="pw-post-body-paragraph kw kx je kz b la lb kf lc ld le ki lf lt lh li lj lu ll lm ln lv lp lq lr ls im bi translated">如果被抑制的日志的亚纳秒惩罚仍然太高，并且您需要<em class="ky">真零</em>，那么您唯一的选择就是完全去掉日志指令。幸运的是，编译时不需要这样做；JIT DCE(死代码消除)可以智能地为你做这件事。有几种模式可以通过不同的方式实现零足迹。</p><p id="0d0b" class="pw-post-body-paragraph kw kx je kz b la lb kf lc ld le ki lf lt lh li lj lu ll lm ln lv lp lq lr ls im bi translated"><strong class="kz jf"> 1。静态常数</strong>上的分支—将导致其中一个分支的DCE。示例:</p><pre class="nv nw nx ny gt pi og pj pk aw pl bi"><span id="a31e" class="ow me je og b gy pm pn l po pp">private static final Zlg zlg = Zlg.forDeclaringClass().get();private static final boolean TRACE_ENABLED = false;</span><span id="ad1d" class="ow me je og b gy pr pn l po pp">public static void withStaticConstant(String address, <br/>                                      int port, double timeout) {<br/>  if (TRACE_ENABLED) {<br/>    zlg.t("Connecting to %s:%d [timeout: %.1f sec]", <br/>          z -&gt; z.arg(address).arg(port).arg(timeout));<br/>  }<br/>}</span></pre><p id="e056" class="pw-post-body-paragraph kw kx je kz b la lb kf lc ld le ki lf lt lh li lj lu ll lm ln lv lp lq lr ls im bi translated">如果分支指令中的常数可以在编译时完全解析，那么就可以安全地消除日志分支。这种方法没有什么特别之处——地球上的每个伐木工都支持这种方法。</p><p id="05ad" class="pw-post-body-paragraph kw kx je kz b la lb kf lc ld le ki lf lt lh li lj lu ll lm ln lv lp lq lr ls im bi translated"><strong class="kz jf"> 2。断言</strong> —当与<code class="fe od oe of og b">-ea</code>一起运行时，将评估记录指令；否则，他们将被DCE教育。示例:</p><pre class="nv nw nx ny gt pi og pj pk aw pl bi"><span id="2654" class="ow me je og b gy pm pn l po pp">private static final Zlg zlg = Zlg.forDeclaringClass().get();</span><span id="016e" class="ow me je og b gy pr pn l po pp">public static void withAssert(String address, int port, <br/>                              double timeout) {<br/>  assert zlg.level(LogLevel.TRACE)<br/>    .format("Connecting to %s:%d [timeout: %.1f sec]")<br/>    .arg(address).arg(port).arg(timeout).log();<br/>}</span></pre><p id="d791" class="pw-post-body-paragraph kw kx je kz b la lb kf lc ld le ki lf lt lh li lj lu ll lm ln lv lp lq lr ls im bi translated">断言示例没有在lambda中链接参数，而是使用了一种稍微长一点的连续链接方式，最终调用了返回常量<code class="fe od oe of og b">true</code>的<code class="fe od oe of og b">log()</code>。如果断言是用<code class="fe od oe of og b">-ea</code> JVM参数启用的，那么log指令将被评估，并且永远不会使断言失败。否则，整个流利链将被DCE丢弃。</p><p id="b53f" class="pw-post-body-paragraph kw kx je kz b la lb kf lc ld le ki lf lt lh li lj lu ll lm ln lv lp lq lr ls im bi translated">当目标是生产使用的零开销，同时在测试构建中保持日志记录启用时，应该首选这种方法。<code class="fe od oe of og b">-ea</code>旗自然有助于这种区分，而不会强迫你在建造前改变你的职业。无论哪种情况，您都将牺牲代码覆盖率，因为这两种技术都在幕后引入了寄生分支指令；测试期间只遍历一条路径。(因为<code class="fe od oe of og b">log()</code>方法从不返回<code class="fe od oe of og b">false</code>，所以完全的分支覆盖是不可能的。)</p><blockquote class="kt ku kv"><p id="1f21" class="kw kx ky kz b la lb kf lc ld le ki lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated"><strong class="kz jf"> <em class="je">注意:</em> </strong> <em class="je">在</em> <code class="fe od oe of og b"><em class="je">assert</em></code> <em class="je">示例之外，强烈建议不要使用连续链接样式。您可能会忘记在链的末尾添加最后一个</em> <code class="fe od oe of og b"><em class="je">log()</em></code> <em class="je">，这将产生“吞噬”日志的效果，而不会将日志事件转发给底层的日志记录器。</em></p></blockquote></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><p id="f42f" class="pw-post-body-paragraph kw kx je kz b la lb kf lc ld le ki lf lt lh li lj lu ll lm ln lv lp lq lr ls im bi translated"><em class="ky">过早优化是万恶之源。东尼·霍尔爵士的这句名言已经成为软件工程师的主要实践。不幸的是，随着许多想法成长为传奇，这句话的原始含义几乎已经丢失，今天的软件工程师应用这句话的方式与它的原始意图不同。随着计算机系统功能的增强，软件的性能已经退居次要地位。今天，对于软件工程师来说，将霍尔的格言扩展成绝对的<em class="ky">“你永远不应该优化你的代码”一点也不稀奇</em></em></p><p id="8586" class="pw-post-body-paragraph kw kx je kz b la lb kf lc ld le ki lf lt lh li lj lu ll lm ln lv lp lq lr ls im bi translated">已经存在并且总是存在这样的场景，其中直接的性能构成了必须在应用程序生命周期的早期解决的首要设计问题。假设优化的收益与其成本被正确建模，那么有无数的理由说明为什么软件系统应该被主动优化。有许多工具——分析器、框架、库——可以帮助进行系统优化，本文利用了一个特定的工具——日志记录，因为在构建高性能应用程序的上下文中很少对它进行充分的度量或处理。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><p id="3fc3" class="pw-post-body-paragraph kw kx je kz b la lb kf lc ld le ki lf lt lh li lj lu ll lm ln lv lp lq lr ls im bi translated"><em class="ky">这篇文章对你有用吗？我很想听到你的反馈，所以不要退缩！如果你对卡夫卡或者事件流感兴趣，或者只是有什么疑问，</em> <a class="ae na" href="https://twitter.com/i/user/562466177" rel="noopener ugc nofollow" target="_blank"> <em class="ky">在Twitter上关注我</em> </a> <em class="ky">。我也是</em><a class="ae na" href="https://github.com/obsidiandynamics/kafdrop" rel="noopener ugc nofollow" target="_blank"><em class="ky">Kafdrop</em></a><em class="ky">的维护者和</em> <a class="ae na" href="https://www.apachekafkabook.com" rel="noopener ugc nofollow" target="_blank"> <em class="ky">有效卡夫卡</em> </a> <em class="ky">的作者。</em></p></div></div>    
</body>
</html>