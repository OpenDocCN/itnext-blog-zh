# 不活动自动注销，带角度和 Ngrx

> 原文：<https://itnext.io/inactivity-auto-logout-w-angular-and-ngrx-3bcb2fd7983f?source=collection_archive---------1----------------------->

![](img/c7d0c381e781f9544068d00ccd4a3f7e.png)

[*点击这里在 LinkedIn* 上分享这篇文章](https://www.linkedin.com/cws/share?url=https%3A%2F%2Fitnext.io%2Finactivity-auto-logout-w-angular-and-ngrx-3bcb2fd7983f)

我构建的一个应用程序有一些非常健壮的安全需求，其中之一是客户端会话过期。这是您在登录手机银行时可能已经注意到的一个功能。您登录到您的帐户，切换到另一个选项卡，几分钟后返回到该选项卡，发现您因不活动而被注销。这有助于防止敏感信息停留在空闲用户的屏幕上，并降低恶意用户访问应用程序的可能性。

这个用例看起来很普通。我开始在互联网上寻找使用 Angular 2+和 Ngrx 的解决方案。唉，我努力寻找一个干净的解决方案，并继续尝试推出自己的。事实证明，实现这一点是愚蠢的简单，我想与互联网分享。

此解决方案使用依赖版本:

*   角度 5.2.0
*   Ngrx ≥ 5.0.0
*   Rxjs 5.5.6

[演示](https://johnbfox.github.io/angular-ngrx-autologout-demo/)

对于那些想直接跳到代码的人，你可以查看完整的 [Github 库](https://github.com/johnbfox/angular-ngrx-autologout)。本演练假设您对用于状态管理的 ngrx 有基本的了解。那些不熟悉 ngrx 和构建 angular 应用程序的人一定要看看这里的。不管怎样……回到我们定期安排的节目。

# 解决办法

我们的自动注销应用程序的需求非常简单。经过一段时间的不活动后，应用程序必须将用户从应用程序中注销。

让我们关注我们的状态管理文件。

actions.ts

首先，我们定义我们的应用程序动作。对于这个演示，我们有三个简单的动作:登录、注销和 ExtendLogoutTimer。现在让我们看看我们的减速器。

减速器. ts

reducers 包含我们的应用程序动作的初始状态和处理程序。我们的状态只跟踪一个变量， *isLoggedIn* ，这个值被初始化为 false。LOG_OUT reducer 将 *isLoggedIn* 设置为假，而 LOG_IN 将其设置为真。我们不显式处理 ExtendLogoutTimer 操作类型。相反，它在效果模块中得到隐式处理。

effects.ts

这就是奇迹发生的地方。这里我们有一个副作用叫做*extendApplicationTimeout*。所有事件类型都会调用此效果。它创建了一个可观察的计时器，在 5000 毫秒(我们预定义的“超时”时间)后发出。一旦定时器到期，我们返回一个新注销类型的动作。

该解决方案的另一个重要部分是使用*开关映射*。当一个动作被调用时， *switchMap* 取消任何未完成的先前效果执行，并用一个新的定时器重新创建一个可观察值。这样，我们只需在每次调用动作时延长注销计时器，并防止前一个动作计时器倒计时。

# 结论

就是这样！用很少的代码，你就为你的 Angular 应用程序增加了很大的安全性。在生产应用程序中，您会希望添加注销操作副作用，通过从本地存储中删除访问令牌、删除 cookies 等来实现正确的注销。否则，这就是实现客户端超时所需的全部内容。

如果你有任何问题，欢迎在评论区留言。我没有在教程中浏览基于组件的代码，但是你可以在上面的介绍中找到实现的链接。我希望这有所帮助！