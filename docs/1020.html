<html>
<head>
<title>Module Oriented Architecture — Part 7: Wrap up</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向模块的体系结构第7部分:总结</h1>
<blockquote>原文：<a href="https://itnext.io/module-oriented-architecture-part-7-wrap-up-742aaf696de6?source=collection_archive---------5-----------------------#2018-07-05">https://itnext.io/module-oriented-architecture-part-7-wrap-up-742aaf696de6?source=collection_archive---------5-----------------------#2018-07-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="0e03" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">…上接<a class="ae kl" href="https://medium.com/@poksi/module-oriented-architecture-part-6-outsmarting-the-mvc-26ef66111057" rel="noopener">第6部分</a></p><p id="baf0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我认为已经有很多关于面向模块的架构可以给任何本地客户端解决方案带来的好处的说法，但是在所有的编码章节中，我们也将提到一些iOS的细节。当然，并不是说它们不能应用到其他地方，但是这些例子来自iOS。</p><h2 id="ff4e" class="km kn iq bd ko kp kq dn kr ks kt dp ku jy kv kw kx kc ky kz la kg lb lc ld le bi translated">MVC和UIKit导航特性的链条终于被打破了</h2><blockquote class="lf lg lh"><p id="be6e" class="jn jo li jp b jq jr js jt ju jv jw jx lj jz ka kb lk kd ke kf ll kh ki kj kk ij bi translated">一直让我非常恼火的一件事是，通过处理视图控制器实现的标准导航如何快速接管任何应用程序架构，并将其严格映射到用户旅程流。这实际上并不令人惊讶，因为MVC是UIKit的核心。</p></blockquote><p id="7e40" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本质上，没有什么是错误的，如果你使用MVC模式，它也不可能很干净，但是我们当然不是在这里讨论标准的客户端架构。当<code class="fe lm ln lo lp b">UINavigationControllers </code>和<code class="fe lm ln lo lp b">UITabBarController</code>接管<code class="fe lm ln lo lp b">UIViewControllers</code>并且后者接管所有其他类别的客户端架构时，问题就开始了。在最好的情况下，我们得到的是松散耦合的应用程序部分的架构，改变或定制流程变得非常具有挑战性。</p><p id="c611" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">随着共享一些其他as依赖项的不同功能的增长，代码会变得非常复杂，并且在某些时候可能变得不可维护…</p><p id="54d6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们有一个不同的故事。导航元素在应用程序流和全局架构中不起作用。<code class="fe lm ln lo lp b">ApplicationServices</code>是主要的业务对象，它们在<code class="fe lm ln lo lp b">ApplicationRouter</code>的帮助下简单地使用模块完成工作。导航对象仅用于其名称所描述的用途，而不是作为业务逻辑编排器。</p><p id="0496" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以争辩说，像<strong class="jp ir"> VIPER </strong>和<strong class="jp ir"> MVP </strong>这样的客户端架构已经做到了这一点，但事实并非如此。首先，这些体系结构非常通用，没有处理甚至没有提到它的路由器类和导航类之间的关系。<code class="fe lm ln lo lp b">StoryboardModuleType</code>正是如此。</p><p id="175d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最重要的是，这些架构专注于一个功能的类之间的关系，由几个类定义，而<code class="fe lm ln lo lp b">ApplicationServices</code>处理应用程序级别的业务逻辑流。底线是，我们在这里谈论的是两件不同的事情。莫阿不是另一个毒蛇，MVP，MVVM，…MOA是它上面的一层，在模块中可以实现任何一种架构。这将是我下一个系列的主题…</p><h2 id="765d" class="km kn iq bd ko kp kq dn kr ks kt dp ku jy kv kw kx kc ky kz la kg lb lc ld le bi translated">UIStoryboard火焰战争结束了</h2><p id="4539" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">什么比较好？一个故事板？很多？没有吗？只是。xib文件？</p><p id="765b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">给出了答案:<strong class="jp ir">每个模块一个，如果需要的话。</strong></p><h2 id="c5d6" class="km kn iq bd ko kp kq dn kr ks kt dp ku jy kv kw kx kc ky kz la kg lb lc ld le bi translated">构建模块化</h2><p id="2c80" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">如果我们构建一个模块或一组模块，当我们可能混合和匹配不同技术时，我们可能会在一个包中使用它。例如，我们已经提到，我们基于URI的传统模块架构如何能够轻松地与React本机部分进行通信。</p><h2 id="bac7" class="km kn iq bd ko kp kq dn kr ks kt dp ku jy kv kw kx kc ky kz la kg lb lc ld le bi translated">具有可重复使用构建模块的白标应用</h2><p id="17bc" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">模块和大积木差不多。不难想象，如何在最广泛的意义上构建白色标签的应用程序。假设你为2FA创建了一个功能，一个模块。你已经将它包含在某个应用a中。虽然非常不同，但应用B可以在同一时间或稍后使用几乎相同的模块。同样的想法也可以使功能切换变得非常容易，例如，当我们有市场特定的需求时，这非常方便。</p><h2 id="04b6" class="km kn iq bd ko kp kq dn kr ks kt dp ku jy kv kw kx kc ky kz la kg lb lc ld le bi translated">相同的模块可以用在非常不同的地方</h2><p id="177c" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">模块使用两种约定:</p><ul class=""><li id="d0b9" class="lv lw iq jp b jq jr ju jv jy lx kc ly kg lz kk ma mb mc md bi translated">URI作为访问模块及其功能的手段</li><li id="72e9" class="lv lw iq jp b jq me ju mf jy mg kc mh kg mi kk ma mb mc md bi translated">HTTP响应和状态代码</li></ul><p id="fa37" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="li">这意味着完全没有任何修改的相同代码可以被使用并移动到不同的地方，如动态框架、静态库、扩展，没有任何修改，甚至在服务器、桌面应用程序上，几乎任何地方，只要语言运行时可以运行。</em> </strong></p><h2 id="d808" class="km kn iq bd ko kp kq dn kr ks kt dp ku jy kv kw kx kc ky kz la kg lb lc ld le bi translated">命令模式</h2><p id="a3c5" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">虽然可能不是很明显，但是这种模式是所提出的面向模块架构的基础。</p><ul class=""><li id="f1f5" class="lv lw iq jp b jq jr ju jv jy lx kc ly kg lz kk ma mb mc md bi translated"><strong class="jp ir">命令</strong> : URL和<code class="fe lm ln lo lp b">ModuleType</code>中的路径列表</li><li id="ce0b" class="lv lw iq jp b jq me ju mf jy mg kc mh kg mi kk ma mb mc md bi translated"><strong class="jp ir">呼叫者</strong> : <code class="fe lm ln lo lp b">ApplicationServices</code>或深层链接</li><li id="1630" class="lv lw iq jp b jq me ju mf jy mg kc mh kg mi kk ma mb mc md bi translated"><strong class="jp ir">调用者</strong> : <code class="fe lm ln lo lp b">ModuleType</code>将完成大部分的调用工作</li><li id="39b8" class="lv lw iq jp b jq me ju mf jy mg kc mh kg mi kk ma mb mc md bi translated"><strong class="jp ir">接收器</strong> : <code class="fe lm ln lo lp b">ModuleRoutable</code>类</li></ul><p id="ab2f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">抛开命令模式的明显用途，一个应用程序可以变成一个真正强大的移动生态系统的一部分。假设您有一个服务器，它不仅提供对请求的响应，还提供逻辑。这也是向特定用户群交付canary版本的一种非常简单的方式。</p><p id="fe8e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">假设您有一个银行应用程序，可以有3个用户选择的特定场景来创建支付:</p><ul class=""><li id="5f4c" class="lv lw iq jp b jq jr ju jv jy lx kc ly kg lz kk ma mb mc md bi translated">用户可以直接付款，不需要额外的逐步认证</li><li id="a2f1" class="lv lw iq jp b jq me ju mf jy mg kc mh kg mi kk ma mb mc md bi translated">用户必须事先重新认证</li><li id="8165" class="lv lw iq jp b jq me ju mf jy mg kc mh kg mi kk ma mb mc md bi translated">用户必须使用2FA才能付款</li></ul><p id="8ab1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当用户登录时，他收到某种配置响应中的URL，然后可以在<code class="fe lm ln lo lp b">ApplicationServices</code>中使用，基本上包含以下内容:</p><figure class="mj mk ml mm gt mn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="4257" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过这种方式，我们可以将应用程序带到一个全新的水平，使其逻辑可以从服务器上控制。通过对JSON进行一些添加，比如占位符和嵌套，我们甚至可以创建一个条件流。</p><h1 id="b26c" class="mq kn iq bd ko mr ms mt kr mu mv mw ku mx my mz kx na nb nc la nd ne nf ld ng bi translated">结论</h1><p id="4fa6" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">正如我们所看到的，面向模块的架构在许多方面都是赢家。它的真正力量在于它的通用概念和简单的设计。实际上，每种客户端技术都可以实现if，这也为整个应用程序生态系统架构、服务器端的概念和实现带来了好处。<br/>有一些权衡，一些开发人员会告诉你，他们不喜欢这种无类型的方法，他们会认为它不太安全。我在一定程度上同意任何考虑，但在我看来这是一个很小的代价。</p></div></div>    
</body>
</html>