<html>
<head>
<title>Using combineLatest for Async form validation in Angular4</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Angular4中使用combineLatest进行异步表单验证</h1>
<blockquote>原文：<a href="https://itnext.io/using-combinelatest-for-async-form-validation-in-angular4-8c9804f48892?source=collection_archive---------1-----------------------#2018-02-08">https://itnext.io/using-combinelatest-for-async-form-validation-in-angular4-8c9804f48892?source=collection_archive---------1-----------------------#2018-02-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/331f6eb3cc16872fe074d0314e511372.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vRDLn6jLL_9rcHWdhlgg-w.png"/></div></div></figure><p id="fc51" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您需要验证一个值依赖于其他表单输入的表单输入，该怎么办？如果验证本身依赖于XHR请求呢？</p><p id="bdce" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kw" href="https://www.linkedin.com/cws/share?url=https%3A%2F%2Fitnext.io%2Fusing-combinelatest-for-async-form-validation-in-angular4–8c9804f48892" rel="noopener ugc nofollow" target="_blank"> <em class="kx">点击这里在LinkedIn </em>上分享这篇文章</a></p><p id="0940" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Angular使Observables和RXJS变得简单。Angular的reactiveForms返回每当表单的输入值改变时发出的可观察值:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="1688" class="lh li iq ld b gy lj lk l ll lm">let input1$ = this.form.controls.input1.valueChanges;<br/>let input2$ = this.form.controls.input2.valueChanges;<br/>let input3$ = this.form.controls.input3.valueChanges;</span></pre><p id="d24c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这个例子中，我将特别观察三个表单输入。这是必要的，因为我需要验证的值取决于这三个输入。例如，验证车辆在城市中从一个地址到另一个地址的行驶时间。我想要验证的值是旅行时间(输入1)。源地址的值是输入2，目的地址的值是输入3。</p><p id="c8ba" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">首先，让我们创建一个每当我们的表单输入改变时发出的可观察对象</strong>。通过将“combineLatest”与我上面获得的三个可观察值一起使用，我可以创建一个可观察值，当这三个输入中的任何一个发生变化时，它都会发出一个值，并始终提供它们的最新值。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="3400" class="lh li iq ld b gy lj lk l ll lm">combineLatest(input1$, input2$, input3$)    <br/>.do(([input1, input2, input3])=&gt;{<br/>  this.form.controls.input1.clearAsyncValidators();<br/>})  <br/>.debounceTime(500)    <br/>  .subscribe(([input1, input2, input3]) =&gt; {        <br/>    if (!input1 || !input2 || !input3) return null;        <br/>    let request = {        <br/>      input1,        <br/>      input2,        <br/>      input3    <br/>    }     <br/>    const inputValidatorFn = this.getValidatorFn(request);                  <br/>    this.form.controls.input1.setAsyncValidators(inputValidatorFn);         <br/>    this.form.controls.input1.updateValueAndValidity();    <br/>  });</span></pre><p id="08d2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后我订阅这个可观察的，在去抖动它的广播速率之后，这样我只在用户停止输入时得到通知。我的订阅为我提供了我需要的三个最新值。<strong class="ka ir"> clearAsyncValidators </strong>方法是为了防止XHR请求在用户停止输入之前被发送。</p><p id="4d1e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为正在讨论的验证发生在服务器上，所以我们可以利用Angular的<strong class="ka ir"> setAsyncValidators </strong>函数。它接受一个类型为<strong class="ka ir"> AsyncValidatorFn </strong>的参数。这种类型的函数可以返回承诺或可观察值，当没有验证错误时，该值解析为null，或者解析为描述验证错误的对象。因此，我们构造了一个类型为<strong class="ka ir"> AsyncValidatorFn </strong>的函数，它将向服务器发出一个XHR请求，并返回一个判断，之后它将使用null进行解析，或者使用一个表示验证错误的对象进行解析。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="1b64" class="lh li iq ld b gy lj lk l ll lm">private getValidatorFn(request): <strong class="ld ir">AsyncValidatorFn</strong> {    <br/> return ( control: FormGroup ) =&gt; {        <br/>   return new Promise((resolve, reject) =&gt; {                            <br/>    this.someService.validateTravelTime(request)                 <br/>     .subscribe((serviceResponse) =&gt; {                    <br/>       let response = serviceResponse.json();                    <br/>       if( response &amp;&amp; response.data.valid ) return resolve(null);                     <br/>       if( response &amp;&amp; !response.data.valid ) {               <br/>         resolve({ err : response.data.errorDescription })                                 <br/>       }                  <br/>     })                <br/>     .catch(err=&gt;handleError(err));        <br/>   })    <br/>  }<br/>}</span></pre><p id="910d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们上面的验证器函数利用了一个发出实际XHR请求的服务。当XHR请求满足时，服务返回一个发出响应的可观察对象。</p><p id="90ff" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">每当任何输入发生变化(输入1、输入2或输入3)时，我们将获取它们的最新值，创建一个新的请求对象，然后创建一个类型为<strong class="ka ir"> AsyncValidatorFn、</strong>的新函数，然后我们将它传递给Angular的<strong class="ka ir"> setAsyncValidators </strong>方法，该方法专门将这个异步验证器附加到输入1。因此，每次输入发生变化(输入1、输入2或输入3)时，我们都会异步检查输入1的有效性。</p><p id="3c88" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，我们使用:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="c2df" class="lh li iq ld b gy lj lk l ll lm">this.form.controls.input1.updateValueAndValidity();</span></pre><p id="c1e1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这将在我们的异步验证器就位后触发验证检查。</p><p id="d22a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">完整代码:</p><figure class="ky kz la lb gt jr"><div class="bz fp l di"><div class="ln lo l"/></div></figure></div></div>    
</body>
</html>