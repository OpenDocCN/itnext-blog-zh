<html>
<head>
<title>How to health check your TopShelf service in Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Kubernetes对您的TopShelf服务进行健康检查</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-health-check-your-topshelf-service-in-kubernetes-d1ad5459304a?source=collection_archive---------7-----------------------#2019-12-26">https://itnext.io/how-to-health-check-your-topshelf-service-in-kubernetes-d1ad5459304a?source=collection_archive---------7-----------------------#2019-12-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/52746dc9e227eccf61a911b6b10f4732.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7pLud_-UcYZ_gBOtR5CJyg.png"/></div></div></figure><div class=""/><p id="da21" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最近，我致力于将一个遗留的TopShelf服务从VM迁移到Kubernetes。</p><p id="09b3" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该服务非常不稳定，并且不时地转换到中断状态，必须手动重启，这不太理想。</p><p id="ff0b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，将服务转移到Kubernetes本身并不能解决问题，因为无论在<em class="kw">部署</em>中定义了多少个pod，它们最终都会由于死锁、无限循环等而一个接一个地失败，而且Kubernetes永远不会知道，因为这些流程看起来仍然在愉快地运行。</p><h1 id="a062" class="kx ky jb bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">Kubernetes的健康检查</h1><p id="9e8d" class="pw-post-body-paragraph jy jz jb ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">为了补救这种情况，我们可以使用Kubernetes的一个健康检查工具<em class="kw"> liveness probe </em>，它将向Kubernetes发出您的服务是死是活的信号。另一个是<em class="kw">就绪探测器</em>，它告诉Kubernetes容器何时准备好接受流量。在这篇文章中，我将重点讨论前者。</p><p id="8ecd" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有3种类型的活性探测器:</p><ul class=""><li id="5232" class="ma mb jb ka b kb kc kf kg kj mc kn md kr me kv mf mg mh mi bi translated">超文本传送协议</li><li id="fb8b" class="ma mb jb ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated">传输控制协议（Transmission Control Protocol）</li><li id="67ef" class="ma mb jb ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated">命令</li></ul><p id="2368" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我将展示如何设置和使用最流行的HTTP类型。</p><p id="7f25" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它是做什么的？</p><p id="5bae" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该探测器对pod规范中指定的pod的IP地址、端口和路径执行HTTP GET请求。如果探头收到2xx或3xx HTTP响应代码，则认为该pod是健康的。如果服务器返回一个&gt; = 400的错误响应代码，或者如果它根本没有响应，则认为探测失败，pod将重新启动。</p><h1 id="130c" class="kx ky jb bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">自宿主TopShelf</h1><p id="54a6" class="pw-post-body-paragraph jy jz jb ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">因为默认情况下，TopShelf不是一个HTTP服务器，所以我们必须使用OWIN (Open Web Interface for。网)。</p><p id="11a7" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为此，我使用了<a class="ae mo" href="https://github.com/dennisroche/TopShelf.Owin" rel="noopener ugc nofollow" target="_blank"> TopShelf。Owin </a> NuGet包。</p><p id="3cf6" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先安装软件包:</p><p id="4000" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mp mq mr ms b">Install-Package Topshelf.Owin</code></p><p id="b1e5" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后更改您的启动代码，并将OWIN端点配置为在<code class="fe mp mq mr ms b">8080</code>端口上运行:</p><pre class="mt mu mv mw gt mx ms my mz aw na bi"><span id="25f6" class="nb ky jb ms b gy nc nd l ne nf">HostFactory.Run(configure =&gt;<br/>{<br/>    configure.Service&lt;MyHeadacheService&gt;(service =&gt;<br/>    {<br/>        service.ConstructUsing(s =&gt; new MyHeadacheService());<br/>        service.WhenStarted(s =&gt; s.Start());<br/>        service.WhenStopped(s =&gt; s.Stop());<br/><br/>        service.OwinEndpoint(app =&gt;<br/>        {<br/>            app.Domain = "*";<br/>            app.Port = 8080;<br/>        });<br/>    });<br/>});</span></pre><p id="d521" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，创建一个新文件<code class="fe mp mq mr ms b">HealthcheckController</code>,并为健康检查定义API控制器。我使用的是<code class="fe mp mq mr ms b">Route("")</code>，这意味着健康检查端点将在<code class="fe mp mq mr ms b">localhost:8080</code>运行。</p><p id="8004" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">只要静态属性<code class="fe mp mq mr ms b">HealthCheckStatus.IsHealthy</code>为<code class="fe mp mq mr ms b">true</code>，健康检查端点就会假设我们的服务是健康的。</p><p id="9323" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这种检查的一个问题是，它可能不会验证服务的响应性，因此检查以与依赖服务类似的方式执行其任务是很重要的。另一方面，它不应该检查它的依赖项，因为它是我前面提到的<em class="kw">就绪探测</em>任务。</p><p id="67f0" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">出于测试目的，我们将添加一个额外的端点，这将使我们的服务进入一种人为的中断状态，因此健康检查将返回<code class="fe mp mq mr ms b">500</code>状态代码，而不是<code class="fe mp mq mr ms b">200</code>。请注意，我使用的是一个<code class="fe mp mq mr ms b">Serilog</code>记录器，它会在每次点击端点时输出到控制台。</p><pre class="mt mu mv mw gt mx ms my mz aw na bi"><span id="23bb" class="nb ky jb ms b gy nc nd l ne nf">public class HealthcheckController : ApiController<br/>{<br/>    [HttpGet, Route("")]<br/>    public IHttpActionResult Healthcheck()<br/>    {<br/>        Log.Information("Healthcheck invoked using User-Agent: {UserAgent}", Request.Headers.UserAgent?.ToString());<br/>        return HealthCheckStatus.IsHealthy ? Ok() : (IHttpActionResult) InternalServerError(new Exception("I'm not healthy. Restart me."));<br/>    }<br/><br/>    [HttpGet, Route("break")]<br/>    public IHttpActionResult Break()<br/>    {<br/>        Log.Information("Ups!");<br/>        HealthCheckStatus.IsHealthy = false;<br/>        return Ok();<br/>    }<br/>}<br/><br/>public static class HealthCheckStatus<br/>{<br/>    public static bool IsHealthy { get; set; } = true;<br/>}</span></pre><h1 id="2632" class="kx ky jb bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">定义活性探测器</h1><p id="3528" class="pw-post-body-paragraph jy jz jb ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">我们的facelifted TopShelf服务现已准备好为Kubernetes探针提供服务。现在我们必须让Kubernetes知道在哪里检查我们的服务。</p><p id="c2f2" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在pod规范中，我们添加了一个部分来告诉Kubernetes在pod的路径<code class="fe mp mq mr ms b">/</code>和端口<code class="fe mp mq mr ms b">8080</code>上执行活性探测:</p><pre class="mt mu mv mw gt mx ms my mz aw na bi"><span id="1bb3" class="nb ky jb ms b gy nc nd l ne nf">livenessProbe:<br/>  httpGet:<br/>    path: /<br/>    port: 8080<br/>  initialDelaySeconds: 5<br/>  periodSeconds: 5</span></pre><ul class=""><li id="f39e" class="ma mb jb ka b kb kc kf kg kj mc kn md kr me kv mf mg mh mi bi translated"><code class="fe mp mq mr ms b">initialDelaySeconds</code> -这是告知kubelet(节点代理)在执行第一次探测之前等待5秒钟的延迟</li><li id="e7a8" class="ma mb jb ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated"><code class="fe mp mq mr ms b">periodSeconds</code> -指定kubelet应该每5秒执行一次活性探测。</li></ul><p id="9cdd" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">探测请求的默认和最小超时是1秒，可以使用<code class="fe mp mq mr ms b">timeoutSeconds</code>进行配置。</p><p id="13f4" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要查看其他配置选项，请查看官方<a class="ae mo" href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/#configure-probes" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><p id="d4d9" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们可以在集群上部署我们的pod，并查看发送到pod的探测器。</p><pre class="mt mu mv mw gt mx ms my mz aw na bi"><span id="adbf" class="nb ky jb ms b gy nc nd l ne nf">kubectl logs -f podname</span><span id="c199" class="nb ky jb ms b gy ng nd l ne nf">[20:25:41 INF] Healthcheck invoked using User-Agent: kube-probe/1.15</span></pre><p id="eef6" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有了我们的中断端点(<code class="fe mp mq mr ms b">:8080/break/</code>)，我们现在可以模拟一个人工中断状态。</p><p id="1a2e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们进入一个运行舱:</p><p id="5c85" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mp mq mr ms b">kubectl exec -it podname cmd</code></p><p id="30f7" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">和触发故障:</p><p id="d266" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mp mq mr ms b">curl -v localhost:8080/break</code></p><p id="2bb8" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">等待足够长的时间，以便探测器有机会执行并在pod事件中查看失败的探测器:</p><p id="f538" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mp mq mr ms b">kubectl describe pod podname</code></p><pre class="mt mu mv mw gt mx ms my mz aw na bi"><span id="2f9c" class="nb ky jb ms b gy nc nd l ne nf"><br/>Liveness probe failed: HTTP probe failed with statuscode: 500</span></pre><p id="72d7" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过列出pod来验证它是否已重新启动:</p><p id="5346" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mp mq mr ms b">kubectl get pod podname</code></p><pre class="mt mu mv mw gt mx ms my mz aw na bi"><span id="f2d5" class="nb ky jb ms b gy nc nd l ne nf">NAME      READY   STATUS    RESTARTS   AGE<br/>podname   1/1     Running   1          1h</span></pre><p id="37f2" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以看到“重新启动”列正好显示了这一点。</p><h1 id="aea9" class="kx ky jb bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">结论</h1><p id="908b" class="pw-post-body-paragraph jy jz jb ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">通过自托管TopShelf服务并向其添加健康检查端点，您可以利用Kubernetes活跃度探测器，这可以极大地提高服务的健壮性和弹性。</p></div></div>    
</body>
</html>