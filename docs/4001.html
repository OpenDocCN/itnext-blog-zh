<html>
<head>
<title>Leveraging Swift in Xcode’s LLDB</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Xcode的LLDB中利用Swift</h1>
<blockquote>原文：<a href="https://itnext.io/leveraging-swift-in-xcodes-lldb-d75e2adc5741?source=collection_archive---------2-----------------------#2020-04-08">https://itnext.io/leveraging-swift-in-xcodes-lldb-d75e2adc5741?source=collection_archive---------2-----------------------#2020-04-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="1236" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">这是一种在Swift中定义助手函数的方法，这些函数在运行时注入到您的应用程序中，以便在调试时使用——不需要LLDB-esque Python！</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/2b6710df13be28488cb5fe436106930c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r0efFnJA9Yuy2NTL4IrAog.png"/></div></div></figure><h1 id="c113" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">第一幕——设置场景</h1><p id="0e9c" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">假设我们正在调试一个焦点视图丢失的问题。换句话说，我们正在寻找任何一个<code class="fe mf mg mh mi b">isFocused</code>属性为<code class="fe mf mg mh mi b">true</code>的<code class="fe mf mg mh mi b">UIView</code>实例。在这个场景中，将视图背景颜色设置为红色很有帮助，这样我们可以很容易地看到它在屏幕上的位置。过去，我通过创建一个函数来递归应用程序中的所有视图，并在适当的地方设置背景颜色来实现这一点:</p><pre class="kg kh ki kj gt mj mi mk ml aw mm bi"><span id="8774" class="mn ks iq mi b gy mo mp l mq mr"><strong class="mi ir"><em class="ms">1.</em></strong> func highlightFocusedView(in target: UIView) {<br/><strong class="mi ir"><em class="ms">2.</em></strong>     target.subviews.forEach {<br/><strong class="mi ir"><em class="ms">3.</em></strong>         if $0.isFocused {<br/><strong class="mi ir"><em class="ms">4.</em></strong>             $0.backgroundColor = .red<br/><strong class="mi ir"><em class="ms">5.</em></strong><em class="ms"> </em>        } else {<br/><strong class="mi ir"><em class="ms">6.</em></strong><em class="ms"> </em>            highlightFocusedView(in: $0)<br/><strong class="mi ir"><em class="ms">7.</em></strong><em class="ms"> </em>        }<br/><strong class="mi ir"><em class="ms">8.</em></strong>     }<br/><strong class="mi ir"><em class="ms">9.</em></strong> }</span></pre><p id="af2d" class="pw-post-body-paragraph lj lk iq ll b lm mt jr lo lp mu ju lr ls mv lu lv lw mw ly lz ma mx mc md me ij bi translated">我通常会将该函数放在我的<code class="fe mf mg mh mi b">AppDelegate.swift</code>的顶部，并简单地不将其提交给源代码控制。为了运行这个函数，我用<code class="fe mf mg mh mi b">⌃⌘Y</code>暂停执行，并在调试器中键入以下内容:</p><pre class="kg kh ki kj gt mj mi mk ml aw mm bi"><span id="f878" class="mn ks iq mi b gy mo mp l mq mr"><strong class="mi ir">(lldb)</strong> expression -l Swift -O -- highlightFocusedView(in: UIApplication.shared.keyWindow!)</span><span id="7a52" class="mn ks iq mi b gy my mp l mq mr"><em class="ms">error: &lt;EXPR&gt;:3:1: error: use of unresolved identifier 'highlightFocusedView'</em></span></pre><p id="04ef" class="pw-post-body-paragraph lj lk iq ll b lm mt jr lo lp mu ju lr ls mv lu lv lw mw ly lz ma mx mc md me ij bi translated">哦，看来我需要导入我的应用程序包。最好先这么做:</p><pre class="kg kh ki kj gt mj mi mk ml aw mm bi"><span id="fb22" class="mn ks iq mi b gy mo mp l mq mr"><strong class="mi ir">(lldb)</strong> expression -l Swift -O -- import MyApp_tvOS</span></pre><p id="a653" class="pw-post-body-paragraph lj lk iq ll b lm mt jr lo lp mu ju lr ls mv lu lv lw mw ly lz ma mx mc md me ij bi translated">再试一次:</p><pre class="kg kh ki kj gt mj mi mk ml aw mm bi"><span id="42ca" class="mn ks iq mi b gy mo mp l mq mr"><strong class="mi ir">(lldb)</strong> expression -l Swift -O -- highlightFocusedView(in: UIApplication.shared.keyWindow!)</span><span id="f364" class="mn ks iq mi b gy my mp l mq mr"><em class="ms">error: &lt;EXPR&gt;:3:26: error: use of unresolved identifier 'UIApplication'</em></span></pre><p id="776c" class="pw-post-body-paragraph lj lk iq ll b lm mt jr lo lp mu ju lr ls mv lu lv lw mw ly lz ma mx mc md me ij bi translated">又来了——需要导入<code class="fe mf mg mh mi b">UIKit</code></p><pre class="kg kh ki kj gt mj mi mk ml aw mm bi"><span id="3d9a" class="mn ks iq mi b gy mo mp l mq mr"><strong class="mi ir">(lldb)</strong> expression -l Swift -O -- import UIKit</span></pre><p id="d611" class="pw-post-body-paragraph lj lk iq ll b lm mt jr lo lp mu ju lr ls mv lu lv lw mw ly lz ma mx mc md me ij bi translated">最后，运行<code class="fe mf mg mh mi b">expression -l Swift -O -— highlightFocusedView(in: UIApplication.shared.keyWindow!)</code>然后取消暂停调试器会导致我的设备屏幕上的视图改变颜色。</p><p id="f10e" class="pw-post-body-paragraph lj lk iq ll b lm mt jr lo lp mu ju lr ls mv lu lv lw mw ly lz ma mx mc md me ij bi translated">总结一下:</p><ul class=""><li id="f81f" class="mz na iq ll b lm mt lp mu ls nb lw nc ma nd me ne nf ng nh bi translated">helper函数存在于我的代码库中，我需要记住不要提交它</li><li id="f124" class="mz na iq ll b lm ni lp nj ls nk lw nl ma nm me ne nf ng nh bi translated">我有多个目标，所以我的助手函数需要在它们之间复制和维护</li><li id="0199" class="mz na iq ll b lm ni lp nj ls nk lw nl ma nm me ne nf ng nh bi translated">我所有的调试器命令都需要以<code class="fe mf mg mh mi b">expression -l Swift -O --</code>为前缀，以便<code class="fe mf mg mh mi b">lldb</code>将它们解释为Swift代码</li><li id="2d9c" class="mz na iq ll b lm ni lp nj ls nk lw nl ma nm me ne nf ng nh bi translated">在调用helper函数之前，我需要<code class="fe mf mg mh mi b">import</code>我的app bundle和UIKit。</li></ul><h1 id="c403" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">第二步—定义lldb别名</h1><p id="63eb" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">和许多好的命令行工具一样，<code class="fe mf mg mh mi b">lldb</code>有一个init文件。在其中，我们可以定义别名(当然没有Python)。</p><pre class="kg kh ki kj gt mj mi mk ml aw mm bi"><span id="69c7" class="mn ks iq mi b gy mo mp l mq mr"><strong class="mi ir">$</strong> vi ~/.lldbinit   <em class="ms"># or use your second favourite editor</em></span></pre><p id="5fde" class="pw-post-body-paragraph lj lk iq ll b lm mt jr lo lp mu ju lr ls mv lu lv lw mw ly lz ma mx mc md me ij bi translated">在这里，我们可以创建一个别名<code class="fe mf mg mh mi b">swift</code>，它可以扩展为<code class="fe mf mg mh mi b">expression -l Swift -O --</code>(实际上，它与<code class="fe mf mg mh mi b">po</code>相同，但是我们将在后面对其进行改进)。既然我们在这里，让我们为老目标C也创建一个，以防万一。将以下两行添加到您的<code class="fe mf mg mh mi b">.lldbinit</code>文件中:</p><pre class="kg kh ki kj gt mj mi mk ml aw mm bi"><span id="837e" class="mn ks iq mi b gy mo mp l mq mr"><strong class="mi ir"><em class="ms">1.</em></strong><em class="ms"> </em>command alias objc expression -l objc -O --<br/><strong class="mi ir"><em class="ms">2.</em></strong> command alias swift expression -l Swift -O --</span></pre><p id="cd67" class="pw-post-body-paragraph lj lk iq ll b lm mt jr lo lp mu ju lr ls mv lu lv lw mw ly lz ma mx mc md me ij bi translated">现在，下次我们启动应用程序并暂停调试器时，我们只需:</p><pre class="kg kh ki kj gt mj mi mk ml aw mm bi"><span id="512b" class="mn ks iq mi b gy mo mp l mq mr"><strong class="mi ir">(lldb)</strong> swift import UIKit; import MyApp_tvOS</span></pre><p id="5a4b" class="pw-post-body-paragraph lj lk iq ll b lm mt jr lo lp mu ju lr ls mv lu lv lw mw ly lz ma mx mc md me ij bi translated">那么，为什么不创建一个别名来定义我们的助手函数呢？通过将我们的函数转换成一行(这是这种无Python方法的一个警告)并在它前面加上前缀<code class="fe mf mg mh mi b">$</code>，我们可以将该函数标记为属于<code class="fe mf mg mh mi b">lldb</code>。让我们把它和我们需要的两个导入结合起来。在你的<code class="fe mf mg mh mi b">.lldbinit</code>后面加上下面一行:</p><pre class="kg kh ki kj gt mj mi mk ml aw mm bi"><span id="9fb2" class="mn ks iq mi b gy mo mp l mq mr"><strong class="mi ir"><em class="ms">1.</em></strong><em class="ms"> </em>command alias import_helpers expression -l Swift -O -- import UIKit; import MyApp_tvOS; func $highlightFocusedView(in target: UIView) { target.subviews.forEach { if $0.isFocused { $0.backgroundColor = .red } else { $highlightFocusedView(in: $0) } } };</span></pre><p id="4880" class="pw-post-body-paragraph lj lk iq ll b lm mt jr lo lp mu ju lr ls mv lu lv lw mw ly lz ma mx mc md me ij bi translated">现在当我们第一次暂停调试器时，我们可以运行</p><pre class="kg kh ki kj gt mj mi mk ml aw mm bi"><span id="97d4" class="mn ks iq mi b gy mo mp l mq mr"><strong class="mi ir">(lldb)</strong> import_helpers</span></pre><p id="746f" class="pw-post-body-paragraph lj lk iq ll b lm mt jr lo lp mu ju lr ls mv lu lv lw mw ly lz ma mx mc md me ij bi translated">从那时起，我们就可以<code class="fe mf mg mh mi b">swift $highlightFocusedView(in: UIApplication.shared.keyWindow!)</code>随心所欲了！当然，您可以继续将<code class="fe mf mg mh mi b">func $helpers(...)</code>添加到同一个别名中——只要确保它们都在一行上，并用<code class="fe mf mg mh mi b">;</code>隔开</p><h1 id="85b3" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">intermission—cat transaction . flush()</h1><p id="68ec" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">您知道在暂停的调试器中进行更改后，可以强制设备屏幕更新吗？在运行任何改变UI的命令后，在<code class="fe mf mg mh mi b">lldb</code>提示符下调用<code class="fe mf mg mh mi b">swift CATransation.flush()</code>应该会强制刷新屏幕！您可以将它插入到您的助手函数中，或者将<code class="fe mf mg mh mi b">func $flush() { CATransation.flush() }</code>添加到您的<code class="fe mf mg mh mi b">import_helpers</code>别名中，这样您就可以根据需要使用<code class="fe mf mg mh mi b">swift $flush()</code>了——不再需要解挂起调试器了！</p><p id="baca" class="pw-post-body-paragraph lj lk iq ll b lm mt jr lo lp mu ju lr ls mv lu lv lw mw ly lz ma mx mc md me ij bi translated">使用<code class="fe mf mg mh mi b">CATransation.flush()</code>对我来说是一种常见的技术，所以我希望能够以最简单的方式调用它(也就是说，我不想总是伸手去拿<code class="fe mf mg mh mi b">$()</code>键)。使用正则表达式，我们可以在别名的变量输入周围插入代码。可选地，用下面一行替换我们之前制作的<code class="fe mf mg mh mi b">command alias swift ...</code>:</p><pre class="kg kh ki kj gt mj mi mk ml aw mm bi"><span id="4937" class="mn ks iq mi b gy mo mp l mq mr"><strong class="mi ir"><em class="ms">1. </em></strong>command regex swift 's#(.+)#expression -l Swift -O -- defer { CATransaction.flush() }; %1#'</span></pre><p id="8217" class="pw-post-body-paragraph lj lk iq ll b lm mt jr lo lp mu ju lr ls mv lu lv lw mw ly lz ma mx mc md me ij bi translated">这是一种在每个命令后利用<code class="fe mf mg mh mi b">defer</code>运行<code class="fe mf mg mh mi b">CATransaction.flush()</code>的偷偷摸摸的方法。我们当然可以简单地在<code class="fe mf mg mh mi b">%1</code>后添加<code class="fe mf mg mh mi b">; CATransaction.flush()</code> <em class="ms">，但是这意味着调试器将打印所述函数的返回值(<code class="fe mf mg mh mi b">Void</code>)供我们检查，而不是我们输入的代码。希望这种变通办法在将来仍然有效！</em></p><h1 id="e116" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">第三幕——大结局</h1><p id="7ba5" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">在每个调试会话开始时调用<code class="fe mf mg mh mi b">import_helpers</code>并不困难，但是我们应该尽可能自动化重复的任务。另一个问题是我们的<code class="fe mf mg mh mi b">import_helpers</code>包含了<code class="fe mf mg mh mi b">import MyApp_tvOS</code>——如果我们正在处理其他目标或项目呢？如果别名中的一条语句失败，所有后续语句都将被跳过。相反，让我们使用一个断点。</p><p id="3d91" class="pw-post-body-paragraph lj lk iq ll b lm mt jr lo lp mu ju lr ls mv lu lv lw mw ly lz ma mx mc md me ij bi translated">Xcode的UI为我们提供了一种创建运行命令的“符号断点”的方法——然而这些小窗口可能有点挑剔。所以让我们再次添加我们的<code class="fe mf mg mh mi b">.lldbinit</code>:</p><pre class="kg kh ki kj gt mj mi mk ml aw mm bi"><span id="606d" class="mn ks iq mi b gy mo mp l mq mr"><strong class="mi ir"><em class="ms">1.</em></strong><em class="ms"> </em>breakpoint set -n AppDelegate.application --one-shot true --auto-continue true<br/><strong class="mi ir"><em class="ms">2.</em></strong><em class="ms"> </em>breakpoint command add<br/><strong class="mi ir"><em class="ms">3.</em></strong><em class="ms"> </em>swift import UIKit<br/><strong class="mi ir"><em class="ms">4.</em></strong><em class="ms"> </em>swift import MyApp_tvOS<br/><strong class="mi ir"><em class="ms">5.</em></strong><em class="ms"> </em>swift func $highlightFocusedView(in target: UIView) { target.subviews.forEach { if $0.isFocused { $0.backgroundColor = .red } else { $highlightFocusedView(in: $0) } } } ;<br/><strong class="mi ir"><em class="ms">6.</em></strong><em class="ms"> </em>DONE</span></pre><p id="145f" class="pw-post-body-paragraph lj lk iq ll b lm mt jr lo lp mu ju lr ls mv lu lv lw mw ly lz ma mx mc md me ij bi translated">它是如何工作的？</p><ul class=""><li id="3b9a" class="mz na iq ll b lm mt lp mu ls nb lw nc ma nd me ne nf ng nh bi translated"><code class="fe mf mg mh mi b">-n AppDelegate.application</code>使断点停在任何匹配该名称的函数上。在我的例子中，这分解为六个独立的函数。理想情况下，我们可以使用<code class="fe mf mg mh mi b">AppDelegate.application(_:didFinishLaunchingWithOption:)</code>作为这个参数的值，但是我无法让它(或者它的变体)工作。基本上，对于这个参数，我们希望选择一个在尽可能接近应用程序生命周期开始时调用的函数，这样我们的助手就可以尽早创建。</li><li id="b56c" class="mz na iq ll b lm ni lp nj ls nk lw nl ma nm me ne nf ng nh bi translated"><code class="fe mf mg mh mi b">--one-shot true</code>表示断点在第一次遇到后应被删除(解决前一点的问题)。</li><li id="f891" class="mz na iq ll b lm ni lp nj ls nk lw nl ma nm me ne nf ng nh bi translated">意味着我们实际上并不想在到达这个断点时暂停执行:只是评估它的命令并继续。</li><li id="2a50" class="mz na iq ll b lm ni lp nj ls nk lw nl ma nm me ne nf ng nh bi translated"><code class="fe mf mg mh mi b">breakpoint command add</code>表示后面的每一行都应该追加先前创建的断点列表，当到达断点时必须执行这些命令。</li><li id="68aa" class="mz na iq ll b lm ni lp nj ls nk lw nl ma nm me ne nf ng nh bi translated"><code class="fe mf mg mh mi b">DONE</code>标志着<code class="fe mf mg mh mi b">breakpoint command add</code>所期望的命令列表的结束</li></ul><p id="32b3" class="pw-post-body-paragraph lj lk iq ll b lm mt jr lo lp mu ju lr ls mv lu lv lw mw ly lz ma mx mc md me ij bi translated">我们现在有能力创建一个可无限扩展(且可合理维护)的Swift语言助手函数列表，这些函数可在调试器中使用！</p><h1 id="50cb" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated"><strong class="ak">结语—我的助手函数</strong></h1><h2 id="1f86" class="mn ks iq bd kt nn no dn kx np nq dp lb ls nr ns ld lw nt nu lf ma nv nw lh nx bi translated"><strong class="ak"> $findViews(_:in:) </strong></h2><p id="a41d" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">我实际上没有一个<code class="fe mf mg mh mi b">$highlightFocusedView(...)</code>助手，因为用一个通用函数找到某个类的所有视图很容易。例如，以下代码查找屏幕上的所有UIButtons，并将它们的背景色更改为红色:</p><pre class="kg kh ki kj gt mj mi mk ml aw mm bi"><span id="136e" class="mn ks iq mi b gy mo mp l mq mr"><strong class="mi ir">(lldb) </strong>swift $findViews(UIButton.self).filter({ $0.isFocused }).forEach({ $0.backgroundColor = .red })</span></pre><p id="85bb" class="pw-post-body-paragraph lj lk iq ll b lm mt jr lo lp mu ju lr ls mv lu lv lw mw ly lz ma mx mc md me ij bi translated">我的另一个常见用途是更改标签的文本:</p><pre class="kg kh ki kj gt mj mi mk ml aw mm bi"><span id="5041" class="mn ks iq mi b gy mo mp l mq mr"><strong class="mi ir">(lldb)</strong> swift $findViews(UILabel.self).first(where: { $0.text == "Interstellar" })!.text = "This is a really long string to test how the layout reacts to it"</span></pre><h2 id="9247" class="mn ks iq bd kt nn no dn kx np nq dp lb ls nr ns ld lw nt nu lf ma nv nw lh nx bi translated"><strong class="ak">$打印子视图(共个)</strong></h2><p id="f002" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">这个助手简单地将私有消息<code class="fe mf mg mh mi b">recursiveDescription</code>发送给一个视图，这样它就可以打印出它的继承性:</p><pre class="kg kh ki kj gt mj mi mk ml aw mm bi"><span id="3185" class="mn ks iq mi b gy mo mp l mq mr"><strong class="mi ir">(lldb)</strong> swift $printSubviews(of: self.view.headerContainer)</span></pre><h2 id="5bb2" class="mn ks iq bd kt nn no dn kx np nq dp lb ls nr ns ld lw nt nu lf ma nv nw lh nx bi translated"><strong class="ak">n对象。$from(_:) </strong></h2><p id="f301" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">我最喜欢的:这个扩展有助于从一个地址获得一个具体的类型，你可能会在Xcode的视图调试器中找到这个地址(或者在打印一个数组时，可能会从<code class="fe mf mg mh mi b">swift $findViews(UIView.self)</code>的输出中找到这个地址？).例如，如果我在视图调试器中看到一个视图，我想隐藏它，我可以从对象检查器中复制它的地址并运行:</p><pre class="kg kh ki kj gt mj mi mk ml aw mm bi"><span id="1add" class="mn ks iq mi b gy mo mp l mq mr"><strong class="mi ir">(lldb)</strong> swift UIView.$from(0x7f921c5144a0).isHidden = true</span></pre><p id="18bf" class="pw-post-body-paragraph lj lk iq ll b lm mt jr lo lp mu ju lr ls mv lu lv lw mw ly lz ma mx mc md me ij bi translated">可能性是无限的！</p><p id="d363" class="pw-post-body-paragraph lj lk iq ll b lm mt jr lo lp mu ju lr ls mv lu lv lw mw ly lz ma mx mc md me ij bi translated">最后，这里是我的<code class="fe mf mg mh mi b">.lldbinit</code>的一个活拷贝:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div><figcaption class="oa ob gj gh gi oc od bd b be z dk translated"><a class="ae oe" href="https://gist.github.com/maxchuquimia/3eb255b0ea2088829b460358d9f058d3" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/maxchuquimia/3eb 255 b 0ea 2088829 b 460358d 9 f 058d 3</a></figcaption></figure></div></div>    
</body>
</html>