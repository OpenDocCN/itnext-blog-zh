<html>
<head>
<title>RxSwift x Firestore</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">RxSwift x Firestore</h1>
<blockquote>原文：<a href="https://itnext.io/rxswift-x-firestore-5beefe97e379?source=collection_archive---------4-----------------------#2021-08-10">https://itnext.io/rxswift-x-firestore-5beefe97e379?source=collection_archive---------4-----------------------#2021-08-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/a792bf8bb61a98da521b9537927da749.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-291qY-_i2HFVevXVrohiA.png"/></div></div></figure><blockquote class="jy jz ka"><p id="be84" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">Firebase的产品之一Cloud Firestore是一个云托管的noSQL数据库，支持移动和网络的实时同步和离线支持，因此您可以构建响应迅速的应用程序，无论网络延迟或互联网连接如何。</p></blockquote><p id="0f0c" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">我不想过多地谈论<strong class="ke ir"> Firebase </strong>生态系统，因为这需要一年的时间来解释它有多不可思议。文章的主要目的是向你展示如何专业地使用<strong class="ke ir">云Firestore </strong>与<strong class="ke ir"> RxSwift </strong>。</p><p id="cc73" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">首先，你得准备一些东西。</p><ul class=""><li id="35ac" class="ld le iq ke b kf kg kj kk la lf lb lg lc lh kz li lj lk ll bi translated"><a class="ae lm" href="https://firebase.google.com/docs/firestore/quickstart#ios" rel="noopener ugc nofollow" target="_blank"> <strong class="ke ir">添加FirebaseFirestore框架</strong> </a></li><li id="3d42" class="ld le iq ke b kf ln kj lo la lp lb lq lc lr kz li lj lk ll bi translated"><a class="ae lm" href="https://github.com/RxSwiftCommunity/RxFirebase#firestore" rel="noopener ugc nofollow" target="_blank"> <strong class="ke ir">添加RxFirestore库</strong> </a></li><li id="917d" class="ld le iq ke b kf ln kj lo la lp lb lq lc lr kz li lj lk ll bi translated"><a class="ae lm" href="https://github.com/alickbass/CodableFirebase" rel="noopener ugc nofollow" target="_blank"> <strong class="ke ir">添加CodableFirebase </strong> </a></li></ul><p id="6d4a" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">其次，我们喝点水，稍微放松一下。</p><h1 id="04d8" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated"><strong class="ak">编码时间！</strong></h1><h2 id="e3ef" class="mq lt iq bd lu mr ms dn ly mt mu dp mc la mv mw mg lb mx my mk lc mz na mo nb bi translated"><strong class="ak"> 1。创建firestore客户端管理。</strong></h2><figure class="nc nd ne nf gt jr"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="6e4c" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">这里，我们将创建一个FirestoreClient类，它应用了<strong class="ke ir">单例模式。</strong></p><ul class=""><li id="399d" class="ld le iq ke b kf kg kj kk la lf lb lg lc lh kz li lj lk ll bi translated"><strong class="ke ir"> persistenceEnabled </strong>:默认情况下，离线持久化是启用的，所以如果你不想缓存你的app正在使用的云Firestore数据的副本，那么就把它设置为<code class="fe ni nj nk nl b"><strong class="ke ir">false.</strong></code> <strong class="ke ir"> </strong>详细概述，参见这个<a class="ae lm" href="https://firebase.google.com/docs/firestore/manage-data/enable-offline" rel="noopener ugc nofollow" target="_blank">文档</a>。</li></ul><h2 id="6d4d" class="mq lt iq bd lu mr ms dn ly mt mu dp mc la mv mw mg lb mx my mk lc mz na mo nb bi translated"><strong class="ak"> 2。将数据写入云Firestore。</strong></h2><p id="7b36" class="pw-post-body-paragraph kb kc iq ke b kf nm kh ki kj nn kl km la no kp kq lb np kt ku lc nq kx ky kz ij bi translated">例如，我们要写一个函数给<strong class="ke ir">发送</strong>一条消息。</p><ul class=""><li id="a0c0" class="ld le iq ke b kf kg kj kk la lf lb lg lc lh kz li lj lk ll bi translated">首先，编写一个您希望从<strong class="ke ir"> Cloud Firestore发送和接收数据的消息请求和响应模型。</strong></li></ul><figure class="nc nd ne nf gt jr"><div class="bz fp l di"><div class="ng nh l"/></div></figure><ul class=""><li id="9509" class="ld le iq ke b kf kg kj kk la lf lb lg lc lh kz li lj lk ll bi translated">接下来，编写一个发送消息函数<strong class="ke ir">。</strong></li></ul><figure class="nc nd ne nf gt jr"><div class="bz fp l di"><div class="ng nh l"/></div></figure><figure class="nc nd ne nf gt jr"><div class="bz fp l di"><div class="ng nh l"/></div></figure><ul class=""><li id="7024" class="ld le iq ke b kf kg kj kk la lf lb lg lc lh kz li lj lk ll bi translated">让我们看看<em class="kd">第7行</em>，<strong class="ke ir"> addDocument </strong>函数需要一个<code class="fe ni nj nk nl b">NSDictionary</code>作为它的参数，所以让我们创建一个扩展，将<code class="fe ni nj nk nl b">Encodable</code>对象转换成一个<code class="fe ni nj nk nl b">NSDictionary.</code><a class="ae lm" href="https://gist.github.com/dubydu/1bd785b2b8507192093981f55662aefc#file-encodable-extension-swift" rel="noopener ugc nofollow" target="_blank"><strong class="ke ir"><em class="kd">Encodable+extension . swift</em></strong></a></li></ul><p id="12ee" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">如果一切顺利，我们将有一个这样的结构化数据:</p><figure class="nc nd ne nf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nr"><img src="../Images/ecd24d2bd65fc2cdea0bbb6541dd2704.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W4mLjsuY1mNXe3l6da372A.png"/></div></div></figure><p id="98cd" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">有关详细概述，请参见本<a class="ae lm" href="https://firebase.google.com/docs/firestore/manage-data/add-data" rel="noopener ugc nofollow" target="_blank">文件</a></p><h2 id="c7f3" class="mq lt iq bd lu mr ms dn ly mt mu dp mc la mv mw mg lb mx my mk lc mz na mo nb bi translated">3.从云Firestore读取数据。</h2><p id="d141" class="pw-post-body-paragraph kb kc iq ke b kf nm kh ki kj nn kl km la no kp kq lb np kt ku lc nq kx ky kz ij bi translated">你已经知道如何发送信息；然而，为了使这个例子更清楚，我们将编写另一个函数来从<code class="fe ni nj nk nl b">messages</code>集合中检索所有消息。</p><figure class="nc nd ne nf gt jr"><div class="bz fp l di"><div class="ng nh l"/></div></figure><figure class="nc nd ne nf gt jr"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="0eed" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">让我们创建一些<strong class="ke ir">可编码的</strong>包装器，以便在收到来自<strong class="ke ir">云Firestore </strong> — <em class="kd"> line 9 </em>的快照后解析数据。</p><ul class=""><li id="d119" class="ld le iq ke b kf kg kj kk la lf lb lg lc lh kz li lj lk ll bi translated"><strong class="ke ir">解码单个文档</strong></li></ul><figure class="nc nd ne nf gt jr"><div class="bz fp l di"><div class="ng nh l"/></div></figure><ul class=""><li id="05d8" class="ld le iq ke b kf kg kj kk la lf lb lg lc lh kz li lj lk ll bi translated"><strong class="ke ir">解码多个文件</strong></li></ul><figure class="nc nd ne nf gt jr"><div class="bz fp l di"><div class="ng nh l"/></div></figure><blockquote class="jy jz ka"><p id="d4f6" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi"><em class="iq">These wrappers took inspiration from this article: </em><a class="ae lm" href="https://qiita.com/d-nakajima/items/236f711937ea81ebdcfa" rel="noopener ugc nofollow" target="_blank"><strong class="ke ir"><em class="iq">[Swift]Firestoreのdocument取得を見やすく書けるようにしてみる</em></strong></a></p></blockquote><p id="e83c" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi ns translated"><span class="l nt nu nv bm nw nx ny nz oa di"> F </span>最后，<code class="fe ni nj nk nl b">listenChatMessage()</code>函数将返回一个包含元素值的<code class="fe ni nj nk nl b">Observable</code>，该元素值是来自<strong class="ke ir"> Cloud Firestore </strong>的当前数据库。然后，每当数据库由于添加、删除或更新等操作而发生变化时，该函数将立即返回一个<code class="fe ni nj nk nl b">Observable</code>,其中包含您修改的数据库的一个元素值。</p></div></div>    
</body>
</html>