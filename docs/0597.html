<html>
<head>
<title>Docker in Docker?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Docker中的Docker？</h1>
<blockquote>原文：<a href="https://itnext.io/docker-in-docker-521958d34efd?source=collection_archive---------0-----------------------#2018-04-08">https://itnext.io/docker-in-docker-521958d34efd?source=collection_archive---------0-----------------------#2018-04-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="a7b4" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">你能在Docker容器中运行Docker吗？</h2></div><p id="3a45" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这篇短文基于jérme Petazzoni的博客文章:<a class="ae lb" href="https://jpetazzo.github.io/2015/09/03/do-not-use-docker-in-docker-for-ci/" rel="noopener ugc nofollow" target="_blank"> <strong class="kh ir">为您的CI或测试环境使用Docker-in-Docker？</strong> </a> <strong class="kh ir">三思而行。</strong></p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi lc"><img src="../Images/6bb32b569d0c32bfe1a203d0cbd2607a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TLfGMbPi7lXyhBJTfCKo2Q.jpeg"/></div></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk translated">货船上的集装箱。<a class="ae lb" href="https://unsplash.com/photos/hjEesK4KSDs?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Axel Ahoi </a>在<a class="ae lb" href="https://unsplash.com/search/photos/container-ship?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照。</figcaption></figure><p id="1435" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">本文关注的问题如下:如果您运行一个安装了Docker的Docker容器，那么您是否可以在该Docker容器中运行Docker(例如，拉取和构建图像，或者运行其他容器),并且两个Docker实例彼此完全独立？</p><p id="5101" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">答案是肯定的，但不建议这样做，因为它会导致许多低级技术问题，这些问题与Docker在操作系统上的实现方式有关，在<a class="ae lb" href="https://jpetazzo.github.io/2015/09/03/do-not-use-docker-in-docker-for-ci/" rel="noopener ugc nofollow" target="_blank">jérme Petazzoni的帖子</a>中有详细解释。</p><p id="f4f2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好消息是，在Docker容器中使用Docker还有另一种推荐的方法，使用这种方法，两个Docker实例不是相互独立的，但是可以绕过这些问题。</p><p id="79a6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用这种方法，安装了Docker的容器不运行它自己的<strong class="kh ir"> </strong> <a class="ae lb" href="https://nickjanetakis.com/blog/understanding-how-the-docker-daemon-and-docker-cli-work-together#visualizing-docker-s-architecture" rel="noopener ugc nofollow" target="_blank"> <strong class="kh ir"> Docker守护进程</strong> </a>，而是连接到主机系统的Docker守护进程。这意味着，在容器和主机系统中都有一个Docker CLI，但是它们都连接到同一个Docker守护进程。在任何时候，只有一个Docker守护进程运行在您的机器上，即运行在主机系统上的那个。</p><p id="89aa" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为此，您可以启动一个安装了Docker的Docker容器，使用以下<strong class="kh ir"> </strong> <a class="ae lb" href="https://docs.docker.com/storage/bind-mounts/" rel="noopener ugc nofollow" target="_blank"> <strong class="kh ir">绑定挂载</strong> </a>选项:</p><pre class="ld le lf lg gt ls lt lu lv aw lw bi"><span id="653a" class="lx ly iq lt b gy lz ma l mb mc">-v /var/run/docker.sock:/var/run/docker.sock</span></pre><p id="2929" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，您可以使用<strong class="kh ir"> </strong> <code class="fe md me mf lt b"><a class="ae lb" href="https://hub.docker.com/r/_/docker/" rel="noopener ugc nofollow" target="_blank"><strong class="kh ir">docker</strong></a></code>映像，这是一个安装了Docker的Docker映像，并像这样启动它:</p><pre class="ld le lf lg gt ls lt lu lv aw lw bi"><span id="c4a1" class="lx ly iq lt b gy lz ma l mb mc">docker run -ti -v /var/run/docker.sock:/var/run/docker.sock docker</span></pre><p id="0e29" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后在刚刚启动的Docker容器中，运行一些Docker命令，例如:</p><pre class="ld le lf lg gt ls lt lu lv aw lw bi"><span id="c141" class="lx ly iq lt b gy lz ma l mb mc">docker images<br/>docker ps</span></pre><p id="1cb8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">观察输出。输出与您在主机系统上运行这些命令时完全相同。</p><p id="ab37" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">看起来像是您刚刚开始的容器的Docker安装，您可能希望它是新的和未被触及的，已经有一些图像被缓存，一些容器正在运行。这是因为我们在容器中连接了Docker CLI，以便与已经在主机系统上运行的Docker守护进程进行对话。</p><p id="2856" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这意味着，如果您将一个图像放入容器中，这个图像在主机系统上也是可见的(反之亦然)。而且如果你在容器内部运行一个容器，这个容器实际上将是主机上运行的所有容器的“兄弟”(包括你在其中运行Docker的容器)。</p><p id="c124" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这一开始可能会令人恼火。您可能会想，如果容器中的Docker安装与主机系统完全隔离开来，那该多好。然而，对于大多数用例来说，完全封装实际上是不需要的，只要您需要在Docker容器中使用Docker，这种变通方法就是一种合法的解决方案。</p><p id="3afd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是什么时候需要在Docker容器中使用Docker呢？</p><h1 id="4fa7" class="mg ly iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">你什么时候需要？</h1><p id="de82" class="pw-post-body-paragraph kf kg iq kh b ki mx jr kk kl my ju kn ko mz kq kr ks na ku kv kw nb ky kz la ij bi translated">在Docker容器中运行Docker的问题在使用像Jenkins这样的CI/CD工具时经常出现。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi nc"><img src="../Images/2bd26feac6a62d72b43262eceec17ed8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s8mwAOWdb2choX4pj9ozvw.png"/></div></div></figure><p id="0e5f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在Jenkins中，管道阶段中的所有命令都在您指定的代理上执行。这个代理可以是一个Docker容器。因此，如果您的命令之一，例如，在<em class="nd">构建</em>阶段，是一个Docker命令(例如，用于构建图像)，那么您需要在Docker容器中运行一个Docker命令。</p><p id="5acf" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，Jenkins本身可以作为Docker容器运行。如果您使用Docker代理，您将从Jenkins Docker容器中启动这个Docker容器。如果您的Jenkins管道中也有Docker命令，那么您将有三层嵌套的“Docker”。</p><p id="00cf" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，使用上面的方法，所有这些Docker使用同一个Docker守护进程，并且绕过了在同一个系统上多个守护进程(在本例中是三个)的所有困难。</p><p id="46d4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要做到这一点，您唯一要做的就是用<code class="fe md me mf lt b">-v /var/run/docker.sock:/var/run/docker.sock </code>选项启动每个Docker容器，如上所述。</p><h1 id="4b46" class="mg ly iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">码头工人中的真正码头工人</h1><p id="480e" class="pw-post-body-paragraph kf kg iq kh b ki mx jr kk kl my ju kn ko mz kq kr ks na ku kv kw nb ky kz la ij bi translated">如果你真的想的话，你可以在Docker中使用“真正的”Docker，也就是完全相互封装的嵌套Docker实例。您可以使用<code class="fe md me mf lt b"><a class="ae lb" href="https://hub.docker.com/r/_/docker/" rel="noopener ugc nofollow" target="_blank">docker</a></code>图像的<code class="fe md me mf lt b">dind</code> ( <em class="nd"> Docker in Docker </em>)标签来完成此操作，如下所示:</p><pre class="ld le lf lg gt ls lt lu lv aw lw bi"><span id="cab5" class="lx ly iq lt b gy lz ma l mb mc">docker run --privileged -d docker:dind</span></pre><p id="6723" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">杰罗姆·佩塔佐尼在<a class="ae lb" href="https://github.com/jpetazzo/dind" rel="noopener ugc nofollow" target="_blank">这里</a>详细描述了这种方法。但是也正如那里提到的，通常没有必要这样做。</p></div></div>    
</body>
</html>