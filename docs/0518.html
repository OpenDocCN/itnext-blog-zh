<html>
<head>
<title>GraphQL: Keeping up with the Apollo’s</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">GraphQL:跟上阿波罗的步伐</h1>
<blockquote>原文：<a href="https://itnext.io/keeping-up-with-the-apollos-40097584714b?source=collection_archive---------1-----------------------#2018-03-24">https://itnext.io/keeping-up-with-the-apollos-40097584714b?source=collection_archive---------1-----------------------#2018-03-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/5dcd6585e97ceffd1b6a1a2099df2b52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2g-Ij0aboa8Sslk2NEg_IQ.png"/></div></div></figure><p id="c2de" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<a class="ae kw" rel="noopener ugc nofollow" target="_blank" href="/graphql-how-far-are-we-gone-77f5ae8fc2e5">上一篇文章</a>中，我谈到了围绕GraphQL萌芽的不同技术。今天我要特别关注一下<a class="ae kw" href="https://www.apollographql.com/" rel="noopener ugc nofollow" target="_blank">阿波罗GraphQL </a>的作品。这是一个开发人员社区，它似乎站在客户端实现的前沿，并为他们的技术提供了机会。这是一件好事，因为Apollo GraphQL的实现非常简单，易于上手。但是新技术带来了新的挑战。</p><h2 id="b96c" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">问题</h2><p id="4687" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated"><a class="ae kw" href="https://dev-blog.apollodata.com/introducing-react-apollo-2-1-c837cc23d926" rel="noopener ugc nofollow" target="_blank"> React Apollo 2.1 </a>已经发布，有一些有趣的事情需要了解。以前的版本采用了更类似Redux的方法将组件连接到Apollo客户机。好处是它是100%向后兼容的。下面是我使用<a class="ae kw" href="https://github.com/kimobrian/GraphQL-Course/blob/lesson3F/packages/client/package.json#L26" rel="noopener ugc nofollow" target="_blank"> react-apollo 2.0.4 </a>的一个项目的摘录。这段代码从GraphQL服务器获取图书列表。请注意我们是如何将组件连接到客户机的。</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="65ca" class="kx ky iq ma b gy me mf l mg mh">...</span><span id="7988" class="kx ky iq ma b gy mi mf l mg mh">import gql from "graphql-tag";<br/>import { graphql } from "react-apollo";</span><span id="088e" class="kx ky iq ma b gy mi mf l mg mh">...</span><span id="2442" class="kx ky iq ma b gy mi mf l mg mh">export const getBooksQuery = gql`  <br/>  query getAllBooks {    <br/>     books: fetchAllBooks {      <br/>        id      <br/>        title      <br/>        description    <br/>      }  <br/>   }`;</span><span id="d76b" class="kx ky iq ma b gy mi mf l mg mh">const BooksComponent = (props) =&gt; {  <br/>  let { error, loading, books } = props.data;  <br/>  if (error) return &lt;div&gt; An Error Occurred&lt;/div&gt;;  <br/>  else if (loading)    <br/>       return ( &lt;div style={styles.loaderSection}&gt; <br/>                   &lt;CircularProgress /&gt;                        <br/>                &lt;/div&gt;    <br/>              );  <br/>   else return ( /* Render the list of books here */ );<br/>}; </span><span id="fb2b" class="kx ky iq ma b gy mi mf l mg mh">const BooksComponentWithData = graphql(getBooksQuery)(BooksComponent);</span><span id="4251" class="kx ky iq ma b gy mi mf l mg mh">export default BooksComponentWithData;</span></pre><p id="4135" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过使用<code class="fe mj mk ml ma b">graphql</code>的上述连接，我们可以访问组件内部的三个重要道具，我们可以使用它们向用户显示适当的消息。</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="4bc3" class="kx ky iq ma b gy me mf l mg mh">let { error, loading, books } = props.data;</span></pre><p id="deab" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们也可以用<code class="fe mj mk ml ma b">withApollo</code>代替<code class="fe mj mk ml ma b">graphql</code>来连接组件。</p><p id="c76a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我跳过了次要的细节和导入，这是Github上的完整组件。</p><div class="mm mn gp gr mo mp"><a href="https://github.com/kimobrian/GraphQL-Course/blob/lesson3F/packages/client/app/components/BooksComponent.jsx" rel="noopener  ugc nofollow" target="_blank"><div class="mq ab fo"><div class="mr ab ms cl cj mt"><h2 class="bd ir gy z fp mu fr fs mv fu fw ip bi translated">kimobrian/graph QL-课程</h2><div class="mw l"><h3 class="bd b gy z fp mu fr fs mv fu fw dk translated">一个完整的GraphQL课程monorepo</h3></div><div class="mx l"><p class="bd b dl z fp mu fr fs mv fu fw dk translated">github.com</p></div></div><div class="my l"><div class="mz l na nb nc my nd jw mp"/></div></div></a></div><p id="78c4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在这里有一个来自Apollo GraphQL迁移文档的例子，差别非常明显，而且更“有反应”。</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="f9d4" class="kx ky iq ma b gy me mf l mg mh">import { Query } from "react-apollo";<br/>import gql from "graphql-tag";<br/><br/>const ExchangeRates = () =&gt; (<br/>  &lt;Query<br/>    query={gql`<br/>      {<br/>        rates(currency: "USD") {<br/>          currency<br/>          rate<br/>        }<br/>      }<br/>    `}<br/>  &gt;<br/>    {({ loading, error, data }) =&gt; {<br/>      if (loading) return &lt;p&gt;Loading...&lt;/p&gt;;<br/>      if (error) return &lt;p&gt;Error :(&lt;/p&gt;;<br/><br/>      return data.rates.map(({ currency, rate }) =&gt; (<br/>        &lt;div key={currency}&gt;<br/>          &lt;p&gt;{`${currency}: ${rate}`}&lt;/p&gt;<br/>        &lt;/div&gt;<br/>      ));<br/>    }}<br/>  &lt;/Query&gt;<br/>);</span></pre><p id="99f0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们仍然可以像以前一样访问加载、数据和错误。注意来自<code class="fe mj mk ml ma b">react-apollo</code>的<code class="fe mj mk ml ma b">Query</code>组件。这里的另一个优点是Apollo Client自动缓存数据，因此如果您运行查询两次，就不会产生加载指示符。</p><p id="b83b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上述实现将在组件加载时自动触发查询。如果您希望查询由用户手动触发，该怎么办？这就是我们得到<a class="ae kw" href="https://www.apollographql.com/docs/react/essentials/queries.html#manual-query" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir"/></a><strong class="ka ir">的地方。</strong>这是我从阿波罗文档中借用的另一个片段。在这种情况下，我们可以在render prop函数中直接访问客户端。</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="722d" class="kx ky iq ma b gy me mf l mg mh">import React, { Component } from 'react';<br/>import { ApolloConsumer } from 'react-apollo';<br/><br/>class DelayedQuery extends Component {<br/>  state = { dog: null };<br/><br/>  onDogFetched = dog =&gt; this.setState(() =&gt; ({ dog }));<br/><br/>  render() {<br/>    return (<br/>      &lt;ApolloConsumer&gt;<br/>        {client =&gt; (<br/>          &lt;div&gt;<br/>            {this.state.dog &amp;&amp; &lt;img src={this.state.dog.displayImage} /&gt;}<br/>            &lt;button<br/>              onClick={async () =&gt; {<br/>                const { data } = await client.query({<br/>                  query: GET_DOG_PHOTO,<br/>                  variables: { breed: "bulldog" }<br/>                });<br/>                this.onDogFetched(data.dog);<br/>              }}<br/>            &gt;<br/>              Click me!<br/>            &lt;/button&gt;<br/>          &lt;/div&gt;<br/>        )}<br/>      &lt;/ApolloConsumer&gt;<br/>    );<br/>  }<br/>}</span></pre><h2 id="94e9" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">突变</h2><p id="974d" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">下面是一个示例组件，它通过变异创建一个新的图书记录。</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="fe89" class="kx ky iq ma b gy me mf l mg mh">import gql from "graphql-tag";<br/>import { graphql } from "react-apollo";<br/>import { getBooksQuery } from "./BooksComponent"; /* Re-use the<br/>          query from the Query section */</span><span id="94ae" class="kx ky iq ma b gy mi mf l mg mh">/* Create the mutation */</span><span id="911c" class="kx ky iq ma b gy mi mf l mg mh">export let createBookMutation = gql`  <br/>  mutation createBook($title: String!, $description: String!) {<br/>    createBook(title: $title, description: $description) {<br/>       id      <br/>       title      <br/>       description          <br/>  }  <br/>}`;</span><span id="1ace" class="kx ky iq ma b gy mi mf l mg mh">class NewBook extends Component {<br/>  ...<br/>  createBook () {<br/>    ... <br/>    /* We can access the mutation method through the props*/<br/>    this.props.<strong class="ma ir"><em class="ne">createNewBook</em></strong>(this.state.title,    this.state.description).then(data=&gt; {/* Logic for result */});<br/>    ...<br/>  }</span><span id="08c9" class="kx ky iq ma b gy mi mf l mg mh">   render() {/* Render Logic(Form to create book) */}<br/>}</span><span id="a896" class="kx ky iq ma b gy mi mf l mg mh">const NewBookComponentWithData = graphql(createBookMutation, {          props: ({ mutate }) =&gt; ({    <br/>    <strong class="ma ir"><em class="ne">createNewBook</em></strong>: (title, description) =&gt; mutate({ <br/>      variables: { title, description },          <br/>      update: (store, { data: { createBook } }) =&gt; { <br/>         /*Read the data from our cache for this query.  */        <br/>         try {            <br/>            const data = store.readQuery({ query: getBooksQuery }); <br/>            /* Add our book from the mutation to the end */  <br/>            data.books.push(createBook);<br/>            /* Write our data back to the cache. */<br/>            store.writeQuery({ query: getBooksQuery, data });<br/>         } catch(err){   <br/>            console.log("Cache Error:", err);<br/>         }<br/>      }, <br/>    })<br/>   })<br/>  })(NewBook); </span><span id="7175" class="kx ky iq ma b gy mi mf l mg mh">export default NewBookComponentWithData;</span></pre><p id="8c77" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是Github上的完整组件。</p><div class="mm mn gp gr mo mp"><a href="https://github.com/kimobrian/GraphQL-Course/blob/lesson3F/packages/client/app/components/NewBook.jsx" rel="noopener  ugc nofollow" target="_blank"><div class="mq ab fo"><div class="mr ab ms cl cj mt"><h2 class="bd ir gy z fp mu fr fs mv fu fw ip bi translated">kimobrian/graph QL-课程</h2><div class="mw l"><h3 class="bd b gy z fp mu fr fs mv fu fw dk translated">一个完整的GraphQL课程monorepo</h3></div><div class="mx l"><p class="bd b dl z fp mu fr fs mv fu fw dk translated">github.com</p></div></div><div class="my l"><div class="nf l na nb nc my nd jw mp"/></div></div></a></div><p id="5a5e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">即使删除了乐观UI部分，连接看起来仍然太多。这相当于<code class="fe mj mk ml ma b">mapDispatchToProps</code>，与其对应的查询相比，看起来并不简单。</p><p id="b3e6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面是react-apollo 2.1中类似于实现的<a class="ae kw" href="https://www.apollographql.com/docs/react/essentials/mutations.html" rel="noopener ugc nofollow" target="_blank"> Apollo GraphQL文档</a>的摘录。</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="6c7e" class="kx ky iq ma b gy me mf l mg mh">import gql from "graphql-tag";<br/>import { Mutation } from "react-apollo";<br/><br/>const ADD_TODO = gql`<br/>  mutation <strong class="ma ir"><em class="ne">addTodo</em></strong>($type: String!) {<br/>    addTodo(type: $type) {<br/>      id<br/>      type<br/>    }<br/>  }<br/>`;<br/><br/>const AddTodo = () =&gt; {<br/>  let input;<br/><br/>  return (<br/>    &lt;Mutation mutation={ADD_TODO}&gt;<br/>      {(<strong class="ma ir"><em class="ne">addTodo</em></strong>, { data }) =&gt; (<br/>        &lt;div&gt;<br/>          &lt;form<br/>            onSubmit={e =&gt; {<br/>              e.preventDefault();<br/>              <strong class="ma ir"><em class="ne">addTodo</em></strong>({ variables: { type: input.value } });<br/>              input.value = "";<br/>            }}<br/>          &gt;<br/>            &lt;input<br/>              ref={node =&gt; {<br/>                input = node;<br/>              }}<br/>            /&gt;<br/>            &lt;button type="submit"&gt;Add Todo&lt;/button&gt;<br/>          &lt;/form&gt;<br/>        &lt;/div&gt;<br/>      )}<br/>    &lt;/Mutation&gt;<br/>  );<br/>};</span></pre><p id="6221" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面的实现看起来更加清晰和直接。</p><blockquote class="ng nh ni"><p id="0dc7" class="jy jz ne ka b kb kc kd ke kf kg kh ki nj kk kl km nk ko kp kq nl ks kt ku kv ij bi translated">在上面的代码片段中，我们将一个用<code class="fe mj mk ml ma b">gql</code>函数包装的GraphQL变异字符串传递给<code class="fe mj mk ml ma b">this.props.mutation</code>，并向<code class="fe mj mk ml ma b">this.props.children</code>提供一个告诉React要呈现什么的函数。<code class="fe mj mk ml ma b">Mutation</code>组件是使用<a class="ae kw" href="https://reactjs.org/docs/render-props.html" rel="noopener ugc nofollow" target="_blank">渲染属性</a>模式的React组件的一个例子。React将调用您提供的render prop函数和一个包含加载、错误、被调用和数据属性的对象。</p><p id="236d" class="jy jz ne ka b kb kc kd ke kf kg kh ki nj kk kl km nk ko kp kq nl ks kt ku kv ij bi translated">首先，创建您的GraphQL变体，将其包装在<code class="fe mj mk ml ma b">gql</code>中，并将其传递给<code class="fe mj mk ml ma b">Mutation</code>组件上的<code class="fe mj mk ml ma b">mutation</code> prop。<code class="fe mj mk ml ma b">Mutation</code>组件也需要一个函数作为子组件(也称为渲染属性函数)。render prop函数的第一个参数是mutate函数，这是告诉Apollo客户端您想要触发一个突变的方式。变异函数可选取<code class="fe mj mk ml ma b">variables</code>、<code class="fe mj mk ml ma b">optimisticResponse</code>、<code class="fe mj mk ml ma b">refetchQueries</code>、<code class="fe mj mk ml ma b">update</code>；然而，您也可以将这些值作为道具传递给<code class="fe mj mk ml ma b">Mutation</code>组件。在示例中，注意使用了mutate函数(名为<code class="fe mj mk ml ma b">addTodo</code>)来提交包含变量的表单。</p><p id="d533" class="jy jz ne ka b kb kc kd ke kf kg kh ki nj kk kl km nk ko kp kq nl ks kt ku kv ij bi translated">render prop函数的第二个参数是一个对象，它包含您对<code class="fe mj mk ml ma b">data</code>属性的变异结果，以及用于<code class="fe mj mk ml ma b">loading</code>的布尔值，如果变异函数是<code class="fe mj mk ml ma b">called</code>，除了<code class="fe mj mk ml ma b">error</code>。如果您想忽略变异的结果，将<code class="fe mj mk ml ma b">ignoreResults</code>作为一个道具传递给变异组件。</p></blockquote><p id="544a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">更新缓存的示例代码可能如下所示:</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="ac60" class="kx ky iq ma b gy me mf l mg mh">...<br/>&lt;Mutation<br/>      mutation={ADD_TODO}<br/>      update={(cache, { data: { addTodo } }) =&gt; {<br/>        const { todos } = cache.readQuery({ query: GET_TODOS });<br/>        cache.writeQuery({<br/>          query: GET_TODOS,<br/>          data: { todos: todos.concat([addTodo]) }<br/>        });<br/>      }}<br/>    &gt;<br/>...</span></pre><p id="5ec8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">实现非常类似于以前的版本，只是更干净。</p><h2 id="5f5c" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">阿波罗-助推</h2><p id="579b" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">以前，我们需要安装几个(很多)包来设置Apollo客户端。Apollo boost带来了所有这些包，并且只允许安装一个包。</p><p id="8935" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Apollo Boost包含了一些我们认为对于使用Apollo客户端开发来说必不可少的包。这是盒子里的东西:</p><ul class=""><li id="c547" class="nm nn iq ka b kb kc kf kg kj no kn np kr nq kv nr ns nt nu bi translated">所有神奇的事情都发生在这里</li><li id="0051" class="nm nn iq ka b kb nv kf nw kj nx kn ny kr nz kv nr ns nt nu bi translated"><code class="fe mj mk ml ma b">apollo-cache-inmemory</code>:我们推荐的缓存</li><li id="843a" class="nm nn iq ka b kb nv kf nw kj nx kn ny kr nz kv nr ns nt nu bi translated"><code class="fe mj mk ml ma b">apollo-link-http</code>:用于远程数据获取的阿波罗链接</li><li id="bfaa" class="nm nn iq ka b kb nv kf nw kj nx kn ny kr nz kv nr ns nt nu bi translated"><code class="fe mj mk ml ma b">apollo-link-error</code>:用于错误处理的阿波罗链接</li><li id="b7f5" class="nm nn iq ka b kb nv kf nw kj nx kn ny kr nz kv nr ns nt nu bi translated"><code class="fe mj mk ml ma b">apollo-link-state</code>:本地状态管理的Apollo链接</li><li id="6e4c" class="nm nn iq ka b kb nv kf nw kj nx kn ny kr nz kv nr ns nt nu bi translated"><code class="fe mj mk ml ma b">graphql-tag</code>:为您的查询&amp;突变导出<code class="fe mj mk ml ma b">gql</code>函数</li></ul><p id="2b8c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">比较以下不带和带apollo-boost的npm命令。</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="ce0c" class="kx ky iq ma b gy me mf l mg mh"># Without apollo-boost<br/>npm install apollo-client apollo-cache-inmemory apollo-link-http apollo-link-error apollo-link --save</span><span id="4aec" class="kx ky iq ma b gy mi mf l mg mh"># With apollo-boost<br/>npm i apollo-boost graphql react-apollo@beta -S</span></pre><p id="072c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这使它变得容易，因为我们管理更少的包。</p><p id="2ecf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我希望这能让您了解GraphQL的客户端实现。</p><p id="c100" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我将欣赏掌声，积极的反馈和批评。我目前也在关注Graphcool社区，并将发布任何重大变化的更新。</p></div></div>    
</body>
</html>