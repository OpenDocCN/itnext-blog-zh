<html>
<head>
<title>Utilise render props to separate logic from presentation in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在React中利用渲染道具将逻辑与表示分离</h1>
<blockquote>原文：<a href="https://itnext.io/utilise-render-props-to-separate-logic-from-presentation-in-react-c5dd0edfa974?source=collection_archive---------5-----------------------#2018-06-10">https://itnext.io/utilise-render-props-to-separate-logic-from-presentation-in-react-c5dd0edfa974?source=collection_archive---------5-----------------------#2018-06-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/8933e4fa3854e49902a096a7f2866351.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y6C4nSvy2Woe0m7bWEn4BA.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">反应JS</figcaption></figure><div class=""/><p id="a079" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">将逻辑从你的陈述中分离出来一直是一种最佳实践。它加强了<a class="ae la" href="https://en.wikipedia.org/wiki/Single_responsibility_principle" rel="noopener ugc nofollow" target="_blank">单一责任原则(SRP) </a>，并使代码更容易测试。</p><p id="e45c" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">然而，React因为让开发人员轻易地将这两个问题混为一谈而陷入麻烦。让我们举一个来自<a class="ae la" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank">主页</a>的例子来解释:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="42b6" class="lk ll jf lg b gy lm ln l lo lp">class Timer extends React.Component {<br/>  constructor(props) {<br/>    super(props)<br/>    this.state = { seconds: 0 }<br/>  }</span><span id="218f" class="lk ll jf lg b gy lq ln l lo lp">  tick() {<br/>    this.setState(prevState =&gt; ({ seconds: prevState.seconds + 1 }))<br/>  }</span><span id="03e5" class="lk ll jf lg b gy lq ln l lo lp">  componentDidMount() {<br/>    this.interval = setInterval(() =&gt; this.tick(), 1000)<br/>  }</span><span id="46bc" class="lk ll jf lg b gy lq ln l lo lp">  componentWillUnmount() {<br/>    clearInterval(this.interval)<br/>  }</span><span id="5433" class="lk ll jf lg b gy lq ln l lo lp">  render() {<br/>    return &lt;<strong class="lg jg">div</strong>&gt;Seconds: {this.state.seconds}&lt;/<strong class="lg jg">div</strong>&gt;<br/>  }<br/>}</span></pre><p id="6e56" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">上面你可以看到相当简单的<code class="fe lr ls lt lg b">Timer</code>类。您还可以看到该类的显示逻辑被编码到了<code class="fe lr ls lt lg b">render()</code>方法中。</p><p id="9cd0" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在<code class="fe lr ls lt lg b">Timer</code>类中有<code class="fe lr ls lt lg b">&lt;div&gt;Seconds: {this.state.seconds}&lt;/div&gt;</code>的问题是它没有将逻辑和表示分开。</p><p id="0cbc" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">让我们把这两个问题分开:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="a2ca" class="lk ll jf lg b gy lm ln l lo lp">const SecondsActive = ({ seconds }) =&gt; <br/>  &lt;<strong class="lg jg">div</strong>&gt;Seconds: {seconds}&lt;/<strong class="lg jg">div</strong>&gt;;</span><span id="7f53" class="lk ll jf lg b gy lq ln l lo lp">class TimerContainer extends React.Component {<br/>  state = { seconds: 0 }</span><span id="19f7" class="lk ll jf lg b gy lq ln l lo lp">  tick() {<br/>    this.setState(({ seconds }) =&gt; ({ seconds: seconds + 1 }))<br/>  }</span><span id="6b27" class="lk ll jf lg b gy lq ln l lo lp">  componentDidMount() {<br/>    this.interval = setInterval(() =&gt; this.tick(), 1000)<br/>  }</span><span id="5af7" class="lk ll jf lg b gy lq ln l lo lp">  componentWillUnmount() {<br/>    clearInterval(this.interval)<br/>  }</span><span id="801c" class="lk ll jf lg b gy lq ln l lo lp">  render() {<br/>    return this.props.view({ seconds: this.state.seconds })<br/>  }<br/>}</span><span id="e384" class="lk ll jf lg b gy lq ln l lo lp">ReactDOM.render(<br/>  &lt;<strong class="lg jg">TimerContainer</strong> view={SecondsActive} /&gt;,<br/>  document.getElementById('app')<br/>);</span></pre><p id="2980" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">通过一个简单的切换到通过<code class="fe lr ls lt lg b">prop</code>渲染，我们使得<code class="fe lr ls lt lg b">Timer</code> ( <code class="fe lr ls lt lg b">TimerContainer</code>)类可以在许多表示组件中重用，并且使得表示组件非常容易测试！</p><h1 id="6088" class="lu ll jf bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">阅读更多关于渲染道具和反应</h1><ul class=""><li id="0380" class="mr ms jf ke b kf mt kj mu kn mv kr mw kv mx kz my mz na nb bi translated"><a class="ae la" href="https://gist.github.com/chantastic/fc9e3853464dffdb1e3c" rel="noopener ugc nofollow" target="_blank"> JSX，一年中</a></li><li id="a89e" class="mr ms jf ke b kf nc kj nd kn ne kr nf kv ng kz my mz na nb bi translated"><a class="ae la" href="https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0" rel="noopener">表示和容器组件</a></li><li id="c23b" class="mr ms jf ke b kf nc kj nd kn ne kr nf kv ng kz my mz na nb bi translated"><a class="ae la" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank">反应JS </a></li><li id="2bf2" class="mr ms jf ke b kf nc kj nd kn ne kr nf kv ng kz my mz na nb bi translated"><a class="ae la" href="https://reactpatterns.com/#render-callback" rel="noopener ugc nofollow" target="_blank">渲染道具</a></li></ul></div></div>    
</body>
</html>