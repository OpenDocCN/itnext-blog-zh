<html>
<head>
<title>Create chrome extension with ReactJs using inject page strategy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用注入页面策略创建带有ReactJs的chrome扩展</h1>
<blockquote>原文：<a href="https://itnext.io/create-chrome-extension-with-reactjs-using-inject-page-strategy-137650de1f39?source=collection_archive---------0-----------------------#2018-07-10">https://itnext.io/create-chrome-extension-with-reactjs-using-inject-page-strategy-137650de1f39?source=collection_archive---------0-----------------------#2018-07-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/104b38d2f7630294379123bbfcc5c202.png" data-original-src="https://miro.medium.com/v2/resize:fit:832/format:webp/1*KU3fbOND7FpocUFE0mLGLA.png"/></div></figure><p id="ee6f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">Chrome是谷歌推出的一款非常棒的浏览器，速度非常快，重量轻，但功能也非常强大。Chrome还有一个非常好的扩展性模型，允许开发人员只需要HTML、CSS和JavaScript技能就可以创建强大的扩展。</p><p id="2c70" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我将向您展示如何将我们自己的JavaScript和CSS注入到现有页面中，以增强其功能。</p><h1 id="a98c" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">目录</h1><ol class=""><li id="1654" class="lq lr iq jw b jx ls kb lt kf lu kj lv kn lw kr lx ly lz ma bi translated"><a class="ae mb" href="https://medium.com/p/137650de1f39#e3f1" rel="noopener">创建和设置React应用</a></li><li id="5ec2" class="lq lr iq jw b jx mc kb md kf me kj mf kn mg kr lx ly lz ma bi translated"><a class="ae mb" href="https://medium.com/p/137650de1f39#6021" rel="noopener">给Chrome添加React应用扩展</a></li><li id="949f" class="lq lr iq jw b jx mc kb md kf me kj mf kn mg kr lx ly lz ma bi translated"><a class="ae mb" href="https://medium.com/p/137650de1f39#3996" rel="noopener">将React应用作为内容脚本注入页面</a></li><li id="98e2" class="lq lr iq jw b jx mc kb md kf me kj mf kn mg kr lx ly lz ma bi translated"><a class="ae mb" href="https://medium.com/p/137650de1f39#1440" rel="noopener">如何利用Chrome消息API </a></li><li id="e1fc" class="lq lr iq jw b jx mc kb md kf me kj mf kn mg kr lx ly lz ma bi translated"><a class="ae mb" href="https://medium.com/p/137650de1f39#6186" rel="noopener">使用Iframe隔离扩展CSS</a></li><li id="0b1f" class="lq lr iq jw b jx mc kb md kf me kj mf kn mg kr lx ly lz ma bi translated"><a class="ae mb" href="https://medium.com/p/137650de1f39#c659" rel="noopener">路由内线react分机</a></li><li id="ac9f" class="lq lr iq jw b jx mc kb md kf me kj mf kn mg kr lx ly lz ma bi translated"><a class="ae mb" href="https://medium.com/p/137650de1f39#98ad" rel="noopener">快速入门Github回购</a></li><li id="d483" class="lq lr iq jw b jx mc kb md kf me kj mf kn mg kr lx ly lz ma bi translated"><a class="ae mb" href="https://github.com/satendra02/react-chrome-extension/issues/2" rel="noopener ugc nofollow" target="_blank">使扩展与Create React App v2.x兼容</a></li></ol><h1 id="e3f1" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">创建和设置React应用程序</h1><p id="8faf" class="pw-post-body-paragraph ju jv iq jw b jx ls jz ka kb lt kd ke kf mh kh ki kj mi kl km kn mj kp kq kr ij bi translated">在命令行中，转到您的工作区目录并运行<code class="fe mk ml mm mn b">npx create-react-app my-extension</code>。这将建立一个名为<code class="fe mk ml mm mn b">my-extension</code>的示例React应用程序，其中内置了所有构建步骤。</p><p id="5266" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">一旦创建了基本的react应用程序，转到<code class="fe mk ml mm mn b">my-extension</code>目录并运行<code class="fe mk ml mm mn b">yarn start</code>以确保应用程序工作正常。如果一切正常，您将看到一个浏览器页面，加载了React应用程序。</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi mo"><img src="../Images/830bae174af2519870f731dbacecd297.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zk0r2FlB_JBdrKTCwgNQuw.png"/></div></div></figure><h2 id="41f2" class="mx kt iq bd ku my mz dn ky na nb dp lc kf nc nd lg kj ne nf lk kn ng nh lo ni bi translated">设置react应用程序以用作扩展</h2><p id="bcb1" class="pw-post-body-paragraph ju jv iq jw b jx ls jz ka kb lt kd ke kf mh kh ki kj mi kl km kn mj kp kq kr ij bi translated">我们的<code class="fe mk ml mm mn b">create-react-app</code>有<code class="fe mk ml mm mn b">manifest.json</code>。我们只需要在里面增加一些细节，让它兼容Chrome的<code class="fe mk ml mm mn b">manifest.json</code>。打开文件<code class="fe mk ml mm mn b">[PROJECT_HOME]/public/manifest.json</code>并用下面的代码替换它。</p><pre class="mp mq mr ms gt nj mn nk nl aw nm bi"><span id="019b" class="mx kt iq mn b gy nn no l np nq">{<br/>    <!-- -->"name": "My Extension",<br/>    <!-- -->"version": "1.0",<br/>    "manifest_version": 2,<br/>    "browser_action": {<br/>        "default_popup": "index.html"<br/>    },<br/>    <!-- -->"content_security_policy": "script-src 'self' 'sha256-GgRxrVOKNdB4LrRsVPDSbzvfdV4UqglmviH9GoBJ5jk='; object-src 'self'"<br/>}</span></pre><h1 id="6021" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">向Chrome添加React应用扩展</h1><p id="cda3" class="pw-post-body-paragraph ju jv iq jw b jx ls jz ka kb lt kd ke kf mh kh ki kj mi kl km kn mj kp kq kr ij bi translated">让React app作为Chrome的扩展。像平常用<code class="fe mk ml mm mn b">yarn build</code>构建react应用一样构建这个应用。这会生成应用程序并将文件放在<code class="fe mk ml mm mn b">[PROJECT_HOME]/build</code>中。</p><p id="c489" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在Chrome浏览器中，进入<code class="fe mk ml mm mn b">chrome://extensions</code>页面，打开<em class="nr">开发者模式</em>。这使得能够在本地安装Chrome扩展。</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi ns"><img src="../Images/555b6167125d2a19199b1bad4391d13e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OaygCwLSwLakyTqCADbmDw.png"/></div></div></figure><p id="578b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在点击<code class="fe mk ml mm mn b">LOAD UNPACKED</code>并浏览到<code class="fe mk ml mm mn b">[PROJECT_HOME]/build</code>，这将安装React应用作为Chrome扩展。</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi nt"><img src="../Images/d69f13979e90b943ebedf088849c200c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kA5czD5o5PQGtuiDRO89hQ.png"/></div></div></figure><p id="c672" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">当您单击扩展图标时，您将看到React应用程序，呈现为一个扩展弹出窗口。</p><h1 id="3996" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">将React应用程序作为内容脚本注入页面</h1><p id="51a0" class="pw-post-body-paragraph ju jv iq jw b jx ls jz ka kb lt kd ke kf mh kh ki kj mi kl km kn mj kp kq kr ij bi translated">Chrome extension使用<code class="fe mk ml mm mn b">content_scripts</code>在<code class="fe mk ml mm mn b">manifest.json</code>中提到一个JS和CSS文件，需要注入到底层页面中。那么这个脚本将可以访问页面DOM。</p><blockquote class="nu nv nw"><p id="6c21" class="ju jv nr jw b jx jy jz ka kb kc kd ke nx kg kh ki ny kk kl km nz ko kp kq kr ij bi translated">我们的<code class="fe mk ml mm mn b">create-react-app</code>的问题是，构建步骤每次都会以不同的名称生成输出JS文件(如果内容发生了变化)。所以我们没有办法知道JS文件的实际文件名，因此我们不能在我们的<code class="fe mk ml mm mn b">manifest.json</code>文件中提到它。</p></blockquote><p id="2c5e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">作为一种变通方法，您可以直接退出<code class="fe mk ml mm mn b">create-react-app</code>，手动修改webpack配置，为内容脚本创建一个单独的入口点。</p><h2 id="b326" class="mx kt iq bd ku my mz dn ky na nb dp lc kf nc nd lg kj ne nf lk kn ng nh lo ni bi translated">弹出create-react-app并配置内容脚本</h2><p id="a3b4" class="pw-post-body-paragraph ju jv iq jw b jx ls jz ka kb lt kd ke kf mh kh ki kj mi kl km kn mj kp kq kr ij bi translated"><a class="ae mb" href="https://github.com/satendra02/react-chrome-extension/wiki/What-happens-when-you-eject-Create-React-App" rel="noopener ugc nofollow" target="_blank">弹出<strong class="jw ir">创建-反应-app</strong>T22】会发生什么</a></p><p id="2029" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">首先，在命令行上运行<code class="fe mk ml mm mn b">yarn run eject</code>。这将弹出<code class="fe mk ml mm mn b">create-react-app</code>，然后在你的项目文件夹中创建所有必要的构建脚本。</p><p id="3cd2" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在运行<code class="fe mk ml mm mn b">yarn install</code>来安装所有的依赖项</p><p id="837b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">退出完成后，转到<code class="fe mk ml mm mn b">[PROJECT_HOME]/config/webpack.config.prod.js</code>文件，并在其中进行以下更改:</p><p id="b04d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">将选项<code class="fe mk ml mm mn b">entry</code>更改为具有多个入口点。这里，我们的内容脚本将被命名为<code class="fe mk ml mm mn b">content.js</code></p><pre class="mp mq mr ms gt nj mn nk nl aw nm bi"><span id="e744" class="mx kt iq mn b gy nn no l np nq">entry: {<br/>    <strong class="mn ir">app</strong>: [require.resolve('./polyfills'), paths.appIndexJs],<br/>    <strong class="mn ir">content</strong>: [require.resolve('./polyfills'), './src/content.js']<br/>},</span></pre><div class="oa ob gp gr oc od"><a href="https://github.com/satendra02/react-chrome-extension/issues/2" rel="noopener  ugc nofollow" target="_blank"><div class="oe ab fo"><div class="of ab og cl cj oh"><h2 class="bd ir gy z fp oi fr fs oj fu fw ip bi translated">使扩展与Create React App v2 . x Issue # 2 satendra 02/React-chrome-extension兼容</h2><div class="ok l"><h3 class="bd b gy z fp oi fr fs oj fu fw dk translated">错误:找不到模块“”。/polyfills '运行纱线运行弹出后</h3></div><div class="ol l"><p class="bd b dl z fp oi fr fs oj fu fw dk translated">github.com</p></div></div></div></a></div><p id="043c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">同样，搜索<code class="fe mk ml mm mn b">.[contenthash:8]</code>、<code class="fe mk ml mm mn b">.[chunkhash:8]</code>并将其从CSS和JS输出文件名中删除。这将确保生成的文件中没有随机散列，因此我们可以在清单JSON中提到文件名。</p><p id="7c84" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在<code class="fe mk ml mm mn b">webpack.config.prod.js</code>文件中完成上述更改后，现在是创建内容脚本文件的时候了。在<code class="fe mk ml mm mn b">src</code>文件夹中创建一个名为<code class="fe mk ml mm mn b">content.js</code>和<code class="fe mk ml mm mn b">content.css</code>的文件。</p><pre class="mp mq mr ms gt nj mn nk nl aw nm bi"><span id="bcb7" class="mx kt iq mn b gy nn no l np nq"><em class="nr">/* src/content.js */</em><br/><strong class="mn ir">import</strong> React from 'react';<br/><strong class="mn ir">import</strong> ReactDOM from 'react-dom';<br/><strong class="mn ir">import</strong> "./content.css";<br/><br/><strong class="mn ir">class</strong> Main <strong class="mn ir">extends</strong> React.Component {<br/>    render() {<br/>        <strong class="mn ir">return</strong> (<br/>            <strong class="mn ir">&lt;</strong>div className<strong class="mn ir">=</strong>{'my-extension'}<strong class="mn ir">&gt;</strong><br/>                &lt;h1&gt;Hello world - My first Extension<strong class="mn ir">&lt;</strong>/h1&gt;<br/>            <strong class="mn ir">&lt;</strong>/div&gt;<br/>        )<br/>    }<br/>}<br/><br/><strong class="mn ir">const</strong> app <strong class="mn ir">=</strong> document.createElement('div');<br/>app.id = "my-extension-root";</span><span id="585f" class="mx kt iq mn b gy om no l np nq">document.body.appendChild(app);<br/>ReactDOM.render(<strong class="mn ir">&lt;</strong>Main <strong class="mn ir">/&gt;</strong>, app);</span></pre></div><div class="ab cl on oo hu op" role="separator"><span class="oq bw bk or os ot"/><span class="oq bw bk or os ot"/><span class="oq bw bk or os"/></div><div class="ij ik il im in"><pre class="nj mn nk nl aw nm bi"><span id="19ce" class="mx kt iq mn b gy ou ov ow ox oy no l np nq"><em class="nr">/* src/content.css */</em></span><span id="ead6" class="mx kt iq mn b gy om no l np nq"><strong class="mn ir">.my-extension</strong> {<br/>   padding: 20px;<br/>}<br/><strong class="mn ir">.my-extension h1 </strong>{<br/>    <strong class="mn ir">color</strong>: #<!-- -->000<!-- -->;<br/>}</span></pre><p id="4204" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">并将下面的CSS添加到<code class="fe mk ml mm mn b">index.css</code>，我将在后面解释为什么我们将两个CSS保存在单独的文件中。</p><pre class="mp mq mr ms gt nj mn nk nl aw nm bi"><span id="a6f0" class="mx kt iq mn b gy nn no l np nq"><em class="nr">/* src/index.css */</em></span><span id="cbcd" class="mx kt iq mn b gy om no l np nq"><strong class="mn ir">#my-extension-root</strong> {<br/>    <strong class="mn ir">width</strong>: 400px;<br/>    <strong class="mn ir">height</strong>: 100%;<br/>    <strong class="mn ir">position:</strong> fixed;<br/>    <strong class="mn ir">top:</strong> 0px;<br/>    <strong class="mn ir">right:</strong> 0px;<br/>    <strong class="mn ir">z-index:</strong> 2147483647;<br/>    <strong class="mn ir">background-color:</strong> white;<br/>    <strong class="mn ir">box-shadow:</strong> 0px 0px 5px #0000009e;<br/>}</span></pre><p id="92f4" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在我们已经配置了React构建管道并创建了内容脚本，让我们更新<code class="fe mk ml mm mn b">manifest.json</code>来获取这些文件。将以下代码添加到<code class="fe mk ml mm mn b">manifest.json</code>文件中。</p><pre class="mp mq mr ms gt nj mn nk nl aw nm bi"><span id="66bb" class="mx kt iq mn b gy nn no l np nq">"content_scripts" : [<br/>    {<br/>      "matches": [<!-- --> "&lt;all_urls&gt;" <!-- -->],<br/>      "css": [<!-- -->"/static/css/app.css", <!-- -->"/static/css/content.css"],<br/>      "js": ["/static/js/content.js"]<br/>    }<br/>]</span></pre><div class="oa ob gp gr oc od"><a href="https://github.com/satendra02/react-chrome-extension/issues/2" rel="noopener  ugc nofollow" target="_blank"><div class="oe ab fo"><div class="of ab og cl cj oh"><h2 class="bd ir gy z fp oi fr fs oj fu fw ip bi translated">使扩展与Create React App v2 . x Issue # 2 satendra 02/React-chrome-extension兼容</h2><div class="ok l"><h3 class="bd b gy z fp oi fr fs oj fu fw dk translated">错误:找不到模块“”。/polyfills '运行纱线运行弹出后</h3></div><div class="ol l"><p class="bd b dl z fp oi fr fs oj fu fw dk translated">github.com</p></div></div></div></a></div><p id="0887" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在构建你的应用，进入<code class="fe mk ml mm mn b">chrome://extensions</code>并重新加载扩展，当你进入任何网站并刷新它时，你可以看到我们的扩展在那里注入。</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi oz"><img src="../Images/78370ee7ae12b2b7893ca16377fa2f52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bXJYfvrcHDWKwUZCrPI-8w.png"/></div></div></figure><blockquote class="nu nv nw"><p id="509d" class="ju jv nr jw b jx jy jz ka kb kc kd ke nx kg kh ki ny kk kl km nz ko kp kq kr ij bi translated">现在，在这个阶段，当你点击扩展图标时，你可以看到一个弹出窗口也将出现，该窗口包含页面上注入的相同组件，但是可接受的行为应该是，在点击扩展图标时，注入的页面必须表现为弹出窗口(点击时切换)</p></blockquote><p id="be29" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">为此，我们不得不使用<code class="fe mk ml mm mn b">Chrome messaging API</code></p><h1 id="1440" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">如何利用Chrome消息API</h1><p id="b767" class="pw-post-body-paragraph ju jv iq jw b jx ls jz ka kb lt kd ke kf mh kh ki kj mi kl km kn mj kp kq kr ij bi translated">为了访问chrome API，我们需要在<code class="fe mk ml mm mn b">[PROJECT_HOME/public/app/background.js</code>中添加<a class="ae mb" href="https://developer.chrome.com/extensions/background_pages" rel="noopener ugc nofollow" target="_blank">后台脚本</a>，并添加以下代码。</p><pre class="mp mq mr ms gt nj mn nk nl aw nm bi"><span id="d7a2" class="mx kt iq mn b gy nn no l np nq"><em class="nr">// Called when the user clicks on the browser action<br/></em>chrome.browserAction.onClicked.<strong class="mn ir">addListener</strong>(function(tab) {<br/>   <em class="nr">// Send a message to the active tab<br/>   </em>chrome.tabs.<strong class="mn ir">query</strong>({active: true, currentWindow:true},<br/>      function(tabs) {<br/>         var activeTab = tabs[0];<br/>         chrome.tabs.<strong class="mn ir">sendMessage</strong>(activeTab.id, <br/>             {"message": "clicked_browser_action"}<br/>         );<br/>   });<br/>});</span></pre><p id="0b36" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">该代码将在点击扩展图标时执行，它将找到当前选项卡，并使用chrome选项卡的<a class="ae mb" href="https://developer.chrome.com/extensions/tabs#method-sendMessage" rel="noopener ugc nofollow" target="_blank"><strong class="jw ir">sendMessage</strong></a><strong class="jw ir"/>API在该选项卡内广播消息。</p><p id="d2af" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">将<code class="fe mk ml mm mn b">background</code>条目添加到<code class="fe mk ml mm mn b">public/manifest.json</code></p><pre class="mp mq mr ms gt nj mn nk nl aw nm bi"><span id="b872" class="mx kt iq mn b gy nn no l np nq">"background": {<br/>    "scripts": ["app/background.js"]<br/>}</span></pre><p id="06cc" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">并从<code class="fe mk ml mm mn b">browser_action</code>上取下<code class="fe mk ml mm mn b">default_popup</code>键</p><blockquote class="nu nv nw"><p id="1cb6" class="ju jv nr jw b jx jy jz ka kb kc kd ke nx kg kh ki ny kk kl km nz ko kp kq kr ij bi translated"><strong class="jw ir">注意:</strong>不要去掉<code class="fe mk ml mm mn b">browser_action</code>键，保持空白否则扩展图标点击不起作用</p></blockquote><pre class="mp mq mr ms gt nj mn nk nl aw nm bi"><span id="f98e" class="mx kt iq mn b gy nn no l np nq">"browser_action": {}</span></pre><p id="6d23" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在我们需要创建一个接收器，它将接收单击浏览器操作的消息。将以下代码添加到<code class="fe mk ml mm mn b">src/content.js</code>文件</p><pre class="mp mq mr ms gt nj mn nk nl aw nm bi"><span id="0941" class="mx kt iq mn b gy nn no l np nq">app.style.display = "none";</span><span id="dc0a" class="mx kt iq mn b gy om no l np nq">chrome.runtime.onMessage.<strong class="mn ir">addListener</strong>(<br/>   function(request, sender, sendResponse) {<br/>      if( request.message === "clicked_browser_action") {<br/>        <strong class="mn ir">toggle</strong>();<br/>      }<br/>   }<br/>);</span><span id="cb03" class="mx kt iq mn b gy om no l np nq">function <strong class="mn ir">toggle</strong>(){<br/>   if(app.style.display === "none"){<br/>     app.style.display = "block";<br/>   }else{<br/>     app.style.display = "none";<br/>   }<br/>}</span></pre><blockquote class="nu nv nw"><p id="f51a" class="ju jv nr jw b jx jy jz ka kb kc kd ke nx kg kh ki ny kk kl km nz ko kp kq kr ij bi translated"><strong class="jw ir">注意:</strong>不要忘记在React组件的顶部添加<code class="fe mk ml mm mn b">/*global chrome*/</code>，这样构建才会成功</p></blockquote><p id="f939" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在构建你的应用程序，进入<code class="fe mk ml mm mn b">chrome://extensions</code>并重新加载扩展，当你进入任何网站并刷新它时，点击扩展图标，注入的页面将会切换</p><h1 id="6186" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">使用iframe隔离扩展CSS</h1><p id="36d0" class="pw-post-body-paragraph ju jv iq jw b jx ls jz ka kb lt kd ke kf mh kh ki kj mi kl km kn mj kp kq kr ij bi translated">当你开始为你的组件编写样式时，你会发现CSS在一些网站上完全失效了。所以为了保持CSS的隔离，我相信今天最好的解决方案是iframe，iframe中的所有东西都将在一个隔离的环境中运行。</p><p id="4526" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">为此，我使用了<a class="ae mb" href="https://github.com/ryanseddon/react-frame-component" rel="noopener ugc nofollow" target="_blank"> <strong class="jw ir">反应帧组件</strong> </a></p><div class="oa ob gp gr oc od"><a href="https://github.com/ryanseddon/react-frame-component" rel="noopener  ugc nofollow" target="_blank"><div class="oe ab fo"><div class="of ab og cl cj oh"><h2 class="bd ir gy z fp oi fr fs oj fu fw ip bi translated">ryanseddon/react-frame-组件</h2><div class="ok l"><h3 class="bd b gy z fp oi fr fs oj fu fw dk translated">react-frame-component -将react应用程序渲染为iFrame</h3></div><div class="ol l"><p class="bd b dl z fp oi fr fs oj fu fw dk translated">github.com</p></div></div><div class="pa l"><div class="pb l pc pd pe pa pf js od"/></div></div></a></div><p id="ab64" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">使用<code class="fe mk ml mm mn b">yarn add</code>安装<strong class="jw ir">反应框架组件</strong></p><pre class="mp mq mr ms gt nj mn nk nl aw nm bi"><span id="9c48" class="mx kt iq mn b gy nn no l np nq">yarn add react-frame-component</span></pre><p id="f292" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在使用<code class="fe mk ml mm mn b">Frame</code>组件来包装你的<code class="fe mk ml mm mn b">Main</code>组件。</p><pre class="mp mq mr ms gt nj mn nk nl aw nm bi"><span id="73fb" class="mx kt iq mn b gy nn no l np nq">/*global chrome*/<br/><em class="nr">/* src/content.js */</em></span><span id="315a" class="mx kt iq mn b gy om no l np nq"><strong class="mn ir">import</strong> React from 'react';<br/><strong class="mn ir">import</strong> ReactDOM from 'react-dom';<br/><strong class="mn ir">import</strong> Frame, { FrameContextConsumer }from 'react-frame-component';<br/><strong class="mn ir">import</strong> "./content.css";</span><span id="67e8" class="mx kt iq mn b gy om no l np nq"><strong class="mn ir">class</strong> Main <strong class="mn ir">extends</strong> React.Component {<br/>    render() {<br/>        <strong class="mn ir">return</strong> (<br/>            <!-- -->&lt;<strong class="mn ir">Frame</strong> <em class="nr">head</em>={[&lt;link <em class="nr">type</em>="text/css" <em class="nr">rel</em>="stylesheet" <em class="nr">href</em>={chrome.runtime.<strong class="mn ir">getURL</strong>("/static/css/content.css")} &gt;&lt;/link&gt;]}&gt; </span><span id="f950" class="mx kt iq mn b gy om no l np nq">              &lt;<strong class="mn ir">FrameContextConsumer</strong>&gt;<br/>               {<br/>               <em class="nr">// Callback is invoked with iframe's window and document instances<br/>                   </em>({document, window}) =&gt; {<br/>                      <em class="nr">// Render Children<br/>                      </em><strong class="mn ir">return </strong>(<strong class="mn ir"><br/>                         &lt;</strong>div className<strong class="mn ir">=</strong>{'my-extension'}<strong class="mn ir">&gt;<br/>                            </strong>&lt;h1&gt;Hello world - My first Extension<strong class="mn ir">&lt;</strong>/h1&gt;<br/>                         <strong class="mn ir">&lt;</strong>/div&gt;<br/>                      )<br/>                   <!-- -->}<br/>                }<br/>               &lt;/<strong class="mn ir">FrameContextConsumer</strong>&gt;<br/>            &lt;/<strong class="mn ir">Frame</strong>&gt;<br/>        <!-- -->)<br/>    }<br/>}</span></pre><blockquote class="nu nv nw"><p id="b13a" class="ju jv nr jw b jx jy jz ka kb kc kd ke nx kg kh ki ny kk kl km nz ko kp kq kr ij bi translated"><strong class="jw ir">注意:</strong>如果你想使用iframe文档或者窗口你可以使用<strong class="jw ir"> FrameContextConsumer </strong>，你可以把它作为道具传递给子组件，如果不清楚可以在评论里问我。</p></blockquote><p id="9e6c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在上面的代码中你可以看到我使用了<a class="ae mb" href="https://developer.chrome.com/extensions/runtime#method-getURL" rel="noopener ugc nofollow" target="_blank"><strong class="jw ir">getURL</strong></a><strong class="jw ir"/>chrome API，将<code class="fe mk ml mm mn b">content.css </code>添加到iframe文档的<code class="fe mk ml mm mn b">head</code>中，这样就不会影响到主页面CSS。</p><p id="7968" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">为了让getURL chrome API工作，我们需要在我们的<code class="fe mk ml mm mn b">manifest.json</code>中的<code class="fe mk ml mm mn b">web_accessible_resources</code>键下添加<code class="fe mk ml mm mn b">content.css</code>，并将其从<code class="fe mk ml mm mn b">content_scripts</code>键中移除。</p><pre class="mp mq mr ms gt nj mn nk nl aw nm bi"><span id="b942" class="mx kt iq mn b gy nn no l np nq">"content_scripts" : [{<br/>    "matches": [ "&lt;all_urls&gt;" ],<br/>    "css": ["/static/css/app.css"],<br/>    "js": ["/static/js/content.js"]<br/>  }<br/>],<br/>"web_accessible_resources":[<br/>   "/static/css/content.css"<br/>]</span></pre><p id="c2b6" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们需要定义iframe的<code class="fe mk ml mm mn b">height</code>和<code class="fe mk ml mm mn b">width</code>，否则，它将不可见，添加在<code class="fe mk ml mm mn b">index.css</code>中的CSS下面</p><pre class="mp mq mr ms gt nj mn nk nl aw nm bi"><span id="615c" class="mx kt iq mn b gy nn no l np nq">#my-extension-root iframe {<br/>  <!-- -->width: 100%;<br/>  height: 100%;<br/>  border: none;<br/>}</span></pre><blockquote class="nu nv nw"><p id="cea2" class="ju jv nr jw b jx jy jz ka kb kc kd ke nx kg kh ki ny kk kl km nz ko kp kq kr ij bi translated">我们保留了两个独立的文件<code class="fe mk ml mm mn b">index.css</code>将被编译为<code class="fe mk ml mm mn b">app.css</code>，用于在iframe之外的HTML元素上应用样式，而<code class="fe mk ml mm mn b">content.css</code>将被编译为<code class="fe mk ml mm mn b">content.css</code>，用于在iframe之内的元素上应用样式，以防止css泄漏到主页面</p></blockquote><p id="357b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在构建你的应用，进入<code class="fe mk ml mm mn b">chrome://extensions</code>并重新加载扩展，当你进入任何网站并刷新它。React组件在iframe中呈现。</p><h1 id="c659" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">react扩展内的路由</h1><p id="0a68" class="pw-post-body-paragraph ju jv iq jw b jx ls jz ka kb lt kd ke kf mh kh ki kj mi kl km kn mj kp kq kr ij bi translated">如果你有两个以上的子组件，你必须要求在它们之间导航，但是使用<strong class="jw ir"> react-router </strong>有点冒险，这种方法有一些问题。</p><ol class=""><li id="e235" class="lq lr iq jw b jx jy kb kc kf pg kj ph kn pi kr lx ly lz ma bi translated">当您在组件之间导航时，组件路由将对主机页面地址栏可见，如果您重新加载它，将会破坏主机页面，因此这是不可接受的。</li><li id="f04e" class="lq lr iq jw b jx mc kb md kf me kj mf kn mg kr lx ly lz ma bi translated">可以找<code class="fe mk ml mm mn b">hashLocationStrategy</code>，但是那样的话，主机页面浏览器后退按钮会受到影响。</li></ol><p id="ec6a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">因此，解决方案必须是提供基于堆栈的路由器，允许通过推入和弹出路由器状态进行基本导航，为此有<a class="ae mb" href="https://github.com/Scout-NU/route-lite" rel="noopener ugc nofollow" target="_blank"><strong class="jw ir">route-lite</strong></a><strong class="jw ir"/>包。</p><div class="oa ob gp gr oc od"><a href="https://github.com/Scout-NU/route-lite" rel="noopener  ugc nofollow" target="_blank"><div class="oe ab fo"><div class="of ab og cl cj oh"><h2 class="bd ir gy z fp oi fr fs oj fu fw ip bi translated">Scout-NU/route-lite</h2><div class="ok l"><h3 class="bd b gy z fp oi fr fs oj fu fw dk translated">route-lite——一个轻量级的、无URL的路由器，用于Chrome扩展或电子应用中的React应用</h3></div><div class="ol l"><p class="bd b dl z fp oi fr fs oj fu fw dk translated">github.com</p></div></div><div class="pa l"><div class="pj l pc pd pe pa pf js od"/></div></div></a></div><blockquote class="nu nv nw"><p id="ff26" class="ju jv nr jw b jx jy jz ka kb kc kd ke nx kg kh ki ny kk kl km nz ko kp kq kr ij bi translated">我不会在这个博客中讨论它的实现，但是如果你有任何疑问，你可以在评论中问我。</p></blockquote><h1 id="98ad" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">克隆git repo以快速启动</h1><div class="oa ob gp gr oc od"><a href="https://github.com/satendra02/react-chrome-extension" rel="noopener  ugc nofollow" target="_blank"><div class="oe ab fo"><div class="of ab og cl cj oh"><h2 class="bd ir gy z fp oi fr fs oj fu fw ip bi translated">satendra 02/react-chrome-extension</h2><div class="ok l"><h3 class="bd b gy z fp oi fr fs oj fu fw dk translated">ReactJs使用注入页面策略的chrome扩展样板文件</h3></div><div class="ol l"><p class="bd b dl z fp oi fr fs oj fu fw dk translated">github.com</p></div></div><div class="pa l"><div class="pk l pc pd pe pa pf js od"/></div></div></a></div><h1 id="9ded" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">重要说明</h1><p id="5b59" class="pw-post-body-paragraph ju jv iq jw b jx ls jz ka kb lt kd ke kf mh kh ki kj mi kl km kn mj kp kq kr ij bi translated">如果你有任何关于实现的问题，不要忘记查看下面的评论和<a class="ae mb" href="https://github.com/satendra02/react-chrome-extension/issues" rel="noopener ugc nofollow" target="_blank"> Github问题</a>部分，也许我已经回答了你的问题。</p><p id="93a0" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">(帮助其他人找到我在Medium上的文章👏🏽下面。)</p></div></div>    
</body>
</html>