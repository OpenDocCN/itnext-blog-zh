<html>
<head>
<title>How to Write Better Unit Tests in Go Using Mocks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用模拟在Go中编写更好的单元测试</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-write-better-unit-tests-in-go-using-mocks-4dd05e867b17?source=collection_archive---------1-----------------------#2018-04-23">https://itnext.io/how-to-write-better-unit-tests-in-go-using-mocks-4dd05e867b17?source=collection_archive---------1-----------------------#2018-04-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="af3e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最近，作为我对<a class="ae kl" href="https://www.cloudfoundry.org/" rel="noopener ugc nofollow" target="_blank">Cloud Foundry</a><a class="ae kl" href="https://github.com/petergtz/bitsgo" rel="noopener ugc nofollow" target="_blank">Bits-Service</a>的Go重新实现工作的一部分，我实现了一个特性，它要求一组动作以正确的顺序执行。这样的一组动作也被称为<em class="km">协议</em>。</p><p id="0b16" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我的案例中，协议是这样的:</p><ol class=""><li id="f429" class="kn ko iq jp b jq jr ju jv jy kp kc kq kg kr kk ks kt ku kv bi translated">针对<code class="fe kw kx ky kz b">Bits-Service</code>发出文件上传请求</li><li id="30e3" class="kn ko iq jp b jq la ju lb jy lc kc ld kg le kk ks kt ku kv bi translated"><code class="fe kw kx ky kz b">Bits-Service</code>告诉<code class="fe kw kx ky kz b">Cloud Controller</code>现在是<code class="fe kw kx ky kz b">PROCESSING_UPLOAD</code>文件时间。</li><li id="1005" class="kn ko iq jp b jq la ju lb jy lc kc ld kg le kk ks kt ku kv bi translated"><code class="fe kw kx ky kz b">Bits-Service</code>上传文件给一个<code class="fe kw kx ky kz b">Blobstore</code>(比如S3)。</li><li id="2acb" class="kn ko iq jp b jq la ju lb jy lc kc ld kg le kk ks kt ku kv bi translated"><code class="fe kw kx ky kz b">Bits-Service</code>告知<code class="fe kw kx ky kz b">Cloud Controller</code>(a)<code class="fe kw kx ky kz b">FAILED</code>或(b)文件上传成功，文件<code class="fe kw kx ky kz b">READY</code>可以使用。</li></ol><p id="48f5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于这些调用中的任何一个都可能返回一个错误，在这种情况下，操作集会发生变化，所以我想对Bits服务与其两个合作者的交互进行单元测试，以确保这一点完全正确。两个协作者<code class="fe kw kx ky kz b">Cloud Controller</code>和<code class="fe kw kx ky kz b">Blobstore</code>已经分别被定义为接口<code class="fe kw kx ky kz b">Updater</code>和<code class="fe kw kx ky kz b">Blobstore</code>。尽管如此，为协议创建模拟并不简单，因为模拟的调用顺序很重要。</p><p id="3eee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用特别的、手工编写的模拟是可能的；他们可以共用一个计数器来跟踪呼叫顺序等。但是让他们的内部行为正确并不简单，并且需要它自己的单元测试集。仅仅编写一个简单的单元测试就要做很多额外的工作。</p><p id="4452" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">幸运的是，有<a class="ae kl" href="https://github.com/petergtz/pegomock" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> Pegomock </strong> </a>，一个极好的模仿围棋的框架。我要做的就是:</p><pre class="lf lg lh li gt lj kz lk ll aw lm bi"><span id="a7bf" class="ln lo iq kz b gy lp lq l lr ls">$ pegomock generate Blobstore <br/>$ pegomock generate Updater</span></pre><p id="423f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后单元测试代码看起来微不足道:</p><figure class="lf lg lh li gt lt"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="8f4c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">真的就这么简单。</p><p id="0895" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我们在做这件事的时候，当然Pegomock不仅仅适用于这个特定的用例。事实上，它对于<em class="km">所有</em>种嘲讽用例都是极好的。想存根一些电话簿一样的界面？方法如下:</p><figure class="lf lg lh li gt lt"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="5119" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以使用匹配器始终返回相同的值:</p><pre class="lf lg lh li gt lj kz lk ll aw lm bi"><span id="ea59" class="ln lo iq kz b gy lp lq l lr ls"><strong class="kz ir">When</strong>(phoneBook.<strong class="kz ir">GetPhoneNumber</strong>(<strong class="kz ir">AnyString</strong>())).<strong class="kz ir">ThenReturn</strong>("123-456")</span></pre><p id="880a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">或者，如果您需要更复杂的东西，您甚至可以实现自己的存根函数:</p><figure class="lf lg lh li gt lt"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="104a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">需要恐慌？这是:</p><pre class="lf lg lh li gt lj kz lk ll aw lm bi"><span id="4fa1" class="ln lo iq kz b gy lp lq l lr ls"><strong class="kz ir">When</strong>(phoneBook.<strong class="kz ir">GetPhoneNumber</strong>("Unknown")).<strong class="kz ir">ThenPanic</strong>("Invalid name")</span></pre><p id="0b92" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，当您需要将存根和验证结合起来时，Pegomock的真正魅力就显现出来了，因为您为两者使用了相同类型的匹配器，所以感觉非常自然。当您在它们之间切换时，您甚至不会注意到，除了您的测试看起来非常干净:</p><figure class="lf lg lh li gt lt"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="1c46" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下次你需要一个模仿围棋的框架时，为什么不试试Pegomock呢？<a class="ae kl" href="https://github.com/petergtz/pegomock#getting-pegomock" rel="noopener ugc nofollow" target="_blank">只是</a> <code class="fe kw kx ky kz b"><a class="ae kl" href="https://github.com/petergtz/pegomock#getting-pegomock" rel="noopener ugc nofollow" target="_blank">go get</a></code> <a class="ae kl" href="https://github.com/petergtz/pegomock#getting-pegomock" rel="noopener ugc nofollow" target="_blank">它</a>。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><p id="8bdd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="km">顺便说一下，Cloud Foundry Bits-Service的Go重新实现正在德国的IBM-Lab Boeblingen开发，我们通常在#bits-service </em>  <em class="km">中的</em><a class="ae kl" href="https://cloudfoundry.slack.com/messages/C0BNGJY0G" rel="noopener ugc nofollow" target="_blank"><em class="km">cloudfoundry.slack.com上闲逛。来和我们聊聊吧！</em></a></p></div></div>    
</body>
</html>