<html>
<head>
<title>Default Interface Methods in C#</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C#中的默认接口方法</h1>
<blockquote>原文：<a href="https://itnext.io/default-interface-methods-in-c-df01dfa7b4e8?source=collection_archive---------0-----------------------#2020-05-01">https://itnext.io/default-interface-methods-in-c-df01dfa7b4e8?source=collection_archive---------0-----------------------#2020-05-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/e980eec0126044afff7365ceb9006683.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7Pffm_E-00L-RY6dtxRY2A.png"/></div></div></figure><p id="8631" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">c# 8允许开发人员为接口中的方法编写默认实现。我认为这个特性是一个高风险的语言特性，因为它很容易被误用，导致灾难性的代码质量。在本文中，我们将讨论该功能的正确使用。</p><p id="393d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们进入接口中的新特性方法实现之前，让我们快速了解一下接口的类型。</p><h1 id="2f0a" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated"><strong class="ak"> 1-表头接口</strong></h1><p id="3550" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">头文件接口类似于c++头文件，通常它是通过从一个类中提取所有方法并在一个接口中定义它而从该类中提取的，通常它用于允许开发人员提供替代实现。</p><p id="6f93" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">示例:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="b383" class="mi kx iq me b gy mj mk l ml mm">public interface IFileSystem<br/>{</span><span id="5bae" class="mi kx iq me b gy mn mk l ml mm">File CreateFile(string filename);<br/>void DeleteFile(string filename);<br/>File GetFile(string filename);<br/>}</span><span id="8ac3" class="mi kx iq me b gy mn mk l ml mm">public class WindowsFileSystem:IFileSystem{// windows impl}</span><span id="6f42" class="mi kx iq me b gy mn mk l ml mm">public class LinuxFileSystem:IFileSystem{// Linux impl}<br/></span></pre><p id="949b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这种情况下，IFileSystem接口只代表一个定义文件系统类实现应该提供什么的契约，并且看起来所有这些方法都将有一个非常定制的实现。</p><p id="8922" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是现在让我们引入一个名为GetOrCreateFile的新方法。这个方法简单地搜索一个文件是否存在并返回它，如果它不存在，它将创建一个新文件。</p><p id="24cd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以我们的新方法可以使用现有的接口方法来定义。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="0702" class="mi kx iq me b gy mj mk l ml mm">public File GetOrCreateFile(string filename)<br/>{<br/>    var file=GetFile(filename);<br/>    <br/>     if(file==null)<br/>       file=CreateFile(filename);<br/>    <br/>    return file;</span><span id="206a" class="mi kx iq me b gy mn mk l ml mm">}</span></pre><p id="a9e7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这种实现对所有文件系统都是有效的，因为它是抽象的，所以在这种情况下，我将在接口内部实现这种方法作为默认方法。</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="mo mp l"/></div></figure><h1 id="11cb" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">接口vs抽象类</h1><p id="ef5c" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">我确信现在人们会更多地问这个问题，因为默认的方法实现特性减少了两者之间的差异。</p><p id="327b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，让我们首先澄清一些事情，这个问题只对头文件接口有意义，因为任何像IFileSystem这样的头文件接口都可以用基类FileSystemBase替换。如果你考虑多重继承的问题，我可以明确地说</p><blockquote class="mq"><p id="ed93" class="mr ms iq bd mt mu mv mw mx my mz kv dk translated">“一个类不能有一个以上的标题接口，如果是这样的话，应该被认为是对单一责任原则的极端违反”</p></blockquote><blockquote class="na nb nc"><p id="8619" class="jy jz nd ka b kb ne kd ke kf nf kh ki ng nh kl km ni nj kp kq nk nl kt ku kv ij bi translated">请在#solid_principals标签下发布</p></blockquote><p id="6c53" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了快速解释为什么这个陈述是一个事实，单个责任意味着一个类应该只有一个改变的原因，并且在头接口存在的情况下，头接口将代表改变的高级原因，想想“IFileSystem，IMediaManger，IRepository，…”</p><p id="07cf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以回到我们的主要问题头接口vs抽象类。答案是受保护的和私有的，接口只是类的一个契约，它告诉消费者从类中期望什么，它不能拥有自己的状态，也不能强迫类自己拥有某种私有状态。</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="6c02" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">很清楚为什么在这种情况下FileSystemBase必须是一个基类，而不能是一个接口，因为GetFileCached句柄上的缓存拥有一个具体的实现。</p><h1 id="6949" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">双角色界面</h1><p id="9346" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">角色接口是创建接口的最佳方式，因为它遵循接口分离原则，与头文件接口相反，头文件接口是关于类可以提供的所有功能的契约，角色接口是关于类为了扮演某个角色应该实现哪些必需功能的契约。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="579b" class="mi kx iq me b gy mj mk l ml mm">public interface IFileWriter<br/>    {<br/>        File CreateFile(string filename);<br/>        void DeleteFile(string filename);<br/>    }</span><span id="567f" class="mi kx iq me b gy mn mk l ml mm">public interface IFileReader<br/>    {<br/>        File GetFile(string filename);<br/>        List&lt;File&gt; GetFiles();<br/>    }</span></pre><p id="4fd5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是一个如何将标题接口IFileSystem重构为角色接口IFileWriter和IFileReader的示例。</p><p id="677e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">只有IFileWriter和IFileReader而没有其他任何东西的原因是消费者代码，例如，我可能需要消费这个代码</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="f626" class="mi kx iq me b gy mj mk l ml mm">public class FilesListViewModel<br/>    {<br/>        public File Files { get; set; }</span><span id="c723" class="mi kx iq me b gy mn mk l ml mm">        public FilesListViewModel(IFileReader fileReader)<br/>        {<br/>            Files = fileReader.GetFiles();<br/>        }</span><span id="1d24" class="mi kx iq me b gy mn mk l ml mm">   }</span><span id="d12b" class="mi kx iq me b gy mn mk l ml mm">public class FileCreatorViewModel<br/>    {<br/>        private readonly IFileWriter _fileWriter;</span><span id="5d45" class="mi kx iq me b gy mn mk l ml mm">        public FileCreatorViewModel(IFileWriter fileWriter)<br/>        {<br/>            _fileWriter = fileWriter;</span><span id="8cbc" class="mi kx iq me b gy mn mk l ml mm">        }</span><span id="44fe" class="mi kx iq me b gy mn mk l ml mm">        public void CreateNewFile(string name)<br/>        {<br/>           <br/>           _fileWriter.CreateFile(name);<br/>        }<br/>    }</span></pre><p id="0eb6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我不能给你一个关于你应该如何设计你的代码的一般指导，但是我建议遵循CQRS原则，回到角色接口。如果角色接口是为了满足消费者的需求而创建的，就像前面例子中的“IFileWriter，IFileReader”或者mvvm模式中的ICommand，并且如果你来自java背景，你将熟悉回调接口。</p><p id="9eb9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">相比之下，对于Header接口，一个类可能需要实现多个角色接口，这就是著名的说法“多重继承问题是通过接口解决的”</p><blockquote class="mq"><p id="fcff" class="mr ms iq bd mt mu mv mw mx my mz kv dk translated">多重继承由接口解决，但它只应与角色接口一起使用</p></blockquote><blockquote class="na nb nc"><p id="ab3e" class="jy jz nd ka b kb ne kd ke kf nf kh ki ng nh kl km ni nj kp kq nk nl kt ku kv ij bi translated">请在#solid_principals标签下发布</p></blockquote><p id="6505" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">默认接口方法的使用方式与头文件接口相同，如</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="939d" class="mi kx iq me b gy mj mk l ml mm">public interface IFileWriter<br/>    {<br/>        File CreateFile(string filename);<br/>        void DeleteFile(string filename);</span><span id="b641" class="mi kx iq me b gy mn mk l ml mm">public File CreateNew(string filename)<br/>        {<br/>            DeleteFile(filename);<br/>            CreateFile(filename);<br/>        }<br/>    }</span></pre><p id="44de" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是在某些情况下，您会发现一个默认的实现具有跨角色的依赖关系，比如GetOrCreateFile()，它需要同时提供接口IFileReader和IFileWriter。</p><p id="e217" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">根据有这种跨角色依赖问题的方法的数量，您可以决定是否需要合并两个接口或者引入一个实现这些接口的联合接口，例如，</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="d58e" class="mi kx iq me b gy mj mk l ml mm">public interface IFileSystem :IFileReader,IFileWriter<br/>    {<br/>        <br/>        public File GetOrCreateFile(string filename)<br/>        {<br/>            var file = GetFile(filename);</span><span id="f00b" class="mi kx iq me b gy mn mk l ml mm">            if (file == null)<br/>                file = CreateFile(filename);</span><span id="4afe" class="mi kx iq me b gy mn mk l ml mm">            return file;<br/>        }<br/>    }</span></pre><p id="b424" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">底线默认方法实现是一个改变游戏规则的新特性，如果正确使用，它将有助于构建更好的软件，但如果滥用，它将破坏您的代码。在接下来的文章中，我将展示装饰模式有多有用，以及更多关于用例的内容。</p><p id="b5be" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以请在推特和媒体上关注我</p><div class="nm nn gp gr no np"><a href="https://twitter.com/MCC_Ahmed" rel="noopener  ugc nofollow" target="_blank"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd ir gy z fp nu fr fs nv fu fw ip bi translated">艾哈迈德·福阿德</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">艾哈迈德·福阿德的最新推文(@MCC_Ahmed)。我是PlanRadar的一名软件工程师，目前住在维也纳…</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">twitter.com</p></div></div><div class="ny l"><div class="nz l oa ob oc ny od jw np"/></div></div></a></div><p id="0215" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你喜欢这篇文章，你可以在</p><div class="nm nn gp gr no np"><a href="https://ko-fi.com/ahmedfouad" rel="noopener  ugc nofollow" target="_blank"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd ir gy z fp nu fr fs nv fu fw ip bi translated">给艾哈迈德·福阿德买杯咖啡。ko-fi.com/ahmedfouad</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">我是PlanRadar的一名软件工程师，目前住在奥地利的维也纳。我的兴趣范围从技术到网络…</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">ko-fi.com</p></div></div><div class="ny l"><div class="oe l oa ob oc ny od jw np"/></div></div></a></div><p id="d294" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以从以下网站了解更多关于c#的信息</p><p id="a12e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">C# 8.0和。NET Core 3.0 —现代跨平台开发:用C#构建应用程序。NET核心，实体框架核心，ASP.NET核心，ML.NET使用Visual Studio代码，第4版第4版，Kindle版</p></div></div>    
</body>
</html>