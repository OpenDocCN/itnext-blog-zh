<html>
<head>
<title>How To Master Advanced React Design Patterns — Render Props</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何掌握高级React设计模式——渲染道具</h1>
<blockquote>原文：<a href="https://itnext.io/using-advanced-design-patterns-to-create-flexible-and-reusable-react-components-part-3-render-d7517dfe72bc?source=collection_archive---------2-----------------------#2018-04-17">https://itnext.io/using-advanced-design-patterns-to-create-flexible-and-reusable-react-components-part-3-render-d7517dfe72bc?source=collection_archive---------2-----------------------#2018-04-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/f49d475608226b3c67beef5a64c733c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ji5DgEliT0219-opdiE5dw.png"/></div></div></figure><p id="1dbe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本系列的第1部分中，我们讨论了如何使用复合组件和静态类属性来生成可读和可重用的Stepper组件。我们看到这种设计模式有一些限制，因为它不是很灵活；组件需要是父组件的直接子组件，否则它会断开。</p><p id="d6c4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kw" rel="noopener ugc nofollow" target="_blank" href="/using-advanced-design-patterns-to-create-flexible-and-reusable-react-components-part-1-dd495fa1823">点击此处查看本系列的第1部分:复合组件</a></p><p id="9bb4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在第2部分中，我们使用了新的上下文API为第1部分的局限性提供了一个优雅且易读的解决方案。这种设计模式的问题是，它需要一些初始设置才能工作，我们的组件不能放入另一个应用程序中，并且在没有初始样板代码的情况下独立工作。</p><p id="46ad" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kw" rel="noopener ugc nofollow" target="_blank" href="/using-advanced-design-patterns-to-create-flexible-and-reusable-react-components-part-2-react-3c5662b997ab">点击这里查看本系列的第2部分:上下文API </a></p><p id="0fb0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这一部分中，我们将讨论一种设计模式，它可以解决到目前为止我们已经确定的所有问题。它叫做:渲染道具。</p><p id="b28c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这种设计模式一开始可能有点让人摸不着头脑(还记得我们在第2部分中放在上下文消费者内部的函数吗？)为了真正掌握它到底是如何工作的，我们需要深入了解顶级React API，以及我们编写的JSX代码是如何转换成javascript的。因此，让我们用一个非常简单的例子，并通过引擎盖下发生了什么。</p><h1 id="30f4" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">JSX</h1><p id="db78" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">JSX是由脸书的工程师设计的JavaScript的语法扩展。我们用它和React来描述UI应该是什么样子(有点像模板语言)，但是它具有JavaScript的全部功能。无论何时你在JSX写任何组件，Babel都会把它编译成一个<code class="fe ma mb mc md b">React.createElement()</code>调用。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi me"><img src="../Images/ae20c06ce8f85d4b9d069bbe649298c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o0vuU7Dzb5aaz7m3p9-Y5A.png"/></div></div></figure><p id="a877" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们看一个非常简单的例子:</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi me"><img src="../Images/3c01bc2333c7e9f15fdb32cfb16bef3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1KwKntECiGRJU5sxnL7LYA.png"/></div></div></figure><p id="0fab" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面的两个例子产生了相同的结果，父组件被简单地转换成一个<code class="fe ma mb mc md b">React.createElement()</code>调用，类型是我们的‘父’组件，没有道具，也没有子组件。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi me"><img src="../Images/a0cb02fb2c7c834b9afa80d2718c7042.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MZqaPGcEykaEhvp8X1TrlA.png"/></div></div></figure><p id="6cad" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我们添加一个子组件时，注意它本身是如何被转换成一个<code class="fe ma mb mc md b">React.createElement()</code>调用的，正是这种格式创建了我们的React组件树。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi me"><img src="../Images/30f0220b15a31caf8bf6f0bfd87a4361.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZuKIoHa_UECNwLVdSVgYMA.png"/></div></div></figure><p id="1dcb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里需要理解的关键点是，Babel编译任何作为单个props javascript对象添加的props；因为它是纯javascript，所以我们可以传递任何我们想要的东西，比如函数。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi me"><img src="../Images/e027f33433e2ecf60ff1728197c85791.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pxbMxCmpRYI-pN0Xul3JjQ.png"/></div></div></figure><p id="762f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上面的例子中，我们没有传递“字符串”，而是传递了一个返回“字符串”的函数。所以，当这个函数被调用时，我们可以得到完全相同的结果。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi me"><img src="../Images/a8b0afe62403c0c2b9644369ead2a6ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PQgX1RJVXBUHWPYqbAMAXg.png"/></div></div></figure><p id="cf8a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">那么上面的例子到底是怎么回事呢？在最初的例子中，我们只是传递字符串，把它放在一个“div”中，然后它就被呈现了。然而，在下一个示例中，我们将它作为一个函数传递，并将其放在一个“div”中，但这次调用该函数可以实现完全相同的结果。</p><h1 id="d8fc" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">渲染道具</h1><p id="9fd2" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">为什么这很重要？传统上，我们用<strong class="ka ir">渲染子组件</strong>，我们把它们放在父组件里面。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi me"><img src="../Images/401ec7471b70c61eb97716bf44614906.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W4X307RXCRX-M92h2XFeyA.png"/></div></div></figure><p id="e812" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是需要理解的关键，不是设计我们的组件来渲染一个孩子，而是没有任何东西阻止我们用<strong class="ka ir">来渲染道具</strong>，同时实现完全相同的结果:</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mj"><img src="../Images/8e3312421d0e1abc8790a1acc1813946.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mugiWhmq3woQb4oYMp509A.png"/></div></div></figure><p id="0037" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以，在这个设计模式中，我们<strong class="ka ir">渲染道具</strong>而不是孩子。我们还可以更进一步。我们还能用函数做什么？我们可以在调用参数时传递它们:</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mj"><img src="../Images/09ecbc71e4448c4a3a22379ecdb357b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yhv4JdMJMlGdenfchcYe2A.png"/></div></div></figure><p id="67ef" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们花点时间来消化一下刚刚发生的事情。我们已经像以前一样传入了一个函数，但它不是总是返回“字符串”,而是在被调用时返回我们传入的参数！</p><p id="959f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">等等，这不是我们在第1部分中遇到的问题吗？为了解决这个问题，我们必须克隆元素，遍历每个元素，然后传递任何需要的道具。</p><p id="98d5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用这种设计模式，我们能够将道具传递给子组件，嘭！</p><p id="0530" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以给这些道具起任何我们想要的名字。因此，我们不用“示例”，而是用更合适的词:</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi me"><img src="../Images/49c6189e0d943c80a767b47482f1c5a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Dm4kxErU2ytof6UYUMIL7A.png"/></div></div></figure><p id="58d9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你以前用过react路由器，这可能看起来很熟悉。当你需要传递道具到一条路线时，你需要使用一个渲染函数。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi me"><img src="../Images/ccc8c8ab356e65d8d06362d078a24ffa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*He7Q_dBroJoyZJykddFUIw.png"/></div></div></figure><p id="d8b6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是<strong class="ka ir">渲染道具。我们可以调用“render”并传入我们想要的任何参数，而不是直接呈现组件。</strong></p><p id="7843" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们回到stepper组件，看看如何利用这种设计模式(我已经删除了所有的上下文样板文件，并将状态添加回Stepper组件)。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi me"><img src="../Images/75ff1a81de86468061c47bbdcbdc1049.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l2Aca-G6z5SVExCUc5ThRA.png"/></div></div></figure><p id="187d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这次我们没有添加<code class="fe ma mb mc md b">{this.props.children}</code>，而是添加了<code class="fe ma mb mc md b">{this.props.render(stage,HandleClick)}</code>。我们不再需要向stepper组件添加任何子组件，我们需要做的只是在render prop中返回相同的标记。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi me"><img src="../Images/87435aad98096c73f93a8ee33c366cd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4e8wL_DEKLswiKya4st1Rw.png"/></div></div></figure><p id="795e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这实现了什么？现在，树中的每个组件都可以访问所有的道具。它本质上为我们提供了与上下文API相同的道具，我们不必手动将道具传递给每个孩子，并且我们可以灵活地移动东西。对组件设计的简单调整解决了我们之前提到的所有问题。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/f49d475608226b3c67beef5a64c733c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ji5DgEliT0219-opdiE5dw.png"/></div></div></figure><p id="b862" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">不过，使用这种设计模式有一个小小的折衷。代码比以前可读性稍差。还记得我们在本系列前面看到的那个奇怪的函数吗，我们需要在Context.consumer组件中添加一个函数。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi me"><img src="../Images/24066faaf71b658812ad158007c10663.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vl1h9TNE5VRFo_q3NrM_zQ.png"/></div></div></figure><p id="02ba" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对我来说，这看起来可读性很强；让我们想想这是怎么回事。我们没有添加渲染函数，而是简单地添加了一个相同的子函数。</p><p id="6754" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们用之前使用的示例组件来尝试这样做:</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi me"><img src="../Images/1bdb41867eee076d21e8e5acc869d943.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qg0GYaUlIrS5Zs6k__DHgw.png"/></div></div></figure><p id="9f2c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在左手边，我们像以前一样给渲染道具添加函数。当这个由Babel编译时，函数被添加到第二个参数中:props。在右边，我们把它作为一个孩子添加，当它被编译时，它被添加到第三个参数:孩子。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi me"><img src="../Images/ae20c06ce8f85d4b9d069bbe649298c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o0vuU7Dzb5aaz7m3p9-Y5A.png"/></div></div></figure><p id="e40a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">创建组件时，我们如何访问子组件？</p><p id="8a51" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"><em class="mk"/></strong></p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi me"><img src="../Images/2b7cb6b6b3cab5d8300d428d34dec160.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WWg_57uJXAc5ImvgoY_idw.png"/></div></div></figure><p id="c264" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">与调用render prop的方式类似，因为child是一个函数，所以我们可以调用props.children来代替，并传入我们所需的参数，为我们提供与以前相同的结果，并增强了可读性。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi me"><img src="../Images/11ed39e14c2057e956248122afb1d2e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Wafoqv6u2sdiGmpkOy4FhQ.png"/></div></div></figure><p id="25e9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在你知道了，我们设计了一个高度灵活且可读性极强的组件。用户可以自主地重新排列子组件，而不用担心它是否可以访问他们需要的道具。最终，它是可重用的。我们可以将它直接放在任何其他应用程序中，无需任何预先设置，它将完美地工作。</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="ml mm l"/></div></figure></div></div>    
</body>
</html>