<html>
<head>
<title>Create your first Ethereum dAPP with Web3 and Vue.JS (Part 2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Web3和Vue创建您的第一个以太坊dAPP。JS(第二部分)</h1>
<blockquote>原文：<a href="https://itnext.io/create-your-first-ethereum-dapp-with-web3-and-vue-js-part-2-52248a74d58a?source=collection_archive---------4-----------------------#2018-03-06">https://itnext.io/create-your-first-ethereum-dapp-with-web3-and-vue-js-part-2-52248a74d58a?source=collection_archive---------4-----------------------#2018-03-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="b53a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://www.linkedin.com/cws/share?url=https%3A%2F%2Fitnext.io%2Fcreate-your-first-ethereum-dapp-with-web3-and-vue-js-part-2–52248a74d58a" rel="noopener ugc nofollow" target="_blank"> <em class="km">点击这里在LinkedIn </em>上分享这篇文章</a></p><p id="ccc5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">欢迎回到这个令人敬畏的教程系列的第2部分，在这里我们动手构建我们的第一个分散式应用程序。在第二部分中，我们将介绍VueJS和Vuex的核心概念，并介绍web3js与metamask的交互。</p><p id="3fd5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你错过了第一部分，你可以在下面找到它，也可以在Twitter上关注我们！</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="ks kt l"/></div></figure><h1 id="6fd6" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">言归正传:VueJS</h1><p id="9752" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">VueJS是一个用于构建用户界面的javascript框架。乍一看，它看起来像经典的小胡子模板，但在引擎盖下发生了很多事情，使Vue反应。</p><pre class="kn ko kp kq gt lx ly lz ma aw mb bi"><span id="fda5" class="mc kv iq ly b gy md me l mf mg">&lt;div id=”app”&gt;<br/> {{ message }}<br/>&lt;/div&gt;</span><span id="abf1" class="mc kv iq ly b gy mh me l mf mg">var app = new Vue({<br/> el: '#app',<br/> data: {<br/> message: 'Hello Vue!'<br/> }<br/>})</span></pre><p id="271d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这将是一个真正基本的Vue应用程序的结构。数据对象中的消息属性将在id为“app”的元素中呈现到屏幕上，当我们更改此消息时，它将在屏幕上更新而不刷新。你可以在这个jsfiddle(打开自动运行)里面查看一下:【https://jsfiddle.net/tn1mfxwr/2/<a class="ae kl" href="https://jsfiddle.net/tn1mfxwr/2/" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="cf9b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">VueJS的另一个重要的关键特性是组件。组件是小的、可重用的和自包含的代码片段。本质上，一个web应用程序可以被抽象成一个由更小的组件组成的树。当我们开始编写前端应用程序时，这一点会变得更加清楚。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/962d382b5c10dabe7980b72c68ec921c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1150/format:webp/1*9XlTaVitmHopHmQ634kfvg.png"/></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">抽象成组件的网页示例。网页由三部分组成。其中两个组件有子组件。</figcaption></figure><h1 id="dc65" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">国家联盟:Vuex</h1><p id="2062" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">我们将使用Vuex来管理应用程序的状态。与redux类似，Vuex实现了一个store，作为我们的应用程序关于数据的“唯一真实来源”。Vuex允许我们以可预测的方式操纵和提供应用程序使用的数据。</p><p id="3b21" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它的工作方式非常简单。一个<strong class="jp ir">组件</strong>在呈现时需要数据，它将<strong class="jp ir">分派</strong>一个<strong class="jp ir">动作</strong>来获取它需要的数据。获取数据的API调用在操作中异步发生。一旦获取数据，动作将<strong class="jp ir">将该数据提交</strong>到<strong class="jp ir">突变</strong>。然后，突变将<strong class="jp ir">改变我们商店的状态</strong>。当该组件使用的存储中的数据发生变化时，它将重新呈现。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/c7765d8f76d07d91665f7907922ff795.png" data-original-src="https://miro.medium.com/v2/resize:fit:1320/format:webp/1*EPstm-VwycENr4PjutJ0KA.png"/></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">Vuex的状态管理模式</figcaption></figure><h1 id="65b9" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated"><strong class="ak">在我们继续之前……</strong></h1><p id="df85" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">在第一部分中，我们通过使用vue-cli生成了一个Vue应用程序，我们还安装了我们需要的依赖项。如果你还没看过第一部分，链接在最上面。</p><p id="7ab0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你做了所有正确的事情，你的目录结构应该是这样的:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi mq"><img src="../Images/5fec180819c043ef8aeb7cc4bc38b4ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*24ZJn3iRu_FZN_Y6E65sgQ.png"/></div></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">新生成的vue应用程序</figcaption></figure><p id="57d4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">快速提示:如果您打算从这里复制粘贴代码块，请将<em class="km"> /src/ </em>添加到您的<em class="km">中。eslintinignore</em>文件以避免缩进错误</strong></p><p id="d79d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在您的终端中，您可以键入“npm start”来运行此应用程序。它将包含默认的vue应用程序，所以我们将首先清除它。<br/><em class="km">* *注意:我们正在使用vue路由器，尽管只有一条路由，我们并不需要它，但我认为在教程中保留它会很好，因为它非常简单。<br/>* *提示:将atom(右下角)中的语法转换为HTML格式。vue文件</em></p><p id="eeea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">是时候清理这个宝贝了:</p><ul class=""><li id="ba07" class="mv mw iq jp b jq jr ju jv jy mx kc my kg mz kk na nb nc nd bi translated">在app.vue中，删除img标签并清除style标签之间的所有内容。</li><li id="57bd" class="mv mw iq jp b jq ne ju nf jy ng kc nh kg ni kk na nb nc nd bi translated">删除<em class="km">组件/HelloWorld.vue </em>，创建两个名为casino-dapp.vue(我们的主组件)和hello-metamask.vue(将包含我们的元掩码数据)的新文件</li><li id="837c" class="mv mw iq jp b jq ne ju nf jy ng kc nh kg ni kk na nb nc nd bi translated">在我们新的<em class="km"> hello-metamask.vue </em>文件中粘贴下面的代码，它现在只在p标签中显示文本“hello”。</li></ul><pre class="kn ko kp kq gt lx ly lz ma aw mb bi"><span id="eb68" class="mc kv iq ly b gy md me l mf mg">&lt;template&gt;<br/> &lt;p&gt;Hello&lt;/p&gt;<br/>&lt;/template&gt;</span><span id="11df" class="mc kv iq ly b gy mh me l mf mg">&lt;script&gt;<br/>export default {<br/> name: 'hello-metamask'<br/>}<br/>&lt;/script&gt;</span><span id="7889" class="mc kv iq ly b gy mh me l mf mg">&lt;style scoped&gt;</span><span id="859a" class="mc kv iq ly b gy mh me l mf mg">&lt;/style&gt;</span></pre><ul class=""><li id="8de3" class="mv mw iq jp b jq jr ju jv jy mx kc my kg mz kk na nb nc nd bi translated">现在，我们将hello-metamask组件加载到我们的主casino-dapp组件中，首先导入文件，然后在我们的vue实例中引用它，这样我们就可以将它作为标签添加到模板中。将此粘贴到<em class="km"> casino-dapp.vue </em>中:</li></ul><pre class="kn ko kp kq gt lx ly lz ma aw mb bi"><span id="75a8" class="mc kv iq ly b gy md me l mf mg">&lt;template&gt;<br/><strong class="ly ir"> &lt;hello-metamask/&gt;</strong><br/>&lt;/template&gt;</span><span id="1d03" class="mc kv iq ly b gy mh me l mf mg">&lt;script&gt;<br/><strong class="ly ir">import HelloMetamask from '@/components/hello-metamask'</strong><br/>export default {<br/> name: 'casino-dapp',<br/> <strong class="ly ir">components: {<br/> 'hello-metamask': HelloMetamask<br/> }</strong><br/>}<br/>&lt;/script&gt;</span><span id="5bcb" class="mc kv iq ly b gy mh me l mf mg">&lt;style scoped&gt;</span><span id="9a80" class="mc kv iq ly b gy mh me l mf mg">&lt;/style&gt;</span></pre><ul class=""><li id="e15d" class="mv mw iq jp b jq jr ju jv jy mx kc my kg mz kk na nb nc nd bi translated">现在，如果您打开router/index.js，您将看到我们只有一条到根的路由，它仍然指向我们删除的HelloWorld.vue组件。我们需要将其更改为我们的主要赌场-dapp.vue组件。</li></ul><pre class="kn ko kp kq gt lx ly lz ma aw mb bi"><span id="c13b" class="mc kv iq ly b gy md me l mf mg">import Vue from 'vue'<br/>import Router from 'vue-router'<br/><strong class="ly ir">import CasinoDapp from '@/components/casino-dapp'</strong></span><span id="1454" class="mc kv iq ly b gy mh me l mf mg">Vue.use(Router)</span><span id="fe17" class="mc kv iq ly b gy mh me l mf mg">export default new Router({<br/> routes: [<br/> {<br/> path: '/',<br/> <strong class="ly ir">name: 'casino-dapp',<br/> component: CasinoDapp</strong><br/> }<br/> ]<br/>})</span></pre><p id="d607" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">关于Vue路由器的一点:你可以添加额外的路径并将组件绑定到它们，当你访问定义的路径时，这些将会呈现。由于App.vue文件中的router-view标记，将呈现正确的组件。</p><ul class=""><li id="84dc" class="mv mw iq jp b jq jr ju jv jy mx kc my kg mz kk na nb nc nd bi translated">在<em class="km"> src </em>中创建一个名为<em class="km"> util的新文件夹。在这个文件夹内创建另一个名为<em class="km">常量</em>的文件夹。创建一个名为<em class="km"> networks.js </em>的文件，并粘贴下面的代码。这将让我们显示以太坊网络名称，而不是它的id，同时保持我们的代码干净。</em></li></ul><pre class="kn ko kp kq gt lx ly lz ma aw mb bi"><span id="ba55" class="mc kv iq ly b gy md me l mf mg">export const NETWORKS = {<br/> '1': 'Main Net',<br/> '2': 'Deprecated Morden test network',<br/> '3': 'Ropsten test network',<br/> '4': 'Rinkeby test network',<br/> '42': 'Kovan test network',<br/> '4447': 'Truffle Develop Network',<br/> '5777': 'Ganache Blockchain'<br/>}</span></pre><ul class=""><li id="936d" class="mv mw iq jp b jq jr ju jv jy mx kc my kg mz kk na nb nc nd bi translated">最后但同样重要的是(实际上这是目前最不重要的)，在<em class="km"> src </em>中创建一个名为<em class="km"> store </em>的新文件夹。我们将在下一节回到这个问题。</li></ul><p id="9ea2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您在终端中运行'<em class="km"> npm start' </em>，并在浏览器中转至<em class="km"> localhost:8080 </em>，您应该会看到<em class="km">‘Hello '</em>出现在屏幕上。如果是这样，你就准备好继续前进了。</p><h1 id="8d31" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">建立我们的Vuex商店</h1><p id="e411" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">在这一部分，我们将建立我们的商店。首先在我们全新的<em class="km">商店</em>目录中创建两个文件(上一节的最后部分):<em class="km"> index.js </em>和<em class="km">state . js</em>；我们将从<em class="km"> state.js </em>开始，它是我们将要检索的数据的空白表示。</p><pre class="kn ko kp kq gt lx ly lz ma aw mb bi"><span id="5ac6" class="mc kv iq ly b gy md me l mf mg">let state = {<br/> web3: {<br/> isInjected: false,<br/> web3Instance: null,<br/> networkId: null,<br/> coinbase: null,<br/> balance: null,<br/> error: null<br/> },<br/> contractInstance: null<br/>}<br/>export default state</span></pre><p id="f90a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好，现在我们将在<em class="km"> index.js </em>建立我们的商店。我们将导入vuex库并告诉vueJS使用它。我们将导入州并将其添加到我们的存储中。</p><pre class="kn ko kp kq gt lx ly lz ma aw mb bi"><span id="78b8" class="mc kv iq ly b gy md me l mf mg">import Vue from 'vue'<br/>import Vuex from 'vuex'<br/>import state from './state'</span><span id="2757" class="mc kv iq ly b gy mh me l mf mg">Vue.use(Vuex)</span><span id="cf83" class="mc kv iq ly b gy mh me l mf mg">export const store = new Vuex.Store({<br/> strict: true,<br/> state,<br/> mutations: {},<br/> actions: {}<br/>})</span></pre><p id="6f73" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后一步是编辑main.js来包含我们的存储:</p><pre class="kn ko kp kq gt lx ly lz ma aw mb bi"><span id="538c" class="mc kv iq ly b gy md me l mf mg">import Vue from 'vue'<br/>import App from './App'<br/>import router from './router'<br/><strong class="ly ir">import { store } from './store/'</strong></span><span id="9845" class="mc kv iq ly b gy mh me l mf mg">Vue.config.productionTip = false</span><span id="2486" class="mc kv iq ly b gy mh me l mf mg">/* eslint-disable no-new */<br/>new Vue({<br/> el: '#app',<br/> router,<br/> <strong class="ly ir">store</strong>,<br/> components: { App },<br/> template: '&lt;App/&gt;'<br/>})</span></pre><p id="8c76" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">做得好，给自己一个鼓励，因为这是一个很大的设置。现在，我们已经准备好通过web3 API获取元掩码数据，并在我们的应用程序中提供它。就要成真了！</p><h1 id="9c0c" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">Web3和元掩码入门</h1><p id="2225" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">如前所述，为了让我们将数据放入我们的Vue应用程序，我们需要调度一个动作来进行异步API调用。我们将使用promises将几个调用链接在一起，并将其抽象到一个文件中。所以在<em class="km"> util </em>文件夹中创建一个名为<em class="km"> getWeb3.js </em>的新文件。粘贴下面的代码，其中包含相当多的评论，供您遵循。我们也将在代码块下面检查它。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nj kt l"/></div></figure><p id="028f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先要注意的是，我们使用承诺来链接我们的回调，如果你不知道承诺，请查看<a class="ae kl" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" rel="noopener ugc nofollow" target="_blank">链接</a>。接下来，我们检查用户是否运行了元遮罩(或薄雾)。Metamask注入它自己的web3实例，因此我们将检查window.web3(注入的实例)不是未定义的。如果不是这样，我们将创建一个web3实例，用Metamask作为当前提供者，这样我们就不依赖于注入实例的版本。我们把新创建的实例传递给下一个承诺，在这里我们进行几个API调用:</p><ul class=""><li id="0e45" class="mv mw iq jp b jq jr ju jv jy mx kc my kg mz kk na nb nc nd bi translated"><em class="km">web 3 . version . get network()</em>会返回我们所连接的网络的ID。</li><li id="e8f6" class="mv mw iq jp b jq ne ju nf jy ng kc nh kg ni kk na nb nc nd bi translated"><em class="km"> web3.eth.coinbase() </em>返回我们的节点正在挖掘的地址，当使用元掩码时，这应该是所选的帐户。</li><li id="6b76" class="mv mw iq jp b jq ne ju nf jy ng kc nh kg ni kk na nb nc nd bi translated"><em class="km">web 3 . eth . get balance(&lt;address&gt;)</em>返回我们作为参数传入的地址的余额。</li></ul><p id="86f0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">还记得我们说过异步API调用需要发生在我们的Vuex存储中的动作内部吗？我们现在将它连接起来，稍后再从我们的组件发送出去。在<em class="km"> store/index.js </em>中，我们将导入我们的<em class="km"> getWeb3.js </em>文件，调用它并将其提交给一个变异，该变异将把它保存到我们的存储中。</p><p id="478d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在导入语句中添加</p><pre class="kn ko kp kq gt lx ly lz ma aw mb bi"><span id="da8c" class="mc kv iq ly b gy md me l mf mg">import getWeb3 from '../util/getWeb3'</span></pre><p id="862a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后在动作对象中(在你的商店中)，我们将调用<em class="km"> getWeb3 </em>和<em class="km"> commit </em>结果。我们正在向我们的逻辑添加一些console.logs，这样我们就可以看到我们的流程的步骤，这将有望使整个调度-操作-提交-变异-状态更改变得更加清晰。</p><pre class="kn ko kp kq gt lx ly lz ma aw mb bi"><span id="72a8" class="mc kv iq ly b gy md me l mf mg">registerWeb3 ({commit}) {<br/>      console.log('registerWeb3 Action being executed')<br/>      getWeb3.then(result =&gt; {<br/>        console.log('committing result to registerWeb3Instance mutation')<br/>        commit('registerWeb3Instance', result)<br/>      }).catch(e =&gt; {<br/>        console.log('error in action registerWeb3', e)<br/>      })<br/>    }</span></pre><p id="3081" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我们将创建我们的突变，它将我们的数据保存到我们的存储状态中。我们可以通过访问第二个参数来访问在变异中传递到提交中的数据。在<em class="km">突变</em>对象内部添加下面的函数。</p><pre class="kn ko kp kq gt lx ly lz ma aw mb bi"><span id="adfc" class="mc kv iq ly b gy md me l mf mg">registerWeb3Instance (state, payload) {<br/> console.log('registerWeb3instance Mutation being executed', payload)<br/> let result = payload<br/> let web3Copy = state.web3<br/> web3Copy.coinbase = result.coinbase<br/> web3Copy.networkId = result.networkId<br/> web3Copy.balance = parseInt(result.balance, 10)<br/> web3Copy.isInjected = result.injectedWeb3<br/> web3Copy.web3Instance = result.web3<br/> state.web3 = web3Copy<br/> }</span></pre><p id="017d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">太好了！现在剩下要做的就是从组件中分派我们的动作，以实际检索数据并将其呈现给应用程序。为了分派我们的动作，我们将利用<a class="ae kl" href="https://vuejs.org/v2/guide/instance.html#Instance-Lifecycle-Hooks" rel="noopener ugc nofollow" target="_blank"> Vue的生命周期钩子</a>。在我们的例子中，我们将在创建之前从主要的casino-dapp组件中调度我们的操作。因此，在<em class="km">组件/casino-dapp.vue </em>中，在名称属性下添加以下函数:</p><pre class="kn ko kp kq gt lx ly lz ma aw mb bi"><span id="7a71" class="mc kv iq ly b gy md me l mf mg">export default {<br/>  name: 'casino-dapp',<br/><strong class="ly ir">  beforeCreate () {<br/>    console.log('registerWeb3 Action dispatched from casino-dapp.vue')<br/>    this.$store.dispatch('registerWeb3')<br/>  },</strong><br/>  components: {<br/>    'hello-metamask': HelloMetamask<br/>  }<br/>}</span></pre><p id="5978" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好了，现在我们将从hello-metamask组件中呈现这些数据，我们所有的帐户数据都将在该组件中呈现。为了从我们的存储中获取数据，我们需要将一个getter函数传递给computed。然后，我们可以使用花括号引用模板中的数据。</p><pre class="kn ko kp kq gt lx ly lz ma aw mb bi"><span id="8eb9" class="mc kv iq ly b gy md me l mf mg">&lt;template&gt;<br/> &lt;div class='metamask-info'&gt;<br/>   &lt;p&gt;Metamask: {{ web3.isInjected }}&lt;/p&gt;<br/>   &lt;p&gt;Network: {{ web3.networkId }}&lt;/p&gt;<br/>   &lt;p&gt;Account: {{ web3.coinbase }}&lt;/p&gt;<br/>   &lt;p&gt;Balance: {{ web3.balance }}&lt;/p&gt;<br/> &lt;/div&gt;<br/>&lt;/template&gt;</span><span id="6750" class="mc kv iq ly b gy mh me l mf mg">&lt;script&gt;<br/>export default {<br/> name: 'hello-metamask',<br/> computed: {<br/>   web3 () {<br/>     return this.$store.state.web3<br/>     }<br/>   }<br/>}<br/>&lt;/script&gt;</span><span id="4c00" class="mc kv iq ly b gy mh me l mf mg">&lt;style scoped&gt;&lt;/style&gt;</span></pre><p id="7f8c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">太好了，现在一切都正常了。在您的终端中，使用“npm start”启动项目，然后转到localhost:8080。我们现在应该可以看到元掩码数据了。当我们打开控制台时，我们应该在vuex段落中描述的状态管理模式中看到来自控制台日志的消息。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi nk"><img src="../Images/6cf4e05c38d9296422af79aa4e67c775.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z1S3FigrOgjE4xEY8f5PcQ.png"/></div></div></figure><p id="aea6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你能做到这一步，并且一切顺利，那就做得很好，真的。这是这个系列中最难的部分。在下一部分中，我们将学习如何轮询元掩码的更改(例如，切换帐户)并将我们在第1部分中编写的智能契约连接到我们的应用程序。</p><p id="3b00" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">如果你遇到错误，你可以在hello-metamask分支的</strong> <a class="ae kl" href="https://github.com/kyriediculous/dapp-tutorial/tree/hello-metamask" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">这个github repo </strong> </a> <strong class="jp ir">中找到这个部分的完整工作代码。</strong></p><p id="e112" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">一定要看完</strong> <a class="ae kl" href="https://medium.com/@Alt_Street/create-your-first-ethereum-dapp-with-web3-and-vue-js-part-3-dc4f82fba4b4" rel="noopener"> <strong class="jp ir">这个系列的最后一部</strong> </a> <strong class="jp ir">！</strong></p><p id="fe46" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">和往常一样，如果你喜欢我们的教程，欢迎你留下你的建议，感谢你的阅读和坚持！</p><p id="c47e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="km">ETH—</em>0x 6d 31 CB 338 b 5590 adafec 46462 a1 b 095 ebdc 37d 50</p></div><div class="ab cl nl nm hu nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="ij ik il im in"><p id="aa29" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">想要建立你的想法吗？我们提供以太坊概念验证和众筹开发服务。</p><div class="ns nt gp gr nu nv"><a href="https://altstreet.io" rel="noopener  ugc nofollow" target="_blank"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd ir gy z fp oa fr fs ob fu fw ip bi translated">Alt Street -区块链顾问</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">区块链概念证明和代币销售</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">altstreet.io</p></div></div><div class="oe l"><div class="of l og oh oi oe oj mj nv"/></div></div></a></div></div></div>    
</body>
</html>