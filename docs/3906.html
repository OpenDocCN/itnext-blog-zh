<html>
<head>
<title>Faster, Lower, Better with Quarkus in k8s</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">k8s的夸库更快，更低，更好</h1>
<blockquote>原文：<a href="https://itnext.io/faster-lower-better-with-quarkus-in-k8s-83185af46f36?source=collection_archive---------3-----------------------#2020-03-23">https://itnext.io/faster-lower-better-with-quarkus-in-k8s-83185af46f36?source=collection_archive---------3-----------------------#2020-03-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="c28e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为什么Docker和Kubernetes具有非常快的启动速度、低内存占用、带标准框架的本机编译，从而提高可伸缩性、弹性和安全性。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/6847b637654e5f8010c9327b7575bebc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qyg8QmgoqSOWc6G7"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">照片由<a class="ae le" href="https://unsplash.com/@i_am_g?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Guillaume Jaillet </a>在<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></figcaption></figure><h1 id="8b51" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">TL；DR；</h1><p id="b64b" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">在这篇博客文章中，我向您展示了Quarkus如何在Docker中使用Docker中最少的映像(也是最安全的)在本地运行Java应用程序(通过用GraalVM将Java字节码编译成机器码),并将其部署在kubernetes上。</p><h1 id="d536" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">夸库斯。</h1><blockquote class="mi"><p id="aa49" class="mj mk it bd ml mm mn mo mp mq mr kn dk translated">一个为OpenJDK HotSpot和GraalVM定制的Kubernetes原生Java栈，由同类最佳的Java库和标准精心打造。</p></blockquote><p id="cf65" class="pw-post-body-paragraph jq jr it js b jt ms jv jw jx mt jz ka kb mu kd ke kf mv kh ki kj mw kl km kn im bi translated"><a class="ae le" href="https://quarkus.io/" rel="noopener ugc nofollow" target="_blank"> Quarkus </a>是由RedHat开发的一个框架，它是为容器世界设计的，具有以下特点:</p><ul class=""><li id="3d24" class="mx my it js b jt ju jx jy kb mz kf na kj nb kn nc nd ne nf bi translated">启动和停止非常快，包括第一次响应时间</li><li id="32ab" class="mx my it js b jt ng jx nh kb ni kf nj kj nk kn nc nd ne nf bi translated">低内存占用</li><li id="39ee" class="mx my it js b jt ng jx nh kb ni kf nj kj nk kn nc nd ne nf bi translated">可以用GraalVM编译成本机代码</li><li id="19f9" class="mx my it js b jt ng jx nh kb ni kf nj kj nk kn nc nd ne nf bi translated">使用同类最佳的Java库和标准:Eclipse MicroProfile、CDI、JAX-RS、JPA、Vert.x、Apache Camel、kafka、Vault、..(参见<a class="ae le" href="https://code.quarkus.io" rel="noopener ugc nofollow" target="_blank"> https://code.quarkus.io </a>和<a class="ae le" href="https://quarkus.io/guides/" rel="noopener ugc nofollow" target="_blank">https://quarkus.io/guides/</a>)</li><li id="60de" class="mx my it js b jt ng jx nh kb ni kf nj kj nk kn nc nd ne nf bi translated">支持命令式和反应式代码或两者的混合(参见<a class="ae le" href="https://quarkus.io/vision/continuum" rel="noopener ugc nofollow" target="_blank">https://quarkus.io/vision/continuum</a></li><li id="0819" class="mx my it js b jt ng jx nh kb ni kf nj kj nk kn nc nd ne nf bi translated">简单统一的配置(参见<a class="ae le" href="https://quarkus.io/guides/all-config" rel="noopener ugc nofollow" target="_blank">https://quarkus.io/guides/all-config</a></li></ul><h1 id="933c" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">GraalVM？</h1><blockquote class="mi"><p id="8cda" class="mj mk it bd ml mm mn mo mp mq mr kn dk translated">GraalVM是一个通用虚拟机，用于运行用JavaScript、Python、Ruby、R、基于JVM的语言编写的应用程序，如Java、Scala、Groovy、Kotlin、Clojure和基于LLVM的语言，如C和C++。</p><p id="f2cb" class="mj mk it bd ml mm mn mo mp mq mr kn dk translated">GraalVM消除了编程语言之间的隔离，并支持共享运行时的互操作性。它可以独立运行，也可以在OpenJDK、Node.js或Oracle数据库的上下文中运行。</p></blockquote><p id="ae44" class="pw-post-body-paragraph jq jr it js b jt ms jv jw jx mt jz ka kb mu kd ke kf mv kh ki kj mw kl km kn im bi translated">GraalVm由Oracle开发，能够本地运行基于JVM的语言(通过将Java字节码编译成机器码),并支持其他语言，如JavaScript、Python、Ruby、C、C++、R等。</p><h1 id="dfd7" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">演示</h1><p id="cf59" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">为了演示这种方法，我使用了一个基于<a class="ae le" href="https://github.com/quarkusio/quarkus-quickstarts/tree/master/getting-started" rel="noopener ugc nofollow" target="_blank">https://github . com/quarkusio/quarkusquickstarts/tree/master/getting-started</a>的演示应用程序</p><p id="7e15" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是一个最小的CRUD服务，通过REST公开了几个端点。<br/>在幕后，这个演示使用RESTEasy来公开REST端点。</p><p id="25e1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可以在以下GitHub资源库中找到源代码:</p><div class="nl nm gp gr nn no"><a href="https://github.com/sokube/quarkus-scratch/blob/master/Dockerfile" rel="noopener  ugc nofollow" target="_blank"><div class="np ab fo"><div class="nq ab nr cl cj ns"><h2 class="bd iu gy z fp nt fr fs nu fu fw is bi translated">sokube/quarkus-scratch</h2><div class="nv l"><h3 class="bd b gy z fp nt fr fs nu fu fw dk translated">在GitHub上创建一个帐户，为sokube/quarkus-scratch开发做贡献。</h3></div><div class="nw l"><p class="bd b dl z fp nt fr fs nu fu fw dk translated">github.com</p></div></div><div class="nx l"><div class="ny l nz oa ob nx oc ky no"/></div></div></a></div><h1 id="6614" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">多级码头建造</h1><p id="7d93" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">为了生成具有严格最小值的图像，使用<a class="ae le" href="https://docs.docker.com/develop/develop-images/multistage-build/" rel="noopener ugc nofollow" target="_blank">多级docker </a>构建，其中基于图像的最后一级为“<a class="ae le" href="https://docs.docker.com/develop/develop-images/baseimages/#create-a-simple-parent-image-using-scratch" rel="noopener ugc nofollow" target="_blank"> scratch </a>”:</p><p id="3e14" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><a class="ae le" href="https://github.com/sokube/quarkus-scratch/blob/master/Dockerfile" rel="noopener ugc nofollow" target="_blank">https://github . com/sokube/quar kus-scratch/blob/master/docker file</a>:</p><pre class="kp kq kr ks gt od oe of og aw oh bi"><span id="8d28" class="oi lg it oe b gy oj ok l ol om">### Image for getting maven dependencies and then acting as a cache for the next image<br/>FROM maven:3.6.3-jdk-11 as mavencache<br/>ENV MAVEN_OPTS=-Dmaven.repo.local=/mvnrepo<br/>COPY pom.xml /app/<br/>WORKDIR /app<br/>RUN mvn test-compile dependency:resolve dependency:resolve-plugins<br/><br/>### Image for building the native binary<br/>FROM oracle/graalvm-ce:19.3.1-java11 AS native-image<br/>ENV MAVEN_OPTS=-Dmaven.repo.local=/mvnrepo<br/>COPY --from=mavencache /mvnrepo/ /mvnrepo/<br/>COPY . /app<br/>WORKDIR /app<br/>ENV GRAALVM_HOME=/usr<br/>RUN gu install native-image &amp;&amp; \<br/>    ./mvnw package -Pnative -Dmaven.test.skip=true &amp;&amp; \<br/>    # Prepare everything for final image<br/>    mkdir -p /dist &amp;&amp; \<br/>    cp /app/target/*-runner /dist/application<br/><br/>### Final image based on scratch containing only the binary<br/>FROM scratch<br/>COPY --chown=1000 --from=native-image /dist /work<br/># it is possible to add timezone, certificat and new user/group<br/># COPY --from=xxx /usr/share/zoneinfo /usr/share/zoneinfo<br/># COPY --from=xxx /etc/ssl/certs/ca-certificates.crt /etc/ssl/certs/<br/># COPY --from=xxx /etc/passwd /etc/passwd<br/># COPY --from=xxx /etc/group /etc/group<br/>EXPOSE 8080<br/>USER 1000<br/>WORKDIR /work/<br/>CMD ["./application", "-Djava.io.tmpdir=/work/tmp"]</span></pre><p id="44dc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这种多级docker构建由3个部分组成:</p><ol class=""><li id="9e52" class="mx my it js b jt ju jx jy kb mz kf na kj nb kn on nd ne nf bi translated">运行maven dependencies plugin: <br/>创建一个包含所有maven jars的中间映像，作为下一个映像的缓存。<br/>这样，下次构建docker映像时，就不需要再次加载所有依赖项。</li><li id="9cc9" class="mx my it js b jt ng jx nh kb ni kf nj kj nk kn on nd ne nf bi translated">创建二进制可执行文件:<br/>带有<a class="ae le" href="https://hub.docker.com/r/oracle/graalvm-ce/tags" rel="noopener ugc nofollow" target="_blank"> Graalvm镜像</a> +原生镜像目标<a class="ae le" href="https://quarkus.io/guides/maven-tooling" rel="noopener ugc nofollow" target="_blank"> quarkus-maven-plugin </a>它将生成一个64位Linux可执行文件。<br/>重要的部分在<a class="ae le" href="https://github.com/sokube/quarkus-scratch/blob/master/pom.xml#L100-L102" rel="noopener ugc nofollow" target="_blank"> pom.xml </a>中:为了创建一个可以在不包含libc的linux发行版上本地运行的nativeImage(如Alpine Linux……),“native-image”命令使用“additionalBuildArg”使用“- static”参数进行编译。</li><li id="c324" class="mx my it js b jt ng jx nh kb ni kf nj kj nk kn on nd ne nf bi translated">使用基于scratch的映像创建最终映像:<br/>“scratch”是Docker的保留名称，用于指示构建过程跳过这一行，转到下一个Dockerfile命令。这不是一个你可以拉或运行的图像(尽管它<a class="ae le" href="https://hub.docker.com/_/scratch" rel="noopener ugc nofollow" target="_blank">出现在DockerHub的库</a>)。<br/>这是所有其他映像的基本祖先，但它是一个没有任何文件夹/文件、外壳、库的空映像……<br/>要了解docker如何解释基于“临时”的映像，请阅读<a class="ae le" href="https://www.mgasch.com/post/scratch/" rel="noopener ugc nofollow" target="_blank">https://www.mgasch.com/post/scratch/</a><br/>因为前面的步骤带有“- static”参数，所以可执行文件可以在“从临时”构建的Docker映像中运行……</li></ol><h1 id="0e11" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">构建并运行docker映像</h1><p id="fa00" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">要执行这种多阶段构建，请使用以下命令行:</p><pre class="kp kq kr ks gt od oe of og aw oh bi"><span id="3611" class="oi lg it oe b gy oj ok l ol om">docker build -t quarkus-app .</span></pre><p id="aee0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">用GraalVm编译一个本地可执行文件需要很长时间，而且占用大量CPU资源。因此，最好将此过程委托给您的CI/CD管道。好消息是，在没有本地编译的情况下，在开发阶段，Quarkus热重装非常有效。</p><p id="d455" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要运行生成的图像:</p><pre class="kp kq kr ks gt od oe of og aw oh bi"><span id="4936" class="oi lg it oe b gy oj ok l ol om">docker run -it --rm --name quarkus -p 8888:8080 quarkus-app</span></pre><p id="3127" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它将生成以下输出:</p><pre class="kp kq kr ks gt od oe of og aw oh bi"><span id="0d86" class="oi lg it oe b gy oj ok l ol om">2020-03-15 18:19:39,643 INFO  [io.quarkus] (main) getting-started 1.0-SNAPSHOT (running on Quarkus 1.2.1.Final) started in <strong class="oe iu">0.028s</strong>. Listening on: http:<br/>//0.0.0.0:8080<br/>2020-03-15 18:19:39,644 INFO  [io.quarkus] (main) Profile prod activated. <br/>2020-03-15 18:19:39,644 INFO  [io.quarkus] (main) Installed features: [cdi, resteasy]</span></pre><p id="2a35" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">请注意0.028秒的启动时间</p><p id="5e5a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可以在您的浏览器中测试该应用程序:<a class="ae le" href="http://localhost:8888/hello/greeting/SoKube" rel="noopener ugc nofollow" target="_blank">http://localhost:8888/hello/greeting/SoKube</a></p><p id="87cd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">不要认为这是一个简单的hello World演示:在引擎盖下，Quarkus框架使用CDI和Resteasy，就像您使用需要服务于业务请求的真实java应用程序一样…</p><p id="df7d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">另一个有趣的测试是限制内存和CPU:</p><pre class="kp kq kr ks gt od oe of og aw oh bi"><span id="6881" class="oi lg it oe b gy oj ok l ol om">docker run -it --rm --name quarkus -p 8888:8080 --cpus="0.05" --memory="4m" --memory-swap="4m" quarkus-app</span></pre><p id="694e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用0.05的CPU和4m的内存，应用程序在2.503秒内启动:</p><pre class="kp kq kr ks gt od oe of og aw oh bi"><span id="eeb4" class="oi lg it oe b gy oj ok l ol om">2020-03-15 18:35:18,137 INFO  [io.quarkus] (main) getting-started 1.0-SNAPSHOT (running on Quarkus 1.2.1.Final) started in <strong class="oe iu">2.503s</strong>. Listening on: <a class="ae le" href="http://0.0.0.0:8080" rel="noopener ugc nofollow" target="_blank">http://0.0.0.0:8080</a><br/>2020-03-15 18:35:18,137 INFO  [io.quarkus] (main) Profile prod activated. <br/>2020-03-15 18:35:18,137 INFO  [io.quarkus] (main) Installed features: [cdi, resteasy]</span></pre><p id="8a6c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">就分配的资源而言，仍然令人印象深刻！</p><h1 id="7ee1" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">Kubernetes Quarkus部署</h1><p id="b9e1" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">为了在Kubernetes上部署，我使用了一个本地的<a class="ae le" href="https://rancher.com/docs/k3s/latest/en/" rel="noopener ugc nofollow" target="_blank"> k3s发行版</a>和<a class="ae le" href="https://github.com/rancher/k3d" rel="noopener ugc nofollow" target="_blank"> k3d </a>。要了解更多信息，请参阅我以前的一篇文章“k3d + k3s = k8s开发和测试的完美匹配”。</p><p id="0047" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，首先创建kubernetes集群:</p><pre class="kp kq kr ks gt od oe of og aw oh bi"><span id="7862" class="oi lg it oe b gy oj ok l ol om">k3d create --name quarkus-cluster --api-port 6555 --publish 8085:80<br/>export KUBECONFIG="$(k3d get-kubeconfig --name='quarkus-cluster')"<br/>kubectl cluster-info</span></pre><p id="9aff" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用<a class="ae le" href="https://github.com/sokube/quarkus-scratch/blob/master/deploy.yaml" rel="noopener ugc nofollow" target="_blank">https://github . com/sokube/quar kus-scratch/blob/master/deploy . YAML</a>部署应用程序</p><p id="515c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">克隆这个Git repo并将目录更改为“quarkus-scratch”</p><pre class="kp kq kr ks gt od oe of og aw oh bi"><span id="4762" class="oi lg it oe b gy oj ok l ol om">k3d import-images --name quarkus-cluster quarkus-app<br/>kubectl apply -f deploy.yaml</span></pre><p id="fd06" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第一行导入k3s集群中之前创建的名为“quarkus-app”的映像。第二行部署应用程序。</p><p id="9061" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后，您应该能够使用:<a class="ae le" href="http://localhost:8085/hello/greeting/SoKube" rel="noopener ugc nofollow" target="_blank">http://localhost:8085/hello/greeting/SoKube</a>访问该应用程序</p><h1 id="c1bf" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">K8s请求和限制</h1><p id="9ef2" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">在Pod规范中，我定义了请求并限制资源最多使用1毫核CPU (1000毫核= 1个CPU)和4Mi内存</p><pre class="kp kq kr ks gt od oe of og aw oh bi"><span id="895a" class="oi lg it oe b gy oj ok l ol om">        resources:<br/>          limits:<br/>            memory: "4Mi"<br/>            cpu: "1m"<br/>          requests:<br/>            cpu: "1m"<br/>            memory: "4Mi"</span></pre><p id="961f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">命令“<em class="oo"> kubectl logs -l app=quarkus </em>”显示了启动日志:</p><pre class="kp kq kr ks gt od oe of og aw oh bi"><span id="98ca" class="oi lg it oe b gy oj ok l ol om">2020-03-17 10:42:26,239 INFO  [io.quarkus] (main) getting-started 1.0-SNAPSHOT (running on Quarkus 1.2.1.Final) started in <strong class="oe iu">0.170s</strong>. Listening on: <a class="ae le" href="http://0.0.0.0:8080" rel="noopener ugc nofollow" target="_blank">http://0.0.0.0:8080</a><br/>2020-03-17 10:42:26,241 INFO  [io.quarkus] (main) Profile prod activated. <br/>2020-03-17 10:42:26,241 INFO  [io.quarkus] (main) Installed features: [cdi, resteasy]</span></pre><p id="00d6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">尽管资源有限，仍然非常快！用你的JEE或SpringBoot应用程序:D尝试这样的场景</p><h1 id="8b5d" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">扩展您的应用</h1><p id="9efa" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">凭借如此快速的启动和低内存占用，您可以在笔记本电脑上使用50个副本轻松扩展您的应用程序:</p><pre class="kp kq kr ks gt od oe of og aw oh bi"><span id="ef87" class="oi lg it oe b gy oj ok l ol om">kubectl scale deployment/quarkus --replicas 50</span><span id="dc2b" class="oi lg it oe b gy op ok l ol om">NAME      READY   UP-TO-DATE   AVAILABLE   AGE<br/>quarkus   50/50   50           50          1h</span></pre><p id="40c6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后很快地把它缩小:</p><pre class="kp kq kr ks gt od oe of og aw oh bi"><span id="6cb2" class="oi lg it oe b gy oj ok l ol om">kubectl scale deployment/quarkus --replicas 1</span><span id="d044" class="oi lg it oe b gy op ok l ol om">NAME      READY   UP-TO-DATE   AVAILABLE   AGE<br/>quarkus   1/1     1            1           1h</span></pre><h1 id="3458" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">好吧，有趣，但是为什么呢？</h1><p id="d643" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">部署这样的应用并不是为了“瓦霍效应”(至少不仅仅是！).</p><ul class=""><li id="abd9" class="mx my it js b jt ju jx jy kb mz kf na kj nb kn nc nd ne nf bi translated">CPU和内存是用于对云或内部环境收费的常见资源。这些资源不是无限的，账单可能会不可思议地增加。此外，它还存在像谷歌云平台(GCP)这样的低成本解决方案，在这个平台上，你可以使用“共享核心机器类型”来订购虚拟机。对于运行小型、非资源密集型应用程序来说，这可能是一种经济高效的方法，例如“E2-micro 2vCPU，1GB内存”每月仅需6.5美元。</li><li id="c251" class="mx my it js b jt ng jx nh kb ni kf nj kj nk kn nc nd ne nf bi translated">对于Kubernetes来说，快速启动和关闭以进行扩展和部署是一个关键方面。<br/>如果应用程序的启动时间很长，将迫使您将<a class="ae le" href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes" rel="noopener ugc nofollow" target="_blank">探测器</a>配置为高超时(除了从k8s 1.16开始，新的启动探测器用于第一次启动，然后使用活动和就绪探测器)。但在所有情况下，它将简化新应用程序版本的推出和回滚。</li><li id="bfbf" class="mx my it js b jt ng jx nh kb ni kf nj kj nk kn nc nd ne nf bi translated">您的笔记本电脑或开发环境上的低内存占用使得本地开发更加容易。将像k3s这样的轻量级Kubernetes发行版与本地应用程序结合起来，就有可能拥有一个更接近真实生产环境的完整k8s平台，但是是本地的！</li><li id="ddfa" class="mx my it js b jt ng jx nh kb ni kf nj kj nk kn nc nd ne nf bi translated">安全性是生产中的一个主要问题，在极简docker映像(没有外壳、文件、文件夹或库)中拥有一个专用的64位Linux可执行文件可以大大减少安全性问题。<br/>如多阶段构建文件所示，不要忘记保持其他安全最佳实践，比如不要成为root…</li><li id="5c31" class="mx my it js b jt ng jx nh kb ni kf nj kj nk kn nc nd ne nf bi translated">无服务器架构和产品可以受益于真实应用程序的更快启动时间。当没有“热”容器可用时，通过“冷启动”按需执行功能。因此，在这些情况下，为了避免高延迟，包括第一次请求响应时间在内的非常快的启动时间非常重要。</li></ul><h1 id="9559" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">完美？</h1><p id="7a9f" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">依靠Quarkus使用原生编译并部署在kubernetes上是好的，但还不够！<br/>你的应用需要被设计成一个<a class="ae le" href="https://thenewstack.io/10-key-attributes-of-cloud-native-applications/" rel="noopener ugc nofollow" target="_blank">云本地应用</a> (CNA)，我不是在说微服务。你可以写一个CNA作为一个“普通”的服务，但是要遵守一些原则，避免，例如，你的应用程序的启动初始化在几分钟内加载一个巨大的缓存在内存中…你的应用程序的设计是非常重要的，没有一个框架，工具，产品可以弥补一个坏的设计！</p><p id="6b85" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">本地编译的一个缺点是<a class="ae le" href="https://github.com/oracle/graal/blob/master/substratevm/REFLECTION.md" rel="noopener ugc nofollow" target="_blank">限制</a>，尤其是在反射和动态类加载的使用方面。这使得将所有应用程序迁移到原生二进制文件变得更加困难(至少目前如此)，但是随着Graal的每个版本，兼容性都在提高。这就是为什么Quarkus <a class="ae le" href="https://quarkus.io/guides/" rel="noopener ugc nofollow" target="_blank">支持有限的扩展列表</a>,但是它正在增长并且已经包含了很多扩展。</p><p id="0574" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">与极简docker形象相关的另一个方面是出道！<br/>无法在容器中执行命令！那么如何调试一个不包含shell，curl，wget…甚至ls，chmod，chown，mkdir…这样的工具的镜像呢？<br/>我不会详细说明如何实现这一点，但简单来说就是使用像<a class="ae le" href="https://hub.docker.com/_/busybox" rel="noopener ugc nofollow" target="_blank"> busybox </a>这样的图像，并从该图像向极简图像注入外壳和所需的工具…</p><h1 id="23e1" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">结论</h1><p id="c709" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">Quarkus非常适合云时代，在这个时代，容器、Kubernetes、微服务或服务、功能即服务和原生为云设计的应用程序允许达到高水平的生产力和效率。</p><p id="8eb0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">像Kubernetes这样的服务、即时可伸缩性和高密度平台要求应用程序具有较小的内存占用和快速启动。Java并没有很好地定位，因为它以牺牲CPU和RAM为代价来支持处理时间。把Quarkus和GraalVM结合起来，就不再是这样了！</p><p id="17ae" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Kubernetes将长期存在，所以让我们为最大的灵活性、效率和安全性准备好我们的开发、应用和平台。</p></div></div>    
</body>
</html>