<html>
<head>
<title>Using Bing Maps in Blazor with JSInterop and TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过JSInterop和TypeScript在Blazor中使用Bing地图</h1>
<blockquote>原文：<a href="https://itnext.io/using-bing-maps-in-blazor-with-jsinterop-and-typescript-90e888e0e2fd?source=collection_archive---------3-----------------------#2019-05-20">https://itnext.io/using-bing-maps-in-blazor-with-jsinterop-and-typescript-90e888e0e2fd?source=collection_archive---------3-----------------------#2019-05-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="c86f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本文中，我们将在客户端Blazor应用程序中使用Bing Maps web控件。由于没有Blazor本地Bing地图控件，我们将使用TypeScript来访问Bing地图API。为了与C#中的TypeScript通信，我们将使用Blazor中的<code class="fe ko kp kq kr b">JSRuntime</code>调用。</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi ks"><img src="../Images/58991baaffb49e224b78bc174a3b3929.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cG6lztM1Z8X8eFm3DtVb6g.png"/></div></div></figure><h1 id="27ce" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">入门指南</h1><p id="9d99" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">本文的所有工作都是用Visual Studio 2019社区版16.1预览版3完成的。一切都会好的。网芯3预览版4或预览版5。使用Blazor(ASP.Net核心托管)模板开始一个新项目。</p><p id="af8e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要使用它，你还需要自己的Bing地图API密匙。你可以在<a class="ae mh" href="https://www.bingmapsportal.com/" rel="noopener ugc nofollow" target="_blank">https://www.bingmapsportal.com/</a>注册自己的免费钥匙。</p><p id="14d1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我正在用MVVM做我所有的客户端Blazor开发。这不是本文的一部分，但是如果你想知道为什么我在我的项目视图和模型中创建文件夹，这就是原因。如果你有兴趣阅读我的布拉佐·MVVM的文章，下面是第一篇文章的链接。</p><div class="mi mj gp gr mk ml"><a rel="noopener  ugc nofollow" target="_blank" href="/a-simple-mvvm-implementation-in-client-side-blazor-8c875c365435"><div class="mm ab fo"><div class="mn ab mo cl cj mp"><h2 class="bd iu gy z fp mq fr fs mr fu fw is bi translated">客户端Blazor中一个简单的MVVM实现。</h2><div class="ms l"><h3 class="bd b gy z fp mq fr fs mr fu fw dk translated">本文是我将介绍我目前计划如何创建Blazor客户端的系列文章的第一篇…</h3></div><div class="mt l"><p class="bd b dl z fp mq fr fs mr fu fw dk translated">itnext.io</p></div></div><div class="mu l"><div class="mv l mw mx my mu mz lc ml"/></div></div></a></div><h1 id="1401" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">设置Bing地图API</h1><p id="f8d2" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">Bing Maps 8 Web API是一个微软Javascript API。为了让我们将要编写的类型脚本可以访问它，我们将为客户端项目的<code class="fe ko kp kq kr b">wwwroot</code>文件夹中的<code class="fe ko kp kq kr b">index.html</code>添加一个<code class="fe ko kp kq kr b">&lt;script&gt;</code>标签。编辑<code class="fe ko kp kq kr b">index.html</code>并在<code class="fe ko kp kq kr b">&lt;/body&gt;</code>之前添加此行:</p><pre class="kt ku kv kw gt na kr nb nc aw nd bi"><span id="3060" class="ne lf it kr b gy nf ng l nh ni">&lt;script type='text/javascript' src='https://www.bing.com/api/maps/mapcontrol?key=MyBingKey' &gt;&lt;/script&gt;</span></pre><p id="857d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">请务必编辑上面的行，用您注册时收到的实际密钥替换MyBingKey。有了这些，Bing Maps API就可以在你的代码中使用了。</p><h1 id="60c2" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">设置我们的Blazor组件</h1><p id="edda" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">Bing地图需要一个<code class="fe ko kp kq kr b">&lt;div&gt;</code>的名字来初始化自己。为了让Bing可以使用它，我们将向Blazor示例模板添加一个新组件，并将所需的&lt; div &gt;放入其中。对于我的项目，我新建了一个文件夹，命名为Views，在这个文件夹中，我添加了一个新的Razor视图，命名为<code class="fe ko kp kq kr b">SiteMapper.razor</code>。你可以使用任何你觉得舒服的名字，我的名字是特定于我正在做的一个地图项目的。在新组件中输入以下代码:</p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="558f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">出于某种原因，设置高度为100%不起作用，但使用视口高度相对长度可以。我们现在有一个id为myMap的<code class="fe ko kp kq kr b">&lt;div&gt;</code>，Bing地图可以使用它。</p><p id="ef2a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我们的组件被创建之后，我们需要把它添加到<code class="fe ko kp kq kr b">Pages</code>文件夹中的<code class="fe ko kp kq kr b">NavMenu.razor</code>中，这样当我们启动我们的应用程序时它就会出现。我们还需要制作一份<code class="fe ko kp kq kr b">_Imports.razor</code>的副本，并将其放入我们的视图文件夹中。</p><h1 id="4ded" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">设置类型脚本</h1><p id="eada" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">Blazor已经编译了添加到内置客户端项目中的TypeScript我们只需要设置我们的文件夹结构。我们还将在项目中添加Bing Map 8类型脚本定义文件，以便在编辑类型脚本时为Bing地图提供智能感知。在我们的<code class="fe ko kp kq kr b">wwwroot</code>文件夹下添加一个新文件夹，并将其命名为ts。要获取智能感知的定义，请到这里下载定义文件:</p><div class="mi mj gp gr mk ml"><a href="https://github.com/microsoft/Bing-Maps-V8-TypeScript-Definitions" rel="noopener  ugc nofollow" target="_blank"><div class="mm ab fo"><div class="mn ab mo cl cj mp"><h2 class="bd iu gy z fp mq fr fs mr fu fw is bi translated">Microsoft/Bing-Maps-V8-TypeScript-定义</h2><div class="ms l"><h3 class="bd b gy z fp mq fr fs mr fu fw dk translated">此项目包含Bing Maps V8 Web控件的TypeScript定义。…</h3></div><div class="mt l"><p class="bd b dl z fp mq fr fs mr fu fw dk translated">github.com</p></div></div><div class="mu l"><div class="nl l mw mx my mu mz lc ml"/></div></div></a></div><p id="2b37" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在你的<code class="fe ko kp kq kr b">ts</code>文件夹下新建一个文件夹，命名为<code class="fe ko kp kq kr b">types</code>。将刚刚下载的定义中的<code class="fe ko kp kq kr b">types</code>文件夹下的所有内容复制到该文件夹中。在你的<code class="fe ko kp kq kr b">ts</code>文件夹下也做一个<code class="fe ko kp kq kr b">interfaces</code>文件夹，我们稍后会用到。您在TS下的文件夹结构将如下所示:</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/73c1a02d51d14ddd44efdd61686e43f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:664/format:webp/1*MYg-ZQefhZMXZj1DWQV2Qw.png"/></div></figure><p id="b013" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">设置好文件夹和定义后，我们可以添加第一个TypeScript文件。在<code class="fe ko kp kq kr b">ts</code>文件夹中添加一个新的TypeScript文件并将其命名为<code class="fe ko kp kq kr b">BingTsInterop.ts</code>。在TypeScript文件中添加以下内容:</p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="b636" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第一行是一个引用，类似于C#中的using语句。它告诉我们的类型脚本关于我们可用的定义文件，并为我们提供智能感知。第3行声明了第5到15行定义的BingMap类的一个实例。该类包含一个<code class="fe ko kp kq kr b">Map</code>的实例和一个构造函数，该构造函数创建一个新的地图，该地图将被放置在<code class="fe ko kp kq kr b">myMap</code> div中。构造函数还指定了一些<code class="fe ko kp kq kr b">MapLoadOptions</code>，在这个例子中是地图的中心、地图类型和缩放级别。</p><p id="db78" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第17到19行的<code class="fe ko kp kq kr b">loadMap()</code>函数将我们的<code class="fe ko kp kq kr b">BingMap</code>类的一个新实例分配给<code class="fe ko kp kq kr b">bingMap</code>。这是我们想从JSInterop调用的函数。</p><h1 id="5c30" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">从布拉索呼叫<code class="fe ko kp kq kr b">loadMap()</code></h1><p id="78ca" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">如果我们现在进行构建，我们会看到<code class="fe ko kp kq kr b">BingTSInterop.ts</code>已经被编译来创建<code class="fe ko kp kq kr b">BingTSInterop.js</code>。现在我们有了我们的输出，返回到<code class="fe ko kp kq kr b">index.html</code>中，用这个标签让它对我们的应用程序可用:</p><pre class="kt ku kv kw gt na kr nb nc aw nd bi"><span id="d13d" class="ne lf it kr b gy nf ng l nh ni">&lt;script src="./ts/BingTsInterop.js"&gt;&lt;/script&gt;</span></pre><p id="1852" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要将所需的C#添加到我们的组件中，让我们添加一个代码隐藏文件。在Views文件夹中添加一个新的C#类，并将其命名为<code class="fe ko kp kq kr b">SiteMapper.razor.cs</code>。将这个类的名字改为<code class="fe ko kp kq kr b">SiteMapperBase</code>，并让它继承自<code class="fe ko kp kq kr b">ComponentBase</code>。为了调用TypeScript，我们还需要将<code class="fe ko kp kq kr b">using MicrosoftJSInterop;</code>添加到using语句中。我们的类将看起来像这样:</p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="a2c3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">到目前为止，这个类相当简单。我们有一个属性，<code class="fe ko kp kq kr b">JSRuntime</code>，它已经被注入到我们的类中，我们已经重写了<code class="fe ko kp kq kr b">OnAfterRenderAsync()</code>来调用<code class="fe ko kp kq kr b">loadMap</code>。因为没有来自<code class="fe ko kp kq kr b">loadMap</code>的返回值，所以我们使用<code class="fe ko kp kq kr b">InvokeAsync&lt;Task&gt;.</code>，如果有返回值，我们需要指定一个合适的类型。</p><p id="f247" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">设置好代码后，我们可以返回到<code class="fe ko kp kq kr b">SiteMapper.razor</code>并在<code class="fe ko kp kq kr b">@page</code>指令下添加下面一行。</p><pre class="kt ku kv kw gt na kr nb nc aw nd bi"><span id="d18c" class="ne lf it kr b gy nf ng l nh ni">@inherits SiteMapperBase</span></pre><p id="09e6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有了它，我们后面的代码将成为我们视图的一部分，而不需要把所有东西都保存在一个文件中。此时，我们可以启动我们的应用程序了。</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi nn"><img src="../Images/a1fccf63ab5939347a5b2d7fec7b90f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TpoRnu8nmU5EMqXDf_o2WQ.png"/></div></div></figure><p id="1918" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一旦我们的组件完成渲染，我们现在就调用我们的TypeScript <code class="fe ko kp kq kr b">loadMap</code>函数。我们可以更改地图的视图或设置，然后导航到不同的控件并返回，将再次调用<code class="fe ko kp kq kr b">loadMap</code>并将其设置回默认值。</p><h1 id="f566" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">添加标记</h1><p id="f603" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">现在我们有了一张地图，让我们用它做点什么吧。地图的一个常见任务是在地图上放置图钉。在https://bingmapsv8samples.azurewebsites.net/有一个非常大的必应地图样本库。我是SVG模板图钉的粉丝(它看起来很干净，颜色也很容易设置),所以让我们来看看这段代码:</p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="f59d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有一点代码，但大部分是制作pin的静态代码。我们最感兴趣的是第一行中对<code class="fe ko kp kq kr b">map.getCenter()</code>的调用，它决定了代码样本中pin的位置，然后在第10行中颜色被设置为蓝色。如果我们可以传入位置和颜色，我们将有一个可重用的图钉。我们的目标是以一种我们可以忘记它存在的方式连接我们所有的TypeScript，并专注于在Blazor中做真正的工作。为了做到这一点，我们需要一种可靠的方法将数据传入TypeScript。</p><p id="674c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通过查看代码我们可以看出<code class="fe ko kp kq kr b">color</code>是一个字符串，但是什么是<code class="fe ko kp kq kr b">map.getCenter()</code>？如果我们将该函数输入到我们的TypeScript文件中，我们可以将鼠标悬停在它上面，并看到它返回一个<code class="fe ko kp kq kr b">Microsoft.Maps.Location</code>。我们已经在<code class="fe ko kp kq kr b">BingMap</code>构造函数中使用了该类型。如果我们将鼠标悬停在该类型上，我们可以看到<code class="fe ko kp kq kr b">constructor Microsoft.Maps.Location(latitude:any, longitude:any)</code>，因此看起来我们需要将颜色、纬度和经度传递到TypeScript中以生成自定义图钉。我们如何使用JSInterop发送所有3个值？我们可以使用<code class="fe ko kp kq kr b">args[]</code>将它们作为3个对象发送，但我有一种感觉，这会让我们的代码更难阅读。如果它们都是一个对象的成员就更好了。</p><h1 id="3265" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">类型脚本接口</h1><p id="c452" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">TypeScript，就像C#一样，允许我们编写接口在代码中作为契约使用。我们将为我们的输入创建一个Typescript接口，然后用C#创建相同的数据结构，并从Blazor传入它。如果一切按预期运行，我们将能够在Blazor中创建自己的对象，并将其直接传递给TypeScript。</p><p id="33c3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">转到我们之前创建的<code class="fe ko kp kq kr b">wwwroot/ts/interfaces</code>文件夹，在其中创建一个新的TypeScript文件，并将其命名为<code class="fe ko kp kq kr b">BingMapsInterfaces.ts</code>。我们之前决定需要一个字符串和一个位置，所以把这段代码放到文件中:</p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="e161" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是TypeScript接口的语法。我们首先声明一个接口并命名它，然后声明成员。除了键入语法之外，它非常接近C#。为了使这个接口对我们的代码可用，我们将添加一个对<code class="fe ko kp kq kr b">BingTsInterop.ts</code>的新引用。</p><pre class="kt ku kv kw gt na kr nb nc aw nd bi"><span id="5d17" class="ne lf it kr b gy nf ng l nh ni">/// &lt;reference path="interfaces/BingMapsInterfaces.ts" /&gt;</span></pre><p id="ec90" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该语句使得我们在<code class="fe ko kp kq kr b">BingMapsInterfaces.ts</code>中创建的任何东西都可以用于我们的代码。接下来，我们将回到我们的Blazor代码，并创建一个匹配的类。</p><p id="e568" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在客户端项目中创建一个<code class="fe ko kp kq kr b">Models</code>文件夹，然后创建一个新的C#类并将其命名为<code class="fe ko kp kq kr b">BingMapObjects.cs</code>。首先我们将创建我们的<code class="fe ko kp kq kr b">Location</code>类。在Typescript中，我们用<code class="fe ko kp kq kr b">number</code>表示纬度和经度，这里我们将使用<code class="fe ko kp kq kr b">double</code>。我们还将添加一个构造函数，以便在赋值时使代码更加简洁。</p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="d998" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">定义了<code class="fe ko kp kq kr b">Location</code>之后，我们现在可以创建一个<code class="fe ko kp kq kr b">Pushpin</code>类。这只是颜色和位置。</p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="706c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们正确地连接了所有的东西，我们现在就可以在Blazor的地图上添加图钉了。回到<code class="fe ko kp kq kr b">SiteMapper.razor.cs</code>，将这段代码添加到我们的<code class="fe ko kp kq kr b">OnAfterRenderAsync</code>方法中:</p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="8052" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在在BingTsInterop.ts中创建<code class="fe ko kp kq kr b">AddPushpin</code>函数:</p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="822e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们已经创建了一个TypeScript函数，它接受一个<code class="fe ko kp kq kr b">BingPin</code>并且没有返回值。我们可以看到，我们从C#代码传入的位置和颜色都来自于<code class="fe ko kp kq kr b">sitePin</code>。该函数的第二条语句只是将我们创建的图钉放在地图上。如果我们再次启动我们的应用程序，我们现在应该会看到一个绿色的图钉。</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi no"><img src="../Images/eaacb33dd39177ea000fd46feda99ea2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TD9GtO4aQGbcHDccom-cag.png"/></div></div></figure><h1 id="3746" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">添加多边形</h1><p id="f460" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">向地图添加多边形是另一项常见任务。如果我们在github知识库上查看一个基本多边形的代码示例，它看起来并不复杂:</p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="2092" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该代码获取地图的中心，并使用另外两个点来定义一个三角形。这些点被放入<code class="fe ko kp kq kr b">exteriorRing</code>。每个多边形由一个或多个环组成。第一个环是外环，它定义了多边形及其填充区域。第一个环之后的每个环都是内部环，它定义了多边形内部的区域，这些区域将成为多边形中的洞。</p><p id="5328" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来是实际的构造函数，看起来还不错。第一个是外环，然后是填充颜色的字符串，笔画颜色的字符串和笔画粗细的数字。定义将这些信息传递给Typescript的接口和类应该不会太难。</p><p id="5cbd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">向我们的typescript代码临时添加一个多边形构造函数，鼠标悬停在它上面会显示一些有趣的东西。</p><pre class="kt ku kv kw gt na kr nb nc aw nd bi"><span id="6375" class="ne lf it kr b gy nf ng l nh ni">constructor Microsoft.Maps.Polygon(rings: Microsoft.Maps.Location[] | Microsoft.Maps.Location[][], options?: Microsoft.Maps.IPolygonOptions)</span></pre><p id="984d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">看起来第一个参数可以是一个环，也可以是一组环(一个环是一个位置[])。options参数也不是必需的，但是我们会提供它，因为我们想使用它。如果我们要定义一个允许一个或多个环的接口，我们必须将其定义为<code class="fe ko kp kq kr b">Microsoft.Maps.Location[][]</code>，即使我们只传递一个环。返回到<code class="fe ko kp kq kr b">BingMapsInterfaces.ts</code>并添加此代码来定义我们选项的接口:</p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="1926" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这只是我们想要提供的三个选项的直接列表。接下来，我们可以定义想要从Blazor传入的实际多边形对象:</p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="a86d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如前所述，我们总是要使用多环语法，即使我们只传递一个环。</p><p id="01b9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有了这样定义的接口，将我们的多边形添加到地图上的函数变得非常短。返回BingTsInterop.ts并添加此函数:</p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="4c44" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们只需要调用构造函数，并把它推到地图上，我们就完成了。</p><h1 id="246a" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">围成一个圈</h1><p id="a22b" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">一些业务需求需要编写代码来创建一个以指定点为圆心、直径大约为10英里的圆。在本文中，我们将使用该代码，而不是手动选择点。在<code class="fe ko kp kq kr b">Models</code>文件夹中创建一个新类<code class="fe ko kp kq kr b">MapCircle.cs</code>,并粘贴以下代码:</p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="bfc5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这段代码使用数学方法在一个中心点周围画出一个圆。靠近底部的循环使用3作为间隔，因此一个圆仅由120个点组成，而不是360个点。该数字可以根据分辨率或性能的需要而提高或降低。</p><p id="0689" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们现在必须返回到BingMapsObjects.cs，并在那里添加类以匹配我们的TypeScript接口。查看类型脚本，我们的C#类看起来像这样:</p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="488a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是1对1的映射，应该在我们调用JSInterop时工作。现在剩下的就是添加代码来创建我们的多边形到<code class="fe ko kp kq kr b">SiteMapper.razor.cs</code>。以下是所有需要的代码:</p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="c7af" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这段代码首先声明一个新的<code class="fe ko kp kq kr b">Polygon</code>，然后为环声明一个<code class="fe ko kp kq kr b">List&lt;Location[]&gt;</code>。<code class="fe ko kp kq kr b">List&lt;T&gt;</code>更容易操作，有方便的<code class="fe ko kp kq kr b">.ToArray()</code>方法。在第3行，我们调用<code class="fe ko kp kq kr b">DrawMapCircle</code>并添加这个圆作为我们的第一个(外部)环。在第4行到第6行，我们画了一个更小的圆，反转它的方向，然后添加它作为第二个环。如果内部环的方向与外部环的方向相反，它将无法正确渲染。第7行将我们的<code class="fe ko kp kq kr b">List</code>环变成了<code class="fe ko kp kq kr b">Array</code>。剩下的代码实例化<code class="fe ko kp kq kr b">PolygonOptions</code>并设置我们想要传入的值。最后，第13行调用我们在TypeScript中创建的<code class="fe ko kp kq kr b">AddPolygon</code>方法。如果我们现在运行我们的应用程序，我们应该在地图上看到一个甜甜圈形状。</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi np"><img src="../Images/ded544310abd3672a6130d5789d8e124.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nLxXBkVI7iQDdiiuQLPOBA.png"/></div></div></figure><h1 id="01c6" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">包扎</h1><p id="7e43" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">在这篇文章中，我们第一次看到在客户端Blazor应用程序中使用Bing Maps 8 web控件。我们从获得一个API键开始，并使API对我们的代码可用。接下来，我们设置了Typescript文件夹，并添加了Bing映射类型定义，为TypeScript中的Bing提供了智能感知。最后，我们经历了如何初始化地图，并添加图钉和多边形。在这个过程中，我们还介绍了如何使用Typescript接口将数据从C#干净地传递给TypeScript。</p><p id="ff10" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Bing Maps 8 API还有更多的东西，我们只是触及了表面。下一次我们可能会讨论API的其他功能，或者我们可能会深入Bing Maps REST API。如果你有任何问题或意见，可以留在这里或在Twitter上联系我@LouisHendricks。</p></div></div>    
</body>
</html>