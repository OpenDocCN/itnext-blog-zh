<html>
<head>
<title>How to mock a dependency in a Node.js, and why you should do it.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何模拟Node.js中的依赖关系，以及为什么应该这样做。</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-mock-dependency-in-a-node-js-and-why-2ad4386f6587?source=collection_archive---------0-----------------------#2017-07-06">https://itnext.io/how-to-mock-dependency-in-a-node-js-and-why-2ad4386f6587?source=collection_archive---------0-----------------------#2017-07-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/0b9c12a5de81f5001aabd631b039d92c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*WNkMzoVO6JMiUXHtebMZVA.png"/></div></figure><p id="b7e7" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这是致力于依赖嘲讽系列的第一个故事:</p><div class="ks kt gp gr ku kv"><a href="https://medium.com/@antonkorzunov/please-stop-playing-with-proxyquire-923fe6009a0a" rel="noopener follow" target="_blank"><div class="kw ab fo"><div class="kx ab ky cl cj kz"><h2 class="bd ir gy z fp la fr fs lb fu fw ip bi translated">请不要玩proxyquire了</h2><div class="lc l"><h3 class="bd b gy z fp la fr fs lb fu fw dk translated">在我们开始之前:我是3个男孩的父亲，他们经常“玩”。我喜欢看他们打球，但他们不是…</h3></div><div class="ld l"><p class="bd b dl z fp la fr fs lb fu fw dk translated">medium.com</p></div></div><div class="le l"><div class="lf l lg lh li le lj js kv"/></div></div></a></div><div class="ks kt gp gr ku kv"><a rel="noopener  ugc nofollow" target="_blank" href="/unit-tests-for-skynet-written-in-js-6704265858a4"><div class="kw ab fo"><div class="kx ab ky cl cj kz"><h2 class="bd ir gy z fp la fr fs lb fu fw ip bi translated">天网的单元测试(用JS编写)</h2><div class="lc l"><h3 class="bd b gy z fp la fr fs lb fu fw dk translated">我要揭示一个关于天网兴衰的真相，以及为什么终结者1之后是终结者2，3…</h3></div><div class="ld l"><p class="bd b dl z fp la fr fs lb fu fw dk translated">itnext.io</p></div></div><div class="le l"><div class="lk l lg lh li le lj js kv"/></div></div></a></div></div><div class="ab cl ll lm hu ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="ij ik il im in"><p id="98b5" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">让我告诉你一个关于一个大的单元测试世界的一小部分的童话。</p><p id="0ca6" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">关于<strong class="jw ir">嘲讽</strong>。</p><blockquote class="ls lt lu"><p id="93d0" class="ju jv lv jw b jx jy jz ka kb kc kd ke lw kg kh ki lx kk kl km ly ko kp kq kr ij bi translated">使用<a class="ae lz" href="https://en.wikipedia.org/wiki/Test-driven_development" rel="noopener ugc nofollow" target="_blank">测试驱动开发</a> (TDD)方法的程序员在编写软件时会使用模拟对象。<strong class="jw ir">模仿对象满足</strong> <a class="ae lz" href="https://en.wikipedia.org/wiki/Interface_(computer_science)" rel="noopener ugc nofollow" target="_blank"> <strong class="jw ir">接口</strong> </a> <strong class="jw ir">的要求，并替代更复杂的真实对象</strong>；因此，它们允许程序员在一个区域编写和<a class="ae lz" href="https://en.wikipedia.org/wiki/Unit_testing" rel="noopener ugc nofollow" target="_blank">单元测试</a>功能，而无需调用复杂的底层或协作<a class="ae lz" href="https://en.wikipedia.org/wiki/Class_(computer_science)" rel="noopener ugc nofollow" target="_blank">类</a>。谢谢你，维基百科</p></blockquote><p id="1c25" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">所以，我希望你知道单元测试<strong class="jw ir">必须</strong> <strong class="jw ir">测试</strong>他们的目标在<strong class="jw ir">隔离</strong>。目标必须被隔离，只要他们只是应该测试自己，而不是第三方库。这就是为什么它们被称为<strong class="jw ir">单元</strong>测试。</p><blockquote class="ma"><p id="fa62" class="mb mc iq bd md me mf mg mh mi mj kr dk translated">你唯一需要测试的是一个被测对象。</p></blockquote><p id="1a57" class="pw-post-body-paragraph ju jv iq jw b jx mk jz ka kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr ij bi translated">作为一个良好的开端，让我们测试简单的模块。</p><ol class=""><li id="6b6b" class="mp mq iq jw b jx jy kb kc kf mr kj ms kn mt kr mu mv mw mx bi translated">天网</li></ol><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="4ff3" class="nh ni iq nd b gy nj nk l nl nm"><strong class="nd ir">import </strong>React, { PropTypes } <strong class="nd ir">from </strong>'react';<br/><strong class="nd ir">import </strong>destroyAllHumans <strong class="nd ir">from </strong>'very-actions';<br/><br/><strong class="nd ir">export const </strong>SkyNetReactComponent= (props) =&gt; (<br/>  &lt;div onClick={<strong class="nd ir">destroyAllHumans</strong>}&gt;BIG BUTTON&lt;/div&gt;<br/>);<br/><br/><strong class="nd ir">export default </strong>ReactComponent;</span></pre><p id="b9fb" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">你能测试这个吗？你能保证人类会被点击毁灭吗？请将地面重新放回<strong class="jw ir">位置，使测试可重复</strong>。</p><blockquote class="ls lt lu"><p id="0e0c" class="ju jv lv jw b jx jy jz ka kb kc kd ke lw kg kh ki lx kk kl km ly ko kp kq kr ij bi translated">终结者1，终结者2，终结者3，终结者起源…没有测试会导致失败的重复。</p></blockquote><p id="1f3e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">好吧，也许这是个不好的例子。</p><p id="123b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">2.缓慢的测试</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="9157" class="nh ni iq nd b gy nj nk l nl nm"><strong class="nd ir">import</strong> dataFetcher <strong class="nd ir">from</strong> 'bigDataSource';</span><span id="ce57" class="nh ni iq nd b gy nn nk l nl nm"><strong class="nd ir">export</strong> <strong class="nd ir">default</strong> () =&gt; dataFetcher().filter.map.reduce;</span></pre><p id="597d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这段代码没有问题。它太慢了，会减慢你的测试速度。但这仍然不是一个最好的例子。</p><p id="a2e3" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">3.生意</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="cc3f" class="nh ni iq nd b gy nj nk l nl nm"><strong class="nd ir">import</strong> prepareData <strong class="nd ir">from</strong> "./data-preparator"<br/><strong class="nd ir">import</strong> {spendSomeMoneyOnAWS} <strong class="nd ir">from</strong> 'AWS';<br/><strong class="nd ir">import</strong> petTheCat <strong class="nd ir">from</strong> './catUtils';</span><span id="93df" class="nh ni iq nd b gy nn nk l nl nm"><strong class="nd ir">const</strong> veryImportantBusinessLogic = data =&gt; {<br/>   const preparedData = prepareData(data);<br/>   const result = spendSomeMoneyOnAWS(preparedData);<br/>   <strong class="nd ir">await</strong> patTheCat();<br/>   <strong class="nd ir">return</strong> result; <br/>}</span></pre><p id="dfc2" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">为了在这个测试中获得“信心”，你必须仔细检查什么<em class="lv">非常重要的后端</em>将被触发，并且有人将轻拍猫。但是你真的要执行那些函数吗，你只是在调用它们的时候侦察它们？</p><p id="3288" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">4.等待</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="0377" class="nh ni iq nd b gy nj nk l nl nm">import eventStream from 'big-event-pipe';<br/>import Santa from 'north-pole';<br/>import { believeIn } from 'side-effects';</span><span id="4ea0" class="nh ni iq nd b gy nn nk l nl nm">eventStream.on('xmas', () =&gt; believeIn(Santa) );</span></pre><p id="ae69" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">好了，你写了这个测试，现在等待…圣诞节！？</p><p id="a845" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在我这里列出的所有情况下，你不应该执行代码，不应该运行它，但应该检查他们实际在做什么。断言“行为”。</p><blockquote class="ma"><p id="044b" class="mb mc iq bd md me mf mg mh mi mj kr dk translated">不应调用任何真正的函数。它们是副作用。</p></blockquote><p id="6a64" class="pw-post-body-paragraph ju jv iq jw b jx mk jz ka kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr ij bi translated">所以<strong class="jw ir">嘲笑你的依赖</strong>。用空函数替换动作，返回你期望从选择器中得到的东西。将(实际上是— <strong class="jw ir">存根</strong> ) redux的handleActions替换为sinon.spy/stub,，并检查您为调用提供的参数。不要执行任何操作。模拟来自假来源、假计时器、假网络、假副作用的事件。假的。嘲笑。存根。测试。</p><p id="a52d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">PS:还有<strong class="jw ir">不要叫destroyAllHumans </strong>。这将使测试可重复。</p><blockquote class="ls lt lu"><p id="8754" class="ju jv lv jw b jx jy jz ka kb kc kd ke lw kg kh ki lx kk kl km ly ko kp kq kr ij bi translated">你忘了吗——天网还没有投入生产。你不应该调用真正的端点。还没有。我有一篇关于这个案子的专题文章</p></blockquote><div class="ks kt gp gr ku kv"><a rel="noopener  ugc nofollow" target="_blank" href="/unit-tests-for-skynet-written-in-js-6704265858a4"><div class="kw ab fo"><div class="kx ab ky cl cj kz"><h2 class="bd ir gy z fp la fr fs lb fu fw ip bi translated">天网的单元测试(用JS编写)</h2><div class="lc l"><h3 class="bd b gy z fp la fr fs lb fu fw dk translated">我将揭示一个关于天网兴衰的真相，以及为什么终结者1之后是终结者2，3…</h3></div><div class="ld l"><p class="bd b dl z fp la fr fs lb fu fw dk translated">itnext.io</p></div></div><div class="le l"><div class="lk l lg lh li le lj js kv"/></div></div></a></div><h1 id="bb1d" class="no ni iq bd np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe of og oh oi oj ok bi translated">建造你自己的孤独堡垒。</h1><p id="98db" class="pw-post-body-paragraph ju jv iq jw b jx ol jz ka kb om kd ke kf on kh ki kj oo kl km kn op kp kq kr ij bi translated">我必须指出一点——很多人没有看到单词<em class="lv">嘲笑</em>后的<em class="lv">依赖</em>，没有区分对象嘲笑和<em class="lv">依赖嘲笑。</em></p><p id="e199" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">由sinon或jasmine等在<code class="fe oq or os nd b">variables</code>、<code class="fe oq or os nd b">function</code>、<code class="fe oq or os nd b">objects</code>或<code class="fe oq or os nd b">instances</code>工作的图书馆提供，并在其他地方有用。</p><blockquote class="ma"><p id="3cb3" class="mb mc iq bd md me mf mg mh mi mj kr dk translated">为了解决谜题，我在上面写道，你必须<strong class="ak">重新连接</strong>被测对象(也就是你的模块)。</p></blockquote><p id="cca6" class="pw-post-body-paragraph ju jv iq jw b jx mk jz ka kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr ij bi translated">我说的是像require-js的<a class="ae lz" href="https://github.com/iammerrick/Squire.js" rel="noopener ugc nofollow" target="_blank"> Squire </a>，Common-JS模块的<a class="ae lz" href="https://github.com/mfncooper/mockery" rel="noopener ugc nofollow" target="_blank">mock</a>/<a class="ae lz" href="https://github.com/boblauer/mock-require" rel="noopener ugc nofollow" target="_blank">mock-require</a>/<a class="ae lz" href="https://github.com/theKashey/proxyquire" rel="noopener ugc nofollow" target="_blank">proxy quire</a>/Jest，webpack环境的rewire、<a class="ae lz" href="https://github.com/plasticine/inject-loader" rel="noopener ugc nofollow" target="_blank"> inject-loader </a>和friends这样的库。</p><p id="b3f6" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我希望你至少知道其中的一个，或者也许你正在使用一个非常常用的库<a class="ae lz" href="https://github.com/wheresrhys/fetch-mock" rel="noopener ugc nofollow" target="_blank"> fetch-mock </a>，它实际上做同样的事情，但只是为了fetch(它模仿它)。</p><h1 id="d86a" class="no ni iq bd np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe of og oh oi oj ok bi translated">嘲笑的正确方式</h1><p id="7f57" class="pw-post-body-paragraph ju jv iq jw b jx ol jz ka kb om kd ke kf on kh ki kj oo kl km kn op kp kq kr ij bi translated">说实话，这些库之间的唯一区别是它们的API和它们以前工作的node.js API。从你的角度来看，结果是一样的。</p><p id="4015" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">每一个都有一些优点和缺点。</p><p id="2cf4" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">比如—mock有关于<code class="fe oq or os nd b">isolation</code>的东西，可以用一个模块替换另一个模块，proxyquire有关于<code class="fe oq or os nd b">callThought</code>的东西，Jest有<code class="fe oq or os nd b">default</code>的模拟实现(__mock__)和自动模拟生成。</p><p id="81af" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">对你们中的许多人来说，嘲笑是一种代码气味。嘲讽就是baaaad。</p><h1 id="fa0a" class="no ni iq bd np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe of og oh oi oj ok bi translated">这种正确的嘲讽方式就是DI！</h1><p id="21bc" class="pw-post-body-paragraph ju jv iq jw b jx ol jz ka kb om kd ke kf on kh ki kj oo kl km kn op kp kq kr ij bi translated">依赖注入——向消费者提供所有“端点”的机制。一种可以替换任何端点的方法，并且可以随心所欲地重新布线。</p><p id="d184" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">DI是替代依赖的一种很酷也很方便的方法，在大多数情况下它会帮助你。但是有三个问题:</p><ol class=""><li id="7f64" class="mp mq iq jw b jx jy kb kc kf mr kj ms kn mt kr mu mv mw mx bi translated">DI是为面向对象的强类型语言设计的，因为没有其他方法可以对组件使用不同的逻辑。</li><li id="5b51" class="mp mq iq jw b jx ot kb ou kf ov kj ow kn ox kr mu mv mw mx bi translated">如果你不像Java那样经常使用OOP，那么DI就不是最好的选择。而且Javascript不是Java。Javascript有自己的方式。</li><li id="6c0c" class="mp mq iq jw b jx ot kb ou kf ov kj ow kn ox kr mu mv mw mx bi translated">可能你已经在使用模仿库，也可能你想模仿<code class="fe oq or os nd b">fs</code>或<code class="fe oq or os nd b">http</code>或<code class="fe oq or os nd b">fetch</code>或<code class="fe oq or os nd b">path</code>或<code class="fe oq or os nd b">ezyme</code>或任何其他库。不是服务提供商。</li><li id="3c96" class="mp mq iq jw b jx ot kb ou kf ov kj ow kn ox kr mu mv mw mx bi translated">我不知道JS有什么真正好的DI/IoT实现</li><li id="b38e" class="mp mq iq jw b jx ot kb ou kf ov kj ow kn ox kr mu mv mw mx bi translated">整个JS/NodeJS生态系统对DI不屑一顾，所以你必须使用“通向DI的javascript方式”——内部模块系统。</li></ol><h1 id="35d0" class="no ni iq bd np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe of og oh oi oj ok bi translated">在NodeJS里嘲讽。</h1><p id="6a17" class="pw-post-body-paragraph ju jv iq jw b jx ol jz ka kb om kd ke kf on kh ki kj oo kl km kn op kp kq kr ij bi translated">嘲讽是非常固执己见的事情。“嘲讽是一种代码气味”，你知道吗？</p><p id="eb3c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">带着“坏”的嘲讽，走上通往地狱的道路是相当容易的。</p><blockquote class="ma"><p id="60ce" class="mb mc iq bd md me mf mg mh mi mj kr dk translated">难以模仿的代码很难测试。</p></blockquote><p id="c5c2" class="pw-post-body-paragraph ju jv iq jw b jx mk jz ka kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr ij bi translated">testDouble作者贾斯汀·瑟尔斯的下一个视频可能会透露一些关于问题、解决方案和嘲笑自己的信息。这是我见过的最好的模拟教程。</p><figure class="my mz na nb gt jr"><div class="bz fp l di"><div class="pa pb l"/></div></figure><p id="6864" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">但是在现实中，模仿的主要问题是你用来模仿的工具。</p><h1 id="f0d8" class="no ni iq bd np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe of og oh oi oj ok bi translated">工具…</h1><p id="5a90" class="pw-post-body-paragraph ju jv iq jw b jx ol jz ka kb om kd ke kf on kh ki kj oo kl km kn op kp kq kr ij bi translated">然后我第一次遇到库/文件级别的嘲讽，我很震惊。</p><blockquote class="ls lt lu"><p id="a068" class="ju jv lv jw b jx jy jz ka kb kc kd ke lw kg kh ki lx kk kl km ly ko kp kq kr ij bi translated">这是proxyquire。太丑了！它不起作用。</p></blockquote><p id="5762" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我不知道为什么——这是个问题。<em class="lv">零反馈</em>库。proxyquire并不是唯一一个被嘲笑的人，另一个流行的是没有正确地做一些事情，他们知道他们的问题，但不打算解决它们。</p><ol class=""><li id="4f4f" class="mp mq iq jw b jx jy kb kc kf mr kj ms kn mt kr mu mv mw mx bi translated">如何使用Proxyquite模拟天网</li></ol><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="ab84" class="nh ni iq nd b gy nj nk l nl nm">const SkyNetUnderTest <strong class="nd ir">=</strong> proxyquire('./SkyNet', {<br/> 'very-actions'<strong class="nd ir">:</strong> { destroyAllHumans: actionStub }<br/>});</span></pre><p id="a244" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">一句台词，就搞定了。Proxyquire完美地模仿了<em class="lv">直接使用的依赖关系</em>。不太适合嘲笑其他任何东西。</p><p id="15f2" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">2.如何用嘲弄来嘲弄天网？</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="027f" class="nh ni iq nd b gy nj nk l nl nm">mockery.registerMock({'<!-- -->very-actions'<strong class="nd ir">:</strong> { destroyAllHumans: actionStub })<br/>mockery.enabled();<br/>const SkyNetUnderTest = require('./SkyNet');<br/>mockery.disable();</span></pre><p id="0000" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">有点啰嗦，但还好。和“类型化”的现成模拟。嘲讽完美的嘲讽出一切，但绝对不适合嘲讽<em class="lv">直接用的</em> deps，只要不是用嵌套深度来区分。</p><p id="d1ac" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">3.玩笑？</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="347c" class="nh ni iq nd b gy nj nk l nl nm">import SkyNet from './SkyNet';<br/>jest.mock('very-actions');</span></pre><p id="9b51" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">然后<code class="fe oq or os nd b">very-actions</code>将被自动模仿取代。和嘲笑一样的问题——到处嘲笑一切。需要笑话(这有问题吗？)</p><p id="db3a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">4.TestDouble？</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="c817" class="nh ni iq nd b gy nj nk l nl nm">td.replace('very-actions');<br/>const SkyNet = require('./SkyNet');</span></pre><p id="d35a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">同样的自动手枪。多年来不支持部分嘲讽。不是很广泛使用。</p><h2 id="5cbb" class="nh ni iq bd np pc pd dn nt pe pf dp nx kf pg ph ob kj pi pj of kn pk pl oj pm bi translated">选哪个？选哪个？</h2><p id="b21f" class="pw-post-body-paragraph ju jv iq jw b jx ol jz ka kb om kd ke kf on kh ki kj oo kl km kn op kp kq kr ij bi translated">我发现要有好的解决方案，我必须自己动手。像往常一样。</p><p id="d43c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这些努力的结果是作为概念证明的<a class="ae lz" href="https://github.com/theKashey/resolveQuire" rel="noopener ugc nofollow" target="_blank">resolve require</a>、<a class="ae lz" href="https://github.com/thekashey/proxyquire" rel="noopener ugc nofollow" target="_blank"> proxyquire2 </a>和<a class="ae lz" href="https://github.com/theKashey/proxyquire-webpack-alias" rel="noopener ugc nofollow" target="_blank">proxy quire-web pack-alias</a>。</p><blockquote class="ls lt lu"><p id="a053" class="ju jv lv jw b jx jy jz ka kb kc kd ke lw kg kh ki lx kk kl km ly ko kp kq kr ij bi translated">如果你喜欢proxyquire，但是想要更好的体验，你应该检查proxyquire2。它不是零反馈库。</p></blockquote><p id="ee84" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我分叉proxyquire是因为一个原因——我希望在<code class="fe oq or os nd b">normal</code>代码和<code class="fe oq or os nd b">tests</code>中有相同的模块名。但是如果在普通代码中我使用webpack-aliases，在测试中我必须使用node.js相对路径。我经常犯错。并且经常只是开始随机改变模拟名字，直到一个通过。而且我经常<code class="fe oq or os nd b">mock</code>一些东西，而不是嘲笑任何东西。</p><blockquote class="ls lt lu"><p id="c295" class="ju jv lv jw b jx jy jz ka kb kc kd ke lw kg kh ki lx kk kl km ly ko kp kq kr ij bi translated">proxyquire2解决了我所有的问题，它可以用一种更聪明的方式模拟文件，它还用非常有用的特性扩展了原始API，比如noUnusedStubs。不幸的是,“真实的”proxyquire拒绝了那个<a class="ae lz" href="https://github.com/thlorenz/proxyquire/pull/164" rel="noopener ugc nofollow" target="_blank"> PR </a>。</p></blockquote><p id="d2fa" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">但是，在我完成proxyquire2之后，我了解到…</p><h1 id="2014" class="no ni iq bd np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe of og oh oi oj ok bi translated">那不是一条正确的路</h1><p id="ab28" class="pw-post-body-paragraph ju jv iq jw b jx ol jz ka kb om kd ke kf on kh ki kj oo kl km kn op kp kq kr ij bi translated">我只是停止对抗代理查询，停止寻找其他解决方案。每个图书馆都有点不同。</p><ul class=""><li id="e307" class="mp mq iq jw b jx jy kb kc kf mr kj ms kn mt kr pn mv mw mx bi translated">proxyquire是易于使用，并且容易出错的库</li><li id="1a55" class="mp mq iq jw b jx ot kb ou kf ov kj ow kn ox kr pn mv mw mx bi translated">嘲弄是强大的、脆弱的和“低信心”的库。</li><li id="2c5f" class="mp mq iq jw b jx ot kb ou kf ov kj ow kn ox kr pn mv mw mx bi translated">诡辩，双重嘲讽，太简单了。</li><li id="41a5" class="mp mq iq jw b jx ot kb ou kf ov kj ow kn ox kr pn mv mw mx bi translated">网络包东西？仅适用于webpack，因为“node”仅适用于nodejs。</li><li id="c6b4" class="mp mq iq jw b jx ot kb ou kf ov kj ow kn ox kr pn mv mw mx bi translated">玩笑。嘲笑？只是为了开玩笑。但它实际上是超级(但不同)可用的。</li></ul><h2 id="803c" class="nh ni iq bd np pc pd dn nt pe pf dp nx kf pg ph ob kj pi pj of kn pk pl oj pm bi translated">你想要什么？</h2><ul class=""><li id="9ac5" class="mp mq iq jw b jx ol kb om kf po kj pp kn pq kr pn mv mw mx bi translated">易于代理的查询，但是“安全”</li><li id="15e3" class="mp mq iq jw b jx ot kb ou kf ov kj ow kn ox kr pn mv mw mx bi translated">强大得可笑，但“可控”</li><li id="fba5" class="mp mq iq jw b jx ot kb ou kf ov kj ow kn ox kr pn mv mw mx bi translated">“右派”一样狡辩，但不那么简单？</li><li id="2512" class="mp mq iq jw b jx ot kb ou kf ov kj ow kn ox kr pn mv mw mx bi translated">node和webpack能有相同的语法吗？</li></ul><p id="8f3b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">所以我没有找到任何其他方法，只是从头开始开发一个新的。</p><h2 id="d625" class="nh ni iq bd np pc pd dn nt pe pf dp nx kf pg ph ob kj pi pj of kn pk pl oj pm bi translated"><a class="ae lz" href="https://github.com/theKashey/rewiremock" rel="noopener ugc nofollow" target="_blank">rewiremock</a>—node . js(和webpack，和typescript，和flow)的最佳模仿库</h2><p id="c545" class="pw-post-body-paragraph ju jv iq jw b jx ol jz ka kb om kd ke kf on kh ki kj oo kl km kn op kp kq kr ij bi translated">为什么我如此厚颜无耻地称它为<code class="fe oq or os nd b">best</code>？我建造它已经一年了，每天我都问自己——我能称它为“最好的”吗？我应该吗？答案仍然是——是的。</p><p id="8dce" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">rewiremock`s的API有点类似于mockery，有点proxyquire的味道。</p><blockquote class="ls lt lu"><p id="3145" class="ju jv lv jw b jx jy jz ka kb kc kd ke lw kg kh ki lx kk kl km ly ko kp kq kr ij bi translated">我只是综合了其他解决方案的优点。</p></blockquote><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="46cc" class="nh ni iq nd b gy nj nk l nl nm">import rewiremock from 'rewiremock';<br/>...<br/><br/>// totally mock `fs` with your stub <br/><em class="lv">rewiremock</em>('fs')<br/>   .with({<br/>       readFile: yourFunction<br/>   });<br/> <br/>// replace module path, by another module <br/><em class="lv">rewiremock</em>('path')<br/>   .by('path-mock');</span><span id="6513" class="nh ni iq nd b gy nn nk l nl nm">// replace module path, by generated module<br/><em class="lv">rewiremock</em>('path')<br/>   .by(() =&gt; generateMockedPath());<br/> <br/>// replace default export of ES6 module <br/><em class="lv">rewiremock</em>('reactComponent')<br/>   .withDefault(MockedComponent)</span><span id="9743" class="nh ni iq nd b gy nn nk l nl nm">// replace "the real" file by mocked double, maintaining exports.<br/><em class="lv">rewiremock</em>('reactComponent')<br/>   .calledFromMock() // mocking a "first-level"(like proxyquire)<br/>   .mockThrough()</span><span id="56b2" class="nh ni iq nd b gy nn nk l nl nm">// replace only part of some library and keep the rest <br/><em class="lv">rewiremock</em>('someLibrary')<br/>   .callThought() <br/>   .with({<br/>       onlyOneMethod<br/>   })<br/>   .toBeUsed()</span></pre><p id="1ada" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">您可以预定义模拟，例如模拟fetch/network/fs，或者为单个模拟回合指定它们。</p><p id="d460" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这也是唯一一个可以轻松处理新的es6动态导入的版本。</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="56e9" class="nh ni iq nd b gy nj nk l nl nm">rewiremock.around(() =&gt; import('somemodule')).then(mockedModule =&gt; doSomething)</span></pre><p id="5c7f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">但是只要你必须为proxyquire定义所有的mock，并且所有的mock都必须在之前定义，在rewiremock的情况下，你可以使用。在范围内或周围。</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="9d23" class="nh ni iq nd b gy nj nk l nl nm">rewiremock.around(<br/>    () =&gt; import('somemodule').then ( you got a mocked module )<br/>    (mock) =&gt; { <br/>        addPlugin(nodePlugin);<br/><br/>        mock('./lib/a/foo').with(() =&gt; 'aa');<br/>        mock('./lib/a/../b/bar').with(() =&gt; 'bb');<br/>        mock('./lib/a/../b/baz').with(() =&gt; 'cc');<br/>    }<br/>).then ( you got a mocked module )<br/>// everything was cleared...</span></pre><p id="b694" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">rewiremock也是非常缓存友好的，所有其他解决方案都是不友好的。所以它跑得更快。</p><p id="6d9c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">正如你所看到的——让你尝试比在一个单独的主题中描述功能更容易。</p><p id="07c3" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">但是rewiremock的主要特性，称之为单元测试最佳的主要原因是…</p><h1 id="19ea" class="no ni iq bd np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe of og oh oi oj ok bi translated">隔离</h1><p id="a695" class="pw-post-body-paragraph ju jv iq jw b jx ol jz ka kb om kd ke kf on kh ki kj oo kl km kn op kp kq kr ij bi translated">有两种类型的隔离:</p><p id="cf08" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">1.第一个确保你没有调用任何东西<code class="fe oq or os nd b">unexpected</code>。</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="071a" class="nh ni iq nd b gy nj nk l nl nm"><strong class="nd ir">import </strong>{action1} <strong class="nd ir">from </strong>'./actions';<br/><br/><strong class="nd ir">export default </strong>() =&gt; {<br/>    action1();<br/>}</span></pre><p id="4944" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">您用动作1和动作2模仿了动作。并进行了测试。一切正常。</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="8c6e" class="nh ni iq nd b gy nj nk l nl nm"><strong class="nd ir">import </strong>{action1} <strong class="nd ir">from </strong>'./actions';<br/><strong class="nd ir">import </strong>{action2} <strong class="nd ir">from </strong>'./new-actions';<br/><br/><strong class="nd ir">export default </strong>() =&gt; {<br/>    action1();<br/>    action2();<br/>}</span></pre><p id="7062" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">接下来，您添加了一个新的依赖项。一切都还好。测试时，动作2<em class="lv">不可见</em>。</p><p id="0064" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">rewiremock。<strong class="jw ir">隔离</strong>()会<code class="fe oq or os nd b">fix</code>它，并且会抛出一个错误或者你要求的东西没有被嘲笑，或者没有被列为<code class="fe oq or os nd b">passBy.</code></p><blockquote class="ls lt lu"><p id="4da9" class="ju jv lv jw b jx jy jz ka kb kc kd ke lw kg kh ki lx kk kl km ly ko kp kq kr ij bi translated">如果passBy列表中列出了某个模块，则它需要的所有模块也会在其中列出。<a class="ae lz" href="https://github.com/mfncooper/mockery/issues/59" rel="noopener ugc nofollow" target="_blank">为什么它如此重要？</a></p></blockquote><p id="f668" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">2.还有一种相反的情况—当您不添加导入，而是删除导入时。在某些情况下，测试仍然是绿色的。这是“<strong class="jw ir">反向隔离</strong>”。</p><p id="5510" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">嘲笑。<strong class="jw ir">待使用的</strong>()，或者插件。<strong class="jw ir">使用默认</strong>将<code class="fe oq or os nd b">fix</code>它。如果mock是由not used by fact创建的— rewiremock将抛出一个错误。</p><p id="0bc5" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果你移动了文件，你打错了字，你的插件产生了错误的文件名——你会得到一个异常。</p><blockquote class="ls lt lu"><p id="1d87" class="ju jv lv jw b jx jy jz ka kb kc kd ke lw kg kh ki lx kk kl km ly ko kp kq kr ij bi translated">依我看，这种隔离必须始终启用。它拯救生命，引导你找到真正的原因，为什么你们间谍没有被召唤。</p></blockquote><p id="3497" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">最后，但同样重要的是</p><h1 id="4a3f" class="no ni iq bd np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe of og oh oi oj ok bi translated">你控制一切</h1><p id="755c" class="pw-post-body-paragraph ju jv iq jw b jx ol jz ka kb om kd ke kf on kh ki kj oo kl km kn op kp kq kr ij bi translated">开始时，我只希望使用我看到的模块名——由webpack别名驱动。</p><p id="a174" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在你可以通过插件系统控制名字的生成。默认情况下，您有:</p><ol class=""><li id="48a6" class="mp mq iq jw b jx jy kb kc kf mr kj ms kn mt kr mu mv mw mx bi translated">Nodejs插件。只是将模拟名转换为真实文件名，否则会失败。</li><li id="58a8" class="mp mq iq jw b jx ot kb ou kf ov kj ow kn ox kr mu mv mw mx bi translated">WebpackAlias插件——相同，但有强大的别名功能。</li><li id="3407" class="mp mq iq jw b jx ot kb ou kf ov kj ow kn ox kr mu mv mw mx bi translated">相对-仅将提供的名称与传入的名称匹配。所以如果你想嘲笑。/foo —它会嘲笑一切。/foo。</li><li id="19dd" class="mp mq iq jw b jx ot kb ou kf ov kj ow kn ox kr mu mv mw mx bi translated">其余的插件就像一个孩子，这使得只有一级儿童被嘲笑。感谢上帝，这是亲戚用的。</li></ol><p id="6b1d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">你也可以控制模仿是如何产生的，或者如何消亡的。简单且可扩展。</p><h1 id="fabf" class="no ni iq bd np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe of og oh oi oj ok bi translated">你可以嘲笑一切</h1><p id="0863" class="pw-post-body-paragraph ju jv iq jw b jx ol jz ka kb om kd ke kf on kh ki kj oo kl km kn op kp kq kr ij bi translated"><strong class="jw ir">例如，Proxyquire </strong>将仅模拟直接子级(不带全局)，与inject相同。</p><p id="191b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">嘲讽</strong>会嘲讽任何依赖，只是因为它也会擦除整个缓存。</p><p id="1646" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir"> Rewiremock </strong>起作用<code class="fe oq or os nd b">perfectly</code> —启用时，它将从缓存中进行模仿和擦除。然后—擦他们的<code class="fe oq or os nd b">parents</code>。然后——父母的父母。</p><p id="e94f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">然后你可以像嘲笑一样嘲笑一切，但你没有抹去一切。</p><p id="a716" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">很多人会认为，这不是一个好主意——能够重写任何东西……但是你实际上能够在项目范围内模仿<code class="fe oq or os nd b">fetch</code>,文件系统，数据库等等。</p><p id="8fd2" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">假设你有模块1。它使用模块2和模块3。模块3也在使用模块2。</p><p id="0a78" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">所以，如果你要模仿模块2，你可能会用<code class="fe oq or os nd b">new</code>模块2得到模块1，用<code class="fe oq or os nd b">old</code>模块2得到模块3。也可能不会。看情况。并且它是顺序独立的。</p><p id="1443" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在rewiremock中，所有的模拟都将从缓存中删除，并重新加载。然后你可以控制你是否应该通过插件来模仿一些模仿。</p><p id="f90b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">插件<code class="fe oq or os nd b">childOnly</code>或<code class="fe oq or os nd b">relative</code>只会模仿一级依赖者。例如-从模块1导入的模块2。如果模块3是在之前导入的，那么你将得到带有<code class="fe oq or os nd b">old</code>模块2的模块3，如果模块3是在之后导入的，那么将得到带有<code class="fe oq or os nd b">new</code>模块2的模块3。</p><p id="d3c4" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我没有答案。至少它是顺序依赖的，稳定的。</p><h1 id="4b46" class="no ni iq bd np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe of og oh oi oj ok bi translated">主要观点</h1><p id="03e5" class="pw-post-body-paragraph ju jv iq jw b jx ol jz ka kb om kd ke kf on kh ki kj oo kl km kn op kp kq kr ij bi translated">rewiremock可以给你的测试带来更多的信心。它可以再次检查你是否已经模仿了你要模仿的东西，使用那个模仿，创造你需要的模仿。从“嘲弄的气味”中去掉“气味”</p><div class="ks kt gp gr ku kv"><a href="https://medium.com/techtrument/unit-tests-are-production-code-d256d86f073e" rel="noopener follow" target="_blank"><div class="kw ab fo"><div class="kx ab ky cl cj kz"><h2 class="bd ir gy z fp la fr fs lb fu fw ip bi translated">单元测试是生产代码</h2><div class="lc l"><h3 class="bd b gy z fp la fr fs lb fu fw dk translated">但是如果是这样，谁来测试你的测试呢？</h3></div><div class="ld l"><p class="bd b dl z fp la fr fs lb fu fw dk translated">medium.com</p></div></div><div class="le l"><div class="pr l lg lh li le lj js kv"/></div></div></a></div><h1 id="257b" class="no ni iq bd np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe of og oh oi oj ok bi translated">结论</h1><p id="0aa5" class="pw-post-body-paragraph ju jv iq jw b jx ol jz ka kb om kd ke kf on kh ki kj oo kl km kn op kp kq kr ij bi translated">嘲讽只会让你的测试停滞不前，并将你的代码库与<code class="fe oq or os nd b">outside</code>隔离开来。</p><p id="4a27" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">您将在编写测试期间花费更少的时间，并且在重构期间花费更少的时间。</p><p id="11a2" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">唯一持久的是——选择一种嘲笑的方式，不要忘记DI。</p><div class="ks kt gp gr ku kv"><a href="https://github.com/theKashey/rewiremock" rel="noopener  ugc nofollow" target="_blank"><div class="kw ab fo"><div class="kx ab ky cl cj kz"><h2 class="bd ir gy z fp la fr fs lb fu fw ip bi translated">theKashey/rewiremock</h2><div class="lc l"><h3 class="bd b gy z fp la fr fs lb fu fw dk translated">rewiremock——在Node.js或webpack环境中模拟依赖关系的正确方法。</h3></div><div class="ld l"><p class="bd b dl z fp la fr fs lb fu fw dk translated">github.com</p></div></div><div class="le l"><div class="ps l lg lh li le lj js kv"/></div></div></a></div><div class="ks kt gp gr ku kv"><a href="https://github.com/thlorenz/proxyquire" rel="noopener  ugc nofollow" target="_blank"><div class="kw ab fo"><div class="kx ab ky cl cj kz"><h2 class="bd ir gy z fp la fr fs lb fu fw ip bi translated">thlorenz/proxyquire</h2><div class="lc l"><h3 class="bd b gy z fp la fr fs lb fu fw dk translated">proxy quire-proxy nodejs需要在测试期间覆盖依赖关系。</h3></div><div class="ld l"><p class="bd b dl z fp la fr fs lb fu fw dk translated">github.com</p></div></div><div class="le l"><div class="pt l lg lh li le lj js kv"/></div></div></a></div><div class="ks kt gp gr ku kv"><a href="https://github.com/mfncooper/mockery" rel="noopener  ugc nofollow" target="_blank"><div class="kw ab fo"><div class="kx ab ky cl cj kz"><h2 class="bd ir gy z fp la fr fs lb fu fw ip bi translated">MFN Cooper/嘲弄</h2><div class="lc l"><h3 class="bd b gy z fp la fr fs lb fu fw dk translated">mockss用Node.js简化mock的使用</h3></div><div class="ld l"><p class="bd b dl z fp la fr fs lb fu fw dk translated">github.com</p></div></div><div class="le l"><div class="pu l lg lh li le lj js kv"/></div></div></a></div><div class="ks kt gp gr ku kv"><a href="https://github.com/speedskater/babel-plugin-rewire" rel="noopener  ugc nofollow" target="_blank"><div class="kw ab fo"><div class="kx ab ky cl cj kz"><h2 class="bd ir gy z fp la fr fs lb fu fw ip bi translated">速滑/巴别塔-插件-重新布线</h2><div class="lc l"><h3 class="bd b gy z fp la fr fs lb fu fw dk translated">这是一个巴别塔插件，增加了重新连接模块依赖的能力。这使模拟模块能够…</h3></div><div class="ld l"><p class="bd b dl z fp la fr fs lb fu fw dk translated">github.com</p></div></div><div class="le l"><div class="pv l lg lh li le lj js kv"/></div></div></a></div><div class="ks kt gp gr ku kv"><a href="https://github.com/plasticine/inject-loader" rel="noopener  ugc nofollow" target="_blank"><div class="kw ab fo"><div class="kx ab ky cl cj kz"><h2 class="bd ir gy z fp la fr fs lb fu fw ip bi translated">橡皮泥/注射装载机</h2><div class="lc l"><h3 class="bd b gy z fp la fr fs lb fu fw dk translated">inject-loader -:注射器:一个Webpack加载器，用于通过模块的依赖关系将代码注入到模块中。</h3></div><div class="ld l"><p class="bd b dl z fp la fr fs lb fu fw dk translated">github.com</p></div></div><div class="le l"><div class="pw l lg lh li le lj js kv"/></div></div></a></div><p id="b8df" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">但是，我要说的是:</p><blockquote class="ls lt lu"><p id="ab1f" class="ju jv lv jw b jx jy jz ka kb kc kd ke lw kg kh ki lx kk kl km ly ko kp kq kr ij bi translated">他们都能够模仿/重新布线/代理/注入依赖性。</p><p id="97a2" class="ju jv lv jw b jx jy jz ka kb kc kd ke lw kg kh ki lx kk kl km ly ko kp kq kr ij bi translated">他们中的大多数人无法做其他任何事情。</p><p id="08ad" class="ju jv lv jw b jx jy jz ka kb kc kd ke lw kg kh ki lx kk kl km ly ko kp kq kr ij bi translated">它们不会帮助你使单元测试更加“单元化”。</p></blockquote><p id="e439" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">唯一的(imho)是带隔离的嘲弄，带反向隔离的代理查询，以及重新嘲弄。</p><p id="58b2" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果他们都嘲笑，结果是一样的。为什么不根据其他功能进行选择？</p><p id="ad1b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">PS:如果你正在寻找非node-js环境，例如webpack，仍然选择rewiremock。</p><h1 id="44df" class="no ni iq bd np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe of og oh oi oj ok bi translated">PS:</h1><p id="7205" class="pw-post-body-paragraph ju jv iq jw b jx ol jz ka kb om kd ke kf on kh ki kj oo kl km kn op kp kq kr ij bi translated">等到rewiremock继续进化的时候。现在它可以在nodejs(mocha甚至Jest)或者浏览器(webpack)环境中运行。它可以为你所有的模拟提供类型检查。它能做你需要的任何事情。</p></div></div>    
</body>
</html>