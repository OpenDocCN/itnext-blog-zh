<html>
<head>
<title>Auditing containers with osquery</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用osquery审计容器</h1>
<blockquote>原文：<a href="https://itnext.io/auditing-containers-with-osquery-389636f8c420?source=collection_archive---------2-----------------------#2019-01-29">https://itnext.io/auditing-containers-with-osquery-389636f8c420?source=collection_archive---------2-----------------------#2019-01-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="4403" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用Docker在生产环境中运行容器时，糟糕的配置很容易导致易受攻击的环境:特权容器、以root用户身份运行的容器内的进程或者缺乏针对安全限制的AppArmor配置文件都是常见的例子。利用容器中的应用程序漏洞的攻击者可以利用这种限制来访问主机或网络上的其他服务器。使用osquery，我们将像查询关系数据库一样查询Docker守护进程，并快速识别这些安全缺陷。</p><h1 id="2aa0" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">osquery快速介绍</h1><p id="a35c" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">📌<em class="kl">如果您已经熟悉osquery，请随意跳到下一章“休斯顿，我们有一个易受攻击的容器”，从实际例子开始。</em></p><p id="9733" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae lp" href="https://osquery.io/" rel="noopener ugc nofollow" target="_blank"> osquery </a>框架将您的操作系统<strong class="jp ir">公开为一个关系数据库</strong>，您可以在其上执行SQL查询来查找关于您系统的特定数据。诸如用户、网络路由、CPU和Docker容器之类的操作系统概念以可查询的表格的形式公开。这种创新的方法允许使用一种单一的查询语言，使用SQL来选择、过滤和聚集关于操作系统及其周围组件的数据。</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div class="gh gi lq"><img src="../Images/a0ad38de43cc2a0a5e2907e425899231.png" data-original-src="https://miro.medium.com/v2/resize:fit:1140/format:webp/1*s8g8eHvy7lSW4WAsJPq_zQ.png"/></div></figure><p id="39c7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">osquery的一个主要优势是它的<strong class="jp ir">广泛的支持</strong>:它可以在每一个主要的操作系统(Linux、Windows、macOS甚至FreeBSD)上执行，并提供各种现成的表来查询您的操作系统(服务、用户、硬件、内核……)。是的，这还包括容器、图像、网络和卷等概念的Docker表。</p><p id="cbd8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在下面的例子中，我们使用<a class="ae lp" href="https://osquery.readthedocs.io/en/stable/introduction/using-osqueryi/" rel="noopener ugc nofollow" target="_blank"> osquery交互式shell </a>来检索系统中使用SQL查询的第一个用户。请注意，osquery提供的交互式shell是一个独立的CLI工具(它只使用内存数据库)，因此非常适合进行查询实验。</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi ly"><img src="../Images/97efacbb9a8559f129e70849f58e0bfb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*1_7aRFqESSuODeXWc3GGYA.gif"/></div></div><figcaption class="md me gj gh gi mf mg bd b be z dk translated">使用osquery交互式shell的查询示例</figcaption></figure><p id="1ecf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当调用<code class="fe mh mi mj mk b">user</code>表时，实时执行相应的操作系统调用来检索系统上的用户，SQL引擎根据查询<code class="fe mh mi mj mk b">SELECT * FROM users LIMIT 1</code>处理您的数据。当使用osquery编写SQL时，SQL语言实际上是SQLite的超集，其他动词如<code class="fe mh mi mj mk b">INSERT</code>、<code class="fe mh mi mj mk b">UPDATE</code>或<code class="fe mh mi mj mk b">DELETE</code>对您的操作系统没有影响(因此查询<code class="fe mh mi mj mk b">DELETE FROM users</code>不会删除您系统中的用户)。</p></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="8e81" class="km kn iq bd ko kp ms kr ks kt mt kv kw kx mu kz la lb mv ld le lf mw lh li lj bi translated">休斯顿，我们有一个易受攻击的集装箱</h1><p id="2eed" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">📌<em class="kl">对于本文的下一部分，我强烈建议在您的工作站上安装Docker和osquery，以便在您自己的操作系统上尝试这些示例。这将使结果更有意义，并有助于理解osquery是如何工作的。</em></p><p id="5787" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们现在将切换到一个实际的例子来演示osquery如何帮助我们审计一些Docker容器的安全缺陷。在这个例子中，我们有一个运行Docker守护进程的Linux服务器。让我们假设有人使用下面的命令在我们的服务器上运行一个新容器:</p><pre class="lr ls lt lu gt mx mk my mz aw na bi"><span id="ab3e" class="nb kn iq mk b gy nc nd l ne nf">docker run -d --name web01 --privileged --user root nginx:latest</span></pre><p id="edf4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们现在在系统上有一个名为<code class="fe mh mi mj mk b">web01</code>的NGINX容器，它以root用户的特权模式运行，没有任何安全约束，比如AppArmor。换句话说，容器现在可以访问所有内核功能，并且可以做几乎所有主机可以做的事情。因此，这个容器<code class="fe mh mi mj mk b">web01</code>是一个主要的安全漏洞，我们现在将使用osquery追踪它。</p><p id="fba2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Osquery为Docker组件定义了下面的<strong class="jp ir"> SQL表，这对我们的审计很有用:<code class="fe mh mi mj mk b">docker_containers</code>列出了主机上所有没有停止或终止的容器，<code class="fe mh mi mj mk b">docker_images</code>提供了存储在服务器上的所有图像的视图，<code class="fe mh mi mj mk b">docker_container_processes</code>深入到一个特定的容器中，列出了他所有正在运行的进程。</strong></p><p id="0d95" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">📌<em class="kl">还有更多的可用表，要深入了解，您可以参考</em> <a class="ae lp" href="https://osquery.io/schema/" rel="noopener ugc nofollow" target="_blank"> <em class="kl">完整osquery表参考</em> </a> <em class="kl">或使用osquery交互shell中的</em> <code class="fe mh mi mj mk b"><em class="kl">.tables</em></code> <em class="kl">命令。</em></p><h1 id="75d5" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">查询Docker容器</h1><figure class="lr ls lt lu gt lv"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="16bb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们从第一个审计例子开始。使用osquery交互式shell和<code class="fe mh mi mj mk b">docker_containers</code>表，我们现在将执行我们的第一个SQL查询来跟踪容器，比如作为<strong class="jp ir">特权</strong>运行的<code class="fe mh mi mj mk b">web01</code>。该查询将主机上运行的容器的名称、映像和状态作为特权给出。</p><figure class="lr ls lt lu gt lv"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="3ad4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将继续使用<code class="fe mh mi mj mk b">docker_containers</code>表来<strong class="jp ir">跟踪环境变量</strong>。使用带有<code class="fe mh mi mj mk b">%</code>的SQL <code class="fe mh mi mj mk b">LIKE</code>语法，我们可以检查包含容器中所有可用环境变量的整个<code class="fe mh mi mj mk b">env_variables</code>列。在上面的查询中，我们将只匹配具有<code class="fe mh mi mj mk b">NGINX_VERSION</code>环境变量的容器。这是一个非常简单的例子，但是我们也可以跟踪具有<code class="fe mh mi mj mk b">PASSWORD</code>、<code class="fe mh mi mj mk b">SECRET</code>或<code class="fe mh mi mj mk b">TOKEN</code>变量的容器，从而导致敏感信息的潜在泄露。</p><figure class="lr ls lt lu gt lv"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="28f7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在生产中运行容器时，Docker还提供了使用<a class="ae lp" href="https://docs.docker.com/engine/security/apparmor/" rel="noopener ugc nofollow" target="_blank"> AppArmor </a>增强安全性的可能性。使用AppArmor，您可以为每个容器定义并实施一个安全配置文件:这将限制容器的能力，并确保它只能访问有限的资源集。上面定义的SQL查询使用<code class="fe mh mi mj mk b">security_options</code>列跟踪所有<strong class="jp ir">没有AppArmor概要文件</strong>的容器。</p><h1 id="9471" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">更多高级查询</h1><figure class="lr ls lt lu gt lv"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="5fdf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用Docker的一个重要方面是确保只有有限的<strong class="jp ir">用户组可以访问守护进程</strong>。对于这个稍微复杂一点的查询，我们将使用包含所有用户的<code class="fe mh mi mj mk b">users</code>表、<code class="fe mh mi mj mk b">groups</code>表和<code class="fe mh mi mj mk b">user_groups</code>表，它们将用户与其对应的组进行映射。如您所见，我们选择名为<code class="fe mh mi mj mk b">docker</code>的组，并列出属于该组的所有用户名。</p><p id="325e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个查询强调了使用osquery的一个主要优势:我们可以轻松地从不同的表中聚集数据，并快速获得关于我们系统的不同概念的更多见解。</p><figure class="lr ls lt lu gt lv"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="898f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我们已经在前面的查询中使用了子查询和SQL join来获得关于多个表的更多信息，我们将继续沿着这条路径，跟踪使用根进程运行的<strong class="jp ir">容器。使用osquery表<code class="fe mh mi mj mk b">docker_container_processes</code>，我们可以找到使用root用户运行NGINX进程的<code class="fe mh mi mj mk b">web01</code>容器。</strong></p><p id="4979" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在osquery中，有些表需要一个参数才能工作:例如,<code class="fe mh mi mj mk b">file</code>表需要一个<code class="fe mh mi mj mk b">path</code>参数来避免对文件系统的彻底探索。因为Docker进程表也需要一个容器<code class="fe mh mi mj mk b">id</code>参数才能工作，所以我们使用了一个选择所有容器标识符的子查询。</p><figure class="lr ls lt lu gt lv"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="298a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后但同样重要的是，我们还可以使用<code class="fe mh mi mj mk b">docker_images</code>表列出没有被活动容器使用的<strong class="jp ir">图像。这使我们能够审核并从我们的服务器中删除未使用的映像。根据记录，该查询获取与<code class="fe mh mi mj mk b">docker image prune -a</code>命令相同的图像，但不删除它们。</strong></p></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="a0ba" class="km kn iq bd ko kp ms kr ks kt mt kv kw kx mu kz la lb mv ld le lf mw lh li lj bi translated">下一步是什么？</h1><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi ni"><img src="../Images/dd6dd728b758b4f8c15f9582b9a09f57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WKjNqa6EG6hoPQs0"/></div></div><figcaption class="md me gj gh gi mf mg bd b be z dk translated">照片由<a class="ae lp" href="https://unsplash.com/@chuttersnap?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> chuttersnap </a>在<a class="ae lp" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="d991" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用这些查询，您现在能够审计一些Docker安全配置，并跟踪可能对您的服务器造成危险的容器。</p><p id="fa56" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">尝试改变上面的一些查询，并开始用osquery提供的其他表<a class="ae lp" href="https://osquery.io/schema" rel="noopener ugc nofollow" target="_blank">进行试验。如果您想比Docker审计更进一步，请确保查看osquery文档，它将指导您从基础到更高级的用例。关于</a><a class="ae lp" href="https://osquery.readthedocs.io/en/stable/deployment/anomaly-detection/" rel="noopener ugc nofollow" target="_blank">异常检测</a>和<a class="ae lp" href="https://osquery.readthedocs.io/en/stable/deployment/process-auditing/" rel="noopener ugc nofollow" target="_blank">流程审计</a>的章节对于获得osquery审计的更多见解尤其重要。</p><p id="6042" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">我希望你喜欢这篇文章，并准备好接受更多osquery审计。如果你发现了错误，不要犹豫给我留言或者通过Twitter，希望分享关于这个内容的建议或者问题</em>👍</p></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><p id="b69a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">👏<em class="kl">特别感谢</em> <a class="ae lp" href="https://twitter.com/adematte" rel="noopener ugc nofollow" target="_blank"> <em class="kl">阿诺·德玛特</em> </a> <em class="kl">对本帖的校对。</em></p></div></div>    
</body>
</html>