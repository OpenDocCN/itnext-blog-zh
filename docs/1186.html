<html>
<head>
<title>Structural directives in Angular</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">角度中的结构指令</h1>
<blockquote>原文：<a href="https://itnext.io/angular-structural-directives-b54ea21b39a7?source=collection_archive---------4-----------------------#2018-08-07">https://itnext.io/angular-structural-directives-b54ea21b39a7?source=collection_archive---------4-----------------------#2018-08-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/32d84e33a7226b4470d3f789eaf7f38e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T4xoFa_YMc6A4ah9ZXdStg.png"/></div></div></figure><blockquote class="jy"><p id="c93d" class="jz ka iq bd kb kc kd ke kf kg kh ki dk translated"><a class="ae kj" href="https://angular.io/guide/structural-directives#what-are-structural-directives" rel="noopener ugc nofollow" target="_blank">负责HTML布局。它们塑造或重新塑造DOM的<em class="kk">结构</em>，通常是通过添加、删除或操作元素。</a></p></blockquote><p id="8583" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ki ij bi translated">结构指令是Angular的一个关键部分，每个人都应该熟悉。它们负责通过添加、删除或更改元素来操作DOM。即使你自己从来没有编写过结构化指令，你也可能经常在你的模板中使用<em class="li"> *ngIf </em>和<em class="li"> *ngFor </em>。星号(*)表示它是一个结构指令。如果你想在继续我们的例子之前阅读更多内容，<a class="ae kj" href="https://angular.io/guide/structural-directives" rel="noopener ugc nofollow" target="_blank"> angular docs </a>提供了一个很好的、详细的解释。</p><p id="b6dd" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh ki ij bi translated">正如我们将在下面的例子中看到的，编写一个结构化的指令是非常容易的。其目的可以从简单的条件呈现(例如，基于用户角色)到在一个范围内迭代或模板内let变量声明。</p><h1 id="c266" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">基础</h1><h2 id="2963" class="mm lp iq bd lq mn mo dn lu mp mq dp ly kw mr ms mc la mt mu mg le mv mw mk mx bi translated">操纵DOM</h2><p id="3ecb" class="pw-post-body-paragraph kl km iq kn b ko my kq kr ks mz ku kv kw na ky kz la nb lc ld le nc lg lh ki ij bi translated">为了让一个指令能够操作DOM，有必要提供一种不需要通过DOM API改变任何东西的方法。在Angular中，这是通过向指令注入一个视图容器引用和一个模板引用来实现的。</p><figure class="nd ne nf ng gt jr"><div class="bz fp l di"><div class="nh ni l"/></div><figcaption class="nj nk gj gh gi nl nm bd b be z dk translated">带有视图容器和模板引用的伪指令示例</figcaption></figure><h2 id="e090" class="mm lp iq bd lq mn mo dn lu mp mq dp ly kw mr ms mc la mt mu mg le mv mw mk mx bi translated">查看容器参考</h2><blockquote class="nn no np"><p id="c382" class="kl km li kn b ko lj kq kr ks lk ku kv nq ll ky kz nr lm lc ld ns ln lg lh ki ij bi translated">表示可以附加一个或多个视图的容器。</p></blockquote><p id="7d52" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh ki ij bi translated">它基本上允许我们操作容器(外部元素包装)并附加在指令内部创建的模板。更多描述见其<a class="ae kj" href="https://angular.io/api/core/ViewContainerRef" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><h2 id="3b98" class="mm lp iq bd lq mn mo dn lu mp mq dp ly kw mr ms mc la mt mu mg le mv mw mk mx bi translated">模板参考</h2><blockquote class="nn no np"><p id="8935" class="kl km li kn b ko lj kq kr ks lk ku kv nq ll ky kz nr lm lc ld ns ln lg lh ki ij bi translated">表示可用于实例化嵌入式视图的嵌入式模板。</p></blockquote><p id="ee39" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh ki ij bi translated">简单地说，这是我们已经把指令放在上面的一个元素。我们在指令中需要这个引用，因为我们几乎总是以某种方式使用模板，要么重复它(<em class="li"> *ngFor </em>)，有条件地显示它(<em class="li"> *ngIf </em>)，要么在悬停时附加另一个元素(<em class="li"> matTooltip </em>)。</p><h2 id="8b20" class="mm lp iq bd lq mn mo dn lu mp mq dp ly kw mr ms mc la mt mu mg le mv mw mk mx bi translated">价值输入</h2><p id="3672" class="pw-post-body-paragraph kl km iq kn b ko my kq kr ks mz ku kv kw na ky kz la nb lc ld le nc lg lh ki ij bi translated">在大多数情况下，我们在指令中输入一些值，这样它就可以在内部使用。例如，要迭代的集合、要评估的条件或用于更具体目的的值。指令的摘要周期也与值的变化联系在一起，所以每次值发生变化时，指令都会被重新评估。</p><p id="7e61" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh ki ij bi translated">并不总是需要输入值；可以注入服务或状态存储，指令可以像组件一样访问这些值。</p><h1 id="9277" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">语境</h1><p id="ded6" class="pw-post-body-paragraph kl km iq kn b ko my kq kr ks mz ku kv kw na ky kz la nb lc ld le nc lg lh ki ij bi translated">每个指令都有自己的上下文。将上下文定义为每个指令的接口是一个很好的实践，因此我们公开什么值是可以理解的。然后这个上下文被用作<em class="li">模板引用</em>的类型，并且当在<em class="li">容器引用</em>上创建嵌入式视图时设置属性。</p><h2 id="f300" class="mm lp iq bd lq mn mo dn lu mp mq dp ly kw mr ms mc la mt mu mg le mv mw mk mx bi translated">公开内部值</h2><p id="8849" class="pw-post-body-paragraph kl km iq kn b ko my kq kr ks mz ku kv kw na ky kz la nb lc ld le nc lg lh ki ij bi translated">有两种可能的方法来公开内部值，以便我们可以在模板中使用它们:一种是在结构中命名变量，另一种是发出一个隐式值。</p><p id="e754" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh ki ij bi translated">例如，<em class="li"> *ngFor </em>指令遍历列表(数组)，在其上下文对象中设置属性并公开当前项目。可以在指令修饰元素范围内的模板中使用公开的值。</p><p id="e049" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh ki ij bi translated">在<em class="li"> *ngFor </em>中，目前有<a class="ae kj" href="https://github.com/angular/angular/blob/master/packages/common/src/directives/ng_for_of.ts#L30...L42" rel="noopener ugc nofollow" target="_blank"> <em class="li"> index </em>，even，<em class="li"> odd </em>，<em class="li"> first </em>，<em class="li"> last </em> </a>上下文变量通过它们的名字导出，还有一个隐式变量表示当前项目，我们可以随意命名。在下面的例子中，是<em class="li">英雄。</em>它应该被赋给上下文<em class="li">$隐式</em>属性。</p><figure class="nd ne nf ng gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nt"><img src="../Images/ef6cc94b8a58168cd386810d58885f70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G2tGR4VZSuW8TFdm7US9BA.png"/></div></div><figcaption class="nj nk gj gh gi nl nm bd b be z dk translated">*ngFor指令中公开的变量的用法</figcaption></figure><h1 id="cc6c" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated"><strong class="ak">让指令</strong></h1><p id="98d8" class="pw-post-body-paragraph kl km iq kn b ko my kq kr ks mz ku kv kw na ky kz la nb lc ld le nc lg lh ki ij bi translated">如果您已经在模板中采用了异步管道的用法，那么您可能会偶然发现这样一个用例，您可以编写如下内容:</p><figure class="nd ne nf ng gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nu"><img src="../Images/6e6cb7f8ee9e5c30664ea892c8ede6fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fN5KOBS0uwU6D-dbdolyew.png"/></div></div><figcaption class="nj nk gj gh gi nl nm bd b be z dk translated">使用异步管道获取用户$数据流的当前值，并将其赋给用户变量</figcaption></figure><p id="e473" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh ki ij bi translated">它允许您重用/共享您用"<em class="li"> as" </em>语法创建的变量中的值。如果您不想多次使用异步管道，这真的很有用，因为它会在每次使用时创建一个订阅。</p><p id="0c0c" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh ki ij bi translated">ngIf指令有两个目的。一个是让我们为异步值创建变量，另一个是如果值为<a class="ae kj" href="https://developer.mozilla.org/en-US/docs/Glossary/Falsy" rel="noopener ugc nofollow" target="_blank"> falsy ( <em class="li"> false，undefined </em>，<em class="li"> null </em>，<em class="li"> 0 </em>，…) </a>，则隐藏/不呈现整个部分。</p><p id="3452" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh ki ij bi translated">但是如果我们想要这个值，即使它是“假的”呢？我们可以利用字母指令。</p><figure class="nd ne nf ng gt jr"><div class="bz fp l di"><div class="nh ni l"/></div><figcaption class="nj nk gj gh gi nl nm bd b be z dk translated">允许输入模板变量的简单字母指令示例</figcaption></figure><p id="dfc0" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh ki ij bi translated">Let指令的上下文有两个属性(如其文档中所述)。然后，这两个属性以不同的语法用于用法示例的HTML模板中的模板变量声明。</p><p id="7de2" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh ki ij bi translated">有些人可能会说，我们应该在<em class="li"> *ngIf </em>中用else语句处理这些情况，是的，对于大多数情况来说，这是一个完全有效的解决方案。好的用例是用某种定制消息处理falsy值。但是并不总是希望或者能够在模板中为falsy和<a class="ae kj" href="https://developer.mozilla.org/en-US/docs/Glossary/Truthy" rel="noopener ugc nofollow" target="_blank"> truthy </a>值分离逻辑，所以使用这样的指令可以使模板更加简单和易读。</p><h1 id="f75a" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">对于每个范围指令</h1><p id="b8b2" class="pw-post-body-paragraph kl km iq kn b ko my kq kr ks mz ku kv kw na ky kz la nb lc ld le nc lg lh ki ij bi translated">模板中的迭代有时需要各种东西。其中之一是可以轻松显示给定数量的元素。一个很好的例子是表格分页或年份选择的数值下拉，可以像下面的例子一样很容易地使用它。</p><figure class="nd ne nf ng gt jr"><div class="bz fp l di"><div class="nh ni l"/></div></figure><h1 id="d5fd" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">代码示例库</h1><p id="e858" class="pw-post-body-paragraph kl km iq kn b ko my kq kr ks mz ku kv kw na ky kz la nb lc ld le nc lg lh ki ij bi translated">所有示例、用法和源代码都在下面的链接中。</p><div class="nv nw gp gr nx ny"><a href="https://github.com/vmasek/ng-beer-directives" rel="noopener  ugc nofollow" target="_blank"><div class="nz ab fo"><div class="oa ab ob cl cj oc"><h2 class="bd ir gy z fp od fr fs oe fu fw ip bi translated">vmasek/ng-啤酒-指令</h2><div class="of l"><h3 class="bd b gy z fp od fr fs oe fu fw dk translated">ngBeer talk的角度指令示例</h3></div><div class="og l"><p class="bd b dl z fp od fr fs oe fu fw dk translated">github.com</p></div></div></div></a></div><figure class="nd ne nf ng gt jr"><div class="bz fp l di"><div class="oh ni l"/></div><figcaption class="nj nk gj gh gi nl nm bd b be z dk translated">我在维也纳会议上关于结构指示的讲话</figcaption></figure></div></div>    
</body>
</html>