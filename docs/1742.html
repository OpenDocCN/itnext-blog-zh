<html>
<head>
<title>Create a High-Availability Kubernetes Cluster on AWS with Kops</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Kops在AWS上创建高可用性Kubernetes集群</h1>
<blockquote>原文：<a href="https://itnext.io/create-a-high-availability-kubernetes-cluster-on-aws-with-kops-c12c6cd4f976?source=collection_archive---------2-----------------------#2019-01-16">https://itnext.io/create-a-high-availability-kubernetes-cluster-on-aws-with-kops-c12c6cd4f976?source=collection_archive---------2-----------------------#2019-01-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/0cf825c31a6ae41693a81ec73b75e0e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*81FEew8y7dvQ_F1v.png"/></div></div></figure><p id="b8a6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">与以前的文章相比，这篇文章更有DevOps的味道，更侧重于灵丹妙药。在本文中，我将展示如何在AWS上轻松运行多区域Kubernetes集群，在这里我们将部署一个Phoenix Chat应用程序。</p><p id="db22" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有很多方法可以在AWS (Amazon Web Services)上部署Kubernetes集群。目前，AWS提供<a class="ae kw" href="https://aws.amazon.com/eks/" rel="noopener ugc nofollow" target="_blank"> EKS，弹性Kubernetes服务</a>，帮助我们部署和管理我们的Kubernetes集群。它的成本是0.20美元/小时，也就是144美元/月:这实际上并不便宜，尤其是如果我们想要运行一个小型集群的话。这不仅仅是成本的问题:我发现EKS仍然太年轻，更喜欢T2的kops。</p><p id="dbd8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kw" href="https://github.com/kubernetes/kops" rel="noopener ugc nofollow" target="_blank">Kops(Kubernetes Operations)</a>，这是一款开源的免费工具，帮助我们在不同的云提供商上轻松部署和管理HA(高可用性)Kubernetes集群。</p><p id="af39" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里我们将重点关注的提供商是AWS。kops非常支持它，让我们能够轻松地将EC2资源(卷、负载平衡器……)集成到我们的Kubernetes集群中。</p><p id="2ab0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一旦在AWS上创建了一个空的高可用性Kubernetes集群，我们将看到如何在开始时部署一个连接到ELB(弹性负载平衡器)的简单nginx服务器，然后部署一个<a class="ae kw" href="https://github.com/poeticoding/phoenix_chat_example" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir"> Phoenix Chat </strong>示例</a> <strong class="ka ir">应用程序</strong>。我们还将了解为什么横向扩展聊天应用程序不能开箱即用。</p><h2 id="58f5" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">高可用性集群</h2><p id="83f3" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">本文的目标是创建一个HA Kubernetes集群，这意味着我们希望有多个Kubernetes主集群和工作集群，跨多个区域运行。</p><figure class="lw lx ly lz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lv"><img src="../Images/f6c5d3963e8e8461444b0a31c254c7ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*FEJu5ryIhxH3P9zo.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">跨3个可用区域的3名主管、6名员工</figcaption></figure><p id="ce82" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上面的例子中，为了使我们的集群高度可用，我们将EC2实例分布在多个<strong class="ka ir"> AZ </strong>(可用区域):<strong class="ka ir"> us-east-1a </strong>、<strong class="ka ir"> us-east-1d </strong>和<strong class="ka ir"> us-east-1f </strong>。</p><blockquote class="me mf mg"><p id="215f" class="jy jz mh ka b kb kc kd ke kf kg kh ki mi kk kl km mj ko kp kq mk ks kt ku kv ij bi translated">每个可用性区域都运行在自己的<strong class="ka ir">物理上不同的</strong>、独立的基础设施上，并且被设计为高度可靠。<strong class="ka ir">发电机和冷却设备<strong class="ka ir">等常见故障点</strong>不在可用区域</strong>之间共享。</p><p id="545d" class="jy jz mh ka b kb kc kd ke kf kg kh ki mi kk kl km mj ko kp kq mk ks kt ku kv ij bi translated"><a class="ae kw" href="https://aws.amazon.com/ec2/faqs/#How_isolated_are_Availability_Zones_from_one_another" rel="noopener ugc nofollow" target="_blank">彼此之间的隔离程度如何</a></p></blockquote><p id="55b4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要拥有一个HA集群，我们至少需要三个主机(管理整个Kubernetes集群的服务器)和两个工作机，位于三个不同的可用性区域。这样，如果一个主设备或更糟的是一个区域出现故障，我们将有另外两个区域有两个主设备和两个工作设备。如果一个工作(或主)节点失败，kops将产生一个新的EC2实例来替换该节点。</p><p id="a36e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">可用性区域的优势在于它们彼此靠近，并且延迟非常低。这意味着主节点之间和容器(运行在工作节点上)之间的通信非常快。目前，我在同一区域看到的ping实例的往返时间大约为0.1毫秒(us-east-1a)，在us-east-1a和us-east-1d之间，我得到的时间几乎相同。这个延迟还取决于EC2实例的网络类型。</p><p id="9e90" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">考虑一下，虽然同一区域内实例之间的流量是免费的，但不同区域之间的<strong class="ka ir">流量要收取0.01美元/GB </strong>。这个价格可能看起来很低，但是如果您有一个跨多个区域的复制数据库，每分钟有数千次更新，这种流量最终可能会成为集群成本的一个显著部分。</p><h2 id="2e56" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">AWS帐户和IAM角色</h2><p id="6308" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">现在让我们设置我们的AWS帐户，这样我们就可以通过<em class="mh"> kops cli </em>创建我们的集群。</p><p id="c95e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们显然需要一个AWS账户。如果你还没有，只需点击<a class="ae kw" href="https://aws.amazon.com/" rel="noopener ugc nofollow" target="_blank">这里</a>并点击“创建一个免费账户”。<br/>如果您不习惯AWS计费，请<strong class="ka ir">小心</strong>您使用的资源，并定期查看<a class="ae kw" href="https://console.aws.amazon.com/billing/home" rel="noopener ugc nofollow" target="_blank">计费页面</a>！</p><p id="7503" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一旦帐户准备就绪，我们需要创建和配置IAM用户，创建<em class="mh">访问密钥</em>和<em class="mh">秘密访问密钥</em>。如果你不知道如何管理IAM用户，看看这两个页面:<a class="ae kw" href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_users_create.html" rel="noopener ugc nofollow" target="_blank">添加用户</a>和<a class="ae kw" href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_access-keys.html" rel="noopener ugc nofollow" target="_blank">访问键。</a></p><p id="5a37" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一旦你创建了密钥，使用<code class="fe ml mm mn mo b">aws-cli</code>在你的计算机上设置它们。如果您从未使用过aws-cli，请看一下:<a class="ae kw" href="https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-install.html" rel="noopener ugc nofollow" target="_blank">安装AWS CLI </a>和<a class="ae kw" href="https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-configure.html" rel="noopener ugc nofollow" target="_blank">配置AWS CLI </a>。AWS CLI安装也在<a class="ae kw" href="https://github.com/kubernetes/kops/blob/master/docs/install.md#installing-aws-cli-tools" rel="noopener ugc nofollow" target="_blank"> kops安装页面中进行了简要说明。</a> <br/>安装好aws-cli后，开始配置并输入您的<em class="mh">访问</em>和<em class="mh">秘密访问密钥</em>。</p><pre class="lw lx ly lz gt mp mo mq mr aw ms bi"><span id="aac4" class="kx ky iq mo b gy mt mu l mv mw">$ aws configure<br/><br/>AWS Access Key ID: YOUR_ACCESS_KEY<br/>AWS Secret Access Key: YOUR_SECRET_ACCESS_KEY<br/>Default region name [None]:<br/>Default output format [None]:</span></pre><p id="3986" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">重要。</strong>在配置IAM用户时，我们需要添加<code class="fe ml mm mn mo b">AdministratorAccess</code>权限策略。这样，运行在本地计算机上的kops 命令将能够创建它需要的所有资源。</p><figure class="lw lx ly lz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mx"><img src="../Images/c14207c0b298a55788bfd9c0b5dde410.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*LWG7d3cLCAHaGQsH.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">IAM用户权限策略-管理员访问</figcaption></figure><p id="fad4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要知道凭证在我们的系统中设置正确，我们可以使用<code class="fe ml mm mn mo b">aws</code>命令列出用户。</p><pre class="lw lx ly lz gt mp mo mq mr aw ms bi"><span id="e242" class="kx ky iq mo b gy mt mu l mv mw">$ aws iam list-users<br/>{<br/>    "Users": [<br/>        {<br/>            "Path": "/",<br/>            "UserName": "alvise",<br/>            "UserId": ...,<br/>            "Arn": ...<br/>        }<br/>    ]<br/>}</span></pre><h2 id="6173" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">安装kops和kubectl</h2><p id="ad2d" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated"><code class="fe ml mm mn mo b">kops</code>是我们在AWS上创建Kubernetes集群所需的工具。<code class="fe ml mm mn mo b">kubectl</code>是我们在集群启动并运行后用来管理集群的cli。<br/>对于linux和MAC,<a class="ae kw" href="https://github.com/kubernetes/kops/blob/master/docs/install.md" rel="noopener ugc nofollow" target="_blank">kops安装页面</a>快速展示了如何安装<code class="fe ml mm mn mo b">kops</code>和<code class="fe ml mm mn mo b">kubectl</code>工具。</p><p id="adde" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你有mac，我的建议是用自制软件安装这两个工具。它使得这些二进制文件的安装和升级变得非常容易。</p><p id="bfca" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于Windows用户，我没有找到二进制文件，但似乎可以在Windows机器上编译kops cli。老实说，我会直接在Windows上使用Docker来运行kops和kubectl。dockerhub上有kops和kubectl不同的docker图片:<a class="ae kw" href="https://hub.docker.com/search?q=kops&amp;type=image" rel="noopener ugc nofollow" target="_blank"> dockerhub kops图片</a>。<br/>要使用Powershell在Windows上原生安装<code class="fe ml mm mn mo b">kubectl</code>，这似乎是一个简单的解决方案:<a class="ae kw" href="https://kubernetes.io/docs/tasks/tools/install-kubectl/#install-with-powershell-from-psgallery" rel="noopener ugc nofollow" target="_blank">用PSGallery的Powershell安装</a>。目前我还没有一个简单的方法在Windows上测试这些工具，所以如果你是Windows用户，请留下你的评论，告诉我什么最适合你！</p><h2 id="9d01" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">Route53中的实域</h2><p id="1aea" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">Kops需要一个真正的域和有效的区域设置到AWS Route53中。我知道，这可能是一个阻碍步骤，尤其是如果你只是想在AWS上尝试kops。你可以暂时将一个域名移入Route53，或者在<a class="ae kw" href="https://console.aws.amazon.com/route53/home?region=us-east-1#DomainRegistration:" rel="noopener ugc nofollow" target="_blank"> Route53域名注册页面</a>购买一个便宜的域名。</p><p id="8ae5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我个人已经把我的<em class="mh">poeticoding.com</em>域名服务器换成Route53了。这非常简单。我只需从GoDaddy下载区域文件，并将其导入Route53，告诉GoDaddy使用Route53名称服务器。</p><p id="40e3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">AWS为此提供了一个方便的文档:<a class="ae kw" href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/resource-record-sets-creating-import.html" rel="noopener ugc nofollow" target="_blank">通过导入一个区域文件</a>来创建记录。请记住，如果你对这个过程有任何问题或疑问，请在本文底部留下评论，我会尽力帮助你！</p><p id="0ac8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们已经将我们的域正确地配置到Route53中(在我的例子中是<em class="mh">poeticoding.com</em>)，它应该看起来像这样</p><figure class="lw lx ly lz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lv"><img src="../Images/64e8ba4826183f6102c4cb17fa38abf5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*b_vN6oand9utun6n.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">53号公路上的poeticoding.com区域</figcaption></figure><h2 id="8818" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">存储集群状态的S3存储桶</h2><p id="eeb7" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">这是真正准备好创建集群之前的最后一步！我们只需要创建一个S3桶，kops将使用它来保存集群的状态文件。由于我们计划部署<a class="ae kw" href="https://github.com/poeticoding/phoenix_chat_example" rel="noopener ugc nofollow" target="_blank">凤凰聊天示例</a>，我将我的bucket命名为子域<em class="mh">state.chat.poeticoding.com</em>，但是您可以随意命名它，它不必是域名。</p><figure class="lw lx ly lz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lv"><img src="../Images/316cadd40a00d992f2a5ba0fb36abadf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*fWRfQ8fcRg34ZBB3.png"/></div></div></figure><figure class="lw lx ly lz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lv"><img src="../Images/b12e3a97a3ad21f64af3f54def5bb1c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*V6-CZw1L0eKScoR9.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">创建S3存储桶以保存Kubernetes集群状态</figcaption></figure><h2 id="84c5" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">创建Kubernetes集群</h2><figure class="lw lx ly lz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lv"><img src="../Images/6af3909e57220aa441c90daa804b810f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*jMz91mQUM_tTNWZ7.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">2个可用区域— 3个主区域— 2个工作区域</figcaption></figure><p id="075b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">与开始的示例不同，在开始的示例中，我们有3个主节点和6个工作节点，分布在3个可用性区域，为了简单起见，我们现在将创建一个小得多的集群，仅使用两个区域。这对于我们的测试来说没问题，但是在生产集群中就没那么好了，因为我们可能会遇到consesus/quorum的问题。为了拥有一个合适的HA集群，我们至少应该使用3个区域，每个区域中有一个主节点。</p><pre class="lw lx ly lz gt mp mo mq mr aw ms bi"><span id="42a2" class="kx ky iq mo b gy mt mu l mv mw">$ kops create cluster \<br/>       --state "s3://state.chat.poeticoding.com" \<br/>       --zones "us-east-1d,us-east-1f"  \<br/>       --master-count 3 \<br/>       --master-size=t2.micro \<br/>       --node-count 2 \<br/>       --node-size=t2.micro \<br/>       --name chat.poeticoding.com \<br/>       --yes</span></pre><p id="9443" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过这个简单的命令，kops了解了我们想要构建的集群的所有信息。</p><ul class=""><li id="78b3" class="my mz iq ka b kb kc kf kg kj na kn nb kr nc kv nd ne nf ng bi translated">是S3桶，kops在那里存储状态文件</li><li id="28c7" class="my mz iq ka b kb nh kf ni kj nj kn nk kr nl kv nd ne nf ng bi translated"><code class="fe ml mm mn mo b">--zones</code>我们在同一地区指定了两个可用性区域，美国东部-1d和美国东部-1f</li><li id="e193" class="my mz iq ka b kb nh kf ni kj nj kn nk kr nl kv nd ne nf ng bi translated"><code class="fe ml mm mn mo b">--master-count</code>主人的数量必须是奇数(1，3，5...)，所以如果我们想要一个高可用性集群，我们至少需要3个主机。因为为了简单起见，我们选择只使用两个AZ，所以两个区域中的一个将有两个masters。</li><li id="6278" class="my mz iq ka b kb nh kf ni kj nj kn nk kr nl kv nd ne nf ng bi translated"><code class="fe ml mm mn mo b">--master-size</code>这是主服务器的EC2实例类型。对于中等规模的集群，我通常使用C4/C5.large masters，但是对于这个例子来说<em class="mh"> t2.micro </em>工作得很好。你在这里找到t2实例定价<a class="ae kw" href="https://aws.amazon.com/ec2/instance-types/t2" rel="noopener ugc nofollow" target="_blank"/>。</li><li id="6000" class="my mz iq ka b kb nh kf ni kj nj kn nk kr nl kv nd ne nf ng bi translated"><code class="fe ml mm mn mo b">--node-count</code>和<code class="fe ml mm mn mo b">--node-size</code>在这个例子中，我们只需要两个节点，在这个例子中是两个t2.micro实例。</li><li id="96b8" class="my mz iq ka b kb nh kf ni kj nj kn nk kr nl kv nd ne nf ng bi translated">我们集群的名称，这也是一个将在route53上创建的真实子域。</li></ul><p id="6e1f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这些节点是kubernetes的工作器，是我们运行容器的服务器。通常这些服务器比主服务器大得多，因为大部分负载都在那里。</p><p id="7578" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你在没有<code class="fe ml mm mn mo b">--yes</code>的情况下运行这个命令，kops会在你的AWS账户上打印出所有操作的列表。创建IAM角色、安全组、卷、EC2实例等。<br/>在运行带有<code class="fe ml mm mn mo b">--yes</code>选项的命令之前，看看kops要做什么通常是个好习惯。</p><pre class="lw lx ly lz gt mp mo mq mr aw ms bi"><span id="5b6d" class="kx ky iq mo b gy mt mu l mv mw">$ kops create cluster ... --yes<br/><br/>Inferred --cloud=aws from zone "us-east-1d"<br/>Running with masters in the same AZs; redundancy will be reduced<br/>Assigned CIDR 172.20.32.0/19 to subnet us-east-1d<br/>Assigned CIDR 172.20.64.0/19 to subnet us-east-1f<br/>Using SSH public key: /Users/alvise/.ssh/id_rsa.pub<br/>...<br/>Tasks: 83 done / 83 total; 0 can run<br/>Pre-creating DNS records<br/>Exporting kubecfg for cluster<br/>kops has set your kubectl context to chat.poeticoding.com<br/><br/>Cluster is starting.  It should be ready in a few minutes.</span></pre><p id="5008" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">只需等待几分钟，集群就应该启动并运行了。我们可以使用<code class="fe ml mm mn mo b">validate</code>命令来检查集群创建的状态。</p><pre class="lw lx ly lz gt mp mo mq mr aw ms bi"><span id="15ba" class="kx ky iq mo b gy mt mu l mv mw">$ kops validate cluster \<br/>       --state "s3://state.chat.poeticoding.com" \<br/>       --name chat.poeticoding.com</span></pre><figure class="lw lx ly lz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lv"><img src="../Images/a047694a5e2b518df39a0ffd786812dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*AH6ATlZ7p81z2DbV.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">kops验证集群—集群就绪</figcaption></figure><figure class="lw lx ly lz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lv"><img src="../Images/e63c7453ed80a3c750f1e2974aca851d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*hw4z7bBx_wefw5q7.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">AWS控制台— EC2实例</figcaption></figure><p id="abdf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Kops为我们导出了Kubernetes配置，所以集群应该可以用<code class="fe ml mm mn mo b">kubectl</code>立即访问。</p><pre class="lw lx ly lz gt mp mo mq mr aw ms bi"><span id="5e48" class="kx ky iq mo b gy mt mu l mv mw">$ kubectl get nodes<br/>NAME                            STATUS    ROLES     AGE       VERSION<br/>ip-172-20-33-199.ec2.internal   Ready     master    11m       v1.11.6<br/>ip-172-20-49-249.ec2.internal   Ready     node      10m       v1.11.6<br/>ip-172-20-59-126.ec2.internal   Ready     master    11m       v1.11.6<br/>ip-172-20-71-37.ec2.internal    Ready     master    11m       v1.11.6<br/>ip-172-20-88-143.ec2.internal   Ready     node      10m       v1.11.6</span></pre><p id="c7f3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们还可以看到kops如何为我们的集群创建VPC(虚拟私有云),并在我们的Route53区域中添加新的DNS记录。</p><figure class="lw lx ly lz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lv"><img src="../Images/90a33065104ddfc9fcdeec186701d788.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*SXU27gLwF7UWIRMS.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">AWS虚拟私有云</figcaption></figure><figure class="lw lx ly lz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lv"><img src="../Images/e99b1633d326036301088ee672753139.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*yjvNriSw71hiSu91.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">新DNS记录</figcaption></figure><h2 id="6c91" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">Kubernetes API和安全组</h2><p id="b94b" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">默认情况下，Kubernetes API在互联网上公开。最后，这是我们可以轻松连接到我们的集群的唯一方法(不使用VPN连接到我们的VPC)。老实说，我不喜欢将API公开的想法，尤其是在去年12月的bug之后<a class="ae kw" href="https://www.youtube.com/watch?v=eBJs4mJjEDA&amp;feature=youtu.be" rel="noopener ugc nofollow" target="_blank">。如果我们在办公室或家里有一个静态ip，我们可以设置一个防火墙规则，只允许我们的IP。当我们拥有动态IP时，我们可以仅在需要时打开外部访问。这可能有点乏味，因为每次我们想要访问我们的集群时，我们都需要进入AWS控制台并临时更改防火墙规则。我们可以使用<code class="fe ml mm mn mo b">aws-cli</code>创建一个脚本来改变防火墙。<br/>这些防火墙规则由主实例安全组处理。</a></p><figure class="lw lx ly lz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lv"><img src="../Images/c12ca91f00b69989eb43dcf5e5c69b17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*SJasl6uU8QHFBzJz.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">默认情况下，Kubernetes API HTTP端口是打开的</figcaption></figure><figure class="lw lx ly lz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nm"><img src="../Images/ded445c6372ff8f99ceb9abb0247c02c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*TOEzCosirHTMTVHf.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">限制API访问</figcaption></figure><h2 id="b95e" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">部署Nginx服务器</h2><p id="bd24" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">现在是时候使用<code class="fe ml mm mn mo b">kubectl</code>命令并部署一个简单的Nginx服务器了。首先，让我们检查命令是否有效，集群配置是否正确导入。我们可以用<code class="fe ml mm mn mo b">kubectl get nodes</code>命令列出我们的节点</p><pre class="lw lx ly lz gt mp mo mq mr aw ms bi"><span id="64ec" class="kx ky iq mo b gy mt mu l mv mw">$ kubectl get nodes<br/>NAME                            STATUS    ROLES     AGE       VERSION<br/>ip-172-20-33-199.ec2.internal   Ready     master    11m       v1.11.6<br/>ip-172-20-49-249.ec2.internal   Ready     node      10m       v1.11.6<br/>ip-172-20-59-126.ec2.internal   Ready     master    11m       v1.11.6<br/>ip-172-20-71-37.ec2.internal    Ready     master    11m       v1.11.6<br/>ip-172-20-88-143.ec2.internal   Ready     node      10m       v1.11.6</span></pre><p id="5964" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要部署Nginx服务器，我们需要创建一个<a class="ae kw" href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/" rel="noopener ugc nofollow" target="_blank"> kubernetes部署</a>。添加多个pod副本，它们将在不同的节点上运行，将负载分散到不同的工作人员。</p><pre class="lw lx ly lz gt mp mo mq mr aw ms bi"><span id="820b" class="kx ky iq mo b gy mt mu l mv mw"># nginx_deploy.yaml<br/>kind: Deployment<br/>apiVersion: apps/v1<br/>metadata:<br/>  name: nginx<br/>  namespace: default<br/>spec:<br/>  replicas: 1<br/>  selector:<br/>    matchLabels:<br/>      app: nginx<br/><br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: nginx<br/>    spec:<br/>      containers:<br/>      - name: nginx<br/>        image: nginx:1.15<br/>        ports:<br/>        - containerPort: 80</span></pre><p id="e521" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是一个非常简单的部署。我们要求kubernetes用一个<code class="fe ml mm mn mo b">nginx</code>容器运行一个单独的pod，并暴露容器端口80。</p><pre class="lw lx ly lz gt mp mo mq mr aw ms bi"><span id="c539" class="kx ky iq mo b gy mt mu l mv mw">$ kubectl create -f nginx_deploy.yaml<br/>deployment.apps "nginx" created<br/><br/>$ kubectl get pod<br/>NAME                   READY     STATUS    RESTARTS   AGE<br/>nginx-c9bd9bc4-jqvb5   1/1       Running   0          1m</span></pre><p id="bb6f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">太好了，我们的吊舱正在运行。我们现在需要一个接近它的方法。我们可以使用负载平衡器。</p><pre class="lw lx ly lz gt mp mo mq mr aw ms bi"><span id="089c" class="kx ky iq mo b gy mt mu l mv mw"># nginx_svc.yaml<br/>kind: Service<br/>apiVersion: v1<br/><br/>metadata:<br/>  name: nginx-elb<br/>  namespace: default<br/>  annotations:<br/>    service.beta.kubernetes.io/aws-load-balancer-type: "nlb"<br/><br/>spec:<br/>  type: LoadBalancer<br/>  selector:<br/>    app: nginx<br/>  ports:<br/>    - name: http<br/>      port: 80<br/>      targetPort: 80</span></pre><p id="1ae1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Kubernetes与AWS集成的一个优点是，我们可以直接从Kubernetes配置文件中管理云资源。在<code class="fe ml mm mn mo b">nginx_svc.yaml</code>中，我们定义了一个<code class="fe ml mm mn mo b">LoadBalancer</code>服务，它将其端口80的流量重定向到Nginx的pod的端口80。<br/>我们可以使用<code class="fe ml mm mn mo b">annotations</code>来设置我们想要的负载平衡器类型(在本例中是网络负载平衡器)、SSL证书等。您可以在这里找到服务注释<a class="ae kw" href="https://gist.github.com/mgoodness/1a2926f3b02d8e8149c224d25cc57dc1" rel="noopener ugc nofollow" target="_blank">的完整列表。</a></p><figure class="lw lx ly lz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lv"><img src="../Images/15bea82fa27f0755cf4f0044fae4af4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ka3B_dDFQlC56Lq_.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">网络负载平衡器</figcaption></figure><pre class="lw lx ly lz gt mp mo mq mr aw ms bi"><span id="a6bf" class="kx ky iq mo b gy mt mu l mv mw">$ kubectl create -f nginx_svc.yaml<br/>service "nginx-elb" created<br/><br/>$ kubectl describe svc nginx-elb<br/>Name:                     nginx-elb<br/>...<br/>LoadBalancer Ingress:     a41626d3d169811e995970e07eeed2b2-243343502.us-east-1.elb.amazonaws.com<br/>Port:                     http  80/TCP<br/>TargetPort:               80/TCP<br/>NodePort:                 http  31225/TCP<br/>...</span></pre><p id="58f1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一旦创建了负载平衡器，我们可以使用<code class="fe ml mm mn mo b">describe</code>命令查看它的详细信息。所有资源在AWS控制台上都是可见的。</p><figure class="lw lx ly lz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lv"><img src="../Images/b08291e38945f5bbede8132e1ad06ff5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*4f1zWBxks2CgYmfk.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">AWS控制台—负载平衡器</figcaption></figure><p id="a041" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在负载平衡器服务的描述中，我们看到了<code class="fe ml mm mn mo b">LoadBalancer Ingress</code>属性，这是我们将用来连接到web服务的DNS名称。通常我们不直接使用它，而是创建一个具有可读域(如chat.poeticoding.com)的CNAME记录，它指向负载平衡器的dns名称。<br/>负载平衡器暴露端口80，并将该流量重定向到kubernetes节点端口31225。然后，该节点会将流量重定向到nginx容器。为了测试它是否工作，我们只需要使用负载平衡器入口地址。</p><figure class="lw lx ly lz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nn"><img src="../Images/c65eac5088b57a39d6dd68184805eee5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*UdMQUko8USwlxjko.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">Nginx索引页面</figcaption></figure><p id="1029" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">太好了，成功了！<br/>如果不起作用，请尝试等待几分钟，让负载平衡器DNS进行传播。</p><p id="1525" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在进入下一步之前，让我们删除nginx pod和负载平衡器。</p><pre class="lw lx ly lz gt mp mo mq mr aw ms bi"><span id="8836" class="kx ky iq mo b gy mt mu l mv mw">$ kubectl delete svc nginx-elb<br/>service "nginx-elb" deleted<br/>$ kubectl delete deploy nginx</span></pre><h2 id="5ccb" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">部署Phoenix聊天</h2><p id="db28" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">由于我们将使用一个现成的图像，我们的Phoenix chat的部署将与我们用Nginx所做的非常相似。<br/>我准备了一张图片，你可以在DockerHub、<a class="ae kw" href="https://cloud.docker.com/repository/docker/alvises/phoenix-chat-example" rel="noopener ugc nofollow" target="_blank">alvises/phoenix-chat-example</a>上找到。你也可以在GitHub上找到完整的代码:<a class="ae kw" href="https://github.com/poeticoding/phoenix_chat_example" rel="noopener ugc nofollow" target="_blank">poeticoding/phoenix _ chat _ example</a></p><pre class="lw lx ly lz gt mp mo mq mr aw ms bi"><span id="af6b" class="kx ky iq mo b gy mt mu l mv mw">kind: Deployment<br/>apiVersion: apps/v1<br/>metadata:<br/>  name: chat<br/>  namespace: default<br/>spec:<br/>  replicas: 1<br/>  selector:<br/>    matchLabels:<br/>      app: chat<br/><br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: chat<br/>    spec:<br/>      containers:<br/>      - name: phoenix-chat<br/>        image: alvises/phoenix-chat-example:1_kops_chat<br/>        ports:<br/>        - containerPort: 4000<br/>        env:<br/>        - name: PORT<br/>          value: "4000"<br/>        - name: PHOENIX_CHAT_HOST<br/>          value: "chat.poeticoding.com"</span></pre><p id="d32c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个部署的配置与上一个非常相似。我们添加了两个环境变量来配置应用程序</p><ul class=""><li id="4e79" class="my mz iq ka b kb kc kf kg kj na kn nb kr nc kv nd ne nf ng bi translated"><code class="fe ml mm mn mo b">PORT</code>将凤凰app端口设置为<code class="fe ml mm mn mo b">4000</code></li><li id="40f2" class="my mz iq ka b kb nh kf ni kj nj kn nk kr nl kv nd ne nf ng bi translated"><code class="fe ml mm mn mo b">PHOENIX_CHAT_HOST</code>让Phoenix知道聊天是在哪个域中进行的，在这里是<code class="fe ml mm mn mo b">"chat.poeticoding.com"</code></li></ul><p id="9dc6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">负载平衡器的配置也非常相似。在这种情况下，我们使用4000目标端口。</p><pre class="lw lx ly lz gt mp mo mq mr aw ms bi"><span id="c215" class="kx ky iq mo b gy mt mu l mv mw">kind: Service<br/>apiVersion: v1<br/><br/>metadata:<br/>  name: chat-elb<br/>  namespace: default<br/>  annotations:<br/>    service.beta.kubernetes.io/aws-load-balancer-type: "nlb"<br/><br/>spec:<br/>  type: LoadBalancer<br/>  selector:<br/>    app: chat<br/>  ports:<br/>    - name: http<br/>      port: 80<br/>      targetPort: 4000</span></pre><p id="6e2f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">几分钟后，您将看到pod正在运行，负载平衡器和它的DNS已经启动。</p><pre class="lw lx ly lz gt mp mo mq mr aw ms bi"><span id="9533" class="kx ky iq mo b gy mt mu l mv mw">$ kubectl get pod<br/>NAME                   READY     STATUS    RESTARTS   AGE<br/>chat-b4d7d4b98-vxckn   1/1       Running   0          3m<br/><br/>$ kubectl get svc<br/>NAME         TYPE           CLUSTER-IP      EXTERNAL-IP        PORT(S)        AGE<br/>chat-elb     LoadBalancer   100.66.10.231   a28419b91169b...   80:31181/TCP   3m</span></pre><p id="2a70" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们不像以前那样直接使用负载平衡器的dns，而是在我们的区域中手动添加一条可读的记录。</p><p id="f48e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个步骤也可以使用<a class="ae kw" href="https://github.com/kubernetes-incubator/external-dns" rel="noopener ugc nofollow" target="_blank">外部dns </a>自动完成，这是一个根据服务注释更新Route53记录的工具。</p><figure class="lw lx ly lz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi no"><img src="../Images/49be8d62a4a3cb0f754026129a711da9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*EjEVWYgW91DtjgJn.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">CNAME 53号公路</figcaption></figure><p id="4c93" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在是聊天的时候了！我们打开两个浏览器，连接凤凰聊。</p><figure class="lw lx ly lz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi np"><img src="../Images/4e7e73b867df257a54ad643cffaf99cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*e-2HvDg4eoK_iS7B.gif"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">工作凤凰聊天</figcaption></figure><p id="f48a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">每个浏览器打开一个WebSocket连接来发送和接收消息。用一个容器就可以很好地工作。所有的流量都被重定向到一个Phoenix聊天服务器。</p><figure class="lw lx ly lz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nq"><img src="../Images/bc4f88bb67597f8ed2700ef72af28b0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*SP1EycCuiB3RuBlt.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">两个浏览器—一个容器</figcaption></figure><h2 id="3a36" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">多个聊天副本</h2><p id="c2c6" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">集群没有得到充分利用，我们只有一个聊天窗格/容器在一个节点上运行。如果我们尝试横向扩展，添加另一个副本，会发生什么情况？</p><figure class="lw lx ly lz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lv"><img src="../Images/5ebffc16c7dc2f47b159a056ad093bc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*2bvCXov-LvkDeJEn.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">两个副本—不同步</figcaption></figure><figure class="lw lx ly lz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nr"><img src="../Images/46d292adc0cabeedc236c3d1cbc72efa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*wlSul3yRLhGLTwS0.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">两个Phoenix聊天容器</figcaption></figure><p id="ec90" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于负载平衡器使用循环法在不同容器之间分配连接，我们看到chat-1连接到node-1中的chat，chat-2连接到node-2中的chat。</p><p id="01df" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有了这个简单的配置，两个phoenix服务器彼此不对话，所以它们就像两个独立的服务器运行不同的聊天室。我们将在以后的文章中看到如何处理这些情况，尤其是在Kubernetes集群上。</p><p id="523c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在使用Redis PubSub 的<a class="ae kw" href="https://www.poeticoding.com/distributed-phoenix-chat-using-redis-pubsub/" rel="noopener ugc nofollow" target="_blank">分布式凤凰聊天中，我们看到了解决这个问题的方法。</a></p><h2 id="37ae" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">摧毁集群</h2><p id="0bf1" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">现在是时候摧毁我们的集群并释放AWS资源了。我们使用带有<code class="fe ml mm mn mo b">delete cluster</code>子命令的<code class="fe ml mm mn mo b">kops</code> cli来完成。</p><pre class="lw lx ly lz gt mp mo mq mr aw ms bi"><span id="4b50" class="kx ky iq mo b gy mt mu l mv mw">$ kops delete cluster \<br/>       --state "s3://state.chat.poeticoding.com" \<br/>       --name chat.poeticoding.com \<br/>       --yes<br/>...<br/>Deleted kubectl config for chat.poeticoding.com<br/>Deleted cluster: "chat.poeticoding.com"</span></pre><figure class="lw lx ly lz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lv"><img src="../Images/aa4adf2fb27ee06180fe7d6fa967535e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*jQA-DNjTpaAclD24.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">kops删除集群EC2终止的实例</figcaption></figure><p id="fb34" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如我们之前所做的，我们需要用<code class="fe ml mm mn mo b">--yes</code>选项来确认动作。<br/>删除过程可能需要几分钟时间。删除集群时，我们看到EC2实例被终止，卷、负载平衡器和VPC也被删除。</p></div><div class="ab cl ns nt hu nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="ij ik il im in"><p id="ed60" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="mh">原载于</em> <a class="ae kw" href="https://www.poeticoding.com/create-a-high-availability-kubernetes-cluster-on-aws-with-kops/" rel="noopener ugc nofollow" target="_blank"> <em class="mh">诗歌集</em> </a> <em class="mh">。</em></p></div></div>    
</body>
</html>