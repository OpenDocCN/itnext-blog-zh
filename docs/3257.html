<html>
<head>
<title>Writing Better Marble Tests for Redux Observable and TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为Redux Observable和TypeScript编写更好的大理石测试</h1>
<blockquote>原文：<a href="https://itnext.io/better-marble-test-70c7676a1e2?source=collection_archive---------2-----------------------#2019-11-06">https://itnext.io/better-marble-test-70c7676a1e2?source=collection_archive---------2-----------------------#2019-11-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/ee8915d36e40bcea697f96814cef5195.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cbQarcERAP0l4D7fb5a1Bg.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片摄于奥地利。牛从山上下来过冬。</figcaption></figure><p id="654e" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">大理石测试是一种测试可见物体的绝妙方法。它关注的是随着时间的推移可观察到的行为。测试断言和<a class="ae ld" href="https://rxmarbles.com/" rel="noopener ugc nofollow" target="_blank">大理石图</a>的结合让我们可以直观地看到所发出的值随时间的进展。</p><p id="5171" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">用<a class="ae ld" href="https://www.typescriptlang.org/" rel="noopener ugc nofollow" target="_blank"> TypeScript </a>为<code class="fe le lf lg lh b"><a class="ae ld" href="https://redux-observable.js.org/" rel="noopener ugc nofollow" target="_blank">redux-observable</a></code> <strong class="kh iu"> </strong>编写Marble测试有时会有点棘手。找到指导或良好实践并不容易。我花了一段时间研究才适应它，所以我想和你分享我的发现，希望它能让你更好地了解如何测试你的史诗。</p><p id="ad68" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我已经做了一个<a class="ae ld" href="https://github.com/DawChihLiou/better-redux-observable-marble-testing" rel="noopener ugc nofollow" target="_blank">快速演示</a>。请参考其类型、动作和减速器。</p></div><div class="ab cl li lj hx lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="im in io ip iq"><h2 id="4151" class="lp lq it bd lr ls lt dn lu lv lw dp lx kq ly lz ma ku mb mc md ky me mf mg mh bi translated">TL；速度三角形定位法(dead reckoning)</h2><ul class=""><li id="3716" class="mi mj it kh b ki mk km ml kq mm ku mn ky mo lc mp mq mr ms bi translated">使用来自<code class="fe le lf lg lh b"><a class="ae ld" href="https://rxjs-dev.firebaseapp.com/api/testing/TestScheduler" rel="noopener ugc nofollow" target="_blank">TestScheduler</a></code>的<code class="fe le lf lg lh b">createTime()</code>方法模拟API错误响应。</li><li id="6334" class="mi mj it kh b ki mt km mu kq mv ku mw ky mx lc mp mq mr ms bi translated">用<code class="fe le lf lg lh b">action$</code>作为热观测值测试史诗。</li><li id="e27d" class="mi mj it kh b ki mt km mu kq mv ku mw ky mx lc mp mq mr ms bi translated">史诗中的<code class="fe le lf lg lh b">state$</code>是一个<code class="fe le lf lg lh b"><a class="ae ld" href="https://redux-observable.js.org/docs/basics/Epics.html" rel="noopener ugc nofollow" target="_blank">StateObservable</a></code>，它带有一个<a class="ae ld" href="https://rxjs-dev.firebaseapp.com/api/index/class/Subject" rel="noopener ugc nofollow" target="_blank">主题</a>和一个你的Redux商店的状态。</li><li id="ca40" class="mi mj it kh b ki mt km mu kq mv ku mw ky mx lc mp mq mr ms bi translated">收集弹珠图来帮助人们更好地理解你的测试。</li><li id="a53f" class="mi mj it kh b ki mt km mu kq mv ku mw ky mx lc mp mq mr ms bi translated">如需演示，请点击查看<a class="ae ld" href="https://github.com/DawChihLiou/better-redux-observable-marble-testing" rel="noopener ugc nofollow" target="_blank">。</a></li></ul></div><div class="ab cl li lj hx lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="im in io ip iq"><p id="9307" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">让我们一起来看一个场景:</p><blockquote class="my mz na"><p id="4d22" class="kf kg nb kh b ki kj kk kl km kn ko kp nc kr ks kt nd kv kw kx ne kz la lb lc im bi translated">在web应用程序中向用户显示Github用户列表。通过点击一个列表项，我们将获取各个Github用户的公共存储库并显示出来。</p></blockquote><p id="f63d" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">当选择一个Github用户时，我们调度一个<code class="fe le lf lg lh b">UPDATE_SELECTED_USER</code>动作来更新商店中的<code class="fe le lf lg lh b">selectedUser</code>。更新后，我们想调度一个<code class="fe le lf lg lh b">fetchRepos</code>动作来通知从Github获取。一旦接收到API响应，存储将被更新为成功响应或错误。动作流程如下所示:</p><figure class="ng nh ni nj gt ju gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/9d1dba73f9c3e8fdddb04f5051b0c3c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1208/format:webp/1*xjpgKz9BpLyss0Kp81bFZA.png"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">行动流程</figcaption></figure><h2 id="6a97" class="lp lq it bd lr ls lt dn lu lv lw dp lx kq ly lz ma ku mb mc md ky me mf mg mh bi translated">测试执行提取的可观察对象</h2><p id="9e13" class="pw-post-body-paragraph kf kg it kh b ki mk kk kl km ml ko kp kq nk ks kt ku nl kw kx ky nm la lb lc im bi translated">我们想从编写一个请求存储库列表的服务开始。我们将根据请求是否成功来保存响应数据或更新错误状态。</p><figure class="ng nh ni nj gt ju"><div class="bz fp l di"><div class="nn no l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae ld" href="https://gist.github.com/DawChihLiou/f79edd5366a52519b9b2466bf3ff7d40" rel="noopener ugc nofollow" target="_blank"> fetchGithubRepos流</a></figcaption></figure><p id="4e96" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">对于我们的第一个测试，我们想看看一个成功的请求是否会立即触发服务中的<code class="fe le lf lg lh b">fetchReposSuccessful</code>动作。弹珠图和弹珠的价值是这样的:</p><pre class="ng nh ni nj gt np lh nq nr aw ns bi"><span id="49f0" class="lp lq it lh b gy nt nu l nv nw">const marbles = {<br/>  i: '-i', // api response<br/>  o: '-o', // output action<br/>};</span><span id="c891" class="lp lq it lh b gy nx nu l nv nw">const values = {<br/>  i: response,<br/>  o: fetchReposSuccessful(response),<br/>};</span></pre><p id="f272" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">请注意，我们一起列出了大理石图。我发现这是一个非常清晰的表示，可以显示随时间推移而产生的值。我们可以在此结构中添加描述或中间步骤，以提高可读性:</p><pre class="ng nh ni nj gt np lh nq nr aw ns bi"><span id="ddd0" class="lp lq it lh b gy nt nu l nv nw">const marbles = {<br/>  i: '-i', // api response<br/>  // == tap ==  <br/>  // '-i'<br/>  // == map ==<br/>  o: '-o', // output action<br/>};</span></pre><p id="4482" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">接下来，就像在<a class="ae ld" href="https://redux-observable.js.org/docs/recipes/WritingTests.html" rel="noopener ugc nofollow" target="_blank">正式文档</a>中一样，我们将在<code class="fe le lf lg lh b">TestScheduler.run</code>中附上我们的测试。</p><pre class="ng nh ni nj gt np lh nq nr aw ns bi"><span id="e8ef" class="lp lq it lh b gy nt nu l nv nw">scheduler.run(({ cold, expectObservable }) =&gt; {      <br/>  const getJSON = (url: string) =&gt; cold(marbles.i, values);        <br/>  const output$ = fetchGithubRepos('test-user', getJSON);      <br/>  expectObservable(output$).toBe(marbles.o, values);    <br/>});</span></pre><p id="7fee" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">Done现在我们测试当API请求失败时，observable是否发出<code class="fe le lf lg lh b">fetchReposFailed</code>。测试的棘手部分是模拟失败的请求。我们能做的就是用<code class="fe le lf lg lh b"><a class="ae ld" href="https://rxjs-dev.firebaseapp.com/api/index/function/timer" rel="noopener ugc nofollow" target="_blank">timer</a></code>创造一个可观察的。</p><p id="c849" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">酷的是我们可以用TestScheduler为<code class="fe le lf lg lh b">timer</code>创建时间跨度。</p><pre class="ng nh ni nj gt np lh nq nr aw ns bi"><span id="2090" class="lp lq it lh b gy nt nu l nv nw">const duration = scheduler.createTime('-|');      <br/>const getJSON = (url: string) =&gt; <br/>  timer(duration).pipe(mergeMap(() =&gt; throwError(error)));</span></pre><p id="38aa" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们用marble符号和<code class="fe le lf lg lh b">TestSchedule</code>来创建<code class="fe le lf lg lh b">timer</code>，而不是用毫秒来表示持续时间。所以当我们执行<code class="fe le lf lg lh b">getJSON</code>，<strong class="kh iu">时，它会在调度器</strong>中的一个tick之后发出一个错误。预期的输出如下所示:</p><pre class="ng nh ni nj gt np lh nq nr aw ns bi"><span id="8c61" class="lp lq it lh b gy nt nu l nv nw">const marbles = {      <br/>  d: '-|', // mock api response time duration<br/>  o: '-(o|)', // output action. Complete when error thrown.<br/>};    </span><span id="5a17" class="lp lq it lh b gy nx nu l nv nw">const values = {      <br/>  o: fetchReposFailed(error),    <br/>};</span><span id="c8b7" class="lp lq it lh b gy nx nu l nv nw">scheduler.run(({ expectObservable }) =&gt; {             <br/>  const output$ = fetchGithubRepos('test-user', getJSON as any);        <br/>  expectObservable(output$).toBe(marbles.o, values);    <br/>});</span></pre><p id="02e4" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">你可以在下面找到完整的测试。</p><figure class="ng nh ni nj gt ju"><div class="bz fp l di"><div class="nn no l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae ld" href="https://gist.github.com/DawChihLiou/f43083bc00096fe40b69cdaec7a3a260" rel="noopener ugc nofollow" target="_blank">fetchGithubRepos流的单元测试</a></figcaption></figure><h2 id="207d" class="lp lq it bd lr ls lt dn lu lv lw dp lx kq ly lz ma ku mb mc md ky me mf mg mh bi translated">测试没有状态的史诗</h2><p id="ac2c" class="pw-post-body-paragraph kf kg it kh b ki mk kk kl km ml ko kp kq nk ks kt ku nl kw kx ky nm la lb lc im bi translated">我们已经准备好编写第一个使用<code class="fe le lf lg lh b">fetchGithubRepos</code>服务获取存储库的epic。</p><figure class="ng nh ni nj gt ju"><div class="bz fp l di"><div class="nn no l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><code class="fe le lf lg lh b"><a class="ae ld" href="https://gist.github.com/DawChihLiou/2bbe6064a0c911b4fcd2119b2af597c1" rel="noopener ugc nofollow" target="_blank">fetchGithubRepos</a></code> <a class="ae ld" href="https://gist.github.com/DawChihLiou/2bbe6064a0c911b4fcd2119b2af597c1" rel="noopener ugc nofollow" target="_blank">史诗</a></figcaption></figure><p id="ee30" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这是一部直截了当的史诗。我们想要监听<code class="fe le lf lg lh b">FETCH_REPOS_REQUESTED</code>动作类型，从动作有效负载中选择用户名，并使用用户名执行服务observable。注意，我们正在使用<code class="fe le lf lg lh b"><a class="ae ld" href="https://rxjs-dev.firebaseapp.com/api/operators/switchMap" rel="noopener ugc nofollow" target="_blank">switchMap</a></code>,所以我们能够取消重复的API请求。</p><figure class="ng nh ni nj gt ju gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/ffb6393072a9c2d14043cca74f76f7d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1208/format:webp/1*rsIhk-Nz_soUTEqpK79s-A.png"/></div></figure><p id="2ef8" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">为了测试epic，我们想看看它是否监听正确的动作，以及它是否只发出最近可观察到的动作。大理石看起来像这样:</p><pre class="ng nh ni nj gt np lh nq nr aw ns bi"><span id="9b67" class="lp lq it lh b gy nt nu l nv nw">const marbles = {      <br/>  r: '--r', // mock api response      <br/>  i: '-ii--i', // input action<br/>  // == switchMap() ==      <br/>  // only emit the latest value for consecutive inputs<br/>  // '----r--r'<br/>  // == map() ==<br/>  o: '----o--o', // output action    <br/>};</span><span id="80a8" class="lp lq it lh b gy nx nu l nv nw">const values = {      <br/>  i: fetchRepos('test-user'),      <br/>  r: response,      <br/>  o: fetchReposSuccessful(response),    <br/>};</span></pre><p id="6d1a" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">现在构建测试。</p><pre class="ng nh ni nj gt np lh nq nr aw ns bi"><span id="6b99" class="lp lq it lh b gy nt nu l nv nw">scheduler.run(({ hot, cold, expectObservable }) =&gt; {      <br/>  const action$ = hot(marbles.i, values) as any;      <br/>  const state$ = null as any;      <br/>  const dependencies = {        <br/>    getJSON: (url: string) =&gt; cold(marbles.r, values),      <br/>  };      <br/>  const output$ = <br/>    fetchGithubReposEpic(action$, state$, dependencies);        <br/>  expectObservable(output$).toBe(marbles.o, values);    <br/>});</span></pre><p id="7bf7" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">为了模拟输入动作的可观察性，我们从<code class="fe le lf lg lh b">scheduler.run</code>的回调函数中使用<code class="fe le lf lg lh b">hot</code>助手来创建热的可观察性。可观察的行动在本质上是冷的；然而，当它们通过<code class="fe le lf lg lh b"><a class="ae ld" href="https://redux-observable.js.org/docs/basics/SettingUpTheMiddleware.html" rel="noopener ugc nofollow" target="_blank">redux-observable</a></code> <a class="ae ld" href="https://redux-observable.js.org/docs/basics/SettingUpTheMiddleware.html" rel="noopener ugc nofollow" target="_blank">的中间件</a>时，<strong class="kh iu">动作可观察物通过将主体设置为观察者而变热</strong>。在本·莱什的文章中阅读更多关于冷热的观察。在文章中，他还谈到了如何让代码变得可观察。</p><p id="e930" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">你可以看到我们断言<code class="fe le lf lg lh b">action$</code>为<code class="fe le lf lg lh b">any</code>供<code class="fe le lf lg lh b">fetchGithubReposEpic</code>使用。那是因为一部史诗期待<code class="fe le lf lg lh b">action$</code>是<code class="fe le lf lg lh b"><a class="ae ld" href="https://github.com/redux-observable/redux-observable/blob/master/src/ActionsObservable.ts" rel="noopener ugc nofollow" target="_blank">ActionsObservable</a></code>型而不是<code class="fe le lf lg lh b"><a class="ae ld" href="https://rxjs-dev.firebaseapp.com/api/testing/TestScheduler" rel="noopener ugc nofollow" target="_blank">ColdObservable</a></code>型。<code class="fe le lf lg lh b">CodeObservable</code>扩展了<code class="fe le lf lg lh b">Observable</code>，它是TestScheduler中一个可观察的帮助器，以方便测试。我们可以有把握地断言。</p><p id="7a58" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们将<code class="fe le lf lg lh b">state$</code>分配给<code class="fe le lf lg lh b">null</code>,因为我们不访问epic中的商店。</p><p id="0a5d" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">对于依赖关系，我们用<code class="fe le lf lg lh b">cold</code>助手模拟<code class="fe le lf lg lh b">getJSON</code>来模拟成功的API请求。</p><figure class="ng nh ni nj gt ju"><div class="bz fp l di"><div class="nn no l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">【fetchGithubRepos Epic的单元测试</figcaption></figure><h2 id="4c46" class="lp lq it bd lr ls lt dn lu lv lw dp lx kq ly lz ma ku mb mc md ky me mf mg mh bi translated">使用state$测试Epic</h2><p id="6cb5" class="pw-post-body-paragraph kf kg it kh b ki mk kk kl km ml ko kp kq nk ks kt ku nl kw kx ky nm la lb lc im bi translated">现在我们可以完成最后一块来完成完整的动作流程。</p><figure class="ng nh ni nj gt ju gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/ad8bb6b82728a2f808cacbf3d985219f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1208/format:webp/1*4ZPbNxDUbZEvd2gT8GesOw.png"/></div></figure><p id="ced2" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们正在创建一个epic来监听<code class="fe le lf lg lh b">updateSelectedUser</code>动作，并使用刚刚更新的用户名来触发<code class="fe le lf lg lh b">fetchGithubRepos</code>服务observable。</p><figure class="ng nh ni nj gt ju"><div class="bz fp l di"><div class="nn no l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae ld" href="https://gist.github.com/DawChihLiou/d2c1e730f6608f886dc34bca0d2add80" rel="noopener ugc nofollow" target="_blank"> listenToSelectedUser史诗</a></figcaption></figure><p id="cdcf" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">为了测试它，我们需要知道如何模拟国家可观测量。状态可观测量(<code class="fe le lf lg lh b">state$</code>)实际上是由<code class="fe le lf lg lh b"><a class="ae ld" href="https://github.com/redux-observable/redux-observable/blob/master/src/StateObservable.ts" rel="noopener ugc nofollow" target="_blank">StateObservable</a></code>创建。<code class="fe le lf lg lh b">StateObservable</code>接受一个Subject和一个Redux状态作为参数。</p><pre class="ng nh ni nj gt np lh nq nr aw ns bi"><span id="c4b3" class="lp lq it lh b gy nt nu l nv nw">const reduxState: AppState = {<br/>  selectedUser: 'test-user',        <br/>  githubRepos: reposInitialState,<br/>};</span><span id="3ec6" class="lp lq it lh b gy nx nu l nv nw">const state$ = new StateObservable&lt;AppState&gt;(<br/>  new Subject(), reduxState);</span></pre><p id="d3d7" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们已经准备好一起组装测试:</p><figure class="ng nh ni nj gt ju"><div class="bz fp l di"><div class="nn no l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae ld" href="https://gist.github.com/DawChihLiou/f7606a8655c19990b03fe01663a6b4ba" rel="noopener ugc nofollow" target="_blank">listenToSelectedUser Epic的单元测试</a></figcaption></figure><p id="cc71" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">现在让我们看看测试结果！</p><figure class="ng nh ni nj gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ny"><img src="../Images/64b86cdbb8b562fdd03c1577d0548823.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ERRVvcishKvmHAsjamkUlw.png"/></div></div></figure><p id="c505" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如果它也能工作，让我们试一试。</p><figure class="ng nh ni nj gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nz"><img src="../Images/2050a895a1e53839404db9f1be4ebc1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*CLrPvP96x_Px0LDRF4ycNQ.gif"/></div></div></figure><p id="468a" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">随意看看我放在一起的<a class="ae ld" href="https://github.com/DawChihLiou/better-redux-observable-marble-testing" rel="noopener ugc nofollow" target="_blank">演示</a>。你可以在那里找到更多关于如何输入史诗和可观测量的细节。</p></div><div class="ab cl li lj hx lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="im in io ip iq"><p id="a4e6" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">给你！感谢您通读。</p><p id="a617" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我希望我尽可能直截了当地抓住它。如果你有想法或者有什么不清楚的地方，欢迎在下面发表评论，或者在twitter上与我联系！</p><p id="3034" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如果你是函数式编程的粉丝，可以看看我写的这篇关于转换器 的文章。这是编写转换器的一步一步的推理，并且涉及到函数式编程的关键思想。</p><p id="9424" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">编码快乐！</p></div></div>    
</body>
</html>