<html>
<head>
<title>Learn how to configure Kubernetes apps using ConfigMap</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解如何使用ConfigMap配置Kubernetes应用程序</h1>
<blockquote>原文：<a href="https://itnext.io/learn-how-to-configure-your-kubernetes-apps-using-the-configmap-object-d8f30f99abeb?source=collection_archive---------0-----------------------#2019-09-18">https://itnext.io/learn-how-to-configure-your-kubernetes-apps-using-the-configmap-object-d8f30f99abeb?source=collection_archive---------0-----------------------#2019-09-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="117d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">“配置与代码分离”是<a class="ae kl" href="https://12factor.net/config" rel="noopener ugc nofollow" target="_blank"> 12因素应用</a>的原则之一。我们将可以改变的东西具体化，这反过来有助于保持我们的应用程序的可移植性。这在Kubernetes世界中是至关重要的，在那里我们的应用程序被打包成Docker映像。Kubernetes <code class="fe km kn ko kp b">ConfigMap</code>允许我们从代码中抽象出配置，最终抽象出Docker映像。</p><p id="dcb8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这篇博文将为Kubernetes中可用的应用配置相关选项提供实践指南。</p><p id="fd61" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">和往常一样，代码在GitHub 上<a class="ae kl" href="https://github.com/abhirockzz/kubernetes-in-a-nutshell" rel="noopener ugc nofollow" target="_blank">可用。所以让我们开始吧…</a></p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div class="gh gi kq"><img src="../Images/8f22ecbedd5cd81331c4c760fd6fdc58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/0*ERExm8kI7oBl4e05.gif"/></div></figure><p id="1974" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要在Kubernetes中配置您的应用程序，您可以使用:</p><ul class=""><li id="56e9" class="ky kz iq jp b jq jr ju jv jy la kc lb kg lc kk ld le lf lg bi translated">好的旧环境变量</li><li id="1a68" class="ky kz iq jp b jq lh ju li jy lj kc lk kg ll kk ld le lf lg bi translated"><code class="fe km kn ko kp b">ConfigMap</code></li><li id="ed16" class="ky kz iq jp b jq lh ju li jy lj kc lk kg ll kk ld le lf lg bi translated"><code class="fe km kn ko kp b">Secret</code>——这将在后续的博客文章中涉及</li></ul><p id="0cec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，您需要一个Kubernetes集群。这可能是一个简单的使用<code class="fe km kn ko kp b"><a class="ae kl" href="https://kubernetes.io/docs/setup/learning-environment/minikube/" rel="noopener ugc nofollow" target="_blank">minikube</a></code>、<code class="fe km kn ko kp b"><a class="ae kl" href="https://blog.docker.com/2018/01/docker-mac-kubernetes/" rel="noopener ugc nofollow" target="_blank">Docker for Mac</a></code>等的单节点本地集群。或者来自<a class="ae kl" href="https://docs.microsoft.com/azure/aks/?WT.mc_id=medium-blog-abhishgu" rel="noopener ugc nofollow" target="_blank">Azure</a>、<a class="ae kl" href="https://cloud.google.com/kubernetes-engine/" rel="noopener ugc nofollow" target="_blank"> Google </a>、<a class="ae kl" href="https://aws.amazon.com/eks/" rel="noopener ugc nofollow" target="_blank"> AWS </a>等的托管Kubernetes服务。要访问您的Kubernetes集群，您需要<code class="fe km kn ko kp b"><a class="ae kl" href="https://kubernetes.io/docs/reference/kubectl/overview/" rel="noopener ugc nofollow" target="_blank">kubectl</a></code>，它很容易安装。</p><p id="0cf2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，要为Mac安装<code class="fe km kn ko kp b">kubectl</code>,您只需</p><pre class="kr ks kt ku gt lm kp ln lo aw lp bi"><span id="54b1" class="lq lr iq kp b gy ls lt l lu lv">curl -LO https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/darwin/amd64/kubectl &amp;&amp; \<br/>chmod +x ./kubectl &amp;&amp; \<br/>sudo mv ./kubectl /usr/local/bin/kubectl</span></pre><h1 id="6104" class="lw lr iq bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">使用环境变量进行配置</h1><p id="fa11" class="pw-post-body-paragraph jn jo iq jp b jq mt js jt ju mu jw jx jy mv ka kb kc mw ke kf kg mx ki kj kk ij bi translated">让我们从一个简单的例子开始，看看如何通过在我们的<code class="fe km kn ko kp b">Pod</code>规范中直接指定环境变量来使用它们。</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="d198" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意我们如何在<code class="fe km kn ko kp b">spec.containers.env</code> — <code class="fe km kn ko kp b">ENVVAR1</code>和<code class="fe km kn ko kp b">ENVVAR2</code>中分别用值<code class="fe km kn ko kp b">value1</code>和<code class="fe km kn ko kp b">value2</code>定义两个变量。</p><p id="c779" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们从使用上面指定的YAML创建<code class="fe km kn ko kp b">Pod</code>开始。</p><blockquote class="na nb nc"><p id="98df" class="jn jo nd jp b jq jr js jt ju jv jw jx ne jz ka kb nf kd ke kf ng kh ki kj kk ij bi translated"><code class="fe km kn ko kp b"><em class="iq">Pod</em></code> <em class="iq">只是一个库伯内特的资源或对象。YAML文件是描述其期望状态以及一些基本信息的东西——它也被称为</em><code class="fe km kn ko kp b"><em class="iq">manifest</em></code><em class="iq"/><code class="fe km kn ko kp b"><em class="iq">spec</em></code><em class="iq">(规范的简写)或</em> <code class="fe km kn ko kp b"><em class="iq">definition</em></code> <em class="iq">。</em></p></blockquote><p id="3f50" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用<code class="fe km kn ko kp b"><a class="ae kl" href="https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#apply" rel="noopener ugc nofollow" target="_blank">kubectl apply</a></code>命令向Kubernetes提交<code class="fe km kn ko kp b">Pod</code>信息。</p><blockquote class="na nb nc"><p id="013b" class="jn jo nd jp b jq jr js jt ju jv jw jx ne jz ka kb nf kd ke kf ng kh ki kj kk ij bi translated"><em class="iq">为了简单起见，YAML文件直接从</em><a class="ae kl" href="https://github.com/abhirockzz/kubernetes-in-a-nutshell" rel="noopener ugc nofollow" target="_blank"><em class="iq">GitHub repo</em></a><em class="iq">中引用，但是你也可以把文件下载到你的本地机器上，以同样的方式使用它。</em></p></blockquote><pre class="kr ks kt ku gt lm kp ln lo aw lp bi"><span id="dbb4" class="lq lr iq kp b gy ls lt l lu lv">$ kubectl apply -f   https://raw.githubusercontent.com/abhirockzz/kubernetes-in-a-nutshell/master/configuration/kin-config-envvar-in-pod.yaml</span><span id="5307" class="lq lr iq kp b gy nh lt l lu lv">pod/pod1 created</span></pre><p id="bf79" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了检查环境变量，我们需要使用<code class="fe km kn ko kp b">kubectl exec</code>在Pod的“内部”执行一个命令——您应该看到在<code class="fe km kn ko kp b">Pod</code>定义中播种的那些变量。</p><p id="03de" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里，我们使用了<code class="fe km kn ko kp b">grep</code>来过滤我们感兴趣的变量</p><pre class="kr ks kt ku gt lm kp ln lo aw lp bi"><span id="45fe" class="lq lr iq kp b gy ls lt l lu lv">$ kubectl exec pod1 -it -- env | grep ENVVAR</span><span id="1647" class="lq lr iq kp b gy nh lt l lu lv">ENVVAR1=value1<br/>ENVVAR2=value2</span></pre><blockquote class="na nb nc"><p id="e3e7" class="jn jo nd jp b jq jr js jt ju jv jw jx ne jz ka kb nf kd ke kf ng kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="iq">什么是</em> </strong> <code class="fe km kn ko kp b"><strong class="jp ir"><em class="iq">kubectl exec</em></strong></code> <strong class="jp ir"> <em class="iq">？</em> </strong> <em class="iq">简单来说，它允许你在一个</em> <code class="fe km kn ko kp b"><em class="iq">Pod</em></code> <em class="iq">内的特定容器中执行一个命令。在这种情况下，我们的</em> <code class="fe km kn ko kp b"><em class="iq">Pod</em></code> <em class="iq">有一个单独的容器，所以我们不需要指定一个</em></p></blockquote><p id="e396" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好了，有了这个概念，我们可以探索一下。</p><h1 id="a760" class="lw lr iq bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">使用<code class="fe km kn ko kp b">ConfigMap</code></h1><p id="9152" class="pw-post-body-paragraph jn jo iq jp b jq mt js jt ju mu jw jx jy mv ka kb kc mw ke kf kg mx ki kj kk ij bi translated">它的工作方式是在一个<code class="fe km kn ko kp b">ConfigMap</code>对象中定义您的配置，然后在一个<code class="fe km kn ko kp b">Pod</code>(或<code class="fe km kn ko kp b">Deployment</code>)中引用该对象。</p><p id="3f5b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们来看看创建<code class="fe km kn ko kp b">ConfigMap</code>的技巧</p><h2 id="2d87" class="lq lr iq bd lx ni nj dn mb nk nl dp mf jy nm nn mj kc no np mn kg nq nr mr ns bi translated">使用清单文件</h2><p id="650f" class="pw-post-body-paragraph jn jo iq jp b jq mt js jt ju mu jw jx jy mv ka kb kc mw ke kf kg mx ki kj kk ij bi translated">可以在定义的<code class="fe km kn ko kp b">data</code>部分创建一个<code class="fe km kn ko kp b">ConfigMap</code>以及作为键值对存储的配置数据。</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="3cbd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上面的清单中:</p><ul class=""><li id="ef9c" class="ky kz iq jp b jq jr ju jv jy la kc lb kg lc kk ld le lf lg bi translated">名为<code class="fe km kn ko kp b">simpleconfig</code>的<code class="fe km kn ko kp b">ConfigMap</code>包含两个(键值)数据— <code class="fe km kn ko kp b">hello=world</code>和<code class="fe km kn ko kp b">foo=bar</code></li><li id="0e53" class="ky kz iq jp b jq lh ju li jy lj kc lk kg ll kk ld le lf lg bi translated"><code class="fe km kn ko kp b">simpleconfig</code>被一个<code class="fe km kn ko kp b">Pod</code> ( <code class="fe km kn ko kp b">pod2</code>)引用；键<code class="fe km kn ko kp b">hello</code>和<code class="fe km kn ko kp b">foo</code>分别作为环境变量<code class="fe km kn ko kp b">HELLO_ENV_VAR</code>和<code class="fe km kn ko kp b">FOO_ENV_VAR</code>使用。</li></ul><blockquote class="na nb nc"><p id="89d6" class="jn jo nd jp b jq jr js jt ju jv jw jx ne jz ka kb nf kd ke kf ng kh ki kj kk ij bi translated"><em class="iq">注意，我们已经把</em> <code class="fe km kn ko kp b"><em class="iq">Pod</em></code> <em class="iq">和</em> <code class="fe km kn ko kp b"><em class="iq">ConfigMap</em></code> <em class="iq">定义包含在同一个YAML中，中间用一个</em> <code class="fe km kn ko kp b"><em class="iq">---</em></code>隔开</p></blockquote><p id="a460" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">创建<code class="fe km kn ko kp b">ConfigMap</code>并确认环境变量已被植入</p><pre class="kr ks kt ku gt lm kp ln lo aw lp bi"><span id="3d50" class="lq lr iq kp b gy ls lt l lu lv">$ kubectl apply -f   https://raw.githubusercontent.com/abhirockzz/kubernetes-in-a-nutshell/master/configuration/kin-config-envvar-configmap.yaml</span><span id="80af" class="lq lr iq kp b gy nh lt l lu lv">configmap/config1 created<br/>pod/pod2 created</span><span id="b59b" class="lq lr iq kp b gy nh lt l lu lv">$ kubectl get configmap/config1</span><span id="c777" class="lq lr iq kp b gy nh lt l lu lv">NAME      DATA   AGE<br/>config1   2      18s</span><span id="7185" class="lq lr iq kp b gy nh lt l lu lv">$ kubectl exec pod2 -it -- env | grep _ENV_</span><span id="0f1a" class="lq lr iq kp b gy nh lt l lu lv">FOO_ENV_VAR=bar<br/>HELLO_ENV_VAR=world</span></pre><h2 id="e976" class="lq lr iq bd lx ni nj dn mb nk nl dp mf jy nm nn mj kc no np mn kg nq nr mr ns bi translated">使用<code class="fe km kn ko kp b">envVar</code>的快捷方式</h2><p id="ce44" class="pw-post-body-paragraph jn jo iq jp b jq mt js jt ju mu jw jx jy mv ka kb kc mw ke kf kg mx ki kj kk ij bi translated">我们通过分别引用配置数据(<code class="fe km kn ko kp b">foo</code>和<code class="fe km kn ko kp b">hello</code>)来使用它们，但是有一种更简单的方法！我们可以在清单中使用<code class="fe km kn ko kp b">envFrom</code>来直接引用<code class="fe km kn ko kp b">ConfigMap</code>中的所有键值数据。</p><blockquote class="na nb nc"><p id="bfaf" class="jn jo nd jp b jq jr js jt ju jv jw jx ne jz ka kb nf kd ke kf ng kh ki kj kk ij bi translated"><em class="iq">当使用</em> <code class="fe km kn ko kp b"><em class="iq">ConfigMap</em></code> <em class="iq">数据这种方式时，key直接用作环境变量名。这就是为什么你需要遵循</em> <a class="ae kl" href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.15/#configmap-v1-core" rel="noopener ugc nofollow" target="_blank"> <em class="iq">命名约定</em> </a> <em class="iq">即每个键必须由字母数字字符、“-”、“_”或“.”组成</em></p></blockquote><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="1991" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就像之前一样，我们需要创建<code class="fe km kn ko kp b">Pod</code>和<code class="fe km kn ko kp b">ConfigMap</code>并确认环境变量的存在</p><pre class="kr ks kt ku gt lm kp ln lo aw lp bi"><span id="191c" class="lq lr iq kp b gy ls lt l lu lv">$ kubectl apply -f   https://raw.githubusercontent.com/abhirockzz/kubernetes-in-a-nutshell/master/configuration/kin-config-envvar-with-envFrom.yaml</span><span id="2d1d" class="lq lr iq kp b gy nh lt l lu lv">configmap/config2 created<br/>pod/pod3 created</span><span id="5e2d" class="lq lr iq kp b gy nh lt l lu lv">$ kubectl get configmap/config2</span><span id="d479" class="lq lr iq kp b gy nh lt l lu lv">NAME      DATA   AGE<br/>config2   2      25s</span><span id="2a5a" class="lq lr iq kp b gy nh lt l lu lv">$ kubectl exec pod3 -it -- env | grep _ENV</span><span id="d6ed" class="lq lr iq kp b gy nh lt l lu lv">HELLO_ENV=world<br/>FOO_ENV=bar</span></pre><p id="5b2a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不错的小把戏哈？:-)</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/6814dd0d502aa059c3c830953ca3e7af.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/0*NjkY1GS3Fmgs8DYx.gif"/></div></figure><h2 id="e584" class="lq lr iq bd lx ni nj dn mb nk nl dp mf jy nm nn mj kc no np mn kg nq nr mr ns bi translated">作为文件的配置数据</h2><p id="fc20" class="pw-post-body-paragraph jn jo iq jp b jq mt js jt ju mu jw jx jy mv ka kb kc mw ke kf kg mx ki kj kk ij bi translated">另一种使用配置数据的有趣方式是指向<code class="fe km kn ko kp b">Deployment</code>或<code class="fe km kn ko kp b">Pod</code>规范的<code class="fe km kn ko kp b">spec.volumes</code>部分中的<code class="fe km kn ko kp b">ConfigMap</code>。</p><blockquote class="na nb nc"><p id="5bf1" class="jn jo nd jp b jq jr js jt ju jv jw jx ne jz ka kb nf kd ke kf ng kh ki kj kk ij bi translated"><em class="iq">如果你不知道</em> <code class="fe km kn ko kp b"><em class="iq">Volumes</em></code> <em class="iq">(在Kubernetes中)是什么，不要着急。他们将在即将到来的博客中讨论。现在，只需要理解卷是一种从底层存储系统抽象容器的方式，例如，它可以是本地磁盘或云中的磁盘，如</em> <a class="ae kl" href="https://docs.microsoft.com/azure/virtual-machines/windows/managed-disks-overview?WT.mc_id=medium-blog-abhishgu" rel="noopener ugc nofollow" target="_blank"> <em class="iq"> Azure磁盘</em></a><em class="iq"/><a class="ae kl" href="https://cloud.google.com/persistent-disk/" rel="noopener ugc nofollow" target="_blank"><em class="iq">GCP持久磁盘</em> </a> <em class="iq">等。</em></p></blockquote><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="a3fb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上面的规范中，注意<code class="fe km kn ko kp b">spec.volumes</code>部分——注意它指的是现有的<code class="fe km kn ko kp b">ConfigMap</code>。<code class="fe km kn ko kp b">ConfigMap</code>中的每个键都作为一个文件添加到规范中指定的目录，即<code class="fe km kn ko kp b">spec.containers.volumeMount.mountPath</code>，其值就是文件的内容。</p><blockquote class="na nb nc"><p id="50b5" class="jn jo nd jp b jq jr js jt ju jv jw jx ne jz ka kb nf kd ke kf ng kh ki kj kk ij bi translated"><em class="iq">注意，如果</em> <code class="fe km kn ko kp b"><em class="iq">ConfigMap</em></code> <em class="iq">改变，卷中的文件会自动更新。</em></p></blockquote><p id="520f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">除了传统的基于字符串的值，您还可以包括成熟的文件(JSON、文本、YAML等。)作为<code class="fe km kn ko kp b">ConfigMap</code>规格中的值。</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="03c5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上面的例子中，我们已经在我们的<code class="fe km kn ko kp b">ConfigMap</code>的数据部分中嵌入了一个完整的JSON。为了进行试验，创建<code class="fe km kn ko kp b">Pod</code>和<code class="fe km kn ko kp b">ConfigMap</code></p><pre class="kr ks kt ku gt lm kp ln lo aw lp bi"><span id="ef45" class="lq lr iq kp b gy ls lt l lu lv">$ kubectl apply -f   https://raw.githubusercontent.com/abhirockzz/kubernetes-in-a-nutshell/master/configuration/kin-config-envvar-json.yaml</span><span id="236b" class="lq lr iq kp b gy nh lt l lu lv">configmap/config3 created<br/>pod/pod4 created</span><span id="85db" class="lq lr iq kp b gy nh lt l lu lv">$ kubectl get configmap/config3</span><span id="671e" class="lq lr iq kp b gy nh lt l lu lv">NAME      DATA   AGE<br/>config3   1     11s</span></pre><p id="2812" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">作为练习，确认环境变量已经植入<code class="fe km kn ko kp b">Pod</code>。几个指针:</p><ul class=""><li id="90f7" class="ky kz iq jp b jq jr ju jv jy la kc lb kg lc kk ld le lf lg bi translated"><code class="fe km kn ko kp b">Pod</code>的名称是<code class="fe km kn ko kp b">pod4</code></li><li id="e6c1" class="ky kz iq jp b jq lh ju li jy lj kc lk kg ll kk ld le lf lg bi translated">仔细检查您应该寻找的环境变量的名称</li></ul><p id="991a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您也可以使用<code class="fe km kn ko kp b">kubectl</code> CLI创建一个<code class="fe km kn ko kp b">ConfigMap</code>。它可能并不适合所有的用例，但是它确实让事情变得简单多了</p><h1 id="8c5a" class="lw lr iq bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">使用<code class="fe km kn ko kp b">kubectl</code></h1><p id="0651" class="pw-post-body-paragraph jn jo iq jp b jq mt js jt ju mu jw jx jy mv ka kb kc mw ke kf kg mx ki kj kk ij bi translated">有多种选择:</p><h2 id="f1f6" class="lq lr iq bd lx ni nj dn mb nk nl dp mf jy nm nn mj kc no np mn kg nq nr mr ns bi translated">使用<code class="fe km kn ko kp b">--from-literal</code>植入配置数据</h2><p id="7e4e" class="pw-post-body-paragraph jn jo iq jp b jq mt js jt ju mu jw jx jy mv ka kb kc mw ke kf kg mx ki kj kk ij bi translated">我们将下面的键值对植入<code class="fe km kn ko kp b">ConfigMap</code> — <code class="fe km kn ko kp b">foo_env=bar</code>和<code class="fe km kn ko kp b">hello_env=world</code></p><pre class="kr ks kt ku gt lm kp ln lo aw lp bi"><span id="6745" class="lq lr iq kp b gy ls lt l lu lv">$ kubectl create configmap config4 --from-literal=foo_env=bar --from-literal=hello_env=world</span></pre><h2 id="4b5d" class="lq lr iq bd lx ni nj dn mb nk nl dp mf jy nm nn mj kc no np mn kg nq nr mr ns bi translated">使用<code class="fe km kn ko kp b">--from-file</code></h2><pre class="kr ks kt ku gt lm kp ln lo aw lp bi"><span id="01a2" class="lq lr iq kp b gy ls lt l lu lv">$ kubectl create configmap config5 --from-file=/config/app-config.properties</span></pre><p id="173d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这将创建一个<code class="fe km kn ko kp b">ConfigMap</code> ( <code class="fe km kn ko kp b">config5</code>)与</p><ul class=""><li id="e589" class="ky kz iq jp b jq jr ju jv jy la kc lb kg lc kk ld le lf lg bi translated">与文件同名的密钥，即本例中的<code class="fe km kn ko kp b">app-config.properties</code></li><li id="9cb2" class="ky kz iq jp b jq lh ju li jy lj kc lk kg ll kk ld le lf lg bi translated">和值作为文件的内容</li></ul><p id="1047" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以选择使用不同的键(而不是文件名)来覆盖默认行为</p><pre class="kr ks kt ku gt lm kp ln lo aw lp bi"><span id="a168" class="lq lr iq kp b gy ls lt l lu lv">$ kubectl create configmap config6 --from-file=CONFIG_DATA=/config/app-config.properties</span></pre><p id="223c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这种情况下，<code class="fe km kn ko kp b">CONFIG_DATA</code>将是关键</p><h2 id="46d4" class="lq lr iq bd lx ni nj dn mb nk nl dp mf jy nm nn mj kc no np mn kg nq nr mr ns bi translated">从目录中的文件</h2><p id="910e" class="pw-post-body-paragraph jn jo iq jp b jq mt js jt ju mu jw jx jy mv ka kb kc mw ke kf kg mx ki kj kk ij bi translated">您可以一次将多个文件(在一个目录中)中的数据植入一个<code class="fe km kn ko kp b">ConfigMap</code></p><pre class="kr ks kt ku gt lm kp ln lo aw lp bi"><span id="f078" class="lq lr iq kp b gy ls lt l lu lv">$ kubectl create configmap config7 --from-file=/home/foo/config/</span></pre><p id="e75a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你最终会得到</p><ul class=""><li id="70f3" class="ky kz iq jp b jq jr ju jv jy la kc lb kg lc kk ld le lf lg bi translated">多个密钥将与单个文件名相同</li><li id="0430" class="ky kz iq jp b jq lh ju li jy lj kc lk kg ll kk ld le lf lg bi translated">该值将是相应文件的内容</li></ul><h1 id="1f46" class="lw lr iq bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">很高兴知道</h1><p id="50e9" class="pw-post-body-paragraph jn jo iq jp b jq mt js jt ju mu jw jx jy mv ka kb kc mw ke kf kg mx ki kj kk ij bi translated">以下是您在使用<code class="fe km kn ko kp b">ConfigMap</code> s时应谨记的事项(非详尽列表):</p><ul class=""><li id="5793" class="ky kz iq jp b jq jr ju jv jy la kc lb kg lc kk ld le lf lg bi translated">一旦您定义了环境变量<code class="fe km kn ko kp b">ConfigMap</code>，您就可以在<code class="fe km kn ko kp b">Pod</code>规范的命令部分使用它们，即使用<code class="fe km kn ko kp b">$(VARIABLE_NAME)</code>格式的<code class="fe km kn ko kp b">spec.containers.command</code></li><li id="c398" class="ky kz iq jp b jq lh ju li jy lj kc lk kg ll kk ld le lf lg bi translated">您需要确保在<code class="fe km kn ko kp b">Pod</code>中被引用的<code class="fe km kn ko kp b">ConfigMap</code>已经被创建——否则，<code class="fe km kn ko kp b">Pod</code>将<em class="nd">不会启动</em>。解决这个问题的唯一方法是将<code class="fe km kn ko kp b">ConfigMap</code>标记为<code class="fe km kn ko kp b">optional</code>。</li><li id="9e01" class="ky kz iq jp b jq lh ju li jy lj kc lk kg ll kk ld le lf lg bi translated">另一种可能阻止<code class="fe km kn ko kp b">Pod</code>启动的情况是当您引用了一个实际上在<code class="fe km kn ko kp b">ConfigMap</code>中不存在的键。</li></ul><blockquote class="na nb nc"><p id="b2cb" class="jn jo nd jp b jq jr js jt ju jv jw jx ne jz ka kb nf kd ke kf ng kh ki kj kk ij bi translated"><em class="iq">你也可以参考</em> <code class="fe km kn ko kp b"><a class="ae kl" href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.15/#configmap-v1-core" rel="noopener ugc nofollow" target="_blank"><em class="iq">ConfigMap API</em></a></code></p></blockquote><p id="1aa7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是本期“果壳中的库伯内特”系列的全部内容。敬请关注更多内容！</p><p id="69ee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你对使用<a class="ae kl" href="https://azure.microsoft.com/services/kubernetes-service/?WT.mc_id=medium-blog-abhishgu" rel="noopener ugc nofollow" target="_blank"> Azure </a>学习Kubernetes和Containers感兴趣，只需<a class="ae kl" href="https://azure.microsoft.com/en-us/free/?WT.mc_id=medium-blog-abhishgu" rel="noopener ugc nofollow" target="_blank">创建一个<strong class="jp ir">免费</strong>账户</a>就可以开始了！一个好的起点是使用文档中的<a class="ae kl" href="https://docs.microsoft.com/azure/aks/?WT.mc_id=medium-blog-abhishgu" rel="noopener ugc nofollow" target="_blank">快速入门、教程和代码示例</a>来熟悉这项服务。我也强烈推荐查看<a class="ae kl" href="https://azure.microsoft.com/resources/kubernetes-learning-path/?WT.mc_id=medium-blog-abhishgu" rel="noopener ugc nofollow" target="_blank"> 50天Kubernetes学习路径</a>。高级用户可能希望参考<a class="ae kl" href="https://docs.microsoft.com/azure/aks/best-practices?WT.mc_id=medium-blog-abhishgu" rel="noopener ugc nofollow" target="_blank"> Kubernetes最佳实践</a>或观看一些<a class="ae kl" href="https://azure.microsoft.com/resources/videos/index/?services=kubernetes-service&amp;WT.mc_id=medium-blog-abhishgu" rel="noopener ugc nofollow" target="_blank">视频</a>以了解演示、主要功能和技术会议。</p><p id="e255" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我真的希望你喜欢这篇文章，并从中学到了一些东西！如果你做了，请喜欢并跟随。很高兴通过<a class="ae kl" href="https://twitter.com/abhi_tweeter" rel="noopener ugc nofollow" target="_blank"> @abhi_tweeter </a>获得反馈或发表评论。</p><div class="nu nv gp gr nw nx"><a href="https://twitter.com/abhi_tweeter" rel="noopener  ugc nofollow" target="_blank"><div class="ny ab fo"><div class="nz ab oa cl cj ob"><h2 class="bd ir gy z fp oc fr fs od fu fw ip bi translated">阿布舍克</h2><div class="oe l"><h3 class="bd b gy z fp oc fr fs od fu fw dk translated">Abhishek的最新推文(@abhi_tweeter)。云开发者🥑@Microsoft @azureadvocates |…</h3></div><div class="of l"><p class="bd b dl z fp oc fr fs od fu fw dk translated">twitter.com</p></div></div><div class="og l"><div class="oh l oi oj ok og ol kw nx"/></div></div></a></div></div></div>    
</body>
</html>