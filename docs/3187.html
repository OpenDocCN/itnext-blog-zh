<html>
<head>
<title>Merging React Refs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">合并反应参考</h1>
<blockquote>原文：<a href="https://itnext.io/mergin-react-refs-5e26f3fcf765?source=collection_archive---------2-----------------------#2019-10-20">https://itnext.io/mergin-react-refs-5e26f3fcf765?source=collection_archive---------2-----------------------#2019-10-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/034d9ba35d13bf20a7679dcbae55556c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L_GAzRRLIrW9BnmKjWZC1A.png"/></div></div></figure><blockquote class="jy jz ka"><p id="91d7" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="iq">TL；DR — </em> <code class="fe la lb lc ld b"><em class="iq">useRef</em></code> <em class="iq">和</em> <code class="fe la lb lc ld b"><em class="iq">createRef</em></code> <em class="iq">并不是您可能感兴趣的唯一API调用👨‍🔬</em></p></blockquote><p id="8ee5" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km le ko kp kq lf ks kt ku lg kw kx ky kz ij bi translated">让我们想象一下——你正在打开一个<a class="ae lh" href="https://reactjs.org/docs/hooks-reference.html#useimperativehandle" rel="noopener ugc nofollow" target="_blank"> React Hooks API Reference </a>，寻找可用的钩子，然后……你的眼睛发现了一个奇怪的钩子，你可能之前错过了——<code class="fe la lb lc ld b">useImperativeHandle</code>。你从未使用过它，可能也从未需要过它，也不知道它有什么用。并且所提供的例子对理解用例没有太大的帮助。<br/>那么是什么呢？</p><pre class="li lj lk ll gt lm ld ln lo aw lp bi"><span id="f8fe" class="lq lr iq ld b gy ls lt l lu lv">function FancyInput(props, ref) {<br/>  const inputRef = useRef();<br/>  useImperativeHandle(ref, () =&gt; ({<br/>    focus: () =&gt; {<br/>      inputRef.current.focus();<br/>    }<br/>  }));<br/>  return &lt;input ref={inputRef} ... /&gt;;<br/>}<br/>FancyInput = forwardRef(FancyInput);</span></pre><p id="b3c3" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km le ko kp kq lf ks kt ku lg kw kx ky kz ij bi translated">嗯，正如我刚才所说——那没什么帮助。我想没人明白这里写的是什么🤔。为什么写在这里🤷‍♂️.让我们用一行代码来解决这个问题。</p><pre class="li lj lk ll gt lm ld ln lo aw lp bi"><span id="81ab" class="lq lr iq ld b gy ls lt l lu lv">function FancyInput(props, ref) {<br/>  const inputRef = useRef();<br/>  useImperativeHandle(ref, () =&gt; ({<br/>+   // this is the PUBLIC API, we are exposing to a consumer via `ref`<br/>    focus: () =&gt; {<br/>      inputRef.current.focus();<br/>    }<br/>  }));<br/>  return &lt;input ref={inputRef} ... /&gt;;<br/>}<br/>FancyInput = forwardRef(FancyInput);</span></pre><p id="f5f2" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km le ko kp kq lf ks kt ku lg kw kx ky kz ij bi translated">换句话说——曾经有人会<code class="fe la lb lc ld b">&lt;FancyInput ref={ref} /&gt;</code>说<code class="fe la lb lc ld b">ref</code>只会包含<strong class="ke ir"/><code class="fe la lb lc ld b">.focus</code>。</p><blockquote class="jy jz ka"><p id="b9bc" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="iq">这里有一个</em> <strong class="ke ir"> <em class="iq">代码三个盒子</em> </strong> <em class="iq">你可以用</em>玩</p></blockquote><figure class="li lj lk ll gt jr"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="8b8a" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km le ko kp kq lf ks kt ku lg kw kx ky kz ij bi translated"><code class="fe la lb lc ld b">useImperativeHandle</code>的力量是一个<a class="ae lh" href="https://en.wikipedia.org/wiki/Bridge_pattern" rel="noopener ugc nofollow" target="_blank">桥</a>的力量，或者更具体地说——一个<a class="ae lh" href="https://en.wikipedia.org/wiki/Facade_pattern" rel="noopener ugc nofollow" target="_blank">立面</a> <strong class="ke ir">图案</strong>(你可能知道它是一个<strong class="ke ir">包装</strong>)。</p><p id="aa18" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km le ko kp kq lf ks kt ku lg kw kx ky kz ij bi translated">然而，<code class="fe la lb lc ld b">useImperativeHandle</code>100%没用，对现实无能为力——我会在下面证明。</p><p id="7cd5" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km le ko kp kq lf ks kt ku lg kw kx ky kz ij bi translated">让我们将一切分解为原子操作，以了解我们实际上需要什么，以及还缺少什么。</p><h1 id="8f0e" class="ly lr iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">1.当裁判改变时，我想做些什么</h1><p id="92eb" class="pw-post-body-paragraph kb kc iq ke b kf mv kh ki kj mw kl km le mx kp kq lf my kt ku lg mz kx ky kz ij bi translated">让我们假设您想要根据<code class="fe la lb lc ld b">ref</code>值公开不同的状态，因为<em class="kd">不同的</em> <code class="fe la lb lc ld b">refs</code>可能意味着<em class="kd">不同的</em>。但是，您向父对象公开的<code class="fe la lb lc ld b">wrapper</code>(和<code class="fe la lb lc ld b">useImperativeHandle</code>“公开”a <code class="fe la lb lc ld b">wrapper</code>)是<strong class="ke ir">总是静态的</strong>。这在某些情况下可以，但在其他情况下就不行了。比如，你不能暴露一个<code class="fe la lb lc ld b">real ref</code>——只能暴露它周围的一个<code class="fe la lb lc ld b">wrapper</code>，永远是一个<code class="fe la lb lc ld b">wrapper</code>。</p><blockquote class="jy jz ka"><p id="dc96" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="iq">你需要类似于</em> <code class="fe la lb lc ld b"><em class="iq">useImperativeHandle(ref, inputRef)</em></code> <em class="iq">的东西来同步</em> <code class="fe la lb lc ld b"><em class="iq">ref.current</em></code> <em class="iq">和</em> <code class="fe la lb lc ld b"><em class="iq">inputRef.current</em></code> <em class="iq">之间的值，但是它不起作用——只有</em> <code class="fe la lb lc ld b"><em class="iq">useImperativeHandle(ref, () =&gt; inputRef.current)</em></code> <em class="iq">可以工作，但是当</em> <code class="fe la lb lc ld b"><em class="iq">inputRef</em></code> <em class="iq">改变时它不会更新值。你没有办法对</em> <code class="fe la lb lc ld b"><em class="iq">inputRef.current</em></code> <em class="iq">的变化做出反应</em></p></blockquote><p id="c2f6" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km le ko kp kq lf ks kt ku lg kw kx ky kz ij bi translated">您可以尝试使用<code class="fe la lb lc ld b">useImperativeHandle</code>钩子的<code class="fe la lb lc ld b">dependency</code>列表来处理这种情况。类似于:</p><pre class="li lj lk ll gt lm ld ln lo aw lp bi"><span id="0fe7" class="lq lr iq ld b gy ls lt l lu lv">useImperativeHandle( <br/>   ref, <br/>   () =&gt; inputRef.current, <br/>   [mmm, butWhen, itsGoing, toChange] // 🤷‍♂️ 🤔<br/>);</span></pre><p id="2c8d" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km le ko kp kq lf ks kt ku lg kw kx ky kz ij bi translated">好吧，你不需要<em class="kd">依赖</em>这些依赖关系(并且<code class="fe la lb lc ld b">eslint</code>规则不会帮助你)，而是你附加<code class="fe la lb lc ld b">ref</code>的东西。更重要的是——你可以将“你的”<code class="fe la lb lc ld b">ref</code>附加到同一个<code class="fe la lb lc ld b">forwardProp</code>组件上，这样做也是一样的——<strong class="ke ir">你不能控制什么是</strong><code class="fe la lb lc ld b"><strong class="ke ir">ref</strong></code><strong class="ke ir"/>。这是一个黑盒，你不可能安全地预测这个黑盒是如何工作的。</p><blockquote class="jy jz ka"><p id="2356" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这种图案非常易碎，请不要使用。请记住，官方文档也要求不要使用它。</p></blockquote><p id="0f1d" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km le ko kp kq lf ks kt ku lg kw kx ky kz ij bi translated">使这种模式“稳定”的唯一方法是知道<code class="fe la lb lc ld b">ref</code>何时更新，并且<em class="kd">反应性地</em>更新<code class="fe la lb lc ld b">parentRef</code>。<br/>怎么做？使用参考号<code class="fe la lb lc ld b">callback</code>！这是官方的建议。</p><figure class="li lj lk ll gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi na"><img src="../Images/b9ba0914b8f369c4645b61e4b76695f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*rUS06qwF_cfoPY4f.png"/></div></div></figure><p id="2330" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km le ko kp kq lf ks kt ku lg kw kx ky kz ij bi translated">这也不是一个好主意。回调并不好，可能这就是为什么我们有<code class="fe la lb lc ld b">RefObject</code>。</p><p id="8a6f" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km le ko kp kq lf ks kt ku lg kw kx ky kz ij bi translated">如何使用<code class="fe la lb lc ld b">RefObject</code>并得到变更通知？简单，和es5兼容。</p><pre class="li lj lk ll gt lm ld ln lo aw lp bi"><span id="fcdd" class="lq lr iq ld b gy ls lt l lu lv">function createCallbackRef(onChangeCallback) {<br/>  let current = null;<br/>  return {<br/>    set current(newValue) {<br/>      // new value set<br/>      current=newValue;<br/>      onChangeCallback(newValue);<br/>    }<br/>    get current() {<br/>      // what shall I return?<br/>      return current;<br/>    }<br/>  }<br/>}</span></pre><p id="fde0" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km le ko kp kq lf ks kt ku lg kw kx ky kz ij bi translated">对象<strong class="ke ir">获取器和设置器</strong>用于救援。还有另一篇关于这种方法的文章，深入解释了不同的用例:</p><div class="nb nc gp gr nd ne"><a href="https://dev.to/thekashey/the-same-useref-but-it-will-callback-8bo" rel="noopener  ugc nofollow" target="_blank"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd ir gy z fp nj fr fs nk fu fw ip bi translated">同一个useRef，但是它会回调🤙</h2><div class="nl l"><h3 class="bd b gy z fp nj fr fs nk fu fw dk translated">很长一段时间，我们没有ref-我们只有ref，它是基于回调的。某些东西会通过调用来设置裁判…</h3></div><div class="nm l"><p class="bd b dl z fp nj fr fs nk fu fw dk translated">开发到</p></div></div><div class="nn l"><div class="no l np nq nr nn ns jw ne"/></div></div></a></div><h1 id="176a" class="ly lr iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">2.我想使用对DOM对象的引用</h1><p id="e250" class="pw-post-body-paragraph kb kc iq ke b kf mv kh ki kj mw kl km le mx kp kq lf my kt ku lg mz kx ky kz ij bi translated">这很好，但是当您需要处理真正的DOM元素时，这并没有什么帮助。<br/>问题还是一样——让<strong class="ke ir">有一个本地引用</strong>，并将其与父引用同步。你需要一石二鸟。我的意思是-你需要更新两个就像只有一个！</p><figure class="li lj lk ll gt jr"><div class="bz fp l di"><div class="nt lx l"/></div></figure><p id="58bb" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km le ko kp kq lf ks kt ku lg kw kx ky kz ij bi translated">事实上——这是一个非常需要和非常强大的功能，就像<code class="fe la lb lc ld b">forwardRef</code>本身一样有用——能够在本地维护<code class="fe la lb lc ld b">ref</code>,对于外部消费者来说仍然是<em class="kd">透明的</em>。</p><p id="64d9" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km le ko kp kq lf ks kt ku lg kw kx ky kz ij bi translated">从某种角度来看，<code class="fe la lb lc ld b">mergeRef</code>是一个<code class="fe la lb lc ld b">forwardRef</code>，只要它<em class="kd">向前</em>一个给定的ref，就不止一个位置。</p><h1 id="73aa" class="ly lr iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">3.我想更新参考文献</h1><p id="1a00" class="pw-post-body-paragraph kb kc iq ke b kf mv kh ki kj mw kl km le mx kp kq lf my kt ku lg mz kx ky kz ij bi translated">但是，<code class="fe la lb lc ld b">ref</code>是什么？它可以是一个对象(<code class="fe la lb lc ld b">ref object</code>)，也可以是一个函数(<code class="fe la lb lc ld b">callback ref</code>)。如果不知道提供的<code class="fe la lb lc ld b">ref</code>是什么，如何设置新值？</p><p id="cc29" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km le ko kp kq lf ks kt ku lg kw kx ky kz ij bi translated"><code class="fe la lb lc ld b">React</code>和<code class="fe la lb lc ld b">useImperativeHandle</code>以及<code class="fe la lb lc ld b">mergeRef</code>都在内部隐藏了这个逻辑，但是在其他情况下你可能需要它。以<code class="fe la lb lc ld b">useEffect</code>为例。<br/>所以给你:</p><pre class="li lj lk ll gt lm ld ln lo aw lp bi"><span id="972a" class="lq lr iq ld b gy ls lt l lu lv">function assignRef&lt;T&gt;(ref, value) {<br/>  if (typeof ref === 'function') {<br/>    ref(value);<br/>  } else if (ref != null) {<br/>    ref.current = value;<br/>  }<br/>  return ref;<br/>}</span></pre><p id="e3f8" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km le ko kp kq lf ks kt ku lg kw kx ky kz ij bi translated">如果将来<code class="fe la lb lc ld b">ref</code>的形状会再次改变，就像React 16发布时那样，这将只是一个需要更新的函数。</p><h1 id="5bec" class="ly lr iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">4.我想改变我的裁判</h1><p id="aac5" class="pw-post-body-paragraph kb kc iq ke b kf mv kh ki kj mw kl km le mx kp kq lf my kt ku lg mz kx ky kz ij bi translated">哪(惊喜！)是<code class="fe la lb lc ld b">useImperativeHandle</code>所做的——它给你一个编程的方法来返回其他的东西，从原始的ref。</p><p id="e5cf" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km le ko kp kq lf ks kt ku lg kw kx ky kz ij bi translated">所以，如果你想:</p><ul class=""><li id="349d" class="nu nv iq ke b kf kg kj kk le nw lf nx lg ny kz nz oa ob oc bi translated">有一个<code class="fe la lb lc ld b">local ref</code>，指的是真正的DOM节点</li><li id="a621" class="nu nv iq ke b kf od kj oe le of lf og lg oh kz nz oa ob oc bi translated">用<code class="fe la lb lc ld b">.focus</code>方法向父对象公开ref</li></ul><p id="d512" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km le ko kp kq lf ks kt ku lg kw kx ky kz ij bi translated">然后你必须合并和转换</p><pre class="li lj lk ll gt lm ld ln lo aw lp bi"><span id="27bd" class="lq lr iq ld b gy ls lt l lu lv">-useImperativeHandle(ref, () =&gt; ({<br/>-  focus: () =&gt; {<br/>-    inputRef.current.focus();<br/>-  }<br/>-}));<br/>mergeRefs([innerRef, tranformRef(ref, (current) =&gt; ({focus:() =&gt; current.focus()})</span></pre><p id="4d8e" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km le ko kp kq lf ks kt ku lg kw kx ky kz ij bi translated">如何创作<code class="fe la lb lc ld b">transformRef</code>？嗯，我们需要一些我们已经有的零件- <code class="fe la lb lc ld b">callbackRef</code>和<code class="fe la lb lc ld b">assignRef</code></p><pre class="li lj lk ll gt lm ld ln lo aw lp bi"><span id="efe8" class="lq lr iq ld b gy ls lt l lu lv">function transformRef(ref, transformer) {<br/>  return createCallbackRef(<br/>    value =&gt; assignRef(ref, transformer(value))<br/>  )<br/>}</span></pre><p id="66e7" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km le ko kp kq lf ks kt ku lg kw kx ky kz ij bi translated"><code class="fe la lb lc ld b">transformRef</code>是两个世界之间真正的“桥梁”，例如在这个<a class="ae lh" href="https://github.com/theKashey/react-focus-lock/issues/85" rel="noopener ugc nofollow" target="_blank">问题</a>中，有人需要将一个“ref，存储在一个ClassComponent实例中，传递给父对象”。</p><pre class="li lj lk ll gt lm ld ln lo aw lp bi"><span id="49ce" class="lq lr iq ld b gy ls lt l lu lv">const FocusLock = ({As}) =&gt; &lt;As ref={ref} /&gt;</span><span id="535c" class="lq lr iq ld b gy oi lt l lu lv">const ResizableWithRef = forwardRef((props, ref) =&gt;<br/>  &lt;Resizable {...props} ref={i =&gt; i &amp;&amp; ref(i.resizable)}/&gt;<br/>  // i is a ref to a Class Component with .resizable property<br/>);<br/>// ...<br/>&lt;FocusLock as={ResizableWithRef}&gt;</span></pre><ul class=""><li id="13f2" class="nu nv iq ke b kf kg kj kk le nw lf nx lg ny kz nz oa ob oc bi translated"><code class="fe la lb lc ld b">FocusLock</code>期望<code class="fe la lb lc ld b">ref</code>成为<code class="fe la lb lc ld b">DOMNode</code></li><li id="2ab2" class="nu nv iq ke b kf od kj oe le of lf og lg oh kz nz oa ob oc bi translated"><code class="fe la lb lc ld b">Resizable</code>是一个<strong class="ke ir">类</strong>组件，所以我们将<code class="fe la lb lc ld b">ref</code>转换成一个<strong class="ke ir">类实例</strong></li><li id="b640" class="nu nv iq ke b kf od kj oe le of lf og lg oh kz nz oa ob oc bi translated"><code class="fe la lb lc ld b">i =&gt; i &amp;&amp; ref(i.resizable)</code> -回调ref - <em class="kd">将</em> <code class="fe la lb lc ld b">i.resizable</code>转换为焦点锁定ref，<em class="kd">自适应</em>API。</li></ul><p id="245a" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km le ko kp kq lf ks kt ku lg kw kx ky kz ij bi translated">和<code class="fe la lb lc ld b">transformRef</code>在一起会是什么样子</p><pre class="li lj lk ll gt lm ld ln lo aw lp bi"><span id="1d11" class="lq lr iq ld b gy ls lt l lu lv">&lt;Resizable {...props} ref={transformRef(ref, i =&gt; i.resizable)}/&gt;</span></pre><p id="60a8" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km le ko kp kq lf ks kt ku lg kw kx ky kz ij bi translated">看起来一样，但不要求<code class="fe la lb lc ld b">ref</code>是<code class="fe la lb lc ld b">callback ref</code>——你不需要担心<code class="fe la lb lc ld b">how</code>你要做什么，只需要担心<code class="fe la lb lc ld b">what</code>你要做什么。</p><h1 id="76e3" class="ly lr iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">5.我希望我的裁判不要每次都重新上马</h1><p id="23ec" class="pw-post-body-paragraph kb kc iq ke b kf mv kh ki kj mw kl km le mx kp kq lf my kt ku lg mz kx ky kz ij bi translated">不知道你是否注意到了，但是上面的代码(是的，上面的所有代码)可以工作，但是不会让你(和反应)开心。</p><p id="4a39" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km le ko kp kq lf ks kt ku lg kw kx ky kz ij bi translated">问题是:当<code class="fe la lb lc ld b">ref</code>改变时，<code class="fe la lb lc ld b">React</code>会将<code class="fe la lb lc ld b">null</code>设置为旧值，然后将正确的值设置为新值。而且，只要上面的所有函数每次都返回一个新函数或新对象——每次它们都会导致本地和父refs的更新。</p><blockquote class="jy jz ka"><p id="259f" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果你使用回调引用，并基于它们的值运行一些效果——那么这将导致更大的更新。</p></blockquote><p id="832a" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km le ko kp kq lf ks kt ku lg kw kx ky kz ij bi translated">我们不要那样做。让我们用<code class="fe la lb lc ld b">hooks</code>来记忆<code class="fe la lb lc ld b">ref</code></p><pre class="li lj lk ll gt lm ld ln lo aw lp bi"><span id="ef40" class="lq lr iq ld b gy ls lt l lu lv">function useTransformRef(ref, transformer) {<br/>  return useState(() =&gt; createCallbackRef(<br/>    value =&gt; assignRef(ref, transformer(value))<br/>  ))[0];<br/>}</span></pre><p id="b57e" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km le ko kp kq lf ks kt ku lg kw kx ky kz ij bi translated">简单而可靠——我们使用<code class="fe la lb lc ld b">useState</code>和<code class="fe la lb lc ld b">state fabric</code>作为参数，只创建一次ref，让我们的代码执行起来更加简单。</p><h1 id="7b91" class="ly lr iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">结论</h1><p id="ee0a" class="pw-post-body-paragraph kb kc iq ke b kf mv kh ki kj mw kl km le mx kp kq lf my kt ku lg mz kx ky kz ij bi translated">有一个库，已经实现了我上面提供的所有的<em class="kd">原子</em>，经过测试和类型化:</p><div class="nb nc gp gr nd ne"><a href="https://github.com/theKashey/use-callback-ref" rel="noopener  ugc nofollow" target="_blank"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd ir gy z fp nj fr fs nk fu fw ip bi translated">卡什/使用回调引用</h2><div class="nl l"><h3 class="bd b gy z fp nj fr fs nk fu fw dk translated">请记住，useRef不会在内容发生变化时通知您。变异了。当前属性不会导致…</h3></div><div class="nm l"><p class="bd b dl z fp nj fr fs nk fu fw dk translated">github.com</p></div></div><div class="nn l"><div class="oj l np nq nr nn ns jw ne"/></div></div></a></div></div><div class="ab cl ok ol hu om" role="separator"><span class="on bw bk oo op oq"/><span class="on bw bk oo op oq"/><span class="on bw bk oo op"/></div><div class="ij ik il im in"><ul class=""><li id="8d53" class="nu nv iq ke b kf kg kj kk le nw lf nx lg ny kz nz oa ob oc bi translated"><code class="fe la lb lc ld b">assignRef</code></li><li id="f0f0" class="nu nv iq ke b kf od kj oe le of lf og lg oh kz nz oa ob oc bi translated"><code class="fe la lb lc ld b">useCallbackRef</code> / <code class="fe la lb lc ld b">createCallbackRef</code></li><li id="3a85" class="nu nv iq ke b kf od kj oe le of lf og lg oh kz nz oa ob oc bi translated"><code class="fe la lb lc ld b">useMergeRefs</code> / <code class="fe la lb lc ld b">mergeRefs</code></li><li id="1b45" class="nu nv iq ke b kf od kj oe le of lf og lg oh kz nz oa ob oc bi translated"><code class="fe la lb lc ld b">useTransformRef</code> / <code class="fe la lb lc ld b">transformRef</code></li><li id="dfb2" class="nu nv iq ke b kf od kj oe le of lf og lg oh kz nz oa ob oc bi translated"><code class="fe la lb lc ld b">useRefToCallback</code> / <code class="fe la lb lc ld b">refToCallback</code></li></ul><blockquote class="jy jz ka"><p id="07a7" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="iq">声明:所有</em> <code class="fe la lb lc ld b"><em class="iq">mergeRefs</em></code> <em class="iq">的荣誉归于格雷格·伯奇和</em><a class="ae lh" href="https://github.com/smooth-code/react-merge-refs" rel="noopener ugc nofollow" target="_blank"><em class="iq">react-merge-refs</em></a></p></blockquote></div></div>    
</body>
</html>