<html>
<head>
<title>Error handling across different languages</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">跨不同语言的错误处理</h1>
<blockquote>原文：<a href="https://itnext.io/error-handling-330d7aea1480?source=collection_archive---------4-----------------------#2022-03-20">https://itnext.io/error-handling-330d7aea1480?source=collection_archive---------4-----------------------#2022-03-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/392c0258f42fa1015bd437e9e5fb5fca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*105RkrdJ-d6dYyFk_VxW4g.jpeg"/></div></div></figure><p id="2f7b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我过去也尝试过围棋，至少我可以说我对它不感兴趣。我最大的苦恼是这种语言如何处理错误，或者更准确地说，它为开发人员提供了管理错误的机制。在这篇文章中，我想描述几种流行的语言是如何处理错误的。</p><h1 id="2faf" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">我们时代之前的时代</h1><p id="1a90" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">我可能会回到很久以前，但我需要在某个时候选择一个基线。在这篇文章中，基线是c。</p><p id="d894" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您在网上搜索“错误处理C ”,您可能会经常看到以下内容:</p><blockquote class="lz ma mb"><p id="95b5" class="jy jz mc ka b kb kc kd ke kf kg kh ki md kk kl km me ko kp kq mf ks kt ku kv ij bi translated"><em class="iq"> C不直接支持错误处理</em></p></blockquote><p id="8506" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于缺乏支持，开发人员创建了应对机制。一种方法是让函数返回一个表示错误的值。该值是数字，文档描述了该问题。</p><p id="3cb8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果函数需要返回一个值，你需要选择。<br/>例如:</p><ul class=""><li id="d591" class="mg mh iq ka b kb kc kf kg kj mi kn mj kr mk kv ml mm mn mo bi translated">定义发生错误时将被设置的指针参数。如果呼叫成功，将是<code class="fe mp mq mr ms b">null</code>。</li><li id="79c9" class="mg mh iq ka b kb mt kf mu kj mv kn mw kr mx kv ml mm mn mo bi translated">另一种方法是使用专用的结构，用一个字段专门存储错误。</li></ul><p id="4ca4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最终的解决方案是使用一个全局误差变量— <code class="fe mp mq mr ms b">errno</code>。</p><p id="9a34" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">每种选择都有利弊。然而，由于没有固定的方式，最大的问题是缺乏一致性。</p><h1 id="84b9" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">例外</h1><p id="0d51" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">我不知道是哪种语言首先实现了异常，但我很确定是Java普及了异常。异常解决了一个常见的问题:简单的错误检查代码将名义路径和错误处理路径交织在一起:</p><pre class="my mz na nb gt nc ms nd ne aw nf bi"><span id="a91d" class="ng kx iq ms b gy nh ni l nj nk">int foo;<br/>int bar;<br/>int slice;<br/>foo = get_foo();<br/>if (foo &lt; 0)<br/>    {<br/>        return foo;<br/>    }<br/>bar = slice_the_bar(foo);<br/>if (bar &lt; 0)<br/>    {<br/>        return bar;<br/>    }<br/>slice = check_bar_slice(bar);<br/>if (slice &lt; 0)<br/>    {<br/>        return slice;<br/>    }</span></pre><p id="d29e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">异常的好处是将它们清楚地分隔在不同的块中，以便于阅读:</p><pre class="my mz na nb gt nc ms nd ne aw nf bi"><span id="6771" class="ng kx iq ms b gy nh ni l nj nk">try {<br/>    int foo = getFoo();             // 1   // 4<br/>    int bar = sliceTheBar(foo);     // 2   // 4<br/>    checkBarSlice(bar);             // 3   // 4<br/>} catch (FooException e) {<br/>    // Do something with e          // 1<br/>} catch (BarException e) {<br/>    // Do something with e          // 2<br/>} catch (SliceException e) {<br/>    // Do something with e          // 3<br/>} finally {<br/>    // Will be executed in all cases<br/>}</span></pre><ol class=""><li id="4e56" class="mg mh iq ka b kb kc kf kg kj mi kn mj kr mk kv nl mm mn mo bi translated">如果调用抛出<code class="fe mp mq mr ms b">FooException</code>，则短路并直接执行相关的<code class="fe mp mq mr ms b">catch</code>块</li><li id="069d" class="mg mh iq ka b kb mt kf mu kj mv kn mw kr mx kv nl mm mn mo bi translated"><code class="fe mp mq mr ms b">BarException</code>也是如此</li><li id="f38f" class="mg mh iq ka b kb mt kf mu kj mv kn mw kr mx kv nl mm mn mo bi translated">同样适用于<code class="fe mp mq mr ms b">SliceException</code></li><li id="b7eb" class="mg mh iq ka b kb mt kf mu kj mv kn mw kr mx kv nl mm mn mo bi translated">额定通路</li></ol><p id="329f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Java异常是在其类型系统中烘焙的。</p><figure class="my mz na nb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nm"><img src="../Images/beb540cea671d0d73fdeb151e90c20dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*yybVJwRT83pueiyt.png"/></div></div></figure><p id="5f3a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Java提供了两种类型的异常:<em class="mc">选中</em>和<em class="mc">未选中</em>。检查例外需要:</p><ul class=""><li id="ef24" class="mg mh iq ka b kb kc kf kg kj mi kn mj kr mk kv ml mm mn mo bi translated">或者在上述的<code class="fe mp mq mr ms b">try</code> / <code class="fe mp mq mr ms b">catch</code>模块中进行本地处理</li><li id="3f27" class="mg mh iq ka b kb mt kf mu kj mv kn mw kr mx kv ml mm mn mo bi translated">或者通过在方法签名中定义异常来“向上”传播，<em class="mc">例如</em>:</li></ul><pre class="my mz na nb gt nc ms nd ne aw nf bi"><span id="ed48" class="ng kx iq ms b gy nh ni l nj nk">Foo getFoo() throws FooException {<br/>    // return a Foo or throw a new FooException<br/>}</span></pre><p id="1e30" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">编译器强制执行这一要求。未检查的异常不需要遵循这个规则，但是可以。</p><p id="833a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一些后来设计的语言也实现了异常:Scala和Kotlin，因为它们共享Java的JVM根，但也共享Python和Ruby。</p><h1 id="8c8c" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">试用容器</h1><p id="f893" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">虽然异常是对普通返回值的改进，但它们也不能免于批评。它的主要目的是检查异常，因为它们所基于的机制会使代码变得混乱。此外，一些人认为<em class="mc">所有的</em>异常都是<code class="fe mp mq mr ms b">GOTO</code>异常，因为它具有短路的性质。</p><p id="f08f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">随着近年来函数式编程的兴起，开发人员提供了库来将其引入主流语言。异常是FP实践者所厌恶的，因为它们为部分定义的函数开辟了道路。部分定义的函数是仅对特定范围的参数值有效的函数。例如，<code class="fe mp mq mr ms b">divide()</code>对除0以外的所有参数都有效。在FP中，应该返回一个调用的结果，不管是成功还是失败。</p><p id="8255" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在Java中，<a class="ae nn" href="https://docs.vavr.io/" rel="noopener ugc nofollow" target="_blank"> Vavr </a>库用<a class="ae nn" href="https://docs.vavr.io/#_try" rel="noopener ugc nofollow" target="_blank"> Try </a>类型在异常和FP之间架起了一座桥梁。我们可以用Vavr将上面的代码片段重写为:</p><pre class="my mz na nb gt nc ms nd ne aw nf bi"><span id="7328" class="ng kx iq ms b gy nh ni l nj nk">Try.of(() -&gt; getFoo())                      // 1<br/>   .mapTry(foo -&gt; sliceTheBar(foo))         // 1<br/>   .andThenTry(bar -&gt; checkBarSlice(bar))   // 1<br/>   .recover(FooException.class, e -&gt; 1)     // 2<br/>   .recover(BarException.class, e -&gt; 2)     // 2<br/>   .recover(SliceException.class, e -&gt; 3)   // 2<br/>   .andFinally(() -&gt; {})                    // 3<br/>   .getOrElse(() -&gt; 5);                     // 4</span></pre><ol class=""><li id="5211" class="mg mh iq ka b kb kc kf kg kj mi kn mj kr mk kv nl mm mn mo bi translated">额定通路</li><li id="87ec" class="mg mh iq ka b kb mt kf mu kj mv kn mw kr mx kv nl mm mn mo bi translated">设置返回值，以防引发相关异常</li><li id="bcb6" class="mg mh iq ka b kb mt kf mu kj mv kn mw kr mx kv nl mm mn mo bi translated">在所有情况下执行的块，名义路径或异常</li><li id="2a4f" class="mg mh iq ka b kb mt kf mu kj mv kn mw kr mx kv nl mm mn mo bi translated">如果有结果，则获取结果，或者返回供应商执行的结果</li></ol><h1 id="d558" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">要么容器</h1><p id="83eb" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">虽然上面的片段可能会吸引你的FP端，但我们的编程端可能不会高兴。我们必须给异常分配唯一的返回值。我们要知道<code class="fe mp mq mr ms b">1</code>、<code class="fe mp mq mr ms b">2</code>、<code class="fe mp mq mr ms b">3</code>的意思。</p><p id="f3c0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最好有一个专门的结构来存储常规结果或异常。这是<code class="fe mp mq mr ms b">Either&lt;L,R&gt;</code>型的目标。</p><figure class="my mz na nb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nm"><img src="../Images/5fcc76ea700ed671f896c90e1e4d53a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*aoKyw_AiU4AnOiuu.png"/></div></div></figure><p id="6069" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">按照惯例，左边代表失败，右边代表成功。我们可以将上面的代码片段改写为:</p><pre class="my mz na nb gt nc ms nd ne aw nf bi"><span id="26d1" class="ng kx iq ms b gy nh ni l nj nk">Try.of(() -&gt; getFoo())<br/>   .mapTry(foo -&gt; sliceTheBar(foo))<br/>   .andThenTry(bar -&gt; checkBarSlice(bar))<br/>   .andFinally(() -&gt; {})<br/>   .toEither()                             // 1</span></pre><ol class=""><li id="050e" class="mg mh iq ka b kb kc kf kg kj mi kn mj kr mk kv nl mm mn mo bi translated">握住一个<code class="fe mp mq mr ms b">Throwable</code> <em class="mc">或</em>一个<code class="fe mp mq mr ms b">Integer</code></li></ol><p id="1f6d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如我上面提到的，<code class="fe mp mq mr ms b">Try</code>是从异常抛出设计到FP方法的优秀桥梁。随着时间的推移，您可能会改进设计，将<code class="fe mp mq mr ms b">Either</code>合并到方法签名中。以下是他们的对比:</p><figure class="my mz na nb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi no"><img src="../Images/27745930e04b2a26821fbebe23b55839.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TbQDGq_5n5kiuHjsQ3q7Uw.png"/></div></div></figure><p id="9172" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">用户代码现在简单多了:</p><pre class="my mz na nb gt nc ms nd ne aw nf bi"><span id="9795" class="ng kx iq ms b gy nh ni l nj nk">var result = getFoo()<br/>    .flatMap(foo -&gt; sliceTheBar(foo))<br/>    .flatMap(bar -&gt; checkBarSlice(bar));</span></pre><p id="25a5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意前面的<code class="fe mp mq mr ms b">andFinally()</code>块不需要特殊处理。</p><h1 id="95e8" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">要么服用类固醇</h1><p id="7e1f" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">Java通过库提供了<code class="fe mp mq mr ms b">Either</code>，其他语言也是如此。然而，他们中的一些人将它集成到了他们的标准库中:</p><ul class=""><li id="e00d" class="mg mh iq ka b kb kc kf kg kj mi kn mj kr mk kv ml mm mn mo bi translated">科特林提供了<a class="ae nn" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-result/" rel="noopener ugc nofollow" target="_blank">结果</a>。与常规的<code class="fe mp mq mr ms b">Either</code>相比，它强制左边是一个例外，它不是模板化的，<em class="mc">即</em>，类型是<code class="fe mp mq mr ms b">Exception</code></li><li id="7b06" class="mg mh iq ka b kb mt kf mu kj mv kn mw kr mx kv ml mm mn mo bi translated">Scala提供了一个常规的<a class="ae nn" href="https://www.scala-lang.org/api/2.13.7/scala/util/Either.html" rel="noopener ugc nofollow" target="_blank">或者</a></li></ul><p id="7780" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，在这两种情况下，它“仅仅”是一种类型。铁锈把<code class="fe mp mq mr ms b">Either</code>带到了另一个层面；它也称之为<a class="ae nn" href="https://doc.rust-lang.org/std/result/enum.Result.html" rel="noopener ugc nofollow" target="_blank">结果</a>。Rust的<code class="fe mp mq mr ms b">Result</code>已经融入了该语言的语法。</p><p id="c6f7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面是Rust编程语言在线书籍中的一个示例函数:</p><pre class="my mz na nb gt nc ms nd ne aw nf bi"><span id="e42e" class="ng kx iq ms b gy nh ni l nj nk">fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {<br/>    let f = File::open("hello.txt");                       // 1<br/>    let mut f = match f {                                  // 2<br/>        Ok(file) =&gt; file,                                    // 3<br/>        Err(e) =&gt; return Err(e),                           // 4<br/>    };<br/>    let mut s = String::new();<br/>    match f.read_to_string(&amp;mut s) {                       // 2 // 5<br/>        Ok(_) =&gt; Ok(s),                                    // 3<br/>        Err(e) =&gt; Err(e),                                  // 4<br/>    }<br/>}</span></pre><ol class=""><li id="49d4" class="mg mh iq ka b kb kc kf kg kj mi kn mj kr mk kv nl mm mn mo bi translated">阅读文件。<code class="fe mp mq mr ms b">File::open</code>返回一个<code class="fe mp mq mr ms b">Result</code>，因为它可能会失败。</li><li id="9bdf" class="mg mh iq ka b kb mt kf mu kj mv kn mw kr mx kv nl mm mn mo bi translated">评估<code class="fe mp mq mr ms b">Result</code></li><li id="9b36" class="mg mh iq ka b kb mt kf mu kj mv kn mw kr mx kv nl mm mn mo bi translated">如果<code class="fe mp mq mr ms b">Result</code>是<code class="fe mp mq mr ms b">Ok</code>，那么继续处理它的内容</li><li id="dfff" class="mg mh iq ka b kb mt kf mu kj mv kn mw kr mx kv nl mm mn mo bi translated">如果不是，返回一个新的错误<code class="fe mp mq mr ms b">Result</code>包装原来的错误</li><li id="4164" class="mg mh iq ka b kb mt kf mu kj mv kn mw kr mx kv nl mm mn mo bi translated">在Rust中，如果函数的最后一行是一个表达式(没有分号)，可以隐式返回</li></ol><p id="c884" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Rust引入了传播错误的捷径<code class="fe mp mq mr ms b">?</code>。<code class="fe mp mq mr ms b">?</code>含义如下:</p><ul class=""><li id="fd51" class="mg mh iq ka b kb kc kf kg kj mi kn mj kr mk kv ml mm mn mo bi translated">如果<code class="fe mp mq mr ms b">Result</code>包含<code class="fe mp mq mr ms b">Err</code>，立即返回</li><li id="e796" class="mg mh iq ka b kb mt kf mu kj mv kn mw kr mx kv ml mm mn mo bi translated">如果它包含<code class="fe mp mq mr ms b">Ok</code>，解开它的值并继续</li></ul><p id="3eb1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有了它，我们可以将上面的代码片段重写为:</p><pre class="my mz na nb gt nc ms nd ne aw nf bi"><span id="abd6" class="ng kx iq ms b gy nh ni l nj nk">fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {<br/>    let mut s = String::new();<br/>    File::open("hello.txt")?                                 // 1<br/>         .read_to_string(&amp;mut s)?;                           // 1<br/>    Ok(s)                                                    // 2<br/>}</span></pre><ol class=""><li id="f0e9" class="mg mh iq ka b kb kc kf kg kj mi kn mj kr mk kv nl mm mn mo bi translated">如果<code class="fe mp mq mr ms b">Ok</code>，展开该值，否则返回<code class="fe mp mq mr ms b">Err</code></li><li id="26ff" class="mg mh iq ka b kb mt kf mu kj mv kn mw kr mx kv nl mm mn mo bi translated">返回<code class="fe mp mq mr ms b">Result</code></li></ol><h1 id="0570" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">奇怪的围棋案例</h1><p id="a181" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">纵观历史，编程语言已经提供了越来越强大的结构来处理错误:从简单的返回值到通过异常的<code class="fe mp mq mr ms b">Either</code>。它把我们带到了Go编程语言。相对来说，它是最近才出现的，它迫使开发人员通过...多个返回值:</p><pre class="my mz na nb gt nc ms nd ne aw nf bi"><span id="1c93" class="ng kx iq ms b gy nh ni l nj nk">varFoo, err := GetFoo()                   // 1<br/>if err != nil {                           // 2<br/>    return err<br/>}<br/>sliceBar, err := SliceTheBar(varFoo)      // 1<br/>if err != nil {                           // 2<br/>    return err<br/>}<br/>err := CheckBarSlice(sliceBar)            // 1<br/>if err != nil {                           // 2<br/>    return err<br/>}</span></pre><ol class=""><li id="d7eb" class="mg mh iq ka b kb kc kf kg kj mi kn mj kr mk kv nl mm mn mo bi translated">返回错误引用</li><li id="836d" class="mg mh iq ka b kb mt kf mu kj mv kn mw kr mx kv nl mm mn mo bi translated">检查引用是否指向错误</li></ol><p id="20f9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">开发人员必须检查每一个潜在的错误，在名义路径中用错误处理代码来混淆代码。我不知道为什么围棋设计师会选择这样的方法。</p><h1 id="3e16" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">结论</h1><p id="4867" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">我不是函数式编程的专家，也不是铁杆粉丝。我只是承认它的好处。例如，您可以围绕不变性来设计您的面向对象模型。</p><p id="3115" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">作为一名JVM开发人员，我从职业生涯开始就一直在使用异常。然而，对于错误处理来说，<code class="fe mp mq mr ms b">Either</code>方法更胜一筹。使用正确的语法，比如Rust的<code class="fe mp mq mr ms b">?</code>操作符，您可以用它来编写既简洁又可读的代码。</p><p id="87f8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">更进一步:</strong></p><ul class=""><li id="4f1b" class="mg mh iq ka b kb kc kf kg kj mi kn mj kr mk kv ml mm mn mo bi translated"><a class="ae nn" href="https://docs.python.org/3/tutorial/errors.html" rel="noopener ugc nofollow" target="_blank"> Python的错误和异常</a></li><li id="b508" class="mg mh iq ka b kb mt kf mu kj mv kn mw kr mx kv ml mm mn mo bi translated"><a class="ae nn" href="https://docs.vavr.io/" rel="noopener ugc nofollow" target="_blank"> Vavr，Java的持久数据类型和功能控制结构</a></li><li id="65e8" class="mg mh iq ka b kb mt kf mu kj mv kn mw kr mx kv ml mm mn mo bi translated"><a class="ae nn" href="https://www.baeldung.com/vavr-try" rel="noopener ugc nofollow" target="_blank">Vavr试用指南</a></li><li id="964a" class="mg mh iq ka b kb mt kf mu kj mv kn mw kr mx kv ml mm mn mo bi translated"><a class="ae nn" href="https://go.dev/doc/tutorial/handle-errors" rel="noopener ugc nofollow" target="_blank">“Go:返回并处理错误”</a></li><li id="eb6e" class="mg mh iq ka b kb mt kf mu kj mv kn mw kr mx kv ml mm mn mo bi translated"><a class="ae nn" href="https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html" rel="noopener ugc nofollow" target="_blank">“Rust:带结果的可恢复错误”</a></li></ul></div><div class="ab cl np nq hu nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="ij ik il im in"><p id="6d8e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="mc">原载于</em> <a class="ae nn" href="https://blog.frankel.ch/error-handling/" rel="noopener ugc nofollow" target="_blank"> <em class="mc">一个Java怪胎</em></a><em class="mc">2022年3月20日</em></p></div></div>    
</body>
</html>