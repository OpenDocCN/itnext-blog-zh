<html>
<head>
<title>JavaScript’s Optional Chaining Proposal</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript的可选链接建议</h1>
<blockquote>原文：<a href="https://itnext.io/javascripts-optional-chaining-proposal-bc9e6e5f2877?source=collection_archive---------0-----------------------#2020-02-16">https://itnext.io/javascripts-optional-chaining-proposal-bc9e6e5f2877?source=collection_archive---------0-----------------------#2020-02-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><h1 id="6f8c" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">吻别那些让你止步不前的未定义的错误</h1><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/866541b3076c13f6a9ff24e35b2fd1cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XfCmNfv7rrc8m2XRaFrnyQ.jpeg"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated"><a class="ae lb" href="https://unsplash.com/@schmidy?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">奥斯汀·施密德</a>在<a class="ae lb" href="https://unsplash.com/s/photos/happy-jumping?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><h1 id="c037" class="jn jo iq bd jp jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk bi translated">介绍</h1><p id="6a0d" class="pw-post-body-paragraph lo lp iq lq b lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml ij bi translated">如果您是一名JavaScript开发人员，那么当我建立这个场景时，您就会理解我所描述的烦恼。</p><p id="5e08" class="pw-post-body-paragraph lo lp iq lq b lr mm lt lu lv mn lx ly lz mo mb mc md mp mf mg mh mq mj mk ml ij bi translated">想象一下:你正在编写代码，构建一些很酷的东西，获取数据和操作对象，突然你看到了错误，可怕的<code class="fe mr ms mt mu b">undefined</code>错误。您的应用程序会崩溃。很难。😑</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mv"><img src="../Images/690e6bad401ca70707466669c106118a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XWtSBgyqS-BiPtMhPAcUSA.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">每个JavaScript开发人员都遇到过的“未定义”错误。</figcaption></figure><p id="8b5f" class="pw-post-body-paragraph lo lp iq lq b lr mm lt lu lv mn lx ly lz mo mb mc md mp mf mg mh mq mj mk ml ij bi translated">你叹气，翻白眼🙄，并在您的<code class="fe mr ms mt mu b">if / else</code>语句中添加<em class="mw">另一个</em>检查，以防止将来出现类似的未定义错误(在这种情况下，它确保<code class="fe mr ms mt mu b">genres</code>数组的长度大于0)。</p><pre class="km kn ko kp gt mx mu my mz aw na bi"><span id="9069" class="nb jo iq mu b gy nc nd l ne nf">if (!loading &amp;&amp; !error &amp;&amp; <em class="mw">genres.</em>length) {<br/>  // do something here<br/>} else { <br/>  // handle if something evaluates to not true in the if statement<br/>}<br/>// program continues on its merry way</span></pre><p id="d5ae" class="pw-post-body-paragraph lo lp iq lq b lr mm lt lu lv mn lx ly lz mo mb mc md mp mf mg mh mq mj mk ml ij bi translated">但是如果有更好的方法呢？</p><p id="e741" class="pw-post-body-paragraph lo lp iq lq b lr mm lt lu lv mn lx ly lz mo mb mc md mp mf mg mh mq mj mk ml ij bi translated">如果在最终得到你想要的数据、好东西、有趣的东西之前，不检查几个对象或对象属性是否存在，而是你可以移动到那个部分<em class="mw">，即使</em>事物确实评估为<code class="fe mr ms mt mu b">null</code>或<code class="fe mr ms mt mu b">undefined</code>？如果你的代码没有在遇到一个未定义的值时就抛出，而不是像预期的那样？</p><p id="f8bc" class="pw-post-body-paragraph lo lp iq lq b lr mm lt lu lv mn lx ly lz mo mb mc md mp mf mg mh mq mj mk ml ij bi translated">听起来像梦里的东西？好得难以置信？不再是了。</p><p id="0d3d" class="pw-post-body-paragraph lo lp iq lq b lr mm lt lu lv mn lx ly lz mo mb mc md mp mf mg mh mq mj mk ml ij bi translated">因为JavaScript想做到这一点。</p><p id="9fe1" class="pw-post-body-paragraph lo lp iq lq b lr mm lt lu lv mn lx ly lz mo mb mc md mp mf mg mh mq mj mk ml ij bi translated">这就是我今天想谈论的:可选的链接操作符<code class="fe mr ms mt mu b">?.</code>提议，它让我们读取位于一个连接对象链<em class="mw">深处的属性的值，而</em>不必明确验证链中的每个引用是否有效。</p></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><h1 id="60d9" class="jn jo iq bd jp jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk bi translated">可选链接运算符</h1><p id="9851" class="pw-post-body-paragraph lo lp iq lq b lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml ij bi translated">正如我在介绍中提到的，<a class="ae lb" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining" rel="noopener ugc nofollow" target="_blank"> <strong class="lq ir">可选链接操作符</strong> </a>是一个提议，目前在<a class="ae lb" href="https://tc39.es/process-document/" rel="noopener ugc nofollow" target="_blank">阶段4 </a>中，如果引用评估为<code class="fe mr ms mt mu b">null</code>或<code class="fe mr ms mt mu b">undefined</code>并返回一个值<code class="fe mr ms mt mu b">undefined</code>，而不是抛出一个程序无法继续的错误，则允许某种短路。</p><p id="f4d1" class="pw-post-body-paragraph lo lp iq lq b lr mm lt lu lv mn lx ly lz mo mb mc md mp mf mg mh mq mj mk ml ij bi translated">当访问链接属性时，当引用可能丢失时，这归结为更短和更简单的表达式。当不能保证需要哪些属性时，在探索对象的内容时，它也非常有用。</p><h2 id="873d" class="nb jo iq bd jp ng nh dn jt ni nj dp jx lz nk nl kb md nm nn kf mh no np kj nq bi translated">可选链接运算符(？。)</h2><p id="0b45" class="pw-post-body-paragraph lo lp iq lq b lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml ij bi translated">我知道这听起来有点复杂，但在代码中看到它应该会更清楚。</p><p id="a4dc" class="pw-post-body-paragraph lo lp iq lq b lr mm lt lu lv mn lx ly lz mo mb mc md mp mf mg mh mq mj mk ml ij bi translated"><strong class="lq ir">与对象属性的可选链接</strong></p><p id="582b" class="pw-post-body-paragraph lo lp iq lq b lr mm lt lu lv mn lx ly lz mo mb mc md mp mf mg mh mq mj mk ml ij bi translated">以下是访问对象属性时可选链接的示例:</p><pre class="km kn ko kp gt mx mu my mz aw na bi"><span id="e645" class="nb jo iq mu b gy nc nd l ne nf">const simpleObj = {<br/>  levelOne: {<br/>    levelTwo: 'hello world'<br/>  }<br/>};</span><span id="c866" class="nb jo iq mu b gy nr nd l ne nf">let nestedProp = simpleObj.levelOne?.levelThree;</span><span id="967a" class="nb jo iq mu b gy nr nd l ne nf">console.log('There is a not a levelThree prop, it is ', nestedProp); // prints: "There is a not a levelThree prop, it is  undefined"</span><span id="3f41" class="nb jo iq mu b gy nr nd l ne nf">console.log('But the program still goes on.'); // prints: "But the program still goes on."</span></pre><p id="9c64" class="pw-post-body-paragraph lo lp iq lq b lr mm lt lu lv mn lx ly lz mo mb mc md mp mf mg mh mq mj mk ml ij bi translated">链接操作符实际上只由<code class="fe mr ms mt mu b">?.</code>组成。如果<code class="fe mr ms mt mu b">?.</code>运算符左侧的操作数计算结果为<code class="fe mr ms mt mu b">undefined</code>或<code class="fe mr ms mt mu b">null</code>，则表达式计算结果为<code class="fe mr ms mt mu b">undefined</code>。否则，正常触发目标属性访问、方法或函数调用。</p><p id="14b3" class="pw-post-body-paragraph lo lp iq lq b lr mm lt lu lv mn lx ly lz mo mb mc md mp mf mg mh mq mj mk ml ij bi translated">您可以将它添加到:</p><ul class=""><li id="864d" class="ns nt iq lq b lr mm lv mn lz nu md nv mh nw ml nx ny nz oa bi translated">一个对象，<code class="fe mr ms mt mu b">a?.b</code></li><li id="04e6" class="ns nt iq lq b lr ob lv oc lz od md oe mh of ml nx ny nz oa bi translated">一个对象表达式，<code class="fe mr ms mt mu b">a?.[x]</code></li><li id="5e13" class="ns nt iq lq b lr ob lv oc lz od md oe mh of ml nx ny nz oa bi translated">一个数组，<code class="fe mr ms mt mu b">a?.[index]</code> or</li><li id="d2f2" class="ns nt iq lq b lr ob lv oc lz od md oe mh of ml nx ny nz oa bi translated">函数的参数<code class="fe mr ms mt mu b"> a?.b()</code>。</li></ul><p id="5abd" class="pw-post-body-paragraph lo lp iq lq b lr mm lt lu lv mn lx ly lz mo mb mc md mp mf mg mh mq mj mk ml ij bi translated">当引用或函数可能是<code class="fe mr ms mt mu b">undefined</code>或<code class="fe mr ms mt mu b">null</code>时，它可以简化通过连接的对象访问值。</p><h2 id="ac8d" class="nb jo iq bd jp ng nh dn jt ni nj dp jx lz nk nl kb md nm nn kf mh no np kj nq bi translated">在可选的链接之前，一切都必须被验证</h2><p id="4c38" class="pw-post-body-paragraph lo lp iq lq b lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml ij bi translated">想想你有多经常处理属性嵌套超过一层的对象，并且你必须每隔验证<em class="mw">。<em class="mw">单个</em>。<em class="mw">一个。</em></em></p><p id="dd6e" class="pw-post-body-paragraph lo lp iq lq b lr mm lt lu lv mn lx ly lz mo mb mc md mp mf mg mh mq mj mk ml ij bi translated">如果没有可选的链接，查找深度嵌套的子属性意味着验证两者之间的引用，如下所示:</p><pre class="km kn ko kp gt mx mu my mz aw na bi"><span id="48cb" class="nb jo iq mu b gy nc nd l ne nf">let newSubProperty = obj.prop &amp;&amp; obj.prop.subProp;</span></pre><p id="9ec5" class="pw-post-body-paragraph lo lp iq lq b lr mm lt lu lv mn lx ly lz mo mb mc md mp mf mg mh mq mj mk ml ij bi translated">检查<code class="fe mr ms mt mu b">obj.prop</code>的值为非空且不是<code class="fe mr ms mt mu b">undefined</code>，然后访问<code class="fe mr ms mt mu b">obj.prop.subProp</code>的值。这防止了在没有首先检查<code class="fe mr ms mt mu b">obj.prop</code>的值是否存在的情况下试图访问<code class="fe mr ms mt mu b">obj.prop.subProp</code>所发生的错误。</p><p id="797d" class="pw-post-body-paragraph lo lp iq lq b lr mm lt lu lv mn lx ly lz mo mb mc md mp mf mg mh mq mj mk ml ij bi translated">我不知道你怎么想，但对我来说，这就像很多额外的、多余的代码。</p><p id="3daa" class="pw-post-body-paragraph lo lp iq lq b lr mm lt lu lv mn lx ly lz mo mb mc md mp mf mg mh mq mj mk ml ij bi translated">然而，使用可选的链接操作符(<code class="fe mr ms mt mu b">?.</code>)，您不必在尝试访问<code class="fe mr ms mt mu b">obj.prop.subProp</code>之前根据<code class="fe mr ms mt mu b">obj.prop</code>的状态进行显式测试和短路:</p><pre class="km kn ko kp gt mx mu my mz aw na bi"><span id="8ae7" class="nb jo iq mu b gy nc nd l ne nf">let newSubProperty = obj.prop?.subProp;</span></pre><p id="ee6f" class="pw-post-body-paragraph lo lp iq lq b lr mm lt lu lv mn lx ly lz mo mb mc md mp mf mg mh mq mj mk ml ij bi translated">通过使用<code class="fe mr ms mt mu b">?.</code>操作符，JavaScript知道在试图访问嵌套的<code class="fe mr ms mt mu b">subProp</code>之前隐式检查<code class="fe mr ms mt mu b">obj.prop</code>不是<code class="fe mr ms mt mu b">null</code>或<code class="fe mr ms mt mu b">undefined</code>值。如果<code class="fe mr ms mt mu b">obj.prop</code><em class="mw"/>最终评估为<code class="fe mr ms mt mu b">null</code>或<code class="fe mr ms mt mu b">undefined</code>，表达式短路并返回一个<code class="fe mr ms mt mu b">undefined</code>值，程序继续运行。</p><p id="a626" class="pw-post-body-paragraph lo lp iq lq b lr mm lt lu lv mn lx ly lz mo mb mc md mp mf mg mh mq mj mk ml ij bi translated">让我们看看更多可选链接操作符的例子。</p><p id="a4d1" class="pw-post-body-paragraph lo lp iq lq b lr mm lt lu lv mn lx ly lz mo mb mc md mp mf mg mh mq mj mk ml ij bi translated"><strong class="lq ir">与函数调用的可选链接</strong></p><p id="89a4" class="pw-post-body-paragraph lo lp iq lq b lr mm lt lu lv mn lx ly lz mo mb mc md mp mf mg mh mq mj mk ml ij bi translated">当试图调用可能不存在的方法时，可以使用可选的链接。当使用的API中某个方法可能不可用时，这可能会很有帮助，这可能是因为实现的时间太长，或者是因为某个功能在用户设备上不可用。</p><pre class="km kn ko kp gt mx mu my mz aw na bi"><span id="c52b" class="nb jo iq mu b gy nc nd l ne nf">let response = someInterface.customFunction?.();</span></pre><p id="3795" class="pw-post-body-paragraph lo lp iq lq b lr mm lt lu lv mn lx ly lz mo mb mc md mp mf mg mh mq mj mk ml ij bi translated">通过对函数调用使用可选的链接，如果没有找到方法，表达式将自动返回<code class="fe mr ms mt mu b">undefined</code>而不是抛出异常。</p><p id="d56e" class="pw-post-body-paragraph lo lp iq lq b lr mm lt lu lv mn lx ly lz mo mb mc md mp mf mg mh mq mj mk ml ij bi translated">当对表达式使用可选链接时，如果左操作数是<code class="fe mr ms mt mu b">null</code>或<code class="fe mr ms mt mu b">undefined</code>，表达式就不会被求值。</p><pre class="km kn ko kp gt mx mu my mz aw na bi"><span id="732c" class="nb jo iq mu b gy nc nd l ne nf">let possibleNull = null;<br/>let value = 0;<br/>let result = possible?.[value++];</span><span id="a6fe" class="nb jo iq mu b gy nr nd l ne nf">console.log(value); // 0 as value was not incremented</span></pre><p id="8170" class="pw-post-body-paragraph lo lp iq lq b lr mm lt lu lv mn lx ly lz mo mb mc md mp mf mg mh mq mj mk ml ij bi translated">即使变量<code class="fe mr ms mt mu b">possibleNull</code>确实是<code class="fe mr ms mt mu b">null</code>，变量<code class="fe mr ms mt mu b">result</code>也没有抛出错误，因为可选的链接操作符已经生效。它只是跳过了函数，继续前进。有用不？</p><p id="46c7" class="pw-post-body-paragraph lo lp iq lq b lr mm lt lu lv mn lx ly lz mo mb mc md mp mf mg mh mq mj mk ml ij bi translated"><strong class="lq ir">与对象表达式的可选链接</strong></p><p id="d806" class="pw-post-body-paragraph lo lp iq lq b lr mm lt lu lv mn lx ly lz mo mb mc md mp mf mg mh mq mj mk ml ij bi translated">当使用属性访问器的括号标记通过表达式访问属性时，也可以使用可选的链接运算符。看看这个。</p><pre class="km kn ko kp gt mx mu my mz aw na bi"><span id="48db" class="nb jo iq mu b gy nc nd l ne nf">let nestedProp = myObj?.['prop' + 'Name'];</span></pre><p id="d837" class="pw-post-body-paragraph lo lp iq lq b lr mm lt lu lv mn lx ly lz mo mb mc md mp mf mg mh mq mj mk ml ij bi translated">我不知道为什么你更喜欢用括号符号而不是点符号，而是你自己的。如果你需要它，它就在那里。</p><p id="1c6e" class="pw-post-body-paragraph lo lp iq lq b lr mm lt lu lv mn lx ly lz mo mb mc md mp mf mg mh mq mj mk ml ij bi translated"><strong class="lq ir">使用可选链接访问数组项目</strong></p><p id="ad0b" class="pw-post-body-paragraph lo lp iq lq b lr mm lt lu lv mn lx ly lz mo mb mc md mp mf mg mh mq mj mk ml ij bi translated">具有可选链接的数组很有意思，通过使用可选链接语法，可以尝试通过传递的索引来访问数组中的项，如果数组中不存在该索引，也不会出错。</p><pre class="km kn ko kp gt mx mu my mz aw na bi"><span id="aada" class="nb jo iq mu b gy nc nd l ne nf">let arr = [1,2,3]</span><span id="9cd4" class="nb jo iq mu b gy nr nd l ne nf">let arrayItem = arr?.[3];</span><span id="7b4c" class="nb jo iq mu b gy nr nd l ne nf">console.log(arrayItem) // prints: undefined</span></pre><p id="5c7d" class="pw-post-body-paragraph lo lp iq lq b lr mm lt lu lv mn lx ly lz mo mb mc md mp mf mg mh mq mj mk ml ij bi translated"><strong class="lq ir">堆叠可选链</strong></p><p id="3c90" class="pw-post-body-paragraph lo lp iq lq b lr mm lt lu lv mn lx ly lz mo mb mc md mp mf mg mh mq mj mk ml ij bi translated">另一件值得注意的事情是，您可以在同一个嵌套对象中多次使用可选链接。</p><pre class="km kn ko kp gt mx mu my mz aw na bi"><span id="4a97" class="nb jo iq mu b gy nc nd l ne nf">let customer = {<br/>  name: "Sean",<br/>   details: {<br/>    age: 43,<br/>    location: "Trinidad" // detailed address and subscription service frequency is unknown<br/>  }<br/>};</span><span id="33ca" class="nb jo iq mu b gy nr nd l ne nf">let customerSubscription = customer.details?.subscription?.frequency;<br/>console.log(customerSubscription); // prints: undefined</span><span id="0738" class="nb jo iq mu b gy nr nd l ne nf">let customerCity = customer.details?.address?.city;<br/>console.log(customerCity); // prints: undefined</span></pre><p id="2b85" class="pw-post-body-paragraph lo lp iq lq b lr mm lt lu lv mn lx ly lz mo mb mc md mp mf mg mh mq mj mk ml ij bi translated">在两个变量<code class="fe mr ms mt mu b">customerSubscription</code>和<code class="fe mr ms mt mu b">customerCity</code>中，值最终都是<code class="fe mr ms mt mu b">undefined</code>，因为它们都没有在<code class="fe mr ms mt mu b">customer</code>对象上定义。但是同样，如果是这种情况，也不会抛出错误。</p><p id="d313" class="pw-post-body-paragraph lo lp iq lq b lr mm lt lu lv mn lx ly lz mo mb mc md mp mf mg mh mq mj mk ml ij bi translated">您也可以对函数做同样的事情:在函数调用中使用多个可选的链接操作符。像这样:</p><pre class="km kn ko kp gt mx mu my mz aw na bi"><span id="0a8e" class="nb jo iq mu b gy nc nd l ne nf">let duration = vacations.trip?.getTime?.();</span></pre><p id="ab19" class="pw-post-body-paragraph lo lp iq lq b lr mm lt lu lv mn lx ly lz mo mb mc md mp mf mg mh mq mj mk ml ij bi translated"><strong class="lq ir">与无效合并运算符组合</strong></p><p id="b30c" class="pw-post-body-paragraph lo lp iq lq b lr mm lt lu lv mn lx ly lz mo mb mc md mp mf mg mh mq mj mk ml ij bi translated">这本身就很有用，但是当可选链接与<a class="ae lb" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Nullish_coalescing_operator" rel="noopener ugc nofollow" target="_blank"> <strong class="lq ir"> nullish合并操作符</strong> </a>结合使用时，真正的威力才显现出来。</p><p id="4dc6" class="pw-post-body-paragraph lo lp iq lq b lr mm lt lu lv mn lx ly lz mo mb mc md mp mf mg mh mq mj mk ml ij bi translated">我不会详细介绍这个特性(也在第4阶段的建议中)，但简单地说，nullish合并操作符，写为<code class="fe mr ms mt mu b">??</code>是一个逻辑操作符，当它的左侧操作数是<code class="fe mr ms mt mu b">null</code>或<code class="fe mr ms mt mu b">undefined</code>时，它返回右侧操作数，否则返回左侧操作数。</p><p id="2266" class="pw-post-body-paragraph lo lp iq lq b lr mm lt lu lv mn lx ly lz mo mb mc md mp mf mg mh mq mj mk ml ij bi translated">下面是当没有找到默认值时，这两个建议如何一起构建默认值。</p><pre class="km kn ko kp gt mx mu my mz aw na bi"><span id="0359" class="nb jo iq mu b gy nc nd l ne nf">let customer2 = {<br/>  name: "Paige",<br/>  details: { <br/>    age: 30 // once again a city is not provided on this object<br/>  }<br/>};</span><span id="78c0" class="nb jo iq mu b gy nr nd l ne nf">const customerCity2 = customer2?.city ?? "City not provided";<br/>console.log(customerCity2); // prints: "City not provided"</span></pre><p id="325c" class="pw-post-body-paragraph lo lp iq lq b lr mm lt lu lv mn lx ly lz mo mb mc md mp mf mg mh mq mj mk ml ij bi translated">由于没有提供<code class="fe mr ms mt mu b">city</code>属性，并且由于可选的链接操作符的缘故，该属性的计算结果为<code class="fe mr ms mt mu b">undefined</code>，因此nullish合并操作符开始生效并默认为右侧操作数<code class="fe mr ms mt mu b">"City not provided"</code>，因为左侧操作数的计算结果为<code class="fe mr ms mt mu b">undefined</code>。</p><p id="2d50" class="pw-post-body-paragraph lo lp iq lq b lr mm lt lu lv mn lx ly lz mo mb mc md mp mf mg mh mq mj mk ml ij bi translated">试想，如果缺省了一个值，您可以创建自己的缺省值，避免花费大量时间调试由坏数据引起的奇怪错误。多棒啊。依我拙见相当牛逼！😀</p></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><h1 id="6726" class="jn jo iq bd jp jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk bi translated">结论</h1><p id="137e" class="pw-post-body-paragraph lo lp iq lq b lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml ij bi translated">可选的链接操作符旨在通过消除当对象值或函数不存在时会破坏应用程序的错误，使我们作为web开发人员的生活和作为程序员的工作更加简单。</p><p id="8fb8" class="pw-post-body-paragraph lo lp iq lq b lr mm lt lu lv mn lx ly lz mo mb mc md mp mf mg mh mq mj mk ml ij bi translated">由于在撰写本文时该提案仍处于第4阶段，因此它还没有得到所有浏览器的完全支持，也没有被标准化为JavaScript语言。Chrome、Firefox和Opera支持该功能，Edge、Safari和Internet Explorer不支持。</p><p id="fcb0" class="pw-post-body-paragraph lo lp iq lq b lr mm lt lu lv mn lx ly lz mo mb mc md mp mf mg mh mq mj mk ml ij bi translated">但是因为它已经到了第4阶段，所以它被添加到标准ECMAScript语法中并得到所有主流浏览器的支持只是时间问题。您可以关注<a class="ae lb" href="https://github.com/tc39/proposal-optional-chaining" rel="noopener ugc nofollow" target="_blank"> Github </a>或<a class="ae lb" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining" rel="noopener ugc nofollow" target="_blank"> MDN文档</a>中的建议。</p><p id="bcc3" class="pw-post-body-paragraph lo lp iq lq b lr mm lt lu lv mn lx ly lz mo mb mc md mp mf mg mh mq mj mk ml ij bi translated">更干净，更清晰，更容易维护代码。这是JavaScript语言所有这些改进的最终结果，我很高兴看到可选的链接操作符很快成为主流开发。</p><p id="41cb" class="pw-post-body-paragraph lo lp iq lq b lr mm lt lu lv mn lx ly lz mo mb mc md mp mf mg mh mq mj mk ml ij bi translated">过几周再来看看，我会写更多关于JavaScript、React、ES6或其他与web开发相关的东西。跟着我，这样你就不会错过了！</p></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><p id="bb13" class="pw-post-body-paragraph lo lp iq lq b lr mm lt lu lv mn lx ly lz mo mb mc md mp mf mg mh mq mj mk ml ij bi translated">感谢您的阅读，我希望您能关注可选链接何时获得完全支持，我们可以开始简化代码的空检查和未定义检查，并将其投入生产。这将使web开发变得更加容易。</p><p id="1484" class="pw-post-body-paragraph lo lp iq lq b lr mm lt lu lv mn lx ly lz mo mb mc md mp mf mg mh mq mj mk ml ij bi translated">如果你喜欢读这篇文章，你可能也会喜欢我的其他作品:</p><ul class=""><li id="3a43" class="ns nt iq lq b lr mm lv mn lz nu md nv mh nw ml nx ny nz oa bi translated"><a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/using-es6-to-destructure-nested-objects-in-javascript-avoid-undefined-errors-that-break-your-code-612ae67913e9">使用ES6来析构JavaScript中深度嵌套的对象&amp;避免未定义的错误破坏你的代码</a></li><li id="da7c" class="ns nt iq lq b lr ob lv oc lz od md oe mh of ml nx ny nz oa bi translated"><a class="ae lb" href="https://medium.com/better-programming/how-to-pass-multiple-route-parameters-in-a-react-url-path-4b919de0abbe" rel="noopener">如何在React URL路径中传递多个路由参数</a></li><li id="87a2" class="ns nt iq lq b lr ob lv oc lz od md oe mh of ml nx ny nz oa bi translated"><a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/javascript-international-methods-b70a2de09d92"> JavaScript国际方法</a></li></ul></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><h1 id="98c5" class="jn jo iq bd jp jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk bi translated">参考资料和更多资源</h1><ul class=""><li id="51c1" class="ns nt iq lq b lr ls lv lw lz og md oh mh oi ml nx ny nz oa bi translated"><a class="ae lb" href="https://github.com/tc39/proposal-optional-chaining" rel="noopener ugc nofollow" target="_blank"> Github </a>上的可选链接建议代码。</li><li id="7c12" class="ns nt iq lq b lr ob lv oc lz od md oe mh of ml nx ny nz oa bi translated">关于<a class="ae lb" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining" rel="noopener ugc nofollow" target="_blank"> MDN文档</a>的可选链接说明文档。</li><li id="a100" class="ns nt iq lq b lr ob lv oc lz od md oe mh of ml nx ny nz oa bi translated">关于<a class="ae lb" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Nullish_coalescing_operator" rel="noopener ugc nofollow" target="_blank"> MDN文档</a>的Nullish合并运算符文档。</li></ul></div></div>    
</body>
</html>