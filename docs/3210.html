<html>
<head>
<title>Learn to Cache your NodeJS Application with Redis in 6 Minutes!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学会用Redis在6分钟内缓存你的NodeJS应用！</h1>
<blockquote>原文：<a href="https://itnext.io/learn-to-cache-your-nodejs-application-with-redis-in-6-minutes-745a574a9739?source=collection_archive---------0-----------------------#2019-10-26">https://itnext.io/learn-to-cache-your-nodejs-application-with-redis-in-6-minutes-745a574a9739?source=collection_archive---------0-----------------------#2019-10-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/54992682937316c964d7e6e7191c51f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4DX0Dj0zI2q4MnqeO_Bfbg.png"/></div></div></figure><p id="b4c6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">缓存您的web应用程序是非常必要的，并且可以在您扩展时获得高性能增益。无论是<strong class="kd iu">搜索引擎</strong>还是<strong class="kd iu"> URL缩短器</strong>或者是<strong class="kd iu">社交网络</strong>或者是一个从第三方web API请求数据的非常简单的web服务器，如果你想以最小的延迟响应频繁请求的查询，缓存数据将会非常有效！</p><h1 id="0077" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">Redis是什么？为什么使用Redis？</h1><p id="77ae" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated"><strong class="kd iu"> Redis </strong>是一个高性能开源<strong class="kd iu"> NoSQL </strong>数据库，主要用作各种类型应用程序的缓存解决方案。令人惊讶的是，它将所有数据存储在RAM中，并承诺高度优化数据读取和写入。Redis还支持许多不同的数据类型和基于不同编程语言的客户机。你可以在这里找到更多关于<strong class="kd iu">Redis</strong>T12】的信息。</p><h1 id="fca3" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">概观</h1><p id="2c51" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">今天，我们将在一个从<strong class="kd iu"> </strong> <a class="ae mc" href="https://swapi.co" rel="noopener ugc nofollow" target="_blank"> <strong class="kd iu">星球大战API </strong> </a>请求<strong class="kd iu">星球大战星际飞船</strong>信息的<strong class="kd iu"> NodeJS </strong> web应用<strong class="kd iu"> </strong>上实现一个基本的缓存机制<strong class="kd iu"> </strong>。我们将学习如何将频繁请求的星舰数据存储到我们的缓存中。来自我们web服务器的未来请求将首先搜索缓存，如果缓存不包含所请求的数据，则仅向<a class="ae mc" href="https://swapi.co" rel="noopener ugc nofollow" target="_blank"> <strong class="kd iu">星球大战API </strong> </a>发送请求。这将允许我们向第三方API发送更少的请求，并总体上加快我们的应用程序。为了确保我们的缓存是最新的，缓存的值将设置一个生存时间(TTL ),并在一段确定的时间后过期。听起来很刺激？我们开始吧！</p><h1 id="b7c7" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">Redis设置</h1><p id="e9db" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">如果您已经在本地机器上安装了Redis，或者如果您正在使用Redis云托管解决方案，请随意跳过这一步。</p><h2 id="f100" class="md la it bd lb me mf dn lf mg mh dp lj km mi mj ln kq mk ml lr ku mm mn lv mo bi translated">在Mac上安装</h2><p id="f65d" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">Redis可以使用<strong class="kd iu">自制软件</strong>安装在你的Mac上。如果您的Mac上没有安装Homebrew，您可以在终端上运行以下命令来安装它，</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="6e07" class="md la it mu b gy my mz l na nb">/usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"</span></pre><p id="0971" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，您可以通过在终端上运行以下命令来安装Redis，</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="8621" class="md la it mu b gy my mz l na nb">brew install redis</span></pre><h2 id="cd0c" class="md la it bd lb me mf dn lf mg mh dp lj km mi mj ln kq mk ml lr ku mm mn lv mo bi translated">在Ubuntu上安装</h2><p id="7eac" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">你可以使用这个简单的指南在你的Ubuntu机器上安装Redis。</p><h2 id="110d" class="md la it bd lb me mf dn lf mg mh dp lj km mi mj ln kq mk ml lr ku mm mn lv mo bi translated">在Windows上安装</h2><p id="5baa" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">你可以使用这个<a class="ae mc" href="https://redislabs.com/blog/redis-on-windows-8-1-and-previous-versions/" rel="noopener ugc nofollow" target="_blank">简单指南</a>在你的Windows机器上安装Redis。</p><h1 id="a6c1" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">启动Redis服务器和Redis CLI</h1><p id="4332" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">在您的终端上，您可以运行以下命令来本地启动Redis服务器，</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="1468" class="md la it mu b gy my mz l na nb">redis-server</span></pre><figure class="mp mq mr ms gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nc"><img src="../Images/d97f350a15c2fd59a0d291cdb78bdbc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X8YnTE55NZbp-V7ER4iKLw.png"/></div></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk translated">启动Redis服务器</figcaption></figure><p id="4f13" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">要访问Redis CLI，您可以在单独的终端窗口/选项卡上运行以下命令，</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="6ba2" class="md la it mu b gy my mz l na nb">redis-cli</span></pre><figure class="mp mq mr ms gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nh"><img src="../Images/70e5f4dd1128ca97efdb192a6c5a6ae1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lPYgPudVRWd1HoJA5khQsQ.png"/></div></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk translated">Redis CLI</figcaption></figure><p id="21c3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">就像本地安装在您机器上的任何其他数据库解决方案一样，您可以使用它的CLI与Redis进行交互。我推荐你在<a class="ae mc" href="https://redis.io/topics/rediscli" rel="noopener ugc nofollow" target="_blank"> Redis网站</a>上查看这个指南。然而，我们将只关注将Redis设置为NodeJS web应用程序的缓存解决方案，并且只通过我们的web服务器与它进行交互。</p><h1 id="27a1" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">NodeJS项目设置</h1><p id="ec2b" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">在一个单独的文件夹中，运行<strong class="kd iu"> npm init </strong>来设置NodeJS项目。</p><figure class="mp mq mr ms gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ni"><img src="../Images/216871c0578cf1e118ddfac3ae476a5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sVU5v2M6FEOMd9LtLaMoOQ.png"/></div></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk translated">使用<strong class="bd lb"> npm init </strong>设置NodeJS应用程序</figcaption></figure><h2 id="96e9" class="md la it bd lb me mf dn lf mg mh dp lj km mi mj ln kq mk ml lr ku mm mn lv mo bi translated">项目相关性</h2><p id="6444" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">我们将在NodeJS应用程序中使用一组依赖项。从您的our目录在终端中运行以下命令，</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="5f4b" class="md la it mu b gy my mz l na nb">npm i express redis axios</span></pre><p id="1f06" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"> Express </strong>将帮助我们设置服务器。我们将使用<strong class="kd iu"> redis </strong>包将我们的应用程序连接到在我们机器上本地运行的redis服务器，并且我们将使用<strong class="kd iu"> axios </strong>向<a class="ae mc" href="https://swapi.co" rel="noopener ugc nofollow" target="_blank"> <strong class="kd iu">星球大战API </strong> </a>请求获取数据。</p><h2 id="1004" class="md la it bd lb me mf dn lf mg mh dp lj km mi mj ln kq mk ml lr ku mm mn lv mo bi translated">开发依赖项</h2><p id="460d" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">我们还将使用<strong class="kd iu"> nodemon </strong>作为我们的<strong class="kd iu">开发依赖性</strong>来保存和运行我们对服务器的更改，而不必重启它。从我们的项目目录在终端中运行以下命令，</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="2566" class="md la it mu b gy my mz l na nb">npm i -D nodemon</span></pre><h2 id="0451" class="md la it bd lb me mf dn lf mg mh dp lj km mi mj ln kq mk ml lr ku mm mn lv mo bi translated">package.json中的安装启动脚本</h2><p id="69b9" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">用下面的脚本替换<strong class="kd iu"> package.json </strong>中的现有脚本，这样我们就可以用<strong class="kd iu"> nodemon </strong>运行我们的服务器，</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="d551" class="md la it mu b gy my mz l na nb">"start": "nodemon index"</span></pre><figure class="mp mq mr ms gt ju"><div class="bz fp l di"><div class="nj nk l"/></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk translated">package.json文件</figcaption></figure><h2 id="9e08" class="md la it bd lb me mf dn lf mg mh dp lj km mi mj ln kq mk ml lr ku mm mn lv mo bi translated">设置我们的初始服务器入口点:index.js</h2><p id="48d2" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">在终端中从我们的项目目录运行下面的命令来创建<strong class="kd iu"> index.js </strong>文件，</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="850e" class="md la it mu b gy my mz l na nb">touch index.js</span></pre><p id="8287" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下面是我们的<strong class="kd iu"> index.js </strong>文件添加一些代码后的样子，</p><figure class="mp mq mr ms gt ju"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="b59e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你以前使用过<strong class="kd iu"> NodeJS </strong>和<strong class="kd iu"> ExpressJS </strong>，这应该看起来很简单。首先，我们设置以前使用npm安装的依赖项。其次，我们设置我们的端口常量并创建我们的Redis客户机。此外，我们在<strong class="kd iu">端口6379 </strong>上配置我们的Redis客户端，在<strong class="kd iu">端口5000 </strong>上配置我们的Express服务器。我们还在服务器上设置了<strong class="kd iu"> Body-Parser </strong>来解析JSON数据。您可以在终端中运行以下命令，使用来自<strong class="kd iu"> package.json </strong>的启动脚本来运行web服务器，</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="f36a" class="md la it mu b gy my mz l na nb">npm start</span></pre><p id="cfdd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">注意</strong>如前所述，我们的Redis服务器应该运行在另一个终端上，以便成功地将我们的NodeJS应用程序连接到Redis。</p><p id="9b47" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，您应该能够在终端上看到以下输出，表明您的web服务器正在运行于<strong class="kd iu">端口5000 </strong>，</p><figure class="mp mq mr ms gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nl"><img src="../Images/1eda4266586d81f8bbd9743c74031576.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1W6F-j0EtdYKDrgJj4hjHg.png"/></div></div></figure><h1 id="48fd" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">设置服务器端点向Star Wars API发送请求</h1><p id="5cb0" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">现在我们有了项目设置，让我们写一些代码来设置一个端点，向<strong class="kd iu">星球大战API </strong>发送一个<strong class="kd iu"> GET </strong>请求来获取星际飞船数据。</p><p id="5dbb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">注意，我们将向https://swapi.co/api/starships/<strong class="kd iu">:id</strong>的<a class="ae mc" href="https://swapi.co/api/starships/${id}" rel="noopener ugc nofollow" target="_blank"> <strong class="kd iu">发出GET请求，以获取与我们的URL中的标识符<strong class="kd iu"> id </strong>相对应的星际飞船的数据。</strong></a></p><p id="0777" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下面是我们的端点看起来的样子，</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="a48c" class="md la it mu b gy my mz l na nb">// Endpoint:  GET /starships/:id</span><span id="0897" class="md la it mu b gy nm mz l na nb">// @desc Return Starships data for particular starship id</span><span id="e92c" class="md la it mu b gy nm mz l na nb">app.get("/starships/:id", async (<em class="nn">req</em>, <em class="nn">res</em>) <em class="nn">=&gt;</em> {</span><span id="bf98" class="md la it mu b gy nm mz l na nb">  try {</span><span id="c39a" class="md la it mu b gy nm mz l na nb"><em class="nn">       const</em> { id } = req.params;</span><span id="7c8e" class="md la it mu b gy nm mz l na nb"><em class="nn">       const</em> starShipInfo = await axios.get(</span><span id="a3ee" class="md la it mu b gy nm mz l na nb">       `https://swapi.co/api/starships/${id}`<br/>       );</span><span id="0d13" class="md la it mu b gy nm mz l na nb">       <br/>       //get data from response</span><span id="d311" class="md la it mu b gy nm mz l na nb"><em class="nn">       const</em> starShipInfoData = starShipInfo.data;<br/></span><span id="a0a1" class="md la it mu b gy nm mz l na nb">       return res.json(starShipInfoData);</span><span id="e0d0" class="md la it mu b gy nm mz l na nb">  } <br/>  catch (error) {<br/>       <br/>       <em class="nn">console</em>.log(error);</span><span id="c471" class="md la it mu b gy nm mz l na nb">       return res.status(500).json(error);</span><span id="75e9" class="md la it mu b gy nm mz l na nb">   }</span><span id="f59f" class="md la it mu b gy nm mz l na nb">});</span></pre><p id="2b8e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将使用带有try和catch块的传统<strong class="kd iu">异步</strong>回调函数，使用<strong class="kd iu"> axios </strong>向<strong class="kd iu">星球大战API </strong>发出GET请求。如果成功，我们的端点将返回与URL中的id对应的Starship的数据。否则，我们的端点将响应一个错误。简单。</p><figure class="mp mq mr ms gt ju"><div class="bz fp l di"><div class="nj nk l"/></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk translated">添加端点后的index.js</figcaption></figure><p id="9ccc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们通过搜索id=9的星际飞船来运行我们的端点。</p><figure class="mp mq mr ms gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi no"><img src="../Images/2e8fa66d946eb2bcd425c2e6f6416b30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8omThnreKe-2gQHS29U9Rw.png"/></div></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk translated">http://localhost:5000/starships/9</figcaption></figure><p id="054b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">哇哦。那行得通。但是你有没有注意到完成这个请求所花的时间？为了做到这一点，你可以检查浏览器中chrome开发者工具下的网络选项卡。</p><p id="c61b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"> 769女士</strong>那就是慢！这就是<strong class="kd iu"> Redis </strong>前来救援的地方。</p><h1 id="cea5" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">为我们的端点实现Redis缓存</h1><h2 id="b4bb" class="md la it bd lb me mf dn lf mg mh dp lj km mi mj ln kq mk ml lr ku mm mn lv mo bi translated">添加到缓存</h2><p id="4423" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">由于Redis将数据存储在键值对中，我们需要确保每当向Star Wars API发出请求并且我们收到成功的响应时，我们都将Starship id及其数据存储在缓存中。</p><p id="dfec" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了做到这一点，我们将在收到来自Star Wars API的响应后，向我们的端点添加以下代码行，</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="5f07" class="md la it mu b gy my mz l na nb">//add data to Redis</span><span id="07c6" class="md la it mu b gy nm mz l na nb">redis_client.setex(id, 3600, JSON.stringify(starShipInfoData));</span></pre><p id="4042" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">上面的命令允许我们将<strong class="kd iu"> key=id </strong>和<strong class="kd iu"> expiration=3600秒</strong>以及<strong class="kd iu"> value= JSON Stringified格式的星舰</strong>数据添加到缓存中。这就是我们的<strong class="kd iu"> index.js </strong>现在的样子，</p><figure class="mp mq mr ms gt ju"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="9d54" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，如果我们转到浏览器，对Starship发出GET请求，它的数据也会被添加到Redis缓存中。</p><figure class="mp mq mr ms gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi np"><img src="../Images/9b0676c05b58969927a1edaea27eb03c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0uTJdzOcDvPlEX7r3QumHw.png"/></div></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk translated">获取星际飞船id 9的请求</figcaption></figure><p id="97d5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如前所述，您可以使用以下命令从终端访问Redis CLI，</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="9b18" class="md la it mu b gy my mz l na nb">redis-cli</span></pre><figure class="mp mq mr ms gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nq"><img src="../Images/cfec0938a3b3dbc802c6c0e68c28bdfe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fhmGALJ_lJ6WksnQ9fo1_A.png"/></div></div></figure><p id="4f4c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">运行命令<strong class="kd iu"> get 9 </strong>显示我们的id=9 的Starship数据确实被添加到了缓存中！</p><h2 id="820e" class="md la it bd lb me mf dn lf mg mh dp lj km mi mj ln kq mk ml lr ku mm mn lv mo bi translated">从缓存中检查和检索</h2><p id="a613" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">现在，如果我们需要的数据在缓存中不存在，我们只需要向<strong class="kd iu">星球大战API </strong>发送GET请求。我们将使用<strong class="kd iu"> Express中间件</strong>来实现一个功能，该功能在端点内执行代码之前检查我们的缓存。该函数将作为第二个参数<strong class="kd iu">传递给我们的端点函数。</strong></p><p id="5829" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">中间件功能将如下，</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="7e78" class="md la it mu b gy my mz l na nb">//Middleware Function to Check Cache</span><span id="7dbd" class="md la it mu b gy nm mz l na nb">checkCache = (<em class="nn">req</em>, <em class="nn">res</em>, <em class="nn">next</em>) <em class="nn">=&gt;</em> {</span><span id="9e13" class="md la it mu b gy nm mz l na nb"><em class="nn">       const</em> { id } = req.params;<br/>       <br/>       //get data value for key =id</span><span id="9402" class="md la it mu b gy nm mz l na nb">       redis_client.get(id, (<em class="nn">err</em>, <em class="nn">data</em>) <em class="nn">=&gt;</em> {</span><span id="4274" class="md la it mu b gy nm mz l na nb">           if (err) {</span><span id="d0fb" class="md la it mu b gy nm mz l na nb"><em class="nn">               console</em>.log(err);</span><span id="edd5" class="md la it mu b gy nm mz l na nb">               res.status(500).send(err);</span><span id="07a4" class="md la it mu b gy nm mz l na nb">           }<br/>           //if no match found</span><span id="5e03" class="md la it mu b gy nm mz l na nb">           if (data != null) {</span><span id="755b" class="md la it mu b gy nm mz l na nb">               res.send(data);</span><span id="9a80" class="md la it mu b gy nm mz l na nb">           } <br/>           else {<br/>               //proceed to next middleware function</span><span id="cd0f" class="md la it mu b gy nm mz l na nb">               next();</span><span id="a1aa" class="md la it mu b gy nm mz l na nb">           }</span><span id="058f" class="md la it mu b gy nm mz l na nb">        });</span><span id="3645" class="md la it mu b gy nm mz l na nb">};</span></pre><figure class="mp mq mr ms gt ju"><div class="bz fp l di"><div class="nj nk l"/></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk translated">添加checkCache中间件功能后的index.js</figcaption></figure><p id="d3b1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们再次对id=9 的Starship发出GET请求。</p><figure class="mp mq mr ms gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi np"><img src="../Images/55018b281aa2df2331e0c91c6ca6e387.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jmu98b42pna6v4t626M7gg.png"/></div></div></figure><p id="377d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">115 ms</strong>这几乎是一个<strong class="kd iu"> 7x </strong>的性能提升！</p><h1 id="0a32" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">结论</h1><p id="4cd6" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">值得注意的是，我们在本教程中仅仅触及了皮毛，Redis还可以提供更多的东西！我强烈推荐查看它的官方文档。这是<a class="ae mc" href="https://github.com/abdamin/redis-node-tutorial" rel="noopener ugc nofollow" target="_blank"> <strong class="kd iu">链接</strong> </a>到<strong class="kd iu"> Github </strong> <strong class="kd iu">存储库</strong>，包含我们应用程序的完整代码。</p><p id="e3c4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果您有任何问题，请随时发表评论。此外，如果这帮助了你，请喜欢并与他人分享。我定期发表与web开发相关的文章。考虑<a class="ae mc" href="https://abdullahsumsum.com/subscribe" rel="noopener ugc nofollow" target="_blank"> <strong class="kd iu">在此输入您的电子邮件</strong> </a>以了解与web开发相关的最新文章和教程。你也可以找到更多关于我在abdullahsumsum.com做的事情</p></div></div>    
</body>
</html>