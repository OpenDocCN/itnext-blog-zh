<html>
<head>
<title>Helm 3 — Mapping a directory of files into a container</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Helm 3 —将文件目录映射到容器中</h1>
<blockquote>原文：<a href="https://itnext.io/helm-3-mapping-a-directory-of-files-into-a-container-ed6c54372df8?source=collection_archive---------0-----------------------#2020-08-22">https://itnext.io/helm-3-mapping-a-directory-of-files-into-a-container-ed6c54372df8?source=collection_archive---------0-----------------------#2020-08-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/1d7e831867b70c570084b8312d710c07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1120/format:webp/0*dwZnIWqUO0vQQS6b.png"/></div></figure><p id="4f1a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在大多数情况下，当使用Helm将文件映射到容器时，标准方法是使用ConfigMap、Volume和VolumeMount。对于单个文件，这种方法非常好，但是如果需要将一个文件目录映射到一个容器中呢？如果这些文件名不符合YAML关键字命名标准，该怎么办？</p><p id="aaba" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">使用Helm的主要原因可能是基于一组不断变化的变量动态构建Kubernetes对象。每次运行Helm升级时动态生成ConfigMap的功能非常强大，但是当与用于文件映射的卷装载结合使用时，特别是在YAML不支持的每个部署或文件名都有许多文件发生变化的情况下，这将带来一些麻烦的挑战。这篇文章将尝试解决其中的一些问题，并提出一个优雅的动态映射文件目录的解决方案。</p><h1 id="3b40" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">简单的例子—一个文件</h1><p id="d7cc" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">假设我们希望将一个文件映射到一个特定路径的容器中。实现这一点的简单方法如下:</p><h2 id="948f" class="lv kt iq bd ku lw lx dn ky ly lz dp lc kf ma mb lg kj mc md lk kn me mf lo mg bi translated">第一步:</h2><p id="3a89" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">创建一个配置映射来映射名为<em class="mh"> config.yaml l </em> ike的文件，如下所示:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="41d5" class="lv kt iq mn b gy mr ms l mt mu"><strong class="mn ir">apiVersion: v1<br/>kind: ConfigMap<br/>metadata:<br/>  name: cm-single-file<br/>binaryData:<br/>{{ range $path, $bytes := .Files.Glob (printf "/path/to/configfile/config.yaml")}}<br/>{{ $name := base $path }}<br/>{{- printf "%s" $name}}{{ print ": "}}{{ $.Files.Get $path | b64enc }}<br/>{{ end }}</strong></span></pre><h2 id="06b7" class="lv kt iq bd ku lw lx dn ky ly lz dp lc kf ma mb lg kj mc md lk kn me mf lo mg bi translated">第二步:</h2><p id="5509" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">在作业、StatefulSet、DaemonSet、Deployment等之一中创建卷装载和卷段。将卷映射到配置映射，并将卷装载到卷，如下所示:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="60b2" class="lv kt iq mn b gy mr ms l mt mu"><strong class="mn ir">volumes:<br/>  - name: cm-single-file-volume<br/>    configMap:<br/>      name: cm-single-file<br/>volumeMounts:<br/>  - name: cm-single-file-volume<br/>    mountPath: /location/to/mount/config.yaml<br/>    subPath: config.yaml</strong></span></pre><p id="3ed9" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">上面的例子获取了一个名为<em class="mh"> config.yaml，</em>的文件，并通过ConfigMap将它映射为一个容器。然而，事情并不总是这么简单。</p><h2 id="2bee" class="lv kt iq bd ku lw lx dn ky ly lz dp lc kf ma mb lg kj mc md lk kn me mf lo mg bi translated">挑战</h2><p id="3023" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">在扩展上述方法时，存在许多挑战:</p><ul class=""><li id="33f1" class="mv mw iq jw b jx jy kb kc kf mx kj my kn mz kr na nb nc nd bi translated">使用不符合YAML规范的字符的文件名会导致Helm失败。此类文件名的示例:</li></ul><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="4258" class="lv kt iq mn b gy mr ms l mt mu"><strong class="mn ir">/some/directory/of/files/data,production.yaml<br/>/some/directory/of/files/config-prod.yaml</strong></span></pre><ul class=""><li id="1a56" class="mv mw iq jw b jx jy kb kc kf mx kj my kn mz kr na nb nc nd bi translated">当试图映射一个有几十甚至几百个文件的目录时，Helm崩溃了。虽然可以列出一个目录并将这些文件映射到一个配置映射中，但是不能迭代结果配置映射的内容，比如说，一个部署对象。这意味着，为了生成映射到配置映射的文件列表以便在文件目录中进行映射，必须再次完成源目录的目录列表。如果你有不符合YAML标准的文件名，你就不走运了。</li></ul><p id="0ed5" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">不幸的是，我遇到了这些问题，在谷歌找到一些结果后，我不得不想出一个创造性的方法来解决这些问题。</p><h1 id="714e" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">使用Helm 3.0映射多个文件</h1><p id="1ab7" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">鉴于上述问题，如何使用Helm将多个文件映射到一个容器中呢？答案在理论上有些简单，但对于初学者来说，生成它的Helm模板代码有些复杂。</p><h2 id="90f4" class="lv kt iq bd ku lw lx dn ky ly lz dp lc kf ma mb lg kj mc md lk kn me mf lo mg bi translated">第一步:</h2><p id="aaea" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">第一步是枚举文件列表，就像我们在简单的单个文件示例中开始做的那样:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="33f2" class="lv kt iq mn b gy mr ms l mt mu"><strong class="mn ir">apiVersion: v1<br/>kind: ConfigMap<br/>metadata:<br/>  name: cm-multi-file<br/>binaryData:<br/>{{ range $path, $bytes := .Files.Glob (printf "/path/to/configfiles/**")}}<br/>{{ $name := base $path }}<br/>{{- sha256sum (printf "%s/%s" (index (regexSplit "path_to_files" (dir $path) -1) 1 ) $name ) | indent 2 }}{{ print ": "}}{{ $.Files.Get $path | b64enc }}<br/>{{ end }}</strong></span></pre><p id="f48f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">注意这次有一些不同:</p><ul class=""><li id="6795" class="mv mw iq jw b jx jy kb kc kf mx kj my kn mz kr na nb nc nd bi translated">首先，我们使用内置的sprig函数<a class="ae ne" href="http://masterminds.github.io/sprig/crypto.html" rel="noopener ugc nofollow" target="_blank"> sha256sum </a>。这个函数允许我们创建文件名的sha256哈希，从而解决了上面列出的第一个挑战。由于sha256哈希包含YAML支持的字符作为键名，我们可以绕过任何奇怪的文件命名约定。</li><li id="f9be" class="mv mw iq jw b jx nf kb ng kf nh kj ni kn nj kr na nb nc nd bi translated">其次，我们使用正则表达式语法从完整路径中只提取文件名，因为我们在生成散列时不希望路径出现在文件名中。</li><li id="38bc" class="mv mw iq jw b jx nf kb ng kf nh kj ni kn nj kr na nb nc nd bi translated">最后，与单个文件示例一样，我们对文件的内容进行了base64加密，这使得我们也可以利用二进制数据文件。</li></ul><p id="b593" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">就是这样。我们现在有了一个包含文件条目的ConfigMap，可以在部署、StatefulSet、DaemonSet或job中使用。</p><h2 id="3696" class="lv kt iq bd ku lw lx dn ky ly lz dp lc kf ma mb lg kj mc md lk kn me mf lo mg bi translated">第二步:</h2><p id="8292" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">与单个文件示例一样，第二步是通过引用我们的新ConfigMap将我们的文件映射到一个VolumeMount，如下所示:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="621b" class="lv kt iq mn b gy mr ms l mt mu"><strong class="mn ir">volumes:<br/> - name: cm-multi-file-volume<br/>   configMap:<br/>     name: cm-multi-file<br/>volumeMounts:<br/> {{ range $path, $bytes := .Files.Glob ( printf "/path/to/configfiles/**") }}<br/> {{ $name := base $path }}<br/>  - name: cm-multi-file-volume<br/>    mountPath: {{ printf "/etc/configuration/%s/%s" (index (regexSplit "/path/to/configfiles" (dir $path) -1) 1) $name | indent 2 }}<br/>    subPath: {{- sha256sum (printf "%s/%s" (index (regexSplit "path_to_files" (dir $path) -1) 1 ) $name ) | indent 2 }}<br/> {{ end }}</strong></span></pre><p id="f238" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这里发生了很多事情，让我们来分解一下:</p><ul class=""><li id="78ef" class="mv mw iq jw b jx jy kb kc kf mx kj my kn mz kr na nb nc nd bi translated">与单个文件示例一样，我们首先必须创建一个引用配置图的卷</li><li id="b989" class="mv mw iq jw b jx nf kb ng kf nh kj ni kn nj kr na nb nc nd bi translated">然后，我们必须创建一组卷装载。这一次，我们需要从配置图中动态添加文件集，而不是手动指定文件。由于我们无法读取创建的配置图，我们再次读取文件的目录列表。</li><li id="3528" class="mv mw iq jw b jx nf kb ng kf nh kj ni kn nj kr na nb nc nd bi translated">上例中的挂载路径只是文件所在的文件夹(也可以是其他文件夹)，映射到/etc/configuration。因此，完整的安装路径应该是:</li></ul><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="3556" class="lv kt iq mn b gy mr ms l mt mu"><strong class="mn ir">/etc/configuration/configfiles/&lt;filename&gt;</strong></span></pre><ul class=""><li id="a5e3" class="mv mw iq jw b jx jy kb kc kf mx kj my kn mz kr na nb nc nd bi translated">对于每个文件，我们必须定义一个子路径。由于配置映射使用SHA256哈希引用文件名，我们必须以与配置映射相同的方式重新哈希文件名。也就是说，通过分离基本路径，只给我们留下文件名。</li></ul><p id="1258" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">假设有一个文件目录，结果输出如下所示:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="a1a2" class="lv kt iq mn b gy mr ms l mt mu"><strong class="mn ir">apiVersion: v1<br/>  kind: ConfigMap<br/>  metadata:<br/>   name: cm-multi-file<br/>  binaryData:<br/>481562103018784bef2571ef183a5284b8246f3e2f1fb86143f401c30602a3a9: sd3243=</strong></span><span id="d1bc" class="lv kt iq mn b gy nk ms l mt mu"><strong class="mn ir">6001ea194c183a6a42269c3d40334a87ade85de82999ec42814618df58a5176a: 2347dfklj37==</strong></span><span id="1948" class="lv kt iq mn b gy nk ms l mt mu"><strong class="mn ir">97acc83e0b4632fe551bd472aac750065b6b73817bbfc7ec8ca05742d9bd2ed8: jhkfv2348lj37==</strong></span><span id="5ade" class="lv kt iq mn b gy nk ms l mt mu"><strong class="mn ir">0e39b2d867947dcb78613d4bb6be6cc714792db9671047dc0ef8efba88185f74: sdfk98gf37==</strong></span></pre><ul class=""><li id="61a4" class="mv mw iq jw b jx jy kb kc kf mx kj my kn mz kr na nb nc nd bi translated">上面我们有一个ConfigMap条目，其中映射了4个文件。每个文件的名称都经过了哈希处理。每个文件中的数据都经过了base64编码，因为我们使用的是binaryData ConfigMap条目。</li></ul><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="1b52" class="lv kt iq mn b gy mr ms l mt mu"><strong class="mn ir">apiVersion: v1<br/> kind: Deployment<br/> ...<br/>       volumes:<br/>         - name: cm-multi-file-volume<br/>           configMap:<br/>             name: cm-multi-file<br/>       containers:<br/>           volumeMounts:<br/>  </strong>           - name: <strong class="mn ir">cm-multi-file-volume<br/></strong>                 mountPath:   <strong class="mn ir">/etc/configuration/configfiles/file1.yaml</strong><br/>                 subPath:  <strong class="mn ir">481562103018784bef2571ef183a5284b8246f3e2f1fb86143f401c30602a3a9</strong></span><span id="01ea" class="lv kt iq mn b gy nk ms l mt mu"><strong class="mn ir">  </strong>           - name: <strong class="mn ir">cm-multi-file-volume<br/>  </strong>               mountPath:   <strong class="mn ir">/etc/configuration/configfiles/file2.yaml</strong><br/>                 subPath:  <strong class="mn ir">6001ea194c183a6a42269c3d40334a87ade85de82999ec42814618df58a5176a</strong></span><span id="fe66" class="lv kt iq mn b gy nk ms l mt mu">             - name: <strong class="mn ir">cm-multi-file-volume<br/>  </strong>               mountPath:   <strong class="mn ir">/etc/configuration/configfiles/file3.yaml</strong><br/>                 subPath:  <strong class="mn ir">97acc83e0b4632fe551bd472aac750065b6b73817bbfc7ec8ca05742d9bd2ed8</strong></span><span id="8742" class="lv kt iq mn b gy nk ms l mt mu">             - name: <strong class="mn ir">cm-multi-file-volume<br/>  </strong>               mountPath:   <strong class="mn ir">/etc/configuration/configfiles/file4.yaml</strong><br/>                 subPath:  <strong class="mn ir">0e39b2d867947dcb78613d4bb6be6cc714792db9671047dc0ef8efba88185f74</strong></span></pre><ul class=""><li id="aae6" class="mv mw iq jw b jx jy kb kc kf mx kj my kn mz kr na nb nc nd bi translated">在部署对象中，我们有VolumeMount条目，它们将文件名映射到它的最终挂载点。注意，文件名仍然是SHA256哈希，但是挂载路径现在包含了实际的文件名</li></ul><h1 id="cbf2" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">替代解决方案—压缩文件</h1><p id="4e95" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">这是解决这个问题的一种方法。还考虑了zip文件解决方案，但是由于Helm没有内置的本地zip/压缩功能，我不得不依赖contain来解压配置文件的目录。由于您不想将配置以zip文件的形式签入源代码管理，因此在升级Helm之前，其他一些进程需要生成一个zip文件。因此，就解决方案的优雅性和在这种情况下只依赖Helm(至少对我来说)而言，基于散列的方法增加的复杂性是值得的。</p><h1 id="509b" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">摘要</h1><p id="8714" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">如果文件的名称不符合Helm YAML密钥命名标准语法，则使用Helm 3无法轻松地将文件目录映射到容器中。为了解决这个问题并保持在Helm工具的范围内，可以由文件名组成SHA256散列来克服这个问题，因此可以使用配置映射、卷和卷装载的组合来映射到容器映像。</p></div></div>    
</body>
</html>