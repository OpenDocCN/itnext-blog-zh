<html>
<head>
<title>Azure WebJob to encrypt blobs into Storage Account with Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Node.js将blobs加密到存储帐户的Azure WebJob</h1>
<blockquote>原文：<a href="https://itnext.io/azure-webjob-to-encrypt-blobs-into-storage-account-with-node-js-90a0e43c6230?source=collection_archive---------3-----------------------#2022-12-26">https://itnext.io/azure-webjob-to-encrypt-blobs-into-storage-account-with-node-js-90a0e43c6230?source=collection_archive---------3-----------------------#2022-12-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/6a9da22d928b877fb35fe089d8b7f926.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*COxzM4sp--z-GlXyk1gurg.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">作者图片:Parodi Ligure周围</figcaption></figure><p id="ff95" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">前段时间我在工作中接到一个任务。来自我的Microsoft Azure DevOps板的用户故事要求用PGP标准加密银行要求的报告。</p><p id="6007" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">因此，我开始像其他开发人员一样四处寻找和研究。</p><p id="7ce8" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">为了做到这一点，我使用了微软的<a class="ae la" href="https://www.npmjs.com/package/@azure/storage-blob" rel="noopener ugc nofollow" target="_blank"> @azure/storage-blob库</a>和<a class="ae la" href="https://www.npmjs.com/package/@azure/storage-blob" rel="noopener ugc nofollow" target="_blank"> openpgp </a>库，除此之外，你还应该留意一下<a class="ae la" href="https://www.npmjs.com/package/dotenv" rel="noopener ugc nofollow" target="_blank"> dotenv </a>，这对于参数化我们的小脚本会有很大的帮助。</p><h1 id="82db" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">动手操作:</h1><ol class=""><li id="381b" class="lz ma iq ke b kf mb kj mc kn md kr me kv mf kz mg mh mi mj bi translated">在您的驱动器上选择您的项目目录，并通过运行命令<em class="mk"> npm init </em>来启动一个新的NPM包，然后按照不言自明的说明进行操作。</li><li id="1e51" class="lz ma iq ke b kf ml kj mm kn mn kr mo kv mp kz mg mh mi mj bi translated">安装所需的库(我们将使用特定的版本，但您可以自由安装最新的版本，并告诉我它是否仍然有效，或者最新的npm包是否正在破坏应用:) )、用于blob操作的<a class="ae la" href="https://www.npmjs.com/package/@azure/storage-blob" rel="noopener ugc nofollow" target="_blank"> @azure/storage-blob库</a>、用于加密的<a class="ae la" href="https://www.npmjs.com/package/@azure/storage-blob" rel="noopener ugc nofollow" target="_blank"> openpgp </a>和<a class="ae la" href="https://www.npmjs.com/package/dotenv" rel="noopener ugc nofollow" target="_blank"> dotenv </a>，方法是将命令运行到您的CLI中，您的<em class="mk"> package.json </em>文件应如下所示:</li></ol><pre class="mq mr ms mt gt mu mv mw bn mx my bi"><span id="b333" class="mz lc iq mv b be na nb l nc nd">npm i @azure/storage-blob@12.0.0<br/>npm i openpgp@5.0.0–3<br/>npm i dotenv@6.0.0</span></pre><pre class="ne mu mv mw bn mx my bi"><span id="9537" class="mz lc iq mv b be na nb l nc nd">{<br/>  "name": "encrypt-webjob",<br/>  "version": "1.0.0",<br/>  "description": "",<br/>  "main": "index.js",<br/>  "scripts": {<br/>    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1"<br/>  },<br/>  "author": "",<br/>  "license": "ISC",<br/>  "dependencies": {<br/>    "@azure/storage-blob": "^12.0.0",<br/>    "dotenv": "^6.0.0",<br/>    "openpgp": "^5.0.0-3"<br/>  }<br/>}</span></pre><p id="63c0" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">3.如果你的app主入口文件是如上的index.js，那么创建<em class="mk"> index.js </em>文件并粘贴如下，这将在文章中进一步解释。</p><pre class="mq mr ms mt gt mu mv mw bn mx my bi"><span id="cf3c" class="mz lc iq mv b be na nb l nc nd">const { BlobServiceClient } = require('@azure/storage-blob');<br/>require('dotenv').config()<br/>const openpgp = require('openpgp');<br/>const streamToString = require('./streamProcessor');<br/><br/>function decryptBase64(paramEncodedAsBase64) {        <br/>    return  Buffer.from(paramEncodedAsBase64,'base64').toString();<br/>}<br/>function modifyExtension(string) {<br/>    let fileName;<br/>    fileName = string + ".pgp";    <br/>    return fileName;<br/>}<br/><br/>async function main() {    <br/>    var publicKey = decryptBase64(process.env.ENCRYPTION_KEY) <br/>        <br/>    const blobServiceClient = BlobServiceClient.fromConnectionString(process.env.STORAGE_CONNECTION_STRING)<br/>    const containerClient = blobServiceClient.getContainerClient(process.env.REPORTS_SOURCE_CONTAINER_FOR_ENCRYPTION)<br/>    const containerEncryptedFiles = blobServiceClient.getContainerClient(process.env.ENCRYPTED_DESTINATION_CONTAINER)<br/>    const containerOriginalFiles = blobServiceClient.getContainerClient(process.env.ORIGINAL_FILES_DESTINATION_CONTAINER)<br/>    const matchBlobByName = process.env.MATCH_REPORT_FILES<br/>    await containerEncryptedFiles.createIfNotExists(process.env.ENCRYPTED_DESTINATION_CONTAINER)<br/>    await containerOriginalFiles.createIfNotExists(process.env.ORIGINAL_FILES_DESTINATION_CONTAINER)<br/>    for await (const blob of containerClient.listBlobsFlat()) {<br/>        if (blob.name.match(matchBlobByName)) {<br/>            const blockBlobClient = containerClient.getBlockBlobClient(blob.name);<br/>            const encryptedBlockBlobClient = containerEncryptedFiles.getBlockBlobClient(modifyExtension(blob.name))<br/>            const originalBlockBlobClient = containerOriginalFiles.getBlockBlobClient(blob.name)<br/>            blockBlobClient.download(0)<br/>            .then(downloadBlockBlobResponse =&gt; streamToString(downloadBlockBlobResponse.readableStreamBody))<br/>            .then(blobAsString =&gt; {<br/>                return Promise.all([openpgp.createMessage({ text: blobAsString }), openpgp.readKey({ armoredKey: publicKey.toString() }), originalBlockBlobClient.upload(blobAsString, blobAsString.length)])<br/>                .then(([message, encryptionKeys])=&gt;{<br/>                    return openpgp.encrypt({<br/>                        message,<br/>                        encryptionKeys,<br/>                    })                   <br/>                })                <br/>                .then(encrypted =&gt; {encryptedBlockBlobClient.upload(encrypted, encrypted.length)})              <br/>                .then(containerClient.deleteBlob(blob.name))                <br/>            })           <br/>        }<br/>    }<br/><br/>}       <br/><br/><br/>main().then(() =&gt; console.log('Done')).catch((ex) =&gt; console.log(ex.message));<br/><br/><br/><br/></span></pre><p id="a59b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">脚本解释:</strong></p><p id="e864" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们导入我们需要的库。</p><pre class="mq mr ms mt gt mu mv mw bn mx my bi"><span id="9957" class="mz lc iq mv b be na nb l nc nd">const { BlobServiceClient } = require('@azure/storage-blob');<br/>require('dotenv').config()<br/>const openpgp = require('openpgp');</span></pre><p id="04f9" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们定义一个引用流处理器脚本的常量(将在下一步中创建)。</p><pre class="mq mr ms mt gt mu mv mw bn mx my bi"><span id="f7a9" class="mz lc iq mv b be na nb l nc nd">const streamToString = require('./streamProcessor');</span></pre><p id="f1a5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们定义了一个函数，它将从base64解码存储在Azure Key Vault中的加密密钥——由于未知的原因，如果密钥不是以base64形式存储的,则无法正确检索到密钥<strong class="ke ir">,因此在密钥以字符串形式生成后，您可以使用<em class="mk"> window.btoa() </em>浏览器内置函数来生成base64字符串密钥，该密钥将作为秘密存储在Azure Key Vault中，并将作为环境变量被引用。</strong></p><pre class="mq mr ms mt gt mu mv mw bn mx my bi"><span id="3ee4" class="mz lc iq mv b be na nb l nc nd">function decryptBase64(paramEncodedAsBase64) {        <br/>    return  Buffer.from(paramEncodedAsBase64,'base64').toString();<br/>}</span></pre><p id="2f78" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们定义一个函数来将结果blob的扩展变成<em class="mk">。pgp </em></p><pre class="mq mr ms mt gt mu mv mw bn mx my bi"><span id="5199" class="mz lc iq mv b be na nb l nc nd">function modifyExtension(string) {<br/>    let fileName;<br/>    fileName = string + ".pgp";    <br/>    return fileName;<br/>}</span></pre><p id="bf2f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们定义了<em class="mk">主</em>函数来完成所有的魔术。它将检索环境变量的值(加密密钥为[process.env.ENCRYPTION_KEY]，存储帐户连接字符串为[process . env . Storage _ CONNECTION _ STRING]，源容器名称为[process . env . reports _ SOURCE _ CONTAINER _ FOR _ ENCRYPTION]，加密blob的目标容器为[process . env . encrypted _ DESTINATION _ CONTAINER]，加密后原始文件的副本，因为我们可能需要在加密后移动它们，这样我们就不会在web作业上再次加密它们，重新运行为[process . env . original _ FILES _ DESTINATION _ CONTAINER</p><p id="cea1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">然后我们动态地创建容器，如果它们不存在</p><pre class="mq mr ms mt gt mu mv mw bn mx my bi"><span id="243a" class="mz lc iq mv b be na nb l nc nd">    await containerEncryptedFiles.createIfNotExists(process.env.ENCRYPTED_DESTINATION_CONTAINER)<br/>    await containerOriginalFiles.createIfNotExists(process.env.ORIGINAL_FILES_DESTINATION_CONTAINER)</span></pre><p id="1907" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">接着我们在斑点上做一个循环</p><pre class="mq mr ms mt gt mu mv mw bn mx my bi"><span id="d1f2" class="mz lc iq mv b be na nb l nc nd">for await (const blob of containerClient.listBlobsFlat()) {...}</span></pre><p id="2fba" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在这个循环中，我们在尖括号&lt;&lt;&lt;<em class="mk">/blobNameVirtualFolder/&gt;&gt;&gt;</em>blob name . extension之间的模式之后过滤斑点，如下所示</p><pre class="mq mr ms mt gt mu mv mw bn mx my bi"><span id="d5de" class="mz lc iq mv b be na nb l nc nd">if (blob.name.match(matchBlobByName)) {...}</span></pre><p id="fca0" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们实例化了<em class="mk"> blockBlobClient、encryptedblockblocbclient</em>和<em class="mk"> originalBlockBlobClient </em>，并且我们下载了过滤后的blobs，以便通过使用<em class="mk">blockBlobClient . download(0)</em>进行加密来“改变”它们</p><pre class="mq mr ms mt gt mu mv mw bn mx my bi"><span id="650f" class="mz lc iq mv b be na nb l nc nd">            const blockBlobClient = containerClient.getBlockBlobClient(blob.name);<br/>            const encryptedBlockBlobClient = containerEncryptedFiles.getBlockBlobClient(modifyExtension(blob.name))<br/>            const originalBlockBlobClient = containerOriginalFiles.getBlockBlobClient(blob.name)<br/>            blockBlobClient.download(0)</span></pre><p id="380d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在<em class="mk">blockblobclient . download(0)</em>上，这是一个从系统中读取或下载blob(包括其元数据和属性)的承诺，我们应用以下逻辑将blob下载为字符串流并返回一个<strong class="ke ir">承诺。all </strong>使用<em class="mk"> openpgp </em>库，一旦完成此承诺，加密的blob将被上传到为加密的blob指定的容器中，并且……旧的原始blob将被删除，因为blob在承诺开始时被移动。</p><pre class="mq mr ms mt gt mu mv mw bn mx my bi"><span id="8f40" class="mz lc iq mv b be na nb l nc nd">            .then(downloadBlockBlobResponse =&gt; streamToString(downloadBlockBlobResponse.readableStreamBody))<br/>            .then(blobAsString =&gt; {<br/>                return Promise.all([openpgp.createMessage({ text: blobAsString }), openpgp.readKey({ armoredKey: publicKey.toString() }), originalBlockBlobClient.upload(blobAsString, blobAsString.length)])<br/>                .then(([message, encryptionKeys])=&gt;{<br/>                    return openpgp.encrypt({<br/>                        message,<br/>                        encryptionKeys,<br/>                    })                   <br/>                })                <br/>                .then(encrypted =&gt; {encryptedBlockBlobClient.upload(encrypted, encrypted.length)})              <br/>                .then(containerClient.deleteBlob(blob.name))                <br/>            })   </span></pre><p id="b09d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在最后一段中，我们调用主<em class="mk">函数</em>来执行</p><pre class="mq mr ms mt gt mu mv mw bn mx my bi"><span id="5dcf" class="mz lc iq mv b be na nb l nc nd">main().then(() =&gt; console.log('Done')).catch((ex) =&gt; console.log(ex.message));</span></pre><p id="d5e5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">也就是说，我们创建文件<em class="mk"> streamProcessor.js </em>并粘贴微软提供的以下代码——不难“猜测”它的目的是什么；)</p><pre class="mq mr ms mt gt mu mv mw bn mx my bi"><span id="ec25" class="mz lc iq mv b be na nb l nc nd">const streamToString = async function (readableStream) {  <br/>    return new Promise((resolve, reject) =&gt; {<br/>        const chunks = [];<br/>        readableStream.on("data", (data) =&gt; {<br/>            chunks.push(data.toString());<br/>        });<br/><br/>        readableStream.on("end", () =&gt; {<br/>            resolve(chunks.join(""));<br/>        });<br/>        readableStream.on("error", reject);<br/>    });<br/>}<br/><br/><br/>module.exports = streamToString;</span></pre><p id="ca2c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">此刻，应用程序已经完成，我们需要转移到云阶段。</p><p id="049f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">首先，将整个项目文件夹压缩为Azure WebJobs接受的zip格式。</p><p id="3d35" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">登录你的Azure账户，进入你的web应用，然后导航到<em class="mk">配置</em>部分，按照下图创建环境变量并添加变量。</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nf"><img src="../Images/d95704b4d2242d08cc9ba98dbabca44a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YvcsYl3V64fWWpz3rYBBsg.png"/></div></div></figure><p id="149a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">最后，您的配置应该是这样的(不要忘记保存配置)。</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ng"><img src="../Images/28ed7565ecf8b86174d0e6e857706163.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LHNPIDfuuA3aQXmE_YufoA.png"/></div></div></figure><p id="8a1f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">关于保存加密密钥值的密钥库引用</strong>的语法的小注意事项——在您的密钥库中，您需要提供对您的web应用程序的访问权限来访问这些秘密(不幸的是，我无法在此介绍这一点，因为这不在本文的讨论范围之内),然后您复制密钥的引用，并将其添加到环境变量的值中，如下例所示。</p><pre class="mq mr ms mt gt mu mv mw bn mx my bi"><span id="7bdb" class="mz lc iq mv b be na nb l nc nd">@Microsoft.KeyVault(SecretUri=https://myvault.vault.azure.net/secrets/mysecret/)</span></pre><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nh"><img src="../Images/8ffaffe5d06ddf86e121873a57036ddf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OMlBL7_K2P8Mm8ZVdog6-A.png"/></div></div></figure><p id="33cc" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">转到WebJobs部分，按照简单的流程，将压缩代码添加为计划的或手动触发的webjob。</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/9ec289df58eeca8eac37aaf33293056a.png" data-original-src="https://miro.medium.com/v2/resize:fit:736/format:webp/1*1xZGGzCJMSWI_zh9wcZKww.png"/></div></figure><p id="83e3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们已经完成了我们的小应用程序，它使用行业标准的PGP强加密来加密文本blobs(不仅如此)。<br/>如有错误或建议，欢迎给我留言。</p></div><div class="ab cl nj nk hu nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="ij ik il im in"><pre class="mq mr ms mt gt mu mv mw bn mx my bi"><span id="2532" class="mz lc iq mv b be na nb l nq nd">More about the author on <a class="ae la" href="https://techdocs.ro" rel="noopener ugc nofollow" target="_blank">https://techdocs.ro</a></span></pre></div></div>    
</body>
</html>