<html>
<head>
<title>Iterators and generators work great together</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">迭代器和生成器一起工作非常好</h1>
<blockquote>原文：<a href="https://itnext.io/iterators-and-generators-work-great-together-80b196aaee2d?source=collection_archive---------4-----------------------#2019-07-24">https://itnext.io/iterators-and-generators-work-great-together-80b196aaee2d?source=collection_archive---------4-----------------------#2019-07-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/53c094ec0de876cc2f45206b38d774ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9H5rmyp3MgrcA8i1emsJPg.jpeg"/></div></div></figure><p id="799c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">迭代器和生成器都是有趣的JavaScript特性。当你把它们结合在一起使用时更是如此。在这篇博文中，让我们重温一下对生成器和迭代器的理解，看看如何将它们结合起来编写优雅的JavaScript代码。</p><h1 id="1dec" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">迭代程序</h1><p id="d79b" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">简单地说，迭代器是一个符号，你可以用它来使任何对象<em class="mc">可迭代</em>。可迭代对象可以使用<code class="fe md me mf mg b">for...of</code>循环进行迭代。首先，让我们回顾一下这些符号是什么。</p><h2 id="f315" class="mh la it bd lb mi mj dn lf mk ml dp lj km mm mn ln kq mo mp lr ku mq mr lv ms bi translated">标志</h2><p id="2367" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">符号是一种保证唯一的原语。它的主要用途之一是用作字典集合(地图或普通对象)的键。此外，它总是独一无二的这一事实使它成为其他有趣用例的良好候选。现在让我们探讨一下我所说的真正独特的符号是什么意思:</p><figure class="mt mu mv mw gt ju"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="0d34" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">上面的代码将打印出来:</p><pre class="mt mu mv mw gt mz mg na nb aw nc bi"><span id="1084" class="mh la it mg b gy nd ne l nf ng"><em class="mc">// String Unique is not equal to Symbol(Unique)</em></span><span id="21e5" class="mh la it mg b gy nh ne l nf ng"><em class="mc">// Symbol(Unique) is not equal to Symbol(Unique)</em></span></pre><p id="26ac" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先<code class="fe md me mf mg b">if</code>将值为<code class="fe md me mf mg b">Unique</code>的字符串<code class="fe md me mf mg b">notSymbol</code>与描述值为<code class="fe md me mf mg b">Unique</code>的符号实例进行比较。如你所见，这两个变量不相等。一个更有趣的例子是第二个<code class="fe md me mf mg b">if</code>，我们在比较两个看起来完全相同的符号。但是，即使两个符号具有相同的描述值，它们也不相等。描述仅用于提高代码的可读性。</p><h2 id="6586" class="mh la it bd lb mi mj dn lf mk ml dp lj km mm mn ln kq mo mp lr ku mq mr lv ms bi translated">定义迭代器和可迭代对象</h2><p id="d551" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">JavaScript提供了<code class="fe md me mf mg b">Symbol.iterator</code>静态符号，我们可以用它来使任何对象可迭代。让我们来看看这个例子:</p><p id="ad28" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先让我们定义一个我们将要迭代的类:</p><figure class="mt mu mv mw gt ju"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="9b4e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe md me mf mg b">PetShelter</code>是一个简单的类，包含一个名为<code class="fe md me mf mg b">pets</code>的对象数组。在我们的<code class="fe md me mf mg b">pets</code>属性下面，我们使用<code class="fe md me mf mg b">Symbol.iterator</code>作为键添加了另一个属性。我们给它分配一个函数，该函数返回一个新的<code class="fe md me mf mg b">PetIterator</code>实例。</p><p id="55fd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在让我们看看<code class="fe md me mf mg b">PetIterator</code>的定义是什么样的:</p><figure class="mt mu mv mw gt ju"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="d7dd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe md me mf mg b">PetIterator</code>只是另一个只包含一个方法的类——<code class="fe md me mf mg b">next</code>。每个迭代器都需要有<code class="fe md me mf mg b">next</code>方法。同样，这个方法必须返回一个包含两个属性的对象:<code class="fe md me mf mg b">done</code>和<code class="fe md me mf mg b">value</code>。您可能已经猜到了这些属性的用途:</p><ul class=""><li id="12b4" class="ni nj it kd b ke kf ki kj km nk kq nl ku nm ky nn no np nq bi translated"><code class="fe md me mf mg b">done</code>是一个布尔属性，表示我们是否已经到达迭代的末尾。</li><li id="fd03" class="ni nj it kd b ke nr ki ns km nt kq nu ku nv ky nn no np nq bi translated"><code class="fe md me mf mg b">value</code>用于返回当前迭代项的值。</li></ul><h2 id="df3f" class="mh la it bd lb mi mj dn lf mk ml dp lj km mm mn ln kq mo mp lr ku mq mr lv ms bi translated">一起使用它们</h2><p id="f7de" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">现在我们有了iterable和iterator，让我们看看如何一起使用它们:</p><figure class="mt mu mv mw gt ju"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="c2e8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">很简单，对吧？<code class="fe md me mf mg b">for...of</code>循环自动创建并使用了由<code class="fe md me mf mg b">PetShelter</code>类提供的迭代器的一个新实例。</p><p id="741b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">上述代码会将以下内容打印到控制台:</p><pre class="mt mu mv mw gt mz mg na nb aw nc bi"><span id="6d26" class="mh la it mg b gy nd ne l nf ng"><em class="mc">// { pet: { type: 'cat', name: 'Emma' } }</em></span><span id="a0e7" class="mh la it mg b gy nh ne l nf ng"><em class="mc">// { pet: { type: 'dog', name: 'Bubbles' } }</em></span><span id="3787" class="mh la it mg b gy nh ne l nf ng"><em class="mc">// { pet: { type: 'dog', name: 'Hank' } }</em></span><span id="4d8a" class="mh la it mg b gy nh ne l nf ng"><em class="mc">// { pet: { type: 'cat', name: 'Leo' } }</em></span></pre><h1 id="f82d" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">发电机</h1><p id="0223" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">生成器是EcmaScript 2015规范中引入的新语法功能之一。就像<code class="fe md me mf mg b">async</code>一样，通过在客户端认为合适的时候暂停和恢复程序，生成器可以用来控制程序的执行流。让我们看一个如何定义生成器的例子:</p><figure class="mt mu mv mw gt ju"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="807c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">正如您所看到的，生成器只是普通的函数，有一些小的不同:</p><ul class=""><li id="43f6" class="ni nj it kd b ke kf ki kj km nk kq nl ku nm ky nn no np nq bi translated">为了定义一个生成器，你必须在关键字<code class="fe md me mf mg b">function</code>后加上<code class="fe md me mf mg b">*</code>。</li><li id="9ac1" class="ni nj it kd b ke nr ki ns km nt kq nu ku nv ky nn no np nq bi translated"><code class="fe md me mf mg b">yield</code>可以在生成器内部使用来暂停执行。另外，<code class="fe md me mf mg b">yield</code>关键字之后的任何值都被传递回调用生成器的客户机。</li></ul><p id="800f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在让我们看看如何使用我们的发电机:</p><figure class="mt mu mv mw gt ju"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="4f42" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下面是上面代码的输出:</p><pre class="mt mu mv mw gt mz mg na nb aw nc bi"><span id="8dcd" class="mh la it mg b gy nd ne l nf ng"><em class="mc">// Hi</em></span><span id="4bc7" class="mh la it mg b gy nh ne l nf ng"><em class="mc">// What's your name?</em></span><span id="6569" class="mh la it mg b gy nh ne l nf ng"><em class="mc">// I'm done here</em></span></pre><p id="74af" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里有几件事需要注意:</p><ul class=""><li id="c893" class="ni nj it kd b ke kf ki kj km nk kq nl ku nm ky nn no np nq bi translated">调用<code class="fe md me mf mg b">generatorSample()</code>并不运行生成器函数，而是返回生成器的一个新实例。</li><li id="9f47" class="ni nj it kd b ke nr ki ns km nt kq nu ku nv ky nn no np nq bi translated">一旦我们的生成器内部的代码遇到<code class="fe md me mf mg b">yield</code>，它就会停止。我们使用生成器的<code class="fe md me mf mg b">next</code>方法继续执行。</li></ul><p id="a410" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下面是<code class="fe md me mf mg b">next</code>对象的结构:</p><pre class="mt mu mv mw gt mz mg na nb aw nc bi"><span id="86e2" class="mh la it mg b gy nd ne l nf ng">{</span><span id="9492" class="mh la it mg b gy nh ne l nf ng">value: 'Hi' <em class="mc">//yielded value,</em></span><span id="4a14" class="mh la it mg b gy nh ne l nf ng">done: <strong class="mg iu">false</strong> <em class="mc">//whether the generator is done executing or not</em></span><span id="3d4a" class="mh la it mg b gy nh ne l nf ng">}</span></pre><h2 id="e762" class="mh la it bd lb mi mj dn lf mk ml dp lj km mm mn ln kq mo mp lr ku mq mr lv ms bi translated">使用生成器创建迭代器</h2><p id="b754" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">看着眼熟？希望现在你开始看到迭代器和生成器之间的联系。坦率地说，ES 2015引入生成器的主要原因之一是让创建迭代器的过程变得更加容易。事实上，要将我们的<code class="fe md me mf mg b">PetShelter</code>变成一个iterable，我们所要做的就是让[ <code class="fe md me mf mg b">Symbol.iterator</code> ]函数返回一个生成器的新实例。现在，让我们来看看如何实现这一点:</p><figure class="mt mu mv mw gt ju"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="8567" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">就像前面的例子一样，上面的代码将产生以下输出:</p><pre class="mt mu mv mw gt mz mg na nb aw nc bi"><span id="afcc" class="mh la it mg b gy nd ne l nf ng"><em class="mc">// { pet: { type: 'cat', name: 'Emma' } }</em></span><span id="b0e0" class="mh la it mg b gy nh ne l nf ng"><em class="mc">// { pet: { type: 'dog', name: 'Bubbles' } }</em></span><span id="a961" class="mh la it mg b gy nh ne l nf ng"><em class="mc">// { pet: { type: 'dog', name: 'Hank' } }</em></span><span id="7336" class="mh la it mg b gy nh ne l nf ng"><em class="mc">// { pet: { type: 'cat', name: 'Leo' } }</em></span></pre><p id="234c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如您所见，我们不再需要为我们的<code class="fe md me mf mg b">PetIterator</code>定义一个单独的类。我们要定义的只是一个生成器，它使用一个<code class="fe md me mf mg b">for</code>循环来迭代<code class="fe md me mf mg b">pets</code>属性。接下来，我们调整了<code class="fe md me mf mg b">[Symbol.iterator]</code>函数来返回一个新的<code class="fe md me mf mg b">PetIterator</code>生成器实例。</p><p id="2512" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们能够使用生成器来代替迭代器，因为生成器已经有了一个名为<code class="fe md me mf mg b">next</code>的方法，它返回一个具有<code class="fe md me mf mg b">done</code>和<code class="fe md me mf mg b">value</code>属性的对象。</p><p id="bcc6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这个帖子到此为止！在这里，我们简要回顾了迭代器和生成器的基础知识，以及如何使用它们轻松创建可迭代对象。我希望这篇文章对你有用。</p><p id="8565" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">感谢您的阅读！</p></div><div class="ab cl nw nx hx ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="im in io ip iq"><p id="10e9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="mc">原载于2019年7月24日https://isamatov.com</em><em class="mc">的</em> <a class="ae od" href="https://isamatov.com/iterators-and-generators-work-perfect-together/" rel="noopener ugc nofollow" target="_blank"> <em class="mc">。</em></a></p></div></div>    
</body>
</html>