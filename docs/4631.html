<html>
<head>
<title>Update lifecycle of a class-based React component</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">更新基于类的React组件的生命周期</h1>
<blockquote>原文：<a href="https://itnext.io/update-lifecycle-of-a-class-based-react-component-f0cb800a8aca?source=collection_archive---------3-----------------------#2020-08-08">https://itnext.io/update-lifecycle-of-a-class-based-react-component-f0cb800a8aca?source=collection_archive---------3-----------------------#2020-08-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/9ce84da788f741bf64f4281d7efddeca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9Mliiczk8XV3XSRgDmUOMg.png"/></div></div></figure><h1 id="b99c" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">更新生命周期</h1><p id="e61c" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">上一篇文章是关于基于类的组件在创建时的生命周期挂钩。在本文中，我们将看到当一个基于类的组件被更新时，钩子开始发挥作用。</p><h1 id="67b5" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">组件何时更新？</h1><p id="6af9" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">当组件的属性或状态发生变化时，组件被更新。发生这种情况时，组件将被重新评估，并经历与创建生命周期不同的生命周期。</p><h2 id="9409" class="lx kc it bd kd ly lz dn kh ma mb dp kl lk mc md kp lo me mf kt ls mg mh kx mi bi translated">1.getDerivedStateFromProps</h2><p id="8a15" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">因为这个钩子给我们的状态来自于props的变化，所以它是组件更新时调用的第一个生命周期钩子。</p><p id="0109" class="pw-post-body-paragraph kz la it lb b lc mj le lf lg mk li lj lk ml lm ln lo mm lq lr ls mn lu lv lw im bi translated">它检查是否对道具进行了任何改变，并从这些改变中导出新的状态。就像在创建生命周期中一样，这种生命周期挂钩很少是必要的，因为很可能会有更好的解决方案。</p><h2 id="b0a7" class="lx kc it bd kd ly lz dn kh ma mb dp kl lk mc md kp lo me mf kt ls mg mh kx mi bi translated">2.shouldComponentUpdate</h2><p id="81b7" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">这个生命周期钩子在<em class="mo"> getDerivedStateFromProps </em>之后和<em class="mo"> render </em>函数之前被调用，并允许我们<strong class="lb iu">取消</strong>更新过程。它可以用来让React知道组件的状态或属性的变化是否会影响组件的输出。为了优化性能，我们可以决定React是否应该继续更新和重新呈现组件。</p><p id="f373" class="pw-post-body-paragraph kz la it lb b lc mj le lf lg mk li lj lk ml lm ln lo mm lq lr ls mn lu lv lw im bi translated">默认情况下，组件将在每次状态改变时重新呈现，但是使用这个钩子，我们可以防止不必要的重新呈现。这使得这个钩子非常强大，因为我们可以避免不必要的渲染循环。但是，如果做得不正确，我们可能会阻止更新并破坏组件。</p><p id="31ad" class="pw-post-body-paragraph kz la it lb b lc mj le lf lg mk li lj lk ml lm ln lo mm lq lr ls mn lu lv lw im bi translated"><a class="ae mp" href="https://reactjs.org/docs/react-component.html#shouldcomponentupdate" rel="noopener ugc nofollow" target="_blank"> React docs </a>推荐使用<code class="fe mq mr ms mt b">PureComponent</code>如果你不确定手动实现<em class="mo">shouldcomponentdupdate</em>。</p><h2 id="5c17" class="lx kc it bd kd ly lz dn kh ma mb dp kl lk mc md kp lo me mf kt ls mg mh kx mi bi translated">3.提供；给予</h2><p id="0b0f" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">接下来是<em class="mo">渲染</em>功能。如果<em class="mo"> shouldComponentUpdate </em>返回false，这意味着组件应该<strong class="lb iu">而不是</strong>更新，则不调用渲染函数。</p><p id="c55f" class="pw-post-body-paragraph kz la it lb b lc mj le lf lg mk li lj lk ml lm ln lo mm lq lr ls mn lu lv lw im bi translated">在创建生命周期中，render函数评估所有JSX，并将组件呈现到DOM中。然而，在更新生命周期中，在评估JSX之后，render函数构造虚拟DOM并检查它是否需要更新真实DOM。如果需要更新，它不是更新整个DOM，而是比较虚拟DOM和真实DOM，只对需要更新的部分进行修改。</p><p id="83b8" class="pw-post-body-paragraph kz la it lb b lc mj le lf lg mk li lj lk ml lm ln lo mm lq lr ls mn lu lv lw im bi translated">这意味着改变按钮的颜色只会更新该按钮，而不是整个页面。</p><h2 id="65e9" class="lx kc it bd kd ly lz dn kh ma mb dp kl lk mc md kp lo me mf kt ls mg mh kx mi bi translated">4.getSnapshotBeforeUpdate</h2><p id="6413" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">尽管<em class="mo">getsnapshotbeforedupdate</em>出现在React组件的更新生命周期中的render函数之后，但它是在任何更新实际提交到真正的DOM之前被调用的。这也是一个不常使用的生命周期挂钩，主要用于最后的操作，比如在更新之前从DOM中捕获一些信息。</p><p id="6fc1" class="pw-post-body-paragraph kz la it lb b lc mj le lf lg mk li lj lk ml lm ln lo mm lq lr ls mn lu lv lw im bi translated">这个钩子接收以前的状态和属性作为参数，并且可以返回一个快照对象或null。这个钩子的一个用例是在DOM更新之前捕获页面上的滚动位置，并将当前的滚动位置设置为那个值。这将确保即使在DOM重新呈现后，滚动位置也保持不变。</p><p id="4da1" class="pw-post-body-paragraph kz la it lb b lc mj le lf lg mk li lj lk ml lm ln lo mm lq lr ls mn lu lv lw im bi translated">由<em class="mo">getsnapshotbeforupdate</em>返回的任何值都作为参数传递给<em class="mo"> componentDidUpdate </em>。</p><h2 id="ab9d" class="lx kc it bd kd ly lz dn kh ma mb dp kl lk mc md kp lo me mf kt ls mg mh kx mi bi translated">5.componentDidUpdate</h2><p id="4aa1" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">这个钩子在<em class="mo"> render </em>函数执行完毕并且DOM更新后被调用。这个钩子不是在页面初始呈现时调用，而是在组件更新时调用。</p><p id="280f" class="pw-post-body-paragraph kz la it lb b lc mj le lf lg mk li lj lk ml lm ln lo mm lq lr ls mn lu lv lw im bi translated">像执行HTTP请求这样的异步任务可以在这个钩子中完成。虽然在这个钩子中更新状态不会阻止更新过程，因为渲染已经完成，但是我们仍然需要小心，因为我们可能会陷入重新渲染的无限循环中。</p><p id="d96b" class="pw-post-body-paragraph kz la it lb b lc mj le lf lg mk li lj lk ml lm ln lo mm lq lr ls mn lu lv lw im bi translated">如果您需要更新状态，请确保在承诺中使用<em class="mo"> setState() </em>，以避免导致不必要的重新呈现。虽然这种重新渲染不会导致任何可见的更改，但仍会影响组件的性能。</p><p id="5064" class="pw-post-body-paragraph kz la it lb b lc mj le lf lg mk li lj lk ml lm ln lo mm lq lr ls mn lu lv lw im bi translated">这个钩子将组件更新之前的状态和属性作为参数。可以将先前的属性与当前的属性进行比较，以检查如果属性已经改变，是否有必要执行网络请求。如果您的组件实现了很少使用的<em class="mo">getsnapshotbeforupdate()</em>生命周期钩子，那么<em class="mo"> componentDidUpdate() </em>将接收第三个参数— <strong class="lb iu">快照</strong>。如果<em class="mo">getsnapshotbefore update()</em>没有实现，第三个参数将是未定义的。</p><blockquote class="mu mv mw"><p id="7b90" class="kz la mo lb b lc mj le lf lg mk li lj mx ml lm ln my mm lq lr mz mn lu lv lw im bi translated">注意:如果<code class="fe mq mr ms mt b">shouldComponentUpdate()</code>返回false，<code class="fe mq mr ms mt b">componentDidUpdate()</code>将不会被调用</p></blockquote><h1 id="e154" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">包扎</h1><p id="e252" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">当一个组件经历一次更新时，这些是被调用的生命周期钩子。在下一篇文章中，我们将看到<em class="mo"> useEffect </em>钩子，它可以用在功能组件中来代替这些生命周期钩子。</p></div><div class="ab cl na nb hx nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="im in io ip iq"><p id="dd4f" class="pw-post-body-paragraph kz la it lb b lc mj le lf lg mk li lj lk ml lm ln lo mm lq lr ls mn lu lv lw im bi translated"><em class="mo">原载于</em> <a class="ae mp" href="https://niharraoteblog.netlify.app/update-lifecycle-of-a-react-component" rel="noopener ugc nofollow" target="_blank"> <em class="mo">我的博客</em> </a> <em class="mo">。</em></p></div></div>    
</body>
</html>