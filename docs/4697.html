<html>
<head>
<title>“Serverless plugin”: KEDA for scaling down your containers to zero</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">“无服务器插件”:KEDA缩小你的容器到零</h1>
<blockquote>原文：<a href="https://itnext.io/serverless-keda-for-scaling-down-your-containers-to-zero-5bf35a75072c?source=collection_archive---------3-----------------------#2020-08-25">https://itnext.io/serverless-keda-for-scaling-down-your-containers-to-zero-5bf35a75072c?source=collection_archive---------3-----------------------#2020-08-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="6623" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用autoscaler最大限度地降低您的容器基础设施成本</h2></div><p id="7741" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我简要描述了什么是无服务器，以及如何将容器缩减到零。这包括库伯内特，KEDA，卡夫卡，Dapr。</p><h1 id="979f" class="lb lc iq bd ld le lf lg lh li lj lk ll jw lm jx ln jz lo ka lp kc lq kd lr ls bi translated">问题:我如何降低成本？</h1><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi lt"><img src="../Images/fb59600fa442efa66e090ca3a87e08c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zZEejy-IDt1sPJijkqmo5Q.png"/></div></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">所有的应用程序都需要每次运行。我们应该关掉开关。</figcaption></figure><p id="432f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我的痛点很简单。这是关于如何降低我的基础设施成本。我将在基础设施上放置许多应用程序。但是没有必要一直运行应用程序。我希望我的应用程序仅在需要时运行。即使如此，我也不能一直关注这些应用程序的每一个请求…当不需要的时候，我该如何关闭我的应用程序呢？</p><h1 id="42c4" class="lb lc iq bd ld le lf lg lh li lj lk ll jw lm jx ln jz lo ka lp kc lq kd lr ls bi translated">解决方案:“无服务器”，更具体地说是“自动缩放”</h1><h2 id="69b6" class="mj lc iq bd ld mk ml dn lh mm mn dp ll ko mo mp ln ks mq mr lp kw ms mt lr mu bi translated">“无服务器”一体式机型(作为学习的第一步)</h2><p id="f1d8" class="pw-post-body-paragraph kf kg iq kh b ki mv jr kk kl mw ju kn ko mx kq kr ks my ku kv kw mz ky kz la ij bi translated">我认为无服务器是这个问题的最后手段。无服务器的先驱，AWS说；</p><blockquote class="na nb nc"><p id="91ad" class="kf kg nd kh b ki kj jr kk kl km ju kn ne kp kq kr nf kt ku kv ng kx ky kz la ij bi translated">它消除了基础架构管理任务，如服务器或群集配置、修补、操作系统维护和容量配置。</p></blockquote><p id="d434" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">简而言之，无服务器意味着<strong class="kh ir">“服务器维护”——少了</strong>。其实还有服务器。服务器永远不会消失。应用程序运行在服务器上。消失的是维护劳动。在无服务器环境中，应用程序开发人员不需要考虑服务器维护，可以专注于开发。</p><p id="7eb8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Serverless只是一个形容词，所以这个词本身并没有提到任何具体的软件、硬件或厂商。</p><p id="f4f5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">AWS lambda是公共云中的无服务器应用平台之一。AWS lambda拥有<a class="ae nh" href="https://docs.aws.amazon.com/lambda/latest/dg/invocation-scaling.html" rel="noopener ugc nofollow" target="_blank">扩展应用的原始机制</a>来增加并发性。上次调用后10分钟，AWS lambda的资源回收(应用程序停止)根据<a class="ae nh" href="https://mikhail.io/serverless/coldstarts/aws/" rel="noopener ugc nofollow" target="_blank">这篇文章</a>自动发生。</p><p id="3778" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当然，还存在其他实现方式。我们可以在本地使用<strong class="kh ir">无服务器应用平台</strong>。例如，<em class="nd"> OpenFaaS </em>、<em class="nd">open whish</em>和<em class="nd"> kubeless </em>都是在内部环境中运行应用的无服务器应用平台。他们在一个平台中提供一体化堆栈。</p><h2 id="e444" class="mj lc iq bd ld mk ml dn lh mm mn dp ll ko mo mp ln ks mq mr lp kw ms mt lr mu bi translated">更深一步的“无服务器”:关键是“自动缩放”</h2><p id="8ae1" class="pw-post-body-paragraph kf kg iq kh b ki mv jr kk kl mw ju kn ko mx kq kr ks my ku kv kw mz ky kz la ij bi translated">深入“无服务器”内部。当我们尝试“无服务器”的自助堆栈时，最简单的方法是使用<strong class="kh ir">容器和Kubernetes </strong>。这些是软件堆栈的构建模块。容器用于应用程序的维护自动化。Kubernetes用于协调多个容器和多个服务器。</p><p id="6e5c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在容器技术和Kubernetes之上，<strong class="kh ir"> autoscaler </strong>来了。Kubernetes推出HPA(卧式容器自动秤)等容器自动秤非常重要。当工作负载增加时，Kubernetes会检测到并自动增加容器数量。这是迈向无服务器世界的惊人一步。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi ni"><img src="../Images/e754905f0ed0c81430601641d29b992b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2WD89PLelVJffYPlQcrBVQ.png"/></div></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">Autoscaler监视事件和指标。自动缩放控制放大或缩小。</figcaption></figure><p id="8b2e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">嵌入在Kubernetes中的autoscaler的限制是它不能处理向下到零的缩放。这意味着，即使工作负载非常低并且暂时接近零请求，Kubernetes也不能杀死最后一个容器。换句话说，只要容器的数量在1到N的范围内，Kubernetes本身就可以扩大和缩小容器部署，但是它不能将容器部署缩小到零。这是缺失的部分。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi nj"><img src="../Images/39c3d256ef74fb7ed1b7b7ffee819944.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/1*XOm6nM7TaCg5xXFuqHbaTA.png"/></div></div></figure><p id="0a37" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">新的其他自动缩放器可以处理这种情况“缩小到零”。这些自动缩放器充当Kubernetes的助手插件。如果一定时间过去了，没有请求，定标器检测到它，杀死最后一个容器。</p><h2 id="7943" class="mj lc iq bd ld mk ml dn lh mm mn dp ll ko mo mp ln ks mq mr lp kw ms mt lr mu bi translated">自动缩放1 : Knative</h2><p id="be48" class="pw-post-body-paragraph kf kg iq kh b ki mv jr kk kl mw ju kn ko mx kq kr ks my ku kv kw mz ky kz la ij bi translated">Knative是Kuberntes世界中scaler的前沿。当Knative在零容器状态下检测到传入请求时，Knative自动将请求保存在一种路由器中，并启动新的容器。非常聪明。Knative具有网络路由器功能，可以监视请求包和目标地址。</p><h2 id="8ff5" class="mj lc iq bd ld mk ml dn lh mm mn dp ll ko mo mp ln ks mq mr lp kw ms mt lr mu bi translated">自动缩放器2: KEDA</h2><p id="8332" class="pw-post-body-paragraph kf kg iq kh b ki mv jr kk kl mw ju kn ko mx kq kr ks my ku kv kw mz ky kz la ij bi translated">KEDA是同一案件的另一个光明的希望。KEDA也支持“缩减至零”。KEDA观察像Apache Kafka这样的许多服务，并检测这些服务中的变化(例如，Kafka主题中是否有新的请求在排队。)</p><h2 id="2691" class="mj lc iq bd ld mk ml dn lh mm mn dp ll ko mo mp ln ks mq mr lp kw ms mt lr mu bi translated">定标器的比较:Knative和KEDA</h2><p id="52f8" class="pw-post-body-paragraph kf kg iq kh b ki mv jr kk kl mw ju kn ko mx kq kr ks my ku kv kw mz ky kz la ij bi translated">Knative和KEDA的区别在于如何检测传入的请求。Knative是非常面向网络的架构。另一方面，KEDA不太依赖网络。相反，KEDA只是依赖其他服务，如阿帕奇卡夫卡。这意味着KEDA的重量更轻。</p><h1 id="74a8" class="lb lc iq bd ld le lf lg lh li lj lk ll jw lm jx ln jz lo ka lp kc lq kd lr ls bi translated">让我们试着把KEDA缩小到零吧！</h1><p id="fc6a" class="pw-post-body-paragraph kf kg iq kh b ki mv jr kk kl mw ju kn ko mx kq kr ks my ku kv kw mz ky kz la ij bi translated">在这篇文章中，我采用Kubernetes为基础，KEDA为自动缩放。我确认KEDA意识到缩小到零。</p><h2 id="23ee" class="mj lc iq bd ld mk ml dn lh mm mn dp ll ko mo mp ln ks mq mr lp kw ms mt lr mu bi translated">KEDA情景</h2><p id="848d" class="pw-post-body-paragraph kf kg iq kh b ki mv jr kk kl mw ju kn ko mx kq kr ks my ku kv kw mz ky kz la ij bi translated">这次我使用发布/订阅采样系统作为自动缩放的目标。该系统有两个应用程序，一个是发送消息的发布者，另一个是接收消息的订阅者。该示例还将Apache Kafka作为发布者和订阅者之间的消息队列。</p><p id="d74d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个系统中，KEDA控制用户容器的数量。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi nk"><img src="../Images/ea7901ea60c50306a9b8900206c9737e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZKE53zjiQZBgNvq5ci0fmg.png"/></div></div></figure><p id="25cc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">KEDA在阿帕奇卡夫卡的一个特定主题(=频道)中观看到来的消息。当一些消息到达主题时，KEDA唤醒Kubernetes上指定为“deploymentName”的目标部署。当在指定为“冷却时间”的冷却时间内没有消息时，KEDA将订户应用程序中的容器号(副本)减少到零。最后，Kubernetes杀死所有运行的容器。</p><h2 id="54cc" class="mj lc iq bd ld mk ml dn lh mm mn dp ll ko mo mp ln ks mq mr lp kw ms mt lr mu bi translated">用善良创造库伯内特</h2><p id="243a" class="pw-post-body-paragraph kf kg iq kh b ki mv jr kk kl mw ju kn ko mx kq kr ks my ku kv kw mz ky kz la ij bi translated">首先，我准备了Kubernetes集群。kind是Kubernetes集群构建器。</p><pre class="lu lv lw lx gt nl nm nn no aw np bi"><span id="0622" class="mj lc iq nm b gy nq nr l ns nt">kind create cluster --name serverless --config kind-config.yaml</span></pre><p id="8987" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe nu nv nw nm b">kind-config.yaml</code>中，我添加了唯一的端口配置，用于稍后在Kubernetes外部公开publisher应用程序。</p><pre class="lu lv lw lx gt nl nm nn no aw np bi"><span id="bfd4" class="mj lc iq nm b gy nq nr l ns nt">kind: Cluster<br/>apiVersion: kind.x-k8s.io/v1alpha4<br/>nodes:<br/>- role: control-plane<br/>  kubeadmConfigPatches:<br/>  - |<br/>    kind: InitConfiguration<br/>    nodeRegistration:<br/>      kubeletExtraArgs:<br/>        node-labels: "ingress-ready=true"<br/>  extraPortMappings:<br/>  - containerPort: 80<br/>    hostPort: 31502<br/>    protocol: TCP<br/>  - containerPort: 443<br/>    hostPort: 31503<br/>    protocol: TCP</span></pre><h2 id="f096" class="mj lc iq bd ld mk ml dn lh mm mn dp ll ko mo mp ln ks mq mr lp kw ms mt lr mu bi translated">在Kubernetes集群上安装KEDA</h2><p id="cf69" class="pw-post-body-paragraph kf kg iq kh b ki mv jr kk kl mw ju kn ko mx kq kr ks my ku kv kw mz ky kz la ij bi translated">这是开球的时间。KEDA安装超级容易。创建一个名称空间<code class="fe nu nv nw nm b">keda</code>，在名称空间中安装KEDA的头盔包。</p><pre class="lu lv lw lx gt nl nm nn no aw np bi"><span id="7547" class="mj lc iq nm b gy nq nr l ns nt">helm repo add kedacore https://kedacore.github.io/charts<br/>kubectl create namespace keda  <br/>helm install keda kedacore/keda --namespace keda</span></pre><h2 id="e6a2" class="mj lc iq bd ld mk ml dn lh mm mn dp ll ko mo mp ln ks mq mr lp kw ms mt lr mu bi translated">安装示例应用程序和Dapr</h2><p id="b3fe" class="pw-post-body-paragraph kf kg iq kh b ki mv jr kk kl mw ju kn ko mx kq kr ks my ku kv kw mz ky kz la ij bi translated">我使用了来自Dapr存储库(应用程序之间的消息传递工具)的示例发布/订阅应用程序。这个例子有非常有用的容器图像。我用这个样本进行KEDA缩放测试。</p><p id="9a92" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在Kubernetes上安装dapr就像在KEDA一样简单。只需运行一个舵命令。</p><pre class="lu lv lw lx gt nl nm nn no aw np bi"><span id="34c5" class="mj lc iq nm b gy nq nr l ns nt">helm repo add dapr <a class="ae nh" href="https://daprio.azurecr.io/helm/v1/repo" rel="noopener ugc nofollow" target="_blank">https://daprio.azurecr.io/helm/v1/repo</a><br/>kubectl create namespace dapr-system<br/>helm install dapr dapr/dapr --namespace dapr-system</span></pre><p id="88cd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">安装Apache Kafka作为发布者和订阅者之间的排队系统。</p><pre class="lu lv lw lx gt nl nm nn no aw np bi"><span id="8b0e" class="mj lc iq nm b gy nq nr l ns nt">helm install my-kafka incubator/kafka</span></pre><p id="87e3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我安装了订阅者和发布者应用程序。</p><p id="2cfb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是publisher应用程序部署<code class="fe nu nv nw nm b">node-subscriber.yaml</code></p><pre class="lu lv lw lx gt nl nm nn no aw np bi"><span id="6365" class="mj lc iq nm b gy nq nr l ns nt">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: node-subscriber<br/>  labels:<br/>    app: node-subscriber<br/>spec:<br/>  # replicas: 1<br/>  selector:<br/>    matchLabels:<br/>      app: node-subscriber<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: node-subscriber<br/>      annotations:<br/>        dapr.io/enabled: "true"<br/>        dapr.io/app-id: "node-subscriber"<br/>        dapr.io/app-port: "3000"<br/>    spec:<br/>      containers:<br/>      - name: node-subscriber<br/>        image: dapriosamples/pubsub-node-subscriber:0.10.0<br/>        ports:<br/>        - containerPort: 3000<br/>        imagePullPolicy: Always</span></pre><p id="face" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是发布者应用部署<code class="fe nu nv nw nm b">react-publisher.yaml</code></p><pre class="lu lv lw lx gt nl nm nn no aw np bi"><span id="d37c" class="mj lc iq nm b gy nq nr l ns nt">kind: Service<br/>apiVersion: v1<br/>metadata:<br/>  name: react-form<br/>  labels:<br/>    app: react-form<br/>spec:<br/>  selector:<br/>    app: react-form<br/>  ports:<br/>  - protocol: TCP<br/>    port: 80<br/>    targetPort: 8080<br/>  type: ClusterIP</span><span id="47ce" class="mj lc iq nm b gy nx nr l ns nt">---<br/>apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: react-form<br/>  labels:<br/>    app: react-form<br/>spec:<br/>  replicas: 1<br/>  selector:<br/>    matchLabels:<br/>      app: react-form<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: react-form<br/>      annotations:<br/>        dapr.io/enabled: "true"<br/>        dapr.io/app-id: "react-form"<br/>        dapr.io/app-port: "8080"<br/>    spec:<br/>      containers:<br/>      - name: react-form<br/>        image: dapriosamples/pubsub-react-form:0.10.0<br/>        ports:<br/>        - containerPort: 8080<br/>        imagePullPolicy: Always</span></pre><p id="ff82" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些应用程序与下列Dapr对象相关联。Dapr将来自发布者的消息数据存储到Apache Kafka部署<code class="fe nu nv nw nm b">my-kafka</code>中。</p><pre class="lu lv lw lx gt nl nm nn no aw np bi"><span id="6f39" class="mj lc iq nm b gy nq nr l ns nt">apiVersion: dapr.io/v1alpha1<br/>kind: Component<br/>metadata:<br/>  name: pubsub<br/>spec:<br/>  type: pubsub.kafka<br/>  metadata:<br/>    - name: brokers<br/>      value: "<strong class="nm ir">my-kafka.default.svc.cluster.local:9092</strong>"<br/>    - name: authRequired<br/>      value: "false"</span></pre><p id="e068" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">到目前为止，发布/订阅应用程序应该可以正常运行。</p><p id="202f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我添加了以下KEDA对象来自动缩小规模。</p><pre class="lu lv lw lx gt nl nm nn no aw np bi"><span id="dc21" class="mj lc iq nm b gy nq nr l ns nt">apiVersion: keda.k8s.io/v1alpha1<br/>kind: ScaledObject<br/>metadata:<br/>  name: kafka-scaler<br/>  namespace: default<br/>  labels:<br/>    deploymentName: node-subscriber<br/>spec:<br/>  scaleTargetRef:<br/>    deploymentName: <strong class="nm ir">node-subscriber</strong><br/>  minReplicaCount: 0<br/>  cooldownPeriod:  <strong class="nm ir">10</strong><br/>  pollingInterval: <strong class="nm ir">30</strong><br/>  triggers:<br/>  - type: kafka<br/>    metadata:<br/>      topic: <strong class="nm ir">A</strong><br/>      bootstrapServers:  <strong class="nm ir">my-kafka.default.svc.cluster.local:9092</strong><br/>      consumerGroup: node-subscriber<br/>      lagThreshold: '1'</span></pre><p id="039e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此<code class="fe nu nv nw nm b">ScaledObject</code>监视ub/sub使用的<code class="fe nu nv nw nm b">my-kafka</code>服务中的主题<code class="fe nu nv nw nm b">A</code>和上面描述的<code class="fe nu nv nw nm b">node-subscriber</code>的kick scaling。冷却时间是<code class="fe nu nv nw nm b">10s</code>。</p><p id="2398" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我确认了publisher应用程序容器和Kafka容器正在<code class="fe nu nv nw nm b">default</code>名称空间中运行。看起来没有订户申请。没错。当KEDA初始化<code class="fe nu nv nw nm b">ScaledObject</code>时，<code class="fe nu nv nw nm b">deploymentName</code>中指定的展开总是设置为零作为初始状态。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi ny"><img src="../Images/a2e69382e4d077c9879929c2fb4a3288.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OjHHpRzkxTDkhsaYdJeRrQ.png"/></div></div></figure><p id="7d73" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">证据可以在部署中找到。部署<code class="fe nu nv nw nm b">node-subscriber</code>实际存在。但是<code class="fe nu nv nw nm b">replicas</code>被设置为零。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi nz"><img src="../Images/6838c395886b1037cd13ede2e464631e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bZl14NjuQ5s-3o89Mm91HQ.png"/></div></div></figure><h2 id="f3fe" class="mj lc iq bd ld mk ml dn lh mm mn dp ll ko mo mp ln ks mq mr lp kw ms mt lr mu bi translated">向订阅者应用程序发送事件</h2><p id="a63a" class="pw-post-body-paragraph kf kg iq kh b ki mv jr kk kl mw ju kn ko mx kq kr ks my ku kv kw mz ky kz la ij bi translated">让我们在publisher应用程序中发送消息。</p><p id="721b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从浏览器访问publisher应用程序。在下面的文本框中放一条随机消息并发送消息。如果KEDA正常工作，您可以仅通过这一步启动订户。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi oa"><img src="../Images/01b1b67e05616e53ee61ef2ab181e0a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-hzA7ZdCSOeVgqxczB_3AQ.png"/></div></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">按“提交”向订户发送消息</figcaption></figure><h2 id="1a6d" class="mj lc iq bd ld mk ml dn lh mm mn dp ll ko mo mp ln ks mq mr lp kw ms mt lr mu bi translated">观察订户的缩小和扩大</h2><pre class="lu lv lw lx gt nl nm nn no aw np bi"><span id="51e4" class="mj lc iq nm b gy nq nr l ns nt">kubectl get pod -w</span></pre><p id="b89c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在发送消息后的30秒内，我观看了上述命令的结果。我确认<code class="fe nu nv nw nm b">node-subscriber</code>应用程序自动启动，并在30秒后自动终止🍻</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi ob"><img src="../Images/77880595dc87d9c6db9d0d72b2d13e1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zi5-8g8zzGeR7_pnOF9R0w.png"/></div></div></figure><p id="0728" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在容器日志中，<code class="fe nu nv nw nm b">node-subscriber</code>应用程序成功获取了从<code class="fe nu nv nw nm b">react-publisher</code>发送的消息。🥳</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi oc"><img src="../Images/165e191edfdb49b25427f693acff7937.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H3RdxcwBjkr93_zFHprKTA.png"/></div></div></figure><p id="7e36" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个可行性检查中，我通过观察Apache Kafka事件流确认了KEDA自动启动并终止了容器。👍</p><p id="0624" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我在这里分享了这个完整的样本<a class="ae nh" href="https://github.com/onelittlenightmusic/keda-dapr-scaling-sample" rel="noopener ugc nofollow" target="_blank">(github)</a>。</p><h2 id="7adf" class="mj lc iq bd ld mk ml dn lh mm mn dp ll ko mo mp ln ks mq mr lp kw ms mt lr mu bi translated">我尝试过的其他挑战(但失败了)</h2><p id="76bb" class="pw-post-body-paragraph kf kg iq kh b ki mv jr kk kl mw ju kn ko mx kq kr ks my ku kv kw mz ky kz la ij bi translated">我先尝试了Knative和Dapr样本，但是试验最终失败了。简单地说，Dapr和Knative并不是很好的组合，因为它们都想通过创建自己的sidecars和服务来控制网络。这是因为Knative在零容器状态期间使用类似Istio的服务网格作为消息传输。</p><h1 id="a5bd" class="lb lc iq bd ld le lf lg lh li lj lk ll jw lm jx ln jz lo ka lp kc lq kd lr ls bi translated">摘要:KEDA是简单而强大的自动缩放器</h1><p id="5bd4" class="pw-post-body-paragraph kf kg iq kh b ki mv jr kk kl mw ju kn ko mx kq kr ks my ku kv kw mz ky kz la ij bi translated">我谈到了我的应用程序维护问题。“无服务器”是一个很有前途的概念，但实现是多种多样的。在现有的实现中，我选择了自己动手堆栈和KEDA作为自动缩放器。通过示例发布/订阅应用程序，我确认了KEDA观察像Apache Kafka这样的排队系统，并从1到0或从0到1改变部署规模。参数是可定制的，KEDA支持除阿帕奇卡夫卡之外的许多<a class="ae nh" href="https://keda.sh/docs/1.5/scalers/" rel="noopener ugc nofollow" target="_blank">缩放器</a>。这么简单又百搭。不像Knative，KEDA可能不支持在线HTTP请求…但是如果我们的目标是发布/订阅类型的应用，KEDA是最有前途的自动缩放器。享受自动缩放！在没有服务器的世界里自由飞翔。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi od"><img src="../Images/bfad67502e92db3697f9f70ac06e143f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3pmRllA-6FjU4XYk"/></div></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">照片由<a class="ae nh" href="https://unsplash.com/@rodlong?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">杆长</a>在<a class="ae nh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="583e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">感谢<a class="ae nh" href="https://app.slack.com/team/UNBV55YKU" rel="noopener ugc nofollow" target="_blank"> Zbynek Roubalik </a> @ redhat对Kubernetes #keda slack频道的建议。</p></div></div>    
</body>
</html>