<html>
<head>
<title>React/Redux API Loading &amp; Errors</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应/减少API加载和错误</h1>
<blockquote>原文：<a href="https://itnext.io/react-redux-api-loading-errors-e783972c5424?source=collection_archive---------2-----------------------#2019-10-01">https://itnext.io/react-redux-api-loading-errors-e783972c5424?source=collection_archive---------2-----------------------#2019-10-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b645" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">管理API请求状态并妥善处理错误</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/433b0c6d8336e81991071539de049346.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jQ_VoSRY0IQ_PcyrPm0kKA.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">威尔·斯图尔特在<a class="ae ky" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="b696" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将向您展示我如何在全局范围内处理API请求和API错误的加载指示器，如果需要的话，特别是针对一个视图。我将使用<strong class="lb iu"> React/Redux </strong>，但是你可以在其他应用程序设置中使用这些想法。我们将涵盖:</p><blockquote class="lv lw lx"><p id="a396" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated"><strong class="lb iu">加载指示器</strong>(概述)<br/> <strong class="lb iu">错误管理</strong>(概述)</p><p id="5a97" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated"><strong class="lb iu">API请求动作的约定</strong></p><p id="a3d1" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated"><strong class="lb iu">加载指示器</strong>(深入)<br/> <strong class="lb iu">错误管理</strong>(深入)</p></blockquote><p id="b720" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这篇文章是一篇更大的文章<a class="ae ky" href="https://medium.com/@robertsavian/my-awesome-react-redux-structure-6044e5007e22" rel="noopener">我的牛逼React/Redux结构</a>的一部分。在那篇文章中，我有一个<a class="ae ky" href="https://codebelt.github.io/react-redux-architecture/" rel="noopener ugc nofollow" target="_blank">示例应用程序</a>，它使用了下面描述的这些技术。查看源代码示例:</p><ul class=""><li id="e886" class="mc md it lb b lc ld lf lg li me lm mf lq mg lu mh mi mj mk bi translated"><a class="ae ky" href="https://github.com/codeBelt/react-redux-architecture/tree/TypeScript" rel="noopener ugc nofollow" target="_blank"> React/Redux(类型脚本—类)</a></li><li id="80ba" class="mc md it lb b lc ml lf mm li mn lm mo lq mp lu mh mi mj mk bi translated"><a class="ae ky" href="https://github.com/codeBelt/react-redux-architecture/tree/JavaScript" rel="noopener ugc nofollow" target="_blank">React/Redux(JavaScript-Classes)</a></li><li id="98e9" class="mc md it lb b lc ml lf mm li mn lm mo lq mp lu mh mi mj mk bi translated"><a class="ae ky" href="https://github.com/codeBelt/react-redux-architecture/tree/ts/function" rel="noopener ugc nofollow" target="_blank">React Hooks/Redux(TypeScript-Functional)</a></li><li id="cde5" class="mc md it lb b lc ml lf mm li mn lm mo lq mp lu mh mi mj mk bi translated"><a class="ae ky" href="https://github.com/codeBelt/react-redux-architecture/tree/js/function" rel="noopener ugc nofollow" target="_blank">React Hooks/Redux(JavaScript-Functional)</a></li></ul></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><h1 id="9a1a" class="mx my it bd mz na nb nc nd ne nf ng nh jz ni ka nj kc nk kd nl kf nm kg nn no bi translated">装载指示器(概述)</h1><p id="1f12" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">让我们直接向您展示这个约定/模式在您的视图中是如何工作的。看下面<code class="fe nu nv nw nx b">mapStateToProps</code>内的<code class="fe nu nv nw nx b">selectRequesting</code>。我正在使用<a class="ae ky" href="https://github.com/reduxjs/reselect" rel="noopener ugc nofollow" target="_blank">重新选择</a>来创建一个选择器，以从<a class="ae ky" href="https://github.com/reduxjs/redux" rel="noopener ugc nofollow" target="_blank"> Redux </a>存储中计算出<code class="fe nu nv nw nx b">ShowsAction.<strong class="lb iu">REQUEST_SHOW</strong></code>动作类型是否已经被分派<em class="ly">(开始)</em>或者伴随的<code class="fe nu nv nw nx b">ShowsAction.<strong class="lb iu">REQUEST_SHOW_FINISHED</strong></code>动作类型是否已经被分派<em class="ly">(结束)</em>。我们以<code class="fe nu nv nw nx b">isRequesting</code>成为<code class="fe nu nv nw nx b">true</code>或<code class="fe nu nv nw nx b">false</code>而告终。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">请求选择器示例</figcaption></figure><p id="dab3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意<code class="fe nu nv nw nx b">selectRequesting</code>是如何接受一个数组的，这样你就可以指定一个或多个动作类型，并且只在所有动作完成后显示/移除加载指示器。如果你想更细化，你可以有一个<code class="fe nu nv nw nx b">isRequestingShow</code>、<code class="fe nu nv nw nx b">isRequestingActors</code>等等。</p></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><h1 id="686e" class="mx my it bd mz na nb nc nd ne nf ng nh jz ni ka nj kc nk kd nl kf nm kg nn no bi translated"><strong class="ak">API请求动作的约定</strong></h1><p id="14b7" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">下面的约定/模式是我如何管理API请求的加载和错误逻辑。</p><p id="b377" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">任何以<code class="fe nu nv nw nx b">REQUEST_</code>开头的动作类型都是开始动作:</p><pre class="kj kk kl km gt oa nx ob oc aw od bi"><span id="ff64" class="oe my it nx b gy of og l oh oi"><strong class="nx iu">SomeAction.<em class="ly">REQUEST_SOMETHING</em></strong></span></pre><p id="b289" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，如果任何以<code class="fe nu nv nw nx b">REQUEST_</code>开始并以<code class="fe nu nv nw nx b">_FINISHED</code>结束的动作类型是已完成的动作:</p><pre class="kj kk kl km gt oa nx ob oc aw od bi"><span id="bfd8" class="oe my it nx b gy of og l oh oi"><strong class="nx iu">SomeAction.<em class="ly">REQUEST_SOMETHING_FINISHED</em></strong></span></pre><p id="d175" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样，您可以创建逻辑来确定动作的加载状态是<code class="fe nu nv nw nx b">true</code>还是<code class="fe nu nv nw nx b">false</code>。我使用的是<a class="ae ky" href="https://github.com/acdlite/flux-standard-action" rel="noopener ugc nofollow" target="_blank">通量标准动作</a>模式，该模式有一个<code class="fe nu nv nw nx b">error</code>属性，可以设置为<code class="fe nu nv nw nx b">true</code>或<code class="fe nu nv nw nx b">false</code>。这允许我们在操作完成或重新启动时显示或删除错误消息。下面是一个动作的<a class="ae ky" href="https://github.com/acdlite/flux-standard-action" rel="noopener ugc nofollow" target="_blank">通量标准动作</a>模式的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">通量标准动作示例</figcaption></figure><p id="5452" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用这种模式，一个动作不能包含除了<code class="fe nu nv nw nx b">type</code>、<code class="fe nu nv nw nx b">payload</code>、<code class="fe nu nv nw nx b">error</code>和<code class="fe nu nv nw nx b">meta</code>之外的属性，因此您的所有动作都是一致的和可预测的。</p><p id="5f4b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我向您展示实现这一切的代码之前，让我们来看看如何在同一个视图中显示错误。</p></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><h1 id="d6ac" class="mx my it bd mz na nb nc nd ne nf ng nh jz ni ka nj kc nk kd nl kf nm kg nn no bi translated">错误管理(概述)</h1><p id="430a" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">类似于上面的<code class="fe nu nv nw nx b">selectRequesting</code> <a class="ae ky" href="https://github.com/reduxjs/reselect" rel="noopener ugc nofollow" target="_blank">重新选择</a>选择器，我有几个选择器来处理错误。下面你可以看到我在<code class="fe nu nv nw nx b">mapStateToProps</code>中添加了一个<code class="fe nu nv nw nx b">requestErrorText</code>，但是我也有一个<code class="fe nu nv nw nx b">hasErrors</code>和<code class="fe nu nv nw nx b">selectRawErrors</code>选择器，我可以在不同的情况下使用它们。现在我们可以检查并显示错误消息(如果存在的话)。“所有错误”选择接受一组操作类型，因此如果需要，您可以检查多个操作类型。需要指出的一点是，对于错误，你使用以<code class="fe nu nv nw nx b">_FINISHED</code>结尾的动作类型，而对于加载状态，<strong class="lb iu">不是</strong>必须以<code class="fe nu nv nw nx b">_FINISHED</code>结尾。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">错误选择器示例</figcaption></figure></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><h1 id="b9cc" class="mx my it bd mz na nb nc nd ne nf ng nh jz ni ka nj kc nk kd nl kf nm kg nn no bi translated"><strong class="ak">加载状态</strong>(深入)</h1><h2 id="6221" class="oe my it bd mz oj ok dn nd ol om dp nh li on oo nj lm op oq nl lq or os nn ot bi translated">行动</h2><p id="d0c2" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">如上所述，这一切都归结到如何命名的行动类型。</p><p id="e199" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的<code class="fe nu nv nw nx b">ShowsAction</code>正在使用<a class="ae ky" href="https://github.com/reduxjs/redux-thunk" rel="noopener ugc nofollow" target="_blank"> Redux-Thunk </a>，它允许我们调度多个动作。通过下面的序列，我们可以知道一个API何时开始，何时结束:</p><ul class=""><li id="ab11" class="mc md it lb b lc ld lf lg li me lm mf lq mg lu mh mi mj mk bi translated"><strong class="lb iu">第8行:</strong>发出启动动作<code class="fe nu nv nw nx b"><strong class="lb iu">REQUEST_</strong>SHOW</code></li><li id="c937" class="mc md it lb b lc ml lf mm li mn lm mo lq mp lu mh mi mj mk bi translated"><strong class="lb iu">第10行:</strong>触发API请求<code class="fe nu nv nw nx b">ShowsEffect.<strong class="lb iu">requestShow(74)</strong></code></li><li id="08ec" class="mc md it lb b lc ml lf mm li mn lm mo lq mp lu mh mi mj mk bi translated"><strong class="lb iu">第13行:</strong>发出一个完成动作<code class="fe nu nv nw nx b"><strong class="lb iu">REQUEST_</strong>SHOW<strong class="lb iu">_FINISHED</strong></code></li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">带有Thunk示例的操作</figcaption></figure><h2 id="a983" class="oe my it bd mz oj ok dn nd ol om dp nh li on oo nj lm op oq nl lq or os nn ot bi translated">请求减速器</h2><p id="c31a" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">减速器做了大部分工作。看看下面的文件，我会一行一行地描述正在发生的事情。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">请求减速器示例</figcaption></figure><ul class=""><li id="289e" class="mc md it lb b lc ld lf lg li me lm mf lq mg lu mh mi mj mk bi translated"><strong class="lb iu">第6行:</strong>检查动作上的<code class="fe nu nv nw nx b">type</code>属性，查看字符串值是否包含<code class="fe nu nv nw nx b">REQUEST_</code>字符串。</li><li id="e231" class="mc md it lb b lc ml lf mm li mn lm mo lq mp lu mh mi mj mk bi translated"><strong class="lb iu">第8行:</strong>如果<code class="fe nu nv nw nx b">isRequestType</code>为真，我们可以假设<code class="fe nu nv nw nx b">type</code>是开始<code class="fe nu nv nw nx b">REQUEST_*</code>或完成<code class="fe nu nv nw nx b">REQUEST_*_FINISHED</code>请求动作。如果不是，我们返回<code class="fe nu nv nw nx b">state</code>不要用减速器<code class="fe nu nv nw nx b">state</code>改变任何东西。</li><li id="12df" class="mc md it lb b lc ml lf mm li mn lm mo lq mp lu mh mi mj mk bi translated"><strong class="lb iu">第13行:</strong>从动作类型中删除字符串<code class="fe nu nv nw nx b">_FINISHED</code>。这意味着<code class="fe nu nv nw nx b">requestName</code>将永远是<code class="fe nu nv nw nx b">REQUEST_*</code>。我们保留它，这样我们就可以将它用作第24行的<strong class="lb iu">对象键。</strong></li><li id="e856" class="mc md it lb b lc ml lf mm li mn lm mo lq mp lu mh mi mj mk bi translated"><strong class="lb iu">第20行:</strong>检查动作的<code class="fe nu nv nw nx b">type</code>属性，查看字符串值是否包含<code class="fe nu nv nw nx b">_FINISHED</code>字符串。</li><li id="4d71" class="mc md it lb b lc ml lf mm li mn lm mo lq mp lu mh mi mj mk bi translated"><strong class="lb iu">第24行:</strong>添加<code class="fe nu nv nw nx b">requestName</code>作为减速器<code class="fe nu nv nw nx b">state</code>的键，如果<code class="fe nu nv nw nx b">type</code>包含<code class="fe nu nv nw nx b">_FINISHED</code>字符串，则设置<strong class="lb iu">真</strong>值，否则设置<strong class="lb iu">假</strong>。下面是减速器<code class="fe nu nv nw nx b">state</code>的样件:</li></ul><pre class="kj kk kl km gt oa nx ob oc aw od bi"><span id="e4b7" class="oe my it nx b gy of og l oh oi">{<br/>  'ShowsAction.REQUEST_SHOW': true,<br/>  'ShowsAction.REQUEST_EPISODES': false,<br/>}</span></pre><h2 id="3423" class="oe my it bd mz oj ok dn nd ol om dp nh li on oo nj lm op oq nl lq or os nn ot bi translated">请求选择器</h2><p id="aacd" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">现在我们知道了<code class="fe nu nv nw nx b">RequestingReducer</code>是如何工作的，我们可以创建一个<a class="ae ky" href="https://github.com/reduxjs/reselect" rel="noopener ugc nofollow" target="_blank">重选</a>选择器来检查任何启动请求动作类型的<code class="fe nu nv nw nx b">RequestingReducer</code>状态，如下所示:</p><pre class="kj kk kl km gt oa nx ob oc aw od bi"><span id="4a33" class="oe my it nx b gy of og l oh oi"><strong class="nx iu"><em class="ly">selectRequesting</em>(</strong>state, [ShowsAction.<strong class="nx iu"><em class="ly">REQUEST_SHOW</em></strong>]<strong class="nx iu">)</strong></span></pre><p id="9881" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">查看下面的第5行,我们可以看到选择器循环遍历我们传入的动作类型数组，并使用<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some" rel="noopener ugc nofollow" target="_blank"> some </a>方法来确定数组中的任何项目是否有值为<strong class="lb iu"> true </strong>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">请求选择器示例</figcaption></figure><p id="4fe7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就这样，现在我们可以通过请求动作来管理我们的加载状态。</p></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><h1 id="d1d1" class="mx my it bd mz na nb nc nd ne nf ng nh jz ni ka nj kc nk kd nl kf nm kg nn no bi translated"><strong class="ak">错误管理</strong>(深入)</h1><p id="4db2" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">我建议从示例<a class="ae ky" href="https://github.com/codeBelt/react-redux-architecture" rel="noopener ugc nofollow" target="_blank">源代码</a>中寻找，但是我所有的操作都与处理API请求的“效果”文件(例如ShowsEffect)一起工作。效果要么返回预期的API数据，要么返回一个<code class="fe nu nv nw nx b">HttpErrorResponseModel</code>。如果你看下面的例子，你会看到<code class="fe nu nv nw nx b">model instanceof HttpErrorResponseModel</code>，它允许我们确定我们的系统是否从API请求返回一个错误。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">带有Thunk示例的操作</figcaption></figure><p id="1ce0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<a class="ae ky" href="https://github.com/acdlite/flux-standard-action" rel="noopener ugc nofollow" target="_blank">通量标准动作</a>模式，我们可以将错误属性设置为真，并将有效载荷属性分配给<code class="fe nu nv nw nx b">HttpErrorResponseModel</code>。</p><h2 id="f29d" class="oe my it bd mz oj ok dn nd ol om dp nh li on oo nj lm op oq nl lq or os nn ot bi translated">误差缩减器</h2><p id="421b" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">在我讨论<code class="fe nu nv nw nx b">ErrorReducer</code>之前，我想指出所有其他的reducers都不处理有错误的动作。只有<code class="fe nu nv nw nx b">ErrorReducer</code>处理来自API请求的错误。下面你可以看到我做了一个提前返回的减速器<code class="fe nu nv nw nx b">state</code>如果这个动作是错误的。</p><pre class="kj kk kl km gt oa nx ob oc aw od bi"><span id="e80c" class="oe my it nx b gy of og l oh oi">export default class ShowsReducer {<br/>  static <em class="ly">initialState </em>= {<br/>   ...<br/>  };<br/><br/>  static <strong class="nx iu"><em class="ly">reducer</em></strong>(state = ShowsReducer.<em class="ly">initialState</em>, action) {<br/><strong class="nx iu">    if (action.error) {<br/>      return state;<br/>    }</strong><br/><br/>    switch (action.type) {<br/>      ...<br/>    }<br/>  }<br/>}</span></pre><p id="2f82" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是<code class="fe nu nv nw nx b">ErrorReducer</code>，你可以阅读评论来了解发生了什么:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">ErrorReducer示例</figcaption></figure><h2 id="1774" class="oe my it bd mz oj ok dn nd ol om dp nh li on oo nj lm op oq nl lq or os nn ot bi translated">误差选择器</h2><p id="52e4" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">当使用一个<code class="fe nu nv nw nx b">ErrorSelector</code>方法时，你总是使用完成的动作类型<code class="fe nu nv nw nx b">(e.g. REQUEST_*_FINISHED)</code>，并且你可以使用一个或多个动作类型，因为选择器接受一个数组。下面你可以看到一个例子:</p><pre class="kj kk kl km gt oa nx ob oc aw od bi"><span id="1975" class="oe my it nx b gy of og l oh oi"><strong class="nx iu">selectErrorText(</strong>state, [ShowsAction.<strong class="nx iu"><em class="ly">REQUEST_SHOW_FINISHED</em></strong>]<strong class="nx iu">)</strong></span></pre><p id="39db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe nu nv nw nx b">ErrorSelector</code>中有三个选择器，它们是:</p><ul class=""><li id="983b" class="mc md it lb b lc ld lf lg li me lm mf lq mg lu mh mi mj mk bi translated"><strong class="lb iu">selectrawrors:</strong>从有错误的已完成动作类型中返回一个<code class="fe nu nv nw nx b">HttpErrorResponseModel</code>数组。</li><li id="6d5f" class="mc md it lb b lc ml lf mm li mn lm mo lq mp lu mh mi mj mk bi translated"><strong class="lb iu"> selectErrorText: </strong>从有错误的已完成操作类型中返回所有错误消息的字符串。</li><li id="f207" class="mc md it lb b lc ml lf mm li mn lm mo lq mp lu mh mi mj mk bi translated"><strong class="lb iu"> hasErrors: </strong>如果数组中某个已完成的动作类型有错误，则返回<strong class="lb iu"> true </strong>。否则将返回一个假值。</li></ul><p id="96b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以阅读评论来了解发生了什么:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">错误选择器示例</figcaption></figure></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><h1 id="a7c4" class="mx my it bd mz na nb nc nd ne nf ng nh jz ni ka nj kc nk kd nl kf nm kg nn no bi translated">感谢阅读！</h1><p id="e178" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">本质上，我们让归约器和选择器做所有的工作，把复杂的逻辑从视图中去掉。</p><p id="a3a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请查看我的相关文章:</p><div class="ou ov gp gr ow ox"><a href="https://medium.com/@robertsavian/my-awesome-react-redux-structure-6044e5007e22" rel="noopener follow" target="_blank"><div class="oy ab fo"><div class="oz ab pa cl cj pb"><h2 class="bd iu gy z fp pc fr fs pd fu fw is bi translated">我的超赞反应/还原结构</h2><div class="pe l"><h3 class="bd b gy z fp pc fr fs pd fu fw dk translated">在Redux中，是跟踪应用程序当前状态的单个对象。您使用减速器来管理…</h3></div><div class="pf l"><p class="bd b dl z fp pc fr fs pd fu fw dk translated">medium.com</p></div></div><div class="pg l"><div class="ph l pi pj pk pg pl ks ox"/></div></div></a></div><p id="ecef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你喜欢这篇文章，请分享它，关注我，阅读我的其他<a class="ae ky" href="https://medium.com/@robertsavian" rel="noopener">文章</a>和/或用我下面的推荐链接注册Medium。谢谢！</p><div class="ou ov gp gr ow ox"><a href="https://medium.com/@robertsavian/membership" rel="noopener follow" target="_blank"><div class="oy ab fo"><div class="oz ab pa cl cj pb"><h2 class="bd iu gy z fp pc fr fs pd fu fw is bi translated">通过我的推荐链接加入Medium—Robert S(代码带)</h2><div class="pe l"><h3 class="bd b gy z fp pc fr fs pd fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="pf l"><p class="bd b dl z fp pc fr fs pd fu fw dk translated">medium.com</p></div></div><div class="pg l"><div class="pm l pi pj pk pg pl ks ox"/></div></div></a></div></div></div>    
</body>
</html>