<html>
<head>
<title>How to profile Go applications inside a docker container</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在docker容器中分析Go应用程序</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-profile-go-applications-inside-a-docker-container-d29431fbb427?source=collection_archive---------5-----------------------#2019-12-12">https://itnext.io/how-to-profile-go-applications-inside-a-docker-container-d29431fbb427?source=collection_archive---------5-----------------------#2019-12-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><h1 id="d111" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">介绍</h1><p id="58a3" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在这篇文章中，我将简要介绍几种可以用来分析/调试docker容器中运行的Go应用程序的方法。为了更深入地了解这几种方法，我在文章末尾添加了源代码链接，您可以参考。我真的建议您阅读列出的源代码，并仔细阅读如何使用和解释创建的概要文件，以便调试/优化您的应用程序。这篇文章旨在帮助你在使用Docker容器运行Go应用程序时创建这些配置文件。主要思想是我们将利用由<code class="fe lj lk ll lm b">net/http</code>包提供的远程概要分析功能。</p><h1 id="bb51" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">应用</h1><p id="dadd" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我们将使用<code class="fe lj lk ll lm b">pprof</code>来分析您的Go应用程序，当您能够在本地访问应用程序的二进制文件时，您通常会使用<code class="fe lj lk ll lm b">pprof</code>。当你使用docker容器时，你需要在容器中安装<code class="fe lj lk ll lm b">go tool</code>来分析它。然而，还有另一种方法来分析docker容器中运行的Go应用程序。为此，我们需要创建一个HTTP web服务器，它将启用<code class="fe lj lk ll lm b">pprof</code> HTTP端点。从这些端点，我们能够下载正在运行的应用程序的配置文件。</p><p id="ebd8" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">所以首先我们需要创建一个HTTP web服务器，我们将在一个goroutine中运行它。然后我们可以导入<code class="fe lj lk ll lm b">net/http/pprof</code>包，它会自动启用我们创建的web服务器的<code class="fe lj lk ll lm b">pprof</code> HTTP端点，并且会在<code class="fe lj lk ll lm b">http://localhost:6060/debug/pprof</code> URL下安装处理程序。</p><p id="862c" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">因此，我们可以在代码中添加以下内容:</p><pre class="ls lt lu lv gt lw lm lx ly aw lz bi"><span id="f67d" class="ma jo iq lm b gy mb mc l md me">// main.go<br/>package main</span><span id="92cc" class="ma jo iq lm b gy mf mc l md me">import (<br/>    "fmt"<br/>    "math/rand"<br/>    "net/http"<br/>    "net/http/pprof"<br/>)</span><span id="fa43" class="ma jo iq lm b gy mf mc l md me">func main() {</span><span id="215f" class="ma jo iq lm b gy mf mc l md me">    // Add the following<br/>    go func() {<br/>        http.ListenAndServe(":6060", nil)<br/>    }()</span><span id="ba2e" class="ma jo iq lm b gy mf mc l md me">    // Some sample code<br/>    for {<br/>        n := rand.Intn(10) + 1<br/>        fmt.Printf("Fibonacci sequence for %d:\n", n)<br/>        for i := 1; i &lt;= n; i++ {<br/>            fmt.Println(fibonacci(i))<br/>        }<br/>    }<br/>}</span><span id="4405" class="ma jo iq lm b gy mf mc l md me">func fibonacci(n int) int {<br/>    if n &lt; 2 {<br/>        return n<br/>    }<br/>    return fibonacci(n-1) + fibonacci(n-2)<br/>}</span></pre><p id="0917" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">当您使用不同的路由器时，我们可以执行以下操作来使<code class="fe lj lk ll lm b">pprof</code> HTTP端点工作。下面是一个例子，如果你使用<a class="ae mg" href="https://github.com/gorilla/mux" rel="noopener ugc nofollow" target="_blank"> gorilla/mux </a>你会如何做</p><pre class="ls lt lu lv gt lw lm lx ly aw lz bi"><span id="3a65" class="ma jo iq lm b gy mb mc l md me">// main.go<br/>package main</span><span id="e231" class="ma jo iq lm b gy mf mc l md me">import (<br/>    _ "expvar"<br/>    "net/http"<br/>    "net/http/pprof"<br/>    _ "net/http/pprof"<br/>    <br/>    "github.com/gorilla/mux"<br/>)</span><span id="f5d2" class="ma jo iq lm b gy mf mc l md me">func main() {<br/>    router := mux.NewRouter()</span><span id="241d" class="ma jo iq lm b gy mf mc l md me">    router.HandleFunc(<br/>        "/debug/pprof/", pprof.Index,<br/>    )<br/>    router.HandleFunc(<br/>        "/debug/pprof/cmdline", pprof.Cmdline,<br/>    )<br/>    router.HandleFunc(<br/>        "/debug/pprof/profile", pprof.Profile,<br/>    )<br/>    router.HandleFunc(<br/>        "/debug/pprof/symbol", pprof.Symbol,<br/>    )<br/>    router.HandleFunc(<br/>        "/debug/pprof/trace", pprof.Trace,<br/>    )<br/>    router.Handle(<br/>        "/debug/pprof/goroutine", pprof.Handler("goroutine"),<br/>    )<br/>    router.Handle(<br/>        "/debug/pprof/heap", pprof.Handler("heap"),<br/>    )<br/>    router.Handle(<br/>        "/debug/pprof/threadcreate", pprof.Handler("threadcreate"),<br/>    )<br/>    router.Handle(<br/>        "/debug/pprof/block", pprof.Handler("block"),<br/>    )<br/>    router.Handle(<br/>        "/debug/vars", http.DefaultServeMux,<br/>    )</span><span id="5faa" class="ma jo iq lm b gy mf mc l md me">    http.ListenAndServe(":6060", router)<br/>}</span></pre><h1 id="2bf0" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">码头工人</h1><p id="0ae4" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">对于docker容器，我们将创建以下<code class="fe lj lk ll lm b">Dockerfile</code>:</p><pre class="ls lt lu lv gt lw lm lx ly aw lz bi"><span id="5f4b" class="ma jo iq lm b gy mb mc l md me"># Dockerfile<br/>FROM golang:1.13<br/><br/>WORKDIR /go/src/app<br/>COPY . .<br/><br/>RUN go get -d -v ./...<br/>RUN go install -v ./...<br/><br/>CMD ["app"]</span></pre><p id="1f86" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">接下来，我们可以构建并启动Docker容器:</p><pre class="ls lt lu lv gt lw lm lx ly aw lz bi"><span id="d1c6" class="ma jo iq lm b gy mb mc l md me">$ docker build -t pprof-app .<br/>$ docker run -p 6060:6060 -it --rm --name my-running-app pprof-app</span></pre><p id="3c0b" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">一旦您更新了文件，您将能够通过使用您的浏览器访问端点并转到<a class="ae mg" href="http://localhost:8888/tree" rel="noopener ugc nofollow" target="_blank">http://localhost:6060/debug/pprof/</a>，或者您可以使用<code class="fe lj lk ll lm b">go tool pprof</code>。我们将探索一些使用<code class="fe lj lk ll lm b">go tool pprof</code>分析应用程序的方法</p><h1 id="ef40" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">pprof</h1><p id="a3a5" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">现在，我们已经为使用<code class="fe lj lk ll lm b">pprof</code>做好了一切准备，我们将为cpu和heap分析我们的应用程序。此外，我们还将跟踪应用程序。</p><p id="cbe4" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated"><strong class="kn ir"> CPU </strong></p><p id="848d" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">当我们想要开始分析我们的应用程序以确定应用程序在哪里花费时间时，我们首先需要做一个CPU分析。我们有几种方法可以做到这一点。下面我就举几个常见的。它的要点是，我们通过HTTP在应用程序中创建的端点上获取配置文件。</p><ol class=""><li id="28b9" class="mh mi iq kn b ko ln ks lo kw mj la mk le ml li mm mn mo mp bi translated">转到<a class="ae mg" href="http://localhost:6060/debug/pprof/profile" rel="noopener ugc nofollow" target="_blank">http://localhost:6060/debug/pprof/profile</a>，30秒后你会自动下载这个概要文件，或者</li><li id="5d84" class="mh mi iq kn b ko mq ks mr kw ms la mt le mu li mm mn mo mp bi translated">使用<code class="fe lj lk ll lm b">go tool pprof</code>。它会告诉您配置文件存储在哪里，并会打开一个交互式终端，您可以使用它来解释结果。像这样:<code class="fe lj lk ll lm b">go tool pprof <a class="ae mg" href="http://localhost:6060/debug/pprof/profile" rel="noopener ugc nofollow" target="_blank">http://localhost:6060/debug/pprof/profile</a></code></li></ol><p id="b7a9" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">之后，我们可以解释结果，为此，我们再次有几个选项和工具，我们可以用来解释结果。你可以在我在帖子末尾的“来源”部分列出的网站上阅读更多关于解释结果的其他方法。</p><p id="935f" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">在这里，我将向你展示其中的几个。其中之一是我们能够在自动创建的web界面中检查结果。</p><pre class="ls lt lu lv gt lw lm lx ly aw lz bi"><span id="4a40" class="ma jo iq lm b gy mb mc l md me">$ go tool pprof -http=":8080" [path-to-profile-dump]</span></pre><p id="d1f5" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">这将打开一个网络浏览器，我们可以在其中检查，例如，所创建的配置文件的火焰图。</p><figure class="ls lt lu lv gt mw gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/4d1915bbd05ccc9b752590d603d07ca2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1348/format:webp/0*kd4fNkT9UFLtewhP.png"/></div></figure><p id="356e" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">横轴代表采集的样本总数。所以面积越大，执行相关功能花费的时间就越多。垂直轴表示调用堆栈的深度。所以峰值越高，调用栈越深。颜色不代表任何特定的东西；它们只是为了形成视觉对比。<a class="ae mg" href="#a60c" rel="noopener ugc nofollow"> </a></p><p id="a40f" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">另一种方法是我们可以通过使用<code class="fe lj lk ll lm b">go tool</code>来使用基于命令行的交互界面:</p><pre class="ls lt lu lv gt lw lm lx ly aw lz bi"><span id="561a" class="ma jo iq lm b gy mb mc l md me">$ go tool pprof [path-to-profile-dump]</span></pre><p id="abbd" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">我们还可以立即转到web界面，通过使用以下命令来单步执行整个下载配置文件步骤:</p><pre class="ls lt lu lv gt lw lm lx ly aw lz bi"><span id="d8ee" class="ma jo iq lm b gy mb mc l md me">$ go tool pprof \<br/>    -http=":8080" \<br/>    <a class="ae mg" href="http://localhost:6060/debug/pprof/profile" rel="noopener ugc nofollow" target="_blank">http://localhost:6060/debug/pprof/profil</a>e</span></pre><p id="329e" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">需要记住的一点是:如果你制作cpu概要文件需要一定的时间，你需要指定你的服务器能够处理那些长时间的请求。您通常希望将以下内容添加到您的<code class="fe lj lk ll lm b">http.Server</code>:</p><pre class="ls lt lu lv gt lw lm lx ly aw lz bi"><span id="d725" class="ma jo iq lm b gy mb mc l md me">srv := &amp;http.Server{<br/>     WriteTimeout: 30 * time.Second,<br/>}</span></pre><h1 id="c778" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">许多</h1><p id="8d1a" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">为了获得堆配置文件，以便我们可以检查应用程序的内存使用情况，我们可以再次发出以下命令:</p><ol class=""><li id="fc4c" class="mh mi iq kn b ko ln ks lo kw mj la mk le ml li mm mn mo mp bi translated">转到<a class="ae mg" href="http://localhost:6060/debug/pprof/heap" rel="noopener ugc nofollow" target="_blank">http://localhost:6060/debug/pprof/heap</a>，我们会自动下载堆概要文件，或者</li><li id="c207" class="mh mi iq kn b ko mq ks mr kw ms la mt le mu li mm mn mo mp bi translated">使用<code class="fe lj lk ll lm b">go tool</code>，它会告诉你配置文件存储在哪里，并打开一个交互式终端，你可以用它来解释结果:</li></ol><pre class="ls lt lu lv gt lw lm lx ly aw lz bi"><span id="9395" class="ma jo iq lm b gy mb mc l md me"># Heap profile<br/>#<br/># optional flags:<br/>#   –alloc_space tells you how many megabytes have been allocated.<br/>#   –inuse_space tells you know how many are still in use.<br/>$ go tool pprof http://localhost:6060/debug/pprof/heap</span></pre><p id="e429" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">而且，就像CPU配置文件一样，我们能够用<code class="fe lj lk ll lm b">go tool pprof</code>和web界面来解释它:</p><pre class="ls lt lu lv gt lw lm lx ly aw lz bi"><span id="aac0" class="ma jo iq lm b gy mb mc l md me"># Go tool<br/>$ go tool pprof [path-to-profile-dump]<br/><br/># Web interface<br/>$ go tool pprof -http=":8080" [path-to-profile-dump]<br/><br/># Create profile and start web interface<br/>$ go tool pprof -http=":8080" http://localhost:6060/debug/pprof/heap</span></pre><figure class="ls lt lu lv gt mw gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/9202eea417eb9edd3dd41ee37ad6832c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1348/format:webp/0*V13O2hFPr6nsgqta.png"/></div></figure><h1 id="ff55" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">找到；查出</h1><p id="6ddc" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">为了跟踪应用程序的运行时活动/事件，我们可以做以下事情。首先，我们需要下载跟踪文件，为此我们可以使用curl。指定要创建跟踪的秒数，并确保在该时间段内创建一些负载。下载完成后，您可以使用<code class="fe lj lk ll lm b">go tool</code>启动一个web界面，在其中您可以检查结果。</p><p id="78fe" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">跟踪工具将捕获执行事件，如创建、阻塞、解除阻塞goroutines、垃圾收集事件、处理器启动和停止、进入、退出和阻塞系统调用。<a class="ae mg" href="#a00a" rel="noopener ugc nofollow">T3】</a></p><p id="8deb" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">发出以下命令:</p><pre class="ls lt lu lv gt lw lm lx ly aw lz bi"><span id="f71f" class="ma jo iq lm b gy mb mc l md me">$ curl \<br/>    http://localhost:6060/debug/pprof/trace?seconds=20 &gt; \<br/>    trace.out<br/>$ go tool trace trace.out</span></pre><p id="5a8c" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">这将打开您的webbrowser，您将能够使用提供的web界面解释您的跟踪结果。</p><h1 id="c883" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">结论</h1><p id="1ef3" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我们已经探索了一些方法，当Go应用程序在Docker容器中运行时，这些方法允许我们分析它。还有很多信息可以帮助您使用这些方法优化应用程序。我在下面的“来源”一节中列出了其中的几个。一定要去看看他们，他们有一些很好的额外信息可以帮助你。</p><h1 id="5878" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">来源</h1><ul class=""><li id="628d" class="mh mi iq kn b ko kp ks kt kw mz la na le nb li nc mn mo mp bi translated"><a class="ae mg" href="https://golang.org/doc/diagnostics.html" rel="noopener ugc nofollow" target="_blank"> golang.org:诊断学</a></li><li id="5e92" class="mh mi iq kn b ko mq ks mr kw ms la mt le mu li nc mn mo mp bi translated"><a class="ae mg" href="https://golang.org/pkg/runtime/pprof/" rel="noopener ugc nofollow" target="_blank">golang . org:Package runtime/pprof</a></li><li id="a359" class="mh mi iq kn b ko mq ks mr kw ms la mt le mu li nc mn mo mp bi translated"><a class="ae mg" href="https://golang.org/pkg/net/http/pprof/" rel="noopener ugc nofollow" target="_blank">golang . org:Package net/http/pprof</a></li><li id="bf73" class="mh mi iq kn b ko mq ks mr kw ms la mt le mu li nc mn mo mp bi translated"><a class="ae mg" href="https://blog.golang.org/profiling-go-programs" rel="noopener ugc nofollow" target="_blank"> golang.org:剖析围棋程序</a></li><li id="0fce" class="mh mi iq kn b ko mq ks mr kw ms la mt le mu li nc mn mo mp bi translated"><a class="ae mg" href="https://github.com/google/pprof/blob/master/doc/README.md" rel="noopener ugc nofollow" target="_blank"> github.com: Go工具pprof </a></li><li id="12d0" class="mh mi iq kn b ko mq ks mr kw ms la mt le mu li nc mn mo mp bi translated"><a class="ae mg" href="https://jvns.ca/blog/2017/09/24/profiling-go-with-pprof/" rel="noopener ugc nofollow" target="_blank">朱莉娅·埃文斯:剖析与pprof一起走</a></li><li id="cd22" class="mh mi iq kn b ko mq ks mr kw ms la mt le mu li nc mn mo mp bi translated"><a class="ae mg" href="https://gist.github.com/Jimmy-Xu/85fb01cd7620454c6d65" rel="noopener ugc nofollow" target="_blank">docker守护进程中的Jimmy-Xu:pprof</a></li><li id="b3bd" class="mh mi iq kn b ko mq ks mr kw ms la mt le mu li nc mn mo mp bi translated"><a class="ae mg" href="https://about.sourcegraph.com/go/an-introduction-to-go-tool-trace-rhys-hiltner" rel="noopener ugc nofollow" target="_blank">Rhys hilt ner:go工具跟踪简介</a></li><li id="1a47" class="mh mi iq kn b ko mq ks mr kw ms la mt le mu li nc mn mo mp bi translated">里斯·希尔特纳:围棋执行追踪(youtube) </li><li id="0076" class="mh mi iq kn b ko mq ks mr kw ms la mt le mu li nc mn mo mp bi translated"><a class="ae mg" href="http://blog.ralch.com/tutorial/golang-performance-and-memory-analysis/" rel="noopener ugc nofollow" target="_blank">Svet Ralchev:Golang程序的性能和内存分析</a></li><li id="dbf0" class="mh mi iq kn b ko mq ks mr kw ms la mt le mu li nc mn mo mp bi translated"><a class="ae mg" href="https://github.com/bradfitz/talk-yapc-asia-2015/blob/master/talk.md" rel="noopener ugc nofollow" target="_blank"> Brad Fritzpatrick:剖析&amp;在Go中优化</a></li><li id="2de6" class="mh mi iq kn b ko mq ks mr kw ms la mt le mu li nc mn mo mp bi translated"><a class="ae mg" href="https://making.pusher.com/go-tool-trace/" rel="noopener ugc nofollow" target="_blank">威尔·休厄尔:去工具追踪</a></li></ul></div><div class="ab cl nd ne hu nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ij ik il im in"><ol class=""><li id="a60c" class="mh mi iq kn b ko ln ks lo kw mj la mk le ml li mm mn mo mp bi translated">【http://www.brendangregg.com/flamegraphs.html T4】</li><li id="a00a" class="mh mi iq kn b ko mq ks mr kw ms la mt le mu li mm mn mo mp bi translated"><a class="ae mg" href="https://golang.org/doc/diagnostics.html" rel="noopener ugc nofollow" target="_blank">https://golang.org/doc/diagnostics.html</a></li></ol></div><div class="ab cl nd ne hu nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ij ik il im in"><p id="acc0" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated"><em class="nk">最初发表于</em><a class="ae mg" href="https://bruinsslot.jp/post/profiling-golang-docker-2" rel="noopener ugc nofollow" target="_blank"><em class="nk">https://bruinsslot.jp/post/profiling-golang-docker-2</em></a></p></div></div>    
</body>
</html>