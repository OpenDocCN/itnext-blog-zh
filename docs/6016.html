<html>
<head>
<title>Sticky Load Balancing in Docker Swarm using public Play-with-Docker Playground</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Docker群中使用公共Play-with-Docker操场的粘性负载均衡</h1>
<blockquote>原文：<a href="https://itnext.io/sticky-load-balancing-in-docker-swarm-using-public-play-with-docker-playground-9899548365ed?source=collection_archive---------1-----------------------#2021-07-25">https://itnext.io/sticky-load-balancing-in-docker-swarm-using-public-play-with-docker-playground-9899548365ed?source=collection_archive---------1-----------------------#2021-07-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="cc08" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用HAProxy在docker swarm中设置定制负载平衡的实践演示</h2></div></div><div class="ab cl kf kg hu kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="ij ik il im in"><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/55af796a50486c8f490265b171b3ed10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*otjalo_AmPaxPMJ7uPRdiw.png"/></div></div></figure></div><div class="ab cl kf kg hu kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="ij ik il im in"><h1 id="bcb4" class="ky kz iq bd la lb lc ld le lf lg lh li jw lj jx lk jz ll ka lm kc ln kd lo lp bi translated">介绍</h1><p id="4036" class="pw-post-body-paragraph lq lr iq ls b lt lu jr lv lw lx ju ly lz ma mb mc md me mf mg mh mi mj mk ml ij bi translated">现代的<strong class="ls ir">基于微服务的网络应用</strong>通常被设计成<strong class="ls ir">无状态</strong>以便于<strong class="ls ir">水平扩展</strong>以适应流量负载。然而，许多web应用程序将状态信息存储在会话对象中，例如由唯一的JSESSIONID标识的Java会话。</p><p id="99d6" class="pw-post-body-paragraph lq lr iq ls b lt mm jr lv lw mn ju ly lz mo mb mc md mp mf mg mh mq mj mk ml ij bi translated">当只有一个应用服务器实例，并且不涉及负载平衡器时，根本不存在任何问题，因为单个应用服务器知道所有用户的会话信息。相比之下，当使用几个横向扩展的应用服务器时，会发生用户向不知道其会话的服务器发送请求的情况。</p><p id="8042" class="pw-post-body-paragraph lq lr iq ls b lt mm jr lv lw mn ju ly lz mo mb mc md mp mf mg mh mq mj mk ml ij bi translated">通常这个问题是通过<strong class="ls ir">中央会话存储</strong>解决的，存储后端可能是一个数据库或<strong class="ls ir">内存中的数据存储，如Redis </strong>。然而，在现有的复杂系统中实现这样的解决方案，除了提供数据库或健壮的redis存储之外，需要在所有会话处理器中进行调整，以使用中央会话存储，这通常不是大问题。</p><p id="dfd4" class="pw-post-body-paragraph lq lr iq ls b lt mm jr lv lw mn ju ly lz mo mb mc md mp mf mg mh mq mj mk ml ij bi translated">如果没有时间或预算在架构中集成中央会话存储解决方案，该怎么办？那么，接下来就要找到一个基于粘性负载平衡的<strong class="ls ir">替代DevOps解决方案</strong>。</p><p id="a691" class="pw-post-body-paragraph lq lr iq ls b lt mm jr lv lw mn ju ly lz mo mb mc md mp mf mg mh mq mj mk ml ij bi translated">在本文中，我们将在基于Docker Swarm的容器平台中使用HAProxy检查<strong class="ls ir">粘性负载平衡的解决方案。</strong></p></div><div class="ab cl kf kg hu kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="ij ik il im in"><h1 id="f88d" class="ky kz iq bd la lb lc ld le lf lg lh li jw lj jx lk jz ll ka lm kc ln kd lo lp bi translated"><strong class="ak">为什么是HAProxy？</strong></h1><p id="eb09" class="pw-post-body-paragraph lq lr iq ls b lt lu jr lv lw lx ju ly lz ma mb mc md me mf mg mh mi mj mk ml ij bi translated">正如我们所知，每个<a class="ae mr" href="https://docs.docker.com/engine/swarm/" rel="noopener ugc nofollow" target="_blank"> <strong class="ls ir"> docker群</strong> </a> <strong class="ls ir">服务都使用docker的内部DNS组件作为其副本任务</strong>的负载平衡器。可惜的是，<strong class="ls ir">只有用Docker Enterprise </strong>版才有官方的方式实现<strong class="ls ir">粘性负载均衡</strong>，否则<strong class="ls ir">默认策略就是循环调度</strong>。另一种可能性是使用<a class="ae mr" href="https://traefik.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ls ir"> Traefik </strong> </a>，它提供了配置粘性会话的功能，但我发现后端服务的<strong class="ls ir">私有IP地址包含在Traefik </strong>创建的coockie中，该地址可能会被修改和滥用，以向基础架构内的非预期后端服务发送请求。</p></div><div class="ab cl kf kg hu kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="ij ik il im in"><h1 id="9edc" class="ky kz iq bd la lb lc ld le lf lg lh li jw lj jx lk jz ll ka lm kc ln kd lo lp bi translated">让我们把手弄脏吧！</h1><p id="d5b9" class="pw-post-body-paragraph lq lr iq ls b lt lu jr lv lw lx ju ly lz ma mb mc md me mf mg mh mi mj mk ml ij bi translated">您可以在<code class="fe ms mt mu mv b"><a class="ae mr" href="https://labs.play-with-docker.com" rel="noopener ugc nofollow" target="_blank">https://labs.play-with-docker.com/</a></code>使用<strong class="ls ir">公共可访问码头游乐场</strong>来跟随示例。检查位于<code class="fe ms mt mu mv b"><a class="ae mr" href="https://github.com/yandok/docker-swarm-sticky-load-balancing" rel="noopener ugc nofollow" target="_blank">https://github.com/yandok/docker-swarm-sticky-load-balancing.git</a></code>的<strong class="ls ir"> github-repository </strong>，它包含指令和<strong class="ls ir"> docker栈</strong>——我们将用来部署我们的演示的文件。</p></div><div class="ab cl kf kg hu kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="ij ik il im in"><h2 id="c751" class="mw kz iq bd la mx my dn le mz na dp li lz nb nc lk md nd ne lm mh nf ng lo nh bi translated">1.初始化Docker集群</h2><ul class=""><li id="26ce" class="ni nj iq ls b lt lu lw lx lz nk md nl mh nm ml nn no np nq bi translated">如果你还没有<strong class="ls ir"> Docker-ID </strong>，在<code class="fe ms mt mu mv b"><a class="ae mr" href="https://hub.docker.com/singup" rel="noopener ugc nofollow" target="_blank">https://hub.docker.com/signup</a></code>注册，你将需要它才能使用免费的Docker游乐场。</li><li id="195d" class="ni nj iq ls b lt nr lw ns lz nt md nu mh nv ml nn no np nq bi translated">登录<strong class="ls ir"> docker playground </strong>，点击左侧面板上的“添加新实例”按钮，添加3个新实例，然后您应该会看到如下视图:</li></ul><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi nw"><img src="../Images/da5963fd6c6bfb35dfe2050308e3ebe7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1wvifLwXjhzbBDuOQYVT9A.png"/></div></div><figcaption class="nx ny gj gh gi nz oa bd b be z dk translated">Docker游乐场-添加3个新实例后的视图</figcaption></figure><ul class=""><li id="4b63" class="ni nj iq ls b lt mm lw mn lz ob md oc mh od ml nn no np nq bi translated">选择左侧面板上的<code class="fe ms mt mu mv b">node1</code>，使用<code class="fe ms mt mu mv b">docker swarm init --advertise-addr $(hostname -i)</code>初始化群组主节点。这将生成一个输出，其中包含作为工作者节点加入群的命令。</li></ul><pre class="kn ko kp kq gt oe mv of og aw oh bi"><span id="4ec0" class="mw kz iq mv b gy oi oj l ok ol">docker swarm init --advertise-addr $(hostname -i)<br/>Swarm initialized: current node (uwkrx412ir5z4tf2kvq6iecjk) is now a manager.</span><span id="c080" class="mw kz iq mv b gy om oj l ok ol">To add a worker to this swarm, run the following command:</span><span id="9036" class="mw kz iq mv b gy om oj l ok ol"><strong class="mv ir">docker swarm join --token SWMTKN-1-0fic14zxca3jtvhe8smgkxj23j9liudtrrzcg3lnw0btt6jx32-40ua7piw3ydimqgkbwic0n2qp 192.168.0.8:2377</strong></span><span id="3f72" class="mw kz iq mv b gy om oj l ok ol">To add a manager to this swarm, run 'docker swarm join-token manager' and follow the instructions.</span></pre><ul class=""><li id="798a" class="ni nj iq ls b lt mm lw mn lz ob md oc mh od ml nn no np nq bi translated">复制该命令，并在另外两个节点上执行。您现在应该有一个初始化的docker-swarm集群，由1个主节点和2个工作节点组成。通过在<code class="fe ms mt mu mv b">node1</code>上输入<code class="fe ms mt mu mv b">docker node ls</code>进行验证。</li></ul><pre class="kn ko kp kq gt oe mv of og aw oh bi"><span id="02ae" class="mw kz iq mv b gy oi oj l ok ol">$ docker node ls<br/>ID                            HOSTNAME   STATUS    AVAILABILITY   MANAGER STATUS   ENGINE VERSION<br/>ymf3ja7z1j5kvksb362vgefms *   node1      Ready     Active         Leader           20.10.0<br/>d9z62lmzc0x3n030hanspyuog     node2      Ready     Active                          20.10.0<br/>owq20hfiyjy65um3dm05hmemb     node3      Ready     Active                          20.10.0</span></pre><h2 id="ab8d" class="mw kz iq bd la mx my dn le mz na dp li lz nb nc lk md nd ne lm mh nf ng lo nh bi translated">2.部署具有循环负载平衡的HAProxy反向代理</h2><ul class=""><li id="68aa" class="ni nj iq ls b lt lu lw lx lz nk md nl mh nm ml nn no np nq bi translated">为了部署我们的HAProxy和后端容器，我们需要一个<strong class="ls ir"> docker覆盖网络</strong>来连接容器。与<strong class="ls ir">桥接网络</strong>相反，桥接网络允许容器在同一主机上通信<strong class="ls ir">(当使用<strong class="ls ir"> docker-compose </strong>时的网络类型)——<strong class="ls ir">覆盖网络</strong>用于docker群集群中，以允许容器<strong class="ls ir">在多个节点</strong>上通信。通过在<code class="fe ms mt mu mv b">node1</code>上发出<code class="fe ms mt mu mv b">docker network create haproxy-network -d overlay --attachable</code>命令来完成。我们使用<code class="fe ms mt mu mv b">-attachable</code>标志，让我们在创建后将独立的docker-containers连接到网络，例如，为了使用<code class="fe ms mt mu mv b"><a class="ae mr" href="https://hub.docker.com/r/nicolaka/netshoot" rel="noopener ugc nofollow" target="_blank">nicolaka/netshoot</a></code>-image调试/排除网络连接故障。通过<code class="fe ms mt mu mv b">docker network ls</code>验证网络已经创建。</strong></li></ul><pre class="kn ko kp kq gt oe mv of og aw oh bi"><span id="2aee" class="mw kz iq mv b gy oi oj l ok ol">$ docker network ls<br/>NETWORK ID     NAME              DRIVER    SCOPE<br/>7273aed117f7   bridge            bridge    local<br/>34c6ebc38466   docker_gwbridge   bridge    local<br/>l2ubmbc3l6my   haproxy-network   overlay   swarm<br/>66fec54a258d   host              host      local<br/>wguoc8osl8q0   ingress           overlay   swarm<br/>097ffdd6bf11   none              null      local</span></pre><ul class=""><li id="4804" class="ni nj iq ls b lt mm lw mn lz ob md oc mh od ml nn no np nq bi translated">在<code class="fe ms mt mu mv b">node1</code>上部署一个haproxy-service，在端口<code class="fe ms mt mu mv b">10087</code>的节点上公开haproxy-listener-port。我们将使用docker-stack和haproxy-configuration定义的git-repository的<code class="fe ms mt mu mv b">02-Load-Balancing/01-roundrobin</code>目录，其中包含以下文件:</li></ul><pre class="kn ko kp kq gt oe mv of og aw oh bi"><span id="9e42" class="mw kz iq mv b gy oi oj l ok ol">02-Load-Balancing/01-roundrobin/<br/>├── deploy-infra.yml<br/>├── deploy-web.yml<br/>└── haproxy.cfg</span></pre><p id="2023" class="pw-post-body-paragraph lq lr iq ls b lt mm jr lv lw mn ju ly lz mo mb mc md mp mf mg mh mq mj mk ml ij bi translated">让我们快速浏览一下:</p><p id="1be8" class="pw-post-body-paragraph lq lr iq ls b lt mm jr lv lw mn ju ly lz mo mb mc md mp mf mg mh mq mj mk ml ij bi translated"><strong class="ls ir"><em class="on">deploy-infra . yml</em></strong></p><pre class="kn ko kp kq gt oe mv of og aw oh bi"><span id="d271" class="mw kz iq mv b gy oi oj l ok ol">version: "3.6"<br/><br/>x-default-deploy: &amp;default-deploy<br/>  replicas: 1<br/>  update_config:<br/>    parallelism: 1<br/>    delay: 10s<br/>    order: stop-first<br/><br/>services:<br/>  haproxy-service:<br/>    image: haproxytech/haproxy-debian:latest<br/>    deploy:<br/>      &lt;&lt;: *default-deploy<br/>      replicas: 1<br/><strong class="mv ir">      placement:<br/>        constraints: [node.hostname == node1]</strong><br/>      resources:<br/>        reservations:<br/>          memory: 512m<br/>        limits:<br/>          memory: 512m<br/>    logging:<br/>      options:<br/>        max-file: 3<br/>        max-size: 10m<br/>    dns: 127.0.0.11<br/><strong class="mv ir">    networks:<br/>      - haproxy-network<br/>    ports:<br/>      - target: 80<br/>        published: 10087<br/>        protocol: tcp<br/>        mode: host</strong><br/>    configs:<br/>      - source: haproxy_config<br/>        target: /etc/haproxy/haproxy.cfg<br/>        mode: 0444<br/><br/>networks:<br/>  haproxy-network:<br/>    name:  haproxy-network<br/>    external: true<br/><br/>configs:<br/>  <em class="on"># ROUNDROBIN<br/>  </em>haproxy_config:<br/>    file: ./haproxy.cfg</span></pre><ul class=""><li id="8442" class="ni nj iq ls b lt mm lw mn lz ob md oc mh od ml nn no np nq bi translated">为了确保haproxy-service被安排在<code class="fe ms mt mu mv b">node1</code>上，我们使用了一个位置约束——我们在主机(mode: host)的端口10087上发布haproxy-listener-port 80，并将服务附加到<code class="fe ms mt mu mv b">haproxy-network</code>。</li></ul><p id="45d3" class="pw-post-body-paragraph lq lr iq ls b lt mm jr lv lw mn ju ly lz mo mb mc md mp mf mg mh mq mj mk ml ij bi translated"><strong class="ls ir"> <em class="on"> haproxy.cfg </em> </strong></p><pre class="kn ko kp kq gt oe mv of og aw oh bi"><span id="fb2d" class="mw kz iq mv b gy oi oj l ok ol">global<br/>    log         fd@2 local2<br/>    chroot      /var/lib/haproxy<br/>    pidfile     /var/run/haproxy.pid<br/>    maxconn     4000<br/>    user        haproxy<br/>    group       haproxy<br/>    stats socket /var/lib/haproxy/stats expose-fd listeners<br/>    master-worker<br/><br/>resolvers docker<br/>    <strong class="mv ir">nameserver dns1 127.0.0.11:53</strong><br/>    resolve_retries 3<br/>    timeout resolve 1s<br/>    timeout retry   1s<br/>    hold other      10s<br/>    hold refused    10s<br/>    hold nx         10s<br/>    hold timeout    10s<br/>    hold valid      10s<br/>    hold obsolete   10s<br/><br/>defaults<br/>    timeout connect 10s<br/>    timeout client 30s<br/>    timeout server 120s<br/>    log global<br/>    mode http<br/>    option forwardfor<br/><br/>frontend  fe_web<br/>    bind *:80<br/><br/>    acl host_main hdr(host) -i &lt;host-node1&gt;-10087.direct.labs.play-with-docker.com<br/><br/>    use_backend stat if { path -i /my-stats }<br/><br/>    use_backend be_whoami_service if host_main<br/><br/><br/><strong class="mv ir">backend be_whoami_service<br/>    balance roundrobin<br/>    server-template whoami 5 tasks.whoami:80 check resolvers docker       init-addr none</strong><br/><br/><br/>backend stat<br/>    stats enable<br/>    stats uri /my-stats<br/>    stats refresh 5s<br/>    stats show-legends<br/>    stats show-node</span></pre><ul class=""><li id="65e0" class="ni nj iq ls b lt mm lw mn lz ob md oc mh od ml nn no np nq bi translated">haproxy配置包含端口80上的监听器和后端服务的定义<code class="fe ms mt mu mv b">be_whoami_service</code>。HAProxy使用<code class="fe ms mt mu mv b">server-template</code> —指令和docker-internal DNS-server 127 . 0 . 0 . 11动态解析haproxy-service的任务。</li><li id="edbf" class="ni nj iq ls b lt nr lw ns lz nt md nu mh nv ml nn no np nq bi translated">确保将<code class="fe ms mt mu mv b">haproxy.cfg</code>的<code class="fe ms mt mu mv b">host_main</code>的acl中的域名适配到您的docker-playground-host的自动生成的主机url。</li></ul><p id="9157" class="pw-post-body-paragraph lq lr iq ls b lt mm jr lv lw mn ju ly lz mo mb mc md mp mf mg mh mq mj mk ml ij bi translated"><strong class="ls ir"><em class="on">deploy-web . yml</em></strong></p><pre class="kn ko kp kq gt oe mv of og aw oh bi"><span id="7a71" class="mw kz iq mv b gy oi oj l ok ol">version: "3.6"<br/><br/>services:<br/>  whoami:<br/>    image: "traefik/whoami"<br/>    deploy:<br/>      replicas: 1<br/><strong class="mv ir">      endpoint_mode: dnsrr</strong><br/>    networks:<br/>      - haproxy-network<br/><br/><br/>networks:<br/>  haproxy-network:<br/>    name:  haproxy-network<br/>    external: true</span></pre><ul class=""><li id="4b0f" class="ni nj iq ls b lt mm lw mn lz ob md oc mh od ml nn no np nq bi translated">后端服务由使用<code class="fe ms mt mu mv b">traefik/whomai</code> -image的任务组成，它通常显示关于主机的一些信息，如主机名和IP地址。</li><li id="420f" class="ni nj iq ls b lt nr lw ns lz nt md nu mh nv ml nn no np nq bi translated">为了绕过docker群路由网格，我们定义了<strong class="ls ir">端点_模式dnsrr </strong>。Docker为服务设置了DNS条目，这样对服务名称的DNS查询会返回一个IP地址列表，客户端直接连接到其中一个地址。(<a class="ae mr" href="https://docs.docker.com/engine/swarm/ingress/#without-the-routing-mesh" rel="noopener ugc nofollow" target="_blank">https://docs . docker . com/engine/swarm/ingress/# without-the-routing-mesh</a></li></ul><p id="4ef3" class="pw-post-body-paragraph lq lr iq ls b lt mm jr lv lw mn ju ly lz mo mb mc md mp mf mg mh mq mj mk ml ij bi translated">阐明演示设置的配置后，让我们部署它。</p><ul class=""><li id="8451" class="ni nj iq ls b lt mm lw mn lz ob md oc mh od ml nn no np nq bi translated"><code class="fe ms mt mu mv b">docker stack deploy -c deploy-infra.yml infra</code>在<code class="fe ms mt mu mv b">node1</code>部署haproxy服务。</li><li id="88fc" class="ni nj iq ls b lt nr lw ns lz nt md nu mh nv ml nn no np nq bi translated">您将会看到发布的端口会在docker-playground UI上弹出一个链接按钮</li></ul><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi oo"><img src="../Images/93f7a8d2b30a2f6c0f0b070bbba17bf5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tsOCYWeFTVso5JxdpCJ7dw.png"/></div></div><figcaption class="nx ny gj gh gi nz oa bd b be z dk translated">docker-playground-UI上已发布端口的弹出链接按钮</figcaption></figure><ul class=""><li id="9dd0" class="ni nj iq ls b lt mm lw mn lz ob md oc mh od ml nn no np nq bi translated">点击10087链接按钮进入<code class="fe ms mt mu mv b">&lt;host-node1&gt;-10087.direct.labs.play-with-docker.com/my-stats</code>的haproxy-stats页面。</li><li id="d252" class="ni nj iq ls b lt nr lw ns lz nt md nu mh nv ml nn no np nq bi translated">在<code class="fe ms mt mu mv b">docker stack deploy -c deploy-web.yml web</code>之前部署whoami服务。</li><li id="a5c1" class="ni nj iq ls b lt nr lw ns lz nt md nu mh nv ml nn no np nq bi translated">将whoami服务扩展到3个副本:<code class="fe ms mt mu mv b">docker service scale web_whoami=3</code></li><li id="1aaa" class="ni nj iq ls b lt nr lw ns lz nt md nu mh nv ml nn no np nq bi translated">在haproxy-stats-page上观察haproxy将如何动态解析服务任务并将它们添加到它的配置中。</li></ul><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi op"><img src="../Images/0627d8f5cb052b2f1e000229eed35881.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hC39sq5CNzDT3QjLwXQ6AA.png"/></div></div><figcaption class="nx ny gj gh gi nz oa bd b be z dk translated">将web _ whoami服务扩展到3个副本后的HAProxy统计页面</figcaption></figure><ul class=""><li id="ff3d" class="ni nj iq ls b lt mm lw mn lz ob md oc mh od ml nn no np nq bi translated">在<code class="fe ms mt mu mv b">&lt;host-node1&gt;-10087.direct.labs.play-with-docker.com</code>访问whoami服务器并多次重新加载页面。</li></ul><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi oq"><img src="../Images/08d166c93eaca9a9946f5cf8bbbca64a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wbTy1uEE3nWivsek9dhNBg.png"/></div></div><figcaption class="nx ny gj gh gi nz oa bd b be z dk translated">whoami网络服务器的响应</figcaption></figure><ul class=""><li id="4bcc" class="ni nj iq ls b lt mm lw mn lz ob md oc mh od ml nn no np nq bi translated">我们看到我们的请求与循环策略是平衡的，因为我们每次都到达不同的whoami服务任务。</li></ul><h2 id="c50e" class="mw kz iq bd la mx my dn le mz na dp li lz nb nc lk md nd ne lm mh nf ng lo nh bi translated">3.部署具有粘性负载平衡的HAProxy反向代理</h2><ul class=""><li id="49a4" class="ni nj iq ls b lt lu lw lx lz nk md nl mh nm ml nn no np nq bi translated">现在，我们将看看如何配置HAProxy以使用粘性负载平衡——我们将使用git-repository的<code class="fe ms mt mu mv b">02-Load-Balancing/02-</code> sticky -directory中定义的docker-stack和haproxy-configuration，它包含以下文件:</li></ul><pre class="kn ko kp kq gt oe mv of og aw oh bi"><span id="64bc" class="mw kz iq mv b gy oi oj l ok ol">02-Load-Balancing/02-sticky/<br/>├── deploy-infra-sticky.yml<br/>├── deploy-web-sticky.yml<br/>└── haproxy-sticky.cfg</span></pre><ul class=""><li id="946f" class="ni nj iq ls b lt mm lw mn lz ob md oc mh od ml nn no np nq bi translated">与循环演示相反，haproxy-service安排在<code class="fe ms mt mu mv b">node2</code>上，haproxy-port暴露在主机端口10088上。</li><li id="287c" class="ni nj iq ls b lt nr lw ns lz nt md nu mh nv ml nn no np nq bi translated">为了给haproxy配置粘性负载平衡，请仔细查看haproxy-sticky.cfg:</li></ul><pre class="kn ko kp kq gt oe mv of og aw oh bi"><span id="44b2" class="mw kz iq mv b gy oi oj l ok ol">backend be_whoami_service<br/>    balance roundrobin<br/><strong class="mv ir">    dynamic-cookie-key njqWdVKWfG<br/>    cookie SRVID insert dynamic<br/>    server-template whoamisticky 5 tasks.whoamisticky:80 check resolvers docker init-addr none</strong></span></pre><ul class=""><li id="91fd" class="ni nj iq ls b lt mm lw mn lz ob md oc mh od ml nn no np nq bi translated">使用指令<code class="fe ms mt mu mv b">dynamic-coockie-key</code>和<code class="fe ms mt mu mv b">coockie SRVID insert dynamic</code>，HAProxy将在用户代理发送的第一个响应中插入一个<code class="fe ms mt mu mv b">SRVID</code> — cookie，并每次引导我们执行相同的后端whoami任务。</li><li id="c725" class="ni nj iq ls b lt nr lw ns lz nt md nu mh nv ml nn no np nq bi translated">为了部署这个演示，<strong class="ls ir">遵循上一节</strong>中的过程——基本上是相同的——来自git-repository的README.md再次包含了如何做的详细说明。</li><li id="0ada" class="ni nj iq ls b lt nr lw ns lz nt md nu mh nv ml nn no np nq bi translated">安装一个chrome-extension<strong class="ls ir">" CoockieManger "</strong>(<a class="ae mr" href="https://chrome.google.com/webstore/detail/cookiemanager-cookie-edit/hdhngoamekjhmnpenphenpaiindoinpo?hl=en" rel="noopener ugc nofollow" target="_blank">https://chrome . Google . com/web store/detail/cookiemanager-cookie-edit/hdhngoamekjhmnpenphenpaiindoippo？hl=en </a>，删除<code class="fe ms mt mu mv b">SRVID</code> — cookie并重新加载页面。您将看到另一个后端任务已经被选择，多次重新加载再次导致相同的后端任务，这验证了粘性负载平衡的工作。</li></ul><p id="24f8" class="pw-post-body-paragraph lq lr iq ls b lt mm jr lv lw mn ju ly lz mo mb mc md mp mf mg mh mq mj mk ml ij bi translated">我希望您喜欢使用公共的免费play-with-docker playground定制默认docker群负载平衡机制的实践演示。</p><p id="336c" class="pw-post-body-paragraph lq lr iq ls b lt mm jr lv lw mn ju ly lz mo mb mc md mp mf mg mh mq mj mk ml ij bi translated">敬请期待！</p><p id="e98d" class="pw-post-body-paragraph lq lr iq ls b lt mm jr lv lw mn ju ly lz mo mb mc md mp mf mg mh mq mj mk ml ij bi translated"><strong class="ls ir">资源</strong></p></div><div class="ab cl kf kg hu kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="ij ik il im in"><div class="kn ko kp kq gt or"><a href="https://github.com/yandok/docker-swarm-sticky-load-balancing" rel="noopener  ugc nofollow" target="_blank"><div class="os ab fo"><div class="ot ab ou cl cj ov"><h2 class="bd ir gy z fp ow fr fs ox fu fw ip bi translated">GitHub-yandok/docker-swarm-sticky-load-balancing:演示粘性负载平衡的示例…</h2><div class="oy l"><h3 class="bd b gy z fp ow fr fs ox fu fw dk translated">在docker swarm-GitHub-yandok/docker-swarm-sticky-load-balancing上演示粘性负载平衡的示例…</h3></div><div class="oz l"><p class="bd b dl z fp ow fr fs ox fu fw dk translated">github.com</p></div></div><div class="pa l"><div class="pb l pc pd pe pa pf kw or"/></div></div></a></div><div class="pg ph gp gr pi or"><a href="https://www.haproxy.com/de/blog/haproxy-on-docker-swarm-load-balancing-and-dns-service-discovery/" rel="noopener  ugc nofollow" target="_blank"><div class="os ab fo"><div class="ot ab ou cl cj ov"><h2 class="bd ir gy z fp ow fr fs ox fu fw ip bi translated">Docker Swarm上的HAProxy:负载平衡和DNS服务发现- HAProxy技术</h2><div class="oy l"><h3 class="bd b gy z fp ow fr fs ox fu fw dk translated">Docker Swarm让你扩展到在一台机器上托管Docker容器之外。它监管服务器集群，并…</h3></div><div class="oz l"><p class="bd b dl z fp ow fr fs ox fu fw dk translated">www.haproxy.com</p></div></div><div class="pa l"><div class="pj l pc pd pe pa pf kw or"/></div></div></a></div><div class="pg ph gp gr pi or"><a href="https://www.haproxy.com/blog/dns-service-discovery-haproxy/" rel="noopener  ugc nofollow" target="_blank"><div class="os ab fo"><div class="ot ab ou cl cj ov"><h2 class="bd ir gy z fp ow fr fs ox fu fw ip bi translated">用于HAProxy - HAProxy技术中的服务发现的DNS</h2><div class="oy l"><h3 class="bd b gy z fp ow fr fs ox fu fw dk translated">HAProxy 1.8和更新版本允许您使用DNS服务发现来检测服务器更改，并自动将它们应用到…</h3></div><div class="oz l"><p class="bd b dl z fp ow fr fs ox fu fw dk translated">www.haproxy.com</p></div></div><div class="pa l"><div class="pk l pc pd pe pa pf kw or"/></div></div></a></div><div class="pg ph gp gr pi or"><a href="https://labs.play-with-docker.com/" rel="noopener  ugc nofollow" target="_blank"><div class="os ab fo"><div class="ot ab ou cl cj ov"><h2 class="bd ir gy z fp ow fr fs ox fu fw ip bi translated">和Docker一起玩</h2><div class="oy l"><h3 class="bd b gy z fp ow fr fs ox fu fw dk translated">与Docker (PWD)一起玩是一个由Marcos Liljedhal和Jonathan Leibiusky开发的项目，由PWD Docker公司赞助…</h3></div><div class="oz l"><p class="bd b dl z fp ow fr fs ox fu fw dk translated">labs.play-with-docker.com</p></div></div><div class="pa l"><div class="pl l pc pd pe pa pf kw or"/></div></div></a></div></div></div>    
</body>
</html>