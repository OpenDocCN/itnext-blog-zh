<html>
<head>
<title>Typescript Gotchas when you come from back-end world</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">当你来自后端世界时</h1>
<blockquote>原文：<a href="https://itnext.io/typescript-gotchas-when-you-come-from-back-end-world-cf7f6c3d0d02?source=collection_archive---------3-----------------------#2019-07-16">https://itnext.io/typescript-gotchas-when-you-come-from-back-end-world-cf7f6c3d0d02?source=collection_archive---------3-----------------------#2019-07-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="78b7" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">以打字打的文件</h2><div class=""/><p id="df03" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">Typescript发展如此之快，以至于无法避免。无论是在Angular、React、Vue应用程序中使用，还是在后端使用，它都极大地增强了Javascript。</p><figure class="ky kz la lb gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi kx"><img src="../Images/097ee77725a14e56f4a05adf09409071.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MpucbJi320PAdMkH"/></div></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk translated"><a class="ae ln" href="https://unsplash.com/@hnhmarketing?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">猎人哈利</a>在<a class="ae ln" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="88a4" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">它提供了许多来自OOP(面向对象编程)的好处，但是它也有一些缺点，你可以在Eric Elliott的文章中找到:</p><div class="lq lr gp gr ls lt"><a href="https://medium.com/javascript-scene/the-typescript-tax-132ff4cb175b" rel="noopener follow" target="_blank"><div class="lu ab fo"><div class="lv ab lw cl cj lx"><h2 class="bd jd gy z fp ly fr fs lz fu fw jc bi translated">打字税</h2><div class="ma l"><h3 class="bd b gy z fp ly fr fs lz fu fw dk translated">成本与收益分析</h3></div><div class="mb l"><p class="bd b dl z fp ly fr fs lz fu fw dk translated">medium.com</p></div></div><div class="mc l"><div class="md l me mf mg mc mh lh lt"/></div></div></a></div><p id="69e9" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">两年多前我开始使用Typescript。我想，和许多后端开发人员一样，我不想错过这个浪潮。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><p id="a9e7" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">本文收集了Java或C#等后端技术中使用的所有常见行为、数据结构和编码技巧。当然，我会尽量让这篇文章保持最新。请随意评论(评论、错误或提示)，我会提到你。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="19b5" class="mp mq it bd mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm bi translated">重载方法</h1><p id="eb00" class="pw-post-body-paragraph jz ka it kb b kc nn ke kf kg no ki kj kk np km kn ko nq kq kr ks nr ku kv kw im bi translated">重载一个方法意味着相同的名字影响到几个参数不同的函数。</p><p id="8a31" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">这在C#中相当容易:</p><pre class="ky kz la lb gt ns nt nu nv aw nw bi"><span id="c44f" class="nx mq it nt b gy ny nz l oa ob">public string SayHello() {<br/>  return "Hello World!";<br/>}</span><span id="130d" class="nx mq it nt b gy oc nz l oa ob">public string SayHello(string firstName, string lastName) {<br/>  return $"Hello {firstName} {lastName}!";<br/>}</span></pre><p id="fd6c" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">但是Typescript呢？这不是小事，我们必须检查参数:</p><pre class="ky kz la lb gt ns nt nu nv aw nw bi"><span id="bf5c" class="nx mq it nt b gy ny nz l oa ob">sayHello(): string;<br/>sayHello(firstName: string, lastName: string): string {<br/>  if(firstName &amp;&amp; lastName) { <br/>    return `Hello ${firstName} ${lastName}`;<br/>  } else {<br/>    return 'Hello World!';<br/>  }<br/>}</span></pre><p id="a08e" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">在提升阶段，扫描所有的函数名。由于函数参数与区分两种方法无关(由于Javascript中的动态类型)，所以不能使用它们。因此，我们需要检查参数(无论是否提供)及其类型。</p><p id="2c22" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated"><strong class="kb jd">提示:</strong>你可以通过<code class="fe od oe of nt b">typeof</code>(原语)或者<code class="fe od oe of nt b">instanceof</code>(复杂类型)关键字来检查参数类型。您也可以使用<a class="ae ln" href="https://www.typescriptlang.org/docs/handbook/advanced-types.html#user-defined-type-guards" rel="noopener ugc nofollow" target="_blank">型防护装置</a>。</p><h1 id="3d5a" class="mp mq it bd mr ms og mu mv mw oh my mz na oi nc nd ne oj ng nh ni ok nk nl nm bi translated">当界面是空的时</h1><p id="023e" class="pw-post-body-paragraph jz ka it kb b kc nn ke kf kg no ki kj kk np km kn ko nq kq kr ks nr ku kv kw im bi translated">事实上，当接口从Typescript转换到Javascript时，它们就消失了。什么都没留下。即使只有void，它们也有很多用处:构造你的代码，扩展类，对象，…</p><p id="8d07" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">在C#中用I作为接口的前缀是一个常见的习惯，例如<code class="fe od oe of nt b">IDisposable</code>。在Typescript中，这不是强制性的。</p><p id="746e" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">多亏了接口，你可以扩展类、对象和其他接口。关于…</p><h1 id="d6e9" class="mp mq it bd mr ms og mu mv mw oh my mz na oi nc nd ne oj ng nh ni ok nk nl nm bi translated">…扩展现有对象</h1><p id="0f09" class="pw-post-body-paragraph jz ka it kb b kc nn ke kf kg no ki kj kk np km kn ko nq kq kr ks nr ku kv kw im bi translated">有时，您只需要向现有对象添加方法。这是扩展该对象功能的一种简单方法。</p><p id="da60" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">在C#中:</p><pre class="ky kz la lb gt ns nt nu nv aw nw bi"><span id="5484" class="nx mq it nt b gy ny nz l oa ob">public static string AppendSmiley(this string message) {<br/>  return $"{message} :-)";<br/>}</span><span id="36bd" class="nx mq it nt b gy oc nz l oa ob">string msg = "Home, sweet home!".AppendSmiley();<br/>// Now msg equals "Home, sweet home! :-)"</span></pre><p id="3061" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">在Typescript中，我们只需要记住两个接口可以拥有相同的名称:</p><pre class="ky kz la lb gt ns nt nu nv aw nw bi"><span id="2864" class="nx mq it nt b gy ny nz l oa ob">declare global {<br/>  interface String {<br/>    sayHello(): String;<br/>  }<br/>}<br/>String.prototype.sayHello = function(): string {<br/>  return 'Hello World!';<br/>}<br/>export{};</span></pre><h1 id="c138" class="mp mq it bd mr ms og mu mv mw oh my mz na oi nc nd ne oj ng nh ni ok nk nl nm bi translated">映射数据</h1><p id="e434" class="pw-post-body-paragraph jz ka it kb b kc nn ke kf kg no ki kj kk np km kn ko nq kq kr ks nr ku kv kw im bi translated">在某些算法中关联数据更有效。您需要创建一个键值对。这样，您可以通过一个键确保唯一性，并改进一组数据中的查找。</p><p id="9a69" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">在C#中，字典<tkey tvalue=""> ( <a class="ae ln" href="https://docs.microsoft.com/fr-fr/dotnet/api/system.collections.generic.dictionary-2?view=netframework-4.8" rel="noopener ugc nofollow" target="_blank"> doc </a>)对象存在:</tkey></p><pre class="ky kz la lb gt ns nt nu nv aw nw bi"><span id="fd8b" class="nx mq it nt b gy ny nz l oa ob">var dico = new Dictionary&lt;int, string&gt;();<br/>dico.Add(1, "One");<br/>dico.Add(2, "Two");<br/>dico.Add(3, "Three");<br/>dico.ContainsKey(2); // true</span></pre><p id="0652" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">Typescript提供了一组实用程序类型，包括<a class="ae ln" href="https://www.typescriptlang.org/docs/handbook/utility-types.html#recordkt" rel="noopener ugc nofollow" target="_blank">记录</a>类型，其行为与C#中的Dictionary完全相同:</p><pre class="ky kz la lb gt ns nt nu nv aw nw bi"><span id="e831" class="nx mq it nt b gy ny nz l oa ob">// Extract from doc</span><span id="1939" class="nx mq it nt b gy oc nz l oa ob"><strong class="nt jd">interface</strong> PageInfo {<br/>    title: string;<br/>}<br/><br/><strong class="nt jd">type</strong> Page = 'home' | 'about' | 'contact';<br/><br/><strong class="nt jd">const</strong> x: Record&lt;Page, PageInfo&gt; = {<br/>    about: { title: 'about' },<br/>    contact: { title: 'contact' },<br/>    home: { title: 'home' },<br/>};<!-- --> </span></pre><p id="1e09" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">您将在以下位置找到所有可用的实用程序类型:</p><div class="lq lr gp gr ls lt"><a href="https://www.typescriptlang.org/docs/handbook/utility-types.html" rel="noopener  ugc nofollow" target="_blank"><div class="lu ab fo"><div class="lv ab lw cl cj lx"><h2 class="bd jd gy z fp ly fr fs lz fu fw jc bi translated">实用程序类型</h2><div class="ma l"><h3 class="bd b gy z fp ly fr fs lz fu fw dk translated">在上面的例子中，makeObject的参数中的methods对象有一个上下文类型，包括ThisType和…</h3></div><div class="mb l"><p class="bd b dl z fp ly fr fs lz fu fw dk translated">www.typescriptlang.org</p></div></div></div></a></div><h1 id="705a" class="mp mq it bd mr ms og mu mv mw oh my mz na oi nc nd ne oj ng nh ni ok nk nl nm bi translated">在文字类型中省略类型</h1><p id="5750" class="pw-post-body-paragraph jz ka it kb b kc nn ke kf kg no ki kj kk np km kn ko nq kq kr ks nr ku kv kw im bi translated">最近，我不得不在我的应用程序中处理过滤器。其中一个标准是readonly，然后我想从<code class="fe od oe of nt b">Filter</code>类型中提取可编辑的键。</p><figure class="ky kz la lb gt lc"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="bdaa" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">在这个要点中，我们有一个格式属性为readonly的<code class="fe od oe of nt b">Filter</code>类。如果我们想让所有可编辑的过滤键在下面的方法中使用它们:<code class="fe od oe of nt b">updateFilters(key: EditableFilters, newValue: unknown)</code>，我们需要“省略”format属性。</p><p id="c5bd" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">的确，<code class="fe od oe of nt b">keyof</code>会返回所有的属性。根据上下文，这个技巧非常有用，但它只在较新版本的Typescript (3.5以上)中有效。如果您想将其用于旧版本，可以使用变通方法:</p><p id="3dfe" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated"><code class="fe od oe of nt b">Pick&lt;T, Exclude&lt;keyof T, K&gt;&gt;</code></p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><p id="d0bc" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">正如开头所建议的，请随意发表评论，以使本文更好。你可以在我的个人资料页面找到其他关于Typescript的文章。</p></div></div>    
</body>
</html>