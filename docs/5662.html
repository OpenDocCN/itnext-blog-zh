<html>
<head>
<title>Docker Running In Rootless Mode</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Docker以无根模式运行</h1>
<blockquote>原文：<a href="https://itnext.io/docker-running-in-rootless-mode-bdbcfc728b3a?source=collection_archive---------1-----------------------#2021-04-27">https://itnext.io/docker-running-in-rootless-mode-bdbcfc728b3a?source=collection_archive---------1-----------------------#2021-04-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ecdf" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">运行具有额外安全层的容器</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7a9a41f3bfc69ad55ab8214a532f1c5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k6KrFQNnnnCY9ag3U2O89A.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@lazycreekimages?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">迈克尔·泽兹奇</a>在<a class="ae ky" href="https://unsplash.com/s/photos/secure?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="94a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我提供Docker培训时，我通常会给每个参与者提供一个Ubuntu VM，并要求他们使用以下命令安装Docker:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="6f91" class="ma mb it lw b gy mc md l me mf">$ curl -sSL <a class="ae ky" href="https://get.docker.com" rel="noopener ugc nofollow" target="_blank">https://get.docker.com</a> | sh</span></pre><p id="40f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Docker 20.10中，该命令的输出略有变化，因为它现在提供了如何在无根模式下运行Docker的信息，这意味着让Docker守护程序与当前用户而不是根用户一起运行。在本文中，我们将看到如何做到这一点，以及这意味着什么。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h2 id="6c90" class="ma mb it bd mn mo mp dn mq mr ms dp mt li mu mv mw lm mx my mz lq na nb nc nd bi translated">运行无根Docker守护程序</h2><p id="d328" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">使用<a class="ae ky" href="https://multipass.run" rel="noopener ugc nofollow" target="_blank"> Multipass </a>我们创建一个名为<code class="fe nj nk nl lw b">docker</code>的Ubuntu虚拟机，并在其中获得一个shell:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="814e" class="ma mb it lw b gy mc md l me mf">$ multipass launch -n docker</span><span id="e585" class="ma mb it lw b gy nm md l me mf">$ multipass shell docker</span></pre><p id="b7c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们从这个shell安装Docker:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="5a54" class="ma mb it lw b gy mc md l me mf">ubuntu@docker:~$ curl -sSL <a class="ae ky" href="https://get.docker.com" rel="noopener ugc nofollow" target="_blank">https://get.docker.com</a> | sh</span></pre><p id="f76b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个命令安装Docker守护进程，并使用<code class="fe nj nk nl lw b">root</code>用户启动它。正如我们从输出中看到的，我们还有一条有趣的消息，解释了如何在无根模式下运行Docker守护进程:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/f733fb0fcb18fd024774064df346cbe0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*129CHdPdCaDEoUbKusMdnA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">Docker守护程序现在可以很容易地在无根模式下安装</figcaption></figure><p id="66c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">默认情况下，Docker守护程序以root用户身份运行，因此访问该守护程序可能会带来许多安全隐患。无根模式的想法是与另一个用户一起运行Docker守护程序，这样在容器受损或坏人获得守护程序API的情况下，权限升级会变得更加困难。</p><p id="4518" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们运行上面输出中指定的命令:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="b58d" class="ma mb it lw b gy mc md l me mf"><strong class="lw iu">$ dockerd-rootless-setuptool.sh install</strong></span></pre><p id="5a05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意:由于涉及到用户名称空间，需要首先安装一些依赖项(如果不存在，您将得到一条错误消息)，这可以通过以下命令来完成:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="e717" class="ma mb it lw b gy mc md l me mf">sudo sh -eux &lt;&lt;EOF<br/># Install newuidmap &amp; newgidmap binaries<br/>apt-get install -y uidmap<br/>EOF</span></pre><p id="b80b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在无根模式下启动docker守护进程后，我们需要设置以下环境变量，以便Docker客户端与守护进程的这个新实例进行通信:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="7773" class="ma mb it lw b gy mc md l me mf">export PATH=/usr/bin:$PATH<br/>export DOCKER_HOST=unix:///run/user/1000/docker.sock</span></pre><p id="7207" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意:DOCKER_HOST past (1000)中引用的id是当前用户的<code class="fe nj nk nl lw b">uid</code>，如以下命令所示:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="e54a" class="ma mb it lw b gy mc md l me mf"><strong class="lw iu">$ id</strong><br/><strong class="lw iu">uid=1000(ubuntu)</strong> gid=1000(ubuntu) groups=1000(ubuntu),4(adm),20(dialout),24(cdrom),25(floppy),27(sudo),29(audio),30(dip),44(video),46(plugdev),117(netdev),118(lxd)</span></pre><p id="41d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在接下来的部分中，我们将通过几个容器来说明无根模式的一些局限性。</p><p id="e75f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">ℹ️一个无根守护进程也可以使用下面的命令直接安装<code class="fe nj nk nl lw b">curl -sSL <a class="ae ky" href="https://get.docker.com/rootless" rel="noopener ugc nofollow" target="_blank">https://get.docker.com/rootless</a> | sh</code></p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h2 id="f636" class="ma mb it bd mn mo mp dn mq mr ms dp mt li mu mv mw lm mx my mz lq na nb nc nd bi translated">启动样本容器</h2><p id="9ce7" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">现在让我们运行几个容器，看看在无根守护进程的上下文中可能遇到的问题。</p><ul class=""><li id="85f4" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu nt nu nv nw bi translated"><strong class="lb iu">幽灵集装箱</strong></li></ul><p id="1a72" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们试着运行第一个基于<a class="ae ky" href="https://hub.docker.com/_/ghost" rel="noopener ugc nofollow" target="_blank"> ghost </a>镜像的容器(ghost是一个免费的开源博客平台):</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="09f8" class="ma mb it lw b gy mc md l me mf">$ docker run -p 2368:2368 -d ghost</span></pre><p id="59dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">容器运行良好，可以使用多路虚拟机的IP在端口2368(默认Ghost端口)上访问Ghost接口:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/f1a314b4101c51c99aaf72e702bf45f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Uo5roytEVH2DJCHtaRe8pQ.png"/></div></div></figure><ul class=""><li id="fb53" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu nt nu nv nw bi translated"><strong class="lb iu"> MongoDB容器</strong></li></ul><p id="5893" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们运行一个基于<a class="ae ky" href="https://hub.docker.com/_/mongo" rel="noopener ugc nofollow" target="_blank"> mongo </a>映像的容器:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="bfce" class="ma mb it lw b gy mc md l me mf">$ docker run -d -p 27017:27017 mongo:4.4</span></pre><p id="a663" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从<a class="ae ky" href="https://www.mongodb.com/products/compass" rel="noopener ugc nofollow" target="_blank"> MongoDB Compass </a>客户端，我们可以通过Multipass VM的IP访问端口27017(默认的Mongo端口)上的数据库。那时一切都很好。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/7563fa903d23bacdcf4fc264c941d58d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X552lA_09T84Ys1dJyqw3w.png"/></div></div></figure><ul class=""><li id="57c8" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu nt nu nv nw bi translated"><strong class="lb iu"> Nginx容器暴露在端口80上</strong></li></ul><p id="6fa3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于守护进程没有使用<code class="fe nj nk nl lw b">root</code>运行，所以有一些明显的限制。例如，不允许在特权端口(端口&lt; 1024)上公开容器，正如我们在nginx容器中看到的:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="f5b5" class="ma mb it lw b gy mc md l me mf"><strong class="lw iu">$ docker run -p 80:80 -d nginx:1.18-alpine<br/></strong>...<br/>cannot expose privileged port 80, you can add 'net.ipv4.ip_unprivileged_port_start=80' to /etc/sysctl.conf (currently 1024), or set CAP_NET_BIND_SERVICE on rootlesskit binary, or choose a larger port number (&gt;= 1024): listen tcp4 0.0.0.0:80: bind: permission denied.</span></pre><ul class=""><li id="6202" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu nt nu nv nw bi translated"><strong class="lb iu">使用捆绑架的阿尔卑斯集装箱</strong></li></ul><p id="76cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们尝试运行一个基于<a class="ae ky" href="https://hub.docker.com/_/alpine" rel="noopener ugc nofollow" target="_blank"> alpine映像</a>的容器，并将主机的根文件夹绑定到容器文件系统中。这可以用下面的命令来完成；</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="5968" class="ma mb it lw b gy mc md l me mf">$ docker run -ti -v /:/host alpine</span></pre><p id="3eec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">默认情况下，我们在容器中得到一个<code class="fe nj nk nl lw b">sh</code>shell(alpine中的默认shell)。在shell中检查我们的身份，我们可以看到我们是root。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="596f" class="ma mb it lw b gy mc md l me mf">/ # whoami<br/>root</span></pre><p id="5ff4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们从这个shell中删除主机的<code class="fe nj nk nl lw b">sh</code>可执行文件:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="1ea4" class="ma mb it lw b gy mc md l me mf">/ # rm /host/usr/bin/sh<br/>rm: can't remove '/host/usr/bin/sh': Permission denied</span></pre><p id="0405" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不允许我们执行此操作，因为我们是容器内的root用户，但不是主机上的root用户。容器内的Root被映射到主机上的非root用户。</p><ul class=""><li id="86e1" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu nt nu nv nw bi translated"><strong class="lb iu">另一个阿尔卑斯集装箱</strong></li></ul><p id="2f1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在将运行一个新的容器，并在容器内部和主机上直接看到与流程相关联的用户:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="a0fa" class="ma mb it lw b gy mc md l me mf">ubuntu@docker:~$ docker run --name sleep -d alpine sleep 3600</span></pre><p id="6130" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们从容器内部检查该进程，我们可以看到sleep命令是以root用户身份运行的</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="1724" class="ma mb it lw b gy mc md l me mf"><strong class="lw iu">ubuntu@docker:~$ docker exec sleep ps aux<br/></strong>PID   USER     TIME  COMMAND<br/>    1 root      0:00 sleep 3600<br/>...</span></pre><p id="8182" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是如果我们检查主机上的睡眠进程，我们可以看到它属于<code class="fe nj nk nl lw b">ubuntu</code>用户。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="3786" class="ma mb it lw b gy mc md l me mf"><strong class="lw iu">ubuntu@docker:~$ ps aux | grep sleep<br/></strong>ubuntu  4642  0.0  0.0 1576     4 ?    Ss   10:45   0:00 sleep 3600</span></pre><p id="a715" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从这个例子中我们可以了解到，如果容器中以root用户身份运行的进程受到威胁，那么最多只能升级到运行Docker守护进程的用户，而不能升级到主机的root用户。</p><blockquote class="nz oa ob"><p id="d773" class="kz la oc lb b lc ld ju le lf lg jx lh od lj lk ll oe ln lo lp of lr ls lt lu im bi translated">在<!-- -->无根模式下，容器内的根不是主机上的根</p></blockquote><ul class=""><li id="5f34" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu nt nu nv nw bi translated"><strong class="lb iu">内存限制</strong></li></ul><p id="50f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们运行一个容器，它的唯一目的是使用RAM填充数组。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="f962" class="ma mb it lw b gy mc md l me mf"><strong class="lw iu">$ docker container run --memory 32m estesp/hogit<br/></strong>WARNING: Your kernel does not support swap limit capabilities or the cgroup is not mounted. Memory limited without swap.<br/>...<br/>Populating row 0 of 500000 sized array of uint64 values<br/>Waiting 3 seconds before next row creation<br/>...<br/>Populating row 9 of 500000 sized array of uint64 values<br/>Waiting 3 seconds before next row creation</span></pre><p id="4b7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个容器创建了这个大数组的10行，正如它应该做的那样，并且没有因为它的内存消耗而被终止。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="6c4a" class="ma mb it lw b gy mc md l me mf">ubuntu@docker:~$ docker inspect hog -f '{{ .State.OOMKilled }}'<br/>false</span></pre><p id="d979" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">🔥在一个非无根守护进程中，这个容器在创建几行后就会被终止(OOM)。</p><p id="5023" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此在运行容器时没有考虑到<code class="fe nj nk nl lw b">--memory</code>标志。我们本可以通过仔细查看我们得到的警告来提前发现这一点:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="dd6d" class="ma mb it lw b gy mc md l me mf">WARNING: Your kernel does not support swap limit capabilities or the cgroup is not mounted. Memory limited without swap.</span></pre><p id="0120" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这可以解释为Docker无根模式不支持Cgroup v1。以下命令显示当前使用了Cgroup v1，而在这个无根上下文中应该使用Cgroup v2。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="ff2e" class="ma mb it lw b gy mc md l me mf"><strong class="lw iu">ubuntu@docker:~$ docker info | grep -i cgroup<br/></strong> Cgroup Driver: none<br/> Cgroup Version: 1<br/>WARNING: Running in rootless-mode without cgroups. To enable cgroups in rootless-mode, you need to boot the system in cgroup v2 mode.</span></pre><p id="35aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果使用Cgroup v1，ℹ️其他Cgroup的相关标志如<code class="fe nj nk nl lw b">--cpus</code>也不起作用。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h2 id="1d02" class="ma mb it bd mn mo mp dn mq mr ms dp mt li mu mv mw lm mx my mz lq na nb nc nd bi translated">摘要</h2><p id="ff62" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">Docker经常被安全人员指出，因为守护程序是以root用户身份运行的。在这种情况下，以无根模式运行Docker守护进程无疑是一个伟大的举措👍</p><p id="3c3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在本文中只看到了一些限制，但还有其他限制，如受支持的存储驱动程序列表。当然，这肯定会在不久的将来发展，以克服许多现有的限制。</p></div></div>    
</body>
</html>