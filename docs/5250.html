<html>
<head>
<title>Server-side Event Streams with Dotnet Core and TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">具有Dotnet核心和TypeScript的服务器端事件流</h1>
<blockquote>原文：<a href="https://itnext.io/server-side-event-streams-with-dotnet-core-and-typescript-d20c84017480?source=collection_archive---------0-----------------------#2021-01-24">https://itnext.io/server-side-event-streams-with-dotnet-core-and-typescript-d20c84017480?source=collection_archive---------0-----------------------#2021-01-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/2985cd6d8b2ec172b390dc43e0eeddde.png" data-original-src="https://miro.medium.com/v2/resize:fit:1330/format:webp/1*z63psYnF6K3UhBfJOW2HMA.png"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">Chrome开发工具中的服务器端事件</figcaption></figure><p id="0c22" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在现代web开发中，看到网站上的数据实时更新是非常常见的。例如，在外卖订单的地图上查找快递员，或者在跟踪和追踪页面上查找新鞋的预计到达时间。这(很可能)是所有的实时数据，直接从服务器传到你的屏幕上。</p><p id="3667" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有多种方法可以实现这些功能。有了Dotnet Core，你当然可以使用<a class="ae kw" href="https://docs.microsoft.com/en-us/aspnet/core/signalr/introduction?view=aspnetcore-5.0" rel="noopener ugc nofollow" target="_blank"> SignalR </a>，但是如果你只是想实时更新ETA，这对于一个小问题来说是一个<a class="ae kw" href="https://bundlephobia.com/result?p=angular@1.8.2" rel="noopener ugc nofollow" target="_blank">相当大的</a>和相对复杂的锤子。另一方面，您可以使用客户端循环，每隔X秒从正常的REST端点获取一个新值。虽然这是一个非常简单的解决方案，但它也不是真正实时的(至少在合理的时间间隔内)。</p><p id="bc4f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第三种不太为人所知的解决方案是使用服务器端事件流。服务器端事件允许您向客户端发送实时事件，由普通JavaScript支持，只需在标准控制器中执行一个普通操作即可完成。这使他们有可能很好地介于前面提到的两个选项之间。在本文中，我想向您展示如何以无库的方式在Dotnet Core和JavaScript中实现服务器端事件。</p><h1 id="2e39" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">在Dotnet核心中发送事件</h1><p id="3910" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">Dotnet Core没有对服务器端事件的内置支持，所以我们必须自己实现一些规范。我决定通过在<code class="fe ma mb mc md b">HttpContext</code>类上创建扩展方法来做到这一点，这些方法可以在任何具有<code class="fe ma mb mc md b">HttpContext</code>属性的控制器中使用。</p><h2 id="cda9" class="me ky iq bd kz mf mg dn ld mh mi dp lh kj mj mk ll kn ml mm lp kr mn mo lt mp bi translated">正在初始化流</h2><p id="5271" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">我们要做的第一件事是通过向客户端发送正确的<code class="fe ma mb mc md b">Content-Type</code>头来初始化流。这将告诉浏览器这个响应确实是一个事件流，并且可以在一个<code class="fe ma mb mc md b">EventStream</code>对象中使用(稍后将详细介绍)。</p><figure class="mq mr ms mt gt jr"><div class="bz fp l di"><div class="mu mv l"/></div></figure><h2 id="596b" class="me ky iq bd kz mf mg dn ld mh mi dp lh kj mj mk ll kn ml mm lp kr mn mo lt mp bi translated">流的内容</h2><p id="94ed" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">之后，我们可以开始向客户端发送事件。可以通过事件流发送多种不同的内容:</p><ul class=""><li id="2096" class="mw mx iq ka b kb kc kf kg kj my kn mz kr na kv nb nc nd ne bi translated">普通数据:只是一个包含一些文本的字符串。要向客户端发送一个字符串，我们需要在写入正文之前在它前面加上<code class="fe ma mb mc md b">data :</code>。一个小问题是，如果我们发送一个多行字符串，我们必须在每一行前面加上<code class="fe ma mb mc md b">data :</code>。</li><li id="82e6" class="mw mx iq ka b kb nf kf ng kj nh kn ni kr nj kv nb nc nd ne bi translated">事件:一个事件由四个字段组成:<code class="fe ma mb mc md b">name</code>、<code class="fe ma mb mc md b">data</code>、<code class="fe ma mb mc md b">id</code>和<code class="fe ma mb mc md b">retry</code>。<code class="fe ma mb mc md b">name</code>是客户端将要收听的事件的名称。<code class="fe ma mb mc md b">data</code>是事件的有效负载，可以是常规字符串，也可以是JSON。<code class="fe ma mb mc md b">id</code>是可选字段，可用于向客户端发送额外的标识符。使用<code class="fe ma mb mc md b">retry</code>可以在出现连接错误时更改客户端的重试策略。</li><li id="c195" class="mw mx iq ka b kb nf kf ng kj nh kn ni kr nj kv nb nc nd ne bi translated">注释:我们可以通过在流前加上<code class="fe ma mb mc md b">:</code>来发送注释。客户端会忽略注释，但是它们对于发送调试数据很有用。</li></ul><h2 id="773d" class="me ky iq bd kz mf mg dn ld mh mi dp lh kj mj mk ll kn ml mm lp kr mn mo lt mp bi translated">发送数据消息</h2><p id="7218" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">我们将从向客户端发送数据字符串的方法开始。扩展方法的实现如下所示。注意，我们必须在发送数据之前写一个额外的换行符，这样客户端就知道消息已经结束并且是完整的。</p><figure class="mq mr ms mt gt jr"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="442c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有了这两种方法，我们就可以创建一个控制器，并开始通过流发送数据。事件流的操作与普通请求的操作有一些重要的不同。因为我们不是对单个请求发送单个响应，所以动作的返回类型不是<code class="fe ma mb mc md b">IActionResult</code>，而是<code class="fe ma mb mc md b">Task</code>(不是<code class="fe ma mb mc md b">void</code>，因为流是异步发生的)。当操作返回所有数据已经发送到客户端时，Dotnet剩下要做的唯一事情就是关闭连接。例如，返回<code class="fe ma mb mc md b">Ok()</code>会抛出一个异常，显示我们已经向客户端发送了一个响应。</p><figure class="mq mr ms mt gt jr"><div class="bz fp l di"><div class="mu mv l"/></div></figure><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/035575b1fe6dedc919bb73dcdd154cda.png" data-original-src="https://miro.medium.com/v2/resize:fit:806/format:webp/1*uWUcnm-A1v3PuFtyW4X8ug.png"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">这个事件流在Chrome开发工具中是什么样子的</figcaption></figure><h2 id="df5d" class="me ky iq bd kz mf mg dn ld mh mi dp lh kj mj mk ll kn ml mm lp kr mn mo lt mp bi translated">发送事件</h2><p id="f842" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">接下来要做的是开始发送事件(毕竟是一个*event*流)。为了存储组成事件的字段，我将首先创建一个代表服务器端事件的<code class="fe ma mb mc md b">SSEEvent</code>类。</p><figure class="mq mr ms mt gt jr"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="0db2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来是向客户机发送完整事件的扩展方法。这一个的实现看起来有很多代码，但是大部分只是在我们将可选字段写入主体之前检查它们是否被设置。注意，我们在这里需要检查我们是否发送了一个<code class="fe ma mb mc md b">string</code>或者一个<code class="fe ma mb mc md b">object</code>，因为如果是一个字符串，我们需要在所有的行前面加上<code class="fe ma mb mc md b">data :</code>前缀。然而，JSON数据字段中的换行符不是问题。另一个特例是<code class="fe ma mb mc md b">null</code>值:它必须用空字符串而不是JSON null发送。</p><figure class="mq mr ms mt gt jr"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="a87b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们已经可以开始沿着事件流发送一些事件了。在本例中，我们仅在500毫秒的延迟后发送一条消息，但当然，您可以在很长的时间内发送任意多条消息:</p><figure class="mq mr ms mt gt jr"><div class="bz fp l di"><div class="mu mv l"/></div></figure><figure class="mq mr ms mt gt jr"><div class="bz fp l di"><div class="mu mv l"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">上面显示的事件主体</figcaption></figure><h2 id="16bc" class="me ky iq bd kz mf mg dn ld mh mi dp lh kj mj mk ll kn ml mm lp kr mn mo lt mp bi translated">发送评论</h2><p id="4b8f" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">为了结束我们的服务器端代码，我们将添加通过事件流发送注释的扩展方法。这种方法几乎与发送数据消息的方法相同，但是现在没有了<code class="fe ma mb mc md b">data</code>前缀(但是我们仍然需要在每一行前面加上<code class="fe ma mb mc md b">:</code>)。</p><figure class="mq mr ms mt gt jr"><div class="bz fp l di"><div class="mu mv l"/></div></figure><h1 id="b0aa" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">在TypeScript中列出事件</h1><p id="be09" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">在TypeScript中，我们可以为每个包含事件流的端点创建一个<code class="fe ma mb mc md b">EventSource</code>对象。这是通过将url和一些可选选项传递给构造函数来实现的。一个单独的<code class="fe ma mb mc md b">EventStream</code>代表一个单独的url，并且可以附加多个事件监听器。</p><figure class="mq mr ms mt gt jr"><div class="bz fp l di"><div class="mu mv l"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">创建事件源</figcaption></figure><h2 id="288c" class="me ky iq bd kz mf mg dn ld mh mi dp lh kj mj mk ll kn ml mm lp kr mn mo lt mp bi translated">列出数据消息</h2><p id="ad89" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">为了监听用<code class="fe ma mb mc md b">SSESendDataAsync</code>发送的普通数据消息，我们可以将事件流的<code class="fe ma mb mc md b">onmessage</code>属性设置为一个函数。该函数将获取事件作为参数，您可以在该事件的<code class="fe ma mb mc md b">data</code>属性中找到数据。</p><figure class="mq mr ms mt gt jr"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="5e68" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于每个<code class="fe ma mb mc md b">EventSource</code>,我们只能有一个数据消息监听器，不像对于事件，我们可以有任意多个监听器。</p><h2 id="132a" class="me ky iq bd kz mf mg dn ld mh mi dp lh kj mj mk ll kn ml mm lp kr mn mo lt mp bi translated">列出事件</h2><p id="1abb" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">对于监听命名事件，您可以使用even信号源的<code class="fe ma mb mc md b">addEventListener</code>方法。对于命名事件，您可以为每个名称添加一个监听器来监听这个特定的事件。可以为每个事件名称添加多个侦听器。移除监听器是通过<code class="fe ma mb mc md b">removeEventListener</code>完成的(就像JavaScript中的任何其他事件监听器一样)。</p><figure class="mq mr ms mt gt jr"><div class="bz fp l di"><div class="mu mv l"/></div></figure><h2 id="cdf3" class="me ky iq bd kz mf mg dn ld mh mi dp lh kj mj mk ll kn ml mm lp kr mn mo lt mp bi translated">关闭流</h2><p id="be9e" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">关于服务器端事件流，需要记住的一点是，只有客户端可以关闭它们。如果服务器停止发送事件，客户端会将其视为连接错误，并重试连接。如果您的应用程序中服务器知道它何时发送完所有事件，这可能有点烦人。解决这个问题的方法是从服务器发送一个空的<code class="fe ma mb mc md b">close</code>事件，并在收到该事件时关闭客户端连接。</p><figure class="mq mr ms mt gt jr"><div class="bz fp l di"><div class="mu mv l"/></div></figure><h1 id="b054" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">事件流和HTTP1</h1><p id="c9c9" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">然而，使用事件流还有最后一个问题:因为事件流保持连接打开，所以您需要通过HTTP2连接运行它们，否则您将遇到最大打开连接数的问题。(在HTTP1中，每个域的最大连接数只有6个。)</p><h1 id="8d01" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">结论</h1><p id="633b" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">我希望这篇文章能让您对服务器端事件如何工作以及如何实现它们有所了解。你怎么看，服务器端事件在polling和SignalR旁边有一席之地吗？(是的，我知道SignalR也使用服务器端事件作为不支持websockets时的后备。)</p></div></div>    
</body>
</html>