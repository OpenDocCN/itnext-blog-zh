<html>
<head>
<title>Responsive design at different levels in Flutter</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">颤振中不同层次的响应设计</h1>
<blockquote>原文：<a href="https://itnext.io/responsive-design-at-different-levels-in-flutter-197443e7f50?source=collection_archive---------4-----------------------#2021-04-14">https://itnext.io/responsive-design-at-different-levels-in-flutter-197443e7f50?source=collection_archive---------4-----------------------#2021-04-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="b2ed" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">响应式设计对于那些希望使用单一代码库面向不同平台的人来说非常重要。这对于颤振的发展尤其如此，因为颤振的目标是所有主要的平台。</p><h1 id="e9d2" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">如何做响应式设计？</h1><p id="16fe" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">颤振响应设计可以用许多方法来实现。最简单的方法是使用MediaQuery小部件获取当前屏幕信息:</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="a1ce" class="lx km iq lt b gy ly lz l ma mb">Size screenSize = MediaQuery.of(context).size;<br/>Orientation orientation = MediaQuery.of(context).orientation;</span></pre><p id="009e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，基于这些信息，以不同的方式构建您的小部件。</p><p id="ef65" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">或者您可以使用一个软件包来简化这个过程。它们通常为您提供如下界面:</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="e2da" class="lx km iq lt b gy ly lz l ma mb">ResponsiveBuilder(<br/>    builder: (context, sizingInformation) {<br/>      <em class="mc">// Check the sizing information here and return your UI</em><br/>          <strong class="lt ir">if</strong> (sizingInformation.deviceScreenType == DeviceScreenType.desktop) {<br/>          <strong class="lt ir">return</strong> Container(color:Colors.blue);<br/>        }<br/><br/>        <strong class="lt ir">if</strong> (sizingInformation.deviceScreenType == DeviceScreenType.tablet) {<br/>          <strong class="lt ir">return</strong> Container(color:Colors.red);<br/>        }<br/><br/>        <strong class="lt ir">if</strong> (sizingInformation.deviceScreenType == DeviceScreenType.watch) {<br/>          <strong class="lt ir">return</strong> Container(color:Colors.yellow);<br/>        }<br/><br/>        <strong class="lt ir">return</strong> Container(color:Colors.purple);<br/>      },<br/>    },<br/>  );<br/>}</span></pre><p id="cd96" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">或者为您提供一些预定义的屏幕类型:</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="ea24" class="lx km iq lt b gy ly lz l ma mb">ScreenTypeLayout.builder(<br/>  mobile: (BuildContext context) =&gt; Container(color:Colors.blue),<br/>  tablet: (BuildContext context) =&gt; Container(color:Colors.yellow),<br/>  desktop: (BuildContext context) =&gt; Container(color:Colors.red),<br/>  watch: (BuildContext context) =&gt; Container(color:Colors.purple),<br/>);</span></pre><p id="0cad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">(以上代码示例来自<a class="ae md" href="https://pub.dev/packages/responsive_builder" rel="noopener ugc nofollow" target="_blank"> responsive_builder </a>包)。</p><h1 id="3816" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">受材料状态属性启发的不同界面</h1><p id="fea9" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">我们希望在编写响应性代码时实现良好的灵活性。有时候我们只是希望单个值(比如GridView中的crossAxisCount整数)是灵活的。有时，我们希望不同的屏幕有完全不同的UI设计(例如，移动设备的TabBarView和桌面设备的Row)。因此，我们应该能够让一个<strong class="jp ir">整数</strong>或一个<strong class="jp ir">小部件</strong>做出响应，而不需要反复编写if/switch语句。此外，人们对在哪里设置断点持有不同的意见。所以我们应该让人们轻松地定义自己的断点。</p><p id="43a2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">内置的材质组件(如ElevatedButton)根据它是被按下、悬停还是被选择来改变它们的外观。这些组件不使用单一颜色实例作为它们的背景色。相反，它们使用MaterialStateProperty，这将根据组件的内部状态生成不同的颜色值。</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="1124" class="lx km iq lt b gy ly lz l ma mb">property?.resolve(_states)</span></pre><p id="b530" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们使用一个类似的接口进行响应会怎么样？</p><p id="c43f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一个状态现在将是一些我们想要作为目标的屏幕配置。我把它命名为屏幕范围:</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="3be7" class="lx km iq lt b gy ly lz l ma mb">class ScreenScope {<br/>  final double minWidth;<br/>  final double maxWidth;<br/>  final double minHeight;<br/>  final double maxHeight;<br/>  final Orientation? orientation;<br/>  ...<br/>}</span></pre><p id="679e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我提供了一些预定义的屏幕范围:</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="70c9" class="lx km iq lt b gy ly lz l ma mb">mobileScreenScope (0px - 480px width)<br/>tabletScreenScope (480px - 840px width)<br/>desktopScreenScope (840px -  width)<br/><br/>mobilePortraitScreenScope (0px - 480px width, portrait)<br/>tabletPortraitScreenScope (480px - 840px width, portrait)<br/>desktopPortraitScreenScope (840px - width, portrait)<br/><br/>mobileLandscapeScreenScope (0px - 840px width, landscape)<br/>tabletLandscapeScreenScope (840px - 1200px width, landscape)<br/>desktopLandscapeScreenScope (1200px - width, landscape)</span></pre><figure class="lo lp lq lr gt mf gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi me"><img src="../Images/f35cd4e1373e496485c01497913cee8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IN8ZRTTZInuvXSnXMsgbWA.png"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">具有2个断点和不同方向的屏幕镜</figcaption></figure><p id="fe04" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果只使用一个断点:</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="962f" class="lx km iq lt b gy ly lz l ma mb">smallScreenScope (0px - 600px width)<br/>bigScreenScope (600px -  width)<br/><br/>smallPortraitScreenScope (0px - 600px width, portrait)<br/>bigPortraitScreenScope (600px - width, portrait)<br/><br/>smallPortraitScreenScope (0px - 1000px width, landscape)<br/>bigPortraitScreenScope (1000px - width, landscape)</span></pre><p id="7165" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后声明一个响应实例，并通过对其调用resolve来获取实际值。</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="7f68" class="lx km iq lt b gy ly lz l ma mb">GridView.count(<br/>  crossAxisSpacing: 10,<br/>  mainAxisSpacing: 10,<br/>  crossAxisCount: Responsive({<br/>        mobileScreenScope: 2,<br/>        tabletScreenScope: 4,<br/>        desktopScreenScope: 6<br/>      }).resolve(context)!,<br/>  children: List.generate(<br/>      30,<br/>      (index) =&gt;<br/>          Container(color: Colors.<em class="mc">green</em>, child: Text("SOME TEXT"))),<br/>);</span></pre><figure class="lo lp lq lr gt mf gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi mq"><img src="../Images/20ff90d16914c865ad2014b374e3cc04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*xqxkSToX8zhC6gQgWnvT4Q.gif"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">响应式网格</figcaption></figure><p id="d164" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您想在不同的屏幕上使用不同的小工具:</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="232e" class="lx km iq lt b gy ly lz l ma mb">Widget widget = Responsive({<br/>    mobileScreenScope: mobileWidget,<br/>    tabletScreenScope: tabletWidget,<br/>    desktopScreenScope: desktopWidget,<br/>  }).resolve(context);</span></pre><p id="7c16" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我还创建了一个叫做ScreenBuilder的助手小工具，可以帮你节省一些时间:</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="7a39" class="lx km iq lt b gy ly lz l ma mb">ScreenBuilder(<br/>  mobile: mobile,<br/>  tablet: tablet,<br/>  desktop: desktop,<br/>  );<br/><br/>ScreenBuilder.builder(<br/>  mobileBuilder: mobileBuilder,<br/>  tabletBuilder: tabletBuilder,<br/>  desktopBuilder: desktopBuilder,<br/>  )</span></pre><p id="ed44" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">构建器语法使用WidgetBuilder，因此您可以访问BuildContext。</p><figure class="lo lp lq lr gt mf gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi mq"><img src="../Images/cdf10a39177f3e736a70b2d389369189.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*nUIRz9sbETXZ4J-jWg4TGQ.gif"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">响应式wiget生成器</figcaption></figure><h1 id="d747" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">结论</h1><p id="b543" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">这就是<a class="ae md" href="https://pub.dev/packages/responsive_property" rel="noopener ugc nofollow" target="_blank"> responsive_property </a>包。目标很简单:响应性设计的灵活性，同时避免您编写if语句。如果您有任何建议或发现任何bug，请随时在Github上打开问题。谢谢大家！</p></div></div>    
</body>
</html>