<html>
<head>
<title>Reflecting business logic rules into the domain models using typescript — Part 3</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用typescript将业务逻辑规则反映到域模型中—第3部分</h1>
<blockquote>原文：<a href="https://itnext.io/reflecting-business-logic-rules-into-the-domain-models-using-typescript-part-3-aa8998bc6d29?source=collection_archive---------1-----------------------#2020-08-02">https://itnext.io/reflecting-business-logic-rules-into-the-domain-models-using-typescript-part-3-aa8998bc6d29?source=collection_archive---------1-----------------------#2020-08-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/a86e0f73d52fa2b9de709cf5d33b222f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-d4vOE2IRgxqMEM1VJSciw.jpeg"/></div></div></figure><p id="2143" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上一篇文章中，我们声明了类型并创建了一个函数来创建和验证类型。</p><p id="7cf7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是如果我们想要为我们想要使用的每个模型创建这些函数和验证器，这将花费太多的时间。</p><p id="272d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本文中，我们将使用<code class="fe kx ky kz la b">io-ts</code>库来自动化这些枯燥的任务。</p><div class="lb lc gp gr ld le"><a href="https://github.com/gcanti/io-ts" rel="noopener  ugc nofollow" target="_blank"><div class="lf ab fo"><div class="lg ab lh cl cj li"><h2 class="bd ir gy z fp lj fr fs lk fu fw ip bi translated">gcanti/io-ts</h2><div class="ll l"><h3 class="bd b gy z fp lj fr fs lk fu fw dk translated">为了安装稳定版，发布了实验性特性(*)，以便从…获得早期反馈</h3></div><div class="lm l"><p class="bd b dl z fp lj fr fs lk fu fw dk translated">github.com</p></div></div><div class="ln l"><div class="lo l lp lq lr ln ls jw le"/></div></div></a></div><p id="77f7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">期末专题可以在这里找到:</p><div class="lb lc gp gr ld le"><a href="https://github.com/mohsensaremi/reflecting-business-logic-rules-into-the-domain-models/tree/using-io-ts" rel="noopener  ugc nofollow" target="_blank"><div class="lf ab fo"><div class="lg ab lh cl cj li"><h2 class="bd ir gy z fp lj fr fs lk fu fw ip bi translated">mohsensaremi/将业务逻辑规则反映到领域模型中</h2><div class="ll l"><h3 class="bd b gy z fp lj fr fs lk fu fw dk translated">为mohsensaremi/reflecting-business-logic-rules-into-domain-models开发作出贡献，方法是创建一个关于…的帐户</h3></div><div class="lm l"><p class="bd b dl z fp lj fr fs lk fu fw dk translated">github.com</p></div></div><div class="ln l"><div class="lt l lp lq lr ln ls jw le"/></div></div></a></div><h1 id="2eff" class="lu lv iq bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">装置</h1><pre class="ms mt mu mv gt mw la mx my aw mz bi"><span id="791f" class="na lv iq la b gy nb nc l nd ne">yarn add io-ts fp-ts</span></pre><p id="617e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">那么什么是<code class="fe kx ky kz la b">fp-ts</code>？</p><p id="eb29" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe kx ky kz la b">fp-ts</code>是typescript的函数式编程工具，是<code class="fe kx ky kz la b">io-ts</code>的对等依赖。</p><p id="6f3b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本文中，我们不打算讨论函数式编程。</p><p id="62f8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们只讨论一点关于单子。</p><h1 id="8600" class="lu lv iq bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">多媒体数字信号编解码器</h1><p id="14f6" class="pw-post-body-paragraph jy jz iq ka b kb nf kd ke kf ng kh ki kj nh kl km kn ni kp kq kr nj kt ku kv ij bi translated"><code class="fe kx ky kz la b">io-ts</code>用一种叫做编解码器的东西来代表我们的类型。</p><p id="a3cd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">编解码器具有<code class="fe kx ky kz la b">decode</code>和<code class="fe kx ky kz la b">encode</code>功能。</p><p id="e0c0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们使用<code class="fe kx ky kz la b">decode</code>函数创建并验证输入数据，并使用<code class="fe kx ky kz la b">encode</code>函数将数据恢复正常。</p><p id="6d28" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">编解码器看起来是这样的:</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="f268" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，我们来谈谈泛型类型。</p><h2 id="f4c4" class="na lv iq bd lw nm nn dn ma no np dp me kj nq nr mi kn ns nt mm kr nu nv mq nw bi translated">通用类型A</h2><p id="ca03" class="pw-post-body-paragraph jy jz iq ka b kb nf kd ke kf ng kh ki kj nh kl km kn ni kp kq kr nj kt ku kv ij bi translated">这就是我们正在建模的。例如在<code class="fe kx ky kz la b">String50</code>类型中，<code class="fe kx ky kz la b">A</code>代表:</p><pre class="ms mt mu mv gt mw la mx my aw mz bi"><span id="2bab" class="na lv iq la b gy nb nc l nd ne">{<br/>     kind: "String50",<br/>     value: string,<br/>}</span></pre><h2 id="8832" class="na lv iq bd lw nm nn dn ma no np dp me kj nq nr mi kn ns nt mm kr nu nv mq nw bi translated">普通O型</h2><p id="463d" class="pw-post-body-paragraph jy jz iq ka b kb nf kd ke kf ng kh ki kj nh kl km kn ni kp kq kr nj kt ku kv ij bi translated">这是输出类型。这表明当我们想要将数据传递给其他人时，数据应该是什么样子。</p><p id="da44" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，我们需要返回<code class="fe kx ky kz la b">String50</code>作为API响应。我们应该转换这种类型:</p><pre class="ms mt mu mv gt mw la mx my aw mz bi"><span id="7699" class="na lv iq la b gy nb nc l nd ne">{<br/>     kind: "String50",<br/>     value: string,<br/>}</span></pre><p id="456f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">来点正常的<code class="fe kx ky kz la b">string</code>。</p><p id="97a3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以这个例子中的输出类型是<code class="fe kx ky kz la b">string</code>。</p><h2 id="9daa" class="na lv iq bd lw nm nn dn ma no np dp me kj nq nr mi kn ns nt mm kr nu nv mq nw bi translated">通用类型I</h2><p id="ce44" class="pw-post-body-paragraph jy jz iq ka b kb nf kd ke kf ng kh ki kj nh kl km kn ni kp kq kr nj kt ku kv ij bi translated">这是输入类型。它指明了我们的类型可以验证什么样的数据。</p><p id="76a7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通常是<code class="fe kx ky kz la b">unknown</code>型。因为我们想从每一个可能的数据中制作和验证我们的类型。我们不限制输入数据。</p></div><div class="ab cl nx ny hu nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="ij ik il im in"><p id="a351" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们知道了泛型类型。先说构造函数。</p><p id="f243" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要创建一个编解码器，我们需要4个参数。</p><h2 id="fe25" class="na lv iq bd lw nm nn dn ma no np dp me kj nq nr mi kn ns nt mm kr nu nv mq nw bi translated">名字</h2><p id="059b" class="pw-post-body-paragraph jy jz iq ka b kb nf kd ke kf ng kh ki kj nh kl km kn ni kp kq kr nj kt ku kv ij bi translated">编解码器的名称</p><h2 id="727f" class="na lv iq bd lw nm nn dn ma no np dp me kj nq nr mi kn ns nt mm kr nu nv mq nw bi translated">类型-高斯函数</h2><p id="d3cf" class="pw-post-body-paragraph jy jz iq ka b kb nf kd ke kf ng kh ki kj nh kl km kn ni kp kq kr nj kt ku kv ij bi translated">这个函数接收未知的输入，并评估输入是否是类型<code class="fe kx ky kz la b">A</code>(记住<code class="fe kx ky kz la b">A</code>是我们的建模类型，就像<code class="fe kx ky kz la b">String50</code>)</p><h2 id="2275" class="na lv iq bd lw nm nn dn ma no np dp me kj nq nr mi kn ns nt mm kr nu nv mq nw bi translated">验证功能</h2><p id="2483" class="pw-post-body-paragraph jy jz iq ka b kb nf kd ke kf ng kh ki kj nh kl km kn ni kp kq kr nj kt ku kv ij bi translated">这个函数就像上一篇文章中的<code class="fe kx ky kz la b">make...</code>函数。它接收一个类型为<code class="fe kx ky kz la b">I</code>(输入类型通常为<code class="fe kx ky kz la b">unknown</code>)的参数，并尝试验证和创建该类型。</p><p id="8379" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果输入有效，它将返回<code class="fe kx ky kz la b">t.success</code>。否则将返回<code class="fe kx ky kz la b">t.failiur</code>。</p><h2 id="7b0c" class="na lv iq bd lw nm nn dn ma no np dp me kj nq nr mi kn ns nt mm kr nu nv mq nw bi translated">编码功能</h2><p id="270a" class="pw-post-body-paragraph jy jz iq ka b kb nf kd ke kf ng kh ki kj nh kl km kn ni kp kq kr nj kt ku kv ij bi translated">该函数接收类型为<code class="fe kx ky kz la b">A</code>(我们的建模类型)的参数，并返回类型为<code class="fe kx ky kz la b">O</code>(编解码器的输出类型)的参数。</p><p id="0a50" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，它将接收一个<code class="fe kx ky kz la b">String50</code>并返回一个正常的<code class="fe kx ky kz la b">string</code>。</p></div><div class="ab cl nx ny hu nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="ij ik il im in"><p id="5fc8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们使用codec逐个定义我们的基本类型。</p><h1 id="4316" class="lu lv iq bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">String50Codec编解码器</h1><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="a4d1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通用类型:</p><ul class=""><li id="b3cd" class="oe of iq ka b kb kc kf kg kj og kn oh kr oi kv oj ok ol om bi translated"><code class="fe kx ky kz la b">A</code> = &gt; <code class="fe kx ky kz la b">String50</code></li><li id="f6be" class="oe of iq ka b kb on kf oo kj op kn oq kr or kv oj ok ol om bi translated"><code class="fe kx ky kz la b">O</code> = &gt; <code class="fe kx ky kz la b">string</code></li><li id="f119" class="oe of iq ka b kb on kf oo kj op kn oq kr or kv oj ok ol om bi translated"><code class="fe kx ky kz la b">I</code> = &gt; <code class="fe kx ky kz la b">unknown</code></li></ul><p id="b157" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">type-guard函数检查输入值的形状，类似于<code class="fe kx ky kz la b">String50</code>。</p><p id="354a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">验证函数检查输入是否为字符串，最大长度为50。这个函数是我们检查业务逻辑规则的地方。<br/>如果输入有效，则返回成功，否则返回失败。</p><p id="048a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">编码函数应该返回一个<code class="fe kx ky kz la b">string</code>。所以只需要归还<code class="fe kx ky kz la b">String50</code>的<code class="fe kx ky kz la b">value</code>财产。</p><p id="95ee" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">再来说说验证函数。</p><p id="ce2d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上一篇文章中，我们使用了<code class="fe kx ky kz la b">CustomTypeError</code>异常来表示故障状态。<br/>但是这里我们返回<code class="fe kx ky kz la b">t.success</code>和<code class="fe kx ky kz la b">t.failure</code>。这些函数是实际值的包装器。</p><p id="bce8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我们尝试使用编解码器的<code class="fe kx ky kz la b">decode</code>函数来验证输入时，它不会为无效输入抛出错误。而是会返回一个<code class="fe kx ky kz la b">Either</code>。</p><p id="70eb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">什么是要么？</p><p id="2d3a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe kx ky kz la b">Either</code>是一个函数式编程单子。我们在这里不讨论函数式编程。</p><p id="9215" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">把一个<code class="fe kx ky kz la b">Either</code>想象成一个围绕值的盒子。它有两种状态。<code class="fe kx ky kz la b">left</code>和<code class="fe kx ky kz la b">right</code>状态。我们用<code class="fe kx ky kz la b">Either.left</code>表示失败状态，用<code class="fe kx ky kz la b">Eihter.right</code>表示成功状态。</p><p id="6387" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">就当<code class="fe kx ky kz la b">right</code>是成功状态，<code class="fe kx ky kz la b">left</code>是失败状态吧。</p><p id="3d70" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，如果输入有效，验证函数返回<code class="fe kx ky kz la b">right</code>，如果输入无效，则返回<code class="fe kx ky kz la b">left</code>。</p><p id="9d3d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将定义下一个编解码器。</p><h1 id="0fdd" class="lu lv iq bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">EmailCodec</h1><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="nk nl l"/></div></figure><h1 id="2163" class="lu lv iq bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">后酒精分解</h1><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="nk nl l"/></div></figure><h1 id="c61b" class="lu lv iq bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">EmailAndPostalCodeCodec</h1><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="aafb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里我们使用了来自<code class="fe kx ky kz la b">io-ts</code>的<code class="fe kx ky kz la b">t.type</code>来创建<code class="fe kx ky kz la b">EmailAndPostalCodeCodec</code>。</p><p id="5943" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它组成<code class="fe kx ky kz la b">EmailCodec</code>和<code class="fe kx ky kz la b">PostalCodeCodec</code>来创建新的编解码器。</p><p id="b1ec" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在是定义<code class="fe kx ky kz la b">PersonCodec</code>的时候了。</p><h1 id="acf9" class="lu lv iq bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">个人编解码器</h1><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="4d1a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上一篇文章中，我们将<code class="fe kx ky kz la b">ContactInfo</code>定义为:</p><pre class="ms mt mu mv gt mw la mx my aw mz bi"><span id="9546" class="na lv iq la b gy nb nc l nd ne">ContactInfo =<br/>    | Email<br/>    | PostalCode<br/>    | EmailAndPostalCode</span></pre><p id="601b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它是一个联合类型，并且<code class="fe kx ky kz la b">io-ts</code>有一个将这种类型转换成编解码器的功能。它叫<code class="fe kx ky kz la b">t.union</code>。</p><p id="f8e2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe kx ky kz la b">t.union</code>接收编解码器数组并返回联合类型编解码器。</p><p id="af1b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们的<code class="fe kx ky kz la b">PersonCodec</code>完成了。让我们用这些编解码器进行测试。</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="5e79" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如你所见，我们移除了<code class="fe kx ky kz la b">try catch</code>块。</p><p id="ffbf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">相反，我们有一个从<code class="fe kx ky kz la b">decode</code>函数返回的<code class="fe kx ky kz la b">personEither</code>。<br/>它是一个<code class="fe kx ky kz la b">Either</code>单子，可以是<code class="fe kx ky kz la b">right</code>(表示成功)或<code class="fe kx ky kz la b">left</code>(表示失败)</p><p id="c25b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们使用<code class="fe kx ky kz la b">fp-ts/Either</code>库中的<code class="fe kx ky kz la b">isRight</code>函数检查它是否正确。</p><p id="c8c2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">记得我说过<code class="fe kx ky kz la b">Either</code>就像一个围绕实际值的盒子。因此，为了获得实际的个人价值，我们使用<code class="fe kx ky kz la b">personEither.right</code>来获得个人。</p><p id="a15f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们打印了个人价值和个人编码价值。</p><p id="4c55" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe kx ky kz la b">PathReporter</code>是一个显示错误细节的实用函数。</p><p id="291a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们看看输出:</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="21d0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您会看到编码后的值就像一个可以传递给其他人的普通值(例如，作为API响应返回)。</p><p id="3f59" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">而<code class="fe kx ky kz la b">PathReporter</code>显示了更详细的错误。您可以找到导致错误的值和字段。</p></div><div class="ab cl nx ny hu nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="ij ik il im in"><p id="fbcc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是将业务逻辑规则反映到领域模型中的最后一部分。</p><p id="5eef" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我希望你能从这些文章中学到一些东西，写出更干净的、自文档化的代码。</p><p id="1e7d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你对编写干净且人类可读的代码感兴趣，我强烈推荐你学习函数式编程，并在日常项目中使用<code class="fe kx ky kz la b">fp-ts</code>库。</p></div></div>    
</body>
</html>