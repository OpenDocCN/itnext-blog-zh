<html>
<head>
<title>Advantages of not using Spring Data and Hibernate with relational data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">对关系数据不使用Spring数据和Hibernate的优势</h1>
<blockquote>原文：<a href="https://itnext.io/advantages-of-not-using-spring-data-and-hibernate-with-relational-data-8a509faf0c48?source=collection_archive---------0-----------------------#2022-07-19">https://itnext.io/advantages-of-not-using-spring-data-and-hibernate-with-relational-data-8a509faf0c48?source=collection_archive---------0-----------------------#2022-07-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="63d6" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">为什么Spring Data JPA非常适合带有空数据库的演示应用程序</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f75ef18822a58933b1c5e56dcf08368f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*M72zIr-3Fkp2I2WS"/></div></div></figure><p id="ce5c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Spring Data是存储数据的常用技术之上的附加层。Spring Data JPA是Spring Data最常用的部分，它应该通过消除重复出现的代码来简化基于JPA的代码。本质上，Spring Data JPA是一种隐藏了<code class="fe lq lr ls lt b">EntityManager</code>的JPA。</p><p id="2b1a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这篇文章中，我想探讨Spring Data JPA对加载关系数据的支持。默认情况下，Spring Data JPA依赖于Hibernate。由于Spring Data JPA的一些限制是由Hibernate造成的，所以我另外用一个更强大的JPA实现EclipseLink来评估Spring Data JPA。</p><p id="6538" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我比较了几种从MySQL数据库的小型Sakila示例模式加载数据的方法。比较方法:</p><ul class=""><li id="b69a" class="lu lv it kw b kx ky la lb ld lw lh lx ll ly lp lz ma mb mc bi translated">我计算执行的SQL查询的数量。默认情况下，JPA实现对每个父实体执行一个查询。</li><li id="7ef5" class="lu lv it kw b kx md la me ld mf lh mg ll mh lp lz ma mb mc bi translated">我测量加载数据所需的时间。时间取决于不必要的<code class="fe lq lr ls lt b">select</code>的数量。</li><li id="c6f7" class="lu lv it kw b kx md la me ld mf lh mg ll mh lp lz ma mb mc bi translated">我检查加载的数据是否被正确地转换成实体。</li><li id="7472" class="lu lv it kw b kx md la me ld mf lh mg ll mh lp lz ma mb mc bi translated">我检查数据是否分类正确。众所周知，Hibernate会打乱加载的关系数据的顺序，但是知道<code class="fe lq lr ls lt b">findAll(Sort)</code>是否与关系数据兼容是很有趣的。</li></ul><p id="b17f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在我的实验中，我使用了三个类<code class="fe lq lr ls lt b">Actor</code>、<code class="fe lq lr ls lt b">Film</code>和<code class="fe lq lr ls lt b">Category</code>，它们被映射到Sakila示例模式的五个表:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mi"><img src="../Images/bb63dcd4dc7b07987fd0ef362d1aa83d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3w3NKk1EjSYWcZIt"/></div></div></figure><p id="2d48" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">关系图是指一个演员可以出演多部电影，每部电影可以包括多个演员。重复使用相同的类别来对电影进行分类。每部电影可以属于许多类别。数据包括200名演员，1000部电影和16个类别。我用三个实体加载数据:</p><pre class="kj kk kl km gt mj lt mk ml aw mm bi"><span id="207b" class="mn mo it lt b gy mp mq l mr ms">@Entity<br/>public class Actor {</span><span id="4130" class="mn mo it lt b gy mt mq l mr ms">    @Id<br/>    int actorId;</span><span id="7c2b" class="mn mo it lt b gy mt mq l mr ms">    String firstName;<br/>    String lastName;</span><span id="a4e3" class="mn mo it lt b gy mt mq l mr ms">    @ManyToMany<br/>    <strong class="lt iu">Set&lt;Film&gt; films;</strong><br/>}</span><span id="3089" class="mn mo it lt b gy mt mq l mr ms">@Entity<br/>public class Film {</span><span id="59e2" class="mn mo it lt b gy mt mq l mr ms">    @Id<br/>    int filmId;<br/>    String title;</span><span id="d62c" class="mn mo it lt b gy mt mq l mr ms">    @ManyToMany<br/>    <strong class="lt iu">Set&lt;Category&gt; categories;</strong><br/>}</span><span id="2f9a" class="mn mo it lt b gy mt mq l mr ms">@Entity<br/>public class Category {</span><span id="71d5" class="mn mo it lt b gy mt mq l mr ms">    @Id<br/>    int categoryId;<br/>    String name;<br/>}</span></pre><p id="cbba" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">表中包含的列比我加载的多。为了简化代码，我只加载最有意义的列。</p><p id="bdbf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae mu" href="https://marian-caikovski.medium.com/efficiently-loading-associations-with-jdbc-hibernate-and-eclipselink-20ee88584938" rel="noopener">还要注意Hibernate毫无意义的局限性。有了一个</a> <code class="fe lq lr ls lt b"><a class="ae mu" href="https://marian-caikovski.medium.com/efficiently-loading-associations-with-jdbc-hibernate-and-eclipselink-20ee88584938" rel="noopener">select</a></code> <a class="ae mu" href="https://marian-caikovski.medium.com/efficiently-loading-associations-with-jdbc-hibernate-and-eclipselink-20ee88584938" rel="noopener">，嵌套关联只能加载到</a> <code class="fe lq lr ls lt b"><a class="ae mu" href="https://marian-caikovski.medium.com/efficiently-loading-associations-with-jdbc-hibernate-and-eclipselink-20ee88584938" rel="noopener">Set</a></code> <a class="ae mu" href="https://marian-caikovski.medium.com/efficiently-loading-associations-with-jdbc-hibernate-and-eclipselink-20ee88584938" rel="noopener"> s中，这种像差在EclipseLink中是不存在的。与<code class="fe lq lr ls lt b">Set</code>不同的是，<code class="fe lq lr ls lt b">List</code>保存了加载数据的顺序，并允许通过方法<code class="fe lq lr ls lt b">get()</code>简单地访问它们的元素。</a></p><h2 id="e811" class="mn mo it bd mv mw mx dn my mz na dp nb ld nc nd ne lh nf ng nh ll ni nj nk nl bi translated">几种不同的方法加载所有演员与相关的电影和类别</h2><p id="ab8d" class="pw-post-body-paragraph ku kv it kw b kx nm ju kz la nn jx lc ld no lf lg lh np lj lk ll nq ln lo lp im bi translated">首先，作为开始和参考结果，我将使用一个纯粹的基于JDBC的代码。然后我评估<code class="fe lq lr ls lt b">JpaRepository</code>的<code class="fe lq lr ls lt b">findAll()</code>和<code class="fe lq lr ls lt b">findAll(Sort)</code>方法。为了说明由于Spring Data JPA依赖于一个过时的Hibernate版本而导致存储库产生的一些偏差，我将Spring Data使用的Hibernate 5.6.9与现代的Hibernate 6进行了比较。然后我评估用<code class="fe lq lr ls lt b">@Query</code>注释修饰的两个方法。最后，我展示了像<code class="fe lq lr ls lt b">findByFirstName()</code>这样好看的存储库方法会生成大量可有可无的查询。</p><p id="bf9d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">以下是数字结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/5f7672417fc0bcafaee311e2a63fe8e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9vwWTks91vGnI35F"/></div></div><figcaption class="ns nt gj gh gi nu nv bd b be z dk translated">冬眠</figcaption></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/b2e679dd30c9a4092ad46d69405fb478.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n-pFsm9s-fSJKo59tCp6BQ.png"/></div></div><figcaption class="ns nt gj gh gi nu nv bd b be z dk translated">EclipseLink</figcaption></figure><p id="79c5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Hibernate和EclipseLink有一些相似之处。如果您查看标记为<code class="fe lq lr ls lt b">rep.query()</code>的行，您会看到一个JPQL查询足以加载所有数据。<code class="fe lq lr ls lt b">findAll()</code>产生大量可有可无的查询，因此速度很慢。<code class="fe lq lr ls lt b">findAll(Sort)</code>另外返回异常的演员数。基本上，不管底层JPA实现如何，<code class="fe lq lr ls lt b">JpaRepository</code>接口的两种方法对于关系数据都不是很有用。</p><p id="c2ae" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我展示了加载数据的顺序，并在下面更详细地讨论了数值结果。但在此之前，我必须解释我是如何收集它们的，以便它们看起来可信。</p><h2 id="6f6e" class="mn mo it bd mv mw mx dn my mz na dp nb ld nc nd ne lh nf ng nh ll ni nj nk nl bi translated">测量方法执行时间和计数由Hibernate或EclipseLink执行的选择</h2><p id="4510" class="pw-post-body-paragraph ku kv it kw b kx nm ju kz la nn jx lc ld no lf lg lh np lj lk ll nq ln lo lp im bi translated">在web应用程序中，通常加载数据以进行显示。要显示数据，必须完全加载。JPA延迟加载<em class="nx">多对多</em>关联，也就是说，当它们被访问时会逐渐加载。为了比较加载完整数据所需的时间，我的基准测试代码访问了所有加载的actors中的所有嵌套类别。</p><p id="b669" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有几种巧妙的方法来计算最不必要的数字。我用了最简单的方法。我通过将<code class="fe lq lr ls lt b">spring.jpa.properties.hibernate.show_sql=true</code>或<code class="fe lq lr ls lt b">spring.jpa.properties.eclipselink.logging.level=FINE</code>分别添加到<em class="nx"> application.properties </em>来打开Hibernate或EclipseLink日志记录。然后，我简单地在标准输出中计算以<code class="fe lq lr ls lt b">Hibernate: select</code>或<code class="fe lq lr ls lt b">[EL Fine]: sql: SELECT</code>开头的行。</p><p id="c302" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">代码测量每个方法的执行时间15次。但是只有最后10次测量用于计算平均时间。代码很简单，但是太长了，看起来不清楚。你可以在<a class="ae mu" href="https://github.com/marianc000/SpringDataJpaRepositories" rel="noopener ugc nofollow" target="_blank"> GitHub </a>里看到。</p><h2 id="f091" class="mn mo it bd mv mw mx dn my mz na dp nb ld nc nd ne lh nf ng nh ll ni nj nk nl bi translated">用纯JDBC加载关系数据</h2><p id="4d03" class="pw-post-body-paragraph ku kv it kw b kx nm ju kz la nn jx lc ld no lf lg lh np lj lk ll nq ln lo lp im bi translated">与依赖于JPA等其他层的代码相比，纯JDBC代码有一个优势——一旦开发出来，当任何依赖关系升级时，它的测试都不会失败。</p><p id="7778" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">使用JDBC，所有数据都可以通过一个SQL查询加载:</p><pre class="kj kk kl km gt mj lt mk ml aw mm bi"><span id="2dd8" class="mn mo it lt b gy mp mq l mr ms">select a.actor_id, a.first_name,a.last_name, f.film_id, f.title,<br/>c.category_id, c.name from actor a<br/>left join film_actor using(actor_id)<br/>left join film f using(film_id)<br/>left join film_category using(film_id)<br/>left join category c using(category_id)<br/><strong class="lt iu">order by a.last_name,a.first_name, f.title, c.name</strong></span></pre><p id="565e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意，我希望数据按演员姓名、电影名称和最终类别名称排序。如果使用JDBC或EclipseLink，这可以通过<code class="fe lq lr ls lt b">order by</code>子句实现。</p><p id="357e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有许多方法可以将一个连接产品分解成相关的实体。用Java流可以很方便地做到这一点。使用定制的泛型收集器，代码变得更加简单。你可以在<a class="ae mu" href="https://github.com/marianc000/SpringDataJpaRepositories" rel="noopener ugc nofollow" target="_blank"> GitHub </a>中看到代码。我没有在这里展示它，因为代码仍然相对较长，正如您在基准测试结果中看到的，它并不比类似的基于JPA的代码快多少。流是方便的，但是与大量的通用辅助代码相关联，因此很慢。</p><p id="261d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">加载并正确排序的数据的第一行:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/b40b588e9aade42b68199fb95e5f2b80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ktZAZXTlr1Oh6nZs"/></div></div></figure><p id="d22a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这与本文无关，但请注意，尽管模式包括电影和类别之间的多对多关系，但Sakila数据库中没有一部电影与多个类别相关联。</p><h2 id="343c" class="mn mo it bd mv mw mx dn my mz na dp nb ld nc nd ne lh nf ng nh ll ni nj nk nl bi translated">由于不合理的选择数，findAll()很慢</h2><p id="e5d8" class="pw-post-body-paragraph ku kv it kw b kx nm ju kz la nn jx lc ld no lf lg lh np lj lk ll nq ln lo lp im bi translated">通常情况下，<code class="fe lq lr ls lt b">JpaRepository</code>中的<code class="fe lq lr ls lt b">findAll()</code>应该只用于没有关系的实体。如果加载的实体有关联，<code class="fe lq lr ls lt b">findAll()</code>可能会成功导致应用程序挂起。在我对不切实际的微小数据的实验中，<code class="fe lq lr ls lt b">findAll()</code>方法只需要比JDBC或JPA方法多4倍的时间。它的大部分执行时间都花在执行1198个<code class="fe lq lr ls lt b">select</code>上(1个<code class="fe lq lr ls lt b">select</code>加载演员，200个<code class="fe lq lr ls lt b">select</code>加载影片，997个<code class="fe lq lr ls lt b">select</code>加载类别)。如果数据库包含更真实的数据量，或者如果数据库不在<em class="nx">本地主机上，</em>执行时间会长得多。可有可无的渐进查询不是Spring数据的问题，而是JPA的一个奇怪特性——每个父实体执行一个查询。</p><h2 id="6668" class="mn mo it bd mv mw mx dn my mz na dp nb ld nc nd ne lh nf ng nh ll ni nj nk nl bi translated">findAll(Sort)不会排序并返回太多</h2><p id="8dd6" class="pw-post-body-paragraph ku kv it kw b kx nm ju kz la nn jx lc ld no lf lg lh np lj lk ll nq ln lo lp im bi translated">我猜像低效的<code class="fe lq lr ls lt b">findAll()</code>返回的数据那样加载未排序的数据是很少被接受的。即使数据在浏览器中被重新排序以响应用户输入，对于第一次呈现来说，拥有排序的数据也是很好的。Spring数据存储库提供了一个方法<code class="fe lq lr ls lt b">findAll(Sort)</code>,用于检索排序后的数据。在执行时间上，和<code class="fe lq lr ls lt b">findAll()</code>一样低效。奇怪的是，它返回一个有5462个参与者的<code class="fe lq lr ls lt b">List</code>,而不是预期的200个。</p><p id="4df6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在我的代码中，调用该方法时使用:</p><pre class="kj kk kl km gt mj lt mk ml aw mm bi"><span id="d89b" class="mn mo it lt b gy mp mq l mr ms">@GetMapping("/findAllSorted")<br/>List&lt;Actor&gt; findAllSorted() {<br/>    return <strong class="lt iu">rep.findAll(Sort.by("lastName", "firstName", "films.title", "films.categories.name"));</strong><br/>}</span></pre><p id="3ccc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">它能成功地按作者的姓和名对他们进行分类，但不能按电影名对其进行分类。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/af369f65d13fcef503b1001d81ab331a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9LTDXv2oz9K_OOxA"/></div></div></figure><p id="2d13" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这一个问题是由Hibernate引起的，因为用EclipseLink的顺序是正确的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/eb74484ea0dabeea51c7ac166fbce21b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZBGBfosbfD4hQG1RwaCgcA.png"/></div></div></figure><h2 id="3c5b" class="mn mo it bd mv mw mx dn my mz na dp nb ld nc nd ne lh nf ng nh ll ni nj nk nl bi translated">现代Hibernate不正确地处理提取连接</h2><p id="e069" class="pw-post-body-paragraph ku kv it kw b kx nm ju kz la nn jx lc ld no lf lg lh np lj lk ll nq ln lo lp im bi translated">在讨论用JPQL查询获得的结果之前，我需要演示Spring数据使用的现代Hibernate 6和过时的Hibernate 5之间的一个重要区别。Hibernate 6不兼容Spring数据，勉强兼容Spring。</p><p id="7ce9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">JPA有时确实可以简化代码。所有作者都可以加载一个比上面等价的SQL查询更短的JPQL查询。加载所有角色的代码比基于JDBC的代码要短得多。</p><pre class="kj kk kl km gt mj lt mk ml aw mm bi"><span id="14ed" class="mn mo it lt b gy mp mq l mr ms">@Repository<br/>public class ActorJpaRepository {</span><span id="6f60" class="mn mo it lt b gy mt mq l mr ms">    @Autowired<br/>    private EntityManager em;</span><span id="60bd" class="mn mo it lt b gy mt mq l mr ms">    public List&lt;Actor&gt; getAll() {<br/>        return em.createQuery("<strong class="lt iu">SELECT a FROM Actor a LEFT JOIN FETCH a.films f LEFT JOIN FETCH f.categories c order by a.lastName, a.firstName, f.title,c.name</strong>", Actor.class).getResultList();<br/>    }<br/>}</span></pre><p id="4eea" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">除了<em class="nx"> fetch joins </em>之外，Hibernate没有提供其他有效加载相关实体的方法。不幸的是，同样的代码在Hibernate 6和Hibernate 5中会产生不同的结果。</p><p id="fa38" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在上面的结果表中可以看到，Spring Data使用的过时Hibernate使用一个<code class="fe lq lr ls lt b">select</code>来加载所有数据，它与JDBC代码一样快，但是它返回一个具有5462个参与者而不是200个参与者的<code class="fe lq lr ls lt b">List</code>。这是JPA的一个特性——根据JPA规范，<em class="nx"> fetch joins </em>必须产生和joins一样多的结果。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/94999c5d4695ca10b4c683ec35db6e2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*L2CSRFZqunwR-3ec"/></div></div></figure><p id="e502" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">相比之下，Hibernate 6返回正确的参与者数量。根据常识，这是方便和正确的，但是根据JPA规范，这是不正确的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/eeafd7b1717d5899abaaac09ea95f925.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gmwqkNiWu-vjpZuX"/></div></div></figure><p id="7981" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Hibernate的两个版本都没有保留由<code class="fe lq lr ls lt b">order by</code>子句设置的顺序。</p><h2 id="df80" class="mn mo it bd mv mw mx dn my mz na dp nb ld nc nd ne lh nf ng nh ll ni nj nk nl bi translated">为什么要使用存储库接口来执行JPQL查询</h2><p id="af1f" class="pw-post-body-paragraph ku kv it kw b kx nm ju kz la nn jx lc ld no lf lg lh np lj lk ll nq ln lo lp im bi translated">可以使用存储库接口来执行JPQL查询。在存储库中，可以用<code class="fe lq lr ls lt b">@Query</code>注释指定查询。</p><pre class="kj kk kl km gt mj lt mk ml aw mm bi"><span id="8fd3" class="mn mo it lt b gy mp mq l mr ms">@Repository<br/>public interface ActorRepository extends JpaRepository&lt;Actor, Integer&gt; {</span><span id="def2" class="mn mo it lt b gy mt mq l mr ms">    @Query("SELECT a FROM Actor a LEFT JOIN FETCH a.films f LEFT JOIN FETCH f.categories c order by a.lastName, a.firstName, f.title, c.name")<br/>    List&lt;Actor&gt; query();<br/>}</span></pre><p id="6774" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">代码看起来并不比上面等价的基于JPA的代码短。与上面的JPA方法一样，它产生了5462个异常的<code class="fe lq lr ls lt b">List</code>。</p><p id="75b4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">EclipseLink不支持嵌套的<em class="nx">获取连接</em>，但是可以使用<em class="nx">查询提示</em>。使用EclipseLink，结果要好得多——200个正确排序的演员。让我们看看JPA代码之间是否有很大的区别:</p><pre class="kj kk kl km gt mj lt mk ml aw mm bi"><span id="dcbd" class="mn mo it lt b gy mp mq l mr ms">@Repository<br/>public class ActorJpaRepository {</span><span id="93b6" class="mn mo it lt b gy mt mq l mr ms">    @Autowired<br/>    EntityManager em;</span><span id="b23e" class="mn mo it lt b gy mt mq l mr ms">    public List&lt;Actor&gt; getAll () {<br/>        return em.createQuery("<strong class="lt iu">SELECT a FROM Actor a LEFT JOIN a.films f LEFT JOIN f.categories c order by a.lastName, a.firstName, f.title, c.name</strong>", Actor.class).setHint("<strong class="lt iu">eclipselink.left-join-fetch</strong>", "<strong class="lt iu">a.films.categories</strong>").getResultList();<br/>    }<br/>}</span></pre><p id="6d05" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">和等效的弹簧数据JPA代码:</p><pre class="kj kk kl km gt mj lt mk ml aw mm bi"><span id="7816" class="mn mo it lt b gy mp mq l mr ms">@Repository<br/>public interface ActorRepository extends JpaRepository&lt;Actor, Integer&gt; {</span><span id="c1fa" class="mn mo it lt b gy mt mq l mr ms">    @Query("SELECT a FROM Actor a LEFT JOIN a.films f LEFT JOIN f.categories c order by a.lastName, a.firstName, f.title, c.name")<br/>    @QueryHints({@QueryHint(name = "eclipselink.left-join-fetch", value = "a.films.categories")})<br/>    List&lt;Actor&gt; query();<br/>}</span></pre><p id="2a62" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当然，与Hibernate不同，EclipseLink返回有序数据:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/583eb6cc26b0c7ff46d51bc52889d394.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*njDYkoA-Rym_ZDPxjw5rEA.png"/></div></div></figure><p id="bf47" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以看起来Spring Data JPA并没有用JPQL查询简化代码。在JPQL查询中使用Spring数据JPA是没有意义的。</p><h2 id="cfde" class="mn mo it bd mv mw mx dn my mz na dp nb ld nc nd ne lh nf ng nh ll ni nj nk nl bi translated">如何对Spring数据JPA使用fetch连接</h2><p id="3da2" class="pw-post-body-paragraph ku kv it kw b kx nm ju kz la nn jx lc ld no lf lg lh np lj lk ll nq ln lo lp im bi translated">在Spring Data JPA开始支持更现代的Hibernate之前，<em class="nx"> fetch joins </em>的异常结果可以通过在JPQL查询中添加关键字<code class="fe lq lr ls lt b">distinct</code>来改善。</p><pre class="kj kk kl km gt mj lt mk ml aw mm bi"><span id="4a9b" class="mn mo it lt b gy mp mq l mr ms">@Repository<br/>public interface ActorRepository extends JpaRepository&lt;Actor, Integer&gt; {</span><span id="e629" class="mn mo it lt b gy mt mq l mr ms">    @Query("SELECT <strong class="lt iu">distinct</strong> a FROM Actor a LEFT JOIN FETCH a.films f LEFT JOIN FETCH f.categories c order by a.lastName, a.firstName, f.title, c.name")<br/>    List&lt;Actor&gt; queryDistinct();<br/>}</span></pre><p id="dbf2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，查询产生了预期数量的实体。但是正如Hibernate所预期的，它们没有被正确排序。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/30e76a551c1c055af39b4a1fc652f979.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*v80AQLRpjXbPSMeJ"/></div></div></figure><h2 id="067c" class="mn mo it bd mv mw mx dn my mz na dp nb ld nc nd ne lh nf ng nh ll ni nj nk nl bi translated">好看但低效的查询方法</h2><p id="5b05" class="pw-post-body-paragraph ku kv it kw b kx nm ju kz la nn jx lc ld no lf lg lh np lj lk ll nq ln lo lp im bi translated">我的数字结果表中的最后一行只是用来说明查询方法是有代价的——它们会产生大量不必要的耗费时间的渐进<code class="fe lq lr ls lt b">select</code>。</p><h1 id="6f2c" class="oe mo it bd mv of og oh my oi oj ok nb jz ol ka ne kc om kd nh kf on kg nk oo bi translated">结论</h1><p id="8b20" class="pw-post-body-paragraph ku kv it kw b kx nm ju kz la nn jx lc ld no lf lg lh np lj lk ll nq ln lo lp im bi translated">如果你知道如何使用它，JPA可以简化代码，而且比纯JDBC慢不了多少。Spring帮助处理事务。Spring Data JPA是JPA和Spring之上的附加层。除了用接口中的方法名定义低效查询的奇特方式之外，还不清楚它带来了什么。</p><p id="0ced" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">存储库接口可以有两种类型的方法——名称定义JPQL查询的方法(例如<code class="fe lq lr ls lt b">findByFirstName()</code>)和返回用<code class="fe lq lr ls lt b">@Query</code>注释指定的JPQL查询结果的方法。</p><p id="cdb1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当使用几乎没有数据的内存中的H2数据库时，这并不明显，但是花哨的存储库接口方法是有代价的——它们最慢。如果使用关系数据库存储关系数据，低效的名称查询方法不能替代JPQL查询。</p><p id="72fc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是使用额外的Spring数据JPA依赖来执行JPQL查询是没有意义的。没有Spring数据的等价代码JPA不会更长，有时可以使用不可或缺的<code class="fe lq lr ls lt b">EntityManager</code>方法，比如缺少存储库接口的<code class="fe lq lr ls lt b">detach()</code>或<code class="fe lq lr ls lt b">persist()</code>。</p><p id="a664" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Spring Data JPA的一些问题是Hibernate的局限性造成的。当与关系数据一起使用时，Hibernate不保留JPQL查询中由<code class="fe lq lr ls lt b">order by</code>子句设置的顺序。因此，低效的方法<code class="fe lq lr ls lt b">findAll(Sort)</code>不会排序，除非用EclipseLink替换Hibernate。奇怪的是，Spring Data JPA依赖的JPA实现似乎并不完全兼容Spring Data JPA提供的方法。</p><p id="5e1a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">总的来说，Spring Data JPA最适合带有空数据库的演示应用程序。</p></div><div class="ab cl op oq hx or" role="separator"><span class="os bw bk ot ou ov"/><span class="os bw bk ot ou ov"/><span class="os bw bk ot ou"/></div><div class="im in io ip iq"><p id="20a1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">代码可以从<a class="ae mu" href="https://github.com/marianc000/SpringDataJpaRepositories" rel="noopener ugc nofollow" target="_blank">https://github.com/marianc000/SpringDataJpaRepositories</a>下载</p><p id="610f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">不要犹豫留下评论</p></div></div>    
</body>
</html>