<html>
<head>
<title>Writing a Custom Resource for Concourse— Detecting Pull Request Close/Merge Events</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为Concourse编写自定义资源—检测拉式请求关闭/合并事件</h1>
<blockquote>原文：<a href="https://itnext.io/writing-a-custom-resource-for-concourse-detecting-pull-request-close-merge-events-e40468eb2a81?source=collection_archive---------3-----------------------#2018-03-25">https://itnext.io/writing-a-custom-resource-for-concourse-detecting-pull-request-close-merge-events-e40468eb2a81?source=collection_archive---------3-----------------------#2018-03-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/40d1bcc04ef7c0ab20697bf51dcc7e64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f4MKPENYpjAyRkVfKVoTOA.png"/></div></div></figure><blockquote class="jy jz ka"><p id="8c85" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><a class="ae la" href="https://www.linkedin.com/cws/share?url=https%3A%2F%2Fitnext.io%2Fwriting-a-custom-resource-for-concourse-detecting-pull-request-close-merge-events-e40468eb2a81%3Futm_source%3Dmedium_sharelink%26utm_medium%3Dsocial%26utm_campaign%3Dbuffer" rel="noopener ugc nofollow" target="_blank">点击这里在LinkedIn </a>上分享这篇文章</p></blockquote><p id="9c2d" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">最近我一直在玩优秀的<a class="ae la" href="https://concourse-ci.org/" rel="noopener ugc nofollow" target="_blank">广场CI </a>项目。这是一个非常酷的项目，作为一个开源的CI/CD解决方案已经获得了很多关注。请看<a class="ae la" href="https://concourse-ci.org/concourse-vs.html" rel="noopener ugc nofollow" target="_blank">这一页</a>了解为什么Concourse如此出色，以及它与其他CI/CD解决方案相比如何。</p><p id="378d" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">在Concourse内部，所有的交互都是通过<a class="ae la" href="https://concourse-ci.org/concepts.html" rel="noopener ugc nofollow" target="_blank">资源和工作</a>来完成的。它的模型是<em class="kd">功能性的</em>在某种意义上，流水线是由无状态的作业组成的，这些作业具有由资源建模的明确定义的输入和输出。一切都在它自己的容器中运行，这防止了任务间自动化环境的任何污染。为了让作业中的任何步骤共享任何内容，必须明确定义输入和输出。这有时会有点乏味，但它让管道内部发生的一切都非常清晰。所有这些特性使它非常适合用作CI/CD解决方案，因为它防止了许多导致构建中断的更神秘和令人沮丧的问题。</p><h1 id="4a8d" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">主旨和动机</h1><p id="40e2" class="pw-post-body-paragraph kb kc iq ke b kf mc kh ki kj md kl km lb me kp kq lc mf kt ku ld mg kx ky kz ij bi translated">使用任何种类的自动化系统实现CI/CD都需要系统与Github等源代码控制解决方案中发生的事件进行交互。特别是，触发CI/CD系统的一个更常见的事件是拉请求。Pivotal的社区和Concourse的维护人员一直都很好，为大多数情况提供资源。已经有一个优秀的<code class="fe mh mi mj mk b"><a class="ae la" href="https://github.com/jtarchie/github-pullrequest-resource" rel="noopener ugc nofollow" target="_blank">github-pullrequest-resource</a></code>可以用来处理Github pull请求，但是有一种情况<a class="ae la" href="https://github.com/jtarchie/github-pullrequest-resource/issues/128" rel="noopener ugc nofollow" target="_blank">没有真正处理，那就是检测已经被合并或关闭的pull请求的能力</a>。</p><p id="2138" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">当以这样一种方式对CI/CD建模时，这可能是有用的，即打开的PR为应用源代码创建一个部署环境，而关闭的或合并的PR启动该环境的清理以回收资源。这种类型的流在云平台中特别有用，在云平台中，成本是按使用计费的，因此平台只在有开放的拉取请求时使用资源。这是我在当前使用Concourse的项目中真正需要的一个用例，所以我决定借此机会深入一点，编写我自己的定制资源，并希望记录这个过程，以便对其他人有用。对于tldr请查看<a class="ae la" href="https://github.com/shinmyung0/pullrequest-events-resource" rel="noopener ugc nofollow" target="_blank">项目回购。</a></p><h1 id="97ef" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">了解Concourse资源</h1><p id="0306" class="pw-post-body-paragraph kb kc iq ke b kf mc kh ki kj md kl km lb me kp kq lc mf kt ku ld mg kx ky kz ij bi translated">在我们开始之前，我们应该先试着理解如何为Concourse实现一个定制资源。我不想在这里深入讨论这个规范，但是基本上一个Concourse资源只是一个实现三个脚本的容器:</p><ul class=""><li id="2c6f" class="ml mm iq ke b kf kg kj kk lb mn lc mo ld mp kz mq mr ms mt bi translated"><code class="fe mh mi mj mk b">/opt/resource/check</code>:检查资源的新版本</li><li id="d457" class="ml mm iq ke b kf mu kj mv lb mw lc mx ld my kz mq mr ms mt bi translated"><code class="fe mh mi mj mk b">/opt/resource/in</code>:拉下资源的一个版本</li><li id="5448" class="ml mm iq ke b kf mu kj mv lb mw lc mx ld my kz mq mr ms mt bi translated"><code class="fe mh mi mj mk b">/opt/resource/out</code>:幂等推一个版本上去</li></ul><p id="81ec" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">所有的资源都应该实现这3个脚本，但是它们并不都必须做些什么。对于不符合资源语义的操作，脚本可以是一个noop。就我们的资源而言，我们实际上只需要实现<code class="fe mh mi mj mk b">check</code>和<code class="fe mh mi mj mk b">in</code>脚本，因为我们并没有从关闭或合并的拉请求中更新任何东西，只是获取关于它们的信息并触发下游作业。</p><h1 id="c5b7" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">了解<code class="fe mh mi mj mk b">check script</code></h1><p id="dc8e" class="pw-post-body-paragraph kb kc iq ke b kf mc kh ki kj md kl km lb me kp kq lc mf kt ku ld mg kx ky kz ij bi translated">现在我们已经了解了我们需要为这个资源实现哪些脚本，让我们更深入地了解一下规范，以了解<code class="fe mh mi mj mk b">check</code>应该为这个资源做些什么。分解规格:</p><ul class=""><li id="5400" class="ml mm iq ke b kf kg kj kk lb mn lc mo ld mp kz mq mr ms mt bi translated">调用资源类型的<code class="fe mh mi mj mk b">check</code>脚本来检测资源的新版本。</li><li id="4e18" class="ml mm iq ke b kf mu kj mv lb mw lc mx ld my kz mq mr ms mt bi translated">在stdin上给出了<code class="fe mh mi mj mk b">source</code>配置和电流<code class="fe mh mi mj mk b">version</code>。</li><li id="6fdb" class="ml mm iq ke b kf mu kj mv lb mw lc mx ld my kz mq mr ms mt bi translated"><code class="fe mh mi mj mk b">source</code>是一个任意的JSON对象，它指定资源的位置，包括任何凭证。这是从<a class="ae la" href="http://concourse-ci.org/configuring-resources.html" rel="noopener ugc nofollow" target="_blank">管道配置</a>中逐字传递过来的。</li><li id="7a66" class="ml mm iq ke b kf mu kj mv lb mw lc mx ld my kz mq mr ms mt bi translated"><code class="fe mh mi mj mk b">version</code>是一个带有<code class="fe mh mi mj mk b">string</code>字段的JSON对象，用来惟一地标识资源的一个实例。</li><li id="8b17" class="ml mm iq ke b kf mu kj mv lb mw lc mx ld my kz mq mr ms mt bi translated">这将在第一个请求中省略，在这种情况下，资源应该返回当前版本(<em class="kd">而不是</em>自资源开始以来的每个版本)。</li><li id="03da" class="ml mm iq ke b kf mu kj mv lb mw lc mx ld my kz mq mr ms mt bi translated">它必须按时间顺序将新版本的数组打印到stdout，包括请求的版本(如果它仍然有效的话)。</li></ul><p id="ed95" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">上面的规范基本上是说，Concourse运行时将使用类似下面的命令来运行脚本:</p><pre class="mz na nb nc gt nd mk ne nf aw ng bi"><span id="b210" class="nh lf iq mk b gy ni nj l nk nl">echo {...source config json...} | /opt/resource/check</span></pre><p id="dd72" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">对于第一次<code class="fe mh mi mj mk b">check</code>调用，脚本的输入将只包括<code class="fe mh mi mj mk b">source</code>配置，但是在随后的请求中，<code class="fe mh mi mj mk b">check</code>脚本也将被传递<em class="kd">当前</em>T5】，它告诉资源返回<em class="kd">下一个</em>有效<code class="fe mh mi mj mk b">version</code>对象。</p><p id="5520" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">有了这个规范，我们可以开始设计我们的<code class="fe mh mi mj mk b">source</code>配置和<code class="fe mh mi mj mk b">version</code>对象应该是什么样子。</p><h1 id="ee1e" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">定义版本和源配置</h1><p id="0591" class="pw-post-body-paragraph kb kc iq ke b kf mc kh ki kj md kl km lb me kp kq lc mf kt ku ld mg kx ky kz ij bi translated">因为我们想从Github返回关于关闭和合并的pull请求的信息，所以让我们试着理解哪种信息是可用的。因为Github提供了<a class="ae la" href="https://developer.github.com/v4/" rel="noopener ugc nofollow" target="_blank">一个优秀的GraphQL API </a>,我们可以使用<a class="ae la" href="https://developer.github.com/v4/explorer/" rel="noopener ugc nofollow" target="_blank"> explorer </a>来做一些探索，看看我们可以从pull请求中获取什么样的数据。经过一些试验，我想到了下面的GraphQL查询:</p><figure class="mz na nb nc gt jr"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="fe7b" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">因为我们的查询将是运行<code class="fe mh mi mj mk b">check</code>脚本所需要的，所以我们几乎可以使用输入参数(带有一些用于凭证和API端点的附加字段)作为我们的<code class="fe mh mi mj mk b">source</code>配置的字段:</p><pre class="mz na nb nc gt nd mk ne nf aw ng bi"><span id="c270" class="nh lf iq mk b gy ni nj l nk nl">source:<br/>  graphql_api: <a class="ae la" href="https://api.github.com/graphql" rel="noopener ugc nofollow" target="_blank">https://api.github.com/graphql</a><br/>  access_token: ((github-access-token))<br/>  base_branch: master<br/>  owner: ((github-owner))<br/>  repo: ((repo-name))<br/>  first: ((num-to-fetch))<br/>  states:<br/>    - closed<br/>    - merged</span></pre><p id="01cc" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">该查询将返回类似如下的有效负载:</p><figure class="mz na nb nc gt jr"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="5afa" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">基于这些信息，我们可以尝试返回一个类似下面的<code class="fe mh mi mj mk b">version</code>对象数组:</p><pre class="mz na nb nc gt nd mk ne nf aw ng bi"><span id="9db1" class="nh lf iq mk b gy ni nj l nk nl">{<br/>    "id": "MDExOlB1bGxSZXF1ZXN0MTcxMjQ5NjI1",<br/>    "cursor": "Y3Vyc29yOnYyOpK5MjAxOC0wMi0yNVQxMjozNDo0NC0wODowMM4KNQ/Z",<br/>    "number": "1",<br/>    "url": "<a class="ae la" href="https://github.com/shinmyung0/fixture-repo/pull/1" rel="noopener ugc nofollow" target="_blank">https://github.com/shinmyung0/fixture-repo/pull/1</a>",<br/>    "baseBranch": "master",<br/>    "headBranch": "test-merged-branch",<br/>    "state": "MERGED",<br/>    "timestamp": "2018-02-25T20:34:44Z"<br/>}</span></pre><p id="cd0f" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">需要强调的一些要点是像<code class="fe mh mi mj mk b">cursor</code>这样的字段，它可以被传递到我们的GraphQL查询的<code class="fe mh mi mj mk b">after</code>字段中，以便只返回特定光标之后的拉请求。因为“当前的”<code class="fe mh mi mj mk b">version</code>对象被传递到<code class="fe mh mi mj mk b">check</code>脚本中以获取“新的”<code class="fe mh mi mj mk b">version</code>对象，所以包含这个对象会很有用。</p><h1 id="d174" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">实现检查脚本</h1><p id="5ebb" class="pw-post-body-paragraph kb kc iq ke b kf mc kh ki kj md kl km lb me kp kq lc mf kt ku ld mg kx ky kz ij bi translated">现在我们对我们的<code class="fe mh mi mj mk b">check</code>脚本应该做什么有了一个清晰的想法，我们可以开始实际实现它了。因为我们知道只要满足规范，Concourse资源可以用任何语言编写，所以我们可以选择最适合我们工作的语言。因为我们使用的是GraphQL，所以我决定使用JS来实现它。处理异步网络调用很容易，处理JSON也很容易，而且现在有很多针对GraphQL的客户端库。我非常喜欢在JS中使用的GraphQL库是<a class="ae la" href="https://www.apollographql.com/docs/react/" rel="noopener ugc nofollow" target="_blank"> Apollo </a>。考虑到所有这些选择，<code class="fe mh mi mj mk b">check</code>脚本的伪代码应该是这样的:</p><pre class="mz na nb nc gt nd mk ne nf aw ng bi"><span id="1f93" class="nh lf iq mk b gy ni nj l nk nl">#! /usr/bin/env node</span><span id="90fd" class="nh lf iq mk b gy no nj l nk nl">// the shebang allows this file to be directly executable</span><span id="6e0c" class="nh lf iq mk b gy no nj l nk nl"><br/>async function check() {</span><span id="c0cc" class="nh lf iq mk b gy no nj l nk nl">  // read stdin<br/>  // parse and validate input json<br/>  // use configuration to run GraphQL query to fetch PRs<br/>  // convert response payload to version objects<br/>  // output to stdout</span><span id="3e09" class="nh lf iq mk b gy no nj l nk nl">}<br/><br/>check()</span></pre><p id="7a78" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">对于实际的实现，检查源代码<a class="ae la" href="https://github.com/shinmyung0/pullrequest-events-resource/blob/master/scripts/check" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><h1 id="a9e8" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">了解脚本中的</h1><p id="2682" class="pw-post-body-paragraph kb kc iq ke b kf mc kh ki kj md kl km lb me kp kq lc mf kt ku ld mg kx ky kz ij bi translated">让我们深入了解一下<code class="fe mh mi mj mk b">in</code>脚本的规格。</p><ul class=""><li id="c71e" class="ml mm iq ke b kf kg kj kk lb mn lc mo ld mp kz mq mr ms mt bi translated">将<code class="fe mh mi mj mk b">in</code>脚本作为<code class="fe mh mi mj mk b">$1</code>传递到目标目录。该脚本必须获取资源并将其放在给定的目录中。</li><li id="e5f2" class="ml mm iq ke b kf mu kj mv lb mw lc mx ld my kz mq mr ms mt bi translated">脚本在<code class="fe mh mi mj mk b">stdin</code>上给出了配置的<code class="fe mh mi mj mk b">source</code>和要获取的资源的精确<code class="fe mh mi mj mk b">version</code>。</li><li id="7118" class="ml mm iq ke b kf mu kj mv lb mw lc mx ld my kz mq mr ms mt bi translated">该脚本必须发出获取的版本，并且可以发出作为键值对列表的元数据。</li></ul><p id="1b04" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">基于这个规范，Concourse运行时将基本上以如下方式调用<code class="fe mh mi mj mk b">in</code>脚本:</p><pre class="mz na nb nc gt nd mk ne nf aw ng bi"><span id="3650" class="nh lf iq mk b gy ni nj l nk nl">echo {... some json ...} | /opt/resource/in outputdir</span></pre><p id="8c0f" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">因为我们的拉请求资源只是获取关于拉请求的<em class="kd">信息</em>,所以除了将<code class="fe mh mi mj mk b">version</code>对象输出为文件之外，我们不需要获取任何额外的东西。因此，我们可以说，上面执行<code class="fe mh mi mj mk b">in</code>脚本的结果将产生一些包含传递给<code class="fe mh mi mj mk b">stdin</code>的<code class="fe mh mi mj mk b">version</code>对象的<code class="fe mh mi mj mk b">outputdir/pull_request</code>文件。它也会发出电流<code class="fe mh mi mj mk b">version</code>到<code class="fe mh mi mj mk b">stdout</code>。</p><h1 id="9af3" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">在脚本中实现</h1><p id="42cb" class="pw-post-body-paragraph kb kc iq ke b kf mc kh ki kj md kl km lb me kp kq lc mf kt ku ld mg kx ky kz ij bi translated">基于我们对<code class="fe mh mi mj mk b">in</code>脚本应该做什么的理解，<code class="fe mh mi mj mk b">in</code>脚本的伪代码应该如下所示:</p><pre class="mz na nb nc gt nd mk ne nf aw ng bi"><span id="10bd" class="nh lf iq mk b gy ni nj l nk nl">#! /usr/bin/env node</span><span id="7c33" class="nh lf iq mk b gy no nj l nk nl">async function doIn() {</span><span id="b08e" class="nh lf iq mk b gy no nj l nk nl">  // read stdin, parse, and validate<br/>  // extract given .version key<br/>  // output version object to $1/pull_request file<br/>  // emit version to stdout</span><span id="fada" class="nh lf iq mk b gy no nj l nk nl">}</span><span id="18e7" class="nh lf iq mk b gy no nj l nk nl">doIn()</span></pre><p id="8497" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">下游作业可以读取<code class="fe mh mi mj mk b">$1/pull_request</code>文件，并提取关于最近关闭或合并的拉请求的信息。</p><h1 id="235f" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">写作测试</h1><p id="2ae1" class="pw-post-body-paragraph kb kc iq ke b kf mc kh ki kj md kl km lb me kp kq lc mf kt ku ld mg kx ky kz ij bi translated">由于我们使用的是Node JS，所以我们可以使用<a class="ae la" href="https://facebook.github.io/jest/" rel="noopener ugc nofollow" target="_blank"> Jest </a>轻松编写一些单元和集成测试。<a class="ae la" href="https://github.com/shinmyung0/pullrequest-events-resource/blob/master/scripts/common.test.js" rel="noopener ugc nofollow" target="_blank">单元测试</a>很容易编写，但是为了能够运行集成测试，我们需要<a class="ae la" href="https://github.com/shinmyung0/fixture-repo" rel="noopener ugc nofollow" target="_blank">设置一个fixture repo </a>和一些关闭或合并的pull请求来测试实际的API调用。</p><p id="179b" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">因为调用这个repo需要一个Github访问令牌，所以我们可以将它作为一个<a class="ae la" href="https://github.com/shinmyung0/pullrequest-events-resource/blob/master/scripts/integration.test.js#L10" rel="noopener ugc nofollow" target="_blank">环境变量传递给集成测试套件</a>。要做的一件好事是确保验证在测试中已经设置了访问令牌。查看测试代码，详细了解这是如何设置的。</p><h1 id="9bd2" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">CI/CD和发布到Docker Hub</h1><p id="23db" class="pw-post-body-paragraph kb kc iq ke b kf mc kh ki kj md kl km lb me kp kq lc mf kt ku ld mg kx ky kz ij bi translated">我们可以使用Travis CI轻松地为这个项目设置一些CI/CD。基本上，CI/CD工作需要做的就是运行所有测试，然后如果成功，提交被标记为发布，构建Docker映像，然后将其发布到公共Docker Hub。非常简单，所以我不会在这里进行过多的描述。但是如果你好奇，请查看一下<a class="ae la" href="https://github.com/shinmyung0/pullrequest-events-resource/blob/master/.travis.yml" rel="noopener ugc nofollow" target="_blank"> Travis CI配置</a>以及<a class="ae la" href="https://github.com/shinmyung0/pullrequest-events-resource/blob/master/build.sh" rel="noopener ugc nofollow" target="_blank">构建脚本</a>。</p><h1 id="6f24" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="1663" class="pw-post-body-paragraph kb kc iq ke b kf mc kh ki kj md kl km lb me kp kq lc mf kt ku ld mg kx ky kz ij bi translated">这是本月要发布的一个有趣的项目。这给了我一个很好的机会深入研究Concourse，这是我最近在工作中经常使用的东西。我对自己定期开源的能力越来越有信心，这也是我今年致力于做的事情。总的来说，Concourse是一个非常棒的项目，我强烈推荐给任何正在寻找一个非常好的CI/CD解决方案的团队。</p></div></div>    
</body>
</html>