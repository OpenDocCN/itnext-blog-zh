<html>
<head>
<title>React Native Performance Optimization and Profiling</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应本机性能优化和分析</h1>
<blockquote>原文：<a href="https://itnext.io/react-native-performance-optimization-and-profiling-5b586e9018f8?source=collection_archive---------0-----------------------#2018-03-24">https://itnext.io/react-native-performance-optimization-and-profiling-5b586e9018f8?source=collection_archive---------0-----------------------#2018-03-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/9c1c8d68b0d0cf9fc61e871511744f7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VaZlfSMNumzopToUZfGN_Q.jpeg"/></div></div></figure><p id="057f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">React Native是一项受工程师欢迎的技术，这些工程师正在寻求以一种高效的方式构建移动应用程序，而不牺牲本机性能。</p><p id="27b7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如今的设备都配备了多核CPU和大量内存。这对于处理大型数据集、计算密集型任务、丰富的交互式UI来说非常棒，我们的应用程序甚至会原谅我们没有考虑性能优化。这并不意味着在开发移动应用程序时不应该考虑性能。</p><p id="49ea" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我将分享我在React Native中应该注意的性能问题方面的经验。这些都是基于在<a class="ae kw" href="https://www.internations.org/" rel="noopener ugc nofollow" target="_blank">国际</a>使用React Native构建大型高性能移动应用程序的经验。我将强调常见的陷阱，并对可能出错的地方以及如何解决问题给出一个大致的理解。🖥 +🕵️‍♀️ +🔧=🚀。</p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><p id="cc23" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="le">在构建一个小型React原生应用的情况下，遇到性能问题的可能性当然相当低，我不建议过早优化。</em></p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h2 id="26a2" class="lf lg iq bd lh li lj dn lk ll lm dp ln kj lo lp lq kn lr ls lt kr lu lv lw lx bi translated">反应本地性能的状态</h2><p id="a819" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated">每次父组件收到新的道具或更新其状态时，React per default都会重新渲染组件，这是React构建UI的范例更优越的众多原因之一。这也是造成重复渲染浪费的原因。</p><p id="c01f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在React Native中，我们可以每秒更新60次帧。这为用户提供了流畅的本地体验。随着应用程序复杂性的增加，计算量也在增加。为了达到恒定的60 FPS，我们需要确保我们的UI永远不会被阻塞。不幸的是，JavaScript运行在一个<em class="le">单线程</em>环境中，相比之下<em class="le"> iOS </em>的<em class="le"> Swift/Objective-C </em>或者<em class="le">Java</em>/<em class="le">Kotlin</em>Android都支持<em class="le">多线程</em>。幸运的是，许多标准的React本地组件在一个独立的线程上执行，这个线程被称为<em class="le">主线程</em>。这真的很好，因为当JavaScript线程繁忙时，UI仍然会有响应。</p><p id="50bd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一个昂贵的用户交互可能是导航。假设用户正在多个屏幕之间切换。每个屏幕都在执行网络请求、计算数据、屏幕转换和导航动画。所有这些都发生在JavaScript线程上，那么应用程序的帧速率会显著下降(取决于复杂性)。我强烈建议将导航完全外包给主线程，这将极大地提高整体性能。寻找原生导航<a class="ae kw" href="https://github.com/wix/react-native-navigation" rel="noopener ugc nofollow" target="_blank">库</a>解决方案。</p><p id="8c5a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在React Native中有一个<em class="le">桥的概念，</em>它是连接本地世界和JavaScript端的东西。他们两个通过以<em class="le"> JSON </em>格式发送和接收数据进行通信。通过网桥来回发送数据可能非常昂贵，因为每次都需要对数据进行<em class="le">序列化</em>和<em class="le">反序列化</em>。</p><h2 id="b13a" class="lf lg iq bd lh li lj dn lk ll lm dp ln kj lo lp lq kn lr ls lt kr lu lv lw lx bi translated">测试性能问题</h2><p id="ed61" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated">可以使用<em class="le">性能监视器</em>来监视两个线程的当前帧速率，该监视器可以位于<a class="ae kw" href="https://facebook.github.io/react-native/docs/debugging.html#accessing-the-in-app-developer-menu" rel="noopener ugc nofollow" target="_blank">开发者菜单</a>下。</p><p id="3448" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">测量组件渲染的次数是绝对关键的。一个简单的方法就是在你的<em class="le"> render </em>方法中添加一个<em class="le"> console.count </em>调用。</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="0b65" class="lf lg iq mi b gy mm mn l mo mp">render() {<br/>  console.count('component')<br/>  return &lt;Component /&gt;<br/>}</span></pre><p id="d20c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您运行的是RN版本0.57或更高版本，您可以使用React Profiler。<br/>参见<a class="ae kw" href="https://github.com/facebook/react-devtools/blob/master/packages/react-devtools/README.md" rel="noopener ugc nofollow" target="_blank">文档</a>了解如何设置react-devtools，并阅读这篇<a class="ae kw" href="https://reactjs.org/blog/2018/09/10/introducing-the-react-profiler.html" rel="noopener ugc nofollow" target="_blank">帖子</a>了解如何配置组件渲染。</p><p id="89c0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最新的<em class="le"> Android Studio </em>和<em class="le"> Xcode </em>版本都提供了评测工具<em class="le">。尝试在运行时诊断您的内存消耗和CPU负载。在应用程序中导航或运行某些活动，以验证内存是否被分配给堆，并在不再使用时再次移除(希望如此)。还要留意CPU峰值，以识别计算繁重的任务。请参阅官方文档，了解关于平台特定评测工具<a class="ae kw" href="https://developer.android.com/studio/profile/memory-profiler.html" rel="noopener ugc nofollow" target="_blank"> Android </a>或<a class="ae kw" href="https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/InstrumentsUserGuide/MonitoringMemoryUsage.html" rel="noopener ugc nofollow" target="_blank"> iOS </a>的更多深入解释。</em></p><blockquote class="mq"><p id="3c78" class="mr ms iq bd mt mu mv mw mx my mz kv dk translated">构建软件时不注意内存泄漏会导致软件出现内存泄漏</p></blockquote><p id="2074" class="pw-post-body-paragraph jy jz iq ka b kb na kd ke kf nb kh ki kj nc kl km kn nd kp kq kr ne kt ku kv ij bi translated">对于运行内存不足的android应用程序，您可能希望通过在Android清单文件中添加<em class="le"> largeHeap </em>属性来请求更大的堆大小。点击查看更多详情<a class="ae kw" href="https://developer.android.com/guide/topics/manifest/application-element.html#largeHeap" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="bfb2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您正在将工作从JavaScript卸载到本机端，那么通过监控通过网络发送和接收消息的次数或者有效负载的大小来防止网桥过载。<a class="ae kw" href="https://github.com/facebook/react-native/blob/master/Libraries/BatchedBridge/MessageQueue.js" rel="noopener ugc nofollow" target="_blank"> <em class="le">消息队列</em> </a>让你调用一个间谍方法来观察<em class="le">桥</em>上的交通。一个好的起点是识别在桥上发送的包含很少到零大小的有效负载的消息，看看是否可以删除或替换消息的来源。例如，用于包装多个元素的空视图可以替换为<a class="ae kw" href="https://reactjs.org/docs/fragments.html" rel="noopener ugc nofollow" target="_blank"> React片段</a>。</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="565f" class="lf lg iq mi b gy mm mn l mo mp">import MessageQueue from 'react-native/Libraries/BatchedBridge/MessageQueue'</span><span id="76ae" class="lf lg iq mi b gy nf mn l mo mp">MessageQueue.spy(message =&gt; console.log('Message', message))</span></pre><h2 id="bb08" class="lf lg iq bd lh li lj dn lk ll lm dp ln kj lo lp lq kn lr ls lt kr lu lv lw lx bi translated">解决性能问题</h2><p id="0f0d" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated">用<a class="ae kw" href="https://reactjs.org/docs/react-api.html#reactpurecomponent" rel="noopener ugc nofollow" target="_blank"> <em class="le"> React保留不必要的重新渲染。PureComponent </em> </a> <em class="le">或</em><a class="ae kw" href="https://reactjs.org/docs/react-api.html#reactmemo" rel="noopener ugc nofollow" target="_blank"><em class="le">memo</em></a><em class="le">。</em>纯组件(不要与无状态函数组件混淆)将对其属性进行浅层比较，以确定是否需要重新渲染。对于更细粒度的控制，你应该使用<a class="ae kw" href="https://reactjs.org/docs/react-component.html#shouldcomponentupdate" rel="noopener ugc nofollow" target="_blank"><em class="le">shouldcomponentwupdate</em></a><em class="le"/>方法。</p><p id="c20f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有时我们希望更频繁地重新呈现，例如，假设您有一个呈现项目列表的组件，该列表从不同的用户输入接收新的<em class="le">道具</em>，如分页或下拉列表以刷新其数据。避免<em class="le">渲染</em>方法中的内联函数，它们将在每次渲染时被重新创建，并导致组件因属性改变而重新渲染，为了降低成本，命名该函数并将其存储在<em class="le">渲染</em>之外。</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="8e29" class="lf lg iq mi b gy mm mn l mo mp">class Component extends React.Component {<br/>  renderSectionHeader = () =&gt; &lt;View style={...} /&gt;</span><span id="6bd0" class="lf lg iq mi b gy nf mn l mo mp">render() {<br/>    return (<br/>      &lt;FlatList <br/>        renderSectionHeader={this.renderSectionHeader}<br/>        {...this.props}<br/>      /&gt;<br/>    )<br/>  }<br/>}</span></pre><p id="c57b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这篇文章中，了解更多关于如何避免无意义的重新渲染的不同技术和概念。</p><p id="64a5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您将状态提升到全局级别，那么状态变化的副作用可能会更大。对于我们这些使用<a class="ae kw" href="https://redux.js.org/" rel="noopener ugc nofollow" target="_blank"> Redux </a>和<a class="ae kw" href="https://redux.js.org/basics/usage-with-react" rel="noopener ugc nofollow" target="_blank"> React Connect </a>作为状态管理工具的人来说，应该注意每次状态改变时<em class="le">选择器</em>的重新运行。保护<em class="le">选择器</em>免于昂贵计算的一个好方法是缓存它们，这样如果它对状态的引用没有改变，它们就返回状态改变的前一个结果。这可以通过一个名为<a class="ae kw" href="https://github.com/reactjs/reselect" rel="noopener ugc nofollow" target="_blank"> Reselect </a>的便利库轻松实现。</p><p id="4937" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您仍然考虑在JavaScript端处理导航，或者您正在与动画中的丢帧现象作斗争。考虑给<a class="ae kw" href="https://facebook.github.io/react-native/docs/interactionmanager.html" rel="noopener ugc nofollow" target="_blank"> InteractionManager </a> API一个机会，例如推迟组件的渲染，直到所有用户交互或动画结束。</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="e209" class="lf lg iq mi b gy mm mn l mo mp">class AfterInteractions extends React.Component {</span><span id="84c0" class="lf lg iq mi b gy nf mn l mo mp">state = { interactions: true }<br/>  <br/>  componentDidMount() {<br/>    InteractionManager.runAfterInteractions(() =&gt; {<br/>      this.setState({ interactions: false })<br/>  }</span><span id="2d91" class="lf lg iq mi b gy nf mn l mo mp">render() {<br/>    if (interactions) {<br/>      return null<br/>    }<br/>    return this.props.children<br/>  }<br/>}</span></pre><p id="d93e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">React Native中的动画看起来很好，也很容易创建。使用<em class="le">动画</em>库可以启用<em class="le">本地驱动程序，</em>这将在动画开始前通过桥将动画发送到本地端。你的动画将在主线程上独立于被阻塞的JavaScript线程执行，这将导致更少的丢帧和更流畅的体验。将<a class="ae kw" href="https://facebook.github.io/react-native/blog/2017/02/14/using-native-driver-for-animated.html" rel="noopener ugc nofollow" target="_blank"> useNativeDriver </a>设置为动画配置。</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="aae7" class="lf lg iq mi b gy mm mn l mo mp">Animated.timing(<br/>  this.state.fadeAnim, {<br/>    toValue: 1,<br/>    useNativeDriver: true,<br/>  }<br/>).start()</span></pre><p id="68ef" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后但同样重要的是，图像。减小图像文件大小对保存用户数据计划、加快网络请求和减少内存占用是有意义的。Webp是一种值得考虑使用的压缩格式。将静态图像转移到本机将减少JavaScript包的大小，这是一件好事👍(但是，您将无法再随时为客户提供您的图像)。关于这个话题的更多细节可以在这里找到。</p><p id="c6b2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在React Native中开发可以让您受益于跨目标平台开发。同时为Android和iOS构建。根据我们的经验，两个平台之间的代码重用是惊人的。iOS上的内存布局与Android不同(自动引用计数而不是垃圾收集),这有助于iOS应用程序占用更少的内存。我们已经注意到，iOS的运行速度比Android快很多倍，而且消耗的内存更少。我建议，如果你的目标是在两个平台上发布，那么优先考虑Android。我希望这不是一件事，但根据我们的经验，如果Android运行流畅，那么iOS也会。</p><p id="6fee" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">不管是什么平台，在开发期间都应该在真实设备上不断进行测试。</strong>在使用模拟器时，确保在Android上激活<a class="ae kw" href="https://developer.android.com/studio/run/emulator-acceleration.html#avd-gpu" rel="noopener ugc nofollow" target="_blank">硬件加速器</a> <em class="le"> </em> it <em class="le"> </em>会大幅提升你模拟器的性能。</p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><p id="2cd9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">到目前为止，React Native在性能和优化工具方面的总体体验是积极的。你边走边学，你的应用程序总会有需要改进的地方。我期待着在React Native中继续开发，并看到社区如何继续改进这项伟大的技术。我希望在React Native中很快看到的一个改进是支持<em class="le">多线程</em>而不需要桥接数据。我可以想象我们在网络上使用的类似于<a class="ae kw" href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API" rel="noopener ugc nofollow" target="_blank"> <em class="le"> workers </em> </a>的东西。</p><p id="dbe4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">我希望你现在已经学到了一些新的东西，这将有助于加速你的原生应用</strong>！</p><p id="b2b4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我很乐意回答问题或讨论这里提到的任何话题。在下面留言或在twitter上找到我。</p></div></div>    
</body>
</html>