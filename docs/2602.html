<html>
<head>
<title>As a Software Developer, Why Should You Care about the Monotonic Clock?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">作为软件开发人员，为什么要关心单调的时钟呢？</h1>
<blockquote>原文：<a href="https://itnext.io/as-a-software-developer-why-should-you-care-about-the-monotonic-clock-7d9c8533595c?source=collection_archive---------1-----------------------#2019-06-22">https://itnext.io/as-a-software-developer-why-should-you-care-about-the-monotonic-clock-7d9c8533595c?source=collection_archive---------1-----------------------#2019-06-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/f693d6a1fe780eb199d303396511a832.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ztueGfLN8oz0BlZN3j1ivw.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">来源:<a class="ae kc" href="https://pixabay.com/" rel="noopener ugc nofollow" target="_blank"> pixabay </a></figcaption></figure><p id="aa2f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">先举个具体的例子。您是一名Java开发人员，想要测量一次执行的持续时间(时间间隔):</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="4868" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你没有注意到这段代码有什么问题，这篇文章值得一读。</p></div><div class="ab cl lh li hu lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ij ik il im in"><p id="f2ca" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一台计算机有两个不同的时钟。首先是<strong class="kf ir">挂钟</strong>，我们都知道它是用来获取一天的当前时间的。</p><p id="ce03" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该时钟可能会出现<strong class="kf ir">变化</strong>。比如和NTP(网络时间协议)同步的话。在这种情况下，在同步之后，我们服务器的本地时钟可以在时间上向后或向前跳<strong class="kf ir"/>。所以从挂钟上测量持续时间可能会有偏差。</p><p id="650a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第二个时钟被称为<strong class="kf ir">单调时钟</strong>。在这里，我们保证时间总是向前移动，不会受到导致时间跳跃的变化的影响。</p><p id="f109" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">唯一的变化是潜在的频率调整。基本上，如果我们的服务器检测到它的本地quartz比NTP服务器移动得快或慢，它可以调整它的时钟频率。但同样，单调时钟没有时间跳跃。</p><p id="22c3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，如果我们必须测量持续时间，我们必须使用单调时钟。这个经验法则只对<strong class="kf ir">本地持续时间测量</strong>有效。事实上，两个不同服务器的单调时钟根据定义是不同步的。因此，基于这些时钟来测量分布式执行是不准确的。</p><p id="83eb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们回到之前的例子。问题是因为在Java中，<code class="fe lo lp lq lr b">System.currentTimeMillis()</code>是基于挂钟的，所以会有变化，甚至是负的持续时间。相比之下，<code class="fe lo lp lq lr b">System.nanoTime()</code>是单调的，所以我们应该使用这个。</p><p id="13be" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">比如像Go这样的另一种语言呢？获取持续时间的标准方法基于以下代码:</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="c536" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lo lp lq lr b">time.Sub(time.Duration)</code>实际上是基于根据<a class="ae kc" href="https://golang.org/pkg/time/#hdr-Monotonic_Clocks" rel="noopener ugc nofollow" target="_blank">文档</a>的单调时钟。</p><p id="c04e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">作为结论，您应该检查您的编程语言如何处理这两个不同的时钟，以确保您的持续时间实际上是准确的。</p><figure class="lb lc ld le gt jr gh gi paragraph-image"><div class="gh gi ls"><img src="../Images/1be1009eeb21be8dacfbf3afe8e56b10.png" data-original-src="https://miro.medium.com/v2/resize:fit:384/format:webp/1*Y9Gm4W5rGboaalEE5hZyhQ.png"/></div></figure><h1 id="90be" class="lt lu iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">进一步阅读</h1><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="mr lg l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">Reddit对其他语言的讨论</figcaption></figure><div class="ms mt gp gr mu mv"><a href="https://linux.die.net/man/2/clock_gettime" rel="noopener  ugc nofollow" target="_blank"><div class="mw ab fo"><div class="mx ab my cl cj mz"><h2 class="bd ir gy z fp na fr fs nb fu fw ip bi translated">clock_gettime - Linux手册页</h2><div class="nc l"><h3 class="bd b gy z fp na fr fs nb fu fw dk translated">函数clock_getres()查找指定时钟clk_id的分辨率(精度),如果res不为空…</h3></div><div class="nd l"><p class="bd b dl z fp na fr fs nb fu fw dk translated">linux.die.net</p></div></div></div></a></div><figure class="lb lc ld le gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ne"><img src="../Images/b6578984dc018c44134738b9e16e76e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ni3QlYv1zjIZfJkxFYTzmA.png"/></div></div></figure><figure class="lb lc ld le gt jr gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/ec9b9710329661db6caf375f69308521.png" data-original-src="https://miro.medium.com/v2/resize:fit:256/format:webp/1*8kh8D7Gu7uPHxI0aaqGrZA.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">在推特上关注我<a class="ae kc" href="https://twitter.com/teivah" rel="noopener ugc nofollow" target="_blank"> @teivah </a></figcaption></figure></div></div>    
</body>
</html>