<html>
<head>
<title>Automating API Testing with Newman</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Newman自动化API测试</h1>
<blockquote>原文：<a href="https://itnext.io/automating-api-testing-with-newman-1e5d0aabcec?source=collection_archive---------1-----------------------#2022-01-12">https://itnext.io/automating-api-testing-with-newman-1e5d0aabcec?source=collection_archive---------1-----------------------#2022-01-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/b7d5af4a8b092fa11f733a2eec64007e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ctswWflPGj1mtarb"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">米克·豪普特在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="2661" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">目前，我正在开发的产品有一个传统的质量保证(QA)团队，当工程师完成他们的工作后，它会进入QA队列等待..有些时候任何人都不喜欢太长的时间，但这就是我们今天的过程。</p><p id="619c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们一直在寻找加快向我们的平台交付特性和错误修复的方法。在过去的6个月里，我花了太多的时间试图弄清楚别人是如何做到一个月/一年发布成百上千个版本的。在那段时间里，我不认为我读过一篇关于团队如何实现高速度的文章，他们也有一个传统的QA周期，包括人工审查。</p><p id="d3bd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是我们追求速度的一大进步！</p><h1 id="e319" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">你好，纽曼</h1><p id="448e" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">后来有一天，我的一个同事发给我一个链接，链接指向<a class="ae kf" href="https://github.com/postmanlabs/newman" rel="noopener ugc nofollow" target="_blank">纽曼</a> GitHub回购。纽曼是一个CLI工具，允许您运行邮差收集。它被构建为集成到CI/CD或任何其他您想要的脚本中。</p><p id="766a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">许多团队成员已经使用Postman进行了一些测试，所以它看起来很适合。现在我们所需要的是邮差收集我们在平台中的每一个微服务。</p><p id="2dbb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">顺便说一句，我不知道这是不是故意的，但如果你记得《宋飞正传》中的纽曼，是的，他实际上是一名邮递员！</p><h1 id="93f9" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">邮递员收藏</h1><p id="386f" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我为平台的每一个API创建了一个集合，并进行适当的测试和数据验证。由于没有Swagger/OpenAPI文档，我们的许多API都花了一些时间。然而，对于我们在Spring Boot的新项目，我只需将<a class="ae kf" href="https://blog.postman.com/openapi-specification-postman-how-to/" rel="noopener ugc nofollow" target="_blank"> Postman的导入指向OpenAPI </a> docs URL，Postman就会自动创建集合。当然，自动创建并没有增加测试，这个过程仍然需要完成。</p><p id="c6f3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请记住，在创建您的集合时，您可以使用变量，它们可以通过CLI传递给Newman。</p><p id="10f2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一旦您通过充分的测试创建了所有您想要的收藏，您将希望<a class="ae kf" href="https://learning.postman.com/docs/getting-started/importing-and-exporting-data/" rel="noopener ugc nofollow" target="_blank">将它们导出</a>为v2.1收藏(单击收藏名称旁边的3个点并选择导出)或通过Postman's cloud提供它们，以便您可以引用Newman的URL。我选择了出口。</p><h1 id="cc97" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">本地测试</h1><p id="659a" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">你可以在本地机器上安装NPM和纽曼，或者直接跳到docker容器。我个人选择了一个容器，因为我知道我想要</p><p id="1353" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你首先从码头路线开始，你需要一个纽曼码头形象。我使用了邮差团队、<code class="fe mh mi mj mk b">postman/newman:alpine</code>发布的图片<a class="ae kf" href="https://github.com/postmanlabs/newman/tree/develop/docker/" rel="noopener ugc nofollow" target="_blank">，效果很好。这将允许您计算出通过CI/CD运行时需要的确切命令行参数。</a></p><p id="9e80" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae kf" href="https://github.com/postmanlabs/newman#newman-run-collection-file-source-options" rel="noopener ugc nofollow" target="_blank">纽曼医生</a>在这里很有帮助！我最终使用了全局变量和环境变量的组合。我开始考虑环境变量，认为它们是系统环境变量，非常适合通过CI/CD使用；然而，他们<strong class="ki iu">不是</strong>他们是邮递员环境，这是完全不同的！</p><p id="4e9e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我的集合需要登录到一个内部auth服务，并获得一个用于访问API的不记名令牌，所以我将用户名和密码作为全局变量传入，还传入了要运行的URL。目前，在新容器部署到k8s后，我们会针对每个环境运行。</p><p id="bf6b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我最终决定与Newman一起进行本地测试的命令是:</p><p id="03cf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">newman run --env-var "url=$URL" --global-var "UNAME=$API_USERNAME" --global-var "PASS=$API_PASS" &lt;collection export name&gt;.postman_collection.json</code></p><h1 id="b65e" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">GitLab CI/CD集成</h1><p id="7d40" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">手动运行很好，但是通过CI/CD管道自动运行更好！</p><p id="f864" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于我们想要运行大约15个不同的api，并且每个API都在各自的项目中，所以我在GitLab中创建了一个api_automation项目，它将包含所有的Postman集合和运行它的CI/CD。这样每个项目都可以触发api_automation项目，事情就会运行起来。</p><p id="0fe6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我在GitLab中使用CI/CD变量作为用户名/密码，存储在更高的级别，以供他人有限查看。</p><p id="dd5f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Newman还能够将它的发现记录为Junit测试。这与GitLab配合得非常好，因此您可以在管道的“测试”部分看到它们。</p><p id="e2fc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我为我的CI/CD项目使用一个模板，所以我将下面的内容添加到我的模板中。我包括了整个部分，这样您可以看到我是如何在多种环境中使用它的:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="e187" class="mt lf it mk b gy mu mv l mw mx">.e2e: &amp;e2e<br/>  stage: test    # It only starts when the job in the build stage completes successfully.<br/>  script:<br/>    - collection=`echo $API_IMAGE_TAG|awk -F/ '{print $NF}'`<br/>    - echo $collection<br/>    - python3 /opt/gosecure/rancher.py --collection=$collection --new_version=$API_IMAGE_VER<br/>    - newman run --env-var "url=$NEWMAN_URL" --global-var "UNAME=$API_USERNAME" --global-var "PASS=$API_PASS" --global-var $collection.postman_collection.json --reporters junit,cli --reporter-junit-export=./myreport.xml<br/>  artifacts:<br/>    reports:<br/>      junit:<br/>        - ./myreport.xml<br/><br/><br/>end2end-test-dev:<br/>  extends: .e2e<br/>  variables:<br/>    NEWMAN_URL: https://devinstance.dev.company.com/api<br/>  rules:<br/>    - if: $NEWMAN_ENV == "DEV"<br/>      when: always<br/>    - when: never<br/><br/>end2end-test-job:qa:<br/>  extends: .e2e<br/>  variables:<br/>    NEWMAN_URL: https://qainstance.dev.company.com/api<br/>  rules:<br/>    - if: $NEWMAN_ENV == "QA"<br/>      when: always<br/>    - when: never</span></pre><h1 id="bce4" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">确保容器已部署</h1><p id="4e9a" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我立即发现的一个挑战是，在开始API收集之前，我需要确保新容器已经部署。我们使用牧场主为我们的Kubernetes编排。Rancher有一个非常健壮的API，文档不多，绝对的API！</p><p id="ec56" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您注意到CI中有一个python3 rancher.py调用，这将确保在开始Newman作业之前实际部署了新容器。</p><p id="246f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我将这个脚本和Python一起包含在我的Newman容器中。是的，我知道，我知道把Python添加到一个节点容器是不好的，但是嘿，我很擅长Python，不知道JavaScript，所以我们在这里。</p><p id="c930" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该脚本实际上非常简单，因为它只是轮询Rancher API并确保容器是“活动的”。我将新的容器版本和容器名称传递给脚本，然后它轮询API，看是否有正确的容器版本正在运行并处于活动状态。</p><p id="2499" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">需要注意的一点是，如果您正在使用Rancher，并且想要为这样的脚本设置一个API键，您将需要创建未划分的API键。Rancher 2.5中有一个错误，如果您试图将API键的范围限定为单个集群，将使所有API调用返回无效。</p><p id="5146" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Rancher中另一个非常有用的东西是使用UI中的“在API中查看”选项。这将向您显示实际的API返回结果。如果您单击右上角的“编辑”按钮，您可以看到运行的CURL命令。这比牧场医生有用多了！</p><p id="abf4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是Rancher.py脚本。</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="6b2b" class="mt lf it mk b gy mu mv l mw mx">RANCHER_URL = "https://rancher.dev.company.com/v3/"<br/><br/>import requests<br/>from requests.models import HTTPBasicAuth<br/>import os<br/>import time<br/>import argparse<br/><br/>RANCHER_USER = "TOKEN HERE"<br/>RANCHER_ACCESS = "KEY HERE"<br/>HEADERS = {<br/>    "Accept": 'application/json',<br/>    'Content-Type': 'application/json'<br/>}<br/><br/>login = requests.put(<br/>    RANCHER_URL,<br/>    auth= HTTPBasicAuth(RANCHER_USER,RANCHER_ACCESS)<br/>)<br/><br/>def get_container_ver(container, version):<br/>    time.sleep(5)<br/>    try:<br/>        results = requests.get(<br/>            RANCHER_URL + "projects/XXXX:XXX/workloads/deployment:dev:{}".format(container),<br/>            auth= HTTPBasicAuth(RANCHER_USER,RANCHER_ACCESS)<br/>        ).json()<br/>        print(results['state'])<br/>        if results['state'] == "active":<br/>            for cont in results['containers']:<br/>                if cont['image'].split(':')[-1] != version:<br/>                    return True<br/>            return False<br/>        else:<br/>            return True<br/>    except:<br/>        return False<br/><br/>parser = argparse.ArgumentParser()<br/>parser.add_argument("--container",dest='API_IMAGE', help = "The container to verify", required=False)<br/>parser.add_argument("--collection",dest='cont', help = "The container to verify", required=True)<br/>parser.add_argument("--new_version",dest='API_VER', help = "The new version to wait for", required=True)<br/>args = parser.parse_args()<br/><br/>while get_container_ver(args.cont,args.API_VER):<br/>    print("Container Not updated")<br/>    time.sleep(10)<br/>exit(0)</span></pre><h1 id="d9c1" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">现在我们有了自动化的API测试</h1><p id="7a7c" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">如果在开发人员构建并部署到我们的开发环境之后，有什么地方不正常，这可以立即告诉开发人员。我们将样本数据加载到我们所有的系统中，这样一组测试就可以用于任何地方的API。</p><p id="8ff2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这种自动化已经极大地帮助了团队。现在我们的QA团队正在维护和改进Postman系列。这对我们来说是双赢！</p><p id="813c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">希望你觉得这很有用，如果你有任何问题，请让我知道，如果你喜欢这篇文章，请鼓掌并分享！</p></div></div>    
</body>
</html>