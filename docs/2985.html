<html>
<head>
<title>Decoding a JSON in 4 steps with Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Swift用4个步骤解码JSON</h1>
<blockquote>原文：<a href="https://itnext.io/mastering-codable-in-swift-part-2-876e646e0844?source=collection_archive---------2-----------------------#2019-09-11">https://itnext.io/mastering-codable-in-swift-part-2-876e646e0844?source=collection_archive---------2-----------------------#2019-09-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/a3015b1062239ed0a8b2c9a0c8d2803f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h41gcDGlJSKOqpUnKycgqA.jpeg"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated"><a class="ae jg" href="https://pixabay.com/photos/letters-numbers-blocks-alphabet-691842/" rel="noopener ugc nofollow" target="_blank">https://pix abay . com/photos/letters-numbers-blocks-alphabet-691842/</a></figcaption></figure><div class=""/><h1 id="e9d2" class="kg kh jj bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">介绍</h1><p id="e217" class="pw-post-body-paragraph le lf jj lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">在本文中，我将给出一个在Swift中解码JSON的步骤列表。</p><ul class=""><li id="19c3" class="mc md jj lg b lh me ll mf lp mg lt mh lx mi mb mj mk ml mm bi translated"><strong class="lg jk">第一步</strong>:剖析你的JSON</li><li id="163e" class="mc md jj lg b lh mn ll mo lp mp lt mq lx mr mb mj mk ml mm bi translated"><strong class="lg jk">第二步</strong>:使用String、Double、Bool等Swift可编码类型定义一个匹配JSON的struct</li><li id="6c74" class="mc md jj lg b lh mn ll mo lp mp lt mq lx mr mb mj mk ml mm bi translated">步骤3 :定义你的类型来管理一些JSON片段</li><li id="a717" class="mc md jj lg b lh mn ll mo lp mp lt mq lx mr mb mj mk ml mm bi translated"><strong class="lg jk">步骤4 </strong>:为<em class="ms"> JSONDecoder </em>设置一个<em class="ms">按键解码策略</em></li></ul><blockquote class="mt mu mv"><p id="bdb8" class="le lf ms lg b lh me lj lk ll mf ln lo mw mx lr ls my mz lv lw na nb lz ma mb im bi translated">这个规则有一些例外，我将在以后的文章中讨论这些特殊的场景。</p></blockquote><figure class="nd ne nf ng gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nc"><img src="../Images/4529de39eec643b95548b95ae3e08eee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PxiCr7y5PDadJ5LHo8JTYw.jpeg"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated"><a class="ae jg" href="https://unsplash.com/photos/6gQjPGx1uQw" rel="noopener ugc nofollow" target="_blank">https://unsplash.com/photos/6gQjPGx1uQw</a></figcaption></figure><h1 id="68dd" class="kg kh jj bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">✅第一步:剖析你的JSON</h1><p id="63a6" class="pw-post-body-paragraph le lf jj lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">JSON数据被表示为键/值对或/和数组。</p><p id="d774" class="pw-post-body-paragraph le lf jj lg b lh me lj lk ll mf ln lo lp mx lr ls lt mz lv lw lx nb lz ma mb im bi translated">该键总是由一个<em class="ms">字符串表示，</em>并且一个值可能包含以下内容之一:</p><ol class=""><li id="1ce2" class="mc md jj lg b lh me ll mf lp mg lt mh lx mi mb nh mk ml mm bi translated"><em class="ms">字符串</em></li><li id="392b" class="mc md jj lg b lh mn ll mo lp mp lt mq lx mr mb nh mk ml mm bi translated"><em class="ms">编号</em></li><li id="0758" class="mc md jj lg b lh mn ll mo lp mp lt mq lx mr mb nh mk ml mm bi translated"><em class="ms">布尔型</em></li><li id="d8be" class="mc md jj lg b lh mn ll mo lp mp lt mq lx mr mb nh mk ml mm bi translated"><em class="ms">阵列</em></li><li id="49fb" class="mc md jj lg b lh mn ll mo lp mp lt mq lx mr mb nh mk ml mm bi translated"><em class="ms">空值</em></li><li id="8585" class="mc md jj lg b lh mn ll mo lp mp lt mq lx mr mb nh mk ml mm bi translated"><em class="ms">另一个JSON对象</em></li></ol><p id="2b2c" class="pw-post-body-paragraph le lf jj lg b lh me lj lk ll mf ln lo lp mx lr ls lt mz lv lw lx nb lz ma mb im bi translated">一旦你学会了管理这些👆六个可能的值，可以用Codable解码任何可能的JSON。</p><h1 id="6f0d" class="kg kh jj bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">✅步骤2:使用Swift可编码类型定义一个匹配JSON的结构</h1><p id="0273" class="pw-post-body-paragraph le lf jj lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">请记住，在Swift中处理JSON解码的大部分工作是定义一个符合<em class="ms"> Codable </em>并且匹配JSON结构的模型类型。</p><p id="299b" class="pw-post-body-paragraph le lf jj lg b lh me lj lk ll mf ln lo lp mx lr ls lt mz lv lw lx nb lz ma mb im bi translated">可能是</p><ul class=""><li id="680c" class="mc md jj lg b lh me ll mf lp mg lt mh lx mi mb mj mk ml mm bi translated">头等</li><li id="9efc" class="mc md jj lg b lh mn ll mo lp mp lt mq lx mr mb mj mk ml mm bi translated">一个结构</li><li id="d927" class="mc md jj lg b lh mn ll mo lp mp lt mq lx mr mb mj mk ml mm bi translated">枚举</li></ul><p id="3bcf" class="pw-post-body-paragraph le lf jj lg b lh me lj lk ll mf ln lo lp mx lr ls lt mz lv lw lx nb lz ma mb im bi translated">通常，我更喜欢使用一个<em class="ms">结构</em>(所有属性都定义为常量)，因为:</p><ul class=""><li id="d2fb" class="mc md jj lg b lh me ll mf lp mg lt mh lx mi mb mj mk ml mm bi translated">当我从一个端点接收到一个JSON时，我认为该数据是不可变的。</li><li id="dbe2" class="mc md jj lg b lh mn ll mo lp mp lt mq lx mr mb mj mk ml mm bi translated">结构值(位于堆栈中)比类实例(位于堆中)快。</li></ul><h2 id="6ac9" class="ni kh jj bd ki nj nk dn km nl nm dp kq lp nn no ku lt np nq ky lx nr ns lc nt bi translated">线</h2><p id="0a58" class="pw-post-body-paragraph le lf jj lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">假设您有一个这样的JSON，其中只有一个类型为<em class="ms"> String </em>的元素。</p><pre class="nd ne nf ng gt nu nv nw nx aw ny bi"><span id="bf77" class="ni kh jj nv b gy nz oa l ob oc">{<br/>    "name": "BoJack Horseman"<br/>}</span></pre><p id="bc34" class="pw-post-body-paragraph le lf jj lg b lh me lj lk ll mf ln lo lp mx lr ls lt mz lv lw lx nb lz ma mb im bi translated">在这种情况下，您需要像这样定义一个结构</p><pre class="nd ne nf ng gt nu nv nw nx aw ny bi"><span id="3801" class="ni kh jj nv b gy nz oa l ob oc">struct Show: Decodable {<br/>    let name: String<br/>}</span></pre><h2 id="3c92" class="ni kh jj bd ki nj nk dn km nl nm dp kq lp nn no ku lt np nq ky lx nr ns lc nt bi translated">数字</h2><p id="7e6a" class="pw-post-body-paragraph le lf jj lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">让我们向JSON添加另一个元素</p><pre class="nd ne nf ng gt nu nv nw nx aw ny bi"><span id="468c" class="ni kh jj nv b gy nz oa l ob oc">{<br/>    "name": "BoJack Horseman",<br/>    <strong class="nv jk">"seasons": 3</strong><br/>}</span></pre><p id="bcd0" class="pw-post-body-paragraph le lf jj lg b lh me lj lk ll mf ln lo lp mx lr ls lt mz lv lw lx nb lz ma mb im bi translated"><em class="ms"> seasons </em>键将始终包含一个数字，特别是一个<em class="ms">整数</em>。所以我们可以这样更新我们的模型结构</p><pre class="nd ne nf ng gt nu nv nw nx aw ny bi"><span id="d413" class="ni kh jj nv b gy nz oa l ob oc">struct Show: Decodable {<br/>    let name: String<br/>    <strong class="nv jk">let seasons: Int</strong><br/>}</span></pre><p id="dd78" class="pw-post-body-paragraph le lf jj lg b lh me lj lk ll mf ln lo lp mx lr ls lt mz lv lw lx nb lz ma mb im bi translated">让我们向JSON添加另一个值</p><pre class="nd ne nf ng gt nu nv nw nx aw ny bi"><span id="48d0" class="ni kh jj nv b gy nz oa l ob oc">{<br/>    "name": "BoJack Horseman",<br/>    "seasons": 3,<br/>    <strong class="nv jk">"rate": 8.6</strong><br/>}</span></pre><p id="b55a" class="pw-post-body-paragraph le lf jj lg b lh me lj lk ll mf ln lo lp mx lr ls lt mz lv lw lx nb lz ma mb im bi translated"><em class="ms"> rate </em>键包含一个float值，这意味着我们应该在我们的结构定义中使用一个<em class="ms"> Float </em>或一个<em class="ms"> Double </em></p><pre class="nd ne nf ng gt nu nv nw nx aw ny bi"><span id="bd82" class="ni kh jj nv b gy nz oa l ob oc">struct Show: Decodable {<br/>    let name: String<br/>    let seasons: Int<br/>    <strong class="nv jk">let rate: Float</strong><br/>}</span></pre><h2 id="538e" class="ni kh jj bd ki nj nk dn km nl nm dp kq lp nn no ku lt np nq ky lx nr ns lc nt bi translated">布尔代数学体系的</h2><p id="e7fb" class="pw-post-body-paragraph le lf jj lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">根据JSON标准，有效的布尔值应该包含<em class="ms">真</em>或<em class="ms">假</em>。</p><blockquote class="mt mu mv"><p id="3a35" class="le lf ms lg b lh me lj lk ll mf ln lo mw mx lr ls my mz lv lw na nb lz ma mb im bi translated">以下值是<strong class="lg jk">而不是</strong>认为有效的布尔值:是，否，“是”，“否”，“真”，“假”，1，0，“1”，“0”。</p></blockquote><p id="8e55" class="pw-post-body-paragraph le lf jj lg b lh me lj lk ll mf ln lo lp mx lr ls lt mz lv lw lx nb lz ma mb im bi translated">现在让我们给JSON添加一个布尔值。</p><pre class="nd ne nf ng gt nu nv nw nx aw ny bi"><span id="509b" class="ni kh jj nv b gy nz oa l ob oc">{<br/>    "name": "BoJack Horseman",<br/>    "seasons": 3,<br/>    "rate": 8.6,<br/>    <strong class="nv jk">"favorite": true</strong><br/>}</span></pre><p id="ad68" class="pw-post-body-paragraph le lf jj lg b lh me lj lk ll mf ln lo lp mx lr ls lt mz lv lw lx nb lz ma mb im bi translated">同样，我们需要做的就是向我们的<em class="ms">结构</em>添加一个属性(具有匹配的<em class="ms">名称</em>和<em class="ms">类型</em></p><pre class="nd ne nf ng gt nu nv nw nx aw ny bi"><span id="e414" class="ni kh jj nv b gy nz oa l ob oc">struct Show: Decodable {<br/>    let name: String<br/>    let seasons: Int<br/>    let rate: Float<br/>    <strong class="nv jk">let favorite: Bool</strong><br/>}</span></pre><h2 id="527a" class="ni kh jj bd ki nj nk dn km nl nm dp kq lp nn no ku lt np nq ky lx nr ns lc nt bi translated">排列</h2><p id="b98e" class="pw-post-body-paragraph le lf jj lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">在JSON中，数组值是用以下语法定义的</p><pre class="nd ne nf ng gt nu nv nw nx aw ny bi"><span id="88ba" class="ni kh jj nv b gy nz oa l ob oc">[value(0), value(1), ..., value(n-1)]</span></pre><p id="ec47" class="pw-post-body-paragraph le lf jj lg b lh me lj lk ll mf ln lo lp mx lr ls lt mz lv lw lx nb lz ma mb im bi translated">所以当你看到一个具有这种结构的JSON片段时，你知道你必须使用Swift数组。</p><blockquote class="mt mu mv"><p id="5224" class="le lf ms lg b lh me lj lk ll mf ln lo mw mx lr ls my mz lv lw na nb lz ma mb im bi translated">请记住，数组的泛型类型必须符合codable。所以使用一个字符串数组，一个整数数组是可以的…</p></blockquote><p id="e28e" class="pw-post-body-paragraph le lf jj lg b lh me lj lk ll mf ln lo lp mx lr ls lt mz lv lw lx nb lz ma mb im bi translated">让我们用一个数组更新我们的JSON</p><pre class="nd ne nf ng gt nu nv nw nx aw ny bi"><span id="6d83" class="ni kh jj nv b gy nz oa l ob oc">{<br/>    "name": "BoJack Horseman",<br/>    "seasons": 3,<br/>    "rate": 8.6,<br/>    "favorite": true,<br/>    <strong class="nv jk">"genres":["Animation", "Comedy", "Drama"]</strong><br/>}</span></pre><p id="5ad0" class="pw-post-body-paragraph le lf jj lg b lh me lj lk ll mf ln lo lp mx lr ls lt mz lv lw lx nb lz ma mb im bi translated">让我们相应地更新我们的结构</p><pre class="nd ne nf ng gt nu nv nw nx aw ny bi"><span id="8f63" class="ni kh jj nv b gy nz oa l ob oc">struct Show: Decodable {<br/>    let name: String<br/>    let seasons: Int<br/>    let rate: Float<br/>    let favorite: Bool<br/>    <strong class="nv jk">let genres: [String]</strong><br/>}</span></pre><h2 id="abaa" class="ni kh jj bd ki nj nk dn km nl nm dp kq lp nn no ku lt np nq ky lx nr ns lc nt bi translated">5.空</h2><p id="21ac" class="pw-post-body-paragraph le lf jj lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">有时JSON的值可能包含空值。如果根据端点的文档，这不是一个错误，您应该将<em class="ms">结构</em>中的相关属性设为可选。否则，JSON解码将不起作用。</p><p id="3873" class="pw-post-body-paragraph le lf jj lg b lh me lj lk ll mf ln lo lp mx lr ls lt mz lv lw lx nb lz ma mb im bi translated">例如，如果我们更新先前的JSON，将<em class="ms"> Null </em>关联到<em class="ms">收藏夹</em>键…</p><pre class="nd ne nf ng gt nu nv nw nx aw ny bi"><span id="f5ed" class="ni kh jj nv b gy nz oa l ob oc">{<br/>    "name": "BoJack Horseman",<br/>    "seasons": 3,<br/>    "rate": 8.6,<br/>    <strong class="nv jk">"favorite": null,</strong><br/>    "genres":["Animation", "Comedy", "Drama"]<br/>}</span></pre><p id="891c" class="pw-post-body-paragraph le lf jj lg b lh me lj lk ll mf ln lo lp mx lr ls lt mz lv lw lx nb lz ma mb im bi translated">…解码将不起作用。</p><pre class="nd ne nf ng gt nu nv nw nx aw ny bi"><span id="6de8" class="ni kh jj nv b gy nz oa l ob oc">Swift.DecodingError.valueNotFound(Swift.Bool, Swift.DecodingError.Context(codingPath: [CodingKeys(stringValue: "favorite", intValue: nil)], debugDescription: "Expected Bool value but found null instead.", underlyingError: nil))</span></pre><p id="84ff" class="pw-post-body-paragraph le lf jj lg b lh me lj lk ll mf ln lo lp mx lr ls lt mz lv lw lx nb lz ma mb im bi translated">因为我们知道<em class="ms"> Null </em>可能是<em class="ms"> favorite </em>属性的有效“值”,所以我们可以将其设为可选</p><pre class="nd ne nf ng gt nu nv nw nx aw ny bi"><span id="288d" class="ni kh jj nv b gy nz oa l ob oc">struct Show: Decodable {<br/>    let name: String<br/>    let seasons: Int<br/>    let rate: Float<br/>    <strong class="nv jk">let favorite: Bool?</strong><br/>    let genres: [String]<br/>}</span></pre><h1 id="f27c" class="kg kh jj bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">✅步骤3:定义你的类型来管理一些JSON片段</h1><p id="9dd1" class="pw-post-body-paragraph le lf jj lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">最后，我们的JSON可以包含另一个JSON对象。它可能看起来像这样</p><pre class="nd ne nf ng gt nu nv nw nx aw ny bi"><span id="380b" class="ni kh jj nv b gy nz oa l ob oc">{<br/>    "name": "BoJack Horseman",<br/>    "seasons": 3,<br/>    "rate": 8.6,<br/>    "favorite": null,<br/>    "genres":["Animation", "Comedy", "Drama"],<br/>    <strong class="nv jk">"platform": {<br/>        "name": "Netflix",<br/>        "ceo": "Reed Hastings"<br/>    }</strong><br/>}</span></pre><figure class="nd ne nf ng gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nc"><img src="../Images/dd0cfb7604647e57bce5256b3afba924.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yM4fDhsyYzW_4AE45F1tmg.jpeg"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated"><a class="ae jg" href="https://unsplash.com/photos/VbGYLwHnw88" rel="noopener ugc nofollow" target="_blank">https://unsplash.com/photos/VbGYLwHnw88</a></figcaption></figure><h2 id="95f6" class="ni kh jj bd ki nj nk dn km nl nm dp kq lp nn no ku lt np nq ky lx nr ns lc nt bi translated">另一个JSON对象</h2><p id="6918" class="pw-post-body-paragraph le lf jj lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">我们如何管理<em class="ms">平台</em>密钥？不是一个<em class="ms">字符串</em>，一个<em class="ms">数字</em>，一个<em class="ms">布尔</em>或者一个<em class="ms">数组</em>。我们没有一个Swift类型与这个值完全匹配，对吗？</p><pre class="nd ne nf ng gt nu nv nw nx aw ny bi"><span id="d64a" class="ni kh jj nv b gy nz oa l ob oc">"platform" {<br/>    "name": "Netflix",<br/>    "ceo": "Reed Hastings"<br/>}</span></pre><p id="f689" class="pw-post-body-paragraph le lf jj lg b lh me lj lk ll mf ln lo lp mx lr ls lt mz lv lw lx nb lz ma mb im bi translated">在这种情况下，我们可以<strong class="lg jk">递归地</strong>应用本文中描述的步骤，并专门为这个JSON片段定义一个新的结构。</p><pre class="nd ne nf ng gt nu nv nw nx aw ny bi"><span id="ed35" class="ni kh jj nv b gy nz oa l ob oc">struct Show: Decodable {<br/>    let name: String<br/>    let seasons: Int<br/>    let rate: Float<br/>    let favorite: Bool?<br/>    let genres: [String]<br/>    <strong class="nv jk">let platform: Platform</strong></span><span id="f34c" class="ni kh jj nv b gy od oa l ob oc"><strong class="nv jk">    struct Platform: Decodable {<br/>        let name: String<br/>        let ceo: String<br/>    }</strong><br/>}</span></pre><blockquote class="mt mu mv"><p id="47db" class="le lf ms lg b lh me lj lk ll mf ln lo mw mx lr ls my mz lv lw na nb lz ma mb im bi translated">记住:<em class="jj"> Show </em>的每个属性必须有一个符合<em class="jj"> Decodable </em>的类型。因此<em class="jj">平台</em>类型也必须符合可解码。</p></blockquote><h2 id="bb52" class="ni kh jj bd ki nj nk dn km nl nm dp kq lp nn no ku lt np nq ky lx nr ns lc nt bi translated">关于字符串的更多信息</h2><p id="7299" class="pw-post-body-paragraph le lf jj lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">有时候你的JSON可能包含一个URL。JSON语法没有URL的特定格式。它们只是被编码成字符串。</p><pre class="nd ne nf ng gt nu nv nw nx aw ny bi"><span id="6ef4" class="ni kh jj nv b gy nz oa l ob oc">{<br/>    "name": "BoJack Horseman",<br/>    "seasons": 3,<br/>    "rate": 8.6,<br/>    "favorite": null,<br/>    "genres":["Animation", "Comedy", "Drama"],<br/>    "platform": {<br/>        "name": "Netflix",<br/>        "ceo": "Reed Hastings"<br/>    },<br/>    <strong class="nv jk">"url":"</strong><a class="ae jg" href="https://en.wikipedia.org/wiki/BoJack_Horseman" rel="noopener ugc nofollow" target="_blank"><strong class="nv jk">https://en.wikipedia.org/wiki/BoJack_Horseman</strong></a><strong class="nv jk">"</strong><br/>}</span></pre><p id="306b" class="pw-post-body-paragraph le lf jj lg b lh me lj lk ll mf ln lo lp mx lr ls lt mz lv lw lx nb lz ma mb im bi translated">所以你可以添加一个<em class="ms">字符串</em>属性到你的结构中，对吗？</p><pre class="nd ne nf ng gt nu nv nw nx aw ny bi"><span id="6cb5" class="ni kh jj nv b gy nz oa l ob oc">struct Show: Decodable {<br/>    let name: String<br/>    let seasons: Int<br/>    let rate: Float<br/>    let favorite: Bool?<br/>    let genres: [String]<br/>    let platform: Platform<br/>    <strong class="nv jk">let url: String</strong><br/>    <br/>    struct Platform: Codable {<br/>        let name: String<br/>        let ceo: String<br/>    }<br/>}</span></pre><p id="9544" class="pw-post-body-paragraph le lf jj lg b lh me lj lk ll mf ln lo lp mx lr ls lt mz lv lw lx nb lz ma mb im bi translated">这个代码是有效的。然而，有一个问题。即使<em class="ms"> url </em>包含一些不是这样的url的字符串值，解码也会工作👇</p><pre class="nd ne nf ng gt nu nv nw nx aw ny bi"><span id="97d9" class="ni kh jj nv b gy nz oa l ob oc">{<br/>    "name": "BoJack Horseman",<br/>    "seasons": 3,<br/>    "rate": 8.6,<br/>    "favorite": null,<br/>    "genres":["Animation", "Comedy", "Drama"],<br/>    "platform": {<br/>        "name": "Netflix",<br/>        "ceo": "Reed Hastings"<br/>    },<br/>    <strong class="nv jk">"url":"NOT A URL!!"</strong><br/>}</span></pre><p id="d12b" class="pw-post-body-paragraph le lf jj lg b lh me lj lk ll mf ln lo lp mx lr ls lt mz lv lw lx nb lz ma mb im bi translated">我们可以强制Codable只接受有效URL的字符串来代替它</p><pre class="nd ne nf ng gt nu nv nw nx aw ny bi"><span id="4941" class="ni kh jj nv b gy nz oa l ob oc">struct Show: Decodable {<br/>    ...<br/>    let url: String<br/>    ...<br/>}</span></pre><p id="8e25" class="pw-post-body-paragraph le lf jj lg b lh me lj lk ll mf ln lo lp mx lr ls lt mz lv lw lx nb lz ma mb im bi translated">与这个</p><pre class="nd ne nf ng gt nu nv nw nx aw ny bi"><span id="c1b5" class="ni kh jj nv b gy nz oa l ob oc">struct Show: Decodable {<br/>    ...<br/>    let url: URL<br/>    ...<br/>}</span></pre><h1 id="25e1" class="kg kh jj bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">✅步骤4:为JSONDecoder设置一个密钥解码器和日期格式</h1><h2 id="7766" class="ni kh jj bd ki nj nk dn km nl nm dp kq lp nn no ku lt np nq ky lx nr ns lc nt bi translated">蛇箱呼叫骆驼箱</h2><p id="4c23" class="pw-post-body-paragraph le lf jj lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">JSON键通常使用<em class="ms"> snake_case </em>符号。让我们相应地更新我们的JSON</p><pre class="nd ne nf ng gt nu nv nw nx aw ny bi"><span id="d0b6" class="ni kh jj nv b gy nz oa l ob oc">{<br/>    "name": "BoJack Horseman",<br/>    "<strong class="nv jk">num_seasons</strong>": 3, <br/>    "rate": 8.6,<br/>    "<strong class="nv jk">is_favorite</strong>": null,<br/>    "genres":["Animation", "Comedy", "Drama"],<br/>    "platform": {<br/>        "name": "Netflix",<br/>        "ceo": "Reed Hastings"<br/>    },<br/>    "url": "<a class="ae jg" href="https://en.wikipedia.org/wiki/BoJack_Horseman" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/BoJack_Horseman</a>"<br/>}</span></pre><p id="b18b" class="pw-post-body-paragraph le lf jj lg b lh me lj lk ll mf ln lo lp mx lr ls lt mz lv lw lx nb lz ma mb im bi translated">然而，Swift指南建议使用<em class="ms">驼峰式</em>符号，因此应该如下所示更新该结构</p><pre class="nd ne nf ng gt nu nv nw nx aw ny bi"><span id="4b5f" class="ni kh jj nv b gy nz oa l ob oc">struct Show: Decodable {<br/>    let name: String<br/>    let <strong class="nv jk">numSeasons</strong>: Int<br/>    let rate: Float<br/>    let <strong class="nv jk">isFavorite</strong>: Bool?<br/>    let genres: [String]<br/>    let platform: Platform<br/>    let url: String<br/>    <br/>    struct Platform: Codable {<br/>        let name: String<br/>        let ceo: String<br/>    }<br/>}</span></pre><p id="1335" class="pw-post-body-paragraph le lf jj lg b lh me lj lk ll mf ln lo lp mx lr ls lt mz lv lw lx nb lz ma mb im bi translated">幸运的是，我们可以告诉Codable自动管理用于键的不同符号(例如，将<em class="ms"> num_seasons </em>转换为<em class="ms"> numSeasons </em>)来设置key decoding策略</p><pre class="nd ne nf ng gt nu nv nw nx aw ny bi"><span id="1e39" class="ni kh jj nv b gy nz oa l ob oc">decoder.keyDecodingStrategy = .convertFromSnakeCase</span></pre><p id="b69b" class="pw-post-body-paragraph le lf jj lg b lh me lj lk ll mf ln lo lp mx lr ls lt mz lv lw lx nb lz ma mb im bi translated">这是你可以在操场上运行的完整代码</p><pre class="nd ne nf ng gt nu nv nw nx aw ny bi"><span id="a2e9" class="ni kh jj nv b gy nz oa l ob oc">let data = """<br/>{<br/>    "name": "BoJack Horseman",<br/>    "num_seasons": 3,<br/>    "rate": 8.6,<br/>    "is_favorite": null,<br/>    "genres":["Animation", "Comedy", "Drama"],<br/>    "platform": {<br/>        "name": "Netflix",<br/>        "ceo": "Reed Hastings"<br/>    },<br/>    "url": "<a class="ae jg" href="https://en.wikipedia.org/wiki/BoJack_Horseman" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/BoJack_Horseman</a>"<br/>}<br/>""".data(using: String.Encoding.utf8)!</span><span id="323c" class="ni kh jj nv b gy od oa l ob oc">struct Show: Decodable {<br/>    let name: String<br/>    let numSeasons: Int<br/>    let rate: Float<br/>    let isFavorite: Bool?<br/>    let genres: [String]<br/>    let platform: Platform<br/>    let url: String<br/>    <br/>    struct Platform: Codable {<br/>        let name: String<br/>        let ceo: String<br/>    }<br/>}</span><span id="d3f8" class="ni kh jj nv b gy od oa l ob oc">let decoder = JSONDecoder()<br/>decoder.keyDecodingStrategy = .convertFromSnakeCase<br/>do {<br/>    let show = try decoder.decode(Show.self, from: data)<br/>    print(show)<br/>} catch {<br/>    debugPrint(error)<br/>}</span></pre><h2 id="5d07" class="ni kh jj bd ki nj nk dn km nl nm dp kq lp nn no ku lt np nq ky lx nr ns lc nt bi translated">处理不一致的键命名</h2><p id="e885" class="pw-post-body-paragraph le lf jj lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">有时JSON没有遵循正确的<em class="ms">键</em>命名规则</p><pre class="nd ne nf ng gt nu nv nw nx aw ny bi"><span id="b7b1" class="ni kh jj nv b gy nz oa l ob oc">{<br/>    "<strong class="nv jk">Name</strong>": "BoJack Horseman",<br/>    "<strong class="nv jk">num_seasons</strong>": 3,<br/>    "rate": 8.6,<br/>    "<strong class="nv jk">isFavorite</strong>": null,<br/>    "genres":["Animation", "Comedy", "Drama"],<br/>    "platform": {<br/>        "name": "Netflix",<br/>        "ceo": "Reed Hastings"<br/>    },<br/>    "url": "<a class="ae jg" href="https://en.wikipedia.org/wiki/BoJack_Horseman" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/BoJack_Horseman</a>"<br/>}</span></pre><p id="cf28" class="pw-post-body-paragraph le lf jj lg b lh me lj lk ll mf ln lo lp mx lr ls lt mz lv lw lx nb lz ma mb im bi translated">如你所见，我们有几处不一致</p><ul class=""><li id="bbae" class="mc md jj lg b lh me ll mf lp mg lt mh lx mi mb mj mk ml mm bi translated"><strong class="lg jk">名字</strong>以大写字母开头</li><li id="13f1" class="mc md jj lg b lh mn ll mo lp mp lt mq lx mr mb mj mk ml mm bi translated"><strong class="lg jk"> num_seasons </strong>在snake_case符号中是小写</li><li id="a767" class="mc md jj lg b lh mn ll mo lp mp lt mq lx mr mb mj mk ml mm bi translated"><strong class="lg jk"> isFavorite </strong>遵循驼峰式符号</li></ul><p id="1728" class="pw-post-body-paragraph le lf jj lg b lh me lj lk ll mf ln lo lp mx lr ls lt mz lv lw lx nb lz ma mb im bi translated">在这种情况下，最好的解决方案是在JSON中的<strong class="lg jk">键名</strong>和我们的struct中的<strong class="lg jk">属性名</strong>之间提供映射。为此，我们向结构中添加一个枚举，如下所示。</p><pre class="nd ne nf ng gt nu nv nw nx aw ny bi"><span id="8d78" class="ni kh jj nv b gy nz oa l ob oc">enum CodingKeys: String, CodingKey {<br/>    case name = "Name"<br/>    case numSeasons = "num_seasons"<br/>    case rate = "rate"<br/>    case isFavorite = "isFavorite"<br/>    case genres = "genres"<br/>    case platform = "platform"<br/>    case url = "url"<br/>}</span></pre><p id="ed26" class="pw-post-body-paragraph le lf jj lg b lh me lj lk ll mf ln lo lp mx lr ls lt mz lv lw lx nb lz ma mb im bi translated">请记住，枚举:</p><ul class=""><li id="0b11" class="mc md jj lg b lh me ll mf lp mg lt mh lx mi mb mj mk ml mm bi translated">必须命名为<em class="ms"> CodingKeys </em></li><li id="5507" class="mc md jj lg b lh mn ll mo lp mp lt mq lx mr mb mj mk ml mm bi translated">必须将<em class="ms">字符串</em>作为<em class="ms"> rawType </em></li><li id="fea0" class="mc md jj lg b lh mn ll mo lp mp lt mq lx mr mb mj mk ml mm bi translated">必须符合<em class="ms">编码密钥</em>协议</li><li id="fe1e" class="mc md jj lg b lh mn ll mo lp mp lt mq lx mr mb mj mk ml mm bi translated">必须在结构内部定义</li><li id="842f" class="mc md jj lg b lh mn ll mo lp mp lt mq lx mr mb mj mk ml mm bi translated">结构的每个属性都必须有一个案例</li><li id="9fd8" class="mc md jj lg b lh mn ll mo lp mp lt mq lx mr mb mj mk ml mm bi translated">每个case都必须有一个与JSON中的键名匹配的字符串值</li></ul><blockquote class="mt mu mv"><p id="1dbd" class="le lf ms lg b lh me lj lk ll mf ln lo mw mx lr ls my mz lv lw na nb lz ma mb im bi translated">请注意，对于那些名称与JSON ( <em class="jj"> rate，platform，url </em>)中的键匹配的属性，可以省略字符串值</p></blockquote><pre class="nd ne nf ng gt nu nv nw nx aw ny bi"><span id="c912" class="ni kh jj nv b gy nz oa l ob oc">enum CodingKeys: String, CodingKey {<br/>    case name = "Name"<br/>    case numSeasons = "num_seasons"<br/>    case rate<br/>    case isFavorite = "isFavorite"<br/>    case genres<br/>    case platform<br/>    case url<br/>}</span></pre><p id="1b82" class="pw-post-body-paragraph le lf jj lg b lh me lj lk ll mf ln lo lp mx lr ls lt mz lv lw lx nb lz ma mb im bi translated">最后，让我们将enum添加到我们的结构中，并删除我们设置<em class="ms">密钥解码策略</em>的那一行。</p><pre class="nd ne nf ng gt nu nv nw nx aw ny bi"><span id="4ba9" class="ni kh jj nv b gy nz oa l ob oc">let data = """<br/>{<br/>    "Name": "BoJack Horseman",<br/>    "num_seasons": 3,<br/>    "rate": 8.6,<br/>    "isFavorite": null,<br/>    "genres":["Animation", "Comedy", "Drama"],<br/>    "platform": {<br/>        "name": "Netflix",<br/>        "ceo": "Reed Hastings"<br/>    },<br/>    "url": "<a class="ae jg" href="https://en.wikipedia.org/wiki/BoJack_Horseman" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/BoJack_Horseman</a>"<br/>}<br/>""".data(using: String.Encoding.utf8)!</span><span id="7e7d" class="ni kh jj nv b gy od oa l ob oc">struct Show: Decodable {<br/>    let name: String<br/>    let numSeasons: Int<br/>    let rate: Float<br/>    let isFavorite: Bool?<br/>    let genres: [String]<br/>    let platform: Platform<br/>    let url: String<br/>    <br/>    struct Platform: Codable {<br/>        let name: String<br/>        let ceo: String<br/>    }<br/>    <br/><strong class="nv jk">    enum CodingKeys: String, CodingKey {<br/>        case name = "Name"<br/>        case numSeasons = "num_seasons"<br/>        case rate<br/>        case isFavorite = "isFavorite"<br/>        case genres<br/>        case platform<br/>        case url<br/>    }</strong><br/>}</span><span id="be75" class="ni kh jj nv b gy od oa l ob oc">let decoder = JSONDecoder()<br/>do {<br/>    let show = try decoder.decode(Show.self, from: data)<br/>    <strong class="nv jk">// decoder.keyDecodingStrategy = .convertFromSnakeCase</strong><br/>    print(show)<br/>} catch {<br/>    debugPrint(error)<br/>}</span></pre><h1 id="12d5" class="kg kh jj bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">结论</h1><p id="bcd5" class="pw-post-body-paragraph le lf jj lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">当我需要构建一个模型类型来匹配给定的JSON时，这些是我遵循的基本步骤。按照这些说明，您应该能够解码大部分的JSONs。</p><p id="eeb4" class="pw-post-body-paragraph le lf jj lg b lh me lj lk ll mf ln lo lp mx lr ls lt mz lv lw lx nb lz ma mb im bi translated">有一些例外(比如在顶层有一个数组的JSON或者在编译时有未知键的JSON)，我将在以后的文章中介绍。</p></div></div>    
</body>
</html>