<html>
<head>
<title>Type safe client-side queries in TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript中的类型安全客户端查询</h1>
<blockquote>原文：<a href="https://itnext.io/type-safe-client-side-queries-in-typescript-3906eb14250e?source=collection_archive---------1-----------------------#2018-07-06">https://itnext.io/type-safe-client-side-queries-in-typescript-3906eb14250e?source=collection_archive---------1-----------------------#2018-07-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/6585189d4e9153f4047a68f530d644dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ODyVVg90dkwy9PC-IiJpGw.png"/></div></div></figure><p id="3e78" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">用于客户端编程的静态类型语言(如TypeScript)的引入极大地提高了大型客户端应用程序的创建质量，如在构建现代SPA时常见的。</p><p id="41d9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这种安全性的提高只延伸到API调用的边界。远程调用的结果总是作为非结构化的JSON返回，或者在TypeScript中称为<code class="fe kw kx ky kz b">any</code>。因此，反序列化是手动完成的，这是一个繁琐且容易出错的过程。此外，去序列化例程遭受各种形式的比特腐烂:随着底层模型的发展，它的验证可能变得过时，甚至更糟，稍微关闭。这会导致假阴性(数据是正确的，但是反序列化器认为有错误)，或者假阳性(错误的数据只是简单地将<em class="la">转换为</em>正确的模型类型，对应用程序的其余部分造成严重破坏)。</p><p id="d3fb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="la">简而言之，委婉地说，客户端去个性化并不好玩。</em></p><p id="adf2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">越来越多地采用丰富的协议，如OData(或其最新的、时髦的GraphQL变体)，使得从客户端进行查询更加有效:客户端可以减少接收到的属性(<code class="fe kw kx ky kz b">$select</code>)、行(<code class="fe kw kx ky kz b">$filter</code>)，甚至通过请求连接的数据(<code class="fe kw kx ky kz b">$expand</code>)来减少查询的总数。不幸的是，这使得接收到的数据解析起来更加复杂，给问题增加了一个动态的维度，这实际上是没有帮助的。</p><p id="c129" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本文中，我们将研究TypeScript的高级类型化机制，这些机制使得基于作为对象构造的查询数据的声明性描述来自动生成类型安全的反序列化程序成为可能。</p><h1 id="9492" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">高级类型</h1><p id="b321" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">TypeScript支持非常丰富的类型语言，允许在编译时创建类型。通过使用类似于sum和product的运算符，将两个(或更多)现有类型组合在一起，可以创建结果类型。这个过程是从其他数字创建数字的抽象的、类型级的等价过程(<code class="fe kw kx ky kz b">5+3</code>实际上可以被看作是通过组合两个数字:<code class="fe kw kx ky kz b">5</code>和<code class="fe kw kx ky kz b">3</code>来创建一个数字<code class="fe kw kx ky kz b">8</code>)。</p><p id="d5b7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用<code class="fe kw kx ky kz b">|</code>和<code class="fe kw kx ky kz b">&amp;</code>操作符可以从两个现有类型中创建一个新类型。<code class="fe kw kx ky kz b">a &amp; b</code>将用<code class="fe kw kx ky kz b">a</code>的所有字段和<code class="fe kw kx ky kz b">b</code>的所有字段创建一个类型。<code class="fe kw kx ky kz b">a | b</code>将创建一个多态类型，包含<code class="fe kw kx ky kz b">a</code>的字段或<code class="fe kw kx ky kz b">b</code>的字段。因此，例如:</p><pre class="me mf mg mh gt mi kz mj mk aw ml bi"><span id="8bcf" class="mm lc iq kz b gy mn mo l mp mq">{ name:string, surname:string } &amp; { age:number }</span></pre><p id="b512" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">与类型相同:</p><pre class="me mf mg mh gt mi kz mj mk aw ml bi"><span id="10ba" class="mm lc iq kz b gy mn mo l mp mq">{ name:string, surname:string, age:number }</span></pre><p id="62b2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">鉴于:</p><pre class="me mf mg mh gt mi kz mj mk aw ml bi"><span id="0022" class="mm lc iq kz b gy mn mo l mp mq">type Car = { kind:"electric", num_batteries:number }<br/>         | { kind:"petrol", engine_size:number }</span></pre><p id="f9e4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将接受与两种形状完全匹配的值，因此永远不会容忍带有<code class="fe kw kx ky kz b">num_batteries</code>的<code class="fe kw kx ky kz b">petrol</code>汽车。</p><p id="f139" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">而且TypeScript还支持更多的特殊类型:<code class="fe kw kx ky kz b">keyof t</code>是类型<code class="fe kw kx ky kz b">t</code>的所有字段名的类型。因此:</p><pre class="me mf mg mh gt mi kz mj mk aw ml bi"><span id="e21b" class="mm lc iq kz b gy mn mo l mp mq">keyof { kind:"petrol", engine_size:number }</span></pre><p id="02ed" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将会是:</p><pre class="me mf mg mh gt mi kz mj mk aw ml bi"><span id="b8dd" class="mm lc iq kz b gy mn mo l mp mq">"kind" | "engine_size"</span></pre><p id="2b59" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">TypeScript支持的最后一个特殊类型是<code class="fe kw kx ky kz b">t[k]</code>，前提是<code class="fe kw kx ky kz b">k extends keyof t</code>。<code class="fe kw kx ky kz b">t[k]</code>是类型<code class="fe kw kx ky kz b">t</code>中字段<code class="fe kw kx ky kz b">k</code>的类型。例如:</p><pre class="me mf mg mh gt mi kz mj mk aw ml bi"><span id="350d" class="mm lc iq kz b gy mn mo l mp mq">{ id:number, name:string, surname:string, age:number }["age"]</span></pre><p id="332e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">简单来说就是<code class="fe kw kx ky kz b">string</code>。</p><p id="13c7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在TypeScript中还有其他相关的类型和类型操作符，但是出于本文的目的，我们并不需要它们全部。</p><h1 id="c0a9" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">查询界面</h1><p id="289d" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">通过使用这些高级类型，我们可以构建一个简单的查询定义接口。由于本文范围有限，我们将只支持一种查询定义语言，这种语言只允许我们指定从给定数据源中需要哪些字段，以及一些基本的过滤。引用和连接的管理也可以作为一个相对简单的扩展添加到我们在本文中设置的基础上，但是我们在这里不会看到它。</p><p id="d217" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">查询类在两种类型上是通用的:数据源的类型，以及我们期望从运行查询中得到的数据的类型。查询定义还将包含一个<code class="fe kw kx ky kz b">deserialize</code>函数，该函数将一个非结构化的<code class="fe kw kx ky kz b">any</code>转换成一个<code class="fe kw kx ky kz b">result</code>:</p><pre class="me mf mg mh gt mi kz mj mk aw ml bi"><span id="ee88" class="mm lc iq kz b gy mn mo l mp mq">export class Query&lt;result,source&gt; {<br/>  deserialize : (res:any) =&gt; result</span><span id="c750" class="mm lc iq kz b gy mr mo l mp mq">  ...</span><span id="3c84" class="mm lc iq kz b gy mr mo l mp mq">  constructor(deserialize : (res:any) =&gt; result) {<br/>    this.deserialize = deserialize<br/>  }<br/>}</span></pre><p id="24ea" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">任何查询的起点都可以方便地封装在一个helper函数中，该函数假设我们查询的任何实体至少都有一个<code class="fe kw kx ky kz b">id</code>字段:</p><pre class="me mf mg mh gt mi kz mj mk aw ml bi"><span id="46cf" class="mm lc iq kz b gy mn mo l mp mq">export let entity_query = &lt;t extends { id:number }&gt;() =&gt;<br/>  new Query&lt;{ id:t["id"] }, t&gt;(<br/>    res =&gt; "id" in res &amp;&amp; typeof res["id"] === "number" ?<br/>        ({ id:res["id"] as number })<br/>      : fail(`Error: expected id in ${JSON.stringify(res)}`)<br/>  )</span></pre><p id="6df8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意，<code class="fe kw kx ky kz b">entity_query</code>需要一个通用参数<code class="fe kw kx ky kz b">t</code>，它应该从<code class="fe kw kx ky kz b">{ id:number }</code>扩展而来(这意味着<code class="fe kw kx ky kz b">t</code>必须有一个类型为<code class="fe kw kx ky kz b">number</code>的字段<code class="fe kw kx ky kz b">id</code>，而不是说<code class="fe kw kx ky kz b">t</code>必须显式继承扩展类型)。生成的查询将产生类型为<code class="fe kw kx ky kz b">{ id:t[“id”] }</code>的结果。在这种情况下，反序列化将简单地检查接收到的blob是否具有类型为<code class="fe kw kx ky kz b">number</code>的预期字段<code class="fe kw kx ky kz b">id</code>。如果是这种情况，那么我们就可以生成所需的对象，否则我们肯定会因异常而失败(或者类型安全的替代方法，如<code class="fe kw kx ky kz b">Option</code>)。</p><p id="dd74" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们给我们的<code class="fe kw kx ky kz b">Query</code>类添加一些方法。因为我们希望我们的查询支持从远程数据源查找字段，所以我们可以添加一个<code class="fe kw kx ky kz b">with_field</code>方法。该方法将接受字段作为通用参数，该参数必须是任何一个<code class="fe kw kx ky kz b">source</code>类型的键:查找一个不在源中的字段是没有意义的！</p><pre class="me mf mg mh gt mi kz mj mk aw ml bi"><span id="f221" class="mm lc iq kz b gy mn mo l mp mq">readonly with_field = &lt;k extends keyof source&gt;(k:k) : ...</span></pre><p id="d1b9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe kw kx ky kz b">with_field</code>将返回一个与原始查询结果完全相同的新查询，包括出现在<code class="fe kw kx ky kz b">source</code>中的字段<code class="fe kw kx ky kz b">k</code>。当然，创建的查询仍然基于原始的<code class="fe kw kx ky kz b">source</code>。它的类型是这样的:</p><pre class="me mf mg mh gt mi kz mj mk aw ml bi"><span id="4a91" class="mm lc iq kz b gy mn mo l mp mq">Query&lt;result &amp; { [f in k]:source[k] }, source&gt;</span></pre><p id="dd7e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">类型<code class="fe kw kx ky kz b">result &amp; { [f in k]:source[k] }</code>包括我们在<code class="fe kw kx ky kz b">result</code>中找到的所有字段，加上一个新字段<code class="fe kw kx ky kz b">[f in k]</code>，其类型为<code class="fe kw kx ky kz b">source</code>中<code class="fe kw kx ky kz b">k</code>的<code class="fe kw kx ky kz b">source[k]</code>。</p><p id="f059" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">新查询中的反序列化基于先前查询的反序列化，然后将新字段<code class="fe kw kx ky kz b">k</code>添加到反序列化的结果中:</p><pre class="me mf mg mh gt mi kz mj mk aw ml bi"><span id="fd1f" class="mm lc iq kz b gy mn mo l mp mq">(res:any) =&gt; {<br/>  let obj = this.deserialize(res) as any<br/>  if (!(k in res)) throw new TypeError(`Error: missing key ${k} in ${JSON.stringify(res)}`)<br/>  obj[k] = res[k]<br/>  return obj as result &amp; { [f in k]:source[k] }<br/>}</span></pre><p id="f9e5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于这种方法，我们现在可以创建只包含给定类型的所需字段的查询:</p><pre class="me mf mg mh gt mi kz mj mk aw ml bi"><span id="385f" class="mm lc iq kz b gy mn mo l mp mq">interface Person { <br/>  id:number, <br/>  name:string, <br/>  surname:string, <br/>  nationality:string,<br/>  age:number }<br/>let name_age_query = entity_query&lt;Person&gt;()<br/>  .with_field("name")<br/>  .with_field("age")</span><span id="947e" class="mm lc iq kz b gy mr mo l mp mq">let res = name_age_query.deserialize({ "id":1, "name":"John", "age":23 })</span></pre><p id="cb11" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">反序列化的结果将采用以下类型:</p><pre class="me mf mg mh gt mi kz mj mk aw ml bi"><span id="bad7" class="mm lc iq kz b gy mn mo l mp mq">let res: {<br/>    id: number;<br/>} &amp; {<br/>    name: string;<br/>} &amp; {<br/>    age: number;<br/>}</span></pre><p id="ef29" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这意味着尝试类似于<code class="fe kw kx ky kz b">res.surname</code>的事情将导致编译器错误，而不是在运行时的某个地方被捕获。此外，如果我们试图创建一个包含一个不存在的字段的查询，例如通过将<code class="fe kw kx ky kz b">.with_field(“favorite_food”)</code>添加到我们的查询中，我们也会马上得到一个编译器错误，因为<code class="fe kw kx ky kz b">favorite_food</code>不是<code class="fe kw kx ky kz b">Person</code>的有效字段。这有可能大大减少与序列化相关的错误！</p><p id="b2a3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以扩展我们的查询系统来支持比较查询。例如，我们可以包含一个类型安全的筛选方法，该方法指定我们要基于属性和给定值的相等性进行筛选，从而验证该值总是与它所比较的属性具有相同的类型:</p><pre class="me mf mg mh gt mi kz mj mk aw ml bi"><span id="887c" class="mm lc iq kz b gy mn mo l mp mq">readonly filter_eq = &lt;k extends keyof result&gt;(k:k, v:result[k]) : Query&lt;result, source&gt; =&gt; {<br/>  return new Query(this.deserialize)<br/>}</span></pre><p id="fd75" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意，这里唯一真正的约束是<code class="fe kw kx ky kz b">k</code>必须是<code class="fe kw kx ky kz b">result</code>的有效属性，并且比较值<code class="fe kw kx ky kz b">v</code>必须具有相同类型的属性。例如，现在我们可以写:</p><pre class="me mf mg mh gt mi kz mj mk aw ml bi"><span id="34d5" class="mm lc iq kz b gy mn mo l mp mq">let q = entity_query&lt;Person&gt;()<br/>  .with_field("name")<br/>  .with_field("age")<br/>  .filter_eq("name", "Johnny")</span></pre><p id="2734" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">尝试<code class="fe kw kx ky kz b">.filter_eq(“name”, 3)</code>或<code class="fe kw kx ky kz b">.filter_eq(“City”, “Rotterdam”)</code>都会产生编译器错误:<code class="fe kw kx ky kz b">3</code>与<code class="fe kw kx ky kz b">string</code>不兼容，而<code class="fe kw kx ky kz b">City</code>不是<code class="fe kw kx ky kz b">Person</code>的字段。同样，这将确保我们的查询是格式良好的，甚至不需要运行代码。</p><h1 id="3e62" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">扩展ˌ扩张</h1><p id="1d0f" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">到目前为止，我们看到的代码相对简单，只涉及查询的规范和基于查询的反序列化函数的生成。可以进一步扩展这个框架，以包含更复杂的查询操作，如排序、分页，但更重要的是关系查找(尤其是<em class="la">一对多</em>)。此外，我们甚至可以将这个框架向前推进一步，从查询规范中生成查询本身(无论是OData、GraphQL还是其他什么)。这可能会成为这篇文章的有趣续篇:)</p><h1 id="3da0" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">嘶！</h1><p id="ba12" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">你是一个雄心勃勃的开发者吗？你喜欢这篇文章吗？您是否正在寻找一家其他软件工程师在高水平上工作的公司，通过应用函数式编程和类型理论概念来构建美观可靠的在线软件？那就别再找了:在令人敬畏的鹿特丹市，我们有多个空缺职位！我们接受各个层次的候选人:从老兵到渴望学习的年轻人。</p><h1 id="4058" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">代码转储—供参考</h1><pre class="me mf mg mh gt mi kz mj mk aw ml bi"><span id="d5e3" class="mm lc iq kz b gy mn mo l mp mq">export class Query&lt;result,source&gt; {<br/>  deserialize : (res:any) =&gt; result<br/>  readonly with_field = &lt;k extends keyof source&gt;(k:k) : Query&lt;result &amp; { [f in k]:source[k] }, source&gt; =&gt; {<br/>    return new Query(<br/>      (res:any) =&gt; {<br/>        let obj = this.deserialize(res) as any<br/>        if (!(k in res)) throw new TypeError(`Error: missing key ${k} in ${JSON.stringify(res)}`)<br/>        obj[k] = res[k]<br/>        return obj as result &amp; { [f in k]:source[k] }<br/>      }<br/>    )<br/>  }<br/>  readonly filter_eq = &lt;k extends keyof result&gt;(k:k, v:result[k]) : Query&lt;result, source&gt; =&gt; {<br/>    return new Query(this.deserialize)<br/>  }<br/>  readonly cast = &lt;t1&gt;() : Query&lt;result, source | t1&gt; =&gt; {<br/>    return new Query(this.deserialize)<br/>  }<br/>  constructor(deserialize : (res:any) =&gt; result) {<br/>    this.deserialize = deserialize<br/>  }<br/>}<br/>export let entity_query = &lt;t extends { id:number }&gt;() =&gt;<br/>  new Query&lt;{ id:t["id"] }, t&gt;(<br/>    res =&gt; "id" in res &amp;&amp; typeof res["id"] === "number" ?<br/>        ({ id:res["id"] as number })<br/>      : fail(`Error: expected id in ${JSON.stringify(res)}`)<br/>  )</span><span id="3d96" class="mm lc iq kz b gy mr mo l mp mq">interface Person { id:number, name:string, surname:string, age:number }<br/>let q = entity_query&lt;Person&gt;()<br/>  .with_field("name")<br/>  .with_field("age")<br/>  .filter_eq("name", "Johnny")</span><span id="fb08" class="mm lc iq kz b gy mr mo l mp mq">let res = q.deserialize({ "id":1, "name":"John", "age":23 })</span></pre></div></div>    
</body>
</html>