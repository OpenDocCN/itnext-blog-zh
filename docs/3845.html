<html>
<head>
<title>Kubernetes node affinity: Placing pods on specific nodes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes节点关联:将pod放在特定的节点上</h1>
<blockquote>原文：<a href="https://itnext.io/kubernetes-node-affinity-placing-pods-on-specific-nodes-8ea918dda9b9?source=collection_archive---------3-----------------------#2020-03-09">https://itnext.io/kubernetes-node-affinity-placing-pods-on-specific-nodes-8ea918dda9b9?source=collection_archive---------3-----------------------#2020-03-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/b1ecf00053a6edb82504ecf3e5d3eec7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZR-rR9sCTRgQHONbxzZSCQ.png"/></div></div></figure><p id="e377" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">有些情况下，我们需要在Kubernetes集群中的特定节点上运行一些应用程序。例如，有一个应用程序需要的资源比群集中的任何单个节点都多。在这种情况下，我们需要创建一个新节点，并将这个应用程序放在这个新节点中。我们如何做到这一点？Kubernetes会允许我们将pod分配到我们决定的特定节点上吗？当然可以。但是要做到这一点，我们需要给Kubernetes scheduler一些小的输入。Kubernetes调度器可以被限制为使用几个不同的选项将一个pod放在特定的节点上。</p><ol class=""><li id="64bd" class="kz la it kd b ke kf ki kj km lb kq lc ku ld ky le lf lg lh bi translated"><a class="ae li" href="https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#nodeselector" rel="noopener ugc nofollow" target="_blank">节点选择器</a></li><li id="1813" class="kz la it kd b ke lj ki lk km ll kq lm ku ln ky le lf lg lh bi translated"><a class="ae li" href="https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#node-affinity" rel="noopener ugc nofollow" target="_blank">节点亲和力</a></li><li id="42b1" class="kz la it kd b ke lj ki lk km ll kq lm ku ln ky le lf lg lh bi translated"><a class="ae li" href="https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#inter-pod-affinity-and-anti-affinity" rel="noopener ugc nofollow" target="_blank"> Pod亲和力</a></li><li id="46f9" class="kz la it kd b ke lj ki lk km ll kq lm ku ln ky le lf lg lh bi translated"><a class="ae li" href="https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/" rel="noopener ugc nofollow" target="_blank">污点和宽容</a></li></ol><p id="a2df" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这篇文章中，我将重点介绍第二种方法，因为它允许我们将pod放置到特定的节点，无论是作为硬规则还是软规则。硬性规则意味着，必须满足该规则才能将一个pod调度到给定的节点上。软规则意味着如果调度程序不能满足我们的约束，pod仍然会被调度到不同的节点。因此调度程序会尝试强制执行，但不会保证pod满足我们的调度约束。</p><p id="002e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们来看看如何使用节点关联机制将pod放置到特定节点上的步骤。</p><ol class=""><li id="aceb" class="kz la it kd b ke kf ki kj km lb kq lc ku ld ky le lf lg lh bi translated">列出群集中的节点及其标签:</li></ol><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="f933" class="lx ly it lt b gy lz ma l mb mc">kubectl get nodes --show-labels</span></pre><p id="b261" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">2.选择要运行应用程序的节点，并为其添加标签:</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="6efa" class="lx ly it lt b gy lz ma l mb mc">kubectl label nodes &lt;node-name&gt; &lt;label-key&gt;=&lt;label-value&gt;</span></pre><p id="07ab" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">可以选择任何键:值对来标记节点。我将使用“type:t2medium”作为我的节点的示例键值对。</p><p id="3b83" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">3.现在我们需要创建一个调度到所选节点的pod:</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="8f44" class="lx ly it lt b gy lz ma l mb mc">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: nginx<br/>spec:<br/>  selector:<br/>    matchLabels:<br/>      app: nginx<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: nginx<br/>    spec:<br/>     <strong class="lt iu"> affinity:<br/>        nodeAffinity:<br/>          requiredDuringSchedulingIgnoredDuringExecution:<br/>            nodeSelectorTerms:<br/>            - matchExpressions:<br/>              - key: type<br/>                operator: In<br/>                values:<br/>                - t2medium</strong><br/>      containers:<br/>      - image: nginx<br/>        name: nginx</span></pre><p id="b041" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">将上述部署yaml文件应用到您的集群，并验证pod正在所选节点上运行:</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="a4f1" class="lx ly it lt b gy lz ma l mb mc">kubectl get pods --all-namespaces -o wide</span></pre><p id="c1f8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">上面的命令将向我们显示pod信息以及它运行的节点。然后，您可以验证pod是否运行在具有相同键值对(例如:type:t2medium)的所选节点上。</p><p id="29ce" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">除了<code class="fe md me mf lt b">requiredDuringSchedulingIgnoredDuringExecution</code>类型的节点关联性之外，还存在<code class="fe md me mf lt b">preferredDuringSchedulingIgnoredDuringExecution</code>。第一个可以被认为是一个“硬”规则，而第二个构成了一个“软”规则，Kubernetes试图强制执行，但不会保证。</p><p id="554c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您可以指明该规则是“软”的，而不是硬的要求，因此如果调度程序不能满足它，pod仍然会被调度。</p><p id="a211" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在调度器过滤掉不符合特定要求的节点后，它会为每个剩余节点计算一个优先级分数，以找到“最佳”节点。这个分数是由多个内置的优先级函数相加得到的，如<code class="fe md me mf lt b">LeastRequestedPriority</code>、<code class="fe md me mf lt b">BalancedResourceAllocation</code>或<code class="fe md me mf lt b">SelectorSpreadPriority</code>。<code class="fe md me mf lt b">NodeAffinityPriority</code>也是这些功能之一，因此当一个pod进入调度程序并且<code class="fe md me mf lt b">preferredDuringSchedulingIgnoredDuringExecution</code>被设置为按需节点时，它将为集群中的每个节点计算一个优先级分数，并且仅对<code class="fe md me mf lt b">matchExpression</code>为真的节点将<code class="fe md me mf lt b">weight</code>字段的值添加到该分数中。因此，这些节点对于<code class="fe md me mf lt b">NodeAffinityPriority</code>将具有更高的优先级分数，但是可能发生的情况是，其他节点上的其他优先级函数平衡了这个更高的优先级。因此，即使在<code class="fe md me mf lt b">matchExpression</code>为真的节点上仍然有空闲容量，pod也可以放在其他地方。</p><p id="d047" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">那么对于将<code class="fe md me mf lt b">weight</code>设置在1-100范围内有什么好的建议？很简单:您无法预先计算每个节点的优先级分数，因此根据经验，您越希望满足自己的偏好，就需要设置越高的权重。</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="cfa0" class="lx ly it lt b gy lz ma l mb mc">apiVersion: apps/v1<br/>kind: <!-- -->Deployment<br/>metadata:<br/>  name: nginx<br/>spec:<br/>  affinity:<br/> <strong class="lt iu">   nodeAffinity:<br/>      preferredDuringSchedulingIgnoredDuringExecution:<br/>      - weight: 1<br/>        preference:<br/>          matchExpressions:<br/>          - key: type<br/>            operator: In<br/>            values:<br/>            - t2medium</strong><br/>  containers:<br/>  - name: nginx<br/>    image: nginx</span></pre><p id="ecf4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">同样，通过节点关联，我们可以使用每个节点上的标签告诉Kubernetes需要在哪个节点上调度哪些pods。希望这篇博客能帮助你理解什么是节点亲和性，以及在调度你的pod时如何使用它。让我们很快在另一篇文章上见面吧！！</p></div></div>    
</body>
</html>