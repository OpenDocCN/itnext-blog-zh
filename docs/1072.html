<html>
<head>
<title>Reactive Programming basics in 5 min (RxJS)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">5分钟反应式编程基础(RxJS)</h1>
<blockquote>原文：<a href="https://itnext.io/reactive-programming-basics-in-5-min-rxjs-8499dac374c?source=collection_archive---------5-----------------------#2018-07-16">https://itnext.io/reactive-programming-basics-in-5-min-rxjs-8499dac374c?source=collection_archive---------5-----------------------#2018-07-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><h1 id="2a6c" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">主要反对意见</h1><p id="4725" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">这篇文章是在这个<a class="ae lj" href="https://gist.github.com/staltz/868e7e9bc2a7b8c1f754" rel="noopener ugc nofollow" target="_blank">教程</a>的启发下写的。我发现理解开头非常有用，特别是因为反应式编程的入门水平很高，尤其是RxJS的api。描述这样的材料会引导你进行大量的反思，以了解你想要与读者分享什么新的东西，而不是重复已经遍布互联网的材料。</p><h1 id="c6d5" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">反应式编程的本质</h1><p id="fb65" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">什么是反应式编程？这是一个基于异步数据流的程序。在流下意味着开发过程中的一切可能:来自输入控件的事件、鼠标事件、变量、动作、数据结构、数据请求和响应。你只是宣布对这些流的反应，它们会协调所有的反应。</p><p id="d816" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">作为时间轴中有序事件序列的流可以发出三种不同类型的数据:数据有效载荷、错误和流结束信号。您可以在每种类型的数据上附加自己的处理程序，或者只关注数据负载。</p><p id="348d" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">订阅过程是监听特定流上的新事件。观察者是我们定义为对某些流事件的反应的函数。信息流本身是一种可观察的东西，我们在倾听新的事件。(这是一种观察者模式，在之前的<a class="ae lj" href="https://medium.com/@ruslanmalogulko/easy-patterns-observer-63c832d41ffd" rel="noopener">文章</a>中描述过)。</p><p id="87e3" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">流的主要好处是它们避免了内存泄漏，并且从内存消耗的角度来看非常便宜。将几个流加入到新的流中，过滤流事件，将一个流作为输入传递给另一个流，从另一个流中排除一个流的结果，这些都非常容易。</p><p id="7667" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">通常流用下一种方式描述:</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="a229" class="ly jo iq lu b gy lz ma l mb mc">---d-----d---d----x------d--|-&gt;</span><span id="3d8a" class="ly jo iq lu b gy md ma l mb mc">d - emitted values<br/>x - error<br/>| - end signal of current stream<br/>-&gt; - timeline itself</span></pre><h1 id="9778" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">您可以对流执行的主要功能</h1><p id="75e9" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">一般来说，在许多反应式库中，你可以找到许多已经实现的函数来帮助编排流。让我们来描述其中的一些。</p><p id="a004" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated"><strong class="kn ir"> map </strong>:基于当前流数据创建另一个流。(例如，对于每个发出的值，我们希望在单独的流中发出1):</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="2fc6" class="ly jo iq lu b gy lz ma l mb mc">clickStream: ---a---b------c-----d---&gt;<br/>                   map(item =&gt; 1)<br/>mapStream:   ---1---1------1-----1---&gt;</span></pre><p id="fede" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated"><strong class="kn ir"> filter </strong>:在过滤当前流的基础上创建另一个流(过滤发射值):</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="6a13" class="ly jo iq lu b gy lz ma l mb mc">clickStream: ---3---2------4-----1---&gt;<br/>              filter(item =&gt; item &gt; 2)<br/>filterStream:---3----------4---------&gt;</span></pre><p id="352a" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated"><strong class="kn ir">扫描</strong>:聚合所有之前发出的值，并作为函数<code class="fe me mf mg lu b">g(aggregatedValue, currentValue)</code>在流上产生值；</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="860a" class="ly jo iq lu b gy lz ma l mb mc">clickStream: ---2---2------3-----1---&gt;<br/>           scan((sum, item) =&gt; sum += item)<br/>scanStream:  ---2---4------7-----8---&gt;</span></pre><p id="7e52" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated"><strong class="kn ir">间隔</strong>:创建流，以给定的间隔和开始延迟发出值；</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="1b34" class="ly jo iq lu b gy lz ma l mb mc">interval(startDelay, intervalTime):<br/>intervalStream:  -0-1-2-3-4-5-6-7-8-(.....)--&gt;</span></pre><p id="bbd7" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated"><strong class="kn ir"> buffer </strong>:创建按照某种标准(例如时间限制)缓冲发出值的流；</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="2769" class="ly jo iq lu b gy lz ma l mb mc">clickStream: ---2-2-------3------1-2------3--2-------&gt;<br/>                     buffer(interval(1000))<br/>scanStream:  ------[2,2]-----[3]-----[1,2]-----[3,2]-&gt;</span></pre><p id="395c" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated"><strong class="kn ir"> merge </strong>:将两个或多个单独的流合并成一个结果流，从所有合并的流中发出数据；</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="c63a" class="ly jo iq lu b gy lz ma l mb mc">clickStream:   ---c-c-------c------c-c------c--c-------&gt;<br/>keyDownStream: -------k---k----k----k---k--------k-----&gt;</span><span id="a03c" class="ly jo iq lu b gy md ma l mb mc">                merge(slickStream, keyDownStream)<br/>mergedStream:  ---c-c-k---k-c--k---ckc--k---c--c-k-----&gt;</span></pre><p id="efc5" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">反应式编程提高了代码的抽象级别，因此您可以专注于事件的相互依赖性，而不必经常摆弄大量的实现细节。今天，网络应用程序更加动态，有许多实时事件UI应该以某种方式作出反应。这是一个很好的想法，将这样的关注分成流，并忘记在应用程序上传播交互逻辑的地狱。</p><h1 id="3071" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">使用示例</h1><p id="5a1f" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">让我们考虑一个不太复杂的解决ui问题的例子。我们在页面上有一些输入字段，这个输入应该在没有交互的3秒钟内阻塞(没有按键或鼠标移动)。只有在页面上单击三次鼠标后，用户才能继续编辑该字段。基于RxJS库的实现，它有非常丰富的api，可以用于很多很多用例，甚至更多。但是对于当前的例子，我们只需要基本的，如上所述。</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="3735" class="ly jo iq lu b gy lz ma l mb mc">// let's create streams from native page events with <br/>// fromEvent function</span><span id="fe0d" class="ly jo iq lu b gy md ma l mb mc">const moveSource = fromEvent(document, "mousemove");<br/>const keyDownSource = fromEvent(document, "keydown");<br/>const clickSource = fromEvent(document, "click");</span><span id="902c" class="ly jo iq lu b gy md ma l mb mc">// let's get a link to page body, input control and prompting <br/>// text which is only available in edit mode</span><span id="f060" class="ly jo iq lu b gy md ma l mb mc">const body = document.querySelector("body");<br/>const input = document.querySelector("input");<br/>const prompt = document.querySelector("#prompt");</span><span id="52a8" class="ly jo iq lu b gy md ma l mb mc">// so, once our streams defined as a sources we can manipulate <br/>// them in needed way and subscribe to operate with result</span><span id="31b1" class="ly jo iq lu b gy md ma l mb mc">clickSource<br/>  .pipe( // collect all manipulations into the pipe<br/>    buffer(interval(1000)), // buffer clicks per 1 sec<br/>    filter(x =&gt; x.length &gt; 2) // filter them by amount more than 2<br/>  )<br/>  .subscribe(x =&gt; {<br/>      // describe what should happen when triple and more <br/>      // clicks happened (enable input control, focus that <br/>      // field and display edit prompt)</span><span id="77d4" class="ly jo iq lu b gy md ma l mb mc">      input.disabled = false;<br/>      input.focus();<br/>      prompt.style.display = 'inline';<br/>});</span><span id="4c65" class="ly jo iq lu b gy md ma l mb mc">// collect mouse keydown events</span><span id="5e9c" class="ly jo iq lu b gy md ma l mb mc">keyDownSource<br/>  .pipe(<br/>    // and merge current stream with mouse move events stream</span><span id="53b5" class="ly jo iq lu b gy md ma l mb mc">    merge(moveSource),</span><span id="3909" class="ly jo iq lu b gy md ma l mb mc">    // switchMap resets mapping function right after new stream <br/>    // value  emitted and waits 3 sec to block ui by passing <br/>    // to subscriber 'inactive' value</span><span id="0d30" class="ly jo iq lu b gy md ma l mb mc">    switchMap(() =&gt;<br/>      interval(3000).pipe(<br/>        mapTo('inactive')<br/>      )<br/>    )<br/>  )<br/>  .subscribe(x =&gt; {</span><span id="5bc0" class="ly jo iq lu b gy md ma l mb mc">    // in subscriber we checking if value came as 'inactive' <br/>    // and after that disabling input control and make prompt <br/>    // hidden to user.</span><span id="44f2" class="ly jo iq lu b gy md ma l mb mc">    console.log(x);<br/>    if (x === "inactive") {<br/>      input.disabled = true;<br/>      prompt.style.display = 'none';<br/>    } <br/>  });</span></pre><figure class="lp lq lr ls gt mh"><div class="bz fp l di"><div class="mi mj l"/></div></figure><h1 id="0b49" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">到目前为止还不错(而不是总结)</h1><p id="ae52" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">反应式方法是伟大而复杂的。但是它需要完成从命令式思维到陈述式思维的转换。在很多情况下，这看起来像是开销，但是你可以决定你的应用程序是否有很多需要复杂管理的事件。在任何情况下，关注分离都是重要且必要的…为什么不从系统中的事件开始呢？:)干杯</p></div></div>    
</body>
</html>