<html>
<head>
<title>Testing Kubernetes Go applications</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">测试Kubernetes Go应用程序</h1>
<blockquote>原文：<a href="https://itnext.io/testing-kubernetes-go-applications-f1f87502b6ef?source=collection_archive---------0-----------------------#2018-06-20">https://itnext.io/testing-kubernetes-go-applications-f1f87502b6ef?source=collection_archive---------0-----------------------#2018-06-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/d6ca3f91c3ba295ac6467498063eb864.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uYUmleDbFseRu0HmAZnJYg.jpeg"/></div></div></figure><p id="0165" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可以在我的新书中了解更多关于使用Kubernetes API和操作符的信息:<a class="ae kw" href="https://bit.ly/3vsuwI9" rel="noopener ugc nofollow" target="_blank">https://bit.ly/3vsuwI9</a></p><p id="4c2b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Kubernetes应用程序可以用Go语言编写，使用<code class="fe kx ky kz la b">client-go</code>库:【https://github.com/kubernetes/client-go】<a class="ae kw" href="https://github.com/kubernetes/client-go" rel="noopener ugc nofollow" target="_blank"/>。这个库提供了测试用它编写的应用程序的工具。让我们来探索这些工具。</p><p id="23bc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可以在一个专门的github知识库上找到这篇文章的完整来源:<a class="ae kw" href="https://github.com/feloy/testing-k8s-go-apps" rel="noopener ugc nofollow" target="_blank">https://github.com/feloy/testing-k8s-go-apps</a></p><h1 id="6fb3" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">kubernetes套餐</h1><p id="28dd" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">让我们首先检查一下<code class="fe kx ky kz la b">kubernetes</code>包，它提供了用于创建新的<code class="fe kx ky kz la b">Clientset</code>对象的<code class="fe kx ky kz la b">NewForConfig</code>方法，需要连接到Kubernetes集群。</p><p id="6198" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe kx ky kz la b">Clientset</code>类型实现了同一个包中定义的<code class="fe kx ky kz la b">Interface</code>接口，该类型的所有方法都属于该接口。因此，可以创建这个接口的另一个实现来替换真实的实现。</p><p id="4a12" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">感谢<code class="fe kx ky kz la b">client-go</code>开发者，他们在<code class="fe kx ky kz la b">kubernetes/fake</code>包中完成了这项工作。这个包提供了一个新的<code class="fe kx ky kz la b">fake.Clientset</code>类型，也实现了这个接口。这个包还提供了一个<code class="fe kx ky kz la b">NewSimpleClientset</code>方法，可以用来创建一个假的客户端集，这对测试我们的应用程序非常有用。</p><h1 id="0f7c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用<code class="fe kx ky kz la b">Interface</code>，卢克！</h1><p id="b3ef" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">为了测试您的应用程序，您将不得不使用真实的(来自<code class="fe kx ky kz la b">kubernetes</code>包)<code class="fe kx ky kz la b">Clientset</code>用于您的应用程序，使用假的(来自<code class="fe kx ky kz la b">kubernetes.fake</code>包)用于您的测试。</p><p id="ac64" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">出于这个原因，你必须声明你的方法使用<code class="fe kx ky kz la b">Clientset</code>来代替使用<code class="fe kx ky kz la b">Interface</code>类型。因此，您将能够使用任何实现，这取决于您是在应用程序中还是在测试中。</p><p id="b78f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们的例子中，我们创建了一个包含类型为<code class="fe kx ky kz la b">kubernetes.Interface</code>的<code class="fe kx ky kz la b">clientset</code>字段的<code class="fe kx ky kz la b">k8s</code>结构。</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mi mj l"/></div></figure><h1 id="778a" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">获取服务器版本</h1><p id="3961" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">我们现在可以开始使用客户机集来处理我们的Kubernetes集群了。首先，让我们编写一个获取Kubernetes服务器版本的方法。下面是完整的实现:</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="55cc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您可以访问Kubernetes集群，并且在您的<code class="fe kx ky kz la b">.kube</code>路径中有相应的<code class="fe kx ky kz la b">config</code>文件，您可以尝试运行您的应用程序:</p><pre class="me mf mg mh gt mk la ml mm aw mn bi"><span id="80b3" class="mo lc iq la b gy mp mq l mr ms">$ go run main.go<br/>v1.9.2</span></pre><h1 id="aa4d" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">并测试它</h1><p id="27ce" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">我们现在必须测试我们的<code class="fe kx ky kz la b">getVersion</code>方法。为此，我们首先必须在<code class="fe kx ky kz la b">NewSimpleClientset</code>方法的帮助下，创建一个<code class="fe kx ky kz la b">k8s</code>结构的实例，其中包含一个客户端集的伪实现，而不是真实的实现。然后，我们可以在这个假实例上调用<code class="fe kx ky kz la b">getVersion</code>方法，并获得由我们的假kubernetes集群返回的版本，它将总是返回相同的默认值。</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mi mj l"/></div></figure><h1 id="aaaf" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">验证服务器版本</h1><p id="71d9" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">我们现在可以编写一个更高级的方法来验证集群服务器是否是预期的版本:</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mi mj l"/></div></figure><h1 id="1d18" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">并测试它</h1><p id="5f60" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">为了测试它，我们将不得不改变由假客户机集返回的版本值。为此，我们看到假的<code class="fe kx ky kz la b">Discovery</code>实现公开了一个我们可以修改的<code class="fe kx ky kz la b">FakedServerVersion</code>字段。多亏了这个工具，我们能够测试我们的<code class="fe kx ky kz la b">isVersion</code>方法的所有情况:</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mi mj l"/></div></figure><h1 id="9fd8" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">创作，反应！</h1><p id="278e" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">在某些情况下，我们希望当我们对它进行一些操作时，我们的假集群有所反应。例如，如果我们需要验证用户可以在集群上创建一些部署，我们将必须创建一些<code class="fe kx ky kz la b">SelfSubjectAccessReview</code> (SSAR)并检查其状态。当我们创建这样一个SSAR时，一个真正的Kubernetes集群将用相应的值更新它的状态。假的集群不行，但是我们自己可以做。</p><h1 id="ffb5" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">我可以吗？</h1><p id="5e91" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">这里有一个新方法，使用<code class="fe kx ky kz la b">SelfSubjectAccessReview</code>来确定运行应用程序的用户是否可以创建部署:</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mi mj l"/></div></figure><h1 id="d0a7" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">并测试它</h1><p id="ae3e" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">和以前一样，我们将首先尝试用一个<code class="fe kx ky kz la b">NewSimpleClientset</code>来测试这个方法。在这种情况下，我们创建的SSAR不会更新，其状态始终为false。该值涵盖了我们想要测试用户没有创建部署的授权的情况，但不包括其他情况。</p><h1 id="4ccc" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">测试包装中的假类型</h1><p id="6fca" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">如果我们查看<code class="fe kx ky kz la b">fake.Clientset</code>类型的内容，我们可以看到它嵌入了<code class="fe kx ky kz la b">testing.Fake</code>类型。这种类型实现了<code class="fe kx ky kz la b">client.Interface</code>接口，尤其是公开了一个<code class="fe kx ky kz la b">AddReactor</code>方法，用于对某些操作做出反应。这是它的签名:</p><pre class="me mf mg mh gt mk la ml mm aw mn bi"><span id="a21e" class="mo lc iq la b gy mp mq l mr ms">type ReactionFunc func(action <a class="ae kw" href="https://godoc.org/k8s.io/client-go/testing#Action" rel="noopener ugc nofollow" target="_blank">Action</a>) (handled <a class="ae kw" href="https://godoc.org/builtin#bool" rel="noopener ugc nofollow" target="_blank">bool</a>, ret <a class="ae kw" href="https://godoc.org/k8s.io/apimachinery/pkg/runtime" rel="noopener ugc nofollow" target="_blank">runtime</a>.<a class="ae kw" href="https://godoc.org/k8s.io/apimachinery/pkg/runtime#Object" rel="noopener ugc nofollow" target="_blank">Object</a>, err <a class="ae kw" href="https://godoc.org/builtin#error" rel="noopener ugc nofollow" target="_blank">error</a>)</span><span id="6b96" class="mo lc iq la b gy mt mq l mr ms">func (c *<a class="ae kw" href="https://godoc.org/k8s.io/client-go/testing#Fake" rel="noopener ugc nofollow" target="_blank">Fake</a>) AddReactor(verb, resource <a class="ae kw" href="https://godoc.org/builtin#string" rel="noopener ugc nofollow" target="_blank">string</a>, reaction <a class="ae kw" href="https://godoc.org/k8s.io/client-go/testing#ReactionFunc" rel="noopener ugc nofollow" target="_blank">ReactionFunc</a>)</span></pre><p id="720d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe kx ky kz la b">AddReactor</code>方法首先获得两个参数<code class="fe kx ky kz la b">verb</code>和<code class="fe kx ky kz la b">resource</code>，它们描述了我们想要对其做出反应的操作。比如在<code class="fe kx ky kz la b">create</code>上打一个<code class="fe kx ky kz la b">SelfSubjectAccessReview</code>。该方法然后获得最新的参数<code class="fe kx ky kz la b">reaction</code>，该参数是将在该操作上执行的方法。这个<code class="fe kx ky kz la b">reaction</code>方法返回一个<code class="fe kx ky kz la b">handled</code>值，指示这个反应器是否有效地处理了这个案例，一个<code class="fe kx ky kz la b">ret</code>对象将替换原来的对象，以及一个<code class="fe kx ky kz la b">err</code>，如果我们想要在操作过程中模拟一个错误。</p><p id="3014" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有了这些反应器，我们现在可以处理两种最新的情况，用户可以创建一个部署，或者当SSAR的创建引起错误时。</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mi mj l"/></div></figure><h1 id="69ea" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="4fad" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">有了这些简单的方法，您应该能够开始并测试用Go编写的Kubernetes应用程序。</p><p id="707e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我真的很感谢对这些第一方法的任何评论，以及任何到其他方法的链接——我会在发现新方法后尽快完成这篇文章。</p></div></div>    
</body>
</html>