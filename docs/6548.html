<html>
<head>
<title>Winds of Change in Web Data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">网络数据的变化趋势</h1>
<blockquote>原文：<a href="https://itnext.io/winds-of-change-in-web-data-728187331f53?source=collection_archive---------1-----------------------#2021-12-15">https://itnext.io/winds-of-change-in-web-data-728187331f53?source=collection_archive---------1-----------------------#2021-12-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/d3bad58fec0f8143dd93af7ff21aacb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uNzdYm56VOaYuiCOMOAqlA.jpeg"/></div></div></figure><div class=""/><blockquote class="jy jz ka"><p id="187a" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们不会停止探索<br/>，我们所有探索<br/>的终点将是到达我们开始的地方<br/>，并第一次了解这个地方</p></blockquote><p id="3b5a" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">T.S .艾略特的话无疑是科技行业赖以生存的咒语。新趋势不时席卷我们的行业，只是为了演变成与我们以前非常相似的东西，只是现在有了新的可能性。</p><p id="3e42" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">不久前，还没有人考虑过你会选择哪个OSS数据库来存储操作数据:如果你想有一个服务器供客户机连接，你可以选择Postgres或MySQL。如果您有一个需要一些本地结构化数据的简单应用程序，那么您会选择SQLite的便利性和低设置成本。</p><p id="3d16" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">但是由于我们不会停止探索，我们集体放弃了SQL的安全港，去寻找新的模型和新的横向扩展架构来满足webscale应用程序的需求。但随着潮水的退去，它也在流动。越来越常见的是，开发人员得出结论，随着硬件、商业环境和开发人员偏好的最近变化，Postgres在几乎任何情况下都是一个很好且安全的选择。</p><p id="64a1" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">但是SQLite呢？嵌入式简单数据库在我们的旅程中还有一席之地吗？在这篇文章中，我将探索一些变革的趋势，为如何考虑2022年及以后的数据库铺平道路，并介绍<a class="ae ld" href="https://github.com/chiselstrike/chiselstore" rel="noopener ugc nofollow" target="_blank">chisser store</a>:一个可嵌入的分布式zero-conf SQLite库，它很可能对您足够好。</p><h2 id="17a0" class="le lf jb bd lg lh li dn lj lk ll dp lm la ln lo lp lb lq lr ls lc lt lu lv lw bi translated">不断变化的景观</h2><p id="ba5f" class="pw-post-body-paragraph kb kc jb ke b kf lx kh ki kj ly kl km la lz kp kq lb ma kt ku lc mb kx ky kz ij bi translated">那么，什么样的转变使得我们有理由重新审视传统的解决方案呢？</p><p id="da8f" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated"><strong class="ke jc">尺寸</strong></p><p id="fffb" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">第一个大的变化仅仅是今天硬件的大小。现代存储设备并没有变得更小:在AWS上，只需点击一个按钮，<a class="ae ld" href="https://aws.amazon.com/ec2/instance-types/i4g/" rel="noopener ugc nofollow" target="_blank">就可以产生一个带有30 TB附加存储的服务器</a>。</p><p id="2edd" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">当对分布式数据库的探索开始时，它主要是由不适合单个服务器的主机数据的需求驱动的。当然，这样的用例仍然存在于特定的领域。但是，在与大数据客户密切合作近十年后，我可以用一只手的手指数出他们中有多少人真正超过了30TB大关。一旦你走出专门的大数据世界，回到web应用程序，很可能你的所有数据要么可以放在一台服务器上，要么可以放在少数几台服务器上，在这种情况下，可以使用基本的分片技术。</p><p id="a338" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">分布仍然很重要，但它不是数据量的推动者，而是需要额外的节点来提供容错和接近用户，以获得更好的延迟。</p><p id="dce1" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated"><strong class="ke jc">性能</strong></p><p id="cccd" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">那些大型存储设备也没有变慢:NVMe设备现在变得无处不在，随之而来的是操作系统接口和API的变化，旨在利用它们。根据我的经验，大多数人并没有真正意识到现代NVMe设备有多快，以及这对数据库有什么实际影响。对于很大一部分开发人员来说，当您提到“数据库”时，首先浮现在脑海中的是受存储速度限制的东西。毕竟，数据库的工作不是存储数据吗？</p><figure class="mc md me mf gt is"><div class="bz fp l di"><div class="mg mh l"/></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk translated">两位数的每秒百万次运算是存储世界的新常态。</figcaption></figure><p id="0a79" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">当然，直到您的设备和软件堆栈的组合能够在单核中每秒处理1000万个请求。现在，您只需点击一个按钮，就可以启动一个64核的盒子(它有30TB的附加存储)，这意味着当您的单核向您的NVMe设备发出1000万个请求时，其他63个内核可以自由地做您想做的任何事情。</p><p id="82ad" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">第一个直接后果是，数据库现在受到CPU能力的限制。但另一个有趣的结果是，计算和数据库节点必然会合并:当存储节点不再有任何特殊之处时，就没有理由将计算和存储视为具有不同访问模式和特征的独立实体。</p><p id="8892" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">事实上，SQLite的一个基本版本，不需要我们做太多的调优工作，就可以在16个线程的情况下每秒处理超过50万个读请求。如果其他水手的故事是可信的，经过一些努力，这些数字可能会更高，<a class="ae ld" href="https://blog.expensify.com/2018/01/08/scaling-sqlite-to-4m-qps-on-a-single-server/" rel="noopener ugc nofollow" target="_blank">单个服务器就有多达400万次阅读</a></p><pre class="mc md me mf gt mm mn mo mp aw mq bi"><span id="b1fd" class="le lf jb mn b gy mr ms l mt mu">[OVERALL], ThreadCount, 16<br/>[OVERALL], RunTime(ms), 17656<br/>[OVERALL], Throughput(ops/sec), 566379.70</span></pre><p id="dd1b" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">写入速度较慢，实际上要慢得多:</p><pre class="mc md me mf gt mm mn mo mp aw mq bi"><span id="65bb" class="le lf jb mn b gy mr ms l mt mu">[OVERALL], ThreadCount, 1<br/>[OVERALL], RunTime(ms), 38478<br/>[OVERALL], Throughput(ops/sec), 2598.88</span></pre><p id="2ef2" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">但是对于web应用程序来说，以读取为主的用例非常常见，而且正如我们很快就会看到的那样，这并不是写入的故事的结尾。</p><p id="4b30" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated"><strong class="ke jc">部署模式</strong></p><p id="c27e" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">第三个架构转变是Kubernetes的传播，以及随之而来的心态变化。在Kubernetes之前，数据库节点是永久性的:无论是金属盒还是虚拟机，一旦启动，它将永远与该节点相连。但是在库伯内特人的世界里，事物本质上都是短暂的。在Kubernetes时代之前诞生的数据库尽可能使用各种技巧来绑定资源，并模仿它们的旧方式。</p><p id="8831" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">但是接受这种新现实的节点表现不同:它们是自然分布的，如果一个节点因为这样或那样的原因死亡，它不会被保留:它只是被替换。从对象存储中流式传输快照，并重放日志的增量。如果这听起来很疯狂，请记住这些服务器可能有100Gbps的链路和每秒几十GB的存储写入速度。</p><p id="2d56" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">采用这样的设计还有其他后果:节点可以在内存中运行，因为它们无论如何都会在失败时被破坏。</p><p id="05dd" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">对于数据适合内存的情况(请记住，2021年的“适合内存”很容易意味着5tb)，sqlite要快得多:</p><pre class="mc md me mf gt mm mn mo mp aw mq bi"><span id="f70e" class="le lf jb mn b gy mr ms l mt mu">[OVERALL], ThreadCount, 1<br/>[OVERALL], RunTime(ms), 2678<br/>[OVERALL], Throughput(ops/sec), 37341.29</span></pre><p id="d8e6" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">尽管如此，内存还是太贵了，而存储越来越便宜。但这也为另一种设计敞开了大门:不要fsync:这种存储可以作为索引大量数据的一种方式，但这一切都被视为短暂的。</p><p id="1dd5" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">对于我们的基准测试，禁用fsync产出:</p><pre class="mc md me mf gt mm mn mo mp aw mq bi"><span id="a127" class="le lf jb mn b gy mr ms l mt mu">[OVERALL], ThreadCount, 1<br/>[OVERALL], RunTime(ms), 8795<br/>[OVERALL], Throughput(ops/sec), 11370.09</span></pre><p id="aa96" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">Kubernetes也只是冰山一角。在面向云的场景中仍然占主导地位，在今天的环境中，web应用程序通常是完全无服务器的，它们的应用程序代码通过边缘功能在边缘计算位置上运行。像<a class="ae ld" href="https://vercel.com/" rel="noopener ugc nofollow" target="_blank"> Vercel </a>和<a class="ae ld" href="http://www.netlify.com/" rel="noopener ugc nofollow" target="_blank"> Netlify </a>这样的玩家用这种模型俘获了web开发人员的心，SQLite的可嵌入性使其成为创新的基于边缘的数据部署的有力竞争者。</p><p id="c89b" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated"><strong class="ke jc">黑拳分发共识</strong></p><p id="e575" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">最后一个经常被忽视的转变是Raft的商品化。不久前，分布式一致意见属于黑魔法领域，在那里，一小撮发起者可以设计出聪明的方法，在分布式系统中提供任何种类的保证。现在，几乎任何语言都有Raft库。</p></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><h1 id="8b93" class="nc lf jb bd lg nd ne nf lj ng nh ni lm nj nk nl lp nm nn no ls np nq nr lv ns bi translated"><strong class="ak">凿商店</strong></h1><p id="4f34" class="pw-post-body-paragraph kb kc jb ke b kf lx kh ki kj ly kl km la lz kp kq lb ma kt ku lc mb kx ky kz ij bi translated">看到上面的趋势展开，是什么让我发现<a class="ae ld" href="http://chiselstrike.com" rel="noopener ugc nofollow" target="_blank">凿击</a>。虽然该公司本身仍处于私人测试阶段，知道的也不多，但我们今天公开了这个故事的一个核心组件:<a class="ae ld" href="https://github.com/chiselstrike/chiselstore/" rel="noopener ugc nofollow" target="_blank">chickerstore</a>。</p><figure class="mc md me mf gt is gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/6b4b9ff835d38766ab9b780e51e2549b.png" data-original-src="https://miro.medium.com/v2/resize:fit:978/format:webp/1*8_RXk9XnBV5Z4-i_lySEpw.png"/></div></figure><p id="7f21" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">简而言之，ChiselStore将sqlite数据库包装在Raft库中。我们不是第一个将这两种技术结合起来的人。最值得注意的是，我们知道<a class="ae ld" href="https://github.com/rqlite/rqlite" rel="noopener ugc nofollow" target="_blank"> rqlite </a>和<a class="ae ld" href="https://dqlite.io/" rel="noopener ugc nofollow" target="_blank"> dqlite </a>。</p><p id="2fd8" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">rqlite是使用SQLite +Raft的分布式数据库的一个很好的实现。但是它被设计为用作独立的数据库。我们认为，嵌入式版本可以释放出巨大的能量，可以像SQLite本身一样在边缘计算场景中以零配置方式使用。</p><p id="f089" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">dqlite在概念上非常匹配ChiselStore，但是C实现拒绝了我们。除了作为一个嵌入式分布式数据库，ChiselStore是使用LittleRaft库用Rust编写的。尽管LittleRaft是一个新生的库，但我们非常看好Rust，并根据经验知道它所吹嘘的安全优势并非侥幸。</p><p id="e12b" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">诚然，SQLite本身也是用c语言编写的。但同时，它可能是现存的在手机、浏览器和各种其他设备上运行的最广泛使用的数据库系统，所以在这一点上，我们将不再讨论它。</p><h2 id="4c8f" class="le lf jb bd lg lh li dn lj lk ll dp lm la ln lo lp lb lq lr ls lc lt lu lv lw bi translated">用木筏和铁锈分发SQLite</h2><p id="ae6d" class="pw-post-body-paragraph kb kc jb ke b kf lx kh ki kj ly kl km la lz kp kq lb ma kt ku lc mb kx ky kz ij bi translated">ChiselStore是一个zero-conf数据库库，可以像嵌入SQLite一样嵌入到应用程序中。使用ChiselStore，您的应用程序使用库API执行SQL语句，如CREATE TABLE、INSERT或SELECT。在内部，ChiselStore使用Raft consensus协议将SQL语句复制到集群中的所有节点，集群将这些语句应用到它们的本地SQLite实例。</p><p id="249a" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">Raft保证集群中的所有SQLite实例具有相同的内容，这使得集群即使在一些节点不可用的情况下也能继续运行。使用Raft的结果是，默认情况下，ChiselStore提供了很强的一致性(线性化)。因为SQL语句是在Raft集群leader节点上执行的，所以在ChiselStore集群上执行的SQL语句看起来好像只有一个数据副本。</p><h2 id="49aa" class="le lf jb bd lg lh li dn lj lk ll dp lm la ln lo lp lb lq lr ls lc lt lu lv lw bi translated">轻松阅读</h2><p id="942d" class="pw-post-body-paragraph kb kc jb ke b kf lx kh ki kj ly kl km la lz kp kq lb ma kt ku lc mb kx ky kz ij bi translated">实现强一致性的成本很高。然而，在web应用程序中，读取相对于写入滞后是可以接受的。对于这些场景，ChiselStore提供了一种<em class="kd">宽松读取</em>一致性模式，允许客户端在本地节点上执行读取操作。这种模式非常适合可用性更重要的情况，即使节点与分布式数据库的其余部分断开连接，应用程序也必须提供读取服务。</p><p id="b361" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">正如我们所看到的，使用宽松读取的性能非常接近SQLite本身提供的性能</p><pre class="mc md me mf gt mm mn mo mp aw mq bi"><span id="1c6b" class="le lf jb mn b gy mr ms l mt mu">[OVERALL], ThreadCount, 16<br/>[OVERALL], RunTime(ms), 17856<br/>[OVERALL], Throughput(ops/sec), 560035.8</span></pre><p id="1e5c" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated"><strong class="ke jc">局限性</strong></p><p id="9c21" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">ChiselStore处于初级阶段，目前不适合生产使用。特别是LittleRaft缺乏对Raft快照和联合共识的支持。也就是说，SQL语句的复制日志永远不会被截断，节点也不可能动态地加入和离开集群。</p><p id="24f9" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">这些是LittleRaft图书馆的局限性，我们认为应该尽快解除。</p></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><h1 id="c50c" class="nc lf jb bd lg nd ne nf lj ng nh ni lm nj nk nl lp nm nn no ls np nq nr lv ns bi translated">摘要</h1><p id="c784" class="pw-post-body-paragraph kb kc jb ke b kf lx kh ki kj ly kl km la lz kp kq lb ma kt ku lc mb kx ky kz ij bi translated">随着最近硬件的进步和行业趋势的转变，就数据库而言，我们经常发现自己处于开始旅程的同一个地方:SQL已经足够好了。</p><p id="c9cd" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">虽然Postgres是一种常见且安全的选择，但在某些场景中，比如在边缘，SQLite可能是一个强有力的竞争者。如何在SQLite之上拥有一个全球分布式应用程序的问题由ChiselStore解决。</p><p id="60c6" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">ChiselStore为许多用例提供了一种在无服务器环境中靠近端点复制数据的简单方法。当使用宽松读取时，它具有与SQLite相当的读取性能。</p><p id="9ace" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">我们目前正致力于将ChiselStore与我们的无服务器运行时集成为一个可选的零配置数据库。如果你想了解更多关于我们在<a class="ae ld" href="http://www.chiselstrike.com" rel="noopener ugc nofollow" target="_blank">凿击</a>无服务器&amp;边缘所做的事情，请<a class="ae ld" href="https://calendly.com/glaubercosta/chiselstrike-private-beta" rel="noopener ugc nofollow" target="_blank">联系我们</a>。</p></div></div>    
</body>
</html>