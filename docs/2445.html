<html>
<head>
<title>Understanding Laravel Scopes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解Laravel范围</h1>
<blockquote>原文：<a href="https://itnext.io/understanding-laravel-scopes-a3d1f9030d51?source=collection_archive---------0-----------------------#2019-05-26">https://itnext.io/understanding-laravel-scopes-a3d1f9030d51?source=collection_archive---------0-----------------------#2019-05-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/623fcc1a212fbeb688bcdf80e37dd012.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xgVmWO4cg_nXwC7AZDPBFw.png"/></div></div></figure><div class=""/><p id="9d79" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我第一次真正体验Laravel scopes是在我最近做的一个项目中。我们偶然发现了一个问题，两个模型在数据库中使用同一个表。</p><p id="91c5" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">每个模型代表不同类型的内容页面。这两种模型在很大程度上以相同的方式工作，但也有一些不同之处。两个模型中的一个可能会被用户喜欢，另一个则不会。这些类型的内容在前台显示的方式也完全不同。</p><p id="522f" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们在数据库表中添加了一个<em class="kz">类型</em>字段，以区分不同类型的内容页面。</p><p id="aa78" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当通过口才查询数据库时，我们必须确保每个模型只检索数据库中相应类型的数据。这是Laravel scopes引入项目的地方。</p><h2 id="d7b4" class="la lb je bd lc ld le dn lf lg lh dp li km lj lk ll kq lm ln lo ku lp lq lr ls bi translated">什么是示波器？</h2><p id="e98c" class="pw-post-body-paragraph kb kc je kd b ke lt kg kh ki lu kk kl km lv ko kp kq lw ks kt ku lx kw kx ky im bi translated">作用域是模型中的一种方法，它能够将数据库逻辑添加到模型中。</p><blockquote class="ly"><p id="5c0b" class="lz ma je bd mb mc md me mf mg mh ky dk translated">作用域允许将数据库逻辑封装到一个模型中，从而能够重用查询逻辑</p></blockquote><h2 id="4f57" class="la lb je bd lc ld mi dn lf lg mj dp li km mk lk ll kq ml ln lo ku mm lq lr ls bi translated">全局范围</h2><p id="1760" class="pw-post-body-paragraph kb kc je kd b ke lt kg kh ki lu kk kl km lv ko kp kq lw ks kt ku lx kw kx ky im bi translated">全局范围允许您向模型上的所有查询添加约束。通过这种方式，您可以确保给定模型上的每个查询都有一定的约束。您可以通过运行以下命令来创建全局范围:</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="03df" class="la lb je ms b gy mw mx l my mz">php artisan make:scope MessageScope</span></pre><p id="0f06" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这将在<em class="kz"> app/Scopes </em>文件夹中创建<em class="kz"> MessageScope </em>类。回到我在本文前面描述的例子，这是<em class="kz"> MessageScope </em>的样子。</p><figure class="mn mo mp mq gt iv"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="97b5" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在创建范围之后，我们应该将它添加到我们的模型中。这可以通过覆盖<em class="kz"> boot </em>方法来实现。这导致该模型上的每个查询都得到<em class="kz">，其中type='message' </em>作为约束。</p><figure class="mn mo mp mq gt iv"><div class="bz fp l di"><div class="na nb l"/></div></figure><h2 id="60e5" class="la lb je bd lc ld le dn lf lg lh dp li km lj lk ll kq lm ln lo ku lp lq lr ls bi translated">匿名全局范围</h2><p id="6b7e" class="pw-post-body-paragraph kb kc je kd b ke lt kg kh ki lu kk kl km lv ko kp kq lw ks kt ku lx kw kx ky im bi translated">如果你有简单的作用域，不需要它们自己的类，你可以使用闭包来定义一个匿名的全局作用域。这也在模型的<em class="kz"> boot </em>方法中完成。上一个示例中的<em class="kz"> MessageScope </em>类可以重写为一个匿名全局范围:</p><figure class="mn mo mp mq gt iv"><div class="bz fp l di"><div class="na nb l"/></div></figure><h2 id="e9c6" class="la lb je bd lc ld le dn lf lg lh dp li km lj lk ll kq lm ln lo ku lp lq lr ls bi translated">删除全局范围</h2><p id="f5bf" class="pw-post-body-paragraph kb kc je kd b ke lt kg kh ki lu kk kl km lv ko kp kq lw ks kt ku lx kw kx ky im bi translated">如果您想在没有全局范围的情况下执行某个查询，则可以删除全局范围。</p><p id="2229" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">有两种方法可以移除全局作用域，具体取决于它是否是匿名全局作用域。</p><p id="4fec" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">要删除一个全局作用域，可以调用不带global scope的<em class="kz">方法，将作用域的类名作为参数。</em></p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="1bfd" class="la lb je ms b gy mw mx l my mz">Message::withoutGlobalScope(MessageScope::class)-&gt;get();</span></pre><p id="6fb2" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于匿名全局作用域，您可以调用相同的方法，但是将匿名全局作用域的名称作为第一个参数。</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="46ae" class="la lb je ms b gy mw mx l my mz">Message::withoutGlobalScope('type')-&gt;get();</span></pre><p id="be0c" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用没有全局作用域的<em class="kz">方法也可以移除多个全局作用域。</em></p><h2 id="46d1" class="la lb je bd lc ld le dn lf lg lh dp li km lj lk ll kq lm ln lo ku lp lq lr ls bi translated">本地范围</h2><p id="7c9e" class="pw-post-body-paragraph kb kc je kd b ke lt kg kh ki lu kk kl km lv ko kp kq lw ks kt ku lx kw kx ky im bi translated">局部作用域使得它能够定义容易重用的公共约束集。例如，如果我们只想获取发布的消息，这就很方便了。</p><figure class="mn mo mp mq gt iv"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="ba8b" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在定义了一个或多个局部范围之后，可以通过调用模型上的scope方法来使用它们。范围方法的链接是可能的。</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="6ce2" class="la lb je ms b gy mw mx l my mz">$messages = Message::published()-&gt;orderBy('created_at')-&gt;get();</span></pre><blockquote class="ly"><p id="87db" class="lz ma je bd mb mc nc nd ne nf ng ky dk translated">当调用scope方法时，不需要添加前缀<code class="fe nh ni nj ms b">scope </code></p></blockquote><h2 id="0d13" class="la lb je bd lc ld mi dn lf lg mj dp li km mk lk ll kq ml ln lo ku mm lq lr ls bi translated">动态本地范围</h2><p id="37f9" class="pw-post-body-paragraph kb kc je kd b ke lt kg kh ki lu kk kl km lv ko kp kq lw ks kt ku lx kw kx ky im bi translated">动态局部作用域的工作方式与普通局部作用域完全相同。唯一的区别是动态局部作用域接受参数。</p><figure class="mn mo mp mq gt iv"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="6253" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">调用范围时，可以传递参数:</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="4b77" class="la lb je ms b gy mw mx l my mz">$messages = Message::isHighlighted(true)-&gt;orderBy('created_at')-&gt;get();</span></pre></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><p id="50a3" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在我们已经了解了所有不同类型的示波器，我希望您在Laravel中获得了一些关于示波器的新知识。一定要看看我的其他帖子，我的很多内容都是关于Laravel的。如果您有任何反馈、问题或希望我写另一个与Laravel相关的主题，请随时留下您的评论。</p></div></div>    
</body>
</html>