<html>
<head>
<title>Sending Asynchronous HTTP-Requests in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Swift中发送异步HTTP请求</h1>
<blockquote>原文：<a href="https://itnext.io/sending-asynchronous-http-requests-in-swift-bfc619a1a2a?source=collection_archive---------1-----------------------#2022-05-23">https://itnext.io/sending-asynchronous-http-requests-in-swift-bfc619a1a2a?source=collection_archive---------1-----------------------#2022-05-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7d5c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">任务和等待的实用介绍</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/401e66a3c5104408d7fba4253d4b9e73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*yaL5HFvzoSl2J8LZ"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@jessbaileydesigns?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">杰斯·贝利</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="a7fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这篇文章介绍了如何在Swift中异步执行代码。首先，将提供关于这一主题的总体看法。之后，两个具体的代码示例将展示如何在实际的例子中使用异步代码。</p><p id="b9cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">代码示例是为Xcode Playgrounds创建的，可以直接复制、粘贴和运行。</p><p id="6e19" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这两个请求都将在reqbin.com上运行，这是一个在线REST和SOAP API测试工具。</p><p id="2de7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第一个例子中，将使用HTTP GET请求，这也可以在他们的网站上在线试用。</p><p id="edf8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，作为第二个例子，HTTP POST请求<a class="ae ky" href="https://reqbin.com/req/4rwevrqh/post-json-example" rel="noopener ugc nofollow" target="_blank">将与JSON </a>有效负载一起使用。</p><p id="b49f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这篇文章还将介绍如何将数据编码和解码成JSON。</p><h2 id="f394" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">异步代码执行</h2><p id="3575" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">在我们进入如何发送HTTP请求的细节之前，让我们看一下异步代码执行。</p><p id="7a10" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Swift <a class="ae ky" href="https://docs.swift.org/swift-book/LanguageGuide/Concurrency.html" rel="noopener ugc nofollow" target="_blank">文档</a>对“异步代码”做了如下描述:</p><blockquote class="mt mu mv"><p id="df37" class="kz la mw lb b lc ld ju le lf lg jx lh mx lj lk ll my ln lo lp mz lr ls lt lu im bi translated">异步代码可以被挂起，稍后再恢复，尽管一次只能执行一部分程序。暂停和恢复程序中的代码可以让它继续在短期操作上取得进展，如更新其UI，同时继续处理长期运行的操作，如通过网络获取数据或解析文件。</p></blockquote><p id="cd5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要使一个长期运行的函数异步，我们需要用<code class="fe na nb nc nd b">async</code>-关键字来标记它。</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="084f" class="lv lw it nd b gy ni nj l nk nl">func myLongRunningFunction() async {<br/>    ...<br/>  // do something that takes lots of time<br/>  ...<br/>}</span></pre><p id="de72" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，为了调用这个函数，我们需要使用<code class="fe na nb nc nd b">await</code> -关键字。</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="6c68" class="lv lw it nd b gy ni nj l nk nl">await myLongRunningFunction()</span></pre><p id="47c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们举一个<code class="fe na nb nc nd b">Task.sleep()</code>的具体例子。在下面的代码中，我们希望等待5秒钟。</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="d676" class="lv lw it nd b gy ni nj l nk nl">print("Before")<br/>try Task.sleep(nanoseconds: 5 * 1_000_000_000)<br/>print("Done")<br/>print("After")</span></pre><p id="0b36" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此代码无法编译。我们得到错误消息:“在不支持并发的函数中进行了‘async’调用”。</p><p id="6e5d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为我们的Xcode操场的主线程是同步的，所以我们需要提前调用<code class="fe na nb nc nd b">async</code>。</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="369a" class="lv lw it nd b gy ni nj l nk nl">print("Before")<br/>async {<br/>    try await Task.sleep(nanoseconds: 5 * 1_000_000_000)<br/>    print("Done")<br/>}<br/>print("After")</span></pre><p id="f2a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然这段代码运行得很好，但它不再编译只是时间问题。</p><p id="69a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">原因是，<code class="fe na nb nc nd b">async</code>已被弃用，将被<code class="fe na nb nc nd b">Task.init</code>取代。</p><p id="39f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们迅速改变这一点。</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="95e0" class="lv lw it nd b gy ni nj l nk nl">print("Before")<br/>Task {<br/>    try await Task.sleep(nanoseconds: 5 * 1_000_000_000)<br/>    print("Done")<br/>}<br/>print("After")</span></pre><p id="3bd1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行该命令将产生以下输出。</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="d1d9" class="lv lw it nd b gy ni nj l nk nl">Before<br/>After<br/>Done</span></pre><p id="d38f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">而“之前”和“之后”将立即打印出来。打印“完成”需要5秒钟。</p><p id="aba7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们已经了解了异步代码执行的基本情况，让我们看看如何使用它来发送HTTP请求。</p><h2 id="e5f0" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">发送HTTP GET请求</h2><p id="9c73" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">下面是发送HTTP GET请求的示例代码。</p><p id="24bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基本上我们需要做三个步骤:</p><ul class=""><li id="5fa3" class="nm nn it lb b lc ld lf lg li no lm np lq nq lu nr ns nt nu bi translated">使用URL创建请求</li><li id="6ade" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">发送请求</li><li id="ff48" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">评估响应</li></ul><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="2cd3" class="lv lw it nd b gy ni nj l nk nl">import PlaygroundSupport<br/>import UIKit<br/><br/>struct SuccessInfo: Decodable {<br/>    let success: String<br/>}<br/><br/>guard let url = URL(string: "https://reqbin.com/echo/get/json") else { fatalError("Missing URL") }<br/><br/>var urlRequest = URLRequest(url: url)<br/>urlRequest.addValue("application/json", forHTTPHeaderField: "Content-Type")<br/><br/>Task {<br/>    let (data, response) = try await URLSession.shared.data(for: urlRequest)<br/>    guard (response as? HTTPURLResponse)?.statusCode == 200 else { fatalError("Error while fetching data") }<br/><br/>    let successInfo = try JSONDecoder().decode(SuccessInfo.self, from: data)<br/><br/>    print(String(data: data, encoding: .utf8) ?? "default value")<br/>    print("Success: \(successInfo.success)")<br/>}<br/><br/>print("I am here already!")<br/><br/>PlaygroundPage.current.needsIndefiniteExecution = true</span></pre><p id="1569" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">重要的类别有:</p><ul class=""><li id="ad93" class="nm nn it lb b lc ld lf lg li no lm np lq nq lu nr ns nt nu bi translated"><a class="ae ky" href="https://developer.apple.com/documentation/foundation/url" rel="noopener ugc nofollow" target="_blank">网址</a></li></ul><blockquote class="mt mu mv"><p id="13c8" class="kz la mw lb b lc ld ju le lf lg jx lh mx lj lk ll my ln lo lp mz lr ls lt lu im bi translated">标识资源位置的值，如远程服务器上的项目或本地文件的路径</p></blockquote><p id="bfd7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://developer.apple.com/documentation/foundation/urlrequest/" rel="noopener ugc nofollow" target="_blank"> URLRequest </a></p><blockquote class="mt mu mv"><p id="75e0" class="kz la mw lb b lc ld ju le lf lg jx lh mx lj lk ll my ln lo lp mz lr ls lt lu im bi translated">"独立于协议或URL方案的URL加载请求."</p></blockquote><ul class=""><li id="3aa8" class="nm nn it lb b lc ld lf lg li no lm np lq nq lu nr ns nt nu bi translated"><a class="ae ky" href="https://developer.apple.com/documentation/foundation/urlsession/" rel="noopener ugc nofollow" target="_blank"> URLSession </a></li></ul><blockquote class="mt mu mv"><p id="eeec" class="kz la mw lb b lc ld ju le lf lg jx lh mx lj lk ll my ln lo lp mz lr ls lt lu im bi translated">"协调一组相关网络数据传输任务的对象."</p></blockquote><ul class=""><li id="276d" class="nm nn it lb b lc ld lf lg li no lm np lq nq lu nr ns nt nu bi translated"><a class="ae ky" href="https://developer.apple.com/documentation/foundation/httpurlresponse/" rel="noopener ugc nofollow" target="_blank"> HTTPURLResponse </a></li></ul><blockquote class="mt mu mv"><p id="89f3" class="kz la mw lb b lc ld ju le lf lg jx lh mx lj lk ll my ln lo lp mz lr ls lt lu im bi translated">"与HTTP协议URL加载请求的响应相关联的元数据."</p></blockquote><h2 id="d98b" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">发送HTTP POST请求</h2><p id="6f09" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">本节展示了带有JSON有效负载的HTTP POST请求。同样，我们需要执行与第一个示例相同的三个步骤。</p><p id="5681" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个例子中最大的不同是，我们向服务器发送一些数据。</p><p id="6c3b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的数据被编码在<code class="fe na nb nc nd b">MyJsonObject</code>中。你可以使用任何你想要的有效负载，后端会忽略它。</p><p id="084b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">大多数REST服务用相同的资源类型响应，因此我们可以使用<code class="fe na nb nc nd b">MyJsonObject</code>作为唯一的类型，并让它从<code class="fe na nb nc nd b">Codable</code>继承。</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="0c70" class="lv lw it nd b gy ni nj l nk nl">import PlaygroundSupport<br/>import UIKit<br/><br/>struct MyJsonObject: Encodable {<br/>    let id: Int<br/>    let foo: String<br/>    let bar: String<br/>}<br/><br/>struct SuccessInfo: Decodable {<br/>    let success: String<br/>}<br/><br/>let myJsonObject = MyJsonObject(id: 1, foo: "Hello", bar: "World")<br/>let payload = try JSONEncoder().encode(myJsonObject)<br/><br/>guard let url = URL(string: "https://reqbin.com/echo/post/json") else { fatalError("Missing URL") }<br/><br/>var urlRequest = URLRequest(url: url)<br/>urlRequest.addValue("application/json", forHTTPHeaderField: "Content-Type")<br/>urlRequest.httpMethod = "POST"<br/><br/>Task {<br/>    let (data, response) = try await URLSession.shared.upload(for: urlRequest, from: payload)<br/>    <br/>    guard (response as? HTTPURLResponse)?.statusCode == 200 else { fatalError("Error while fetching data") }<br/>    <br/>    let successInfo = try JSONDecoder().decode(SuccessInfo.self, from: data)<br/>    <br/>    print(String(data: data, encoding: .utf8) ?? "default value")<br/>    print("Success: \(successInfo.success)")<br/>}<br/><br/>print("I am here already!")<br/><br/>PlaygroundPage.current.needsIndefiniteExecution = true</span></pre><p id="b16b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看看，找出可编码、可解码和可编码之间的区别。</p><ul class=""><li id="0121" class="nm nn it lb b lc ld lf lg li no lm np lq nq lu nr ns nt nu bi translated"><a class="ae ky" href="https://developer.apple.com/documentation/foundation/jsondecoder/" rel="noopener ugc nofollow" target="_blank"> JSONDecoder </a></li></ul><blockquote class="mt mu mv"><p id="d69c" class="kz la mw lb b lc ld ju le lf lg jx lh mx lj lk ll my ln lo lp mz lr ls lt lu im bi translated">"一个从JSON对象中解码数据类型实例的对象."</p></blockquote><ul class=""><li id="ef83" class="nm nn it lb b lc ld lf lg li no lm np lq nq lu nr ns nt nu bi translated"><a class="ae ky" href="https://developer.apple.com/documentation/swift/encodable/" rel="noopener ugc nofollow" target="_blank">可编码</a></li></ul><blockquote class="mt mu mv"><p id="eb0c" class="kz la mw lb b lc ld ju le lf lg jx lh mx lj lk ll my ln lo lp mz lr ls lt lu im bi translated">"一种可以将自身编码成外部表示的类型."</p></blockquote><ul class=""><li id="1eab" class="nm nn it lb b lc ld lf lg li no lm np lq nq lu nr ns nt nu bi translated"><a class="ae ky" href="https://developer.apple.com/documentation/swift/decodable/" rel="noopener ugc nofollow" target="_blank">可解码</a></li></ul><blockquote class="mt mu mv"><p id="aee8" class="kz la mw lb b lc ld ju le lf lg jx lh mx lj lk ll my ln lo lp mz lr ls lt lu im bi translated">"一种能从外部表示中自我解码的类型."</p></blockquote><ul class=""><li id="9b2e" class="nm nn it lb b lc ld lf lg li no lm np lq nq lu nr ns nt nu bi translated"><a class="ae ky" href="https://developer.apple.com/documentation/swift/codable/" rel="noopener ugc nofollow" target="_blank"> Codable </a></li></ul><blockquote class="mt mu mv"><p id="1b60" class="kz la mw lb b lc ld ju le lf lg jx lh mx lj lk ll my ln lo lp mz lr ls lt lu im bi translated">"一种可以将自身转换成外部表示或从外部表示转换出来的类型."</p></blockquote><h2 id="cfb7" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">运行代码</h2><p id="0f79" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">当执行示例中的代码时，您可能会看到“我已经在这里了！”在HTTP-response正文之前打印。</p><h2 id="52df" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">结论</h2><p id="3197" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">在对如何使用<code class="fe na nb nc nd b">async</code>和<code class="fe na nb nc nd b">await</code>在Swift中编写异步代码进行了一般性介绍之后，提供了两个关于如何通过HTTP GET和POST请求异步发送和接收数据的实例。</p><p id="5fc5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请随意将代码复制并粘贴到您自己的Xcode-Playground中，并进行试验。</p><p id="425b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您的阅读！</p><ul class=""><li id="81b2" class="nm nn it lb b lc ld lf lg li no lm np lq nq lu nr ns nt nu bi translated">如果你喜欢这个，请<a class="ae ky" href="https://twissmueller.medium.com/" rel="noopener">在媒体</a>上跟随我</li><li id="ac43" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">给我买杯咖啡让我继续前进</li><li id="40ed" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">通过<a class="ae ky" href="https://twissmueller.medium.com/membership" rel="noopener">在这里注册</a>来支持我和其他媒体作者</li></ul><div class="oa ob gp gr oc od"><a href="https://twissmueller.medium.com/membership" rel="noopener follow" target="_blank"><div class="oe ab fo"><div class="of ab og cl cj oh"><h2 class="bd iu gy z fp oi fr fs oj fu fw is bi translated">通过我的推荐链接加入媒体</h2><div class="ok l"><h3 class="bd b gy z fp oi fr fs oj fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="ol l"><p class="bd b dl z fp oi fr fs oj fu fw dk translated">twissmueller.medium.com</p></div></div><div class="om l"><div class="on l oo op oq om or ks od"/></div></div></a></div><h2 id="9955" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">资源</h2><ul class=""><li id="d740" class="nm nn it lb b lc mo lf mp li os lm ot lq ou lu nr ns nt nu bi translated"><a class="ae ky" href="https://developer.apple.com/news/?id=2o3euotz" rel="noopener ugc nofollow" target="_blank">满足Swift并发</a></li><li id="b639" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated"><a class="ae ky" href="https://docs.swift.org/swift-book/LanguageGuide/Concurrency.html" rel="noopener ugc nofollow" target="_blank">并发</a></li><li id="44fb" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated"><a class="ae ky" href="https://developer.apple.com/videos/play/wwdc2021/10132/" rel="noopener ugc nofollow" target="_blank">在Swift中异步会面/等待</a></li><li id="d641" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated"><a class="ae ky" href="https://developer.apple.com/videos/play/wwdc2021/10095/" rel="noopener ugc nofollow" target="_blank">对URLSession使用async/await</a></li></ul></div></div>    
</body>
</html>