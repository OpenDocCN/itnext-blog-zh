<html>
<head>
<title>Authentication with JWT in Dart</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Dart中的JWT认证</h1>
<blockquote>原文：<a href="https://itnext.io/authentication-with-jwt-in-dart-6fbc70130806?source=collection_archive---------1-----------------------#2019-08-30">https://itnext.io/authentication-with-jwt-in-dart-6fbc70130806?source=collection_archive---------1-----------------------#2019-08-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e2f3" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何在Dart中实现JSON Web令牌认证</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/fcdd5cfa00ebc779054302a7e4426dcd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hIcsRvRL64pSyIeRppKtoQ.png"/></div></div></figure><h2 id="63c8" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">介绍</h2><p id="5be6" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi mj translated"><span class="l mk ml mm bm mn mo mp mq mr di"> W </span>随着安全问题<a class="ae ms" href="https://www.securitymagazine.com/articles/90376-concerns-about-physical-security-and-cybersecurity-are-increasing" rel="noopener ugc nofollow" target="_blank">稳步上升</a>，组织正在寻找更好、更快的方法来实施强大、可靠的安全措施，以保护关键基础设施和重要客户数据。</p><p id="368f" class="pw-post-body-paragraph lq lr it ls b lt mt ju lv lw mu jx ly ld mv ma mb lh mw md me ll mx mg mh mi im bi translated">在本文中，我们将了解如何使用<a class="ae ms" href="https://jwt.io" rel="noopener ugc nofollow" target="_blank"> JSON Web令牌</a>在<a class="ae ms" href="https://dart.dev" rel="noopener ugc nofollow" target="_blank"> Dart </a>中启动并运行基本身份验证，这是一种越来越流行且易于使用的方法，用于保护网络上两台机器之间的身份验证。</p><p id="1619" class="pw-post-body-paragraph lq lr it ls b lt mt ju lv lw mu jx ly ld mv ma mb lh mw md me ll mx mg mh mi im bi translated">Dart是一种富有表现力的高效语言，适合处理任何标准的客户端或服务器任务，这使得它成为基于现代概念(如<a class="ae ms" href="https://www.google.com/search?client=safari&amp;rls=en&amp;q=solid+design+principles&amp;ie=UTF-8&amp;oe=UTF-8" rel="noopener ugc nofollow" target="_blank">固体设计原则</a>和<a class="ae ms" href="https://12factor.net" rel="noopener ugc nofollow" target="_blank">十二因素应用程序方法学</a>)构建端到端客户端-服务器解决方案的绝佳选择。</p><p id="c6a5" class="pw-post-body-paragraph lq lr it ls b lt mt ju lv lw mu jx ly ld mv ma mb lh mw md me ll mx mg mh mi im bi translated">示例项目的源代码可以在GitHub 上的<a class="ae ms" href="https://github.com/kenreilly/dart-jwt-example" rel="noopener ugc nofollow" target="_blank">处获得。如果你还没有Dart环境，你可以</a><a class="ae ms" href="https://dart.dev/get-dart" rel="noopener ugc nofollow" target="_blank">在这里</a>获得。</p></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><h2 id="15db" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">项目设置</h2><p id="6586" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">这个项目是用命令<code class="fe nf ng nh ni b">$ stagehand package-shelf</code>创建的，它为<a class="ae ms" href="https://github.com/dart-lang/shelf" rel="noopener ugc nofollow" target="_blank"> shelf web服务器</a>初始化一个样板项目。</p><p id="9fb1" class="pw-post-body-paragraph lq lr it ls b lt mt ju lv lw mu jx ly ld mv ma mb lh mw md me ll mx mg mh mi im bi translated">首先，让我们检查一下<strong class="ls iu"> pubspec.yaml </strong>中的项目定义:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="525b" class="pw-post-body-paragraph lq lr it ls b lt mt ju lv lw mu jx ly ld mv ma mb lh mw md me ll mx mg mh mi im bi translated">在这个文件中有名称、描述、环境和依赖关系的标准定义。添加<a class="ae ms" href="https://pub.dev/packages/jaguar_jwt" rel="noopener ugc nofollow" target="_blank"> jaguar_jwt </a>包是为了处理创建和验证令牌的内部jwt任务。还添加了<a class="ae ms" href="https://pub.dev/packages/dotenv" rel="noopener ugc nofollow" target="_blank"> dotenv </a>包，以符合12因素原则的<a class="ae ms" href="https://12factor.net/config" rel="noopener ugc nofollow" target="_blank">因素III(配置)</a>，并允许使用本地环境变量进行原型制作和测试。</p><p id="35ef" class="pw-post-body-paragraph lq lr it ls b lt mt ju lv lw mu jx ly ld mv ma mb lh mw md me ll mx mg mh mi im bi translated">为这个项目创建了一个默认的配置文件<strong class="ls iu"> .env.example </strong>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="ca59" class="pw-post-body-paragraph lq lr it ls b lt mt ju lv lw mu jx ly ld mv ma mb lh mw md me ll mx mg mh mi im bi translated"><code class="fe nf ng nh ni b">PORT</code>变量表示服务器将在端口3000上运行，而<code class="fe nf ng nh ni b">JWT_AUTH_SECRET</code>是一个特定于应用程序的秘密，用于生成令牌，并验证它们以确保它们来自我们的网络。</p></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><h2 id="383d" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated"><strong class="ak">申请入口点</strong></h2><p id="d29c" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">我们要看的下一个文件是<strong class="ls iu"> bin/server.dart </strong>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="e547" class="pw-post-body-paragraph lq lr it ls b lt mt ju lv lw mu jx ly ld mv ma mb lh mw md me ll mx mg mh mi im bi translated"><strong class="ls iu"> Server </strong>类处理示例API服务器的初始化，包括环境变量加载、命令行参数解析和服务器管道/中间件设置。定义为参数的<em class="nl">调试</em>模式在本例中未实现，仅用于说明。</p><p id="4645" class="pw-post-body-paragraph lq lr it ls b lt mt ju lv lw mu jx ly ld mv ma mb lh mw md me ll mx mg mh mi im bi translated"><em class="nl"> _echo </em>方法是一个通用的HTTP请求处理程序，它总是返回OK，这使得它成为一个很好的测试点，确保我们是否获得OK完全取决于底层中间件。</p><p id="d100" class="pw-post-body-paragraph lq lr it ls b lt mt ju lv lw mu jx ly ld mv ma mb lh mw md me ll mx mg mh mi im bi translated">使用名副其实的<em class="nl"> createMiddleware、</em>创建<em class="nl"> auth </em>中间件，然后在请求记录之后和<em class="nl"> _echo </em>处理程序之前将其放入管道中。</p><p id="87f9" class="pw-post-body-paragraph lq lr it ls b lt mt ju lv lw mu jx ly ld mv ma mb lh mw md me ll mx mg mh mi im bi translated">一旦服务器启动，管道将接收请求，通过auth中间件处理它们，然后或者在那里停止(如果响应是由auth处理程序发送的),或者继续到_echo处理程序(如果auth处理程序验证了请求并在管道中进一步发送它)。</p></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><h2 id="9e58" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">配置</h2><p id="5506" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">接下来是第一个实用程序类，在<strong class="ls iu"> lib/config.dart </strong>中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="cc8e" class="pw-post-body-paragraph lq lr it ls b lt mt ju lv lw mu jx ly ld mv ma mb lh mw md me ll mx mg mh mi im bi translated"><strong class="ls iu"> Config </strong>类在内部使用dotenv包，从文件中加载一个环境图，然后将属性<em class="nl"> port </em>和<em class="nl"> secret </em>暴露给程序的其余部分。这种方法使得升级dotenv包变得容易，甚至可以用另一个工作解决方案完全替换它，而对系统的其余部分没有影响。它还允许设置故障保护逻辑，以便在变量丢失或值不正确时进行捕捉。</p></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><h2 id="8d64" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">生成哈希</h2><p id="a39a" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">第二个实用程序类用于生成散列，位于<strong class="ls iu"> lib/hash.dart </strong>中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="aa94" class="pw-post-body-paragraph lq lr it ls b lt mt ju lv lw mu jx ly ld mv ma mb lh mw md me ll mx mg mh mi im bi translated">这个简单的散列类有一个目的:生成用来代替明文密码的散列。虽然这只是一个示例应用程序，但通常最好是不惜一切代价避免使用明文密码，<em class="nl">即使只是原型制作</em>。花五分钟时间使用哈希。</p></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><h2 id="175d" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">身份验证提供者</h2><p id="fa87" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">我们要看的下一个文件是<strong class="ls iu"> lib/auth-provider.dart </strong>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="bade" class="pw-post-body-paragraph lq lr it ls b lt mt ju lv lw mu jx ly ld mv ma mb lh mw md me ll mx mg mh mi im bi translated"><strong class="ls iu"> AuthProvider </strong>类处理这个API的实际认证。创建一个<a class="ae ms" href="https://api.dartlang.org/stable/2.4.1/dart-convert/JsonDecoder-class.html" rel="noopener ugc nofollow" target="_blank"> JsonDecoder </a>的实例来处理来自JSON的登录请求体的反序列化。<em class="nl"> _check </em>方法是一个实用程序，如果用户数据映射对象与从硬编码到类中的<em class="nl">用户列表</em>中传递的对象相匹配，则该实用程序返回true。在一个真实的应用程序中，这个用户列表将被存储在某个数据库中和/或由一个服务管理，但是为了测试的目的，快速模拟一个100%工作的东西是很方便的。</p><p id="54e7" class="pw-post-body-paragraph lq lr it ls b lt mt ju lv lw mu jx ly ld mv ma mb lh mw md me ll mx mg mh mi im bi translated">在请求处理期间，<em class="nl"> handle </em>方法由中间件处理程序调用，如果请求可以在内部处理(例如处理登录或拒绝API调用的坏令牌),它将返回<strong class="ls iu">响应</strong>,或者如果不需要任何操作，它将返回<code class="fe nf ng nh ni b">null</code>,允许请求继续到管道中的下一个中间件或处理程序(在我们的例子中，回显请求)。</p><p id="470a" class="pw-post-body-paragraph lq lr it ls b lt mt ju lv lw mu jx ly ld mv ma mb lh mw md me ll mx mg mh mi im bi translated">为了实现这一点，处理程序检查请求url字符串，如果url是<code class="fe nf ng nh ni b">'login'</code>，将调用<em class="nl"> auth </em>方法，否则调用<em class="nl"> verify </em>方法。</p><p id="29e2" class="pw-post-body-paragraph lq lr it ls b lt mt ju lv lw mu jx ly ld mv ma mb lh mw md me ll mx mg mh mi im bi translated"><em class="nl"> auth </em>方法首先反序列化请求JSON并从中提取所需的属性，将<em class="nl">用户名</em>和<em class="nl">密码</em>的散列变体存储在<em class="nl"> creds </em>中，然后在硬编码的用户列表中搜索一个实体，当使用<em class="nl"> _check </em>方法进行测试时，该实体返回一个匹配。如果存在一个令牌，则使用用户名以及颁发者和受众声明创建一个令牌。有关JWT声明和实施的更多信息，<a class="ae ms" href="https://jwt.io/introduction/" rel="noopener ugc nofollow" target="_blank">参见本页</a>。</p><p id="1502" class="pw-post-body-paragraph lq lr it ls b lt mt ju lv lw mu jx ly ld mv ma mb lh mw md me ll mx mg mh mi im bi translated"><em class="nl">验证</em>方法反向工作，从<code class="fe nf ng nh ni b">Authorization</code>头中检索一个JWT(在删除<code class="fe nf ng nh ni b">'Bearer: '</code>组件之后)，或者验证请求并允许它继续发送，或者如果令牌本身无效或者它的声明与硬编码到这个应用程序中的不匹配，则直接拒绝它(<code class="fe nf ng nh ni b">‘Acme Widgets Corp’</code>和<code class="fe nf ng nh ni b">‘example.com’</code>)。</p></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><h2 id="b249" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">测试</h2><p id="22fb" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">为了测试API，从项目目录中用<code class="fe nf ng nh ni b">$ dart bin/server.dart</code>启动服务器。应该会返回消息<code class="fe nf ng nh ni b">Serving at <a class="ae ms" href="http://localhost:3000" rel="noopener ugc nofollow" target="_blank">http://localhost:3000</a></code>,表明已经准备好测试了。首先，让我们检查一下我们未经身份验证的请求是否被拒绝:</p><pre class="kj kk kl km gt nm ni nn no aw np bi"><span id="ac06" class="ku kv it ni b gy nq nr l ns nt">$ curl localhost:3000/hello</span></pre><p id="3026" class="pw-post-body-paragraph lq lr it ls b lt mt ju lv lw mu jx ly ld mv ma mb lh mw md me ll mx mg mh mi im bi translated">这应该会返回响应<code class="fe nf ng nh ni b">Authorization rejected</code>。接下来，使用硬编码列表中的用户名/密码测试登录:</p><pre class="kj kk kl km gt nm ni nn no aw np bi"><span id="df2a" class="ku kv it ni b gy nq nr l ns nt">$ curl localhost:3000/login -d \ '{"username":"test","password":"insecure"}'</span></pre><p id="9db1" class="pw-post-body-paragraph lq lr it ls b lt mt ju lv lw mu jx ly ld mv ma mb lh mw md me ll mx mg mh mi im bi translated">如果一切顺利，这将返回一个JSON web令牌(截图如下)。复制该字符串并将其粘贴到下面的<code class="fe nf ng nh ni b">MY_JWT</code>处:</p><pre class="kj kk kl km gt nm ni nn no aw np bi"><span id="2eee" class="ku kv it ni b gy nq nr l ns nt">$ curl localhost:3000/hello -H "Authorization: Bearer MY_JWT"</span></pre><p id="d066" class="pw-post-body-paragraph lq lr it ls b lt mt ju lv lw mu jx ly ld mv ma mb lh mw md me ll mx mg mh mi im bi translated">这将返回<code class="fe nf ng nh ni b">Authorization OK for “hello”</code>,表明我们之前被拒绝的请求现在被批准了，这意味着API正在按预期工作，请求正在被正确处理。</p></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><h2 id="23cc" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">结论</h2><p id="343f" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">本文展示了使Dart成为服务器端开发的最佳选择的一些特性，例如简洁而富于表现力的语法和维护良好且易于使用的包系统。这个示例项目(<a class="ae ms" href="https://github.com/kenreilly/dart-jwt-example" rel="noopener ugc nofollow" target="_blank">在这里可用</a>)为构建更复杂的API解决方案以支持任何类型的桌面、移动和web客户端提供了一个很好的起点。</p><p id="2623" class="pw-post-body-paragraph lq lr it ls b lt mt ju lv lw mu jx ly ld mv ma mb lh mw md me ll mx mg mh mi im bi translated">感谢您的阅读，祝您的下一个DevOps项目好运！</p></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/9d9cc3a18d955d14a61e02ec4a2881ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*qWX8gAvOX-c-9_XBtwt1Fw.gif"/></div></div><figcaption class="nv nw gj gh gi nx ny bd b be z dk translated">JWT身份验证测试会话的屏幕截图</figcaption></figure></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><blockquote class="nz"><p id="04e1" class="oa ob it bd oc od oe of og oh oi mi dk translated">肯尼斯·雷利(<a class="ae ms" href="https://twitter.com/8_bit_hacker" rel="noopener ugc nofollow" target="_blank"> 8_bit_hacker </a>)是<a class="ae ms" href="https://lvl-up.tech/" rel="noopener ugc nofollow" target="_blank"> LevelUP </a>的CTO</p></blockquote></div></div>    
</body>
</html>