<html>
<head>
<title>From Junior to Genius: an optimization story</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从少年到天才:一个优化的故事</h1>
<blockquote>原文：<a href="https://itnext.io/from-junior-to-genius-an-optimization-story-ab20afc8159d?source=collection_archive---------0-----------------------#2022-10-01">https://itnext.io/from-junior-to-genius-an-optimization-story-ab20afc8159d?source=collection_archive---------0-----------------------#2022-10-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="615e" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">重构校验和，直到它运行快100倍</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/140e2cb9d5078c4cd5e81afd88ba4b44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cAE0L18Qwv3D0a3dksd7Iw.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">准备接受挑战</figcaption></figure><p id="92bb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最近，我遇到了一个散列方法，它位于多年来被不同开发人员重构过几次的热门代码路径中——这是一段有趣的Git历史。每个人都带来了自己的一套工具和知识，应用不同的技术和选择不同的折衷方案。</p><p id="9166" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">观察一个方法随时间的演变是认识到性能范围有多广的好方法，即使对于简单的例程也是如此。在处理高级语言时尤其如此——源代码和编译代码之间有许多移动部分，减少执行时间的机会无处不在，有时很明显，有时不太明显。</p><h1 id="bd3e" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">挑战</h1><p id="b1a5" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">我们准备拿一个简单的<em class="mo">校验和</em>的方法，交给六个不同的开发者，分别命名为<strong class="kx ir">初级</strong>、<strong class="kx ir">专业</strong>、<strong class="kx ir">高级</strong>、<strong class="kx ir">黑客</strong>、<strong class="kx ir">专家</strong>和<strong class="kx ir">天才</strong>。他们会用尽他们的能力去优化它，我们希望能从他们每个人身上学到一些东西。</p><p id="fae1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">以下是限制条件:</p><ul class=""><li id="de2c" class="mp mq iq kx b ky kz lb lc le mr li ms lm mt lq mu mv mw mx bi translated"><strong class="kx ir"> C# / dotnet 6。拥有一个JIT编译器让它变得更有趣。</strong></li><li id="48a5" class="mp mq iq kx b ky my lb mz le na li nb lm nc lq mu mv mw mx bi translated"><strong class="kx ir">单线程。</strong>我们不打算探索并行化。</li><li id="b2e5" class="mp mq iq kx b ky my lb mz le na li nb lm nc lq mu mv mw mx bi translated"><strong class="kx ir"> x86。</strong> ARM、WASM等目标将被排除在外。</li></ul><p id="06ae" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">事不宜迟，下面是我所说的<strong class="kx ir">少年</strong>校验和:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="1e57" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">该方法非常简单，累加4列和，并使用来自每个累加器<em class="mo">的LSB将其缩减为一个<code class="fe nf ng nh ni b"><em class="mo">uint</em></code>。给定需求，这就是我期望一个受过教育的初级开发人员所交付的东西。</em></p><blockquote class="nj nk nl"><p id="f1c5" class="kv kw mo kx b ky kz jr la lb lc ju ld nm lf lg lh nn lj lk ll no ln lo lp lq ij bi translated">我知道你在想什么:Junior刚刚从StackOverflow复制了这个。如果你是大三，我告诉你:没关系。每个人都在某种程度上这样做——只是要确保你明白你在复制什么。</p></blockquote><h1 id="c10c" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">职业选手来了</h1><p id="49d4" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">所以现在我们的小校验和被交给了专业人士。Pro已经混了一点，学了几招，但还是称不上资深。</p><p id="b305" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Pro做的第一件事就是基准测试Junior的代码来建立一个基线。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="a133" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">基准测试使用1MB的缓冲区，其中充满了随机数据。</p><p id="78ae" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">结果如下:</p><pre class="kg kh ki kj gt np ni nq nr aw ns bi"><span id="08ba" class="nt ls iq ni b gy nu nv l nw nx">|   Method |  Length |     Mean |<br/>|--------- |-------- |---------:|<br/>|   Junior | 1000000 | 1.799 ms |</span></pre><p id="45d8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这些数字是好是坏？1Mb的数据需要1.8毫秒，这似乎很快，但任务很明确:让它更快。在挠头了一会儿之后，Pro决定展开循环。</p><p id="689c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">循环展开是一种以代码大小换取性能的技术。这个想法是在每次循环迭代中做更多的工作。所以与其说:</p><pre class="kg kh ki kj gt np ni nq nr aw ns bi"><span id="461c" class="nt ls iq ni b gy nu nv l nw nx">for (x = 0; x &lt; 100; x++)<br/>{<br/>     work(x);<br/>}</span></pre><p id="7c69" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">有人会写:</p><pre class="kg kh ki kj gt np ni nq nr aw ns bi"><span id="b2a8" class="nt ls iq ni b gy nu nv l nw nx">for (x = 0; x &lt; 100; x+=5)<br/>{<br/>    work(x);<br/>    work(x+1);<br/>    work(x+2);<br/>    work(x+3);<br/>    work(x+4);<br/>}</span></pre><p id="5efd" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">背后的主要推理是，在每一次迭代中，都会有一次比较(<em class="mo"> x &lt; 100 </em>)，一次加法(<em class="mo"> x++ </em>)，一次跳转。通过重复这些语句，编译后的代码导致更少的操作，因为现在跳转和比较在每5个<em class="mo"> work() </em>调用中只发生一次。</p><blockquote class="nj nk nl"><p id="e0f4" class="kv kw mo kx b ky kz jr la lb lc ju ld nm lf lg lh nn lj lk ll no ln lo lp lq ij bi translated">大多数编译器都将循环展开作为优化工具之一。通常，如果循环具有固定的低迭代次数，您会注意到展开发生在生成的程序集上。</p></blockquote><p id="fe31" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Pro版本的校验和:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="b2b0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">虽然有可能，但这个版本每次迭代使用16个字节。之后，它执行几个4字节的循环，最后添加最后3、2或1个剩余字节。这些代码要多得多，但是值得吗？</p><pre class="kg kh ki kj gt np ni nq nr aw ns bi"><span id="b7b7" class="nt ls iq ni b gy nu nv l nw nx">|   Method |  Length |       Mean |     Median | Ratio |<br/>|--------- |-------- |-----------:|-----------:|------:|<br/>|   Junior | 1000000 | 1,855.5 us | 1,825.4 us |  1.00 |<br/>|      Pro | 1000000 |   373.8 us |   373.8 us |  0.20 |</span></pre><p id="252e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">对比基准尖叫是的。比Junior快5倍。</p><h1 id="ab85" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">在路上的几年有什么不同吗？</h1><p id="d425" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">我们现在把任务交给<strong class="kx ir">高层，</strong>同样的简单命令:让它更快。</p><p id="902e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Senior已经存在了相当长一段时间，实际上已经存在了很长时间，以至于当他们刚开始编程时，C#是一个笑话。学长用C写了很多代码，懂指针，懂汇编代码。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="eca9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">请注意，有些Gists只显示解决方案中最相关的循环。在本文的结尾，有一个Github库的链接，你可以使用它。</p><p id="18d1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">更新的性能指标评测，比专业版提高了1.6倍，比初级版提高了7.8倍:</p><pre class="kg kh ki kj gt np ni nq nr aw ns bi"><span id="0d79" class="nt ls iq ni b gy nu nv l nw nx">|   Method |  Length |       Mean | Ratio |<br/>|--------- |-------- |-----------:|------:|<br/>|    Junior| 1000000 | 1,803.0 us |  1.00 |<br/>|      Pro | 1000000 |   365.2 us |  0.20 |<br/>|   Senior | 1000000 |   231.6 us |  0.13 |</span></pre><p id="f0c6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">代码看起来很像Pro的，所以让我们分解一下变化，了解一下是怎么回事。</p><h2 id="94b8" class="nt ls iq bd lt ny nz dn lx oa ob dp mb le oc od md li oe of mf lm og oh mh oi bi translated">1.将该方法标记为不安全</h2><pre class="kg kh ki kj gt np ni nq nr aw ns bi"><span id="6b6d" class="nt ls iq ni b gy nu nv l nw nx">public static uint ChecksumPro(ReadOnlySpan&lt;byte&gt; arr)<br/>public unsafe static uint ChecksumSenior(ReadOnlySpan&lt;byte&gt; arr)</span></pre><p id="4d45" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">第一个编辑是将<code class="fe nf ng nh ni b"><em class="mo">unsafe</em></code> <em class="mo"> </em>关键字添加到签名中。例如，这允许我们在方法中使用指针。在C#世界中，这是开发人员做出的声明，翻译成“我知道我在做什么，编译器，冷静点。”</p><h2 id="51e7" class="nt ls iq bd lt ny nz dn lx oa ob dp mb le oc od md li oe of mf lm og oh mh oi bi translated">2.实际上获得一个指针</h2><pre class="kg kh ki kj gt np ni nq nr aw ns bi"><span id="8104" class="nt ls iq ni b gy nu nv l nw nx">fixed (byte* ptr = arr)</span></pre><p id="53ee" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在C#中使用指针最常见的方式是在固定的<strong class="kx ir">范围内。用C#文档自己的话说:</strong></p><blockquote class="nj nk nl"><p id="531a" class="kv kw mo kx b ky kz jr la lb lc ju ld nm lf lg lh nn lj lk ll no ln lo lp lq ij bi translated">fixed语句防止<a class="ae oj" href="https://learn.microsoft.com/en-us/dotnet/standard/garbage-collection/" rel="noopener ugc nofollow" target="_blank">垃圾收集器</a>重新定位一个可移动变量，并声明一个指向该变量的指针。</p></blockquote><p id="b1af" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">基本上，它确保我们得到的指针保持有效，CLR不会移动底层数据。这种担心只发生在这里，因为我们是在托管内存环境中操作的。CLR在我们认为的变量和实际内存地址之间增加了一个抽象层。(公平地说，操作系统还增加了一个抽象层，为进程提供虚拟内存，但这不在我们讨论的范围之内)。每个抽象都不可避免地引入了开销。这是开发人员为垃圾收集器的便利所付出的代价。在C#中使用指针是为了暂时绕过这种抽象。</p><p id="4758" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">从这里开始，代码看起来几乎完全相同，但它不是索引数组，而是索引指针:</p><pre class="kg kh ki kj gt np ni nq nr aw ns bi"><span id="ecb6" class="nt ls iq ni b gy nu nv l nw nx">arr[z + 0] //indexed array <br/>ptr[z + 0] //indexed pointer</span></pre><h2 id="b115" class="nt ls iq bd lt ny nz dn lx oa ob dp mb le oc od md li oe of mf lm og oh mh oi bi translated">3.密切关注ASM</h2><p id="b477" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">到最后，C#代码会被翻译成机器代码来执行。当您达到这种详细程度时，从执行路径中删除的每个指令都将被计算在内。以这两种方法为例:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="7bc8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">使用无符号整数的版本少了一条指令。因为在第一种方法中我们使用的是<code class="fe nf ng nh ni b">int</code> <em class="mo">，</em>编译器在每次内存访问(<code class="fe nf ng nh ni b"><strong class="kx ir">movzx</strong></code>)前加了一个<code class="fe nf ng nh ni b"><a class="ae oj" href="https://www.felixcloutier.com/x86/movsx:movsxd" rel="noopener ugc nofollow" target="_blank"><strong class="kx ir">movsxd</strong></a></code> <a class="ae oj" href="https://www.felixcloutier.com/x86/movsx:movsxd" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir"> </strong> </a>。</p><p id="3ad5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir"> movsxd </strong>是<strong class="kx ir"> </strong> <em class="mo">随符号扩展移动</em></p><p id="f047" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">基本上，它是从一个有符号的整数转换成一个无符号的整数来索引指针。您可能认为多一条指令没有坏处，但是如果恰好在一个紧循环中，6条指令对7条指令可以转化为15%的性能差异。</p><blockquote class="nj nk nl"><p id="6b8d" class="kv kw mo kx b ky kz jr la lb lc ju ld nm lf lg lh nn lj lk ll no ln lo lp lq ij bi translated">我知道有些人接下来会说什么:你需要考虑指令互易吞吐量、等待时间和流水线，才能真正实现上面的陈述。没错，我为了证明一个观点而过于简单化了。</p></blockquote><p id="ff6a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">同样值得一提的是，在我们的例子中，虽然显示的是X86 ASM代码，但实际发生的是编译器输出IL代码，然后根据平台由JIT编译器编译成机器码。例如，这里的语句可能对ARM指令集无效。</p><p id="6d4c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">除此之外，不能保证JIT总是输出相同的ASM指令。JIT是一项工程壮举，充满了启发性和不断的进化。我们今天编写的代码明天可能会编译成不同的指令集，因为JIT已经更新了新的性能技巧。这是使用即时编译器在框架上工作的好处——我们的代码可能运行得更快，而不需要我们实际发布更新。不利的一面是，它会降低性能的可预测性。</p><p id="7d38" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">好吧，但是在专业版和高级版之间真正改变的是什么？让我们来看两者的反编译ASM的一部分:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="1339" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">即使不知道每条ASM指令具体在做什么，也很容易注意到一种模式:</p><pre class="kg kh ki kj gt np ni nq nr aw ns bi"><span id="e9af" class="nt ls iq ni b gy nu nv l nw nx">lea      ebx, [r11+0CH]<br/>cmp      ebx, ecx<br/>jae      G_M000_IG17<br/>mov      ebx, ebx<br/>movzx    rbx, byte  ptr [rdx+rbx]<br/>add      eax, ebx</span></pre><p id="d24c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">对比:</p><pre class="kg kh ki kj gt np ni nq nr aw ns bi"><span id="2605" class="nt ls iq ni b gy nu nv l nw nx">lea      ebx, [r11+08H]<br/>movzx    rbx, byte  ptr [rdx+rbx]<br/>add      eax, ebx</span></pre><p id="d9ab" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们分解第一行:</p><pre class="kg kh ki kj gt np ni nq nr aw ns bi"><span id="63de" class="nt ls iq ni b gy nu nv l nw nx">lea      ebx, [r11+0CH] //loads data into ebx</span><span id="e838" class="nt ls iq ni b gy ok nv l nw nx">cmp      ebx, ecx       //compares ebx to ecx</span><span id="5fc6" class="nt ls iq ni b gy ok nv l nw nx">jae      G_M000_IG17    //jump to G_M000_IG17 if result from compare<br/>                        //is above or equal 0</span><span id="1116" class="nt ls iq ni b gy ok nv l nw nx">mov      ebx, ebx       //moves data from address in ebx into ebx<br/>                        //this is a pointer dereferencing (*ptr)</span></pre><p id="85a9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这个跳跃在这里做什么？</p><p id="6fbe" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果检查标签G_M000_IG17处的内容，我们会发现:</p><pre class="kg kh ki kj gt np ni nq nr aw ns bi"><span id="8690" class="nt ls iq ni b gy nu nv l nw nx">G_M000_IG17:                ;; offset=0445H<br/>        E8E675C15F           <strong class="ni ir">call</strong>     CORINFO_HELP_RNGCHKFAIL<br/>        CC                   <strong class="ni ir">int3</strong></span></pre><p id="1e1b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">好吧——看来是范围检查失败了。现在清楚了:如果代码试图访问数组的越界位置，额外的指令负责抛出异常。这就是为什么上面的代码片段抛出一个异常，而不是在<code class="fe nf ng nh ni b">arr[2]</code>读取未定义的数据:</p><pre class="kg kh ki kj gt np ni nq nr aw ns bi"><span id="56a0" class="nt ls iq ni b gy nu nv l nw nx">var arr = new byte[1] { 0 };<br/>var invalid = arr[2];       // IndexOutOfRangeException thrown</span></pre><p id="4d75" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果不检查边界，访问无效地址，会发生什么情况？各种讨厌的东西，SEGFAUTS和类似的。不漂亮。这是C#在你的自行车上安装辅助轮。</p><p id="c320" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">高级代码通过使用<strong class="kx ir">不安全的</strong>关键字和指针，避免了在紧密循环中的这些绑定检查。因此，大多数读/写模式最终使用3条指令，而不是6条。</p><blockquote class="nj nk nl"><p id="733e" class="kv kw mo kx b ky kz jr la lb lc ju ld nm lf lg lh nn lj lk ll no ln lo lp lq ij bi translated">如果JIT编译器能够证明索引永远不会超出数组的界限，它就能够移除界限检查。Pro犯了一个错误，如果修复，将导致JIT编译器删除绑定检查，并在不使用指针的情况下使其性能更接近高级。我鼓励你去发现它。</p></blockquote><p id="86ff" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">有些人会说，最重要的方面实际上是消除所有这些跳转，因为跳转意味着分支，而分支意味着CPU必须进行推测性执行，并试图预测分支将采用哪条路径。我明白了，但是在这个练习中，为了简单起见，让我们把更少的指令看作是更少的工作。</p><h1 id="cc6c" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">谁需要黑客？</h1><p id="ade7" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">学长的解决方案很棒。超越这一点需要打破常规的思维。我们把它交给<strong class="kx ir">黑客。任务还是一样:让它更快。</strong></p><p id="3999" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们得到这个:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><pre class="kg kh ki kj gt np ni nq nr aw ns bi"><span id="e2d9" class="nt ls iq ni b gy nu nv l nw nx">|   Method |  Length |       Mean | Ratio |<br/>|--------- |-------- |-----------:|------:|<br/>| Baseline | 1000000 | 1,761.0 us |  1.00 |<br/>|      Pro | 1000000 |   363.6 us |  0.21 |<br/>|   Senior | 1000000 |   224.6 us |  0.13 |<br/>|   Hacker | 1000000 |   120.0 us |  0.07 |</span></pre><p id="c62d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">比高年级学生提高了2倍，但在外行人看来可能是垃圾。然而，你们中的一些读者可能已经发现了窍门。你有吗？留下评论告诉我:)</p><p id="d70b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在我们的挑战中，黑客的定义是:</p><blockquote class="ol"><p id="bc67" class="om on iq bd oo op oq or os ot ou lq dk translated">一个为了达到某个特定目标，会脱离最初目的去寻找和使用工具的人。</p></blockquote><p id="43c9" class="pw-post-body-paragraph kv kw iq kx b ky ov jr la lb ow ju ld le ox lg lh li oy lk ll lm oz lo lp lq ij bi translated">通常，当您从真正对性能敏感的项目中读取源代码时，例如Linux内核，您会遇到看起来像用ASCII字符编写的巫术咒语的部分。一个很好的练习是去理解这些细节，并分解所使用的技术，这样它们就成为你可以用来为你自己将来可能面临的问题构建聪明的解决方案的基石。</p><p id="62e2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这里的技巧是将一个<code class="fe nf ng nh ni b">long</code> <strong class="kx ir"> </strong>重新用作一个<strong class="kx ir"/><code class="fe nf ng nh ni b"><strong class="kx ir">short</strong></code><strong class="kx ir">4-wide vector。</strong>让我们来分解相关部分:</p><pre class="kg kh ki kj gt np ni nq nr aw ns bi"><span id="f0a0" class="nt ls iq ni b gy nu nv l nw nx">ulong l1 = *(ulong*)(ptr + z);<br/>//1. a=(ptr + z) adds offset z to pointer ptr ( ptr is byte* )<br/>//2. b=(ulong*)(a) casts that pointer to a ulong*<br/>//3. *(b) dereferences the pointer and reads the long value</span></pre><p id="0ae7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">所以第一个小技巧是将8个字节读入一个<code class="fe nf ng nh ni b">ulong</code> <em class="mo">。</em>假设我们在x64机器上，这是一次内存读取。然后再重复3次:</p><pre class="kg kh ki kj gt np ni nq nr aw ns bi"><span id="b9da" class="nt ls iq ni b gy nu nv l nw nx">ulong l1 = *(ulong*)(ptr + z);<br/>ulong l2 = *(ulong*)(ptr + z + 8);<br/>ulong l3 = *(ulong*)(ptr + z + 16);<br/>ulong l4 = *(ulong*)(ptr + z + 24);</span></pre><p id="498a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">此时，我们有效地读取了4个<code class="fe nf ng nh ni b">ulong</code>，即32个字节的数据，代价是4条指令，而逐字节读取需要32条指令。</p><pre class="kg kh ki kj gt np ni nq nr aw ns bi"><span id="edb8" class="nt ls iq ni b gy nu nv l nw nx"><strong class="ni ir">l1 </strong>&amp; <strong class="ni ir">0x00FF00FF00FF00FF</strong>;</span></pre><p id="9094" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下一个技巧是对第一个<code class="fe nf ng nh ni b">long</code>应用蒙版。如果我们在小端系统上标注l1处的字节，它看起来像:</p><pre class="kg kh ki kj gt np ni nq nr aw ns bi"><span id="1d32" class="nt ls iq ni b gy nu nv l nw nx"><strong class="ni ir">B7_B6_B5_B4_B3_B2_B1_B0</strong></span></pre><p id="c083" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">应用我们得到的面具</p><pre class="kg kh ki kj gt np ni nq nr aw ns bi"><span id="b642" class="nt ls iq ni b gy nu nv l nw nx">  <strong class="ni ir">B7_B6_B5_B4_B3_B2_B1_B0</strong> &amp; <strong class="ni ir">0x00_FF_00_FF_00_FF00_FF</strong><br/>= <strong class="ni ir">00_B6_00_B4_00_B2_00_B0</strong></span></pre><p id="f4c9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，如果我们一次看两个被屏蔽的长字节，会发生什么呢？</p><pre class="kg kh ki kj gt np ni nq nr aw ns bi"><span id="d0cc" class="nt ls iq ni b gy nu nv l nw nx"><strong class="ni ir">0x00_B6</strong> <strong class="ni ir">0x00_B4 x00_B2 0x00_B0</strong></span></pre><p id="b475" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">它的B0，B2，B4和B4从一个单字节字扩展到一个2宽度的字。我们将每个字节转换成一个短整型。</p><pre class="kg kh ki kj gt np ni nq nr aw ns bi"><span id="7aa3" class="nt ls iq ni b gy nu nv l nw nx">(<strong class="ni ir">l1 </strong>&amp; <strong class="ni ir">0xFF_00_FF_00_FF_00_FF_00</strong>) &gt;&gt; <strong class="ni ir">8</strong></span></pre><p id="54ec" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">对于奇数字节也是如此，移动一个字节使它们处于正确的位置。对我们读过的所有4本<code class="fe nf ng nh ni b">ulong</code>书都这样做，我们现在有了:</p><pre class="kg kh ki kj gt np ni nq nr aw ns bi"><span id="a0b3" class="nt ls iq ni b gy nu nv l nw nx">M1= 00_<strong class="ni ir">B6</strong>__00_<strong class="ni ir">B4</strong>__00_<strong class="ni ir">B2</strong>__00_<strong class="ni ir">B0</strong><br/>M2= 00_<strong class="ni ir">B7</strong>__00_<strong class="ni ir">B5</strong>__00_<strong class="ni ir">B3</strong>__00_<strong class="ni ir">B1</strong><br/>M3= 00_<strong class="ni ir">B14</strong>_00_<strong class="ni ir">B12</strong>_00_<strong class="ni ir">B10</strong>_00_<strong class="ni ir">B8</strong><br/>M4= 00_<strong class="ni ir">B15</strong>_00_<strong class="ni ir">B13</strong>_00_<strong class="ni ir">B11</strong>_00_<strong class="ni ir">B9</strong><br/>M5= 00_<strong class="ni ir">B22</strong>_00_<strong class="ni ir">B20</strong>_00_<strong class="ni ir">B18</strong>_00_<strong class="ni ir">B16</strong><br/>M6= 00_<strong class="ni ir">B23</strong>_00_<strong class="ni ir">B21</strong>_00_<strong class="ni ir">B19</strong>_00_<strong class="ni ir">B17</strong><br/>M7= 00_<strong class="ni ir">B30</strong>_00_<strong class="ni ir">B28</strong>_00_<strong class="ni ir">B26</strong>_00_<strong class="ni ir">B24</strong><br/>M8= 00_<strong class="ni ir">B31</strong>_00_<strong class="ni ir">B29</strong>_00_<strong class="ni ir">B27</strong>_00_<strong class="ni ir">B25</strong></span></pre><p id="25ad" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果我们将M1与M3、M5和M7相加会发生什么？假设个人</p><pre class="kg kh ki kj gt np ni nq nr aw ns bi"><span id="aa91" class="nt ls iq ni b gy nu nv l nw nx">  00_<strong class="ni ir">B6</strong>__00_<strong class="ni ir">B4</strong>__00_<strong class="ni ir">B2</strong>__00_<strong class="ni ir">B0<br/>+ </strong>00_<strong class="ni ir">B14</strong>_00_<strong class="ni ir">B12</strong>_00_<strong class="ni ir">B10</strong>_00_<strong class="ni ir">B8<br/>+ </strong>00_<strong class="ni ir">B22</strong>_00_<strong class="ni ir">B20</strong>_00_<strong class="ni ir">B18</strong>_00_<strong class="ni ir">B16<br/>+ </strong>00_<strong class="ni ir">B30</strong>_00_<strong class="ni ir">B28</strong>_00_<strong class="ni ir">B26</strong>_00_<strong class="ni ir">B24</strong></span><span id="3752" class="nt ls iq ni b gy ok nv l nw nx"><strong class="ni ir">= [B6+B14+B22+B30]_[B4+B12+B20+B28]_[B2+B10+B18+B26]_[B0+B8+B16+B24]</strong></span></pre><p id="04d5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们姑且称之为对S1、S2、S3和S4的短期看法:</p><pre class="kg kh ki kj gt np ni nq nr aw ns bi"><span id="9550" class="nt ls iq ni b gy nu nv l nw nx">S1= <strong class="ni ir">[B6+B14+B22+B30] = </strong>(<strong class="ni ir">M1+M5</strong>)&amp; 0x<strong class="ni ir">FF_FF</strong>_00_00_00_00_00_00 &gt;&gt; 48<br/>S2= <strong class="ni ir">[B4+B12+B20+B28] = </strong>(<strong class="ni ir">M1+M5</strong>)&amp; 0x00_00_<strong class="ni ir">FF_FF</strong>_00_00_00_00 &gt;&gt; 32<br/>S3= <strong class="ni ir">[B2+B10+B18+B26] = </strong>(<strong class="ni ir">M1+M5</strong>)&amp; 0x00_00_00_00_<strong class="ni ir">FF_FF</strong>_00_00 &gt;&gt; 16<br/>S4= <strong class="ni ir">[B0+B8+B16+B24]  = </strong>(<strong class="ni ir">M1+M5</strong>)&amp; 0x00_00_00_00_00_00_<strong class="ni ir">FF_FF</strong></span></pre><p id="5262" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">回想以前的版本，累加器是:</p><pre class="kg kh ki kj gt np ni nq nr aw ns bi"><span id="99ea" class="nt ls iq ni b gy nu nv l nw nx">sum0 += (B0 + B4 + B8 + B12 + B16 + B20 + B24 + B28)<br/>sum1 += (B1 + B5 + B9 + B13 + B17 + B21 + B25 + B29)<br/>sum2 += (B2 + B6 + B10 + B14 + B18 + B22 + B26 + B30)<br/>sum3 += (B4 + B7 + B11 + B15 + B19 + B23 + B27 + B31)</span></pre><p id="338a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">很明显，我们可以使用这些位操作实现相同的累加。</p><pre class="kg kh ki kj gt np ni nq nr aw ns bi"><span id="0b6c" class="nt ls iq ni b gy nu nv l nw nx">sum0 = (S2 + S4)<br/>sum2 = (S1 + S3)<br/>...</span></pre><p id="bb9a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是，如果我们在将空头合并为sum0、sum1等之前，继续对这些多头求和，结果会怎样呢？？</p><pre class="kg kh ki kj gt np ni nq nr aw ns bi"><span id="4bdf" class="nt ls iq ni b gy nu nv l nw nx">while(...)<br/>{<br/>    tmp1 += M1+M3+M5+M7<br/>    ...<br/>}</span></pre><p id="479a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们现在正在破解一个<code class="fe nf ng nh ni b">ulong</code>，将它重新用作一个4-wide <code class="fe nf ng nh ni b">short</code>向量。但是有一个问题:我们不能让任何单个元素的总和超过无符号short <code class="fe nf ng nh ni b">0xFFFF</code>的最大值。</p><p id="4d46" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们在每次迭代中为每个short添加4个字节，所以在到达<code class="fe nf ng nh ni b">0xFF</code>之前，我们可以安全地这样做64次。</p><pre class="kg kh ki kj gt np ni nq nr aw ns bi"><span id="d4d4" class="nt ls iq ni b gy nu nv l nw nx">0xFF * 4 *64 = 0xFF00</span></pre><p id="d31a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">过了那个点，任何一个短路都可能溢出，我们被黑的向量就会被破坏。因此，一旦我们做了64次迭代，我们提取每个向量的值，并将其添加到原始总和，重置向量。这正是该部门正在做的事情:</p><pre class="kg kh ki kj gt np ni nq nr aw ns bi"><span id="d651" class="nt ls iq ni b gy nu nv l nw nx">if (limit2 != 64)<br/>   sum0= ...<br/>   sum1= ...<br/>   sum2= ...<br/>   sum3= ...<br/>}</span></pre><p id="522d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">以下是ASM代码在这个紧密循环中的表现:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="2ed6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是一个扩展和带注释的版本，带有可能更容易理解的中间变量:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><h1 id="22cc" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">专家为什么叫专家？</h1><p id="ecff" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">我用来描述专家的一个主要特征是从根本上分析问题的能力。你看，我们所有的开发伙伴都完成了任务，把他们所有的知识都倾倒在他们的前辈身上。他们中没有人质疑这一推理——他们只是利用手中的工具对其进行了改进。</p><p id="a99a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们的专家回顾了该方法的第一个版本:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><pre class="kg kh ki kj gt np ni nq nr aw ns bi"><span id="a195" class="nt ls iq ni b gy nu nv l nw nx">//Compute a 32-bit big-endian checksum on arr</span></pre><p id="2ab2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这里的线索是，这是一个大端校验和。这可以通过理解代码本身来解决，但是这个注释行一直都在那里，说明了这个方法的基本点。</p><p id="bbfd" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">概括地说，<a class="ae oj" href="https://en.wikipedia.org/wiki/Endianness" rel="noopener ugc nofollow" target="_blank">字节序</a>指的是字节在一个字中出现的顺序。对于数字，它是指第一个字节是MSB或LSB。</p><div class="kg kh ki kj gt ab cb"><figure class="pa kk pb pc pd pe pf paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><img src="../Images/482955bf8f5d815d9cc35b65e2d6c35f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*MueIrW18ZfqZAUP4gWEK2Q.png"/></div></figure><figure class="pa kk pb pc pd pe pf paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><img src="../Images/4d2e276c3f93cfd2abc355194e36dc42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*vQptVzZp-igc1KfuKCfvOg.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk pg di ph pi translated">来自维基百科</figcaption></figure></div><p id="a855" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">今天的大多数系统都是小端序的，但是如果我们真的在大端序系统中会发生什么呢？该方法的核心循环可能很简单:</p><pre class="kg kh ki kj gt np ni nq nr aw ns bi"><span id="8d21" class="nt ls iq ni b gy nu nv l nw nx">while (z &lt; limit){<br/>  sum += *(uint*)(ptr + z);<br/>  z += 4;<br/>}</span></pre><p id="2984" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这正好是输入数组的32位总和。但是因为我们是小端的，所以当读取4个字节时，它们的顺序与简单求和应该工作的顺序相反。所有需要做的就是读取一个<code class="fe nf ng nh ni b">int</code>，反转它们的字节，然后求和。</p><p id="be7c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最后，这是专家的观点:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><pre class="kg kh ki kj gt np ni nq nr aw ns bi"><span id="d406" class="nt ls iq ni b gy nu nv l nw nx">|         Method |  Length |        Mean | Ratio |<br/>|--------------- |-------- |------------:|------:|<br/>|         Junior | 1000000 | 1,785.46 us |  1.00 |<br/>|            Pro | 1000000 |   362.37 us |  0.20 |<br/>|         Senior | 1000000 |   224.11 us |  0.13 |<br/>|         Hacker | 1000000 |   120.26 us |  0.07 |<br/>|         Expert | 1000000 |    79.83 us |  0.04 |</span></pre><p id="a31b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">几乎是黑客<strong class="kx ir">、</strong>的两倍，代码可读。<br/>这是解决所有其他解决方案的根本问题的一句话:</p><pre class="kg kh ki kj gt np ni nq nr aw ns bi"><span id="18be" class="nt ls iq ni b gy nu nv l nw nx">sum += BinaryPrimitives.ReverseEndianness(*(uint*)(ptr + z));</span></pre><p id="d46b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">它会反转读取的4个字节的字节顺序。这转化为单个ASM指令</p><pre class="kg kh ki kj gt np ni nq nr aw ns bi"><span id="3b46" class="nt ls iq ni b gy nu nv l nw nx">movbe    r11d, dword ptr [rdx+r10+08H]</span></pre><p id="2d2d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下面是<code class="fe nf ng nh ni b"><a class="ae oj" href="https://www.felixcloutier.com/x86/movbe" rel="noopener ugc nofollow" target="_blank"><strong class="kx ir">MOVBE</strong></a></code>的定义:<strong class="kx ir"> </strong>交换字节后移动数据。它一次读取和交换字节。用于此目的的另一个指令是<code class="fe nf ng nh ni b"><a class="ae oj" href="https://www.felixcloutier.com/x86/bswap" rel="noopener ugc nofollow" target="_blank"><strong class="kx ir">BSWAP</strong></a></code> <strong class="kx ir">，</strong>，其在寄存器中就地操作。所以现在<strong class="kx ir">专家</strong>向我们展示了我们可以在不增加额外指令的情况下跨字节序操作。</p><h1 id="b07a" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">SIMD的专家2.0</h1><p id="c62e" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">SIMD代表<a class="ae oj" href="https://en.wikipedia.org/wiki/Single_instruction,_multiple_data" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir">单指令多数据</strong> </a> <strong class="kx ir">，</strong>我知道你们很多读者都期待看到SIMD的解决方案。关键是SIMD指令允许我们一次操作更多的字节。我们的校验和似乎是这种矢量化的完美候选。</p><p id="16bc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是英特尔处理器上SIMD扩展可用性的大致时间表。我们将重点关注AVX和AVX2，它们分别为128和256位宽。瞄准AVX和AVX2意味着瞄准任何从2011年开始生产的CPU。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pj"><img src="../Images/743e63a839adbe30b85c905f62db23f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ItKUweEOTRl4zphhZ-NssA.png"/></div></div></figure><p id="1aff" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Dotnet在dotnet core 3中引入了硬件内部函数。你可以在这里阅读更多的内容。网络核心-。网博(microsoft.com)。目前它支持高达AVX2。AVX512 最终也将上市。</p><p id="19e6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们先来看看AVX的解决方案:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="be00" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这里的明星函数是<strong class="kx ir"> Avx。洗牌，</strong>即编译为<a class="ae oj" href="https://www.felixcloutier.com/x86/pshufb.html" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir"> vpshufb </strong> </a>。这条指令允许我们通过提供一个屏蔽参数来重新排序和屏蔽字节。我们精心制作了一个掩码，它将交换每个4字节块的字节顺序。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pk"><img src="../Images/b406ff69d0606887c9c7b2de37794282.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FsbfHGpm7EvrP5d3y9GZZQ.png"/></div></div></figure><p id="1649" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后，它将向量重新解释为向量<code class="fe nf ng nh ni b">unsigned int</code>，并将其添加到累加器向量中。在ASM中，这看起来像:</p><pre class="kg kh ki kj gt np ni nq nr aw ns bi"><span id="e259" class="nt ls iq ni b gy nu nv l nw nx"><strong class="ni ir">vmovdqu</strong>  xmm2, xmmword ptr [rdx+r9]<br/><strong class="ni ir">vpshufb</strong>  xmm2, xmm2, xmmword ptr [reloc @RWD00]<br/><strong class="ni ir">vpaddd</strong>   xmm1, xmm1, xmm2</span><span id="c4f6" class="nt ls iq ni b gy ok nv l nw nx">RWD00      dq    0405060700010203h, 0C0D0E0F08090A0Bh</span></pre><p id="6f50" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在只使用3条指令，我们就能处理16个字节。它有多快？</p><pre class="kg kh ki kj gt np ni nq nr aw ns bi"><span id="4d3c" class="nt ls iq ni b gy nu nv l nw nx">|    Method |  Length |        Mean | Ratio |<br/>|---------- |-------- |------------:|------:|<br/>|    Junior | 1000000 | 1,774.14 us |  1.00 |<br/>|       Pro | 1000000 |   359.41 us |  0.20 |<br/>|    Senior | 1000000 |   223.97 us |  0.13 |<br/>|    Hacker | 1000000 |   117.98 us |  0.07 |<br/>|    Expert | 1000000 |    78.27 us |  0.04 |<br/>| ExpertAvx | 1000000 |    30.62 us |  0.02 |</span></pre><p id="1f51" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">还不错！又一个2倍的提升。我们现在，多亏了<strong class="kx ir">专家</strong>，<strong class="kx ir"> </strong>比<strong class="kx ir">少年快大约57倍。</strong></p><p id="32eb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下一步是从128宽度的向量转移到256宽度的向量。实现非常相似，但是我们需要注意一些问题。例如，对于大多数操作，Vector256实际上被认为是128宽的两个通道。这超出了这里的范围—让我们看看我们最终是否能比我们希望的更快地达到<strong class="kx ir"> 100x </strong>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><pre class="kg kh ki kj gt np ni nq nr aw ns bi"><span id="bb69" class="nt ls iq ni b gy nu nv l nw nx">|    Method  |  Length |        Mean | Ratio |<br/>|----------- |-------- |------------:|------:|<br/>|     Junior | 1000000 | 1,774.14 us |  1.00 |<br/>|        Pro | 1000000 |   359.41 us |  0.20 |<br/>|     Senior | 1000000 |   223.97 us |  0.13 |<br/>|     Hacker | 1000000 |   117.98 us |  0.07 |<br/>|     Expert | 1000000 |    78.27 us |  0.04 |<br/>|  ExpertAvx | 1000000 |    30.62 us |  0.02 |<br/>| ExpertAvx2 | 1000000 |    20.83 us |  0.02 |</span></pre><p id="be05" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">比初级快85倍左右。快到了！</p><h1 id="f57c" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">有时会有一堵墙挡住去路</h1><p id="54a5" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">需要注意的是，我们的处理速度从<strong class="kx ir"> 563MB/s </strong>提高到了<strong class="kx ir">48GB/s。</strong>在这些速度下，瓶颈变成了内存访问，而不是CPU。</p><p id="de8b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们停下来想一想。我使用的系统有DDR4内存，根据<a class="ae oj" href="https://en.wikipedia.org/wiki/DDR4_SDRAM" rel="noopener ugc nofollow" target="_blank">维基百科</a>的说法，这应该不会超过25GBs。那么，我们的基准测试如何能够以48GB/s的速度运行呢？</p><p id="13fe" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们观察这些速率的唯一原因是因为我们的测试数据完全适合CPU的L3缓存，在我这里使用的英特尔i7 10875H的情况下，它有16MB。L3缓存更靠近CPU内核，峰值可达200GB/s，但这将因CPU而异。如果我们的数据适合L2甚至L1，我们会看到更高的数字。</p><p id="b849" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">使用100MB阵列运行相同的基准测试会使我们面临RAM瓶颈，事实上:</p><pre class="kg kh ki kj gt np ni nq nr aw ns bi"><span id="9533" class="nt ls iq ni b gy nu nv l nw nx">|     Method |    Length |       Mean | Ratio |     Bandwidth |<br/>|----------- |---------- |-----------:|------:|--------------:|<br/>|     Junior | 100000000 | 180.620 ms |  1.00 |   555.55 MB/s |<br/>| ExpertAvx2 | 100000000 |  5.7772 ms |  0.03 | 17320.00 MB/s |</span></pre><p id="027e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在17GB/s的速度下，它实际上非常符合我拥有的特定内存模块的规格。如果我们从存储中读取文件，我们将受到磁盘速度的限制，而不是RAM、L3缓存，当然也不是CPU。</p><p id="ed1d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">也就是说，作为一名软件工程师，重要的是要理解性能数字来源于系统中的各种因素，代码很重要，但它只是组件之一。了解目标系统的底层组件可以帮助您计划如何更有效地安排和移动内存。</p><h2 id="00b5" class="nt ls iq bd lt ny nz dn lx oa ob dp mb le oc od md li oe of mf lm og oh mh oi bi translated">多核并行化怎么样？</h2><p id="8c2c" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">我最初声明这是我们不会探究的事情。原因现在应该很明显了。除了RAM瓶颈之外，L3缓存在典型的CPU中的所有内核之间共享，所以这是毫无意义的。</p><h1 id="d44c" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">天才能让我们走得更远吗？</h1><p id="22fd" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">考虑到限制因素——我知道还有从本文提出的解决方案中获取更多信息的余地。</p><p id="bd1e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这里有一个回购，您可以用自己的版本复制并提交一个拉取请求:</p><blockquote class="nj nk nl"><p id="0af6" class="kv kw mo kx b ky kz jr la lb lc ju ld nm lf lg lh nn lj lk ll no ln lo lp lq ij bi translated"><a class="ae oj" href="https://github.com/israellot/checksum-challenge" rel="noopener ugc nofollow" target="_blank"><strong class="kx ir">【github.com/israellot/checksum-challenge】</strong></a></p></blockquote><p id="a898" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我会用最好的更新这篇文章。我很好奇你会想出什么。</p></div></div>    
</body>
</html>