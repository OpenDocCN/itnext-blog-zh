<html>
<head>
<title>Micro In Action, Part 7: Circuit Breaker &amp; Rate Limiter</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">微操作，第7部分:断路器和限速器</h1>
<blockquote>原文：<a href="https://itnext.io/micro-in-action-7-circuit-breaker-rate-limiter-431ccff6a120?source=collection_archive---------3-----------------------#2020-02-25">https://itnext.io/micro-in-action-7-circuit-breaker-rate-limiter-431ccff6a120?source=collection_archive---------3-----------------------#2020-02-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/aaa42e605e2c79044446005132d2a3f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cb5CQnDyMZfYkT_VA2EFOA.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">微在行动</figcaption></figure><p id="165f" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这是“微在行动”系列文章的第7篇，讨论微<a class="ae ld" href="https://micro.mu/" rel="noopener ugc nofollow" target="_blank"/>。我们将从基本概念和主题开始，然后转向高级功能。</p><p id="ae0f" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">今天的话题是断路器和限速器。</p><p id="9ad3" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">断路器和速率限制器是大型系统架构中的重要主题。当我们开始将单片系统分割成分布式微服务时，这些主题变得更加重要。如果没有断路器和速率限制器，系统很容易因单个组件的故障而遭遇“雪崩”效应，从而导致整个系统的崩溃。</p><p id="39d7" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在Micro的可插拔架构下，可以非常容易地引入上述机制。我们知道Micro支持用中间件包装请求。这些中间件中最重要的两个是:</p><ol class=""><li id="c6ff" class="le lf it kh b ki kj km kn kq lg ku lh ky li lc lj lk ll lm bi translated"><strong class="kh iu">微。WrapClient，</strong>，用于包装出站请求，也称为客户端包装</li><li id="73f2" class="le lf it kh b ki ln km lo kq lp ku lq ky lr lc lj lk ll lm bi translated"><strong class="kh iu">微。WrapHandler，</strong>，用于包装入站请求，也称为服务器端包装</li></ol><p id="f7d3" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这两类中间件分别适用于断路器和限速器的场景。下面我们举例说明如何使用这些中间件来提高系统的健壮性。</p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="ff2e" class="lz ma it bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">断路器</h1><p id="a44d" class="pw-post-body-paragraph kf kg it kh b ki mx kk kl km my ko kp kq mz ks kt ku na kw kx ky nb la lb lc im bi translated">一般来说，这样一个常见的功能并不需要我们自己开发。社区里已经有优秀的开源库，比如<a class="ae ld" href="https://github.com/afex/hystrix-go/" rel="noopener ugc nofollow" target="_blank"> hystrix-go </a>、<a class="ae ld" href="https://github.com/sony/gobreaker" rel="noopener ugc nofollow" target="_blank"> gobreaker </a>。</p><p id="cb85" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">此外，Micro还提供了适配上述库的插件如<a class="ae ld" href="https://github.com/micro/go-plugins/tree/master/wrapper/breaker/hystrix" rel="noopener ugc nofollow" target="_blank"> hystrix插件</a>和<a class="ae ld" href="https://github.com/micro/go-plugins/tree/master/wrapper/breaker/gobreaker" rel="noopener ugc nofollow" target="_blank"> gobreaker插件</a>。</p><p id="67a8" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在这些插件的帮助下，在Micro中使用断路器变得非常容易。以hystrix为例:</p><pre class="nc nd ne nf gt ng nh ni nj aw nk bi"><span id="19ae" class="nl ma it nh b gy nm nn l no np">import (<br/>...<br/>  <strong class="nh iu">"github.com/micro/go-plugins/wrapper/breaker/hystrix/v2"</strong><br/>...<br/>)</span><span id="2c1d" class="nl ma it nh b gy nq nn l no np">func main(){<br/>...<br/>  // New Service<br/>  service := micro.NewService(<br/>     micro.Name("com.foo.breaker.example"),<br/>     <strong class="nh iu">micro.WrapClient(hystrix.NewClientWrapper())</strong>,<br/>  )<br/>  // Initialise service<br/>  service.Init()<br/>...<br/>}</span></pre><p id="36b6" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们所需要做的就是在<code class="fe nr ns nt nh b">service</code>创建期间分配hystrix插件，</p><p id="6b5c" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">从现在开始，所有对远程服务的调用都将被插件跟踪。当请求超时或并发数达到限制时，将立即向调用者返回一个错误。</p><p id="f6c9" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">那么并发和超时的默认限制是什么呢？答案就在<em class="nu"> hystrix-go </em>插件的源代码中。查看<strong class="kh iu">github.com/afex/hystrix-go/hystrix/settings.go</strong>你会看到几个包级变量:</p><pre class="nc nd ne nf gt ng nh ni nj aw nk bi"><span id="b089" class="nl ma it nh b gy nm nn l no np">...<br/>   // DefaultTimeout is how long to wait for command to complete, in milliseconds<br/>   <strong class="nh iu">DefaultTimeout</strong> = 1000<br/>   // DefaultMaxConcurrent is how many commands of the same type can run at the same time<br/>   <strong class="nh iu">DefaultMaxConcurrent</strong> = 10<br/>...</span></pre><p id="465b" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">所以默认超时是1秒，默认并发限制是10。</p><p id="d818" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">注意:除了这两个之外还有更多设置，但是对它们的讨论超出了本文的范围。有兴趣可以去<em class="nu"> hystrix-go </em>库的<a class="ae ld" href="https://github.com/afex/hystrix-go/" rel="noopener ugc nofollow" target="_blank">官网</a>了解详细文档。</p><p id="e10a" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如果默认设置不符合我们的要求，您可以按如下方式进行修改:</p><pre class="nc nd ne nf gt ng nh ni nj aw nk bi"><span id="d5f1" class="nl ma it nh b gy nm nn l no np">import (<br/>...<br/><strong class="nh iu">  hystrixGo "github.com/afex/hystrix-go/hystrix"<br/></strong>  "github.com/micro/go-plugins/wrapper/breaker/hystrix/v2"<br/>...<br/>)</span><span id="4908" class="nl ma it nh b gy nq nn l no np">func main(){<br/>...<br/>  // New Service<br/>  service := micro.NewService(<br/>     micro.Name("com.foo.breaker.example"),<br/>     micro.WrapClient(hystrix.NewClientWrapper()),<br/>  )<br/>  // Initialise service<br/>  service.Init()<br/>  <strong class="nh iu">hystrixGo.DefaultMaxConcurrent = 3</strong>//change concurrrent to 3<br/>  <strong class="nh iu">hystrixGo.DefaultTimeout = 200 </strong>//change timeout to 200 milliseconds</span><span id="fbe5" class="nl ma it nh b gy nq nn l no np">...<br/>}</span></pre><p id="1d66" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如代码所示，我们可以更改默认超时和并发限制</p><p id="7b38" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">你可能对<strong class="kh iu"> DefaultMaxConcurrent </strong>有疑问:它的范围是什么？假设有3个服务，每个服务有3种不同的方法。我们想同时调用所有这些方法。是否意味着我们必须将<strong class="kh iu"> DefaultMaxConcurrent </strong>设置为大于3*3的数才能实现完全并发？</p><p id="4f2e" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">要回答这个问题，需要搞清楚两点:</p><p id="49fb" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">一、<strong class="kh iu"> DefaultMaxConcurrent </strong>的目标是什么？从hystrix文档中可以看到，这是hystrix中的<strong class="kh iu">命令</strong>:</p><blockquote class="nv nw nx"><p id="30cd" class="kf kg nu kh b ki kj kk kl km kn ko kp ny kr ks kt nz kv kw kx oa kz la lb lc im bi translated">DefaultMaxConcurrent是同一类型的命令可以同时运行的数量</p></blockquote><p id="1ce3" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">接下来，你需要知道hystrix插件如何处理不同方法和<strong class="kh iu">命令</strong>之间的映射。查看<strong class="kh iu">github . com/micro/go-plugins/wrapper/breaker/hy strix/v2/hy strix . go</strong>，你会发现相关代码如下:</p><pre class="nc nd ne nf gt ng nh ni nj aw nk bi"><span id="3226" class="nl ma it nh b gy nm nn l no np">import(<br/>  "github.com/afex/hystrix-go/hystrix"<br/>  ...<br/>)<br/>...</span><span id="72e7" class="nl ma it nh b gy nq nn l no np">func (c *clientWrapper) <strong class="nh iu">Call</strong>(ctx context.Context, req client.Request, rsp interface{}, opts ...client.CallOption) error {<br/>   return <strong class="nh iu">hystrix.Do</strong>(<strong class="nh iu">req.Service()+"."+req.Endpoint()</strong>, func() error {<br/>      return c.Client.Call(ctx, req, rsp, opts...)<br/>   }, nil)<br/>}<br/>...</span></pre><p id="272d" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">注意<code class="fe nr ns nt nh b">req.Service () + “.” + Req.Endpoint ()</code>，这是hystrix的<strong class="kh iu">命令</strong>。并且<strong class="kh iu">命令</strong>不包含节点信息，这意味着对于同一业务，无论是单节点部署还是多节点部署都没有区别，所有节点共享一个限制。</p><p id="92d0" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">至此，很清楚了:每个服务的每个方法都独立计数，互不影响。<strong class="kh iu"> DefaultMaxConcurrent </strong>的范围是<em class="nu">方法级</em>，不考虑节点数。</p><p id="6c96" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在实践中，不同的方法可能需要不同的限制。如何实现这一点？从上面的源代码中，我们知道一个服务方法被映射到一个hystrix <strong class="kh iu">命令</strong>，hystrix通过<code class="fe nr ns nt nh b">hystrix.ConfigureCommand</code>支持对不同命令的独立控制:</p><pre class="nc nd ne nf gt ng nh ni nj aw nk bi"><span id="9bdd" class="nl ma it nh b gy nm nn l no np">...<br/>hystrix.ConfigureCommand("<strong class="nh iu">com.serviceA.methodFoo</strong>",<br/>   hystrix.CommandConfig{<br/>      MaxConcurrentRequests: 50,<br/>      Timeout:               10,<br/>   })<br/>hystrix.ConfigureCommand("<strong class="nh iu">com.serviceB.methodBar</strong>",<br/>   hystrix.CommandConfig{<br/>      Timeout: 60,<br/>   })<br/>...</span></pre><p id="0d6e" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">通过上面的代码，我们为不同的方法设置了不同的限制。如果没有指定<code class="fe nr ns nt nh b">hystrix.CommandConfig</code>结构的任何字段，将使用系统默认值。</p><p id="1832" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">总结:断路器作用于客户端。通过适当的阈值，它可以确保客户机资源不会耗尽。即使它所依赖的服务不健康，客户端也会很快返回一个错误，而不是让调用者等待很长时间。</p><h1 id="0246" class="lz ma it bd mb mc ob me mf mg oc mi mj mk od mm mn mo oe mq mr ms of mu mv mw bi translated">限速器</h1><p id="15df" class="pw-post-body-paragraph kf kg it kh b ki mx kk kl km my ko kp kq mz ks kt ku na kw kx ky nb la lb lc im bi translated">与断路器类似，限速也是分布式系统中常用的功能。不同的是，速率限制器在服务器端生效，它的作用是保护服务器:一旦请求处理的速度达到预设的限制，服务器就不再接收新的请求，直到正在处理的请求完成。限速器可以避免服务器因大量请求而崩溃。</p><p id="fee9" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这里打个比方:假设我们经营一家可以容纳10位客人的餐厅。如果100位客人同时来吃饭，最好的处理方法是选择前10位来服务，并告诉其他90位客人:我们目前无法服务，请改天再来。虽然这90位客人会不开心，但我们保证至少前10位客人能吃到开心餐。</p><p id="4a0f" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">没有限速器，结果就是100个客人进餐厅，厨房忙不过来，所有客人都没地方坐。没有人能得到服务。整个餐厅最终陷入瘫痪。</p><p id="d932" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在Micro中使用速率限制器也非常简单。我们只需要一行代码就可以实现这一点。目前有两个速率限制器插件可用。本文以<a class="ae ld" href="https://github.com/micro/go-plugins/tree/master/wrapper/ratelimiter/uber" rel="noopener ugc nofollow" target="_blank">优步速率限制器插件</a>为例(当然，如果现有插件不符合要求，您随时可以自行开发更合适的插件)。让我们修改源文件<strong class="kh iu"> hello-service/main.go </strong>:</p><pre class="nc nd ne nf gt ng nh ni nj aw nk bi"><span id="782d" class="nl ma it nh b gy nm nn l no np">package main</span><span id="cb84" class="nl ma it nh b gy nq nn l no np">import (<br/>...<br/>   <strong class="nh iu">limiter "github.com/micro/go-plugins/wrapper/ratelimiter/uber/v2"</strong><br/>...<br/>)</span><span id="0e1f" class="nl ma it nh b gy nq nn l no np">func main() {<br/>   const <em class="nu">QPS </em>= 100<br/>   // New Service<br/>   service := micro.NewService(<br/>      micro.Name("com.foo.srv.hello"),<br/>      micro.Version("latest"),<br/>      <strong class="nh iu">micro.WrapHandler(limiter.NewHandlerWrapper(</strong><em class="nu">QPS</em><strong class="nh iu">)),</strong><br/>   )</span><span id="c791" class="nl ma it nh b gy nq nn l no np">...</span><span id="c689" class="nl ma it nh b gy nq nn l no np">}</span></pre><p id="f970" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">上述代码为<strong class="kh iu"> hello-service </strong>添加了服务器端速率限制器，QPS上限为100。此限制由该服务中所有处理程序的方法共享。换句话说，这种限制的范围是服务级别的。</p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="256a" class="lz ma it bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">最后的话</h1><p id="cbbf" class="pw-post-body-paragraph kf kg it kh b ki mx kk kl km my ko kp kq mz ks kt ku na kw kx ky nb la lb lc im bi translated">断路器和限速器都很重要。由于Micro的可插拔架构，我们可以轻松地应用这两个重要的功能。</p><p id="9485" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">断路器的作用是保护客户端不被外部服务问题拖累，始终快速响应(即使出错也比长时间等待好)。始终避免过度消耗资源。</p><p id="1681" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">而限速器的作用是保护服务器。只处理其能力范围内的流量，实现过载保护。当流量超过预设限制时，会立即返回错误。</p><p id="a42d" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">断路器和限速器的组合体现了一种设计哲学:<strong class="kh iu">永远先对自己负责，</strong>一个组件无论外部依赖状态如何，都要保证其鲁棒性。</p><p id="c399" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">当这种理念应用到分布式系统的每个组件时，系统将变得非常强大和有弹性，不会被突然的流量高峰淹没。</p><p id="ae13" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">所以在分布式系统的开发中应该遵循这样一个最佳实践:<strong class="kh iu">给每个服务添加断路器和速率限制器</strong>。在开始，它可以是粗粒度的限制。随着业务的发展，控制可以逐渐细化。最后，每个服务都会得到与之匹配的特定限制策略。</p><p id="60ff" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">未完待续。</p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><p id="6698" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">另请参见:</p><ul class=""><li id="9f70" class="le lf it kh b ki kj km kn kq lg ku lh ky li lc og lk ll lm bi translated"><a class="ae ld" rel="noopener ugc nofollow" target="_blank" href="/micro-in-action-getting-started-a79916ae3cac"> Micro In Action，第1部分:入门</a></li><li id="fe0c" class="le lf it kh b ki ln km lo kq lp ku lq ky lr lc og lk ll lm bi translated"><a class="ae ld" rel="noopener ugc nofollow" target="_blank" href="/micro-in-action-part-2-71230f01d6fb"> Micro In Action，第2部分:Bootstrap终极指南</a></li><li id="6ec5" class="le lf it kh b ki ln km lo kq lp ku lq ky lr lc og lk ll lm bi translated"><a class="ae ld" rel="noopener ugc nofollow" target="_blank" href="/micro-in-action-part-3-calling-a-service-55d865928f11">微操作，第3部分:调用服务</a></li><li id="99f3" class="le lf it kh b ki ln km lo kq lp ku lq ky lr lc og lk ll lm bi translated"><a class="ae ld" rel="noopener ugc nofollow" target="_blank" href="/micro-in-action-part4-pub-sub-564f3b054ecd">微在行动，第4部分:发布/订阅</a></li><li id="b918" class="le lf it kh b ki ln km lo kq lp ku lq ky lr lc og lk ll lm bi translated"><a class="ae ld" rel="noopener ugc nofollow" target="_blank" href="/micro-in-action-part-5-message-broker-a3decf07f26a"> Micro在行动，第5部分:消息代理</a></li><li id="062f" class="le lf it kh b ki ln km lo kq lp ku lq ky lr lc og lk ll lm bi translated"><a class="ae ld" rel="noopener ugc nofollow" target="_blank" href="/micro-in-action-part6-service-discovery-f988988e5936">微在行动，第6部分:服务发现</a></li><li id="0316" class="le lf it kh b ki ln km lo kq lp ku lq ky lr lc og lk ll lm bi translated"><a class="ae ld" rel="noopener ugc nofollow" target="_blank" href="/micro-in-action-coda-distributed-cron-job-a2b577885b24">微操作，Coda:分布式Cron作业</a></li><li id="6dc9" class="le lf it kh b ki ln km lo kq lp ku lq ky lr lc og lk ll lm bi translated"><a class="ae ld" href="https://medium.com/@dche423/micro-in-action-1be29b057f2d" rel="noopener">微在行动的索引页</a></li></ul></div></div>    
</body>
</html>