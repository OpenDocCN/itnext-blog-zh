<html>
<head>
<title>Authenticating Absinthe GraphQL APIs in Phoenix with Guardian</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">《卫报》对凤凰城苦艾酒原料药的鉴定</h1>
<blockquote>原文：<a href="https://itnext.io/authenticating-absinthe-graphql-apis-in-phoenix-with-guardian-d647ea45a69a?source=collection_archive---------2-----------------------#2018-03-02">https://itnext.io/authenticating-absinthe-graphql-apis-in-phoenix-with-guardian-d647ea45a69a?source=collection_archive---------2-----------------------#2018-03-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="3683" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><a class="ae ko" href="https://www.linkedin.com/cws/share?url=https%3A%2F%2Fitnext.io%2Fauthenticating-absinthe-graphql-apis-in-phoenix-with-guardian-d647ea45a69a" rel="noopener ugc nofollow" target="_blank"> <em class="kp">点击这里在LinkedIn </em>上分享这篇文章</a></p><p id="0f0b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我的前两篇文章中，我重点介绍了在Phoenix中编写GraphQL APIs以及用Guardian认证REST APIs。你可以在这里阅读这两篇文章——<a class="ae ko" rel="noopener ugc nofollow" target="_blank" href="/graphql-with-elixir-phoenix-and-absinthe-6b0ffd260094">graph QL with Elixir/Phoenix and absinie</a>和<a class="ae ko" rel="noopener ugc nofollow" target="_blank" href="/user-authentication-with-guardian-for-phoenix-1-3-web-apps-e2064cac0ec1">Guardian for Phoenix 1.3 Web Apps的用户认证</a>。在本文中，我将在之前文章的基础上使用Guardian认证GraphQL APIs。</p><h1 id="960f" class="kq kr it bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated"><strong class="ak">我们需要什么</strong></h1><ol class=""><li id="b973" class="lo lp it js b jt lq jx lr kb ls kf lt kj lu kn lv lw lx ly bi translated"><a class="ae ko" href="http://phoenixframework.org" rel="noopener ugc nofollow" target="_blank"> Phoenix Web框架</a> —用于编写Web应用</li><li id="51d4" class="lo lp it js b jt lz jx ma kb mb kf mc kj md kn lv lw lx ly bi translated"><a class="ae ko" href="http://absinthe-graphql.org" rel="noopener ugc nofollow" target="_blank">苦艾酒</a> — GraphQL编写查询/突变的灵丹妙药工具包</li><li id="5ad4" class="lo lp it js b jt lz jx ma kb mb kf mc kj md kn lv lw lx ly bi translated"><a class="ae ko" href="https://github.com/graphql/graphiql" rel="noopener ugc nofollow" target="_blank">GraphQL</a>—一个用于探索graph QL的浏览器内集成开发环境。你可以把它想象成休息的邮递员。我们将在这里使用来自<a class="ae ko" href="https://github.com/skevy/graphiql-app" rel="noopener ugc nofollow" target="_blank">的mac应用</a>，它是GraphiQL的一个包装器。</li><li id="2bcd" class="lo lp it js b jt lz jx ma kb mb kf mc kj md kn lv lw lx ly bi translated"><a class="ae ko" href="https://github.com/ueberauth/guardian" rel="noopener ugc nofollow" target="_blank"> Guardian </a> —用于Elixir应用程序的认证库</li></ol><h1 id="dded" class="kq kr it bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">应用概述</h1><p id="5c66" class="pw-post-body-paragraph jq jr it js b jt lq jv jw jx lr jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">我们将使用的Phoenix应用程序是一个简单的博客应用程序，Phoenix 1.3有两个模式，分别在帐户和博客上下文中定义用户和帖子。这与前一篇文章中使用的相同——graph QL与酏剂/凤凰和苦艾酒。完整代码可从github <a class="ae ko" href="https://github.com/imeraj/Phoenix_Playground/tree/master/1.3/blog_app_gql" rel="noopener ugc nofollow" target="_blank">这里</a>获得。我们将扩展这个应用程序来支持一些新的基于令牌的认证API。</p><h1 id="b932" class="kq kr it bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated"><strong class="ak">添加依赖关系</strong></h1><p id="9c8b" class="pw-post-body-paragraph jq jr it js b jt lq jv jw jx lr jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">首先，我们需要将Guardian和其他一些库作为依赖项添加到我们的应用程序中—</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="9954" class="mq kr it mm b gy mr ms l mt mu">defp deps <strong class="mm iu">do<br/>  </strong>[<br/>    {:guardian, "~&gt; 1.0"},<br/>    {:comeonin, "~&gt; 4.0"},<br/>    {:bcrypt_elixir, "~&gt; 1.0"}<br/>  ]<br/><strong class="mm iu">end</strong></span></pre><p id="1962" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里—</p><p id="5ab9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一、<a class="ae ko" href="https://github.com/ueberauth/guardian" rel="noopener ugc nofollow" target="_blank"> guardian </a>:是认证库</p><p id="726b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">二。是仙丹的密码哈希库</p><p id="ea9b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">三。<a class="ae ko" href="https://github.com/riverrun/bcrypt_elixir" rel="noopener ugc nofollow" target="_blank">bcrypt _ elixir</a>:comeon使用的是密码哈希算法吗</p><h1 id="1d7d" class="kq kr it bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated"><strong class="ak">新的原料药</strong></h1><p id="6394" class="pw-post-body-paragraph jq jr it js b jt lq jv jw jx lr jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">我们将在以前的GraphQL文章中开发的应用程序的基础上添加以下新的GraphQL APIs</p><p id="e387" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">I .创建用户——注册新用户</p><p id="b7a7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">二。登录—允许用户登录</p><p id="741b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">三。注销—让用户注销</p><p id="3de7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">此外，我们将使用身份验证来保护上一篇文章中开发的所有API。</p><h1 id="41a3" class="kq kr it bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">注册用户</h1><p id="ff4a" class="pw-post-body-paragraph jq jr it js b jt lq jv jw jx lr jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">为了让用户使用名称、电子邮件和密码进行注册，我们需要将password_hash添加到DB中。所以，让我们首先创建一个如下的迁移—</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="7487" class="mq kr it mm b gy mr ms l mt mu">defmodule BlogAppGql.Repo.Migrations.AddPasswordHashToAccountsUser <strong class="mm iu">do<br/>  </strong>use Ecto.Migration<br/><br/>  def change <strong class="mm iu">do<br/>    </strong>alter table(:accounts_users) <strong class="mm iu">do<br/>      </strong>add :password_hash, :string<br/>    <strong class="mm iu">end<br/>  end<br/>end</strong></span></pre><p id="7efe" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">并将用户模式更改为password虚拟字段和password_hash字段。</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="826d" class="mq kr it mm b gy mr ms l mt mu">schema "accounts_users" <strong class="mm iu">do<br/>  </strong>field(:email, :string)<br/>  field(:name, :string)<br/>  <strong class="mm iu">field(:password, :string, virtual: true)<br/>  field(:password_hash, :string)<br/>  </strong><br/>  has_many(:blog_posts, BlogAppGql.Blog.Post, foreign_key: :accounts_user_id)<br/><br/>  timestamps()<br/><strong class="mm iu">end</strong></span></pre><p id="2f60" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们需要把我们的突变写成如下—</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="19e9" class="mq kr it mm b gy mr ms l mt mu">field :create_user, type: :accounts_user <strong class="mm iu">do<br/> </strong>arg(:name, non_null(:string))<br/> arg(:email, non_null(:string))<br/> arg(:password, non_null(:string))<br/><br/> resolve(&amp;BlogAppGql.Accounts.UserResolver.create/2)<br/><strong class="mm iu">end</strong></span></pre><p id="646b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">解析器功能看起来像—</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="c507" class="mq kr it mm b gy mr ms l mt mu">def create(params, _info) <strong class="mm iu">do<br/>  </strong>Accounts.create_user(params)<br/><strong class="mm iu">end</strong></span><span id="ad8c" class="mq kr it mm b gy mv ms l mt mu">def create_user(attrs \\ %{}) <strong class="mm iu">do<br/>  </strong>%User{}<br/>  |&gt; User.changeset(attrs)<br/>  |&gt; Repo.insert()<br/><strong class="mm iu">end</strong></span></pre><p id="14d5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">变更集看起来如下—</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="a769" class="mq kr it mm b gy mr ms l mt mu">def changeset(%User{} = user, attrs) <strong class="mm iu">do<br/>  </strong>user<br/>  |&gt; cast(attrs, [:name, :email, :password])<br/>  |&gt; validate_required([:name, :email, :password])<br/>  |&gt; validate_length(:name, min: 3, max: 10)<br/>  |&gt; validate_length(:password, min: 5, max: 20)<br/>  |&gt; unique_constraint(:email, downcase: <strong class="mm iu">true</strong>)<br/>  |&gt; <strong class="mm iu">put_password_hash()</strong><br/><strong class="mm iu">end</strong></span><span id="1e3b" class="mq kr it mm b gy mv ms l mt mu">defp put_password_hash(changeset) <strong class="mm iu">do<br/>  </strong>case changeset <strong class="mm iu">do<br/>    </strong>%Ecto.Changeset{valid?: <strong class="mm iu">true</strong>, changes: %{password: pass}} -&gt;<br/>      put_change(changeset, :password_hash, Comeonin.Bcrypt.hashpwsalt(pass))<br/><br/>    _ -&gt;<br/>      changeset<br/>  <strong class="mm iu">end<br/>end</strong></span></pre><p id="07c8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> put_password_hash() </strong>负责在注册过程中创建password_hash，并将其放入变更集中，以便数据库只包含哈希后的密码。</p><p id="ffe9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">启动GraphiQL，让我们测试新的API(不要忘记运行DB迁移和phoenix服务器:)。</p><figure class="mh mi mj mk gt mx gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi mw"><img src="../Images/c55abb890a23b084eef012d7bb1d1c6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2C-BXWv44OavwwXzvNVCdw.png"/></div></div><figcaption class="ne nf gj gh gi ng nh bd b be z dk translated">创建用户API</figcaption></figure><p id="0631" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">请注意，我使用了端点—<a class="ae ko" href="http://0.0.0.0:4000/api/graphiql" rel="noopener ugc nofollow" target="_blank">http://0 . 0 . 0 . 0:4000/API/graphiql</a>而不是<a class="ae ko" href="http://0.0.0.0:4000/graphiql." rel="noopener ugc nofollow" target="_blank">http://0 . 0 . 0 . 0:4000/graphiql。</a>这将在后面解释。</p><p id="c5ce" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">既然createUser (registration)正在工作，我们将需要配置Guardian并实现身份验证机制。</p><h1 id="3150" class="kq kr it bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">配置挂点</h1><p id="40ce" class="pw-post-body-paragraph jq jr it js b jt lq jv jw jx lr jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">在config/config.exs中添加以下内容以配置Guardian —</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="08df" class="mq kr it mm b gy mr ms l mt mu"># configures Guardian<br/>config :blog_app_gql, BlogAppGql.Guardian,<br/>  # optional<br/>  allowed_algos: ["HS512"],<br/>  # optional<br/>  verify_module: Guardian.JWT,<br/>  issuer: "BlogAppGql",<br/>  ttl: {30, :days},<br/>  allowed_drift: 2000,<br/>  # optional<br/>  verify_issuer: <strong class="mm iu">true</strong>,<br/>  <strong class="mm iu"><em class="kp"># generated using: JOSE.JWK.generate_key({:oct, 16}) |&gt; JOSE.JWK.to_map |&gt; elem(1)</em></strong><br/>  <strong class="mm iu">secret_key: %{"k" =&gt; "3gx0vXjUD2BJ8xfo_aQWIA", "kty" =&gt; "oct"},<br/>  </strong>serializer: BlogAppGql.Guardian</span></pre><p id="c2c9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">大多数字段都是可选的，可以省略。</p><p id="e449" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">secret_key可以在iex会话(iex -S mix)中使用上面一行中的命令生成。</p><p id="df6c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们需要添加序列化器模块<strong class="js iu">blogapgql。卫报</strong>包含一些回调—</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="e324" class="mq kr it mm b gy mr ms l mt mu">defmodule BlogAppGql.Guardian <strong class="mm iu">do<br/> </strong>use Guardian, otp_app: :blog_app_gql<br/> alias BlogAppGql.Accounts<br/><br/> def subject_for_token(user, _claims) <strong class="mm iu">do<br/>  </strong># You can use any value for the subject of your token but<br/>  # it should be useful in retrieving the user later, see<br/>  # how it being used on `user_from_claims/1` function.<br/>  # A unique `id` is a good subject, a non-unique email address<br/>  # is a poor subject.<br/>  sub = to_string(user.id)<br/>  {:ok, sub}<br/> <strong class="mm iu">end<br/><br/> </strong>def resource_from_claims(claims) <strong class="mm iu">do<br/>  </strong># Here we'll look up our resource from the claims, the subject can be<br/>  # found in the `"sub"` key. In `above subject_for_token/2` we returned<br/>  # the resource id so here we'll rely on that to look it up.<br/>  user = claims["sub"] |&gt; Accounts.get_user!<br/>  {:ok,  user}<br/> <strong class="mm iu">end<br/>end</strong></span></pre><h1 id="5962" class="kq kr it bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated"><strong class="ak">登录/验证用户</strong></h1><p id="03c1" class="pw-post-body-paragraph jq jr it js b jt lq jv jw jx lr jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">现在，我们准备创建我们的登录API。为此，我们需要在用户表中创建一个令牌字段。让我们创建另一个迁移，如下所示—</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="e853" class="mq kr it mm b gy mr ms l mt mu">defmodule BlogAppGql.Repo.Migrations.AddTokenToAccountsUsers <strong class="mm iu">do<br/>  </strong>use Ecto.Migration<br/><br/>  def change <strong class="mm iu">do<br/>   </strong>alter table(:accounts_users) <strong class="mm iu">do<br/>    </strong>add :token, :text<br/>   <strong class="mm iu">end<br/>  end<br/>end</strong></span></pre><p id="369c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">并修改用户模式，使其具有令牌字段—</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="7575" class="mq kr it mm b gy mr ms l mt mu">schema "accounts_users" <strong class="mm iu">do<br/>  </strong>field(:email, :string)<br/>  field(:name, :string)<br/>  field(:password, :string, virtual: <strong class="mm iu">true</strong>)<br/>  field(:password_hash, :string)<br/>  <strong class="mm iu">field(:token, :string)</strong><br/><br/>  has_many(:blog_posts, BlogAppGql.Blog.Post, foreign_key: :accounts_user_id)<br/><br/>  timestamps()<br/><strong class="mm iu">end</strong></span></pre><p id="9235" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在让我们创建登录查询—</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="9dc0" class="mq kr it mm b gy mr ms l mt mu">field :login, type: :session <strong class="mm iu">do<br/>  </strong>arg(:email, non_null(:string))<br/>  arg(:password, non_null(:string))<br/><br/>  resolve(&amp;BlogAppGql.Accounts.UserResolver.login/2)<br/><strong class="mm iu">end</strong></span></pre><p id="6870" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">登录解析器功能如下所示—</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="543e" class="mq kr it mm b gy mr ms l mt mu">def login(%{email: email, password: password}, _info) <strong class="mm iu">do<br/>  </strong>with {:ok, user} &lt;- <strong class="mm iu">login_with_email_pass(email, password)</strong>,<br/>       {:ok, jwt, _} &lt;- <strong class="mm iu">BlogAppGql.Guardian.encode_and_sign(user)</strong>,<br/>       {:ok, _ } &lt;- <strong class="mm iu">BlogAppGql.Accounts.store_token(user, jwt)</strong> <strong class="mm iu">do<br/>    </strong>{:ok, %{token: jwt}}<br/>  <strong class="mm iu">end<br/>end</strong></span></pre><p id="b4cf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里—</p><p id="673c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">i. <strong class="js iu"> login_with_email_pass(电子邮件，密码)</strong> —将根据电子邮件和密码验证用户的身份</p><p id="ea2f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">二。<strong class="js iu">blogapgql。guardian . encode _ and _ sign(user)</strong>—将生成令牌(jwt，即JSON Web令牌)</p><p id="4f5e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">三。<strong class="js iu">blogapgql。Accounts.store_token(user，jwt) </strong> —将生成的令牌存储在数据库中</p><p id="bd08" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">登录电子邮件通行证(电子邮件，密码)</strong>的代码如下所示—</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="260f" class="mq kr it mm b gy mr ms l mt mu">defmodule BlogAppGql.AuthHelper <strong class="mm iu">do<br/>  </strong>@moduledoc <strong class="mm iu">false<br/><br/>  </strong>import Comeonin.Bcrypt, only: [checkpw: 2]<br/>  alias BlogAppGql.Repo<br/>  alias BlogAppGql.Accounts.User<br/><br/>  def login_with_email_pass(email, given_pass) <strong class="mm iu">do<br/>    </strong>user = Repo.get_by(User, email: String.downcase(email))<br/><br/>    cond <strong class="mm iu">do<br/>      user &amp;&amp; checkpw(given_pass, user.password_hash)</strong> -&gt;<br/>        {:ok, user}<br/><br/>      user -&gt;<br/>        {:error, "Incorrect login credentials"}<br/><br/>      <strong class="mm iu">true </strong>-&gt;<br/>        {:error, :"User not found"}<br/>    <strong class="mm iu">end<br/>  end<br/>end</strong></span></pre><p id="5143" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">还有<strong class="js iu">blogapgql。Accounts.store_token(user，jwt) </strong>看起来像是——</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="201d" class="mq kr it mm b gy mr ms l mt mu">def store_token(%User{} = user, token) <strong class="mm iu">do<br/>  </strong>user<br/>  |&gt; User.store_token_changeset(%{token: token})<br/>  |&gt; Repo.update()<br/><strong class="mm iu">end</strong></span></pre><p id="7ac0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这应该足以在成功登录时向我们发放令牌。让我们试试这个—</p><figure class="mh mi mj mk gt mx gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi ni"><img src="../Images/7c01f906ecb1faa023daa88cc1040b6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CQ7MFinzLsOcx0OuZmr-6A.png"/></div></div><figcaption class="ne nf gj gh gi ng nh bd b be z dk translated">登录API</figcaption></figure><p id="0611" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们已经能够成功地向登录用户颁发令牌。</p><p id="3e78" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，我们希望使用身份验证来保护我们的API(在上一篇文章中开发),以便只有登录的用户才能访问这些API。</p><h1 id="17f0" class="kq kr it bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated"><strong class="ak">写上下文插</strong></h1><p id="b2ad" class="pw-post-body-paragraph jq jr it js b jt lq jv jw jx lr jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">我们需要编写这个上下文插件，并将其挂接到graphql API管道(<strong class="js iu"> router.ex </strong>)中，这样，如果有人登录，我们的解析器函数就可以使用登录的用户信息。</p><p id="0e97" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们的<strong class="js iu">上下文</strong>插件看起来如下—</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="6d09" class="mq kr it mm b gy mr ms l mt mu">defmodule BlogAppGql.Context <strong class="mm iu">do<br/> </strong>@behaviour Plug<br/><br/> import Plug.Conn<br/> import Ecto.Query, only: [where: 2]<br/><br/> alias BlogAppGql.Repo<br/> alias BlogAppGql.Accounts.User<br/><br/> def init(opts), <strong class="mm iu">do</strong>: opts<br/><br/> def call(conn, _) <strong class="mm iu">do<br/>  </strong>case build_context(conn) <strong class="mm iu">do<br/>   </strong>{:ok, context} -&gt;<br/>    <strong class="mm iu">put_private(conn, :absinthe, %{context: context})</strong><br/>   _ -&gt;<br/>    conn<br/>  <strong class="mm iu">end<br/> end<br/><br/> </strong>defp build_context(conn) <strong class="mm iu">do<br/>  </strong>with ["Bearer " &lt;&gt; token] &lt;- <strong class="mm iu">get_req_header(conn, "authorization")</strong>,<br/>       {:ok, current_user} &lt;- <strong class="mm iu">authorize(token)</strong> <strong class="mm iu">do<br/>   </strong>{:ok, %{current_user: current_user, token: token}}<br/>  <strong class="mm iu">end<br/> end<br/><br/> </strong>defp authorize(token) <strong class="mm iu">do<br/>    </strong>User<br/>    <strong class="mm iu">|&gt; where(token: ^token)</strong><br/>    |&gt; Repo.one()<br/>  |&gt; case <strong class="mm iu">do<br/>       nil </strong>-&gt; {:error, "Invalid authorization token"}<br/>    user -&gt; {:ok, user}<br/>     <strong class="mm iu">end<br/> end<br/>end</strong></span></pre><p id="cee1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这里，粗线很重要。<strong class="js iu"> get_req_header </strong>将从conn检索授权承载令牌。然后使用<strong class="js iu"> authorize </strong>函数中的令牌检索用户信息，并且<strong class="js iu"> put_private </strong>将当前用户和令牌放入上下文中。</p><h1 id="d813" class="kq kr it bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated"><strong class="ak">路由器中的修改</strong></h1><p id="5c67" class="pw-post-body-paragraph jq jr it js b jt lq jv jw jx lr jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">接下来，我们需要在<strong class="js iu"> router.ex </strong>中进行修改，以便将上下文插件放在api管道中</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="553b" class="mq kr it mm b gy mr ms l mt mu">defmodule BlogAppGql.Web.Router <strong class="mm iu">do<br/>  </strong>use BlogAppGql.Web, :router<br/><br/>  pipeline :graphql <strong class="mm iu">do<br/>   </strong>plug BlogAppGql.Context<br/>  <strong class="mm iu">end<br/><br/>  </strong>scope "/api" <strong class="mm iu">do<br/>    </strong>pipe_through(:graphql)<br/><br/>    forward("/", Absinthe.Plug, schema: BlogAppGql.Web.Schema)<br/>    forward("/graphiql", Absinthe.Plug.GraphiQL, schema: BlogAppGql.Web.Schema)<br/>  <strong class="mm iu">end<br/>end</strong></span></pre><p id="1e7e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="kp">我们创建了一个作用域“api ”,并将我们的graphql路由放在该作用域中。这就是为什么我们需要访问端点作为—</em><a class="ae ko" href="http://0.0.0.0:4000/api/graphiql." rel="noopener ugc nofollow" target="_blank"><em class="kp">http://0 . 0 . 0 . 0:4000/API/graphiql。</em> </a></p><p id="22e9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，我们需要修改现有的解析器函数，使用上下文信息来防止未经授权的访问。我将展示一个API createPost的例子。其余的类似，可以在源代码库中找到。</p><h1 id="8ae6" class="kq kr it bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">修改授权访问的createPost API</h1><p id="1398" class="pw-post-body-paragraph jq jr it js b jt lq jv jw jx lr jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">我们现在必须写两个函数如下—</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="3976" class="mq kr it mm b gy mr ms l mt mu">def create(args, %{context: %{current_user: _current_user}}) <strong class="mm iu">do<br/>  </strong>Blog.create_post(args)<br/><strong class="mm iu">end<br/><br/></strong>def create(_args, _info) <strong class="mm iu">do<br/> </strong>{:error, "Not Authorized"}<br/><strong class="mm iu">end</strong></span></pre><p id="6db4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果找到当前用户并且允许访问，则第一个将匹配。</p><p id="55db" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果找不到current_user，第二个将匹配。在这种情况下，它会给出“未授权”的错误信息。</p><p id="ffa2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们为这两种场景运行API</p><figure class="mh mi mj mk gt mx gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi nj"><img src="../Images/7b04ad17b27c820dc404a181ec15e032.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8xBjXw_kZVv8W3K8Sr8mYw.png"/></div></div><figcaption class="ne nf gj gh gi ng nh bd b be z dk translated">在标题中设置标记</figcaption></figure><figure class="mh mi mj mk gt mx gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi nk"><img src="../Images/f9c45423b39b25637d898b0e4b5b0a2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_GIsbOvX0h9-DOetQ8SaVg.png"/></div></div><figcaption class="ne nf gj gh gi ng nh bd b be z dk translated">创建发布API(带有访问令牌)</figcaption></figure><p id="c009" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是如果我们不给出访问令牌，输出将如下所示—</p><figure class="mh mi mj mk gt mx gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi nk"><img src="../Images/d75322b913c4bd1d2665f5a86956df81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2U4XSEjaUzaG3dpycElQpQ.png"/></div></div><figcaption class="ne nf gj gh gi ng nh bd b be z dk translated">创建发布API(无访问令牌)</figcaption></figure><p id="8bea" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">完成这些工作后，我们的最后一步是实现注销/退出功能。</p><h1 id="d35b" class="kq kr it bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated"><strong class="ak">退出/注销用户:</strong></h1><p id="b8f2" class="pw-post-body-paragraph jq jr it js b jt lq jv jw jx lr jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">注销非常简单。我们只需要在用户注销时从数据库中删除令牌。让我们先创建一个标记突变—</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="7277" class="mq kr it mm b gy mr ms l mt mu">field :sign_out, type: :accounts_user <strong class="mm iu">do<br/> </strong>arg(:id, non_null(:id))<br/> resolve(&amp;BlogAppGql.Accounts.UserResolver.logout/2)<br/><strong class="mm iu">end</strong></span></pre><p id="5a29" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">解析器功能看起来像—</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="8589" class="mq kr it mm b gy mr ms l mt mu">def logout(_args,  %{context: %{current_user: current_user, token: _token}}) <strong class="mm iu">do<br/>  BlogAppGql.Accounts.revoke_token(current_user, nil)</strong><br/>  {:ok, current_user}<br/><strong class="mm iu">end<br/><br/></strong>def logout(_args, _info) <strong class="mm iu">do<br/>  </strong>{:error, "Please log in first!"}<br/><strong class="mm iu">end</strong></span></pre><p id="7adc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">还有<strong class="js iu">blogapgql。accounts . revoke _ token(current _ user，nil) </strong>看起来像是—</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="861c" class="mq kr it mm b gy mr ms l mt mu">def revoke_token(%User{} = user, token) <strong class="mm iu">do<br/>  </strong>user<br/>  |&gt; User.store_token_changeset(%{token: token})<br/>  |&gt; Repo.update()<br/><strong class="mm iu">end</strong></span></pre><p id="7296" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们现在试试这个。因为我们必须先登录才能注销，所以我们必须传递授权头中的访问令牌—</p><figure class="mh mi mj mk gt mx gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi nl"><img src="../Images/ba4c965ee2ddaea8585bc9ac7327cefb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bK6tBcWCOrwVUiuUrZ46Zw.png"/></div></div><figcaption class="ne nf gj gh gi ng nh bd b be z dk translated">注销API</figcaption></figure><p id="2fbd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本文中，我们用代码示例演示了如何在用苦艾酒库编写的Phoenix Web应用程序的GraphQL APIs中实现身份验证。我希望它能帮助一些读者。</p><p id="cbd8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="kp">更多详细和深入的未来技术帖子请关注我这里或点击</em> <a class="ae ko" href="https://twitter.com/meraj_enigma" rel="noopener ugc nofollow" target="_blank"> <em class="kp"> twitter </em> </a> <em class="kp">。</em></p></div></div>    
</body>
</html>