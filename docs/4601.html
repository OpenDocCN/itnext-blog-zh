<html>
<head>
<title>Complex JSON parsing with Ansible and JMESPath</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Ansible和JMESPath进行复杂的JSON解析</h1>
<blockquote>原文：<a href="https://itnext.io/complex-json-parsing-with-ansible-and-jmespath-5ca58ad5fbf3?source=collection_archive---------1-----------------------#2020-08-03">https://itnext.io/complex-json-parsing-with-ansible-and-jmespath-5ca58ad5fbf3?source=collection_archive---------1-----------------------#2020-08-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/98f4ed2a80009910fbe8a16ceb3f75b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-Hre0tQ7WuPdheCWhkmuQw.png"/></div></div></figure><p id="5550" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">JSON已经成为计算机世界中应用程序间共享信息的通用语言。几乎所有编写代码与Web APIs交互或检索应用程序结果的人都需要知道如何解析JSON。幸运的是，由于JSON的流行，它得到了广泛的支持，并且有许多包，比如<a class="ae kw" href="https://jmespath.org" rel="noopener ugc nofollow" target="_blank"> JMESPath </a>，可以用来帮助解析复杂的JSON结构。</p><p id="8015" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我经常使用<a class="ae kw" href="https://www.ansible.com" rel="noopener ugc nofollow" target="_blank"> Ansible </a>部署或更新基础设施时，我必须解析来自<a class="ae kw" href="https://docs.ansible.com/ansible/latest/modules/list_of_cloud_modules.html" rel="noopener ugc nofollow" target="_blank">云提供商</a>的JSON结果，或者在与<a class="ae kw" href="https://kubernetes.io" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>交互时解析类似<code class="fe kx ky kz la b">kubectl</code>的命令输出。这些来源的输出通常包含大量信息，解析所有这些信息以获得所需的内容并将其转换为可用的格式通常很困难。</p><p id="2cc8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在下面来自<code class="fe kx ky kz la b">kubectl get node node-name -o json</code>的示例输出中，没有一种简单的方法可以在不遍历列表的情况下使用Ansible的本地JSON解析来获取<code class="fe kx ky kz la b">type</code> <code class="fe kx ky kz la b">Ready</code>的<code class="fe kx ky kz la b">status</code>。</p><pre class="lb lc ld le gt lf la lg lh aw li bi"><span id="c4dc" class="lj lk iq la b gy ll lm l ln lo">{<br/>  "conditions": [<br/>              {<br/>                  "status": "False",<br/>                  "type": "NetworkUnavailable"<br/>              },<br/>              {<br/>                 "status": "False",<br/>                  "type": "MemoryPressure"<br/>              },<br/>              {<br/>                  "status": "False",<br/>                  "type": "DiskPressure"<br/>              },<br/>              {<br/>                  "status": "False",<br/>                  "type": "PIDPressure"<br/>              },<br/>              {<br/>                 "status": "True",<br/>                  "type": "Ready"<br/>              }<br/>  ]<br/>}</span></pre><p id="7f96" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，Ansible通过使用<a class="ae kw" href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_filters.html#json-query-filter" rel="noopener ugc nofollow" target="_blank"> json_query </a>过滤器公开JMESPath JSON解析库解决了这个问题。</p><p id="3e30" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这个例子中，我将演示如何使用Ansible和JMESPath解析复杂的JSON输出，并通过使用一个键过滤器和压缩两个JSON列表将结果转换成更有用的格式。</p></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><p id="f08a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于这个例子，我使用<a class="ae kw" href="https://www.openstack.org/software/releases/ussuri/components/heat" rel="noopener ugc nofollow" target="_blank"> OpenStack Heat </a>创建一个8节点(3个MON节点和5个OSD节点)的Ceph集群，该集群将使用<a class="ae kw" href="https://docs.ceph.com/ceph-ansible/master/" rel="noopener ugc nofollow" target="_blank"> ceph-ansible </a>安装Ceph。因为我处于这个项目的开发和测试阶段，所以我经常创建和销毁集群。OpenStack Heat和Ansible在自动化大多数创建和销毁步骤方面做得很好，但是仍然有一个手动步骤，我必须将OpenStack Heat创建的节点的主机名和ip地址复制到Ansible的库存文件中。为了完全自动化这个过程，我必须在Ansible中捕获OpenStack Heat的输出，这样我就可以使用Ansible模板自动生成库存文件。</p><p id="4844" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要创建库存文件，这意味着要转换这个JSON:</p><pre class="lb lc ld le gt lf la lg lh aw li bi"><span id="6842" class="lj lk iq la b gy ll lm l ln lo">{<br/>    "stack_create.stack.outputs": [<br/>        {<br/>            "description": "Ceph osd management addresses",<br/>            "output_key": "ceph_osd_management_addresses",<br/>            "output_value": [<br/>                "192.168.0.95",<br/>                "192.168.0.101",<br/>                "192.168.0.155",<br/>                "192.168.0.161",<br/>                "192.168.0.23"<br/>            ]<br/>        },<br/>        {<br/>            "description": "Ceph osd server names",<br/>            "output_key": "ceph_osd_server_names",<br/>            "output_value": [<br/>                "ceph-osd-0",<br/>                "ceph-osd-1",<br/>                "ceph-osd-2",<br/>                "ceph-osd-3",<br/>                "ceph-osd-4"<br/>            ]<br/>        },<br/>        {<br/>            "description": "Ceph mon management addresses",<br/>            "output_key": "ceph_mon_management_addresses",<br/>            "output_value": [<br/>                "192.168.0.117",<br/>                "192.168.0.240",<br/>                "192.168.0.44"<br/>            ]<br/>        },<br/>        {<br/>            "description": "Ceph mon server names",<br/>            "output_key": "ceph_mon_server_names",<br/>            "output_value": [<br/>                "ceph-mon-0",<br/>                "ceph-mon-1",<br/>                "ceph-mon-2"<br/>            ]<br/>        }<br/>    ]<br/>}</span></pre><p id="f397" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">到以下库存文件中:</p><pre class="lb lc ld le gt lf la lg lh aw li bi"><span id="0f14" class="lj lk iq la b gy ll lm l ln lo">[mons]<br/>ceph-mon-0 ansible_host=192.168.0.117 <br/>ceph-mon-1 ansible_host=192.168.0.240 <br/>ceph-mon-2 ansible_host=192.168.0.44</span><span id="ee46" class="lj lk iq la b gy lw lm l ln lo">[osds]<br/>ceph-osd-0 ansible_host=192.168.0.95 <br/>ceph-osd-1 ansible_host=192.168.0.101 <br/>ceph-osd-2 ansible_host=192.168.0.155<br/>ceph-osd-3 ansible_host=192.168.0.161<br/>ceph-osd-4 ansible_host=192.168.0.23</span></pre><p id="d206" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一般来说，Ansible有很好的JSON原生解析，但是Ansible的原生JSON解析不能处理这种情况，就像上面一样，当你需要根据一个JSON对象中的键值过滤一系列JSON对象时。例如，在上面的JSON输出中，我想要键<code class="fe kx ky kz la b">output_value</code>中的ip地址列表，其中<code class="fe kx ky kz la b">output_key</code> = <code class="fe kx ky kz la b">ceph_mon_management_addresses</code>。Ansible的原生JSON解析所能做到的最好的是<code class="fe kx ky kz la b">stack_create.stack.outputs[2].output_value</code>，但是这需要<code class="fe kx ky kz la b">ceph_mon_management_addresses</code>总是列表中的第三项，这是无法保证的。</p><p id="a8e6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这就是Ansible的<a class="ae kw" href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_filters.html#json-query-filter" rel="noopener ugc nofollow" target="_blank"> json_query过滤器</a>的用武之地。使用JMESPath，我们可以在对象列表中搜索一个键值对，但返回同一对象中另一个键值。实际上，对于这个例子，我们可以在对象列表中搜索对象where <code class="fe kx ky kz la b">output_key</code> = <code class="fe kx ky kz la b">ceph_mon_management_addresses</code>并返回<code class="fe kx ky kz la b">output_value</code>的值。下面是一个Ansible <code class="fe kx ky kz la b">set_fact</code>任务，它使用一个JMESPath查询来获得结果:</p><pre class="lb lc ld le gt lf la lg lh aw li bi"><span id="6ea5" class="lj lk iq la b gy ll lm l ln lo">- name: Create a list of mon ip addresses<br/>  set_fact:<br/>     mon_ips: "{{ stack_create | json_query(\"<strong class="la ir">stack.</strong><strong class="la ir">outputs[?output_key == ‘ceph_mon_management_addresses’].output_value</strong>\") }}"</span></pre><p id="d1ef" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本例中，对包含<code class="fe kx ky kz la b">output_key == ‘ceph_mon_management_addresses’</code>的对象的搜索是通过上面的语句使用JMESPath <a class="ae kw" href="https://jmespath.org/tutorial.html#filter-projections" rel="noopener ugc nofollow" target="_blank">过滤器投影</a> ( <code class="fe kx ky kz la b">?</code>)完成的。然后我们追加<code class="fe kx ky kz la b">.output_value</code>来返回<code class="fe kx ky kz la b">output_value</code>键的值。结果将会是这样的:</p><pre class="lb lc ld le gt lf la lg lh aw li bi"><span id="14ec" class="lj lk iq la b gy ll lm l ln lo">[<br/>  [<br/>    "192.168.0.117",<br/>    "192.168.0.240",<br/>    "192.168.0.44"<br/>  ]<br/>]</span></pre><p id="5fcc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为JMESPath保留了JSON的原始格式，所以有两个嵌套列表，对象列表和ip地址列表。我们只想要一个ip地址列表，因此我们可以应用JMESPath<a class="ae kw" href="https://jmespath.org/tutorial.html#flatten-projections" rel="noopener ugc nofollow" target="_blank">flatten projection</a>来获得我们想要的输出。简单地把<code class="fe kx ky kz la b">[]</code>加到声明的末尾，就像这样:</p><pre class="lb lc ld le gt lf la lg lh aw li bi"><span id="9a22" class="lj lk iq la b gy ll lm l ln lo">- name: Create a list of mon ip addresses<br/>  set_fact:<br/>     mon_ips: "{{ stack_create | json_query(\"stack.<!-- -->outputs[?output_key == ‘ceph_mon_management_addresses’].output_value<strong class="la ir">[]</strong>\") }}"</span></pre><p id="de76" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">结果是我们想要的:</p><pre class="lb lc ld le gt lf la lg lh aw li bi"><span id="b5f9" class="lj lk iq la b gy ll lm l ln lo">[                                               <br/>  "192.168.0.117",                                    <br/>  "192.168.0.240",<br/>  "192.168.0.44"<br/>]</span></pre></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><p id="dc87" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">顺便说一下，如果我们想将所有ip地址放入一个列表中，我们可以使用JMESPath的OR ( <code class="fe kx ky kz la b">||</code>)操作符和<strong class="ka ir"> filter </strong>和<strong class="ka ir"> flatten projections </strong>来获得所有mon和osd ip地址的列表。</p><pre class="lb lc ld le gt lf la lg lh aw li bi"><span id="3f72" class="lj lk iq la b gy ll lm l ln lo">- name: Create a list of all ip addresses<br/>  set_fact:<br/>     mon_ips: "{{ stack_create | json_query(\"stack.<!-- -->outputs[?output_key == ‘ceph_mon_management_addresses’ <strong class="la ir">|| output_key ==’ceph_osd_management_addresses’</strong>].output_value[]<!-- -->\") }}"</span></pre><p id="ecb3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">结果是:</p><pre class="lb lc ld le gt lf la lg lh aw li bi"><span id="fb8d" class="lj lk iq la b gy ll lm l ln lo">[<br/>  "192.168.0.95",<br/>  "192.168.0.101",<br/>  "192.168.0.155",<br/>  "192.168.0.161",<br/>  "192.168.0.23",<br/>  "192.168.0.117",<br/>  "192.168.0.240",<br/>  "192.168.0.44"<br/>]</span></pre></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><p id="b64e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了在顶部生成清单文件，我们需要两个不同JSON对象中的所有mon名称和ip地址。我们可以在<code class="fe kx ky kz la b">ceph_mon_management_addresses</code>和<code class="fe kx ky kz la b">ceph_mon_server_name</code>上使用JMESPath或运算符以及过滤器投影，如下所示:</p><pre class="lb lc ld le gt lf la lg lh aw li bi"><span id="3d10" class="lj lk iq la b gy ll lm l ln lo">- name: Create a list of all ip addresses<br/>  set_fact:<br/>     mon_ips: "{{ stack_create | json_query(\"stack.<!-- -->outputs[?output_key == ‘ceph_mon_management_addresses’ <strong class="la ir">|| output_key == ‘ceph_mon_server_names’</strong>].output_value<!-- -->\") }}"</span></pre><p id="9da8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">结果是:</p><pre class="lb lc ld le gt lf la lg lh aw li bi"><span id="460c" class="lj lk iq la b gy ll lm l ln lo">[<br/>  [<br/>    "192.168.0.117",<br/>    "192.168.0.240",<br/>    "192.168.0.44"<br/>  ],<br/>  [<br/>    "ceph-mon-0",<br/>    "ceph-mon-1",<br/>    "ceph-mon-2"<br/>  ]<br/>]</span></pre><p id="0045" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">结果给出了我们需要的所有信息，但不幸的是，我们得到了一个列表的列表，如果不进行复杂的循环，我们就不能用它来完成一个模板。</p><p id="1a29" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们希望信息以下列格式返回:</p><pre class="lb lc ld le gt lf la lg lh aw li bi"><span id="0f86" class="lj lk iq la b gy ll lm l ln lo">{<br/>    "ceph-mon-0": "192.168.0.117",<br/>    "ceph-mon-1": "192.168.0.240",<br/>    "ceph-mon-2": "192.168.0.44"<br/>}</span></pre><p id="5ac1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这种格式下，我们可以使用一个简单的<a class="ae kw" href="https://jinja.palletsprojects.com/en/2.11.x/" rel="noopener ugc nofollow" target="_blank"> Jinja </a>模板来创建ceph-ansible所需的库存文件。<code class="fe kx ky kz la b">key</code>是主机名，<code class="fe kx ky kz la b">value</code>是ip地址:</p><pre class="lb lc ld le gt lf la lg lh aw li bi"><span id="879b" class="lj lk iq la b gy ll lm l ln lo">[mons]<br/>{% for key, value in mons.items() %}<br/>{{ key }} ansible_host={{ value }}<br/>{% endfor %}</span><span id="9b3b" class="lj lk iq la b gy lw lm l ln lo">[osds]<br/>{% for key, value in osds.items() %}<br/>{{ key }} ansible_host={{ value }}<br/>{% endfor %}</span></pre><p id="73e5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了完成这个任务，我们需要创建两个列表，一个是主机名列表，一个是ip地址列表，然后将这两个列表合并。组合两个列表以产生Jinja模板所需格式的最简单方法是使用<a class="ae kw" href="https://en.wikipedia.org/wiki/Convolution_(computer_science)" rel="noopener ugc nofollow" target="_blank"> zip(或zipper或Convolution </a>)函数。不幸的是，JMESPath没有<a class="ae kw" href="https://github.com/jmespath/jmespath.py/issues/152" rel="noopener ugc nofollow" target="_blank"> zip方法</a>，但是<a class="ae kw" href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_filters.html#zip-and-zip-longest-filters" rel="noopener ugc nofollow" target="_blank"> Ansible有</a>。</p><p id="e3fc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，让我们一起来看看。第一个可回答的任务将创建四个可回答的事实，包含列表<code class="fe kx ky kz la b">mon_ips</code>、<code class="fe kx ky kz la b">mon_name</code>、<code class="fe kx ky kz la b">osd_ips</code>和<code class="fe kx ky kz la b">osd_names</code>。然后，第二个可行任务将把<code class="fe kx ky kz la b">mon_names</code>和<code class="fe kx ky kz la b">osd_names</code>列表转换成字典，然后把<code class="fe kx ky kz la b">mon_ips</code>和<code class="fe kx ky kz la b">osd_ips</code>压缩成字典。</p><pre class="lb lc ld le gt lf la lg lh aw li bi"><span id="7a0b" class="lj lk iq la b gy ll lm l ln lo">- name: Set mon and osd facts<br/>  set_fact:<br/>     mon_ips: "{{ stack_create | json_query(\"stack.outputs[?output_key == 'ceph_mon_management_addresses'].output_value[]\") }}"<br/>     mon_names: "{{ stack_create | json_query(\"stack.outputs[?output_key == 'ceph_mon_server_names'].output_value[]\") }}"<br/>     osd_ips: "{{ stack_create | json_query(\"stack.outputs[?output_key == 'ceph_osd_management_addresses'].output_value[]\") }}"<br/>     osd_names: "{{ stack_create | json_query(\"stack.outputs[?output_key == 'ceph_osd_server_names'].output_value[]\") }}"<br/><br/>- name: Zip names and ips<br/>  set_fact:<br/>     mons: "{{ <strong class="la ir">dict</strong>(mon_names | <strong class="la ir">zip</strong>(mon_ips)) }}"<br/>     osds: "{{ <strong class="la ir">dict</strong>(osd_names | <strong class="la ir">zip</strong>(osd_ips)) }}"</span></pre><p id="3966" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe kx ky kz la b">mons</code>和<code class="fe kx ky kz la b">osds</code>变量将如下所示，并完全适合Jinja模板，以创建所需的ceph-ansible库存文件。</p><pre class="lb lc ld le gt lf la lg lh aw li bi"><span id="cb28" class="lj lk iq la b gy ll lm l ln lo">mons:<br/>{<br/>    "ceph-mon-0": "192.168.0.117",<br/>    "ceph-mon-1": "192.168.0.240",<br/>    "ceph-mon-2": "192.168.0.44"<br/>}</span><span id="856a" class="lj lk iq la b gy lw lm l ln lo">osds:<br/>{<br/>    "ceph-osd-0": "192.168.0.95",<br/>    "ceph-osd-1": "192.168.0.101",<br/>    "ceph-osd-2": "192.168.0.155",<br/>    "ceph-osd-3": "192.168.0.161",<br/>    "ceph-osd-4": "192.168.0.23"<br/>}</span></pre><p id="9955" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">希望这个例子有帮助。JSON在计算中无处不在，找到解析它的捷径对于简单易管理的代码至关重要。JMESPath是用于简单JSON解析的强大工具，我们可以用循环和复杂的Jinja模板获得相同的结果，但是我们有一些简短、简单和易于查看的东西。</p></div></div>    
</body>
</html>