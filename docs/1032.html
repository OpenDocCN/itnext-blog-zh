<html>
<head>
<title>Turn On Time-Travelling Engine For MobX</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为MobX打开时间旅行引擎</h1>
<blockquote>原文：<a href="https://itnext.io/turn-on-time-travelling-for-mobx-c3f267a46f10?source=collection_archive---------3-----------------------#2018-07-09">https://itnext.io/turn-on-time-travelling-for-mobx-c3f267a46f10?source=collection_archive---------3-----------------------#2018-07-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="f920" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">注:本文不是</em><a class="ae km" href="https://github.com/mobxjs/mobx-state-tree" rel="noopener ugc nofollow" target="_blank"><em class="kl">mobx-state-tree</em></a><em class="kl">用法指南。其实整篇文章与MST (mobx-state-tree) </em>无关</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div class="gh gi kn"><img src="../Images/d303106f5bfcb9488698a03c9b8e409a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1140/1*W6EuAuGl0N-MAE4X6o-QUw.gif"/></div></figure><h1 id="618e" class="kv kw iq bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated"><strong class="ak">前言</strong></h1><p id="633b" class="pw-post-body-paragraph jn jo iq jp b jq lt js jt ju lu jw jx jy lv ka kb kc lw ke kf kg lx ki kj kk ij bi translated">作为官方的状态模型构建库，MST提供了许多精彩的特性，如时间旅行、热重装和redux-devtools支持。但是MST的问题是它太固执己见了(官方网站已经提到了)，你必须接受一组值(就像redux一样)才能使用它们。</p><p id="dc20" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们快速看一下如何在MST中定义模型:</p><pre class="ko kp kq kr gt ly lz ma mb aw mc bi"><span id="a016" class="md kw iq lz b gy me mf l mg mh">import { types } from "mobx-state-tree"</span><span id="7944" class="md kw iq lz b gy mi mf l mg mh">const Todo = types.model("Todo", {<br/>    title: types.string,<br/>    done: false<br/>}).actions(self =&gt; ({<br/>    toggle() {<br/>        self.done = !self.done<br/>    }<br/>}))</span><span id="5768" class="md kw iq lz b gy mi mf l mg mh">const Store = types.model("Store", {<br/>    todos: types.array(Todo)<br/>})</span></pre><p id="48ac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">老实说，我第一次看到这段代码的时候，内心是拒绝的，太主观了。直观地说，我们使用MobX来定义一个应该如下所示的模型:</p><pre class="ko kp kq kr gt ly lz ma mb aw mc bi"><span id="c578" class="md kw iq lz b gy me mf l mg mh">import { observable, action } from 'mobx'<br/>class Todo {<br/>  title: string;<br/>  @observable done = false;</span><span id="f53b" class="md kw iq lz b gy mi mf l mg mh">  @action<br/>  toggle() {<br/>    this.done = !this.done;<br/>  }<br/>}</span><span id="fcf3" class="md kw iq lz b gy mi mf l mg mh">class Store {<br/>  todos: Todo[]<br/>}</span></pre><p id="65d9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">用基于类的方式定义模型，对开发者来说显然更直观纯粹，而MST的“主观”方式有些反直觉，对项目的可维护性并不友好(基于类的方式只要谁懂最基本的OOP都可以理解)。但相应的，MST提供的诸如时间旅行等能力确实很吸引人。有没有办法用通常的方式编写MobX，在MST中享受同样的特性？</p><p id="72df" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">相比MobX的多存储和基于类方法的动作这种序列化不友好的范式，Redux对时间旅行/动作回放的支持显然要容易得多(但对应的应用程序代码更繁琐)。但是只要我们解决了两个问题，MobX中的时间旅行/动作回放支持问题也就解决了:</p><p id="0b8f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">1.收集应用程序的所有商店并被动激活它们，当它们发生变化时手动序列化它们。完成存储-&gt;反应式存储收集-&gt;快照(json)过程。<br/> 2。识别收集的存储实例和各种变化(动作),并映射关系。完成快照的逆向过程(json) - &gt;基于类的存储。</p><p id="b09f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">针对这两个问题，<a class="ae km" href="https://github.com/mmlpxjs/mmlpx" rel="noopener ugc nofollow" target="_blank"> mmlpx </a>给出了相应的解决方案:</p><p id="a578" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">1.DI +反应容器+快照(收集存储并响应存储变化，生成序列化快照)<br/> 2。<a class="ae km" href="https://github.com/mmlpxjs/ts-plugin-mmlpx" rel="noopener ugc nofollow" target="_blank">ts-plugin-mm lpx</a>+hydrate(标识存储和活动，将序列化数据合并到有状态存储实例中)</p><p id="400d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们来看看<a class="ae km" href="https://github.com/mmlpxjs/mmlpx" rel="noopener ugc nofollow" target="_blank"> mmlpx </a>是如何给出这两种基于快照的解决方案的。</p><h1 id="b151" class="kv kw iq bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">快照需要的基本功能</h1><p id="8e1e" class="pw-post-body-paragraph jn jo iq jp b jq lt js jt ju lu jw jx jy lv ka kb kc lw ke kf kg lx ki kj kk ij bi translated">如上所述，为了在MobX下为应用程序状态提供快照功能，我们需要解决以下问题:</p><h2 id="2e4c" class="md kw iq bd kx mj mk dn lb ml mm dp lf jy mn mo lj kc mp mq ln kg mr ms lr mt bi translated">收集app的所有商店</h2><p id="1701" class="pw-post-body-paragraph jn jo iq jp b jq lt js jt ju lu jw jx jy lv ka kb kc lw ke kf kg lx ki kj kk ij bi translated">MobX本身与应用程序组织无关。它不限制应用程序如何组织状态存储，遵循单一存储(如redux)或多存储范例。但是，由于MobX本身是OOP，在实践中我们通常采用<a class="ae km" href="https://msdn.microsoft.com/en-us/library/hh848246.aspx" rel="noopener ugc nofollow" target="_blank"> MVVM </a>模式。行为准则定义了我们的领域模型和UI相关模型(如何区分两类模型可以参见MVVM相关文章或者<a class="ae km" href="https://mobx.js.org/best/store.html" rel="noopener ugc nofollow" target="_blank"> MobX官方最佳实践</a>，此处不再赘述)。这导致我们在使用MobX时，下意识地遵循多商店范式。那么如果我们想管理应用程序中的所有商店呢？</p><p id="18bc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在OOP世界观中，为了管理所有类的实例，我们自然需要一个集中的存储容器，这通常很容易被称为<a class="ae km" href="https://www.martinfowler.com/articles/injection.html" rel="noopener ugc nofollow" target="_blank"> IOC容器</a>。作为最常见的IOC实现类型，DI(依赖注入)是手工实例化MobX存储的一个很好的替代方法。对于DI，我们推荐商店的方式如下:</p><pre class="ko kp kq kr gt ly lz ma mb aw mc bi"><span id="b5e7" class="md kw iq lz b gy me mf l mg mh">import { inject } from 'mmlpx'<br/>import UserStore from './UserStore'</span><span id="5011" class="md kw iq lz b gy mi mf l mg mh">class AppViewModel {<br/>    @inject() userStore: UserStore<br/>    <br/>    loadUsers() {<br/>        this.userStore.loadUser()<br/>    }<br/>}</span></pre><p id="8731" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">之后，我们可以很容易地通过IOC容器中的依赖注入来实例化所有商店实例。这就解决了收集MobX中所有商店的问题。</p><p id="e97d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">更多DI用法看这里:<a class="ae km" href="https://github.com/mmlpxjs/mmlpx#di-system" rel="noopener ugc nofollow" target="_blank"> mmlpx di系统</a>。</p><h2 id="4da5" class="md kw iq bd kx mj mk dn lb ml mm dp lf jy mn mo lj kc mp mq ln kg mr ms lr mt bi translated">响应所有存储状态变化</h2><p id="e091" class="pw-post-body-paragraph jn jo iq jp b jq lt js jt ju lu jw jx jy lv ka kb kc lw ke kf kg lx ki kj kk ij bi translated">一旦拥有了所有的存储实例，下一步就是监听状态的变化。</p><p id="4295" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果在应用程序初始化之后，应用程序中的所有存储都被实例化了，那么监控应用程序中的变化就相对容易了。但通常在阿迪系统中，实例化是懒惰的，只有当一个存储被实际使用时才被实例化，然后初始化它的状态。这意味着从我们打开快照特性的那一刻起，IOC容器就应该被转换为reactive，从而允许为新添加的存储中定义的状态自动绑定侦听器。</p><p id="e8a9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我们可以通过<code class="fe mu mv mw lz b">onSnapshot</code>方法获取当前IOC容器当前收集的所有存储，然后基于MobX <code class="fe mu mv mw lz b">ObservableMap</code>构建一个新的容器，加载所有之前的存储，最后用<code class="fe mu mv mw lz b">reaction</code>做数据重定义和递归跟踪依赖关系，这样就可以响应容器(存储添加/移除)和存储状态变化。如果更改触发了反应，我们可以手动序列化应用程序快照的当前应用程序状态。</p><p id="bb2e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">具体实现可以看这里:<a class="ae km" href="https://github.com/mmlpxjs/mmlpx/blob/master/src/api/snapshot.ts#L155" rel="noopener ugc nofollow" target="_blank"> mmlpx onSnapshot </a></p><h1 id="6479" class="kv kw iq bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">从快照中唤醒应用程序</h1><p id="bbc3" class="pw-post-body-paragraph jn jo iq jp b jq lt js jt ju lu jw jx jy lv ka kb kc lw ke kf kg lx ki kj kk ij bi translated">通常，我们获取应用程序的快照数据，并使其持久化，以确保应用程序在下次进入时可以直接恢复到退出时的状态，或者我们需要实现一个常见的重做/撤消功能。</p><p id="1186" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这在Redux系统中相对容易实现，因为它是用普通对象定义的，并且是序列化友好的。但这并不意味着您不能在不友好的序列化MobX系统中从快照中唤醒应用程序。</p><p id="eed0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要成功从快照恢复，我们必须满足以下两个条件:</p><h2 id="9188" class="md kw iq bd kx mj mk dn lb ml mm dp lf jy mn mo lj kc mp mq ln kg mr ms lr mt bi translated"><strong class="ak">给每个商店添加一个唯一的标识符</strong></h2><p id="2c21" class="pw-post-body-paragraph jn jo iq jp b jq lt js jt ju lu jw jx jy lv ka kb kc lw ke kf kg lx ki kj kk ij bi translated">如果我们希望序列化后的快照数据成功地恢复到它自己的存储中，我们必须给每个存储一个惟一的标识符，以便IOC容器可以通过这个id将每个数据层与其原始存储相关联。</p><p id="f14c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在mmlpx方案下，我们可以用@Store和@ViewModel decorator标记应用程序的全局状态和局部状态，并赋予相应的模型类一个id:</p><pre class="ko kp kq kr gt ly lz ma mb aw mc bi"><span id="02b2" class="md kw iq lz b gy me mf l mg mh"><a class="ae km" href="http://twitter.com/Store" rel="noopener ugc nofollow" target="_blank">@Store</a>('UserStore')<br/>class UserStore {}</span></pre><p id="423f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是手动命名存储是愚蠢且容易出错的，您必须确保您的名称空间没有重叠(这正是redux所做的🙃).</p><p id="e25f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">幸好<a class="ae km" href="https://github.com/mmlpxjs/ts-plugin-mmlpx" rel="noopener ugc nofollow" target="_blank"> ts-plugin-mmlpx </a>救了我们。我们只需要这样定义商店:</p><pre class="ko kp kq kr gt ly lz ma mb aw mc bi"><span id="1cd0" class="md kw iq lz b gy me mf l mg mh">@Store<br/>class UserStore {}</span></pre><p id="499d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">插件运行后，它变成了:</p><pre class="ko kp kq kr gt ly lz ma mb aw mc bi"><span id="c9a1" class="md kw iq lz b gy me mf l mg mh">@Store('UserStore.ts/UserStore')<br/>class UserStore {}</span></pre><p id="f99f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">文件名+类名的组合通常可以确保存储名称空间的唯一性。关于插件使用的更多信息，请查看<a class="ae km" href="https://github.com/mmlpxjs/ts-plugin-mmlpx" rel="noopener ugc nofollow" target="_blank"> ts-plugin-mmlpx </a>项目主页。</p><h2 id="e207" class="md kw iq bd kx mj mk dn lb ml mm dp lf jy mn mo lj kc mp mq ln kg mr ms lr mt bi translated">hydration</h2><p id="9f6a" class="pw-post-body-paragraph jn jo iq jp b jq lt js jt ju lu jw jx jy lv ka kb kc lw ke kf kg lx ki kj kk ij bi translated">从序列化快照状态激活app的反应系统，从静态到动态的逆向过程非常类似于SSR中的<a class="ae km" href="https://ssr.vuejs.org/guide/hydration.html" rel="noopener ugc nofollow" target="_blank">水化</a>。事实上，这是在MobX中实现时间旅行最困难的一步。与受Flux启发的库(如redux和vuex)不同，MobX中的状态通常是基于类的充血模型定义的。在对模型进行脱水和重新填充之后，我们还必须确保那些不能被序列化的行为仍然被正确地定义到模型上下文中。重新绑定行为尚未完成，我们必须确保反序列化后数据的mobx定义也与原始定义一致。比如我用了一个特殊的修改器比如<code class="fe mu mv mw lz b">observable.ref</code>、<code class="fe mu mv mw lz b">observable.shallow</code>、<code class="fe mu mv mw lz b">ObservableMap</code>，重新填充后必须保持原来的能力。特别是对于不能连载的<code class="fe mu mv mw lz b">ObservableMap</code>，我们要想办法让他们恢复到原来的状态行为。</p><p id="69f3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">幸运的是，我们整个解决方案的基石是DI系统，当调用者请求获得依赖项时，它给了我们“动手”的可能性。我们所要做的就是当依赖项被获取时，识别依赖项是否是由序列化数据填充的，也就是说，存储在IOC容器中的实例不是原始类类型的实例。此时，水合作用开始，然后水合作用恢复。激活过程也非常简单，因为我们在<code class="fe mu mv mw lz b">inject</code>的上下文中有了store类类型(构造函数)，我们只需要重新初始化一个新的空白Store实例，并用序列化数据填充它。幸运的是，MobX只有三种数据类型，对象、数组和映射。我们只需要对不同类型的水合物进行简单处理即可完成:</p><pre class="ko kp kq kr gt ly lz ma mb aw mc bi"><span id="6d97" class="md kw iq lz b gy me mf l mg mh">if (!(instance instanceof Host)) {</span><span id="831c" class="md kw iq lz b gy mi mf l mg mh">const real: any = new Host(...args);</span><span id="62eb" class="md kw iq lz b gy mi mf l mg mh">    // awake the reactive system of the model<br/>    Object.keys(instance).forEach((key: string) =&gt; {<br/>        if (real[key] instanceof ObservableMap) {<br/>            const { name, enhancer } = real[key];<br/>            runInAction(() =&gt; real[key] = new ObservableMap((instance as any)[key], enhancer, name));<br/>        } else {<br/>            runInAction(() =&gt; real[key] = (instance as any)[key]);<br/>        }<br/>    });</span><span id="8d7c" class="md kw iq lz b gy mi mf l mg mh">return real as T;<br/>}</span></pre><p id="6094" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae km" href="https://github.com/mmlpxjs/mmlpx/blob/master/src/core/dependency-inject/hydrate.ts" rel="noopener ugc nofollow" target="_blank">这里的</a>是水合物的源代码。</p><h1 id="1aaf" class="kv kw iq bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">情节</h1><p id="e23c" class="pw-post-body-paragraph jn jo iq jp b jq lt js jt ju lu jw jx jy lv ka kb kc lw ke kf kg lx ki kj kk ij bi translated">与MST的快照功能(MST只能拍摄某个商店的快照，而不是整个应用程序的快照)相比，基于mmlpx的方法更容易实现快照派生的功能:</p><h2 id="623a" class="md kw iq bd kx mj mk dn lb ml mm dp lf jy mn mo lj kc mp mq ln kg mr ms lr mt bi translated">时间旅行</h2><p id="726b" class="pw-post-body-paragraph jn jo iq jp b jq lt js jt ju lu jw jx jy lv ka kb kc lw ke kf kg lx ki kj kk ij bi translated">时光旅行功能在实际开发中有两个应用场景，一个是重做/撤销，一个是redux-devtools提供的动作回放功能。</p><p id="1e4d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用mmlpx后，在MobX中重做/撤消实现非常容易。实际上你只需要<code class="fe mu mv mw lz b">onSnapshot</code>和<code class="fe mu mv mw lz b">applySnapshot</code>这两个API。文章开头的gif图片是<a class="ae km" href="https://github.com/mmlpxjs/mmlpx-todomvc" rel="noopener ugc nofollow" target="_blank">重做/撤销演示</a>，你可以查看<a class="ae km" href="https://github.com/mmlpxjs/mmlpx" rel="noopener ugc nofollow" target="_blank"> mmlpx项目主页</a>了解详情。</p><p id="20b1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">像redux-devtools这样的函数实现起来有点复杂(实际上很简单)，因为我们想要重放每个动作，我们应该为每个动作提供一个唯一的标识符。redux中的目标是通过手动编写具有不同名称空间的action _ types来实现的。这个太繁琐了。幸运的是，我们有<a class="ae km" href="https://github.com/mmlpxjs/ts-plugin-mmlpx" rel="noopener ugc nofollow" target="_blank"> ts-plugins-mmlpx </a>可以帮助我们自动命名动作(就像自动给商店命名一样)。解决了这个问题后，我们只需要在<code class="fe mu mv mw lz b">onSnapshot</code>工作的同时记录下每个动作，就可以方便地使用MobX中的redux-devtool功能了。</p><h2 id="55b5" class="md kw iq bd kx mj mk dn lb ml mm dp lf jy mn mo lj kc mp mq ln kg mr ms lr mt bi translated">苏维埃社会主义共和国</h2><p id="2a73" class="pw-post-body-paragraph jn jo iq jp b jq lt js jt ju lu jw jx jy lv ka kb kc lw ke kf kg lx ki kj kk ij bi translated">我们知道，当React或Vue进行SSR时，预取的数据通过在窗口上挂载全局变量传递给客户端，但通常官方的例子是基于Redux或Vuex的，如果我们想使用MobX代替，还有一些问题需要解决。现在，在mmlpx的帮助下，我们只需要在应用程序启动之前使用预取数据在客户端上应用快照:</p><pre class="ko kp kq kr gt ly lz ma mb aw mc bi"><span id="159e" class="md kw iq lz b gy me mf l mg mh">import { applySnapshot } from 'mmlpx'</span><span id="90a3" class="md kw iq lz b gy mi mf l mg mh">if (window.__PRELOADED_STATE__) {<br/>    applySnapshot(window.__PRELOADED_STATE__)<br/>}</span></pre><h2 id="0961" class="md kw iq bd kx mj mk dn lb ml mm dp lf jy mn mo lj kc mp mq ln kg mr ms lr mt bi translated">应用崩溃监控</h2><p id="b115" class="pw-post-body-paragraph jn jo iq jp b jq lt js jt ju lu jw jx jy lv ka kb kc lw ke kf kg lx ki kj kk ij bi translated">这个特性可以由每个可以快照应用程序状态并从中恢复的库提供。也就是说，当检测到应用崩溃时，按下快门然后将快照数据上传到云端，那么云平台就可以通过快照数据还原场景。如果我们上传的快照数据也包含用户之前的操作栈，那么就有可能在监控平台上回放用户操作。</p><h1 id="a673" class="kv kw iq bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">最后</h1><p id="5b0f" class="pw-post-body-paragraph jn jo iq jp b jq lt js jt ju lu jw jx jy lv ka kb kc lw ke kf kg lx ki kj kk ij bi translated">作为“多店”范式的信奉者，MobX在我心目中取代了redux在前端状态管理领域的地位。但由于MobX多店架构下的店铺缺乏集中管理，在时光旅行等一系列功能的开发经验上一直有所欠缺。现在有了<a class="ae km" href="https://github.com/mmlpxjs/mmlpx" rel="noopener ugc nofollow" target="_blank"> mmlpx </a>的帮助，MobX也可以开启时光旅行了，Redux在我心目中最后的优势也没有了。</p></div></div>    
</body>
</html>