<html>
<head>
<title>Rust and the JVM</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Rust和JVM</h1>
<blockquote>原文：<a href="https://itnext.io/rust-jvm-ab4de9f14eb6?source=collection_archive---------5-----------------------#2021-07-18">https://itnext.io/rust-jvm-ab4de9f14eb6?source=collection_archive---------5-----------------------#2021-07-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/994d1e55b19ae15a63046c0bce8d5be1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1140/format:webp/1*wW8ZJyysa_-bFEWm6AsjfA.png"/></div></figure><p id="f62b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">到目前为止，我们已经学习了Rust语法的基础知识，开发了一个自定义的Kubernetes控制器，并与Wasm的前端集成。</p><p id="c935" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这是开始锈焦点系列的第7篇文章。其他职位包括:</p><ul class=""><li id="71fa" class="ks kt iq jw b jx jy kb kc kf ku kj kv kn kw kr kx ky kz la bi translated"><a class="ae lb" href="https://blog.frankel.ch/start-rust/1/" rel="noopener ugc nofollow" target="_blank">我的第一杯铁锈</a></li><li id="595b" class="ks kt iq jw b jx lc kb ld kf le kj lf kn lg kr kx ky kz la bi translated"><a class="ae lb" href="https://blog.frankel.ch/start-rust/2/" rel="noopener ugc nofollow" target="_blank">我的第二杯铁锈</a></li><li id="8188" class="ks kt iq jw b jx lc kb ld kf le kj lf kn lg kr kx ky kz la bi translated"><a class="ae lb" href="https://blog.frankel.ch/start-rust/3/" rel="noopener ugc nofollow" target="_blank">沙沙声练习—第一部分</a></li><li id="6789" class="ks kt iq jw b jx lc kb ld kf le kj lf kn lg kr kx ky kz la bi translated"><a class="ae lb" href="https://blog.frankel.ch/start-rust/4/" rel="noopener ugc nofollow" target="_blank">生锈练习—第二部分</a></li><li id="264f" class="ks kt iq jw b jx lc kb ld kf le kj lf kn lg kr kx ky kz la bi translated"><a class="ae lb" href="https://blog.frankel.ch/start-rust/5/" rel="noopener ugc nofollow" target="_blank">前端生锈</a></li><li id="cb64" class="ks kt iq jw b jx lc kb ld kf le kj lf kn lg kr kx ky kz la bi translated"><a class="ae lb" href="https://blog.frankel.ch/start-rust/6/" rel="noopener ugc nofollow" target="_blank">用于Kubernetes的生锈控制器</a></li><li id="ffce" class="ks kt iq jw b jx lc kb ld kf le kj lf kn lg kr kx ky kz la bi translated"><em class="lh"> Rust和JVM(本帖)</em></li></ul><p id="8867" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我使用JVM已经二十年了，主要是在Java中。JVM是一项了不起的技术。IMHO，它最显著的好处是能够让原生代码适应当前的工作负载；如果工作负载发生变化，并且本机代码不是最佳的，它将相应地重新编译<em class="lh">字节码</em>。</p><p id="3670" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">另一方面，当不再需要对象时，JVM会自动从内存中释放它们。这个过程被称为<em class="lh">垃圾收集</em>。在没有GC的语言中，开发人员必须负责释放对象。对于遗留语言和大型代码库，发布并没有得到一致的应用，并且在产品中发现了错误。</p><p id="8006" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">虽然GC算法随着时间的推移已经有所改进，但是GC本身仍然是一个庞大复杂的机器。微调GC是复杂的，并且严重依赖于上下文。昨天行得通的今天可能行不通。总而言之，在您的环境中配置JVM来最好地处理GC就像变魔术一样。</p><p id="02ab" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">随着围绕JVM的生态系统得到很好的发展，使用JVM开发应用程序并将需要可预测性的部分委托给Rust是有意义的。</p><h1 id="ea8d" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">JVM-Rust集成的现有替代方案</h1><p id="1a7b" class="pw-post-body-paragraph ju jv iq jw b jx mg jz ka kb mh kd ke kf mi kh ki kj mj kl km kn mk kp kq kr ij bi translated">在这篇文章的研究过程中，我发现了几个JVM-Rust集成的方法:</p><ul class=""><li id="8217" class="ks kt iq jw b jx jy kb kc kf ku kj kv kn kw kr kx ky kz la bi translated">Asmble:</li></ul><blockquote class="ml mm mn"><p id="6bbc" class="ju jv lh jw b jx jy jz ka kb kc kd ke mo kg kh ki mp kk kl km mq ko kp kq kr ij bi translated">Asmble是一个将WebAssembly代码编译成JVM字节码的编译器。它还包含一个解释器和实用程序，用于从命令行和JVM语言处理WASM代码。</p><p id="8435" class="ju jv lh jw b jx jy jz ka kb kc kd ke mo kg kh ki mp kk kl km mq ko kp kq kr ij bi translated">—<a class="ae lb" href="https://github.com/cretz/asmble" rel="noopener ugc nofollow" target="_blank">https://github.com/cretz/asmble</a></p></blockquote><p id="649d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">Asmble是在MIT许可下发布的，但是没有被积极维护(最后一次提交是在2年前)。</p><ul class=""><li id="aa98" class="ks kt iq jw b jx jy kb kc kf ku kj kv kn kw kr kx ky kz la bi translated">GraalVM:</li></ul><blockquote class="ml mm mn"><p id="27f4" class="ju jv lh jw b jx jy jz ka kb kc kd ke mo kg kh ki mp kk kl km mq ko kp kq kr ij bi translated">GraalVM是一个高性能的JDK发行版，旨在加速用Java和其他JVM语言编写的应用程序的执行，并支持JavaScript、Ruby、Python和许多其他流行语言。GraalVM的多语言功能使得在一个应用程序中混合多种编程语言成为可能，同时消除了外语调用成本。</p><p id="2933" class="ju jv lh jw b jx jy jz ka kb kc kd ke mo kg kh ki mp kk kl km mq ko kp kq kr ij bi translated">——<a class="ae lb" href="https://www.graalvm.org/" rel="noopener ugc nofollow" target="_blank">https://www.graalvm.org/</a></p></blockquote><p id="284e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">GraalVM允许运行<a class="ae lb" href="https://llvm.org/" rel="noopener ugc nofollow" target="_blank"> LLVM位代码</a>。Rust可以编译成LLVM。因此，<a class="ae lb" href="https://www.graalvm.org/reference-manual/llvm/Compiling/" rel="noopener ugc nofollow" target="_blank"> GraalVM可以运行Rust生成的LLVM代码</a>以及Java/Scala/Kotlin/Groovy生成的<em class="lh">字节码</em>。</p><ul class=""><li id="ad79" class="ks kt iq jw b jx jy kb kc kf ku kj kv kn kw kr kx ky kz la bi translated">jni机箱:</li></ul><blockquote class="ml mm mn"><p id="e016" class="ju jv lh jw b jx jy jz ka kb kc kd ke mo kg kh ki mp kk kl km mq ko kp kq kr ij bi translated">这个机箱提供了一种(大部分)安全的方法来使用JNI在Java中实现方法。因为谁想<em class="iq">居然</em>写Java？</p><p id="e255" class="ju jv lh jw b jx jy jz ka kb kc kd ke mo kg kh ki mp kk kl km mq ko kp kq kr ij bi translated">—<a class="ae lb" href="https://docs.rs/jni/0.19.0/jni/" rel="noopener ugc nofollow" target="_blank">https://docs.rs/jni/0.19.0/jni/</a></p></blockquote><p id="1a91" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">过去，JNI一直是集成C/C++和Java的方式。虽然这不是最迷人的方法，但它不需要特定的平台，而且稳定。由于这个原因，我将在下一节中详细描述它。</p><h1 id="1673" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">通过JNI集成Java和Rust</h1><p id="8445" class="pw-post-body-paragraph ju jv iq jw b jx mg jz ka kb mh kd ke kf mi kh ki kj mj kl km kn mk kp kq kr ij bi translated">从鸟瞰图来看，集成Java和Rust需要以下步骤:</p><ol class=""><li id="8c8d" class="ks kt iq jw b jx jy kb kc kf ku kj kv kn kw kr mr ky kz la bi translated">用Java创建“框架”方法</li><li id="672a" class="ks kt iq jw b jx lc kb ld kf le kj lf kn lg kr mr ky kz la bi translated">从它们生成C头文件</li><li id="34c7" class="ks kt iq jw b jx lc kb ld kf le kj lf kn lg kr mr ky kz la bi translated">在Rust中实现它们</li><li id="91e3" class="ks kt iq jw b jx lc kb ld kf le kj lf kn lg kr mr ky kz la bi translated">编译Rust生成系统库</li><li id="05f1" class="ks kt iq jw b jx lc kb ld kf le kj lf kn lg kr mr ky kz la bi translated">从Java程序加载库</li><li id="b0c9" class="ks kt iq jw b jx lc kb ld kf le kj lf kn lg kr mr ky kz la bi translated">调用第一步中定义的方法。至此，库包含了实现，集成完成了。</li></ol><p id="52f2" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">老前辈们会意识到，当你需要与C或C++集成时，这些步骤是相同的。这是因为它们也能生成一个系统库。让我们详细看一下每个步骤。</p><h1 id="7033" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">Java框架方法</h1><p id="ca1e" class="pw-post-body-paragraph ju jv iq jw b jx mg jz ka kb mh kd ke kf mi kh ki kj mj kl km kn mk kp kq kr ij bi translated">我们首先需要创建Java框架方法。在Java中，我们知道方法需要有一个主体，除非它们是<code class="fe ms mt mu mv b">abstract</code>。或者，它们可以是<code class="fe ms mt mu mv b">native</code>:一个本地方法将其实现委托给一个库。</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="5222" class="ne lj iq mv b gy nf ng l nh ni">public native int doubleRust(int input);</span></pre><p id="fb9e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">接下来，我们需要生成相应的C头文件。为了自动化生成，我们可以利用Maven编译器插件:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="a359" class="ne lj iq mv b gy nf ng l nh ni">&lt;plugin&gt;<br/>    &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;<br/>    &lt;version&gt;3.8.1&lt;/version&gt;<br/>    &lt;configuration&gt;<br/>        &lt;compilerArgs&gt;<br/>            &lt;arg&gt;-h&lt;/arg&gt;                           &lt;!--1--&gt;<br/>            &lt;arg&gt;target/headers&lt;/arg&gt;               &lt;!--2--&gt;<br/>        &lt;/compilerArgs&gt;<br/>    &lt;/configuration&gt;<br/>&lt;/plugin&gt;</span></pre><ol class=""><li id="9a38" class="ks kt iq jw b jx jy kb kc kf ku kj kv kn kw kr mr ky kz la bi translated">生成头文件…</li><li id="2a46" class="ks kt iq jw b jx lc kb ld kf le kj lf kn lg kr mr ky kz la bi translated">…在这个位置</li></ol><p id="b6bb" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">上述Java代码片段生成的头应该如下所示:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="eebc" class="ne lj iq mv b gy nf ng l nh ni">#include </span><span id="c7ac" class="ne lj iq mv b gy nj ng l nh ni">#ifndef _Included_ch_frankel_blog_rust_Main<br/>#define _Included_ch_frankel_blog_rust_Main<br/>#ifdef __cplusplus<br/>extern "C" {<br/>#endif<br/>/*<br/> * Class:     ch_frankel_blog_rust_Main<br/> * Method:    doubleRust<br/> * Signature: (I)I<br/> */<br/>JNIEXPORT jint JNICALL Java_ch_frankel_blog_rust_Main_doubleRust<br/>  (JNIEnv *, jobject, jint);</span><span id="b34d" class="ne lj iq mv b gy nj ng l nh ni">#ifdef __cplusplus<br/>}<br/>#endif<br/>#endif</span></pre><h1 id="9505" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">Rust实现</h1><p id="94c6" class="pw-post-body-paragraph ju jv iq jw b jx mg jz ka kb mh kd ke kf mi kh ki kj mj kl km kn mk kp kq kr ij bi translated">现在，我们可以开始Rust实现了。让我们创建一个新项目:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="845c" class="ne lj iq mv b gy nf ng l nh ni">cargo new lib-rust</span><span id="777d" class="ne lj iq mv b gy nj ng l nh ni">[package]<br/>name = "dummymath"<br/>version = "0.1.0"<br/>authors = ["Nicolas Frankel "]<br/>edition = "2018"</span><span id="03f2" class="ne lj iq mv b gy nj ng l nh ni">[dependencies]<br/>jni = "0.19.0"                                     // 1</span><span id="a5c0" class="ne lj iq mv b gy nj ng l nh ni">[lib]<br/>crate_type = ["cdylib"]                            // 2</span></pre><ol class=""><li id="edf7" class="ks kt iq jw b jx jy kb kc kf ku kj kv kn kw kr mr ky kz la bi translated">使用<code class="fe ms mt mu mv b">jni</code>板条箱</li><li id="c4af" class="ks kt iq jw b jx lc kb ld kf le kj lf kn lg kr mr ky kz la bi translated">生成一个<em class="lh">系统</em>库。有几种板条箱类型可用:<code class="fe ms mt mu mv b">cdylib</code>用于动态系统库，可以从其他语言加载。您可以在文档中查看所有其他可用类型<a class="ae lb" href="https://doc.rust-lang.org/reference/linkage.html" rel="noopener ugc nofollow" target="_blank">。</a></li></ol><p id="ba81" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">以下是板条箱提供的API的节略:</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nl nm di nn bf no"><div class="gh gi nk"><img src="../Images/69eaeb23378c07a971d9097cbc4f22da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2kY6bH655w2Vg_PwpTRXUg.png"/></div></div></figure><p id="8846" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">API一对一地映射到生成的C代码。我们可以相应地使用它:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="a5b2" class="ne lj iq mv b gy nf ng l nh ni">#[no_mangle]<br/>pub extern "system" fn Java_ch_frankel_blog_rust_Main_doubleRust(_env: JNIEnv, _obj: JObject, x: jint) -&gt; jint {<br/>    x * 2<br/>}</span></pre><p id="4739" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">上面的代码中发生了很多事情。下面详细说一下。</p><ul class=""><li id="db0e" class="ks kt iq jw b jx jy kb kc kf ku kj kv kn kw kr kx ky kz la bi translated"><code class="fe ms mt mu mv b">no_mangle</code>宏告诉编译器在编译后的代码中保持相同的函数签名。这是至关重要的，因为JVM将使用这个签名。</li><li id="e3bd" class="ks kt iq jw b jx lc kb ld kf le kj lf kn lg kr kx ky kz la bi translated">大多数时候，我们在Rust函数中使用<code class="fe ms mt mu mv b">extern</code>来将实现委托给其他语言:这被称为FFI。这和我们在Java里用<code class="fe ms mt mu mv b">native</code>做的一样。不过Rust也用<code class="fe ms mt mu mv b">extern</code>反过来用<em class="lh">即</em>，让函数可以从其他语言调用。</li><li id="620a" class="ks kt iq jw b jx lc kb ld kf le kj lf kn lg kr kx ky kz la bi translated">签名本身应该精确地模仿C头文件中的代码，因此有了这个有趣的名字</li><li id="d498" class="ks kt iq jw b jx lc kb ld kf le kj lf kn lg kr kx ky kz la bi translated">最后，<code class="fe ms mt mu mv b">x</code>是一个<code class="fe ms mt mu mv b">jint</code>，是<code class="fe ms mt mu mv b">i32</code>的别名。</li></ul><p id="e589" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们现在可以构建项目了:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="de11" class="ne lj iq mv b gy nf ng l nh ni">cargo build</span></pre><p id="74e1" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">构建器产生一个依赖于系统库。比如在OSX上，神器有一个<code class="fe ms mt mu mv b">dylib</code>扩展名；在Linux上，它会有一个<code class="fe ms mt mu mv b">so</code>等。</p><h1 id="168c" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">使用Java端的库</h1><p id="bc77" class="pw-post-body-paragraph ju jv iq jw b jx mg jz ka kb mh kd ke kf mi kh ki kj mj kl km kn mk kp kq kr ij bi translated">最后一部分是在Java端使用生成的库。它需要首先加载它。为此，有两种方法可用，<code class="fe ms mt mu mv b">System.load(filename)</code>和<code class="fe ms mt mu mv b">System.loadLibrary(libname)</code>。</p><p id="4e4a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe ms mt mu mv b">load()</code>需要库的绝对路径，包括其扩展名，<em class="lh">如</em>，<code class="fe ms mt mu mv b">/path/to/lib.so</code>。对于需要跨系统工作的应用程序来说，这是不现实的。<code class="fe ms mt mu mv b">loadLibrary()</code>允许您只传递库的名称-不带扩展名。注意库被加载到由<code class="fe ms mt mu mv b">java.library.path</code>系统属性指示的位置。</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="a9c0" class="ne lj iq mv b gy nf ng l nh ni">public class Main {</span><span id="0899" class="ne lj iq mv b gy nj ng l nh ni">    static {<br/>        System.loadLibrary("dummymath");<br/>    }<br/>}</span></pre><p id="132c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">请注意，在Mac OS上，<code class="fe ms mt mu mv b">lib</code>前缀是<strong class="jw ir">而不是</strong>库名称的一部分。</p><h1 id="e060" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">使用对象</h1><p id="e6a0" class="pw-post-body-paragraph ju jv iq jw b jx mg jz ka kb mh kd ke kf mi kh ki kj mj kl km kn mk kp kq kr ij bi translated">上面的代码非常简单:它包含一个纯粹的函数，根据定义，这个函数只依赖于它的输入参数。假设我们想要更复杂一点的东西。我们想出了一个新方法，将参数与来自对象状态的另一个参数相乘:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="9032" class="ne lj iq mv b gy nf ng l nh ni">public class Main {</span><span id="d488" class="ne lj iq mv b gy nj ng l nh ni">    private int state;</span><span id="f97e" class="ne lj iq mv b gy nj ng l nh ni">    public Main(int state) {<br/>        this.state = state;<br/>    }</span><span id="9cb7" class="ne lj iq mv b gy nj ng l nh ni">    public static void main(String[] args) {<br/>        try {<br/>            var arg1 = Integer.parseInt(args[1]);<br/>            var arg2 = Integer.parseInt(args[2]);<br/>            var result = new Main(arg1).timesRust(arg2);                // 1<br/>            System.out.println(arg1 + "x" + arg2 + " = " + result);<br/>        } catch (NumberFormatException e) {<br/>            throw new IllegalArgumentException("Arguments must be ints");<br/>        }<br/>    }</span><span id="17aa" class="ne lj iq mv b gy nj ng l nh ni">    public native int timesRust(int input);<br/>}</span></pre><ol class=""><li id="7e0e" class="ks kt iq jw b jx jy kb kc kf ku kj kv kn kw kr mr ky kz la bi translated">应该计算<code class="fe ms mt mu mv b">arg1 * arg2</code></li></ol><p id="6219" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe ms mt mu mv b">native</code>方法看起来和上面完全一样，但是它的名字。因此，生成的C头看起来也是一样的。奇迹需要发生在生锈的一面。</p><p id="ab08" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在pure函数中，我们没有使用<code class="fe ms mt mu mv b">JNIEnv</code>和<code class="fe ms mt mu mv b">JObject</code>参数:<code class="fe ms mt mu mv b">JObject</code>代表Java对象，<em class="lh">即</em>、<code class="fe ms mt mu mv b">Main</code>和<code class="fe ms mt mu mv b">JNIEnv</code>允许访问其数据(或行为)。</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="e652" class="ne lj iq mv b gy nf ng l nh ni">#[no_mangle]<br/>pub extern "system" fn Java_ch_frankel_blog_rust_Main_timesRust(env: JNIEnv, obj: JObject, x: jint) -&gt; jint {                    // 1<br/>    let state = env.get_field(obj, "state", "I");            // 2<br/>    state.unwrap().i().unwrap() * x                         // 3<br/>}</span></pre><ol class=""><li id="a371" class="ks kt iq jw b jx jy kb kc kf ku kj kv kn kw kr mr ky kz la bi translated">同上</li><li id="140a" class="ks kt iq jw b jx lc kb ld kf le kj lf kn lg kr mr ky kz la bi translated">传递对象的引用、Java中的字段名及其类型。类型是指正确的<a class="ae lb" href="https://docs.oracle.com/en/java/javase/11/docs/specs/jni/types.html#type-signatures" rel="noopener ugc nofollow" target="_blank"> JVM类型签名</a>，<em class="lh">例如</em> <code class="fe ms mt mu mv b">"I"</code>对应<code class="fe ms mt mu mv b">int</code>。</li><li id="8997" class="ks kt iq jw b jx lc kb ld kf le kj lf kn lg kr mr ky kz la bi translated"><code class="fe ms mt mu mv b">state</code>是一个<code class="fe ms mt mu mv b">Result&lt;JValue&gt;</code>。我们需要将其解包到一个<code class="fe ms mt mu mv b">JValue</code>，然后通过<code class="fe ms mt mu mv b">i()</code>将其“造型”到一个<code class="fe ms mt mu mv b">Result&lt;jint&gt;</code></li></ol><h1 id="3a65" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">结论</h1><p id="bcf9" class="pw-post-body-paragraph ju jv iq jw b jx mg jz ka kb mh kd ke kf mi kh ki kj mj kl km kn mk kp kq kr ij bi translated">在这篇文章中，我们看到了如何从Java调用Rust。它包括标记要委托为<code class="fe ms mt mu mv b">native</code>的方法，生成C头文件，以及使用<code class="fe ms mt mu mv b">jni</code>箱。我们只是用简单的例子触及了表面:然而，我们已经为更复杂的用法铺平了道路。</p><p id="b320" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这篇文章的完整源代码可以在<a class="ae lb" href="https://github.com/ajavageek/rust-jvm" rel="noopener ugc nofollow" target="_blank"> Github </a>上找到。</p><p id="6dce" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">更进一步:</strong></p><ul class=""><li id="cb33" class="ks kt iq jw b jx jy kb kc kf ku kj kv kn kw kr kx ky kz la bi translated"><a class="ae lb" href="https://doc.rust-lang.org/reference/linkage.html" rel="noopener ugc nofollow" target="_blank">联动</a></li><li id="1a62" class="ks kt iq jw b jx lc kb ld kf le kj lf kn lg kr kx ky kz la bi translated"><a class="ae lb" href="https://doc.rust-lang.org/std/keyword.extern.html" rel="noopener ugc nofollow" target="_blank">关键字extern </a></li><li id="572e" class="ks kt iq jw b jx lc kb ld kf le kj lf kn lg kr kx ky kz la bi translated"><a class="ae lb" href="https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html#calling-rust-functions-from-other-languages" rel="noopener ugc nofollow" target="_blank">从其他语言调用Rust函数</a></li><li id="54cb" class="ks kt iq jw b jx lc kb ld kf le kj lf kn lg kr kx ky kz la bi translated"><a class="ae lb" href="https://docs.oracle.com/en/java/javase/11/docs/specs/jni/" rel="noopener ugc nofollow" target="_blank"> JNI规范</a></li></ul></div><div class="ab cl np nq hu nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="ij ik il im in"><p id="77fc" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><em class="lh">原载于</em> <a class="ae lb" href="https://blog.frankel.ch/start-rust/7/" rel="noopener ugc nofollow" target="_blank"> <em class="lh">一个Java极客</em></a><em class="lh">2021年7月18日</em></p></div></div>    
</body>
</html>