<html>
<head>
<title>Python-like list/array operator in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中类似Python的列表/数组操作符</h1>
<blockquote>原文：<a href="https://itnext.io/python-like-list-array-operator-in-javascript-1f17aea32ed2?source=collection_archive---------6-----------------------#2019-05-20">https://itnext.io/python-like-list-array-operator-in-javascript-1f17aea32ed2?source=collection_archive---------6-----------------------#2019-05-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/71bf0057112f585236c9971c3ed44ae7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EQRZp1Lu3eSeVGf_f3IVow.png"/></div></div></figure><p id="7123" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi kz translated">当在不同语言之间切换时，我经常发现自己编写的代码在一种技术中可以工作，但在另一种技术中却不是有效的语法。当我试图访问JavaScript中数组的最后一个元素时，这种情况经常发生。我经常尝试引用<code class="fe li lj lk ll b">-1</code>索引，这在Python中很好，但在JS中并不实用。因为数组是在JavaScript中实现的，所以当你试图访问它时，它甚至不会警告你。事实上，以下内容在JS中是完全合法的:</p><figure class="lm ln lo lp gt ju"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="739f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因为JavaScript array在内部的行为就像一个map，所以它并不关心索引是否是它所期望的——它只是为它创建一个map条目。有时这可能是有用的，但大多数情况下这是代码中有错误的迹象。</p><p id="48c2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这让我想到——有没有可能破解array <code class="fe li lj lk ll b">[]</code>操作符，使其行为类似于Python中的操作符(或者甚至更进一步，实现numpy数组的一些功能)。事实证明，利用代理人的力量是可能的！</p><h1 id="fef6" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">接受负指数的Getter</h1><p id="e4bd" class="pw-post-body-paragraph kb kc it kd b ke mq kg kh ki mr kk kl km ms ko kp kq mt ks kt ku mu kw kx ky im bi translated">让我们从允许JavaScript获取提供负索引的元素开始。我们可以通过使用代理类很容易地做到这一点。它是元编程的JavaScript机制——改变语言的行为，而不是在应用程序层面上使用它。我们可以用代理包装任何JavaScript对象(甚至函数),并拦截它的方法调用。</p><p id="12be" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们使用的第二个本地对象是<code class="fe li lj lk ll b">Reflect</code>，它是不同类型对象的getters和setters的简单外观。有了它，我们可以对不同类型的对象使用相同的代码(想想数组和ES6映射的通用API)。</p><figure class="lm ln lo lp gt ju"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="2031" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">代理接受两个参数——它扩展的目标对象和它覆盖的函数映射。在这个例子中，我们只通过提供一个自定义函数来覆盖getter。Getter有三个参数:</p><ul class=""><li id="bfcd" class="mw mx it kd b ke kf ki kj km my kq mz ku na ky nb nc nd ne bi translated"><code class="fe li lj lk ll b">target</code>这是一个原始阵列</li><li id="ae87" class="mw mx it kd b ke nf ki ng km nh kq ni ku nj ky nb nc nd ne bi translated"><code class="fe li lj lk ll b">prop</code>这是我们正在访问的属性(转换为字符串)</li><li id="ba5c" class="mw mx it kd b ke nf ki ng km nh kq ni ku nj ky nb nc nd ne bi translated">哪个是代理类的实例</li></ul><p id="f2a8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们分析一下代码:如果提供的属性小于0，我们通过将我们的值加到数组的长度上来计算正确的索引。如果是正数，我们就使用getter而不改变参数。(使用<code class="fe li lj lk ll b">Reflect.get</code>，在这种情况下相当于直接调用<code class="fe li lj lk ll b">target[prop]</code>)。</p><h1 id="6e23" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">接受范围</h1><p id="7cda" class="pw-post-body-paragraph kb kc it kd b ke mq kg kh ki mr kk kl km ms ko kp kq mt ks kt ku mu kw kx ky im bi translated">在numPy中，通过提供一个索引数组来一次访问多个元素是很常见的。如果JavaScript支持这一点，那就太酷了，不是吗？我们可以很容易地扩展我们的解决方案来为我们做这件事。</p><figure class="lm ln lo lp gt ju"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="dd28" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因为JavaScript自动将所有属性转换成字符串，所以数组<code class="fe li lj lk ll b">[1, -1]</code>将变成字符串<code class="fe li lj lk ll b">1,-1</code>。如果参数最初是一个数组，那么我们可以使用split进行逆向工程，如果是这样，我们可以单独调用每个元素的getter。</p><h1 id="283d" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">作曲者</h1><p id="4bd3" class="pw-post-body-paragraph kb kc it kd b ke mq kg kh ki mr kk kl km ms ko kp kq mt ks kt ku mu kw kx ky im bi translated">以类似于我们写getter函数的方式，我们可以扩展setter。这将允许我们通过简单地调用<code class="fe li lj lk ll b">l[-1] = 5</code>来设置最后一个元素。唯一的区别是<code class="fe li lj lk ll b">set</code>函数带有一个额外的参数，这是我们试图设置的值。</p><figure class="lm ln lo lp gt ju"><div class="bz fp l di"><div class="lq lr l"/></div></figure><h1 id="7203" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">范围设置器</h1><p id="188d" class="pw-post-body-paragraph kb kc it kd b ke mq kg kh ki mr kk kl km ms ko kp kq mt ks kt ku mu kw kx ky im bi translated">我们可以更进一步，接受一组指数——就像numPy一样。然后我们可以一次为多个指标设置值:<code class="fe li lj lk ll b">l[[1, -1]] = 5</code>。请注意，我们可以组合我们的解决方案——我们也可以提供范围内的负指数。</p><figure class="lm ln lo lp gt ju"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="7f52" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">类似于我们在getter中所做的，我们检查我们的<code class="fe li lj lk ll b">prop</code>是否包含分号，如果是，我们为每个单独的元素调用getter。<code class="fe li lj lk ll b">reciever[p] = value</code>用新的<code class="fe li lj lk ll b">props</code>属性递归调用我们的setter函数。</p><h1 id="648c" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">具有析构的范围的设置器</h1><p id="c52e" class="pw-post-body-paragraph kb kc it kd b ke mq kg kh ki mr kk kl km ms ko kp kq mt ks kt ku mu kw kx ky im bi translated">前面的例子运行得很好，但是如果我们输入<code class="fe li lj lk ll b">l[[0, -1]] = [5, 6];</code>会发生什么呢？如果您一直在使用numPy，那么您应该将5赋给第一个元素，将6赋给最后一个元素。在我们的代码中，它将嵌套这些数组:</p><figure class="lm ln lo lp gt ju"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="a69f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以通过检查我们的<code class="fe li lj lk ll b">values</code>属性是否是一个数组来容易地修复它，如果是，在我们的<code class="fe li lj lk ll b">forEach</code>中使用数组的元素而不是数组本身:</p><figure class="lm ln lo lp gt ju"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="aa77" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在我们可以做出这样的东西:</p><figure class="lm ln lo lp gt ju"><div class="bz fp l di"><div class="lq lr l"/></div></figure><h1 id="e37e" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">编后记</h1><p id="603f" class="pw-post-body-paragraph kb kc it kd b ke mq kg kh ki mr kk kl km ms ko kp kq mt ks kt ku mu kw kx ky im bi translated">代理还可以用于各种其他情况。您可以使用它们来调试您的对象、模拟无限集合、验证数据、自动修复用户输入。你必须记住，权力越大，责任越大——当你改变底层实现时，你可能会面临许多事情以不可预知的方式中断的风险——尤其是当你试图扩展本机对象时(这在JavaScript中很容易做到)。这就是为什么我们不直接修改<code class="fe li lj lk ll b">Array.prototype</code>而是允许用户显式创建新的<code class="fe li lj lk ll b">List</code>实例的原因之一。</p></div></div>    
</body>
</html>