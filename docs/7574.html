<html>
<head>
<title>Kubernetes Tips | Exposing information about Pods</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes提示|暴露关于豆荚的信息</h1>
<blockquote>原文：<a href="https://itnext.io/kubernetes-tips-exposing-information-about-pods-9e7cf45d8a9a?source=collection_archive---------1-----------------------#2022-11-11">https://itnext.io/kubernetes-tips-exposing-information-about-pods-9e7cf45d8a9a?source=collection_archive---------1-----------------------#2022-11-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/d8100e3fe169f140dcfd69abd050c981.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6HtxSH_ULwguHGYnGWWD4g.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://cncf-branding.netlify.app/projects/kubernetes/" rel="noopener ugc nofollow" target="_blank">https://cncf-branding.netlify.app/projects/kubernetes/</a></figcaption></figure><p id="630c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你是否曾经需要从当前正在运行的pod中获取信息，并在你的应用程序中使用这些信息？也许你需要获得你的应用程序运行所在的pod的名称，或者你想使用从<a class="ae kc" href="https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/" rel="noopener ugc nofollow" target="_blank">变异webhook </a>创建的某个标签，让你的应用程序做出关于将请求路由到哪里的某些决定。</p><p id="0219" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">幸运的是，通过使用来自<a class="ae kc" href="https://kubernetes.io/docs/concepts/workloads/pods/downward-api/" rel="noopener ugc nofollow" target="_blank">向下API </a>和向下API量的Pod字段，这非常简单。使用向下API，我们能够将当前正在运行的Pod的Pod级字段信息作为环境变量或文件直接暴露给容器。</p><p id="78da" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这篇文章中，我们不会深入探讨向下的API，但是我们将通过一个例子来演示如何将pod信息作为环境变量公开，以及如何将信息作为文件公开。</p><p id="38f7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">对于我们的K8s环境，我们将使用</em> <a class="ae kc" href="https://kind.sigs.k8s.io/" rel="noopener ugc nofollow" target="_blank"> <em class="lb">类</em> </a> <em class="lb">。有关KiND入门的更多信息，请参见文档。这是我比较喜欢的本土开发K8s。</em></p></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><h2 id="e371" class="lj lk iq bd ll lm ln dn lo lp lq dp lr ko ls lt lu ks lv lw lx kw ly lz ma mb bi translated">作为环境变量公开</h2><p id="532d" class="pw-post-body-paragraph kd ke iq kf b kg mc ki kj kk md km kn ko me kq kr ks mf ku kv kw mg ky kz la ij bi translated">如果您以前曾经在pod中的容器中暴露过环境变量，那么这应该不是什么新鲜事。为了将Pod级别的字段作为环境变量公开，我们采用的方式与我们习惯于为硬编码的环境变量、配置映射或机密所采用的方式相同。这种情况下唯一的区别是我们需要在<a class="ae kc" href="https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/pod-v1/#Pod" rel="noopener ugc nofollow" target="_blank"> Pod </a>或<a class="ae kc" href="https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/pod-v1/#PodSpec" rel="noopener ugc nofollow" target="_blank"> PodSpec </a> API中定义字段的<em class="lb"> fieldRef </em>和<em class="lb"> fieldValue </em>。</p><p id="ec0f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">示例:</p><pre class="mh mi mj mk gt ml mm mn bn mo mp bi"><span id="20b3" class="mq lk iq mm b be mr ms l mt mu">apiVersion: v1<br/>kind: Pod<br/>metadata:<br/>  name: env-var-example<br/>  labels:<br/>    envrionment: test<br/>    zone: us-east-1a<br/>    app: env-var-test<br/>spec:<br/>  containers:<br/>    - name: env-test<br/>      image: python<br/>      command: [ "python", "-c"]<br/>      args:<br/>      - "import os; print(os.environ['LABEL_NAME'], os.environ['POD_NAME'], os.environ['POD_IP'])"<br/>      env:<br/>        - name: LABEL_NAME<br/>          valueFrom:<br/>            fieldRef:<br/>              fieldPath: metadata.labels['zone']<br/>        - name: POD_NAME<br/>          valueFrom:<br/>            fieldRef:<br/>              fieldPath: metadata.name<br/>        - name: POD_IP<br/>          valueFrom:<br/>            fieldRef:<br/>              fieldPath: status.podIP</span></pre><p id="77dc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的示例中，我们向容器公开了关于Pod的以下内容:</p><ul class=""><li id="5951" class="mv mw iq kf b kg kh kk kl ko mx ks my kw mz la na nb nc nd bi translated"><strong class="kf ir">标签名称</strong> —标签区域的值。作为一个例子，这可能是从变异的webhook注入的东西。</li><li id="9f91" class="mv mw iq kf b kg ne kk nf ko ng ks nh kw ni la na nb nc nd bi translated"><strong class="kf ir"> POD_NAME </strong> —我们给POD起的名字。这里我们静态地定义了它，因为我们使用了Pod资源种类。但是，如果我们需要来自作为部署资源一部分的Pod的信息，名称将会自动生成，并且我们在发布之前不会知道。</li><li id="8a7a" class="mv mw iq kf b kg ne kk nf ko ng ks nh kw ni la na nb nc nd bi translated"><strong class="kf ir">POD _ IP—</strong>POD的IP。在这里，我们演示了甚至可以获取Pod的状态信息并公开它。</li></ul><p id="a5f0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面你可以看到环境变量是由Python打印的。</p><pre class="mh mi mj mk gt ml mm mn bn mo mp bi"><span id="bd2a" class="mq lk iq mm b be mr ms l mt mu">&gt; kubectl logs -f env-var-example<br/>us-east-1a env-var-example 10.244.0.25</span></pre><p id="9046" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">自己试试上面的，看看还有哪些领域可以曝光。所有可用字段参见<a class="ae kc" href="https://kubernetes.io/docs/concepts/workloads/pods/downward-api/#available-fields" rel="noopener ugc nofollow" target="_blank">官方文件</a>。</p><p id="655d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">还要注意</strong>，我们不会在这里展示相同的过程，你也可以使用向下API将容器字段公开为环境变量。见<a class="ae kc" href="https://kubernetes.io/docs/tasks/inject-data-application/environment-variable-expose-pod-information/#use-container-fields-as-values-for-environment-variables" rel="noopener ugc nofollow" target="_blank">官方K8s文档</a>上的教程。</p><h1 id="8ae8" class="nj lk iq bd ll nk nl nm lo nn no np lr nq nr ns lu nt nu nv lx nw nx ny ma nz bi translated">作为文件公开</h1><p id="bfb1" class="pw-post-body-paragraph kd ke iq kf b kg mc ki kj kk md km kn ko me kq kr ks mf ku kv kw mg ky kz la ij bi translated">现在我们将展示一个如何使用向下API volume公开Pod字段的示例。这将获取Pod级别的字段，然后将它们公开为容器中的一个文件。如果您曾经将pod中的配置图或秘密作为卷公开过，这看起来应该也很熟悉。这里的主要区别是我们在卷资源中定义了向下API。请参见下面的示例。</p><p id="fce8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">示例:</p><pre class="mh mi mj mk gt ml mm mn bn mo mp bi"><span id="7d66" class="mq lk iq mm b be mr ms l mt mu">apiVersion: v1<br/>kind: Pod<br/>metadata:<br/>  name: file-example<br/>  labels:<br/>    envrionment: test<br/>    zone: us-east-1a<br/>    app: file-test<br/>spec:<br/>  containers:<br/>    - name: file-test<br/>      image: python<br/>      command: [ "python", "-c"]<br/>      args:<br/>      - "import time; f = open(‘/etc/labelinfo/labels.txt’, ‘r’); content = f.read(); print(content); f.close(); time.sleep(5)"<br/>      volumeMounts:<br/>        - name: labelinfo<br/>          mountPath: /etc/labelinfo<br/>  volumes:<br/>    - name: labelinfo<br/>      downwardAPI:<br/>        items:<br/>          - path: "labels.txt"<br/>            fieldRef:<br/>              fieldPath: metadata.labels</span></pre><p id="eaae" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在示例中，我们使用downwardAPI创建了一个名为<em class="lb"> labelinfo </em>的卷，并从我们的pod中为我们的<em class="lb"> fieldRef </em>和<em class="lb"> fieldPath选择标签。</em>然后我们使用<em class="lb"> labels.txt </em>的路径，它告诉Kubernetes我们将调用文件名labels.txt。在我们的容器中，我们将指向卷<em class="lb"> labelinfo的<em class="lb"> volumeMount </em>赋值。</em>然后我们将<em class="lb"> labels.txt </em>挂载到<em class="lb">volume mount中指定的</em>挂载路径下。</p><p id="7c2d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面资源的app用Python读取<em class="lb"> "labels.txt" </em>文件。下面是日志的输出:</p><pre class="mh mi mj mk gt ml mm mn bn mo mp bi"><span id="d0d0" class="mq lk iq mm b be mr ms l mt mu">&gt; kubectl logs -f file-example<br/>app="file-test"<br/>envrionment="test"<br/>zone="us-east-1a"</span></pre><p id="1e34" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以在这里看到，Python成功地打印了Pod资源中的所有标签，并将它们放在一个文件中，供我们在应用程序中使用。这不是一个真实世界的应用程序，但你可以看到这是多么简单，可以纳入您的用例。</p><p id="223d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">注意:</strong>和上面的环境变量例子一样，使用这个方法也支持获取容器字段并将它们存储为文件。例如参见<a class="ae kc" href="https://kubernetes.io/docs/tasks/inject-data-application/downward-api-volume-expose-pod-information/#store-container-fields" rel="noopener ugc nofollow" target="_blank">正式文件</a>。</p></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><p id="3d21" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面你可以看到向你的应用程序展示Pod信息是多么简单。这些年来，有好几次这两种方式都帮助我获得了我需要的信息。希望你喜欢它！</p></div></div>    
</body>
</html>