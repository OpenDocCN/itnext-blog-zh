<html>
<head>
<title>TypeScript + Serverless + Webpack + Babel</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript +无服务器+ Webpack + Babel</h1>
<blockquote>原文：<a href="https://itnext.io/typescript-serverless-webpack-babel-15778188c7?source=collection_archive---------2-----------------------#2019-03-07">https://itnext.io/typescript-serverless-webpack-babel-15778188c7?source=collection_archive---------2-----------------------#2019-03-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="b025" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">随着TypeScript的兴起，我们决定将我们的代码从JS + Flow转移到TypeScript。使用Flow，我们发现了严格类型化的许多好处，它帮助我们在错误出现之前就将其消除，另外，围绕ts的工具也在快速发展(VSCode + ts是一种惊人的体验)，所以现在似乎是拥抱TS的正确时机。</p><p id="21b0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">基本上，你可以将这个旅程分为两个部分，第一部分你重写你的代码到TypeScript，这并不痛苦，因为我们已经在Flow上有一段时间了，Flow非常像TypeScript，所以这只是花费时间修复语法错误和类型错误<code class="fe kl km kn ko b">tsc</code>不喜欢的问题。第二部分是用TypeScript配置其他cogs播放流畅，这是能让公子哥砸键盘的部分。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi kp"><img src="../Images/fb337d52c921dd76009b9139ac145f8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*nviGMyw1WuYk4rB0RsdZEg.gif"/></div></figure><p id="82f4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们使用无服务器框架来管理我们的lambda函数，并使用<a class="ae kx" href="https://www.npmjs.com/package/serverless-webpack" rel="noopener ugc nofollow" target="_blank">server less-web pack</a>+Babel将TS代码转换为Lambda runtime (NodeJS 8.10)满意的JS代码。</p><pre class="kq kr ks kt gt ky ko kz la aw lb bi"><span id="2080" class="lc ld iq ko b gy le lf l lg lh">#Part of serverless.yml</span><span id="f65e" class="lc ld iq ko b gy li lf l lg lh">custom:<br/>  webpack:<br/>    webpackConfig: webpack.config.js<br/>    packager: 'yarn'</span></pre><p id="b8bb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">网络包.配置. js</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="lj lk l"/></div></figure><p id="dbe4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可以看到我们用<code class="fe kl km kn ko b">babel-loader</code>而不是<code class="fe kl km kn ko b">ts-loader</code>，没有特别的原因，但是你需要在巴别塔7上有<code class="fe kl km kn ko b">@babel/preset-env</code>和<code class="fe kl km kn ko b">@babel/typescript</code>。如果你决定使用<code class="fe kl km kn ko b">ts-loader</code>，确保你有<strong class="jp ir"> transpileOnly: true，</strong>这将让<code class="fe kl km kn ko b">ts-loader</code>做transpile工作，而不是类型检查，通常类型检查过程应该是你的CI测试任务的一部分，这里它应该只处理transpile to JS和push to Lambda。</p><p id="12a2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于<code class="fe kl km kn ko b">@babel/preset-env</code>，targets被设置为<strong class="jp ir"> node: true，</strong>因为transpiled JS代码是针对Lambda NodeJS运行时的，不需要担心所有不同的浏览器，这有多好！</p><p id="6ef9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">还有一点需要注意的是，<strong class="jp ir"> output.filename </strong>需要是<strong class="jp ir"> [name】。js </strong>，这将把传输的js代码命名为与源TS代码相同的名称，这是因为在您的serverless.yml中，您可能有类似</p><pre class="kq kr ks kt gt ky ko kz la aw lb bi"><span id="df4b" class="lc ld iq ko b gy le lf l lg lh">functions:<br/>  your-function:<br/>    handler: my/lambda/functions/in-ts/hello.world<br/>....</span></pre><p id="aebb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这告诉离线模拟器这个函数位于<strong class="jp ir">my/lambda/functions/in-ts</strong>，文件名是hello.js，如果webpack配置成输出文件到【name】-bundle . js，那么你应该把它改成<strong class="jp ir">my/lambda/functions/in-ts/hello-bundle . world .</strong></p><p id="5751" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如上所述，Babel不会验证你的类型，它只是去掉所有的类型脚本，把它变成你想要的任何JS，因此它比<code class="fe kl km kn ko b">tsc</code>更快。但是你确实需要在Babel开始之前验证输入，所以用<code class="fe kl km kn ko b">tsconfig.js</code>和运行<strong class="jp ir"> tsc </strong>你得到检查。在您的<code class="fe kl km kn ko b">tsconfig.json</code>中，确保您有<strong class="jp ir">“no emit”:true</strong>，这将告诉tsc不要传输，因为我们有<code class="fe kl km kn ko b">babel-node</code>做这项工作。</p><p id="a9f4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后但同样重要的是，不要被迷惑。<strong class="jp ir"> babelrc </strong>和<strong class="jp ir"> tsconfig.json </strong>，Babel看着。babelrc和不关心tsconfig.json，<strong class="jp ir"> tsc </strong>只看tsconfig.json和不关心. babelrc。</p><p id="3eb2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如我在开始时所说的，围绕TypeScript的工具进展很快，今天工作的东西明天可能会改变，所以如果事情不工作，不要砸你的键盘，只是要有耐心，不断尝试。</p></div></div>    
</body>
</html>