<html>
<head>
<title>On-premises HA Kubernetes cluster</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">内部HA Kubernetes集群</h1>
<blockquote>原文：<a href="https://itnext.io/on-premise-ha-kubernetes-cluster-15e41f18bd12?source=collection_archive---------2-----------------------#2019-10-13">https://itnext.io/on-premise-ha-kubernetes-cluster-15e41f18bd12?source=collection_archive---------2-----------------------#2019-10-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="6a1b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在建立生产Kubernetes集群时克服基础设施限制</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/64fc52b0d876a7b80bcaceb48361217d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vUeqU0mqLlBlBS1ZSGtwEQ.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">瑞安·帕克在<a class="ae kv" href="https://unsplash.com/search/photos/storage?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="c6a2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls">考虑到配置的便利性、网络和成本，我们进行了彻底的搜索，选择了一家托管提供商，并按照我们想要的方式设置了许多专用服务器。</em></p><p id="b4d9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">出于演示目的，我假设我们有<strong class="ky ir"> 9 </strong>台专用服务器。</p><p id="e405" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是我的另一篇文章的后续。</p><div class="lt lu gp gr lv lw"><a href="https://medium.com/@anisinanaj/kubernetes-on-premise-8ceffa48fee5" rel="noopener follow" target="_blank"><div class="lx ab fo"><div class="ly ab lz cl cj ma"><h2 class="bd ir gy z fp mb fr fs mc fu fw ip bi translated">在内部配置Kubernetes</h2><div class="md l"><h3 class="bd b gy z fp mb fr fs mc fu fw dk translated">概述在你自己的服务器上设置Kubernetes，分析这种方法的问题以及如何克服…</h3></div><div class="me l"><p class="bd b dl z fp mb fr fs mc fu fw dk translated">medium.com</p></div></div><div class="mf l"><div class="mg l mh mi mj mf mk kp lw"/></div></div></a></div></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="05a4" class="ms mt iq bd mu mv mw mx my mz na nb nc jw nd jx ne jz nf ka ng kc nh kd ni nj bi translated">高可用性</h1><p id="7f67" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated">那么为什么是9台服务器呢？到目前为止，我们可以把构成星团的部分分成3个部分。我们有<em class="ls">存储</em>、<em class="ls">控制平面</em>和<em class="ls">工作者</em>节点。</p><h1 id="3a77" class="ms mt iq bd mu mv np mx my mz nq nb nc jw nr jx ne jz ns ka ng kc nt kd ni nj bi translated">工作节点</h1><p id="797e" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated">毫无疑问，工作者节点需要不止一个，否则使用Kubernetes就没有意义。所以我们选择3，因为我们需要保证多数法则<em class="ls">一半加二分之一</em>。</p><p id="fdd8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设我们正在部署一个应用程序，我们需要它高度可用。我们复制它两次。但是，如果一个拷贝由于某种原因出现故障，我们就不再处于高可用性环境中了。因此，为了保证这种情况，我们需要3个副本，因此，如果这3个副本中的任何一个因未知原因而失败，我们都不必担心，而是可以专注于对失败的副本进行故障排除。</p><p id="d97c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">服务器也是如此。如果一台服务器出现故障或者我们需要进入维护模式，我们可以关闭一台服务器，而不用担心我们的生产应用程序。</p><h1 id="1574" class="ms mt iq bd mu mv np mx my mz nq nb nc jw nr jx ne jz ns ka ng kc nt kd ni nj bi translated">制导机</h1><p id="9327" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated">在我的上一篇文章中，我用单节点控制平面设置了集群。为了理解与该设计相关的问题，我们先来看看控制平面是如何工作的。</p><p id="38f9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它由一个键-值数据库组成，其中存储了所有配置和部署指令，即<code class="fe nu nv nw nx b">etcd.</code>然后是<code class="fe nu nv nw nx b">controller manager</code>，它确保集群的状态与<code class="fe nu nv nw nx b">etcd.</code>中的配置相匹配。<code class="fe nu nv nw nx b">scheduler</code>决定资源(即pod)去往哪个节点。最后，<code class="fe nu nv nw nx b">api server</code>为集群管理和节点间的通信公开了一个REST API。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ny"><img src="../Images/c1f6b178b9dc93fde3f19c64152634d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zKucz6ldz_zXgLuM7LaBmQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">控制平面架构</figcaption></figure><p id="f1c9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上述所有组件都被设计为可扩展的。最重要的组件是数据库。<strong class="ky ir">如果失败，我们将失去所有关于部署和其他资源的配置</strong>因此Kubernetes不能保证所有应用程序都可用。因为ETCD是一个内存数据库，它依赖于服务器。如果服务器出现故障，数据库就会丢失。</p><blockquote class="nz oa ob"><p id="2d6c" class="kw kx ls ky b kz la jr lb lc ld ju le oc lg lh li od lk ll lm oe lo lp lq lr ij bi translated">因此，我们需要确保，如果一台服务器出现故障，我们仍然可以正常运行。我们需要将控制平面置于高可用性状态。这就是为什么我们需要3台服务器。</p></blockquote><p id="5130" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然这种方法有些复杂，但是首先让我们看看如何配置它。</p><h2 id="c51e" class="of mt iq bd mu og oh dn my oi oj dp nc lf ok ol ne lj om on ng ln oo op ni oq bi translated">控制平面设置</h2><p id="a887" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated">我将我的服务器称为<em class="ls"> kube-cp-1 </em>、<em class="ls"> kube-cp-2 </em>、<em class="ls"> kube-cp-3 </em>，我将假设我的服务器分别有以下主机名<em class="ls">kube-cp-1.com、kube-cp-2.com、kube-cp-3.com</em></p><p id="9bb0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">根据文档，我将ssh到每个服务器，并按照我以前的文章中描述的那样设置它们，稍加修改，Kubernetes现在支持docker的最新版本。</p><pre class="kg kh ki kj gt or nx os ot aw ou bi"><span id="f791" class="of mt iq nx b gy ov ow l ox oy">sudo apt-get install \<br/>    apt-transport-https \<br/>    ca-certificates \<br/>    curl \<br/>    gnupg2 \<br/>    software-properties-common</span><span id="dec7" class="of mt iq nx b gy oz ow l ox oy">curl -fsSL <a class="ae kv" href="https://download.docker.com/linux/debian/gpg" rel="noopener ugc nofollow" target="_blank">https://download.docker.com/linux/debian/gpg</a> | sudo apt-key add -</span><span id="b39f" class="of mt iq nx b gy oz ow l ox oy">sudo apt-key fingerprint 0EBFCD88</span><span id="9c42" class="of mt iq nx b gy oz ow l ox oy">sudo add-apt-repository \<br/>   "deb [arch=amd64] <a class="ae kv" href="https://download.docker.com/linux/debian" rel="noopener ugc nofollow" target="_blank">https://download.docker.com/linux/debian</a> \<br/>   $(lsb_release -cs) \<br/>   stable"</span><span id="6c77" class="of mt iq nx b gy oz ow l ox oy">apt-get update<br/>apt-get install docker-ce</span></pre><p id="1620" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此时，我们可以安装Kubernetes包。</p><pre class="kg kh ki kj gt or nx os ot aw ou bi"><span id="3a35" class="of mt iq nx b gy ov ow l ox oy">apt-get update &amp;&amp; apt-get install -y apt-transport-https curl</span><span id="a114" class="of mt iq nx b gy oz ow l ox oy">curl -s <a class="ae kv" href="https://packages.cloud.google.com/apt/doc/apt-key.gpg" rel="noopener ugc nofollow" target="_blank">https://packages.cloud.google.com/apt/doc/apt-key.gpg</a> | apt-key add -</span><span id="f594" class="of mt iq nx b gy oz ow l ox oy">cat &lt;&lt;EOF &gt;/etc/apt/sources.list.d/kubernetes.list<br/>deb <a class="ae kv" href="https://apt.kubernetes.io/" rel="noopener ugc nofollow" target="_blank">https://apt.kubernetes.io/</a> kubernetes-xenial main<br/>EOF</span><span id="7717" class="of mt iq nx b gy oz ow l ox oy">apt-get update<br/>apt-get install -y kubelet kubeadm kubectl<br/>apt-mark hold kubelet kubeadm kubectl</span></pre><p id="f100" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，关闭一些操作系统功能和最终检查。</p><pre class="kg kh ki kj gt or nx os ot aw ou bi"><span id="962d" class="of mt iq nx b gy ov ow l ox oy"># The swap should be turned off<br/>swapoff -a</span><span id="4fda" class="of mt iq nx b gy oz ow l ox oy"># Remove the line that contains <strong class="nx ir">swap</strong> from /etc/fstab<br/>nano /etc/fstab</span><span id="4e4a" class="of mt iq nx b gy oz ow l ox oy"># Check that all servers have different mac addresses<br/>ip link</span><span id="4375" class="of mt iq nx b gy oz ow l ox oy"># Check that all servers have a different product ID<br/>sudo cat /sys/class/dmi/id/product_uuid</span></pre><p id="ce97" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们必须在指定给控制平面的所有服务器上执行上述操作。完成后，我们现在可以初始化集群。</p><p id="39a0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我将使用以下命令生成令牌</p><pre class="kg kh ki kj gt or nx os ot aw ou bi"><span id="a4a2" class="of mt iq nx b gy ov ow l ox oy">kubeadm token generate</span></pre><p id="d1f9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我将创建一个包含一些配置参数的文件。</p><pre class="kg kh ki kj gt or nx os ot aw ou bi"><span id="7871" class="of mt iq nx b gy ov ow l ox oy">apiVersion: kubeadm.k8s.io/v1beta1<br/>kind: ClusterConfiguration<br/>kubernetesVersion: stable</span><span id="ebf2" class="of mt iq nx b gy oz ow l ox oy">etcd:<br/> local:<br/>  serverCertSANs:<br/>  - 10.10.1.1<br/>  - 10.10.1.2<br/>  - 10.10.1.3<br/>  - localhost<br/>  - 127.0.0.1<br/>  - kube-cp-1.com<br/>  - kube-cp-2.com<br/>  - kube-cp-3.com<br/>  - lb.kube-cp.com<br/>  peerCertSANs:<br/>  - 10.10.1.1<br/>  - 10.10.1.2<br/>  - 10.10.1.3<br/>  - localhost<br/>  - 127.0.0.1<br/>  - kube-cp-1.com<br/>  - kube-cp-2.com<br/>  - kube-cp-3.com<br/>  - lb.kube-cp.com</span><span id="0971" class="of mt iq nx b gy oz ow l ox oy">apiServer:<br/>  certSANs:<br/>  - 10.10.1.1<br/>  - 10.10.1.2<br/>  - 10.10.1.3<br/>  - localhost<br/>  - 127.0.0.1<br/>  - kube-cp-1.com<br/>  - kube-cp-2.com<br/>  - kube-cp-3.com<br/>  - lb.kube-cp.com</span><span id="f79c" class="of mt iq nx b gy oz ow l ox oy">controlPlaneEndpoint: "lb.control_plane:6443"<br/>networking:<br/>  serviceSubnet: "10.32.0.0/162<br/>  podSubnet: "10.244.0.0/16"<br/>  dnsDomain: "cluster.local"</span></pre><p id="70cb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个配置文件主要用于定义自签名证书应该工作的不同地址。这里我们包括所有控制平面IP、主机名、本地主机、127.0.0.1和一个特殊域<em class="ls">lb.kube-cp.com</em>。还要记住<code class="fe nu nv nw nx b">podSubnet</code>和<code class="fe nu nv nw nx b">serviceSubnet</code>是专用于<a class="ae kv" href="https://github.com/coreos/flannel" rel="noopener ugc nofollow" target="_blank">法兰绒</a>的，它是一种通用CNI。</p><p id="2a7e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了理解我们为什么需要特殊的域lb.kube-cp.com，我们首先需要深入研究一下<strong class="ky ir"> controlPlaneEndpoint </strong>配置属性。</p><h2 id="1ce2" class="of mt iq bd mu og oh dn my oi oj dp nc lf ok ol ne lj om on ng ln oo op ni oq bi translated"><strong class="ak">控制平面端点</strong></h2><p id="359d" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated">如前所述，所有其他节点都通过API服务器与控制平面通信。这个API服务器需要通过一个由<strong class="ky ir">控制计划端点</strong>定义的端点来访问。默认情况下，它使用初始化Kubernetes的第一个服务器的ip，虽然它在单节点控制平面上工作，但它在HA控制平面上存在问题。</p><p id="51cf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第一种情况是有三个控制平面服务器，每个都有自己的IP地址。设置好Kubernetes之后，我们将<strong class="ky ir"> controlPlaneEndpoint </strong>设置为第一台服务器的IP。所有工作节点都引用该IP。最后，我们有了一个HA控制平面，但是所有的服务都指向一个服务器来获取所有的信息。如果该服务器出现故障，尽管控制平面本身已启动，但群集将无法工作，因为所有工作节点都将引用一个失效的服务器。(所有部署继续工作)</p><p id="e353" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第二个场景利用了一个<strong class="ky ir">神奇的IP地址</strong>，它总是指向一个活动的控制平面节点。这样，对于三个控制平面，当第一个出现故障时，IP会自动切换到其中一个正常工作的控制平面。为了让一切正常工作，我们将controlPlaneEndpoint设置为这个神奇的IP地址或主机名。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pa"><img src="../Images/0cc93c56a58846bacdd275c0f21e4796.png" data-original-src="https://miro.medium.com/v2/resize:fit:1080/format:webp/1*arfTmZbtrZsV7szb9Xbndw.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">具有VIP和保持活动状态的高可用性控制平面</figcaption></figure><p id="ad7c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有不同的方法来设置这个神奇的IP地址，每一个都提出了自己的挑战。一个常见的方法是使用<a class="ae kv" href="http://keepalived.org" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> Keepalived </strong> </a>，这是一个强大的工具，可以做各种事情，其中之一就是创建一个<strong class="ky ir">虚拟IP </strong>或<strong class="ky ir"> VIP </strong>。这种方法的一个问题是，它假设所有节点之间有一个公共的VLAN，因为它在VLAN上创建了VIP，并且只能在VLAN的上下文中访问。</p><p id="91a1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，我们创建一个VLAN，并将所有6个Kubernetes服务器(3个主服务器和3个工作服务器)的网络接口配置为连接到同一个虚拟网络(根据提供商的不同，可能无法创建一个虚拟网络)。现在，所有这些服务器的本地IP都将对其他服务器可见，如10.0.0.1、10.0.0.2等。可以在此网络上配置Keepalived，以创建新的IP (10.0.1.1)并根据一组规则在控制平面节点之间切换，这些规则可以是服务器是否停机，也可以是它们的优先级。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pb"><img src="../Images/6176ef27530b40b62a30004767ef1d1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1078/format:webp/1*I-lzyKb3navw8pTxLmyJAA.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">具有CDN负载平衡的高可用性控制面板</figcaption></figure><p id="3d93" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不过，有一种更简单的方法可以解决我们的问题。我们需要一个地址来访问我们的控制平面节点。可以是一个<strong class="ky ir"> IP地址</strong>或者<strong class="ky ir"> </strong>一个<strong class="ky ir">域名</strong>。假设我们可以为这组服务器创建一个新的域名。如果其中一个失败了，我如何让它在它们之间切换。错误的做法是，一旦我们收到主服务器出现故障的<strong class="ky ir">警报</strong>，就手动将域名切换到第二台服务器。有一个更智能的方法来解决这个问题，那就是通过DNS级别的负载平衡器。比如<a class="ae kv" href="https://www.cloudflare.com/load-balancing/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> CloudFlare </strong> </a>就提供这种服务。您可以配置带有自定义健康检查的域名级别负载平衡，以便所需的域名(<strong class="ky ir">lb.kube-cp.com</strong>)自动切换到健康服务器。</p><p id="d202" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您也可以创建自己的负载均衡器，也许可以使用MetalLB，但是由于显而易见的原因，这需要至少3台额外的服务器。</p><h2 id="3b0a" class="of mt iq bd mu og oh dn my oi oj dp nc lf ok ol ne lj om on ng ln oo op ni oq bi translated">包装它</h2><p id="7729" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated">总结一下这个话题，这里有两件事需要记住。</p><ul class=""><li id="d78b" class="pc pd iq ky b kz la lc ld lf pe lj pf ln pg lr ph pi pj pk bi translated">监控是任何类型的任何群集的一个重要元素，即使对于后台组件(如控制面板)也是如此</li><li id="b69e" class="pc pd iq ky b kz pl lc pm lf pn lj po ln pp lr ph pi pj pk bi translated">根据不同的用例，有不同的平衡请求的方法。对于控制平面，DNS负载平衡可能就足够了。</li></ul><p id="b6b6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，为控制面板启动三台服务器，这些是命令。</p><p id="0bdf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们只在一台服务器上初始化集群。</p><pre class="kg kh ki kj gt or nx os ot aw ou bi"><span id="d851" class="of mt iq nx b gy ov ow l ox oy">kubeadm init \<br/>  --config /root/master.yml \<br/>  --skip-token-print</span></pre><p id="40f1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">完成后，我们像这样将证书复制到其他服务器。</p><p id="e8e5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从上述服务器:</p><pre class="kg kh ki kj gt or nx os ot aw ou bi"><span id="9484" class="of mt iq nx b gy ov ow l ox oy">USER=root<br/>DIR=/etc/kubernetes/pki<br/>CONTROL_PLANE_IPS="10.10.1.2 10.10.1.3"</span><span id="a6cf" class="of mt iq nx b gy oz ow l ox oy">for host in ${CONTROL_PLANE_IPS}; do<br/>    scp ${DIR}/ca.crt "${USER}"@$host:${DIR}/ca.crt<br/>    scp ${DIR}/ca.key "${USER}"@$host:${DIR}/ca.key<br/>    scp ${DIR}/sa.key "${USER}"@$host:${DIR}/sa.key<br/>    scp ${DIR}/sa.pub "${USER}"@$host:${DIR}/sa.pub<br/>    scp ${DIR}/front-proxy-ca.crt "${USER}"@$host:${DIR}/front-proxy-ca.crt<br/>    scp ${DIR}/front-proxy-ca.key "${USER}"@$host:${DIR}/front-proxy-ca.key<br/>    scp ${DIR}/etcd/ca.crt "${USER}"@$host:${DIR}/etcd/ca.crt<br/>    scp ${DIR}/etcd/ca.key "${USER}"@$host:${DIR}/etcd/ca.key<br/>done</span></pre><p id="ed97" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该脚本假设第一个节点可以通过SSH对其他两个节点进行root访问。取自<a class="ae kv" href="https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/high-availability/#manual-certs" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">文档</strong> <strong class="ky ir">此处</strong> </a> <strong class="ky ir"> </strong>并稍加更新使其具有单一命令。</p><p id="73e5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">再次从第一个节点我们得到<strong class="ky ir">加入命令</strong></p><pre class="kg kh ki kj gt or nx os ot aw ou bi"><span id="1b66" class="of mt iq nx b gy ov ow l ox oy">kubeadm token create --print-join-command</span></pre><p id="d115" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">并使用它像这样连接另外两个节点(<code class="fe nu nv nw nx b">JOIN_COMMAND</code>是执行上述命令的结果)</p><pre class="kg kh ki kj gt or nx os ot aw ou bi"><span id="76c5" class="of mt iq nx b gy ov ow l ox oy">JOIN_COMMAND --control-plane</span></pre><p id="d6d1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过这最后一步，我们有了一个完全工作的高可用性控制平面，Kubernetes集群为工作节点做好了准备。现在，只要执行下面的命令，我们就可以得到一个完全正常工作的K8s集群。</p><pre class="kg kh ki kj gt or nx os ot aw ou bi"><span id="d6ff" class="of mt iq nx b gy ov ow l ox oy">JOIN_COMMAN</span></pre></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="a29d" class="ms mt iq bd mu mv mw mx my mz na nb nc jw nd jx ne jz nf ka ng kc nh kd ni nj bi translated">储存；储备</h1><p id="3ad9" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated">这部分变得太长了，所以我把它移到了一篇单独的文章里，你可以在这里找到。</p><div class="lt lu gp gr lv lw"><a href="https://medium.com/@anisinanaj/storage-on-kubernetes-efa0a5b4f858" rel="noopener follow" target="_blank"><div class="lx ab fo"><div class="ly ab lz cl cj ma"><h2 class="bd ir gy z fp mb fr fs mc fu fw ip bi translated">Kubernetes上的存储</h2><div class="md l"><h3 class="bd b gy z fp mb fr fs mc fu fw dk translated">所以我告诉Kubernetes部署一个php应用程序来生成pdf文件，将“生成”状态存储在…</h3></div><div class="me l"><p class="bd b dl z fp mb fr fs mc fu fw dk translated">medium.com</p></div></div><div class="mf l"><div class="pq l mh mi mj mf mk kp lw"/></div></div></a></div></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="a1cb" class="ms mt iq bd mu mv mw mx my mz na nb nc jw nd jx ne jz nf ka ng kc nh kd ni nj bi translated">网络</h1><p id="7151" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated">关于网络和如何使集群更快的考虑将在另一篇文章中继续。</p><div class="lt lu gp gr lv lw"><a href="https://medium.com/@anisinanaj/kubernetes-cluster-networking-ad77eb4f826b" rel="noopener follow" target="_blank"><div class="lx ab fo"><div class="ly ab lz cl cj ma"><h2 class="bd ir gy z fp mb fr fs mc fu fw ip bi translated">Kubernetes集群和网络</h2><div class="md l"><h3 class="bd b gy z fp mb fr fs mc fu fw dk translated">让我们来看看我们需要如何连接所有的服务器来充分利用它们。文章由此继续…</h3></div><div class="me l"><p class="bd b dl z fp mb fr fs mc fu fw dk translated">medium.com</p></div></div><div class="mf l"><div class="pr l mh mi mj mf mk kp lw"/></div></div></a></div></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="28d4" class="ms mt iq bd mu mv mw mx my mz na nb nc jw nd jx ne jz nf ka ng kc nh kd ni nj bi translated">完成这个循环。</h1><p id="49af" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated">要使集群运行起来，还缺少一些东西。</p><p id="3509" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">查看这篇文章。</p><div class="lt lu gp gr lv lw"><a href="https://medium.com/@anisinanaj/completing-the-kubernetes-setup-7462383ab3c" rel="noopener follow" target="_blank"><div class="lx ab fo"><div class="ly ab lz cl cj ma"><h2 class="bd ir gy z fp mb fr fs mc fu fw ip bi translated">完成循环(K8s)</h2><div class="md l"><h3 class="bd b gy z fp mb fr fs mc fu fw dk translated">在上一篇文章中，我解释了如何打开HA K8s集群。但这只是Kubernetes的裸装…</h3></div><div class="me l"><p class="bd b dl z fp mb fr fs mc fu fw dk translated">medium.com</p></div></div><div class="mf l"><div class="ps l mh mi mj mf mk kp lw"/></div></div></a></div></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><p id="21e7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我希望我涵盖了一切。感谢你有耐心读到这里。<br/>敬请关注更多:)</p></div></div>    
</body>
</html>