<html>
<head>
<title>Go Does Not Need a Java Style GC</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Go不需要Java风格的GC</h1>
<blockquote>原文：<a href="https://itnext.io/go-does-not-need-a-java-style-gc-ac99b8d26c60?source=collection_archive---------0-----------------------#2021-05-01">https://itnext.io/go-does-not-need-a-java-style-gc-ac99b8d26c60?source=collection_archive---------0-----------------------#2021-05-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a6ec" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">为什么Go不需要Java、C#这样花哨昂贵的垃圾收集器？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b59257b06fa6823e91090145b415f73c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yKuWBj_IZ8MnGZvx2HX37Q.jpeg"/></div></div></figure><p id="0164" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi lq translated">像Go、Julia和Rust这样的现代语言不需要像Java C#那样复杂的垃圾收集器。但是为什么呢？</p><p id="387b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了解释原因，我们需要了解垃圾收集器是如何工作的，以及不同的语言如何以不同的方式分配内存。然而，我们将从为什么Java特别需要如此复杂的垃圾收集器开始。</p><p id="9fb3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我将在这里讨论许多不同的垃圾收集器主题:</p><ul class=""><li id="fe28" class="lz ma it kw b kx ky la lb ld mb lh mc ll md lp me mf mg mh bi translated">为什么Java如此依赖快速GC。我将介绍Java语言本身的一些设计选择，它们给GC带来了很大的压力。</li><li id="8d09" class="lz ma it kw b kx mi la mj ld mk lh ml ll mm lp me mf mg mh bi translated">内存碎片及其对GC设计的影响。为什么这对Java很重要，但对Go却没那么重要。</li><li id="39c1" class="lz ma it kw b kx mi la mj ld mk lh ml ll mm lp me mf mg mh bi translated">值类型以及它们如何改变GC游戏。</li><li id="7066" class="lz ma it kw b kx mi la mj ld mk lh ml ll mm lp me mf mg mh bi translated">分代垃圾收集器和为什么Go不需要一个。</li><li id="1d87" class="lz ma it kw b kx mi la mj ld mk lh ml ll mm lp me mf mg mh bi translated">逸出分析——Go用来减轻GC压力的一个技巧。</li><li id="9c0d" class="lz ma it kw b kx mi la mj ld mk lh ml ll mm lp me mf mg mh bi translated">压缩垃圾收集器——在Java世界中很重要，但Go却不需要它。为什么？</li><li id="4a6d" class="lz ma it kw b kx mi la mj ld mk lh ml ll mm lp me mf mg mh bi translated">并发垃圾收集——How Go通过使用多线程运行并发垃圾收集器解决了许多垃圾收集难题。为什么用Java很难做到这点。</li><li id="c285" class="lz ma it kw b kx mi la mj ld mk lh ml ll mm lp me mf mg mh bi translated">对Go GC的常见批评，以及为什么这种批评背后的许多假设往往是有缺陷的或完全错误的。</li></ul><h1 id="27e9" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">为什么Java比任何人都更需要快速GC</h1><p id="bc2d" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated">Java是一种基本上将内存管理完全外包给垃圾收集器的语言。这被证明是一个大错误。然而，为了能够解释为什么，我需要涵盖更多的细节。</p><p id="fb70" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们从头开始。现在是1991年，关于Java的工作已经开始。垃圾收集者风靡一时。研究看起来很有希望，Java的设计者们把赌注压在了高级垃圾收集器上，它们能够解决管理内存中的所有挑战。</p><p id="b840" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，Java中的所有对象都被设计为在堆上分配，整数和浮点值等基本类型除外。当谈到内存分配时，我们通常会区分堆和栈。堆栈使用起来非常快，但是空间有限，并且只能用于在函数调用的生存期之后不需要存在的对象。它只适用于局部变量。堆可用于所有对象。Java基本上忽略了栈，选择在堆上分配所有东西，除了像整数和浮点数这样的原语。每当你用Java写<code class="fe nk nl nm nn b">new Something()</code>的时候，你都在消耗堆上的内存。</p><p id="a64e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，这种类型的内存管理实际上在内存使用方面是相当昂贵的。您可能认为创建一个只有32位整数的对象只需要4个字节的内存。</p><pre class="kj kk kl km gt no nn np nq aw nr bi"><span id="f2a5" class="ns mo it nn b gy nt nu l nv nw">class Knight {<br/>   int health;<br/>}</span></pre><p id="1b1e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，为了让垃圾收集器工作，Java存储了一个带有如下信息的头:</p><ul class=""><li id="7648" class="lz ma it kw b kx ky la lb ld mb lh mc ll md lp me mf mg mh bi translated">类型—标识对象的类别或类型。</li><li id="a5ac" class="lz ma it kw b kx mi la mj ld mk lh ml ll mm lp me mf mg mh bi translated">锁定—用于同步语句。</li><li id="3929" class="lz ma it kw b kx mi la mj ld mk lh ml ll mm lp me mf mg mh bi translated">标记-在垃圾收集器的标记和扫描面期间使用。</li></ul><p id="b434" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">该数据通常总计16个字节。因此，标题数据与实际数据的比率为4:1。Java对象的C++源代码定义为:<a class="ae nx" href="http://hg.openjdk.java.net/jdk8/jdk8/hotspot/file/87ee5ee27509/src/share/vm/oops/oop.hpp" rel="noopener ugc nofollow" target="_blank"> OpenJDK基类</a>。</p><pre class="kj kk kl km gt no nn np nq aw nr bi"><span id="3472" class="ns mo it nn b gy nt nu l nv nw">class oopDesc {<br/>    volatile markOop  _mark;   // for mark and sweep<br/>    Klass*           _klass;   // the type<br/>}</span></pre><h2 id="d97e" class="ns mo it bd mp ny nz dn mt oa ob dp mx ld oc od mz lh oe of nb ll og oh nd oi bi translated">内存碎片</h2><p id="eb7f" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated">下一个问题是内存碎片。当Java分配一个对象数组时，它真正做的是创建一个引用数组，指向内存中其他位置的对象。这些对象最终可能会分散在堆内存中。这对性能不利，因为现代微处理器不读取单个字节的数据。因为启动内存传输很慢，所以每当微处理器试图访问一个特定的内存位置时，它总是读取一个大的连续内存块。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/653eb6d96da49a23197611f73c87fbe9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TESQmAGGOzsT-3y1iqAyHw.png"/></div></div></figure><p id="3463" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个内存块被称为缓存行。CPU有自己的高速内存，称为高速缓存。这比主存小得多。它用于存储最近访问的对象，因为这些对象可能会再次被访问。如果主内存被碎片化，这意味着缓存线将被碎片化，CPU缓存将被大量无用数据填满。</p><h2 id="4662" class="ns mo it bd mp ny nz dn mt oa ob dp mx ld oc od mz lh oe of nb ll og oh nd oi bi translated">Java如何克服内存碎片</h2><p id="528c" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated">为了解决这些主要的缺点，Java维护者在高级垃圾收集器上投入了大量的资金。这些做的事情叫做<em class="ok">压实</em>。压缩包括在内存中移动对象，并将它们收集到内存中的连续块中。这个不便宜。不仅将块从一个内存位置移动到另一个内存位置会消耗CPU周期，而且更新对这些对象的每个引用以指向新的位置也会消耗CPU周期。</p><p id="fb54" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">进行这些更新需要冻结所有线程。您不能更新正在使用的参考。这通常会导致Java程序完全冻结数百毫秒，在此期间，对象被四处移动，引用被更新，未使用的内存被回收。</p><h2 id="c7d2" class="ns mo it bd mp ny nz dn mt oa ob dp mx ld oc od mz lh oe of nb ll og oh nd oi bi translated">增加复杂性</h2><p id="6792" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated">为了减少这些长时间的停顿，Java使用了所谓的<em class="ok">分代垃圾收集器</em>。这些都基于以下前提:</p><blockquote class="ol om on"><p id="00b7" class="ku kv ok kw b kx ky ju kz la lb jx lc oo le lf lg op li lj lk oq lm ln lo lp im bi translated">程序中分配的大部分值很快就被用完了，所以GC花更多的时间查看最近分配的对象是有好处的。</p></blockquote><p id="d8b5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这就是为什么Java把它们分配对象分成两组:</p><ul class=""><li id="6543" class="lz ma it kw b kx ky la lb ld mb lh mc ll md lp me mf mg mh bi translated">旧对象—经历了GC的多次标记和清除操作的对象。在每次标记和扫描时更新世代计数器，以跟踪对象的年龄。</li><li id="3d66" class="lz ma it kw b kx mi la mj ld mk lh ml ll mm lp me mf mg mh bi translated">年轻对象—这些对象的世代计数器较低。这意味着它们是最近才被分配的。</li></ul><p id="961a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Java更主动地调查最近分配的对象，并检查它们是否应该被回收或移动。随着对象的老化，它们被移出年轻一代区域。</p><p id="c2ee" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所有这些自然会增加复杂性。它需要更多的发展。它需要为更有才华的开发人员付费，花费更多的钱。</p><h1 id="742e" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">现代语言如何避免和Java一样的陷阱</h1><p id="1d2d" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated">现代语言不需要像Java和C#那样复杂的垃圾收集器。这是因为它们没有被设计成在相同程度上依赖它们。</p><pre class="kj kk kl km gt no nn np nq aw nr bi"><span id="9841" class="ns mo it nn b gy nt nu l nv nw">// Go: Make an an array of 15 000 Point objects in</span><span id="4ef7" class="ns mo it nn b gy or nu l nv nw"><strong class="nn iu">type</strong> Point <strong class="nn iu">struct</strong> {<br/>    X, Y int<br/>}</span><span id="f95d" class="ns mo it nn b gy or nu l nv nw"><strong class="nn iu">var</strong> points [15000]Point</span></pre><p id="e9ce" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在上面的Go代码示例中，我们分配了15 000个<code class="fe nk nl nm nn b">Point</code>对象。这只是一次分配，产生一个指针。在Java中，这需要15 000个单独的分配，每个分配产生一个必须被管理的单独的引用。每个<code class="fe nk nl nm nn b">Point</code>对象都会得到我之前提到的16字节的头开销。无论是在围棋，朱莉娅或Rust你得到这个开销。这些对象通常是无头的。</p><p id="afb7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在Java中，GC需要跟踪和管理15 000个独立的对象。Go只有一个要跟踪的对象。</p><h2 id="b544" class="ns mo it bd mp ny nz dn mt oa ob dp mx ld oc od mz lh oe of nb ll og oh nd oi bi translated">值类型</h2><p id="aeaf" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated">这在其他语言中之所以可能，是因为它们支持值类型。下面的代码定义了一个矩形，用一个<code class="fe nk nl nm nn b">Min</code>和<code class="fe nk nl nm nn b">Max</code>点定义它的范围。</p><pre class="kj kk kl km gt no nn np nq aw nr bi"><span id="b0d2" class="ns mo it nn b gy nt nu l nv nw"><strong class="nn iu">type</strong> Rect <strong class="nn iu">struct</strong> {<br/>   Min, Max Point<br/>}</span></pre><p id="d179" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这成为一个连续的内存块。在Java中，这将变成一个引用两个独立对象的<code class="fe nk nl nm nn b">Rect</code>对象，即<code class="fe nk nl nm nn b">Min</code>和<code class="fe nk nl nm nn b">Max</code>点对象。因此，在Java中，<code class="fe nk nl nm nn b">Rect</code>的一个实例需要3次分配，但在Go、Rust、C/C++和Julia中只需要1次分配。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/f55005e8ef5db8173d6b9975867b99c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BVQIKCIUZXFKizCBpsFh8w.png"/></div></div><figcaption class="ot ou gj gh gi ov ow bd b be z dk translated">左边是Java风格的内存碎片。在右边连续的内存块可能在Go，C/C++，Julia等。</figcaption></figure><p id="a1cb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">将Git移植到Java时，值类型的缺乏造成了严重的问题。没有值类型，很难获得好的性能。正如Shawn O. Pearce <a class="ae nx" href="https://marc.info/?l=git&amp;m=124111702609723" rel="noopener ugc nofollow" target="_blank">在JGit开发者邮件列表上的评论</a>:</p><blockquote class="ol om on"><p id="64f0" class="ku kv ok kw b kx ky ju kz la lb jx lc oo le lf lg op li lj lk oq lm ln lo lp im bi translated">JGit苦于没有有效的方法来表示阿沙-1。c可以只说<code class="fe nk nl nm nn b">unsigned char[20]</code>并将它内联到容器的内存分配中。Java中的一个<code class="fe nk nl nm nn b">byte[20]</code>将消耗<em class="it">额外的</em> 16字节内存，并且访问速度较慢，因为字节本身与容器对象位于不同的内存区域。我们试图通过将一个<code class="fe nk nl nm nn b">byte[20]</code>转换为5个整数来解决这个问题，但这需要我们花费机器指令。</p></blockquote><p id="c98f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们在那里谈论什么？在Go中，我可以做和C/C++一样的事情，定义一个这样的结构:</p><pre class="kj kk kl km gt no nn np nq aw nr bi"><span id="0909" class="ns mo it nn b gy nt nu l nv nw"><strong class="nn iu">type</strong> Sha1 <strong class="nn iu">struct</strong> {<br/>   data [20]byte<br/>}</span></pre><p id="07cc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这些字节将成为一块内存的一部分。Java会创建一个指向内存中其他地方的指针。</p><p id="b9e9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Java开发人员意识到他们搞砸了，并且你真的需要值类型来获得好的性能。你可以说这种说法有些夸张，但是你需要解释一下瓦尔哈拉项目。这是Oracle为Java提供值类型而率先做出的努力，他们阐述的这样做的原因正是我在这里所说的。</p><h2 id="76e3" class="ns mo it bd mp ny nz dn mt oa ob dp mx ld oc od mz lh oe of nb ll og oh nd oi bi translated">值类型是不够的</h2><p id="346b" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated">那么<em class="ok">项目会解决Java的问题吗？不完全是。它将简单地把Java放在与C#平等的地位上。C#比Java晚出现了几年，并且已经意识到垃圾收集器并不像大家想象的那么神奇。因此他们增加了值类型。</em></p><p id="9dd1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，就内存管理灵活性而言，这并没有将C#和Java与Go和C/C++等语言放在同等的位置上。Java不支持真正的指针。在围棋中，我可以写出这样的东西:</p><pre class="kj kk kl km gt no nn np nq aw nr bi"><span id="a3c9" class="ns mo it nn b gy nt nu l nv nw">// Go pointer usage</span><span id="4bc2" class="ns mo it nn b gy or nu l nv nw"><strong class="nn iu">var</strong> ptr *Point = &amp;rect.Min // Store pointer to Min in ptr<br/>*ptr = Point(2, 4)         // replace rect.Min</span></pre><p id="5f8f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你可以像在C/C++中一样，在Go中获取对象或对象字段的地址，并将其存储在一个指针中。然后，您可以传递这个指针，并使用它来修改它所指向的字段。这意味着您可以在Go中创建大值对象，并将其作为指针传递给函数以优化性能。对于C#来说，情况稍微好一点，因为它对指针的支持<em class="ok">有限</em>。前面的Go示例可以用C#写成:</p><pre class="kj kk kl km gt no nn np nq aw nr bi"><span id="4885" class="ns mo it nn b gy nt nu l nv nw">// C# pointer usage</span><span id="3103" class="ns mo it nn b gy or nu l nv nw"><strong class="nn iu">unsafe</strong> <strong class="nn iu">void </strong>foo() {<br/>   Rect* ptr = &amp;rect.Min;<br/>   *ptr = new Point(2, 4);<br/>}</span></pre><p id="bf85" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，C#指针支持附带了许多不适用于Go的警告:</p><ol class=""><li id="1847" class="lz ma it kw b kx ky la lb ld mb lh mc ll md lp ox mf mg mh bi translated">代码使用点必须标记为<strong class="kw iu">不安全</strong>。这使得代码安全性更低，更有可能崩溃。</li><li id="9fea" class="lz ma it kw b kx mi la mj ld mk lh ml ll mm lp ox mf mg mh bi translated">在堆栈上分配的纯值类型(所有结构字段必须是值类型)。</li><li id="f239" class="lz ma it kw b kx mi la mj ld mk lh ml ll mm lp ox mf mg mh bi translated">在<strong class="kw iu">固定的</strong>范围内，使用fixed关键字关闭垃圾收集。</li></ol><p id="4dd2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，在C#中使用值类型的正常而安全的方法是复制它们，因为这不需要定义不安全或固定的代码区域。但是对于较大的值类型，这可能会产生性能问题。围棋没有这些问题。您可以在Go中创建由垃圾收集器管理的对象的指针。你不需要像在C#中一样，在Go中使用指针来隔离代码。</p><h2 id="2b78" class="ns mo it bd mp ny nz dn mt oa ob dp mx ld oc od mz lh oe of nb ll og oh nd oi bi translated">自定义辅助分配器</h2><p id="e174" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated">有了合适的指针，你可以做很多事情，这在你只有值类型时是不可能的。一个例子是创建次级分配器。<a class="ae nx" href="https://github.com/ordovician/arena" rel="noopener ugc nofollow" target="_blank">这里的</a>是一个使用Go泛型创建的竞技场分配器的例子。</p><pre class="kj kk kl km gt no nn np nq aw nr bi"><span id="e990" class="ns mo it nn b gy nt nu l nv nw"><strong class="nn iu">type</strong> Arena[T any] <strong class="nn iu">struct</strong> {<br/>    blocks Stack[*T]<br/>}</span><span id="2494" class="ns mo it nn b gy or nu l nv nw"><strong class="nn iu">func</strong> (arena *Arena[T]) Alloc() *T {<br/>    <strong class="nn iu">if</strong> arena.blocks.IsEmpty() {<br/>        <strong class="nn iu">var</strong> blocks [32]T     // allocate 32 elements at a time<br/>        <strong class="nn iu">for</strong> i, _ := <strong class="nn iu">range</strong> blocks {<br/>            arena.blocks.Push(&amp;blocks[i])<br/>        }<br/>    }<br/>    b, _ := arena.blocks.Top()<br/>    arena.blocks.Pop()</span><span id="148a" class="ns mo it nn b gy or nu l nv nw">    <strong class="nn iu">return</strong> b<br/>}</span></pre><p id="8989" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这些为什么有用？如果你查看生成二叉树的算法的微基准，你通常会发现Java比Go有很大的优势。这是因为二叉树算法通常用于测试垃圾收集器在分配对象时的速度。Java在这方面非常快，因为它使用了我们所说的bump指针。它只是增加一个指针，而Go将在内存中搜索合适的位置来分配对象。然而，使用Arena分配器，您也可以在Go中快速构建二叉树。</p><pre class="kj kk kl km gt no nn np nq aw nr bi"><span id="9779" class="ns mo it nn b gy nt nu l nv nw"><strong class="nn iu">import</strong> "golang.org/x/exp/constraints"</span><span id="56dd" class="ns mo it nn b gy or nu l nv nw"><strong class="nn iu">type</strong> Tree[K constraints.Ordered, V any] <strong class="nn iu">struct</strong> {<br/>    Root      *TreeNode[K, V]<br/>    allocator Arena[TreeNode[K, V]]<br/>}</span><span id="e20d" class="ns mo it nn b gy or nu l nv nw"><strong class="nn iu">func</strong> (tree *Tree[K, V]) NewNode(key K, value V) *TreeNode[K, V] {<br/>    n := tree.allocator.Alloc()<br/>    n.Key = key<br/>    n.Value = value<br/>    n.left = nil<br/>    n.right = nil</span><span id="6115" class="ns mo it nn b gy or nu l nv nw">    <strong class="nn iu">return</strong> n<br/>}</span><span id="c1c8" class="ns mo it nn b gy or nu l nv nw"><strong class="nn iu">func</strong> (tree *Tree[K, V]) Insert(key K, value V) {<br/>    n := tree.NewNode(key, value)</span><span id="c7eb" class="ns mo it nn b gy or nu l nv nw">    <strong class="nn iu">if</strong> tree.Root == nil {<br/>        tree.Root = n<br/>    } <strong class="nn iu">else</strong> {<br/>        tree.Root.Insert(n)<br/>    }<br/>}</span></pre><p id="29b3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这就是为什么拥有真正的指针有好处。没有它，就不能在连续的内存块中创建指向某个元素的指针。在<code class="fe nk nl nm nn b">Alloc</code>方法中，我们创建了一个由32个元素组成的连续块。然后，我们将指向该块中每个元素的指针存储在一个堆栈中，该堆栈包含一个可供分配的块列表。</p><pre class="kj kk kl km gt no nn np nq aw nr bi"><span id="f3b0" class="ns mo it nn b gy nt nu l nv nw"><strong class="nn iu">var</strong> blocks [32]T<br/><strong class="nn iu">for</strong> i, _ := <strong class="nn iu">range</strong> blocks {<br/>    arena.blocks.Push(&amp;blocks[i])<br/>}</span></pre><p id="e445" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是唯一可能的，因为我可以选择一个任意元素<code class="fe nk nl nm nn b">blocks[i]</code>并获得指向该元素<code class="fe nk nl nm nn b">&amp;blocks[i]</code>的指针。Java没有给你这种可能性。</p><h1 id="2862" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">Java缓冲分配器的问题</h1><p id="f16b" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated">Java GC使用的bump分配器类似于Arena分配器，只是增加一个指针来获得下一个值。除了你不需要自己建造它。这似乎更聪明。但是它导致了Go中避免的几个问题:</p><ol class=""><li id="2d79" class="lz ma it kw b kx ky la lb ld mb lh mc ll md lp ox mf mg mh bi translated">迟早你需要做<em class="ok">压缩</em>，这涉及到移动数据和固定指针。竞技场分配者不需要这么做。</li><li id="f8de" class="lz ma it kw b kx mi la mj ld mk lh ml ll mm lp ox mf mg mh bi translated">在多线程程序中，冲击分配器需要锁(除非您使用线程本地存储)。这扼杀了它们的性能优势，要么是因为锁降低了性能，要么是线程本地存储将导致碎片，这需要稍后进行压缩。</li></ol><p id="266d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Go <a class="ae nx" href="https://groups.google.com/g/golang-nuts/c/KJiyv2mV2pU" rel="noopener ugc nofollow" target="_blank">的创始人之一伊恩·兰斯·泰勒澄清了凹凸分配器</a>的问题:</p><blockquote class="ol om on"><p id="34a5" class="ku kv ok kw b kx ky ju kz la lb jx lc oo le lf lg op li lj lk oq lm ln lo lp im bi translated">一般来说，使用一组基于线程的缓存来分配内存可能会更有效，此时您就失去了bump分配器的优势。所以我断言，总的来说，虽然有很多警告，但是现在对多线程程序使用压缩内存分配器并没有真正的优势。</p></blockquote><h1 id="14eb" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">分代GC和逸出分析</h1><p id="1495" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated">Java垃圾收集器有更多的工作要做，因为它分配了更多的对象。为什么？我们刚刚讨论过了。如果没有值对象和真正的指针，在分配大型数组或复杂的数据结构时，最终总是会有大量的对象。因此，它需要一个分代GC。</p><p id="fd83" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">分配更少对象的需求对Go有利。但是围棋还有另外一个技巧。Go和Java在编译函数时都会做所谓的<em class="ok">转义分析</em>。</p><p id="2a33" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">逸出分析包括查看在函数内部创建的指针，并确定该指针是否逸出了函数范围。</p><pre class="kj kk kl km gt no nn np nq aw nr bi"><span id="dcde" class="ns mo it nn b gy nt nu l nv nw"><strong class="nn iu">func</strong> escapingPtr() []int {<br/>   values := []int{4, 5, 10}<br/>   <strong class="nn iu">return</strong> values<br/>}<br/><br/><strong class="nn iu">fun</strong> nonEscapingPtr() int {<br/>    values = []int{4, 5, 10}<br/>    <strong class="nn iu">var</strong> total int = addUp(values)<br/>    <strong class="nn iu">return</strong> total<br/>}</span></pre><p id="2fc5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在第一个例子中，<code class="fe nk nl nm nn b">values</code>指向一个片，本质上与指向数组的指针相同。它因为被返回而转义。这意味着<code class="fe nk nl nm nn b">values</code>必须在堆上分配。</p><p id="5ccd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，在第二个例子中，没有指向<code class="fe nk nl nm nn b">values</code>的指针离开过<code class="fe nk nl nm nn b">nonEscapingPtr</code>函数。因此<code class="fe nk nl nm nn b">values</code>可以在堆栈上分配，这是非常快速和廉价的。转义分析本身只是分析一个指针是否转义。</p><h2 id="2103" class="ns mo it bd mp ny nz dn mt oa ob dp mx ld oc od mz lh oe of nb ll og oh nd oi bi translated">Java转义分析的局限性</h2><p id="f6b8" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated">Java也能逃脱分析，但是对它的使用有更多的限制。<a class="ae nx" href="https://docs.oracle.com/en/java/javase/16/vm/java-hotspot-virtual-machine-performance-enhancements.html#GUID-6BD8FCB5-995B-4AE9-BFAA-B2C7DE2BA5CD" rel="noopener ugc nofollow" target="_blank">摘自Java SE 16 Oracle文档</a>，涵盖了HotSpot虚拟机:</p><blockquote class="ol om on"><p id="f59e" class="ku kv ok kw b kx ky ju kz la lb jx lc oo le lf lg op li lj lk oq lm ln lo lp im bi translated">对于没有全局转义的对象，它不会用堆栈分配替换堆分配。</p></blockquote><p id="cf0d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，Java使用了另一种叫做<em class="ok">标量替换的技巧，</em>它避免了将对象放入堆栈的需要。本质上，它分解object并将其原始成员放入堆栈。记住Java已经可以把原始值比如<code class="fe nk nl nm nn b">int</code>和<code class="fe nk nl nm nn b">float</code>放到堆栈上了。然而，实际上标量替换即使在非常小的情况下也不起作用，正如<a class="ae nx" href="https://pkolaczk.github.io/" rel="noopener ugc nofollow" target="_blank">Piotr koaczkowski</a>在2021年发现的。</p><p id="08a3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">相反，主要优点是避免了锁定。如果你知道指针不在函数外使用，你也可以确定它不需要锁。</p><h2 id="e64e" class="ns mo it bd mp ny nz dn mt oa ob dp mx ld oc od mz lh oe of nb ll og oh nd oi bi translated">Go转义分析的优势</h2><p id="81e4" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated">但是，Go使用转义分析来确定哪些对象可以分配到堆栈上。这大大减少了受益于分代GC的短命对象的数量。请记住，分代式GC的全部意义在于利用最近分配的对象存在时间很短这一事实。然而，Go中的大多数对象很可能会长寿，因为短命的对象很可能会被转义分析捕获。</p><p id="17d4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">与Java不同，这也适用于复杂对象。Java通常只能成功地对像字节数组这样的简单对象进行转义分析。即使内置的<code class="fe nk nl nm nn b">ByteBuffer</code>也不能使用标量替换在堆栈上分配。</p><h1 id="4692" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">现代语言不需要压缩GC</h1><p id="0449" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated">你可以读到很多垃圾收集器方面的专家声称，由于内存碎片，Go比Java更有可能耗尽内存。争论大概是这样的:因为Go没有压缩垃圾收集器，所以随着时间的推移，内存会变得支离破碎。当记忆碎片化的时候，你将会到达一个点，在那里将一个新的物体放入记忆变得困难。</p><p id="76a5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，由于两个原因，这个问题大大减少了:</p><ol class=""><li id="879d" class="lz ma it kw b kx ky la lb ld mb lh mc ll md lp ox mf mg mh bi translated">Go不像Java那样分配那么多微小的对象。它可以将大型对象数组作为单个内存块来分配。</li><li id="d147" class="lz ma it kw b kx mi la mj ld mk lh ml ll mm lp ox mf mg mh bi translated">现代的内存分配器，如谷歌的TCMalloc或英特尔的可扩展Malloc，不会对内存进行分段。</li></ol><p id="19f7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">回到Java设计的时候，内存碎片是内存分配器的一个大问题。人们认为这个问题无法解决。但是甚至早在1998年，Java问世后不久，研究人员就开始解决这个问题。这里有一篇来自马克·s·约翰斯通和保罗·r·威尔逊的论文:</p><blockquote class="ol om on"><p id="e45a" class="ku kv ok kw b kx ky ju kz la lb jx lc oo le lf lg op li lj lk oq lm ln lo lp im bi translated">这大大加强了我们以前的结果，表明内存碎片问题通常被误解，良好的分配器策略可以为大多数程序提供良好的内存使用。</p></blockquote><p id="3357" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，为Java设计内存分配策略的许多假设已经不再成立。</p><h1 id="aeb3" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">分代GC与并发GC暂停</h1><p id="e119" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated">使用分代GC的Java策略旨在缩短垃圾收集周期。记住Java必须停止一切来移动数据和修复指针。如果持续时间太长，会降低性能和响应能力。有了分代GC，每次检查的数据就更少了，从而减少了检查时间。</p><p id="866c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，Go通过许多替代策略解决了相同的问题:</p><ol class=""><li id="eb44" class="lz ma it kw b kx ky la lb ld mb lh mc ll md lp ox mf mg mh bi translated">因为不需要移动内存，也不需要固定指针，所以在GC运行期间需要做的工作更少。Go GC只做标记和扫描:它在对象图中寻找应该释放的对象。</li><li id="7c58" class="lz ma it kw b kx mi la mj ld mk lh ml ll mm lp ox mf mg mh bi translated">它同时运行。因此，一个单独的GC线程可以在不停止其他线程的情况下寻找要释放的对象。</li></ol><p id="57e3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为什么可以同时运行GC而不是Java？因为Go不修复任何指针，也不移动内存中的任何对象。因此，尝试访问指向刚被移动的对象的指针是没有风险的，但是该指针还没有被更新。不再对其有任何引用的对象不会由于一些并发线程的运行而突然获得引用。因此，并行移除死物体是没有危险的。</p><p id="f9b4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这将如何发展？假设你有4个线程在一个Go程序中工作。其中一个线程在某个任意的时间段<code class="fe nk nl nm nn b">T</code>秒内进行了总计4秒的临时GC工作。</p><p id="b871" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在想象一个Java程序，一个GC只做了2秒钟的GC工作。哪个程序挤出的性能最多？谁在<code class="fe nk nl nm nn b">T</code>秒内完成的工作最多？听起来像Java程序，对吗？不对！</p><p id="314f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Java程序中的4个工作线程的所有工作都停止了2秒钟。这意味着2×4 = 8秒的工作在<code class="fe nk nl nm nn b">T</code>间隔中丢失。因此，虽然Go停止的时间更长，但每次停止影响的工作更少，因为不是所有的线程都停止了。因此，一个缓慢的并发GC可能会优于一个依靠停止所有线程来完成工作的快速GC。</p><h2 id="ab03" class="ns mo it bd mp ny nz dn mt oa ob dp mx ld oc od mz lh oe of nb ll og oh nd oi bi translated">如果垃圾产生的速度比Go清理垃圾的速度还快怎么办？</h2><p id="2d5f" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated">反对当前垃圾收集器的一个流行观点是，活动工作线程产生垃圾的速度可能会快于垃圾收集器线程收集垃圾的速度。在Java世界中，这被称为“并发模式故障”。</p><p id="7b7d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">据称，在这种情况下，运行时别无选择，只能完全停止程序，等待GC周期完成。因此，当Go声称GC暂停非常低时，这种说法只适用于GC有足够的CPU时间和空间来超过主程序的情况。</p><p id="6eb2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是Go有一个巧妙的技巧来绕过这种由Go GC大师Rick Hudson描述的<a class="ae nx" href="https://blog.golang.org/ismmkeynote" rel="noopener ugc nofollow" target="_blank">。围棋使用的是所谓的步行者。</a></p><blockquote class="ol om on"><p id="248b" class="ku kv ok kw b kx ky ju kz la lb jx lc oo le lf lg op li lj lk oq lm ln lo lp im bi translated">如果需要，步行者在加速标记的同时减慢分配。在一个高层次上，步行者停止了正在进行大量分配的Goroutine，并让它进行标记工作。工作量与Goroutine的分配成正比。这加快了垃圾收集器的速度，同时降低了变异函数的速度。</p></blockquote><p id="2905" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Goroutines有点像线程池中复用的绿色线程。基本上，Go接管运行产生大量垃圾的工作负载的线程，并让它们帮助GC清理垃圾。它将继续接管线程，直到GC运行得比产生垃圾的例程更快。</p><h1 id="9bfd" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">总之</h1><p id="1611" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated">虽然高级垃圾收集器解决了Java中的实际问题，但现代语言如Go和Julia已经简单地避免了在一开始就产生这些问题，从而消除了使用劳斯莱斯垃圾收集器的需要。当您拥有值类型、转义分析、指针、多核处理器和现代分配器时，那么Java设计背后的许多假设都将不复存在。它们不再适用。</p><h1 id="b2fc" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">假设的GC权衡不再适用</h1><p id="1510" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated">迈克·赫恩在Medium上有一个非常受欢迎的故事，批评关于Go GC的说法:<a class="ae nx" href="https://blog.plan99.net/modern-garbage-collection-911ef4f8bd8e" rel="noopener ugc nofollow" target="_blank">现代垃圾收集。</a>。</p><p id="6254" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">赫恩的关键信息是，在GC设计中总是有权衡。他的观点是，由于Go的目标是低延迟收集，他们将在许多其他指标上受到影响。这是一篇有趣的文章，因为它涵盖了很多关于GC设计中权衡的细节。</p><p id="2e3f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">首先，我所说的低延迟是什么意思？与花费数百毫秒的各种Java收集器相比，Go GC平均只暂停大约0.5毫秒。</p><p id="2950" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我认为Mike Hearn的论点的问题在于，它们基于一个有缺陷的前提，即所有语言的内存访问模式都是相同的。正如我在这篇文章中提到的，这是不正确的。Go将产生更少的由GC管理的对象，并且它将使用escape分析尽早清理它们。</p><h2 id="6d6b" class="ns mo it bd mp ny nz dn mt oa ob dp mx ld oc od mz lh oe of nb ll og oh nd oi bi translated">老技术本来就不好？</h2><p id="b4b1" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated">赫恩提出的论点表明，简单的收集从某种程度上来说是有害的:</p><blockquote class="ol om on"><p id="7f2c" class="ku kv ok kw b kx ky ju kz la lb jx lc oo le lf lg op li lj lk oq lm ln lo lp im bi translated">Stop-the-world (STW)标记/清扫是大学计算机科学课程中最常教授的GC算法。在做工作面试的时候，我有时会让候选人谈一点关于GC的事情，几乎总是，他们要么把GC看作一个黑箱，对它一无所知，要么认为它仍然使用这种非常古老的技术。</p></blockquote><p id="83a9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">是的，它可能已经过时了，但是这种技术允许您同时运行GC，这是“现代”技术所不允许的。在现代多核硬件世界中，这一点更为重要。</p><h2 id="1ad5" class="ns mo it bd mp ny nz dn mt oa ob dp mx ld oc od mz lh oe of nb ll og oh nd oi bi translated">Go不是C#</h2><p id="7ac3" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated">另一个说法:</p><blockquote class="ol om on"><p id="4309" class="ku kv ok kw b kx ky ju kz la lb jx lc oo le lf lg op li lj lk oq lm ln lo lp im bi translated">由于Go是一种具有值类型的相对普通的命令式语言，它的内存访问模式可能与C#相当，在C #中世代假设肯定成立，因此。NET使用分代收集器。</p></blockquote><p id="51b4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">事实并非如此。C#开发人员会尽量减少使用较大值的对象，因为与指针相关的代码不能安全使用。我们必须假设C#开发人员更喜欢复制值类型，而不是使用指针，因为这可以在CLR中安全地完成。这自然会带来更高的开销。</p><p id="3a2b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">据我所知，C#也没有利用转义分析来减少堆上短期对象的产生。其次，<a class="ae nx" href="https://alexyakunin.medium.com/go-vs-c-part-1-goroutines-vs-async-await-ac909c651c11" rel="noopener"> C#不擅长同时运行许多任务</a>。Go可以利用它们的协同程序来加速并发收集，就像Pacer提到的那样。</p><h2 id="6a63" class="ns mo it bd mp ny nz dn mt oa ob dp mx ld oc od mz lh oe of nb ll og oh nd oi bi translated">压紧</h2><blockquote class="ol om on"><p id="45b4" class="ku kv ok kw b kx ky ju kz la lb jx lc oo le lf lg op li lj lk oq lm ln lo lp im bi translated">压缩:因为没有压缩，你的程序最终会把它的堆分成碎片。我将在下面详细讨论堆碎片。将东西整齐地放在缓存中也不会让你受益。</p></blockquote><p id="9668" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这里，Mike Hearn只是没有更新分配器的当前状态。TCMalloc等现代分配器基本消除了这个问题。</p><blockquote class="ol om on"><p id="27de" class="ku kv ok kw b kx ky ju kz la lb jx lc oo le lf lg op li lj lk oq lm ln lo lp im bi translated">程序吞吐量:由于GC必须在每个周期做大量的工作，这从程序本身窃取了CPU时间，降低了程序的速度。</p></blockquote><p id="4667" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当您有并发GC时，这并不适用。所有其他线程都可以在GC工作的时候继续运行——不像Java，它必须停止整个世界。</p><h2 id="b9ec" class="ns mo it bd mp ny nz dn mt oa ob dp mx ld oc od mz lh oe of nb ll og oh nd oi bi translated">堆开销</h2><p id="783c" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated">赫恩提出了“并发模式失败”的问题，假设Go GC将冒跟不上垃圾产生者的风险。</p><blockquote class="ol om on"><p id="b34e" class="ku kv ok kw b kx ky ju kz la lb jx lc oo le lf lg op li lj lk oq lm ln lo lp im bi translated">堆开销:因为通过标记/清除收集堆非常慢，所以您需要大量的空闲空间来确保您不会遭受“并发模式故障”。Go默认的堆开销是100% …它使你的程序需要的内存加倍。</p></blockquote><p id="525f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我对这种说法持怀疑态度，因为我看到的许多现实世界的例子似乎表明围棋程序使用更少的内存。更不用说这忽略了步行者的存在，步行者会抓取产生大量垃圾的Goroutines并让它们去清理。</p><h1 id="11d5" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">为什么低延迟对Java也很重要</h1><p id="306b" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated">我们生活在一个docker容器和微服务的世界里。这意味着许多更小的程序相互通信和工作。想象一下工作通过几个服务。每当一个链中的其中一个服务出现重大停顿时，就会产生连锁反应。它会导致所有其他进程停止工作。如果管道中的下一个服务正在等待一个忙于垃圾收集的服务，则该服务无法工作。</p><p id="fb9a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，延迟/吞吐量的权衡不再是GC设计中的权衡。多个服务协同工作时，高延迟将导致吞吐量下降。Java对高吞吐量和高延迟GC的偏好适用于monolith世界。它不再适用于微服务领域。</p><p id="bbce" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是迈克·赫恩的论点的一个根本问题，即没有灵丹妙药，只有权衡。它试图给人这样一种印象，即Java权衡同样有效。但是权衡必须适应我们生活的世界。</p><p id="586f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">简而言之，我认为可以公平地说，Go做出了许多明智的举动和战略选择。就像这只是任何人都可能做出的权衡一样，挥挥手，并不能解决问题。</p></div></div>    
</body>
</html>