<html>
<head>
<title>Handle Tab changes in React Navigation v2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">处理React Navigation v2中的选项卡更改</h1>
<blockquote>原文：<a href="https://itnext.io/handle-tab-changes-in-react-navigation-v2-faeadc2f2ffe?source=collection_archive---------0-----------------------#2018-07-27">https://itnext.io/handle-tab-changes-in-react-navigation-v2-faeadc2f2ffe?source=collection_archive---------0-----------------------#2018-07-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/70d0e36103683ce613aa85dbe678ae7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9jjWRYyi2eWncPteR8rTuQ.png"/></div></div></figure><p id="750d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">本文涵盖<strong class="ka ir"> <em class="kw">反应-导航v2 </em> </strong>。示例使用的是<strong class="ka ir"> v2.9.0 </strong>。<br/>如果你使用的是v1，请考虑<a class="ae kx" rel="noopener ugc nofollow" target="_blank" href="/handle-tab-changes-in-react-navigation-3717180cddb"> <em class="kw">原文为v1 </em> </a>。</p><h1 id="483c" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">用例</h1><ol class=""><li id="6fcc" class="lw lx iq ka b kb ly kf lz kj ma kn mb kr mc kv md me mf mg bi translated"><strong class="ka ir">切换到标签页时，复位到以前的状态</strong>；</li><li id="83f1" class="lw lx iq ka b kb mh kf mi kj mj kn mk kr ml kv md me mf mg bi translated"><strong class="ka ir">当用户聚焦标签时执行附加逻辑</strong>；</li><li id="7ce7" class="lw lx iq ka b kb mh kf mi kj mj kn mk kr ml kv md me mf mg bi translated"><strong class="ka ir">阻止用户聚焦</strong>特定标签；</li><li id="c17c" class="lw lx iq ka b kb mh kf mi kj mj kn mk kr ml kv md me mf mg bi translated"><strong class="ka ir">处理选项卡上的双击</strong>；</li></ol></div><div class="ab cl mm mn hu mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ij ik il im in"><p id="650a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<strong class="ka ir"> v1 </strong>中，你必须使用<code class="fe mt mu mv mw b">tabBarOnPress</code>来处理这些用例。</p><p id="b191" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是<strong class="ka ir"> v2 </strong>引入了一个新特性，叫做<code class="fe mt mu mv mw b">NavigationEvents</code>。我们将仔细研究这两种方法。</p><p id="6ab2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们考虑下面的<strong class="ka ir"> TabNavigator </strong>:</p><pre class="mx my mz na gt nb mw nc nd aw ne bi"><span id="917d" class="nf kz iq mw b gy ng nh l ni nj">// App.js</span><span id="4643" class="nf kz iq mw b gy nk nh l ni nj"><em class="kw">import</em> { <strong class="mw ir">createBottomTabNavigator</strong> } <em class="kw">from</em> "react-navigation";</span><span id="e03b" class="nf kz iq mw b gy nk nh l ni nj"><em class="kw">export</em> <em class="kw">default</em> createBottomTabNavigator({<br/>  Home: HomeScreen,<br/>  Settings: SettingsScreen<br/>});</span></pre><p id="85e5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">和具有以下内容的<code class="fe mt mu mv mw b"><strong class="ka ir">HomeScreen</strong></code>:</p><pre class="mx my mz na gt nb mw nc nd aw ne bi"><span id="cad0" class="nf kz iq mw b gy ng nh l ni nj">// HomeScreen.js</span><span id="da11" class="nf kz iq mw b gy nk nh l ni nj"><em class="kw">import</em> React <em class="kw">from</em> "react";<br/><em class="kw">import</em> { Text, View } <em class="kw">from</em> "react-native";</span><span id="1de5" class="nf kz iq mw b gy nk nh l ni nj">class HomeScreen extends React.Component {<br/>  render() {<br/>    <em class="kw">return</em> (<br/>      &lt;View&gt;<br/>        &lt;Text&gt;Home&lt;/Text&gt;<br/>      &lt;/View&gt;<br/>    );<br/>  }<br/>}</span></pre><p id="59e7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，假设您想在用户聚焦Home选项卡时做一些事情。</p><h1 id="9c06" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">方法1:使用<code class="fe mt mu mv mw b">NavigationEvents</code></h1><p id="9e9a" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj nl kl km kn nm kp kq kr nn kt ku kv ij bi translated">正如我之前提到的，<em class="kw"> react-navigation v2 </em>引入了一个名为<code class="fe mt mu mv mw b"><a class="ae kx" href="https://reactnavigation.org/docs/en/navigation-events.html" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir">NavigationEvents</strong></a></code>的新组件，它提供了一个声明式API来订阅典型的导航事件，例如:</p><ul class=""><li id="5481" class="lw lx iq ka b kb kc kf kg kj no kn np kr nq kv nr me mf mg bi translated"><code class="fe mt mu mv mw b">onWillFocus</code>:聚焦标签页前；</li><li id="1a1a" class="lw lx iq ka b kb mh kf mi kj mj kn mk kr ml kv nr me mf mg bi translated"><code class="fe mt mu mv mw b">onDidFocus</code>:聚焦一个标签页后；</li><li id="b90d" class="lw lx iq ka b kb mh kf mi kj mj kn mk kr ml kv nr me mf mg bi translated"><code class="fe mt mu mv mw b">onWillBlur</code>:在标签上失去焦点之前；</li><li id="1183" class="lw lx iq ka b kb mh kf mi kj mj kn mk kr ml kv nr me mf mg bi translated"><code class="fe mt mu mv mw b">onDidBlur</code>:在标签页上失去焦点后；</li></ul><p id="50a2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用这个组件非常简单明了。您只需将它包含在需要由这些事件通知的屏幕中，并指定事件处理程序:</p><pre class="mx my mz na gt nb mw nc nd aw ne bi"><span id="a1e2" class="nf kz iq mw b gy ng nh l ni nj">// HomeScreen.js</span><span id="180c" class="nf kz iq mw b gy nk nh l ni nj">...</span><span id="e4e3" class="nf kz iq mw b gy nk nh l ni nj"><strong class="mw ir"><em class="kw">import</em> { NavigationEvents } <em class="kw">from</em> "react-navigation";</strong></span><span id="ce55" class="nf kz iq mw b gy nk nh l ni nj">class HomeScreen extends React.Component {<br/>  render() {<br/>    <em class="kw">return</em> (<br/>      &lt;View&gt;<br/>        <strong class="mw ir">&lt;NavigationEvents<br/>          onWillFocus={payload =&gt; {<br/>            </strong>console.log("will focus", payload);<strong class="mw ir"><br/>          }}<br/>        /&gt;</strong></span><span id="017d" class="nf kz iq mw b gy nk nh l ni nj">        &lt;Text&gt;Home&lt;/Text&gt;<br/>      &lt;/View&gt;<br/>    );<br/>  }<br/>}</span></pre><h2 id="49db" class="nf kz iq bd la ns nt dn le nu nv dp li kj nw nx lm kn ny nz lq kr oa ob lu oc bi translated">优点:</h2><ul class=""><li id="e1b6" class="lw lx iq ka b kb ly kf lz kj ma kn mb kr mc kv nr me mf mg bi translated">易于使用的声明式API</li><li id="08a8" class="lw lx iq ka b kb mh kf mi kj mj kn mk kr ml kv nr me mf mg bi translated">在装载时立即订阅，在卸载时取消订阅；</li></ul><h2 id="f6a3" class="nf kz iq bd la ns nt dn le nu nv dp li kj nw nx lm kn ny nz lq kr oa ob lu oc bi translated">缺点:</h2><ul class=""><li id="e922" class="lw lx iq ka b kb ly kf lz kj ma kn mb kr mc kv nr me mf mg bi translated">无法阻止聚焦在选项卡上；</li><li id="36a9" class="lw lx iq ka b kb mh kf mi kj mj kn mk kr ml kv nr me mf mg bi translated">无法检测双击；</li></ul><p id="e8f9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以这种方法只解决了我们最初用例中的2/4。接下来，我们将看看另一种方法，这是必要的，但将为我们提供更多的灵活性。</p></div><div class="ab cl mm mn hu mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ij ik il im in"><h1 id="a670" class="ky kz iq bd la lb od ld le lf oe lh li lj of ll lm ln og lp lq lr oh lt lu lv bi translated">方法2:使用<code class="fe mt mu mv mw b">tabBarOnPress()</code></h1><p id="fa42" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj nl kl km kn nm kp kq kr nn kt ku kv ij bi translated">我们可以以两种不同的方式使用<code class="fe mt mu mv mw b"><a class="ae kx" href="https://reactnavigation.org/docs/en/bottom-tab-navigator.html#tabbaronpress" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir">tabBarOnPress()</strong></a></code>。我们可以在每个单独的屏幕上设置它:</p><pre class="mx my mz na gt nb mw nc nd aw ne bi"><span id="7bbf" class="nf kz iq mw b gy ng nh l ni nj">// HomeScreen.js</span><span id="8529" class="nf kz iq mw b gy nk nh l ni nj">class HomeScreen extends React.Component {</span><span id="a6a2" class="nf kz iq mw b gy nk nh l ni nj">  <strong class="mw ir">static navigationOptions = () =&gt; {<br/>    <em class="kw">return</em> {<br/>      tabBarOnPress({ navigation, defaultHandler }) {</strong></span><span id="0f7e" class="nf kz iq mw b gy nk nh l ni nj">        // perform your logic here</span><span id="26e8" class="nf kz iq mw b gy nk nh l ni nj">        // this is mandatory to perform the actual switch<br/>        // don't call this if you want to prevent focus<br/><strong class="mw ir">        defaultHandler();<br/>      }<br/>    };<br/>  };</strong></span><span id="4be1" class="nf kz iq mw b gy nk nh l ni nj">  render() {<br/>    ...<br/>  }<br/>}</span></pre><p id="a451" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">或者，我们可以在导航器级别为所有选项卡设置它:</p><pre class="mx my mz na gt nb mw nc nd aw ne bi"><span id="bbdb" class="nf kz iq mw b gy ng nh l ni nj">// App.js</span><span id="7379" class="nf kz iq mw b gy nk nh l ni nj"><em class="kw">export</em> <em class="kw">default</em> createBottomTabNavigator({<br/>  Home: HomeScreen,<br/>  Settings: SettingsScreen<br/>}, {<br/><strong class="mw ir">  navigationOptions: {<br/>    tabBarOnPress: ({ navigation, defaultHandler }) =&gt; {</strong></span><span id="416c" class="nf kz iq mw b gy nk nh l ni nj">      // perform your logic here</span><span id="d25a" class="nf kz iq mw b gy nk nh l ni nj">      // this is mandatory to perform the actual switch<br/>      // don't call this if you want to prevent focus<br/><strong class="mw ir">      defaultHandler();<br/>    }<br/>  }<br/></strong>});</span></pre><p id="6cb2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您的逻辑可以直接在处理程序中执行，那么您就可以开始了。</p><p id="74fc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是如果你需要在组件上执行一些<strong class="ka ir">方法</strong>，或者访问组件的<strong class="ka ir">状态</strong>或者<strong class="ka ir">属性</strong>，你需要做一些额外的工作。</p><h2 id="1490" class="nf kz iq bd la ns nt dn le nu nv dp li kj nw nx lm kn ny nz lq kr oa ob lu oc bi translated">访问组件的状态、属性和方法</h2><p id="e1af" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj nl kl km kn nm kp kq kr nn kt ku kv ij bi translated">这是一种有点奇怪的方法。你必须:</p><ul class=""><li id="47b2" class="lw lx iq ka b kb kc kf kg kj no kn np kr nq kv nr me mf mg bi translated">使用<code class="fe mt mu mv mw b"><strong class="ka ir">setParams()</strong></code>方法在<code class="fe mt mu mv mw b">navigation</code>对象上设置一个<code class="fe mt mu mv mw b">param</code>；</li><li id="36d9" class="lw lx iq ka b kb mh kf mi kj mj kn mk kr ml kv nr me mf mg bi translated">从<code class="fe mt mu mv mw b"><strong class="ka ir">tabBarOnPress()</strong></code>打这个<code class="fe mt mu mv mw b">param</code>；</li><li id="febd" class="lw lx iq ka b kb mh kf mi kj mj kn mk kr ml kv nr me mf mg bi translated">从<code class="fe mt mu mv mw b">param</code>内部访问任何<code class="fe mt mu mv mw b">prop</code>、<code class="fe mt mu mv mw b">state</code>或<code class="fe mt mu mv mw b">method</code>，因为它是在组件的上下文中调用的；</li></ul><pre class="mx my mz na gt nb mw nc nd aw ne bi"><span id="87a8" class="nf kz iq mw b gy ng nh l ni nj">// HomeScreen.js</span><span id="b1bd" class="nf kz iq mw b gy nk nh l ni nj">class HomeScreen extends Component {</span><span id="9924" class="nf kz iq mw b gy nk nh l ni nj"><strong class="mw ir">  </strong>static navigationOptions = () =&gt; {<br/>    <em class="kw">return</em> {<br/>      tabBarOnPress({ navigation, defaultHandler }) {</span><span id="fcf4" class="nf kz iq mw b gy nk nh l ni nj">        <strong class="mw ir">navigation.state.params.onTabFocus();</strong></span><span id="47c3" class="nf kz iq mw b gy nk nh l ni nj">        defaultHandler();<br/>      }<br/>    };<br/>  };</span><span id="9ce9" class="nf kz iq mw b gy nk nh l ni nj">  constructor(props) {<br/>    <em class="kw">super</em>(props);<br/>    <strong class="mw ir">props.navigation.setParams({<br/>      onTabFocus: <em class="kw">this</em>.handleTabFocus<br/>    });</strong><br/>  }</span><span id="0950" class="nf kz iq mw b gy nk nh l ni nj">  <strong class="mw ir">handleTabFocus = () =&gt; {<br/>    // perform your logic here<br/>  };</strong></span><span id="0acd" class="nf kz iq mw b gy nk nh l ni nj">  ...</span><span id="5e9d" class="nf kz iq mw b gy nk nh l ni nj">}</span></pre><p id="792d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此外，您需要禁用选项卡导航器的延迟加载:</p><pre class="mx my mz na gt nb mw nc nd aw ne bi"><span id="9a7f" class="nf kz iq mw b gy ng nh l ni nj"><em class="kw">export</em> <em class="kw">default</em> createBottomTabNavigator({<br/>  ... // your screens<br/>}, {<br/><strong class="mw ir">  lazy: false<br/></strong>});</span></pre><blockquote class="oi oj ok"><p id="d558" class="jy jz kw ka b kb kc kd ke kf kg kh ki ol kk kl km om ko kp kq on ks kt ku kv ij bi translated"><strong class="ka ir">注意</strong>:该设置目前在文档中不可用</p></blockquote><p id="5ec6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以我们不直接访问状态或道具。相反，我们:</p><ul class=""><li id="183d" class="lw lx iq ka b kb kc kf kg kj no kn np kr nq kv nr me mf mg bi translated">使用<code class="fe mt mu mv mw b"><em class="kw">this</em>.props.navigation.setParams({ <em class="kw">myParam</em>: this.<em class="kw">myHandler</em> })</code>在导航对象上设置自定义参数</li><li id="a739" class="lw lx iq ka b kb mh kf mi kj mj kn mk kr ml kv nr me mf mg bi translated">所以这个自定义参数可以在navigationOptions中调用，使用<code class="fe mt mu mv mw b">navigation.state.params.<em class="kw">myParam</em></code></li></ul><p id="6d69" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好吧，这显然比使用声明性方法和<code class="fe mt mu mv mw b"><strong class="ka ir">NavigationEvents</strong></code>更样板化。但是通过这种方式，我们能够实现一些额外的功能。</p><h2 id="e950" class="nf kz iq bd la ns nt dn le nu nv dp li kj nw nx lm kn ny nz lq kr oa ob lu oc bi translated"><strong class="ak">防止标签焦点</strong></h2><p id="4621" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj nl kl km kn nm kp kq kr nn kt ku kv ij bi translated">这个很简单。如果忽略调用<code class="fe mt mu mv mw b">defaultHandler()</code>，选项卡将不会被聚焦:</p><pre class="mx my mz na gt nb mw nc nd aw ne bi"><span id="2646" class="nf kz iq mw b gy ng nh l ni nj">// HomeScreen.js</span><span id="480e" class="nf kz iq mw b gy nk nh l ni nj">class HomeScreen extends Component {</span><span id="0a5f" class="nf kz iq mw b gy nk nh l ni nj">  static navigationOptions = () =&gt; {<br/>    <em class="kw">return</em> {<br/>      tabBarOnPress({ navigation, defaultHandler }) {</span><span id="7bf9" class="nf kz iq mw b gy nk nh l ni nj"><strong class="mw ir">        if (/* some condition is met */) {<br/>          </strong>defaultHandler();<br/>  <strong class="mw ir">      }<br/></strong>      }<strong class="mw ir"><br/>    </strong>};<br/>  };<br/>  <br/>  ...</span><span id="3adf" class="nf kz iq mw b gy nk nh l ni nj">}</span></pre><h2 id="cbd1" class="nf kz iq bd la ns nt dn le nu nv dp li kj nw nx lm kn ny nz lq kr oa ob lu oc bi translated">手柄双击</h2><p id="0798" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj nl kl km kn nm kp kq kr nn kt ku kv ij bi translated">通常，移动应用程序会保存标签的内部状态。例如，如果在一个选项卡中有另一个<code class="fe mt mu mv mw b">StackNavigator</code>,当您导航到另一个选项卡并返回时，状态会被持久化。</p><p id="7e6a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一旦用户再次点击同一个标签，重置标签的内部状态是一种常见的模式。这很容易实现:</p><pre class="mx my mz na gt nb mw nc nd aw ne bi"><span id="317d" class="nf kz iq mw b gy ng nh l ni nj">// HomeScreen.js</span><span id="5315" class="nf kz iq mw b gy nk nh l ni nj">class HomeScreen extends Component {</span><span id="6dca" class="nf kz iq mw b gy nk nh l ni nj">  static navigationOptions = () =&gt; {<br/>    <em class="kw">return</em> {<br/>      tabBarOnPress({ navigation, defaultHandler }) {</span><span id="82ba" class="nf kz iq mw b gy nk nh l ni nj"><em class="kw">        </em><strong class="mw ir"><em class="kw">if</em> (navigation.isFocused()) {</strong><br/>          // same tab was tapped twice<br/>          // reset inner state<br/>          <strong class="mw ir">return;</strong><br/>        <strong class="mw ir">}</strong></span><span id="25c7" class="nf kz iq mw b gy nk nh l ni nj">        // tab was not previously focused<br/>        defaultHandler();<br/>      }<strong class="mw ir"><br/>    </strong>};<br/>  };<br/>  <br/>  ...</span><span id="2a05" class="nf kz iq mw b gy nk nh l ni nj">}</span></pre><p id="3237" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">见完整工作示例:<a class="ae kx" href="https://snack.expo.io/@andreipfeiffer/handle-tab-changes-in-react-navigation-v2" rel="noopener ugc nofollow" target="_blank"><em class="kw">https://snack . Expo . io/@ andreipfeifffer/handle-tab-changes-in-react-navigation-v2</em></a></p></div></div>    
</body>
</html>