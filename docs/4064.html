<html>
<head>
<title>Bypass SSL Pinning with LLDB on AppStore iOS apps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在AppStore iOS应用上使用LLDB绕过SSL锁定</h1>
<blockquote>原文：<a href="https://itnext.io/bypass-ssl-pinning-with-lldb-in-ios-app-b78f9e7cc9cd?source=collection_archive---------2-----------------------#2020-04-20">https://itnext.io/bypass-ssl-pinning-with-lldb-in-ios-app-b78f9e7cc9cd?source=collection_archive---------2-----------------------#2020-04-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/5edd13f3a552369e5b58dfcd70448e45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xk3wFwTMdRqNXDpM3Immtw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><strong class="bd kc">图:附LLDB】</strong></figcaption></figure><p id="8a47" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">假设您想要检查应用程序，以查看移动应用程序和服务器之间的信息交换，您可以考虑使用简单的代理工具来嗅探请求和响应，或者使用更高级的技术，如反向二进制文件来查看端点、参数和响应有效负载…为了开始SSL Pinning bypass系列，这篇文章将介绍如何利用LLDB工具来禁用iOS应用程序中的SSL Pinning和反向工程过程。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lb"><img src="../Images/0b53c6c708b7f20f9fa3edacdb0aa97e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ffX6N2_-3WPuCHKI"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae lg" href="https://unsplash.com/@nahelabdlhadi?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">纳赫尔·阿卜杜勒·哈迪</a>在<a class="ae lg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure></div><div class="ab cl lh li hu lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ij ik il im in"><h1 id="140c" class="lo lp iq bd kc lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">放弃</h1><p id="408b" class="pw-post-body-paragraph kd ke iq kf b kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">本帖仅用于教育目的，请自行使用，如果发现问题，请联系应用程序的作者。我们将检查一个应用程序名称编辑。帖子中的数字只是为了演示，可能与编辑的应用程序无关。</p><h1 id="3f19" class="lo lp iq bd kc lq mq ls lt lu mr lw lx ly ms ma mb mc mt me mf mg mu mi mj mk bi translated">先决条件</h1><p id="3d31" class="pw-post-body-paragraph kd ke iq kf b kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">本次开机自检期间使用了以下工具:</p><ul class=""><li id="99e8" class="mv mw iq kf b kg kh kk kl ko mx ks my kw mz la na nb nc nd bi translated">越狱装置。</li><li id="31cc" class="mv mw iq kf b kg ne kk nf ko ng ks nh kw ni la na nb nc nd bi translated"><a class="ae lg" href="https://support.portswigger.net/customer/portal/articles/1841109-Mobile%20Set-up_iOS%20Device%20-%20Installing%20CA%20Certificate.html" rel="noopener ugc nofollow" target="_blank">在iOS设备中安装Burp的CA证书</a></li><li id="a1e3" class="mv mw iq kf b kg ne kk nf ko ng ks nh kw ni la na nb nc nd bi translated"><a class="ae lg" href="https://support.portswigger.net/customer/portal/articles/1841108-configuring-an-ios-device-to-work-with-burp" rel="noopener ugc nofollow" target="_blank">配置iOS设备使用打嗝功能</a></li><li id="7762" class="mv mw iq kf b kg ne kk nf ko ng ks nh kw ni la na nb nc nd bi translated"><a class="ae lg" href="https://www.hopperapp.com/download.html" rel="noopener ugc nofollow" target="_blank">料斗拆卸器</a></li><li id="49b0" class="mv mw iq kf b kg ne kk nf ko ng ks nh kw ni la na nb nc nd bi translated"><a class="ae lg" href="https://kov4l3nko.github.io/blog/2016-04-27-debugging-ios-binaries-with-lldb/" rel="noopener ugc nofollow" target="_blank">设置LLDB环境</a></li></ul><h1 id="f65b" class="lo lp iq bd kc lq mq ls lt lu mr lw lx ly ms ma mb mc mt me mf mg mu mi mj mk bi translated">概观</h1><p id="9782" class="pw-post-body-paragraph kd ke iq kf b kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">我们想知道编校的应用程序如何与服务器交换信息，所以让我们选择Burp Suite作为代理工具来嗅探请求。启动Burp套件，并做一些必要的设置作为先决条件一节。启动应用程序时，观察Burp Suite中的<em class="nj"> HTTP history </em>选项卡，我们没有看到任何交换玩家信息或配置的请求，这里看起来有问题。正常情况下，当我们启动应用程序时，我们应该会看到一些获取应用程序配置或发送玩家状态(游戏应用程序)的请求……我们想到这可能是由于应用程序中采用的SSL pin。</p><p id="fb8c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你不知道什么是SSL pin，我建议参考这篇关于<a class="ae lg" href="https://appinventiv.com/blog/ssl-pinning-in-ios-app/" rel="noopener ugc nofollow" target="_blank">SSL pin如何工作的详细解释文章</a>。简而言之，SSL pin是客户端验证应用程序是否只与指定的服务器本身通信的一种方式。当应用程序实现SSL锁定时，通过代理服务器连接将不起作用，因为客户端会认为代理服务器是服务器，而不是真正的服务器，它不会建立到代理服务器的连接(由于代理服务器的证书/公钥与应用程序中捆绑的证书/公钥不匹配)，因此不会发出请求，也不会在<em class="nj"> HTTP历史</em>选项卡中显示任何记录。要让app请求出现在这个标签页上，我们需要想办法把<strong class="kf ir"> https </strong>请求降级为<strong class="kf ir"> http </strong>。当应用程序通过HTTP协议进行通信时，不需要SSL pin评估，我们的Burp Suite代理将轻松捕获所有信息。为了再次确认这一点，我们来做一些分析。^_^</p></div><div class="ab cl lh li hu lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ij ik il im in"><h1 id="b34e" class="lo lp iq bd kc lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">静态分析</h1><h2 id="9def" class="nk lp iq bd kc nl nm dn lt nn no dp lx ko np nq mb ks nr ns mf kw nt nu mj nv bi translated">检查。ipa资源</h2><p id="5ae3" class="pw-post-body-paragraph kd ke iq kf b kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">在<a class="ae lg" href="https://github.com/AloneMonkey/frida-ios-dump" rel="noopener ugc nofollow" target="_blank"> Frida iOS Dump </a>或<a class="ae lg" href="https://forum.iphonecake.com/index.php?/topic/363020-crackerxi-gui-app-decryption-tool-for-ios-11-12-13/" rel="noopener ugc nofollow" target="_blank"> CrackerXI </a>的帮助下，我们可以轻松拔出<strong class="kf ir">。越狱设备上的编校应用的ipa </strong>文件，解压<strong class="kf ir">。ipa </strong>并导航至Payload/redated . app文件夹。所有的应用程序资源和二进制文件都在这个文件夹中。</p><p id="9860" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们知道有两种方法可以进行SSL锁定:<strong class="kf ir">锁定证书</strong>或<strong class="kf ir">锁定公钥</strong>。Pin证书是实现SSL pin的更简单的方法，因为开发人员只需下载服务器的证书并将其捆绑在应用程序中，在运行时，应用程序会将服务器端证书与捆绑的证书进行比较。</p><p id="a757" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通常iOS应用程序中的证书文件会有<strong class="kf ir">。cer </strong>或<strong class="kf ir">。der </strong>扩展。这是<code class="fe nw nx ny nz b">DER</code>编码，你可以参考这篇<a class="ae lg" href="https://www.ssls.com/knowledgebase/what-are-certificate-formats-and-what-is-the-difference-between-them/" rel="noopener ugc nofollow" target="_blank">文章</a>了解更多细节。打开“终端”并导航到REDACTED.app内部，然后运行此命令来搜索证书文件:<code class="fe nw nx ny nz b">find . -name "*.cer"</code></p><pre class="lc ld le lf gt oa nz ob oc aw od bi"><span id="5c8f" class="nk lp iq nz b gy oe of l og oh">MBP# find . -name "*.cer"<br/>./redacted_test_ca.cer<br/>./redacted.cer<br/>./certificate.cer<br/>./redacted_certificate.cer<br/>./server_ranking.cer<br/>./mqttServer.cer</span></pre><p id="fd30" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">图1:查找证书文件</strong></p><p id="0448" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如我们所见，证书文件捆绑在应用程序中，因此我们可以说这个应用程序主要实现了SSL Pinning证书。如果您检查应用程序，并没有发现任何证书文件与此命令，它可能是开发人员固定的公钥。相反，您需要检查二进制文件。我将在另一个帖子中分享它。</p><p id="ea77" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在好了。让我们寻找应用程序正在使用的URL，因为这是网络框架将用于发出NSURLSession、AlamoFire、AFNetworking等请求的参数，仅举几例。</p><h2 id="b992" class="nk lp iq bd kc nl nm dn lt nn no dp lx ko np nq mb ks nr ns mf kw nt nu mj nv bi translated">搜寻基本URL (https)</h2><p id="ca87" class="pw-post-body-paragraph kd ke iq kf b kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">我们确信编校的应用程序正在使用安全的https端点与服务器通信，因为如果只是HTTP，那么它将显示在<em class="nj"> HTTP历史</em>选项卡中。大多数开发人员喜欢将应用程序的基本URL放在一些地方，以便在整个应用程序中重用:</p><ul class=""><li id="2902" class="mv mw iq kf b kg kh kk kl ko mx ks my kw mz la na nb nc nd bi translated">主机应用程序中的info . plist(REDACTED.app/Info.plist)</li><li id="1d19" class="mv mw iq kf b kg ne kk nf ko ng ks nh kw ni la na nb nc nd bi translated">主机应用程序中的Mach-O二进制文件(REDACTED.app/REDACTED)</li><li id="1a6d" class="mv mw iq kf b kg ne kk nf ko ng ks nh kw ni la na nb nc nd bi translated">框架中的Info.plist或Mach-O文件(该应用程序有专门的网络框架，例如REDACTED.app/Frameworks/NetworkXYZ.framework/Info.plist, REDACTED.app/Frameworks/NetworkXYZ.framework/NetworkXYZ…)</li></ul><p id="edde" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过使用<code class="fe nw nx ny nz b">strings</code>命令- <em class="nj">字符串开始搜索<strong class="kf ir"> https </strong>字符串，在二进制文件或标准输入中查找ASCII字符串。字符串对于识别随机目标文件和许多其他东西很有用</em>，我们可以在修订的Mach-O文件中找到一些结果。</p><pre class="lc ld le lf gt oa nz ob oc aw od bi"><span id="d2df" class="nk lp iq nz b gy oe of l og oh">MBP# strings -a REDACTED | grep https<br/>https://redacted-backend.redacted.com/<br/>https://www.redacted.com/games/redacted/privacy<br/>https://graph.facebook.com/<br/>https://private-redacted-api.redacted.com/</span></pre><p id="bc64" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">图2:找到基础HTTPS端点</strong></p><p id="0042" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">看起来<code class="fe nw nx ny nz b">https://redacted-backend.redacted.com</code>和<code class="fe nw nx ny nz b"><a class="ae lg" href="https://private-redacted" rel="noopener ugc nofollow" target="_blank">https://private-redacted</a>-api.redacted.com</code>才是可疑的人。这些可能是应用程序将使用的基本URL，并附加其他URL的路径来发出请求。是时候追踪这些URL字符串在应用程序中的使用位置了。我们可能需要Hopper反汇编程序的帮助。</p><h2 id="ca3f" class="nk lp iq bd kc nl nm dn lt nn no dp lx ko np nq mb ks nr ns mf kw nt nu mj nv bi translated">基本URL的跟踪引用— Hopper反汇编程序</h2><p id="36fe" class="pw-post-body-paragraph kd ke iq kf b kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">现在，让我们用Hopper反汇编工具来提升我们的静态分析技能——这是一个逆向工程工具，可以让你反汇编、反编译我们的应用程序。在这种情况下，我们使用Hopper将Mach-O文件反汇编成汇编指令(本例为arm64)并找到https字符串的引用。</p><p id="fd5c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">启动Hopper反汇编应用程序，然后将我们的REDACTED.app/REDACTED拖放到Hopper中，等待一段时间让它反汇编。完成后，切换到左侧面板上的<strong class="kf ir"> Str </strong>选项卡，搜索<code class="fe nw nx ny nz b">https://</code>字符串，它将显示与我们使用<code class="fe nw nx ny nz b">strings</code>命令完全相同的结果。让我们点击左边面板上的<code class="fe nw nx ny nz b">https://redacted-backend.redacted.com/</code>，它将导航到右边的这个地址:</p><pre class="lc ld le lf gt oa nz ob oc aw od bi"><span id="46ad" class="nk lp iq nz b gy oe of l og oh">0000000101522d9d  db  "https://redacted-backend.redacted.com/", 0  ; DATA XREF=cfstring_https___redacted_backend_redacted_com_</span></pre><p id="7e78" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">图3:在Hopper反汇编程序中找到基本HTTPS端点</strong></p><p id="5d98" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">双击<code class="fe nw nx ny nz b">DATA XREF=cfstring_https___redacted_backend_redacted_com_</code>查找它何时被引用，它将导航到新的位置并显示引用该字符串的方法。</p><pre class="lc ld le lf gt oa nz ob oc aw od bi"><span id="266c" class="nk lp iq nz b gy oe of l og oh">cfstring_https___redacted_backend_redacted_com_:<br/>00000001019c5170  dq  0x00000000000007c8 ; "https://redacted-backend.redacted.com/", DATA XREF=-[BackendController init]+112</span></pre><p id="e844" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">图4:料斗拆卸器中的HTTPS字符串引用</strong></p><p id="37b8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以看到，有一个方法使用这个字符串:<code class="fe nw nx ny nz b">-[BackendController init]</code>。如果您以前曾经开发过Objective-C应用程序，您应该熟悉这个语法。对于没有回答的人，让我长话短说。这是objective-C类初始化器(也称为构造函数)。所以用Swift语言来说应该是这样的<code class="fe nw nx ny nz b">BackendController.init()</code>。让我们双击这个<code class="fe nw nx ny nz b">-[BackendController init]</code>来导航到它的确切使用位置。</p><pre class="lc ld le lf gt oa nz ob oc aw od bi"><span id="9bfa" class="nk lp iq nz b gy oe of l og oh">    -[BackendController init]:<br/>...<br/>100037fdc  adrp       x8, #0x101f09000<br/>100037fe0  ldr        x0, [x8, #0x3c8]            ; objc_cls_ref_BackendHttpClient,__objc_class_BackendHttpClient_class<br/>100037fe4  adrp       x8, #0x101eb7000<br/>100037fe8  ldr        x20, [x8, #0xb88]           ; "alloc",<a class="ae lg" href="http://twitter.com/selector" rel="noopener ugc nofollow" target="_blank">@selector</a>(alloc)<br/>100037fec  mov        x1, x20<br/>100037ff0  bl         imp___stubs__objc_msgSend   ; objc_msgSend<br/>100037ff4  adrp       x8, #0x101eba000                        <br/>100037ff8  ldr        x1, [x8, #0x50]             ; "initWithBaseURL:",<a class="ae lg" href="http://twitter.com/selector" rel="noopener ugc nofollow" target="_blank">@selector</a>(initWithBaseURL:)<br/>100037ffc  adrp       x2, #0x1019c5000                            <br/>100038000  add        x2, x2, #0x170              ; @"<a class="ae lg" href="https://redacted-backend.redacted.com/" rel="noopener ugc nofollow" target="_blank">https://redacted-backend.redacted.com/</a>"<br/>100038004  bl         imp___stubs__objc_msgSend   ; objc_msgSend<br/>100038008  mov        x21, x0<br/>10003800c  adrp       x8, #0x101eba000            <br/>100038010  ldr        x1, [x8, #0x58]             ; "setHttpClient:",<a class="ae lg" href="http://twitter.com/selector" rel="noopener ugc nofollow" target="_blank">@selector</a>(setHttpClient:)<br/>100038014  mov        x0, x19<br/>100038018  mov        x2, x21<br/>10003801c  bl         imp___stubs__objc_msgSend   ; objc_msgSend<br/>100038020  mov        x0, x21<br/>...</span></pre><p id="1b7c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">图5: -【后端控制器初始化】</strong></p><p id="4cc7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请不要因为这些汇编指令而惊慌失措并放弃，我保证我会马上解释它们是什么。再仔细看看，你会发现这个字符串在地址<code class="fe nw nx ny nz b">100038000</code>被汇编指令<code class="fe nw nx ny nz b">add x2, x2, #0x170</code>和生成的注释<code class="fe nw nx ny nz b">; @"https://redacted-backend.redacted.com/"</code>引用。请记下这个地址<code class="fe nw nx ny nz b">100038000</code>，我们将在接下来的章节中调试应用程序时使用它。</p><h2 id="c554" class="nk lp iq bd kc nl nm dn lt nn no dp lx ko np nq mb ks nr ns mf kw nt nu mj nv bi translated">什么是ARM64指令？</h2><p id="2cc8" class="pw-post-body-paragraph kd ke iq kf b kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">我不会在这里解释ARM64指令的所有内容，但为了这篇文章，我会尝试解释一些基本的指令，以便您可以继续跟进(老实说，即使现在我仍然需要学习这种强大的语言，我最近迷上了它，并发现它就像一个益智游戏)。</p><p id="cca0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一、什么是汇编语言？让我引用来自<a class="ae lg" href="https://en.wikipedia.org/wiki/Assembly_language" rel="noopener ugc nofollow" target="_blank"> Wiki </a> : <em class="nj">的这个简短解释在计算机编程中，汇编语言(或汇编语言)，通常缩写为asm，是任何一种低级编程语言，其中语言中的指令和架构的机器代码指令之间有非常强的对应关系。因为汇编依赖于</em> <strong class="kf ir">机器码指令</strong> <em class="nj">，所以每一个汇编程序都有自己的汇编语言，专门为一个特定的</em> <strong class="kf ir">计算机架构</strong> <em class="nj">而设计。让我来分解一下这些术语:</em></p><ul class=""><li id="ce76" class="mv mw iq kf b kg kh kk kl ko mx ks my kw mz la na nb nc nd bi translated"><strong class="kf ir">机器码指令</strong> : Objective-C或者Swift都是高级语言。你的Objective-C或者Swift代码编译成汇编语言，是低级的。然后，汇编程序将这个程序集汇编成机器代码，以便CPU能够读取(0和1)。你可以在任何文本编辑器中打开密文文件，你会看到机器码指令:</li></ul><pre class="lc ld le lf gt oa nz ob oc aw od bi"><span id="3706" class="nk lp iq nz b gy oe of l og oh">cffa edfe 0c00 0001 0000 0000 0200 0000<br/>5c00 0000 2026 0000 8580 2100 0000 0000<br/>1900 0000 4800 0000 5f5f 5041 4745 5a45<br/>524f 0000 0000 0000 0000 0000 0000 0000<br/>0000 0000 0100 0000 0000 0000 0000 0000<br/>0000 0000 0000 0000 0000 0000 0000 0000<br/>0000 0000 0000 0000 1900 0000 0804 0000<br/>5f5f 5445 5854 0000 0000 0000 0000 0000<br/>0000 0000 0100 0000 00c0 9201 0000 0000<br/>0000 0000 0000 0000 00c0 9201 0000 0000<br/>0500 0000 0500 0000 0c00 0000 0000 0000<br/>5f5f 7465 7874 0000 0000 0000 0000 0000<br/>5f5f 5445 5854 0000 0000 0000 0000 0000<br/>b455 0000 0100 0000 c484 3101 0000 0000<br/>b455 0000 0200 0000 0000 0000 0000 0000<br/>0004 0080 0000 0000 0000 0000 0000 0000<br/>5f5f 7374 7562 7300 0000 0000 0000 0000<br/>5f5f 5445 5854 0000 0000 0000 0000 0000<br/>78da 3101 0100 0000 983a 0000 0000 0000<br/>78da 3101 0200 0000 0000 0000 0000 0000<br/>0804 0080 0000 0000 0c00 0000 0000 0000<br/>...</span></pre><p id="3344" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">图6:十六进制形式的机器代码</strong></p><ul class=""><li id="def7" class="mv mw iq kf b kg kh kk kl ko mx ks my kw mz la na nb nc nd bi translated"><strong class="kf ir">计算机架构</strong>:是CPU架构，比如。<code class="fe nw nx ny nz b">arm64</code>(是目前的64位ARM CPU架构，自iPhone 5S和更高版本以来一直使用)<code class="fe nw nx ny nz b">armv7s</code>(用于iPhone 5、iPhone 5C和iPad 4上的苹果A6和A6X芯片)<code class="fe nw nx ny nz b">armv7</code> (32位ARM CPU，用于A5和更早版本)<code class="fe nw nx ny nz b">x86_64</code> (64位英特尔模拟器)<code class="fe nw nx ny nz b">i386</code> (32位英特尔模拟器)iOS设备使用基于<a class="ae lg" href="http://en.wikipedia.org/wiki/ARM_architecture" rel="noopener ugc nofollow" target="_blank"> ARM架构的CPU</a>。在我看来，这比<a class="ae lg" href="https://en.wikipedia.org/wiki/X86_assembly_language" rel="noopener ugc nofollow" target="_blank"> x86_64 </a>指令集更容易阅读。</li><li id="41bd" class="mv mw iq kf b kg ne kk nf ko ng ks nh kw ni la na nb nc nd bi translated"><strong class="kf ir">寄存器</strong>:内存有一系列级别。靠近CPU的速度最快。在现代计算机中，这些通常类似于:CPU寄存器&gt; L1缓存&gt; L2缓存&gt; L3缓存&gt;主内存&gt;硬盘。处理器将使用一些内存存储位置，也称为寄存器。对于ARM64，有32个通用寄存器和一些特殊寄存器，请查看下面的详细信息以及何时可以使用。</li></ul><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oi"><img src="../Images/c24b647583022795c0b21d47bb226cab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6Kp7Plgr6wWp0ATjvVhPDA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><strong class="bd kc">图7:寄存器</strong></figcaption></figure><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oj"><img src="../Images/a239019f183c418e49790e4de961cf8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a_-kFvSY0vUz3orRmbQh8Q.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><strong class="bd kc">图8:寄存器用途</strong></figcaption></figure><ul class=""><li id="9d82" class="mv mw iq kf b kg kh kk kl ko mx ks my kw mz la na nb nc nd bi translated"><strong class="kf ir">汇编指令</strong>:有很多命令(操作码— opcode)，是CPU可以执行的单个指令。一般格式可以认为是<strong class="kf ir">指令</strong>，后跟<strong class="kf ir">操作数</strong> : <code class="fe nw nx ny nz b">Instruction Rd, Rn, Operand2</code>，其中<strong class="kf ir">指令</strong>是命令(MOV、SUB、ADD…)，<strong class="kf ir"> Rd </strong>是目的寄存器，<strong class="kf ir"> Rn </strong>是被操作的寄存器，<strong class="kf ir"> Operand2 </strong>可能是寄存器或立即值(例如。#0xff)。</li></ul><p id="14f6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我认为这就足够了，现在，当我们在下一节使用LLDB调试应用程序时，我会解释更多。</p></div><div class="ab cl lh li hu lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ij ik il im in"><h1 id="ce13" class="lo lp iq bd kc lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">动态分析</h1><p id="695b" class="pw-post-body-paragraph kd ke iq kf b kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">从XCode 5开始，LLDB与XCode完全集成，所以如果你是一名iOS开发人员，你应该已经熟悉了它的日常工作。我们可以从XCode或终端连接到正在运行的进程，在这篇文章中，我将从终端运行LLDB，并连接到越狱设备上正在运行的app。假设您已经在<strong class="kf ir">先决条件</strong>部分的越狱设备上安装了debugserver。</p><h2 id="72a3" class="nk lp iq bd kc nl nm dn lt nn no dp lx ko np nq mb ks nr ns mf kw nt nu mj nv bi translated">启动调试服务器</h2><p id="cd03" class="pw-post-body-paragraph kd ke iq kf b kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">让SSH连接到越狱设备，对我来说，应该是这样的:<code class="fe nw nx ny nz b">ssh ipse_home</code>，对你来说应该是<code class="fe nw nx ny nz b">ssh root@your_device_ip_address</code>。当出现密码提示时，您可能需要键入密码(默认密码是<code class="fe nw nx ny nz b">alpine</code>)。如果你想经常在越狱设备上调试，你可以像这样在你的<code class="fe nw nx ny nz b">~/.ssh/config</code>文件中创建一个SSH快捷方式(更多细节你可以参考这个<a class="ae lg" href="https://scotch.io/tutorials/how-to-create-an-ssh-shortcut" rel="noopener ugc nofollow" target="_blank">帖子</a>了解如何设置)，然后你可以通过快捷方式进行SSH。如果你经常使用SSH，你也可以使用SSH Keygen进行无密码登录。</p><pre class="lc ld le lf gt oa nz ob oc aw od bi"><span id="6c40" class="nk lp iq nz b gy oe of l og oh">Host ipse_home<br/>	HostName 192.168.1.113<br/>	User root</span></pre><p id="81f8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">图9: SSH快捷方式</strong></p><p id="0dba" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">SSH进入越狱设备后，我们将使用<code class="fe nw nx ny nz b">debugserver</code>连接到应用程序并监听来自其他机器的连接，然后从我们的笔记本电脑启动<code class="fe nw nx ny nz b">LLDB</code>连接到<code class="fe nw nx ny nz b">debugserver</code>进行远程调试。让我们一步一步来。</p><p id="9ba5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从终端SSH进入设备，然后运行这个命令:<code class="fe nw nx ny nz b">debugserver 0.0.0.0:1234 -w "Executable file"</code></p><ul class=""><li id="99f8" class="mv mw iq kf b kg kh kk kl ko mx ks my kw mz la na nb nc nd bi translated"><strong class="kf ir">可执行文件</strong>是我们要附加的进程名(这个值你需要从<code class="fe nw nx ny nz b">Info.plist</code>文件中获取)。</li><li id="91aa" class="mv mw iq kf b kg ne kk nf ko ng ks nh kw ni la na nb nc nd bi translated"><code class="fe nw nx ny nz b">0.0.0.0</code>是允许其他连接进行连接的IP范围(如果你知道远程调试机器的IP地址，那么为了安全请指定)。</li><li id="2eb9" class="mv mw iq kf b kg ne kk nf ko ng ks nh kw ni la na nb nc nd bi translated"><code class="fe nw nx ny nz b">1234</code>是端口号(如果您愿意，可以定义任意一个)。</li><li id="4e5b" class="mv mw iq kf b kg ne kk nf ko ng ks nh kw ni la na nb nc nd bi translated"><code class="fe nw nx ny nz b">-w</code>参数是<code class="fe nw nx ny nz b">--waitfor</code>的缩写，它将等待进程启动(如果尚未启动)或立即附加(如果已经启动)。</li></ul><pre class="lc ld le lf gt oa nz ob oc aw od bi"><span id="b176" class="nk lp iq nz b gy oe of l og oh">iPhone-SE:~ root# debugserver 0.0.0.0:1234 -w REDACTED<br/>debugserver-@(#)PROGRAM:LLDB  PROJECT:lldb-900.3.57..2<br/> for arm64.<br/>Waiting to attach to process REDACTED...</span></pre><p id="1902" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">图10:启动调试服务器</strong></p><p id="605b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">假设你已经使用Burp Suite代理配置了越狱设备，这个应用程序还没有启动，然后在上面的<code class="fe nw nx ny nz b">debugserver</code>命令中启动。每当你看到输出<code class="fe nw nx ny nz b">Waiting to attach to process</code>，是时候从越狱设备启动我们的应用程序了，你可以从终端看到它会打印出新的消息<code class="fe nw nx ny nz b">Listening to port 1234 for a connection from 0.0.0.0...</code>，这意味着它成功连接并等待连接调试。</p><pre class="lc ld le lf gt oa nz ob oc aw od bi"><span id="17a0" class="nk lp iq nz b gy oe of l og oh">iPhone-SE:~ root# debugserver 0.0.0.0:1234 -w REDACTED<br/>debugserver-@(#)PROGRAM:LLDB  PROJECT:lldb-900.3.57..2<br/> for arm64.<br/>Waiting to attach to process REDACTED...<br/>Listening to port 1234 for a connection from 0.0.0.0...</span></pre><p id="344c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">图11:调试服务器附加流程</strong></p><h2 id="2d71" class="nk lp iq bd kc nl nm dn lt nn no dp lx ko np nq mb ks nr ns mf kw nt nu mj nv bi translated">启动LLDB</h2><p id="9eea" class="pw-post-body-paragraph kd ke iq kf b kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">在这篇文章中，我们将使用LLDB作为独立的调试器，而不是通过XCode调试功能(XCode控制台窗格)使用LLDB调试器。因此，让LLDB命令行给我们带来一些乐趣，为什么不呢？</p><p id="bf4c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让乐趣开始吧。打开终端的另一个标签，运行<code class="fe nw nx ny nz b">lldb</code>命令。</p><pre class="lc ld le lf gt oa nz ob oc aw od bi"><span id="3535" class="nk lp iq nz b gy oe of l og oh">MBP# lldb<br/>(lldb)</span></pre><p id="11d4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">图12:启动LLDB独立版</strong></p><p id="e657" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe nw nx ny nz b">lldb</code>提示符下，键入<code class="fe nw nx ny nz b">platform select remote-ios</code>然后<code class="fe nw nx ny nz b">process connect connect://192.168.1.113:1234</code>通过<code class="fe nw nx ny nz b">debugserver</code>连接到我们的app(进程)中(记住<code class="fe nw nx ny nz b">192.168.1.113</code>是越狱设备的IP地址)。如果我们可以成功地附加到该进程，您将在终端中看到该日志:</p><pre class="lc ld le lf gt oa nz ob oc aw od bi"><span id="a153" class="nk lp iq nz b gy oe of l og oh">(lldb) platform select remote-ios<br/>  Platform: remote-ios<br/> Connected: no<br/>  SDK Path: "/Users/xyz/Library/Developer/Xcode/iOS DeviceSupport/13.3.1 (17D50) arm64e"<br/> SDK Roots: [ 0] "/Users/xyz/Library/Developer/Xcode/iOS DeviceSupport/13.3.1 (17D50) arm64e"<br/> SDK Roots: [ 1] "/Users/xyz/Library/Developer/Xcode/iOS DeviceSupport/11.3.1 (15E302)"<br/> SDK Roots: [ 2] "/Users/xyz/Library/Developer/Xcode/iOS DeviceSupport/11.0 (15A372)"<br/> SDK Roots: [ 3] "/Users/xyz/Library/Developer/Xcode/iOS DeviceSupport/12.4 (16G77)"<br/>Process 19596 stopped<br/>* thread #1, queue = 'com.apple.main-thread', stop reason = signal SIGSTOP<br/>    frame #0: 0x000000018104e3b0 libsystem_c.dylib`strlen  + 48<br/>libsystem_c.dylib`strlen:<br/>-&gt;  0x18104e3b0 &lt;+48&gt;: ldr         	q0, [x1, #0x10]!<br/>    0x18104e3b4 &lt;+52&gt;: uminv.16b 	b1, v0<br/>    0x18104e3b8 &lt;+56&gt;: fmov 		w2, s1<br/>    0x18104e3bc &lt;+60&gt;: cbnz 		w2, 0x18104e3b0 	; &lt;+48&gt;<br/>Target 0: (REDACTED) stopped.</span></pre><p id="616e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">图13:附加到进程的LLDB</strong></p><p id="423e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果<code class="fe nw nx ny nz b">lldb</code>显示SDK路径错误或其他情况，您可以仔细检查您的设备iOS版本是否存在于XCode iOS DeviceSupport中。你可以参考这篇很棒的<a class="ae lg" href="https://kov4l3nko.github.io/blog/2016-04-27-debugging-ios-binaries-with-lldb/#problems-and-solutions" rel="noopener ugc nofollow" target="_blank">帖子</a>来解决问题。</p><p id="c96c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">每次您想在<code class="fe nw nx ny nz b">lldb</code>提示符下调试应用程序时，您都需要键入上述两个命令，为了节省时间，LLDB allow to config命令可以在<code class="fe nw nx ny nz b">lldb</code>启动时加载。你只需要复制这两个命令并输入<code class="fe nw nx ny nz b">~/.lldbinit</code>就可以了。这是我的样本<code class="fe nw nx ny nz b">~/.lldbinit</code>文件:</p><pre class="lc ld le lf gt oa nz ob oc aw od bi"><span id="29d8" class="nk lp iq nz b gy oe of l og oh">## .lldbinit start ###<br/>command alias rr register read<br/>command alias rw register write<br/>command alias mr memory read<br/>command alias mw memory write<br/>command alias il image list -o -f<br/>command alias eoc expression -l objc -O --<br/><br/>platform select remote-ios<br/>process connect connect://192.168.1.113:1234</span></pre><p id="7107" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">图14: ~/。lldbinit </strong></p><p id="7f57" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您也可以在这里定义<code class="fe nw nx ny nz b">lldb</code>命令别名，它会在<code class="fe nw nx ny nz b">lldb</code>提示符下生效。但是如果你是一个iOS开发人员，这里会有一个问题，因为这个文件也会应用于XCode中的LLDB，这意味着当你在XCode中调试一个应用程序时，它也会加载这个init文件，并且会花费你更多的时间来启动这个应用程序。要分离LLDB standalone和XCode的LLDB之间的配置，您可以创建一个新的<code class="fe nw nx ny nz b">~/.lldbinit-Xcode</code>文件，并将您的命令放在那里，只供XCode使用。每当你通过XCode调试应用程序时，它会检查<code class="fe nw nx ny nz b">~/.lldbinit-Xcode</code>文件是否存在，然后XCode会加载这个文件而不是<code class="fe nw nx ny nz b">~/.lldbinit</code>。</p><h2 id="987b" class="nk lp iq bd kc nl nm dn lt nn no dp lx ko np nq mb ks nr ns mf kw nt nu mj nv bi translated">设置断点</h2><p id="8ec5" class="pw-post-body-paragraph kd ke iq kf b kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">现在，<code class="fe nw nx ny nz b">lldb</code>附加在app进程上等待我们调试，你可能会注意到，由于进程正在被中断，app挂在了越狱的设备上。调试过程和我们在XCode中调试的过程是一样的，除了在XCode中你调试每一行代码，这里你调试每一行汇编指令，你检查寄存器而不是变量。在检查寄存器之前，让我们先设置一个断点。回到Hopper反汇编程序，转到<code class="fe nw nx ny nz b">-[BackendController init]</code>方法的地址<code class="fe nw nx ny nz b">0x100038000</code>，我们需要在这个地址设置断点，看看应用程序是否会调用这个方法，并检查传递给寄存器的URL字符串的值(在Hopper反汇编程序中，按下<code class="fe nw nx ny nz b">G</code>，然后输入要导航到的地址值)。在LLDB中，要在某个地址设置断点，我们可以键入:<code class="fe nw nx ny nz b">breakpoint set --address 0x100038000</code>，或者简称为<code class="fe nw nx ny nz b">br s -a 0x100038000</code>，然后输入。</p><pre class="lc ld le lf gt oa nz ob oc aw od bi"><span id="ea5d" class="nk lp iq nz b gy oe of l og oh">(lldb) breakpoint set --address 0x100038000<br/>warning: failed to set breakpoint site at 0x100038000 for breakpoint 1.1: error: 0 sending the breakpoint request<br/>Breakpoint 1: address: 0x100038000</span></pre><p id="5d1f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">图15: LLDB设置断点失败</strong></p><p id="abbb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是看那个警告，在<code class="fe nw nx ny nz b">0x100038000</code>设置断点失败。为什么？？？失败的原因是因为<strong class="kf ir"> ASLR(地址空间布局随机化)</strong>。<a class="ae lg" href="https://searchsecurity.techtarget.com/definition/address-space-layout-randomization-ASLR" rel="noopener ugc nofollow" target="_blank"> ASLR是一种针对操作系统(OS)的内存保护进程，它通过随机化系统可执行文件加载到内存的位置来防范缓冲区溢出攻击。</a>。我们需要在进程运行时计算真实地址来设置断点(每次启动app都需要重新计算真实地址)。<code class="fe nw nx ny nz b">Real Address = ASLR shift + Hopper Address</code>，找出缺失的部分<code class="fe nw nx ny nz b">ASLR Shift</code>。</p><p id="4406" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe nw nx ny nz b">lldb</code>提示符下，键入<code class="fe nw nx ny nz b">image list -o processName</code>然后回车，控制台中的结果是<code class="fe nw nx ny nz b">ASLR shift</code>(请注意，该值可能与您的不同，因为它是一个随机数)。</p><pre class="lc ld le lf gt oa nz ob oc aw od bi"><span id="c137" class="nk lp iq nz b gy oe of l og oh">(lldb) image list -o REDACTED<br/>[ 0] 0x00000000045bc000<br/>(lldb)</span></pre><p id="670e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">图十六:ASLR换挡</strong></p><p id="f68e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我的案子<code class="fe nw nx ny nz b">ASLR Shift = 0x00000000045bc000</code>，所以<code class="fe nw nx ny nz b">Real Address = ASLR shift + Hopper Address = 0x00000000045bc000+0x100038000 = 0x1045F4000</code>。让我们重新设置断点:<code class="fe nw nx ny nz b">br s -a 0x00000000045bc000+0x100038000</code>或<code class="fe nw nx ny nz b">br s -a 0x1045F4000</code>然后回车。</p><pre class="lc ld le lf gt oa nz ob oc aw od bi"><span id="ba7f" class="nk lp iq nz b gy oe of l og oh">(lldb) br s -a 0x00000000045bc000+0x100038000<br/>Breakpoint 2: where = REDACTED`___lldb_unnamed_symbol1321$$REDACTED + 112, address: 0x00000001045F4000</span></pre><p id="1ca1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">图17:断点设置成功</strong></p><p id="5508" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们刚刚成功设置了断点，现在通过键入:<code class="fe nw nx ny nz b">continue</code>或<code class="fe nw nx ny nz b">c</code>让进程继续运行，然后回车。它将运行应用程序一秒钟，然后你会看到它将再次停止在控制台中，它命中断点！！！！</p><pre class="lc ld le lf gt oa nz ob oc aw od bi"><span id="7d08" class="nk lp iq nz b gy oe of l og oh">(lldb) c<br/>Process 19596 resuming<br/>Process 19596 stpped<br/>* thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 2.1<br/>	frame #0: 0x00000001045f4000 REDACTED`___lldb_unnamed_symbol1321$$REDACTED + 112<br/>REDACTED`___lldb_unnamed_symbol1321$$REDACTED<br/>-&gt;  0x1045f4000 &lt;+112&gt;: add   x2, x2, #0x170 ; =0x170<br/>    0x1045f4004 &lt;+116&gt;: bl    0x1058dcae4    ; symbol stub for: objc_msgSend<br/>    0x1045f4008 &lt;+120&gt;: mov   x21, x0<br/>    0x1045f400c &lt;+124&gt;: adrp  x8, 7810<br/>Target 0: (REDACTED) stopped.<br/>(lldb)</span></pre><p id="cdd5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">图18: LLDB命中断点</strong></p><h2 id="426d" class="nk lp iq bd kc nl nm dn lt nn no dp lx ko np nq mb ks nr ns mf kw nt nu mj nv bi translated">检查寄存器</h2><p id="6836" class="pw-post-body-paragraph kd ke iq kf b kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">您可以看到进程在指令<code class="fe nw nx ny nz b">add x2, x2, #0x170</code>处的断点(地址<code class="fe nw nx ny nz b">0x1045F4000</code>处)停止。让我们在Hopper反汇编程序中再次查看这些说明:</p><pre class="lc ld le lf gt oa nz ob oc aw od bi"><span id="9dc6" class="nk lp iq nz b gy oe of l og oh">    -[BackendController init]:<br/>...<br/>100037fdc  adrp       x8, #0x101f09000<br/>100037fe0  ldr        x0, [x8, #0x3c8]            ; objc_cls_ref_BackendHttpClient,__objc_class_BackendHttpClient_class<br/>100037fe4  adrp       x8, #0x101eb7000<br/>100037fe8  ldr        x20, [x8, #0xb88]           ; "alloc",<a class="ae lg" href="http://twitter.com/selector" rel="noopener ugc nofollow" target="_blank">@selector</a>(alloc)<br/>100037fec  mov        x1, x20<br/>100037ff0  bl         imp___stubs__objc_msgSend   ; objc_msgSend<br/>100037ff4  adrp       x8, #0x101eba000                        <br/>100037ff8  ldr        x1, [x8, #0x50]             ; "initWithBaseURL:",<a class="ae lg" href="http://twitter.com/selector" rel="noopener ugc nofollow" target="_blank">@selector</a>(initWithBaseURL:)<br/>100037ffc  adrp       x2, #0x1019c5000                            <br/>100038000  add        x2, x2, #0x170              ; @"<a class="ae lg" href="https://redacted-backend.redacted.com/" rel="noopener ugc nofollow" target="_blank">https://redacted-backend.redacted.com/</a>"<br/>100038004  bl         imp___stubs__objc_msgSend   ; objc_msgSend<br/>100038008  mov        x21, x0<br/>10003800c  adrp       x8, #0x101eba000            <br/>100038010  ldr        x1, [x8, #0x58]             ; "setHttpClient:",<a class="ae lg" href="http://twitter.com/selector" rel="noopener ugc nofollow" target="_blank">@selector</a>(setHttpClient:)<br/>100038014  mov        x0, x19<br/>100038018  mov        x2, x21<br/>10003801c  bl         imp___stubs__objc_msgSend   ; objc_msgSend<br/>100038020  mov        x0, x21<br/>...</span></pre><p id="21c4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">图19:说明解释</strong></p><p id="d669" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我为那些指令添加了注释，<code class="fe nw nx ny nz b">add x2, x2, #0x170</code>可以翻译成<code class="fe nw nx ny nz b">x2 = x2 + #0x170 = #0x1019c5000 + #0x170 = 0x1019c5170</code>，这是<code class="fe nw nx ny nz b">https://redacted-backend.redacted.com/</code>的地址(你可以回头看上面的<strong class="kf ir">图4</strong>), Hopper反汇编器足够聪明，可以找出注释并将其放在这条指令的末尾。所以在执行这条指令后，我们期望x2的值是<code class="fe nw nx ny nz b">https://redacted-backend.redacted.com/</code>。让type <code class="fe nw nx ny nz b">next</code>或<code class="fe nw nx ny nz b">n</code>然后回车执行该指令。</p><p id="60bc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在要检查寄存器<code class="fe nw nx ny nz b">x2</code>的值，您可以键入<code class="fe nw nx ny nz b">po $x2</code> (po是打印对象)或<code class="fe nw nx ny nz b">register read x2</code>，您将看到寄存器<code class="fe nw nx ny nz b">x2</code>现在保存着包含字符串<code class="fe nw nx ny nz b"><a class="ae lg" href="https://redacted-backend.redacted.com" rel="noopener ugc nofollow" target="_blank">https://redacted-backend.redacted.com/</a></code>的地址</p><pre class="lc ld le lf gt oa nz ob oc aw od bi"><span id="c804" class="nk lp iq nz b gy oe of l og oh">(lldb) next<br/>Process 19596 stopped<br/>* thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 2.1<br/> frame #0: 0x00000001045f4004 REDACTED`___lldb_unnamed_symbol1321$$REDACTED + 116<br/>REDACTED`___lldb_unnamed_symbol1321$$REDACTED<br/>-&gt;  0x1045f4004 &lt;+116&gt;: bl    0x1058dcae4    ; symbol stub for: objc_msgSend<br/>    0x1045f4008 &lt;+120&gt;: mov   x21, x0<br/>    0x1045f400c &lt;+124&gt;: adrp  x8, 7810<br/>    0x1045f4010 &lt;+128&gt;: ldr   x1, [x8, #0x58]<br/>Target 0: (REDACTED) stopped.<br/>(lldb) po $x2<br/><a class="ae lg" href="https://redacted-backend.redacted.com" rel="noopener ugc nofollow" target="_blank">https://redacted-backend.redacted.com</a>/</span><span id="9480" class="nk lp iq nz b gy ok of l og oh">(lldb) register read x2<br/> x2 = 0x0000000105f81170   @"<a class="ae lg" href="https://redacted-backend.redacted.com" rel="noopener ugc nofollow" target="_blank">https://redacted-backend.redacted.com</a>/"</span></pre><p id="76bf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">图20:检查寄存器x2 </strong></p><h2 id="2d92" class="nk lp iq bd kc nl nm dn lt nn no dp lx ko np nq mb ks nr ns mf kw nt nu mj nv bi translated">更改寄存器值</h2><p id="2907" class="pw-post-body-paragraph kd ke iq kf b kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">由于我们处于调试模式，改变寄存器的值是微不足道的。我们想将<code class="fe nw nx ny nz b">https</code>降级为<code class="fe nw nx ny nz b">http</code>协议，因此我们需要将寄存器<code class="fe nw nx ny nz b">x2</code>的值从<code class="fe nw nx ny nz b">https://redacted-backend.redacted.com/</code>更改为<code class="fe nw nx ny nz b">http://redacted-backend.redacted.com/</code>，让我们这样做:</p><ul class=""><li id="4cc0" class="mv mw iq kf b kg kh kk kl ko mx ks my kw mz la na nb nc nd bi translated">首先，让我们通过:<code class="fe nw nx ny nz b">expression @"http://redacted-backend.redacted.com/"</code>或<code class="fe nw nx ny nz b">e @"http://redacted-backend.redacted.com/"</code>创建新的<code class="fe nw nx ny nz b">http://redacted-backend.redacted.com/</code>字符串，它将吐出用该字符串在内存中的地址创建的新字符串。如下，<code class="fe nw nx ny nz b">0x00000001c0c63740</code>是我的案例的新字符串的地址:</li></ul><pre class="lc ld le lf gt oa nz ob oc aw od bi"><span id="f626" class="nk lp iq nz b gy oe of l og oh">(lldb) expression @"http://redacted-backend.redacted.com/"<br/>(__NSCFString *) $5 = 0x00000001c0c63740 @"http://redacted-backend.redacted.com/"<br/>(lldb)</span></pre><p id="2efe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">图21:创建一个新的字符串</strong></p><ul class=""><li id="7163" class="mv mw iq kf b kg kh kk kl ko mx ks my kw mz la na nb nc nd bi translated">接下来，我们需要通过<code class="fe nw nx ny nz b">register write x2 0x00000001c0c63740</code>设置寄存器<code class="fe nw nx ny nz b">x2</code>来保存新值，并再次检查其值，我们可以看到<code class="fe nw nx ny nz b">x2</code>现在反映了新值。</li></ul><pre class="lc ld le lf gt oa nz ob oc aw od bi"><span id="6c1b" class="nk lp iq nz b gy oe of l og oh">(lldb) register write x2 0x00000001c0c63740<br/>(lldb) po $x2<br/>http://redacted-backend.redacted.com/<br/><br/>(lldb)</span></pre><p id="fed2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">图22:将寄存器x2更改为新值</strong></p><ul class=""><li id="e84e" class="mv mw iq kf b kg kh kk kl ko mx ks my kw mz la na nb nc nd bi translated">最后，只需键入<code class="fe nw nx ny nz b">c</code>即可恢复应用程序，因此它将继续使用新的URL端点运行，流程不再遇到断点，查看Hopper反汇编器，我们可以看到所有的<code class="fe nw nx ny nz b">http://redacted-backend.redacted.com/</code>端点都显示在<em class="nj"> HTTP History </em>选项卡中，包含请求和响应的详细信息，任务完成！！！</li></ul><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ol"><img src="../Images/f209fabdecea57097a384ba3127a2c90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4cxgIFBAYxMdIUi4vLpH4Q.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><strong class="bd kc">图23:料斗拆装器可以看到应用请求&amp;响应</strong></figcaption></figure><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi om"><img src="../Images/435390aabbedb2cb051331c4b8df2f3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*R5kSaJ7QJVfNL5z7"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">我看到了光——照片由<a class="ae lg" href="https://unsplash.com/@snowidesignz?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">埃利亚斯·毛雷尔</a>在<a class="ae lg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="1658" class="lo lp iq bd kc lq mq ls lt lu mr lw lx ly ms ma mb mc mt me mf mg mu mi mj mk bi translated">最终想法</h1><ul class=""><li id="1210" class="mv mw iq kf b kg ml kk mm ko on ks oo kw op la na nb nc nd bi translated">SSL Pinning只适用于<code class="fe nw nx ny nz b">https</code>协议，所以要降级到<code class="fe nw nx ny nz b">http</code>请求，我们可以很容易地绕过它</li><li id="289d" class="mv mw iq kf b kg ne kk nf ko ng ks nh kw ni la na nb nc nd bi translated">编校服务器支持<code class="fe nw nx ny nz b">http</code>和<code class="fe nw nx ny nz b">https</code>协议，所以当降级到<code class="fe nw nx ny nz b">http</code>时应用程序可以正常工作</li><li id="d02e" class="mv mw iq kf b kg ne kk nf ko ng ks nh kw ni la na nb nc nd bi translated">对于不支持<code class="fe nw nx ny nz b">http</code>协议的服务器，这种SSL锁定旁路将不起作用，但是我们可以让代理将<code class="fe nw nx ny nz b">http</code>重定向到<code class="fe nw nx ny nz b">https</code>，这样它就可以工作了(客户端将<code class="fe nw nx ny nz b">http</code>请求发送到代理- &gt;代理将<code class="fe nw nx ny nz b">http</code>重写为<code class="fe nw nx ny nz b">https</code>请求并发送到服务器)</li><li id="4df1" class="mv mw iq kf b kg ne kk nf ko ng ks nh kw ni la na nb nc nd bi translated">LLDB很厉害！！玩寄存器是我们可以学习的高级技能。你可以做任何事情，只要你能在运行的应用程序中附加一个调试器。</li><li id="fe1c" class="mv mw iq kf b kg ne kk nf ko ng ks nh kw ni la na nb nc nd bi translated">这个app没有越狱和反调试检测，所以我们可以不受限制的为所欲为。如果你想保护应用程序，你需要考虑在你的代码中使用这种检测。</li></ul><h1 id="e131" class="lo lp iq bd kc lq mq ls lt lu mr lw lx ly ms ma mb mc mt me mf mg mu mi mj mk bi translated">进一步阅读</h1><ul class=""><li id="0a7f" class="mv mw iq kf b kg ml kk mm ko on ks oo kw op la na nb nc nd bi translated"><a class="ae lg" href="https://www.objc.io/issues/19-debugging/lldb-debugging/" rel="noopener ugc nofollow" target="_blank">在调试器中跳舞——和LLDB跳华尔兹</a></li><li id="f768" class="mv mw iq kf b kg ne kk nf ko ng ks nh kw ni la na nb nc nd bi translated"><a class="ae lg" href="https://appinventiv.com/blog/ssl-pinning-in-ios-app/" rel="noopener ugc nofollow" target="_blank">iOS应用中的SSL锁定</a></li><li id="0b19" class="mv mw iq kf b kg ne kk nf ko ng ks nh kw ni la na nb nc nd bi translated"><a class="ae lg" href="https://en.wikipedia.org/wiki/Assembly_language" rel="noopener ugc nofollow" target="_blank">汇编语言维基</a></li><li id="524c" class="mv mw iq kf b kg ne kk nf ko ng ks nh kw ni la na nb nc nd bi translated"><a class="ae lg" href="http://en.wikipedia.org/wiki/ARM_architecture" rel="noopener ugc nofollow" target="_blank"> ARM架构</a></li></ul><h2 id="0a80" class="nk lp iq bd kc nl nm dn lt nn no dp lx ko np nq mb ks nr ns mf kw nt nu mj nv bi translated">我希望这篇文章对你有所帮助。请在Twitter(<a class="ae lg" href="https://twitter.com/ReverseThatApp" rel="noopener ugc nofollow" target="_blank">@ reverse thatap</a>)上关注并联系我，以获得我即将在^_^发布的帖子的通知</h2></div></div>    
</body>
</html>