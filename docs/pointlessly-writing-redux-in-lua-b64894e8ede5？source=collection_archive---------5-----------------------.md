# ESP8266 上的 Redux

> 原文：<https://itnext.io/pointlessly-writing-redux-in-lua-b64894e8ede5?source=collection_archive---------5----------------------->

![](img/82c39af64069d5380991191755dae13c.png)

照片由[克里斯里德](https://unsplash.com/@cdr6934?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 拍摄

## 为什么我用 Lua 写 Redux

## 重构我的物联网节点 MCU

*这篇文章讲述了我在 Lua 中使用中间件编写 Redux 所面临的挑战。我想做的只是为 NodeMCU 的 ESP8266 清理一些我自己的遗留代码，结果做了一些比最初看起来或需要的更复杂的事情。*

# 历史

当我在 2017 年夏天买下这所房子时，我开始为我的智能家居开发定制软件。随之而来的是对 NodeMCU (ESP8266)等嵌入式系统的需求。

我的第一个也是唯一的项目是控制我的车库门。我用 C 和 Lua 写了两个不同的版本。我买了一个专为这类事情设计的叶片开关，这样我的软件就能知道车库是开着还是关着。我用这些数据来确定我是否忘记关车库了。我相信你以前也有过同样的感觉！

我从来没有买过一根长长的车库门电缆来安装它，尽管我已经编写了所有的软件，测试了它，并且做好了一切准备。没过多久，我换了工作，停止了所有的个人项目。我觉得买一个智能车库门开启器会更容易，然后在车库里多放一个 Nest Cam，就为了那一点点额外的想法。

# 智能花环灯

快进到 2018 年平安夜奥运会。我们又要举办家庭圣诞派对了。虽然我已经按计划为所有的圣诞树安装了 WeMo 智能插头，但我和妻子从来都不记得打开壁炉架上的电池供电的花环灯。我想如果它至少和 Alexa 连上了，我们就更有可能打开它。

经过一些初步测试后，我发现隐藏在电池盒顶部的两个引脚实际上需要 3V 来为灯供电。这正是电池盒中的两节 D 电池所提供的电量。我现在需要做的就是在连接两个引脚的一根电线之间放一个继电器，然后我就可以控制回路了！

# 重构

我拿着旧的车库门软件开始重构。按照我编写 Lua 版本的方式，它将加载一个带有 3 个端点的简单 web 服务器:

```
GET /status
GET /garage-door/off
GET /garage-door/on
```

我知道这不是超级安全的，也没有使用`POST`或`PUT`来执行这些命令，但它仍然是我最初的原型。想法是用 fauxmo 库设置 Node.js 服务。当您请求 Alexa 更改该设备的状态时，Node.js 服务将调用 NodeMCU web 服务器上的 on 或 off 端点。如果我需要调试什么，我可以简单地使用`/status`端点。

# 过度嫉妒

当我在修改旧的车库门代码以适应 garland 灯时，我开始发现旧的代码很难读懂，使用 Redux 可以清理它。因为我已经编写了一个类似 Redux 的库来允许 reducers 用于 React 组件，所以我认为为 Lua 编写 Redux 应该是小菜一碟。哦，我错了！

首先，我的 Lua 生锈了。我从来没有真正学过它，我最后一次真正使用它是在几年前我开发 [Pulsen](https://pulsengame.com/game) 的时候，那是我的第一个也是唯一一个游戏。

其次，嵌入式环境与我们的标准操作系统完全不同。我的内存被限制在 64K，调试很麻烦，因为我必须监听串行接口。在监听串行接口时，我无法同时上传文件更改。每次出现错误，我都必须关闭串行监听器，发送更新的文件，然后重启设备。

我遇到了一些其他问题，比如“如何通过 HTTP 发送回 JSON？”。或者更好的是“我如何将这个套接字协议转换成 HTTP？”。我在 NodeMCU 上挂接的库直接使用 HTTP 套接字，而不是 Express.js 如何处理它。NodeMCU ROM 确实有一个可用的 webserver 库，但是我记得上次它引起了一些问题，所以我避开了它。

哦，对了，表格合并是另一个问题。在 JavaScript 中，我可以使用`Object.assign`或 spread 操作符，但是在 Lua 中，我完全迷失了。我最终在一个 StackOverflow 答案中找到了一个合并函数，它允许我组合 Lua 表，而不用引入一个占用大量内存的库。当组合 Redux 状态的各个部分时，这是必需的。

在某个时候，我开始收到奇怪的错误信息。后来，我发现这是因为内存不足。通常情况下，缩小会有帮助，但我没有大小限制；我的记忆受到限制。我最终编译了 Lua 文件，然后传输了它们。最后，我有足够的内存来测试。遗憾的是，在这种模式下，我无法调试错误，因为每个错误都是第 1 行中的一些神秘消息。简直是浪费我的时间。

另一个问题涉及文件导入。我在早期使用了`dofile`,但是意识到把一切都放在全局范围内。我后来改用了`loadfile`，如果你不知道的话，结果看起来很蠢，就像这样:

```
local actions = loadfile('actions.lc')()
```

Yes `loadfile`返回一个函数。然后，您必须调用该函数来获取文件数据。而且我相信如果你的文件不存在，你会得到`nil`，相当于`null`。我只是假设所有导入的文件都在那里，因为我把它们放在那里了。

由于 NodeMCU 专有的 Lua 代码，我无法在我的主机系统中使用 Lua 解释器测试除语法之外的任何东西。ESP8266 芯片也没有仿真器或调试板。如果我有一个，哦，男孩！

我想我终于可以在早上 6 点或 7 点左右睡觉了。我真的可以只手动打开加兰圣诞节，然后就完事了，但是不行，我必须去写一套物联网软件，包括一个完整的国家管理库！如果我只是做了简单的重构，我就不必处理内存不足的问题，并且可以更早地入睡。哦，好吧，现在我有一篇文章要写，还有一个我再也用不到的 Redux 库。

# Lua 中的 Redux 呢？

那么这个 Redux 实现是什么呢？它有什么了不起的？完全是 Redux。它有三个基本功能:`dispatch`、`getState`和`subscribe`。`subscribe`函数很容易编写，因为它只是添加订户。`dispatch`也一样简单，因为它只是一个接一个地调用每个订户，甚至不传递状态。然后`getState`，ooh boy。`function() return state end`。你能再简单点吗？

不。事实上，事情变得更复杂了。`dispatch`不仅仅是给用户打电话。你必须采取行动，调用所有减速器，并创建一个新的`state`。遗憾的是，我没有`combineReducers`来帮助我，所以我不得不在 Lua 表(想想 JS 中的 object props)中获取一个命名的 reducers 列表并遍历它们，确保将新的状态片添加到`state`中的适当位置。

# 一切都错了！

这就是我整个系统设计的错误之处。我需要添加副作用。当 Redux 只在 state 中存储值时，它不是很有用；这就是`subscribe`功能存在的原因。在 react-redux 中，副作用是更新组件属性。在这个项目中，它改变 GPIO 并发回 web 请求。

Redux 有两种副作用。**中间件**，用于当您需要知道被调用的动作并可能调用其他动作时，以及**订户**，用于当您只需要知道`state`何时更新时。

实现一个 reducer 来存储当前的 GPIO 状态有点没用，因为即使是我的`/status`端点也可以直接请求当前的引脚状态，而根本不需要 Redux。在这样的嵌入式系统上，那会节省我很多时间。就在这个时候，我有了一个顿悟的时刻:为这个项目编写 Redux 比我最初想象的还要无用。最重要的是，我也花了很多时间在这上面。

看，因为我复制-粘贴-修改了车库代码，所以除了重写那里的代码之外，我什么也没想。可悲的是，我实际上并不需要那部分代码；将状态存储在内存中的部分。在我最初的车库门实现中，这是一个糟糕的设计选择，导致我花费了所有不必要的时间为 Lua 编写 Redux。如果我想到我最初的实现，而不是简单地重写它——认为它会很有趣——使用 Redux，我会为自己节省很多时间，早点睡觉，并为我的超级简单的解决方案感到高兴。

# 为什么要用 Redux 中间件？

因为我已经在这一点上，我想完成我开始了。事实上，我还没有遇到内存问题。这些将在 Redux 中间件开发期间的某个时候开始。

我有几个选择。我可以将 **GPIO** 副作用写成一个`subscribe`方法，它需要创建一个 reducer 并将 GPIO 状态存储在 Redux 的状态中。或者，我可以编写中间件，这样我就可以编写类似于 reducer 的东西，只处理副作用。这样，我不需要在状态中重复存储 GPIO。我选择了后者，但还是把我的减速器留在了那里，doh！

除了 GPIO，我还需要一种方法来返回有效的 **HTTP 响应**。我本可以在我的网络服务器上直接使用`subscribe`方法，但是有一个问题。我需要知道 pin 的当前状态。为此，我可以简单地返回当前的 GPIO 值。在这种特殊情况下，我根本不需要等待 Redux！

对于另外两个端点，我可以不返回任何东西，只返回一个 HTTP 200，但是我想只在您更改了当前的 GPIO 状态之后才返回它，以便于调试。这意味着我需要我的 web 服务器响应来自 Redux 中间件，因为我需要监听一个在有效载荷中包含了`socket`的`SEND_RESPONSE`动作，这样我就可以做`socket:send(httpResponse)`。

这对于我所需要的来说太复杂了，因为我需要调用`sendResponse`，现在我的 Redux 动作需要包含一个`socket`道具。我就知道这个系统是代码味的，但是这个时候已经这么晚了，我也不想费神去想。

# 向 Redux 添加中间件功能

整个 Redux 项目有趣的部分是添加中间件的挑战。在我的 React components 文章中，前面的实现不包括中间件功能，所以中间件代码只是等待编写。即使它是 Lua，我也要在那里得到那个功能！

Redux 中间件的一个有趣之处在于，它是一个返回函数的函数，而函数又返回函数。所有中间件彼此异步运行。为了实现这一点，我们为您提供了一个`next`回调。稍微想了一下，才知道回调只是`store.dispatch`。

当一个中间件函数想要返回值时，它实际上只是调度另一个动作；否则，它返回 void。这个动作可以触发一个 reducer 写状态，或者触发另一个中间件功能，就像我的例子一样。它甚至可以什么都不返回！Redux 中间件真的很神奇。

这是从`dispatch`函数看起来的样子:

```
middlewareFunction(store)(store.dispatch)(action)
```

这就是编写中间件的样子:

为什么这个不叫`dispatch`而叫`next`？让我怀疑我是不是不了解 Redux。不大；我的实现仍然遵循中间件 API。

请在这里随意查看其余复杂的源代码:

[](https://github.com/Sawtaytoes/Living-Room-Garland/tree/master/app) [## 锯脚趾/客厅花环

### 智能家居控制器，处理客厅花环上圣诞灯的开关状态…

github.com](https://github.com/Sawtaytoes/Living-Room-Garland/tree/master/app) 

# 结论

我做到了！我最终用一种完全不同的语言编写了 Redux 的中间件组件。总而言之，完全没用。刚刚在网上看了之后，其他人也已经为 Lua 写了他们自己的 Redux 库，如果我今天重写这个项目，它根本不会包含它。我可以通过完全去除复杂性的代码来清理它，而不是使用 Redux。

我学到的重要一点是，仅仅做最少量的工作是不够的。有时候，在编写代码之前，最好重新考虑整个架构和设计。显然，过去的我做了一些愚蠢的事情，因此我在此时此地遭受了痛苦。难过，但我还是写了很酷的东西！

当我在写这两个中间件函数时，我在想如果使用 RxLua 而不是自己写中间件该有多好。一旦我遇到内存限制，那就不会发生了。哦好吧。用 Lua 写我自己的 Redux-Observable 会很酷。

# 更多阅读

如果你喜欢你所读的，你也应该检查我的其他文章；尤其是 Redux 上的那些:

*   [在 React 组件中使用 Redux 还原剂](/using-redux-reducers-in-react-components-4e92985dd9cb)
*   使用 Redux 的秘密:createNamespaceReducer
*   [为什么你不需要 React-Redux 的“连接”](https://medium.com/@Sawtaytoes/why-you-shouldnt-need-connect-from-react-redux-498876de9e4e)
*   [Redux-Observable 可以解决你的状态问题](https://medium.com/@Sawtaytoes/redux-observable-can-solve-your-state-problems-15b23a9649d7)