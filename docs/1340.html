<html>
<head>
<title>Custom Scalars in GraphQL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">GraphQL中的自定义标量</h1>
<blockquote>原文：<a href="https://itnext.io/custom-scalars-in-graphql-9c26f43133f3?source=collection_archive---------2-----------------------#2018-09-17">https://itnext.io/custom-scalars-in-graphql-9c26f43133f3?source=collection_archive---------2-----------------------#2018-09-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="6189" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">GraphQL提供了一小组预定义的<em class="kl">标量</em>类型:<code class="fe km kn ko kp b">Boolean</code>、<code class="fe km kn ko kp b">ID</code>、<code class="fe km kn ko kp b">Int</code>、<code class="fe km kn ko kp b">Float</code>和<code class="fe km kn ko kp b">String</code>。但是我们也可以定义自己的自定义标量类型。在本文中，我们将通过一个基于Apollo服务器的例子来看看如何做到这一点。</p><p id="f6ce" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">自定义类型的一个常见用途是表示日期和时间。对日期/时间值进行编码有不同的方式:作为ISO-8601字符串，例如<code class="fe km kn ko kp b">2018-09-16T17:27:33.963Z</code>。或者作为Unix时间戳，即类似于<code class="fe km kn ko kp b">1537118853</code>的数字，表示自<em class="kl">纪元</em>(1970年1月1日)以来经过的秒数。或者也可以是从epoch开始的<em class="kl">毫秒</em>，例如<code class="fe km kn ko kp b">1537118853231</code>。</p><p id="cd6e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">假设我们想使用ISO-8601，因为它是一个标准，也更容易被人理解。</p><h1 id="ae18" class="kq kr iq bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">(计划或理论的)纲要</h1><p id="e171" class="pw-post-body-paragraph jn jo iq jp b jq lo js jt ju lp jw jx jy lq ka kb kc lr ke kf kg ls ki kj kk ij bi translated">我们可以像这样声明一个模式(假设我们的整个API由一个返回<code class="fe km kn ko kp b">time</code>值的查询组成):</p><pre class="lt lu lv lw gt lx kp ly lz aw ma bi"><span id="8184" class="mb kr iq kp b gy mc md l me mf">type Query {<br/>  time: String<br/>}</span></pre><p id="83c7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是这并没有真正告诉我们的客户，我们返回的<code class="fe km kn ko kp b">String</code>不仅仅是一个字符串，它是一个代表日期/时间值的ISO-8601字符串。</p><p id="9662" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是我们如何声明并使用一个名为<code class="fe km kn ko kp b">DateTime</code>的自定义标量类型:</p><pre class="lt lu lv lw gt lx kp ly lz aw ma bi"><span id="230f" class="mb kr iq kp b gy mc md l me mf">scalar DateTime</span><span id="24c3" class="mb kr iq kp b gy mg md l me mf">type Query {<br/>  time: DateTime<br/>}</span></pre><p id="5f38" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这样我们就清楚了<code class="fe km kn ko kp b">time</code>的类型是<code class="fe km kn ko kp b">DateTime</code>。</p><p id="3de1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不可否认的是，看着上面的类型定义，我们真的不能断定一个<code class="fe km kn ko kp b">DateTime</code>被表示为一个ISO-8601字符串。但是当我们开始实现我们的自定义标量实现时，我们会注意这一点。我们将提供一个将在模式文档中显示的描述。</p><p id="511d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，Github GraphQL API定义了自己的<a class="ae mh" href="https://developer.github.com/v4/scalar/datetime/" rel="noopener ugc nofollow" target="_blank"> DateTime </a>标量，其文档解释说它是“一个ISO-8601编码的UTC日期字符串”。</p><h1 id="1f13" class="kq kr iq bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">履行</h1><p id="68b4" class="pw-post-body-paragraph jn jo iq jp b jq lo js jt ju lp jw jx jy lq ka kb kc lr ke kf kg ls ki kj kk ij bi translated">在模式中定义自定义标量类型是不够的。我们还需要告诉GraphQL引擎在编写响应或读取请求时，如何从代码中使用的内部表示转换该类型的值。</p><p id="e94a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，我们可以在代码中使用JavaScript <code class="fe km kn ko kp b">Date</code>对象来表示日期/时间，但是在生成GraphQL响应时，我们希望将JavaScript <code class="fe km kn ko kp b">Date</code>转换成ISO-8601字符串。</p><p id="b99a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们看看这是如何在Apollo Server的JavaScript中实现的。</p><p id="7508" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">作为示例的起点，我们将使用<a class="ae mh" href="https://github.com/mirkonasato/graphql-examples" rel="noopener ugc nofollow" target="_blank">mirkonasato/GraphQL-examples</a>Github存储库中的基本graph QL服务器和客户端项目。所以，如果你想在你的机器上尝试代码，那么就按照文件中的设置说明去做。</p><p id="f887" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<code class="fe km kn ko kp b">server</code>项目中，我们可以通过将<code class="fe km kn ko kp b">server.js</code>中的<code class="fe km kn ko kp b">typeDefs</code>值改为我们上面定义的模式来开始，即:</p><pre class="lt lu lv lw gt lx kp ly lz aw ma bi"><span id="f448" class="mb kr iq kp b gy mc md l me mf">const typeDefs = gql`<br/>  scalar DateTime<br/><br/>  type Query {<br/>    time: DateTime<br/>  }<br/>`;</span></pre><p id="4cd6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后我们可以更改<code class="fe km kn ko kp b">resolvers</code>对象，通过返回一个新的Date对象来响应<code class="fe km kn ko kp b">time</code>查询:</p><pre class="lt lu lv lw gt lx kp ly lz aw ma bi"><span id="c822" class="mb kr iq kp b gy mc md l me mf">const resolvers = {<br/>  Query: {<br/>    time: () =&gt; new Date()<br/>  }<br/>};</span></pre><p id="e0b3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，我们进入正题:我们的定制<code class="fe km kn ko kp b">DateTime</code>实现。这也适用于<code class="fe km kn ko kp b">resolvers</code>对象，就像我们的模式中声明的任何其他自定义类型和字段一样:</p><pre class="lt lu lv lw gt lx kp ly lz aw ma bi"><span id="f797" class="mb kr iq kp b gy mc md l me mf">const { GraphQLScalarType } = require('graphql');<br/><br/>const typeDefs = /*…*/;<br/><br/>const resolvers = {<br/>  DateTime: new GraphQLScalarType({<br/>    name: 'DateTime',<br/>    description: 'A date and time, represented as an ISO-8601 string',<br/>    serialize: (value) =&gt; value.toISOString(),<br/>    parseValue: (value) =&gt; new Date(value),<br/>    parseLiteral: (ast) =&gt; new Date(ast.value)<br/>  }),<br/><br/>  Query: /*…*/<br/>};</span></pre><p id="5f44" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们使用核心<code class="fe km kn ko kp b">graphql</code>库中的<a class="ae mh" href="https://graphql.org/graphql-js/type/#graphqlscalartype" rel="noopener ugc nofollow" target="_blank"> GraphQLScalarType </a>类来创建一个新的自定义标量。</p><p id="6e9b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们通过<code class="fe km kn ko kp b">name</code>和<code class="fe km kn ko kp b">description</code>，那应该是自圆其说。在<code class="fe km kn ko kp b">description</code>中，我们可以证明<code class="fe km kn ko kp b">DateTime</code>值是一个ISO-8601字符串。</p><p id="a0db" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，我们需要告诉GraphQL引擎如何<code class="fe km kn ko kp b">serialize</code>一个值，即在编写响应时将它从JavaScript <code class="fe km kn ko kp b">Date</code>对象转换为ISO-8601字符串。因为我们知道<code class="fe km kn ko kp b">value</code>是一个JavaScript <code class="fe km kn ko kp b">Date</code>，我们可以简单地使用它的<a class="ae mh" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString" rel="noopener ugc nofollow" target="_blank"> toISOString </a>方法。</p><p id="2e1d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">类似地，我们需要为<em class="kl">解析</em>一个值提供逻辑，即从GraphQL请求中读取它，在那里它将被编码为ISO-8601字符串，并将其转换为JavaScript <code class="fe km kn ko kp b">Date</code>对象，以便在我们的代码中内部使用。</p><p id="7c1c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于这种情况，我们实际上需要提供两个不同的函数:<code class="fe km kn ko kp b">parseValue</code>接收原始值，即一个ISO-8601字符串，而<code class="fe km kn ko kp b">parseLiteral</code>接收一个<em class="kl">抽象语法树</em> (AST)对象。AST由GraphQL引擎在解析请求时生成。</p><p id="0b01" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这两种情况下，我们都可以通过将<code class="fe km kn ko kp b">value</code>作为构造函数参数传递来创建一个新的<code class="fe km kn ko kp b">Date</code>对象，因为<a class="ae mh" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date" rel="noopener ugc nofollow" target="_blank">日期构造函数</a>可以接受一个ISO-8601字符串作为参数。</p><p id="7ebe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是让我们的示例正常工作所需的最少代码量。理想情况下，我们应该通过检查<code class="fe km kn ko kp b">value</code>实际上是预期的类型，如果不是，抛出一个错误，等等，使我们的代码更加健壮。但是对于这个例子，我们将保持简单。</p><p id="b551" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于真实世界的使用，<a class="ae mh" href="https://github.com/okgrow/graphql-scalars" rel="noopener ugc nofollow" target="_blank">@ ok grow/graph QL-scalars</a>库提供了许多现成的定制标量，包括更完整的<a class="ae mh" href="https://github.com/okgrow/graphql-scalars/blob/master/src/DateTime.js" rel="noopener ugc nofollow" target="_blank"> DateTime </a>实现。</p><h1 id="9c45" class="kq kr iq bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">操场</h1><p id="cf93" class="pw-post-body-paragraph jn jo iq jp b jq lo js jt ju lp jw jx jy lq ka kb kc lr ke kf kg ls ki kj kk ij bi translated">如果我们启动服务器并打开位于<a class="ae mh" href="http://localhost:9000/" rel="noopener ugc nofollow" target="_blank"> localhost:9000 </a>的GraphQL Playground，我们现在应该在模式文档浏览器中看到我们的<code class="fe km kn ko kp b">DateTime</code>标量:</p><figure class="lt lu lv lw gt mj gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/8e57fb949d03adbc99c73bd5f015daf8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/format:webp/0*P96RKpmTx2yNp0TF.png"/></div></figure><p id="5790" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此时，我们可以发送一个查询:</p><pre class="lt lu lv lw gt lx kp ly lz aw ma bi"><span id="784c" class="mb kr iq kp b gy mc md l me mf">query {<br/>  time<br/>}</span></pre><p id="f6d3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们应该收到这样的回应:</p><pre class="lt lu lv lw gt lx kp ly lz aw ma bi"><span id="39dd" class="mb kr iq kp b gy mc md l me mf">{<br/>  "data": {<br/>    "time": "2018-09-17T10:46:55.328Z"<br/>  }<br/>}</span></pre><p id="b910" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这表明GraphQL响应包含一个ISO-8601，尽管在我们的<code class="fe km kn ko kp b">time</code>解析器函数中，我们返回了一个JavaScript <code class="fe km kn ko kp b">Date</code>对象。我们的<code class="fe km kn ko kp b">DateTime</code>标量正在执行转换。</p><h1 id="7fc8" class="kq kr iq bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">客户</h1><p id="8f06" class="pw-post-body-paragraph jn jo iq jp b jq lo js jt ju lp jw jx jy lq ka kb kc lr ke kf kg ls ki kj kk ij bi translated">这就是更新的服务器。客户呢？</p><p id="f784" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">默认情况下，客户端将接收到字符串形式的<code class="fe km kn ko kp b">time</code>字段，正如我们在上面的JSON响应中看到的。</p><p id="4030" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要将字符串转换成JavaScript <code class="fe km kn ko kp b">Date</code>对象，我们还需要将我们的自定义<code class="fe km kn ko kp b">DateTime</code>实现插入到我们的客户端代码中。事实上，我们可以用其他语言编写客户端，比如Android的Java和iOS的Swift。因此，这些客户端需要自己的特定于语言的自定义标量实现。例如，Java版本可以将字符串转换成一个<code class="fe km kn ko kp b">java.util.Date</code>实例。</p><p id="18e4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是使用自定义标量的缺点。它们不受开箱即用的支持，我们需要使我们的定制逻辑对任何想要使用它们的项目可用。或者简单地让客户端以普通字符串的形式接收<code class="fe km kn ko kp b">DateTime</code>值。</p><p id="7e0a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">示例存储库包括一个使用Apollo客户端的简单React应用程序。事实证明，Apollo客户端目前不支持自定义标量(问题<a class="ae mh" href="https://github.com/apollographql/apollo-feature-requests/issues/2" rel="noopener ugc nofollow" target="_blank">Apollo-feature-requests # 2</a>)。因此，我们必须以字符串形式接收我们的<code class="fe km kn ko kp b">time</code>值，并在收到响应时手动转换它。例如在<code class="fe km kn ko kp b">src/queries.js</code>中有:</p><pre class="lt lu lv lw gt lx kp ly lz aw ma bi"><span id="200e" class="mb kr iq kp b gy mc md l me mf">export async function getTime() {<br/>  const {data: {time}} = await client.query({<br/>    query: gql`<br/>      query TimeQuery {<br/>        time<br/>      }<br/>    `<br/>  });<br/>  return new Date(time);<br/>}</span></pre><p id="c612" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个例子的完整代码可以在<a class="ae mh" href="https://github.com/mirkonasato/graphql-examples/tree/custom-scalar" rel="noopener ugc nofollow" target="_blank">自定义标量</a>分支中找到，你也可以只查看<a class="ae mh" href="https://github.com/mirkonasato/graphql-examples/compare/custom-scalar" rel="noopener ugc nofollow" target="_blank">相关的变化</a>。</p><h1 id="d6d6" class="kq kr iq bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">结论</h1><p id="b35b" class="pw-post-body-paragraph jn jo iq jp b jq lo js jt ju lp jw jx jy lq ka kb kc lr ke kf kg ls ki kj kk ij bi translated">如果每个客户端仍然需要自己的逻辑来正确解释它们，那么使用定制标量值得吗？还是坚持使用预定义的标量类型更好？这是你或你的团队的设计决策。</p><p id="9c05" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我个人认为，在任何情况下，服务器在其模式中使用自定义标量都是有价值的，可以更有意义地表示其API。</p></div><div class="ab cl mm mn hu mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ij ik il im in"><p id="1d39" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">最初发表于</em><a class="ae mh" href="https://encoded.io/graphql-custom-scalars/" rel="noopener ugc nofollow" target="_blank"><em class="kl">encoded . io</em></a><em class="kl">。</em></p></div></div>    
</body>
</html>