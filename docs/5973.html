<html>
<head>
<title>Speed-up your Python applications using Lithops and Serverless Cloud resources</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Lithops和无服务器云资源加速您的Python应用程序</h1>
<blockquote>原文：<a href="https://itnext.io/speed-up-your-python-applications-using-lithops-and-serverless-cloud-resources-a64beb008bb5?source=collection_archive---------4-----------------------#2021-07-15">https://itnext.io/speed-up-your-python-applications-using-lithops-and-serverless-cloud-resources-a64beb008bb5?source=collection_archive---------4-----------------------#2021-07-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="7164" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">无服务器计算的兴起。</p><p id="73a0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">大多数用户或企业应用程序本质上都是并行的。并行的高级特性通常用于增强应用程序的性能。也就是说，减少应用程序完成所需的总时间，充分利用大部分可用资源。</p><p id="98ab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本文旨在解释串行和并行编程之间的区别，并展示我们如何利用“无服务器”云资源来加速我们的python应用程序。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/d96ad121e2e7c1ec9b8f21aeb08fc51c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GaNd9AkU5shfHq1A"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">照片由<a class="ae lc" href="https://unsplash.com/@aronvisuals?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Aron视觉效果</a>在<a class="ae lc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="8af3" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">从串行编程到并行编程</h1><p id="605e" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">在编写python应用程序时，新手用户开始编写<em class="kl">【串行】</em>代码，也就是在一种<em class="kl">【意大利面】</em>应用程序中一个接一个的指令，这是非常常见的。在这种情况下，当程序被执行时，代码使用计算机中的一个核心来执行应用程序直到结束。让我们看下一个例子:</p><pre class="kn ko kp kq gt mg mh mi bn mj mk bi"><span id="25bf" class="ml le iq mh b be mm mn l mo mp">import time<br/><br/>def f(x):<br/>    time.sleep(10)<br/>    return x*x<br/><br/>if __name__ == '__main__':<br/>    for i in [1, 2, 3]:<br/>        print(f(i))</span></pre><p id="fb3a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要知道一个应用程序是串行执行还是并行执行，最简单的方法是测量它完成的时间。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi mq"><img src="../Images/136fef040d30afe9da8bbba87b71db7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8WUqAoaHWeYAjV3TcqHvEQ.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">串行执行3个任务</figcaption></figure><p id="c967" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如您所见，这个简单的串行应用程序需要30秒来完成它的执行。这是因为每个<em class="kl"> f(i) </em>执行都需要前一个执行完成才能开始。好吧，但是我们怎样才能加速这段代码呢？</p><p id="c44c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在大多数计算机都有多个内核。新的处理器架构使得在一台普通笔记本电脑中集成16个(或更多)内核成为可能。这个事实使得你在执行<em class="kl">“串行”</em>应用程序时，放弃了计算机的大部分计算能力。因此，人们可以很容易地推断，通过使用计算机的所有核心，我们可以大大加快任何应用程序的速度。从这个意义上来说，python <a class="ae lc" href="https://docs.python.org/3/library/multiprocessing.html" rel="noopener ugc nofollow" target="_blank"> <em class="kl">多处理</em> </a> <em class="kl"> </em>库更容易利用计算机的所有(或仅所需)内核。让我们看下一个例子:</p><pre class="kn ko kp kq gt mg mh mi bn mj mk bi"><span id="af49" class="ml le iq mh b be mm mn l mo mp">import time<br/>from multiprocessing import Pool<br/><br/>def f(x):<br/>    time.sleep(10)<br/>    return x*x<br/><br/>if __name__ == '__main__':<br/>    with Pool() as p:<br/>        print(p.map(f, [1, 2, 3]))</span></pre><p id="8bf0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个应用程序是前一个示例的等效并行版本。在这种情况下，<em class="kl"> Pool() </em>将检测我们笔记本电脑中的可用内核(假设我们的笔记本电脑有4个内核)，并创建一个包含4个准备执行任务的进程的池。创建池时，进程保持空闲状态，等待任务。为了提交任务，我们需要调用一个可用的<a class="ae lc" href="https://docs.python.org/3/library/multiprocessing.html#module-multiprocessing.pool" rel="noopener ugc nofollow" target="_blank">多处理操作</a>。在这个例子中，我们调用<em class="kl"> p.map() </em>操作，为列表<em class="kl"> [1，2，3]中的每个值生成一个<em class="kl"> f() </em>函数。也就是说</em>，这段代码将<em class="kl"> f(1) </em>、<em class="kl"> f(2) </em>和<em class="kl"> f(3) </em>提交到池中，然后，<em class="kl">、</em>由于池中有4个空闲进程，其中3个进程将各自获取这些任务中的一个并并行运行。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi mr"><img src="../Images/8bcde59b7e4c1f99d89af767533e94a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UXE-KaDzK-GDevD3uSkoqQ.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">并行执行3项任务</figcaption></figure><p id="b429" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这种情况下，执行只花了10秒钟。<em class="kl">这太棒了！</em>这显示了并行性的好处。但是如果我们把输入列表增加到比如说100个元素呢？</p><pre class="kn ko kp kq gt mg mh mi bn mj mk bi"><span id="ac4a" class="ml le iq mh b be mm mn l mo mp">if __name__ == '__main__':<br/>    with Pool() as p:<br/>        print(p.map(f, range(100))</span></pre><p id="5e17" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这种情况下，<em class="kl"> p.map() </em>操作将向池中提交100个任务。然而，笔记本电脑只有4个内核，因此它只能处理4乘4的任务。这意味着，在最后，这个应用程序大约需要250秒才能完成。让我们检查一下:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi ms"><img src="../Images/338e7247d7140026070110094948711f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JFPBiy9zErzR5SVAl7PwsQ.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">并行执行100个任务</figcaption></figure><p id="36fb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">行刑花了280秒才完成。这比预期多了30秒。这是由于<em class="kl">多处理</em>库是如何内部构建的，表明当任务多于核心时它会有一些开销，这导致了瓶颈。</p></div><div class="ab cl mt mu hu mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ij ik il im in"><p id="17cd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">到目前为止，我们已经演示了如何将一个简单的应用程序从串行迁移到并行，展示了并行的好处，以及由于资源有限而导致并行度较低时的缺点。现在是时候做更大的梦和思考了；如果一个应用程序是为处理大量数据而设计的呢？如果我的笔记本电脑的内核很少，获得的速度很低怎么办？如果即使使用计算机的所有内核，应用程序仍然需要几个小时才能完成，那该怎么办？<strong class="jp ir">别着急，云上千核等你；)</strong></p><h1 id="fdc3" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">Lithops来救援了</h1><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi na"><img src="../Images/980f677d84cd2d74545b0e888bd2057f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nfhcp3HUNwd87oQiAcGbcw.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">Lithops标志</figcaption></figure><p id="6a4f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在是介绍<strong class="jp ir"> Lithops、</strong>python框架的时候了，它允许将你的多进程应用程序扩展到云中。Lithops在后台使用无服务器计算平台，对您完全透明地完成这项任务。让它工作的唯一要求是在你的应用程序中修改一行代码。</p><p id="1660" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">无服务器？</strong>无服务器是一种计算模式，允许在云中执行被称为<em class="kl">功能</em>的计算单元任务。在无服务器计算中，数百(或数千)个内核可在几秒钟内立即供您使用，只需为您使用的确切资源付费。</p><p id="b5cd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">透明？</strong> Lithops将用户的代码和数据交付到云中，而不需要了解它如何部署和运行到无服务器平台中。</p><p id="94cd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Lithops是一个开源项目，可在<a class="ae lc" href="https://github.com/lithops-cloud/lithops" rel="noopener ugc nofollow" target="_blank"> Github </a>上获得:</p><div class="nb nc gp gr nd ne"><a href="https://github.com/lithops-cloud/lithops" rel="noopener  ugc nofollow" target="_blank"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd ir gy z fp nj fr fs nk fu fw ip bi translated">石质云/石质</h2><div class="nl l"><h3 class="bd b gy z fp nj fr fs nk fu fw dk translated">Lithops是一个Python多云分布式计算框架。它允许在…上运行未修改的本地python代码</h3></div><div class="nm l"><p class="bd b dl z fp nj fr fs nk fu fw dk translated">github.com</p></div></div><div class="nn l"><div class="no l np nq nr nn ns kw ne"/></div></div></a></div><p id="c3f6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你是Lithops的新手，也请阅读这篇博文:</p><div class="nb nc gp gr nd ne"><a rel="noopener  ugc nofollow" target="_blank" href="/lithops-a-multi-cloud-serverless-programming-framework-fd97f0d5e9e4"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd ir gy z fp nj fr fs nk fu fw ip bi translated">Lithops，一个多云无服务器编程框架</h2><div class="nl l"><h3 class="bd b gy z fp nj fr fs nk fu fw dk translated">无服务器计算的兴起</h3></div><div class="nm l"><p class="bd b dl z fp nj fr fs nk fu fw dk translated">itnext.io</p></div></div><div class="nn l"><div class="nt l np nq nr nn ns kw ne"/></div></div></a></div><p id="6b65" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">太神奇了！让我们使用<strong class="jp ir">光刻</strong>。</p><p id="7d38" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们必须安装Lithop并运行测试，以确保它正常工作。Lithops附带了一个<em class="kl"> cli </em>工具，允许从控制台运行一些管理任务:</p><pre class="kn ko kp kq gt mg mh mi bn mj mk bi"><span id="3f00" class="ml le iq mh b be mm mn l mo mp">$ pip3 install lithops<br/>$ lithops test<br/><br/>Hello Josep! Lithops is working as expected :)</span></pre><p id="efa3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好了，一切正常，正如我向你保证的，让我们修改一行代码，使用Lithops运行前面的例子:</p><pre class="kn ko kp kq gt mg mh mi bn mj mk bi"><span id="8f8b" class="ml le iq mh b be mm mn l mo mp">import time<br/># from multiprocessing import Pool<br/>from lithops.multiprocessing import Pool<br/><br/>def f(x):<br/>    time.sleep(10)<br/>    return x*x<br/><br/>if __name__ == '__main__':<br/>    with Pool() as p:<br/>        print(p.map(f, range(100)))</span></pre><p id="c592" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在开始时，如果没有提供额外的配置，Lithops使用本地进程来执行功能，所以此时它就像是<em class="kl">多处理</em>库的替代品。这意味着，如果你执行这段代码，它将使用Lithops框架在你的计算机上并行运行。</p><blockquote class="nu nv nw"><p id="9a27" class="jn jo kl jp b jq jr js jt ju jv jw jx nx jz ka kb ny kd ke kf nz kh ki kj kk ij bi translated">让我激活Lithops日志，向您展示它正在工作；)</p></blockquote><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi oa"><img src="../Images/0454b67d5639d3fdd5f1d6de1b5449ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y1lQNyPWURyF_QBKVFGVvg.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">Lithops本地执行</figcaption></figure><p id="6d28" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意，现在我们使用100个元素的列表作为输入。因此，当我们在我们的4核笔记本电脑上本地运行代码时，应用程序花了250秒才完成…等一下… 250秒？使用多处理内置python库需要280秒…是的，在某些情况下，<strong class="jp ir">在Localhost模式下使用Lithops比内置python多处理库更快</strong>。这太酷了！</p><p id="6ad8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在是时候将python脚本迁移到云中，并增加并行性来提高速度了。为了配置Lithops在云中运行脚本，<a class="ae lc" href="https://lithops-cloud.github.io/docs/source/configuration.html" rel="noopener ugc nofollow" target="_blank">按照这些详细的说明</a>并在您首选的云提供商中设置一个<strong class="jp ir">无服务器计算后端</strong>和一个<strong class="jp ir">存储后端</strong>。一旦用适当的密钥创建了配置文件，Lithops就自动开始使用配置的后端。因此，现在我们只需要重新执行之前的python示例，然后…</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi ob"><img src="../Images/05c60f5c79be132f69606cf33632561d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HQLXM4CnNuAR8nYCVYK55w.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">Lithops云执行</figcaption></figure><p id="b669" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">… <em class="kl">瞧！</em>脚本在云端运行，现在只用了~18秒就完成了。<em class="kl">非常酷！</em>现在，您已经准备好将您的应用迁移到云中，并使用无服务器平台为您提供的令人印象深刻的并行性。</p><h1 id="f061" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">摘要</h1><p id="a2d5" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">本文提供了Python <strong class="jp ir"> Lithops </strong>库的概述，并展示了如何通过只修改一行代码，我们就可以将任何Python应用程序迁移到云中，从而利用大量的计算和存储资源。</p><p id="0050" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用Lithops，我们不仅可以移动，还可以构建全新的类似多进程的应用程序，这些应用程序可以利用云无服务器平台的惊人并行性。更重要的是，由于Lithops的多云特性，只需更改Lithops配置文件，应用程序就可以从一个云迁移到另一个云，而不需要对用户的python代码进行任何更改。</p></div></div>    
</body>
</html>