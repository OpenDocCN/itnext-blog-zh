<html>
<head>
<title>Taste of Functional Programming in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中函数式编程的味道</h1>
<blockquote>原文：<a href="https://itnext.io/taste-of-functional-programming-in-javascript-57fc0035238?source=collection_archive---------2-----------------------#2019-09-02">https://itnext.io/taste-of-functional-programming-in-javascript-57fc0035238?source=collection_archive---------2-----------------------#2019-09-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/4de0ecd4adce6e5faa027461fcb21b3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vwTgoPNuUN6pOFiCc4Qalg.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">咖啡店就是一个很好的例子，展示了函数式编程的好处。</figcaption></figure><p id="b328" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">函数式编程(FP)基于一个简单的思想，即使用<a class="ae ld" href="https://en.wikipedia.org/wiki/Pure_function" rel="noopener ugc nofollow" target="_blank"> <strong class="kh iu">纯函数</strong> </a>来构造程序。一个纯函数为相同的参数返回相同的值，它的求值没有<a class="ae ld" href="https://en.wikipedia.org/wiki/Side_effect_(computer_science)" rel="noopener ugc nofollow" target="_blank"> <strong class="kh iu">副作用</strong> </a>(即没有局部静态变量、非局部变量、可变引用参数或I/O流的突变)。JavaScript中纯函数的一个简单例子是在数组数据结构的原型上定义的<a class="ae ld" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map" rel="noopener ugc nofollow" target="_blank">映射</a>、<a class="ae ld" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter" rel="noopener ugc nofollow" target="_blank">过滤</a>和<a class="ae ld" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce" rel="noopener ugc nofollow" target="_blank">减少</a>方法。</p><p id="cb96" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">让我们看一个例子来演示FP和纯函数的好处。</p><h1 id="0211" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">咖啡店</h1><p id="29e4" class="pw-post-body-paragraph kf kg it kh b ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky mg la lb lc im bi translated">假设，我们正在实现一个处理咖啡店购物的程序。我将从一个有副作用的简单程序开始，然后用纯函数重写它。域实体是不同种类的咖啡，有相应的价格(图1)和支付给定订单的信用卡(图2)。</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mh"><img src="../Images/473a32ae1118f954eeb12baf3ab54aa2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IGOlku0dO6-DAiBKg3xBmg.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">图一。Base Coffee接口，Late和Cappuccino实现。</figcaption></figure><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mh"><img src="../Images/46aa5a58f15f34917d345d7af11e205d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BAiLcry5nT70o3Emtti9nQ.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">图二。信用卡提供了一个异步方法“charge()”来执行给定价格的订单。为了简单起见，它返回一个没有“无效”的承诺。</figcaption></figure><p id="72b4" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">咖啡店应用程序的简单实现应该允许选择一种咖啡并下订单(图3)。</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mh"><img src="../Images/60c30a4924e7f3a35ea53eb31c0d86a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8Z8dQO4DpZz_jlVvi6pfFw.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">图3。顾客可以买一杯咖啡。</figcaption></figure><p id="ba9e" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在这个实现中，行# 28<strong class="kh iu">cc . charge(cup . price)</strong>是副作用的一个例子，因为对信用卡收费涉及到与外界的一些交互。</p><p id="ed12" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">假设有两个客户:Alice和Bob。爱丽丝点了一杯拿铁和卡布奇诺，鲍勃——只要拿铁。</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mh"><img src="../Images/29cc5e1e2cbd5c9f27fa5797e3992745.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lgBwoa7BmOdU5814S55Rjw.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">图4。客户下了订单。</figcaption></figure><p id="88b2" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">可能有更多的顾客，他们中的一些人想点12杯咖啡。按照目前的实施方式，这将涉及对支付系统的12次单独呼叫，这可能会增加更高的处理费用和更慢的操作速度。将属于同一张信用卡的订单合并成一笔交易似乎是个好主意。我们能做些什么呢？</p><h1 id="a6c3" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">咖啡店2</h1><p id="5cd6" class="pw-post-body-paragraph kf kg it kh b ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky mg la lb lc im bi translated">FP解决方案是消除副作用。我们需要让<strong class="kh iu"> buyCoffee() </strong>成为一个纯函数。这可以通过引入另一个名为Charge的对象来实现，该对象将封装有关信用卡和订单价格的信息。</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mh"><img src="../Images/9202d20b9f9d49a270e94c894aa685ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l9vqX7369Vwm-QinmtHtVw.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">图5。收费对象包含信用卡和订单价格。</figcaption></figure><p id="232a" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们不是立即执行订单，而是返回订单和支付信息的元组(图6)。</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mh"><img src="../Images/eba76d096b4cdab9f27ac68c460ec18b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MYj2BrE0M86Q2aBMHeYw1Q.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">图6。返回一个元组[咖啡，收费]。</figcaption></figure><p id="4497" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">现在可以用不同的支付方式下多个订单，组合这些订单(图7)并在每张信用卡的一次交易中执行(图8)。</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mh"><img src="../Images/de0e6060d0c359766c57296558da266d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RcVmPTaw76r9LFe7MKY8hQ.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">图7。通过信用卡合并订单。下划线变量是一个“lodash”库。</figcaption></figure><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mm"><img src="../Images/cc6a913fb9858cf3ee11fea2770087ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bQgrHMDyY4hXkhvBfyC75g.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">图8。下单，组合，执行。</figcaption></figure><p id="6005" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们现在能够编写订单并应用不同的支付策略，因为咖啡店不需要了解支付处理。总的来说，这个解决方案非常灵活。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><p id="38ff" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这只是FP的一个味道。不可变的数据结构和纯函数使得代码更不容易出错，更易测试，并能适应业务需求的变化。如果你想了解更多关于FP的知识，我最喜欢的书是保罗·丘萨诺和罗纳·比雅纳松的《Scala函数式编程》。</p></div></div>    
</body>
</html>