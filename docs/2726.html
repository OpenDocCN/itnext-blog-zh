<html>
<head>
<title>Going Multithread with Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Node.js实现多线程</h1>
<blockquote>原文：<a href="https://itnext.io/going-multithread-with-node-js-492258ba32cf?source=collection_archive---------2-----------------------#2019-07-22">https://itnext.io/going-multithread-with-node-js-492258ba32cf?source=collection_archive---------2-----------------------#2019-07-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/725fc2231136b4d4e2a046fad4b71fcc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eaLZYjZd8Mp4l8gAwN2pGA.png"/></div></div></figure><p id="479a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Node.js因为它的设计受到了很多批评。<br/>来自<strong class="kd iu"> Java </strong>、<strong class="kd iu"> C、</strong>或<strong class="kd iu"> Python </strong>等编程语言，Node.js不直接访问线程似乎有些奇怪。我们如何同时处理事情？</p><p id="a752" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在Node.js 11之前，我们实际上可以使用<strong class="kd iu">集群</strong>模块运行并发/并行代码，如前一篇文章 中的<a class="ae kz" href="https://medium.com/free-code-camp/how-to-scale-your-node-js-server-using-clustering-c8d43c656e8f" rel="noopener"> <strong class="kd iu">所示。<br/>但是如果我们在只有一个内核的服务器上，我们该怎么做呢？</strong></a></p><p id="8b8e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在Node.js 11中，我们有<strong class="kd iu"> worker_thread </strong>模块，它允许我们在一个内核上产生多个线程。我们实际上可以在Node.js 10中使用这个带有<code class="fe la lb lc ld b">--experimental-worker</code>标志的模块，但是在Node.js 11中，我们最终可以避免它！</p><h1 id="f047" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">一个简单的用例</h1><p id="b9a8" class="pw-post-body-paragraph kb kc it kd b ke mc kg kh ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky im bi translated">我们需要创建一个包含100万用户的文件，包括他们的名字、中间名和姓氏。我发现了这个神奇的GitHub repo，它提供了一个名、中间名和姓的数组。我们将在项目中使用这些JSON文件:</p><div class="mh mi gp gr mj mk"><a href="https://github.com/dominictarr/random-name" rel="noopener  ugc nofollow" target="_blank"><div class="ml ab fo"><div class="mm ab mn cl cj mo"><h2 class="bd iu gy z fp mp fr fs mq fu fw is bi translated">多米尼克·塔尔/random-name</h2><div class="mr l"><h3 class="bd b gy z fp mp fr fs mq fu fw dk translated">在GitHub上创建一个帐户，为dominictarr/random-name开发做贡献。</h3></div><div class="ms l"><p class="bd b dl z fp mp fr fs mq fu fw dk translated">github.com</p></div></div><div class="mt l"><div class="mu l mv mw mx mt my jz mk"/></div></div></a></div><p id="aa1c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们使用以下文件夹结构创建一个新项目:</p><figure class="na nb nc nd gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/402cdc5759528ef2f564ce075d09474b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2Z_3C2BhSx4SOxDDQJ-Ieg.png"/></div></div></figure><p id="446a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">所以让我们从<code class="fe la lb lc ld b">main.js</code>文件开始:</p><figure class="na nb nc nd gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/b46ac997b56120b8ddb8bc9eaf42d49b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qZWtsFRIQ23opFpJWdPkJA.png"/></div></div></figure><p id="abf5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如你所见，我们正在使用<code class="fe la lb lc ld b">fs-extra</code>包。它就像<code class="fe la lb lc ld b">fs</code>模块一样工作，但是为每个函数返回一个承诺。它解决了那种操作带来的一个大问题:内存使用。事实上，如果我们试图用Node.js打开太多文件，就会产生错误并杀死主进程，因为它无法处理同时打开的所有文件(并耗尽内存)。在我们的<code class="fe la lb lc ld b">for</code>循环中，<code class="fe la lb lc ld b">await</code>将停止循环，直到操作结束:这样，我们每次迭代都只有一个打开的文件。</p><p id="ad79" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们看看<code class="fe la lb lc ld b">utils/index.js</code>文件:</p><figure class="na nb nc nd gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/e4e3fc56bbaaae618123e65768f0e9c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1oz32Ax0rYCsPPqMfYd_lA.png"/></div></div></figure><p id="01ea" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里我们只是从数组中获取一个随机值。当我们需要获得一个随机的名字、中间名或姓时，这非常有用。</p><p id="1966" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在我的机器(2016 MacBook Pro，2,7 GHz英特尔酷睿i7，16GB RAM)上运行上面的代码，需要3分32秒才能完成任务。让我们看看如何使用Node.js工作线程来提高性能！</p><h1 id="4ea2" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">走向多线程</h1><p id="48b0" class="pw-post-body-paragraph kb kc it kd b ke mc kg kh ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky im bi translated">为了对这个简单的程序采用多线程的方法，我们需要在我们的代码库中做一些改变。让我们从<code class="fe la lb lc ld b">main.js</code>文件开始:</p><figure class="na nb nc nd gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/499388093072c154c40cbe75786dabe7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LMIGqvuiAs-ut0oGIE8yjw.png"/></div></div></figure><p id="007c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先，我们需要从<code class="fe la lb lc ld b">worker_threads</code>模块导入<code class="fe la lb lc ld b">Worker</code>类。这将允许我们在任何时候产生一个新的工作者。然后我们可以设置生成几个线程:在这种情况下，我决定只生成10个线程。<br/>我们需要计算每个线程应该生成多少个名字；这很简单。我们只是将所需名称的总数除以线程数。对于每个线程，我们需要产生一个新的<code class="fe la lb lc ld b">Worker</code>。如您所见，它的代码将位于<code class="fe la lb lc ld b">worker.js</code>文件中。<br/>我们将向我们的新<code class="fe la lb lc ld b">Worker</code>发送一个有效载荷，告诉它应该创建多少个名字以及把它们放在哪里(输出文件)。<br/>我们将继续监听错误和退出，因此我们将跟踪我们的工人内部发生了什么。</p><p id="4ad5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在让我们看看<code class="fe la lb lc ld b">worker.js</code>文件是如何工作的:</p><figure class="na nb nc nd gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/91ec335f9f41c78896b3862ff9b91a47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zRyMF2aPzhE5oLlrCgqrvA.png"/></div></div></figure><p id="cde5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">基本上和原来的<code class="fe la lb lc ld b">main.js</code>文件代码一样。每次我们存储一个新名字，我们都把它发送回主线程，所以它会跟踪我们线程内部发生了什么。</p><p id="6eb7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">结果呢？我们做同样的操作只用了1分24秒！<strong class="kd iu">比单线程版本快37%</strong>！</p><h1 id="8d3e" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">其他使用案例</h1><p id="f8c0" class="pw-post-body-paragraph kb kc it kd b ke mc kg kh ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky im bi translated">当您需要执行CPU密集型任务时，工作线程是一个惊人的解决方案。它们使得与文件系统相关的操作更快，并且在您需要执行任何并发操作时帮助很大。最重要的是，正如我们之前所说，它们也可以在单核机器上工作，因此它们可以在任何服务器上提供更好的性能。</p><p id="2014" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我实际上在一次大规模上传操作中使用了<strong class="kd iu">工作线程</strong>，我必须检查数百万用户并将他们的数据存储到数据库中。采用多线程方法，运算速度比单线程快10倍左右。</p><p id="3e56" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我还使用<strong class="kd iu">工作线程</strong>进行图像操作。我必须从一张图像中构建三个缩略图(不同尺寸)，多线程方法再次帮助了我，节省了操作时间。</p><p id="a8b3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">正如你所看到的，<strong class="kd iu">工人线程</strong>模块可以帮助你提高性能，所以让我知道它是否在某些方面帮助了你！</p><figure class="na nb nc nd gt ju gh gi paragraph-image"><a href="https://github.com/sponsors/micheleriva"><div class="gh gi ne"><img src="../Images/e05f00ed2cddfd2907284cb397168c3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xAIiY1uBKSNdw12oq2BbjA.png"/></div></a></figure></div></div>    
</body>
</html>