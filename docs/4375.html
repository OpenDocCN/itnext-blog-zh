<html>
<head>
<title>Simplifying Jetpack Navigation between top-level destinations using Dagger-Hilt</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用匕首柄简化顶级目的地之间的Jetpack导航</h1>
<blockquote>原文：<a href="https://itnext.io/simplifying-jetpack-navigation-between-top-level-destinations-using-dagger-hilt-3d918721d91e?source=collection_archive---------2-----------------------#2020-06-19">https://itnext.io/simplifying-jetpack-navigation-between-top-level-destinations-using-dagger-hilt-3d918721d91e?source=collection_archive---------2-----------------------#2020-06-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/8fd7fbaeab7c04c43b492e463194d76a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CLbJWCakyfK19AtLzMdFOA.png"/></div></div></figure><p id="530d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Google创建了Jetpack导航来简化目的地(如片段目的地)之间的导航，并允许使用共享导航图定义这些目的地之间的逻辑范围。</p><p id="00b5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以将视图模型的范围扩展到这些导航图的相关NavBackStackEntry，甚至可以使用SavedStateHandle在进程死亡时保持它们的状态。</p><p id="0cfa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，由于<code class="fe kw kx ky kz b">NavController</code>实例的作用域是一个活动，从视图模型使用Jetpack导航的流行模式在历史上是冗长的。对于ViewModel想要发出的每个导航事件，它通常定义一个“<a class="ae la" href="https://medium.com/androiddevelopers/livedata-with-snackbar-navigation-and-other-events-the-singleliveevent-case-ac2622673150" rel="noopener"> LiveData事件包装器</a>”，该包装器由一个片段观察，该片段将<em class="lb">实际上</em>与NavController对话。</p><p id="7a63" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们能做得更好吗？我们能否减少从视图模型触发导航所需的代码量，并将“实际执行导航动作”的“责任”从片段本身转移出去？</p><p id="400d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">而且考虑到答案是肯定的，那跟Hilt有什么关系呢？😏</p><h1 id="65ce" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">匕首柄是什么？</h1><p id="068b" class="pw-post-body-paragraph jy jz iq ka b kb ma kd ke kf mb kh ki kj mc kl km kn md kp kq kr me kt ku kv ij bi translated">Dagger-Hilt是Google新推荐的依赖注入框架<a class="ae la" href="https://developer.android.com/training/dependency-injection/hilt-android" rel="noopener ugc nofollow" target="_blank">建立在Dagger2之上。</a></p><p id="f848" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">虽然还是alpha，但是已经相当强大了。总的想法是，你过去可能已经定义的每个组件(最常见的是<a class="ae la" href="https://medium.com/@Zhuinden/that-missing-guide-how-to-use-dagger2-ef116fbea97" rel="noopener"/><code class="fe kw kx ky kz b"><a class="ae la" href="https://medium.com/@Zhuinden/that-missing-guide-how-to-use-dagger2-ef116fbea97" rel="noopener">ApplicationComponent</a></code>)已经作为一个“预定义”的组件存在，你必须<em class="lb"/>“安装”你现有的模块到其中。</p><p id="f751" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最引人注目的组件是<code class="fe kw kx ky kz b">ApplicationComponent</code>和<code class="fe kw kx ky kz b">ActivityRetainedComponent</code>。</p><p id="1ace" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">安装在<code class="fe kw kx ky kz b">ApplicationComponent</code>中的模块内任何标有<code class="fe kw kx ky kz b">@Singleton</code>的类，其提供者的作用域都是app组件。</p><p id="3278" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">安装在<code class="fe kw kx ky kz b">ActivityRetainedComponent</code>中的模块内任何标有<code class="fe kw kx ky kz b">@ActivityRetainedScoped</code>的类，其提供者的作用域都是活动保留的组件。</p><p id="0aee" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">什么是<code class="fe kw kx ky kz b">ActivityRetainedComponent</code>？在内部，它使用活动范围的ViewModel将实例的范围限定在活动的保留范围内(并在配置更改时保持它)。</p><p id="a41f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">绑定到<code class="fe kw kx ky kz b">ApplicationComponent</code>或<code class="fe kw kx ky kz b">ActivityRetainedComponent</code>的依赖项将可用于通过<code class="fe kw kx ky kz b">@ViewModelInject</code>从Hilt自己的ViewModelFactory注入的视图模型(当在活动/片段上使用<code class="fe kw kx ky kz b">@AndroidEntryPoint</code>时，这是自动的“默认”)。</p><h1 id="b63c" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">设置匕首柄</h1><p id="d0fd" class="pw-post-body-paragraph jy jz iq ka b kb ma kd ke kf mb kh ki kj mc kl km kn md kp kq kr me kt ku kv ij bi translated">目前，我们必须添加以下依赖项:</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="mj mk l"/></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">匕首-刀柄装置</figcaption></figure><p id="aedb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">之后，我们需要用<code class="fe kw kx ky kz b">@HiltAndroidApp</code>注释应用程序类，用<code class="fe kw kx ky kz b">@AndroidEntryPoint</code>注释任何注入的活动/片段。</p><p id="578d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们还必须在我们的模块上添加<code class="fe kw kx ky kz b">@InstallIn(SomeComponent::class)</code>注释。</p><h1 id="b8a2" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">匕首柄和视图模型注入</h1><p id="fcf6" class="pw-post-body-paragraph jy jz iq ka b kb ma kd ke kf mb kh ki kj mc kl km kn md kp kq kr me kt ku kv ij bi translated">Hilt允许直接用单例、未分段和活动保留的实例注入视图模型。它还支持向ViewModel提供<a class="ae la" href="https://proandroiddev.com/dagger-tips-leveraging-assistedinjection-to-inject-viewmodels-with-savedstatehandle-and-93fe009ad874" rel="noopener ugc nofollow" target="_blank">saved state handle作为现成的辅助参数</a>。</p><p id="f7d7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">任何标注了<code class="fe kw kx ky kz b">@ViewModelInject constructor()</code>的ViewModel都可以从Hilt的ViewModelFactory提供，他们可以使用<code class="fe kw kx ky kz b">@Assisted</code>接收SavedStateHandle。</p><p id="1445" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，我们可以用最简单的方式(通过ktx)获得对这些视图模型的引用:</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="mj mk l"/></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">LoginFragment + ktx</figcaption></figure><h1 id="4f5f" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">NavGraph范围的视图模型呢？</h1><p id="60cc" class="pw-post-body-paragraph jy jz iq ka b kb ma kd ke kf mb kh ki kj mc kl km kn md kp kq kr me kt ku kv ij bi translated">默认情况下，句柄ViewModelFactory是默认的ViewModelProvider。喜利得工厂或喜利得工厂。</p><p id="0b64" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们打算将ViewModel的范围扩大到一个NavGraph，我们仍然需要提供Hilt的工厂作为工厂。只要<a class="ae la" href="https://github.com/google/dagger/issues/1938" rel="noopener ugc nofollow" target="_blank">我们可以假设片段的参数与NavGraph自己的参数</a>相同，这也可以正确地为SavedStateHandle提供参数。</p><p id="0462" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是，首先需要解决以下问题:<a class="ae la" href="https://github.com/google/dagger/issues/2152" rel="noopener ugc nofollow" target="_blank">https://github.com/google/dagger/issues/2152</a></p><h1 id="b701" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">使用Jetpack导航、Jetpack视图模型和Dagger-Hilt处理导航事件</h1><p id="eaf3" class="pw-post-body-paragraph jy jz iq ka b kb ma kd ke kf mb kh ki kj mc kl km kn md kp kq kr me kt ku kv ij bi translated">那么这如何帮助我们减少代码中的<code class="fe kw kx ky kz b">.observe(viewLifecycleOwner, EventObserver {</code>呢？实际上，很简单。</p><p id="916a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以创建一个存在于<code class="fe kw kx ky kz b">ActivityRetainedScope</code>中的<code class="fe kw kx ky kz b">NavigationDispatcher</code>类。</p><p id="f358" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，我们可以确保挂起的导航操作在活动中得到处理(但是由于范围的原因，在配置更改中保持活动)。</p><p id="b87c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过将挂起的导航事件描述为lambda表达式，我们可以使活动始终使用NavController的当前实例来处理导航事件，即使重新创建了NavHostFragment。感谢Lifecycle API(这是LiveData内部使用的)，我们可以确保只有当观察者处于活动状态时(在<code class="fe kw kx ky kz b">onStart</code>之后)才能获得导航事件。</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="mj mk l"/></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">导航命令</figcaption></figure><p id="3229" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">那么我们可以使用<code class="fe kw kx ky kz b"><a class="ae la" href="https://github.com/Zhuinden/event-emitter" rel="noopener ugc nofollow" target="_blank">EventEmitter&lt;NavigationCommand&gt;</a></code>或者<code class="fe kw kx ky kz b">LiveData&lt;Event&lt;NavigationCommand&gt;&gt;</code></p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="mj mk l"/></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">导航调度员</figcaption></figure><p id="4a1b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在活动方面:</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="mj mk l"/></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">主要活动</figcaption></figure><p id="5e1e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以在任何视图模型中轻松使用它:</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="mj mk l"/></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">发出导航命令作为操作ID</figcaption></figure><p id="8ed6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当然，我们也可以使用safe-args插件:</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="mj mk l"/></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">发出导航方向</figcaption></figure><h1 id="049a" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">结论</h1><p id="8f36" class="pw-post-body-paragraph jy jz iq ka b kb ma kd ke kf mb kh ki kj mc kl km kn md kp kq kr me kt ku kv ij bi translated">使用单个ActivityRetainedScoped类将当前挂起的导航操作排队(类似于<a class="ae la" href="https://github.com/terrakok/Cicerone" rel="noopener ugc nofollow" target="_blank"> Cicerone </a>的<code class="fe kw kx ky kz b">CommandBuffer</code>或<a class="ae la" href="https://github.com/Zhuinden/simple-stack" rel="noopener ugc nofollow" target="_blank"> Simple-Stack </a>的<code class="fe kw kx ky kz b">Backstack</code>)，我们可以消除所有那些讨厌的<code class="fe kw kx ky kz b">_navigateToSomeDirection</code>实时数据，而是在我们想要的地方随时触发我们想要的操作:直接从视图模型中执行导航操作，同时确保无论如何它都将工作<em class="lb">。</em></p><p id="7cb1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要了解更多信息，您可以查看<a class="ae la" href="https://github.com/Zhuinden/jetpack-navigation-ftue-sample/tree/hilt" rel="noopener ugc nofollow" target="_blank">Jetpack Navigation FTUE示例的<strong class="ka ir">句柄</strong>分支</a>，这些更改发生在哪里，这些更改可以在<a class="ae la" href="https://github.com/Zhuinden/jetpack-navigation-ftue-sample/commit/30edde0c2ff995ff1c1abc82c12bcebe95fe8ca2" rel="noopener ugc nofollow" target="_blank">这个提交</a>中看到。</p><p id="5f0e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="lb">查看</em><a class="ae la" href="https://www.reddit.com/r/android_devs/comments/hby9ru/simplifying_jetpack_navigation_between_toplevel/" rel="noopener ugc nofollow" target="_blank"><em class="lb">/r/Android _ devs</em></a><em class="lb">上的讨论线程。</em></p><p id="1dd4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi">— — — —</p><h1 id="4260" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">附录:对一个有趣问题的回答</h1><p id="933a" class="pw-post-body-paragraph jy jz iq ka b kb ma kd ke kf mb kh ki kj mc kl km kn md kp kq kr me kt ku kv ij bi translated">为了解决一个给定的注释，我将把它附加在这里:</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mp"><img src="../Images/fc126dc0d5c32b129e4ab9069e1dc2ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sIGkIXdM26USG_jcKlHXSQ.png"/></div></div></figure><p id="ad2c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里的问题是，现在片段拥有订阅，因此负责管理订阅的生命周期，而这应该在ViewModel中，以便异步操作不会在方向改变时被取消。</p><p id="2202" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此外，现在由您的视图决定谁知道何时启动<code class="fe kw kx ky kz b">performSomeTask()</code>调用，而不是只公开它的事件，比如<code class="fe kw kx ky kz b">onSomethingClicked()</code>。ViewModel拥有行为，因为NavGraph范围的ViewModel表示流，并且作为流控制器，它还应该拥有并控制导航行为。</p><p id="87ca" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">…我通常只需要调用<code class="fe kw kx ky kz b">backstack.goTo(SomeScreen())</code>来导航，结论中也提到了这一点，但是这方面的细节超出了本文的范围。<a class="ae la" href="https://medium.com/@Zhuinden/simplified-android-development-using-simple-stack-6e44ce808c35" rel="noopener"> <strong class="ka ir"> <em class="lb">敬请期待下一期</em> </strong> </a>如果你好奇的话。😏</p></div></div>    
</body>
</html>