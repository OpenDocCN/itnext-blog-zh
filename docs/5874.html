<html>
<head>
<title>Sending Messages to Kafka in Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">给库伯内特斯的卡夫卡发信息</h1>
<blockquote>原文：<a href="https://itnext.io/sending-messages-to-kafka-cfb5a246f5eb?source=collection_archive---------0-----------------------#2021-06-18">https://itnext.io/sending-messages-to-kafka-cfb5a246f5eb?source=collection_archive---------0-----------------------#2021-06-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="fe8e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在之前的博客中，我展示了如何声明性地使用来自卡夫卡的信息。今天，我将向你们展示如何反其道而行之，如何将消息生成到Kafka，也就是如何以声明的方式将消息发送到Kafka主题。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/3a8a2b1d7c302053f23aa6c60d9eea03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Dk14gdJrknd_2HTzeav6Ig.png"/></div></div></figure><p id="427c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">去上一篇博客了解一下背景。基本上，我们试图编写Kubernetes清单来声明我们如何发送和接收或生成/消费Kafka主题的消息。上图显示了这一切。对于这篇博客的混乱部分，请注意，<code class="fe ky kz la lb b">KafkaSink</code>产生了Kafka主题的事件，因此是Kafka集群的POV的Kafka源:)，因此<code class="fe ky kz la lb b">KafkaSource</code>消费了Kafka主题的事件，因此是Kafka集群的POV的Kafka接收器，否则就太容易了！！！</p><h1 id="5232" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">为什么？</h1><p id="d655" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">因为这比我自己编写Kafka客户端、编译、打包、部署等要容易得多。如果我能写一点配置，让一个像Kubernetes这样的系统为我管理它，那就太好了。</p><h1 id="1f69" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated"><strong class="ak">如何？</strong></h1><p id="e2a2" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">我们为一种叫做<code class="fe ky kz la lb b">KafkaSink</code>的新类型安装了两个控制器和一个CRD，并且为了更好的度量(否则狗屎会砸到风扇)，我们安装了knative eventing CRD(我们将修复它，因为它将很好地避免必须做的那一步……)。</p><pre class="kn ko kp kq gt mf lb mg mh aw mi bi"><span id="b1fb" class="mj ld iq lb b gy mk ml l mm mn">kubectl apply -f <a class="ae kl" href="https://github.com/knative/eventing/releases/download/v0.23.0/eventing-crds.yaml" rel="noopener ugc nofollow" target="_blank">https://github.com/knative/eventing/releases/download/v0.23.0/eventing-crds.yaml</a></span><span id="c994" class="mj ld iq lb b gy mo ml l mm mn">kubectl apply --filename <a class="ae kl" href="https://github.com/knative-sandbox/eventing-kafka-broker/releases/download/v0.23.0/eventing-kafka-controller.yaml" rel="noopener ugc nofollow" target="_blank">https://github.com/knative-sandbox/eventing-kafka-broker/releases/download/v0.23.0/eventing-kafka-controller.yaml</a></span><span id="890a" class="mj ld iq lb b gy mo ml l mm mn">kubectl apply --filename https://github.com/knative-sandbox/eventing-kafka-broker/releases/download/v0.23.0/eventing-kafka-sink.yaml</span></pre><p id="7c1f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在应用后不久，pod正在运行。请注意，下面的示例还显示了<code class="fe ky kz la lb b">KafkaSource</code>的控制器</p><pre class="kn ko kp kq gt mf lb mg mh aw mi bi"><span id="1dcb" class="mj ld iq lb b gy mk ml l mm mn">kubectl get pods -n knative-eventing<br/>NAME READY STATUS RESTARTS AGE<br/>kafka-controller-86948cddc6-g5mnn 1/1 Running 0 2m18s<br/>kafka-controller-manager-78c5588947-wt5bj 1/1 Running 0 5h29m<br/>kafka-sink-receiver-7dcb7b9b44–5w6j7 1/1 Running 0 115s<br/>kafka-webhook-eventing-fb6ddfd9d-jsmzm 1/1 Running 0 2m18s</span></pre><p id="0ae7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们新的花式CRD <code class="fe ky kz la lb b">KafkaSink</code>已经就位</p><pre class="kn ko kp kq gt mf lb mg mh aw mi bi"><span id="e0e4" class="mj ld iq lb b gy mk ml l mm mn">kubectl get crd | grep kafka<br/>kafkabindings.bindings.knative.dev 2021–06–18T08:44:51Z<br/>kafkasinks.eventing.knative.dev 2021–06–18T14:12:12Z<br/>kafkasources.sources.knative.dev 2021–06–18T08:44:52Z</span></pre><h1 id="5ebb" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">卡夫卡在行动</h1><p id="7937" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">使用与前一篇博客中相同的秘密，允许我们在合流云中与我们的Kafka集群对话，我们现在可以像这样声明性地设置Kafka sink:</p><pre class="kn ko kp kq gt mf lb mg mh aw mi bi"><span id="fb7a" class="mj ld iq lb b gy mk ml l mm mn">apiVersion: eventing.knative.dev/v1alpha1<br/>kind: KafkaSink<br/>metadata:<br/>  name: my-kafka-topic<br/>spec:<br/>  auth:<br/>    secret:<br/>      ref:<br/>        name: kafkahackathon<br/>  bootstrapServers:<br/>  - pkc-456q9.us-east4.gcp.confluent.cloud:9092<br/>  topic: hackathon</span></pre><p id="7275" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这将在我的Kubernetes集群中设置一个HTTP端点，我可以在这里发布CloudEvents。这些CloudEvents随后将被生成到我的Kafka集群中。<code class="fe ky kz la lb b">KafkaSink</code>看起来像是:</p><pre class="kn ko kp kq gt mf lb mg mh aw mi bi"><span id="d175" class="mj ld iq lb b gy mk ml l mm mn">kubectl get kafkasink<br/>NAME URL AGE READY REASON<br/>my-kafka-topic <a class="ae kl" href="http://kafka-sink-ingress.knative-eventing.svc.cluster.local/default/my-kafka-topic" rel="noopener ugc nofollow" target="_blank">http://kafka-sink-ingress.knative-eventing.svc.cluster.local/default/my-kafka-topic</a> 12m True</span></pre><p id="379a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们有了一个HTTP端点作为Kafka主题的HTTP代理，我们可以简单地将CloudEvent发布到这个端点，接收器将为主题“产生”事件。为此，我们可以在集群中获得一个快速shell，并使用curl手工创建一个CloudEvent，如下所示:</p><pre class="kn ko kp kq gt mf lb mg mh aw mi bi"><span id="6512" class="mj ld iq lb b gy mk ml l mm mn">curl -v “<a class="ae kl" href="http://kafka-sink-ingress.knative-eventing.svc.cluster.local/default/my-kafka-topic" rel="noopener ugc nofollow" target="_blank">http://kafka-sink-ingress.knative-eventing.svc.cluster.local/default/my-kafka-topic</a>" \<br/>&gt; -X POST \<br/>&gt; -H “Ce-Id: 536808d3–88be-4077–9d7a-a3f162705f79” \<br/>&gt; -H “Ce-Specversion: 1.0” \<br/>&gt; -H “Ce-Type: dev.knative.samples.helloworld” \<br/>&gt; -H “Ce-Source: dev.knative.samples/helloworldsource” \<br/>&gt; -H “Content-Type: application/json” \<br/>&gt; -d ‘{“msg”:”Hello World from the curl pod.”}’</span></pre><p id="8228" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">检查显示窗格中的日志，我们看到我们的CloudEvent被我们在之前的博客<a class="ae kl" href="https://sebgoa.medium.com/consuming-kafka-messages-in-kubernetes-9e43050d6eb4" rel="noopener">中设置的<code class="fe ky kz la lb b">KafkaSource</code>接收。</a></p><pre class="kn ko kp kq gt mf lb mg mh aw mi bi"><span id="6ac0" class="mj ld iq lb b gy mk ml l mm mn">☁️ cloudevents.Event<br/>Context Attributes,<br/> specversion: 1.0<br/> type: dev.knative.samples.helloworld<br/> source: dev.knative.samples/helloworldsource<br/> id: 536808d3–88be-4077–9d7a-a3f162705f79<br/> datacontenttype: application/json<br/>Data,<br/> {<br/> “msg”: “Hello World from the curl pod.”<br/> }</span></pre><p id="55f8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">流程结束后，我们可以在任何地方以CloudEvents的形式生成事件，并将它们放入Kafka主题中，然后消费该事件并将其发送到Kubernetes工作负载，所有这些都是以声明方式定义的。</p><p id="c145" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这为……鼓声……一种配置Kafka源和汇的声明式/kubernetes方式打开了大门。这将是下一篇博客。</p></div></div>    
</body>
</html>