<html>
<head>
<title>What are Database Migrations?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么是数据库迁移？</h1>
<blockquote>原文：<a href="https://itnext.io/what-are-database-migrations-5ad203d7d955?source=collection_archive---------3-----------------------#2022-03-15">https://itnext.io/what-are-database-migrations-5ad203d7d955?source=collection_archive---------3-----------------------#2022-03-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/0678819a5c338603be7c3b911afe1406.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hQfDuEqeEhrIyjYG"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">克里斯·布里格斯在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="8a1a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le">注意:这是关于编写良好的数据库迁移的第1部分，共2部分。</em> <a class="ae kf" href="https://freedomben.medium.com/the-rules-of-clean-and-mostly-painless-migrations-75b8b0dec194?sk=789b59e1ce45077303daea7866acf508" rel="noopener"> <em class="le">第2部分列出了一些规则，您可以遵循这些规则来体验干净且(大部分)轻松的迁移</em> </a> <em class="le">。</em></p><p id="bf8d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">简而言之，数据库迁移是修改数据库模式以满足应用程序需求的一系列脚本或步骤。在第一次提交时，应用程序模式很少是完美的！因此，数据库迁移是以安全、轻松的方式更新数据库模式的公认最佳实践。</p><p id="429b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您曾经开发过由ops团队或DBA维护模式定义的应用程序，并且每次部署都需要停机时间和维护周期，那么您会感受到这种痛苦。数据库迁移方法允许频繁(甚至每天多次)和安全地部署应用程序，而不需要任何停机时间。</p><h1 id="9cf7" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">为什么我们需要一个模式？</h1><p id="aadd" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">几乎每个web应用程序都需要某种持久性。最常见的是，使用关系数据库(如PostgreSQL)来提供这种功能。通过使用数据库来存储所有的应用程序状态，实际的应用程序进程本身变成了无状态的。这很好，因为保持流程无状态是<a class="ae kf" href="https://12factor.net/" rel="noopener ugc nofollow" target="_blank"> 12因子应用</a>的规则之一。</p><p id="a6d6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">关系数据库通常需要定义一个<em class="le">模式</em>。该模式声明了每一列的数据类型，以及关于可以包含哪些值的一些规则。例如，外键限制要求受影响的列必须指向链接表的现有行的主键。模式有时会让人感觉受到限制，但是它们也提供了大量关于数据完整性的好处。</p><p id="1f32" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当编写一个web应用程序时，重要的是所有的模式定义(以及任何随时间的变化)<em class="le">都包含在应用程序</em>中。如果不能将这些结合在一起，可能会在以后导致许多挑战。许多现代web框架提供了一个管理模式变化的官方工具包，称为“迁移”这些迁移是数据库在一系列增量中从初始状态到期望的最终状态所采取的步骤。</p><p id="1f3d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这些“步骤”就是<a class="ae kf" href="https://www.educba.com/data-definition-language/" rel="noopener ugc nofollow" target="_blank"> DDL </a>，或者数据定义语言。它们是修改模式而不是读取、更新或删除数据的SQL命令(DML或数据操作语言)。理想情况下，可以从一个空数据库开始，连续运行每个迁移，最后得到最终的模式定义。然而，这需要开发人员遵守一些规则。</p><h1 id="bf50" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">移民帮助解决的问题</h1><p id="424e" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">在部署代码更改时，有时必须同时修改架构以确保兼容性。对于大多数模式更改(向后兼容)，这不是问题，因为新代码和旧代码都可以成功地查询数据库。例如，添加新列是向后兼容的更改，因为用于查询的SQL不需要更改。考虑在迁移之前<em class="le">的查询:</em></p><figure class="mi mj mk ml gt ju"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="ff8b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们的应用程序的新版本将添加一个<code class="fe mo mp mq mr b">middle_name</code>列，我们将包括一个迁移，该迁移在应用程序的新版本部署之前立即运行以下代码:</p><figure class="mi mj mk ml gt ju"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="7f4d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这个命令运行之后，我们的应用程序可以开始向任何<code class="fe mo mp mq mr b">INSERT</code>或<code class="fe mo mp mq mr b">UPDATE</code>命令添加一个<code class="fe mo mp mq mr b">middle_name</code>，但是这样做的应用程序代码直到不久之后才会开始运行。与此同时，运行我们前面的查询的应用程序代码需要继续工作而不出错。多亏了只要求您需要的列的方法，它继续工作得很好。</p><p id="133b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，现在考虑我们想要重命名或删除一列的情况。如果我们现在的查询是:</p><figure class="mi mj mk ml gt ju"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="8f3b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们决定删除' middle_name '列，则在运行查询时，我们的应用程序代码的现有部署将会失败，直到应用程序的新版本被完全部署(并且旧版本不再运行)。</p><p id="9eea" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了处理这种情况，我们将:</p><ol class=""><li id="176b" class="ms mt it ki b kj kk kn ko kr mu kv mv kz mw ld mx my mz na bi translated">部署新版本的代码，它不再引用我们要移除的列。</li><li id="39f1" class="ms mt it ki b kj nb kn nc kr nd kv ne kz nf ld mx my mz na bi translated">创建将删除该列的迁移</li><li id="f86e" class="ms mt it ki b kj nb kn nc kr nd kv ne kz nf ld mx my mz na bi translated">部署我们代码的新版本</li></ol><p id="39ed" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可能会注意到，这个过程需要<strong class="ki iu">两个</strong>部署。不难想象可能需要三个或更多的场景。</p><p id="507a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在某些查询中，考虑表和行的<strong class="ki iu">锁</strong>的影响也很重要。如果模式被更改，有时会放置一个锁。您应该知道您运行的任何SQL语句对您的首选数据库的影响。</p><p id="57f6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您准备好开始编写迁移，<a class="ae kf" href="https://freedomben.medium.com/the-rules-of-clean-and-mostly-painless-migrations-75b8b0dec194?sk=789b59e1ce45077303daea7866acf508" rel="noopener">请阅读第二部分，其中包括干净和(大部分)无痛迁移的规则</a>。</p></div></div>    
</body>
</html>