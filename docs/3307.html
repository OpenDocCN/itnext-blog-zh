<html>
<head>
<title>Using TDD for 100% test coverage on Golang console applications</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用TDD对Golang控制台应用程序进行100%的测试覆盖</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-tdd-a-console-application-to-achieve-100-coverage-starting-from-main-test-go-934a617b080f?source=collection_archive---------2-----------------------#2019-11-19">https://itnext.io/how-to-tdd-a-console-application-to-achieve-100-coverage-starting-from-main-test-go-934a617b080f?source=collection_archive---------2-----------------------#2019-11-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/5d2c9439845b9d2ae9f6f11888157b7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h97CtdSBgJfRqpa7W2kK-g.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">由上田拓也<a class="ae jd" href="https://twitter.com/tenntenn" rel="noopener ugc nofollow" target="_blank">创作的地鼠</a></figcaption></figure><div class=""/><div class=""><h2 id="f3f1" class="pw-subtitle-paragraph kd jf jg bd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dk translated">我们将使用TDD创建一个控制台计算器应用程序，专注于进程内测试，以获得完美的测试覆盖和干净的架构。</h2></div><p id="c7fb" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在实践TDD时，您不可避免地会遇到一些场景，在这些场景中，要获得良好的覆盖率可能会有一点挑战性，尤其是在尝试不求助于进程外测试的时候。一般来说，<code class="fe lr ls lt lu b">main.go</code>就是那种情况。</p><p id="6cac" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在开发控制台应用程序时，我会给出两个建议:</p><ol class=""><li id="9d9b" class="lv lw jg kx b ky kz lb lc le lx li ly lm lz lq ma mb mc md bi translated">保持尽可能少的代码。最终，这应该只是您的应用程序的入口点。</li><li id="639f" class="lv lw jg kx b ky me lb mf le mg li mh lm mi lq ma mb mc md bi translated">真正尝试坚持TDD过程，首先创建一个测试，让它通过，然后再重构它。我还建议遵循<a class="ae jd" href="https://blog.cleancoder.com/uncle-bob/2013/05/27/TheTransformationPriorityPremise.html" rel="noopener ugc nofollow" target="_blank">转换优先前提</a> (TPP)，因为这将有助于保持一个干净的架构，并迫使代码变更由测试驱动。</li></ol><p id="10d7" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最初，TDD可能会感觉很慢，在应用TPP时更是如此，但是一旦你掌握了它的窍门，好处应该会开始显现出来。</p><h1 id="4805" class="mj mk jg bd ml mm mn mo mp mq mr ms mt km mu kn mv kp mw kq mx ks my kt mz na bi translated">都是为了第一次测试！</h1><p id="e63f" class="pw-post-body-paragraph kv kw jg kx b ky nb kh la lb nc kk ld le nd lg lh li ne lk ll lm nf lo lp lq ij bi translated">我们将从端到端测试开始，这将帮助我们驱动整个应用程序的架构。测试将集中在断言我们的计算器的加法运算，并将被放在一个名为<code class="fe lr ls lt lu b">main_test.go</code>的新文件中。</p><p id="2327" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在编写测试时，我倾向于从断言行开始。这将非常清楚地表明我将要测试的内容，因此在我着手实现实际测试时不会出现混乱。在这种情况下，我希望我的第一个测试断言计算器将能够对1 + 1求和并返回2。</p><figure class="ng nh ni nj gt is"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="3916" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这段代码还不能编译，这绝对没问题。</p><p id="643a" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">注意<code class="fe lr ls lt lu b">assertThat</code>将是一个变量func。我个人以这种方式处理测试，使其读作英语:“断言应该求和1 + 1并返回2”。当您需要创建同一个测试的不同变体时，它也会有所帮助，正如我们在创建新的操作(即乘法)时所需要的那样。</p><p id="dfa5" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了测试过程中的<code class="fe lr ls lt lu b">main.go</code>，两件事将是最重要的:</p><ol class=""><li id="51f4" class="lv lw jg kx b ky kz lb lc le lx li ly lm lz lq ma mb mc md bi translated"><strong class="kx jh">覆盖输入:</strong>在我们的计算器中，这是用户将用来执行应用程序的命令行:<code class="fe lr ls lt lu b">calc 1 + 1</code>。</li><li id="ce98" class="lv lw jg kx b ky me lb mf le mg li mh lm mi lq ma mb mc md bi translated"><strong class="kx jh">覆盖输出:</strong>应用程序将使用标准输出向用户打印结果，因此它需要被覆盖，这样我们就可以对它进行断言。</li></ol><h2 id="1c31" class="nm mk jg bd ml nn no dn mp np nq dp mt le nr ns mv li nt nu mx lm nv nw mz nx bi translated">覆盖输入</h2><p id="b272" class="pw-post-body-paragraph kv kw jg kx b ky nb kh la lb nc kk ld le nd lg lh li ne lk ll lm nf lo lp lq ij bi translated">在这一点上，事情开始变得有趣起来，我们如何在不求助于进程外调用的情况下将<code class="fe lr ls lt lu b">calc 1 + 1</code>转换成应用程序实际接收的内容？事实证明golang允许对<code class="fe lr ls lt lu b">os.Args</code>进行修改，所以我们可以在调用<code class="fe lr ls lt lu b">main()</code>之前简单地修改一下，大致如下:</p><pre class="ng nh ni nj gt ny lu nz oa aw ob bi"><span id="42b3" class="nm mk jg lu b gy oc od l oe of">os.Args = strings.Split("calc 1 + 1", " ")</span></pre><p id="6ef9" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">同样，您的控制台应用程序可能依赖的任何输入源也需要进行相应的处理。例如，如果你正在创建一个支持<code class="fe lr ls lt lu b">os.Stdin</code>或者需要访问环境变量的应用程序，这些需要在<code class="fe lr ls lt lu b">main.go</code>处理。</p><p id="367d" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">关注保持<code class="fe lr ls lt lu b">main.go</code>作为整个应用程序中唯一可以访问<code class="fe lr ls lt lu b">os.*</code>资源的地方。这将提高应用程序的可测试性，并使应用程序的每个部分都与其适当的抽象级别保持一致。</p><h2 id="faa2" class="nm mk jg bd ml nn no dn mp np nq dp mt le nr ns mv li nt nu mx lm nv nw mz nx bi translated">覆盖操作系统。标准输出</h2><p id="6ade" class="pw-post-body-paragraph kv kw jg kx b ky nb kh la lb nc kk ld le nd lg lh li ne lk ll lm nf lo lp lq ij bi translated"><code class="fe lr ls lt lu b">os.Stdout</code>的实现基于<code class="fe lr ls lt lu b">*os.File</code>。这不是一个用于测试的好类型，所以在其他抽象层次，我们将用<code class="fe lr ls lt lu b">io.Writer</code>来代替它。然而，此时我们别无选择，只能使用临时文件来覆盖<code class="fe lr ls lt lu b">os.Stdout</code>。</p><p id="a061" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在覆盖了输入和输出之后，我的测试如下所示:</p><figure class="ng nh ni nj gt is"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="8648" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了简单起见，我不处理创建临时文件的错误，也不处理读取临时文件的错误。如果这些操作中的任何一个失败了，它们将会崩溃，因此，可以随意实现这些断言。</p><h1 id="b203" class="mj mk jg bd ml mm mn mo mp mq mr ms mt km mu kn mv kp mw kq mx ks my kt mz na bi translated">让我们追寻那道绿光吧！</h1><p id="3317" class="pw-post-body-paragraph kv kw jg kx b ky nb kh la lb nc kk ld le nd lg lh li ne lk ll lm nf lo lp lq ij bi translated">一旦实际创建了测试，我们应该创建最小数量的产品代码来使它通过。</p><p id="e376" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">首先我会创建一个除了空的<code class="fe lr ls lt lu b">func main()</code>之外什么都没有的<code class="fe lr ls lt lu b">main.go</code>文件，这样代码就可以编译了。然后运行测试并得到错误:</p><figure class="ng nh ni nj gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi og"><img src="../Images/e84ef77c0f4aed46effe3430a80be1b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0KvGmQH_MEklnB2-jJw0Dw.png"/></div></div></figure><p id="00e9" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在TPP之后，通过硬编码我们想要的结果来使测试通过:</p><figure class="ng nh ni nj gt is"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="9070" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在运行我们的单一测试应该可以通过。这让我们处于一个非常有利的位置，从现在开始，无论发生什么，我们都可以保证不会破坏该命令的命令行语法，否则测试将会失败。</p><h1 id="169e" class="mj mk jg bd ml mm mn mo mp mq mr ms mt km mu kn mv kp mw kq mx ks my kt mz na bi translated">重构…</h1><p id="a0e5" class="pw-post-body-paragraph kv kw jg kx b ky nb kh la lb nc kk ld le nd lg lh li ne lk ll lm nf lo lp lq ij bi translated">现在我们可以通过替换对<code class="fe lr ls lt lu b">os.Args</code>和<code class="fe lr ls lt lu b">os.Stdout</code>的依赖来重构这段代码。如前所述，<code class="fe lr ls lt lu b">os.File</code>现在可以用<code class="fe lr ls lt lu b">io.Writer</code>代替，<code class="fe lr ls lt lu b">os.Args</code>可以用一个简单的字符串数组代替，这两者都将使我们未来的测试简单很多。</p><figure class="ng nh ni nj gt is"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="72a2" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在<code class="fe lr ls lt lu b">main.go</code>中只保留<code class="fe lr ls lt lu b">main</code> func，在<code class="fe lr ls lt lu b">main_test.go</code>中只保留应用的端到端测试是有意义的。我们将从它里面重构出<code class="fe lr ls lt lu b">Run</code>，并把它放到一个新的<code class="fe lr ls lt lu b">cli.go</code>文件中。</p><figure class="ng nh ni nj gt is"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="7650" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">有了新的变化，我们也必须改变<code class="fe lr ls lt lu b">main.go</code>中的代码:</p><figure class="ng nh ni nj gt is"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="9cfa" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">从这一点开始，如果我们的要求迫使我们，我们将只接触<code class="fe lr ls lt lu b">main.go</code>和<code class="fe lr ls lt lu b">main_test.go</code>。否则，我们将专注于在<code class="fe lr ls lt lu b">cli.go</code>创建测试，并从那里深入我们的测试。</p><h1 id="6888" class="mj mk jg bd ml mm mn mo mp mq mr ms mt km mu kn mv kp mw kq mx ks my kt mz na bi translated">命令行界面CLI</h1><p id="d835" class="pw-post-body-paragraph kv kw jg kx b ky nb kh la lb nc kk ld le nd lg lh li ne lk ll lm nf lo lp lq ij bi translated">现在我们有了一个<code class="fe lr ls lt lu b">cli.go</code>,我们应该创建它的测试文件对应部分，这样我们就创建了一个新的测试，它将驱动我们更多的实现。为此，请记住cli将负责与处理参数、选择要执行的操作和错误处理相关的所有事情。</p><p id="d6b6" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们可以从测试开始，如果没有错误发生(例如，无效语法、无效操作等),我们只运行加法命令。)这里我还将一次性添加两个测试以避免冗余，但是在开发时，一次做一个。:)</p><p id="96c3" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是<code class="fe lr ls lt lu b">cli_test.go</code>的样子:</p><figure class="ng nh ni nj gt is"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="322d" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">请注意，我跳了几步，在那里得到了一个工厂，否则这篇帖子会有两倍长。:)工厂将负责处理传入的参数，并根据<code class="fe lr ls lt lu b">args</code>决定哪个命令最合适，目前，它将被硬编码为总是返回<code class="fe lr ls lt lu b">additionCommand</code>:</p><figure class="ng nh ni nj gt is"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="7788" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们可以通过为<code class="fe lr ls lt lu b">additionCommand</code>创建测试来迫使一些真正的计算开始发生:</p><figure class="ng nh ni nj gt is"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="7e60" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">通过最少的更改，它将通过所有测试:</p><figure class="ng nh ni nj gt is"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="721d" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这将持续一段时间，因为您可能会测试<code class="fe lr ls lt lu b">NewConsole</code>以确保它在接收到<code class="fe lr ls lt lu b">nil</code>作为输入时会出现混乱。根据传递给args的操作符，<code class="fe lr ls lt lu b">GetCommand</code>实际上返回了正确的类型。一旦所有这些都实现了，所有的测试都通过了，你也可以将<code class="fe lr ls lt lu b">a.value1 +a.value2</code>从<code class="fe lr ls lt lu b">run</code> func重构到它自己的<code class="fe lr ls lt lu b">calc</code>包中，毕竟，那是我们的领域逻辑和一个完全不同的抽象层次。</p><h1 id="765b" class="mj mk jg bd ml mm mn mo mp mq mr ms mt km mu kn mv kp mw kq mx ks my kt mz na bi translated">就这些吗？等等！退出密码呢？</h1><p id="bf0f" class="pw-post-body-paragraph kv kw jg kx b ky nb kh la lb nc kk ld le nd lg lh li ne lk ll lm nf lo lp lq ij bi translated">控制台应用程序中的一个重要部分是退出代码。然而，测试退出代码可能相当棘手，原因是当您执行<code class="fe lr ls lt lu b">os.Exit(2)</code>(或<code class="fe lr ls lt lu b">log.Fatal</code>)时，后台会调用一个<code class="fe lr ls lt lu b">exit</code>系统调用，这将使您的应用程序立即停止。当测试中出现这种情况时，测试就会失败——甚至在您的断言执行之前。</p><p id="a4c1" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这里的答案是求助于进程外测试。然而，我们想确保我们测试的是其他测试运行的同一个编译版本，因此我们不应该用<code class="fe lr ls lt lu b">go run</code>或<code class="fe lr ls lt lu b">go test</code>来测试。相反，我们将使用您执行<code class="fe lr ls lt lu b">go test</code>时在幕后编译的测试二进制文件，这将使所有事情保持同步。</p><figure class="ng nh ni nj gt is"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="1cbb" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">以下是一些需要注意的事项:</p><ol class=""><li id="5ba1" class="lv lw jg kx b ky kz lb lc le lx li ly lm lz lq ma mb mc md bi translated">当前的可执行文件名称是我们用来运行新命令的名称。这是我们确保测试与其他测试完全相同的二进制文件的方法。</li><li id="ed74" class="lv lw jg kx b ky me lb mf le mg li mh lm mi lq ma mb mc md bi translated">将要执行的新的进程外测试是<code class="fe lr ls lt lu b">TestMain_ErrorCodes_Inception</code>，所以我们将它作为参数传递给文件。</li><li id="0a03" class="lv lw jg kx b ky me lb mf le mg li mh lm mi lq ma mb mc md bi translated"><code class="fe lr ls lt lu b">TestMain_ErrorCodes_Inception</code>测试只有在收到环境变量<code class="fe lr ls lt lu b">ErrorCodes_Args</code>时才会执行<code class="fe lr ls lt lu b">main()</code>。这也将用于覆盖该测试中的<code class="fe lr ls lt lu b">os.Args</code>。这对于测试多个测试场景非常有用，每个场景都有不同的命令行，导致不同的退出代码。</li><li id="9022" class="lv lw jg kx b ky me lb mf le mg li mh lm mi lq ma mb mc md bi translated">第<code class="fe lr ls lt lu b">if !ok {</code>行主要是为了确保如果测试没有出现错误代码，不会使您的测试错误难以阅读。</li><li id="b566" class="lv lw jg kx b ky me lb mf le mg li mh lm mi lq ma mb mc md bi translated">我只验证<code class="fe lr ls lt lu b">CombinedOutput</code>，它包含标准输出和标准误差。我可以将它们分开，并确保我只通过StdErr得到错误。但是我决定在<code class="fe lr ls lt lu b">cli_test.go</code>的其他测试中验证这一点。</li></ol><p id="3b51" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在通过测试之前，这个测试将会在应用程序代码中驱动相当多的变化。注意<code class="fe lr ls lt lu b">main.go</code>现在必须同时传递<code class="fe lr ls lt lu b">os.StdErr</code>和<code class="fe lr ls lt lu b">os.Exit</code>。后者的原因是为了确保我们可以在测试<code class="fe lr ls lt lu b">cli.go</code>时覆盖它，否则它将需要另一个进程外测试，并且还会违反我们的抽象层。</p><h1 id="5f40" class="mj mk jg bd ml mm mn mo mp mq mr ms mt km mu kn mv kp mw kq mx ks my kt mz na bi translated">那么最后会是什么样子呢？</h1><p id="d586" class="pw-post-body-paragraph kv kw jg kx b ky nb kh la lb nc kk ld le nd lg lh li ne lk ll lm nf lo lp lq ij bi translated">下面只是应用程序代码，测试和完整的源代码可以在<a class="ae jd" href="https://github.com/pjbgf/go-sample-console-app" rel="noopener ugc nofollow" target="_blank">这个repo </a>找到。</p><h2 id="851a" class="nm mk jg bd ml nn no dn mp np nq dp mt le nr ns mv li nt nu mx lm nv nw mz nx bi translated">main.go</h2><p id="8c44" class="pw-post-body-paragraph kv kw jg kx b ky nb kh la lb nc kk ld le nd lg lh li ne lk ll lm nf lo lp lq ij bi translated">仍然是一个单独的liner，但是现在它也传递给了<code class="fe lr ls lt lu b">cli</code>标准错误和退出方法。</p><figure class="ng nh ni nj gt is"><div class="bz fp l di"><div class="nk nl l"/></div></figure><h2 id="8616" class="nm mk jg bd ml nn no dn mp np nq dp mt le nr ns mv li nt nu mx lm nv nw mz nx bi translated">cli.go</h2><p id="129f" class="pw-post-body-paragraph kv kw jg kx b ky nb kh la lb nc kk ld le nd lg lh li ne lk ll lm nf lo lp lq ij bi translated">从下面的实现来看，我可能会改变的一件事是避免违反<a class="ae jd" href="https://martinfowler.com/bliki/TellDontAsk.html" rel="noopener ugc nofollow" target="_blank">告诉不要问</a>并将解析参数的责任转移到命令本身，然而，我认为一旦实现了更多的操作，并且实际上出现了这种需求，这将是一个重构步骤。</p><figure class="ng nh ni nj gt is"><div class="bz fp l di"><div class="nk nl l"/></div></figure><h2 id="2c75" class="nm mk jg bd ml nn no dn mp np nq dp mt le nr ns mv li nt nu mx lm nv nw mz nx bi translated">计算. go</h2><p id="f6b6" class="pw-post-body-paragraph kv kw jg kx b ky nb kh la lb nc kk ld le nd lg lh li ne lk ll lm nf lo lp lq ij bi translated">我们的领域逻辑非常简单，所以这没什么好奇怪的:</p><figure class="ng nh ni nj gt is"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="3294" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一旦实现，结果应该是100%的测试覆盖率:</p><figure class="ng nh ni nj gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oh"><img src="../Images/da59633ccb3a7c85fd7030c538cd2e71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8WsvzPFTwIRqM_opkF0CIw.png"/></div></div></figure><h1 id="04fb" class="mj mk jg bd ml mm mn mo mp mq mr ms mt km mu kn mv kp mw kq mx ks my kt mz na bi translated">关于项目组织和清洁建筑的说明</h1><p id="c178" class="pw-post-body-paragraph kv kw jg kx b ky nb kh la lb nc kk ld le nd lg lh li ne lk ll lm nf lo lp lq ij bi translated">最后，应用程序将分为三个部分:</p><figure class="ng nh ni nj gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oi"><img src="../Images/c68859a0ef59d5fa354203643514e65d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UskZRzUiHbOz5olEg1urUw.png"/></div></div></figure><p id="b97a" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">每个部分都有自己的职责，最重要的是，它们之间的依赖只有一个方向，我们的域逻辑(calc)是无依赖的。</p><h1 id="6a83" class="mj mk jg bd ml mm mn mo mp mq mr ms mt km mu kn mv kp mw kq mx ks my kt mz na bi translated">现在怎么办？</h1><p id="2218" class="pw-post-body-paragraph kv kw jg kx b ky nb kh la lb nc kk ld le nd lg lh li ne lk ll lm nf lo lp lq ij bi translated">一旦加法命令完全实现，为了实现下一个操作，比方说乘法，您将在<code class="fe lr ls lt lu b">main_test.go</code>中创建一个新的端到端测试:</p><pre class="ng nh ni nj gt ny lu nz oa aw ob bi"><span id="e0b1" class="nm mk jg lu b gy oc od l oe of">assertThat("should multiply 5 * 5 and return 25", "calc 5 * 5", "multiplication total: 25\n")</span></pre><p id="0ad5" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">它会被放在我们一开始写的第一行代码的下面。一旦测试失败，您将实现一些代码来使它通过，然后创建其他测试来进一步深入实现。</p></div><div class="ab cl oj ok hu ol" role="separator"><span class="om bw bk on oo op"/><span class="om bw bk on oo op"/><span class="om bw bk on oo"/></div><div class="ij ik il im in"><p id="541b" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我很喜欢Rene French的gif，我在欺骗c#开发者的<a class="ae jd" rel="noopener ugc nofollow" target="_blank" href="/4-golang-code-snippets-that-will-deceive-c-developers-6f50a31f0548"> 4 golang代码片段中使用了它，所以我将在这里再次添加它。:)</a></p><figure class="ng nh ni nj gt is gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/af4bdac1584a26072c3801e70343a0b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:384/0*7CUwJOzPURO5-5EJ.gif"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">图片来源:<a class="ae jd" href="https://github.com/egonelbre/gophers" rel="noopener ugc nofollow" target="_blank">雷内·弗伦奇</a></figcaption></figure></div></div>    
</body>
</html>