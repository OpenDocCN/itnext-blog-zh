<html>
<head>
<title>3 common mistakes when using Angular + NGRX + FIREBASE</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Angular + NGRX + FIREBASE时的3个常见错误</h1>
<blockquote>原文：<a href="https://itnext.io/3-common-mistakes-when-using-angular-ngrx-firebase-9de4e241d866?source=collection_archive---------2-----------------------#2018-09-30">https://itnext.io/3-common-mistakes-when-using-angular-ngrx-firebase-9de4e241d866?source=collection_archive---------2-----------------------#2018-09-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/00cc65b16974e7325d235670741d07b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jUvlbXUmoB-Da0kZV4xjyw.png"/></div></div></figure><p id="682e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本文中，我将展示一些技术，我们可以使用这些技术来提高Angular + NGRX + FIREBASE的性能。</p><p id="7072" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">NgRx对于中等复杂程度的应用程序来说是一个很好的解决方案。Redux模式结合RxJs的强大功能确实适合Angular生态系统，添加Firebase实时数据库或Firestore将使您的应用程序真正快速和反应灵敏。Angular大量使用Observables，NgRx也是用Observables和AngularFire2(也改为@angular/fire)构建的，所以我们可以用我们的数据和状态做很多复杂的事情。然而，对于初学者来说，可观测量并不容易学习，许多人避免使用NgRx，因为它是样板文件，即使是使用它们的人，他们也会犯错误，导致性能问题和内存问题。</p><h2 id="fe8d" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">错误1。不退订(一般情况下)</h2><p id="c6b8" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">有两种类型可观察值，第一种发出值并完成，第二种发出值并不自动完成。对于大多数发出一个值并完成的观察值，我将调用<code class="fe lu lv lw lx b">finite</code>，对于一直发出值直到我们手动告诉它们停止的观察值，我将调用<code class="fe lu lv lw lx b">infinite</code>。当我们订阅一个可观察对象时，我们必须取消订阅，否则会导致内存泄漏和应用程序中的意外行为。</p><p id="0090" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如我提到的，Angular大量使用RxJs和observables。其中一个例子是<code class="fe lu lv lw lx b">HttpClient </code>提供的Angular。我们使用HttpClient向服务器发出请求，并且可以观察到响应。但是HttpClient返回的可观察对象是<code class="fe lu lv lw lx b">finite</code>，所以我们一般不会，但是可以手动退订。</p><blockquote class="ly lz ma"><p id="d9c0" class="jy jz mb ka b kb kc kd ke kf kg kh ki mc kk kl km md ko kp kq me ks kt ku kv ij bi translated">有限的observables发出值并自动完成，所以如果您不取消订阅Http请求，就不会有问题。</p></blockquote><p id="c5b3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">另一件事是无限可观。当我们订阅无限可观测量时，我们必须在某个时候取消订阅。如果我们忘记了，这将导致内存泄漏和我们的应用程序中的意外行为，因为无限可观测量不会自动完成。Angular中有许多无限的可观察性(路线事件、形态变化)，如果我们不退订，就会有问题。当使用NgRx和Firebase时，我们会遇到更多的问题。【NgRx提供的一切实际上都是无限的可观测量，大多数firebase查询方法也返回无限的可观测量。在这种情况下，你需要小心，取消订阅。</p><blockquote class="ly lz ma"><p id="667d" class="jy jz mb ka b kb kc kd ke kf kg kh ki mc kk kl km md ko kp kq me ks kt ku kv ij bi translated">在使用NgRx(从store中选择state)或Firebase时，总是要考虑何时取消订阅</p></blockquote><h2 id="adcd" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">错误2。通过Firebase的效果获取数据时，使用平面图(合并图)而不是切换图</h2><p id="fa0b" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">当我们使用NgRx时，我们应该使用这个状态管理系统提供的所有强大功能。其中一个是<code class="fe lu lv lw lx b">Effects</code>，用于处理异步操作。例如，如果我们想要将数据加载到我们的组件中，我们将分派一个动作，该动作将在<code class="fe lu lv lw lx b">Effects</code>中处理。Effect将获取数据并分派新的动作来更新状态。</p><p id="1eab" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">考虑以下影响。</p><pre class="mf mg mh mi gt mj lx mk ml aw mm bi"><span id="4293" class="kw kx iq lx b gy mn mo l mp mq">@Effect()<br/> loadPosts$ = this.actions$.pipe(<br/>   ofType(LOAD_POSTS),<br/>   pluck(‘payload’),<br/>   flatMap(uid =&gt;<br/>     this.db.getAllPosts(uid).pipe(<br/>     tap(() =&gt; console.log(‘Data loaded’))<br/>    ),<br/>   map(posts =&gt; new LoadPostsSuccess({ entries: posts }))<br/>   )<br/>  )<br/> );</span></pre><p id="4aa2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们监听<code class="fe lu lv lw lx b">LOAD_POSTS</code>动作，当发生这种情况时，我们获取用户的uid并从firebase(它给出了<code class="fe lu lv lw lx b">infinite observable</code>)获取数据。现在考虑以下场景。我们在一个组件<strong class="ka ir"> A </strong>中，这个动作在<code class="fe lu lv lw lx b">ngOnInit()</code>中被调度，然后我们导航到另一个组件<strong class="ka ir"> B </strong>，然后返回到<strong class="ka ir"> A </strong>(再次被调度)，然后是B，如此反复几次。现在，当我们的数据库发生变化时，因为我们订阅了这些变化，所以我们会看到<code class="fe lu lv lw lx b">LoadPostsSuccess</code>动作被分派了许多次(取决于我们返回组件<strong class="ka ir"> A </strong>的次数)。原因是因为我们使用了<strong class="ka ir"> <em class="mb"> flatMap </em> </strong>运算符。每次我们打开页面<strong class="ka ir"> A </strong>(组件被初始化)，效果就会起作用，并添加另一个对db变更的订阅。解决这个问题最简单的方法就是使用<strong class="ka ir"> <em class="mb"> switchMap。</em> </strong>如果有以前的订阅，该操作符将取消订阅，因此当我们导航到另一个页面并返回时，我们将只有一个活动订阅。</p><blockquote class="ly lz ma"><p id="03ae" class="jy jz mb ka b kb kc kd ke kf kg kh ki mc kk kl km md ko kp kq me ks kt ku kv ij bi translated">如果你想了解更多关于像flatMap或switchMap这样的操作符，请阅读<a class="ae mr" href="https://blog.angular-university.io/rxjs-higher-order-mapping/" rel="noopener ugc nofollow" target="_blank">这篇文章</a>。</p></blockquote><h2 id="0244" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">错误3。不退订Firebase的效果</h2><p id="1c47" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">尽管在上面的例子中，我展示了如何在使用switchMap时避免多次执行代码，但仍然存在一个问题。因为firebase查询方法提供了无限的可观察性，即使当我们导航到另一个页面时，我们仍然在监听数据库的变化。考虑上面带有switchMap()的示例。我们在组件<strong class="ka ir"> A </strong>中，动作<code class="fe lu lv lw lx b">LOAD_POSTS </code>被分派。在获得数据后<code class="fe lu lv lw lx b">LoadPostsSuccess </code>动作被分派。现在我们导航到组件<strong class="ka ir"> B </strong>。我们操纵数据库中的数据，因为我们仍然订阅这些更改，我们将再次看到<code class="fe lu lv lw lx b">LoadPostsSuccess </code>动作被调度。当我们导航到组件<strong class="ka ir"> A </strong>时，我们将会看到<code class="fe lu lv lw lx b">LOAD_POSTS </code>，然后<code class="fe lu lv lw lx b">LoadPostsSuccess </code>被分派。所以你可能会问问题出在哪里？问题是，在这种特殊情况下，当我们不在组件<strong class="ka ir"> A </strong>中时，我们不需要继续监听来自数据库的<code class="fe lu lv lw lx b">LOAD_POSTS </code>，因为无论如何，当我们导航到组件<strong class="ka ir"> A </strong>时，这个动作(<code class="fe lu lv lw lx b">LOAD_POSTS</code>)将再次被调度。</p><p id="2f02" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这不是一个大问题，但是当您不在负责从firebase呈现数据的组件中时，您可能希望取消订阅firebase stream。您可能会执行数据转换，甚至更复杂的操作。没有必要一直监听那个流，因为模板中不会显示任何内容。</p><p id="310c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以使用<code class="fe lu lv lw lx b">take(1)</code>仅从firebase获取第一个发出的值并取消订阅，但是在这种情况下，我们不会对firebase进行实时更改。如果我们在组件<strong class="ka ir"> A </strong>中，我们实际需要的是来自firebase的实时更改，而当我们不再在组件<strong class="ka ir"> A </strong>中时，我们可以取消订阅。没有这样做的标准机制，我们可以使用许多技术。我发现最简单的方法是使用带有主题的服务。</p><blockquote class="ly lz ma"><p id="d9b0" class="jy jz mb ka b kb kc kd ke kf kg kh ki mc kk kl km md ko kp kq me ks kt ku kv ij bi translated">主体是一种特殊的混合体，可以同时充当被观察者和观察者。</p></blockquote><p id="0038" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">服务很简单。(subscription.service.ts)</p><pre class="mf mg mh mi gt mj lx mk ml aw mm bi"><span id="471c" class="kw kx iq lx b gy mn mo l mp mq">@Injectable({<br/> providedIn: ‘root’<br/>})<br/>export class SubscriptionService {<br/> public unsubscribeComponent$ = new Subject&lt;void&gt;();<br/> public unsubscribe$ = this.unsubscribeComponent$.asObservable();<br/>}</span></pre><p id="adac" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们有两个公共领域。<code class="fe lu lv lw lx b">unsubscribeComponent$</code>应该用在组件中的和<code class="fe lu lv lw lx b"> unsubscribe$</code>应该用在效果中的。</p><p id="f7a0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">修改效果文件，将此服务包含在构造函数中，并添加<code class="fe lu lv lw lx b">takeUntil(this.subService.unsubscribe$)</code>以在离开组件时取消订阅。</p><pre class="mf mg mh mi gt mj lx mk ml aw mm bi"><span id="90ec" class="kw kx iq lx b gy mn mo l mp mq"><strong class="lx ir">constructor( private subService: SubscriptionService)</strong><br/>@Effect()<br/> loadPosts$ = this.actions$.pipe(<br/>   ofType(LOAD_POSTS),<br/>   pluck(‘payload’),<br/>   <strong class="lx ir">switchMap</strong>(uid =&gt;<br/>     this.db.getAllPosts(uid).pipe(<br/>       <strong class="lx ir">takeUntil(this.subService.unsubscribe$)</strong><br/>    ),<br/>   map(posts =&gt; new LoadPostsSuccess({ entries: posts }))<br/>   )<br/>  )<br/> );</span></pre><p id="f0ca" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，在我们调度这个动作的组件中，我们需要注入这个服务，并在<code class="fe lu lv lw lx b">ngOnDestroy() </code>方法中调用<code class="fe lu lv lw lx b">unsubscribeComponent$</code>主体的<code class="fe lu lv lw lx b">next()</code>方法。</p><pre class="mf mg mh mi gt mj lx mk ml aw mm bi"><span id="b273" class="kw kx iq lx b gy mn mo l mp mq"><strong class="lx ir">//A.component.ts</strong></span><span id="3484" class="kw kx iq lx b gy ms mo l mp mq"><strong class="lx ir">constructor( private subService: SubscriptionService)</strong></span><span id="af83" class="kw kx iq lx b gy ms mo l mp mq">ngOnDestroy(): void {<br/>  this.subService.unsubscribeComponent$.next();<br/>}</span></pre><p id="dc88" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，当我们在组件<strong class="ka ir"> A </strong>中时，我们会看到来自firebase的所有实时更改，但当我们导航离开时，我们将不会再听到这些更改，当我们再次激活组件<strong class="ka ir"> A </strong>时，动作将被分派，我们将再次看到实时更改。</p><p id="cca7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">感谢阅读全文。你可以用Angular+ RxJs + Firebase做更多更酷的事情，这将在下一篇文章中介绍。</p></div></div>    
</body>
</html>