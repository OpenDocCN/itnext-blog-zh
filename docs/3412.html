<html>
<head>
<title>JetStream: The Next Generation Of NATS Persistence Engine</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JetStream:下一代NATS持久引擎</h1>
<blockquote>原文：<a href="https://itnext.io/jetstream-the-next-generation-of-nats-persistence-engine-cb6c2c80dd20?source=collection_archive---------1-----------------------#2019-12-10">https://itnext.io/jetstream-the-next-generation-of-nats-persistence-engine-cb6c2c80dd20?source=collection_archive---------1-----------------------#2019-12-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a544" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">技术预览中主要概念的概述</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d870332d0ffd41f91a08dc97ae6783ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4XTdtwK7-9v3m2oX5Tu-yw.png"/></div></div></figure></div><div class="ab cl ku kv hx kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="im in io ip iq"><p id="a48d" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated"><strong class="ld iu">更新Mars 27 2020: </strong>以下文章是JetSteam的技术预览版第一版发布时写的。从那以后发生了很多变化。出于历史目的，本文将保留在此，但当JetStream正式上市时，将很快编写一个新版本。请继续收听:)</p><h1 id="cc69" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">主要概念</h1><p id="5017" class="pw-post-body-paragraph lb lc it ld b le mp ju lg lh mq jx lj lk mr lm ln lo ms lq lr ls mt lu lv lw im bi translated">在<a class="ae mu" rel="noopener ugc nofollow" target="_blank" href="/overview-of-nats-streaming-ea0e80449507">之前的帖子</a>中，我们展示了NATS Steaming，并通过一个简单的基于物联网的用例展示了它的一些功能。我们看到NATS流媒体在NATS之上实现了消息持久性:NATS流媒体的客户端和服务器通过底层的NATS服务器使用<a class="ae mu" href="https://developers.google.com/protocol-buffers/" rel="noopener ugc nofollow" target="_blank">谷歌协议缓冲区</a>交换二进制消息</p><p id="c773" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">JetStream是下一代NATS流。与其前身不同，JetStream的所有持久性功能都直接内置于NATS中，因此不需要使用任何额外的服务器。因此，JetStream的客户端只需要使用NATS的纯文本协议，没有更多的协议缓冲区。JetStream还提供了我们将在本帖中介绍的附加功能和新概念。</p><p id="6745" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">JetStream使用两个主要组件:</p><ul class=""><li id="a7d2" class="mv mw it ld b le lf lh li lk mx lo my ls mz lw na nb nc nd bi translated"><em class="ne">消息集</em>定义了我们想要存储的消息类型、排序、保留策略、副本和资源限制</li><li id="af85" class="mv mw it ld b le nf lh ng lk nh lo ni ls nj lw na nb nc nd bi translated">定义如何使用消息集的观察值</li></ul><p id="8e99" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">让我们看看如何在一个简单的例子中使用它们。</p></div><div class="ab cl ku kv hx kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="im in io ip iq"><h1 id="ed0c" class="lx ly it bd lz ma nk mc md me nl mg mh jz nm ka mj kc nn kd ml kf no kg mn mo bi translated">示例使用案例</h1><p id="44ff" class="pw-post-body-paragraph lb lc it ld b le mp ju lg lh mq jx lj lk mr lm ln lo ms lq lr ls mt lu lv lw im bi translated">在<a class="ae mu" rel="noopener ugc nofollow" target="_blank" href="/overview-of-nats-streaming-ea0e80449507">关于NATS流媒体的帖子</a>中，我们考虑了一个物联网应用。在本帖中，我们将使用该示例的简化版本，其中我们将仅考虑几个设备和单个微服务组件:</p><ul class=""><li id="a0e5" class="mv mw it ld b le lf lh li lk mx lo my ls mz lw na nb nc nd bi translated">一个设备在“<em class="ne">设备上发布消息。ID . events</em>subject(ID是当前设备标识符)并等待来自服务器的确认<strong class="ld iu">。</strong>此ack确保消息已被NATS正确接收，但并不表示任何关于向潜在订户交付的信息。发送的消息示例:</li></ul><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="160f" class="nu ly it nq b gy nv nw l nx ny">{ 'ts': '2019–12–08T23:12:00Z', 'temp': '21.3' }</span></pre><ul class=""><li id="6578" class="mv mw it ld b le lf lh li lk mx lo my ls mz lw na nb nc nd bi translated"><em class="ne">监听器</em>微服务应该订阅<em class="ne">设备。*.事件</em>”因此它接收包含由它订阅的每个设备发送的温度信息的消息。</li></ul><p id="ebec" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">注意:在NATS，流媒体客户端不能使用通配符来创建<strong class="ld iu">持久</strong>订阅。JetStream打破了这种限制，允许在一个消息集中有多个主题(以及对每个主题的通配符支持)。这绝对是JetStream提供的一个很棒的附加功能。</p><p id="3676" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">下面的模式说明了上面列出的组件。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/7c5e199a06aa68abc1a7a2e7b52576f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z2vs4M099kln8ZaH9ny4mQ.png"/></div></div><figcaption class="oa ob gj gh gi oc od bd b be z dk translated">示例用例的整体架构</figcaption></figure><p id="b25a" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">让我们看看如何使用JetStream来实现这个例子。</p></div><div class="ab cl ku kv hx kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="im in io ip iq"><h1 id="a4a9" class="lx ly it bd lz ma nk mc md me nl mg mh jz nm ka mj kc nn kd ml kf no kg mn mo bi translated">启动服务器</h1><p id="920b" class="pw-post-body-paragraph lb lc it ld b le mp ju lg lh mq jx lj lk mr lm ln lo ms lq lr ls mt lu lv lw im bi translated">JetStream目前是一个技术预览版，正在等待社区的反馈。由于jetstrteam特性还没有发布，我们首先需要克隆<a class="ae mu" href="http://github.com/nats-io/nats-server.git" rel="noopener ugc nofollow" target="_blank"> nats-server GitHub存储库</a>，切换到<em class="ne"> jetstream </em>分支并构建nats服务器(我们所需要的就是在本地机器上安装Golang)</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="ab0a" class="nu ly it nq b gy nv nw l nx ny">$ git clone <a class="ae mu" href="mailto:git@github.com" rel="noopener ugc nofollow" target="_blank">git@github.com</a>:nats-io/nats-server.git<br/>$ cd nats-server<br/>$ git checkout jetstream<br/>$ go build<br/>$ go install</span></pre><p id="85f3" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">可以使用<em class="ne"> nats-server </em>命令的<em class="ne"> -js </em>标志运行具有JetStream功能的NATS。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/c561c9754fd58dbbd74e179220b8c370.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yla7opyRnYXkzl7nrstJNw.png"/></div></div><figcaption class="oa ob gj gh gi oc od bd b be z dk translated">运行具有JetStream功能的NATS服务器</figcaption></figure><p id="ee07" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">注意:一个额外的<em class="ne"> -sd </em>标志可以用来指定存储目录</p><p id="4b86" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">JetStream使用JSM工具来管理消息集和可观察组件。在这个技术预览版中，首先需要使用以下命令构建JSM:</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="c5d7" class="nu ly it nq b gy nv nw l nx ny">$ cd jetstream/jsm<br/>$ go build<br/>$ go install</span></pre><p id="7225" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">jsm二进制文件现在可以使用了。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/cbc35f49110d9511748b3206bebc8ff1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dZOnA9EpHuoEqNBVtF5p_w.png"/></div></div><figcaption class="oa ob gj gh gi oc od bd b be z dk translated">JSM的可用命令</figcaption></figure></div><div class="ab cl ku kv hx kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="im in io ip iq"><h1 id="a40b" class="lx ly it bd lz ma nk mc md me nl mg mh jz nm ka mj kc nn kd ml kf no kg mn mo bi translated">创建消息集</h1><p id="283b" class="pw-post-body-paragraph lb lc it ld b le mp ju lg lh mq jx lj lk mr lm ln lo ms lq lr ls mt lu lv lw im bi translated">使用jsm二进制文件，我们首先创建一个消息集，它将负责在"<em class="ne">设备上发布的消息的存储。*.事件</em>主题。</p><p id="92ce" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">注意:jsm使用普通的NATS消息，这允许单个应用程序发布消息、消费者消息以及管理JetStream</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="c777" class="nu ly it nq b gy nv nw l nx ny">$ jsm add<br/>Enter the following information<br/>Name: <strong class="nq iu">devices-events</strong><br/>Subjects: <strong class="nq iu">devices.*.events</strong><br/>Limits (msgs, bytes, age):<br/>Storage: file<br/>Received response of "+OK"</span></pre><p id="af3f" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">该消息集具有以下规格:</p><ul class=""><li id="4baf" class="mv mw it ld b le lf lh li lk mx lo my ls mz lw na nb nc nd bi translated">它被命名为<em class="ne">设备-事件</em></li><li id="fad8" class="mv mw it ld b le nf lh ng lk nh lo ni ls nj lw na nb nc nd bi translated">它将存储在<em class="ne">设备上发布的所有消息。*.</em>主题事件</li><li id="7cc1" class="mv mw it ld b le nf lh ng lk nh lo ni ls nj lw na nb nc nd bi translated">它没有在消息数量、每个消息的大小和TTL(生存时间)方面定义任何消息限制</li><li id="3ef7" class="mv mw it ld b le nf lh ng lk nh lo ni ls nj lw na nb nc nd bi translated">将确保存储在本地文件系统上</li></ul><p id="3ec5" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">列出现有的消息集，我们可以看到刚刚创建的消息集</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="199c" class="nu ly it nq b gy nv nw l nx ny">$ jsm list</span><span id="238d" class="nu ly it nq b gy og nw l nx ny">1) devices-events</span></pre><p id="4003" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">由于没有设备发布任何消息，该消息集目前为空，我们可以从<em class="ne"> info </em>命令中看到:</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="f741" class="nu ly it nq b gy nv nw l nx ny">$ jsm info devices-events</span><span id="e18e" class="nu ly it nq b gy og nw l nx ny">Messages: 0<br/>Bytes:    0 B<br/>FirstSeq: 0<br/>LastSeq:  0</span></pre><p id="4bf1" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">现在让我们用一个虚拟设备向NATS发送数据。我们将使用以下Python代码，即使用NATS官方Python客户端的代码:</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="8a72" class="nu ly it nq b gy nv nw l nx ny">import asyncio<br/>import time<br/>import datetime<br/>import random<br/>import json<br/>import sys<br/>from nats.aio.client import Client as NATS</span><span id="e185" class="nu ly it nq b gy og nw l nx ny"># Get device ID<br/>device_id = sys.argv[1]</span><span id="ee31" class="nu ly it nq b gy og nw l nx ny"># Get NATS client<br/>nc = NATS()</span><span id="5495" class="nu ly it nq b gy og nw l nx ny">async def sending():<br/>    while True:<br/>      # Build message (with current timestamp and dummy temperature)<br/>      now = datetime.datetime.utcnow()<br/>      ts = now.strftime("%Y-%m-%dT%H:%M:%ST")<br/>      temp = round(random.uniform(20,25), 2)<br/>      msg = json.dumps({'ts': ts, 'temp': temp}).encode()</span><span id="d678" class="nu ly it nq b gy og nw l nx ny">      # Send message and wait for an ACK<br/>      subject = "devices.{}.events".format(device_id)<br/>      async def ack_handler(msg):<br/>        data = msg.data.decode()<br/>        print("Received {data}".format(data=data))<br/>      print("Sending {msg}".format(msg=msg))<br/>      await nc.request(subject, msg, cb=ack_handler)</span><span id="f31a" class="nu ly it nq b gy og nw l nx ny">      # Wait before sending next message<br/>      await asyncio.sleep(1)</span><span id="8847" class="nu ly it nq b gy og nw l nx ny">async def main():<br/>    # Connect client to NATS<br/>    await nc.connect()</span><span id="40e6" class="nu ly it nq b gy og nw l nx ny">    # Define sending task<br/>    send = asyncio.create_task(sending())<br/>    await send</span><span id="fb10" class="nu ly it nq b gy og nw l nx ny">asyncio.run(main())</span></pre><p id="e16b" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">可以使用以下命令运行该脚本，并提供一个设备标识符作为参数:</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="a631" class="nu ly it nq b gy nv nw l nx ny">$ python device.py 3F45</span></pre><p id="28ce" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">几秒钟后，我们可以看到我们的消息集现在包含几条消息:</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="45a1" class="nu ly it nq b gy nv nw l nx ny">$ jsm info devices-events</span><span id="a0ac" class="nu ly it nq b gy og nw l nx ny">Messages: 72<br/>Bytes:    6.8 kB<br/>FirstSeq: 1<br/>LastSeq:  72</span></pre><p id="7f87" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">下面的动画演示了以下流程:</p><ul class=""><li id="4071" class="mv mw it ld b le lf lh li lk mx lo my ls mz lw na nb nc nd bi translated">标识符为3F45的设备每分钟在“<em class="ne">devices . 3f 45 . events”</em>(左上)上发布一条消息</li><li id="7c5b" class="mv mw it ld b le nf lh ng lk nh lo ni ls nj lw na nb nc nd bi translated">标识符为28E3的设备每分钟在“<em class="ne">设备上发布一条消息。</em> 28E3 <em class="ne">。事件"</em>(左下角)</li><li id="847e" class="mv mw it ld b le nf lh ng lk nh lo ni ls nj lw na nb nc nd bi translated">消息集内容的演变(右)</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/0badf6b6bf95eb19cb5254a754a52042.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Mywb9U60jo8D_xEGuVmuHQ.gif"/></div></div><figcaption class="oa ob gj gh gi oc od bd b be z dk translated">添加到消息集中的消息</figcaption></figure><p id="064d" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">下一步是创建一个可观察对象，它将定义如何使用存储在消息集中的消息。</p></div><div class="ab cl ku kv hx kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="im in io ip iq"><h1 id="149b" class="lx ly it bd lz ma nk mc md me nl mg mh jz nm ka mj kc nn kd ml kf no kg mn mo bi translated">创造一个可观察的</h1><p id="5967" class="pw-post-body-paragraph lb lc it ld b le mp ju lg lh mq jx lj lk mr lm ln lo ms lq lr ls mt lu lv lw im bi translated">jsm二进制允许以交互的方式创建一个可观察对象。需要设置几个参数:</p><ul class=""><li id="c8ca" class="mv mw it ld b le lf lh li lk mx lo my ls mz lw na nb nc nd bi translated">基础消息集的名称</li><li id="e90d" class="mv mw it ld b le nf lh ng lk nh lo ni ls nj lw na nb nc nd bi translated"><strong class="ld iu">持久名称</strong>定义了持久订阅的名称(<em class="ne">持久</em>是NATS流中引入的概念)。虽然JetStream支持持久和短暂的可观测量(最后一个需要一个活跃的订户)，但在当前版本中，<em class="ne"> jsm </em>只支持持久测量</li><li id="bcd2" class="mv mw it ld b le nf lh ng lk nh lo ni ls nj lw na nb nc nd bi translated">消费类型:基于推还是基于拉。</li><li id="0c94" class="mv mw it ld b le nf lh ng lk nh lo ni ls nj lw na nb nc nd bi translated">消费者应该订阅的主题，以便获取消息(仅用于推送)</li><li id="de88" class="mv mw it ld b le nf lh ng lk nh lo ni ls nj lw na nb nc nd bi translated"><strong class="ld iu">交付策略</strong>定义了消息将如何交付。这里有几种可能性:从第一条消息开始发送，只发送最后一条消息，从特定时间开始发送所有消息</li><li id="c9a9" class="mv mw it ld b le nf lh ng lk nh lo ni ls nj lw na nb nc nd bi translated"><strong class="ld iu">确认策略</strong>定义客户端应用程序是否以及如何确认消息传递:<em class="ne"> none </em> (NoAck)表示不需要确认，<em class="ne"> all </em> (AckAll)表示所有消息，直到当前序列号被确认，AckExplicit表示每个消息需要单独确认</li><li id="3aa3" class="mv mw it ld b le nf lh ng lk nh lo ni ls nj lw na nb nc nd bi translated"><strong class="ld iu">重放策略</strong>定义了消息传递的方式。两个可用选项:一行中的所有消息，它们之间没有任何特定的延迟，或者一个接一个地考虑它们之间存在的原始延迟</li></ul><p id="f668" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">在本例中，我们用以下参数配置了可观察对象:</p><ul class=""><li id="158f" class="mv mw it ld b le lf lh li lk mx lo my ls mz lw na nb nc nd bi translated">底层消息集是<strong class="ld iu">设备-事件</strong></li><li id="8ecf" class="mv mw it ld b le nf lh ng lk nh lo ni ls nj lw na nb nc nd bi translated">持久名称设置为<strong class="ld iu">温度</strong>(因为它用于从设备获取温度相关信息)</li><li id="66fa" class="mv mw it ld b le nf lh ng lk nh lo ni ls nj lw na nb nc nd bi translated">它被定义为基于<strong class="ld iu">推动</strong>的消费</li><li id="7dda" class="mv mw it ld b le nf lh ng lk nh lo ni ls nj lw na nb nc nd bi translated">消息将被推送给订阅了<strong class="ld iu">设备.事件</strong>主题的所有消费者。消息将使用它们发布时的原始主题来传递(稍后会有更多相关内容)。</li></ul><p id="55b5" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">注意:从可伸缩性的角度来看，对于基于推送的可观察对象，不建议有多个消费者。基于拉的可观察允许容易的缩放。</p><ul class=""><li id="85be" class="mv mw it ld b le lf lh li lk mx lo my ls mz lw na nb nc nd bi translated">默认值用于所有其他选项</li></ul><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="6682" class="nu ly it nq b gy nv nw l nx ny">$ jsm add-obs<br/>Enter the following information<br/>Message Set Name: <strong class="nq iu">devices-events</strong><br/>Durable Name: <strong class="nq iu">temperature</strong><br/>Push or Pull: <strong class="nq iu">Push</strong><br/>Delivery Subject: <strong class="nq iu">devices.events</strong><br/>Deliver All? (Y|n):<br/>AckPolicy (None|all|explicit):<br/>Replay Policy (Instant|original):<br/>Received response of "+OK"</span></pre><p id="eb92" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">使用<em class="ne"> jsm，</em>我们可以列出一个给定消息的所有可观察到的现象:</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="cb6b" class="nu ly it nq b gy nv nw l nx ny">$ jsm ls-obs devices-events</span><span id="beb9" class="nu ly it nq b gy og nw l nx ny">1) temperature</span></pre><p id="e43f" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">我们还可以使用观察对象的名称和它所操作的消息集来获得观察对象的信息:</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="2a8a" class="nu ly it nq b gy nv nw l nx ny">$ jsm info-obs devices-events temperature<br/>Received response of {<br/>  "Delivered": {<br/>    "ObsSeq": 1,<br/>    "SetSeq": 1<br/>  },<br/>  "AckFloor": {<br/>    "ObsSeq": 0,<br/>    "SetSeq": 0<br/>  },<br/>  "Pending": null,<br/>  "Redelivery": null<br/>}</span></pre><p id="a673" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">这里需要注意几件事:</p><ul class=""><li id="62e8" class="mv mw it ld b le lf lh li lk mx lo my ls mz lw na nb nc nd bi translated">要传递的下一条消息是序列号为1的消息</li><li id="ff38" class="mv mw it ld b le nf lh ng lk nh lo ni ls nj lw na nb nc nd bi translated">尚未确认任何消息</li><li id="cdf7" class="mv mw it ld b le nf lh ng lk nh lo ni ls nj lw na nb nc nd bi translated">当前没有挂起的消息(已发送但未确认)</li><li id="89f6" class="mv mw it ld b le nf lh ng lk nh lo ni ls nj lw na nb nc nd bi translated">没有消息被重新传递</li></ul><p id="e93a" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">现在可观察对象被创建，常规的NATS客户端可以订阅"<em class="ne">devices . events "</em>subject，以便接收存储在底层消息集中的消息。</p><p id="2266" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">让我们考虑一个名为<em class="ne"> listener </em>的微服务，它负责收集和解析每条消息，并将其内容存储到一个时间序列数据库中(InfluxDB可能是实现这一目的的最佳选择，但这是另一个故事)。以下Python代码是侦听器的简化版本:</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="b8a2" class="nu ly it nq b gy nv nw l nx ny">import asyncio<br/>import json<br/>import ssl<br/>import sys<br/>from nats.aio.client import Client as NATS</span><span id="e30f" class="nu ly it nq b gy og nw l nx ny">async def run(loop):</span><span id="e049" class="nu ly it nq b gy og nw l nx ny">    # Connection to NATS<br/>    nc = NATS()<br/>    await nc.connect(io_loop=loop)</span><span id="6e40" class="nu ly it nq b gy og nw l nx ny">    # Handling incoming messages<br/>    async def message_handler(msg):<br/>        data = json.loads(msg.data.decode())<br/>        print(data)</span><span id="32e1" class="nu ly it nq b gy og nw l nx ny">    # Subscription to "devices.events"<br/>    subject="devices.events"<br/>    await nc.subscribe(subject, cb=message_handler)<br/>    print('Subscribed to [%s]' % subject);</span><span id="c4a8" class="nu ly it nq b gy og nw l nx ny">if __name__ == '__main__':<br/>    loop = asyncio.get_event_loop()<br/>    loop.run_until_complete(run(loop))<br/>    try:<br/>        loop.run_forever()<br/>    finally:<br/>        loop.close()</span></pre><p id="ad3a" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">这里需要注意一件重要的事情:侦听器订阅“<em class="ne">设备.事件</em>主题，而每个设备向“<em class="ne">设备发送消息。ID.events </em> " subject (ID是设备的唯一标识符)。事实上，如果侦听器订阅了"<em class="ne"> devices.events </em>"，它将接收到关于消息原始主题的消息。这种行为在下一个版本中可能会有所改变，这样客户端就可以直接订阅原始主题。</p><p id="69e8" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">启动侦听器，我们可以看到从消息集中的第一条消息开始，所有消息都被传递。下面的动画演示了监听器收到的所有消息。可观察的状态被改变，显示所有的消息都已经被传递(在这个例子中，消息集中有25条消息)</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/b91af51b3c246d8bf98ae99136a620b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*ZnRLUjCG8zAtzKDoGnp71Q.gif"/></div></div><figcaption class="oa ob gj gh gi oc od bd b be z dk translated">用户接收存储在消息集中的消息</figcaption></figure><p id="3267" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">如果设备发布了其他消息，侦听器将会接收到这些消息。此外，如果侦听器碰巧离线，而设备继续发布消息，它将从它确认的最后一个序列号开始接收消息。</p></div><div class="ab cl ku kv hx kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="im in io ip iq"><h1 id="aa63" class="lx ly it bd lz ma nk mc md me nl mg mh jz nm ka mj kc nn kd ml kf no kg mn mo bi translated">摘要</h1><p id="7421" class="pw-post-body-paragraph lb lc it ld b le mp ju lg lh mq jx lj lk mr lm ln lo ms lq lr ls mt lu lv lw im bi translated">我们只涉及JetStream背后的一些主要概念。此外，由于JetSteam服务是在NATS境内实施的，所有的NATS 2.0安全功能都可以直接用于验证和授权客户。</p><p id="a222" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">这篇文章基于JetStream的技术预览。因为在它达到稳定版本之前事情可能会改变，这篇文章将会定期更新以反映它的发展。</p></div></div>    
</body>
</html>