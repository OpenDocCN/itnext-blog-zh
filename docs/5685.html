<html>
<head>
<title>Async Rust: history strikes back.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">异步生锈:历史反击。</h1>
<blockquote>原文：<a href="https://itnext.io/async-rust-history-strikes-back-d69aced6760?source=collection_archive---------0-----------------------#2021-05-03">https://itnext.io/async-rust-history-strikes-back-d69aced6760?source=collection_archive---------0-----------------------#2021-05-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/000f6220d82010f515bcfeef38ab044d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dLTi22htUleDWBCfWr2JmQ.jpeg"/></div></div></figure><div class=""/><blockquote class="kb kc kd"><p id="4d97" class="ke kf kg kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">那些不研究历史的人注定要重复历史。</p><p id="2579" class="ke kf kg kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">那些研究历史的人注定只能坐在一边看着某个白痴重复历史。</p></blockquote><p id="d84a" class="pw-post-body-paragraph ke kf je kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc im bi translated">上周，我们发布了新版本的Glommio T4，这是一个针对Rust的每核线程异步执行器。让每个单独的执行器在单线程的范围内工作，可以让我们做出很多生态系统无法做到的保证。在我们最新的版本中，我们确信我们已经精心制作了一个定义良好的API，它将简化异步Glommio程序的创建。却发现我们只是在重复前人的错误。</p><p id="51a4" class="pw-post-body-paragraph ke kf je kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc im bi translated">根据经验，我们作为人喜欢谈论我们的成功，而不是我们的失败。稍微颠倒一下，我想我应该花点时间写一写最近的失败，思考一下异步Rust是如何比它看起来更困难和充满惊喜，以及这对它的未来意味着什么。</p><h1 id="1233" class="lh li je bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">问题是</h1><p id="279a" class="pw-post-body-paragraph ke kf je kh b ki mf kk kl km mg ko kp ld mh ks kt le mi kw kx lf mj la lb lc im bi translated">Rust中新人的一个众所周知的摩擦来源是带有生命周期规则的借货检查器。然而，借用检查器赋予Rust独特的风格并保证内存安全:编译器为您强制执行这些规则，只要您不编写标有<code class="fe mk ml mm mn b">unsafe</code>关键字的代码，内存损坏就不可能发生。</p><p id="578e" class="pw-post-body-paragraph ke kf je kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc im bi translated">尽管有最初的摩擦，一旦理解了，生存期通常是容易处理的:一个对象将是活的，直到它超出范围，并且你一次只能保持对它的一个可变引用。</p><p id="d6f4" class="pw-post-body-paragraph ke kf je kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc im bi translated">对于异步代码，这个模型变得有点复杂:就其本质而言，异步代码可以在未来的任何时间执行(或者根本不执行)，这使得作用域不可预测。因此，像这样的代码需要一个<code class="fe mk ml mm mn b">'static</code>界限:一个特殊的生存期参数，它指示一个对象在程序的整个持续时间内都是活动的。</p><p id="9274" class="pw-post-body-paragraph ke kf je kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc im bi translated">例如，请看如何在Rust中<a class="ae lg" href="https://doc.rust-lang.org/std/thread/fn.spawn.html" rel="noopener ugc nofollow" target="_blank">生成</a>一个新线程:</p><figure class="mo mp mq mr gt iv"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="d013" class="pw-post-body-paragraph ke kf je kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc im bi translated">尽管这被认为是同步代码，但问题是相同的，并且是这个问题有多普遍的一个很好的例子:因为线程将继续在后台运行，所以当它在线程中被访问时，你的数据可能已经死了很久，所以你需要<code class="fe mk ml mm mn b">'static</code>数据。</p><p id="daf1" class="pw-post-body-paragraph ke kf je kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc im bi translated">在异步Rust中，不产生线程，而是产生<em class="kg">任务。</em>像线程一样，任务可能独立于它们的原始上下文运行，因此也需要<code class="fe mk ml mm mn b">'static</code>关键字。相比同步线程，Tokio的spawn有<a class="ae lg" href="https://docs.rs/tokio/1.5.0/tokio/fn.spawn.html" rel="noopener ugc nofollow" target="_blank">类似的方法</a>，async-std <a class="ae lg" href="https://docs.rs/async-std/1.9.0/async_std/task/fn.spawn.html" rel="noopener ugc nofollow" target="_blank">也是一样的</a>，Glommio当然<a class="ae lg" href="https://docs.rs/glommio/0.3.1/glommio/struct.Task.html#method.local" rel="noopener ugc nofollow" target="_blank">也不例外</a>。与线程的主要区别在于，您将未来而不是同步闭包传递给那些函数。</p><p id="79a5" class="pw-post-body-paragraph ke kf je kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc im bi translated">由于对动态创建的对象的引用不是<code class="fe mk ml mm mn b">'static</code>，并且产生整个程序的引用很少——它们只发生在静态定义的变量中，更常见的是<code class="fe mk ml mm mn b">'static</code>边界意味着根本没有引用。对象的所有权被转移到异步上下文中，完全避免了生存期问题。</p><p id="992e" class="pw-post-body-paragraph ke kf je kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc im bi translated">但是很多时候，我们仍然希望在对象的原始上下文中使用它，或者在许多异步任务中使用它。解决方案是使用<em class="kg">引用计数指针，</em>因为这样的指针强制不变性，所以也必须使用<a class="ae lg" href="https://doc.rust-lang.org/book/ch15-05-interior-mutability.html" rel="noopener ugc nofollow" target="_blank">内部可变性</a>模式。</p><p id="9c3c" class="pw-post-body-paragraph ke kf je kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc im bi translated">在下面简单的Glommio示例中，我们希望在任务和原始上下文之间共享<code class="fe mk ml mm mn b">keep_running</code>变量，并使用它来控制任务将运行多长时间。注意，它必须被包装在一个共享指针中(<code class="fe mk ml mm mn b">Rc</code>)，由于在Rust中共享指针是不可变的，我们需要使用内部可变性模式(<code class="fe mk ml mm mn b">Cell</code>)。</p><figure class="mo mp mq mr gt iv"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="cfd5" class="pw-post-body-paragraph ke kf je kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc im bi translated">引用计数不是世界末日。事实上，在早些时候的一篇文章《T21》中，我认为这是我们生活在一个文明的异步世界中的代价。与简单的内存访问相比，共享指针增加了一个算术运算和一个可能的缓存解引用。对于现代处理器来说，两者都应该非常便宜。</p><p id="3fb7" class="pw-post-body-paragraph ke kf je kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc im bi translated">但这并不意味着它们是免费的，如果我们能够避免它们，我们显然会过得更好。此外，关于任何原语的成本或缺乏成本的总括声明是有问题的。肯定有引用计数变得非常昂贵的情况吧？</p><p id="341b" class="pw-post-body-paragraph ke kf je kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc im bi translated">确实有:当差别不再是你做多少工作来访问数据，而是必须做工作或根本不做工作。</p><p id="4a52" class="pw-post-body-paragraph ke kf je kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc im bi translated">例如，考虑一个大的引用向量。一旦它们超出了作用域，编译器可以简单地释放vector的后备内存并完成它，这非常快。但是如果你累积一个引用计数的向量，编译器现在必须遍历它们，减少它们的引用计数，并潜在地单独释放它们。在这种情况下，有很多额外的工作要做，相比之下，如果我们可以使用简单的引用，则没有工作。如果你有少量的引用，这并不重要，但是随着vector的增长，这就变得很重要了。</p><h1 id="bd93" class="lh li je bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">我们能做得更好吗？</h1><p id="d9e5" class="pw-post-body-paragraph ke kf je kh b ki mf kk kl km mg ko kp ld mh ks kt le mi kw kx lf mj la lb lc im bi translated">任务可以超越它们最初的范围，但并不总是如此。事实上，大多数时候他们不会。异步代码最终看起来像下面的代码:</p><figure class="mo mp mq mr gt iv"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="a8b2" class="pw-post-body-paragraph ke kf je kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc im bi translated">通常情况下，任务有一个明确的生命周期:它们需要被终止，我们知道一旦发生，它们将不再执行。如果不是，它们会被立即取消，所以它们也不会造成任何伤害。为了让任务在其原始范围之外继续存在，需要显式地<code class="fe mk ml mm mn b">.detach()</code>它(在Glommio的情况下，尽管其他执行器也是类似的)。那么，如果我们提供一个永远无法分离的<code class="fe mk ml mm mn b">Task</code>版本，并且要么马上死亡，要么在某个特定点终止，会怎么样呢？</p><p id="ab6a" class="pw-post-body-paragraph ke kf je kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc im bi translated">经过一些<a class="ae lg" href="https://github.com/DataDog/glommio/pull/335" rel="noopener ugc nofollow" target="_blank">讨论</a>，我们想出了<a class="ae lg" href="https://docs.rs/glommio/0.4.0/glommio/struct.ScopedTask.html#method.local" rel="noopener ugc nofollow" target="_blank">与</a> <code class="fe mk ml mm mn b"><a class="ae lg" href="https://docs.rs/glommio/0.4.0/glommio/struct.ScopedTask.html#method.local" rel="noopener ugc nofollow" target="_blank">ScopedTask.</a></code>顾名思义，<code class="fe mk ml mm mn b">ScopedTask</code>有一个很好定义的范围。没有提供允许后台执行的方法，所以我们确切地知道它什么时候结束。与普通任务一样，<code class="fe mk ml mm mn b">ScopedTask</code>会立即开始执行，因此它仍然可以用于驱动并发性。</p><h1 id="8522" class="lh li je bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">历史重演？</h1><p id="05b3" class="pw-post-body-paragraph ke kf je kh b ki mf kk kl km mg ko kp ld mh ks kt le mi kw kx lf mj la lb lc im bi translated">除了新来者的摩擦问题，我最近发现自己的两个实例中，下降矢量的钢筋混凝土问题显示出明显的热点。所以我很高兴终于可以用<code class="fe mk ml mm mn b">ScopedTask</code>来解决这个问题。</p><p id="17db" class="pw-post-body-paragraph ke kf je kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc im bi translated">当然，除了我们不是第一个这样做的人。幸运的话，这篇文章将帮助我们成为最后一个。事实证明，早在2015年<a class="ae lg" href="https://github.com/rust-lang/rust/issues/24292" rel="noopener ugc nofollow" target="_blank"> Rust的标准库<em class="kg">就从其同步线程实现</em></a>中移除了一个类似的API。读到这里，我感到欣慰的是，比我更有经验的农村人一开始也没有发现这个问题。像往常一样，事情在被发现之前根本不容易被发现，而发现之后事情就变得非常明显了。</p><p id="fd70" class="pw-post-body-paragraph ke kf je kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc im bi translated">报告中的原始代码有点难以理解，但它归结为一个事实，即在Rust，<em class="kg">中，不能保证析构函数会运行。</em>毫无疑问，这些很可能是bug。但是Rust lifetime规则的要点是，虽然这是生活中的事实，但是错误不应该导致无效的内存被访问。</p><p id="f630" class="pw-post-body-paragraph ke kf je kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc im bi translated">下面是一个更容易理解的例子，虽然更人为:</p><figure class="mo mp mq mr gt iv"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="b923" class="pw-post-body-paragraph ke kf je kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc im bi translated"><a class="ae lg" href="https://doc.rust-lang.org/std/mem/fn.forget.html" rel="noopener ugc nofollow" target="_blank"> std::mem::forget </a>阻止析构函数运行。所以他们没有，而我们从未完成的可怜任务也从未被取消，并继续制造混乱，破坏Rust的安全保证。</p><h1 id="a33d" class="lh li je bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">现在怎么办？</h1><p id="5ea1" class="pw-post-body-paragraph ke kf je kh b ki mf kk kl km mg ko kp ld mh ks kt le mi kw kx lf mj la lb lc im bi translated">我们非常幸运，虽然这不幸地通过了审查过程，但一旦它通过发行说明达到更广泛的范围，我们的一个用户和频繁的<a class="ae lg" href="https://github.com/trtsl" rel="noopener ugc nofollow" target="_blank">贡献者</a>显然研究过历史，发现了这个问题，并决定不会坐着看一些白痴重复它。新版本被从crates.io中删除，新版本将会出现在这个API被标记为不安全的地方，直到我们想出该怎么做。</p><p id="2fe3" class="pw-post-body-paragraph ke kf je kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc im bi translated">这也是一个反思的机会。当我越来越接近我写Rust代码的第一年的时候，这告诉了我什么？在某种程度上，我感到欣慰的是，这样的事情表明了社区对Rust的安全保证是多么重视。尽管遭到抗议，一个类似的设计还是被从标准库中删除了，抵制了对这个不适定的例子不屑一顾的诱惑。</p><p id="ce63" class="pw-post-body-paragraph ke kf je kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc im bi translated">另一方面，令人难过的是，内存模型迫使异步Rust生态系统中的许多东西强加了不必要的高成本。不得不依赖共享指针就是一个例子，但是还有其他众所周知的例子，比如使用异步特征的<a class="ae lg" href="https://rust-lang.github.io/async-book/07_workarounds/05_async_in_traits.html" rel="noopener ugc nofollow" target="_blank">强制内存分配</a>。</p><p id="99b4" class="pw-post-body-paragraph ke kf je kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc im bi translated">总的来说，我仍然看到了铁锈的光明前景。<a class="ae lg" href="https://rust-lang.github.io/wg-async-foundations/welcome.html" rel="noopener ugc nofollow" target="_blank">异步基金会工作组</a>似乎明确意识到这些问题，并努力解决它们。他们肯定致力于让异步Rust变得更好。最近还有令人瞠目结舌的消息，Rust被认为是除了C语言之外的第一种用于<a class="ae lg" href="https://lwn.net/Articles/853423/" rel="noopener ugc nofollow" target="_blank">编写Linux内核代码</a>的语言。作为一个在近十年的大部分时间里以编写Linux内核代码为生的人，这是一个不小的成就。</p><p id="bea2" class="pw-post-body-paragraph ke kf je kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc im bi translated">现在，我所能希望的是，我最近的冒险也能帮助你了解这个社区的历史，避免重蹈覆辙。</p></div></div>    
</body>
</html>