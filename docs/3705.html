<html>
<head>
<title>Kubernetes: running a push-server with Gorush behind an AWS LoadBalancer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes:在AWS负载均衡器后面运行带有Gorush的推送服务器</h1>
<blockquote>原文：<a href="https://itnext.io/kubernetes-running-a-push-server-with-gorush-behind-an-aws-loadbalancer-48563f9a0319?source=collection_archive---------7-----------------------#2020-02-06">https://itnext.io/kubernetes-running-a-push-server-with-gorush-behind-an-aws-loadbalancer-48563f9a0319?source=collection_archive---------7-----------------------#2020-02-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/e2de23e96997a20591779397cc9eb688.png" data-original-src="https://miro.medium.com/v2/resize:fit:260/format:webp/0*NU8dYYHgPPiOAZlg.png"/></div></figure><p id="e14c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">Gorush是一个Go-written应用程序，我们计划用它向我们的移动客户端发送推送通知。</p><p id="23b1" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">项目所在地—<a class="ae ks" href="https://github.com/appleboy/gorush" rel="noopener ugc nofollow" target="_blank">https://github.com/appleboy/gorush</a></p><p id="e4cd" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">该服务将在我们的Kubernetes集群中的专用名称空间中运行，并且必须只能在集群的VPC中访问，因此我们将使用AWS的内部ALB。</p><h2 id="de8e" class="kt ku iq bd kv kw kx dn ky kz la dp lb kf lc ld le kj lf lg lh kn li lj lk ll bi translated">运行Gorush服务</h2><h2 id="2382" class="kt ku iq bd kv kw kx dn ky kz la dp lb kf lc ld le kj lf lg lh kn li lj lk ll bi translated">命名空间</h2><p id="dfe6" class="pw-post-body-paragraph ju jv iq jw b jx lm jz ka kb ln kd ke kf lo kh ki kj lp kl km kn lq kp kq kr ij bi translated">克隆存储库:</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="6b75" class="kt ku iq lw b gy ma mb l mc md">$ git clone <a class="ae ks" href="https://github.com/appleboy/gorush" rel="noopener ugc nofollow" target="_blank">https://github.com/appleboy/gorush</a><br/>$ cd gorush/k8s/</span></pre><p id="4425" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">创建一个名称空间和一个<code class="fe me mf mg lw b"><a class="ae ks" href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-configmap/" rel="noopener ugc nofollow" target="_blank">confgiMap</a></code>，用于配置对本地Redis服务的访问:</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="8376" class="kt ku iq lw b gy ma mb l mc md">$ kubectl apply -f gorush-namespace.yaml<br/>namespace/gorush created<br/>$ kubectl apply -f gorush-configmap.yaml<br/>configmap/gorush-config created</span></pre><p id="13e5" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们也可以稍后使用这个<code class="fe me mf mg lw b">configMap</code>为Gorush服务添加我们自己的配置文件。</p><p id="0d3c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">检查资源:</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="bab1" class="kt ku iq lw b gy ma mb l mc md">$ kubectl -n gorush get cm<br/>NAME DATA AGE<br/>gorush-config 2 20s</span></pre><h2 id="09b5" class="kt ku iq bd kv kw kx dn ky kz la dp lb kf lc ld le kj lf lg lh kn li lj lk ll bi translated">雷迪斯</h2><p id="2d1f" class="pw-post-body-paragraph ju jv iq jw b jx lm jz ka kb ln kd ke kf lo kh ki kj lp kl km kn lq kp kq kr ij bi translated">启动Redis服务:</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="bd0c" class="kt ku iq lw b gy ma mb l mc md">$ kubectl apply -f gorush-redis-deployment.yaml<br/>deployment.extensions/redis created<br/>$ kubectl apply -f gorush-redis-service.yaml<br/>service/redis created</span></pre><h2 id="1d18" class="kt ku iq bd kv kw kx dn ky kz la dp lb kf lc ld le kj lf lg lh kn li lj lk ll bi translated">Gorush</h2><p id="08b5" class="pw-post-body-paragraph ju jv iq jw b jx lm jz ka kb ln kd ke kf lo kh ki kj lp kl km kn lq kp kq kr ij bi translated">我想在创建Gorush后用Debian添加一个额外的pod来运行测试，以确保它能正常工作，所以让我们用一个名为<em class="mh"> Bastion </em>的新容器来更新部署文件<code class="fe me mf mg lw b">gorush-deployment.yaml</code>:</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="d5cc" class="kt ku iq lw b gy ma mb l mc md">apiVersion: extensions/v1beta1<br/>kind: Deployment<br/>metadata:<br/>  name: gorush<br/>  namespace: gorush<br/>spec:<br/>  replicas: 3<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: gorush<br/>        tier: frontend<br/>    spec:<br/>      containers:<br/>      - image: appleboy/gorush<br/>        name: gorush<br/>        imagePullPolicy: Always<br/>        ports:<br/>        - containerPort: 8088<br/>        livenessProbe:<br/>          httpGet:<br/>            path: /healthz<br/>            port: 8088<br/>          initialDelaySeconds: 3<br/>          periodSeconds: 3<br/>        env:<br/>        - name: GORUSH_STAT_ENGINE<br/>          valueFrom:<br/>            configMapKeyRef:<br/>              name: gorush-config<br/>              key: stat.engine<br/>        - name: GORUSH_STAT_REDIS_ADDR<br/>          valueFrom:<br/>            configMapKeyRef:<br/>              name: gorush-config<br/>              key: stat.redis.host<br/>      - image: debian<br/>        name: bastion<br/>        command: ["sleep"]<br/>        args: ["600"]</span></pre><p id="dc7e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在我们可以开始Gorush了:</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="fece" class="kt ku iq lw b gy ma mb l mc md">$ kubectl apply -f gorush-deployment.yaml<br/>deployment.extensions/gorush created</span></pre><p id="1f18" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">检查舱:</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="3761" class="kt ku iq lw b gy ma mb l mc md">$ kubectl -n gorush get po<br/>NAME READY STATUS RESTARTS AGE<br/>gorush-59bd9dd4fc-dzm47 2/2 Running 0 8s<br/>gorush-59bd9dd4fc-fkrhw 2/2 Running 0 8s<br/>gorush-59bd9dd4fc-klsbz 2/2 Running 0 8s<br/>redis-7d5844c58d-7j5jp 1/1 Running 0 3m1s</span></pre><h2 id="bdaa" class="kt ku iq bd kv kw kx dn ky kz la dp lb kf lc ld le kj lf lg lh kn li lj lk ll bi translated">AWS内部应用程序负载平衡器</h2><p id="76cb" class="pw-post-body-paragraph ju jv iq jw b jx lm jz ka kb ln kd ke kf lo kh ki kj lp kl km kn lq kp kq kr ij bi translated">接下来要创建的是一个带有<code class="fe me mf mg lw b"><a class="ae ks" href="https://rtfm.co.ua/en/kubernetes-part-1-architecture-and-main-components-overview/#NodePort" rel="noopener ugc nofollow" target="_blank">NodePort</a></code>的服务和一个<code class="fe me mf mg lw b"><a class="ae ks" href="https://kubernetes.io/docs/concepts/services-networking/ingress/" rel="noopener ugc nofollow" target="_blank">Ingress</a></code>服务，后者将触发一个<code class="fe me mf mg lw b"><a class="ae ks" href="https://github.com/kubernetes-sigs/aws-alb-ingress-controller" rel="noopener ugc nofollow" target="_blank">alb-ingress-controller</a></code>来在AWS帐户上创建一个新的负载平衡器。</p><p id="8e81" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">更新<code class="fe me mf mg lw b">gorush-service.yaml</code>，取消<code class="fe me mf mg lw b">NodePort</code>的注释，并注释掉<code class="fe me mf mg lw b">LoadBalancer</code>行:</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="2b83" class="kt ku iq lw b gy ma mb l mc md">...<br/>#type: LoadBalancer<br/>type: NodePort<br/>...</span></pre><p id="8798" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">所以现在看起来像是:</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="46ad" class="kt ku iq lw b gy ma mb l mc md">apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: gorush<br/>  namespace: gorush<br/>  labels:<br/>    app: gorush<br/>    tier: frontend<br/>spec:<br/>  selector:<br/>    app: gorush<br/>    tier: frontend<br/>  # if your cluster supports it, uncomment the following to automatically create<br/>  # an external load-balanced IP for the frontend service.<br/>  #type: LoadBalancer<br/>  type: NodePort<br/>  ports:<br/>  - protocol: TCP<br/>    port: 80<br/>    targetPort: 8088</span></pre><p id="efcd" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">创建服务:</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="1deb" class="kt ku iq lw b gy ma mb l mc md">$ kubectl apply -f gorush-service.yaml<br/>service/gorush created</span></pre><p id="0c26" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">让我们配置ALB。更新<code class="fe me mf mg lw b">gorush-aws-alb-ingress.yaml</code>，添加<code class="fe me mf mg lw b">kubernetes.io/ingress.class: alb</code>以触发<code class="fe me mf mg lw b">alb-ingress-controller</code>，将<em class="mh">方案</em>更新为<em class="mh">内部</em>值，并设置子网和安全组的值。</p><p id="da30" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">另外，请注意这里的<code class="fe me mf mg lw b">servicePort</code>从原来的<em class="mh"> 8088 </em>更改为<em class="mh"> 80 </em>，因为我们使用了ALB和专用的<code class="fe me mf mg lw b">NodePort</code>服务:</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="8c9b" class="kt ku iq lw b gy ma mb l mc md">apiVersion: extensions/v1beta1<br/>kind: Ingress<br/>metadata:<br/>  name: gorush<br/>  namespace: gorush<br/>  annotations:<br/>    # Kubernetes Ingress Controller for AWS ALB<br/>    # <a class="ae ks" href="https://github.com/coreos/alb-ingress-controller" rel="noopener ugc nofollow" target="_blank">https://github.com/coreos/alb-ingress-controller</a><br/>    #alb.ingress.kubernetes.io/scheme: internet-facing<br/>    kubernetes.io/ingress.class: alb<br/>    alb.ingress.kubernetes.io/scheme: internal<br/>    alb.ingress.kubernetes.io/subnets: subnet-010f9918532f52c6d, subnet-0f6dbde36b6669f48<br/>    alb.ingress.kubernetes.io/security-groups: sg-0f1df776a767a2589<br/>spec:<br/>  rules:<br/>  - http:<br/>      paths:<br/>      - path: /*<br/>        backend:<br/>          serviceName: gorush<br/>          servicePort: 80</span></pre><p id="da29" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">创建ALB:</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="8d9e" class="kt ku iq lw b gy ma mb l mc md">$ kubectl apply -f gorush-aws-alb-ingress.yaml<br/>ingress.extensions/gorush created</span></pre><p id="316c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">查看<code class="fe me mf mg lw b">alb-ingress-controller</code>日志:</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="3609" class="kt ku iq lw b gy ma mb l mc md">$ kubectl logs -f -n kube-system $(kubectl get po -n kube-system | egrep -o ‘alb-ingress[a-zA-Z0–9-]+’)<br/>…<br/>E0206 11:08:52.664554 1 controller.go:217] kubebuilder/controller “msg”=”Reconciler error” “error”=”no object matching key \”gorush/gorush\” in local store” “controller”=”alb-ingress-controller” “request”={“Namespace”:”gorush”,”Name”:”gorush”}<br/>I0206 11:08:53.731420 1 loadbalancer.go:191] gorush/gorush: creating LoadBalancer 3407a88c-gorush-gorush-f66a<br/>I0206 11:08:54.372743 1 loadbalancer.go:208] gorush/gorush: LoadBalancer 3407a88c-gorush-gorush-f66a created, ARN: arn:aws:elasticloadbalancing:us-east-2:534***385:loadbalancer/app/3407a88c-gorush-gorush-f66a/d31b461c65a278f0<br/>I0206 11:08:54.516572 1 targetgroup.go:119] gorush/gorush: creating target group 3407a88c-e50bdf2f1d39b9db54c<br/>…<br/>I0206 11:08:57.215907 1 rules.go:98] gorush/gorush: rule 1 modified with conditions [{ Field: “path-pattern”, Values: [“/*”] }]</span></pre><p id="9560" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">检查<code class="fe me mf mg lw b">Ingress</code>服务:</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="f174" class="kt ku iq lw b gy ma mb l mc md">$ kubectl -n gorush get ingress<br/>NAME HOSTS ADDRESS PORTS AGE<br/>gorush * internal-3407a88c-gorush-gorush-f66a-***.us-east-2.elb.amazonaws.com 80 3m57s</span></pre><h2 id="34ad" class="kt ku iq bd kv kw kx dn ky kz la dp lb kf lc ld le kj lf lg lh kn li lj lk ll bi translated">测试API</h2><p id="87e0" class="pw-post-body-paragraph ju jv iq jw b jx lm jz ka kb ln kd ke kf lo kh ki kj lp kl km kn lq kp kq kr ij bi translated">让我们连接到我们的Bastion hos，安装<code class="fe me mf mg lw b">dnsutils</code>、<code class="fe me mf mg lw b">dnsping</code>和<code class="fe me mf mg lw b">curl</code>包。</p><p id="8440" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">要获得Pod，我们可以使用以下命令:</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="3f72" class="kt ku iq lw b gy ma mb l mc md">$ kubectl -n gorush get pod | grep gorush | cut -d” “ -f 1 | tail -1<br/>gorush-59bd9dd4fc-klsbz</span></pre><p id="fe24" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">并连接到<em class="mh">堡垒</em>:</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="c625" class="kt ku iq lw b gy ma mb l mc md">$ kubectl -n gorush exec -ti $(kubectl -n gorush get pod | grep gorush | cut -d” “ -f 1 | tail -1) -c bastion bash<br/>root@gorush-59bd9dd4fc-klsbz:/#</span></pre><p id="c966" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">安装必要的实用程序，并检查我们的推送服务是否正常工作:</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="2483" class="kt ku iq lw b gy ma mb l mc md">root@gorush-59bd9dd4fc-klsbz:/# apt update &amp;&amp; apt -y install dnsutils curl dnsdiagroot@gorush-59bd9dd4fc-klsbz:/# curl dualstack.internal-3407a88c-gorush-gorush-f66a-***.us-east-2.elb.amazonaws.com<br/>{“text”:”Welcome to notification server.”}</span></pre><p id="57ec" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">目前看来不错。</p><h2 id="ce40" class="kt ku iq bd kv kw kx dn ky kz la dp lb kf lc ld le kj lf lg lh kn li lj lk ll bi translated">53号公路</h2><p id="92d6" class="pw-post-body-paragraph ju jv iq jw b jx lm jz ka kb ln kd ke kf lo kh ki kj lp kl km kn lq kp kq kr ij bi translated">让我们检查一下我们的内部ALB是否被解析为私有IP，因为它的类型被设置为<em class="mh"> Internal </em>:</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="3792" class="kt ku iq lw b gy ma mb l mc md">root@gorush-59bd9dd4fc-klsbz:/# dig +short dualstack.internal-3407a88c-gorush-gorush-f66a-***.us-east-2.elb.amazonaws.com<br/>10.0.15.167<br/>10.0.23.138</span></pre><p id="72aa" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">很好。</p><p id="2f72" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们希望使用自己的URL来访问上面创建的ALB，所以让我们转到AWS Route53，像往常一样添加一条指向ALB的新记录—通过一个<code class="fe me mf mg lw b">ALIAS</code>:</p><figure class="lr ls lt lu gt jr gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/006c12ab06a7d883b6fec87b46695b23.png" data-original-src="https://miro.medium.com/v2/resize:fit:956/format:webp/0*7Cz7BZqIDRuJEI0i.png"/></div></figure><p id="37b1" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">并从<em class="mh"> Bastion </em>发出<code class="fe me mf mg lw b">GET</code>请求，使其在VPS内部运行，使用自己的DNS将域解析为ALB的私有IP:</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="f22e" class="kt ku iq lw b gy ma mb l mc md">root@gorush-59bd9dd4fc-klsbz:/# dig push.example.com +short<br/>10.0.23.138<br/>10.0.15.167</span></pre><p id="1e3d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">该服务:</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="8e8f" class="kt ku iq lw b gy ma mb l mc md">root@gorush-59bd9dd4fc-klsbz:/# curl push.example.com<br/>{“text”:”Welcome to notification server.”}</span></pre><p id="bca5" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">完成了。</p></div><div class="ab cl mj mk hu ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ij ik il im in"><p id="63ef" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><em class="mh">最初发布于</em> <a class="ae ks" href="https://rtfm.co.ua/en/kubernetes-running-a-push-server-with-gorush-behind-an-aws-loadbalancer/" rel="noopener ugc nofollow" target="_blank"> <em class="mh"> RTFM: Linux、DevOps和系统管理</em> </a> <em class="mh">。</em></p></div></div>    
</body>
</html>