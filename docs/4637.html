<html>
<head>
<title>Security starts in the Firmware</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">安全性始于固件</h1>
<blockquote>原文：<a href="https://itnext.io/security-starts-in-the-firmware-19e0fc75afd9?source=collection_archive---------4-----------------------#2020-08-10">https://itnext.io/security-starts-in-the-firmware-19e0fc75afd9?source=collection_archive---------4-----------------------#2020-08-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="ebcc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我是LinkedIn的一个相当频繁的用户——因为我确实比邢更喜欢这个网络的风格，而且我觉得它有一个更活跃的社区。我收到了很多关于安全设备、防火墙、身份管理系统等广告的垃圾邮件。但大多数人不知道的是:安全性，无论是防火墙、VPN设备还是投票系统，它总是从固件级别开始。让我们了解如何构建这样一个系统，以及为什么安全性总是始于固件。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi kp"><img src="../Images/03b87c869c5609e3bbc197bc98962dc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p23OawDcvNRueAw-Mgpg4w.jpeg"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">由<a class="ae ko" href="https://unsplash.com/@_miltiadis_?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">米尔蒂亚迪斯·弗拉基迪斯</a>在<a class="ae ko" href="https://unsplash.com/s/photos/chain?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="d9ce" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">安全工程师倾向于谈论信任链。这意味着具有各种组件的系统需要在彼此之上构建安全性，通过完整的系统链接可信度。这个链条总是有一个所谓的信任锚，信任的根源。信任的根源是您需要信任的系统中的一个代码块、二进制代码或硬件部分，以便建立信任链。让我们在这里做一个例子:</p><h1 id="d9df" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">一个“安全”系统</h1><p id="70d3" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">首先，没有安全的系统。安全性的衡量标准是:需要付出多大的努力才能打破它。不管怎样，假设您想要构建一个VPN设备。那么我们需要什么呢</p><ul class=""><li id="b987" class="mi mj it js b jt ju jx jy kb mk kf ml kj mm kn mn mo mp mq bi translated">裸机平台，即<em class="mr">硬件</em></li><li id="5b11" class="mi mj it js b jt ms jx mt kb mu kf mv kj mw kn mn mo mp mq bi translated">一些操作系统——可能是<em class="mr"> Linux </em></li><li id="0858" class="mi mj it js b jt ms jx mt kb mu kf mv kj mw kn mn mo mp mq bi translated">VPN服务器——因为你和我一样是开源软件的粉丝，所以让我们使用OpenVPN吧</li></ul><p id="343f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">大多数人现在把这些部分放在一起，在Linux中做一些很好的配置，这样它只允许特定的端口通过，没有根登录，你的VPN设备就可以使用了。但是，从系统开始引导到应用程序被加载，实际上会发生什么呢？</p><h1 id="10f5" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">Bootflow</h1><p id="244f" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">每台计算机总是从重置向量开始。复位向量是一个片上系统特定的地址，它指向系统上运行的初始代码(即所谓的固件)的存储位置，大多数情况下这可能是一个SPI闪存芯片。</p><p id="91cd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">固件将初始化系统上运行的大部分硬件，并跳转到引导装载程序，然后装载操作系统。在我们的场景中，一旦加载了您的操作系统，OpenVPN服务器将启动并向我们的客户端提供所需的服务。</p><p id="8ed5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以很明显根，整个系统的开始就是固件。在固件中，我们甚至可以更加具体。固件由多个部分组成。因为我的主要专业领域是x86固件，所以我们可以将其分为几个阶段。代码的第一部分在UEFI中被称为<em class="mr"> bootblock </em>或<em class="mr">安全</em>阶段。安全阶段根本不包含安全，这个名字选得很不恰当。安全阶段确实初始化CPU，并将CPU缓存作为RAM，因为还没有可用的RAM。</p><p id="a630" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下一个阶段是Pre-Efi Init (PEI)或romstage。romstage主要有两个目的。做额外的硬件初始化和最重要的:启动内存。</p><p id="e55f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来是ramstage或驱动程序执行(DXE)阶段。DXE阶段可以完成系统需要的所有工作。启动硬件，与系统中的设备对话，如基板管理控制器。必要时加载USB驱动程序等等。我们不需要在这里详细讨论。在所有的驱动程序都被初始化后，引导程序弹出，并开始执行你的操作系统内核(是的，Windows也有一个内核)。</p><p id="b073" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">内核基本上重复了固件中的许多步骤——尤其是DXE部分。一旦加载了用户空间，应用程序就会启动，我们就可以开始了。</p><h1 id="34b3" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">信任的根源</h1><p id="0543" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">在大多数系统中，信任的根源是<em class="mr">完整的固件。因为我们并不真正知道下面发生了什么，因为大部分都是封闭的源代码，我们只需要把固件当作一个大的blob，作为我们信任的根源。从那里可以建立一个信任链使用已知的技术，如UEFI安全引导。</em></p><p id="6045" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">UEFI安全引导声明系统的完整性是正确的，从信任的根开始，并且固件仅加载了签名的引导加载程序，该引导加载程序加载了签名的操作系统，该操作系统仅加载签名的内核驱动程序。所以这里的链条应该是</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/5c37bbb3e187eb2fab6df9bbe7c25f75.png" data-original-src="https://miro.medium.com/v2/resize:fit:882/format:webp/1*yKsgWrraBH8yNgRJL0y4tQ.png"/></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">经典UEFI安全引导</figcaption></figure><p id="0fa0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">整个系统依赖于固件没有被破坏。由于这是完全闭源的，我们必须将整个固件作为RoT——大约16MB。</p><h1 id="eb81" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">我们能做得更好吗？</h1><p id="3beb" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">是的。开源固件是一种工具，可以获得对信任根的更多控制和安全性，并最小化RoT。我们以<a class="ae ko" href="https://www.coreboot.org" rel="noopener ugc nofollow" target="_blank"> coreboot </a>为例。coreboot有多个阶段，在引导加载程序加载之前执行。这将是</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi my"><img src="../Images/570fef1f3127d251f585f48b853d9e4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/format:webp/1*cMbMP_1Nxm6ZEkeJcZXr7g.png"/></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">具有测量/验证引导的核心引导引导流</figcaption></figure><p id="2c83" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">coreboot遵循最小信任计算基础方法bootblock是整个固件的一个非常小的部分，只需要启动堆栈和磁头，以便固件可以工作，我们不必再使用汇编。在bootblock之后，可信平台模块将被初始化，我们的信任链开始。</p><p id="a83a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，我们没有将完整的固件作为信任的根源，而是仅将固件中的一小部分，即bootblock和verstage作为我们的信任根源，并从那里开始信任链。因此，所有后续阶段都将从启动模块和结束阶段开始进行测量和验证。这大大增加了安全性，因为我们确实需要信任一小部分代码——甚至是开源的。</p><h1 id="c493" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">TL；速度三角形定位法(dead reckoning)</h1><p id="ae9e" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">如果你正在设计一个安全的系统，固件应该是你安全的基础——理想情况下，它应该是开放的和最小化的。</p><p id="4570" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">感谢您的阅读——如果您想了解更多关于开源固件的信息，请查看:</p><div class="mz na gp gr nb nc"><a href="https://medium.com/swlh/open-source-firmware-why-should-we-support-it-bbd0ad75b651" rel="noopener follow" target="_blank"><div class="nd ab fo"><div class="ne ab nf cl cj ng"><h2 class="bd iu gy z fp nh fr fs ni fu fw is bi translated">开源固件——我们为什么要支持它？</h2><div class="nj l"><h3 class="bd b gy z fp nh fr fs ni fu fw dk translated">固件是平台上运行的最强大的软件。但是为什么所有的东西都是闭源的呢？支持…</h3></div><div class="nk l"><p class="bd b dl z fp nh fr fs ni fu fw dk translated">medium.com</p></div></div><div class="nl l"><div class="nm l nn no np nl nq kz nc"/></div></div></a></div><div class="mz na gp gr nb nc"><a href="https://medium.com/swlh/getting-started-with-coreboot-7ade78327e75" rel="noopener follow" target="_blank"><div class="nd ab fo"><div class="ne ab nf cl cj ng"><h2 class="bd iu gy z fp nh fr fs ni fu fw is bi translated">入门指南:coreboot</h2><div class="nj l"><h3 class="bd b gy z fp nh fr fs ni fu fw dk translated">coreboot是一个开源固件替代方案。本文介绍了固件，并向您展示了如何开始使用…</h3></div><div class="nk l"><p class="bd b dl z fp nh fr fs ni fu fw dk translated">medium.com</p></div></div><div class="nl l"><div class="nr l nn no np nl nq kz nc"/></div></div></a></div></div></div>    
</body>
</html>