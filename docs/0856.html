<html>
<head>
<title>That data looks so fetching on you: Understanding the JS Fetch API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">这些数据看起来很吸引人:理解JS Fetch API</h1>
<blockquote>原文：<a href="https://itnext.io/that-data-looks-so-fetching-on-you-understanding-the-js-fetch-api-880eae0c8d25?source=collection_archive---------1-----------------------#2018-06-10">https://itnext.io/that-data-looks-so-fetching-on-you-understanding-the-js-fetch-api-880eae0c8d25?source=collection_archive---------1-----------------------#2018-06-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/30e0395d148599bf0df788f4be970e9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C5b9mNOi7sKN0-LW-66DYw.jpeg"/></div></div></figure><p id="85aa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这不是JS处理来自服务器的数据的唯一方式，但可能是最普遍的方式。很久以前，主要方法曾经是<a class="ae la" href="https://www.w3schools.com/xml/ajax_xmlhttprequest_create.asp" rel="noopener ugc nofollow" target="_blank"> XMLHttpRequest </a>，然而这种方法已经过时了。你可以安装一些模块来发出请求(比如<a class="ae la" href="https://www.npmjs.com/package/axios" rel="noopener ugc nofollow" target="_blank"> Axios </a>)，但是fetch已经可以在所有浏览器中使用了。任何开发人员都应该花些时间熟悉这个内置的API。</p><p id="6548" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe kw kx ky kz b"><em class="lb">fetch()</em></code> <em class="lb">用途承诺，所以读</em> <a class="ae la" href="https://medium.com/@mikecronin92/promises-promises-understanding-the-basics-of-js-promise-objects-dd5c656f2db4" rel="noopener"> <em class="lb">这个</em> </a> <em class="lb">如果不知道那些是什么</em></p><h1 id="ea38" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">大局</h1><p id="1382" class="pw-post-body-paragraph jy jz iq ka b kb ma kd ke kf mb kh ki kj mc kl km kn md kp kq kr me kt ku kv ij bi translated">我在这里稍微解释了一下，但是<a class="ae la" href="https://javascript.info/promise-chaining#bigger-example-fetch" rel="noopener ugc nofollow" target="_blank"> javascript.info </a>很好地分解了<code class="fe kw kx ky kz b">fetch()</code>的基础:</p><blockquote class="mf mg mh"><p id="c638" class="jy jz lb ka b kb kc kd ke kf kg kh ki mi kk kl km mj ko kp kq mk ks kt ku kv ij bi translated">1.<code class="fe kw kx ky kz b">fetch()</code>向url发出网络请求并返回承诺。</p><p id="8b42" class="jy jz lb ka b kb kc kd ke kf kg kh ki mi kk kl km mj ko kp kq mk ks kt ku kv ij bi translated">2.当远程服务器用头响应时，这个承诺用一个响应对象来解决。</p><p id="5157" class="jy jz lb ka b kb kc kd ke kf kg kh ki mi kk kl km mj ko kp kq mk ks kt ku kv ij bi translated">3.为了读取响应体，我们必须在其上调用一个响应方法，如<code class="fe kw kx ky kz b">text()</code>或<code class="fe kw kx ky kz b">json()</code>，它将返回另一个承诺，其解析值是响应的<strong class="ka ir"> <em class="iq">体</em> </strong>。</p></blockquote><pre class="ml mm mn mo gt mp kz mq mr aw ms bi"><span id="1143" class="mt ld iq kz b gy mu mv l mw mx"><strong class="kz ir">fetch</strong>('<a class="ae la" href="https://jsonplaceholder.typicode.com/users/1" rel="noopener ugc nofollow" target="_blank"><em class="lb">https://jsonplaceholder.typicode.com/users/1</em></a>')<br/>  .then((<strong class="kz ir">response</strong>) =&gt; <strong class="kz ir">response</strong>.json())<br/>  .then((<strong class="kz ir">myJson</strong>) =&gt; {<br/>    <strong class="kz ir">console</strong>.log(<em class="lb">'Here is the json!'</em>, <strong class="kz ir">myJson</strong>);<br/>  });</span></pre><p id="8015" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">关于更详细的技术分析，我鼓励你查看那个链接。此外，谷歌<a class="ae la" href="https://developers.google.com/web/updates/2015/03/introduction-to-fetch" rel="noopener ugc nofollow" target="_blank">写了一篇很棒的文章</a>，不出所料，它们比《小小的我》更深入。</p><h1 id="f9b3" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">故障</h1><p id="eb18" class="pw-post-body-paragraph jy jz iq ka b kb ma kd ke kf mb kh ki kj mc kl km kn md kp kq kr me kt ku kv ij bi translated"><code class="fe kw kx ky kz b">fetch()</code>创建一个用<a class="ae la" href="https://developer.mozilla.org/en-US/docs/Web/API/Response" rel="noopener ugc nofollow" target="_blank">响应对象</a>解析的承诺。现在，那个响应对象确实有一个主体，但是它是一个叫做<a class="ae la" href="https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream" rel="noopener ugc nofollow" target="_blank">可读流对象</a>的东西。我们的数据就在那里，但是获取它的唯一方式是通过一个<a class="ae la" href="https://developer.mozilla.org/en-US/docs/Web/API/Response#Methods" rel="noopener ugc nofollow" target="_blank">响应方法</a>返回我们的数据作为<em class="lb">另一个</em>解决的承诺值。所以我们还需要一个<code class="fe kw kx ky kz b">then()</code>来实际使用我们的数据。下面是发生的事情的基本伪代码版本:</p><pre class="ml mm mn mo gt mp kz mq mr aw ms bi"><span id="4074" class="mt ld iq kz b gy mu mv l mw mx"><strong class="kz ir">fetch</strong>('https://some-url.com')<br/>  .then((<strong class="kz ir">theResponseObject</strong>) =&gt; {<br/>    return <strong class="kz ir">theResponseObject</strong>.methodToGetToData()<br/>  })<br/>  .then((<strong class="kz ir">myUsableData</strong>) =&gt; {<br/>   <em class="lb"> // manipulate/show/log our data </em><br/>  })<br/>  .catch((<strong class="kz ir">error</strong>) =&gt; {<br/> <em class="lb">   // error handling here</em><br/>  });</span></pre><p id="084d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果这些步骤中的任何一个被拒绝，你就可以<code class="fe kw kx ky kz b">catch()</code>它。</p><h1 id="5c6c" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">使用示例</h1><p id="3764" class="pw-post-body-paragraph jy jz iq ka b kb ma kd ke kf mb kh ki kj mc kl km kn md kp kq kr me kt ku kv ij bi translated">现在让我们来看一个例子。为此，我们将使用精彩的<a class="ae la" href="https://jsonplaceholder.typicode.com/" rel="noopener ugc nofollow" target="_blank"> JSONplaceholder </a>站点，它给出了遵循REST约定的虚拟JSON文件。<em class="lb">完善</em>进行测试和教程。下面，让我们在页面上放置一个“用户”:</p><pre class="ml mm mn mo gt mp kz mq mr aw ms bi"><span id="718e" class="mt ld iq kz b gy mu mv l mw mx">fetch('<em class="lb">https://jsonplaceholder.typicode.com/users/1</em>')<br/>  .then((<strong class="kz ir">response</strong>) =&gt; {<br/>    <strong class="kz ir">console</strong>.log(`<em class="lb">status: </em>${<strong class="kz ir">response</strong>.status}`);<br/>    <strong class="kz ir">console</strong>.dir(<strong class="kz ir">response</strong>.body);<br/>    return <strong class="kz ir">response</strong>.json() <em class="lb">// the important line</em> <br/>  })<br/>  .then((myJson) =&gt; {<br/>    <strong class="kz ir">document</strong>.write(<br/>      `<em class="lb">User: </em>${<strong class="kz ir">myJson</strong>.name} <em class="lb">&lt;br/&gt;</em><br/>      <em class="lb">Email: </em>${<strong class="kz ir">myJson</strong>.email} <em class="lb">&lt;br /&gt;</em><br/>      <em class="lb">Website: </em>${<strong class="kz ir">myJson</strong>.website}`<br/>    );<br/>    return <strong class="kz ir">myJson;</strong><br/>  })<br/>  .then(<strong class="kz ir">console</strong>.log)</span></pre><p id="d6cc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的<code class="fe kw kx ky kz b">fetch()</code>用一个响应对象进行解析，这个对象被引入到我们的第一个<code class="fe kw kx ky kz b">then()</code>方法中。我记录了一些基本的属性，但是我也鼓励你自己去探索。我们的第一个<code class="fe kw kx ky kz b">then()</code>返回<code class="fe kw kx ky kz b">response.json()</code>，这是一个包含我们数据的解析承诺。在这种情况下，它是JSON，但是如果它只是文本，我们可以使用<code class="fe kw kx ky kz b">text()</code>响应方法。</p><p id="84bb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们的第二个<code class="fe kw kx ky kz b">then()</code>中，我们实际上开始操纵我们的数据。我只是在本教程中使用了<code class="fe kw kx ky kz b">document.write()</code>，但是现在你已经可以访问数据了，你可以把它放到你的页面中。第二个<code class="fe kw kx ky kz b">then()</code>只是返回我们的数据，以强调链接可以一直进行下去。最后，将我们的用户JSON登录到控制台。</p><p id="3dd0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，对于您想要显示或操作其数据的每个<code class="fe kw kx ky kz b">fetch()</code>，您将需要至少两个<strong class="ka ir"><em class="lb"/></strong><code class="fe kw kx ky kz b">then()</code>方法:第一个返回检索您的数据的响应方法，第二个<code class="fe kw kx ky kz b">then()</code>实际处理数据。</p><h1 id="7b42" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">获取不仅仅是为了得到</h1><p id="85b1" class="pw-post-body-paragraph jy jz iq ka b kb ma kd ke kf mb kh ki kj mc kl km kn md kp kq kr me kt ku kv ij bi translated">如果我们的应用程序只能<em class="lb">读取</em>数据，那么它们就很难是动态的，所以<code class="fe kw kx ky kz b">fetch()</code>可以接受第二个参数，一个<a class="ae la" href="https://developer.mozilla.org/en-US/docs/Web/API/Request#Examples" rel="noopener ugc nofollow" target="_blank">请求</a>。您只需向<code class="fe kw kx ky kz b">fetch()</code>传递一个对象，该对象指定您想要发出的请求的类型，以及消息头、消息体和您需要的任何内容。谷歌的好心人在他们关于fetch 的<a class="ae la" href="https://developers.google.com/web/updates/2015/03/introduction-to-fetch#post_request" rel="noopener ugc nofollow" target="_blank">文章中创建了这个示例代码:</a></p><pre class="ml mm mn mo gt mp kz mq mr aw ms bi"><span id="94b8" class="mt ld iq kz b gy mu mv l mw mx">const<strong class="kz ir"> options = </strong>{<br/>  method: '<em class="lb">POST</em>',<br/>  headers: {<br/>    '<em class="lb">Content-type'</em>: 'application/json; charset=UTF-8'<br/>  },<br/>  body: '<em class="lb">foo=bar&amp;lorem=ipsum</em>',<br/>}<strong class="kz ir"><br/>fetch</strong>('https://<em class="lb">example.com</em>', options)<br/>  .then((<strong class="kz ir">response)</strong> =&gt; <strong class="kz ir">response</strong>.json())<br/>  .then((<strong class="kz ir">data</strong>) =&gt; {<br/>    <strong class="kz ir">console</strong>.log('<em class="lb">Request succeeded with JSON response</em>', <strong class="kz ir">data</strong>);<br/>  })<br/>  .catch((<strong class="kz ir">error</strong>) =&gt; {<br/>    console.log('<em class="lb">Request failed</em>', <strong class="kz ir">error</strong>);<br/>  });</span></pre><p id="5fa1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是，要从您的页面发送数据，您需要设置您的服务器来正确处理传入的信息。这超出了本教程的范围。但是在大多数web框架中，接受JSON数据非常容易。</p><h1 id="c281" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">在您自己的站点上使用fetch()</h1><p id="6375" class="pw-post-body-paragraph jy jz iq ka b kb ma kd ke kf mb kh ki kj mc kl km kn md kp kq kr me kt ku kv ij bi translated"><code class="fe kw kx ky kz b">fetch()</code>可以去任何网址，包括你自己的服务器。要访问你的站点自己的文件，只需给出一个相对路径名而不是URL。如果<code class="fe kw kx ky kz b">fetch()</code>没有看到“http”，它会假设你是从你的根目录。这适用于生产或本地主机服务器。下面是一个简单的<code class="fe kw kx ky kz b">fetch()</code>的例子，从本地测试服务器上的根文件夹中检索一些JSON数据:</p><pre class="ml mm mn mo gt mp kz mq mr aw ms bi"><span id="0a5b" class="mt ld iq kz b gy mu mv l mw mx">fetch('/test.json')<br/>  .then((<strong class="kz ir">r</strong>) =&gt; <strong class="kz ir">r</strong>.json())<br/>  .then(console.log)</span><span id="fce6" class="mt ld iq kz b gy my mv l mw mx">// { example: 'data' }</span></pre><h1 id="ccda" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">去拿回来</h1><p id="bfc5" class="pw-post-body-paragraph jy jz iq ka b kb ma kd ke kf mb kh ki kj mc kl km kn md kp kq kr me kt ku kv ij bi translated">这就是<code class="fe kw kx ky kz b">fetch()</code>的基本要素。我非常鼓励阅读<a class="ae la" href="https://developer.mozilla.org/en-US/docs/Web/API/Response#Methods" rel="noopener ugc nofollow" target="_blank"> MDN </a> docs、<a class="ae la" href="https://developers.google.com/web/updates/2015/03/introduction-to-fetch" rel="noopener ugc nofollow" target="_blank"> Google </a>和<a class="ae la" href="https://javascript.info/promise-chaining#bigger-example-fetch" rel="noopener ugc nofollow" target="_blank"> javascript.info </a>文章。还有一种更好的方式来使用带有Async/Await 的<a class="ae la" rel="noopener ugc nofollow" target="_blank" href="/a-beginners-guide-to-async-await-in-javascript-97750bd09ffa"> fetch，一旦你熟悉了这种语法，我鼓励你去看看。但是最好的学习方法是去做，所以走出去，建立一个吸引人的新网站。</a></p><p id="5249" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">大家编码快乐，</p><p id="f571" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">麦克风</p></div></div>    
</body>
</html>