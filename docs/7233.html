<html>
<head>
<title>Deeper testing of Bun’s performance and compatibility against Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">对Bun的性能和与Node.js的兼容性进行更深入的测试</h1>
<blockquote>原文：<a href="https://itnext.io/deeper-testing-of-buns-performance-and-compatibility-against-node-js-9115763965ed?source=collection_archive---------0-----------------------#2022-07-25">https://itnext.io/deeper-testing-of-buns-performance-and-compatibility-against-node-js-9115763965ed?source=collection_archive---------0-----------------------#2022-07-25</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="08b8" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">Bun最终可能会使Node.js和/或Deno变得无关紧要，但现在说它们都是死项目还为时过早</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/0ac0273940e54a326df32646af0a2f20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*nhggQ5rggFenxV-_.png"/></div></div></figure><p id="2663" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated"><strong class="kx iv"> Bun是一个新的项目，旨在与Node.js兼容，但是有巨大的性能增益。公开发布还不到一个月，人们就声称Node.js和Deno项目已经死亡。</strong></p><p id="e93a" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">“杀死”一个软件平台需要什么？例如，人们仍在使用COBOL，有多少关于Perl、PHP或Java死亡的预测？</p><p id="725b" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">Bun项目宣称它将与Node.js平台兼容，同时带来巨大的性能优势。如果是真的，这很容易动摇许多软件工程师放弃Node.js。但这将需要几年时间才能展开。Node.js处于非常成熟的地位，Bun项目在完全取代Node.js之前还有很多工作要做。</p><p id="32db" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">但是，当Bun变得足够稳定和成熟，可以运行目前在Node.js上运行的复杂应用程序时，会发生什么呢？</p><p id="8c14" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">我感兴趣的是评估Bun是否能像Node.js一样运行我的应用程序。</p><p id="8f56" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">这些主张引起了很多人的注意。我在YouTube上看到一群人运行简单的性能测试，然后吹嘘这些测试如何证明Bun比Node.js快得多。</p><p id="c592" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">当然，简单的性能测试证明不了什么。正如我后面所说的，过分看重一个简单的测试是错误的。</p><p id="3ed7" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">这让我尝试在Bun上运行一个复杂应用程序的测试。也就是说，我开发了一个静态网站生成器系统(AkashaCMS)，我用它来构建几个网站，包括<code class="fe lr ls lt lu b">techsparx.com</code>和<code class="fe lr ls lt lu b">greentransportation.info</code>。AkashaCMS足够复杂，可以提供一个很好的测试场景。如果Bun能够成功运行AkashaCMS，并且性能更高，这将证明Bun团队的说法。这个想法很好，但结果有缺陷。</p><p id="ff4d" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">我写了一篇<a class="ae lv" href="https://techsparx.com/nodejs/bun/1st-trial.html" rel="noopener ugc nofollow" target="_blank">的文章，当时我相信我已经成功地使用Bun </a>(也在<a class="ae lv" rel="noopener ugc nofollow" target="_blank" href="/testing-buns-compatibility-and-speed-with-a-complex-application-bee823a1a1b3">介质</a>上)渲染了我的网站，但看起来我却意外地运行了Node.js，我的测试是无效的。</p><p id="231b" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">本文旨在重温我尝试做的事情，并展示一些更仔细构建的性能测试。一路上，我发现了Bun中的一些bug，这些bug已经被归档在Bun发布队列中。</p><p id="3112" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">目前Bun中的错误和不完整的特性阻止了使用它来运行AkashaCMS。但是我已经可以用Bun执行它的一部分了。正如我们将看到的，这显示了某些方面的性能提升。</p><h1 id="1878" class="lw lx iu bd ly lz ma mb mc md me mf mg ka mh kb mi kd mj ke mk kg ml kh mm mn bi translated">什么是Bun，而不是Node.js</h1><p id="d790" class="pw-post-body-paragraph kv kw iu kx b ky mo jv la lb mp jy ld le mq lg lh li mr lk ll lm ms lo lp lq in bi translated">Node.js是JavaScript应用程序的服务器端执行平台。它在2009年出现，并声称单线程事件驱动架构如何能够提供比通常复杂的基于线程的架构更好的系统性能。</p><p id="282c" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">Node.js是在浏览器外运行的JavaScript。自2009年以来，一个大型的工具和框架生态系统已经围绕Node.js发展起来，涵盖了各种软件开发工具、web应用程序框架、数据库ORM层，甚至GUI应用程序工具包。</p><p id="6815" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">Bun像Node.js，但又不一样。其中Node.js基于Chrome的V8引擎，用C++编写，Bun基于Safari的JavaScriptCore，用Zig编写。在听说Bun之前，你可能从来没有听说过Zig，我也没有，但是Zig声称它比C++等其他系统编程语言有很多好处。另外，Bun旨在实现Node.js用例，即支持在web浏览器之外运行现代JavaScript。</p><p id="5f1d" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">这并不是第一次尝试在不同的JavaScript引擎上运行Node.js。几年前，有人试图在ChakraCore ( <a class="ae lv" href="https://github.com/nodejs/node-chakracore" rel="noopener ugc nofollow" target="_blank"> GitHub </a>)上运行Node.js，但当微软从Edge上放弃ChakraCore后，这一尝试被放弃了。</p><p id="5bc1" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">小圆面包的卖点是:</p><ol class=""><li id="0217" class="mt mu iu kx b ky kz lb lc le mv li mw lm mx lq my mz na nb bi translated">与Node.js兼容，包括直接使用Node.js的包(甚至是本地代码包)</li><li id="9343" class="mt mu iu kx b ky nc lb nd le ne li nf lm ng lq my mz na nb bi translated">巨大的性能好处:a)是用Zig写的，而不是C++，有一些好处；b)它建立在JavaScriptCore引擎之上。该引擎应该比Node.js和Deno的核心V8引擎更快。</li><li id="81b0" class="mt mu iu kx b ky nc lb nd le ne li nf lm ng lq my mz na nb bi translated">它支持直接执行类型脚本和JSX代码。</li></ol><p id="ab1a" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">如果Bun团队能够完全实现这些卖点，我想Node.js/Deno社区中的许多人会转而使用Bun。</p><p id="97cb" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">但是，从实际情况来看，Node.js已经经历了12年的完善、改进和错误修复。正如我们将会看到的，Bun有很多工作要做。</p><p id="b377" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">任何有经验的软件工程师在他们的职业生涯中都可能使用过许多不同的编程工具和平台。我们不断评估使用哪些工具，我们中的大多数人都足够聪明，能够看到Bun团队的声明，并知道他们做出了一些非常大的声明。我当然希望那些声明能够实现，但是在这个阶段</p><h1 id="1e22" class="lw lx iu bd ly lz ma mb mc md me mf mg ka mh kb mi kd mj ke mk kg ml kh mm mn bi translated">Bun可以杀死Node.js和/或Deno</h1><p id="01a9" class="pw-post-body-paragraph kv kw iu kx b ky mo jv la lb mp jy ld le mq lg lh li mr lk ll lm ms lo lp lq in bi translated">已经有人声称Bun会扼杀Deno和Node.js两个项目。基本原理就是我刚才提到的:如果Bun能够以高度的兼容性实现所有Node.js，同时保持巨大的性能优势，那么他们显然有一个赢家。</p><p id="d396" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">因为Bun采用了<code class="fe lr ls lt lu b">node_modules</code>基础设施，所以它比Deno有很大的优势。Deno很难利用成千上万的软件包。这是我们共同建立的宝贵资源，Bun将能够充分利用它。</p><p id="495a" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">例如，可以使用<code class="fe lr ls lt lu b">npm install</code>建立一个<code class="fe lr ls lt lu b">node_modules</code>目录，然后立即与Bun一起使用。目标是用同样的<code class="fe lr ls lt lu b">package.json</code>用<code class="fe lr ls lt lu b">bun install</code>做同样的事情，但是性能更好。</p><p id="ebf7" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">Bun不会马上杀Node.js。正如我们在下面看到的，有许多缺失的特性和许多错误需要修复。此外，为了使Bun成为一个自我维持的项目，必须开发所有的流程和后勤支持。</p><p id="e329" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">Node.js开发人员将如何处理与现有生态系统兼容但速度更快的替代方案？</p><h1 id="4ee5" class="lw lx iu bd ly lz ma mb mc md me mf mg ka mh kb mi kd mj ke mk kg ml kh mm mn bi translated">简单性能测试的陷阱</h1><p id="8b3c" class="pw-post-body-paragraph kv kw iu kx b ky mo jv la lb mp jy ld le mq lg lh li mr lk ll lm ms lo lp lq in bi translated">YouTube上已经有几个视频让Bun第一次尝试。我看过的每个视频都显示他们运行一些简单的命令，并说天哪，哇，这真快。</p><p id="c3f2" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">有一个众所周知的过分简单的性能测试的谬误。用Bun运行一个简单的脚本是否意味着它在实际应用中比Node.js快得多？这就是谬误。要验证Bun确实更快，需要比几个简单的例子更深入的测试。</p><h1 id="a4d4" class="lw lx iu bd ly lz ma mb mc md me mf mg ka mh kb mi kd mj ke mk kg ml kh mm mn bi translated">Bun的现有性能测试</h1><p id="fe74" class="pw-post-body-paragraph kv kw iu kx b ky mo jv la lb mp jy ld le mq lg lh li mr lk ll lm ms lo lp lq in bi translated">Bun源代码树包括一套基准测试。要运行这些测试:</p><pre class="kk kl km kn gu nh lu ni nj aw nk bi"><span id="2bf8" class="nl lx iu lu b gz nm nn l no np">$ git clone https://github.com/oven-sh/bun.git <br/>$ cd bun/bench<br/>$ bun install<br/>$ bun run ffi<br/>$ bun run log<br/>$ bun run gzip<br/>$ bun run async<br/>$ bun run sqlite</span></pre><p id="87a7" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">我没有足够的空间来展示所有的结果。但是，让我们看看SQLite测试:</p><pre class="kk kl km kn gu nh lu ni nj aw nk bi"><span id="f8f5" class="nl lx iu lu b gz nm nn l no np">david@davidpc:~/Projects/bun/bun/bench/sqlite$ bun run bench<br/>$ bun run bench:bun &amp;&amp; bun run bench:node &amp;&amp; bun run bench:deno<br/>$ $BUN bun.js<br/>[0.02ms] ".env"<br/>cpu: Intel(R) Core(TM) i7-5600U CPU @ 2.60GHz<br/>runtime: bun 0.1.4 (x64-linux)<br/><br/>benchmark                        time (avg)             (min … max)<br/>-------------------------------------------------------------------<br/>SELECT * FROM "Order"         43.62 ms/iter   (40.67 ms … 47.89 ms)<br/>SELECT * FROM "Product"      121.84 µs/iter  (87.83 µs … 928.85 µs)<br/>SELECT * FROM "OrderDetail"  499.15 ms/iter  (470.1 ms … 620.22 ms)<br/>$ $NODE node.mjs<br/>cpu: Intel(R) Core(TM) i7-5600U CPU @ 2.60GHz<br/>runtime: node v18.6.0 (x64-linux)<br/><br/>benchmark                        time (avg)             (min … max)<br/>-------------------------------------------------------------------<br/>SELECT * FROM "Order"        108.33 ms/iter (106.17 ms … 113.98 ms)<br/>SELECT * FROM "Product"       318.2 µs/iter (285.53 µs … 775.32 µs)<br/>SELECT * FROM "OrderDetail"     2.13 s/iter       (2.02 s … 2.37 s)<br/>$ $DENO run -A --unstable deno.js<br/>cpu: Intel(R) Core(TM) i7-5600U CPU @ 2.60GHz<br/>runtime: deno 1.23.4 (x86_64-unknown-linux-gnu)<br/><br/>benchmark                        time (avg)             (min … max)<br/>-------------------------------------------------------------------<br/>SELECT * FROM "Order"         274.7 ms/iter (263.29 ms … 342.62 ms)<br/>SELECT * FROM "Product"      490.34 µs/iter   (377.47 µs … 7.49 ms)<br/>SELECT * FROM "OrderDetail"      1.6 s/iter       (1.43 s … 2.12 s)</span></pre><p id="7462" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">这个特定的基准对SQLite数据库进行<code class="fe lr ls lt lu b">SELECT</code>查询。对于Node.js，测试使用<code class="fe lr ls lt lu b">better-sqlite</code>，Deno测试使用<code class="fe lr ls lt lu b">"https://deno.land/x/sqlite/mod.ts"</code>。相比之下，Bun使用直接集成在Bun源代码中的SQLite实现。</p><p id="94e4" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">这些是令人印象深刻的性能差异。</p><h1 id="1710" class="lw lx iu bd ly lz ma mb mc md me mf mg ka mh kb mi kd mj ke mk kg ml kh mm mn bi translated">Bun的不完整性阻碍了更深入的测试</h1><p id="e785" class="pw-post-body-paragraph kv kw iu kx b ky mo jv la lb mp jy ld le mq lg lh li mr lk ll lm ms lo lp lq in bi translated">我的目标是运行更大的应用程序来评估Bun的兼容性和性能。在我的例子中，这个应用程序是AkashaCMS，我为<code class="fe lr ls lt lu b">techsparx.com</code>、<code class="fe lr ls lt lu b">greentransportation.info</code>和一些其他网站使用的静态网站生成器。AkashaCMS使用Cheerio进行服务器端DOM处理，Cheerio使用各种模板引擎(主要是EJS和Nunjucks)等等。换句话说，它将为Bun与Node.js的兼容性提供一个很好的测试案例。</p><p id="1303" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">但是，存在许多兼容性问题:</p><pre class="kk kl km kn gu nh lu ni nj aw nk bi"><span id="0a26" class="nl lx iu lu b gz nm nn l no np">$ bun ./node_modules/akasharender/cli.js copy-assets config.js<br/>error: Cannot find package "child_process" from "/home/david/ws/techsparx.com/node_modules/akasharender/node_modules/commander/index.js"</span></pre><p id="6ed0" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated"><code class="fe lr ls lt lu b">akasharender</code>命令使用Commander来解析参数，它不能工作，因为<code class="fe lr ls lt lu b">child_process</code>包不存在。Commander是一个非常流行的用于在Node.js中编写CLI工具的包，缺少<code class="fe lr ls lt lu b">child_process</code>内置包会阻止任何围绕Commander构建的工具运行。</p><p id="0ac4" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">FWIW，Bun发布队列包含<a class="ae lv" href="https://github.com/oven-sh/bun/issues/159" rel="noopener ugc nofollow" target="_blank"> Buns路线图</a>列出了一堆还没有实现的东西。</p><p id="21b6" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">我曾希望简单地使用AkashaCMS来评估Bun。既然做不到这一点，下一个最好的解决方案就是选择AkashaCMS的部分来进行评估。</p><h1 id="08cf" class="lw lx iu bd ly lz ma mb mc md me mf mg ka mh kb mi kd mj ke mk kg ml kh mm mn bi translated">模板引擎的文本处理、性能以及Bun和Node.js之间的兼容性</h1><p id="3e94" class="pw-post-body-paragraph kv kw iu kx b ky mo jv la lb mp jy ld le mq lg lh li mr lk ll lm ms lo lp lq in bi translated">这里讨论的代码在:<a class="ae lv" href="https://github.com/akashacms/akashacms-perftest/tree/master/bench" rel="noopener ugc nofollow" target="_blank">https://github . com/akashacms/akashacms-perf test/tree/master/bench</a></p><p id="59ab" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated"><code class="fe lr ls lt lu b">akashacms/akashacms-perftest</code>用于AkashaCMS的性能测试。在<code class="fe lr ls lt lu b">bench</code>目录中，我打算为AkashaCMS的某些特性创建一些类似基准的测试。</p><p id="50d2" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">例如，考虑:</p><pre class="kk kl km kn gu nh lu ni nj aw nk bi"><span id="bbe8" class="nl lx iu lu b gz nm nn l no np">import { bench, run } from "mitata";<br/><br/>let people = ['geddy', 'neil', 'alex'];<br/><br/>// TEMPLATE STRINGS<br/><br/>bench('literal', () =&gt; { return `${people.join(', ')}`; });<br/><br/>// EJS<br/><br/>import * as ejs from 'ejs';<br/><br/>bench('ejs-join', () =&gt; {<br/>    ejs.render('&lt;%= people.join(", "); %&gt;', { people: people });<br/>});<br/>bench('ejs-list', () =&gt; {<br/>    ejs.render(`<br/>    &lt;ul&gt;<br/>    &lt;% people.forEach(function (person) {<br/>        %&gt;&lt;li&gt;&lt;%= person %&gt;&lt;/li&gt;&lt;%<br/>    }) %&gt;<br/>    &lt;/ul&gt;<br/>`, { people: people });<br/>});</span></pre><p id="f98d" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">Bun项目使用Mitata基准执行框架。为了帮助比较Bun测试的结果，我也将使用Mitata。</p><p id="3e83" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">第一个测试是测试模板字符串中的文本替换。</p><p id="1636" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">第二个是使用EJS模板引擎的几个场景。在这两种情况下，它都接受一个值数组，并以几种方式格式化该数组。我已经为多个模板引擎实现了类似的代码，从下面的结果可以明显看出。</p><p id="3f76" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">另外两项测试是:</p><ul class=""><li id="358a" class="mt mu iu kx b ky kz lb lc le mv li mw lm mx lq nq mz na nb bi translated"><code class="fe lr ls lt lu b">markdown-render</code>使用MarkdownIT包处理降价。</li><li id="7a98" class="mt mu iu kx b ky nc lb nd le ne li nf lm ng lq nq mz na nb bi translated"><code class="fe lr ls lt lu b">cheerio</code>使用<code class="fe lr ls lt lu b">cheerio</code>进行服务器端DOM处理，这是AkashaCMS的一个主要特性。</li></ul><p id="6edc" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">结果显示了这些性能差异:</p><pre class="kk kl km kn gu nh lu ni nj aw nk bi"><span id="00cb" class="nl lx iu lu b gz nm nn l no np">$ npm run bench<br/><br/>&gt; bench@1.0.0 bench<br/>&gt; npm-run-all render:node render:bun<br/><br/>&gt; bench@1.0.0 render:node<br/>&gt; node render-node.mjs<br/><br/>cpu: Intel(R) Core(TM) i7-5600U CPU @ 2.60GHz<br/>runtime: node v18.6.0 (x64-linux)<br/><br/>benchmark            time (avg)             (min … max)<br/>-------------------------------------------------------<br/>literal          133.73 ns/iter (119.76 ns … 661.32 ns)<br/>ejs-join          18.15 µs/iter  (14.89 µs … 583.95 µs)<br/>ejs-list           30.6 µs/iter  (25.98 µs … 398.45 µs)<br/>handlebars-join    5.95 µs/iter   (4.78 µs … 371.31 µs)<br/>handlebars-list    5.97 µs/iter   (4.76 µs … 411.31 µs)<br/>liquid-join       30.26 µs/iter    (18.04 µs … 3.66 ms)<br/>liquid-list       91.91 µs/iter     (64.02 µs … 1.3 ms)<br/>nunjucks-join     46.25 µs/iter    (26.71 µs … 1.09 ms)<br/>nunjucks-list     93.28 µs/iter    (65.62 µs … 1.22 ms)<br/>markdown-render   38.78 µs/iter  (28.93 µs … 603.53 µs)<br/>cheerio          130.17 µs/iter    (78.42 µs … 5.04 ms)<br/><br/>&gt; bench@1.0.0 render:bun<br/>&gt; bun render-bun.js<br/><br/>cpu: Intel(R) Core(TM) i7-5600U CPU @ 2.60GHz<br/>runtime: bun 0.1.4 (x64-linux)<br/><br/>benchmark                 time (avg)             (min … max)<br/>------------------------------------------------------------<br/>literal               129.64 ns/iter (107.87 ns … 534.11 ns)<br/>handlebars-join-once    4.34 µs/iter     (3.07 µs … 1.17 ms)<br/>handlebars-list-once    4.66 µs/iter     (3.44 µs … 1.22 ms)<br/>liquid-join            38.63 µs/iter    (21.23 µs … 2.63 ms)<br/>liquid-list           125.84 µs/iter    (87.41 µs … 2.12 ms)<br/>cheerio                68.81 µs/iter    (43.25 µs … 2.09 ms)<!-- --> </span></pre><p id="647f" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">从中可以得出两点:</p><ol class=""><li id="605b" class="mt mu iu kx b ky kz lb lc le mv li mw lm mx lq my mz na nb bi translated">我无法在Node.js和Bun上实现所有场景</li><li id="151b" class="mt mu iu kx b ky nc lb nd le ne li nf lm ng lq my mz na nb bi translated">Cheerio测试有显著的性能提升，而其他测试的性能提升不太显著</li></ol><p id="2ea1" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">为什么全套场景不能在两者上实现？在Mitata下，某些场景存在分段错误。已在Bun的问题队列中提交了一个问题，描述了该问题:<a class="ae lv" href="https://github.com/oven-sh/bun/issues/811" rel="noopener ugc nofollow" target="_blank">https://github.com/oven-sh/bun/issues/811</a></p><p id="a933" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">对于某些模板引擎，Mitata加上该模板引擎的组合导致了分段错误。一个只运行模板引擎而没有正确执行Mitata代码的脚本。</p><p id="516a" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">就性能而言，Bun显示了在两种平台上都能工作的场景的性能增益。啦啦队表现的提高非常有趣。</p><h1 id="abc7" class="lw lx iu bd ly lz ma mb mc md me mf mg ka mh kb mi kd mj ke mk kg ml kh mm mn bi translated">Chokidar暴露了问题</h1><p id="71a4" class="pw-post-body-paragraph kv kw iu kx b ky mo jv la lb mp jy ld le mq lg lh li mr lk ll lm ms lo lp lq in bi translated">Chokidar是一个流行的包，用于扫描目录树和动态地注意变化。在AkashaCMS中，它用于通知文件何时被更改以及进行自动重建。它起着核心作用，我想知道在Node.js和Bun之间扫描给定目录的执行时间是否有任何差异。</p><p id="3dcb" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">测试在这里:<a class="ae lv" href="https://github.com/akashacms/stacked-directories/tree/master/example/adhoc" rel="noopener ugc nofollow" target="_blank">https://github . com/akashacms/stacked-directory/tree/master/example/ad hoc</a></p><p id="896c" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">测试案例是这样的:</p><pre class="kk kl km kn gu nh lu ni nj aw nk bi"><span id="664c" class="nl lx iu lu b gz nm nn l no np">import { inspect } from 'util';<br/>import { default as chokidar } from 'chokidar';<br/><br/>let watcher;<br/><br/>const start = new Date();<br/>let count = 0;<br/><br/>try {<br/>    await new Promise((resolve, reject) =&gt; {<br/>        try {<br/>            watcher = chokidar.watch(process.argv[2]);<br/>            watcher<br/>            .on('error', async (error) =&gt; {<br/>                console.error(error);<br/>                reject(error);<br/>            })<br/>            .on('add', (fpath, stats) =&gt; {<br/>                // console.log(`add ${fpath} ${inspect(stats)}`);<br/>                count++;<br/>            })<br/>            .on('change', (fpath, stats) =&gt; {<br/>                // console.log(`change ${fpath} ${inspect(stats)}`);<br/>            })<br/>            .on('ready', async () =&gt; {<br/>                // console.log(`ready`);<br/>                await close();<br/><br/>                const finish = new Date();<br/><br/>                console.log(`time ${(finish - start) / 1000} seconds - ${count} files`);<br/><br/>                resolve();<br/>            });<br/>        } catch (err) { reject(err); }<br/>    });<br/><br/>} catch (errr) { console.error(errr); }<br/><br/>async function close() {<br/>    await watcher.close();<br/>    watcher = undefined;<br/>}</span></pre><p id="0db9" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">它使用Chokidar扫描命令行上传递的目录。在我的测试中，我让它扫描了<code class="fe lr ls lt lu b">node_modules</code>目录，以确保有很多文件需要扫描。Chokidar根据它正在扫描的文件系统中发生的情况发出几个事件。当它完成初始扫描时，发出<code class="fe lr ls lt lu b">ready</code>事件。我们使用该事件来关闭Chokidar实例并计算时间。</p><p id="a78f" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">这意味着它可以作为Node.js和Bun之间的性能比较，但是正如我们将看到的，Bun不能执行Chokidar。</p><p id="e600" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">使用Node.js:</p><pre class="kk kl km kn gu nh lu ni nj aw nk bi"><span id="c630" class="nl lx iu lu b gz nm nn l no np">$ node choke.mjs ../../node_modules/<br/>time 0.763 seconds - 3498 files</span></pre><p id="5082" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">但是，对于Bun，测试并不成功:</p><pre class="kk kl km kn gu nh lu ni nj aw nk bi"><span id="2b69" class="nl lx iu lu b gz nm nn l no np">$ bun choke.mjs ../../node_modules/ <br/>241 |     ); <br/>242 |   } <br/>243 |  <br/>244 |   filterPath(entry) { <br/>245 |     const {stats} = entry; <br/>246 |     if (stats &amp;&amp; stats.isSymbolicLink()) return this.filterDir(entry);<br/>                      ^  TypeError: stats.isSymbolicLink is not a function. (In 'stats.isSymbolicLink()', 'stats.isSymbolicLink' is undefined)<br/>       at filterPath (/home/david/Projects/akasharender/stacked-directories/node_modules/chokidar/index.js:246:17)<br/>       at /home/david/Projects/akasharender/stacked-directories/node_modules/readdirp/index.js:141:79</span></pre><p id="cd18" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">这意味着<code class="fe lr ls lt lu b">fs.stats</code>返回的Stats对象不包含<code class="fe lr ls lt lu b">isSymbolicLink</code>函数。这个函数从Node.js v10.10.0就有了，当然应该有。</p><p id="ce35" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">问题已经被修复了——我的错误报告<a class="ae lv" href="https://github.com/oven-sh/bun/issues/797" rel="noopener ugc nofollow" target="_blank">https://github.com/oven-sh/bun/issues/797</a>——注意在底部有一个链接指向更多Stats对象方法的问题跟踪实现。截至本文撰写之时，Bun 0.1.5已经发布，并且<code class="fe lr ls lt lu b">isSymbolicLink</code>功能已经存在。</p><p id="8691" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">很遗憾，Chokidar出现了一个新错误。</p><pre class="kk kl km kn gu nh lu ni nj aw nk bi"><span id="ba84" class="nl lx iu lu b gz nm nn l no np">114 |         sysPath.resolve(path, evPath), KEY_LISTENERS, sysPath.join(path, evPath) <br/>115 |       ); <br/>116 |     } <br/>117 |   }; <br/>118 |   try { <br/>119 |     return fs.watch(path, options, handleEvent);<br/>                ^ TypeError: fs.watch is not a function. (In 'fs.watch(path, options, handleEvent)', 'fs.watch' is undefined)<br/>       at createFsWatchInstance (/home/david/Projects/akasharender/stacked-directories/node_modules/chokidar/lib/nodefs-handler.js:119:11)<br/>       at /home/david/Projects/akasharender/stacked-directories/node_modules/chokidar/lib/nodefs-handler.js:166:14<br/>       at _watchWithNodeFs (/home/david/Projects/akasharender/stacked-directories/node_modules/chokidar/lib/nodefs-handler.js:331:13)<br/>       at _handleFile (/home/david/Projects/akasharender/stacked-directories/node_modules/chokidar/lib/nodefs-handler.js:395:17)<br/>       at /home/david/Projects/akasharender/stacked-directories/node_modules/chokidar/lib/nodefs-handler.js:637:15</span></pre><p id="ce4f" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">的确，我们可以证实它并不如此存在:</p><pre class="kk kl km kn gu nh lu ni nj aw nk bi"><span id="2f62" class="nl lx iu lu b gz nm nn l no np">import * as fs from 'fs';<br/>console.log(fs.watch);</span></pre><p id="f500" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">在Node.js上它打印一个函数对象，但是在Bun上它当前打印<code class="fe lr ls lt lu b">undefined</code>。发布日期:<a class="ae lv" href="https://github.com/oven-sh/bun/issues/832" rel="noopener ugc nofollow" target="_blank">https://github.com/oven-sh/bun/issues/832</a></p><h1 id="f6bc" class="lw lx iu bd ly lz ma mb mc md me mf mg ka mh kb mi kd mj ke mk kg ml kh mm mn bi translated">摘要</h1><p id="1899" class="pw-post-body-paragraph kv kw iu kx b ky mo jv la lb mp jy ld le mq lg lh li mr lk ll lm ms lo lp lq in bi translated">烤箱中的一个面包(优先级列表中的<a class="ae lv" href="https://github.com/oven-sh/bun/issues/798" rel="noopener ugc nofollow" target="_blank">)是这样描述的:</a></p><blockquote class="nr ns nt"><p id="3a92" class="kv kw nu kx b ky kz jv la lb lc jy ld nv lf lg lh nw lj lk ll nx ln lo lp lq in bi translated"><em class="iu">提高Node.js兼容性。快递需要工作。像chalk，debug，discord.js这样的流行包需要工作。需要实现child_process和net。我们需要更多的测试。这些包应该通过实现较低级别的Node.js APIs来支持，而不是通过侵入兼容层来支持。从长远来看，Bun可能希望用本机代码实现Express，但今天我们只让原语工作良好。</em></p></blockquote><p id="4a9d" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">是的，上面清楚地表明了Node.js兼容性目前是缺乏的。但是，这只是修复错误或添加缺失功能的问题。正如优先级列表所说，让更多的人参与项目将有助于解决这些问题。</p><p id="f6cb" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">如果Bun项目允许我提几个建议:</p><ul class=""><li id="1025" class="mt mu iu kx b ky kz lb lc le mv li mw lm mx lq nq mz na nb bi translated">客观准确的兼容性测试列表。换句话说，最好有一个核心Node.js模块的列表，以及当前的实现状态。要获得灵感，看看<a class="ae lv" href="https://node.green/" rel="noopener ugc nofollow" target="_blank">https://node.green/</a></li><li id="e9b2" class="mt mu iu kx b ky nc lb nd le ne li nf lm ng lq nq mz na nb bi translated">应该在数据库中跟踪性能测量，这样我们就可以随时观察改进情况。</li><li id="6c27" class="mt mu iu kx b ky nc lb nd le ne li nf lm ng lq nq mz na nb bi translated">应该有比现在更多的性能测量。(我应该考虑贡献我上面描述的场景)</li></ul><p id="d4cf" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">第一个建议，Node.js API兼容性测试来自于我在Sun Microsystems的Java SE团队工作了10多年的经验。(<a class="ae lv" href="https://blog.sourcerer.io/why-is-a-java-guy-so-excited-about-node-js-and-javascript-7cfc423efb44" rel="noopener ugc nofollow" target="_blank">见我那篇关于我从Java过渡到Node.js的文章</a>)有多个组织为多个平台创建的多个Java实现。多个Java实现之间的兼容性由相应的TCK来保证。我不记得缩写是什么意思了，但它是一个兼容性测试，或者更准确地说，是对规范的符合性测试。</p><p id="e1f3" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">Bun团队正着手创建Node.js API的第二个实现。这使它处于与独立开发的Java实现相同的角色。</p><p id="6ce9" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">作为Node.js或Bun的潜在客户，我们需要了解两者之间的兼容程度。我们的工作可能是维护一家价值数十亿美元的企业的网站，在两者之间做出糟糕的选择可能会扼杀这家企业。</p><p id="2972" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">在Java生态系统中，一致性/兼容性测试是建立可信度的一大步。通过这些测试是一件大事，并允许一个项目或产品自称为Java兼容的。</p><p id="1c86" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">Node.js没有这样的测试套件，也没有Node.js API的正式规范。<code class="fe lr ls lt lu b">https://nodejs.org/api/index.html</code>的API文档很好，但不是正式的规范。在Java生态系统中，一致性测试是通过仔细解析规范中的细节来编写的。</p><p id="4610" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">随着时间的推移，可能会有其他尝试来构建Node.js API的独立实现。像今天的Bun团队一样，这些团队将面临同样的问题，即确定与Node.js的兼容程度。</p><p id="74f1" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">理论上，团队需要梳理Node.js API文档。一致性测试可以被开发，理想地作为一个独立的项目，可以被Node.js和Bun团队使用。</p><p id="1b7a" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">然而，这需要大量的工作，谁有资金支付这样的测试套件？</p><p id="deb0" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">目前，Bun团队将创建他们认为适合Bun的任何测试。如果我在Bun团队工作，我会寻找一种方法来利用Node.js团队开发的测试。我甚至可能在一个单独的存储库中这样做。Bun和Node.js团队的目标是共同合作开发Node.js API的测试套件。</p><p id="86f5" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">我想到的一个想法是，有人可以开发一个网站或GitHub存储库，项目所有者可以通过它来声明“<em class="nu">与Bun </em>一起工作”……越来越多的“<em class="nu">与Bun </em>一起工作”包应该有助于证明Bun是一个不错的选择。“【T4作品与包子”倡议的发起者会用什么标准来验证真实性？</p><p id="61e3" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">可能我跑题太远了。</p><p id="ee40" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">这篇文章证明了两件事:</p><ol class=""><li id="131f" class="mt mu iu kx b ky kz lb lc le mv li mw lm mx lq my mz na nb bi translated">试图在Bun上运行重要的应用程序还为时过早，因为它缺少许多功能。</li><li id="14a6" class="mt mu iu kx b ky nc lb nd le ne li nf lm ng lq my mz na nb bi translated">根据功能的不同，性能会有所提高。</li></ol><p id="0ce3" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">底线是如果Node.js社区参与进来，Bun将会成功。在推荐将Bun用于重要应用程序之前，还有许多工作要做。性能提升非常有希望。</p><h1 id="b0c2" class="lw lx iu bd ly lz ma mb mc md me mf mg ka mh kb mi kd mj ke mk kg ml kh mm mn bi translated">关于作者</h1><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj ny"><img src="../Images/b0ae04524ec14860d9209ec45070aa7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*Baih9PRtAwXSThu4.jpg"/></div></figure><p id="10c1" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated"><a class="ae lv" href="https://davidherron.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="kx iv">大卫·赫伦</strong> </a> <strong class="kx iv"> </strong>:大卫·赫伦是一名作家和软件工程师，专注于技术的明智使用。他对太阳能、风能和电动汽车等清洁能源技术特别感兴趣。David在硅谷从事了近30年的软件工作，从电子邮件系统到视频流，再到Java编程语言，他已经出版了几本关于Node.js编程和电动汽车的书籍。</p></div><div class="ab cl nz oa hy ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="in io ip iq ir"><p id="e263" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated"><em class="nu">原载于</em><a class="ae lv" href="https://techsparx.com/nodejs/bun/speed-test.html" rel="noopener ugc nofollow" target="_blank"><em class="nu">https://techsparx.com</em></a><em class="nu">。</em></p></div></div>    
</body>
</html>