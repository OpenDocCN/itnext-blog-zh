# 开发者:为性能和效率而设计。

> 原文：<https://itnext.io/developers-dont-fail-this-first-step-31d193241bbf?source=collection_archive---------2----------------------->

## 解决问题有一千种方法。

考虑性能对于获得稳定的最终产品至关重要。在设计解决方案的关键第一步，我经常看到事情出错。当第一步出了问题，接下来的步骤就会土崩瓦解。让我们一起来看一个实际的例子，看看为什么它如此重要。

![](img/55b9c65549926c349df485b16e82a502.png)

一开始就为性能而设计。照片由 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上的 [Jp Valery](https://unsplash.com/@jpvalery?utm_source=medium&utm_medium=referral)

# 解决方案并不总是好的解决方案

开发中最大的错误之一就是简单地开发“一个解决方案”。在开发解决方案时，我们不希望采用先到先得的方法。相反，花时间想一个解决方法。一旦你比较了不同解决方案的优缺点，就选择最有意义的方案。这需要一些解决问题的技巧和时间去思考一个问题。

慢慢来，不要匆忙，这很重要。一旦你承担越来越多的技术决策，这一点就会变得越来越明显。你会发现，在立即寻找解决方案之前，通过思考或等待，一个完全不同的想法可能会出现在你的脑海中，以一种更好更快的方式工作，同时也节省了开发工作！

> 不要急于做出开发和技术决策。总是喜欢稳定的最终产品。

虽然我们将在下面的例子中使用 Java，但本文对任何编程语言都有效。通过改进解决方案背后的算法，我们可以提高应用程序的性能。这本身就说明了问题，然而，我们在这个问题上应该有多极端呢？让我们开始吧！

# 目标:计数重复

对于这个例子，我们将重点关注[这个 CodeWars kata](https://www.codewars.com/kata/54bf1c2cd5b56cc47f0007a1/train/java) :计数重复。以下是这个形的说明:

> 编写一个函数，该函数将返回在输入字符串中多次出现的不区分大小写的字母字符和数字的计数。可以假设输入字符串只包含字母(大写和小写)和数字。~代码战争

因此，我们的目的是创建一个函数，返回一个字符串中不区分大小写的重复字符的数量。注意不要混淆，我们不需要重复的总数，相反，我们需要有重复的字符的数量。让我们看看 CodeWars 提供的一些示例输出值。

> " abcde "-> 0`# no characters repeats more than once`
> " aabBcde "->2`# 'a' and 'b'`
> " aabBcde "->2`# 'a' occurs twice and 'b' twice (`b` and `B`)`
> "不可分割性"- > 1 `# 'i' occurs six times`
> "不可分割性"->2`# 'i' occurs seven times and 's' occurs twice`
> " aA11 "->2`# 'a' and '1'`
> " ABBA "->2`# 'A' and 'B' each occur twice` 来源: [CodeWars](https://www.codewars.com/kata/54bf1c2cd5b56cc47f0007a1/train/java)

慢慢来，迅速想出解决这个问题的办法。让我们在下图中找到一种可能的实现方式。

![](img/41f5de2c69013dcb883cd1e9046394be.png)

奥斯卡·伊尔迪兹在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄的照片

# 第一种解决方案

我们需要计算一个字符串中的重复数。一个简单的方法是检查字符串，对于每个字符，在同一个字符串中搜索重复的，对吗？让我们试一试。

## 第一个解决方案:代码

我们现在有了这个问题的第一个工作解决方案！问题解决了，一切都好，对吧？是吗？让我们思考一下我们已经完成了什么。我们使用了多少内存？这个解决方案的复杂性是什么？我们做了不必要的动作吗？让我们来看看。

## 第一个解决方案元:空间复杂性

我们使用了多少内存？我们使用一个`ArrayList`来保存有重复的字符，并使用一个整数来计算总重复数。

如果我们有`n`个重复字符，我们将使用大约`n + 1`个空间，也称为空间复杂度。请注意，这不是一个确切的数字，但更多的是对空间使用情况的估计。

通常，空间复杂度是作为我们得到的输入文本的最坏情况的内存使用来衡量的。在最坏的情况下，空间复杂度将等于或低于输入文本长度，因此我们可以用`O(n)`作为我们空间复杂度的最坏情况，认为`n`是我们的输入文本长度。

## 第一个解决方案元:时间复杂性

在我们的解决方案中，我们有两个循环。更糟糕的是，我们有一个循环中的循环..如果`n`是我们的输入长度，我们将在`n`上循环`n`次，与`n²`相同。这导致了`O(n²)`的时间复杂性。

乍看之下，`O(n²)`不是一种非常有效的计算方式，除非真的有必要。

## 第一个解决方案元:不必要的计算

我们的解决方案不包含不必要的变量或计算。

## 第一个解决方案元:结论和元

我们用`O(n)`的空间复杂度相当不错，但是我们用`O(n²)`的时间复杂度真的不是很大。

我们还能做得更好吗？我们认为，在实际开发解决方案之前，最好先考虑不同的解决方案，而不是立即投入解决方案。现在，我们已经浪费了时间来制作一个可能已经实际交付生产的低效解决方案，我们仍然需要想出一个更好的解决方案。最终，仍然需要重构或从头编写第二个解决方案。

# 第二个解决方案

为了提高时间复杂度，我们需要尽可能地避免循环中的循环。实现这一点的一种方法是为了赢得时间复杂度而牺牲一些空间复杂度。这意味着我们可以通过缓存值来节省时间，因此我们不需要重新计算这些值。

花点时间想想这个问题的下一个解决方案。准备好之后，向下滚动到下一张图片，找到我们的下一个想法。

![](img/2dec3dfbd6517c436e7fd1ab3f51613a.png)

[斯科特·格雷厄姆](https://unsplash.com/@homajob?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上的照片

我们需要的是计算重复字符的数量。如果我们在内存中保存每个字符的副本数量会怎么样？我们可以在整个输入中循环一次，计算每个字符的重复数。最后，我们将检查每个字符的重复列表，并计算实际上有重复的字符数。

让我们开始实施这个解决方案吧！

## 第二个解决方案:代码

我们现在有了第二个可行的解决方案。让我们再次反思我们在三个方面所做的工作。

1.  时间复杂度
2.  空间复杂性
3.  不必要的代码

## 第二个解决方案元:空间复杂性

就空间而言，我们使用了一个 hashmap 和一个 integer。请记住，我们需要将复杂性与我们收到的输入量进行比较。我们将定义`n`为输入文本的长度。散列表将包含不同字符的数量。在最坏的情况下，让我们考虑这将是与输入字符串相同的数量。

我们可以推断我们的空间复杂度大约为`O(n)`。不要忘记这是一个估计，所以如果它是 4-5 个整数，我们仍然会保留一个`O(n)`，因为它永远不会到达`O(2n)`或`O(n²)`，除非`n`低得不切实际。

## 第二个解决方案元:时间复杂性

从时间上来说，我们做得好多了！我们不再有嵌套循环了。相反，我们有两个循环，一个用于输入，一个用于我们缓存的字符列表。

我们可以断定这是一个大约为`O(2n)`的时间复杂度。

## 第二个解决方案元:不必要的计算

这一次，我们没有不必要的变量或计算。

## 第二解决方案元:结论和元

我们的第二个解决方案是牺牲一点空间，以获得更好的时间复杂度。然而，如果我们看一下结果，粗略地说，这两种解决方案的空间复杂度都是`O(n)`，所以从`O(n²)`到`O(2n)`，与时间复杂度增益相比，稍微大一点的空间使用是非常小的。

# 总结和结论

最佳解决方案往往不是你首先想到的。慢慢想。想一想是否有什么方法可以让它变得更好，提供值得你花时间去做的改进，而不会让解决方案变得太复杂。

还要考虑你正在做的东西是否真的需要，或者它是否可以开箱即用，不需要实际的代码。有时候，额外的代码不是解决问题的方法，而问题可以通过改变环境变量来解决。

如果没有经过深思熟虑，现在开发的最快的解决方案可能会在将来花费您更多的重构和开发时间。

## 提高性能的复杂解决方案

如果这个解决方案只是稍微快了一点，但是使维护变得太复杂，在我看来是不值得的。始终考虑未来的维护成本，以及将来更新时哪个解决方案可能导致潜在的错误。我们不想混淆未来的自己或来自未来的同事！

拥有一个性能稍微好一点的解决方案，在将来更容易出错，通常是不值得的。我们不想过度设计它。努力在性能和可读、可维护的代码之间取得平衡。

## 其他解决方案

请注意，我并不是说第二种解决方案是最好的。然而，这两个解决方案确实说明了本文的观点。开发人员应该在实际开发之前花些时间考虑解决方案。此外，他们还应该反思自己的解决方案，以及这些解决方案是否足够好，可以交付到生产环境中。

[订阅我的媒介](https://kevinvr.medium.com/membership)到**解锁** **所有** **文章**。通过使用我的链接订阅，你是支持我的工作，没有额外的费用。你会得到我永远的感激。