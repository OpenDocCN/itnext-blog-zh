<html>
<head>
<title>Azure DevOps Pipelines: Multi-Stage Pipelines</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Azure DevOps管道:多级管道</h1>
<blockquote>原文：<a href="https://itnext.io/azure-devops-pipelines-multi-stage-pipelines-555dad72047c?source=collection_archive---------8-----------------------#2020-07-20">https://itnext.io/azure-devops-pipelines-multi-stage-pipelines-555dad72047c?source=collection_archive---------8-----------------------#2020-07-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="6e9c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">前几篇文章一直在讨论Azure Pipelines下的Releases区域管理的发布。本周，我们将把我们在Azure DevOps的独立领域中所做的事情变成目前构建我们应用程序的YAML的一部分。如果你需要一些关于这个项目如何发展到这一步的背景知识，可以看看下面的帖子。</p><p id="fef3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://elanderson.net/2020/02/getting-started-with-azure-devops/" rel="noopener ugc nofollow" target="_blank">Azure devo PS入门</a><br/><a class="ae kl" href="https://elanderson.net/2020/03/pipeline-creation-in-azure-devops/" rel="noopener ugc nofollow" target="_blank">Azure devo PS中的管道创建</a> <br/> <a class="ae kl" href="https://elanderson.net/2020/03/azure-devops-publish-asp-net-core/" rel="noopener ugc nofollow" target="_blank"> Azure DevOps为ASP.NET核心发布工件</a> <br/> <a class="ae kl" href="https://elanderson.net/2020/03/azure-devops-pipelines-multiple-jobs-in-yaml/" rel="noopener ugc nofollow" target="_blank"> Azure DevOps管道:YAML的多个作业</a> <br/> <a class="ae kl" href="https://elanderson.net/2020/03/azure-devops-pipelines-reuseable-yaml/" rel="noopener ugc nofollow" target="_blank"> Azure DevOps管道:可重用的YAML </a> <br/> <a class="ae kl" href="https://elanderson.net/2020/04/azure-devops-pipelines-use-yaml-across-repos/" rel="noopener ugc nofollow" target="_blank"> Azure DevOps管道:跨Repos使用YAML</a><br/><a class="ae kl" href="https://elanderson.net/2020/04/azure-devops-pipelines-conditionals-in-yaml/" rel="noopener ugc nofollow" target="_blank">Azure devo PS管道:YAML的条件</a> <br/> <a class="ae kl" href="https://elanderson.net/2020/04/azure-devops-pipelines-naming-and-tagging/" rel="noopener ugc nofollow" target="_blank"> Azure DevOps管道:依赖于YAML的with条件</a> <br/> <a class="ae kl" href="https://elanderson.net/2020/05/azure-devops-pipelines-powershell-task/" rel="noopener ugc nofollow" target="_blank"> Azure DevOps管道:PowerShell任务</a> <br/> <a class="ae kl" href="https://elanderson.net/2020/07/azure-devops-releases-auto-create-new-release-after-pipeline-build/" rel="noopener ugc nofollow" target="_blank"> Azure DevOps版本:在管道构建后自动创建新版本</a> <br/> <a class="ae kl" href="https://elanderson.net/2020/07/azure-devops-releases-auto-create-release-with-pull-requests/" rel="noopener ugc nofollow" target="_blank"> Azure DevOps版本:自动创建带有拉请求的版本</a></p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi km"><img src="../Images/24159af0acfff56cbf142949d43943aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/0*howUs-pV1zr6XxIJ.png"/></div></figure><h2 id="aaa6" class="ku kv iq bd kw kx ky dn kz la lb dp lc jy ld le lf kc lg lh li kg lj lk ll lm bi translated">概述</h2><p id="239f" class="pw-post-body-paragraph jn jo iq jp b jq ln js jt ju lo jw jx jy lp ka kb kc lq ke kf kg lr ki kj kk ij bi translated">我们目前的设置使用基于YAML的Azure管道来构建几个ASP.NET核心web应用程序。然后在发布方面，我们基本上有一个虚拟发布，它实际上不做任何事情，只是作为如何配置持续部署类型发布的演示。以下是目前YAML的管道供我们参考。</p><pre class="kn ko kp kq gt ls lt lu lv aw lw bi"><span id="afdb" class="ku kv iq lt b gy lx ly l lz ma">name: $(SourceBranchName)_$(date:yyyyMMdd)$(rev:.r)<br/><br/>resources:      <br/>  repositories: <br/>  - repository: Shared<br/>    name: Playground/Shared<br/>    type: git <br/>    ref: master #branch name<br/><br/>trigger: none<br/><br/>variables:<br/>  buildConfiguration: 'Release'<br/><br/>jobs:<br/>- job: WebApp1<br/>  displayName: 'Build WebApp1'<br/>  pool:<br/>    vmImage: 'ubuntu-latest'<br/><br/>  steps:<br/>  - task: PowerShell@2<br/>    inputs:<br/>      targetType: 'inline'<br/>      script: 'Get-ChildItem -Path Env:\'<br/><br/>  - template: buildCoreWebProject.yml@Shared<br/>    parameters:<br/>      buildConFiguration: $(buildConfiguration)<br/>      project: WebApp1.csproj<br/>      artifactName: WebApp1<br/><br/>- job: WebApp2<br/>  displayName: 'Build WebApp2'<br/>  condition: and(succeeded(), eq(variables['BuildWebApp2'], 'true'))<br/>  pool:<br/>    vmImage: 'ubuntu-latest'<br/><br/>  steps:<br/>  - template: build.yml<br/>    parameters:<br/>      buildConFiguration: $(buildConfiguration)<br/>      project: WebApp2.csproj<br/>      artifactName: WebApp2<br/>      <br/>- job: DependentJob<br/>  displayName: 'Build Dependent Job'<br/>  pool:<br/>    vmImage: 'ubuntu-latest'<br/><br/>  dependsOn:<br/>  - WebApp1<br/>  - WebApp2<br/><br/>  steps:<br/>  - template: buildCoreWebProject.yml@Shared<br/>    parameters:<br/>      buildConFiguration: $(buildConfiguration)<br/>      project: WebApp1.csproj<br/>      artifactName: WebApp1Again<br/><br/>- job: TagSources<br/>  displayName: 'Tag Sources'<br/>  pool:<br/>    vmImage: 'ubuntu-latest'<br/><br/>  dependsOn:<br/>  - WebApp1<br/>  - WebApp2<br/>  - DependentJob<br/>  condition: |<br/>    and<br/>    (<br/>      eq(dependencies.WebApp1.result, 'Succeeded'),<br/>      in(dependencies.WebApp2.result, 'Succeeded', 'Skipped'),<br/>      in(dependencies.DependentJob.result, 'Succeeded', 'Skipped')<br/>    )<br/> <br/>  steps:<br/>  - checkout: self<br/>    persistCredentials: true<br/>    clean: true<br/>    fetchDepth: 1<br/><br/>  - task: PowerShell@2<br/>    inputs:<br/>      targetType: 'inline'<br/>      script: |<br/>        $env:GIT_REDIRECT_STDERR` = '2&gt;&amp;1'<br/>        $tag = "manual_$(Build.BuildNumber)".replace(' ', '_')<br/>        git tag $tag<br/>        Write-Host "Successfully created tag $tag" <br/><br/>        git push --tags<br/>         Write-Host "Successfully pushed tag $tag"     <br/><br/>      failOnStderr: false</span></pre><p id="5c6b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上面的设置工作得很好，但在今年4月，Azure Pipelines有了<a class="ae kl" href="https://devblogs.microsoft.com/premier-developer/azure-devops-pipelines-multi-stage-pipelines-and-yaml-for-continuous-delivery/" rel="noopener ugc nofollow" target="_blank">多级管道</a>的概念，这使我们能够在与我们的构建相同的YAML中管理发布方面的事情，并允许发布受源代码控制，并且每个分支都不同，就像在YAML的构建一样。</p><h2 id="902a" class="ku kv iq bd kw kx ky dn kz la lb dp lc jy ld le lf kc lg lh li kg lj lk ll lm bi translated">简化版YAML</h2><p id="cf2c" class="pw-post-body-paragraph jn jo iq jp b jq ln js jt ju lo jw jx jy lp ka kb kc lq ke kf kg lr ki kj kk ij bi translated">以上是我们的示例构建的完整YAML，其中包含大量代码。下面是一个配对的版本，我们将在这篇文章的剩余部分使用，它只构建WebApp1，应该有助于突出这些变化。</p><pre class="kn ko kp kq gt ls lt lu lv aw lw bi"><span id="2da7" class="ku kv iq lt b gy lx ly l lz ma">name: $(SourceBranchName)_$(date:yyyyMMdd)$(rev:.r)<br/><br/>resources:      <br/>  repositories: <br/>  - repository: Shared<br/>    name: Playground/Shared<br/>    type: git <br/>    ref: master #branch name<br/><br/>trigger: none<br/><br/>variables:<br/>  buildConfiguration: 'Release'<br/><br/>jobs:<br/>- job: WebApp1<br/>  displayName: 'Build WebApp1'<br/>  pool:<br/>    vmImage: 'ubuntu-latest'<br/><br/>  steps:<br/>  - task: PowerShell@2<br/>    inputs:<br/>      targetType: 'inline'<br/>      script: 'Get-ChildItem -Path Env:\'<br/><br/>  - template: buildCoreWebProject.yml@Shared<br/>    parameters:<br/>      buildConFiguration: $(buildConfiguration)<br/>      project: WebApp1.csproj<br/>      artifactName: WebApp1</span></pre><h2 id="ca33" class="ku kv iq bd kw kx ky dn kz la lb dp lc jy ld le lf kc lg lh li kg lj lk ll lm bi translated">添加阶段</h2><p id="e83b" class="pw-post-body-paragraph jn jo iq jp b jq ln js jt ju lo jw jx jy lp ka kb kc lq ke kf kg lr ki kj kk ij bi translated">阶段是分组的额外一层，有助于划分管道，类似于作业的工作方式，只是级别更高。作业是一组步骤，但阶段是一组作业。在下面的YAML中，您可以看到我们现有的作业已经被分组到一个构建阶段下，并且添加了一个新的发布阶段。</p><pre class="kn ko kp kq gt ls lt lu lv aw lw bi"><span id="956e" class="ku kv iq lt b gy lx ly l lz ma">name: $(SourceBranchName)_$(date:yyyyMMdd)$(rev:.r)<br/><br/>resources:      <br/>  repositories: <br/>  - repository: Shared<br/>    name: Playground/Shared<br/>    type: git <br/>    ref: master #branch name<br/><br/>trigger: none<br/><br/>variables:<br/>  buildConfiguration: 'Release'<br/><br/>stages:<br/>- stage: Build<br/>  jobs:<br/>  - job: WebApp1<br/>    displayName: 'Build WebApp1'<br/>    pool:<br/>      vmImage: 'ubuntu-latest'<br/><br/>    steps:<br/>    - task: PowerShell@2<br/>      inputs:<br/>        targetType: 'inline'<br/>        script: 'Get-ChildItem -Path Env:\'<br/><br/>    - template: buildCoreWebProject.yml@Shared<br/>      parameters:<br/>        buildConFiguration: $(buildConfiguration)<br/>        project: WebApp1.csproj<br/>        artifactName: WebApp1<br/><br/>- stage: Deploy<br/>  jobs:<br/>  - job: Deploy<br/>    steps:<br/>      - script: echo Fake deploying code</span></pre><p id="1b61" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当添加阶段时，注意你的空格，当你在阶段中包装它们时，很容易遗漏你现有代码中的空格。</p><h2 id="1d05" class="ku kv iq bd kw kx ky dn kz la lb dp lc jy ld le lf kc lg lh li kg lj lk ll lm bi translated">结果</h2><p id="8ae8" class="pw-post-body-paragraph jn jo iq jp b jq ln js jt ju lo jw jx jy lp ka kb kc lq ke kf kg lr ki kj kk ij bi translated">经过上述更改运行管道后，您将在管道的摘要页面上看到，它将显示每个阶段的结果。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi mb"><img src="../Images/17c2889dc08a4863b8d4b2b5433d33e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*xjpCd0cmqZZFGjEY.png"/></div></div></figure><p id="c891" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在特定管道运行的详细视图中，现在将有一个Stages选项卡，按阶段显示结果。如果您在某个阶段点击了扩展器，它还会为您提供一个重新运行某个阶段的选项(如果您需要的话)。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi mg"><img src="../Images/e243f9d475015bf34b771aacfcddb449.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*uRXnY2jysvWPK39Z.png"/></div></div></figure><h2 id="ccc0" class="ku kv iq bd kw kx ky dn kz la lb dp lc jy ld le lf kc lg lh li kg lj lk ll lm bi translated">包扎</h2><p id="f9a8" class="pw-post-body-paragraph jn jo iq jp b jq ln js jt ju lo jw jx jy lp ka kb kc lq ke kf kg lr ki kj kk ij bi translated">希望这将帮助您快速建立自己的多级管道。虽然我仍然不喜欢YAML，但是当你需要的时候，让构建和发布在源代码控制中能够随分支的不同而变化是很好的。如果您希望每次都运行所有的阶段，这个设置非常有用。后续的帖子会看看如何制作一个需要审批的舞台。</p></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><p id="2a63" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mo">原载于</em> <a class="ae kl" href="https://elanderson.net/2020/07/azure-devops-pipelines-multi-stage-pipelines/" rel="noopener ugc nofollow" target="_blank"> <em class="mo">安德森</em> </a> <em class="mo">。</em></p></div></div>    
</body>
</html>