<html>
<head>
<title>gVisor on ECS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ECS上的监视器</h1>
<blockquote>原文：<a href="https://itnext.io/gvisor-on-ecs-78d4edc24604?source=collection_archive---------10-----------------------#2019-04-05">https://itnext.io/gvisor-on-ecs-78d4edc24604?source=collection_archive---------10-----------------------#2019-04-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="a3f2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">谷歌的<a class="ae kl" href="https://github.com/google/gvisor" rel="noopener ugc nofollow" target="_blank"> gVisor </a>的存在是为了给你的Docker容器提供一个<strong class="jp ir">真正的沙箱</strong>。它取代了最近有严重漏洞的默认Docker运行时<code class="fe km kn ko kp b">runc</code>。</p><p id="b9dd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">理论上，gVisor是<code class="fe km kn ko kp b">runc</code>的替代产品<strong class="jp ir">，但它真的能与<a class="ae kl" href="https://aws.amazon.com/ecs/" rel="noopener ugc nofollow" target="_blank">亚马逊ECS </a>一起工作吗？</strong></p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi kq"><img src="../Images/023cebbd838abe0724bf75a5005e0368.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*L6bdhJwUJbkwTStK.jpg"/></div></div><figcaption class="lc ld gj gh gi le lf bd b be z dk translated">克里斯·帕纳斯<a class="ae kl" href="https://unsplash.com/@chrispanas" rel="noopener ugc nofollow" target="_blank">https://unsplash.com/@chrispanas</a></figcaption></figure><h1 id="fa94" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">什么是gVisor？</h1><blockquote class="me mf mg"><p id="6d92" class="jn jo mh jp b jq jr js jt ju jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj kk ij bi translated">gVisor是容器的用户空间内核。它限制了应用程序可访问的主机内核表面，同时仍然允许应用程序访问它期望的所有特性。</p><p id="0d93" class="jn jo mh jp b jq jr js jt ju jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj kk ij bi translated"><a class="ae kl" href="https://github.com/google/gvisor" rel="noopener ugc nofollow" target="_blank"><em class="iq">github.com/google/gvisor</em></a></p></blockquote><p id="77fb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Docker不像VMs那样在容器之间提供严格的安全边界。同一主机上的容器共享内核，并且可以直接对主机进行系统调用。当多租户(在单个主机上运行多个应用程序)您的虚拟机时，这是一个问题——当您的一个应用程序受到威胁时，您的所有应用程序<strong class="jp ir">都会受到威胁。</strong></p><p id="e6ea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最近，在Docker中发现了其中一个漏洞。</p><blockquote class="me mf mg"><p id="a49c" class="jn jo mh jp b jq jr js jt ju jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj kk ij bi translated"><em class="iq">当以root (UID 0)身份在容器中运行进程时，该进程可以利用runc中的错误来获得运行容器的主机上的root权限。这允许他们无限制地访问服务器以及该服务器上的任何其他容器。</em></p><p id="9417" class="jn jo mh jp b jq jr js jt ju jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj kk ij bi translated"><a class="ae kl" href="https://kubernetes.io/blog/2019/02/11/runc-and-cve-2019-5736/" rel="noopener ugc nofollow" target="_blank"><em class="iq">kubernetes.io/blog/2019/02/11/…</em></a></p></blockquote><p id="0512" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">gVisor通过替换易受攻击的组件<code class="fe km kn ko kp b">runc</code>来缓解此漏洞。</p><h1 id="d362" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">安装遮阳板</h1><p id="ee5b" class="pw-post-body-paragraph jn jo iq jp b jq ml js jt ju mm jw jx jy mn ka kb kc mo ke kf kg mp ki kj kk ij bi translated">作为替代，安装gVisor很简单:</p><pre class="kr ks kt ku gt mq kp mr ms aw mt bi"><span id="230f" class="mu lh iq kp b gy mv mw l mx my">curl -LsO  <a class="ae kl" href="https://storage.googleapis.com/gvisor/releases/nightly/latest/runsc" rel="noopener ugc nofollow" target="_blank">https://storage.googleapis.com/gvisor/releases/nightly/latest/runsc</a><br/>chmod +x runsc<br/>mv runsc /usr/local/bin<br/>cat &lt;&lt;EOF &gt;&gt; /etc/docker/daemon.json<br/>{<br/>    "runtimes": {<br/>        "runsc": {<br/>            "path": "/usr/local/bin/runsc"<br/>       }<br/>    }<br/>}<br/>EOF<br/>systemctl restart docker</span></pre><p id="7d03" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，您可以通过在Docker命令中添加<code class="fe km kn ko kp b">--runtime=runsc</code>标志来使用gVisor运行容器。</p><p id="bfca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">这本身并不是特别有用</strong>，因为我们依赖ECS来为我们编排和运行容器。不幸的是，我们不能直接从ECS中挑选运行时。<a class="ae kl" href="https://github.com/aws/amazon-ecs-agent/issues/1084" rel="noopener ugc nofollow" target="_blank">此功能请求仍未完成</a>。<a class="ae kl" href="https://github.com/aws/amazon-ecs-agent/issues/1084#issuecomment-357689366" rel="noopener ugc nofollow" target="_blank">其中一条注释</a>为我们提供了一个解决方法的提示:<strong class="jp ir">覆盖默认运行时</strong>。我们需要做的只是向Docker配置文件添加一个额外的值:</p><pre class="kr ks kt ku gt mq kp mr ms aw mt bi"><span id="f04c" class="mu lh iq kp b gy mv mw l mx my">{<br/>    "default-runtime": "runsc",<br/>    "runtimes": {<br/>        "runsc": {<br/>            "path": "/usr/local/bin/runsc"<br/>       }<br/>    }<br/>}</span></pre><p id="06bb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">重启Docker后，我们可以看到容器现在使用gVisor沙箱化了:</p><pre class="kr ks kt ku gt mq kp mr ms aw mt bi"><span id="585a" class="mu lh iq kp b gy mv mw l mx my">$ docker run -d nginx<br/>Unable to find image 'nginx:latest' locally<br/>latest: Pulling from library/nginx<br/>f7e2b70d04ae: Pull complete<br/>08dd01e3f3ac: Pull complete<br/>d9ef3a1eb792: Pull complete<br/>Digest: sha256:98efe605f61725fd817ea69521b0eeb32bef007af0e3d0aeb6258c6e6fe7fc1a<br/>Status: Downloaded newer image for nginx:latest<br/>74cdfe0c0c1b1520b662d946c98883190b885f456ab3c082104521b88460a37c<br/>$ ps aux | grep '[r]unc'<br/>$ # no results<br/>$ ps aux | grep '[r]unsc'<br/>root     29540  0.0  0.0  10800  5004 ?        Sl   10:29   0:00 containerd-shim -namespace moby -workdir /var/lib/containerd/io.containerd.runtime.v1.linux/moby/74cdfe0c0c1b1520b662d946c98883190b885f456ab3c082104521b88460a37c -address /run/containerd/containerd.sock -containerd-binary /usr/bin/containerd -runtime-root /var/run/docker/runtime-runsc<br/>root     29553  0.0  0.0 119304 11404 ?        Sl   10:29   0:00 runsc-gofer --root=/var/run/docker/runtime-runsc/moby --debug=false --log=/run/containerd/io.containerd.runtime.v1.linux/moby/74cdfe0c0c1b1520b662d946c98883190b885f456ab3c082104521b88460a37c/log.json --log-format=json --debug-log= --debug-log-format=text --file-access=exclusive --overlay=false --network=sandbox --log-packets=false --platform=ptrace --strace=false --strace-syscalls= --strace-log-size=1024 --watchdog-action=LogWarning --panic-signal=-1 --log-fd=3<br/>gofer --bundle /run/containerd/io.containerd.runtime.v1.linux/moby/74cdfe0c0c1b1520b662d946c98883190b885f456ab3c082104521b88460a37c --spec-fd=4 --io-fds=5 --io-fds=6 --io-fds=7<br/>--io-fds=8 --apply-caps=false --setup-root=false<br/>nfsnobo+ 29557  2.6  0.1 166480 22572 ?        Ssl  10:29   0:01 runsc-sandbox --root=/var/run/docker/runtime-runsc/moby --debug=false --log=/run/containerd/io.containerd.runtime.v1.linux/moby/74cdfe0c0c1b1520b662d946c98883190b885f456ab3c082104521b88460a37c/log.json --log-format=json --debug-log= --debug-log-format=text --file-access=exclusive --overlay=false --network=sandbox --log-packets=false --platform=ptrace --strace=false --strace-syscalls= --strace-log-size=1024 --watchdog-action=LogWarning --panic-signal=-1 --log-fd=3 boot --bundle=/run/containerd/io.containerd.runtime.v1.linux/moby/74cdfe0c0c1b1520b662d946c98883190b885f456ab3c082104521b88460a37c --controller-fd=4 --spec-fd=5 --start-sync-fd=6 --io-fds=7 --io-fds=8 --io-fds=9 --io-fds=10 --stdio-fds=11 --stdio-fds=12 --stdio-fds=13 --cpu-num 8 74cdfe0c0c1b1520b662d946c98883190b885f456ab3c082104521b88460a37c</span></pre><h1 id="9cfc" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">正在运行<code class="fe km kn ko kp b">ecs-agent</code></h1><p id="1a65" class="pw-post-body-paragraph jn jo iq jp b jq ml js jt ju mm jw jx jy mn ka kb kc mo ke kf kg mp ki kj kk ij bi translated">因为gVisor只实现了有限的一组Linux系统调用，所以有些东西不能用它。任何期望在较低层次上与系统交互的东西都可能无法按预期工作。</p><p id="3166" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一个显而易见的例子是ECS用来管理EC2实例的代理。在<a class="ae kl" href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/al2ami.html" rel="noopener ugc nofollow" target="_blank"> Amazon ECS优化的Amazon Linux 2 </a>上，<a class="ae kl" href="https://github.com/aws/amazon-ecs-agent" rel="noopener ugc nofollow" target="_blank"> ECS代理</a>通常由ecs-init systemd服务启动，并运行Docker容器本身。因为它需要对运行它的系统进行低级别的访问，所以它不能很好地与gVisor兼容。</p><p id="cedf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是可以的，因为我们的目标不是用沙箱保护ECS代理本身。<code class="fe km kn ko kp b">docker</code>客户端允许我们指定另一个运行时，因此我们可以强制ECS代理使用<code class="fe km kn ko kp b">runc</code>，Docker的默认运行时运行:</p><p id="7650" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe km kn ko kp b">docker run --runtime=runc [...]</code></p><p id="15dc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不幸的是，ecs-init服务相当不透明，所以我们不能以优雅的方式覆盖它。完全禁用它并手动启动ECS代理(使用额外的运行时标志)可以达到预期的效果。</p><pre class="kr ks kt ku gt mq kp mr ms aw mt bi"><span id="4da8" class="mu lh iq kp b gy mv mw l mx my">systemctl stop ecs  # the ecs-init service will try to start the ecs-agent with gVisor, which doesn't work. We must force stop it and run ecs-agent with runc<br/>systemctl disable ecs<br/>docker run --name ecs-agent \<br/>    --runtime=runc \<br/>    --detach=true \<br/>    --restart=on-failure:10 \<br/>    --volume=/var/run/docker.sock:/var/run/docker.sock \<br/>    --volume=/var/log/ecs:/log \<br/>    --volume=/var/lib/ecs/data:/data \<br/>    --net=host \<br/>    --env-file=/etc/ecs/ecs.config \<br/>    --env=ECS_LOGFILE=/log/ecs-agent.log \<br/>    --env=ECS_DATADIR=/data/ \<br/>    --env=ECS_ENABLE_TASK_IAM_ROLE=true \<br/>    --env=ECS_ENABLE_TASK_IAM_ROLE_NETWORK_HOST=true \<br/>    amazon/amazon-ecs-agent:latest</span></pre><p id="adc0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通常，手动调用一个通常由init系统管理的进程并期望它保持运行是一个坏主意。在这种情况下，Docker守护程序管理ECS代理的正常运行时间，并在失败时重新启动它。</p><h1 id="8779" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">把所有的放在一起</h1><p id="99d2" class="pw-post-body-paragraph jn jo iq jp b jq ml js jt ju mm jw jx jy mn ka kb kc mo ke kf kg mp ki kj kk ij bi translated">总之，您的userdata或AMI烘焙脚本将如下所示:</p><pre class="kr ks kt ku gt mq kp mr ms aw mt bi"><span id="4209" class="mu lh iq kp b gy mv mw l mx my">curl -LsO  <a class="ae kl" href="https://storage.googleapis.com/gvisor/releases/nightly/latest/runsc" rel="noopener ugc nofollow" target="_blank">https://storage.googleapis.com/gvisor/releases/nightly/latest/runsc</a><br/>chmod +x runsc<br/>mv runsc /usr/local/bin<br/>cat &lt;&lt;EOF &gt;&gt; /etc/docker/daemon.json<br/>{<br/>    "default-runtime": "runsc",<br/>    "runtimes": {<br/>        "runsc": {<br/>            "path": "/usr/local/bin/runsc"<br/>       }<br/>    }<br/>}<br/>EOF<br/>systemctl restart docker<br/>systemctl stop ecs  # the ecs-init service will try to start the ecs-agent with gVisor, which doesn't work. We must force stop it and run ecs-agent with runc<br/>systemctl disable ecs<br/>docker run --name ecs-agent \<br/>    --runtime=runc \<br/>    --detach=true \<br/>    --restart=on-failure:10 \<br/>    --volume=/var/run/docker.sock:/var/run/docker.sock \<br/>    --volume=/var/log/ecs:/log \<br/>    --volume=/var/lib/ecs/data:/data \<br/>    --net=host \<br/>    --env-file=/etc/ecs/ecs.config \<br/>    --env=ECS_LOGFILE=/log/ecs-agent.log \<br/>    --env=ECS_DATADIR=/data/ \<br/>    --env=ECS_ENABLE_TASK_IAM_ROLE=true \<br/>    --env=ECS_ENABLE_TASK_IAM_ROLE_NETWORK_HOST=true \<br/>    amazon/amazon-ecs-agent:latest</span></pre><p id="999d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">结果是完全透明的。您在ECS上运行的任何服务都将正常启动，并出现在AWS控制台中，就好像您使用的是开箱即用的Docker一样，但实际上您运行的是<code class="fe km kn ko kp b">runsc</code>而不是<code class="fe km kn ko kp b">runc</code>。</p><h1 id="8ef7" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">奖励:资源预留</h1><p id="846a" class="pw-post-body-paragraph jn jo iq jp b jq ml js jt ju mm jw jx jy mn ka kb kc mo ke kf kg mp ki kj kk ij bi translated">我让gVisor在几个集群上运行了几个星期，没有出现任何明显的问题。在此期间，<a class="ae kl" href="https://www.openwall.com/lists/oss-security/2019/02/11/2" rel="noopener ugc nofollow" target="_blank"> runc漏洞</a>被公布，我对自己相当满意。</p><p id="4a68" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有一天，我注意到我们的一个非prod集群出现了一些奇怪的行为。我们的EC2实例从ECS的左右两边断开，导致容器无法调度。我开始调查，发现我们的一个应用程序已经失控，正在消耗100%的<strong class="jp ir">主机的</strong> CPU。ECS代理处于如此严重的资源争用状态，以至于它无法保持与ECS控制平面的连接。</p><p id="eff9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这应该是不可能的。我们充分利用<a class="ae kl" href="https://aarongorka.com/blog/ecs-autoscaling-tips/#enforce-reservations-on-ecs-services" rel="noopener ugc nofollow" target="_blank">多租户和资源预留</a>来防止这类问题。一个应用程序就能关闭群集破坏了多租户的理念。</p><p id="8c7c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">结果是gVisor没有强制执行资源配额。拒绝服务是一种安全风险，所以修补一个小漏洞而在其他地方打开一个大漏洞是没有意义的。我最终不得不从集群中删除gVisor，以使其再次稳定。</p><p id="a5ee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此后，gVisor中增加了对<a class="ae kl" href="https://github.com/google/gvisor/commit/29cd05a7c66ee8061c0e5cf8e94c4e507dcf33e0" rel="noopener ugc nofollow" target="_blank"> cgroup设置</a>的支持。</p><h1 id="7d0d" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">结论</h1><p id="a44c" class="pw-post-body-paragraph jn jo iq jp b jq ml js jt ju mm jw jx jy mn ka kb kc mo ke kf kg mp ki kj kk ij bi translated">对于仍然希望利用容器和多租户的高风险环境，gVisor绝对值得一试。</p><p id="9ab0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于这不是一个完全成熟的项目，您将需要测试任何缺失的功能。您还需要测试<a class="ae kl" href="https://github.com/google/gvisor#will-my-container-work-with-gvisor" rel="noopener ugc nofollow" target="_blank">是否适用于您组织的应用</a>。</p><p id="b8bf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">感谢<a class="ae kl" href="https://medium.com/@melchi.salins" rel="noopener"> Melchi Salins </a>的文章<a class="ae kl" href="https://medium.com/momenton/securing-your-caas-using-googles-gvisor-d6e0cd0ae230" rel="noopener">使用Google的gVisor </a>保护您的CaaS，这启发了我开始研究这个问题。</p></div><div class="ab cl mz na hu nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ij ik il im in"><p id="e02b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mh">原载于</em><a class="ae kl" href="https://aarongorka.com/blog/gvisor-on-ecs/" rel="noopener ugc nofollow" target="_blank"><em class="mh"/></a><em class="mh">。</em></p></div></div>    
</body>
</html>