<html>
<head>
<title>Stupid Simple Service Mesh in Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes中愚蠢的简单服务网格</h1>
<blockquote>原文：<a href="https://itnext.io/stupid-simple-service-mesh-in-kubernetes-9acc9576e1a7?source=collection_archive---------5-----------------------#2022-02-22">https://itnext.io/stupid-simple-service-mesh-in-kubernetes-9acc9576e1a7?source=collection_archive---------5-----------------------#2022-02-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/45d0372e7934ec2261a3f27e560f73de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1GK3ly_7Yrtu7ASP"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">图片由<a class="ae kf" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=2660914" rel="noopener ugc nofollow" target="_blank">皮克斯拜</a>的Gerd Altmann 提供</figcaption></figure><p id="e53f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们在上一篇<a class="ae kf" rel="noopener ugc nofollow" target="_blank" href="/stupid-simple-service-mesh-what-when-why-e9be9e5f4d41"><strong class="ki iu"/></a>中讲述了<strong class="ki iu">什么</strong>，什么时候<strong class="ki iu"/>，以及<strong class="ki iu">为什么</strong>服务网<strong class="ki iu">的</strong>。现在我想谈谈为什么他们在Kubernetes是至关重要的。</p><p id="cc91" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了理解在处理基于微服务的应用程序时使用服务网格的重要性，让我们从一个故事开始。</p><p id="1bfa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">假设您正在开发一个大型的基于微服务的银行应用程序，其中任何错误都会产生严重的影响。有一天，开发团队收到一个特性请求，要求在应用程序中添加一个评级功能。解决方案很明显:创建一个新的微服务，可以处理用户评级。现在是困难的部分。团队必须提出一个合理的时间估计来添加这个新服务。</p><p id="0897" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该团队估计评级系统可以在4次冲刺中完成。经理生气了。他不明白为什么给应用程序添加一个简单的评分功能如此困难。</p><p id="1fa0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了理解估算，让我们来理解为了有一个功能评级微服务我们需要做什么。CRUD(创建、读取、更新、删除)部分很简单——只是简单的编码。但是将这个新项目添加到我们基于微服务的应用程序中并不容易。首先，我们必须实现身份验证和授权，然后我们需要某种跟踪来了解我们的应用程序中发生了什么。因为网络不可靠(不稳定的连接会导致数据丢失)，我们必须考虑重试、断路器、超时等解决方案。</p><p id="1d95" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还需要考虑部署策略。也许我们想使用影子部署在生产中测试我们的代码，而不影响用户。也许我们想增加A/B测试功能或金丝雀部署。因此，即使我们只创建一个简单的微服务，我们也必须牢记许多跨领域的问题。</p><p id="7a52" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有时，向现有服务添加新功能比创建新服务并将其添加到我们的基础架构中要容易得多。部署新服务、添加身份验证和授权、配置跟踪、创建CI/CD管道、实现重试机制等等，都需要花费大量时间。但是将新功能添加到现有服务中会使服务变得太大。它还将打破单一责任的规则，像许多现有的微服务项目一样，它将转变为一组相互连接的“宏服务”或单片。</p><p id="4853" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们称之为<strong class="ki iu">横切关注点负担</strong>——在每个微服务中，你必须重新实现横切关注点，比如认证、授权、重试机制和速率限制。</p><p id="cea3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这种负担的解决方法是什么？有没有办法一次实现所有这些关注点，注入到每一个微服务中，让开发团队专注于产生商业价值？答案是<a class="ae kf" href="https://istio.io/latest/" rel="noopener ugc nofollow" target="_blank"><strong class="ki iu">Istio</strong>T5。</a></p><h1 id="3068" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">使用Istio在Kubernetes中建立服务网格</h1><p id="8188" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">Istio使用<strong class="ki iu">边车</strong>解决了这些问题，它会自动注入你的豆荚。您的服务不会直接相互通信，而是通过边车进行通信。边车会处理所有交叉的问题。您只需定义一次规则，这些规则就会自动注入到您的所有pod中。</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/4a448e0b5cdc1959c9455966732716c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1302/0*H6nN9HHU_eNdkYSZ"/></div></figure><h1 id="6d88" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">示例应用程序</h1><p id="0d1c" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">让我们把这个想法付诸实践。我们将构建一个示例应用程序来解释Istio的基本功能和结构。</p><p id="d418" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在<a class="ae kf" rel="noopener ugc nofollow" target="_blank" href="/stupid-simple-service-mesh-what-when-why-e9be9e5f4d41">之前的文章</a>中，我们使用envoy代理手工创建了一个服务网格。在本教程中，我们将使用相同的服务，但是我们将使用<strong class="ki iu"> Istio </strong>和<strong class="ki iu"> Kubernetes </strong>来配置我们的服务网格。</p><p id="efda" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下图描述了该应用程序架构。</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/c6643dec2996ee80a0a98e9ad041ab2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4nIesGGajB0CeB9o"/></div></div></figure><h1 id="f000" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">要求</h1><p id="3730" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">要学习本教程，您需要安装以下工具:</p><ol class=""><li id="6d67" class="mm mn it ki b kj kk kn ko kr mo kv mp kz mq ld mr ms mt mu bi translated"><a class="ae kf" href="https://kubernetes.io/docs/setup/" rel="noopener ugc nofollow" target="_blank"><strong class="ki iu">Kubernetes</strong></a><strong class="ki iu"/>(本教程中我们用的是1.21.3版本)</li><li id="3066" class="mm mn it ki b kj mv kn mw kr mx kv my kz mz ld mr ms mt mu bi translated"><a class="ae kf" href="https://helm.sh/docs/intro/install/" rel="noopener ugc nofollow" target="_blank"> <strong class="ki iu">掌舵</strong> </a>(我们用的是v2)</li><li id="aacb" class="mm mn it ki b kj mv kn mw kr mx kv my kz mz ld mr ms mt mu bi translated"><a class="ae kf" href="https://istio.io/latest/news/releases/1.1.x/announcing-1.1.17/" rel="noopener ugc nofollow" target="_blank"> <strong class="ki iu"> Istio </strong> </a>(我们用的是1 . 1 . 17)——<a class="ae kf" href="https://istio.io/latest/docs/setup/getting-started/" rel="noopener ugc nofollow" target="_blank">设置教程</a></li><li id="0003" class="mm mn it ki b kj mv kn mw kr mx kv my kz mz ld mr ms mt mu bi translated"><a class="ae kf" href="https://minikube.sigs.k8s.io/docs/start/" rel="noopener ugc nofollow" target="_blank"> <strong class="ki iu"> Minikube </strong> </a>，<a class="ae kf" href="https://k3s.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ki iu"> k3s </strong>，</a>或者在Docker中启用Kubernetes集群</li></ol><h1 id="3e40" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">Git储存库</h1><p id="cecd" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我在Kubernetes  资源库中的<a class="ae kf" href="https://github.com/CzakoZoltan08/StupidSimpleServiceMeshWithIstioAndKubernetes" rel="noopener ugc nofollow" target="_blank"> <strong class="ki iu">愚蠢的简单服务网格包含了本教程的所有脚本。基于这些脚本，您可以配置任何项目。</strong></a></p><h1 id="9f55" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">使用Istio和Kubernetes运行我们基于微服务的项目</h1><p id="0268" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">正如我上面提到的，第一步是配置Istio，将sidecars从一个名称空间注入到每个pod中。我们将使用默认的名称空间。这可以使用以下命令来完成:</p><pre class="mi mj mk ml gt na nb nc nd aw ne bi"><span id="52e5" class="nf lf it nb b gy ng nh l ni nj">kubectl label namespace default istio-injection=enabled</span></pre><p id="e5e2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在第二步中，我们从下载的存储库中导航到<em class="nk"> /kubernetes </em>文件夹，并为我们的服务应用配置文件:</p><pre class="mi mj mk ml gt na nb nc nd aw ne bi"><span id="94d3" class="nf lf it nb b gy ng nh l ni nj">kubectl apply -f service1.yaml<br/>kubectl apply -f service2.yaml<br/>kubectl apply -f service3.yaml</span></pre><p id="3664" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">完成这些步骤后，我们将启动并运行绿色部分:</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/8f7599c3d2fd3d223e14d46d1ea9a91c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gkY926UhVhtuqfD2"/></div></div></figure><p id="1ceb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">目前，我们无法从浏览器访问我们的服务。下一步，我们将配置<strong class="ki iu"> Istio入口和网关</strong>，这样<strong class="ki iu">允许来自外部的流量</strong>。</p><p id="d594" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">网关配置</strong>如下所示:</p><pre class="mi mj mk ml gt na nb nc nd aw ne bi"><span id="05e1" class="nf lf it nb b gy ng nh l ni nj">apiVersion: networking.istio.io/v1alpha3<br/>kind: Gateway<br/>metadata:  <br/>    name: http-gateway<br/>spec:<br/>    selector: <br/>        istio: ingressgateway<br/>    servers:<br/>        - port:<br/>            number: 80<br/>            name: http<br/>            protocol: HTTP<br/>        hosts:    - "*"</span></pre><p id="3562" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用选择器<em class="nk">istio:Ingres gateway</em>我们指定使用默认的入口网关控制器，它是在我们安装Istio时自动添加的。如您所见，网关允许端口80上的流量，但是它不知道将请求<strong class="ki iu">路由到哪里</strong>。为了定义路由，我们<strong class="ki iu">需要一个所谓的VirtualService </strong>，这是由Istio定义的另一个定制Kubernetes资源。</p><pre class="mi mj mk ml gt na nb nc nd aw ne bi"><span id="fbff" class="nf lf it nb b gy ng nh l ni nj">apiVersion: networking.istio.io/v1b<br/>kind: VirtualService<br/>metadata:<br/>    name: sssm-virtual-services<br/>spec:<br/>    hosts:  - "*"<br/>    gateways:  - http-gateway<br/>    http:  <br/>        - match:<br/>            - uri:<br/>                prefix: /service1<br/>            route:<br/>                - destination:<br/>                    host: service1<br/>                    port:<br/>                        number: 80<br/>        - match:<br/>            - uri:<br/>                prefix: /service2<br/>            route:<br/>                - destination:<br/>                    host: service2<br/>                    port:<br/>                        number: 80</span></pre><p id="74be" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的代码显示了VirtualService的配置示例。在第7行中，我们指定虚拟服务应用于来自名为http-gateway 的网关的<strong class="ki iu">请求，从第8行开始，我们定义了<strong class="ki iu">规则来匹配请求应该发送到的服务</strong>。每个带有/service1的请求将被路由到service1容器，而每个带有/service2的请求将被路由到service2容器。</strong></p><p id="c50f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这一步，我们有一个工作的应用程序，直到现在Istio没有什么特别的，相同的架构可以通过使用一个简单的Kubernetes入口控制器来获得，没有边车和网关配置的负担。</p><p id="d080" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在让我们看看使用Istion规则可以做些什么。</p><h2 id="c231" class="nf lf it bd lg nl nm dn lk nn no dp lo kr np nq ls kv nr ns lw kz nt nu ma nv bi translated">Istio的安全性</h2><p id="2c93" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">如果没有Istio，每个微服务都必须实现某种身份验证和授权。Istio <strong class="ki iu">将添加<strong class="ki iu">认证</strong>和<strong class="ki iu">授权</strong>的职责</strong>从主容器中移除(这样开发者可以专注于提供商业价值),而<strong class="ki iu">将这些职责转移到它的副容器</strong>中。sidecars可以配置为在每次调用时请求访问令牌，这样可以确保只有经过身份验证的请求才能到达我们的服务。</p><pre class="mi mj mk ml gt na nb nc nd aw ne bi"><span id="fd5f" class="nf lf it nb b gy ng nh l ni nj">apiVersion: authentication.istio.io/v1beta1<br/>kind: Policy<br/>metadata:<br/>    name: auth-policy<br/>spec:  <br/>    targets:  <br/>        - name: service1  <br/>        - name: service2  <br/>        - name: service3 <br/>        - name: service4  <br/>        - name: service5  <br/>    origins: <br/>    - jwt:      <br/>        issuer: "{YOUR_DOMAIN}"     <br/>        jwksUri: "{YOUR_JWT_URI}"  <br/>    principalBinding: USE_ORIGIN</span></pre><p id="d52f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">作为身份和访问管理服务器，您可以使用例如<a class="ae kf" href="https://auth0.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="ki iu"> Auth0 </strong> </a>、<a class="ae kf" href="https://www.okta.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="ki iu"> Okta </strong> </a>或其他<strong class="ki iu"> OAuth </strong>提供者。你可以在<a class="ae kf" href="https://medium.com/google-cloud/back-to-microservices-with-istio-part-2-authentication-authorization-b079f77358ac" rel="noopener"> <strong class="ki iu">这篇文章</strong> </a>中了解更多关于使用Auth0 with Istion进行认证和授权的信息。</p><h2 id="604b" class="nf lf it bd lg nl nm dn lk nn no dp lo kr np nq ls kv nr ns lw kz nt nu ma nv bi translated">使用目的地规则的流量管理</h2><p id="7e15" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">Istio的<a class="ae kf" href="https://istio.io/latest/docs/reference/config/networking/destination-rule/" rel="noopener ugc nofollow" target="_blank"> <strong class="ki iu">官方文档</strong> </a>称<strong class="ki iu"> DestinationRule </strong> <em class="nk">“定义了在路由发生后应用于某项服务的流量的策略”。</em>这意味着DestionationRule资源<strong class="ki iu">位于</strong>入口控制器和我们的服务之间的某处<strong class="ki iu">。使用DestinationRules，我们可以为<em class="nk">负载平衡</em>、<em class="nk">速率限制、</em>甚至<em class="nk">异常值检测</em>定义策略，以检测不健康的主机。</strong></p><p id="b76c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">遮蔽</strong></p><p id="e9c9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当您希望在不影响最终用户的情况下静默测试生产中的更改时，隐藏(也称为镜像)非常有用。发送到主服务的所有请求都被镜像(请求的副本)到您想要测试的辅助服务。</p><p id="4aaf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通过使用子集和定义镜像路由的虚拟服务来定义目的地规则，可以容易地实现隐藏。</p><p id="dce6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">目标规则将定义如下:</p><pre class="mi mj mk ml gt na nb nc nd aw ne bi"><span id="23c9" class="nf lf it nb b gy ng nh l ni nj">apiVersion: networking.istio.io/v1beta1<br/>kind: DestinationRule<br/>metadata:  <br/>    name: service2<br/>spec:  <br/>    host: service2<br/>    subsets:  <br/>    - name: v1     <br/>      labels:      <br/>          version: v1<br/>    - name: v2    <br/>      labels:      <br/>          version: v2</span></pre><p id="d816" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如我们在上面看到的，我们为两个版本定义了两个子集。</p><p id="6d6e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，我们用镜像配置来定义虚拟服务，如下面的脚本所示:</p><pre class="mi mj mk ml gt na nb nc nd aw ne bi"><span id="52c1" class="nf lf it nb b gy ng nh l ni nj">apiVersion: networking.istio.io/v1alpha3<br/>kind: VirtualService<br/>metadata:  <br/>    name: service2<br/>spec:  <br/>    hosts:    <br/>    - service2  <br/>    http:  <br/>    - route:    <br/>        - destination:        <br/>          host: service2<br/>          subset: v1           <br/>        mirror:      <br/>            host: service2<br/>            subset: v2</span></pre><p id="8d9e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在此虚拟服务中，我们为service2版本v1定义了主要目的地路由，镜像服务将是相同的服务，但带有v2版本标记。这样，最终用户将与v1服务进行交互，同时请求也将被发送到v2服务进行测试。</p><p id="6f03" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">流量分流</strong></p><p id="0e8b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">流量分流是一种用来测试你的新服务版本的技术，通过<strong class="ki iu">让一小部分(一个子集)用户与新服务互动</strong>。通过这种方式，如果新服务出现问题，只有一小部分最终用户会受到影响。</p><p id="74f4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这可以通过如下修改我们的虚拟服务来实现:</p><pre class="mi mj mk ml gt na nb nc nd aw ne bi"><span id="76c2" class="nf lf it nb b gy ng nh l ni nj">apiVersion: networking.istio.io/v1alpha3<br/>kind: VirtualService<br/>metadata:  <br/>    name: service2<br/>spec:  <br/>    hosts:    <br/>    - service2 <br/>    http:  <br/>    - route:    <br/>        - destination:        <br/>              host: service2        <br/>              subset: v1      <br/>         weight: 90           <br/>         - destination:        <br/>               host: service2<br/>               subset: v2      <br/>         weight: 10</span></pre><p id="2f55" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该脚本最重要的部分是<strong class="ki iu">权重</strong>标记，它定义了将到达特定服务实例的请求的百分比。在我们的例子中，90%的请求会发送到v1服务，而只有10%的请求会发送到v2服务。</p><p id="8f5e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">金丝雀部署</strong></p><p id="22a9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在canary部署中，较新版本的服务以增量方式向用户推出，以最小化较新版本引入的任何错误的风险和影响。</p><p id="9458" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这可以通过<strong class="ki iu">逐渐减少旧版本</strong>的重量，同时<strong class="ki iu">增加新版本</strong>的重量来实现。</p><p id="0c66" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu"> A/B测试</strong></p><p id="5da8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我们有两个或更多不同的用户界面，并且我们想测试哪一个提供更好的用户体验时，就使用这种技术。我们部署所有不同的版本，并收集有关用户交互的指标。A/B测试可以使用基于一致散列的负载平衡器或通过使用子集来配置。</p><p id="696e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在第一种方法中，我们定义了负载平衡器，如下所示:</p><pre class="mi mj mk ml gt na nb nc nd aw ne bi"><span id="89e1" class="nf lf it nb b gy ng nh l ni nj">apiVersion: networking.istio.io/v1alpha3<br/>kind: DestinationRule<br/>metadata:  <br/>    name: service2<br/>spec:  <br/>    host: service2<br/>    trafficPolicy:    <br/>        loadBalancer:      <br/>            consistentHash:        <br/>                httpHeaderName: version</span></pre><p id="cc86" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如您所见，一致性哈希基于版本标签，因此必须将该标签添加到我们名为“service2”的服务中，就像这样(在存储库中，您将找到两个文件，分别名为service2_v1和service2_v2，用于我们使用的两个不同版本):</p><pre class="mi mj mk ml gt na nb nc nd aw ne bi"><span id="05aa" class="nf lf it nb b gy ng nh l ni nj">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:  <br/>    name: service2-v2  <br/>    labels:    <br/>        app: service2<br/>spec:  <br/>    selector:    <br/>        matchLabels:      <br/>            app: service2  <br/>    strategy:    <br/>        type: Recreate  <br/>    template:    <br/>        metadata:     <br/>            labels:        <br/>                app: service2        <br/>                version: v2    <br/>        spec:      <br/>            containers:      <br/>            - image: zoliczako/sssm-service2:1.0.0        <br/>              imagePullPolicy: Always        <br/>              name: service2        <br/>              ports:          <br/>              - containerPort: 5002        <br/>              resources:          <br/>                  limits:            <br/>                      memory: "256Mi"            <br/>                      cpu: "500m"</span></pre><p id="3ef8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">需要注意的最重要的部分是规范-&gt;模板-&gt;元数据-&gt;版本:v2。另一个服务具有版本:v1标记。</p><p id="2989" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一种方案是基于<a class="ae kf" href="https://istio.io/latest/docs/reference/config/networking/destination-rule/" rel="noopener ugc nofollow" target="_blank"> <strong class="ki iu">子集</strong> </a>。</p><p id="5ce3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">重试管理</strong></p><p id="12d8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用Istio，我们可以很容易地定义如果初始尝试失败(例如，在服务过载或网络错误的情况下)连接到服务的最大尝试次数。</p><p id="d694" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">可以通过在我们的虚拟服务末尾添加以下行来定义重试策略:</p><pre class="mi mj mk ml gt na nb nc nd aw ne bi"><span id="555e" class="nf lf it nb b gy ng nh l ni nj">retries:  <br/>    attempts: 5<br/>    perTryTimeout: 10s</span></pre><p id="8726" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用这种配置，我们的service2在失败的情况下将有五次重试尝试，它将等待10秒钟，然后返回超时。</p><p id="fb79" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在<a class="ae kf" href="https://medium.com/google-cloud/back-to-microservices-with-istio-p1-827c872daa53" rel="noopener"> <strong class="ki iu">本文</strong> </a>了解更多交通管理知识。在这里 你会发现一个使用Istio <a class="ae kf" href="https://www.istioworkshop.io/01-workshop-overview/" rel="noopener ugc nofollow" target="_blank"> <strong class="ki iu">配置端到端服务网格的好地方。</strong></a></p><h1 id="41f2" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="f6d4" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">在本文中，我们学习了如何使用Istio 在Kubernetes中<strong class="ki iu">设置</strong>和<strong class="ki iu">配置</strong>一个<strong class="ki iu">服务网格。首先，我们配置了一个<strong class="ki iu">入口控制器</strong>和<strong class="ki iu">网关</strong>，并使用<strong class="ki iu">目的地规则</strong>和<strong class="ki iu">虚拟服务</strong>了解了<strong class="ki iu">流量管理</strong>。</strong></p><p id="40a8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">还有一个正在进行的<strong class="ki iu">《愚蠢的简单AI》</strong>系列。前两篇可以在这里找到:<a class="ae kf" href="https://towardsdatascience.com/svm-and-kernel-svm-fed02bef1200" rel="noopener" target="_blank"> <strong class="ki iu"> SVM和内核SVM </strong> </a>和<a class="ae kf" href="https://towardsdatascience.com/knn-in-python-835643e2fb53" rel="noopener" target="_blank"> <strong class="ki iu"> KNN在Python </strong> </a>。</p><p id="5987" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">感谢您阅读本文！</strong></p></div><div class="ab cl nw nx hx ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="im in io ip iq"><p id="d236" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">成为媒介上的作家:</strong><a class="ae kf" href="https://czakozoltan08.medium.com/membership" rel="noopener">https://czakozoltan08.medium.com/membership</a></p></div><div class="ab cl nw nx hx ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="im in io ip iq"><p id="bbae" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我真的很喜欢咖啡，因为它给了我写更多文章的能量。如果你喜欢这篇文章，那么你可以给我买杯咖啡来表达你的欣赏和支持！</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><a href="https://ko-fi.com/zozoczako"><div class="gh gi od"><img src="../Images/0f03dd542bf76f1125912312a7c936ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*bFjnvelnpwuYa4vfPMGkhA@2x.png"/></div></a></figure></div></div>    
</body>
</html>