<html>
<head>
<title>Everything You Always Wanted To Know About Web Components (But Were Afraid To Ask)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你一直想知道的关于Web组件的一切(但是不敢问)</h1>
<blockquote>原文：<a href="https://itnext.io/everything-you-always-wanted-to-know-about-web-components-but-were-afraid-to-ask-d553a504a328?source=collection_archive---------2-----------------------#2022-07-21">https://itnext.io/everything-you-always-wanted-to-know-about-web-components-but-were-afraid-to-ask-d553a504a328?source=collection_archive---------2-----------------------#2022-07-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="4efb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以下是你需要知道的</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/ed10e8683cd30443285c6a509af95bae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eJYQx4UsFpQPUn4-al0XQg.png"/></div></div></figure><p id="6ddc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你对Web组件了解多少？关于Web组件，你想知道什么？</p><p id="51d5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以下是我经常被问到的最常见问题的答案。</p><h1 id="fc5a" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">Web组件没有JavaScript能工作吗？</h1><p id="712e" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">是的，通过<a class="ae md" href="https://web.dev/declarative-shadow-dom/" rel="noopener ugc nofollow" target="_blank">声明式阴影DOM </a>可以不用JavaScript渲染Web组件。</p><p id="92b0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通常，影子根通过JavaScript附加到Web组件(技术上是一个自定义元素):</p><pre class="kp kq kr ks gt me mf mg mh aw mi bi"><span id="6832" class="mj lb it mf b gy mk ml l mm mn">const shadowRoot = this.attachShadow({mode: 'open'});</span><span id="9c1e" class="mj lb it mf b gy mo ml l mm mn">this.shadowRoot.innerHTML = `&lt;p&gt;Hi there!&lt;/p&gt;`;</span></pre><p id="0705" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果没有JavaScript，你就不能这样创建一个影子根。</p><p id="f319" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是声明式影子DOM使您能够在HTML中直接声明式地定义影子根:</p><pre class="kp kq kr ks gt me mf mg mh aw mi bi"><span id="4c4e" class="mj lb it mf b gy mk ml l mm mn">&lt;host-element&gt;<br/>  &lt;template shadowroot="open"&gt;<br/>    &lt;slot&gt;&lt;/slot&gt;<br/>  &lt;/template&gt;<br/>  &lt;h2&gt;Light content&lt;/h2&gt;<br/>&lt;/host-element&gt;</span></pre><p id="e929" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当HTML解析器遇到这个HTML时，它会立即应用属性为<code class="fe mp mq mr mf b">shadowroot="open"</code>的<code class="fe mp mq mr mf b">&lt;template&gt;</code>元素作为<code class="fe mp mq mr mf b">&lt;host-element&gt;</code>的影子根，产生以下HTML，不需要任何JavaScript:</p><pre class="kp kq kr ks gt me mf mg mh aw mi bi"><span id="ead0" class="mj lb it mf b gy mk ml l mm mn">&lt;host-element&gt;<br/>  #shadow-root (open)<br/>  &lt;slot&gt;<br/>    ↳<br/>    &lt;h2&gt;Light content&lt;/h2&gt;<br/>  &lt;/slot&gt;<br/>&lt;/host-element&gt;</span></pre><p id="efad" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因为这不需要JavaScript，所以声明性Shadow DOM可以用于服务器端呈现Web组件。</p><p id="154b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，不要担心，从现在开始，您将需要用这种语法编写所有的Web组件。这有点违背了影子DOM带来的封装的目的。</p><p id="73fb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当服务器端呈现HTML页面时，您可以使用新的<code class="fe mp mq mr mf b">getInnerHTML</code>方法简单地获得元素的声明性阴影根:</p><pre class="kp kq kr ks gt me mf mg mh aw mi bi"><span id="4824" class="mj lb it mf b gy mk ml l mm mn">const el = document.querySelector('host-element');<br/>const html = el.getInnerHTML({includeShadowRoots: true});</span><span id="6c17" class="mj lb it mf b gy mo ml l mm mn">// html is now:<br/>`&lt;host-element&gt;<br/>  &lt;template shadowroot="open"&gt;&lt;slot&gt;&lt;/slot&gt;&lt;/template&gt;<br/>  &lt;h2&gt;Light content&lt;/h2&gt;<br/>&lt;/host-element&gt;`</span></pre><p id="2fed" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mp mq mr mf b">getInnerHTML</code>的工作方式和<code class="fe mp mq mr mf b">innerHTML</code>一样，但是你可以将<code class="fe mp mq mr mf b">{includeShadowRoots: true}</code>作为参数传递，它也将返回元素的阴影DOM。</p><p id="b4ee" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在写作的时候，你可以在Chrome中省略这个参数，默认情况下它会返回影子根。</p><p id="ac30" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在服务器端脚本中，你可以简单地用这个<code class="fe mp mq mr mf b">html</code>替换<code class="fe mp mq mr mf b">&lt;host-element&gt;</code>的内容，你的元素的影子根现在不用JavaScript就可以呈现了。</p><p id="3cf0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">请记住，声明式阴影DOM只负责在没有JavaScript的情况下呈现Web组件。</p><p id="73b0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">用于点击等交互。您仍然需要JavaScript，但这适用于任何组件。</p><p id="64dc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在撰写本文时，声明式阴影DOM仅在Chrome、Edge和Opera中受支持。</p><h1 id="b8aa" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">React支持Web组件吗？</h1><p id="38e6" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">您可以在任何JavaScript框架中使用Web组件，React也支持这一点，但是您可能需要为您的Web组件编写一个包装器。</p><p id="ea1b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在所有JS框架中，React不是最容易集成Web组件的。</p><div class="mt mu gp gr mv mw"><a href="https://reactjs.org/docs/web-components.html" rel="noopener  ugc nofollow" target="_blank"><div class="mx ab fo"><div class="my ab mz cl cj na"><h2 class="bd iu gy z fp nb fr fs nc fu fw is bi translated">Web组件-反应</h2><div class="nd l"><h3 class="bd b gy z fp nb fr fs nc fu fw dk translated">React和Web组件是为了解决不同的问题而构建的。Web组件为…提供了强大的封装</h3></div><div class="ne l"><p class="bd b dl z fp nb fr fs nc fu fw dk translated">reactjs.org</p></div></div><div class="nf l"><div class="ng l nh ni nj nf nk ky mw"/></div></div></a></div><h1 id="5b56" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">为什么你会选择Web组件而不是框架？</h1><p id="3163" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">就像我写的，你可以在任何框架中使用Web组件，这样你就不用选择了。</p><p id="34c0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是Web组件的好处是它们是标准的，可以在任何地方使用(它们只是HTML元素),并且提供真正有作用域的CSS。</p><h1 id="c525" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">什么是作用域CSS？</h1><p id="83b0" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">您在Web组件中定义的CSS仅适用于您的组件<em class="ms"/>。</p><p id="674f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它不会影响Web组件之外的任何元素，外部文档的CSS也不会应用于您的组件，除了一些标准样式。</p><p id="8639" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这意味着Web组件提供了真正有作用域的CSS，而不需要任何命名约定。</p><h1 id="f211" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">Web组件如何与可访问性一起工作？</h1><p id="d77f" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">Web组件的美妙之处在于它们只是普通的HTML元素，就像本地元素一样，如<code class="fe mp mq mr mf b">&lt;p&gt;</code>、<code class="fe mp mq mr mf b">&lt;div&gt;</code>、<code class="fe mp mq mr mf b">&lt;h1&gt;</code>等。</p><p id="8c3b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这意味着使Web组件可访问与使其他HTML元素可访问没有什么不同。</p><p id="b866" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可以添加aria标签、键盘和焦点处理程序等。</p><h1 id="728c" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">我可以使用外部CSS吗？</h1><p id="4807" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">是的，你可以。</p><p id="0295" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">虽然有更好的方法来设计Web组件的样式，但是您可以使用<code class="fe mp mq mr mf b">&lt;link rel="stylesheet"&gt;</code>将样式表加载到Web组件中:</p><pre class="kp kq kr ks gt me mf mg mh aw mi bi"><span id="76c1" class="mj lb it mf b gy mk ml l mm mn">class HostElement extends <strong class="mf iu"><em class="ms">HTMLElement </em></strong>{<br/><br/>  constructor() {<br/>    super();<br/><br/>    const shadowRoot = this.attachShadow({mode: 'open'});<br/><br/>    shadowRoot.innerHTML = `<br/>      &lt;link rel="stylesheet" href="/path/to/external.css"&gt;</span><span id="9f8b" class="mj lb it mf b gy mo ml l mm mn">      &lt;slot&gt;&lt;/slot&gt;<br/><br/>    `;<br/>  }</span><span id="ecdd" class="mj lb it mf b gy mo ml l mm mn">}</span></pre><p id="868c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">另一个更有趣的选择是使用可构造的样式表，这使得定义和准备共享的CSS样式成为可能，然后将这些样式应用于多个影子根。</p><p id="7c5b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这使您能够将共享CSS放在如下文件中:</p><pre class="kp kq kr ks gt me mf mg mh aw mi bi"><span id="9981" class="mj lb it mf b gy mk ml l mm mn">// shared-css.js</span><span id="513a" class="mj lb it mf b gy mo ml l mm mn">const css = `h1 {<br/>  color: red;<br/>}`<br/><br/>const sheet<strong class="mf iu"><em class="ms"> </em></strong>= new CSSStyleSheet();<br/><strong class="mf iu"><em class="ms">sheet.replaceSync</em></strong>(css);<br/><br/>export {<br/>  sheet<strong class="mf iu"><em class="ms"><br/></em></strong>}</span></pre><p id="ee17" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后您可以在多个Web组件中使用它，如下所示:</p><pre class="kp kq kr ks gt me mf mg mh aw mi bi"><span id="17aa" class="mj lb it mf b gy mk ml l mm mn">import {sheet} from './shared-css.js';<br/><br/>class HostElement extends <strong class="mf iu"><em class="ms">HTMLElement </em></strong>{</span><span id="22c0" class="mj lb it mf b gy mo ml l mm mn">  constructor() {<br/>    super();<br/><br/>    const shadowRoot = this.attachShadow({mode: 'open'});<br/>    shadowRoot.adoptedStyleSheets = [sheet];<br/><br/>    shadowRoot.innerHTML = `<br/>      &lt;h1&gt;Hi there!&lt;/h1&gt;<br/>    `;<br/>  }<br/>}</span></pre><div class="mt mu gp gr mv mw"><a href="https://web.dev/constructable-stylesheets/" rel="noopener  ugc nofollow" target="_blank"><div class="mx ab fo"><div class="my ab mz cl cj na"><h2 class="bd iu gy z fp nb fr fs nc fu fw is bi translated">可构造的样式表</h2><div class="nd l"><h3 class="bd b gy z fp nb fr fs nc fu fw dk translated">可构造的样式表提供了一种无缝的方式来创建样式并将其分发到文档或影子根，而无需…</h3></div><div class="ne l"><p class="bd b dl z fp nb fr fs nc fu fw dk translated">网络开发</p></div></div><div class="nf l"><div class="nl l nh ni nj nf nk ky mw"/></div></div></a></div><h1 id="0706" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">我可以在Web组件中使用SASS吗？</h1><p id="ed49" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">你也许可以，但是你可能只需要变量，因为Shadow DOM可以极大地简化你的CSS，并且变量已经可以通过<a class="ae md" href="https://developer.mozilla.org/en-US/docs/Web/CSS/Using_CSS_custom_properties" rel="noopener ugc nofollow" target="_blank"> CSS自定义属性</a>获得。</p><p id="53b1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，虽然您可以使用SASS，但您可能不需要它。</p><h1 id="045b" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">使用Web组件需要第三方库吗？</h1><p id="0209" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">不，你不知道。</p><p id="ef29" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在所有浏览器都支持Web组件。一些实验特征可能需要聚合填充，但核心特征现在随处可用。</p><p id="975f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">请记住，Web组件就像普通的HTML元素一样，浏览器也会这样对待它。</p><h1 id="0092" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">Web组件可以服务器端渲染吗？</h1><p id="a634" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">是的，他们可以用<a class="ae md" href="https://web.dev/declarative-shadow-dom/" rel="noopener ugc nofollow" target="_blank">声明性阴影DOM </a>。见第一个问题。</p><h1 id="5e93" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">最重要的优点是什么？</h1><p id="5146" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">Web组件只是标准的HTML元素，可以在任何地方使用，并且可以集成到任何框架中。</p><p id="dea5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您不需要任何第三方代码来呈现和使用Web组件。因为它们只是普通的HTML元素，浏览器已经知道如何有效地处理它们。</p><p id="0930" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">虽然框架来来去去，但Web组件是一种标准，不太可能被废弃。</p><p id="30d6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">另一个非常重要的优点是，你可以完全封装你的组件的HTML和CSS，这样你就真正地限定了CSS的范围。</p><p id="efb0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这使你能够<em class="ms">极大地</em>简化你的组件的CSS，因为它是真正有作用域的，不需要约定。</p><h1 id="1c71" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">最重要的缺点是什么？</h1><p id="3544" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">Web组件不像框架那样提供现成的特性，如数据绑定和声明性模板(尽管实现这些并不难)。</p><h1 id="4f71" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">OMG，Web组件不是反应式的？？？</h1><p id="4ea6" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">Web组件不像大多数框架那样提供现成的特性，比如反应性和声明性模板。</p><p id="b88b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是实现这些并不难:</p><div class="mt mu gp gr mv mw"><a href="https://medium.com/swlh/https-medium-com-drmoerkerke-data-binding-for-web-components-in-just-a-few-lines-of-code-33f0a46943b3" rel="noopener follow" target="_blank"><div class="mx ab fo"><div class="my ab mz cl cj na"><h2 class="bd iu gy z fp nb fr fs nc fu fw is bi translated">仅用几行代码实现Web组件的数据绑定</h2><div class="nd l"><h3 class="bd b gy z fp nb fr fs nc fu fw dk translated">这不是火箭科学，而且虚拟DOM通常都是多余的。</h3></div><div class="ne l"><p class="bd b dl z fp nb fr fs nc fu fw dk translated">medium.com</p></div></div><div class="nf l"><div class="nm l nh ni nj nf nk ky mw"/></div></div></a></div><p id="0e66" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可以使用像setter这样简单的东西来实现数据绑定。</p><p id="1cbf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里有一个故意简化的例子:</p><pre class="kp kq kr ks gt me mf mg mh aw mi bi"><span id="3c78" class="mj lb it mf b gy mk ml l mm mn">class HostElement extends <strong class="mf iu"><em class="ms">HTMLElement </em></strong>{<br/>  constructor() {<br/>    super();<br/><br/>    const shadowRoot = this.attachShadow({mode: 'open'});<br/><br/>    this._name = 'John';<br/><br/>    shadowRoot.innerHTML = `<br/>      &lt;h1&gt;<br/>        Hi &lt;span data-bind="name"&gt;${this._name}&lt;/span&gt;<br/>      &lt;/h1&gt;<br/>    `;<br/>  }<br/><br/>  set name(value) {<br/>    this._name = value;<br/>    this.shadowRoot<br/>      .querySelectorAll('[data-bind="name"]')<br/>      .forEach((element) =&gt; element.textContent = value);<br/>  }<br/><br/>  get name() {<br/>    return this._name;<br/>  }<br/>}</span></pre><p id="df08" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里，绑定到属性的元素有一个<code class="fe mp mq mr mf b">data-bind</code>属性，其内容是属性的名称。</p><p id="9c2d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在setter中，查找所有相应的元素，并将它们的<code class="fe mp mq mr mf b">textContent</code>属性设置为新值。</p><p id="029e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当然，如果你有很多绑定属性，这很快就会变得混乱，所以在这种情况下，使用像<a class="ae md" href="https://lit.dev/" rel="noopener ugc nofollow" target="_blank"> lit </a>或<a class="ae md" href="https://stenciljs.com/" rel="noopener ugc nofollow" target="_blank"> StencilJS </a>这样的工具可能会更好，但是我希望你明白这个想法。</p><h1 id="0c2e" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">可以用11ty把Web组件编译成HTML吗？</h1><p id="48b6" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">Web组件<em class="ms">是</em> HTML <em class="ms"> </em>所以没有什么要编译成HTML。</p><p id="94c1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">已经是HTML了。</p><p id="626b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Web组件只是可以在任何HTML页面中使用的自定义HTML元素。</p><h1 id="9b45" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">使用影子DOM总是明智的吗？</h1><p id="f392" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">这确实取决于您的用例，但通常Shadow DOM将是一个很好的选择，因为根据定义，Web组件是一个自包含的单元，它将受益于HTML和CSS的封装。</p><p id="258f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是如果你不需要它，你可以创建一个不使用影子DOM的Web组件</p><h1 id="ba22" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">你的问题是什么？</h1><p id="584e" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">我希望这篇文章已经回答了你关于Web组件的一些问题。</p><p id="14ba" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您有任何其他问题，请在这里发表评论或在Twitter(<a class="ae md" href="https://twitter.com/dannymoerkerke" rel="noopener ugc nofollow" target="_blank">@ dannymoerkerke</a>)上给我发消息，在那里您可以关注我以获得更多关于web组件和现代Web的文章。</p></div></div>    
</body>
</html>