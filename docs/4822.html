<html>
<head>
<title>Java RMI for pentesters: structure, recon and communication (non-JMX Registries).</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">pentesters的Java RMI:结构、侦察和通信(非JMX注册中心)。</h1>
<blockquote>原文：<a href="https://itnext.io/java-rmi-for-pentesters-structure-recon-and-communication-non-jmx-registries-a10d5c996a79?source=collection_archive---------1-----------------------#2020-09-27">https://itnext.io/java-rmi-for-pentesters-structure-recon-and-communication-non-jmx-registries-a10d5c996a79?source=collection_archive---------1-----------------------#2020-09-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="6903" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本文的目的是向您解释，在基础设施的渗透测试中，您可能会遇到哪些RMI接口。由于我想谈论的整个话题有点长，我把它分成了两部分。在接下来的部分中，我将简单解释什么是RMI接口，如何创建一个用于测试的接口，以及如何手动构建一个RMI客户机来调用远程方法。攻击部分会在本帖第二部分描述，可以在这里找到<a class="ae kl" href="https://medium.com/@afinepl/java-rmi-for-pentesters-part-two-reconnaissance-attack-against-non-jmx-registries-187a6561314d" rel="noopener">。</a></p><p id="c881" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">另外，这些文章是关于本地RMI注册中心的。还有一些流行的JMXRMI注册中心，它们有些不同。我计划发布一篇关于JMX的独立文章，其中将涉及JMXRMI以及其他与<strong class="jp ir"> J </strong> ava <strong class="jp ir"> M </strong>管理e <strong class="jp ir"> X </strong>张力互动的方式。简而言之，我在这里要描述的是:</p><ul class=""><li id="50e5" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk kr ks kt ku bi translated">什么是RMI接口</li><li id="62fb" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">如何从源代码构建一个RMI接口(包括代码)</li><li id="3a1a" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">使用Nmap扫描可以获得关于RMI接口的哪些信息</li><li id="d978" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">如何构建一个RMI客户机(以及构建一个客户机需要知道什么)</li><li id="fea7" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">在处理RMI时，典型的问题/堆栈跟踪是什么？原因可能是什么</li></ul><h1 id="4a5d" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">什么是Java RMI</h1><p id="4e80" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">Java RMI服务器是一个暴露在网络上的虚拟实体，它允许其他远程方(客户端)在运行它的系统(技术上是在该系统上运行的JVM)上执行方法。这在编程世界中并不罕见——类似的概念如<a class="ae kl" href="https://docs.microsoft.com/en-us/windows/win32/rpc/how-rpc-works" rel="noopener ugc nofollow" target="_blank">远程过程调用(RPC) </a>被广泛使用。</p><p id="9c8e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，通过在系统上运行一个公开的RMI服务器，可以允许外部参与者与它进行交互，并可能在RMI服务器上执行方法。这些方法应该在服务器实现中定义。一旦它们被客户端调用，它们将在服务器上执行，返回值将返回给客户端。另一个有趣的部分是，除了使用SSL加密连接之外，原生RMI(同样，我不是在谈论JMXRMI)不支持太多的安全性。[1]</p><p id="bfbb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">RMI接口的架构如下所示:</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div class="gh gi md"><img src="../Images/18433634ff36e8551b0a8d740f995436.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/0*LhshPPfUYAe439Zl"/></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated"><a class="ae kl" href="https://www.assignmentpoint.com/wp-content/uploads/2020/07/Remote-Method-Invocation.jpg" rel="noopener ugc nofollow" target="_blank">https://www . assignment point . com/WP-content/uploads/2020/07/Remote-Method-invocation . jpg</a></figcaption></figure><p id="21c8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">“stub”和“skeleton”这两个名称乍一看可能会令人困惑，但这就是远程对象的“客户机”和“服务器”部分的简单叫法。</p><p id="616d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Stub是一个实现远程接口的类，充当远程对象的客户端占位符。另一方面，Skeleton是一个服务器端实体，它将调用分派给远程对象的实际实现。</p><p id="b0db" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">RMI注册表本身是一个Java实用程序，可以在JDK的二进制文件中以“RMI registry”的名称找到。启动带有一个数字参数的二进制文件，该参数是要监听的端口(默认为1099)，这将允许<a class="ae kl" href="https://docs.oracle.com/javase/7/docs/api/java/rmi/registry/Registry.html#bind(java.lang.String,%20java.rmi.Remote)" rel="noopener ugc nofollow" target="_blank">将<a class="ae kl" href="https://docs.oracle.com/javase/jndi/tutorial/objects/storing/remote.html#:~:text=The%20RMI%20(Java%20Remote%20Method,rmi." rel="noopener ugc nofollow" target="_blank">远程对象</a>绑定到</a>上。稍后可以从运行rmi registry的机器外部的网络访问这些远程对象。</p><p id="77f5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">简而言之:我们首先启动RMI注册中心，然后创建一个Java对象(Java类，它有一些要被远程方调用的方法),并给它一个名称(绑定),在这个名称下可以在注册中心内找到它。</p><p id="712d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了允许远程方执行某些方法，RMI注册表必须至少包含两个程序组件:</p><ul class=""><li id="ea2e" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk kr ks kt ku bi translated">一个接口，它定义了哪些方法可以在远程对象上调用</li><li id="2d84" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">绑定和导出远程对象的代码(将在该对象上调用远程方法)</li><li id="62d5" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">远程方法的实现</li></ul><h1 id="0ae7" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">构建RMI客户端和服务器</h1><p id="05d2" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">让我们用一个RMI服务器和客户机的简单例子。首先，服务器逻辑将有两个独立的类。你也可以在我的GitHub库<a class="ae kl" href="https://github.com/0xluk3/simple-rmi" rel="noopener ugc nofollow" target="_blank">这里</a>找到那篇文章的完整代码。</p><pre class="me mf mg mh gt mp mq mr ms aw mt bi"><span id="9817" class="mu lb iq mq b gy mv mw l mx my"><strong class="mq ir">//RMIInterface.java</strong></span><span id="cfbe" class="mu lb iq mq b gy mz mw l mx my">import java.rmi.*;</span><span id="6ce2" class="mu lb iq mq b gy mz mw l mx my">import java.rmi.registry.*;</span><span id="c7fe" class="mu lb iq mq b gy mz mw l mx my">import java.net.*;</span><span id="7baa" class="mu lb iq mq b gy mz mw l mx my">interface RMIInterface extends Remote {</span><span id="445c" class="mu lb iq mq b gy mz mw l mx my">    public String echo(Object obj) throws RemoteException;</span><span id="d92a" class="mu lb iq mq b gy mz mw l mx my">}</span><span id="d35d" class="mu lb iq mq b gy mz mw l mx my"><strong class="mq ir">//Server.java</strong></span><span id="e1b1" class="mu lb iq mq b gy mz mw l mx my">import java.rmi.registry.Registry;</span><span id="5f49" class="mu lb iq mq b gy mz mw l mx my">import java.rmi.registry.LocateRegistry;</span><span id="a29a" class="mu lb iq mq b gy mz mw l mx my">import java.rmi.RemoteException;</span><span id="b898" class="mu lb iq mq b gy mz mw l mx my">import java.rmi.server.UnicastRemoteObject;</span><span id="53a5" class="mu lb iq mq b gy mz mw l mx my">import java.rmi.Naming;</span><span id="aca7" class="mu lb iq mq b gy mz mw l mx my">public class Server extends UnicastRemoteObject implements RMIInterface {</span><span id="b5ad" class="mu lb iq mq b gy mz mw l mx my">public String echo(Object input) throws RemoteException {</span><span id="d053" class="mu lb iq mq b gy mz mw l mx my">    return “Echoing: “ + input.toString();</span><span id="f738" class="mu lb iq mq b gy mz mw l mx my">}</span><span id="8449" class="mu lb iq mq b gy mz mw l mx my">protected Server() throws RemoteException {</span><span id="d33d" class="mu lb iq mq b gy mz mw l mx my">    super();</span><span id="4931" class="mu lb iq mq b gy mz mw l mx my">}</span><span id="a768" class="mu lb iq mq b gy mz mw l mx my">public static void main(String[] args) {</span><span id="b6bb" class="mu lb iq mq b gy mz mw l mx my">    try {</span><span id="09b6" class="mu lb iq mq b gy mz mw l mx my">      System.out.println(“[+] Trying to bind…”);</span><span id="64a6" class="mu lb iq mq b gy mz mw l mx my">      //Below IP:PORT can be changed</span><span id="dbfa" class="mu lb iq mq b gy mz mw l mx my">      Naming.rebind(“rmi://127.0.0.1:11099/RMIInterface”, new Server());</span><span id="2676" class="mu lb iq mq b gy mz mw l mx my">      System.out.println(“[+] Server started.”);</span><span id="b087" class="mu lb iq mq b gy mz mw l mx my">    } catch (Exception e) {</span><span id="8f33" class="mu lb iq mq b gy mz mw l mx my">      e.printStackTrace();</span><span id="5b58" class="mu lb iq mq b gy mz mw l mx my">    }</span><span id="3b50" class="mu lb iq mq b gy mz mw l mx my">}</span><span id="b5d7" class="mu lb iq mq b gy mz mw l mx my">}</span></pre><p id="6ec4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这两个文件应该存储在同一个文件夹中。现在，编译它们并运行rmiregistry。请注意，您应该从这些文件所在的目录运行RMIRegistry(因此您当前的工作目录应该保持不变，然后运行rmiregistry二进制文件)</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi na"><img src="../Images/df9079a990fe4e0950e525ccacb991ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HElmx1QGsKFk9wYJ"/></div></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">编译后运行上面的代码</figcaption></figure><h1 id="1acb" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">使用Nmap侦察RMI接口</h1><p id="2992" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">此时，我们可以使用nmap扫描本地主机接口，其中rmi注册表及其所有绑定都是可见的:</p><p id="467c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="nf">nmap-sV-p 11099-T4-本地主机</em></p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi ng"><img src="../Images/961dba549d6232a3ee9e6d1c7f99fde9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dLgnCas6fmJPDnVF"/></div></div></figure><p id="2e44" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上面的清单是名为<a class="ae kl" href="https://nmap.org/nsedoc/scripts/rmi-dumpregistry.html" rel="noopener ugc nofollow" target="_blank"> rmi-dumpregistry </a>的nmap脚本的结果。它告诉我们:</p><ul class=""><li id="4681" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk kr ks kt ku bi translated">注册表在端口11099上运行</li><li id="57c0" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">它使用(实现)RMIInterface，这是一个自定义类，我们不知道它在纯黑盒视角下的结构(但是我们在创建它时是如何知道它的)</li><li id="a38b" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">invocationHandler在端口34087上运行。简言之，Invocationhandler是负责执行远程调用方法的端点。</li></ul><p id="a7d0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下图显示了与RMI注册表交互的顺序:</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div class="gh gi md"><img src="../Images/224f159d62fa26d72d233e7b8c32732c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/0*qu96CRk57lHt_TV0"/></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated"><a class="ae kl" href="https://static1.makeuseofimages.com/wp-content/uploads/2017/10/how-rmi-works-500x500.png" rel="noopener ugc nofollow" target="_blank">https://static 1 . makeuseofimages . com/WP-content/uploads/2017/10/how-RMI-works-500 x500 . png</a></figcaption></figure><h1 id="100a" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">创建RMI客户端</h1><p id="f1c9" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">为了获得完整的图片，让我们实现客户端代码。Client.java与Server和RMIInterface放在同一个目录中。</p><pre class="me mf mg mh gt mp mq mr ms aw mt bi"><span id="3ff9" class="mu lb iq mq b gy mv mw l mx my"><strong class="mq ir">//Client.java</strong></span><span id="127c" class="mu lb iq mq b gy mz mw l mx my">import java.net.MalformedURLException;</span><span id="ec08" class="mu lb iq mq b gy mz mw l mx my">import java.rmi.Naming;</span><span id="70b7" class="mu lb iq mq b gy mz mw l mx my">import java.rmi.NotBoundException;</span><span id="6590" class="mu lb iq mq b gy mz mw l mx my">import java.rmi.RemoteException;</span><span id="dac7" class="mu lb iq mq b gy mz mw l mx my">public class Client implements RMIInterface {</span><span id="0bed" class="mu lb iq mq b gy mz mw l mx my">public String echo(Object input) throws RemoteException {</span><span id="1ad4" class="mu lb iq mq b gy mz mw l mx my">    return “Echoing: “ + input.toString();</span><span id="b85b" class="mu lb iq mq b gy mz mw l mx my">}</span><span id="7059" class="mu lb iq mq b gy mz mw l mx my">private static RMIInterface look_up;</span><span id="5188" class="mu lb iq mq b gy mz mw l mx my">public static void main(String[] args)</span><span id="3a23" class="mu lb iq mq b gy mz mw l mx my">throws MalformedURLException, RemoteException, NotBoundException {</span><span id="705f" class="mu lb iq mq b gy mz mw l mx my">    look_up = (RMIInterface)      Naming.lookup(“rmi://127.0.0.1:11099/RMIInterface”);</span><span id="72ca" class="mu lb iq mq b gy mz mw l mx my">    System.out.println(“Calling Echo… “);</span><span id="27a9" class="mu lb iq mq b gy mz mw l mx my">    try {</span><span id="96d4" class="mu lb iq mq b gy mz mw l mx my">      String response = look_up.echo(“Let’s use a string here. “);</span><span id="145e" class="mu lb iq mq b gy mz mw l mx my">      System.out.println(response);</span><span id="946c" class="mu lb iq mq b gy mz mw l mx my">} catch (Exception e) {}</span><span id="a557" class="mu lb iq mq b gy mz mw l mx my">}<br/>}</span></pre><p id="d895" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，Client.java实现了服务器端使用的接口，在当前情况下，我们提供了与服务器端相同的函数echo实现。</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi nh"><img src="../Images/a1f2329e84ddf86d4a7f9be5829e21d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QhWrQCsHY2pVMpEo"/></div></div></figure><p id="88fd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">编译后，您可以看到客户端可以被调用。如果您在运行客户端时查看wireshark，您可以确认上面的图形流，因为观察到了到RMI Registry的第一个连接，之后是到InvocationHandler的第二个连接。</p><p id="d7de" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">开始时，客户端只与注册端口11099通信</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi ni"><img src="../Images/eab5e646fbdfe9304c8cdc99cec8ec00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fqVwTgyJ_N4qaGNB"/></div></div></figure><p id="e553" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">稍后，它被指示再次与将服务于方法执行的InvocationHandler对话:</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi nj"><img src="../Images/dedbdf91202c59c88a0b618672933318.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*z7IaDUvLprDR56BM"/></div></div></figure><p id="0f57" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以观察到从该端点返回的echo方法的结果。</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi nk"><img src="../Images/553b71bc9cb77a93fbbb4c7ff41af1e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*huOS80BE_EW9frgv"/></div></div></figure><p id="fd2b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">还有，值得一提的是，我们可以看到数据是以序列化的形式交换的，这可以通过查看序列化的“神奇字节”0xaced0005来说。这将在关于攻击RMI注册中心的文章的第二部分中进一步讨论(剧透:现代Java版本已经减轻了这种攻击:( )</p><p id="000e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以基本上，为了在远程服务器上连接和执行方法，我们需要:</p><ul class=""><li id="2582" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk kr ks kt ku bi translated">服务器正在使用的接口代码，该代码不公开可见，也不能从注册中心下载</li><li id="a885" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">nmap检测到的绑定名称和注册端口</li><li id="5211" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">调用处理程序必须可以在网络级别上使用它在注册表转储中显示的IP/主机名进行访问</li></ul><p id="0343" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">等一下！</strong></p><p id="4b17" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你喜欢这篇文章吗？想让<strong class="jp ir">了解最新的</strong>网络安全内容吗？</p><p id="e272" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://newsletter.afine.academy/join" rel="noopener ugc nofollow" target="_blank">免费订阅我们的<strong class="jp ir"/><strong class="jp ir">时事通讯</strong> —点击这里</a>！</p><div class="nl nm gp gr nn no"><a href="https://newsletter.afine.academy/join" rel="noopener  ugc nofollow" target="_blank"><div class="np ab fo"><div class="nq ab nr cl cj ns"><h2 class="bd ir gy z fp nt fr fs nu fu fw ip bi translated">AFINE网络通讯</h2><div class="nv l"><p class="bd b dl z fp nt fr fs nu fu fw dk translated">点击这里加入！</p></div></div><div class="nw l"><div class="nx l ny nz oa nw ob mj no"/></div></div></a></div><h1 id="556c" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">客户端故障排除</h1><p id="c3e8" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">下面我们将讨论在这一点上可能遇到的两个常见障碍:<strong class="jp ir">外来InvocationHandler </strong>和<strong class="jp ir">缺少服务器端接口</strong>。</p><p id="7010" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如上面的wireshark转储所示，在连接到RMI注册表的过程中，首先注册表将被命中，然后客户端将被重定向到相应的InvocationHandler。如果InvocationHandler设置为外部主机，例如localhost或无法解析的主机名，请记住，仍然是您的计算机将尝试连接到InvocationHandler的地址。</p><ul class=""><li id="22e2" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk kr ks kt ku bi translated">如果它被设置为localhost，您将得到一个连接错误，因为在连接到注册表之后，您的客户端将尝试连接到您的机器的本地主机<strong class="jp ir">上的InvocationHandler。您必须使用防火墙或socat等工具设置中继，并将流量从[localhost]:[调用处理程序端口]重定向到[RMI _ host]:[调用处理程序端口]</strong></li><li id="0418" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">如果它被设置为无法解析的主机名，请尝试将rmi服务器的ip地址和外部主机名一起添加到/etc/hosts文件中，以便正确解析它，并且您将能够连接到它</li></ul><p id="82b1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">执行远程方法的第二个障碍是接口的代码。如果没有服务器端接口，事情会更复杂。</p><h1 id="0923" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">目标接口未知怎么办？</h1><p id="d5cb" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">在文章的第二部分，我将向您展示RMIScout工具，它允许自动化该过程，但是，到目前为止，让我们采用手动方法(我相信手动方法应该总是首先用于理解幕后发生的事情；只有这样，自动化方法才能有效地使用)</p><p id="435c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">考虑下面的例子:我们将启动上面提供的rmiserver，并将客户机类和接口类复制到不同的文件夹中。</p><p id="97da" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这种情况下，如果您能够猜出方法名和参数，您就能够调用它。考虑以下客户端代码:</p><pre class="me mf mg mh gt mp mq mr ms aw mt bi"><span id="88d3" class="mu lb iq mq b gy mv mw l mx my"><strong class="mq ir">//Client2.java</strong></span><span id="f058" class="mu lb iq mq b gy mz mw l mx my">import java.net.MalformedURLException;</span><span id="bfa4" class="mu lb iq mq b gy mz mw l mx my">import java.rmi.Naming;</span><span id="d687" class="mu lb iq mq b gy mz mw l mx my">import java.rmi.NotBoundException;</span><span id="639a" class="mu lb iq mq b gy mz mw l mx my">import java.rmi.RemoteException;</span><span id="e081" class="mu lb iq mq b gy mz mw l mx my">public class Client2 implements RMIInterface {</span><span id="b474" class="mu lb iq mq b gy mz mw l mx my"><strong class="mq ir">public String echo(Object something) throws RemoteException {</strong></span><span id="23ce" class="mu lb iq mq b gy mz mw l mx my"><strong class="mq ir">    String notUsed = something.toString();</strong></span><span id="cb9c" class="mu lb iq mq b gy mz mw l mx my"><strong class="mq ir">    return “Sorry, I don’t know the original implementation”;</strong></span><span id="831e" class="mu lb iq mq b gy mz mw l mx my"><strong class="mq ir">}</strong></span><span id="4db0" class="mu lb iq mq b gy mz mw l mx my">private static RMIInterface look_up;</span><span id="8ed5" class="mu lb iq mq b gy mz mw l mx my">public static void main(String[] args)</span><span id="8206" class="mu lb iq mq b gy mz mw l mx my">throws MalformedURLException, RemoteException, NotBoundException {</span><span id="b980" class="mu lb iq mq b gy mz mw l mx my">    look_up = (RMIInterface) Naming.lookup(“rmi://127.0.0.1:11099/RMIInterface”);</span><span id="d2ca" class="mu lb iq mq b gy mz mw l mx my">    System.out.println(“Calling Echo… “);</span><span id="618f" class="mu lb iq mq b gy mz mw l mx my">    try {</span><span id="5a89" class="mu lb iq mq b gy mz mw l mx my">      String response = look_up.echo(“Let’s use a string here. “);</span><span id="fd10" class="mu lb iq mq b gy mz mw l mx my">      System.out.println(response);</span><span id="2d34" class="mu lb iq mq b gy mz mw l mx my">    } catch (Exception e) {}</span><span id="827d" class="mu lb iq mq b gy mz mw l mx my">}</span><span id="d595" class="mu lb iq mq b gy mz mw l mx my">}</span></pre><p id="3fa1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您运行这样的客户端代码，代码将被运行，并且<strong class="jp ir">服务器实现将被执行</strong>。这意味着，要执行远程方法，您只需要知道接口名称以及方法名称、返回的数据类型和参数数据类型。为什么重要？简而言之，如果您能够获得至少一个存在于服务器端的函数的信息，<strong class="jp ir">您可以构建一个与nmap转储的名称相同的虚拟接口，</strong> <strong class="jp ir">在那里放置适当的函数签名(返回的数据类型、名称和参数类型—只有这些)，并创建一个客户端，该客户端使用该函数的虚拟实现来实现该接口。</strong></p><p id="93fd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">唯一重要的是接口存在于客户端的类路径中，因此可能需要构建一个虚拟包，如<em class="nf">org . company . RMI package . RMI interface</em>，将其放在一个虚拟包中。jar文件，最后放到类路径中。一旦您调用它，您将能够执行服务器端的方法并获得它的正确结果(当然，如果它返回任何结果值)。</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi oc"><img src="../Images/de2b019bc8acfcd3502c82c2223f69ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Hl1CLOK8EOa8bqtB"/></div></div></figure><p id="050b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这反过来表明，您只需要猜测方法签名(返回数据类型、方法名称和参数数据类型)就能够执行它们。如果足够幸运的话，您可能能够在GitHub上找到完整的RMI接口，这反过来也允许您检查某个方法做了什么。否则，将在本文第二部分讨论的RMIScout将是发现服务器端潜在方法的绝佳选择。如果您能够识别RMI方法，其中一些可能已经帮助您在目标系统上获得了立足点。</p><p id="f9a5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可以在GitHub <a class="ae kl" href="https://github.com/0xluk3/simple-rmi" rel="noopener ugc nofollow" target="_blank">这里</a>找到这里使用的程序的完整代码。</p><h1 id="167c" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">RMI注册表故障排除</h1><p id="ce9d" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">当使用上面描述的RMI注册中心，或者使用任何其他连接到远程注册中心的工具(还有ysoserial或rmiscout等等)时，您可能会遇到一个错误，这个错误通常伴随着一个堆栈跟踪。虽然堆栈跟踪对出错的地方有很大的帮助，但完全可以理解，您可能不想深入故障诊断，而只是让工具工作并继续前进。以下列表显示了在处理RMI注册表时遇到的常见异常，并附有简短的解释和补救措施。请注意，每种情况都是不同的，所以它们不会在100%的情况下都有效，但是如果你觉得卡住了，这些可以是你的第一步。</p><p id="5a98" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">客户端异常:</strong></p><ul class=""><li id="1ac3" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk kr ks kt ku bi translated">【Java . security . accesscontrolexception:拒绝访问(Java . net . socket permission hostname.server.com)</li></ul><p id="e34e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">JVM没有权限打开远程套接字。这可能是您的<a class="ae kl" href="https://docs.oracle.com/en/java/javase/11/security/permissions-jdk1.html#GUID-1E8E213A-D7F2-49F1-A2F0-EFB3397A8C95" rel="noopener ugc nofollow" target="_blank"> java安全策略(java.policy) </a>的问题。</p><ul class=""><li id="bc84" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk kr ks kt ku bi translated"><strong class="jp ir">异常:连接拒绝主机:10 . 10 . 4 . 1；嵌套异常是:<br/> java.net.ConnectException:连接被拒绝</strong></li></ul><p id="5442" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">无法建立连接。这是因为注册表在网络级别上不可达。目标注册表可能已关闭，或者有什么东西正在阻止网络连接。</p><ul class=""><li id="914e" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk kr ks kt ku bi translated"><strong class="jp ir">Java . RMI . notboundexception:</strong></li></ul><p id="8bd7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这意味着注册表存在，但您正在寻找的绑定不存在。例如，您想绑定到“MYRegistry ”,但是您打错了，写成了“MYRegistr ”,所以您得到了NotBoundException</p><ul class=""><li id="7a32" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk kr ks kt ku bi translated"><strong class="jp ir">异常:解组退货出错；嵌套异常是:<br/>Java . lang . classnotfoundexception:[class name]</strong></li></ul><p id="41b3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这意味着您的类路径中缺少[ClassName]。尝试从您的接口所在的目录运行您的rmi客户机(或工具)。如果您正在运行一个jar工具，可能需要解包它，将一个编译好的类添加到某个包中，然后重新打包jar。如果你不确定如何操作，请点击下面的链接了解软件包的工作原理:<a class="ae kl" href="https://www.geeksforgeeks.org/packages-in-java/" rel="noopener ugc nofollow" target="_blank">https://www.geeksforgeeks.org/packages-in-java/</a></p><p id="ccb0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">运行服务器时出现异常:</strong></p><ul class=""><li id="2b26" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk kr ks kt ku bi translated"><strong class="jp ir">Java . RMI . server . export exception:端口已被使用:1099；嵌套异常是:</strong></li></ul><p id="60ca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当您尝试在同一个端口上运行两次rmiregistry时，可能会发生这种情况。</p><ul class=""><li id="a909" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk kr ks kt ku bi translated">Java . RMI . access exception:Registry。不允许Registry.rebind产地foreign.host.com是非本地主机</li></ul><p id="40a8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">RMI只能绑定到本地主机——如果您收到这个错误，您可能试图绑定到位于远程机器上的注册表。</p><ul class=""><li id="a1fe" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk kr ks kt ku bi translated"><strong class="jp ir">Java . RMI . alreadyboundexception:my registry</strong></li></ul><p id="76dd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这仅仅意味着这种约束已经存在。更改名称或取消绑定上一个对象。</p><p id="3180" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是了解RMI注册中心的基本知识所需要的全部内容。这很长，但是如果你想以一种聪明的方式使用自动攻击工具，并且在测试基础设施时更有效，这是值得一试的。在下一部分中，我将向您展示有趣的部分——枚举和攻击技术，它们可能因目标的Java安全级别和补丁策略而异。</p><p id="292d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">作者:</strong>卢卡斯·米库拉——渗透测试仪&amp;研发负责人&amp; D @ AFINE。在LinkedIn(<a class="ae kl" href="https://www.linkedin.com/in/lukaszmikula/" rel="noopener ugc nofollow" target="_blank">https://www.linkedin.com/in/lukaszmikula/</a>)或Twitter(<a class="ae kl" href="https://twitter.com/0xluk3" rel="noopener ugc nofollow" target="_blank">https://twitter.com/0xluk3</a>)上关注我</p><p id="062e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">参考文献</strong>:</p><p id="d88b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">[1]<a class="ae kl" href="https://www.slideshare.net/NickBloor3/nicky-bloor-barmie-poking-javas-back-door-44con-2017" rel="noopener ugc nofollow" target="_blank">https://www . slide share . net/nickbloor 3/Nicky-bloor-bar mie-poking-javas-back-door-44con-2017</a></p><p id="8331" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，这篇文章的灵感来自于阅读下面的文章(我建议你也阅读它们！):</p><ul class=""><li id="0c0d" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk kr ks kt ku bi translated">https://artemis.wszib.edu.pl/~tgubala/rmi/exceptions.html(这张是波兰文)</li><li id="8b14" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated"><a class="ae kl" href="https://mogwailabs.de/blog/2019/03/attacking-java-rmi-services-after-jep-290/" rel="noopener ugc nofollow" target="_blank">https://mogwailabs . de/blog/2019/03/attaking-Java-RMI-services-after-jep-290/</a></li><li id="d79f" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated"><a class="ae kl" href="https://stackoverflow.com/questions/17351336/i-am-running-a-rmi-application-and-no-security-manager-rmi-class-loader-disable" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/17351336/I-am-running-a-RMI-application-and-no-security-manager-RMI-class-loader-disable</a></li><li id="4431" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated"><a class="ae kl" href="https://www.knowledgehut.com/tutorials/java-tutorial/java-rmi" rel="noopener ugc nofollow" target="_blank">https://www . knowledge hut . com/tutorials/Java-tutorial/Java-RMI</a></li><li id="2358" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">【https://labs.bishopfox.com/tech-blog/rmiscout T4】</li></ul></div></div>    
</body>
</html>