<html>
<head>
<title>Developing Spring Boot Applications for Querying Data Lakes on AWS using Amazon Athena</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Amazon Athena开发用于在AWS上查询数据湖的Spring Boot应用程序</h1>
<blockquote>原文：<a href="https://itnext.io/developing-spring-boot-applications-for-querying-data-lakes-on-aws-eeefa298741?source=collection_archive---------0-----------------------#2022-06-26">https://itnext.io/developing-spring-boot-applications-for-querying-data-lakes-on-aws-eeefa298741?source=collection_archive---------0-----------------------#2022-06-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="96f9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解如何开发云原生的RESTful Java服务，使用Amazon Athena的API在基于AWS的数据湖中查询数据</h2></div><h1 id="548e" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">介绍</h1><p id="5ff0" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">AWS提供了一系列完全托管的服务，使构建和管理安全的数据湖更快更容易，包括AWS Lake Formation、AWS Glue和亚马逊S3。Amazon EMR、AWS Glue Studio和Amazon Redshift等其他分析服务允许数据科学家和分析师快速、经济地对大量半结构化和结构化数据运行高性能查询。</p><p id="8505" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">不太明显的是团队如何开发基于数据湖之上的内部和外部面向客户的分析应用程序。例如，想象一下电子商务平台上的卖家，这篇文章中使用的场景，想要通过分析销售趋势和买家偏好来做出关于他们产品的更好的营销决策。此外，假设分析所需的数据必须从多个系统和数据源聚集；数据湖的理想用例。</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi mb"><img src="../Images/3b18b0b803c745a21b464baa9c14373f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C8fFmK-7CVrPxi3Q-cVc3A.png"/></div></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">从Spring Boot服务的<code class="fe mr ms mt mu b">salesbyseller</code>端点生成的个性化销售报告示例</figcaption></figure><p id="f02e" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">在本帖中，我们将探索一个示例Java<a class="ae mv" href="https://spring.io/projects/spring-boot" rel="noopener ugc nofollow" target="_blank">Spring Boot</a>RESTful Web服务，它允许最终用户查询存储在AWS上的数据湖中的数据。RESTful Web服务将使用Amazon Athena通过一个<a class="ae mv" href="https://docs.aws.amazon.com/glue/latest/dg/populate-data-catalog.html" rel="noopener ugc nofollow" target="_blank"> AWS Glue数据目录</a>访问存储为亚马逊S3<a class="ae mv" href="https://parquet.apache.org/" rel="noopener ugc nofollow" target="_blank">Apache Parquet</a>的数据。该服务将使用Spring Boot和用于Java的<a class="ae mv" href="https://aws.amazon.com/sdk-for-java/" rel="noopener ugc nofollow" target="_blank">AWS SDK</a>来公开一个安全的RESTful应用编程接口(API)。</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi mw"><img src="../Images/ae63a73908af6c3b9790f8b15bd9b233.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T4O8QSBNCP3XbIHQ-2QLqw.png"/></div></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">这篇文章展示了高级AWS架构</figcaption></figure><p id="5737" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated"><a class="ae mv" href="https://aws.amazon.com/athena/" rel="noopener ugc nofollow" target="_blank"> Amazon Athena </a>是基于<a class="ae mv" href="https://prestodb.io/" rel="noopener ugc nofollow" target="_blank"> Presto </a>的无服务器交互式查询服务，用于使用标准SQL在亚马逊S3查询数据和分析大数据。使用AWS SDK for Java和Athena API公开的Athena功能，Spring Boot服务将演示如何访问<a class="ae mv" href="https://docs.aws.amazon.com/athena/latest/ug/creating-tables.html" rel="noopener ugc nofollow" target="_blank">表</a>、<a class="ae mv" href="https://docs.aws.amazon.com/athena/latest/ug/views.html" rel="noopener ugc nofollow" target="_blank">视图</a>、<a class="ae mv" href="https://docs.aws.amazon.com/athena/latest/ug/querying-with-prepared-statements.html" rel="noopener ugc nofollow" target="_blank">准备好的语句</a>和<a class="ae mv" href="https://docs.aws.amazon.com/athena/latest/ug/saved-queries.html" rel="noopener ugc nofollow" target="_blank">保存的查询</a>(又名<a class="ae mv" href="https://docs.aws.amazon.com/athena/latest/APIReference/API_NamedQuery.html" rel="noopener ugc nofollow" target="_blank">命名查询</a>)。</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi mx"><img src="../Images/5da8a5e13dd9926359a12fc0ed54ced7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Di-K1leA6w8uzXckh799Pg.png"/></div></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">亚马逊雅典娜查询编辑器</figcaption></figure><h1 id="a8cc" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">TL；速度三角形定位法(dead reckoning)</h1><p id="1220" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在阅读整篇文章之前，您是想探索一下这篇文章的Spring Boot服务的源代码，还是想将其部署到Kubernetes？所有的源代码、Docker和Kubernetes资源都是开源的，可以在GitHub上获得。</p><pre class="mc md me mf gt my mu mz na aw nb bi"><span id="696c" class="nc kj it mu b gy nd ne l nf ng">git clone --depth 1 -b main \<br/>    <a class="ae mv" href="https://github.com/garystafford/athena-spring-app.git" rel="noopener ugc nofollow" target="_blank">https://github.com/garystafford/athena-spring-app.git</a></span></pre><p id="ded6" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">在<a class="ae mv" href="https://hub.docker.com/r/garystafford/athena-spring-app/tags" rel="noopener ugc nofollow" target="_blank"> Docker Hub </a>上还可以看到Spring Boot服务的Docker图像。</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi mx"><img src="../Images/534fa1d696912fa07fa6ff26e19d630b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fEch1Ldml7-u_GbXPl9M6w.png"/></div></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">Docker Hub上提供的Spring Boot服务图片</figcaption></figure><h1 id="6756" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">数据湖数据源</h1><p id="5de5" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在AWS上构建一个演示数据湖有无穷无尽的数据源。这篇文章使用了由AWS提供的<a class="ae mv" href="https://docs.aws.amazon.com/redshift/latest/dg/c_sampledb.html" rel="noopener ugc nofollow" target="_blank"> TICKIT样本数据库</a>，它是为AWS的云数据仓库服务Amazon Redshift设计的。数据库由七个表组成。前两篇文章和相关视频<a class="ae mv" href="https://garystafford.medium.com/building-a-data-lake-with-apache-airflow-b48bd953c2b" rel="noopener">用Apache Airflow在AWS上构建数据湖</a>和<a class="ae mv" href="https://garystafford.medium.com/building-a-simple-data-lake-on-aws-df21ca092e32" rel="noopener">在AWS上构建数据湖</a>，详细介绍了本文中使用AWS Glue和可选的Apache Airflow与亚马逊MWAA的数据湖的设置。</p><div class="nh ni gp gr nj nk"><a href="https://garystafford.medium.com/building-a-data-lake-with-apache-airflow-b48bd953c2b" rel="noopener follow" target="_blank"><div class="nl ab fo"><div class="nm ab nn cl cj no"><h2 class="bd iu gy z fp np fr fs nq fu fw is bi translated">用Apache气流构建数据湖</h2><div class="nr l"><h3 class="bd b gy z fp np fr fs nq fu fw dk translated">使用服务组合，包括Amazon管理的工作流，以编程方式在AWS上构建一个简单的数据湖…</h3></div><div class="ns l"><p class="bd b dl z fp np fr fs nq fu fw dk translated">garystafford.medium.com</p></div></div><div class="nt l"><div class="nu l nv nw nx nt ny ml nk"/></div></div></a></div><div class="nh ni gp gr nj nk"><a href="https://garystafford.medium.com/building-a-simple-data-lake-on-aws-df21ca092e32" rel="noopener follow" target="_blank"><div class="nl ab fo"><div class="nm ab nn cl cj no"><h2 class="bd iu gy z fp np fr fs nq fu fw is bi translated">在AWS上构建数据湖</h2><div class="nr l"><h3 class="bd b gy z fp np fr fs nq fu fw dk translated">使用服务组合在AWS上构建一个简单的数据湖，包括AWS Glue、AWS Glue Studio、Amazon Athena…</h3></div><div class="ns l"><p class="bd b dl z fp np fr fs nq fu fw dk translated">garystafford.medium.com</p></div></div><div class="nt l"><div class="nz l nv nw nx nt ny ml nk"/></div></div></a></div><p id="bddb" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">这两篇文章使用了数据湖模式，将数据分为青铜(<em class="oa">即原始的</em>)、白银(<em class="oa">即精炼的</em>)和黄金(<em class="oa">即聚集的</em>)，并通过<a class="ae mv" href="https://databricks.com/" rel="noopener ugc nofollow" target="_blank">数据块</a>推广开来。数据湖模拟了一个典型的场景，其中数据来自多个来源，包括一个电子商务平台、一个CRM系统和一个必须进行聚合和分析的SaaS提供商。</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi ob"><img src="../Images/b8276958439bcf9fdbeb9056ee57a761.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8q702varXJjLJZ6OOOfhgw.png"/></div></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">上一篇文章中展示的高级数据湖架构</figcaption></figure><h1 id="2e28" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">使用智能集成开发的Spring项目</h1><p id="f10e" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">尽管不是必需的，我还是使用了JetBrains IntelliJ IDEA 2022(终极版)来开发和测试邮报的Spring Boot服务。用IntelliJ引导Spring项目很容易。开发人员可以使用IntelliJ附带的Spring Initializr插件快速创建一个Spring项目。</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi oc"><img src="../Images/4ea6171fe8a3a65bcfd2f3d512eac50f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BsijYn7i-AQrmNIWygD9bw.png"/></div></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">对Spring项目的JetBrains IntelliJ IDEA插件支持</figcaption></figure><p id="b692" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">Spring Initializr插件的新项目创建向导基于<a class="ae mv" href="https://start.spring.io/" rel="noopener ugc nofollow" target="_blank"> start.spring.io </a>。该插件允许您快速选择想要合并到项目中的Spring依赖项。</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi oc"><img src="../Images/3ecbb140ec3798ae439e1403d7be270c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QEV06qrf5rQH-DcvepEHZw.png"/></div></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">在IntelliJ中向新的Spring项目添加依赖项</figcaption></figure><h1 id="ea04" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">Visual Studio代码</h1><p id="2302" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">流行的Visual Studio代码IDE也有几个Spring扩展，包括微软的<a class="ae mv" href="https://marketplace.visualstudio.com/items?itemName=vscjava.vscode-spring-initializr" rel="noopener ugc nofollow" target="_blank"> Spring Initializr Java支持</a>扩展。</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi od"><img src="../Images/3592002344ada6112c90d3e53c3b778d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g4nsVW6RsNCeAcmg0wEh2Q.png"/></div></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">微软对Visual Studio代码的扩展</figcaption></figure><h1 id="a475" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">格拉德勒</h1><p id="9bce" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这篇文章使用Gradle代替Maven来开发、测试、构建、打包和部署Spring服务。基于上面显示的新项目设置中选择的包，Spring Initializr插件的新项目创建向导创建一个<code class="fe mr ms mt mu b">build.gradle</code>文件。额外的包，如<a class="ae mv" href="https://projectlombok.org/" rel="noopener ugc nofollow" target="_blank">隆巴克</a>、<a class="ae mv" href="https://github.com/micrometer-metrics/micrometer" rel="noopener ugc nofollow" target="_blank">千分尺</a>和<a class="ae mv" href="https://github.com/rest-assured/rest-assured/wiki/GettingStarted#maven--gradle-users" rel="noopener ugc nofollow" target="_blank">放心</a>被单独添加。</p><figure class="mc md me mf gt mg"><div class="bz fp l di"><div class="oe of l"/></div></figure><h1 id="ef5b" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">亚马逊科雷托</h1><p id="4e8e" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">Spring boot服务是为最新版本的<a class="ae mv" href="https://docs.aws.amazon.com/corretto/latest/corretto-17-ug/what-is-corretto-17.html" rel="noopener ugc nofollow" target="_blank">亚马逊Corretto 17 </a>开发和编译的。根据AWS的说法，亚马逊Corretto是一个免费的、多平台的、生产就绪的<a class="ae mv" href="https://openjdk.org/" rel="noopener ugc nofollow" target="_blank">开放Java开发包</a> (OpenJDK)发行版。Corretto提供长期支持，包括性能增强和安全修复。Corretto被认证为与Java SE标准兼容，并在Amazon内部用于许多生产服务。</p><h1 id="9adc" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">源代码</h1><p id="0e7a" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">Spring Boot RESTful Web服务中的每个API端点都有一个对应的POJO数据模型类、服务接口和服务实现类以及控制器类。此外，还有一些公共类，如配置、客户端工厂和特定于Athena的请求/响应方法。最后，对于视图和准备好的语句，还有额外的类依赖。</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi og"><img src="../Images/8c2c4cea1e4a26aa1dd99168f2c65527.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QFxyYRKvpFqPIJLjb6rj_A.png"/></div></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">与查询Amazon Athena <code class="fe mr ms mt mu b">refined_tickit_public_category</code>表相关的Java类关系</figcaption></figure><p id="dfff" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">项目的源代码按照包和类类型的逻辑层次进行排列。</p><figure class="mc md me mf gt mg"><div class="bz fp l di"><div class="oe of l"/></div></figure><h1 id="e092" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">亚马逊雅典娜访问</h1><p id="57f2" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">使用AWS SDK for Java访问Amazon Athena有三种标准方法:1)使用<code class="fe mr ms mt mu b"><a class="ae mv" href="https://sdk.amazonaws.com/java/api/latest/software/amazon/awssdk/services/athena/AthenaClient.html" rel="noopener ugc nofollow" target="_blank">AthenaClient</a></code>服务客户端，2)使用<code class="fe mr ms mt mu b"><a class="ae mv" href="https://sdk.amazonaws.com/java/api/latest/software/amazon/awssdk/services/athena/AthenaAsyncClient.html" rel="noopener ugc nofollow" target="_blank">AthenaAsyncClient</a></code>服务客户端异步访问Athena，3)使用<a class="ae mv" href="https://docs.aws.amazon.com/athena/latest/ug/connect-with-jdbc.html" rel="noopener ugc nofollow" target="_blank"> JDBC驱动程序</a>和AWS SDK。<code class="fe mr ms mt mu b"><a class="ae mv" href="https://sdk.amazonaws.com/java/api/latest/software/amazon/awssdk/services/athena/AthenaClient.html" rel="noopener ugc nofollow" target="_blank">AthenaClient</a></code>和<code class="fe mr ms mt mu b">AthenaAsyncClient</code>服务客户端都是<code class="fe mr ms mt mu b"><a class="ae mv" href="https://sdk.amazonaws.com/java/api/latest/software/amazon/awssdk/services/athena/package-summary.html" rel="noopener ugc nofollow" target="_blank">software.amazon.awssdk.services.athena</a></code>包的一部分。为了简单起见，本文的Spring Boot服务使用了<code class="fe mr ms mt mu b">AthenaClient</code>服务客户端，而不是Java的异步编程模型。AWS提供基本的<a class="ae mv" href="https://docs.aws.amazon.com/athena/latest/ug/code-samples.html" rel="noopener ugc nofollow" target="_blank">代码样本</a>作为他们文档的一部分，作为使用SDK编写Athena应用程序的起点。代码示例也使用了<code class="fe mr ms mt mu b">AthenaClient</code>服务客户端。</p><h1 id="ecba" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">基于POJO的数据模型</h1><p id="3860" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">对于Spring Boot RESTful Web服务中的每个API端点，都有一个对应的普通旧Java对象(POJO)。根据维基百科的说法，POGO是一个普通的Java对象，不受任何特定限制的约束。POJO类类似于JPA实体，表示存储在关系数据库中的持久数据。在这种情况下，POJO使用Lombok的<code class="fe mr ms mt mu b">@Data</code>注释。根据文档，这个注释为所有字段生成getters，一个有用的<code class="fe mr ms mt mu b">toString</code>方法，以及检查所有非瞬态字段的<code class="fe mr ms mt mu b">hashCode</code>和<code class="fe mr ms mt mu b">equals</code>实现。它还为所有非final字段和一个构造函数生成setters。</p><figure class="mc md me mf gt mg"><div class="bz fp l di"><div class="oe of l"/></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated"><code class="fe mr ms mt mu b">Event</code> POJO数据模型</figcaption></figure><p id="f9c1" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">每个POJO都直接对应于AWS Glue数据目录中的一个“银”表。例如，<code class="fe mr ms mt mu b">Event</code> POJO对应于<code class="fe mr ms mt mu b">tickit_demo</code>数据目录数据库中的<code class="fe mr ms mt mu b">refined_tickit_public_event</code>表。POJO为从相应的AWS粘合数据目录表中读取的数据定义了Spring Boot服务的数据模型。</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi mx"><img src="../Images/6867991d615c9631226265e03f4cb1fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HniwyXHk9mYLmL8d-h0r1A.png"/></div></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">粘附数据目录refined_tickit_public_event表</figcaption></figure><p id="dcd7" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">粘合数据目录表是Athena查询和存储在亚马逊S3对象存储中的底层数据之间的接口。Athena查询的目标是从S3返回底层数据的表。</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi oh"><img src="../Images/769795f96500ff2eb06cf15ae19f327d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bKfv9RuoZG9q4ypvVpX0aw.png"/></div></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">Tickit类别数据存储为亚马逊S3的Apache Parquet文件</figcaption></figure><h1 id="aa3f" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">服务</h1><p id="64a8" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">使用Athena通过AWS Glue从数据湖中检索数据是由一个服务类处理的。对于Spring Boot RESTful Web服务中的每个API端点，都有相应的服务接口和实现类。服务实现类使用Spring框架的<code class="fe mr ms mt mu b">@Service</code>注释。根据文档，它表明一个带注释的类是一个“服务”，最初由域驱动设计(Evans，2003)定义为“<em class="oa">一个作为独立于模型的接口提供的操作，没有封装的状态。对于Spring Boot服务来说，最重要的是，这个注释充当了<code class="fe mr ms mt mu b">@Component</code>的专门化，允许通过类路径扫描自动检测实现类。</em></p><figure class="mc md me mf gt mg"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="33d6" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">使用Spring的通用<a class="ae mv" href="https://docs.spring.io/spring-boot/docs/2.0.x/reference/html/using-boot-spring-beans-and-dependency-injection.html" rel="noopener ugc nofollow" target="_blank">基于构造函数的依赖注入</a> (DI)方法(<em class="oa">又名构造函数注入</em>)，服务自动连接<code class="fe mr ms mt mu b">AthenaClientFactory</code>接口的一个实例。注意，我们是自动连接服务接口，而不是服务实现，如果需要的话，允许我们连接不同的实现，比如为了测试。</p><p id="95aa" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">该服务调用<code class="fe mr ms mt mu b">AthenaClientFactory</code>类的<code class="fe mr ms mt mu b">createClient()</code>方法，该方法使用几种可用的身份验证方法之一返回到Amazon Athena的连接。身份验证方案将取决于服务的部署位置以及您希望如何安全地连接到AWS。一些选项包括环境变量、本地AWS配置文件、EC2实例配置文件或来自web身份提供者的令牌。</p><figure class="mc md me mf gt mg"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="cba2" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">服务类将由实例<code class="fe mr ms mt mu b">GetQueryResultsResponse</code>返回的有效负载转换成有序集合(<em class="oa">也称为序列</em>)，<code class="fe mr ms mt mu b">List&lt;E&gt;</code>，其中<code class="fe mr ms mt mu b">E</code>代表一个POJO。例如，对于数据湖的<code class="fe mr ms mt mu b">refined_tickit_public_event</code>表，服务返回一个<code class="fe mr ms mt mu b">List&lt;Event&gt;</code>。对于表、视图、预处理语句和命名查询，这种模式会重复出现。可以动态转换和格式化列数据类型，添加新列，跳过现有列。</p><figure class="mc md me mf gt mg"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="bf18" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">对于控制器类中定义的每个端点，例如<code class="fe mr ms mt mu b">get()</code>、<code class="fe mr ms mt mu b">findAll()</code>和<code class="fe mr ms mt mu b">FindById()</code>，在服务类中都有相应的方法。下面，我们看到了一个在<code class="fe mr ms mt mu b">SalesByCategoryServiceImp</code>服务类中的<code class="fe mr ms mt mu b">findAll()</code>方法的例子。这个方法对应于<code class="fe mr ms mt mu b">SalesByCategoryController</code>控制器类中同名的方法。这些服务方法都遵循一个相似的模式，即基于输入参数构造一个动态Athena SQL查询，该查询通过使用<code class="fe mr ms mt mu b">GetQueryResultsRequest</code>实例的<code class="fe mr ms mt mu b">AthenaClient</code>服务客户端传递给Athena。</p><figure class="mc md me mf gt mg"><div class="bz fp l di"><div class="oe of l"/></div></figure><h1 id="363a" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">控制器</h1><p id="8d96" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">最后，在Spring Boot RESTful Web服务中，每个API端点都有一个对应的控制器类。控制器类使用Spring框架的<code class="fe mr ms mt mu b">@RestController</code>注释。根据文档，该注释是一个方便的注释，它本身用<code class="fe mr ms mt mu b">@Controller</code>和<code class="fe mr ms mt mu b">@ResponseBody</code>进行了注释。带有该注释的类型被视为控制器，其中默认情况下<code class="fe mr ms mt mu b">@RequestMapping</code>方法采用<code class="fe mr ms mt mu b">@ResponseBody</code>语义。</p><p id="d855" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">控制器类使用<a class="ae mv" href="https://docs.spring.io/spring-boot/docs/2.0.x/reference/html/using-boot-spring-beans-and-dependency-injection.html" rel="noopener ugc nofollow" target="_blank">基于构造函数的依赖注入</a> (DI)依赖于相应的服务类应用组件。像上面的服务例子一样，我们自动连接服务接口，而不是服务实现。</p><figure class="mc md me mf gt mg"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="245d" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">控制器负责将有序的POJOs集合序列化为JSON，并在对初始HTTP请求的HTTP响应正文中返回JSON有效负载。</p><h1 id="fb86" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">查询视图</h1><p id="3081" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">除了查询AWS Glue数据目录表(<em class="oa">又名Athena表</em>)之外，我们还查询视图。根据<a class="ae mv" href="https://docs.aws.amazon.com/athena/latest/ug/views.html" rel="noopener ugc nofollow" target="_blank">文档</a>，Amazon Athena中的视图是一个逻辑表，而不是物理表。因此，每次在查询中引用视图时，都会运行定义视图的查询。</p><p id="7f40" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">为了方便起见，每次Spring Boot服务启动时，主<code class="fe mr ms mt mu b">AthenaApplication</code>类调用<code class="fe mr ms mt mu b">View.java</code>类的<code class="fe mr ms mt mu b">CreateView()</code>方法来检查视图<code class="fe mr ms mt mu b">view_tickit_sales_by_day_and_category</code>的存在。如果该视图不存在，则会创建该视图，所有应用程序最终用户都可以访问该视图。通过服务的<code class="fe mr ms mt mu b">/salesbycategory</code>端点查询视图。</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi oi"><img src="../Images/6b1c40e348ca4901d73eeb3fc39f781c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gu-7IlrcUAoPibArRDRLXw.png"/></div></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">与查询Amazon Athena视图相关的Java类关系</figcaption></figure><p id="64b3" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">这种确认或创建模式在主<code class="fe mr ms mt mu b">AthenaApplication</code>类(下一节中详述的<em class="oa">)的准备好的语句中重复。</em></p><figure class="mc md me mf gt mg"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="0b98" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">下面，我们看到服务在启动时调用的<code class="fe mr ms mt mu b">View</code>类。</p><figure class="mc md me mf gt mg"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="7a31" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">除了<code class="fe mr ms mt mu b">/salesbycategory</code>端点查询视图之外，其他一切都与查询表相同。这个端点使用相同的模型-服务-控制器模式。</p><h1 id="d8e9" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">执行预准备语句</h1><p id="b06c" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">根据<a class="ae mv" href="https://docs.aws.amazon.com/athena/latest/ug/querying-with-prepared-statements.html" rel="noopener ugc nofollow" target="_blank">文档</a>，您可以使用Athena参数化查询特性来准备语句，以便使用不同的查询参数重复执行相同的查询。服务使用的准备好的语句<code class="fe mr ms mt mu b">tickit_sales_by_seller</code>接受单个参数，即销售者的ID(<code class="fe mr ms mt mu b">sellerid</code>)。使用<code class="fe mr ms mt mu b">/salesbyseller</code>端点执行准备好的语句。这个场景模拟了一个分析应用程序的最终用户，他想要检索有关其销售的丰富的销售信息。</p><figure class="mc md me mf gt mg"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="f01d" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">查询数据的模式类似于表和视图，只是我们没有使用常见的<code class="fe mr ms mt mu b">SELECT...FROM...WHERE</code> SQL查询模式，而是使用了<code class="fe mr ms mt mu b">EXECUTE...USING</code>模式。</p><figure class="mc md me mf gt mg"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="40e1" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">例如，要为ID为3的销售者执行准备好的语句，我们将使用<code class="fe mr ms mt mu b">EXECUTE tickit_sales_by_seller USING 3;</code>。我们将销售者的ID 3作为路径参数传递，类似于服务公开的其他端点:<code class="fe mr ms mt mu b">/v1/salesbyseller/3</code>。</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi od"><img src="../Images/71a6af61414409c5486ca21b56539e8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yqn83JT3OkMJjWStsoKgmg.png"/></div></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">Athena的Sales by seller查询结果使用销售者的ID作为预准备语句的参数</figcaption></figure><p id="04de" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">同样，除了<code class="fe mr ms mt mu b">/salesbyseller</code>端点执行一个准备好的语句并传递一个参数之外；其他一切都与查询表或视图相同，使用相同的模型-服务-控制器模式。</p><h1 id="e2ec" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">使用命名查询</h1><p id="c3b2" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">除了表、视图和准备好的语句，Athena还有<a class="ae mv" href="https://docs.aws.amazon.com/athena/latest/ug/saved-queries.html" rel="noopener ugc nofollow" target="_blank">保存的查询</a>的概念，在Athena API中和使用AWS CloudFormation时称为<a class="ae mv" href="https://docs.aws.amazon.com/athena/latest/APIReference/API_NamedQuery.html" rel="noopener ugc nofollow" target="_blank">命名查询</a>。您可以使用Athena控制台或API来保存、编辑、运行、重命名和删除查询。使用查询的唯一标识符(UUID)来持久化查询。当使用现有的命名查询时，必须引用<code class="fe mr ms mt mu b">NamedQueryId</code>。</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi oh"><img src="../Images/ead60584d57d9e8bb5ced0c0d5a6faad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oDEYbK0wHRtk4a7Y3NKBWQ.png"/></div></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">本帖中使用的已保存查询(命名查询)示例</figcaption></figure><p id="e053" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">有多种方法可以以编程方式使用和重用现有的命名查询。对于这个演示，我预先创建了命名查询<code class="fe mr ms mt mu b">buyer_likes_by_category</code>，然后将结果<code class="fe mr ms mt mu b">NamedQueryId</code>存储为应用程序属性，在运行时或kubernetes部署时通过本地环境变量注入。</p><figure class="mc md me mf gt mg"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="c41e" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">或者，您可以遍历一个命名查询列表，在启动时找到一个匹配名称的查询。然而，这种方法无疑会影响服务性能、启动时间和成本。最后，您可以在启动时使用包含在未使用的<code class="fe mr ms mt mu b">NamedQuery</code>类中的<code class="fe mr ms mt mu b">NamedQuery()</code>这样的方法，类似于view和prepared语句。该命名查询的惟一属性<code class="fe mr ms mt mu b">NamedQueryId</code>将作为<a class="ae mv" href="https://docs.oracle.com/javase/tutorial/essential/environment/sysprop.html" rel="noopener ugc nofollow" target="_blank">系统属性</a>持久化，可由服务类引用。缺点是，每次启动服务时，您都会创建一个命名查询的副本。因此，也不推荐这种方法。</p><h1 id="6fa4" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">配置</h1><p id="dc2c" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">负责持久化Spring Boot服务配置的两个组件是<code class="fe mr ms mt mu b">application.yml</code>属性文件和<code class="fe mr ms mt mu b">ConfigProperties</code>类。该类使用Spring框架的<code class="fe mr ms mt mu b">@ConfigurationProperties</code>注释。根据文档，该注释用于外部化配置。如果您想要绑定和验证一些外部属性(例如，来自<code class="fe mr ms mt mu b">.properties</code>或<code class="fe mr ms mt mu b">.yml</code>文件)，请将其添加到<code class="fe mr ms mt mu b">@Configuration</code>类的类定义或<code class="fe mr ms mt mu b">@Bean</code>方法中。绑定是通过调用带注释的类上的setters来执行的，或者，如果<code class="fe mr ms mt mu b">@ConstructorBinding</code>正在使用，通过绑定到构造函数参数来执行。</p><figure class="mc md me mf gt mg"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="644a" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated"><code class="fe mr ms mt mu b"><a class="ae mv" href="http://twitter.com/ConfigurationPropert" rel="noopener ugc nofollow" target="_blank">@ConfigurationPropert</a>ies</code>标注包括<code class="fe mr ms mt mu b">athena</code>的<code class="fe mr ms mt mu b">prefix</code>。该值对应于<code class="fe mr ms mt mu b">application.yml</code>属性文件中的<code class="fe mr ms mt mu b">athena</code>前缀。<code class="fe mr ms mt mu b">ConfigProperties</code>类中的字段被绑定到<code class="fe mr ms mt mu b">application.yml</code>中的属性。例如，属性<code class="fe mr ms mt mu b">namedQueryId</code>被绑定到属性<code class="fe mr ms mt mu b">athena.named.query.id</code>。此外，该属性被绑定到外部环境变量<code class="fe mr ms mt mu b">NAMED_QUERY_ID</code>。这些值可以由外部配置系统、Kubernetes秘密或外部秘密管理系统提供。</p><figure class="mc md me mf gt mg"><div class="bz fp l di"><div class="oe of l"/></div></figure><h1 id="0687" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">AWS IAM:验证和授权</h1><p id="c261" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">为了让Spring Boot服务与Amazon Athena、AWS Glue和Amazon S3进行交互，您需要建立一个AWS IAM角色，一旦通过身份验证，服务就会承担这个角色。该角色必须与包含必需的Athena、Glue和S3权限的附加IAM策略相关联。对于开发，该服务使用类似于下面所示的策略。请注意，该政策比建议的生产范围更广；它不代表最低特权的安全最佳实践。特别是，在创建策略时，应该严格避免对资源使用过于宽泛的<code class="fe mr ms mt mu b">*</code>。</p><figure class="mc md me mf gt mg"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="0db6" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">除了IAM策略授予的授权之外，<a class="ae mv" href="https://aws.amazon.com/lake-formation/" rel="noopener ugc nofollow" target="_blank"> AWS Lake Formation </a>可以与亚马逊S3、AWS Glue和亚马逊Athena一起使用，以授予对数据集的细粒度数据库级、表级、列级和行级访问。</p><h1 id="b0d3" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">Swagger UI和OpenAPI规范</h1><p id="8807" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">查看和试验通过控制器类可用的所有端点的最简单方法是通过<code class="fe mr ms mt mu b"><a class="ae mv" href="https://springdoc.org/" rel="noopener ugc nofollow" target="_blank">springdoc-openapi</a></code> Java库使用示例Spring Boot服务中包含的Swagger UI。在<code class="fe mr ms mt mu b">/v1/swagger-ui/index.html</code>访问Swagger UI。</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi mx"><img src="../Images/c9c7fa1ca3312d9d4fdef4e9996c2ae8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zgsi-GOGODXa3mSFrH2NQQ.png"/></div></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">显示由服务的控制器类公开的端点的Swagger UI</figcaption></figure><p id="160b" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">OpenAPI规范(以前的Swagger规范)是REST APIs的API描述格式。<code class="fe mr ms mt mu b">/v1/v3/api-docs</code>端点允许您生成一个<a class="ae mv" href="https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.0.md" rel="noopener ugc nofollow" target="_blank"> OpenAPI v3规范</a>文件。OpenAPI文件描述了整个API。</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi mx"><img src="../Images/09b3df9f7897f6c5046feba8de8d2e22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S4m4kZCKzA0p50AlKTaMFw.png"/></div></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">Spring Boot服务的OpenAPI v3规范</figcaption></figure><p id="fcdf" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated"><a class="ae mv" href="https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.0.md" rel="noopener ugc nofollow" target="_blank"> OpenAPI v3规范</a>可以保存为文件，并导入到像<a class="ae mv" href="https://www.postman.com/" rel="noopener ugc nofollow" target="_blank"> Postman </a>这样的应用程序中，这是一个用于构建和使用API的API平台。</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi od"><img src="../Images/adffad690f4c4f803bf22ccee6e17bb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*172ceOhsRP5LuYI4tT36hw.png"/></div></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">使用Postman调用服务的<code class="fe mr ms mt mu b">/users</code> API端点</figcaption></figure><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi od"><img src="../Images/d70b984315fecdea516b9816f088379c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v0yUm3Sg5d5fhGWdJGMZoA.png"/></div></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">使用Postman对Spring Boot服务运行一套集成测试</figcaption></figure><h1 id="5f61" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">集成测试</h1><p id="0070" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">Spring Boot服务的源代码中包括有限数量的集成测试示例，不要与单元测试混淆。每个测试类都使用Spring框架的<code class="fe mr ms mt mu b"><a class="ae mv" href="https://docs.spring.io/spring-boot/docs/current/api/org/springframework/boot/test/context/SpringBootTest.html" rel="noopener ugc nofollow" target="_blank">@SpringBootTest</a></code>注释。根据<a class="ae mv" href="https://docs.spring.io/spring-boot/docs/current/api/org/springframework/boot/test/context/SpringBootTest.html" rel="noopener ugc nofollow" target="_blank">文档</a>，这个注释可以在运行基于Spring Boot的测试的测试类上指定。它提供了常规Spring <code class="fe mr ms mt mu b">TestContext</code>框架之外的几个特性。</p><figure class="mc md me mf gt mg"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="6003" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">集成测试使用<a class="ae mv" href="https://rest-assured.io/" rel="noopener ugc nofollow" target="_blank">放心</a>的测试时给定模式，作为<a class="ae mv" href="http://dannorth.net/introducing-bdd/" rel="noopener ugc nofollow" target="_blank">行为驱动开发</a> (BDD)的一部分而流行。此外，每个测试都使用JUnit的<code class="fe mr ms mt mu b">@Test</code>注释。根据文档，这个注释表明被注释的方法是一个测试方法。因此，使用此批注的方法不能是私有的或静态的，并且不能返回值。</p><figure class="mc md me mf gt mg"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="cc26" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">使用Gradle从项目的根:<code class="fe mr ms mt mu b">./gradlew clean build test</code>运行集成测试。一个详细的“测试总结”以HTML格式生成在项目的<code class="fe mr ms mt mu b">build</code>目录中，以便于审查。</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi oh"><img src="../Images/a71e696c6137224ab11694a635f1455e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d85KHYOswOJt6Rt1vf4z0g.png"/></div></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">测试详情</figcaption></figure><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi oh"><img src="../Images/cf561506dbfd71b29f8debecdb1649e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vx3H5feuvT-s2clicbGkgg.png"/></div></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">测试详情</figcaption></figure><h1 id="34cb" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">对服务进行负载测试</h1><p id="cc2a" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在生产中，Spring Boot服务将需要处理多个并发用户对Amazon Athena执行查询。</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi oh"><img src="../Images/86d19b525c07be6cb3483b2578c66d15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yXF1zRq7G8fvGUBBx6dxNQ.png"/></div></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">Athena的最近查询控制台显示了正在排队和执行的多个并发查询</figcaption></figure><p id="9e80" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">我们可以使用各种负载测试工具来评估服务处理多个并发用户的能力。其中最简单的一个是我最喜欢的基于go的实用程序<code class="fe mr ms mt mu b"><a class="ae mv" href="https://github.com/rakyll/hey" rel="noopener ugc nofollow" target="_blank">hey</a></code>，它在提供的并发级别中使用提供的请求数量将负载发送到URL，并打印统计数据。它还支持HTTP2端点。例如，我们可以使用<code class="fe mr ms mt mu b">hey</code>对Spring Boot服务的<code class="fe mr ms mt mu b">/users</code>端点执行500个并发级别为25的HTTP请求。《邮报》的集成测试是针对部署在亚马逊EKS的三个Kubernetes服务副本进行的。</p><pre class="mc md me mf gt my mu mz na aw nb bi"><span id="4dc6" class="nc kj it mu b gy nd ne l nf ng">hey -n 500 -c 25 -T "application/json;charset=UTF-8" \<br/>  -h2 <a class="ae mv" href="https://athena.example-api.com/v1/users" rel="noopener ugc nofollow" target="_blank">https://athena.example-api.com/v1/users</a></span></pre><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi oj"><img src="../Images/2c2e556013eee5b639b84e8d9c6985d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P9UMH2pLxc5HvQkF3izxJw.png"/></div></div></figure><p id="d504" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">从Athena的最近查询控制台，我们看到许多并发查询正在排队，并由一个<code class="fe mr ms mt mu b">hey</code>通过Spring Boot服务的端点执行。</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi oh"><img src="../Images/aaaa14a4e10200a99e381d0dde9da4ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n27beo7fYbdW0ZiKAXWC1A.png"/></div></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">Athena的最近查询控制台显示正在排队和执行的同步查询</figcaption></figure><h1 id="d970" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">韵律学</h1><p id="f0ac" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">Spring Boot服务实现了<code class="fe mr ms mt mu b"><a class="ae mv" href="https://quarkus.io/guides/micrometer" rel="noopener ugc nofollow" target="_blank">micrometer-registry-prometheus</a></code>扩展。微米度量库公开了运行时和应用度量。<a class="ae mv" href="https://micrometer.io/" rel="noopener ugc nofollow" target="_blank">千分尺</a>定义了一个核心库，提供了度量和核心度量类型的注册机制。这些指标由服务的<code class="fe mr ms mt mu b">/v1/actuator/prometheus</code>端点公开。</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi ok"><img src="../Images/7c51d350b6f2a8ff841597bdcaf1c72a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lts9C8SGEqLFRHBYzqGoWQ.png"/></div></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">使用Prometheus端点公开的指标</figcaption></figure><p id="1ca6" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">使用千分尺扩展，由<code class="fe mr ms mt mu b">/v1/actuator/prometheus</code>端点暴露的指标可以通过工具如<a class="ae mv" href="https://prometheus.io/" rel="noopener ugc nofollow" target="_blank">普罗米修斯</a>刮取和可视化。方便的是，AWS为普罗米修斯(AMP) 提供完全托管的<a class="ae mv" href="https://docs.aws.amazon.com/grafana/latest/userguide/prometheus-data-source.html" rel="noopener ugc nofollow" target="_blank">亚马逊托管服务，该服务可以轻松与亚马逊EKS集成。</a></p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi mx"><img src="../Images/f9782f07e8045034cf0782ed30063fc7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R5KzLCTEktc7ElmNjXtkYQ.png"/></div></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">Prometheus从Spring Boot服务收集的HTTP服务器请求的图形</figcaption></figure><p id="09e4" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">使用Prometheus作为数据源，我们可以在<a class="ae mv" href="https://grafana.com/" rel="noopener ugc nofollow" target="_blank"> Grafana </a>中构建仪表板来观察服务的指标。像AMP一样，AWS也提供完全管理的<a class="ae mv" href="https://aws.amazon.com/grafana/" rel="noopener ugc nofollow" target="_blank">亚马逊管理的Grafana </a> (AMG)。</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi ok"><img src="../Images/6a49784e5d33309fed6618addfd7e42f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x3FFwa1I2yQ0myrcz1P-eg.png"/></div></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">Grafana仪表板显示部署到亚马逊EKS的普罗米修斯Spring Boot服务的指标</figcaption></figure><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi ok"><img src="../Images/56cee12bca5eb567a14ec39691c96e56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wdVe08sdke2rkqyyNCI_nA.png"/></div></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">Grafana仪表板显示部署到亚马逊EKS的Prometheus for Spring Boot服务的JVM指标</figcaption></figure><h1 id="f966" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">结论</h1><p id="aebb" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这篇文章告诉我们如何创建一个Spring Boot RESTful Web服务，允许终端用户应用程序安全地查询存储在AWS上的数据湖中的数据。该服务使用AWS SDK for Java，通过使用Amazon Athena的AWS Glue数据目录来访问存储在亚马逊S3的数据。</p></div><div class="ab cl ol om hx on" role="separator"><span class="oo bw bk op oq or"/><span class="oo bw bk op oq or"/><span class="oo bw bk op oq"/></div><div class="im in io ip iq"><p id="c6d8" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">这篇博客代表我自己的观点，而不是我的雇主亚马逊网络服务公司(AWS)的观点。所有产品名称、徽标和品牌都是其各自所有者的财产。除非另有说明，所有图表和插图都是作者的财产。</p></div></div>    
</body>
</html>