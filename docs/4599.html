<html>
<head>
<title>End-to-end from front-end to back-end with Catcher</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从前端到后端的端到端，带捕捉器</h1>
<blockquote>原文：<a href="https://itnext.io/end-to-end-from-front-end-to-back-end-with-catcher-c6d8e0388258?source=collection_archive---------5-----------------------#2020-08-02">https://itnext.io/end-to-end-from-front-end-to-back-end-with-catcher-c6d8e0388258?source=collection_archive---------5-----------------------#2020-08-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="46ee" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">捕手外部模块<strong class="js iu"> 5.1.0 </strong>终于发布了。这是个好消息，因为它支持Selenium step进行前端测试！</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/6c884fc631660a5a6e835720c5bea56f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1156/format:webp/1*jwyW6SdjnpY0lj25FFo0-w.jpeg"/></div></div></figure><h1 id="cc26" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">正确的e2e测试应该是什么样的？</h1><p id="24af" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">假设您有一个带有漂亮UI的用户服务，它允许您获取在您的系统中注册的用户的信息。在后端深处，您还有一个审计日志，它保存所有的操作。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi md"><img src="../Images/642e30b4cdc64fceabd5c3c3fe1fe860.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/format:webp/0*wF6C3ALOpRvGBO2P.png"/></div></div></figure><p id="e921" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在5.1.0之前，您可以使用HTTP调用来模拟前端行为，以触发后端的一些动作。</p><p id="83fc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您的测试可能看起来像这样:<br/> -调用http端点来搜索用户<br/> -检查搜索事件是否保存到数据库中<br/> -将找到的用户与保存在数据库中的搜索事件进行比较</p><p id="bfe9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该测试检查100%的后端功能。但是前端很可能也是您系统的一部分！因此<strong class="js iu">正确的</strong>端到端测试应该从<strong class="js iu">前端</strong>应用开始，在<strong class="js iu">后端</strong>结束。</p><p id="059d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果不接触前端，你可能会在e2e测试中得到假阳性结果。一个用户的名字中有一些特殊的符号。所有后端测试都通过了，您就可以在生产中部署您的应用程序了。部署之后，您的用户开始抱怨应用程序的前端部分崩溃。原因是——在渲染名字中带有特殊符号的用户详情时，前端无法处理后端的响应。</p><p id="fcc6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用新的Catcher版本，您可以在测试中包含前端。所以——你可以使用<a class="ae me" href="https://catcher-modules.readthedocs.io/en/latest/source/selenium.html" rel="noopener ugc nofollow" target="_blank"> selenium </a> step来代替调用http。</p><h1 id="4f08" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">测试</h1><p id="a43a" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">让我们编写一个测试，它将搜索一个用户，并检查我们的搜索尝试是否被记录。</p><p id="bd63" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">每个测试都是从变量开始的。为了避免误报结果，我们需要保存多个用户，然后检查是否只返回正确的用户。让我们组成我们的用户。由于<a class="ae me" href="https://catcher-test-tool.readthedocs.io/en/latest/source/catcher.modules.filter_impl.html#catcher.modules.filter_impl.bifs.function_random" rel="noopener ugc nofollow" target="_blank">随机</a>内置功能，每个用户都将拥有一个随机的电子邮件和随机的名字。</p><pre class="kp kq kr ks gt mf mg mh mi aw mj bi"><span id="a8a2" class="mk lb it mg b gy ml mm l mn mo">variables: <br/>  users: <br/>    - name: '{{ random("name") }}' <br/>      email: '{{ random("email") }}' <br/>    - name: '{{ random("name") }}' <br/>      email: '{{ random("email") }}' <br/>    - name: '{{ random("name") }}' <br/>      email: '{{ random("email") }}'</span></pre><p id="18aa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们准备写我们的<code class="fe mp mq mr mg b">steps</code>。</p><h2 id="5d4a" class="mk lb it bd lc ms mt dn lg mu mv dp lk kb mw mx lo kf my mz ls kj na nb lw nc bi translated">填充数据</h2><p id="ae71" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">我们需要做的第一步是用<a class="ae me" href="https://catcher-modules.readthedocs.io/en/latest/source/prepare_expect.html" rel="noopener ugc nofollow" target="_blank">准备</a>步骤填充数据。</p><p id="f72a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们准备一个<code class="fe mp mq mr mg b">users.sql</code>，它将创建所有后端表(在干净运行的情况下，我们没有它们)。</p><pre class="kp kq kr ks gt mf mg mh mi aw mj bi"><span id="6aea" class="mk lb it mg b gy ml mm l mn mo">CREATE TABLE if not exists users_table( <br/>     email varchar(36) primary key, <br/>     name varchar(36) NOT NULL <br/>);</span></pre><p id="822d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来——我们需要用测试数据填充表格。<code class="fe mp mq mr mg b">users.csv</code>将使用我们的<code class="fe mp mq mr mg b">users</code>变量为我们的步骤准备数据。</p><pre class="kp kq kr ks gt mf mg mh mi aw mj bi"><span id="b933" class="mk lb it mg b gy ml mm l mn mo">email,name <br/>{%- for user in users -%} <br/>{{ user.email }},{{ user.name }} <br/>{%- endfor -%}</span></pre><p id="ec10" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果需要，该步骤本身将采用<code class="fe mp mq mr mg b">users.sql</code>并创建数据库表。然后它将基于<code class="fe mp mq mr mg b">users</code>变量使用<code class="fe mp mq mr mg b">users.csv</code>填充它。</p><pre class="kp kq kr ks gt mf mg mh mi aw mj bi"><span id="f3ac" class="mk lb it mg b gy ml mm l mn mo">steps: <br/>  - prepare: <br/>      populate: <br/>        postgres: <br/>          conf: '{{ postgres }}' <br/>          schema: users_table.sql <br/>          data: <br/>            users: users.csv <br/>      name: Populate postgres with {{ users|length }} users</span></pre><h2 id="f1ee" class="mk lb it bd lc ms mt dn lg mu mv dp lk kb mw mx lo kf my mz ls kj na nb lw nc bi translated">选择要搜索的用户</h2><p id="d4c6" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">下一步(小)是为我们的搜索选择一个用户。<a class="ae me" href="https://catcher-test-tool.readthedocs.io/en/latest/source/catcher.steps.html?highlight=echo#module-catcher.steps.echo" rel="noopener ugc nofollow" target="_blank"> Echo </a>步骤将从<code class="fe mp mq mr mg b">users</code>变量中随机选择用户，并将其电子邮件注册为一个新变量。</p><pre class="kp kq kr ks gt mf mg mh mi aw mj bi"><span id="b4ff" class="mk lb it mg b gy ml mm l mn mo">- echo: <br/>    from: '{{ random_choice(users).email }}' <br/>    register: {search_for: '{{ OUTPUT }}'} <br/>    name: 'Select {{ search_for }} for search'</span></pre><h2 id="aa95" class="mk lb it bd lc ms mt dn lg mu mv dp lk kb mw mx lo kf my mz ls kj na nb lw nc bi translated">为我们的用户搜索前端</h2><p id="f55d" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">通过<a class="ae me" href="https://catcher-modules.readthedocs.io/en/latest/source/catcher_modules.frontend.html#catcher_modules.frontend.selenium.Selenium" rel="noopener ugc nofollow" target="_blank"> Selenium </a>步骤，我们可以使用我们的前端来搜索用户。Selenium step从resources目录运行JS/Java/Jar/Python中的脚本。</p><p id="a2a9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它将Catcher的变量作为环境变量传递给脚本，因此您可以在Selenium中访问它。它还greps了脚本的输出，因此您可以访问Catcher后续步骤中的所有内容。</p><pre class="kp kq kr ks gt mf mg mh mi aw mj bi"><span id="e6ed" class="mk lb it mg b gy ml mm l mn mo">- selenium: <br/>    test: <br/>      file: register_user.js <br/>      driver: '/usr/lib/geckodriver' <br/>    register: {title: '{{ OUTPUT.title }}'}</span></pre><p id="2f18" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该脚本将运行register_user来搜索我们选择的用户，并将注册页面的标题。</p><h2 id="930f" class="mk lb it bd lc ms mt dn lg mu mv dp lk kb mw mx lo kf my mz ls kj na nb lw nc bi translated">检查搜索日志</h2><p id="3665" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">在我们完成搜索后，我们需要检查它是否被记录。想象一下我们的后端用的是MongoDB。所以我们将使用<a class="ae me" href="https://catcher-modules.readthedocs.io/en/latest/source/catcher_modules.database.html#catcher-modules-database-mongo-module" rel="noopener ugc nofollow" target="_blank"> mongo </a> step。</p><pre class="kp kq kr ks gt mf mg mh mi aw mj bi"><span id="f0ff" class="mk lb it mg b gy ml mm l mn mo">- mongo: <br/>    request: <br/>      conf: '{{ mongo }}' <br/>      collection: 'search_log' <br/>      find: {'text': '{{ search_for }}'} <br/>    register: {search_log: '{{ OUTPUT }}'}</span></pre><p id="554e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这一步在MongoDB <code class="fe mp mq mr mg b">search_log</code>集合中搜索我们用户的任何文本搜索尝试。</p><h2 id="eb4b" class="mk lb it bd lc ms mt dn lg mu mv dp lk kb mw mx lo kf my mz ls kj na nb lw nc bi translated">比较结果</h2><p id="441c" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">最终步骤与结果比较相关。首先——我们将再次使用<code class="fe mp mq mr mg b">echo</code>来转换我们的<code class="fe mp mq mr mg b">users</code>,以便我们可以通过电子邮件搜索用户。</p><pre class="kp kq kr ks gt mf mg mh mi aw mj bi"><span id="b197" class="mk lb it mg b gy ml mm l mn mo">- echo: <br/>    from: '{{ users|groupby("email")|asdict }}' <br/>    register: {users_kv: '{{ OUTPUT }}'}</span></pre><p id="3024" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第二—我们将把从selenium获得的前端页面标题与MongoDB搜索日志和用户名进行比较。</p><pre class="kp kq kr ks gt mf mg mh mi aw mj bi"><span id="0e09" class="mk lb it mg b gy ml mm l mn mo">- check: <br/>    and: <br/>      - equals: {the: '{{ users_kv[search_for][0].name }}', is: '{{ title }}'} <br/>      - equals: {the: '{{ title }}', is: '{{ search_log.name }}'}</span></pre><h1 id="fe39" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">硒资源</h1><p id="df1c" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">让我们添加一个Selenium测试资源。它将进入你的网站并搜索你的用户。如果一切正常，页面标题将是这一步的结果。</p><h2 id="8cfa" class="mk lb it bd lc ms mt dn lg mu mv dp lk kb mw mx lo kf my mz ls kj na nb lw nc bi translated">java描述语言</h2><p id="83a5" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">Selenium step支持Java、JS、Python和Jar归档。在本文中，我将向您展示它们(除了Jar，它与Java相同，但没有编译)。让我们从JavaScript开始。</p><pre class="kp kq kr ks gt mf mg mh mi aw mj bi"><span id="40d3" class="mk lb it mg b gy ml mm l mn mo">const {Builder, By, Key, until} = require('selenium-webdriver');<br/>async function basicExample() {<br/>  let driver = await new Builder().forBrowser('firefox').build();<br/>  try{<br/>    await driver.get(process.env.site_url);<br/>    await driver.findElement(By.name('q')).sendKeys(process.env.search_for, Key.RETURN);<br/>    await driver.wait(until.titleContains(process.env.search_for), 1000);<br/>    await driver.getTitle().then(function(title) {<br/>      console.log('{\"title\":\"' + title + '\"}')<br/>    });<br/>    driver.quit();<br/>  }<br/>  catch(err) {<br/>    console.error(err);<br/>    process.exitCode = 1;<br/>    driver.quit();<br/>  }<br/>}<br/>basicExample();</span></pre><p id="a502" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Catcher将其所有变量作为环境变量传递，因此您可以从JS/Java/Python访问它们。本例中的<code class="fe mp mq mr mg b">process.env.site_url</code>从Catcher的变量中获取site_url，而<code class="fe mp mq mr mg b">process.env.search_for</code>获取用户电子邮件来搜索它。</p><p id="1c3a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你写到STDOUT的所有东西都被Catcher捕获。在JSON的情况下，它将作为字典返回。带有<code class="fe mp mq mr mg b">console.log('{\"title\":\"' + title + '\"}')</code>声明的f . e .<code class="fe mp mq mr mg b">OUTPUT.title</code>将在捕手侧可用。如果Catcher不能解析JSON，它将返回一个文本作为<code class="fe mp mq mr mg b">OUTPUT</code>。</p><h2 id="d4af" class="mk lb it bd lc ms mt dn lg mu mv dp lk kb mw mx lo kf my mz ls kj na nb lw nc bi translated">计算机编程语言</h2><p id="6422" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">下面是同一资源的Python实现。也应该放在<code class="fe mp mq mr mg b">resources</code>目录下。要使用它代替Java实现，您需要在Selenium步骤中更改<code class="fe mp mq mr mg b">file</code>参数。</p><pre class="kp kq kr ks gt mf mg mh mi aw mj bi"><span id="a69b" class="mk lb it mg b gy ml mm l mn mo">from selenium import webdriver<br/>from selenium.webdriver.common.keys import Keys<br/>import os<br/>from selenium.webdriver.firefox.options import Options<br/><br/>options = Options()<br/>options.headless = True<br/>driver = webdriver.Firefox(options=options)<br/>try:<br/>    driver.get(os.environ['site_url'])<br/>    assert "Python" in driver.title<br/>    elem = driver.find_element_by_name("q")<br/>    elem.clear()<br/>    elem.send_keys(os.environ['search_for'])<br/>    elem.send_keys(Keys.RETURN)<br/>    assert "No results found." not in driver.page_source<br/>    print(f'{"title":"{driver.title}"')<br/>finally:<br/>    driver.close()</span></pre><h2 id="f830" class="mk lb it bd lc ms mt dn lg mu mv dp lk kb mw mx lo kf my mz ls kj na nb lw nc bi translated">Java 语言(一种计算机语言，尤用于创建网站)</h2><p id="08d9" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">Java稍微复杂一点，因为(如果您没有使用已经编译过的Jar) Catcher应该在运行之前编译Java源代码。为此，您需要在系统中安装Java和Selenium库。</p><p id="c137" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">幸运的是，Catcher附带了Docker <a class="ae me" href="https://hub.docker.com/repository/docker/comtihon/catcher" rel="noopener ugc nofollow" target="_blank"> image </a>，其中安装了库(JS、Java、Python)、Selenium驱动程序(Firefox、Chrome、Opera)和工具(NodeJS、JDK、Python)。</p><pre class="kp kq kr ks gt mf mg mh mi aw mj bi"><span id="0433" class="mk lb it mg b gy ml mm l mn mo">package selenium;<br/><br/>import org.openqa.selenium.By; <br/>import org.openqa.selenium.WebDriver;<br/>import org.openqa.selenium.WebElement;<br/>import org.openqa.selenium.firefox.FirefoxDriver;<br/>import org.openqa.selenium.firefox.FirefoxBinary;<br/>import org.openqa.selenium.firefox.FirefoxOptions;<br/><br/>public class MySeleniumTest {<br/><br/>    public static void main(String[] args) {<br/>        FirefoxBinary firefoxBinary = new FirefoxBinary();<br/>        FirefoxOptions options = new FirefoxOptions();<br/>        options.setBinary(firefoxBinary);<br/>        options.setHeadless(true);<br/>        WebDriver driver = new FirefoxDriver(options);<br/>        try {<br/>            driver.get(System.getenv("site_url"));<br/>            WebElement element = driver.findElement(By.name("q"));<br/>            element.sendKeys(System.getenv("search_for"));<br/>            element.submit();<br/>            System.out.println("{\"title\":\""+driver.getTitle() + "\"}");<br/>        } finally {<br/>            driver.quit();<br/>        }<br/>    }<br/>}</span></pre><h1 id="6b0e" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">结论</h1><p id="86d0" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">Catcher的更新5.1.0统一了前端和后端测试，允许它们同时存在于一个测试用例中。它提高了覆盖率，使测试真正端到端。</p></div></div>    
</body>
</html>