<html>
<head>
<title>Byfrost Source Code Visualizer in Development 1— An Indexing Graph</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">开发1中的Byfrost源代码可视化工具—索引图</h1>
<blockquote>原文：<a href="https://itnext.io/byfrost-in-development-1-an-indexing-graph-b696282c734d?source=collection_archive---------0-----------------------#2022-07-24">https://itnext.io/byfrost-in-development-1-an-indexing-graph-b696282c734d?source=collection_archive---------0-----------------------#2022-07-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="8200" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个标题可能更好，但它确实与图表有很大关系，因此它至少不是虚假广告。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/e0e796f92ecb94a06325e0d4a05d50e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9kxqucvFtbdWUU3v6z5N-w.jpeg"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">但首先，一张彩虹桥状的东西的照片！</figcaption></figure><p id="cc43" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是我第一篇文章的延续，在那篇文章中，我在这里宣布了我的源代码路径可视化器；<a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/introducing-byfrost-a-source-code-path-visualizer-2d64002d1f9a">介绍by frost-一个源代码路径可视化工具</a>。</p><p id="d21e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，Byfrost的开发终于拉开了序幕，并得到了Reddit和Medium上的大量赞誉。我喜欢围绕这个工具的激动人心的事情，所以我想我应该让大家了解一下从零开始构建一个索引器的痛苦、令人心悸的悲剧。所以，请坐好，放松，凝视窗帘后面，很快，当主题公园开门的时候，你也可能会想到是什么促成了这个美丽的噩梦。</p><p id="7aab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么，在丢下那颗重磅炸弹后的两周里，我都在忙些什么呢？很多，然后突然什么都没有了，然后所有的事情都发生了！我很高兴地宣布，我们已经有了一个工作的后端！！🎉到目前为止的功能:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="lc ld l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">进步！！</figcaption></figure><p id="49e3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">UI需要大量的定位工作，但核心已经启动并运行！</p><p id="ba70" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们进入细节之前，让我们快速回顾一下一些变故:毕竟我不会首先支持C。我在Reddit上的一个我不愿称之为Q&amp;As的文章中说过，这个工具将支持C作为第一语言，现在我已经决定我确实不会这么做了。🤔。事实证明，C语言比我最初想象的要难解析得多。这是欺骗性的，因为缺乏结构使我认为这很容易做到，但这是一个谎言。</p><p id="5d68" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">另一个原因是这将是一个插件。是，也不是。它将是一个网络应用程序，但也是一个插件，但也是一个网络应用程序，因为我有点立即需要这个，我还没有学会插件开发。但是总有一天你会选择你的毒药。</p><p id="f82e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好吧，让我们开始吧！</p><h2 id="26e5" class="le lf iq bd lg lh li dn lj lk ll dp lm jy ln lo lp kc lq lr ls kg lt lu lv lw bi translated">我将在今天的更新中讨论什么</h2><p id="1de4" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">自从最初宣布这个小项目以来，我变得非常富有成效，这个项目已经覆盖了大量的领域。正因为如此，我将尽可能地保持“概述”的形式，以便在不把它变成小说的情况下，让读者理解索引器背后的思想。</p><p id="c4f7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我要过去了:</p><ul class=""><li id="1931" class="mc md iq jp b jq jr ju jv jy me kc mf kg mg kk mh mi mj mk bi translated">索引器的整体架构——算是吧(编辑:回想起来，我搁置了很多细节，因为这篇文章太长了)</li><li id="beb0" class="mc md iq jp b jq ml ju mm jy mn kc mo kg mp kk mh mi mj mk bi translated">索引方法以及将功能标签与各自的功能相关联</li></ul><p id="5e23" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个系统是用Golang后端和Angular前端编写的。为什么要去棱角分明？这是我日常工作中用到的语言，所以这是我唯一能及时找到的一堆语言。我是说，我的职业是围棋工程师，哇，那个棱角分明的家伙确实对我的生存意志造成了影响。虽然我使用了Angular前端，但我无意中使我的前端渲染结构与框架无关，主要是因为我无法用Angular的许多指令和内置的Angular“东西”完成大量的HTML动态渲染。我将在下面的<strong class="jp ir">方法</strong>部分详细介绍这一点。</p><h1 id="c973" class="mq lf iq bd lg mr ms mt lj mu mv mw lm mx my mz lp na nb nc ls nd ne nf lv ng bi translated">前端——与Angular的战斗</h1><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nh"><img src="../Images/e49237b4c2d477a6be68bec1145301c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X86zzdXODaL1Mdyf40iRPQ.jpeg"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">它就像看起来一样史诗</figcaption></figure><p id="da94" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">哦，天啊，这个角色多次踢到我的牙齿。我根本不是一个前端工程师，我必须在几周内学会这种技术，并达到一定程度才能完成这个任务，我要说的是:前端比后端难——等等！让我解释一下！把煎锅放下，布莱恩！！(这可能不是你的名字，但我想我会吓坏所有叫“布莱恩”的读者)。</p><p id="dbfc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我发现frontend类似于告诉一个画家从零开始画蒙娜丽莎，并且完全按照你在喝醉和遭受新的心碎时在昏暗的报纸上写的糟糕的指示。我对大多数看起来简单的东西最后的困难感到困惑。对于动态大规模HTML呈现，你需要一些技巧来避免代码被遗忘。</p><h1 id="534d" class="mq lf iq bd lg mr ms mt lj mu mv mw lm mx my mz lp na nb nc ls nd ne nf lv ng bi translated">方法</h1><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/b04739837c23c4de9ec38f0c9606bd82.png" data-original-src="https://miro.medium.com/v2/resize:fit:364/format:webp/1*aSZreGq5tBsfoxwGHDE48w.jpeg"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">…嗯嗯…</figcaption></figure><p id="e03f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这里，我将回顾我采用的三种方法，为什么它们失败了，为什么最后一种方法成功了。这将涵盖很多我与Angular的斗争。</p><p id="40db" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">方法1:运行时组件生成</strong></p><p id="98ef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对我来说，第一个直观方法是制作一个表示单个代码显示面板的角形组件。类似这样的东西；</p><pre class="km kn ko kp gt nj nk nl nm aw nn bi"><span id="3080" class="le lf iq nk b gy no np l nq nr">export class ByFrost implements whatever {<br/>  ...<br/>}</span></pre><p id="2a48" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这将容纳一切。它会有一些变量来组成一个单独的程序面板。</p><p id="bc2c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">类似于:</p><pre class="km kn ko kp gt nj nk nl nm aw nn bi"><span id="f90e" class="le lf iq nk b gy no np l nq nr">let filePath: string = "&lt;a (click)="openFile()"&gt;main.c&lt;/a&gt;"</span><span id="283b" class="le lf iq nk b gy ns np l nq nr">let sourceCode: string = "int main(int argc char **argv)\n{\n\t&lt;a (click)=\"newComponent()\"&gt;printf&lt;/a&gt;(\"hello world\");\n\treturn (0);...</span></pre><p id="d20e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe nt nu nv nk b">filePath</code>是…嗯…文件路径和<code class="fe nt nu nv nk b">sourceCode</code> …你明白了。</p><p id="f069" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这种方法的唯一问题是，这些指令(<code class="fe nt nu nv nk b">(click)="openFile"</code>)和另一个指令不能在运行时呈现，它们是编译时专有的细节。看到了；那些就是我之前提到的有棱角的“东西”(指令什么的)。他们所做的是将那些<code class="fe nt nu nv nk b">a</code>标签绑定到那些被点击时会在后台触发的目标函数上。<code class="fe nt nu nv nk b">openFile</code>会触发一个名为<code class="fe nt nu nv nk b">openFile</code>的函数，当你点击它时会触发这个函数。与<code class="fe nt nu nv nk b">printf</code>同样的故事。对于<code class="fe nt nu nv nk b">printf</code>,包含其源代码的新组件将被生成并附加到原始ByFrost组件上。这就是我们的想法。单击路径时打开文件；并在单击一个函数时创建一个新的函数组件。</p><p id="7196" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">超级简单。这能有多难，真的？</p><p id="ea55" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">哦，这预示着…</p><p id="08b2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我的朋友们，事实证明这是一个非常非常困难的主意，而且是一个非常糟糕的主意。</p><p id="2af2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">事实证明你不能这样做。在为此哭泣了无数个小时之后，我发现运行时编译那些角度标签/指令/等等真的是不可能的。不完全是。我全身心投入到这个方法中。部分原因是它让我觉得自己像一个真正的编译器工程师，我可以证明我花了这么多年努力成为一名编译器工程师是正确的。我甚至在研究Angular的即时编译器，看看我是否可以强迫它在运行时编译这些。我也会进入Angular源代码来强制修复(并使我的整个Angular设置成为垃圾，因为它会破坏CLI和使Angular不可怕的一切)，但我停下来，决定用下午剩下的时间在电影院看壮志凌云：独行侠。伟大的电影。</p><p id="3de4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">方法2:使用innerHTML进行渲染</strong></p><p id="33f0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这接近我最终决定的，但我的第一次尝试也有类似的问题。这次我没有生成新的组件。不，这一次，我只是有一个巨大的HTML字符串列表，表示代码显示面板，它将在一个Angular ngFor循环中输出。</p><p id="2b92" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是一种进步；事情是渲染，但我仍然有我的渲染没有编译角函数和标签的问题。</p><p id="c19e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我完全不知所措了。在所有的大张旗鼓之后；这些年来我一直在努力构建我的索引工具。这条路终于结束了吗？</p><p id="ab70" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">方法3:在后端准备所有前端功能</strong></p><p id="e0b2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这种新的思考方式是在与另一位后端工程师同事交谈时产生的。我遇到了一些小问题，这里我就不多说了，因为这篇文章会很长。这里的方法包括在HTML中完全去除角组件的使用；这是永远不会工作，因为动态HTML渲染是绝对必须的，这些从来没有编译。去除有棱角的“东西”实际上效果很好。这种方法的最后一个问题是，将HTML源代码呈现为一个超长字符串，然后管理函数和那些父函数调用的函数之间的动态关系很快就会变得混乱。我找不到任何一个函数调用来记住它们的父函数是什么以及它们与谁相关。</p><p id="9bc3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">举个简单的例子:</p><pre class="km kn ko kp gt nj nk nl nm aw nn bi"><span id="d340" class="le lf iq nk b gy no np l nq nr">void first() {<br/>   toRepeat();<br/>}</span><span id="60b8" class="le lf iq nk b gy ns np l nq nr">void second() {<br/>   toRepeat();<br/>}</span></pre><p id="4baa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦<code class="fe nt nu nv nk b">toRepeat</code>被点击展开，在HTML中没有层次结构的情况下，就没有办法看到<code class="fe nt nu nv nk b">toReturn</code>的调用来自哪个函数。它没有父母。一个迷失的，没有目标的孩子，在黑暗中徘徊…</p><p id="ccc3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，绞尽脑汁思考这最后一个问题时，我灵机一动…</p><h1 id="4ea7" class="mq lf iq bd lg mr ms mt lj mu mv mw lm mx my mz lp na nb nc ls nd ne nf lv ng bi translated">后端——文件系统，我的至爱</h1><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nx"><img src="../Images/52181e9bc2ef1f7b9d64adbf14c1b5e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tDV3ofXrMEQKIToZJWta-Q.jpeg"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">啊…这勾起了我的回忆。</figcaption></figure><p id="6628" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">守旧派读者可能还记得我大约一年前的旧的虚拟文件系统项目。这教会了我很多关于在Go中很好地处理树形数据结构中的层次关系的知识。</p><p id="16b6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这正是那种问题。函数体是目录，这些函数体调用的函数是子目录。</p><p id="a71f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我会这么做。这就是我如何在函数和它们的子函数调用之间建立关系。</p><p id="5dc3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有了这个新的范例，这个项目:</p><pre class="km kn ko kp gt nj nk nl nm aw nn bi"><span id="3bca" class="le lf iq nk b gy no np l nq nr">int  main() {<br/>  helloworld("test");<br/>  read_file("test2");<br/>}</span><span id="edc0" class="le lf iq nk b gy ns np l nq nr">char  helloworld(char i) {<br/>  testing(42);<br/>  return 'c';<br/>}</span><span id="3801" class="le lf iq nk b gy ns np l nq nr">int read_file(char *filename) {<br/> helloworld(filename[0]);<br/> return (0);<br/>}</span><span id="a83e" class="le lf iq nk b gy ns np l nq nr">int testing(int i) {<br/> return (0);<br/>}</span></pre><p id="c159" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将被转换为以下树形结构:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ny"><img src="../Images/932df46e5ba4e664ca8992633e01fea0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i0WXRpdCP5cG6Bs56zbYMQ.png"/></div></div></figure><p id="6f4d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每个函数都有一个唯一的路径，表示该函数的层次结构。<code class="fe nt nu nv nk b">read_file</code>的唯一路径将是<code class="fe nt nu nv nk b">main.read_file</code>，它对<code class="fe nt nu nv nk b">helloworld</code>的调用将把<code class="fe nt nu nv nk b">main.read_file.helloworld</code>作为路径，依此类推。</p><p id="6674" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">支持此功能的Go结构如下所示:</p><pre class="km kn ko kp gt nj nk nl nm aw nn bi"><span id="e0dc" class="le lf iq nk b gy no np l nq nr">type Display struct {<br/> name    string    //  read_file<br/> path    string    //  main.read_file</span><span id="759f" class="le lf iq nk b gy ns np l nq nr"> active    bool    //  when function expands, this is true.<br/> rawTokens []*Token</span><span id="a01e" class="le lf iq nk b gy ns np l nq nr">  // Display{<br/>  //   name:"hellowworld", <br/>  //   path: "main.read_file.hellowworld"<br/>  // ...  }<br/>  childDisplays map[string]*Display<br/>}</span></pre><p id="a761" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe nt nu nv nk b">name</code>是当前函数的名称，像<code class="fe nt nu nv nk b">main</code>一样，<code class="fe nt nu nv nk b">childDisplays</code>为函数<code class="fe nt nu nv nk b">main</code>调用持有自己的显示；在我们的例子中，<code class="fe nt nu nv nk b">read_file</code>和<code class="fe nt nu nv nk b">helloworld</code>的显示。<code class="fe nt nu nv nk b">active</code>用于折叠逻辑。当一个函数被点击时，这个值将决定它是被展开还是被折叠。最后，我们还有<code class="fe nt nu nv nk b">rawTokens</code>。它们在一个数组中保存了所有的标记，这些标记在视觉上构成了当前的函数，并保存了Angular将解释的UI配置信息，以使其更加美观。</p><p id="da4c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe nt nu nv nk b">rawTokens</code>是从lexer和解析阶段构建的，但是有一个额外的目的，即确定哪些标签在前端是可点击的，并且在将来，将为我必须手工构建的语法突出显示保存样式信息(稍后您将看到为什么)。因此，我们将在以后的文章中讨论这个问题。</p><p id="33ef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这样，由上面的<code class="fe nt nu nv nk b">path</code>值保存的每个函数链接将在前端为每个函数标签调用附加一个唯一的ID，当点击时，将立即准确地识别哪个路径被扩展。这也使得精确的函数路径折叠成为可能。因此，当你点击一个已经扩展的函数时，再次点击它会将<code class="fe nt nu nv nk b">active</code>设置为false，当这种情况发生时，当前函数的所有子函数的递归循环将被解析，并全部设置为false，从而触发Angular在UI中删除它们。</p><p id="8b65" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">随着最后的调整，这也允许每个面板是他们自己的干净，独立的自我，并采取以下形状；</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nz"><img src="../Images/98929e66ae4dfbd8429f8b186c2f2d7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1TF_bAP4fBrPTO5OgO-IoQ.png"/></div></div></figure><p id="ea1d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我喜欢每个功能面板的这种设计，因为从UI的角度来看，这意味着每个单独的块都可以被设计成不同的样式，而不会相互重叠。它还使得添加和删除代码块变得非常容易，因为HTML DIV主体彼此不相关(没有嵌套子元素或类似的东西)。</p><p id="ed09" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这也在很大程度上使得前端框架不可知。由于没有使用特定于角度的结构，这很容易被移植到React甚至JQuery(但愿不会如此)。当我最初出发时，我不知道会发生这种事，但这是一个令人高兴的意外。这也会让造型变得更加容易。</p></div><div class="ab cl oa ob hu oc" role="separator"><span class="od bw bk oe of og"/><span class="od bw bk oe of og"/><span class="od bw bk oe of"/></div><div class="ij ik il im in"><p id="5a24" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">至此这条路就到此为止了。接下来我会提到一些我在文章中找不到合适位置的荣誉。</p><h1 id="36c4" class="mq lf iq bd lg mr ms mt lj mu mv mw lm mx my mz lp na nb nc ls nd ne nf lv ng bi translated">一些可敬的提及</h1><p id="597b" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">这是我认为我做过的最难的事情。前端变成了一个相当大的怪物，我遇到了相当多的障碍。</p><p id="2a2f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于一些可敬的提及，我想涵盖其中一些；我遇到的问题和我试图克服它们的策略。我还将回顾集成新语言支持的未来，并将所有这些从web应用程序转变为插件。</p><ul class=""><li id="49d4" class="mc md iq jp b jq jr ju jv jy me kc mf kg mg kk mh mi mj mk bi translated"><strong class="jp ir">画线</strong>——这是目前为止分割前端HTML显示获益匪浅的一件事。最初我打算用一些粗糙的方法手工绘制它们——也许计算出每个面板实时出现的位置，然后画出一些起伏的线条。但是使用传统的JavaScript和Angular来发号施令，这是我一直在纠结的事情。做一些简单的事情，比如用<code class="fe nt nu nv nk b">getElementById</code>引用HTML元素，从StackOverflow中复制代码(因为我确实这么做了)来定位行的目的地，从来没有成功过。我怀疑这是传统的JS步骤。谢天谢地，有一个为Angular设计的叫做<code class="fe nt nu nv nk b">linear-line</code>的很棒的库，它做到了。使用没有关系的问题捆绑HTML DIVs给父母节省了我很多痛苦。然后就是把库导入Angular…现在杀了我吧…💀。</li><li id="6b67" class="mc md iq jp b jq ml ju mm jy mn kc mo kg mp kk mh mi mj mk bi translated"><strong class="jp ir">语法突出显示— </strong>好吧，我真的被这个冒犯了，因为这应该是一个容易摘到的果子；去网上下载一些我在虚拟文件系统的文本编辑器中使用的可爱的Ace编辑器动作，把它切换到readonly，然后砰，午餐开始了。不幸的是没有——添加Ace会禁用我所有的按钮，所以点击功能不再扩展任何东西。不过不用担心，谷歌有一个名为<a class="ae lb" href="https://code.google.com/archive/p/google-code-prettify/" rel="noopener ugc nofollow" target="_blank">pre tify</a><em class="nw">的奇特库，除了它是垃圾！</em>说真的，突出这一点很难做到！这也不太顺利。尽管平心而论，我确信这个库工作得很好，如果它不是被如此不客气地强迫成Angular或什么的。这一次，我不断遇到语法突出问题，我的文本不改变颜色，有时不“打开”这里和那里，所以他妈的。我是这个坏家伙的第一原则。在C的情况下如果我们想到Vim的高亮；数据类型是绿色的，控制流语句是黄色的，文字是粉红色的，所以我做了自己的语法高亮显示，这将是一个使用的梦想。我有一个工作规范，因为我别无选择，只能在发布日把它做好。这能有多难…</li><li id="a944" class="mc md iq jp b jq ml ju mm jy mn kc mo kg mp kk mh mi mj mk bi translated">语言API——这也需要很多关注和一些正式的规范。到目前为止，添加语言非常非常困难，因为它们都非常不同。我决定放弃C，专注于Go，因为它有自己的原生解析器库。我认为C会更容易，因为它缺乏结构，但它看起来很乱，我找不到一个开源解析器来满足我的需要。在阳光下插入所有语言将是一个巨大的任务。从编译器开发人员那里获得这方面的帮助是非常好的。</li><li id="56f4" class="mc md iq jp b jq ml ju mm jy mn kc mo kg mp kk mh mi mj mk bi translated"><strong class="jp ir">使它成为一个插件</strong>——现在，我将把它作为第一个版本的网络应用，同时为VSCode完善一个插件，因为这很难…</li></ul><p id="64e1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是目前的情况。在过去的三周里，我做了大量的工作，涵盖了太多的领域，无法在一篇文章中全部展开，尽管如此，这篇文章无疑是我写过的最长的一篇。</p><h1 id="58a2" class="mq lf iq bd lg mr ms mt lj mu mv mw lm mx my mz lp na nb nc ls nd ne nf lv ng bi translated">路线图</h1><p id="7fda" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">至于在我们得到第一个初始alpha版本之前路线图上还剩下什么:</p><ul class=""><li id="5ed2" class="mc md iq jp b jq jr ju jv jy me kc mf kg mg kk mh mi mj mk bi translated"><strong class="jp ir">语法突出显示</strong>——现在只有一个主题，因为我充实了库和语法突出显示的方法。</li><li id="1494" class="mc md iq jp b jq ml ju mm jy mn kc mo kg mp kk mh mi mj mk bi translated"><strong class="jp ir"> Go移植</strong> —该工具只有在Go掉落时才可用。Go是我在日常生活中使用的语言，它有解析器支持。这种健康的支持也将有助于确定某种语言API或服务的标准。</li><li id="4538" class="mc md iq jp b jq ml ju mm jy mn kc mo kg mp kk mh mi mj mk bi translated"><strong class="jp ir">代码面板的定位和大小</strong> —这有点棘手，因为现在所有的面板看起来都是相同的大小，并沿着页面向下流动。让它们以一种更“可读”的风格向右展开是Byfrost要实现的最后一个特性。</li></ul><p id="0c29" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是我在开发帖子中对第一篇Byfrost的全部介绍。</p><p id="44ba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我会发布更多的更新，并准备一个阿尔法发送一些早期测试。如果你想尝试一下，我会在某个地方建立一个你可以注册的地方(看看我在那里做了什么)。</p><p id="de73" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当然，Github回购仍在进行中。</p><p id="95df" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">很快聊天！👋</p><p id="a327" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">艾莉森</p></div></div>    
</body>
</html>