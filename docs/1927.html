<html>
<head>
<title>Angular for React Developers: Differences and Component API comparison</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React开发人员的角度:差异和组件API比较</h1>
<blockquote>原文：<a href="https://itnext.io/angular-for-react-developers-63239f278158?source=collection_archive---------2-----------------------#2019-02-25">https://itnext.io/angular-for-react-developers-63239f278158?source=collection_archive---------2-----------------------#2019-02-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="6821" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这不是另一篇Angular vs React文章。我为对Angular感兴趣的React开发人员写了这篇文章，反之亦然。我将主要探索两个框架中的组件API，它们如何相互比较，以及它们如何解决相同的问题。</p><h2 id="2530" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">组件:</h2><p id="9e47" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">让我们比较一下两个框架中的组件API。React中一个非常简单的类组件如下所示</p><pre class="lj lk ll lm gt ln lo lp lq aw lr bi"><span id="4091" class="kl km iq lo b gy ls lt l lu lv">import React, { Component } from 'react'<br/>import './App.css'</span><span id="16d0" class="kl km iq lo b gy lw lt l lu lv">export class App extends Component {</span><span id="a745" class="kl km iq lo b gy lw lt l lu lv">  render () {</span><span id="ac6c" class="kl km iq lo b gy lw lt l lu lv">    return &lt;div&gt; Hello world &lt;/div&gt;</span><span id="dfd2" class="kl km iq lo b gy lw lt l lu lv">  }</span><span id="2ec6" class="kl km iq lo b gy lw lt l lu lv">}</span></pre><p id="1ffd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这将是角度的等效实现</p><pre class="lj lk ll lm gt ln lo lp lq aw lr bi"><span id="0303" class="kl km iq lo b gy ls lt l lu lv">import { Component } from '@angular/core'</span><span id="1aa1" class="kl km iq lo b gy lw lt l lu lv">@Component({</span><span id="8220" class="kl km iq lo b gy lw lt l lu lv">  selector: 'app-component',</span><span id="36b1" class="kl km iq lo b gy lw lt l lu lv">  template: `&lt;div&gt; Hello world &lt;/div&gt;`,</span><span id="fc38" class="kl km iq lo b gy lw lt l lu lv">  styleUrls: ['./app.component.css']</span><span id="c9ff" class="kl km iq lo b gy lw lt l lu lv">})</span><span id="766c" class="kl km iq lo b gy lw lt l lu lv">export class AppComponent {}</span></pre><h2 id="7ab7" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">将输入传递给组件并处理事件:</h2><p id="c133" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">在React中，您可以通过<code class="fe lx ly lz lo b">props</code>将输入绑定传递给组件，并以同样的方式将回调函数传递给子组件，以处理子组件中发生的事件。</p><figure class="lj lk ll lm gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi ma"><img src="../Images/c8d1b935bfb6d08020d32d467137b27c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MhlEsKTP_bqJ3z07wqhvdA.png"/></div></div></figure><p id="c0af" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在Angular中，您依靠<code class="fe lx ly lz lo b">@Input()</code>装饰器将属性绑定传递给子组件，依靠<code class="fe lx ly lz lo b">@Output()</code>装饰器将定制事件发送给父组件进行处理。让我们看看这是如何看起来有角度的</p><figure class="lj lk ll lm gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi mi"><img src="../Images/7814ebc0f40e6b7cedc3589dc6666674.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LM3-MdPxJiGWLfbs9yEZXg.png"/></div></div></figure><p id="4739" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">子组件有一个EventEmitter，当按钮被单击时，它向父组件发出事件。父组件通过<code class="fe lx ly lz lo b">(buttonClicked)</code>监听DOM/output事件，并处理实现。</p><p id="e4fd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">另一件你可能已经注意到的事情是，这里没有<code class="fe lx ly lz lo b">props</code>或<code class="fe lx ly lz lo b">state</code>，所有的东西都连接到<code class="fe lx ly lz lo b">this</code>上。相反，通常在模板中使用公共变量，所以这是Angular中你能得到的最接近状态的变量。您可能还注意到了模板中方括号和圆括号的奇怪语法。这就给我们带来了两个框架中的模板差异。</p><h2 id="699d" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">模板:</h2><p id="85cc" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">React依靠JSX进行模板化，这基本上只是一种语法糖，它以封装了<code class="fe lx ly lz lo b">document.createElement()</code>的<code class="fe lx ly lz lo b">React.createElement()</code>形式转换成JavaScript。</p><p id="7e17" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Angular有自己的领域特定语言(DSL ),允许我们在普通html之上编写Angular特定的类似html的语法。它也有自己的编译器，将这种语法编译成浏览器可以理解的html。在Angular的DSL语言中，主要有3种主要语法。<code class="fe lx ly lz lo b">*</code>、<code class="fe lx ly lz lo b">()</code>和<code class="fe lx ly lz lo b">[]</code>。</p><p id="4327" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lx ly lz lo b">()</code>用于输出和DOM事件</p><p id="7779" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lx ly lz lo b">[]</code>用于输入特定的DOM元素属性</p><p id="40f0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lx ly lz lo b">*</code>表示这是一个结构指令。会影响/改变DOM结构的东西。如<code class="fe lx ly lz lo b">*ngFor</code>或<code class="fe lx ly lz lo b">*ngIf.</code></p><h2 id="30d7" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">生命周期挂钩</h2><p id="7622" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">两个框架都有生命周期挂钩，代表组件的呈现/更新状态。下面你可以找到每一个React生命周期钩子和它在Angular中的等价物。</p><p id="b4a5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lx ly lz lo b">componentWillMount</code>(已废弃)→ <code class="fe lx ly lz lo b">ngOnInit</code></p><p id="6b14" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lx ly lz lo b">componentDidMount</code> → <code class="fe lx ly lz lo b">ngAfterViewInit</code></p><p id="e0a9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lx ly lz lo b">componentWillUnmount</code> → <code class="fe lx ly lz lo b">ngOnDestroy</code></p><p id="6309" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lx ly lz lo b">componentWillReceiveProps</code>(已弃用)<code class="fe lx ly lz lo b">getDerivedStateFromProps</code><code class="fe lx ly lz lo b">componentWillUpdate</code><code class="fe lx ly lz lo b">componentDidUpdate</code>在Angular中均可替换为<code class="fe lx ly lz lo b">ngOnChanges</code>。</p><p id="7063" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">与<code class="fe lx ly lz lo b">componentWillReceiveProps</code>不同的是，<code class="fe lx ly lz lo b">ngOnChanges</code>实际上只在组件的属性/输入绑定改变时才触发，它在参数中有一个changes对象，告诉您哪些特定的属性以及它们当前/以前的值发生了改变。所以你不必担心它在每次渲染前被触发，不像<code class="fe lx ly lz lo b">componentWillReceiveProps</code>。</p><h2 id="7cd2" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">变化检测</h2><p id="ec3b" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">React依赖于单向数据流，它使用一种叫做虚拟DOM的东西来处理变化检测，虚拟DOM基本上是DOM的JavaScript对象表示。在重构虚拟dom之后，它只对与实际DOM不同的部分进行区分和应用更改。</p><p id="908a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Angular内置了自己的变更检测策略，每当Angular认为某些代码可能会导致变更检测时，就会运行该策略。即DOM事件、异步调用如<code class="fe lx ly lz lo b">setTimeout</code> / <code class="fe lx ly lz lo b">setInterval</code> / <code class="fe lx ly lz lo b">Promises</code>和输入变量的改变。这既允许单向数据流，也允许开发人员首选的双向数据绑定。</p><p id="b714" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Angular通过围绕一个名为<code class="fe lx ly lz lo b">zone.js </code>的库实现他们自己的包装器来实现这一点，这允许他们在执行后猴子修补像<code class="fe lx ly lz lo b">setTimeout</code>这样的异步JavaScript APIs来运行角度变化检测，所以每次运行<code class="fe lx ly lz lo b">setTimeout</code>时，你都执行angular的change detection，如果你有一些不应该触发变化检测的异步调用，你可以通过使用<code class="fe lx ly lz lo b">ngZone.runOutsideAngular(fn)</code>来选择退出。</p><h2 id="513d" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">性能优化</h2><p id="c5d4" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">Angular和React都有类似的方法来优化它们的变化检测。在react中，你可以使用<code class="fe lx ly lz lo b">PureComponent</code> <code class="fe lx ly lz lo b">React.memo</code>或<code class="fe lx ly lz lo b">shouldComponentUpdate</code>，这实际上是告诉React跳过渲染，除非组件的一个道具发生变化(仅参考发生变化)。允许它通过引用来比较对象/数组，而不是深入检查它们。</p><p id="786f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在角度上与此相当的是<code class="fe lx ly lz lo b">ChangeDetectionStrategy.OnPush</code>角度也有可能完全脱离<code class="fe lx ly lz lo b">ChangeDetector</code>并手动触发变化。OnPush变化检测可以通过<code class="fe lx ly lz lo b">@Component</code>装饰器进行如下设置:</p><pre class="lj lk ll lm gt ln lo lp lq aw lr bi"><span id="0eb6" class="kl km iq lo b gy ls lt l lu lv">import { Component, ChangeDetectionStrategy } from '@angular/core';</span><span id="a158" class="kl km iq lo b gy lw lt l lu lv">@Component({</span><span id="e4ff" class="kl km iq lo b gy lw lt l lu lv">  selector: 'app-root',</span><span id="c522" class="kl km iq lo b gy lw lt l lu lv">  templateUrl: './app.component.html',</span><span id="d400" class="kl km iq lo b gy lw lt l lu lv">  styleUrls: ['./app.component.css'],</span><span id="b907" class="kl km iq lo b gy lw lt l lu lv">  changeDetection: ChangeDetectionStrategy.OnPush</span><span id="96f8" class="kl km iq lo b gy lw lt l lu lv">})</span><span id="516f" class="kl km iq lo b gy lw lt l lu lv">export class AppComponent {</span><span id="bb6b" class="kl km iq lo b gy lw lt l lu lv">  title = 'angular-performance-demo';</span><span id="19d9" class="kl km iq lo b gy lw lt l lu lv">}</span></pre><p id="11aa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">另一个常见的优化是在呈现列表时使用React中的键来告诉框架只呈现数组中新的/删除的项目，而不是在数组改变时替换所有的DOM元素。这在角度上的等价物是<code class="fe lx ly lz lo b">trackBy</code>。</p><h2 id="f5b3" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">风格封装</h2><p id="faee" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">一个好的可重用组件是你可以插入到应用程序的其他地方使用的，而不必担心副作用或自定义配置。</p><p id="43e8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在React中，如果你想确保你的css不会渗透到其他组件，你必须使用像<code class="fe lx ly lz lo b">css modules</code>或<code class="fe lx ly lz lo b">css in javascript</code>这样的解决方案。</p><p id="1899" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Angular在其组件API中有一个选项，允许css按组件封装或者根本不封装。该属性的值可以通过浏览器的<code class="fe lx ly lz lo b">ShadowDOM</code> API或<code class="fe lx ly lz lo b">Emulated</code>模式获得，在这种模式下angular生成随机id并将它们附加到每个dom元素的类中。</p><p id="7eb2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">默认情况下，Angular中的样式封装是启用的，要更改封装策略，您可以使用<code class="fe lx ly lz lo b">@Component</code>装饰器中的封装属性，如下所示:</p><pre class="lj lk ll lm gt ln lo lp lq aw lr bi"><span id="214a" class="kl km iq lo b gy ls lt l lu lv">import { Component, ViewEncapsulation } from '@angular/core';</span><span id="9076" class="kl km iq lo b gy lw lt l lu lv">@Component({</span><span id="74ad" class="kl km iq lo b gy lw lt l lu lv">  selector: 'app-root',</span><span id="a625" class="kl km iq lo b gy lw lt l lu lv">  templateUrl: './app.component.html',</span><span id="d478" class="kl km iq lo b gy lw lt l lu lv">  styleUrls: ['./app.component.css'],</span><span id="e71f" class="kl km iq lo b gy lw lt l lu lv">  encapsulation: ViewEncapsulation.ShadowDom</span><span id="7f27" class="kl km iq lo b gy lw lt l lu lv">})</span><span id="d537" class="kl km iq lo b gy lw lt l lu lv">export class AppComponent {</span><span id="5fb6" class="kl km iq lo b gy lw lt l lu lv">  title = 'my-app';</span><span id="6fec" class="kl km iq lo b gy lw lt l lu lv">}</span></pre><h2 id="6815" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">碎片</h2><p id="3453" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">有时你需要在你的DOM元素周围有一个包装元素，但是你不想在你的树中引入另一个DOM元素，出于性能和可读性的原因，在你的应用中最小化DOM元素是一个很好的惯例。在React中，你可以用<code class="fe lx ly lz lo b">&lt;React.Fragment&gt;</code>包装你的元素。</p><p id="4437" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Angular也有类似的成分，你可以用<code class="fe lx ly lz lo b">&lt;ng-container&gt;</code>来实现。</p><h2 id="3479" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">道具。儿童、老虎机和跨界车</h2><p id="c37d" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">重用React组件中的一些逻辑。React已经提供了多种方法来做到这一点，从<em class="mj">混音，高阶组件，renderProps，props.children </em>。这些都是解决同一个问题的不同方法，这个问题就是用相同的功能呈现不同的内容。通常建议使用<em class="mj"> renderProps </em>而不是<em class="mj"> HOCs </em>，这已经非常类似于<code class="fe lx ly lz lo b">props.children</code>。</p><p id="d8a4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在Angular中，你可以把你的javaScript逻辑放到服务中，并依赖于Transclusion/slots，这相当于React中的props.children。以下示例将呈现从父组件的模板传递到子组件的模板的内容，您也可以在模板的特定部分呈现多个ng内容:</p><pre class="lj lk ll lm gt ln lo lp lq aw lr bi"><span id="a4b4" class="kl km iq lo b gy ls lt l lu lv">//child.component.html</span><span id="a8e3" class="kl km iq lo b gy lw lt l lu lv">&lt;div&gt;Children render here:<br/>  &lt;ng-content&gt;&lt;/ng-content&gt;<br/>&lt;/div&gt;</span><span id="7031" class="kl km iq lo b gy lw lt l lu lv">//parent.component.html<br/>&lt;app-child-component&gt;I render in child component&lt;/app-child-component&gt;</span></pre><p id="bd05" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这相当于React中的</p><pre class="lj lk ll lm gt ln lo lp lq aw lr bi"><span id="90d1" class="kl km iq lo b gy ls lt l lu lv">//child.component.js<br/>export function Child(props) {</span><span id="a68a" class="kl km iq lo b gy lw lt l lu lv">  return (<br/>    &lt;div&gt; Children render here:<br/>    {this.props.children}<br/>    &lt;/div&gt;<br/>  )<br/>}</span></pre><h2 id="d894" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">Web组件兼容性</h2><p id="2e64" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">Angular的组件实现有些类似，并且与自定义元素v1规范的本机浏览器实现兼容，因为它们支持ShadowDOM、插槽、自定义事件、css变量以及等效的生命周期挂钩。</p><p id="f814" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">事实上，你可以将你的Angular组件编译成本地web组件，你可以使用任何其他框架或者根本不用框架，就像<a class="ae mk" href="https://stenciljs.com" rel="noopener ugc nofollow" target="_blank"> stencilJS </a>所做的那样。</p><p id="1959" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，React似乎更关注拥有一个易于使用的声明式API来实现业务逻辑和UI组件。有关自定义元素与React兼容性的更多信息，请参见<a class="ae mk" href="https://reactjs.org/docs/web-components.html" rel="noopener ugc nofollow" target="_blank">https://reactjs.org/docs/web-components.html</a></p><h2 id="20ee" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">结论</h2><p id="6c03" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">我们查看了Angular和React中的组件。希望这激发了您学习和/或尝试其他框架的好奇心。两个框架对相同的问题都有自己的解决方案，这就是为什么学习和理解实际的问题及其解决方案比框架特定的语法和解决方案更重要。</p></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><p id="dc90" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你喜欢我的内容并想表示支持，你可以<a class="ae mk" href="https://www.buymeacoffee.com/khaledosman" rel="noopener ugc nofollow" target="_blank">请我喝啤酒</a></p></div></div>    
</body>
</html>