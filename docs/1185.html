<html>
<head>
<title>React patterns—lambda components and render props</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应模式—lambda组件和渲染道具</h1>
<blockquote>原文：<a href="https://itnext.io/react-patterns-lambda-components-and-render-props-c4dce3903a52?source=collection_archive---------3-----------------------#2018-08-07">https://itnext.io/react-patterns-lambda-components-and-render-props-c4dce3903a52?source=collection_archive---------3-----------------------#2018-08-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/fba99298ed31968716e358c513c25168.png" data-original-src="https://miro.medium.com/v2/resize:fit:1142/format:webp/1*eFCjaxOFp5jYUwTCLnSp4Q.png"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">“渲染道具”模式</figcaption></figure><p id="674e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">观察开发人员如何在React中不断发现新的组件组合模式是很棒的。一些曾经被认为是反模式的模式突然获得了一个名字，开发人员开始使用它。另一方面，一些成熟的模式变得过时，因为有更好的方法来解决问题。</p><p id="5bd1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我开始在<a class="ae kw" href="https://github.com/lingui/js-lingui" rel="noopener ugc nofollow" target="_blank"> jsLingui </a> i18n库中使用所谓的渲染道具来定制翻译的渲染。我不知道这种模式被称为“渲染道具”，但它很快在React生态系统中流行起来。几天前，我收到一个关于withI18n高阶组件是否有“渲染属性”变体的问题，很自然地，我将用户指向Trans组件的<a class="ae kw" href="https://lingui.github.io/js-lingui/ref/react.html#local-configuration" rel="noopener ugc nofollow" target="_blank">渲染属性</a>。他的回答很有趣:</p><blockquote class="kx"><p id="a6f3" class="ky kz iq bd la lb lc ld le lf lg kv dk translated">这已经是一种渲染道具了，尽管这是一种有趣变化，我还没有见过</p></blockquote><p id="5518" class="pw-post-body-paragraph jy jz iq ka b kb lh kd ke kf li kh ki kj lj kl km kn lk kp kq kr ll kt ku kv ij bi translated">我想:什么？它是一个道具，叫做render，用来自定义渲染。还有什么能更“渲染道具”呢？于是我开始谷歌搜索，在官方React文档中找到了一篇关于<a class="ae kw" href="https://reactjs.org/docs/render-props.html" rel="noopener ugc nofollow" target="_blank">渲染道具</a>的文章。</p><p id="96f0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我不想责怪任何人，因为命名是编程中最难的事情之一。相反，我想写下我自己对“渲染道具”模式的观点。</p><h1 id="f7fe" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">React文档中定义的“渲染道具”</h1><p id="82f4" class="pw-post-body-paragraph jy jz iq ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">术语“渲染道具”通常用于以下模式:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="b15f" class="my ln iq mu b gy mz na l nb nc">&lt;DataProvider&gt;<br/>  {(data) =&gt; data.map(item =&gt; &lt;li key={item.id}&gt;{item.value}&lt;/li&gt;)}<br/>&lt;/DataProvider&gt;</span></pre><p id="19cf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们有一个数据提供者(data provider ),它可以封装数据获取、复杂的行为，但是将渲染委托给子进程。有一个单独的子函数，一个以数据为参数的函数。</p><p id="3f46" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">简单的实现可能如下所示:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="e442" class="my ln iq mu b gy mz na l nb nc">function DataProvider({ children }) {<br/>  const data = /* fetch data somehow: state, derive from props, … */<br/>  return children(data)<br/>}</span></pre><p id="06a8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">术语“渲染道具”源自类似的用例，其中使用道具<code class="fe nd ne nf mu b">render</code>代替子道具:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="d79e" class="my ln iq mu b gy mz na l nb nc">&lt;DataProvider render={<br/>  (data) =&gt; data.map(item =&gt; &lt;li key={item.id}&gt;{item.value}&lt;/li&gt;)<br/>} /&gt;</span></pre><p id="6344" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">毕竟，孩子只是道具的特例。</p><p id="9fab" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">问题是，为什么这种模式被称为“渲染道具”？</p><blockquote class="kx"><p id="5172" class="ky kz iq bd la lb lc ld le lf lg kv dk translated">重要的不是名为<code class="fe nd ne nf mu b">render</code>的道具，而是这个道具的值是一个函数这个事实。</p></blockquote><p id="089c" class="pw-post-body-paragraph jy jz iq ka b kb lh kd ke kf li kh ki kj lj kl km kn lk kp kq kr ll kt ku kv ij bi translated">不是任何函数，而是在render方法中定义的匿名函数。为什么不叫它<strong class="ka ir">λ分量</strong>？</p><p id="e263" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们去兔子洞吧。</p><h2 id="7702" class="my ln iq bd lo ng nh dn ls ni nj dp lw kj nk nl ma kn nm nn me kr no np mi nq bi translated">用组件和元素替换lambda组件</h2><p id="ff16" class="pw-post-body-paragraph jy jz iq ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">想象一下，函数将接受一个对象作为第一个(也是唯一的)参数:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="f186" class="my ln iq mu b gy mz na l nb nc">&lt;DataProvider&gt;<br/>  {({ data }) =&gt; data.map(i =&gt; &lt;li key={i.id}&gt;{i.value}&lt;/li&gt;)}<br/>&lt;/DataProvider&gt;</span></pre><p id="afef" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在lambda组件看起来非常像函数组件:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="737d" class="my ln iq mu b gy mz na l nb nc">const DataRenderer = ({ data }) =&gt; <br/>  data.map(i =&gt; &lt;li key={i.id}&gt;{i.value}&lt;/li&gt;)</span><span id="5274" class="my ln iq mu b gy nr na l nb nc">&lt;DataProvider&gt;<br/>  &lt;DataRenderer /&gt;<br/>&lt;/DataProvider&gt;</span></pre><p id="cfe2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有道理，对吧？除了它不能工作，因为我们的<code class="fe nd ne nf mu b">DataProvider</code>的实现期望孩子作为一个函数，但是现在我们传递的甚至不是一个函数组件，而是一个元素。</p><p id="e4ed" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="ns">注:组件为</em> <code class="fe nd ne nf mu b"><em class="ns">DataRenderer</em></code> <em class="ns">，元素为</em> <code class="fe nd ne nf mu b"><em class="ns">&lt;DataRenderer /&gt;</em></code> <em class="ns">。</em> <code class="fe nd ne nf mu b"><em class="ns">&lt;DataRenderer /&gt;</em></code> <em class="ns">在JSX被改造成</em> <code class="fe nd ne nf mu b"><em class="ns">React.createElement(DataRenderer)</em></code> <em class="ns">。</em></p><p id="3676" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们更新一下我们的<code class="fe nd ne nf mu b">DataProvider</code>:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="078a" class="my ln iq mu b gy mz na l nb nc">function DataProvider({ children }) {<br/>  const data = /* fetch data somehow: state, derive from props, … */<br/>  const props = { data }</span><span id="bcea" class="my ln iq mu b gy nr na l nb nc">  return React.isValidElement(children)<br/>    ? React.cloneElement(children, props)  // element as children<br/>    : React.createElement(children, props) // component as children<br/>}</span></pre><p id="9960" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在<code class="fe nd ne nf mu b">DataProvider</code>支持两种模式。经典组合，但内部组件从父组件获取注入数据:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="5a0b" class="my ln iq mu b gy mz na l nb nc">const DataRenderer = ({ data }) =&gt; <br/>  data.map(i =&gt; &lt;li key={i.id}&gt;{i.value}&lt;/li&gt;)</span><span id="538a" class="my ln iq mu b gy nr na l nb nc">&lt;DataProvider&gt;<br/>  &lt;DataRenderer /&gt;<br/>&lt;/DataProvider&gt;</span></pre><p id="be56" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">和“渲染属性”模式，其中我们将lambda组件作为子组件传递:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="c012" class="my ln iq mu b gy mz na l nb nc">&lt;DataProvider&gt;<br/>  {({ data }) =&gt; data.map(i =&gt; &lt;li key={i.id}&gt;{i.value}&lt;/li&gt;)}<br/>&lt;/DataProvider&gt;</span></pre><p id="f87c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，我们可能有一个“渲染道具”行为，但没有lambda组件，问题仍然是:有什么区别？范围！</p><h2 id="6cbb" class="my ln iq bd lo ng nh dn ls ni nj dp lw kj nk nl ma kn nm nn me kr no np mi nq bi translated">通过作用域传递数据</h2><p id="3f76" class="pw-post-body-paragraph jy jz iq ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">我们可以将前面示例中的函数提取到函数组件中，因为该函数是“纯”的:它不使用范围之外的数据，即使它可以访问这些数据。想象一个不同的组件:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="bce2" class="my ln iq mu b gy mz na l nb nc">function DataPage(props) {<br/>  const computedProperty = compute(props)<br/>  <br/>  return (<br/>    &lt;DataProvider&gt;<br/>      {({ data }) =&gt; (<br/>        &lt;div&gt;<br/>          {computedProperty}<br/>          {data.map(i =&gt; &lt;li key={i.id}&gt;{i.value}&lt;/li&gt;)}<br/>        &lt;/div&gt;<br/>      )}<br/>    &lt;/DataProvider&gt;<br/>  )<br/>}</span></pre><p id="f046" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Lambda组件使用父作用域中的数据！如果我们在<code class="fe nd ne nf mu b">DataPage</code>范围之外声明它，我们需要显式传递所需的数据:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="bcd7" class="my ln iq mu b gy mz na l nb nc">const DataRenderer = {({ data, computedProperty }) =&gt; (<br/>  &lt;div&gt;<br/>    {computedProperty}<br/>    {data.map(i =&gt; &lt;li key={i.id}&gt;{i.value}&lt;/li&gt;)}<br/>  &lt;/div&gt;<br/>)}</span><span id="74ad" class="my ln iq mu b gy nr na l nb nc">function DataPage(props) {<br/>  const computedProperty = compute(props)<br/>  <br/>  return (<br/>    &lt;DataProvider&gt;<br/>      &lt;DataRenderer computedProperty={computedProperty} /&gt;<br/>    &lt;/DataProvider&gt;<br/>  )<br/>}</span></pre><p id="443b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们又回到了良好的旧组件构成。不太明显的是，<code class="fe nd ne nf mu b">DataProvider</code>实际上将<code class="fe nd ne nf mu b">data</code> prop注入到了<code class="fe nd ne nf mu b">DataRenderer</code>，但这是相同的模式，相同的行为，只是没有lambda组件。</p><p id="653f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在React中，我们似乎有三种传递数据的方式:</p><ul class=""><li id="8d09" class="nt nu iq ka b kb kc kf kg kj nv kn nw kr nx kv ny nz oa ob bi translated">通过道具</li><li id="c3f7" class="nt nu iq ka b kb oc kf od kj oe kn of kr og kv ny nz oa ob bi translated">通过上下文</li><li id="c1f3" class="nt nu iq ka b kb oc kf od kj oe kn of kr og kv ny nz oa ob bi translated">通过范围</li></ul><p id="3ef8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它们都有优点和缺点，取决于具体的用例。</p><h1 id="ce80" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">结论</h1><p id="4cd3" class="pw-post-body-paragraph jy jz iq ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">我花了几个小时写这篇短文，因为我完全迷失在不同的模式中。我还发现了一些我不知道存在于React中的模式。无论如何，这是我对“渲染道具”的观点，也是为什么我觉得这个名字很混乱。</p><p id="e129" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你对名称<strong class="ka ir">λ组件</strong>有什么看法？</p><p id="6eaa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后一个问题是:如何命名<code class="fe nd ne nf mu b">DataProvider</code>，这个组件消耗组件或元素并向其注入数据？它是一个容器吗？提供商？“渲染道具”组件？就我个人而言，我倾向于使用<strong class="ka ir">容器</strong>，因为它通常定义一种行为或业务逻辑，而不是表示逻辑。</p><p id="99c5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">“渲染属性”模式不是HOC最终替代品，因为您不能在生命周期方法中使用容器中的数据。在某些情况下，它仍然是有用的模式，并且肯定是每个React开发人员都应该拥有的模式。</p></div><div class="ab cl oh oi hu oj" role="separator"><span class="ok bw bk ol om on"/><span class="ok bw bk ol om on"/><span class="ok bw bk ol om"/></div><div class="ij ik il im in"><p id="31b2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">嘿！我正在开发<a class="ae kw" href="https://github.com/lingui/js-lingui" rel="noopener ugc nofollow" target="_blank"> jsLingui </a>，这是一个用于JavaScript的i18n库。该库从头到尾解决了i18n，提供了用于翻译的组件、用于管理消息目录的CLI以及离线编译消息以节省包大小。它是react-intl的替代方案，但也适用于普通JS。看看<a class="ae kw" href="https://lingui.github.io/js-lingui/tutorials/react.html" rel="noopener ugc nofollow" target="_blank"> React教程</a>或者说<a class="ae kw" href="https://lingui.github.io/js-lingui/misc/react-intl.html" rel="noopener ugc nofollow" target="_blank">和react-intl </a>有什么不同。</p></div></div>    
</body>
</html>