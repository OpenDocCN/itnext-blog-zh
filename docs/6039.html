<html>
<head>
<title>6 new TypeScript features for writing clean code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">6个用于编写干净代码的新TypeScript特性</h1>
<blockquote>原文：<a href="https://itnext.io/6-new-typescript-features-for-writing-clean-code-ea7810cf5019?source=collection_archive---------0-----------------------#2021-07-30">https://itnext.io/6-new-typescript-features-for-writing-clean-code-ea7810cf5019?source=collection_archive---------0-----------------------#2021-07-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/d77b8ca3b9fe00308c4809fd1f9d5ee7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0lAYuIRYksZLtzbjpEs9DQ.png"/></div></div></figure><p id="bf94" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们介绍一些较新的TypeScript特性和改进。这些是我发现在我的日常工作中对编写精确和干净的代码最有帮助的特性。</p><h1 id="580b" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">带有参数属性的构造函数简写</h1><p id="6e4e" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">有一种方法可以使用TypeScript的<a class="ae mc" href="https://www.typescriptlang.org/docs/handbook/2/classes.html#parameter-properties" rel="noopener ugc nofollow" target="_blank">参数属性</a>编写更短的类。这种简写允许您使用与类构造函数参数相同的名称来声明类属性。你所需要做的就是在你的参数前加上可见性修饰符。</p><p id="8ecb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">看一看这个类:</p><figure class="me mf mg mh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi md"><img src="../Images/4bab55332338daa43c19fc1042c73018.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h8GqW6QfVnOqf05ORcH2_w.png"/></div></div></figure><p id="74c8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里，我们手动将构造函数接收到的参数分配给同名的类属性。</p><p id="fd8d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下面是我们如何使用参数属性来修改这段代码:</p><figure class="me mf mg mh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi md"><img src="../Images/956840cfea751773dac0b2eec3c52ccc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pOEGCmKkoC4EhOlDIHh_dQ.png"/></div></div></figure><h1 id="9e21" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">无效聚结</h1><p id="a782" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated"><a class="ae mc" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Nullish_coalescing_operator" rel="noopener ugc nofollow" target="_blank"> Nullish合并</a>是一个较新的ECMAScript特性，TypeScript最近开始支持它。Nullish合并运算符允许您为<code class="fe mi mj mk ml b">null</code>或<code class="fe mi mj mk ml b">undefined</code>提供回退值。下面是它在代码中的样子:</p><figure class="me mf mg mh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mm"><img src="../Images/84a1c6d050dfa2e9945bdd448a9f9da2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qBsVj7M7CSfqHfpevSjaPg.png"/></div></div></figure><p id="74ee" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您可能想知道:“它与逻辑OR ( <code class="fe mi mj mk ml b">||</code>)运算符有何不同”？答案是nullish合并操作符专门处理<code class="fe mi mj mk ml b">null</code>和<code class="fe mi mj mk ml b">undefined</code>值，而or操作符将返回任何falsy值的右操作数，包括<code class="fe mi mj mk ml b">null</code>、<code class="fe mi mj mk ml b">undefined</code>、空字符串和零。</p><h1 id="9251" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">私有类字段</h1><p id="3eae" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">这个特性也来自ECMAScript。<a class="ae mc" href="https://github.com/tc39/proposal-class-fields/" rel="noopener ugc nofollow" target="_blank">私有类字段</a>是一个第3阶段ECMAScript提议，在TypeScript社区中被越来越多的人采用。要声明私有类字段，可以使用<code class="fe mi mj mk ml b">#</code>语法:</p><figure class="me mf mg mh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mm"><img src="../Images/16156f0ff7ef4865aced1815f96d8536.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YI-JPhucLX6Vv5VYAkKXKQ.png"/></div></div></figure><p id="53b9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在关键字<code class="fe mi mj mk ml b">private</code>上使用私有类字段的区别在于前者有更好的运行时保证。用<code class="fe mi mj mk ml b">private</code>关键字声明的TypeScript字段将成为编译后的JavaScript代码中的常规字段。另一方面，私有类字段在编译后的代码中将保持私有。</p><p id="2150" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">试图在运行时访问私有类字段将导致语法错误。这也意味着人们不能使用浏览器开发工具检查和窥探你的私有类字段。</p><p id="5254" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">有了私有类字段，我们终于在JavaScript中获得了真正的隐私。</p><h1 id="014f" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">标签元组类型</h1><p id="ef58" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">此功能适用于TypeScript及更高版本。带标签的元组类型改善了我们使用元组的体验。</p><p id="f203" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先，让我们简单介绍一下TypeScript中的元组是什么。元组是固定大小的数组类型。元组必须声明它们的类型，尽管这些类型不需要完全相同。下面是一个元组类型声明示例:</p><figure class="me mf mg mh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mm"><img src="../Images/c7f3b2dc273354a9fd94516b4b048656.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xLJ0-87KwMIh47oSQJzCnQ.png"/></div></div></figure><p id="ca4a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用<em class="mn">标记的</em>元组类型，我们可以，你猜对了——标记我们的元组包含的类型。它看起来是这样的:</p><figure class="me mf mg mh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mm"><img src="../Images/fe6699dc863305fbd162ccc3f597e5db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EMIPSu-sPP32R2OOxWnQtg.png"/></div></div></figure><p id="3704" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">那么为什么要使用带标签的元组类型呢？主要是当使用函数和扩展操作符时，您会获得更好的自动完成体验:</p><figure class="me mf mg mh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mo"><img src="../Images/fed8d1042346b5877af580c8deb068b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*spdOI_Zjy5Ghc6w_1Oelmg.png"/></div></div></figure><p id="8eb3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下面是使用常规元组时自动完成的样子:</p><figure class="me mf mg mh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mp"><img src="../Images/fe1343f780713195f21e79d6f30d3cbb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j78O3-1k18iVF5dClryVmQ.png"/></div></div></figure><p id="8cd4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用带标签的元组类型，您可以看到函数接受的数据的性质，而无需深入到它的声明。</p><h1 id="600b" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">模板类型文字</h1><p id="12f5" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">模板类型文本是4.1版及更高版本中提供的较新的TypeScript功能。模板类型文本允许您从多个联合类型的组合中创建新的字符串类型。</p><p id="898f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">假设您想为用户提供一组通过组合两种联合类型创建的选项。您可以使用模板类型文本，而不是手动键入每个选项:</p><figure class="me mf mg mh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mq"><img src="../Images/b3440a4b40cbb9272a2f77878da19fa9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WlNxukeQVthWP_6bQZGREw.png"/></div></div></figure><p id="2176" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">注意新的<code class="fe mi mj mk ml b">Position</code>类型是如何包含了<code class="fe mi mj mk ml b">topBottom</code>和<code class="fe mi mj mk ml b">leftRight</code>类型的所有组合的。</p><p id="7258" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">模板类型文字有许多应用，但最常见于UI库和设计系统中。</p><h1 id="3e87" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">实用程序类型</h1><p id="3d09" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">TypeScript为您提供了一组实用工具类型，允许您在现有类型的基础上构造新类型。有许多实用程序类型涵盖了不同的场景，例如选择要复制的类型属性，使它们大写，或者使所有属性可选。</p><p id="0bf1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下面是一个使用<code class="fe mi mj mk ml b">Omit</code>实用程序的例子，该实用程序从原始类型中复制所有的道具，除了您选择不包括的那些:</p><figure class="me mf mg mh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mm"><img src="../Images/6a7919ebac0dafdeae50fa9ec9a0593c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uitrTs_kIshjwJGsC2S5fg.png"/></div></div></figure><p id="0fff" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">要了解更多关于TypeScript中的实用程序类型的信息，请查看这里的<a class="ae mc" href="https://isamatov.com/typescript-utility-types-for-react/" rel="noopener ugc nofollow" target="_blank">我的帖子</a>。</p><p id="04fd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这就是这篇文章的全部内容。在这里，我们介绍了一些较新的TypeScript特性，您很可能会觉得这些特性很有趣，并会很好地加以利用。感谢您的阅读！</p></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><p id="89fd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="mn">原载于2021年7月30日https://isamatov.com</em><em class="mn">的</em> <a class="ae mc" href="https://isamatov.com/new-typescript-features/" rel="noopener ugc nofollow" target="_blank"> <em class="mn">。</em></a></p></div></div>    
</body>
</html>