<html>
<head>
<title>Master Lists in React Native : Beyond the List</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React Native中的主列表:列表之外</h1>
<blockquote>原文：<a href="https://itnext.io/master-lists-in-react-native-beyond-the-list-3a80dcd85522?source=collection_archive---------6-----------------------#2019-10-26">https://itnext.io/master-lists-in-react-native-beyond-the-list-3a80dcd85522?source=collection_archive---------6-----------------------#2019-10-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="c71b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在React Native的<a class="ae kl" rel="noopener ugc nofollow" target="_blank" href="/master-lists-in-react-native-54b485de56f5">主列表(第1部分)</a>中，我们探讨了在一个不可预见的多状态世界中设计列表的概念。今天，我们将重温和扩展列表状态的概念。每个事实都是半个事实，在幻觉的背后，第一篇文章中概述的数据和无数据列表状态更加复杂。</p><blockquote class="km"><p id="5c00" class="kn ko iq bd kp kq kr ks kt ku kv kk dk translated">事实上，所有类型的异步请求都存在这些状态。</p></blockquote><figure class="kx ky kz la lb lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi kw"><img src="../Images/fd4a20932696f284384987724a2e9272.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*W65WURa-qzHRN7vgii-Xqw.gif"/></div></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk translated">不可能的异步状态管理</figcaption></figure><p id="7e5b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">同学们，要解决这个问题，我们必须勾画出问题空间。我们在和什么类型的黑暗势力战斗？<strong class="jp ir">异步请求会产生多种可能的状态，我们的接口需要适应这些状态。</strong></p><p id="d7ae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了解决这个问题，我们可以看看我们的接口需要处理的可能状态:</p><ul class=""><li id="ca26" class="ln lo iq jp b jq jr ju jv jy lp kc lq kg lr kk ls lt lu lv bi translated">已完成(大多数情况下都有数据)</li><li id="daeb" class="ln lo iq jp b jq lw ju lx jy ly kc lz kg ma kk ls lt lu lv bi translated">错误(就像React Native (Part 1) 中的<a class="ae kl" rel="noopener ugc nofollow" target="_blank" href="/master-lists-in-react-native-54b485de56f5">主列表一样，有各种类型的错误)</a></li><li id="ec09" class="ln lo iq jp b jq lw ju lx jy ly kc lz kg ma kk ls lt lu lv bi translated">正在加载(异步请求正在进行中)</li><li id="5370" class="ln lo iq jp b jq lw ju lx jy ly kc lz kg ma kk ls lt lu lv bi translated">空(没有可用数据，但不是因为错误)</li></ul><p id="7a0d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在仔细听工程师、设计师和艺术家们说。问题不在于我们如何处理列表中的这些状态，而在于……我们如何构建一个通用的接口来响应异步请求产生的过多状态？</p><p id="6a16" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了解决这个问题，我们将分析一个手机应用程序中“推荐朋友”的屏幕。</p><figure class="mc md me mf gt lc gh gi paragraph-image"><div class="gh gi mb"><img src="../Images/2540c6068c23b95c2c0bf394ddbfeae8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1320/1*cyHoaDReDxQjoORQmQ-hOw.gif"/></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk translated">推荐朋友屏幕</figcaption></figure><p id="9a32" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个屏幕由两部分数据组成，一部分是附加到我们的用户对象的引用URL，另一部分是属于它自己的独立端点的引用列表。要检索该屏幕的数据，必须执行两个异步操作。</p><h1 id="fe54" class="mg mh iq bd mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd bi translated">问题</h1><h2 id="cb51" class="ne mh iq bd mi nf ng dn mm nh ni dp mq jy nj nk mu kc nl nm my kg nn no nc np bi translated">指标爆发</h2><p id="2caf" class="pw-post-body-paragraph jn jo iq jp b jq nq js jt ju nr jw jx jy ns ka kb kc nt ke kf kg nu ki kj kk ij bi translated">在我看来，当我们遇到屏幕上有多个加载指示器的情况时，体验会受到影响，应用程序的质量也会下降。在某些情况下，这可能是我们想要的，而在其他情况下，它不是。作为开发人员，我们需要控制应用程序这方面的能力。</p><figure class="mc md me mf gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi nv"><img src="../Images/bad25c342031015e6244c72b71d3879a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BdsyUSJMyk4OEgKtZlNV9Q.jpeg"/></div></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk translated">多个装载指示灯(<strong class="bd mi">左</strong> — <strong class="bd mi">不良</strong> ) /单个指示灯(<strong class="bd mi">右</strong> — <strong class="bd mi">良好</strong></figcaption></figure><p id="2495" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上图中，左边是我们试图避免的体验，右边是我们想要建立的体验。</p><h2 id="965e" class="ne mh iq bd mi nf ng dn mm nh ni dp mq jy nj nk mu kc nl nm my kg nn no nc np bi translated"><strong class="ak"> iFrame UX </strong></h2><p id="787a" class="pw-post-body-paragraph jn jo iq jp b jq nq js jt ju nr jw jx jy ns ka kb kc nt ke kf kg nu ki kj kk ij bi translated">这个问题被称为iFrame UX，因为我们在屏幕上有多个回退。如果我们将屏幕的多个部分连接到不同的数据源，就会出现这种情况。反常的是，有时这是我们想要发生的(右例)，而在其他情况下却不是(左例)。</p><figure class="mc md me mf gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi nw"><img src="../Images/ece7086c9979afd2f0408e8c3cd99db6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*74fwnugJyUN8RIHrfpV_Xg.jpeg"/></div></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk translated">使用相同的技术:回退处理(<strong class="bd mi">左</strong> — <strong class="bd mi">坏</strong>)，回退处理(<strong class="bd mi">右</strong> — <strong class="bd mi">好</strong>)</figcaption></figure><p id="b3c4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上图中，我们看到了每个数据源的回退何时可行，何时不可行的例子。在左图中，整个屏幕的一个回退效果会更好。在右边的图像中，每个部分的后退是我们想要的。作为开发人员，我们需要灵活性来控制这一点。</p><h2 id="74f1" class="ne mh iq bd mi nf ng dn mm nh ni dp mq jy nj nk mu kc nl nm my kg nn no nc np bi translated">短暂过载</h2><p id="b01f" class="pw-post-body-paragraph jn jo iq jp b jq nq js jt ju nr jw jx jy ns ka kb kc nt ke kf kg nu ki kj kk ij bi translated">这个问题的出现是因为我们需要跟踪大量的变量来提供有说服力的体验。如果我们使用REST API，我们的屏幕通常由来自不同端点的各种数据组成。这意味着多重加载、错误和空状态🌀。</p><figure class="mc md me mf gt lc"><div class="bz fp l di"><div class="nx ny l"/></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk translated"><a class="ae kl" href="https://gist.github.com/lukebrandonfarrell/558d0e758db2a3d4c5e0f86f5873d8f6" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/lukebrandonfarrell/558 d0e 758 db 2 a 3d 4c 5 E0 f 86 f 5873 D8 f 6</a></figcaption></figure><p id="d10e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上面是我们的referral屏幕的一个片段，其中包含一些用于跟踪加载、错误和空状态的变量。当我们添加更多的异步数据源时，这变得更加复杂。</p><h1 id="00da" class="mg mh iq bd mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd bi translated">解决方法</h1><h2 id="9f5c" class="ne mh iq bd mi nf ng dn mm nh ni dp mq jy nj nk mu kc nl nm my kg nn no nc np bi translated">异步边界</h2><p id="0eeb" class="pw-post-body-paragraph jn jo iq jp b jq nq js jt ju nr jw jx jy ns ka kb kc nt ke kf kg nu ki kj kk ij bi translated">为了解决“指示器爆发”和“iFrame UX”问题，我们需要某种包装器组件，它将接受异步操作的当前状态并提供回退。作为开发人员，我们应该能够使用多个这样的包装组件，这样当部分界面准备好了，我们就可以显示它了。我们不希望整个界面都在加载，显示一个错误，空的；如果只有一部分失败了…</p><p id="be4a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是！在某些情况下，显示完整接口的错误是有意义的，即使它的一部分失败了。</p><p id="6384" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们需要能让我们做到这一点的东西…悬念…</p><figure class="mc md me mf gt lc"><div class="bz fp l di"><div class="nx ny l"/></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk translated"><AsyncBoundary/>(<a class="ae kl" href="https://gist.github.com/lukebrandonfarrell/bf3ad19f0009fa0e052209f926be2c53" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/lukebrandonfarrell/BF3 ad 19 f 0009 fa 0e 052209 f 926 be 2c 53</a>)</figcaption></figure><p id="c7cc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上面的代码与<code class="fe nz oa ob oc b"><a class="ae kl" href="https://reactjs.org/docs/concurrent-mode-suspense.html" rel="noopener ugc nofollow" target="_blank">&lt;Suspense /&gt;</a></code>无关，目前处于实验阶段。使用上面的组件，您能够为错误、空和加载状态提供回退。一个<code class="fe nz oa ob oc b">&lt;AsyncBoundary /&gt;</code>可以有子异步边界，允许您在粒度级别上控制加载指示器和回退。默认情况下，加载和错误不会优先于数据，如第1部分所述:<em class="od">“我们不希望错误和加载优先于我们的数据”</em>。</p><p id="13ec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">阅读上面的代码，看看它是否对你有用，如果需求足够，我会发布详细的文档。</p><h2 id="ceaf" class="ne mh iq bd mi nf ng dn mm nh ni dp mq jy nj nk mu kc nl nm my kg nn no nc np bi translated">状态约束</h2><p id="9fc6" class="pw-post-body-paragraph jn jo iq jp b jq nq js jt ju nr jw jx jy ns ka kb kc nt ke kf kg nu ki kj kk ij bi translated">“短暂过载”的问题不需要用代码来解决。它需要更好地理解我们的接口中与异步操作相关的各种状态和子状态，这样我们就可以在我们的组件之间保持一致性。这些状态可以分为三种类型；<strong class="jp ir">核心状态</strong>、<strong class="jp ir">派生状态</strong>和<strong class="jp ir">跟踪状态</strong>。</p><p id="0ec3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">核心状态</strong></p><p id="1de8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是任何异步操作的典型状态。</p><ul class=""><li id="4fde" class="ln lo iq jp b jq jr ju jv jy lp kc lq kg lr kk ls lt lu lv bi translated">数据(我们希望在界面上显示的数据)</li><li id="ffae" class="ln lo iq jp b jq lw ju lx jy ly kc lz kg ma kk ls lt lu lv bi translated">正在加载(请求正在进行中)</li><li id="6122" class="ln lo iq jp b jq lw ju lx jy ly kc lz kg ma kk ls lt lu lv bi translated">isError(请求有错误)</li></ul><p id="65fc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">还值得注意的是，我们可以跟踪HTTP状态代码，它可以为我们提供有关错误的更多信息，例如401未授权-显示登录按钮，500内部服务器错误-出错回退。</p><p id="f456" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">派生状态</strong></p><p id="cd73" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该状态可以根据您的要求从<strong class="jp ir">核心状态</strong>中的三个变量中导出。</p><ul class=""><li id="2ac6" class="ln lo iq jp b jq jr ju jv jy lp kc lq kg lr kk ls lt lu lv bi translated">isEmpty(数据可用)</li></ul><p id="8438" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们想只在数据可用时显示界面的某个部分，例如“推荐朋友”屏幕上的页脚，这个状态就很重要。</p><figure class="mc md me mf gt lc gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/2971f0c2a442be5d2e28dd585134e4f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1308/format:webp/1*Ey23Pp0bm7hNv5_cAhowpg.png"/></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk translated">“推荐朋友”页脚</figcaption></figure><ul class=""><li id="2ba8" class="ln lo iq jp b jq jr ju jv jy lp kc lq kg lr kk ls lt lu lv bi translated">isRefreshing(有数据可用时请求正在进行)</li></ul><p id="7cfe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在React Native(第一部分)中的<a class="ae kl" rel="noopener ugc nofollow" target="_blank" href="/master-lists-in-react-native-54b485de56f5">主列表中，我们了解到可以用下面这个简单的公式来导出列表的刷新状态:<code class="fe nz oa ob oc b">!isEmpty &amp;&amp; isLoading</code>。这是一个很好的指标，表明刷新操作已经发生，但是当我们只使用<code class="fe nz oa ob oc b">isLoading</code>作为一个指标来导出这个状态时，这可能会变得有点复杂。</a></p><p id="6dab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我解释一下。在我们的“推荐朋友”应用程序中，每次打开应用程序时，我们还会发出一个请求来获取推荐列表和用户。意味着当应用程序关闭/打开时，我们的<code class="fe nz oa ob oc b">isLoading</code>标志将被设置为<code class="fe nz oa ob oc b">true</code>，我们的<code class="fe nz oa ob oc b">isRefreshing</code>标志也将被设置为<code class="fe nz oa ob oc b">true</code>。</p><p id="6501" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们在<code class="fe nz oa ob oc b">isRefreshing</code>为<code class="fe nz oa ob oc b">true</code>时在屏幕上显示指示器，那么打开和关闭应用程序将被视为用户下拉列表，因此当他们打开应用程序时会显示一个加载指示器。这是一个小细节，也许你会觉得很舒服。这将我们带到<strong class="jp ir">跟踪状态</strong>。</p><p id="7bab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">跟踪状态</strong></p><p id="bb37" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们必须明确跟踪每个组件的状态。</p><ul class=""><li id="3251" class="ln lo iq jp b jq jr ju jv jy lp kc lq kg lr kk ls lt lu lv bi translated">正在刷新</li></ul><p id="a38f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们把我们的<code class="fe nz oa ob oc b">isRefreshing</code>变量想象成一个表示用户已经开始刷新的值。为了解决上面的问题，当应用程序而不是用户发起请求时应用程序的刷新，我们必须手动跟踪<code class="fe nz oa ob oc b">isRefreshing</code>状态；<code class="fe nz oa ob oc b">const [isRefreshing, setIsRefreshing] = useState(false)</code>。当用户执行一个刷新动作时，你想把这个状态设置为<code class="fe nz oa ob oc b">true</code>，当请求完成时，你想把它设置为<code class="fe nz oa ob oc b">false</code>。</p><ul class=""><li id="92a7" class="ln lo iq jp b jq jr ju jv jy lp kc lq kg lr kk ls lt lu lv bi translated">isPaginating(仅用于列表)</li></ul><p id="58c3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就像刷新一样，分页需要被显式地跟踪，当一个用户动作发生时；<code class="fe nz oa ob oc b">const [isPaginating, setIsPaginating] = useState(false)</code>。这将允许您仅在用户发起分页动作(例如，滚动到底部)时显示加载指示器。</p><p id="8e24" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">还有许多其他的<strong class="jp ir">跟踪状态</strong>用例，比如在列表的情况下，与项目交互、每个项目的加载状态以及单个项目的回退。这些将在第3部分中讨论。</p><h1 id="ad35" class="mg mh iq bd mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd bi translated">结论</h1><p id="4986" class="pw-post-body-paragraph jn jo iq jp b jq nq js jt ju nr jw jx jy ns ka kb kc nt ke kf kg nu ki kj kk ij bi translated">您仍然希望将您的接口视为<em class="od">数据可用</em> / <em class="od">数据不可用。</em>当数据不可用时，您希望显示回退。如果数据可用，那么您希望将问题通知给用户。下面是使用<a class="ae kl" href="https://github.com/lukebrandonfarrell/react-native-action-tips" rel="noopener ugc nofollow" target="_blank"> React本地操作提示</a>向用户显示通知的代码片段。例如当刷新失败时。</p><figure class="mc md me mf gt lc"><div class="bz fp l di"><div class="nx ny l"/></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk translated"><a class="ae kl" href="https://gist.github.com/lukebrandonfarrell/df152b1e8416a02cd976f3bd1240ab9a" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/lukebrandonfarrell/df 152 B1 e 8416 a 02 CD 976 F3 BD 1240 ab9 a</a></figcaption></figure><figure class="mc md me mf gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi of"><img src="../Images/1acf7affb7e3a063c70235e40e097fc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zrifEquQXVUj8Z71tPpthg.png"/></div></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk translated">网络错误的操作提示</figcaption></figure></div><div class="ab cl og oh hu oi" role="separator"><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol"/></div><div class="ij ik il im in"><p id="964d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">总有一天会有一个第三方库来缓解这种复杂性，目前，这些问题取决于我们。</p></div></div>    
</body>
</html>