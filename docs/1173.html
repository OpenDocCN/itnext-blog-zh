<html>
<head>
<title>The SSH management TO-DOs list</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SSH管理待办事项列表</h1>
<blockquote>原文：<a href="https://itnext.io/the-ssh-management-to-dos-list-7c40421387e1?source=collection_archive---------0-----------------------#2018-08-04">https://itnext.io/the-ssh-management-to-dos-list-7c40421387e1?source=collection_archive---------0-----------------------#2018-08-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/8f0b45bb440eb8948b3190a0b76af1d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E2AWZRsLgOIxFFnF7l_S7Q.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/photos/xhmek6FD_8Y?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> rawpixel </a>在<a class="ae kc" href="https://unsplash.com/search/photos/single-key?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="db24" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在工作中，我们的大多数虚拟机都运行Linux。能够SSH到我们的服务器，以便跨不同的堆栈开发、自动化或故障排除服务，这对我们来说至关重要。话虽如此，但从第一天起，确保我们以安全的方式这样做就成了首要关注的问题。</p><p id="662b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在接下来的文章中，我将分享一些我们在控制SSH的过程中实施的措施。</p><h1 id="c3d3" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">1:用SSH客户端证书消除<strong class="ak">密钥爆炸</strong></h1><p id="a078" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">大家都知道，繁忙的工程师遇到共享服务器，第一个失控的就是SSH keys。仅仅工作几天后，SSH密钥就开始通过各种渠道传播:电子邮件、Slack、复制到服务器上，有时它们甚至出现在一个合流站点上。</p><p id="b433" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了防止这种情况，我们使用SSH证书。这个概念类似于TLS PKI，即引入第三方机构来签署用户密钥。因此，目标服务器不再需要依赖authorized_key文件，因为它们可以根据本地公共CA根证书按需验证提供的凭证。</p><p id="70b1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">除此之外，SSH证书可以携带关于客户端的额外元数据，比如通用名称、允许的功能、到期信息、允许的Linux用户模拟等。</p><blockquote class="me mf mg"><p id="ec4f" class="kd ke mh kf b kg kh ki kj kk kl km kn mi kp kq kr mj kt ku kv mk kx ky kz la ij bi translated"><a class="ae kc" href="https://ef.gy/hardening-ssh#SSH%20certificates" rel="noopener ugc nofollow" target="_blank">https://ef.gy/hardening-ssh</a>(向下滚动到SSH证书)</p></blockquote><h1 id="886a" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">2:使用Hashicorp Vault提供SSH证书自签名服务</h1><p id="3a56" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">Hashicorp Vault提供了一个易于设置的PKI后端来处理SSH证书签名工作流。在我们的例子中，用户使用他们的AD或AWS凭证登录到Vault，然后提交他们的个人id_rsa.pub密钥给Vault签名。生成的证书允许用户根据他们的角色最多一天通过SSH进入不同的环境。</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="9f00" class="mu lc iq mq b gy mv mw l mx my"># ------------------------------------<br/># cat /usr/local/bin/vault-ssh.sh<br/># ------------------------------------</span><span id="737e" class="mu lc iq mq b gy mz mw l mx my">#! /bin/bash</span><span id="69c5" class="mu lc iq mq b gy mz mw l mx my">set -ue</span><span id="d0ff" class="mu lc iq mq b gy mz mw l mx my">USERNAME=fist.last@ldapdomain.com<br/>SSH_DIR=~/.ssh<br/>export VAULT_ADDR=<a class="ae kc" href="https://vault.shrd.sparklecore.net" rel="noopener ugc nofollow" target="_blank">https://vault.shrd.</a>internal.net</span><span id="f44f" class="mu lc iq mq b gy mz mw l mx my"># Login to Vault using LDAP if not already logged in<br/>if ! vault token lookup &gt; /dev/null 2&gt;&amp;1; then<br/>  # The Vault cli will prompt for a password<br/>  vault login -method=ldap -field token_policies <a class="ae kc" href="mailto:username=$USERNAME@sparkletech.com.au" rel="noopener ugc nofollow" target="_blank">username=$USERNAME</a><br/>fi</span><span id="52fa" class="mu lc iq mq b gy mz mw l mx my"># Sign POC and DEV environment certificates<br/>vault write -field=signed_key <strong class="mq ir">ssh-poc</strong>/sign/ec2-user  public_key=@${SSH_DIR}/<strong class="mq ir">id_rsa.pub</strong> &gt; ${SSH_DIR}/<strong class="mq ir">id_rsa-poc-cert.pub</strong></span><span id="fa91" class="mu lc iq mq b gy mz mw l mx my">vault write -field=signed_key <strong class="mq ir">ssh-dev</strong>/sign/ec2-user  public_key=@${SSH_DIR}/<strong class="mq ir">id_rsa.pub</strong> &gt; ${SSH_DIR}/<strong class="mq ir">id_rsa-dev-cert.pub</strong></span></pre><p id="4e17" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了连接到服务器，我们在SSH命令参数中结合了签名证书和私钥:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="3996" class="mu lc iq mq b gy mv mw l mx my">ssh -i <strong class="mq ir">id_rsa</strong> -i <strong class="mq ir">id_rsa-poc-cert.pub</strong> ec2-user@mybox.internal.net</span></pre><blockquote class="me mf mg"><p id="69e3" class="kd ke mh kf b kg kh ki kj kk kl km kn mi kp kq kr mj kt ku kv mk kx ky kz la ij bi translated"><a class="ae kc" href="https://www.vaultproject.io/docs/secrets/ssh/signed-ssh-certificates.html" rel="noopener ugc nofollow" target="_blank">https://www . vault project . io/docs/secrets/ssh/signed-ssh-certificates . html</a></p></blockquote><h1 id="234a" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">3:设置SSH配置文件</h1><p id="1ee9" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">SSH配置文件通过将所有连接信息移动到一个文件中来帮助您摆脱SSH命令行的冗长。下面是一个默认SSH配置文件的例子，它允许我只需输入<code class="fe na nb nc mq b">ssh poc_kafka</code>就可以通过堡垒进入我的开发Kafka服务器:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="fe54" class="mu lc iq mq b gy mv mw l mx my"># ------------------<br/># cat ~/.ssh/config<br/># ------------------</span><span id="136a" class="mu lc iq mq b gy mz mw l mx my">Host poc_datastax<br/>  Hostname datastax.poc.internal.net</span><span id="9955" class="mu lc iq mq b gy mz mw l mx my">Host poc_loopback<br/>  Hostname loopback.poc.internal.net</span><span id="4fa1" class="mu lc iq mq b gy mz mw l mx my">Host <strong class="mq ir">poc_kafka</strong><br/>  Hostname kafka.poc.internal.net</span><span id="7120" class="mu lc iq mq b gy mz mw l mx my">Host <strong class="mq ir">poc_*</strong><br/>  IdentityFile ~/.ssh/id_rsa<br/>  CertificateFile ~/.ssh/id_rsa-poc-cert.pub<br/>  ProxyCommand ssh bastion_shrd nc %h %p 2&gt; /dev/null<br/>  User ec2-user</span><span id="7fcf" class="mu lc iq mq b gy mz mw l mx my"># Tunnel SSH connections through a single subnet<br/>Host bastion_shrd<br/>  Hostname bastion.shrd.internal.net<br/>  IdentityFile ~/.ssh/id_rsa<br/>  CertificateFile ~/.ssh/id_rsa-poc-cert.pub<br/>  User ec2-user</span></pre><p id="53b0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">除此之外，您还可以将这些信息分成多个文件，然后使用它们来分隔您的环境:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="f00d" class="mu lc iq mq b gy mv mw l mx my">ssh -F ~/.ssh/config-<strong class="mq ir">stg</strong>  loopback<br/>ssh -F ~/.ssh/config-<strong class="mq ir">prod</strong> loopback</span></pre><blockquote class="me mf mg"><p id="7e88" class="kd ke mh kf b kg kh ki kj kk kl km kn mi kp kq kr mj kt ku kv mk kx ky kz la ij bi translated"><a class="ae kc" href="https://linux.die.net/man/5/ssh_config" rel="noopener ugc nofollow" target="_blank">https://linux.die.net/man/5/ssh_config</a></p></blockquote><h1 id="41c8" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">4:通过源代码控制共享SSH配置</h1><p id="d16f" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们在ssh配置文件上遇到的一个问题是，它们很快就会过时，而且很难在整个团队中保持最新的SSH信息同步。</p><p id="6e77" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">作为一个解决方案，我们最近开始对每个项目的SSH配置文件进行源代码控制，以便在需要特定工作负载的连接信息时，很容易知道去哪里:如果我需要访问Kafka服务器，我应该能够在Kafka git repo中找到连接信息。</p><p id="5faa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个解决方案也可以应用于Ansible项目，这样SSH连接信息就保存在代码旁边:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="f20f" class="mu lc iq mq b gy mv mw l mx my"># ------------------<br/># cat ./ansible.cfg<br/># ------------------</span><span id="8380" class="mu lc iq mq b gy mz mw l mx my">[defaults]<br/>inventory = ./inventory.ini<br/>remote_user = ec2-user</span><span id="e2ad" class="mu lc iq mq b gy mz mw l mx my">host_key_checking = false<br/>retry_files_enabled = false<br/>retry_files_enabled=false<br/>nocows = true</span><span id="dd62" class="mu lc iq mq b gy mz mw l mx my">[privilege_escalation]<br/>become = true<br/>become_method = sudo</span><span id="bba3" class="mu lc iq mq b gy mz mw l mx my">[ssh_connection]<br/>control_path = %(directory)s/%%h-%%r<br/>pipelining = true<br/><strong class="mq ir">ssh_args = -F ./ansible-ssh.cfg</strong></span></pre><p id="7e95" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们将所有连接信息打包到本地SSH配置文件中，如下所示:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="e857" class="mu lc iq mq b gy mv mw l mx my"># ---------------------<br/># cat ./ansible-ssh.cfg<br/># ---------------------</span><span id="5985" class="mu lc iq mq b gy mz mw l mx my">Host bastion_shrd<br/>  Hostname bastion.shrd.internal.net<br/>  IdentityFile ~/.ssh/id_rsa<br/>  CertificateFile ~/.ssh/id_rsa-poc-cert.pub<br/>  User ec2-user</span><span id="5dfc" class="mu lc iq mq b gy mz mw l mx my">Host 10.90.?.*<br/>  CertificateFile ~/.ssh/id_rsa-poc-cert.pub</span><span id="eb4a" class="mu lc iq mq b gy mz mw l mx my">Host 10.90.3?.*<br/>  CertificateFile ~/.ssh/id_rsa-dev-cert.pub</span><span id="ebb9" class="mu lc iq mq b gy mz mw l mx my">Host 10.90.6?.*<br/>  CertificateFile ~/.ssh/id_rsa-shrd-cert.pub</span><span id="5460" class="mu lc iq mq b gy mz mw l mx my">Host 10.90.*.*<br/>  IdentityFile ~/.ssh/id_rsa<br/>  ProxyCommand ssh -F ./ansible-ssh.cfg bastion_shrd nc %h %p 2&gt; /dev/null<br/>  User ec2-user</span></pre><h1 id="532f" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">5:通过双因素OpenVPN +管理网络堡垒的隧道SSH</h1><p id="87a4" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们所有的服务器都运行在私有网络和dns后面的云中。这意味着，如果没有某种网络魔法，就无法从我们的桌面访问服务。这就是OpenVPN派上用场的地方:</p><ul class=""><li id="15bd" class="nd ne iq kf b kg kh kk kl ko nf ks ng kw nh la ni nj nk nl bi translated">它充当NAT，允许连接的客户端访问私有网络IP。</li><li id="edc9" class="nd ne iq kf b kg nm kk nn ko no ks np kw nq la ni nj nk nl bi translated">它可以修改桌面的默认DNS服务器来使用OpenVPN的服务器，这样就可以解析私有DNS记录。</li><li id="759e" class="nd ne iq kf b kg nm kk nn ko no ks np kw nq la ni nj nk nl bi translated">它可以与LDAP身份提供者集成，通过双因素身份认证进行增强，处理暴力密码攻击，控制哪个用户可以访问哪个范围的子网等。</li></ul><p id="38b4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">话虽如此，但并不是网络中的每个人，无论是人还是机器，都应该拥有SSH功能:我们不希望任何恶意的受损服务器在其他机器周围打探。为了控制这种情况，我们在网络级别设置了ACL，以将SSH连接限制到一个管理子网，该子网还托管了Jenkins和Ansible Tower等自动化引擎。我们还在这个子网中放置了一个SSH堡垒，这样来自OpenVPN的可信用户就可以通过它到达环境中的其他服务器。</p><figure class="ml mm mn mo gt jr gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/15faae0e816d619ba628d650d2e1cbae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1010/format:webp/1*qmzQg5S3R6-SUmPDKn4FmQ.jpeg"/></div></figure><h1 id="ed31" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">6:通过报告/var/log/secure文件来监控活动</h1><p id="e26a" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们还没有开始这方面的工作，但是正如我们在下面看到的，SSH证书的使用给我们留下了用户到连接的信息。我们目前正在将这些日志记录信息放入一个中央存储库，但在未来，我们希望创建图形分析和指标来了解我们的服务器周围的行为。</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="b310" class="mu lc iq mq b gy mv mw l mx my">Aug  4 02:20:46 ip-x-x-x-x sshd[12437]: Accepted publickey for ec2-user from x.x.x.x port 55746 ssh2: RSA-CERT ID <a class="ae kc" href="mailto:vault-ldap-first.last@ldapdomain.com.au" rel="noopener ugc nofollow" target="_blank">vault-ldap-first.last@ldapdomain.com.au</a>-1c5ea7ca827f81296db79c94cc2b46acb908cc14d84eaa28701dfc9748794465 (serial 1112258391964872070) CA RSA SHA256:VXSUR8gWWDItRMTMMhgC2XrUxvMtk4b5qacG8RyUX3g</span><span id="0c41" class="mu lc iq mq b gy mz mw l mx my">Aug  4 02:20:47 ip-x-x-x-x sshd[12437]: pam_unix(sshd:session): session opened for user ec2-user by (uid=0)</span><span id="7cbc" class="mu lc iq mq b gy mz mw l mx my">Aug  4 02:20:48 ip-x-x-x-x sshd[12440]: Received disconnect from x.x.x.x port 55746:11: disconnected by user</span><span id="a9b5" class="mu lc iq mq b gy mz mw l mx my">Aug  4 02:20:48 ip-x-x-x-x sshd[12440]: Disconnected from x.x.x.x port 55746</span><span id="94f2" class="mu lc iq mq b gy mz mw l mx my">Aug  4 02:20:48 ip-x-x-x-x sshd[12437]: pam_unix(sshd:session): session closed for user ec2-user</span></pre><h1 id="0d69" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">包扎</h1><p id="dbaf" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如您所见，SSH管理不是一项简单的任务。如果除了Google之外的云提供商能够提供现成的SSH管理，让事情变得更简单，那就太好了。我希望在此之前，这篇文章能够在这方面提供一些思路。</p><p id="3d9c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">干杯</p></div></div>    
</body>
</html>