<html>
<head>
<title>Kubernetes Networking: Behind the scenes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">库本尼斯网络:幕后</h1>
<blockquote>原文：<a href="https://itnext.io/kubernetes-networking-behind-the-scenes-39a1ab1792bb?source=collection_archive---------0-----------------------#2018-07-17">https://itnext.io/kubernetes-networking-behind-the-scenes-39a1ab1792bb?source=collection_archive---------0-----------------------#2018-07-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="66fc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">凯尔西·海托华的《艰难之路》指南中，我最喜欢的一点是——除了它能在AWS上运行(T2)之外！)—它保持了网络的干净和简单；例如，这是了解集装箱网络接口(<a class="ae kl" href="https://github.com/containernetworking/cni/blob/master/SPEC.md" rel="noopener ugc nofollow" target="_blank"> CNI </a>)作用的绝佳机会。话虽如此，Kubernetes的网络并不十分直观，尤其是对于新手来说……不要忘记“<a class="ae kl" href="https://www.youtube.com/watch?v=t98CX8Tberc" rel="noopener ugc nofollow" target="_blank">没有容器网络</a>”</p><p id="d71c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">虽然关于这个主题有很好的资源(链接<a class="ae kl" href="https://github.com/nleiva/kubernetes-networking-links" rel="noopener ugc nofollow" target="_blank">在这里</a>)，但是我找不到一个例子把所有的点和网络工程师喜欢和讨厌的命令输出联系起来，展示幕后实际发生的事情。所以，我决定从许多不同的来源收集这些信息，希望能帮助你更好地理解事物是如何联系在一起的。这不仅对于验证目的很重要，而且对于简化故障诊断也很重要。您可以在自己的<a class="ae kl" href="https://github.com/kelseyhightower/kubernetes-the-hard-way" rel="noopener ugc nofollow" target="_blank"> Kubernetes The Hard Way </a>集群中遵循这个示例，因为所有的IP寻址和设置都是从该集群中获取的(2018年5月提交，在<a class="ae kl" href="https://nabla-containers.github.io/" rel="noopener ugc nofollow" target="_blank"> Nabla Containers </a>之前)。</p><p id="af1d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们从头开始；我们有三个控制器和三个工作节点。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/145888904373b096aa0d01d8a8dd9fbf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FWHZ6tqgLFJDqgEf8n9n0w.png"/></div></div></figure><p id="6522" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可能会注意到，至少还有三个不同的专用网络子网！。请耐心等待，我们将探索它们。请记住，虽然我们指的是非常特定的IP前缀，但这些只是为《艰难之路》指南<a class="ae kl" href="https://github.com/kelseyhightower/kubernetes-the-hard-way" rel="noopener ugc nofollow" target="_blank">Kubernetes</a>选择的前缀，因此它们具有本地意义，您可以根据您的环境选择任何其他<a class="ae kl" href="https://tools.ietf.org/html/rfc1918" rel="noopener ugc nofollow" target="_blank"> RFC 1918 </a>地址块。我将为IPv6发布一篇单独的博客文章。</p><h1 id="a857" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated"><strong class="ak">节点网络(10.240.0.0/24) </strong></h1><p id="385a" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">这是内部网络，您的所有节点都是其中的一部分，当<a class="ae kl" href="https://github.com/nleiva/kubernetes-the-hard-way/blob/master/docs/03-compute-resources.md#kubernetes-workers" rel="noopener ugc nofollow" target="_blank">配置计算资源</a>时，用<a class="ae kl" href="https://cloud.google.com/sdk/gcloud/reference/compute/instances/create" rel="noopener ugc nofollow" target="_blank"> GCP </a>中的标志<code class="fe mb mc md me b">— private-network-ip</code>或<a class="ae kl" href="https://docs.aws.amazon.com/cli/latest/reference/ec2/run-instances.html" rel="noopener ugc nofollow" target="_blank"> AWS </a>中的选项<code class="fe mb mc md me b">— private-ip-address</code>指定。</p><p id="683c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">在GCP配置控制器节点</strong></p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="5ce8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">在AWS中配置控制器节点</strong></p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mf mg l"/></div></figure><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi mh"><img src="../Images/03f149a9b7a5868e16836d4ab265351e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0zjen_ez2-cwL-kG_ywpYQ.png"/></div></div></figure><p id="4ad7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每个实例将有两个IP地址；一个来自节点网络的私有IP地址(控制器:<code class="fe mb mc md me b">10.240.0.1${i}/24</code>，工人:<code class="fe mb mc md me b">10.240.0.2${i}/24</code>)和一个由您的云提供商分配的公共IP地址，我们将在稍后到达<code class="fe mb mc md me b">NodePorts</code>时讨论这个问题。</p><p id="35e7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> GCP </strong></p><pre class="kn ko kp kq gt mi me mj mk aw ml bi"><span id="04c9" class="mm kz iq me b gy mn mo l mp mq">$ <strong class="me ir">gcloud compute instances list</strong></span><span id="16e9" class="mm kz iq me b gy mr mo l mp mq">NAME          ZONE        MACHINE_TYPE   PREEMPTIBLE  INTERNAL_IP  EXTERNAL_IP     STATUS<br/>controller-0  us-west1-c  n1-standard-1               10.240.0.10  35.231.XXX.XXX  RUNNING<br/>worker-1      us-west1-c  n1-standard-1               10.240.0.21  35.231.XX.XXX   RUNNING<br/>...</span></pre><p id="4f1f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> AWS </strong></p><pre class="kn ko kp kq gt mi me mj mk aw ml bi"><span id="1050" class="mm kz iq me b gy mn mo l mp mq">$ <strong class="me ir">aws ec2 describe-instances --query 'Reservations[].Instances[].[Tags[?Key==`Name`].Value[],PrivateIpAddress,PublicIpAddress]' --output text | sed '$!N;s/\n/ /'</strong><br/>10.240.0.10    34.228.XX.XXX controller-0<br/>10.240.0.21    34.173.XXX.XX worker-1<br/>...</span></pre><p id="d4d5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果<a class="ae kl" href="https://github.com/nleiva/kubernetes-the-hard-way/blob/master/docs/03-compute-resources.md#firewall-rules" rel="noopener ugc nofollow" target="_blank">安全策略是正确的</a>(…并且如果ping确实安装在主机中)，所有节点应该能够彼此ping通。</p><h1 id="6628" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated"><strong class="ak"> Pod网络(10.200.0.0/16) </strong></h1><p id="71d4" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">这是豆荚生活的网络。每个工作节点运行该网络的一个子网。在我们为<code class="fe mb mc md me b">worker-${i}</code>设置的<code class="fe mb mc md me b">POD_CIDR=10.200.${i}.0/24</code>中。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi ms"><img src="../Images/82c9a6ccebd52685cc43ed11cecd43dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PWUwwjXZOnV7nQlZN2i3gg.png"/></div></div></figure><p id="823d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了理解这是如何设置的，我们需要后退一步，回顾一下<a class="ae kl" href="https://kubernetes.io/docs/concepts/cluster-administration/networking/#kubernetes-model" rel="noopener ugc nofollow" target="_blank"> Kubernetes网络模型</a>，它要求:</p><ul class=""><li id="a8d0" class="mt mu iq jp b jq jr ju jv jy mv kc mw kg mx kk my mz na nb bi translated">所有容器都可以在没有NAT的情况下与所有其它容器通信</li><li id="c7bf" class="mt mu iq jp b jq nc ju nd jy ne kc nf kg ng kk my mz na nb bi translated">所有节点都可以在没有NAT的情况下与所有容器通信(反之亦然)</li><li id="20d0" class="mt mu iq jp b jq nc ju nd jy ne kc nf kg ng kk my mz na nb bi translated">容器将自己视为的IP与其他容器视为的IP相同</li></ul><p id="b2b1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">考虑到可以有多种方式来满足这些，Kubernetes通常会将网络设置交给一个<a class="ae kl" href="https://github.com/containernetworking/cni/blob/master/SPEC.md#overview-1" rel="noopener ugc nofollow" target="_blank"> CNI插件</a>。</p><blockquote class="nh ni nj"><p id="ac9e" class="jn jo nk jp b jq jr js jt ju jv jw jx nl jz ka kb nm kd ke kf nn kh ki kj kk ij bi translated">CNI插件负责将网络接口插入容器<strong class="jp ir">网络名称空间</strong>(例如<strong class="jp ir"> veth对</strong>的一端)并在主机上进行任何必要的更改(例如将veth的另一端连接到网桥)。然后，它应该将IP分配给接口，并通过调用适当的IPAM插件<em class="iq">设置与IP地址管理部分一致的路由。【</em> <a class="ae kl" href="https://github.com/containernetworking/cni/blob/master/SPEC.md#cni-plugin" rel="noopener ugc nofollow" target="_blank"> <em class="iq"> CNI插件概述</em></a><em class="iq">】</em></p></blockquote><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi no"><img src="../Images/fe91428bfb96c2f4889269fc39c9f006.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tMZfRpG4tzSx5yjz-CIMaw.png"/></div></div></figure><h2 id="7c8e" class="mm kz iq bd la np nq dn le nr ns dp li jy nt nu lm kc nv nw lq kg nx ny lu nz bi translated">网络命名空间</h2><blockquote class="nh ni nj"><p id="840e" class="jn jo nk jp b jq jr js jt ju jv jw jx nl jz ka kb nm kd ke kf nn kh ki kj kk ij bi translated">一个<strong class="jp ir">命名空间</strong>将一个全局系统资源封装在一个抽象中，使得命名空间中的进程看起来拥有自己的全局资源的独立实例。对全局资源的改变对于作为名称空间成员的其他进程是可见的，但是对于其他进程是不可见的<em class="iq">。</em><em class="iq"/><a class="ae kl" href="http://man7.org/linux/man-pages/man7/namespaces.7.html" rel="noopener ugc nofollow" target="_blank"><em class="iq">名称空间手册页</em></a><em class="iq"/></p></blockquote><p id="6855" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Linux提供了七种不同的名称空间(<code class="fe mb mc md me b">Cgroup</code>、<code class="fe mb mc md me b">IPC</code>、<code class="fe mb mc md me b">Network</code>、<code class="fe mb mc md me b">Mount</code>、<code class="fe mb mc md me b">PID</code>、<code class="fe mb mc md me b">User</code>和<code class="fe mb mc md me b">UTS</code>)。网络名称空间(<code class="fe mb mc md me b">CLONE_NEWNET</code>)决定了进程可用的网络资源，“<em class="nk">每个网络名称空间都有自己的网络设备、IP地址、IP路由表、</em> <code class="fe mb mc md me b"><em class="nk">/proc/net</em></code> <em class="nk">目录、端口号等等</em>”。[ <a class="ae kl" href="https://lwn.net/Articles/531114/" rel="noopener ugc nofollow" target="_blank">操作中的名称空间</a></p><h2 id="a0c1" class="mm kz iq bd la np nq dn le nr ns dp li jy nt nu lm kc nv nw lq kg nx ny lu nz bi translated">虚拟以太网(Veth)设备</h2><blockquote class="nh ni nj"><p id="ef1c" class="jn jo nk jp b jq jr js jt ju jv jw jx nl jz ka kb nm kd ke kf nn kh ki kj kk ij bi translated"><strong class="jp ir">虚拟网络(veth) </strong>设备对提供类似管道的抽象，可用于在网络名称空间之间创建隧道，并可用于创建到另一个名称空间中的物理网络设备的桥。当一个名称空间被释放时，它包含的veth设备被销毁。<em class="iq"/><a class="ae kl" href="http://man7.org/linux/man-pages/man7/network_namespaces.7.html" rel="noopener ugc nofollow" target="_blank"><em class="iq">网络名称空间手册页</em></a><em class="iq"/></p></blockquote><p id="b8bb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们回到现实，看看这一切是如何应用到我们的集群。首先，Kubernetes中的<a class="ae kl" href="https://kubernetes.io/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/" rel="noopener ugc nofollow" target="_blank">网络插件</a>有几种口味；CNI插件是其中之一(<a class="ae kl" href="https://kubernetes.io/blog/2016/01/why-kubernetes-doesnt-use-libnetwork/" rel="noopener ugc nofollow" target="_blank">为什么不是CNM </a>？).每个节点中的<a class="ae kl" href="https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet/#kubelet" rel="noopener ugc nofollow" target="_blank"> Kubelet </a>将告诉容器运行时使用什么<a class="ae kl" href="https://kubernetes.io/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/" rel="noopener ugc nofollow" target="_blank">网络插件</a>。容器网络接口(<a class="ae kl" href="https://github.com/containernetworking/cni/blob/master/SPEC.md" rel="noopener ugc nofollow" target="_blank"> CNI </a>)位于容器运行时和网络实现之间。只有CNI插件配置网络。</p><blockquote class="nh ni nj"><p id="85fc" class="jn jo nk jp b jq jr js jt ju jv jw jx nl jz ka kb nm kd ke kf nn kh ki kj kk ij bi translated">通过向Kubelet传递命令行选项<code class="fe mb mc md me b">— network-plugin=cni</code>来选择CNI插件。Kubelet从<code class="fe mb mc md me b">— cni-conf-dir</code>(默认为<code class="fe mb mc md me b">/etc/cni/net.d</code>)读取一个文件，并使用该文件中的CNI配置来设置每个pod的网络。[ <a class="ae kl" href="https://kubernetes.io/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/#network-plugin-requirements" rel="noopener ugc nofollow" target="_blank">网络插件需求</a></p></blockquote><p id="cf8e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">实际的CNI插件二进制文件位于<code class="fe mb mc md me b">— cni-bin-dir</code>(默认为<code class="fe mb mc md me b">/opt/cni/bin</code>)</p><p id="e37b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意我们的<a class="ae kl" href="https://github.com/nleiva/kubernetes-the-hard-way/blob/master/docs/09-bootstrapping-kubernetes-workers.md#configure-the-kubelet" rel="noopener ugc nofollow" target="_blank"> kubelet.service </a>执行参数包括<code class="fe mb mc md me b">network-plugin=cni</code>。</p><pre class="kn ko kp kq gt mi me mj mk aw ml bi"><span id="80a4" class="mm kz iq me b gy mn mo l mp mq">[Service]<br/>ExecStart=/usr/local/bin/kubelet \\<br/>  --config=/var/lib/kubelet/kubelet-config.yaml \\<br/>  --<strong class="me ir">network-plugin=cni</strong> \\<br/>  ...</span></pre><p id="7fb7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在调用任何插件之前，Kubernetes首先为pod创建网络名称空间。这是通过创建一个<code class="fe mb mc md me b">pause</code>容器来完成的，该容器“<em class="nk">充当pod </em>中所有容器的“父容器””[ <a class="ae kl" href="https://www.ianlewis.org/en/almighty-pause-container" rel="noopener ugc nofollow" target="_blank">全能暂停容器</a> ]。Kubernetes然后调用CNI插件将<code class="fe mb mc md me b">pause</code>容器加入网络。pod中的所有容器都使用<code class="fe mb mc md me b">pause</code>网络名称空间(<code class="fe mb mc md me b">netns</code>)。</p><pre class="kn ko kp kq gt mi me mj mk aw ml bi"><span id="921c" class="mm kz iq me b gy mn mo l mp mq">{<br/>    "cniVersion": "0.3.1",<br/>    "name": "bridge",<br/>    "<strong class="me ir">type</strong>": "<strong class="me ir">bridge</strong>",<br/>    "bridge": "<strong class="me ir">cnio0</strong>",<br/>    "isGateway": true,<br/>    "ipMasq": true,<br/>    "<strong class="me ir">ipam</strong>": {<br/>        "type": "<strong class="me ir">host-local</strong>",<br/>        "ranges": [<br/>          [{"subnet": "${POD_CIDR}"}]<br/>        ],<br/>        "routes": [{"dst": "0.0.0.0/0"}]<br/>    }<br/>}</span></pre><p id="cba2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的<a class="ae kl" href="https://github.com/nleiva/kubernetes-the-hard-way/blob/master/docs/09-bootstrapping-kubernetes-workers.md#configure-cni-networking" rel="noopener ugc nofollow" target="_blank"> CNI配置</a>指示我们使用<code class="fe mb mc md me b">bridge</code>插件在根名称空间中配置一个名为<code class="fe mb mc md me b">cnio0</code>(<a class="ae kl" href="https://github.com/containernetworking/plugins/blob/v0.6.0/plugins/main/bridge/bridge.go#L38" rel="noopener ugc nofollow" target="_blank">默认名称是cni0 </a>)的L2 Linux软件桥，作为网关(<code class="fe mb mc md me b">“isGateway”: true</code>)。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi oa"><img src="../Images/6826d6a320dd60b131aaf164a49dd73a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*onIKAmOzQ8VybP7P6rrrFQ.png"/></div></div></figure><p id="6d35" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它还将<a class="ae kl" href="https://github.com/containernetworking/plugins/blob/v0.6.0/plugins/main/bridge/bridge.go#L335" rel="noopener ugc nofollow" target="_blank">设置一个veth对</a>将pod连接到刚刚创建的桥上。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi ob"><img src="../Images/70cff65487249ce4e916cf4c2a1e3b32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SE-BgF6jp86NmZWMM9TJ6Q.png"/></div></div></figure><p id="cb3f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了分配L3信息，例如IP地址，调用IPAM插件(<code class="fe mb mc md me b">ipam</code>)。在这种情况下，类型是<code class="fe mb mc md me b">host-local</code>“<em class="nk">将状态本地存储在主机文件系统上，从而确保单个主机上IP地址的唯一性</em>”[<a class="ae kl" href="https://github.com/containernetworking/plugins/tree/master/plugins/ipam/host-local#overview" rel="noopener ugc nofollow" target="_blank">主机本地插件</a> ]。IPAM插件将该信息返回给前一个插件(<code class="fe mb mc md me b">bridge</code>)，因此可以配置配置中提供的任何路由(<code class="fe mb mc md me b">“routes”: [{“dst”: “0.0.0.0/0”}]</code>)。如果没有提供<code class="fe mb mc md me b">gw</code>，它将从子网派生<a class="ae kl" href="https://github.com/containernetworking/plugins/blob/v0.6.0/pkg/ipam/ipam.go#L83-L89" rel="noopener ugc nofollow" target="_blank">。在指向网桥的pod网络命名空间中也配置了默认路由(使用pod子网的第一个IP进行配置)。</a></p><p id="ea6b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后但同样重要的是，我们还请求伪装(<code class="fe mb mc md me b">“ipMasq”: true</code>)来自pod网络的流量。我们在这里并不真的需要NAT，但这是Kubernetes中的配置。因此，为了完整起见，我应该提到为这个特殊例子配置的<code class="fe mb mc md me b">bridge</code>插件<code class="fe mb mc md me b">iptables</code>中的条目；来自目的地不在范围<code class="fe mb mc md me b">224.0.0.0/4</code> <a class="ae kl" href="https://github.com/containernetworking/plugins/blob/v0.6.0/pkg/ip/ipmasq.go#L26-L74" rel="noopener ugc nofollow" target="_blank">内的pod的所有数据包都将被NAT</a>，这在某种程度上与“<em class="nk">所有容器无需NAT即可与所有其他容器通信</em>”不一致。嗯，我们会证明你不需要NAT简而言之。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="oc mg l"/></div></figure><h2 id="39a6" class="mm kz iq bd la np nq dn le nr ns dp li jy nt nu lm kc nv nw lq kg nx ny lu nz bi translated">Pod路由</h2><p id="6206" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">我们现在准备配置pod。我们将查看一个worker节点中的所有网络名称空间，并在创建一个<code class="fe mb mc md me b">nginx</code>部署后分析其中一个名称空间，如这里的<a class="ae kl" href="https://github.com/kelseyhightower/kubernetes-the-hard-way/blob/master/docs/13-smoke-test.md#deployments" rel="noopener ugc nofollow" target="_blank">所述</a>。我们将使用带有选项<code class="fe mb mc md me b">-t</code>的<code class="fe mb mc md me b">lsns </code>来选择名称空间的类型(<code class="fe mb mc md me b">net</code>)。</p><pre class="kn ko kp kq gt mi me mj mk aw ml bi"><span id="c0fa" class="mm kz iq me b gy mn mo l mp mq">ubuntu@<strong class="me ir">worker-0</strong>:~$ <strong class="me ir">sudo lsns -t net</strong><br/>        NS TYPE NPROCS   PID USER COMMAND<br/>4026532089 net     113     1 root /sbin/init<br/>4026532280 net       2  8046 root /pause<br/>4026532352 net       4 16455 root /pause<br/><strong class="me ir">4026532426</strong> net       3 27255 root /<strong class="me ir">pause</strong></span></pre><p id="b8d6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以通过<code class="fe mb mc md me b">ls</code>中的<code class="fe mb mc md me b">-i</code>选项找出这些的<code class="fe mb mc md me b">inode</code>号。</p><pre class="kn ko kp kq gt mi me mj mk aw ml bi"><span id="3223" class="mm kz iq me b gy mn mo l mp mq">ubuntu@<strong class="me ir">worker-0</strong>:~$ <strong class="me ir">ls -1i /var/run/netns</strong><br/>4026532352 cni-1d85bb0c-7c61-fd9f-2adc-f6e98f7a58af<br/>4026532280 cni-7cec0838-f50c-416a-3b45-628a4237c55c<br/><strong class="me ir">4026532426</strong> <strong class="me ir">cni-912bcc63-712d-1c84-89a7-9e10510808a0</strong></span></pre><p id="bad3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">也可以选择用<code class="fe mb mc md me b">ip netns</code>列出所有的网络名称空间。</p><pre class="kn ko kp kq gt mi me mj mk aw ml bi"><span id="acf5" class="mm kz iq me b gy mn mo l mp mq">ubuntu@<strong class="me ir">worker-0</strong>:~$ <strong class="me ir">ip netns</strong><br/><strong class="me ir">cni-912bcc63-712d-1c84-89a7-9e10510808a0</strong> (id: 2)<br/>cni-1d85bb0c-7c61-fd9f-2adc-f6e98f7a58af (id: 1)<br/>cni-7cec0838-f50c-416a-3b45-628a4237c55c (id: 0)</span></pre><p id="f4c8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了查看在网络名称空间<code class="fe mb mc md me b">cni-912bcc63–712d-1c84–89a7–9e10510808a0</code> ( <code class="fe mb mc md me b">4026532426</code>)中运行的所有进程，您可以这样做:</p><pre class="kn ko kp kq gt mi me mj mk aw ml bi"><span id="079e" class="mm kz iq me b gy mn mo l mp mq">ubuntu@<strong class="me ir">worker-0</strong>:~$ <strong class="me ir">sudo ls -l /proc/[1-9]*/ns/net | grep 4026532426  | cut -f3 -d"/" | xargs ps -p</strong><br/>  PID TTY      STAT   TIME COMMAND<br/><strong class="me ir">27255</strong> ?        Ss     0:00 /<strong class="me ir">pause</strong><br/>27331 ?        Ss     0:00 nginx: master process nginx -g daemon off;<br/>27355 ?        S      0:00 nginx: worker process</span></pre><p id="909d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这表明我们正在pod中运行<code class="fe mb mc md me b">nginx</code>和<code class="fe mb mc md me b">pause</code>。pod中的<code class="fe mb mc md me b">pause</code>容器和其余容器共享<code class="fe mb mc md me b">net</code>和<code class="fe mb mc md me b">ipc</code>名称空间。让我们将<code class="fe mb mc md me b">pause</code> PID <code class="fe mb mc md me b">27255</code>放在手边。</p><p id="acb5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们看看<code class="fe mb mc md me b">kubectl</code>能告诉我们关于这个吊舱的什么:</p><pre class="kn ko kp kq gt mi me mj mk aw ml bi"><span id="9479" class="mm kz iq me b gy mn mo l mp mq">$ <strong class="me ir">kubectl get pods -o wide | grep nginx</strong><br/><strong class="me ir">nginx-65899c769f-wxdx6</strong>   1/1       Running   0          5d        <strong class="me ir">10.200.0.4</strong>   worker-0</span></pre><p id="56dc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">更多细节:</p><pre class="kn ko kp kq gt mi me mj mk aw ml bi"><span id="e211" class="mm kz iq me b gy mn mo l mp mq">$ <strong class="me ir">kubectl describe pods nginx-65899c769f-wxdx6</strong><br/>Name:           nginx-65899c769f-wxdx6<br/>Namespace:      default<br/>Node:           worker-0/10.240.0.20<br/>Start Time:     Thu, 05 Jul 2018 14:20:06 -0400<br/>Labels:         pod-template-hash=2145573259<br/>                run=nginx<br/>Annotations:    &lt;none&gt;<br/>Status:         Running<br/>IP:             <strong class="me ir">10.200.0.4</strong><br/>Controlled By:  ReplicaSet/nginx-65899c769f<br/>Containers:<br/>  nginx:<br/>    Container ID:   containerd://<strong class="me ir">4c0bd2e2e5c0b17c637af83376879c38f2fb11852921b12413c54ba49d6983c7</strong><br/>    Image:          nginx<br/>...</span></pre><p id="b5b1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们有pod名称<code class="fe mb mc md me b">nginx-65899c769f-wxdx6 </code>和其中一个容器的ID(<code class="fe mb mc md me b">ngnix</code>)，但是没有关于<code class="fe mb mc md me b">pause</code>的任何信息。是时候深入挖掘worker节点来连接所有的点了。请记住<a class="ae kl" href="https://github.com/kelseyhightower/kubernetes-the-hard-way" rel="noopener ugc nofollow" target="_blank"> Kubernetes艰难地发现</a>不使用<a class="ae kl" href="https://www.docker.com/" rel="noopener ugc nofollow" target="_blank"> Docker </a>，因此我们将使用<a class="ae kl" href="https://github.com/containerd/containerd" rel="noopener ugc nofollow" target="_blank"> Containerd </a> CLI <code class="fe mb mc md me b">ctr</code>来探索容器细节。</p><pre class="kn ko kp kq gt mi me mj mk aw ml bi"><span id="6406" class="mm kz iq me b gy mn mo l mp mq">ubuntu@<strong class="me ir">worker-0</strong>:~$ <strong class="me ir">sudo ctr namespaces ls</strong><br/>NAME   LABELS<br/><strong class="me ir">k8s.i</strong>o</span></pre><p id="61df" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用<a class="ae kl" href="https://github.com/containerd/containerd" rel="noopener ugc nofollow" target="_blank">容器ID</a>名称空间(<code class="fe mb mc md me b">k8s.io</code>，我们可以获得<code class="fe mb mc md me b">ngnix</code>的容器ID:</p><pre class="kn ko kp kq gt mi me mj mk aw ml bi"><span id="4c69" class="mm kz iq me b gy mn mo l mp mq">ubuntu@<strong class="me ir">worker-0</strong>:~$ <strong class="me ir">sudo ctr -n k8s.io containers ls | grep nginx</strong><br/><strong class="me ir">4c0bd2e2e5c0b17c637af83376879c38f2fb11852921b12413c54ba49d6983c7</strong>    docker.io/library/<strong class="me ir">nginx</strong>:latest                                 io.containerd.runtime.v1.linux</span></pre><p id="acfe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">并暂停:</p><pre class="kn ko kp kq gt mi me mj mk aw ml bi"><span id="e1c6" class="mm kz iq me b gy mn mo l mp mq">ubuntu@<strong class="me ir">worker-0</strong>:~$ <strong class="me ir">sudo ctr -n k8s.io containers ls | grep pause</strong><br/>0866803b612f2f55e7b6b83836bde09bd6530246239b7bde1e49c04c7038e43a    k8s.gcr.io/pause:3.1                                           io.containerd.runtime.v1.linux<br/>21640aea0210b320fd637c22ff93b7e21473178de0073b05de83f3b116fc8834    k8s.gcr.io/pause:3.1                                           io.containerd.runtime.v1.linux<br/><strong class="me ir">d19b1b1c92f7cc90764d4f385e8935d121bca66ba8982bae65baff1bc2841da6</strong>    k8s.gcr.io/<strong class="me ir">pause</strong>:3.1                                           io.containerd.runtime.v1.linux</span></pre><p id="2816" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以<code class="fe mb mc md me b">983c7</code>结尾的<code class="fe mb mc md me b">ngnix</code>的容器ID与我们用<code class="fe mb mc md me b">kubectl</code>得到的相匹配。让我们看看能否找出哪个<code class="fe mb mc md me b">pause</code>容器属于<code class="fe mb mc md me b">nginx</code>容器。</p><pre class="kn ko kp kq gt mi me mj mk aw ml bi"><span id="d547" class="mm kz iq me b gy mn mo l mp mq">ubuntu@<strong class="me ir">worker-0</strong>:~$ <strong class="me ir">sudo ctr -n k8s.io task ls</strong><br/>TASK                                                                PID      STATUS<br/>...<br/><strong class="me ir">d19b1b1c92f7cc90764d4f385e8935d121bca66ba8982bae65baff1bc2841da6</strong>    27255    RUNNING<br/>4c0bd2e2e5c0b17c637af83376879c38f2fb11852921b12413c54ba49d6983c7    27331    RUNNING</span></pre><p id="33f7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您还记得在网络名称空间<code class="fe mb mc md me b">cni-912bcc63–712d-1c84–89a7–9e10510808a0</code>中运行的PID<code class="fe mb mc md me b">27331</code>和<code class="fe mb mc md me b">27355</code>吗？</p><pre class="kn ko kp kq gt mi me mj mk aw ml bi"><span id="9a54" class="mm kz iq me b gy mn mo l mp mq">ubuntu@<strong class="me ir">worker-0</strong>:~$ <strong class="me ir">sudo ctr -n k8s.io containers info d19b1b1c92f7cc90764d4f385e8935d121bca66ba8982bae65baff1bc2841da6</strong><br/>{<br/>    "ID": "<strong class="me ir">d19b1b1c92f7cc90764d4f385e8935d121bca66ba8982bae65baff1bc2841da6</strong>",<br/>    "Labels": {<br/>        "io.cri-containerd.kind": "sandbox",<br/>        "io.kubernetes.pod.name": "<strong class="me ir">nginx-65899c769f-wxdx6</strong>",<br/>        "io.kubernetes.pod.namespace": "default",<br/>        "io.kubernetes.pod.uid": "0b35e956-8080-11e8-8aa9-0a12b8818382",<br/>        "pod-template-hash": "2145573259",<br/>        "run": "nginx"<br/>    },<br/>    "Image": "k8s.gcr.io/<strong class="me ir">pause</strong>:3.1",<br/>...</span></pre><p id="0cba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">和</p><pre class="kn ko kp kq gt mi me mj mk aw ml bi"><span id="1e50" class="mm kz iq me b gy mn mo l mp mq">ubuntu@worker-0:~$ <strong class="me ir">sudo ctr -n k8s.io containers info 4c0bd2e2e5c0b17c637af83376879c38f2fb11852921b12413c54ba49d6983c7</strong><br/>{<br/>    "ID": "<strong class="me ir">4c0bd2e2e5c0b17c637af83376879c38f2fb11852921b12413c54ba49d6983c7</strong>",<br/>    "Labels": {<br/>        "io.cri-containerd.kind": "container",<br/>        "io.kubernetes.container.name": "nginx",<br/>        "io.kubernetes.pod.name": "<strong class="me ir">nginx-65899c769f-wxdx6</strong>",<br/>        "io.kubernetes.pod.namespace": "default",<br/>        "io.kubernetes.pod.uid": "0b35e956-8080-11e8-8aa9-0a12b8818382"<br/>    },<br/>    "Image": "docker.io/library/<strong class="me ir">nginx</strong>:latest",<br/>...</span></pre><p id="44ac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们现在确切地知道哪些容器正在这个pod ( <code class="fe mb mc md me b">nginx-65899c769f-wxdx6</code>)和网络名称空间(<code class="fe mb mc md me b">cni-912bcc63–712d-1c84–89a7–9e10510808a0</code>)中运行:</p><ul class=""><li id="f861" class="mt mu iq jp b jq jr ju jv jy mv kc mw kg mx kk my mz na nb bi translated">nginx (ID: <code class="fe mb mc md me b">4c0bd2e2e5c0b17c637af83376879c38f2fb11852921b12413c54ba49d6983c7</code>)</li><li id="dad2" class="mt mu iq jp b jq nc ju nd jy ne kc nf kg ng kk my mz na nb bi translated">暂停(ID: <code class="fe mb mc md me b">d19b1b1c92f7cc90764d4f385e8935d121bca66ba8982bae65baff1bc2841da6</code>)</li></ul><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi od"><img src="../Images/578db5d2cc47fe477e7b3af1ebfb6b18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KC8CRopspuplUDMPcAcOyw.png"/></div></div></figure><p id="dcda" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么，这个pod ( <code class="fe mb mc md me b">nginx-65899c769f-wxdx6</code>)实际上是如何连接网络的呢？。让我们用之前得到的<code class="fe mb mc md me b">pause</code> PID <code class="fe mb mc md me b">27255</code>在它的网络名称空间(<code class="fe mb mc md me b">cni-912bcc63–712d-1c84–89a7–9e10510808a0</code>)中运行命令。</p><pre class="kn ko kp kq gt mi me mj mk aw ml bi"><span id="c18d" class="mm kz iq me b gy mn mo l mp mq">ubuntu@<strong class="me ir">worker-0</strong>:~$ <strong class="me ir">sudo ip netns identify 27255</strong><br/><strong class="me ir">cni-912bcc63-712d-1c84-89a7-9e10510808a0</strong></span></pre><p id="48e4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为此，我们将使用<code class="fe mb mc md me b">nsenter</code>和选项<code class="fe mb mc md me b">-t</code>来指定目标pid，并提供不带文件的<code class="fe mb mc md me b">-n</code>，以便输入目标进程的网络名称空间(<code class="fe mb mc md me b">27255</code>)。让我们看看<code class="fe mb mc md me b">ip link show</code>，</p><pre class="kn ko kp kq gt mi me mj mk aw ml bi"><span id="a7df" class="mm kz iq me b gy mn mo l mp mq">ubuntu@<strong class="me ir">worker-0</strong>:~$ <strong class="me ir">sudo nsenter -t 27255 -n ip link show</strong><br/>1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000<br/>    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00<br/>3: <strong class="me ir">eth0</strong>@if7: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP mode DEFAULT group default<br/>    link/ether 0a:58:0a:c8:00:04 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span></pre><p id="7c64" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">并且<code class="fe mb mc md me b">ifconfig eth0</code>说:</p><pre class="kn ko kp kq gt mi me mj mk aw ml bi"><span id="042d" class="mm kz iq me b gy mn mo l mp mq">ubuntu@<strong class="me ir">worker-0</strong>:~$ <strong class="me ir">sudo nsenter -t 27255 -n ifconfig eth0</strong><br/><strong class="me ir">eth0</strong>: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500<br/>        inet <strong class="me ir">10.200.0.4</strong>  netmask 255.255.255.0  broadcast 0.0.0.0<br/>        inet6 fe80::2097:51ff:fe39:ec21  prefixlen 64  scopeid 0x20&lt;link&gt;<br/>        ether 0a:58:0a:c8:00:04  txqueuelen 0  (Ethernet)<br/>        RX packets 540  bytes 42247 (42.2 KB)<br/>        RX errors 0  dropped 0  overruns 0  frame 0<br/>        TX packets 177  bytes 16530 (16.5 KB)<br/>        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span></pre><p id="5a7b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们确认之前从<code class="fe mb mc md me b">kubectl get pod</code>获得的IP地址配置在pod的<code class="fe mb mc md me b">eth0</code>接口上。该接口是<strong class="jp ir"> veth对</strong>的一部分；一端在pod中，另一端在根命名空间中。为了找出另一端是什么接口，我们使用<code class="fe mb mc md me b">ethtool</code>。</p><pre class="kn ko kp kq gt mi me mj mk aw ml bi"><span id="e498" class="mm kz iq me b gy mn mo l mp mq">ubuntu@<strong class="me ir">worker-0</strong>:~$ <strong class="me ir">sudo ip netns exec cni-912bcc63-712d-1c84-89a7-9e10510808a0 ethtool -S eth0</strong><br/>NIC statistics:<br/>     peer_ifindex: <strong class="me ir">7</strong></span></pre><p id="b540" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这告诉我们对等体<code class="fe mb mc md me b">ifindex</code>是7。我们现在可以检查根名称空间中的内容。我们可以用<code class="fe mb mc md me b">ip link</code>做到这一点:</p><pre class="kn ko kp kq gt mi me mj mk aw ml bi"><span id="f133" class="mm kz iq me b gy mn mo l mp mq">ubuntu@<strong class="me ir">worker-0</strong>:~$ <strong class="me ir">ip link | grep '^7:'</strong><br/>7: <strong class="me ir">veth71f7d238</strong>@if3: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master cnio0 state UP mode DEFAULT group default</span></pre><p id="a98f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要复查，请参阅:</p><pre class="kn ko kp kq gt mi me mj mk aw ml bi"><span id="fa30" class="mm kz iq me b gy mn mo l mp mq">ubuntu@<strong class="me ir">worker-0</strong>:~$ <strong class="me ir">sudo cat /sys/class/net/veth71f7d238/ifindex</strong><br/>7</span></pre><p id="c470" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">酷，虚拟链接现在清楚了。我们可以用<code class="fe mb mc md me b">brctl</code>看看还有什么连接到我们的Linux桥:</p><pre class="kn ko kp kq gt mi me mj mk aw ml bi"><span id="e118" class="mm kz iq me b gy mn mo l mp mq">ubuntu@<strong class="me ir">worker-0</strong>:~$ <strong class="me ir">brctl show cnio0</strong><br/>bridge name    bridge id        STP enabled    interfaces<br/>cnio0        8000.0a580ac80001    no        veth71f7d238<br/>                                            veth73f35410<br/>                                            vethf273b35f</span></pre><p id="d508" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以我们有这个:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi oe"><img src="../Images/4b259a1ee8bcf0374a6dcd321623895a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BMPcFOtZBz7nL2m23Yn8fw.png"/></div></div></figure><h2 id="4706" class="mm kz iq bd la np nq dn le nr ns dp li jy nt nu lm kc nv nw lq kg nx ny lu nz bi translated">验证路由</h2><p id="a962" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">我们实际上是如何转发流量的？。让我们来看看pod的网络命名空间中的路由表:</p><pre class="kn ko kp kq gt mi me mj mk aw ml bi"><span id="2a45" class="mm kz iq me b gy mn mo l mp mq">ubuntu@<strong class="me ir">worker-0</strong>:~$ <strong class="me ir">sudo ip netns exec cni-912bcc63-712d-1c84-89a7-9e10510808a0 ip route show</strong><br/><strong class="me ir">default via 10.200.0.1</strong> dev eth0<br/>10.200.0.0/24 dev eth0 proto kernel scope link src 10.200.0.4</span></pre><p id="837e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，我们至少知道如何到达根名称空间(<code class="fe mb mc md me b">default via 10.200.0.1</code>)。现在让我们检查主机的路由表:</p><pre class="kn ko kp kq gt mi me mj mk aw ml bi"><span id="fb8f" class="mm kz iq me b gy mn mo l mp mq">ubuntu@<strong class="me ir">worker-0</strong>:~$ <strong class="me ir">ip route list</strong><br/><strong class="me ir">default via 10.240.0.1</strong> dev eth0 proto dhcp src 10.240.0.20 metric 100<br/>10.200.0.0/24 dev cnio0 proto kernel scope link src 10.200.0.1<br/>10.240.0.0/24 dev eth0 proto kernel scope link src 10.240.0.20<br/>10.240.0.1 dev eth0 proto dhcp scope link src 10.240.0.20 metric 100</span></pre><p id="1ce6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们知道如何将数据包转发到VPC路由器(<a class="ae kl" href="https://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_Route_Tables.html#RouteTables" rel="noopener ugc nofollow" target="_blank">您的VPC有一个隐式路由器</a>、<a class="ae kl" href="https://cloud.google.com/vpc/docs/vpc#reserved_ip_addresses_in_every_subnet" rel="noopener ugc nofollow" target="_blank">，它通常具有子网</a>的主IP范围内的第二个地址)。现在，VPC路由器知道如何到达每个pod网络吗？；不，它不会，所以你会期望CNI插件在那里安装路径，或者你只是手动<a class="ae kl" href="https://github.com/nleiva/kubernetes-the-hard-way/blob/master/docs/11-pod-network-routes.md#routes" rel="noopener ugc nofollow" target="_blank"/>(如指南中所示)。还没有检查，但是<a class="ae kl" href="https://github.com/aws/amazon-vpc-cni-k8s" rel="noopener ugc nofollow" target="_blank"> AWS CNI插件</a>可能会在AWS中为我们处理这个问题。记住有大量的<a class="ae kl" href="https://kubernetes.io/docs/concepts/cluster-administration/networking/#how-to-implement-the-kubernetes-networking-model" rel="noopener ugc nofollow" target="_blank"> CNI插件存在</a>，这个例子代表了<strong class="jp ir">最简单的网络设置</strong>。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi of"><img src="../Images/7ec3dc50cdd4bdd4f8274a8f9a535758.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JGfgQ0aUD5OwseC-aKDy6w.png"/></div></div></figure><h2 id="001a" class="mm kz iq bd la np nq dn le nr ns dp li jy nt nu lm kc nv nw lq kg nx ny lu nz bi translated">NAT深潜</h2><p id="d3ad" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">让我们使用<code class="fe mb mc md me b">kubectl create -f busybox.yaml</code>创建两个相同的带有复制控制器的<code class="fe mb mc md me b">busybox</code>容器。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="0eb1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们得到:</p><pre class="kn ko kp kq gt mi me mj mk aw ml bi"><span id="5532" class="mm kz iq me b gy mn mo l mp mq">$ <strong class="me ir">kubectl get pods -o wide</strong><br/>NAME                     READY     STATUS        RESTARTS   AGE       IP            NODE<br/>busybox0-g6pww           1/1       Running       0          4s        <strong class="me ir">10.200.1.15</strong>   worker-1<br/><strong class="me ir">busybox0-rw89s</strong>           1/1       Running       0          4s        10.200.0.21   worker-0<br/>...</span></pre><p id="e67c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从一个容器Pings另一个容器应该是成功的:</p><pre class="kn ko kp kq gt mi me mj mk aw ml bi"><span id="66cb" class="mm kz iq me b gy mn mo l mp mq">$ <strong class="me ir">kubectl exec -it busybox0-rw89s -- ping -c 2 10.200.1.15</strong><br/>PING 10.200.1.15 (10.200.1.15): 56 data bytes<br/>64 bytes from 10.200.1.15: seq=0 ttl=62 time=0.528 ms<br/>64 bytes from 10.200.1.15: seq=1 ttl=62 time=0.440 ms</span><span id="d13e" class="mm kz iq me b gy mr mo l mp mq">--- 10.200.1.15 ping statistics ---<br/>2 packets transmitted, 2 packets received, 0% packet loss<br/>round-trip min/avg/max = 0.440/0.484/0.528 ms</span></pre><p id="5e97" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要了解流量，您可以使用<code class="fe mb mc md me b">tcpdump</code>或<code class="fe mb mc md me b">conntrack</code>来捕获数据包。</p><pre class="kn ko kp kq gt mi me mj mk aw ml bi"><span id="1278" class="mm kz iq me b gy mn mo l mp mq">ubuntu@<strong class="me ir">worker-0</strong>:~$ <strong class="me ir">sudo conntrack -L | grep 10.200.1.15</strong><br/>icmp     1 29 <strong class="me ir">src=10.200.0.21</strong> dst=10.200.1.15 type=8 code=0 id=1280 src=10.200.1.15 <strong class="me ir">dst=10.240.0.20</strong> type=0 code=0 id=1280 mark=0 use=1</span></pre><p id="b6c3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">pod的源IP地址<code class="fe mb mc md me b">10.200.0.21</code>被转换为节点IP <code class="fe mb mc md me b">10.240.0.20</code>。</p><pre class="kn ko kp kq gt mi me mj mk aw ml bi"><span id="12e2" class="mm kz iq me b gy mn mo l mp mq">ubuntu@<strong class="me ir">worker-1</strong>:~$ <strong class="me ir">sudo conntrack -L | grep 10.200.1.15</strong><br/>icmp     1 28 <strong class="me ir">src=10.240.0.20</strong> dst=10.200.1.15 type=8 code=0 id=1280 src=10.200.1.15 <strong class="me ir">dst=10.240.0.20</strong> type=0 code=0 id=1280 mark=0 use=1</span></pre><p id="ef88" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以看到计数器在<code class="fe mb mc md me b">iptables</code>中增加，如下所示:</p><pre class="kn ko kp kq gt mi me mj mk aw ml bi"><span id="dad5" class="mm kz iq me b gy mn mo l mp mq">ubuntu@<strong class="me ir">worker-0</strong>:~$ <strong class="me ir">sudo iptables -t nat -Z POSTROUTING -L -v</strong><br/>Chain POSTROUTING (policy ACCEPT 0 packets, 0 bytes)<br/> pkts bytes target     prot opt in     out     source               destination<br/>...<br/>    <strong class="me ir">5</strong>   324 CNI-be726a77f15ea47ff32947a3  all  --  any    any     10.200.0.0/24        anywhere             /* name: "bridge" id: "631cab5de5565cc432a3beca0e2aece0cef9285482b11f3eb0b46c134e457854" */<br/>Zeroing chain `POSTROUTING'</span></pre><p id="9bd3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">另一方面，如果我们从CNI插件配置中删除了<code class="fe mb mc md me b">“ipMasq”: true</code>，我们会看到以下内容(我们不建议在运行的集群上更改此配置，这只是出于教育目的):</p><pre class="kn ko kp kq gt mi me mj mk aw ml bi"><span id="ec3b" class="mm kz iq me b gy mn mo l mp mq">$ <strong class="me ir">kubectl get pods -o wide</strong><br/>NAME                     READY     STATUS        RESTARTS   AGE       IP            NODE<br/><strong class="me ir">busybox0-2btxn</strong>           1/1       Running       0          16s       10.200.0.15   worker-0<br/>busybox0-dhpx8           1/1       Running       0          16s       <strong class="me ir">10.200.1.13</strong>   worker-1<br/>...</span></pre><p id="d072" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Ping应该还管用:</p><pre class="kn ko kp kq gt mi me mj mk aw ml bi"><span id="f1c6" class="mm kz iq me b gy mn mo l mp mq">$  <strong class="me ir">kubectl exec -it busybox0-2btxn -- ping -c 2 10.200.1.13</strong><br/>PING 10.200.1.6 (10.200.1.6): 56 data bytes<br/>64 bytes from 10.200.1.6: seq=0 ttl=62 time=0.515 ms<br/>64 bytes from 10.200.1.6: seq=1 ttl=62 time=0.427 ms</span><span id="08a5" class="mm kz iq me b gy mr mo l mp mq">--- 10.200.1.6 ping statistics ---<br/>2 packets transmitted, 2 packets received, 0% packet loss<br/>round-trip min/avg/max = 0.427/0.471/0.515 ms</span></pre><p id="2780" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在没有NAT的情况下:</p><pre class="kn ko kp kq gt mi me mj mk aw ml bi"><span id="bf0a" class="mm kz iq me b gy mn mo l mp mq">ubuntu@<strong class="me ir">worker-0</strong>:~$ <strong class="me ir">sudo conntrack -L | grep 10.200.1.13</strong><br/>icmp     1 29 <strong class="me ir">src=10.200.0.15</strong> dst=10.200.1.13 type=8 code=0 id=1792 src=10.200.1.13 <strong class="me ir">dst=10.200.0.15</strong> type=0 code=0 id=1792 mark=0 use=1</span></pre><p id="26e5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，我们刚刚验证了“所有容器都可以在没有NAT的情况下与所有其他容器进行通信”。</p><pre class="kn ko kp kq gt mi me mj mk aw ml bi"><span id="0049" class="mm kz iq me b gy mn mo l mp mq">ubuntu@<strong class="me ir">worker-1</strong>:~$ <strong class="me ir">sudo conntrack -L | grep 10.200.1.13</strong><br/>icmp     1 27 <strong class="me ir">src=10.200.0.15</strong> dst=10.200.1.13 type=8 code=0 id=1792 src=10.200.1.13 <strong class="me ir">dst=10.200.0.15</strong> type=0 code=0 id=1792 mark=0 use=1</span></pre><h1 id="ca34" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated"><strong class="ak">集群网络(10.32.0.0/24) </strong></h1><p id="266a" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">你可能注意到在<code class="fe mb mc md me b">busybox</code>的例子中，分配给<code class="fe mb mc md me b">busybox</code> pod的IP地址在每种情况下都是不同的。如果我们想让这些容器可用，这样其他的豆荚就可以到达呢？。你可以获取他们当前的pod IP地址，但这些最终会改变。因此，您希望配置一个服务资源，将请求代理到一组临时pod。</p><blockquote class="nh ni nj"><p id="0b13" class="jn jo nk jp b jq jr js jt ju jv jw jx nl jz ka kb nm kd ke kf nn kh ki kj kk ij bi translated">“Kubernetes中的服务是一种抽象，它定义了一组逻辑单元和访问它们的策略”<em class="iq"> [ </em> <a class="ae kl" href="https://kubernetes.io/docs/tutorials/kubernetes-basics/expose/expose-intro/" rel="noopener ugc nofollow" target="_blank"> <em class="iq"> Kubernetes服务</em> </a> <em class="iq"> ] </em></p></blockquote><p id="6558" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">公开服务有不同的方式；默认类型是<code class="fe mb mc md me b">ClusterIP</code>，它将在集群CIDR之外设置一个IP地址(只能从集群内部访问)。一个例子是在Kubernetes中配置的<a class="ae kl" href="https://github.com/kelseyhightower/kubernetes-the-hard-way" rel="noopener ugc nofollow" target="_blank"> DNS集群插件。</a></p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="a4ce" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mb mc md me b">kubectl</code>显示服务跟踪端点，它会为你做翻译。</p><pre class="kn ko kp kq gt mi me mj mk aw ml bi"><span id="2baf" class="mm kz iq me b gy mn mo l mp mq">$ <strong class="me ir">kubectl -n kube-system describe services</strong><br/>...<br/>Selector:          k8s-app=kube-dns<br/>Type:              <strong class="me ir">ClusterIP</strong><br/><strong class="me ir">IP:                10.32.0.10</strong><br/>Port:              dns  53/UDP<br/>TargetPort:        53/UDP<br/><strong class="me ir">Endpoints:         10.200.0.27:53</strong><br/>Port:              dns-tcp  53/TCP<br/>TargetPort:        53/TCP<br/>Endpoints:         10.200.0.27:53<br/>...</span></pre><p id="f4f7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">具体怎么做？… <code class="fe mb mc md me b">iptables</code>又来了。让我们看一下为这个例子创建的规则。您可以使用<code class="fe mb mc md me b">iptables-save</code>命令将它们全部列出。</p><p id="fcd9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于数据包是由一个进程产生的(<code class="fe mb mc md me b">OUTPUT</code>)或刚刚到达网络接口(<code class="fe mb mc md me b">PREROUTING</code>)，它们由以下<code class="fe mb mc md me b">iptables</code>链检查:</p><pre class="kn ko kp kq gt mi me mj mk aw ml bi"><span id="e918" class="mm kz iq me b gy mn mo l mp mq">-A <strong class="me ir">PREROUTING</strong> -m comment --comment "kubernetes service portals" -j <strong class="me ir">KUBE-SERVICES</strong><br/>-A <strong class="me ir">OUTPUT</strong> -m comment --comment "kubernetes service portals" -j <strong class="me ir">KUBE-SERVICES</strong></span></pre><p id="bb2c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以下目标匹配目的地为<code class="fe mb mc md me b">10.32.0.10</code>端口<code class="fe mb mc md me b">53</code>的<code class="fe mb mc md me b">TCP</code>数据包，并将目的地址转换为<code class="fe mb mc md me b">10.200.0.27</code>端口<code class="fe mb mc md me b">53</code>。</p><pre class="kn ko kp kq gt mi me mj mk aw ml bi"><span id="3e5f" class="mm kz iq me b gy mn mo l mp mq">-A <strong class="me ir">KUBE-SERVICES</strong> <strong class="me ir">-d 10.32.0.10/32</strong> <strong class="me ir">-p tcp</strong> -m comment --comment "kube-system/kube-dns:dns-tcp cluster IP" -m tcp <strong class="me ir">--dport 53</strong> -j <strong class="me ir">KUBE-SVC-ERIFXISQEP7F7OF4</strong><br/>-A <strong class="me ir">KUBE-SVC-ERIFXISQEP7F7OF4</strong> -m comment --comment "kube-system/kube-dns:dns-tcp" -j <strong class="me ir">KUBE-SEP-32LPCMGYG6ODGN3H</strong><br/>-A <strong class="me ir">KUBE-SEP-32LPCMGYG6ODGN3H</strong> -p tcp -m comment --comment "kube-system/kube-dns:dns-tcp" -m tcp <strong class="me ir">-j DNAT</strong> <strong class="me ir">--to-destination 10.200.0.27:53</strong></span></pre><p id="7019" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以下目标匹配目的地为<code class="fe mb mc md me b">10.32.0.10</code>端口<code class="fe mb mc md me b">53</code>的<code class="fe mb mc md me b">UDP</code>数据包，并将目的地地址转换为<code class="fe mb mc md me b">10.200.0.27</code>端口<code class="fe mb mc md me b">53</code>。</p><pre class="kn ko kp kq gt mi me mj mk aw ml bi"><span id="45d0" class="mm kz iq me b gy mn mo l mp mq">-A <strong class="me ir">KUBE-SERVICES</strong> <strong class="me ir">-d 10.32.0.10/32</strong> <strong class="me ir">-p udp</strong> -m comment --comment "kube-system/kube-dns:dns cluster IP" -m udp <strong class="me ir">--dport 53</strong> -j <strong class="me ir">KUBE-SVC-TCOU7JCQXEZGVUNU</strong><br/>-A <strong class="me ir">KUBE-SVC-TCOU7JCQXEZGVUNU</strong> -m comment --comment "kube-system/kube-dns:dns" -j <strong class="me ir">KUBE-SEP-LRUTK6XRXU43VLIG</strong><br/>-A <strong class="me ir">KUBE-SEP-LRUTK6XRXU43VLIG</strong> -p udp -m comment --comment "kube-system/kube-dns:dns" -m udp <strong class="me ir">-j DNAT --to-destination 10.200.0.27:53</strong></span></pre><p id="f1f5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Kubernetes还有其他类型的服务；<code class="fe mb mc md me b">NodePort</code>特别是在<a class="ae kl" href="https://github.com/kelseyhightower/kubernetes-the-hard-way" rel="noopener ugc nofollow" target="_blank">中也有涉及</a>的敬酒不吃吃罚酒。参见<a class="ae kl" href="https://github.com/kelseyhightower/kubernetes-the-hard-way/blob/master/docs/13-smoke-test.md#services" rel="noopener ugc nofollow" target="_blank">烟雾测试:服务</a>。</p><pre class="kn ko kp kq gt mi me mj mk aw ml bi"><span id="e7e8" class="mm kz iq me b gy mn mo l mp mq">kubectl expose deployment nginx --port 80 --type NodePort</span></pre><p id="ec19" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mb mc md me b">NodePort</code>在一个静态端口公开每个节点IP上的服务(即<code class="fe mb mc md me b">NodePort</code>)。您可以从集群外部访问<code class="fe mb mc md me b">NodePort</code>服务。您可以检查用<code class="fe mb mc md me b">kubectl</code>(本例中为<code class="fe mb mc md me b">31088</code>)分配的端口。</p><pre class="kn ko kp kq gt mi me mj mk aw ml bi"><span id="6cec" class="mm kz iq me b gy mn mo l mp mq">$ <strong class="me ir">kubectl describe services nginx</strong><br/>...<br/>Type:                     NodePort<br/><strong class="me ir">IP:                       10.32.0.53</strong><br/>Port:                     &lt;unset&gt;  80/TCP<br/>TargetPort:               80/TCP<br/><strong class="me ir">NodePort</strong>:                 &lt;unset&gt;  <strong class="me ir">31088</strong>/TCP<br/><strong class="me ir">Endpoints:                10.200.1.18:80</strong><br/>...</span></pre><p id="63b0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在可以在<code class="fe mb mc md me b"><a class="ae kl" href="http://${EXTERNAL_IP}:31088/." rel="noopener ugc nofollow" target="_blank">http://${EXTERNAL_IP}:31088/</a></code>从互联网访问pod。其中<code class="fe mb mc md me b">EXTERNAL_IP</code>是<strong class="jp ir">您的任何工作实例</strong>的公共IP地址。在这个例子中，我使用了<strong class="jp ir"> worker-0 </strong>的公共IP地址。在具有私有IP的节点<code class="fe mb mc md me b">10.240.0.20</code>中接收请求(云提供商处理面向公共的NAT)，但是服务实际上在另一个节点中运行(<strong class="jp ir"> worker-1 </strong>，您可以通过端点的IP地址<code class="fe mb mc md me b">10.200.<strong class="jp ir">1</strong>.18</code>来判断)</p><pre class="kn ko kp kq gt mi me mj mk aw ml bi"><span id="f898" class="mm kz iq me b gy mn mo l mp mq">ubuntu@<strong class="me ir">worker-0</strong>:~$ <strong class="me ir">sudo conntrack -L | grep 31088</strong><br/>tcp      6 86397 ESTABLISHED src=173.38.XXX.XXX dst=10.240.0.20 sport=30303 dport=31088 src=10.200.1.18 dst=10.240.0.20 sport=80 dport=30303 [ASSURED] mark=0 use=1</span></pre><p id="ed99" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此数据包从<strong class="jp ir"> worker-0 </strong>转发到<strong class="jp ir"> worker-1 </strong>到达目的地。</p><pre class="kn ko kp kq gt mi me mj mk aw ml bi"><span id="61ff" class="mm kz iq me b gy mn mo l mp mq">ubuntu@<strong class="me ir">worker-1</strong>:~$ <strong class="me ir">sudo conntrack -L | grep 80</strong><br/>tcp      6 86392 ESTABLISHED src=10.240.0.20 dst=10.200.1.18 sport=14802 dport=80 src=10.200.1.18 dst=10.240.0.20 sport=80 dport=14802 [ASSURED] mark=0 use=1</span></pre><p id="e980" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">理想吗？。可能不会，但很管用。在这种情况下编程的<code class="fe mb mc md me b">iptables</code>规则是:</p><pre class="kn ko kp kq gt mi me mj mk aw ml bi"><span id="b3f7" class="mm kz iq me b gy mn mo l mp mq">-A KUBE-NODEPORTS -p tcp -m comment --comment "default/nginx:" -m tcp <strong class="me ir">--dport 31088</strong> -j <strong class="me ir">KUBE-SVC-4N57TFCL4MD7ZTDA</strong><br/>-A <strong class="me ir">KUBE-SVC-4N57TFCL4MD7ZTDA</strong> -m comment --comment "default/nginx:" -j <strong class="me ir">KUBE-SEP-UGTFMET44DQG7H7H</strong><br/>-A <strong class="me ir">KUBE-SEP-UGTFMET44DQG7H7H</strong> -p tcp -m comment --comment "default/nginx:" -m tcp -j <strong class="me ir">DNAT --to-destination 10.200.1.18:80</strong></span></pre><p id="d762" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">换句话说，目的端口为<code class="fe mb mc md me b">31088</code>的数据包的目的地址被转换为<code class="fe mb mc md me b">10.200.1.18</code>。端口也从<code class="fe mb mc md me b">31088</code>翻译成<code class="fe mb mc md me b">80</code>。</p><p id="ec7d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们没有讨论使用云提供商的负载均衡器对外公开服务的服务类型<code class="fe mb mc md me b">LoadBalancer</code>，因为这篇文章已经够长了。</p><h1 id="4c5b" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">结论</h1><p id="3684" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">虽然这看起来很多，但我们只是触及了表面。我计划接下来介绍IPv6、IPVS、eBPF和一些有趣的CNI插件。</p><p id="d293" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我希望这已经提供了信息。请让我知道，如果你认为我得到了一些错误或任何打字错误。</p><p id="d585" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">延伸阅读:</p><ul class=""><li id="1a55" class="mt mu iq jp b jq jr ju jv jy mv kc mw kg mx kk my mz na nb bi translated"><a class="ae kl" rel="noopener ugc nofollow" target="_blank" href="/kubernetes-multi-cluster-networking-made-simple-c8f26827813?source=friends_link&amp;sk=5cc1662ff502213d67aa49ab35ccf0c9"> Kubernetes简化了多集群网络</a></li><li id="d144" class="mt mu iq jp b jq nc ju nd jy ne kc nf kg ng kk my mz na nb bi translated"><a class="ae kl" href="https://medium.com/@nleiva/how-to-run-ipv6-enabled-docker-containers-on-aws-87e090ab0397?source=friends_link&amp;sk=126bd9850d2fc46a2ff99bee89c735ca" rel="noopener">如何在AWS上运行支持IPv6的Docker容器</a></li><li id="91cd" class="mt mu iq jp b jq nc ju nd jy ne kc nf kg ng kk my mz na nb bi translated"><a class="ae kl" href="https://nleiva.medium.com/three-reasons-we-need-ipv6-in-kubernetes-69b6f3cbadb7" rel="noopener">我们需要IPv6的三个原因…在Kubernetes </a></li></ul></div></div>    
</body>
</html>