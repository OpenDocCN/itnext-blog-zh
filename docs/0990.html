<html>
<head>
<title>Visualize your real-time data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">可视化您的实时数据</h1>
<blockquote>原文：<a href="https://itnext.io/visualize-your-real-time-data-c8f17fe65dde?source=collection_archive---------2-----------------------#2018-06-29">https://itnext.io/visualize-your-real-time-data-c8f17fe65dde?source=collection_archive---------2-----------------------#2018-06-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><h1 id="f0b4" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">实时数据的特征</h1><p id="6e3c" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">一般来说，数据的可视化可以传递比数据背后更多的信息。通过一个简单的<code class="fe lm ln lo lp b">BarChart</code>，我们可以了解到哪种特定的产品在Q2卖得最好，或者可以很明显地看出员工在特定月份的工作时间是如何分配的。那些图表都或多或少与时间有关——当时间流逝时，一些数字在不断变化。</p><p id="e165" class="pw-post-body-paragraph ko kp it kq b kr lq kt ku kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll im bi translated">但是，在其他一些特定领域，需要一些更具时效性的图表。例如，在任何给定的时间，了解当前有多少用户登录到系统中，主站点的流量如何，或者最重要的是，有多少事务正在进行，这是非常重要的。此外，几乎所有的维护工作都需要实时分析，比如服务器集群负载在过去5分钟内的情况，或者当前的内存使用情况。</p><p id="2a2a" class="pw-post-body-paragraph ko kp it kq b kr lq kt ku kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll im bi translated">这些图表具有以下特征:</p><ul class=""><li id="67dc" class="lv lw it kq b kr lq kv lr kz lx ld ly lh lz ll ma mb mc md bi translated">高度时间敏感</li><li id="57d6" class="lv lw it kq b kr me kv mf kz mg ld mh lh mi ll ma mb mc md bi translated">粒度越小，可能需要的数据存储量就越多</li><li id="1436" class="lv lw it kq b kr me kv mf kz mg ld mh lh mi ll ma mb mc md bi translated">一段时间后，数据的价值急剧下降</li></ul><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi mj"><img src="../Images/c706fb5904a179c06c794a450a4c639a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N2BIIREKrIDV3Oqm7a5YcA.png"/></div></div></figure><p id="fe35" class="pw-post-body-paragraph ko kp it kq b kr lq kt ku kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll im bi translated">上图显示了我的Mac Book上的实时CPU负载，它说明了花费在系统、用户空间和空闲上的时间。数据是连续产生的，然后在数值显示在图表上后立即删除。实际上没有人关心一小时前的CPU使用率如何，最近几分钟生成的数据就足够了。</p><p id="c204" class="pw-post-body-paragraph ko kp it kq b kr lq kt ku kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll im bi translated">基于这些因素，如何存储和访问数据、如何分析测量结果、如何旋转海量数据等问题都不同于其他类型的图表。此外，由于实时数据可视化与时间高度耦合，因此本质上它必须是动态的，并且应该实时生动地变化。</p><p id="d1dd" class="pw-post-body-paragraph ko kp it kq b kr lq kt ku kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll im bi translated">在这篇文章中，我想谈谈这些问题，以及一些相应的解决办法。</p><h1 id="e3a8" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">实时可视化中的主题</h1><p id="040b" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">对于实时生成的数据，我们关心的是某些特定事件发生的频率、持续时间等。首先，让我们定义一些要观察的对象:</p><ul class=""><li id="5a7e" class="lv lw it kq b kr lq kv lr kz lx ld ly lh lz ll ma mb mc md bi translated">计数器</li><li id="0aca" class="lv lw it kq b kr me kv mf kz mg ld mh lh mi ll ma mb mc md bi translated">计时器</li><li id="4b58" class="lv lw it kq b kr me kv mf kz mg ld mh lh mi ll ma mb mc md bi translated">测量</li></ul><h2 id="4a31" class="mv jr it bd js mw mx dn jw my mz dp ka kz na nb ke ld nc nd ki lh ne nf km ng bi translated">计数器</h2><p id="161c" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">当然，计数器是数字，它们记录一些特定事情发生的时间(通常我们需要在事件发生时增加或减少总数)，变化的速度通常保持稳定，或者至少是可预测的。例如:</p><ul class=""><li id="fccf" class="lv lw it kq b kr lq kv lr kz lx ld ly lh lz ll ma mb mc md bi translated">代码为200的响应</li><li id="4197" class="lv lw it kq b kr me kv mf kz mg ld mh lh mi ll ma mb mc md bi translated">来自特定会话的请求</li></ul><p id="f9f7" class="pw-post-body-paragraph ko kp it kq b kr lq kt ku kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll im bi translated">一旦这种事件发生，我们可以通过增加相关的计数器来记录。</p><h2 id="2b53" class="mv jr it bd js mw mx dn jw my mz dp ka kz na nb ke ld nc nd ki lh ne nf km ng bi translated">计时器</h2><p id="0b9d" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">计时器负责记录某个事件需要多长时间，通常我们可以引入一个<code class="fe lm ln lo lp b">interval</code>来计算一些统计信息:平均值、标准差、最小值、最大值等。计时器是这样的东西:</p><ul class=""><li id="7804" class="lv lw it kq b kr lq kv lr kz lx ld ly lh lz ll ma mb mc md bi translated">特定资源的响应时间</li><li id="1065" class="lv lw it kq b kr me kv mf kz mg ld mh lh mi ll ma mb mc md bi translated">每个用户在特定页面的停留时间</li></ul><h2 id="404c" class="mv jr it bd js mw mx dn jw my mz dp ka kz na nb ke ld nc nd ki lh ne nf km ng bi translated">测量</h2><p id="d646" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">有时，当我们只是想记录一些(随机)数字时，这很有用，标尺就是为此而生的。与计数器相比，它没有稳定的变化速度，因此它们根本不可预测。我们通常不关心它如何变化，相反，我们只关心某一时刻的数字/状态。</p><ul class=""><li id="f7e7" class="lv lw it kq b kr lq kv lr kz lx ld ly lh lz ll ma mb mc md bi translated">该节点是否处于活动状态</li><li id="4e69" class="lv lw it kq b kr me kv mf kz mg ld mh lh mi ll ma mb mc md bi translated">有多少个过程</li><li id="7486" class="lv lw it kq b kr me kv mf kz mg ld mh lh mi ll ma mb mc md bi translated">给定时间的内存使用情况</li></ul><h1 id="f277" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">实时数据可视化的典型工作流程</h1><p id="11cb" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在许多生产环境中，实时数据是通过日志文件收集的，而在其他系统中，它可能来自事件存储(通常是数据库)。日志文件是最常用的手段，几乎每个系统都会一直生成不同类型的日志，其中大多数都有轮换机制:日志被记录在固定大小的文本文件中，较旧的记录被自动刷新到另一个文件中(有时，会有一些相关的cron-jobs负责清理较旧的文件)。另一方面，在一些基于事件的系统中，事件会被记录在专门设计的数据库中，这些数据可以作为实时数据可视化的来源。</p><p id="ac2f" class="pw-post-body-paragraph ko kp it kq b kr lq kt ku kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll im bi translated">然而，原始日志文件很少适合可视化。通常，需要进行一些清理和处理，例如:</p><ul class=""><li id="f2f9" class="lv lw it kq b kr lq kv lr kz lx ld ly lh lz ll ma mb mc md bi translated">获取原始数据</li><li id="3c45" class="lv lw it kq b kr me kv mf kz mg ld mh lh mi ll ma mb mc md bi translated">标记化并使其结构化</li><li id="7186" class="lv lw it kq b kr me kv mf kz mg ld mh lh mi ll ma mb mc md bi translated">简单聚集</li><li id="f1ec" class="lv lw it kq b kr me kv mf kz mg ld mh lh mi ll ma mb mc md bi translated">更深层的聚合</li></ul><h2 id="9bf6" class="mv jr it bd js mw mx dn jw my mz dp ka kz na nb ke ld nc nd ki lh ne nf km ng bi translated">标记化并使其结构化</h2><p id="fcce" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">有各种各样的工具可以帮助我们做这项工作。通过一些基本的配置，我们可以通过使用<a class="ae nh" href="https://www.elastic.co/products/logstash" rel="noopener ugc nofollow" target="_blank"> logstash </a>从生产日志文件向<a class="ae nh" href="https://github.com/etsy/statsd" rel="noopener ugc nofollow" target="_blank"> statsd </a>馈送数据(并且数据最终被馈送到<a class="ae nh" href="https://graphiteapp.org/" rel="noopener ugc nofollow" target="_blank"> graphite </a>)来使其工作。</p><pre class="mk ml mm mn gt ni lp nj nk aw nl bi"><span id="8a93" class="mv jr it lp b gy nm nn l no np">input {<br/>  stdin {}<br/>}</span><span id="b360" class="mv jr it lp b gy nq nn l no np">filter {<br/>  grok {<br/>    match =&gt; {<br/>      "message" =&gt; "%{DATA:time} %{DATA:status} %{NUMBER:request_time} %{DATA:campaign} %{DATA:mac} %{DATA:ap_mac} %{GREEDYDATA:session}"<br/>    }<br/>  }<br/>}</span><span id="ea09" class="mv jr it lp b gy nq nn l no np">output {<br/>  stdout { codec =&gt; rubydebug }</span><span id="8eb9" class="mv jr it lp b gy nq nn l no np">  statsd {<br/>    host =&gt; 'localhost'<br/>    increment =&gt; "airport.%{session}"<br/>  }</span><span id="79c8" class="mv jr it lp b gy nq nn l no np">  statsd {<br/>    host =&gt; 'localhost'<br/>    increment =&gt; "airport.%{status}"<br/>  }<br/>}</span></pre><p id="532e" class="pw-post-body-paragraph ko kp it kq b kr lq kt ku kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll im bi translated"><code class="fe lm ln lo lp b">logstash</code>实际上是一个非常灵活的、可定制的工具，它允许我们定义数据源、匹配规则和输出:给定一个<code class="fe lm ln lo lp b">data source</code>，一旦其中的记录匹配了一个特定的<code class="fe lm ln lo lp b">rule</code>，然后将其格式化并输出到<code class="fe lm ln lo lp b">output</code>。听起来像是IFTTT  (If This Then That)做的事情，对吗？</p><pre class="mk ml mm mn gt ni lp nj nk aw nl bi"><span id="5a3d" class="mv jr it lp b gy nm nn l no np">tail -f /var/logs/nginx/access.log | logstash -f log.conf</span></pre><p id="9cd1" class="pw-post-body-paragraph ko kp it kq b kr lq kt ku kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll im bi translated">在上面的例子中，我们使用stdin作为输入，当它包含<code class="fe lm ln lo lp b">time status request_time campaign mac ap_mac session</code>时，它就是一个匹配。对于那些匹配的线，我们将它们放入本地运行的<code class="fe lm ln lo lp b">statsd</code>实例中。指令<code class="fe lm ln lo lp b">increment</code>可以为每个匹配增加相应的计数器。</p><p id="1642" class="pw-post-body-paragraph ko kp it kq b kr lq kt ku kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll im bi translated">比方说，我们在日志文件中得到一行:</p><pre class="mk ml mm mn gt ni lp nj nk aw nl bi"><span id="21e0" class="mv jr it lp b gy nm nn l no np">1529242838 403 0.02 f3715a7f52d8cef53fef1f73134e487a 00:61:71:53:ff:b0 T2-CL*-49-D* 2293c8e9-8801-485b-9f1d-9e5a7f5a8965</span></pre><p id="9bb6" class="pw-post-body-paragraph ko kp it kq b kr lq kt ku kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll im bi translated">那么匹配结果应该是:</p><pre class="mk ml mm mn gt ni lp nj nk aw nl bi"><span id="6b58" class="mv jr it lp b gy nm nn l no np">{<br/>        "campaign" =&gt; "f3715a7f52d8cef53fef1f73134e487a",<br/>    "request_time" =&gt; "0.02",<br/>          "status" =&gt; "403",<br/>         "session" =&gt; "2293c8e9-8801-485b-9f1d-9e5a7f5a8965",<br/>         "message" =&gt; "1529242838 403 0.02 f3715a7f52d8cef53fef1f73134e487a 00:61:71:53:f4:0b T2-CL13-49-D87 2293c8e9-8801-485b-9f1d-9e5a7f5a8965",<br/>        "@version" =&gt; "1",<br/>            "host" =&gt; "juntao-qiu.local",<br/>          "ap_mac" =&gt; "T2-CL*-49-D*",<br/>            "time" =&gt; "1529242838",<br/>             "mac" =&gt; "00:61:71:53:ff:b0",<br/>      "@timestamp" =&gt; 2018-06-17T13:40:39.023Z<br/>}</span></pre><p id="baeb" class="pw-post-body-paragraph ko kp it kq b kr lq kt ku kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll im bi translated">然后，<code class="fe lm ln lo lp b">logstash</code>将递增计数器<code class="fe lm ln lo lp b">airport.2293c8e9-8801-485b-9f1d-9e5a7f5a8965</code>:</p><pre class="mk ml mm mn gt ni lp nj nk aw nl bi"><span id="5092" class="mv jr it lp b gy nm nn l no np">counter["airport.2293c8e9-8801-485b-9f1d-9e5a7f5a8965"] += 1</span></pre><h2 id="f365" class="mv jr it bd js mw mx dn jw my mz dp ka kz na nb ke ld nc nd ki lh ne nf km ng bi translated">统计的</h2><p id="7f0c" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">对于结构化数据，我们可以定期进行一些基本的统计。对于计时器，我们可以计算平均值，std，medium。<code class="fe lm ln lo lp b">statsd</code>可以帮我们完成所有这些任务。</p><p id="f101" class="pw-post-body-paragraph ko kp it kq b kr lq kt ku kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll im bi translated">基本上，<code class="fe lm ln lo lp b">StatsD</code>是一个非常简单的<code class="fe lm ln lo lp b">UDP</code>服务。使用<code class="fe lm ln lo lp b">UDP</code>可以避免<code class="fe lm ln lo lp b">TCP</code>花费大量时间来建立可靠的连接。<code class="fe lm ln lo lp b">StatsD</code>维护一些本地计数器和状态，默认情况下每10秒与<code class="fe lm ln lo lp b">graphite</code>同步一次。</p><h1 id="a2f3" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">显现</h1><p id="bc89" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">为了可视化实时数据，您必须考虑很多问题，就像您通常在其他可视化项目中所做的那样。桌面、网络甚至移动设备上？如果你必须在Web上呈现，页面是否应该适应不同的屏幕尺寸？可视化是一个动态的交互式图表还是仅仅是一个静态的表示？</p><p id="62b8" class="pw-post-body-paragraph ko kp it kq b kr lq kt ku kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll im bi translated">再者，精度要求是什么？我们应该每分钟还是每15分钟计算一次统计数据？对于不同的精度，在存储方面的要求完全不同。一种常用的策略是降低过期数据的准确性，并以更高的分辨率呈现最新的数据。</p><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi mj"><img src="../Images/838a96d8c64f46673cc1d7268a81ce0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qpgRKmCg3GuwhSR2nyc7iw.png"/></div></div></figure><p id="ecff" class="pw-post-body-paragraph ko kp it kq b kr lq kt ku kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll im bi translated">上面展示了一个典型的基于Web的实时仪表盘，使用的是<code class="fe lm ln lo lp b">grafana</code>。</p><h1 id="40c5" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">工具</h1><p id="ce06" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我们需要各种各样的工具来实现实时数据可视化。简而言之，我们需要工具来存储实际数据，需要API来访问这些数据，最后是表示库或框架。</p><h1 id="815b" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">时间序列数据库</h1><p id="6948" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在这个特别狭窄的领域，实际上有一种特定的数据库，时间序列数据库管理系统。它本质上是一个<code class="fe lm ln lo lp b">Key-Value</code>数据库，通常维护时间戳、键和值。此外，一些实现提供了一个<code class="fe lm ln lo lp b">Query Language</code>来方便灵活地查询存储的值。</p><p id="2cd2" class="pw-post-body-paragraph ko kp it kq b kr lq kt ku kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll im bi translated">以下是一些著名的临时数据库列表:</p><ul class=""><li id="aa97" class="lv lw it kq b kr lq kv lr kz lx ld ly lh lz ll ma mb mc md bi translated"><a class="ae nh" href="https://graphiteapp.org/" rel="noopener ugc nofollow" target="_blank">石墨</a></li><li id="0d5c" class="lv lw it kq b kr me kv mf kz mg ld mh lh mi ll ma mb mc md bi translated"><a class="ae nh" href="https://www.influxdata.com/" rel="noopener ugc nofollow" target="_blank"> Influxdb </a></li><li id="a72d" class="lv lw it kq b kr me kv mf kz mg ld mh lh mi ll ma mb mc md bi translated"><a class="ae nh" href="https://prometheus.io/" rel="noopener ugc nofollow" target="_blank"> Promethous </a></li></ul><h1 id="8ffa" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">Feeder / API</h1><p id="0dd7" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">尽管大多数TSDB都提供了本地API来存储和访问数据，但是大多数人更喜欢使用简单的HTTP APIs。<code class="fe lm ln lo lp b">StatsD</code>是一个非常简单的<code class="fe lm ln lo lp b">Node.js</code>服务，通过使用API(已经绑定了很多编程语言)，你可以很容易地创建<code class="fe lm ln lo lp b">counter</code>和<code class="fe lm ln lo lp b">timer</code>。</p><ul class=""><li id="e499" class="lv lw it kq b kr lq kv lr kz lx ld ly lh lz ll ma mb mc md bi translated"><a class="ae nh" href="https://github.com/etsy/statsd" rel="noopener ugc nofollow" target="_blank"> StatsD </a></li><li id="13c4" class="lv lw it kq b kr me kv mf kz mg ld mh lh mi ll ma mb mc md bi translated"><a class="ae nh" href="https://graphiteapp.org/" rel="noopener ugc nofollow" target="_blank">石墨</a></li></ul><h1 id="b257" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">可视化库</h1><p id="7548" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><code class="fe lm ln lo lp b">Grafana</code>是一个强大且广泛使用的客户端框架。您可以轻松地集成来自各种后端数据源。这可以呈现来自<code class="fe lm ln lo lp b">graphite</code>的数据和在线用户状态可能来自<code class="fe lm ln lo lp b">influxdb</code>或<code class="fe lm ln lo lp b">promethous</code>的CPU/内存负载。</p><p id="3bd9" class="pw-post-body-paragraph ko kp it kq b kr lq kt ku kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll im bi translated">如果你想在某些特定情况下有更多的控制权。你可能想使用<code class="fe lm ln lo lp b">d3.js</code> + <code class="fe lm ln lo lp b">cubism</code>组合。您可以编写一些JavaScript来定期从后端服务获取数据。最后，在<code class="fe lm ln lo lp b">svg</code>画布上渲染它们。</p><ul class=""><li id="f47e" class="lv lw it kq b kr lq kv lr kz lx ld ly lh lz ll ma mb mc md bi translated"><a class="ae nh" href="https://grafana.com/" rel="noopener ugc nofollow" target="_blank">格拉夫纳</a></li><li id="0ced" class="lv lw it kq b kr me kv mf kz mg ld mh lh mi ll ma mb mc md bi translated"><a class="ae nh" href="http://square.github.io/cubism/" rel="noopener ugc nofollow" target="_blank">立体派</a></li></ul><h1 id="0ff4" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">渲染时间</h1><h1 id="1bec" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">凉廊</h1><p id="5d97" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><code class="fe lm ln lo lp b">Logstalgia</code>是一个非常有趣的工具，可以读取某种格式的日志，然后以非常花哨的方式渲染它们，就像玩经典游戏<code class="fe lm ln lo lp b">Brick Breaker</code>一样。</p><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi mj"><img src="../Images/0e78af9894102b4924d257c7e1a9ffe9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*849HayXou-Cl-NT_PNvDUQ.png"/></div></div></figure><p id="4a14" class="pw-post-body-paragraph ko kp it kq b kr lq kt ku kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll im bi translated">下列字段是必需的:</p><ul class=""><li id="7db9" class="lv lw it kq b kr lq kv lr kz lx ld ly lh lz ll ma mb mc md bi translated">UNIX时间戳</li><li id="036e" class="lv lw it kq b kr me kv mf kz mg ld mh lh mi ll ma mb mc md bi translated">请求主机名</li><li id="95eb" class="lv lw it kq b kr me kv mf kz mg ld mh lh mi ll ma mb mc md bi translated">请求路径</li><li id="24b0" class="lv lw it kq b kr me kv mf kz mg ld mh lh mi ll ma mb mc md bi translated">响应代码</li><li id="4b60" class="lv lw it kq b kr me kv mf kz mg ld mh lh mi ll ma mb mc md bi translated">响应大小</li></ul><p id="5d27" class="pw-post-body-paragraph ko kp it kq b kr lq kt ku kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll im bi translated">所有字段都应该这样放置:</p><pre class="mk ml mm mn gt ni lp nj nk aw nl bi"><span id="e45b" class="mv jr it lp b gy nm nn l no np">1529206121|12.21.18.246|/dispatcher/campaigns/2de808e08dccec2c7e55e41ecbd5a421|200|20</span></pre><p id="2e68" class="pw-post-body-paragraph ko kp it kq b kr lq kt ku kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll im bi translated">通常，你的日志可能比这个复杂得多，你可以写一个小的适配器来转换。这里有一个例子:</p><pre class="mk ml mm mn gt ni lp nj nk aw nl bi"><span id="7e56" class="mv jr it lp b gy nm nn l no np">const source = '[$time_local] "$remote_addr - $remote_user" "$request" $status $body_bytes_sent "$http_referer" $request_time "$http_user_agent"'; </span><span id="3ca7" class="mv jr it lp b gy nq nn l no np">const NginxParser = require('nginxparser');<br/>const parser = new NginxParser(source);</span><span id="f2f5" class="mv jr it lp b gy nq nn l no np">const moment = require('moment');</span><span id="0b27" class="mv jr it lp b gy nq nn l no np">parser.read('-', (row) =&gt; {<br/>    const ts = moment(row.time_local, "DD/MMM/YYYY:HH:mm:ss Z").unix();<br/>    const parsed = row.request.split(/\s+/)<br/>    console.log(`${ts}|${row.ip_str}|${parsed[1]}|${row.status}|${row.body_bytes_sent}`);<br/>}, (err) =&gt; {<br/>    throw err;<br/>});</span></pre><p id="637e" class="pw-post-body-paragraph ko kp it kq b kr lq kt ku kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll im bi translated">注意，这个脚本的输入和输出是stdin和stdout，所以您可以很容易地将它放到命令行中，并使它与其他与pipeline <code class="fe lm ln lo lp b">|</code>连接的工具一起工作。</p><pre class="mk ml mm mn gt ni lp nj nk aw nl bi"><span id="a093" class="mv jr it lp b gy nm nn l no np">tail -f /var/log/nginx/access.log | node adaptor.js | logstalgia</span></pre><p id="63ba" class="pw-post-body-paragraph ko kp it kq b kr lq kt ku kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll im bi translated">不过<code class="fe lm ln lo lp b">logstalgia</code>有一点限制就是只能在桌面上运行，没有办法自定义观感。有时，我们只需要转移到Web上，使可视化更加可定制。</p><h1 id="0434" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">在网页上呈现时间</h1><p id="ffea" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">为了实现实时渲染，可以直接读取日志文件，通过WebSocket将事件发送到客户端。这种方法的优点是及时性，一个<code class="fe lm ln lo lp b">500</code>错误或失败的交易可以直接在用户界面上显示。另一方面，缺点也很明显:如果日志文件增加的速度太快，那么前端可能会不堪重负。此外，平面事件消息太粗糙，难以分析。</p><h2 id="83e1" class="mv jr it bd js mw mx dn jw my mz dp ka kz na nb ke ld nc nd ki lh ne nf km ng bi translated">WebScoket + D3.js</h2><pre class="mk ml mm mn gt ni lp nj nk aw nl bi"><span id="946a" class="mv jr it lp b gy nm nn l no np">const _ = require('lodash');<br/>const { spawn } = require('child_process');<br/>const generator = spawn('./generator.sh');</span><span id="350d" class="mv jr it lp b gy nq nn l no np">const WebSocket = require('ws');</span><span id="60b6" class="mv jr it lp b gy nq nn l no np">const wss = new WebSocket.Server({ port: 8080 });</span><span id="1c97" class="mv jr it lp b gy nq nn l no np">function parse(data) {<br/>    //...<br/>}</span><span id="bdef" class="mv jr it lp b gy nq nn l no np">wss.on('connection', (ws) =&gt; {</span><span id="6019" class="mv jr it lp b gy nq nn l no np">  const output = (data) =&gt; {<br/>    ws.send(JSON.stringify(parse(data)));<br/>  }</span><span id="4917" class="mv jr it lp b gy nq nn l no np">  generator.stdout.on('data', output);</span><span id="be61" class="mv jr it lp b gy nq nn l no np">  ws.on('close', () =&gt; {<br/>    generator.stdout.removeListener('data', output);<br/>  });<br/>});</span></pre><p id="31e1" class="pw-post-body-paragraph ko kp it kq b kr lq kt ku kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll im bi translated">在上面的脚本中，我们<code class="fe lm ln lo lp b">spawn</code>了一个运行shell脚本的进程，它将从远程服务器获取日志，并在控制台上打印出来。当客户端通过WebSocket连接时，我们可以将来自<code class="fe lm ln lo lp b">generator</code>的数据附加到套接字上。在以JSON格式发送到客户端之前，我们必须确保数据是精心组织的。</p><p id="5dc6" class="pw-post-body-paragraph ko kp it kq b kr lq kt ku kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll im bi translated">最后，一旦客户端关闭了连接，我们需要确保事件侦听器被删除。</p><p id="f439" class="pw-post-body-paragraph ko kp it kq b kr lq kt ku kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll im bi translated"><code class="fe lm ln lo lp b">generator.sh</code>的实现可以是任何可以连续输出一些日志消息的东西，一个简单的实现可以是这样的:</p><pre class="mk ml mm mn gt ni lp nj nk aw nl bi"><span id="6810" class="mv jr it lp b gy nm nn l no np">tail -f /var/logs/nginx/access.log</span></pre><p id="788f" class="pw-post-body-paragraph ko kp it kq b kr lq kt ku kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll im bi translated">如果您在本地根本没有访问日志，您可以指向测试环境:</p><pre class="mk ml mm mn gt ni lp nj nk aw nl bi"><span id="3eff" class="mv jr it lp b gy nm nn l no np">ssh qa-env tail -f /var/logs/wifi-portal/wifi-portal-2018-06-13-access.log</span></pre><p id="0be8" class="pw-post-body-paragraph ko kp it kq b kr lq kt ku kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll im bi translated">对于客户端，您唯一需要做的就是建立一个WebSocket连接，并监听数据的到来。这里有一个用D3.js写的脚本，它使用了一个来自<a class="ae nh" href="https://bl.ocks.org/boeric/6a83de20f780b42fadb9" rel="noopener ugc nofollow" target="_blank">实时插件</a>的插件。</p><pre class="mk ml mm mn gt ni lp nj nk aw nl bi"><span id="5270" class="mv jr it lp b gy nm nn l no np">var ws = new WebSocket("ws://localhost:8080");</span><span id="83f6" class="mv jr it lp b gy nq nn l no np">ws.onopen = function() {<br/>  console.log('connected');<br/>};</span><span id="7a46" class="mv jr it lp b gy nq nn l no np">ws.onmessage = function (evt) { <br/>  const event = JSON.parse(evt.data);<br/>  categroies.push(_.truncate(event.campaign, { 'length': 8 }));<br/>  const campaigns = _.uniq(categroies);</span><span id="2f3d" class="mv jr it lp b gy nq nn l no np">  chart.yDomain(campaigns);<br/>  chart.yDomain().forEach(function(cat, i) {<br/>    var now = new Date(event.date);</span><span id="c2cf" class="mv jr it lp b gy nq nn l no np">    var mills = event.mills * 200;</span><span id="1330" class="mv jr it lp b gy nq nn l no np">    const obj = {<br/>      time: now,<br/>      color: color(mills),<br/>      opacity: 1,<br/>      category: _.truncate(event.campaign, { 'length': 8}),<br/>      type: "circle",<br/>      size: mills,<br/>    }</span><span id="11c2" class="mv jr it lp b gy nq nn l no np">    chart.datum(obj);<br/>  });</span><span id="6330" class="mv jr it lp b gy nq nn l no np">};</span></pre><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi mj"><img src="../Images/1628775590a670d400c90ce053797f30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vcgE2Dcl0BzJWLCrzSx9tg.png"/></div></div></figure><p id="7d21" class="pw-post-body-paragraph ko kp it kq b kr lq kt ku kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll im bi translated">图表的图例是:</p><ul class=""><li id="dc56" class="lv lw it kq b kr lq kv lr kz lx ld ly lh lz ll ma mb mc md bi translated">x轴代表时间</li><li id="5c1a" class="lv lw it kq b kr me kv mf kz mg ld mh lh mi ll ma mb mc md bi translated">y轴代表已被访问的特定资源</li><li id="6a4c" class="lv lw it kq b kr me kv mf kz mg ld mh lh mi ll ma mb mc md bi translated">每个请求都将被绘制为一个点</li><li id="7d5f" class="lv lw it kq b kr me kv mf kz mg ld mh lh mi ll ma mb mc md bi translated">斑点的大小代表以毫秒为单位的响应时间</li></ul><h1 id="f973" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">将统计数据可视化</h1><h1 id="8212" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">使用石墨</h1><p id="4d07" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><code class="fe lm ln lo lp b">graphite</code>有一个内置的仪表盘系统，你可以选择在单个图表上演示多个仪表盘:</p><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/5e0657c2aefe66abf8ddce99a0c98088.png" data-original-src="https://miro.medium.com/v2/resize:fit:1172/format:webp/1*j8E28NgvrUZ3jn2H_FIJLw.png"/></div></figure><p id="f05f" class="pw-post-body-paragraph ko kp it kq b kr lq kt ku kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll im bi translated">除此之外，<code class="fe lm ln lo lp b">graphite</code>提供了一个更加强大的<code class="fe lm ln lo lp b">render</code> API。你可以得到各种格式，比如<code class="fe lm ln lo lp b">csv</code>、<code class="fe lm ln lo lp b">json</code>或者二进制图像格式。另外，您可以通过<code class="fe lm ln lo lp b">target</code>参数获得更复杂的计算结果。</p><p id="11fc" class="pw-post-body-paragraph ko kp it kq b kr lq kt ku kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll im bi translated">例如:</p><pre class="mk ml mm mn gt ni lp nj nk aw nl bi"><span id="c98e" class="mv jr it lp b gy nm nn l no np"><a class="ae nh" href="http://localhost/render/?format=json&amp;target=stats.jc.airport.campaigns.1565ae2c79aee5e635e55d73354c7cd3" rel="noopener ugc nofollow" target="_blank">http://localhost/render/?format=json&amp;target=stats.jc.airport.campaigns.1565ae2c79aee5e635e55d73354c7cd3</a></span><span id="3f2a" class="mv jr it lp b gy nq nn l no np"><a class="ae nh" href="http://localhost/render?format=raw&amp;target=alias(sumSeries(stats.jc.airport.campaigns.*)%2C%27%27)&amp;from=1529245830&amp;until=1529245929" rel="noopener ugc nofollow" target="_blank">http://localhost/render?format=raw&amp;target=alias(sumSeries(stats.jc.airport.campaigns.*)%2C%27%27)&amp;from=1529245830&amp;until=1529245929</a></span></pre><p id="04b4" class="pw-post-body-paragraph ko kp it kq b kr lq kt ku kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll im bi translated">这里<code class="fe lm ln lo lp b">target</code>的值是<code class="fe lm ln lo lp b">alias(sumSeries(stats.jc.airport.campaigns.*), '')</code>，表示从<code class="fe lm ln lo lp b">stats.jc.airport.campaigns</code>开始计算所有计数器的总和。您可以指定<code class="fe lm ln lo lp b">from</code>和<code class="fe lm ln lo lp b">until</code>来获取一段时间内的数据。</p><p id="a36a" class="pw-post-body-paragraph ko kp it kq b kr lq kt ku kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll im bi translated"><code class="fe lm ln lo lp b">graphite</code>提供了大量的聚集函数，如平均值、最小值/最大值等。这里完全是<a class="ae nh" href="http://graphite.readthedocs.io/en/latest/render_api.html#id3" rel="noopener ugc nofollow" target="_blank">参考</a>。</p><h1 id="2261" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">使用地平线图表</h1><p id="ede9" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><a class="ae nh" href="http://square.github.io/cubism/" rel="noopener ugc nofollow" target="_blank">立体派</a>是D3.js的一个非常著名的插件，专门用来表现实时图表。实际上，有许多研究和论文支持表示时间序列数据的图的形状非常重要。图表以一定的速度定期刷新，整个图形逐渐从右向左移动，最左侧的数据被涂上清漆，因为更多新的数据流从最右侧流入。</p><p id="79aa" class="pw-post-body-paragraph ko kp it kq b kr lq kt ku kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll im bi translated">您可以为地平线图指定不同的数据源，以<code class="fe lm ln lo lp b">graphite</code>为例:</p><pre class="mk ml mm mn gt ni lp nj nk aw nl bi"><span id="da21" class="mv jr it lp b gy nm nn l no np">var graphite = context.graphite("http://localhost");</span><span id="11bf" class="mv jr it lp b gy nq nn l no np">var api_metrics = [<br/>  graphite.metric("sumSeries(stats.jc.airport.campaigns.*)").alias("Campaigns Freq")<br/>];</span></pre><p id="2fa4" class="pw-post-body-paragraph ko kp it kq b kr lq kt ku kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll im bi translated"><code class="fe lm ln lo lp b">cubims</code>然后每隔10秒向<code class="fe lm ln lo lp b">graphite</code>发送这样的请求:</p><pre class="mk ml mm mn gt ni lp nj nk aw nl bi"><span id="ef43" class="mv jr it lp b gy nm nn l no np"><a class="ae nh" href="http://localhost/render?format=raw&amp;target=alias(sumSeries(stats.jc.airport.campaigns.*)%2C%27%27)&amp;from=1529245830&amp;until=1529245929" rel="noopener ugc nofollow" target="_blank">http://localhost/render?format=raw&amp;target=alias(sumSeries(stats.jc.airport.campaigns.*)%2C%27%27)&amp;from=1529245830&amp;until=1529245929</a></span></pre><p id="ecf7" class="pw-post-body-paragraph ko kp it kq b kr lq kt ku kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll im bi translated">它根据接收到的数据刷新绘图:</p><pre class="mk ml mm mn gt ni lp nj nk aw nl bi"><span id="fe13" class="mv jr it lp b gy nm nn l no np">d3.select("body").selectAll(".horizon")<br/>    .data(api_metrics)<br/>  .enter().insert("div", ".bottom")<br/>    .attr("class", "horizon").call(horizon.extent([0, 50]));</span></pre><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi mj"><img src="../Images/4cae04774d60e912da33d55cfe795bc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7kE1ZEu_QcF2Gp0SHfz7OQ.png"/></div></div></figure><p id="e38d" class="pw-post-body-paragraph ko kp it kq b kr lq kt ku kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll im bi translated">实际上，<code class="fe lm ln lo lp b">horizon chart</code>在垂直方向上只占用很少的空间，所以你可以像上面一样轻松地将几个图表组合在一起。</p><h1 id="ff5d" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">摘要</h1><p id="7b49" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我介绍了实时数据可视化领域的一些典型场景，以及我们如何准备数据并呈现它们的方法。通过一些现有的工具和简单的脚本，我们可以很容易地将连续生成的生产数据输入到一些时间序列数据库中，并为不同的目的将它们可视化。</p><p id="d62f" class="pw-post-body-paragraph ko kp it kq b kr lq kt ku kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll im bi translated">通常，基于固定时间间隔的统计数据可以提供更多的价值和洞察力，比如，任何给定时间间隔内的请求数量，或者平均响应时间。另一方面，在某些情况下，通过显示有多少人在线，发生了多少故障，或者超过90%负载的节点数量，这可能是有用的。</p><h1 id="0df9" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">参考</h1><ul class=""><li id="bb1e" class="lv lw it kq b kr ks kv kw kz ns ld nt lh nu ll ma mb mc md bi translated"><a class="ae nh" href="http://vis.berkeley.edu/papers/horizon/2009-TimeSeries-CHI.pdf" rel="noopener ugc nofollow" target="_blank">地平线图</a></li><li id="0ba6" class="lv lw it kq b kr me kv mf kz mg ld mh lh mi ll ma mb mc md bi translated"><a class="ae nh" href="http://vis.berkeley.edu/papers/" rel="noopener ugc nofollow" target="_blank">可视化试卷</a></li><li id="f03d" class="lv lw it kq b kr me kv mf kz mg ld mh lh mi ll ma mb mc md bi translated"><a class="ae nh" href="https://github.com/square/cubism/wiki" rel="noopener ugc nofollow" target="_blank">立体派</a></li></ul><h1 id="1a40" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">其他有用的链接</h1><ul class=""><li id="1e7e" class="lv lw it kq b kr ks kv kw kz ns ld nt lh nu ll ma mb mc md bi translated"><a class="ae nh" href="https://github.com/graphite-project/docker-graphite-statsd" rel="noopener ugc nofollow" target="_blank">在Docker </a>中设置石墨</li><li id="8f46" class="lv lw it kq b kr me kv mf kz mg ld mh lh mi ll ma mb mc md bi translated"><a class="ae nh" href="https://github.com/phobos182/cubism-graphite/blob/master/cubism/index.html" rel="noopener ugc nofollow" target="_blank">使用石墨立体主义的具体例子</a></li></ul></div></div>    
</body>
</html>