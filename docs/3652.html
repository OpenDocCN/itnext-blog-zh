<html>
<head>
<title>Lazy Pipelines with Generators in TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript中带有生成器的惰性管道</h1>
<blockquote>原文：<a href="https://itnext.io/fast-pipelines-with-generators-in-typescript-85d285ae6f51?source=collection_archive---------0-----------------------#2020-01-25">https://itnext.io/fast-pipelines-with-generators-in-typescript-85d285ae6f51?source=collection_archive---------0-----------------------#2020-01-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/a412fd60689eb49d0e7056ab4d93e2ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wEQnHaPoHc_QJo5vxwrCEg.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@quinten149?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">昆腾·德格拉夫</a>在<a class="ae kc" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="6ae7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">近年来，JavaScript社区已经接受了像<code class="fe lb lc ld le b">map</code>和<code class="fe lb lc ld le b">filter</code>这样的函数数组方法。编写for-loops已经成为与2015和JQuery联系在一起的东西。但是当我们谈论性能时，JavaScript中的数组方法远非理想。让我们看一个例子来阐明这些问题:</p><figure class="lf lg lh li gt jr"><div class="bz fp l di"><div class="lj lk l"/></div></figure><p id="999e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该代码将执行以下步骤:</p><ul class=""><li id="e129" class="ll lm iq kf b kg kh kk kl ko ln ks lo kw lp la lq lr ls lt bi translated">创建包含5个项目的数组</li><li id="30ef" class="ll lm iq kf b kg lu kk lv ko lw ks lx kw ly la lq lr ls lt bi translated">创建一个所有数字都加倍的新数组</li><li id="1ad8" class="ll lm iq kf b kg lu kk lv ko lw ks lx kw ly la lq lr ls lt bi translated">创建一个过滤了数字的新数组</li><li id="1190" class="ll lm iq kf b kg lu kk lv ko lw ks lx kw ly la lq lr ls lt bi translated">拿第一个项目</li></ul><p id="93d6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这涉及到比实际需要更多的事情发生。唯一要发生的事情是，第一个通过<code class="fe lb lc ld le b">x &gt; 5</code>的项目被处理并返回。在其他语言(如Python)中，迭代器被用来解决这个问题。那些迭代器是一个懒惰的集合，只在被请求时处理数据。如果JavaScript将惰性迭代器用于其数组方法，则会发生以下情况:</p><ul class=""><li id="6af1" class="ll lm iq kf b kg kh kk kl ko ln ks lo kw lp la lq lr ls lt bi translated"><code class="fe lb lc ld le b">[0]</code>向<code class="fe lb lc ld le b">filter</code>请求第一个项目</li><li id="a8a8" class="ll lm iq kf b kg lu kk lv ko lw ks lx kw ly la lq lr ls lt bi translated"><code class="fe lb lc ld le b">filter</code>请求来自<code class="fe lb lc ld le b">map</code>的项目，直到找到一个通过谓词的项目并产生(“返回”)它</li><li id="a600" class="ll lm iq kf b kg lu kk lv ko lw ks lx kw ly la lq lr ls lt bi translated"><code class="fe lb lc ld le b">map</code>每次处理<code class="fe lb lc ld le b">filter</code>请求的项目</li></ul><p id="ce23" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里我们只做了数组中的第一个树条目<code class="fe lb lc ld le b">map</code>和<code class="fe lb lc ld le b">filter</code>，因为迭代器不再请求更多的条目。这里也没有构造额外的数组或迭代器，因为每一项都一个接一个地通过整个管道。这是一个概念，当处理大量数据时,<em class="lz">可以</em>产生巨大的性能增益。</p><h1 id="8890" class="ma mb iq bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated">JavaScript中的生成器和迭代器</h1><p id="d26c" class="pw-post-body-paragraph kd ke iq kf b kg my ki kj kk mz km kn ko na kq kr ks nb ku kv kw nc ky kz la ij bi translated">幸运的是，JavaScript实际上支持迭代器的概念。它们可以用生成集合项目的<a class="ae kc" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators" rel="noopener ugc nofollow" target="_blank">生成器</a>函数来创建。生成器函数如下所示:</p><figure class="lf lg lh li gt jr"><div class="bz fp l di"><div class="lj lk l"/></div></figure><p id="88eb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里for循环将为每个循环请求一个迭代器项。generator函数使用<code class="fe lb lc ld le b">yield</code>关键字返回集合中的下一项。如你所见，我们可以多次生成包含多项的迭代器。永远不会在内存中构造任何数组。当我们去掉一些语法糖时，我们可以更好地理解这一点:</p><figure class="lf lg lh li gt jr"><div class="bz fp l di"><div class="lj lk l"/></div></figure><p id="57ea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里可以看到迭代器有一个用于请求下一项的<code class="fe lb lc ld le b">next</code>方法。这个方法的结果有一个值和一个布尔值，表明迭代器中还有更多结果。虽然这非常有趣，但如果我们想用迭代器构建合适的数据管道，我们还需要更多的东西:</p><ul class=""><li id="fb49" class="ll lm iq kf b kg kh kk kl ko ln ks lo kw lp la lq lr ls lt bi translated">从数组到迭代器的转换</li><li id="b4fa" class="ll lm iq kf b kg lu kk lv ko lw ks lx kw ly la lq lr ls lt bi translated">操作其他迭代器的迭代器，比如<code class="fe lb lc ld le b">map</code>和<code class="fe lb lc ld le b">filter</code>(也称为‘高阶迭代器’)</li><li id="89b6" class="ll lm iq kf b kg lu kk lv ko lw ks lx kw ly la lq lr ls lt bi translated">一个合适的接口，以优雅和实用的方式将所有这些链接在一起</li></ul><p id="639f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文的其余部分，我将展示如何做这些事情。最后，我加入了一个链接，指向我创建的包含更多特性的库。遗憾的是，这不是惰性迭代器的本机实现。这意味着有开销，在很多情况下这个库不值得。但是我仍然想向您展示这个概念，并讨论它的利弊。</p><h1 id="b00a" class="ma mb iq bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated">迭代器构造函数</h1><p id="8db6" class="pw-post-body-paragraph kd ke iq kf b kg my ki kj kk mz km kn ko na kq kr ks nb ku kv kw nc ky kz la ij bi translated">我们希望能够从多个数据源创建迭代器。最容易忘记的是数组。这个很简单，我们遍历数组，得到所有的条目:</p><figure class="lf lg lh li gt jr"><div class="bz fp l di"><div class="lj lk l"/></div></figure><p id="21b0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">转动数组中的迭代器需要我们调用<code class="fe lb lc ld le b">next</code>,直到我们得到所有的元素。在此之后，我们可以返回我们的数组。当然，你只希望在绝对需要的时候把迭代器变成数组，因为这个函数会导致一次完整的迭代。</p><figure class="lf lg lh li gt jr"><div class="bz fp l di"><div class="lj lk l"/></div></figure><p id="7de6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从迭代器读取数据的另一种方法是<code class="fe lb lc ld le b">first</code>。它的实现如下所示。注意，它只从迭代器中请求第一项！这意味着下面所有的潜在值将永远不会被计算，从而减少数据管道中的资源浪费。</p><figure class="lf lg lh li gt jr"><div class="bz fp l di"><div class="lj lk l"/></div></figure><p id="aeec" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在完整的库中，也有从<a class="ae kc" href="https://github.com/WimJongeneel/ts-lazy-collections/blob/master/src/main.ts#L65-L74" rel="noopener ugc nofollow" target="_blank">函数</a>或<a class="ae kc" href="https://github.com/WimJongeneel/ts-lazy-collections/blob/master/src/main.ts#L57-L63" rel="noopener ugc nofollow" target="_blank">范围</a>创建迭代器的构造函数。</p><h1 id="c3b9" class="ma mb iq bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated">高阶迭代器</h1><p id="39f1" class="pw-post-body-paragraph kd ke iq kf b kg my ki kj kk mz km kn ko na kq kr ks nb ku kv kw nc ky kz la ij bi translated">高阶迭代器将现有迭代器转换成新的迭代器。这些迭代器构成了管道中的操作。众所周知的转换函数<code class="fe lb lc ld le b">map</code>如下所示。它接受一个迭代器和一个函数，并返回一个新的迭代器，其中函数应用于原始迭代器中的所有项。注意，在转换迭代器时，我们仍然是逐项生成，并保留了迭代器的惰性。如果我们真的想达到我在本文介绍中提到的更高的效率，这是非常重要的！</p><figure class="lf lg lh li gt jr"><div class="bz fp l di"><div class="lj lk l"/></div></figure><p id="5eac" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">过滤可以以类似方式实现。当请求下一个条目时，它将继续从内部迭代器请求条目，直到找到一个通过谓词的条目。该项将被放弃，执行将暂停，直到下一项的请求到来。</p><figure class="lf lg lh li gt jr"><div class="bz fp l di"><div class="lj lk l"/></div></figure><p id="ac92" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">更多的高阶迭代器可以用我上面展示的相同概念来构造。完整的图书馆里有很多，点击<a class="ae kc" href="https://github.com/WimJongeneel/ts-lazy-collections#collection-methods" rel="noopener ugc nofollow" target="_blank">这里</a>查看。</p><h1 id="f604" class="ma mb iq bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated">构建器界面</h1><p id="5465" class="pw-post-body-paragraph kd ke iq kf b kg my ki kj kk mz km kn ko na kq kr ks nb ku kv kw nc ky kz la ij bi translated">库的最后一部分是面向公众的API。该库使用builder模式来允许您像在数组上一样链接方法。这是通过创建一个函数来实现的，该函数接受一个迭代器并返回一个包含方法的对象。这些方法可以使用更新的迭代器再次调用构造函数进行链接:</p><figure class="lf lg lh li gt jr"><div class="bz fp l di"><div class="lj lk l"/></div></figure><p id="566b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">本文开头的例子可以写成如下。在这个实现中，我们不创建额外的数组，只处理实际使用的数据！</p><figure class="lf lg lh li gt jr"><div class="bz fp l di"><div class="lj lk l"/></div></figure><h1 id="c13d" class="ma mb iq bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated">结论</h1><p id="894e" class="pw-post-body-paragraph kd ke iq kf b kg my ki kj kk mz km kn ko na kq kr ks nb ku kv kw nc ky kz la ij bi translated">在本文中，我向您展示了如何使用生成器和迭代器来创建一个强大且非常高效的库，以处理大量数据。当然，迭代器并不是解决所有问题的灵丹妙药。效率的提高是因为节省了不必要的计算。这在实数中意味着什么完全取决于有多少计算可以优化，这些计算有多重，以及你要处理多少数据。当没有要保存的计算或者集合相对较小时，您可能会因为库的开销而损失性能。</p><p id="fb47" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">完整的源代码可以在<a class="ae kc" href="https://github.com/WimJongeneel/ts-lazy-collections#collection-methods" rel="noopener ugc nofollow" target="_blank"> Github </a>上找到，包含了更多适合本文的特性。我很想听听你对此的看法。你认为JavaScript没有对数组方法使用惰性迭代是一个遗憾吗？你认为使用生成器是JavaScript集合的发展方向吗？如果JavaScript在默认情况下使用惰性迭代器，它们应该能够优化开销(就像其他语言所做的那样)，同时仍然有效地保持潜在的优势。</p></div></div>    
</body>
</html>