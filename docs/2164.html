<html>
<head>
<title>Don’t do ‘this’ — Part Two</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">不要做“这个”——第二部分</h1>
<blockquote>原文：<a href="https://itnext.io/dont-do-this-part-two-the-trouble-with-typescript-8ea9b26892e2?source=collection_archive---------0-----------------------#2019-04-10">https://itnext.io/dont-do-this-part-two-the-trouble-with-typescript-8ea9b26892e2?source=collection_archive---------0-----------------------#2019-04-10</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><figure class="iq ir gq gs is it gi gj paragraph-image"><div role="button" tabindex="0" class="iu iv di iw bf ix"><div class="gi gj ip"><img src="../Images/f0b559e93cd9ad6d5a833c221ac718ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gIa3bngVAUFMBUdyUL3Dhw.png"/></div></div><figcaption class="ja jb gk gi gj jc jd bd b be z dk translated">瑞士阿尔卑斯山的漫步(图片由作者提供)</figcaption></figure><div class=""/><div class=""><h2 id="a2bd" class="pw-subtitle-paragraph kd jf jg bd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dk translated">打字稿的问题是</h2></div><h1 id="7da8" class="kv kw jg bd kx ky kz la lb lc ld le lf km lg kn lh kp li kq lj ks lk kt ll lm bi translated">背景</h1><p id="cca8" class="pw-post-body-paragraph ln lo jg lp b lq lr kh ls lt lu kk lv lw lx ly lz ma mb mc md me mf mg mh mi ik bi translated">我在之前的一篇文章中指出，“该死的Javascript编码员说的是‘T1’”，没有人应该使用曾经的<a class="ae mj" href="https://www.typescriptlang.org" rel="noopener ugc nofollow" target="_blank">打字稿</a>，我认为最好是我详细解释一下为什么我认为是这样。</p><p id="6641" class="pw-post-body-paragraph ln lo jg lp b lq mk kh ls lt ml kk lv lw mm ly lz ma mn mc md me mo mg mh mi ik bi translated">这是由两部分组成的文章的第二部分。跳到<a class="ae mj" href="https://medium.com/@davesag/dont-do-this-part-one-objects-and-their-misuse-bd0771c3178a" rel="noopener">前一部分</a>，在那里我对面向对象软件进行了大规模的倾倒，尤其是当它与Javascript相关的时候。</p><h1 id="6199" class="kv kw jg bd kx ky kz la lb lc ld le lf km lg kn lh kp li kq lj ks lk kt ll lm bi translated">所以让我们来谈谈Typescript</h1><p id="71c1" class="pw-post-body-paragraph ln lo jg lp b lq lr kh ls lt lu kk lv lw lx ly lz ma mb mc md me mf mg mh mi ik bi translated">Typescript是Javascript的强类型(因此得名)超集。对于来自强类型OO语言(如Java或C#)的开发人员来说，这是一种很好的方式，可以用强类型和IDE代码完成的安全毯来开发Javascript应用程序。对于没有经验或不称职的开发人员来说，这也是一个非常好的方法来创造一个真正壮观的技术债务山。</p><p id="419b" class="pw-post-body-paragraph ln lo jg lp b lq mk kh ls lt ml kk lv lw mm ly lz ma mn mc md me mo mg mh mi ik bi translated">Typescript鼓励开发人员认为他们是在使用类型安全和面向对象的语言工作。但事实是，Typescript可以编译成Javascript，并允许您将您非常熟悉的类型安全的OO代码与原始的、纯粹的Javascript混合在一起。这就是问题所在。</p><p id="58c1" class="pw-post-body-paragraph ln lo jg lp b lq mk kh ls lt ml kk lv lw mm ly lz ma mn mc md me mo mg mh mi ik bi translated">Javascript本质上并不是一种面向对象语言。当然，它假装是一个，而且，如果你小心的话，你可以写OO风格的Javascript，但是如果你出错了，你<em class="mp">就会</em>出错，那么你就会遇到很多很难调试的小错误。</p><h2 id="2774" class="mq kw jg bd kx mr ms dn lb mt mu dp lf lw mv mw lh ma mx my lj me mz na ll nb bi translated">打字稿是拐杖</h2><p id="5559" class="pw-post-body-paragraph ln lo jg lp b lq lr kh ls lt lu kk lv lw lx ly lz ma mb mc md me mf mg mh mi ik bi translated">但这是一个松散的，不稳定的拐杖。</p><p id="cdf4" class="pw-post-body-paragraph ln lo jg lp b lq mk kh ls lt ml kk lv lw mm ly lz ma mn mc md me mo mg mh mi ik bi translated">Typescript鼓励使用OO。在<a class="ae mj" rel="noopener ugc nofollow" target="_blank" href="/dont-do-this-part-one-objects-and-their-misuse-bd0771c3178a">第一部分</a>中，我讨论了面向对象，特别指出了Javascript的面向对象是应该避免的，除非在极少数情况下你真的想要可重用的对象。</p><h2 id="f960" class="mq kw jg bd kx mr ms dn lb mt mu dp lf lw mv mw lh ma mx my lj me mz na ll nb bi translated">Typescript冗长而难看</h2><p id="4d16" class="pw-post-body-paragraph ln lo jg lp b lq lr kh ls lt lu kk lv lw lx ly lz ma mb mc md me mf mg mh mi ik bi translated">这里有一个例子。对象分解是任何Javascript开发人员工具箱中的重要工具。但是Typescript真的会让你搞砸。</p><p id="0d81" class="pw-post-body-paragraph ln lo jg lp b lq mk kh ls lt ml kk lv lw mm ly lz ma mn mc md me mo mg mh mi ik bi translated">将属性名从一个对象映射到另一个对象是一项非常常见的任务，比方说，因为您已经从一个API中提取了一些JSON，并且您需要不同的属性名。所以你可以写一个映射函数，比如:</p><pre class="nc nd ne nf gu ng nh ni nj aw nk bi"><span id="b484" class="mq kw jg nh b gz nl nm l nn no">const mapUser = ({<br/>  user_name: username,<br/>  first_name: firstName,<br/>  last_name: lastName<br/>}) =&gt; ({<br/>  username,<br/>  firstName,<br/>  lastName<br/>})</span></pre><p id="90d6" class="pw-post-body-paragraph ln lo jg lp b lq mk kh ls lt ml kk lv lw mm ly lz ma mn mc md me mo mg mh mi ik bi translated">这是完全有效的，也是非常可疑的Javascript，但是它肯定会把Typescript搞得一团糟。要在Typescript中编写它，您需要像这样做:</p><pre class="nc nd ne nf gu ng nh ni nj aw nk bi"><span id="133c" class="mq kw jg nh b gz nl nm l nn no">const mapUser = ({<br/>  user_name: username,<br/>  first_name: firstName,<br/>  last_name: lastName<br/>} : {<br/>  username: string,<br/>  firstName: string,<br/>  lastname: string<br/>}) =&gt; ({<br/>  username,<br/>  firstName,<br/>  lastName<br/>} : any);</span></pre><p id="1663" class="pw-post-body-paragraph ln lo jg lp b lq mk kh ls lt ml kk lv lw mm ly lz ma mn mc md me mo mg mh mi ik bi translated">一个非常简洁的映射函数现在变成了一堆可怕的重复，所有这些都是为了确保你的输入是字符串。这还不包括有毒的T2仿制药T3。扔一些尖括号在那里，为所有失去的美丽掉一滴眼泪。</p><p id="8e0d" class="pw-post-body-paragraph ln lo jg lp b lq mk kh ls lt ml kk lv lw mm ly lz ma mn mc md me mo mg mh mi ik bi translated">如果您使用该函数来映射JSON文件中的字段，那么无论如何，您的花哨的类型安全检查已经过时了。</p><pre class="nc nd ne nf gu ng nh ni nj aw nk bi"><span id="4593" class="mq kw jg nh b gz nl nm l nn no">const getUsers = async url =&gt; {<br/>  const { json } = await fetch(url)<br/>  const data = await json()<br/>  return data.map(mapUser)<br/>}</span></pre><p id="4bb6" class="pw-post-body-paragraph ln lo jg lp b lq mk kh ls lt ml kk lv lw mm ly lz ma mn mc md me mo mg mh mi ik bi translated">Typescript怎么知道<code class="fe np nq nr nh b">data</code>里有什么？并没有。而且一旦被编译成Javascript，Typescript假定的类型安全就消失了。</p><h2 id="bd9e" class="mq kw jg bd kx mr ms dn lb mt mu dp lf lw mv mw lh ma mx my lj me mz na ll nb bi translated">Typescript鼓励IDE依赖</h2><p id="a006" class="pw-post-body-paragraph ln lo jg lp b lq lr kh ls lt lu kk lv lw lx ly lz ma mb mc md me mf mg mh mi ik bi translated">也许这只是我的看法，但我实在无法忍受大多数想法。人们似乎喜欢它们的一些东西，比如自动完成，让我抓狂。软件开发不是靠提高你的打字速度来提高的，而是靠提高你的推理能力来提高的。只要你有体面的语法着色，一个集成的文件浏览器，和良好的搜索和替换，这真的是所有体面的Javascript开发人员需要的。我使用Atom和很少的插件。我有时也会使用TextMate，因为出于某种难以理解的原因，Atom不允许您拖动文件从一个项目复制到另一个项目。</p><p id="c6f1" class="pw-post-body-paragraph ln lo jg lp b lq mk kh ls lt ml kk lv lw mm ly lz ma mn mc md me mo mg mh mi ik bi translated">但是要正确使用Typescript，你真的需要购买整个微软VS Code的东西，或者在WebStorm或更糟的地方混日子。来自Java或C#的人可能会渴望Eclipse或NetBeans，但其他人不会。</p><h2 id="0821" class="mq kw jg bd kx mr ms dn lb mt mu dp lf lw mv mw lh ma mx my lj me mz na ll nb bi translated">Typescript引入了自己奇怪的错误</h2><p id="adf6" class="pw-post-body-paragraph ln lo jg lp b lq lr kh ls lt lu kk lv lw lx ly lz ma mb mc md me mf mg mh mi ik bi translated">在他的博客文章“<a class="ae mj" href="https://blog.codeminer42.com/the-good-the-bad-and-the-ugly-of-typescript-58a3ff3e248" rel="noopener ugc nofollow" target="_blank">打字稿的好、坏、丑</a>”中，莱昂纳多·弗雷塔斯解释道:</p><blockquote class="ns nt nu"><p id="5fe1" class="ln lo mp lp b lq mk kh ls lt ml kk lv nv mm ly lz nw mn mc md nx mo mg mh mi ik bi translated">如果你像我一样是一个函数式编程的人，将curried方法与承诺联系起来有时会有问题。这是因为一些框架使用了原生的ES Promises，而另一些使用了第三方promise库，比如<a class="ae mj" href="http://bluebirdjs.com/docs/getting-started.html" rel="noopener ugc nofollow" target="_blank"> Bluebird </a>。尽管在JS中链接它们没有问题，但TypeScript认为它们是不同的类型，甚至会拒绝传输，因此抛出了一个<code class="fe np nq nr nh b"><em class="jg">TypeError</em></code>。</p></blockquote><h2 id="d282" class="mq kw jg bd kx mr ms dn lb mt mu dp lf lw mv mw lh ma mx my lj me mz na ll nb bi translated">Typescript意味着您需要一个预处理器</h2><p id="89b6" class="pw-post-body-paragraph ln lo jg lp b lq lr kh ls lt lu kk lv lw lx ly lz ma mb mc md me mf mg mh mi ik bi translated">前端开发人员非常习惯于使用像<a class="ae mj" href="https://babeljs.io" rel="noopener ugc nofollow" target="_blank"> Babel </a>这样的预处理器和像<a class="ae mj" href="https://webpack.js.org" rel="noopener ugc nofollow" target="_blank"> Webpack </a>这样的构建工具来将他们的超级现代Javascript转换成浏览器可以理解的东西。但是对于使用NodeJS的后端开发人员来说，不需要构建工具，预处理器只是增加了一层烦人的复杂性，没有任何价值。部署一个需要在使用之前就构建好的服务器是令人厌烦的。</p><h2 id="9f44" class="mq kw jg bd kx mr ms dn lb mt mu dp lf lw mv mw lh ma mx my lj me mz na ll nb bi translated">使用Typescript在单元测试中进行模拟更加困难</h2><p id="f751" class="pw-post-body-paragraph ln lo jg lp b lq lr kh ls lt lu kk lv lw lx ly lz ma mb mc md me mf mg mh mi ik bi translated">前端开发人员可以使用像<code class="fe np nq nr nh b"><a class="ae mj" href="https://jestjs.io" rel="noopener ugc nofollow" target="_blank">Jest</a></code>这样的测试框架，其中包括真正令人惊讶的模仿能力。但是，当您将Typescript添加到组合中时，这些<a class="ae mj" href="https://stackoverflow.com/search?q=jest+typescript" rel="noopener ugc nofollow" target="_blank">就会变得混乱</a>。对于使用Node的后端开发人员来说，更常用的是<code class="fe np nq nr nh b"><a class="ae mj" href="https://mochajs.org" rel="noopener ugc nofollow" target="_blank">mocha</a></code>测试框架，以及像<code class="fe np nq nr nh b">proxyquire</code>这样的模仿工具，插入<em class="mp">任何</em>类型的预处理构建步骤都会使您的测试设置更加困难。</p><p id="336c" class="pw-post-body-paragraph ln lo jg lp b lq mk kh ls lt ml kk lv lw mm ly lz ma mn mc md me mo mg mh mi ik bi translated">单元测试很重要。我读过各种各样的文章，声称使用Typescript时不需要进行严格的单元测试，因为它具有编译时的类型安全性，但这只是无稽之谈。我也读到过这样的观点:如果你在嘲笑，你就是在做错误的测试；那也是废话。事实恰恰相反。</p><h2 id="e22e" class="mq kw jg bd kx mr ms dn lb mt mu dp lf lw mv mw lh ma mx my lj me mz na ll nb bi translated">题外话:为嘲笑辩护</h2><p id="e620" class="pw-post-body-paragraph ln lo jg lp b lq lr kh ls lt lu kk lv lw lx ly lz ma mb mc md me mf mg mh mi ik bi translated">真正的单元测试只测试有问题的特定代码单元。如果您的代码是这样的:</p><pre class="nc nd ne nf gu ng nh ni nj aw nk bi"><span id="5d4d" class="mq kw jg nh b gz nl nm l nn no">const fetch = require('node-fetch)<br/>const mapUser = require('src/utils/mapUser')</span><span id="33ed" class="mq kw jg nh b gz ny nm l nn no">const getUsers = async url =&gt; {<br/>  const { json } = await fetch(url)<br/>  const data = await json()<br/>  return data.map(mapUser)<br/>}</span></pre><p id="27d5" class="pw-post-body-paragraph ln lo jg lp b lq mk kh ls lt ml kk lv lw mm ly lz ma mn mc md me mo mg mh mi ik bi translated">您可以像这样对它进行单元测试:</p><pre class="nc nd ne nf gu ng nh ni nj aw nk bi"><span id="8b6b" class="mq kw jg nh b gz nl nm l nn no">const { expect } = require('chai')<br/>const { stub } = require('sinon')<br/>const proxyquire = require('proxyquire')</span><span id="1358" class="mq kw jg nh b gz ny nm l nn no">describe('getUsers', () =&gt; {<br/>  const fetch = stub()<br/>  const json = stub()<br/>  const data = ['some data']<br/>  const mapUser = stub()</span><span id="0c20" class="mq kw jg nh b gz ny nm l nn no">const response = { json }<br/>  const url = 'some-url'</span><span id="a5e3" class="mq kw jg nh b gz ny nm l nn no">const getUsers = proxyquire('src/getUsers', {<br/>    'node-fetch': fetch,<br/>    'src/utils/mapUser': mapUser<br/>  })<br/>  const expected = ['some result']</span><span id="d933" class="mq kw jg nh b gz ny nm l nn no">let result</span><span id="15ce" class="mq kw jg nh b gz ny nm l nn no">before(async () =&gt; {<br/>    fetch.resolves(response)<br/>    json.resolves(data)<br/>    mapUser.returns(expected[0])<br/>    result = await getUsers(url)<br/>  })<br/>  <br/>  it('called fetch with the supplied url', () =&gt; {<br/>    expect(fetch).to.have.been.calledWith(url)<br/>  })<br/>  <br/>  it('called json', () =&gt; {<br/>    expect(json).to.have.been.calledOnce<br/>  })<br/>  <br/>  it('called mapUser once with the right data', () =&gt; {<br/>    expect(mapUser).to.have.been.calledOnceWith(data[0])<br/>  })<br/>  <br/>  it('returned the expected result', () =&gt; {<br/>    expect(result).to.deep.equal(expected)<br/>  })<br/>})</span></pre><p id="9ce5" class="pw-post-body-paragraph ln lo jg lp b lq mk kh ls lt ml kk lv lw mm ly lz ma mn mc md me mo mg mh mi ik bi translated">像这样的测试既全面又快速。任何编写单元测试而不无情嘲讽的人，根本就不是在编写高效的单元测试。</p><p id="5edf" class="pw-post-body-paragraph ln lo jg lp b lq mk kh ls lt ml kk lv lw mm ly lz ma mn mc md me mo mg mh mi ik bi translated">单元测试当然不能替代实际的集成测试，但那是另一回事了。</p><h2 id="3ddf" class="mq kw jg bd kx mr ms dn lb mt mu dp lf lw mv mw lh ma mx my lj me mz na ll nb bi translated">Typescript是编程语言的宝库</h2><p id="7819" class="pw-post-body-paragraph ln lo jg lp b lq lr kh ls lt lu kk lv lw lx ly lz ma mb mc md me mf mg mh mi ik bi translated">你知道沃尔沃的司机认为他们是世界上最安全的司机，因为他们驾驶的汽车据称有更多的安全功能。但是这种虚假的安全感实际上会让他们成为危险的不安全司机。</p><figure class="nc nd ne nf gu it"><div class="bz fq l di"><div class="nz oa l"/></div><figcaption class="ja jb gk gi gj jc jd bd b be z dk translated"><strong class="ak">牛群</strong> — 1997年由<a class="ae mj" href="https://en.wikipedia.org/wiki/Heather_Croall" rel="noopener ugc nofollow" target="_blank">希瑟·克罗尔</a>创作，音乐由<a class="ae mj" href="https://www.youtube.com/watch?v=-h9j5N8aX1M" rel="noopener ugc nofollow" target="_blank">汤姆·史密斯</a>创作。经许可使用<a class="ae mj" href="https://twitter.com/heathercroall/status/1115598759394549763" rel="noopener ugc nofollow" target="_blank"/>。</figcaption></figure><h1 id="d258" class="kv kw jg bd kx ky kz la lb lc ld le lf km lg kn lh kp li kq lj ks lk kt ll lm bi translated">第二部分到此结束</h1><p id="99cf" class="pw-post-body-paragraph ln lo jg lp b lq lr kh ls lt lu kk lv lw lx ly lz ma mb mc md me mf mg mh mi ik bi translated">回到<a class="ae mj" href="https://medium.com/@davesag/dont-do-this-part-one-objects-and-their-misuse-bd0771c3178a" rel="noopener">第一部分</a>阅读我对面向对象的一般性批评，尤其是因为它是用Javascript完成的。</p><h2 id="41b7" class="mq kw jg bd kx mr ms dn lb mt mu dp lf lw mv mw lh ma mx my lj me mz na ll nb bi translated">我们了解到:</h2><ul class=""><li id="283f" class="ob oc jg lp b lq lr lt lu lw od ma oe me of mi og oh oi oj bi translated">Typescript鼓励过度使用对象</li><li id="b18d" class="ob oc jg lp b lq ok lt ol lw om ma on me oo mi og oh oi oj bi translated">Typescript给了开发人员一种虚假的安全感</li><li id="c13b" class="ob oc jg lp b lq ok lt ol lw om ma on me oo mi og oh oi oj bi translated">Typescript使您的代码变得难看并且更难测试</li><li id="23aa" class="ob oc jg lp b lq ok lt ol lw om ma on me oo mi og oh oi oj bi translated">不应该使用Typescript</li></ul><h1 id="7a92" class="kv kw jg bd kx ky kz la lb lc ld le lf km lg kn lh kp li kq lj ks lk kt ll lm bi translated">链接</h1><h2 id="66be" class="mq kw jg bd kx mr ms dn lb mt mu dp lf lw mv mw lh ma mx my lj me mz na ll nb bi translated">文章</h2><ul class=""><li id="cf2d" class="ob oc jg lp b lq lr lt lu lw od ma oe me of mi og oh oi oj bi translated"><a class="ae mj" href="https://blog.codeminer42.com/the-good-the-bad-and-the-ugly-of-typescript-58a3ff3e248" rel="noopener ugc nofollow" target="_blank">打字稿的好、坏、丑</a></li><li id="4f89" class="ob oc jg lp b lq ok lt ol lw om ma on me oo mi og oh oi oj bi translated"><a class="ae mj" href="https://medium.com/@davesag/shit-javascript-coders-say-7a2d2881228d" rel="noopener">狗屁Javascript编码员说</a></li></ul><h2 id="b13e" class="mq kw jg bd kx mr ms dn lb mt mu dp lf lw mv mw lh ma mx my lj me mz na ll nb bi translated">技术</h2><ul class=""><li id="19a4" class="ob oc jg lp b lq lr lt lu lw od ma oe me of mi og oh oi oj bi translated"><a class="ae mj" href="https://www.typescriptlang.org" rel="noopener ugc nofollow" target="_blank">打字稿</a></li><li id="14dd" class="ob oc jg lp b lq ok lt ol lw om ma on me oo mi og oh oi oj bi translated"><a class="ae mj" href="https://nodejs.org" rel="noopener ugc nofollow" target="_blank"> NodeJS </a></li><li id="52ce" class="ob oc jg lp b lq ok lt ol lw om ma on me oo mi og oh oi oj bi translated"><a class="ae mj" href="https://mochajs.org" rel="noopener ugc nofollow" target="_blank">摩卡</a></li><li id="453e" class="ob oc jg lp b lq ok lt ol lw om ma on me oo mi og oh oi oj bi translated"><a class="ae mj" href="https://github.com/thlorenz/proxyquire" rel="noopener ugc nofollow" target="_blank">代理查询</a></li><li id="2fbd" class="ob oc jg lp b lq ok lt ol lw om ma on me oo mi og oh oi oj bi translated"><a class="ae mj" href="https://babeljs.io" rel="noopener ugc nofollow" target="_blank">巴别塔</a></li><li id="59f5" class="ob oc jg lp b lq ok lt ol lw om ma on me oo mi og oh oi oj bi translated"><a class="ae mj" href="https://webpack.js.org" rel="noopener ugc nofollow" target="_blank">网络包</a></li><li id="2b3c" class="ob oc jg lp b lq ok lt ol lw om ma on me oo mi og oh oi oj bi translated"><a class="ae mj" href="https://jestjs.io" rel="noopener ugc nofollow" target="_blank">笑话</a></li><li id="70e0" class="ob oc jg lp b lq ok lt ol lw om ma on me oo mi og oh oi oj bi translated"><a class="ae mj" href="https://jestjs.io/docs/en/manual-mocks.html" rel="noopener ugc nofollow" target="_blank">手动模拟</a></li></ul><p id="ad93" class="pw-post-body-paragraph ln lo jg lp b lq mk kh ls lt ml kk lv lw mm ly lz ma mn mc md me mo mg mh mi ik bi">—</p><p id="f5f2" class="pw-post-body-paragraph ln lo jg lp b lq mk kh ls lt ml kk lv lw mm ly lz ma mn mc md me mo mg mh mi ik bi translated">像这样但不是订户？你可以通过<a class="ae mj" href="https://davesag.medium.com/membership" rel="noopener">davesag.medium.com</a>加入来支持作者。</p></div></div>    
</body>
</html>