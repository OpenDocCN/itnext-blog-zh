<html>
<head>
<title>Variations on imagestreams in OpenShift 4</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">OpenShift 4中图像流的变化</h1>
<blockquote>原文：<a href="https://itnext.io/variations-on-imagestreams-in-openshift-4-f8ee5e8be633?source=collection_archive---------1-----------------------#2019-08-14">https://itnext.io/variations-on-imagestreams-in-openshift-4-f8ee5e8be633?source=collection_archive---------1-----------------------#2019-08-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="fee9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">集装箱图像存储在图像注册中心(如<a class="ae kl" href="https://hub.docker.com/" rel="noopener ugc nofollow" target="_blank"> Docker Hub </a>、<a class="ae kl" href="https://quay.io/" rel="noopener ugc nofollow" target="_blank"> Quay.io </a>)，从这里可以<em class="km">提取</em>并手动运行或在Kubernetes集群中运行。Vanilla Kubernetes没有企业环境中通常需要的内部图像注册中心。<a class="ae kl" href="https://www.openshift.com/" rel="noopener ugc nofollow" target="_blank"> Red Hat OpenShift </a>打算通过提供一个开箱即用的<a class="ae kl" href="https://docs.openshift.com/container-platform/4.1/registry/architecture-component-imageregistry.html" rel="noopener ugc nofollow" target="_blank">集成注册表</a>并引入一个名为<em class="km"> ImageStream </em>的新Kubernetes资源来以“Kubernetes-native方式”管理图像，从而填补这一空白。</p><p id="f05d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">ImageStreams旨在支持不同的用例，但某些参数的影响在开始时可能会令人困惑。在本帖中，我们将看看其中的一些参数，以及它们如何改变从不同图像流创建的部署的行为。要了解OpenShift中图像管理的基本概念，请首先查看以下链接:</p><ul class=""><li id="6776" class="kn ko iq jp b jq jr ju jv jy kp kc kq kg kr kk ks kt ku kv bi translated"><a class="ae kl" href="https://docs.openshift.com/container-platform/4.1/openshift_images/image-streams-manage.html" rel="noopener ugc nofollow" target="_blank">管理OpenShift 4文档中的图像流</a></li><li id="2f80" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk ks kt ku kv bi translated"><a class="ae kl" href="https://docs.openshift.com/container-platform/3.11/dev_guide/managing_images.html" rel="noopener ugc nofollow" target="_blank">管理OpenShift 3文档中的图像</a></li><li id="c1a8" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk ks kt ku kv bi translated">相关博客<a class="ae kl" href="https://cloudowski.com/articles/why-managing-container-images-on-openshift-is-better-than-on-kubernetes/" rel="noopener ugc nofollow" target="_blank">这里</a>，这里<a class="ae kl" href="https://blog.openshift.com/automatically-update-red-hat-container-images-on-openshift-3-11/" rel="noopener ugc nofollow" target="_blank">这里</a>，这里<a class="ae kl" href="https://blog.openshift.com/image-streams-faq/" rel="noopener ugc nofollow" target="_blank">这里</a>。</li></ul><blockquote class="lb lc ld"><p id="65ef" class="jn jo km jp b jq jr js jt ju jv jw jx le jz ka kb lf kd ke kf lg kh ki kj kk ij bi translated">在OpenShift 4中，ImageStreams的功能与OpenShift 3中的基本相同。对于这篇博文中的测试，我们使用了OpenShift v4.1.6。</p></blockquote><p id="0030" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从技术上讲，ImageStream只是一个包含元数据的Kubernetes资源。除了管理内部图像——通常<a class="ae kl" href="https://docs.openshift.com/container-platform/4.1/builds/understanding-image-builds.html" rel="noopener ugc nofollow" target="_blank">构建在OpenShift集群</a>中——ImageStreams还可以指向外部注册表中的图像。在这种情况下，它们只是一个额外的抽象层，提供一些额外的功能(例如轮询更新、缓存)。因为图像流可以以两种不同的方式表现，如果我们区分它们是指向内部图像还是外部图像，就更容易理解它们。</p><blockquote class="lb lc ld"><p id="90d4" class="jn jo km jp b jq jr js jt ju jv jw jx le jz ka kb lf kd ke kf lg kh ki kj kk ij bi translated">类似于注册表中的存储库，ImageStream有多个<em class="iq">标记</em>指向一个图像，因此ImageStream实际上是ImageStream标记的集合。严格地说，容器是从ImageStreamTag(不是ImageStream)创建的，但为了简单起见，我们在本文中互换使用这些术语。</p></blockquote><h2 id="460e" class="lh li iq bd lj lk ll dn lm ln lo dp lp jy lq lr ls kc lt lu lv kg lw lx ly lz bi translated">内部与外部图像</h2><p id="13b1" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">首先，关于存储在内部注册表中的图像的一些注意事项:</p><ul class=""><li id="db3a" class="kn ko iq jp b jq jr ju jv jy kp kc kq kg kr kk ks kt ku kv bi translated">对于内部图像，图像流和内部注册表是紧密耦合的。例如，<code class="fe mf mg mh mi b">myproject</code>名称空间中的<code class="fe mf mg mh mi b">myimage-internal</code>图像流被映射到<code class="fe mf mg mh mi b">image-registry.openshift-image-registry.svc:5000/myproject/myimage-internal</code>存储库。</li><li id="95cf" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk ks kt ku kv bi translated">如果我们运行一个新的构建，其中的<a class="ae kl" href="https://docs.openshift.com/container-platform/4.1/builds/managing-build-output.html" rel="noopener ugc nofollow" target="_blank">输出</a>是一个ImageStream，那么这个图像将被存储在内部注册表中。</li><li id="a5bc" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk ks kt ku kv bi translated">如果我们手动<em class="km">将</em>推送到注册表(参见<a class="ae kl" href="https://blog.openshift.com/remotely-push-pull-container-images-openshift" rel="noopener ugc nofollow" target="_blank">如何操作</a>)，将自动创建一个匹配的图像流。该url必须引用一个有效的名称空间，我们在其中拥有<em class="km">编辑</em>权限。</li><li id="63a0" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk ks kt ku kv bi translated">如果我们删除图像流，内部注册表中的存储库也会被删除，我们的图像也会丢失。</li><li id="98d0" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk ks kt ku kv bi translated">为了维护注册表使用的空间，你必须偶尔<a class="ae kl" href="https://docs.openshift.com/container-platform/4.1/applications/pruning-objects.html" rel="noopener ugc nofollow" target="_blank">修剪图像</a>。在修剪过程中，会自动保留在构建或部署中使用过或最近使用过的内部映像。</li></ul><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi mj"><img src="../Images/ccf3e1106b7e4141bd578641a37e0a29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M_pqkbqDvXkOSK0z3ckRpA.png"/></div></div></figure><p id="cf62" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">外部图像的ImageStreams怎么样？：</p><ul class=""><li id="0f87" class="kn ko iq jp b jq jr ju jv jy kp kc kq kg kr kk ks kt ku kv bi translated">我们可以用<code class="fe mf mg mh mi b">oc import-image</code>或<code class="fe mf mg mh mi b">oc tag</code>命令或者直接用<em class="km"> yaml </em>创建一个指向外部图像的图像流。</li><li id="c69c" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk ks kt ku kv bi translated">在单个ImageStream中，您可以让标签指向来自完全不同的注册中心和存储库的图像。这是耦合相关但存储在不同存储库中的外部图像的有效方法。</li><li id="dc0f" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk ks kt ku kv bi translated">作为抽象层，图像流隐藏了图像的实际来源。当构建和部署引用ImageStream时，我们可以通过修改ImageStream中的url来更改正在使用的映像，而不是逐个编辑每个构建和部署。</li><li id="bd70" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk ks kt ku kv bi translated">当创建或更新图像时，ImageStream通过其唯一的<em class="km"> sha256 </em> <em class="km"> ID </em>而不是标签来引用图像。这提供了防止标签在外部注册表中移动的稳定性。</li><li id="f130" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk ks kt ku kv bi translated">ImageStreams可以定期(15分钟)监控外部标签是否改变(通过<code class="fe mf mg mh mi b">--scheduled=true</code>)。有时这是一个有用的特性—对于安全更新来说—有时我们想要相反的东西，使用ImageStreams来确保我们使用相同的图像，即使外部标签移动了—为了稳定性。</li><li id="0d3f" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk ks kt ku kv bi translated">我们可以在内部注册表中缓存外部图像(通过<code class="fe mf mg mh mi b">--reference-policy=local</code>)。这真的很有用，因为它使部署更快，并且独立于外部注册表的可用性。</li></ul><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi mv"><img src="../Images/8eacf6d6e168b430b398134ef107ef80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I_FCoX7_560PPnyvF1pkoQ.png"/></div></div></figure><p id="1377" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">另一个重要的特性——对于内部和外部映像——是能够自动触发相关的<em class="km"> BuildConfigs </em>和<em class="km"> DeploymentConfigs </em>如果它们的映像流被更新。这种行为可以在那些资源上进行设置(<a class="ae kl" href="https://docs.openshift.com/container-platform/4.1/applications/deployments/managing-deployment-processes.html#deployments-triggers_deployment-operations" rel="noopener ugc nofollow" target="_blank">参见</a> <code class="fe mf mg mh mi b">imageChangeParams.automatic=true</code>)并且通常是启用的。</p><h1 id="7088" class="mw li iq bd lj mx my mz lm na nb nc lp nd ne nf ls ng nh ni lv nj nk nl ly nm bi translated">变化</h1><p id="2709" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">现在，让我们来看看不同类型的图像流的详细信息:</p><ul class=""><li id="0016" class="kn ko iq jp b jq jr ju jv jy kp kc kq kg kr kk ks kt ku kv bi translated">指向外部图像</li><li id="69e1" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk ks kt ku kv bi translated">用<em class="km">拉通</em>指向外部图像(缓存)</li><li id="2580" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk ks kt ku kv bi translated">直接引用外部图像url</li><li id="fa32" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk ks kt ku kv bi translated">指向内部图像</li><li id="d36a" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk ks kt ku kv bi translated">指向另一个图像流</li></ul><h2 id="dee2" class="lh li iq bd lj lk ll dn lm ln lo dp lp jy lq lr ls kc lt lu lv kg lw lx ly lz bi translated">外部图像</h2><p id="1b13" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">创建指向外部图像的ImageStream，如下所示:</p><pre class="mk ml mm mn gt nn mi no np aw nq bi"><span id="6266" class="lh li iq mi b gy nr ns l nt nu">oc import-image myproject/myimage-ref-source:mytag --from="docker.io/balazsszeti/hello:sleeper" --confirm</span></pre><p id="903f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">或者，我们可以使用具有相同结果的<code class="fe mf mg mh mi b">oc tag</code>:</p><pre class="mk ml mm mn gt nn mi no np aw nq bi"><span id="e954" class="lh li iq mi b gy nr ns l nt nu">oc tag docker.io/balazsszeti/hello:sleeper myproject/myimage-ref-source:mytag</span></pre><p id="0dc7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">查看前面命令创建的<em class="km"> yaml </em>资源:</p><pre class="mk ml mm mn gt nn mi no np aw nq bi"><span id="aff4" class="lh li iq mi b gy nr ns l nt nu">$ oc get is myimage-ref-source -oyaml<br/>apiVersion: image.openshift.io/v1<br/>kind: ImageStream<br/>metadata:<br/>  annotations:<br/>    openshift.io/image.dockerRepositoryCheck: "2019-08-08T17:50:46Z"<br/>  creationTimestamp: "2019-08-08T17:50:45Z"<br/>  generation: 2<br/>  name: myimage-ref-source<br/>  namespace: myproject<br/>  resourceVersion: "741320"<br/>  selfLink: /apis/image.openshift.io/v1/namespaces/myproject/imagestreams/myimage-ref-source<br/>  uid: 0c8c4396-ba05-11e9-b920-0a580a800116<br/>spec:<br/>  <strong class="mi ir">lookupPolicy:<br/>    local: false</strong><br/>  tags:<br/>  - annotations: null<br/>    <strong class="mi ir">from:<br/>      kind: DockerImage<br/>      name: docker.io/balazsszeti/hello:sleeper</strong><br/>    generation: 2<br/>    <strong class="mi ir">importPolicy: {}</strong><br/>    name: mytag<br/>    <strong class="mi ir">referencePolicy:<br/>      type: Source</strong><br/>status:<br/>  dockerImageRepository: image-registry.openshift-image-registry.svc:5000/myproject/myimage-ref-source<br/>  publicDockerImageRepository: default-route-openshift-image-registry.apps-crc.testing/myproject/myimage-ref-source<br/>  tags:<br/>  - items:<br/>    - created: "2019-08-08T17:50:46Z"<br/>      dockerImageReference: docker.io/balazsszeti/hello@sha256:42957024...<br/>      generation: 2<br/>      image: sha256:42957024...<br/>    tag: mytag</span></pre><blockquote class="lb lc ld"><p id="056a" class="jn jo km jp b jq jr js jt ju jv jw jx le jz ka kb lf kd ke kf lg kh ki kj kk ij bi translated">在本例中，我们使用名称“我的图像参考源”,因为默认情况下设置<code class="fe mf mg mh mi b">referencePolicy.type</code>为<code class="fe mf mg mh mi b">Source</code>。参见下面的“<a class="ae kl" href="#3eae" rel="noopener ugc nofollow">带拉通</a>的外部图像”，我们如何为不同的行为改变该设置。</p></blockquote><p id="a3dc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们讨论一下这个图像流是如何工作的:</p><ol class=""><li id="75dd" class="kn ko iq jp b jq jr ju jv jy kp kc kq kg kr kk nv kt ku kv bi translated"><strong class="jp ir">当Pod由引用此图像流的构建或部署创建时，它使用哪个图像url？<br/> </strong>图像由<em class="km"> sha256 ID </em>提取，外部标签在图像流创建时指向此处:<code class="fe mf mg mh mi b">docker.io/balazsszeti/hello@sha256:42957024b43e121a210a1b3a8a44f497233a2385f7ef48227a6866afdb9b8e1b</code></li><li id="6b62" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk nv kt ku kv bi translated"><strong class="jp ir">如果外部注册表不可访问，它还能工作吗？例如，在临时网络中断或外部注册表关闭时？</strong> <br/>否，因为Pod使用外部url。</li><li id="3cdf" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk nv kt ku kv bi translated"><strong class="jp ir">如果外部注册表中的标签移动，并且我们为DeploymentConfig提供了新的卷展栏，会发生什么情况？</strong> <br/>由于ImageStream标签指向图像的<em class="km"> sha256 ID </em>，所以即使外部标签移动，容器也将从图像的该版本创建。您可以通过再次运行<code class="fe mf mg mh mi b">oc tag</code>或<code class="fe mf mg mh mi b">oc import-image</code>或通过<code class="fe mf mg mh mi b">--scheduled=true</code>启用自动更新来手动更新ImageStream中的引用(这将在yaml中添加<code class="fe mf mg mh mi b">importPolicy: {scheduled: true}</code>)。</li><li id="76d4" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk nv kt ku kv bi translated">这个ImageStream可以用在Pod(或其他香草Kubernetes资源)中吗？ <br/>是，但不是默认。您需要<code class="fe mf mg mh mi b">lookupPolicy: {local: true}</code> <a class="ae kl" href="https://docs.openshift.com/container-platform/3.9/dev_guide/managing_images.html#using-is-with-k8s" rel="noopener ugc nofollow" target="_blank"> set </a>并且它只在同一个名称空间内工作。<br/> <code class="fe mf mg mh mi b">oc set image-lookup myimage-ref-source</code></li><li id="77ff" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk nv kt ku kv bi translated"><strong class="jp ir">deployment config roll back在部署后切换回以前的版本有效吗？</strong> <br/>是的。使用<code class="fe mf mg mh mi b">oc rollback dc/myimage-ref-source</code>回滚会使用DeploymentConfig以前的映像url创建一个新的部署。因为它通过以前的<em class="km"> sha256 ID </em>引用外部映像url注意:只有旧映像在外部注册表中仍然可用时，这才会起作用。</li></ol><blockquote class="lb lc ld"><p id="8832" class="jn jo km jp b jq jr js jt ju jv jw jx le jz ka kb lf kd ke kf lg kh ki kj kk ij bi translated">我们的测试容器是一个简单的“Hello World ”,带有一个docker文件:</p></blockquote><figure class="mk ml mm mn gt mo"><div class="bz fp l di"><div class="nw nx l"/></div></figure><blockquote class="lb lc ld"><p id="ca0c" class="jn jo km jp b jq jr js jt ju jv jw jx le jz ka kb lf kd ke kf lg kh ki kj kk ij bi translated">还有一个DeploymentConfig示例，用于参考使用ImageStream的测试部署:</p></blockquote><figure class="mk ml mm mn gt mo"><div class="bz fp l di"><div class="nw nx l"/></div></figure><h2 id="3eae" class="lh li iq bd lj lk ll dn lm ln lo dp lp jy lq lr ls kc lt lu lv kg lw lx ly lz bi translated">具有拉通的外部图像</h2><p id="5aa9" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">要创建指向外部映像的ImageStream并启用pullthrough，请将reference-policy标志修改为<code class="fe mf mg mh mi b">—-reference-policy=local</code>:</p><pre class="mk ml mm mn gt nn mi no np aw nq bi"><span id="1c3f" class="lh li iq mi b gy nr ns l nt nu">oc import-image myproject/myimage-ref-local:mytag --from="docker.io/balazsszeti/hello:sleeper" --confirm --reference-policy=local</span></pre><p id="77dd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">或者</p><pre class="mk ml mm mn gt nn mi no np aw nq bi"><span id="d5f0" class="lh li iq mi b gy nr ns l nt nu">oc tag docker.io/balazsszeti/hello:sleeper myproject/myimage-ref-local:mytag --reference-policy=local</span></pre><p id="c804" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里我们只展示了<em class="km"> yaml </em>中有趣的部分:</p><pre class="mk ml mm mn gt nn mi no np aw nq bi"><span id="f46a" class="lh li iq mi b gy nr ns l nt nu">$ oc get is -oyaml myimage-ref-local<br/>apiVersion: image.openshift.io/v1<br/>kind: ImageStream<br/>metadata:<br/>  name: myimage-ref-local<br/>spec:<br/>  tags:<br/>  - <strong class="mi ir">from:<br/>      kind: DockerImage<br/>      name: docker.io/balazsszeti/hello:sleeper</strong><br/>    name: mytag<br/>    <strong class="mi ir">referencePolicy:<br/>      type: Local</strong><br/>status:<br/>  dockerImageRepository: image-registry.openshift-image-registry.svc:5000/myproject/myimage-ref-local<br/>  tags:<br/>  - items:<br/>    - dockerImageReference: docker.io/balazsszeti/hello@sha256:42957024...<br/>      image: sha256:42957024...<br/>    tag: mytag</span></pre><p id="ac8a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">和上面一样的问题:</p><ol class=""><li id="1cf4" class="kn ko iq jp b jq jr ju jv jy kp kc kq kg kr kk nv kt ku kv bi translated"><strong class="jp ir">Pod中的图片url是什么？<br/> </strong>图像通过被<em class="km">拉入内部注册表，因此Pod引用一个内部图像url: <code class="fe mf mg mh mi b">image-registry.openshift-image-registry.svc:5000/myproject/myimage-ref-local@sha256:42957024b43e121a210a1b3a8a44f497233a2385f7ef48227a6866afdb9b8e1b</code></em></li><li id="1129" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk nv kt ku kv bi translated"><strong class="jp ir">当外部注册表不可达时是否工作？<br/> </strong>图像第一次使用时被缓存。所以它在第一次部署时不能脱机工作，但是一旦被缓存，就再也不需要联系外部注册表了。即使图像从外部注册表中删除，它仍将保留在缓存中。</li><li id="ff89" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk nv kt ku kv bi translated"><strong class="jp ir">如果标签移动会怎样？</strong> <br/>和以前一样，ImageStream标签指向图像的<em class="km"> sha256 ID </em>，所以即使外部标签移动，容器也是从同一个图像创建的。使用<code class="fe mf mg mh mi b">--scheduled=true</code>或者手动刷新ImageStream将会更新它所引用的<em class="km"> sha256 ID </em>，但是新的图像只有在容器需要它的时候才会被缓存。</li><li id="1fe3" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk nv kt ku kv bi translated"><strong class="jp ir">该ImageStream可以在Pod中使用吗？</strong> <br/>是的，设定后<code class="fe mf mg mh mi b">lookupPolicy: {local: true}</code>。</li><li id="df5a" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk nv kt ku kv bi translated"><strong class="jp ir">回滚有效吗？</strong> <br/>是的。pod通过<em class="km"> sha256 ID </em>指向内部url，因此在回滚后旧的映像如预期的那样被使用。显然，这只有在旧图像没有从内部注册表中删除的情况下才有效——如果您仍然可以在ImageStream标签项目历史记录中看到它，则它是可用的。</li></ol><h2 id="8a80" class="lh li iq bd lj lk ll dn lm ln lo dp lp jy lq lr ls kc lt lu lv kg lw lx ly lz bi translated">引用外部图像</h2><p id="3bf3" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">我们可以通过<code class="fe mf mg mh mi b">--reference=true</code>标志创建一个直接引用外部标签的ImageStream:</p><pre class="mk ml mm mn gt nn mi no np aw nq bi"><span id="25d3" class="lh li iq mi b gy nr ns l nt nu">oc tag docker.io/balazsszeti/hello:sleeper myproject/myimage-reference:mytag --reference=true</span></pre><p id="a0cc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">相关的<em class="km"> yaml </em>:</p><pre class="mk ml mm mn gt nn mi no np aw nq bi"><span id="eee6" class="lh li iq mi b gy nr ns l nt nu">$ oc get is myimage-reference -oyaml<br/>apiVersion: image.openshift.io/v1<br/>kind: ImageStream<br/>metadata:<br/>  name: myimage-reference<br/>spec:<br/>  tags:<br/>  - <strong class="mi ir">from:<br/>      kind: DockerImage<br/>      name: docker.io/balazsszeti/hello:sleeper</strong><br/>    name: mytag<br/>    <strong class="mi ir">reference: true</strong><br/>    referencePolicy:<br/>      type: Source<br/>status:<br/>  dockerImageRepository: image-registry.openshift-image-registry.svc:5000/myproject/myimage-reference<br/>  tags:<br/>  - items:<br/>    - dockerImageReference: docker.io/balazsszeti/hello:sleeper<br/>      image: ""<br/>    tag: mytag</span></pre><p id="0861" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">和上面一样的问题:</p><ol class=""><li id="a06b" class="kn ko iq jp b jq jr ju jv jy kp kc kq kg kr kk nv kt ku kv bi translated"><strong class="jp ir">Pod中的图像url是什么？<br/></strong>Pod正在通过标签(而不是<em class="km"> sha256 ID </em>)从外部注册表:<code class="fe mf mg mh mi b">docker.io/balazsszeti/hello:sleeper</code>中提取图像</li><li id="5917" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk nv kt ku kv bi translated">离线工作吗？<br/> 不，图像是从外部注册表中提取的。加<code class="fe mf mg mh mi b">--reference-policy=local</code>没什么区别。</li><li id="0825" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk nv kt ku kv bi translated"><strong class="jp ir">如果标签移动会发生什么？</strong> <br/>容器是从外部标签url创建的，所以标签后面的新图像总是被使用。Pod参数<code class="fe mf mg mh mi b">imagePullPolicy: Always</code>在这种情况下很重要，否则旧图像可能会被容器运行时缓存在节点上。</li><li id="4514" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk nv kt ku kv bi translated"><strong class="jp ir">该图像流可以在Pod中使用吗？</strong> <br/>不行，连<code class="fe mf mg mh mi b">lookupPolicy: {local: true}</code>都帮不上。如果设置了该标志，Pod将尝试从一个不存在的内部url: <code class="fe mf mg mh mi b">image: image-registry.openshift-image-registry.svc:5000/myproject/myimage-reference:mytag</code></li><li id="0a20" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk nv kt ku kv bi translated"><strong class="jp ir">回滚有效吗？</strong> <br/>否，因为Pod引用了外部浮动标签(而不是<em class="km"> sha256 ID </em>)。因此，在回滚后，容器将从外部注册表中提取图像的相同标记版本(例如<code class="fe mf mg mh mi b">docker.io/balazsszeti/hello:sleeper</code>)，就像我们在DeploymentConfig中使用外部图像标记而不是图像流一样。</li></ol><blockquote class="lb lc ld"><p id="f533" class="jn jo km jp b jq jr js jt ju jv jw jx le jz ka kb lf kd ke kf lg kh ki kj kk ij bi translated">在<a class="ae kl" href="https://quay.io" rel="noopener ugc nofollow" target="_blank"> Quay.io </a> public registry中，当一个新的图像被推送到一个现有的标签中时，先前的<em class="iq"> sha256 ID </em>立即失效，并且先前的图像不能再被拉取——这似乎与<a class="ae kl" href="https://hub.docker.com/" rel="noopener ugc nofollow" target="_blank"> Docker Hub </a>的情况不同。这是一个很好的例子，其中<em class="iq">穿越</em>特性可以帮助缓存我们部署的图像。</p></blockquote><h2 id="2ca2" class="lh li iq bd lj lk ll dn lm ln lo dp lp jy lq lr ls kc lt lu lv kg lw lx ly lz bi translated">内影像</h2><p id="605b" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">让我们通过在集群上运行Docker构建来创建一个映像—参见上面的示例<em class="km">Docker file</em><a class="ae kl" href="#8832" rel="noopener ugc nofollow"/>:</p><pre class="mk ml mm mn gt nn mi no np aw nq bi"><span id="49bf" class="lh li iq mi b gy nr ns l nt nu">oc new-build --to='myimage-internal:mytag' --strategy=docker --binary=true --name=myimage-internal</span><span id="af95" class="lh li iq mi b gy ny ns l nt nu">oc start-build myimage-internal --from-dir=.  --follow</span></pre><p id="6611" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="km"> yaml </em>看起来有点不一样，注意:没有<code class="fe mf mg mh mi b">spec.tags</code>:</p><pre class="mk ml mm mn gt nn mi no np aw nq bi"><span id="4735" class="lh li iq mi b gy nr ns l nt nu">$ oc get is myimage-internal -oyaml<br/>apiVersion: image.openshift.io/v1<br/>kind: ImageStream<br/>metadata:<br/>  labels:<br/>    build: myimage-internal<br/>  name: myimage-internal<br/>spec:<br/>  lookupPolicy:<br/>    local: false<br/>status:<br/>  dockerImageRepository: image-registry.openshift-image-registry.svc:5000/myproject/myimage-internal<br/>  tags:<br/>  - items:<br/>    - dockerImageReference: image-registry.openshift-image-registry.svc:5000/myproject/myimage-internal@sha256:ff3b3c5e...<br/>      image: sha256:ff3b3c5e...<br/>    tag: mytag</span></pre><p id="b16a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">又是常见的问题:</p><ol class=""><li id="09ab" class="kn ko iq jp b jq jr ju jv jy kp kc kq kg kr kk nv kt ku kv bi translated"><strong class="jp ir">Pod中的图片url是什么？<br/> </strong>图片URL将通过<em class="km">sha 256 ID</em>:<em class="km"/><code class="fe mf mg mh mi b">image-registry.openshift-image-registry.svc:5000/myproject/myimage-internal@sha256:ff3b3c5e3d09bf93e2a05ece04235f4ea8212f36b617161d8f11f374a14aeb74</code>引用内部注册表</li><li id="1fd6" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk nv kt ku kv bi translated">离线工作吗？<br/>T37】是的。图像在内部注册表中。</li><li id="842e" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk nv kt ku kv bi translated"><strong class="jp ir">如果标签移动会发生什么？</strong> <br/>图像流和内部图像保持同步，因此新的构建(或推送)也会更新标签。卷展栏将始终创建一个包含最新图像的窗格。</li><li id="2300" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk nv kt ku kv bi translated"><strong class="jp ir">该图像流可以在Pod中使用吗？</strong> <br/>是，设定<code class="fe mf mg mh mi b">lookupPolicy: {local: true}</code>后。</li><li id="f524" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk nv kt ku kv bi translated"><strong class="jp ir">回滚有效吗？</strong> <br/>是的。只要图像没有从内部注册表中删除。</li></ol><blockquote class="lb lc ld"><p id="c76d" class="jn jo km jp b jq jr js jt ju jv jw jx le jz ka kb lf kd ke kf lg kh ki kj kk ij bi translated">注意:在上面的例子中，我们为每种类型使用了不同的ImageStream，但是通过在一个ImageStream中使用不同的标签也可以达到同样的效果。</p></blockquote><h2 id="611c" class="lh li iq bd lj lk ll dn lm ln lo dp lp jy lq lr ls kc lt lu lv kg lw lx ly lz bi translated">引用另一个图像流</h2><p id="77f9" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">一个ImageStream也可以从另一个ImageStream创建，新标签的图像url设置在源标签当时指向的位置。新的图像流不会自动跟随旧的图像流(在这种情况下，您不能设置<code class="fe mf mg mh mi b">--scheduled=true</code>)。其他属性(<code class="fe mf mg mh mi b">referencePolicy</code>、<code class="fe mf mg mh mi b">reference</code>、<code class="fe mf mg mh mi b">lookupPolicy</code>、…)也不会被接管。新的ImageStream在创建/更新时采用源ImageStream的图像的<em class="km"> sha256 ID </em>,并且之后独立。</p><p id="c09f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从另一个图像流创建新图像流的最常见用例是用于内部存储的图像，因为这对于外部图像来说意义不大。例如，如果我们有一个由<em class="km"> git挂钩触发的自动构建，</em>在“开发”、“测试”或“生产”名称空间中标记图像流可以触发DeploymentConfig，我们不需要做太多其他事情就可以拥有一个基本的CI/CD流程。但是这个话题绝对超出了这篇已经很长的文章的范围。</p><p id="e172" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们基于源图像流的类型和不同的参数来检查图像url看起来如何——当从我们的新图像流创建pod时。</p><blockquote class="lb lc ld"><p id="ffbe" class="jn jo km jp b jq jr js jt ju jv jw jx le jz ka kb lf kd ke kf lg kh ki kj kk ij bi translated">这最后一节只是为了涵盖所有场景。我们通常不使用这些边缘情况——除了在另一个名称空间中创建简单的“克隆”标签。</p></blockquote><p id="0d92" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">旧图像流指向外部图像:</strong></p><pre class="mk ml mm mn gt nn mi no np aw nq bi"><span id="c595" class="lh li iq mi b gy nr ns l nt nu">oc tag myproject/myimage-ref-source:mytag myproject/fromis-ref-source-myimage-ref-source:mytag<br/>  --&gt; Pod image: docker.io/balazsszeti/hello@sha256:42957024...</span><span id="8b43" class="lh li iq mi b gy ny ns l nt nu">oc tag myproject/myimage-ref-source:mytag myproject/fromis-reference-myimage-ref-source:mytag <strong class="mi ir">--reference=true</strong><br/>  --&gt; Pod image: docker.io/balazsszeti/hello@sha256:42957024...</span><span id="530b" class="lh li iq mi b gy ny ns l nt nu">oc tag myproject/myimage-ref-source:mytag myproject/fromis-ref-local-myimage-ref-source:mytag <strong class="mi ir">--reference-policy=local</strong> <br/>  --&gt; Pod image: image-registry.openshift-image-registry.svc:5000/myproject/fromis-ref-local-myimage-ref-source@sha256:42957024...</span></pre><p id="7fa0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所有三个<em class="km"> yaml </em>变体看起来都很相似:</p><pre class="mk ml mm mn gt nn mi no np aw nq bi"><span id="270e" class="lh li iq mi b gy nr ns l nt nu">$ oc get is -o yaml fromis-ref-source-myimage-ref-source<br/>apiVersion: image.openshift.io/v1<br/>kind: ImageStream<br/>metadata:<br/>  name: fromis-ref-source-myimage-ref-source<br/>spec:<br/>  tags:<br/><strong class="mi ir">  - from:<br/>      kind: ImageStreamImage<br/>      name: myimage-ref-source@sha256:42957024...<br/>      namespace: myproject</strong><br/>    name: mytag<br/>status:<br/>  dockerImageRepository: image-registry.openshift-image-registry.svc:5000/myproject/fromis-ref-source-myimage-ref-source<br/>  tags:<br/>  - items:<br/>    - dockerImageReference: docker.io/balazsszeti/hello@sha256:42957024...<br/>      image: sha256:42957024...<br/>    tag: mytag</span></pre><p id="c8ef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">旧图像流指向带有拉通的外部图像:</strong></p><pre class="mk ml mm mn gt nn mi no np aw nq bi"><span id="1dd4" class="lh li iq mi b gy nr ns l nt nu">oc tag myproject/myimage-ref-local:mytag myproject/fromis-ref-source-myimage-ref-local:mytag<br/>  --&gt; Pod image: docker.io/balazsszeti/hello@sha256:42957024...</span><span id="6f79" class="lh li iq mi b gy ny ns l nt nu">oc tag myproject/myimage-ref-local:mytag myproject/fromis-reference-myimage-ref-local:mytag <strong class="mi ir">--reference=true</strong><br/>  --&gt; Pod image: docker.io/balazsszeti/hello@sha256:42957024...</span><span id="4614" class="lh li iq mi b gy ny ns l nt nu">oc tag myproject/myimage-ref-local:mytag myproject/fromis-ref-local-myimage-ref-local:mytag <strong class="mi ir">--reference-policy=local</strong><br/>  --&gt; Pod image: image-registry.openshift-image-registry.svc:5000/myproject/fromis-ref-local-myimage-ref-local@sha256:42957024...</span></pre><p id="aa7a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">与从非直通图像流进行标记相比，没有区别。</p><p id="a839" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">旧图像流是外部参考:</strong></p><pre class="mk ml mm mn gt nn mi no np aw nq bi"><span id="8428" class="lh li iq mi b gy nr ns l nt nu">oc tag myproject/myimage-reference:mytag myproject/fromis-ref-source-myimage-reference:mytag<br/>  --&gt; Pod image: docker.io/balazsszeti/hello@sha256:42957024...</span><span id="8744" class="lh li iq mi b gy ny ns l nt nu">oc tag myproject/myimage-reference:mytag myproject/fromis-reference-myimage-reference:mytag <strong class="mi ir">--reference=true</strong><br/>  --&gt; Pod image: docker.io/balazsszeti/hello:sleeper</span><span id="8043" class="lh li iq mi b gy ny ns l nt nu">oc tag myproject/myimage-reference:mytag myproject/fromis-ref-local-myimage-reference:mytag <strong class="mi ir">--reference-policy=local</strong><br/>  --&gt; Pod image: image-registry.openshift-image-registry.svc:5000/myproject/fromis-ref-local-myimage-reference@sha256:42957024...</span></pre><p id="71e1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们标记的源图像流是<code class="fe mf mg mh mi b">--reference=true</code>，新的图像流定义看起来与其他情况不同。这里标签的种类是<code class="fe mf mg mh mi b">DockerImage</code>，没有迹象表明这是从另一个图像流创建的。</p><pre class="mk ml mm mn gt nn mi no np aw nq bi"><span id="cd9c" class="lh li iq mi b gy nr ns l nt nu">$ oc get is -oyaml fromis-ref-source-myimage-reference<br/>apiVersion: image.openshift.io/v1<br/>kind: ImageStream<br/>metadata:<br/>  name: fromis-ref-source-myimage-reference<br/>spec:<br/>  tags:<br/><strong class="mi ir">  - from:<br/>      kind: DockerImage<br/>      name: docker.io/balazsszeti/hello:sleeper</strong><br/>    name: mytag<br/>status:<br/>  dockerImageRepository: image-registry.openshift-image-registry.svc:5000/myproject/fromis-ref-source-myimage-reference<br/>  tags:<br/>  - items:<br/>    - dockerImageReference: docker.io/balazsszeti/hello@sha256:42957024...<br/>      image: sha256:42957024...<br/>    tag: mytag</span></pre><p id="b98a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">旧图像流指向内部图像:</strong></p><p id="2e84" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如上所述，在不同的名称空间之间标记内部图像是很常见的。在这种情况下，似乎有一些特殊的逻辑来像处理<code class="fe mf mg mh mi b">--reference-policy=local</code>一样处理<code class="fe mf mg mh mi b">--reference-policy=source</code>，以避免名称空间之间的权限问题:</p><pre class="mk ml mm mn gt nn mi no np aw nq bi"><span id="dc4b" class="lh li iq mi b gy nr ns l nt nu">oc tag myproject/myimage-internal:mytag myproject/fromis-ref-source-myimage-internal:mytag<br/>  --&gt; Pod image: image-registry.openshift-image-registry.svc:5000/myproject/<strong class="mi ir">fromis-ref-source-myimage-internal</strong>@sha256:ff3b3c5e...</span><span id="c472" class="lh li iq mi b gy ny ns l nt nu">oc tag myproject/myimage-internal:mytag myproject/fromis-reference-myimage-internal:mytag <strong class="mi ir">--reference=true</strong><br/>  --&gt; Pod image: image-registry.openshift-image-registry.svc:5000/myproject/myimage-internal@sha256:ff3b3c5e...</span><span id="a8d5" class="lh li iq mi b gy ny ns l nt nu">oc tag myproject/myimage-internal:mytag myproject/fromis-ref-local-myimage-internal:mytag <strong class="mi ir">--reference-policy=local</strong><br/>  --&gt; Pod image: image-registry.openshift-image-registry.svc:5000/myproject/fromis-ref-local-myimage-internal@sha256:ff3b3c5e...</span></pre><p id="f59d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">ImageStream <em class="km"> yaml </em>看起来是这样的:</p><pre class="mk ml mm mn gt nn mi no np aw nq bi"><span id="c289" class="lh li iq mi b gy nr ns l nt nu">$ oc get is -oyaml fromis-ref-source-myimage-internal<br/>apiVersion: image.openshift.io/v1<br/>kind: ImageStream<br/>metadata:<br/>  name: fromis-ref-source-myimage-internal<br/>spec:<br/>  tags:<br/><strong class="mi ir">  - from:<br/>      kind: ImageStreamImage<br/>      name: myimage-internal@sha256:ff3b3c5e...<br/>      namespace: myproject</strong><br/>    name: mytag<br/>status:<br/>  dockerImageRepository: image-registry.openshift-image-registry.svc:5000/myproject/fromis-ref-source-myimage-internal<br/>  tags:<br/>  - items:<br/>    - dockerImageReference: image-registry.openshift-image-registry.svc:5000/myproject/fromis-ref-source-myimage-internal@sha256:ff3b3c5e...<br/>      image: sha256:ff3b3c5e...<br/>    tag: mytag</span></pre><h1 id="c839" class="mw li iq bd lj mx my mz lm na nb nc lp nd ne nf ls ng nh ni lv nj nk nl ly nm bi translated">摘要</h1><p id="b43f" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">ImageStreams是管理存储在OpenShift内部注册表中的图像的一种很好的方式，但是当它们指向外部URL时，一些参数可能会令人困惑。OpenShift 4的发布和日益流行给了我们一个很好的理由来做一个全面的概述，并检查当在部署中使用ImageStream标签时，它们是如何被解析为实际的容器图像url的。希望这有助于回答您在设计自己的映像管理策略时可能遇到的一些问题。</p></div></div>    
</body>
</html>