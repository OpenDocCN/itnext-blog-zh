<html>
<head>
<title>Techniques for Optimising SQL Queries</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">优化SQL查询的技术</h1>
<blockquote>原文：<a href="https://itnext.io/techniques-for-optimising-sql-queries-c362dbe626b4?source=collection_archive---------0-----------------------#2022-11-13">https://itnext.io/techniques-for-optimising-sql-queries-c362dbe626b4?source=collection_archive---------0-----------------------#2022-11-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/7a22efbc6624b5c211b60b35a1caf5ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IOupJk-yndymZusZiIjHuw.png"/></div></div></figure><p id="b7ba" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">众所周知，SQL数据库是当今使用最多的数据库之一。它们可以在不同的用例中使用，从简单的新闻订阅数据库这样的小型应用程序到用于数据分析的大型数据库。</p><p id="14d0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">由于这种使用的灵活性，数据库越大，如果我们不在数据库的表中进行相应的优化，查询就会越慢。</p><p id="ea5a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这里，我们将列出并快速介绍如何实现这一点的技术和方法，从最简单的开始，如优化查询，到繁重的内容，如表分区。</p><h2 id="c8b8" class="kz la it bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated">1.解释的力量</h2><p id="c155" class="pw-post-body-paragraph kb kc it kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">这个关键字将给出我们的查询将做什么的详细信息，以及在执行时将花费多少时间。</p><p id="417a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">根据我们使用的SQL数据库，它将提供额外的信息，如我们正在尝试执行什么类型的查询，我们是否有连接，我们使用什么键来过滤，我们期望的结果行数等等。</p><p id="800b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这篇<a class="ae lx" href="https://medium.com/random-life-journal/explain-sql-command-in-postgresql-6b0d50c7bd9a" rel="noopener"> <strong class="kd iu">文章中</strong> </a> <strong class="kd iu"> </strong>出自<a class="ly lz ep" href="https://medium.com/u/edcc77054fcb?source=post_page-----c362dbe626b4--------------------------------" rel="noopener" target="_blank">雨武</a>我们举几个例子来说明一个PostgreSQL数据库。</p><h2 id="f756" class="kz la it bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated">2.停止循环运行查询</h2><p id="0618" class="pw-post-body-paragraph kb kc it kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">这是我见过的许多人犯的最常见的错误之一，不管他们的经验水平如何，也不管他们在这个行业有多少年。</p><p id="79ff" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这样做确实很有诱惑力，因为它的简单性和加速一个特性的交付。考虑一个合适的SQL查询需要更多的时间，这样我们就不必循环运行它了。</p><p id="2896" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">例如，我们有一个用户表和一个地址表。地址表中有用户id。我们需要找到某个用户的地址来执行一些操作。</p><p id="4c57" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最简单和直观的方法是使用两个查询，一个获取用户，遍历用户并对用户数据执行一些操作，直到我们意识到我们也需要地址，并且本能地开始在循环中编写地址查询，而没有意识到这一点。有两种可能的解决方案比这个更好。</p><ul class=""><li id="7c88" class="ma mb it kd b ke kf ki kj km mc kq md ku me ky mf mg mh mi bi translated">首先，运行第一个查询来获取所有用户数据，从结果集中过滤出用户id，然后运行地址查询，条件是表中的用户id字段与我们从第一个查询中获取的一个id相匹配。</li><li id="4e87" class="ma mb it kd b ke mj ki mk km ml kq mm ku mn ky mf mg mh mi bi translated">第二种也是最好的方法是执行一个<code class="fe mo mp mq mr b">JOIN</code>并从两个表中获取数据。这样，我们只执行一个查询，就拥有了我们需要的所有数据。</li></ul><h2 id="8edd" class="kz la it bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated">3.仅选择您需要的字段</h2><p id="1998" class="pw-post-body-paragraph kb kc it kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">另一个常见的问题是，我们不考虑哪些数据是我们需要的，哪些是我们不需要的，所以我们所做的是编写一个<code class="fe mo mp mq mr b">SELECT * …</code>查询。</p><p id="63aa" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">根据上面的例子，假设我们只需要用户的全名、街道、邮政编码和城市。我们的查询应该是这样的，带有一个内部连接，因为我们需要基于条件的两个表的交集</p><pre class="ms mt mu mv gt mw mr mx bn my mz bi"><span id="46e3" class="na la it mr b be nb nc l nd ne">SELECT u.firstname, u.lastname, a.street, a.zipcode, a.city <br/>  FROM user u <br/>  INNER JOIN address a<br/>WHERE a.userid = u.id</span></pre><p id="0a36" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这样我们就不会增加结果集的开销，并且我们只处理我们需要的数据。</p><h2 id="4049" class="kz la it bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated">4.避免在内部联接中使用WHERE</h2><p id="c34a" class="pw-post-body-paragraph kb kc it kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">从上面的查询中，我们还注意到在连接两个表时使用了过滤。连接时使用<code class="fe mo mp mq mr b">ON</code>过滤器，而不是使用<code class="fe mo mp mq mr b">WHERE</code>子句。</p><pre class="ms mt mu mv gt mw mr mx bn my mz bi"><span id="5877" class="na la it mr b be nb nc l nd ne">SELECT u.firstname, u.lastname, a.street, a.zipcode, a.city <br/>FROM user u <br/>INNER JOIN address a ON a.userid = u.id</span></pre><h2 id="4b7d" class="kz la it bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated">5.用WHERE代替have</h2><p id="989c" class="pw-post-body-paragraph kb kc it kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">WHERE和HAVING子句之间的主要区别在于，WHERE在任何分组之前被处理，并且不能访问聚合值，如<code class="fe mo mp mq mr b">max</code>、<code class="fe mo mp mq mr b">min</code>函数等等。另一方面，HAVING是在分组后处理的，这会降低查询速度，降低查询性能，因为我们需要处理更多的记录。</p><p id="b102" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">简单来说，<strong class="kd iu"> WHERE用于分组前筛选行，HAVING用于分组后排除记录</strong>。</p><h2 id="cc0b" class="kz la it bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated">6.使用有利于子查询的连接</h2><p id="4f9d" class="pw-post-body-paragraph kb kc it kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">虽然子查询更容易编写和理解，但它们会使查询变得冗长、不可读、难以维护且性能较低。</p><p id="a59d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在某些情况下，子查询是首选的，也是鼓励使用的，比如在返回聚合值的where子句中。</p><pre class="ms mt mu mv gt mw mr mx bn my mz bi"><span id="677f" class="na la it mr b be nb nc l nd ne">SELECT name FROM product<br/>WHERE cost&lt;(SELECT AVG(price) from sale);</span></pre><p id="b177" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">或者在FROM子句中使用group by。</p><pre class="ms mt mu mv gt mw mr mx bn my mz bi"><span id="3878" class="na la it mr b be nb nc l nd ne">SELECT city, sum_price <br/> FROM <br/>(<br/>  SELECT city, SUM(price) AS sum_price FROM sale<br/>  GROUP BY city<br/>) AS s<br/>WHERE sum_price &lt; 2100;</span></pre><h2 id="7938" class="kz la it bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated">7.避免使用SELECT DISTINCT</h2><p id="dbac" class="pw-post-body-paragraph kb kc it kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">就性能而言，该子句的代价非常高，因为它必须检查所有数据集以确保没有重复。它逐行扫描数据集，当发现一个重复时就删除它。</p><p id="57e3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这个过程会增加CPU和内存的使用。</p><p id="b121" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">要获得更详细的解释，我鼓励你阅读这篇详细的<a class="ae lx" href="https://jmarquesdatabeyond.medium.com/sql-like-a-pro-please-stop-using-distinct-31bdb6481256" rel="noopener"> <strong class="kd iu">文章</strong> </a>来自<a class="ly lz ep" href="https://medium.com/u/1afd200bdabf?source=post_page-----c362dbe626b4--------------------------------" rel="noopener" target="_blank">Joao Marques @ Data Beyond Ltd</a>关于DISTINCT子句。</p><h2 id="0bd4" class="kz la it bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated">8.使用EXISTS()代替COUNT()</h2><p id="116e" class="pw-post-body-paragraph kb kc it kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">使用EXISTS关键字执行存在性检查几乎总是比使用COUNT(*)快。</p><p id="ec43" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">只要逻辑测试证明为真，EXISTS就可以停止，但是COUNT(*)必须对每一行进行计数，即使它知道有一行通过了测试。</p><p id="feb5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下面简单介绍一下<a class="ae lx" href="https://mattsuyolo.medium.com/choose-exists-rather-than-count-61476b702919" rel="noopener"> <strong class="kd iu">基准</strong> </a>来自<a class="ly lz ep" href="https://medium.com/u/c80a8ac50fa0?source=post_page-----c362dbe626b4--------------------------------" rel="noopener" target="_blank"> Mattsuyolo </a>这两个关键词。</p><h2 id="a601" class="kz la it bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated">9.利用索引</h2><p id="98de" class="pw-post-body-paragraph kb kc it kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">索引是SQL中最重要的性能因素之一。它通过提供对所请求数据的快速访问(称为索引查找操作)来帮助加速查询，而不是扫描整个表来检索几条记录。</p><p id="3110" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">它有一些缺点，因为需要额外的磁盘空间，并且通过插入、更新和删除进行的数据修改会变慢。</p><p id="ab3e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这就是为什么我们需要特别注意在必要时只在我们需要的列上使用它，并删除未使用的索引。</p><p id="806b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在Kousik Nath的文章中，我们对它的工作原理有详细的解释。</p><h2 id="37ed" class="kz la it bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated">10.使用聚集索引进行数据修剪</h2><p id="8534" class="pw-post-body-paragraph kb kc it kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">数据修剪是查询引擎用来确保查询只扫描与WHERE子句提供的条件相匹配的行的技术。</p><p id="4cce" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">聚集索引是数据中行的顺序与索引中行的顺序相对应的索引。它提供了对数据的线性访问。聚集索引的一个例子是可以由一列或多列组成的主索引。</p><p id="0036" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">更详细的解释可以在火弩箭博客<a class="ly lz ep" href="https://medium.com/u/7664a035848d?source=post_page-----c362dbe626b4--------------------------------" rel="noopener" target="_blank"> Octavian Zarzu </a>的<code class="fe mo mp mq mr b"><a class="ae lx" href="https://www.firebolt.io/blog/firebolt-indexes-in-action" rel="noopener ugc nofollow" target="_blank"><strong class="kd iu">Indexes in Action</strong></a></code>博文中找到。</p><figure class="ms mt mu mv gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nf"><img src="../Images/a48f43f38306d70be8fdc0b81d838171.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ru3PSM1l3U575n2QvstDjg.jpeg"/></div></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk translated">聚集索引与非聚集索引</figcaption></figure><h2 id="816e" class="kz la it bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated">11.使用JSON/ARRAY列和LAMBDA</h2><p id="1aea" class="pw-post-body-paragraph kb kc it kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">使用这种技术，我们试图最小化表的数量，因此，也最小化连接的数量，只使用一个具有数组或JSON列的表，以结构化的方式包含我们的数据。</p><p id="6d8d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">例如，我们有一个产品表和一个产品价格表，其中记录了每天的产品价格。我们可以想象，这些桌子的尺寸会增加很多。</p><p id="ee17" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这种情况下，我们可以做的是只有一个产品表，其中有两列作为数组，一列存储日期，另一列存储价格，其中日期索引与价格索引相匹配。</p><figure class="ms mt mu mv gt ju gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/12969e5582d9b2c20616654ed4e43c6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:790/format:webp/1*a5EkHvYz94Og9O-bwx_MGQ.jpeg"/></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk translated">合并表结果</figcaption></figure><p id="0b54" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在本例中，为了根据日期对产品价格进行升序排序，我们使用了一个名为<code class="fe mo mp mq mr b">ARRAY_SORT</code>的SQL Lambda函数</p><p id="d9f4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">同样的方法也用于JSON列，其中数据存储为一个键值对JSON对象。</p><p id="a1bd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了更好地理解SQL中的Lambdas，我鼓励阅读Firebolt博客中由<a class="ly lz ep" href="https://medium.com/u/7664a035848d?source=post_page-----c362dbe626b4--------------------------------" rel="noopener" target="_blank"> Octavian Zarzu </a>撰写的<code class="fe mo mp mq mr b"><a class="ae lx" href="https://www.firebolt.io/blog/sql-thinking-in-lambdas" rel="noopener ugc nofollow" target="_blank"><strong class="kd iu">SQL: Thinking in Lambdas</strong></a></code>博客文章，并观看下面的视频<a class="ly lz ep" href="https://medium.com/u/57fe71010707?source=post_page-----c362dbe626b4--------------------------------" rel="noopener" target="_blank"> Matan Sarig </a>，他是Firebolt的解决方案架构师团队领导。</p><figure class="ms mt mu mv gt ju"><div class="bz fp l di"><div class="nl nm l"/></div></figure><h2 id="01b0" class="kz la it bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated">12.表分区/减小表的大小</h2><p id="fd57" class="pw-post-body-paragraph kb kc it kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">这是另一个非常重要的技术，它包括将数据库表分割成多个称为分区的部分，然后我们可以分别查询每个分区。</p><p id="26b1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们的查询将变得更高效，因为我们将查询记录更少的整个表的一小部分。</p><p id="b91d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为此，您可以阅读我的<a class="ae lx" href="https://albionbame.medium.com/mysql-caching-and-table-partitioning-c65d7010216e" rel="noopener"> SQL缓存和表分区</a>文章。</p></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><p id="7fe0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">希望你觉得这些信息有用，并随时让我知道你的想法。</p><p id="37a1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果您想与我联系，您可以关注或联系我的任何社交网站，或者通过我的<a class="ae lx" href="https://abame.github.io/" rel="noopener ugc nofollow" target="_blank">个人网站</a>上的联系方式。</p></div></div>    
</body>
</html>