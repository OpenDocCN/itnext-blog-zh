<html>
<head>
<title>DockerHub to Google Cloud Run</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">DockerHub到谷歌云运行</h1>
<blockquote>原文：<a href="https://itnext.io/running-any-container-on-cloudrun-cca137cddbca?source=collection_archive---------2-----------------------#2019-05-31">https://itnext.io/running-any-container-on-cloudrun-cca137cddbca?source=collection_archive---------2-----------------------#2019-05-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/5cf7a21e2283c83cf3ea159db73906b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZVOBM3MhqOncXKKwBRFmQg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">直冲云端</figcaption></figure><p id="6edb" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在听说它的一分钟后，我不得不尝试Google CloudRun out，结果发现它有一个小怪癖:它要求您的服务器侦听＄{ PORT }环境变量中定义的特定端口。“粮草！如何运行我刚刚从Docker-Hub上下载的容器，没有修改的理由！?"，不要评价我，作为这个同步世界的公民，我有天赐的权利可以极度懒惰！毕竟，我如此喜欢CloudRun的原因是因为它让我变得懒惰…</p><p id="2b8f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">言归正传:</strong>我有一些想要运行的docker映像，它知道如何监听某个端口，该端口可以在某个配置文件或命令行参数中进行配置，但它绝对不知道google注入到容器env中的＄{ PORT }参数。</p><p id="8b9a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">对原始docker文件的一点观察表明它是从一些Debian风格(debian-slim，ubuntu等)开始的。)所以我有apt get，你可能需要用yam或者apk取决于发行版。</p><p id="f8e8" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">我的计划:</strong></p><ol class=""><li id="f5fe" class="la lb iq ke b kf kg kj kk kn lc kr ld kv le kz lf lg lh li bi translated">从我的目标容器开始</li><li id="9bc4" class="la lb iq ke b kf lj kj lk kn ll kr lm kv ln kz lf lg lh li bi translated">安装nginx</li><li id="05f9" class="la lb iq ke b kf lj kj lk kn ll kr lm kv ln kz lf lg lh li bi translated">更改nginx配置以监听{PORT}</li><li id="2c12" class="la lb iq ke b kf lj kj lk kn ll kr lm kv ln kz lf lg lh li bi translated">配置nginx，将流量路由到原始服务器的默认端口</li><li id="e2dd" class="la lb iq ke b kf lj kj lk kn ll kr lm kv ln kz lf lg lh li bi translated">在CloudRun上启动它，并在几秒钟内获得可扩展的云服务</li></ol><p id="22e5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">你可能已经注意到一个小问题</strong> : nginx不知道如何监听env变量提供的动态端口号，不要担心，我们将在我们的容器运行脚本中使用一个小的<strong class="ke ir"> sed命令</strong>来替换运行它之前nginx配置中的端口，以及原始的服务器进程。</p><p id="5274" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">下面是我们的nginx配置。一个基本服务器，在端口$NGINX_PORT上有一个监听器(在容器运行时由sed脚本替换)，以及一个proxy_pass命令，用于将所有内容发送到原始服务器端口(此处为8042):</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="98d0" class="lx ly iq lt b gy lz ma l mb mc">worker_processes 1;<br/>events { worker_connections 1024; }<br/>http {<br/>  server {<br/>    listen $NGINX_PORT;<br/>    location / {<br/>      proxy_pass <a class="ae md" href="http://127.0.0.1:8042" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:8042</a>;<br/>      proxy_redirect off;<br/>    }<br/>  }<br/>}</span></pre><p id="12db" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">dockerfile只是按照计划，从原始映像开始，安装nginx并对其进行配置，然后运行一个脚本，该脚本将用${PORT}替换nginx监听端口，并运行所有需要的进程。</p><p id="36ba" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">请注意带有<strong class="ke ir"> "Entrypoint []" </strong>的那一行，因为它删除了原始的入口点，消除了在容器而不是我们的脚本中启动的原始流程的错误或问题。</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="0904" class="lx ly iq lt b gy lz ma l mb mc">FROM jodogne/orthanc-plugins</span><span id="c140" class="lx ly iq lt b gy me ma l mb mc">RUN apt-get update &amp;&amp; apt-get install -y \<br/>    nginx</span><span id="962f" class="lx ly iq lt b gy me ma l mb mc">RUN rm -rf /etc/nginx/nginx.conf<br/>ADD nginx.conf /etc/nginx/nginx.conf<br/>ADD run_nginx.sh ./run_nginx.sh</span><span id="71d3" class="lx ly iq lt b gy me ma l mb mc">ENTRYPOINT []</span><span id="b1ab" class="lx ly iq lt b gy me ma l mb mc">CMD ["bash", "./run_nginx.sh"]</span></pre><p id="ce9d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我现在需要从我的原始容器中得到的唯一东西是获取它的原始CMD(或端点),并把它作为我的run_nginx shell文件启动的最后一个进程。</p><p id="252f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">下面是我的nginx_run.sh文件，</strong>它用“sed”替换端口，作为后台进程启动nginx，然后作为容器的主进程运行原来的服务器。如果你有任何问题，首先检查你的nginx_run.sh文件中是否有[CR][LF]，把它们改成[LF]，这样linux/bash就不会发疯了…</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="b0f7" class="lx ly iq lt b gy lz ma l mb mc">sed -i "s/\$NGINX_PORT/${PORT}/g" /etc/nginx/nginx.conf<br/>exec "/usr/sbin/nginx" -c "/etc/nginx/nginx.conf" -g "daemon off;" &amp;<br/>exec "/usr/local/sbin/Orthanc"</span></pre><p id="ee37" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在我需要做的就是构建docker，标记它并将其推送到一个google cloud registry (CloudRun不支持其他注册表)，并通过选择docker映像和启用一个公共URL在CloudRun控制台中设置服务。可选地，您还可以提供想要注入到容器中的任何env变量，并更改内存限制和超时。</p><figure class="lo lp lq lr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mf"><img src="../Images/7810002be9782ec6fa931918cae0bd32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oWVmQqgcES0kadNn4fIp8Q.png"/></div></div></figure><p id="e6d4" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">现在按“部署”,一分钟后，通过调用其Url检查服务是否启动并运行。</strong>这项新服务现在是一项完全可扩展的服务，因为每当遇到高流量时，google都会运行额外的容器，这是通过检查设置中每个容器的最大并发请求数来实现的(目前，80是允许的最高设置)。只有当至少有一个请求处于活动状态时，才会对容器进行计费，因此一个没有被访问的运行中的容器绝对不会产生任何成本。</p><p id="5005" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">希望这有助于你使用这个非常好的Goolge云服务，是时候让容器变得比ECS/GKE/EKS更容易使用了，一旦你克服了CoudRun的单一粗糙点，它就会像纯粹的魔法一样运行你的容器。<strong class="ke ir">我必须祝贺谷歌云团队</strong>战胜了AWS，AWS仍然是我在大多数情况下首选的云提供商。</p></div></div>    
</body>
</html>