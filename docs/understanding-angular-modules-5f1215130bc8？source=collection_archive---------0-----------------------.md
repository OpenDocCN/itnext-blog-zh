# 了解角度模块

> 原文：<https://itnext.io/understanding-angular-modules-5f1215130bc8?source=collection_archive---------0----------------------->

## 理解不同类型角度模块的快速而全面的指南

![](img/28b047a77c46684a8edf4732c6af13d6.png)

理解不同类型的 [Angular 模块](https://angular.io/guide/module-types)是设计或重构应用程序的关键因素。

角度模块的概念已经成熟，因为它们是在一个较晚的 RC 版本中首次引入框架的。

但是随着时间的推移，Angular 团队和社区都提出了指导方针，解释了不同类型的模块是什么，以及它们的用途。

# 角度模块的剖析

角度模块由一组简单的属性和一个生命周期挂钩组成。为了充分理解模块，我们想首先检查每个属性以及它们的用途。

让我们来概述一下 *NgModule* 接口:

## 声明

也许是最简单和最常用的属性，我们使用*声明*数组来导入*组件*、*指令、*和*管道*。

## 提供者

另一个众所周知的属性，我们使用数组提供者来定义已经用*可注入的*装饰器来装饰的服务，这使得它们可以通过 Angular DI 来访问。

## 进口

我们使用 *imports* 数组来导入其他模块。

## 出口

默认情况下，模块中定义的所有东西都是私有的*。Exports* 是一个数组，它允许声明和一个模块中的声明可以从模块中访问，这些模块导入定义这些声明的模块。

## 入口组件

EntryComponents 指定模块引导时编译的组件列表。这些组件不是模板中定义的组件，而是通常强制加载的，例如使用*viewcontainerref . create component()。*

一个例子是路由组件，但是框架会自动将它们添加到 *entryComponents* 中。

## 引导程序

Bootstrap 还指定模块引导时编译的组件，并自动将它们添加到 *entryComponents。*

## 身份

标识模块的名称

## 计划

该属性的允许值是 NO_ERRORS_SCHEMA 或 CUSTOM_ELEMENTS_SCHEMA，例如，在使用 web 组件时，您可能会用到这两个值。

我建议小心使用它，因为您可能没有定义的组件不会抛出错误。

当您不想测试模块中没有定义的组件时，通常可以使用它进行测试。但是要知道编译器实际上跳过了什么。

## 吉特舞乐

这个属性将使框架总是使用 JIT 而不是 AOT 编译模块。

在我们开始深入了解每一个模块之前，我们先假设有 5 种不同类型的模块:

*   领域模块
*   路由模块
*   路由模块
*   服务模块
*   小部件模块

对此，我觉得我们还需要提到 3 个*额外的*模块 *: AppModule、AppServerModule、*和 *SharedModule* 。

# AppModule

让我们从您将看到的最常见的模块开始，即所谓的 *AppModule* 。

AppModule 通常也称为根模块，是负责引导整个应用程序的模块，这意味着我们需要将运行应用程序所需的所有模块和提供程序导入到 AppModule 中。

该模块通常会导入核心角模块、共享模块、域模块、服务模块和*approving 模块*(后面会介绍的根路由模块)。

此外，它引导根组件，通常称为 *AppComponent* 。

记住，任何可以延迟加载的东西都不应该被导入到这个模块中。这意味着——如果我们只需要一个包含在延迟加载路由的模块中的服务，**我们只在那个路由的模块**中导入它。

## 清单

*   仅声明和引导根组件(必需)
*   导入其他模块(角度模块、域模块、*共享模块*)
*   可以声明提供程序
*   不导出任何内容

# AppServerModule

只有在应用程序使用服务器端呈现时，才使用 AppServerModule。

我会称它为 *AppModule、*的服务器副本，但是 [Angular 文档](https://angular.io/guide/universal)可能对它有更好的定义:

> 它是通用服务器端渲染器和角度应用程序之间的桥梁。

# 共享模块

一个 *SharedModule* 是一个负责托管所有共享实体的模块，这些实体将被提供给应用程序的每个模块。

一个*共享模块*通常由项目内不同模块间共享的实体组成——但在项目外通常不需要。

理解什么应该构建在 SharedModule 中，什么应该构建在库中是很重要的:当你发现服务或组件可以在不同的团队和项目中重用，并且理想情况下不会经常改变时，你可能想要构建一个 *Angular 库*而不是在本地托管你的文件。

*共享模块*通常由*应用模块*导入。

关于这一点的更深入的解释可以在我之前关于[创建企业级项目结构](/building-an-enterprise-grade-angular-project-structure-f5be32533ba3)的文章中找到。

# 领域模块

领域模块是应用程序的模块附属特性。例如，电子商务应用程序可能包含以下领域模块:

*   购物车—导出*购物车.组件. ts*
*   检出-导出*检出.组件. ts*
*   产品详细视图—导出*产品详细视图.组件. ts*

根据模块的复杂性(由您来评估)，一个域模块可以被分解成更小的域模块。

例如，产品细节视图模块可以导入更小的模块，如产品评论、产品描述或产品评论。

当每个模块都是复杂的组件集合时，或者如果您认为将来某个组件会越来越复杂时，这确实有意义。

## 清单

域模块:

*   仅导出顶部组件
*   很少声明提供程序
*   可以由 AppModule 或其他域模块导入

# 路由模块

路由模块负责声明域模块(包括 AppModule)的路由，将配置传递给模块，以及定义防护和解析器服务。这还包括引用将加载惰性加载路由的模块，我们将在下一节中展示这些模块。

让我们看一个配置文件页面域模块的路由模块示例:

批准模块和子路由模块之间的区别:

*   AppRoutingModule 将使用 RouterModule 上的属性定义路由，而所有其他模块应该使用属性*定义子模块。*正如你在上面的例子*中看到的，我们使用 forChild*

## 清单

路由模块:

*   为根或子导入带有*的路由配置*
*   可以将解析器和防护器声明为提供者，而不是任何其他服务
*   总是导出 *RouterModule*
*   不要申报任何东西

# 路由模块

路由模块被非常简单地定义为托管惰性加载路由的模块，这些模块被由*域模块*或*应用模块*导入的*路由模块*引用。让我们看一个简单的例子:

我们首先为延迟加载的 route *ProfilePage* 定义一个路由模块，称为 *ProfilePageModule:*

然后我们引用(而不是导入)模块*中的 profile page module approach module*:

始终确保模块的路径是正确的，并且模块的名称与路径中引用的名称完全相同。此外，注意扩展:正如您在上面的例子中看到的，它被省略了。

## 清单

路由模块:

*   可以声明组件、管道和指令
*   很少声明提供者
*   输出*路由器模块*
*   从不进口！导入不会让它懒加载。相反，它被相对路由模块引用

# 服务模块

顾名思义，服务模块是只定义服务的模块。最好的例子是 *HttpClientModule。*

它们通常在各种情况下都很有用:

*   仅处理逻辑，而不引用 UI，这导致了可被不同领域模块使用的高度可重用的逻辑片段
*   信息发送
*   状态管理

## 清单

服务模块:

*   仅定义提供商
*   由域模块导入

## 小部件模块

小部件模块是收集和导出声明的模块。WidgetModule 的一个例子是提供组件和指令的第三方 UI 库。

如果你或者你的公司正在构建一个 UI 库，它大概可以被归类为 UI 库。

## 清单

小部件模块:

*   仅声明声明
*   很少有供应商
*   仅出口申报
*   由域模块导入

## 您可能需要 Widget 模块的迹象:

*   声明是高度可重用的
*   声明不特定于任何域模块
*   组件不是容器

# 最后的话

随着社区的不断发展，编写 Angular 应用程序的专家越来越多，我相信将来模块类型的列表仍然有可能不同或扩展。

即使你不记得所有的规则，在编写一个模块时问自己这些问题，这将有助于你根据指导方针设计模块:

*   应该导入这个特定的组件/服务吗？
*   这些声明应该是私有的还是公共的？
*   这些声明应该是单独的小部件模块的一部分吗？
*   这些服务应该在这里定义，还是应该存在于一个服务模块中？
*   这组组件应该是更小的域模块吗？

和往常一样，我的建议是让架构问题成为团队问题，而不是一个人的问题。

通过提出和遵循这些问题，您也为您的团队提供了一个清晰的指导方针，这也应该导致一个整个团队都可以理解和遵守的平稳和一致的方式。

*如果你喜欢这篇文章，请关注我的* [*Medium*](https://medium.com/@.gc) *或*[*Twitter*](https://twitter.com/home)*以获取更多关于 Angular、RxJS、Typescript 等的文章！*

*最初发布于*[*https://frontend . consulting*](https://frontend.consulting/understanding-angular-modules)*。*