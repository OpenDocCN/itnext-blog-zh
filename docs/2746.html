<html>
<head>
<title>Kubernetes: part 1 — architecture and main components overview</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes:第1部分—架构和主要组件概述</h1>
<blockquote>原文：<a href="https://itnext.io/kubernetes-part-1-architecture-and-main-components-overview-a9ce97264a74?source=collection_archive---------7-----------------------#2019-07-25">https://itnext.io/kubernetes-part-1-architecture-and-main-components-overview-a9ce97264a74?source=collection_archive---------7-----------------------#2019-07-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/deb05acf0650f658523ed1892a0f41d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:260/format:webp/0*EY813Srl3F2WFrwt.png"/></div></figure><p id="a923" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在我目前的移动应用项目中，我们在Yii PHP-framework上有一个API-backend，它现在工作在一个普通的LEMP堆栈上——Linux/NGINX/PHP-FPM/MySQL(AWS EC2+Maria db RDS)。</p><p id="2d45" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">最终，是时候将这个庞然大物分解成微服务了，这些微服务将由Kubernetes精心编排，并在EKS的服务上运行。</p><p id="c8b1" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在这篇文章中，我们将简要概述Kubernetes的主要组件及其架构，在接下来的文章中，我们将更深入地了解它的配置和使用，以及AWS EKS的例子。</p><p id="b496" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在这篇文章中有很多有用的链接，但是请记住一个事实，Kubernetes发展非常快，所以任何例子都可能在几个月内过时。</p><p id="4311" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">下一个帖子:</p><ul class=""><li id="4154" class="kt ku iq jw b jx jy kb kc kf kv kj kw kn kx kr ky kz la lb bi translated"><a class="ae ks" href="https://rtfm.co.ua/en/kubernetes-part-2-a-cluster-set-up-on-aws-with-aws-cloud-provider-and-aws-loadbalancer/" rel="noopener ugc nofollow" target="_blank"> Kubernetes:第2部分—利用AWS云提供商和AWS负载平衡器在AWS上建立集群</a></li><li id="7830" class="kt ku iq jw b jx lc kb ld kf le kj lf kn lg kr ky kz la lb bi translated"><a class="ae ks" href="https://rtfm.co.ua/en/kubernetes-part-3-aws-eks-overview-and-manual-eks-cluster-set-up/" rel="noopener ugc nofollow" target="_blank"> Kubernetes:第3部分— AWS EKS概述和手动EKS集群设置</a></li></ul></div><div class="ab cl lh li hu lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ij ik il im in"><ul class=""><li id="57d5" class="kt ku iq jw b jx jy kb kc kf kv kj kw kn kx kr ky kz la lb bi translated"><a class="ae ks" href="#4bcd" rel="noopener ugc nofollow">架构——概述</a></li><li id="1d68" class="kt ku iq jw b jx lc kb ld kf le kj lf kn lg kr ky kz la lb bi translated"><a class="ae ks" href="#a8a6" rel="noopener ugc nofollow">主节点</a></li><li id="1a0f" class="kt ku iq jw b jx lc kb ld kf le kj lf kn lg kr ky kz la lb bi translated"><a class="ae ks" href="#24b2" rel="noopener ugc nofollow">工人节点</a></li><li id="25e5" class="kt ku iq jw b jx lc kb ld kf le kj lf kn lg kr ky kz la lb bi translated"><a class="ae ks" href="#23d0" rel="noopener ugc nofollow">组件交互</a></li><li id="63d3" class="kt ku iq jw b jx lc kb ld kf le kj lf kn lg kr ky kz la lb bi translated"><a class="ae ks" href="#6d08" rel="noopener ugc nofollow"> Kubernetes抽象概念</a></li><li id="fd54" class="kt ku iq jw b jx lc kb ld kf le kj lf kn lg kr ky kz la lb bi translated"><a class="ae ks" href="#a6ad" rel="noopener ugc nofollow"> Pod </a></li><li id="94fc" class="kt ku iq jw b jx lc kb ld kf le kj lf kn lg kr ky kz la lb bi translated"><a class="ae ks" href="#de1d" rel="noopener ugc nofollow">服务</a></li><li id="61f8" class="kt ku iq jw b jx lc kb ld kf le kj lf kn lg kr ky kz la lb bi translated"><a class="ae ks" href="#b95b" rel="noopener ugc nofollow">卷</a></li><li id="68ce" class="kt ku iq jw b jx lc kb ld kf le kj lf kn lg kr ky kz la lb bi translated"><a class="ae ks" href="#dabb" rel="noopener ugc nofollow">名称空间</a></li><li id="449d" class="kt ku iq jw b jx lc kb ld kf le kj lf kn lg kr ky kz la lb bi translated"><a class="ae ks" href="#cfb7" rel="noopener ugc nofollow">控制器</a></li></ul></div><div class="ab cl lh li hu lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ij ik il im in"><h2 id="4bcd" class="lo lp iq bd lq lr ls dn lt lu lv dp lw kf lx ly lz kj ma mb mc kn md me mf mg bi translated">建筑——概述</h2><p id="ad3d" class="pw-post-body-paragraph ju jv iq jw b jx mh jz ka kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr ij bi translated">一般来说，Kubernetes集群组件如下所示:</p><figure class="mn mo mp mq gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi mm"><img src="../Images/39e1628deae5b813a3656a43e6882fe7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*AnDIb4QsPzh1bnPx.jpg"/></div></div></figure><p id="01be" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">或者更简单一点:</p><figure class="mn mo mp mq gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi mv"><img src="../Images/8216416cf20a2b988488fe591e794304.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*UEpKFB6Kvm3q9ohe.png"/></div></div></figure><p id="f407" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">集群本身由一个或多个<em class="mw">主节点</em>和一个或多个<em class="mw">工作节点</em>组成。</p></div><div class="ab cl lh li hu lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ij ik il im in"><h2 id="a8a6" class="lo lp iq bd lq lr ls dn lt lu lv dp lw kf lx ly lz kj ma mb mc kn md me mf mg bi translated">主网点</h2><p id="9e0a" class="pw-post-body-paragraph ju jv iq jw b jx mh jz ka kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr ij bi translated">运行在主节点上的服务称为“<a class="ae ks" href="https://kubernetes.io/docs/concepts/#kubernetes-control-plane" rel="noopener ugc nofollow" target="_blank"><em class="mw">”Kubernetes控制平面</em> </a>”(不包括<code class="fe mx my mz na b">etcd</code>)，主节点仅用于管理任务，而包含您的服务的容器将在工作节点上创建。</p><p id="5558" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">Kubernetes核心服务又称Kubernetes控制平面</p><ul class=""><li id="81b9" class="kt ku iq jw b jx jy kb kc kf kv kj kw kn kx kr ky kz la lb bi translated"><a class="ae ks" href="https://medium.com/jorgeacetozi/kubernetes-master-components-etcd-api-server-controller-manager-and-scheduler-3a0179fc8186" rel="noopener"> Kubernetes主组件:Etcd、API服务器、控制器管理器和调度器</a></li></ul><p id="3f1e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在主节点上，有三个主要的Kubernetes组件使整个集群工作:</p><ul class=""><li id="f44e" class="kt ku iq jw b jx jy kb kc kf kv kj kw kn kx kr ky kz la lb bi translated"><code class="fe mx my mz na b"><a class="ae ks" href="https://kubernetes.io/docs/reference/command-line-tools-reference/kube-apiserver/" rel="noopener ugc nofollow" target="_blank">kube-apiserver</a></code></li><li id="409d" class="kt ku iq jw b jx lc kb ld kf le kj lf kn lg kr ky kz la lb bi translated">对集群的所有请求的主入口点，例如<code class="fe mx my mz na b">kubectl</code>命令将作为API请求发送到主节点上的<code class="fe mx my mz na b"><a class="ae ks" href="https://kubernetes.io/docs/reference/command-line-tools-reference/kube-apiserver/" rel="noopener ugc nofollow" target="_blank">kube-apiserver</a></code></li><li id="a11f" class="kt ku iq jw b jx lc kb ld kf le kj lf kn lg kr ky kz la lb bi translated">API服务器为所有REST请求提供服务，验证它们并将其发送给<code class="fe mx my mz na b">etcd</code> (API服务器是唯一一个与<code class="fe mx my mz na b">etcd</code>对话的服务——所有其他组件将与API本身对话，API服务器将依次更新<code class="fe mx my mz na b">etcd</code>中的数据，参见<em class="mw">组件交互</em>)</li><li id="6ea7" class="kt ku iq jw b jx lc kb ld kf le kj lf kn lg kr ky kz la lb bi translated">API服务器还负责认证和授权</li><li id="cab6" class="kt ku iq jw b jx lc kb ld kf le kj lf kn lg kr ky kz la lb bi translated"><code class="fe mx my mz na b"><a class="ae ks" href="https://kubernetes.io/docs/reference/command-line-tools-reference/kube-scheduler/" rel="noopener ugc nofollow" target="_blank">kube-scheduler</a></code></li><li id="c2eb" class="kt ku iq jw b jx lc kb ld kf le kj lf kn lg kr ky kz la lb bi translated">决定哪个工作节点w将用于新的Pod创建(请参见。<a class="ae ks" href="https://rtfm.co.ua/en/?p=21104#Pod" rel="noopener ugc nofollow" target="_blank"> <em class="mw"> Pod </em> </a>)取决于请求的资源和节点使用情况</li><li id="bbcd" class="kt ku iq jw b jx lc kb ld kf le kj lf kn lg kr ky kz la lb bi translated"><code class="fe mx my mz na b"><a class="ae ks" href="https://kubernetes.io/docs/reference/command-line-tools-reference/kube-controller-manager/" rel="noopener ugc nofollow" target="_blank">kube-controller-manager</a></code></li><li id="292b" class="kt ku iq jw b jx lc kb ld kf le kj lf kn lg kr ky kz la lb bi translated">用于<a class="ae ks" href="https://kubernetes.io/docs/concepts/overview/components/#kube-controller-manager" rel="noopener ugc nofollow" target="_blank">控制器</a>的守护程序，例如<em class="mw">复制控制器</em>、<em class="mw">端点控制器、</em>和<em class="mw">名称空间控制器</em></li><li id="269a" class="kt ku iq jw b jx lc kb ld kf le kj lf kn lg kr ky kz la lb bi translated">通过API服务器定期比较集群状态，并应用必要的更改</li><li id="39f7" class="kt ku iq jw b jx lc kb ld kf le kj lf kn lg kr ky kz la lb bi translated">也用于Linux名称空间(参见<a class="ae ks" href="https://rtfm.co.ua/what-is-linux-namespaces-primery-na-c-clone-pid-i-net-namespaces/" rel="noopener ugc nofollow" target="_blank">什么是:Linux名称空间，примеры PID и网络名称空间</a>，<em class="mw"> Rus </em>)的创建和管理以及垃圾收集</li></ul><p id="6491" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe mx my mz na b">etcd</code></p><ul class=""><li id="baee" class="kt ku iq jw b jx jy kb kc kf kv kj kw kn kx kr ky kz la lb bi translated"><a class="ae ks" href="https://etcd.io/" rel="noopener ugc nofollow" target="_blank"> etcd.io </a></li></ul><p id="30b5" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">是Kubernetes用于<a class="ae ks" href="https://en.wikipedia.org/wiki/Service_discovery" rel="noopener ugc nofollow" target="_blank">服务发现</a>和配置管理的<em class="mw">键:值</em>存储。</p><p id="293d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">此外，它保持集群的<em class="mw">当前</em>和<em class="mw">期望</em>状态:如果K8s将发现这些状态之间的区别，它将应用<em class="mw">期望</em>状态，使其成为<em class="mw">当前</em>状态。</p></div><div class="ab cl lh li hu lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ij ik il im in"><h2 id="24b2" class="lo lp iq bd lq lr ls dn lt lu lv dp lw kf lx ly lz kj ma mb mc kn md me mf mg bi translated">工作节点</h2><p id="93ea" class="pw-post-body-paragraph ju jv iq jw b jx mh jz ka kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr ij bi translated">Worker Node(以前称为<em class="mw"> minion </em> ) —一个虚拟或裸机服务器，带有Kuberners组件来创建和管理Pod(参见<a class="ae ks" href="https://rtfm.co.ua/en/?p=21104#Pod" rel="noopener ugc nofollow" target="_blank"> <em class="mw"> Pod </em> </a>)。</p><p id="7040" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这些组成部分是:</p><ul class=""><li id="1f42" class="kt ku iq jw b jx jy kb kc kf kv kj kw kn kx kr ky kz la lb bi translated"><code class="fe mx my mz na b"><a class="ae ks" href="https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet/" rel="noopener ugc nofollow" target="_blank">kubelet</a></code>:每个集群节点上的主Kubernetes组件，它与API服务器对话，以检查当前Worker节点上是否有要创建的新Pods</li><li id="0ee4" class="kt ku iq jw b jx lc kb ld kf le kj lf kn lg kr ky kz la lb bi translated">它通过API与Docker守护进程(或其他容器系统，如<code class="fe mx my mz na b"><a class="ae ks" href="https://coreos.com/rkt/" rel="noopener ugc nofollow" target="_blank">rkt</a></code>或<code class="fe mx my mz na b"><a class="ae ks" href="https://containerd.io/" rel="noopener ugc nofollow" target="_blank">containerd</a></code>)通信，以创建和管理容器</li><li id="ba4e" class="kt ku iq jw b jx lc kb ld kf le kj lf kn lg kr ky kz la lb bi translated">在节点上的Pod中发生任何更改后，会将它们发送到API服务器，然后API服务器会将它们保存到<code class="fe mx my mz na b">etcd</code>数据库中</li><li id="93a9" class="kt ku iq jw b jx lc kb ld kf le kj lf kn lg kr ky kz la lb bi translated">执行容器监控</li><li id="7c93" class="kt ku iq jw b jx lc kb ld kf le kj lf kn lg kr ky kz la lb bi translated"><code class="fe mx my mz na b"><a class="ae ks" href="https://kubernetes.io/docs/reference/command-line-tools-reference/kube-proxy/" rel="noopener ugc nofollow" target="_blank">kube-proxy</a></code>:类似于一个反向代理服务，将请求转发到Kubernetes私有网络中的适当服务或应用程序</li><li id="efcc" class="kt ku iq jw b jx lc kb ld kf le kj lf kn lg kr ky kz la lb bi translated">默认使用<a class="ae ks" href="https://rtfm.co.ua/linux-iptables-rukovodstvo-chast-1-osnovy-iptables/" rel="noopener ugc nofollow" target="_blank"> IPTABLES </a>(您可以通过<code class="fe mx my mz na b">kubectl -n kube-system exec -ti kube-proxy-5ctt2 -- iptables --table nat --list</code>命令检查现有规则)</li><li id="8e41" class="kt ku iq jw b jx lc kb ld kf le kj lf kn lg kr ky kz la lb bi translated">看吧。<a class="ae ks" href="https://supergiant.io/blog/understanding-kubernetes-kube-proxy/" rel="noopener ugc nofollow" target="_blank">了解Kubernetes Kube-Proxy </a></li></ul></div><div class="ab cl lh li hu lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ij ik il im in"><h2 id="23d0" class="lo lp iq bd lq lr ls dn lt lu lv dp lw kf lx ly lz kj ma mb mc kn md me mf mg bi translated">组件交互</h2><p id="6249" class="pw-post-body-paragraph ju jv iq jw b jx mh jz ka kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr ij bi translated">创建新Pod时的示例:</p><ol class=""><li id="452d" class="kt ku iq jw b jx jy kb kc kf kv kj kw kn kx kr nb kz la lb bi translated"><code class="fe mx my mz na b">kubectl</code>将向API服务器发送请求</li><li id="fa4d" class="kt ku iq jw b jx lc kb ld kf le kj lf kn lg kr nb kz la lb bi translated">API服务器将对其进行验证，并发送给<code class="fe mx my mz na b">etcd</code></li><li id="85d0" class="kt ku iq jw b jx lc kb ld kf le kj lf kn lg kr nb kz la lb bi translated"><code class="fe mx my mz na b">etcd</code>将回复API，请求被接受并保存在数据库中</li><li id="1226" class="kt ku iq jw b jx lc kb ld kf le kj lf kn lg kr nb kz la lb bi translated">API服务器将与<code class="fe mx my mz na b">kube-scheduler</code>对话</li><li id="fd34" class="kt ku iq jw b jx lc kb ld kf le kj lf kn lg kr nb kz la lb bi translated"><code class="fe mx my mz na b">kube-scheduler</code>将选择一个工人节点来创建一个新的Pod并将该信息发送回API服务器</li><li id="d1fa" class="kt ku iq jw b jx lc kb ld kf le kj lf kn lg kr nb kz la lb bi translated">API服务器会将此信息发送给<code class="fe mx my mz na b">etcd</code></li><li id="e44b" class="kt ku iq jw b jx lc kb ld kf le kj lf kn lg kr nb kz la lb bi translated"><code class="fe mx my mz na b">etcd</code>会回复它已接受并保存的数据</li><li id="1a53" class="kt ku iq jw b jx lc kb ld kf le kj lf kn lg kr nb kz la lb bi translated">API服务器与所选工作节点上的<code class="fe mx my mz na b">kubelet</code>对话</li><li id="af71" class="kt ku iq jw b jx lc kb ld kf le kj lf kn lg kr nb kz la lb bi translated"><code class="fe mx my mz na b">kubelet</code>将通过其API与Docker守护进程(或另一个使用的<a class="ae ks" href="https://kubernetes.io/docs/setup/production-environment/container-runtimes/" rel="noopener ugc nofollow" target="_blank">容器运行时</a>对话，以创建一个新的容器</li><li id="d21d" class="kt ku iq jw b jx lc kb ld kf le kj lf kn lg kr nb kz la lb bi translated"><code class="fe mx my mz na b">kubelet</code>将把关于新Pod的信息发送回API服务器</li><li id="8973" class="kt ku iq jw b jx lc kb ld kf le kj lf kn lg kr nb kz la lb bi translated">API服务器将更新<code class="fe mx my mz na b">etcd</code>中的信息</li></ol></div><div class="ab cl lh li hu lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ij ik il im in"><h2 id="6d08" class="lo lp iq bd lq lr ls dn lt lu lv dp lw kf lx ly lz kj ma mb mc kn md me mf mg bi translated">Kubernetes抽象</h2><p id="302d" class="pw-post-body-paragraph ju jv iq jw b jx mh jz ka kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr ij bi translated">上面我们谈到了或多或少“可触摸”的东西，如虚拟机、网络、IP地址等等。</p><p id="4bc5" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">但是Kubernetes本身只是一大块…抽象:-)放置在物理或虚拟基础设施上。</p><p id="d882" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">因此，Kubernetes有许多自己的对象，这些对象是Kubernetes的抽象或逻辑组件。</p><h2 id="a6ad" class="lo lp iq bd lq lr ls dn lt lu lv dp lw kf lx ly lz kj ma mb mc kn md me mf mg bi translated">豆荚</h2><p id="8473" class="pw-post-body-paragraph ju jv iq jw b jx mh jz ka kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr ij bi translated">Pod—Kubernetes集群中的主要逻辑单元。</p><p id="8740" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">本质上，Pod是Kubernetes集群中的一种虚拟机:它有自己的私有IP、主机名、共享卷等(参见。<a class="ae ks" href="https://rtfm.co.ua/en/?p=21104#Volumes" rel="noopener ugc nofollow" target="_blank"> <em class="mw">卷</em> </a>)。</p><p id="7070" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">Pod是一个部署单元(参见<a class="ae ks" href="https://rtfm.co.ua/en/?p=21104#Deployment" rel="noopener ugc nofollow" target="_blank"> <em class="mw">部署</em> </a>),在这个“虚拟机”内部将创建一个或多个容器，这些容器由一个共同的目标联系在一起，并且是一个运行一个或多个进程的逻辑应用程序。</p><p id="e35b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">每个这样的pod都被指定为运行和服务一个应用程序的唯一副本:如果您想要进行水平扩展，您需要为每个工作节点使用一个专用的Pod。</p><figure class="mn mo mp mq gt jr gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/b9fbc04043b8aff23b6031ba13bc5572.png" data-original-src="https://miro.medium.com/v2/resize:fit:1258/format:webp/0*iXG4_sldBKgojJvv.png"/></div></figure><p id="af9f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这样一个被称为<em class="mw">的节点组复制了pod</em>并由一个专用控制器管理(见<a class="ae ks" href="https://rtfm.co.ua/?p=21053#Conrtollers" rel="noopener ugc nofollow" target="_blank"> <em class="mw">控制器</em> </a>)。</p><p id="3a33" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在这样做的时候，容器本身不是Kubernetes集群对象，它们不是由Kubernetes直接管理的，而是——Kubernetes管理Pod，而这个Pod内部的容器共享其名称空间，包括IP地址和端口，并且可以通过<em class="mw"> localhost </em>相互通信(因为Pod就像一个VM)。</p><p id="ce2d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">Pod的模板示例:</p><pre class="mn mo mp mq gt nd na ne nf aw ng bi"><span id="0a5a" class="lo lp iq na b gy nh ni l nj nk">apiVersion: v1<br/>kind: Pod<br/>metadata:<br/>  name: my-pod<br/>  labels:<br/>    app: my-app<br/>    type: front-app<br/><br/>spec:<br/>  containers:<br/>  - name: nginx-container<br/>    image: nginx</span></pre><h2 id="de1d" class="lo lp iq bd lq lr ls dn lt lu lv dp lw kf lx ly lz kj ma mb mc kn md me mf mg bi translated">服务</h2><p id="12ea" class="pw-post-body-paragraph ju jv iq jw b jx mh jz ka kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr ij bi translated">链接:</p><ul class=""><li id="09f7" class="kt ku iq jw b jx jy kb kc kf kv kj kw kn kx kr ky kz la lb bi translated"><a class="ae ks" href="https://kubernetes.io/docs/concepts/services-networking/service/" rel="noopener ugc nofollow" target="_blank">服务</a></li><li id="fdb6" class="kt ku iq jw b jx lc kb ld kf le kj lf kn lg kr ky kz la lb bi translated"><a class="ae ks" href="https://www.bmc.com/blogs/kubernetes-services/" rel="noopener ugc nofollow" target="_blank"> Kubernetes服务:初学者指南</a></li><li id="7fc6" class="kt ku iq jw b jx lc kb ld kf le kj lf kn lg kr ky kz la lb bi translated"><a class="ae ks" href="https://www.youtube.com/watch?v=5lzUpDtmWgM" rel="noopener ugc nofollow" target="_blank"> Kubernetes —服务说明</a></li></ul><p id="54e9" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">首先，服务是Kubernetes集群中关于网络的一切。</p><p id="55d5" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">它们用于应用程序内部和外部组件之间的通信。</p><p id="f27d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">基本上，服务是与<a class="ae ks" href="https://rtfm.co.ua/?p=21053#Pod" rel="noopener ugc nofollow" target="_blank"> <em class="mw"> Pod </em> </a>，<a class="ae ks" href="https://rtfm.co.ua/?p=21053#ReplicaSet" rel="noopener ugc nofollow" target="_blank"> <em class="mw"> ReplicaSets </em> </a>，<a class="ae ks" href="https://rtfm.co.ua/?p=21053#DaemonSet" rel="noopener ugc nofollow" target="_blank"> <em class="mw"> DaemonSet </em> </a>相同的Kubernetes对象，您可以将服务想象成集群节点内的专用虚拟机。</p><p id="dd1c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">它们可以显示为下一个:</p><figure class="mn mo mp mq gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi nl"><img src="../Images/67c3f720cee0e3b43e584488204abb91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*5_zk1F3RpHBxCjJT.png"/></div></div></figure><p id="2e35" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这里有一个用户通过一个服务连接到一个前端应用程序，然后这个前端使用两个附加服务与两个后端应用程序对话，后端通过另一个服务与一个数据库服务通信。</p><p id="0781" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe mx my mz na b">ClusterIP</code></p><p id="d5e1" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">将通过群集的内部IP开放对应用程序的访问，因此可以从群集内部访问。</p><p id="d03c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">是默认的服务类型。</p><p id="5687" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe mx my mz na b">NodePort</code></p><p id="6d75" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">此服务类型将使用工作节点的静态IP开放对应用程序的访问。</p><p id="9ab7" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">此外，automatically将为应用程序创建一个<code class="fe mx my mz na b">ClusterIP</code>服务来路由来自<code class="fe mx my mz na b">NodePort</code>的流量。</p><figure class="mn mo mp mq gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi nm"><img src="../Images/7dadb9b598023479ff2cde0786d1f9c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*qeKOTh2H8aNviRKx.png"/></div></div></figure><p id="2b8f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这里:</p><ul class=""><li id="91c8" class="kt ku iq jw b jx jy kb kc kf kv kj kw kn kx kr ky kz la lb bi translated"><em class="mw"> 30008 </em> —工作节点上可用于连接到<code class="fe mx my mz na b">NodePort</code>服务的外部端口必须在30000 - 32767端口范围内</li><li id="e42b" class="kt ku iq jw b jx lc kb ld kf le kj lf kn lg kr ky kz la lb bi translated"><code class="fe mx my mz na b">NodePort</code>服务于<code class="fe mx my mz na b">ClusterIP</code>、自身端口(<em class="mw">端口</em>)和来自<code class="fe mx my mz na b">serviceSubnet</code>模块的IP</li><li id="209e" class="kt ku iq jw b jx lc kb ld kf le kj lf kn lg kr ky kz la lb bi translated">内部有应用程序的Pod—Pod将接受到其端口80 ( <em class="mw">目标端口</em>)的新连接，并拥有来自<code class="fe mx my mz na b">podSubnet</code>块的IP</li></ul><p id="ab94" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">使用<code class="fe mx my mz na b">kubeadm config view</code>命令可以找到这些网络:</p><pre class="mn mo mp mq gt nd na ne nf aw ng bi"><span id="aaec" class="lo lp iq na b gy nh ni l nj nk">root@k8s-master:~# kubeadm config view<br/>apiServer:<br/>extraArgs:<br/>authorization-mode: Node,RBAC<br/>timeoutForControlPlane: 4m0s<br/>apiVersion: kubeadm.k8s.io/v1beta2<br/>certificatesDir: /etc/kubernetes/pki<br/>clusterName: kubernetes<br/>controllerManager: {}<br/>dns:<br/>type: CoreDNS<br/>etcd:<br/>local:<br/>dataDir: /var/lib/etcd<br/>imageRepository: k8s.gcr.io<br/>kind: ClusterConfiguration<br/>kubernetesVersion: v1.15.0<br/>networking:<br/>dnsDomain: cluster.local<br/>podSubnet: 10.244.0.0/16<br/>serviceSubnet: 10.96.0.0/12<br/>scheduler: {}</span></pre><p id="7215" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">同样，您可以想象一个服务，就像您的Worker节点中的另一个VM，就像Pods一样。</p><p id="e25c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">一个<code class="fe mx my mz na b">NodePort</code>服务的模板示例:</p><pre class="mn mo mp mq gt nd na ne nf aw ng bi"><span id="24e2" class="lo lp iq na b gy nh ni l nj nk">apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: my-svc<br/><br/>spec:<br/>  type: NodePort<br/>  ports:<br/>    - targetPort: 80<br/>      port: 80<br/>      nodePort: 30008<br/>  selector:<br/>    app: my-app<br/>    type: front-app</span></pre><p id="d815" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">服务、Pod、标签、选择器</strong></p><ul class=""><li id="a4d8" class="kt ku iq jw b jx jy kb kc kf kv kj kw kn kx kr ky kz la lb bi translated"><a class="ae ks" href="https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/" rel="noopener ugc nofollow" target="_blank">标签和选择器</a></li></ul><p id="ad04" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">为了让服务区分必须使用哪个Pod来路由流量，使用了<code class="fe mx my mz na b">Labels</code> и <code class="fe mx my mz na b">Selectors</code>。</p><p id="0aa2" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在上面的pod模板示例中，我们为应用程序添加了标签:</p><pre class="mn mo mp mq gt nd na ne nf aw ng bi"><span id="9567" class="lo lp iq na b gy nh ni l nj nk">apiVersion: v1<br/>kind: Pod<br/>metadata:<br/>  name: my-pod<br/>  labels:<br/>    app: my-app<br/>    type: front-app<br/><br/>spec:<br/>  containers:<br/>  - name: nginx-container<br/>    image: nginx</span></pre><p id="b804" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在这里—标签<em class="mw">标签</em>:</p><pre class="mn mo mp mq gt nd na ne nf aw ng bi"><span id="7ae6" class="lo lp iq na b gy nh ni l nj nk">...<br/>  labels: <br/>    app: my-app</span></pre><p id="5869" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">然后在服务的描述中—我们使用了<em class="mw">选择器</em>:</p><pre class="mn mo mp mq gt nd na ne nf aw ng bi"><span id="5be8" class="lo lp iq na b gy nh ni l nj nk">...<br/>  selector:<br/>    app: my-app</span></pre><p id="32e8" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">因此，如果一个集群有多个带有此类标签的pod，则服务会尝试将流量路由到所有这些pod:</p><figure class="mn mo mp mq gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi nn"><img src="../Images/df23291922413d713af1a24a228beae3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*8YO8bCWNVII63T-r.png"/></div></div></figure><p id="7682" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果一个应用程序被放置在多个工作节点上，那么一个<code class="fe mx my mz na b">NodePort</code>服务将在所有这些节点之间传播，并且<em class="mw"> 30008 </em>端口将在每个这样的节点上打开。</p><p id="0687" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">因此，您可以使用任何工作节点的公共IP通过<code class="fe mx my mz na b">NodePort</code>服务访问应用程序:</p><figure class="mn mo mp mq gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi no"><img src="../Images/0a741f4ef2530a231c1f7ab273d128f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*LBsHCKIA3BYGPCF0.png"/></div></div></figure><p id="8046" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe mx my mz na b">LoadBalancer</code></p><ul class=""><li id="8b31" class="kt ku iq jw b jx jy kb kc kf kv kj kw kn kx kr ky kz la lb bi translated"><a class="ae ks" href="https://kubernetes.io/docs/concepts/services-networking/#loadbalancer" rel="noopener ugc nofollow" target="_blank">型负载平衡器</a></li><li id="9b41" class="kt ku iq jw b jx lc kb ld kf le kj lf kn lg kr ky kz la lb bi translated"><a class="ae ks" href="https://kubernetes.io/docs/concepts/cluster-administration/cloud-providers/" rel="noopener ugc nofollow" target="_blank">云提供商</a></li><li id="1bc7" class="kt ku iq jw b jx lc kb ld kf le kj lf kn lg kr ky kz la lb bi translated"><a class="ae ks" href="https://blog.giantswarm.io/load-balancer-service-use-cases-on-aws/" rel="noopener ugc nofollow" target="_blank">在AWS上使用Kubernetes负载平衡器服务</a></li></ul><p id="e89b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">将创建一个云提供商的负载均衡器，例如— <a class="ae ks" href="https://docs.aws.amazon.com/elasticloadbalancing/latest/application/introduction.html" rel="noopener ugc nofollow" target="_blank"> AWS ALB </a>。</p><p id="3c13" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">工作节点将连接到这个负载平衡器，流量将通过内部的<code class="fe mx my mz na b">LoadBalancer</code>服务路由到一个节点的<code class="fe mx my mz na b">NodePort</code>服务。</p><p id="385f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe mx my mz na b">NodePort</code>和<code class="fe mx my mz na b">ClusterIP</code>将被自动创建。</p><p id="5f8a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe mx my mz na b">ExternalName</code></p><p id="ae0b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">将服务绑定到其<code class="fe mx my mz na b">externalName</code>字段值，以返回其CNAME值。</p><p id="8cb5" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">一个<code class="fe mx my mz na b">ExternalName</code>服务模板示例:</p><pre class="mn mo mp mq gt nd na ne nf aw ng bi"><span id="2839" class="lo lp iq na b gy nh ni l nj nk">apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: my-google-svc<br/>spec:<br/>  type: ExternalName<br/>  externalName: google.com</span></pre><p id="1e28" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">创建后，您可以通过此服务名从任何Pod访问它，例如，根据上面的模板示例，<em class="mw"> my-google-svc </em>:</p><pre class="mn mo mp mq gt nd na ne nf aw ng bi"><span id="7759" class="lo lp iq na b gy nh ni l nj nk">root@k8s-master:~# kubectl exec -it my-pod --dig my-google-svc.default.svc.cluster.local +short<br/>google.com.<br/>74.125.193.101<br/>…</span></pre><h2 id="b95b" class="lo lp iq bd lq lr ls dn lt lu lv dp lw kf lx ly lz kj ma mb mc kn md me mf mg bi translated">卷</h2><ul class=""><li id="96e3" class="kt ku iq jw b jx mh kb mi kf np kj nq kn nr kr ky kz la lb bi translated"><a class="ae ks" href="https://kubernetes.io/docs/concepts/storage/volumes" rel="noopener ugc nofollow" target="_blank">卷</a></li><li id="954a" class="kt ku iq jw b jx lc kb ld kf le kj lf kn lg kr ky kz la lb bi translated"><a class="ae ks" href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/" rel="noopener ugc nofollow" target="_blank">持久卷</a></li><li id="a63f" class="kt ku iq jw b jx lc kb ld kf le kj lf kn lg kr ky kz la lb bi translated"><a class="ae ks" href="https://matthewpalmer.net/kubernetes-app-developer/articles/kubernetes-volumes-example-nfs-persistent-volume.html" rel="noopener ugc nofollow" target="_blank"> Kubernetes卷指南</a></li></ul><p id="caa5" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">容器中的数据是短暂的，也就是说，如果容器被<code class="fe mx my mz na b">kubelet</code>重新创建，那么旧容器中的所有数据都将丢失。</p><p id="02c9" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">此外，同一个Pod中的多个容器可以使用共享数据。</p><p id="2c42" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">Kubernetes中的<code class="fe mx my mz na b">Volumes</code>概念类似于Docker的解决方案，只是功能更多。</p><p id="87fb" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">例如，Kubernete的Volumes支持各种驱动程序将卷挂载到pod，如<a class="ae ks" href="https://kubernetes.io/docs/concepts/storage/volumes/#awselasticblockstore" rel="noopener ugc nofollow" target="_blank"> awsElasticBlockStore </a>、<a class="ae ks" href="https://kubernetes.io/docs/concepts/storage/volumes/#hostpath" rel="noopener ugc nofollow" target="_blank"> hostPath </a>、<a class="ae ks" href="https://kubernetes.io/docs/concepts/storage/volumes/#nfs" rel="noopener ugc nofollow" target="_blank"> nfs </a>等。</p><h2 id="dabb" class="lo lp iq bd lq lr ls dn lt lu lv dp lw kf lx ly lz kj ma mb mc kn md me mf mg bi translated">名称空间</h2><ul class=""><li id="e721" class="kt ku iq jw b jx mh kb mi kf np kj nq kn nr kr ky kz la lb bi translated"><a class="ae ks" href="https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/" rel="noopener ugc nofollow" target="_blank">名称空间</a></li><li id="1dcb" class="kt ku iq jw b jx lc kb ld kf le kj lf kn lg kr ky kz la lb bi translated"><a class="ae ks" href="https://kubernetes.io/docs/tasks/administer-cluster/namespaces/" rel="noopener ugc nofollow" target="_blank">用名称空间共享一个集群</a></li><li id="0bf9" class="kt ku iq jw b jx lc kb ld kf le kj lf kn lg kr ky kz la lb bi translated"><a class="ae ks" href="https://rtfm.co.ua/what-is-linux-namespaces-primery-na-c-clone-pid-i-net-namespaces/" rel="noopener ugc nofollow" target="_blank">什么是:Linux名称空间，примеры PID и网络名称空间</a></li></ul><p id="1c82" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">Kubernetes中的<em class="mw">命名空间</em>是您现有集群中的一种专用集群，具有自己的一组命名空间，用于网络、磁盘/卷、进程等。</p><p id="e47a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">名称空间背后的主要思想是专用于工作环境、用户，并可用于设置资源使用限制— CPU、内存等。参见<a class="ae ks" href="https://kubernetes.io/docs/concepts/policy/resource-quotas/" rel="noopener ugc nofollow" target="_blank"> <em class="mw">资源配额</em> </a>。</p><p id="8e04" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在Kubernetes DNS服务中也使用了这个名称空间来创建一个<em class="mw"> &lt;服务名&gt;中的URL。&lt;名称空间名称&gt; .svc.cluster.local </em>视图。</p><p id="a4a6" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">大多数Kubernetes资源都存在于这样的名称空间中，您可以通过以下方式列出它们:</p><pre class="mn mo mp mq gt nd na ne nf aw ng bi"><span id="0c93" class="lo lp iq na b gy nh ni l nj nk">$ kubectl api-resources --namespaced=true</span></pre><p id="d11f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">要列出位于任何命名空间之外的资源，请使用下一个命令:</p><pre class="mn mo mp mq gt nd na ne nf aw ng bi"><span id="8c63" class="lo lp iq na b gy nh ni l nj nk">$ kubectl api-resources --namespaced=false</span></pre><h2 id="cfb7" class="lo lp iq bd lq lr ls dn lt lu lv dp lw kf lx ly lz kj ma mb mc kn md me mf mg bi translated">控制器</h2><p id="8fbb" class="pw-post-body-paragraph ju jv iq jw b jx mh jz ka kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr ij bi translated">Kubernetes中的<em class="mw">控制器</em>是一些持续工作的进程，它与API服务器通信并检查集群的当前状态，并进行必要的更改以使<em class="mw">当前</em>状态等于<em class="mw">期望的</em>状态。</p><p id="f052" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">除了标准控制器之外——您可以创建自己的控制器，参见<a class="ae ks" rel="noopener ugc nofollow" target="_blank" href="/how-to-create-a-kubernetes-custom-controller-using-client-go-f36a7a7536cc">如何使用client-go </a>创建Kubernetes定制控制器。</p><p id="5b46" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe mx my mz na b"><strong class="jw ir">ReplicaSet</strong></code></p><ul class=""><li id="b6ec" class="kt ku iq jw b jx jy kb kc kf kv kj kw kn kx kr ky kz la lb bi translated"><a class="ae ks" href="https://kubernetes.io/docs/concepts/workloads/controllers/replicaset/" rel="noopener ugc nofollow" target="_blank">复制集</a></li><li id="b47c" class="kt ku iq jw b jx lc kb ld kf le kj lf kn lg kr ky kz la lb bi translated"><a class="ae ks" href="https://towardsdatascience.com/key-kubernetes-concepts-62939f4bc08e" rel="noopener" target="_blank">关键的Kubernetes概念</a></li><li id="6d0b" class="kt ku iq jw b jx lc kb ld kf le kj lf kn lg kr ky kz la lb bi translated"><a class="ae ks" href="https://dzone.com/articles/kubernetes-knowhow-working-with-replicaset" rel="noopener ugc nofollow" target="_blank"> Kubernetes专有技术—使用复制集</a></li><li id="dd80" class="kt ku iq jw b jx lc kb ld kf le kj lf kn lg kr ky kz la lb bi translated"><a class="ae ks" href="https://ealebed.github.io/posts/2018/%D0%B7%D0%BD%D0%B0%D0%BA%D0%BE%D0%BC%D1%81%D1%82%D0%B2%D0%BE-%D1%81-kubernetes-%D1%87%D0%B0%D1%81%D1%82%D1%8C-4-replicaset/" rel="noopener ugc nofollow" target="_blank">знакомствосKubernetes。часть4:реплики</a>(<em class="mw">RUS</em>)</li></ul><p id="cb5c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe mx my mz na b">ReplicaSet</code>由<code class="fe mx my mz na b">Deployment</code>创建，<code class="fe mx my mz na b">ReplicaSet</code>的主要目标是创建和缩放豆荚。</p><p id="d0eb" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe mx my mz na b">ReplicaSet</code>是<code class="fe mx my mz na b"><a class="ae ks" href="https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller/" rel="noopener ugc nofollow" target="_blank">ReplicationController</a></code>的下一代，可以使用多个选择器(参见<a class="ae ks" href="https://rtfm.co.ua/en/?p=21104#Service_Pod_labels_selectors" rel="noopener ugc nofollow" target="_blank">服务、Pod、标签、选择器</a>)。</p><p id="1902" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">建议使用<code class="fe mx my mz na b">Deployment</code>而不是直接创建<code class="fe mx my mz na b">ReplicaSet</code>对象。</p><p id="252e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">一个<code class="fe mx my mz na b">ReplicaSet</code>模板示例:</p><pre class="mn mo mp mq gt nd na ne nf aw ng bi"><span id="d2ba" class="lo lp iq na b gy nh ni l nj nk">apiVersion: apps/v1<br/>kind: ReplicaSet<br/>metadata:<br/>  name: my-nginx-rc<br/>  labels:<br/>    app: my-nginx-rc-app<br/>spec:<br/>  replicas: 3<br/>  selector:<br/>    matchLabels:<br/>      app: my-nginx-rc-app<br/>  template: # PODs template<br/>    metadata:<br/>      labels: <br/>        app: my-nginx-rc-app<br/>    spec:<br/>      containers:<br/>      - name: nginx-container<br/>        image: nginx</span></pre><p id="1cb6" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe mx my mz na b"><strong class="jw ir">Deployment</strong></code></p><ul class=""><li id="1ee7" class="kt ku iq jw b jx jy kb kc kf kv kj kw kn kx kr ky kz la lb bi translated"><a class="ae ks" href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/" rel="noopener ugc nofollow" target="_blank">部署</a></li><li id="a76a" class="kt ku iq jw b jx lc kb ld kf le kj lf kn lg kr ky kz la lb bi translated"><a class="ae ks" href="https://ealebed.github.io/posts/2018/%D0%B7%D0%BD%D0%B0%D0%BA%D0%BE%D0%BC%D1%81%D1%82%D0%B2%D0%BE-%D1%81-kubernetes-%D1%87%D0%B0%D1%81%D1%82%D1%8C-5-deployments/" rel="noopener ugc nofollow" target="_blank">знакомствосKubernetes。часть5号:развертывания(部署)</a></li><li id="3c31" class="kt ku iq jw b jx lc kb ld kf le kj lf kn lg kr ky kz la lb bi translated"><a class="ae ks" href="https://semaphoreci.com/blog/kubernetes-deployment/" rel="noopener ugc nofollow" target="_blank"> Kubernetes部署:终极指南</a></li><li id="aa66" class="kt ku iq jw b jx lc kb ld kf le kj lf kn lg kr ky kz la lb bi translated"><a class="ae ks" href="https://www.weave.works/blog/kubernetes-deployment-strategies" rel="noopener ugc nofollow" target="_blank">部署策略</a></li><li id="c085" class="kt ku iq jw b jx lc kb ld kf le kj lf kn lg kr ky kz la lb bi translated"><a class="ae ks" href="https://devopscube.com/kubernetes-deployment-tutorial/" rel="noopener ugc nofollow" target="_blank"> Kubernetes初学者部署教程</a></li><li id="4b39" class="kt ku iq jw b jx lc kb ld kf le kj lf kn lg kr ky kz la lb bi translated"><a class="ae ks" href="https://supergiant.io/blog/managing-kubernetes-deployments/" rel="noopener ugc nofollow" target="_blank">管理Kubernetes部署</a></li><li id="475a" class="kt ku iq jw b jx lc kb ld kf le kj lf kn lg kr ky kz la lb bi translated"><a class="ae ks" href="https://medium.com/stakater/k8s-deployments-vs-statefulsets-vs-daemonsets-60582f0c62d4" rel="noopener"> K8s:部署vs状态集vs守护集</a></li></ul><p id="388f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><em class="mw">部署</em>控制器将应用对Pods和<code class="fe mx my mz na b">RelicaSets</code>的更改，目前是Kubernetes中部署应用程序使用最多的资源。</p><p id="3013" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">它主要用于<em class="mw">无状态</em>应用，但是你可以附加一个<a class="ae ks" href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/" rel="noopener ugc nofollow" target="_blank"> <em class="mw">持久卷</em> </a>并作为<em class="mw">有状态</em>应用使用。</p><p id="5c3c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">参见<a class="ae ks" href="https://whatis.techtarget.com/definition/stateful-app" rel="noopener ugc nofollow" target="_blank">有状态</a> vs <a class="ae ks" href="https://whatis.techtarget.com/definition/stateless-app" rel="noopener ugc nofollow" target="_blank">无状态</a>。</p><p id="3342" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在一个<code class="fe mx my mz na b">Deployment</code>创建过程中——它将创建一个<code class="fe mx my mz na b">ReplicaSet</code>对象，该对象将依次为这个<code class="fe mx my mz na b">Deployment</code>创建和管理pod。</p><p id="9374" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe mx my mz na b">Deployment</code>习惯于:</p><ul class=""><li id="6cfe" class="kt ku iq jw b jx jy kb kc kf kv kj kw kn kx kr ky kz la lb bi translated">update Pods — <code class="fe mx my mz na b">Deployment</code>将创建一个新的<code class="fe mx my mz na b">ReplicaSet</code>并将更新一个部署的修订号(<code class="fe mx my mz na b">deployment.kubernetes.io/revision: ""</code>由<code class="fe mx my mz na b">ReplicaSet</code>使用)</li><li id="b535" class="kt ku iq jw b jx lc kb ld kf le kj lf kn lg kr ky kz la lb bi translated">如果部署不成功，使用修订回滚部署</li><li id="bac6" class="kt ku iq jw b jx lc kb ld kf le kj lf kn lg kr ky kz la lb bi translated">可以使用部署(<code class="fe mx my mz na b">kubectl scale</code> и <code class="fe mx my mz na b">kubectl autoscale</code>，参见<a class="ae ks" href="https://kubernetes.io/docs/reference/kubectl/cheatsheet/" rel="noopener ugc nofollow" target="_blank"> kubectl备忘单</a>)来完成Pods扩展和自动扩展</li><li id="2386" class="kt ku iq jw b jx lc kb ld kf le kj lf kn lg kr ky kz la lb bi translated">可用于金丝雀部署(参见<a class="ae ks" href="https://dev.to/mostlyjason/intro-to-deployment-strategies-blue-green-canary-and-more-3a3" rel="noopener ugc nofollow" target="_blank">部署策略介绍:蓝绿色、金丝雀等</a>)</li></ul><figure class="mn mo mp mq gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi ns"><img src="../Images/077fe49ce07e86b2dec44452ac2c4a43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Oqol-gMyYMxye-Fs.png"/></div></div></figure><p id="db1b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">除了<code class="fe mx my mz na b">Deployments</code>之外，还可以使用<a class="ae ks" href="https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#rolling-update" rel="noopener ugc nofollow" target="_blank"> kubectl滚动更新</a>，尽管推荐使用<code class="fe mx my mz na b">Deployments</code>。</p><p id="eefd" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe mx my mz na b"><strong class="jw ir">StatefulSet</strong></code></p><ul class=""><li id="d2f6" class="kt ku iq jw b jx jy kb kc kf kv kj kw kn kx kr ky kz la lb bi translated"><a class="ae ks" href="https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/" rel="noopener ugc nofollow" target="_blank">状态集</a></li><li id="3898" class="kt ku iq jw b jx lc kb ld kf le kj lf kn lg kr ky kz la lb bi translated"><a class="ae ks" href="https://kubernetes.io/docs/tutorials/stateful-application/basic-stateful-set/#updating-statefulsets" rel="noopener ugc nofollow" target="_blank">更新状态集</a></li></ul><p id="77e0" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe mx my mz na b">StatefulSet</code>用于管理有状态的应用程序。</p><p id="616f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">它将直接创建一个具有唯一名称的Pod，而不是<code class="fe mx my mz na b">ReplicaSet</code>。因此，当使用<code class="fe mx my mz na b">StatefulSet</code>时，您无法运行部署回滚。相反，您可以删除资源或对其进行缩放。</p><p id="436e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在<code class="fe mx my mz na b">StatefulSet</code>更新期间，一个<a class="ae ks" href="https://kubernetes.io/docs/tutorials/stateful-application/basic-stateful-set/#updating-statefulsets" rel="noopener ugc nofollow" target="_blank">滚动更新</a>将被应用于所有节点。</p><p id="5b6c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe mx my mz na b"><strong class="jw ir">DaemonSet</strong></code></p><ul class=""><li id="a400" class="kt ku iq jw b jx jy kb kc kf kv kj kw kn kx kr ky kz la lb bi translated"><a class="ae ks" href="https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/" rel="noopener ugc nofollow" target="_blank">达蒙塞特</a></li></ul><p id="2b01" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">当您需要在集群中的所有节点上运行应用程序时使用<code class="fe mx my mz na b">DaemonSet</code>,而不仅仅是在工作节点上。如果在<code class="fe mx my mz na b">DaemonSet</code>之后创建一个新的Pod，那么这个新的Pod上也会部署一个应用程序。</p><p id="874f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe mx my mz na b">DaemonSet</code>是运行必须存在于每个节点上的应用程序的完美设计，例如监控、日志收集器等。</p><p id="fcd8" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在此期间，一些节点将拒绝在其上创建pod，例如主节点，因为它具有<code class="fe mx my mz na b">node-role.kubernetes.io/master:NoSchedule</code>集合(参见<a class="ae ks" href="https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/" rel="noopener ugc nofollow" target="_blank">污点和容忍</a>):</p><pre class="mn mo mp mq gt nd na ne nf aw ng bi"><span id="12a6" class="lo lp iq na b gy nh ni l nj nk">$ kubectl describe node k8s-master | grep Taint<br/>Taints: node-role.kubernetes.io/master:NoSchedule</span></pre><p id="a4b5" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">当创建一个也必须在主节点上创建pod的<code class="fe mx my mz na b">DaemonSet</code>时，您必须指定<code class="fe mx my mz na b">tolerations</code>。</p><p id="f806" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这样一个<code class="fe mx my mz na b">DaemonSet</code>模板示例:</p><pre class="mn mo mp mq gt nd na ne nf aw ng bi"><span id="7354" class="lo lp iq na b gy nh ni l nj nk">apiVersion: apps/v1<br/>kind: DaemonSet<br/>metadata:<br/>  name: my-nginx-ds<br/>spec:<br/>  selector:<br/>    matchLabels:<br/>      app: my-nginx-pod<br/>  template: <br/>    metadata:<br/>      labels: <br/>        app: my-nginx-pod<br/>    spec:<br/>      tolerations:<br/>      - effect: NoSchedule<br/>        operator: Exists<br/>      containers:<br/>      - name: nginx-container<br/>        image: nginx<br/>        ports:<br/>        - containerPort: 80</span></pre><p id="eec2" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在<code class="fe mx my mz na b">DaemonSet</code>更新期间——将应用所有pod的<a class="ae ks" href="https://kubernetes.io/docs/tutorials/stateful-application/basic-stateful-set/#updating-statefulsets" rel="noopener ugc nofollow" target="_blank">滚动更新</a>。</p><p id="6a2f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe mx my mz na b"><strong class="jw ir">Job</strong></code></p><ul class=""><li id="ac17" class="kt ku iq jw b jx jy kb kc kf kv kj kw kn kx kr ky kz la lb bi translated"><a class="ae ks" href="https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/" rel="noopener ugc nofollow" target="_blank">作业—运行至完成</a></li><li id="b9e9" class="kt ku iq jw b jx lc kb ld kf le kj lf kn lg kr ky kz la lb bi translated"><a class="ae ks" href="https://dotsandbrackets.com/one-off-kubernetes-jobs-ru/" rel="noopener ugc nofollow" target="_blank">однократныезадачивkubernetes</a></li><li id="317c" class="kt ku iq jw b jx lc kb ld kf le kj lf kn lg kr ky kz la lb bi translated"><a class="ae ks" href="https://medium.com/coryodaniel/working-with-kubernetes-jobs-848914418" rel="noopener">与Kubernetes Jobs合作</a></li></ul><p id="17c3" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe mx my mz na b">Job</code>在Kubernetes中缩进用来创建一个将只执行一个任务的Pod，一旦它将完成一个任务的执行——这个Pod将被停止。</p><p id="0459" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这样的<code class="fe mx my mz na b">Job</code>可以创建一个或多个Pods，可以并行运行你的任务，执行这个任务指定的尝试次数。</p><p id="d29c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">一个<code class="fe mx my mz na b">Job</code>模板的例子:</p><pre class="mn mo mp mq gt nd na ne nf aw ng bi"><span id="3f74" class="lo lp iq na b gy nh ni l nj nk">apiVersion: batch/v1<br/>kind: Job<br/>metadata:<br/>  name: job-example<br/>spec:<br/>  completions: 2<br/>  parallelism: 2<br/>  template:<br/>    metadata:<br/>      name: counter<br/>    spec:<br/>      containers:<br/>      - name: counter<br/>        image: ubuntu<br/>        command: ["bash"]<br/>        args: ["-c",  "for i in {1..10}; do echo $i; done"]<br/>      restartPolicy: Never</span></pre><p id="61ee" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe mx my mz na b"><strong class="jw ir">CronJob</strong></code></p><p id="d709" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">与<code class="fe mx my mz na b">Job</code>类似，但旨在按计划运行任务——检查下面的<code class="fe mx my mz na b">schedule</code>参数:</p><pre class="mn mo mp mq gt nd na ne nf aw ng bi"><span id="d008" class="lo lp iq na b gy nh ni l nj nk">apiVersion: batch/v1beta1<br/>kind: CronJob<br/>metadata:<br/>  name: cronjob-example<br/>spec:<br/>  schedule: "*/1 * * * *"<br/>  jobTemplate:<br/>    spec:<br/>      completions: 2<br/>      parallelism: 2     <br/>      template:<br/>        metadata:<br/>          name: counter<br/>        spec:<br/>          containers:<br/>          - name: counter<br/>            image: ubuntu<br/>            command: ["bash"]<br/>            args: ["-c",  "for i in {1..10}; do echo $i; done"]<br/>          restartPolicy: Never</span></pre><h2 id="5b06" class="lo lp iq bd lq lr ls dn lt lu lv dp lw kf lx ly lz kj ma mb mc kn md me mf mg bi translated">有用的链接</h2><h2 id="315d" class="lo lp iq bd lq lr ls dn lt lu lv dp lw kf lx ly lz kj ma mb mc kn md me mf mg bi translated">普通的</h2><ul class=""><li id="ec64" class="kt ku iq jw b jx mh kb mi kf np kj nq kn nr kr ky kz la lb bi translated"><a class="ae ks" href="https://kubernetes.io/docs/concepts/?origin_team=T08E6NNJJ" rel="noopener ugc nofollow" target="_blank">概念</a></li><li id="df15" class="kt ku iq jw b jx lc kb ld kf le kj lf kn lg kr ky kz la lb bi translated"><a class="ae ks" href="https://towardsdatascience.com/key-kubernetes-concepts-62939f4bc08e" rel="noopener" target="_blank">Kubernetes的关键概念</a></li><li id="3f56" class="kt ku iq jw b jx lc kb ld kf le kj lf kn lg kr ky kz la lb bi translated"><a class="ae ks" href="https://medium.com/jorgeacetozi/kubernetes-master-components-etcd-api-server-controller-manager-and-scheduler-3a0179fc8186" rel="noopener"> Kubernetes主组件:Etcd、API服务器、控制器管理器和调度器</a></li><li id="6352" class="kt ku iq jw b jx lc kb ld kf le kj lf kn lg kr ky kz la lb bi translated"><a class="ae ks" href="https://kubernetes.io/docs/concepts/policy/resource-quotas/?origin_team=T08E6NNJJ" rel="noopener ugc nofollow" target="_blank">资源配额</a></li><li id="2112" class="kt ku iq jw b jx lc kb ld kf le kj lf kn lg kr ky kz la lb bi translated">库伯内特斯 ( <em class="mw"> все посты по тегу，интересный блог у человека </em>)</li><li id="cd4b" class="kt ku iq jw b jx lc kb ld kf le kj lf kn lg kr ky kz la lb bi translated"><a class="ae ks" href="https://kubernetes.io/docs/reference/kubectl/cheatsheet/?origin_team=T08E6NNJJ" rel="noopener ugc nofollow" target="_blank"> kubectl小抄</a></li><li id="186e" class="kt ku iq jw b jx lc kb ld kf le kj lf kn lg kr ky kz la lb bi translated"><a class="ae ks" href="https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/?origin_team=T08E6NNJJ" rel="noopener ugc nofollow" target="_blank">污点和宽容</a></li></ul><h2 id="9b53" class="lo lp iq bd lq lr ls dn lt lu lv dp lw kf lx ly lz kj ma mb mc kn md me mf mg bi translated">建立工作关系网</h2><ul class=""><li id="0d39" class="kt ku iq jw b jx mh kb mi kf np kj nq kn nr kr ky kz la lb bi translated"><a class="ae ks" href="https://kubernetes.io/docs/concepts/services-networking/service/?origin_team=T08E6NNJJ" rel="noopener ugc nofollow" target="_blank">服务</a></li><li id="0eea" class="kt ku iq jw b jx lc kb ld kf le kj lf kn lg kr ky kz la lb bi translated"><a class="ae ks" href="https://kubernetes.io/docs/concepts/cluster-administration/cloud-providers/?origin_team=T08E6NNJJ" rel="noopener ugc nofollow" target="_blank">云提供商</a></li><li id="a3a8" class="kt ku iq jw b jx lc kb ld kf le kj lf kn lg kr ky kz la lb bi translated"><a class="ae ks" href="https://supergiant.io/blog/understanding-kubernetes-kube-proxy/" rel="noopener ugc nofollow" target="_blank">了解Kubernetes Kube-Proxy </a></li><li id="2a6f" class="kt ku iq jw b jx lc kb ld kf le kj lf kn lg kr ky kz la lb bi translated"><a class="ae ks" href="https://www.bmc.com/blogs/kubernetes-services/" rel="noopener ugc nofollow" target="_blank"> Kubernetes服务:初学者指南</a></li><li id="e05e" class="kt ku iq jw b jx lc kb ld kf le kj lf kn lg kr ky kz la lb bi translated"><a class="ae ks" href="https://www.youtube.com/watch?v=5lzUpDtmWgM" rel="noopener ugc nofollow" target="_blank"> Kubernetes —服务说明</a></li><li id="3d51" class="kt ku iq jw b jx lc kb ld kf le kj lf kn lg kr ky kz la lb bi translated"><a class="ae ks" href="https://blog.giantswarm.io/load-balancer-service-use-cases-on-aws/" rel="noopener ugc nofollow" target="_blank">在AWS上使用Kubernetes负载平衡器服务</a></li></ul><h2 id="d379" class="lo lp iq bd lq lr ls dn lt lu lv dp lw kf lx ly lz kj ma mb mc kn md me mf mg bi translated">部署</h2><ul class=""><li id="995d" class="kt ku iq jw b jx mh kb mi kf np kj nq kn nr kr ky kz la lb bi translated"><a class="ae ks" href="https://www.weave.works/blog/kubernetes-deployment-strategies" rel="noopener ugc nofollow" target="_blank"> Kubernetes部署策略</a></li><li id="6403" class="kt ku iq jw b jx lc kb ld kf le kj lf kn lg kr ky kz la lb bi translated"><a class="ae ks" href="https://semaphoreci.com/blog/kubernetes-deployment/" rel="noopener ugc nofollow" target="_blank"> Kubernetes部署:终极指南</a></li><li id="0c5b" class="kt ku iq jw b jx lc kb ld kf le kj lf kn lg kr ky kz la lb bi translated"><a class="ae ks" href="https://devopscube.com/kubernetes-deployment-tutorial/" rel="noopener ugc nofollow" target="_blank"> Kubernetes初学者部署教程</a></li><li id="3369" class="kt ku iq jw b jx lc kb ld kf le kj lf kn lg kr ky kz la lb bi translated"><a class="ae ks" href="https://supergiant.io/blog/managing-kubernetes-deployments/" rel="noopener ugc nofollow" target="_blank">管理Kubernetes部署</a></li><li id="1c64" class="kt ku iq jw b jx lc kb ld kf le kj lf kn lg kr ky kz la lb bi translated"><a class="ae ks" href="https://medium.com/stakater/k8s-deployments-vs-statefulsets-vs-daemonsets-60582f0c62d4" rel="noopener"> K8s:部署vs状态集vs守护集</a></li></ul><h2 id="d7b1" class="lo lp iq bd lq lr ls dn lt lu lv dp lw kf lx ly lz kj ma mb mc kn md me mf mg bi translated">乔布斯</h2><ul class=""><li id="98aa" class="kt ku iq jw b jx mh kb mi kf np kj nq kn nr kr ky kz la lb bi translated"><a class="ae ks" href="https://medium.com/coryodaniel/working-with-kubernetes-jobs-848914418" rel="noopener">与Kubernetes Jobs合作</a></li><li id="84a1" class="kt ku iq jw b jx lc kb ld kf le kj lf kn lg kr ky kz la lb bi translated"><a class="ae ks" href="https://dotsandbrackets.com/one-off-kubernetes-jobs-ru/" rel="noopener ugc nofollow" target="_blank">однократныезадачив库伯内特</a></li></ul><h2 id="9099" class="lo lp iq bd lq lr ls dn lt lu lv dp lw kf lx ly lz kj ma mb mc kn md me mf mg bi translated">混杂的</h2><ul class=""><li id="8699" class="kt ku iq jw b jx mh kb mi kf np kj nq kn nr kr ky kz la lb bi translated"><a class="ae ks" rel="noopener ugc nofollow" target="_blank" href="/how-to-create-a-kubernetes-custom-controller-using-client-go-f36a7a7536cc">如何使用client-go创建Kubernetes定制控制器</a></li><li id="3ef3" class="kt ku iq jw b jx lc kb ld kf le kj lf kn lg kr ky kz la lb bi translated"><a class="ae ks" href="https://dzone.com/articles/kubernetes-knowhow-working-with-replicaset" rel="noopener ugc nofollow" target="_blank"> Kubernetes技术诀窍—使用复制集</a></li><li id="ade7" class="kt ku iq jw b jx lc kb ld kf le kj lf kn lg kr ky kz la lb bi translated"><a class="ae ks" href="https://dev.to/mostlyjason/intro-to-deployment-strategies-blue-green-canary-and-more-3a3" rel="noopener ugc nofollow" target="_blank">部署策略介绍:蓝绿色、淡黄色等</a></li></ul></div><div class="ab cl lh li hu lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ij ik il im in"><p id="8947" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><em class="mw">最初发布于</em> <a class="ae ks" href="https://rtfm.co.ua/en/kubernetes-part-1-architecture-and-main-components-overview/" rel="noopener ugc nofollow" target="_blank"> <em class="mw"> RTFM: Linux、DevOps和系统管理</em> </a> <em class="mw">。</em></p></div></div>    
</body>
</html>