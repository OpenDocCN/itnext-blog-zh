<html>
<head>
<title>Platform-as-Code: how it relates to Infrastructure-as-Code and what it enables</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">平台即代码:它与基础设施即代码的关系以及它能实现什么</h1>
<blockquote>原文：<a href="https://itnext.io/platform-as-code-how-it-compares-with-infrastructure-as-code-and-what-it-enables-2684b348be2e?source=collection_archive---------2-----------------------#2018-10-04">https://itnext.io/platform-as-code-how-it-compares-with-infrastructure-as-code-and-what-it-enables-2684b348be2e?source=collection_archive---------2-----------------------#2018-10-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="01d9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在之前的一篇文章中，我们在Kubernetes中概述了PaaS系统是如何向平台即代码发展的。在这篇文章中，我们来看看平台代码系统和基础设施代码系统的比较。</p><p id="a18e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">“原代码”系统是那些为供应和管理应用程序堆栈中元素提供声明性模型的系统。由Terraform和AWS CloudFormation等基础设施即代码系统开创的“即代码”方法在管理相应元素时提供了可重复性、可共享性和版本控制。</p><p id="a2fd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">“平台”系统是那些专注于为应用程序部署提供平台级功能的系统。由Heroku首创的平台级功能通常被理解为包括以下内容:</p><p id="5a84" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">(a)使用高级抽象表示应用程序及其所需的依赖关系(如数据库、负载平衡器),以及</p><p id="8fd6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">(b)应用程序的部署(来自源代码或预建容器),具有与其依赖项的适当绑定</p><p id="dbda" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，<em class="km">平台代码</em>系统可以被认为是以“代码”方式支持平台级功能的系统。这意味着，这样的系统能够使用高级声明性表示来定义应用程序及其平台依赖性；并使用该定义以可重复的方式支持应用程序堆栈的部署。</p><p id="ee4b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Kubernetes及其<a class="ae kl" rel="noopener ugc nofollow" target="_blank" href="/comparing-kubernetes-api-extension-mechanisms-of-custom-resource-definition-and-aggregated-api-64f4ca6d0966"> API扩展机制</a> ( <a class="ae kl" href="https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/" rel="noopener ugc nofollow" target="_blank">自定义资源</a>，自定义控制器和<a class="ae kl" href="https://coreos.com/operators/" rel="noopener ugc nofollow" target="_blank">操作符</a>)使得构建真正的平台即代码系统成为可能，该系统以声明的方式提供创建应用程序平台，将“即代码”系统的优势带到平台功能中。</p><h1 id="5440" class="kn ko iq bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated"><strong class="ak">平台即代码和基础设施即代码的比较</strong></h1><p id="aa34" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">在这里，我们将平台即代码的概念与现代基础设施即代码系统(如地形或云形成)进行比较。虽然IaC和PaC模型将像IaaS和PaaS模型一样相互补充，但这种比较将有助于用户了解PaC系统可以带来的独特方面。</p><ul class=""><li id="6f9f" class="lq lr iq jp b jq jr ju jv jy ls kc lt kg lu kk lv lw lx ly bi translated"><strong class="jp ir">平台即代码和基础设施即代码之间的相似性</strong></li></ul><p id="16d5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">1)声明性表示:两种类型的实现都基于使用声明性定义。这使得这些系统能够在管理相应的(基础设施或平台)元素时提供可重复性、可共享性和版本控制。</p><p id="f48f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2)基于差异的实现:这两种类型的系统都使用“基于差异的”实现，用所提供的输入将当前状态调和为新状态。</p><ul class=""><li id="e6be" class="lq lr iq jp b jq jr ju jv jy ls kc lt kg lu kk lv lw lx ly bi translated"><strong class="jp ir">平台即代码和基础设施即代码的区别</strong></li></ul><p id="3c85" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">PaC和IaC之间的关键区别在于<em class="km">每个模型如何实现其抽象。基础设施即代码是通过编写抽象作为底层基础设施层API的包装器来实现的。平台即代码是通过<a class="ae kl" rel="noopener ugc nofollow" target="_blank" href="/how-kubernetes-api-extensions-enable-platform-as-code-experience-cbb72b0970d9">编写抽象作为Kubernetes API扩展</a>来实现的，而不是在Kubernetes API上编写包装器。</em></p><p id="9e5c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这使得PaC抽象成为底层Kubernetes层的一级实体。这反过来允许利用“kubectl”来处理抽象(自定义资源)，而不是使用全新的CLI。相反，在基础设施即代码系统中，这是不可能的。IaC抽象是作为底层IaaS层上的包装器编写的，因此，在使用IaC系统时，必须使用新的CLI。</p><h1 id="e888" class="kn ko iq bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated"><strong class="ak">平台即代码体验的早期表现:</strong></h1><ol class=""><li id="ed43" class="lq lr iq jp b jq ll ju lm jy lz kc ma kg mb kk mc lw lx ly bi translated">Kubernetes运营商正在为平台元素构建数据库(<a class="ae kl" href="https://github.com/oracle/mysql-operator" rel="noopener ugc nofollow" target="_blank"> MySQL </a>)、<a class="ae kl" href="https://github.com/jetstack/cert-manager" rel="noopener ugc nofollow" target="_blank"> TLS证书管理</a>等。运营商为平台元素定义定制资源(例如:MySQLCluster、证书、发行商)。如果您在应用程序YAMLs中使用这样的定制资源以及本地Kubernetes资源，如部署、服务、配置映射，那么您实际上是在为您的应用程序创建一个定制平台作为代码(YAML文件)。</li><li id="7380" class="lq lr iq jp b jq md ju me jy mf kc mg kg mh kk mc lw lx ly bi translated">基于Git存储库中的工件协调集群状态的<a class="ae kl" href="https://github.com/hasura/gitkube" rel="noopener ugc nofollow" target="_blank"> GitOps模型</a>通常使用一个操作符来实现，该操作符监视Git存储库的变化，然后协调集群。自定义资源用作触发协调的机制。GitOps模型本质上是提供“git push to deploy”工作流，这是许多PaaS系统的典型特征，使用声明性定制资源。</li><li id="c42b" class="lq lr iq jp b jq md ju me jy mf kc mg kg mh kk mc lw lx ly bi translated">我们正在基于Moodle构建一个基于Kubernetes的电子学习解决方案。该系统需要管理Moodle实例的生命周期操作，如安装Moodle、安装Moodle插件、升级Moodle。我们正在为此创建一个Moodle操作器。这是一个用于Moodle应用程序的平台代码系统，其中Moodle自定义资源用于建模Moodle应用程序及其生命周期操作。Moodle控制器基于Moodle自定义资源输入实现状态协调逻辑。</li></ol><h1 id="8f95" class="kn ko iq bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated"><strong class="ak">平台即代码的未来——挑战与机遇</strong></h1><p id="5400" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">虽然Kubernetes操作符的概念允许我们用新的客户资源扩展Kubernetes，但是复杂的应用程序平台将需要在一个Kubernetes集群中有多个这样的操作符。例如，我们将使用MySQL、LetsEncrypt和Moodle这三种操作系统为我们的一个客户提供一个PaC系统，构建一个电子学习解决方案。</p><p id="40ac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这样一个多运营商的世界中，出现了以下挑战。</p><p id="151f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">1.<em class="km">自定义资源的发现:</em></p><p id="0721" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当使用多个操作符时，应用程序开发人员发现集群中可用的各种定制资源的能力成为一个挑战——所有可用的定制资源是什么？它们的属性是什么？如何使用它们？应用程序开发人员可以查阅每个运营商的文档来查找这些信息，但这不是一种用户友好的方法。我们需要Kubernetes的本地方式来找到这些信息。对于标准的Kubernetes对象，有“kubectl explain”。我们需要<a class="ae kl" href="https://medium.com/@cloudark/understanding-kubectl-explain-9d703396cc8" rel="noopener">定制资源</a>类似的东西。</p><p id="4828" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2.<em class="km">自定义资源可组合性:</em></p><p id="9c26" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">另一个挑战是不同的定制资源如何协同工作。例如，MySQL自定义资源和备份自定义资源都可以使用卷。如何确保这两种定制资源在其操作中使用相同的卷？一种方法可能是使用资源名。他们总是去工作吗？如果没有，可以用标签吗？目前没有关于运营商需要支持什么功能的标准。我们正在制定在这方面有所帮助的指南。</p><p id="d5e1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">3.<em class="km">自定义资源的可追溯性:</em></p><p id="32a4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Kubernetes自定义资源扩展了基本API，以声明方式管理第三方平台元素。重要的是跟踪在定制资源上执行的各种声明性操作，以了解这些操作如何影响底层平台元素——例如，对于Postgres定制资源的实例，我们可能想知道:创建了多少个数据库用户，数据库用户的密码何时被更改，等等。为此，我们需要一种通用的方法来维护定制资源的出处信息。</p><h1 id="35b4" class="kn ko iq bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated"><strong class="ak">平台即代码能够实现什么？</strong></h1><p id="a20c" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">平台即代码模型为弥合开发人员和运营人员之间的鸿沟提供了机会。</p><figure class="mj mk ml mm gt mn gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi mi"><img src="../Images/42e228c5eb8f6484249182109a3109e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*91EXFhoDXsi6bz8ka3rVcw.jpeg"/></div></div></figure><p id="ff9f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这些年来，已经发展出两种类型的工具。一组可以大致归类为PaaS，专注于交付端到端的开发人员工作流，试图消除对Ops工程师的需求。另一组可以大致归类为“基础设施即代码”,侧重于简化自动化和资源调配方面的运营挑战。在实践中，当由开发人员和运营工程师组成的团队一起构建应用程序部署工作流时，他们会因为缺少公共工具而出现沟通障碍。这通常会迫使开发人员至少学习Ops系统和工具的基础知识，以便能够在DevOps工作流中做出有意义的贡献。例如，开发人员可能需要理解反向代理这样的概念，以及如何配置Nginx/Apache这样的系统来部署web应用程序。有了平台即代码(Kubernetes +所需平台元素的操作者)，Kubernetes YAML有可能成为开发人员和运营人员之间的通用语言，从而弥合这一鸿沟。</p><p id="a146" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们预计，运营团队将参与为数据库、负载平衡器、记录器等平台元素选择Kubernetes运营商。这是应用程序所需要的。利用他们现有的运营知识，他们将帮助应用程序开发人员正确配置和使用与Kubernetes运营商管理的各种平台元素相对应的定制资源。应用程序开发人员将专注于消费这些定制资源来构建他们的应用程序平台，并且还可以根据需要在上面添加新的操作符(例如:Moodle)。这种合作将利用Kubernetes YAML作为共同语言。</p><p id="2d84" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="http://www.cloudark.io" rel="noopener ugc nofollow" target="_blank"> www.cloudark.io </a></p></div></div>    
</body>
</html>