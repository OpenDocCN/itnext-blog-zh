<html>
<head>
<title>The fundamentals of microservices-oriented architecture</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向微服务架构的基础</h1>
<blockquote>原文：<a href="https://itnext.io/the-fundamentals-of-microservices-oriented-architecture-8779d756f70f?source=collection_archive---------3-----------------------#2020-01-19">https://itnext.io/the-fundamentals-of-microservices-oriented-architecture-8779d756f70f?source=collection_archive---------3-----------------------#2020-01-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/4640210c7263bff19126a58b9efe4b98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xPN1TMIK_kHoVBcQLKErYA.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">凯文·Ku在<a class="ae kc" href="https://unsplash.com/s/photos/code?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="556b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">微服务架构近年来越来越受欢迎；有一个很好的理由:正确实施，微服务可以带来许多优势，这些优势在我们现代的云计算时代尤为重要。</p><p id="895b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这篇博客中，我们关注支撑面向微服务架构的几个重要架构基础。对这些基本原则的深刻理解有助于创建更好的软件架构，这些架构是有弹性的、可扩展的、成熟的，当然也是面向微服务的。</p><h2 id="b628" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">想想分布式计算的谬误</h2><p id="56b1" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated"><a class="ae kc" href="https://en.wikipedia.org/wiki/Distributed_computing" rel="noopener ugc nofollow" target="_blank">分布式计算</a>并不是一个新概念；事实上，互联网本身就是一个巨大的分布式计算系统。根据定义，微服务属于分布式系统的范畴。</p><blockquote class="lz ma mb"><p id="cb49" class="kd ke mc kf b kg kh ki kj kk kl km kn md kp kq kr me kt ku kv mf kx ky kz la ij bi translated"><strong class="kf ir">分布式计算的吸引力在于能够利用多种并行计算资源的能力，并利用现代云计算产品实现几乎无限的扩展。</strong></p></blockquote><p id="6caf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，分布式系统本质上是在一个不可预测的环境中运行的，在这个环境中很多事情都可能出错。一个非常常见的陷阱是，我们对待分布式计算系统的信任程度与对待本地非分布式环境的信任程度相同。</p><blockquote class="lz ma mb"><p id="a484" class="kd ke mc kf b kg kh ki kj kk kl km kn md kp kq kr me kt ku kv mf kx ky kz la ij bi translated"><strong class="kf ir">分布式计算的</strong> <a class="ae kc" href="https://medium.com/baseds/foraging-for-the-fallacies-of-distributed-computing-part-1-1b35c3b85b53" rel="noopener"> <strong class="kf ir">谬误</strong> </a> <strong class="kf ir">帮助我们理解我们对分布式系统最常见的错误假设。</strong></p></blockquote><p id="2921" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面的列表在理想世界中是正确的，但是在我们不完美的现实中，做出这些假设是危险的:</p><ul class=""><li id="3c96" class="mg mh iq kf b kg kh kk kl ko mi ks mj kw mk la ml mm mn mo bi translated">网络是可靠的</li><li id="bdda" class="mg mh iq kf b kg mp kk mq ko mr ks ms kw mt la ml mm mn mo bi translated">延迟为零</li><li id="f74a" class="mg mh iq kf b kg mp kk mq ko mr ks ms kw mt la ml mm mn mo bi translated">带宽是无限的</li><li id="7952" class="mg mh iq kf b kg mp kk mq ko mr ks ms kw mt la ml mm mn mo bi translated">网络是安全的</li><li id="1b97" class="mg mh iq kf b kg mp kk mq ko mr ks ms kw mt la ml mm mn mo bi translated">拓扑不会改变</li><li id="e891" class="mg mh iq kf b kg mp kk mq ko mr ks ms kw mt la ml mm mn mo bi translated">只有一个管理员</li><li id="087c" class="mg mh iq kf b kg mp kk mq ko mr ks ms kw mt la ml mm mn mo bi translated">运输成本为零</li><li id="cd33" class="mg mh iq kf b kg mp kk mq ko mr ks ms kw mt la ml mm mn mo bi translated">网络是同构的</li></ul><p id="039f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上述情况尤其适用于基于微服务的系统，根据定义，这些系统是分布式的。</p><h2 id="9f67" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">承诺理论</h2><p id="1dd8" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">微服务通常通过以下方式受益于异步通信:</p><ul class=""><li id="25c6" class="mg mh iq kf b kg kh kk kl ko mi ks mj kw mk la ml mm mn mo bi translated">Kafka、RabbitMQ或云提供商本地服务总线产品等排队机制</li><li id="1d97" class="mg mh iq kf b kg mp kk mq ko mr ks ms kw mt la ml mm mn mo bi translated">HTTP、TCP上的异步调用，最流行的是REST API模型和gRPC调用。</li></ul><p id="8167" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae kc" href="https://www.youtube.com/watch?v=2TPsB5WuZgk" rel="noopener ugc nofollow" target="_blank"> Promise Theory </a>对微服务架构的主要贡献是能够脱离通信的<em class="mc">义务概念</em>——其中发送者和接收者都相互依赖，并且必须在通信过程中保持活跃——而转向<em class="mc">承诺概念</em>。</p><blockquote class="lz ma mb"><p id="60bc" class="kd ke mc kf b kg kh ki kj kk kl km kn md kp kq kr me kt ku kv mf kx ky kz la ij bi translated"><strong class="kf ir"> Promises概念假设作为分布式系统的一部分，相互协作的系统和服务具有自治性和独立性。</strong></p></blockquote><h2 id="4e82" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">演员模型</h2><p id="db31" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated"><a class="ae kc" href="https://en.wikipedia.org/wiki/Actor_model" rel="noopener ugc nofollow" target="_blank"> Actor model </a>试图通过引入“Actors”的概念来对域建模，类似于使用“对象”的面向对象编程(OOP)和使用“函数”的函数式编程(FP ),作为任何给定域的基础一级公民构建块。</p><p id="6634" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">参与者是一个计算实体，它可以响应收到的消息，同时:</p><ul class=""><li id="161e" class="mg mh iq kf b kg kh kk kl ko mi ks mj kw mk la ml mm mn mo bi translated">向其他参与者发送有限数量的消息；</li><li id="8261" class="mg mh iq kf b kg mp kk mq ko mr ks ms kw mt la ml mm mn mo bi translated">创造有限数量的新演员；</li><li id="a07a" class="mg mh iq kf b kg mp kk mq ko mr ks ms kw mt la ml mm mn mo bi translated">指定它接收的下一条消息要使用的行为。</li></ul><p id="c791" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">参与者模型也是一种描述分布式系统中自治参与者之间交互的方法。这种模式通过包含自治的不确定性(参与者A不能强迫参与者B)来允许容错和弹性。承诺理论引入了交流参与者自主性的概念。</p><blockquote class="lz ma mb"><p id="2b64" class="kd ke mc kf b kg kh ki kj kk kl km kn md kp kq kr me kt ku kv mf kx ky kz la ij bi translated"><strong class="kf ir">参与者模型帮助我们理解如何应对并发性、状态管理和一致性方面的挑战。</strong></p></blockquote><h2 id="764f" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">事件驱动架构</h2><p id="c930" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated"><a class="ae kc" href="https://microservices.io/patterns/data/event-driven-architecture.html" rel="noopener ugc nofollow" target="_blank">事件驱动架构</a>通过引入“事件”的概念，或者简单地说，重要的状态变化，进一步促进了异步和解耦通信。</p><blockquote class="lz ma mb"><p id="e949" class="kd ke mc kf b kg kh ki kj kk kl km kn md kp kq kr me kt ku kv mf kx ky kz la ij bi translated"><strong class="kf ir">相互协作的微服务可以在自己的时间内完全自主地对事件做出反应</strong>。</p></blockquote><p id="1689" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它带来了对数据交换的动态本质及其对体系结构的影响的更深入的理解。</p><p id="049a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种类型的通信有一些非常著名的实现，如无服务器计算、事件源或CQRS。</p><h2 id="bd4b" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">CAP定理</h2><p id="4a55" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated"><a class="ae kc" href="https://www.ibm.com/cloud/learn/cap-theorem" rel="noopener ugc nofollow" target="_blank"> CAP定理</a>指出，在分布式系统中，就数据管理而言，不可能提供以下三种保证中的两种以上:</p><ul class=""><li id="16c5" class="mg mh iq kf b kg kh kk kl ko mi ks mj kw mk la ml mm mn mo bi translated">一致性:所有客户端都有相同的数据表示</li><li id="05ed" class="mg mh iq kf b kg mp kk mq ko mr ks ms kw mt la ml mm mn mo bi translated">可用性:每个客户端都可以在任何时间点读写数据</li><li id="57d4" class="mg mh iq kf b kg mp kk mq ko mr ks ms kw mt la ml mm mn mo bi translated">分区容差:物理数据分区不影响系统的功能</li></ul><blockquote class="lz ma mb"><p id="32c5" class="kd ke mc kf b kg kh ki kj kk kl km kn md kp kq kr me kt ku kv mf kx ky kz la ij bi translated">牢记CAP定理有助于我们根据需求和用例选择最佳组合。</p></blockquote><h2 id="152e" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">UNIX哲学</h2><p id="5f6d" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">伟大的软件架构通常由它们的老化程度来判断。最古老的体系结构之一，并且至今仍然非常相关的是<a class="ae kc" href="https://homepage.cs.uri.edu/~thenry/resources/unix_art/ch01s06.html" rel="noopener ugc nofollow" target="_blank"> Unix哲学</a>。</p><blockquote class="lz ma mb"><p id="04b5" class="kd ke mc kf b kg kh ki kj kk kl km kn md kp kq kr me kt ku kv mf kx ky kz la ij bi translated"><strong class="kf ir">UNIX哲学的核心思想是每个程序都应该做好一件事，并通过定义良好的接口与其他程序协作。</strong></p></blockquote><p id="e16b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Peter H. Salus很好地总结了UNIX哲学准则。在Unix的四分之一世纪里:</p><p id="0361" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这就是Unix的哲学:编写程序，让<strong class="kf ir">做一件事，并把它做好</strong>。写程序给<strong class="kf ir">一起工作</strong>。编写处理文本流的程序，因为那是一个<strong class="kf ir">通用接口</strong>。</p><h2 id="e139" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">十二因素应用程序方法</h2><p id="a550" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated"><a class="ae kc" href="https://12factor.net/" rel="noopener ugc nofollow" target="_blank">十二因素应用方法</a>是一套非常有用的原则和指南，用于开发基于微服务的架构，有助于避免软件设计过程中最常见的陷阱和问题。以下是12个因素:</p><ul class=""><li id="97a4" class="mg mh iq kf b kg kh kk kl ko mi ks mj kw mk la ml mm mn mo bi translated">代码库:一个在版本控制中跟踪的代码库，多个部署</li><li id="3b6b" class="mg mh iq kf b kg mp kk mq ko mr ks ms kw mt la ml mm mn mo bi translated">依赖关系:显式声明并隔离依赖关系</li><li id="d748" class="mg mh iq kf b kg mp kk mq ko mr ks ms kw mt la ml mm mn mo bi translated">配置:在环境中存储配置</li><li id="a453" class="mg mh iq kf b kg mp kk mq ko mr ks ms kw mt la ml mm mn mo bi translated">后台服务:将后台服务视为附属资源</li><li id="22ee" class="mg mh iq kf b kg mp kk mq ko mr ks ms kw mt la ml mm mn mo bi translated">构建、发布、运行:严格分离构建和运行阶段</li><li id="2a4c" class="mg mh iq kf b kg mp kk mq ko mr ks ms kw mt la ml mm mn mo bi translated">进程:将应用程序作为一个或多个无状态进程来执行</li><li id="001e" class="mg mh iq kf b kg mp kk mq ko mr ks ms kw mt la ml mm mn mo bi translated">端口绑定:通过端口绑定导出服务</li><li id="294d" class="mg mh iq kf b kg mp kk mq ko mr ks ms kw mt la ml mm mn mo bi translated">并发性:通过流程模型向外扩展</li><li id="8b60" class="mg mh iq kf b kg mp kk mq ko mr ks ms kw mt la ml mm mn mo bi translated">一次性:快速启动和正常关机，最大限度地提高耐用性</li><li id="2d3b" class="mg mh iq kf b kg mp kk mq ko mr ks ms kw mt la ml mm mn mo bi translated">开发/生产对等:使开发、试运行和生产尽可能相似</li><li id="212c" class="mg mh iq kf b kg mp kk mq ko mr ks ms kw mt la ml mm mn mo bi translated">日志:将日志视为事件流</li><li id="7538" class="mg mh iq kf b kg mp kk mq ko mr ks ms kw mt la ml mm mn mo bi translated">管理流程:将管理任务作为一次性流程运行</li></ul><blockquote class="lz ma mb"><p id="1a0b" class="kd ke mc kf b kg kh ki kj kk kl km kn md kp kq kr me kt ku kv mf kx ky kz la ij bi translated"><strong class="kf ir">12因素应用方法帮助我们设计软件，并以与现代微服务架构一致的方式支持开发运维流程。</strong></p></blockquote><h2 id="b276" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">把所有的放在一起</h2><p id="9316" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">使用微服务方法设计一个好的架构是非常具有挑战性的。应用来自上述理论和模型的知识可以帮助创建任何架构的初稿:</p><ol class=""><li id="3258" class="mg mh iq kf b kg kh kk kl ko mi ks mj kw mk la mu mm mn mo bi translated">从理解分布式系统环境中的需求及其谬误开始。系统需要跨越多个数据中心吗？你打算如何解决分布式计算的八个谬误？您的系统会利用公共云产品吗？</li><li id="f1b2" class="mg mh iq kf b kg mp kk mq ko mr ks ms kw mt la mu mm mn mo bi translated">考虑服务将如何通信。作为交流的结果，是否需要管理状态(参与者模型)？是否需要对事件做出反应(基于事件的架构)？</li><li id="f9e0" class="mg mh iq kf b kg mp kk mq ko mr ks ms kw mt la mu mm mn mo bi translated">数据管理有什么要求？哪个微服务应该满足CAP定理的哪两个要素？</li><li id="85e6" class="mg mh iq kf b kg mp kk mq ko mr ks ms kw mt la mu mm mn mo bi translated">如何通过提供和帮助引入面向微服务的设计模式和实践(十二要素应用和UNIX哲学)来支持开发人员？</li></ol><h2 id="3122" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">结论</h2><p id="2f51" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">基于微服务的分布式系统的架构是一项复杂的任务，涉及的内容远不止这篇博客中提到的；我们没有将安全性、测试、开发运维、基础设施作为代码来讨论，只是提到了几个重要的主题。</p><p id="a541" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">目标是让有抱负的软件架构师了解基于微服务的系统的理论基础，并给更有经验的架构师一些启发。在我看来，让自己熟悉这些理论，知道什么时候应用哪个是值得努力的。</p><p id="81ef" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你可以在<a class="ae kc" href="https://github.com/Piotr1215?tab=repositories" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到我，或者在回复区留言。我很想听听你在设计基于微服务的架构方面的经验，以及是什么帮助你让你的架构变得伟大。</p></div></div>    
</body>
</html>