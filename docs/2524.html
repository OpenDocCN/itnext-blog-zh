<html>
<head>
<title>I Flink You Freaky And I like you a lot!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我觉得你很奇怪，我很喜欢你！</h1>
<blockquote>原文：<a href="https://itnext.io/i-flink-you-freaky-and-i-like-you-a-lot-68554f7629df?source=collection_archive---------3-----------------------#2019-06-07">https://itnext.io/i-flink-you-freaky-and-i-like-you-a-lot-68554f7629df?source=collection_archive---------3-----------------------#2019-06-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="8b2e" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">或者……如何为Flink jobs建立自己的Kubernetes运营商</h2></div><p id="1119" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">TL；DR —你可以在这里找到所有的代码和文档！</p><p id="2d49" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">…但让我们回到一切开始的地方</p><p id="11b2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">[淡出…淡入…]六个月前…</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi lc"><img src="../Images/5c1983fb66b861527bb56d51ae1b0317.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*wNe01uWnZ0sbJ2HUnKnAUg.gif"/></div></figure><h1 id="0a03" class="lk ll iq bd lm ln lo lp lq lr ls lt lu jw lv jx lw jz lx ka ly kc lz kd ma mb bi translated">"库伯内特:去了又回来！"</h1><p id="77f0" class="pw-post-body-paragraph kf kg iq kh b ki mc jr kk kl md ju kn ko me kq kr ks mf ku kv kw mg ky kz la ij bi translated">像大多数公司一样——当我们在<a class="ae lb" href="http://dav.network/" rel="noopener ugc nofollow" target="_blank"> DAV </a>开始创建后端时，我们采取了一些可能会极大影响我们产品的架构决策。</p><p id="8ec6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们对<a class="ae lb" href="https://kubernetes.io/" rel="noopener ugc nofollow" target="_blank"> K8S </a>足够成熟非常有信心，<a class="ae lb" href="http://cassandra.apache.org/" rel="noopener ugc nofollow" target="_blank">卡珊德拉</a>和<a class="ae lb" href="https://kafka.apache.org/" rel="noopener ugc nofollow" target="_blank">卡夫卡</a>也是一个确定无疑的赌注。</p><p id="5481" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">选择流处理器不是一个容易的选择。Apache BEAM 是一个显而易见的解决方案，但是即使BEAM允许我们相当容易地将相同的代码迁移到一个新的runner上，runner也是一个选择。</p><p id="5b94" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">经过初步筛选后，选择了<a class="ae lb" href="https://spark.apache.org/" rel="noopener ugc nofollow" target="_blank"> Apache Spark </a>和<a class="ae lb" href="https://flink.apache.org/" rel="noopener ugc nofollow" target="_blank"> Apache Flink </a>。两者都在Apache的保护伞下，既快速又可伸缩。斯帕克更成熟、更普通，而弗林克是街区里的新人。</p><p id="7496" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为内心年轻，我们选择了弗林克。</p></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h1 id="2fd8" class="lk ll iq bd lm ln mo lp lq lr mp lt lu jw mq jx lw jz mr ka ly kc ms kd ma mb bi translated">弗林克</h1><p id="6aee" class="pw-post-body-paragraph kf kg iq kh b ki mc jr kk kl md ju kn ko me kq kr ks mf ku kv kw mg ky kz la ij bi translated"><em class="mt">如果您已经熟悉K8S上的Flink，请跳到下一部分。</em></p><p id="96e5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在K8S上设置Flink集群非常容易。我们为JobManager(Flink主机)提供了一个pod Statefulset，为task manager(Flink workers)提供了一个部署，为job manager提供了一个服务。您只需将TaskManagers指向JobManager URL，集群就设置好了。该服务公开了一个8081端口，您可以在浏览器中打开该端口，了解Flink集群的当前状态。它显示作业管理器配置、连接的任务管理器及其配置以及作业——正在运行、已完成等..您还可以通过UI执行大多数操作，例如部署新的工作负载、停止或取消正在运行的作业、查看作业日志等。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi mu"><img src="../Images/0df662a65bbaa0c4edf6c919ef5312f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xJUWxYAdodlS1HWDA3j-7w.png"/></div></div><figcaption class="mz na gj gh gi nb nc bd b be z dk translated">K8S仪表板视图—简单的Flink集群(单个工人)</figcaption></figure><p id="f925" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Flink还有一个RESTful api和一个CLI可以与之交互。我选择使用CLI从我的配置项/光盘中自动执行任务。我们需要的是能够向Flink提交作业，检测作业正在运行，并能够停止/取消正在运行的作业。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi nd"><img src="../Images/55d2e57706c8f8ae691aa0a4b13ceb99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dp11XNUqIauBg2VjqoDTgg.png"/></div></div><figcaption class="mz na gj gh gi nb nc bd b be z dk translated">Flink UI(概览页面)</figcaption></figure></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h1 id="4ca5" class="lk ll iq bd lm ln mo lp lq lr mp lt lu jw mq jx lw jz mr ka ly kc ms kd ma mb bi translated">阿帕奇波束</h1><p id="a50a" class="pw-post-body-paragraph kf kg iq kh b ki mc jr kk kl md ju kn ko me kq kr ks mf ku kv kw mg ky kz la ij bi translated"><em class="mt">如果您已经熟悉射束管道，请跳到下一部分。</em></p><p id="42fd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Apache BEAM是一个API，它可以生成管道工作流，并且能够在多个运行器上运行这些工作流(例如Spark、Flink、Airflow等)。它以几乎相同的接口支持批处理和流式管道，使得在两种模式下运行相同的代码非常简单。它由Google发布，基本上是他们第一个数据流API的重新设计——自从发布以来，它已经得到了广泛的改进，在原始的Java API中添加了Python API。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi ne"><img src="../Images/b6709755c551cb55ad2e2c365fd434f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m0KXlJ1R_UUO_b5LKS0nRg.png"/></div></div></figure><p id="7c0e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">波束管道是非循环有向图，其中每个节点是数据元素的集合(有界或无界)，每个边是从一个集合到不同集合的转换(可能在类型、大小等方面不同)</p><p id="0689" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">管道由使用API的代码定义。然后，API根据给定的管道和各种管道选项(包括运行程序的类型)生成图形，并将其发送给运行程序执行。</p><p id="38e7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">BEAM中元素集合的基本形式是“p集合”。它表示元素的集合，可以是有界的，即具有有限的大小，也可以是无界的，即可能具有无限的大小。这允许编写处理流和批处理数据收集的代码。</p><p id="a111" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">波束变换的基本形式称为“p变换”。它定义了从一个p集合到另一个p集合的转换。将PTransforms应用于PCollections以创建新的PCollections，从而形成管道图。</p><p id="ce1f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">更高级的用法可能包括辅助输入和辅助输出、聚合、窗口和连接，但那是以后的事情了。</p><p id="3a72" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">管道通常从应用特殊的PTransform开始，该p transform表示要拉入管道的数据源。这些被称为“源”。类似地，它们常常通过应用“Sink”p transform将数据发送到某个外部端点(即数据库、存储甚至API)来结束。</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="nf ng l"/></div><figcaption class="mz na gj gh gi nb nc bd b be z dk translated">使用Flink作为流道的简单射束管道</figcaption></figure></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h1 id="459e" class="lk ll iq bd lm ln mo lp lq lr mp lt lu jw mq jx lw jz mr ka ly kc ms kd ma mb bi translated">开始退缩了！</h1><p id="0328" class="pw-post-body-paragraph kf kg iq kh b ki mc jr kk kl md ju kn ko me kq kr ks mf ku kv kw mg ky kz la ij bi translated"><em class="mt">如果你只是对我感到非常厌烦，想开门见山，请跳到下一部分。</em></p><p id="35ba" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们有了一个工作的BEAM管道和K8S中的Flink集群，我们需要做的就是运行它。</p><p id="cb82" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="mt">flink run-m&lt;JOB manager _ URL&gt;T8】JAR _ PATH&gt;-c&lt;JOB _ class name&gt;T5】</em></p><p id="1980" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">会把工作交给弗林克。然后，您可以在Flink Web UI中看到它的运行。</p><p id="35b3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是如果工作失败了会怎么样呢？如何才能确保重启？</p><p id="7201" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最直接的解决方法是，只要检测到作业没有运行，就运行“flink”CLI。一个简单的狂欢就能做到。但是，我们如何确保这个脚本保持运行。我们需要为我们监控和管理的资源。想到了一个K8S pod。</p><p id="3a28" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们为每个Flink作业创建了一个K8S部署，其中一个Pod运行一个bash脚本，该脚本提交作业、监控作业并在作业失败时重新提交。pod运行一个Docker映像，其中包含JAR形式的代码。</p><p id="6e46" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一个缺点是，当我们必须部署新版本的代码时，我们必须手动停止Flink作业，以使新的pods检测到它，并使用最新的代码重新提交作业。</p><p id="60b2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们开始有更多的工作时，另一个不利因素就很明显了。创建K8S清单脚本的开销变成了一项非常耗时的任务。</p><p id="f946" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们需要将它提升到一个新的水平，并在最大限度地减少配置量的同时完全自动化这一过程。</p></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h1 id="f6bc" class="lk ll iq bd lm ln mo lp lq lr mp lt lu jw mq jx lw jz mr ka ly kc ms kd ma mb bi translated">权力越大，责任越大</h1><p id="7612" class="pw-post-body-paragraph kf kg iq kh b ki mc jr kk kl md ju kn ko me kq kr ks mf ku kv kw mg ky kz la ij bi translated">今天的主角是K8S和一个不太常见的附加组件—“<a class="ae lb" href="https://metacontroller.app/" rel="noopener ugc nofollow" target="_blank">元控制器</a>”。</p><p id="f544" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Metacontroller出自Google。它利用了一个名为“<a class="ae lb" href="https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/#customresourcedefinitions" rel="noopener ugc nofollow" target="_blank">customresourcediation</a>”的K8S对象，简称为CRD。CRD是在K8S中定义新的(自定义)对象的对象，因此允许您自定义和扩展K8S。扩展K8S的另一种方式是使用<a class="ae lb" href="https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/#api-server-aggregation" rel="noopener ugc nofollow" target="_blank"> API服务器聚合</a>——这可能更强大，但需要更多的工作。</p><p id="f4d0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Metacontroller提供了两个元对象——定义新对象的对象——<a class="ae lb" href="https://metacontroller.app/api/decoratorcontroller/" rel="noopener ugc nofollow" target="_blank">decorator controller</a>,这是向现有对象(以及更多)添加功能的好方法，以及<a class="ae lb" href="https://metacontroller.app/api/compositecontroller/" rel="noopener ugc nofollow" target="_blank"> CompositeController </a>,它定义包含/拥有子资源的对象。</p><p id="3630" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要创建自己的CompositeController，首先需要定义一个CRD。CRD定义您的自定义对象以及它将如何显示给用户。它必须声明名称(复数和单数—大小写很重要)。它还使用<a class="ae lb" href="https://www.openapis.org/" rel="noopener ugc nofollow" target="_blank"> OpenAPI </a>声明定制属性的模式(有一些限制)。它允许您定义对象将如何出现在K8S CLI中，以及许多其他选项来控制它在K8S上的行为。我们Flink Jobs的CRD看起来有点像<a class="ae lb" href="https://github.com/srfrnk/k8s-flink-operator/blob/master/components/crd.jsonnet" rel="noopener ugc nofollow" target="_blank">这个</a>:</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="nf ng l"/></div><figcaption class="mz na gj gh gi nb nc bd b be z dk translated">一份K8S CRD的工作清单</figcaption></figure><p id="1b91" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最重要的挂钩是“同步”挂钩。Metacontroller调用这个钩子来检查子资源的状态，并在父对象定义改变时创建/删除。此时它可以是一个WebHook，这意味着您需要创建一个HTTP服务来处理这些调用。</p><p id="59e6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">任何支持HTTP的服务都可以在这里使用，但是由于我们使用K8S，创建该服务的最佳方式是使用带有服务的Deployment/Statefulset。</p><p id="57a2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们使用了一个由Statefulset部署的<a class="ae lb" href="https://expressjs.com/" rel="noopener ugc nofollow" target="_blank"> NodeJS ExpressJS </a>服务器。</p><p id="5819" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae lb" href="https://github.com/srfrnk/k8s-flink-operator/tree/master/controller-app" rel="noopener ugc nofollow" target="_blank">服务器代码</a>监听”。/sync "调用并通过发送包含“状态”的JSON对象和childreen资源的K8S清单对象列表进行响应。“状态”可以是任何东西，但你可以看到其他k8如何报告状态，以符合惯例。服务器代码如下所示:</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="nf ng l"/></div><figcaption class="mz na gj gh gi nb nc bd b be z dk translated">控制器index.js的框架结构</figcaption></figure><p id="3804" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">与所有K8S清单脚本一样，Metacontroller使用声明性声明——这意味着您的sync hook应该只响应<strong class="kh ir">期望的</strong>状态，metacontoller将处理其余部分。不需要审问当前状态。事实上，如果给定了相同的父规范，你的代码应该总是返回完全相同的子资源清单。</p><p id="cbf2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们的例子中，我们选择创建一个Statefulset来处理每个作业。我们还创建了一个ConfigMap，它将一个启动shell脚本注入其中一个容器。</p><p id="c04e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当用户创建FlinkJob对象时，他们将定义Flink JobManager URL以及在哪里找到要运行的类的信息。为了定义这一点，他们需要创建一个Docker映像，其中包含一个带有编译代码的JAR。他们还将指定副本数量。</p><p id="e60d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于一个特定的FlinkJob，我们将创建一个Statefulset，其副本数量与FlinkJob规范中指定的一样多。这将导致K8S为每个副本创建一个pod。每一个pod负责一个运行在Flink上的任务。它需要在创建pod时启动作业，监视作业，并在pod完成时停止作业。</p><p id="0f78" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了能够读取包含作业代码的jar，pod运行“JAR”容器——它的唯一目的是将JAR挂载到与主“作业”容器共享的卷中。</p><p id="8247" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">“作业”容器然后通过运行flink CLI提交作业来启动。然后，它将等待，直到被中断停止作业，然后退出:</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="d94f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这负责启动和停止作业。为了监控停止或崩溃的作业，我们尽可能地使用K8S内置机制。</p><p id="86a3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们想要确保一个崩溃的任务重新启动时，我们现在需要做的就是让K8S用一个新的pod替换它。当pod意外终止时，这由Statefulset自动处理。为了使pod在作业终止时退出，我们使用了一个<a class="ae lb" href="https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes" rel="noopener ugc nofollow" target="_blank">容器活性探测器</a>。我们定义了“作业”容器的活性探测，以使用Flink CLI来检查作业是否是活动的。如果它在运行作业列表中找不到作业，它将使活性探测失败，导致容器报告它已死亡，最终触发pod回收。定义的<a class="ae lb" href="https://github.com/srfrnk/k8s-flink-operator/blob/master/job-app/check.sh" rel="noopener ugc nofollow" target="_blank">代码如下所示:</a></p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="nf ng l"/></div><figcaption class="mz na gj gh gi nb nc bd b be z dk translated">“作业”容器规格</figcaption></figure><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="nf ng l"/></div><figcaption class="mz na gj gh gi nb nc bd b be z dk translated">check.sh</figcaption></figure></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h1 id="65a3" class="lk ll iq bd lm ln mo lp lq lr mp lt lu jw mq jx lw jz mr ka ly kc ms kd ma mb bi translated">运行库贝克运行…</h1><p id="96d3" class="pw-post-body-paragraph kf kg iq kh b ki mc jr kk kl md ju kn ko me kq kr ks mf ku kv kw mg ky kz la ij bi translated">要开始使用新的CRD，我们首先需要将元控制器部署到我们的集群中。</p><p id="c612" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为此，我们只需运行:</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="9502" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，要部署k8s-flink-operator CRD，只需运行以下命令:</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="9725" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">完整的源代码和文档可以在<a class="ae lb" href="https://github.com/srfrnk/k8s-flink-operator" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="2137" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，要将您的工作部署为FlinkJob，您现在需要做的是:</p><ol class=""><li id="c5d4" class="nh ni iq kh b ki kj kl km ko nj ks nk kw nl la nm nn no np bi translated">创建一个BEAM管道并编译到一个JAR中。</li><li id="cd11" class="nh ni iq kh b ki nq kl nr ko ns ks nt kw nu la nm nn no np bi translated">创建一个包含JAR的Docker映像。</li><li id="9eb6" class="nh ni iq kh b ki nq kl nr ko ns ks nt kw nu la nm nn no np bi translated">为FlinkJob对象部署清单。</li></ol><p id="2e04" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以看到用一个JAR创建Docker图像的代码，这个JAR包含一个简单的BEAM管道<a class="ae lb" href="https://github.com/srfrnk/k8s-flink-operator/tree/master/test" rel="noopener ugc nofollow" target="_blank">这里是</a>。</p><p id="f55d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">部署它的清单就像<a class="ae lb" href="https://github.com/srfrnk/k8s-flink-operator/blob/master/test/flink-streaming-job.json" rel="noopener ugc nofollow" target="_blank"> this </a>一样简单:</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="nf ng l"/></div></figure></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h1 id="9f83" class="lk ll iq bd lm ln mo lp lq lr mp lt lu jw mq jx lw jz mr ka ly kc ms kd ma mb bi translated">和弗林克一起开心吗？</h1><p id="37c7" class="pw-post-body-paragraph kf kg iq kh b ki mc jr kk kl md ju kn ko me kq kr ks mf ku kv kw mg ky kz la ij bi translated">使用k8s-flink-operator，我们现在可以更快地创建在k8s上运行的flink作业，并安全地维护更多作业。</p><p id="33aa" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但更重要的是，使用元控制器来添加CRD，我们可以扩展K8S和许多其他方式来促进开发过程和维护更好的系统。</p></div></div>    
</body>
</html>