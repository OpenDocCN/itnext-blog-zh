<html>
<head>
<title>The Promise of WebComponents &amp; WebAssembly</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">WebComponents和WebAssembly的承诺</h1>
<blockquote>原文：<a href="https://itnext.io/the-promise-of-webcomponents-webassembly-ad26af56fcf1?source=collection_archive---------4-----------------------#2018-03-20">https://itnext.io/the-promise-of-webcomponents-webassembly-ad26af56fcf1?source=collection_archive---------4-----------------------#2018-03-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/3841fafda78fc9162c8deb00b0aa2bef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7CNXBPA6hD3it6yRh2aCjQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">WebComponents和WebAssembly</figcaption></figure><blockquote class="kc kd ke"><p id="e954" class="kf kg kh ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ij bi translated"><a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/the-promise-of-webcomponents-webassembly-ad26af56fcf1?utm_source=medium_sharelink&amp;utm_medium=social&amp;utm_campaign=buffer">点击这里在LinkedIn上分享这篇文章</a></p></blockquote><h1 id="f39a" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">变化的迹象</h1><p id="9785" class="pw-post-body-paragraph kf kg iq ki b kj md kl km kn me kp kq mf mg kt ku mh mi kx ky mj mk lb lc ld ij bi translated">尽管我们中的许多人会同意将<strong class="ki ir"> Javascript疲劳</strong>称为一种真正的疾病，但web平台似乎是唯一一个在全球范围内成功管理系统设计的复杂性、灵活性和稳定性之间的挑战的环境。在撰写本文时，节点包管理器(npm)为开发人员社区提供了650，000个可重用javascript代码的构建块。这些块有各种大小和形状，如小函数、库或完全成熟的框架。虽然这种数字生态系统带来了挑战，但开发人员正在习惯于与这样一种具有可塑性和非常丰富的物质一起工作。但是如果这个规模只是冰山一角呢…</p><p id="c821" class="pw-post-body-paragraph kf kg iq ki b kj kk kl km kn ko kp kq mf ks kt ku mh kw kx ky mj la lb lc ld ij bi translated">我总是对web平台的每一个新标准为开发者提供的未来感到兴奋，但是我相信对<strong class="ki ir"> WebComponents </strong>和<strong class="ki ir"> WebAssembly </strong>的整体分析尤其能够揭示出总的趋势，这将在不久的将来使web成为一个非常不同的地方。本文的目的是推测这种未来，并想象当这两种技术的<strong class="ki ir">承诺</strong>实现时，web开发人员的生活将会发生怎样的变化。</p><p id="70ef" class="pw-post-body-paragraph kf kg iq ki b kj kk kl km kn ko kp kq mf ks kt ku mh kw kx ky mj la lb lc ld ij bi translated">简而言之，这两个标准都具有足够的革命性，都值得拥有一本像样的书。<strong class="ki ir">无框架web组件</strong>具有重塑和简化应用程序设计的潜力，就像npm包帮助许多开发人员解决日常问题一样，从普通的日期转换到复杂的机器学习计算。<strong class="ki ir">language less web assembly</strong>作为编译目标提供了新的表达水平和速度，这在浏览器或任何其他web堆栈上都是前所未有的。尽管目前这些想法是新鲜的，仍然缺乏采纳，但它们都将推动彼此的进步。</p><h1 id="27af" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">web组件重要性</h1><p id="68ce" class="pw-post-body-paragraph kf kg iq ki b kj md kl km kn me kp kq mf mg kt ku mh mi kx ky mj mk lb lc ld ij bi translated">大约4年前，许多Javascript框架，比如Angular和React，在构造UI代码时选择使用组件作为主要单元。这种模式有助于理解日益复杂的单页面应用程序。大约在那个时候，W3C开始致力于一个叫做<a class="ae le" href="https://www.w3.org/standards/techs/components#w3c_all" rel="noopener ugc nofollow" target="_blank"> WebComponents </a>的新标准。随着聚合物和模板等库在2017年的兴起，我们开始看到这项技术的一些真正力量。突然之间，开发人员能够将他们的时间投入到框架无关的方式中，为他们的应用程序构建可重用的UI部件。无论你现在用什么，是Angular，React还是Vue——每个人都可以适应这种模式。它一步一步地通过现有项目的许多层消除摩擦。Ionic等公司已经能够通过为网站制作类似于原生iOS和Android控件的高质量元素库来获利。你可以在下面的视频中找到他们的故事:</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="2e50" class="pw-post-body-paragraph kf kg iq ki b kj kk kl km kn ko kp kq mf ks kt ku mh kw kx ky mj la lb lc ld ij bi translated">目前，WebComponents.org T2 T3提供了大约1000种不同的ui构建模块，可以在世界各地的项目中集成和重用。这个数字注定会增长，并扩展到许多高质量的控件、UI元素或成熟的应用程序，这些应用程序可以轻松地与宿主应用程序进行互操作。HTML和CSS在孤立的web组件中成为UX设计的通用语言，这将使web平台和应用程序与本地操作系统解决方案相比更具竞争力。但是，尽管WebComponent模式很好地解决了我们在项目中面临的架构问题，但与本地应用程序相比，web平台到目前为止仍然缺乏基本性能问题的答案。这就是WebAssembly要走的路…就像一条大的路…非常大的路…</p><h1 id="b786" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">Wasm</h1><p id="c00d" class="pw-post-body-paragraph kf kg iq ki b kj md kl km kn me kp kq mf mg kt ku mh mi kx ky mj mk lb lc ld ij bi translated">如果明天您将在开发人员工具窗口中单步执行代码，当出现如下所示的代码时，请不要惊慌:</p><pre class="ml mm mn mo gt mr ms mt mu aw mv bi"><span id="4ccd" class="mw lg iq ms b gy mx my l mz na">(module<br/>  (func (param $lhs i32) (param $rhs i32) (result i32)<br/>    get_local $lhs<br/>    get_local $rhs<br/>    i32.add))</span></pre><p id="1e28" class="pw-post-body-paragraph kf kg iq ki b kj kk kl km kn ko kp kq mf ks kt ku mh kw kx ky mj la lb lc ld ij bi translated">你可能碰到过这样的库，它决定优化它的代码，使其工作得更快，体积更小。这个库被编译成WebAssembly(简称为<strong class="ki ir"> wasm </strong>),并作为常规静态javascript文件提供给浏览器。即使wasm编译成二进制格式，当使用<a class="ae le" href="http://webassembly.org/getting-started/advanced-tools/" rel="noopener ugc nofollow" target="_blank">转换工具</a>时，我们仍然可以使它对人类可读。如果上面的代码对你来说完全陌生——去MDN网站查看更多信息<a class="ae le" href="https://developer.mozilla.org/en-US/docs/WebAssembly/Understanding_the_text_format" rel="noopener ugc nofollow" target="_blank">“理解Webassembly文本格式”</a>。还要查看g <a class="ae le" href="https://github.com/WebAssembly/design/blob/master/BinaryEncoding.md" rel="noopener ugc nofollow" target="_blank"> ithub WebAssembly库</a>以了解更多关于wasm的二进制编码。如果这还不够，看看杰伊·菲尔普斯的视频:</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="cec8" class="pw-post-body-paragraph kf kg iq ki b kj kk kl km kn ko kp kq mf ks kt ku mh kw kx ky mj la lb lc ld ij bi translated">到目前为止，当谈到浏览器的语言选择时，Javascript是唯一的障碍。像Java这样的其他语言也尝试过，但是在单独的VM中运行时，却没有成功。尽管Javascript是一种优秀的、富于表现力的、非常动态的语言，但它在性能、静态类型和大小方面也有不足之处。<a class="ae le" href="http://webassembly.org/" rel="noopener ugc nofollow" target="_blank">Webassembly.org</a>向Wasm提供了这个定义:</p><blockquote class="kc kd ke"><p id="94cf" class="kf kg kh ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ij bi translated">WebAssembly(缩写为<em class="iq"> Wasm </em>)是一种基于堆栈的虚拟机的二进制指令格式。Wasm被设计为C/C++/Rust等高级语言编译的可移植目标，支持客户端和服务器应用程序在web上的部署。</p></blockquote><p id="04cc" class="pw-post-body-paragraph kf kg iq ki b kj kk kl km kn ko kp kq mf ks kt ku mh kw kx ky mj la lb lc ld ij bi translated">这意味着像C#、TurboScript、Elm等语言将提供wasm作为编译目标。这是斯科特·汉瑟曼的一篇名为<a class="ae le" href="https://www.hanselman.com/blog/NETAndWebAssemblyIsThisTheFutureOfTheFrontend.aspx" rel="noopener ugc nofollow" target="_blank">的好文章。NET和WebAssembly是前端的未来，他说WebAssembly将会继续存在。而。NET绝对不是前端的唯一未来，对于那些喜欢用C#、VB甚至F#编写全栈应用程序的人来说，它是一个很好的选择…</a></p><h1 id="114d" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">“巴别塔”正在倒塌</h1><p id="908e" class="pw-post-body-paragraph kf kg iq ki b kj md kl km kn me kp kq mf mg kt ku mh mi kx ky mj mk lb lc ld ij bi translated">不管你喜不喜欢，这个新标准将会引起网络语言的爆炸。这并不是说Javascript将被淘汰，这只是意味着在不久的将来我们将有更多的选择。从事通用库和框架工作的开发人员将从中受益，因为他们能够将更多的特性打包到相同大小的包中。这种模块的用户将受益，因为他们的基础设施将变得轻量级，并有望优化运行速度。</p><p id="42dc" class="pw-post-body-paragraph kf kg iq ki b kj kk kl km kn ko kp kq mf ks kt ku mh kw kx ky mj la lb lc ld ij bi translated">浏览器世界对新语言的需求已经存在了一段时间。在过去的三年里，我们看到了Javascript超集的爆炸式增长，比如<a class="ae le" href="http://www.typescriptlang.org/" rel="noopener ugc nofollow" target="_blank"> Typescript </a>、<a class="ae le" href="https://reasonml.github.io/" rel="noopener ugc nofollow" target="_blank"> Reason M </a> L或者<a class="ae le" href="http://elm-lang.org/" rel="noopener ugc nofollow" target="_blank"> Elm </a>。这些语言都承诺改善Javascript代码的可伸缩性、开发者体验和稳定性。前端和后端社区都非常积极地接受WebAssembly，从而将这些目标提升到更高的水平，这并不奇怪。</p><h1 id="e593" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">但是革命在哪里？</h1><p id="7e90" class="pw-post-body-paragraph kf kg iq ki b kj md kl km kn me kp kq mf mg kt ku mh mi kx ky mj mk lb lc ld ij bi translated">虽然这真的很令人兴奋，但在网络上使用任何语言的自由并没有真正使WebAssembly成为该平台的杀手级功能。以接近本地速度执行代码将会改变我们网站的外观。历史上第一次，浏览器将能够在性能上与本地操作系统竞争。WebAssembly将实现一致的多线程模型。如果你认为webworkers是一种进步，那就等着用运行在threadripping处理器上的客户机或者其他人类未来的奇迹发明弄脏你的手吧。</p><p id="28e1" class="pw-post-body-paragraph kf kg iq ki b kj kk kl km kn ko kp kq mf ks kt ku mh kw kx ky mj la lb lc ld ij bi translated">随着基本客户端性能限制的消除，Pandoras的盒子打开了——游戏、光线跟踪和物理引擎、3D CAD应用程序、严肃的模拟库将最终能够进入浏览器空间。这也有可能复兴虚拟现实和增强现实在网络上的应用。这里是<a class="ae le" href="https://s3.amazonaws.com/mozilla-games/ZenGarden/EpicZenGarden.html" rel="noopener ugc nofollow" target="_blank">史诗禅宗花园演示</a>的链接，你可以从中获得灵感。别忘了，这是真正的游戏般的互动体验，而不是预先渲染的电影播放。查看Luke Wagner撰写的这篇<a class="ae le" href="https://spectrum.ieee.org/computing/software/webassembly-will-finally-let-you-run-highperformance-applications-in-your-browser" rel="noopener ugc nofollow" target="_blank"> IEEE Spectrum文章</a>，了解wasm即将推出的高性能应用的更多详情。如果这还不够——这有望以类似的方式影响IOT世界，如果不是更严重的话。Node 8 LTS及其V8引擎和微软的ChakraCore也已经支持wasm。更多信息请看来自<a class="ae le" href="https://twitter.com/binjimint?lang=en" rel="noopener ugc nofollow" target="_blank">本恩·史密斯</a>的视频:</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="c594" class="pw-post-body-paragraph kf kg iq ki b kj kk kl km kn ko kp kq mf ks kt ku mh kw kx ky mj la lb lc ld ij bi translated">当然，仍然存在挑战，WebAssembly中缺少许多实用的东西，如垃圾收集或异常处理。你可以在这里找到<a class="ae le" href="http://webassembly.org/docs/future-features/" rel="noopener ugc nofollow" target="_blank">后MVP特性列表</a>。此外，如果你感兴趣的话，你可以查看这篇博客文章，了解来自新堆栈的关于这项技术的精彩<a class="ae le" href="https://thenewstack.io/ready-web-assembly-revolution/" rel="noopener ugc nofollow" target="_blank">摘要。也有人担心通过WebAssembly运行的专有二进制代码会使其他人的代码难以阅读。但是1.0版本已经发布，并且所有主要的浏览器供应商都同意这个规范，这一事实表明，我们在未来几年将享受到的所有乐趣现在已经没有回头路了。</a></p><h1 id="cdbe" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">这一切给我们留下了什么…</h1><p id="4e4a" class="pw-post-body-paragraph kf kg iq ki b kj md kl km kn me kp kq mf mg kt ku mh mi kx ky mj mk lb lc ld ij bi translated">那么，WebComponents与WebAssembly有什么关系，它们将如何进一步推动应用呢？这两个标准都为前端堆栈提供了一个模块化的抽象层。想象一下，将在VR中的WebGL上呈现CAD内容的WebComponents与wasm中针对多线程模拟进行优化的WebComponents以及旨在通过WebComponents创建独特UI控件的WebComponents结合起来……通过web components……周而复始。</p><p id="4cdd" class="pw-post-body-paragraph kf kg iq ki b kj kk kl km kn ko kp kq mf ks kt ku mh kw kx ky mj la lb lc ld ij bi translated">这种运行wasm代码的快速互联web组件的模块化系统将在不久的将来驱动web开发的未来。管理这些组件之间的信息流仍将是一个挑战，但有了像<a class="ae le" href="https://redux.js.org/" rel="noopener ugc nofollow" target="_blank"> Redux </a>和<a class="ae le" href="https://www.apollographql.com/" rel="noopener ugc nofollow" target="_blank"> Apollo GraphQL </a>这样的库，我们正在寻找解决方案。将这一点与用静态类型语言编写前端代码的可能性结合起来，web平台将突然变得非常活跃。在这种情况下，650，000个npm包看起来确实是一个非常不起眼的开始。</p><p id="0933" class="pw-post-body-paragraph kf kg iq ki b kj kk kl km kn ko kp kq mf ks kt ku mh kw kx ky mj la lb lc ld ij bi translated">总的来说，单单这些新标准就可能会让javascript变得乏味，但这是件好事。我们做得越快，就越早享受到这些标准带来的新的可能性。同时，webpack现在用<a class="ae le" href="https://github.com/ballercat/wasm-loader" rel="noopener ugc nofollow" target="_blank"> wasm-loader </a>支持WebAssembly，只需几个右边的<a class="ae le" href="https://github.com/webcomponents/webcomponentsjs" rel="noopener ugc nofollow" target="_blank">poly fill</a>我们就可以让WebComponents在我们的网站上工作。所以，让我们享受和创新未来。</p></div></div>    
</body>
</html>