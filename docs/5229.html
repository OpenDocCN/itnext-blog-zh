<html>
<head>
<title>Lessons learned from forking a Helm Project</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从分叉Helm项目中吸取的经验教训</h1>
<blockquote>原文：<a href="https://itnext.io/lessons-learned-from-forking-a-helm-project-743ad48112e7?source=collection_archive---------2-----------------------#2021-01-17">https://itnext.io/lessons-learned-from-forking-a-helm-project-743ad48112e7?source=collection_archive---------2-----------------------#2021-01-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="ad0e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">头盔对我来说并不陌生。写自己的东西或参与图表项目也不是。然而，最近对我来说很新鲜的一件事是派生一个上游图表项目，并在其上添加特性。我学到了一些艰难但也非常有用的经验，应该会使未来的贡献过程变得容易得多。在这篇文章中，我将解释我在过去的一周里在一个分叉图项目中所学到的东西。我会用一个决议来解释每一个教训。我不认为我会从这样一个简单的任务中学到一些有价值的经验。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi kl"><img src="../Images/48accd510339339e6b8d923936d5becd.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*YcByGZNVtb6cGO4FQLr0mw.jpeg"/></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">helm.sh</figcaption></figure></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h2 id="87fa" class="le lf iq bd lg lh li dn lj lk ll dp lm jy ln lo lp kc lq lr ls kg lt lu lv lw bi translated">您还必须将您的fork添加为Github页面。</h2><p id="d08b" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">这是我不确定的事情，因为我还没有<em class="mc">分叉</em>一个使用<a class="ae md" href="https://pages.github.com/" rel="noopener ugc nofollow" target="_blank"> Github页面</a>的项目。对于上下文，Helm使用Github页面托管<a class="ae md" href="https://helm.sh/docs/topics/chart_repository/#github-pages-example" rel="noopener ugc nofollow" target="_blank">图表库</a>。一旦我分叉了回购，我就检查我的回购是否继承了Github页面设置，并立即得到一个“<em class="mc"> 404 Not Found </em>”错误。</p><pre class="km kn ko kp gt me mf mg mh aw mi bi"><span id="34dc" class="le lf iq mf b gy mj mk l ml mm">&gt; helm repo add test <a class="ae md" href="https://geekbass.github.io/aws-efs-csi-driver/helm/Chart.yaml" rel="noopener ugc nofollow" target="_blank">https://geekbass.github.io/aws-efs-csi-driver/helm/Chart.yaml</a><br/>W0112 16:02:38.753252   55521 loader.go:223] Config not found: admin.conf<br/>Error: looks like "<a class="ae md" href="https://geekbass.github.io/aws-efs-csi-driver/helm/Chart.yaml" rel="noopener ugc nofollow" target="_blank">https://geekbass.github.io/aws-efs-csi-driver/helm/Chart.yaml</a>" is not a valid chart repository or cannot be reached: failed to fetch <a class="ae md" href="https://geekbass.github.io/aws-efs-csi-driver/helm/Chart.yaml/index.yaml" rel="noopener ugc nofollow" target="_blank">https://geekbass.github.io/aws-efs-csi-driver/helm/Chart.yaml/index.yaml</a> : 404 Not Found</span></pre><p id="abcc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我还从我的repo中的Settings UI确认它还没有发布。为Helm repo设置Github页面时，请务必查看<a class="ae md" href="https://helm.sh/docs/topics/chart_repository/#github-pages-example" rel="noopener ugc nofollow" target="_blank"> Helm站点</a>上的文档，并确保使用指定的分支“gh-pages”。请注意，在简单地分叉一个项目后，Github不会正确地托管您的分叉项目，并且需要上面的额外步骤。</p><h2 id="6de7" class="le lf iq bd lg lh li dn lj lk ll dp lm jy ln lo lp kc lq lr ls kg lt lu lv lw bi translated"><strong class="ak">分叉时，您可能看不到版本中的所有工件。</strong></h2><p id="470a" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">尽管我已经是Github的用户很长时间了，并参与了许多项目，但这对我来说还是有点震惊。我完全期望，如果我分叉一个项目，它会有完全相同的工件。在我的例子中，最初的项目在每个版本中都将图表打包在一个名为<strong class="jp ir"><em class="mc">helm-chart . tgz</em></strong>的归档文件中。Helm希望提取该文件，然后根据分支“gh-pages”上托管的<strong class="jp ir"><em class="mc">index . YAML</em></strong>中的<strong class="jp ir"><em class="mc">URL</em></strong><em class="mc"/>v<em class="mc">alue部署版本。因为我假设当我测试图表的初始部署时，所有工件，或者每个Github发布页面UI的“资产”都在那里，所以我最终得到了另一个404。</em></p><pre class="km kn ko kp gt me mf mg mh aw mi bi"><span id="6c17" class="le lf iq mf b gy mj mk l ml mm">Warning  DriverDeployFailure  4m36s (x2 over 7m13s)  kubeaddons-controller  failed to fetch <a class="ae md" href="https://github.com/geekbass/aws-efs-csi-driver/releases/download/v1.0.2/helm-chart.tgz" rel="noopener ugc nofollow" target="_blank">https://github.com/geekbass/aws-efs-csi-driver/releases/download/v1.0.0/helm-chart.tgz</a> : 404 Not Found</span></pre><p id="3849" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我不确定为什么在我进行回购后没有包括所有的资产，但我能够确认所有相同的发行都存在，但没有<strong class="jp ir"> <em class="mc"> helm-chart.tgz </em> </strong>文件(资产)。也许这是因为它是一个定制的工件，需要额外的工作来上传它？我没有对此做进一步的调查，因为调查并不重要，而是为将来做准备。</p><p id="b9c7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我只是能够从原始回购中下载缺失的资产(helm-chart.tgz ),在我的分叉回购中编辑1.0.0版本并上传它。一旦我上传了它，测试图表的部署就像预期的那样工作了！</p><h2 id="c371" class="le lf iq bd lg lh li dn lj lk ll dp lm jy ln lo lp kc lq lr ls kg lt lu lv lw bi translated"><strong class="ak">密切关注发布，而不仅仅是主分支上存在的内容。</strong></h2><p id="ea07" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">在我开始成功部署图表之后，我准备开始添加我自己的特性，然后最终删除我自己构建的版本。我最初的思考过程和我立即开始做的事情是基于师父创建一个新的分支。一旦我对特性感到满意，我就会将那个分支合并回主版本，然后根据我合并到主版本中的变更，剪切出一个新的版本。根据我的经验，这是非常普通的流程，但是我没有考虑到的是，到目前为止，<em class="mc">我只在最新的图表发布版本</em>上进行测试。从那以后，master做了一些其他的改变，而且自上一个版本以来，很多东西都发生了变化。因为我没有考虑到这些变化，所以在我的初始部署中到处都是错误。不同组件的版本关闭，在这种情况下，驱动程序部署因此出现故障。</p><pre class="km kn ko kp gt me mf mg mh aw mi bi"><span id="d111" class="le lf iq mf b gy mj mk l ml mm">&gt; k logs -f -n kube-system efs-csi-controller-6c65c6674f-4j6n5 csi-provisioner<br/>I0113 18:57:49.472377       1 csi-provisioner.go:121] Version: v2.0.2<br/>I0113 18:57:49.472472       1 csi-provisioner.go:135] Building kube configs for running in cluster...<br/>I0113 18:57:49.478396       1 connection.go:153] Connecting to unix:///var/lib/csi/sockets/pluginproxy/csi.sock<br/>I0113 18:57:49.478854       1 common.go:111] Probing CSI driver for readiness<br/>I0113 18:57:49.478874       1 connection.go:182] GRPC call: /csi.v1.Identity/Probe<br/>I0113 18:57:49.478878       1 connection.go:183] GRPC request: {}<br/>I0113 18:57:49.480539       1 connection.go:185] GRPC response: {}<br/>I0113 18:57:49.480586       1 connection.go:186] GRPC error: &lt;nil&gt;<br/>I0113 18:57:49.480595       1 connection.go:182] GRPC call: /csi.v1.Identity/GetPluginInfo<br/>I0113 18:57:49.480601       1 connection.go:183] GRPC request: {}<br/>I0113 18:57:49.480882       1 connection.go:185] GRPC response: {"name":"efs.csi.aws.com","vendor_version":"v1.0.0-dirty"}<br/>I0113 18:57:49.480933       1 connection.go:186] GRPC error: &lt;nil&gt;<br/>I0113 18:57:49.480947       1 csi-provisioner.go:182] Detected CSI driver efs.csi.aws.com<br/>W0113 18:57:49.480957       1 metrics.go:142] metrics endpoint will not be started because `metrics-address` was not specified.<br/>I0113 18:57:49.480966       1 connection.go:182] GRPC call: /csi.v1.Identity/GetPluginCapabilities<br/>I0113 18:57:49.480976       1 connection.go:183] GRPC request: {}<br/>I0113 18:57:49.481196       1 connection.go:185] GRPC response: {}<br/>I0113 18:57:49.481230       1 connection.go:186] GRPC error: &lt;nil&gt;<br/>I0113 18:57:49.481237       1 connection.go:182] GRPC call: /csi.v1.Controller/ControllerGetCapabilities<br/>I0113 18:57:49.481242       1 connection.go:183] GRPC request: {}<br/>I0113 18:57:49.481523       1 connection.go:185] GRPC response: {}<br/>I0113 18:57:49.481578       1 connection.go:186] GRPC error: rpc error: code = Unimplemented desc = unknown service csi.v1.Controller<br/>F0113 18:57:49.481597       1 csi-provisioner.go:188] Error getting CSI driver capabilities: rpc error: code = Unimplemented desc = unknown service csi.v1.Controller</span></pre><p id="8379" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如上所述，经过进一步调查，这是由于不兼容的版本。然后我意识到我应该把我的特性建立在我玩的上一个版本上，而不是master上当前的版本。这对于我正在做的事情来说很好。</p><p id="ee3d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为这不是你的回购，你可能不了解也不知道发行流程是怎么运作的。我现在将尝试识别最新版本和master之间的差异。此外，如果可能的话，我会试着更好地理解发布过程，以避免意外的问题。</p><h2 id="3e21" class="le lf iq bd lg lh li dn lj lk ll dp lm jy ln lo lp kc lq lr ls kg lt lu lv lw bi translated">检查Github操作目录。</h2><p id="497b" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">这适用于任何回购分叉，而不仅仅是从这个经验。始终注意项目根目录下的<code class="fe mn mo mp mf b">.github/</code>目录，因为这是用于<a class="ae md" href="https://github.com/features/actions" rel="noopener ugc nofollow" target="_blank"> Github动作</a>的。我在提交或合并时没有遇到任何问题或意想不到的事情，除了我每次都会收到一封烦人的电子邮件，说我的回购出现了“<em class="mc">故障”</em>。这里的要点是，不注意这一点可能会导致意想不到的事情发生，而你最初并没有意识到。只是想在这里指出这一点。在我的特殊情况下，这是用于归档<strong class="jp ir"> helm-chart.tgz </strong>文件并剪切新版本的工作流。</p><h2 id="6e56" class="le lf iq bd lg lh li dn lj lk ll dp lm jy ln lo lp kc lq lr ls kg lt lu lv lw bi translated"><strong class="ak">舵图中的范围流量控制。</strong></h2><p id="5789" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">最初分叉这个项目的主要原因是因为我想添加一个特性，允许图表部署一个或多个<a class="ae md" href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/" rel="noopener ugc nofollow" target="_blank"> PersistentVolumes </a> (PVs)、<a class="ae md" href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/" rel="noopener ugc nofollow" target="_blank">persistent volume claims</a>(PVCs)和/或一个<a class="ae md" href="https://kubernetes.io/docs/concepts/storage/storage-classes/" rel="noopener ugc nofollow" target="_blank"> StorageClass </a>。在查看了所有Kubernetes资源的规范之后，我决定需要一种方法来创建同一资源的多个实例，同时只使用一个模板文件。(例如:当用户想要创建两个PV时，它将使用相同的<strong class="jp ir"> persistent-volume.yaml </strong>模板文件来创建这两个PV。)这最好通过键值对的循环条件(在本例中是一个映射)来实现，但是不确定如何在Helm中实现。首先谷歌搜索揭示了<a class="ae md" href="https://helm.sh/docs/chart_template_guide/control_structures/#looping-with-the-range-action" rel="noopener ugc nofollow" target="_blank">范围</a>流控制结构。</p><p id="512a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从这里开始，我决定如何在一个<strong class="jp ir"> values.yaml </strong>文件中分配这些值，我得到了如下的结果(有点简化):</p><pre class="km kn ko kp gt me mf mg mh aw mi bi"><span id="9e08" class="le lf iq mf b gy mj mk l ml mm">peristentVolumes:<br/>  pv1:<br/>    annotations:<br/>      provisioned-by: efs-csi-driver<br/>    storageCapacity: 5Gi<br/>    storageClass: efs-storageclass<br/>    fileSystemId: fs-blahblah<br/>  pv2:<br/>    storageCapacity: 10Gi<br/>    storageClass: efs-sc<br/>    fileSystemId: fs-woohoo</span></pre><p id="df67" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上面的想法是创建两个名为“pv1”和“pv2”的PVs，并根据其贴图分配下面的属性。我们需要“循环”通过每个映射(pv1，pv2)，然后每个键值对来得到我们想要的。我们将此设置为<code class="fe mn mo mp mf b">{{- range $k, $v := .Values.peristentVolumes }}</code>的舵变量。(更多信息见<a class="ae md" href="https://golang.org/pkg/text/template/#hdr-Variables" rel="noopener ugc nofollow" target="_blank"> Go模板变量</a>)我得出的最终解决方案如下图<code class="fe mn mo mp mf b">./templates/pv.yaml</code>:</p><pre class="km kn ko kp gt me mf mg mh aw mi bi"><span id="69f7" class="le lf iq mf b gy mj mk l ml mm">{{- range $k, $v := .Values.peristentVolumes }}<br/>apiVersion: v1<br/>kind: PersistentVolume<br/>metadata:<br/>  {{- if $v.annotations }}<br/>  annotations: {{ toYaml $v.annotations | nindent 4 }}<br/>  {{- end }}<br/>  name: {{ $k }}<br/>spec:<br/>  capacity:<br/>    storage: {{ $v.storageCapacity }}<br/>  volumeMode: Filesystem<br/>  accessModes:<br/>    - ReadWriteMany<br/>  persistentVolumeReclaimPolicy: Retain<br/>  storageClassName: {{ $v.storageClass }}<br/>  csi:<br/>    driver: efs.csi.aws.com<br/>    volumeHandle: {{ $v.fileSystemId }}<br/>---<br/>{{- end }}</span></pre><p id="9a42" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要在本地测试这一点，看看我们的模板是否如预期的那样工作:</p><pre class="km kn ko kp gt me mf mg mh aw mi bi"><span id="184c" class="le lf iq mf b gy mj mk l ml mm">&gt; helm template ./<br/>W0117 09:14:26.723511   43895 loader.go:223] Config not found: admin.conf<br/>---<br/># Source: foochart/templates/pv.yaml<br/>apiVersion: v1<br/>kind: PersistentVolume<br/>metadata:<br/>  annotations:<br/>    provisioned-by: efs-csi-driver<br/>  name: pv1<br/>spec:<br/>  capacity:<br/>    storage: 5Gi<br/>  volumeMode: Filesystem<br/>  accessModes:<br/>    - ReadWriteMany<br/>  persistentVolumeReclaimPolicy: Retain<br/>  storageClassName: efs-storageclass<br/>  csi:<br/>    driver: efs.csi.aws.com<br/>    volumeHandle: fs-blahblah<br/>---<br/># Source: foochart/templates/pv.yaml<br/>apiVersion: v1<br/>kind: PersistentVolume<br/>metadata:<br/>  name: pv2<br/>spec:<br/>  capacity:<br/>    storage: 10Gi<br/>  volumeMode: Filesystem<br/>  accessModes:<br/>    - ReadWriteMany<br/>  persistentVolumeReclaimPolicy: Retain<br/>  storageClassName: efs-sc<br/>  csi:<br/>    driver: efs.csi.aws.com<br/>    volumeHandle: fs-woohoo</span></pre><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="93b4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里还有一件令人尴尬的事情需要注意。在我的例子中，因为我想从一个模板文件中创建多个相同的资源，我忘了用<code class="fe mn mo mp mf b">---</code>来分隔资源。K8s API不喜欢这种格式。</p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><p id="c1c1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">没有什么比把自己投入到本该如此简单的事情中，最后却把头撞向键盘，质疑自己的职业选择更好的了。我是说真的(在很大程度上)。每一次斗争都会增长知识，不管多小。这让我作为一名工程师脚踏实地。我从未期望从这个小小的旅程中学到一些简单的教训，但希望这篇文章中有一些东西可以帮助其他人摆脱他们的键盘。</p></div></div>    
</body>
</html>