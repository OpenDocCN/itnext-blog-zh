<html>
<head>
<title>Shell Scripting in Rust?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Rust中的Shell脚本？</h1>
<blockquote>原文：<a href="https://itnext.io/shell-scripting-in-rust-2bdb8c738c94?source=collection_archive---------0-----------------------#2021-04-29">https://itnext.io/shell-scripting-in-rust-2bdb8c738c94?source=collection_archive---------0-----------------------#2021-04-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="fcf4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">TL；dr: </strong>是的，对于一种面向性能的系统级语言来说，Rust中的脚本非常实用，在这种情况下与Python不相上下。与使用C或C++这样的语言相比，Cargo build/package manager提供了三大优势。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/558f1ab53825aebd101178de406911c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9uaBdbhUODq2o7cF"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">对于一个花园来说，也许有些过分了…但是看起来很有趣！<a class="ae lb" href="https://unsplash.com/@oommiidd?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">奥米德·罗山</a>在<a class="ae lb" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h1 id="2a99" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated"><strong class="ak">照片排序</strong></h1><p id="2c2f" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">Gphoto-sort 最初是一个小型Bash脚本，当时谷歌终止了它在谷歌照片和谷歌驱动之间的链接。我使用Google Drive sync工具轻松备份了我们所有的照片。后来它被谷歌外卖取代，可以让我下载我所有的照片。每一个。单身。时间。在不同的目录结构中。</p><p id="fc52" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">大多数照片在文件名中都有时间戳，所以我想如果文件不存在的话，我可以很容易地用脚本将文件从外卖存档移动到现有的树中。这样，我可以保留我的目录结构，而不必再次进行完整的云备份。</p><p id="1409" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">除了我真的想包括我妻子的外卖存档和重复数据删除，这意味着比较文件校验和。诸如此类……随着大多数软件项目范围的扩大，我的Bash-foo突然不能胜任任务了。通常我会将这样的脚本转移到Python，但我也在学习Rust语言，我很好奇，这在Rust中有多实用，Rust是一种像C/C++一样的系统级语言？</p><p id="455d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我职业生涯的大部分时间都在编写C++代码，我真的很喜欢编写面向性能、接近金属的代码。但是在C++中，我永远不会这么做。即使我已经在家安装并构建了Boost和Makefile结构设置，我还是会使用Python，因为有更高级别的库可以构建。</p><h1 id="f1c1" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated"><strong class="ak">真的，Rust里的脚本？</strong></h1><p id="aae7" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">事实证明，效果很好。非常好。我把这归因于Rust在这方面的三个优势:货物，货物，货物。</p><h2 id="6fce" class="mg ld iq bd le mh mi dn li mj mk dp lm jy ml mm lq kc mn mo lu kg mp mq ly mr bi translated"><strong class="ak"> Cargo让代码重用变得切实可行</strong></h2><p id="54fc" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">如果你不熟悉的话，<a class="ae lb" href="https://doc.rust-lang.org/cargo/" rel="noopener ugc nofollow" target="_blank"> Cargo </a>是Rust的包管理器和构建工具。它处理下载、更新和构建依赖项，然后编译和链接最终的可执行文件。如果你来自Javascript世界，使用NPM，或者使用Ruby和Gem，这已经过时了。与C++相比，甚至在某种程度上与Python相比，这就相当于给了一台洗衣机，而不必把脏衣服拖到最近的小溪里去扔石头。</p><p id="89ce" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，我将下面一行添加到我的Cargo.toml中:</p><pre class="km kn ko kp gt ms mt mu mv aw mw bi"><span id="dafd" class="mg ld iq mt b gy mx my l mz na">rust-crypto = "0.2"</span></pre><p id="78b0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">突然，我有了一个MD5哈希库(Crate)来计算文件的校验和。就是这样。不需要弄清楚每个包的构建系统的特性和它们的依赖关系。</p><h2 id="fcef" class="mg ld iq bd le mh mi dn li mj mk dp lm jy ml mm lq kc mn mo lu kg mp mq ly mr bi translated"><strong class="ak">货物造就了丰富的板条箱生态系统</strong></h2><p id="e2ce" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">即使是很小的模块也很容易重用，这意味着一个丰富的支持箱生态系统已经迅速发展起来。像<a class="ae lb" href="https://github.com/BurntSushi/walkdir" rel="noopener ugc nofollow" target="_blank"> Walkdir </a>和<a class="ae lb" href="https://github.com/clap-rs/clap" rel="noopener ugc nofollow" target="_blank"> Clap </a>(命令行解析)这样优秀的板条箱意味着组装一个文件处理实用程序的构件只需要几分钟。同样，这对于许多高级语言来说并不新鲜，但在系统级并不常见。</p><h2 id="6c81" class="mg ld iq bd le mh mi dn li mj mk dp lm jy ml mm lq kc mn mo lu kg mp mq ly mr bi translated"><strong class="ak">货物鼓励小板条箱，因此更小的模块接口</strong></h2><p id="c74c" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">Rust Crate生态系统中模块的精细粒度让我吃惊。比如Walkdir本身就不是很大，有三个依赖项。甚至还有一个(有用！)单功能机箱:<a class="ae lb" href="https://crates.io/crates/gethostname" rel="noopener ugc nofollow" target="_blank"> GetHostName </a>。为什么？</p><p id="36bf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我认为，部分原因是Rust中的模块支持。这使得用定义良好的接口来定义甚至很小的模块变得很容易。然而，这与创建一个C++类或者一个头文件加上内部细节头文件并没有什么不同。</p><p id="b4b1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不同的是，将一个C++类拆分到一个单独的目录中，有一个单独的构建目标，这(根据我的经验)要麻烦得多:每个消费者都必须链接。o文件、静态库或共享库。但是，每个消费者还需要知道要链接的任何依赖项，并从那时起保持这些依赖项最新。这就是Cargo改变游戏规则的地方，因为突然间我的构建只关注我的直接依赖项。这允许将内部模块分解成可重用的组件，这些组件可以独立于主应用程序进行修改。</p><h1 id="ada1" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">例子</h1><p id="63af" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">举例来说，下面是递归遍历当前目录下的目录树并打印找到的所有文件和目录所需的代码:</p><pre class="km kn ko kp gt ms mt mu mv aw mw bi"><span id="a6f6" class="mg ld iq mt b gy mx my l mz na">for ent in WalkDir::new(".") {<br/>    if let Ok(ent) = ent {<br/>        let path = ent.path();<br/>        if path.is_dir() {<br/>            println!("{:?} is a directory", path);<br/>        } else {<br/>            println!("{:?} is a file", path);<br/>        }<br/>    }<br/>}</span></pre><div class="nb nc gp gr nd ne"><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=8d69c19a9ae2ef00fecd4e27216d8afb" rel="noopener  ugc nofollow" target="_blank"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd ir gy z fp nj fr fs nk fu fw ip bi translated">Rust Playground —在此运行示例</h2></div></div></a></div><p id="c47e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe nl nm nn mt b">if let Ok(ent) = ent</code>表达式再次将每个“Ok”(不是错误)的条目输入到变量<code class="fe nl nm nn mt b">ent</code>中。然后代码检查路径是文件还是目录并打印出来。</p><p id="30af" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一个类似的例子可以用Rust的迭代器支持写成管道，如下所示:</p><pre class="km kn ko kp gt ms mt mu mv aw mw bi"><span id="1dfe" class="mg ld iq mt b gy mx my l mz na">let count = WalkDir::new(".")<br/>    .into_iter()<br/>    .filter_map(|e| e.ok())<br/>    .filter(|e|e.path().is_file())<br/>    .count();<br/> println!("Found {} files", count);</span></pre><p id="5ad3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个示例使用filter_map来删除任何错误条目，然后过滤以只保留文件条目，最后产生这些文件的计数。</p><p id="1c73" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">真正有趣的一点是，这个基于迭代器的版本可以很好地处理名为<a class="ae lb" href="https://crates.io/crates/rayon" rel="noopener ugc nofollow" target="_blank"> Rayon </a>的数据并行机箱。Rayon可以使用这样的管道，使用线程池在多个CPU内核之间传播处理，并几乎神奇地聚合最终结果。为了并行化我们的简单示例，我们只添加了一行代码，<code class="fe nl nm nn mt b">.par_bridge()</code>:</p><pre class="km kn ko kp gt ms mt mu mv aw mw bi"><span id="daee" class="mg ld iq mt b gy mx my l mz na">let count = WalkDir::new(".")<br/>    .into_iter()<br/>    .filter_map(|e| e.ok())<br/>    .<strong class="mt ir">par_bridge()</strong><br/>    .filter(|e|e.path().is_file())<br/>    .count();<br/> println!("Found {} files", count);</span></pre><div class="nb nc gp gr nd ne"><a href="https://play.rust-lang.org/?version=stable&amp;mode=release&amp;edition=2018&amp;gist=dac9befb1f916629ee6408be0f88e00f" rel="noopener  ugc nofollow" target="_blank"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd ir gy z fp nj fr fs nk fu fw ip bi translated">Rust Playground —在此运行示例</h2></div></div></a></div><p id="0d99" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，在数千个文件上调用<code class="fe nl nm nn mt b">is_file</code>的“繁重处理”可以跨多个CPU核心共享。当然，这在这里是没有意义的，但是如果过滤步骤在计算上更加昂贵，这可能会产生很大的不同。</p><h1 id="e9b3" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated"><strong class="ak">总结</strong></h1><p id="e4ae" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">简而言之，我对Rust作为一种系统级语言的“动态范围”印象深刻，这也让我能够在不到300行的代码中编写出相当于美化了的shell脚本——注释、单元测试等等。这确实反映了那里板条箱的质量和货物的想法。</p><p id="6a4d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有必要用低级语言写这个吗？一点也不！然而，令人惊讶的是，这种文件系统级别的操作经常出现在大型应用程序中。即使在应用程序堆栈的最底层也能高效地完成这项工作，这是一个很好的生产力提升。</p></div></div>    
</body>
</html>