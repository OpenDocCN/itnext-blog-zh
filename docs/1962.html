<html>
<head>
<title>How to access your app behind an OpenShift Router?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在OpenShift路由器后面访问您的应用程序？</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-access-your-app-behind-an-openshift-router-87cbae3e7185?source=collection_archive---------0-----------------------#2019-03-04">https://itnext.io/how-to-access-your-app-behind-an-openshift-router-87cbae3e7185?source=collection_archive---------0-----------------------#2019-03-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="886a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">构建<a class="ae kl" href="https://opensource.com/article/18/7/what-are-cloud-native-apps" rel="noopener ugc nofollow" target="_blank">云原生</a>应用，并在部署在<a class="ae kl" href="https://kubernetes.io/" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>上的容器中运行您的代码，成为许多组织首选的运行时环境。利用容器的进程和网络级隔离减少了应用程序配置的维护开销，提高了安全性，但是使得从集群外部访问您的服务有点棘手。</p><p id="e1f7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://www.openshift.com/" rel="noopener ugc nofollow" target="_blank"> Red Hat OpenShift </a>使用<a class="ae kl" href="https://docs.openshift.com/container-platform/3.11/architecture/networking/routes.html" rel="noopener ugc nofollow" target="_blank">路由</a>的概念将入口流量导向部署在集群上的应用。该解决方案基于运行在1-3个专用节点(基础设施节点)上的<a class="ae kl" href="http://www.haproxy.org/" rel="noopener ugc nofollow" target="_blank"> HAProxy </a>实例，这些节点负责<a class="ae kl" href="https://en.wikipedia.org/wiki/Virtual_hosting" rel="noopener ugc nofollow" target="_blank">虚拟主机</a>。这意味着我们将在同一个IP地址和端口后面有多个服务，它们仅通过主机名来区分(例如，<strong class="jp ir"><em class="km">orders</em></strong><em class="km">. apps . my company . com</em>，<strong class="jp ir"><em class="km">stock</em></strong><em class="km">. apps . my company . com</em>)。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi kn"><img src="../Images/a9ef1c945f84e049876ee7f885072ada.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GjBriX91xGXTwkkOC6H0Cg.png"/></div></div></figure><p id="641a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">主机名不是基本TCP/IP堆栈的一部分，但是HAProxy路由器需要知道客户端想要访问哪个服务。代理在两个地方检查主机名:</p><ul class=""><li id="26d5" class="kz la iq jp b jq jr ju jv jy lb kc lc kg ld kk le lf lg lh bi translated">HTTP <em class="km">主机</em>头</li><li id="1251" class="kz la iq jp b jq li ju lj jy lk kc ll kg lm kk le lf lg lh bi translated">TLS <em class="km">客户端问候</em>消息</li></ul><p id="a1ce" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用<em class="km"> Host </em>头显然只适用于HTTP/S流量，但通常这正是我们想要公开的。它由大多数HTTP客户端自动添加。看起来是这样的:</p><pre class="ko kp kq kr gt ln lo lp lq aw lr bi"><span id="1e31" class="ls lt iq lo b gy lu lv l lw lx">$ curl -v http://fuse7-hello-plain.192.168.99.100.nip.io/api/hello<br/>...<br/>&gt; GET /api/hello HTTP/1.1<br/>&gt; <strong class="lo ir">Host: fuse7-hello-plain.192.168.99.100.nip.io</strong><br/>&gt; User-Agent: curl/7.54.0<br/>&gt; Accept: */*<br/>&gt;<br/>&lt; HTTP/1.1 200 OK<br/>...</span></pre><p id="466c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">TLS <em class="km"> Client Hello </em>是一个更通用的解决方案，适用于任何使用<a class="ae kl" href="https://en.wikipedia.org/wiki/Server_Name_Indication" rel="noopener ugc nofollow" target="_blank">服务器名称指示(SNI </a>)的TLS连接(包括HTTPS)。主机名以不加密的方式发送，因此代理可以决定将加密流量转发到哪里:</p><pre class="ko kp kq kr gt ln lo lp lq aw lr bi"><span id="2a28" class="ls lt iq lo b gy lu lv l lw lx">curl -k https://fuse7-hello-passthrough.192.168.99.100.nip.io/</span></pre><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi ly"><img src="../Images/e3c899f7534303632548eb0303e0ce8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xZREGKTS5CK7IZYBjRxr2w.png"/></div></div></figure><h2 id="99f7" class="ls lt iq bd lz ma mb dn mc md me dp mf jy mg mh mi kc mj mk ml kg mm mn mo mp bi translated">路线类型</h2><p id="b8b8" class="pw-post-body-paragraph jn jo iq jp b jq mq js jt ju mr jw jx jy ms ka kb kc mt ke kf kg mu ki kj kk ij bi translated">基于TLS卸载的OpenShift中有四种不同类型的路由:</p><ul class=""><li id="a01a" class="kz la iq jp b jq jr ju jv jy lb kc lc kg ld kk le lf lg lh bi translated"><strong class="jp ir">无TLS </strong>(端口80):非加密HTTP流量</li><li id="1f76" class="kz la iq jp b jq li ju lj jy lk kc ll kg lm kk le lf lg lh bi translated"><strong class="jp ir"> Edge </strong>(端口443):客户端和路由器代理之间的加密HTTPS流量。pod公开了未加密的HTTP端点。</li><li id="4e39" class="kz la iq jp b jq li ju lj jy lk kc ll kg lm kk le lf lg lh bi translated"><strong class="jp ir">重新加密</strong>(端口443):加密的流量被路由器代理终止，就像对<em class="km">边缘</em>路由一样，但是pod也暴露了一个HTTPS端点。所以在代理和pod之间有另一个TLS连接。</li><li id="f1b7" class="kz la iq jp b jq li ju lj jy lk kc ll kg lm kk le lf lg lh bi translated"><strong class="jp ir">穿越</strong>(端口443):路由器不参与TLS卸载。客户端和pod之间的流量是端到端加密的。此类型也可用于非HTTP TLS终结点。</li></ul><p id="a8a6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">路由类型决定了代理是检查HTTP <em class="km">主机</em>报头还是TLS <em class="km">客户端Hello中的主机名。</em>为到达路由端点的客户端显示的证书也取决于路由的配置。在下文中，我们将检查如何验证不同路由类型的行为。对于那些对细节不太感兴趣的人，让我们从一个简短的总结开始:</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="b837" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<em class="km">边缘</em>和<em class="km">重新加密</em>的情况下，TLS被路由器代理终止，因此它可以访问未加密的HTTP流量。主机名应该在HTTP <em class="km">主机</em>头中。正在使用为路由配置的单个证书，或者在大多数情况下使用安装的默认通配符证书(例如<em class="km"> *.apps.mycompany.com </em>)。</p><p id="b06e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<em class="km">直通</em>的情况下，代理无法访问未加密的流量——甚至可能不是HTTP——因此主机名是从TLS <em class="km">客户端问候</em>消息中选取的，并且客户端可以看到pod端点上的证书。</p><blockquote class="mx my mz"><p id="2cc7" class="jn jo km jp b jq jr js jt ju jv jw jx na jz ka kb nb kd ke kf nc kh ki kj kk ij bi translated">这有关系吗？大多数情况下不会。无论遇到哪种路由类型，HTTP客户端都能正常工作。了解代理可能很重要，例如，如果您必须在外部负载平衡器中设置健康检查，通过IP地址访问基础架构节点，以检查应用程序是否部署在OpenShift集群上。</p></blockquote><h2 id="5462" class="ls lt iq bd lz ma mb dn mc md me dp mf jy mg mh mi kc mj mk ml kg mm mn mo mp bi translated">环境</h2><p id="7c6d" class="pw-post-body-paragraph jn jo iq jp b jq mq js jt ju mr jw jx jy ms ka kb kc mt ke kf kg mu ki kj kk ij bi translated">对于一个简单的测试，我们可以使用<a class="ae kl" href="https://www.okd.io/minishift/" rel="noopener ugc nofollow" target="_blank"> MiniShift </a>(参见<a class="ae kl" href="https://developers.redhat.com/products/cdk/overview/" rel="noopener ugc nofollow" target="_blank">红帽CDK </a>)，这是一个本地单节点OpenShift虚拟机。查看用于此博客的版本:</p><pre class="ko kp kq kr gt ln lo lp lq aw lr bi"><span id="f7b3" class="ls lt iq lo b gy lu lv l lw lx">$ <strong class="lo ir">minishift version</strong><br/>minishift v1.27.0+5981f996<br/>CDK v3.7.0-1</span><span id="3359" class="ls lt iq lo b gy nd lv l lw lx">$ <strong class="lo ir">oc version</strong><br/>oc v3.11.69<br/>kubernetes v1.11.0+d4cacc0<br/>features: Basic-Auth<br/>Server <a class="ae kl" href="https://192.168.99.100:8443" rel="noopener ugc nofollow" target="_blank">https://192.168.99.100:8443</a><br/>kubernetes v1.11.0+d4cacc0</span><span id="4bfc" class="ls lt iq lo b gy nd lv l lw lx">$ <strong class="lo ir">minishift config view</strong><br/>- iso-url                            : file:///Users/bszeti/.minishift/cache/iso/minishift-rhel7.iso<br/>- memory                             : 6GB<br/>- openshift-version                  : v3.11.82<br/>- vm-driver                          : virtualbox</span></pre><p id="f065" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们在OpenShift中为我们简单的<a class="ae kl" href="https://github.com/bszeti/camel-springboot/tree/master/fuse7-hello" rel="noopener ugc nofollow" target="_blank"> Hello World API </a>应用程序创建以下路线(参见<a class="ae kl" href="#b7b1" rel="noopener ugc nofollow">附录</a>中的命令):</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="7ee4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">按照MiniShift的默认<em class="km"> *.192.168.99.100.nip.io </em>命名约定，为每个路由类型创建了一个路由，该路由使用<a class="ae kl" href="http://nip.io/" rel="noopener ugc nofollow" target="_blank"> nip.io </a>将域名解析为虚拟机的ip。我们还创建了一个带有自定义名称的额外路由，以测试它不需要坚持这种命名模式。</p><h2 id="0901" class="ls lt iq bd lz ma mb dn mc md me dp mf jy mg mh mi kc mj mk ml kg mm mn mo mp bi translated">工具</h2><p id="7c87" class="pw-post-body-paragraph jn jo iq jp b jq mq js jt ju mr jw jx jy ms ka kb kc mt ke kf kg mu ki kj kk ij bi translated"><em class="km"> OpenSSL </em>通常在Linux或Mac上可用。它可用于手动打开TLS连接、打印证书和发送HTTP命令:</p><pre class="ko kp kq kr gt ln lo lp lq aw lr bi"><span id="161e" class="ls lt iq lo b gy lu lv l lw lx">$ <strong class="lo ir">openssl s_client -showcerts -connect fuse7-hello-edge.192.168.99.100.nip.io:443</strong><br/>CONNECTED(00000005)<br/>depth=1 CN = openshift-signer@1551218868<br/>verify error:num=19:self signed certificate in certificate chain<br/>verify return:0<br/>---<br/>Certificate chain<br/> 0 s:/CN=*.router.default.svc.cluster.local<br/>   i:/CN=openshift-signer@1551218868<br/>-----BEGIN CERTIFICATE-----<br/>...<br/>---<br/><strong class="lo ir">GET /api/hello HTTP/1.1<br/>Host: fuse7-hello-edge.192.168.99.100.nip.io</strong></span><span id="80ed" class="ls lt iq lo b gy nd lv l lw lx">HTTP/1.1 200 OK<br/>...</span></pre><p id="2a11" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">默认情况下，该命令中使用的<em class="km">主机名</em>被添加到TLS <em class="km">客户端Hello </em>中，但是可以手动设置:</p><pre class="ko kp kq kr gt ln lo lp lq aw lr bi"><span id="175b" class="ls lt iq lo b gy lu lv l lw lx">$ <strong class="lo ir">openssl s_client -connect 192.168.99.100:443 --servername any.custom.name</strong><br/>CONNECTED(00000003)<br/>...<br/>---<br/><strong class="lo ir">GET /api/hello HTTP/1.0</strong></span><span id="8cb7" class="ls lt iq lo b gy nd lv l lw lx">HTTP/1.1 200 OK<br/>...</span></pre><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi ne"><img src="../Images/91ff99b4b5234b6ed960a83bafabf5e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D62r2QdjHKDGjB5Q3ekyiA.png"/></div></div></figure><p id="971c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="km"> Curl </em>自动在HTTP <em class="km"> Host </em>头以及TLS <em class="km"> Client Hello </em>中设置主机名。可以很容易地更改报头，但是TLS消息中的主机名需要在DNS解析方面做一些小技巧:</p><pre class="ko kp kq kr gt ln lo lp lq aw lr bi"><span id="d667" class="ls lt iq lo b gy lu lv l lw lx"><em class="km"># Flag '-k' is used to skip certificate verification.</em><br/>$ <strong class="lo ir">curl -vk --resolve any.custom.name:443:192.168.99.100 -H 'Host: myhost' </strong><a class="ae kl" href="https://any.custom.name/api/hello" rel="noopener ugc nofollow" target="_blank"><strong class="lo ir">https://any.custom.name/api/hello</strong></a><br/>* Added any.custom.name:443:192.168.99.100 to DNS cache<br/>* Hostname any.custom.name was found in DNS cache<br/>*   Trying 192.168.99.100...<br/>* TCP_NODELAY set<br/>* Connected to any.custom.name (192.168.99.100) port 443 (#0)<br/>...<br/>&gt; GET /api/hello HTTP/1.1<br/>&gt; Host: myhost<br/>&gt; User-Agent: curl/7.54.0<br/>&gt; Accept: */*<br/>&gt;<br/>&lt; HTTP/1.1 200 OK</span></pre><h2 id="7e6a" class="ls lt iq bd lz ma mb dn mc md me dp mf jy mg mh mi kc mj mk ml kg mm mn mo mp bi translated">让我们跳舞吧</h2><p id="a3f8" class="pw-post-body-paragraph jn jo iq jp b jq mq js jt ju mr jw jx jy ms ka kb kc mt ke kf kg mu ki kj kk ij bi translated">因为我们已经准备好了环境和工具，所以让我们快速看一下不同路由类型的行为。</p><p id="c9de" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">无TLS </strong></p><p id="7a04" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">普通的HTTP路由没什么可看的。路由器代理根据HTTP <em class="km"> Host </em>报头决定要访问哪些pods。</p><pre class="ko kp kq kr gt ln lo lp lq aw lr bi"><span id="fe50" class="ls lt iq lo b gy lu lv l lw lx">$ <strong class="lo ir">curl -v http://fuse7-hello-plain.192.168.99.100.nip.io/api/hello</strong><br/>&gt; GET /api/hello HTTP/1.1<br/>&gt; Host: fuse7-hello-plain.192.168.99.100.nip.io<br/>&gt; User-Agent: curl/7.54.0<br/>&gt; Accept: */*<br/>&gt;<br/>&lt; HTTP/1.1 200 OK</span><span id="4765" class="ls lt iq lo b gy nd lv l lw lx"><em class="km"># If the Host header is incorrect, the service is not found</em><br/>$ <strong class="lo ir">curl -v http://fuse7-hello-plain.192.168.99.100.nip.io/api/hello -H 'Host: xxx'</strong><br/>&gt; GET /api/hello HTTP/1.1<br/>&gt; Host: xxx<br/>&gt; User-Agent: curl/7.54.0<br/>&gt; Accept: */*<br/>&gt;<br/>&lt; HTTP/1.0 503 Service Unavailable</span></pre><p id="0a7c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">边缘</strong></p><p id="dbee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">路由决定由HTTP <em class="km">主机</em>报头做出，TLS <em class="km">客户端Hello </em>中的主机名被忽略。使用路由器的默认通配符证书，或路由的单独证书(如果设置的话)。</p><pre class="ko kp kq kr gt ln lo lp lq aw lr bi"><span id="a72f" class="ls lt iq lo b gy lu lv l lw lx">$ <strong class="lo ir">curl -vk https://fuse7-hello-edge.192.168.99.100.nip.io/api/hello</strong> <br/>&gt; GET /api/hello HTTP/1.1<br/>&gt; Host: fuse7-hello-edge.192.168.99.100.nip.io<br/>&gt;...<br/>&lt; HTTP/1.1 200 OK</span><span id="2c9d" class="ls lt iq lo b gy nd lv l lw lx"><em class="km"># Hostname in TLS Client Hello is ignored</em><br/>$ <strong class="lo ir">curl -vk --resolve nonexistinghost:443:192.168.99.100 </strong><a class="ae kl" href="https://nonexistinghost/api/hello" rel="noopener ugc nofollow" target="_blank"><strong class="lo ir">https://nonexistinghost/api/hello</strong></a><strong class="lo ir"> -H 'Host: fuse7-hello-edge.192.168.99.100.nip.io'</strong><br/>&gt; GET /api/hello HTTP/1.1<br/>&gt; Host: fuse7-hello-edge.192.168.99.100.nip.io<br/>&gt; ...<br/>&lt; HTTP/1.1 200 OK</span><span id="35bf" class="ls lt iq lo b gy nd lv l lw lx"><em class="km"># If the Host header is incorrect, the service is not found</em><br/>$ <strong class="lo ir">curl -vk https://fuse7-hello-edge.192.168.99.100.nip.io/api/hello -H 'Host: xxx'</strong><br/>&gt; GET /api/hello HTTP/1.1<br/>&gt; Host: xxx<br/>&gt;...<br/>&lt; HTTP/1.0 503 Service Unavailable</span></pre><p id="03d8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">重新加密</strong></p><p id="7c1b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就像在<em class="km"> Edge </em>的情况下，HTTP <em class="km"> Host </em>头很重要。客户端会看到路由器的(默认或特定于路由的)证书。重要的是，路由器代理必须信任pod提供的证书，因此必须在路由上相应地设置<em class="km">destinationCACertificate</em>。要信任自签名证书，只需在此处添加即可。对于由CA签名的证书，添加CA的根(或中间)证书。pod证书上的CN(主机名)未经验证。</p><pre class="ko kp kq kr gt ln lo lp lq aw lr bi"><span id="b55a" class="ls lt iq lo b gy lu lv l lw lx">$ <strong class="lo ir">curl -vk https://fuse7-hello-reencrypt.192.168.99.100.nip.io/api/hello</strong><br/>...<br/>* Server certificate:<br/>*  subject: CN=*.router.default.svc.cluster.local<br/>...<br/>&gt; GET /api/hello HTTP/1.1<br/>&gt; Host: fuse7-hello-reencrypt.192.168.99.100.nip.io<br/>&gt;...<br/>&lt; HTTP/1.1 200 OK</span><span id="0c8b" class="ls lt iq lo b gy nd lv l lw lx"><em class="km"># Hostname in TLS Client Hello is ignored<br/></em>$ <strong class="lo ir">curl -vk --resolve nonexistinghost:443:192.168.99.100 https://nonexistinghost/api/hello -H 'Host: fuse7-hello-reencrypt.192.168.99.100.nip.io'</strong><br/>&gt; GET /api/hello HTTP/1.1<br/>&gt; Host: fuse7-hello-reencrypt.192.168.99.100.nip.io<br/>&gt; ...<br/>&lt; HTTP/1.1 200 OK</span><span id="15a8" class="ls lt iq lo b gy nd lv l lw lx"><em class="km"># If the Host header is incorrect, the service is not found</em><br/>$ <strong class="lo ir">curl -vk https://fuse7-hello-reencrypt.192.168.99.100.nip.io/api/hello -H 'Host: xxx'</strong><br/>&gt; GET /api/hello HTTP/1.1<br/>&gt; Host: xxx<br/>&gt;...<br/>&lt; HTTP/1.0 503 Service Unavailable</span></pre><p id="5c20" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">通过</strong></p><p id="2c7d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">TLS由pod终止，因此代理无法访问未加密的流量。路由决定基于TLS <em class="km">客户端Hello </em>中的主机名，忽略<em class="km">主机</em>报头。此外，流量不一定是HTTPS，因为TLS包装的协议仅由pod处理。</p><pre class="ko kp kq kr gt ln lo lp lq aw lr bi"><span id="c43c" class="ls lt iq lo b gy lu lv l lw lx">$ <strong class="lo ir">curl -vk https://fuse7-hello-passthrough.192.168.99.100.nip.io/api/hello</strong><br/>&gt; GET /api/hello HTTP/1.1<br/>&gt; Host: fuse7-hello-passthrough.192.168.99.100.nip.io<br/>&gt; ...<br/>&lt; HTTP/1.1 200 OK</span><span id="46f5" class="ls lt iq lo b gy nd lv l lw lx"><em class="km"># Incorrect Host header causes no problem </em><br/>$ <strong class="lo ir">curl -vk https://fuse7-hello-passthrough.192.168.99.100.nip.io/api/hello -H 'Host: xxx'</strong><br/>&gt; GET /api/hello HTTP/1.1<br/>&gt; Host: xxx<br/>&gt;...<br/>&lt; HTTP/1.1 200 OK</span><span id="f02c" class="ls lt iq lo b gy nd lv l lw lx"><em class="km"># If the TLS Client Hello is incorrect, the service is not found<br/></em>$ <strong class="lo ir">curl -vk --resolve nonexistinghost:443:192.168.99.100 https://nonexistinghost/api/hello -H 'Host: fuse7-hello-passthrough.192.168.99.100.nip.io'</strong><br/>&gt; GET /api/hello HTTP/1.1<br/>&gt; Host: fuse7-hello-passthrough.192.168.99.100.nip.io<br/>&gt; ...<br/>&lt; HTTP/1.0 503 Service Unavailable</span></pre><h2 id="b7b1" class="ls lt iq bd lz ma mb dn mc md me dp mf jy mg mh mi kc mj mk ml kg mm mn mo mp bi translated">附录</h2><p id="f3c5" class="pw-post-body-paragraph jn jo iq jp b jq mq js jt ju mr jw jx jy ms ka kb kc mt ke kf kg mu ki kj kk ij bi translated">解释如何设置MiniShift、构建和部署应用以及如何创建OpenShift资源超出了本文的范围。作为指南，请参见上面用于为我们的测试准备环境的命令。</p><p id="a69b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">构建应用程序并创建图像</strong></p><pre class="ko kp kq kr gt ln lo lp lq aw lr bi"><span id="318d" class="ls lt iq lo b gy lu lv l lw lx">$ oc project openshift</span><span id="a5ac" class="ls lt iq lo b gy nd lv l lw lx">$ oc new-build java:8~<a class="ae kl" href="https://github.com/bszeti/camel-springboot.git" rel="noopener ugc nofollow" target="_blank">https://github.com/bszeti/camel-springboot.git</a> --context-dir=fuse7-hello</span><span id="17f2" class="ls lt iq lo b gy nd lv l lw lx">$ oc logs bc/camel-springboot -f<br/><em class="km">...<br/>Running 'mvn -e -Popenshift -DskipTests -Dcom.redhat.xpaas.repo.redhatga -Dfabric8.skip=true --batch-mode -Djava.net.preferIPv4Stack=true -s /tmp/src/configuration/settings.xml -Dmaven.repo.local=/tmp/artifacts/m2  package'<br/>...</em></span><span id="702a" class="ls lt iq lo b gy nd lv l lw lx">$ oc get is camel-springboot -n openshift<br/>camel-springboot   172.30.1.1:5000/openshift/camel-springboot</span></pre><p id="8789" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">用HTTP启动app</strong></p><pre class="ko kp kq kr gt ln lo lp lq aw lr bi"><span id="b054" class="ls lt iq lo b gy lu lv l lw lx">$ oc new-project hello-http</span><span id="d2c8" class="ls lt iq lo b gy nd lv l lw lx"><em class="km"># Required only to read secrets and configMaps</em><br/>$ oc policy add-role-to-user edit -z default</span><span id="f32e" class="ls lt iq lo b gy nd lv l lw lx">$ cat &lt;&lt;EOF | oc apply -f -<br/>apiVersion: apps.openshift.io/v1<br/>kind: DeploymentConfig<br/>metadata:<br/>  name: fuse7-hello<br/>  labels:<br/>    app: fuse7-hello<br/>spec:<br/>  replicas: 1<br/>  selector:<br/>    app: fuse7-hello<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: fuse7-hello<br/>    spec:<br/>      containers:<br/>      - name: default-container<br/>        image: 172.30.1.1:5000/openshift/camel-springboot:latest<br/>        readinessProbe:<br/>           failureThreshold: 3<br/>           httpGet:<br/>             path: /health<br/>             port: 8080<br/>           initialDelaySeconds: 10<br/>           timeoutSeconds: 1<br/>        resources:<br/>           limits:<br/>             memory: 512Mi<br/>EOF</span><span id="f9cb" class="ls lt iq lo b gy nd lv l lw lx">$ oc get pod -n hello-http</span><span id="6762" class="ls lt iq lo b gy nd lv l lw lx">$ oc create service clusterip fuse7-hello --tcp=8080:8080</span><span id="93c4" class="ls lt iq lo b gy nd lv l lw lx">$ cat &lt;&lt;EOF | oc apply -f -<br/>apiVersion: route.openshift.io/v1<br/>kind: Route<br/>metadata:<br/>  labels:<br/>    app: fuse7-hello<br/>  name: fuse7-hello-plain<br/>spec:<br/>  host: fuse7-hello-plain.192.168.99.100.nip.io<br/>  port:<br/>    targetPort: 8080-8080<br/>  to:<br/>    kind: Service<br/>    name: fuse7-hello<br/>EOF</span><span id="d931" class="ls lt iq lo b gy nd lv l lw lx">$ curl -k http://fuse7-hello-plain.192.168.99.100.nip.io/api/hello<br/><em class="km">{"message":"Hello World!"}</em></span><span id="e1b7" class="ls lt iq lo b gy nd lv l lw lx">$ cat &lt;&lt;EOF | oc apply -f -<br/>apiVersion: route.openshift.io/v1<br/>kind: Route<br/>metadata:<br/>  labels:<br/>    app: fuse7-hello<br/>  name: fuse7-hello-edge<br/>spec:<br/>  host: fuse7-hello-edge.192.168.99.100.nip.io<br/>  port:<br/>    targetPort: 8080-8080<br/>  tls:<br/>    termination: edge<br/>  to:<br/>    kind: Service<br/>    name: fuse7-hello<br/>EOF</span><span id="f58d" class="ls lt iq lo b gy nd lv l lw lx">$ curl -k https://fuse7-hello-edge.192.168.99.100.nip.io/api/hello<br/><em class="km">{"message":"Hello World!"}</em></span></pre><p id="9255" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">用HTTPS启动app</strong></p><pre class="ko kp kq kr gt ln lo lp lq aw lr bi"><span id="f7b8" class="ls lt iq lo b gy lu lv l lw lx">$ oc new-project hello-https</span><span id="3aa7" class="ls lt iq lo b gy nd lv l lw lx">$ oc policy add-role-to-user edit -z default</span><span id="2b89" class="ls lt iq lo b gy nd lv l lw lx"><em class="km"># Generate selfsigned cert in one step. Use passphrase "mysecret"</em><br/>$ openssl req -newkey rsa:2048 -keyout selfsigned.key -x509 -days 365 -out selfsigned.crt -subj '/DC=com/DC=mycompany/CN=myapp'</span><span id="9e55" class="ls lt iq lo b gy nd lv l lw lx">$ openssl pkcs12 -export -in selfsigned.crt -inkey selfsigned.key -out selfsigned.p12 -name myapp</span><span id="8b21" class="ls lt iq lo b gy nd lv l lw lx">$ oc create secret generic hello-keystore --from-file=keystore.p12=selfsigned.p12</span><span id="5f3f" class="ls lt iq lo b gy nd lv l lw lx"><em class="km"># The fuse7-hello app reads ConfigMap with matching name</em><br/>$ oc create configmap fuse7-hello --from-literal=server.ssl.key-store=/etc/keystore/keystore.p12 --from-literal=server.ssl.key-store-password=mysecret --from-literal=server.port=8443</span><span id="3726" class="ls lt iq lo b gy nd lv l lw lx">$ cat &lt;&lt;EOF | oc apply -f -<br/>apiVersion: apps.openshift.io/v1<br/>kind: DeploymentConfig<br/>metadata:<br/>  name: fuse7-hello<br/>  labels:<br/>    app: fuse7-hello<br/>spec:<br/>  replicas: 1<br/>  selector:<br/>    app: fuse7-hello<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: fuse7-hello<br/>    spec:<br/>      containers:<br/>      - name: default-container<br/>        image: 172.30.1.1:5000/openshift/camel-springboot:latest<br/>        readinessProbe:<br/>           failureThreshold: 3<br/>           httpGet:<br/>             path: /health<br/>             port: 8443<br/>             scheme: HTTPS<br/>           initialDelaySeconds: 10<br/>           timeoutSeconds: 1<br/>        resources:<br/>           limits:<br/>             memory: 512Mi<br/>        volumeMounts:<br/>          - mountPath: /etc/keystore<br/>            name: keystore-volume<br/>      volumes:<br/>        - name: keystore-volume<br/>          secret:<br/>            secretName: hello-keystore<br/>EOF</span><span id="d759" class="ls lt iq lo b gy nd lv l lw lx">$ oc create service clusterip fuse7-hello --tcp=8443:8443</span><span id="2874" class="ls lt iq lo b gy nd lv l lw lx">$ cat &lt;&lt;EOF | oc apply -f -<br/>apiVersion: route.openshift.io/v1<br/>kind: Route<br/>metadata:<br/>  labels:<br/>    app: fuse7-hello<br/>  name: fuse7-hello-passthrough<br/>spec:<br/>  host: fuse7-hello-passthrough.192.168.99.100.nip.io<br/>  port:<br/>    targetPort: 8443-8443<br/>  tls:<br/>    termination: passthrough<br/>  to:<br/>    kind: Service<br/>    name: fuse7-hello<br/>EOF</span><span id="3609" class="ls lt iq lo b gy nd lv l lw lx">$ curl -k https://fuse7-hello-passthrough.192.168.99.100.nip.io/api/hello<br/><em class="km">{"message":"Hello World!"}</em></span><span id="463c" class="ls lt iq lo b gy nd lv l lw lx">$ cat &lt;&lt;EOF | oc apply -f -<br/>apiVersion: route.openshift.io/v1<br/>kind: Route<br/>metadata:<br/>  labels:<br/>    app: fuse7-hello<br/>  name: fuse7-hello-reencrypt<br/>spec:<br/>  host: fuse7-hello-reencrypt.192.168.99.100.nip.io<br/>  port:<br/>    targetPort: 8443-8443<br/>  tls:<br/>    termination: reencrypt<br/>    destinationCACertificate: |-<br/>      -----BEGIN CERTIFICATE-----<br/>      <em class="km"># Certificate from selfsigned.crt</em><br/>      -----END CERTIFICATE-----<br/>  to:<br/>    kind: Service<br/>    name: fuse7-hello<br/>EOF</span><span id="7652" class="ls lt iq lo b gy nd lv l lw lx">$ curl -k https://fuse7-hello-reencrypt.192.168.99.100.nip.io/api/hello<br/><em class="km">{"message":"Hello World!"}</em></span><span id="6e65" class="ls lt iq lo b gy nd lv l lw lx">$ cat &lt;&lt;EOF | oc apply -f -<br/>apiVersion: route.openshift.io/v1<br/>kind: Route<br/>metadata:<br/>  labels:<br/>    app: fuse7-hello<br/>  name: fuse7-hello-custom<br/>spec:<br/>  host: any.custom.name<br/>  port:<br/>    targetPort: 8443-8443<br/>  tls:<br/>    termination: passthrough<br/>  to:<br/>    kind: Service<br/>    name: fuse7-hello<br/>EOF</span><span id="a848" class="ls lt iq lo b gy nd lv l lw lx">$ curl -k --resolve any.custom.name:443:192.168.99.100 https://any.custom.name/api/hello<br/><em class="km">{"message":"Hello World!"}</em></span></pre></div></div>    
</body>
</html>