<html>
<head>
<title>Clean Code with ES6: ExpressJS + ReactJS: Part 3</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用ES6清理代码:ExpressJS + ReactJS:第3部分</h1>
<blockquote>原文：<a href="https://itnext.io/clean-code-with-es6-expressjs-reactjs-part-3-2306b1f62c26?source=collection_archive---------3-----------------------#2018-03-29">https://itnext.io/clean-code-with-es6-expressjs-reactjs-part-3-2306b1f62c26?source=collection_archive---------3-----------------------#2018-03-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/d7930344e8dd5c427ecfe11b931965ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6K5vmzalJUxn44v3cm6wBw.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">由<a class="ae kc" href="https://unsplash.com/photos/oZPwn40zCK4?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">托马斯·克维斯霍尔特</a>在<a class="ae kc" href="https://unsplash.com/search/photos/server?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><blockquote class="kd ke kf"><p id="7f59" class="kg kh ki kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated"><a class="ae kc" href="https://www.linkedin.com/cws/share?url=https%3A%2F%2Fitnext.io%2Fclean-code-with-es6-expressjs-reactjs-part-3–2306b1f62c26%3Futm_source%3Dmedium_sharelink%26utm_medium%3Dsocial%26utm_campaign%3Dbuffer" rel="noopener ugc nofollow" target="_blank">点击这里在LinkedIn上分享这篇文章</a></p></blockquote><p id="a99e" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">这是一个简短系列文章的第三部分，重点是使用ES6+ Javascript、React、Redux、ExpressJS和MongoDB创建和部署一个准系统的全栈博客站点。</p><p id="4de4" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">在这些文章中，我真的试图把重点放在我发现的使用ES6+ JavaScript和我称之为“Redux风格”的项目结构来设置和组织我的代码的一些方法上。目标是编写可读、可扩展且易于测试的代码。</p><p id="19bf" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">这个系列将分为几个部分:</p><ol class=""><li id="4049" class="li lj iq kj b kk kl ko kp lf lk lg ll lh lm le ln lo lp lq bi translated"><a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/clean-code-with-react-expressjs-and-mongodb-part-1-aa6b1a4aef82">设置ExpressJS使用ES6+语法</a></li><li id="8776" class="li lj iq kj b kk lr ko ls lf lt lg lu lh lv le ln lo lp lq bi translated"><a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/clean-code-with-react-expressjs-and-mongodb-part-2-89d20e684820"> Redux风格的文件结构</a></li><li id="9b80" class="li lj iq kj b kk lr ko ls lf lt lg lu lh lv le ln lo lp lq bi translated">创建简单快速服务器👈🏽<em class="ki">你在这里</em></li><li id="8e7e" class="li lj iq kj b kk lr ko ls lf lt lg lu lh lv le ln lo lp lq bi translated">用我们的博客设置Mongoose(即将推出！)</li><li id="c098" class="li lj iq kj b kk lr ko ls lf lt lg lu lh lv le ln lo lp lq bi translated">用CMS创建一个React博客(即将推出！)</li><li id="9170" class="li lj iq kj b kk lr ko ls lf lt lg lu lh lv le ln lo lp lq bi translated">将Redux添加到您的前端(即将推出！)</li><li id="d1cc" class="li lj iq kj b kk lr ko ls lf lt lg lu lh lv le ln lo lp lq bi translated">包装您的应用:部署(即将推出！)</li></ol><h1 id="f8be" class="lw lx iq bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">创建简单快速服务器</h1><p id="fa63" class="pw-post-body-paragraph kg kh iq kj b kk mu km kn ko mv kq kr lf mw ku kv lg mx ky kz lh my lc ld le ij bi translated">现在我们已经设置好了ES6+语法，并且知道如何“Redux-style”地导入/导出我们的模块，让我们开始用ExpressJS创建一个非常简单但是健壮的服务器。</p><p id="fbb8" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">如果您遵循上一篇文章，您的文件结构应该如下所示。不要担心<code class="fe mz na nb nc b">*.js</code>文件是空的，因为我们很快就会处理它们。</p><pre class="nd ne nf ng gt nh nc ni nj aw nk bi"><span id="08b3" class="nl lx iq nc b gy nm nn l no np">📁/<br/> 📂configs/<br/>  📄index.js<br/>  📄server.js<br/> 📂database/<br/> 📂routes/<br/> 📄index.js<br/> 📄.babelrc<br/> 📄package.json<br/> 📄yarn.lock</span></pre><p id="d8a5" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">首先清除我们的<strong class="kj ir">根</strong>T1】文件中的所有内容。复制并粘贴以下代码:</p><p id="d007" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated"><em class="ki">。/index.js: </em></p><pre class="nd ne nf ng gt nh nc ni nj aw nk bi"><span id="a842" class="nl lx iq nc b gy nm nn l no np">// APP<br/>import express from 'express'<br/>const app = express()<br/>// CONFIGS<br/>// ROUTES<br/>// RUN<br/>app.listen(8000, err =&gt; {<br/>  if (err) {<br/>    console.log(err)<br/>  }<br/>  console.log('EXPRESS SERVER Running on port: 8000')<br/>})</span></pre><p id="1cb2" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">🔬我们正在做三件事:</p><ol class=""><li id="3434" class="li lj iq kj b kk kl ko kp lf lk lg ll lh lm le ln lo lp lq bi translated">导入express(不使用“Redux-style”)</li><li id="fd0d" class="li lj iq kj b kk lr ko ls lf lt lg lu lh lv le ln lo lp lq bi translated">快速应用程序的创建和实例</li><li id="7756" class="li lj iq kj b kk lr ko ls lf lt lg lu lh lv le ln lo lp lq bi translated">告诉我们的express应用程序在端口8000运行并报告(或报告任何错误)</li></ol><h1 id="7402" class="lw lx iq bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">配置服务器中间件</h1><p id="3368" class="pw-post-body-paragraph kg kh iq kj b kk mu km kn ko mv kq kr lf mw ku kv lg mx ky kz lh my lc ld le ij bi translated">接下来，让我们设置我们的中间件。我们将使用以下包:<a class="ae kc" href="https://www.npmjs.com/package/helmet" rel="noopener ugc nofollow" target="_blank">头盔</a>、<a class="ae kc" href="https://www.npmjs.com/package/compression" rel="noopener ugc nofollow" target="_blank">压缩</a>、<a class="ae kc" href="https://www.npmjs.com/package/body-parser" rel="noopener ugc nofollow" target="_blank">身体解析器</a>、<a class="ae kc" href="https://www.npmjs.com/package/cors" rel="noopener ugc nofollow" target="_blank"> cors </a>和<a class="ae kc" href="https://www.npmjs.com/package/morgan" rel="noopener ugc nofollow" target="_blank">摩根</a>。</p><p id="85de" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">🔬<strong class="kj ir">中间件</strong>是在HTTP请求路由逻辑之前运行的代码的术语</p><p id="1f67" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">用纱线将它们安装在我们的终端:</p><p id="4145" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated"><code class="fe mz na nb nc b">yarn add helmet compression body-parser cors -S</code></p><p id="b56a" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">和</p><p id="f4af" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated"><code class="fe mz na nb nc b">yarn add morgan -D</code></p><p id="bc27" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">在<code class="fe mz na nb nc b">📂configs/</code>目录中修改<code class="fe mz na nb nc b">server.js</code>和<code class="fe mz na nb nc b">index.js</code>如下:</p><p id="776b" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated"><em class="ki">。/configs/server.js: </em></p><pre class="nd ne nf ng gt nh nc ni nj aw nk bi"><span id="016a" class="nl lx iq nc b gy nm nn l no np">import helmet from 'helmet'<br/>import compression from 'compression'<br/>import cors from 'cors'<br/>import morgan from 'morgan'<br/>import bodyParser from 'body-parser'<br/>//<br/>export const configureServer = app =&gt; {<br/>  app.use(helmet())<br/>  app.use(compression())<br/>  app.use(bodyParser.urlencoded({ extended: 'true' }))<br/>  app.use(bodyParser.json())<br/>  app.use(bodyParser.json({ type: 'application/vnd.api+json' }))<br/>  app.use(morgan('dev'))<br/>  app.use(cors())<br/>  return app<br/>}</span></pre><p id="dbe3" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated"><em class="ki">。/configs/index.js </em></p><pre class="nd ne nf ng gt nh nc ni nj aw nk bi"><span id="6d52" class="nl lx iq nc b gy nm nn l no np">export * from './server'</span></pre><p id="b21a" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">现在，在我们的<strong class="kj ir">根</strong>T5处，添加以下代码:</p><p id="c1f1" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated"><em class="ki">。/index.js: </em></p><pre class="nd ne nf ng gt nh nc ni nj aw nk bi"><span id="a6f3" class="nl lx iq nc b gy nm nn l no np">// APP<br/>import express from 'express'<br/>const app = express()<br/>// CONFIGS<br/>import {configureServer} from './configs<br/>configureServer(app)<br/>// ROUTES<br/>// RUN<br/>app.listen(8000, err =&gt; {<br/>  if (err) {<br/>    console.log(err)<br/>  }<br/>  console.log('EXPRESS SERVER Running on port: 8000')<br/>})</span></pre><p id="b098" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">🔬让我们来分析一下这个复制意大利面:</p><ol class=""><li id="7d0f" class="li lj iq kj b kk kl ko kp lf lk lg ll lh lm le ln lo lp lq bi translated">我们正在导入我们的中间件，以便稍后可以通过它运行我们的应用程序:</li></ol><ul class=""><li id="34b2" class="li lj iq kj b kk kl ko kp lf lk lg ll lh lm le nq lo lp lq bi translated"><a class="ae kc" href="https://www.npmjs.com/package/helmet" rel="noopener ugc nofollow" target="_blank"> <strong class="kj ir">头盔</strong> </a>为我们的HTTP头提供了基本的安全性</li><li id="5572" class="li lj iq kj b kk lr ko ls lf lt lg lu lh lv le nq lo lp lq bi translated"><a class="ae kc" href="https://www.npmjs.com/package/compression" rel="noopener ugc nofollow" target="_blank"> <strong class="kj ir">压缩</strong> </a>减小我们发送回客户端的响应的大小</li><li id="b3e0" class="li lj iq kj b kk lr ko ls lf lt lg lu lh lv le nq lo lp lq bi translated"><a class="ae kc" href="https://www.npmjs.com/package/cors" rel="noopener ugc nofollow" target="_blank"> <strong class="kj ir"> cors </strong> </a>保护我们免受可疑的<a class="ae kc" href="https://w3c.github.io/webappsec-cors-for-developers/" rel="noopener ugc nofollow" target="_blank">跨来源请求</a></li><li id="7764" class="li lj iq kj b kk lr ko ls lf lt lg lu lh lv le nq lo lp lq bi translated"><a class="ae kc" href="https://www.npmjs.com/package/morgan" rel="noopener ugc nofollow" target="_blank"> <strong class="kj ir">摩根</strong> </a>是一个伟大的，基本的工具，让我们监视我们的控制台中的HTTP活动</li><li id="fd84" class="li lj iq kj b kk lr ko ls lf lt lg lu lh lv le nq lo lp lq bi translated"><a class="ae kc" href="https://www.npmjs.com/package/body-parser" rel="noopener ugc nofollow" target="_blank"> <strong class="kj ir"> body-parser </strong> </a>转换传入的请求，以便我们可以在Express中处理它们</li></ul><p id="2799" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">2.接下来，我们创建一个接受Express应用程序实例的函数，并通过中间件运行该应用程序。</p><p id="7002" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated"><em class="ki">(注意:这些中间件中的每一个都可以彻底配置。</em><strong class="kj ir"><em class="ki">CORS</em></strong><em class="ki">尤其如此。因为我们正在设置一个最小的服务器，所以我不会在这里讨论这些细节，但是我们过一会儿再回到cors。)</em></p><h1 id="c4e4" class="lw lx iq bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">设置路线</h1><p id="9f1c" class="pw-post-body-paragraph kg kh iq kj b kk mu km kn ko mv kq kr lf mw ku kv lg mx ky kz lh my lc ld le ij bi translated">在<code class="fe mz na nb nc b">📂routes/</code>目录下，创建以下两个文件:<code class="fe mz na nb nc b">public.js</code>和<code class="fe mz na nb nc b">index.js</code>。我们将在这里用<code class="fe mz na nb nc b">index.js</code>做一些稍微不同的事情，但是不要担心，它非常符合一直指导我们的组织精神。</p><p id="c412" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">将以下代码添加到各自的文件中:</p><p id="61fd" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated"><em class="ki">。/routes/public.js: </em></p><pre class="nd ne nf ng gt nh nc ni nj aw nk bi"><span id="a371" class="nl lx iq nc b gy nm nn l no np">export const publicRoutes = app =&gt; {<br/>  app.get('/', (req, res) =&gt; {<br/>    res.json({ message: 'Hello GET from ROOT' })<br/>  })</span><span id="e83c" class="nl lx iq nc b gy nr nn l no np">app.post('/', (req, res) =&gt; {<br/>    res.json({ message: 'Hello POST from ROOT' })<br/>  })<br/>}</span></pre><p id="0e23" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated"><em class="ki">。/routes/index.js: </em></p><pre class="nd ne nf ng gt nh nc ni nj aw nk bi"><span id="16d0" class="nl lx iq nc b gy nm nn l no np">import { publicRoutes } from './public'</span><span id="b274" class="nl lx iq nc b gy nr nn l no np">export const configureRoutes = app =&gt; {<br/>  publicRoutes(app)<br/>  return app<br/>}</span></pre><p id="5b06" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">现在，让我们使用我们的主要路线<code class="fe mz na nb nc b">index.js</code>。我们的整个<code class="fe mz na nb nc b">index.js</code>应该如下所示:</p><p id="cde4" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated"><em class="ki">。/index.js: </em></p><pre class="nd ne nf ng gt nh nc ni nj aw nk bi"><span id="a31a" class="nl lx iq nc b gy nm nn l no np">// APP<br/>import express from 'express'<br/>const app = express()<br/>// CONFIGS<br/>import { configureServer, configureDb } from './configs'<br/>configureServer(app)<br/>// ROUTES<br/>import { configureRoutes } from './routes'<br/>configureRoutes(app)<br/>// RUN<br/>app.listen(8000, err =&gt; {<br/>  if (err) {<br/>    console.log(err)<br/>  }<br/>  console.log('EXPRESS SERVER Running on port: 8000')<br/>})</span></pre><p id="db29" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">如果您现在运行应用程序，您应该能够从我们指定的两条路线获得回复。使用Postman，我们可以看到我们从<code class="fe mz na nb nc b"><a class="ae kc" href="http://localhost:8000/:" rel="noopener ugc nofollow" target="_blank">http://localhost:8000/</a></code> <a class="ae kc" href="http://localhost:8000/:" rel="noopener ugc nofollow" target="_blank"> : </a></p><pre class="nd ne nf ng gt nh nc ni nj aw nk bi"><span id="7050" class="nl lx iq nc b gy nm nn l no np">{ "message": "Hello GET from ROOT" }</span></pre><p id="0220" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">不错！</p><h1 id="dc6e" class="lw lx iq bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">进一步组织</h1><p id="a531" class="pw-post-body-paragraph kg kh iq kj b kk mu km kn ko mv kq kr lf mw ku kv lg mx ky kz lh my lc ld le ij bi translated">但是为什么就此打住呢？</p><p id="0faf" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">浏览我们的代码，我们可以注意到两件事:</p><ol class=""><li id="14ac" class="li lj iq kj b kk kl ko kp lf lk lg ll lh lm le ln lo lp lq bi translated">我们重复代码的某些部分，其中一些我们可以称之为“常量”</li><li id="73e2" class="li lj iq kj b kk lr ko ls lf lt lg lu lh lv le ln lo lp lq bi translated">我们可能想把逻辑从我们的路线中分离出来</li></ol><p id="8e99" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">将我们的常量分离到一个单独的文件中是一个特别好的主意。我们可以在我们的<code class="fe mz na nb nc b">📂configs</code>目录中创建一个<code class="fe mz na nb nc b">constants.js</code>文件。它将保存与我们的工作环境相关的所有逻辑(比如在<code class="fe mz na nb nc b">.env</code>文件中指定的端口和API键:参见这篇<a class="ae kc" href="https://www.twilio.com/blog/2017/08/working-with-environment-variables-in-node-js.html" rel="noopener ugc nofollow" target="_blank"> Twilio文章</a>了解更多信息。</p><h2 id="f14d" class="nl lx iq bd ly ns nt dn mc nu nv dp mg lf nw nx mk lg ny nz mo lh oa ob ms oc bi translated">清洁和粉笔索引. js</h2><p id="b04e" class="pw-post-body-paragraph kg kh iq kj b kk mu km kn ko mv kq kr lf mw ku kv lg mx ky kz lh my lc ld le ij bi translated">在我们开始工作之前，让我们进一步清理我们的主<code class="fe mz na nb nc b">index.js</code>并清理我们的控制台输出！这并不是真正必要的，但是为什么不竭尽全力让我们的代码看起来超级干净和易读呢？</p><p id="cfed" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">使用纱线添加<a class="ae kc" href="https://www.npmjs.com/package/chalk" rel="noopener ugc nofollow" target="_blank">粉笔</a>:</p><pre class="nd ne nf ng gt nh nc ni nj aw nk bi"><span id="5a6c" class="nl lx iq nc b gy nm nn l no np">yarn add chalk -D</span></pre><p id="1509" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">现在，在我们的<code class="fe mz na nb nc b">📂configs</code>目录中创建一个名为<code class="fe mz na nb nc b">runServer.js</code>的文件。添加以下代码:</p><p id="63d5" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated"><em class="ki">。/configs/runServer.js: </em></p><pre class="nd ne nf ng gt nh nc ni nj aw nk bi"><span id="b803" class="nl lx iq nc b gy nm nn l no np">import { constants } from './'<br/>import chalk from 'chalk'</span><span id="56b0" class="nl lx iq nc b gy nr nn l no np">export const runServer = app =&gt; {<br/>  app.listen(constants.PORT, err =&gt; {<br/>    let date = new Date()<br/>    if (err) {<br/>      console.log(chalk.redBright(err))<br/>    }<br/>    console.log(<br/>      chalk.bgBlueBright('Express Server\n') +<br/>        chalk.blueBright(<br/>          'Port: ' + constants.PORT + '\nStarted: ' + date.toLocaleTimeString()<br/>        )<br/>    )<br/>  })<br/>}</span></pre><p id="9963" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">🔬Chalk允许我们指定控制台输出的颜色，如果你整天盯着你的控制台，这是很好的。我们还添加了时间，这样我们就可以看到服务器上次刷新的时间。</p><p id="2d70" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">注意，我们已经从同一个<code class="fe mz na nb nc b">📂configs</code>目录中导入了<code class="fe mz na nb nc b">constants</code>。让我们来指定这些常数。创建一个名为<code class="fe mz na nb nc b">constants.js</code>的文件，在同一个目录下通过<code class="fe mz na nb nc b">index.js</code>导出两个新函数:</p><p id="e767" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated"><em class="ki">。/configs/constants.js: </em></p><pre class="nd ne nf ng gt nh nc ni nj aw nk bi"><span id="8b05" class="nl lx iq nc b gy nm nn l no np">export const constants = {<br/>  PORT: 8000<br/>}</span></pre><p id="f24c" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated"><em class="ki">。/configs/index.js: </em></p><pre class="nd ne nf ng gt nh nc ni nj aw nk bi"><span id="05c4" class="nl lx iq nc b gy nm nn l no np">export * from './constants'<br/>export * from './runServer'<br/>export * from './server'</span></pre><p id="5f1a" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">现在我们可以用下面的代码更新我们的<code class="fe mz na nb nc b">📁backend</code>目录中的<code class="fe mz na nb nc b">index.js</code>，删除<code class="fe mz na nb nc b">app.listen(8000)...</code>。既然这样，让我们重新安排一下<code class="fe mz na nb nc b">import</code>语句。如果我们拿它穿过棉绒，它会心脏病发作。整个文件应该如下所示:</p><p id="b15b" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated"><em class="ki">。/index.js: </em></p><pre class="nd ne nf ng gt nh nc ni nj aw nk bi"><span id="78f6" class="nl lx iq nc b gy nm nn l no np">// IMPORTS<br/>import express from 'express'<br/>import { configureServer, runServer } from './configs'<br/>import { configureRoutes } from './routes'<br/>// INITALIZE APP<br/>const app = express()<br/>// CONFIGS<br/>configureServer(app)<br/>// ROUTES<br/>configureRoutes(app)<br/>// RUN<br/>runServer(app)</span></pre><p id="90de" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">不仅可读性更好，而且，当我们需要修改某些东西时，我们知道去哪里！</p><h1 id="1c4c" class="lw lx iq bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">清理路线</h1><p id="4581" class="pw-post-body-paragraph kg kh iq kj b kk mu km kn ko mv kq kr lf mw ku kv lg mx ky kz lh my lc ld le ij bi translated">虽然我们还没有建立我们的MongoDB数据库(这是下一篇文章)，但是我们仍然可以通过将逻辑(或者将要成为的逻辑)移动到<code class="fe mz na nb nc b">📁database</code>目录来做准备。但是让我们从<code class="fe mz na nb nc b">📁routes</code>目录开始。</p><p id="e7ae" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">用以下代码修改<code class="fe mz na nb nc b">📁routes</code>目录中的<code class="fe mz na nb nc b">public.js</code>:</p><p id="7737" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated"><em class="ki">。/routes/public.js: </em></p><pre class="nd ne nf ng gt nh nc ni nj aw nk bi"><span id="71e2" class="nl lx iq nc b gy nm nn l no np">import { postsGetAll, userLogin } from '../database'</span><span id="a3aa" class="nl lx iq nc b gy nr nn l no np">export const publicRoutes = app =&gt; {<br/>  app.get('/api/get_all_posts', postsGetAll)<br/>}</span></pre><p id="de20" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">让我们保持逻辑的语义分离。没有必要，但仍然是一个好主意。我们将创建另一个路由文件:</p><p id="ccf9" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated"><em class="ki">。/routes/userManagement.js: </em></p><pre class="nd ne nf ng gt nh nc ni nj aw nk bi"><span id="21d0" class="nl lx iq nc b gy nm nn l no np">import { postsGetAll, userLogin } from '../database'</span><span id="5037" class="nl lx iq nc b gy nr nn l no np">export const userManagementRoutes = app =&gt; {<br/>  app.post('/api/login_user', userLogin)<br/>}</span></pre><p id="6064" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">现在我们需要更新<code class="fe mz na nb nc b">📁routes</code>目录中的<code class="fe mz na nb nc b">index.js</code>:</p><p id="61ea" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated"><em class="ki">。/routes/index.js: </em></p><pre class="nd ne nf ng gt nh nc ni nj aw nk bi"><span id="62f4" class="nl lx iq nc b gy nm nn l no np">import { publicRoutes } from './public'<br/>import { userManagementRoutes } from './userManagement'</span><span id="de72" class="nl lx iq nc b gy nr nn l no np">export const configureRoutes = app =&gt; {<br/>  publicRoutes(app)<br/>  userManagementRoutes(app_<br/>  return app<br/>}</span></pre><p id="7c3d" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">🔬请注意，我们更改了路由文件中的URL。如果我们使用带有内置路由器的ExpressJS，URL将取决于您在路由过程中的位置。有了这种类型的架构，我们可以清楚地知道我们要把客户送到哪里。</p><h1 id="ca1d" class="lw lx iq bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">数据库逻辑的位置</h1><p id="b610" class="pw-post-body-paragraph kg kh iq kj b kk mu km kn ko mv kq kr lf mw ku kv lg mx ky kz lh my lc ld le ij bi translated">即使我们正在做一些甜蜜的路由，如果我们试图运行我们的应用程序，它会崩溃。这是因为我们需要在我们的<code class="fe mz na nb nc b">📁database</code>目录中设置一些东西。现在，让我们通过创建以下文件来实现这一点:</p><p id="3b2d" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated"><em class="ki">。/database/posts.js </em></p><pre class="nd ne nf ng gt nh nc ni nj aw nk bi"><span id="baf4" class="nl lx iq nc b gy nm nn l no np">// Blog Post Logic<br/>export const postsGetAll = (req, res) =&gt; {<br/>         res.json({ posts: 'ALL POSTS!' })<br/>}</span></pre><p id="dc72" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated"><em class="ki">。/database/user.js </em></p><pre class="nd ne nf ng gt nh nc ni nj aw nk bi"><span id="970f" class="nl lx iq nc b gy nm nn l no np">// User Management Logic</span><span id="942f" class="nl lx iq nc b gy nr nn l no np">export const userLogin = (req, res) =&gt; {<br/>         res.json({ username: 'User Login Username: ' +         <br/>                    req.body.username })<br/>}</span></pre><p id="6e2e" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated"><em class="ki">。/database/index.js </em></p><pre class="nd ne nf ng gt nh nc ni nj aw nk bi"><span id="844e" class="nl lx iq nc b gy nm nn l no np">export * from './posts'<br/>export * from './user'</span></pre><p id="0661" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">现在我们可以用<code class="fe mz na nb nc b">yarn start</code>运行我们的服务器并测试路线了！我将使用Postman来完成这项工作:</p><h1 id="adb1" class="lw lx iq bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">接下来呢？</h1><p id="ff0a" class="pw-post-body-paragraph kg kh iq kj b kk mu km kn ko mv kq kr lf mw ku kv lg mx ky kz lh my lc ld le ij bi translated">在本文中，我们学习了如何设置一个非常简单的服务器。以这种方式分离我们的逻辑不仅有助于可读性，还有助于重用。(如果<em class="ki">真的</em>我们想要，我们可以创建另一个Express实例，使用不同的路由，但是使用相同的中间件！)在下一篇文章中，我们将探讨如何使用Mongoose设置MongoDB。敬请期待！</p></div></div>    
</body>
</html>