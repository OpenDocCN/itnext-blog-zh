<html>
<head>
<title>Do your tax filling by using a directed acyclic graph</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过使用有向无环图来报税</h1>
<blockquote>原文：<a href="https://itnext.io/do-your-tax-filling-by-using-a-directed-acyclic-graph-ed89682adbd0?source=collection_archive---------5-----------------------#2021-07-05">https://itnext.io/do-your-tax-filling-by-using-a-directed-acyclic-graph-ed89682adbd0?source=collection_archive---------5-----------------------#2021-07-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/ddbcf057fb7da9f08831c07e886d91d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L_wFn2GojD2bgwGzHn27jQ.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://www.pexels.com/photo/tax-return-form-and-notebooks-on-the-table-6863514/" rel="noopener ugc nofollow" target="_blank">娜塔莉亚·瓦特凯维奇</a>在<a class="ae kc" href="https://www.pexels.com/" rel="noopener ugc nofollow" target="_blank">佩克斯</a>拍摄</figcaption></figure><p id="8137" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在许多国家，当你完成记账后，你必须填写一些官方表格。文档中的每个单元格通常遵循一些不透明的规则，在这些规则中，您需要绘制不同数量的簿记，并最终将它们与其他单元格的值相结合。它看起来像一个巨大的人造电子表格，实际上是一个依赖关系的<a class="ae kc" href="https://en.wikipedia.org/wiki/Directed_acyclic_graph" rel="noopener ugc nofollow" target="_blank">有向无环图</a>(或DAG)。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h2 id="e584" class="li lj iq bd lk ll lm dn ln lo lp dp lq ko lr ls lt ks lu lv lw kw lx ly lz ma bi translated">定义图表</h2><p id="bbe5" class="pw-post-body-paragraph kd ke iq kf b kg mb ki kj kk mc km kn ko md kq kr ks me ku kv kw mf ky kz la ij bi translated">让我们定义填充文档的规则:</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="21ae" class="li lj iq ml b gy mp mq l mr ms">const <strong class="ml ir"><em class="mt">documentRules </em></strong>= {<br/>    cell1({bookkeeping: {amount1}}) {<br/>        return amount1 * 2;<br/>    },<br/>    cell2({bookkeeping: {amount2}, document: {cell1}}) {<br/>        return amount2 + cell1;<br/>    },<br/>    cell3({document: {cell2}}) {<br/>        return cell2 + 42;<br/>    },<br/>    // etc<br/>};</span></pre><p id="4a55" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">每个属性都是一个函数，它的名字指向文档的一个给定的单元格，它的参数是依赖项，我们需要通过解析来获取单元格的值。<br/>如果<em class="mt">记账</em>是一个外部依赖关系(我们可以假设所有记账值在当前单据之前已经被解析)，则<em class="mt">单据</em>引用当前单据(<em class="mt">即</em>引用<em class="mt">单据规则</em>对象的其他函数)。</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mu"><img src="../Images/335c2b9f167215e2d74896b4ee478956.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Le4wQWM2B3XP_PBEbmVbzA.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">依赖图</figcaption></figure><p id="7106" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您希望用正确的数量填充文档，您需要以某种方式解析根节点所依赖的所有值(以及它们的传递依赖关系)。幸运的是，在JavaScript中只需要几行代码！</p><h2 id="9f3c" class="li lj iq bd lk ll lm dn ln lo lp dp lq ko lr ls lt ks lu lv lw kw lx ly lz ma bi translated">属性描述符</h2><p id="25b6" class="pw-post-body-paragraph kd ke iq kf b kg mb ki kj kk mc km kn ko md kq kr ks me ku kv kw mf ky kz la ij bi translated">在Javascript中，由于有了<a class="ae kc" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" rel="noopener ugc nofollow" target="_blank">属性描述符</a>，您可以精确定义对象的属性行为。例如，您可以定义一个getter函数或/和setter函数，每当通过常规点符号/等式赋值读取或赋值属性时，都会调用该函数。</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="056f" class="li lj iq ml b gy mp mq l mr ms">const <strong class="ml ir"><em class="mt">obj </em></strong>= <strong class="ml ir"><em class="mt">Object</em></strong>.defineProperties({} /* here empty object but can be whatever object */,{<br/>    someProp:{<br/>        get(){<br/>            <strong class="ml ir"><em class="mt">console</em></strong>.log('getter called');<br/>            return 42;<br/>        },<br/>        set(val){<br/>            <strong class="ml ir"><em class="mt">console</em></strong>.log('setter is ignored');<br/>        }<br/>    }<br/>});<br/><br/><strong class="ml ir"><em class="mt">console</em></strong>.log(<strong class="ml ir"><em class="mt">obj</em></strong>.someProp); // getter called<br/><br/><strong class="ml ir"><em class="mt">obj</em></strong>.someProp = 43; // setter called<br/><br/><strong class="ml ir"><em class="mt">console</em></strong>.log(<strong class="ml ir"><em class="mt">obj</em></strong>.someProp); // still 42!</span></pre><p id="bc56" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这将在控制台中打印出来:</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="f568" class="li lj iq ml b gy mp mq l mr ms">getter called<br/>42<br/>setter is ignored<br/>getter called<br/>42</span></pre><p id="ffc5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我能想到的一些常见用例有:</p><ul class=""><li id="fba3" class="mv mw iq kf b kg kh kk kl ko mx ks my kw mz la na nb nc nd bi translated">将属性设为只读</li></ul><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="4b7b" class="li lj iq ml b gy mp mq l mr ms">const <strong class="ml ir"><em class="mt">obj </em></strong>= <strong class="ml ir"><em class="mt">Object</em></strong>.defineProperties({},{<br/>    someProp:{<br/>        get(){<br/>            return 42;<br/>        }<br/>    }<br/>});<br/><br/><strong class="ml ir"><em class="mt">obj</em></strong>.someProp = 43; // will throw " Cannot set property someProp of #&lt;Object&gt; which has only a getter"</span></pre><ul class=""><li id="7dc8" class="mv mw iq kf b kg kh kk kl ko mx ks my kw mz la na nb nc nd bi translated">代理属性:</li></ul><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="d153" class="li lj iq ml b gy mp mq l mr ms">let <strong class="ml ir"><em class="mt">value </em></strong>= 42;<br/><br/>const <strong class="ml ir"><em class="mt">descriptors </em></strong>= {<br/>    someProp:{<br/>        get(){<br/>            return <strong class="ml ir"><em class="mt">value</em></strong>;<br/>        },<br/>        set(val){<br/>            <strong class="ml ir"><em class="mt">value </em></strong>= val<br/>        }<br/>    }<br/>}<br/><br/>const <strong class="ml ir"><em class="mt">obj </em></strong>= <strong class="ml ir"><em class="mt">Object</em></strong>.defineProperties({},<strong class="ml ir"><em class="mt">descriptors</em></strong>);<br/>const <strong class="ml ir"><em class="mt">objBis </em></strong>= <strong class="ml ir"><em class="mt">Object</em></strong>.defineProperties({},<strong class="ml ir"><em class="mt">descriptors</em></strong>); // different object !<br/><strong class="ml ir"><em class="mt">obj</em></strong>.someProp = 43;<br/><strong class="ml ir"><em class="mt">console</em></strong>.log(<strong class="ml ir"><em class="mt">objBis</em></strong>.someProp); // 43 !</span></pre><ul class=""><li id="2338" class="mv mw iq kf b kg kh kk kl ko mx ks my kw mz la na nb nc nd bi translated">记录属性访问</li><li id="d6e5" class="mv mw iq kf b kg ne kk nf ko ng ks nh kw ni la na nb nc nd bi translated">等等..</li></ul><p id="4c4f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请注意，析构对象也会调用这些getters:</p><p id="b28c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe nj nk nl ml b">const {someProp} = obj;// getter for "someProp" is called here</code></p><h2 id="146a" class="li lj iq bd lk ll lm dn ln lo lp dp lq ko lr ls lt ks lu lv lw kw lx ly lz ma bi translated">解析图形</h2><p id="c93f" class="pw-post-body-paragraph kd ke iq kf b kg mb ki kj kk mc km kn ko md kq kr ks me ku kv kw mf ky kz la ij bi translated">仔细想想，您几乎可以将文档及其依赖图定义为一个普通的Javascript对象:</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="ef36" class="li lj iq ml b gy mp mq l mr ms">const <strong class="ml ir"><em class="mt">bookkeeping </em></strong>= {<br/>    // whatever<br/>}<br/><br/>const <strong class="ml ir"><em class="mt">document </em></strong>= {<br/>    cell1: <strong class="ml ir"><em class="mt">bookkeeping</em></strong>.amount1,<br/>    cell2: <strong class="ml ir"><em class="mt">bookkeeping</em></strong>.amount2 + <strong class="ml ir"><em class="mt">document</em></strong>.cell1,<br/>    cell3: <strong class="ml ir"><em class="mt">document</em></strong>.cell2<br/>}</span></pre><p id="bb49" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">问题在于你不能在文件初始化之前使用它，上面的代码会抛出</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="9f07" class="li lj iq ml b gy mp mq l mr ms">ReferenceError: Cannot access ‘document’ before initialization</span></pre><p id="a2ca" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是我们可以利用属性getters来推迟对属性的访问，直到真正需要它的时候(由cell rule函数分解)。</p><p id="a91f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们先定义一些实用函数(通常由库提供如<a class="ae kc" href="https://ramdajs.com/" rel="noopener ugc nofollow" target="_blank"> ramda </a>、<a class="ae kc" href="https://lodash.com/" rel="noopener ugc nofollow" target="_blank"> lodash </a>等):</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="ba3a" class="li lj iq ml b gy mp mq l mr ms">const mapValues = (mapFn) =&gt; (target) =&gt; <strong class="ml ir"><em class="mt">Object</em></strong>.fromEntries(<br/>    <strong class="ml ir"><em class="mt">Object<br/>        </em></strong>.entries(target)<br/>        .map(([key, value]) =&gt; [key, mapFn(value)])<br/>);</span></pre><p id="0bb7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="mt"> mapValues </em>用提供的函数映射一个对象的值，并返回一个形状与目标相同的新对象:</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="0cc5" class="li lj iq ml b gy mp mq l mr ms">const <strong class="ml ir"><em class="mt">target </em></strong>= {<br/>    propA: 'foo',<br/>    propB: 'bar'<br/>}<br/><br/>const <strong class="ml ir"><em class="mt">highlightValues </em></strong>= mapValues((string) =&gt;string.toUpperCase());<br/><br/>const <strong class="ml ir"><em class="mt">newObj </em></strong>= <strong class="ml ir"><em class="mt">highlightValues</em></strong>(<strong class="ml ir"><em class="mt">target</em></strong>);<br/><br/><strong class="ml ir"><em class="mt">console</em></strong>.log(<strong class="ml ir"><em class="mt">newObj</em></strong>);</span><span id="a847" class="li lj iq ml b gy nm mq l mr ms">// &gt; { propA: 'FOO', propB: 'BAR' }</span></pre><p id="8652" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">还有一个:</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="d72b" class="li lj iq ml b gy mp mq l mr ms">const memoize = (fn) =&gt; {<br/>    let result;<br/>    return () =&gt; result !== undefined ? result : (result = fn());<br/>};</span></pre><p id="f5af" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它在第一次调用函数时对其求值，并在下一次调用时返回缓存的结果，因此避免了不必要的计算。</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="25cc" class="li lj iq ml b gy mp mq l mr ms">const <strong class="ml ir"><em class="mt">exec </em></strong>= memoize(() =&gt; {<br/>    <strong class="ml ir"><em class="mt">console</em></strong>.log('I can be long to terminate');<br/>    return 42;<br/>});<br/><br/><strong class="ml ir"><em class="mt">console</em></strong>.log(<strong class="ml ir"><em class="mt">exec</em></strong>());<br/><strong class="ml ir"><em class="mt">console</em></strong>.log(<strong class="ml ir"><em class="mt">exec</em></strong>());<br/><strong class="ml ir"><em class="mt">console</em></strong>.log(<strong class="ml ir"><em class="mt">exec</em></strong>());<br/><strong class="ml ir"><em class="mt">console</em></strong>.log(<strong class="ml ir"><em class="mt">exec</em></strong>());</span><span id="b102" class="li lj iq ml b gy nm mq l mr ms">/*<br/>&gt; I can be long to terminate<br/>&gt; 42<br/>&gt; 42<br/>&gt; 42<br/>&gt; 42<br/>*/</span></pre><p id="bc0b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">传递的函数实际上只被调用一次。</p><p id="1d7d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们现在可以基于文档规则对象定义属性描述符，就像我们之前看到的那样:</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="4965" class="li lj iq ml b gy mp mq l mr ms">const createInjector = (deps, rules) =&gt; {<br/>    const createPropertyDescriptors = mapValues((rule) =&gt; ({<br/>            enumerable: true, // make sure prop is "serializable"<br/>            get: memoize(() =&gt; rule(deps))<br/>        }<br/>    ));<br/>    return (target = {}) =&gt; <strong class="ml ir"><em class="mt">Object</em></strong>.defineProperties(target, createPropertyDescriptors(rules));<br/>};</span></pre><p id="b365" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个函数有两个参数:一个收集依赖项并注入每个规则函数的对象和规则本身。</p><p id="c7fa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它返回一个函数，将映射为属性描述符的规则集分配给给定的目标。它们是注入依赖关系的基本getters(忘记enumerable:它只是确保属性被正确序列化)。由于getter无法传递参数(否则您将无法使用简单的点语法来访问对象属性:<em class="mt"> obj.prop </em>)，我们自动包装规则函数，注入依赖项。</p><p id="6d48" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">快到了！最后一个技巧是将对目标文档对象的引用作为对自身的依赖来传递，以便规则可以引用同一文档的其他规则:</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="6aa2" class="li lj iq ml b gy mp mq l mr ms">import {test} from 'zora';<br/><br/>test('should resolve all values', ({equal}) =&gt; {<br/>    <br/>    const document = {}; // empty at first<br/>    const bookkeeping = {<br/>        amount1: 100,<br/>        amount2: 200<br/>    };<br/>    <br/>    const rules = {<br/>        cell1({bookkeeping: {amount1}}) {<br/>            return amount1 * 2;<br/>        },<br/>        cell2({bookkeeping: {amount2}, document: {cell1}}) {<br/>            return amount2 + cell1;<br/>        },<br/>        cell3({document: {cell2}}) {<br/>            return cell2 + 42;<br/>        }<br/>    };<br/>    <br/>    const resolve = createInjector({document, bookkeeping}, rules);<br/>    equal(resolve(document), {cell1: 200, cell2: 400, cell3: 442});<br/>});</span></pre><p id="11c3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意:我们将文档传递给了依赖项和目标！</p><p id="8e54" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们检查对象的相等性时，每个属性getter都被调用级联调用堆栈并同时解析图，而无需我们使用任何特定的算法来遍历图。</p><h2 id="1330" class="li lj iq bd lk ll lm dn ln lo lp dp lq ko lr ls lt ks lu lv lw kw lx ly lz ma bi translated">结论</h2><p id="3ed1" class="pw-post-body-paragraph kd ke iq kf b kg mb ki kj kk mc km kn ko md kq kr ks me ku kv kw mf ky kz la ij bi translated">属性描述符有时看起来有点不可思议，但是如果小心使用，它们仍然是以简单优雅的方式解决许多问题的强大工具。</p></div></div>    
</body>
</html>