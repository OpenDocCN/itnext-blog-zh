<html>
<head>
<title>Easy Peasy the React Redux wrapper</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">简单的反应Redux包装</h1>
<blockquote>原文：<a href="https://itnext.io/easy-peasy-the-react-redux-wrapper-b31a5911c5e3?source=collection_archive---------4-----------------------#2020-06-01">https://itnext.io/easy-peasy-the-react-redux-wrapper-b31a5911c5e3?source=collection_archive---------4-----------------------#2020-06-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/9ca7736032e324daf5db74e9db2f0c1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QgGGzwcXpPsixPJamBrWgg.jpeg"/></div></div></figure><div class=""/><div class=""><h2 id="a496" class="pw-subtitle-paragraph jy ja jb bd b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp dk translated">如何使用简单的全局状态和反应</h2></div></div><div class="ab cl kq kr hu ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="ij ik il im in"><blockquote class="kx ky kz"><p id="e9f6" class="la lb lc ld b le lf kc lg lh li kf lj lk ll lm ln lo lp lq lr ls lt lu lv lw ij bi translated">这篇文章假设读者对新的React Hooks特性有一些基本的了解。</p></blockquote><p id="b610" class="pw-post-body-paragraph la lb jb ld b le lf kc lg lh li kf lj lx ll lm ln ly lp lq lr lz lt lu lv lw ij bi translated">最近发布的<a class="ae ma" href="https://reactjs.org/docs/hooks-intro.html" rel="noopener ugc nofollow" target="_blank">钩子</a>吹走了复杂性，完全重新激发了我对React的热爱。有了这些新工具，我决定重新评估我所接触的库和模式，看看是否可以用本机实现来代替它们。</p><p id="0538" class="pw-post-body-paragraph la lb jb ld b le lf kc lg lh li kf lj lx ll lm ln ly lp lq lr lz lt lu lv lw ij bi translated">一个直接的考虑是全球国家。一些内置的React挂钩包括<code class="fe mb mc md me b"><a class="ae ma" href="https://reactjs.org/docs/hooks-reference.html#usereducer" rel="noopener ugc nofollow" target="_blank">useReducer</a></code>和<code class="fe mb mc md me b"><a class="ae ma" href="https://reactjs.org/docs/hooks-reference.html#usecontext" rel="noopener ugc nofollow" target="_blank">useContext</a></code>。这些都是强大的原语，如果有人说服自己不再需要第三方州立图书馆，那也情有可原。</p><p id="c935" class="pw-post-body-paragraph la lb jb ld b le lf kc lg lh li kf lj lx ll lm ln ly lp lq lr lz lt lu lv lw ij bi translated">钩子很棒，这是必须要说的。随着时间的推移，更复杂的状态管理组件(例如异步流和派生状态)开始出现。这些问题需要自制的解决方案或第三方库——冲淡了我的体验。</p><p id="fa81" class="pw-post-body-paragraph la lb jb ld b le lf kc lg lh li kf lj lx ll lm ln ly lp lq lr lz lt lu lv lw ij bi translated">我试图继续进行迁移，但是我的全局状态的复杂性继续增长，最终我达到了一个临界点，在这个临界点上，我非常渴望一个更健壮、更包容的状态解决方案。bug在蔓延，我发现识别和解决它们非常困难——我的调试工具已经从令人难以置信的<a class="ae ma" href="https://github.com/zalmoxisus/redux-devtools-extension" rel="noopener ugc nofollow" target="_blank"> Redux Dev Tools扩展</a>减少到明显更简单的<code class="fe mb mc md me b">console.log</code>。</p><p id="15db" class="pw-post-body-paragraph la lb jb ld b le lf kc lg lh li kf lj lx ll lm ln ly lp lq lr lz lt lu lv lw ij bi translated">我练习的结果是一个结论，钩子很棒，但是它们只能带你到这里。仍然存在复杂的应用程序状态结构，Redux等将是更好的选择。</p><p id="28e0" class="pw-post-body-paragraph la lb jb ld b le lf kc lg lh li kf lj lx ll lm ln ly lp lq lr lz lt lu lv lw ij bi translated">另一个结果是，我无意中重新点燃了对Redux及其成熟生态系统的欣赏。鉴于最近社区(包括我自己)对它的抵制，这是一个有趣的地方。</p><p id="e0c7" class="pw-post-body-paragraph la lb jb ld b le lf kc lg lh li kf lj lx ll lm ln ly lp lq lr lz lt lu lv lw ij bi translated">过去有一种教条式的信念，认为Redux是任何“值得尊敬的”应用程序的一个要求。令人鼓舞的是，社区正在摆脱这种思维，但是，我们应该注意不要把钟摆摆向另一端。宣称没有Redux的位置也同样是不负责任的。我们更应该选择一个实用的中间地带，一个我们花时间考虑添加Redux到项目中是否会带来价值的地方。</p><p id="c190" class="pw-post-body-paragraph la lb jb ld b le lf kc lg lh li kf lj lx ll lm ln ly lp lq lr lz lt lu lv lw ij bi translated">就我而言，我觉得我的项目肯定需要一个更强大的国家系统。我下定决心，我将允许第三方库再次管理我的状态。</p><p id="5ef5" class="pw-post-body-paragraph la lb jb ld b le lf kc lg lh li kf lj lx ll lm ln ly lp lq lr lz lt lu lv lw ij bi translated">Redux在叫我。</p><p id="3aeb" class="pw-post-body-paragraph la lb jb ld b le lf kc lg lh li kf lj lx ll lm ln ly lp lq lr lz lt lu lv lw ij bi translated">所有这些样板文件虽然…</p><h1 id="110f" class="mf mg jb bd mh mi mj mk ml mm mn mo mp kh mq ki mr kk ms kl mt kn mu ko mv mw bi translated">容易的事</h1><p id="a7b8" class="pw-post-body-paragraph la lb jb ld b le mx kc lg lh my kf lj lx mz lm ln ly na lq lr lz nb lu lv lw ij bi translated">这是围绕redux的第三方包装。这是一个一体化，零配置，全局状态库！最重要的是，它使用钩子作为与组件集成的机制。</p><p id="18c4" class="pw-post-body-paragraph la lb jb ld b le lf kc lg lh li kf lj lx ll lm ln ly lp lq lr lz lt lu lv lw ij bi translated">我已经积极地使用它一个多星期了，解决了最初的错误和性能问题。我的观点肯定有很大的偏见，但我必须说，我觉得这是一股新鲜空气。我的速度和快乐水平正在飙升，因为我正在开发<a class="ae ma" href="https://comickult.com/" rel="noopener ugc nofollow" target="_blank"> ComicKult </a>。</p><p id="35a3" class="pw-post-body-paragraph la lb jb ld b le lf kc lg lh li kf lj lx ll lm ln ly lp lq lr lz lt lu lv lw ij bi translated">你需要做的就是安装一个软件包。您需要的一切都包括在内，不需要额外的配置。</p><p id="7f63" class="pw-post-body-paragraph la lb jb ld b le lf kc lg lh li kf lj lx ll lm ln ly lp lq lr lz lt lu lv lw ij bi translated"><code class="fe mb mc md me b">npm install easy-peasy</code></p></div><div class="ab cl kq kr hu ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="ij ik il im in"><blockquote class="kx ky kz"><p id="d249" class="la lb lc ld b le lf kc lg lh li kf lj lk ll lm ln lo lp lq lr ls lt lu lv lw ij bi translated"><em class="jb">记住，这个包依赖于React Hooks特性，它只在React/React-DOM-v 16 . 7 . 0-alpha . 0的alpha版本中可用。我当然不建议你在生产中使用它，但是如果你必须足够负责任地只在你的个人项目中使用它。</em></p></blockquote><p id="f783" class="pw-post-body-paragraph la lb jb ld b le lf kc lg lh li kf lj lx ll lm ln ly lp lq lr lz lt lu lv lw ij bi translated">主要的API可以很容易地通过下面简洁的代码片段来说明。</p><pre class="nc nd ne nf gt ng me nh ni aw nj bi"><span id="a0d6" class="nk mg jb me b gy nl nm l nn no">import { StoreProvider, createStore, useStore, useAction } from 'easy-peasy';</span><span id="b293" class="nk mg jb me b gy np nm l nn no">// 👇 firstly, create your store by providing your model<br/>const store = createStore({<br/>  todos: {<br/>    items: ['Install easy-peasy', 'Build app', 'Profit'],<br/>    // 👇 define actions<br/>    add: (state, payload) =&gt; {<br/>      state.items.push(payload) // 👈 you mutate state to update (we convert<br/>                                //    to immutable updates)<br/>    }<br/>  }<br/>});</span><span id="b7a7" class="nk mg jb me b gy np nm l nn no">function App() {<br/>  return (<br/>    // 👇 secondly, surround your app with the provider to expose the store to your app<br/>    &lt;StoreProvider store={store}&gt;<br/>      &lt;TodoList /&gt;<br/>    &lt;/StoreProvider&gt;<br/>  );<br/>}</span><span id="8100" class="nk mg jb me b gy np nm l nn no">function TodoList() {<br/>  // 👇 finally, use hooks to get state or actions. your component will receive<br/>  //    updated state automatically<br/>  const todos = useStore(state =&gt; state.todos.items)<br/>  const add = useAction(dispatch =&gt; dispatch.todos.add)<br/>  return (<br/>    &lt;div&gt;<br/>      {todos.map((todo, idx) =&gt; &lt;div key={idx}&gt;{todo.text}&lt;/div&gt;)}<br/>      &lt;AddTodo onAdd={add} /&gt;<br/>    &lt;/div&gt;<br/>  )<br/>}</span></pre><p id="ad0d" class="pw-post-body-paragraph la lb jb ld b le lf kc lg lh li kf lj lx ll lm ln ly lp lq lr lz lt lu lv lw ij bi translated">你可以简单地定义一个模型来描述你的状态，而不是绘制出无尽的减少器、动作等等。这个模型只是一个很好的旧JavaScript对象，可以简单也可以复杂。它用来描述您的状态结构及其默认值。在引擎盖下，我们将做所有的艰苦工作，将你的模型转换成Redux期望的惯用结构(Redux，actions等)。</p><p id="6676" class="pw-post-body-paragraph la lb jb ld b le lf kc lg lh li kf lj lx ll lm ln ly lp lq lr lz lt lu lv lw ij bi translated">让我们把API分成更小的部分。首先，定义您的模型…</p><pre class="nc nd ne nf gt ng me nh ni aw nj bi"><span id="8873" class="nk mg jb me b gy nl nm l nn no">const model = {<br/>  todos: {<br/>    items: [],<br/>  },<br/>  session: {<br/>    user: null <br/>  }<br/>};</span></pre><p id="b594" class="pw-post-body-paragraph la lb jb ld b le lf kc lg lh li kf lj lx ll lm ln ly lp lq lr lz lt lu lv lw ij bi translated">要定义用于更新状态的动作，只需在状态的适当部分添加一个函数。</p><pre class="nc nd ne nf gt ng me nh ni aw nj bi"><span id="ffe4" class="nk mg jb me b gy nl nm l nn no">const model = {<br/>  todos: {<br/>    items: [],<br/>    // 👇 an action<br/>    add: (state, payload) =&gt; {<br/>      state.items.push(payload);  <br/>    }<br/>  },<br/>  session: {<br/>    user: null <br/>  }<br/>};</span></pre><p id="0886" class="pw-post-body-paragraph la lb jb ld b le lf kc lg lh li kf lj lx ll lm ln ly lp lq lr lz lt lu lv lw ij bi translated">注意动作是如何接收状态片作为它的第一个参数的，第二个参数包含可能已经提供给动作的任何有效负载。您还会注意到，您直接改变了状态。我们在这里使用<code class="fe mb mc md me b"><a class="ae ma" href="https://github.com/mweststrate/immer" rel="noopener ugc nofollow" target="_blank">immer</a></code>是为了让我们熟悉和容易使用基于突变的API。在引擎盖下，它为我们做了所有的艰苦工作，将对<code class="fe mb mc md me b">state</code>的任何修改转换成一个单一的不可变更新。</p><p id="d795" class="pw-post-body-paragraph la lb jb ld b le lf kc lg lh li kf lj lx ll lm ln ly lp lq lr lz lt lu lv lw ij bi translated">然后，您将您的模型提供给<code class="fe mb mc md me b">createStore</code>，它将输出一个Redux store，它与标准Redux store的唯一区别是，动作已经方便地绑定到了<code class="fe mb mc md me b">dispatch</code>属性。</p><pre class="nc nd ne nf gt ng me nh ni aw nj bi"><span id="1662" class="nk mg jb me b gy nl nm l nn no">import { createStore } from 'easy-peasy';</span><span id="4e73" class="nk mg jb me b gy np nm l nn no">// Pass in your model and you get back a Redux store<br/>const store = createStore(model);</span><span id="e895" class="nk mg jb me b gy np nm l nn no">// you can query state as normal<br/>store.getState().todos.items;<br/>// ['Install easy-peasy']</span><span id="24f2" class="nk mg jb me b gy np nm l nn no">// and dispatch actions<br/>store.dispatch.todos.add('Build an app')<br/>//            |---------|<br/>//                 |- Actions are bound to a path matching model<br/>  <br/>// and access the other standard APIs of a Redux store<br/>store.listen(() =&gt; console.log('An update occurred'))</span></pre><p id="4397" class="pw-post-body-paragraph la lb jb ld b le lf kc lg lh li kf lj lx ll lm ln ly lp lq lr lz lt lu lv lw ij bi translated">为了向您的应用程序公开您的商店，您将它提供给<code class="fe mb mc md me b">StoreProvider</code>。</p><pre class="nc nd ne nf gt ng me nh ni aw nj bi"><span id="3f69" class="nk mg jb me b gy nl nm l nn no">import { StoreProvider } from 'easy-peasy';</span><span id="e44f" class="nk mg jb me b gy np nm l nn no">function App() {<br/>  return (<br/>    // 👇 secondly, surround your app with the provider to expose the store to your app<br/>    &lt;StoreProvider store={store}&gt;<br/>      &lt;TodoList /&gt;<br/>    &lt;/StoreProvider&gt;<br/>  );<br/>}</span></pre><p id="3358" class="pw-post-body-paragraph la lb jb ld b le lf kc lg lh li kf lj lx ll lm ln ly lp lq lr lz lt lu lv lw ij bi translated">最后，您可以使用提供的挂钩与您的商店进行交互。</p><pre class="nc nd ne nf gt ng me nh ni aw nj bi"><span id="319e" class="nk mg jb me b gy nl nm l nn no">import { useStore, useAction } from 'easy-peasy';</span><span id="3f8c" class="nk mg jb me b gy np nm l nn no">function TodoList() {<br/>  // 👇 Access state<br/>  const todos = useStore(state =&gt; state.todos.items)<br/>  // 👇 Access actions<br/>  const add = useAction(dispatch =&gt; dispatch.todos.add)<br/>  return (<br/>    &lt;div&gt;<br/>      {todos.map((todo, idx) =&gt; &lt;div key={idx}&gt;{todo.text}&lt;/div&gt;)}<br/>      &lt;AddTodo onAdd={add} /&gt;<br/>    &lt;/div&gt;<br/>  )<br/>}</span></pre><p id="37d6" class="pw-post-body-paragraph la lb jb ld b le lf kc lg lh li kf lj lx ll lm ln ly lp lq lr lz lt lu lv lw ij bi translated">只有当组件跟踪的相应状态被更新时，组件才会收到新的状态。</p><p id="5ade" class="pw-post-body-paragraph la lb jb ld b le lf kc lg lh li kf lj lx ll lm ln ly lp lq lr lz lt lu lv lw ij bi translated">需要执行数据提取/持久化等效果？然后使用<code class="fe mb mc md me b">effect</code>助手。</p><pre class="nc nd ne nf gt ng me nh ni aw nj bi"><span id="4423" class="nk mg jb me b gy nl nm l nn no">import { createStore, effect } from 'easy-peasy'; // 👈 import the helper</span><span id="e826" class="nk mg jb me b gy np nm l nn no">const store = createStore({<br/>  session: {<br/>    user: undefined,<br/>    // 👇 define your effectful action<br/>    login: effect(async (dispatch, payload, getState) =&gt; {<br/>      const user = await loginService(payload)<br/>      dispatch.session.loginSucceeded(user)<br/>    }),<br/>    loginSucceeded: (state, payload) =&gt; {<br/>      state.user = payload<br/>    }<br/>  }<br/>});</span></pre><p id="65c5" class="pw-post-body-paragraph la lb jb ld b le lf kc lg lh li kf lj lx ll lm ln ly lp lq lr lz lt lu lv lw ij bi translated">注意你如何使用async/await，或者Promises，或者任何你喜欢的异步编程风格。提供的<code class="fe mb mc md me b">dispatch</code>允许您用任何结果更新您的状态。</p><p id="3054" class="pw-post-body-paragraph la lb jb ld b le lf kc lg lh li kf lj lx ll lm ln ly lp lq lr lz lt lu lv lw ij bi translated">派生状态呢？<code class="fe mb mc md me b">select</code>帮手为你撑腰。</p><pre class="nc nd ne nf gt ng me nh ni aw nj bi"><span id="26b8" class="nk mg jb me b gy nl nm l nn no">import { select } from 'easy-peasy'; // 👈 import the helper</span><span id="3f47" class="nk mg jb me b gy np nm l nn no">const store = createStore({<br/>  shoppingBasket: {<br/>    products: [{ name: 'Shoes', price: 123 }, { name: 'Hat', price: 75 }],<br/>    // 👇 define your derived state<br/>    totalPrice: select(state =&gt;<br/>      state.products.reduce((acc, cur) =&gt; acc + cur.price, 0)<br/>    )<br/>  }<br/>});</span></pre><p id="65fc" class="pw-post-body-paragraph la lb jb ld b le lf kc lg lh li kf lj lx ll lm ln ly lp lq lr lz lt lu lv lw ij bi translated">只有当它所关心的状态发生变化时，才会重新计算派生状态。它是开箱记忆的。</p></div></div>    
</body>
</html>