<html>
<head>
<title>Handling OOMKilled issue of Java applications running inside Docker</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">处理Docker中运行的Java应用程序的死机问题</h1>
<blockquote>原文：<a href="https://itnext.io/docker-and-java-handling-oomkilled-7dba9759df72?source=collection_archive---------0-----------------------#2020-02-26">https://itnext.io/docker-and-java-handling-oomkilled-7dba9759df72?source=collection_archive---------0-----------------------#2020-02-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="4ea8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在Docker容器中运行Java应用程序时，经常会遇到致命错误。这个错误的主要原因是JVM错误地检测了docker容器中的内存。我们可以通过为Java应用程序设置正确的堆大小来解决这个问题。</p><p id="f1c8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，我们来看看为什么JVM会为我们的Docker容器检测到不准确的内存？</p><p id="4cea" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">当我们让JVM为它在容器中的堆大小设置默认值时，JVM将分配运行容器的机器的物理内存的1/4。</strong></p><p id="6a9d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这背后的公式是，</p><p id="b5c5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe ko kp kq kr b">MaxHeap = MaxRAM * 1 / MaxRAMFraction</code></p><p id="4427" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">其中MaxRAMFraction默认为4。因此，JVM分配物理机RAM大小的1/4作为JVM进程的最大堆大小。因为JVM不知道Linux容器。它认为自己正在主机上运行，并且可以访问机器的最大RAM大小。</p><p id="3a1d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">假设我们在一台拥有4000MB内存的机器上运行一个docker容器。然后我们给docker容器分配250MB内存。默认情况下，JVM分配机器1/4的内存(在本例中是1000MB)作为最大堆。当JVM试图使用docker容器内存之外的更多内存时，对容器中可用内存的无效检测会导致容器被杀死。所以JVM试图超越200MB的那一刻，就会被docker杀死。</p><p id="d47d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通过为JVM进程设置最大堆大小，而不是让JVM选择默认值，我们可以很容易地解决这个问题。因此，我们可以相应地为我们的Java进程定义准确的<strong class="js iu"> -Xms </strong>和<strong class="js iu"> -Xmx </strong>值。例如，如果我们分配250MB给docker容器，我们可以在docker文件中设置如下JAVA_OPTS，</p><pre class="ks kt ku kv gt kw kr kx ky aw kz bi"><span id="7a40" class="la lb it kr b gy lc ld l le lf">JAVA_OPTS='<!-- -->-Xms128m -Xmx128m'</span></pre><p id="25a6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这将有助于JVM不超过docker容器内存，因为最大堆大小(128MB)小于容器内存(250MB)。在这种情况下，我们应该将MaxHeap值设置为一个仔细猜测的值。否则，JVM进程将无法运行。</p><p id="5389" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为docker容器中运行的JVM设置Xms和Xmx值是解决OOMKilled问题的最佳解决方案吗？绝对没有。</p><p id="6cfe" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">什么？没有吗？那么这里的问题是什么呢？</p><p id="07ee" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这意味着您需要控制内存两次，一次在JVM中，一次在Docker中。这不是一个理想的解决方案。应该有更好的方法来做这件事。否则，每次你需要改变的时候，你都要做两次。</p><p id="c69a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Java 10+引入了它最伟大的特性之一<strong class="js iu">选择容器可用RAM大小的堆大小百分比。</strong></p><p id="b0a4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对JAVA_OPTS使用以下标志将根据容器内存调整JVM堆大小:</p><pre class="ks kt ku kv gt kw kr kx ky aw kz bi"><span id="595d" class="la lb it kr b gy lc ld l le lf"><strong class="kr iu">To JVM to aware to read the size of the container memory instead of reading the RAM size of the host machine. <br/></strong>-XX:-UseContainerSupport</span><span id="0e95" class="la lb it kr b gy lg ld l le lf"><strong class="kr iu">To set the </strong><strong class="kr iu">percentage of real memory used for initial heap size</strong><br/>-XX:InitialRAMPercentage=40  </span><span id="873b" class="la lb it kr b gy lg ld l le lf"><strong class="kr iu">To set the </strong><strong class="kr iu">Maximum percentage of real memory used for maximum heap size</strong><br/>-XX:MaxRAMPercentage=60<br/></span></pre><p id="8d1c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">假设上述场景的docker内存限制是1GB，那么JVM根据上述标志将初始堆大小设置为400MB，将最大堆大小设置为600MB。</p><p id="2cba" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你使用的是java 8或9，你就没有机会使用上面的标志了。但是不用担心。有一个解决方法。对于Java 8u131和Java 9，您有以下选择:</p><pre class="ks kt ku kv gt kw kr kx ky aw kz bi"><span id="6b03" class="la lb it kr b gy lc ld l le lf"><strong class="kr iu">To JVM to aware to read the size of the container memory instead of reading the RAM size of the host machine.<br/></strong>-XX:+UnlockExperimentalVMOptions <br/>-XX:+UseCGroupMemoryLimitForHeap </span><span id="8903" class="la lb it kr b gy lg ld l le lf"><strong class="kr iu">To set the </strong><strong class="kr iu">percentage of real memory used for initial heap size</strong><br/>-XX:InitialRAMFraction=4</span><span id="5b0e" class="la lb it kr b gy lg ld l le lf"><strong class="kr iu">To set the </strong><strong class="kr iu">Maximum percentage of real memory used for maximum heap size</strong><br/>-XX:MaxRAMFraction=2</span></pre><p id="ac50" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这种情况下，如果docker内存限制是1GB，那么JVM将初始堆大小设置为250 MB(1GB的1/4 ),将最大堆大小设置为500 MB(1GB的1/2)。java 10+的唯一缺点是我们不能使用一定百分比的内存，相反，我们必须使用一部分内存，而且这个部分必须是整数。</p><p id="0dab" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我建议将初始堆大小和最大堆大小设置为相同的值，因为这样可以防止堆扩展导致的暂停。这会导致在等待JAVA处理内存分配更改时防止性能问题。</p><p id="7a7e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当使用上述标志时，您不需要为JVM和Docker调整两次内存。这些标志将根据docker容器内存限制调整JVM的堆。干杯！！</p></div></div>    
</body>
</html>