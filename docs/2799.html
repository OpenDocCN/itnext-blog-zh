<html>
<head>
<title>A comparison of GraphQL and REST</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">GraphQL和REST的比较</h1>
<blockquote>原文：<a href="https://itnext.io/a-comparison-of-graphql-and-rest-e125d77fb329?source=collection_archive---------4-----------------------#2019-08-05">https://itnext.io/a-comparison-of-graphql-and-rest-e125d77fb329?source=collection_archive---------4-----------------------#2019-08-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="0535" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于我们大多数人来说，在设计API和web应用程序时，REST架构已经深入我们的脑海。仅仅想到范式转换到其他东西上，就可以被看作是一种无意义的头痛诱导练习，不会带来任何净收益，而且会带来大量工作。</p><p id="4db8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通过亲自调查这一转变，我想我会分享一些我在这一过程中学到的东西。我将尝试解释如何使用GraphQL，并强调这两种方法之间的区别。</p><blockquote class="ko"><p id="9146" class="kp kq it bd kr ks kt ku kv kw kx kn dk translated">GraphQL是什么？</p></blockquote><p id="b180" class="pw-post-body-paragraph jq jr it js b jt ky jv jw jx kz jz ka kb la kd ke kf lb kh ki kj lc kl km kn im bi translated">GraphQL在很多方面被描述为，“<em class="ld">访问数据的统一接口。”，“一种在单个端点上公开数据模式的查询语言。</em>、<em class="ld">服务器端运行时，使用数据定义的类型系统执行查询。</em>”。</p><p id="80d8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">老实说，所有这些不同的描述可能会增加最初对使用它的内容、位置和原因的困惑。从表面上看，所有这些描述都指向同一件事，而不是给你另一个关于GraphQL基本存在的乏味描述。我觉得用图片的形式更容易理解。</p><p id="4c00" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面是一个GraphQL查询的例子。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi le"><img src="../Images/931bcb4f43488e2bd5016982cfc065a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hbheCx0tCzyFv9wGDGTVjA.png"/></div></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk translated">来源于<a class="ae lu" href="https://www.howtographql.com/basics/1-graphql-is-the-better-rest/" rel="noopener ugc nofollow" target="_blank">https://www . howtographql . com/basics/1-graph QL-is-the-better-rest/</a></figcaption></figure><p id="8540" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里我们用用户的“id”查询用户数据。关于查询和响应要注意的第一件事是它们是相同的，这是因为GraphQL是类型化的，这意味着您要求的就是您得到的。我们只是说“给我这个id的用户，并返回给我他们的名字，帖子和追随者”。</p><p id="0e35" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，为了帮助您理解GraphQL查询，让我们将它与使用下面的REST端点得到的相同结果进行比较。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi lv"><img src="../Images/33495f301d1fccc58d1b38caf43c1d23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8C-_H9rXNsXqXNUiW6wZfg.png"/></div></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk translated">来源于<a class="ae lu" href="https://www.howtographql.com/basics/1-graphql-is-the-better-rest/" rel="noopener ugc nofollow" target="_blank">https://www . howtographql . com/basics/1-graph QL-is-the-better-rest/</a></figcaption></figure><p id="f9e1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里，我们必须定义3个独立的端点，以便能够访问相同的数据。现在，你们中的一些人会说，通过在第一个请求中返回整个用户对象，可以将此减少到一个端点，这将被视为过度获取数据。如果我们设想我们有一个只需要显示用户名列表的UI，使用这个单一的REST请求来获取所有用户将意味着我们必须对响应数据执行一些客户端处理，以便获取我们最初想要的内容。</p><p id="d6dc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里要注意的一个主要区别是，使用GraphQL，您知道每个查询可以使用哪些对象和数据，因此您可以指定希望从服务器返回的数据的形式。使用REST，您无法真正定义返回给您的内容，因为这是服务器决定的。</p><p id="7aad" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，我们可以将GraphQL视为一个端点，在这个端点上，我们有一组可执行的查询，这些查询映射到我们希望服务器公开的数据模式。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><p id="9ef6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">好了，对GraphQL描述的拙劣尝试可能仍然没有任何意义，所以让我们运行一些代码示例，并构建我们自己的小API来比较这两者。我已经创建了一个小节点应用程序，你可以从GitHub派生。在这个应用程序中，我们将重现上图所示的例子。这一切都紧扣<a class="ae lu" href="https://www.howtographql.com" rel="noopener ugc nofollow" target="_blank"><strong class="js iu"/></a>团队精彩的介绍指导。</p><div class="md me gp gr mf mg"><a href="https://github.com/CameronNewby/graphqlvsrest" rel="noopener  ugc nofollow" target="_blank"><div class="mh ab fo"><div class="mi ab mj cl cj mk"><h2 class="bd iu gy z fp ml fr fs mm fu fw is bi translated">Cameron newby/graphqlvrest</h2><div class="mn l"><h3 class="bd b gy z fp ml fr fs mm fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="mo l"><p class="bd b dl z fp ml fr fs mm fu fw dk translated">github.com</p></div></div></div></a></div><p id="911e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们要做的第一件事是创建并启动一个本地mongoDB服务器。之后，使用mongoose为我们的用户数据定义一个模型。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="4c06" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我还创建了一个简单的数据库管理器类，它可以启动和停止本地MongoDB服务器，并插入一些虚拟数据供我们运行查询。</p><p id="c79a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我们将使用express创建一个非常简单的REST API，它将具有与上图所示大致相同的端点。每个人都会调用数据库来获得一堆模拟数据。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="7357" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，让我们创建我们的GraphQL端点和模式。为此，我们将使用<em class="ld"/><strong class="js iu"><em class="ld">express-graph QL</em></strong>来完成，它将通过HTTP提供我们的GraphQL API，并使用<strong class="js iu"> <em class="ld"> graphql工具来构建和定义我们的模式。</em> </strong>有许多其他的方法来表示你的GraphQL模式，但是对于这个例子，我想尽可能地接近GraphQL SDL模型。我打算将类型定义从解析器函数中分离出来，希望这样更容易理解。其他方式请看<a class="ae lu" href="https://blog.apollographql.com/three-ways-to-represent-your-graphql-schema-a41f4175100d" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu">这里</strong> </a>。</p><p id="e9e7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，我们创建我们的类型定义，它布局了我们的数据结构。我们将把它映射到我们之前定义的mongoose模型。这里的前两个类型定义是特价类型。每个GraphQL服务都必须有一个查询类型(默认情况下不需要突变)。这些类型与常规对象类型相同，但它们是唯一的，因为它们定义了每个GraphQL查询的入口点。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="a9e2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，对于“查询”类型，我们将定义一个用户函数，它将接受一个字符串并返回一个用户对象“！”表示我们返回的不能是空对象，它必须是我们稍后定义的“用户”类型的对象。</p><pre class="lf lg lh li gt mr ms mt mu aw mv bi"><span id="95ac" class="mw mx it ms b gy my mz l na nb">user(name: String!): User!</span></pre><p id="57a9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">其他类型是普通对象类型(它们不是GraphQL特有的)，其中使用一系列受支持的标量类型，这些类型表示数据的实际类型(String、Int、Date)。因此，这里我们希望创建基于存储在mongo中的数据结构的类型，并将返回给客户端。“User”、“Post”和“Comments”类型定义将类似于我们的mongoose模式定义。</p><pre class="lf lg lh li gt mr ms mt mu aw mv bi"><span id="0e65" class="mw mx it ms b gy my mz l na nb">type User: {<br/>  name: String!<br/>  age: Int!<br/>  posts: [Post!]!<br/>  followers: [User!]<br/>}</span></pre><p id="2a84" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">看看我们是如何为“User”对象创建上面的GraphQL类型定义，使其类似于下面的“User”mongose模式的。</p><pre class="lf lg lh li gt mr ms mt mu aw mv bi"><span id="b2ba" class="mw mx it ms b gy my mz l na nb">let userSchema = new mongoose.Schema({<br/>  name: { type: String },        <br/>  age: { type: Number },        <br/>  posts: [postSchema],        <br/>  followers: [{type: mongoose.Schema.Types.ObjectId, ref: 'User'}]    });</span></pre><p id="adca" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">GraphQL有以下类型:</p><ul class=""><li id="501d" class="nc nd it js b jt ju jx jy kb ne kf nf kj ng kn nh ni nj nk bi translated"><code class="fe nl nm nn ms b">Int</code>:一个带符号的32位整数。</li><li id="03a7" class="nc nd it js b jt no jx np kb nq kf nr kj ns kn nh ni nj nk bi translated"><code class="fe nl nm nn ms b">Float</code>:有符号双精度浮点值。</li><li id="1324" class="nc nd it js b jt no jx np kb nq kf nr kj ns kn nh ni nj nk bi translated"><code class="fe nl nm nn ms b">String</code>:UTF‐8字符序列。</li><li id="be2a" class="nc nd it js b jt no jx np kb nq kf nr kj ns kn nh ni nj nk bi translated"><code class="fe nl nm nn ms b">Boolean</code> : <code class="fe nl nm nn ms b">true</code>或<code class="fe nl nm nn ms b">false</code>。</li><li id="c9b0" class="nc nd it js b jt no jx np kb nq kf nr kj ns kn nh ni nj nk bi translated"><code class="fe nl nm nn ms b">ID</code>:ID标量类型表示一个惟一的标识符，通常用于重新提取一个对象或作为缓存的键。ID类型以与字符串相同的方式序列化；然而，将它定义为<code class="fe nl nm nn ms b">ID</code>意味着它不适合人类阅读。</li></ul><p id="07a8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">GraphQL还允许您构建和创建自己的标量类型，因此虽然它们只支持开箱即用的基本标量类型，但您可以相当容易地构建自己的类型，有关GraphQL类型的更多信息，请参见<a class="ae lu" href="https://graphql.org/learn/schema/#type-system" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu">此处</strong> </a>。</p><p id="8035" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，在编写了查询和变异方法的正式类型定义之后，下一步是使用这些定义来构建相应的函数/解析器，调用这些函数/解析器来获取或更新数据。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="9328" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">每个解析器可以接受四个参数:</p><ul class=""><li id="5eb0" class="nc nd it js b jt ju jx jy kb ne kf nf kj ng kn nh ni nj nk bi translated"><code class="fe nl nm nn ms b">parent</code> : <strong class="js iu"> </strong>前一个对象，这对于根查询类型上的一个字段是经常不使用的。</li><li id="0071" class="nc nd it js b jt no jx np kb nq kf nr kj ns kn nh ni nj nk bi translated"><code class="fe nl nm nn ms b">args</code> : <strong class="js iu"> </strong>是您在类型定义中注册的输入，以及提供给GraphQL查询中的字段的参数。</li><li id="73d3" class="nc nd it js b jt no jx np kb nq kf nr kj ns kn nh ni nj nk bi translated"><code class="fe nl nm nn ms b">context</code>:提供给每个解析器的值，保存重要的上下文信息，如当前登录的用户或对数据库的访问。</li><li id="5ed9" class="nc nd it js b jt no jx np kb nq kf nr kj ns kn nh ni nj nk bi translated"><code class="fe nl nm nn ms b">info</code> : <strong class="js iu"> </strong>保存与当前查询相关的特定于字段的信息以及模式详细信息的值</li></ul><p id="3941" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这种情况下，我们将在上下文中传递数据库连接。我们解构的参数与我们之前在这些方法的类型定义中定义的参数相同。我们还通过使用'<strong class="js iu">'定义了哪些参数是强制的，哪些是可选的！</strong>符号，带符号的是解析器的强制参数。</p><p id="4de2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，让我们从“查询”类型回到“用户”类型定义。</p><pre class="lf lg lh li gt mr ms mt mu aw mv bi"><span id="b807" class="mw mx it ms b gy my mz l na nb">user(name: String!): User!</span></pre><p id="ed30" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们已经定义了这个“用户”查询接受一个名为<em class="ld"> name </em>的参数，该参数必须是非空字符串。现在我们知道解析器的“args”参数将是以下形状的对象。</p><pre class="lf lg lh li gt mr ms mt mu aw mv bi"><span id="9092" class="mw mx it ms b gy my mz l na nb">args: {<br/>  name: 'John'<br/>}</span></pre><p id="427a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后，我们对每个解析器所做的就是接受给定的参数，并使用它们对我们的mongoose模型执行查询，以获取或更新数据记录。</p><p id="a046" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">就是这样！我想我还没有详细介绍GraphQL模式的所有组件，但这是因为有太多其他很好的描述和教程，我想鼓励人们自己去运行代码，并将其作为学习和改进的基础。这里要注意的一个要点是，不仅为嵌套模式创建类型定义是如此简单，而且创建一个比REST方法更具通用性的查询方法只需要很少的代码。</p><p id="a2d7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有关如何安装和运行该应用程序的详细信息，请参见GitHub项目的自述文件。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><p id="d70b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，让我们回顾一下使用GraphQL优于REST的优点和缺点。</p><h1 id="3afb" class="nt mx it bd nu nv nw nx ny nz oa ob oc od oe of og oh oi oj ok ol om on oo op bi translated">优势</h1><h2 id="99fa" class="mw mx it bd nu oq or dn ny os ot dp oc kb ou ov og kf ow ox ok kj oy oz oo pa bi translated">1.不再有过多和过少的获取</h2><p id="1f06" class="pw-post-body-paragraph jq jr it js b jt pb jv jw jx pc jz ka kb pd kd ke kf pe kh ki kj pf kl km kn im bi translated">REST最常见的一个问题是提取过量和不足。我们这样说的意思是，客户端正在调用返回由服务器定义的数据结构的固定端点，因此客户端可能会接收到它不想要的数据，或者可能必须发出几个请求才能获得它实际需要的所有数据。很难设计一个没有这个固有问题的REST API。</p><p id="7b2f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">另一方面，GraphQL没有这个问题。在GraphQL中，服务器声明哪些资源是可用的，客户机询问它当时需要什么。</p><h2 id="2527" class="mw mx it bd nu oq or dn ny os ot dp oc kb ou ov og kf ow ox ok kj oy oz oo pa bi translated">2.模式定义和文档</h2><p id="ef39" class="pw-post-body-paragraph jq jr it js b jt pb jv jw jx pc jz ka kb pd kd ke kf pe kh ki kj pf kl km kn im bi translated">GraphQL使用强类型系统，该系统概述了服务器可以返回的数据的结构。使用SDL定义模式意味着客户端可以很容易地确定他们可以接收的数据的形状以及他们可以进行什么样的改变或查询，这样做允许客户端开发者独立工作，因为他们可以很容易地看到他们有什么可用的数据。</p><p id="802c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以这种方式定义模式允许您非常容易地编写API文档，而以前您必须在开发REST端点之后编写API文档，现在您的模式充当了文档的一种形式。</p><h2 id="cf33" class="mw mx it bd nu oq or dn ny os ot dp oc kb ou ov og kf ow ox ok kj oy oz oo pa bi translated">3.减少所需的端点数量</h2><p id="96ce" class="pw-post-body-paragraph jq jr it js b jt pb jv jw jx pc jz ka kb pd kd ke kf pe kh ki kj pf kl km kn im bi translated">这可能是我最喜欢的一点。不得不设计和构建多个REST API，所有这些都有大量的端点，对于开发人员来说，减少到一个似乎是一个辉煌的胜利。</p><h2 id="a5c1" class="mw mx it bd nu oq or dn ny os ot dp oc kb ou ov og kf ow ox ok kj oy oz oo pa bi translated">4.捐款</h2><p id="45d5" class="pw-post-body-paragraph jq jr it js b jt pb jv jw jx pc jz ka kb pd kd ke kf pe kh ki kj pf kl km kn im bi translated">GraphQL订阅是一种将数据从服务器推送到客户端的方式，客户端选择收听来自服务器的实时消息。订阅类似于查询，因为它们指定了一组要传递给客户端的字段，但不是立即返回单个答案，而是在服务器上每次发生特定事件时都发送一个结果。</p><p id="fb1e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这允许您通过web套接字通知客户端已经执行或完成的特定事件。</p><h1 id="d21e" class="nt mx it bd nu nv nw nx ny nz oa ob oc od oe of og oh oi oj ok ol om on oo op bi translated">不足之处</h1><h2 id="2685" class="mw mx it bd nu oq or dn ny os ot dp oc kb ou ov og kf ow ox ok kj oy oz oo pa bi translated">1.采用和支持</h2><p id="c062" class="pw-post-body-paragraph jq jr it js b jt pb jv jw jx pc jz ka kb pd kd ke kf pe kh ki kj pf kl km kn im bi translated">GraphQL是新的，正因为如此，它不仅仅具有REST所具有的时间天赋，因此这使得它被如此普遍地采用，以及围绕其框架构建的大量支持和工具。但是GraphQL的变化很快，随着越来越多的公司采用这项技术，我们只会看到支持和工具的增长。</p><h2 id="71a2" class="mw mx it bd nu oq or dn ny os ot dp oc kb ou ov og kf ow ox ok kj oy oz oo pa bi translated">2.你的嵌入程度如何？</h2><p id="cfc2" class="pw-post-body-paragraph jq jr it js b jt pb jv jw jx pc jz ka kb pd kd ke kf pe kh ki kj pf kl km kn im bi translated">这并不是GraphQL的直接缺点，而是切换到它的过程。对于一些应用程序和API来说，向这种新的工作方式转变可能为时已晚。如果您已经有了一个非常复杂的路由结构，或者有大量的客户端使用您的API，那么进行这种转换可能从来都不划算，甚至不实际。但是请记住，脸书有这个确切的问题，并且GraphQL是如何首先出现的，所以在这方面，总是有可能进行转换，这只是它是否值得的问题。</p><p id="c122" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这些只是我在考虑将一个API从REST迁移到GraphQL时发现的一些事情。如果你对两者之间的比较有更多的想法？请在评论中发表！</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h2 id="6d96" class="mw mx it bd nu oq or dn ny os ot dp oc kb ou ov og kf ow ox ok kj oy oz oo pa bi translated">参考资料和有用的链接</h2><div class="md me gp gr mf mg"><a href="https://blog.apollographql.com/graphql-vs-rest-5d425123e34b" rel="noopener  ugc nofollow" target="_blank"><div class="mh ab fo"><div class="mi ab mj cl cj mk"><h2 class="bd iu gy z fp ml fr fs mm fu fw is bi translated">GraphQL与REST</h2><div class="mn l"><h3 class="bd b gy z fp ml fr fs mm fu fw dk translated">通过HTTP发送数据的两种方式:有什么区别？</h3></div><div class="mo l"><p class="bd b dl z fp ml fr fs mm fu fw dk translated">blog.apollographql.com</p></div></div><div class="pg l"><div class="ph l pi pj pk pg pl lo mg"/></div></div></a></div><div class="md me gp gr mf mg"><a href="https://www.freecodecamp.org/news/so-whats-this-graphql-thing-i-keep-hearing-about-baf4d36c20cf/?source=post_page---------------------------" rel="noopener  ugc nofollow" target="_blank"><div class="mh ab fo"><div class="mi ab mj cl cj mk"><h2 class="bd iu gy z fp ml fr fs mm fu fw is bi translated">我一直听说的GraphQL是什么？</h2><div class="mn l"><h3 class="bd b gy z fp ml fr fs mm fu fw dk translated">我一直听说的GraphQL是什么？如果你像我一样，你可能会经历三个…</h3></div><div class="mo l"><p class="bd b dl z fp ml fr fs mm fu fw dk translated">www.freecodecamp.org</p></div></div><div class="pg l"><div class="pm l pi pj pk pg pl lo mg"/></div></div></a></div><div class="md me gp gr mf mg"><a href="https://blog.apollographql.com/the-next-step-for-realtime-data-in-graphql-b564b72eb07b" rel="noopener  ugc nofollow" target="_blank"><div class="mh ab fo"><div class="mi ab mj cl cj mk"><h2 class="bd iu gy z fp ml fr fs mm fu fw is bi translated">GraphQL中实时数据的下一步</h2><div class="mn l"><h3 class="bd b gy z fp ml fr fs mm fu fw dk translated">规范中现在有一个开放的RFC用于订阅！</h3></div><div class="mo l"><p class="bd b dl z fp ml fr fs mm fu fw dk translated">blog.apollographql.com</p></div></div><div class="pg l"><div class="pn l pi pj pk pg pl lo mg"/></div></div></a></div></div></div>    
</body>
</html>