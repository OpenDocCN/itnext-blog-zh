<html>
<head>
<title>How to implement a JAX-RS authentication filter</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何实现JAX-RS认证过滤器</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-implement-a-jax-rs-authentication-filter-3eee64b34b99?source=collection_archive---------0-----------------------#2019-12-20">https://itnext.io/how-to-implement-a-jax-rs-authentication-filter-3eee64b34b99?source=collection_archive---------0-----------------------#2019-12-20</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><p id="9a1a" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">如果你正在用Java创建REST-API，你可能已经听说过JAX-RS。虽然JAX-RS可以在Servlets之上实现，但并不要求这样做。这也意味着您可能无法使用特定于Servlet的东西，如ServletFilters。</p><figure class="kn ko kp kq gu kr gi gj paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gi gj km"><img src="../Images/8ea1ffa7ea5c753024cd3245e072c2df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uBCokypGpa2c4VBq3-JbPg.jpeg"/></div></div></figure><p id="0c5d" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">但是不要害怕——JAX-RS提供了一个很好的替代方案，我将向您展示如何通过这种方式轻松实现认证过滤器。接口是<a class="ae ky" href="https://jax-rs.github.io/apidocs/2.0/javax/ws/rs/container/ContainerRequestFilter.html" rel="noopener ugc nofollow" target="_blank"><em class="kz">javax . ws . RS . container . container request Filter</em></a>，这里我们需要实现filter()方法，下面我们就来做。我们要做的另一项工作是决定它在(可能的)过滤器链中的应用位置。让我们看一下请求流程:</p><figure class="kn ko kp kq gu kr gi gj paragraph-image"><div class="gi gj la"><img src="../Images/6b5c1707793d06faced2d9c9662868b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1290/format:webp/1*rIc_bXvRBvWSnAKoHxENHw.png"/></div><figcaption class="lb lc gk gi gj ld le bd b be z dk translated">通过过滤器的请求流</figcaption></figure><p id="5ba9" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">中间部分是<em class="kz">资源匹配</em>(绿色)，引擎在@Path和@GET注释的帮助下从请求url和方法中决定调用哪个<em class="kz">资源方法</em>。当您创建一个没有进一步限定的请求过滤器时，它将是一个<em class="kz">后匹配</em>过滤器(红色)。如果您想要<em class="kz"> PreMatch </em>(黄色)，那么您需要在您的类上提供@PreMatch注释。</p><h2 id="89f9" class="lf lg ir bd lh li lj dn lk ll lm dp ln jz lo lp lq kd lr ls lt kh lu lv lw lx bi translated">什么时候使用预赛和赛后？</h2><p id="1d6b" class="pw-post-body-paragraph jo jp ir jq b jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh mc kj kk kl ik bi translated">为了说明这一点，我实现了一个/test端点，我用一次预匹配和一次后匹配来调用我的身份验证过滤器(不传递身份验证信息)。我们先来看看赛后(默认):</p><pre class="kn ko kp kq gu md me mf mg aw mh bi"><span id="df8c" class="lf lg ir me b gz mi mj l mk ml"><strong class="me is">$ </strong>curl -i  http://localhost:8080/test<br/>HTTP/1.1 <strong class="me is">401</strong> Unauthorized<br/><br/><strong class="me is">$ </strong>curl -i  http://localhost:8080/bad-path<br/>HTTP/1.1 <strong class="me is">404</strong> Not Found</span><span id="0072" class="lf lg ir me b gz mm mj l mk ml"># Now with auth header<br/><strong class="me is">$ </strong>curl -i  -Hx-auth:`cat cred.txt` http://localhost:8080/test<br/>HTTP/1.1 <strong class="me is">200</strong> OK</span></pre><p id="3622" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">您可以看到，默认情况是首先运行资源匹配，然后通过返回404 Not Found for /bad-path来运行我们的请求过滤器。同样，如果我指定了resource方法不支持的可接受的媒体类型，引擎将返回406代码。根据您的使用情况，可能不希望将此类信息泄露给未经身份验证的用户。</p><p id="3458" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">现在我们来看看赛前的情况(上图中的黄色):</p><pre class="kn ko kp kq gu md me mf mg aw mh bi"><span id="bb5a" class="lf lg ir me b gz mi mj l mk ml"><strong class="me is">$ </strong>curl -i  <a class="ae ky" href="http://localhost:8080/test" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/test</a><br/>HTTP/1.1 <strong class="me is">401</strong> Unauthorized</span><span id="94ad" class="lf lg ir me b gz mm mj l mk ml"><strong class="me is">$ </strong>curl -i  <a class="ae ky" href="http://localhost:8080/bad-path" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/bad-path</a><br/>HTTP/1.1 <strong class="me is">401</strong> Unauthorized</span></pre><p id="1a86" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">我们的过滤器在两种情况下都检测到授权失败，并使用401响应提前中止请求:请求甚至没有达到我们想要的资源匹配(绿色)。</p><h2 id="91e9" class="lf lg ir bd lh li lj dn lk ll lm dp ln jz lo lp lq kd lr ls lt kh lu lv lw lx bi translated">滤波器排序呢？</h2><p id="77e9" class="pw-post-body-paragraph jo jp ir jq b jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh mc kj kk kl ik bi translated">如第一张图所示，可以部署多个过滤器。虽然有时排序并不重要，但大多数时候却很重要。例如，采用两个过滤器，它们首先检查身份验证，然后从数据库加载一些关于已验证用户的数据。</p><figure class="kn ko kp kq gu kr gi gj paragraph-image"><div class="gi gj mn"><img src="../Images/c918fe7378db34e4a975a3f56b4f4b3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:782/format:webp/1*-FTiWev0BKSubRCZgtM9Zw.png"/></div><figcaption class="lb lc gk gi gj ld le bd b be z dk translated">过滤器排序</figcaption></figure><p id="efc8" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">为了定义排序，我们可以使用@Priority注释。</p><pre class="kn ko kp kq gu md me mf mg aw mh bi"><span id="ed4d" class="lf lg ir me b gz mi mj l mk ml">@Priority(<strong class="me is">1</strong>)<br/>@PreMatching<br/>@Provider<br/>public class AuthFilter .. {..}<br/><br/>@Priority(<strong class="me is">2</strong>)<br/>@PreMatching<br/>@Provider<br/>public class DbLoadFilter .. {..}</span></pre><p id="c4f0" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">过滤器按优先级值的升序排序。</p><h2 id="4cef" class="lf lg ir bd lh li lj dn lk ll lm dp ln jz lo lp lq kd lr ls lt kh lu lv lw lx bi translated">废话少说——给我看看代码</h2><p id="6bde" class="pw-post-body-paragraph jo jp ir jq b jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh mc kj kk kl ik bi translated">好，我们开始:-)</p><pre class="kn ko kp kq gu md me mf mg aw mh bi"><span id="e747" class="lf lg ir me b gz mi mj l mk ml">@PreMatching             // <strong class="me is">(1)</strong><br/>@Provider                // <strong class="me is">(2)</strong> <br/>public class IncomingRequestFilter implements ContainerRequestFilter {<br/><br/>  @Override<br/>  public void <strong class="me is">filter</strong>(ContainerRequestContext requestContext) throws IOException {<br/><br/>    String xAuth = requestContext.getHeaderString("x-auth");<br/><br/>    // No auth - abort<br/>    if (xAuth == null || xAuth.isEmpty()) {      // <strong class="me is">(3)</strong><br/>      requestContext.abortWith(Response.<em class="kz">status</em>(<br/>              Response.Status.<em class="kz">UNAUTHORIZED</em>).build());<br/>      return;    // <strong class="me is">(4)</strong><br/>    }</span></pre><p id="cc16" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">如上所述，我们需要一个预匹配滤波器(1)。JAX-RS引擎需要@Provider注释(2)来找到我们的过滤器，并将其正确连接到过滤器链中。在<em class="kz"> filter() </em>方法中，我们检索auth头并检查它是否存在并且不为空(3)。如果报头不存在或为空，我们用<em class="kz"> 401未执行</em>状态中止上下文。</p><figure class="kn ko kp kq gu kr gi gj paragraph-image"><div class="gi gj mo"><img src="../Images/6d2135f446adcfb257828a1318cd30d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:834/format:webp/1*tyU4gNIfdaG36xDU3aXTrA.png"/></div><figcaption class="lb lc gk gi gj ld le bd b be z dk translated">如果验证头不存在或不正确，则中止请求</figcaption></figure><p id="8333" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">最后，我们需要直接返回(4)，因为仅仅调用<em class="kz">request context . abort with()</em>并不能为我们做到这一点，代码流仍然会运行到下面的代码中。</p><pre class="kn ko kp kq gu md me mf mg aw mh bi"><span id="cd0f" class="lf lg ir me b gz mi mj l mk ml">// Now that we are sure that there is a header, we can use it.<br/>    Optional&lt;XId&gt; xid = HeaderHelper.<em class="kz">getXIdFromString</em>(xAuth); // <strong class="me is">(5)</strong><br/>    if (xid.isPresent()) {<br/>      // header was good, so now create the security context<br/>      XId xIdentity = xid.get();                              // <strong class="me is">(6)</strong><br/>      SecurityContext sctx = new XIdSecurityContext(xIdentity);<br/>      requestContext.setSecurityContext(sctx);<br/>    } else {<br/>      // Header was present, but not correct            // <strong class="me is">(7)</strong><br/>      requestContext.abortWith(Response.<em class="kz">status</em>(<br/>             Response.Status.<em class="kz">UNAUTHORIZED</em>).build());<br/>    }<br/>  }<br/>}</span></pre><p id="890d" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">既然头部已经存在，我们可以解析它了(5)。如果解析成功，我们可以创建一个javax . ws . RS . core . security context，并将其粘贴到请求(6)中，以便资源方法稍后可以通过头注入来检索它，以便进一步处理。构造SecurityContext还将在其中设置调用者主体以供以后使用。<br/>如果解析失败，我们再次使用401响应中止流程。</p><h2 id="7789" class="lf lg ir bd lh li lj dn lk ll lm dp ln jz lo lp lq kd lr ls lt kh lu lv lw lx bi translated">如何使用SecurityContext？</h2><p id="fcf2" class="pw-post-body-paragraph jo jp ir jq b jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh mc kj kk kl ik bi translated">我们的身份验证头还提供了额外的信息，比如当前用户名，这在后面的处理中可能会用到。</p><p id="ed20" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">在我们的资源方法中，我们可以以两种方式使用它:</p><pre class="kn ko kp kq gu md me mf mg aw mh bi"><span id="e9d7" class="lf lg ir me b gz mi mj l mk ml">@Path("/test")<br/>@RequestScoped<br/>public class TestService {<br/><br/>  // Needed to retrieve the user<br/>  @Context SecurityContext <strong class="me is">ctx</strong>;   // <strong class="me is">(7)</strong><br/><br/><br/>  @Path("/")<br/>  @GET<br/>  public String test(@Context SecurityContext <strong class="me is">ctx2</strong>) { // <strong class="me is">(8)</strong><br/><br/>    System.<em class="kz">out</em>.println(<strong class="me is">ctx</strong>.getUserPrincipal().getName());<br/>    System.<em class="kz">out</em>.println(<strong class="me is">ctx2</strong>.getUserPrincipal().getName());</span></pre><p id="34b6" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">我们既可以为整个类注入SecurityContext)，也可以在每个方法的基础上注入SecurityContext)，例如从其中检索调用主体。</p><p id="5b36" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">当然还有改进的空间:我们可以直接使Princpial可用于注入，这样我们就不需要从SecurityContext中取出它。因为你可以在GitHub上看看我的<a class="ae ky" href="https://github.com/RedHatInsights/policies-ui-backend/blob/master/src/main/java/com/redhat/cloud/policies/app/auth/IncomingRequestFilter.java" rel="noopener ugc nofollow" target="_blank">incomrequestfilter</a>和相关类的完整代码。</p></div></div>    
</body>
</html>