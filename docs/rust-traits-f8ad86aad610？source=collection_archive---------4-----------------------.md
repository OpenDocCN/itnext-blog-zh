# 生锈特征

> 原文：<https://itnext.io/rust-traits-f8ad86aad610?source=collection_archive---------4----------------------->

![](img/ddefbf7a6ba6758b0cea5175e00b50c7.png)

你好

在这篇文章中，我们将谈论锈病的特征。

这篇文章的视频版本也可以在 YouTube 上找到。

那么让我们从发现什么是特质开始？

特征是在类型上定义共享行为的可靠方式，与接口相似但不完全相同。

让我们来看看 rust 定义特征的语法。

在上面的例子中，我们已经定义了一个简单的特征，它定义了一个类型应该如何将自己表示为一个字符串的行为。

现在，假设我们需要一个函数来获取实现这一特征的类型，并将其记录到 stdout 中。

你可以看到我们使用了一个泛型参数和一个绑定到该类型的 trait，我们基本上是说我们需要一个实现`AsString` trait 的类型。

现在我们有了一个特征和一个使用该特征作为输入的函数，但是我们需要为我们想要用作函数输入的类型实现该特征，最简单的实现可能是`String`,因为不需要任何类型的转换或其他任何东西。Rust 类型系统很酷的一点是，它允许我们为任何类型实现一个特征，甚至是来自其他库的类型或来自标准库的类型。

让我们开始吧。

Rust 语法与其他拥有接口和接口实现概念的语言有些不同。

现在我们已经为 Rust `String`实现了`AsString`，让我们使用它。

你可以看到，使用一个具有泛型参数界限的函数是如此容易，因为 Rust 编译器足够智能，可以找到泛型参数的实际类型，我们不需要为编译器指定它。

现在让我们来看看 Rust 中最强大的特征概念之一，你可以为实现另一个特征的所有类型实现一个特征，而不是为每个类型单独实现一个特征。

让我们看看在 Rust 中这是如何发生的。

让我们来看看发生了什么，我们告诉 rust，我们希望为所有从 stdlib 实现 ToString trait 的类型实现我们的 trait。我们的例子相当简单，但是你可以对 Rust 语言中的每个特征都这样做，这给了你很大的能力，另一个为其他特征的实现者实现一个特征的例子是标准库中的`Into`和`From`特征。

在上面的代码中，我们可以看到`From`和`Into`特征的定义，这两个特征是在 Rust 编译器需要将一种类型转换成另一种类型时用于 Rust 中的类型转换。为了在你自己的类型中获得这个功能，你不需要实现两个特征，你只需要为你的类型实现`From`，你可以通过为你的类型实现`From`来免费获得`Into`的实现。

上面的代码来自 Rust 标准库，正如你所见(就像我们自己的例子)，它为所有实现了`From`的类型实现了`Into`。

这是对 rust 中特征的简单介绍，Rust 中有很多特征，特征是几乎所有语言特征的支柱，Rust 中的每个语言特征都映射到语言中的某个特征。

特征是非常强大的，学习如何使用它们是编写 Rust 的重要一步。