<html>
<head>
<title>An Update on WebAssembly/WASI Support in Ruby</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Ruby中WebAssembly/WASI支持的更新</h1>
<blockquote>原文：<a href="https://itnext.io/final-report-webassembly-wasi-support-in-ruby-4aface7d90c9?source=collection_archive---------0-----------------------#2022-03-16">https://itnext.io/final-report-webassembly-wasi-support-in-ruby-4aface7d90c9?source=collection_archive---------0-----------------------#2022-03-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><h1 id="2621" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">概观</h1><p id="8eb9" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">CRuby是一个高度可移植的C应用，它运行在许多平台上(你可以在CI <a class="ae lj" href="https://rubyci.org/" rel="noopener ugc nofollow" target="_blank">这里</a>看到哪些平台经过测试)。然而,“可移植性”只是在源代码级别，构建的可执行文件不能跨架构和系统调用接口移植。</p><p id="e732" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">该项目通过将CRuby移植到WASI·ABI的独立WebAssembly，使其在可执行文件级别上具有可移植性。此外，我们在WASI实现了一个VFS(虚拟文件系统),将Ruby脚本打包成一个WebAssembly二进制文件。这些改进使得发布Ruby脚本变得更加容易。</p><p id="649c" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">这是<a class="ae lj" href="https://www.ruby.or.jp/en/news/20211025" rel="noopener ugc nofollow" target="_blank">要求的2021年红宝石协会拨款</a>的最终报告。</p><h1 id="1a4b" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">关于WebAssembly和WASI</h1><p id="aabe" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">WebAssembly不仅用于将现有项目移植到web浏览器，还用于提供沙箱化的可移植可执行文件。它不仅限于web，而且正被用于各种情况，如边缘计算、嵌入式环境和插件系统的接口。</p><p id="cfb9" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">Ruby社区已经使用Emscripten将CRuby移植到WebAssembly，但它严重依赖于主机JavaScript环境。这使得它很难用于上述应用。</p><p id="8e5a" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">WASI致力于为WebAssembly模块定义一组标准的系统调用，允许WebAssembly模块不仅可以跨架构移植，还可以跨实现这组标准系统调用的环境移植。WASI根本不依赖JavaScript。</p><p id="9878" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">为C和C++用户提供了<a class="ae lj" href="https://github.com/WebAssembly/wasi-sdk" rel="noopener ugc nofollow" target="_blank"> WASI SDK </a>，这是一个LLVM编译器工具链，带有基于musl和cloudlibc的libc <a class="ae lj" href="https://github.com/WebAssembly/wasi-libc" rel="noopener ugc nofollow" target="_blank"> wasi-libc </a>。</p><h1 id="2099" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">履行</h1><p id="db3d" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">现在克鲁比的主分支通过我们的几个补丁支持WASI作为建造目标。支持的初始补丁集是<a class="ae lj" href="https://github.com/ruby/ruby/pull/5407" rel="noopener ugc nofollow" target="_blank"> ruby/ruby#5407 </a>(已经合并)。</p><p id="6d05" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">在<a class="ae lj" href="https://bugs.ruby-lang.org/issues/18462" rel="noopener ugc nofollow" target="_blank">“合并基于WASI的WebAssembly支持的提案”</a>中跟踪此功能。</p><p id="b046" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">如今的WASI系统调用有限，WebAssembly本身也没有上下文切换机制。因此，CRuby需要一些变通办法来解决这些问题。值得注意的变化是:</p><ul class=""><li id="edda" class="lp lq iq kn b ko lk ks ll kw lr la ls le lt li lu lv lw lx bi translated">使用Asyncify为一些缺失的功能添加仿真实现:异常使用setjmp/longjmp，纤程使用ucontext，GC使用register scan</li><li id="053c" class="lp lq iq kn b ko ly ks lz kw ma la mb le mc li lu lv lw lx bi translated">支持无线程环境</li></ul><p id="a2bd" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">除了与线程和进程相关的测试之外，当前主分支通过了basictest、bootstraptest和ruby/spec。它还支持静态链接的扩展库。</p><p id="4d07" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">你可以在这里看到如何建立WASI目标红宝石:<a class="ae lj" href="https://github.com/ruby/ruby/blob/master/wasm/README.md" rel="noopener ugc nofollow" target="_blank">https://github.com/ruby/ruby/blob/master/wasm/README.md</a></p><p id="20a5" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">此外，我成为了一个持续维护这个特性的提交者。</p><h1 id="4710" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">由Asyncify支持的仿真</h1><p id="9746" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">如上所述，当前的WebAssembly没有上下文切换功能，但是有一种用户技术可以通过二进制转换暂停和恢复WebAssembly进程。这种技术被称为<a class="ae lj" href="https://kripken.github.io/blog/wasm/2019/07/16/asyncify.html" rel="noopener ugc nofollow" target="_blank">不对称</a>。</p><p id="ad96" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">Asyncify提供了两种操作来控制程序的执行。</p><ol class=""><li id="f566" class="lp lq iq kn b ko lk ks ll kw lr la ls le lt li md lv lw lx bi translated">停止当前执行，并展开到根调用框架，同时将执行状态和函数局部寄存器(也称为Wasm局部寄存器)写到内存中</li><li id="ec1d" class="lp lq iq kn b ko ly ks lz kw ma la mb le mc li md lv lw lx bi translated">在恢复保存的执行状态和寄存器时，回退到停止的调用帧。</li></ol><p id="c04f" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">你可以在ruby/ruby库的<a class="ae lj" href="https://github.com/ruby/ruby/tree/master/wasm" rel="noopener ugc nofollow" target="_blank"/><code class="fe me mf mg mh b"><a class="ae lj" href="https://github.com/ruby/ruby/tree/master/wasm" rel="noopener ugc nofollow" target="_blank">wasm</a></code><a class="ae lj" href="https://github.com/ruby/ruby/tree/master/wasm" rel="noopener ugc nofollow" target="_blank">目录下看到这些仿真实现。</a></p><h2 id="22d8" class="mi jo iq bd jp mj mk dn jt ml mm dp jx kw mn mo kb la mp mq kf le mr ms kj mt bi translated">setjmp/longjmp</h2><p id="0774" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">由于这些神奇的操作，setjmp和longjmp可以像下面这样简单地模拟:</p><ol class=""><li id="34f5" class="lp lq iq kn b ko lk ks ll kw lr la ls le lt li md lv lw lx bi translated">setjmp通过展开到main来保存当前的堆栈指针和执行状态，然后重绕到setjmp的调用点。</li><li id="9d72" class="lp lq iq kn b ko ly ks lz kw ma la mb le mc li md lv lw lx bi translated">longjmp退绕到main，但是丢弃收集的执行状态，并倒绕到步骤1中保存的setjmp的调用点，然后恢复保存的堆栈指针。</li></ol><figure class="mv mw mx my gt mz gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi mu"><img src="../Images/1f0ccebe7c246b3751ba0e2995d1f27c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7v3Qda9royMX-kn1"/></div></div></figure><p id="cbb2" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">然而，随着调用栈越来越深，这个setjmp仿真变得越来越慢！此外，setjmp用于Ruby VM的核心。因此，我们通过在核心实现中避免重绕到main来减轻性能损失。</p><p id="ce07" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">我们也考虑过使用<a class="ae lj" href="https://github.com/WebAssembly/exception-handling" rel="noopener ugc nofollow" target="_blank">异常处理提议</a>，它比微基准测试中的Asyncify方法快1.88倍。然而，我们发现在C层用try-catch风格重写setjmp/longjmp的所有使用需要相当多的修改。我们决定现在使用一种非对称的方法来最小化补丁的影响，而不是性能的提高。</p><h2 id="b888" class="mi jo iq bd jp mj mk dn jt ml mm dp jx kw mn mo kb la mp mq kf le mr ms kj mt bi translated">纤维(ucontext)</h2><p id="91ca" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">与setjmp/longjmp类似，WASI上的光纤利用了Asyncify。它只是通过展开/倒带和交换堆栈指针来切换执行状态。</p><figure class="mv mw mx my gt mz gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi ng"><img src="../Images/4698c1cb0f828f841083a523620d32ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kWPXA0L_1P-qxdXx"/></div></div></figure><h2 id="61b4" class="mi jo iq bd jp mj mk dn jt ml mm dp jx kw mn mo kb la mp mq kf le mr ms kj mt bi translated">扫描GC的寄存器(Wasm局部变量)</h2><p id="2200" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">CRuby使用保守的垃圾收集，通过扫描一些值空间来寻找有生命的对象，从而标记类似指针的值。</p><p id="49ef" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">运行WebAssembly程序时，可以将Ruby对象(<code class="fe me mf mg mh b">VALUE</code>)放入:</p><ol class=""><li id="241c" class="lp lq iq kn b ko lk ks ll kw lr la ls le lt li md lv lw lx bi translated">Wasm堆栈:在Wasm规范中定义</li><li id="8066" class="lp lq iq kn b ko ly ks lz kw ma la mb le mc li md lv lw lx bi translated">函数局部寄存器(Wasm局部寄存器):在Wasm规范中定义</li><li id="8038" class="lp lq iq kn b ko ly ks lz kw ma la mb le mc li md lv lw lx bi translated">c堆栈:在线性内存中分配</li></ol><p id="84f3" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">不像3这样的普通内存空间。c堆栈，1。Wasm堆栈和2。不能动态扫描函数局部寄存器。幸运的是，Asyncify将Wasm局部变量和Wasm堆栈作为执行状态写入，因此GC通过Asyncify展开和倒带，并扫描存储在线性内存中的执行状态。</p><h1 id="f08d" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">WASI的虚拟文件系统</h1><p id="fc03" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我们在WASI实现了一个名为<a class="ae lj" href="https://github.com/kateinoigakukun/wasi-vfs" rel="noopener ugc nofollow" target="_blank"> wasi-vfs </a>的VFS(虚拟文件系统)，将Ruby脚本打包成一个WebAssembly二进制文件。它不仅适用于Ruby，也适用于任何使用wasi-libc的应用程序。</p><h2 id="7485" class="mi jo iq bd jp mj mk dn jt ml mm dp jx kw mn mo kb la mp mq kf le mr ms kj mt bi translated">使用</h2><p id="6910" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">您可以使用与运行wasmtime或wasmer相同的选项来打包目录。</p><pre class="mv mw mx my gt nh mh ni nj aw nk bi"><span id="a290" class="mi jo iq mh b gy nl nm l nn no"># Without packing<br/>$ wasmtime run ruby.wasm --mapdir /::./lib -- /irb.rb<br/>irb(main):001:0&gt;<br/>...<br/># Packing with wasm-vfs<br/>$ wasm-vfs pack ruby.wasm --mapdir /::./lib -o irb.wasm<br/>$ wasmtime run irb.wasm -- /irb.rb<br/>irb(main):001:0&gt;<br/>...</span></pre><p id="5dd3" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">注意，它目前需要链接<code class="fe me mf mg mh b">libwasi_vfs.a</code>，因为它依赖链接器的符号解析机制来挂钩WASI系统调用，并且还需要合并数据段。然而，在<a class="ae lj" href="https://github.com/WebAssembly/module-linking" rel="noopener ugc nofollow" target="_blank">模块链接</a>到位后，该限制将被取消。</p><figure class="mv mw mx my gt mz gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi np"><img src="../Images/e070d5d5133568359e004fea70677357.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*D5QQTugkoT-bwgib.png"/></div></div></figure><h2 id="99df" class="mi jo iq bd jp mj mk dn jt ml mm dp jx kw mn mo kb la mp mq kf le mr ms kj mt bi translated">它是如何工作的？</h2><p id="2481" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><code class="fe me mf mg mh b">wasi-vfs pack</code>命令是Wizer的包装器，Wizer是Wasm应用程序的预初始化器。参见<a class="ae lj" href="https://bytecodealliance.org/articles/making-javascript-run-fast-on-webassembly" rel="noopener ugc nofollow" target="_blank">字节码联盟:让JavaScript在WebAssembly上快速运行</a>。</p><p id="f963" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">wasi-vfs中的初始化过程扫描映射的目录，然后将它们复制到内存中的虚拟文件系统中。然后Wizer会拍摄该状态的快照，并将其保存为Wasm文件。</p><h1 id="dba5" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">与JavaScript的互操作</h1><p id="fd68" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我们还实现了一个Ruby  JavaScript interop库，作为浏览器和Node.js的npm包<a class="ae lj" href="https://github.com/kateinoigakukun/ruby.wasm/blob/main/packages/npm-packages/ruby-wasm-wasi/README.md" rel="noopener ugc nofollow" target="_blank">。它已经在try.ruby-lang.org</a><a class="ae lj" href="https://try.ruby-lang.org/playground/" rel="noopener ugc nofollow" target="_blank">中使用。</a></p><pre class="mv mw mx my gt nh mh ni nj aw nk bi"><span id="ac71" class="mi jo iq mh b gy nl nm l nn no">const vm = await DefaultRubyVM();<br/>vm.eval(`<br/>  luckiness = ["Lucky", "Unlucky"].sample<br/>  JS::eval("document.body.innerText = '#{luckiness}'")<br/>`);</span></pre><h1 id="91c4" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">性能基准</h1><p id="1990" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">这里是一份<a class="ae lj" href="https://github.com/mame/optcarrot" rel="noopener ugc nofollow" target="_blank">optre b</a>与原生CRuby和其他Ruby实现进行比较的性能基准报告。(越大越好)</p><p id="be5f" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated"><code class="fe me mf mg mh b">master (wasm32-wasi)</code>和<code class="fe me mf mg mh b">opal</code>使用Node.js v16.14.0作为他们的js和Wasm运行时。</p><figure class="mv mw mx my gt mz gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/d25d6aea5ebdc910fedb824c8d504aab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1294/format:webp/1*XoJC70n9dBsHoY6wBOlplA.png"/></div></figure><figure class="mv mw mx my gt mz gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/4c0b1d374896607a8ced0389bcc5e932.png" data-original-src="https://miro.medium.com/v2/resize:fit:1294/format:webp/1*Y27xFxcFRfZ3LmCL0Noi7A.png"/></div></figure><p id="0605" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">Performance profiler报告了最重函数的类似趋势，因此瓶颈不在CRuby实现中，而是Wasm运行时比本机运行时慢。此外，它还包括我们上面提到的非对称管理费用。</p><h1 id="e5b4" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">其他琐碎的工作</h1><ul class=""><li id="84cc" class="lp lq iq kn b ko kp ks kt kw nr la ns le nt li lu lv lw lx bi translated">ruby.wasm :预构建wasm目标ruby的夜间发布</li><li id="f9d2" class="lp lq iq kn b ko ly ks lz kw ma la mb le mc li lu lv lw lx bi translated"><a class="ae lj" href="https://github.com/kateinoigakukun/wasi-preset-args" rel="noopener ugc nofollow" target="_blank"> wasi-preset-args </a>:预设wasi模块命令行参数的工具。这对于设置传递给Ruby的脚本路径很有用。像<a class="ae lj" href="https://www.fastly.com/jp/products/edge-compute/serverless" rel="noopener ugc nofollow" target="_blank"> Compute@Edge </a>这样的平台无法给出参数，所以这个工具是必不可少的</li><li id="328d" class="lp lq iq kn b ko ly ks lz kw ma la mb le mc li lu lv lw lx bi translated">optcarrot.wasm :一个在浏览器上用Ruby编写的游戏模拟器，由WebAssembly提供支持</li><li id="79e6" class="lp lq iq kn b ko ly ks lz kw ma la mb le mc li lu lv lw lx bi translated"><a class="ae lj" href="https://github.com/kateinoigakukun/irb.wasm" rel="noopener ugc nofollow" target="_blank">irb . wasm</a>:web assembly支持的浏览器上的IRB</li><li id="e24e" class="lp lq iq kn b ko ly ks lz kw ma la mb le mc li lu lv lw lx bi translated"><a class="ae lj" href="https://wapm.io/katei/ruby" rel="noopener ugc nofollow" target="_blank"> katei/ruby </a>，<a class="ae lj" href="https://wapm.io/katei/irb" rel="noopener ugc nofollow" target="_blank"> katei/irb </a>:非官方WAPM套餐</li></ul><h1 id="c69c" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">未来工作思路</h1><ul class=""><li id="6a41" class="lp lq iq kn b ko kp ks kt kw nr la ns le nt li lu lv lw lx bi translated">将初始化的虚拟机状态快照为可执行的Wasm文件</li><li id="aa25" class="lp lq iq kn b ko ly ks lz kw ma la mb le mc li lu lv lw lx bi translated">压缩wasi-vfs嵌入的文件</li><li id="b222" class="lp lq iq kn b ko ly ks lz kw ma la mb le mc li lu lv lw lx bi translated">在浏览器中运行示例代码的RDoc集成</li><li id="a846" class="lp lq iq kn b ko ly ks lz kw ma la mb le mc li lu lv lw lx bi translated">扩展RubyGems以允许静态链接扩展库</li></ul><h1 id="00c6" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">结论</h1><p id="162c" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我们已经展示了如何通过WASI·ABI将CRuby移植到WebAssembly，并介绍了相关工具。这一成果将推动Ruby在更多环境中的使用。另外，这个特性将由Ruby的新手森英士·斋藤来维护。当然，欢迎任何投稿！</p><p id="0692" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">如果没有发现重大问题，它将随Ruby 3.2一起发布。</p></div></div>    
</body>
</html>