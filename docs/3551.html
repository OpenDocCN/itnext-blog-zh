<html>
<head>
<title>Handling Reachability in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Swift中处理可达性</h1>
<blockquote>原文：<a href="https://itnext.io/handling-reachability-in-swift-d12dbd538df?source=collection_archive---------4-----------------------#2020-01-07">https://itnext.io/handling-reachability-in-swift-d12dbd538df?source=collection_archive---------4-----------------------#2020-01-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div class="gh gi jq"><img src="../Images/0241e83c1c6468a1eca243c382861a57.png" data-original-src="https://miro.medium.com/v2/resize:fit:512/format:webp/1*q0cqFgdwIzLkLfcH6nYNrQ.png"/></div></figure><p id="4bbf" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">作为一名iOS开发人员，有时我们需要处理没有互联网的情况。有一个很棒的第三方库，<a class="ae kv" href="https://github.com/ashleymills/Reachability.swift" rel="noopener ugc nofollow" target="_blank"> ReachabilitySwift </a>，它帮助我们完成所有的底层工作，并为我们提供易于使用的API。</p><figure class="kx ky kz la gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="gh gi kw"><img src="../Images/ca671e8f0577fa01322ef735fc27af0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*1VtY9q3F8dD_q8yh2QRKIQ.gif"/></div></div></figure><p id="4d2b" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">然而，每当我们有一个对象需要检测互联网状况时，实例化一个新的<code class="fe lf lg lh li b">Reachability</code>实例并调用<code class="fe lf lg lh li b">startNotifier()</code>来使用它是不符合逻辑的。</p><figure class="kx ky kz la gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="gh gi lj"><img src="../Images/c70a802933e584740cf4457571af57d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tmiWIR9Mnh2csONcpB-bQQ.png"/></div></div></figure><p id="5cda" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们目前想要的是做一次设置，并允许多个实例有能力检查互联网连接。在这种情况下，通过结合单例模式和多播委托模式来解决这个问题是合适的。看看下面的插图，你很快就会明白。</p><figure class="kx ky kz la gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="gh gi lk"><img src="../Images/0dd7e94897011d110b0946acaf6ba1b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pjLcl0sUEDlf5G_jgvST0A.png"/></div></div></figure><figure class="kx ky kz la gt ju"><div class="bz fp l di"><div class="ll lm l"/></div></figure><p id="48ec" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">你可以在这里看到完整的<a class="ae kv" href="https://github.com/ji3g4kami/ReachabilityManager" rel="noopener ugc nofollow" target="_blank">源代码</a>。或者，如果你想直接使用它，只需通过Cocoapods安装即可。</p><h2 id="dacb" class="ln lo it bd lp lq lr dn ls lt lu dp lv ki lw lx ly km lz ma mb kq mc md me mf bi translated">多播委托模式</h2><p id="2a7a" class="pw-post-body-paragraph jx jy it jz b ka mg kc kd ke mh kg kh ki mi kk kl km mj ko kp kq mk ks kt ku im bi translated">这种模式适合创建一对多的代理关系。</p><figure class="kx ky kz la gt ju"><div class="bz fp l di"><div class="ll lm l"/></div></figure><p id="30a3" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这种模式的关键是如何:</p><ul class=""><li id="31c7" class="ml mm it jz b ka kb ke kf ki mn km mo kq mp ku mq mr ms mt bi translated">使用泛型接受您的委托协议(<code class="fe lf lg lh li b">ConnectionListener</code>，并用<code class="fe lf lg lh li b">AnyObject</code>实例化DelegateWrapper。</li><li id="5a89" class="ml mm it jz b ka mu ke mv ki mw km mx kq my ku mq mr ms mt bi translated">用身份(<code class="fe lf lg lh li b">===</code>)管理您的委托人:<code class="fe lf lg lh li b">addDelegate()</code>和<code class="fe lf lg lh li b">removeDelegate()</code>。</li><li id="61ac" class="ml mm it jz b ka mu ke mv ki mw km mx kq my ku mq mr ms mt bi translated">使用for循环通知您的委托人:<code class="fe lf lg lh li b">invokeDelegates()</code>。</li></ul><h2 id="42c9" class="ln lo it bd lp lq lr dn ls lt lu dp lv ki lw lx ly km lz ma mb kq mc md me mf bi translated">从这里去哪里</h2><p id="2ff7" class="pw-post-body-paragraph jx jy it jz b ka mg kc kd ke mh kg kh ki mi kk kl km mj ko kp kq mk ks kt ku im bi translated">现在您已经掌握了多播代理模式的概念。如果您想了解更多关于设计模式的知识，我建议您看一看:</p><ul class=""><li id="f717" class="ml mm it jz b ka kb ke kf ki mn km mo kq mp ku mq mr ms mt bi translated"><a class="ae kv" href="https://store.raywenderlich.com/products/design-patterns-by-tutorials" rel="noopener ugc nofollow" target="_blank">通过教程设计模式</a></li><li id="277b" class="ml mm it jz b ka mu ke mv ki mw km mx kq my ku mq mr ms mt bi translated"><a class="ae kv" href="https://refactoring.guru/design-patterns" rel="noopener ugc nofollow" target="_blank">重构大师</a></li></ul></div></div>    
</body>
</html>