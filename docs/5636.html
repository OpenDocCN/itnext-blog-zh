<html>
<head>
<title>Enhance your frontend state management with view models</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用视图模型增强您的前端状态管理</h1>
<blockquote>原文：<a href="https://itnext.io/enhance-your-frontend-state-management-with-view-models-7bf49e1a0991?source=collection_archive---------2-----------------------#2021-04-21">https://itnext.io/enhance-your-frontend-state-management-with-view-models-7bf49e1a0991?source=collection_archive---------2-----------------------#2021-04-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="320f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你很可能使用过<a class="ae kl" href="https://mobx.js.org/README.html" rel="noopener ugc nofollow" target="_blank"> MobX </a>、<a class="ae kl" href="https://redux.js.org/" rel="noopener ugc nofollow" target="_blank"> Redux </a>或者查看过<a class="ae kl" href="https://reactjs.org/docs/context.html" rel="noopener ugc nofollow" target="_blank"> React上下文API </a>。</p><p id="b381" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">引用上下文API登录网站:</p><p id="d17c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">“上下文提供了一种通过组件树传递数据的方式，而不必在每一级手动向下传递属性。”</p><p id="e7e7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是大多数状态管理解决方案的基本共同点:</p><p id="9fe5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如何使子组件可以访问数据，以及如何动态更新状态。</p><p id="2677" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本文将介绍使用视图模型的一些可能性和优点。我们将讨论代码。很多！</p><p id="e827" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">虽然在<a class="ae kl" href="https://github.com/neomjs/neo" rel="noopener ugc nofollow" target="_blank"> neo.mjs </a>中使用视图模型非常强大并且相当容易做到，但是理解它如何工作的内部逻辑是具有挑战性的，即使对于有经验的Javascript开发人员来说也是如此。</p><p id="5c77" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这篇文章分为两部分:</p><ol class=""><li id="18a3" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk kr ks kt ku bi translated">“利用视图模型增强您的前端状态管理”<br/>包括几个示例应用的代码以及视频&amp;在线演示</li><li id="831c" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">“使用视图模型增强您的前端状态管理—第2部分”<br/>幕后:设计目标&amp;谈论视图模型实现</li></ol><p id="26c1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">欢迎来到第1部分！</strong></p><p id="ce95" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">【旁注】本文是“neo.mjs Javascript UI框架视图模型介绍”的扩展重写。对于neo.mjs第2版，关于如何使用绑定格式化程序的语法从字符串转换为函数，这在以前的文章中没有反映出来。如果您已经阅读了前一篇文章，请查看视图定义(箭头函数)并深入到新的内容部分8。</p><h1 id="9187" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">内容</h1><ol class=""><li id="d007" class="km kn iq jp b jq ly ju lz jy ma kc mb kg mc kk kr ks kt ku bi translated">介绍</li><li id="d2f3" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">neo.mjs是什么？</li><li id="d79c" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">不使用视图模型的简单演示应用程序</li><li id="7fb3" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">使用视图模型类的简单演示应用程序</li><li id="0e9b" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">使用内嵌视图模型的简单演示应用程序</li><li id="555a" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">使用嵌套数据的简单演示应用程序</li><li id="b005" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">高级演示应用</li><li id="6f5b" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">对话框应用程序:访问父树之外的视图模型</li><li id="af4b" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">在线演示</li><li id="0090" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">源代码位置</li><li id="44bf" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">铊-溴</li><li id="a215" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">感谢您的反馈！</li></ol><h1 id="4f93" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">1.介绍</h1><p id="e8ba" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">组件(扩展<a class="ae kl" href="https://github.com/neomjs/neo/blob/dev/src/component/Base.mjs" rel="noopener ugc nofollow" target="_blank">组件的类。基本</a>和视图控制器(扩展<a class="ae kl" href="https://github.com/neomjs/neo/blob/dev/src/controller/Component.mjs" rel="noopener ugc nofollow" target="_blank">控制器的类)。组件</a>已经在框架内部很长时间了，所以支持<a class="ae kl" href="https://en.wikipedia.org/wiki/Model-view-viewmodel" rel="noopener ugc nofollow" target="_blank"> MVVM设计模式</a>的缺失部分是视图模型。</p><p id="a61a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我很兴奋地宣布，这个框架现在为这个主题提供了一个优雅的解决方案。优雅尤其与绑定格式化程序相关，它开箱即用，无需创建或使用模板引擎。这里的术语是<a class="ae kl" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals" rel="noopener ugc nofollow" target="_blank">模板文字</a>。</p><p id="4c0c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">视图模型可以帮助您调整复杂组件树的状态，并减少锅炉板代码。</p><p id="7853" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我认为深入这个主题的一个好方法是创建一个简单的演示应用程序，首先不使用视图模型，然后将其转换为使用它们的版本。从那里我们可以转移到更高级的用例。</p><h1 id="46c6" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">2.neo.mjs是什么？</h1><p id="84b1" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">如果您已经熟悉该框架，请跳到第3步。</p><p id="c448" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://github.com/neomjs/neo" rel="noopener ugc nofollow" target="_blank"> neo.mjs </a>是一个麻省理工学院许可的开源项目，它使你能够构建多线程前端，而无需关心工人设置或通信层。</p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi mg"><img src="../Images/4358ba77f4bcdfe7597627edacb5f735.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*yavSy5X_b-eY_0Ei.png"/></div></div></figure><p id="d2f9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一个扩展的ES8+类配置系统帮助你在专业水平上创建Javascript驱动的UI代码。</p><p id="32d2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一个独特的方面是，开发模式直接在浏览器中运行，没有任何构建或转换。对于调试来说，这可以节省大量时间。</p><p id="809a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">只需更改一个顶层框架配置，就可以切换到SharedWorkers模式。这种模式使你能够创建下一代用户界面，否则这是很难实现的。</p><figure class="mh mi mj mk gt ml"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="b2d7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">阅读这篇文章不需要任何网络工作者的知识。</p><p id="ee9a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请记住，所有组件实例都存在于应用程序工作者领域中。这意味着视图模型也存在于这个范围内。</p><h1 id="7675" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">3.不使用视图模型的简单演示应用程序</h1><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi mu"><img src="../Images/01bb8dc83a86ddbe697bb3788934c892.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*-pxyttRR99rnpEKg.png"/></div></div></figure><p id="2433" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们正在创建一个包含面板的视口(MainContainer)。</p><p id="0ae8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们希望将两个文本字段都连接到匹配的按钮，这样，更改输入值将会更新按钮文本。单击按钮应该会将匹配的字段值重置为其原始值。</p><figure class="mh mi mj mk gt ml"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="d21e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://neomjs.github.io/pages/node_modules/neo.mjs/dist/production/examples/model/inlineNoModel/index.html" rel="noopener ugc nofollow" target="_blank">在线演示(分销/制作)</a></p><p id="0fa4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个演示应用的架构非常简单:</p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi mv"><img src="../Images/64681c814a61647ec65c8aec3b2c7b52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*fiIP0tzMd1BUK-yn.png"/></div></div></figure><p id="d54d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们看一下主容器代码:</p><figure class="mh mi mj mk gt ml"><div class="bz fp l di"><div class="mw mt l"/></div></figure><p id="04ef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">视图定义不包含任何应有的业务逻辑。</p><p id="3ef3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">基于JSON的项目定义遵循架构图。</p><p id="9757" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您将注意到基于字符串的按钮处理程序和监听器→它们将被映射到我们的视图控制器中，期望在那里(或者在父视图控制器中)找到具有相同名称的真实方法。</p><p id="e0b2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还使用了4个引用，这使得访问特定项目更加容易。有几种不同的方法可以访问子项，例如使用<a class="ae kl" href="https://github.com/neomjs/neo/blob/dev/src/manager/Component.mjs" rel="noopener ugc nofollow" target="_blank">管理器。组件</a>。</p><p id="e4ff" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">主容器控制器:</p><figure class="mh mi mj mk gt ml"><div class="bz fp l di"><div class="mw mt l"/></div></figure><p id="f371" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们使用配置来存储我们的两个数据属性button1Text_和button2Text_。使用尾部下划线，配置系统将使我们能够选择性地使用beforeGetName()、beforeSetName()和afterSetName()。“名称”等于配置名称的大写版本。</p><p id="dbba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<code class="fe mx my mz na b">afterSetButton1Text()</code>中，我们正在更新button1引用的文本配置以及textfield1引用的值配置。</p><p id="2b98" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mx my mz na b">afterSetButton2Text()</code>对button2和textfield2执行相同的操作。</p><p id="54b6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们忽略第一个初始调用(oldValue === undefined)，因为在这个时间点，视图控制器还没有解析视图配置。相反，我们是在<code class="fe mx my mz na b">onViewParsed()</code>方法内部这样做的。</p><p id="b808" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可能想知道我们是否应该在<code class="fe mx my mz na b">updateReferences()</code>中添加更多检查，例如，如果您在textfield1中键入，该方法不仅会调整button1文本配置，还会将textfield1本身的值config设置为相同的值。这很好！如果设置了相同的值，就不会有变化事件→相关的<code class="fe mx my mz na b">afterSet()</code>方法不会被触发→不检查增量更新甚至DOM操作。</p><p id="b925" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mx my mz na b">onButtonClick1()</code>将把我们的<code class="fe mx my mz na b">button1Text</code>控制器配置设置为初始值，<code class="fe mx my mz na b">onTextField1Change()</code>将把控制器配置设置为新的输入值。“2”也是如此。</p><p id="7d8c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您也可以将这两个数据属性添加到视图类(MainContainer)中。这对于本例来说没有意义，但这是创建新组件的一般方法(扩展所需的基类并向其中添加新配置、新方法和/或覆盖)。</p><p id="213d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">希望到现在一切都清楚了。第一个演示应用程序非常简单。如果没有，请提问！</p><h1 id="afbd" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">4.使用视图模型的简单演示应用程序</h1><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi mv"><img src="../Images/4d7a209e1651fbd495b7668628609db5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*-5xV94z5jFpjGrkY.png"/></div></div></figure><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi nb"><img src="../Images/570d7d424b43a2db74e6d5942e218356.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*hRQSGcK1vlnQt5En.png"/></div></div></figure><p id="5f80" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">显然，我们保持相同的视图架构。<br/>嗯，我增加了一个按钮来记录模型实例:)<br/>(图中没有，因为不相关)</p><p id="80c1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">唯一的区别是我们添加了新的模型。组合中的组件类别:</p><figure class="mh mi mj mk gt ml"><div class="bz fp l di"><div class="mw mt l"/></div></figure><p id="5174" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们正在扩展模型。组件，并将我们的2个数据属性添加到一个数据配置中，而不是将每个属性都添加为顶级配置。这对于支持更深层次的嵌套数据结构非常重要。</p><p id="db51" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当然，您也可以在这里添加新的方法或覆盖。neo.mjs 的一个美妙之处在于你可以扩展和改变几乎所有的东西。</p><p id="bd15" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下一个主容器:</p><figure class="mh mi mj mk gt ml"><div class="bz fp l di"><div class="mw mt l"/></div></figure><p id="b7b0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们正在导入新的模型类(第2行),并将导入的模块放入模型配置中。</p><p id="548d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在视图定义中，您会注意到4个引用都不见了。我们不再需要它们了。</p><p id="075d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">相反，我们使用4个绑定对象。</p><pre class="mh mi mj mk gt nc na nd ne aw nf bi"><span id="b18d" class="ng lb iq na b gy nh ni l nj nk">bind: {<br/>    text: data =&gt; data.button1Text<br/>},</span></pre><p id="dc40" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">绑定对象中使用的键应该匹配类配置名。</p><p id="60bf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的视图模型将在组件生命周期的早期自动添加绑定的配置键值。这发生在组件<code class="fe mx my mz na b">constructor</code>完成之前。</p><p id="4a29" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的视图模型还会在每次相关数据属性改变时更新组件配置。</p><p id="c811" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当然，您可以为每个组件添加多个绑定。</p><p id="4e51" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">绑定值可以是箭头函数(可读性更好)或实函数(为了获得稍好的性能，因为函数将被绑定到最近的视图模型范围)。</p><p id="4848" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">视图模型将解析使用的数据属性，并且仅在<strong class="jp ir">使用的</strong>变量之一发生变化时触发更新。<strong class="jp ir">重新渲染调用</strong>(检查虚拟dom web worker内部的增量更新)<strong class="jp ir">的数量最少。</strong></p><p id="5edc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">主容器控制器:</p><figure class="mh mi mj mk gt ml"><div class="bz fp l di"><div class="mw mt l"/></div></figure><p id="05a4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您会注意到控制器内部的逻辑变得更简单了。</p><p id="34f1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2个数据属性配置消失。</p><p id="b4e4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们使用2个按钮处理程序和2个textfield更改监听器来简单地更改视图模型数据属性。</p><p id="5f91" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mx my mz na b">controller.getModel()</code>将返回连接组件父树中最近的模型，因此不是每个组件都必须使用自己的模型。</p><p id="8468" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我使用两种不同的方法来改变数据属性，只是为了演示的目的。</p><pre class="mh mi mj mk gt nc na nd ne aw nf bi"><span id="c76d" class="ng lb iq na b gy nh ni l nj nk">this.getModel().data['button1Text'] = value;</span></pre><p id="e439" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">或者</p><pre class="mh mi mj mk gt nc na nd ne aw nf bi"><span id="a580" class="ng lb iq na b gy nh ni l nj nk">this.getModel().data.button1Text = value;</span></pre><p id="55dd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您确定数据属性确实存在于父树链中最近的模型上，您可以简单地为它分配一个新值。</p><p id="fefa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个“任务”触发了引擎盖下的setter。</p><pre class="mh mi mj mk gt nc na nd ne aw nf bi"><span id="4cc8" class="ng lb iq na b gy nh ni l nj nk">this.getModel().setData({<br/>    button2Text: value<br/>});</span></pre><p id="a79f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mx my mz na b">setData()</code>是做这件事的更好方法。您可以一次更改多个数据属性，该方法将在组件视图模型的父链中搜索每个键。如果没有为给定的键找到匹配，新的数据属性将在最接近的模型级别上注册。</p><p id="b659" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">到目前为止我们学到了什么:</strong></p><ol class=""><li id="3b85" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk kr ks kt ku bi translated">使用视图模型是可选的，没有它们也可以创建相同的业务逻辑。</li><li id="8920" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">视图模型可以减少代码量:<br/>使用绑定，你只需要更新vm数据属性</li></ol><h1 id="095b" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">5.使用内嵌视图模型的简单演示应用程序</h1><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi nl"><img src="../Images/0be622b7aa6f644825c3d27c60e15c36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ZU7fDR-5dwdiaEM5.png"/></div></div></figure><p id="c68d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">主容器:</p><figure class="mh mi mj mk gt ml"><div class="bz fp l di"><div class="mw mt l"/></div></figure><p id="9c25" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们只想在视图模型上设置数据属性，我们不需要扩展这个类。</p><p id="fe73" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">相反，我们可以将一个对象分配给组件模型配置。</p><p id="5b7f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mx my mz na b">module: ComponentModel</code>在这里是可选的，但是模型导入(第1行)不是。因为视图模型是可选的，所以框架不会自动导入它们的基类。但是，您只需要导入模型。组件基类一次(对于最“顶层”的视图)。</p><h1 id="7785" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">6.使用嵌套数据的简单演示应用程序</h1><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi mv"><img src="../Images/d4d8b4fda4bb978469d3c5ecb3b3bfc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*sAsZADVqVxd9OuXS.png"/></div></div></figure><p id="734e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">主容器:</p><figure class="mh mi mj mk gt ml"><div class="bz fp l di"><div class="mw mt l"/></div></figure><p id="3963" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">【旁注】我在这里用的是<a class="ae kl" href="https://www.linkedin.com/in/nils-dehl/" rel="noopener ugc nofollow" target="_blank"> Nils </a>的名字，我希望这样没问题:)Nils是Ext JS的专家，也是早期<a class="ae kl" href="https://github.com/neomjs/neo" rel="noopener ugc nofollow" target="_blank"> neo.mjs </a>的贡献者之一。再次感谢你对现实世界演示应用的帮助！</p><p id="4094" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我跳过了模型对象定义中的<code class="fe mx my mz na b">module: ComponentModel</code>。</p><p id="80cd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们在这里嵌套了3层数据。</p><pre class="mh mi mj mk gt nc na nd ne aw nf bi"><span id="52a0" class="ng lb iq na b gy nh ni l nj nk">bind: {<br/>    text: data =&gt; data.user.details.firstname<br/>}</span></pre><figure class="mh mi mj mk gt ml"><div class="bz fp l di"><div class="mw mt l"/></div></figure><p id="5273" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">只有两个数据属性设置发生了变化。</p><p id="ea10" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您仍然可以简单地将数据属性叶更改为赋值。<br/>(甚至通过<code class="fe mx my mz na b">Object.defineProperty()</code> → get() &amp; set())创建嵌套结构)</p><p id="5e20" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<code class="fe mx my mz na b">setData()</code>方法中使用基于字符串的数据路径很重要。值可能是对象，在这种情况下，我们无法知道属性的结束和值的开始。</p><h1 id="b49b" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">7.高级演示应用</h1><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi nm"><img src="../Images/619910e2e6ca69808e105cadb85e2316.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*WE8UQ6P-P2FIuS-1.png"/></div></div></figure><figure class="mh mi mj mk gt ml"><div class="bz fp l di"><div class="nn mt l"/></div></figure><p id="3dce" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在视频的最后，您可以看到您的应用程序代码是在开发模式中“按原样”(无构建)使用的，并且在应用程序工作器中运行。</p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi no"><img src="../Images/38197a42b4775e1c5f4171d2b6ed320f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*CJ50M4njCvwnEVwa.png"/></div></div></figure><p id="e760" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">高级演示体系结构是之前演示的扩展版本。这次我们使用两个视图模型。</p><p id="1947" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">body容器使用垂直框(vbox)布局，因为我们现在也想显示每个按钮格式化程序，所以我们将每个“行”包装到一个容器中(包含一个textfield和一个displayfield的水平框(hbox)布局)。</p><p id="3cb0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我对一些项目使用了绿色→当你点击“添加第三个按钮&amp;文本字段”按钮时，这些项目会被动态添加。</p><p id="4c7a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">主容器:</p><figure class="mh mi mj mk gt ml"><div class="bz fp l di"><div class="mw mt l"/></div></figure><p id="e8ef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里真正重要的部分是顶层视图模型包含数据属性<code class="fe mx my mz na b">button<strong class="jp ir">1</strong>Text</code> &amp; <code class="fe mx my mz na b">button<strong class="jp ir">3</strong>Text</code>，而面板(子)视图模型包含<code class="fe mx my mz na b">button<strong class="jp ir">2</strong>Text</code>。</p><p id="c290" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">查看前两个按钮格式化程序:</p><pre class="mh mi mj mk gt nc na nd ne aw nf bi"><span id="3baa" class="ng lb iq na b gy nh ni l nj nk">text: data =&gt; `Hello ${data.button2Text} ${1+2} ${data.button1Text + data.button2Text}`</span></pre><p id="6ef9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">button1格式化程序包含主容器模型<code class="fe mx my mz na b">button1Text</code>数据属性以及面板模型<code class="fe mx my mz na b">button2Text</code>数据属性。</p><p id="e604" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">显然，无论模型级别如何，我们都希望文本在这两个属性中的任何一个发生变化时都会更新。这正是所发生的:)</p><pre class="mh mi mj mk gt nc na nd ne aw nf bi"><span id="1c54" class="ng lb iq na b gy nh ni l nj nk">text: data =&gt; data.button2Text.toLowerCase()</span></pre><p id="c858" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以对每个数据属性调用函数。数据属性解析器足够智能，可以判断出您的绑定属性名称是“data.button2Text”。</p><p id="6541" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于button2Text是一个字符串，所以使用<code class="fe mx my mz na b">.toLowerCase()</code>就可以了。</p><p id="40c2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">主容器控制器:</p><figure class="mh mi mj mk gt ml"><div class="bz fp l di"><div class="mw mt l"/></div></figure><p id="968f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在第一个方法<code class="fe mx my mz na b">onAddButtonTextfieldButtonClick()</code>中，我们在面板主体中添加了一个新的“row”容器。视图定义中的<code class="fe mx my mz na b">itemDefaults</code>配置仍在使用，所以我们不需要指定模块或布局。</p><p id="d9d4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">同时，我们还在标题工具栏中添加了button3。</p><p id="8100" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里的关键部分是，两个项目定义都包含绑定配置，它们应该以与我们的初始视图定义相同的方式工作。</p><p id="5cad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好消息是:动态添加绑定也非常好:)</p><p id="5637" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">快速了解3种数据属性更新方法:</p><pre class="mh mi mj mk gt nc na nd ne aw nf bi"><span id="9d6e" class="ng lb iq na b gy nh ni l nj nk">updateButton2Text(value) {<br/>    this.getReference('panel').getModel().setData({<br/>        button2Text: value<br/>    });<br/>}</span></pre><p id="1c50" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">访问面板(子)模型是最好的方法。另外两种方法只是为了测试不同的方式。</p><pre class="mh mi mj mk gt nc na nd ne aw nf bi"><span id="a460" class="ng lb iq na b gy nh ni l nj nk">updateButton3Text(value) {<br/>    this.getModel().data['button3Text'] = value;<br/>}</span></pre><p id="b2ab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的MainContainerController连接到我们的MainContainer视图。调用<code class="fe mx my mz na b">this.getModel()</code>将访问顶层视图模型。由于<code class="fe mx my mz na b">button1Text</code>和<code class="fe mx my mz na b">button2Text</code>是在这个层次上定义的，所以它工作得很好。</p><pre class="mh mi mj mk gt nc na nd ne aw nf bi"><span id="19cb" class="ng lb iq na b gy nh ni l nj nk">updateButton1Text(value) {<br/>    this.getReference('panel').getModel().setData('button1Text', value);<br/>}</span></pre><p id="ca06" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个调用基本上是一个测试:我们在面板(子)模型上调用<code class="fe mx my mz na b">setData()</code>，知道<code class="fe mx my mz na b">button1Text</code>数据属性确实存在于父级。工作正常。</p><h1 id="9a26" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">8.对话框应用程序:访问父树之外的视图模型</h1><figure class="mh mi mj mk gt ml"><div class="bz fp l di"><div class="ms mt l"/></div></figure><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div class="gh gi np"><img src="../Images/937dca2a55da088811c4eae7addb53df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1198/format:webp/1*j10VBcQ5MXSQmhi9dB09qA.png"/></div></figure><p id="50c3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个新例子很特别，绝对值得仔细研究。</p><p id="31d3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">MainContainer和EditUserDialog都是document.body的直接子节点，它们之间没有父子关系。</p><p id="c7ea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当点击“编辑用户”按钮时，我们也延迟加载编辑用户对话框。</p><p id="3e90" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">主容器:</p><figure class="mh mi mj mk gt ml"><div class="bz fp l di"><div class="mw mt l"/></div></figure><p id="f439" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">非常简单:我们定义了一个内嵌视图模型，其中包含嵌套数据，并在左上角的标签中显示数据。</p><p id="87b7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">编辑用户对话框:</p><figure class="mh mi mj mk gt ml"><div class="bz fp l di"><div class="mw mt l"/></div></figure><p id="6c75" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对话框的类定义根本不包含视图模型。然而，我们对包含MainContainer模型的数据属性的文本字段使用绑定值。</p><p id="9275" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">编辑用户对话框控制器:</p><figure class="mh mi mj mk gt ml"><div class="bz fp l di"><div class="mw mt l"/></div></figure><p id="3cbc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对话框视图控制器监听TextField更改事件，并将调整最接近的模型中的数据。</p><p id="e8b8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">主容器控制器:</p><figure class="mh mi mj mk gt ml"><div class="bz fp l di"><div class="mw mt l"/></div></figure><p id="72b1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是真正的交易:当点击“编辑用户”按钮时，我们检查是否已经创建了一个对话框。如果没有，我们使用动态导入来延迟加载文件(这也将延迟加载对话框文件中的静态导入)。</p><p id="74c5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们为对话框实例(！idspnonenote)分配一个空模型。)并使用父配置将其映射到我们的主容器模型。</p><p id="5c60" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就是这个:)</p><h1 id="34a4" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">9.在线演示</h1><p id="3add" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated"><strong class="jp ir">发行/生产:</strong> <br/>基于Webpack的构建(缩小)。在所有主流浏览器中运行。</p><p id="52dc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://neomjs.github.io/pages/node_modules/neo.mjs/dist/production/examples/model/advanced/index.html" rel="noopener ugc nofollow" target="_blank">示例/模型/高级/ </a></p><p id="f38f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://neomjs.github.io/pages/node_modules/neo.mjs/dist/production/examples/model/dialog/index.html" rel="noopener ugc nofollow" target="_blank">例子/模型/对话框/ </a></p><p id="f65e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://neomjs.github.io/pages/node_modules/neo.mjs/dist/production/examples/model/extendedClass/index.html" rel="noopener ugc nofollow" target="_blank">示例/模型/扩展类/ </a></p><p id="9da5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://neomjs.github.io/pages/node_modules/neo.mjs/dist/production/examples/model/inline/index.html" rel="noopener ugc nofollow" target="_blank">示例/模型/内嵌/ </a></p><p id="4298" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://neomjs.github.io/pages/node_modules/neo.mjs/dist/production/examples/model/inlineNoModel/index.html" rel="noopener ugc nofollow" target="_blank">示例/模型/inlineNoModel/ </a></p><p id="fa62" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://neomjs.github.io/pages/node_modules/neo.mjs/dist/production/examples/model/nestedData/index.html" rel="noopener ugc nofollow" target="_blank">示例/模型/嵌套数据/ </a></p><p id="8b6f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">开发模式:<br/> </strong>直接在你的浏览器内部使用真实代码，不需要任何编译或编译。这种模式仅限于Chromium (Chrome &amp; Edge)，因为其他浏览器还不支持worker范围内的JS模块。</p><p id="3f60" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://neomjs.github.io/pages/node_modules/neo.mjs/examples/model/advanced/index.html" rel="noopener ugc nofollow" target="_blank">示例/模型/高级/ </a></p><p id="c82c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://neomjs.github.io/pages/node_modules/neo.mjs/examples/model/dialog/index.html" rel="noopener ugc nofollow" target="_blank">示例/模型/对话框/ </a></p><p id="859c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://neomjs.github.io/pages/node_modules/neo.mjs/examples/model/extendedClass/index.html" rel="noopener ugc nofollow" target="_blank">示例/模型/扩展类/ </a></p><p id="945b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://neomjs.github.io/pages/node_modules/neo.mjs/examples/model/inline/index.html" rel="noopener ugc nofollow" target="_blank">例子/模型/内联/ </a></p><p id="2798" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://neomjs.github.io/pages/node_modules/neo.mjs/examples/model/inlineNoModel/index.html" rel="noopener ugc nofollow" target="_blank">示例/模型/inlineNoModel/ </a></p><p id="e6e2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://neomjs.github.io/pages/node_modules/neo.mjs/examples/model/nestedData/index.html" rel="noopener ugc nofollow" target="_blank">范例/模型/嵌套数据/ </a></p><p id="0d91" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以将模型实例动态登录到您的控制台<br/>(左下方的按钮):</p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/e1e149806195dcdfa4a4ced86e4c419e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1208/format:webp/1*QAMi6WG_X2L-mo1wTylSfA.png"/></div></figure><p id="2841" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您的重点应该放在绑定和数据配置上。</p><p id="3a82" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">[提示]控制台日志在开发模式中更有意义<br/> →非精简类名。</p><h1 id="118b" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">10.源代码位置</h1><p id="6152" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">你可以在这里找到所有例子的源代码:<br/> <a class="ae kl" href="https://github.com/neomjs/neo/tree/dev/examples/model" rel="noopener ugc nofollow" target="_blank">例子/模型</a></p><p id="c208" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将讨论模型的内部逻辑。本文第2部分中的组件。到目前为止，它“只是”586行代码，我尽力保持它非常干净和结构化。</p><p id="4462" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你是一名Javascript专家，并且现在很想深入研究一下:<br/><a class="ae kl" href="https://github.com/neomjs/neo/blob/dev/src/model/Component.mjs" rel="noopener ugc nofollow" target="_blank">src/model/component . mjs</a></p><h1 id="b80a" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">11.铊-溴</h1><p id="47f6" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">使用新的<a class="ae kl" href="https://github.com/neomjs/neo" rel="noopener ugc nofollow" target="_blank"> neo.mjs </a>视图模型可以做的事情的可能性是惊人的！您不仅可以显著减少您的锅炉板应用程序代码，而且还可以轻松地修改您的视图相关状态。</p><p id="5d8e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">总结一下:</p><ol class=""><li id="ef7c" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk kr ks kt ku bi translated">使用视图模型是可选的，没有它们也可以创建相同的业务逻辑。</li><li id="528f" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">如果实际使用的数据属性之一发生了变化，视图模型只会将变化推送到绑定值。</li><li id="5d6f" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">视图模型可以减少代码量:<br/>使用绑定，你只需要更新vm数据属性。</li><li id="4a37" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">您可以动态地改变您的视图，绑定是持久的。</li><li id="eeb3" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">您可以动态地添加包含绑定的视图，即使它们没有自己的视图模型。</li><li id="ee52" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">不是每个视图都需要自己的视图模型，你总是可以通过调用<code class="fe mx my mz na b">myComponent.getModel()</code>来访问最近的父模型。</li><li id="0d14" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">我个人建议不要为应用程序视图结构中的“叶节点”注册模型(例如按钮、表单字段或其他简单的组件)。</li><li id="a842" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">我还建议在尽可能低的模型级别应用状态相关数据。</li></ol><h1 id="e8e7" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">12.感谢您的反馈！</h1><p id="b482" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">我很期待看到像您这样有才华的开发人员使用这项新技术可以实现什么。</p><p id="cf66" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">万一你做了什么好东西或者有什么问题，<br/>一定要给我一个ping！</p><p id="aa46" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">【<strong class="jp ir">编辑</strong>快速更新:part 2现已上线:</p><div class="nr ns gp gr nt nu"><a href="https://tobiasuhlig.medium.com/enhance-your-frontend-state-management-with-view-models-part2-5a9384bd863c" rel="noopener follow" target="_blank"><div class="nv ab fo"><div class="nw ab nx cl cj ny"><h2 class="bd ir gy z fp nz fr fs oa fu fw ip bi translated">使用视图模型增强您的前端状态管理—第2部分</h2><div class="ob l"><h3 class="bd b gy z fp nz fr fs oa fu fw dk translated">设计目标&amp;谈基于模板文字的视图模型实现。</h3></div><div class="oc l"><p class="bd b dl z fp nz fr fs oa fu fw dk translated">tobiasuhlig.medium.com</p></div></div><div class="od l"><div class="oe l of og oh od oi mq nu"/></div></div></a></div><p id="c8ab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">明天(2021年4月23日)，neo.mjs第2版发布公告将会发布:)</p><p id="cb27" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最诚挚的问候&amp;快乐编码，<br/>托比亚斯</p></div></div>    
</body>
</html>