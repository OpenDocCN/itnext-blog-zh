<html>
<head>
<title>Don’t use inline functions or bind() in React ref callbacks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">不要在React ref回调中使用内联函数或bind()</h1>
<blockquote>原文：<a href="https://itnext.io/dont-use-inline-functions-or-bind-in-react-ref-callbacks-5559e4342ead?source=collection_archive---------1-----------------------#2018-03-16">https://itnext.io/dont-use-inline-functions-or-bind-in-react-ref-callbacks-5559e4342ead?source=collection_archive---------1-----------------------#2018-03-16</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><figure class="gm go jp jq jr js gi gj paragraph-image"><div role="button" tabindex="0" class="jt ju di jv bf jw"><div class="gi gj jo"><img src="../Images/ea1c73088ca5f639dfd7a5f279feb2b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_-kUYJJnPmIDRBVyNIgRFQ.png"/></div></div><figcaption class="jz ka gk gi gj kb kc bd b be z dk translated">rawpixel.com在<a class="ae kd" href="https://unsplash.com/search/photos/polaroid?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上<a class="ae kd" href="https://unsplash.com/photos/2CilBNsOC3Q?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">拍照</a></figcaption></figure><p id="297c" class="pw-post-body-paragraph ke kf ir kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">React使得<em class="lc">几乎</em>永远不用担心底层的HTML/JavaScript文档对象模型。React的保留模式呈现允许你以声明的方式定义网页上的一切，包括交互和呈现状态。太棒了！</p><p id="0249" class="pw-post-body-paragraph ke kf ir kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">但是每隔一段时间，你都需要回到DOM来管理状态<a class="ae kd" href="https://xkcd.com/149/" rel="noopener ugc nofollow" target="_blank">命令</a>。您可能需要选择页面上的一些文本，或者管理表单元素的焦点。对于这些情况，React提供了<a class="ae kd" href="https://reactjs.org/docs/refs-and-the-dom.html" rel="noopener ugc nofollow" target="_blank"> ref回调</a>。</p><p id="cbae" class="pw-post-body-paragraph ke kf ir kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">下面是一个非常简单的React组件类的例子，它使用了ref回调特性。</p><pre class="ld le lf lg gu lh li lj lk aw ll bi"><span id="3aff" class="lm ln ir li b gz lo lp l lq lr">Import { Component } from ‘react’;</span><span id="058b" class="lm ln ir li b gz ls lp l lq lr">class ExampleComponent extends Component {<br/>  setFocus() {<br/>    this.textInput.focus();<br/>  }</span><span id="966a" class="lm ln ir li b gz ls lp l lq lr">  render() {<br/>    return (<br/>      &lt;input type=”text”<br/>             ref={(input) =&gt; { this.textInput = input; }} /&gt;<br/>    );<br/>  }<br/>}</span></pre><p id="b699" class="pw-post-body-paragraph ke kf ir kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">这个例子是这样工作的:当<code class="fe lt lu lv li b">&lt;input&gt;</code>元素被呈现时，React调用在<code class="fe lt lu lv li b">ref</code>属性中定义的函数，将<code class="fe lt lu lv li b">&lt;input&gt;</code>元素作为参数传递给该函数。</p><p id="dd3b" class="pw-post-body-paragraph ke kf ir kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">这与你在React官方文档和大多数关于React引用的教程中找到的例子非常相似。然而，如果你想做任何更复杂的事情，而不仅仅是保存对元素/组件的引用，<strong class="kg is">你不应该使用这种模式</strong>。</p><p id="9a4c" class="pw-post-body-paragraph ke kf ir kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">我们使用<a class="ae kd" href="https://www.daily.co/" rel="noopener ugc nofollow" target="_blank">Daily.co</a>代码库中的引用来管理媒体和画布元素。我们经常需要在第一次安装一个元素时做一些事情。大概是这样的:</p><pre class="ld le lf lg gu lh li lj lk aw ll bi"><span id="508d" class="lm ln ir li b gz lo lp l lq lr">class CanvasWithAttitude extends Component {<br/>  setupToDraw(canvas) {<br/>    // ...<br/>  }</span><span id="4d2a" class="lm ln ir li b gz ls lp l lq lr">render() {<br/>    return (<br/>      &lt;canvas ref={(canvas) =&gt; { this.setupToDraw(canvas); }} /&gt;<br/>    );<br/>  }<br/>}</span></pre><p id="044c" class="pw-post-body-paragraph ke kf ir kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">除了我们<strong class="kg is">不做那个</strong>，因为用上面的代码，每次渲染时<code class="fe lt lu lv li b">setupToDraw()</code>函数实际上会被调用<strong class="kg is">两次。这绝对不是我们想要的。</strong></p><p id="88dd" class="pw-post-body-paragraph ke kf ir kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">每次组件呈现时，React都需要重新创建任何被定义为元素属性的内联或绑定函数。为了清除旧的引用，它首先用一个<code class="fe lt lu lv li b">null</code>参数调用内联或绑定函数。然后，它使用元素/组件参数再次调用该函数。(关于官方React文档中对此的解释，向下滚动到<a class="ae kd" href="https://reactjs.org/docs/refs-and-the-dom.html" rel="noopener ugc nofollow" target="_blank"> Refs和DOM页面</a>的最底部。)</p><p id="758e" class="pw-post-body-paragraph ke kf ir kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">请注意，我写的是“内联或绑定”，所以这也是不对的:</p><pre class="ld le lf lg gu lh li lj lk aw ll bi"><span id="7ff5" class="lm ln ir li b gz lo lp l lq lr">&lt;canvas ref={ this.setupToDraw.bind(this); } /&gt;</span></pre><p id="ec29" class="pw-post-body-paragraph ke kf ir kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">我们的目标是当组件挂载时，ref回调被调用一次。</p><p id="6d86" class="pw-post-body-paragraph ke kf ir kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">一种解决方法是使用<a class="ae kd" href="https://babeljs.io/docs/plugins/transform-class-properties/" rel="noopener ugc nofollow" target="_blank"> ES7类属性语法</a>来定义函数。</p><pre class="ld le lf lg gu lh li lj lk aw ll bi"><span id="6f14" class="lm ln ir li b gz lo lp l lq lr">class CanvasWithAttitude extends Component {<br/>  setupToDraw = (canvas) =&gt; {<br/>    // ...<br/>  }</span><span id="0825" class="lm ln ir li b gz ls lp l lq lr">  render() {<br/>    return (<br/>      &lt;canvas ref={ this.setupToDraw } /&gt;<br/>    );<br/>  }<br/>}</span></pre><p id="0a44" class="pw-post-body-paragraph ke kf ir kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">这将为每个<code class="fe lt lu lv li b">CanvasWithAttitude</code>实例创建一个新的<code class="fe lt lu lv li b">setupToDraw()</code>函数，并将该函数赋给对象的<code class="fe lt lu lv li b">setupToDraw</code>属性。实际上，我们已经将内联函数定义移出了渲染函数，并让JavaScript transpiler在实例创建时不可见地为我们完成了这项工作。:-)</p><p id="77dd" class="pw-post-body-paragraph ke kf ir kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">我们的许多类中都有这样的代码，但我不喜欢这种模式。JavaScript对象模型中有很多极端情况，我发现很容易忘记上面的代码做了一些不明显的事情。首先，为该类的每个新实例创建了<code class="fe lt lu lv li b">setupToDraw()</code>函数，其次，该函数不作为类原型的一部分存在(例如，因此它不会被继承)。</p><p id="8b13" class="pw-post-body-paragraph ke kf ir kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">我更喜欢这样写这个模式。</p><pre class="ld le lf lg gu lh li lj lk aw ll bi"><span id="e5bb" class="lm ln ir li b gz lo lp l lq lr">class CanvasWithAttitude extends Component {<br/>  constructor() {<br/>    super();<br/>    this.setupToDrawBound = this.setupToDraw.bind(this);<br/>  }</span><span id="8094" class="lm ln ir li b gz ls lp l lq lr">  setupToDraw(canvas) {<br/>    // ...<br/>  }</span><span id="f473" class="lm ln ir li b gz ls lp l lq lr">  render() {<br/>    return (<br/>      &lt;canvas ref={ this.setupToDrawBound } /&gt;<br/>    );<br/>  }<br/>}</span></pre><p id="e793" class="pw-post-body-paragraph ke kf ir kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">这里，<code class="fe lt lu lv li b">setupToDrawBound()</code>仍然是一个新函数，每次构造实例时都会创建一个，但是<code class="fe lt lu lv li b">setupToDraw()</code>是一个普通的成员函数，在扫描代码时很容易推断出<code class="fe lt lu lv li b">bind()</code>的用法。最后，<code class="fe lt lu lv li b">setupToDraw()</code>和<code class="fe lt lu lv li b">setupToDrawBound</code>都被任何扩展<code class="fe lt lu lv li b">CanvasWithAttitude</code>的类继承。</p><p id="6dea" class="pw-post-body-paragraph ke kf ir kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">我敢肯定，有其他的模式来做奇特的事情与反应参考。当一个组件被安装时，也有其他的方法来组织做一些事情。(例如，我们可以挂钩React <code class="fe lt lu lv li b">componentDidMount()</code>生命周期方法。)我很想听听其他React开发者的想法——尤其是有趣用例的例子！</p></div></div>    
</body>
</html>