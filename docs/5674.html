<html>
<head>
<title>Lazy loading for card layout items and tabs → neo.mjs v2.0.10</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">卡片布局项目和选项卡的惰性加载→ neo.mjs v2.0.10</h1>
<blockquote>原文：<a href="https://itnext.io/lazy-loading-for-card-layout-items-and-tabs-neo-mjs-v2-0-10-2bd1c16cd458?source=collection_archive---------2-----------------------#2021-04-29">https://itnext.io/lazy-loading-for-card-layout-items-and-tabs-neo-mjs-v2-0-10-2bd1c16cd458?source=collection_archive---------2-----------------------#2021-04-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="21e2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">虽然只呈现活动的卡片并有选择地从DOM中移除不活动的卡片同时保持它们的JS实例是不错的，但是在需要的时候延迟加载卡片的JS模块就更好了。</p><h1 id="8fd3" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">内容</h1><ol class=""><li id="ed41" class="lj lk iq jp b jq ll ju lm jy ln kc lo kg lp kk lq lr ls lt bi translated">介绍</li><li id="77c6" class="lj lk iq jp b jq lu ju lv jy lw kc lx kg ly kk lq lr ls lt bi translated">问题是</li><li id="eb6b" class="lj lk iq jp b jq lu ju lv jy lw kc lx kg ly kk lq lr ls lt bi translated">解决方案</li><li id="32a9" class="lj lk iq jp b jq lu ju lv jy lw kc lx kg ly kk lq lr ls lt bi translated">它是如何在引擎盖下工作的？</li><li id="d1ba" class="lj lk iq jp b jq lu ju lv jy lw kc lx kg ly kk lq lr ls lt bi translated">让我们看看它的实际效果吧！</li><li id="df10" class="lj lk iq jp b jq lu ju lv jy lw kc lx kg ly kk lq lr ls lt bi translated">在线演示</li><li id="6e54" class="lj lk iq jp b jq lu ju lv jy lw kc lx kg ly kk lq lr ls lt bi translated">接下来是什么？</li><li id="725d" class="lj lk iq jp b jq lu ju lv jy lw kc lx kg ly kk lq lr ls lt bi translated">最后的想法</li></ol><h1 id="3fc5" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">1.介绍</h1><p id="3ffb" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">您现在很可能已经见过Covid Dashboard演示应用程序:</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi mc"><img src="../Images/30a745037ce7ee11795dfbca536ce29c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QCGN9HYaL9KiN_DLbqdqzA.png"/></div></div></figure><p id="2750" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该应用程序在应用程序<a class="ae mo" href="https://developer.mozilla.org/en-US/docs/Web/API/Worker" rel="noopener ugc nofollow" target="_blank">工人</a>内部运行。所有组件都在那里。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/0e4ba63a201cb3b9981e28f4f76982e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1366/format:webp/1*mws86vEA-33bd9hVRNRmwA.png"/></div></figure><p id="b722" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，应用程序工作人员是主要参与者:</p><div class="mq mr gp gr ms mt"><a href="https://surma.dev/things/actormodel/" rel="noopener  ugc nofollow" target="_blank"><div class="mu ab fo"><div class="mv ab mw cl cj mx"><h2 class="bd ir gy z fp my fr fs mz fu fw ip bi translated">“一名演员、一名模特和一名建筑师走上网络……”-苏尔马·德夫</h2><div class="na l"><h3 class="bd b gy z fp my fr fs mz fu fw dk translated">旧的都是新的。让我们从70年代拿一个并发模型，在2017年应用到web上。为什么？嗯…</h3></div><div class="nb l"><p class="bd b dl z fp my fr fs mz fu fw dk translated">surma.dev</p></div></div><div class="nc l"><div class="nd l ne nf ng nc nh mm mt"/></div></div></a></div><h1 id="d63d" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">2.问题是</h1><p id="dea2" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">这个应用的主要选项卡包含大量内容，因此根据需要为每个选项卡延迟加载相关的JS模块可以加快初始渲染。</p><p id="8a16" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">虽然我们能够在视图控制器(不同的演示应用程序)中轻松地动态导入(延迟加载)JS模块:</p><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="b6e3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对卡片布局项目或标签做同样的事情实际上很棘手。</p><p id="7f21" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们来看看旧版本的Covid Dashboard MainContainer:</p><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="0414" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们在顶部有相当多的静态导入，它们被分配给每个选项卡的模块配置。</p><p id="4bfa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以前可以实现卡片的延迟加载，但这需要为每个标签添加一个虚拟组件，然后为您的<code class="fe nk nl nm nn b">tab.Container</code>添加一个<code class="fe nk nl nm nn b">activeIndexChange</code>监听器，并检查视图控制器内部被激活的标签是否是第一次被激活。如果是这样，延迟加载模块并替换组件。</p><p id="00cc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">是的…不太方便，所以需要一个通用的解决方案。</p><h1 id="7801" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">3.解决方案</h1><p id="1544" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">让我们来看看<strong class="jp ir">新</strong>版本的Covid Dashboard MainContainer:</p><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="63b2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每个选项卡顶部的静态导入都消失了。</p><p id="3038" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">而不是直接分配一个模块</p><pre class="md me mf mg gt no nn np nq aw nr bi"><span id="0a0a" class="ns km iq nn b gy nt nu l nv nw">module: TableContainer</span></pre><p id="0c11" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们现在可以选择为模块配置使用基于函数的值。</p><pre class="md me mf mg gt no nn np nq aw nr bi"><span id="ec10" class="ns km iq nn b gy nt nu l nv nw">module: () =&gt; import('./TableContainer.mjs')</span></pre><p id="f2fd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可能想知道为什么我们存储整个导入语句，而不仅仅是路径。这是为了给<a class="ae mo" href="https://github.com/webpack/webpack" rel="noopener ugc nofollow" target="_blank"> webpack </a>一个公平的机会来计算出所需的分割块。</p><p id="a960" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们现在可以使用<code class="fe nk nl nm nn b">activeIndex: null</code>最初不渲染或延迟加载任何标签页主体。</p><h1 id="3d83" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">4.它是如何在引擎盖下工作的？</h1><p id="70c0" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">大部分逻辑应用于<a class="ae mo" href="https://github.com/neomjs/neo/blob/dev/src/layout/Card.mjs" rel="noopener ugc nofollow" target="_blank">布局。卡片</a>:</p><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="1b47" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">方法变成了<code class="fe nk nl nm nn b">async</code>，所以我们可以使用:</p><pre class="md me mf mg gt no nn np nq aw nr bi"><span id="677a" class="ns km iq nn b gy nt nu l nv nw">module = await module();</span></pre><p id="5e3e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于基于功能的模块配置。一旦模块被加载，我们就创建一个实例并把它放到布局所有者的<code class="fe nk nl nm nn b">items</code>数组和<code class="fe nk nl nm nn b">vdom</code>配置中。</p><p id="e499" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae mo" href="https://github.com/neomjs/neo/blob/dev/src/tab/Container.mjs" rel="noopener ugc nofollow" target="_blank">选项卡。集装箱</a>:</p><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="558c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这种方法现在也被<code class="fe nk nl nm nn b">async</code>采用。我们希望在触发<code class="fe nk nl nm nn b">activeIndexChange</code>事件之前，等到卡片布局完成，并且有一个潜在的延迟加载。</p><p id="2625" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了支持惰性加载<strong class="jp ir">初始</strong>活动选项卡(例如，在covid应用程序中，初始活动索引依赖于路线)，我们不再检查在方法开始时<code class="fe nk nl nm nn b">oldVaue !== undefined</code>是否存在。</p><p id="cc2e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">covid应用程序有一个边缘情况:当加载没有默认路线的应用程序时，主视图控制器现在会立即触发路线更改。在这个时间点上，<code class="fe nk nl nm nn b">cardContainer</code>还不存在。</p><p id="abdc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以我认为在这里应用一个<code class="fe nk nl nm nn b">constructed</code>监听器不会有什么坏处，因为你可能也会这么做。</p><p id="0e0a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae mo" href="https://github.com/neomjs/neo/blob/dev/src/container/Base.mjs" rel="noopener ugc nofollow" target="_blank">集装箱。底座</a>:</p><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="ac82" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里的线索是:</p><pre class="md me mf mg gt no nn np nq aw nr bi"><span id="c13f" class="ns km iq nn b gy nt nu l nv nw">if (!lazyLoadItem) {<br/>    item = <strong class="nn ir"><em class="nx">Neo</em></strong>[item.className ? 'create' : 'ntype'](item);<br/>} else {<br/>    item.vdom = {removeDom: true};<br/>}</span></pre><p id="aa89" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们延迟加载一个项目，我们添加一个只包含<code class="fe nk nl nm nn b">removeDom</code>标志的对象作为<code class="fe nk nl nm nn b">vdom</code>。</p><p id="1bc1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe nk nl nm nn b">removeDom</code>旗帜是<a class="ae mo" href="https://github.com/neomjs/neo" rel="noopener ugc nofollow" target="_blank"> neo.mjs </a>项目最强大的方面之一。我们可以动态地将它分配给虚拟dom中任何级别的任何节点。通过这样做，这个节点将从真正的DOM中删除，同时保持<code class="fe nk nl nm nn b">vdom</code>的内部结构不变。</p><p id="6e58" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于我们的<code class="fe nk nl nm nn b">tab.Container</code>示例:如果我们将索引更改为例如3，我们可以确定该索引处的<code class="fe nk nl nm nn b">vdom</code>项目是我们想要更改的项目。如果我们不从DOM中移除不活动的卡片(卡片布局有一个<code class="fe nk nl nm nn b">removeInactiveCards</code>配置)，不添加占位符会导致卡片项目比标签标题按钮少。</p><p id="1ecf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这面旗帜确实在很多地方被使用。也许最明显的例子是:一个按钮有一个<code class="fe nk nl nm nn b">iconCls</code>和一个<code class="fe nk nl nm nn b">text</code>配置。如果没有设置<code class="fe nk nl nm nn b">iconCls</code>，相关的<code class="fe nk nl nm nn b">vdom</code>节点将获得<code class="fe nk nl nm nn b">removeDom</code>标志。因此，当我们更改<code class="fe nk nl nm nn b">text</code>配置时，我们可以确保它匹配按钮的第二个虚拟子节点。如果没有<code class="fe nk nl nm nn b">iconCls</code>，我们将从<code class="fe nk nl nm nn b">vdom</code>中删除虚拟节点本身，那么<code class="fe nk nl nm nn b">text</code>配置的每次更改都必须检查第一个子节点是否是图标或标签。</p><p id="08f7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您的组件越复杂，这个标志就越强大。</p><h1 id="3c0a" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">5.让我们看看它的实际效果吧！</h1><p id="faa9" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">下面是开发模式版本的视频。在这种模式下，我们运行真正的代码，没有任何构建或编译，所以我们可以看到每个模块文件都是自己加载的。调试的完美省时器。</p><p id="e051" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这种模式在Chrome、Edge和几天前的Safari(科技预览版)中都可以使用</p><div class="mq mr gp gr ms mt"><a href="https://levelup.gitconnected.com/safari-webkit-about-to-release-support-for-js-modules-inside-the-worker-scope-9dd33fc20190" rel="noopener  ugc nofollow" target="_blank"><div class="mu ab fo"><div class="mv ab mw cl cj mx"><h2 class="bd ir gy z fp my fr fs mz fu fw ip bi translated">Safari (Webkit)即将在worker范围内发布对JS模块的支持</h2><div class="na l"><h3 class="bd b gy z fp my fr fs mz fu fw dk translated">这是让UI开发回到它该在的地方的一大步:浏览器。</h3></div><div class="nb l"><p class="bd b dl z fp my fr fs mz fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="nc l"><div class="ny l ne nf ng nc nh mm mt"/></div></div></a></div><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="nz nj l"/></div></figure><p id="6e8e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">dist/production build (webpack)显然适用于所有主流浏览器。</p><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="nz nj l"/></div></figure><p id="7ca8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我刚刚注意到，动态加载的JS分割块不再出现在“JS”或“XHR”下，而是出现在“其他”开发工具标签中。</p><p id="761c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">老实说:我不知道这是否与Chromium或webpack的变化有关。感觉就是不对。</p><h1 id="d40d" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">6.在线演示</h1><p id="e0c4" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">这个演示不是为手机而精心制作的。桌面谢谢。</p><p id="3913" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">开发模式(Chromium或Safari Tech预览版)<br/><a class="ae mo" href="https://neomjs.github.io/pages/node_modules/neo.mjs/apps/covid/index.html#mainview=helix" rel="noopener ugc nofollow" target="_blank">neo.mjs/apps/covid/</a></p><p id="32ef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">分销/生产(所有主要浏览器)<br/><a class="ae mo" href="https://neomjs.github.io/pages/node_modules/neo.mjs/dist/production/apps/covid/index.html#mainview=helix" rel="noopener ugc nofollow" target="_blank">neo.mjs/dist/production/apps/covid/</a></p><h1 id="4c04" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">7.接下来是什么？</h1><p id="d8c7" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">由于Covid Dashboard现在使用新的延迟加载技术，独立回购也需要进行调整。</p><p id="6fba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">相同的变化应适用于多窗口covid应用程序(框架和独立回购版本)</p><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="oa nj l"/></div></figure><p id="3ca4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我还想增强现实世界演示应用程序(再次2个版本)。</p><p id="be4e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">之后，我对想法持开放态度。</p><p id="0d0d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以在版本2发布公告中找到潜在的路线图项目:</p><div class="mq mr gp gr ms mt"><a rel="noopener  ugc nofollow" target="_blank" href="/the-webworkers-driven-ui-framework-neo-mjs-version-2-release-announcement-b91b476d6f16"><div class="mu ab fo"><div class="mv ab mw cl cj mx"><h2 class="bd ir gy z fp my fr fs mz fu fw ip bi translated">webworkers驱动的UI框架neo.mjs第2版发布公告</h2><div class="na l"><h3 class="bd b gy z fp my fr fs mz fu fw dk translated">新产品的概念必须是颠覆性的，否则就没什么必要。然而，使用它们的方法…</h3></div><div class="nb l"><p class="bd b dl z fp my fr fs mz fu fw dk translated">itnext.io</p></div></div><div class="nc l"><div class="ob l ne nf ng nc nh mm mt"/></div></div></a></div><p id="3acc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本文里面提到:<br/> <strong class="jp ir">欢迎你来影响路线图！</strong></p><h1 id="01ca" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">8.最后的想法</h1><p id="a886" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">您可以在此处找到neo.mjs项目:</p><div class="mq mr gp gr ms mt"><a href="https://github.com/neomjs/neo" rel="noopener  ugc nofollow" target="_blank"><div class="mu ab fo"><div class="mv ab mw cl cj mx"><h2 class="bd ir gy z fp my fr fs mz fu fw ip bi translated">近地天体</h2><div class="na l"><h3 class="bd b gy z fp my fr fs mz fu fw dk translated">neo.mjs使您能够使用一个以上的CPU创建可扩展的高性能应用程序，而无需使用…</h3></div><div class="nb l"><p class="bd b dl z fp my fr fs mz fu fw dk translated">github.com</p></div></div><div class="nc l"><div class="oc l ne nf ng nc nh mm mt"/></div></div></a></div><p id="a5e8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该框架以及所有演示应用程序都是开源的→麻省理工学院许可的。</p><p id="b39f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一些开发人员向我提出了一个问题:</p><p id="7b5d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">“鸢，你在独自推动这个项目，因为它在财务上不可持续，你甚至不能全职做这个项目。<br/>它到底怎么会进化得这么快？”</p><p id="46fd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我的回答总是一样的:<br/>“没有XML。实际上没有。一切都是基于JSON的。就这么简单。”</p><p id="431b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">想一想。</strong></p><p id="88b9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">问候&amp;快乐编码，<br/>托拜厄斯</p></div></div>    
</body>
</html>