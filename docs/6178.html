<html>
<head>
<title>Multi-Cluster Kubernetes Networking with Netmaker</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">多集群Kubernetes与Netmaker联网</h1>
<blockquote>原文：<a href="https://itnext.io/multi-cluster-kubernetes-networking-with-netmaker-bfa4e22eb2fb?source=collection_archive---------1-----------------------#2021-09-08">https://itnext.io/multi-cluster-kubernetes-networking-with-netmaker-bfa4e22eb2fb?source=collection_archive---------1-----------------------#2021-09-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/d2859204adac950ca9c05529572364a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F70Qa6PFOyIFe5I_Vv9Yew.png"/></div></div></figure><p id="a90b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们已经在之前的教程中讨论过多云Kubernetes(见<a class="ae kw" rel="noopener ugc nofollow" target="_blank" href="/how-to-deploy-a-cross-cloud-kubernetes-cluster-with-built-in-disaster-recovery-bbce27fcc9d7">这里</a>和<a class="ae kw" rel="noopener ugc nofollow" target="_blank" href="/how-to-deploy-a-single-kubernetes-cluster-across-multiple-clouds-using-k3s-and-wireguard-a5ae176a6e81">这里</a>)。在这些帖子中，我们将讨论如何建立跨越多个云的<strong class="ka ir">单个</strong>集群。这种模式带来了许多潜在的用例、效率和资源节约。</p><p id="4d70" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，通常这不是一个选项。通常，组织需要在不同的环境中运行不同的集群，并在事后连接它们。</p><p id="cf1b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这些场景中，我们如何连接集群？如果您希望跨云或环境在不同的Kubernetes集群中实现pods和服务之间的直接联网，该怎么办？</p><p id="a65a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本教程中，我们将向您展示如何使用<a class="ae kw" href="https://github.com/gravitl/netmaker" rel="noopener ugc nofollow" target="_blank"> Netmaker </a>来实现这一点。有几个其他工具也有类似的最终目标，那么为什么选择Netmaker呢？</p><ol class=""><li id="55ab" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv lc ld le lf bi translated"><strong class="ka ir">使用内核WireGuard实现更快的联网:</strong>内核WireGuard是迄今为止最快的VPN隧道技术<a class="ae kw" href="https://www.the-digital-life.com/wireguard-vs-openvpn-and-ipsec-which-one-is-the-best/" rel="noopener ugc nofollow" target="_blank">。如果您担心跨集群网络的速度，您会希望使用内核WireGuard。</a></li><li id="a81c" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated"><strong class="ka ir">更细粒度的控制:</strong> Netmaker允许您将DaemonSets部署到集群的一个子集，以限制访问。</li><li id="8592" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated"><strong class="ka ir">不仅仅是Kubernetes: </strong>除了连接集群网络，Netmaker还可以安全地集成集群外的资源，例如:外部SQL服务器、数据存储和遗留应用程序。组织还可以让开发人员从他们的工作站直接访问pod和服务网络。因此，虽然多集群网络可能是主要目标，但为这些不同的场景提供一个通用平台可能更实际，并且可以增强平台所有者的能力。点击这里了解更多关于Netmaker的一般使用案例。</li></ol><p id="6fcf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">那么，如何使用Netmaker连接两个(或更多)Kubernetes集群呢？</p><p id="f062" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们开始吧。</p><h1 id="c26d" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">先决条件</h1><p id="c595" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">Netmaker: 我们将在其他教程以及我们的<a class="ae kw" href="https://netmaker.readthedocs.io/en/v0.7.2/quick-start.html" rel="noopener ugc nofollow" target="_blank">快速入门指南</a>中介绍如何部署Netmaker。这里，我们假设您已经有了一个Netmaker服务器并正在运行。如果没有，请花些时间浏览一下快速入门指南。</p><p id="055a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> Kubernetes集群:</strong>在我们的教程中，我们将使用两个k3s集群，一个在DigitalOcean，一个在prem。<strong class="ka ir">这些集群不得有重叠的pod和CIDR服务网络。这暂时是一个硬限制(计划将来允许重叠CIDR)。此外，您必须能够在您的k8s节点上安装软件包，即WireGuard，正如我们将在下一步中所做的。</strong></p><h1 id="f500" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated"><strong class="ak">安装电线护罩</strong></h1><p id="b5d8" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">任何参与多群集服务的节点都必须安装WireGuard。WireGuard现在是Linux内核的一部分，应该很容易安装在大多数操作系统上。</p><p id="e93c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们的节点上，我们运行的是Ubuntu 20.04，所以我们只需运行<strong class="ka ir">在每个节点上安装wireguard wireguard-tools </strong>。查看操作系统的<a class="ae kw" href="https://www.wireguard.com/install/" rel="noopener ugc nofollow" target="_blank">安装文档</a>。</p><p id="6bf5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果使用云提供商发行版，如IKS或DOKS，有办法在节点上安装WireGuard，但它需要一些特殊的操作。</p><p id="5a12" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="mo">如果您没有直接访问云提供商节点的root权限，您可以尝试部署和执行到这个</em><a class="ae kw" href="https://github.com/gravitl/netmak8s/blob/main/ubuntu.yaml" rel="noopener ugc nofollow" target="_blank"><em class="mo"/><strong class="ka ir"><em class="mo">root shell pod</em></strong></a><strong class="ka ir"><em class="mo">，</em> </strong> <em class="mo">中，它挂载整个根文件系统，模拟节点级别的SSH会话。这应该允许您安装WireGuard，即使您无法直接访问云提供商的操作系统。</em></p><h1 id="3265" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">建立网络</h1><p id="414a" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">在您的netmaker实例中，您将为每个集群创建一个网络，给它一个合理的名称，如aws-k8s或dc-1-k8s。每个集群应该有一个单独的子网。子网应该足够大，能够包含所有群集节点。通常像10.100.11.0/24这样的a /24就可以了。</p><p id="95a4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于我们的教程，我们有两个集群，一个在Ubuntu VPS上的DigitalOcean中，另一个在prem上的Ubuntu VM上。我们创建了两个网络:</p><p id="05e1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">云-k3s: 10.36.50.0/24 </strong></p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mp"><img src="../Images/cf6b4fa1402bafce7a7e9a3a2777f781.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-uoyWmIH3bRxgJoDD7bmqA.png"/></div></div></figure><p id="2950" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> dc1-k3s: 10.65.24.0/24 </strong></p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mu"><img src="../Images/d7d8dddd824e44c4df000b1e0f4d4679.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n4NehELTkkEn7I3Z4LsVLw.png"/></div></div></figure><p id="73dd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">重要的是，这些范围不能与任一集群上的pod或服务网络重叠。</p><p id="5faf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，为每个网络生成并存储一个访问令牌:</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/b5fd3d0e287663edad56974d9e7f7807.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*efSe3wIukmjvxwIUpVh3ag.png"/></div></div></figure><p id="473d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">访问令牌是中间值，是一个大的base 64编码的密钥，看起来像这样:</p><p id="0f66" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">eym 5 tlmdvywxsy 2 xvdwrzlmnvbjjb 3 jlzg 5 zywrkcii 6 ije 0 mi 45m 4 ynteumzyilcjhcgljb 25 uijoiyxbpl M5 tmxvdwyxsy 2 xvdwrzlmnvbsisimfwaxbvcnqioii 4 MDG xiiwiz 3 jwy 2 nvb…</p><p id="261d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们来看看库伯内特斯。</p><h1 id="0c56" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated"><strong class="ak">部署网络客户端守护进程</strong></h1><p id="1c30" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">在每个集群上，您将部署一个DaemonSet，它将您的节点添加到上面定义的专用网络中。此外，您将在每个集群上部署一个<strong class="ka ir">出口网关</strong>。</p><p id="66d4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对每个集群执行以下步骤<strong class="ka ir">，</strong>，使用运行命令的集群各自的<strong class="ka ir">网络名称</strong>和<strong class="ka ir">访问令牌</strong>。</p><pre class="mq mr ms mt gt mw mx my mz aw na bi"><span id="c2bd" class="nb lm iq mx b gy nc nd l ne nf">wget <a class="ae kw" href="https://raw.githubusercontent.com/gravitl/netmak8s/main/netclient-daemonset.yaml" rel="noopener ugc nofollow" target="_blank">https://raw.githubusercontent.com/gravitl/netmak8s/main/netclient-daemonset.yaml</a></span><span id="bcaa" class="nb lm iq mx b gy ng nd l ne nf">sed -i 's/XXXX/&lt;your token&gt;/g' netclient-daemonset.yaml</span><span id="4175" class="nb lm iq mx b gy ng nd l ne nf">sed -i 's/YYYY/&lt;your network name&gt;/g' netclient-daemonset.yaml</span><span id="edfa" class="nb lm iq mx b gy ng nd l ne nf">kubectl apply -f netclient-daemonset.yaml</span></pre><p id="6965" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">几分钟后，pod应该会启动并运行。要测试网络，请尝试执行其中一个pod，并通过专用地址ing一个节点:</p><pre class="mq mr ms mt gt mw mx my mz aw na bi"><span id="7ab4" class="nb lm iq mx b gy nc nd l ne nf">root@master1:~# kubectl get pods<br/>NAME                     READY   STATUS    RESTARTS   AGE<br/>netclient-hkznw          1/1     Running   0          9m13s<br/>netclient-p5dqg          1/1     Running   0          9m13s<br/>netclient-gv4zf          1/1     Running   0          4m54s</span><span id="80ab" class="nb lm iq mx b gy ng nd l ne nf"><strong class="mx ir">root@master1:~# kubectl exec -it netclient-hkznw -- /bin/bash</strong></span><span id="18bd" class="nb lm iq mx b gy ng nd l ne nf">root@datacenter1:~# wg show<br/>interface: nm-dc1-k3s<br/>  public key: ZuXfeakfja3aa3tA#TatAF#FAM=<br/>  private key: (hidden)<br/>  listening port: 51821</span><span id="6534" class="nb lm iq mx b gy ng nd l ne nf">peer: 3ORn8HAFWfaWFaweFAfawfafwfaPbSKox9xm/qtFDo=<br/>  endpoint: 192.168.88.152:51821<br/>  allowed ips: 10.65.24.3/32<br/>  latest handshake: 12 seconds ago<br/>  transfer: 1.64 KiB received, 548 B sent<br/>  persistent keepalive: every 20 seconds</span><span id="1f28" class="nb lm iq mx b gy ng nd l ne nf">peer: E/Cg60pAFWafwAWFafAWfAJoEA=<br/>  endpoint: 150.100.200.36:51829<br/>  allowed ips: 10.65.24.1/32<br/>  latest handshake: 1 minute, 29 seconds ago<br/>  transfer: 492 B received, 1.90 KiB sent<br/>  persistent keepalive: every 20 seconds</span><span id="d96e" class="nb lm iq mx b gy ng nd l ne nf">root@datacenter1:~# ping 192.168.88.152<br/>PING 192.168.88.152 (192.168.88.152) 56(84) bytes of data.<br/>64 bytes from 192.168.88.152: icmp_seq=1 ttl=64 time=0.349 ms<br/>64 bytes from 192.168.88.152: icmp_seq=2 ttl=64 time=0.385 ms<br/>64 bytes from 192.168.88.152: icmp_seq=3 ttl=64 time=0.381 ms</span></pre><p id="9ae9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果pings通了，恭喜你！您的专用网络已启动并运行。您的节点现在有了一个安全的通信通道。在UI中，每个网络看起来应该是这样的(随意将节点名称更改为与您的实际集群节点名称相匹配的名称)。</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nh"><img src="../Images/d50aec3d84553a978235b80ec56abb35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mRemyHr3MvpjLelmNQXeUg.png"/></div></div></figure><h2 id="7a99" class="nb lm iq bd ln ni nj dn lr nk nl dp lv kj nm nn lz kn no np md kr nq nr mh ns bi translated">网络客户端连接故障排除</h2><p id="8c44" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">如果在群集上启动网络时遇到问题，要重新添加netclient，首先需要在每个节点上运行“netclient leave”。要做到这一点，您可以使用kubectl运行以下代码:</p><pre class="mq mr ms mt gt mw mx my mz aw na bi"><span id="ac80" class="nb lm iq mx b gy nc nd l ne nf">kubectl exec -it netclient-XXX -- /bin/bash -c './netclient leave -n &lt;network name&gt;'</span></pre><p id="43ab" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后使用新配置重新应用daemonset或gateway yaml。</p><p id="b214" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您在单个机器上遇到问题，您可以简单地运行上面的“exec”命令，从网络中删除该节点，然后删除pod再试一次。</p><p id="55d9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">常见问题包括无法访问Netmaker服务器、访问密钥过期或不正确，以及与netclient映像的<strong class="ka ir">基本操作系统不兼容。</strong>最后一个可能是许多基本kubernetes操作系统的情况。netclient映像是使用debian:buster构建的。</p><p id="663d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是，netclient Dockerfile文件包含在repo中。您可以更改第二个“FROM”语句以使用与您的节点兼容的基本操作系统，并为您的用例重新构建映像:<a class="ae kw" href="https://github.com/gravitl/netmaker/blob/master/Dockerfile-netclient" rel="noopener ugc nofollow" target="_blank">https://github . com/gravitl/net maker/blob/master/docker file-net client</a></p></div><div class="ab cl nt nu hu nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="ij ik il im in"><p id="9278" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在进入下一步，我们将把我们的群集连接在一起。</p><h1 id="c914" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">部署网关节点</h1><p id="0811" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">在每个集群上，单个节点将充当“出口网关”来访问本地pod和服务网络。该节点将成为<strong class="ka ir">其他</strong>集群上网络的一部分。</p><p id="5bde" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，在我们的示例中，数字海洋集群将在数据中心网络(dc1-k3s)中有一个网关，我们的数据中心集群将在数字海洋网络(cloud-k3s)中有一个网关。</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/d2859204adac950ca9c05529572364a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F70Qa6PFOyIFe5I_Vv9Yew.png"/></div></div></figure><p id="034f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了实现这一点，我们将重复上述过程，但这一次使用netclient-gateway.yaml文件，该文件将在部署中部署单个netclient，并使用标签选择器将它绑定到一个节点。</p><pre class="mq mr ms mt gt mw mx my mz aw na bi"><span id="4856" class="nb lm iq mx b gy nc nd l ne nf">wget <a class="ae kw" href="https://raw.githubusercontent.com/gravitl/netmak8s/main/netclient-gateway.yaml" rel="noopener ugc nofollow" target="_blank">https://raw.githubusercontent.com/gravitl/netmak8s/main/netclient-gateway.yaml</a></span></pre><p id="216a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在每个集群上选择将充当网关的节点，并将其标记为gateway=true</p><pre class="mq mr ms mt gt mw mx my mz aw na bi"><span id="fa9e" class="nb lm iq mx b gy nc nd l ne nf"><strong class="mx ir">kubectl label node &lt;node name&gt; gateway=true</strong></span></pre><p id="4518" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，再次使用相同的访问令牌和网络名称值，但这一次是相反的。在“本地”群集上，为“云群集”添加值，反之亦然。</p><pre class="mq mr ms mt gt mw mx my mz aw na bi"><span id="0274" class="nb lm iq mx b gy nc nd l ne nf">sed -i 's/XXXX/&lt;other token&gt;/g' netclient-gateway.yaml</span><span id="f133" class="nb lm iq mx b gy ng nd l ne nf">sed -i 's/YYYY/&lt;other network name&gt;/g' netclient-gateway.yaml</span><span id="910e" class="nb lm iq mx b gy ng nd l ne nf">kubectl apply -f netclient-gateway.yaml</span></pre><p id="815f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">和以前一样，您可能希望进入pod，运行“wg show ”,并确保您能够ping通专用网络中的其他地址。</p><pre class="mq mr ms mt gt mw mx my mz aw na bi"><span id="b131" class="nb lm iq mx b gy nc nd l ne nf"><strong class="mx ir">kubectl exec -it netclient-gateway-XXXX -- /bin/bash</strong></span></pre><p id="b102" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，虽然这个pod已经被部署为出口网关，但是它仍然没有被定义为出口网关。</p><p id="323b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">回到您的Netmaker仪表板，在两个网络中的每一个上，单击按钮使这个新节点成为出口网关(它将具有名称“k8s-gw”)。</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oa"><img src="../Images/947589cb4061c423e3484b8c79179da2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rHEXfPvhEsCi8rcUs-BP4Q.png"/></div></div></figure><p id="bc56" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">添加<strong class="ka ir"> other cluster的</strong> pod和服务网络的范围，并指定机器的默认接口。</p><p id="d54d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要确定这一点，您可以运行“kubectl get po -A”和“kubectl get svc -A”。这应该足以告诉您正在处理的子网(通常是前两位数字，后面是. 0.0/16)。</p><p id="9822" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在一个节点上，运行“ip a”，要使用的接口通常是第二个列出的接口。</p><p id="fded" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，我的本地k8s集群的服务CIDR为10.43.0.0/16，pod CIDR为10.42.0.0/16。这些节点的默认接口为eno1。</p><p id="333c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，在<strong class="ka ir"> cloud-k3s </strong>网关(云集群)上，我按如下方式设置网关，以便接入本地集群网络:</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ob"><img src="../Images/a735165e6cc4ff8665a5b8ba9e860a51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HfjwZz6JwBh8PDUHImz2eg.png"/></div></div></figure><p id="bbfb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">反之，我的云k8s集群的pod CIDR为10.44.0.0/16，服务CIDR为10.45.0.0/16，默认接口为eth0。因此，我用这些值在我的<strong class="ka ir"> dc1-k3s </strong>网络(本地集群)上设置网关。</p><p id="da31" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一旦部署完毕，网关将在一分钟内投入使用。作为快速测试，我在本地集群中部署了一个Nginx服务。</p><pre class="mq mr ms mt gt mw mx my mz aw na bi"><span id="6a7a" class="nb lm iq mx b gy nc nd l ne nf">root@master1:~# kubectl get svc<br/>ngnix-service   ClusterIP   10.43.45.229        80/TCP</span></pre><p id="79d8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个服务现在应该可以从云集群中的任何pod访问到。作为测试，我在我的云集群上执行了一个pod，并尝试使用服务IP:</p><pre class="mq mr ms mt gt mw mx my mz aw na bi"><span id="8ec5" class="nb lm iq mx b gy nc nd l ne nf">root@k3s-1:~# kubectl exec -it mypod -- /bin/bash<br/>bash-5.0$ curl 10.43.45.229<br/>&lt;!DOCTYPE html&gt;<br/>&lt;html&gt;<br/>&lt;head&gt;<br/>&lt;title&gt;Welcome to nginx!&lt;/title&gt;<br/>&lt;style&gt;<br/>    body {<br/>        width: 35em;<br/>        margin: 0 auto;<br/>        font-family: Tahoma, Verdana, Arial, sans-serif;<br/>    }<br/>&lt;/style&gt;<br/>&lt;/head&gt;<br/>&lt;body&gt;<br/>&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;<br/>&lt;p&gt;If you see this page, the nginx web server is successfully installed and<br/>working. Further configuration is required.&lt;/p&gt;</span><span id="751d" class="nb lm iq mx b gy ng nd l ne nf">&lt;p&gt;For online documentation and support please refer to<br/>&lt;a href="<a class="ae kw" href="http://nginx.org/" rel="noopener ugc nofollow" target="_blank">http://nginx.org/</a>"&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;<br/>Commercial support is available at<br/>&lt;a href="<a class="ae kw" href="http://nginx.com/" rel="noopener ugc nofollow" target="_blank">http://nginx.com/</a>"&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;</span><span id="0952" class="nb lm iq mx b gy ng nd l ne nf">&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;<br/>&lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="c02f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如您所见，服务网络现在是可达的。在这一点上，网络连接，我们可以称之为退出。然而，我们可能需要一个额外的特性:<strong class="ka ir">服务发现</strong>。</p><h1 id="8d4d" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">部署服务导出器</h1><p id="4dbe" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">服务导出器将通过以下约定使DNS名称在集群之间可用:service.namespace.networkname。netmaker网络名称是cloud-k3s，所以我们的服务将是nodejs.webapp.cloud-k3s。</p><p id="9caa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，为了使其他集群中的所有pod都可以使用它，我们只需在每个集群上的CoreDNS configmap中添加一个条目。</p><p id="c714" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，获取模板</p><pre class="mq mr ms mt gt mw mx my mz aw na bi"><span id="9d36" class="nb lm iq mx b gy nc nd l ne nf">wget <a class="ae kw" href="https://raw.githubusercontent.com/gravitl/netmak8s/main/servicex-deploy.yaml" rel="noopener ugc nofollow" target="_blank">https://raw.githubusercontent.com/gravitl/netmak8s/main/servicex-deploy.yaml</a></span></pre><p id="5acb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">网络名称:</strong>我们一直在使用的网络，例如dc1-k3s和cloud-k3s</p><p id="3cbf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> Netmaker Secret key: </strong>在您的Netmaker服务器的docker compose中，查找MASTER_KEY下的值。</p><p id="2190" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> Netmaker API URL: </strong>这将与您的UI url相同，但将“仪表板”替换为“API”，例如“https://api.netmaker.url.com”(应包括http(s)模式)。</p><p id="2f23" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，将此信息添加到模板中(您将为每个集群执行一次，将<net name="">替换为该特定集群的网络名称:</net></p><pre class="mq mr ms mt gt mw mx my mz aw na bi"><span id="b2fe" class="nb lm iq mx b gy nc nd l ne nf">sed -i 's/XXXX/&lt;net name&gt;/g' servicex-deploy.yaml<br/>sed -i 's/YYYY/&lt;secret key&gt;/g' servicex-deploy.yaml<br/>sed -i 's/ZZZZ/&lt;api url&gt;/g' servicex-deploy.yaml</span></pre><p id="06d8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，您就可以部署服务了。该模板假设您正在部署到<strong class="ka ir">默认名称空间中。</strong>如果没有，请修改模板中的服务帐户角色绑定，以引用适当的名称空间。</p><pre class="mq mr ms mt gt mw mx my mz aw na bi"><span id="d630" class="nb lm iq mx b gy nc nd l ne nf">kubectl apply -f servicex-deploy.yaml</span></pre><p id="8cb6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">检查servicex pod的日志。您应该会看到正在导出的服务列表。</p><pre class="mq mr ms mt gt mw mx my mz aw na bi"><span id="d108" class="nb lm iq mx b gy nc nd l ne nf">root@master1:~# kubectl logs servicex-785dd5699b-78q5w<br/>2021/09/08 18:48:01 pushing {10.43.0.1 kubernetes.default dc1-k3s}<br/>2021/09/08 18:48:01 pushing {10.43.0.10 kube-dns.kube-system dc1-k3s}<br/>2021/09/08 18:48:01 pushing {10.43.137.90 metrics-server.kube-system dc1-k3s}<br/>2021/09/08 18:48:01 pushing {10.43.102.255 traefik.kube-system dc1-k3s}<br/>2021/09/08 18:48:01 pushing {10.43.45.229 ngnix-service.default dc1-k3s}</span></pre><p id="41f7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您应该可以在Netmaker的DNS中看到您的所有服务。服务导出器只需在Netmaker中为每个Kubernetes服务创建定制的DNS条目。它将每分钟运行一次(默认情况下)，收集任何新的或修改过的服务，并将它们推送到DNS。</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oc"><img src="../Images/85a3d9867f88d16d744585c0384b5817.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zEzyLoojj3KguRzpRPUsNQ.png"/></div></div></figure><p id="cc76" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一旦这两个集群都完成了，我们还有<strong class="ka ir">最后一步:</strong>将集群A中服务的DNS添加到集群B，反之亦然。为此，我们需要在每个集群上的CoreDNS中添加一个条目。为此，您需要知道您的Netmaker服务器公共IP。</p><pre class="mq mr ms mt gt mw mx my mz aw na bi"><span id="d8f3" class="nb lm iq mx b gy nc nd l ne nf">kubectl edit cm coredns -n kube-system</span></pre><p id="f398" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您将输入以下代码片段，用另一个集群上运行的网络名称替换<code class="fe od oe of mx b"><em class="mo">&lt;other cluster net name&gt;</em></code> <em class="mo"> </em>。例如，如果修改cloud-k3s CoreDNS configmap，您将输入dc1-k3s。</p><pre class="mq mr ms mt gt mw mx my mz aw na bi"><span id="1bb0" class="nb lm iq mx b gy nc nd l ne nf"><em class="mo">&lt;other cluster net name&gt;:53 {<br/>        errors<br/>        cache 30<br/>        forward . &lt;netmaker public IP&gt;<br/>    }</em></span></pre><p id="34bc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">修改该文件后，删除CoreDNS pod。当它恢复时，DNS应该立即可用。</p><pre class="mq mr ms mt gt mw mx my mz aw na bi"><span id="8907" class="nb lm iq mx b gy nc nd l ne nf">kubectl get po -n kube-system<br/>kubectl delete po -n kube-system coredns-XXXX</span></pre><p id="be9b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了进行测试，我们将尝试像以前一样从云集群访问相同的“本地”nginx服务。这一次，我们将使用DNS名称，而不是服务IP地址:</p><pre class="mq mr ms mt gt mw mx my mz aw na bi"><span id="9a0c" class="nb lm iq mx b gy nc nd l ne nf">kubectl exec -it servicex-6d6fc57669-ksgvl -- /bin/bash</span><span id="4481" class="nb lm iq mx b gy ng nd l ne nf">bash-5.0$ nslookup ngnix-service.default.dc1-k3s<br/>Server:  10.45.0.10<br/>Address: 10.45.0.10:53</span><span id="dd21" class="nb lm iq mx b gy ng nd l ne nf">Name: ngnix-service.default.dc1-k3s<br/>Address: 10.43.45.229</span><span id="39d9" class="nb lm iq mx b gy ng nd l ne nf">bash-5.0$ curl ngnix-service.default.dc1-k3s<br/>&lt;!DOCTYPE html&gt;<br/>&lt;html&gt;<br/>&lt;head&gt;<br/>&lt;title&gt;Welcome to nginx!&lt;/title&gt;<br/>&lt;style&gt;<br/>    body {<br/>        width: 35em;<br/>        margin: 0 auto;<br/>        font-family: Tahoma, Verdana, Arial, sans-serif;<br/>    }<br/>&lt;/style&gt;<br/>&lt;/head&gt;<br/>&lt;body&gt;<br/>&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;<br/>&lt;p&gt;If you see this page, the nginx web server is successfully installed and<br/>working. Further configuration is required.&lt;/p&gt;</span><span id="e8ab" class="nb lm iq mx b gy ng nd l ne nf">&lt;p&gt;For online documentation and support please refer to<br/>&lt;a href="<a class="ae kw" href="http://nginx.org/" rel="noopener ugc nofollow" target="_blank">http://nginx.org/</a>"&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;<br/>Commercial support is available at<br/>&lt;a href="<a class="ae kw" href="http://nginx.com/" rel="noopener ugc nofollow" target="_blank">http://nginx.com/</a>"&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;</span><span id="b915" class="nb lm iq mx b gy ng nd l ne nf">&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;<br/>&lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="48b8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">服务名现在跨集群可用，IP是可解析的，返回Nginx网页。</p><h1 id="bcf6" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">结论</h1><p id="df47" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">我们采用了两个断开连接的集群，一个公共集群和一个私有集群，并使它们的pods和服务可以通过IP和DNS相互访问。通过使用内核WireGuard，我们能够以最快的速度连接这些网络。</p><p id="f096" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">只要X个集群的pod/服务网络不重叠，就可以完成相同的过程，这是一个提醒:这是一个不断发展的项目，当前的限制包括:</p><ol class=""><li id="c908" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv lc ld le lf bi translated">需要跨集群的唯一CIDR</li><li id="61ad" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">需要在集群上安装内核WireGuard</li></ol><p id="41a7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这些都是我们打算在不久的将来消除的限制，所以如果这是您的安装中的一个硬停止，请确保检查未来的版本。</p></div></div>    
</body>
</html>