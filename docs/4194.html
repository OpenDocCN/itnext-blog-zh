<html>
<head>
<title>Continuous Deployment to Kubernetes (EKS) using AWS CodePipeline, AWS CodeCommit and AWS CodeBuild</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用AWS CodePipeline、AWS CodeCommit和AWS CodeBuild持续部署到Kubernetes (EKS)</h1>
<blockquote>原文：<a href="https://itnext.io/continuous-deployment-to-kubernetes-eks-using-aws-codepipeline-aws-codecommit-and-aws-codebuild-fce7d6c18e83?source=collection_archive---------0-----------------------#2020-05-13">https://itnext.io/continuous-deployment-to-kubernetes-eks-using-aws-codepipeline-aws-codecommit-and-aws-codebuild-fce7d6c18e83?source=collection_archive---------0-----------------------#2020-05-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="c002" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">一个简单的管道可以用于Kubernetes集群，而不需要任何复杂的机制。</h2></div><p id="517c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我一直在考虑实现一个解决方案，关于如何使用完全由AWS提供的服务进行持续部署的解决方案，类似于Google Cloud 提供的<a class="ae lb" href="https://cloud.google.com/kubernetes-engine/docs/tutorials/gitops-cloud-build#create_the_continuous_delivery_pipeline" rel="noopener ugc nofollow" target="_blank"> GitOps风格的持续交付管道教程。部分原因是，我想看看在AWS上实现这样一个解决方案有多难(或多容易),因为EKS和持续交付解决方案在AWS中是本地可用的。我之所以想使用完全依赖AWS服务的解决方案，是为了避免管理托管解决方案的额外成本和开销。事不宜迟，让我告诉你我想做什么。</a></p><p id="d0ba" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我在AWS DevOps博客上看到了这篇文章，它提供了一个使用AWS CodePipeline、AWS CodeCommit、AWS CodeBuild、Amazon ECR和AWS Lambda实现连续交付的解决方案。</p><div class="lc ld gp gr le lf"><a href="https://aws.amazon.com/blogs/devops/continuous-deployment-to-kubernetes-using-aws-codepipeline-aws-codecommit-aws-codebuild-amazon-ecr-and-aws-lambda/" rel="noopener  ugc nofollow" target="_blank"><div class="lg ab fo"><div class="lh ab li cl cj lj"><h2 class="bd ir gy z fp lk fr fs ll fu fw ip bi translated">使用AWS CodePipeline、AWS CodeCommit、AWS CodeBuild、Amazon ECR和AWS Lambda持续部署到Kubernetes</h2><div class="lm l"><p class="bd b dl z fp lk fr fs ll fu fw dk translated">aws.amazon.com</p></div></div><div class="ln l"><div class="lo l lp lq lr ln ls lt lf"/></div></div></a></div><p id="5f72" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这篇文章本身没有问题，但我想看看是否有可能删除AWS Lambda要求，就像它在GCP是如何实现的一样(或在某种程度上)。我最终做到了这一点，现在我将向你解释这是如何做到的。</p><p id="838f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于这个练习，您需要两个代码管道。为什么是两个？正如在Google的文章中，源代码和Kubernetes部署有两个不同的生命周期。此外，开发源代码的开发人员不会对它是如何部署的太感兴趣。首先，我建议你看一下<a class="ae lb" href="https://cloud.google.com/kubernetes-engine/docs/tutorials/gitops-cloud-build#create_the_continuous_delivery_pipeline" rel="noopener ugc nofollow" target="_blank"> GCP教程</a>，对所用的比喻有一个公平的概念，因为没有必要延长这篇文章。</p><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div class="gh gi lu"><img src="../Images/112ce5d10a89e5bc0703eed0a7319cb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1134/format:webp/1*soR2_hPwhPFUsXj6pZAMmA.png"/></div><figcaption class="mb mc gj gh gi md me bd b be z dk translated">管道的架构</figcaption></figure></div><div class="ab cl mf mg hu mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ij ik il im in"><h2 id="7b71" class="mm mn iq bd mo mp mq dn mr ms mt dp mu ko mv mw mx ks my mz na kw nb nc nd ne bi translated">第一个代码管道:从git仓库到容器注册中心</h2><p id="c2af" class="pw-post-body-paragraph kf kg iq kh b ki nf jr kk kl ng ju kn ko nh kq kr ks ni ku kv kw nj ky kz la ij bi translated">首先，您需要一个git存储库来存储源代码。我在这里使用CodeCommit。它在根目录中包含以下内容:</p><ul class=""><li id="ba10" class="nk nl iq kh b ki kj kl km ko nm ks nn kw no la np nq nr ns bi translated"><strong class="kh ir"> code </strong> directory:每当有更新时要被容器化的源代码。</li><li id="a81b" class="nk nl iq kh b ki nt kl nu ko nv ks nw kw nx la np nq nr ns bi translated"><strong class="kh ir">docker-distribution</strong><em class="ny"/>目录:仅包含<strong class="kh ir"> Dockerfile </strong>。</li><li id="7504" class="nk nl iq kh b ki nt kl nu ko nv ks nw kw nx la np nq nr ns bi translated"><strong class="kh ir"> buildspec.yaml </strong>文件:包含CodeBuild稍后在管道阶段使用的指令。</li></ul><p id="4aed" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦对CodeCommit存储库进行了任何代码更改，就需要根据Dockerfile中的指令创建docker容器，并将其推送到容器注册中心，在本例中是弹性容器注册中心。</p><p id="bb10" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我现在将告诉您如何从AWS控制台设置管道。</p><p id="6d95" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦进入AWS控制台，从<strong class="kh ir">服务</strong>中选择<strong class="kh ir">代码管道</strong>，点击<strong class="kh ir">创建管道</strong>。在本例中，我将管道命名为<strong class="kh ir"> ecs-pipeline </strong>。以下是我使用的设置:</p><ul class=""><li id="ee2d" class="nk nl iq kh b ki kj kl km ko nm ks nn kw no la np nq nr ns bi translated"><strong class="kh ir">管道名称:</strong><em class="ny">ECR-管道</em></li><li id="dbe7" class="nk nl iq kh b ki nt kl nu ko nv ks nw kw nx la np nq nr ns bi translated"><strong class="kh ir">服务角色:</strong> <em class="ny">新增服务角色</em></li><li id="d392" class="nk nl iq kh b ki nt kl nu ko nv ks nw kw nx la np nq nr ns bi translated">确保<strong class="kh ir">允许AWS代码管道创建一个服务角色，这样它就可以与选择的这个新管道</strong>一起使用。</li><li id="f1e8" class="nk nl iq kh b ki nt kl nu ko nv ks nw kw nx la np nq nr ns bi translated">点击<strong class="kh ir">下一步</strong></li><li id="d572" class="nk nl iq kh b ki nt kl nu ko nv ks nw kw nx la np nq nr ns bi translated"><strong class="kh ir">来源提供者:</strong> <em class="ny"> AWS代码提交</em></li><li id="df86" class="nk nl iq kh b ki nt kl nu ko nv ks nw kw nx la np nq nr ns bi translated"><strong class="kh ir">存储库名称:</strong>代码所在的存储库。</li><li id="8d89" class="nk nl iq kh b ki nt kl nu ko nv ks nw kw nx la np nq nr ns bi translated"><strong class="kh ir">分店名称:</strong>分店名称</li><li id="6a49" class="nk nl iq kh b ki nt kl nu ko nv ks nw kw nx la np nq nr ns bi translated">将所有其他内容保留为默认值，然后单击下一步的<strong class="kh ir">。</strong></li><li id="f149" class="nk nl iq kh b ki nt kl nu ko nv ks nw kw nx la np nq nr ns bi translated"><strong class="kh ir">构建提供者:</strong> AWS代码构建</li><li id="72e8" class="nk nl iq kh b ki nt kl nu ko nv ks nw kw nx la np nq nr ns bi translated">点击<strong class="kh ir">创建项目</strong></li><li id="6a7c" class="nk nl iq kh b ki nt kl nu ko nv ks nw kw nx la np nq nr ns bi translated">将<strong class="kh ir">项目名称</strong>命名为<em class="ny">ECR-项目</em></li><li id="436b" class="nk nl iq kh b ki nt kl nu ko nv ks nw kw nx la np nq nr ns bi translated"><strong class="kh ir">环境镜像:</strong> <em class="ny">管理镜像</em></li><li id="b493" class="nk nl iq kh b ki nt kl nu ko nv ks nw kw nx la np nq nr ns bi translated"><strong class="kh ir">操作系统:</strong> <em class="ny">亚马逊Linux 2 </em></li><li id="ac74" class="nk nl iq kh b ki nt kl nu ko nv ks nw kw nx la np nq nr ns bi translated"><strong class="kh ir">运行时:</strong> <em class="ny">标准</em></li><li id="f02e" class="nk nl iq kh b ki nt kl nu ko nv ks nw kw nx la np nq nr ns bi translated"><strong class="kh ir">图片:</strong><em class="ny">AWS/codebuild/amazonlinux 2-x86 _ 64-standard:2.0</em></li><li id="1345" class="nk nl iq kh b ki nt kl nu ko nv ks nw kw nx la np nq nr ns bi translated"><strong class="kh ir">服务角色:</strong> <em class="ny">新服务角色</em></li><li id="f648" class="nk nl iq kh b ki nt kl nu ko nv ks nw kw nx la np nq nr ns bi translated"><strong class="kh ir">角色名称:</strong> <em class="ny">给角色起个名字</em></li><li id="c557" class="nk nl iq kh b ki nt kl nu ko nv ks nw kw nx la np nq nr ns bi translated">展开<strong class="kh ir">附加配置。</strong></li><li id="5290" class="nk nl iq kh b ki nt kl nu ko nv ks nw kw nx la np nq nr ns bi translated">给出这些环境变量:</li></ul><pre class="lv lw lx ly gt nz oa ob oc aw od bi"><span id="0f00" class="mm mn iq oa b gy oe of l og oh">AWS_DEFAULT_REGION: us-east-1<br/>AWS_ACCOUNT_ID: &lt;your-aws-account-id&gt;<br/>ENV: latest #use other environment name based on the type; eg., <strong class="oa ir">staging</strong><br/>IMAGE_REPO_NAME: web-app #The container image name I intent to use</span></pre><ul class=""><li id="8702" class="nk nl iq kh b ki kj kl km ko nm ks nn kw no la np nq nr ns bi translated">在<strong class="kh ir">构建规范</strong>下，选择<strong class="kh ir">使用构建规范文件</strong>。</li><li id="2097" class="nk nl iq kh b ki nt kl nu ko nv ks nw kw nx la np nq nr ns bi translated">进行其他必要的更改，并选择<strong class="kh ir">继续编码管道</strong>。</li><li id="fbb2" class="nk nl iq kh b ki nt kl nu ko nv ks nw kw nx la np nq nr ns bi translated">回到代码管道页面，点击下一个的<strong class="kh ir">。</strong></li><li id="6ac9" class="nk nl iq kh b ki nt kl nu ko nv ks nw kw nx la np nq nr ns bi translated">在部署阶段，点击<strong class="kh ir">跳过部署阶段</strong>。</li><li id="357e" class="nk nl iq kh b ki nt kl nu ko nv ks nw kw nx la np nq nr ns bi translated">查看并选择<strong class="kh ir">创建管道</strong>。</li></ul><p id="46d1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您需要对许多管道应用这种方法，为了简单起见，您也可以为CodePipeline和CodeBuild创建一个JSON文件。这超出了本文的范围。</p><p id="e0ff" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第一次构建将会失败，因为您还没有创建<strong class="kh ir"> buildspec.yaml </strong>。现在，我们将继续定义我们的buildspec。我需要构建做的是，每当代码有任何更改时，将目录更改为<strong class="kh ir">代码</strong>目录，使用<strong class="kh ir"> yarn build </strong>为生产构建静态文件，使用Dockerfile中的指令对此进行容器化，并将其推送到弹性容器注册表。</p><p id="12b9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是buildspec创建时的样子:</p><figure class="lv lw lx ly gt lz"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="1eb1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们来分解一下。</p><p id="372c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第一阶段是<strong class="kh ir">安装</strong>阶段。这里，要使用的nodejs的版本可以在<strong class="kh ir">运行时-版本</strong>下指定。在<strong class="kh ir">命令下</strong>为<strong class="kh ir">安装</strong>阶段是<strong class="kh ir">纱线安装</strong>。由于<em class="ny">AWS/code build/amazonlinux 2-x86 _ 64-standard:2.0</em>build image预装了yarn，我们不需要在安装阶段单独安装。因此，我们现在将运行yarn install来安装所需的包。我还将指定一个COMMIT_HASH，它是code build _ RESOLVED _ SOURCE _ VERSION的截断版本，code build _ RESOLVED _ SOURCE _ VERSION是从源阶段返回到构建环境的环境变量，它只不过是启动管道的最后一个git提交ID。您可以在此链接中看到构建环境使用的环境变量列表:</p><div class="lc ld gp gr le lf"><a href="https://docs.aws.amazon.com/codebuild/latest/userguide/build-env-ref-env-vars.html" rel="noopener  ugc nofollow" target="_blank"><div class="lg ab fo"><div class="lh ab li cl cj lj"><h2 class="bd ir gy z fp lk fr fs ll fu fw ip bi translated">构建环境中的环境变量</h2><div class="ok l"><h3 class="bd b gy z fp lk fr fs ll fu fw dk translated">AWS CodeBuild提供了几个可以在构建命令中使用的环境变量:CODEBUILD_BUILD_ARN</h3></div><div class="lm l"><p class="bd b dl z fp lk fr fs ll fu fw dk translated">docs.aws.amazon.com</p></div></div></div></a></div><p id="2943" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">COMMIT_HASH将被用作构建图像的图像标签。</p><p id="20bc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<strong class="kh ir"> pre_build </strong>阶段，云构建角色将使用命令<code class="fe ol om on oa b">$(aws ecr get-login — no-include-email — region $AWS_DEFAULT_REGION)</code>登录Amazon ECR。但这需要访问ECR，而我们的云构建帐户没有。但是我们不需要给Cloud Build account不必要的权限来创建容器存储库，只需要更新镜像即可。因此，我们将继续在ECR中手动创建一个映像。继续从ECR创建一个名为<strong class="kh ir"> web-app </strong>(在我的例子中)的存储库。现在，转到<strong class="kh ir"> IAM </strong> &gt; <strong class="kh ir">角色</strong> &gt; <strong class="kh ir"> </strong>选择您的云构建角色&gt;添加策略<strong class="kh ir">amazonec 2 containerregistrypoweruser</strong>。权限完成了。现在，我们将看看在构建规范中还有什么。现在，有两个命令<strong class="kh ir">纱线清洁</strong>和<strong class="kh ir">纱线构建</strong>来构建我们的文件。您将需要根据您的要求来改变这一点。</p><p id="1afd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来如果<strong class="kh ir">建立</strong>阶段。在这一阶段，我们将把目录更改为<strong class="kh ir"> docker-distribution </strong>，并构建docker映像。</p><p id="2f09" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<strong class="kh ir"> post_build </strong>阶段，我们会将此docker映像上传到ECR，这应该不会有问题，因为我们已经将所需的策略附加到云构建角色。</p><p id="d0c0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦buildspec.yaml被创建并被推送到CodeCommit，这将再次触发管道。最终产品将是上传到ECR的容器图像。</p><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/851eb3ff96d17b38bd83666eb38041ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:932/format:webp/1*tXNnV4MhJ7JcH4VFC33r2A.png"/></div></figure><p id="b74d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我们将讨论如何将这个容器映像应用到kubernetes (EKS)部署中。</p></div><div class="ab cl mf mg hu mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ij ik il im in"><h2 id="daef" class="mm mn iq bd mo mp mq dn mr ms mt dp mu ko mv mw mx ks my mz na kw nb nc nd ne bi translated">第二条代码管道:从ECR到EKS</h2><p id="6f3d" class="pw-post-body-paragraph kf kg iq kh b ki nf jr kk kl ng ju kn ko nh kq kr ks ni ku kv kw nj ky kz la ij bi translated">如前所述，开发人员不需要知道Kubernetes部署是什么样子的。此外，您可能希望限制对少数人的访问。这就是为什么您需要第二个管道(加上我试图在单个管道中设置它，但未能满足我的要求)。</p><p id="1452" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于这个管道，我们需要两个源(它启动管道的触发器):</p><ol class=""><li id="00c7" class="nk nl iq kh b ki kj kl km ko nm ks nn kw no la op nq nr ns bi translated">每当container registry中有新的映像时，它都应该应用到我们已经存在的Kubernetes部署中。</li><li id="1716" class="nk nl iq kh b ki nt kl nu ko nv ks nw kw nx la op nq nr ns bi translated">如果我们的Kubernetes部署清单有变化，也应该应用到部署中。</li></ol><p id="48af" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那是什么意思？所以，你有一个EKS部署。当ECR中有新的容器映像可用时，您需要更新该部署中的映像。如果存储在Git存储库(在我们的例子中是另一个CodeCommit存储库)中的<a class="ae lb" href="https://kubernetes.io/docs/concepts/overview/working-with-objects/kubernetes-objects/" rel="noopener ugc nofollow" target="_blank">部署清单</a>被更新，那么部署也应该被更新。</p><p id="5db2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我解释一下我的CodeCommit存储库在它的根目录中存储了什么(这只是一个测试用例)。</p><ul class=""><li id="16b8" class="nk nl iq kh b ki kj kl km ko nm ks nn kw no la np nq nr ns bi translated">一个包含部署清单的<strong class="kh ir"> deployment.yaml </strong>文件。</li><li id="0edb" class="nk nl iq kh b ki nt kl nu ko nv ks nw kw nx la np nq nr ns bi translated">一个<strong class="kh ir"> buildspec.yaml </strong>，它存储了关于如何应用这个deployment.yaml文件的信息。</li></ul><p id="f2ed" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将从为第一个源——ECR registry创建管道开始。转到IAM，创建一个名为<strong class="kh ir"> codebuild-eks </strong>的角色。它应该应用于codebuild服务。</p><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/7da129fd53907a099bdff5c80ee5aa43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1190/format:webp/1*wrDJ2zu7j6eCJVvHq9uUCw.png"/></div></figure><p id="df0e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，创建一个名为<strong class="kh ir"> EKS集群访问</strong>的IAM策略，具有以下权限:</p><figure class="lv lw lx ly gt lz"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="1be2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是CodeBuild角色向EKS群集(您应该已经创建了该群集)进行身份验证所必需的。您不需要附加任何其他策略，因为它将在接下来的步骤中完成。我们现在将像以前一样创建一个新的管道。</p><ul class=""><li id="9039" class="nk nl iq kh b ki kj kl km ko nm ks nn kw no la np nq nr ns bi translated"><strong class="kh ir">管道名称:</strong><em class="ny">eks-管道</em></li><li id="356b" class="nk nl iq kh b ki nt kl nu ko nv ks nw kw nx la np nq nr ns bi translated"><strong class="kh ir">服务角色:</strong> <em class="ny">新增服务角色</em></li><li id="7cd2" class="nk nl iq kh b ki nt kl nu ko nv ks nw kw nx la np nq nr ns bi translated">确保<strong class="kh ir">允许AWS代码管道创建一个服务角色，这样它就可以与选择的这个新管道</strong>一起使用。</li><li id="c104" class="nk nl iq kh b ki nt kl nu ko nv ks nw kw nx la np nq nr ns bi translated">点击<strong class="kh ir">下一个</strong></li><li id="c010" class="nk nl iq kh b ki nt kl nu ko nv ks nw kw nx la np nq nr ns bi translated"><strong class="kh ir">货源供应商:</strong> <em class="ny">亚马逊ECR </em></li><li id="e62f" class="nk nl iq kh b ki nt kl nu ko nv ks nw kw nx la np nq nr ns bi translated"><strong class="kh ir">资源库名称:</strong> <em class="ny"> web-app </em></li><li id="59ee" class="nk nl iq kh b ki nt kl nu ko nv ks nw kw nx la np nq nr ns bi translated"><strong class="kh ir">图像标签:</strong>最新</li><li id="000b" class="nk nl iq kh b ki nt kl nu ko nv ks nw kw nx la np nq nr ns bi translated">点击下一个的<strong class="kh ir">。</strong></li><li id="efc5" class="nk nl iq kh b ki nt kl nu ko nv ks nw kw nx la np nq nr ns bi translated"><strong class="kh ir">构建提供者:</strong> AWS代码构建</li><li id="7099" class="nk nl iq kh b ki nt kl nu ko nv ks nw kw nx la np nq nr ns bi translated">点击<strong class="kh ir">创建项目</strong></li><li id="eae3" class="nk nl iq kh b ki nt kl nu ko nv ks nw kw nx la np nq nr ns bi translated">将<strong class="kh ir">项目名称</strong>命名为<em class="ny">eks-项目</em></li><li id="7146" class="nk nl iq kh b ki nt kl nu ko nv ks nw kw nx la np nq nr ns bi translated"><strong class="kh ir">环境图像:</strong> <em class="ny">管理图像</em></li><li id="25fa" class="nk nl iq kh b ki nt kl nu ko nv ks nw kw nx la np nq nr ns bi translated"><strong class="kh ir">操作系统:</strong>T28】亚马逊Linux 2 </li><li id="db80" class="nk nl iq kh b ki nt kl nu ko nv ks nw kw nx la np nq nr ns bi translated"><strong class="kh ir">运行时:</strong> <em class="ny">标准</em></li><li id="1a2d" class="nk nl iq kh b ki nt kl nu ko nv ks nw kw nx la np nq nr ns bi translated"><strong class="kh ir">图片:</strong><em class="ny">AWS/codebuild/amazonlinux 2-x86 _ 64-standard:2.0</em></li><li id="4adf" class="nk nl iq kh b ki nt kl nu ko nv ks nw kw nx la np nq nr ns bi translated"><strong class="kh ir">服务角色:</strong> <em class="ny">现有服务角色</em></li><li id="08b5" class="nk nl iq kh b ki nt kl nu ko nv ks nw kw nx la np nq nr ns bi translated"><strong class="kh ir">角色ARN: </strong>选择<em class="ny"> codebuild-eks </em>角色对应的ARN</li><li id="3485" class="nk nl iq kh b ki nt kl nu ko nv ks nw kw nx la np nq nr ns bi translated">确保<strong class="kh ir">允许AWS CodeBuild修改此服务角色，以便它可以与选择的构建项目</strong>一起使用。</li><li id="2932" class="nk nl iq kh b ki nt kl nu ko nv ks nw kw nx la np nq nr ns bi translated">展开<strong class="kh ir">附加配置。</strong></li><li id="f3df" class="nk nl iq kh b ki nt kl nu ko nv ks nw kw nx la np nq nr ns bi translated">给出这些环境变量:</li></ul><pre class="lv lw lx ly gt nz oa ob oc aw od bi"><span id="3235" class="mm mn iq oa b gy oe of l og oh">AWS_DEFAULT_REGION: us-east-1<br/>AWS_CLUSTER_NAME: &lt;your-cluster-name&gt;</span></pre><ul class=""><li id="e9c0" class="nk nl iq kh b ki kj kl km ko nm ks nn kw no la np nq nr ns bi translated">在<strong class="kh ir">构建规范</strong>下，选择<strong class="kh ir">使用构建规范文件</strong>。</li><li id="886e" class="nk nl iq kh b ki nt kl nu ko nv ks nw kw nx la np nq nr ns bi translated">进行其他必要的更改，并选择<strong class="kh ir">继续编码管道</strong>。</li><li id="04d8" class="nk nl iq kh b ki nt kl nu ko nv ks nw kw nx la np nq nr ns bi translated">回到代码管道页面，点击<strong class="kh ir">下一个</strong>。</li><li id="b2c4" class="nk nl iq kh b ki nt kl nu ko nv ks nw kw nx la np nq nr ns bi translated">在部署阶段，点击<strong class="kh ir">跳过部署阶段</strong>。</li><li id="f996" class="nk nl iq kh b ki nt kl nu ko nv ks nw kw nx la np nq nr ns bi translated">查看并选择<strong class="kh ir">创建管道</strong>。</li></ul><p id="ef8d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如所料，这个管道也会失败，因为CodeBuild在其当前工作目录(<a class="ae lb" href="https://docs.aws.amazon.com/codebuild/latest/userguide/build-env-ref-env-vars.html" rel="noopener ugc nofollow" target="_blank"> CODEBUILD_SRC_DIR </a>)中没有<strong class="kh ir"> buildspec.yaml </strong>文件。继续创建一个空的CodeCommit存储库，比如说<strong class="kh ir"> eks-distribution </strong>。现在，回到CodePipeline并执行以下操作:</p><ul class=""><li id="9224" class="nk nl iq kh b ki kj kl km ko nm ks nn kw no la np nq nr ns bi translated">选择<strong class="kh ir">eks-管道</strong>。</li><li id="a634" class="nk nl iq kh b ki nt kl nu ko nv ks nw kw nx la np nq nr ns bi translated">点击<strong class="kh ir">编辑</strong></li><li id="5fb8" class="nk nl iq kh b ki nt kl nu ko nv ks nw kw nx la np nq nr ns bi translated">在<strong class="kh ir">编辑:源</strong>部分选择<strong class="kh ir">编辑阶段</strong>。</li></ul><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div role="button" tabindex="0" class="os ot di ou bf ov"><div class="gh gi or"><img src="../Images/66b062e703b5936193fbe41cb216845d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*01ipKxlKXS2RNH1PQ3qWPw.png"/></div></div></figure><ul class=""><li id="72e1" class="nk nl iq kh b ki kj kl km ko nm ks nn kw no la np nq nr ns bi translated">点击<strong class="kh ir">添加动作</strong>。</li></ul><p id="1eaa" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">弹出新的<strong class="kh ir">编辑动作</strong>页面。</p><ul class=""><li id="fe75" class="nk nl iq kh b ki kj kl km ko nm ks nn kw no la np nq nr ns bi translated"><strong class="kh ir">动作名称:</strong><em class="ny">EKS _部署_来源</em></li><li id="78cf" class="nk nl iq kh b ki nt kl nu ko nv ks nw kw nx la np nq nr ns bi translated"><strong class="kh ir">动作提供者:</strong> <em class="ny"> AWS代码提交</em></li><li id="4070" class="nk nl iq kh b ki nt kl nu ko nv ks nw kw nx la np nq nr ns bi translated"><strong class="kh ir">储存库名称:</strong> <em class="ny"> eks-distribution </em></li><li id="39af" class="nk nl iq kh b ki nt kl nu ko nv ks nw kw nx la np nq nr ns bi translated"><strong class="kh ir">分公司名称:</strong>T94】主</li><li id="cbac" class="nk nl iq kh b ki nt kl nu ko nv ks nw kw nx la np nq nr ns bi translated"><strong class="kh ir">输出工件:</strong><em class="ny">EKS _部署_工件</em></li><li id="4fea" class="nk nl iq kh b ki nt kl nu ko nv ks nw kw nx la np nq nr ns bi translated">将其他一切保持默认，并点击<strong class="kh ir">完成</strong></li><li id="c883" class="nk nl iq kh b ki nt kl nu ko nv ks nw kw nx la np nq nr ns bi translated">在<strong class="kh ir">编辑:eks-pipeline </strong>页面下再次点击<strong class="kh ir">完成</strong>。</li><li id="457d" class="nk nl iq kh b ki nt kl nu ko nv ks nw kw nx la np nq nr ns bi translated">现在点击<strong class="kh ir">编辑:构建</strong>部分中的<strong class="kh ir">编辑阶段</strong>。</li><li id="0a1b" class="nk nl iq kh b ki nt kl nu ko nv ks nw kw nx la np nq nr ns bi translated">点击铅笔按钮，编辑已经存在的<strong class="kh ir"> AWS CodeBuild </strong>动作。</li><li id="5c8f" class="nk nl iq kh b ki nt kl nu ko nv ks nw kw nx la np nq nr ns bi translated">当弹出新的<strong class="kh ir">编辑动作</strong>页面时，点击输入工件下的<strong class="kh ir">添加</strong>，选择<em class="ny">EKS _部署_工件</em>。</li><li id="4bd0" class="nk nl iq kh b ki nt kl nu ko nv ks nw kw nx la np nq nr ns bi translated">在<strong class="kh ir">主源</strong>下，选择<em class="ny">EKS _部署_工件</em>。</li><li id="9587" class="nk nl iq kh b ki nt kl nu ko nv ks nw kw nx la np nq nr ns bi translated">您的构建阶段现在应该如下所示:</li></ul><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div role="button" tabindex="0" class="os ot di ou bf ov"><div class="gh gi ow"><img src="../Images/9c4e0bab1f9fedbb4b5118f391debef0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Yhjxlq2syjBSONZCJgLyGA.png"/></div></div></figure><ul class=""><li id="55f6" class="nk nl iq kh b ki kj kl km ko nm ks nn kw no la np nq nr ns bi translated">其他一切保持原样，点击<strong class="kh ir">完成</strong>。</li></ul><p id="15b6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这一次，管道也将失败，因为我们的eks发行版存储库中什么也没有。继续创建<strong class="kh ir"> deployment.yaml </strong>文件，确保将标签中的图像替换为<strong class="kh ir">:最新的</strong>标签。<strong class="kh ir"> buildspec.yaml </strong>文件应该是这样的:</p><figure class="lv lw lx ly gt lz"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="bc34" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我还在上面的repo中包含了一个示例deployment.yaml。</p><p id="fc7d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">阶段很简单。在安装阶段，我们安装kubectl命令。在<strong class="kh ir">预构建</strong>阶段，我们向EKS集群进行身份认证。这将创建一个<a class="ae lb" href="https://kubernetes.io/docs/concepts/configuration/organize-cluster-access-kubeconfig/" rel="noopener ugc nofollow" target="_blank"> kubeconfig文件</a>。但是，尽管CodeBuild角色拥有向群集进行身份验证的权限，但它没有在群集上执行任何其他操作所需的RBAC访问权限。您甚至可以在集群中列出pod。您应该阅读以下来自EKS文档的引文:</p><blockquote class="ox oy oz"><p id="b782" class="kf kg ny kh b ki kj jr kk kl km ju kn pa kp kq kr pb kt ku kv pc kx ky kz la ij bi translated">当您创建一个亚马逊EKS集群时，IAM实体用户或角色，比如创建集群的<a class="ae lb" href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_providers.html" rel="noopener ugc nofollow" target="_blank">联合用户</a>，在集群的RBAC配置中被自动授予<code class="fe ol om on oa b">system:masters</code>权限。要授予其他AWS用户或角色与您的集群交互的能力，您必须在Kubernetes中编辑<code class="fe ol om on oa b">aws-auth</code> ConfigMap。</p></blockquote><p id="9cb3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，您需要编辑aws-auth配置图。你是怎么做到的？如果您是创建集群的人，您需要在本地终端中运行以下命令来创建一个<code class="fe ol om on oa b">aws-auth</code>配置图的副本。</p><pre class="lv lw lx ly gt nz oa ob oc aw od bi"><span id="0368" class="mm mn iq oa b gy oe of l og oh"># aws configure<br/># aws eks — region $AWS_DEFAULT_REGION update-kubeconfig — name $AWS_CLUSTER_NAME<br/># kubectl get configmaps aws-auth -n kube-system -o yaml &gt; aws-auth.yaml</span></pre><p id="6d75" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如您可能已经想到的，您需要有可用的aws和kubectl命令。您可以使用下面的链接来参考如何设置它:</p><p id="a661" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae lb" href="https://docs.aws.amazon.com/cli/latest/userguide/install-cliv2.html" rel="noopener ugc nofollow" target="_blank">安装AWS CLI版本2</a><br/>T5】安装kubectl </p><p id="7694" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，编辑您的aws-auth.yaml，并在<strong class="kh ir"> data.mapRoles </strong>下添加以下内容</p><pre class="lv lw lx ly gt nz oa ob oc aw od bi"><span id="ec59" class="mm mn iq oa b gy oe of l og oh">- rolearn: arn:aws:iam::510442909921:role/codebuild-eks<br/>  username: codebuild-eks<br/>  groups:<br/>    - system:masters</span></pre><p id="df02" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最终的aws-auth.yaml看起来应该有点像这样:</p><figure class="lv lw lx ly gt lz"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="2838" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从您的终端应用此配置:</p><p id="e0c7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ol om on oa b"># kubectl apply -f aws-auth.yaml</code></p><p id="79d5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，CodeBuild帐户拥有了必需的RBAC访问权限。在<strong class="kh ir">构建</strong>阶段，有一个到<strong class="kh ir"> $CODEBUILD_SRC_DIR </strong>的变更目录，这不是必需的，因为默认情况下代码构建将在这个目录中。如果<strong class="kh ir">EKS _部署_工件</strong>不是主要来源，您需要将目录更改为<strong class="kh ir">$ CODEBUILD _ SRC _ DIR _ EKS _部署_工件</strong>。你可以在这里阅读更多信息:</p><div class="lc ld gp gr le lf"><a href="https://docs.aws.amazon.com/codebuild/latest/userguide/sample-pipeline-multi-input-output.html" rel="noopener  ugc nofollow" target="_blank"><div class="lg ab fo"><div class="lh ab li cl cj lj"><h2 class="bd ir gy z fp lk fr fs ll fu fw ip bi translated">AWS代码管道与CodeBuild和多个输入源和输出工件的集成示例</h2><div class="lm l"><p class="bd b dl z fp lk fr fs ll fu fw dk translated">docs.aws.amazon.com</p></div></div></div></a></div><p id="2fa3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在最后一个阶段，您使用<code class="fe ol om on oa b">kubectl apply -f deployment.yaml</code>应用部署</p><p id="679a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在您提交<strong class="kh ir"> buildspec.yaml </strong>文件并将更改推送到CodeCommit。管道随之而来，如果到目前为止你做了所有正确的事情，它应该是成功的。</p><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div role="button" tabindex="0" class="os ot di ou bf ov"><div class="gh gi pd"><img src="../Images/c51ac0173146ca3fee8bf1fedad5ee5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rFPhFbKUtJeMDmAloFGL9g.png"/></div></div></figure></div></div>    
</body>
</html>