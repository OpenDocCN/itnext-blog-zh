<html>
<head>
<title>Save costs in your Kubernetes cluster with 5 open source tools</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用5个开源工具节省Kubernetes集群的成本</h1>
<blockquote>原文：<a href="https://itnext.io/save-costs-in-your-kubernetes-cluster-with-5-open-source-projects-7f53899a1429?source=collection_archive---------4-----------------------#2018-07-23">https://itnext.io/save-costs-in-your-kubernetes-cluster-with-5-open-source-projects-7f53899a1429?source=collection_archive---------4-----------------------#2018-07-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><ol class=""><li id="28c2" class="jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke bi translated">使用Prometheus监控过多的资源请求</li><li id="575c" class="jn jo iq jp b jq kf js kg ju kh jw ki jy kj ka kb kc kd ke bi translated">工作时间自动缩放</li><li id="5051" class="jn jo iq jp b jq kf js kg ju kh jw ki jy kj ka kb kc kd ke bi translated">节点自动缩放</li><li id="738a" class="jn jo iq jp b jq kf js kg ju kh jw ki jy kj ka kb kc kd ke bi translated">水平pod自动缩放</li><li id="7b0f" class="jn jo iq jp b jq kf js kg ju kh jw ki jy kj ka kb kc kd ke bi translated">垂直pod自动缩放</li></ol><p id="763f" class="pw-post-body-paragraph kk kl iq jp b jq jr km kn js jt ko kp ju kq kr ks jw kt ku kv jy kw kx ky ka ij bi translated">额外:降低云成本的更多技巧</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi kz"><img src="../Images/b727f18de53c614ba5e6bbbe0864f576.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fs3S95C63Z_jyS3ASt1tKQ.jpeg"/></div></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk translated"><a class="ae lp" href="https://twitter.com/todaywasawesome/status/915374176063463424" rel="noopener ugc nofollow" target="_blank">图片来自丹·加菲尔德</a></figcaption></figure><p id="8daa" class="pw-post-body-paragraph kk kl iq jp b jq jr km kn js jt ko kp ju kq kr ks jw kt ku kv jy kw kx ky ka ij bi translated">嗨！今天，我想分享我是如何通过使用上述工具，在我的集群中大幅降低成本的。</p><p id="175e" class="pw-post-body-paragraph kk kl iq jp b jq jr km kn js jt ko kp ju kq kr ks jw kt ku kv jy kw kx ky ka ij bi translated">本文描述了许多开源项目，但这并不是详细的指南。重点是快速建立他们来<em class="lq">品尝</em>每个项目。</p><p id="8ccf" class="pw-post-body-paragraph kk kl iq jp b jq jr km kn js jt ko kp ju kq kr ks jw kt ku kv jy kw kx ky ka ij bi translated">我知道开源可能很难接近，所以我将包括部署这些项目所需的所有代码，以及一个最小的描述和进一步文档的链接。如果您决定继续使用任何软件，请阅读完整的文档。</p><p id="4db8" class="pw-post-body-paragraph kk kl iq jp b jq jr km kn js jt ko kp ju kq kr ks jw kt ku kv jy kw kx ky ka ij bi translated">最后一点，我将只讨论CPU指标，但是同样的代码对于内存指标总是有效的。</p><h1 id="0314" class="lr ls iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">使用Prometheus监控过多的资源请求</h1><p id="1a52" class="pw-post-body-paragraph kk kl iq jp b jq mp km kn js mq ko kp ju mr kr ks jw ms ku kv jy mt kx ky ka ij bi translated">首先，我将展示如何测量在您的Kubernetes集群中浪费了多少资源。</p><p id="034e" class="pw-post-body-paragraph kk kl iq jp b jq jr km kn js jt ko kp ju kq kr ks jw kt ku kv jy kw kx ky ka ij bi translated">普罗米修斯是Kubernetes admin最好的朋友。部署它最简单的方法是通过<a class="ae lp" href="https://hub.kubeapps.com/charts/stable/prometheus" rel="noopener ugc nofollow" target="_blank">这个舵图</a>:</p><pre class="la lb lc ld gt mu mv mw mx aw my bi"><span id="f13b" class="mz ls iq mv b gy na nb l nc nd">helm install stable/prometheus</span></pre><p id="e832" class="pw-post-body-paragraph kk kl iq jp b jq jr km kn js jt ko kp ju kq kr ks jw kt ku kv jy kw kx ky ka ij bi translated">如果您的集群中已经有一个Prometheus实例，请确保您已经部署并监控了<a class="ae lp" href="https://github.com/kubernetes/kube-state-metrics" rel="noopener ugc nofollow" target="_blank"> kube-state-metrics </a>，并且您已经配置了一个作业来<a class="ae lp" href="https://github.com/prometheus/prometheus/blob/master/documentation/examples/prometheus-kubernetes.yml#L102" rel="noopener ugc nofollow" target="_blank">监控节点的cAdvisor </a>。如果你正在使用上面链接的舵图，你已经准备好继续。</p><p id="a4f2" class="pw-post-body-paragraph kk kl iq jp b jq jr km kn js jt ko kp ju kq kr ks jw kt ku kv jy kw kx ky ka ij bi translated">我将通过容器请求的内核和实际使用的内核之间的关系来衡量资源效率。这个数字越大，不必要保留的资源就越多。</p><p id="bf1b" class="pw-post-body-paragraph kk kl iq jp b jq jr km kn js jt ko kp ju kq kr ks jw kt ku kv jy kw kx ky ka ij bi translated">不要害怕下面的查询，它实际上很简单，你会学到一些普罗米修斯的技巧😉</p><pre class="la lb lc ld gt mu mv mw mx aw my bi"><span id="0d43" class="mz ls iq mv b gy na nb l nc nd">label_replace(<br/>  label_replace(<br/>    kube_pod_container_resource_requests_cpu_cores{},<br/>    "pod_name", <br/>    "$1", <br/>    "pod", <br/>    "(.+)"<br/>  ),<br/>  "container_name", <br/>  "$1", <br/>  "container", <br/>  "(.+)"<br/>) <br/>/<br/>on(pod_name,namespace,container_name) <br/>sum(<br/>  rate(<br/>    container_cpu_usage_seconds_total{pod_name=~".+"}[60m]<br/>  )<br/>) <br/>by (pod_name,namespace,container_name)</span></pre><p id="657a" class="pw-post-body-paragraph kk kl iq jp b jq jr km kn js jt ko kp ju kq kr ks jw kt ku kv jy kw kx ky ka ij bi translated">分子是容器的CPU请求。指标<em class="lq">kube _ pod _ container _ resource _ requests _ CPU _ cores</em>由kube-state-metrics提供。我使用了两次<code class="fe ne nf ng mv b">label_replace </code>函数来转换<em class="lq"> pod </em>和<em class="lq"> container </em>标签，以匹配分母中的<em class="lq"> pod_name </em>和<em class="lq"> container_name </em>标签(标签匹配是划分不同度量所必需的)。</p><p id="bd71" class="pw-post-body-paragraph kk kl iq jp b jq jr km kn js jt ko kp ju kq kr ks jw kt ku kv jy kw kx ky ka ij bi translated">分母是CPU使用率，以60分钟的时间间隔计算，以避免出现峰值。<code class="fe ne nf ng mv b">on </code>关键字用于限制两部分匹配的标签。</p><p id="fc91" class="pw-post-body-paragraph kk kl iq jp b jq jr km kn js jt ko kp ju kq kr ks jw kt ku kv jy kw kx ky ka ij bi translated">这是我在测试集群中得到的输出:</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi nh"><img src="../Images/fcfe28a84619c75ce2709f1170965926.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yNFctBkrj37iz8yEjfY5Nw.png"/></div></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk translated">每个容器的CPU请求/使用情况图表</figcaption></figure><p id="ac67" class="pw-post-body-paragraph kk kl iq jp b jq jr km kn js jt ko kp ju kq kr ks jw kt ku kv jy kw kx ky ka ij bi translated">是的，一个容器占用的资源是它实际使用的25000倍😒。</p><p id="5a28" class="pw-post-body-paragraph kk kl iq jp b jq jr km kn js jt ko kp ju kq kr ks jw kt ku kv jy kw kx ky ka ij bi translated">使用这个指标，您可以配置一个警报，以便在每次请求超过使用量时通知您。</p><p id="6dd5" class="pw-post-body-paragraph kk kl iq jp b jq jr km kn js jt ko kp ju kq kr ks jw kt ku kv jy kw kx ky ka ij bi translated">但是我不喜欢收到大量关于员工的邮件或松散的信息，这些都是可以自动处理的。我们将在“垂直Pod自动缩放”部分了解如何自动改进这一指标。</p><h1 id="e738" class="lr ls iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">工作时间自动缩放</h1><p id="b1f3" class="pw-post-body-paragraph kk kl iq jp b jq mp km kn js mq ko kp ju mr kr ks jw ms ku kv jy mt kx ky ka ij bi translated">对于我来说，最大的节省实际上来自于避免不必要的工作负载。部署只在工作时间使用的工具或环境是正常的。</p><p id="e774" class="pw-post-body-paragraph kk kl iq jp b jq jr km kn js jt ko kp ju kq kr ks jw kt ku kv jy kw kx ky ka ij bi translated">值得庆幸的是，有一个有用的工具可以安排何时将部署扩展到0(感谢<a class="ae lp" href="https://github.com/hjacobs" rel="noopener ugc nofollow" target="_blank">雅各布斯</a>):</p><div class="ni nj gp gr nk nl"><a href="https://github.com/hjacobs/kube-downscaler" rel="noopener  ugc nofollow" target="_blank"><div class="nm ab fo"><div class="nn ab no cl cj np"><h2 class="bd ir gy z fp nq fr fs nr fu fw ip bi translated">hjacobs/kube-降频器</h2><div class="ns l"><h3 class="bd b gy z fp nq fr fs nr fu fw dk translated">kube-缩减规模—在下班后缩减Kubernetes部署</h3></div><div class="nt l"><p class="bd b dl z fp nq fr fs nr fu fw dk translated">github.com</p></div></div><div class="nu l"><div class="nv l nw nx ny nu nz lj nl"/></div></div></a></div><p id="cd75" class="pw-post-body-paragraph kk kl iq jp b jq jr km kn js jt ko kp ju kq kr ks jw kt ku kv jy kw kx ky ka ij bi translated">该存储库包含在集群中部署该控制器的YAMLs:</p><pre class="la lb lc ld gt mu mv mw mx aw my bi"><span id="df90" class="mz ls iq mv b gy na nb l nc nd">git clone <a class="ae lp" href="https://github.com/hjacobs/kube-downscaler.git" rel="noopener ugc nofollow" target="_blank">https://github.com/hjacobs/kube-downscaler.git</a><br/>cd kube-downscaler<br/>kubectl apply -f deploy/</span></pre><p id="d944" class="pw-post-body-paragraph kk kl iq jp b jq jr km kn js jt ko kp ju kq kr ks jw kt ku kv jy kw kx ky ka ij bi translated">接下来，您只需要注释您想要缩减的部署:</p><pre class="la lb lc ld gt mu mv mw mx aw my bi"><span id="cbfe" class="mz ls iq mv b gy na nb l nc nd">kubectl annotate deploy &lt;MY DEPLOY&gt; "downscaler/uptime=Mon-Fri 07:30–20:00 Europe/Madrid"</span></pre><p id="0f0e" class="pw-post-body-paragraph kk kl iq jp b jq jr km kn js jt ko kp ju kq kr ks jw kt ku kv jy kw kx ky ka ij bi translated">此数量将在20:00缩减为零，并在7:30(周一至周五)恢复到之前的副本数量。</p><p id="b39c" class="pw-post-body-paragraph kk kl iq jp b jq jr km kn js jt ko kp ju kq kr ks jw kt ku kv jy kw kx ky ka ij bi translated">与下一个工具一起使用，它将帮助你在睡觉时节省很多钱。</p><h1 id="c2b2" class="lr ls iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">节点自动缩放</h1><p id="347d" class="pw-post-body-paragraph kk kl iq jp b jq mp km kn js mq ko kp ju mr kr ks jw ms ku kv jy mt kx ky ka ij bi translated">集群自动缩放器是任何Kubernetes集群的必备插件。它负责管理集群中可用的资源总量，并与您的云提供商进行沟通以扩大或缩小资源规模。毕竟不少用节点就不是真正的节约。</p><div class="ni nj gp gr nk nl"><a href="https://github.com/kubernetes/autoscaler/tree/master/cluster-autoscaler" rel="noopener  ugc nofollow" target="_blank"><div class="nm ab fo"><div class="nn ab no cl cj np"><h2 class="bd ir gy z fp nq fr fs nr fu fw ip bi translated">kubernetes/自动缩放器</h2><div class="ns l"><h3 class="bd b gy z fp nq fr fs nr fu fw dk translated">自动缩放Kubernetes的自动缩放组件</h3></div><div class="nt l"><p class="bd b dl z fp nq fr fs nr fu fw dk translated">github.com</p></div></div><div class="nu l"><div class="oa l nw nx ny nu nz lj nl"/></div></div></a></div><p id="4543" class="pw-post-body-paragraph kk kl iq jp b jq jr km kn js jt ko kp ju kq kr ks jw kt ku kv jy kw kx ky ka ij bi translated">它可以与kubeapps中的这个<a class="ae lp" href="https://github.com/kubernetes/autoscaler/tree/master/cluster-autoscaler" rel="noopener ugc nofollow" target="_blank">头盔图</a>一起部署。请参阅文档，根据您的云提供商进行配置。阅读<a class="ae lp" href="https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/FAQ.md" rel="noopener ugc nofollow" target="_blank">常见问题</a>也是一种建议。</p><p id="6f5e" class="pw-post-body-paragraph kk kl iq jp b jq jr km kn js jt ko kp ju kq kr ks jw kt ku kv jy kw kx ky ka ij bi translated">集群自动缩放刚刚工作。通过一些配置，它可以自动发现节点的自动扩展组，您将不再有处于挂起状态的pod。每当可用的CPU或内存不足以部署新的pod时，它都会启动一个新的节点。此外，它还会在必要时缩小规模。</p><p id="591f" class="pw-post-body-paragraph kk kl iq jp b jq jr km kn js jt ko kp ju kq kr ks jw kt ku kv jy kw kx ky ka ij bi translated">额外的节省:你可以通过添加一个标签到你的自动缩放组来缩放一个节点组到0，在这里了解如何<a class="ae lp" href="https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/FAQ.md#how-can-i-scale-a-node-group-to-0" rel="noopener ugc nofollow" target="_blank"/>。</p><h1 id="2504" class="lr ls iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">水平Pod自动缩放</h1><p id="8edf" class="pw-post-body-paragraph kk kl iq jp b jq mp km kn js mq ko kp ju mr kr ks jw ms ku kv jy mt kx ky ka ij bi translated">如果您有多个服务副本，这种方法非常有用，可以避免流量高峰时的中断。使用此功能根据实际流量调整副本的数量。</p><div class="ni nj gp gr nk nl"><a href="https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/" rel="noopener  ugc nofollow" target="_blank"><div class="nm ab fo"><div class="nn ab no cl cj np"><h2 class="bd ir gy z fp nq fr fs nr fu fw ip bi translated">水平Pod自动秤— Kubernetes</h2><div class="ns l"><h3 class="bd b gy z fp nq fr fs nr fu fw dk translated">编辑此页面水平窗格自动缩放器自动缩放复制控制器中的窗格数量…</h3></div><div class="nt l"><p class="bd b dl z fp nq fr fs nr fu fw dk translated">kubernetes.io</p></div></div></div></a></div><p id="6bea" class="pw-post-body-paragraph kk kl iq jp b jq jr km kn js jt ko kp ju kq kr ks jw kt ku kv jy kw kx ky ka ij bi translated">Kubernetes已经改进了它的水平扩展能力。在任何部署中，只需一个命令就可以配置自动扩展，并且可以使用CPU和内存边界以及任何其他自定义指标来完成。</p><p id="cc7b" class="pw-post-body-paragraph kk kl iq jp b jq jr km kn js jt ko kp ju kq kr ks jw kt ku kv jy kw kx ky ka ij bi translated">如果您的集群不符合先决条件，我会帮助您满足这些条件。惟一的先决条件是metrics-server，但是要部署它，您需要启用聚合层。</p><p id="339e" class="pw-post-body-paragraph kk kl iq jp b jq jr km kn js jt ko kp ju kq kr ks jw kt ku kv jy kw kx ky ka ij bi translated"><a class="ae lp" href="https://kubernetes.io/docs/tasks/access-kubernetes-api/configure-aggregation-layer/" rel="noopener ugc nofollow" target="_blank">聚合层</a>是Kubernetes的一部分，它允许用额外的API(作为我们需要的度量API)来扩展默认的apiserver。可以通过向apiserver添加以下参数来启用它:</p><pre class="la lb lc ld gt mu mv mw mx aw my bi"><span id="df9f" class="mz ls iq mv b gy na nb l nc nd">--requestheader-client-ca-file=/etc/kubernetes/certificates/ca.crt<br/>--requestheader-allowed-names=<br/>--requestheader-extra-headers-prefix=X-Remote-Extra-<br/>--requestheader-group-headers=X-Remote-Group<br/>--requestheader-username-headers=X-Remote-User<br/>--proxy-client-cert-file=/etc/kubernetes/certificates/apiserver.crt<br/>--proxy-client-key-file=/etc/kubernetes/certificates/apiserver.key</span></pre><p id="6503" class="pw-post-body-paragraph kk kl iq jp b jq jr km kn js jt ko kp ju kq kr ks jw kt ku kv jy kw kx ky ka ij bi translated">是的，在这个例子中，我使用了我已经为apiserver拥有的相同证书，并在requestheader-allowed-names中设置了通配符。我在我的生产集群中不这样做，这只是为了更快地进行。在<a class="ae lp" href="https://kubernetes.io/docs/reference/command-line-tools-reference/kube-apiserver/" rel="noopener ugc nofollow" target="_blank"> apiserver参考</a>中找到所有这些参数的解释。</p><p id="d45b" class="pw-post-body-paragraph kk kl iq jp b jq jr km kn js jt ko kp ju kq kr ks jw kt ku kv jy kw kx ky ka ij bi translated">我们准备部署<a class="ae lp" href="https://github.com/kubernetes-incubator/metrics-server" rel="noopener ugc nofollow" target="_blank">度量服务器</a>。首先克隆repo，它提供YAMLs来部署一切。</p><pre class="la lb lc ld gt mu mv mw mx aw my bi"><span id="bb4f" class="mz ls iq mv b gy na nb l nc nd">git clone <a class="ae lp" href="https://github.com/kubernetes-incubator/metrics-server.git" rel="noopener ugc nofollow" target="_blank">https://github.com/kubernetes-incubator/metrics-server.git</a><br/>cd metrics-server</span></pre><p id="f8f9" class="pw-post-body-paragraph kk kl iq jp b jq jr km kn js jt ko kp ju kq kr ks jw kt ku kv jy kw kx ky ka ij bi translated">我们只需要在文件deploy/1.8+/metrics-server-deployment . YAML中添加一个参数，结果文件如下:</p><pre class="la lb lc ld gt mu mv mw mx aw my bi"><span id="6f95" class="mz ls iq mv b gy na nb l nc nd"># File: deploy/1.8+/metrics-server-deployment.yaml<br/>........<br/>........<br/>........<br/>command:        <br/>  - /metrics-server        <br/>  - --source=kubernetes.summary_api:''<br/>  - --requestheader-allowed-names=</span></pre><p id="cd58" class="pw-post-body-paragraph kk kl iq jp b jq jr km kn js jt ko kp ju kq kr ks jw kt ku kv jy kw kx ky ka ij bi translated">保存、退出并运行:</p><pre class="la lb lc ld gt mu mv mw mx aw my bi"><span id="dad8" class="mz ls iq mv b gy na nb l nc nd">kubectl create -f deploy/1.8+/</span></pre><p id="c519" class="pw-post-body-paragraph kk kl iq jp b jq jr km kn js jt ko kp ju kq kr ks jw kt ku kv jy kw kx ky ka ij bi translated">检查pod日志以验证它是否正常工作。</p><p id="1694" class="pw-post-body-paragraph kk kl iq jp b jq jr km kn js jt ko kp ju kq kr ks jw kt ku kv jy kw kx ky ka ij bi translated">好吧！我将创建一个使用0.9内核的测试部署:</p><pre class="la lb lc ld gt mu mv mw mx aw my bi"><span id="d15e" class="mz ls iq mv b gy na nb l nc nd">kubectl create -f - &lt;&lt;EOF<br/>apiVersion: extensions/v1beta1<br/>kind: Deployment<br/>metadata:<br/>  name: scaling-test<br/>  namespace: default<br/>spec:<br/>  replicas: 1<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: scaling-test<br/>    spec:            <br/>      containers:<br/>      - name: hamster<br/>        image: k8s.gcr.io/ubuntu-slim:0.1<br/>        command: ["/bin/sh"]<br/>        args: ["-c", "while true; do timeout 0.9s yes &gt;/dev/null; sleep 0.1s; done"]<br/>EOF</span></pre><p id="3df4" class="pw-post-body-paragraph kk kl iq jp b jq jr km kn js jt ko kp ju kq kr ks jw kt ku kv jy kw kx ky ka ij bi translated">现在，让我们为超过80%的CPU使用率配置一个水平pod自动扩展(HPA)规则:</p><pre class="la lb lc ld gt mu mv mw mx aw my bi"><span id="1308" class="mz ls iq mv b gy na nb l nc nd">kubectl autoscale deploy scaling-test -min=1 -max=5 -cpu-percent=80</span></pre><p id="5b3b" class="pw-post-body-paragraph kk kl iq jp b jq jr km kn js jt ko kp ju kq kr ks jw kt ku kv jy kw kx ky ka ij bi translated">检查新创建的HPA资源并等待事件:</p><pre class="la lb lc ld gt mu mv mw mx aw my bi"><span id="31d8" class="mz ls iq mv b gy na nb l nc nd">k describe hpa scaling-test</span></pre><p id="6342" class="pw-post-body-paragraph kk kl iq jp b jq jr km kn js jt ko kp ju kq kr ks jw kt ku kv jy kw kx ky ka ij bi translated">一分钟后，部署应该扩展到最大值(5)。在最初的几秒钟内，您可能会看到一些错误。</p><p id="1995" class="pw-post-body-paragraph kk kl iq jp b jq jr km kn js jt ko kp ju kq kr ks jw kt ku kv jy kw kx ky ka ij bi translated">现在编辑部署，并将参数更改为:</p><pre class="la lb lc ld gt mu mv mw mx aw my bi"><span id="015d" class="mz ls iq mv b gy na nb l nc nd">- args:<br/>  - -c<br/>  - while true; do timeout 0.5s yes &gt;/dev/null; sleep 0.5s; done</span></pre><p id="a700" class="pw-post-body-paragraph kk kl iq jp b jq jr km kn js jt ko kp ju kq kr ks jw kt ku kv jy kw kx ky ka ij bi translated">此命令将仅使用50%的核心，因此部署应该自动缩减到1个副本。</p><h1 id="f10c" class="lr ls iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">垂直Pod自动缩放</h1><p id="3595" class="pw-post-body-paragraph kk kl iq jp b jq mp km kn js mq ko kp ju mr kr ks jw ms ku kv jy mt kx ky ka ij bi translated">这个<a class="ae lp" href="https://github.com/kubernetes/autoscaler/tree/master/vertical-pod-autoscaler" rel="noopener ugc nofollow" target="_blank">项目</a>处于alpha状态，但它对我来说是最有用的。正确配置后，它会自动为您的pod设置资源请求！</p><div class="ni nj gp gr nk nl"><a href="https://github.com/kubernetes/autoscaler/tree/master/vertical-pod-autoscaler" rel="noopener  ugc nofollow" target="_blank"><div class="nm ab fo"><div class="nn ab no cl cj np"><h2 class="bd ir gy z fp nq fr fs nr fu fw ip bi translated">kubernetes/自动缩放器</h2><div class="ns l"><h3 class="bd b gy z fp nq fr fs nr fu fw dk translated">自动缩放Kubernetes的自动缩放组件</h3></div><div class="nt l"><p class="bd b dl z fp nq fr fs nr fu fw dk translated">github.com</p></div></div><div class="nu l"><div class="ob l nw nx ny nu nz lj nl"/></div></div></a></div><p id="d4de" class="pw-post-body-paragraph kk kl iq jp b jq jr km kn js jt ko kp ju kq kr ks jw kt ku kv jy kw kx ky ka ij bi translated">您在第一部分已经看到，我的pod请求的CPU内核比它们实际使用的多得多。一旦设置了垂直pod autoscaler，这个指标就会大幅下降，并根据需要调整我的集群大小，而不需要更多的工作。</p><p id="4c8c" class="pw-post-body-paragraph kk kl iq jp b jq jr km kn js jt ko kp ju kq kr ks jw kt ku kv jy kw kx ky ka ij bi translated"><strong class="jp ir">建议</strong>:暂时不兼容水平吊舱自动缩放器。不要在同一个部署中同时使用两者！</p><p id="64eb" class="pw-post-body-paragraph kk kl iq jp b jq jr km kn js jt ko kp ju kq kr ks jw kt ku kv jy kw kx ky ka ij bi translated">Vertical Pod Autoscaler也依赖于metrics-server，我们在上一节中学习了如何部署它。另一个先决条件是在apiserver中启用<a class="ae lp" href="https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/#admission-webhooks" rel="noopener ugc nofollow" target="_blank">准入webhooks </a>。只需在apiserver参数中添加这些准入控制器:</p><pre class="la lb lc ld gt mu mv mw mx aw my bi"><span id="9f52" class="mz ls iq mv b gy na nb l nc nd">--admission-control=ValidatingAdmissionWebhook,MutatingAdmissionWebhook</span></pre><p id="da45" class="pw-post-body-paragraph kk kl iq jp b jq jr km kn js jt ko kp ju kq kr ks jw kt ku kv jy kw kx ky ka ij bi translated">现在克隆存储库，并使用安装脚本设置自动缩放器:</p><pre class="la lb lc ld gt mu mv mw mx aw my bi"><span id="4ed3" class="mz ls iq mv b gy na nb l nc nd">git clone <a class="ae lp" href="https://github.com/kubernetes/autoscaler.git" rel="noopener ugc nofollow" target="_blank">https://github.com/kubernetes/autoscaler.git</a><br/>cd autoscaler/vertical-pod-autoscaler<br/>./hack/vpa-up.sh</span></pre><p id="2d89" class="pw-post-body-paragraph kk kl iq jp b jq jr km kn js jt ko kp ju kq kr ks jw kt ku kv jy kw kx ky ka ij bi translated">这将为其三个组件创建自定义资源定义、部署和RBAC配置:</p><ol class=""><li id="39c7" class="jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke bi translated">推荐器:它监控pod指标并估计使用情况。</li><li id="bd85" class="jn jo iq jp b jq kf js kg ju kh jw ki jy kj ka kb kc kd ke bi translated">Updater:它接受建议，更新verticalPodAutoscaler对象，并在需要时驱逐pod。</li><li id="e736" class="jn jo iq jp b jq kf js kg ju kh jw ki jy kj ka kb kc kd ke bi translated">准入控制器:它在创建时用推荐的请求更新pod。</li></ol><p id="720c" class="pw-post-body-paragraph kk kl iq jp b jq jr km kn js jt ko kp ju kq kr ks jw kt ku kv jy kw kx ky ka ij bi translated">查看名称空间kube-system中三个组件的日志，检查部署是否成功。</p><p id="174d" class="pw-post-body-paragraph kk kl iq jp b jq jr km kn js jt ko kp ju kq kr ks jw kt ku kv jy kw kx ky ka ij bi translated">现在，创建一个使用0.5个内核但仅请求0.1个内核的部署，同时创建一个VPA(verticalPodAutoscaling)，看看会发生什么:</p><pre class="la lb lc ld gt mu mv mw mx aw my bi"><span id="7e43" class="mz ls iq mv b gy na nb l nc nd">kubectl create -f - &lt;&lt;EOF<br/>apiVersion: extensions/v1beta1<br/>kind: Deployment<br/>metadata:<br/>  name: vertical-scaling-test<br/>spec:<br/>  replicas: 1<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: vertical-scaling-test<br/>    spec:            <br/>      containers:<br/>      - name: ubuntu<br/>        image: k8s.gcr.io/ubuntu-slim:0.1<br/>        resources:<br/>          requests:<br/>            cpu: 0.1<br/>            memory: 50Mi<br/>        command: ["/bin/sh"]<br/>        args: ["-c", "while true; do timeout 0.5s yes &gt;/dev/null; sleep 0.5s; done"]<br/>EOF</span><span id="d27e" class="mz ls iq mv b gy oc nb l nc nd">kubectl create -f - &lt;&lt;EOF<br/>apiVersion: "poc.autoscaling.k8s.io/v1alpha1"<br/>kind: VerticalPodAutoscaler<br/>metadata:  <br/>  name: vertical-scaling-test<br/>spec:  <br/>  selector:<br/>    matchLabels:<br/>      app: vertical-scaling-test<br/>EOF</span></pre><p id="b259" class="pw-post-body-paragraph kk kl iq jp b jq jr km kn js jt ko kp ju kq kr ks jw kt ku kv jy kw kx ky ka ij bi translated">几分钟后，您应该会看到pod被新的请求重新创建。如果您编辑窗格以使用较少的资源，它将再次缩小。</p><p id="671e" class="pw-post-body-paragraph kk kl iq jp b jq jr km kn js jt ko kp ju kq kr ks jw kt ku kv jy kw kx ky ka ij bi translated">这个项目对于开发环境非常有用，但是不要忘记这是一个alpha版本。您还可以自定义每个组件，以设置最小值、限制值等。点击查看每个文件夹<a class="ae lp" href="https://github.com/kubernetes/autoscaler/tree/master/vertical-pod-autoscaler/pkg" rel="noopener ugc nofollow" target="_blank">中的自述文件。</a></p><h1 id="0098" class="lr ls iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">在Kubernetes省钱的额外技巧</h1><ul class=""><li id="b8f1" class="jn jo iq jp b jq mp js mq ju od jw oe jy of ka og kc kd ke bi translated">避免负载平衡器服务类型。使用入口对象和入口控制器更好也更便宜。</li><li id="1323" class="jn jo iq jp b jq kf js kg ju kh jw ki jy kj ka og kc kd ke bi translated">如果您在云中，请使用小型持久卷。使用此<a class="ae lp" href="https://kubernetes.io/blog/2018/07/12/resizing-persistent-volumes-using-kubernetes/" rel="noopener ugc nofollow" target="_blank">新功能</a>在需要时扩展它们。</li><li id="ceea" class="jn jo iq jp b jq kf js kg ju kh jw ki jy kj ka og kc kd ke bi translated">根据您对CPU和内存的要求，为集群使用正确的实例类型。选择正确的实例类型以优化使用。</li></ul><p id="cae1" class="pw-post-body-paragraph kk kl iq jp b jq jr km kn js jt ko kp ju kq kr ks jw kt ku kv jy kw kx ky ka ij bi translated">我希望你可以在你的集群中使用这些项目来节省一些信贷，让我知道你取得了什么成就！</p><p id="56b9" class="pw-post-body-paragraph kk kl iq jp b jq jr km kn js jt ko kp ju kq kr ks jw kt ku kv jy kw kx ky ka ij bi translated"><a class="ae lp" href="https://ignaciomillan.com" rel="noopener ugc nofollow" target="_blank">ignaciomillan.com</a></p></div></div>    
</body>
</html>