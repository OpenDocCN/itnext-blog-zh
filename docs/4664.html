<html>
<head>
<title>Testing Angular HTTP Communication</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">测试角度HTTP通信</h1>
<blockquote>原文：<a href="https://itnext.io/testing-angular-http-communication-9a120a10da18?source=collection_archive---------3-----------------------#2020-08-18">https://itnext.io/testing-angular-http-communication-9a120a10da18?source=collection_archive---------3-----------------------#2020-08-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/a8aaf695d59a4e37341d36a03611b562.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j8P5gNPHxKQlSqn60Pv8Tg.png"/></div></div></figure><p id="e94c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Angular有很棒的内置工具来进行web请求。它还包含一个很棒的测试HTTP通信的模块:<a class="ae kw" href="https://angular.io/api/common/http/testing/HttpClientTestingModule" rel="noopener ugc nofollow" target="_blank"> HttpClientTestingModule。</a>该模块包含完整的工具箱，以确保web通信按照开发人员的意图进行。让我们探索一下<a class="ae kw" href="https://angular.io/api/common/http/testing/HttpClientTestingModule" rel="noopener ugc nofollow" target="_blank"> HttpClientTestingModule </a>并了解如何:</p><ul class=""><li id="e563" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv lc ld le lf bi translated">测试HTTP请求</li><li id="1caf" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">模拟响应</li><li id="ee58" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">处理错误</li><li id="b47d" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">测试HTTP拦截器</li></ul><h1 id="f1c7" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">测试HTTP请求</h1><p id="1c52" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">让我们制作一个简单的应用程序，显示由GitHub用户标记的存储库列表。它将包括一个用户名输入框，一个请求按钮和一个显示结果的表格。为了让事情看起来漂亮，让我们使用bootstrap。</p><p id="c908" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当用户点击“显示”按钮时，我们需要发出web请求。让我们设置一个测试套件，并创建一个测试来确保web请求发生。</p><p id="8749" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Angular配备了一个非常棒的HTTP测试工具箱。<a class="ae kw" href="https://angular.io/api/common/http/testing/HttpClientTestingModule" rel="noopener ugc nofollow" target="_blank"> HttpClientTestingModule </a>是一个现成的容器，包含了我们进行HTTP测试所需的所有工具。它提供了<a class="ae kw" href="https://angular.io/api/common/http/testing/HttpTestingController" rel="noopener ugc nofollow" target="_blank">HttpTestingController</a>——一个管理HTTP请求的可注入服务。<a class="ae kw" href="https://angular.io/api/common/http/testing/HttpTestingController" rel="noopener ugc nofollow" target="_blank"> HttpTestingController </a>公开了测试执行过程中发生的所有HTTP请求的信息。我们可以像其他可注入服务一样注入它的一个实例。</p><p id="7c11" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们来做设置代码。</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="cf36" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在是编写第一个测试的时候了。当用户点击按钮时，我们期待这个请求，检索所有由用户加星号的回复的端点是<a class="ae kw" href="https://api.github.com/users/:userName/starred." rel="noopener ugc nofollow" target="_blank">https://api.github.com/users/:userName/starred.</a>。</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="a26e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kw" href="https://angular.io/api/common/http/testing/HttpTestingController" rel="noopener ugc nofollow" target="_blank"> HttpTestingController </a>包含两个期望方法:<a class="ae kw" href="https://angular.io/api/common/http/testing/HttpClientTestingModule" rel="noopener ugc nofollow" target="_blank"> expectOne </a>和<a class="ae kw" href="https://angular.io/api/common/http/testing/HttpClientTestingModule" rel="noopener ugc nofollow" target="_blank"> expectNone </a>。两者都有几个带有不同参数的重载来识别特定的请求。方法的名字很好地描述了它们做什么——不需要或者只需要一个特定的请求。如果没有达到预期，就会抛出异常。Jasmine需要一个“expect”语句。为了让测试通过，我们使用expect()not . to throw()。</p><p id="a3e3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在是HTML和请求代码。</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="ms mt l"/></div></figure><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="ms mt l"/></div></figure><h1 id="8a37" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">模拟响应</h1><p id="2a50" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">我们有一个HTTP请求。我们需要在表格中显示这个请求的结果。首先，我们需要将响应保存到视图中可访问的属性。让我们在组件中创建该属性，并编写一个测试来检查响应是否保存到新创建的属性中。</p><p id="1f5f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Github提供了很多关于回购的信息。我们将只使用几个字段。让我们创建一个简单的typescript接口，它只知道我们需要的属性。</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="fae6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用<a class="ae kw" href="https://angular.io/api/common/http/testing/HttpClientTestingModule" rel="noopener ugc nofollow" target="_blank"> HttpClientTestingModule </a>时，管理HTTP响应的所有责任都转移给了开发人员。除非在测试代码中显式发送响应，否则组件或服务不会运行对响应做出反应的代码。要发送响应，我们需要获取对<a class="ae kw" href="https://angular.io/api/common/http/testing/TestRequest" rel="noopener ugc nofollow" target="_blank"> TestRequest </a>的引用，并调用提供响应参数的方法<a class="ae kw" href="https://angular.io/api/common/http/testing/TestRequest#flush" rel="noopener ugc nofollow" target="_blank"> flush </a>。</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="6efd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于我们的场景，我们只需要提供一个响应体。在其他场景中，响应可能包含标题、文件、特定的状态文本或状态代码等。<a class="ae kw" href="https://angular.io/api/common/http/testing/TestRequest#flush" rel="noopener ugc nofollow" target="_blank"> flush </a>方法有一个到达签名，为开发人员提供了细化响应的能力。</p><p id="d4e3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们编写一个代码来通过测试。</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="48d9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">测试通过，在我们创建简单的HTML标记后，我们能够看到一些用户界面。</p><h1 id="29c0" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">错误处理</h1><p id="59e2" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">如果GitHub不知道用户，API会返回一个404状态码。让我们来处理这种情况，并显示一个友好的错误消息。</p><p id="debb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了发送错误而不是成功的响应，我们需要利用<a class="ae kw" href="https://angular.io/api/common/http/testing/TestRequest" rel="noopener ugc nofollow" target="_blank"> TestRequest </a>的<a class="ae kw" href="https://angular.io/api/common/http/testing/TestRequest#error" rel="noopener ugc nofollow" target="_blank"> error </a>方法。让我们做两个测试——一个检查当请求失败时错误消息是否显示，另一个检查当请求成功时错误消息是否隐藏。</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="2f9d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kw" href="https://angular.io/api/common/http/testing/TestRequest#error" rel="noopener ugc nofollow" target="_blank">错误</a>方法也有一个reach签名来细化响应。对于我们的场景，我们不需要太多—我们只需要发送任何带有错误的响应。现在让我们编写代码使测试工作。</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="ms mt l"/></div></figure><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="ms mt l"/></div></figure><h1 id="8f2d" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">HttpInterceptor</h1><p id="d8b5" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">当每个请求发生时，HttpInterceptor 允许执行代码。它还可以修改HTTP请求本身。GitHub API可以根据Accept头返回不同的响应。比方说，我们希望将所有对GitHub API的请求的Accept头设置为“application/vnd.github.v3+json”。最好的方法是利用<a class="ae kw" href="https://angular.io/api/common/http/HttpInterceptor" rel="noopener ugc nofollow" target="_blank"> HttpInterceptor </a>。</p><p id="b63e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了让拦截器处理请求，我们需要将它添加到需要拦截器的模块的providers数组中。这意味着为了测试，我们需要在测试模块配置中提供它。让我们也马上注入http客户端。稍后我们将使用它来发出请求。</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="cb24" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们首先编写测试。由于测试中所有的HTTP请求都需要Accept头，我们将创建一个简单的URL请求，从<a class="ae kw" href="https://api.github.com/" rel="noopener ugc nofollow" target="_blank">https://api.github.com/</a>开始，并检查它是否包含Accept头。另一个测试将检查对非GitHub API URL的请求是否不包含头。</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="02b6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们通过动词获取请求，而不是使用<a class="ae kw" href="https://angular.io/api/common/http/testing/HttpClientTestingModule" rel="noopener ugc nofollow" target="_blank"> expectOne </a>方法。这更方便，因为我们不关心网址。现在剩下的就是编写拦截器代码了。</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="ms mt l"/></div></figure><h1 id="c2b0" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">摘要</h1><p id="bcb5" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">在本文中，我们学习了如何测试HTTP请求，模拟HTTP响应和HTTP错误，测试HTTP拦截器。完全可以处理Angular应用程序中HTTP通信的测试。</p><p id="3c7c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">探索本文中使用的<a class="ae kw" href="https://github.com/IAfanasov/AngularHttpTesting" rel="noopener ugc nofollow" target="_blank">源代码</a>或者玩玩<a class="ae kw" href="https://stackblitz.com/github/IAfanasov/AngularHttpTesting" rel="noopener ugc nofollow" target="_blank"> stackblitz </a>。<br/> *** <br/> <em class="mu">原载于</em><a class="ae kw" href="https://www.mobiquity.com/insights/testing-angular-http-communication" rel="noopener ugc nofollow" target="_blank"><em class="mu">https://www . mobiquity . com/insights/testing-angular-http-communication</em></a></p></div></div>    
</body>
</html>