<html>
<head>
<title>Verifying Service Mesh TLS in Kubernetes, Using ksniff and Wireshark</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用ksniff和Wireshark验证Kubernetes中的服务网状TLS</h1>
<blockquote>原文：<a href="https://itnext.io/verifying-service-mesh-tls-in-kubernetes-using-ksniff-and-wireshark-2e993b26bf95?source=collection_archive---------4-----------------------#2019-09-03">https://itnext.io/verifying-service-mesh-tls-in-kubernetes-using-ksniff-and-wireshark-2e993b26bf95?source=collection_archive---------4-----------------------#2019-09-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="17e3" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">查看k8s集群内的加密流量</h2></div><p id="879e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">与来自<a class="ae le" href="https://www.hashicorp.com/" rel="noopener ugc nofollow" target="_blank"> HashiCorp </a>的<a class="ae le" href="https://twitter.com/sheriffjackson" rel="noopener ugc nofollow" target="_blank"> Nic Jackson </a>一起，我最近在几个会议和网络研讨会上讲述了在现代应用中，跨越端到端，或“<a class="ae le" href="https://www.cncf.io/event/securing-cloud-native-communication-from-end-user-to-service/" rel="noopener ugc nofollow" target="_blank">用户到服务</a>”的传输层加密的需求。针对从用户浏览器到应用边缘的流量的TLS加密(和终止)一直是API网关、cdn和边缘代理的长期特性，但直到最近，服务网格技术才使针对服务到服务流量实施TLS成为我们大多数人的现实方法。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/63261099fbab512cecb509e6cffc5719.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cKtjYloX-T_q-D8AlSWIfA.png"/></div></div></figure><p id="394c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">许多服务网格实施承诺低接触TLS实施，允许运营商通过单个配置选项或YAML文件中的几行来实现这一点。但是，您如何知道您的集群间流量确实被成功加密了呢？当然，您可以在Kubernetes集群中运行的Pod内启动<a class="ae le" href="https://www.tcpdump.org/" rel="noopener ugc nofollow" target="_blank"> tcpdump </a>，但是这可能很难管理，尤其是对于那些不太熟悉Linux工具的人来说。在最近的一系列服务网格调查和TLS调试之后，我遇到了来自<a class="ae le" href="https://twitter.com/d3bu9" rel="noopener ugc nofollow" target="_blank"> Eldad Rudich </a>的<a class="ae le" href="https://github.com/eldadru/ksniff" rel="noopener ugc nofollow" target="_blank">ksniff</a>T0】插件，它被证明是一个非常有用的工具，可以用来检查集群内的流量。</p><p id="8ccd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我想分享我从使用ksniff中学到的东西，并根据我最近对API网关和服务网格的第一个内部跳之间的TLS通信的研究，提供几个例子。</p><h1 id="ddc2" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">ksniff—Wireshark的所有优点，运行在Kubernetes</h1><p id="c0f5" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">根据该项目的GitHub repo，ksniff是一个“使用tcpdump和wireshark来缓解kubernetes pods上的嗅探的插件”。我使用tcpdump和Wireshark检查网络流量已经很多年了，但是我发现在Kubernetes中使用它有些棘手。使用一个简单的<code class="fe lr ls lt lu b">kubectl</code>插件，比如ksniff，几乎消除了配置这两个流量嗅探工具的所有手工操作。</p><p id="0910" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你可以使用<code class="fe lr ls lt lu b">kubectl</code>插件包管理器<a class="ae le" href="https://github.com/GoogleContainerTools/krew" rel="noopener ugc nofollow" target="_blank"> krew </a>安装ksniff:</p><pre class="lg lh li lj gt ms lu mt mu aw mv bi"><span id="9e71" class="mw lw it lu b gy mx my l mz na">$ kubectl krew install sniff</span></pre><p id="6528" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我以前也手动安装过ksniff(因为我想访问一个当时krew包中没有的特性)，这很容易做到，也有很好的文档记录。</p><p id="a8e6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你还需要在你的本地机器上安装<a class="ae le" href="https://www.wireshark.org/" rel="noopener ugc nofollow" target="_blank"> Wireshark </a>。我通常是通过网站下载完成的，但是你也可以通过大多数包管理器找到Wireshark，比如apt和brew。</p><p id="da9a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在您已经安装了工具，让我们来进行一次演示。</p><h1 id="231b" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">嗅探未加密的边缘到服务流量</h1><p id="7db1" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">我已经通过Helm将<a class="ae le" href="https://www.getambassador.io/" rel="noopener ugc nofollow" target="_blank">大使API网关</a>和<a class="ae le" href="https://www.hashicorp.com/products/consul/service-mesh" rel="noopener ugc nofollow" target="_blank">哈希公司的领事服务网格</a>部署到GKE托管的Kubernetes集群中。由于<a class="ae le" href="https://www.consul.io/docs/platform/k8s/ambassador.html" rel="noopener ugc nofollow" target="_blank"> Ambassador和Consul </a>之间的集成，我可以向通过Ambassador公开的API端点(管理GCP负载平衡器)发出请求，并通过TLS连接将该请求从网关动态路由到Consul管理的任何内部服务。我还可以使用Consul作为Ambassador的简单服务发现机制，它支持流量的动态路由，但不使用传输加密。让我们先这样做，因为这样您可以通过ksniff看到未加密的流量。</p><p id="e298" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我已经安装了Ambassador、Consul和一个“当前引用(QOTM)”服务，如<a class="ae le" href="https://www.getambassador.io/user-guide/consul/" rel="noopener ugc nofollow" target="_blank">网关/网格集成文档</a>的前半部分所述。在我的集群中，我看到以下服务正在运行:</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi nb"><img src="../Images/ba47bc475852a56d9794763f224873f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*JNhNkRlBWNPjAVFm"/></div></div></figure><p id="75eb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我可以向通过<code class="fe lr ls lt lu b">/qotm-consul/</code>端点公开的QOTM应用程序发出外部请求，该端点通过Ambassador和Consul路由</p><pre class="lg lh li lj gt ms lu mt mu aw mv bi"><span id="aad1" class="mw lw it lu b gy mx my l mz na">$ curl -v 34.67.222.12/qotm-consul/<br/>*   Trying 34.67.222.12...<br/>* TCP_NODELAY set<br/>* Connected to 34.67.222.12 (34.67.222.12) port 80 (#0)<br/>&gt; GET /qotm-consul/ HTTP/1.1<br/>&gt; Host: 34.67.222.12<br/>&gt; User-Agent: curl/7.54.0<br/>&gt; Accept: */*<br/>&gt; <br/>&lt; HTTP/1.1 200 OK<br/>&lt; content-type: application/json<br/>&lt; content-length: 174<br/>&lt; server: envoy<br/>&lt; date: Mon, 05 Aug 2019 08:30:18 GMT<br/>&lt; x-envoy-upstream-service-time: 1<br/>&lt; <br/>{"hostname":"qotm-7fcb555cdf-xb27c","ok":true,"quote":"Nihilism gambles with lives, happiness, and even destiny itself!","time":"2019-08-05T08:30:18.802450","version":"1.7"}<br/>* Connection #0 to host 34.67.222.12 left intact</span></pre><p id="dec2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个请求看起来一切都很好，读了这段话后，我已经开始觉得自己更聪明了……:)</p><p id="7106" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们发出另一个请求，但是通过ksniff查看内部集群间网络流量。首先，我需要获得QOTM服务的Pod的名称，因为这是我将连接ksniff的地方:</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi nc"><img src="../Images/687b27efea601e0079d2e81c7f8f486d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ddjoe6KCB-aEM3Av.png"/></div></div></figure><p id="aa06" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，我可以通过本地机器用一个简单的命令将ksniff连接到这个Pod:</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi nd"><img src="../Images/59b798b5bdd05a8776b08817a4d8778e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*_3qgYKJuZkrpY_n9.png"/></div></div></figure><p id="287a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以在CLI输出中看到所有tcpdump配置，如果一切顺利，Wireshark应该会启动，这将显示以下窗口:</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi ne"><img src="../Images/81d192ebe962c6d570580bd32462bc17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zMBmnbclaWT5tW5k"/></div></div></figure><p id="9606" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Wireshark用户界面起初看起来有点令人生畏，但实际上并不复杂。顶部的菜单栏允许您开始和停止网络流量捕获，还可以搜索和导航捕获的流量数据。菜单栏正下方还有一个显示过滤器。顶部窗口显示流入和流出Pod网络接口的流量数据包，中间窗口提供流量概述(如协议详细信息和报头元数据)，底部窗口显示流量数据包内容。</p><p id="817b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以应用显示过滤器，只显示http流量，只需在过滤器框(菜单栏下方)中键入“HTTP”并按回车键即可。现在，如果您通过网关发出请求，您应该看到Pod处理这个请求并生成响应:</p><pre class="lg lh li lj gt ms lu mt mu aw mv bi"><span id="c614" class="mw lw it lu b gy mx my l mz na">$ curl 34.67.222.12/qotm-consul/<br/>{“hostname”:”qotm-7fcb555cdf-xb27c”,”ok”:true,”quote”:”Nihilism gambles with lives, happiness, and even destiny itself!”,”time”:”2019–08–05T08:40:28.469624",”version”:”1.7"}</span></pre><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi nf"><img src="../Images/d1afec15f76fdd8b386ec3edf6e24fd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2OY1xUd5Hoxa7LB-"/></div></div></figure><p id="001e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以忽略大量的<code class="fe lr ls lt lu b">GET /health HTTP</code>请求，因为这些请求是通过Kubernetes节点的kubelet生成的，在kube let中部署了这个Pod，这是部署就绪检查的结果。</p><p id="4d72" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有意思的是<code class="fe lr ls lt lu b">GET / HTTP request</code>，用红框突出显示。您可以看到入站HTTP请求来自<code class="fe lr ls lt lu b">10.60.2.2</code>，这将导致一个响应，其中包含由Python服务器(通过第一个红色箭头显示)生成的200 HTTP状态代码，该服务器是QOTM服务，HTTP有效负载(通过第二个红色箭头显示)与您向集群发出curl请求时看到的结果相同。</p><p id="9a02" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我查看所有Pod的配置，我可以看到集群内的<code class="fe lr ls lt lu b">10.60.2.2</code>流量源IP属于大使Pod，而<code class="fe lr ls lt lu b">10.60.1.6</code>的目的地属于QOTM Pod。这似乎是合理的，因为我提出了一个外部请求，即Ambassador通过Consul服务查找路由到Pod IP。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi nb"><img src="../Images/df6cbd6aa2452369193de1f96cb60ab2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*rJW_WqEpsKfuC8zl"/></div></div></figure><p id="8b51" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这一点上，我鼓励您向集群发出更多的请求，也许部署您自己的服务，并继续探索集群中流动的请求。</p><p id="8a63" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在让我们启用大使和领事服务网状mTLS集成，这将加密来自边缘和服务到服务的所有流量，并查看使用此配置生成的流量。</p><h1 id="fe58" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">加密边缘到服务流量达到峰值</h1><p id="e046" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">为了简单起见，我建议终止您当前与QOTM Pod的ksniff连接，并从您的Kubernetes集群中删除当前的QOTM服务和地图。</p><p id="ff7e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">之后，您可以返回到大使和领事集成文档中的<a class="ae le" href="https://www.getambassador.io/user-guide/consul/#encrypted-tls" rel="noopener ugc nofollow" target="_blank">“加密”部分，并安装第二版的QOTM服务，该服务使用领事连接和特使侧车来管理进出pod的所有流量处理(如果您正在跟进，请不要忘记应用<code class="fe lr ls lt lu b">ambassador-consul-connector.yaml</code>，因为没有它，演示将无法工作)。</a></p><p id="22c1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一旦一切就绪并开始运行，您应该能够通过新的端点<code class="fe lr ls lt lu b">/qotm-consul-tls/</code>向这个修改后的服务版本发出请求</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi ng"><img src="../Images/9e1ddfcaf64352f8bdac05a40a1e28d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*yjptwFyvqFxEvvvb.png"/></div></div></figure><p id="767b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在让我们将ksniff连接到您的新QOTM吊舱。如果你在豆荚处检查，你会注意到这个版本的QOTM有两个容器，一个用于QOTM服务，一个用于领事管理的特使边车:</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi nc"><img src="../Images/cc259ea0403b9ae69cf1c4c6997da13e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*evy5PhZ-5LIHiuVx.png"/></div></div></figure><p id="6c80" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以描述pod来获取容器名称，这也将显示一些关于如何使用init-container引导Envoy sidecar的有趣信息:</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi nh"><img src="../Images/bc6ba60b73d6ede141e7168de6321996.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*jme-uXQHerOQUeYj.png"/></div></div></figure><p id="5e4b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面突出显示了Envoy sidecar init容器中有趣的细节，它显示了启动时生成并加载到sidecar中的Envoy配置。您可以看到我的QOTM服务在端口5000上侦听的详细信息，还可以看到Envoy sidecar将在Pod的网络接口上侦听端口20000。请记下这一点，因为您将在稍后的博客文章中使用这些信息。</p><pre class="lg lh li lj gt ms lu mt mu aw mv bi"><span id="a081" class="mw lw it lu b gy mx my l mz na">...<br/>      cat &lt;&lt;EOF &gt;/consul/connect-inject/service.hcl<br/>      services {<br/>        id   = "${POD_NAME}-qotm-sidecar-proxy"<br/>        name = "qotm-sidecar-proxy"<br/>        kind = "connect-proxy"<br/>        address = "${POD_IP}"<br/>        port = 20000<br/>      <br/>        proxy {<br/>          destination_service_name = "qotm"<br/>          destination_service_id = "qotm"<br/>          local_service_address = "127.0.0.1"<br/>          local_service_port = 5000<br/>          <br/>        }<br/>...</span></pre><p id="c663" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果此时您不想使用完整的describe命令，您还可以使用一点<code class="fe lr ls lt lu b">kubectl</code>魔法从标有“qotm-mtls”的Pod中获取容器名称:</p><pre class="lg lh li lj gt ms lu mt mu aw mv bi"><span id="acb0" class="mw lw it lu b gy mx my l mz na">$ kubectl get pods -l app=qotm-mtls -o jsonpath={.items[].spec.containers[*].name}qotm consul-connect-envoy-sidecar</span></pre><p id="8141" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这里你可以看到领事注入特使边车被称为“领事-连接-特使-边车”。</p><p id="11b5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">将ksniff连接到具有多个容器的Pod时，您需要指定要连接到哪个容器。由于一个Pod中的所有容器共享一个网络名称空间，因此容器的选择通常取决于您可以成功附加到哪个容器，例如，哪个容器具有正确的权限并且没有运行临时基础映像等(在下面的“高级技术”部分中可以找到更多信息)。</p><p id="9e47" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我现在将ksniff连接到我的QOTM吊舱和特使边车集装箱:</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi ni"><img src="../Images/a8cd622b45bfa2d549258fbe00046e6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*dKPIYk6TV2y1x00u.png"/></div></div></figure><p id="e699" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我将“http”过滤器添加到Wireshark，并向我的QOTM服务发出请求，我会看到以下内容:</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi nj"><img src="../Images/6a4b539964fe6fcc0df96a228a4ddd80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*hmm4Bu-y55JB1Syn.png"/></div></div></figure><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi nf"><img src="../Images/baf44c20fb990589e18c53065e38f21e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hWPa3ic3-b_blpJh"/></div></div></figure><p id="3911" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">除了注意源和目的IP地址:它们都是<code class="fe lr ls lt lu b">127.0.0.1</code>之外，一切看起来与前面的例子非常相似。您在这里看到的是领事特使sidecar和QOTM服务之间的未加密流量，它们通过Pod的本地主机环回适配器进行通信。这在容器之间是可行的，因为一个Pod中的所有容器共享一个网络名称空间。顺便提一下，值得注意的是，在生产中，QOTM服务应该只绑定到Pod的环回适配器，因为您不希望Pod之外的任何进程通过不安全的传输介质(即HTTP)与它通信。然而，这将意味着HTTP准备就绪检查(通过节点的kubelet进行)不起作用，因此您必须使用其他形式的<a class="ae le" href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-probes/" rel="noopener ugc nofollow" target="_blank">准备就绪检查</a>。</p><p id="efc2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">看到到QOTM服务的未加密通信只发生在环回适配器上只是TLS验证过程的一部分。理想情况下，您希望看到加密流量在集群中流动。您可以通过删除“http”过滤器来做到这一点，而是添加一个显示过滤器，只显示带有您的QOTM Pod的目的IP地址和目标端口20000的TCP流量，您可以看到Envoy sidecar正在通过之前发出的<code class="fe lr ls lt lu b">kubectl</code> describe命令侦听该流量。</p><p id="2aaa" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您的速度很快(因为通常有大量运行状况检查流量在群集中流动)，您应该能够看到如下内容:</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi nf"><img src="../Images/0630b1a65f331ac1e977750971b0fe88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bdGszR2f7-ZJetW5"/></div></div></figure><p id="c6ec" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">虽然这不像HTTP流量那样容易阅读，但您可以清楚地看到大使Pod(在<code class="fe lr ls lt lu b">10.60.0.11</code>)向我的QOTM应用程序(在<code class="fe lr ls lt lu b">10.60.2.7</code>)发起的“Client Hello”TLS握手，然后是一系列使用TLSv1.2协议的其他数据包，其中包含不可读的加密数据。</p><p id="7af0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这就是了。将两个结果放在一起，一个是QOTM通过Pod的环回适配器响应领事使团代理的请求，另一个是大使Pod通过TLS与QOTM领事使团侧车通信，这应该证明您已经正确配置了TLS。</p><h1 id="8152" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">先进的技术</h1><p id="b51e" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">有几个主题超出了这篇博文的范围，但是我可以在以后的文章中探索它们(如果您对此感兴趣，请告诉我！).第一种是使用Wireshark进行额外的<a class="ae le" href="https://www.wireshark.org/docs/wsug_html_chunked/ChWorkDisplayFilterSection.html" rel="noopener ugc nofollow" target="_blank">高级过滤</a>，这在您试图调试不同IP和端口上公开的特定服务时会很有用。同样有趣的是，<a class="ae le" href="https://redflagsecurity.net/2019/03/10/decrypting-tls-wireshark/" rel="noopener ugc nofollow" target="_blank">解密在集群中流动的TLS流量</a>的能力，例如，通过将Consul提供的私钥加载到Wireshark中。最后，ksniff还能够在<a class="ae le" href="https://github.com/eldadru/ksniff#user-content-non-privileged-and-scratch-pods" rel="noopener ugc nofollow" target="_blank">特权模式</a>下执行，以便嗅探从零开始构建的容器中的流量，或者不允许附加进程。</p><h1 id="56a7" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><p id="3347" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">在探索<a class="ae le" href="https://www.getambassador.io/" rel="noopener ugc nofollow" target="_blank"> Ambassador </a> API与各种服务网格的集成时，我发现ksniff是一个非常有价值的工具，比如<a class="ae le" href="https://www.getambassador.io/user-guide/consul" rel="noopener ugc nofollow" target="_blank">consult</a>、<a class="ae le" href="https://linkerd.io/2/tasks/using-ingress/#ambassador" rel="noopener ugc nofollow" target="_blank"> Linkerd </a>和<a class="ae le" href="https://www.getambassador.io/user-guide/with-istio/" rel="noopener ugc nofollow" target="_blank"> Istio </a>。当然，您可以使用tcpdump，但是我发现配置它有时很有挑战性，而且我喜欢Wireshark提供的强大GUI。</p><p id="d4c6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我还想对ksniff的创造者Eldad Rudich表示感谢，感谢他创造了这个工具，也感谢他帮助回答了我的几个问题。</p><p id="523e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你想问关于这个的任何问题，你可以在Twitter上的<a class="ae le" href="https://twitter.com/danielbryantuk" rel="noopener ugc nofollow" target="_blank"> @danielbryantuk </a>找到我，或者在<a class="ae le" href="http://d6e.co/slack" rel="noopener ugc nofollow" target="_blank"> Datawire OSS Slack </a>上使用相同的句柄。</p></div></div>    
</body>
</html>