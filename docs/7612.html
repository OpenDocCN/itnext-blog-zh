<html>
<head>
<title>Trapping Hackers with Containerized Deception</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用集装箱式欺骗诱捕黑客</h1>
<blockquote>原文：<a href="https://itnext.io/trapping-hackers-with-containerized-deception-7a52c78285aa?source=collection_archive---------0-----------------------#2022-11-24">https://itnext.io/trapping-hackers-with-containerized-deception-7a52c78285aa?source=collection_archive---------0-----------------------#2022-11-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="0937" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">码头深水潜水</h2><div class=""/><div class=""><h2 id="4f76" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">使用Docker部署高交互蜜罐的终极指南</h2></div><h1 id="93f7" class="kr ks it bd kt ku kv kw kx ky kz la lb ki lc kj ld kl le km lf ko lg kp lh li bi translated">TL；速度三角形定位法(dead reckoning)</h1><p id="2477" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">这个故事探索了利用容器化的现代蜜罐，通过遍历一个高交互蜜罐的设计，可以使用任意Docker容器来引诱恶意攻击。</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi mf"><img src="../Images/ea8a3973844837568fccd35cf1c1216e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*h0h6Zb6TppnzGvtD"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">照片由克林特·帕特森 / <a class="ae mv" href="https://unsplash.com/?utm_source=ghost&amp;utm_medium=referral&amp;utm_campaign=api-credit" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><h1 id="bba1" class="kr ks it bd kt ku kv kw kx ky kz la lb ki lc kj ld kl le km lf ko lg kp lh li bi translated">介绍</h1><p id="8b74" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">虽然蜜罐已经存在了很长一段时间，但这个故事将试图提供一个新的视角，看看集装箱化是如何影响我们今天在集装箱化环境中使用蜜罐的方式的。诚然，从2005年开始，我就没有再探讨过这个话题。因此，当我在研究实现一些同样有价值和有趣的东西时，我遇到了至少六次错误的开始。我认为，像计算的其他领域一样，先进的蜜罐系统会在开源社区中大量存在。但是，我想我低估了这个主题的深奥本质，以及它严密保护的商业可行性。</p><p id="f925" class="pw-post-body-paragraph lj lk it ll b lm mw kd lo lp mx kg lr ls my lu lv lw mz ly lz ma na mc md me im bi translated">自2005年以来，发生了很多变化，但也有很多保持不变。蜜罐不是一个复杂的概念；它是一个系统或服务，故意将自己暴露给攻击者，以便当有人试图闯入时可以被检测到。与入侵检测系统不同，蜜罐可以是简单的几行代码，将自己伪装成系统上易受攻击的开放端口，也可以是成熟的操作系统，带有分析行为模式的秘密日志记录系统。</p><p id="02d2" class="pw-post-body-paragraph lj lk it ll b lm mw kd lo lp mx kg lr ls my lu lv lw mz ly lz ma na mc md me im bi translated">然而，随着开发人员和系统专家将容器化融入到他们的设计中，许多使用蜜罐的传统方法变得不那么有效了。在2005年，部署蜜罐通常只需一次，通常放置在网络其他部分容易访问的地方。但是对于容器化的系统，由于它们与网络和其他服务隔离，部署蜜罐同样变得毫无用处。</p><p id="3c93" class="pw-post-body-paragraph lj lk it ll b lm mw kd lo lp mx kg lr ls my lu lv lw mz ly lz ma na mc md me im bi translated">虽然开发人员精通技术，但通常情况下他们并不了解安全性。即使他们是，优先考虑方便也是很常见的。这使得确保Docker的安全成为具有安全意识的DevOps专业人员的一个更加重要的部分。对于负担过重的系统管理员来说也是如此，他们采取不重视安全性的方法来快速完成工作。</p><p id="0bd5" class="pw-post-body-paragraph lj lk it ll b lm mw kd lo lp mx kg lr ls my lu lv lw mz ly lz ma na mc md me im bi translated">大部分问题源于这样一个事实，即开发人员通常对公司内部的计算资源有很高的访问权限。系统管理员必然比开发人员拥有更高的访问级别。他们不仅可以访问系统中的所有源代码，还可以测试数据库，而且在许多情况下，尤其是在DevOps环境中，他们甚至可以访问生产系统。此外，出于测试目的，开发人员需要执行许多在安全软件看来可疑的任务，这为禁用安全软件提供了理由。这使得恶意软件和攻击者更容易感染系统硬件。</p><p id="423a" class="pw-post-body-paragraph lj lk it ll b lm mw kd lo lp mx kg lr ls my lu lv lw mz ly lz ma na mc md me im bi translated">在本地windows环境中运行Docker的情况下，正如许多开发人员出于开发目的所做的那样，不能相信所有的开发系统都会遵守适当的安全配置。在我的例子中，出于测试的目的，我经常在主机上启用Docker remote API，并让它保持启用状态，这可能是出于遗忘，也可能是为了方便。</p><h1 id="0dc4" class="kr ks it bd kt ku kv kw kx ky kz la lb ki lc kj ld kl le km lf ko lg kp lh li bi translated">欺骗系统概述</h1><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi mf"><img src="../Images/52f066dacc1dc0e4c18f760faa767f5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*CBEd2KrPMY62oYPY"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">照片由<a class="ae mv" href="https://unsplash.com/@arget?utm_source=ghost&amp;utm_medium=referral&amp;utm_campaign=api-credit" rel="noopener ugc nofollow" target="_blank">阿吉特</a> / <a class="ae mv" href="https://unsplash.com/?utm_source=ghost&amp;utm_medium=referral&amp;utm_campaign=api-credit" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><h2 id="fbfb" class="nb ks it bd kt nc nd dn kx ne nf dp lb ls ng nh ld lw ni nj lf ma nk nl lh iz bi translated">蜜罐</h2><p id="3034" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">蜜罐可以与网络中不同类型的系统一起部署。它们是诱饵，旨在引诱攻击者和恶意软件，以便可以检测、记录和跟踪源头。蜜罐有各种类型。高交互蜜罐被设计为作为一种服务运行，并意味着足够复杂，以欺骗系统认为它是一个全功能的操作系统或设备。中间交互蜜罐模拟应用层的某些方面，但不太复杂，因此更难被轻易攻破。我们将在本文中讨论的低交互蜜罐易于部署和维护，同时作为一个简单的早期预警系统，防止环境中更关键的系统受到感染。</p><h2 id="9f5f" class="nb ks it bd kt nc nd dn kx ne nf dp lb ls ng nh ld lw ni nj lf ma nk nl lh iz bi translated">蜜网</h2><p id="5479" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">蜜网是一个蜜罐的集合，旨在战略性地跟踪恶意软件和攻击者的方法和技术。这种方法允许管理员观察黑客和恶意代码利用系统的各种漏洞，并可用于生产或研究目的，以发现新的漏洞和攻击。</p><h2 id="2ac0" class="nb ks it bd kt nc nd dn kx ne nf dp lb ls ng nh ld lw ni nj lf ma nk nl lh iz bi translated">基本用例</h2><p id="8d84" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">蜜罐的优势在于不需要关于网络攻击方法的详细知识。对于低交互的蜜罐来说尤其如此，蜜罐是相对简单的应用程序，它位于一个端口上监听，通常很少模仿原始服务。他们记录访问尝试，其他什么也不做。在收集某些类型的访问信息时，或者在出现任何严重问题之前，作为受损服务的早期警告，这种数据收集可能是非常宝贵的。</p><h1 id="760a" class="kr ks it bd kt ku kv kw kx ky kz la lb ki lc kj ld kl le km lf ko lg kp lh li bi translated">背景</h1><h2 id="9381" class="nb ks it bd kt nc nd dn kx ne nf dp lb ls ng nh ld lw ni nj lf ma nk nl lh iz bi translated">脆弱点</h2><p id="5bfd" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">使用容器作为蜜罐已经引起了一些争论，因为容器化技术与完全虚拟化相比还不成熟。一些管理员也很容易忽略潜在的配置问题，如下所示。</p><h2 id="256a" class="nb ks it bd kt nc nd dn kx ne nf dp lb ls ng nh ld lw ni nj lf ma nk nl lh iz bi translated">Docker引擎API</h2><p id="adbb" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">API是应用程序的编程接口。它是一种协议；规则集；有时是抽象的，但不管实现如何，它总是不同类型的程序相互对话的标准方法。REST代表“代表性状态转移”。这是一个标准，开发人员可以使用它来获取信息并与其他应用程序交换信息，以特定URL的形式发送信息请求，同时在返回响应的主体中接收数据。</p><p id="3937" class="pw-post-body-paragraph lj lk it ll b lm mw kd lo lp mx kg lr ls my lu lv lw mz ly lz ma na mc md me im bi translated">Docker引擎API由Docker CLI用来管理对象。虽然在Linux系统上默认启用UNIX套接字(<code class="fe nm nn no np b">unix:///var/run/docker.sock</code>)，但在Windows系统上默认启用TCP套接字(<code class="fe nm nn no np b">tcp://127.0.0.1:2376</code>)。在Linux系统上，出于开发和自动化的目的，这个API也可以作为REST API被远程应用程序直接访问，方法是允许它被TCP套接字使用。</p><h2 id="3a77" class="nb ks it bd kt nc nd dn kx ne nf dp lb ls ng nh ld lw ni nj lf ma nk nl lh iz bi translated">基础图像</h2><p id="4f11" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">今天发现的大多数漏洞都存在于基础映像本身。对于Docker，基本映像由一个操作系统组成，通常是从Docker Hub上的另一个流行映像定制的。恶意的或意外的定制，以及原始的基础映像，为攻击创造了大量的机会，有时甚至是最新手的黑客。</p><h2 id="afec" class="nb ks it bd kt nc nd dn kx ne nf dp lb ls ng nh ld lw ni nj lf ma nk nl lh iz bi translated">码头枢纽</h2><p id="4167" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">虽然Docker Hub过去已经删除了恶意的Docker容器，但作为一个社区存储库，它很容易被滥用和攻击。上传到Docker Hub的基本映像应谨慎使用。但是，考虑到许多管理员认为便利性往往大于风险，采取谨慎的安全措施来降低攻击风险是有道理的。</p><h1 id="4b27" class="kr ks it bd kt ku kv kw kx ky kz la lb ki lc kj ld kl le km lf ko lg kp lh li bi translated">著名的蜜罐系统</h1><p id="3a01" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">有许多蜜罐系统在普遍使用，但是，很少专门针对或唯一受益于集装箱化的使用。以下两个开源包是明显的例外。</p><h2 id="c172" class="nb ks it bd kt nc nd dn kx ne nf dp lb ls ng nh ld lw ni nj lf ma nk nl lh iz bi translated">现代蜂蜜网</h2><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi mf"><img src="../Images/9f0e7c583e7700197229a80fae9fa686.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*HQ_dCTET8QaCFqUy.png"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">作者截图</figcaption></figure><p id="1689" class="pw-post-body-paragraph lj lk it ll b lm mw kd lo lp mx kg lr ls my lu lv lw mz ly lz ma na mc md me im bi translated">MHN对于容器集成有很大的潜力，但是官方并不支持它运行Docker。作为一个全面的蜜网管理系统，蜜罐可以作为K8s配置的一部分轻松部署。特别是从内部网络来源收集的蜜罐数据，对于保护分布式容器环境非常有价值。</p><h2 id="f402" class="nb ks it bd kt nc nd dn kx ne nf dp lb ls ng nh ld lw ni nj lf ma nk nl lh iz bi translated">Oncyberblog的捕鲸船:一个Docker API蜜罐</h2><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/78f949063b42a452c337b6525aac8675.png" data-original-src="https://miro.medium.com/v2/resize:fit:1366/format:webp/0*oN3an_evb-NKC4tf.png"/></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">作者截图</figcaption></figure><p id="7d61" class="pw-post-body-paragraph lj lk it ll b lm mw kd lo lp mx kg lr ls my lu lv lw mz ly lz ma na mc md me im bi translated">十几个GitHub库都以Whaler为名，然而<a class="ae mv" href="https://github.com/oncyberblog" rel="noopener ugc nofollow" target="_blank"> Oncyberblog </a>的这个实际上是这个故事的预计竞争者。这个项目是独一无二的，因为它试图引诱攻击者使用暴露的Docker引擎API。然而，它也有其局限性。首先，因为它运行的是嵌入式Docker容器，Docker必须在其主机上以特权模式运行。这是一个问题，因为这是一个巨大的安全风险，可能会危及主机的安全。因此，有必要采取预防措施，将其安装在一个隔离且安全的主机上。系统要求不高，所以主机不需要很大。但是，由于您需要监控主要主机上的单个容器，因此您需要一种方法来将隔离的蜜罐主机链接到被监控的应用程序容器所在的应用程序主机。</p><h1 id="6258" class="kr ks it bd kt ku kv kw kx ky kz la lb ki lc kj ld kl le km lf ko lg kp lh li bi translated">系统概况</h1><p id="2fed" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">这个项目快速利用了传统的Linux内部机制来处理容器编排、负载平衡和安全性。有关更多信息、源代码和更新，请参见为本文创建的配套GitHub资源库<a class="ae mv" href="https://github.com/mrhavens/DockerTrap" rel="noopener ugc nofollow" target="_blank"> DockerTrap </a>。</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi nr"><img src="../Images/3cbe9eb48aa82de4bf59166d610f6b17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*on3Xn0Jq5ViZpNLD.png"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">作者图表</figcaption></figure><h1 id="f6c8" class="kr ks it bd kt ku kv kw kx ky kz la lb ki lc kj ld kl le km lf ko lg kp lh li bi translated">系统配置</h1><h2 id="3636" class="nb ks it bd kt nc nd dn kx ne nf dp lb ls ng nh ld lw ni nj lf ma nk nl lh iz bi translated">更改主机上SSH的默认端口</h2><p id="ffac" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">在做其他事情之前，将默认端口<code class="fe nm nn no np b">22</code>改为其他端口，比如<code class="fe nm nn no np b">2222</code>。系统将使用端口<code class="fe nm nn no np b">22</code>引诱攻击者，因此该端口应该被释放使用。</p><h2 id="ebfd" class="nb ks it bd kt nc nd dn kx ne nf dp lb ls ng nh ld lw ni nj lf ma nk nl lh iz bi translated">安装Docker</h2><pre class="mg mh mi mj gt ns np nt bn nu nv bi"><span id="4cbb" class="nw ks it np b be nx ny l nz oa">sudo apt -y install apt-transport-https ca-certificates curl software-properties-common<br/>curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -<br/>sudo add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu bionic stable"<br/>sudo apt update<br/>apt-cache policy docker-ce<br/>sudo apt -y install docker-ce</span></pre><h2 id="874b" class="nb ks it bd kt nc nd dn kx ne nf dp lb ls ng nh ld lw ni nj lf ma nk nl lh iz bi translated">安装支持系统工具</h2><pre class="mg mh mi mj gt ns np nt bn nu nv bi"><span id="15b0" class="nw ks it np b be nx ny l nz oa">sudo apt update<br/>sudo apt -y install socat xinetd auditd netcat-openbsd</span></pre><h2 id="d931" class="nb ks it bd kt nc nd dn kx ne nf dp lb ls ng nh ld lw ni nj lf ma nk nl lh iz bi translated">配置<code class="fe nm nn no np b">xinetd</code></h2><p id="6529" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">这个系统使用下面的bash脚本，由<code class="fe nm nn no np b">xinetd</code>管理，每当端口<code class="fe nm nn no np b">22</code>请求一个传入连接时，就启动容器。</p><p id="083b" class="pw-post-body-paragraph lj lk it ll b lm mw kd lo lp mx kg lr ls my lu lv lw mz ly lz ma na mc md me im bi translated">下面的<code class="fe nm nn no np b">bash</code>脚本应该作为具有<code class="fe nm nn no np b">755</code>权限和根用户所有权的<code class="fe nm nn no np b">/usr/bin/honeypot</code>对<code class="fe nm nn no np b">xinetd</code>可用。</p><p id="191c" class="pw-post-body-paragraph lj lk it ll b lm mw kd lo lp mx kg lr ls my lu lv lw mz ly lz ma na mc md me im bi translated">应该将<code class="fe nm nn no np b">EXT_IFACE</code>变量更改为与您希望在端口<code class="fe nm nn no np b">22</code>上接收传入ssh连接的设备相对应的接口。</p><pre class="mg mh mi mj gt ns np nt bn nu nv bi"><span id="f646" class="nw ks it np b be nx ny l nz oa"><br/>#!/bin/bash<br/><br/>EXT_IFACE=ens4<br/>MEM_LIMIT=128M<br/>SERVICE=22<br/><br/>QUOTA_IN=5242880<br/>QUOTA_OUT=1310720<br/>REMOTE_HOST=`echo ${REMOTE_HOST} | grep -o '[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}'`<br/><br/>{<br/>    CONTAINER_NAME="honeypot-${REMOTE_HOST}"<br/>    HOSTNAME=$(/bin/hostname)<br/>    # check if the container exists<br/>    if ! /usr/bin/docker inspect "${CONTAINER_NAME}" &amp;&gt; /dev/null; then<br/>        # create new container<br/>        CONTAINER_ID=$(/usr/bin/docker run --name ${CONTAINER_NAME} -h ${HOSTNAME} -e "REMOTE_HOST=${REMOTE_HOST}" -m ${MEM_LIMIT} -d -i honeypot ) ##/sbin/init)<br/>        CONTAINER_IP=$(/usr/bin/docker inspect --format '{{ .NetworkSettings.IPAddress }}' ${CONTAINER_ID})<br/>        PROCESS_ID=$(/usr/bin/docker inspect --format '{{ .State.Pid }}' ${CONTAINER_ID})<br/><br/>        # drop all inbound and outbound traffic by default<br/>        /usr/bin/nsenter --target ${PROCESS_ID} -n /sbin/iptables -P INPUT DROP<br/>        /usr/bin/nsenter --target ${PROCESS_ID} -n /sbin/iptables -P OUTPUT DROP<br/><br/>        # allow access to the service regardless of the quota<br/>        /usr/bin/nsenter --target ${PROCESS_ID} -n /sbin/iptables -A INPUT -p tcp -m tcp --dport ${SERVICE} -j ACCEPT<br/>        /usr/bin/nsenter --target ${PROCESS_ID} -n /sbin/iptables -A INPUT -m quota --quota ${QUOTA_IN} -j ACCEPT<br/><br/>        # allow related outbound access limited by the quota<br/>        /usr/bin/nsenter --target ${PROCESS_ID} -n /sbin/iptables -A OUTPUT -p tcp --sport ${SERVICE} -m state --state ESTABLISHED,RELATED -m quota --quota ${QUOTA_OUT} -j ACCEPT<br/><br/>        # enable the host to connect to rsyslog on the host<br/>        /usr/bin/nsenter --target ${PROCESS_ID} -n /sbin/iptables -A OUTPUT -p tcp -m tcp --dst 172.17.0.1 --dport 514 -j ACCEPT<br/><br/>        # add iptables redirection rule<br/>        /sbin/iptables -t nat -A PREROUTING -i ${EXT_IFACE} -s ${REMOTE_HOST} -p tcp -m tcp --dport ${SERVICE} -j DNAT --to-destination ${CONTAINER_IP}<br/>        /sbin/iptables -t nat -A POSTROUTING -j MASQUERADE<br/>    else<br/>        # start container if exited and grab the cid<br/>        /usr/bin/docker start "${CONTAINER_NAME}" &amp;&gt; /dev/null<br/>        CONTAINER_ID=$(/usr/bin/docker inspect --format '{{ .Id }}' "${CONTAINER_NAME}")<br/>        CONTAINER_IP=$(/usr/bin/docker inspect --format '{{ .NetworkSettings.IPAddress }}' ${CONTAINER_ID})<br/><br/>        # add iptables redirection rule<br/>        /sbin/iptables -t nat -A PREROUTING -i ${EXT_IFACE} -s ${REMOTE_HOST} -p tcp -m tcp --dport ${SERVICE} -j DNAT --to-destination ${CONTAINER_IP}<br/>        /sbin/iptables -t nat -A POSTROUTING -j MASQUERADE<br/>    fi<br/>    echo ${CONTAINER_IP}<br/>} &amp;&gt; /dev/null<br/><br/># forward traffic to the container<br/>exec /usr/bin/socat stdin tcp:${CONTAINER_IP}:22,retry=60</span></pre><p id="cd3e" class="pw-post-body-paragraph lj lk it ll b lm mw kd lo lp mx kg lr ls my lu lv lw mz ly lz ma na mc md me im bi translated">以下服务文件应创建为<code class="fe nm nn no np b">/etc/xinetd.d/honeypot</code>:</p><pre class="mg mh mi mj gt ns np nt bn nu nv bi"><span id="2766" class="nw ks it np b be nx ny l nz oa"># Container launcher for an SSH honeypot <br/>service honeypot<br/>{<br/>        disable         = no<br/>        instances       = UNLIMITED<br/>        server          = /usr/bin/honeypot<br/>        socket_type     = stream<br/>        protocol        = tcp<br/>        port            = 22<br/>        user            = root<br/>        wait            = no<br/>        log_type        = SYSLOG authpriv info<br/>        log_on_success  = HOST PID<br/>        log_on_failure  = HOST<br/>}</span></pre><p id="003a" class="pw-post-body-paragraph lj lk it ll b lm mw kd lo lp mx kg lr ls my lu lv lw mz ly lz ma na mc md me im bi translated">然后，<code class="fe nm nn no np b">/etc/services</code>应该更新为包含以下内容，以反映新的ssh端口和端口<code class="fe nm nn no np b">22</code>上的蜜罐端口</p><pre class="mg mh mi mj gt ns np nt bn nu nv bi"><span id="97de" class="nw ks it np b be nx ny l nz oa">ssh          2222/tcp<br/>honeypot     22/tcp</span></pre><h2 id="cb4b" class="nb ks it bd kt nc nd dn kx ne nf dp lb ls ng nh ld lw ni nj lf ma nk nl lh iz bi translated">配置<code class="fe nm nn no np b">crond</code></h2><p id="0913" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">为了处理停止和清理旧容器，应该使用<code class="fe nm nn no np b">755</code>权限和根所有权将下面的<code class="fe nm nn no np b">bash</code>脚本部署到<code class="fe nm nn no np b">/usr/bin/honeypot.clean</code>。</p><pre class="mg mh mi mj gt ns np nt bn nu nv bi"><span id="269d" class="nw ks it np b be nx ny l nz oa">#!/bin/bash<br/><br/>EXT_IFACE=ens4<br/>SERVICE=22<br/><br/>HOSTNAME=$(/bin/hostname)<br/>LIFETIME=$((3600 * 6)) # Six hours<br/><br/>datediff () {<br/>    d1=$(/bin/date -d "$1" +%s)<br/>    d2=$(/bin/date -d "$2" +%s)<br/>    echo $((d1 - d2))<br/>}<br/><br/>for CONTAINER_ID in $(/usr/bin/docker ps -a --no-trunc | grep "honeypot-" | cut -f1 -d" "); do<br/>    STARTED=$(/usr/bin/docker inspect --format '{{ .State.StartedAt }}' ${CONTAINER_ID})<br/>    RUNTIME=$(datediff now "${STARTED}")<br/>    if [[ "${RUNTIME}" -gt "${LIFETIME}" ]]; then<br/>        logger -p local3.info "Stopping honeypot container ${CONTAINER_ID}"<br/>        /usr/bin/docker stop $CONTAINER_ID<br/>    fi<br/><br/>    RUNNING=$(/usr/bin/docker inspect --format '{{ .State.Running }}' ${CONTAINER_ID})<br/><br/>    if [[ "$RUNNING" != "true" ]]; then<br/>        # delete iptables rule<br/>        CONTAINER_IP=$(/usr/bin/docker inspect --format '{{ .NetworkSettings.IPAddress }}' ${CONTAINER_ID})<br/>        REMOTE_HOST=$(/usr/bin/docker inspect --format '{{ .Name }}' ${CONTAINER_ID} | cut -f2 -d-)<br/>        /sbin/iptables -t nat -D PREROUTING -i ${EXT_IFACE} -s ${REMOTE_HOST} -p tcp --dport ${SERVICE} -j DNAT --to-destination ${CONTAINER_IP}<br/>        logger -p local3.info "Removing honeypot container ${CONTAINER_ID}"<br/>        /usr/bin/docker rm $CONTAINER_ID<br/>    fi<br/><br/>done</span></pre><p id="b09f" class="pw-post-body-paragraph lj lk it ll b lm mw kd lo lp mx kg lr ls my lu lv lw mz ly lz ma na mc md me im bi translated">默认情况下，通过将以下内容附加到<code class="fe nm nn no np b">/etc/crontab</code>，上述脚本被设置为每5分钟运行一次。</p><pre class="mg mh mi mj gt ns np nt bn nu nv bi"><span id="2938" class="nw ks it np b be nx ny l nz oa">*/5 * * * * /usr/bin/honeypot.clean</span></pre><h2 id="2475" class="nb ks it bd kt nc nd dn kx ne nf dp lb ls ng nh ld lw ni nj lf ma nk nl lh iz bi translated">配置<code class="fe nm nn no np b">auditd</code></h2><p id="13ab" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">通过添加以下审核规则，启用在auditd中记录execve系统调用:</p><pre class="mg mh mi mj gt ns np nt bn nu nv bi"><span id="eb89" class="nw ks it np b be nx ny l nz oa">auditctl -a exit,always -F arch=b64 -S execve<br/>auditctl -a exit,always -F arch=b32 -S execve</span></pre><h2 id="0339" class="nb ks it bd kt nc nd dn kx ne nf dp lb ls ng nh ld lw ni nj lf ma nk nl lh iz bi translated">展开<code class="fe nm nn no np b">apitrap.sh</code></h2><p id="6c4c" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated"><code class="fe nm nn no np b">apitrap.sh</code>脚本是一个可选组件，它尝试在主机上模拟Docker API。由于这是一个bash脚本，建议从Docker容器运行，以无权限用户身份运行，并重定向到端口2375或2376，以避免潜在的漏洞。</p><pre class="mg mh mi mj gt ns np nt bn nu nv bi"><span id="fb25" class="nw ks it np b be nx ny l nz oa">#!/bin/bash<br/><br/>## Docker API heading<br/>H1="HTTP/1.1 404 Not Found\n"<br/>H2="Content-Type: application/json\n"<br/>H3="Date: "`date '+%a, %d %b %Y %T %Z'`"\n"<br/>H4="Content-Length: 29\n\n"<br/><br/>## API error message<br/>B1="{\"message\":\"page not found\"}\n"<br/>HEADERS+=$H1$H2$H3$H4<br/><br/>## Default to port 2376 if no port is given<br/>if ! test -z "$1"; then<br/>  PORT=$1;<br/>  else <br/>    PORT=2376; <br/>fi<br/><br/>QUEUE_FILE=/tmp/apitrap<br/>test -p $QUEUE_FILE &amp;&amp; rm $QUEUE_FILE<br/>mkfifo $QUEUE_FILE<br/><br/>while true; do<br/>  cat "$QUEUE_FILE" | nc -l "$PORT" | while read -r line || [[ -n "$line" ]]; do<br/>    if echo $line | grep -q 'GET \|HEAD \|POST \|PUT \|DELETE \|CONNECT \|OPTIONS \|TRACE'; then<br/>      echo "&gt;&gt;&gt; ["$(date)"] &lt;&lt;&lt;"<br/>      echo : $line<br/>      echo -e $HEADERS$B1 &gt; $QUEUE_FILE<br/>    fi<br/>  done<br/>done</span></pre><p id="54dd" class="pw-post-body-paragraph lj lk it ll b lm mw kd lo lp mx kg lr ls my lu lv lw mz ly lz ma na mc md me im bi translated">您需要对系统进行适当的修改，但是从您决定部署的任何蜜罐内部，应该可以从docker容器内部获得主机IP。例如:</p><pre class="mg mh mi mj gt ns np nt bn nu nv bi"><span id="c21c" class="nw ks it np b be nx ny l nz oa">root@dockerhost:~# hostname -I |awk '{ print $2 }'<br/>172.17.0.1<br/>root@dockerhost:~# docker run -it honeypot-test /sbin/ip route|awk '/default/ { print $3 }'<br/>172.17.0.1<br/>root@dockerhost:~#</span></pre><p id="d95f" class="pw-post-body-paragraph lj lk it ll b lm mw kd lo lp mx kg lr ls my lu lv lw mz ly lz ma na mc md me im bi translated">我们显示dockerhost的主机名是<code class="fe nm nn no np b">172.17.0.1</code>。检索Docker容器的网关地址发现它也是<code class="fe nm nn no np b">172.17.0.1</code>。这很容易使主机IP受到来自容器的攻击。因此，我们应该在我们的项目中利用这一点，确保DockerTrap的配置被重定向并在同一主机上可用。但是，这里不讨论这些细节。在<a class="ae mv" href="https://github.com/mrhavens/DockerTrap" rel="noopener ugc nofollow" target="_blank"> DockerTrap </a> GitHub仓库上寻找更新。</p><h2 id="2c27" class="nb ks it bd kt nc nd dn kx ne nf dp lb ls ng nh ld lw ni nj lf ma nk nl lh iz bi translated">从<code class="fe nm nn no np b">Dockerfile</code>构建蜜罐镜像</h2><p id="fc67" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">这个映像的主要特点是启用了sshd，启用了root登录，root的密码设置为<code class="fe nm nn no np b">root</code>。您应该对此进行修改，以包括其他用户帐户，以及有助于吸引更多攻击的琐碎密码。</p><pre class="mg mh mi mj gt ns np nt bn nu nv bi"><span id="1e1b" class="nw ks it np b be nx ny l nz oa">FROM alpine:3.9<br/>ENTRYPOINT ["/entrypoint.sh"]<br/>EXPOSE 22<br/><br/>## Root is gloriously unsecure!<br/>RUN apk add --no-cache openssh \<br/>  &amp;&amp; sed -i s/#PermitRootLogin.\*/PermitRootLogin\ yes/ /etc/ssh/sshd_config \<br/>  &amp;&amp; echo "root:root" | chpasswd<br/><br/>RUN echo -e '#!/bin/ash\n\nssh-keygen -A\n/usr/sbin/sshd -D -e "$@"' &gt; /entrypoint.sh<br/>RUN chmod 555 /entrypoint.sh</span></pre><h2 id="5f1a" class="nb ks it bd kt nc nd dn kx ne nf dp lb ls ng nh ld lw ni nj lf ma nk nl lh iz bi translated">提交最终蜜罐映像</h2><p id="fb83" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">系统查找提交为<code class="fe nm nn no np b">honeypot:latest</code>的基础映像。当建立ssh连接时，系统会自动创建一个带有<code class="fe nm nn no np b">honeypot-</code>前缀的镜像的唯一实例。根据需要修改此图像。</p><h1 id="5e30" class="kr ks it bd kt ku kv kw kx ky kz la lb ki lc kj ld kl le km lf ko lg kp lh li bi translated">测试</h1><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi mf"><img src="../Images/2bfae1206957ea13a736ad2e79e37b22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*4xIFfG6E38oRZ7mR.jpg"/></div></div></figure><h2 id="37a2" class="nb ks it bd kt nc nd dn kx ne nf dp lb ls ng nh ld lw ni nj lf ma nk nl lh iz bi translated">SSH进入蜜罐</h2><p id="b9a7" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">每个动态创建的蜜罐将采用主机的主机名。此时，如果在localhost的端口<code class="fe nm nn no np b">22</code>上建立了任何套接字连接(或主机上配置为由DockerTrap使用的任何其他网络适配器)，它将被重定向到一个蜜罐容器内的蜜罐的sshd守护进程。由<code class="fe nm nn no np b">xinetd</code>触发的Bash脚本<code class="fe nm nn no np b">/usr/bin/honeypot</code>确保每个IP地址都指向其对应的容器，因此如果攻击者试图第二次、第三次或第四次从同一个IP地址登录，他们每次都会登录到同一个容器。</p><pre class="mg mh mi mj gt ns np nt bn nu nv bi"><span id="a02c" class="nw ks it np b be nx ny l nz oa">dockertrap:~# ssh root@localhost -p 22<br/>The authenticity of host 'localhost (127.0.0.1)' can't be established.<br/>ECDSA key fingerprint is SHA256:dY6EIpV1nBw5143TkgPQU5SRWIkrxkZCiLWd+ktiNKE.<br/>Are you sure you want to continue connecting (yes/no)? yes<br/>Warning: Permanently added 'localhost' (ECDSA) to the list of known hosts.<br/>root@localhost's password:<br/>Welcome to Alpine!<br/><br/>The Alpine Wiki contains a large amount of how-to guides and general<br/>information about administrating Alpine systems.<br/>See &lt;http://wiki.alpinelinux.org/&gt;.<br/><br/>You can setup the system with the command: setup-alpine<br/><br/>You may change this message by editing /etc/motd.<br/><br/>dockertrap:~# ifconfig -a<br/>eth0      Link encap:Ethernet  HWaddr 02:42:AC:11:00:02<br/>          inet addr:172.17.0.2  Bcast:172.17.255.255  Mask:255.255.0.0<br/>          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1<br/>          RX packets:124 errors:0 dropped:0 overruns:0 frame:0<br/>          TX packets:96 errors:0 dropped:0 overruns:0 carrier:0<br/>          collisions:0 txqueuelen:0<br/>          RX bytes:13954 (13.6 KiB)  TX bytes:14026 (13.6 KiB)<br/><br/>lo        Link encap:Local Loopback<br/>          inet addr:127.0.0.1  Mask:255.0.0.0<br/>          UP LOOPBACK RUNNING  MTU:65536  Metric:1<br/>          RX packets:0 errors:0 dropped:0 overruns:0 frame:0<br/>          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0<br/>          collisions:0 txqueuelen:1000<br/>          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)<br/><br/>dockertrap:~# exit<br/>Connection to localhost closed.<br/>root@dockertrap:~#</span></pre><p id="c13a" class="pw-post-body-paragraph lj lk it ll b lm mw kd lo lp mx kg lr ls my lu lv lw mz ly lz ma na mc md me im bi translated">注意，上面的以太网设备<code class="fe nm nn no np b">eth0</code>配置了IP地址<code class="fe nm nn no np b">172.17.0.2</code>和MAC地址<code class="fe nm nn no np b">02:42:AC:11:00:02</code>。当从主机的本地主机之外的IP地址登录时，比如我的hope PC，DockerTrap将产生一个新的、几乎相同的容器供我登录(当然，IP和MAC地址除外)。</p><pre class="mg mh mi mj gt ns np nt bn nu nv bi"><span id="6dfa" class="nw ks it np b be nx ny l nz oa">C:\Users\user&gt;ssh root@35.238.100.5 -p 22<br/>The authenticity of host '35.238.100.5 (35.238.100.5)' can't be established.<br/>ECDSA key fingerprint is SHA256:VKG+5VhB0WL5ncPomfmb+XW484LtjS8oAs+BDM07sJQ.<br/>Are you sure you want to continue connecting (yes/no)? yes<br/>Warning: Permanently added '35.238.100.5' (ECDSA) to the list of known hosts.<br/>root@35.238.100.5's password:<br/>Welcome to Alpine!<br/><br/>The Alpine Wiki contains a large amount of how-to guides and general<br/>information about administrating Alpine systems.<br/>See &lt;http://wiki.alpinelinux.org/&gt;.<br/><br/>You can setup the system with the command: setup-alpine<br/><br/>You may change this message by editing /etc/motd.<br/><br/>honeypot2:~# ifconfig -a<br/>eth0      Link encap:Ethernet  HWaddr 02:42:AC:11:00:09<br/>          inet addr:172.17.0.9  Bcast:172.17.255.255  Mask:255.255.0.0<br/>          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1<br/>          RX packets:72 errors:0 dropped:0 overruns:0 frame:0<br/>          TX packets:50 errors:0 dropped:0 overruns:0 carrier:0<br/>          collisions:0 txqueuelen:0<br/>          RX bytes:7593 (7.4 KiB)  TX bytes:7041 (6.8 KiB)<br/>lo        Link encap:Local Loopback<br/>          inet addr:127.0.0.1  Mask:255.0.0.0<br/>          UP LOOPBACK RUNNING  MTU:65536  Metric:1<br/>          RX packets:0 errors:0 dropped:0 overruns:0 frame:0<br/>          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0<br/>          collisions:0 txqueuelen:1000<br/>          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)<br/>honeypot2:~# exit<br/>Connection to 35.238.100.5 closed.<br/>C:\Users\user&gt;</span></pre><p id="ab64" class="pw-post-body-paragraph lj lk it ll b lm mw kd lo lp mx kg lr ls my lu lv lw mz ly lz ma na mc md me im bi translated">IP地址和MAC地址不同，但主机名相同。过一会儿，我们会注意到越来越多的容器开始在主机上旋转，因为随机的机器人连接到端口<code class="fe nm nn no np b">22</code>。为了防止内存资源攻击，您需要编辑<code class="fe nm nn no np b">/etc/xinetd.d/honeypot</code>文件，以便<code class="fe nm nn no np b">xinetd</code>限制实例的数量，这是没有意义的。</p><pre class="mg mh mi mj gt ns np nt bn nu nv bi"><span id="5fe2" class="nw ks it np b be nx ny l nz oa">root@dockertrap:/usr/bin# docker ps<br/>CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES<br/>4971d1c8272a        honeypot            "/entrypoint.sh"    17 minutes ago      Up 17 minutes       22/tcp              honeypot-175.111.182.186<br/>bf4f9b94ad03        honeypot            "/entrypoint.sh"    27 minutes ago      Up 27 minutes       22/tcp              honeypot-58.96.198.15<br/>e69231243915        honeypot            "/entrypoint.sh"    29 minutes ago      Up 29 minutes       22/tcp              honeypot-<br/>906c4e2be5c7        honeypot            "/entrypoint.sh"    30 minutes ago      Up 30 minutes       22/tcp              honeypot-10.128.0.46<br/>root@dockertrap:/usr/bin#</span></pre><h1 id="6807" class="kr ks it bd kt ku kv kw kx ky kz la lb ki lc kj ld kl le km lf ko lg kp lh li bi translated">未来的工作</h1><p id="8359" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">DockerTrap的大部分设计可以应用于Kubernetes。类似于Docker如何在这里启用资源限制，K8s支持高级的<a class="ae mv" href="https://kubernetes.io/docs/tasks/administer-cluster/securing-a-cluster/" rel="noopener ugc nofollow" target="_blank">安全特性</a>，包括一个iptables对应的<a class="ae mv" href="https://kubernetes.io/docs/concepts/services-networking/network-policies/" rel="noopener ugc nofollow" target="_blank">网络策略</a>。API蜜罐<code class="fe nm nn no np b">apitrap.sh</code>也可以被更强大的系统取代，如<a class="ae mv" href="https://github.com/oncyberblog/whaler" rel="noopener ugc nofollow" target="_blank"> Whaler </a>，这将有助于识别专门寻找错误配置的Docker主机的受损系统。</p></div><div class="ab cl ob oc hx od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="im in io ip iq"><p id="a5cb" class="pw-post-body-paragraph lj lk it ll b lm mw kd lo lp mx kg lr ls my lu lv lw mz ly lz ma na mc md me im bi translated"><em class="oi">作为Medium上的一名作者，</em> <a class="ae mv" href="https://mark-havens.medium.com/membership" rel="noopener"> <em class="oi">我邀请你成为会员</em> </a> <em class="oi">并获得我的故事集，以及成千上万其他天才作家写的故事。你的会员费直接支持我和你阅读的其他作家，并让你完全接触媒体上的每一个故事。</em></p></div><div class="ab cl ob oc hx od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="im in io ip iq"><figure class="mg mh mi mj gt mk gh gi paragraph-image"><a href="https://www.buymeacoffee.com/markrhavens"><div class="gh gi oj"><img src="../Images/3cc04fc4dcc9f932f08586707d3328ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*sx8Q8VXq5-Fj_4gq.png"/></div></a><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">如果你喜欢这篇文章，像你这样的粉丝再给我一杯咖啡，肯定会鼓励我再写一篇这样的文章。顺便来看看，打个招呼，让我知道你对你可能想读的话题的想法。你可能是我需要写一些更棒的东西的灵感火花！</figcaption></figure></div><div class="ab cl ob oc hx od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="im in io ip iq"><h1 id="0263" class="kr ks it bd kt ku ok kw kx ky ol la lb ki om kj ld kl on km lf ko oo kp lh li bi translated">更新:2022年11月24日</h1><p id="c3d3" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">在2020年疫情爆发时，我提出并被委托写上述的穿越。由<a class="ae mv" href="https://appfleet.com/" rel="noopener ugc nofollow" target="_blank"><em class="oi">Appfleet</em></a><em class="oi">发布，并于2020年3月2日作为app fleet博客</em>  <em class="oi">发布</em> <a class="ae mv" href="https://appfleet.com/blog/compromised-container-detection-with-honeypot-containers/" rel="noopener ugc nofollow" target="_blank"> <em class="oi">。</em> </a><a class="ae mv" href="https://havdevops.com/Trapping-Hackers-with-Containerized-Deception/" rel="noopener ugc nofollow" target="_blank"> <em class="oi">这个故事的一个版本</em> </a> <em class="oi">也可以在</em><a class="ae mv" href="https://havdevops.com/" rel="noopener ugc nofollow" target="_blank"><em class="oi">my havdoveps博客</em> </a> <em class="oi">上找到。我将上面更新的故事发布到Medium，只做了微小的编辑和格式更改。如果有人发现错误需要我的注意，请不吝赐教。</em></p></div><div class="ab cl ob oc hx od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="im in io ip iq"><p id="b4fc" class="pw-post-body-paragraph lj lk it ll b lm mw kd lo lp mx kg lr ls my lu lv lw mz ly lz ma na mc md me im bi translated"><a class="ae mv" href="https://markhavens.us/" rel="noopener ugc nofollow" target="_blank"> <em class="oi">马克·兰道尔·哈文斯</em> </a> <em class="oi">是一位连续创业者和创造者，他从19岁起就开始创业。他是北德克萨斯州最知名的两个创客社区</em> <a class="ae mv" href="https://dallasmakercommunity.org/" rel="noopener ugc nofollow" target="_blank"> <em class="oi">达拉斯创客社区</em> </a> <em class="oi">和</em> <a class="ae mv" href="https://dallasmakerspace.org/" rel="noopener ugc nofollow" target="_blank"> <em class="oi">达拉斯创客空间</em> </a> <em class="oi">的创始人。他拥有科罗拉多技术大学的管理学硕士学位，并获得了德克萨斯大学Rio Grand Valley分校的计算机科学学士学位。为了表彰他在创客社区的工作，他获得了位于阿灵顿的德克萨斯大学的博士奖学金。当马克不从事制造工作或探索生活、文化和技术时，他住在达拉斯的中心郊区——沃斯堡大都会区，探索新的、创新的方式来养活他的母亲和两个孩子。</em></p></div></div>    
</body>
</html>