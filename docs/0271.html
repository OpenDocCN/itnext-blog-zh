<html>
<head>
<title>When Istio Meets Jaeger — An Example of End-to-end Distributed Tracing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">当Istio遇到Jaeger——一个端到端分布式追踪的例子</h1>
<blockquote>原文：<a href="https://itnext.io/when-istio-meets-jaeger-an-example-of-end-to-end-distributed-tracing-2c136eb335eb?source=collection_archive---------2-----------------------#2018-02-05">https://itnext.io/when-istio-meets-jaeger-an-example-of-end-to-end-distributed-tracing-2c136eb335eb?source=collection_archive---------2-----------------------#2018-02-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/19f09aa165a908357a4c67cf71847ab8.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*6MjgQZk-pWVtF88PENpNhA.png"/></div></figure><p id="5829" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><a class="ae ks" href="https://www.linkedin.com/cws/share?url=https%3A%2F%2Fitnext.io%2Fwhen-istio-meets-jaeger-an-example-of-end-to-end-distributed-tracing-2c136eb335eb" rel="noopener ugc nofollow" target="_blank"> <em class="kt">点击这里在LinkedIn上分享这篇文章</em> </a></p><p id="1869" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">Kubernetes太棒了！它帮助许多工程团队实现了SOA(面向服务的架构)的梦想。很长一段时间以来，我们围绕着整体思维的概念来构建我们的应用程序，这实质上是让一个大型计算实例运行应用程序中提供的所有服务。账户管理、计费、报告生成等都是从共享资源中运行的。在SOA出现并承诺给我们一个更加光明的未来之前，这一切都运转得很好。通过将应用程序分解成更小的组件，并让它们使用REST或gRPC相互通信。我们希望事情只会从那里变得更好，但只会意识到一系列新的挑战在等待着我们。跨服务交流怎么样？日志或寻迹等微服务之间的可观测性如何？这篇文章演示了如何在Kubernetes集群中设置OpenTracing，以支持服务之间的端到端跟踪，以及使用正确的工具在服务内部进行跟踪。</p><h1 id="1604" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">Kubernetes集群设置</h1><p id="7eb1" class="pw-post-body-paragraph ju jv iq jw b jx ls jz ka kb lt kd ke kf lu kh ki kj lv kl km kn lw kp kq kr ij bi translated">首先，我们需要一个可以使用的Kubernetes集群。我在AWS上使用<a class="ae ks" href="https://github.com/kubernetes/kops" rel="noopener ugc nofollow" target="_blank"> kops </a>，因为它提供了一系列自动化集群操作，如升级、扩展/缩小和多个实例组。除了方便的集群操作之外，kops团队一直密切关注最新的Kubernetes版本，以提供最新的集群体验。我发现非常酷的:D</p><p id="f105" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">要让kops运行起来，需要遵循一些步骤。</p><h1 id="8b69" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">创建集群</h1><p id="0e8f" class="pw-post-body-paragraph ju jv iq jw b jx ls jz ka kb lt kd ke kf lu kh ki kj lv kl km kn lw kp kq kr ij bi translated">在AWS上用kops创建Kubernetes集群可能像一个<a class="ae ks" href="https://github.com/kubernetes/kops/blob/master/docs/cli/kops_create_cluster.md" rel="noopener ugc nofollow" target="_blank">集群创建命令</a>一样简单。</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="58c4" class="mg kv iq mc b gy mh mi l mj mk">kops create cluster \ <br/>--name steven.buffer-k8s.com \ <br/>--cloud aws \ <br/>--master-size t2.medium \ <br/>--master-zones=us-east-1b \ <br/>--node-size m5.large \ <br/>--zones=us-east-1a,us-east-1b,us-east-1c,us-east-1d,us-east-1e,us-east-1f \ <br/>--node-count=2 \ <br/>--kubernetes-version=1.8.6 \ <br/>--vpc=vpc-1234567a \ <br/>--network-cidr=10.0.0.0/16 \ <br/>--networking=flannel \ <br/>--authorization=RBAC \ <br/>--ssh-public-key="~/.ssh/kube_aws_rsa.pub" \ <br/>--yes</span></pre><p id="7d3b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这个命令告诉AWS使用CIDR <code class="fe ml mm mn mc b">10.0.0.0/16</code>在VPC <code class="fe ml mm mn mc b">1234567a</code>的<code class="fe ml mm mn mc b">us-east-1</code>创建一个Kubernetes集群，其中有1个主节点和2个minion (worker)节点。大约需要10分钟，群集才能启动并准备就绪。同时，您可以使用<code class="fe ml mm mn mc b">watch kubectl get nodes</code>来监控进度。</p><p id="1b9c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">一旦完成，我们应该准备好在新的Kubernetes集群上安装<a class="ae ks" href="https://istio.io/" rel="noopener ugc nofollow" target="_blank"> Istio </a>。它是一个服务网格，管理在同一个集群上运行的服务之间的流量。由于这一特性，它使Istio成为跨服务跟踪请求的完美候选。</p><h1 id="99d2" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">安装Istio</h1><p id="11c7" class="pw-post-body-paragraph ju jv iq jw b jx ls jz ka kb lt kd ke kf lu kh ki kj lv kl km kn lw kp kq kr ij bi translated">从他们的<a class="ae ks" href="https://github.com/istio/istio/releases/tag/0.4.0" rel="noopener ugc nofollow" target="_blank"> GitHub repo </a>下载Istio。</p><p id="833d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">从下载的Istio目录中，您可以使用以下命令将Istio安装到Kubernetes集群中</p><p id="56ac" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe ml mm mn mc b">kubectl apply -f install/kubernetes/istio.yaml</code></p><p id="80ff" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在Istio应该已经在集群上启动并运行了。它还创建了一个接受外部请求的Nginx入口控制器。我们将在后面介绍如何设置ip。</p><h1 id="f024" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">安装Jaeger</h1><p id="1db5" class="pw-post-body-paragraph ju jv iq jw b jx ls jz ka kb lt kd ke kf lu kh ki kj lv kl km kn lw kp kq kr ij bi translated">Jaeger和Instio携手提供跨服务的追踪。您可以用这个命令安装Jaeger</p><p id="52a4" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe ml mm mn mc b">kubectl create -n istio-system -f <a class="ae ks" href="https://raw.githubusercontent.com/jaegertracing/jaeger-kubernetes/master/all-in-one/jaeger-all-in-one-template.yml" rel="noopener ugc nofollow" target="_blank">https://raw.githubusercontent.com/jaegertracing/jaeger-kubernetes/master/all-in-one/jaeger-all-in-one-template.yml</a></code></p><p id="a09f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">完成后，您应该能够访问Jaeger用户界面。维奥拉。</p><figure class="lx ly lz ma gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi mo"><img src="../Images/d623d0e132bbb59fea190592aa907ae0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Z8fQqmATKom1Au34."/></div></div></figure><h1 id="5bbc" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">仪器代码</h1><p id="29b1" class="pw-post-body-paragraph ju jv iq jw b jx ls jz ka kb lt kd ke kf lu kh ki kj lv kl km kn lw kp kq kr ij bi translated">安装Jaeger和Istio后，你将能够自动看到跨服务的痕迹！这是因为Istio注入的Envoy sidecars处理服务间流量，而部署的应用程序只与分配的sidecars对话。</p><p id="6a94" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">你可以用一个小的示例应用程序找到我的<a class="ae ks" href="https://github.com/stevenc81/jaeger-tracing-example" rel="noopener ugc nofollow" target="_blank"> GitHub repo </a>。</p><p id="816a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe ml mm mn mc b">main.go</code>看起来是这样的</p><figure class="lx ly lz ma gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="0703" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在第28–30行，我们创建了一个Zipkin传播器，告诉Jaeger从请求头中捕获OpenZipkin上下文。您可能会问，这些头首先是如何到达请求的？还记得我说过Istio sidecar处理服务通信，而您的应用程序只与它对话吗？是的，你可能已经猜到了。为了让Istio跟踪服务之间的请求，当请求进入集群时，Istio的入口控制器会注入一组头。然后它得到了一个和特使边车的传播，每个边车向耶格报告相关的跨度。这有助于将跨度连接到单个轨迹。我们的应用程序代码利用这些头来折叠服务间和服务内的跨度。</p><p id="62dc" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">下面是Istio入口控制器注入的OpenZipkin头列表</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="726e" class="mg kv iq mc b gy mh mi l mj mk">x-request-id<br/>x-b3-traceid<br/>x-b3-spanid<br/>x-b3-parentspanid<br/>x-b3-sampled<br/>x-b3-flags<br/>x-ot-span-context</span></pre><p id="8950" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">要部署示例应用程序，您可以使用这个yaml文件</p><figure class="lx ly lz ma gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><h1 id="d2c4" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">部署</h1><p id="70a8" class="pw-post-body-paragraph ju jv iq jw b jx ls jz ka kb lt kd ke kf lu kh ki kj lv kl km kn lw kp kq kr ij bi translated"><code class="fe ml mm mn mc b">kubectl apply -f &lt;(istioctl kube-inject -f myhelloword.yaml)</code></p><p id="3215" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">请注意，bin <code class="fe ml mm mn mc b">istioctl</code>可以在bin文件夹下的Istio repo中找到。</p><p id="cc42" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">是时候收获利润了！当我们向Istio入口控制器发送请求时，它将在服务之间以及应用程序内部被跟踪。从截图中我们可以看到从不同地方报道的3个跨度</p><ul class=""><li id="bf93" class="mv mw iq jw b jx jy kb kc kf mx kj my kn mz kr na nb nc nd bi translated">入口控制器</li><li id="2561" class="mv mw iq jw b jx ne kb nf kf ng kj nh kn ni kr na nb nc nd bi translated">申请特使边车</li><li id="d1b2" class="mv mw iq jw b jx ne kb nf kf ng kj nh kn ni kr na nb nc nd bi translated">应用代码</li></ul><figure class="lx ly lz ma gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi mo"><img src="../Images/46ba1017726e18784b595caaec9958ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*iTwIzJGOa-w055jC."/></div></div></figure><p id="785a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">展开跟踪(显示3个跨度)并查看我们将:D的端到端跟踪</p><figure class="lx ly lz ma gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi mo"><img src="../Images/b97405f0334d3ee10ce7eb7331533129.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hHfzLg-i6yMtPFlk."/></div></div></figure><h1 id="a490" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">结束语</h1><ul class=""><li id="be0e" class="mv mw iq jw b jx ls kb lt kf nj kj nk kn nl kr na nb nc nd bi translated">SOA带来了一系列新问题，尤其是围绕服务可观察性的问题</li><li id="b172" class="mv mw iq jw b jx ne kb nf kf ng kj nh kn ni kr na nb nc nd bi translated">Istio + Jager集成解决了服务对服务级别的问题</li><li id="2f67" class="mv mw iq jw b jx ne kb nf kf ng kj nh kn ni kr na nb nc nd bi translated">在Jaeger中使用OpenZipkin prapagator可以实现真正的端到端跟踪</li></ul></div><div class="ab cl nm nn hu no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="ij ik il im in"><p id="9820" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><em class="kt">原载于【gist.github.com】<a class="ae ks" href="https://gist.github.com/stevenc81/2c6840784c6223cdbd62cdd1563a4811" rel="noopener ugc nofollow" target="_blank"><em class="kt"/></a><em class="kt">。</em></em></p></div></div>    
</body>
</html>