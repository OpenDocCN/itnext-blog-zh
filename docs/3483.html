<html>
<head>
<title>Memory-wise apps with C# .NET</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用C#的内存型应用程序。网</h1>
<blockquote>原文：<a href="https://itnext.io/memory-wise-apps-with-c-net-50b6379ed86?source=collection_archive---------1-----------------------#2019-12-24">https://itnext.io/memory-wise-apps-with-c-net-50b6379ed86?source=collection_archive---------1-----------------------#2019-12-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/e150c29d9f5133a3cf35c86393d965e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fSH4tDeqmv5VfE9aDOlndg.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">计算机内存芯片由<a class="ae kf" href="https://www.publicdomainpictures.net/nl/view-image.php?image=18192&amp;picture=geheugen-van-de-computer-chips" rel="noopener ugc nofollow" target="_blank">彼得·克拉托奇维尔</a></figcaption></figure><p id="9a05" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">每个应用程序都由两部分组成:<strong class="ki iu">代码</strong>和<strong class="ki iu">数据</strong>存储应用程序在执行过程中的<strong class="ki iu">状态。当一个. NET应用程序运行时，幕后有一堆魔法，而<strong class="ki iu">内存管理</strong>就是其中之一。在我看来，要编写一个智能内存的应用程序，你需要知道内存管理背后发生了什么。</strong></p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h2 id="69a6" class="ll lm it bd ln lo lp dn lq lr ls dp lt kr lu lv lw kv lx ly lz kz ma mb mc md bi translated">1)术语</h2><p id="982b" class="pw-post-body-paragraph kg kh it ki b kj me kl km kn mf kp kq kr mg kt ku kv mh kx ky kz mi lb lc ld im bi translated">在讨论内存管理之前，需要描述几个术语:</p><p id="5325" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">📒<em class="mj">如果你已经知道GC、堆、代、代码等术语。跳过这一部分。</em></p><ul class=""><li id="20d1" class="mk ml it ki b kj kk kn ko kr mm kv mn kz mo ld mp mq mr ms bi translated"><strong class="ki iu">垃圾收集器(GC): </strong>是的一部分。NET内存管理，为你的应用程序释放内存。</li><li id="3fb5" class="mk ml it ki b kj mt kn mu kr mv kv mw kz mx ld mp mq mr ms bi translated"><strong class="ki iu">堆:一个</strong>堆是一个专门的基于树的数据。在<strong class="ki iu">中有不同的类型。NET、</strong>如<strong class="ki iu">代码堆</strong>、<strong class="ki iu">小对象堆(SOH) </strong>、<strong class="ki iu">大对象堆(LOH) </strong>和<strong class="ki iu">进程堆</strong>。</li><li id="48a1" class="mk ml it ki b kj mt kn mu kr mv kv mw kz mx ld mp mq mr ms bi translated"><strong class="ki iu">托管堆</strong>:是<a class="ae kf" href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/reference-types" rel="noopener ugc nofollow" target="_blank">引用类型化</a>对象存储的内存的一部分。</li><li id="dcdd" class="mk ml it ki b kj mt kn mu kr mv kv mw kz mx ld mp mq mr ms bi translated"><strong class="ki iu">代:</strong>为了GC更好的释放内存性能，从<strong class="ki iu">零</strong>开始将堆分成不同的代索引(例如<strong class="ki iu"> Gen0 </strong>，<strong class="ki iu"> Gen1 </strong>等等)。</li><li id="4056" class="mk ml it ki b kj mt kn mu kr mv kv mw kz mx ld mp mq mr ms bi translated"><strong class="ki iu">栈</strong>:在计算机科学中，栈是一种抽象的数据类型，作为元素的集合，有两个主要操作push用于添加到顶部，pop用于从顶部检索和移除。元素从堆栈中出来的顺序产生了它的另一个名字，<strong class="ki iu"> LIFO </strong>(后进先出)</li></ul></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h2 id="2878" class="ll lm it bd ln lo lp dn lq lr ls dp lt kr lu lv lw kv lx ly lz kz ma mb mc md bi translated">2)变量在哪里，堆还是栈？</h2><p id="f5e4" class="pw-post-body-paragraph kg kh it ki b kj me kl km kn mf kp kq kr mg kt ku kv mh kx ky kz mi lb lc ld im bi translated">。NET将变量数据存储在<strong class="ki iu">堆</strong>或<strong class="ki iu">堆栈中。</strong>如何<strong class="ki iu">。NET </strong>根据声明它的上下文来处理它。我们使用变量在内存中存储数据，但这意味着什么呢？</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="7cb5" class="ll lm it nd b gy nh ni l nj nk">int variable1 = 1;<br/>object variable2 = new Object();<br/>object variable3 = null;</span></pre><p id="b869" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">众所周知，我们使用变量将一个名字(在编码中)与一个包含它的值的内存槽相关联。但是对于一个<strong class="ki iu">引用类型的</strong>变量(例如<code class="fe nl nm nn nd b">new Object()</code>)，变量的值是对对象的<strong class="ki iu">引用</strong>，而不是对象本身。</p><p id="3bdc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你有没有问过自己为什么不能给一个<strong class="ki iu">值类型化的</strong>变量赋一个<strong class="ki iu"> null </strong>值？</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="d357" class="ll lm it nd b gy nh ni l nj nk">int number = null; // Why this isn't correct?<br/>object myObject = null; // Why this is correct?</span></pre><p id="a320" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">将<strong class="ki iu"> null </strong>存储到一个<strong class="ki iu">值类型的</strong>变量中有意义吗？它应该存储一个值，比如一个数字，对吗？😉</p><p id="a9f9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是将null赋值给被引用类型是可以的(但是在使用null之前，请阅读<a class="ae kf" href="https://en.wikipedia.org/wiki/Tony_Hoare#Apologies_and_retractions" rel="noopener ugc nofollow" target="_blank">一个十亿美元的错误</a>)。因为你声明了一个没有引用任何对象的变量，所以你把它赋值为null。</p><p id="c907" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在让我们回到堆和栈的主题！</p><ul class=""><li id="88ce" class="mk ml it ki b kj kk kn ko kr mm kv mn kz mo ld mp mq mr ms bi translated">中的<strong class="ki iu">堆</strong>或<strong class="ki iu">托管堆</strong>。NET是对象存在的地方。</li><li id="21ba" class="mk ml it ki b kj mt kn mu kr mv kv mw kz mx ld mp mq mr ms bi translated">每个<strong class="ki iu">局部变量</strong>都存储在堆栈中，即使是引用类型的。我知道看起来不是很清楚。但是要记住，<strong class="ki iu"> <em class="mj">对象本身存在于</em> </strong>堆中，而<strong class="ki iu"> <em class="mj">变量值只是对对象本身</em> </strong>的引用。</li><li id="1033" class="mk ml it ki b kj mt kn mu kr mv kv mw kz mx ld mp mq mr ms bi translated">静态变量总是存储在<strong class="ki iu">堆中，</strong>当然，它们只有一个内存槽。</li></ul><p id="413b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">总有例外:方法参数被认为是局部变量，但是当用<code class="fe nl nm nn nd b">ref</code>修饰符声明它们时，它们共享调用方法变量的槽。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h2 id="9d09" class="ll lm it bd ln lo lp dn lq lr ls dp lt kr lu lv lw kv lx ly lz kz ma mb mc md bi translated">3)内存管理</h2><p id="ea9d" class="pw-post-body-paragraph kg kh it ki b kj me kl km kn mf kp kq kr mg kt ku kv mh kx ky kz mi lb lc ld im bi translated">所以。NET将引用类型变量的值存储到<strong class="ki iu">小对象堆(SOH) </strong>和<strong class="ki iu">大对象堆(LOH) </strong>中，并将它们分成代。那么，什么是世代？</p><ul class=""><li id="ad42" class="mk ml it ki b kj kk kn ko kr mm kv mn kz mo ld mp mq mr ms bi translated">当一个新对象<strong class="ki iu">刚刚被创建</strong>时，它将在<strong class="ki iu"> Gen0中。</strong>当<strong class="ki iu"> Gen0 </strong>满时，GC执行扫描并尝试从堆中移除<strong class="ki iu">不可到达的</strong>对象，它会将<strong class="ki iu">已到达的对象</strong>重定位到<strong class="ki iu"> Gen1 </strong>。</li><li id="3e26" class="mk ml it ki b kj mt kn mu kr mv kv mw kz mx ld mp mq mr ms bi translated">在第二次迭代中，当<strong class="ki iu"> Gen1 </strong>已满并且执行GC时，所有幸存的对象将提升到<strong class="ki iu"> Gen2 </strong>。(第0代收集也发生在这里)</li><li id="b808" class="mk ml it ki b kj mt kn mu kr mv kv mw kz mx ld mp mq mr ms bi translated">当Gen2也满时，GC执行一个<strong class="ki iu">完全垃圾收集:</strong>首先是Gen2，然后是Gen1和Gen0。如果没有剩余内存，GC将抛出一个<a class="ae kf" href="https://docs.microsoft.com/en-us/dotnet/api/system.outofmemoryexception?view=netframework-4.8" rel="noopener ugc nofollow" target="_blank"> OutOfMemory </a>异常。</li></ul><figure class="my mz na nb gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi no"><img src="../Images/b82e4b76445ebc723888a9d4037c7bc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TvHWRAyBYMhL_Ux9MK7vEg.png"/></div></div></figure><p id="2921" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了获得更好的性能，。NET在LOH中存储大于85Kb (85，000千字节)的对象，在SOH中存储较小的对象。随着时间的推移，LOH中幸存的对象将遭受碎片化。</p><p id="86de" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们知道堆、栈和代，但是GC是如何工作的。</p><h2 id="703b" class="ll lm it bd ln lo lp dn lq lr ls dp lt kr lu lv lw kv lx ly lz kz ma mb mc md bi translated">4)垃圾收集器</h2><p id="4625" class="pw-post-body-paragraph kg kh it ki b kj me kl km kn mf kp kq kr mg kt ku kv mh kx ky kz mi lb lc ld im bi translated">在GC过程中，它从应用程序不再使用的对象中释放内存。想象一下，你在一个方法中声明了几个变量，在执行之后，它们就不再需要了。</p><p id="abc9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">GC检查应用程序根以确定该对象是否仍在使用。对于每个根，GC将构建一个图，通过这个图，它可以找到未使用的对象。下面的照片试图展示活动根的图形和对象的关系。</p><figure class="my mz na nb gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi np"><img src="../Images/2acf36e43ace80e1abd8adf4f5765fb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qp8LbJIYeDiN4RR67dUZ2w.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">红色插槽是需要删除的无法访问的对象。</figcaption></figure><p id="a893" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">别忘了GC永远不会收集GC根。静态变量也被认为是GC根。</p><h2 id="a8bf" class="ll lm it bd ln lo lp dn lq lr ls dp lt kr lu lv lw kv lx ly lz kz ma mb mc md bi translated">5)智能内存应用程序！</h2><p id="3451" class="pw-post-body-paragraph kg kh it ki b kj me kl km kn mf kp kq kr mg kt ku kv mh kx ky kz mi lb lc ld im bi translated">当你用完每一个<a class="ae kf" href="https://docs.microsoft.com/en-us/dotnet/api/system.idisposable.dispose?view=netframework-4.8" rel="noopener ugc nofollow" target="_blank">一次性物品</a>后，将处理掉。位图对象、SQL连接或任何其他可任意处理的对象。</p><p id="34ac" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这可以通过使用如下语句来实现:</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="d9d6" class="ll lm it nd b gy nh ni l nj nk">using(var sqlCon = new SqlConnection()<br/>{<br/>} // sqlCon will be disposed here</span></pre><p id="2dc4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">或者手动调用dispose方法:</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="8b88" class="ll lm it nd b gy nh ni l nj nk">var bitMap = Bitmap.FromFile();<br/>// ..<br/>// rest of code ...<br/>// ..<br/>if(bitMap != null) bitMap.Dispose();</span></pre><p id="7733" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">避免使用静态成员</p><p id="3e06" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一些程序员认为使用静态成员是一种不好的做法，而且有代码味道。GC将静态变量视为GC根，它不会收集它们。</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="ff33" class="ll lm it nd b gy nh ni l nj nk">public class Cache<br/>{<br/> static List&lt;Object&gt; _internalCache = new List&lt;Object&gt;(); <br/> public void Add(obj) =&gt; _internalCache.Add(obj);<br/>}</span></pre><p id="9324" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的例子中，静态成员<code class="fe nl nm nn nd b">internalCache</code>是一个GC根，永远不会被收集。想象一下，向它添加对象不仅会导致应用程序内存泄漏，还会对GC隐藏大量对象！</p><p id="8d63" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">不要</strong>串联长字符串，改用<a class="ae kf" href="https://docs.microsoft.com/en-us/dotnet/api/system.text.stringbuilder?view=netframework-4.8" rel="noopener ugc nofollow" target="_blank"><strong class="ki iu">StringBuilder</strong></a>！</p><p id="fad5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">字符串是<a class="ae kf" href="https://docs.microsoft.com/en-us/dotnet/api/system.string?view=netframework-4.8" rel="noopener ugc nofollow" target="_blank">对象</a>，字符串是不可变的。所以通过连接它们，每次你创建另一个更大字符串。</p><figure class="my mz na nb gt ju"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="0a42" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果使用了<strong class="ki iu"> StringBuilder </strong>，程序只消耗<strong class="ki iu">141，140T20】字节。但是用加号运算符将它们连接起来将使用大约666，632个字节，是原来的6倍😲！</strong></p><p id="d7e6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">避免在匿名方法中捕获成员</p><p id="f855" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">看看这个例子:</p><figure class="my mz na nb gt ju"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="3e49" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu"> EnqueueJob </strong>中的匿名方法捕获了<code class="fe nl nm nn nd b">_uniqueId</code>这导致了<code class="fe nl nm nn nd b">Foo</code>引用的实例！</p><ol class=""><li id="fec0" class="mk ml it ki b kj kk kn ko kr mm kv mn kz mo ld ns mq mr ms bi translated">Foo引用了作业队列。</li><li id="3d81" class="mk ml it ki b kj mt kn mu kr mv kv mw kz mx ld ns mq mr ms bi translated">JobQueue在匿名方法中引用了Foo实例。</li></ol><p id="4973" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以只要JobQueue存在，Foo也会存在，因为GC总是在它们之间找到一个引用！</p><p id="8950" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">解决方案？本地复制变量可以解决这个问题。</strong></p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="0849" class="ll lm it nd b gy nh ni l nj nk">public void Foo()<br/>{<br/> var uniqueId = _uniqueId;</span><span id="c806" class="ll lm it nd b gy nt ni l nj nk">_jobQueue.EnqueueJob(() =&gt;<br/> {<br/>  Logger.Log($"Executing job {uniqueId}");<br/> });<br/>}</span></pre><p id="f43b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">😲事件处理程序可能会带来与匿名相同的问题</p><ul class=""><li id="a411" class="mk ml it ki b kj kk kn ko kr mm kv mn kz mo ld mp mq mr ms bi translated">完成后取消订阅</li><li id="379b" class="mk ml it ki b kj mt kn mu kr mv kv mw kz mx ld mp mq mr ms bi translated">如果可能的话，用匿名方法重写它们，不要捕获！</li></ul><p id="d047" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用<strong class="ki iu">武器参考</strong></p><p id="c6b4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">可以收集被引用的对象。<strong class="ki iu"> WeakReference </strong>可以用来允许访问对象，直到它们被GC收集。</p><figure class="my mz na nb gt ju"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="c614" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我将<strong class="ki iu"> StringBuilder </strong>定义为<strong class="ki iu"> WeakReference。因为这是一个弱引用，所以它每次都可以通过GC收集。所以我们需要检查它是否还活着。通过执行上面的代码，输出将是:</strong></p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="f7f7" class="ll lm it nd b gy nh ni l nj nk">Alive<br/>Sad, it's collected.</span></pre><p id="4329" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以GC是不可预测的，每次都可以收集，但是有时你需要缓存那些最终需要过期的东西，在这种情况下使用WeakReference。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><p id="60ff" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">📒总是用你能得到的任何内存分析器来分析你的应用程序！<strong class="ki iu">内存泄漏</strong>是你无法避免的。即使您将代码写得非常干净，也很有可能会发生内存泄漏。档案可以帮助你了解记忆中发生了什么。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h2 id="2631" class="ll lm it bd ln lo lp dn lq lr ls dp lt kr lu lv lw kv lx ly lz kz ma mb mc md bi translated">结论</h2><p id="3ba7" class="pw-post-body-paragraph kg kh it ki b kj me kl km kn mf kp kq kr mg kt ku kv mh kx ky kz mi lb lc ld im bi translated">垃圾收集是一项非常繁重的操作。让你的应用程序变得更有内存智慧不仅会阻止任何内存泄漏，还会对你的整个应用程序产生重大影响。因此，一个内存明智的应用程序是速度明智的！</p><h2 id="1c8d" class="ll lm it bd ln lo lp dn lq lr ls dp lt kr lu lv lw kv lx ly lz kz ma mb mc md bi translated">参考资料:</h2><ul class=""><li id="9f9e" class="mk ml it ki b kj me kn mf kr nu kv nv kz nw ld mp mq mr ms bi translated"><a class="ae kf" href="https://jonskeet.uk/csharp/memory.html" rel="noopener ugc nofollow" target="_blank">记忆在。乔恩·斯基特</a></li><li id="02fd" class="mk ml it ki b kj mt kn mu kr mv kv mw kz mx ld mp mq mr ms bi translated">在…的罩下。克里斯·法雷尔和尼克·哈里森的《网络内存管理》</li><li id="a63d" class="mk ml it ki b kj mt kn mu kr mv kv mw kz mx ld mp mq mr ms bi translated"><a class="ae kf" href="https://docs.microsoft.com/en-us/dotnet/standard/garbage-collection/fundamentals" rel="noopener ugc nofollow" target="_blank">微软文档垃圾收集基础</a></li></ul></div></div>    
</body>
</html>