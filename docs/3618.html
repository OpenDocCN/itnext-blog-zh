<html>
<head>
<title>A Workerpool From Scratch in TypeScript and Node</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在类型脚本和节点中从头开始工作</h1>
<blockquote>原文：<a href="https://itnext.io/a-workerpool-from-scratch-in-typescript-and-node-c4352106ffde?source=collection_archive---------1-----------------------#2020-01-19">https://itnext.io/a-workerpool-from-scratch-in-typescript-and-node-c4352106ffde?source=collection_archive---------1-----------------------#2020-01-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/c8e1a07881d52e199dd7fdd6830212e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*At6-3iVh3gdFdeoVRVyjSw.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@betno?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">张秀坤·贝德纳兹</a>在<a class="ae kc" href="https://unsplash.com/s/photos/workers?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="de11" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">await</code>和<code class="fe lb lc ld le b">async</code>关键字受到JavaScript开发人员的喜爱，因为它们能够以优雅的方式编写复杂的异步逻辑。但有一件事是不可能的:多个代码块同时运行的“真正”并发。JavaScript的架构是以这样一种方式建立的，即总是有一个进程运行在一个执行所有代码的线程上。异步行为是通过使用一个队列来实现的，该队列保存将要执行的下一个代码块。通过对该队列进行战术调度，可以暂停某个功能，直到在节点进程之外运行的某个后台任务完成，如文件操作或网络调用。但是不可能在另一个JavaScript函数运行的同时让其他JavaScript函数继续运行。</p><figure class="lf lg lh li gt jr"><div class="bz fp l di"><div class="lj lk l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">如何在节点中阻塞主进程的示例</figcaption></figure><p id="ee10" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码示例中，将会进行api调用，但是在此之后的<code class="fe lb lc ld le b">api</code>函数中的所有内容都不会被执行，因为该过程被while循环阻塞了。在处理大量数据的大节点应用程序中，这可能会成为一个严重的问题。为了解决这个问题<a class="ae kc" href="https://developer.mozilla.org/nl/docs/Web/API/Worker" rel="noopener ugc nofollow" target="_blank">工人</a>在那里介绍。它们允许开发人员启动一个全新的节点流程，该流程运行一个脚本，并可以通过事件系统与主流程通信。然而，这确实是一个新的节点实例，不像基于线程的系统那样有共享内存(例如C#或Java中的多线程)。这意味着当您将数据发送给一个worker时，它将被克隆并在另一个运行时重新创建。当在一个过程中传递对象并对其进行变异时，这可能会令人困惑。那些变异不会在另一边体现出来！模块的每个节点进程也将有一个实例，打破了它们默认的单例行为。</p><h1 id="823b" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">资源池</h1><p id="ea41" class="pw-post-body-paragraph kd ke iq kf b kg mj ki kj kk mk km kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">在上一段中，我们已经讨论了创建workers将会创建一个新的节点实例。这意味着创造新工人是一项相对繁重的任务。此外，还存在创建大量工作进程并使主机系统充满进程的风险。这就是资源池的用武之地。当我们启动应用程序时，我们将创建一定数量的工作线程，并在每次我们想要在另一个进程上运行任务时重用这些工作线程。这个工作线程池将由池管理器管理，池管理器接受任务并将它们分配给一个空闲的工作线程。函数本身将被封装在<code class="fe lb lc ld le b">Task</code>接口中，该接口提供了链接和运行任务的方法。我们可以使用Promises来轻松处理这种“真正的”异步代码，就像节点主机在后台为我们运行的网络和文件操作一样。</p><h1 id="7b14" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated"><strong class="ak">创建池</strong></h1><p id="e3c0" class="pw-post-body-paragraph kd ke iq kf b kg mj ki kj kk mk km kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">我们将从定义我们架构的总体形状开始。将有一个workerspool，它将包含所有带有任务的worker和queues。我决定给workerpool一个公共方法:<code class="fe lb lc ld le b">createTask</code>。此方法将创建一个任务，该任务将在创建它的池内运行。<code class="fe lb lc ld le b">Task</code>接口也有一个单独的公共方法:<code class="fe lb lc ld le b">runAsync</code>。该方法将在工作线程上运行包装的函数。这个函数的返回值是一个承诺，当一个工人执行完这个函数时，这个承诺就会被解决。这些接口定义如下:</p><figure class="lf lg lh li gt jr"><div class="bz fp l di"><div class="lj lk l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">任务是围绕一个函数的盒子，它使函数异步</figcaption></figure><p id="e1bf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">实现这些接口将从为workerpool创建一个构造函数开始。这个函数从定义池的所有内部开始:</p><ul class=""><li id="2e04" class="mo mp iq kf b kg kh kk kl ko mq ks mr kw ms la mt mu mv mw bi translated">一个id和workers的映射，包含我们池中的所有workers。这些workers将被一次性创建，并被workerpool将要执行的所有任务重用。</li><li id="6dea" class="mo mp iq kf b kg mx kk my ko mz ks na kw nb la mt mu mv mw bi translated">一个集合，包含空闲并准备接受新任务的工作线程的id。</li><li id="3094" class="mo mp iq kf b kg mx kk my ko mz ks na kw nb la mt mu mv mw bi translated">已排队并将尽快执行的积压任务。这些任务包括一个id、一个函数和发送给工人的附加数据。这里所有的数据都被输入为<code class="fe lb lc ld le b">any</code>，类型安全将在<code class="fe lb lc ld le b">Task</code>界面中介绍</li><li id="c732" class="mo mp iq kf b kg mx kk my ko mz ks na kw nb la mt mu mv mw bi translated">带有taskid和解析器的映射。解析器是当工作人员完成任务时将被调用的函数。每个任务都有自己的解析器。</li><li id="2fa5" class="mo mp iq kf b kg mx kk my ko mz ks na kw nb la mt mu mv mw bi translated">将用于分配增量任务标识符的计数器。</li></ul><figure class="lf lg lh li gt jr"><div class="bz fp l di"><div class="lj lk l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">我们允许外界来定义这个池子的大小</figcaption></figure><p id="0ef5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">workers由一个脚本构成，该脚本将是该节点实例的主进程。我们稍后将定义它的内容。有了这些定义，我们就可以开始添加执行任务的逻辑了。我们将从创建一个函数开始，如果有一个工人准备好了，这个函数将运行backlog上的下一个任务。为此，必须采取某些步骤:</p><ol class=""><li id="371e" class="mo mp iq kf b kg kh kk kl ko mq ks mr kw ms la nc mu mv mw bi translated">检查我们是否有一个任务和一个空闲的工作线程</li><li id="7270" class="mo mp iq kf b kg mx kk my ko mz ks na kw nb la nc mu mv mw bi translated">接受下一个任务和空闲的工人</li><li id="0ef8" class="mo mp iq kf b kg mx kk my ko mz ks na kw nb la nc mu mv mw bi translated">为员工构建信息。我们不能在工人之间发送函数，所以我们必须把它变成一个字符串</li><li id="ad6a" class="mo mp iq kf b kg mx kk my ko mz ks na kw nb la nc mu mv mw bi translated">将任务发送给员工</li></ol><p id="b5a6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后我们会再次调用<code class="fe lb lc ld le b">runNext</code>。这样，只要我们还有空闲的工作线程和任务，我们就会继续在工作线程上调度任务。每次我们接触到backlog或<code class="fe lb lc ld le b">idle</code>集合时，都应该调用<code class="fe lb lc ld le b">runNext</code>。这样，我们将总是尽可能快地安排任务。</p><figure class="lf lg lh li gt jr"><div class="bz fp l di"><div class="lj lk l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">在函数上调用toString会给出源代码</figcaption></figure><p id="ed30" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">之后，是时候创建将在workers内部运行的脚本了。这个脚本将监听任务的到达。当一个任务到达时，它将运行它们并将结果和标识符一起发送回来。要运行我们的函数，我们必须首先将它转换成命名函数。之后我们可以使用<code class="fe lb lc ld le b">eval</code>运行编译并运行它。该脚本可以在下面找到:</p><figure class="lf lg lh li gt jr"><div class="bz fp l di"><div class="lj lk l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">我们使用一些js魔法来确保我们总是在评估一个命名的函数</figcaption></figure><p id="1de6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来将发生的事情是workerpool接收结果并解析任务。为此，我们为所有工人添加了一个<code class="fe lb lc ld le b">message</code>监听器。在这里，我们调用任务id的resolver函数，并将worker放在空闲任务列表中。最后，我们调用<code class="fe lb lc ld le b">runNext</code>,以便处理积压工作，新的空闲工作者得到一个任务。</p><figure class="lf lg lh li gt jr"><div class="bz fp l di"><div class="lj lk l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">请注意，我们还在工作线程之间传输结果，因此它们也必须是可克隆的</figcaption></figure><h1 id="c932" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">创建任务</h1><p id="1148" class="pw-post-body-paragraph kd ke iq kf b kg mj ki kj kk mk km kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">现在我们已经有了workerpool的内部结构，我们可以开始创建和排队任务了。任务将由从<code class="fe lb lc ld le b">createWorkerpool</code>返回的函数创建。这意味着任务总是绑定到特定的workerpool。因此，我们的结构将如下所示:</p><figure class="lf lg lh li gt jr"><div class="bz fp l di"><div class="lj lk l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">从函数中返回对象意味着我们捕获了任务内部的池</figcaption></figure><p id="13de" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe lb lc ld le b">createTask</code>中，不发生任何退出的事情，它只是返回一个带有运行任务和使用池的函数的对象。为了运行该任务，我们必须采取以下步骤:</p><ol class=""><li id="f5dc" class="mo mp iq kf b kg kh kk kl ko mq ks mr kw ms la nc mu mv mw bi translated">创建新的taskid</li><li id="7b97" class="mo mp iq kf b kg mx kk my ko mz ks na kw nb la nc mu mv mw bi translated">将任务添加到待办事项中</li><li id="3695" class="mo mp iq kf b kg mx kk my ko mz ks na kw nb la nc mu mv mw bi translated">创建承诺并将解决程序添加到解决程序中</li><li id="7c9e" class="mo mp iq kf b kg mx kk my ko mz ks na kw nb la nc mu mv mw bi translated">兑现承诺</li><li id="9803" class="mo mp iq kf b kg mx kk my ko mz ks na kw nb la nc mu mv mw bi translated">调用<code class="fe lb lc ld le b">runNext</code>启动系统</li></ol><p id="8a23" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请注意，我们将Promise构造函数中的解析器设置为一个映射，该映射位于更高的闭包中。这样，我们可以回报承诺，并在以后从外部解决它。</p><figure class="lf lg lh li gt jr"><div class="bz fp l di"><div class="lj lk l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">主进程一次只运行一个函数，所以我们不会在taskIdCounter中得到竞争条件</figcaption></figure><p id="015a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在是时候对我们的系统进行第一次测试了。在下面的例子中，我在后台运行3个函数来计算不同数字的斐波纳契数列。如果您阅读控制台输出，您将看到任务在不同的时间并行运行和完成。</p><figure class="lf lg lh li gt jr"><div class="bz fp l di"><div class="lj lk l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">我们不能使<code class="fe lb lc ld le b">task</code>递归，因为它将在另一个不存在<code class="fe lb lc ld le b">task</code>的节点实例中运行</figcaption></figure><h1 id="2d44" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated"><strong class="ak">链接任务</strong></h1><p id="e45b" class="pw-post-body-paragraph kd ke iq kf b kg mj ki kj kk mk km kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">承诺的一个常用特性是将多个承诺按顺序连接起来，其中下一个承诺依赖于前一个承诺的输出。本文简介中的api调用就是一个很好的例子。我们使用<code class="fe lb lc ld le b">fetch</code>的结果来调用<code class="fe lb lc ld le b">json</code> on，并使用其结果来提取<code class="fe lb lc ld le b">value</code>属性。我还将把<code class="fe lb lc ld le b">then</code>函数添加到我们的<code class="fe lb lc ld le b">Task</code>接口中，以允许这种后台进程的链接。更新后的界面如下所示:</p><figure class="lf lg lh li gt jr"><div class="bz fp l di"><div class="lj lk l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">我们用一个从我们的结果到一个新的结果的任务来链接</figcaption></figure><p id="4df4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于实现，我们简单地覆盖<code class="fe lb lc ld le b">runAsync</code>函数，首先运行当前任务，当它解决后运行下一个任务。有了这个函数，我们可以不断地将任务链接在一起，以创建更大的进程，从而最佳地利用工人池的排队能力。</p><figure class="lf lg lh li gt jr"><div class="bz fp l di"><div class="lj lk l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">基于你是否使用<code class="fe lb lc ld le b">:</code>，这在对象文字上的工作是不同的</figcaption></figure><p id="1af6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个功能是这样使用的:</p><figure class="lf lg lh li gt jr"><div class="bz fp l di"><div class="lj lk l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">链接任务的工作方式与承诺相同</figcaption></figure><h1 id="34f3" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">结论</h1><p id="60b6" class="pw-post-body-paragraph kd ke iq kf b kg mj ki kj kk mk km kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">在这篇文章中，我讨论了JavaScript的一些最大的弱点和最强的特性。围绕这一点，我们编写了一个托管workerpool，它允许我们在并发性的道路上走得比JavaScript设计的更远。源代码可以在<a class="ae kc" href="https://github.com/WimJongeneel/ts-workerpool" rel="noopener ugc nofollow" target="_blank"> Github </a>上找到。这篇文章是我关于it的最新文章的后续，接下来你可能会喜欢:</p><div class="nd ne gp gr nf ng"><a rel="noopener  ugc nofollow" target="_blank" href="/a-web-server-from-scratch-in-typescript-854642a85402"><div class="nh ab fo"><div class="ni ab nj cl cj nk"><h2 class="bd ir gy z fp nl fr fs nm fu fw ip bi translated">在TypeScript和Node中从头开始创建Web服务器</h2><div class="nn l"><h3 class="bd b gy z fp nl fr fs nm fu fw dk translated">通过制作自己的来了解互联网</h3></div><div class="no l"><p class="bd b dl z fp nl fr fs nm fu fw dk translated">itnext.io</p></div></div><div class="np l"><div class="nq l nr ns nt np nu jw ng"/></div></div></a></div></div></div>    
</body>
</html>