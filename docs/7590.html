<html>
<head>
<title>Write your Kubernetes Infrastructure as Go code — Combine cdk8s with AWS CDK</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将您的Kubernetes基础设施编写为Go代码—将cdk8s与AWS CDK相结合</h1>
<blockquote>原文：<a href="https://itnext.io/write-your-kubernetes-infrastructure-as-go-code-combine-cdk8s-with-aws-cdk-425c7b8136c6?source=collection_archive---------5-----------------------#2022-11-16">https://itnext.io/write-your-kubernetes-infrastructure-as-go-code-combine-cdk8s-with-aws-cdk-425c7b8136c6?source=collection_archive---------5-----------------------#2022-11-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/aa0c154d626b1f56bbc2933878a741d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YlHypfWYZXvMu2Ak7CzyYg.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">cdk8s.io</figcaption></figure><div class=""/><p id="1923" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在之前的一篇博文中，您看到了如何将<a class="ae la" href="https://cdk8s.io/docs/latest/" rel="noopener ugc nofollow" target="_blank"> cdk8s </a>与<a class="ae la" href="https://aws-controllers-k8s.github.io/community/docs/community/overview/" rel="noopener ugc nofollow" target="_blank"> AWS控制器一起用于Kubernetes </a>(也称为<strong class="ke jg"> ACK </strong>)，这是因为您可以使用<code class="fe lb lc ld le b">cdk8s</code>导入现有的Kubernetes自定义资源定义！这使得使用<code class="fe lb lc ld le b">cdk8s</code>和Kubernetes将<code class="fe lb lc ld le b">DynamoDB</code>与客户端应用一起部署成为可能。</p><p id="0439" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">但是，如果你继续将<a class="ae la" href="https://docs.aws.amazon.com/cdk/v2/guide/home.html" rel="noopener ugc nofollow" target="_blank"> AWS CDK </a>用于AWS基础设施，并利用动力<code class="fe lb lc ld le b">cdk8s</code>(和<code class="fe lb lc ld le b">cdk8s-plus</code>)呢！)使用常规代码定义Kubernetes资源？由于AWS EKS模块和cdk8s之间的本机集成，您可以拥有两个世界的精华！</p><p id="5e42" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这篇博文的目的是用几个例子来证明这一点。我们将从一个简单的(基于nginx的)例子开始，然后转向一个成熟的应用堆栈(包括<code class="fe lb lc ld le b">DynamoDB</code>等)。).两者都将使用在<a class="ae la" href="https://docs.aws.amazon.com/cdk/v2/guide/work-with-cdk-go.html" rel="noopener ugc nofollow" target="_blank"> AWS CDK </a>以及<a class="ae la" href="https://cdk8s.io/docs/latest/getting-started/#prerequisites" rel="noopener ugc nofollow" target="_blank"> cdk8s </a>中得到很好支持的Go编程语言。</p><blockquote class="lf lg lh"><p id="f16b" class="kc kd li ke b kf kg kh ki kj kk kl km lj ko kp kq lk ks kt ku ll kw kx ky kz ij bi translated"><em class="jf">本博客讨论的所有代码均可在</em> <a class="ae la" href="https://github.com/abhirockzz/cdk8s-for-go-developers/tree/master/part6-cdk-eks-cdk8s" rel="noopener ugc nofollow" target="_blank"> <em class="jf">本GitHub repo </em> </a>中获得</p></blockquote></div><div class="ab cl lm ln hu lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="ij ik il im in"><h1 id="b97d" class="lt lu jf bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">先决条件</h1><p id="a358" class="pw-post-body-paragraph kc kd jf ke b kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv mv kx ky kz ij bi translated">除了AWS帐户之外，要逐步跟进，您还需要以下CLI—<a class="ae la" href="https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.html" rel="noopener ugc nofollow" target="_blank">AWS CLI</a>、<a class="ae la" href="https://cdk8s.io/docs/latest/getting-started/#install-the-cli" rel="noopener ugc nofollow" target="_blank"> cdk8s CLI </a>和<a class="ae la" href="https://kubernetes.io/docs/tasks/tools/#kubectl" rel="noopener ugc nofollow" target="_blank"> kubectl </a>。另外，不要忘记安装<a class="ae la" href="https://docs.aws.amazon.com/cdk/v2/guide/getting_started.html#getting_started_install" rel="noopener ugc nofollow" target="_blank"> AWS CDK </a>、<a class="ae la" href="https://go.dev/dl/" rel="noopener ugc nofollow" target="_blank"> Go编程语言</a>(1.16或以上版本)以及<a class="ae la" href="https://docs.docker.com/engine/install/" rel="noopener ugc nofollow" target="_blank"> Docker </a>，如果你还没有的话。</p><h1 id="9470" class="lt lu jf bd lv lw mw ly lz ma mx mc md me my mg mh mi mz mk ml mm na mo mp mq bi translated">在EKS用Nginx保持简单</h1><p id="5ede" class="pw-post-body-paragraph kc kd jf ke b kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv mv kx ky kz ij bi translated">就像生活中的大多数事情一样，有两种方式——简单的方式或困难的方式；)你会看到他们两个！让我们先尝试一下，看看它们是如何工作的，然后再看看代码。</p><p id="60c7" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">首先，克隆存储库并切换到正确的目录:</p><pre class="nb nc nd ne gt nf le ng bn nh ni bi"><span id="372e" class="nj lu jf le b be nk nl l nm nn">git clone https://github.com/abhirockzz/cdk8s-for-go-developers<br/>cd cdk8s-for-go-developers/part6-cdk-eks-cdk8s/cdk-cdk8s-nginx-eks</span></pre><p id="0bf8" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">要设置一切，您只需要一个命令:</p><pre class="nb nc nd ne gt nf le ng bn nh ni bi"><span id="e55a" class="nj lu jf le b be nk nl l nm nn">cdk deploy</span></pre><blockquote class="lf lg lh"><p id="6fd6" class="kc kd li ke b kf kg kh ki kj kk kl km lj ko kp kq lk ks kt ku ll kw kx ky kz ij bi translated"><em class="jf">您也可以使用</em> <code class="fe lb lc ld le b"><em class="jf">cdk synth</em></code> <em class="jf">先生成并检查云形成模板</em></p></blockquote><p id="fafa" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">系统将提示您确认。一旦你这样做了，过程将开始-这将需要一些时间，因为大量的AWS资源将被创建，包括VPC，EKS集群等。</p><blockquote class="lf lg lh"><p id="833b" class="kc kd li ke b kf kg kh ki kj kk kl km lj ko kp kq lk ks kt ku ll kw kx ky kz ij bi translated">请随时查看自动气象站云形成控制台来跟踪进度。</p></blockquote><p id="8e96" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">一旦这个过程完成，您需要使用<code class="fe lb lc ld le b">kubectl</code>连接到EKS集群。此所需的命令将作为<code class="fe lb lc ld le b">cdk deploy</code>过程(在终端中)的结果可用，或者您可以参考AWS云形成堆栈的<strong class="ke jg">输出</strong>部分。</p><figure class="nb nc nd ne gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi no"><img src="../Images/da9daaf9982e632ffc1d9ce28c97dd5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*XNkAWEJUEZD2oT3X.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">自动气象站云信息输出</figcaption></figure><p id="394b" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">一旦您将<code class="fe lb lc ld le b">kubectl</code>配置为指向您的EKS集群，您就可以检查Nginx <code class="fe lb lc ld le b">Deployment</code>和<code class="fe lb lc ld le b">Service</code>。</p><pre class="nb nc nd ne gt nf le ng bn nh ni bi"><span id="6846" class="nj lu jf le b be nk nl l nm nn">kubectl get deployment<br/><br/># output<br/>NAME                          READY   UP-TO-DATE   AVAILABLE   AGE<br/>nginx-deployment-cdk8s        1/1     1            1           1m<br/>nginx-deployment-cdk          1/1     1            1           1m</span></pre><p id="b756" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">你会看到已经创建了两个<code class="fe lb lc ld le b">Deployment</code>——稍后会有更多的介绍。同样，如果你检查<code class="fe lb lc ld le b">Service</code> ( <code class="fe lb lc ld le b">kubectl get svc</code>，你应该会看到其中的两个——<code class="fe lb lc ld le b">nginx-service-cdk</code>和<code class="fe lb lc ld le b">nginx-service-cdk8s</code>。</p><p id="24fd" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">要访问Nginx，选择两个<code class="fe lb lc ld le b">Service</code>中的任意一个<code class="fe lb lc ld le b">EXTERNAL-IP</code>，例如:</p><pre class="nb nc nd ne gt nf le np nq aw nr bi"><span id="af87" class="ns lu jf le b gy nt nu l nv nn">APP_URL=$(kubectl get service/nginx-service-cdk -o jsonpath="{.status.loadBalancer.ingress[0].hostname}")</span><span id="321a" class="ns lu jf le b gy nw nu l nv nn">echo $APP_URL</span><span id="1775" class="ns lu jf le b gy nw nu l nv nn"># to access nginx (notice we are using port 9090)<br/>curl -i <a class="ae la" rel="noopener ugc nofollow" target="_blank" href="/$APP_URL">http://$APP_URL:9090</a></span></pre><blockquote class="lf lg lh"><p id="610e" class="kc kd li ke b kf kg kh ki kj kk kl km lj ko kp kq lk ks kt ku ll kw kx ky kz ij bi translated"><em class="jf">如果在访问LB URL时出现</em> <code class="fe lb lc ld le b"><em class="jf">Could not resolve host</em></code> <em class="jf">错误，请等待一分钟左右，然后重试</em></p></blockquote><h2 id="6ac3" class="ns lu jf bd lv nx ny dn lz nz oa dp md kn ob oc mh kr od oe ml kv of og mp oh bi translated">在幕后</h2><p id="1af3" class="pw-post-body-paragraph kc kd jf ke b kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv mv kx ky kz ij bi translated">现在让我们<a class="ae la" href="https://github.com/abhirockzz/cdk8s-for-go-developers/blob/master/part6-cdk-eks-cdk8s/cdk-cdk8s-nginx-eks/main.go" rel="noopener ugc nofollow" target="_blank">看看代码</a>——这将阐明为什么我们有两个Nginx <code class="fe lb lc ld le b">Deployment</code>。</p><p id="223f" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">感谢AWS CDK公司，VPC创作公司与awsec2合二为一。NewVpc 函数和创建一个<a class="ae la" href="https://pkg.go.dev/github.com/aws/aws-cdk-go/awscdk/v2/awseks#NewCluster" rel="noopener ugc nofollow" target="_blank"> EKS集群</a>也不是太难！</p><pre class="nb nc nd ne gt nf le ng bn nh ni bi"><span id="d2f1" class="nj lu jf le b be nk nl l nm nn">func NewNginxOnEKSStack(scope constructs.Construct, id string, props *CdkStackProps) awscdk.Stack {<br/>  //...<br/>  vpc := awsec2.NewVpc(stack, jsii.String("demo-vpc"), nil)<br/>    eksSecurityGroup := awsec2.NewSecurityGroup(stack, jsii.String("eks-demo-sg"),<br/>        &amp;awsec2.SecurityGroupProps{<br/>            Vpc:               vpc,<br/>            SecurityGroupName: jsii.String("eks-demo-sg"),<br/>            AllowAllOutbound:  jsii.Bool(true)})<br/>    eksCluster := awseks.NewCluster(stack, jsii.String("demo-eks"),<br/>        &amp;awseks.ClusterProps{<br/>            ClusterName:   jsii.String("demo-eks-cluster"),<br/>            Version:       awseks.KubernetesVersion_V1_21(),<br/>            Vpc:           vpc,<br/>            SecurityGroup: eksSecurityGroup,<br/>            VpcSubnets: &amp;[]*awsec2.SubnetSelection{<br/>                {Subnets: vpc.PrivateSubnets()}},<br/>            DefaultCapacity:         jsii.Number(2),<br/>            DefaultCapacityInstance: awsec2.InstanceType_Of(awsec2.InstanceClass_BURSTABLE3, awsec2.InstanceSize_SMALL), DefaultCapacityType: awseks.DefaultCapacityType_NODEGROUP,<br/>            OutputConfigCommand: jsii.Bool(true),<br/>            EndpointAccess:      awseks.EndpointAccess_PUBLIC()})<br/>//...</span></pre></div><div class="ab cl lm ln hu lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="ij ik il im in"><h1 id="3012" class="lt lu jf bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">Kubernetes上的Nginx，来硬的！</h1><p id="0fd2" class="pw-post-body-paragraph kc kd jf ke b kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv mv kx ky kz ij bi translated">现在我们来看看创建Nginx的两种不同方式，从“硬”方式开始。在这种情况下，我们使用AWS CDK ( <em class="li">而不是</em> <code class="fe lb lc ld le b">cdk8s</code>)来定义<code class="fe lb lc ld le b">Deployment</code>和<code class="fe lb lc ld le b">Service</code>资源。</p><pre class="nb nc nd ne gt nf le ng bn nh ni bi"><span id="227f" class="nj lu jf le b be nk nl l nm nn">func deployNginxUsingCDK(eksCluster awseks.Cluster) {<br/>    appLabel := map[string]*string{<br/>        "app": jsii.String("nginx-eks-cdk"),<br/>    }<br/>    deployment := map[string]interface{}{<br/>        "apiVersion": jsii.String("apps/v1"),<br/>        "kind":       jsii.String("Deployment"),<br/>        "metadata": map[string]*string{<br/>            "name": jsii.String("nginx-deployment-cdk"),<br/>        },<br/>        "spec": map[string]interface{}{<br/>            "replicas": jsii.Number(1),<br/>            "selector": map[string]map[string]*string{<br/>                "matchLabels": appLabel,<br/>            },<br/>            "template": map[string]interface{}{<br/>                "metadata": map[string]map[string]*string{<br/>                    "labels": appLabel,<br/>                },<br/>                "spec": map[string][]map[string]interface{}{<br/>                    "containers": {<br/>                        {<br/>                            "name":  jsii.String("nginx"),<br/>                            "image": jsii.String("nginx"),<br/>                            "ports": []map[string]*float64{<br/>                                {<br/>                                    "containerPort": jsii.Number(80),<br/>                                },<br/>                            },<br/>                        },<br/>                    },<br/>                },<br/>            },<br/>        },<br/>    }<br/>    service := map[string]interface{}{<br/>        "apiVersion": jsii.String("v1"),<br/>        "kind":       jsii.String("Service"),<br/>        "metadata": map[string]*string{<br/>            "name": jsii.String("nginx-service-cdk"),<br/>        },<br/>        "spec": map[string]interface{}{<br/>            "type": jsii.String("LoadBalancer"),<br/>            "ports": []map[string]*float64{<br/>                {<br/>                    "port":       jsii.Number(9090),<br/>                    "targetPort": jsii.Number(80),<br/>                },<br/>            },<br/>            "selector": appLabel,<br/>        },<br/>    }<br/>    eksCluster.AddManifest(jsii.String("app-deployment"), &amp;service, &amp;deployment)<br/>}</span></pre><p id="c35d" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">最后，为了在EKS创建它，我们调用<a class="ae la" href="https://pkg.go.dev/github.com/aws/aws-cdk-go/awscdk/v2/awseks#Cluster.AddManifest" rel="noopener ugc nofollow" target="_blank"> AddManifest </a>(把它想象成<code class="fe lb lc ld le b">kubectl apply</code>的编程等价物)。这是可行的，但是这种方法存在一些缺陷:</p><ul class=""><li id="7019" class="oi oj jf ke b kf kg kj kk kn ok kr ol kv om kz on oo op oq bi translated">我们无法从Go这种强类型语言中获益。这是因为API是松散的T31类型，这要感谢无处不在的T6。这使得它非常容易出错(我也犯了一些错误！)</li><li id="5e22" class="oi oj jf ke b kf or kj os kn ot kr ou kv ov kz on oo op oq bi translated">冗长也很明显。看起来好像我们在<code class="fe lb lc ld le b">Go</code>中写<code class="fe lb lc ld le b">YAML</code>——没有太大的改进！</li></ul><h2 id="e447" class="ns lu jf bd lv nx ny dn lz nz oa dp md kn ob oc mh kr od oe ml kv of og mp oh bi translated">有更好的方法吗..？</h2><p id="b038" class="pw-post-body-paragraph kc kd jf ke b kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv mv kx ky kz ij bi translated">让我们看看第二个函数<code class="fe lb lc ld le b">deployNginxUsingCDK8s</code>——从它的名字可以明显看出，我们使用了<code class="fe lb lc ld le b">cdk8s</code>，而不仅仅是CDK)</p><pre class="nb nc nd ne gt nf le ng bn nh ni bi"><span id="4189" class="nj lu jf le b be nk nl l nm nn">func deployNginxUsingCDK8s(eksCluster awseks.Cluster) {<br/>    app := cdk8s.NewApp(nil)<br/>    eksCluster.AddCdk8sChart(jsii.String("nginx-eks-chart"), NewNginxChart(app, "nginx-cdk8s", nil), nil)<br/>}</span></pre><p id="359d" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这看起来“太容易”了，不可能是真的！但由于CDK和<code class="fe lb lc ld le b">cdk8s</code>之间的互操作性，这是可能的。这意味着，您可以使用<em class="li">定义</em> Kubernetes资源，使用<code class="fe lb lc ld le b">cdk8s</code> <code class="fe lb lc ld le b">Chart</code>将它们应用到用CDK创建的EKS集群(这使它成为一种混合系统)。</p><p id="534f" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们故事的主角是<a class="ae la" href="https://pkg.go.dev/github.com/aws/aws-cdk-go/awscdk/v2/awseks#Cluster.AddCdk8sChart" rel="noopener ugc nofollow" target="_blank"> AddCdk8sChart </a>函数，它接受一个<a class="ae la" href="https://pkg.go.dev/github.com/aws/constructs-go/constructs/v10#Construct" rel="noopener ugc nofollow" target="_blank">构造。构造</a>(记住，<a class="ae la" href="https://dev.to/abhirockzz/write-your-kubernetes-infrastructure-as-go-code-getting-started-with-cdk8s-37n" rel="noopener ugc nofollow" target="_blank">一切都是构造</a>！).在这种情况下，<code class="fe lb lc ld le b">Construct</code>恰好是一个<a class="ae la" href="https://pkg.go.dev/github.com/cdk8s-team/cdk8s-core-go/cdk8s/v2#Chart" rel="noopener ugc nofollow" target="_blank"> cdk8s。图表</a>是由<code class="fe lb lc ld le b">NewNginxChart</code>函数返回的，所以<a class="ae la" href="https://github.com/abhirockzz/cdk8s-for-go-developers/blob/master/part6-cdk-eks-cdk8s/cdk-cdk8s-nginx-eks/nginx.go" rel="noopener ugc nofollow" target="_blank">让我们来看看那个</a>。</p><pre class="nb nc nd ne gt nf le ng bn nh ni bi"><span id="5ecb" class="nj lu jf le b be nk nl l nm nn">func NewNginxChart(scope constructs.Construct, id string, props *MyChartProps) cdk8s.Chart {<br/>  //....<br/>    dep := cdk8splus22.NewDeployment(chart, jsii.String("nginx-deployment"),<br/>        &amp;cdk8splus22.DeploymentProps{<br/>            Metadata: &amp;cdk8s.ApiObjectMetadata{<br/>                Name: jsii.String("nginx-deployment-cdk8s")}})<br/>    dep.AddContainer(&amp;cdk8splus22.ContainerProps{<br/>        Name:  jsii.String("nginx-container"),<br/>        Image: jsii.String("nginx"),<br/>        Port:  jsii.Number(80)})<br/>    dep.ExposeViaService(&amp;cdk8splus22.DeploymentExposeViaServiceOptions{<br/>        Name:        jsii.String("nginx-service-cdk8s"),<br/>        ServiceType: cdk8splus22.ServiceType_LOAD_BALANCER,<br/>        Ports: &amp;[]*cdk8splus22.ServicePort{{<br/>            Port:       jsii.Number(9090),<br/>            TargetPort: jsii.Number(80)}}})<br/>    return chart<br/>}</span></pre><p id="70c9" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果你曾经和<code class="fe lb lc ld le b">cdk8s</code>(和Go)一起工作过，或者读过我以前关于这个主题的一些博客，这应该看起来很熟悉——一个强类型、紧凑和富于表现力的API！我甚至不需要带你走一遍，因为它非常易读——我们使用<code class="fe lb lc ld le b">cdk8s-plus</code>创建一个Nginx <code class="fe lb lc ld le b">Deployment</code>，添加容器信息，最后通过<code class="fe lb lc ld le b">Service</code>公开它，这样我们就可以从EKS之外访问Nginx。</p><p id="e525" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这是一个足够简单的例子来说明这两种方法之间的区别。下一个场景是不同的——除了EKS集群，它还有DynamoDB和一个URL shortener应用程序，将部署到EKS。</p></div><div class="ab cl lm ln hu lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="ij ik il im in"><h1 id="1b57" class="lt lu jf bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">端到端示例:DynamoDB及其在EKS的应用</h1><p id="c7dc" class="pw-post-body-paragraph kc kd jf ke b kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv mv kx ky kz ij bi translated">我们不是从头开始创建一个新的EKS集群，而是重用上一个示例中创建的现有集群——这是一个很好的机会来看看如何在您的CDK代码中引用现有的EKS集群。正如所料，我们还需要创建<code class="fe lb lc ld le b">DynamoDB</code>表。</p><p id="00ca" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">就像前面的例子一样，让我们先尝试一下解决方案。首先切换到正确的目录:</p><pre class="nb nc nd ne gt nf le np nq aw nr bi"><span id="019d" class="ns lu jf le b gy nt nu l nv nn">cd part6-cdk-eks-cdk8s/cdk-cdk8s-dynamodb-app-eks</span></pre><p id="ae8a" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">由于URL shortener应用程序必须对<code class="fe lb lc ld le b">DynamoDB</code>进行API调用，我们需要为服务帐户(也称为<strong class="ke jg"> IRSA </strong>)配置<a class="ae la" href="https://docs.aws.amazon.com/eks/latest/userguide/iam-roles-for-service-accounts.html" rel="noopener ugc nofollow" target="_blank"> IAM角色。</a></p><blockquote class="lf lg lh"><p id="716e" class="kc kd li ke b kf kg kh ki kj kk kl km lj ko kp kq lk ks kt ku ll kw kx ky kz ij bi translated"><em class="jf">参考</em><a class="ae la" href="https://docs.aws.amazon.com/eks/latest/userguide/create-service-account-iam-policy-and-role.html" rel="noopener ugc nofollow" target="_blank"><em class="jf">https://docs . AWS . Amazon . com/eks/latest/user guide/create-service-account-iam-policy-and-role . html</em></a></p></blockquote><p id="ccfa" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke jg">为应用程序定义IAM角色</strong></p><p id="5ee2" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">首先创建一个<a class="ae la" href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/" rel="noopener ugc nofollow" target="_blank"> Kubernetes服务帐户</a>:</p><pre class="nb nc nd ne gt nf le ng bn nh ni bi"><span id="4723" class="nj lu jf le b be nk nl l nm nn">kubectl apply -f - &lt;&lt;EOF<br/>apiVersion: v1<br/>kind: ServiceAccount<br/>metadata:<br/>  name: eks-dynamodb-app-sa<br/>EOF</span></pre><blockquote class="lf lg lh"><p id="eba3" class="kc kd li ke b kf kg kh ki kj kk kl km lj ko kp kq lk ks kt ku ll kw kx ky kz ij bi translated"><em class="jf">确认—</em>T0】</p></blockquote><p id="12f7" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">将您的AWS帐户ID和<a class="ae la" href="https://docs.aws.amazon.com/eks/latest/userguide/enable-iam-roles-for-service-accounts.html" rel="noopener ugc nofollow" target="_blank"> OIDC身份提供者</a>设置为环境变量:</p><pre class="nb nc nd ne gt nf le np nq aw nr bi"><span id="4cde" class="ns lu jf le b gy nt nu l nv nn">ACCOUNT_ID=$(aws sts get-caller-identity --query "Account" --output text)</span><span id="7115" class="ns lu jf le b gy nw nu l nv nn">export EKS_CLUSTER_NAME=&lt;enter cluster name&gt;<br/>export AWS_REGION=&lt;enter region e.g. us-east-1&gt;</span><span id="c187" class="ns lu jf le b gy nw nu l nv nn">OIDC_PROVIDER=$(aws eks describe-cluster --name $EKS_CLUSTER_NAME --query "cluster.identity.oidc.issuer" --output text | sed -e "s/^https:\/\///")</span></pre><p id="0509" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">为角色创建一个带有<em class="li">可信实体</em>的JSON文件:</p><pre class="nb nc nd ne gt nf le ng bn nh ni bi"><span id="6276" class="nj lu jf le b be nk nl l nm nn">read -r -d '' TRUST_RELATIONSHIP &lt;&lt;EOF<br/>{<br/>  "Version": "2012-10-17",<br/>  "Statement": [<br/>    {<br/>      "Effect": "Allow",<br/>      "Principal": {<br/>        "Federated": "arn:aws:iam::${ACCOUNT_ID}:oidc-provider/${OIDC_PROVIDER}"<br/>      },<br/>      "Action": "sts:AssumeRoleWithWebIdentity",<br/>      "Condition": {<br/>        "StringEquals": {<br/>          "${OIDC_PROVIDER}:aud": "sts.amazonaws.com",<br/>          "${OIDC_PROVIDER}:sub": "system:serviceaccount:default:eks-dynamodb-app-sa"<br/>        }<br/>      }<br/>    }<br/>  ]<br/>}<br/>EOF<br/>echo "${TRUST_RELATIONSHIP}" &gt; trust.json</span></pre><blockquote class="lf lg lh"><p id="0910" class="kc kd li ke b kf kg kh ki kj kk kl km lj ko kp kq lk ks kt ku ll kw kx ky kz ij bi translated"><em class="jf">检查—</em>T1】</p></blockquote><p id="422f" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在，创建IAM角色:</p><pre class="nb nc nd ne gt nf le ng bn nh ni bi"><span id="25db" class="nj lu jf le b be nk nl l nm nn">export ROLE_NAME=dynamodb-app-irsa<br/>aws iam create-role --role-name $ROLE_NAME --assume-role-policy-document file://trust.json --description "IRSA for DynamoDB app on EKS"</span></pre><p id="72e6" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们需要创建策略并将其附加到角色，因为我们只想允许应用程序中的<code class="fe lb lc ld le b">PutItem</code>和<code class="fe lb lc ld le b">GetItem</code>操作。下面是策略JSON文件:</p><pre class="nb nc nd ne gt nf le ng bn nh ni bi"><span id="8ebb" class="nj lu jf le b be nk nl l nm nn">{<br/>    "Version": "2012-10-17",<br/>    "Statement": [<br/>        {<br/>            "Sid": "PutandGet",<br/>            "Effect": "Allow",<br/>            "Action": [<br/>                "dynamodb:PutItem",<br/>                "dynamodb:GetItem"<br/>            ],<br/>            "Resource": "arn:aws:dynamodb:*:*:table/urls"<br/>        }<br/>    ]<br/>}</span></pre><p id="49ca" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">创建策略并将其附加到我们刚刚创建的角色:</p><pre class="nb nc nd ne gt nf le ng bn nh ni bi"><span id="2e17" class="nj lu jf le b be nk nl l nm nn">aws iam create-policy --policy-name dynamodb-irsa-policy --policy-document file://policy.json<br/>aws iam attach-role-policy --role-name $ROLE_NAME --policy-arn=arn:aws:iam::&lt;enter AWS account ID&gt;:policy/dynamodb-irsa-policy</span></pre><p id="2bc8" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">最后，我们需要关联IAM角色和服务帐户:</p><pre class="nb nc nd ne gt nf le ng bn nh ni bi"><span id="f310" class="nj lu jf le b be nk nl l nm nn">kubectl annotate serviceaccount -n default eks-dynamodb-app-sa eks.amazonaws.com/role-arn=arn:aws:iam::&lt;enter AWS account ID&gt;:role/dynamodb-app-irsa</span></pre><p id="c579" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke jg">得到EKS</strong><code class="fe lb lc ld le b"><strong class="ke jg">kubectl</strong></code>T31】角色ARN </p><p id="1802" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">要<a class="ae la" href="https://docs.aws.amazon.com/cdk/api/v2/docs/aws-cdk-lib.aws_eks-readme.html#using-existing-clusters" rel="noopener ugc nofollow" target="_blank">引用AWS CDK中现有的EKS集群</a>，您需要EKS集群名称和<code class="fe lb lc ld le b">kubectl</code>角色ARN。</p><p id="003a" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">你可以在AWS云形成堆栈的<strong class="ke jg">输出</strong>部分找到角色ARN。</p><figure class="nb nc nd ne gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi no"><img src="../Images/9757cd84c7ae9c5dbec38aad3213ddd6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*p1LSfqpb6cRByV3Y.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">ARN在自动气象站云信息输出中的作用</figcaption></figure><p id="62f2" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们已经准备好使用CDK部署应用程序。设置所需的环境变量，后跟<code class="fe lb lc ld le b">cdk deploy</code>:</p><blockquote class="lf lg lh"><p id="3b4c" class="kc kd li ke b kf kg kh ki kj kk kl km lj ko kp kq lk ks kt ku ll kw kx ky kz ij bi translated"><em class="jf">您也可以使用</em> <code class="fe lb lc ld le b"><em class="jf">cdk synth</em></code> <em class="jf">先生成并检查云形成模板</em></p></blockquote><pre class="nb nc nd ne gt nf le ng bn nh ni bi"><span id="9564" class="nj lu jf le b be nk nl l nm nn">export EKS_CLUSTER_NAME=&lt;enter name of EKS cluster&gt;<br/>export KUBECTL_ROLE_ARN=&lt;enter kubectl role ARN&gt;<br/>export SERVICE_ACCOUNT_NAME=eks-dynamodb-app-sa<br/>export APP_PORT=8080<br/>export AWS_REGION=&lt;enter region e.g. us-east-1&gt;<br/><br/>cdk deploy</span></pre><p id="4422" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">CDK(和<code class="fe lb lc ld le b">cdk8s</code>)将完成所有繁重的工作(我们很快就会看到代码):</p><ul class=""><li id="9fbc" class="oi oj jf ke b kf kg kj kk kn ok kr ol kv om kz on oo op oq bi translated">将创建新的DynamoDB表</li><li id="5d58" class="oi oj jf ke b kf or kj os kn ot kr ou kv ov kz on oo op oq bi translated">我们的应用程序的docker映像将被构建并推送到ECR</li><li id="7716" class="oi oj jf ke b kf or kj os kn ot kr ou kv ov kz on oo op oq bi translated">用于URL shortener应用程序的Kubernetes资源将被部署到现有的EKS集群中</li></ul><p id="605a" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">一旦堆栈创建完成，检查Kubernetes <code class="fe lb lc ld le b">Deployment</code>和<code class="fe lb lc ld le b">Service</code>:</p><pre class="nb nc nd ne gt nf le ng bn nh ni bi"><span id="40f5" class="nj lu jf le b be nk nl l nm nn">kubectl get deployment/dynamodb-app<br/>kubectl get pods<br/>kubectl get service/dynamodb-app-service</span></pre><p id="fd05" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">测试URL shortener服务很容易。但我不会在这里重复，因为它已经在[本博客](<a class="ae la" href="https://dev.to/abhirockzz/write-your-kubernetes-infrastructure-as-go-code-manage-aws-services-3pgi" rel="noopener ugc nofollow" target="_blank">https://dev . to/abhirockzz/write-your-kubernetes-infra structure-as-go-code-manage-AWS-services-3pgi</a>中涉及到了。你所需要的是负载平衡器的URL来访问服务，并使用yout浏览器或<code class="fe lb lc ld le b">curl</code>来保存和访问URL。</p><p id="6761" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke jg">再次回到探索Go代码</strong></p><p id="6ff2" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在堆栈中，我们定义了<code class="fe lb lc ld le b">DynamoDB</code>表(使用<a class="ae la" href="https://pkg.go.dev/github.com/aws/aws-cdk-go/awscdk/v2/awsdynamodb#NewTable" rel="noopener ugc nofollow" target="_blank"> awsdynamodb。NewTable </a>)以及我们的应用程序的docker图像(带有<a class="ae la" href="https://pkg.go.dev/github.com/aws/aws-cdk-go/awscdk/v2/awsecrassets#NewDockerImageAsset" rel="noopener ugc nofollow" target="_blank"> awsecrassets。NewDockerImageAsset </a></p><pre class="nb nc nd ne gt nf le ng bn nh ni bi"><span id="f5ce" class="nj lu jf le b be nk nl l nm nn">func NewDynamoDBAppStack(scope constructs.Construct, id string, props *CdkStackProps) awscdk.Stack {<br/>  //...<br/>    table := awsdynamodb.NewTable(stack, jsii.String("dynamodb-table"),<br/>        &amp;awsdynamodb.TableProps{<br/>            TableName: jsii.String(tableName),<br/>            PartitionKey: &amp;awsdynamodb.Attribute{<br/>                Name: jsii.String(dynamoDBPartitionKey),<br/>                Type: awsdynamodb.AttributeType_STRING,<br/>            },<br/>            BillingMode:   awsdynamodb.BillingMode_PAY_PER_REQUEST,<br/>            RemovalPolicy: awscdk.RemovalPolicy_DESTROY,<br/>        })<br/>    appDockerImage := awsecrassets.NewDockerImageAsset(stack, jsii.String("app-image"),<br/>        &amp;awsecrassets.DockerImageAssetProps{<br/>            Directory: jsii.String(appDirectory)})<br/>  //...g</span></pre><p id="8e0c" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">接下来是有趣的部分，我们获得对现有EKS集群的引用，并使用<code class="fe lb lc ld le b">AddCdk8sChart</code>(就像之前一样)将应用程序部署到EKS。</p><pre class="nb nc nd ne gt nf le ng bn nh ni bi"><span id="e240" class="nj lu jf le b be nk nl l nm nn">//...<br/>  eksCluster := awseks.Cluster_FromClusterAttributes(stack, jsii.String("existing cluster"),<br/>        &amp;awseks.ClusterAttributes{<br/>            ClusterName:    jsii.String(eksClusterName),<br/>            KubectlRoleArn: jsii.String(kubectlRoleARN)})<br/>    app := cdk8s.NewApp(nil)<br/>    appProps := NewAppChartProps(appDockerImage.ImageUri(), table.TableName())<br/>    eksCluster.AddCdk8sChart(jsii.String("dynamodbapp-chart"), NewDynamoDBAppChart(app, "dynamodb-cdk8s", &amp;appProps), nil)</span></pre><p id="116d" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><a class="ae la" href="https://github.com/abhirockzz/cdk8s-for-go-developers/blob/master/part6-cdk-eks-cdk8s/cdk-cdk8s-dynamodb-app-eks/dynamodb_app.go#L59" rel="noopener ugc nofollow" target="_blank"> NewDynamoDBAppChart函数</a>定义了<code class="fe lb lc ld le b">Deployment</code>和<code class="fe lb lc ld le b">Service</code>。不像前面的Nginx例子有静态值，这个应用程序接受动态值——特别是<code class="fe lb lc ld le b">DynamoDB</code>表名(用作容器环境变量<code class="fe lb lc ld le b">TABLE_NAME</code>)。还要注意这样一个事实，我们显式地添加了在上一步中创建的Kubernetes服务帐户的名称(用于<em class="li"> IRSA </em>)。</p><pre class="nb nc nd ne gt nf le ng bn nh ni bi"><span id="131d" class="nj lu jf le b be nk nl l nm nn">func NewDynamoDBAppChart(scope constructs.Construct, id string, props *AppChartProps) cdk8s.Chart {<br/>  //...<br/>    dep := cdk8splus22.NewDeployment(chart, jsii.String("dynamodb-app-deployment"), &amp;cdk8splus22.DeploymentProps{<br/>        Metadata: &amp;cdk8s.ApiObjectMetadata{<br/>            Name: jsii.String("dynamodb-app")},<br/>        ServiceAccount: cdk8splus22.ServiceAccount_FromServiceAccountName(<br/>            chart,<br/>            jsii.String("aws-irsa"),<br/>            jsii.String(props.serviceAccountName))})<br/>    container := dep.AddContainer(//.. omitted for brevity)<br/>    container.Env().AddVariable(jsii.String("TABLE_NAME"), cdk8splus22.EnvValue_FromValue(props.tableName))<br/>    container.Env().AddVariable(jsii.String("AWS_REGION"), cdk8splus22.EnvValue_FromValue(&amp;props.region))<br/>    dep.ExposeViaService(//.. omitted for brevity)<br/>    return chart<br/>}</span></pre></div><div class="ab cl lm ln hu lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="ij ik il im in"><h1 id="71fe" class="lt lu jf bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">包裹</h1><p id="4acf" class="pw-post-body-paragraph kc kd jf ke b kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv mv kx ky kz ij bi translated">本博客(及系列)到此为止！我们从一个简单的例子开始，展示AWS CDK和<code class="fe lb lc ld le b">cdk8s</code>之间的集成，以及它使事情变得多么容易(相比之下，只使用CDK将应用程序部署到EKS)。然后，我们继续探索一个成熟的场景，您可以在其中部署基础设施(<code class="fe lb lc ld le b">DynamoDB</code>等)。)以及EKS上的客户端应用程序。</p><p id="96d8" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">快乐大厦！</p></div></div>    
</body>
</html>