<html>
<head>
<title>Async/await without try/catch in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中不带try/catch的异步/等待</h1>
<blockquote>原文：<a href="https://itnext.io/async-await-without-try-catch-in-javascript-6dcdf705f8b1?source=collection_archive---------0-----------------------#2019-10-02">https://itnext.io/async-await-without-try-catch-in-javascript-6dcdf705f8b1?source=collection_archive---------0-----------------------#2019-10-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/3d174c9343a9f6ddb1048c6cb7eec7c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jcywAqHuABrR1wt0oB1WCQ.png"/></div></div></figure><p id="2152" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="kz">“如何确保正确处理异步错误”</em></p><p id="e93b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当<em class="kz"> async/await </em>发布时，它成为了JavaScript开发的游戏改变者。它允许以同步的方式编写代码，我们不需要连锁的承诺处理程序:</p><figure class="la lb lc ld gt ju"><div class="bz fp l di"><div class="le lf l"/></div></figure><p id="a1b2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如何用<em class="kz">异步/等待</em>语法重构这段代码:</p><figure class="la lb lc ld gt ju"><div class="bz fp l di"><div class="le lf l"/></div></figure><p id="9dae" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在遵循代码更容易了。但是我们仍然可以对代码做一些改进，使其更加整洁。</p><p id="6518" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因为我们用<em class="kz"> try/catch </em>包装了我们的异步函数，我们期望在下面的<em class="kz"> catch </em>块中处理来自这个函数的所有错误。但是如果我们在这个<em class="kz"> try </em>块中继续我们的代码呢？这意味着所有错误都将落入最近的<em class="kz"> catch </em>块。</p><figure class="la lb lc ld gt ju"><div class="bz fp l di"><div class="le lf l"/></div></figure><p id="2e37" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们添加的代码越多，<em class="kz"> catch </em>块就变得越不清晰，越普通。我们防止这种情况的唯一方法是仔细检查代码。但是我们怎么能只对<em class="kz"> fetchPosts </em>函数进行错误处理呢？</p><p id="f192" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">即使我们的代码看起来不像是在履行承诺，但别忘了我们仍然在履行承诺。每一个用<em class="kz"> async </em>关键字声明的函数都返回一个承诺，即使我们没有明确的返回语句。因为我们有一个承诺，我们可以使用它的所有方法。我们感兴趣的是<a class="ae lg" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/catch" rel="noopener ugc nofollow" target="_blank">promise . prototype . catch</a>这个方法也返回一个承诺，所以我们可以将它与一个<em class="kz"> await </em>关键字结合起来。</p><figure class="la lb lc ld gt ju"><div class="bz fp l di"><div class="le lf l"/></div></figure><p id="3a4e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这允许显式地捕捉异步函数的错误，并且当<em class="kz"> doSomethingWithPosts </em>中发生某些事情时，它不会进入<em class="kz">fetch post catch</em>块，我们可以单独处理错误。</p><h1 id="0353" class="lh li it bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">结论</h1><p id="9f26" class="pw-post-body-paragraph kb kc it kd b ke mf kg kh ki mg kk kl km mh ko kp kq mi ks kt ku mj kw kx ky im bi translated">当使用<em class="kz"> async/await </em>时，我们可以使用常规承诺的所有函数来避免代码中的<em class="kz"> try/catch </em>噪声，有助于显式处理错误并保持变量为常量。</p></div></div>    
</body>
</html>