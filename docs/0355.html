<html>
<head>
<title>I Promise These Are Easy (js promises)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我保证这些都很容易(js承诺)</h1>
<blockquote>原文：<a href="https://itnext.io/i-promise-these-are-easy-js-promises-c0a6b1f33e7?source=collection_archive---------3-----------------------#2018-02-25">https://itnext.io/i-promise-these-are-easy-js-promises-c0a6b1f33e7?source=collection_archive---------3-----------------------#2018-02-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/816b6aa25906a4ecaa0bf20c0f42c806.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Bf17KrH3fJo09LTKHRYJcw.jpeg"/></div></div></figure><p id="0735" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kw" href="https://www.linkedin.com/cws/share?url=https%3A%2F%2Fitnext.io%2Fi-promise-these-are-easy-js-promises-c0a6b1f33e7" rel="noopener ugc nofollow" target="_blank"> <em class="kx">点击这里在LinkedIn </em> </a>上分享这篇文章</p><p id="8ae2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">已经有一段时间了，但我答应过我会写这篇文章，所以就在这里。首先，让我们用一个简单的例子来确定你是否在正确的地方。这里有一个你以前可能用过的承诺:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="d0ef" class="lh li iq ld b gy lj lk l ll lm">$.get('<a class="ae kw" href="https://randomuser.me/api/'" rel="noopener ugc nofollow" target="_blank">https://randomuser.me/api/'</a>)<br/>  .done(function(data) {<br/>   console.log(data.results[0]);<br/>  })<br/>  .catch(function(err) {<br/>    console.log('Error: ' + err.responseText)<br/>  });</span></pre><p id="ebaf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">很可能你已经使用了上面的片段几十次，却没有真正思考它是如何工作的。首先，它可能有助于理解什么是回调，所以如果你不熟悉这个术语，你可能想读一读我以前关于<a class="ae kw" href="https://medium.com/@jgrisafe/callbacks-for-babies-ae5624257a6f" rel="noopener">回调</a>的文章。承诺清理了臭名昭著的回调地狱，你可能听说过。这看起来有点像史蒂夫·巴斯米作为一个代码块的转世。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="e8ad" class="lh li iq ld b gy lj lk l ll lm">fs.readdir(source, <strong class="ld ir">function</strong> (err, files) {<br/>  getData(function(x){<br/>    getMoreData(x, function(y){<br/>        getMoreData(y, function(z){ <br/>            ...<br/>        });<br/>    });<br/>});</span></pre><p id="92ec" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">很丑，是吧？别担心，你再也看不到了。承诺旨在让异步代码看起来更像瑞恩·高斯林，但不幸的是，他们并没有完全实现。你必须阅读我在async/await上的下一篇文章(抓紧你的裤子，这一篇我会更快)。</p><p id="5a45" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">那么到底什么是承诺呢？好吧，正如大多数代码一样，这个定义并不公平，特别是如果你只是在学习编码，有些东西看起来仍然像象形文字。承诺本质上是一个表示异步操作完成或失败的对象(<a class="ae kw" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" rel="noopener ugc nofollow" target="_blank"> Mozilla </a>)。通俗地说，promise是一个由异步函数返回的对象，比如ajax调用，它<em class="kx">承诺</em>无论函数成功还是失败都运行代码。promise对象通常至少有两个主要的方法(函数)，称为<code class="fe ln lo lp ld b">then</code>和<code class="fe ln lo lp ld b">catch</code>。不幸的是，有些库，比如jQuery，喜欢与众不同，用自己的方式实现它们。所以你可能会看到<code class="fe ln lo lp ld b">then</code>被<code class="fe ln lo lp ld b">done</code>取代，或者<code class="fe ln lo lp ld b">catch</code>被<code class="fe ln lo lp ld b">fail</code>取代。请务必阅读文档！</p><p id="cd28" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe ln lo lp ld b">then</code>和<code class="fe ln lo lp ld b">catch</code>方法各有一个参数，即臭名昭著的回调函数，当函数的目的实现或失败时，将分别运行该函数。让我们用一些代码对此进行分解:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="b868" class="lh li iq ld b gy lj lk l ll lm">// The function below returns a promise object.<br/>// You can think of the the result of this function as an object<br/>// that looks like this { then: function..., catch: function... }<br/>// so that's why you can chain the then/catch functions onto it</span><span id="a174" class="lh li iq ld b gy lq lk l ll lm">asynchronousFunction() // immediately returns promise when called</span><span id="6560" class="lh li iq ld b gy lq lk l ll lm">  // when the asynchronous operation completes,<br/>  // the callback (anonymous function) you pass here is run<br/>  .then(function(result) {</span><span id="a90e" class="lh li iq ld b gy lq lk l ll lm">      // the optional result is passed/injected into your callback<br/>      // now you can use it in something like...<br/>      $('.some-class').text(result.something)<br/>   })<br/>   <br/>   // if the operation fails the error<br/>   // will be passed/injected into the catch callback<br/>   .catch(function(err) {</span><span id="1670" class="lh li iq ld b gy lq lk l ll lm">     // do something with the error such as<br/>     // showing it to the user in the html markup or<br/>     console.log(err);<br/>   })</span></pre><p id="2738" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">开始看起来很像美元。阿贾克斯哈？所以现在你就像“好酷，你刚刚给我看了我已经在用的，非常感谢。”别担心，在我向你展示如何创造你自己的承诺之前，我只是在制定基本规则。</p><p id="570f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在此之前，让我们提醒你一件关于复试的小事。请记住，回调只是作为参数传递并由另一个函数调用的函数。因此，前面的示例可以这样编写，并且工作方式完全相同:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="4914" class="lh li iq ld b gy lj lk l ll lm">function successCallback(result) {<br/>  $('.some-class').text(result.something)<br/>}</span><span id="c55e" class="lh li iq ld b gy lq lk l ll lm">function errorCallback(err) {<br/>  console.log(err);<br/>}</span><span id="7015" class="lh li iq ld b gy lq lk l ll lm">asynchronousFunction()<br/>  .then(successCallback)<br/>  .catch(errorCallback)</span></pre><p id="a966" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请记住，像第一个例子中一样，匿名函数只是编写上述内容的一种更简短的方式，在javascript中，函数可以像任何其他数据类型一样作为参数传递！好的，所以，如果事情开始清楚承诺的用法，让我们继续创造它们。如果没有，复制顶部的jQuery代码，并对其进行修改，直到您满意为止(它工作了)。</p><p id="de45" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">ES2015或ES6具有内置承诺。因此，您可以创建异步函数，而无需导入任何库。所有主流浏览器都支持这一点(显然，除了Internet Explorer)。所以我们可以这样做:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="2b15" class="lh li iq ld b gy lj lk l ll lm">// this function, waitThreeSeconds, returns a promise</span><span id="fc38" class="lh li iq ld b gy lq lk l ll lm">function waitThreeSeconds() {</span><span id="93d0" class="lh li iq ld b gy lq lk l ll lm">  // below is the constructor for the promise. It takes a <br/>  // callback that accepts two arguments,<br/>  // resolve and reject (functions)<br/>  // you call these functions when the code succeeds or fails</span><span id="a9c7" class="lh li iq ld b gy lq lk l ll lm">  return new Promise(function(resolve, reject) {</span><span id="ee8f" class="lh li iq ld b gy lq lk l ll lm">   setTimeout(function() {</span><span id="b55f" class="lh li iq ld b gy lq lk l ll lm">      // resolve the promise after 3 seconds<br/>      // the function you pass to 'then' will be called<br/>      resolve();</span><span id="82da" class="lh li iq ld b gy lq lk l ll lm">    }, 3000);<br/>  })<br/>}</span><span id="dd82" class="lh li iq ld b gy lq lk l ll lm">// call the asynchronous function, which returns our promise<br/>waitThreeSeconds()</span><span id="68dc" class="lh li iq ld b gy lq lk l ll lm">  // chain the 'then' method, which accepts a callback to <br/>  // be called when the promise is rsolved<br/> .then(function() {<br/>   alert('It\'s been three seconds!');<br/> })</span><span id="63f6" class="lh li iq ld b gy lq lk l ll lm"> // we don't need a catch method in this example, because the<br/> // promise has no potential to fail (be rejected)</span></pre><p id="6d3b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<a class="ae kw" href="https://repl.it/@jgrisafe/AccomplishedUnlawfulChapter" rel="noopener ugc nofollow" target="_blank"> repl.it </a>上试试这个，自己看吧！正如你在上面看到的，你不需要链接一个<code class="fe ln lo lp ld b">catch</code>函数，但是如果你的代码有失败的可能，你必须用<code class="fe ln lo lp ld b">reject</code>在promise中处理它，然后在你调用函数时使用<code class="fe ln lo lp ld b">catch</code>来处理拒绝。</p><p id="61ce" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面的代码在现实生活中没什么用处，所以让我给你举个例子，你可能会用到承诺。假设您想创建一个提示用户上传文件的功能，一旦文件被选中(或未选中)，您想在页面上向用户显示一条消息。检查这个<a class="ae kw" href="https://jsfiddle.net/jgrisafe/Le7pxr5j/54/" rel="noopener ugc nofollow" target="_blank"> jsfiddle </a>来查看html标记和css。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="0a0b" class="lh li iq ld b gy lj lk l ll lm">function promptUserForFile() {</span><span id="4cf4" class="lh li iq ld b gy lq lk l ll lm">  return new Promise(function(resolve, reject) {</span><span id="3769" class="lh li iq ld b gy lq lk l ll lm">    // call the click event on a hidden file input<br/>    $('#file-input').click();<br/>    <br/>    // set an interval to check if the document regains<br/>    // focus (when the file dialog closes). If no file<br/>    // was chosen, reject the promise<br/>    const interval = setInterval(function() {<br/>        const fileCount = $('#file-input')[0].files.length;<br/>        if (document.hasFocus() &amp;&amp; !fileCount) {<br/>          clearInterval(interval)<br/>          reject();<br/>        }<br/>    }, 1000);<br/>    <br/>    // if the file input changes, resolve the promise<br/>    // and pass it the file name<br/>    $('#file-input').on('change', function() {<br/>      const filePath = $(this).val();<br/>      const fileName = filePath.split('\\').pop();<br/>      clearInterval(interval)<br/>      resolve(fileName);<br/>    })<br/>  })<br/>}</span><span id="3f55" class="lh li iq ld b gy lq lk l ll lm">$('button').on('click', function() {</span><span id="e3ac" class="lh li iq ld b gy lq lk l ll lm">  // call the asynchronous function<br/>  promptUserForFile()<br/>  <br/>   // when it's resolved (file chosen), set the success text<br/>   .then(function(fileName) {<br/>     $('.file-chosen-message').text('File chosen: ' + fileName);<br/>   })<br/>   <br/>   // when it's rejected (no file), set the error text<br/>   .catch(function() {<br/>     $('.file-chosen-message')<br/>       .text('no file chosen')<br/>       .addClass('error');<br/>   })<br/>})</span></pre><p id="2b87" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好吧，我知道这很难接受。但是让我们试着把它分解成一些容易阅读的步骤。</p><ol class=""><li id="5ea2" class="lr ls iq ka b kb kc kf kg kj lt kn lu kr lv kv lw lx ly lz bi translated">创建一个异步函数<code class="fe ln lo lp ld b">promptUserForFile</code>，返回一个promise对象。</li><li id="2647" class="lr ls iq ka b kb ma kf mb kj mc kn md kr me kv lw lx ly lz bi translated">该函数在隐藏的文件输入上调用一个click事件，我们选择隐藏它是因为它们很难看，我们需要自己的标记。</li><li id="2bde" class="lr ls iq ka b kb ma kf mb kj mc kn md kr me kv lw lx ly lz bi translated">promise在文件输入上设置了一个事件监听器，以监视变化。这仅在用户选择文件时发生。</li><li id="e89a" class="lr ls iq ka b kb ma kf mb kj mc kn md kr me kv lw lx ly lz bi translated">如果文件输入发生变化，我们解析承诺并传递文件名给它。</li><li id="e829" class="lr ls iq ka b kb ma kf mb kj mc kn md kr me kv lw lx ly lz bi translated">它还设置了一个时间间隔，用于观察文档是否重新获得焦点，这将在文件上传对话框关闭时发生。</li><li id="0d28" class="lr ls iq ka b kb ma kf mb kj mc kn md kr me kv lw lx ly lz bi translated">如果interval检测到对话框已经关闭(文档重新获得焦点)，但用户没有选择文件，它将拒绝承诺。</li><li id="040e" class="lr ls iq ka b kb ma kf mb kj mc kn md kr me kv lw lx ly lz bi translated">“解决”和“拒绝”都将清除该时间间隔，以便用户下次单击该按钮时可以再次设置。</li><li id="2e2a" class="lr ls iq ka b kb ma kf mb kj mc kn md kr me kv lw lx ly lz bi translated">接下来，我们在自定义按钮上设置了click listener，它看起来比原生文件输入好得多。</li><li id="778d" class="lr ls iq ka b kb ma kf mb kj mc kn md kr me kv lw lx ly lz bi translated">点击事件触发了我们的异步函数<code class="fe ln lo lp ld b">pomptUserForFile</code>，并将两个回调函数传递给<code class="fe ln lo lp ld b">then</code>和<code class="fe ln lo lp ld b">catch</code>。</li><li id="e3c1" class="lr ls iq ka b kb ma kf mb kj mc kn md kr me kv lw lx ly lz bi translated"><code class="fe ln lo lp ld b">then</code>和<code class="fe ln lo lp ld b">catch</code>回调将在页面上设置一些文本，无论用户是否选择了文件，也就是承诺被解决或拒绝的时间。</li><li id="2a3f" class="lr ls iq ka b kb ma kf mb kj mc kn md kr me kv lw lx ly lz bi translated">你可以想象我们可以在这些回调中放入任何我们想要的东西，这样我们的承诺处理就非常灵活。例如，如果我们愿意，我们可以在页面上显示图像。</li></ol><p id="7598" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好了，我们已经想出了一个实际的例子，当我们想要使用我们自己的承诺的时候。多好的旅程啊！我希望这篇文章对如何使用和创造承诺有所启发。如果有什么不清楚的，请在评论中说出来，我会做必要的更新！一份爱，乔伊。</p></div></div>    
</body>
</html>