<html>
<head>
<title>React setState usage and gotchas</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应设置状态用法和陷阱</h1>
<blockquote>原文：<a href="https://itnext.io/react-setstate-usage-and-gotchas-ac10b4e03d60?source=collection_archive---------0-----------------------#2018-03-10">https://itnext.io/react-setstate-usage-and-gotchas-ac10b4e03d60?source=collection_archive---------0-----------------------#2018-03-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/></div><div class="ab cl jn jo hu jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ij ik il im in"><figure class="jv jw jx jy gt jz gh gi paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="gh gi ju"><img src="../Images/651693188ebf89b808998ee4a6b5c3d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1EdhEzJOw80RPWj64ydsAA.jpeg"/></div></div></figure><blockquote class="kg kh ki"><p id="855c" class="kj kk kl km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated"><a class="ae li" href="https://www.linkedin.com/cws/share?url=https%3A%2F%2Fitnext.io%2Freact-setstate-usage-and-gotchas-ac10b4e03d60%3Futm_source%3Dmedium_sharelink%26utm_medium%3Dsocial%26utm_campaign%3Dbuffer" rel="noopener ugc nofollow" target="_blank"> <em class="iq">点击这里在LinkedIn </em> </a>上分享这篇文章</p></blockquote><p id="6a7c" class="pw-post-body-paragraph kj kk iq km b kn ko kp kq kr ks kt ku lj kw kx ky lk la lb lc ll le lf lg lh ij bi translated">React类组件有一个内部状态，像props一样影响组件的渲染和行为。与props不同，状态是组件的本地状态，只能在组件内部初始化和更新。</p><h1 id="baeb" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated"><strong class="ak">初始化</strong></h1><p id="5af3" class="pw-post-body-paragraph kj kk iq km b kn mk kp kq kr ml kt ku lj mm kx ky lk mn lb lc ll mo lf lg lh ij bi translated">在使用state之前，我们需要为初始状态声明一组缺省值。这可以通过在构造函数中创建一个状态对象或者直接在类中创建来实现。</p><pre class="jv jw jx jy gt mp mq mr ms aw mt bi"><span id="d8f2" class="mu ln iq mq b gy mv mw l mx my">class Counter extends React.Component {<br/>  constructor(props, context) {<br/>    super(props, context)<br/>    this.state = {<br/>      quantity: 1,<br/>      counter: 0<br/>    }<br/>  }<br/>}</span><span id="3d2a" class="mu ln iq mq b gy mz mw l mx my">class Counter extends React.Component {<br/>  state = {<br/>    quantity: 1,<br/>    counter: 0<br/>  }<br/>}</span></pre><h1 id="46fb" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated"><strong class="ak">更新</strong></h1><p id="6c66" class="pw-post-body-paragraph kj kk iq km b kn mk kp kq kr ml kt ku lj mm kx ky lk mn lb lc ll mo lf lg lh ij bi translated">状态可以响应于事件处理程序、服务器响应或属性改变而被更新。React为此提供了一个名为<code class="fe na nb nc mq b">setState</code>的方法。</p><p id="9fbc" class="pw-post-body-paragraph kj kk iq km b kn ko kp kq kr ks kt ku lj kw kx ky lk la lb lc ll le lf lg lh ij bi translated"><code class="fe na nb nc mq b">setState()</code>将组件状态的更改排入队列，并告诉React该组件及其子组件需要用更新后的状态重新呈现。</p><pre class="jv jw jx jy gt mp mq mr ms aw mt bi"><span id="a57f" class="mu ln iq mq b gy mv mw l mx my">this.setState({quantity: 2})</span></pre><p id="112b" class="pw-post-body-paragraph kj kk iq km b kn ko kp kq kr ks kt ku lj kw kx ky lk la lb lc ll le lf lg lh ij bi translated">这里，我们传递了一个包含我们想要更新的状态的对象<code class="fe na nb nc mq b">setState()</code>。传递的对象会有对应于组件状态中的键的键，然后<code class="fe na nb nc mq b">setState()</code>通过将对象合并到状态来更新或设置状态。</p><h1 id="44b0" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated"><strong class="ak">设置状态并重新渲染</strong></h1><p id="0b78" class="pw-post-body-paragraph kj kk iq km b kn mk kp kq kr ml kt ku lj mm kx ky lk mn lb lc ll mo lf lg lh ij bi translated"><code class="fe na nb nc mq b">setState()</code>将总是导致重新渲染，除非<code class="fe na nb nc mq b">shouldComponentUpdate()</code>返回<code class="fe na nb nc mq b">false</code>。为了避免不必要的渲染，只在新状态不同于前一状态时调用<code class="fe na nb nc mq b">setState()</code>是有意义的，并且可以避免在某些生命周期方法(如<code class="fe na nb nc mq b">componentDidUpdate</code>)中无限循环地调用<code class="fe na nb nc mq b">setState()</code>。</p><blockquote class="kg kh ki"><p id="7309" class="kj kk kl km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">从16开始，用<code class="fe na nb nc mq b">null</code>调用<code class="fe na nb nc mq b">setState</code>不再触发更新。这意味着我们可以决定是否在我们的<code class="fe na nb nc mq b">setState</code>方法本身中更新状态！</p></blockquote><h1 id="e56e" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated"><strong class="ak">签名</strong></h1><pre class="jv jw jx jy gt mp mq mr ms aw mt bi"><span id="39d6" class="mu ln iq mq b gy mv mw l mx my">setState(<!-- -->updater[, callback]<!-- -->)</span></pre><p id="510f" class="pw-post-body-paragraph kj kk iq km b kn ko kp kq kr ks kt ku lj kw kx ky lk la lb lc ll le lf lg lh ij bi translated">第一个参数是一个带有签名的<code class="fe na nb nc mq b">updater</code>函数:</p><pre class="jv jw jx jy gt mp mq mr ms aw mt bi"><span id="843a" class="mu ln iq mq b gy mv mw l mx my">(prevState, props) =&gt; stateChange</span></pre><p id="d783" class="pw-post-body-paragraph kj kk iq km b kn ko kp kq kr ks kt ku lj kw kx ky lk la lb lc ll le lf lg lh ij bi translated"><code class="fe na nb nc mq b">prevState</code>是对之前状态的引用。应该不会直接变异。相反，应该通过基于来自<code class="fe na nb nc mq b">prevState</code>和<code class="fe na nb nc mq b">props</code>的输入构建一个新对象来表示变化。例如，通过<code class="fe na nb nc mq b">props.step</code>增加状态值:</p><pre class="jv jw jx jy gt mp mq mr ms aw mt bi"><span id="1455" class="mu ln iq mq b gy mv mw l mx my">this.setState((prevState, props) =&gt; {<br/>  return {counter: prevState.counter + props.step};<br/>})</span></pre><blockquote class="kg kh ki"><p id="1763" class="kj kk kl km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">由于<code class="fe na nb nc mq b">setState</code>的异步特性，不建议使用<code class="fe na nb nc mq b">this.state</code>在<code class="fe na nb nc mq b">setState</code>内获得前一个状态。而是一直依靠上面的方式。更新函数接收到的<code class="fe na nb nc mq b">prevState</code>和<code class="fe na nb nc mq b">props</code>都保证是最新的。更新器的输出与<code class="fe na nb nc mq b">prevState</code>浅合并。</p></blockquote><p id="eb32" class="pw-post-body-paragraph kj kk iq km b kn ko kp kq kr ks kt ku lj kw kx ky lk la lb lc ll le lf lg lh ij bi translated"><code class="fe na nb nc mq b">setState()</code>的第二个参数是一个可选的回调函数，一旦<code class="fe na nb nc mq b">setState</code>完成并且组件被重新渲染，这个函数就会被执行。<code class="fe na nb nc mq b">componentDidUpdate</code>应改为在大多数情况下应用此类逻辑。</p><p id="a389" class="pw-post-body-paragraph kj kk iq km b kn ko kp kq kr ks kt ku lj kw kx ky lk la lb lc ll le lf lg lh ij bi translated">你可以直接传递一个对象作为第一个参数给<code class="fe na nb nc mq b">setState</code>，而不是一个函数。这将执行状态变化到新状态的浅层合并。</p><pre class="jv jw jx jy gt mp mq mr ms aw mt bi"><span id="94a4" class="mu ln iq mq b gy mv mw l mx my">this.setState({quantity: 2})</span></pre><h1 id="ad66" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">批处理状态更新</h1><p id="222f" class="pw-post-body-paragraph kj kk iq km b kn mk kp kq kr ml kt ku lj mm kx ky lk mn lb lc ll mo lf lg lh ij bi translated">如果进行了多次<code class="fe na nb nc mq b">setState()</code>调用，React可能会在考虑更新顺序的同时批量更新状态。目前(React 16及更早版本)，<strong class="km ir">默认情况下只有React事件处理程序内部的更新被批处理</strong>。事件结束时，更改总是一起刷新，您看不到中间状态。</p><p id="3cf6" class="pw-post-body-paragraph kj kk iq km b kn ko kp kq kr ks kt ku lj kw kx ky lk la lb lc ll le lf lg lh ij bi translated">无论您在React事件处理程序中调用多少个组件，它们都只会在事件结束时产生一次重新渲染。例如，如果子节点和父节点在处理click事件时都调用了<code class="fe na nb nc mq b">setState()</code>，那么子节点只会重新渲染一次。</p><p id="bd00" class="pw-post-body-paragraph kj kk iq km b kn ko kp kq kr ks kt ku lj kw kx ky lk la lb lc ll le lf lg lh ij bi translated">直到React 16，<strong class="km ir">在React事件处理程序</strong>之外默认没有批处理。因此，如果每个<code class="fe na nb nc mq b">setState()</code>位于任何事件处理程序之外，它们将被立即处理。例如:</p><pre class="jv jw jx jy gt mp mq mr ms aw mt bi"><span id="0c78" class="mu ln iq mq b gy mv mw l mx my">promise.then(() =&gt; {<br/>  // We're not in an event handler, so these are flushed separately.<br/>  this.setState({a: true}); // Re-renders with {a: true, b: false }<br/>  this.setState({b: true}); // Re-renders with {a: true, b: true }<br/>})</span></pre><p id="8263" class="pw-post-body-paragraph kj kk iq km b kn ko kp kq kr ks kt ku lj kw kx ky lk la lb lc ll le lf lg lh ij bi translated">然而，<code class="fe na nb nc mq b">ReactDOM</code>提供了一个api，可以用来强制批量更新。</p><pre class="jv jw jx jy gt mp mq mr ms aw mt bi"><span id="b2b1" class="mu ln iq mq b gy mv mw l mx my">promise.then(() =&gt; {<br/>  // Forces batching<br/>  ReactDOM.unstable_batchedUpdates(() =&gt; {<br/>    this.setState({a: true}); // Doesn't re-render yet<br/>    this.setState({b: true}); // Doesn't re-render yet<br/>  });<br/>  // When we exit unstable_batchedUpdates, re-renders once<br/>})</span></pre><p id="c70b" class="pw-post-body-paragraph kj kk iq km b kn ko kp kq kr ks kt ku lj kw kx ky lk la lb lc ll le lf lg lh ij bi translated">内部React事件处理程序都包装在<code class="fe na nb nc mq b">unstable_batchedUpdates</code>中，因此默认情况下它们是批处理的。在<code class="fe na nb nc mq b">unstable_batchedUpdates</code>中包装一个更新两次没有效果。当最外层的<code class="fe na nb nc mq b">unstable_batchedUpdates</code>调用退出时，更新被刷新。</p><blockquote class="kg kh ki"><p id="9b87" class="kj kk kl km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">该API是“不稳定的”,因为当批处理在React核心中已经默认启用时，它将被删除。</p></blockquote></div><div class="ab cl jn jo hu jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ij ik il im in"><h1 id="2135" class="lm ln iq bd lo lp nd lr ls lt ne lv lw lx nf lz ma mb ng md me mf nh mh mi mj bi translated">在React组件外部声明状态更改</h1><p id="f38d" class="pw-post-body-paragraph kj kk iq km b kn mk kp kq kr ml kt ku lj mm kx ky lk mn lb lc ll mo lf lg lh ij bi translated">这一部分的灵感来自下面丹·阿布拉莫夫的推文。</p><figure class="jv jw jx jy gt jz"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="3982" class="pw-post-body-paragraph kj kk iq km b kn ko kp kq kr ks kt ku lj kw kx ky lk la lb lc ll le lf lg lh ij bi translated">由于<code class="fe na nb nc mq b">setState</code>期望参数中有一个函数，该函数可以在React类之外的某个地方实现，然后作为<code class="fe na nb nc mq b">setState</code>的参数导入并在组件内部使用。如果需要额外的参数，高阶函数可以帮忙。</p><pre class="jv jw jx jy gt mp mq mr ms aw mt bi"><span id="7db2" class="mu ln iq mq b gy mv mw l mx my">const multiplyBy = multiplier =&gt; state =&gt; ({<br/>  value: state.value * multiplier<br/>})</span></pre><p id="8003" class="pw-post-body-paragraph kj kk iq km b kn ko kp kq kr ks kt ku lj kw kx ky lk la lb lc ll le lf lg lh ij bi translated">由于状态更新现在是普通的JavaScript，测试复杂的状态转换不会涉及React组件的浅层呈现。</p><figure class="jv jw jx jy gt jz"><div class="bz fp l di"><div class="ni nj l"/></div></figure></div><div class="ab cl jn jo hu jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ij ik il im in"><h1 id="8a80" class="lm ln iq bd lo lp nd lr ls lt ne lv lw lx nf lz ma mb ng md me mf nh mh mi mj bi translated">setState和生命周期方法</h1><p id="e1fc" class="pw-post-body-paragraph kj kk iq km b kn mk kp kq kr ml kt ku lj mm kx ky lk mn lb lc ll mo lf lg lh ij bi translated">在生命周期方法中调用<code class="fe na nb nc mq b">setState</code>需要一定程度的谨慎。有一些方法调用setState是没有意义的，也有一些方法应该有条件地调用。让我们具体情况具体分析。</p><h2 id="9b45" class="mu ln iq bd lo nk nl dn ls nm nn dp lw lj no np ma lk nq nr me ll ns nt mi nu bi translated">组件将安装</h2><p id="02b6" class="pw-post-body-paragraph kj kk iq km b kn mk kp kq kr ml kt ku lj mm kx ky lk mn lb lc ll mo lf lg lh ij bi translated"><code class="fe na nb nc mq b">setState</code>可以在这里调用。更新后的状态将在即时呈现中使用，只要它不是基于承诺解析计算的。建议使用<code class="fe na nb nc mq b">componentDidMount</code>对承诺解析等执行任何状态更新。不使用该方法的另一个原因是，在React的未来版本(17以后)中，该方法将被弃用。</p><div class="nv nw gp gr nx ny"><a href="https://github.com/reactjs/rfcs/blob/master/text/0006-static-lifecycle-methods.md" rel="noopener  ugc nofollow" target="_blank"><div class="nz ab fo"><div class="oa ab ob cl cj oc"><h2 class="bd ir gy z fp od fr fs oe fu fw ip bi translated">reactj/RFC</h2><div class="of l"><h3 class="bd b gy z fp od fr fs oe fu fw dk translated">RFC-对变更做出反应的RFC</h3></div><div class="og l"><p class="bd b dl z fp od fr fs oe fu fw dk translated">github.com</p></div></div><div class="oh l"><div class="oi l oj ok ol oh om ke ny"/></div></div></a></div><h2 id="debd" class="mu ln iq bd lo nk nl dn ls nm nn dp lw lj no np ma lk nq nr me ll ns nt mi nu bi translated">组件安装</h2><p id="7599" class="pw-post-body-paragraph kj kk iq km b kn mk kp kq kr ml kt ku lj mm kx ky lk mn lb lc ll mo lf lg lh ij bi translated">这是异步渲染的首选方法。</p><h2 id="3eef" class="mu ln iq bd lo nk nl dn ls nm nn dp lw lj no np ma lk nq nr me ll ns nt mi nu bi translated">componentWillReceiveProps</h2><p id="dfff" class="pw-post-body-paragraph kj kk iq km b kn mk kp kq kr ml kt ku lj mm kx ky lk mn lb lc ll mo lf lg lh ij bi translated">此方法的主要目的是计算一些从props派生的值，以便在渲染过程中使用。虽然，如果计算足够快，它可以在<code class="fe na nb nc mq b">render</code>完成。在这里使用绝对安全。</p><h2 id="8b66" class="mu ln iq bd lo nk nl dn ls nm nn dp lw lj no np ma lk nq nr me ll ns nt mi nu bi translated">shouldComponentUpdate</h2><p id="ad86" class="pw-post-body-paragraph kj kk iq km b kn mk kp kq kr ml kt ku lj mm kx ky lk mn lb lc ll mo lf lg lh ij bi translated">这是更新组件状态没有意义的方法之一。它在更新阶段(props或状态更改)由React在内部调用。在这里调用<code class="fe na nb nc mq b">setState</code>会导致无限循环，因为这是它在更新状态时调用的下一个方法。如果需要在道具更新阶段设置状态，使用<code class="fe na nb nc mq b">componentWillReceiveProps</code>。</p><h2 id="8ae5" class="mu ln iq bd lo nk nl dn ls nm nn dp lw lj no np ma lk nq nr me ll ns nt mi nu bi translated">组件将更新</h2><p id="e059" class="pw-post-body-paragraph kj kk iq km b kn mk kp kq kr ml kt ku lj mm kx ky lk mn lb lc ll mo lf lg lh ij bi translated">这里不要用<code class="fe na nb nc mq b">setState</code>。和<code class="fe na nb nc mq b">shouldComponentUpdate</code>类似的原因。</p><h2 id="311b" class="mu ln iq bd lo nk nl dn ls nm nn dp lw lj no np ma lk nq nr me ll ns nt mi nu bi translated">提供；给予</h2><p id="1807" class="pw-post-body-paragraph kj kk iq km b kn mk kp kq kr ml kt ku lj mm kx ky lk mn lb lc ll mo lf lg lh ij bi translated">在这里调用<code class="fe na nb nc mq b">setState</code>会使您的组件成为产生无限循环的竞争者。<code class="fe na nb nc mq b">render</code>应保持纯净，并用于根据状态或道具有条件地在JSX片段/子组件之间切换。render中的回调可用于更新状态，然后根据更改重新呈现。</p><blockquote class="kg kh ki"><p id="e2a6" class="kj kk kl km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">如果你发现自己不得不在<code class="fe na nb nc mq b">render</code>中写<code class="fe na nb nc mq b">setState</code>，你可能需要重新考虑设计。事实上，这可能是实现状态机模式的完美用例。</p></blockquote><div class="nv nw gp gr nx ny"><a href="https://medium.freecodecamp.org/boost-your-react-with-state-machines-1e9641b0aa43" rel="noopener  ugc nofollow" target="_blank"><div class="nz ab fo"><div class="oa ab ob cl cj oc"><h2 class="bd ir gy z fp od fr fs oe fu fw ip bi translated">使用状态机增强您的反应</h2><div class="of l"><h3 class="bd b gy z fp od fr fs oe fu fw dk translated">混合React和状态机对于开发人员来说是极大的生产力提升。它还提高了通常…</h3></div><div class="og l"><p class="bd b dl z fp od fr fs oe fu fw dk translated">medium.freecodecamp.org</p></div></div><div class="oh l"><div class="on l oj ok ol oh om ke ny"/></div></div></a></div><h2 id="3400" class="mu ln iq bd lo nk nl dn ls nm nn dp lw lj no np ma lk nq nr me ll ns nt mi nu bi translated">componentDidUpdate</h2><p id="8fd4" class="pw-post-body-paragraph kj kk iq km b kn mk kp kq kr ml kt ku lj mm kx ky lk mn lb lc ll mo lf lg lh ij bi translated">这里调用<code class="fe na nb nc mq b">setState</code>最常见的用例是更新DOM以响应属性或状态的变化。这里，在再次更新状态之前，您等待组件被呈现。这使得它成为设置依赖于呈现的DOM值的状态值的候选对象。请记住检查您是否再次更新了相同的状态，因为在调用<code class="fe na nb nc mq b">setState()</code>之后会再次调用该方法。例如:</p><pre class="jv jw jx jy gt mp mq mr ms aw mt bi"><span id="d1dc" class="mu ln iq mq b gy mv mw l mx my">componentDidUpdate = (prevProps, prevState) =&gt; {<br/>  let width = ReactDOM.findDOMNode(this).parentNode.offsetWidth<br/>  if (prevState &amp;&amp; prevState.width !== width) {<br/>    this.setState({ width })<br/>  }<br/>}</span></pre><h2 id="27f5" class="mu ln iq bd lo nk nl dn ls nm nn dp lw lj no np ma lk nq nr me ll ns nt mi nu bi translated">组件将卸载</h2><p id="4ec2" class="pw-post-body-paragraph kj kk iq km b kn mk kp kq kr ml kt ku lj mm kx ky lk mn lb lc ll mo lf lg lh ij bi translated">这里不要用<code class="fe na nb nc mq b">setState</code>。你的组件正在消失。</p></div><div class="ab cl jn jo hu jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ij ik il im in"><p id="6c09" class="pw-post-body-paragraph kj kk iq km b kn ko kp kq kr ks kt ku lj kw kx ky lk la lb lc ll le lf lg lh ij bi translated">参考</p><ul class=""><li id="f2ab" class="oo op iq km b kn ko kr ks lj oq lk or ll os lh ot ou ov ow bi translated"><a class="ae li" href="https://reactjs.org/docs/react-component.html#setstate" rel="noopener ugc nofollow" target="_blank">https://reactjs.org/docs/react-component.html#setstate</a></li><li id="42f8" class="oo op iq km b kn ox kr oy lj oz lk pa ll pb lh ot ou ov ow bi translated"><a class="ae li" href="https://stackoverflow.com/questions/48563650/does-react-keep-the-order-for-state-updates/48610973#48610973" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/48563650/does-react-keep-the-order-for-state-updates/48610973 # 48610973</a></li></ul><p id="b2d2" class="pw-post-body-paragraph kj kk iq km b kn ko kp kq kr ks kt ku lj kw kx ky lk la lb lc ll le lf lg lh ij bi translated"><strong class="km ir"> <em class="kl">附:如果这篇文章对你有帮助，一定要鼓掌👏，关注我的</em> </strong> <a class="ae li" href="https://twitter.com/nitishk88" rel="noopener ugc nofollow" target="_blank"> <strong class="km ir"> <em class="kl">推特</em> </strong> </a> <strong class="km ir"> <em class="kl">，并分享给你的朋友！</em> </strong></p></div></div>    
</body>
</html>