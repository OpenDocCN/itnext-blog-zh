<html>
<head>
<title>GitHub Actions for Android Developers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向Android开发者的GitHub行动</h1>
<blockquote>原文：<a href="https://itnext.io/github-actions-for-android-developers-9ae606df2bfa?source=collection_archive---------0-----------------------#2021-08-07">https://itnext.io/github-actions-for-android-developers-9ae606df2bfa?source=collection_archive---------0-----------------------#2021-08-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/9bc4a24ea8f100393e506198d0e48fda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o2xoQgyHYMN4B2BafV_nHA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">面向Android开发者的GitHub行动</figcaption></figure><p id="7631" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">大家好，我是Amr Hesham，一名软件工程师，我对Android开发和编译器设计感兴趣，在这篇文章中，我将谈论GitHub Actions，以及作为一名Android开发人员，如何使用它为您的项目构建持续集成管道(CI ),但首先什么是持续集成？</p><p id="f663" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">持续集成<br/> 将来自多个参与者的代码变更自动集成到一个软件项目中的实践，可以在构建管道中验证代码的质量。从长远来看，使用左移方法及早检测安全漏洞和代码质量问题可以降低成本，因为在生产过程中检测到的漏洞修复起来成本很高。</p><p id="32ff" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">bug成本<br/> </strong>跳过测试可能会导致bug潜入产品，这会花费更多的钱或者引起客户不满，导致法律诉讼或者损害你的商业声誉。同样，手动测试会花费金钱并延迟交付。迫切需要测试自动化来避免额外的成本和软件交付问题。</p><figure class="lb lc ld le gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi la"><img src="../Images/51df4bd869db03d32358102b85a996c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VE6JsBaL-Nc4TG0PqPehEg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">数据来自IBM系统科学研究所修复缺陷研究门户的相对成本</figcaption></figure><p id="eb90" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir"> GitHub操作<br/> </strong> GitHub操作是GitHub存储库工作流中的一组操作，允许您定制和执行软件开发工作流，您可以创建操作或利用现有操作，并创建和定制工作流来执行任何工作或自动化软件开发生命周期(SDLC ),包括CI/CD。</p><p id="2f0e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">工作流</strong> <br/>在GitHub仓库中，流程设置在一个定义构建、测试、打包或部署作业的YAML文件中，称为工作流，它存储在GitHub/workflow文件夹中，一个工作流可能包含一个或多个作业，并根据触发器/事件进行调度运行。</p><p id="91f1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">作业<br/> </strong>作业是在运行程序的单个新实例上运行的一组步骤，可以顺序运行，也可以并行运行，这取决于需求。默认情况下，如果您的工作流包含多个作业，它将并行运行。您还可以创建一个依赖作业，如果依赖项失败，它将不会运行。对于每个作业，您应该指定运行程序操作系统和版本。</p><p id="8029" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir"> GitHub托管运行程序<br/> </strong>托管运行程序是机器，它们预装了常用软件，包含操作系统Linux、macOS或Windows和硬件配置，您不能自定义托管运行程序的硬件配置，但是如果您的应用程序有特定需求，您可以将您的机器或虚拟机设置为GitHub操作的运行程序，例如，要在ubuntu上运行，您可以编写:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="7210" class="lk ll iq lg b gy lm ln l lo lp">run-on:ubuntu-latest</span></pre><p id="fc0b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">你可以在<a class="ae lq" href="https://github.com/actions/virtual-environments/tree/main/images" rel="noopener ugc nofollow" target="_blank"><strong class="ke ir"/></a><strong class="ke ir">的虚拟环境中找到GitHub runners安装的软件和操作系统信息。</strong></p><p id="e5eb" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir"> Action <br/> </strong> Action是工作流的最小构建块，它可以被标识为一个单独的任务，这些步骤可以组合起来创建一个可以在工作流中执行的作业，您可以使用GitHub<a class="ae lq" href="https://github.com/marketplace?type=actions" rel="noopener ugc nofollow" target="_blank"><strong class="ke ir">market place</strong></a><strong class="ke ir"/>中的现有操作或者创建您的操作，每个操作都有一个名称和版本，例如:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="92c0" class="lk ll iq lg b gy lm ln l lo lp">-uses: actions/checkout@v1</span></pre><p id="d6ea" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">操作名称为“结帐”,提供者(用户或组织)为“操作”,版本为1，因此，如果您要查找操作URL以查找有关如何设置它的文档，它将是github.com/{provider}/{name}，例如github.com/actions/checkout.</p><p id="1b54" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">步骤<br/>步骤</strong>一个任务即一个动作或命令被标识为一个步骤，一个作业中的所有步骤运行在同一个运行器中，共享文件系统信息，命令可以是这样的。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="78f1" class="lk ll iq lg b gy lm ln l lo lp">- name: Say Hello<br/>  run: echo 'Hello, World!'</span></pre><p id="d8a2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">事件<br/></strong></p><p id="52c4" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">对于手动事件示例，您可以使用workflow_dispatch使您能够使用按钮来触发它</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="564b" class="lk ll iq lg b gy lm ln l lo lp">on: [workflow_dispatch]</span></pre><figure class="lb lc ld le gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lr"><img src="../Images/e7020d8c547a711fab87fe753df11fc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*14l8epE2BzZ4OSEGuJiJ-A.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">来自Github.com的手动工作流触发器图像</figcaption></figure><p id="4255" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">对于webhooks事件，您可以让您的工作流在所有分支或特定分支中的代码更改被推或拉请求时运行</p><p id="c864" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">对于所有分支机构。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="3b30" class="lk ll iq lg b gy lm ln l lo lp">on: [push, pull_request]</span></pre><p id="f3fb" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">仅适用于主支行。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="b9af" class="lk ll iq lg b gy lm ln l lo lp">push:<br/> branches: [ master ]<br/>pull_request:<br/> branches: [ master ]</span></pre><p id="5cd8" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">或者，您可以使用cron: syntax将预定事件作为触发器</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="63c4" class="lk ll iq lg b gy lm ln l lo lp">on:<br/> schedule:<br/> - cron: ’30 * * * *’</span></pre><p id="a8e4" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">Cron语法有五个由空格分隔的字段，每个字段代表一个时间单位。</p><figure class="lb lc ld le gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ls"><img src="../Images/d6e2c1ec9f77bf6fc816a0b5806c70b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L9H_v6Q0fG87FEMON25DAg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">Github.com的Cron语法</figcaption></figure><p id="56bb" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">你可以从这里找到GitHub Doc中所有事件以及如何配置的列表:<a class="ae lq" href="https://docs.github.com/en/actions/reference/events-that-trigger-workflows" rel="noopener ugc nofollow" target="_blank"> <strong class="ke ir">事件</strong> </a>。</p><p id="4f31" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在，在你知道什么是GitHub动作之后，让我们知道如何为Android项目构建我们的工作流来构建和测试它，为此我们有两个选项，第一个是从头开始一步一步地创建我们的工作流文件，另一个选项是使用市场中现有的动作。</p><p id="8a18" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在我们开始编写我们的第一个工作流之前，我们需要确保我们的gradlew文件是可执行的，这样工作流就可以使用它，要做到这一点，请在您的android项目中打开终端并编写</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="0010" class="lk ll iq lg b gy lm ln l lo lp">git update-index --chmod=+x gradlew</span></pre><p id="5533" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在，让我们从第一个选项开始，即从头开始创建工作流，因为这将有助于我们理解文件的结构，并在将来轻松创建我们的操作。</p><p id="b33d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">第一步是在中创建工作流文件。扩展名为yml或yaml的github/workflows文件夹，例如build.yml。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="2550" class="lk ll iq lg b gy lm ln l lo lp">name: Build</span><span id="1923" class="lk ll iq lg b gy lt ln l lo lp">on:<br/>  push:<br/>    branches: [ master ]<br/>  pull_request:<br/>    branches: [ master ]</span></pre><p id="939a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们的工作流名称是build，它将在主分支上进行代码推送或拉取请求时运行，然后让我们定义id为Build的作业，并在ubuntu-latest上运行。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="4503" class="lk ll iq lg b gy lm ln l lo lp">jobs:<br/>  build:<br/>    runs-on: ubuntu-latest</span></pre><p id="f68c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在让我们定义我们的工作步骤，我们的第一步是在$GITHUB_WORKSPACE下签出我们的存储库，以便工作流可以访问它。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="e2cf" class="lk ll iq lg b gy lm ln l lo lp">- uses: actions/checkout@v1</span></pre><p id="29a0" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">然后我们需要将java版本定义为1.8。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="8803" class="lk ll iq lg b gy lm ln l lo lp">- name: Set up JDK 1.8<br/>  uses: actions/setup-java@v1<br/>    with:<br/>      java-version: 1.8</span></pre><p id="2a83" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在我们的环境已经准备好了，我们将开始编写命令步骤来使用Gradle，运行所有你能做的单元测试。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="c554" class="lk ll iq lg b gy lm ln l lo lp">- name: Run Tests<br/>  run: ./gradlew test</span></pre><p id="534f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">为了构建这个项目你可以写。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="1bb2" class="lk ll iq lg b gy lm ln l lo lp">- name: Build Project<br/>  run: ./gradlew assemble</span></pre><p id="e287" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在，我们的工作流将正确工作，它验证您的项目正在成功构建，并且所有测试都已通过，但请记住，您的时间和资源有限，如果我们每次下载一些依赖项，我们都会浪费它们，请记住，在您的本地计算机上下载一次，每次运行作业时，作业都会在新的实例上运行，因此要解决这个问题，我们需要缓存它们，这很容易，因为有了缓存操作，所以在您使用签出操作后，您可以像这样运行我们的缓存操作。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="f617" class="lk ll iq lg b gy lm ln l lo lp">- uses: actions/cache@v2<br/>  with:<br/>    path: |<br/>      ~/.gradle/caches<br/>      ~/.gradle/wrapper<br/>    key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}<br/>    restore-keys: |<br/>      ${{ runner.os }}-gradle-</span></pre><p id="87ff" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">完整的工作流程将是这样的。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="1392" class="lk ll iq lg b gy lm ln l lo lp">name: Build</span><span id="ada8" class="lk ll iq lg b gy lt ln l lo lp">on:<br/>  push:<br/>    branches: [ master ]<br/>  pull_request:<br/>    branches: [ master ]</span><span id="b83e" class="lk ll iq lg b gy lt ln l lo lp">jobs:<br/>  build:<br/>    runs-on: ubuntu-latest</span><span id="8f19" class="lk ll iq lg b gy lt ln l lo lp">    steps:<br/>      - uses: actions/checkout@v1</span><span id="92a4" class="lk ll iq lg b gy lt ln l lo lp">      - uses: actions/cache@v2<br/>          with:<br/>            path: |<br/>              ~/.gradle/caches<br/>              ~/.gradle/wrapper<br/>            key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}<br/>            restore-keys: |<br/>            ${{ runner.os }}-gradle-</span><span id="0d83" class="lk ll iq lg b gy lt ln l lo lp">      - name: Set Up JDK<br/>        uses: actions/setup-java@v1<br/>        with:<br/>          java-version: 1.8</span><span id="3f64" class="lk ll iq lg b gy lt ln l lo lp">      - name: Run Tests<br/>        run: ./gradlew test</span><span id="9569" class="lk ll iq lg b gy lt ln l lo lp">      - name: Build Project<br/>        run: ./gradlew assemble</span></pre><p id="0c48" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果一切正常，您将在action选项卡中看到这一点。</p><figure class="lb lc ld le gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lu"><img src="../Images/aea1385aab871f7784266bc6e189a478.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X9RxEOyXcSiZaprIWVGuiA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">GitHub操作成功</figcaption></figure><p id="7c1c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">您可能面临的一个额外问题是，您的local.properties文件中有变量，而该文件被忽略，因此构建工作流会因为这些变量而失败，所以我们需要在构建之前添加它。</p><p id="739d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">首先，我们需要将其定义为一个秘密值，您有两种类型的秘密，存储库级别将仅在当前存储库中使用，组织级别将用于该组织中的所有存储库。</p><p id="c4af" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">机密名称区分大小写，不能以数字开头，只能用下划线分隔，也不能使用GITHUB_，并且在存储库和组织级别必须是唯一的。</p><p id="4e93" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">让我们定义我们的回购级别机密，您可以从存储库中的设置选项卡定义机密，然后单击创建新的存储库机密。</p><figure class="lb lc ld le gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lv"><img src="../Images/ccffb8bf7760a25663e706912398d462.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UILHr51useQh1_zRqe8hLw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">创建新的存储库密码</figcaption></figure><p id="a5c7" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">然后写秘密名和值。</p><figure class="lb lc ld le gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lw"><img src="../Images/2bbbfc5622b86bf6fe705675cabc122c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1Sg6oYDIO-ncA5UGccPUCA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">创建带有名称和值的秘密</figcaption></figure><p id="ee64" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在我们创建了我们的秘密之后，我们应该把它添加到local.properties文件中，但是首先让我们使用命令步骤创建一个。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="ff6d" class="lk ll iq lg b gy lm ln l lo lp">- name: Create Local Properties File<br/>  run: touch local.properties</span></pre><p id="5129" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">然后我们需要用一个变量名把我们的秘密值加进去。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="67f2" class="lk ll iq lg b gy lm ln l lo lp">- name: Add secret API Key<br/>  run: echo "apiKey=\""${{ secrets.secret_name }}"\"" &gt;&gt; local.properties</span></pre><p id="8963" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">例如，如果我们的密钥是10，变量名是apiKey，文件中的最终结果将是。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="c451" class="lk ll iq lg b gy lm ln l lo lp">apkKey="10"</span></pre><p id="2ea0" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在我们已经将它们添加到了属性文件中，但是请记住，这应该是在构建或测试命令之前。</p><p id="b7bb" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">GitHub Actions上有许多功能，你可以用它做许多事情，我推荐你阅读《GitHub Actions  实践》一书，这样你就可以知道如何创建一个好的CI/CD管道，以及如何创建你的自定义操作和Runner。</p><p id="5135" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">你可以在:<a class="ae lq" href="https://github.com/amrdeveloper" rel="noopener ugc nofollow" target="_blank"><strong class="ke ir">GitHub</strong></a><a class="ae lq" href="https://www.linkedin.com/in/amrdeveloper/" rel="noopener ugc nofollow" target="_blank"><strong class="ke ir">LinkedIn</strong></a><a class="ae lq" href="https://twitter.com/amrdeveloper" rel="noopener ugc nofollow" target="_blank"><strong class="ke ir">Twitter</strong></a>上找到我。</p><p id="5abf" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">享受编程😋。</p></div></div>    
</body>
</html>