<html>
<head>
<title>Creating an Independent Search Component Using Akita &amp; Angular</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Akita &amp; Angular创建独立的搜索组件</h1>
<blockquote>原文：<a href="https://itnext.io/creating-an-independent-search-component-using-akita-angular-ea6b67da90d7?source=collection_archive---------6-----------------------#2019-02-08">https://itnext.io/creating-an-independent-search-component-using-akita-angular-ea6b67da90d7?source=collection_archive---------6-----------------------#2019-02-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="5f94" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最近，我开始使用<a class="ae kl" href="https://netbasal.com/introducing-akita-a-new-state-management-pattern-for-angular-applications-f2f0fab5a8" rel="noopener ugc nofollow" target="_blank"> Akita </a>作为我的新应用程序的状态存储。<br/>它附带了一系列很好的概念，用于在web应用程序中清理商店的使用。</p><ul class=""><li id="c1ed" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk kr ks kt ku bi translated">你有一个存储在所谓的“实体店”中的模型。</li><li id="f8c7" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">您可以使用实体API服务来填充“实体存储”。</li><li id="1e19" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">然后，您可以使用一个查询服务在“实体存储”中查询值，该服务附带了一组现成的查询/选择器。</li></ul><p id="3d16" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们看看如何使用这个存储来创建一个独立的搜索组件，您可以稍后将它嵌入到您的应用程序中的任何地方，而不必为它的工作注入必要的初始/功能数据。</p><p id="2384" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是<a class="ae kl" href="https://stackblitz.com/edit/angular-m2hwu4" rel="noopener ugc nofollow" target="_blank">最后的结果</a>。</p><h1 id="39f1" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">搜索组件</h1><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi ly"><img src="../Images/b706e8b0a0f048a196898f90ffda7c36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Hdoxu5INlucr-wMpbCxv3A.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">搜索组件的详细说明</figcaption></figure><p id="bb0f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将创建一个搜索组件，它获取自己的必要数据(在我们的例子中是类别)，也可以从外部预设(<code class="fe mo mp mq mr b">selectedCategoryId</code>和<code class="fe mo mp mq mr b">searchTerm</code>)。</p><p id="672e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">注意</strong>我们只接收来自外部的<code class="fe mo mp mq mr b">id</code>，这意味着包装器组件不需要获取任何类别来传递所选的类别——例如，如果我们从URL查询参数中读取所选的类别，这一点尤其重要。</p><p id="6324" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，让我们从创建类别模型并存储相关文件开始:</p><figure class="lz ma mb mc gt md"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="3518" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">太好了。</p><p id="acb6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">花点时间通读，这样你就能理解每一个文件。<br/>可能会有相当多的人创建类别商店，但这就是<a class="ae kl" href="https://en.wikipedia.org/wiki/Separation_of_concerns" rel="noopener ugc nofollow" target="_blank">关注点分离</a>的妙处。</p></div><div class="ab cl mu mv hu mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="ij ik il im in"><p id="0598" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们构建搜索组件(我使用<a class="ae kl" href="https://material.angular.io/" rel="noopener ugc nofollow" target="_blank"> Angular Material </a>来促进开发和减少代码):</p><figure class="lz ma mb mc gt md"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="a4c6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里没什么特别的，但是让我们回顾一下2个与秋田相关的事情:</p><ol class=""><li id="9ae5" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk nb ks kt ku bi translated"><code class="fe mo mp mq mr b">fetchCategories</code> —该方法负责获取搜索组件所需的数据，以便在选择框中显示类别。我们使用<code class="fe mo mp mq mr b">categoryStoreService</code>，它将依次调用<code class="fe mo mp mq mr b">categoryApiService</code>来获取类别，然后将它们设置在商店中。</li><li id="4a2d" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk nb ks kt ku bi translated">重要的是要记住，因为我们使用商店来管理我们的状态，并且我们的应用程序中可用的类别是一个状态，所以我们不分配从<code class="fe mo mp mq mr b">categoryStoreService</code>(它传递来自<code class="fe mo mp mq mr b">categoryApiService</code>的值)返回的类别，而是使用Akita的<code class="fe mo mp mq mr b">query</code>概念来选择我们插入到商店中的类别。<br/>我们通过使用<code class="fe mo mp mq mr b">this.categories$ = this.categoryQuery.selectAll();</code>来做到这一点</li></ol><p id="3f0a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们应该有一个搜索组件来处理它的依赖数据，但是也可以从外部设置。它是独立的，所以我们可以拿着它，在任何需要的地方使用它。</p><p id="f723" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">看一看<a class="ae kl" href="https://stackblitz.com/edit/angular-m2hwu4" rel="noopener ugc nofollow" target="_blank">功能演示</a>。</p><h2 id="e731" class="nc lb iq bd lc nd ne dn lg nf ng dp lk jy nh ni lo kc nj nk ls kg nl nm lw nn bi translated">陷阱</h2><p id="ffe7" class="pw-post-body-paragraph jn jo iq jp b jq no js jt ju np jw jx jy nq ka kb kc nr ke kf kg ns ki kj kk ij bi translated">我有一个谜语给你:</p><p id="5003" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">假设我们从一个URL查询参数中读取选定的类别。当页面刚刚加载时，我们将它传递给搜索组件。</p><p id="fc3e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">搜索组件中的类别选择器会被设置为具有相应ID的类别吗？</p><p id="6fcd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">是/否——试着解释你的答案。</p></div><div class="ab cl mu mv hu mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="ij ik il im in"><h2 id="543c" class="nc lb iq bd lc nd ne dn lg nf ng dp lk jy nh ni lo kc nj nk ls kg nl nm lw nn bi translated">回答</h2><p id="7bb4" class="pw-post-body-paragraph jn jo iq jp b jq no js jt ju np jw jx jy nq ka kb kc nr ke kf kg ns ki kj kk ij bi translated">答案是否定的，行不通。原因如下:</p><p id="f085" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当页面加载时，我们读取类别id并将其传递给搜索组件——搜索组件正在获取类别。</p><p id="915b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">与此同时，它意识到您传递了一个类别<code class="fe mo mp mq mr b">id</code>来设置类别选择器，并试图将您传递的id与组件中可用类别的id进行匹配。</p><p id="3225" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是，唉——我们仍然在获取数据，所以我们没有任何类别可以匹配！</p><p id="9e48" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，结果是选择器不会显示任何被选中的类别。</p><h2 id="2b86" class="nc lb iq bd lc nd ne dn lg nf ng dp lk jy nh ni lo kc nj nk ls kg nl nm lw nn bi translated">固定</h2><p id="c862" class="pw-post-body-paragraph jn jo iq jp b jq no js jt ju np jw jx jy nq ka kb kc nr ke kf kg ns ki kj kk ij bi translated">有一个简单的方法可以解决这个问题(尽管我不确定这是否是一个最佳实践，介意分享一下你的想法吗？):</p><p id="c88b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们转换<code class="fe mo mp mq mr b">getEntity</code>查询，它是与<code class="fe mo mp mq mr b">selectEntity</code>同步的操作，它基本上做同样的事情——只是有一个可观察的。<br/>因此，您可以使用传递给搜索组件的类别id来锁定订阅:</p><pre class="lz ma mb mc gt nv mr nw nx aw ny bi"><span id="b17b" class="nc lb iq mr b gy nz oa l ob oc">this.categoryQuery.selectEntity(changes.selectedCategoryId.currentValue).subscribe((category) =&gt; { this.selectedCategory = category });</span></pre><p id="a9cd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在这应该可以工作了(当然，您需要处理退订。也许使用<code class="fe mo mp mq mr b"><a class="ae kl" href="http://reactivex.io/documentation/operators/take.html" rel="noopener ugc nofollow" target="_blank">take</a>(1)</code>,因为您只想为类别等待一次)</p></div><div class="ab cl mu mv hu mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="ij ik il im in"><p id="0c10" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">干杯。🍻</p></div></div>    
</body>
</html>