<html>
<head>
<title>Simple React form validation with Formik, Yup and/or Spected</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Formik、Yep和/或Spected进行简单的反应表单验证</h1>
<blockquote>原文：<a href="https://itnext.io/simple-react-form-validation-with-formik-yup-and-or-spected-206ebe9e7dcc?source=collection_archive---------0-----------------------#2018-05-21">https://itnext.io/simple-react-form-validation-with-formik-yup-and-or-spected-206ebe9e7dcc?source=collection_archive---------0-----------------------#2018-05-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="86da" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最近，我在工作中写了一些需要验证的表格。因为我喜欢和图书馆打交道，尤其是那些帮助过我的图书馆，我想把你介绍给他们。</p><p id="407e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们构建一个简单的注册表单进行演示。此类表格通常包含用户的电子邮件、密码、密码确认以及条款和条件协议。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/32b3194c63de283217e64ac8e2d2da70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bo-IdqI6KHvxy3OYDZnoWg.jpeg"/></div></div></figure><h1 id="2d5b" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">福米克</h1><p id="64e3" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">首先，我们用<a class="ae ma" href="https://github.com/jaredpalmer/formik" rel="noopener ugc nofollow" target="_blank"> Formik </a>库创建注册表单。我喜欢Formik，因为它是轻量级的，几乎没有抽象库来帮助你在React中创建表单。如果你不需要Redux ( <a class="ae ma" href="https://medium.com/@dan_abramov/you-might-not-need-redux-be46360cf367" rel="noopener">你可能不需要Redux — Dan Abramov — Medium </a>，<a class="ae ma" href="https://goshakkk.name/should-i-put-form-state-into-redux/" rel="noopener ugc nofollow" target="_blank">你应该把你的表单状态存储在Redux中吗？— Gosha Arinich </a>)是非常不错的选择。在我们的例子中，Formik帮助我们保持状态(值、错误和表单是否被提交)并处理变更。它还在每次提交时为我们调用验证功能。我使用Formik作为React组件和<a class="ae ma" href="https://reactjs.org/docs/render-props.html" rel="noopener ugc nofollow" target="_blank">渲染道具</a>，但是你也可以用它作为HoC。</p><pre class="km kn ko kp gt mb mc md me aw mf bi"><span id="0d9d" class="mg ky iq mc b gy mh mi l mj mk">export default function SignUpFormContainer() {<br/>  return (<br/>    &lt;Formik<br/>      initialValues={initialValues}<br/>      validate={validate}<br/>      onSubmit={onSubmit}<br/>      render={SignUpForm}<br/>    /&gt;<br/>  )<br/>}</span><span id="2c56" class="mg ky iq mc b gy ml mi l mj mk">function SignUpForm(props) {<br/>  const {<br/>    isSubmitting,<br/>    errors,<br/>    handleChange,<br/>    handleSubmit,<br/>  } = props</span><span id="ef8f" class="mg ky iq mc b gy ml mi l mj mk">return (<br/>    &lt;div className="form"&gt;<br/>      &lt;label className="form-field" htmlFor="email"&gt;<br/>        &lt;span&gt;E-mail:&lt;/span&gt;<br/>        &lt;input<br/>          name="email"<br/>          type="email"<br/>          onChange={handleChange}<br/>        /&gt;<br/>      &lt;/label&gt;<br/>      &lt;div className="form-field-error"&gt;{errors.email}&lt;/div&gt;</span><span id="ac91" class="mg ky iq mc b gy ml mi l mj mk">      &lt;label className="form-field" htmlFor="password"&gt;<br/>        &lt;span&gt;Password:&lt;/span&gt;<br/>        &lt;input<br/>          name="password"<br/>          type="password"<br/>          onChange={handleChange}<br/>        /&gt;<br/>      &lt;/label&gt;<br/>      &lt;div className="form-field-error"&gt;{errors.password}&lt;/div&gt;</span><span id="fe39" class="mg ky iq mc b gy ml mi l mj mk">      &lt;label<br/>        className="form-field"<br/>        htmlFor="passwordConfirmation"<br/>      &gt;<br/>        &lt;span&gt;Confirm password:&lt;/span&gt;<br/>        &lt;input<br/>          name="passwordConfirmation"<br/>          type="password"<br/>          onChange={handleChange}<br/>        /&gt;<br/>      &lt;/label&gt;<br/>      &lt;div className="form-field-error"&gt;<br/>        {errors.passwordConfirmation}<br/>      &lt;/div&gt;</span><span id="c787" class="mg ky iq mc b gy ml mi l mj mk">      &lt;label className="form-field" htmlFor="consent"&gt;<br/>        &lt;span&gt;Consent:&lt;/span&gt;<br/>        &lt;input<br/>          name="consent"<br/>          type="checkbox"<br/>          onChange={handleChange}<br/>        /&gt;<br/>      &lt;/label&gt;<br/>      &lt;div className="form-field-error"&gt;{errors.consent}&lt;/div&gt;</span><span id="688c" class="mg ky iq mc b gy ml mi l mj mk">      &lt;button onClick={handleSubmit}&gt;<br/>        {isSubmitting ? 'Loading' : 'Sign Up'}<br/>      &lt;/button&gt;<br/>    &lt;/div&gt;<br/>  )<br/>}</span></pre><h1 id="03cc" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">确认</h1><p id="1092" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">我们如何验证这一点？我们可能会找到更多的方法来验证这种形式。我写下了一些我们将用来验证表单验证方法的需求(是的，这就像电影《盗梦空间》的重演。)</p><h2 id="ecd3" class="mg ky iq bd kz mm mn dn ld mo mp dp lh jy mq mr ll kc ms mt lp kg mu mv lt mw bi translated">要求</h2><ul class=""><li id="6c36" class="mx my iq jp b jq lv ju lw jy mz kc na kg nb kk nc nd ne nf bi translated">我不想创建特殊的表单字段组件，并像<code class="fe ng nh ni mc b">&lt;FormField validate={value =&gt; someValidation(value)} /&gt;</code>一样单独为表单的每个字段添加验证。我认为验证应该是业务逻辑的一部分，而不是UI的一部分，如果没有必要，我不想混淆它。否则，我想有一个整个表单的验证函数，它接受表单值的对象，并返回每个值的错误消息对象。这种验证方法甚至可以用于任何其他JS对象，而不仅仅是表单验证。</li><li id="547f" class="mx my iq jp b jq nj ju nk jy nl kc nm kg nn kk nc nd ne nf bi translated">没有<code class="fe ng nh ni mc b">if</code>语句。</li><li id="acd2" class="mx my iq jp b jq nj ju nk jy nl kc nm kg nn kk nc nd ne nf bi translated">有可能用例外来代替<code class="fe ng nh ni mc b">if</code>的。我也不喜欢那样。异常是针对意外行为的，但是表单域是否被填充并不意外。相反，这是意料之中的。正如我已经提到的，验证是我们业务规则的一部分。</li><li id="4222" class="mx my iq jp b jq nj ju nk jy nl kc nm kg nn kk nc nd ne nf bi translated">每个字段一个或多个规则。我想根据一个或多个规则来验证每个属性。</li><li id="413c" class="mx my iq jp b jq nj ju nk jy nl kc nm kg nn kk nc nd ne nf bi translated">我也希望能够返回给定字段更多的错误。</li><li id="bcc6" class="mx my iq jp b jq nj ju nk jy nl kc nm kg nn kk nc nd ne nf bi translated">返回错误消息，每个规则都不同。</li><li id="d45a" class="mx my iq jp b jq nj ju nk jy nl kc nm kg nn kk nc nd ne nf bi translated">属性之间的交叉验证，这意味着根据其他字段值验证字段。</li></ul><p id="c366" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我提到“不”,因为从这样的事情开始会很有诱惑力:</p><pre class="km kn ko kp gt mb mc md me aw mf bi"><span id="b107" class="mg ky iq mc b gy mh mi l mj mk">if (!values.email) {<br/>  errors.email = 'E-mail is required!'<br/>}</span><span id="67ab" class="mg ky iq mc b gy ml mi l mj mk">if (!values.password) {<br/>  errors.password = 'Password is required!'<br/>} else if (values.password.length &lt; 6) {<br/>  errors.password = 'Password has to be longer than 6 characters'<br/>}</span></pre><p id="80db" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果有更多的字段或更复杂的规则，可能会很难理解，所以我在想:“我们能做得更好吗？一定有其他更明确的方式，没有<code class="fe ng nh ni mc b">if</code> s。</p><h2 id="1eda" class="mg ky iq bd kz mm mn dn ld mo mp dp lh jy mq mr ll kc ms mt lp kg mu mv lt mw bi translated">是的</h2><p id="40e6" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">幸运的是，Formik本身默认允许使用<a class="ae ma" href="https://github.com/jquense/yup" rel="noopener ugc nofollow" target="_blank"> Yup </a>验证库。用最简单的方法，你可以只写<code class="fe ng nh ni mc b">validationSchema</code>并把它作为道具传递给<code class="fe ng nh ni mc b">&lt;Formik /&gt;</code>组件。</p><pre class="km kn ko kp gt mb mc md me aw mf bi"><span id="408f" class="mg ky iq mc b gy mh mi l mj mk">const validationSchema = Yup.object().shape({<br/>  email: Yup.string()<br/>    .email('E-mail is not valid!')<br/>    .required('E-mail is required!'),<br/>  password: Yup.string()<br/>    .min(6, 'Password has to be longer than 6 characters!')  <br/>    .required('Password is required!')<br/>})</span><span id="0eb1" class="mg ky iq mc b gy ml mi l mj mk">&lt;Formik <br/>  ...<br/>  validationSchema={validationSchema} <br/>  ...<br/>/&gt;</span></pre><p id="97b5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这看起来比<code class="fe ng nh ni mc b">if</code>的好得多，但是它只在你需要一些交叉验证时才有效。在我们的例子中，密码和密码确认就是这种情况。</p><p id="0aaa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这种情况下，您仍然可以使用Yup，但是要和您自己的验证函数一起使用。我们创建<code class="fe ng nh ni mc b">getValidationSchema</code>函数。它接受<code class="fe ng nh ni mc b">values</code>对象并返回验证模式，类似于上面的例子。</p><pre class="km kn ko kp gt mb mc md me aw mf bi"><span id="21d0" class="mg ky iq mc b gy mh mi l mj mk">function getValidationSchema(values) {<br/>  return Yup.object().shape({<br/>    email: Yup.string()<br/>      .email('E-mail is not valid!')<br/>      .required('E-mail is required!'),<br/>    password: Yup.string()<br/>      .min(6, 'Password has to be longer than 6 characters!')<br/>      .required('Password is required!'),<br/>    passwordConfirmation: Yup.string()<br/>      .oneOf([values.password], 'Passwords are not the same!')<br/>      .required('Password confirmation is required!'),<br/>    consent: Yup.bool()<br/>      .test(<br/>        'consent',<br/>        'You have to agree with our Terms and Conditions!',<br/>        value =&gt; value === true<br/>      )<br/>      .required(<br/>        'You have to agree with our Terms and Conditions!'<br/>      ),<br/>  })<br/>}</span></pre><p id="32d9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这很简单。我只想在这里强调两点:</p><ol class=""><li id="db85" class="mx my iq jp b jq jr ju jv jy no kc np kg nq kk nr nd ne nf bi translated"><code class="fe ng nh ni mc b">passwordConfirmation</code>验证:据我所知，Yup没有任何类似于<code class="fe ng nh ni mc b">equals</code>的方法来比较两个字符串。我们需要将<code class="fe ng nh ni mc b">passwordConfirmation</code>值与数组值<code class="fe ng nh ni mc b">oneOf(array, 'Error message')</code>进行比较，其中<code class="fe ng nh ni mc b">array</code>是只有一个来自<code class="fe ng nh ni mc b">values</code>对象<code class="fe ng nh ni mc b">values.password</code>的值的数组。</li><li id="ba4a" class="mx my iq jp b jq nj ju nk jy nl kc nm kg nn kk nr nd ne nf bi translated"><code class="fe ng nh ni mc b">consent</code>验证:Yup也没有办法检查值是<code class="fe ng nh ni mc b">true</code>还是<code class="fe ng nh ni mc b">false</code>。我们需要使用带3个参数的<code class="fe ng nh ni mc b">test</code>方法。第一个是验证的名称(我不知道为什么🤔)，第二个是错误消息，第三个是我们的自定义验证函数，它将<code class="fe ng nh ni mc b">value</code>作为参数，必须返回<code class="fe ng nh ni mc b">true</code>或<code class="fe ng nh ni mc b">false</code>。我们我用的只是简单的<code class="fe ng nh ni mc b">value =&gt; value === true</code>。</li></ol><p id="09c7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们只是在这个模式上调用方法<code class="fe ng nh ni mc b">validateSync()</code>:</p><pre class="km kn ko kp gt mb mc md me aw mf bi"><span id="1dbe" class="mg ky iq mc b gy mh mi l mj mk">function validate(values) {<br/>  validate = (values) =&gt; {<br/>    const validationSchema = getValidationSchema(values)<br/>    try {<br/>      validationSchema.validateSync(values, { abortEarly: false })<br/>      return {}<br/>    } catch (error) {<br/>      return getErrorsFromValidationError(error)<br/>    }<br/>  }<br/>}</span></pre><p id="2e4f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有一点小问题，因为<code class="fe ng nh ni mc b">validateSync</code>方法不返回有错误的对象，而是抛出<code class="fe ng nh ni mc b">ValidationError</code>。如果它直接返回errors对象就更好了。总之，我写了另一个简单的函数，它接受这个错误对象，并以我们想要的形式返回错误对象(每个表单字段只有第一个验证错误消息):</p><pre class="km kn ko kp gt mb mc md me aw mf bi"><span id="b06e" class="mg ky iq mc b gy mh mi l mj mk">function getErrorsFromValidationError(validationError) {<br/>  const FIRST_ERROR = 0<br/>  return validationError.inner.reduce((errors, error) =&gt; {<br/>    return {<br/>      ...errors,<br/>      [error.path]: error.errors[FIRST_ERROR],<br/>    }<br/>  }, {})<br/>}</span></pre><p id="3e82" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如您所见，我们的验证现在看起来好多了。是的，我们必须再添加两个函数(是的，我们正在处理异常验证🙄)，但这些都是简单的函数，可以在任何验证模式中重用。如果我可以在<code class="fe ng nh ni mc b">if</code>和带有另外两个函数的声明式验证模式之间进行选择，我肯定会选择第二个选项。</p><p id="ca1a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">优点:</p><ul class=""><li id="0c85" class="mx my iq jp b jq jr ju jv jy no kc np kg nq kk nc nd ne nf bi translated">宣言的</li><li id="331f" class="mx my iq jp b jq nj ju nk jy nl kc nm kg nn kk nc nd ne nf bi translated">预定义的验证方法(<code class="fe ng nh ni mc b">email</code>、<code class="fe ng nh ni mc b">min</code>、<code class="fe ng nh ni mc b">max</code>、<code class="fe ng nh ni mc b">required</code>)</li></ul><p id="d082" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">缺点:</p><ul class=""><li id="d7bf" class="mx my iq jp b jq jr ju jv jy no kc np kg nq kk nc nd ne nf bi translated">你必须学习它的API</li><li id="1fb0" class="mx my iq jp b jq nj ju nk jy nl kc nm kg nn kk nc nd ne nf bi translated">由异常处理的验证</li></ul><h2 id="caae" class="mg ky iq bd kz mm mn dn ld mo mp dp lh jy mq mr ll kc ms mt lp kg mu mv lt mw bi translated">斯佩克特</h2><p id="cbb6" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">Formik的伟大之处在于，您可以使用任何您想要的验证库。你只需要使用<code class="fe ng nh ni mc b">validate</code>函数，而不是Yup特定的<code class="fe ng nh ni mc b">validationSchema</code>。我意识到使用<a class="ae ma" href="https://github.com/25th-floor/spected" rel="noopener ugc nofollow" target="_blank"> Spected </a>验证库来进行表单验证会很好，因为我们已经在工作项目的后端使用它来验证JS对象。</p><p id="a9e7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Spected验证也非常具有声明性。它甚至比“是”更实用。没有命令，没有异常处理，只有简单的声明性函数验证。</p><p id="07c9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们从<code class="fe ng nh ni mc b">getValidationSchema</code>功能开始:</p><pre class="km kn ko kp gt mb mc md me aw mf bi"><span id="4fe7" class="mg ky iq mc b gy mh mi l mj mk">function getSpectedValidationSchema(values) {<br/>  return {<br/>    email: [<br/>      [value =&gt; !isEmpty(value), 'E-mail is required!'],<br/>      [value =&gt; isEmail(value), 'E-mail is not valid!'],<br/>    ],<br/>    password: [<br/>      [value =&gt; !isEmpty(value), 'Password is required!'],<br/>      [<br/>        value =&gt; value.length &gt;= 6,<br/>        `Password has to be longer than 6 characters!`,<br/>      ],<br/>    ],<br/>    passwordConfirmation: [<br/>      [<br/>        value =&gt; !isEmpty(value),<br/>        'Password confirmation is required!',<br/>      ],<br/>      [<br/>        value =&gt; value === values.password,<br/>        'Passwords are not the same!',<br/>      ],<br/>    ],<br/>    consent: [<br/>      [<br/>        value =&gt; value === true,<br/>        'You have to agree with our Terms and Conditions!',<br/>      ],<br/>    ],<br/>  }<br/>}</span></pre><p id="3689" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如你所看到的，我们需要使用我们自己的<code class="fe ng nh ni mc b">isEmpty</code>和<code class="fe ng nh ni mc b">isEmail</code>函数，但是我也可能是有益的，因为我们可以定义和命名函数，以便更方便地用于我们的业务领域。</p><p id="ce94" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的验证函数看起来有点不同。现在，我们不处理异常，但是我们仍然必须处理验证结果以符合我们的要求(以表单字段作为键，以错误消息作为值的错误对象):</p><pre class="km kn ko kp gt mb mc md me aw mf bi"><span id="8f26" class="mg ky iq mc b gy mh mi l mj mk">function validate(getValidationSchema) {<br/>  return (values) =&gt; {<br/>    const spec = getValidationSchema(values)<br/>    const validationResult = spected(spec, values)<br/>    return getErrorsFromValidationResult(validationResult)<br/>  }<br/>}</span><span id="3187" class="mg ky iq mc b gy ml mi l mj mk">function getErrorsFromValidationResult(validationResult) {<br/>  const FIRST_ERROR = 0<br/>  return Object.keys(validationResult).reduce((errors, field) =&gt; {<br/>    return validationResult[field] !== true<br/>      ? { ...errors, [field]: validationResult[field][FIRST_ERROR] }<br/>      : errors<br/>  }, {})<br/>}</span></pre><p id="3f48" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Spected有一个问题——必需表单字段的定义。例如，如果<code class="fe ng nh ni mc b">values</code>对象不包含<code class="fe ng nh ni mc b">consent</code>，那么就不会调用<code class="fe ng nh ni mc b">consent</code>的验证函数。这是因为Spected不会迭代未定义的属性。</p><p id="1697" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这在我们的注册表单中不是问题，因为我们将所有值都定义为初始状态。在其他情况下，我们可以通过将所有必填字段定义为未定义并用验证对象中的值覆盖它们来解决这个问题:</p><pre class="km kn ko kp gt mb mc md me aw mf bi"><span id="4667" class="mg ky iq mc b gy mh mi l mj mk">const requiredFields = {<br/>  email: undefined,<br/>  password: undefined,<br/>  passwordConfirmation: undefined,<br/>  consent: undefined,<br/>}</span><span id="3a62" class="mg ky iq mc b gy ml mi l mj mk">const valuesWithRequiredFields = { ...requiredFields, ...values }</span></pre><p id="2005" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">优点:</p><ul class=""><li id="c117" class="mx my iq jp b jq jr ju jv jy no kc np kg nq kk nc nd ne nf bi translated">声明性的，但功能性更强的方法。</li><li id="fe62" class="mx my iq jp b jq nj ju nk jy nl kc nm kg nn kk nc nd ne nf bi translated">简单的轻量级API。</li><li id="6a17" class="mx my iq jp b jq nj ju nk jy nl kc nm kg nn kk nc nd ne nf bi translated">验证不是由异常处理的。</li></ul><p id="1fa3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">缺点:</p><ul class=""><li id="852f" class="mx my iq jp b jq jr ju jv jy no kc np kg nq kk nc nd ne nf bi translated">不检查验证对象中不包含的必填字段。</li><li id="d464" class="mx my iq jp b jq nj ju nk jy nl kc nm kg nn kk nc nd ne nf bi translated">没有预定义的验证函数。</li></ul><p id="9aaf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可以在这里找到完整的代码示例:<a class="ae ma" href="https://github.com/jakubkoci/react-form-validation" rel="noopener ugc nofollow" target="_blank">GitHub—jakubkoci/react-form-validation:用Formik和Yup </a>进行简单的React表单验证。</p></div></div>    
</body>
</html>