<html>
<head>
<title>Effective Algorithms for Dart and Flutter. Hash Set.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">飞镖和颤振的有效算法。哈希集。</h1>
<blockquote>原文：<a href="https://itnext.io/effective-algorithms-for-dart-and-flutter-hash-set-f71e6d2b5837?source=collection_archive---------0-----------------------#2021-07-20">https://itnext.io/effective-algorithms-for-dart-and-flutter-hash-set-f71e6d2b5837?source=collection_archive---------0-----------------------#2021-07-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/595653a1c22709bb55797ec4f3d50e8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PeGiOSrXg1LgmVkLkmk-xQ.png"/></div></div></figure><p id="66bd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<a class="ae kw" rel="noopener ugc nofollow" target="_blank" href="/effective-algorithms-for-dart-and-flutter-big-o-874627c433ba">Dart的有效算法，第1部分</a>中，我们开始讨论Dart和Flutter中的算法和数据结构。我们想到了<strong class="ka ir">算法至关重要</strong>的想法。即使在非常简单的情况下，选择合适的算法也是至关重要的。</p><p id="14bf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">今天我们将讨论选择合适的数据结构的重要性。今天课程的口号是<strong class="ka ir">数据结构很重要</strong>。</p><p id="b9b9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">像往常一样，在<a class="ae kw" href="https://flutlab.io/" rel="noopener ugc nofollow" target="_blank"> Online Flutter IDE </a>的帮助下，我们的旅程将会很实用。</p><p id="f7b1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以我们这里挑<a class="ae kw" href="https://widgetbay.flutlab.io/widget/algorithms-matter-2" rel="noopener ugc nofollow" target="_blank">初始颤振项目</a>。</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi kx"><img src="../Images/569c09f2da63ecc01286666fdf223804.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I2KHIrRsl2_E5Mg9_2XtFQ.png"/></div></div></figure><p id="5e87" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">单击“Fork to FlutLab IDE”。现在，您应该会在仪表板中看到一个名为“算法至关重要2”的新颤振项目:</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lc"><img src="../Images/99c01df70eafbe608250a6768e920375.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rWRG59IyZM6ChkKsV_AGOw.png"/></div></div></figure><p id="baed" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">打开此项目并运行Web build:</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ld"><img src="../Images/585419ad30e9c1ca082ff72848a89c00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F5TbuKqxIT1joh23eSVycA.png"/></div></div></figure><p id="d4f1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们为我们的旅程做好了准备！</p><p id="f236" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将尝试编写一个非常简单的应用程序。这个应用程序将在数组中搜索一些数字。让我们看看我们的Flutter应用程序的<strong class="ka ir">构建</strong>方法:</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div class="gh gi le"><img src="../Images/247da4af254875db41914ba12a793327.png" data-original-src="https://miro.medium.com/v2/resize:fit:986/format:webp/1*NM0SAjS-T8bHKfgGjonzcQ.png"/></div></figure><p id="d457" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它从<strong class="ka ir">算法</strong>类创建一个<strong class="ka ir">算法</strong>对象。<strong class="ka ir">算法</strong>的构造器有两个参数:</p><ul class=""><li id="aeae" class="lf lg iq ka b kb kc kf kg kj lh kn li kr lj kv lk ll lm ln bi translated">要搜索的数组</li><li id="04ba" class="lf lg iq ka b kb lo kf lp kj lq kn lr kr ls kv lk ll lm ln bi translated">要查找的值</li></ul><p id="504d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后我们的应用程序在应用程序屏幕中央的文本中呈现<strong class="ka ir"> algo.perform() </strong>的结果。老实说，它在搜索方面做得很糟糕——它说在数组[1，2，3，4]中没有找到数字4。</p><p id="0a72" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们看看位于main.dart附近的<strong class="ka ir"> algo.dart </strong>文件:</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lt"><img src="../Images/69b6a908aa1edb3845812e1cada16cbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7L3O-B4Qv4ENFnvVTMct-Q.png"/></div></div></figure><p id="349e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在一切都清楚了！Algo已经硬编码<strong class="ka ir">执行</strong>方法。它总是返回错误的。</p><p id="2fc3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们用最简单的方法来解决这个问题:</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lu"><img src="../Images/d9da6f58818c4424120e8e0eee8ee7e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k8Kehg1m-_vUH5XPmMaARg.png"/></div></div></figure><p id="bea8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这看起来是一个合适的解决方案。让我们用这个按钮来运行我们的单元测试:</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div class="gh gi lv"><img src="../Images/1d83379a50c9dfa7e2dc376024f6fdac.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/format:webp/1*HcLHtznOn8vOksgvHP8ekQ.png"/></div></figure><p id="29ea" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里我们可以看到一些问题:</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lw"><img src="../Images/4e54b225c53629d4780203098d38c07a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2p_JqTL86QSuS5dmJw0bCg.png"/></div></div></figure><p id="cf7b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面是失败的测试:</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lx"><img src="../Images/22c873729b422897a04a6ed97c871052.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WNzl7aRLjsCwP9myYslBZQ.png"/></div></div></figure><p id="a3f6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，我们期望查找函数的执行速度快于10毫秒，但它用了623毫秒。</p><p id="f718" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">问题的解决方法是改变我们查找的数据结构。</p><p id="f1a7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们改变我们的实现，在<strong class="ka ir">中使用<strong class="ka ir"> Set </strong>而不是<strong class="ka ir">List</strong>perform</strong>方法:</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ly"><img src="../Images/a8b4e9ebfde0a16245f2c99f6df7204e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uJHjofWAoWnf7owDyGpmIg.png"/></div></div></figure><p id="6b59" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们现在运行我们的单元测试——它们将会成功通过。</p><p id="6979" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们来分析一下<strong class="ka ir"> Set </strong>为什么查找这么快。但是首先，让我们使用<strong class="ka ir">列表</strong>集合来估计我们第一次实现查找的时间复杂度。平均来说，对于N个元素，我们需要花N/2步才能找到列表中的值。我们只是从第一个元素到最后一个元素，一步一步来。它是<strong class="ka ir"> O(n) </strong>算法，因为我们必须丢弃所有的常数(<a class="ae kw" rel="noopener ugc nofollow" target="_blank" href="/effective-algorithms-for-dart-and-flutter-big-o-874627c433ba">详见第1部分</a>)。</p><p id="5c85" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">什么是野兽，谁能允许<strong class="ka ir">O①</strong>搜索呢？我们看到这个野兽是一个<strong class="ka ir">集合</strong>集合。更具体地说，一个<strong class="ka ir">散列集</strong>。</p><p id="4b12" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是在深入讨论Hash之前，让我们从另一个角度来看看out <strong class="ka ir"> List </strong>数据结构。姑且称之为索引表吧。我们可以画一些列表，比如<strong class="ka ir">【5，2，6，4】</strong>为两列的表格:<strong class="ka ir">指标</strong>和<strong class="ka ir">值</strong>:</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div class="gh gi lz"><img src="../Images/648722144e35bdd36ddd9016f7af037d.png" data-original-src="https://miro.medium.com/v2/resize:fit:852/format:webp/1*frGgarRIvB00qQXRCgYltA.png"/></div></figure><p id="98d4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">其中index —是我们的值在列表中的位置。事实上，有了某个值的索引，我们可以用<strong class="ka ir"> O(1) </strong>的时间复杂度得到它——我们只需跳转到相应的存储单元即可。事实上，因为我们所有的元素都有相同的大小(整数值)——我们可以用索引乘以单个元素的大小。</p><p id="a187" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们可以将该值用作自身的<strong class="ka ir">键</strong>呢？我们刚刚发现了哈希集的主要思想！</p><p id="d988" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">想象一个特殊的数学函数，它可以得到值，比如说，<strong class="ka ir"> 5 </strong>，并计算它在我们的集合中的位置。这个函数有一个特殊的名字:<strong class="ka ir"> Hash </strong>。哈希函数可以非常简单。例如，它可以是一个简单的算法:</p><ul class=""><li id="f8fc" class="lf lg iq ka b kb kc kf kg kj lh kn li kr lj kv lk ll lm ln bi translated">获取值的字符串表示形式</li><li id="8719" class="lf lg iq ka b kb lo kf lp kj lq kn lr kr ls kv lk ll lm ln bi translated">将该字符串拆分为单个字符</li><li id="27f2" class="lf lg iq ka b kb lo kf lp kj lq kn lr kr ls kv lk ll lm ln bi translated">将字符映射到它们的ASCII数字</li><li id="5aa8" class="lf lg iq ka b kb lo kf lp kj lq kn lr kr ls kv lk ll lm ln bi translated">返回这些ASCII数字的总和</li></ul><p id="122d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以，对于我们的简单值<strong class="ka ir"> 5 </strong>，我们得出一个数字<strong class="ka ir"> 53 </strong> (google ASCII表)。这是我们自己的散列集实现中的值为5的地址。</p><p id="3c62" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当然，生产哈希函数要复杂得多。它们结合了计算速度和有效的碰撞算法。是的，碰撞会发生！想象两个值:53和35。我们自己简单的哈希函数会将它们放入哈希集中的单个<strong class="ka ir">桶</strong>中。是的，碰撞解决方案需要桶内的O(n)交互。好的散列函数会将你的值均匀地放在足够小的内存空间中。</p><p id="b311" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这一点上，你应该保持对哈希集如何工作以及为什么它对搜索算法如此重要的一般性理解。</p><p id="8450" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可以跳转到FlutLab并使用本课的代码，阅读一些关于Dart集合的方法的资料。</p><p id="ab3f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">结论。算法和数据结构是一个复杂而广泛的知识库。但是，我们可以在实践中学习。它的方法和术语的关键的、小的子集允许我们编写更有效的代码并通过编码面试。今天我们学习了如何使用适当的数据结构:散列集来加速搜索算法。我们已经知道散列函数是什么了。</p><p id="21bd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">待续..</p></div></div>    
</body>
</html>