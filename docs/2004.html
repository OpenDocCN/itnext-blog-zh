<html>
<head>
<title>React17, or how to get rid of “componentWillReceiveProps”?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React17，或者如何去掉“componentWillReceiveProps”？</h1>
<blockquote>原文：<a href="https://itnext.io/react17-or-how-to-get-rid-of-componentwillreceiveprops-c91f9a6f6f03?source=collection_archive---------0-----------------------#2019-03-14">https://itnext.io/react17-or-how-to-get-rid-of-componentwillreceiveprops-c91f9a6f6f03?source=collection_archive---------0-----------------------#2019-03-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/0c149cfab2f05ac7c19e356e31f0cec5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xd9PslNemQpco79bpCaWsQ.jpeg"/></div></div></figure><div class=""/><p id="8bbf" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如你可能已经知道的，随着<em class="kw"> React 16.3 </em>的发布，一些遗留的生命周期被废弃了。</p><blockquote class="kx ky kz"><p id="b833" class="jy jz kw ka b kb kc kd ke kf kg kh ki la kk kl km lb ko kp kq lc ks kt ku kv ij bi translated">我们学到的最大教训之一是，我们的一些遗留组件生命周期倾向于鼓励不安全的编码实践。</p><p id="8cf4" class="jy jz kw ka b kb kc kd ke kf kg kh ki la kk kl km lb ko kp kq lc ks kt ku kv ij bi translated">这些生命周期方法经常被误解和微妙地误用；此外，我们预计它们的潜在误用可能会给异步渲染带来更大的问题。</p></blockquote><h1 id="126b" class="ld le jb bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">那么现在会发生什么呢？</h1><p id="a3c7" class="pw-post-body-paragraph jy jz jb ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">从版本17开始，React对某些生命周期的支持将发生变化:</p><ul class=""><li id="33b4" class="mg mh jb ka b kb kc kf kg kj mi kn mj kr mk kv ml mm mn mo bi translated"><code class="fe mp mq mr ms b">componentWillMount</code></li><li id="5353" class="mg mh jb ka b kb mt kf mu kj mv kn mw kr mx kv ml mm mn mo bi translated"><code class="fe mp mq mr ms b">componentWillReceiveProps</code></li><li id="5785" class="mg mh jb ka b kb mt kf mu kj mv kn mw kr mx kv ml mm mn mo bi translated"><code class="fe mp mq mr ms b">componentWillUpdate</code></li></ul><p id="769c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从现在开始，只有新的“UNSAFE_”生命周期名称才起作用。这给我们留下了几个选择:</p><ul class=""><li id="9713" class="mg mh jb ka b kb kc kf kg kj mi kn mj kr mk kv ml mm mn mo bi translated">我们可以将生命周期事件重命名为<code class="fe mp mq mr ms b">UNSAFE_componentWillMount</code>、<code class="fe mp mq mr ms b">UNSAFE_componentWillReceiveProps</code>、<code class="fe mp mq mr ms b">UNSAFE_componentWillUpdate</code>，并希望一旦v17发布，什么都不会中断。甚至有这样的工具。</li><li id="4ce6" class="mg mh jb ka b kb mt kf mu kj mv kn mw kr mx kv ml mm mn mo bi translated">我们确实在尝试，并更改我们的组件以兼容React的未来版本。</li></ul><p id="1dd0" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我建议选择后者。</p></div><div class="ab cl mz na hu nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ij ik il im in"><h1 id="27c5" class="ld le jb bd lf lg ng li lj lk nh lm ln lo ni lq lr ls nj lu lv lw nk ly lz ma bi translated">让我们开始吧</h1><p id="20c2" class="pw-post-body-paragraph jy jz jb ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">我们必须去掉三个生命周期，所以我将尝试分别讨论每一个。</p><h2 id="7b58" class="nl le jb bd lf nm nn dn lj no np dp ln kj nq nr lr kn ns nt lv kr nu nv lz nw bi translated"><code class="fe mp mq mr ms b">componentWillMount</code></h2><p id="2898" class="pw-post-body-paragraph jy jz jb ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">这个很简单。用<code class="fe mp mq mr ms b">constructor</code>代替就行了。</p><figure class="nx ny nz oa gt is"><div class="bz fp l di"><div class="ob oc l"/></div><figcaption class="od oe gj gh gi of og bd b be z dk translated">以前</figcaption></figure><figure class="nx ny nz oa gt is"><div class="bz fp l di"><div class="ob oc l"/></div><figcaption class="od oe gj gh gi of og bd b be z dk translated">在...之后</figcaption></figure><p id="d9d4" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它看起来不错，但有一些警告。不建议在<code class="fe mp mq mr ms b">constructor</code>中有副作用(api获取，也许是一些计算)。最好把他们移到<code class="fe mp mq mr ms b">componentDidMount</code>而不是<em class="kw">建造者</em>。不利的一面是，它是在<code class="fe mp mq mr ms b">render()</code>之后执行的，所以根据副作用，你可能需要重新渲染。</p><div class="ip iq gp gr ir oh"><a href="http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/" rel="noopener  ugc nofollow" target="_blank"><div class="oi ab fo"><div class="oj ab ok cl cj ol"><h2 class="bd jc gy z fp om fr fs on fu fw ja bi translated">反应生命周期方法图</h2><div class="oo l"><h3 class="bd b gy z fp om fr fs on fu fw dk translated">完全交互式和可访问的React生命周期方法图。</h3></div><div class="op l"><p class="bd b dl z fp om fr fs on fu fw dk translated">projects.wojtekmaj.pl</p></div></div><div class="oq l"><div class="or l os ot ou oq ov ix oh"/></div></div></a></div></div><div class="ab cl mz na hu nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ij ik il im in"><h2 id="446c" class="nl le jb bd lf nm nn dn lj no np dp ln kj nq nr lr kn ns nt lv kr nu nv lz nw bi translated"><code class="fe mp mq mr ms b">componentWillUpdate</code></h2><blockquote class="kx ky kz"><p id="e46d" class="jy jz kw ka b kb kc kd ke kf kg kh ki la kk kl km lb ko kp kq lc ks kt ku kv ij bi translated">当接收到新的道具或状态时，在渲染之前调用<code class="fe mp mq mr ms b">componentWillUpdate()</code>。利用这一机会，在更新发生之前做好准备。初始呈现时不调用此方法。</p></blockquote><p id="af71" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个事件钩子基本上是<code class="fe mp mq mr ms b">componentWillReceiveProps</code>，但是更差。它发生在渲染之前，但是你不能使用<code class="fe mp mq mr ms b"><strong class="ka jc">this</strong>.setState()</code>。</p><p id="d040" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是它很有用，因为它让您可以在组件接收新的属性或状态之前控制组件的操作。我主要将它用于动画，因为它允许您为DOM节点预定义一些初始条件。</p><p id="0a13" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">根据React文档，该方法可以由<code class="fe mp mq mr ms b">componentDidUpdate()</code>代替。如果您用这种方法从DOM中读取(例如，保存一个滚动位置)，您可以将该逻辑移动到<code class="fe mp mq mr ms b">getSnapshotBeforeUpdate()</code>。</p><pre class="nx ny nz oa gt ow ms ox oy aw oz bi"><span id="dca0" class="nl le jb ms b gy pa pb l pc pd">getSnapshotBeforeUpdate(prevProps, prevState)</span></pre><p id="6b72" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mp mq mr ms b">getSnapshotBeforeUpdate()</code>在最近渲染的输出提交到DOM之前被调用。它返回快照<em class="kw">(默认值:NULL)，</em>，作为<code class="fe mp mq mr ms b">componentDidUpdate(prevProps, prevState, snapshot)</code>的第三个参数</p><figure class="nx ny nz oa gt is"><div class="bz fp l di"><div class="ob oc l"/></div></figure></div><div class="ab cl mz na hu nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ij ik il im in"><h1 id="f9c7" class="ld le jb bd lf lg ng li lj lk nh lm ln lo ni lq lr ls nj lu lv lw nk ly lz ma bi translated"><code class="fe mp mq mr ms b">componentWillReceiveProps</code></h1><p id="3664" class="pw-post-body-paragraph jy jz jb ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">这是非常常用和误用的react生命周期事件。我想把这一部分分成两部分——副作用和状态。</p><h2 id="f169" class="nl le jb bd lf nm nn dn lj no np dp ln kj nq nr lr kn ns nt lv kr nu nv lz nw bi translated">副作用</h2><p id="cd6f" class="pw-post-body-paragraph jy jz jb ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">考虑这个例子:我有一个内部通信集成，但是它需要在特定的路由上显示。</p><figure class="nx ny nz oa gt is"><div class="bz fp l di"><div class="ob oc l"/></div><figcaption class="od oe gj gh gi of og bd b be z dk translated">以前</figcaption></figure><figure class="nx ny nz oa gt is"><div class="bz fp l di"><div class="ob oc l"/></div><figcaption class="od oe gj gh gi of og bd b be z dk translated">在...之后</figcaption></figure><p id="ebd9" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mp mq mr ms b">componentDidUpdate</code>仅在更新发生并且<strong class="ka jc"> <em class="kw">未</em> </strong>在初始渲染时被调用。</p><p id="9c87" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可以用它做各种各样的副作用，从数据获取到DOM操作。你可以调用<code class="fe mp mq mr ms b"><strong class="ka jc">this</strong>.setState()</code>,但是要注意它必须被包装在一个条件中，就像上面的例子一样，否则你会导致一个无限循环。</p><h2 id="d2d8" class="nl le jb bd lf nm nn dn lj no np dp ln kj nq nr lr kn ns nt lv kr nu nv lz nw bi translated">组件级状态</h2><p id="ff3d" class="pw-post-body-paragraph jy jz jb ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">考虑这个例子:我有用于列表呈现组件，可以使用拖放操作对列表进行重新排序。出于性能原因，我决定在内部保留列表的副本，并且只更新dragEnd上的<em class="kw"> redux状态</em>。这要求我保持两种状态同步。</p><figure class="nx ny nz oa gt is"><div class="bz fp l di"><div class="ob oc l"/></div><figcaption class="od oe gj gh gi of og bd b be z dk translated">以前</figcaption></figure><figure class="nx ny nz oa gt is"><div class="bz fp l di"><div class="ob oc l"/></div><figcaption class="od oe gj gh gi of og bd b be z dk translated">在...之后</figcaption></figure><blockquote class="kx ky kz"><p id="d2a8" class="jy jz kw ka b kb kc kd ke kf kg kh ki la kk kl km lb ko kp kq lc ks kt ku kv ij bi translated"><code class="fe mp mq mr ms b">getDerivedStateFromProps</code>在调用render方法之前被调用，无论是初始挂载还是后续更新。它应该返回一个对象来更新状态，或者返回null来不更新任何东西。</p></blockquote><p id="2a04" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该方法仅<strong class="ka jc">对状态处理</strong>有用，所有其他副作用应移至<code class="fe mp mq mr ms b">componentDidUpdate</code>。此外，它是一个<code class="fe mp mq mr ms b">static</code>方法，对内部类方法的访问是有限的。</p></div><div class="ab cl mz na hu nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ij ik il im in"><blockquote class="kx ky kz"><p id="a560" class="jy jz kw ka b kb kc kd ke kf kg kh ki la kk kl km lb ko kp kq lc ks kt ku kv ij bi translated">此方法不能访问组件实例。如果您愿意，您可以通过提取组件props的纯函数和类定义之外的state，在<code class="fe mp mq mr ms b">getDerivedStateFromProps()</code>和其他类方法之间重用一些代码。</p></blockquote><p id="3146" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">假设我需要在两个数组之间做一些比较，在<code class="fe mp mq mr ms b">getDerivedStateFromProps</code>里面。我不能使用<code class="fe mp mq mr ms b"><strong class="ka jc">this.</strong>compareArrays()</code>、<strong class="ka jc">、</strong>来访问组件内部函数，所以在我的列表组件之外创建纯函数<code class="fe mp mq mr ms b">compareArrays</code>没什么不好。</p><figure class="nx ny nz oa gt is"><div class="bz fp l di"><div class="ob oc l"/></div></figure></div><div class="ab cl mz na hu nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ij ik il im in"><p id="0a2e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">感谢您阅读这篇文章。所有报价均取自官方<a class="ae my" href="https://reactjs.org/docs/react-component.html" rel="noopener ugc nofollow" target="_blank">反应文件</a>。</p></div><div class="ab cl mz na hu nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ij ik il im in"><p id="6ad0" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<a class="ae my" href="https://www.linkedin.com/in/giedrius-vickus" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上联系我或者在<a class="ae my" href="https://github.com/giedriusvickus" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上关注我。</p></div></div>    
</body>
</html>