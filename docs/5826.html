<html>
<head>
<title>Two lines change turned a 6 sec request to 300ms</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">两条线的改变将6秒的请求变成了300毫秒</h1>
<blockquote>原文：<a href="https://itnext.io/two-lines-change-turned-a-6-sec-request-to-300ms-cf0f13c00a75?source=collection_archive---------1-----------------------#2021-06-03">https://itnext.io/two-lines-change-turned-a-6-sec-request-to-300ms-cf0f13c00a75?source=collection_archive---------1-----------------------#2021-06-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="2a4d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们系统中一个奇怪的缓慢让我在TypeOrm的库代码中寻找宝藏。</p><p id="9c3b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于底线和解决方案，向下滚动到<a class="ae kl" href="#10f7" rel="noopener ugc nofollow"> <strong class="jp ir">第3部分</strong> </a>。</p><p id="8e44" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那是一个安静的下午，我正在做我自己的开发工作，这时我们的CTO闯进房间，喊道:“我们有一个大的演示，系统坏了！”<br/>快速查看了一下我的账户，显示一切正常，所以和大多数开发者一样，我回答说“对我来说一切正常”。<br/>但是当我查看主演示帐户(用于所有销售和CS演示)时，我发现它用了6秒钟(！！)来创造我们的基本实体。</p></div><div class="ab cl km kn hu ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ij ik il im in"><h1 id="4bfe" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">背景</h1><p id="c14b" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">在我们的系统中，有3个主要的实体:<br/> <strong class="jp ir">卖方</strong> -这个实体代表账户<br/> <strong class="jp ir">买方</strong> -从卖方<br/> <strong class="jp ir">交易</strong>购买的用户-买方和卖方<br/>之间的一个订单，我们花了6秒钟创建的实体是“交易”。</p><figure class="lw lx ly lz gt ma"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="44c3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">填充了所有关系的基本交易示例:</p><figure class="lw lx ly lz gt ma"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="e0f0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就是这样；我们准备开始了！</p></div><div class="ab cl km kn hu ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ij ik il im in"><h1 id="fe90" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated"><strong class="ak">第1部分—调查慢度</strong></h1><p id="7a3b" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">那么，为什么其他帐户都很好，而模拟帐户却很慢呢？我的第一个直觉是，这与这个帐户比其他帐户拥有更多数据的事实有关。</p><p id="6134" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">第一步:检查模拟账户中的数据</strong> <br/>在模拟账户下我发现我们有4000+的交易，和800+的买家。虽然这比其他帐户多，但不足以导致这种缓慢。</p><p id="03a3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">第二步:添加指标(感谢</strong> <a class="ae kl" href="https://www.honeycomb.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">蜂巢</strong> </a> <strong class="jp ir">！！)</strong></p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi md"><img src="../Images/f0eea70f74e88bfc922cf937ca7590ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GukrnjDRGyQ2jRdtzGWBxA.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">请求耗时6.3秒</figcaption></figure><p id="59fe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从指标中我们可以看到，创建事务(及其相关实体，如行)是瓶颈，但是实际插入的查询似乎非常快。</p><p id="65ed" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">步骤3:查看“createTransaction”内部</strong></p><p id="b2fc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">创建事务方法有两个部分，初始化实例并将其保存到数据库:</p><figure class="lw lx ly lz gt ma"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="d825" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我的猜测是，问题出在创建事务的“保存”部分，这是异步部分，也是我们调用数据库的地方。“<a class="ae kl" href="https://typeorm.io/#/entity-manager-api" rel="noopener ugc nofollow" target="_blank"> create </a>()”部分是一个简单的实例初始化，与new Transaction()相同；</p><p id="f705" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了证实这一点，我在两个部分都添加了指标:</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi mo"><img src="../Images/c4a90912c497ffda87ecac4cb2d857ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TR75ovYoo2elymh4ghTzyg.png"/></div></div></figure><p id="d5f6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这不可能是对的。一个简单的对象初始化怎么可能需要2秒钟？<br/>这里很可能隐藏着另一个问题；也许度量库在异步方面有一些缺陷？</p><p id="e2e2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我可以很容易地通过手动初始化来反驳这一点，但老实说，我对这个解决方案没有信心。</p><p id="2906" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">步骤4:更改实例初始化以确保</strong></p><figure class="lw lx ly lz gt ma"><div class="bz fp l di"><div class="mb mc l"/></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">变化之前</figcaption></figure><figure class="lw lx ly lz gt ma"><div class="bz fp l di"><div class="mb mc l"/></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">变化之后</figcaption></figure><p id="bc0e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在来看一下指标:</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi mp"><img src="../Images/a34ab1c80a496770741d00ddbf1621c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*n8PSX8nS7AABfHW5"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">300毫秒</figcaption></figure><p id="cb00" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">什么？为什么？怎么会？6秒变成了300毫秒。</p><p id="c4cb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在TypeOrm create()方法中一定有隐藏的逻辑，但是为什么这个问题只出现在一个帐户中？所有实例的初始化行为应该相同。</p><p id="ea6e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我唯一能确定的是，来自TypeOrm库的create()并不像他们的文档中描述的那样是一个简单的“新实例()”</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi mq"><img src="../Images/a215949757d08aee206f1d5ef4fdccd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0zjoYGAwqjCnOxSk"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">来自https://typeorm.io/#/entity-manager-api<a class="ae kl" href="https://typeorm.io/#/entity-manager-api" rel="noopener ugc nofollow" target="_blank">的文件</a></figcaption></figure></div><div class="ab cl km kn hu ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ij ik il im in"><h1 id="67ba" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated"><strong class="ak">第二部分-调试类型代码</strong></h1><p id="48ad" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">我的下一步是看看typeOrm create方法中的内容:</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi mr"><img src="../Images/51002ae64d61998c7533a4a8a77350ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GQVtmu4F8Aeb8vDC"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated"><a class="ae kl" href="https://github.com/typeorm/typeorm/blob/beea2e1e4429d13d7864ebc23aa6e58fa01647ea/src/entity-manager/EntityManager.ts#L239" rel="noopener ugc nofollow" target="_blank">https://github . com/type ORM/type ORM/blob/beea 2e 1 e 4429d 13d 7864 ebc 23 aa 6 e 58 fa 01647 ea/src/entity-manager/entitymanager . ts # L239</a></figcaption></figure><p id="a357" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此时，我开始在Js TypeOrm代码中添加指标(当连接到模拟帐户数据库时，我在本地调试它)</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi ms"><img src="../Images/e60c67bf618aed207c2ff9d7ed41945a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Sn8CxU0qYl2zzJfk"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">这是添加了我的“time()”的JS TypeOrm代码</figcaption></figure><p id="3ca6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Time()度量显示问题出在转换部分。我们来看一下(transform()方法刚刚调用了groupAndTransform()):</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi mt"><img src="../Images/99997ccc0ad815b0894f1092a5d980a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*iUxSktlni-Dkotvw"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated"><a class="ae kl" href="https://github.com/typeorm/typeorm/blob/beea2e1e4429d13d7864ebc23aa6e58fa01647ea/src/query-builder/transformer/PlainObjectToNewEntityTransformer.ts#L14" rel="noopener ugc nofollow" target="_blank">https://github . com/type ORM/type ORM/blob/beea 2 E1 e 4429d 13d 7864 ebc 23 aa 6 e 58 fa 01647 ea/src/query-builder/transformer/plainobjecttonetitytransformer . ts # L14</a></figcaption></figure><p id="954d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是怎么回事？<br/>突出显示的行是一个递归调用:对于事务中的每个关系字段，该方法都被调用，但是对于该关系的每个关系字段…</p><p id="050f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们以发送给create()的事务为例，打印我们在transform方法中得到的所有对象。</p><figure class="lw lx ly lz gt ma"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="12a5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们得到这个:<br/>交易//我们发送的要创建的交易实体<br/>卖方-S1//卖方与交易的关系<br/>买方-B1//买方1与卖方1的关系<br/>买方-B2//买方2与卖方1的关系<br/>买方-B3//买方3与卖方1的关系<br/>买方-B1//买方1与交易的关系</p><p id="0dfd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好的，我有所进展…在模拟账户案例中，我们有800个买家，所以它被称为800+次。<br/>第一个用于交易，第二个用于卖方关系，一个用于该卖方的每个买方关系(800+)。</p><p id="3596" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这也是为什么我们只看到这个帐户的缓慢，其他帐户只有少数买家连接到他们。</p></div><div class="ab cl km kn hu ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ij ik il im in"><h1 id="10f7" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated"><strong class="ak">第3部分:解决方案</strong></h1><p id="54d5" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">该问题是由于TypeOrm在create()方法中转换关系实例的方式造成的。以下是如何解决/避免这种情况的一些选项:</p><p id="8c0a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在进行任何修复之前，我对create()的调用如下所示:</p><figure class="lw lx ly lz gt ma"><div class="bz fp l di"><div class="mb mc l"/></div></figure><ol class=""><li id="f97f" class="mu mv iq jp b jq jr ju jv jy mw kc mx kg my kk mz na nb nc bi translated">使用New()初始化——你总是可以使用简单的new Instance()并自己初始化字段，就像我在第4步中做的那样，这样你就可以完全避免调用create()。</li></ol><figure class="lw lx ly lz gt ma"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="4ceb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2.仅发送id-如果仍想使用create()，请确保不要在创建字段中发送完整的关系实例，仅发送id。(该字段是您真正需要的唯一内容，因为这是表中的真正引用)。</p><figure class="lw lx ly lz gt ma"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="16b9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">3.记住只从数据库中获取您需要的关系。在我的例子中，我们不需要所有800+的买家在内存中找到卖家。TypeOrm使得获取你不需要的字段变得非常容易，因为你已经在实体上有了它们。</p><p id="3d09" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">结束了！</p></div></div>    
</body>
</html>