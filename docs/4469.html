<html>
<head>
<title>JS and ES6 cool hints for shorter statements</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JS和ES6针对较短语句的酷提示</h1>
<blockquote>原文：<a href="https://itnext.io/js-and-es6-cool-hints-for-shorter-statements-be766983a75e?source=collection_archive---------5-----------------------#2020-07-06">https://itnext.io/js-and-es6-cool-hints-for-shorter-statements-be766983a75e?source=collection_archive---------5-----------------------#2020-07-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="c499" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">java描述语言</h2><div class=""/><div class=""><h2 id="3682" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">已知或未知的快捷方式…</h2></div><p id="8a5e" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">众所周知，Javascript或JS是一种强大的编程语言，它允许创建许多令人印象深刻的应用程序。</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi ln"><img src="../Images/0d43e2103a3d2db92049e22e3b1abe0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dbFmyCfRQmPhVXi6"/></div></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk translated">照片由<a class="ae md" href="https://unsplash.com/@parthposts?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> parth upadhyay </a>在<a class="ae md" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="b9c9" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">顺便说一下，让我们停止称它为Javascript，而更喜欢用<strong class="kt jd"> JS </strong>作为<a class="ae md" href="https://mobile.twitter.com/BrendanEich" rel="noopener ugc nofollow" target="_blank"> Brendan Eich </a>几天前宣称的名称:</p><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="me mf l"/></div></figure></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><p id="16b6" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">无论如何，在这篇文章中，我将分享一些我日常使用的有用技巧，使我的陈述更简短，有时更具可读性。</p><h1 id="1b8a" class="mn mo it bd mp mq mr ms mt mu mv mw mx ki my kj mz kl na km nb ko nc kp nd ne bi translated">字符串操作</h1><h2 id="871f" class="nf mo it bd mp ng nh dn mt ni nj dp mx la nk nl mz le nm nn nb li no np nd iz bi translated">—字符串串联数组—</h2><p id="1b3b" class="pw-post-body-paragraph kr ks it kt b ku nq kd kw kx nr kg kz la ns lc ld le nt lg lh li nu lk ll lm im bi translated">也许你知道<code class="fe nv nw nx ny b">join</code>函数，我肯定你知道。但是如果我告诉你有一个秘密的方法来声明分隔符呢:</p><p id="ddb6" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我们习惯说:</p><pre class="lo lp lq lr gt nz ny oa ob aw oc bi"><span id="d7ec" class="nf mo it ny b gy od oe l of og">['a', 'b', 'c', 'd'].join(', ') =&gt; 'a, b, c, d'</span></pre><p id="d799" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我给你介绍一种更简单的方法:</p><pre class="lo lp lq lr gt nz ny oa ob aw oc bi"><span id="c791" class="nf mo it ny b gy od oe l of og">['a', 'b', 'c', 'd'].join`, ` =&gt; 'a, b, c, d'</span></pre><blockquote class="oh oi oj"><p id="6598" class="kr ks ok kt b ku kv kd kw kx ky kg kz ol lb lc ld om lf lg lh on lj lk ll lm im bi translated">是的，它节省了2个角色，但这是展示你技能的一种很酷的方式<em class="it">😉</em></p></blockquote><h2 id="aa2c" class="nf mo it bd mp ng nh dn mt ni nj dp mx la nk nl mz le nm nn nb li no np nd iz bi translated">—字符串拆分—</h2><p id="6fa7" class="pw-post-body-paragraph kr ks it kt b ku nq kd kw kx nr kg kz la ns lc ld le nt lg lh li nu lk ll lm im bi translated">如前所述，我们可以对<code class="fe nv nw nx ny b">split</code>函数使用相同的快捷方式:</p><p id="fc32" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">之前:</p><pre class="lo lp lq lr gt nz ny oa ob aw oc bi"><span id="ec3b" class="nf mo it ny b gy od oe l of og">'abcd'.split('') =&gt; ['a', 'b', 'c', 'd']</span></pre><p id="f4f1" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">然后:</p><pre class="lo lp lq lr gt nz ny oa ob aw oc bi"><span id="6581" class="nf mo it ny b gy od oe l of og">['a', 'b', 'c', 'd'].split`` =&gt; ['a', 'b', 'c', 'd']</span></pre><blockquote class="oh oi oj"><p id="a122" class="kr ks ok kt b ku kv kd kw kx ky kg kz ol lb lc ld om lf lg lh on lj lk ll lm im bi translated">再一次，2个角色被保存，这是一个很酷的方式来证明你不可思议的技能<em class="it">😉</em></p></blockquote><h2 id="291e" class="nf mo it bd mp ng nh dn mt ni nj dp mx la nk nl mz le nm nn nb li no np nd iz bi translated">—弦铸造—</h2><p id="582c" class="pw-post-body-paragraph kr ks it kt b ku nq kd kw kx nr kg kz la ns lc ld le nt lg lh li nu lk ll lm im bi translated">要将变量转换成字符串原语，有很多方法:</p><pre class="lo lp lq lr gt nz ny oa ob aw oc bi"><span id="4bb8" class="nf mo it ny b gy od oe l of og">let a = 4; a.toString()   =&gt;  '4'<br/>String(3)                 =&gt;  '3'<br/>'' + true                 =&gt;  'true'<br/>`${ { 'a': 7 } }`         =&gt;  '[object Object]'</span></pre><h2 id="13b3" class="nf mo it bd mp ng nh dn mt ni nj dp mx la nk nl mz le nm nn nb li no np nd iz bi translated">—访问一个角色—</h2><p id="5e23" class="pw-post-body-paragraph kr ks it kt b ku nq kd kw kx nr kg kz la ns lc ld le nt lg lh li nu lk ll lm im bi translated">访问字符有助于在呈现字符串时对其进行格式化，为此，有两种可能的方法:</p><pre class="lo lp lq lr gt nz ny oa ob aw oc bi"><span id="d9d8" class="nf mo it ny b gy od oe l of og">'IamAString'[3] =&gt; 'A'<br/>let b = 'IamAnotherString'; b.charAt(9) =&gt; 'r'</span></pre><blockquote class="oh oi oj"><p id="faef" class="kr ks ok kt b ku kv kd kw kx ky kg kz ol lb lc ld om lf lg lh on lj lk ll lm im bi translated">实际上，字符串只是一个字符数组，对吧！？<em class="it">😊</em></p></blockquote></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="7d59" class="mn mo it bd mp mq oo ms mt mu op mw mx ki oq kj mz kl or km nb ko os kp nd ne bi translated">布尔检查</h1><h2 id="c9fe" class="nf mo it bd mp ng nh dn mt ni nj dp mx la nk nl mz le nm nn nb li no np nd iz bi translated">—一体化检查—</h2><p id="2d8f" class="pw-post-body-paragraph kr ks it kt b ku nq kd kw kx nr kg kz la ns lc ld le nt lg lh li nu lk ll lm im bi translated">在代码中的某些地方，您可能需要检查几个布尔值，因此您最终会得到以下代码:</p><pre class="lo lp lq lr gt nz ny oa ob aw oc bi"><span id="3a1a" class="nf mo it ny b gy od oe l of og">isConnected &amp;&amp; isAdmin &amp;&amp; !isLoading &amp;&amp; !dataFetched &amp;&amp; …</span></pre><p id="1078" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">断言可能会很长…相反，我们可以结合使用<code class="fe nv nw nx ny b">every</code>函数和一个简单的断言:</p><pre class="lo lp lq lr gt nz ny oa ob aw oc bi"><span id="c9da" class="nf mo it ny b gy od oe l of og">[<br/>isConnected,<br/>isAdmin,<br/>!isLoading,<br/>!dataFetched<br/>].every(x =&gt; x === true)</span></pre><p id="86e1" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">这种方式使您的代码更具可读性，并易于修改。</p><blockquote class="oh oi oj"><p id="5ba5" class="kr ks ok kt b ku kv kd kw kx ky kg kz ol lb lc ld om lf lg lh on lj lk ll lm im bi translated">当您的检查使用<em class="it"> || </em>运算符时，这也可以与<code class="fe nv nw nx ny b">some</code>函数一起使用。</p></blockquote><h2 id="4d11" class="nf mo it bd mp ng nh dn mt ni nj dp mx la nk nl mz le nm nn nb li no np nd iz bi translated">—短路评估—</h2><p id="2768" class="pw-post-body-paragraph kr ks it kt b ku nq kd kw kx nr kg kz la ns lc ld le nt lg lh li nu lk ll lm im bi translated">这是非常常见的检查和调用函数如下:</p><pre class="lo lp lq lr gt nz ny oa ob aw oc bi"><span id="2b2c" class="nf mo it ny b gy od oe l of og">if (isAdmin) {<br/>  deleteUser(userToDelete);<br/>}</span></pre><p id="7f5d" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">然而，通过<em class="ok">短路评估</em>，您可以将3行代码转换成1:</p><pre class="lo lp lq lr gt nz ny oa ob aw oc bi"><span id="09b5" class="nf mo it ny b gy od oe l of og">isAdmin &amp;&amp; deleteUser(userToDelete)</span></pre><p id="a170" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">相当得心应手，对！？</p><h2 id="fd55" class="nf mo it bd mp ng nh dn mt ni nj dp mx la nk nl mz le nm nn nb li no np nd iz bi translated">—无效运算符—</h2><p id="bd3f" class="pw-post-body-paragraph kr ks it kt b ku nq kd kw kx nr kg kz la ns lc ld le nt lg lh li nu lk ll lm im bi translated">好吧，我猜你知道:</p><pre class="lo lp lq lr gt nz ny oa ob aw oc bi"><span id="f6ae" class="nf mo it ny b gy od oe l of og">const isSimpleUser = !user.hasAdminRights()</span></pre><p id="d5fa" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">但是，关于:</p><pre class="lo lp lq lr gt nz ny oa ob aw oc bi"><span id="7594" class="nf mo it ny b gy od oe l of og">const isUserDefined = !!user</span></pre><blockquote class="oh oi oj"><p id="e794" class="kr ks ok kt b ku kv kd kw kx ky kg kz ol lb lc ld om lf lg lh on lj lk ll lm im bi translated">事实上，<code class="fe nv nw nx ny b">!</code>操作符将一个原语或一个对象转换成它的<em class="it">布尔值</em>并返回它的<code class="fe nv nw nx ny b">falsy</code>值。再次应用<code class="fe nv nw nx ny b">!</code>会将其转换为<code class="fe nv nw nx ny b">truthy</code>值。</p></blockquote><p id="ee89" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">或者甚至:</p><pre class="lo lp lq lr gt nz ny oa ob aw oc bi"><span id="2fcd" class="nf mo it ny b gy od oe l of og">const user = getLocalUser() ?? new User()</span></pre><p id="7055" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">当左边的成员为<code class="fe nv nw nx ny b">null</code>或<code class="fe nv nw nx ny b">undefined</code>时<a class="ae md" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Nullish_coalescing_operator" rel="noopener ugc nofollow" target="_blank">无效合并</a>操作符<code class="fe nv nw nx ny b">??</code>返回右边的成员。与<code class="fe nv nw nx ny b">||</code>运算符不同的是，当左边的运算符为<em class="ok"> falsy </em>时，这个运算符返回右边的成员。</p><blockquote class="oh oi oj"><p id="21f2" class="kr ks ok kt b ku kv kd kw kx ky kg kz ol lb lc ld om lf lg lh on lj lk ll lm im bi translated">小心，也许你的编译器不会接受这种语法。为了克服这个障碍，可以考虑添加<a class="ae md" href="https://babeljs.io/docs/en/babel-plugin-proposal-nullish-coalescing-operator" rel="noopener ugc nofollow" target="_blank">相关的Babel插件</a>。</p></blockquote></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="ee8d" class="mn mo it bd mp mq oo ms mt mu op mw mx ki oq kj mz kl or km nb ko os kp nd ne bi translated">设置功能</h1><h2 id="158e" class="nf mo it bd mp ng nh dn mt ni nj dp mx la nk nl mz le nm nn nb li no np nd iz bi translated">—数组函数—</h2><p id="0e23" class="pw-post-body-paragraph kr ks it kt b ku nq kd kw kx nr kg kz la ns lc ld le nt lg lh li nu lk ll lm im bi translated"><code class="fe nv nw nx ny b"><strong class="kt jd">pop</strong></code></p><p id="0a3a" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">这个函数用于移除数组的最后一个值，但是你知道它会返回值吗？</p><p id="07dc" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">而这是移除的值，所以是数组的最后一个值！</p><p id="fa43" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><code class="fe nv nw nx ny b"><strong class="kt jd">shift</strong></code></p><p id="bb27" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我猜你看到它来了…是的，它和<code class="fe nv nw nx ny b">pop</code>完全一样，<code class="fe nv nw nx ny b">shift</code>返回数组的第一个值，当然，这个值已经通过调用这个方法被移除了。</p><h2 id="a026" class="nf mo it bd mp ng nh dn mt ni nj dp mx la nk nl mz le nm nn nb li no np nd iz bi translated">— ES6阵列功能—</h2><p id="9535" class="pw-post-body-paragraph kr ks it kt b ku nq kd kw kx nr kg kz la ns lc ld le nt lg lh li nu lk ll lm im bi translated"><code class="fe nv nw nx ny b"><strong class="kt jd">Removing duplicates</strong></code></p><p id="ec3e" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">如果你知道<code class="fe nv nw nx ny b">Set</code>在JS中是如何工作的，也许你知道这个技巧，它使用了扩展操作符<code class="fe nv nw nx ny b">…</code>:</p><pre class="lo lp lq lr gt nz ny oa ob aw oc bi"><span id="9ebb" class="nf mo it ny b gy od oe l of og">const a = [1, 1, 2, 2, 3, 4, 4, 5]</span><span id="0747" class="nf mo it ny b gy ot oe l of og">function unique (arr) {<br/>  return [...new Set(arr)]<br/>}</span><span id="26f2" class="nf mo it ny b gy ot oe l of og">const b = unique(a) =&gt; [1, 2, 3, 4, 5]</span></pre><p id="7dd5" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">它有一个使用<code class="fe nv nw nx ny b">reduce</code>数组函数的版本，但是没有前面的代码片段那么短。</p><pre class="lo lp lq lr gt nz ny oa ob aw oc bi"><span id="1555" class="nf mo it ny b gy od oe l of og">function removeDuplicates(arr) {<br/>  return arr.reduce((acc, cur) =&gt; {<br/>    if(acc.indexOf(cur) === -1) acc.push(cur);<br/>    return acc;<br/>  }, []);<br/>}</span></pre></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="e5cf" class="mn mo it bd mp mq oo ms mt mu op mw mx ki oq kj mz kl or km nb ko os kp nd ne bi translated">对象、析构和函数</h1><p id="78a8" class="pw-post-body-paragraph kr ks it kt b ku nq kd kw kx nr kg kz la ns lc ld le nt lg lh li nu lk ll lm im bi translated"><em class="ok">用ES6特性增强您的代码……</em></p><h2 id="cd7f" class="nf mo it bd mp ng nh dn mt ni nj dp mx la nk nl mz le nm nn nb li no np nd iz bi translated">—箭头功能和对象—</h2><p id="503f" class="pw-post-body-paragraph kr ks it kt b ku nq kd kw kx nr kg kz la ns lc ld le nt lg lh li nu lk ll lm im bi translated">我毫不怀疑你知道并使用箭头功能。</p><pre class="lo lp lq lr gt nz ny oa ob aw oc bi"><span id="1d74" class="nf mo it ny b gy od oe l of og">(name) =&gt; {<br/>  return `Hello World ${name}!`<br/>}</span></pre><p id="9642" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">有一个有用的快捷方式可以避免大括号并简化上面的代码:</p><pre class="lo lp lq lr gt nz ny oa ob aw oc bi"><span id="fea1" class="nf mo it ny b gy od oe l of og">(name) =&gt; `Hello World ${name}!`</span></pre><p id="1437" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">这也可以用于对象和对象文字:</p><pre class="lo lp lq lr gt nz ny oa ob aw oc bi"><span id="ffa5" class="nf mo it ny b gy od oe l of og">const rights = (user) =&gt; user.rights</span><span id="463c" class="nf mo it ny b gy ot oe l of og">// OR</span><span id="8d38" class="nf mo it ny b gy ot oe l of og">const customRights = (user) =&gt; ({<br/>  canAdd: user.rights.addition,<br/>  canEdit: user.rights.edition,<br/>  canDelete: user.rights.deletion<br/>})</span></pre><blockquote class="oh oi oj"><p id="5460" class="kr ks ok kt b ku kv kd kw kx ky kg kz ol lb lc ld om lf lg lh on lj lk ll lm im bi translated"><em class="it"> ⚠️ </em>小心，记住箭头函数的作用域是它们父函数的作用域。</p></blockquote><h2 id="3cf4" class="nf mo it bd mp ng nh dn mt ni nj dp mx la nk nl mz le nm nn nb li no np nd iz bi translated">—覆盖对象属性—</h2><p id="8698" class="pw-post-body-paragraph kr ks it kt b ku nq kd kw kx nr kg kz la ns lc ld le nt lg lh li nu lk ll lm im bi translated">如你所知，我们可以像下面这样析构一个对象:</p><pre class="lo lp lq lr gt nz ny oa ob aw oc bi"><span id="4131" class="nf mo it ny b gy od oe l of og">const { name } = { name: 'Adrien' }</span></pre><p id="8cf0" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">例如，我们可以使用扩展运算符<code class="fe nv nw nx ny b">…</code>来合并数组:</p><pre class="lo lp lq lr gt nz ny oa ob aw oc bi"><span id="92f2" class="nf mo it ny b gy od oe l of og">const a = [1, 2, 3]<br/>const b = [4, 5, 6]</span><span id="6a98" class="nf mo it ny b gy ot oe l of og">const c = [...a, ...b] =&gt; [1, 2, 3, 4, 5, 6]</span></pre><p id="cdf1" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">该运算符也可用于对象:</p><pre class="lo lp lq lr gt nz ny oa ob aw oc bi"><span id="a809" class="nf mo it ny b gy od oe l of og">const objA = { a: 1, b: 2 }<br/>const objB = { ...objA, c: 3 }</span></pre><p id="b198" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">甚至覆盖属性:</p><pre class="lo lp lq lr gt nz ny oa ob aw oc bi"><span id="f13b" class="nf mo it ny b gy od oe l of og">const objC = { ...objB, c: 4 } =&gt; { a: 1, b: 2, c: 4 }</span></pre><blockquote class="oh oi oj"><p id="a647" class="kr ks ok kt b ku kv kd kw kx ky kg kz ol lb lc ld om lf lg lh on lj lk ll lm im bi translated"><em class="it"> ⚠️ </em>注意:被覆盖的属性必须出现在<code class="fe nv nw nx ny b">…</code>之后，因为最后一个值被考虑在内。</p></blockquote><h2 id="4234" class="nf mo it bd mp ng nh dn mt ni nj dp mx la nk nl mz le nm nn nb li no np nd iz bi translated">—参数和解构—</h2><p id="fbc9" class="pw-post-body-paragraph kr ks it kt b ku nq kd kw kx nr kg kz la ns lc ld le nt lg lh li nu lk ll lm im bi translated">有时，你有一个带参数的函数，你只使用一个属性或一组属性。多亏了对象析构，你可以得到你需要的属性:</p><pre class="lo lp lq lr gt nz ny oa ob aw oc bi"><span id="b95e" class="nf mo it ny b gy od oe l of og">// Before</span><span id="faf0" class="nf mo it ny b gy ot oe l of og">function parseValue (data) {<br/>  const val = data.value<br/>  // ...<br/>}</span><span id="a207" class="nf mo it ny b gy ot oe l of og">// After</span><span id="8d96" class="nf mo it ny b gy ot oe l of og">function parseValue ({ value }) {<br/>  // you can directly use value<br/>  // ...<br/>}</span></pre></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="20a3" class="mn mo it bd mp mq oo ms mt mu op mw mx ki oq kj mz kl or km nb ko os kp nd ne bi translated">结尾词</h1><p id="3d47" class="pw-post-body-paragraph kr ks it kt b ku nq kd kw kx nr kg kz la ns lc ld le nt lg lh li nu lk ll lm im bi translated">这些快捷方式相对来说比较方便。根据你的观点，它们可能看起来更易读，否则，对初级开发人员来说是不可理解的。反正用不用都是你自己的事。</p><p id="0bae" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我强烈建议你在Codewars上面对一些挑战:</p><div class="ou ov gp gr ow ox"><a href="https://www.codewars.com/" rel="noopener  ugc nofollow" target="_blank"><div class="oy ab fo"><div class="oz ab pa cl cj pb"><h2 class="bd jd gy z fp pc fr fs pd fu fw jc bi translated">代码战争:通过挑战达到精通</h2><div class="pe l"><h3 class="bd b gy z fp pc fr fs pd fu fw dk translated">Codewars是开发人员通过挑战掌握代码的地方。在道场训练形，达到你的最高境界…</h3></div><div class="pf l"><p class="bd b dl z fp pc fr fs pd fu fw dk translated">www.codewars.com</p></div></div><div class="pg l"><div class="ph l pi pj pk pg pl lx ox"/></div></div></a></div><p id="4430" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">这是提高和挑战自己技能的好方法。玩几个不同难度的谜题，我学到了很多。尤其是发现JS函数的意外用法时…</p></div></div>    
</body>
</html>