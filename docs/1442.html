<html>
<head>
<title>Building a Javascript module bundler</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建Javascript模块捆绑器</h1>
<blockquote>原文：<a href="https://itnext.io/building-a-javascript-module-bundler-152233571824?source=collection_archive---------3-----------------------#2018-10-15">https://itnext.io/building-a-javascript-module-bundler-152233571824?source=collection_archive---------3-----------------------#2018-10-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/93384742759c09f032dfb89f93e3b910.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BT35xIMQiUgkcOxk67qL1g.png"/></div></div></figure><p id="4686" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Javascript模块捆绑器是一个工具，允许您将多个Javascript模块捆绑到一个或多个输出文件中。将您的JS代码分成多个模块，并需要来自包管理存储库的共享模块，这是现代web开发中的常见做法。浏览器中的Javascript本身并不支持模块(尽管一些浏览器开始支持)，因此需要模块捆绑来将所有模块粘合在一起。有几种不同的方式可以捆绑模块，包括AMD、Common JS和Import方法，Javascript运行时节点普及了Common JS，我们将构建自己的捆绑器来支持这一点。有几个流行的Javascript捆绑器已经存在一段时间了，webpack是最常见的一个，其他的包括Rollup、Browserify和package。</p><p id="0474" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">捆绑器获取Javascript源代码，对其进行处理，以某种方式进行转换，然后输出不同形式的源代码。在我们的例子中，我们将各个Javascript源文件捆绑在一起，同时重写特定的代码片段，例如常见JS模块格式使用的require函数调用。大多数捆绑器将使用图形数据结构(<a class="ae kw" href="https://en.wikipedia.org/wiki/Dependency_graph" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Dependency_graph</a>)来构建依赖图，这可以用于生成JS包、可视化和代码分割。在这个bundler中，我们将简化一些事情，例如放弃一个完全定向的依赖图，只使用一个对象来存储我们的包，我们还将同步解析模块，这将会更慢，但允许更简单的代码。</p><h1 id="6ef8" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">TL；速度三角形定位法(dead reckoning)</h1><p id="eeac" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated"><em class="ma">来源</em>:【https://github.com/jackpopp/bundler/blob/master/src】T4</p><p id="475d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">捆绑模块的基本步骤如下:</p><ul class=""><li id="4d60" class="mb mc iq ka b kb kc kf kg kj md kn me kr mf kv mg mh mi mj bi translated">使用acorn将初始源代码转换为抽象语法树</li><li id="400c" class="mb mc iq ka b kb mk kf ml kj mm kn mn kr mo kv mg mh mi mj bi translated">遍历抽象语法树并检测所需的函数调用</li><li id="8dae" class="mb mc iq ka b kb mk kf ml kj mm kn mn kr mo kv mg mh mi mj bi translated">通过处理具有名为require的被调用方的调用表达式来解析模块</li><li id="df28" class="mb mc iq ka b kb mk kf ml kj mm kn mn kr mo kv mg mh mi mj bi translated">在公共JS helper函数中包装解析的模块</li><li id="14f3" class="mb mc iq ka b kb mk kf ml kj mm kn mn kr mo kv mg mh mi mj bi translated">对于每个已解析的模块，生成抽象语法树并递归地遍历该抽象语法树</li><li id="9df0" class="mb mc iq ka b kb mk kf ml kj mm kn mn kr mo kv mg mh mi mj bi translated">将每个修改后的抽象语法树添加到模块对象中</li><li id="1221" class="mb mc iq ka b kb mk kf ml kj mm kn mn kr mo kv mg mh mi mj bi translated">迭代抽象语法树集合，使用escodegen将每个树转换为代码</li><li id="9672" class="mb mc iq ka b kb mk kf ml kj mm kn mn kr mo kv mg mh mi mj bi translated">包装在立即调用的函数表达式中</li><li id="3fde" class="mb mc iq ka b kb mk kf ml kj mm kn mn kr mo kv mg mh mi mj bi translated">将包写入文件</li></ul><p id="34fe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">捆绑器首先读取入口点JS文件file，并将其转换为遵循ecmascript 2018规范的抽象语法树(AST)(<a class="ae kw" href="https://www.ecma-international.org/ecma-262/9.0/index.html#Title" rel="noopener ugc nofollow" target="_blank">https://www . ECMA-international . org/ECMA-262/9.0/index . html # Title</a>)。AST是源代码的树形表示，每个节点代表语言中的一个结构。为了将初始源文件解析为AST，我们可以使用acorn模块，生成的AST遵循2018 Ecmascript规范的estree实现，可以在这里找到(<a class="ae kw" href="https://github.com/estree/estree" rel="noopener ugc nofollow" target="_blank">https://github.com/estree/estree</a>)。使用规范，我们可以找出我们想要查找和修改的节点，以便将我们所有的代码捆绑在一起。我们将使用AST，并使用estraverse模块来遍历节点，访问每个节点，检查类型，然后修改、替换或删除。对于我们找到的所有常见的JS require函数调用，这将需要递归地发生。</p><h1 id="5329" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">初始设置</h1><p id="b990" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">为我们所有的源代码创建一个名为bundler的目录，在这里为bundler源代码添加一个src目录，为我们的演示项目添加演示目录。在根目录和演示目录中初始化package.json，我们需要演示目录中的package.json来测试我们已经安装在演示项目中的捆绑节点模块。</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="28c7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们的演示目录中，我们将添加一些代码，要求对src目录中的模块和已经从npm安装到node_modules目录中的模块进行函数调用。</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><h1 id="60a4" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">创建初始AST</h1><p id="bdff" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">在src目录下安装<strong class="ka ir"> acorn </strong>并在索引文件中需要它以及path和fs模块，并创建一个名为<code class="fe mv mw mx my b">sourceToAST</code>的函数，这将把源文件转换成AST。该函数将有一个源参数，并将调用acorn的<code class="fe mv mw mx my b">parse</code>函数，它将接受源作为一个参数以及一个选项对象，我们可以在其中指定emca版本。我们还将初始化一个名为<code class="fe mv mw mx my b">MODULES</code>的对象变量，它将存储所有已解析模块的集合。</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="28a5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来创建一个bundler函数，它有入口点和输出文件的参数，我们需要为根路径、初始模块和输出文件创建变量。我们将使用全局流程对象基于当前工作目录创建这些路径。我们还将运行捆绑器初始化，并注销捆绑器中的路径，以确保一切正常。</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="2951" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们应该看到一个格式良好的对象，包含所有路径，变量作为关键字，如下所示:</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="0847" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我们需要将初始模块的源代码传递给生成AST的函数，然后我们就有了可以开始工作的初始AST。因此，让我们删除之前添加的<code class="fe mv mw mx my b">console.log</code>调用，取而代之的是读入文件并将源代码传递给函数。</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="c967" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们已经有了初始的AST，我们可以遍历它来找到所有的<code class="fe mv mw mx my b">require</code>函数调用，我们将处理这些以便捆绑所有的模块，并且我们将需要对所有被解析的模块递归地这样做。</p><h1 id="c297" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">访问节点</h1><p id="fda8" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">让我们看一下AST，以便更好地理解它的结构以及我们将如何遍历它。我们可以使用https://astexplorer.net/的T2来查看作为AST的源的可视化，我们可以打开和关闭不同的节点，并查看不同节点包含的所有不同属性。</p><p id="6e9e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了支持常见的JS require调用，我们需要访问<strong class="ka ir"> CallExpression </strong>节点，因为这个表达式表示函数何时被调用。这方面的一个例子是:</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="6da5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将采用上面的简单示例，并使用AST Explorer将其转换为AST:</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="b8d9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上面的源代码中，我们可以看到一些节点类型，从acorn生成的树将以一个类型为<em class="ma"> Program </em>的根节点和一个节点数组body属性开始。在body属性中，我们将看到所有顶级节点，每个节点都有基于类型的属性，这些属性是所有节点类型中常见的其他节点或属性的混合。例如，所有节点都有属性<strong class="ka ir"> type </strong>(节点类型)、<strong class="ka ir"> start </strong>(源代码中的起始字符位置)和<strong class="ka ir"> end </strong>(源代码的结束字符位置)。任何带有块的节点都将有一个新的节点体，例如if语句或for循环，这些都在一个新的范围内，但是如果需要的话，您需要手动跟踪它。</p><p id="ca47" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上面的例子中，我们可以看到我们从一个<em class="ma">变量声明</em>开始，它包含一个名为declarations的属性，该属性包含一个声明节点数组。每个声明节点包括多个属性，包括引用标识符的<em class="ma"> id </em>和变量声明的初始化器<em class="ma"> init </em>属性，这是变量将初始化的内容。例如:</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="dbf7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">id是<em class="ma">值</em>，初始化器是文字值<em class="ma"> 1 </em>，为了弄清楚所有的节点类型，我们可以看看acorn创建AST所遵循的规范。Acorn遵循estree规范，该规范可在github上查看:<a class="ae kw" href="https://github.com/estree/estree" rel="noopener ugc nofollow" target="_blank">https://github.com/estree/estree</a>。有一个规范与Ecmascript规范的每个版本相匹配，如es5、es2015等，我们可以用它来识别不同的语言结构。</p><p id="13fd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们将开始通过遍历树来访问节点，我们将使用<em class="ma">estr object</em>模块来遍历AST并访问我们需要转换的节点，以便开始安装和要求estr object。</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="a659" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来让我们创建一个名为<em class="ma"> walkAndParse </em>的新函数，它将遍历AST中的所有节点，并允许您有条件地检查每个节点，对每个节点进行操作。estr hore模块为此使用了访问者模式(<a class="ae kw" href="https://en.wikipedia.org/wiki/Visitor_pattern" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Visitor_pattern</a>)，我们可以访问每个节点，并在进入或离开节点时有条件地执行操作。我们将使用estr object<em class="ma">replace</em>函数，因为当我们修改一个节点时，我们希望替换它，并且我们必须在函数结束时返回该节点，如果需要的话，replace还允许我们删除节点。在遍历每个节点时，我们将执行的基本操作是寻找所需的函数调用，然后我们需要解析模块，解析该模块，并将其添加到我们的已解析模块集合中。对于从源文件中解析出来的每个模块，我们需要再次调用<em class="ma"> walkAndParse </em>，利用递归，到结束过程时，我们应该将所有模块捆绑到我们的模块集合中。</p><p id="89a2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我们访问一个节点时，我们将得到一个节点对象，并可以访问节点属性，这些属性可以通过查看estree规范找到。我们调用<code class="fe mv mw mx my b">estraverse.replace</code>并传递AST作为第一个参数和一个带有enter属性的对象，该属性的值是一个函数。enter属性是一个回调函数，在每次进入一个节点时执行，然后节点对象将作为第一个参数传递，我们可以添加一个if语句来检查类型是否为<code class="fe mv mw mx my b">CallExpression</code>。<a class="ae kw" href="https://github.com/estree/estree/blob/master/es5.md#callexpression" rel="noopener ugc nofollow" target="_blank">https://github . com/estree/estree/blob/master/es5 . MD # call expression</a></p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="ca95" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，让我们更新捆绑器以运行walkAndParse函数:</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="d371" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一旦我们输入了一个节点，它是一个调用表达式，我们想要检查这个调用表达式被调用方类型是否是一个标识符，这告诉我们一个命名的函数正在被调用。我们需要检查这是一个命名函数，因为您也可以有一个匿名函数的调用表达式节点，该节点没有作为被调用者的标识符，而是有一个FunctionExpression或ArrowFunctionExpression。如果它是一个函数表达式，那么它不可能调用<em class="ma"> require </em>，因为没有标识符来引用一个已定义的函数。<a class="ae kw" href="https://github.com/estree/estree/blob/master/es5.md#identifier" rel="noopener ugc nofollow" target="_blank">https://github . com/estree/estree/blob/master/es5 . MD #标识符</a></p><p id="86ee" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果被调用者没有这个节点的标识符，那么我们就不尝试解析它，walker仍然会递归地访问它的子节点，因为在树的那个分支的更下面可能需要调用表达式。</p><p id="ef49" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们发现被调用者类型是标识符，那么我们可以检查标识符名称，如果这是<em class="ma"> require </em>，那么我们现在知道我们已经访问了require函数调用。最后一步是检查require调用是否有任何参数，我们需要一个参数，我们希望它是一个字符串。文字是源代码中的静态表达式，它们是代码中定义的静态值，并且是不可变的，它需要是一个文字，因为我们需要一个静态值作为模块路径。有关文字的更多信息，请访问:<a class="ae kw" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Grammar_and_Types#Literals" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/JavaScript/Guide/Grammar _ and _ Types # Literals</a><a class="ae kw" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Grammar_and_Types#String_literals" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/JavaScript/Guide/Grammar _ and _ Types # String _ Literals</a></p><p id="152d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">按如下方式更新<code class="fe mv mw mx my b">walkAndParse</code>功能:</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="072b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们很可能还想在上面的测试中检查文字值是否也是字符串，因为整数和布尔值也是文字，但我们现在跳过这一步。现在，如果我们在终端中使用<code class="fe mv mw mx my b">node src/index.js</code>再次运行代码，我们应该会看到以下内容:</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><h1 id="83c0" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">解析模块</h1><p id="ce11" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">既然已经确定了带有文字表达式参数的require call表达式，就需要进行模块解析，以便找到该模块的正确完整路径。当需要一个模块时，有许多路径可以使用，并且每种路径有不同的使用情况，下面是我们将支持的三种主要路径类型。</p><h2 id="4990" class="mz ky iq bd kz na nb dn ld nc nd dp lh kj ne nf ll kn ng nh lp kr ni nj lt nk bi translated">绝对模块路径</h2><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="c13f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">绝对模块路径允许require函数调用引用文件系统上的任何模块，这是最简单的处理路径，因为完整路径已经为我们定义了。但这也可能是脆弱的，因为这意味着您的代码不再是可移植的，如果它引用了特定用户文件系统上的一个模块，那么对于想要捆绑该项目的其他用户来说，它可能不在那里。</p><h2 id="5bb7" class="mz ky iq bd kz na nb dn ld nc nd dp lh kj ne nf ll kn ng nh lp kr ni nj lt nk bi translated">相对模块路径</h2><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="3e1c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">相对模块路径允许require调用查找与当前模块相关的模块，您可以在当前目录中require，或者使用<code class="fe mv mw mx my b">..</code>上移您想要上移的每个目录。对于需要模块的常见JS模式，不需要文件扩展名，因此对于相对和绝对路径，我们可能需要在模块解析期间添加扩展名。</p><h2 id="bf47" class="mz ky iq bd kz na nb dn ld nc nd dp lh kj ne nf ll kn ng nh lp kr ni nj lt nk bi translated">节点模块路径</h2><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="6192" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">节点模块路径允许require解析通过npm/yarn等安装的模块，所有这些模块都位于node_modules目录中。这是一种极其常见的模式，在所有不同的解析路径中，这是最复杂的。</p><p id="79f8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当解析一个模块时，比如上面的<em class="ma"> react </em>例子，模块解析将需要不同的工作方式。首先，我们需要查看node_modules目录，如果您现在安装了react并查看node_modules目录，您将看到react目录，而不是名为react的文件。另一个例子是在哪里解析一个文件呢这不是节点模块的情况，那么在这个例子中解析器到底在寻找什么呢？</p><p id="5700" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当安装node_module时，也安装了modules package.json，在这个文件中可以有一个对主文件的可选引用，它告诉我们模块的初始文件应该是什么，我们可以解决这个问题。因为这是可选的，所以如果package.json中没有主属性，这种方法的后备方法是寻找一个<em class="ma"> index.js </em>文件，index.js名称是对web服务器如何使用默认的<em class="ma">index.html</em>文件来满足web请求的引用。</p><p id="ac28" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，可以从已安装的节点模块的目录中请求一个文件，例如，如果我们使用lodash，我们可以只请求我们需要的方法。</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="c694" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们在另一个文件中创建解析器，并导出类供捆绑器使用，因此在src目录中创建一个名为<em class="ma"> resolver.js </em>的文件。</p><p id="0ca7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在代码中，我们导出了一个需要根路径的解析器类，每当我们想要解析一个模块时，我们都需要根路径。我们使用path模块来帮助进行路径格式化，使用fs模块来检索关于正在被解析的模块的信息。</p><p id="7ef9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该类有一个名为resolvePath的函数，它有两个参数<code class="fe mv mw mx my b">modulePath</code>和<code class="fe mv mw mx my b">currentPath</code>。<code class="fe mv mw mx my b">modulePath</code>参数是现在正在被解析的模块的路径，而as <code class="fe mv mw mx my b">currentPath</code>参数是调用require函数的模块的路径。</p><p id="1890" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后我们想返回一个具有两个属性<code class="fe mv mw mx my b">fullPath</code>和<code class="fe mv mw mx my b">newResolutionPath</code>的对象。fullPath属性是我们已经解析的路径，newResolutionPath属性是不带模块名的完整路径。如果bundler在我们刚刚解析的模块中发现任何require调用，那么newResolutionPath属性将被用作currentPath参数。</p><p id="3c49" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以让我们补充一下:</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="6693" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我们将为所有不同的可能模块路径添加逻辑，我们将使用if语句来测试不同的路径类型。在我们这样做之前，您可能记得之前您不必在require函数调用中包含文件扩展名，所以我们将创建一个名为<code class="fe mv mw mx my b">modulePathWithExtension</code>的变量，并使用三元运算符有条件地附加一个<code class="fe mv mw mx my b">.js</code>扩展名(如果它丢失的话)。</p><p id="4806" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们检查路径模块是否以<code class="fe mv mw mx my b">./</code>或<code class="fe mv mw mx my b">../</code>开头，如果是，那么我们期望它是一个相对路径，将<code class="fe mv mw mx my b">fullPath</code>设置为当前路径，并附加require参数中的模块路径。接下来，我们将测试它是否以<code class="fe mv mw mx my b">/</code>开头，如果是，那么我们期望它是一个绝对路径，我们只需将<code class="fe mv mw mx my b">fullPath</code>赋值给<code class="fe mv mw mx my b">modulePathWithExtension</code>。</p><p id="7ad3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">节点模块解析稍微复杂一点，require函数调用可能以目录或目录中的文件为目标。因为require函数调用可能没有文件扩展名，所以我们需要检查它是一个目录还是一个包含所需目录的文件。如果它是一个目录，那么我们还必须尝试加载package.json，以便检查是否定义了一个主入口点，如果定义了，我们就使用它，如果没有，我们默认使用<code class="fe mv mw mx my b">index.js</code>。接下来与上面类似，我们将把一个<code class="fe mv mw mx my b">.js</code>附加到<code class="fe mv mw mx my b">nodeModulePath</code>上，作为一个名为<code class="fe mv mw mx my b">nodeModulePathWithExtension</code>的变量，如果它没有，检查它是否是一个有效的文件，如果它被赋值<code class="fe mv mw mx my b">fullPath</code>到<code class="fe mv mw mx my b">nodeModulePathWithExtension</code>。</p><p id="4644" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，<code class="fe mv mw mx my b">newResolutionPath</code>与完整路径相同，但是没有路径的目录名，我们可以通过调用<code class="fe mv mw mx my b">path.dirname</code>函数来实现。</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="62dd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们已经创建了解析器，我们需要创建一个解析器的新实例，并将它传递给<code class="fe mv mw mx my b">walkAndParse</code>函数。按照解析器顶部的要求更新代码:</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="ee93" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，向<code class="fe mv mw mx my b">walkAndParse</code>函数定义添加额外的解析器参数:</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="ab6d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后更新捆绑器:</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="1f03" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">更新<code class="fe mv mw mx my b">walkAndParse</code>功能，删除我们添加的控制台日志，替换为以下内容:</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="b0ab" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我们想尝试读取解析后的文件路径，这样就可以将它捆绑到生成的文件中，这样我们就可以解析这个解析后的模块的常见JS require调用。我们可以通过使用fs模块读取文件来实现这一点，为了简洁起见，我们将同步进行，但也可以将这些调用链接起来，然后异步进行以提高性能。</p><p id="093c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在resolvePath调用后更新代码以添加:</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="f357" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们已经加载了一个新的模块源文件，我们需要能够确保源文件中导出的任何代码都被返回，并由require调用或require调用所分配的任何内容使用。</p><p id="cbc6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">//也许我们会删除该位。我们在这里可能会看到的一种情况是，如果返回的解析路径未定义，原因可能是需要一个本机节点模块，如<code class="fe mv mw mx my b">stream</code>。在这些情况下，你可以使用基于浏览器的实现，比如<a class="ae kw" href="https://github.com/webpack/node-libs-browser" rel="noopener ugc nofollow" target="_blank">https://github.com/webpack/node-libs-browser</a>。</p><h1 id="8eab" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">包装和递归解析</h1><p id="e4c6" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">如果我们查看我们的<code class="fe mv mw mx my b">index.js</code>文件，我们可以看到第一个require调用引用了<code class="fe mv mw mx my b">app.js</code>，<code class="fe mv mw mx my b">app.js</code>文件导出了一个名为<code class="fe mv mw mx my b">helloWorld</code>的函数，在<code class="fe mv mw mx my b">index.js</code>文件中，这个函数被赋给了<code class="fe mv mw mx my b">index.js</code>中的常量变量<code class="fe mv mw mx my b">app</code>。</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="2e0a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，我们希望一旦这些文件被捆绑成一个单独的生成文件，我们将能够执行<code class="fe mv mw mx my b">app</code>变量，这将执行对<code class="fe mv mw mx my b">helloWorld</code>函数的引用。通用JS规范提到我们应该能够引用用<code class="fe mv mw mx my b">module.exports</code>和<code class="fe mv mw mx my b">exports</code>导出的任何值，并且这两者应该能够导出任何原始数据类型。最后，我们希望确保每个模块范围内的所有内容都保持在其范围内，不会泄漏到文件的全局范围内。</p><p id="c9c1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了实现这一点，我们可以借鉴要求模块的NodeJS实现，当一个模块被要求时，它就被包装在一个带有多个参数的函数中，比如exports、module和__dirname。想了解更多信息，你可以去https://nodejs.org/api/modules.html<a class="ae kw" href="https://nodejs.org/api/modules.html" rel="noopener ugc nofollow" target="_blank">看看。</a></p><p id="12f2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们的实现中，我们将把我们的每个源文件包装在一个函数中，该函数被赋予require_HASH_ID的值，其中HASH_ID是源文件的md5散列。在此基础上，我们需要创建一个初始的<code class="fe mv mw mx my b">module</code>变量，该变量引用一个具有<code class="fe mv mw mx my b">exports</code>对象属性和引用<code class="fe mv mw mx my b">module.exports</code>值的<code class="fe mv mw mx my b">exports</code>属性的对象，我们还需要返回<code class="fe mv mw mx my b">module.exports</code>。最后，我们可以用require_HASH_ID值替换原始调用表达式的节点名，这样就完成了对所需文件源的引用。</p><p id="798b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个包装源代码的模板可以作为一个函数添加到我们的index.js文件中，带有如下的<code class="fe mv mw mx my b">source</code>参数:</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="6294" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们有了通用的JS包装器模板，我们可以返回到CallExpression访问者来包装源代码，并继续递归搜索更多需要解析、包装和绑定的require call表达式。让我们更新访问者，以便创建散列id，创建引用当前AST节点、路径、id和已解析模块源的模块对象。我们还将添加对名为exports的属性的引用，这将调用名为<code class="fe mv mw mx my b">wrapSourceAndParse</code>的函数。<code class="fe mv mw mx my b">wrapSourceAndParse</code>函数将解析的模块包装在公共JS包装器中，将源代码转换成AST，然后在这个AST上调用<code class="fe mv mw mx my b">walkAndParse</code>。<code class="fe mv mw mx my b">walkAndParse</code>函数将返回AST作为函数的结束，因此它将被分配给我们已经创建的<code class="fe mv mw mx my b">module</code>对象的<code class="fe mv mw mx my b">exports</code>属性。</p><p id="b51f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我们将把CallExpression从<code class="fe mv mw mx my b">require</code>重命名为require_HASH_ID，如前所述，我们将把我们已经创建的<code class="fe mv mw mx my b">module</code>对象推送到一个全局<code class="fe mv mw mx my b">MODULES</code>对象中，我们将在bundler的顶部定义该对象。稍后我们将迭代<code class="fe mv mw mx my b">MODULES</code>对象来生成我们的最终包。首先，我们需要安装md5库来创建我们的散列，并要求它位于我们的bundler的顶部:</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="0d89" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来更新if语句中的<code class="fe mv mw mx my b">walkAndParse</code>函数，如下所示:</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="4730" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来添加新功能<code class="fe mv mw mx my b">wrapSourceAndParse</code>。</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="aff2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">既然我们能够从初始文件中解析所有模块，并创建一组解析的AST，我们希望能够生成新的捆绑代码，这将在下一节中进行。</p><h1 id="8dc1" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">代码生成</h1><p id="d7af" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">我们已经做了相当多的处理，让我们实际上从我们所有的硬字中生成一些东西，生成的代码实际上将无法执行，我们很快就会看到，很抱歉。但是我们会有<em class="ma">生成的东西</em>，我们可以插入一个小的hack来查看我们的劳动成果，然后立即修复它。</p><p id="7e50" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">生成最终的代码输出非常容易，我们将使用一个名为escodegen的模块，它代表ECMAscript代码生成器，该模块允许您传入一个estree兼容的AST，并将从AST输出源代码。我们将迭代<code class="fe mv mw mx my b">MODULE</code>对象中已解析的模块来生成它们的输出代码，然后我们将生成初始模块代码。最后，我们将把整个事情包装在一个立即调用的函数执行(IIFE)中，这样我们就可以把包中的所有东西都放在全局范围之外，不会意外地污染全局范围内的任何其他代码，也不会污染我们的代码。</p><p id="9807" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先在根目录中安装escodegen，并要求它位于index.js文件的顶部:</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="ee3c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来我们将更新我们的bundler函数，我们将添加一个对名为<code class="fe mv mw mx my b">generateCode</code>的函数的调用，该函数接受我们的<code class="fe mv mw mx my b">parsedIntialAST</code>和<code class="fe mv mw mx my b">MODULES</code>对象。然后一个<code class="fe mv mw mx my b">iifeTemplate</code>函数获取<code class="fe mv mw mx my b">parsedIntialAST</code>调用的结果代码，最后我们用<code class="fe mv mw mx my b">fs</code>模块将结果写到<code class="fe mv mw mx my b">OUT_PATH</code>定义的路径。</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="46ae" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来我们将创建<code class="fe mv mw mx my b">generateCode</code>函数，如前所述，它将迭代ASTs以生成我们的输出文件。我们将使用<code class="fe mv mw mx my b">Object.values</code>遍历模块以生成一个值数组，然后使用map创建一个包含模块导出值的生成的源代码数组。然后我们将使用join创建一个字符串，最后我们需要将<code class="fe mv mw mx my b">init</code>文件转换回源代码，我们将使用多行字符串连接所有代码，init文件放在最后。</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="6dc8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">既然我们已经创建了生成的输出文件，我们希望将它包装在我们前面提到的life中，我们将创建一个模板函数，就像我们对公共JS包装器所做的那样。</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="8726" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们应该能够从终端使用以下命令运行捆绑器:</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="d4ee" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果一切按计划进行，我们应该在我们的根目录下看到一个生成的JS文件。让我们创建一个小的演示html页面来测试我们的包，在根目录下创建一个新文件并添加以下内容。</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="c848" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，如果我们尝试访问该页面，我们将看到实际上没有呈现任何react元素，如果我们检查控制台，我们应该会看到以下堆栈跟踪错误。</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="0bcc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这有点奇怪，原因是许多模块有一个开发和生产版本，将使用当前的过程来尝试只捆绑正确的版本。webpack和rollup等不同的捆绑器支持基于当前的<code class="fe mv mw mx my b">NODE_ENV</code>有条件地要求模块，当前的<code class="fe mv mw mx my b">NODE_ENV</code>在捆绑时被定义为环境变量。以react为例，如果我们查看索引文件，可以看到以下内容:</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="8f85" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在捆绑时，捆绑器将根据定义的环境变量中的<code class="fe mv mw mx my b">NODE_ENV</code>值，寻找react的预编译版本，该版本可以是开发版本，也可以是生产版本。</p><p id="845e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们添加一个快速的hack来运行我们生成的代码，然后我们可以实现条件捆绑。更新<code class="fe mv mw mx my b">iifeTemplate</code>，在生成文件的最顶层添加一个流程对象，该文件包含一个<code class="fe mv mw mx my b">env</code>对象，其<code class="fe mv mw mx my b">NODE_ENV</code>属性设置为<code class="fe mv mw mx my b">development</code>。</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="f5ee" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，如果我们重新加载我们创建的测试页面，我们应该看到react代码已经运行并呈现了一个链接，我们应该看到一堆控制台日志，其中包含我们在开发人员控制台中导出的模块和函数执行的输出。我们的捆扎机工作了！让我们恢复更改，并考虑实现条件捆绑功能。</p><h1 id="adf3" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">使用NODE_ENV的条件捆绑</h1><p id="567e" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">为了支持条件捆绑，我们需要遍历每个AST并处理任何if语句，寻找对<code class="fe mv mw mx my b">process.env.NODE_ENV</code>的引用，并静态地确定if语句中的测试结果是真还是假。为了弄清楚我们需要处理哪种节点属性，我们可以再次查看estree节点的规范<a class="ae kw" href="https://github.com/estree/estree/blob/master/es5.md#ifstatement" rel="noopener ugc nofollow" target="_blank">https://github . com/estree/estree/blob/master/es5 . MD # if statement</a>。由此，我们可以确定存在if语句测试的测试节点、包含一些要执行的代码的后续块语句节点以及可选的替代语句，该替代语句可以是块语句或另一个if语句。对于我们的实现，我们将检查替代语句，但只支持block语句，而不会继续尝试处理任何<code class="fe mv mw mx my b">else if ()</code>语句。</p><p id="6d13" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从测试节点开始，我们需要检查它是否是一个<strong class="ka ir">二进制表达式</strong>，例如<code class="fe mv mw mx my b">1 == 1</code>是一个二进制表达式，如果是这样，它应该有一个左、右和运算符节点，我们可以对其求值。</p><p id="3c67" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我们希望在二进制表达式测试的左侧或右侧找到一个<strong class="ka ir"> MemberExpression </strong>，一个成员表达式意味着我们试图访问一个对象的属性(成员)。访问对象属性有不同的方式，例如使用点符号，如<code class="fe mv mw mx my b">object.property</code>或方括号访问，如<code class="fe mv mw mx my b">object['property']</code>。查看estree规范<a class="ae kw" href="https://github.com/estree/estree/blob/master/es5.md#memberexpression" rel="noopener ugc nofollow" target="_blank">https://github . com/estree/estree/blob/master/es5 . MD # member expression</a>我们可以看到有<code class="fe mv mw mx my b">object</code>和<code class="fe mv mw mx my b">property</code>值，我们可以使用它们来确定测试是否在检查<code class="fe mv mw mx my b">process.env.NODE_ENV</code>。<code class="fe mv mw mx my b">object</code>值指的是被访问的对象，而<code class="fe mv mw mx my b">property</code>指的是该对象中的属性，这在表面上很简单。这些值的计算顺序有点混乱，当访问两层深度的属性时，会有嵌套的成员表达式。嵌套从右到左工作，因此顶级成员表达式实际上会将<code class="fe mv mw mx my b">property</code>引用到所引用的最终属性，并且递归<code class="fe mv mw mx my b">object</code>值将向后工作到起始对象。例如，使用<code class="fe mv mw mx my b">process.env.NODE_ENV</code>，节点看起来像:</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="ab89" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从节点的JSON表示中可以看出，第一个属性值是<code class="fe mv mw mx my b">NODE_ENV</code>而不是<code class="fe mv mw mx my b">process</code>,<code class="fe mv mw mx my b">process</code>引用实际上位于对象值中的下一个MemberExpression节点中。让我们将所有这些检查放在一起作为代码，这样我们最终会得到一些功能，这些功能可以确定我们是否在if语句中有一个测试，该测试根据文字值评估<code class="fe mv mw mx my b">NODE_ENV</code>环境变量，并将其添加到<code class="fe mv mw mx my b">walkAndParse</code>函数中。在<code class="fe mv mw mx my b">if (node.type === 'CallExpression') {...}</code>块后添加以下内容:</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="e9b4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上面的代码中，每个代码注释都有一些注释，因为它有点复杂，我们检查它是否是BinaryExpression，然后检查测试值是MemberExpression和Literal。然后我们检查MemberExpression是否引用了当前进程的环境变量，并查看了环境变量<code class="fe mv mw mx my b">NODE_ENV</code>。如果我们进行到这一步而没有返回，那么我们想要运行If语句测试，假设我们在这一点上实际上没有源代码，我们需要重建if语句测试并调用它。我们可以使用函数类<a class="ae kw" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/JavaScript/Reference/Global _ Objects/Function</a>来实现这一点，在运行时创建一个函数，该函数构造一个将评估并返回测试值的函数，然后我们可以运行它并将其分配给一个变量进行检查。在NODE_ENV检查之后，添加以下内容:</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="d673" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们有了一个结果，我们希望用应该在那里的代码块替换整个if语句，例如，假设NODE_ENV是development，我们会得到如下结果:</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="983d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们还希望在代码单元周围保留花括号(BlockStatement ),以便维护范围，因为花括号中的每个代码块都有自己的词法范围。因此，为了完成我们正在寻找的功能，我们希望检查测试的结果，如果它评估为真，我们希望保留随之而来的check语句。如果测试为假，并且有一个替换的block语句，那么我们希望保留这个block语句，如果没有替换的，那么我们删除整个节点。</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="f221" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们现在准备再次运行我们的bundler，我们需要设置一个<code class="fe mv mw mx my b">NODE_ENV</code>环境变量，因为现在我们不回退到默认值。所以运行下面的代码:</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="aa8c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，如果您打开我们之前创建的html文件，您应该看到react组件与多个控制台日志一起呈现。如果你有react开发工具扩展，你也应该看到<em class="ma">这个页面使用React的开发版本。</em>点击图标时。</p><p id="f8c8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，让我们尝试使用以下命令捆绑生产版本:</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="38ec" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们仍然会看到与之前相同的功能，但单击react dev tools图标会显示出<em class="ma">该页面正在使用react的生产版本。</em>，您还应该看到包大小减少了几百千字节。对于奖励积分，您还可以在生产模式下缩小，以进一步减少您的包大小。</p><p id="1eef" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这就是我们的bundler工作，有很多改进可以做，所以请随意尝试和实施，其中包括:</p><ul class=""><li id="2ef0" class="mb mc iq ka b kb kc kf kg kj md kn me kr mf kv mg mh mi mj bi translated">将捆绑器封装到类中</li><li id="922d" class="mb mc iq ka b kb mk kf ml kj mm kn mn kr mo kv mg mh mi mj bi translated">使用图形数据结构来跟踪依赖性</li><li id="b6c3" class="mb mc iq ka b kb mk kf ml kj mm kn mn kr mo kv mg mh mi mj bi translated">代码分割</li><li id="dcb2" class="mb mc iq ka b kb mk kf ml kj mm kn mn kr mo kv mg mh mi mj bi translated">esmodule支持</li><li id="7ae7" class="mb mc iq ka b kb mk kf ml kj mm kn mn kr mo kv mg mh mi mj bi translated">替换同步调用模块可以并行解析</li></ul><p id="73b3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一些参考资料:</p><p id="d26e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kw" href="https://www.ecma-international.org/ecma-262/" rel="noopener ugc nofollow" target="_blank">https://www.ecma-international.org/ecma-262/</a><a class="ae kw" href="https://nodejs.org/docs/latest/api/modules.html#modules_the_module_object" rel="noopener ugc nofollow" target="_blank">https://nodejs . org/docs/latest/API/modules . html # modules _ the _ module _ object</a><a class="ae kw" href="https://github.com/webpack/docs/wiki/commonjs" rel="noopener ugc nofollow" target="_blank">https://github.com/webpack/docs/wiki/commonjs</a><a class="ae kw" href="https://stackoverflow.com/questions/16383795/difference-between-module-exports-and-exports-in-the-commonjs-module-system" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/16383795/difference-between-module-exports-and-exports-in-the-the-common js-module-system</a></p></div><div class="ab cl nl nm hu nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="ij ik il im in"><p id="160d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="ma">最初发表于</em><a class="ae kw" href="https://gist.github.com/jackpopp/054d4d64b3281feb3e31570e9e6dda5f" rel="noopener ugc nofollow" target="_blank"><em class="ma">gist.github.com</em></a><em class="ma">。</em></p></div></div>    
</body>
</html>