<html>
<head>
<title>Write custom Android/Kotlin linting rules like a Psi-chic!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">像写Psi-chic一样写自定义的Android/Kotlin林挺规则！</h1>
<blockquote>原文：<a href="https://itnext.io/write-custom-android-kotlin-linting-rules-like-a-psi-chic-e081e032da2f?source=collection_archive---------4-----------------------#2021-02-27">https://itnext.io/write-custom-android-kotlin-linting-rules-like-a-psi-chic-e081e032da2f?source=collection_archive---------4-----------------------#2021-02-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/fe562becebfc8fecf84eaa03db0763aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aZ6Tk_LPHp9jLDirRxUf9Q.jpeg"/></div></div></figure><div class=""/><div class=""><h2 id="f279" class="pw-subtitle-paragraph jy ja jb bd b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp dk translated">利用Ktlint &amp; PsiViewer增强您团队的林挺工作流程。</h2></div><h1 id="327b" class="kq kr jb bd ks kt ku kv kw kx ky kz la kh lb ki lc kk ld kl le kn lf ko lg lh bi translated">目录</h1><p id="112d" class="pw-post-body-paragraph li lj jb lk b ll lm kc ln lo lp kf lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">∘ <a class="ae me" href="#918d" rel="noopener ugc nofollow">前言</a>T2】∘<a class="ae me" href="#4ec1" rel="noopener ugc nofollow">鸡，还是蛋？</a> <br/> ∘ <a class="ae me" href="#6dbb" rel="noopener ugc nofollow">潜入母体</a><br/>∘<a class="ae me" href="#2134" rel="noopener ugc nofollow">get psi-ched</a><br/><a class="ae me" href="#f972" rel="noopener ugc nofollow">psi-viewer</a><br/><a class="ae me" href="#d936" rel="noopener ugc nofollow">好玩的部分(实现)</a> <br/> ∘ <a class="ae me" href="#96a5" rel="noopener ugc nofollow">等一下</a> <br/> ∘ <a class="ae me" href="#608f" rel="noopener ugc nofollow">预设置</a> <br/> ∘ <a class="ae me" href="#93bb" rel="noopener ugc nofollow">设置</a> <br/> <a class="ae me" href="#73a2" rel="noopener ugc nofollow">好东西</a> <br/> <a class="ae me" href="#3592" rel="noopener ugc nofollow">包装</a></p><h2 id="918d" class="mf kr jb bd ks mg mh dn kw mi mj dp la lr mk ml lc lv mm mn le lz mo mp lg mq bi translated">前言</h2><p id="ac0e" class="pw-post-body-paragraph li lj jb lk b ll lm kc ln lo lp kf lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">在我的<a class="ae me" href="https://medium.com/@jasondhl/ktlint-git-hooked-on-it-48f4e08d1c8b" rel="noopener">上一篇文章</a>中，我谈到了如何利用git钩子和Ktlint的力量来为您的团队的林挺工作流带来健康。在本文中，我将向您展示如何通过利用Ktlint中的自定义规则集来改进这一点。是啊！自定义林挺规则！</p></div><div class="ab cl mr ms hu mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ij ik il im in"><h2 id="4ec1" class="mf kr jb bd ks mg mh dn kw mi mj dp la lr mk ml lc lv mm mn le lz mo mp lg mq bi translated">鸡肉，还是鸡蛋？</h2><p id="cab0" class="pw-post-body-paragraph li lj jb lk b ll lm kc ln lo lp kf lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">在我搜索如何使用自定义林挺规则的过程中，我看到了不少文章，讨论如何反复编写或多或少相同的林挺规则。</p><p id="d982" class="pw-post-body-paragraph li lj jb lk b ll my kc ln lo mz kf lq lr na lt lu lv nb lx ly lz nc mb mc md ij bi translated">现在，可以说我不擅长谷歌搜索，但真正让我头疼的是，在每篇文章的结尾，我仍然不知道如何开始编写自定义规则。</p><p id="72f8" class="pw-post-body-paragraph li lj jb lk b ll my kc ln lo mz kf lq lr na lt lu lv nb lx ly lz nc mb mc md ij bi translated">好吧，酷，我写了我的第一个“没有内部导入”规则，太好了。但是我如何使用这些知识来编写其他规则呢？首先，linter怎么知道它在看什么，我怎么知道要<em class="nd">告诉它</em>去寻找我想要它检查的东西？当我甚至不知道它是如何构造的时候，我怎么能写规则呢？</p><p id="537a" class="pw-post-body-paragraph li lj jb lk b ll my kc ln lo mz kf lq lr na lt lu lv nb lx ly lz nc mb mc md ij bi translated">为此，我们需要理解代码实际上是如何编写的。</p><h2 id="6dbb" class="mf kr jb bd ks mg mh dn kw mi mj dp la lr mk ml lc lv mm mn le lz mo mp lg mq bi translated">潜入母体</h2><p id="194b" class="pw-post-body-paragraph li lj jb lk b ll lm kc ln lo lp kf lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">我们生活在一个非凡的时代，我们拥有先进的ide，能够动态地执行代码分析，并对我们遗漏分号或编写真正多余的表达式大喊大叫，代码编译需要几分钟甚至几秒钟(如果在过去我是多么粗心，我会浪费无数的时间和打卡)。</p><p id="f525" class="pw-post-body-paragraph li lj jb lk b ll my kc ln lo mz kf lq lr na lt lu lv nb lx ly lz nc mb mc md ij bi translated">我们的编程语言随着我们的工具一起进化，但是就像人类语言中的语法一样，无论是旧的还是新的编程语言都有一个基本的结构。</p><p id="d15d" class="pw-post-body-paragraph li lj jb lk b ll my kc ln lo mz kf lq lr na lt lu lv nb lx ly lz nc mb mc md ij bi translated">这种语法结构就是像Android Studio这样的IDE如何知道你在函数闭包的开始错过了一个空格。特别是在Android Studio和Kotlin/Java的环境中，JetBrains开发了一个<em class="nd">“解释器”</em>来查看代码如何编写的模式，这个“解释器”被称为<strong class="lk jc"> UAS(通用抽象语法树)</strong>。</p><p id="9e0d" class="pw-post-body-paragraph li lj jb lk b ll my kc ln lo mz kf lq lr na lt lu lv nb lx ly lz nc mb mc md ij bi translated">我不会假装理解它是如何工作的，相反，我将在本文末尾链接参考资料，但您应该知道的是，这使得使用工具来识别常见的代码结构成为可能。这个工具是一个名为<a class="ae me" href="https://plugins.jetbrains.com/plugin/227-psiviewer" rel="noopener ugc nofollow" target="_blank"> PsiViewer </a>的插件。</p><h2 id="2134" class="mf kr jb bd ks mg mh dn kw mi mj dp la lr mk ml lc lv mm mn le lz mo mp lg mq bi translated">获得Psi-che</h2><p id="7e3e" class="pw-post-body-paragraph li lj jb lk b ll lm kc ln lo lp kf lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated"><strong class="lk jc"> PSI </strong></p><p id="360f" class="pw-post-body-paragraph li lj jb lk b ll my kc ln lo mz kf lq lr na lt lu lv nb lx ly lz nc mb mc md ij bi translated">PsiViewer 只是一个方便的图形用户界面插件，让浏览这个界面结构不那么痛苦。不依赖于外部插件，还有其他方法可以查看树结构，但是输出将在终端中打印出来，我将向您展示为什么这是一个等待的坏时机。</p><p id="6cb7" class="pw-post-body-paragraph li lj jb lk b ll my kc ln lo mz kf lq lr na lt lu lv nb lx ly lz nc mb mc md ij bi translated">当我第一次发现这个工具并理解它时，这是一个令人兴奋的发现(请注意，我仍然不理解它的大部分)，就像《黑客帝国》中的山谬·里维一样，我能够看到世界是如何形成的。</p><p id="5afe" class="pw-post-body-paragraph li lj jb lk b ll my kc ln lo mz kf lq lr na lt lu lv nb lx ly lz nc mb mc md ij bi translated">那么，让我停止我的漫谈，让我们看看工具本身，好吗？</p></div><div class="ab cl mr ms hu mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ij ik il im in"><h1 id="f972" class="kq kr jb bd ks kt ne kv kw kx nf kz la kh ng ki lc kk nh kl le kn ni ko lg lh bi translated">Psi查看器</h1><blockquote class="nj nk nl"><p id="d994" class="li lj nd lk b ll my kc ln lo mz kf lq nm na lt lu nn nb lx ly no nc mb mc md ij bi translated">没有人能被告知矩阵是什么，你必须自己去看。</p></blockquote><p id="60c8" class="pw-post-body-paragraph li lj jb lk b ll my kc ln lo mz kf lq lr na lt lu lv nb lx ly lz nc mb mc md ij bi translated">为了更清楚地说明如何使用这个插件，让我用两张图片来说明我的观点:</p><figure class="nq nr ns nt gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi np"><img src="../Images/34b239b2e0955ba4a4f13a09de7167ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uylHyN4Pw-Y6aQwnhGP_Gw.png"/></div></div><figcaption class="nu nv gj gh gi nw nx bd b be z dk translated">图片A</figcaption></figure><figure class="nq nr ns nt gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ny"><img src="../Images/2c005c73b5e97135769f97eb39213117.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mwNSwahjD5tRIXiuzZoJlQ.png"/></div></div><figcaption class="nu nv gj gh gi nw nx bd b be z dk translated">图片B</figcaption></figure><p id="536d" class="pw-post-body-paragraph li lj jb lk b ll my kc ln lo mz kf lq lr na lt lu lv nb lx ly lz nc mb mc md ij bi translated">位于Android Studio右侧面板的Psi查看器的视觉层次结构:</p><ol class=""><li id="fbef" class="nz oa jb lk b ll my lo mz lr ob lv oc lz od md oe of og oh bi translated">右上角的面板代表了这个文件的PSI结构，我将它命名为“SomeRandomClass”。</li><li id="0b27" class="nz oa jb lk b ll oi lo oj lr ok lv ol lz om md oe of og oh bi translated">右下方的面板是<em class="nd">的详细分解，只是代码中突出显示的部分，</em>即<code class="fe on oo op oq b">class</code>关键字。</li></ol><p id="1af1" class="pw-post-body-paragraph li lj jb lk b ll my kc ln lo mz kf lq lr na lt lu lv nb lx ly lz nc mb mc md ij bi translated">因此，在<strong class="lk jc">图像A </strong>中，我的光标高亮显示/悬停在<code class="fe on oo op oq b">class</code>上，正如你所看到的，在右侧的Psi-Viewer面板中有很多单词，但是，我们最关心的是在右下方的面板中，在<code class="fe on oo op oq b">Property</code>列下，有一个名为<code class="fe on oo op oq b">elementType</code>的字段。对于<strong class="lk jc">图片A，</strong>高亮显示为<code class="fe on oo op oq b">class</code>，其中，我们<em class="nd">终究是</em>高亮显示一个类关键字声明。</p><p id="3493" class="pw-post-body-paragraph li lj jb lk b ll my kc ln lo mz kf lq lr na lt lu lv nb lx ly lz nc mb mc md ij bi translated">更有趣的是，当我们查看<strong class="lk jc">图像B </strong>时，当我们高亮显示<code class="fe on oo op oq b">TODO</code>注释时，它会告诉我们<code class="fe on oo op oq b">elementType</code>是一个<code class="fe on oo op oq b">EOL_COMMENT</code>。这向我们展示了代码如何构造的完整蓝图，以及我们如何识别代码的类型，就像我们识别枚举一样。</p><p id="df00" class="pw-post-body-paragraph li lj jb lk b ll my kc ln lo mz kf lq lr na lt lu lv nb lx ly lz nc mb mc md ij bi translated">“所以呢？这对我们有什么帮助？搞什么杰森，这什么也没告诉我们😖”，嗯，我认为这是文章中我们应该用代码油脂弄脏手的部分。</p><h1 id="d936" class="kq kr jb bd ks kt ku kv kw kx ky kz la kh lb ki lc kk ld kl le kn lf ko lg lh bi translated">有趣的部分(实现)</h1><h2 id="96a5" class="mf kr jb bd ks mg mh dn kw mi mj dp la lr mk ml lc lv mm mn le lz mo mp lg mq bi translated">等一下</h2><p id="edc9" class="pw-post-body-paragraph li lj jb lk b ll lm kc ln lo lp kf lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">这里的假设是，你已经有一个Android项目启动并运行，带有主<code class="fe on oo op oq b">app</code>模块，以及2个<code class="fe on oo op oq b">build.gradle</code>文件；一个用于<code class="fe on oo op oq b">app</code>模块，另一个用于整个项目本身。</p><p id="1d1d" class="pw-post-body-paragraph li lj jb lk b ll my kc ln lo mz kf lq lr na lt lu lv nb lx ly lz nc mb mc md ij bi translated">此外，我是从Mac用户的角度来写这篇文章的，同时也是在一个正在进行的项目中实现的，所以你的收获可能会有所不同。</p><h2 id="608f" class="mf kr jb bd ks mg mh dn kw mi mj dp la lr mk ml lc lv mm mn le lz mo mp lg mq bi translated">预设置</h2><p id="681c" class="pw-post-body-paragraph li lj jb lk b ll lm kc ln lo lp kf lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">下载Android Studio插件<a class="ae me" href="https://plugins.jetbrains.com/plugin/227-psiviewer" rel="noopener ugc nofollow" target="_blank"> PsiViewer </a>来辅助查看代码的结构。如果你不确定如何在Android Studio中下载插件，只需在mac上按下<code class="fe on oo op oq b">CMD + SHIFT + A</code>(或者在Windows上按下<code class="fe on oo op oq b">CTRL + SHIFT + A</code>即可打开全局动作搜索栏，输入“<strong class="lk jc">插件</strong>”，然后在市场中搜索。</p><h2 id="93bb" class="mf kr jb bd ks mg mh dn kw mi mj dp la lr mk ml lc lv mm mn le lz mo mp lg mq bi translated">设置</h2><p id="cb9b" class="pw-post-body-paragraph li lj jb lk b ll lm kc ln lo lp kf lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">首先，我们需要将Ktlint作为我们的主要林挺引擎(PsiViewer也可以应用于其他林挺机制，但是在本文中，我们只关注Ktlint)</p><ul class=""><li id="206e" class="nz oa jb lk b ll my lo mz lr ob lv oc lz od md or of og oh bi translated">在你的项目根文件夹中创建一个单独的模块(它应该和你的<code class="fe on oo op oq b">app</code>模块在同一层，你可以随意命名。我给我的取名<code class="fe on oo op oq b">custom-ktlint-rules</code></li><li id="b8c4" class="nz oa jb lk b ll oi lo oj lr ok lv ol lz om md or of og oh bi translated">将这个新模块中的<code class="fe on oo op oq b">build.gradle</code>文件配置如下(这对于确保我们使用的是<code class="fe on oo op oq b">ktlint</code>的pinterest版本非常重要)</li></ul><pre class="nq nr ns nt gt os oq ot ou aw ov bi"><span id="c3cd" class="mf kr jb oq b gy ow ox l oy oz">plugins {<br/>    id "kotlin"<br/>    id "java-library"<br/>    id "maven"<br/>}</span><span id="476e" class="mf kr jb oq b gy pa ox l oy oz">dependencies {<br/>    implementation "org.jetbrains.kotlin:kotlin-stdlib:<!-- -->0.33.0<!-- -->"<br/>    compileOnly "com.pinterest.ktlint:ktlint-core:<!-- -->0.33.0<!-- -->"</span><span id="b25b" class="mf kr jb oq b gy pa ox l oy oz">    testImplementation "junit:junit:4.12"<br/>    testImplementation "org.assertj:assertj-core:3.12.2"<br/>    testImplementation "com.pinterest.ktlint:ktlint-core:<!-- -->0.33.0<!-- -->"<br/>    testImplementation "com.pinterest.ktlint:ktlint-test:<!-- -->0.33.0<!-- -->"<br/>}</span><span id="2b09" class="mf kr jb oq b gy pa ox l oy oz">compileKotlin {<br/>    kotlinOptions.jvmTarget = "1.8"<br/>}<br/>compileTestKotlin {<br/>    kotlinOptions.jvmTarget = "1.8"<br/>}</span></pre><p id="8b90" class="pw-post-body-paragraph li lj jb lk b ll my kc ln lo mz kf lq lr na lt lu lv nb lx ly lz nc mb mc md ij bi translated"><em class="nd">需要注意的是，在撰写本文时，这是最新的依赖版本，根据版本的不同，可能会有不兼容的问题，所以请记住这一点，以防出现错误。</em></p><ul class=""><li id="b001" class="nz oa jb lk b ll my lo mz lr ob lv oc lz od md or of og oh bi translated">接下来，在定制模块(我们刚刚创建的<code class="fe on oo op oq b">custom-ktlint-rules</code>模块)中，创建两个分别扩展<code class="fe on oo op oq b">RuleSetProvider</code>和<code class="fe on oo op oq b">Rule</code>的类。您应该会得到类似这样的结果(暂时忽略编译错误，我们一会儿就会看到):</li></ul><div class="nq nr ns nt gt ab cb"><figure class="pb is pc pd pe pf pg paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><img src="../Images/7a1812d7053feee11bd01248264761dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:786/format:webp/1*AF2ZLhfkmn-K5G7tYmK1Ag.png"/></div></figure><figure class="pb is ph pd pe pf pg paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><img src="../Images/d584d97b4ccb71f7b692fb94c04049ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:632/format:webp/1*u9Cv94e_rxjZt2RRfcudQA.png"/></div></figure><figure class="pb is pi pd pe pf pg paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><img src="../Images/48c6a7f95b3520bfba189fd2edc26225.png" data-original-src="https://miro.medium.com/v2/resize:fit:586/format:webp/1*2APj_bV-SYe5uG24YJyXyg.png"/></div><figcaption class="nu nv gj gh gi nw nx bd b be z dk pj di pk pl translated">第三张图片是此时你的模块目录应该是什么样子。</figcaption></figure></div><ul class=""><li id="c326" class="nz oa jb lk b ll my lo mz lr ob lv oc lz od md or of og oh bi translated">接下来，在自定义模块的<code class="fe on oo op oq b">src-&gt;main</code>目录下创建一个文件夹，命名为<code class="fe on oo op oq b">resources/META-INF/services</code>，在这个目录下，新建一个名为<code class="fe on oo op oq b">com.pinterest.ktlint.core.RuleSetProvider</code>的文件。现在，在<em class="nd">这个</em>文件中，您需要引用您的自定义<code class="fe on oo op oq b">RuleSetProvider</code>类，在本例中，是我们刚刚在上面创建的<code class="fe on oo op oq b">CustomRuleSetProvider</code>类。</li></ul><div class="nq nr ns nt gt ab cb"><figure class="pb is pm pd pe pf pg paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><img src="../Images/4b2199d989b07fec682c93390641791e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1694/format:webp/1*AwFBBqRJyefGcgRqNSGwNQ.png"/></div></figure><figure class="pb is pn pd pe pf pg paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><img src="../Images/a89d15a888ce46e6805128400c8625d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:308/format:webp/1*w0DpJK6AdD_dYK78CFf58w.png"/></div></figure></div><ul class=""><li id="33b1" class="nz oa jb lk b ll my lo mz lr ob lv oc lz od md or of og oh bi translated">最后，回到你的<code class="fe on oo op oq b">app</code>模块的<code class="fe on oo op oq b">build.gradle</code>，确保你在<code class="fe on oo op oq b">dependencies</code>下包含了<code class="fe on oo op oq b">ktlintRuleset project(‘:custom-ktlint-rules’)</code></li><li id="90ee" class="nz oa jb lk b ll oi lo oj lr ok lv ol lz om md or of og oh bi translated">这就是完成的设置过程！</li></ul><p id="1831" class="pw-post-body-paragraph li lj jb lk b ll my kc ln lo mz kf lq lr na lt lu lv nb lx ly lz nc mb mc md ij bi translated"><em class="nd">还要注意，您可能需要将</em> e <code class="fe on oo op oq b">classpath("org.jlleitschuh.gradle:ktlint-gradle:9.3.0)</code> <em class="nd">包含到您的</em><strong class="lk jc">root</strong><code class="fe on oo op oq b"><strong class="lk jc">build.gradle</strong></code><strong class="lk jc"/>的<code class="fe on oo op oq b">dependencies</code> <em class="nd">块中，因为可能会出现一些编译错误，我还没有找到根本原因。它本质上与之前的</em> Pinterest <em class="nd">依赖项相同，只是一个故障安全实现。</em></p><h1 id="73a2" class="kq kr jb bd ks kt ku kv kw kx ky kz la kh lb ki lc kk ld kl le kn lf ko lg lh bi translated">好东西</h1><p id="ba42" class="pw-post-body-paragraph li lj jb lk b ll lm kc ln lo lp kf lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">好的，谢谢你一直坐着，这很重要，相信我，我知道。但我发誓现在事情会变得更有意义。*咳嗽*好，下一个:</p><ul class=""><li id="73a9" class="nz oa jb lk b ll my lo mz lr ob lv oc lz od md or of og oh bi translated">回到我们之前刚刚编写的<code class="fe on oo op oq b">CustomRuleSetProvider</code>类，复制并粘贴以下代码:</li></ul><pre class="nq nr ns nt gt os oq ot ou aw ov bi"><span id="8de2" class="mf kr jb oq b gy ow ox l oy oz">class CustomRuleSetProvider : RuleSetProvider {<br/>    override fun get() = RuleSet(<br/>        "custom-rule-set",<br/>        TodoCommentRule(),<br/>    )<br/>}</span></pre><p id="5bb7" class="pw-post-body-paragraph li lj jb lk b ll my kc ln lo mz kf lq lr na lt lu lv nb lx ly lz nc mb mc md ij bi translated">所以这实际上是用id<code class="fe on oo op oq b">custom-rule-set</code>(或者你想叫它什么)声明这个新的规则集，并且声明你想要的定制规则。在这种情况下，是我们的<code class="fe on oo op oq b">TodoCommentRule</code>！</p><p id="a566" class="pw-post-body-paragraph li lj jb lk b ll my kc ln lo mz kf lq lr na lt lu lv nb lx ly lz nc mb mc md ij bi translated">现在，我将把整个代码实现粘贴到这里:</p><pre class="nq nr ns nt gt os oq ot ou aw ov bi"><span id="4210" class="mf kr jb oq b gy ow ox l oy oz">class TodoCommentRule : Rule("todo-comment") {<br/>    override fun visit(<br/>        node: ASTNode,<br/>        autoCorrect: Boolean,<br/>        emit: (<br/>            offset: Int,<br/>            errorMessage: String,<br/>            canBeAutoCorrected: Boolean<br/>        ) -&gt; Unit<br/>    ) {<br/>        if (node.<em class="nd">elementType </em>== <em class="nd">EOL_COMMENT</em>) {<br/>            val commentText = node.<em class="nd">text<br/>            </em>if (commentText.<em class="nd">contains</em>("TODO")) {<br/>                val keywordIndex = commentText.<em class="nd">indexOf</em>("TODO")<br/><br/>                if (keywordIndex &gt; 0) {<br/>                    val keywordCountOffset = keywordIndex + "TODO".length<br/>                    val noColonAfter = commentText[keywordCountOffset].toString() != ":"<br/><br/>                    if (noColonAfter) {<br/>                        emit(<br/>                            node.<em class="nd">startOffset</em>,<br/>                            "TODO should have a ':' immediately after",<br/>                            true<br/>                        )<br/>                    }<br/>                }<br/>            }<br/>        }<br/>    }<br/>}</span></pre><p id="003b" class="pw-post-body-paragraph li lj jb lk b ll my kc ln lo mz kf lq lr na lt lu lv nb lx ly lz nc mb mc md ij bi translated">是的，一整块格式不佳的代码(感谢Medium)，但是，唯一重要的是:</p><ul class=""><li id="6a70" class="nz oa jb lk b ll my lo mz lr ob lv oc lz od md or of og oh bi translated"><code class="fe on oo op oq b">todo-comment</code>的<code class="fe on oo op oq b">id</code>被传递到<code class="fe on oo op oq b">Rule</code>的构造函数中以唯一标识该规则。</li><li id="62ed" class="nz oa jb lk b ll oi lo oj lr ok lv ol lz om md or of og oh bi translated">覆盖<code class="fe on oo op oq b">visit</code>方法，以便linter知道基于您的定制实现应该注意什么。</li></ul><p id="a18c" class="pw-post-body-paragraph li lj jb lk b ll my kc ln lo mz kf lq lr na lt lu lv nb lx ly lz nc mb mc md ij bi translated">还记得我不久前发布的<strong class="lk jc">图片A </strong>和<strong class="lk jc">图片B </strong>吗？看到熟悉的东西了吗？是的，那个<code class="fe on oo op oq b">EOL_COMMENT</code>。</p><p id="ef5b" class="pw-post-body-paragraph li lj jb lk b ll my kc ln lo mz kf lq lr na lt lu lv nb lx ly lz nc mb mc md ij bi translated">对于你们当中更有眼力的人来说，你们可能已经意识到这个定制规则是一个用来过滤代码注释中的违规的规则，特别是对于TODOs。更具体地说，它检查在<code class="fe on oo op oq b">:</code>符号后面是否有空格，这意味着像<code class="fe on oo op oq b">TODO:no space after the colon lollll</code>这样的注释在这个规则下会失败，但是<code class="fe on oo op oq b">TODO: This is fine</code>会飞起来。</p><p id="2356" class="pw-post-body-paragraph li lj jb lk b ll my kc ln lo mz kf lq lr na lt lu lv nb lx ly lz nc mb mc md ij bi translated">现在，我知道，我知道，检查违规的算法写得很糟糕，不能检查过多的情况，但是，我只是希望当时有一些工作，所以，放我一马？是的，我知道，这不是最性感的习俗，就像，我已经可以听到人们说“真的吗？所有这一切都是为了TODO后面的一个微不足道的间距？”，但是，在我的辩护中，这篇文章是关于如何编写自定义规则，而不是如何编写<em class="nd">伟大的</em>自定义规则。我相信你能比我做得更好😉</p><p id="2568" class="pw-post-body-paragraph li lj jb lk b ll my kc ln lo mz kf lq lr na lt lu lv nb lx ly lz nc mb mc md ij bi translated">总之，因为Psi-Viewer已经帮助我们识别了特定代码块的类型，所以我们可以通过被覆盖的<code class="fe on oo op oq b">visit</code>方法的<code class="fe on oo op oq b">node.elementType</code>来定位该类型的代码，并通过<code class="fe on oo op oq b">emit(node.<em class="nd">startOffset</em>, “TODO should have a ‘:’ immediately after”, true)</code>向我的不知情的同事发出一个错误</p><p id="3e47" class="pw-post-body-paragraph li lj jb lk b ll my kc ln lo mz kf lq lr na lt lu lv nb lx ly lz nc mb mc md ij bi translated">在我的例子中，我甚至编写了一个快速的方法来修复这个违规，如下图所示:</p><figure class="nq nr ns nt gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi po"><img src="../Images/cfc2a3b7eb09aff111856132b10720a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dUl8MZgG9QvnLgFsSq4ooQ.png"/></div></div></figure><h1 id="3592" class="kq kr jb bd ks kt ku kv kw kx ky kz la kh lb ki lc kk ld kl le kn lf ko lg lh bi translated">包裹</h1><p id="b642" class="pw-post-body-paragraph li lj jb lk b ll lm kc ln lo lp kf lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">我知道这是一篇相当长的文章，在这方面还有很多东西需要探索。但是，如果你设法坚持到现在，并且你感觉到了我发现如何做到这一点时的那种眩晕感，那么也许这是值得的。</p><p id="f566" class="pw-post-body-paragraph li lj jb lk b ll my kc ln lo mz kf lq lr na lt lu lv nb lx ly lz nc mb mc md ij bi translated">我并不天真，我知道考虑到潜在的回报，一个团队将时间投入到像定制林挺规则这样的小众事物上可能是不值得的。但是，如果你的团队的PR注释被关于风格选择的注释所困扰，或者，甚至更多的功能情况，比如“如果在一个片段中有一个<code class="fe on oo op oq b">RecyclerView</code>，类名应该有一个‘listing’后缀”，这可能是你的团队技术堆栈中的一个银弹。</p><p id="a962" class="pw-post-body-paragraph li lj jb lk b ll my kc ln lo mz kf lq lr na lt lu lv nb lx ly lz nc mb mc md ij bi translated">毕竟，自动化在前期几乎是不值得的，但是从长期来看，它将确保所做的决策比开发团队的租约更长久。母体终究是永恒的。</p><p id="5bcb" class="pw-post-body-paragraph li lj jb lk b ll my kc ln lo mz kf lq lr na lt lu lv nb lx ly lz nc mb mc md ij bi translated">如果你想看看我以前的一篇文章，其中我谈到了利用git挂钩来改进你的团队的林挺工作流，<a class="ae me" href="https://medium.com/@jasondhl/ktlint-git-hooked-on-it-48f4e08d1c8b" rel="noopener">请点击这里</a>！</p><p id="04df" class="pw-post-body-paragraph li lj jb lk b ll my kc ln lo mz kf lq lr na lt lu lv nb lx ly lz nc mb mc md ij bi translated">否则，请在twitter上关注我，了解我对技术、发展和生活思考的更多想法:)</p><h2 id="60f6" class="mf kr jb bd ks mg mh dn kw mi mj dp la lr mk ml lc lv mm mn le lz mo mp lg mq bi translated">参考</h2><ol class=""><li id="a057" class="nz oa jb lk b ll lm lo lp lr pp lv pq lz pr md oe of og oh bi translated"><a class="ae me" href="https://www.kotlindevelopment.com/formatting-code-analysis-rule-with-android-lint/" rel="noopener ugc nofollow" target="_blank"> Psi查看器和自定义林挺规则</a>(强烈推荐阅读)</li><li id="cdf4" class="nz oa jb lk b ll oi lo oj lr ok lv ol lz om md oe of og oh bi translated"><a class="ae me" href="https://www.glureau.com/2020/05/26/Ktlint-Moshi-Introduction/" rel="noopener ugc nofollow" target="_blank">用魔石自定义Ktlint规则</a></li><li id="c0d6" class="nz oa jb lk b ll oi lo oj lr ok lv ol lz om md oe of og oh bi translated"><a class="ae me" href="https://medium.com/@vanniktech/writing-your-first-ktlint-rule-5a1707f4ca5b" rel="noopener">编写你的第一个ktlint规则</a></li></ol></div></div>    
</body>
</html>