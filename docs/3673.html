<html>
<head>
<title>Patterns For Testable React Components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">可测试React组件的模式</h1>
<blockquote>原文：<a href="https://itnext.io/patterns-for-testable-react-components-26705a17810d?source=collection_archive---------3-----------------------#2020-01-28">https://itnext.io/patterns-for-testable-react-components-26705a17810d?source=collection_archive---------3-----------------------#2020-01-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/23ec49ef7c78361568b2c821dc8cc215.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lDQbBnMgte7iB7NsJfxHew.png"/></div></div></figure><p id="9569" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">想象一下当<code class="fe kz la lb lc b">prop</code>中的<code class="fe kz la lb lc b">name</code>的值为<code class="fe kz la lb lc b">James</code>时，<code class="fe kz la lb lc b">HelloName</code>下面呈现Hello James的组件。因为<code class="fe kz la lb lc b">name</code>值不归<code class="fe kz la lb lc b">HelloName</code>所有，所以它被称为<code class="fe kz la lb lc b">WithName</code>的装饰器高阶组件传递给它。这在使用还没有使用React的上下文API的库时很常见。</p><figure class="ld le lf lg gt ju"><div class="bz fp l di"><div class="lh li l"/></div></figure><p id="27c1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">而名字装饰者是这样的。</p><figure class="ld le lf lg gt ju"><div class="bz fp l di"><div class="lh li l"/></div></figure><p id="b58e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">上面的<code class="fe kz la lb lc b">HelloName</code>和<code class="fe kz la lb lc b">WithName</code>的关系很常见，因为在Reactjs中用来实现很多事情。如果您使用过Redux，这是很熟悉的，因为您将总是使用这种关系将组件绑定到全局状态。</p><p id="1d42" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了测试上面的<code class="fe kz la lb lc b">HelloName</code>，测试看起来就像只是渲染它。</p><figure class="ld le lf lg gt ju"><div class="bz fp l di"><div class="lh li l"/></div></figure><p id="c8ec" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe kz la lb lc b">Now the problem is:</code> -测试的目标是给组件随机的可能状态和道具，并检查组件是否工作。假设您不拥有<code class="fe kz la lb lc b">WithName</code>组件(这很常见)。这意味着您不容易访问<code class="fe kz la lb lc b">name</code>变量来操作它来测试不同的场景。当在<code class="fe kz la lb lc b">HelloName</code>中使用该值进行一些计算以产生结果而不仅仅是呈现Hello {name}时，这甚至变得更加必要。例如，我们需要测试它是否可以在另一个场景中说你好詹姆斯和你好迈克。</p><p id="878f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe kz la lb lc b">The solution:</code> -这个问题的解决方案非常简单。让我们看看。首先要做的就是导出未修饰的<code class="fe kz la lb lc b">HelloName</code>组件，并将修饰后的版本作为默认版本。</p><figure class="ld le lf lg gt ju"><div class="bz fp l di"><div class="lh li l"/></div></figure><p id="71e3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在测试中，测试修饰过的版本，然后根据需要测试未修饰的版本。</p><figure class="ld le lf lg gt ju"><div class="bz fp l di"><div class="lh li l"/></div></figure><p id="f60c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当我负责测试一个与<a class="ae lj" href="https://redux.js.org/" rel="noopener ugc nofollow" target="_blank"> Redux </a>和<a class="ae lj" href="https://redux-form.com/8.2.2/" rel="noopener ugc nofollow" target="_blank"> Redux Form </a>高度集成的react应用程序时，这种模式帮我省了不少事。</p><h1 id="8e1c" class="lk ll it bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">测试组件动作</h1><p id="1188" class="pw-post-body-paragraph kb kc it kd b ke mi kg kh ki mj kk kl km mk ko kp kq ml ks kt ku mm kw kx ky im bi translated">另一种模式是测试组件内发生的动作。考虑一个组件<code class="fe kz la lb lc b">Form</code>，它呈现一个HTML表单，表单中有一个值<code class="fe kz la lb lc b">name</code>的输入绑定到一个状态变量<code class="fe kz la lb lc b">name</code>。该表单有一个按钮，该按钮有一个绑定到被执行函数的<code class="fe kz la lb lc b">onClick</code>事件。</p><figure class="ld le lf lg gt ju"><div class="bz fp l di"><div class="lh li l"/></div></figure><p id="40eb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在我们需要测试在渲染时，当一些文本被输入到输入域中，然后点击按钮，函数<code class="fe kz la lb lc b">handleSubmit</code>被调用一次。</p><p id="4535" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe kz la lb lc b">The problem:</code> - handleSubmit在表单组件中定义，因此不可访问。为了使其可测试，从props组件中移除handleSubmit函数。</p><figure class="ld le lf lg gt ju"><div class="bz fp l di"><div class="lh li l"/></div></figure><p id="47fe" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了测试这个组件，我们现在只需用一个模拟代替道具中的<code class="fe kz la lb lc b">handleSubmit</code>。看见...</p><figure class="ld le lf lg gt ju"><div class="bz fp l di"><div class="lh li l"/></div></figure><p id="2953" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是一种将外部动作从组件移除到props的方式，提供了操纵组件以更好地测试用户在与组件交互时将触发的动作的能力。</p><h1 id="63ec" class="lk ll it bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">具有复杂状态版本的组件。</h1><p id="12c4" class="pw-post-body-paragraph kb kc it kd b ke mi kg kh ki mj kk kl km mk ko kp kq ml ks kt ku mm kw kx ky im bi translated">假设您有以下组件。依赖于<code class="fe kz la lb lc b">localStorage</code>中变量<code class="fe kz la lb lc b">user_id</code>的轮廓组件因此具有这些状态。</p><ul class=""><li id="1e32" class="mn mo it kd b ke kf ki kj km mp kq mq ku mr ky ms mt mu mv bi translated"><code class="fe kz la lb lc b">localStorage</code>中没有<code class="fe kz la lb lc b">user_id</code>时显示登录页面。</li><li id="fb14" class="mn mo it kd b ke mw ki mx km my kq mz ku na ky ms mt mu mv bi translated">仅在用户登录时显示</li><li id="9263" class="mn mo it kd b ke mw ki mx km my kq mz ku na ky ms mt mu mv bi translated">如果<code class="fe kz la lb lc b">localStorage</code>中的<code class="fe kz la lb lc b">user_id</code>不是<code class="fe kz la lb lc b">profile</code>中的<code class="fe kz la lb lc b">user_id</code>，则显示跟随按钮</li><li id="d8e6" class="mn mo it kd b ke mw ki mx km my kq mz ku na ky ms mt mu mv bi translated">如果<code class="fe kz la lb lc b">localStorage</code>中的<code class="fe kz la lb lc b">user_id</code>与<code class="fe kz la lb lc b">profile</code>中的<code class="fe kz la lb lc b">user_id</code>相同，则显示编辑按钮</li></ul><figure class="ld le lf lg gt ju"><div class="bz fp l di"><div class="lh li l"/></div></figure><p id="d901" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">注意，这只是一个例子。不要使用localStorage来表示登录或未登录。我通常不认为这是最好的方法，尽管它很有效而且超级简单。</p><p id="602a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，为了测试上面的组件，我们首先必须确保用于呈现组件的数据从组件中很好地抽象出来，以便操作组件变得容易。</p><p id="96d9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先，有一个数据所有者组件，一个除了使数据可用之外副作用最小的组件。可能根本不渲染。在Redux中，这将是一个reducer和一个带有一些HOC的provider，或者它们在MobX或Flux中被称为什么。</p><p id="c4f3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在我的示例解决方案中，我使用了React上下文向组件提供数据。我有ProfileDataContext/Provider。</p><figure class="ld le lf lg gt ju"><div class="bz fp l di"><div class="lh li l"/></div></figure><p id="fe74" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">组件现在看起来像这样。</p><figure class="ld le lf lg gt ju"><div class="bz fp l di"><div class="lh li l"/></div></figure><p id="9b8a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，在我的测试中，我可以使用原始组件，并把我自己的数据和boom提供给它！我现在可以测试尽可能多的场景，不管概要文件数据有多复杂，渲染有多复杂，甚至是<code class="fe kz la lb lc b">Profile</code>组件中的子组件。请看我如何测试代表组件版本的四种不同状态。</p><figure class="ld le lf lg gt ju"><div class="bz fp l di"><div class="lh li l"/></div></figure><p id="4a87" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这些方法使得测试组件变得非常容易。这里的要点是:</p><ul class=""><li id="dfd7" class="mn mo it kd b ke kf ki kj km mp kq mq ku mr ky ms mt mu mv bi translated">尽可能制造纯组件。</li><li id="b88b" class="mn mo it kd b ke mw ki mx km my kq mz ku na ky ms mt mu mv bi translated">组件的副作用越少，就越容易精确测试。</li><li id="7cdc" class="mn mo it kd b ke mw ki mx km my kq mz ku na ky ms mt mu mv bi translated">将组件动作抽象为你可以轻易模仿的纯父动作。</li><li id="6bc2" class="mn mo it kd b ke mw ki mx km my kq mz ku na ky ms mt mu mv bi translated">尽可能抽象数据。</li></ul><p id="86c4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">希望这对你有所帮助！如果是这样的话，只要在GitHub和T2推特上关注我，那将会有很大的帮助。全部代码也在<a class="ae lj" href="https://github.com/zemuldo/reactjs-testing-patterns" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上😄</p><p id="45a8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">干杯！</p></div></div>    
</body>
</html>