<html>
<head>
<title>Kubernetes: ClusterIP vs NodePort vs LoadBalancer, Services, and Ingress — an overview with examples</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes:集群IP与节点端口与负载平衡器、服务和入口—示例概述</h1>
<blockquote>原文：<a href="https://itnext.io/kubernetes-clusterip-vs-nodeport-vs-loadbalancer-services-and-ingress-an-overview-with-722a07f3cfe1?source=collection_archive---------1-----------------------#2020-06-24">https://itnext.io/kubernetes-clusterip-vs-nodeport-vs-loadbalancer-services-and-ingress-an-overview-with-722a07f3cfe1?source=collection_archive---------1-----------------------#2020-06-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/68df703b7f84ae512a4984ab18a19d44.png" data-original-src="https://miro.medium.com/v2/resize:fit:260/format:webp/0*rOAsSyIH1hNiQOQr.png"/></div></figure><p id="1c82" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">对于网络通信，Kubernetes提供了四种服务类型— <code class="fe ks kt ku kv b">ClusterIP</code>(默认)、<code class="fe ks kt ku kv b">NodePort</code>、<code class="fe ks kt ku kv b">LoadBalancer</code>和<code class="fe ks kt ku kv b">ExternalName</code>，以及<code class="fe ks kt ku kv b">Ingress</code>资源。</p><p id="24e5" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在这篇文章中，我们将对它们进行一个简短的概述，并检查它们是如何工作的。</p><p id="859a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">文档可在此处获得— <a class="ae kw" href="https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types" rel="noopener ugc nofollow" target="_blank">发布服务(服务类型)</a>。</p><p id="cbed" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我使用的是AWS Elastic Kubernetes服务，所以请记住，我们有AWS虚拟私有云以及AWS应用程序负载平衡器。</p><h1 id="c499" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">网络和Kubernetes</h1><p id="1439" class="pw-post-body-paragraph ju jv iq jw b jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ij bi translated">在Kubernetes集群中，您可能需要使用以下网络场景:</p><ul class=""><li id="735b" class="ma mb iq jw b jx jy kb kc kf mc kj md kn me kr mf mg mh mi bi translated">容器之间的直接通信—由<em class="mj"> Pod </em>抽象提供，容器通过同一Pod内的本地主机相互访问—参见<a class="ae kw" href="https://kubernetes.io/docs/concepts/workloads/pods/pod/" rel="noopener ugc nofollow" target="_blank">Pod</a></li><li id="3ee4" class="ma mb iq jw b jx mk kb ml kf mm kj mn kn mo kr mf mg mh mi bi translated">集群范围内Pod之间的通信——由网络插件提供，对于AWS EKS，参见<a class="ae kw" href="https://kubernetes.io/docs/concepts/cluster-administration/networking/#aws-vpc-cni-for-kubernetes" rel="noopener ugc nofollow" target="_blank">用于Kubernetes的AWS VPC CNI</a></li><li id="91ca" class="ma mb iq jw b jx mk kb ml kf mm kj mn kn mo kr mf mg mh mi bi translated">从Pod到服务的连接—由服务抽象提供，例如— <code class="fe ks kt ku kv b">ClusterIP</code></li><li id="308d" class="ma mb iq jw b jx mk kb ml kf mm kj mn kn mo kr mf mg mh mi bi translated">从世界到集群中的pod的连接—由服务抽象提供，使用外部资源，例如— AWS负载平衡器</li></ul><p id="0f55" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">Kubernetes中服务的主要目标是提供对其pod的持久访问，而不必在每次重新创建这样的Pod时都寻找Pod的IP。</p><p id="b725" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">此外，服务可以在相似的pod之间提供最小的负载平衡，参见<a class="ae kw" href="https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies" rel="noopener ugc nofollow" target="_blank">服务</a>。</p><h1 id="85ac" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">准备</h1><p id="3f72" class="pw-post-body-paragraph ju jv iq jw b jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ij bi translated">为了进行测试，让我们使用一个带有NGINX web服务器的pod创建一个部署，该部署将接受到其端口80的连接:</p><pre class="mp mq mr ms gt mt kv mu mv aw mw bi"><span id="37e2" class="mx ky iq kv b gy my mz l na nb">$ kubectl create deployment nginx --image=nginx<br/>deployment.apps/nginx created</span></pre><p id="f24f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">检查:</p><pre class="mp mq mr ms gt mt kv mu mv aw mw bi"><span id="609a" class="mx ky iq kv b gy my mz l na nb">$ kk get deploy nginx<br/>NAME READY UP-TO-DATE AVAILABLE AGE<br/>nginx 1/1 1 1 53s</span></pre><p id="aa93" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">因为服务将根据标签来查找pod，所以让我们检查一下此部署有哪些标签:</p><pre class="mp mq mr ms gt mt kv mu mv aw mw bi"><span id="780c" class="mx ky iq kv b gy my mz l na nb">$ kubectl get deploy nginx -o jsonpath=’{.metadata.labels}’<br/>map[app:nginx]</span></pre><p id="60b7" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">好的——这是带有<em class="mj"> nginx </em>值的<em class="mj"> app </em>标签——记住它。</p><h2 id="a9d1" class="mx ky iq bd kz nc nd dn ld ne nf dp lh kf ng nh ll kj ni nj lp kn nk nl lt nm bi translated"><code class="fe ks kt ku kv b">kubectl port-forward</code></h2><p id="3cf1" class="pw-post-body-paragraph ju jv iq jw b jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ij bi translated">为了确保我们的pod启动并运行，并且能够处理到端口80的传入连接，让我们使用<code class="fe ks kt ku kv b"><a class="ae kw" href="https://kubernetes.io/docs/tasks/access-application-cluster/port-forward-access-application-cluster/" rel="noopener ugc nofollow" target="_blank">kubectl port-forward</a></code>。在我们检查它是否工作之后——我们可以从Kubernetes集群端开始使用网络设置。</p><p id="a3f6" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">找到pod的名称:</p><pre class="mp mq mr ms gt mt kv mu mv aw mw bi"><span id="2a69" class="mx ky iq kv b gy my mz l na nb">$ kubectl get pod<br/>NAME READY STATUS RESTARTS AGE<br/>nginx-554b9c67f9-rwbp7 1/1 Running 0 40m</span></pre><p id="46e3" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">将其作为第一个参数传递给<code class="fe ks kt ku kv b">kubectl port-forward</code>，然后指定一个本地端口(<em class="mj"> 8080 </em>)和pod上的端口(<em class="mj"> 80 </em>):</p><pre class="mp mq mr ms gt mt kv mu mv aw mw bi"><span id="38b1" class="mx ky iq kv b gy my mz l na nb">$ kubectl port-forward nginx-554b9c67f9-rwbp7 8080:80<br/>Forwarding from [::1]:8080 -&gt; 80</span></pre><p id="e9d4" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">从本地机器检查到Kubernetes集群中NGINX pod的连接:</p><pre class="mp mq mr ms gt mt kv mu mv aw mw bi"><span id="e20b" class="mx ky iq kv b gy my mz l na nb">$ curl localhost:8080<br/>&lt;!DOCTYPE html&gt;<br/>&lt;html&gt;<br/>&lt;head&gt;<br/>&lt;title&gt;Welcome to nginx!&lt;/title&gt;<br/>…</span></pre><p id="825c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">酷—“管用！”，我们有一个工作舱，现在我们可以用它来为我们的服务。</p><h1 id="b1f0" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">Kubernetes服务类型—概述</h1><p id="3fa5" class="pw-post-body-paragraph ju jv iq jw b jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ij bi translated">让我们简要概述一下每种类型，然后从示例开始:</p><ol class=""><li id="67eb" class="ma mb iq jw b jx jy kb kc kf mc kj md kn me kr nn mg mh mi bi translated"><code class="fe ks kt ku kv b"><strong class="jw ir">ClusterIP</strong></code>:默认类型，将从集群的池中创建一个具有IP地址的服务资源，这样的服务将只在集群内部可用(或使用<code class="fe ks kt ku kv b"><a class="ae kw" href="https://rtfm.co.ua/?p=24328kubectl_proxy" rel="noopener ugc nofollow" target="_blank">kube-proxy</a></code></li><li id="fc71" class="ma mb iq jw b jx mk kb ml kf mm kj mn kn mo kr nn mg mh mi bi translated"><code class="fe ks kt ku kv b"><strong class="jw ir">NodePort</strong></code>:将在每个worker node e eс2上打开一个TCP端口，“在它后面”将自动创建一个<code class="fe ks kt ku kv b">ClusterIP</code>服务，并将流量从ес2上的这个TCP端口路由到这个<code class="fe ks kt ku kv b">ClusterIP</code>——这样的服务将可以从全世界(显然，如果EC2有公共IP)或在VPC内访问</li><li id="1dd6" class="ma mb iq jw b jx mk kb ml kf mm kj mn kn mo kr nn mg mh mi bi translated"><code class="fe ks kt ku kv b"><strong class="jw ir">LoadBalancer</strong></code>:将创建一个外部负载平衡器(AWS Classic LB)，“在其后面”将自动创建一个<code class="fe ks kt ku kv b">NodePort</code>，然后是<code class="fe ks kt ku kv b">ClusterIP</code>，并以这种方式将流量从负载平衡器路由到集群中的一个单元</li><li id="b023" class="ma mb iq jw b jx mk kb ml kf mm kj mn kn mo kr nn mg mh mi bi translated"><code class="fe ks kt ku kv b"><strong class="jw ir">ExternalName</strong></code>:类似DNS-proxy的东西-响应这样的服务将返回一个通过CNAME获取的记录，该记录在<code class="fe ks kt ku kv b">externalName</code>中指定</li></ol><h2 id="f7a8" class="mx ky iq bd kz nc nd dn ld ne nf dp lh kf ng nh ll kj ni nj lp kn nk nl lt nm bi translated">ClusterIP</h2><p id="a3f1" class="pw-post-body-paragraph ju jv iq jw b jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ij bi translated">最简单的类型，默认的那种。</p><p id="270b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">将开放对群集中应用程序的访问，而不允许外界访问。</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="np nq di nr bf ns"><div class="gh gi no"><img src="../Images/c5ec176412ada44ad116d9e9a84ad0c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*68-S52P8DTX4i-8D.png"/></div></div></figure><p id="b7c9" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">例如，可以使用它来访问缓存服务，使名称空间中的所有pod都可以访问该服务。</p><p id="7860" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">让我们使用下一个Kubernetes清单:</p><pre class="mp mq mr ms gt mt kv mu mv aw mw bi"><span id="4108" class="mx ky iq kv b gy my mz l na nb">---<br/>apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: "nginx-service"<br/>  namespace: "default"<br/>spec:<br/>  ports:<br/>    - port: 80<br/>  type: ClusterIP<br/>  selector:<br/>    app: "nginx"</span></pre><p id="d1f3" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">创建服务:</p><pre class="mp mq mr ms gt mt kv mu mv aw mw bi"><span id="5924" class="mx ky iq kv b gy my mz l na nb">$ kubectl apply -f nginx-svc.yaml<br/>service/nginx-service created</span></pre><p id="20ea" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">检查一下:</p><pre class="mp mq mr ms gt mt kv mu mv aw mw bi"><span id="43bd" class="mx ky iq kv b gy my mz l na nb">$ kk get svc nginx-service<br/>NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE<br/>nginx-service ClusterIP 172.20.54.138 &lt;none&gt; 80/TCP 38s</span></pre><h2 id="d698" class="mx ky iq bd kz nc nd dn ld ne nf dp lh kf ng nh ll kj ni nj lp kn nk nl lt nm bi translated"><code class="fe ks kt ku kv b">kubectl proxy</code>和服务域名系统</h2><p id="e5a7" class="pw-post-body-paragraph ju jv iq jw b jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ij bi translated">因为<code class="fe ks kt ku kv b">ClusterIP</code>服务类型只能从集群中访问——我们可以使用<code class="fe ks kt ku kv b"><a class="ae kw" href="https://kubernetes.io/docs/tasks/access-kubernetes-api/http-proxy-access-api/#using-kubectl-to-start-a-proxy-server" rel="noopener ugc nofollow" target="_blank">kubectl proxy</a></code>来测试它——这将打开一个到API服务器的本地TCP端口，然后我们可以使用它来访问我们的NGINX。</p><p id="0326" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">启动代理:</p><pre class="mp mq mr ms gt mt kv mu mv aw mw bi"><span id="f1d7" class="mx ky iq kv b gy my mz l na nb">$ kubectl proxy --port=8080<br/>Starting to serve on 127.0.0.1:8080</span></pre><p id="1187" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在，知道了我们的服务名——我们在<code class="fe ks kt ku kv b">metadata: name</code>中设置它——我们可以打开到<em class="mj"> localhost:8080 </em>的连接，然后通过名称空间名称连接到服务本身:</p><pre class="mp mq mr ms gt mt kv mu mv aw mw bi"><span id="1a13" class="mx ky iq kv b gy my mz l na nb">$ curl -L localhost:8080/api/v1/namespaces/default/services/nginx-service/proxy<br/>&lt;!DOCTYPE html&gt;<br/>&lt;html&gt;<br/>&lt;head&gt;<br/>&lt;title&gt;Welcome to nginx!&lt;/title&gt;<br/>…</span></pre><p id="9c85" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">或者只是可以获得关于服务的信息:</p><pre class="mp mq mr ms gt mt kv mu mv aw mw bi"><span id="2e56" class="mx ky iq kv b gy my mz l na nb">$ curl -L localhost:8080/api/v1/namespaces/default/services/nginx-service/<br/>{<br/>“kind”: “Service”,<br/>“apiVersion”: “v1”,<br/>“metadata”: {<br/>“name”: “nginx-service”,<br/>“namespace”: “default”,<br/>“selfLink”: “/api/v1/namespaces/default/services/nginx-service”,</span></pre><p id="293e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi">…</p><p id="45f2" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">所以，<code class="fe ks kt ku kv b">ClusterIP</code>:</p><ul class=""><li id="180c" class="ma mb iq jw b jx jy kb kc kf mc kj md kn me kr mf mg mh mi bi translated">将提供对Kubernetes集群中的应用程序的访问，但不从外部访问</li><li id="8c55" class="ma mb iq jw b jx mk kb ml kf mm kj mn kn mo kr mf mg mh mi bi translated">将使用集群IP池中的IP，并可通过集群范围内的DNS名称进行访问，请参见<a class="ae kw" href="https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/" rel="noopener ugc nofollow" target="_blank">服务和pod的DNS</a></li></ul><h2 id="4d5a" class="mx ky iq bd kz nc nd dn ld ne nf dp lh kf ng nh ll kj ni nj lp kn nk nl lt nm bi translated"><code class="fe ks kt ku kv b">NodePort</code></h2><p id="c0ac" class="pw-post-body-paragraph ju jv iq jw b jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ij bi translated">现在，让我们仔细看看<code class="fe ks kt ku kv b">NodePort</code>服务类型。</p><p id="cf17" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">使用这种类型，Kubernetes将在每个WorkerNode上打开一个TCP端口，然后通过在所有节点上工作的<code class="fe ks kt ku kv b"><a class="ae kw" href="https://kubernetes.io/docs/reference/command-line-tools-reference/kube-proxy/" rel="noopener ugc nofollow" target="_blank">kube-proxy</a></code>将请求从这个TCP端口代理到这个节点上的一个pod。</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="np nq di nr bf ns"><div class="gh gi nt"><img src="../Images/b5d263aa1a59fa1fa8b0c898fd5cc496.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*IsJBAmsgHRYLy75e.png"/></div></div></figure><p id="e53c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">更新我们的清单:</p><pre class="mp mq mr ms gt mt kv mu mv aw mw bi"><span id="8a72" class="mx ky iq kv b gy my mz l na nb">---<br/>apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: "nginx-service"<br/>  namespace: "default"<br/>spec:<br/>  ports:<br/>    - port: 80<br/>      nodePort: 30001<br/>  type: NodePort<br/>  selector:<br/>    app: "nginx"</span></pre><p id="e4d3" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这里的<code class="fe ks kt ku kv b">nodePort</code>参数是可选的，这里添加只是为了举例。如果没有它，Kubernetes将从30000-32767端口范围内分配一个端口。</p><p id="c08d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">更新服务:</p><pre class="mp mq mr ms gt mt kv mu mv aw mw bi"><span id="d622" class="mx ky iq kv b gy my mz l na nb">$ kubectl apply -f nginx-svc.yaml<br/>service/nginx-service configured</span></pre><p id="025c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">检查一下:</p><pre class="mp mq mr ms gt mt kv mu mv aw mw bi"><span id="2474" class="mx ky iq kv b gy my mz l na nb">$ kubectl get svc nginx-service<br/>NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE<br/>nginx-service NodePort 172.20.54.138 &lt;none&gt; 80:30001/TCP 20h</span></pre><p id="45b5" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">并检查EC2实例上的端口:</p><pre class="mp mq mr ms gt mt kv mu mv aw mw bi"><span id="7a43" class="mx ky iq kv b gy my mz l na nb">[root@ip-10–3–49–200 ec2-user]# netstat -anp | grep 30001<br/>tcp6 0 0 :::30001 :::* LISTEN 5332/kube-proxy</span></pre><p id="d641" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">显然，如果WorkerNodes被放在私有子网中，并且它们不能从外部访问——这样的服务就不能用于从网络外部访问应用程序。</p><p id="7d44" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">不过，您仍然可以从同一个网络访问NGINX应用程序，例如从Bastion-host:</p><pre class="mp mq mr ms gt mt kv mu mv aw mw bi"><span id="e10c" class="mx ky iq kv b gy my mz l na nb">[ec2-user@ip-10–3–49–200 ~]$ curl 10.3.49.200:30001<br/>&lt;!DOCTYPE html&gt;<br/>&lt;html&gt;<br/>&lt;head&gt;<br/>&lt;title&gt;Welcome to nginx!&lt;/title&gt;<br/>…</span></pre><p id="acaf" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">所以，<code class="fe ks kt ku kv b">NodePort</code>式为:</p><ul class=""><li id="67b2" class="ma mb iq jw b jx jy kb kc kf mc kj md kn me kr mf mg mh mi bi translated">绑定到一个特定的宿主，比如ес2</li><li id="381c" class="ma mb iq jw b jx mk kb ml kf mm kj mn kn mo kr mf mg mh mi bi translated">如果主机在世界上不可用，那么这样的服务将不会提供对pod的外部访问</li><li id="2694" class="ma mb iq jw b jx mk kb ml kf mm kj mn kn mo kr mf mg mh mi bi translated">将使用提供商池中的IP，例如AWS VPC CIDR</li><li id="15ca" class="ma mb iq jw b jx mk kb ml kf mm kj mn kn mo kr mf mg mh mi bi translated">将仅在同一工作节点上提供对pod的访问</li></ul><h2 id="9ca5" class="mx ky iq bd kz nc nd dn ld ne nf dp lh kf ng nh ll kj ni nj lp kn nk nl lt nm bi translated"><code class="fe ks kt ku kv b">LoadBalancer</code></h2><p id="a7e8" class="pw-post-body-paragraph ju jv iq jw b jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ij bi translated">最常用的服务类型。</p><p id="6ca3" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">对于AWS —将创建一个AWS负载平衡器，默认情况下为经典类型，它会将流量代理到与此负载平衡器关联的TargetGroup的所有ес2实例，然后通过<code class="fe ks kt ku kv b">NodePort</code>服务代理到所有pod。</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="np nq di nr bf ns"><div class="gh gi nu"><img src="../Images/89f69c817bd34ea042051097dd2e4fa8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*lIyakXiVy9PXDgBY.png"/></div></div></figure><p id="1e87" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在这样的负载平衡器上，您可以<a class="ae kw" href="https://kubernetes.io/docs/concepts/services-networking/service/#ssl-support-on-aws" rel="noopener ugc nofollow" target="_blank">使用TLS </a>，可以使用各种负载平衡器类型——内部/外部，等等，请参见<a class="ae kw" href="https://kubernetes.io/docs/concepts/services-networking/service/#other-elb-annotations" rel="noopener ugc nofollow" target="_blank">其他ELB注释</a>。</p><p id="f1cd" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">更新清单:</p><pre class="mp mq mr ms gt mt kv mu mv aw mw bi"><span id="02a7" class="mx ky iq kv b gy my mz l na nb">---<br/>apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: "nginx-service"<br/>  namespace: "default"<br/>spec:<br/>  ports:<br/>    - port: 80<br/>  type: LoadBalancer<br/>  selector:<br/>    app: "nginx"</span></pre><p id="6c59" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">应用它:</p><pre class="mp mq mr ms gt mt kv mu mv aw mw bi"><span id="bad8" class="mx ky iq kv b gy my mz l na nb">$ kubectl apply -f nginx-svc.yaml<br/>service/nginx-service configured</span></pre><p id="b55c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">检查:</p><pre class="mp mq mr ms gt mt kv mu mv aw mw bi"><span id="10ab" class="mx ky iq kv b gy my mz l na nb">$ kubectl get svc nginx-service<br/>NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE<br/>nginx-service LoadBalancer 172.20.54.138 ac8415de24f6c4db9b5019f789792e45–443260761.us-east-2.elb.amazonaws.com 80:30968/TCP 21h</span></pre><p id="4b48" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">请稍等几分钟，您的DSN将会更新，并检查所创建的平衡器的URL:</p><pre class="mp mq mr ms gt mt kv mu mv aw mw bi"><span id="288f" class="mx ky iq kv b gy my mz l na nb">$ curl ac8415de24f6c4db9b5019f789792e45–443260761.us-east-2.elb.amazonaws.com<br/>&lt;!DOCTYPE html&gt;<br/>&lt;html&gt;]<br/>&lt;head&gt;<br/>&lt;title&gt;Welcome to nginx!&lt;/title&gt;<br/>…</span></pre><p id="9282" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">使用这种类型不能使用主机或基于路径的路由，请参见<a class="ae kw" href="https://cloudacademy.com/blog/application-load-balancer-vs-classic-load-balancer/" rel="noopener ugc nofollow" target="_blank">应用负载平衡器与传统负载平衡器</a>。</p><p id="1659" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">实际上，为了在AWS <strong class="jw ir">应用</strong>负载均衡器上拥有所有的可能性，我们可以使用另一种服务类型— <code class="fe ks kt ku kv b">Ingress</code>，我将在这篇文章的<a class="ae kw" href="https://rtfm.co.ua/kubernetes-clusterip-vs-nodeport-vs-loadbalancer-services-i-ingress-obzor-primery/#Ingress" rel="noopener ugc nofollow" target="_blank">入口</a>部分简要介绍它。</p><p id="70dc" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">所以，<code class="fe ks kt ku kv b">LoadBalancer</code>服务类型:</p><ul class=""><li id="c5dd" class="ma mb iq jw b jx jy kb kc kf mc kj md kn me kr mf mg mh mi bi translated">将提供外部进入吊舱的通道</li><li id="6047" class="ma mb iq jw b jx mk kb ml kf mm kj mn kn mo kr mf mg mh mi bi translated">将为不同EC2上的pod提供基本的负载平衡</li><li id="e7b1" class="ma mb iq jw b jx mk kb ml kf mm kj mn kn mo kr mf mg mh mi bi translated">将提供终止SSL/TLS会话的能力</li><li id="9559" class="ma mb iq jw b jx mk kb ml kf mm kj mn kn mo kr mf mg mh mi bi translated">不支持7级路由</li></ul><h2 id="2c24" class="mx ky iq bd kz nc nd dn ld ne nf dp lh kf ng nh ll kj ni nj lp kn nk nl lt nm bi translated"><code class="fe ks kt ku kv b">ExternalName</code></h2><p id="95db" class="pw-post-body-paragraph ju jv iq jw b jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ij bi translated">另一种服务类型是<code class="fe ks kt ku kv b">ExternalName</code>，它会将请求重定向到其<code class="fe ks kt ku kv b">externalName</code>参数中指定的域:</p><pre class="mp mq mr ms gt mt kv mu mv aw mw bi"><span id="46f8" class="mx ky iq kv b gy my mz l na nb">---<br/>apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: "google-service"<br/>  namespace: "default"<br/>spec:<br/>  ports:<br/>    - port: 80<br/>  type: ExternalName<br/>  externalName: google.com</span></pre><p id="b566" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">创建它:</p><pre class="mp mq mr ms gt mt kv mu mv aw mw bi"><span id="0cb3" class="mx ky iq kv b gy my mz l na nb">$ kubectl apply -f nginx-svc.yaml<br/>service/google-service created</span></pre><p id="6a24" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">检查服务:</p><pre class="mp mq mr ms gt mt kv mu mv aw mw bi"><span id="052a" class="mx ky iq kv b gy my mz l na nb">$ kubectl get svc google-service<br/>NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE<br/>google-service ExternalName &lt;none&gt; google.com 80/TCP 33s</span></pre><p id="b87e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">并检查它是如何工作的——转到NGINX pod并使用<code class="fe ks kt ku kv b">dig</code>实用程序来检查DNS记录:</p><pre class="mp mq mr ms gt mt kv mu mv aw mw bi"><span id="a3cf" class="mx ky iq kv b gy my mz l na nb">root@nginx-554b9c67f9-rwbp7:/# dig google-service.default.svc.cluster.local +short<br/>google.com.<br/>172.217.8.206</span></pre><p id="208c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在这里，我们请求一个本地DNS名称为<em class="mj"> google-servic </em> e，它被解析为在<code class="fe ks kt ku kv b">externalName</code>中设置的<em class="mj">google.com</em>域的一个IP。</p><h1 id="a072" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated"><code class="fe ks kt ku kv b">Ingress</code></h1><p id="69ed" class="pw-post-body-paragraph ju jv iq jw b jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ij bi translated">实际上，<code class="fe ks kt ku kv b">Ingress</code>并不是一个专用的服务——它只是描述了Kubernetes入口控制器创建负载平衡器的一组规则，它的监听器和路由规则。</p><p id="9849" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这里的文献资料是<a class="ae kw" href="https://kubernetes.io/docs/concepts/services-networking/ingress/" rel="noopener ugc nofollow" target="_blank">&gt;&gt;&gt;</a>。</p><p id="2443" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在AWS的情况下，它将是ALB入口控制器——参见亚马逊EKS上的<a class="ae kw" href="https://docs.aws.amazon.com/eks/latest/userguide/alb-ingress.html" rel="noopener ugc nofollow" target="_blank"> ALB入口控制器</a>和<a class="ae kw" href="https://rtfm.co.ua/en/aws-elastic-kubernetes-service-running-alb-ingress-controller/" rel="noopener ugc nofollow" target="_blank"> AWS弹性Kubernetes服务:运行ALB入口控制器</a>。</p><p id="700b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">为了让它工作，<code class="fe ks kt ku kv b">Ingress</code>需要一个额外的服务，其中<code class="fe ks kt ku kv b">Ingress</code>将把流量路由到一种后端。</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="np nq di nr bf ns"><div class="gh gi nv"><img src="../Images/24e6e9f8883656191b5211817158f331.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*aHUIOyo4QokMtaZc.png"/></div></div></figure><p id="0e29" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">对于ALB入口控制器，具有<code class="fe ks kt ku kv b">Ingress</code>及其服务的清单可以是下一个:</p><pre class="mp mq mr ms gt mt kv mu mv aw mw bi"><span id="c3fb" class="mx ky iq kv b gy my mz l na nb">---<br/>apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: "nginx-service"<br/>  namespace: "default"<br/>spec:<br/>  ports:<br/>    - port: 80<br/>  type: NodePort<br/>  selector:<br/>    app: "nginx"<br/>--- <br/>apiVersion: extensions/v1beta1<br/>kind: Ingress<br/>metadata:<br/>  name: "nginx-ingress"<br/>  annotations:<br/>    kubernetes.io/ingress.class: alb<br/>    alb.ingress.kubernetes.io/scheme: internet-facing<br/>  labels:<br/>    app: "nginx"<br/>spec:<br/>  backend:<br/>    serviceName: "nginx-service"<br/>    servicePort: 80</span></pre><p id="eae7" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这里我们创建了一个类型为<code class="fe ks kt ku kv b">NodePort</code>的服务和类型为ALB的<code class="fe ks kt ku kv b">Ingress</code>。</p><p id="21fc" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">Kubernetes将创建一个<code class="fe ks kt ku kv b">Ingress</code>对象，然后<em class="mj"> alb-ingress-controller </em>将看到它，将使用来自<code class="fe ks kt ku kv b">Ingress</code>的<code class="fe ks kt ku kv b">spec</code>的路由规则创建一个AWS ALBс，将使用<code class="fe ks kt ku kv b">NodePort</code>端口创建一个服务对象，然后将在WorkerNodes上打开一个TCP端口，并开始通过服务将流量从clients = &gt;路由到负载平衡器= &gt;再到EC2 = &gt;上的NodePort。</p><p id="40c3" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">让我们检查一下。</p><p id="9b0e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">该服务:</p><pre class="mp mq mr ms gt mt kv mu mv aw mw bi"><span id="fd7e" class="mx ky iq kv b gy my mz l na nb">$ kubectl get svc nginx-service<br/>NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE<br/>nginx-service NodePort 172.20.54.138 &lt;none&gt; 80:30968/TCP 21h</span></pre><p id="86f1" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe ks kt ku kv b">Ingress</code>:</p><pre class="mp mq mr ms gt mt kv mu mv aw mw bi"><span id="c5f8" class="mx ky iq kv b gy my mz l na nb">$ kubectl get ingress nginx-ingress<br/>NAME HOSTS ADDRESS PORTS AGE<br/>nginx-ingress * e172ad3e-default-nginxingr-29e9–1405936870.us-east-2.elb.amazonaws.com 80 5m22s</span></pre><p id="5fe9" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">和负载平衡器的URL:</p><pre class="mp mq mr ms gt mt kv mu mv aw mw bi"><span id="cdc8" class="mx ky iq kv b gy my mz l na nb">$ curl e172ad3e-default-nginxingr-29e9–1405936870.us-east-2.elb.amazonaws.com<br/>&lt;!DOCTYPE html&gt;<br/>&lt;html&gt;<br/>&lt;head&gt;<br/>&lt;title&gt;Welcome to nginx!&lt;/title&gt;<br/>…</span></pre><p id="39f9" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">“管用！”</p><h2 id="910a" class="mx ky iq bd kz nc nd dn ld ne nf dp lh kf ng nh ll kj ni nj lp kn nk nl lt nm bi translated">基于路径的路由</h2><p id="5cf8" class="pw-post-body-paragraph ju jv iq jw b jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ij bi translated">在上面的例子中，我们将把来自ALB的所有流量发送到同一个服务及其pod。</p><p id="6ec5" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">通过使用<code class="fe ks kt ku kv b">Ingress</code>和it规则，我们还可以根据请求的URI来指定将流量发送到特定后端的规则。</p><p id="fbbd" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">那么，让我们旋转两个NGINX pods:</p><pre class="mp mq mr ms gt mt kv mu mv aw mw bi"><span id="d046" class="mx ky iq kv b gy my mz l na nb">$ kubectl create deployment nginx-1 --image=nginx<br/>deployment.apps/nginx-1 created</span><span id="2fae" class="mx ky iq kv b gy nw mz l na nb">$ kubectl create deployment nginx-2 --image=nginx<br/>deployment.apps/nginx-2 created</span></pre><p id="ef5b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在每个文件上创建一个文件，但内容不同:</p><pre class="mp mq mr ms gt mt kv mu mv aw mw bi"><span id="0217" class="mx ky iq kv b gy my mz l na nb">$ kubectl exec nginx-1–75969c956f-gnzwv --bash -c "echo svc-1 &gt; /usr/share/nginx/html/sv1.html"</span><span id="a491" class="mx ky iq kv b gy nw mz l na nb">$ kubectl exec nginx-2-db55bc45b-lssc8 --bash -c "echo svc-2 &gt; /usr/share/nginx/html/svc2.html"</span></pre><p id="456e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">更新清单文件，增加一个服务，为有两个后端的<code class="fe ks kt ku kv b">Ingress</code>设置规则:</p><pre class="mp mq mr ms gt mt kv mu mv aw mw bi"><span id="66d4" class="mx ky iq kv b gy my mz l na nb">---<br/>apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: "nginx-1-service"<br/>  namespace: "default"<br/>spec:<br/>  ports:<br/>    - port: 80<br/>  type: NodePort<br/>  selector:<br/>    app: "nginx-1"<br/>---<br/>apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: "nginx-2-service"<br/>  namespace: "default"<br/>spec:<br/>  ports:<br/>    - port: 80<br/>  type: NodePort<br/>  selector:<br/>    app: "nginx-2"    <br/>---<br/>apiVersion: extensions/v1beta1<br/>kind: Ingress<br/>metadata:<br/>  name: "nginx-ingress"<br/>  annotations:<br/>    kubernetes.io/ingress.class: alb<br/>    alb.ingress.kubernetes.io/scheme: internet-facing<br/>  labels:<br/>    app: "nginx"<br/>spec:<br/>  rules:<br/>  - http:<br/>      paths:<br/>      - path: /svc1.html<br/>        backend:<br/>          serviceName: "nginx-1-service"<br/>          servicePort: 80<br/>      - path: /svc2.html<br/>        backend:<br/>          serviceName: "nginx-2-service"<br/>          servicePort: 80</span></pre><p id="60c4" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这里我们设置了两条规则:如果svc1.html = =/<em class="mj"/>或svc2.html/<em class="mj"/>——则相应地将流量发送到<em class="mj"> nginx-1 </em>或<em class="mj"> nginx-2 </em>。</p><p id="baf0" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">部署它:</p><pre class="mp mq mr ms gt mt kv mu mv aw mw bi"><span id="1e73" class="mx ky iq kv b gy my mz l na nb">$ kubectl apply -f nginx-svc.yaml<br/>service/nginx-1-service created<br/>service/nginx-2-service created<br/>ingress.extensions/nginx-ingress configured</span></pre><p id="2604" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">检查规则:</p><pre class="mp mq mr ms gt mt kv mu mv aw mw bi"><span id="fd7f" class="mx ky iq kv b gy my mz l na nb">$ kubectl describe ingress nginx-ingress<br/>…<br/>Rules:<br/>Host Path Backends<br/> — — — — — — — — <br/>*<br/>/svc1.html nginx-1-service:80 (&lt;none&gt;)<br/>/svc2.html nginx-2-service:80 (&lt;none&gt;)<br/>…</span></pre><p id="5a8d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">检查一下——向svc1.html的URIs <em class="mj">和svc2.html的<em class="mj">发出请求:</em></em></p><pre class="mp mq mr ms gt mt kv mu mv aw mw bi"><span id="25a7" class="mx ky iq kv b gy my mz l na nb">$ curl e172ad3e-default-nginxingr-29e9–1405936870.us-east-2.elb.amazonaws.com/svc1.html</span><span id="eb01" class="mx ky iq kv b gy nw mz l na nb">svc-1</span><span id="752c" class="mx ky iq kv b gy nw mz l na nb">$ curl e172ad3e-default-nginxingr-29e9–1405936870.us-east-2.elb.amazonaws.com/svc2.html</span><span id="cc86" class="mx ky iq kv b gy nw mz l na nb">svc-2</span></pre><h2 id="cc6d" class="mx ky iq bd kz nc nd dn ld ne nf dp lh kf ng nh ll kj ni nj lp kn nk nl lt nm bi translated">基于名称的路由</h2><p id="e803" class="pw-post-body-paragraph ju jv iq jw b jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ij bi translated">另一个例子是基于主机名的路由。</p><p id="982f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">让我们创建三个DNS记录——<em class="mj">svc1.example.com</em>、<em class="mj">svc2.example.com</em>和<em class="mj">svc.example.com</em>，然后通过CNAME记录将它们指向我们从<code class="fe ks kt ku kv b">Ingress</code>资源创建的负载平衡器URL。</p><p id="49ea" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">然后，更新清单:</p><pre class="mp mq mr ms gt mt kv mu mv aw mw bi"><span id="550d" class="mx ky iq kv b gy my mz l na nb">---<br/>apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: "nginx-1-service"<br/>  namespace: "default"<br/>spec:<br/>  ports:<br/>    - port: 80<br/>  type: NodePort<br/>  selector:<br/>    app: "nginx-1"<br/>---<br/>apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: "nginx-2-service"<br/>  namespace: "default"<br/>spec:<br/>  ports:<br/>    - port: 80<br/>  type: NodePort<br/>  selector:<br/>    app: "nginx-2"    <br/>---<br/>apiVersion: extensions/v1beta1<br/>kind: Ingress<br/>metadata:<br/>  name: "nginx-ingress"<br/>  annotations:<br/>    kubernetes.io/ingress.class: alb<br/>    alb.ingress.kubernetes.io/scheme: internet-facing<br/>  labels:<br/>    app: "nginx"<br/>spec:<br/>  rules:<br/>  - host: "svc1.example.com"<br/>    http:<br/>      paths:<br/>      - backend:<br/>          serviceName: "nginx-1-service"<br/>          servicePort: 80<br/>  - host: "svc2.example.com"<br/>    http:<br/>      paths:<br/>      - backend:<br/>          serviceName: "nginx-2-service"<br/>          servicePort: 80<br/>  - http:<br/>      paths:      <br/>      - backend:<br/>          serviceName: "nginx-1-service"<br/>          servicePort: 80</span></pre><p id="8e0b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这里我们没有对服务做任何修改，但是在规则中，我们设置了一个对svc1.example.com的请求必须发送到服务1的T1、服务2的svc2.example.com、服务2的T2、服务1的svc.example.com、服务1的T4。</p><p id="b110" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">检查一下:</p><pre class="mp mq mr ms gt mt kv mu mv aw mw bi"><span id="2493" class="mx ky iq kv b gy my mz l na nb">$ curl svc1.example.com<br/>svc-1</span><span id="2f0e" class="mx ky iq kv b gy nw mz l na nb">$ curl svc2.example.comsvc-2</span><span id="e343" class="mx ky iq kv b gy nw mz l na nb">$ curl svc.example.com<br/>svc-1</span></pre><p id="0c66" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">并在AWS控制台中检查负载平衡器的侦听器上的规则:</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="np nq di nr bf ns"><div class="gh gi nx"><img src="../Images/04a72d632ab15567902812d7cb70fedb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*fj94qLqdxZFhHXb_.png"/></div></div></figure><p id="03ca" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">“那都是乡亲们！”</p></div><div class="ab cl ny nz hu oa" role="separator"><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od"/></div><div class="ij ik il im in"><p id="61ba" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><em class="mj">最初发布于</em> <a class="ae kw" href="https://rtfm.co.ua/en/kubernetes-clusterip-vs-nodeport-vs-loadbalancer-services-and-ingress-an-overview-with-examples/" rel="noopener ugc nofollow" target="_blank"> <em class="mj"> RTFM: Linux、DevOps、系统管理</em> </a> <em class="mj">。</em></p></div></div>    
</body>
</html>