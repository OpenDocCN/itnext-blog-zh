<html>
<head>
<title>Distributed Tracing with Java “MicroDonuts”, Kubernetes and the Ambassador API Gateway</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Java“微数据点”、Kubernetes和Ambassador API网关进行分布式跟踪</h1>
<blockquote>原文：<a href="https://itnext.io/distributed-tracing-with-java-microdonuts-kubernetes-and-the-ambassador-api-gateway-c3e663e1f79a?source=collection_archive---------6-----------------------#2018-08-28">https://itnext.io/distributed-tracing-with-java-microdonuts-kubernetes-and-the-ambassador-api-gateway-c3e663e1f79a?source=collection_archive---------6-----------------------#2018-08-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="f001" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">分布式跟踪越来越被视为观察基于微服务的应用的必要组成部分，许多现代微服务语言框架都提供了对跟踪实现的支持，如T2的Open Zipkin T3、T4的Jaeger T5、T6的Open census T7和T8的light step xPM T9。谷歌是第一批在2010年的一篇论文中谈论他们使用分布式跟踪的组织之一，该论文描述了他们的<a class="ae kl" href="https://research.google.com/archive/papers/dapper-2010-1.pdf" rel="noopener ugc nofollow" target="_blank"> Dapper </a>实现，并且他们得出的基本要求之一是跟踪系统的无处不在的部署:</p><blockquote class="km kn ko"><p id="d77f" class="jn jo kp jp b jq jr js jt ju jv jw jx kq jz ka kb kr kd ke kf ks kh ki kj kk ij bi translated">无处不在是很重要的，因为即使系统的一小部分没有被监控，跟踪基础设施的有用性也会受到严重影响</p></blockquote><p id="7006" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如我之前所写的，许多工程师开始一个绿地项目或探索基于微服务架构的迁移时，通常从在边缘部署前端代理或API网关开始<a class="ae kl" rel="noopener ugc nofollow" target="_blank" href="/using-api-gateways-to-facilitate-your-transition-from-monolith-to-microservices-c08fe3489237">以便动态地将流量路由到独立的服务</a>。由于每个入站请求都流经该组件，因此边缘网关自然需要支持分布式跟踪，最好使用一个成熟的开放协议。</p><p id="a297" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本文探讨了如何将开源<a class="ae kl" href="https://www.getambassador.io/" rel="noopener ugc nofollow" target="_blank"> Ambassador API Gateway </a>提供的分布式跟踪支持添加到Kubernetes中运行的现有open tracing Java "<a class="ae kl" href="https://github.com/opentracing-contrib/java-opentracing-walkthrough" rel="noopener ugc nofollow" target="_blank">micro donuts</a>"演示应用程序中。</p><h1 id="ce45" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">从为什么开始？</h1><p id="f37f" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">正如Cindy Sridharan在她内容丰富的“<a class="ae kl" href="https://medium.com/@copyconstruct/monitoring-in-the-time-of-cloud-native-c87c7a5bfa3e" rel="noopener">Monitoring in the Time of Cloud Native</a>”博客中所讨论的，分布式跟踪不仅被认为是现代可观测性的三大支柱之一(与指标监控和日志记录一起)，而且它为开发人员提供了更丰富的调试分布式系统的选项:</p><blockquote class="km kn ko"><p id="b620" class="jn jo kp jp b jq jr js jt ju jv jw jx kq jz ka kb kr kd ke kf ks kh ki kj kk ij bi translated">当请求流经分布式系统的各个组件时，跟踪可以捕获请求的生存期。支持使用额外的键值对来丰富正在传播的上下文，这使得在跟踪中编码应用程序特定的元数据成为可能，这可能会给开发人员带来更多的调试能力。</p></blockquote><p id="e65d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">根据我构建和使用微服务的经验，在开发和生产中诊断问题时，跟踪非常有用。了解基于服务的应用程序的行为通常是一项重要的任务，当您将此与系统表现出的不确定性行为(尤其是在部署到云环境中时)或与不可靠的第三方的通信结合起来时，挑战只会更加严峻。至关重要的是，分布式跟踪可以让您了解应用程序中如何处理请求。</p><h1 id="1531" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">分布式跟踪101</h1><p id="3ca9" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">分布式跟踪背后的基本思想相对简单——请求所经过的特定拐点必须在系统中被识别并被检测。例如，这些拐点包括API网关、每个内部服务和数据存储或有状态的外部服务。必须协调和整理所有的跟踪数据，以提供请求的有意义的流程视图；这就是为什么您会听说使用相关性标识符来将相关的跟踪数据分组在一起，以便进行<a class="ae kl" href="https://thenewstack.io/opentracing-aims-clearer-view-processes-distributed-systems/" rel="noopener ugc nofollow" target="_blank">更有意义的分析</a>:</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi lw"><img src="../Images/70a0c9f73efdc4331cf2a5aa8b08cda1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*188Ketv-rzAVw1px"/></div></div></figure><p id="1265" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">CNCF托管的<a class="ae kl" href="http://opentracing.io/" rel="noopener ugc nofollow" target="_blank"> OpenTracing API </a>正在成为事实上的开放跟踪标准，有几个流行的开源框架实现了这一点，如<a class="ae kl" href="https://zipkin.io/" rel="noopener ugc nofollow" target="_blank"> OpenZipkin </a>和<a class="ae kl" href="https://www.jaegertracing.io/" rel="noopener ugc nofollow" target="_blank"> Jaeger </a>，以及商业选项如<a class="ae kl" href="https://lightstep.com/" rel="noopener ugc nofollow" target="_blank"> LightStep </a>。许多微服务框架现在提供集成或兼容的跟踪实现。Java <a class="ae kl" href="https://spring.io/projects/spring-boot" rel="noopener ugc nofollow" target="_blank"> Spring Boot </a>栈为<a class="ae kl" href="https://cloud.spring.io/spring-cloud-sleuth/" rel="noopener ugc nofollow" target="_blank"> Spring Cloud Sleuth </a>提供Zipkin集成，Golang <a class="ae kl" href="https://micro.mu/" rel="noopener ugc nofollow" target="_blank"> micro </a>框架提供<a class="ae kl" href="https://github.com/micro/go-plugins/blob/master/wrapper/trace/opentracing/opentracing.go" rel="noopener ugc nofollow" target="_blank"> OpenTracing wrappers </a>。</p><h1 id="99b7" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">使用大使API网关进行跟踪</h1><p id="4142" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">最近，Kubernetes-native Ambassador API gateway<a class="ae kl" href="https://www.getambassador.io/user-guide/tracing-tutorial" rel="noopener ugc nofollow" target="_blank">增加了分布式跟踪支持</a>，它基于底层<a class="ae kl" href="https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/tracing" rel="noopener ugc nofollow" target="_blank">特使代理</a>在其核心提供的功能。Ambassador现在可以生成一个请求(关联)标识符，并填充x-request-id HTTP头。上游服务可以转发该报头，以便传播请求上下文，用于跟踪和统一聚合日志记录。</p><p id="5b78" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">大使跟踪实现目前支持开放的Zipkin和兼容Zipkin的后端，如Jaeger和Lightstep的商业xPM产品。与Envoy一样，当使用Zipkin tracer时，Ambassador会添加<a class="ae kl" href="https://github.com/openzipkin/b3-propagation" rel="noopener ugc nofollow" target="_blank"> B3 HTTP头</a>，当使用LightStep tracer时，<a class="ae kl" href="https://www.envoyproxy.io/docs/envoy/latest/configuration/http_conn_man/headers#config-http-conn-man-headers-x-ot-span-context" rel="noopener ugc nofollow" target="_blank"> x-ot-span-context HTTP头</a>会被添加到任何向上游发送的请求中。</p><h1 id="6565" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">探索微点应用</h1><p id="4fcb" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">OpenTracing社区贡献了一系列非常有用的示例应用程序，这些应用程序使用提到的所有实现来演示分布式跟踪。“<a class="ae kl" href="https://github.com/opentracing-contrib/java-opentracing-walkthrough" rel="noopener ugc nofollow" target="_blank">Java-open tracing-walk through</a>”GitHub存储库提供了一个“微点”示例，该示例为基于web的甜甜圈订购应用程序提供跟踪。这个例子被设计成通过Maven运行，不需要任何额外的基础设施，比如Docker和Kubernetes。</p><p id="b982" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">MicroDonuts应用程序是作为一个独立的应用程序执行的(具有一个静态的void主入口点)，但是它提供了几个servlets来模拟运行多个服务的<a class="ae kl" href="https://github.com/danielbryantuk/java-opentracing-walkthrough/blob/master/microdonuts/src/main/java/com/otsample/api/ApiContextHandler.java#L37" rel="noopener ugc nofollow" target="_blank">，这些服务可用于准备我们的甜甜圈订单:</a></p><pre class="lx ly lz ma gt mi mj mk ml aw mm bi"><span id="03e3" class="mn ku iq mj b gy mo mp l mq mr">void registerServlets() {<br/>  kitchenConsumer = new KitchenConsumer();<br/>  addServlet(new ServletHolder(new OrderServlet(kitchenConsumer)), "/order");<br/>  addServlet(new ServletHolder(new StatusServlet(kitchenConsumer)), "/status");<br/>  addServlet(new ServletHolder(new ConfigServlet(config)), "/config.js");<br/>    }</span></pre><p id="685b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">应用程序中的跟踪组件是使用<a class="ae kl" href="https://github.com/opentracing/opentracing-java" rel="noopener ugc nofollow" target="_blank"> OpenTracing Java SDK </a>和<a class="ae kl" href="https://github.com/openzipkin/brave" rel="noopener ugc nofollow" target="_blank">“勇敢”Zipkin Java SDK </a>实现的。根据指定的配置文件(更多信息见下文)，<a class="ae kl" href="https://github.com/danielbryantuk/java-opentracing-walkthrough/blob/master/microdonuts/src/main/java/com/otsample/api/App.java" rel="noopener ugc nofollow" target="_blank">应用程序类</a>初始化跟踪框架:</p><pre class="lx ly lz ma gt mi mj mk ml aw mm bi"><span id="37e2" class="mn ku iq mj b gy mo mp l mq mr">} else if ("zipkin".equals(tracerName)){<br/>    OkHttpSender sender = OkHttpSender.create(<br/>        "http://" +<br/>            config.getProperty("zipkin.reporter_host") + ":" +<br/>            config.getProperty("zipkin.reporter_port") + "/api/v1/spans");<br/>    Reporter&lt;Span&gt; reporter = AsyncReporter.builder(sender).build();<br/>    tracer = BraveTracer.create(Tracing.newBuilder()<br/>        .localServiceName(componentName)<br/>        .spanReporter(reporter)<br/>        .build());<br/>}</span></pre><p id="3f84" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后通过HTTP请求为servlet的每个创新创建跨度。如果您查看ApiContextHandler类，您将看到我对OrderServlet所做的修改，以便从当前的下游请求中提取跟踪头(这将在您通过web浏览器向应用程序发出请求后由Ambassador完成)，并将此span指定为您为每个油炸圈饼订单创建的新span的父span:</p><pre class="lx ly lz ma gt mi mj mk ml aw mm bi"><span id="3370" class="mn ku iq mj b gy mo mp l mq mr"><a class="ae kl" href="http://twitter.com/Override" rel="noopener ugc nofollow" target="_blank">@Override</a><br/>public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {<br/><strong class="mj ir">    TextMap headersTextMap = new TextMapExtractAdapter(getHeadersInfo(request));<br/>    SpanContext parentSpanCtx = GlobalTracer.get().extract(Format.Builtin.HTTP_HEADERS, headersTextMap);</strong></span><span id="e512" class="mn ku iq mj b gy ms mp l mq mr">try (Scope orderSpanScope = GlobalTracer.get()<br/>            .buildSpan("order_span")<br/><strong class="mj ir">            .asChildOf(parentSpanCtx)</strong><br/>            .startActive(true)) {</span><span id="724a" class="mn ku iq mj b gy ms mp l mq mr">request.setAttribute("span", orderSpanScope.span());<br/>...</span></pre><p id="be9d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">完成这些修改后，我需要做的就是将应用程序打包并部署到Kubernetes上。</p><h1 id="1287" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">与大使一起在Kubernetes上部署微点</h1><p id="fe0e" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">在meetups上使用MicroDonuts示例演示了跟踪概念之后，我经常被问及如何将这个应用程序打包以部署到Kubernetes上(因为这是许多组织在生产中运行应用程序的流行平台)。我热衷于测试新的Ambassador分布式跟踪功能，因此这提供了一个完美的借口，在Docker中打包MicroDonuts应用程序，并将其与Ambassador一起部署在Kubernetes上。</p><p id="a8be" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我在另一篇文章中提供了对我所采用的方法的深入探究(以及我所遇到的考验和磨难！)，但是本文关注的是结果，目标是让您在10分钟内开始使用示例。</p><p id="fa8e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先从<a class="ae kl" href="https://github.com/danielbryantuk/java-opentracing-walkthrough" rel="noopener ugc nofollow" target="_blank">https://github . com/danielbryantuk/Java-open tracing-walk through</a>中克隆我的项目分叉版本，并导航到目录中</p><pre class="lx ly lz ma gt mi mj mk ml aw mm bi"><span id="e177" class="mn ku iq mj b gy mo mp l mq mr">$ git clone <a class="ae kl" href="https://github.com/danielbryantuk/java-opentracing-walkthrough" rel="noopener ugc nofollow" target="_blank">https://github.com/danielbryantuk/java-opentracing-walkthrough</a> <br/>$ cd java-opentracing-walkthrough</span></pre><p id="7ed9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您需要配置一个空的Kubernetes集群，并准备就绪。我通常使用<a class="ae kl" href="https://cloud.google.com/kubernetes-engine/" rel="noopener ugc nofollow" target="_blank">谷歌的Kubernetes引擎(GKE) </a>和通过<a class="ae kl" href="https://cloud.google.com/sdk/install" rel="noopener ugc nofollow" target="_blank"> gcloud SDK </a>配置的短暂实例，因为这以合理的价格提供了真正的集群体验。但是，您应该能够使用minikube或Docker for Mac/Windows，只需进行最小的更改。</p><pre class="lx ly lz ma gt mi mj mk ml aw mm bi"><span id="2a3a" class="mn ku iq mj b gy mo mp l mq mr">$ gcloud container clusters create ambassador-tracing-demo --preemptible<br/>...<br/>kubeconfig entry generated for ambassador-tracing-demo.<br/>NAME                     LOCATION       MASTER_VERSION  MASTER_IP      MACHINE_TYPE   NODE_VERSION  NUM_NODES  STATUS<br/>ambassador-tracing-demo  us-central1-a  1.9.7-gke.5     35.226.58.170  n1-standard-1  1.9.7-gke.5   3          RUNNING<br/>$<br/>$ # As all GKE clusters enable RBAC by default, create a cluster-admin clusterrolebinding <br/>$ # for your user account<br/>$ kubectl create clusterrolebinding cluster-admin-binding-new \<br/>--clusterrole cluster-admin --user <a class="ae kl" href="mailto:my.user.account@gmail.com" rel="noopener ugc nofollow" target="_blank">my.user.account@gmail.com</a></span></pre><p id="8ec4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">尽管Dockerfile是一个带有OpenJDK 8 JRE的相当标准的Java映像，但您可以随意探索这个目录中的docker file。接下来，导航到kubernetes-ambassador目录，其中包含引导演示所需的配置文件:</p><pre class="lx ly lz ma gt mi mj mk ml aw mm bi"><span id="2d60" class="mn ku iq mj b gy mo mp l mq mr">$ cd kubernetes-ambassador/<br/>(master) kubernetes-ambassador $ ls -lsa<br/>total 304<br/>  0 drwxr-xr-x   8 danielbryant  staff    256 12 Aug 15:13 .<br/>  0 drwxr-xr-x  11 danielbryant  staff    352  8 Aug 16:42 ..<br/>  8 -rw-r--r--@  1 danielbryant  staff   2043  1 Aug 16:26 ambassador-rbac.yaml<br/>  8 -rw-r--r--   1 danielbryant  staff    374  8 Aug 10:43 ambassador-service.yaml<br/>  8 -rw-r--r--   1 danielbryant  staff   1145 12 Aug 15:10 microdonut.yaml<br/>  8 -rw-r--r--   1 danielbryant  staff    576 12 Aug 14:53 tracing-config.yaml<br/>  8 -rw-r--r--   1 danielbryant  staff   1037  8 Aug 11:16 zipkin.yaml</span></pre><p id="2a41" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">大使API网关部署和管理服务在ambassador-rbac.yaml文件中配置，外部<a class="ae kl" href="https://httpbin.org/" rel="noopener ugc nofollow" target="_blank">httpbin.org</a>服务的简单重写映射大使注释示例包含在ambassador-service.yaml文件中。</p><h1 id="d664" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">在Kubernetes部署Zipkin和大使</h1><p id="3231" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">Zipkin部署和服务是在zipkin.yaml文件中配置的，该文件使用OpenZipkin Docker映像。这个文件中有两个大使注释:一个TracingService指定负责收集Zipkin跟踪数据的服务，另一个映射允许您导航到Zipkin UI并在浏览器中检查跟踪。下面显示了该配置的摘录:</p><pre class="lx ly lz ma gt mi mj mk ml aw mm bi"><span id="13e1" class="mn ku iq mj b gy mo mp l mq mr">---<br/>apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: zipkin<br/>  annotations:<br/>    getambassador.io/config: |<br/>      ---<br/>      apiVersion: ambassador/v0<br/>      kind: TracingService<br/>      name: /tracing/<br/>      service: zipkin:9411<br/>      driver: zipkin<br/>      ---<br/>      apiVersion: ambassador/v0<br/>      kind: Mapping<br/>      name: zipkin_mapping<br/>      prefix: /zipkin/<br/>      rewrite: ""<br/>      service: zipkin:9411</span></pre><p id="14bb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在microdonut.yaml中定义的MicroDonut应用程序由一个服务和一个相关联的部署组成，该部署使用了我在<a class="ae kl" href="https://hub.docker.com/r/danielbryantuk/microdonut/tags/" rel="noopener ugc nofollow" target="_blank">danielbryantuk/microd onut:1.3</a>添加到DockerHub存储库中的容器。我还为服务的映射添加了一个大使注释，以便您可以通过UI订购一些甜甜圈。</p><p id="37af" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您检查microdonut.yaml文件，您将看到我已经为microdonut容器指定了一个卷挂载，并用configMap对此进行了备份。ConfigMap在tracing-config.yaml文件中定义，其内容用于配置MicroDonut应用程序的所有跟踪选项。如果您想从Zipkin更改为Jaeger跟踪，或者更改Zipkin收集器服务主机或端口，请编辑该文件。</p><pre class="lx ly lz ma gt mi mj mk ml aw mm bi"><span id="ce88" class="mn ku iq mj b gy mo mp l mq mr">---</span><span id="e5d9" class="mn ku iq mj b gy ms mp l mq mr">kind: ConfigMap<br/>apiVersion: v1<br/>metadata:<br/>    name: tracing-config<br/>data:<br/>    tracer_config.properties: |<br/>        public_directory=../client</span><span id="521f" class="mn ku iq mj b gy ms mp l mq mr"><strong class="mj ir">// Selector for the below config blocks<br/>        tracer=zipkin</strong></span><span id="e046" class="mn ku iq mj b gy ms mp l mq mr">// Jaeger config<br/>        jaeger.reporter_host=localhost<br/>        jaeger.reporter_port=5775</span><span id="afba" class="mn ku iq mj b gy ms mp l mq mr"><strong class="mj ir">// Zipkin config<br/>        zipkin.reporter_host=zipkin<br/>        zipkin.reporter_port=9411</strong></span><span id="b3e8" class="mn ku iq mj b gy ms mp l mq mr">// LightStep config<br/>        lightstep.collector_host=collector.lightstep.com<br/>        lightstep.collector_port=80<br/>        lightstep.access_token={your_token}</span></pre><p id="c342" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以部署kubernetes-ambassador目录下的YAML文件中指定的所有服务和配置，如下所示:</p><pre class="lx ly lz ma gt mi mj mk ml aw mm bi"><span id="d060" class="mn ku iq mj b gy mo mp l mq mr">$ kubectl apply -f .<br/>service "ambassador-admin" created<br/>clusterrole "ambassador" created<br/>serviceaccount "ambassador" created<br/>clusterrolebinding "ambassador" created<br/>deployment "ambassador" created<br/>service "ambassador" created<br/>service "microdonut" created<br/>deployment "microdonut" created<br/>configmap "tracing-config" created<br/>service "zipkin" created<br/>deployment "zipkin" created</span></pre><p id="bfc9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，您可以通过kubectl查询所有的服务，但是如果使用GKE，您可能需要等待一段时间，大使负载平衡器服务才能获得一个外部IP(最初查询可能会导致“【T2”)</p><pre class="lx ly lz ma gt mi mj mk ml aw mm bi"><span id="0318" class="mn ku iq mj b gy mo mp l mq mr">$ kubectl get svc<br/>NAME               TYPE           CLUSTER-IP      EXTERNAL-IP      PORT(S)          AGE<br/>ambassador         LoadBalancer   10.51.248.134   35.224.129.220   80:30306/TCP     1m<br/>ambassador-admin   NodePort       10.51.245.207   &lt;none&gt;           8877:32035/TCP   1m<br/>kubernetes         ClusterIP      10.51.240.1     &lt;none&gt;           443/TCP          1m<br/>microdonut         ClusterIP      10.51.245.91    &lt;none&gt;           10001/TCP        1m<br/>zipkin             NodePort       10.51.244.91    &lt;none&gt;           9411:31899/TCP   1m</span></pre><p id="35be" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您现在可以通过访问以下网址来查看MicroDonut网页:</p><p id="d66c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mt mu mv mj b">http://&lt;external-ip&gt;/microdonut/</code></p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi mw"><img src="../Images/978853a2a21ead27de65ac7df8276b6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WqAEppQJwQvnF3HH"/></div></div></figure><p id="b2c9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您也可以访问以下网站查看Zipkin仪表盘:</p><p id="7e98" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mt mu mv mj b">http://&lt;external-ip&gt;/zipkin/</code></p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi mx"><img src="../Images/5ec37ed9d9c68a2a314324f758ef4e17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OU19xnAxxvwzx2NW"/></div></div></figure><p id="d227" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一切都准备好了，现在你需要做的就是订购一些唐</p><h1 id="8116" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">追踪油炸圈饼</h1><p id="96c8" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">现在，为了看到一些有趣的痕迹，您需要订购一些甜甜圈。为此，只需点击MicroDonut网页上的几张甜甜圈图片，然后点击甜甜圈图片下方的图标“订购”。完成此操作后，您应该会在图标中看到一个倒计时，并显示甜甜圈准备阶段的一系列步骤(“添加”、“等待”、“烹饪”等)。随意下几个订单，尽管做这个的时候尽量不要太饿！</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi my"><img src="../Images/7fa43fafb83aed8adb0f4137e7b3fdd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1GU603tOaGdJRwag"/></div></div></figure><p id="728c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，打开Zipkin仪表盘，点击“查找痕迹”。通过Ambassador的每一个请求(包括对Zipkin dashboard的任何请求)都会被跟踪，因此您必须确定一个与准备甜甜圈相关的跟踪。</p><p id="3907" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通常，大多数具有2个跨度(两个服务跳)的较短跟踪与Zipkin仪表板相关，而具有9+跳(多个服务跳，以及每个服务创建的多个跨度)的较长跟踪与MicroDonut应用程序相关。您可能需要订购几个甜甜圈，并快速切换到Zipkin dash来查找相关的跟踪，因为这些可能会在UI搜索结果中很快被Ambassador跟踪的其他请求所取代。</p><p id="8868" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在下面的截图中，您可以看到在我的示例中，一个甜甜圈订单创建了11个跨度，用了184.084毫秒完成。</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi mz"><img src="../Images/39926d3b4f2190d8b5ba211fe61d88fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*nusJkbOqw2FbRJwc"/></div></div></figure><p id="9bbd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以点击跟踪，以获得更详细的请求处理情况，例如:</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi na"><img src="../Images/a3b678921c09281971b8cd726ab10bfa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*SM4Er-nnNCDbmLwA"/></div></div></figure><p id="866b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这里，您可以看到Ambassador处理了入口请求，然后将该请求向上游传递到“order_span”开始的微节点服务。“ambassador-default”服务名在跟踪中清晰可见，我不确定为什么“microdonut”服务名没有出现，因为它看起来在MicroDonut应用程序的<a class="ae kl" href="https://github.com/danielbryantuk/java-opentracing-walkthrough/blob/master/microdonuts/src/main/java/com/otsample/api/App.java#L98" rel="noopener ugc nofollow" target="_blank"> Zipkin (Brave / OpenTracing)配置</a>中被正确指定。</p><p id="f52a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">需要注意的另一件有趣的事情是，即使您在订购和烹饪甜甜圈的过程中向同一个MicroDonut应用程序发出多个请求，每个请求都是通过localhost loopback适配器发出的进程外HTTP请求(因此不通过Ambassador)，并且span信息由Brave implement传播，以便正确地连接所有这些跟踪。</p><h1 id="5067" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">下一步是什么？</h1><p id="21f8" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">给定这个示例应用程序和Ambassador配置，您应该能够毫不费力地启动和运行任何Zipkin兼容的应用程序。由于Ambassador将Zipkin头注入到任何上游请求中，任何识别这些头(并向前传播它们)的应用程序都应该是可跟踪的。</p><p id="b1d9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://github.com/danielbryantuk/java-opentracing-walkthrough/tree/master/microdonuts" rel="noopener ugc nofollow" target="_blank">示例Java代码</a>展示了如何使用Brave库实现Zipkin头处理(以及如何将<a class="ae kl" href="https://github.com/danielbryantuk/java-opentracing-walkthrough/commit/ec549bc5e7ffaf47d30b6ee4f7fb540df5815b96" rel="noopener ugc nofollow" target="_blank">大使生成的span作为父span</a>附加到每个子span)，我将在其他帖子中更详细地介绍我是如何修改MicroDonut示例的。然而，不要让这个例子是用Java编写的这一事实阻止了你。任何支持Zipkin的语言或框架都应该可以使用提供的配置开箱即用——您只需指定Zipkin Kubernetes服务主机和端口，就可以开始了！</p><p id="beff" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以在https://www . getambassador . io了解更多关于ambassador的信息，并在Ambassador文档中了解<a class="ae kl" href="https://www.getambassador.io/user-guide/tracing-tutorial" rel="noopener ugc nofollow" target="_blank"> Ambassador分布式跟踪</a>功能。如果你有任何问题，请加入我们的<a class="ae kl" href="http://d6e.co/slack" rel="noopener ugc nofollow" target="_blank"> Slack </a>，在下面的评论中给我们留言，或者在Twitter上发<a class="ae kl" href="https://twitter.com/getambassadorio" rel="noopener ugc nofollow" target="_blank"> @getambassadorio </a>。</p><p id="abc0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kp">本文原载于</em> <a class="ae kl" href="https://blog.getambassador.io/distributed-tracing-with-java-microdonuts-kubernetes-and-the-ambassador-api-gateway-ace15b62a89e" rel="noopener ugc nofollow" target="_blank"> <em class="kp"> getambassador.io博客</em> </a> <em class="kp">。</em></p></div></div>    
</body>
</html>