<html>
<head>
<title>Benchmarking the experimental Redis Multi-Threaded I/O</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">实验性Redis多线程I/O的基准测试</h1>
<blockquote>原文：<a href="https://itnext.io/benchmarking-the-experimental-redis-multi-threaded-i-o-1bb28b69a314?source=collection_archive---------4-----------------------#2019-04-26">https://itnext.io/benchmarking-the-experimental-redis-multi-threaded-i-o-1bb28b69a314?source=collection_archive---------4-----------------------#2019-04-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="a70f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Redis通常被认为是一个单进程、单线程模型。对于较新版本的Redis，情况并非如此。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/05da3fcb5308841d5d3b63a11b628e6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cXOVEBO4XpneMVVn"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated"><strong class="bd le">金门大桥</strong> —这张照片是2019年3月30日在旧金山湾拍摄的，当时正在为RedisConf 19做准备</figcaption></figure><p id="a4d3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">引用<a class="ae lf" href="https://redis.io/topics/faq" rel="noopener ugc nofollow" target="_blank">官方文件</a>:</p><blockquote class="lg lh li"><p id="602e" class="jq jr lj js b jt ju jv jw jx jy jz ka lk kc kd ke ll kg kh ki lm kk kl km kn im bi translated">从Redis 4.0开始，我们开始让Redis更加线程化。目前，这仅限于在后台删除对象，以及阻止通过Redis模块实现的命令。对于下一个版本，计划是让Redis越来越线程化。</p></blockquote><p id="29a5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Redis运行多个后端线程来执行后端清理工作，比如清理脏数据和关闭文件描述符。当你在每次后台保存时派生子进程时，它不再是单进程。</p><p id="2ede" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要使Redis更加多线程化，最简单的方法是，一旦Redis需要执行任何写或读操作，这项工作就由N个先前分散的I/O线程来执行。没有增加太多的复杂性，因为主线程仍然负责主要任务，但是大部分优势，因为Redis花费的大部分时间都在IO上，通常，Redis的工作负载要么是内存，要么是网络。</p><h2 id="ff24" class="ln lo it bd le lp lq dn lr ls lt dp lu kb lv lw lx kf ly lz ma kj mb mc md me bi translated">1)调优Redis虚拟机并找出哪些Redis代码路径是热的(CPU上繁忙)</h2><p id="61ae" class="pw-post-body-paragraph jq jr it js b jt mf jv jw jx mg jz ka kb mh kd ke kf mi kh ki kj mj kl km kn im bi translated">为了找出我们在io上花费了多少时间，我们在GCP上设置了两个<strong class="js iu"> n1-highcpu-96 </strong>实例，其中一个我们将运行redis-server(从线程化IO分支),另一个我们将运行redis-benchmark。</p><p id="3e86" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了以最高效的方式运行redis-server，我们使用tuned-adm <strong class="js iu">吞吐量-性能配置文件</strong>和手动设置，通过以下方式调整了两个<strong class="js iu"> n1-highcpu-96 </strong>实例:</p><ul class=""><li id="5b84" class="mk ml it js b jt ju jx jy kb mm kf mn kj mo kn mp mq mr ms bi translated">禁用<strong class="js iu">调谐</strong>和<strong class="js iu"> ktune </strong>节电机制。</li><li id="68af" class="mk ml it js b jt mt jx mu kb mv kf mw kj mx kn mp mq mr ms bi translated">启用<strong class="js iu"> sysctl </strong>设置，提高您的磁盘和网络I/O的吞吐量性能，并切换到<strong class="js iu">截止时间调度器</strong>。</li><li id="610c" class="mk ml it js b jt mt jx mu kb mv kf mw kj mx kn mp mq mr ms bi translated">将CPU调节器设置为<code class="fe my mz na nb b">performance.</code></li><li id="ab79" class="mk ml it js b jt mt jx mu kb mv kf mw kj mx kn mp mq mr ms bi translated">手动禁用透明大页面。</li><li id="5dd2" class="mk ml it js b jt mt jx mu kb mv kf mw kj mx kn mp mq mr ms bi translated">手动将somaxconn提高到65535。</li><li id="322d" class="mk ml it js b jt mt jx mu kb mv kf mw kj mx kn mp mq mr ms bi translated">手动将vm.overcommit_memory从0(默认值)设置为1(从不拒绝任何malloc)。</li></ul><p id="56eb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们上面提到的手动设置可以通过运行以下命令来实现。最后一项确保sysctl设置会立即生效。</p><pre class="kp kq kr ks gt nc nb nd ne aw nf bi"><span id="a89f" class="ln lo it nb b gy ng nh l ni nj"><strong class="nb iu"><em class="lj">sudo -i<br/></em></strong>echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled</span><span id="44e1" class="ln lo it nb b gy nk nh l ni nj">sysctl -w vm.overcommit_memory=1<br/>sysctl -w net.core.somaxconn=65535<br/><em class="lj">sysctl -p</em></span></pre><h2 id="39c9" class="ln lo it bd le lp lq dn lr ls lt dp lu kb lv lw lx kf ly lz ma kj mb mc md me bi translated">1.1)分析单线程redis服务器</h2><p id="23d4" class="pw-post-body-paragraph jq jr it js b jt mf jv jw jx mg jz ka kb mh kd ke kf mi kh ki kj mj kl km kn im bi translated"><strong class="js iu"> 1.1.1 ) redis-server虚拟机</strong></p><p id="7575" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，我们已经针对服务器工作负载调整了虚拟机，我们可以在其中一个虚拟机上启动redis-server实例，配置如下:</p><pre class="kp kq kr ks gt nc nb nd ne aw nf bi"><span id="fb42" class="ln lo it nb b gy ng nh l ni nj"><strong class="nb iu">fcosta_oliveira@n1-highcpu-96-redis-server-1</strong>:<strong class="nb iu">/</strong>redis-server --protected-mode no --save "" --appendonly no   --daemonize yes</span></pre><p id="64f3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> 1.1.2 ) redis基准虚拟机</strong></p><p id="9caf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了评估Redis的性能并生成我们分析Redis所需的多个工作负载，我们将在整篇文章中使用redis-benchmark。官方的redis-benchmark程序是获取一些数据的一种快速而有用的方法。</p><p id="0229" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们已经派生出官方版本，并在github存储库之后的<a class="ae lf" href="https://github.com/filipecosta90/redis/tree/benchmark_xadd" rel="noopener ugc nofollow" target="_blank">中包含了对新流数据类型的测试。我们目前正在等待</a><a class="ae lf" href="https://github.com/antirez/redis/pull/6015" rel="noopener ugc nofollow" target="_blank">的公关修订</a>，以便将其纳入Redis。</p><p id="883a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本节中，我们只对验证Redis花费在IO上的时间感兴趣，以便能够使用Amdahl定律来预测使用并行工作负载时的理论加速。为此，我们将使用新的线程redis基准来发送1000万个GET命令，由150个客户端发出，密钥大小为100字节。</p><pre class="kp kq kr ks gt nc nb nd ne aw nf bi"><span id="1352" class="ln lo it nb b gy ng nh l ni nj"><strong class="nb iu">fcosta_oliveira@n1-highcpu-96-redis-benchmark-1</strong>:<strong class="nb iu">~/</strong>redis-benchmark -t get -c 150 -n 10000000 — threads 46 -h {ip of redis-server vm} -d 100</span></pre><p id="39fd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> 1.1.3)运行基准工具</strong>时分析堆栈轨迹</p><p id="1533" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当我们从<strong class="js iu">n1-high CPU-96-redis-benchmark-1</strong>虚拟机运行基准测试时，我们可以通过运行以下命令，使用Linux perf_events(又名“perf”)以99Hz堆栈样本的固定采样率分析<strong class="js iu">n1-high CPU-96-redis-server-1</strong>虚拟机、<strong class="js iu"> </strong>中的redis-server堆栈跟踪:</p><pre class="kp kq kr ks gt nc nb nd ne aw nf bi"><span id="987f" class="ln lo it nb b gy ng nh l ni nj"><strong class="nb iu">fcosta_oliveira@n1-highcpu-96-redis-server-1</strong>:<strong class="nb iu">~/</strong>sudo perf record -F 99 — pid `pgrep redis-server` -g -o 100_bytes_no_iothreads</span></pre><p id="4dd8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">产生下面的火焰图:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nl"><img src="../Images/5643377675332189cad2d0b60120aafc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K4OfwNbkGY_M0TkUBINdNQ.png"/></div></div></figure><p id="3bc8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Redis服务器在实验性Redis多线程I/O改进前的执行时间记为t，它包括不会从资源改进中受益的部分的执行时间和会从中受益的部分的执行时间。从前面的flame图可以看出，46.6%的执行时间(花费在sys_write上)可能是实验性Redis多线程I/O加速的主题。</p><p id="73b8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">加速受到程序串行部分的限制，在我们的例子中为53.4%，导致使用并行计算的理论最大加速为2倍，如下图的蓝线所示。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nm"><img src="../Images/529e8cbe5dc3fdad8f6627006e95370c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*P4PbxqYSG7XW0sLi.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">根据阿姆达尔的理论加速定律，进化是一个程序执行的等待时间与执行它的处理器数量的函数关系。从<a class="ae lf" href="https://en.wikipedia.org/wiki/Amdahl%27s_law" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Amdahl%27s_law</a>检索的图像。</figcaption></figure><h2 id="e277" class="ln lo it bd le lp lq dn lr ls lt dp lu kb lv lw lx kf ly lz ma kj mb mc md me bi translated">2)为我们的基准设定硬性限制</h2><p id="4209" class="pw-post-body-paragraph jq jr it js b jt mf jv jw jx mg jz ka kb mh kd ke kf mi kh ki kj mj kl km kn im bi translated"><strong class="js iu"> 2.1)网络硬限制</strong></p><p id="d2fc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">网络带宽和延迟通常会直接影响Redis的性能。在进一步进行基准测试之前，我们将使用qperf检查基准测试和redis-server虚拟机之间的延迟。</p><p id="7e98" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以下输出的实验结果是针对单租户非拥塞网络的，其中没有来自其他应用程序的后台流量，因此没有网络干扰。</p><pre class="kp kq kr ks gt nc nb nd ne aw nf bi"><span id="5af8" class="ln lo it nb b gy ng nh l ni nj"><strong class="nb iu">fcosta_oliveira@n1-highcpu-96-redis-benchmark-1</strong>:<strong class="nb iu">~/qperf</strong>$ qperf -t 60 -v {ip of redis-server vm} tcp_bw <br/><strong class="nb iu">tcp_lattcp_bw:</strong>    <br/>   bw              =  3.05 GB/sec    <br/>   msg_rate        =  46.5 K/sec    <br/>   time            =    60 sec    <br/>   send_cost       =   248 ms/GB    <br/>   recv_cost       =   181 ms/GB    <br/>   send_cpus_used  =  75.6 % cpus    <br/>   recv_cpus_used  =  55.3 %<br/><strong class="nb iu">cpustcp_lat: </strong>   <br/>    latency        =  27.6 us    <br/>    msg_rate       =  36.3 K/sec    <br/>    time           =    60 sec    <br/>    loc_cpus_used  =  14.6 % cpus    <br/>    rem_cpus_used  =  15.9 % cpus</span></pre><p id="5767" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以观察到网络的实测带宽为3.05 GB/秒(24.4Gbits秒)。Redis中为每个键设置100个字节值的基准将被网络硬限制在大约每秒3200万次查询。</p><p id="d31b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> 2.2)内存硬限制</strong></p><p id="1da0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">浏览Redis官方文档，</p><blockquote class="lg lh li"><p id="22ea" class="jq jr lj js b jt ju jv jw jx jy jz ka lk kc kd ke ll kg kh ki lm kk kl km kn im bi translated">RAM的速度和内存带宽对于全局性能似乎不太重要，尤其是对于小对象。对于大对象(&gt; 10 KB)，这可能会变得很明显。</p></blockquote><p id="9751" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">尽管如此，我们将使用STREAM对VM内存带宽进行基准测试，这是一个旨在表示长向量上的操作的基准测试，广泛用于研究、测试和营销目的。</p><p id="8606" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以下命令获取流，并将数组大小设置为大于n1-highcpu-96缓存。我们已经重复了10次测试，并放弃了第一次。</p><pre class="kp kq kr ks gt nc nb nd ne aw nf bi"><span id="bdcb" class="ln lo it nb b gy ng nh l ni nj">git clone <a class="ae lf" href="https://github.com/jeffhammond/STREAM.git" rel="noopener ugc nofollow" target="_blank">https://github.com/jeffhammond/STREAM.git</a><br/>cd STREAM/<br/>gcc -fopenmp -D_OPENMP -O -DSTREAM_ARRAY_SIZE=100000000 stream.c -o stream.100M<br/>export OMP_NUM_THREADS=48<br/>./stream.100M</span></pre><p id="09ba" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">流的第二次运行如下所示。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="87c4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以观察到副本内核的最佳速率GB/s约为83GB/s。例如，Redis中为每个键设置100个字节值的基准测试会“天真地”受到VM内存的硬限制，约为每秒8.9亿次查询。我们没有考虑不同的内存访问模式和无效性——测得的最佳速率和硬限制只是相对粗略的估计。</p><h1 id="b8b0" class="np lo it bd le nq nr ns lr nt nu nv lu nw nx ny lx nz oa ob ma oc od oe md of bi translated">3)针对不同的配置运行基准测试</h1><p id="a2ae" class="pw-post-body-paragraph jq jr it js b jt mf jv jw jx mg jz ka kb mh kd ke kf mi kh ki kj mj kl km kn im bi translated">我们的实验研究从考虑内存密集型工作负载开始，这些工作负载执行具有不同特征的内存到内存网络I/O，即:</p><ul class=""><li id="04c2" class="mk ml it js b jt ju jx jy kb mm kf mn kj mo kn mp mq mr ms bi translated"><strong class="js iu">设置</strong>，向Redis服务器产生写请求。写请求时间复杂度为O(1)。</li><li id="de62" class="mk ml it js b jt mt jx mu kb mv kf mw kj mx kn mp mq mr ms bi translated"><strong class="js iu"> GET </strong>，生成对Redis服务器的读取请求。读请求时间复杂度为O(1)。</li><li id="51af" class="mk ml it js b jt mt jx mu kb mv kf mw kj mx kn mp mq mr ms bi translated"><strong class="js iu"> MSET </strong>，在数据结构上生成写请求，其中插入或检索数字比SET O(1)请求花费更高的时间复杂度O(N)，其中N是要设置的键的数量。</li><li id="d4e7" class="mk ml it js b jt mt jx mu kb mv kf mw kj mx kn mp mq mr ms bi translated"><strong class="js iu"> HSET </strong>，在更复杂的数据结构上生成写请求，但是其中插入操作具有与SET O(1)相同的时间复杂度。</li><li id="b75c" class="mk ml it js b jt mt jx mu kb mv kf mw kj mx kn mp mq mr ms bi translated"><strong class="js iu"> LRANGE </strong>前100个元素，生成对数据结构的读请求，其中检索数据的时间复杂度O(S+N)高于GET O(1)，这取决于到列表头部或尾部的距离(S)以及我们想要检索的元素数量(N)。</li><li id="a540" class="mk ml it js b jt mt jx mu kb mv kf mw kj mx kn mp mq mr ms bi translated"><strong class="js iu"> X_ADD </strong>，以仅附加数据结构生成写请求。该操作具有恒定的时间复杂度O(N)。我们将把这个操作的测试扩展到字段-值对的几种组合:XADD_1用于具有一个字段-值对的流，XADD_5用于具有五个字段-值对的流，XADD_10用于具有十个字段-值对的流。</li></ul><p id="6714" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所有工作负载都被配置为从内存中的Redis存储中产生/请求三种不同大小(3字节、100字节和1 KB)的对象。为了加速和减少基准测试过程中的手工工作，产生了下面的脚本。然而，我们仍然需要按需更改redis服务器io-threads配置。第3节将介绍在<strong class="js iu">n1-high CPU-96-redis-server-1</strong>和<strong class="js iu">n1-high CPU-96-redis-benchmark-1</strong>上运行所需的命令顺序。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nn no l"/></div></figure><h2 id="f902" class="ln lo it bd le lp lq dn lr ls lt dp lu kb lv lw lx kf ly lz ma kj mb mc md me bi translated">3.0)在基准虚拟机上:</h2><pre class="kp kq kr ks gt nc nb nd ne aw nf bi"><span id="9b5a" class="ln lo it nb b gy ng nh l ni nj"><strong class="nb iu">@n1-highcpu-96-redis-benchmark-1</strong>:<strong class="nb iu">/</strong>mkdir results</span></pre><h2 id="4cf0" class="ln lo it bd le lp lq dn lr ls lt dp lu kb lv lw lx kf ly lz ma kj mb mc md me bi translated">3.1)没有io线程</h2><p id="5b98" class="pw-post-body-paragraph jq jr it js b jt mf jv jw jx mg jz ka kb mh kd ke kf mi kh ki kj mj kl km kn im bi translated"><strong class="js iu"> 3.1.1)在redis-server虚拟机上:</strong></p><pre class="kp kq kr ks gt nc nb nd ne aw nf bi"><span id="a823" class="ln lo it nb b gy ng nh l ni nj"><strong class="nb iu">@n1-highcpu-96-redis-server-1</strong>:<strong class="nb iu">/</strong>redis-server — protected-mode no — save “” — appendonly no — io-threads 1</span></pre><p id="4f33" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">在基准虚拟机上:</strong></p><pre class="kp kq kr ks gt nc nb nd ne aw nf bi"><span id="ac5a" class="ln lo it nb b gy ng nh l ni nj"><strong class="nb iu">@n1-highcpu-96-redis-benchmark-1</strong>:<strong class="nb iu">/</strong>./<strong class="nb iu">run-redis-benchmark.sh</strong> “1000000” “10.168.0.2” “0” “./results”</span></pre><h2 id="af07" class="ln lo it bd le lp lq dn lr ls lt dp lu kb lv lw lx kf ly lz ma kj mb mc md me bi translated">3.2) 8个io线程</h2><p id="ae75" class="pw-post-body-paragraph jq jr it js b jt mf jv jw jx mg jz ka kb mh kd ke kf mi kh ki kj mj kl km kn im bi translated"><strong class="js iu"> 3.2.1)在redis-server虚拟机上:</strong></p><pre class="kp kq kr ks gt nc nb nd ne aw nf bi"><span id="58ec" class="ln lo it nb b gy ng nh l ni nj"><strong class="nb iu">@n1-highcpu-96-redis-server-1</strong>:<strong class="nb iu">/</strong>redis-server — protected-mode no — save “” — appendonly no — io-threads 8</span></pre><p id="5653" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> 3.2.2)在基准虚拟机上:</strong></p><pre class="kp kq kr ks gt nc nb nd ne aw nf bi"><span id="8922" class="ln lo it nb b gy ng nh l ni nj"><strong class="nb iu">@n1-highcpu-96-redis-benchmark-1</strong>:<strong class="nb iu">/</strong>./<strong class="nb iu">run-redis-benchmark.sh</strong> “1000000” “10.168.0.2” “8” “./results”</span></pre><h2 id="9df3" class="ln lo it bd le lp lq dn lr ls lt dp lu kb lv lw lx kf ly lz ma kj mb mc md me bi translated">3.3) 16个io线程</h2><p id="f1df" class="pw-post-body-paragraph jq jr it js b jt mf jv jw jx mg jz ka kb mh kd ke kf mi kh ki kj mj kl km kn im bi translated"><strong class="js iu"> 3.3.1)在redis-server虚拟机上:</strong></p><pre class="kp kq kr ks gt nc nb nd ne aw nf bi"><span id="8dad" class="ln lo it nb b gy ng nh l ni nj"><strong class="nb iu">@n1-highcpu-96-redis-server-1</strong>:<strong class="nb iu">/</strong>redis-server — protected-mode no — save “” — appendonly no — io-threads 16</span></pre><p id="2269" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> 3.3.2)在基准虚拟机上:</strong></p><pre class="kp kq kr ks gt nc nb nd ne aw nf bi"><span id="404c" class="ln lo it nb b gy ng nh l ni nj"><strong class="nb iu">@n1-highcpu-96-redis-benchmark-1</strong>:<strong class="nb iu">/</strong>./<strong class="nb iu">run-redis-benchmark.sh</strong>”1000000" “10.168.0.2” “16” “./results”</span></pre><h2 id="7fdc" class="ln lo it bd le lp lq dn lr ls lt dp lu kb lv lw lx kf ly lz ma kj mb mc md me bi translated">3.4) 24个io线程</h2><p id="83ec" class="pw-post-body-paragraph jq jr it js b jt mf jv jw jx mg jz ka kb mh kd ke kf mi kh ki kj mj kl km kn im bi translated"><strong class="js iu"> 3.4.1)在redis-server虚拟机上:</strong></p><pre class="kp kq kr ks gt nc nb nd ne aw nf bi"><span id="3c10" class="ln lo it nb b gy ng nh l ni nj"><strong class="nb iu">@n1-highcpu-96-redis-server-1</strong>:<strong class="nb iu">/</strong>redis-server — protected-mode no — save “” — appendonly no — io-threads 24</span></pre><p id="18f6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> 3.4.2)在基准虚拟机上:</strong></p><pre class="kp kq kr ks gt nc nb nd ne aw nf bi"><span id="1c8e" class="ln lo it nb b gy ng nh l ni nj"><strong class="nb iu">@n1-highcpu-96-redis-benchmark-1</strong>:<strong class="nb iu">/</strong>./<strong class="nb iu">run-redis-benchmark.sh</strong> “1000000” “10.168.0.2” “24” “./results”</span></pre><h2 id="e815" class="ln lo it bd le lp lq dn lr ls lt dp lu kb lv lw lx kf ly lz ma kj mb mc md me bi translated">3.5) 32个io线程</h2><p id="de42" class="pw-post-body-paragraph jq jr it js b jt mf jv jw jx mg jz ka kb mh kd ke kf mi kh ki kj mj kl km kn im bi translated"><strong class="js iu"> 3.5.1)在redis-server虚拟机上:</strong></p><pre class="kp kq kr ks gt nc nb nd ne aw nf bi"><span id="f994" class="ln lo it nb b gy ng nh l ni nj"><strong class="nb iu">@n1-highcpu-96-redis-server-1</strong>:<strong class="nb iu">/</strong>redis-server — protected-mode no — save “” — appendonly no — io-threads 32</span></pre><p id="b84b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> 3.5.2)在基准虚拟机上:</strong></p><pre class="kp kq kr ks gt nc nb nd ne aw nf bi"><span id="d6ba" class="ln lo it nb b gy ng nh l ni nj"><strong class="nb iu">@n1-highcpu-96-redis-benchmark-1</strong>:<strong class="nb iu">/</strong>./<strong class="nb iu">run-redis-benchmark.sh</strong> “1000000” “10.168.0.2” “32” “./results”</span></pre><h2 id="bd1e" class="ln lo it bd le lp lq dn lr ls lt dp lu kb lv lw lx kf ly lz ma kj mb mc md me bi translated">3.6) 48个io线程</h2><p id="2c7e" class="pw-post-body-paragraph jq jr it js b jt mf jv jw jx mg jz ka kb mh kd ke kf mi kh ki kj mj kl km kn im bi translated"><strong class="js iu"> 3.6.1)在redis-server虚拟机上:</strong></p><pre class="kp kq kr ks gt nc nb nd ne aw nf bi"><span id="f5e7" class="ln lo it nb b gy ng nh l ni nj"><strong class="nb iu">@n1-highcpu-96-redis-server-1</strong>:<strong class="nb iu">/</strong>redis-server — protected-mode no — save “” — appendonly no — io-threads 48</span></pre><p id="a7cf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> 3.6.2)在基准虚拟机上:</strong></p><pre class="kp kq kr ks gt nc nb nd ne aw nf bi"><span id="6853" class="ln lo it nb b gy ng nh l ni nj"><strong class="nb iu">@n1-highcpu-96-redis-benchmark-1</strong>:<strong class="nb iu">/</strong>./<strong class="nb iu">run-redis-benchmark.sh</strong> “1000000” “10.168.0.2” “48” “./results”</span></pre><h2 id="92bd" class="ln lo it bd le lp lq dn lr ls lt dp lu kb lv lw lx kf ly lz ma kj mb mc md me bi translated">3.7) 64个io线程</h2><p id="2602" class="pw-post-body-paragraph jq jr it js b jt mf jv jw jx mg jz ka kb mh kd ke kf mi kh ki kj mj kl km kn im bi translated"><strong class="js iu"> 3.7.1)在redis-server虚拟机上:</strong></p><pre class="kp kq kr ks gt nc nb nd ne aw nf bi"><span id="0f8d" class="ln lo it nb b gy ng nh l ni nj"><strong class="nb iu">@n1-highcpu-96-redis-server-1</strong>:<strong class="nb iu">/</strong>redis-server — protected-mode no — save “” — appendonly no — io-threads 64</span></pre><p id="a634" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> 3.7.2)在基准虚拟机上:</strong></p><pre class="kp kq kr ks gt nc nb nd ne aw nf bi"><span id="bf5f" class="ln lo it nb b gy ng nh l ni nj"><strong class="nb iu">@n1-highcpu-96-redis-benchmark-1</strong>:<strong class="nb iu">/</strong>./<strong class="nb iu">run-redis-benchmark.sh</strong>”1000000" “10.168.0.2” “64” “./results”</span></pre><h1 id="63a0" class="np lo it bd le nq nr ns lr nt nu nv lu nw nx ny lx nz oa ob ma oc od oe md of bi translated">4)提高了读写性能</h1><p id="5d76" class="pw-post-body-paragraph jq jr it js b jt mf jv jw jx mg jz ka kb mh kd ke kf mi kh ki kj mj kl km kn im bi translated">我们测量了16或24个io线程(取决于命令和工作负载)的较大性能提升。例如，我们已经将GET操作的每秒请求数从173，000个增加到了285，000个，使用24个io线程，每秒请求数增加了110，000个，加速提高了1.6倍。</p><p id="8b82" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">显而易见，当消息大小增加时，以每秒请求数表示的吞吐量会降低。如下所示，此行为与所有命令一致。</p><p id="430b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们决定单独绘制Redis STREAMS基准。对于流，改进与其他Redis操作不相上下，从没有io线程时每秒117，000个请求到有8个io线程时每秒210，000个请求。</p><p id="09be" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下图展示了单命令、5命令和10命令管道的每秒测量请求数。</p><h2 id="6e37" class="ln lo it bd le lp lq dn lr ls lt dp lu kb lv lw lx kf ly lz ma kj mb mc md me bi translated">4.1.1)单命令性能(无流水线)</h2><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi og"><img src="../Images/e56ccd73650a8e126b0423668d8dc588.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_MWvBT3AxEahBs5nCWcUZw.png"/></div></div></figure><h2 id="4df4" class="ln lo it bd le lp lq dn lr ls lt dp lu kb lv lw lx kf ly lz ma kj mb mc md me bi translated">4.1.2 ) Redis流单命令性能(无流水线)</h2><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi og"><img src="../Images/8f844830b860ed6276bebed604080f32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lRelZRqSekw_tSjtwLYMEw.png"/></div></div></figure><h2 id="db84" class="ln lo it bd le lp lq dn lr ls lt dp lu kb lv lw lx kf ly lz ma kj mb mc md me bi translated">4.1.3 ) 5命令管道性能</h2><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi og"><img src="../Images/346477470b9fbe3978c23964763bedf9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oCeJFsykBtiLzBHdLXGkwg.png"/></div></div></figure><h2 id="b0da" class="ln lo it bd le lp lq dn lr ls lt dp lu kb lv lw lx kf ly lz ma kj mb mc md me bi translated">4.1.4 ) Redis STREAMS 5命令管道性能</h2><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi og"><img src="../Images/27a6846eb503418c19440c7e8ac20c4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hKRmZV6FtiRFinngEO_xGA.png"/></div></div></figure><h2 id="cc53" class="ln lo it bd le lp lq dn lr ls lt dp lu kb lv lw lx kf ly lz ma kj mb mc md me bi translated">4.1.5 ) 10命令管道性能</h2><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi og"><img src="../Images/d2c76891db436a3635b669497b4b28c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9o-d6gGbj2CSCoBOGx2syA.png"/></div></div></figure><h2 id="c585" class="ln lo it bd le lp lq dn lr ls lt dp lu kb lv lw lx kf ly lz ma kj mb mc md me bi translated">4.1.6 ) Redis流10命令管道性能</h2><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi og"><img src="../Images/b4bb07ea893812940f15613642fb38b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YhpmmxAfH0n51LRhmlXSYg.png"/></div></div></figure><h2 id="2be0" class="ln lo it bd le lp lq dn lr ls lt dp lu kb lv lw lx kf ly lz ma kj mb mc md me bi translated">4.2)分析实验Redis多线程I/O的堆栈跟踪</h2><p id="34d7" class="pw-post-body-paragraph jq jr it js b jt mf jv jw jx mg jz ka kb mh kd ke kf mi kh ki kj mj kl km kn im bi translated">如果您使用Linux perf_events(又名“perf”)对SET命令工作负载上的16个线程在<strong class="js iu">n1-high cpu-96-redis-server-1</strong>VM、<strong class="js iu"> </strong>中再次分析redis-server堆栈跟踪，您将获得一个CPU火焰图，类似于下图。<strong class="js iu">我们已经把45%到5%的时间花在给fd写信上了。</strong></p><blockquote class="oh"><p id="c99a" class="oi oj it bd ok ol om on oo op oq kn dk translated">我们已经花了45%到5%的时间给fd写信。</p></blockquote><figure class="ot ou ov ow ox kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi os"><img src="../Images/ebd6cd4ba2eccf7198527254cb05718f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CCqzBWhOzUqeeNPXHKF-og.png"/></div></div></figure><h1 id="b000" class="np lo it bd le nq nr ns lr nt nu nv lu nw nx ny lx nz oa ob ma oc od oe md of bi translated">结论</h1><p id="f15f" class="pw-post-body-paragraph jq jr it js b jt mf jv jw jx mg jz ka kb mh kd ke kf mi kh ki kj mj kl km kn im bi translated">我们对多线程在读写操作方面的改进进行了基准测试。然而，这些相同的io线程可以用于命令处理和其他不受CPU限制的操作。</p><p id="f47e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">引用<a class="ae lf" href="https://twitter.com/antirez/status/1117308774459555841" rel="noopener ugc nofollow" target="_blank">萨尔瓦托</a>:</p><blockquote class="oh"><p id="da27" class="oi oj it bd ok ol om on oo op oq kn dk translated">将请求解析放在相同的代码路径中的工作仍在继续。</p></blockquote><p id="a7e0" class="pw-post-body-paragraph jq jr it js b jt oy jv jw jx oz jz ka kb pa kd ke kf pb kh ki kj pc kl km kn im bi translated">多线程自然比单线程有更高的性能极限，但在如今的云计算环境和挑战下，连单机的上限也往往不够。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi pd"><img src="../Images/b16668d09243a0e15f6316582e31ab60.png" data-original-src="https://miro.medium.com/v2/resize:fit:978/format:webp/0*eNoeCqxvS6X75Rq1.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">来自<a class="ae lf" href="https://www.networkcomputing.com/data-centers/100-gbps-headed-data-centers" rel="noopener ugc nofollow" target="_blank">https://www . network computing . com/Data-centers/100-Gbps-Headed-Data-centers</a>的“100 Gbps走向数据中心”</figcaption></figure><p id="b35b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">由于主要云提供商采用了40 Gbps和100Gbps网络适配器的新标准(AWS的<a class="ae lf" href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/enhanced-networking-ena.html" rel="noopener ugc nofollow" target="_blank">弹性网络适配器</a>、Azure的<a class="ae lf" href="https://azure.microsoft.com/en-us/blog/azure-networking-fall-2018-update/" rel="noopener ugc nofollow" target="_blank"> ExpressRoute Direct </a>和<a class="ae lf" href="https://azure.microsoft.com/en-us/blog/introducing-the-new-hb-and-hc-azure-vm-sizes-for-hpc/" rel="noopener ugc nofollow" target="_blank">具有100 Gbps连接的HB和HC Azure虚拟机</a>以及GCP的<a class="ae lf" href="https://cloud.google.com/vpc/docs/quota#per_instance" rel="noopener ugc nofollow" target="_blank"> 32 Gbps)，网络带宽很快就会作为第一个瓶颈消失。因此，我们需要考虑的是如何利用网络适配器的多核优势和性能优势。</a></p><p id="018a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">需要进一步探索的是一种多实例集群解决方案，在这种方案中，可以使用多线程技术来改进每个独立的redis-server实例。这是我们将在下一篇文章中深入探讨的内容。</p><p id="5afc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如前所述，在Redis中为每个键设置100字节值的基准测试，将被网络硬限制在每VM每秒3200万次查询左右。即使对于1000字节的值，Redis也只能被网络硬限制在每VM每秒300万次查询左右。我们将需要16个独立的redis实例，每台redis服务器每秒20万次查询的速度来填满网络。</p><p id="bae1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Redis Labs在公共云提供商亚马逊的26个EC2节点上创造了每秒5000万次操作的记录，这意味着每个实例每秒的2M请求数。然而，借助专为计算密集型应用设计的新AWS公共云<a class="ae lf" href="https://aws.amazon.com/blogs/aws/new-c5n-instances-with-100-gbps-networking/" rel="noopener ugc nofollow" target="_blank"> C5n实例</a>并提供与裸机几乎无差别的性能，借助100 Gbps网络以及每秒更高的数据包上限，我们应该能够以更少的虚拟机节点在1毫秒内提供至少相同的5000万次操作，并利用开源Redis版本严格打破Redis实验室记录。</p></div></div>    
</body>
</html>