<html>
<head>
<title>Next.js Awesome Typescript integration</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Next.js出色的类型脚本集成</h1>
<blockquote>原文：<a href="https://itnext.io/next-js-awesome-typescript-integration-d05cfe9af057?source=collection_archive---------1-----------------------#2018-04-16">https://itnext.io/next-js-awesome-typescript-integration-d05cfe9af057?source=collection_archive---------1-----------------------#2018-04-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/ef5d6495afd00f06aff15cd209c61e79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9mESIE8IL4eEFZ6FIO4smA.png"/></div></div></figure><p id="a4dd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">很多人喜欢Next.js，很多人喜欢Typescript。所以，最终会有一群人想要一起使用它们，你可以猜到，这已经发生了。那么，我们有什么选择呢？默认的是使用官方的Zeit的<code class="fe kw kx ky kz b"><a class="ae la" href="https://github.com/zeit/next-plugins/tree/master/packages/next-typescript" rel="noopener ugc nofollow" target="_blank">next-typescript</a></code>包。它使用了<code class="fe kw kx ky kz b">ts-loader</code>并且运行良好，但是在webpack-typescript-loaders市场上有第二个人物(如果不是一个的话):它是<code class="fe kw kx ky kz b"><a class="ae la" href="https://github.com/s-panferov/awesome-typescript-loader" rel="noopener ugc nofollow" target="_blank">awesome-typescript-loader</a></code>。使用它的主要原因是它的<a class="ae la" href="https://github.com/s-panferov/awesome-typescript-loader#differences-between-ts-loader" rel="noopener ugc nofollow" target="_blank">性能优化</a>:与<code class="fe kw kx ky kz b">babel</code>的集成(这是Next.js的完美案例)和在单独的进程中运行类型检查器(你也可以用<code class="fe kw kx ky kz b"><a class="ae la" href="https://github.com/Realytics/fork-ts-checker-webpack-plugin" rel="noopener ugc nofollow" target="_blank">fork-ts-checker-webpack-plugin</a></code>来做，但是包含电池是一件好事)。请注意，<a class="ae la" href="https://github.com/s-panferov/awesome-typescript-loader/issues/497" rel="noopener ugc nofollow" target="_blank">并不总是比<code class="fe kw kx ky kz b">ts-loader</code>快</a>，所以不要不经过实际测量就盲目切换。但是通常只要正确使用它，编译时间就会大大增加，所以让我们开始尝试将Next.js与令人敬畏的Typescript Loader集成起来，耶！</p><blockquote class="lb lc ld"><p id="c4c6" class="jy jz le ka b kb kc kd ke kf kg kh ki lf kk kl km lg ko kp kq lh ks kt ku kv ij bi translated">第一号免责声明:⚠️这仅兼容Next.js v5️，不兼容v6，详见<a class="ae la" href="https://github.com/saitonakamura/next-awesome-typescript/issues/8#issuecomment-394487142" rel="noopener ugc nofollow" target="_blank">本推理</a></p><p id="313b" class="jy jz le ka b kb kc kd ke kf kg kh ki lf kk kl km lg ko kp kq lh ks kt ku kv ij bi translated">第一号声明:如果你对细节感兴趣，你可以直接使用我的<code class="fe kw kx ky kz b"><a class="ae la" href="https://github.com/saitonakamura/next-awesome-typescript" rel="noopener ugc nofollow" target="_blank">next-awesome-typescript</a></code> <a class="ae la" href="https://github.com/saitonakamura/next-awesome-typescript" rel="noopener ugc nofollow" target="_blank">插件</a></p></blockquote><p id="c51e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以，我们想做的第一件事是使用这个超级棒的Next.js v5特性，称为<a class="ae la" href="https://zeit.co/blog/next5#universal-webpack-and-next-plugins" rel="noopener ugc nofollow" target="_blank">通用Webpack </a>，因为它允许我们以某种方式改变默认的Next.js webpack配置。您可以通过在<code class="fe kw kx ky kz b">next.config.js</code>文件中提供<code class="fe kw kx ky kz b">webpack</code>函数和其他配置来实现。</p><figure class="li lj lk ll gt jr"><div class="bz fp l di"><div class="lm ln l"/></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk translated">如何修改Next.js默认webpack配置</figcaption></figure><p id="ea60" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好了，让我们加上<code class="fe kw kx ky kz b">awesome-typescript-loader</code>。</p><figure class="li lj lk ll gt jr"><div class="bz fp l di"><div class="lm ln l"/></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk translated">如何将awesome-typescript-loader添加到Next.js webpack配置</figcaption></figure><p id="8794" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请注意带有<code class="fe kw kx ky kz b">defaultLoaders.babel</code>的那一行，因为它基本上意味着我们首先通过两个加载器<code class="fe kw kx ky kz b">awesome-typescript-loader</code>，然后通过Next.js配置通过<code class="fe kw kx ky kz b">babel-loader</code>运行我们的文件。为了让<code class="fe kw kx ky kz b">babel</code>为我们完成大部分的传输工作，我们需要通知<code class="fe kw kx ky kz b">typescript</code>我们的意图。为此，我们将创建<code class="fe kw kx ky kz b">tsconfig.json</code>(如果您之前没有)。最小的会是这个样子。</p><figure class="li lj lk ll gt jr"><div class="bz fp l di"><div class="lm ln l"/></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk translated">最小tsconfig.json</figcaption></figure><p id="d583" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">就这样，应该能行！但是现在我们的配置在速度方面并不比<code class="fe kw kx ky kz b">next-typescript</code>好。我们从巴别塔整合开始。为此，我们需要在<code class="fe kw kx ky kz b">awesome-typescript-loader</code>配置中启用<code class="fe kw kx ky kz b">useBabel</code>选项，并将Next.js默认的babel配置传递给<code class="fe kw kx ky kz b">babelOptions</code>。这里的问题是Next.js默认的babel配置包含<code class="fe kw kx ky kz b">cacheDirectory</code>选项，这在babel集成的上下文中是不适用的，因为缓存是常见的，所以我们需要省略它。我在这里写了小而简单的<code class="fe kw kx ky kz b">omit</code> helper，但是你可以自由地使用任何你想要的方法:lodash，ramda，object destructing等等。</p><figure class="li lj lk ll gt jr"><div class="bz fp l di"><div class="lm ln l"/></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk translated">如何添加巴别塔集成</figcaption></figure><p id="75ba" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请注意，我们删除了<code class="fe kw kx ky kz b">defaultLoaders.babel</code>。我们要采取的下一步是启用缓存。</p><figure class="li lj lk ll gt jr"><div class="bz fp l di"><div class="lm ln l"/></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk translated">如何添加缓存</figcaption></figure><p id="8f7b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后一种方法是使用<code class="fe kw kx ky kz b">CheckerPlugin</code>在一个单独的进程中运行typecheck，以进一步加快编译时间。</p><figure class="li lj lk ll gt jr"><div class="bz fp l di"><div class="lm ln l"/></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk translated">如何在单独的进程中运行typecheck</figcaption></figure><p id="bf0a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，我们编写了一个相当具有编译性能的Next.js类型脚本配置。当然，手动编写webpack配置可能很麻烦，但不用担心，我写了一个<code class="fe kw kx ky kz b"><a class="ae la" href="https://github.com/saitonakamura/next-awesome-typescript" rel="noopener ugc nofollow" target="_blank">next-awesome-typescript</a></code> <a class="ae la" href="https://github.com/saitonakamura/next-awesome-typescript" rel="noopener ugc nofollow" target="_blank">插件</a>，它可以完成所有这些，甚至更多！随意放置一颗星星，提出一个问题，留下评论，订阅t̶o̶̶m̶o̶r̶e̶̶w̶e̶e̶k̶l̶y̶̶s̶c̶i̶e̶n̶c̶e̶̶v̶i̶d̶e̶o̶s，对不起，我的媒体:)</p></div></div>    
</body>
</html>