<html>
<head>
<title>Implementing Arithmetic Within TypeScript’s Type System</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在TypeScript的类型系统中实现算法</h1>
<blockquote>原文：<a href="https://itnext.io/implementing-arithmetic-within-typescripts-type-system-a1ef140a6f6f?source=collection_archive---------1-----------------------#2020-11-29">https://itnext.io/implementing-arithmetic-within-typescripts-type-system-a1ef140a6f6f?source=collection_archive---------1-----------------------#2020-11-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/0c618560b9b0490c024d6ad1e58ba9af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*loN_JL3n0EcLTAUF"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@mbaumi?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">米卡·鲍梅斯特</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="43f3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我在工作中经常使用TypeScript，并且我喜欢创建精细优雅的类型来准确地模拟我正在解决的问题的约束。我发现只要有足够的独创性(和探索)，我就能实现我所需要的。然而，有时我会遇到这样的情况，我需要的类型超出了TypeScript当前的能力，我发现自己被迫编写类型断言，如果TypeScript更具表达性，我会觉得这是不必要的。</p><p id="36ed" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">偶尔TypeScript会发布一个版本，增加额外的功能来克服我必须明确修补的一些限制。整个4.x发布系列就是一个这样的例子，它使以前不可能的构建类型的方法成为可能。为了纪念最近发布的4.1版本，我想介绍一些最新的特性，并通过展示我们如何使用它们来创建一个算术系统，来展示我们现在拥有的能力。</p><p id="1e96" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">显然，如果我们给自己提供了TypeScript的全部功能，那么在TypeScript中做算术是微不足道的，所以我将把我们的解决方案限制在我们完全可以在类型系统中做的事情上。这意味着我们没有能力使用像<code class="fe lb lc ld le b">+</code>和<code class="fe lb lc ld le b">-</code>这样的简单操作符，我们构建的任何东西都必须使用TypeScript的方法来组合和操作类型。换句话说，我们将把自己限制在我们能对<code class="fe lb lc ld le b">type SomeType = ...</code>宣言做些什么。</p><p id="875d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的目标是拥有像<code class="fe lb lc ld le b">Add</code>这样的类型，它可以接受两个数字文字类型并确定它们的和。所以我们希望<code class="fe lb lc ld le b">Add&lt;3, 5&gt;</code>为我们生成文字<code class="fe lb lc ld le b">8</code>。</p><p id="1ece" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们看看建立我们的算术系统需要哪些重要的特征。</p><h1 id="ee07" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">初始基础</h1><p id="47a0" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">为了构建基于类型的算法，我们将在很大程度上依赖于TypeScript的一些老的熟悉特性:</p><ul class=""><li id="d2d5" class="mi mj iq kf b kg kh kk kl ko mk ks ml kw mm la mn mo mp mq bi translated">条件类型</li><li id="92e7" class="mi mj iq kf b kg mr kk ms ko mt ks mu kw mv la mn mo mp mq bi translated">类型推理</li><li id="daa4" class="mi mj iq kf b kg mr kk ms ko mt ks mu kw mv la mn mo mp mq bi translated">通用约束</li></ul><p id="99b9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们需要在此列表中添加在4.x发布周期中添加的某些功能:</p><ul class=""><li id="bf41" class="mi mj iq kf b kg kh kk kl ko mk ks ml kw mm la mn mo mp mq bi translated">条件类型中的递归</li><li id="2a9b" class="mi mj iq kf b kg mr kk ms ko mt ks mu kw mv la mn mo mp mq bi translated">可变元组</li><li id="19d3" class="mi mj iq kf b kg mr kk ms ko mt ks mu kw mv la mn mo mp mq bi translated">模板文字类型</li></ul><p id="e1f5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">虽然对这些特性的深入讨论超出了本文的范围，但是在我们说明它们在我们的系统中的使用时，有必要进行一个简短的讨论，以确保一些共同点。</p><p id="654f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一个<strong class="kf ir">条件类型</strong>仅仅是形式<code class="fe lb lc ld le b">SomeType extends AnotherType ? TrueType : FalseType</code>的某种东西。这是一种向类型添加if/else结构的方法，这样我们就可以根据<code class="fe lb lc ld le b">extends</code>条件的求值方式在两个不同的类型之间切换。</p><p id="53d4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">类型推理</strong>是一个在条件类型表达式中使用的强大内省工具。它的主要目标是从一个复杂类型中提取出组成它的其他类型。一个人为的例子是从数组中提取类型:<code class="fe lb lc ld le b">type Flatten&lt;T&gt; = T extends (infer U)[] ? U : T</code>。然后我们可以调用<code class="fe lb lc ld le b">Flatten&lt;[number, string, object]&gt;</code>来获取数组元素的底层类型(<code class="fe lb lc ld le b">number | string | object</code>)。</p><p id="1314" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">泛型约束给了我们一种创建泛型类型的方法，同时指定泛型期望用什么类型来实例化。因此，<code class="fe lb lc ld le b">type Flatten&lt;T&gt;</code>允许<code class="fe lb lc ld le b">T</code>成为任何可能的类型，而<code class="fe lb lc ld le b">type Flatten&lt;T extends any[]&gt;</code>要求<code class="fe lb lc ld le b">T</code>是可分配给数组的类型。</p><p id="ca0a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">递归条件类型</strong>允许条件类型的一个分支引用自身，并通过条件类型的逻辑递归任意次。但是，像所有递归一样，它必须停止，所以一个分支需要进行终止检查。在4.1版本之前，尝试递归类型会给我们带来错误<code class="fe lb lc ld le b">Type alias 'SomeType' circularly references itself</code>。</p><p id="b7b6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一个<strong class="kf ir">可变元组</strong>赋予我们在另一个元组中自由使用扩展操作符的能力，以便创建一些新的元组类型，直接对应于其组件的级联类型。因此我们可以获取一个元组<code class="fe lb lc ld le b">type Booleans = [boolean, boolean]</code>并派生出一个新的元组<code class="fe lb lc ld le b">type Derived = [...Booleans, string]</code>，其类型为<code class="fe lb lc ld le b">[boolean, boolean, string]</code>。</p><p id="133b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，<strong class="kf ir">模板文字类型</strong>使用模板文字语法从其他字符串文字类型形成字符串文字类型。我们可以采用类似<code class="fe lb lc ld le b">type ClickEvent = 'click'</code>的类型，并派生出它的事件处理程序类型<code class="fe lb lc ld le b">type ClickEventHandler = `on${ClickEvent}`</code> ( <code class="fe lb lc ld le b">'onclick'</code>)。</p><h1 id="b6d9" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">快速概述我们的方法</h1><p id="2766" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">在高层次上，我们操作数字文字类型的目标(正如我们前面所说的，我们不能使用典型的算术运算符)直接取决于我们将它们与一些更容易操作的类型相关联的能力。所以我们的基本方法是:</p><ol class=""><li id="3c7b" class="mi mj iq kf b kg kh kk kl ko mk ks ml kw mm la mw mo mp mq bi translated">将每个数字文字映射到该长度的元组</li><li id="36c5" class="mi mj iq kf b kg mr kk ms ko mt ks mu kw mv la mw mo mp mq bi translated">使用新发现的可变功能操纵元组</li><li id="d316" class="mi mj iq kf b kg mr kk ms ko mt ks mu kw mv la mw mo mp mq bi translated">将结果元组映射回它的数字文本对应物</li></ol><p id="c4a9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">假设我们的算法的基础是元组，我们自然会被限制在对自然数实现算法。元组没有小数或负长度的概念，因此我们同样没有能力处理这些类型的数字。这种无意义的输入与我们无关，因为我们将看到如何保证我们的系统只对非负整数进行操作。</p><p id="1aaa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将使用第1-3点的机制来实现最基本的算术运算(尽管我们<em class="mx">可以</em>实现更多的运算):</p><ul class=""><li id="8e74" class="mi mj iq kf b kg kh kk kl ko mk ks ml kw mm la mn mo mp mq bi translated">添加</li><li id="01c0" class="mi mj iq kf b kg mr kk ms ko mt ks mu kw mv la mn mo mp mq bi translated">减法</li><li id="ee49" class="mi mj iq kf b kg mr kk ms ko mt ks mu kw mv la mn mo mp mq bi translated">增加</li><li id="3af9" class="mi mj iq kf b kg mr kk ms ko mt ks mu kw mv la mn mo mp mq bi translated">分开</li><li id="cd0c" class="mi mj iq kf b kg mr kk ms ko mt ks mu kw mv la mn mo mp mq bi translated">以…为模</li></ul><h1 id="18e5" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">构建系统</h1><h2 id="1adf" class="my lg iq bd lh mz na dn ll nb nc dp lp ko nd ne lt ks nf ng lx kw nh ni mb nj bi translated">基本公用事业</h2><p id="6801" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">我们完成目标所需的基本类型是满足我们概述中列出的第1点和第3点的类型。尽管它们对我们的项目至关重要，但它们是相当简单的类型。我们将从构建点3的类型开始。</p><pre class="nk nl nm nn gt no le np nq aw nr bi"><span id="7295" class="my lg iq le b gy ns nt l nu nv">type Length&lt;T extends any[]&gt; = <br/>    T extends { length: infer L } ? L : never;</span></pre><p id="f877" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了将一个元组映射回一个数字，我们利用了这样一个事实，即它们可赋给数组，具有一个<code class="fe lb lc ld le b">length</code>属性，因此我们将它<code class="fe lb lc ld le b">infer</code>出来。</p><p id="60d1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第1点的类型(将一个数字映射到一个元组)稍微复杂一些。</p><pre class="nk nl nm nn gt no le np nq aw nr bi"><span id="a26c" class="my lg iq le b gy ns nt l nu nv">type BuildTuple&lt;L extends number, T extends any[] = []&gt; = <br/>    T extends { length: L } ? T : BuildTuple&lt;L, [...T, any]&gt;;</span></pre><p id="c2fa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们稍微解释一下这种类型。<code class="fe lb lc ld le b">BuildTuple</code>接受一个数字文字类型<code class="fe lb lc ld le b">L</code>，它应该是最后一个元组的长度，以及一个类似数组的类型<code class="fe lb lc ld le b">T</code>，它将最终成为那个元组。我们首先检查我们的<code class="fe lb lc ld le b">T</code>元组是否具有期望的长度<code class="fe lb lc ld le b">L</code>，如果是，则返回它。如果没有，我们向tuple添加一个元素，并递归到另一个迭代<code class="fe lb lc ld le b">BuildTuple</code>(不过这次是用增加的tuple)。以这种方式，我们不断增加元组的大小，直到它达到期望的长度。</p><p id="dc74" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在行动中，我们的类型给我们以下结果:</p><pre class="nk nl nm nn gt no le np nq aw nr bi"><span id="a0f3" class="my lg iq le b gy ns nt l nu nv">let length: Length&lt;[number, string, string, boolean]&gt;; // `4`<br/>let tuple: BuildTuple&lt;5&gt;; // `[any, any, any, any, any]`</span></pre><h2 id="836f" class="my lg iq bd lh mz na dn ll nb nc dp lp ko nd ne lt ks nf ng lx kw nh ni mb nj bi translated">基本算术</h2><p id="9c94" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">有了这些基本类型，我们现在可以构建我们的第一个算术类型:<code class="fe lb lc ld le b">Add</code>和<code class="fe lb lc ld le b">Subtract</code>。</p><pre class="nk nl nm nn gt no le np nq aw nr bi"><span id="8a5f" class="my lg iq le b gy ns nt l nu nv">type Add&lt;A extends number, B extends number&gt; = <br/>    Length&lt;[...BuildTuple&lt;A&gt;, ...BuildTuple&lt;B&gt;]&gt;;</span><span id="042d" class="my lg iq le b gy nw nt l nu nv">type Subtract&lt;A extends number, B extends number&gt; = <br/>    BuildTuple&lt;A&gt; extends [...(infer U), ...BuildTuple&lt;B&gt;]<br/>        ? Length&lt;U&gt;<br/>        : never;</span></pre><p id="1695" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">Add</code>是一个简单的类型，它构建两个元组，每个元组是其中一个输入的长度，组合这些元组，并确定结果元组的长度。</p><p id="5bb2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">Subtract</code>对表达式<code class="fe lb lc ld le b">A — B</code>建模(因此<code class="fe lb lc ld le b">A</code>需要大于<code class="fe lb lc ld le b">B</code>以使结果为自然数)，并通过构建一个长度为<code class="fe lb lc ld le b">A</code>的大型元组并将其分配给一个由长度为<code class="fe lb lc ld le b">B</code>的元组和一些余数元组(我们的<code class="fe lb lc ld le b">infer U</code>)构建的可变元组来执行其工作。这个<code class="fe lb lc ld le b">U</code>元组弥补了<code class="fe lb lc ld le b">A</code>和<code class="fe lb lc ld le b">B</code>的值之差，所以我们返回它的长度。</p><p id="ec69" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在代码中使用这些，我们得到以下结果:</p><pre class="nk nl nm nn gt no le np nq aw nr bi"><span id="a117" class="my lg iq le b gy ns nt l nu nv">let five: Add&lt;3, 2&gt;; // `5`<br/>let one: Subtract&lt;3, 2&gt;; // `1`</span></pre><h2 id="8f2e" class="my lg iq bd lh mz na dn ll nb nc dp lp ko nd ne lt ks nf ng lx kw nh ni mb nj bi translated">更复杂的工具</h2><p id="ba9c" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">为了构建<code class="fe lb lc ld le b">Multiply</code>和<code class="fe lb lc ld le b">Divide</code>的类型，我们需要一些比我们现有的更强大的实用程序类型。由于乘法实际上只是重复的加法，我们将需要一个能够累加我们的<code class="fe lb lc ld le b">Add</code>类型的多次迭代结果的类型。</p><pre class="nk nl nm nn gt no le np nq aw nr bi"><span id="2b5c" class="my lg iq le b gy ns nt l nu nv">type MultiAdd&lt;<br/>    N extends number, A extends number, I extends number<br/>&gt; = I extends 0 ? A : MultiAdd&lt;N, Add&lt;N, A&gt;, Subtract&lt;I, 1&gt;&gt;;</span></pre><p id="9ca4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种类型的输入表示我们想要重复相加的数字<code class="fe lb lc ld le b">N</code>,存储每个<code class="fe lb lc ld le b">Add</code>操作结果的数字<code class="fe lb lc ld le b">A</code>,以及跟踪还剩下多少次迭代的数字<code class="fe lb lc ld le b">I</code>。</p><p id="bb00" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，执行<code class="fe lb lc ld le b">8 * 3</code>将意味着<code class="fe lb lc ld le b">8</code>被加上自身的<code class="fe lb lc ld le b">3</code>倍，我们应该将这两个数分别赋给<code class="fe lb lc ld le b">N</code>和<code class="fe lb lc ld le b">I</code>。<code class="fe lb lc ld le b">A</code>是蓄能器，应该从<code class="fe lb lc ld le b">0</code>开始。在每次迭代中，我们从<code class="fe lb lc ld le b">I</code>的当前值中减去<code class="fe lb lc ld le b">1</code>，并将<code class="fe lb lc ld le b">N</code>加到<code class="fe lb lc ld le b">A</code>的当前值中。最终，<code class="fe lb lc ld le b">I</code>将向下工作到<code class="fe lb lc ld le b">0</code>，此时存储在<code class="fe lb lc ld le b">A</code>中的值是我们两个数的乘积。</p><p id="932a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">(欧几里得)除法同样是减法的重复使用，所以我们可以构建一个类似的实用程序来处理它。然而，因为我们需要在<code class="fe lb lc ld le b">A</code>小于<code class="fe lb lc ld le b">B</code>的任何时候终止我们的重复减法例程，所以它的实现需要额外的实用程序。</p><pre class="nk nl nm nn gt no le np nq aw nr bi"><span id="3eff" class="my lg iq le b gy ns nt l nu nv">type EQ&lt;A, B&gt; =<br/>    A extends B<br/>        ? (B extends A ? true : false)<br/>        : false;</span><span id="839f" class="my lg iq le b gy nw nt l nu nv">type AtTerminus&lt;A extends number, B extends number&gt; = <br/>    A extends 0<br/>        ? true<br/>        : (B extends 0 ? true : false);</span><span id="c176" class="my lg iq le b gy nw nt l nu nv">type LT&lt;A extends number, B extends number&gt; = <br/>    AtTerminus&lt;A, B&gt; extends true<br/>        ? EQ&lt;A, B&gt; extends true<br/>            ? false<br/>            : (A extends 0 ? true : false)<br/>        : LT&lt;Subtract&lt;A, 1&gt;, Subtract&lt;B, 1&gt;&gt;;</span><span id="3c67" class="my lg iq le b gy nw nt l nu nv">type MultiSub&lt;<br/>    N extends number, D extends number, Q extends number<br/>&gt; = LT&lt;N, D&gt; extends true<br/>    ? Q<br/>    : MultiSub&lt;Subtract&lt;N, D&gt;, D, Add&lt;Q, 1&gt;&gt;;</span></pre><p id="c335" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们分析一下我们在这里做什么。</p><p id="0707" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">简单地检查两种类型是否可以互相分配。如果是这样，它们一定是同一类型，所以我们断定它们是相等的。这意味着<code class="fe lb lc ld le b">EQ&lt;1, 3&gt;</code>是<code class="fe lb lc ld le b">false</code>，而<code class="fe lb lc ld le b">EQ&lt;3, 3&gt;</code>是<code class="fe lb lc ld le b">true</code>。</p><p id="623e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">AtTerminus</code>检查<code class="fe lb lc ld le b">A</code>或<code class="fe lb lc ld le b">B</code>是否为<code class="fe lb lc ld le b">0</code>，如果是则指示<code class="fe lb lc ld le b">true</code>。这是为了以后，当我们从<code class="fe lb lc ld le b">A</code>和<code class="fe lb lc ld le b">B</code>中减去时，我们确保我们不会迭代超过<code class="fe lb lc ld le b">0</code>，从而使两个中的一个为负(因为这些也不是为我们的目的而定义的)。</p><p id="4de7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">LT</code>是一个小于操作。它检查我们是否已经到达终点(意味着<code class="fe lb lc ld le b">A</code>或<code class="fe lb lc ld le b">B</code>或两者都是<code class="fe lb lc ld le b">0</code>),如果没有，重复地从每个输入中减去<code class="fe lb lc ld le b">1</code>。如果我们已经到达终点，那么它检查<code class="fe lb lc ld le b">A</code>和<code class="fe lb lc ld le b">B</code>是否相等。他们相等的意思是<code class="fe lb lc ld le b">A</code>是<em class="mx">不是</em>小于<code class="fe lb lc ld le b">B</code>(由于<code class="fe lb lc ld le b">4</code>不小于<code class="fe lb lc ld le b">4</code>)，所以我们返回<code class="fe lb lc ld le b">false</code>。但是如果它们不相等，那么只有一个命中了<code class="fe lb lc ld le b">0</code>，所以如果<code class="fe lb lc ld le b">A</code>命中了，我们就返回<code class="fe lb lc ld le b">true</code>。</p><p id="908d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，<code class="fe lb lc ld le b">MultiSub</code>取一个数<code class="fe lb lc ld le b">N</code>、一个除数<code class="fe lb lc ld le b">D</code>和一个商<code class="fe lb lc ld le b">Q</code>，该商表示在每次迭代中从<code class="fe lb lc ld le b">N</code>中减去了多少次<code class="fe lb lc ld le b">D</code>。一旦<code class="fe lb lc ld le b">N</code>变得小于<code class="fe lb lc ld le b">D</code>，我们的减法就停止，我们返回<code class="fe lb lc ld le b">Q</code>我们递归的次数。</p><p id="6fdf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，做<code class="fe lb lc ld le b">8 / 3</code>意味着<code class="fe lb lc ld le b">N</code>和<code class="fe lb lc ld le b">D</code>应该分别被分配<code class="fe lb lc ld le b">8</code>和<code class="fe lb lc ld le b">3</code>。<code class="fe lb lc ld le b">Q</code>将从<code class="fe lb lc ld le b">0</code>开始(因为我们在<code class="fe lb lc ld le b">MultiSub</code>的第一次迭代中没有减去任何东西)，并且每次我们从<code class="fe lb lc ld le b">8</code>中减去<code class="fe lb lc ld le b">3</code>，我们就增加<code class="fe lb lc ld le b">Q</code>，直到<code class="fe lb lc ld le b">LT</code>检查为<code class="fe lb lc ld le b">true</code>。此时<code class="fe lb lc ld le b">Q</code>代表我们除法的商。</p><h2 id="9253" class="my lg iq bd lh mz na dn ll nb nc dp lp ko nd ne lt ks nf ng lx kw nh ni mb nj bi translated">更复杂的算术类型</h2><p id="4bed" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">我们现在可以实现乘法和除法类型了。因为大部分工作是由实用程序完成的，所以这些工作相当简单。</p><pre class="nk nl nm nn gt no le np nq aw nr bi"><span id="0f30" class="my lg iq le b gy ns nt l nu nv">type Multiply&lt;A extends number, B extends number&gt; = <br/>    MultiAdd&lt;A, 0, B&gt;;</span><span id="ec25" class="my lg iq le b gy nw nt l nu nv">type Divide&lt;A extends number, B extends number&gt; = <br/>    MultiSub&lt;A, B, 0&gt;;</span><span id="0c3c" class="my lg iq le b gy nw nt l nu nv">type Modulo&lt;A extends number, B extends number&gt; = <br/>    LT&lt;A, B&gt; extends true ? A : Modulo&lt;Subtract&lt;A, B&gt;, B&gt;;</span></pre><p id="4b51" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意<code class="fe lb lc ld le b">Modulo</code>不需要任何工具，因为我们只需要知道在我们重复的减法练习之后剩下了什么，而不需要知道我们通过递归调用迭代了多少次。</p><p id="8293" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用这些类型给出了以下示例:</p><pre class="nk nl nm nn gt no le np nq aw nr bi"><span id="1d55" class="my lg iq le b gy ns nt l nu nv">let twentyEight: Multiply&lt;7, 4&gt;; // `28`<br/>let one: Divide&lt;7, 4&gt;; // `1`<br/>let three: Modulo&lt;7, 4&gt;; // `3`</span></pre><h2 id="88da" class="my lg iq bd lh mz na dn ll nb nc dp lp ko nd ne lt ks nf ng lx kw nh ni mb nj bi translated">确保输入是自然数</h2><p id="0eb0" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">到目前为止，我们的泛型类型约束只要求输入是一个数字，而不是一个自然的数字。这意味着，如果我们试图使用自然数以外的东西进行任何算术运算，我们都会得到一个编译错误。</p><pre class="nk nl nm nn gt no le np nq aw nr bi"><span id="ee02" class="my lg iq le b gy ns nt l nu nv">let one: Add&lt;3, -2&gt;;<br/>let onePointSeven: Subtract&lt;3, 1.3&gt;;</span></pre><p id="7543" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些声明中的任何一个都会出错并告诉我们<code class="fe lb lc ld le b">Type instantiation is excessively deep and possibly infinite</code>。考虑到我们上面所说的元组的长度既是离散的又是正的，这是有意义的，因此这些无效数字类存在于由这两个属性产生的“间隙”中。利用上面的无效数字，<code class="fe lb lc ld le b">-2</code>会一直在 <code class="fe lb lc ld le b">L</code>的起始值后面<em class="mx">，而<code class="fe lb lc ld le b">BuildTuple</code>的每一次迭代只是扩大了<code class="fe lb lc ld le b">-2</code>和<code class="fe lb lc ld le b">L</code>之间的差距。当构造一个长度为<code class="fe lb lc ld le b">1</code>的元组并转到长度为<code class="fe lb lc ld le b">2</code>的元组时，<code class="fe lb lc ld le b">1.3</code>总是会被忽略。在任一情况下，<code class="fe lb lc ld le b">BuildTuple</code>从未被告知终止，也从未被告知终止。</em></p><p id="c4d3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，虽然我们可以让TypeScript编译器在我们提供无效数字时抛出一个错误，但这并不理想；我们应该明确地考虑这些情况，甚至不要试图在遇到它们时执行算术。</p><p id="812f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们处理这个问题的方式是使用TypeScript的新模板文字类型。我们的目标是查看我们的输入是否与负数或小数模式匹配。所以让我们创建我们的类型来检查每一种情况。</p><pre class="nk nl nm nn gt no le np nq aw nr bi"><span id="491c" class="my lg iq le b gy ns nt l nu nv">type IsPositive&lt;N extends number&gt; = <br/>    `${N}` extends `-${number}` ? false : true;</span><span id="821f" class="my lg iq le b gy nw nt l nu nv">type IsWhole&lt;N extends number&gt; = <br/>    `${N}` extends `${number}.${number}` ? false : true;</span></pre><p id="b623" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这两个泛型类型都用某种类型<code class="fe lb lc ld le b">N</code>实例化(由于泛型约束保证它必须是一个数字，所以能够被插入到模板文字类型中)，然后将从<code class="fe lb lc ld le b">N</code>派生的模板文字类型与特定模式进行比较。</p><p id="35ee" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在第一种情况下，模式是以负号开始，后跟一个<code class="fe lb lc ld le b">number</code>的任何东西。不像上面我们的<strong class="kf ir">初始基础</strong>部分，我们从一个显式字符串文字<code class="fe lb lc ld le b">'click'</code>中派生出一个事件处理程序，这是更加通用的，将匹配<em class="mx">任何</em>负数。第二个模式确定<code class="fe lb lc ld le b">N</code>是否匹配任何两个有效的<code class="fe lb lc ld le b">numbers</code>，中间有一个小数位(<code class="fe lb lc ld le b">1.3</code>，因为<code class="fe lb lc ld le b">1</code>和<code class="fe lb lc ld le b">3</code>是有效数字)。</p></div><div class="ab cl nx ny hu nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="ij ik il im in"><p id="35ca" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="mx">说句题外话，我们的模板字面类型</em> <code class="fe lb lc ld le b"><em class="mx">-${number}</em></code> <em class="mx">会根据需要匹配</em> <code class="fe lb lc ld le b"><em class="mx">-1</em></code> <em class="mx">，但也会匹配</em> <code class="fe lb lc ld le b"><em class="mx">--1</em></code> <em class="mx">。原因是</em> <code class="fe lb lc ld le b"><em class="mx">1</em></code> <em class="mx">和</em> <code class="fe lb lc ld le b"><em class="mx">-1</em></code> <em class="mx">都可以赋值给</em> <code class="fe lb lc ld le b"><em class="mx">number</em></code> <em class="mx">，所以当我们在模板文本中使用</em> <code class="fe lb lc ld le b"><em class="mx">number</em></code> <em class="mx">时，我们实际上是在</em>的每一个可能的数字<em class="mx">上加了一个减号，而不管最终的模板文本类型在我们的上下文中是否有意义。类似地，我们的十进制模式将匹配类似于</em> <code class="fe lb lc ld le b"><em class="mx">1.3.1</em></code> <em class="mx">的东西，因为</em> <code class="fe lb lc ld le b"><em class="mx">1.3</em></code> <em class="mx">和</em> <code class="fe lb lc ld le b"><em class="mx">1</em></code> <em class="mx">都可以赋值给</em> <code class="fe lb lc ld le b"><em class="mx">number</em></code> <em class="mx">，我们的模式在它们之间天真地添加了一个小数点。</em></p><p id="021c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="mx">由于我们的</em> <code class="fe lb lc ld le b"><em class="mx">N</em></code> <em class="mx">类型被限制为</em> <code class="fe lb lc ld le b"><em class="mx">number</em></code> <em class="mx">，不能有效地构造双重否定或多重小数，这些边缘情况在我们的系统中不会出现问题，我们可以放心地忘记它们的存在。这只是出于完整性的考虑。</em></p></div><div class="ab cl nx ny hu nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="ij ik il im in"><p id="eabd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些类型的简单例子给了我们</p><pre class="nk nl nm nn gt no le np nq aw nr bi"><span id="d8e0" class="my lg iq le b gy ns nt l nu nv">let negativeNumber: IsPositive&lt;-13&gt;; // `false`<br/>let positiveNumber: IsPositive&lt;5&gt;; // `true`</span><span id="b141" class="my lg iq le b gy nw nt l nu nv">let float: IsWhole&lt;1.3&gt;; // `false`<br/>let round: IsWhole&lt;13&gt;; // `true`</span></pre><p id="2b93" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们可以在这些基础上检查数字是否有效。</p><pre class="nk nl nm nn gt no le np nq aw nr bi"><span id="4239" class="my lg iq le b gy ns nt l nu nv">type IsValid&lt;N extends number&gt; = <br/>    IsPositive&lt;N&gt; extends true<br/>        ? (IsWhole&lt;N&gt; extends true ? true : false)<br/>        : false;</span><span id="1f14" class="my lg iq le b gy nw nt l nu nv">type AreValid&lt;A extends number, B extends number&gt; = <br/>    IsValid&lt;A&gt; extends true<br/>        ? (IsValid&lt;B&gt; extends true ? true : false)<br/>        : false;</span></pre><p id="7a72" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用我们的<code class="fe lb lc ld le b">AreValid</code>类型，我们可以创建所有算术运算的安全版本，方法是将它们包装在一个条件类型中，如果我们的任何一个输入无效，这个条件类型就会失效。</p><pre class="nk nl nm nn gt no le np nq aw nr bi"><span id="737b" class="my lg iq le b gy ns nt l nu nv">type SafeAdd&lt;A extends number, B extends number&gt; = <br/>    AreValid&lt;A, B&gt; extends true ? Add&lt;A, B&gt; : never;</span><span id="5bb5" class="my lg iq le b gy nw nt l nu nv">type SafeSubtract&lt;A extends number, B extends number&gt; = <br/>    AreValid&lt;A, B&gt; extends true ? Subtract&lt;A, B&gt; : never;</span><span id="e1b7" class="my lg iq le b gy nw nt l nu nv">type SafeMultiply&lt;A extends number, B extends number&gt; = <br/>    AreValid&lt;A, B&gt; extends true ? Multiply&lt;A, B&gt; : never;</span><span id="775a" class="my lg iq le b gy nw nt l nu nv">type SafeDivide&lt;A extends number, B extends number&gt; = <br/>    AreValid&lt;A, B&gt; extends true ? Divide&lt;A, B&gt; : never;</span><span id="e0a0" class="my lg iq le b gy nw nt l nu nv">type SafeModulo&lt;A extends number, B extends number&gt; = <br/>    AreValid&lt;A, B&gt; extends true ? Modulo&lt;A, B&gt; : never;</span></pre><p id="ed4f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这给了我们想要看到的结果:</p><pre class="nk nl nm nn gt no le np nq aw nr bi"><span id="4a24" class="my lg iq le b gy ns nt l nu nv">let sum: Add&lt;3, 4&gt;; // `7`<br/>let badSum: Add&lt;3, 4.5&gt;; // `never`<br/>let anotherBadSum: Add&lt;3, -4&gt;; // `never`</span></pre><h1 id="5ea1" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">我们系统的局限性</h1><p id="b836" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">虽然现在有可能在TypeScript中实现自然数和算术，但它也有一些警告。</p><p id="1bc9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，递归条件类型确实有递归深度限制。这是一个明显的限制，因为如果没有它，实例化像<code class="fe lb lc ld le b">BuildTuple&lt;-1&gt;</code>这样的类型将会挂起编译器，因为我们将永远找不到扩展<code class="fe lb lc ld le b">{ length: -1 }</code>的元组，我们的递归将永远不会结束。这个限制对于我们自己的算术系统有一个真正的含义:我们不能直接创建一个长度大于<code class="fe lb lc ld le b">46</code>的元组(试图执行<code class="fe lb lc ld le b">BuildTuple&lt;47&gt;</code>会抛出我们前面看到的“过深”错误)。由于这个限制，我们的大多数类型都不能生成任何大的数。</p><p id="4207" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">其次，随着这些递归条件变得越来越复杂，它们的计算成本也会很高。太大太复杂的递归类型会降低编译器的速度。甚至4.1版本的<a class="ae kc" href="https://devblogs.microsoft.com/typescript/announcing-typescript-4-1/#recursive-conditional-types" rel="noopener ugc nofollow" target="_blank">发行说明</a>也说应该少用这些以避免性能下降。</p><p id="5483" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们整个系统的一个小缺陷是关于<code class="fe lb lc ld le b">Subtract</code>。虽然它<em class="mx">不应该</em>能够接受一对差值为负的数字，但事实上它接受了，而且不是我们预期的结果。将<code class="fe lb lc ld le b">Subtract</code>实例化为<code class="fe lb lc ld le b">Subtract&lt;1, 2&gt;</code>给出的结果类型不是<code class="fe lb lc ld le b">-1</code>(我们知道无论如何都无法生成它)，而是<code class="fe lb lc ld le b">number</code>。不幸的是，像我们对<code class="fe lb lc ld le b">Safe*</code>类型所做的那样，防止这种情况的唯一方法是保证<code class="fe lb lc ld le b">A</code>总是小于<code class="fe lb lc ld le b">B</code>。但是由于我们的<code class="fe lb lc ld le b">LT</code>类型依赖于<code class="fe lb lc ld le b">Subtract</code>来确定这样的排序，我们最终陷入了困境，因为在<code class="fe lb lc ld le b">Subtract</code>中实现<code class="fe lb lc ld le b">LT</code>会给我们一个无限循环引用。所以我们不得不接受这样一个事实，我们不能完全防止<code class="fe lb lc ld le b">Subtract</code>的无效输入。</p><h1 id="37ac" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">结论</h1><p id="b25f" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">我们展示了如何利用TypeScript的最新特性来构建自然数和算术系统。我们的实现仅仅触及了可能的表面，还有许多有趣的东西我们遗漏了(检查素性、相对素性、生成约数、<em class="mx">等等)。读者可以拿起它进行实验。</em></p><p id="90a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我会留下一个链接，链接到<a class="ae kc" href="https://www.typescriptlang.org/play?noUncheckedIndexedAccess=true&amp;useDefineForClassFields=true&amp;noUnusedLocals=true&amp;noUnusedParameters=true&amp;esModuleInterop=false&amp;declaration=false&amp;experimentalDecorators=false&amp;emitDecoratorMetadata=false&amp;target=99&amp;jsx=0&amp;pretty=true&amp;noErrorTruncation=true&amp;isolatedModules=false&amp;useUnknownInCatchVariables=true&amp;exactOptionalPropertyTypes=true&amp;noFallthroughCasesInSwitch=true&amp;noImplicitOverride=true&amp;noPropertyAccessFromIndexSignature=true&amp;ts=4.4.4#code/PTAEFUBcEsBtsgT1EgDgUwM4Cg3tADLoB2A5pABYA8AKqOgB6QkAmmoAhsYgNoC6APlABeUHUbNibUAG9QsEuQoAuUNGIAzdACdCoAL6gA-HtXF0ANx0BubLkQZQAIQCucFjReoFVAvSas7MQuALYARjoANGL+ktJcvHwioPxCwtigmTESgbLyipSqfvoZWWUmNKVlmaqu7p7e6L7RPAB07TTRCYK29o4Asi6wMACCLCxUAHKxucHhUaAjM1JBoRHa0QCSy9Jz62lVoNs5K6AADIfli5dZqmMTk9EjQie7azo31cagg8PQ91MnuNAYsBNEAMouMKQbQcADGkCom2iAEYBAJPtUzJYbHY8ItIDQdCF1C5MFQlq9VvMNs4dtT9iJDpSAqcLl9MiYYS50JjVAAKJz087fbn4VQaDiwTDoACUvXxAFEAIoU6JOA5lFlxdhOTEmQXCpZc7Q80ASqUy2V80CS6XoBUOfAEGgU4V7BZCqmgD3aTVZEaE4mk8kjdUvVnSMX60AqtXOCM6lCm3kc6omO0yzFlAXa3JnUUp822y1ym0uqiQ6GwhHxtEQqEw+GIpyo9GOgZDGBVqbu960gAifZp0WVw8Z6TKFceoAHidy0bTJmVNoByrb44+aauv27UMrjZriJnc+iA6BE3XoDRGO3tx9OO0Hfwm0wAAUAPaYBDQKy972+v6mQAAYACQyJM+jAcKwEALTgb6UExpmqYcqoYrPkcmAAOoUB+PjTAB-ZAaAYEQVBMEIf2+itFRNJIUuJb2jaGF4k6WEAGpStADybn6TJlK+n7fjAf6TPOpyLhyBqvrh+FNOJwpioWZoWva1ppmpMqYSM2joFx8ATHmpy+uqfEka+Bk8RSElRimMb8pZ3ETBqSlFiaqlMVaNoob0ICLNoCAUCE6AwHCUooE6OD4gCxlvCOdJETSJFEGQlBUG07R1LAHheD4zzRO0rTZbljRUBqPRsY4VZNrWcUMp65kCVkJUNPltnsJlrT8uoWi6OAsqFVlbg5W1TQVTGqVKFQ4C3mhD5WE+VX4Lu0DeIgbpJesZlbToJGrbF0RnOGmEDr+PFNPVPr9jtkYNfxk5ZKtPZhs4R0CJh-QfiwQwfptd3XQlXoA4BzWZBWr2ud6UlfCYIw2l9P2wH9NVHvGGonXY-nghwWikC4HDaCw6AsJwgWUCFYURXg0XsTjWixXxt1JqDj2ZLp+nOejHXJjyMaHQmNrmItmH0+gqPNv9LM3YlIPEWDAWc4Z3NuXzjES3V4ZC4+ou4+gq3rVLswy8D0vJQrHNWUZ4aq6hsM-F2a2wBtkNzV82Ii8toBi2dFgXUbJkm01bOK1bKvQ-ZjG+-7rva57fT4GLiO-QH8XbbLZsTsyelh67tsxsnyPc3HNhAA" rel="noopener ugc nofollow" target="_blank">TypeScript playground</a>，那里有整个系统的布局，随时可以使用，以防有人想扩展我们已经建立的功能，以及有相同内容的<a class="ae kc" href="https://gist.github.com/ryandabler/8b4ff4f36aed47bc09acc03174638468" rel="noopener ugc nofollow" target="_blank"> Gist </a>。</p></div></div>    
</body>
</html>