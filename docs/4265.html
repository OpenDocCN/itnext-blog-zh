<html>
<head>
<title>Laravel: Getting the previous and next records</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Laravel:获取上一条和下一条记录</h1>
<blockquote>原文：<a href="https://itnext.io/laravel-getting-the-previous-and-next-records-60a8cf109daa?source=collection_archive---------3-----------------------#2020-05-26">https://itnext.io/laravel-getting-the-previous-and-next-records-60a8cf109daa?source=collection_archive---------3-----------------------#2020-05-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8ac0" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">一些简单的查询就是你所需要的</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c3fd4cda347a4e86706dbca557567734.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*sRWiv0u3pXNoQkzM"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@golfarisa?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">阿里萨·查塔萨</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="501d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我需要为我的播客应用程序完成的任务之一是在播客视图中显示同一节目的下一个和上一个播客。</p><p id="2079" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">前端的计划很简单:有两个链接到这些邻居记录的按钮，所以用户可以遍历播客，而不必求助于手动寻找它们。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lv"><img src="../Images/dd4482f6d55517ce4820f6b24fe14411.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ciw6gs9fz_LqMRh2wnsocQ.png"/></div></div></figure><p id="601f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然这听起来很容易，但考虑到没有标准的SQL查询可以在一个简单的语句中跨所有引擎做到这一点，这并不容易。我的意思是，我们不能只是把这些告诉数据库，然后期望引擎知道我们在做什么。</p><pre class="kj kk kl km gt lx ly lz ma aw mb bi"><span id="d1ae" class="mc md it ly b gy me mf l mg mh">SELECT *<br/>FROM 'podcasts'<br/>WHERE podcasts.id = 4<br/>WITH NEXT, PREV</span></pre><p id="619d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">换句话说，我们无法执行任何查询来检索给定记录的下一个记录和前一个记录，因为SQL不知道什么是有效的“邻居”记录，更不知道如何对它们进行本机排序，因为最后一个记录因引擎而异。</p><p id="7502" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，对于一个给定的问题，总是有不止一个解决方案。在这种情况下，我在许多解决方案之间循环，但我最终得到了一个不太复杂的解决方案，它可以不受阻碍地工作，并且是SQL引擎不可知的:SQLite、MySQL、MariaDB、PostgreSQL、SQL Server等等。</p><h1 id="f2fa" class="mi md it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">两个SQL查询来规则它们</h1><p id="30ad" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">我们不会为了在一行中完成所有事情而强行在数据库和复杂查询的原始SQL调用中使用我们的方法，我们将只再发出两个查询:一个用于下一条记录，另一个用于上一条记录。</p><p id="aae7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">什么被认为是下一个和上一个？嗯，你可以说下一个id，这是一个有效的答案，考虑到旧的记录将有一个较低的ID，而新的记录将有一个最大的ID。</p><p id="fd41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这些查询中，我们对表进行反向排序，使当前记录成为“上限”，然后我们取列表中的第一条记录。</p><pre class="kj kk kl km gt lx ly lz ma aw mb bi"><span id="e18a" class="mc md it ly b gy me mf l mg mh">$podcast = Podcast::find(4);</span><span id="97b2" class="mc md it ly b gy ne mf l mg mh">$next = Podcast::where('id', '&gt;', $podcast-&gt;id)<br/>    -&gt;oldest('id')<br/>    -&gt;first();</span><span id="ad25" class="mc md it ly b gy ne mf l mg mh">$prev = Podcast::where('id', '&lt;', $podcast-&gt;id)<br/>    -&gt;latest('id')<br/>    -&gt;first();</span></pre><h2 id="9413" class="mc md it bd mj nf ng dn mn nh ni dp mr li nj nk mt lm nl nm mv lq nn no mx np bi translated">我不明白你想做什么</h2><p id="f4df" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">为了获得下一个播客，我们将首先从最老的表开始排序，这意味着“按升序排序ID”。然后，我们将只根据大于播客ID的列表进行筛选。第一条记录将是具有较大ID的第一条记录:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nq"><img src="../Images/55c2158a9d861855be81dfd425167f3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GUx1MwowQT7GMzRMoC-2UA.png"/></div></div></figure><p id="e950" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在之前的播客中，我们做了相反的事情。我们从最新的ID开始排序(降序)，筛选出小于播客ID的ID，并取出列表中的第一个ID:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/3b065d57d1c616938de1a6450391f8cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7p-1BdCj_I2ykZhBTahLqA.png"/></div></div></figure><p id="162f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样，如果播客的ID为<code class="fe ns nt nu ly b">3</code>，我们可以安全地将ID为<code class="fe ns nt nu ly b">2</code>的记录作为“下一个”，将ID为<code class="fe ns nt nu ly b">4</code>的记录作为“上一个”。</p><h1 id="aa46" class="mi md it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">利大于弊</h1><p id="1248" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">这种方法解决了许多其他解决方案存在的问题。</p><ul class=""><li id="6189" class="nv nw it lb b lc ld lf lg li nx lm ny lq nz lu oa ob oc od bi translated">不需要增加或减少ID，因为这是非常不可靠的，可能会返回意外的结果或逸出合理的数据。</li><li id="4919" class="nv nw it lb b lc oe lf of li og lm oh lq oi lu oa ob oc od bi translated">我们可以进一步过滤查询，在本例中，对于播客节目，它属于另一个<code class="fe ns nt nu ly b">where</code>子句。</li><li id="246c" class="nv nw it lb b lc oe lf of li og lm oh lq oi lu oa ob oc od bi translated">如果模型使用软删除，软删除的记录将不会被考虑，因为雄辩将自动应用范围。</li><li id="4dd2" class="nv nw it lb b lc oe lf of li og lm oh lq oi lu oa ob oc od bi translated">如果我们分别检查最后一个或第一个记录，我们可以安全地期待下一个和前一个记录的<code class="fe ns nt nu ly b">null</code>。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/aa0d87ce22940427365011a260455823.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MlKX01LYlIzdFadOW8ku7Q.png"/></div></div></figure><p id="2ba0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者，如果使用UUID或其他非顺序列，可以使用时间戳(默认情况下是<code class="fe ns nt nu ly b">created_at</code>和<code class="fe ns nt nu ly b">updated_at</code>)。</p><p id="1b5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果这些查询没有命中索引或主键，那么当表变大时，SQL查询会变得更慢，因为它需要扫描整个表。</p><pre class="kj kk kl km gt lx ly lz ma aw mb bi"><span id="e007" class="mc md it ly b gy me mf l mg mh">$next = Podcast::where('created_at', '&gt;', $podcast-&gt;created_at)<br/>    -&gt;oldest()<br/>    -&gt;first();</span></pre><p id="9ea2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您<em class="lw">可以</em>使用缓存，或者在某个地方永久存储这些信息，但是如果记录被修改或删除，您将不得不触发更新。这可以通过添加复合索引或主键来永久修复。</p><p id="3cae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">添加复合索引或主键可以避免在有大量记录的表上停留几秒钟的请求，这也使得对显示UUID的查询更快，因为<a class="ae ky" href="https://use-the-index-luke.com/sql/where-clause/the-equals-operator/concatenated-keys" rel="noopener ugc nofollow" target="_blank">复合索引可以使用第一列</a>工作。</p><p id="abea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">比方说，我们使用UUID，我们想过滤他们的节目UUID的播客。</p><pre class="kj kk kl km gt lx ly lz ma aw mb bi"><span id="3183" class="mc md it ly b gy me mf l mg mh">$next = Podcast::where('show_uuid', $podcast-&gt;show_uuid)<br/>    -&gt;where('created_at', '&gt;', $podcast-&gt;created_at)<br/>    -&gt;oldest()<br/>    -&gt;first();</span></pre><p id="af9d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们现在在数据库中托管1，000条记录，上述操作将花费大量时间，但是这两列上的索引可以使它更快，并且也可以使过滤节目更快。</p><pre class="kj kk kl km gt lx ly lz ma aw mb bi"><span id="c124" class="mc md it ly b gy me mf l mg mh">Schema::create('podcasts', function (Blueprint $table) {<br/>    // ...</span><span id="841b" class="mc md it ly b gy ne mf l mg mh">    $table-&gt;index(['show_uuid','created_at']);<br/>});</span></pre><p id="24fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，我认为这是在一些网站上克服这个问题的好方法，不需要过度设计SQL查询。</p></div><div class="ab cl ok ol hx om" role="separator"><span class="on bw bk oo op oq"/><span class="on bw bk oo op oq"/><span class="on bw bk oo op"/></div><div class="im in io ip iq"><p id="1e07" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这段代码可以在我的Laravel 的<a class="ae ky" href="https://github.com/DarkGhostHunter/Laratraits" rel="noopener ugc nofollow" target="_blank"> Laratraits包中找到，还有很多其他有用的工具。如果你不想重新发明轮子，就去看看吧。</a></p><div class="or os gp gr ot ou"><a href="https://github.com/DarkGhostHunter/Laratraits" rel="noopener  ugc nofollow" target="_blank"><div class="ov ab fo"><div class="ow ab ox cl cj oy"><h2 class="bd iu gy z fp oz fr fs pa fu fw is bi translated">黑暗幽灵之旅</h2><div class="pb l"><h3 class="bd b gy z fp oz fr fs pa fu fw dk translated">Laratraits是一个Laravel包，包含有用的特征和一些类，可以和你的模型、控制器一起使用</h3></div><div class="pc l"><p class="bd b dl z fp oz fr fs pa fu fw dk translated">github.com</p></div></div><div class="pd l"><div class="pe l pf pg ph pd pi ks ou"/></div></div></a></div></div></div>    
</body>
</html>