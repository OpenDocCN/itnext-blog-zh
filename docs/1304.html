<html>
<head>
<title>Going deeper into the RouteComposer configuration</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">深入了解RouteComposer配置</h1>
<blockquote>原文：<a href="https://itnext.io/going-deeper-into-the-routecomposer-configuration-3a54661bb16a?source=collection_archive---------3-----------------------#2018-09-04">https://itnext.io/going-deeper-into-the-routecomposer-configuration-3a54661bb16a?source=collection_archive---------3-----------------------#2018-09-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="93fc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我之前的<a class="ae kl" href="https://medium.com/@eugenenekhoroshiy/composition-of-uiviewcontrollers-and-navigation-between-them-and-not-only-15b825da5ac" rel="noopener">文章</a>中，我带你了解了<a class="ae kl" href="https://github.com/ekazaev/route-composer" rel="noopener ugc nofollow" target="_blank">route composer</a>——我们在iOS应用程序中使用的库，用于处理合成、导航和深度链接任务。在这篇文章中，我将介绍这个库的一些棘手的元素。</p><h1 id="043b" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">路由器如何解析配置:</h1><p id="525a" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">路由器从第一步开始一系列的步骤。如果这一步的查找器说这一步的UIViewController不存在，就继续下一步。它一直这样做，直到其中一个查找器说它已经找到了链中描述的<code class="fe lp lq lr ls b">UIViewController</code>。然后，Router开始通过步骤链向后移动，并开始使用其工厂为每个步骤创建<code class="fe lp lq lr ls b">UIViewController</code>,并使用附加到该步骤的操作将其集成到堆栈中。</p><p id="7417" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您开始认为用户可以在应用程序中的任何地方，并且已经收到了请求您的应用程序显示某个特定的<code class="fe lp lq lr ls b">UIViewController</code>的通用链接，那么考虑如何配置到<code class="fe lp lq lr ls b">UIViewController</code>的路由就更容易了。</p><h1 id="0c61" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated"><code class="fe lp lq lr ls b">StackIteratingFinder</code>选项:</h1><p id="d0fe" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">使用<code class="fe lp lq lr ls b">SearchOptions</code>可以改变<code class="fe lp lq lr ls b">StackIteratingFinder</code>的行为。它们是:</p><ul class=""><li id="6374" class="lt lu iq jp b jq jr ju jv jy lv kc lw kg lx kk ly lz ma mb bi translated"><code class="fe lp lq lr ls b">current</code>:最顶层的视图控制器</li><li id="09a4" class="lt lu iq jp b jq mc ju md jy me kc mf kg mg kk ly lz ma mb bi translated"><code class="fe lp lq lr ls b">visible</code>:如果视图控制器是一个容器，在它的可视视图控制器中搜索(例如:<code class="fe lp lq lr ls b">UINavigationController</code>总是有一个可视视图控制器，<code class="fe lp lq lr ls b">UISplitController</code>如果展开可以有2个可视控制器。)</li><li id="81c5" class="lt lu iq jp b jq mc ju md jy me kc mf kg mg kk ly lz ma mb bi translated"><code class="fe lp lq lr ls b">containing</code>:如果视图控制器是一个容器，搜索它包含的所有视图控制器(即当前可见的视图控制器之前的<code class="fe lp lq lr ls b">UINavigationController</code>中的所有视图控制器)</li><li id="16da" class="lt lu iq jp b jq mc ju md jy me kc mf kg mg kk ly lz ma mb bi translated"><code class="fe lp lq lr ls b">presenting</code>:在最顶层视图控制器下的所有视图控制器中搜索</li><li id="8cad" class="lt lu iq jp b jq mc ju md jy me kc mf kg mg kk ly lz ma mb bi translated"><code class="fe lp lq lr ls b"><em class="mh">presented</em></code>:从所有呈现的视图控制器中提供的视图控制器中搜索(与<code class="fe lp lq lr ls b">StackIteratingFinder</code>一起使用没有意义，因为它总是从最顶层的视图控制器开始，所以上面不会有任何视图控制器)</li></ul><p id="add3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下图可能会帮助你想象示例应用程序中的<code class="fe lp lq lr ls b">SearchOptions</code>:</p><figure class="mj mk ml mm gt mn gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi mi"><img src="../Images/80f59d4a877eed80024c9e857bcbffb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*qxtUH-2KRBAPGZv0.png"/></div></div></figure><p id="fa6d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你想让<code class="fe lp lq lr ls b">StackIteratingFinder</code>在任何地方寻找想要的视图控制器，但是只有当它们可见时，它应该像下面这样设置:</p><pre class="mj mk ml mm gt mu ls mv mw aw mx bi"><span id="7ba4" class="my kn iq ls b gy mz na l nb nc">ClassFinder&lt;CircleViewController, Any?&gt;(options: [.current, .visible, .presenting])</span></pre><h1 id="3eaa" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">配置问答:</h1><h2 id="976c" class="my kn iq bd ko nd ne dn ks nf ng dp kw jy nh ni la kc nj nk le kg nl nm li nn bi translated">我有一些<code class="fe lp lq lr ls b">UIViewController</code>作为根，我想把它换成<code class="fe lp lq lr ls b">HomeViewController</code>:</h2><figure class="mj mk ml mm gt mn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="1c31" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mh"/><code class="fe lp lq lr ls b"><em class="mh">XibFactory</em></code><em class="mh">将从名为</em> <code class="fe lp lq lr ls b"><em class="mh">HomeViewController.xib</em></code>的xib文件中加载 <code class="fe lp lq lr ls b"><em class="mh">HomeViewController</em></code> <em class="mh"/></p><p id="ac25" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mh">不要忘记，如果你使用抽象</em> <code class="fe lp lq lr ls b"><em class="mh">Finder</em></code> <em class="mh">和</em> <code class="fe lp lq lr ls b"><em class="mh">Factory</em></code> <em class="mh">的组合——你必须为其中一个</em> <code class="fe lp lq lr ls b"><em class="mh">ClassFinder&lt;HomeViewController, Any?&gt;</em></code>指定 <code class="fe lp lq lr ls b"><em class="mh">UIViewController</em></code> <em class="mh">和</em> <code class="fe lp lq lr ls b"><em class="mh">Context</em></code>的类型</p><h2 id="9c30" class="my kn iq bd ko nd ne dn ks nf ng dp kw jy nh ni la kc nj nk le kg nl nm li nn bi translated">如果在上面的配置中，我将<code class="fe lp lq lr ls b">RootViewControllerStep</code>替换为<code class="fe lp lq lr ls b">CurrentViewControllerStep</code>，会发生什么？</h2><p id="cf14" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">如果用户不在模式化呈现的某个<code class="fe lp lq lr ls b">UIViewController</code>中，它将工作。如果是，则<code class="fe lp lq lr ls b">ReplaceRoot</code>不能替换模态显示的<code class="fe lp lq lr ls b">UIViewController</code>，导航失败。如果您希望这种配置在所有情况下都有效，您应该向路由器解释它应该从根视图控制器开始构建堆栈。那么路由器将消除根视图控制器之上的所有模态视图控制器(如果有的话)。</p><h2 id="a4da" class="my kn iq bd ko nd ne dn ks nf ng dp kw jy nh ni la kc nj nk le kg nl nm li nn bi translated">我想将<code class="fe lp lq lr ls b">AccountViewController</code>推入屏幕上出现的任何<code class="fe lp lq lr ls b">UINavigationController</code>(即使<code class="fe lp lq lr ls b">UINavigationController</code>处于某种模式下<code class="fe lp lq lr ls b">UIViewController</code>):</h2><figure class="mj mk ml mm gt mn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="5c2a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mh">这里为什么用</em> <code class="fe lp lq lr ls b"><em class="mh">NilFactory</em></code> <em class="mh">？也就是说:到处寻找</em> <code class="fe lp lq lr ls b"><em class="mh">UINavigationController</em></code> <em class="mh">，如果找不到就不要创建(这种情况下路由会失败)。</em> <code class="fe lp lq lr ls b"><em class="mh">NilFactory</em></code> <em class="mh">通常必须伴随着</em> <code class="fe lp lq lr ls b"><em class="mh">NilAction</em></code> <em class="mh">就好像工厂没有创造任何东西。它不应集成到堆栈中</em></p><h2 id="3299" class="my kn iq bd ko nd ne dn ks nf ng dp kw jy nh ni la kc nj nk le kg nl nm li nn bi translated">如果<code class="fe lp lq lr ls b">UIViewController</code>出现在屏幕上，则应将其推入任意一个<code class="fe lp lq lr ls b">UINavigationController</code>中，如果不是模态显示:</h2><figure class="mj mk ml mm gt mn"><div class="bz fp l di"><div class="no np l"/></div></figure><h2 id="0fb1" class="my kn iq bd ko nd ne dn ks nf ng dp kw jy nh ni la kc nj nk le kg nl nm li nn bi translated">我想在选项卡中显示带有<code class="fe lp lq lr ls b">HomeViewController</code>和<code class="fe lp lq lr ls b">AccountViewController</code>的<code class="fe lp lq lr ls b">UITabBarController</code>:</h2><figure class="mj mk ml mm gt mn"><div class="bz fp l di"><div class="no np l"/></div></figure><h2 id="abe4" class="my kn iq bd ko nd ne dn ks nf ng dp kw jy nh ni la kc nj nk le kg nl nm li nn bi translated">我想使用自定义的<code class="fe lp lq lr ls b">UIViewControllerTransitioningDelegate</code>和<code class="fe lp lq lr ls b">PresentModally</code>动作:</h2><figure class="mj mk ml mm gt mn"><div class="bz fp l di"><div class="no np l"/></div></figure><h2 id="0d07" class="my kn iq bd ko nd ne dn ks nf ng dp kw jy nh ni la kc nj nk le kg nl nm li nn bi translated">如果用户在另一个选项卡中，或者即使用户在某个有模式呈现的<code class="fe lp lq lr ls b">UIViewController</code>中，我也想导航到<code class="fe lp lq lr ls b">AccountViewController</code>:</h2><figure class="mj mk ml mm gt mn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="6920" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mh">这里为什么用</em> <code class="fe lp lq lr ls b"><em class="mh">NilFactory</em></code> <em class="mh">？我们不需要构建任何东西:在依赖的</em> <code class="fe lp lq lr ls b"><em class="mh">tabScreen</em></code> <em class="mh">配置中会构建</em> <code class="fe lp lq lr ls b"><em class="mh">AccountViewController</em></code> <em class="mh">。参见上面的</em> <code class="fe lp lq lr ls b"><em class="mh">tabScreen</em></code> <em class="mh">配置。</em></p><h2 id="4681" class="my kn iq bd ko nd ne dn ks nf ng dp kw jy nh ni la kc nj nk le kg nl nm li nn bi translated">我想强制呈现<code class="fe lp lq lr ls b">ForgotPasswordViewController</code>，但是在<code class="fe lp lq lr ls b">UINavigationController</code>中的<code class="fe lp lq lr ls b">LoginViewController</code>之后:</h2><figure class="mj mk ml mm gt mn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="21df" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mh">通过以上配置，您可以使用</em> <code class="fe lp lq lr ls b"><em class="mh">Router</em></code>导航至两个屏幕</p><h2 id="d068" class="my kn iq bd ko nd ne dn ks nf ng dp kw jy nh ni la kc nj nk le kg nl nm li nn bi translated">如果在上面的配置中，我用<code class="fe lp lq lr ls b">RootViewControllerStep</code>替换<code class="fe lp lq lr ls b">CurrentViewControllerStep</code>，会发生什么？</h2><p id="74e2" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">它将会工作，但是这意味着路由器必须从根<code class="fe lp lq lr ls b">UIViewController</code>开始构建堆栈，所以如果用户处于某个模态呈现的<code class="fe lp lq lr ls b">UIViewController</code>中——路由器将在开始导航之前关闭它。</p><h2 id="9b8c" class="my kn iq bd ko nd ne dn ks nf ng dp kw jy nh ni la kc nj nk le kg nl nm li nn bi translated">这个应用有一个标签栏控制器，里面有<code class="fe lp lq lr ls b">HomeViewController</code>和<code class="fe lp lq lr ls b">BagViewController</code>。用户应该能够使用标签栏手动导航到行李。但是如果他们点击<code class="fe lp lq lr ls b">HomeViewController</code>中的“去包”按钮，应用程序应该有模式地显示<code class="fe lp lq lr ls b">BagViewController</code>。如果必须使用通用链接将用户发送到袋子，也会发生同样的情况。</h2><p id="f3c9" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">实现这种配置有两种方式:</p><ol class=""><li id="2d2d" class="lt lu iq jp b jq jr ju jv jy lv kc lw kg lx kk nq lz ma mb bi translated">使用<code class="fe lp lq lr ls b">NilFinder</code>,这意味着路由器永远不会在屏幕上找到现有的<code class="fe lp lq lr ls b">BagViewController</code>,而总是会创建一个新的并以模态显示。然而，这有一个缺点:如果用户已经在模态呈现的<code class="fe lp lq lr ls b">BagViewController</code>中，然后他点击推送通知，再次将他深度链接到包，路由器将构建另一个<code class="fe lp lq lr ls b">BagViewController</code>并在顶部模态呈现它。</li><li id="389c" class="lt lu iq jp b jq mc ju md jy me kc mf kg mg kk nq lz ma mb bi translated">稍微调整<code class="fe lp lq lr ls b">ClassFinder</code>，这样它将忽略没有模式化显示的<code class="fe lp lq lr ls b">BagViewController</code>，并在配置中使用它:</li></ol><figure class="mj mk ml mm gt mn"><div class="bz fp l di"><div class="no np l"/></div></figure></div><div class="ab cl nr ns hu nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="ij ik il im in"><p id="646b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我会很高兴你的意见和建议。</p><p id="2105" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">PS:如果你喜欢这个库，别忘了在<a class="ae kl" href="https://github.com/ekazaev/route-composer" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上给它一颗星！</p></div></div>    
</body>
</html>