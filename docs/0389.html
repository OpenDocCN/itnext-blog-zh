<html>
<head>
<title>Angular CLI proxy configuration</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Angular CLI代理配置</h1>
<blockquote>原文：<a href="https://itnext.io/angular-cli-proxy-configuration-4311acec9d6f?source=collection_archive---------0-----------------------#2018-03-04">https://itnext.io/angular-cli-proxy-configuration-4311acec9d6f?source=collection_archive---------0-----------------------#2018-03-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="afe2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://www.linkedin.com/cws/share?url=https%3A%2F%2Fitnext.io%2Fangular-cli-proxy-configuration-4311acec9d6f" rel="noopener ugc nofollow" target="_blank"> <em class="km">点击这里在LinkedIn上分享这篇文章</em> </a></p><p id="18fa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你的Angular前端和很多后端服务对话吗？您是否也使用类似nginx或Kubernetes Ingress这样的反向代理将请求从同一域的不同路径路由到这些服务？如果是这样，那么您应该知道Angular CLI提供的代理配置选项，这些选项使本地开发成为一种非常棒的体验。</p><p id="0a8a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这些配置选项通过一个示例得到了最好的说明。如果您对所需的更改感兴趣，那么请看GitHub上的这个<a class="ae kl" href="https://github.com/rars/demo-angularcli-proxy/commit/6008230a29bab0368810ff0a18c38b62852d4d99" rel="noopener ugc nofollow" target="_blank"> commit </a>，它显示了设置代理所需的差异。这篇博文将更详细地讨论这个例子。</p><p id="4d0b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们以一个在路径<code class="fe kn ko kp kq b">/catalog/</code>上服务的前端为例。“目录服务器”负责提供静态文件(。js，。css，。html ),还提供了一个API，前端可以使用它来检索特定于环境的配置。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi kr"><img src="../Images/0744e646cf1e3a1031be36947d054535.png" data-original-src="https://miro.medium.com/v2/resize:fit:1062/format:webp/1*RouvKjaSXKBRt97oUrz_uw.png"/></div></figure><p id="f33b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">前端将向另外两个REST API服务器发出请求:在同一个域上的路径<code class="fe kn ko kp kq b">/video/</code>和<code class="fe kn ko kp kq b">/library/</code>中可用的“视频API”和“库API”。这些将产生图书和电影信息，目录页面将显示这些信息。</p><p id="b211" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">默认情况下，Angular CLI假设前端服务于基本路径<code class="fe kn ko kp kq b">/</code>，即在<code class="fe kn ko kp kq b">index.html</code>中插入<code class="fe kn ko kp kq b">&lt;base href="/"&gt;</code>。因此，例如当<code class="fe kn ko kp kq b"><a class="ae kl" href="https://mydomain.com/catalog/index.html" rel="noopener ugc nofollow" target="_blank">https://mydomain.com/catalog/index.html</a></code>加载时，浏览器将从<code class="fe kn ko kp kq b"><a class="ae kl" href="http://mydomain.com/main.bundle.js" rel="noopener ugc nofollow" target="_blank">https://mydomain.com/main.bundle.j</a>s</code> <a class="ae kl" href="https://mydomain.com/styles.bundle.css." rel="noopener ugc nofollow" target="_blank">请求<code class="fe kn ko kp kq b">main.bundle.js</code>。</a>但是在那个位置找不到这个。浏览器应该从<code class="fe kn ko kp kq b"><a class="ae kl" href="https://mydomain.com/catalog/main.bundle.js" rel="noopener ugc nofollow" target="_blank">https://mydomain.com/catalog/main.bundle.js</a></code>请求它。这可以通过在您的<code class="fe kn ko kp kq b">package.json</code>文件中指定实际的基本HREF(在本例中为<code class="fe kn ko kp kq b">/catalog/</code>)和部署URL来解决:</p><pre class="ks kt ku kv gt kz kq la lb aw lc bi"><span id="2a10" class="ld le iq kq b gy lf lg l lh li">"start": "ng serve --base-href /catalog/ --deploy-url /catalog/",<br/>"build": "ng build --prod --base-href /catalog/ --deploy-url /catalog/"</span></pre><p id="5193" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您运行<code class="fe kn ko kp kq b">npm run start</code>，您现在应该看到它生成了一个带有<code class="fe kn ko kp kq b">&lt;base href="/catalog/"&gt;</code>的<code class="fe kn ko kp kq b">index.html</code>文件，并且您应该能够在<code class="fe kn ko kp kq b"><a class="ae kl" href="http://localhost:4200/catalog/." rel="noopener ugc nofollow" target="_blank">http://localhost:4200/catalog/</a></code>访问页面。我已经掩饰了<code class="fe kn ko kp kq b">deploy-url</code>场景到底是做什么的。执行重写对CSS中的<code class="fe kn ko kp kq b">url(...)</code>引用有类似的影响(因此，如果您在CSS引用字体或图像等资源时遇到问题，请检查该设置是否正确)。</p><p id="1077" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，它已经更加类似于我们期望在生产中部署服务和前端的结构。然而，Angular CLI已经开始为静态文件提供服务的本地服务器不知道如何处理对<code class="fe kn ko kp kq b">GET /video/films</code>或<code class="fe kn ko kp kq b">GET /library/books</code>甚至<code class="fe kn ko kp kq b">GET /catalog/config</code>的请求。</p><p id="0a5c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了处理这些额外的请求，我们必须配置Angular CLI，以便将这些请求代理给其他能够理解这些请求并做出适当响应的服务器。为此，在Angular CLI项目的根目录下创建一个文件<code class="fe kn ko kp kq b">proxy.conf.json</code>，与<code class="fe kn ko kp kq b">package.json</code>文件放在一起。在本例中，内容如下所示</p><pre class="ks kt ku kv gt kz kq la lb aw lc bi"><span id="af20" class="ld le iq kq b gy lf lg l lh li">{<br/>  "/library/*": {<br/>    "target": "http://localhost:10000",<br/>    "secure": false,<br/>    "logLevel": "debug",<br/>    "changeOrigin": true,<br/>    "pathRewrite": {<br/>      "^/library": ""<br/>    }<br/>  },<br/>  "/video/*": {<br/>    "target": "http://localhost:10001",<br/>    "secure": false,<br/>    "logLevel": "debug",<br/>    "changeOrigin": true,<br/>    "pathRewrite": {<br/>      "^/video": ""<br/>    }<br/>  },<br/>  "/catalog/api/*": {<br/>    "target": "http://localhost:5000",<br/>    "secure": false,<br/>    "logLevel": "debug",<br/>    "changeOrigin": true,<br/>    "pathRewrite": {<br/>      "^/catalog": ""<br/>    }<br/>  }<br/>}</span></pre><p id="09a3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本地运行时，您还需要更新您的<code class="fe kn ko kp kq b">package.json</code>来引用这个文件，如下所示:</p><pre class="ks kt ku kv gt kz kq la lb aw lc bi"><span id="0536" class="ld le iq kq b gy lf lg l lh li">"start": "ng serve --base-href /catalog/ --deploy-url /catalog/     --proxy-config proxy.conf.json",</span></pre><p id="349f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，当我们运行<code class="fe kn ko kp kq b">npm run start</code>时，您可以在命令行中看到它设置了这些代理设置:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi lj"><img src="../Images/4e94237f992d83e48029a1a0e1f7b028.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4RzklzNGo66qgtjtUJyQ6Q.jpeg"/></div></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk translated">启动时设置代理</figcaption></figure><p id="c242" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，当您在浏览器中转至<code class="fe kn ko kp kq b"><a class="ae kl" href="http://localhost:4200/catalog/" rel="noopener ugc nofollow" target="_blank">http://localhost:4200/catalog/</a> </code>时，您可以在命令行中看到该服务器正在向其他服务器发出几个代理请求:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ls"><img src="../Images/4b767dcc5768833721ac5a36ae1d7932.png" data-original-src="https://miro.medium.com/v2/resize:fit:1102/format:webp/1*UWS7s8kzR_JckRNDnj9wOw.jpeg"/></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk translated">从代理到相关服务器的浏览器接收的请求</figcaption></figure><p id="117f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对<code class="fe kn ko kp kq b"><a class="ae kl" href="http://localhost:4200/library/books" rel="noopener ugc nofollow" target="_blank">http://localhost:4200/library/books</a></code>的请求导致请求被发送到<code class="fe kn ko kp kq b"><a class="ae kl" href="http://localhost:10000/books" rel="noopener ugc nofollow" target="_blank">http://localhost:10000/books</a></code>，然后响应从Angular CLI服务器传回前端。发生这种情况是因为配置要求任何匹配<code class="fe kn ko kp kq b">/library/*</code>的路径都以<code class="fe kn ko kp kq b"><a class="ae kl" href="http://localhost:10000" rel="noopener ugc nofollow" target="_blank">http://localhost:10000</a></code>服务器为目标。它有一个额外的<code class="fe kn ko kp kq b">pathRewrite</code>设置，表明如果路径匹配<code class="fe kn ko kp kq b">^/library</code>(即如果它以<code class="fe kn ko kp kq b">/library</code>开始)，那么用空字符串重写该部分(即从路径中删除它)，因此在对<code class="fe kn ko kp kq b"><a class="ae kl" href="http://localhost:10000." rel="noopener ugc nofollow" target="_blank">http://localhost:10000</a></code> <a class="ae kl" href="http://localhost:10000." rel="noopener ugc nofollow" target="_blank">的请求中<code class="fe kn ko kp kq b">/library/books</code>被重写为<code class="fe kn ko kp kq b">/books</code>。</a></p><p id="0c2b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从与代理设置<code class="fe kn ko kp kq b">"^/catalog/api/*"</code>匹配的<code class="fe kn ko kp kq b">http://localhost:4200/catalog/api/config</code>中检索配置。<code class="fe kn ko kp kq b">pathRewrite</code>设置表示在形成代理请求之前，路径开始处的<code class="fe kn ko kp kq b">/catalog</code>应替换为空字符串，即<code class="fe kn ko kp kq b"><a class="ae kl" href="http://localhost:5000/api/config." rel="noopener ugc nofollow" target="_blank">http://localhost:5000/api/config</a></code> <a class="ae kl" href="http://localhost:5000/api/config." rel="noopener ugc nofollow" target="_blank">。</a></p><p id="af33" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">显然，这些其他服务器必须在本地运行，请求才能工作。如果您不打算对REST APIs进行任何更改，那么您可以将“开发”环境作为目标，而不是本地运行的服务器。</p><p id="7650" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我认为新的Angular CLI工具非常棒，它使得本地开发比在AngularJS中更容易。在处理复杂的部署场景时尤其如此，这个例子表明它足够灵活，可以适应这种复杂性。感谢您的阅读，我希望您发现以上细节对您自己的设置有用。</p><h1 id="9a66" class="lt le iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">参考</h1><p id="17f8" class="pw-post-body-paragraph jn jo iq jp b jq mq js jt ju mr jw jx jy ms ka kb kc mt ke kf kg mu ki kj kk ij bi translated">这个例子的完整代码可以在https://github.com/rars/demo-angularcli-proxy/找到</p><p id="b9d4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您只想查看将这个代理添加到一个新的Angular CLI项目中的更改，只需查看该存储库中的提交<a class="ae kl" href="https://github.com/rars/demo-angularcli-proxy/commit/6008230a29bab0368810ff0a18c38b62852d4d99" rel="noopener ugc nofollow" target="_blank"> 6008230 </a>。</p><p id="24b7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">更多文档可以在<a class="ae kl" href="https://github.com/angular/angular-cli/blob/master/docs/documentation/stories/proxy.md" rel="noopener ugc nofollow" target="_blank">https://github . com/angular/angular-CLI/blob/master/docs/documentation/stories/proxy . MD</a>找到</p></div></div>    
</body>
</html>