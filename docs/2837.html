<html>
<head>
<title>Using CMS blocks effectively in Vue Storefront</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Vue店面中有效使用CMS块</h1>
<blockquote>原文：<a href="https://itnext.io/using-cms-blocks-effectively-in-vue-storefront-8020df888844?source=collection_archive---------2-----------------------#2019-08-12">https://itnext.io/using-cms-blocks-effectively-in-vue-storefront-8020df888844?source=collection_archive---------2-----------------------#2019-08-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/8612e094737d82eafb7cf18bc3a18eda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lpu2JEl-snCXbi4ZNzX0PQ.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@estherrj?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Esther Jiao </a>在<a class="ae kc" href="https://unsplash.com/search/photos/blocks?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="bd78" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">CMS块是一种流行的方式，使用户能够从后端编辑Magento 2网站中的元素，它(几乎)不需要任何编码技能，并提供了一种相对安全的方式来更新内容，而不会有破坏您的电子商务网站的风险。</p><p id="904c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">开箱即用Vue Storefront提供对CMS块的支持，如果您使用的是官方的<a class="ae kc" href="https://github.com/DivanteLtd/magento2-vsbridge-indexer" rel="noopener ugc nofollow" target="_blank"> Magento 2 VS Indexer </a>或<a class="ae kc" href="https://github.com/DivanteLtd/mage2vuestorefront" rel="noopener ugc nofollow" target="_blank"> mage2vuestorefront </a>数据泵(v1.6+) CMS块和页面会同步到弹性搜索数据库，因此我们可以非常高效地查询这些数据。</p><p id="2f00" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Vue Storefront还包括一个组件，可以帮助我们在站点中的任何地方呈现这些内容，让我们看看如果我们想让主页中的一个块可以从CMS块编辑，它会是什么样子:</p><h1 id="de34" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">1.使用CmsBlock组件</h1><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">在Vue Storefront中使用CmsBlock组件</figcaption></figure><p id="fa78" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我选择了<code class="fe mf mg mh mi b">PromotedOffers</code>组件使最左边的横幅可编辑，所以我用<code class="fe mf mg mh mi b">&lt;cms-block /&gt;</code>组件替换了它，该组件带有一个与Magento 2管理区中的标识符相对应的<code class="fe mf mg mh mi b">identifier</code>(或<code class="fe mf mg mh mi b">id</code>)属性。</p><p id="0f42" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该组件所做的只是显示CMS块的内容，请记住，这将按原样呈现HTML，因此我们需要确保它与Vue Storefront主题期望的结构相匹配，这样它看起来就很好:</p><h1 id="bdd9" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">2.创建CMS块</h1><figure class="lz ma mb mc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mj"><img src="../Images/4e0f753d6d94508a84ac5b3f63924989.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P2ZnVksH_bK6xhcvNhwLGw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">CMS阻止Magento 2后端的标记</figcaption></figure><blockquote class="mk ml mm"><p id="64eb" class="kd ke mn kf b kg kh ki kj kk kl km kn mo kp kq kr mp kt ku kv mq kx ky kz la ij bi translated">确保CMS块<strong class="kf ir">标识符</strong>与Vue Storefront中的标识符相匹配</p></blockquote><p id="72f9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">保存并确保它被索引到弹性搜索数据库后，您将能够在主页中看到包含新内容的块:</p><figure class="lz ma mb mc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mr"><img src="../Images/5f815d3a54a54e8b48ea80399877178e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3gIorBDCmUtsvnat-PCYVQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@sonniehiles?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Sonnie Hiles </a>在<a class="ae kc" href="https://unsplash.com/search/photos/model?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="1033" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这适用于许多用例，但最大的缺点是，如前所述，<code class="fe mf mg mh mi b">&lt;cms-block /&gt;</code>组件将块的内容呈现为HTML，因此Vue无法真正访问它，这意味着我们将无法使用Vue Storefront的任何优点，如:</p><ul class=""><li id="5f5e" class="ms mt iq kf b kg kh kk kl ko mu ks mv kw mw la mx my mz na bi translated">按指定路线发送</li><li id="e70c" class="ms mt iq kf b kg nb kk nc ko nd ks ne kw nf la mx my mz na bi translated">惰性装载</li><li id="ee63" class="ms mt iq kf b kg nb kk nc ko nd ks ne kw nf la mx my mz na bi translated">自定义组件(如转盘、弹出窗口等)</li><li id="10b7" class="ms mt iq kf b kg nb kk nc ko nd ks ne kw nf la mx my mz na bi translated">自定义绑定</li><li id="baee" class="ms mt iq kf b kg nb kk nc ko nd ks ne kw nf la mx my mz na bi translated">事件等…</li></ul><p id="bdf1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这也使得CMS块更难维护，因为你需要在它的内容中保留大量的标记，所以它很容易被错误地更改，破坏网站的布局。</p><p id="cb1d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">幸运的是，由于Vue Storefront的模块化方法，我们可以轻松解决这个问题。</p><h1 id="5ea9" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">CMS块混合</h1><p id="f376" class="pw-post-body-paragraph kd ke iq kf b kg ng ki kj kk nh km kn ko ni kq kr ks nj ku kv kw nk ky kz la ij bi translated">默认的CMS块组件完成了我们想要的大部分开箱即用的功能，我们唯一需要的是一种解析内容的方法，这样我们就能够“提取”出我们需要的元素，并在我们的Vue Storefront组件中随心所欲地使用它们。</p><p id="d24c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我认为这是一个常见的用例，所以我创建了一个独立的mixin来将CMS块内容从一个字符串解析成更容易从前端操作的内容。</p><div class="nl nm gp gr nn no"><a href="https://github.com/jahvi/vsf-cms-block-mixin" rel="noopener  ugc nofollow" target="_blank"><div class="np ab fo"><div class="nq ab nr cl cj ns"><h2 class="bd ir gy z fp nt fr fs nu fu fw ip bi translated">jahvi/vsf-cms-block-mixin</h2><div class="nv l"><h3 class="bd b gy z fp nt fr fs nu fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="nw l"><p class="bd b dl z fp nt fr fs nu fu fw dk translated">github.com</p></div></div><div class="nx l"><div class="ny l nz oa ob nx oc jw no"/></div></div></a></div><p id="15df" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我正在使用<a class="ae kc" href="https://www.npmjs.com/package/node-html-parser" rel="noopener ugc nofollow" target="_blank"> node-html-parser </a>库将CMS块内容转换成一个简化的DOM树，这意味着我们可以访问一些我们用来查询html元素的低级API:</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">节点HTML解析器示例</figcaption></figure><p id="c717" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有了这些，我们可以重构我们的CMS块实现，这次让我们从实际的标记开始。</p><h1 id="dde8" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">1.更新CMS块内容</h1><figure class="lz ma mb mc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi od"><img src="../Images/767e0839d8ee4915c0c822a666a83b47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aqf3U2aJyXhCMJBv6ak1Mg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">已更新CMS块内容</figcaption></figure><p id="0517" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如你现在看到的，内容已经被简化了很多，因为我们将能够更容易地解析它，我们不需要担心类、属性、内联内容等等。事实上，标记现在几乎无关紧要，注意我们现在是如何使用一个<code class="fe mf mg mh mi b">&lt;img&gt;</code>的，尽管我们以后会需要它作为前端的<code class="fe mf mg mh mi b">background-image</code>。</p><h1 id="6fda" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">2.使用新的CMS块混合</h1><p id="0b6f" class="pw-post-body-paragraph kd ke iq kf b kg ng ki kj kk nh km kn ko ni kq kr ks nj ku kv kw nk ky kz la ij bi translated">让我们更改我们的<code class="fe mf mg mh mi b">&lt;cms-block /&gt;</code>,使用我们稍后创建的自定义组件，只是为了让事情更有条理:</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">更新的CMS块组件</figcaption></figure><p id="4a4d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于CMS块Mixin的实现与内置的<code class="fe mf mg mh mi b">&lt;cms-block /&gt;</code>组件非常相似，所以这里没有太大的变化，然而<code class="fe mf mg mh mi b">LeftBanner</code>组件是所有奇迹发生的原因:</p><blockquote class="mk ml mm"><p id="364d" class="kd ke mn kf b kg kh ki kj kk kl km kn mo kp kq kr mp kt ku kv mq kx ky kz la ij bi translated">确保在下一步之前已经运行了<code class="fe mf mg mh mi b"><em class="iq">yarn add vsf-cms-block-mixin</em></code> <em class="iq"/></p></blockquote><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">更新的CMS块组件</figcaption></figure><p id="0fcc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如您可以看到的<a class="ae kc" href="https://github.com/jahvi/vsf-cms-block-mixin" rel="noopener ugc nofollow" target="_blank"> vsf-cms-block-mixin </a>公开了一个<code class="fe mf mg mh mi b">parsedContent</code>属性，让您可以像在DOM中一样查询元素，因此我们实际上使用Vue Storefront组件来显示我们的数据，而不是呈现普通的HTML，这意味着:</p><ul class=""><li id="c5d6" class="ms mt iq kf b kg kh kk kl ko mu ks mv kw mw la mx my mz na bi translated">我们将复杂性移到了前端，因此内容更容易更新。</li><li id="0898" class="ms mt iq kf b kg nb kk nc ko nd ks ne kw nf la mx my mz na bi translated">我们可以充分利用Vue组件，看看我们如何使用<code class="fe mf mg mh mi b">v-lazy</code>来惰性加载背景图像，使用<code class="fe mf mg mh mi b">&lt;router-link&gt;</code>来渲染链接，而无需重新加载整个页面。</li><li id="ce70" class="ms mt iq kf b kg nb kk nc ko nd ks ne kw nf la mx my mz na bi translated">CMS块的内容不必遵循与前端相同的结构，只要它可以被查询，就可以按照你想要的方式存储。</li></ul><p id="f6f6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最终结果看起来和以前一样，但这次我们可以看到我们正在处理一个真正的Vue组件:</p><figure class="lz ma mb mc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oe"><img src="../Images/d61a49e5b13ac972829706b44fa5c03d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*toayw38Y0m4mPOB8vL8tVw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">前端重构的CMS块</figcaption></figure><p id="3fc6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请记住，<a class="ae kc" href="https://www.npmjs.com/package/node-html-parser" rel="noopener ugc nofollow" target="_blank"> node-html-parser </a>比其他任何东西都更注重性能，所以它只公开了可用于查询html元素的API的一个简化子集，但是我没有发现这是一个限制。</p><h1 id="3bcb" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">奖金！</h1><p id="34b2" class="pw-post-body-paragraph kd ke iq kf b kg ng ki kj kk nh km kn ko ni kq kr ks nj ku kv kw nk ky kz la ij bi translated">根据您使用CMS块的位置，您可能会注意到，在完全重新加载后，它们不会随页面一起加载。</p><figure class="lz ma mb mc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi of"><img src="../Images/f5eabebac4be83b5a26684d280f8a23b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*xPhO7oLX64HhJDpsnt-dog.gif"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">页面加载后CMS块加载</figcaption></figure><p id="8b1b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是因为这些块不是在服务器端加载的，所以它们不是初始DOM内容的一部分。我们不能在我们的组件或mixin中预取<code class="fe mf mg mh mi b">asyncData</code>中的CMS数据，因为这只对最顶层的组件及其mixin运行，但是我们可以将这个登录移动到使用它的页面组件中，在我们的例子中是<code class="fe mf mg mh mi b">Home.vue</code>组件:</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">在服务器上呈现CMS块</figcaption></figure><p id="9cf3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">用我们在页面中需要的所有CMS块的数组调度<code class="fe mf mg mh mi b">cmsBlock/list</code>动作将确保块的数据在加载前可用。</p><blockquote class="mk ml mm"><p id="c123" class="kd ke mn kf b kg kh ki kj kk kl km kn mo kp kq kr mp kt ku kv mq kx ky kz la ij bi translated">请记住，在Vue Storefront的更高版本中，<code class="fe mf mg mh mi b">asyncData</code>方法将被替换为<code class="fe mf mg mh mi b">serverPrefetch</code></p></blockquote><figure class="lz ma mb mc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi of"><img src="../Images/dc054c132c2e50f6d3e5c6245f8fe81d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*XrlkXV6Scls_kTI3O35w3Q.gif"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">服务器在前端呈现CMS块</figcaption></figure><p id="0daa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如今，酷小孩们使用独立的CMS解决方案，如<strong class="kf ir"> WordPress </strong>或<strong class="kf ir"> Contentful </strong>来管理Vue店面网站中的内容，但我认为这是一种非常轻量级的方法，如果你已经在使用Magento 2来管理你的电子商务网站，你可以采用。</p></div><div class="ab cl og oh hu oi" role="separator"><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol"/></div><div class="ij ik il im in"><p id="a320" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您觉得该模块有用，请随意使用并投稿，我们非常欢迎PRs和建议！👋🏽</p><div class="nl nm gp gr nn no"><a href="https://github.com/jahvi/vsf-cms-block-mixin" rel="noopener  ugc nofollow" target="_blank"><div class="np ab fo"><div class="nq ab nr cl cj ns"><h2 class="bd ir gy z fp nt fr fs nu fu fw ip bi translated">jahvi/vsf-cms-block-mixin</h2><div class="nv l"><h3 class="bd b gy z fp nt fr fs nu fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="nw l"><p class="bd b dl z fp nt fr fs nu fu fw dk translated">github.com</p></div></div><div class="nx l"><div class="on l nz oa ob nx oc jw no"/></div></div></a></div></div></div>    
</body>
</html>