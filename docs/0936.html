<html>
<head>
<title>Partial Mocking in Swift — Backwards</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">《急速后退》中的部分嘲讽</h1>
<blockquote>原文：<a href="https://itnext.io/partial-mocking-in-swift-backwards-e5036cf32a1b?source=collection_archive---------4-----------------------#2018-06-21">https://itnext.io/partial-mocking-in-swift-backwards-e5036cf32a1b?source=collection_archive---------4-----------------------#2018-06-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="5630" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">简短免责声明:</strong>本帖面向刚开始学习单元测试的iOS开发者。或者对于在之前<a class="ae kl" href="https://blog.hubstaff.com/why-you-should-write-unit-tests/" rel="noopener ugc nofollow" target="_blank">没有写过测试的有经验的iOS开发者来说。</a></p><p id="6042" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<a class="ae kl" href="https://www.raywenderlich.com/" rel="noopener ugc nofollow" target="_blank"> Ray Wenderlich </a>上有一个精彩的<a class="ae kl" href="https://videos.raywenderlich.com/courses/105-testing-in-ios/lessons/1" rel="noopener ugc nofollow" target="_blank">视频教程系列</a>(第一个视频是免费的，但你需要订阅才能观看其余部分)。到目前为止，我的体验是这样的:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi km"><img src="../Images/b29cd532716737c1cfb58ef448241586.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/1*an7ecKwQBgkgyR7UMLx4dw.gif"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">我对教程的典型体验</figcaption></figure><p id="23fc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">复杂性迅速增加，所有足够重要的主题都是如此。我看到了约翰·桑德尔写的一篇很棒的文章，标题是《在迅捷中嘲弄》。我强烈建议首先阅读那篇文章，并从单元测试的RW系列开始，以便从后面的内容中获得最大收益。</p><p id="7565" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么，接下来是什么呢？我将逐步介绍我使用John Sundell的策略和代码创建部分模拟测试的方法。</p></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><h1 id="04da" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">创建测试</h1><p id="bdd7" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">首先，假设您有某种异步获取数据的网络类。其次，让我们假设您知道如何为您的单元测试创建一个<code class="fe mi mj mk ml b">XCTestCase</code>子类。当然，如果我们可以测试我们的网络类，那就太好了。那么我们如何着手做这件事呢？让我们先来看看我们的网络课程:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mm mn l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">网络课。创建数据任务并返回结果。</figcaption></figure><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mm mn l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">网络结果枚举</figcaption></figure><p id="69ba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上面我们有一个<code class="fe mi mj mk ml b">loadData</code>函数，它接受一个URL和一个带有<code class="fe mi mj mk ml b">NetworkResult</code>输入的转义闭包。我们使用共享的<code class="fe mi mj mk ml b">URLSession</code>实例创建一个数据任务，该实例返回一个包含<code class="fe mi mj mk ml b">data</code>和<code class="fe mi mj mk ml b">error</code>对象的闭包。然后我们设置我们的枚举，并把它扔进完成处理器。</p><p id="f7c6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可能想测试很多东西！网络调用是否返回正确的数据？我们能正确地连接到我们传递的URL吗？正如Sundell所写的，我们可以编写一个测试，用一个有效的URL简单地调用<code class="fe mi mj mk ml b">loadData</code>函数——但是这种技术有几个缺陷。</p><p id="e6dd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，互联网可能会中断，因此我们的数据任务将会失败。我们也可能从我们的URL中得到一些垃圾数据。但是我们应该首先测试一个简单得多的特性——如果有真正的错误，我们的代码会返回一个<code class="fe mi mj mk ml b">failure</code>案例吗？如果返回一些数据，我们会得到一个<code class="fe mi mj mk ml b">success</code>案例吗？正如Sundell所建议的，我们可以按照下面的方式开始编写我们的单元测试:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="eb25" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上面的测试中，我们创建了一个URL以及网络类的实例。然后，我们在实例上调用<code class="fe mi mj mk ml b">loadData</code>，并将结果存储在一个局部变量中。最后，我们测试我们从网络调用中得到的结果是否等于用一些数据变量(还没有定义)初始化的成功案例。</p><p id="5886" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了让我们的断言工作，我们需要数据！为此，我们需要一个有效的URL，一个互联网连接，和时间(让函数异步加载)。这就是嘲讽的用武之地——与其用真实的URL获取真实的数据，为什么不用假的URL获取假的数据呢？</p><h1 id="6822" class="lf lg iq bd lh li mo lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ms ma mb mc bi translated">部分嘲笑</h1><p id="1dbb" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">首先，我们必须理解在我们的assert案例中发生了什么。我们正在比较<code class="fe mi mj mk ml b">result</code>(T4)和<code class="fe mi mj mk ml b">.success(data)</code>。如果它们都包含相同的数据对象，则该测试将通过。创建一个我们指定并填充自己的<code class="fe mi mj mk ml b">NetworkResult</code>枚举的伪<code class="fe mi mj mk ml b">Data</code>对象的实例非常容易。然而，我们如何确保我们的<code class="fe mi mj mk ml b">loadData</code>函数返回相同的假数据呢？</p><p id="b82f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要解决这个问题，请看上面的<code class="fe mi mj mk ml b">loadData</code>代码。数据对象从一个用我们的URL创建的<code class="fe mi mj mk ml b">dataTask</code>返回，并使用一个共享的<code class="fe mi mj mk ml b">URLSession</code>。为了欺骗我们的测试，我们必须以某种方式重写那个函数，使它返回我们的假数据。一种方法是创建一个<code class="fe mi mj mk ml b">URLSession</code>的子类，并覆盖dataTask函数，让它做我们想要的事情。这个<code class="fe mi mj mk ml b">URLSession</code>子类必须在<code class="fe mi mj mk ml b">NetworkManager</code>中使用。</p><p id="d13e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们如何确保我们的网络类默认使用<code class="fe mi mj mk ml b">URLSession.shared</code>，但是仍然在我们的测试用例中定制它来使用我们的定制<code class="fe mi mj mk ml b">URLSession</code>子类？这就是<a class="ae kl" href="http://www.jamesshore.com/Blog/Dependency-Injection-Demystified.html" rel="noopener ugc nofollow" target="_blank">依赖注入</a>发挥作用的地方。这允许我们用我们创建的<code class="fe mi mj mk ml b">URLSession</code>实例化一个<code class="fe mi mj mk ml b">NetworkManager</code>对象。我们也不能忘记让<code class="fe mi mj mk ml b">URLSession</code>知道我们在测试案例中创建的虚假数据。</p><p id="591f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们总结一下。首先，我们创建一个假的URL。然后我们创造假数据。然后我们实例化我们的<code class="fe mi mj mk ml b">URLSession</code>子类，并向它发送我们创建的假数据。然后我们创建一个<code class="fe mi mj mk ml b">NetworkManager</code>实例并用我们的<code class="fe mi mj mk ml b">URLSession</code>子类初始化它。这在测试用例中看起来如何？也许是这样的:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="3ad0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们沿着树往上爬。第一站是<code class="fe mi mj mk ml b">NetworkManager</code>，这里我们需要添加一些代码，允许我们在初始化时给它一个<code class="fe mi mj mk ml b">URLSession</code>(见上面的第15行)，但也保留默认使用<code class="fe mi mj mk ml b">URLSession.shared</code>的原始功能。要做到这一点，我们知道我们需要一个类型为<code class="fe mi mj mk ml b">URLSession</code>的属性来存储要使用的会话，我们还需要创建自己的初始化器，它将允许我们编写类似于<code class="fe mi mj mk ml b">NetworkManager(session: session)</code>的代码，但也保留一个默认值。幸运的是，Swift为我们提供了默认参数值的功能:</p><blockquote class="mt mu mv"><p id="1359" class="jn jo mw jp b jq jr js jt ju jv jw jx mx jz ka kb my kd ke kf mz kh ki kj kk ij bi translated">您可以为函数中的任何参数定义一个<em class="iq">默认值</em>，方法是在该参数的类型之后为该参数赋值。如果定义了默认值，则在调用函数时可以省略该参数。</p></blockquote><p id="ffa1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们来看看我们新的网络管理器代码:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="1c1e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">与前面的代码相比，你可以看到只有如上所述的微小修改。我们现在不使用<code class="fe mi mj mk ml b">URLSession.shared</code>而是使用私有<code class="fe mi mj mk ml b">session</code>属性。</p><p id="115c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">太好了！我们有我们的测试代码，我们的网络代码。剩下的工作就是创建我们的<code class="fe mi mj mk ml b">URLSession</code>子类。</p><p id="b73a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<code class="fe mi mj mk ml b">NetworkManager</code>代码中，我们可以看到我们的子类必须有一个数据属性(因为我们设置了<code class="fe mi mj mk ml b">session.data</code>)，我们知道它必须覆盖<code class="fe mi mj mk ml b">dataTask</code>函数。稍微提前考虑一下，我们也可以假设它必须有一个错误属性，因为我们希望最终测试一个错误状态。查看我们的<code class="fe mi mj mk ml b">loadData</code>函数，我们也知道<code class="fe mi mj mk ml b">dataTask</code>必须接受一个<code class="fe mi mj mk ml b">@escaping</code>完成，因为有一个回调。该完成必须返回一个<code class="fe mi mj mk ml b">URLSessionDataTask</code>对象，因为它应该存储在<code class="fe mi mj mk ml b">NetworkManager</code>的<code class="fe mi mj mk ml b">task</code>变量中。到目前为止的代码:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="bf12" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么，我们在我们的<code class="fe mi mj mk ml b">dataTask</code>函数中放什么呢？嗯，我们必须返回一个包含数据的<code class="fe mi mj mk ml b">DataTask</code>对象。由于我们必须定制<code class="fe mi mj mk ml b">DataTask</code>，听起来我们需要另一个子类。在我们的<code class="fe mi mj mk ml b">URLSessionMock</code>子类中，我们必须实例化一个模拟的<code class="fe mi mj mk ml b">DataTask</code>对象并返回它。这个<code class="fe mi mj mk ml b">DataTask</code>对象应该具有这样的属性:在调用它的<code class="fe mi mj mk ml b">resume()</code>函数时，闭包最终被调用。它可能如下所示:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="4dbb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">咻。快好了。现在我们得到一个错误，我们的<code class="fe mi mj mk ml b">NetworkResult</code>是不等价的，然而我们试图在我们的<code class="fe mi mj mk ml b">XCTAssert</code>中使它等价。这是有道理的——所以这里有一个大致等同的版本<code class="fe mi mj mk ml b">NetworkResult</code>。不是说它很完美，但它确实有效(参见此处以供参考):</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="3915" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们只是比较底层的<code class="fe mi mj mk ml b">Data</code>和<code class="fe mi mj mk ml b">Error</code>对象。</p><p id="64ae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">完成处理程序链如下所示:在我们的测试函数中，我们将第一个完成<code class="fe mi mj mk ml b">{ result = $0 }</code>发送给<code class="fe mi mj mk ml b">loadData</code>函数。<code class="fe mi mj mk ml b">loadData</code>函数需要转义<code class="fe mi mj mk ml b">(NetworkResult) -&gt; Void</code>完成，因此<code class="fe mi mj mk ml b">$0</code>将代表<code class="fe mi mj mk ml b">NetworkResult</code>。这个完成通过<code class="fe mi mj mk ml b">URLSessionMock</code>并最终通过<code class="fe mi mj mk ml b">URLSessionDataTaskMock</code>工作，直到在<code class="fe mi mj mk ml b">resume()</code>函数中被调用。</p><p id="ad0b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们运行测试，它是绿色的！(或者至少，应该是)。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi na"><img src="../Images/0da1d23b75f5d931eb0bc6fb3ef4b5ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_V0eWu32nY9ys4bhX_f_mw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">一次成功的假网络测试</figcaption></figure><p id="edd5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">咻！对于一个测试来说，代码太多了。</p><p id="e305" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上面的策略被称为<em class="mw">部分模仿</em>——通过部分修改对象来改变它们的行为。</p><p id="74f7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以这种方式逆向工作类似于<a class="ae kl" href="https://blog.cleancoder.com/uncle-bob/2014/12/17/TheCyclesOfTDD.html" rel="noopener ugc nofollow" target="_blank">红绿重构</a>，失败的测试先写<em class="mw">然后写产品代码。在我们的例子中，我们甚至在这一步之前就开始编写一个测试，直到我们创建了必要的测试类，这个测试才被编译。</em></p><p id="0f30" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">约翰·桑德尔继续解释完全的嘲笑以及何时应该避免嘲笑。上面的策略对于完全模仿和部分模仿一样有效！</p><p id="3032" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">感谢阅读！如果你有评论、更正或问题，请在下面留下，我会尽力回答——或者，你可以在<a class="ae kl" href="https://twitter.com/eduardlev" rel="noopener ugc nofollow" target="_blank"> Twitter-@eduardlev </a>上给我发消息</p></div></div>    
</body>
</html>