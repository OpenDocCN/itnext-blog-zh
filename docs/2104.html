<html>
<head>
<title>Memoization Forget-Me-Bomb</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">记忆勿忘我炸弹</h1>
<blockquote>原文：<a href="https://itnext.io/kashe-memoization-forget-me-bomb-db14e9597e05?source=collection_archive---------3-----------------------#2019-04-01">https://itnext.io/kashe-memoization-forget-me-bomb-db14e9597e05?source=collection_archive---------3-----------------------#2019-04-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/dcaefc671faa39322056520129c7f94f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lkIlvyC1kwdig8cDSo8irQ.jpeg"/></div></div></figure><div class=""/><blockquote class="jy jz ka"><p id="e6fd" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">还记得吗？不要！</p></blockquote><p id="71c4" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">你听说过<em class="kd">记忆</em>吗？这是一件超级简单的事情。只需<em class="kd">记住</em>你从第一次函数调用中得到的结果，并使用它而不是第二次调用函数——不要毫无理由地调用真实的东西，不要浪费你的时间。是的，这只适用于纯函数，当相同参数的结果相同时。</p><blockquote class="jy jz ka"><p id="5dd9" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果结果是一样的，你为什么要做两次呢？</p></blockquote><p id="3c6c" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated"><strong class="ke jc">跳过</strong>一些<strong class="ke jc">密集型操作</strong>是一种很常见的优化技术。每次你可能<strong class="ke jc">不</strong> <strong class="ke jc">做</strong>某事——<strong class="ke jc">不要做</strong>。尽量使用缓存— <code class="fe ld le lf lg b">memcache</code>、<code class="fe ld le lf lg b">file cache</code>、<code class="fe ld le lf lg b">local cache</code> —任意缓存！这是高负载系统的必备组件，也是过去和现在任何后端系统的重要组成部分。</p><p id="8060" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">明白了吗？算了吧！</p><figure class="li lj lk ll gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi lh"><img src="../Images/ec70448aa5d13471f9b08b8c018b5a4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E8-kTJ1JbOkFnmh40K_b4w.jpeg"/></div></div></figure><h1 id="45d8" class="lm ln jb bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">记忆与缓存</h1><blockquote class="jy jz ka"><p id="dde2" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">记忆化就像缓存。只是有点不同。不是<strong class="ke jc">缓存</strong>，姑且称之为<strong class="ke jc">卡舍</strong>。</p></blockquote><p id="d1c4" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">长话短说，但是记忆化不是缓存，也不是永久缓存。记忆甚至听起来像是一瞬间。在服务器端这可能是相当长的一段时间，但在客户端不可能也不应该是真正的长期缓存。更多的是关于可用资源、使用模式和使用的理由。</p><h2 id="8e39" class="mk ln jb bd lo ml mm dn ls mn mo dp lw la mp mq ma lb mr ms me lc mt mu mi mv bi translated">问题—缓存需要一个“缓存键”</h2><p id="496e" class="pw-post-body-paragraph kb kc jb ke b kf mw kh ki kj mx kl km la my kp kq lb mz kt ku lc na kx ky kz ij bi translated">缓存使用一个<strong class="ke jc">字符串</strong> <code class="fe ld le lf lg b">cache key</code>存储和获取数据。构造一个唯一且可用的键已经是一个问题了，但是你必须对数据进行序列化和反序列化，然后再存储在基于字符串的介质中……简而言之，缓存可能没有你想象的那么快，尤其是分布式缓存。</p><h2 id="b53d" class="mk ln jb bd lo ml mm dn ls mn mo dp lw la mp mq ma lb mr ms me lc mt mu mi mv bi translated">记忆不需要任何缓存键</h2><p id="3551" class="pw-post-body-paragraph kb kc jb ke b kf mw kh ki kj mx kl km la my kp kq lb mz kt ku lc na kx ky kz ij bi translated">同时，记忆不需要钥匙。通常* 它按原样使用参数，不试图从它们中创建一个单独的键，也不像缓存通常做的那样，使用一些全局可用的共享对象，如<code class="fe ld le lf lg b">window.cache</code>来存储结果。</p><blockquote class="jy jz ka"><p id="c6e2" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">内存化和缓存的区别在于API接口！</p></blockquote><p id="4ba0" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated"><em class="kd">*通常</em>不代表<em class="kd">总是</em>。默认情况下，<code class="fe ld le lf lg b">Lodash.memoize</code>使用<code class="fe ld le lf lg b">JSON.stringify</code>将传递的参数转换到字符串缓存中。因为他们要用这个键来访问一个内部对象，保存一个缓存的值。<a class="ae nb" href="https://community.risingstack.com/the-worlds-fastest-javascript-memoization-library/" rel="noopener ugc nofollow" target="_blank">快速记忆</a>、<em class="kd">、【最快的记忆库】</em>也是如此。两个命名库都不是<em class="kd">内存化</em>库，而是<em class="kd">缓存</em>库。</p><blockquote class="jy jz ka"><p id="2b39" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">值得一提的是——<code class="fe ld le lf lg b">JSON.stringify</code>可能比你要<em class="jb">记忆</em>的函数慢10倍。</p></blockquote><p id="8f18" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated"><strong class="ke jc">显然，</strong>这个问题最简单的解决方案就是不使用缓存键，并且不使用那个键访问一些内部缓存。所以，记住你被调用的最后一个参数，比如<a class="ae nb" href="https://github.com/thinkloop/memoizerific" rel="noopener ugc nofollow" target="_blank">memoizeric</a>，memoize-one或者reselect do。是的——所有最好的记忆库都是这样做的。</p><blockquote class="jy jz ka"><p id="d1bb" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">memoizeric可能是你唯一想使用的<strong class="ke jc">通用</strong>缓存库。</p></blockquote><h2 id="b1c6" class="mk ln jb bd lo ml mm dn ls mn mo dp lw la mp mq ma lb mr ms me lc mt mu mi mv bi translated">缓存大小</h2><p id="1f92" class="pw-post-body-paragraph kb kc jb ke b kf mw kh ki kj mx kl km la my kp kq lb mz kt ku lc na kx ky kz ij bi translated">所有库之间的第二大区别是缓存大小和缓存结构。</p><p id="e1f8" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">你有没有想过——为什么<code class="fe ld le lf lg b">reselect</code>或<code class="fe ld le lf lg b">memoize-one</code>只持有一个，最后的结果？不是为了"<em class="kd">不使用缓存键能够存储多个结果"</em>，而是因为<strong class="ke jc">没有理由存储比仅一个<strong class="ke jc">最后结果</strong>更多的</strong>。</p><p id="cc34" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">…它更多的是关于:</p><ul class=""><li id="54fd" class="nc nd jb ke b kf kg kj kk la ne lb nf lc ng kz nh ni nj nk bi translated">可用资源——单个缓存行是非常资源友好的</li><li id="f367" class="nc nd jb ke b kf nl kj nm la nn lb no lc np kz nh ni nj nk bi translated">使用模式——记住“原地”的东西是一个好的模式。“就地”你通常只需要一个，最后一个，结果。</li><li id="5f07" class="nc nd jb ke b kf nl kj nm la nn lb no lc np kz nh ni nj nk bi translated">使用理由——模块化、隔离和内存安全是很好的理由。就缓存冲突而言，不与应用程序的其余部分共享缓存更安全。</li></ul><h1 id="31c3" class="lm ln jb bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">单一结果？！</h1><p id="0167" class="pw-post-body-paragraph kb kc jb ke b kf mw kh ki kj mx kl km la my kp kq lb mz kt ku lc na kx ky kz ij bi translated">是的——唯一的一个结果。一个结果记忆了一些经典的东西，比如记忆的斐波那契数生成，你可以在每篇关于记忆的文章中找到这个例子。但是，通常，你在做别的事情——谁需要前端的斐波那契？在后端？真实世界的例子与抽象的IT测验相去甚远。</p><p id="8005" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">但是，关于单值记忆类型还有两个大问题。</p><h2 id="497b" class="mk ln jb bd lo ml mm dn ls mn mo dp lw la mp mq ma lb mr ms me lc mt mu mi mv bi translated">问题1——它很“脆弱”</h2><p id="a1db" class="pw-post-body-paragraph kb kc jb ke b kf mw kh ki kj mx kl km la my kp kq lb mz kt ku lc na kx ky kz ij bi translated">默认情况下—所有参数都应该匹配，确切地说<strong class="ke jc">是“===”相同的</strong>。如果一个论点不匹配，游戏就结束了。即使这来自记忆化的想法——那可能不是你现在想要的东西。我的意思是——你想尽可能多地回忆，尽可能经常地回忆。</p><blockquote class="jy jz ka"><p id="58de" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">即使缓存未命中也是缓存擦除爆头。</p></blockquote><p id="b792" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">“现在”和“过去”之间有一点点不同——不可变的数据结构，例如在Redux中使用的。</p><pre class="li lj lk ll gt nq lg nr ns aw nt bi"><span id="5e1d" class="mk ln jb lg b gy nu nv l nw nx">const getSomeDataFromState = memoize(state =&gt; compute(state.tasks));</span></pre><p id="3627" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">好看吗？向右看？然而当<code class="fe ld le lf lg b">tasks</code>不变的时候<code class="fe ld le lf lg b">state</code>可能会改变，你只需要<code class="fe ld le lf lg b">tasks</code>来匹配。</p><p id="35af" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated"><strong class="ke jc">结构选择者</strong>在这里用他们最强的战士<strong class="ke jc">重新选择</strong>在你的召唤下拯救世界。Reselect不仅仅是记忆化库，它的力量来自记忆化<strong class="ke jc">级联</strong>，或者透镜(它们不是，但是把选择器想象成光学透镜)。</p><pre class="li lj lk ll gt nq lg nr ns aw nt bi"><span id="e1af" class="mk ln jb lg b gy nu nv l nw nx">// every time `state` changes, cached value would be rejected<br/>const getTasksFromState = createSelector(state =&gt; state.tasks);</span><span id="c2c9" class="mk ln jb lg b gy ny nv l nw nx">const getSomeDataFromState = createSelector(<br/>  // `tasks` "without" `state`<br/>  <strong class="lg jc">getTasksFromState</strong>,            <br/>  // and this operation would be memoized "more often"<br/>  tasks =&gt; compute(state.tasks) <br/>);</span></pre><p id="24ac" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">因此，在不可变数据的情况下——您总是必须首先"<strong class="ke jc">关注</strong>您真正需要的数据，然后——执行计算，否则缓存将被拒绝，所有记忆化背后的想法都将消失。</p><p id="1eed" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">这实际上是一个大问题，尤其是对新手来说，但是作为不可变数据结构背后的思想，它有一个显著的好处— <strong class="ke jc">如果某个东西没有被改变—它就没有被改变。如果某件事情发生了变化——很可能就是发生了变化</strong>。这给了我们一个超级快速的比较，但有一些假阴性，就像第一个例子。</p><blockquote class="nz"><p id="2f83" class="oa ob jb bd oc od oe of og oh oi kz dk translated">这个想法是关于“关注”你所依赖的数据</p></blockquote><p id="8c62" class="pw-post-body-paragraph kb kc jb ke b kf oj kh ki kj ok kl km la ol kp kq lb om kt ku lc on kx ky kz ij bi translated">有两个时刻我应该提到:</p><ul class=""><li id="0972" class="nc nd jb ke b kf kg kj kk la ne lb nf lc ng kz nh ni nj nk bi translated"><code class="fe ld le lf lg b">lodash.memoize</code>和<code class="fe ld le lf lg b">fast-memoize</code>正在把你的数据转换成一个字符串，用作一个键。这意味着它们1) <strong class="ke jc">不快</strong> 2) <strong class="ke jc">不安全</strong> 3)可能会产生误报——一些不同的数据可能有相同的字符串表示。这可能会提高“缓存热率”，但实际上是一件非常糟糕的事情。</li><li id="c8f6" class="nc nd jb ke b kf nl kj nm la nn lb no lc np kz nh ni nj nk bi translated">有一种ES6代理方法，关于跟踪所有使用的<em class="kd">给定的</em>个变量，并且只检查重要的键。虽然我个人想创建无数的数据选择器——你可能不喜欢或不理解这个过程，但可能希望开箱即用的适当的内存化——然后使用<a class="ae nb" href="https://github.com/theKashey/memoize-state" rel="noopener ugc nofollow" target="_blank"> memoize-state </a>。</li></ul><div class="ip iq gp gr ir oo"><a rel="noopener  ugc nofollow" target="_blank" href="/how-i-wrote-the-worlds-fastest-react-memoization-library-535f89fc4a17"><div class="op ab fo"><div class="oq ab or cl cj os"><h2 class="bd jc gy z fp ot fr fs ou fu fw ja bi translated">我如何编写世界上最快的反应记忆库</h2><div class="ov l"><h3 class="bd b gy z fp ot fr fs ou fu fw dk translated">实际上我已经试着写了最慢的一个，而“最快的JavaScript记忆库”是一年前写的…</h3></div><div class="ow l"><p class="bd b dl z fp ot fr fs ou fu fw dk translated">itnext.io</p></div></div><div class="ox l"><div class="oy l oz pa pb ox pc ix oo"/></div></div></a></div><h2 id="6714" class="mk ln jb bd lo ml mm dn ls mn mo dp lw la mp mq ma lb mr ms me lc mt mu mi mv bi translated">问题2—它是“一条缓存线”</h2><p id="c2b8" class="pw-post-body-paragraph kb kc jb ke b kf mw kh ki kj mx kl km la my kp kq lb mz kt ku lc na kx ky kz ij bi translated">无限的缓存大小是一个杀手。只要内存非常有限，任何不受控制的缓存都是杀手。所以——所有最好的库都是“一个缓存行长”。这是一个功能和强大的设计决策。我刚刚写了它是多么正确，相信我——这确实是一件<strong class="ke jc">正确</strong>的事情，但它<strong class="ke jc">仍然是一个问题</strong>。一个大问题。</p><pre class="li lj lk ll gt nq lg nr ns aw nt bi"><span id="ce61" class="mk ln jb lg b gy nu nv l nw nx">const tasks = getTasks(state);</span><span id="a9f7" class="mk ln jb lg b gy ny nv l nw nx"><br/>// let's get some data from state1 (function was defined above)<br/>getDataFromTask(tasks[0]); <br/>// 🚀</span><span id="0c31" class="mk ln jb lg b gy ny nv l nw nx">equal(getDataFromTask(tasks[0]), getDataFromTask(tasks[0])) <br/>//🔥</span><span id="b7ba" class="mk ln jb lg b gy ny nv l nw nx">getDataFromTask(tasks<strong class="lg jc">[1]</strong>); <br/>// a different task? What the heck?<br/>// oh! That's <strong class="lg jc">another</strong> argument? How dare you!?</span><span id="c349" class="mk ln jb lg b gy ny nv l nw nx">// TLDR -&gt; task[0] in the cache got replaced by task[1]</span><span id="f2e4" class="mk ln jb lg b gy ny nv l nw nx">🤷‍♂️ you cannot use getDataFromTask to get data from different tasks</span></pre><p id="8610" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">一旦<strong class="ke jc">相同的</strong>选择器不得不与<strong class="ke jc">不同的</strong>源数据一起工作，而且不止一个——一切都被打破了。而且很容易碰到这样的问题:</p><ul class=""><li id="fde9" class="nc nd jb ke b kf kg kj kk la ne lb nf lc ng kz nh ni nj nk bi translated">只要我们使用选择器从一个状态中获取任务，我们就可以使用相同的选择器从一个任务中获取某些东西。激烈来自于API本身。但它不工作，那么你只能记住最后一次调用，但必须与多个数据源。</li><li id="ab3c" class="nc nd jb ke b kf nl kj nm la nn lb no lc np kz nh ni nj nk bi translated">多个React组件也有同样的问题——它们都是相同的，但都有一点不同，获取不同的<code class="fe ld le lf lg b">tasks</code>，擦除彼此的结果。</li></ul><p id="627c" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">有3种可能的解决方案:</p><ul class=""><li id="8094" class="nc nd jb ke b kf kg kj kk la ne lb nf lc ng kz nh ni nj nk bi translated">如果<strong class="ke jc">重复</strong>——使用<code class="fe ld le lf lg b">mapStateToProps</code>工厂。它将创建每个实例的记忆。</li></ul><pre class="li lj lk ll gt nq lg nr ns aw nt bi"><span id="b4ea" class="mk ln jb lg b gy nu nv l nw nx">const mapStateToProps = () =&gt; {<br/>   const selector = createSelector(...); <br/>   // ^ you have to define per-instance selectors here<br/>   // usually that's not possible :)  <br/>   return state =&gt; ({<br/>      data: selector(data), // a usual mapStateToProps<br/>   });<br/>}</span></pre><ul class=""><li id="b182" class="nc nd jb ke b kf kg kj kk la ne lb nf lc ng kz nh ni nj nk bi translated">第二个变体几乎相同(对于redux也是如此)——它是关于使用<a class="ae nb" href="https://github.com/toomuchdesign/re-reselect" rel="noopener ugc nofollow" target="_blank">重新选择</a>。这是一个复杂的库，通过区分组件可以化险为夷。它可以理解，新的调用是针对“另一个”组件的，并且它可以为“前一个”组件保留缓存。</li></ul><figure class="li lj lk ll gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi pd"><img src="../Images/b034bf0e93a88dc43630bca761e67ca6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jk1pqQMN_w1nnNp1PVf5Hw.png"/></div></div><figcaption class="pe pf gj gh gi pg ph bd b be z dk translated">重新选择缓存桶</figcaption></figure><p id="27d9" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">这个库可以帮助你“保留”记忆缓存，但不能删除它。尤其是因为它正在实现5(五！)适合任何情况的不同缓存策略。那是一股难闻的气味。选错了怎么办？</p><p id="3d8e" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">你记住的所有数据——你迟早会忘记的。重点不在于记住最后一次函数调用——重点是在适当的时候忘记它。不要太快，破坏记忆，也不要太晚。</p><blockquote class="jy jz ka"><p id="5cbf" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">明白了吗？现在算了吧！</p></blockquote><h1 id="92b4" class="lm ln jb bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">让我们暂停一下</h1><p id="12c4" class="pw-post-body-paragraph kb kc jb ke b kf mw kh ki kj mx kl km la my kp kq lb mz kt ku lc na kx ky kz ij bi translated">停下来。放松点。做一个深呼吸。回答一个简单的问题——目标是什么？我们必须做些什么来达到目标？什么能拯救这一天？</p><blockquote class="nz"><p id="3892" class="oa ob jb bd oc od oe of og oh oi kz dk translated">提示:那个该死的“隐藏”在哪里！</p></blockquote><figure class="pj pk pl pm pn is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi pi"><img src="../Images/43ae89b6524a57abdd2eb6959ef08d34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AZ4GcvGVELDqzVQoqQpzWQ.jpeg"/></div></div></figure><p id="ce69" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">那个该死的“贮藏库”在哪里？是的——这是个正确的问题。谢谢你的提问。答案很简单——它<strong class="ke jc">位于一个封闭物</strong>中。在内存函数内部的<em class="kd">隐藏点。举个例子，这是memoize-one代码:</em></p><pre class="li lj lk ll gt nq lg nr ns aw nt bi"><span id="9499" class="mk ln jb lg b gy nu nv l nw nx">function(fn) {<br/>  let lastArgs;  // the last arguments<br/>  let <strong class="lg jc">lastResult</strong>;// the last result</span><span id="b2f1" class="mk ln jb lg b gy ny nv l nw nx">// the memoized function<br/>const memoizedCall = function(...newArgs) {<br/>    if (isEqual(newArgs, lastArgs)) {<br/>      return lastResult;<br/>    }</span><span id="f3c2" class="mk ln jb lg b gy ny nv l nw nx">    lastResult = resultFn.apply(this, newArgs);<br/>    lastArgs = newArgs;<br/>    return lastResult;<br/>  };</span><span id="445b" class="mk ln jb lg b gy ny nv l nw nx">return memoizedCall;<br/>}</span></pre><p id="41f5" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">您将获得一个<code class="fe ld le lf lg b">memoizedCall</code>，它将保存附近的最后一个结果<em class="kd">，在其本地闭包内，除了<code class="fe ld le lf lg b">memoizedCall</code>之外，任何人都不能访问。一个安全的地方。这个“T23”是一个安全的地方。</em></p><p id="1dd6" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated"><code class="fe ld le lf lg b">Reselect</code>做同样的事情，唯一的方法是创建一个“分支”，用另一个<em class="kd">缓存</em>——创建一个新的内存化闭包。</p><blockquote class="nz"><p id="c0ef" class="oa ob jb bd oc od oe of og oh oi kz dk translated">但是(另一个)主要问题是，它(缓存)何时会“消失”？</p></blockquote><blockquote class="jy jz ka"><p id="674a" class="kb kc kd ke b kf oj kh ki kj ok kl km kn ol kp kq kr om kt ku kv on kx ky kz ij bi translated">TLDR:当函数实例被垃圾收集器吃掉时，它就和函数一起“消失”了。</p></blockquote><p id="7b71" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">实例？实例！那么，什么是<strong class="ke jc">每实例内存化？</strong>React文档中有一整篇关于它的文章:</p><div class="ip iq gp gr ir oo"><a href="https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#what-about-memoization" rel="noopener  ugc nofollow" target="_blank"><div class="op ab fo"><div class="oq ab or cl cj os"><h2 class="bd jc gy z fp ot fr fs ou fu fw ja bi translated">你可能不需要衍生的状态反应博客</h2><div class="ov l"><h3 class="bd b gy z fp ot fr fs ou fu fw dk translated">React 16.4包含一个getDerivedStateFromProps的错误修复，该错误导致React组件中的一些现有错误…</h3></div><div class="ow l"><p class="bd b dl z fp ot fr fs ou fu fw dk translated">reactjs.org</p></div></div><div class="ox l"><div class="po l oz pa pb ox pc ix oo"/></div></div></a></div><p id="3e0d" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">因此，如果您使用基于类的React组件，您可能会:</p><pre class="li lj lk ll gt nq lg nr ns aw nt bi"><span id="1606" class="mk ln jb lg b gy nu nv l nw nx">import memoize from "memoize-one";</span><span id="1f18" class="mk ln jb lg b gy ny nv l nw nx">class Example extends Component {<br/>  <strong class="lg jc">filter = memoize</strong>(<br/>    (list, filterText) =&gt; list.filter(...);<br/>  // ^ that is "per instance" memoization<br/>  // we are creating "own" memoization function<br/>  // with the "own" lastResult</span><span id="e850" class="mk ln jb lg b gy ny nv l nw nx">render() {<br/>    // Calculate the latest filtered list. <br/>    // If these arguments haven't changed since the last render, <br/>    // `memoize-one` will reuse the last return value.<br/>    const filteredList = this.filter(something, somehow);</span><span id="2c97" class="mk ln jb lg b gy ny nv l nw nx">    return &lt;ul&gt;{filteredList.map(item =&gt; ...}&lt;/ul&gt;<br/>  }<br/>}</span></pre><p id="d359" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">那么“<strong class="ke jc">last result”</strong>存储在哪里呢？在内存化的<strong class="ke jc">过滤器</strong>的局部范围内，在<strong class="ke jc">这个</strong>类实例内。长话短说…</p><blockquote class="nz"><p id="2675" class="oa ob jb bd oc od oe of og oh oi kz dk translated">它什么时候会“消失”？</p></blockquote><p id="11a4" class="pw-post-body-paragraph kb kc jb ke b kf oj kh ki kj ok kl km la ol kp kq lb om kt ku lc on kx ky kz ij bi translated">这一次，它将随着一个类实例“消失”。一旦组件被卸载，它就会消失得无影无踪。这是一个真正的“每个实例”，您可以使用<strong class="ke jc"> this.lastResult </strong>来保存一个临时结果，具有完全相同的“记忆化”效果。</p><h1 id="94dd" class="lm ln jb bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">反应呢。钩住</h1><p id="009a" class="pw-post-body-paragraph kb kc jb ke b kf mw kh ki kj mx kl km la my kp kq lb mz kt ku lc na kx ky kz ij bi translated">我们越来越近了。Redux挂钩有几个可疑的命令，可能是关于内存化的。比如— <code class="fe ld le lf lg b">useMemo</code>、<code class="fe ld le lf lg b">useCallback</code>、<code class="fe ld le lf lg b">useRef</code></p><blockquote class="jy jz ka"><p id="c79c" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><a class="ae nb" href="https://reactjs.org/docs/hooks-reference.html#usememo" rel="noopener ugc nofollow" target="_blank"> useMemo </a>只会在其中一个依赖关系改变时重新计算记忆值。</p></blockquote><figure class="li lj lk ll gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi pp"><img src="../Images/fa24510bfd65358879a83f4da3f7673e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tanRFdDzrObEkeSJP_xjUA.png"/></div></div></figure><blockquote class="nz"><p id="e98c" class="oa ob jb bd oc od pq pr ps pt pu kz dk translated">但问题是——这次它在哪里存储记忆值呢？</p></blockquote><p id="92a8" class="pw-post-body-paragraph kb kc jb ke b kf oj kh ki kj ok kl km la ol kp kq lb om kt ku lc on kx ky kz ij bi translated">简而言之——它将它存储在“钩子”中，在VDOM元素的一个特殊部分，称为与当前元素相关联的<code class="fe ld le lf lg b">fiber</code>。在并行数据结构中。</p><p id="1fc2" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">没那么短——钩子改变了你程序的工作方式，将你的函数移到另一个函数中，一些变量在父闭包的隐藏点中。这样的函数被称为可挂起的，或可恢复的，或<strong class="ke jc">协程</strong>。在JavaScript中，它们通常被称为生成器或异步函数。</p><p id="b0f6" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">但这有点极端。简而言之— <code class="fe ld le lf lg b">useMemo</code>就是在<strong class="ke jc">这个</strong>中存储记忆值。只是“这个”有点不一样。</p><blockquote class="jy jz ka"><p id="e347" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果我们想创建一个更好的记忆库，我们应该找到一个更好的“this”。</p></blockquote><blockquote class="nz"><p id="2861" class="oa ob jb bd oc od pq pr ps pt pu kz dk translated">Zing！</p></blockquote><figure class="pj pk pl pm pn is gh gi paragraph-image"><div class="gh gi pv"><img src="../Images/82ddb37501eebf4e7ad3974d6befb9ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:870/1*be6YOZws0_yl-MEztAYbjA.gif"/></div></figure><h1 id="008a" class="lm ln jb bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">孬种！</h1><p id="4df4" class="pw-post-body-paragraph kb kc jb ke b kf mw kh ki kj mx kl km la my kp kq lb mz kt ku lc na kx ky kz ij bi translated">是啊！孬种！存储键值，其中<code class="fe ld le lf lg b">key</code>是<code class="fe ld le lf lg b">this</code>，只要WeakMap不接受除<code class="fe ld le lf lg b">this</code>之外的任何东西，即“objects”。</p><p id="3dbe" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">让我们创建一个简单的例子:</p><pre class="li lj lk ll gt nq lg nr ns aw nt bi"><span id="01ea" class="mk ln jb lg b gy nu nv l nw nx">const createHiddenSpot = (fn) =&gt; {<br/>  const map = new WeakMap(); // a hidden "closure"<br/>  const set = (key, value) =&gt; (map.set(key, value), value);</span><span id="09fb" class="mk ln jb lg b gy ny nv l nw nx">  return (key) =&gt; { <br/>     return map.get(key) || set(key, fn(key))<br/>  }<br/>}</span><span id="9266" class="mk ln jb lg b gy ny nv l nw nx">const weakSelect = createHiddenSpot(selector);<br/>weakSelect(todos);    // create a new entry<br/>weakSelect(todos);    // return an existing entry<br/>weakSelect(todos[0]); // create a new entry<br/>weakSelect(todos[1]); // create a new entry<br/>weakSelect(todos[0]); // return an existing entry!<br/>weakSelect(todos[1]); // return an existing entry!!<br/>weakSelect(todos);    // return an existing entry!!!</span></pre><p id="99e9" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">这非常简单，而且非常“正确”。所以“它什么时候会消失”？</p><ul class=""><li id="6523" class="nc nd jb ke b kf kg kj kk la ne lb nf lc ng kz nh ni nj nk bi translated">忘记<code class="fe ld le lf lg b">weakSelect</code>,整个“地图”就会消失</li><li id="78f4" class="nc nd jb ke b kf nl kj nm la nn lb no lc np kz nh ni nj nk bi translated">忘记<code class="fe ld le lf lg b">todos[0]</code>和他们的<em class="kd">弱</em>条目就会消失</li><li id="5c7d" class="nc nd jb ke b kf nl kj nm la nn lb no lc np kz nh ni nj nk bi translated">忘记<code class="fe ld le lf lg b">todos</code>——记忆数据将会消失！</li></ul><blockquote class="nz"><p id="512f" class="oa ob jb bd oc od pq pr ps pt pu kz dk translated">很清楚什么时候会“消失”</p></blockquote><blockquote class="jy jz ka"><p id="f5ba" class="kb kc kd ke b kf oj kh ki kj ok kl km kn ol kp kq kr om kt ku kv on kx ky kz ij bi translated">TL；DR —只在应该的时候。</p></blockquote><p id="9f4f" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">神奇的是，所有的<code class="fe ld le lf lg b">reselect</code>问题都消失了。与<em class="kd">激进的</em>记忆化有关的问题——也是一去不复返了。</p><p id="fb30" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">这种方法<strong class="ke jc">记住</strong>的数据，直到<strong class="ke jc">忘记</strong>为止。这是难以置信的，但要更好地记住一些事情，你必须能够更好地忘记它。</p><p id="7222" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">唯一持久的是—为这种情况创建一个更健壮的API</p><h1 id="a852" class="lm ln jb bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">Kashe —是一个缓存</h1><p id="b0a0" class="pw-post-body-paragraph kb kc jb ke b kf mw kh ki kj mx kl km la my kp kq lb mz kt ku lc na kx ky kz ij bi translated"><code class="fe ld le lf lg b">kashe</code>是一个基于WeakMap的记忆库，可以拯救你的一天。</p><div class="ip iq gp gr ir oo"><a href="https://github.com/theKashey/kashe" rel="noopener  ugc nofollow" target="_blank"><div class="op ab fo"><div class="oq ab or cl cj os"><h2 class="bd jc gy z fp ot fr fs ou fu fw ja bi translated">theKashey/kashe</h2><div class="ov l"><h3 class="bd b gy z fp ot fr fs ou fu fw dk translated">🤯有时缓存是kashe。在GitHub上创建一个帐户，为Kashey/kashe的发展做出贡献。</h3></div><div class="ow l"><p class="bd b dl z fp ot fr fs ou fu fw dk translated">github.com</p></div></div><div class="ox l"><div class="pw l oz pa pb ox pc ix oo"/></div></div></a></div><p id="d42a" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">这个库公开了4个函数</p><ul class=""><li id="0f0c" class="nc nd jb ke b kf kg kj kk la ne lb nf lc ng kz nh ni nj nk bi translated"><code class="fe ld le lf lg b">kashe</code>—用于记忆。</li><li id="ac58" class="nc nd jb ke b kf nl kj nm la nn lb no lc np kz nh ni nj nk bi translated"><code class="fe ld le lf lg b">box</code> —对于前缀记忆，增加记忆的机会。</li><li id="8d91" class="nc nd jb ke b kf nl kj nm la nn lb no lc np kz nh ni nj nk bi translated"><code class="fe ld le lf lg b">inbox</code> —嵌套前缀记忆化，以_减少_改变记忆化</li><li id="3c37" class="nc nd jb ke b kf nl kj nm la nn lb no lc np kz nh ni nj nk bi translated"><code class="fe ld le lf lg b">fork</code> — to _fork_(明显)记忆化。</li></ul><h2 id="103d" class="mk ln jb bd lo ml mm dn ls mn mo dp lw la mp mq ma lb mr ms me lc mt mu mi mv bi translated">kashe(fn) =&gt; memoizedFn(…args)</h2><p id="d486" class="pw-post-body-paragraph kb kc jb ke b kf mw kh ki kj mx kl km la my kp kq lb mz kt ku lc na kx ky kz ij bi translated">它实际上是上一个示例中的createHiddenSpot。它将使用第一个参数作为内部WeakMap的<code class="fe ld le lf lg b">key</code>。</p><pre class="li lj lk ll gt nq lg nr ns aw nt bi"><span id="42dd" class="mk ln jb lg b gy nu nv l nw nx">const selector = (state, prop) =&gt; ({result: state[prop]});<br/>const memoized = kashe(selector);<br/>const old = memoized(state, 'x')<br/>memoized(state, 'x') === old<br/>memoized(state, 'y') === memoized(state, 'y') <br/>// ^^ another argument</span><span id="a8a0" class="mk ln jb lg b gy ny nv l nw nx">// but<br/>old !== memoized(state, 'x') // 'y' wiped 'x' cache in `state`</span></pre><p id="0550" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated"><strong class="ke jc">第一个参数</strong>是一个键，如果你再次调用同一个函数<code class="fe ld le lf lg b">key</code>，但是不同的参数——缓存将被替换，它仍然是一个缓存行长的内存化。为了让它工作——你必须为不同的情况提供不同的<code class="fe ld le lf lg b">keys</code>,就像我用<code class="fe ld le lf lg b">weakSelect</code>例子做的那样，以提供不同的this来保存结果。重选瀑布A还是那个东西。</p><p id="61e5" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">并非所有功能都是可记忆的。第一个参数必须是对象、数组或函数。它应该可以用作<code class="fe ld le lf lg b">WeakMap</code>的按键。</p><h2 id="2d4a" class="mk ln jb bd lo ml mm dn ls mn mo dp lw la mp mq ma lb mr ms me lc mt mu mi mv bi translated">box(fn) =&gt; memoizedFn2(box，…args)</h2><p id="eb25" class="pw-post-body-paragraph kb kc jb ke b kf mw kh ki kj mx kl km la my kp kq lb mz kt ku lc na kx ky kz ij bi translated">这是同一个功能，只是<strong class="ke jc">应用了两次</strong>。一次用于<code class="fe ld le lf lg b">fn</code>，一次用于<code class="fe ld le lf lg b">memoizedFn</code>，为参数添加前导<code class="fe ld le lf lg b">key</code>。它可能会使任何功能<em class="kd">可记忆</em>。</p><blockquote class="jy jz ka"><p id="6e91" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这是相当声明性的-嘿功能！我将<strong class="ke jc">将结果存储在这个</strong> <code class="fe ld le lf lg b"><strong class="ke jc">box</strong></code>中。</p></blockquote><pre class="li lj lk ll gt nq lg nr ns aw nt bi"><span id="d858" class="mk ln jb lg b gy nu nv l nw nx">// could not be "kashe" memoized<br/>const addTwo = (a,b) =&gt; ({ result: a+b }); </span><span id="764c" class="mk ln jb lg b gy ny nv l nw nx">const bAddTwo = boxed(addTwo);<br/>const cacheKey = {}; // any object</span><span id="876e" class="mk ln jb lg b gy ny nv l nw nx">bAddTwo(cacheKey, 1, 2) === bAddTwo(cacheKey, 1, 2) === { result: 3}</span></pre><p id="026c" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">如果你<code class="fe ld le lf lg b">box</code>已经记忆了函数——你将增加记忆的机会，比如每个实例记忆——你可以创建<strong class="ke jc">记忆级联。</strong></p><pre class="li lj lk ll gt nq lg nr ns aw nt bi"><span id="2a0e" class="mk ln jb lg b gy nu nv l nw nx">const selectSomethingFromTodo = (state, prop) =&gt; ...<br/>const selector = kashe(selectSomethingFromTodo);<br/>const boxedSelector = kashe(selector);</span><span id="0a7a" class="mk ln jb lg b gy ny nv l nw nx">class Component {<br/>  render () {<br/>    const result = boxedSelector(this, todos, this.props.todoId);<br/>    // 1. try to find result in `this`<br/>    // 2. try to find result in `todos`<br/>    // 3. store in `todos`<br/>    // 4. store in `this`</span><span id="a2c6" class="mk ln jb lg b gy ny nv l nw nx">    // if multiple `this`(components) are reading from `todos` - <br/>    // selector is not working (they are wiping each other)<br/>    // but data stored in `this` - exists.</span><span id="3379" class="mk ln jb lg b gy ny nv l nw nx">    ...<br/>  }<br/>} </span></pre><h2 id="8b32" class="mk ln jb bd lo ml mm dn ls mn mo dp lw la mp mq ma lb mr ms me lc mt mu mi mv bi translated">inbox(fn) =&gt; memoizedFn2(box，…args)</h2><p id="6832" class="pw-post-body-paragraph kb kc jb ke b kf mw kh ki kj mx kl km la my kp kq lb mz kt ku lc na kx ky kz ij bi translated">这个与box相反，但是做的几乎一样，命令嵌套缓存将数据存储到提供的<code class="fe ld le lf lg b">box</code>中。从一个角度来看，它降低了记忆化的可能性(没有记忆化级联)。但是从另一个角度来看——它消除了缓存冲突，并且有助于隔离进程，如果它们不应该由于任何原因相互干扰的话。</p><blockquote class="jy jz ka"><p id="e20e" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">很有宣示性——嘿！所有人都进去！这里有一个<code class="fe ld le lf lg b">box</code>可以使用</p></blockquote><pre class="li lj lk ll gt nq lg nr ns aw nt bi"><span id="28f4" class="mk ln jb lg b gy nu nv l nw nx">const getAndSet = (task, number) =&gt; task.value + number;<br/>const memoized = kashe(getAndSet);<br/>const inboxed = inbox(getAndSet);<br/>const doubleBoxed = inbox(memoized);</span><span id="944f" class="mk ln jb lg b gy ny nv l nw nx">memoized(task, 1) // ok<br/>memoized(task, 2) // previous result wiped</span><span id="765b" class="mk ln jb lg b gy ny nv l nw nx">inboxed(key1, task, 1) // ok<br/>inboxed(key2, task, 2) // ok</span><span id="ae48" class="mk ln jb lg b gy ny nv l nw nx">// inbox also override the cache for any underlaying kashe calls<br/>doubleBoxed(key1, task, 1) // ok<br/>doubleBoxed(key2, task, 2) // ok</span></pre><h2 id="a307" class="mk ln jb bd lo ml mm dn ls mn mo dp lw la mp mq ma lb mr ms me lc mt mu mi mv bi translated">fork(kashe-memo ized)= &gt; kashe-memo ized</h2><p id="33af" class="pw-post-body-paragraph kb kc jb ke b kf mw kh ki kj mx kl km la my kp kq lb mz kt ku lc na kx ky kz ij bi translated">Fork是一个真正的fork——它获取任何<em class="kd"> kashe-memoized </em>函数，并返回相同的结果，但带有另一个内部缓存条目。还记得redux mapStateToProps工厂方法吗？</p><pre class="li lj lk ll gt nq lg nr ns aw nt bi"><span id="126e" class="mk ln jb lg b gy nu nv l nw nx">const mapStateToProps = () =&gt; {<br/>   // const selector = createSelector(...); // <br/>   const selector = fork(realSelector);<br/>   // just fork existing selector. Or box it, or don't do anything<br/>   // kashe is more "stable" than reselect.</span><span id="d9a0" class="mk ln jb lg b gy ny nv l nw nx">   return state =&gt; ({<br/>      data: selector(data),<br/>   });<br/>}</span></pre><h1 id="6ad5" class="lm ln jb bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">重新选</h1><p id="99f5" class="pw-post-body-paragraph kb kc jb ke b kf mw kh ki kj mx kl km la my kp kq lb mz kt ku lc na kx ky kz ij bi translated">还有一件事你应该知道— <strong class="ke jc"> kashe可以代替reselect </strong>。字面上。</p><pre class="li lj lk ll gt nq lg nr ns aw nt bi"><span id="28fa" class="mk ln jb lg b gy nu nv l nw nx">import { createSelector } from 'kashe/reselect';</span></pre><p id="fadf" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">它实际上是同样的<code class="fe ld le lf lg b">reselect</code>，只是用<code class="fe ld le lf lg b">kashe</code>作为记忆功能创建的。</p><blockquote class="nz"><p id="07a5" class="oa ob jb bd oc od oe of og oh oi kz dk translated">全部测试完毕，准备就绪！</p></blockquote><figure class="pj pk pl pm pn is"><div class="bz fp l di"><div class="px py l"/></div></figure><blockquote class="jy jz ka"><p id="be14" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">PS:值得一提的是，这种方法的更简单的版本——<a class="ae nb" href="https://github.com/emotion-js/emotion/tree/master/packages/weak-memoize" rel="noopener ugc nofollow" target="_blank">weak-memo ize</a>——在emotion-js中使用了一段时间。没有抱怨。<a class="ae nb" href="https://medium.com/@anywhichway/nano-memoize-faster-than-fast-smaller-than-micro-c8a8d626bb82" rel="noopener"> nano-memoize </a>也将WeakMaps用于单参数情况。</p></blockquote><figure class="li lj lk ll gt is"><div class="bz fp l di"><div class="pz py l"/></div></figure><p id="357a" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">明白了吗？“较弱”的方法会帮助你更好地记住一些东西，也更好地忘记它。是的，关于遗忘——你能看这里吗？</p><figure class="li lj lk ll gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi qa"><img src="../Images/efc83110fbadd00d0264ab229231f598.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yDW6XqeYRYn3WgG_SGN94A.jpeg"/></div></div></figure></div></div>    
</body>
</html>