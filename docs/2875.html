<html>
<head>
<title>Benefits of Identity Monad in Scala Cats</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Scala猫中身份单子的好处</h1>
<blockquote>原文：<a href="https://itnext.io/benefits-of-identity-monad-in-scala-cats-a2cb0baef639?source=collection_archive---------7-----------------------#2019-08-19">https://itnext.io/benefits-of-identity-monad-in-scala-cats-a2cb0baef639?source=collection_archive---------7-----------------------#2019-08-19</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><figure class="gm go js jt ju jv gi gj paragraph-image"><div class="gi gj jr"><img src="../Images/10642dc187730075a423729873c1c811.png" data-original-src="https://miro.medium.com/v2/resize:fit:848/format:webp/1*hWssOPPeUF-Az-37M-0ReA.jpeg"/></div></figure><p id="841a" class="pw-post-body-paragraph jy jz iu ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv in bi translated">在开始讲述cat中的身份Monad之前，让我们简单描述一下Monad及其在函数式编程中的用法。</p><h1 id="c021" class="kw kx iu bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">什么是单子</h1><p id="f3b6" class="pw-post-body-paragraph jy jz iu ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv in bi translated">根据<a class="ae lz" href="https://typelevel.org/cats/typeclasses/monad.html" rel="noopener ugc nofollow" target="_blank">猫文档</a>一个月:</p><blockquote class="ma mb mc"><p id="dc42" class="jy jz md ka b kb kc kd ke kf kg kh ki me kk kl km mf ko kp kq mg ks kt ku kv in bi translated">允许组合相关的有效函数。</p></blockquote><p id="fb26" class="pw-post-body-paragraph jy jz iu ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv in bi translated">这个定义非常简短，包含了一些新概念，比如<code class="fe mh mi mj mk b">dependent</code> <code class="fe mh mi mj mk b">effectful</code>或者<code class="fe mh mi mj mk b">composition</code>。有几个内容试图以不同的方式描述单子概念:</p><div class="ml mm gq gs mn mo"><a href="https://typelevel.org/cats/typeclasses/monad.html" rel="noopener  ugc nofollow" target="_blank"><div class="mp ab fp"><div class="mq ab mr cl cj ms"><h2 class="bd iv gz z fq mt fs ft mu fv fx it bi translated">猫:单子</h2><div class="mv l"><h3 class="bd b gz z fq mt fs ft mu fv fx dk translated">Monad用一个新的函数flatten扩展了应用类型类。Flatten接受嵌套上下文中的值(例如…</h3></div><div class="mw l"><p class="bd b dl z fq mt fs ft mu fv fx dk translated">typelevel.org</p></div></div><div class="mx l"><div class="my l mz na nb mx nc jw mo"/></div></div></a></div><p id="833f" class="pw-post-body-paragraph jy jz iu ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv in bi translated">或者这个:</p><div class="ml mm gq gs mn mo"><a href="https://blog.knoldus.com/scalafp-lets-find-reasons-behind-monads/" rel="noopener  ugc nofollow" target="_blank"><div class="mp ab fp"><div class="mq ab mr cl cj ms"><h2 class="bd iv gz z fq mt fs ft mu fv fx it bi translated">ScalaFP:让我们找到单子背后的原因。</h2><div class="mv l"><h3 class="bd b gz z fq mt fs ft mu fv fx dk translated">函数式编程中的单子起着重要的作用，但它们最让初学者困惑。…的原因之一</h3></div><div class="mw l"><p class="bd b dl z fq mt fs ft mu fv fx dk translated">blog.knoldus.com</p></div></div><div class="mx l"><div class="nd l mz na nb mx nc jw mo"/></div></div></a></div><p id="a2e3" class="pw-post-body-paragraph jy jz iu ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv in bi translated">您可以阅读这些好文章来了解更多关于Monad的信息，但首先，请从不同的角度在一个段落中阅读Monad的定义(然后继续讨论同一性Monad):</p><p id="482e" class="pw-post-body-paragraph jy jz iu ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv in bi translated"><strong class="ka iv">在</strong> <code class="fe mh mi mj mk b"><strong class="ka iv">Monad[F[_]]</strong></code> <strong class="ka iv">，</strong> <code class="fe mh mi mj mk b"><strong class="ka iv">F</strong></code> <strong class="ka iv">表示“效果”或“计算上下文”，如</strong> <code class="fe mh mi mj mk b"><strong class="ka iv">Future</strong></code> <strong class="ka iv">，</strong> <code class="fe mh mi mj mk b"><strong class="ka iv">Either</strong></code> <strong class="ka iv">或</strong> <code class="fe mh mi mj mk b"><strong class="ka iv">Option</strong></code> <strong class="ka iv">，允许将函数(</strong> <code class="fe mh mi mj mk b"><strong class="ka iv">A =&gt; B</strong></code> <strong class="ka iv">或</strong> <code class="fe mh mi mj mk b"><strong class="ka iv">A =&gt; F[B]</strong></code> <strong class="ka iv">)应用于单个有效值(</strong> <code class="fe mh mi mj mk b"><strong class="ka iv">A</strong></code> 【T31)，而无需“离开”该“效果”或“计算上下文”(【T31</p><p id="17d2" class="pw-post-body-paragraph jy jz iu ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv in bi translated">现在来看看Monad类型类的简化版本:</p><figure class="ne nf ng nh gu jv"><div class="bz fq l di"><div class="ni nj l"/></div><figcaption class="nk nl gk gi gj nm nn bd b be z dk translated">Monad类型类的简化版本</figcaption></figure><h1 id="31fe" class="kw kx iu bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">什么是同一性单子？</h1><p id="07ce" class="pw-post-body-paragraph jy jz iu ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv in bi translated">让我们继续一个例子。我们将使用Monad编写一个通用函数，将两个字符串附加到包装在Monad中的参数上，并在结果的开头添加一个echo，然后返回Monad作为结果:</p><figure class="ne nf ng nh gu jv"><div class="bz fq l di"><div class="ni nj l"/></div></figure><p id="bd61" class="pw-post-body-paragraph jy jz iu ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv in bi translated">这个函数只适用于打包成单子的所有字符串值(如Option、Future或…)，但不适用于普通字符串值。为了解决这类问题，猫提供了身份类型。同一性单子的定义是:</p><figure class="ne nf ng nh gu jv"><div class="bz fq l di"><div class="ni nj l"/></div></figure><p id="3be7" class="pw-post-body-paragraph jy jz iu ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv in bi translated">Identity Monad是一个类型别名，它将类型转换为单参数类型构造函数。我们可以将任何类型的任何值转换为相应的Id。我们可以这样使用它:</p><figure class="ne nf ng nh gu jv"><div class="bz fq l di"><div class="ni nj l"/></div></figure><p id="f9d7" class="pw-post-body-paragraph jy jz iu ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv in bi translated">或者更简单地说:</p><figure class="ne nf ng nh gu jv"><div class="bz fq l di"><div class="ni nj l"/></div></figure><h1 id="ff24" class="kw kx iu bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">结论</h1><p id="3285" class="pw-post-body-paragraph jy jz iu ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv in bi translated">单位单子允许我们编写处理一元和非一元值的函数，它非常强大，因为我们可以在生产中将值包装到<strong class="ka iv">“效果”或“计算上下文”</strong>中，并将它们从<strong class="ka iv">“效果”或“计算上下文”</strong>中移除，以便使用单位单子进行测试。例如，我们可以使用Future在产品中异步运行代码，使用Identity Monad在测试中同步运行代码，并轻松地在异步和同步世界之间切换。</p></div><div class="ab cl no np hy nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="in io ip iq ir"><h1 id="6247" class="kw kx iu bd ky kz nv lb lc ld nw lf lg lh nx lj lk ll ny ln lo lp nz lr ls lt bi translated">资源:</h1><ul class=""><li id="131e" class="oa ob iu ka b kb lu kf lv kj oc kn od kr oe kv of og oh oi bi translated"><a class="ae lz" href="https://underscore.io/books/scala-with-cats/" rel="noopener ugc nofollow" target="_blank">斯卡拉与猫书</a></li><li id="bd67" class="oa ob iu ka b kb oj kf ok kj ol kn om kr on kv of og oh oi bi translated"><a class="ae lz" href="https://typelevel.org/cats/" rel="noopener ugc nofollow" target="_blank">猫咪纪录片</a></li></ul></div></div>    
</body>
</html>