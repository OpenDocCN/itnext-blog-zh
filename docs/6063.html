<html>
<head>
<title>React Higher-Order Components with TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用TypeScript反应高阶组件</h1>
<blockquote>原文：<a href="https://itnext.io/react-higher-order-components-with-typescript-e41c64954825?source=collection_archive---------0-----------------------#2021-08-08">https://itnext.io/react-higher-order-components-with-typescript-e41c64954825?source=collection_archive---------0-----------------------#2021-08-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/b3568806aaad4199bacdca1f235c2212.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Yq3F2WfqCQrwoAs6hAJBEQ.png"/></div></div></figure><p id="0d1b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">有些React模式在TypeScript中实现起来比其他模式更棘手，需要了解正确的方法并利用正确的TypeScript特性。高阶分量就是这样一种模式。</p><p id="b70b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在本帖中，我们将探索如何从头开始创建一个高阶组件，并使用泛型和实用程序类型动态计算它的正确需求。</p><h1 id="b7b5" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">什么是高阶分量？</h1><p id="b384" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated"><a class="ae mc" href="https://reactjs.org/docs/higher-order-components.html" rel="noopener ugc nofollow" target="_blank">高阶组件</a> (HOC)是一个接受另一个组件并将附加属性注入其中的函数。可以把它想象成用一个额外的层来包装你的组件，给它更多的功能。</p><p id="c6d9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">hoc的目的通常是重用组件之间的公共逻辑，并将逻辑层和表示层分开。随着钩子的引入，HOCs在很大程度上退居二线。尽管你很少看到它们，hoc仍然是相关的，并且比钩子有一定的优势，例如，与基于类的组件有更好的兼容性。</p><p id="c337" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一个众所周知的例子是来自<code class="fe md me mf mg b">react-router</code>库中的<a class="ae mc" href="https://reactrouter.com/web/api/withRouter" rel="noopener ugc nofollow" target="_blank"> withRouter </a>函数。</p><h1 id="e315" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">设置特设</h1><p id="503a" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">让我们先从搭建我们的HOC开始。我们将创建一个简单的特设，为我们的组件添加计时器功能。我们的第一次迭代不会有严格的类型，但是随着我们的进展，我们会把它收紧。</p><p id="9163" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是我们的高阶组件的第一个版本:</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mh"><img src="../Images/ecc3121ff656ef721e0269dac4a8e6ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8rSfizBagjThqED4EO2nCw.png"/></div></div></figure><p id="7ecd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">此时，我们的HOC不是很安全，因为我们为目标组件的类型设置了<code class="fe md me mf mg b">any</code>。没有类型检查来确保我们传递的组件接受我们试图注入的道具。</p><p id="5b88" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在让我们开始加强类型检查。</p><h1 id="9b31" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">添加泛型</h1><p id="0153" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">让我们这样做，使我们的HOC只接受React组件，并期望与目标组件相同的属性。我们可以使用TypeScript泛型来实施这些约束:</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mm"><img src="../Images/0678438b65cc81212b100d013224a80c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QmGYt1jfhinrWft3ZgjEWQ.png"/></div></div></figure><p id="4d3f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><a class="ae mc" href="https://flow.org/en/docs/react/types/#toc-react-componenttype" rel="noopener ugc nofollow" target="_blank"> ComponentType </a>是React提供的一种特殊类型，用于处理TypeScript中的组件。</p><p id="dc45" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">另外，请注意我们对泛型的使用。我们在几个地方使用了<code class="fe md me mf mg b">T</code>类型:</p><ul class=""><li id="21a1" class="mn mo it kd b ke kf ki kj km mp kq mq ku mr ky ms mt mu mv bi translated">我们将参数类型设置为<code class="fe md me mf mg b">ComponentType&lt;T&gt;</code>。现在，在这个函数的范围内，<code class="fe md me mf mg b">T</code>表示目标组件的道具类型。</li><li id="daed" class="mn mo it kd b ke mw ki mx km my kq mz ku na ky ms mt mu mv bi translated">我们还将<code class="fe md me mf mg b">hocProps</code>类型设置为<code class="fe md me mf mg b">T</code>，以强制我们的HOC组件接收与目标相同的道具。</li></ul><p id="176d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">多亏了泛型，TypeScript可以动态计算我们的原始组件接受的所有属性，并对HOC实施相同的限制。你可以从<a class="ae mc" href="https://www.typescriptlang.org/docs/handbook/2/generics.html" rel="noopener ugc nofollow" target="_blank">类型脚本文档</a>中了解更多关于泛型的知识。</p><h1 id="7be0" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">使用实用程序类型</h1><p id="1b34" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">到目前为止，我们的HOC中的类型检查看起来不错。下面是我们如何使用它:</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mm"><img src="../Images/9a4ecf4ea64f1baa294aacbc4c642ce1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JSDVVdtSyXCMweKjG_eUVA.png"/></div></div></figure><p id="59ec" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">但是我们还有一个问题需要解决。当您使用我们的HOC时，会从TypeScript中得到一个错误:</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nb"><img src="../Images/4ad43612e4cb7b93977576c7090bd4e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0o-pTvcnCjN3p63lrC1BtQ.png"/></div></div></figure><p id="a4a6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">早些时候，我说过特设应该期待与目标组件完全相同的道具<code class="fe md me mf mg b">T</code>，但这并不完全是真的。我们的HOC不应该期待道具<code class="fe md me mf mg b">counter</code>、<code class="fe md me mf mg b">startTimer</code>和<code class="fe md me mf mg b">endTimer</code>，因为首先注入这些道具是高阶组件的工作。</p><p id="317a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以通过使用<a class="ae mc" href="https://www.typescriptlang.org/docs/handbook/utility-types.html#omittype-keys" rel="noopener ugc nofollow" target="_blank">省略实用程序类型</a>来解决这个问题。使用Omit，我们可以告诉HOC期待我们的目标组件所期待的所有道具，除了它注入的那些:</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nd"><img src="../Images/170bd2ae2d0498a5185bb7a7eda2a25b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xe9j2s9hrT_Fu5pZVSAVZQ.png"/></div></div></figure><p id="c64d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们对代码又做了两处修改:</p><ul class=""><li id="4cf7" class="mn mo it kd b ke kf ki kj km mp kq mq ku mr ky ms mt mu mv bi translated">现在我们的HOC接受<code class="fe md me mf mg b">hocProps: Omit&lt;T, "count" | "startTimer" | "endTimer"&gt;</code>类型的道具。使用<code class="fe md me mf mg b">Omit</code>，我们创建了一个新的类型，期望除了<code class="fe md me mf mg b">count</code>、<code class="fe md me mf mg b">startTimer</code>和<code class="fe md me mf mg b">endTimer</code>之外的所有道具<code class="fe md me mf mg b">T</code>。</li><li id="9117" class="mn mo it kd b ke mw ki mx km my kq mz ku na ky ms mt mu mv bi translated">由于<code class="fe md me mf mg b">Omit</code>创建了一个新的类型，我们不得不使用一个变通方法<code class="fe md me mf mg b">{...(hocProps as T)}</code>让TypeScript知道我们期望<code class="fe md me mf mg b">hocProps</code>与<code class="fe md me mf mg b">T</code>几乎相同，除了我们省略的属性。</li></ul><p id="292e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在我们的高阶组件可以使用了！</p><h1 id="07a0" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">结论</h1><p id="6362" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">在这篇文章中，我们讨论了在TypeScript中编写高阶组件的正确方法。我们使用TypeScript的泛型和实用程序类型使我们的HOC既灵活又安全。看看我的帖子，了解更多对React 有用的其他<a class="ae mc" href="https://isamatov.com/typescript-utility-types-for-react/" rel="noopener ugc nofollow" target="_blank"> TypeScript实用工具类型。</a></p><p id="6351" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里是本教程的<a class="ae mc" href="https://codesandbox.io/s/hoc-with-typescript-vjrmh" rel="noopener ugc nofollow" target="_blank">代码沙箱</a>的链接。感谢您的阅读！</p></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><p id="ba08" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="nc">原载于2021年8月8日</em><a class="ae mc" href="https://isamatov.com/react-hoc-typescript/" rel="noopener ugc nofollow" target="_blank"><em class="nc">【https://isamatov.com】</em></a><em class="nc">。</em></p></div></div>    
</body>
</html>