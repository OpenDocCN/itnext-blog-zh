<html>
<head>
<title>A tagged template literals utility for ease of composing parameterized SQL queries</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一个带标记的模板文字实用程序，用于简化参数化SQL查询的编写</h1>
<blockquote>原文：<a href="https://itnext.io/a-tagged-template-literals-utility-for-ease-of-composing-parameterized-sql-queries-f507e159466e?source=collection_archive---------3-----------------------#2022-05-15">https://itnext.io/a-tagged-template-literals-utility-for-ease-of-composing-parameterized-sql-queries-f507e159466e?source=collection_archive---------3-----------------------#2022-05-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/8426c170356a53860f288ce0c1135168.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gzxp4GshSY51e0t9"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@casparrubin?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">卡斯帕·卡米尔·鲁宾</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="687c" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">模板文字</h1><p id="a9b8" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">从ES6 (JavaScript 2015)开始，“模板文字”功能可用，并提供了一种将变量和表达式插入字符串的简单方法。例如:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="c0ff" class="mi ke iq me b gy mj mk l ml mm">const firstName = "Joe";<br/>const lastName = "Bloggs";</span><span id="3db3" class="mi ke iq me b gy mn mk l ml mm">const message = `Welcome ${firstName}, ${lastName}!`;<br/>console.log(message);<br/>// will output: Welcome Joe, Bloggs!</span></pre><p id="be09" class="pw-post-body-paragraph lb lc iq ld b le mo lg lh li mp lk ll lm mq lo lp lq mr ls lt lu ms lw lx ly ij bi translated">当您必须手动编写SQL查询时，这种语法可能也很方便:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="c1c6" class="mi ke iq me b gy mj mk l ml mm">const sqlQuery = `SELECT * FROM users WHERE id='${userId}'`;</span></pre><p id="a17b" class="pw-post-body-paragraph lb lc iq ld b le mo lg lh li mp lk ll lm mq lo lp lq mr ls lt lu ms lw lx ly ij bi translated">但是，这种方法可能(并且经常)导致SQL注入漏洞，因为参数未经适当处理就直接嵌入到SQL字符串中。</p><h1 id="0c75" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">参数化SQL查询</h1><p id="6548" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">为了避免SQL注入漏洞，大多数数据库客户端库都支持“参数化SQL查询”。以“<a class="ae kc" href="https://node-postgres.com/features/queries" rel="noopener ugc nofollow" target="_blank"> node-postgres </a>为例，可以发送如下参数化的SQL查询:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="ac3d" class="mi ke iq me b gy mj mk l ml mm">client.query("SELECT * FROM users WHERE id = $1", [userId]);</span></pre><p id="c388" class="pw-post-body-paragraph lb lc iq ld b le mo lg lh li mp lk ll lm mq lo lp lq mr ls lt lu ms lw lx ly ij bi translated">对于上面的参数化SQL查询，参数替换不会发生在客户端。事实上，未更改的查询文本<code class="fe mt mu mv me b">SELECT * FROM users WHERE id = $1</code>将与参数值<code class="fe mt mu mv me b">userId</code>一起发送到PostgreSQL服务器。然后，该参数将被安全地替换到查询中，并在服务器端使用久经考验的参数替换代码。</p><p id="6174" class="pw-post-body-paragraph lb lc iq ld b le mo lg lh li mp lk ll lm mq lo lp lq mr ls lt lu ms lw lx ly ij bi translated">尽管有SQL注入漏洞防御的好处，但在您的代码中构建复杂的参数化SQL查询并保持正确的参数顺序可能很困难，尤其是在构建包含条件查询条件的查询时。这里有一个例子:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="289f" class="mi ke iq me b gy mj mk l ml mm">const parameters = [];<br/>const conditions = [];</span><span id="fe56" class="mi ke iq me b gy mn mk l ml mm">if (req.query["field1"]) {<br/>  conditions.push("field1 = $1");<br/>  parameters.push(req.query["field1"]);<br/>}<br/>if (req.query["field2"]) {<br/>  conditions.push("field2 = $2");<br/>  /* The query might break here. when `req.query["field1"]` doesn't have a value, this will be the first condition. Thus, thr query string should be "field2 = $1". */<br/>  parameters.push(req.query["field2"]);<br/>}</span><span id="4b7b" class="mi ke iq me b gy mn mk l ml mm">const where = conditions.length ? " WHERE " + conditions.join(" AND ") : "";</span><span id="1c65" class="mi ke iq me b gy mn mk l ml mm">client.query("SELECT * FROM users" + where, parameters);</span></pre><h1 id="34ad" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">标记的模板文字</h1><p id="3200" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">当仔细观察上面的问题时，我们会意识到该问题来自于连接查询片段的需要，同时用查询片段保持所涉及的参数的上下文信息。“带标签的模板文字”正是解决这个问题的合适工具。</p><p id="028e" class="pw-post-body-paragraph lb lc iq ld b le mo lg lh li mp lk ll lm mq lo lp lq mr ls lt lu ms lw lx ly ij bi translated">标记模板文本是模板文本的更高级形式。它允许你用一个函数来解析模板文字。该函数接收占位符值列表，并返回一个值作为字符串插值结果。字符串插值结果通常是字符串。但是该函数可以选择返回一个更高级的数据结构(例如一个对象),该数据结构携带查询文本字符串和相关参数。这允许我们在字符串插值/复杂查询构造期间，始终将查询文本字符串和相关参数作为一个整体来处理。</p><h1 id="1df0" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">SQLSyntax实用工具</h1><p id="446d" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">“<a class="ae kc" href="https://github.com/t83714/SQLSyntax" rel="noopener ugc nofollow" target="_blank"> SQLSyntax </a>”是一个nodejs库，它是基于上面类似的思想创建的。最初的想法实际上来自scala世界中流行的<a class="ae kc" href="http://scalikejdbc.org/" rel="noopener ugc nofollow" target="_blank"> ScalikeJDBC </a>库。“<a class="ae kc" href="https://github.com/t83714/SQLSyntax" rel="noopener ugc nofollow" target="_blank"> SQLSyntax </a>”库提供了一个<code class="fe mt mu mv me b">sqls</code>函数，该函数总是产生一个SQLSyntax类的实例作为字符串插值结果。通过利用es6的标记模板文字特性，用户可以享受模板文字语法的便利，同时确保所涉及的参数的上下文信息总是得到适当的维护，并与涉及参数的查询片段保持一致。</p><p id="c95b" class="pw-post-body-paragraph lb lc iq ld b le mo lg lh li mp lk ll lm mq lo lp lq mr ls lt lu ms lw lx ly ij bi translated">下面有一个简单的例子说明它的基本用法:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="adfc" class="mi ke iq me b gy mj mk l ml mm">import SQLSyntax, {sqls} from "sql-syntax";</span><span id="39b6" class="mi ke iq me b gy mn mk l ml mm">// the return value is an instance of SQLSyntax class<br/>const query:SQLSyntax = sqls`SELECT * FROM users WHERE user_id = ${userId} AND number = ${number}`;</span><span id="0fed" class="mi ke iq me b gy mn mk l ml mm">// we can generate SQL query text string &amp; binding parameters array for querying database. <br/>const [sql, parameters] = query.toQuery();</span><span id="69cc" class="mi ke iq me b gy mn mk l ml mm">// sql: "SELECT * FROM users WHERE user_id = $1 AND number = $2"<br/>// parameters: [userId, number]<br/>const result = await client.query(sql, parameters);</span><span id="5b5e" class="mi ke iq me b gy mn mk l ml mm">// Or more concisely using spread syntax for function calls<br/>const result = await client.query(...query.toQuery());</span></pre><p id="886b" class="pw-post-body-paragraph lb lc iq ld b le mo lg lh li mp lk ll lm mq lo lp lq mr ls lt lu ms lw lx ly ij bi translated"><code class="fe mt mu mv me b">sqls</code>函数还可以识别任何作为字符串插值传递的SQLSyntax类实例值。当发生这种情况时，<code class="fe mt mu mv me b">sqls</code>函数将合并所有相关查询片段的SQL查询文本字符串(由SQLSyntax类实例值表示)，创建一个新的参数列表并返回一个新的SQLSyntax类实例。</p><p id="6cd2" class="pw-post-body-paragraph lb lc iq ld b le mo lg lh li mp lk ll lm mq lo lp lq mr ls lt lu ms lw lx ly ij bi translated">这里有一个例子:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="413a" class="mi ke iq me b gy mj mk l ml mm">import SQLSyntax, {sqls} from "sql-syntax";</span><span id="2a09" class="mi ke iq me b gy mn mk l ml mm">// create 2 query fragments that involve parameters<br/>const condition1:SQLSyntax = sqls`user_id = ${userId}`;<br/>const condition2:SQLSyntax = sqls`number = ${number}`;</span><span id="6a7f" class="mi ke iq me b gy mn mk l ml mm">const [sql1, parameters1] = condition1.toQuery();<br/>// sql1: "user_id = $1"<br/>// parameters1: [userId]</span><span id="963d" class="mi ke iq me b gy mn mk l ml mm">// Create the final query by passing the query fragments<br/>const query:SQLSyntax = sqls`SELECT * FROM users <br/>WHERE ${sqls`field1=${field1Val}`} AND ${condition1} AND ${condition2}`;</span><span id="c7d1" class="mi ke iq me b gy mn mk l ml mm">const [sql, parameters] = query.toQuery();<br/>// sql: "SELECT * FROM users WHERE field1=$1 AND user_id=$2 AND number=$3"<br/>// parameters1: [field1Val, userId, number]</span><span id="f375" class="mi ke iq me b gy mn mk l ml mm">// execute the query<br/>const result = await client.query(...query.toQuery());</span></pre><h1 id="9d8e" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">对其他数据库的支持</h1><p id="5e86" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated"><code class="fe mt mu mv me b">SQLSyntax</code>对象的默认<code class="fe mt mu mv me b">toQuery</code>方法将生成针对postgreSQL的SQL文本字符串。如果它对您不起作用，您可以用自己的实现替换该逻辑:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="8b00" class="mi ke iq me b gy mj mk l ml mm">import SQLSyntax from "sql-syntax";</span><span id="3357" class="mi ke iq me b gy mn mk l ml mm">SQLSyntax.customToQueryFunc = (s:SQLSyntax) =&gt; {<br/>    //you own implementation...<br/>}</span></pre><h1 id="3ffd" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">尝试一下</h1><p id="9ca3" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">为了进行试验，您可以通过以下方式使用yarn或npm安装该库:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="c73b" class="mi ke iq me b gy mj mk l ml mm">// if you use npm <br/>npm install sql-syntax</span><span id="a44c" class="mi ke iq me b gy mn mk l ml mm">// if you use yarn<br/>yarn add sql-syntax</span></pre><p id="3f9b" class="pw-post-body-paragraph lb lc iq ld b le mo lg lh li mp lk ll lm mq lo lp lq mr ls lt lu ms lw lx ly ij bi translated">也可以访问其github repo:<a class="ae kc" href="https://github.com/t83714/SQLSyntax" rel="noopener ugc nofollow" target="_blank">https://github.com/t83714/SQLSyntax</a>或<a class="ae kc" href="https://t83714.github.io/SQLSyntax/classes/SQLSyntax.html" rel="noopener ugc nofollow" target="_blank"> API文档</a>了解更多信息。</p></div></div>    
</body>
</html>