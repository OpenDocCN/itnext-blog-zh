<html>
<head>
<title>Tutorial: Basics of Kubernetes Volumes (Part 1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">教程:Kubernetes卷的基础(第1部分)</h1>
<blockquote>原文：<a href="https://itnext.io/learn-about-the-basics-of-kubernetes-persistence-part-1-b1fa2847768f?source=collection_archive---------0-----------------------#2019-09-24">https://itnext.io/learn-about-the-basics-of-kubernetes-persistence-part-1-b1fa2847768f?source=collection_archive---------0-----------------------#2019-09-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="56a0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们继续我们的“果壳中的库伯内特”之旅，这一部分将涵盖库伯内特卷！</p><div class="kl km gp gr kn ko"><a href="https://medium.com/@abhishek1987/kubernetes-in-a-nutshell-blog-series-c3a97fce9445" rel="noopener follow" target="_blank"><div class="kp ab fo"><div class="kq ab kr cl cj ks"><h2 class="bd ir gy z fp kt fr fs ku fu fw ip bi translated">“果壳中的库伯内特”——博客系列</h2><div class="kv l"><h3 class="bd b gy z fp kt fr fs ku fu fw dk translated">本系列将涵盖Kubernetes的“广度”和核心/基础主题(见下一节)。它会…</h3></div><div class="kw l"><p class="bd b dl z fp kt fr fs ku fu fw dk translated">medium.com</p></div></div></div></a></div><p id="4d2b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您将了解到:</p><ul class=""><li id="7e17" class="kx ky iq jp b jq jr ju jv jy kz kc la kg lb kk lc ld le lf bi translated">概述<code class="fe lg lh li lj b">Volume</code>以及为什么需要它们</li><li id="6ab3" class="kx ky iq jp b jq lk ju ll jy lm kc ln kg lo kk lc ld le lf bi translated">如何使用<code class="fe lg lh li lj b">Volume</code></li><li id="16d7" class="kx ky iq jp b jq lk ju ll jy lm kc ln kg lo kk lc ld le lf bi translated">帮助探索<code class="fe lg lh li lj b">Volume</code>的实用实例</li></ul><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div class="gh gi lp"><img src="../Images/9cd931e2b34723530f2732b9162fdeab.png" data-original-src="https://miro.medium.com/v2/resize:fit:256/format:webp/1*1Cc99RF4vtCSKaHDgz_iyQ.png"/></div></figure><p id="c8bb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">代码可从GitHub 上的<a class="ae lx" href="https://github.com/abhirockzz/kubernetes-in-a-nutshell/blob/master/volumes-1" rel="noopener ugc nofollow" target="_blank">获得</a></p><blockquote class="ly lz ma"><p id="a410" class="jn jo mb jp b jq jr js jt ju jv jw jx mc jz ka kb md kd ke kf me kh ki kj kk ij bi translated"><em class="iq">很高兴通过</em><a class="ae lx" href="https://twitter.com/abhi_tweeter" rel="noopener ugc nofollow" target="_blank"><em class="iq">Twitter</em></a><em class="iq">获得您的反馈，或者发表评论！</em></p></blockquote><h1 id="8c09" class="mf mg iq bd mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc bi translated">先决条件:</h1><p id="6280" class="pw-post-body-paragraph jn jo iq jp b jq nd js jt ju ne jw jx jy nf ka kb kc ng ke kf kg nh ki kj kk ij bi translated">你将需要<code class="fe lg lh li lj b">minikube</code>和<code class="fe lg lh li lj b">kubectl</code>。</p><p id="e129" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将<code class="fe lg lh li lj b"><a class="ae lx" href="https://kubernetes.io/docs/tasks/tools/install-minikube/" rel="noopener ugc nofollow" target="_blank">minikube</a></code>作为单节点Kubernetes集群安装在您计算机上的虚拟机中。在Mac上，您可以简单地:</p><pre class="lq lr ls lt gt ni lj nj nk aw nl bi"><span id="33fb" class="nm mg iq lj b gy nn no l np nq">curl -Lo minikube https://storage.googleapis.com/minikube/releases/latest/minikube-darwin-amd64 &amp;&amp; chmod +x minikube</span><span id="7df3" class="nm mg iq lj b gy nr no l np nq">sudo mv minikube /usr/local/bin</span></pre><p id="714e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">安装<code class="fe lg lh li lj b"><a class="ae lx" href="https://kubernetes.io/docs/tasks/tools/install-kubectl/" rel="noopener ugc nofollow" target="_blank">kubectl</a></code>与你的AKS集群交互。在Mac上，您可以简单地:</p><pre class="lq lr ls lt gt ni lj nj nk aw nl bi"><span id="e3a2" class="nm mg iq lj b gy nn no l np nq">curl -LO https://storage.googleapis.com/kubernetes-release/release/$(curl -s <a class="ae lx" href="https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/darwin/amd64/kubectl" rel="noopener ugc nofollow" target="_blank">https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/darwin/amd64/kubectl</a></span><span id="fdd5" class="nm mg iq lj b gy nr no l np nq">chmod +x ./kubectl</span><span id="f8e3" class="nm mg iq lj b gy nr no l np nq">sudo mv ./kubectl /usr/local/bin/kubectl</span></pre><h1 id="2205" class="mf mg iq bd mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc bi translated">概观</h1><p id="ab87" class="pw-post-body-paragraph jn jo iq jp b jq nd js jt ju ne jw jx jy nf ka kb kc ng ke kf kg nh ki kj kk ij bi translated">存储在Docker容器中的数据是短暂的，也就是说，它只在容器存活之前存在。Kubernetes可以重启一个失败或崩溃的容器(在同一个<code class="fe lg lh li lj b">Pod</code>中)，但是你最终仍然会丢失你可能已经存储在容器文件系统中的任何数据。Kubernetes在<code class="fe lg lh li lj b">Volume</code> s的帮助下解决了这个问题，它支持多种类型的<code class="fe lg lh li lj b">Volume</code> s，包括外部云存储(例如<a class="ae lx" href="https://azure.microsoft.com/services/storage/disks/?WT.mc_id=mediumblog-abhishgu" rel="noopener ugc nofollow" target="_blank"> Azure Disk </a>，Amazon EBS，GCE持久盘等。)、网络文件系统，如Ceph、GlusterFS等。以及其他选项，如<code class="fe lg lh li lj b">emptyDir</code>、<code class="fe lg lh li lj b">hostPath</code>、<code class="fe lg lh li lj b">local</code>、<code class="fe lg lh li lj b">downwardAPI</code>、<code class="fe lg lh li lj b">secret</code>、<code class="fe lg lh li lj b">config</code>等。</p><h1 id="4bed" class="mf mg iq bd mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc bi translated">如何使用卷？</h1><p id="8d56" class="pw-post-body-paragraph jn jo iq jp b jq nd js jt ju ne jw jx jy nf ka kb kc ng ke kf kg nh ki kj kk ij bi translated">使用<code class="fe lg lh li lj b">Volume</code>相对简单——看看这个部分<code class="fe lg lh li lj b">Pod</code>规范作为例子</p><pre class="lq lr ls lt gt ni lj nj nk aw nl bi"><span id="4285" class="nm mg iq lj b gy nn no l np nq">spec:<br/>  containers:<br/>  - name: kvstore<br/>    image: abhirockzz/kvstore:latest<br/>    volumeMounts:<br/>    - mountPath: /data<br/>      name: data-volume<br/>    ports:<br/>    - containerPort: 8080<br/>  volumes:<br/>    - name: data-volume<br/>      emptyDir: {}</span></pre><p id="c324" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意以下事项:</p><ul class=""><li id="1cb4" class="kx ky iq jp b jq jr ju jv jy kz kc la kg lb kk lc ld le lf bi translated"><code class="fe lg lh li lj b">spec.volumes</code> -声明可用卷、其<code class="fe lg lh li lj b">name</code>(例如<code class="fe lg lh li lj b">data-volume</code>)和其他(卷)特定特征，例如在这种情况下，其指向Azure磁盘</li><li id="52c2" class="kx ky iq jp b jq lk ju ll jy lm kc ln kg lo kk lc ld le lf bi translated"><code class="fe lg lh li lj b">spec.containers.volumeMounts</code> -它指向在<code class="fe lg lh li lj b">spec.volumes</code>(例如<code class="fe lg lh li lj b">data-volume</code>)中声明的卷，并确切地指定它想要在容器文件系统中的什么位置挂载该卷(例如<code class="fe lg lh li lj b">/data</code>)。</li></ul><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="nt nu di nv bf nw"><div class="gh gi ns"><img src="../Images/bd4fc60cb9e2d515d3539a67b98a81f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Tjw9DmommJvF90Wz.jpg"/></div></div></figure><p id="aaf3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一个<code class="fe lg lh li lj b">Pod</code>可以有多个<code class="fe lg lh li lj b">Volume</code>在<code class="fe lg lh li lj b">spec.volumes</code>中声明。这些<code class="fe lg lh li lj b">Volume</code>中的每一个都可以被<code class="fe lg lh li lj b">Pod</code>中的所有容器访问，但是并不是所有容器都必须挂载或使用所有的卷。如果需要，<code class="fe lg lh li lj b">Pod</code>中的容器可以将多个卷挂载到其文件系统的不同路径中。此外，不同的容器可能同时装载一个卷。</p><h1 id="d97d" class="mf mg iq bd mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc bi translated">对卷进行分类的另一种方式</h1><p id="e876" class="pw-post-body-paragraph jn jo iq jp b jq nd js jt ju ne jw jx jy nf ka kb kc ng ke kf kg nh ki kj kk ij bi translated">我喜欢把它们分为:</p><ul class=""><li id="da80" class="kx ky iq jp b jq jr ju jv jy kz kc la kg lb kk lc ld le lf bi translated"><strong class="jp ir">短暂的</strong> — <code class="fe lg lh li lj b">Volume</code>与<code class="fe lg lh li lj b">Pod</code>生存期紧密相关(如<code class="fe lg lh li lj b">emptyDir</code>卷)，即如果<code class="fe lg lh li lj b">Pod</code>被移除(出于任何原因)，它们将被删除。</li><li id="8071" class="kx ky iq jp b jq lk ju ll jy lm kc ln kg lo kk lc ld le lf bi translated"><strong class="jp ir">持久性</strong> — <code class="fe lg lh li lj b">Volume</code>用于长期存储，独立于<code class="fe lg lh li lj b">Pod</code>或<code class="fe lg lh li lj b">Node</code>生命周期。在托管Kubernetes产品的情况下，这可能是<code class="fe lg lh li lj b">NFS</code>或基于云的存储，如Azure Kubernetes服务、Google Kubernetes引擎等。</li></ul><p id="ddfc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们以<code class="fe lg lh li lj b">emptyDir</code>为例</p><h1 id="181b" class="mf mg iq bd mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc bi translated">运行中的emptyDir卷</h1><p id="e936" class="pw-post-body-paragraph jn jo iq jp b jq nd js jt ju ne jw jx jy nf ka kb kc ng ke kf kg nh ki kj kk ij bi translated">一个<code class="fe lg lh li lj b">emptyDir</code>卷开始是空的(因此得名！)并且本质上是短暂的，即只在<code class="fe lg lh li lj b">Pod</code>活着的时候存在。一旦<code class="fe lg lh li lj b">Pod</code>被删除，那么<code class="fe lg lh li lj b">emptyDir</code>数据也被删除。这在一些场景/需求中是非常有用的，比如临时缓存，一个<code class="fe lg lh li lj b">Pod</code>中多个容器的共享存储等等。</p><p id="abdd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了运行这个例子，我们将使用一个简单的、过于简化的键值存储，它为</p><ul class=""><li id="fe09" class="kx ky iq jp b jq jr ju jv jy kz kc la kg lb kk lc ld le lf bi translated">添加键值对</li><li id="98c4" class="kx ky iq jp b jq lk ju ll jy lm kc ln kg lo kk lc ld le lf bi translated">读取键的值</li></ul><blockquote class="ly lz ma"><p id="ccaa" class="jn jo mb jp b jq jr js jt ju jv jw jx mc jz ka kb md kd ke kf me kh ki kj kk ij bi translated"><a class="ae lx" href="https://github.com/abhirockzz/kubernetes-in-a-nutshell/blob/master/volumes-1/main.go" rel="noopener ugc nofollow" target="_blank"> <em class="iq">这里是代码</em> </a> <em class="iq">如果你感兴趣的话</em></p></blockquote><h1 id="f585" class="mf mg iq bd mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc bi translated">初始部署</h1><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/3d58aded8b035d37353112c1eda05bae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/0*cZO-rHPzmyy9vy0h.gif"/></div></figure><p id="0847" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果尚未运行，启动<code class="fe lg lh li lj b">minikube</code></p><pre class="lq lr ls lt gt ni lj nj nk aw nl bi"><span id="393d" class="nm mg iq lj b gy nn no l np nq">minikube start</span></pre><p id="2c25" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">部署<code class="fe lg lh li lj b">kvstore</code>应用程序。这将简单地创建一个带有一个应用实例(<code class="fe lg lh li lj b">Pod</code>)的<code class="fe lg lh li lj b">Deployment</code>和一个<code class="fe lg lh li lj b">NodePort</code>服务</p><pre class="lq lr ls lt gt ni lj nj nk aw nl bi"><span id="2088" class="nm mg iq lj b gy nn no l np nq">kubectl apply -f <a class="ae lx" href="https://raw.githubusercontent.com/abhirockzz/kubernetes-in-a-nutshell/master/volumes-1/kvstore.yaml" rel="noopener ugc nofollow" target="_blank">https://raw.githubusercontent.com/abhirockzz/kubernetes-in-a-nutshell/master/volumes-1/kvstore.yaml</a></span></pre><blockquote class="ly lz ma"><p id="8672" class="jn jo mb jp b jq jr js jt ju jv jw jx mc jz ka kb md kd ke kf me kh ki kj kk ij bi translated"><em class="iq">为了简单起见，YAML文件直接从</em><a class="ae lx" href="https://github.com/abhirockzz/kubernetes-in-a-nutshell" rel="noopener ugc nofollow" target="_blank"><em class="iq">GitHub repo</em></a><em class="iq">中引用，但是你也可以把文件下载到你的本地机器上，以同样的方式使用它。</em></p></blockquote><p id="062f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">确认它们已被创建</p><pre class="lq lr ls lt gt ni lj nj nk aw nl bi"><span id="d95d" class="nm mg iq lj b gy nn no l np nq">kubectl get deployments kvstore</span><span id="3283" class="nm mg iq lj b gy nr no l np nq">NAME      READY   UP-TO-DATE   AVAILABLE   AGE<br/>kvstore   1/1     1            1           28s</span><span id="5938" class="nm mg iq lj b gy nr no l np nq">kubectl get pods -l app=kvstore</span><span id="1feb" class="nm mg iq lj b gy nr no l np nq">NAME                       READY   STATUS    RESTARTS   AGE<br/>kvstore-6c94877886-gzq25   1/1     Running   0          40s</span></pre><blockquote class="ly lz ma"><p id="9f44" class="jn jo mb jp b jq jr js jt ju jv jw jx mc jz ka kb md kd ke kf me kh ki kj kk ij bi translated">如果你不知道什么是 <code class="fe lg lh li lj b"><em class="iq">NodePort</em></code> <em class="iq">服务，那也没关系——这将在后续的博客文章中介绍。暂时只理解为是一种访问我们app的方式(这里是REST端点)</em></p></blockquote><p id="c174" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">检查由<code class="fe lg lh li lj b">NodePort</code>服务生成的随机端口的值——您可能会看到与此类似的结果(使用不同的IP、端口)</p><pre class="lq lr ls lt gt ni lj nj nk aw nl bi"><span id="0a11" class="nm mg iq lj b gy nn no l np nq">kubectl get service kvstore-service</span><span id="2087" class="nm mg iq lj b gy nr no l np nq">NAME              TYPE       CLUSTER-IP      EXTERNAL-IP   PORT(S)          AGE<br/>kvstore-service   NodePort   10.106.144.48   &lt;none&gt;        8080:32598/TCP   5m</span></pre><p id="1dc5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">检查<code class="fe lg lh li lj b">PORT(S)</code>列以找出随机端口，例如，在这种情况下是<code class="fe lg lh li lj b">32598</code>(<code class="fe lg lh li lj b">8080</code>是我们的应用程序公开的容器内的内部端口——忽略它)</p><p id="d2e0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，您只需要使用<code class="fe lg lh li lj b">minikube ip</code>获得<code class="fe lg lh li lj b">minikube</code>节点的IP地址</p><blockquote class="ly lz ma"><p id="078d" class="jn jo mb jp b jq jr js jt ju jv jw jx mc jz ka kb md kd ke kf me kh ki kj kk ij bi translated">如果你使用的是VirtualBox虚拟机，这可能会返回类似 <code class="fe lg lh li lj b"><em class="iq">192.168.99.100</em></code> <em class="iq">的东西</em></p></blockquote><p id="539e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在随后的命令中，用minikube虚拟机IP替换<code class="fe lg lh li lj b">host</code>,用随机端口值替换<code class="fe lg lh li lj b">port</code></p><p id="62d5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">创建几个新的键值对条目</p><pre class="lq lr ls lt gt ni lj nj nk aw nl bi"><span id="058e" class="nm mg iq lj b gy nn no l np nq">curl http://[host]:[port]/save -d 'foo=bar'<br/>curl http://[host]:[port]/save -d 'mac=cheese'</span></pre><p id="a62e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如</p><pre class="lq lr ls lt gt ni lj nj nk aw nl bi"><span id="f522" class="nm mg iq lj b gy nn no l np nq">curl http://192.168.99.100:32598/save -d 'foo=bar'<br/>curl http://192.168.99.100:32598/save -d 'mac=cheese'</span></pre><p id="c19e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">访问键<code class="fe lg lh li lj b">foo</code>的值</p><pre class="lq lr ls lt gt ni lj nj nk aw nl bi"><span id="a43a" class="nm mg iq lj b gy nn no l np nq">curl <a class="ae lx" href="http://[host]:[port]/read/foo" rel="noopener ugc nofollow" target="_blank">http://[host]:[port]/read/foo</a></span></pre><p id="cd15" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您应该会得到您为<code class="fe lg lh li lj b">foo</code> - <code class="fe lg lh li lj b">bar</code>保存的值。这同样适用于<code class="fe lg lh li lj b">mac</code>，即你将得到<code class="fe lg lh li lj b">cheese</code>作为它的值。程序将键值数据保存在<code class="fe lg lh li lj b">/data</code>中——让我们通过直接查看<code class="fe lg lh li lj b">Pod</code>中的Docker容器来确认这一点</p><pre class="lq lr ls lt gt ni lj nj nk aw nl bi"><span id="5224" class="nm mg iq lj b gy nn no l np nq">kubectl exec &lt;pod name&gt; -- ls /data/</span><span id="3ee0" class="nm mg iq lj b gy nr no l np nq">foo<br/>mac</span></pre><p id="45cf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lg lh li lj b">foo</code>、<code class="fe lg lh li lj b">mac</code>是以按键命名的单个文件。如果我们进一步挖掘，我们也应该能够确认它们各自的值</p><p id="2dde" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">确认<code class="fe lg lh li lj b">mac</code>键的值</p><pre class="lq lr ls lt gt ni lj nj nk aw nl bi"><span id="bd02" class="nm mg iq lj b gy nn no l np nq">kubectl exec &lt;pod name&gt; -- cat /data/mac`</span><span id="035b" class="nm mg iq lj b gy nr no l np nq">cheese</span></pre><p id="2e3f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如所料，您得到了<code class="fe lg lh li lj b">cheese</code>作为答案，因为这是您之前存储的内容。如果你试图寻找一个你还没有存储的键，你会得到一个错误</p><pre class="lq lr ls lt gt ni lj nj nk aw nl bi"><span id="1d2a" class="nm mg iq lj b gy nn no l np nq">cat: can't open '/data/moo': No such file or directory<br/>command terminated with exit code 1</span></pre><h1 id="faf5" class="mf mg iq bd mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc bi translated">杀死容器；-)</h1><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/ac3cf6426c074b0b2b4f600277f81859.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/0*uB6wgzTAFAWa60t8.gif"/></div></figure><p id="5ce5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好的，目前为止一切顺利！使用一个<code class="fe lg lh li lj b">Volume</code>可以确保数据在容器重启/崩溃时得到保存。让我们“欺骗”一下，手动杀死Docker容器。</p><pre class="lq lr ls lt gt ni lj nj nk aw nl bi"><span id="d4e8" class="nm mg iq lj b gy nn no l np nq">kubectl exec [pod name] -- ps</span><span id="1d49" class="nm mg iq lj b gy nr no l np nq">PID   USER     TIME  COMMAND<br/>  1   root     0:00 /kvstore<br/>  31 root      0:00  ps</span></pre><blockquote class="ly lz ma"><p id="af8c" class="jn jo mb jp b jq jr js jt ju jv jw jx mc jz ka kb md kd ke kf me kh ki kj kk ij bi translated"><em class="iq">注意进程ID为</em> <code class="fe lg lh li lj b"><em class="iq">kvstore</em></code> <em class="iq">的应用程序(应该是</em> <code class="fe lg lh li lj b"><em class="iq">1</em></code> <em class="iq"> ) </em></p></blockquote><p id="f1bf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在不同的终端中，在pod上设置一个观察器</p><pre class="lq lr ls lt gt ni lj nj nk aw nl bi"><span id="26cd" class="nm mg iq lj b gy nn no l np nq">kubectl get pods -l app=kvstore --watch</span></pre><p id="3f55" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们杀死了我们的应用程序进程</p><pre class="lq lr ls lt gt ni lj nj nk aw nl bi"><span id="8cf2" class="nm mg iq lj b gy nn no l np nq">kubectl exec [pod name] -- kill 1</span></pre><p id="3d2e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你会注意到Pod会经历几个阶段(如<code class="fe lg lh li lj b">Error</code>等)。)然后返回到<code class="fe lg lh li lj b">Running</code>状态(由Kubernetes重新启动)。</p><pre class="lq lr ls lt gt ni lj nj nk aw nl bi"><span id="7c87" class="nm mg iq lj b gy nn no l np nq">NAME                       READY     STATUS    RESTARTS   AGE<br/>kvstore-6c94877886-gzq25   1/1       Running   0         15m<br/>kvstore-6c94877886-gzq25   0/1       Error     0         15m<br/>kvstore-6c94877886-gzq25   1/1       Running   1         15m</span></pre><p id="7670" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">执行<code class="fe lg lh li lj b">kubectl exec &lt;pod name&gt; -- ls /data</code>以确认尽管容器重启，数据实际上仍然存在。</p><h1 id="76ce" class="mf mg iq bd mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc bi translated">删除Pod！</h1><p id="ab31" class="pw-post-body-paragraph jn jo iq jp b jq nd js jt ju ne jw jx jy nf ka kb kc ng ke kf kg nh ki kj kk ij bi translated">但是数据不会在Pod的生命周期后继续存在。为了确认这一点，让我们手动删除<code class="fe lg lh li lj b">Pod</code></p><pre class="lq lr ls lt gt ni lj nj nk aw nl bi"><span id="cabe" class="nm mg iq lj b gy nn no l np nq">kubectl delete pod -l app=kvstore</span></pre><p id="c5b4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您应该会看到如下确认消息</p><pre class="lq lr ls lt gt ni lj nj nk aw nl bi"><span id="aa77" class="nm mg iq lj b gy nn no l np nq">pod "kvstore-6c94877886-gzq25" deleted</span></pre><p id="13fe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Kubernetes将再次重启<code class="fe lg lh li lj b">Pod</code>。几秒钟后，您可以确认同样的情况</p><pre class="lq lr ls lt gt ni lj nj nk aw nl bi"><span id="0a80" class="nm mg iq lj b gy nn no l np nq">kubectl get pods -l app=kvstore</span></pre><blockquote class="ly lz ma"><p id="ff29" class="jn jo mb jp b jq jr js jt ju jv jw jx mc jz ka kb md kd ke kf me kh ki kj kk ij bi translated"><em class="iq">你应该会在</em> <code class="fe lg lh li lj b"><em class="iq">Running</em></code> <em class="iq">状态下看到一个新的</em> <code class="fe lg lh li lj b"><em class="iq">Pod</em></code> <em class="iq"/></p></blockquote><p id="7911" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">获取pod名称并再次查看文件</p><pre class="lq lr ls lt gt ni lj nj nk aw nl bi"><span id="a955" class="nm mg iq lj b gy nn no l np nq">kubectl get pods -l app=kvstore<br/>kubectl exec [pod name] -- ls /data/store</span></pre><p id="abe2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不出所料，<code class="fe lg lh li lj b">/data/</code>目录将为空！</p><h1 id="3000" class="mf mg iq bd mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc bi translated">对持久存储的需求</h1><p id="6a32" class="pw-post-body-paragraph jn jo iq jp b jq nd js jt ju ne jw jx jy nf ka kb kc ng ke kf kg nh ki kj kk ij bi translated">简单的(短暂的)<code class="fe lg lh li lj b">Volume</code>与<code class="fe lg lh li lj b">Pod</code>同生共死——但是这对大多数应用程序来说是不够的。为了具有弹性、可靠性、可用性和可伸缩性，Kubernetes应用程序需要能够跨pod作为多个实例运行，这些pod本身可能被调度或放置在Kubernetes集群中的不同节点上。我们需要的是一个稳定的、持久的存储，比运行Pod的<code class="fe lg lh li lj b">Pod</code>甚至<code class="fe lg lh li lj b">Node</code>更持久。</p><p id="239c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如本博客开头所提到的，使用<code class="fe lg lh li lj b">Volume</code>很简单——不仅仅是像我们刚刚看到的那样的临时存储，甚至是长期的持久存储。</p><p id="944e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里有一个(虚构的)例子，说明如何使用<a class="ae lx" href="https://azure.microsoft.com/services/storage/disks/?WT.mc_id=devto-blog-abhishgu" rel="noopener ugc nofollow" target="_blank"> Azure Disk </a>作为部署到<a class="ae lx" href="https://azure.microsoft.com/services/kubernetes-service/?WT.mc_id=devto-blog-abhishgu" rel="noopener ugc nofollow" target="_blank"> Azure Kubernetes服务</a>的应用程序的存储介质。</p><pre class="lq lr ls lt gt ni lj nj nk aw nl bi"><span id="9441" class="nm mg iq lj b gy nn no l np nq">apiVersion: v1<br/>kind: Pod<br/>metadata:<br/>  name: testpod<br/>spec:<br/>  volumes:<br/>  - name: logs-volume<br/>    azureDisk:<br/>          kind: Managed<br/>          diskName: myAKSDiskName<br/>          diskURI: myAKSDiskURI<br/>  containers:<br/>  - image: myapp-docker-image<br/>    name: myapp<br/>    volumeMounts:<br/>    - mountPath: /app/logs<br/>      name: logs-volume</span></pre><p id="df6d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就这样吗？不完全是！😉这种方法有局限性。这一点以及更多内容将在本系列的下一部分讨论——敬请关注！</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/58dba47a9dc599d28d80457ece4a6bb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:500/0*slz7AJITiJR-kqDh.gif"/></div></figure><p id="4f6c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我真的希望你喜欢这篇文章，并从中学到了一些东西😃😃如果你做了，请喜欢并跟随！</p></div></div>    
</body>
</html>