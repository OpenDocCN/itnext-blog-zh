<html>
<head>
<title>knative Build Primitive</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">knative构建原语</h1>
<blockquote>原文：<a href="https://itnext.io/knative-build-primitive-32b69c3974a1?source=collection_archive---------2-----------------------#2018-07-24">https://itnext.io/knative-build-primitive-32b69c3974a1?source=collection_archive---------2-----------------------#2018-07-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/2dff32ad7354f6c36b3c2164cebb1db2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fWtVse6DItxvOBowU85Www.png"/></div></div></figure><p id="1904" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">今天<a class="ae kw" href="https://cloudplatform.googleblog.com/2018/07/bringing-the-best-of-serverless-to-you.html" rel="noopener ugc nofollow" target="_blank"> Google宣布了knative </a>一个新的开源项目，它定义了一组从源代码到Kubernetes操作的原语。</p><p id="1ac6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">knative是Kubernetes的扩展，或者我应该说是扩展(复数)，这意味着它使用Kubernetes自定义资源定义来定义一组新的API，使构建、部署、扩展和路由流量到应用程序变得更容易。</p><p id="33c7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">knative的目标肯定是无服务器领域，在接下来的几天/几个月里，你会读到很多关于这方面的内容。一个非常有趣的功能是，它可以根据访问您的微服务的请求数量，将您的副本缩小到0，或者从0扩大到0(目前通过Istio)。</p><p id="94e1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在接下来的几天里，我会写更多关于knative的细节，它是一个复杂的系统。但是现在:)knative带来的一个非常有趣的API是<code class="fe kx ky kz la b">Build</code> API对象。如果您需要将编译语言函数投入生产，构建是必要的，但是<code class="fe kx ky kz la b">Build</code>也可以用于定义您的CI管道。</p><p id="ef27" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我有机会预览它，所以让我分享一下<code class="fe kx ky kz la b">Build</code> API的要点。对于了解Kubernetes的人来说，这是一个带有自己控制器的CRD，您可以在集群中使用它:</p><pre class="lb lc ld le gt lf la lg lh aw li bi"><span id="ba41" class="lj lk iq la b gy ll lm l ln lo">kubectl create -f <a class="ae kw" href="https://storage.googleapis.com/knative-releases/build/latest/release.yaml" rel="noopener ugc nofollow" target="_blank">https://storage.googleapis.com/knative-releases/build/latest/release.yaml</a></span></pre><p id="0253" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">knative <code class="fe kx ky kz la b">Build</code>几乎是<a class="ae kw" href="https://cloud.google.com/container-builder/" rel="noopener ugc nofollow" target="_blank">谷歌容器构建器</a>的开源。它定义了一组作为Pod中的init-containers实现的<code class="fe kx ky kz la b">steps</code>。</p><h1 id="5ea7" class="lp lk iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">步伐</h1><p id="b588" class="pw-post-body-paragraph jy jz iq ka b kb mm kd ke kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv ij bi translated">这是一个执行<code class="fe kx ky kz la b">/bin/date</code>的玩具<code class="fe kx ky kz la b">Build</code>清单。</p><pre class="lb lc ld le gt lf la lg lh aw li bi"><span id="c230" class="lj lk iq la b gy ll lm l ln lo"><br/>apiVersion: build.knative.dev/v1alpha1<br/>kind: Build<br/>metadata:<br/> name: test<br/>spec:<br/> steps:<br/> — name: date<br/>   image: debian:stable-slim<br/>   args: [‘/bin/date’]<br/></span></pre><p id="059d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它有一个基于<code class="fe kx ky kz la b">debian:stable-slim</code> Docker映像的单个<code class="fe kx ky kz la b">step</code>，并运行<code class="fe kx ky kz la b">/bin/date</code>。</p><p id="95fd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在一个构建中，每个步骤共享一个<code class="fe kx ky kz la b">/workspace</code>目录，并且每个步骤都在Docker容器中执行，正如前面提到的,<code class="fe kx ky kz la b">step</code>是一个Kubernetes<a class="ae kw" href="https://kubernetes.io/docs/concepts/workloads/pods/init-containers/" rel="noopener ugc nofollow" target="_blank">init-container</a>。当您创建这个对象时，knative build controller将创建一个带有适当的init-containers和volumes设置的Pod。</p><h1 id="2c6d" class="lp lk iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">来源</h1><p id="df0b" class="pw-post-body-paragraph jy jz iq ka b kb mm kd ke kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv ij bi translated">但是构建需要源代码，所以一个<code class="fe kx ky kz la b">Build</code>对象也定义了一个<code class="fe kx ky kz la b">source</code>。通常，您可以克隆一个存储库，然后对其执行步骤，如下所示:</p><pre class="lb lc ld le gt lf la lg lh aw li bi"><span id="8f4f" class="lj lk iq la b gy ll lm l ln lo"><br/>apiVersion: build.knative.dev/v1alpha1<br/>kind: Build<br/>metadata:<br/> name: test<br/>spec:<br/> source:<br/>   git:<br/>     url: <a class="ae kw" href="https://github.com/sebgoa/functions.git" rel="noopener ugc nofollow" target="_blank">https://github.com/sebgoa/functions.git</a><br/>     revision: master<br/> steps:<br/> — name: ls<br/>   image: busybox<br/>   args: [‘ls’]<br/></span></pre><p id="1355" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">到目前为止，构建是基于源代码和一组最有可能在源代码上执行操作的步骤。</p><h1 id="4592" class="lp lk iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">模板</h1><p id="af9d" class="pw-post-body-paragraph jy jz iq ka b kb mm kd ke kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv ij bi translated">为了简化构建清单，您可以将<a class="ae kw" href="https://github.com/knative/build-templates" rel="noopener ugc nofollow" target="_blank">模板</a>定义为另一个API对象。我邀请你去看看模板库，因为这是了解<code class="fe kx ky kz la b">Build</code>对象的好方法。例如，要在Kubernetes中构建Docker图像并推送结果图像，可以使用<a class="ae kw" href="https://github.com/GoogleContainerTools/kaniko" rel="noopener ugc nofollow" target="_blank"> Kaniko </a>。我向你展示了如何用一个标准的Kubernetes工作来做这件事。它的主要好处是你可以在一个非特权容器中进行Docker构建。</p><p id="a1ab" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">以下是使用Kaniko构建和推送Docker映像的基本模板:</p><pre class="lb lc ld le gt lf la lg lh aw li bi"><span id="d27d" class="lj lk iq la b gy ll lm l ln lo"><br/>apiVersion: build.knative.dev/v1alpha1<br/>kind: BuildTemplate<br/>metadata:<br/> name: kaniko<br/>spec:<br/> parameters:<br/> — name: IMAGE<br/>   description: The name of the image to push<br/> — name: DOCKERFILE<br/>   description: Path to the Dockerfile to build.<br/>   default: /workspace/Dockerfile<br/> steps:<br/> — name: build-and-push<br/>   image: gcr.io/kaniko-project/executor<br/>   args:<br/>   - --dockerfile=${DOCKERFILE}<br/>   — --destination=${IMAGE}<br/>   — name: fail<br/>     image: busybox<br/>     args: [‘foo’]<br/></span></pre><p id="fe94" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意，我保留了一个<code class="fe kx ky kz la b">fail</code>步骤用于调试，否则我们看不到构建步骤的日志(新的零日软件FWIW:)。</p><p id="a661" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">定义了模板后，您的<code class="fe kx ky kz la b">Build</code>变得更加简单:</p><pre class="lb lc ld le gt lf la lg lh aw li bi"><span id="a711" class="lj lk iq la b gy ll lm l ln lo"><br/>apiVersion: build.knative.dev/v1alpha1<br/>kind: Build<br/>metadata:<br/> name: kaniko-test<br/>spec:<br/> serviceAccountName: build<br/> source:<br/>   git:<br/>     url: <a class="ae kw" href="https://github.com/sebgoa/functions.git" rel="noopener ugc nofollow" target="_blank">https://github.com/sebgoa/functions.git</a><br/>     revision: master<br/> template:<br/>   name: kaniko<br/> arguments:<br/> — name: IMAGE<br/>   value: docker.io/runseb/bazbaz<br/></span></pre><p id="9916" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">需要使用<code class="fe kx ky kz la b">serviceAccountName</code>才能正确推送至您的Docker hub repo。详细文档见<a class="ae kw" href="https://github.com/knative/build-templates/tree/master/kaniko" rel="noopener ugc nofollow" target="_blank"><em class="mr">https://github . com/kna tive/build-templates/tree/master/kaniko</em></a>。</p><h1 id="1c4d" class="lp lk iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">与Google容器构建器的连接</h1><p id="5ca2" class="pw-post-body-paragraph jy jz iq ka b kb mm kd ke kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv ij bi translated">如果你一直在用GCB的话，和GCB的联系就相当清楚了。实际上是很棒的服务。一个<code class="fe kx ky kz la b">Build</code>对象的模式基本上就是你的<code class="fe kx ky kz la b">cloudbuild.yaml</code>文件。</p><p id="5ec2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，要构建一个Go应用程序，您可以在源代码的根目录中放置以下<code class="fe kx ky kz la b">cloudbuild.yaml</code>:</p><pre class="lb lc ld le gt lf la lg lh aw li bi"><span id="9c90" class="lj lk iq la b gy ll lm l ln lo"><br/>steps:<br/>- name: ‘gcr.io/cloud-builders/go’<br/>  args: [‘install’, ‘.’]<br/>  env: [‘PROJECT_ROOT=hello’]<br/>- name: ‘gcr.io/cloud-builders/go’<br/>  args: [‘build’, ‘hello’]<br/>  env: [‘PROJECT_ROOT=hello’]<br/></span></pre><p id="9ef7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你现在可以在Kubernetes中使用Knative构建来做一些事情。耶！！！！</p><h1 id="2f96" class="lp lk iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">结论</h1><p id="fdf7" class="pw-post-body-paragraph jy jz iq ka b kb mm kd ke kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv ij bi translated">当然，GCB不仅仅是新的knative <code class="fe kx ky kz la b">Build</code>,但是knative的开源让我们非常接近它，并给了我们一个工具来构建CI管道，并更快地将我们的代码投入生产。</p><p id="b836" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Knative不仅仅是<code class="fe kx ky kz la b">Build</code>，我将在接下来的几周内谈论其他部分。我并没有故意谈论无服务器组件，但是你可以想象如何使用它来打包所有的函数依赖和处理编译语言函数。</p></div></div>    
</body>
</html>