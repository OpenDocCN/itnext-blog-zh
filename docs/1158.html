<html>
<head>
<title>Understand Async Iterators Without Really Trying</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">不用真正尝试就能理解异步迭代器</h1>
<blockquote>原文：<a href="https://itnext.io/understand-async-iterators-665259680044?source=collection_archive---------3-----------------------#2018-08-01">https://itnext.io/understand-async-iterators-665259680044?source=collection_archive---------3-----------------------#2018-08-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/3e5f51223477076999f308918b505bcc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ePBvJ78g2a614Rpe0qoGgg.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">保罗·坎德罗拍摄的照片</figcaption></figure><p id="6325" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">没人喜欢回调。这就像是现代版的<code class="fe lb lc ld le b">GOTO</code>声明。但是我们怎样才能取代那些讨厌的东西，比如点击处理程序呢？很有可能，您已经将所有简单的语句都重构到async/await语句中，但是仍然存在那些讨厌的顽固分子，比如DOM事件、WebSockets、事件发射器和任何其他类似流的对象。当然，我们可以把这些变成可观的，但是把1次回调变成3次回调似乎并没有太大的改善。如果我可以承诺一个函数，为什么我不能迭代一个事件流？答案是新的2018 async iterables，自从几年前首次提出以来，已经有很多旧的、令人困惑的、完全错误的信息存在。所以，通过反复试验的魔力，我写了一个助手来把点击处理程序变成for循环。</p><h1 id="c7cc" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">开始简单</h1><p id="f71b" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">在编程中，就像在生活中一样，懒惰通常更好。所以，当我构建新的东西时，我喜欢尽可能地懒惰，延迟编写让我思考的代码。所以，让我们写下我们想要的样子&amp;把所有难写的东西放进一个黑盒子里:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="ba57" class="mq lg iq le b gy mr ms l mt mu"><em class="mv">// I want to go from this<br/></em>document.addEventListener('click', (event) =&gt; console.log('click')<br/><br/><em class="mv">// to this<br/>const </em>clicks = <strong class="le ir">streamify</strong>(document, 'click')<br/><em class="mv">for await </em>(<em class="mv">const </em>event <em class="mv">of </em>clicks) {<br/>  console.log('click')<br/>}</span></pre><p id="d1a3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">到目前为止一切顺利！现在我们只需要那个神奇的<code class="fe lb lc ld le b">streamify</code>函数来实际做一些事情。我们知道它将调用<code class="fe lb lc ld le b">addEventListener</code>，它需要一个<code class="fe lb lc ld le b">handler</code>来获得<code class="fe lb lc ld le b">event</code>。因此，让我们只填写简单的部分，将困难的部分放在另一个黑盒中:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="fdaf" class="mq lg iq le b gy mr ms l mt mu"><em class="mv">function</em> streamify(element, listener) {<br/>  <em class="mv">const </em>handler = (event) =&gt; {<strong class="le ir"><br/>    // do magic here<br/>  </strong>}<strong class="le ir"> </strong><br/>  element.addEventListener(listener, handler)<br/>}</span></pre><p id="fd22" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">进步！现在避开困难的事情，让我们想想如何返回一个“异步迭代器”。老实说，我真的不知道那看起来像什么，我不能只写<code class="fe lb lc ld le b">new AsyncIterator()</code>，但我知道<code class="fe lb lc ld le b">async</code>意味着<code class="fe lb lc ld le b">promise</code>，迭代器是返回多于1个值的东西，有点像生成器，所以让我们滚动它，返回无限的承诺。无用的函数是我的专长，所以很简单:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="fa6e" class="mq lg iq le b gy mr ms l mt mu"><strong class="le ir"><em class="mv">function</em>*</strong> streamify(element, listener) {<br/>  <em class="mv">const </em>handler = (event) =&gt; {}<br/>  element.addEventListener(listener, handler)<br/>  <strong class="le ir"><em class="mv">while </em>(<em class="mv">true</em>) {<br/>    <em class="mv">yield new </em>Promise(resolve =&gt; resolve(event))<br/>  }</strong><br/>}</span></pre><p id="6aef" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们在有土豆的地方锄地！看起来<code class="fe lb lc ld le b">handler</code>正在得到一个<code class="fe lb lc ld le b">event</code>，而<code class="fe lb lc ld le b">Promise</code>正在产生一个<code class="fe lb lc ld le b">event</code>，所以现在我必须以某种方式将<code class="fe lb lc ld le b">event</code>从<code class="fe lb lc ld le b">handler</code>移动到<code class="fe lb lc ld le b">Promise</code>。我能想到的最愚蠢的事情就是共享一个变量，所以让我们这样做:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="c816" class="mq lg iq le b gy mr ms l mt mu"><em class="mv">function</em>* streamify(element, event) {<br/><strong class="le ir">  <em class="mv">let </em>nextResolve<br/></strong>  <em class="mv">const </em>handler = (event) =&gt; {<br/><strong class="le ir">    nextResolve(event)<br/></strong>  }<br/>  element.addEventListener(event, handler)<br/>  <em class="mv">while </em>(<em class="mv">true</em>) {<br/>    <em class="mv">yield new </em>Promise(resolve =&gt; {<br/><strong class="le ir">      nextResolve = resolve<br/></strong>    })<br/>  }<br/>}</span></pre><p id="6729" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们做到了！我们有一个正常工作的整流器！当一个点击事件进来时，它用我们给它的承诺来解决。相当甜蜜！…直到有人点击<em class="mv">真的</em>快。</p><h1 id="e1c8" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">加强水流调节器</h1><p id="b143" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">天真的解决方案只适用于缓慢的事件。如果两个事件被快速连续触发，第二个调用将被吞掉。我们不希望这样，尤其是如果我们将它用于websockets之类的东西。所以，管它呢，如果1个共享解析器是好的，那么一系列共享解析器肯定会更好！让我们按事件的顺序排列它们:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="1289" class="mq lg iq le b gy mr ms l mt mu"><em class="mv">function</em>* streamify(element, event) {<br/><strong class="le ir">  <em class="mv">const </em>pushQueue = []<br/></strong>  <em class="mv">const </em>handler = (event) =&gt; {<br/><strong class="le ir">    pushQueue.push(event)<br/></strong>  }<br/>  element.addEventListener(event, handler)<br/>  <em class="mv">while </em>(<em class="mv">true</em>) {<br/>    <em class="mv">yield new </em>Promise(resolve =&gt; {<br/><strong class="le ir">      <em class="mv">const </em>nextEvent = pushQueue.shift()<br/></strong>      resolve(nextEvent) // error! no nextEvent<br/>    })<br/>  }<br/>}</span></pre><p id="d424" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不，这解决了推送问题，但是现在我们得到了一个错误，因为迭代器在一个点击事件存在之前请求了一个点击事件。该死。好吧，队列用于推送事件，为什么不用一个队列来拉取解析器呢？</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="9d33" class="mq lg iq le b gy mr ms l mt mu"><em class="mv">function</em>* streamify(element, event) {<br/>  <em class="mv">const </em>pushQueue = []<br/><strong class="le ir">  <em class="mv">const </em>pullQueue = []<br/></strong>  <em class="mv">const </em>handler = (event) =&gt; {<br/>    <em class="mv">const </em>nextResolve = pullQueue.shift()<br/>    <em class="mv">if </em>(nextResolve) {<br/>      nextResolve(event)<br/>    } <em class="mv">else </em>{<br/>      pushQueue.push(event)<br/>    }<br/><br/>  }<br/>  element.addEventListener(event, handler)</span><span id="9f96" class="mq lg iq le b gy mw ms l mt mu">  <strong class="le ir"><em class="mv">const </em>pullValue = () =&gt; <em class="mv">new </em>Promise(resolve =&gt; {<br/>    <em class="mv">const </em>nextEvent = pushQueue.shift()<br/>    <em class="mv">if </em>(nextEvent) {<br/>      resolve(nextEvent)<br/>    } <em class="mv">else </em>{<br/>      pullQueue.push(resolve)<br/>    }<br/>  })</strong><br/>  <em class="mv">while </em>(<em class="mv">true</em>) {<br/><strong class="le ir">    <em class="mv">yield </em>pullValue()<br/></strong>  }<br/>}</span></pre><p id="c810" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">呜！有用！现在我可以永远随心所欲地点击了！…但是如果我只想听第一对夫妇呢？本来，我会调用<code class="fe lb lc ld le b">removeEventListener</code>，但是处理函数隐藏在我们可爱的新包装器中。当流结束时，我如何删除它？好吧，我从简单的&amp;开始，只要写出我想要的样子:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="39cb" class="mq lg iq le b gy mr ms l mt mu"><em class="mv">// from this<br/>let </em>clickCount = 0<br/><em class="mv">if </em>(clickCount++ &gt; 2) {<br/><strong class="le ir">  document.removeEventListener('click', handler)<br/></strong>  console.log('Bye!')  <br/>}<br/><br/><br/><em class="mv">// to this<br/>let </em>clickCount = 0<br/><em class="mv">for await </em>(<em class="mv">const </em>event <em class="mv">of </em>clicks) {<br/>  console.log('click', event)<br/>  <em class="mv">if </em>(clickCount++ &gt; 2)<strong class="le ir"> clicks.return() </strong>// this breaks the loop<br/>}<br/>console.log('Bye!')</span></pre><p id="c46f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我知道生成器值有那个神奇的<code class="fe lb lc ld le b">return()</code>方法，但是我希望我可以自己写，这样我也可以调用<code class="fe lb lc ld le b">removeEventListener</code>。我知道那个小<code class="fe lb lc ld le b">*</code>其实并不神奇；它只是告诉函数用4个方法将返回值包装在一个特殊的对象中。因此，让我们抛弃星号&amp;来编写引擎实际读取的生成器(加上添加我们的小额外处理程序):</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="a27e" class="mq lg iq le b gy mr ms l mt mu"><strong class="le ir"><em class="mv">function</em></strong><em class="mv"> </em>streamify(element, event) {<br/>  ...<br/>  <em class="mv">return </em>{<br/>    [Symbol.asyncIterator] () {<br/>      <em class="mv">return this<br/>    </em>},<br/>    next: () =&gt; ({<br/>      done, // TODO how do we calculate this?<br/>      value: <strong class="le ir">pullValue()</strong><br/>    }),<br/>    <em class="mv">return</em>: () =&gt; {<br/><strong class="le ir">      element.removeEventListener(listener, handler)</strong><br/>      <em class="mv">return </em>{done: <em class="mv">true</em>}<br/>    },<br/>    <em class="mv">throw</em>: (error) =&gt; ({done, value: Promise.reject(error)})<br/>  }<br/>}</span></pre><p id="4fd4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这看起来令人望而生畏，但它实际上只是<code class="fe lb lc ld le b">*</code>免费提供给我们的一堆样板文件。在发电机出现之前的糟糕日子里，我们不得不一直写类似的蹩脚的东西。今天，这个样板文件看起来应该很熟悉，因为它和你在控制台上登录<code class="fe lb lc ld le b">Set</code>或<code class="fe lb lc ld le b">Map</code>时看到的是一样的。</p><p id="9d0f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们看看我们得到了什么:<code class="fe lb lc ld le b">Symbol.asyncIterator()</code>方法告诉世界上的其他人把它当作一个生成器，而不是一个恰好具有完全相同字段的对象。其他所有的都返回一个带有<code class="fe lb lc ld le b">done</code>字段的对象，可能还有一个<code class="fe lb lc ld le b">value</code>。如果<code class="fe lb lc ld le b">done</code>为假，我们知道我们可以期待<em class="mv">某种</em>类型的值——因为这是一个<em class="mv">异步</em>迭代器，我猜这个值将是我们之前给出的同一个<code class="fe lb lc ld le b">pullValue()</code>承诺。剩下要做的就是在调用<code class="fe lb lc ld le b">next()</code>时计算出<code class="fe lb lc ld le b">done</code>的值。既然我们知道如果调用了<code class="fe lb lc ld le b">throw</code>或<code class="fe lb lc ld le b">return</code>，那么<code class="fe lb lc ld le b">done</code>应该为真，那么让我们像在&amp;之前一样，在外部作用域中共享变量:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="5496" class="mq lg iq le b gy mr ms l mt mu"><em class="mv">function </em>streamify(element, event) {<br/>  ...<br/><strong class="le ir">  <em class="mv">let </em>done = <em class="mv">false<br/></em></strong><em class="mv">  return </em>{<br/>    [Symbol.asyncIterator] () {<br/>      <em class="mv">return this<br/>    </em>},<br/>    next: () =&gt; ({<strong class="le ir">done</strong>, value: pullValue()}),<br/>    <em class="mv">return</em>: () =&gt; {<br/><strong class="le ir">      done = <em class="mv">true<br/></em></strong><em class="mv">      </em>element.removeEventListener(listener, handler)<br/>      <em class="mv">return </em>{done}<br/>    },<br/>    <em class="mv">throw</em>: (error) =&gt; {<br/><strong class="le ir">      done = <em class="mv">true<br/></em></strong><em class="mv">      return </em>{done, value: Promise.reject(error)}<br/>    }<br/>  }<br/>}</span></pre><p id="13fe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">…我们是<code class="fe lb lc ld le b">done</code>！我现在可以编写一个for循环，每次有事件进来时都进行迭代。如果我不喜欢这个值，我可以调用<code class="fe lb lc ld le b">throw</code>。当我玩够了，我可以打电话给<code class="fe lb lc ld le b">return</code>。</p><p id="c80d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以下是它的整体外观:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="5565" class="mq lg iq le b gy mr ms l mt mu"><em class="mv">const </em>streamify = <em class="mv">function </em>(element, event) {<br/>  <em class="mv">const </em>pullQueue = []<br/>  <em class="mv">const </em>pushQueue = []<br/>  <em class="mv">let </em>done = <em class="mv">false<br/>  const </em>pushValue = <em class="mv">async </em>(args) =&gt; {<br/>    <em class="mv">if </em>(pullQueue.length !== 0) {<br/>      <em class="mv">const </em>resolver = pullQueue.shift()<br/>      resolver(...args)<br/>    } <em class="mv">else </em>{<br/>      pushQueue.push(args)<br/>    }<br/>  }<br/><br/>  <em class="mv">const </em>pullValue = () =&gt; {<br/>    <em class="mv">return new </em>Promise((resolve) =&gt; {<br/>      <em class="mv">if </em>(pushQueue.length !== 0) {<br/>        <em class="mv">const </em>args = pushQueue.shift()<br/>        resolve(...args)<br/>      } <em class="mv">else </em>{<br/>        pullQueue.push(resolve)<br/>      }<br/>    })<br/>  }<br/><br/>  <em class="mv">const </em>handler = (...args) =&gt; {<br/>    pushValue(args)<br/>  }<br/><br/>  element.addEventListener(event, handler)<br/>  <em class="mv">return </em>{<br/>    [Symbol.asyncIterator]() {<br/>      <em class="mv">return this<br/>    </em>},<br/>    next: () =&gt; ({<br/>      done,<br/>      value: done ? <em class="mv">undefined </em>: pullValue()<br/>    }),<br/>    <em class="mv">return</em>: () =&gt; {<br/>      done = <em class="mv">true<br/>      </em>element.removeEventListener(event, handler)<br/>      <em class="mv">return </em>{done}<br/>    },<br/>    <em class="mv">throw</em>: (error) =&gt; {<br/>      done = <em class="mv">true<br/>      return </em>{<br/>        done,<br/>        value: Promise.reject(error)<br/>      }<br/>    }<br/>  }<br/>}</span></pre><h1 id="7cd3" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated"><strong class="ak">结论</strong></h1><p id="c753" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">如果你一直滚动到底部找到GitHub repo的链接，<a class="ae kc" href="https://github.com/mattkrick/asynciterify" rel="noopener ugc nofollow" target="_blank">这里是</a>。</p><p id="8f13" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在5分钟内，我们已经编写了一个50 LOC的包装器，它可以与所有存在依赖性的竞争包直接接触。在包装了我们的事件之后，我们终于可以宣布我们不再编写带有回调的代码了。2012年的梦想来了！最棒的是，我们没有学习什么是异步可迭代<em class="mv">而是学习了</em>如何使用它。我们不必拿出函数式编程教科书来研究一个<code class="fe lb lc ld le b">Subject</code>、<code class="fe lb lc ld le b">Deferrable,</code>或<code class="fe lb lc ld le b">Disposable</code>的定义。相反，我们建造了一些实用的东西——比如上烹饪课，然后带着晚餐离开。<em class="mv">方式</em>比CS理论更好玩。</p><p id="6c71" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">唯一的问题是:仅仅因为我们可以，就意味着我们应该吗？从干净代码的角度来看，也许是吧！但是性能呢？承诺天生就比回调慢，最重要的是，我们在两个队列中调用<code class="fe lb lc ld le b">shift()</code>一堆。在Chrome 67中运行代码，对于100-1，000，000个事件，它比原生回调慢2-100倍以上。当代码被传输到ES5时，速度会慢20-1000倍！因此，从基准的角度来看，这简直糟透了。但在现实世界中，这相当于额外增加0.1毫秒来处理10个并发事件。放弃试镜是公平的交易！</p></div></div>    
</body>
</html>