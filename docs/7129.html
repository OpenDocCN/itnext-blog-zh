<html>
<head>
<title>Merging concurrent IAsyncEnumerable<t> operations for increased performance</t></title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">合并并发IAsyncEnumerable <t>操作以提高性能</t></h1>
<blockquote>原文：<a href="https://itnext.io/merging-concurrent-iasyncenumerable-t-operations-for-increased-performance-d8393005c6ae?source=collection_archive---------2-----------------------#2022-06-20">https://itnext.io/merging-concurrent-iasyncenumerable-t-operations-for-increased-performance-d8393005c6ae?source=collection_archive---------2-----------------------#2022-06-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/395d4de80400a103ee84d00b9fa1dd1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NvtypWm9IPho2gATJiSLNw.png"/></div></div></figure><div class=""/><p id="86c5" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最近，我终于有机会使用一些IAsyncEnumerable方法，而不仅仅是尝试这些新的异步流的一些概念证明。因为它非常适合，我认为我可以同时运行多个IAsyncEnumerable，但是我很快注意到没有好的内置方法将多个异步流合并为一个，所以我决定开始构建自己的系统！</p><h1 id="d702" class="kz la je bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">快速IAsyncEnumerable简介</h1><p id="b8e1" class="pw-post-body-paragraph kb kc je kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">如果您还不熟悉IAsyncEnumerable，我会为您做好准备。这是C#8引入的一个(相对)新特性，本质上代表了一个基于异步拉的流。它是众所周知的IEnumerable的异步对应。如果你现在想知道为什么我们需要它，因为我们已经可以使用Task <ienumerable>&gt;，主要的区别是新的API允许一个生成器，一旦有东西被返回，它就产生执行。这在IEnumerable中是不可能的，因为它没有异步生成器。你总是一次就得到所有的结果，中间什么都没有。</ienumerable></p><p id="ea1d" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下面是一个演示IAsyncEnumerable的示例:</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="37a5" class="ml la je mh b gy mm mn l mo mp">async Task Main()<br/>{<br/> await foreach (var item in Iterate())<br/> {<br/>  Console.WriteLine(item);<br/> }<br/>}</span><span id="a4a4" class="ml la je mh b gy mq mn l mo mp">public async IAsyncEnumerable&lt;int&gt; Iterate()<br/>{<br/> for (var i = 0; i &lt; 5; ++i)<br/> {<br/>  await Task.Delay(100);<br/>  Console.WriteLine("Yielding");<br/>  yield return i;<br/> }<br/>}</span><span id="c2fc" class="ml la je mh b gy mq mn l mo mp">// Output:<br/>Yielding<br/>0<br/>Yielding<br/>1<br/>Yielding<br/>2<br/>Yielding<br/>3<br/>Yielding<br/>4</span></pre><h1 id="603f" class="kz la je bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">合并IAsyncEnumerable</h1><p id="a5bf" class="pw-post-body-paragraph kb kc je kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">太好了，现在我们知道它是如何工作的了。让我们回到我最初面临的问题。本质上，我想消费一个端点，比如</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="0c33" class="ml la je mh b gy mm mn l mo mp">public async IAsyncEnumerable&lt;int&gt; Iterate()<br/>{<br/> for (var i = 0; i &lt; 5; ++i)<br/> {<br/>  await Task.Delay(100);<br/>  yield return i;<br/> }<br/>}</span></pre><p id="b92e" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">多次，同时。但是，假设我们一次创建多个IAsyncEnumerable <int>:</int></p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="3664" class="ml la je mh b gy mm mn l mo mp">var asyncIterators = Enumerable.Range(0, 3).Select(_ =&gt; Iterate());</span></pre><p id="6bcd" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，我们如何迭代它们呢？</p><p id="bebb" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们逐个迭代，那么我们基本上是先迭代第一个IAsyncEnumerable，然后第二个，然后第三个。我们总共需要15*100毫秒才能完成。与常规的“热”任务不同，IAsyncEnumerable number 2和3也不会在后台开始迭代——记住，我们处理的是基于拉的生成器。除非有人从中抽取内容，否则什么都不会发生。</p><p id="5ddf" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">所以，我们走吧。我的主要目标是将合并后的东西也作为IAsyncEnumerable <t>公开，这样外界就不必改变它们的用法并适应不同的模式。</t></p><p id="bca9" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先，我创建了一个类，它接受任意数量的IAsyncEnumerable <t>，并从IAsyncEnumerable <t>继承:</t></t></p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="75d6" class="ml la je mh b gy mm mn l mo mp">public class MergedAsyncEnumerable&lt;T&gt; : IAsyncEnumerable&lt;T&gt;<br/>{<br/> private readonly IAsyncEnumerable&lt;T&gt;[] _asyncEnumerables;</span><span id="18f6" class="ml la je mh b gy mq mn l mo mp">public MergedAsyncEnumerable(params IAsyncEnumerable&lt;T&gt;[] asyncEnumerables)<br/> {<br/>  _asyncEnumerables = asyncEnumerables;<br/> }</span><span id="13fb" class="ml la je mh b gy mq mn l mo mp">public IAsyncEnumerator&lt;T&gt; GetAsyncEnumerator(CancellationToken cancellationToken = default)<br/>  =&gt; ConsumeMergedAsyncEnumerabled().GetAsyncEnumerator(cancellationToken);</span><span id="8ac1" class="ml la je mh b gy mq mn l mo mp">private async IAsyncEnumerable&lt;T&gt; ConsumeMergedAsyncEnumerabled()<br/> {<br/>...</span></pre><p id="0b40" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">GetAsyncEnumerator是由接口引入的方法，所以我们必须实现它。我还添加了一个方法，我们将使用该方法来消费合并的流，我们返回该合并流的枚举数以符合接口。</p><p id="da10" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在我们有了这个设置，我们需要做的就是在ConsumeMergedAsyncEnumerabled方法中直接得到我们的逻辑。核心思想是将我们的异步可枚举数转换成一个结构，该结构同时遍历每个单独的异步可枚举数，并允许我们为每个可枚举数提取一个任务。</p><p id="b056" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一旦我们有了每个异步可枚举的当前“未决”任务，我们就可以使用Task。WhenAny(…)获取第一个完成的任务，并在相应的索引处向前移动迭代器。如果任何一个异步枚举没有更多的条目，我们将在下一个WhenAny中忽略它，并继续这样做，直到所有的条目都被处理。</p><p id="d142" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是我们的索引迭代器结构:</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="6eae" class="ml la je mh b gy mm mn l mo mp">private record IndexedIteratorResult(T Item, bool HasMore, int Index);</span><span id="6281" class="ml la je mh b gy mq mn l mo mp">private class IndexedIterator<br/> {<br/>  private int _index;</span><span id="0c42" class="ml la je mh b gy mq mn l mo mp">private readonly IAsyncEnumerator&lt;T&gt; _asyncEnumerator;</span><span id="4532" class="ml la je mh b gy mq mn l mo mp">public IndexedIterator(IAsyncEnumerable&lt;T&gt; asyncEnumerable, int index)<br/>  {<br/>   _asyncEnumerator = asyncEnumerable.GetAsyncEnumerator();<br/>   _index = index;<br/>  }</span><span id="f5ab" class="ml la je mh b gy mq mn l mo mp">public async Task&lt;IndexedIteratorResult&gt; MoveAhead()<br/>  {<br/>   var hasMoreEntries = await _asyncEnumerator.MoveNextAsync();<br/>   return new IndexedIteratorResult(_asyncEnumerator.Current, hasMoreEntries, _index);<br/>  }<br/> }</span></pre><p id="4072" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">它接受IAsyncEnumerator并按需前进。</p><p id="5ad4" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">综上所述，这是最终的实现:</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="a53c" class="ml la je mh b gy mm mn l mo mp">private async IAsyncEnumerable&lt;T&gt; ConsumeMergedAsyncEnumerabled()<br/> {<br/>  var iterators = _asyncEnumerables<br/>   .Select((x, index) =&gt; new IndexedIterator(x, index))<br/>   .ToArray();</span><span id="851b" class="ml la je mh b gy mq mn l mo mp">var tasks = iterators<br/>   .Select(x =&gt; x.MoveAhead())<br/>   .ToArray();</span><span id="0ad4" class="ml la je mh b gy mq mn l mo mp">while (tasks.Any(x =&gt; x is not null))<br/>  {<br/>   var winningTask = await Task.WhenAny(tasks.Where(x =&gt; x is not null));<br/>   var (Item, HasMore, Index) = winningTask.Result;</span><span id="4003" class="ml la je mh b gy mq mn l mo mp">if (!HasMore)<br/>   {<br/>    tasks[Index] = null;<br/>    continue;<br/>   }</span><span id="357f" class="ml la je mh b gy mq mn l mo mp">yield return Item;<br/>tasks[Index] = iterators[Index].MoveAhead();</span><span id="9a58" class="ml la je mh b gy mq mn l mo mp">  }<br/> }</span></pre><p id="2299" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先，我们创建一个IndexedIterators数组，每个数组对应一个异步枚举。</p><p id="bb59" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后，我们通过将每个迭代器向前移动一位来开始最初的任务数组。这将同时发生。</p><p id="03b6" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们循环遍历任务，直到所有的任务都为空，这基本上表明没有异步可枚举的剩余项。</p><p id="8827" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们获取集合中第一个完成的任务，yield返回它的值(并因此为我们的组合IAsyncEnumerable <t>的消费者生成一个条目),并根据它是否还有条目，或者将它标记为完成，或者推进它的迭代器。</t></p><p id="dc62" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">所有这些工作背后的驱动力是所有异步流的任务同时运行的事实，我们只是碰巧选择了第一个完成的，而其余的只是继续工作。</p><p id="3c59" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了证明这确实有效，我们得到了以下结果:</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="63af" class="ml la je mh b gy mm mn l mo mp">sw.Restart();</span><span id="4395" class="ml la je mh b gy mq mn l mo mp">var asyncIteratorsMerged = new MergedAsyncEnumerable&lt;int&gt;(Enumerable.Range(0, 3).Select(_ =&gt; Iterate()).ToArray());</span><span id="65c3" class="ml la je mh b gy mq mn l mo mp">await foreach (var item in asyncIteratorsMerged)<br/> {<br/>  Console.WriteLine(item);<br/> }</span><span id="f3f8" class="ml la je mh b gy mq mn l mo mp">sw.Stop();<br/> Console.WriteLine(sw.Elapsed);<br/>}</span><span id="bbe5" class="ml la je mh b gy mq mn l mo mp">// Output:<br/>0<br/>0<br/>0<br/>1<br/>1<br/>1<br/>2<br/>2<br/>2<br/>3<br/>3<br/>3<br/>4<br/>4<br/>4<br/>00:00:00.5737606</span></pre><p id="e43d" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">完美！我们达到了500毫秒，而不是1500毫秒，保持了IAsyncEnumerable <t>的处理，并正确地使一切并行工作！</t></p><p id="fb7a" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">请注意，我完全意识到这可能不是最聪明或最有效的方式，但这是我解决的问题，它帮助我正确理解IAsyncEnumerable <t>，它的约束和它的底层机制。</t></p><p id="fd6c" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">希望有帮助！</p></div></div>    
</body>
</html>