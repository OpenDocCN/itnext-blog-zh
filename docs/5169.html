<html>
<head>
<title>Create a Stopwatch App with Flutter</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Flutter创建秒表应用程序</h1>
<blockquote>原文：<a href="https://itnext.io/create-a-stopwatch-app-with-flutter-f0dc6a176b8a?source=collection_archive---------1-----------------------#2020-12-31">https://itnext.io/create-a-stopwatch-app-with-flutter-f0dc6a176b8a?source=collection_archive---------1-----------------------#2020-12-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/1b1947c795384cb21055ae62e4ea389a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*IvTHTzUOVEU540PT.png"/></div></div></figure><p id="cdc2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我最近一直在学习Flutter和Dart语言，它们给我留下了深刻的印象。Flutter很大程度上受到React的启发，许多概念已经很熟悉了:有状态/无状态、渲染函数、组件层次结构等等。至于支持Flutter的Dart语言，它继承了其他语言的许多最好的特性，同时避免了不好的东西，所以如果你已经知道python、JavaScript、C++，你可以很快学会Dart。</p><p id="a803" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">好了，让我们回到这篇文章的主题:创建秒表应用程序。有一些关于如何制作秒表的帖子(像<a class="ae kz" href="https://medium.com/analytics-vidhya/build-a-simple-stopwatch-in-flutter-a1f21cfcd7a8" rel="noopener">这个</a>，但是我想分享一个替代的方法。</p><p id="03e5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这篇文章中的例子使用了Android Studio。如果您还没有这样做，请按照Flutter文档中的<a class="ae kz" href="https://flutter.dev/docs/get-started/install" rel="noopener ugc nofollow" target="_blank">“开始”部分来设置Flutter和Android Studio。</a></p><h1 id="7e14" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">这个想法</h1><p id="8405" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">旋舞提供了一个<code class="fe md me mf mg b"><a class="ae kz" href="https://api.flutter.dev/flutter/dart-core/Stopwatch-class.html" rel="noopener ugc nofollow" target="_blank">Stopwatch</a></code> <a class="ae kz" href="https://api.flutter.dev/flutter/dart-core/Stopwatch-class.html" rel="noopener ugc nofollow" target="_blank">类</a>。可以启动或停止，经过的时间可以从<code class="fe md me mf mg b">elapsedMilliseconds</code>属性中读取。所以从技术上讲，我们可以建立一个带有<code class="fe md me mf mg b">Stopwatch</code>实例的页面，然后简单地显示<code class="fe md me mf mg b">stopwatch.elapsedMilliseconds</code>。</p><p id="13ca" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然而，有一个问题:<code class="fe md me mf mg b">Stopwatch</code>不提供任何回调，所以我们不知道何时执行重新渲染。这里<code class="fe md me mf mg b"><a class="ae kz" href="https://api.flutter.dev/flutter/dart-async/Timer-class.html" rel="noopener ugc nofollow" target="_blank">Timer</a></code> <a class="ae kz" href="https://api.flutter.dev/flutter/dart-async/Timer-class.html" rel="noopener ugc nofollow" target="_blank">级</a>前来救援。它以给定的时间间隔触发回调。因此，我们可以使用一个<code class="fe md me mf mg b">Timer</code>来触发重新渲染，读取<code class="fe md me mf mg b">stopwatch.elapsedMilliseconds</code>并重建页面。</p><h1 id="f9dd" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">履行</h1><p id="b9cd" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">在Android Studio中创建新的Flutter项目，然后用下面的代码替换<code class="fe md me mf mg b">main.dart</code>。</p><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="ff96" class="mp lb it mg b gy mq mr l ms mt">import 'package:flutter/material.dart';</span><span id="e29c" class="mp lb it mg b gy mu mr l ms mt">void main() {<br/>  runApp(MyApp());<br/>}</span><span id="6da2" class="mp lb it mg b gy mu mr l ms mt">String formatTime(int milliseconds) {<br/>  var secs = milliseconds ~/ 1000;<br/>  var hours = (secs ~/ 3600).toString().padLeft(2, '0');<br/>  var minutes = ((secs % 3600) ~/ 60).toString().padLeft(2, '0');<br/>  var seconds = (secs % 60).toString().padLeft(2, '0');</span><span id="c774" class="mp lb it mg b gy mu mr l ms mt">  return "$hours:$minutes:$seconds";<br/>}</span><span id="9fa0" class="mp lb it mg b gy mu mr l ms mt">class MyApp extends StatelessWidget {<br/>  @override<br/>  Widget build(BuildContext context) {<br/>    return MaterialApp(title: 'Stopwatch Example', home: StopwatchPage());<br/>  }<br/>}</span><span id="7d7e" class="mp lb it mg b gy mu mr l ms mt">class StopwatchPage extends StatefulWidget {<br/>  @override<br/>  _StopwatchPageState createState() =&gt; _StopwatchPageState();<br/>}</span><span id="cfc0" class="mp lb it mg b gy mu mr l ms mt">class _StopwatchPageState extends State&lt;StopwatchPage&gt; {<br/>  Stopwatch _stopwatch;</span><span id="946c" class="mp lb it mg b gy mu mr l ms mt">  @override<br/>  void initState() {<br/>    super.initState();<br/>    _stopwatch = Stopwatch();<br/>  }</span><span id="1489" class="mp lb it mg b gy mu mr l ms mt">  void handleStartStop() {<br/>    if (_stopwatch.isRunning) {<br/>      _stopwatch.stop();<br/>    } else {<br/>      _stopwatch.start();<br/>    }<br/>    setState(() {});    // re-render the page<br/>  }</span><span id="90f1" class="mp lb it mg b gy mu mr l ms mt">  @override<br/>  Widget build(BuildContext context) {<br/>    return Scaffold(<br/>      appBar: AppBar(title: Text('Stopwatch Example')),<br/>      body: Center(<br/>        child: Column(<br/>          mainAxisAlignment: MainAxisAlignment.center,<br/>          children: &lt;Widget&gt;[<br/>            Text(formatTime(_stopwatch.elapsedMilliseconds), style: TextStyle(fontSize: 48.0)),<br/>            ElevatedButton(onPressed: handleStartStop, child: Text(_stopwatch.isRunning ? 'Stop' : 'Start')),<br/>          ],<br/>        ),<br/>      ),<br/>    );<br/>  }<br/>}</span></pre><p id="af26" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">主类<code class="fe md me mf mg b">StopwatchPage</code>是一个<code class="fe md me mf mg b">StatefulWidget</code>，他创建了一个<code class="fe md me mf mg b">Stopwatch</code>实例<code class="fe md me mf mg b">_stopwatch</code>。<code class="fe md me mf mg b">_stopwatch.elapsedMilliseconds</code>由<code class="fe md me mf mg b">formatTime</code>函数格式化并显示在页面上。一个按钮控制<code class="fe md me mf mg b">_stopwatch</code>的启动/停止。非常简单的设置。</p><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/8ac14069a5ecfa97aa001f9fac945978.png" data-original-src="https://miro.medium.com/v2/resize:fit:1064/format:webp/0*jtygb7gZu5bSG2lJ.png"/></div></figure><p id="3a5a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">运行这个应用程序，你会看到上面的页面。您还会注意到，单击“开始”按钮后，秒表不会增加。它实际上正在运行，因为如果你反复点击“开始”/“停止”按钮，你会看到时间增加。这就是我们在“想法”部分讨论的问题——我们不知道何时重新呈现页面。<code class="fe md me mf mg b">_stopwatch</code>在后台运行，只是不显示。</p><p id="0223" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将添加一个<code class="fe md me mf mg b">Timer</code>实例来帮助重新渲染。</p><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="e625" class="mp lb it mg b gy mq mr l ms mt">  <strong class="mg iu">Timer _timer;</strong></span><span id="db3e" class="mp lb it mg b gy mu mr l ms mt">  @override<br/>  void initState() {<br/>    super.initState();<br/>    _stopwatch = Stopwatch();<br/>    <strong class="mg iu">// re-render every 30ms<br/>    _timer = new Timer.periodic(new Duration(milliseconds: 30), (timer) {<br/>      setState(() {});<br/>    });</strong><br/>  }</span><span id="33db" class="mp lb it mg b gy mu mr l ms mt"><strong class="mg iu">  @override<br/>  void dispose() {<br/>    _timer.cancel();<br/>    super.dispose();<br/>  }</strong></span></pre><p id="76f4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在上面的代码中，我们创建了一个每30毫秒调用一次<code class="fe md me mf mg b">setState</code>的<code class="fe md me mf mg b">Timer</code>实例。这将帮助我们重新呈现页面并反映实际的秒表值。</p><p id="5239" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在重启应用程序(由于<code class="fe md me mf mg b">initState()</code>中发生了更改，热重装将不起作用)。单击“开始”按钮，您将看到秒表正常工作。</p><h1 id="4dd0" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">结论</h1><p id="57b2" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">你可以访问我的GitHub查看<a class="ae kz" href="https://github.com/charlee/stopwatch_example" rel="noopener ugc nofollow" target="_blank">这篇帖子的完整代码</a>。</p><p id="6a54" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">简而言之，秒表由两部分组成:计算时间的<code class="fe md me mf mg b">Stopwatch</code>实例和呈现页面的<code class="fe md me mf mg b">Timer</code>实例。</p><p id="f57c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当然，这个应用程序可以进一步改进，例如改进<code class="fe md me mf mg b">Timer</code>回调，以便只有当格式化的时间字符串改变时才触发重新渲染。为了使这篇文章简短，我将把它留给读者。</p><p id="c938" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">但是请记住，如果应用程序转到后台，在UI小部件中创建的<code class="fe md me mf mg b">Stopwatch</code>实例将无法存活。我在Android上的测试显示，应用程序停止运行几分钟后，秒表就会停止计时。</p><p id="2e5b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">所以秒表只能在应用程序激活时使用。要创建一个即使应用程序不活动也能运行的真正的秒表，需要一些先进的方法，例如需要在Android上创建一个<a class="ae kz" href="https://developer.android.com/guide/components/foreground-services" rel="noopener ugc nofollow" target="_blank">前台服务</a>。</p></div></div>    
</body>
</html>