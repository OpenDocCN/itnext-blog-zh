<html>
<head>
<title>Typing basic types with Typescript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Typescript键入基本类型</h1>
<blockquote>原文：<a href="https://itnext.io/typing-basic-types-with-typescript-84288aa38b7c?source=collection_archive---------4-----------------------#2021-09-07">https://itnext.io/typing-basic-types-with-typescript-84288aa38b7c?source=collection_archive---------4-----------------------#2021-09-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/df432c48a5dec9106dc6ab8e22af4ddd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oyMFqbKT3ykY6euVJsKIEg.png"/></div></div></figure><p id="6021" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以这里有一个问题。我们有<code class="fe kw kx ky kz b">string</code>和<code class="fe kw kx ky kz b">ISOStrings</code>以及<code class="fe kw kx ky kz b">ids</code>。</p><ol class=""><li id="e8ec" class="la lb iq ka b kb kc kf kg kj lc kn ld kr le kv lf lg lh li bi translated">我们不想将任何<code class="fe kw kx ky kz b">string</code>分配给有<code class="fe kw kx ky kz b">ISOString</code>的字段，但是<code class="fe kw kx ky kz b">ISOString</code>应该可以分配给<code class="fe kw kx ky kz b">string</code></li><li id="07d0" class="la lb iq ka b kb lj kf lk kj ll kn lm kr ln kv lf lg lh li bi translated">我们不希望将一种数据类型的<code class="fe kw kx ky kz b">id</code>赋给另一种数据类型的id。</li></ol><h1 id="a2ee" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">1:模板文字类型</h1><p id="cdd3" class="pw-post-body-paragraph jy jz iq ka b kb mm kd ke kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv ij bi translated">自4.1版本以来，模板文本类型一直是Typescript的一部分。现在我们可以指定一个满足模板的<code class="fe kw kx ky kz b">string</code>。</p><pre class="mr ms mt mu gt mv kz mw mx aw my bi"><span id="0e33" class="mz lp iq kz b gy na nb l nc nd">type Hello&lt;Greeted extends string&gt; = `Hello, ${Greeted}!`<br/>type HelloWorld = Hello&lt;'World'&gt;<br/>const hello1: HelloWorld = 'Hello, World!'<br/>const hello2: HelloWorld = 'Hello, Oli!' // error</span></pre><p id="76ca" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这样我们就可以用<code class="fe kw kx ky kz b">${number}</code>来定义一个等值串。但是要小心，因为如果你“正确地”处理，结果类型将是一个有太多字段的<code class="fe kw kx ky kz b">Union</code>类型。下面是我们如何为<code class="fe kw kx ky kz b">ISOString</code> s创建一个类型:</p><pre class="mr ms mt mu gt mv kz mw mx aw my bi"><span id="bcc8" class="mz lp iq kz b gy na nb l nc nd">type PaddedNumber = `${'0' | ''}${number}`<br/>type ISODate = `${number}-${PaddedNumber}-${PaddedNumber}`<br/>type ISOTime = `${PaddedNumber}:${PaddedNumber}:${PaddedNumber}`<br/>export type ISOString = `${ISODate}T${ISOTime}Z`</span></pre><h1 id="6aac" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">2:品牌</h1><h2 id="f606" class="mz lp iq bd lq nf ng dn lu nh ni dp ly kj nj nk mc kn nl nm mg kr nn no mk np bi translated">传统品牌</h2><p id="98d9" class="pw-post-body-paragraph jy jz iq ka b kb mm kd ke kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv ij bi translated">到目前为止，人们已经使用了某种“品牌化”的方法来使一个<code class="fe kw kx ky kz b">id</code>不能分配给另一个<code class="fe kw kx ky kz b">id</code>。例如:</p><pre class="mr ms mt mu gt mv kz mw mx aw my bi"><span id="69ad" class="mz lp iq kz b gy na nb l nc nd">interface UserBrand { type: 'User' }<br/>type UserId = string &amp; UserBrand</span><span id="1cc6" class="mz lp iq kz b gy nq nb l nc nd">interface ArticleBrand { type: 'Article' }<br/>type ArticleId = string &amp; ArticleBrand</span></pre><p id="c7f9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在当我们…</p><pre class="mr ms mt mu gt mv kz mw mx aw my bi"><span id="d3f9" class="mz lp iq kz b gy na nb l nc nd">const userId: UserId = user.id // ok<br/>const articleId: ArticleId = userId // error</span></pre><p id="0ed6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">…这对我们的类型检查有很大的好处。但是，当我们这样做时，这种方法确实会引起问题。</p><pre class="mr ms mt mu gt mv kz mw mx aw my bi"><span id="d0f3" class="mz lp iq kz b gy na nb l nc nd">const userId: UserId = 'user-id' // error<br/>const userId2: UserId = 'user-id' as UserId // casting is ok</span></pre><h2 id="5b09" class="mz lp iq bd lq nf ng dn lu nh ni dp ly kj nj nk mc kn nl nm mg kr nn no mk np bi translated">备选方案1:允许分配基本类型的品牌</h2><p id="b28d" class="pw-post-body-paragraph jy jz iq ka b kb mm kd ke kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv ij bi translated">这里有一个来自<a class="ae nr" href="https://spin.atomicobject.com/2018/01/15/typescript-flexible-nominal-typing/" rel="noopener ugc nofollow" target="_blank">德鲁·科尔索普关于不透明类型的文章</a>的解决方案(在他的文章“调味”中)，通过使用这个接口，我们创建了一个带有<code class="fe kw kx ky kz b">string</code>的联合类型，而不是不可相互赋值的类型</p><pre class="mr ms mt mu gt mv kz mw mx aw my bi"><span id="31bf" class="mz lp iq kz b gy na nb l nc nd">interface OpaqueType&lt;OpaqueT&gt; {<br/>  _type?: OpaqueT;<br/>}<br/>export type Opaque&lt;T, OpaqueT&gt; = T &amp; OpaqueType&lt;OpaqueT&gt;;</span></pre><p id="47d1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，如果我们将id类型更改为…</p><pre class="mr ms mt mu gt mv kz mw mx aw my bi"><span id="5f67" class="mz lp iq kz b gy na nb l nc nd">type UserId = Opaque&lt;string, "User”&gt;<br/>type ArticleId = Opaque&lt;number, "Article"&gt;</span></pre><p id="7a2d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们现在得到这样的效果:</p><pre class="mr ms mt mu gt mv kz mw mx aw my bi"><span id="3ce0" class="mz lp iq kz b gy na nb l nc nd">const userId: UserId = 'user-id' // ok<br/>const articleId: ArticleId = 'article-id // ok<br/>const userId2: UserId = articleId // error</span></pre><h2 id="fef5" class="mz lp iq bd lq nf ng dn lu nh ni dp ly kj nj nk mc kn nl nm mg kr nn no mk np bi translated">使用“唯一符号”</h2><p id="5fb6" class="pw-post-body-paragraph jy jz iq ka b kb mm kd ke kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv ij bi translated">使用<code class="fe kw kx ky kz b">unique symbol</code>可以保护品牌的单一真实来源，并确保两个品牌永远不会相同。例如，我们可以创建两个ISOString品牌，如下所示:</p><pre class="mr ms mt mu gt mv kz mw mx aw my bi"><span id="3b82" class="mz lp iq kz b gy na nb l nc nd">type ISOString = string &amp; {readonly ISOString: unique symbol}<br/>type ISOString2 = string &amp; {readonly ISOString: unique symbol}<br/>let isoString1: ISOString = 'isostring' as ISOString // ok<br/>let isoString2: ISOString2 = 'isostring2' as ISOString2 // ok<br/>isoString1 = isoString2 // error</span></pre><p id="2111" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">同样，你可以用一个独特的符号来代替不透明的文字。</p><pre class="mr ms mt mu gt mv kz mw mx aw my bi"><span id="63b0" class="mz lp iq kz b gy na nb l nc nd">type ISOString = Opaque&lt;string, { readonly T: unique symbol }&gt;<br/>type ISOString2 = Opaque&lt;string, { readonly T: unique symbol }&gt;<br/>const isostring: ISOString = 'isostring'<br/>let alsoIsostring: ISOString2 = 'isostring'<br/>alsoIsostring = isostring // error</span></pre><p id="5e95" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">差别是微妙的。假设两个人用相同的签名创造了相同的品牌，那么用<code class="fe kw kx ky kz b">unique symbol</code>他们将不可互换。代码库越大，你就越需要知道你正在导入正确的<code class="fe kw kx ky kz b">CommentId</code>或类型。</p><h2 id="6573" class="mz lp iq bd lq nf ng dn lu nh ni dp ly kj nj nk mc kn nl nm mg kr nn no mk np bi translated">什么时候应该使用哪个？</h2><p id="ac11" class="pw-post-body-paragraph jy jz iq ka b kb mm kd ke kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv ij bi translated">当然，这取决于你的需要。</p><ul class=""><li id="0efb" class="la lb iq ka b kb kc kf kg kj lc kn ld kr le kv ns lg lh li bi translated">如果你想要一个内置的字符串验证，那么使用一个模板文字</li><li id="2f28" class="la lb iq ka b kb lj kf lk kj ll kn lm kr ln kv ns lg lh li bi translated">如果你想确保人们不会混淆不同格式的id或字符串，那么就使用某种品牌。</li><li id="2673" class="la lb iq ka b kb lj kf lk kj ll kn lm kr ln kv ns lg lh li bi translated">如果你两个都需要，那就两个都用。</li></ul><p id="dbce" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">到此为止，快乐编码！</p><h2 id="2875" class="mz lp iq bd lq nf ng dn lu nh ni dp ly kj nj nk mc kn nl nm mg kr nn no mk np bi translated">附录:图书推荐</h2><p id="902a" class="pw-post-body-paragraph jy jz iq ka b kb mm kd ke kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv ij bi translated">这些书让我跨越了几年的经验，对你也一样。罗伯特·马丁的<br/> * <a class="ae nr" href="https://amzn.to/3z083SU" rel="noopener ugc nofollow" target="_blank">干净的代码<br/> * </a><a class="ae nr" href="https://amzn.to/2UyrEdS" rel="noopener ugc nofollow" target="_blank">罗伯特·马丁的</a>干净的架构</p></div></div>    
</body>
</html>