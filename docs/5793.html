<html>
<head>
<title>Introducing KSML: Kafka Streams for Low Code Environments</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">介绍KSML:适用于低代码环境的Kafka流</h1>
<blockquote>原文：<a href="https://itnext.io/introducing-ksml-kafka-streams-for-low-code-environments-1f813ee69a14?source=collection_archive---------5-----------------------#2021-05-26">https://itnext.io/introducing-ksml-kafka-streams-for-low-code-environments-1f813ee69a14?source=collection_archive---------5-----------------------#2021-05-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="b9ad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Kafka Streams吸引了许多希望在Kafka基础上开发流媒体应用程序的开发人员。但是尽管框架很强大，Kafka Streams还是很难避开编写Java代码和建立构建管道的要求。有一些重建Kafka流的尝试，但是直到现在像Python这样的流行语言还没有得到同样强大的(和维护的)流处理框架。在这篇文章中，我们将提出一个新的声明性方法来解锁Kafka流，称为KSML。当你读完的时候，你将能够自己编写流应用程序，只需要使用一些简单的基本规则和Python代码片段。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/0e9e7fc55fb190366cd935b90a8a29ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2d1uT33p1uP42oWxr6LZow.png"/></div></div></figure><h1 id="b088" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">背景</h1><p id="7a5c" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">Axual是面向企业客户的基于Kafka的流媒体平台供应商。在Axual Platform和Axual Cloud的名称下，我们主要向企业客户销售我们的解决方案。我们的总体使命是让流媒体变得简单，这意味着我们的产品试图为客户隐藏卡夫卡的复杂性。我们通过提供标准方法、标准化架构和简单安装来实现这一目标。更多关于Axual的信息，请访问<a class="ae ma" href="https://axual.com/" rel="noopener ugc nofollow" target="_blank">https://axual.com</a>。</p><p id="5fed" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Axual产品的一个主要特点是为开发团队提供自助服务。直观的UI允许客户团队配置他们的通用Kafka平台。团队自己定义主题、模式和应用程序。严格的所有权和批准流程为企业提供了必要的数据治理。</p><p id="d15f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">自助服务的用户通常不太懂卡夫卡。他们了解Kafka，甚至可能喜欢它，但他们的主要职责是构建一个恰好需要与Kafka交互的业务应用程序。自助服务允许他们将自己的应用程序定义为自定义应用程序或Kafka连接器。但直到最近，我们还没有办法轻松定义“简单转换”应用。Kafka Streams提供了流处理的基础，但是需要Java开发人员和(通常很复杂)构建管道。</p><p id="b47d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了更容易定义流媒体应用，我们开始研究是否可以在不需要Java的情况下释放Kafka流的力量。</p><h1 id="fae9" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">来自家庭助理的灵感</h1><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mb"><img src="../Images/0526e4cc20b9f4da13e6500b3cf8b079.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pNjqO39Rd3mMpc8aX63b3g.png"/></div></div></figure><p id="72de" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在新冠肺炎封锁期间，我开始试验<a class="ae ma" href="https://home-assistant.io/" rel="noopener ugc nofollow" target="_blank">家庭助手</a>，这是一个家庭自动化平台，集成了你家里的一切<em class="mc">和</em>厨房水槽。如果你对家庭自动化感兴趣，我强烈推荐你看看这个巨大的软件。</p><p id="c886" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了允许集成和控制来自任何供应商的任何类型的设备，Home Assistant为自动化、脚本和传感器等定义了自己的YAML结构。YAML真正的好处在于它是被解释的，不需要编译。</p><h1 id="ef53" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">假设</h1><p id="6d15" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">Home Assistant定义定制逻辑的方式引发了我们的思考:我们可以使用类似的结构来定义Kafka Streams拓扑吗？很容易按照以下方式来想象拓扑:</p><pre class="km kn ko kp gt md me mf mg aw mh bi"><span id="6d8d" class="mi ky iq me b gy mj mk l ml mm">pipelines:<br/>  main:<br/>    from: some_topic<br/>    to: some_other_topic</span></pre><p id="8773" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个例子定义了一个拓扑，它只是将消息从源主题复制到目标主题。但任何熟悉卡夫卡作品的人都会立即意识到，这只能是整体解决方案的一部分。Kafka Streams在Java中需要很多自定义的用户函数，比如谓词、键/值转换器和ValueJoiners。如果我们想定义YAML的一切，我们需要一种无编译器的表达式语言。</p><p id="0108" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后我们转向了<a class="ae ma" href="https://www.jython.org/" rel="noopener ugc nofollow" target="_blank"> Jython </a>，这是一个运行在Java JVM中的完整Python实现。运行Python代码就像创建PythonInterpreter的实例并让它执行以字符串形式提供的代码一样简单。</p><pre class="km kn ko kp gt md me mf mg aw mh bi"><span id="c10d" class="mi ky iq me b gy mj mk l ml mm">import org.python.util.PythonInterpreter;</span><span id="15b8" class="mi ky iq me b gy mn mk l ml mm">public class JythonHelloWorld {<br/>  public static void main(String[] args) {<br/>    try(PythonInterpreter pyInterp = new PythonInterpreter()) {<br/>      pyInterp.exec("print('Hello Python World!')");<br/>    }<br/>  }<br/>}</span></pre><p id="14c4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">经过几天的修补，我们能够将这两者结合成我们预想的通用解释器。在深入例子之前，让我们看一下我们使用的测试环境。</p><h1 id="159d" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">设置测试环境</h1><p id="3aa2" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">为了说明KSML的能力，我们设置了一个名为<code class="fe mo mp mq me b">ksml_sensordata_avro</code>的测试主题，其键/值类型为<code class="fe mo mp mq me b">String</code> / <code class="fe mo mp mq me b">SensorData</code>。<code class="fe mo mp mq me b">SensorData</code>模式包含以下字段:</p><pre class="km kn ko kp gt md me mf mg aw mh bi"><span id="aa5c" class="mi ky iq me b gy mj mk l ml mm">{<br/>  "namespace": "io.axual.ksml.example",<br/>  "doc": "Emulated sensor data with a few additional attributes",<br/>  "name": "SensorData",<br/>  "type": "record",<br/>  "fields": [<br/>    {<br/>      "doc": "The name of the sensor",<br/>      "name": "name",<br/>      "type": "string"<br/>    },<br/>    {<br/>      "doc": "The timestamp of the sensor reading",<br/>      "name": "timestamp",<br/>      "type": "long"<br/>    },<br/>    {<br/>      "doc": "The value of the sensor, represented as string",<br/>      "name": "value",<br/>      "type": "string"<br/>    },<br/>    {<br/>      "doc": "The type of the sensor",<br/>      "name": "type",<br/>      "type": {<br/>        "name": "SensorType",<br/>        "type": "enum",<br/>        "symbols": [<br/>          "AREA",<br/>          "HUMIDITY",<br/>          "LENGTH",<br/>          "STATE",<br/>          "TEMPERATURE"<br/>        ]<br/>      }<br/>    },<br/>    {<br/>      "doc": "The unit of the sensor",<br/>      "name": "unit",<br/>      "type": "string"<br/>    },<br/>    {<br/>      "doc": "The color of the sensor",<br/>      "name": "color",<br/>      "type": [<br/>        "null",<br/>        "string"<br/>      ],<br/>      "default": null<br/>    },<br/>    {<br/>      "doc": "The city of the sensor",<br/>      "name": "city",<br/>      "type": [<br/>        "null",<br/>        "string"<br/>      ],<br/>      "default": null<br/>    },<br/>    {<br/>      "doc": "The owner of the sensor",<br/>      "name": "owner",<br/>      "type": [<br/>        "null",<br/>        "string"<br/>      ],<br/>      "default": null<br/>    }<br/>  ]<br/>}</span></pre><p id="7d2d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们创建了一个生成器，它生成随机的测试数据并在主题上生成它。我们将省略这个生成器的细节，但是您可以假设它只是用从一个可能值列表中选取的随机值填充所有字段。</p><p id="0e67" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，没有任何进一步的延迟，让我们看看KSML如何允许我们处理这些数据。</p><h1 id="00c8" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">实践中的KSML</h1><p id="43ea" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated"><strong class="jp ir">例1。检查主题数据</strong></p><p id="b092" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第一个例子是我们检查特定主题的数据。定义如下:</p><pre class="km kn ko kp gt md me mf mg aw mh bi"><span id="01e2" class="mi ky iq me b gy mj mk l ml mm">streams:<br/>  - topic: ksml_sensordata_avro<br/>    keyType: string<br/>    valueType: avro:SensorData</span><span id="ccff" class="mi ky iq me b gy mn mk l ml mm">functions:<br/>  print_message:<br/>    type: forEach<br/>    code: "print('key='+(key if isinstance(key,str) else str(key))+', value='+(value if isinstance(value,str) else str(value)))"</span><span id="90e6" class="mi ky iq me b gy mn mk l ml mm">pipelines:<br/>  main:<br/>    from: ksml_sensordata_avro<br/>    forEach: print_message</span></pre><p id="128c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们一次一个元素地剖析这个定义。在定义处理逻辑之前，我们首先定义定义所使用的流。在这种情况下，我们定义了<code class="fe mo mp mq me b">ksml_sensordata_avro</code>，如上所述，它具有<code class="fe mo mp mq me b">string</code>键和<code class="fe mo mp mq me b">SensorData</code>值。</p><p id="db6f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来是处理逻辑可以使用的功能列表。这里我们只定义了一个函数<code class="fe mo mp mq me b">print_message</code>，它只是将消息的键和值打印到stdout。</p><p id="d523" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第三个元素<code class="fe mo mp mq me b">pipelines</code>定义了真正的处理逻辑。我们定义了一个名为<code class="fe mo mp mq me b">main</code>的管道，它从<code class="fe mo mp mq me b">ksml_sensordata_avro</code>获取消息，并将它们传递给<code class="fe mo mp mq me b">print_message</code>。</p><p id="fca6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">定义文件由KSML解析，并转换成Kafka Streams拓扑，如下<a class="ae ma" href="https://kafka.apache.org/27/javadoc/org/apache/kafka/streams/Topology.html#describe--" rel="noopener ugc nofollow" target="_blank">所述:</a></p><pre class="km kn ko kp gt md me mf mg aw mh bi"><span id="0d5a" class="mi ky iq me b gy mj mk l ml mm">Sub-topology: 0<br/>    Source: KSTREAM-SOURCE-0000000000 (topics: [ksml_sensordata_avro])<br/>      --&gt; KSTREAM-FOREACH-0000000001<br/>    Processor: KSTREAM-FOREACH-0000000001 (stores: [])<br/>      --&gt; none<br/>      &lt;-- KSTREAM-SOURCE-0000000000</span></pre><p id="282f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">生成的拓扑的输出如下所示:</p><pre class="km kn ko kp gt md me mf mg aw mh bi"><span id="aec0" class="mi ky iq me b gy mj mk l ml mm">key=sensor0, value={'owner': 'Evan', 'color': 'red', 'city': 'Xanten', '@type': 'io.axual.ksml.example.SensorData', 'type': 'AREA', 'unit': 'ft2', 'name': 'sensor0', 'value': '225', 'timestamp': 1620217832071L}<br/>key=sensor1, value={'owner': 'Charlie', 'color': 'red', 'city': 'Alkmaar', '@type': 'io.axual.ksml.example.SensorData', 'type': 'HUMIDITY', 'unit': '%', 'name': 'sensor1', 'value': '86', 'timestamp': 1620217833268L}<br/>key=sensor2, value={'owner': 'Dave', 'color': 'red', 'city': 'Alkmaar', '@type': 'io.axual.ksml.example.SensorData', 'type': 'HUMIDITY', 'unit': 'g/m3', 'name': 'sensor2', 'value': '89', 'timestamp': 1620217833269L}<br/>key=sensor3, value={'owner': 'Charlie', 'color': 'white', 'city': 'Amsterdam', '@type': 'io.axual.ksml.example.SensorData', 'type': 'LENGTH', 'unit': 'm', 'name': 'sensor3', 'value': '392', 'timestamp': 1620217833269L}<br/>key=sensor4, value={'owner': 'Dave', 'color': 'red', 'city': 'Xanten', '@type': 'io.axual.ksml.example.SensorData', 'type': 'LENGTH', 'unit': 'ft', 'name': 'sensor4', 'value': '459', 'timestamp': 1620217833270L}<br/>key=sensor5, value={'owner': 'Bob', 'color': 'red', 'city': 'Alkmaar', '@type': 'io.axual.ksml.example.SensorData', 'type': 'TEMPERATURE', 'unit': 'C', 'name': 'sensor5', 'value': '466', 'timestamp': 1620217833270L}<br/>key=sensor6, value={'owner': 'Dave', 'color': 'red', 'city': 'Amsterdam', '@type': 'io.axual.ksml.example.SensorData', 'type': 'HUMIDITY', 'unit': 'g/m3', 'name': 'sensor6', 'value': '37', 'timestamp': 1620217833270L}<br/>key=sensor7, value={'owner': 'Evan', 'color': 'red', 'city': 'Alkmaar', '@type': 'io.axual.ksml.example.SensorData', 'type': 'TEMPERATURE', 'unit': 'F', 'name': 'sensor7', 'value': '704', 'timestamp': 1620217833271L}<br/>key=sensor8, value={'owner': 'Dave', 'color': 'red', 'city': 'Leiden', '@type': 'io.axual.ksml.example.SensorData', 'type': 'STATE', 'unit': 'state', 'name': 'sensor8', 'value': 'on', 'timestamp': 1620217833271L}<br/>key=sensor9, value={'owner': 'Dave', 'color': 'black', 'city': 'Leiden', '@type': 'io.axual.ksml.example.SensorData', 'type': 'HUMIDITY', 'unit': 'g/m3', 'name': 'sensor9', 'value': '67', 'timestamp': 1620217833272L}<br/>key=sensor0, value={'owner': 'Evan', 'color': 'blue', 'city': 'Utrecht', '@type': 'io.axual.ksml.example.SensorData', 'type': 'TEMPERATURE', 'unit': 'F', 'name': 'sensor0', 'value': '2', 'timestamp': 1620217833272L}<br/>key=sensor1, value={'owner': 'Alice', 'color': 'black', 'city': 'Amsterdam', '@type': 'io.axual.ksml.example.SensorData', 'type': 'LENGTH', 'unit': 'm', 'name': 'sensor1', 'value': '126', 'timestamp': 1620217833272L}<br/>key=sensor2, value={'owner': 'Charlie', 'color': 'white', 'city': 'Xanten', '@type': 'io.axual.ksml.example.SensorData', 'type': 'HUMIDITY', 'unit': '%', 'name': 'sensor2', 'value': '58', 'timestamp': 1620217833273L}</span></pre><p id="afdb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如您所见，应用程序的输出正是我们在<code class="fe mo mp mq me b">print_message</code>函数中定义的内容，即主题中所有数据的转储。</p><p id="2d73" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">例二。将数据复制到另一个主题</strong></p><p id="d7d3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们可以看到主题上有什么数据，我们将开始操纵它的路由。在本例中，我们将未修改的数据复制到辅助主题:</p><pre class="km kn ko kp gt md me mf mg aw mh bi"><span id="28a4" class="mi ky iq me b gy mj mk l ml mm">streams:<br/>  - topic: ksml_sensordata_avro<br/>    keyType: string<br/>    valueType: avro:SensorData<br/>  - topic: ksml_sensordata_copy<br/>    keyType: string<br/>    valueType: avro:SensorData</span><span id="2acb" class="mi ky iq me b gy mn mk l ml mm">functions:<br/>  print_message:<br/>    type: forEach<br/>    code: "print('key='+(key if isinstance(key,str) else str(key))+', value='+(value if isinstance(value,str) else str(value)))"</span><span id="15ab" class="mi ky iq me b gy mn mk l ml mm">pipelines:<br/>  main:<br/>    from: ksml_sensordata_avro<br/>    via:<br/>      - type: peek<br/>        forEach: print_message<br/>    to: ksml_sensordata_copy</span></pre><p id="3aaf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以看到，在本例中，我们指定了第二个主题，作为所有消息复制到的目标主题。<code class="fe mo mp mq me b">print_message</code>功能不变，但是流水线确实发生了一些变化。这里引入两个新元素，分别是<code class="fe mo mp mq me b">via</code>和<code class="fe mo mp mq me b">to</code>。</p><p id="70e0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mo mp mq me b">via</code>标签允许用户定义对数据执行的一系列操作。在这种情况下，只有一个操作，即<code class="fe mo mp mq me b">peek</code>操作，它不修改任何数据，只是在stdout上输出数据作为副作用。</p><p id="dd24" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mo mp mq me b">to</code>操作是所谓的“下沉操作”。接收器操作总是管道中的最后一个。将管道传递给接收器操作后，管道的处理不再继续。注意，在上面的第一个例子中，<code class="fe mo mp mq me b">forEach</code>也是一个接收操作，而在这个例子中，我们通过将<code class="fe mo mp mq me b">print_message</code>函数作为参数传递给<code class="fe mo mp mq me b">peek</code>操作来获得相同的结果。</p><p id="ac04" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当KSML翻译这个定义时，会创建以下Kafka Streams拓扑:</p><pre class="km kn ko kp gt md me mf mg aw mh bi"><span id="9de3" class="mi ky iq me b gy mj mk l ml mm">Sub-topology: 0<br/>    Source: KSTREAM-SOURCE-0000000000 (topics: [ksml_sensordata_copy])<br/>      --&gt; none</span><span id="b727" class="mi ky iq me b gy mn mk l ml mm">  Sub-topology: 1<br/>    Source: KSTREAM-SOURCE-0000000001 (topics: [ksml_sensordata_avro])<br/>      --&gt; KSTREAM-PEEK-0000000002<br/>    Processor: KSTREAM-PEEK-0000000002 (stores: [])<br/>      --&gt; KSTREAM-SINK-0000000003<br/>      &lt;-- KSTREAM-SOURCE-0000000001<br/>    Sink: KSTREAM-SINK-0000000003 (topic: ksml_sensordata_copy)<br/>      &lt;-- KSTREAM-PEEK-0000000002</span></pre><p id="0e44" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">输出类似于示例1，但是现在在<code class="fe mo mp mq me b">ksml_sensordata_copy</code>主题上也可以找到相同的数据。</p><p id="8a1f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">例3。过滤数据</strong></p><p id="d714" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们可以读写数据了，让我们看看是否可以将一些逻辑应用到处理中。在本例中，我们将根据值的内容过滤数据:</p><pre class="km kn ko kp gt md me mf mg aw mh bi"><span id="1714" class="mi ky iq me b gy mj mk l ml mm">streams:<br/>  - topic: ksml_sensordata_avro<br/>    keyType: string<br/>    valueType: avro:SensorData<br/>  - topic: ksml_sensordata_filtered<br/>    keyType: string<br/>    valueType: avro:SensorData</span><span id="b537" class="mi ky iq me b gy mn mk l ml mm">functions:<br/>  print_message:<br/>    type: forEach<br/>    code: "print('key='+(key if isinstance(key,str) else str(key))+', value='+(value if isinstance(value,str) else str(value)))"</span><span id="9ceb" class="mi ky iq me b gy mn mk l ml mm">  filter_message:<br/>    type: predicate<br/>    expression: value['color'] == 'blue'</span><span id="8019" class="mi ky iq me b gy mn mk l ml mm">pipelines:<br/>  main:<br/>    from: ksml_sensordata_avro<br/>    via:<br/>      - type: filter<br/>        predicate: filter_message<br/>      - type: peek<br/>        forEach: print_message<br/>    to: ksml_sensordata_filtered</span></pre><p id="7bce" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">同样，首先我们定义处理中涉及的流和函数。您可以看到我们添加了一个名为<code class="fe mo mp mq me b">filter_message</code>的新函数，它根据消息值中的<code class="fe mo mp mq me b">color</code>字段返回<code class="fe mo mp mq me b">true</code>或<code class="fe mo mp mq me b">false</code>。这个函数在下面的管道中使用。</p><p id="5c19" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该流水线被扩展为包括一个<code class="fe mo mp mq me b">filter</code>操作，该操作将一个<code class="fe mo mp mq me b">predicate</code>函数作为参数。每个输入消息都会调用这个函数。只有函数返回<code class="fe mo mp mq me b">true</code>的消息才会被传播。所有其他消息都将被丢弃。</p><p id="78f1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用这个定义，KSML生成以下Kafka Streams拓扑:</p><pre class="km kn ko kp gt md me mf mg aw mh bi"><span id="9335" class="mi ky iq me b gy mj mk l ml mm">Sub-topology: 0<br/>    Source: KSTREAM-SOURCE-0000000000 (topics: [ksml_sensordata_avro])<br/>      --&gt; KSTREAM-FILTER-0000000002<br/>    Processor: KSTREAM-FILTER-0000000002 (stores: [])<br/>      --&gt; KSTREAM-PEEK-0000000003<br/>      &lt;-- KSTREAM-SOURCE-0000000000<br/>    Processor: KSTREAM-PEEK-0000000003 (stores: [])<br/>      --&gt; KSTREAM-SINK-0000000004<br/>      &lt;-- KSTREAM-FILTER-0000000002<br/>    Sink: KSTREAM-SINK-0000000004 (topic: ksml_sensordata_filtered)<br/>      &lt;-- KSTREAM-PEEK-0000000003</span><span id="e4ba" class="mi ky iq me b gy mn mk l ml mm">  Sub-topology: 1<br/>    Source: KSTREAM-SOURCE-0000000001 (topics: [ksml_sensordata_filtered])<br/>      --&gt; none</span></pre><p id="9d1f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当它执行时，我们会看到以下输出:</p><pre class="km kn ko kp gt md me mf mg aw mh bi"><span id="6f47" class="mi ky iq me b gy mj mk l ml mm">key=sensor0, value={'owner': 'Evan', 'color': 'blue', 'city': 'Utrecht', '@type': 'io.axual.ksml.example.SensorData', 'type': 'TEMPERATURE', 'unit': 'F', 'name': 'sensor0', 'value': '2', 'timestamp': 1620217833272L}<br/>key=sensor4, value={'owner': 'Bob', 'color': 'blue', 'city': 'Amsterdam', '@type': 'io.axual.ksml.example.SensorData', 'type': 'STATE', 'unit': 'state', 'name': 'sensor4', 'value': 'on', 'timestamp': 1620217833273L}<br/>key=sensor5, value={'owner': 'Bob', 'color': 'blue', 'city': 'Amsterdam', '@type': 'io.axual.ksml.example.SensorData', 'type': 'HUMIDITY', 'unit': '%', 'name': 'sensor5', 'value': '14', 'timestamp': 1620217833277L}<br/>key=sensor6, value={'owner': 'Charlie', 'color': 'blue', 'city': 'Alkmaar', '@type': 'io.axual.ksml.example.SensorData', 'type': 'STATE', 'unit': 'state', 'name': 'sensor6', 'value': 'off', 'timestamp': 1620217833278L}<br/>key=sensor7, value={'owner': 'Bob', 'color': 'blue', 'city': 'Utrecht', '@type': 'io.axual.ksml.example.SensorData', 'type': 'AREA', 'unit': 'ft2', 'name': 'sensor7', 'value': '292', 'timestamp': 1620217833278L}<br/>key=sensor4, value={'owner': 'Charlie', 'color': 'blue', 'city': 'Amsterdam', '@type': 'io.axual.ksml.example.SensorData', 'type': 'HUMIDITY', 'unit': '%', 'name': 'sensor4', 'value': '72', 'timestamp': 1620217833280L}<br/>key=sensor5, value={'owner': 'Evan', 'color': 'blue', 'city': 'Leiden', '@type': 'io.axual.ksml.example.SensorData', 'type': 'LENGTH', 'unit': 'm', 'name': 'sensor5', 'value': '876', 'timestamp': 1620217833281L}<br/>key=sensor8, value={'owner': 'Alice', 'color': 'blue', 'city': 'Utrecht', '@type': 'io.axual.ksml.example.SensorData', 'type': 'STATE', 'unit': 'state', 'name': 'sensor8', 'value': 'off', 'timestamp': 1620217833282L}<br/>key=sensor1, value={'owner': 'Evan', 'color': 'blue', 'city': 'Alkmaar', '@type': 'io.axual.ksml.example.SensorData', 'type': 'LENGTH', 'unit': 'm', 'name': 'sensor1', 'value': '952', 'timestamp': 1620217833282L}<br/>key=sensor2, value={'owner': 'Bob', 'color': 'blue', 'city': 'Leiden', '@type': 'io.axual.ksml.example.SensorData', 'type': 'TEMPERATURE', 'unit': 'F', 'name': 'sensor2', 'value': '602', 'timestamp': 1620217833286L}</span></pre><p id="0e91" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如您所见，过滤操作完成了它的工作。只有字段<code class="fe mo mp mq me b">color</code>设置为<code class="fe mo mp mq me b">blue</code>的消息被传递给<code class="fe mo mp mq me b">peek</code>操作，而其他消息被丢弃。</p><p id="d8b0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">例4。分支消息</strong></p><p id="db36" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">另一种过滤消息的方法是使用<code class="fe mo mp mq me b">branch</code>操作。这也是一个接收器操作，它关闭管道的处理。在这方面，它与<code class="fe mo mp mq me b">forEach</code>和<code class="fe mo mp mq me b">to</code>相似，但具有不同的定义和行为。</p><pre class="km kn ko kp gt md me mf mg aw mh bi"><span id="3f3e" class="mi ky iq me b gy mj mk l ml mm">streams:<br/>  - topic: ksml_sensordata_avro<br/>    keyType: string<br/>    valueType: avro:SensorData<br/>  - topic: ksml_sensordata_blue<br/>    keyType: string<br/>    valueType: avro:SensorData<br/>  - topic: ksml_sensordata_red<br/>    keyType: string<br/>    valueType: avro:SensorData</span><span id="0b53" class="mi ky iq me b gy mn mk l ml mm">functions:<br/>  print_message:<br/>    type: forEach<br/>    code: "print('key='+(key if isinstance(key,str) else str(key))+', value='+(value if isinstance(value,str) else str(value)))"</span><span id="3240" class="mi ky iq me b gy mn mk l ml mm">pipelines:<br/>  main:<br/>    from: ksml_sensordata_avro<br/>    via:<br/>      - type: peek<br/>        forEach: print_message<br/>    branch:<br/>      - if:<br/>          expression: value['color'] == 'blue'<br/>        to: ksml_sensordata_blue<br/>      - if:<br/>          expression: value['color'] == 'red'<br/>        to: ksml_sensordata_red<br/>      - forEach:<br/>          code: |<br/>            print('Unknown color sensor: '+str(value))</span></pre><p id="7b5e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mo mp mq me b">branch</code>操作将一个分支列表作为参数，每个分支指定一个自己的处理管道。分支包含关键字<code class="fe mo mp mq me b">if</code>，它采用一个谓词函数来确定消息是否将流入该特定分支，或者是否将被传递到下一个分支。每条消息将只在一个分支中结束，即第一个分支，其中<code class="fe mo mp mq me b">if</code>谓词函数返回<code class="fe mo mp mq me b">true</code>。</p><p id="b5d4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本例中，我们看到第一个分支将仅由<code class="fe mo mp mq me b">color</code>字段设置为<code class="fe mo mp mq me b">blue</code>的消息填充。一旦到达那里，这些消息将被写入<code class="fe mo mp mq me b">ksml_sensordata_blue</code>。第二个分支将只包含带有<code class="fe mo mp mq me b">color</code> = <code class="fe mo mp mq me b">red</code>的消息，这些消息将被写入<code class="fe mo mp mq me b">ksml_sensordata_red</code>。最后，最后一个分支输出颜色未知的消息，并结束任何进一步的处理。</p><p id="956b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">KSML将该定义转换为以下Kafka Streams拓扑:</p><pre class="km kn ko kp gt md me mf mg aw mh bi"><span id="8f43" class="mi ky iq me b gy mj mk l ml mm">Sub-topology: 0<br/>    Source: KSTREAM-SOURCE-0000000000 (topics: [ksml_sensordata_blue])<br/>      --&gt; none</span><span id="cad8" class="mi ky iq me b gy mn mk l ml mm">  Sub-topology: 1<br/>    Source: KSTREAM-SOURCE-0000000001 (topics: [ksml_sensordata_red])<br/>      --&gt; none</span><span id="7b38" class="mi ky iq me b gy mn mk l ml mm">  Sub-topology: 2<br/>    Source: KSTREAM-SOURCE-0000000002 (topics: [ksml_sensordata_avro])<br/>      --&gt; KSTREAM-PEEK-0000000003<br/>    Processor: KSTREAM-PEEK-0000000003 (stores: [])<br/>      --&gt; KSTREAM-BRANCH-0000000004<br/>      &lt;-- KSTREAM-SOURCE-0000000002<br/>    Processor: KSTREAM-BRANCH-0000000004 (stores: [])<br/>      --&gt; KSTREAM-BRANCHCHILD-0000000005, KSTREAM-BRANCHCHILD-0000000006, KSTREAM-BRANCHCHILD-0000000007<br/>      &lt;-- KSTREAM-PEEK-0000000003<br/>    Processor: KSTREAM-BRANCHCHILD-0000000005 (stores: [])<br/>      --&gt; KSTREAM-SINK-0000000008<br/>      &lt;-- KSTREAM-BRANCH-0000000004<br/>    Processor: KSTREAM-BRANCHCHILD-0000000006 (stores: [])<br/>      --&gt; KSTREAM-SINK-0000000009<br/>      &lt;-- KSTREAM-BRANCH-0000000004<br/>    Processor: KSTREAM-BRANCHCHILD-0000000007 (stores: [])<br/>      --&gt; KSTREAM-FOREACH-0000000010<br/>      &lt;-- KSTREAM-BRANCH-0000000004<br/>    Processor: KSTREAM-FOREACH-0000000010 (stores: [])<br/>      --&gt; none<br/>      &lt;-- KSTREAM-BRANCHCHILD-0000000007<br/>    Sink: KSTREAM-SINK-0000000008 (topic: ksml_sensordata_blue)<br/>      &lt;-- KSTREAM-BRANCHCHILD-0000000005<br/>    Sink: KSTREAM-SINK-0000000009 (topic: ksml_sensordata_red)<br/>      &lt;-- KSTREAM-BRANCHCHILD-0000000006</span></pre><p id="7c2c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">很明显，KSML在拓扑中集成了分支操作。它的输出如下所示:</p><pre class="km kn ko kp gt md me mf mg aw mh bi"><span id="b3a4" class="mi ky iq me b gy mj mk l ml mm">key=sensor0, value={'owner': 'Evan', 'color': 'red', 'city': 'Xanten', '@type': 'io.axual.ksml.example.SensorData', 'type': 'AREA', 'unit': 'ft2', 'name': 'sensor0', 'value': '225', 'timestamp': 1620217832071L}<br/>key=sensor1, value={'owner': 'Charlie', 'color': 'red', 'city': 'Alkmaar', '@type': 'io.axual.ksml.example.SensorData', 'type': 'HUMIDITY', 'unit': '%', 'name': 'sensor1', 'value': '86', 'timestamp': 1620217833268L}<br/>key=sensor2, value={'owner': 'Dave', 'color': 'red', 'city': 'Alkmaar', '@type': 'io.axual.ksml.example.SensorData', 'type': 'HUMIDITY', 'unit': 'g/m3', 'name': 'sensor2', 'value': '89', 'timestamp': 1620217833269L}<br/>key=sensor3, value={'owner': 'Charlie', 'color': 'white', 'city': 'Amsterdam', '@type': 'io.axual.ksml.example.SensorData', 'type': 'LENGTH', 'unit': 'm', 'name': 'sensor3', 'value': '392', 'timestamp': 1620217833269L}<br/>Unknown color sensor: {'owner': 'Charlie', 'color': 'white', 'city': 'Amsterdam', '@type': 'io.axual.ksml.example.SensorData', 'type': 'LENGTH', 'unit': 'm', 'name': 'sensor3', 'value': '392', 'timestamp': 1620217833269L}<br/>key=sensor4, value={'owner': 'Dave', 'color': 'red', 'city': 'Xanten', '@type': 'io.axual.ksml.example.SensorData', 'type': 'LENGTH', 'unit': 'ft', 'name': 'sensor4', 'value': '459', 'timestamp': 1620217833270L}<br/>key=sensor5, value={'owner': 'Bob', 'color': 'red', 'city': 'Alkmaar', '@type': 'io.axual.ksml.example.SensorData', 'type': 'TEMPERATURE', 'unit': 'C', 'name': 'sensor5', 'value': '466', 'timestamp': 1620217833270L}<br/>key=sensor6, value={'owner': 'Dave', 'color': 'red', 'city': 'Amsterdam', '@type': 'io.axual.ksml.example.SensorData', 'type': 'HUMIDITY', 'unit': 'g/m3', 'name': 'sensor6', 'value': '37', 'timestamp': 1620217833270L}<br/>key=sensor7, value={'owner': 'Evan', 'color': 'red', 'city': 'Alkmaar', '@type': 'io.axual.ksml.example.SensorData', 'type': 'TEMPERATURE', 'unit': 'F', 'name': 'sensor7', 'value': '704', 'timestamp': 1620217833271L}<br/>key=sensor8, value={'owner': 'Dave', 'color': 'red', 'city': 'Leiden', '@type': 'io.axual.ksml.example.SensorData', 'type': 'STATE', 'unit': 'state', 'name': 'sensor8', 'value': 'on', 'timestamp': 1620217833271L}<br/>key=sensor9, value={'owner': 'Dave', 'color': 'black', 'city': 'Leiden', '@type': 'io.axual.ksml.example.SensorData', 'type': 'HUMIDITY', 'unit': 'g/m3', 'name': 'sensor9', 'value': '67', 'timestamp': 1620217833272L}<br/>Unknown color sensor: {'owner': 'Dave', 'color': 'black', 'city': 'Leiden', '@type': 'io.axual.ksml.example.SensorData', 'type': 'HUMIDITY', 'unit': 'g/m3', 'name': 'sensor9', 'value': '67', 'timestamp': 1620217833272L}<br/>key=sensor0, value={'owner': 'Evan', 'color': 'blue', 'city': 'Utrecht', '@type': 'io.axual.ksml.example.SensorData', 'type': 'TEMPERATURE', 'unit': 'F', 'name': 'sensor0', 'value': '2', 'timestamp': 1620217833272L}<br/>key=sensor1, value={'owner': 'Alice', 'color': 'black', 'city': 'Amsterdam', '@type': 'io.axual.ksml.example.SensorData', 'type': 'LENGTH', 'unit': 'm', 'name': 'sensor1', 'value': '126', 'timestamp': 1620217833272L}<br/>Unknown color sensor: {'owner': 'Alice', 'color': 'black', 'city': 'Amsterdam', '@type': 'io.axual.ksml.example.SensorData', 'type': 'LENGTH', 'unit': 'm', 'name': 'sensor1', 'value': '126', 'timestamp': 1620217833272L}<br/>key=sensor2, value={'owner': 'Charlie', 'color': 'white', 'city': 'Xanten', '@type': 'io.axual.ksml.example.SensorData', 'type': 'HUMIDITY', 'unit': '%', 'name': 'sensor2', 'value': '58', 'timestamp': 1620217833273L}</span></pre><p id="836f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们看到管道处理的每条消息都是通过<code class="fe mo mp mq me b">print_message</code>函数发送的。但是分支操作对消息进行分类，并将带有颜色<code class="fe mo mp mq me b">blue</code>和<code class="fe mo mp mq me b">red</code>的消息发送到它们自己的分支中。显示为<code class="fe mo mp mq me b">Unknown color sensor</code>消息的颜色只有非蓝色和非红色。</p><p id="bd76" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> 5。动态路由</strong></p><p id="a59a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">作为本文的最后一个例子，我们将使用Kafka Streams的<a class="ae ma" href="https://kafka.apache.org/27/javadoc/index.html?org/apache/kafka/streams/processor/TopicNameExtractor.html" rel="noopener ugc nofollow" target="_blank"> TopicNameExtractor </a>动态路由消息。</p><pre class="km kn ko kp gt md me mf mg aw mh bi"><span id="2d82" class="mi ky iq me b gy mj mk l ml mm">streams:<br/>  - topic: ksml_sensordata_avro<br/>    keyType: string<br/>    valueType: avro:SensorData<br/>  - topic: ksml_sensordata_sensor0<br/>    keyType: string<br/>    valueType: avro:SensorData<br/>  - topic: ksml_sensordata_sensor1<br/>    keyType: string<br/>    valueType: avro:SensorData<br/>  - topic: ksml_sensordata_sensor2<br/>    keyType: string<br/>    valueType: avro:SensorData</span><span id="3014" class="mi ky iq me b gy mn mk l ml mm">functions:<br/>  print_message:<br/>    type: forEach<br/>    code: "print('key='+(key if isinstance(key,str) else str(key))+', value='+(value if isinstance(value,str) else str(value)))"</span><span id="4c08" class="mi ky iq me b gy mn mk l ml mm">pipelines:<br/>  main:<br/>    from: ksml_sensordata_avro<br/>    via:<br/>      - type: peek<br/>        forEach: print_message<br/>    toExtractor:<br/>      code: |<br/>        if key == 'sensor1':<br/>          return 'ksml_sensordata_sensor1'<br/>        elif key == 'sensor2':<br/>          return 'ksml_sensordata_sensor2'<br/>        else:<br/>          return 'ksml_sensordata_sensor0'</span></pre><p id="ccd4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mo mp mq me b">toExtractor</code>操作采用一个函数，该函数通过返回一个主题名称字符串来确定每条消息的路由。在这种情况下，当消息的关键字是<code class="fe mo mp mq me b">sensor1</code>时，该消息将被发送到<code class="fe mo mp mq me b">ksml_sensordata_sensor1</code>。当它包含<code class="fe mo mp mq me b">sensor2</code>时，消息被发送到<code class="fe mo mp mq me b">ksml_sensordata_sensor2</code>。所有其他消息都发送到<code class="fe mo mp mq me b">ksml_sensordata_sensor0</code>。</p><p id="f777" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">等效的Kafka Streams拓扑如下所示:</p><pre class="km kn ko kp gt md me mf mg aw mh bi"><span id="5493" class="mi ky iq me b gy mj mk l ml mm">Sub-topology: 0<br/>    Source: KSTREAM-SOURCE-0000000000 (topics: [ksml_sensordata_sensor0])<br/>      --&gt; none</span><span id="eb37" class="mi ky iq me b gy mn mk l ml mm">  Sub-topology: 1<br/>    Source: KSTREAM-SOURCE-0000000001 (topics: [ksml_sensordata_avro])<br/>      --&gt; KSTREAM-PEEK-0000000004<br/>    Processor: KSTREAM-PEEK-0000000004 (stores: [])<br/>      --&gt; KSTREAM-SINK-0000000005<br/>      &lt;-- KSTREAM-SOURCE-0000000001<br/>    Sink: KSTREAM-SINK-0000000005 (extractor class: io.axual.ksml.user.UserTopicNameExtractor@713529c2)<br/>      &lt;-- KSTREAM-PEEK-0000000004</span><span id="fba3" class="mi ky iq me b gy mn mk l ml mm">  Sub-topology: 2<br/>    Source: KSTREAM-SOURCE-0000000002 (topics: [ksml_sensordata_sensor2])<br/>      --&gt; none</span><span id="5cfa" class="mi ky iq me b gy mn mk l ml mm">  Sub-topology: 3<br/>    Source: KSTREAM-SOURCE-0000000003 (topics: [ksml_sensordata_sensor1])<br/>      --&gt; none</span></pre><p id="3b50" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">输出也没什么特别的，因为它只显示所有消息。</p><h1 id="845f" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">当前状态</h1><p id="e09f" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">看过这些例子后，我希望我能激发你的兴趣。所以了解项目的现状是有好处的。</p><p id="1663" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将KSML发布为版本0.0.1，这表明人们应该将它视为技术预览版(或alpha)软件，而不是在生产中使用它。写这篇文章的原因是我们认为有可能围绕KSML形成一个新的社区。我们希望其他人的输入和观点能极大地有利于语言的状态和实现，所以我们希望尽早利用你们的集体热情。</p><p id="74a3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">KSML的状态已经比我们在这里展示的要先进得多。在本文中，我们只涉及了目前支持的最简单的操作。0.0.1版本已经支持几乎所有Kafka Streams操作，尽管还没有完全测试。在数据类型方面，我们支持所有基本类型(字符串、整数、布尔等)，基本的Avro处理(通过Python字典)，并将很快引入Json支持。这使得KSML已经能够处理简单的流处理逻辑。</p><h1 id="b6f9" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">后续步骤</h1><p id="00bc" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">在不久的将来，我们预计围绕KSML有三个主要活动:</p><ul class=""><li id="43a4" class="mr ms iq jp b jq jr ju jv jy mt kc mu kg mv kk mw mx my mz bi translated"><strong class="jp ir">测试，测试，测试</strong>:我们已经测试了相当多的处理逻辑，但是为了达到第一个alpha版本而进行的内部重构可能会引入一些我们在这个阶段忽略的错误。因此，我们欢迎每个人尝试一下，并提出发现、建议和改进。</li><li id="516d" class="mr ms iq jp b jq na ju nb jy nc kc nd kg ne kk mw mx my mz bi translated"><strong class="jp ir">建立社区</strong>:通过这篇文章和一些演示，我们希望得到你对这个想法的真实反馈。它对你和你的用例有价值吗？您希望如何运行这些类型的处理管道？作为一个库，一个Docker映像或者一个通用的处理容器(比如Kafka Connect)提供了什么？</li><li id="8793" class="mr ms iq jp b jq na ju nb jy nc kc nd kg ne kk mw mx my mz bi translated"><strong class="jp ir">致力于测试版的发布</strong>:我们知道当前的代码非常alpha化。单元测试和集成测试严重缺乏，但是我们在这个阶段没有关注这些，因为在这个阶段发现概念的有用性比优雅的代码更重要。但是当然，当我们发展KSML语言、它的类型模型和它的实现时，代码质量需要认真关注。</li></ul><p id="1b2a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果这篇文章引起了你的兴趣，请随时试驾，让我们听听你的经历。可以在<a class="ae ma" href="https://ksml.io/" rel="noopener ugc nofollow" target="_blank"> https://ksml.io </a>找到主网站。代码托管在<a class="ae ma" href="https://github.com/Axual/ksml" rel="noopener ugc nofollow" target="_blank">https://github.com/Axual/ksml</a>。</p><h1 id="558e" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">关于作者</h1><p id="8735" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">耶鲁安·范·迪塞尔多普是Axual公司的首席执行官和创始人，该公司为企业提供现成的Apache Kafka发行版。他在系统开发和架构方面有广泛的背景。在加入Axual之前，耶鲁安是凯捷的首席顾问，也是开源软件的全球思想领袖。</p></div></div>    
</body>
</html>