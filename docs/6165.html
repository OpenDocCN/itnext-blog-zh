<html>
<head>
<title>C++20 Modules — Complete Guide</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C++20模块—完整指南</h1>
<blockquote>原文：<a href="https://itnext.io/c-20-modules-complete-guide-ae741ddbae3d?source=collection_archive---------1-----------------------#2021-09-06">https://itnext.io/c-20-modules-complete-guide-ae741ddbae3d?source=collection_archive---------1-----------------------#2021-09-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="f2af" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">编译器和构建系统慢慢开始支持C++20模块。这是您阅读本指南并从大规模编译加速中获益的绝佳时机。本文反映的是截至2021年9月的状态。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/ba0063d910f7ca2622b553fd3e7c9695.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d2iajdrbl-Cnrxuc9yF4Vg.png"/></div></div></figure><h2 id="090a" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">你好世界</h2><p id="88f9" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">首先，稍微提醒一下头文件在C++中是如何工作的。当您编写<code class="fe lv lw lx ly b">#include "header.h"</code>时，预处理器实际上将复制粘贴<code class="fe lv lw lx ly b">header.h</code>的已处理内容来代替include。这确实涉及到扩展任何递归包含，因此您可以很容易地从一个简单的包含中获得数兆字节的文本。例如，对于一个简单的hello world，我们最终得到了几乎2MB的文本。</p><pre class="km kn ko kp gt lz ly ma mb aw mc bi"><span id="f27e" class="kx ky iq ly b gy md me l mf mg"><strong class="ly ir">&gt; cat hello_world.cc</strong><br/>#include &lt;iostream&gt;</span><span id="4b22" class="kx ky iq ly b gy mh me l mf mg">int main() {<br/>    std::cout &lt;&lt; "Hello World!\n";<br/>}</span><span id="53b5" class="kx ky iq ly b gy mh me l mf mg"><strong class="ly ir">&gt; clang++ -std=c++20 -stdlib=libc++ -E hello_world.cc | wc -c</strong><br/>1956614</span></pre><p id="cd1e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这已经是个问题了，但是考虑到编译器会对项目中的每个实现文件都这样做。处理普通包括多次。各种供应商已经认识到这种浪费，并提供了使用预编译头文件的非标准解决方案，其中一组公共头文件被处理一次，然后被包括在任何地方。</p><p id="b12c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">模块的目标是解决同样的问题，但是以标准的方式。让我们再来看看hello world，但现在是模块:</p><pre class="km kn ko kp gt lz ly ma mb aw mc bi"><span id="d6d4" class="kx ky iq ly b gy md me l mf mg"><strong class="ly ir">&gt; cat hello_modular_world.cc</strong><br/>import &lt;iostream&gt;;</span><span id="0e41" class="kx ky iq ly b gy mh me l mf mg">int main() {<br/>    std::cout &lt;&lt; "Hello Modular World!\n";<br/>}</span><span id="2356" class="kx ky iq ly b gy mh me l mf mg"><strong class="ly ir">&gt; clang++ -std=c++20 -stdlib=libc++ -fmodules -fbuiltin-module-map \<br/>          -E hello_modular_world.cc | wc -c</strong><br/>239</span></pre><p id="2b35" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这也是通过转换到模块节省时间的一个极端例子:</p><pre class="km kn ko kp gt lz ly ma mb aw mc bi"><span id="b42c" class="kx ky iq ly b gy md me l mf mg"><strong class="ly ir">&gt; time clang++ -std=c++20 -stdlib=libc++ hello_world.cc</strong></span><span id="2849" class="kx ky iq ly b gy mh me l mf mg">real 0m0.639s<br/>user 0m0.584s<br/>sys 0m0.058s</span><span id="2788" class="kx ky iq ly b gy mh me l mf mg"><strong class="ly ir">&gt; time clang++ -std=c++20 -stdlib=libc++ -fmodules \<br/>               -fbuiltin-module-map hello_modular_world.cc</strong></span><span id="69c3" class="kx ky iq ly b gy mh me l mf mg">real 0m0.087s<br/>user 0m0.052s<br/>sys 0m0.037s</span></pre><p id="276b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">而Clang附带了标准头文件到模块的映射。使用GCC，我们需要手动编译<code class="fe lv lw lx ly b">iostream</code>。</p><pre class="km kn ko kp gt lz ly ma mb aw mc bi"><span id="8c43" class="kx ky iq ly b gy md me l mf mg"><strong class="ly ir">&gt; g++ -std=c++20 -fmodules-ts -xc++-system-header iostream<br/>&gt; g++ -std=c++20 -fmodules-ts hello_modular_world.cc</strong></span></pre><h2 id="3d7d" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">编写模块</h2><p id="b1eb" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">所以我们已经可以使用标准的头作为模块。现在让我们来看看如何编写自己的模块。和C++一样，它的语言特性非常广泛，并且是非规定性的。</p><p id="f512" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每个模块必须有一个导出该模块的文件。该文件被命名为<em class="mi">模块接口单元</em>。模块与名称空间完全正交，所以没有什么可以阻止您将符号导出到全局名称空间(就像这里的<code class="fe lv lw lx ly b">plus</code>函数)或者作为名称空间的一部分导出(就像这里的<code class="fe lv lw lx ly b">minus</code>函数)。</p><pre class="km kn ko kp gt lz ly ma mb aw mc bi"><span id="d753" class="kx ky iq ly b gy md me l mf mg"><strong class="ly ir">&gt; cat advanced_mathematics.cc</strong><br/>export module AdvancedMathematics;</span><span id="d7ea" class="kx ky iq ly b gy mh me l mf mg">export auto plus(auto x, auto y) -&gt; decltype(x+y) {<br/>    return x + y;<br/>}</span><span id="8ca1" class="kx ky iq ly b gy mh me l mf mg">export namespace AdvancedMathematics {<br/>    auto minus(auto x, auto y) -&gt; decltype(x-y) {<br/>        return x - y;  <br/>    }   <br/>}</span><span id="d2a5" class="kx ky iq ly b gy mh me l mf mg">void this_function_will_not_be_exported() {}</span><span id="2984" class="kx ky iq ly b gy mh me l mf mg"><strong class="ly ir">&gt; cat main.cc</strong><br/>import &lt;iostream&gt;;<br/>import AdvancedMathematics;</span><span id="29db" class="kx ky iq ly b gy mh me l mf mg">int main() {<br/>    std::cout &lt;&lt; "1+2 = " &lt;&lt;  plus(1,2) &lt;&lt; "\n";<br/>    std::cout &lt;&lt; "3-2 = " &lt;&lt; AdvancedMathematics::minus(3,2) <br/>              &lt;&lt; "\n";<br/>}</span></pre><p id="2941" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">未导出的符号具有私有可见性，这与正常的C++行为相反，在正常的c++行为中，只有匿名命名空间中的符号是未导出的。</p><p id="9916" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">用GCC编译这个例子相当简单。GCC在构建模块接口单元时会自动发出一个预编译的模块。Clangs实现仍然缺乏，<code class="fe lv lw lx ly b">clang++</code>接口没有公开用于发出预编译模块的标志，所以我们需要使用<code class="fe lv lw lx ly b">-Xclang</code>将<code class="fe lv lw lx ly b">-emit-module-interface</code>直接传递给clang编译器模块。对于更多的例子，我将坚持使用GCC。</p><pre class="km kn ko kp gt lz ly ma mb aw mc bi"><span id="230e" class="kx ky iq ly b gy md me l mf mg"># Compiling with GCC<br/><strong class="ly ir">&gt; g++ -std=c++20 -fmodules-ts -xc++-system-header iostream<br/>&gt; g++ -std=c++20 -fmodules-ts -c advanced_mathematics.cc<br/>&gt; g++ -std=c++20 -fmodules-ts -c main.cc<br/>&gt; g++ -std=c++20 main.o advanced_mathematics.o -o main</strong></span><span id="cba3" class="kx ky iq ly b gy mh me l mf mg"># Compiling with Clang<br/><strong class="ly ir">&gt; FLAGS="-std=c++20 -stdlib=libc++ -fmodules -fbuiltin-module-map"<br/>&gt; clang++ $FLAGS -fmodules-ts -Xclang -emit-module-interface -c advanced_mathematics.cc -o AdvancedMathematics.pcm<br/>&gt; clang++ $FLAGS -c advanced_mathematics.cc<br/>&gt; clang++ $FLAGS -fprebuilt-module-path=. -c main.cc<br/>&gt; clang++ $FLAGS main.o advanced_mathematics.o -o main</strong></span><span id="d514" class="kx ky iq ly b gy mh me l mf mg"><strong class="ly ir">&gt; ./main</strong><br/>1+2 = 3<br/>3-2 = 1</span></pre><p id="ff59" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果需要，一个模块可以分布在多个文件中——多个<em class="mi">模块单元。</em>但是，这些文件中只有一个可以导出模块(并且是<em class="mi">模块接口单元</em>)。</p><pre class="km kn ko kp gt lz ly ma mb aw mc bi"><span id="dbbe" class="kx ky iq ly b gy md me l mf mg"><strong class="ly ir">&gt; cat spreadables.cc</strong><br/>export module Spreadables;</span><span id="50a5" class="kx ky iq ly b gy mh me l mf mg">import &lt;string&gt;;</span><span id="93a6" class="kx ky iq ly b gy mh me l mf mg">export {<br/>    std::string butter();<br/>    std::string jam();<br/>}</span><span id="31de" class="kx ky iq ly b gy mh me l mf mg"><strong class="ly ir">&gt; cat butter.cc</strong><br/>module Spreadables;</span><span id="8578" class="kx ky iq ly b gy mh me l mf mg">import &lt;string&gt;;</span><span id="064f" class="kx ky iq ly b gy mh me l mf mg">std::string butter() {<br/>    return "Spreading some butter.";<br/>}</span><span id="5bb7" class="kx ky iq ly b gy mh me l mf mg"><strong class="ly ir">&gt; cat jam.cc</strong><br/>module Spreadables;</span><span id="39de" class="kx ky iq ly b gy mh me l mf mg">import &lt;string&gt;;</span><span id="45e7" class="kx ky iq ly b gy mh me l mf mg">std::string jam() {<br/>    return "Spreading some jam.";<br/>}</span><span id="762e" class="kx ky iq ly b gy mh me l mf mg"><strong class="ly ir">&gt; cat bread.cc</strong><br/>import &lt;iostream&gt;;</span><span id="a828" class="kx ky iq ly b gy mh me l mf mg">import Spreadables;</span><span id="3352" class="kx ky iq ly b gy mh me l mf mg">int main() {<br/>    std::cout &lt;&lt; "Taking some bread.\n";<br/>    std::cout &lt;&lt; butter() &lt;&lt; "\n";<br/>    std::cout &lt;&lt; jam() &lt;&lt; "\n";<br/>}</span></pre><p id="67ae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以这种方式使用模块反映了如何使用头文件和实现文件，除了需要编译模块接口单元来生成预编译模块。</p><pre class="km kn ko kp gt lz ly ma mb aw mc bi"><span id="5747" class="kx ky iq ly b gy md me l mf mg"><strong class="ly ir">&gt; g++ -std=c++20 -fmodules-ts -xc++-system-header iostream<br/>&gt; g++ -std=c++20 -fmodules-ts -xc++-system-header string</strong></span><span id="5949" class="kx ky iq ly b gy mh me l mf mg"><strong class="ly ir">&gt; g++ -std=c++20 -fmodules-ts -c spreadables.cc<br/>&gt; g++ -std=c++20 -fmodules-ts -c jam.cc<br/>&gt; g++ -std=c++20 -fmodules-ts -c butter.cc<br/>&gt; g++ -std=c++20 -fmodules-ts -c bread.cc<br/>&gt; g++ -std=c++20 bread.o spreadables.o jam.o butter.o -o bread</strong></span><span id="8368" class="kx ky iq ly b gy mh me l mf mg"><strong class="ly ir">&gt; ./bread<br/></strong>Taking some bread.<br/>Spreading some butter.<br/>Spreading some jam.</span></pre><h2 id="8863" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">模块分区</h2><p id="5135" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">将一个模块分布到多个文件的另一种方法是模块分区(目前Clang不支持)。分区只能由主模块访问，必须是单个单元(单个文件)，但可以是接口单元(导出符号)或只是一个单元。但是，如果分区是一个模块接口单元，它必须在主模块<code class="fe lv lw lx ly b">export import :partition;</code>中重新导出。主模块将可以访问所有分区符号，即使它们没有被标记为导出。</p><pre class="km kn ko kp gt lz ly ma mb aw mc bi"><span id="2b63" class="kx ky iq ly b gy md me l mf mg"><strong class="ly ir">&gt; cat main_internal.cc</strong><br/>// This file is module unit for a partition internal of module main<br/>module main:internal;</span><span id="1745" class="kx ky iq ly b gy mh me l mf mg">void internal_function() {} // will be visible in main module</span><span id="7c8f" class="kx ky iq ly b gy mh me l mf mg"><strong class="ly ir">&gt; cat main_base.cc<br/></strong>// This file is module interface unit for a partition base<br/>// of module main<br/>export module main:base; // this must be re-exported</span><span id="6773" class="kx ky iq ly b gy mh me l mf mg">export void visible() {} // will be visible to users of main<br/>void internal_base() {} // will be visible to main module only</span><span id="66ac" class="kx ky iq ly b gy mh me l mf mg"><strong class="ly ir">&gt; cat main.cc</strong><br/>// This file is module interface unit for module main<br/>export module main;<br/>// Import partition internal, cannot be re-exported<br/>import :internal;<br/>// Import partition base and re-export its exported symbols<br/>export import :base;</span></pre><h2 id="5bcc" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">编译时结构与模块</h2><p id="0b94" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">您可以在模块接口或模块分区内的任何地方使用编译时构造(templates、auto、decltype、constexpr、consteval)。</p><pre class="km kn ko kp gt lz ly ma mb aw mc bi"><span id="d6b8" class="kx ky iq ly b gy md me l mf mg"><strong class="ly ir">&gt; cat main_internal.cc<br/></strong>module main:internal;</span><span id="af8d" class="kx ky iq ly b gy mh me l mf mg">template &lt;typename T&gt;<br/>T identity(T x) { return x; }</span><span id="2313" class="kx ky iq ly b gy mh me l mf mg"><strong class="ly ir">&gt; cat main.cc<br/></strong>export module main;<br/>import :internal;</span><span id="c242" class="kx ky iq ly b gy mh me l mf mg">void function() {<br/>    if (identity(3) != 3) abort();<br/>}</span></pre><p id="93c1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，当使用多文件模块时，只有模块接口单元对预编译模块有贡献。因此，所有编译时构造都需要放在接口文件中。</p><h2 id="fc45" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">处理遗留标头</h2><p id="4796" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">如果您不能简单地导入您的遗留头文件(特别是在使用特性宏时)，您仍然可以在全局模块片段部分使用它们。</p><pre class="km kn ko kp gt lz ly ma mb aw mc bi"><span id="c0a1" class="kx ky iq ly b gy md me l mf mg">module; // start of global module fragment</span><span id="409a" class="kx ky iq ly b gy mh me l mf mg">#define _POSIX_C_SOURCE 200809L<br/>#include &lt;stdlib.h&gt;</span><span id="4d69" class="kx ky iq ly b gy mh me l mf mg">export module MyModule;</span><span id="0785" class="kx ky iq ly b gy mh me l mf mg">// etc...</span></pre><h2 id="2249" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">风格推荐</h2><p id="85ac" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">现在是这篇文章中更主观的部分。以下是我的两条建议，我认为作为一种风格来遵循是有意义的。</p><p id="c096" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，关于名称空间。模块名可以包含没有任何语义意义的<code class="fe lv lw lx ly b">.</code>符号。这允许我们构造命名来匹配嵌套的名称空间。因此，我的建议是按如下方式构造模块的命名和导出:</p><pre class="km kn ko kp gt lz ly ma mb aw mc bi"><span id="5e15" class="kx ky iq ly b gy md me l mf mg">export module my.nested.named.module;</span><span id="2295" class="kx ky iq ly b gy mh me l mf mg">export namespace my::nested::named::module {<br/>    // exported content of the module<br/>}</span></pre><p id="715d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">其次，关于多文件模块。多文件模块有两种支持方式。首先，简单地通过具有多个模块单元，其次通过具有模块分区。我的建议如下:</p><ol class=""><li id="f457" class="mj mk iq jp b jq jr ju jv jy ml kc mm kg mn kk mo mp mq mr bi translated">如果可能的话，每个模块一个文件。</li><li id="f4a7" class="mj mk iq jp b jq ms ju mt jy mu kc mv kg mw kk mo mp mq mr bi translated">如果多个文件有益于代码可读性，明智地利用模块分区(分离逻辑上相关的功能)。</li></ol><h2 id="8a19" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">链接和技术说明</h2><p id="5de3" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">所有的例子都使用GCC和Clang(2021年9月)的主干版本进行了演示。</p><p id="d1a1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所有代码示例和脚本都可以在https://github.com/HappyCerberus/article-cpp20-modules的<a class="ae mx" href="https://github.com/HappyCerberus/article-cpp20-modules" rel="noopener ugc nofollow" target="_blank">获得。</a></p><h1 id="a019" class="my ky iq bd kz mz na nb lc nc nd ne lf nf ng nh li ni nj nk ll nl nm nn lo no bi translated">感谢您的阅读</h1><p id="c79a" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">感谢您阅读这篇文章。你喜欢吗？</p><p id="532a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我还在YouTube<a class="ae mx" href="https://youtube.com/c/simontoth" rel="noopener ugc nofollow" target="_blank">youtube.com/c/simontoth</a>上发布视频，如果你想聊天，可以在Twitter <a class="ae mx" href="https://twitter.com/SimonToth83" rel="noopener ugc nofollow" target="_blank"> @SimonToth83 </a>或LinkedIn<a class="ae mx" href="https://www.linkedin.com/in/simontoth" rel="noopener ugc nofollow" target="_blank">linkedin.com/in/simontoth</a>上联系我。</p></div></div>    
</body>
</html>