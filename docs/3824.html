<html>
<head>
<title>Symfony Messenger worker on Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes上的Symfony信使工作者</h1>
<blockquote>原文：<a href="https://itnext.io/symfony-messenger-worker-on-kubernetes-77f75725b5ed?source=collection_archive---------0-----------------------#2020-03-04">https://itnext.io/symfony-messenger-worker-on-kubernetes-77f75725b5ed?source=collection_archive---------0-----------------------#2020-03-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b002" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何在Kubernetes上正确运行Symfony Messenger Worker而不在消息处理过程中被杀死</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b5acf4066bc00cd02488ee189f44f02b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l0UPrDazPCn1ja11sdA5fQ.png"/></div></div></figure><h2 id="18bf" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">零件箱生命周期</h2><ol class=""><li id="72c7" class="lq lr it ls b lt lu lv lw ld lx lh ly ll lz ma mb mc md me bi translated"><a class="ae mf" rel="noopener ugc nofollow" target="_blank" href="/k8s-prevent-queue-worker-pod-from-being-killed-during-deployment-4252ea7c13f6?source=friends_link&amp;sk=7abba2425e2f8b77ff932b1ceb55a7a7">防止队列工人吊舱在部署过程中被杀死</a></li><li id="6901" class="lq lr it ls b lt mg lv mh ld mi lh mj ll mk ma mb mc md me bi translated">(本文)</li></ol><h2 id="19ee" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">零件Symfony</h2><ol class=""><li id="e177" class="lq lr it ls b lt lu lv lw ld lx lh ly ll lz ma mb mc md me bi translated"><a class="ae mf" href="https://medium.com/@wuestkamp/say-yes-to-the-symfony4-messenger-queue-f6a4fe16ee4?source=friends_link&amp;sk=8d731ddaa5ed22067b12e3be8b2143f1" rel="noopener">答应Symfony4的信使</a></li><li id="bd19" class="lq lr it ls b lt mg lv mh ld mi lh mj ll mk ma mb mc md me bi translated"><a class="ae mf" href="https://medium.com/@wuestkamp/unit-functional-test-the-symfony4-messenger-9eef328dce8?source=friends_link&amp;sk=0619aa9ae17a0f405ed9fb4cf99d4d88" rel="noopener">symfony 4 Messenger的单元+功能测试</a></li><li id="d43c" class="lq lr it ls b lt mg lv mh ld mi lh mj ll mk ma mb mc md me bi translated">(本文)</li></ol><h2 id="d890" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">我们将讨论什么？</h2><p id="5679" class="pw-post-body-paragraph ml mm it ls b lt lu ju mn lv lw jx mo ld mp mq mr lh ms mt mu ll mv mw mx ma im bi translated">Symfony Messenger很棒，正如第一部分<a class="ae mf" href="https://medium.com/@wuestkamp/say-yes-to-the-symfony4-messenger-queue-f6a4fe16ee4?source=friends_link&amp;sk=8d731ddaa5ed22067b12e3be8b2143f1" rel="noopener">中描述的那样。但是，如果您想在Kubernetes上以Pods的形式运行worker进程呢？</a></p><h2 id="a629" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">有什么问题？</h2><p id="5b0e" class="pw-post-body-paragraph ml mm it ls b lt lu ju mn lv lw jx mo ld mp mq mr lh ms mt mu ll mv mw mx ma im bi translated">Kubernetes上的豆荚/应用被认为是短暂的/可替换的。这意味着在任何时候，比如在一个新的应用程序版本的部署过程中，Pods可以被终止，而其他的Pods可以被启动。这是Kubernetes部署资源自带的一个很棒的特性。</p><p id="698b" class="pw-post-body-paragraph ml mm it ls b lt my ju mn lv mz jx mo ld na mq mr lh nb mt mu ll nc mw mx ma im bi translated">但是如果您更新了您的Symfony worker映像并部署它会怎么样呢？正确，你所有的工人舱都会被杀死，不管他们是否正在处理信息。</p><h2 id="f109" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">TL；速度三角形定位法(dead reckoning)</h2><p id="5afd" class="pw-post-body-paragraph ml mm it ls b lt lu ju mn lv lw jx mo ld mp mq mr lh ms mt mu ll mv mw mx ma im bi translated">我们可以挂钩到Kubernetes Pod生命周期事件，以防止工人Pod在处理消息时被杀死。</p><p id="152a" class="pw-post-body-paragraph ml mm it ls b lt my ju mn lv mz jx mo ld na mq mr lh nb mt mu ll nc mw mx ma im bi translated">将terminationGracePeriodSeconds设置为工作进程处理您的消息所需的最长时间，甚至可以更长一些。这里最好保守一点。然后，一旦不再有消息被处理，就通过挂钩生命周期事件来控制更早的删除。</p><h1 id="4011" class="nd kv it bd kw ne nf ng kz nh ni nj lc jz nk ka lg kc nl kd lk kf nm kg lo nn bi translated">Pod生命周期</h1><p id="2925" class="pw-post-body-paragraph ml mm it ls b lt lu ju mn lv lw jx mo ld mp mq mr lh ms mt mu ll mv mw mx ma im bi translated">如果一个吊舱被杀死，手动通过<code class="fe no np nq nr b">kubectl</code>或任何k8s控制器，像在部署期间，它将立即从运行状态变为终止状态。同时，SIGTERM信号将被发送到该容器内的所有容器。</p><h2 id="1bc2" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">处于终止状态的Pod</h2><p id="7716" class="pw-post-body-paragraph ml mm it ls b lt lu ju mn lv lw jx mo ld mp mq mr lh ms mt mu ll mv mw mx ma im bi translated">当Pod处于终止状态时，它仍然像以前一样被调度，并使用相同的资源(CPU/内存)。但是没有新的请求被k8s服务重定向到终结点。在终止状态下，Pod可以并且应该正确地自行关闭。</p><p id="0ee2" class="pw-post-body-paragraph ml mm it ls b lt my ju mn lv mz jx mo ld na mq mr lh nb mt mu ll nc mw mx ma im bi translated">当处于终止状态时，如果容器结束，容器不会重新启动。每当Pod内的容器在运行状态下停止时，该容器就会重新启动。这样做是因为除非发生错误，否则Pod应该一直运行。</p><p id="9c25" class="pw-post-body-paragraph ml mm it ls b lt my ju mn lv mz jx mo ld na mq mr lh nb mt mu ll nc mw mx ma im bi translated">Pod停留在终止状态的最长时间为terminationGracePeriodSeconds设置的时间，默认情况下为30秒。如果所有Pod的容器都自行结束，则可以提前离开终止状态。一旦Pod离开终止状态，它将被移除并取消计划。</p><h2 id="3ab7" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">关于Pod生命周期的更多信息</h2><p id="2a1e" class="pw-post-body-paragraph ml mm it ls b lt lu ju mn lv lw jx mo ld mp mq mr lh ms mt mu ll mv mw mx ma im bi translated">如果您想了解本文中提供的示例YAML声明的更多背景信息，请查看<a class="ae mf" rel="noopener ugc nofollow" target="_blank" href="/k8s-prevent-queue-worker-pod-from-being-killed-during-deployment-4252ea7c13f6?source=friends_link&amp;sk=7abba2425e2f8b77ff932b1ceb55a7a7">我的文章，此处的</a>通过更一般的示例提供了一些简单的解释。</p><h1 id="3ee0" class="nd kv it bd kw ne nf ng kz nh ni nj lc jz nk ka lg kc nl kd lk kf nm kg lo nn bi translated">员工Pod示例</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="2c95" class="pw-post-body-paragraph ml mm it ls b lt my ju mn lv mz jx mo ld na mq mr lh nb mt mu ll nc mw mx ma im bi translated">在本例中，我们运行了Symfony runner的8个副本。我们还定义了Pod停留在终止状态的最长时间为1小时(3600)。我们使用生命周期钩子捕获Pod SIGTERM并创建文件<code class="fe no np nq nr b">/tmp/kill_me</code>。</p><p id="b45c" class="pw-post-body-paragraph ml mm it ls b lt my ju mn lv mz jx mo ld na mq mr lh nb mt mu ll nc mw mx ma im bi translated">Symfony工作进程被定义为只处理1条消息，最多等待60秒。当进程结束时，shell while循环将再次启动它，但前提是文件<code class="fe no np nq nr b">/tmp/kill_me</code>不存在。因此，如果通讯器处理消息，Pod将继续运行。</p><p id="65b0" class="pw-post-body-paragraph ml mm it ls b lt my ju mn lv mz jx mo ld na mq mr lh nb mt mu ll nc mw mx ma im bi translated">如果收到SIGTERM，这将导致工作线程不会再次启动。因此，工作进程只处理当前正在处理的任何消息，或者等待60秒等待新消息，然后结束。</p><h1 id="2249" class="nd kv it bd kw ne nf ng kz nh ni nj lc jz nk ka lg kc nl kd lk kf nm kg lo nn bi translated">边车集装箱示例</h1><p id="2f85" class="pw-post-body-paragraph ml mm it ls b lt lu ju mn lv lw jx mo ld mp mq mr lh ms mt mu ll mv mw mx ma im bi translated">如果我们有另一个sidecar，比如Nginx代理或Python Flask应用程序也在运行，会怎么样？如果它们本身不处理SIGTERM信号，那么我们必须像这样实现它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="0143" class="pw-post-body-paragraph ml mm it ls b lt my ju mn lv mz jx mo ld na mq mr lh nb mt mu ll nc mw mx ma im bi translated">这里我们引入了一个共享卷，两个容器可以通过它进行通信。当代理容器接收到SIGTERM时，它通过创建文件<code class="fe no np nq nr b">/tmp/kill_me</code>通知Symfony runner不要再次启动。当while循环退出时，文件<code class="fe no np nq nr b">/share/kill_sidecar</code>被创建。</p><p id="324b" class="pw-post-body-paragraph ml mm it ls b lt my ju mn lv mz jx mo ld na mq mr lh nb mt mu ll nc mw mx ma im bi translated">sidecar容器也收到了SIGTERM，但是会一直等到文件<code class="fe no np nq nr b">/share/kill_sidecar</code>通过挂钩生命周期事件被创建。这样，它会一直保持活动状态，直到主容器完成处理。</p><h1 id="918d" class="nd kv it bd kw ne nf ng kz nh ni nj lc jz nk ka lg kc nl kd lk kf nm kg lo nn bi translated">伊斯迪奥</h1><p id="f642" class="pw-post-body-paragraph ml mm it ls b lt lu ju mn lv lw jx mo ld mp mq mr lh ms mt mu ll mv mw mx ma im bi translated">如果你在Kubernetes上运行Istio，那么你可能需要禁用它。因为对于sidecar容器如何处理SIGTERM还没有明确的处理方式(Istio版本1.4.3)。我们可以通过以下方式禁用:</p><pre class="kj kk kl km gt nu nr nv nw aw nx bi"><span id="f526" class="ku kv it nr b gy ny nz l oa ob">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: agent<br/>spec:<br/>  replicas: 8<br/>  selector:<br/>    matchLabels:<br/>      id: agent-pod<br/>  template:<br/>    metadata:<br/>      labels:<br/>        id: agent-pod<br/><strong class="nr iu">      annotations:<br/>        sidecar.istio.io/inject: "false"</strong></span></pre><h1 id="e2f8" class="nd kv it bd kw ne nf ng kz nh ni nj lc jz nk ka lg kc nl kd lk kf nm kg lo nn bi translated">概述</h1><p id="7dc9" class="pw-post-body-paragraph ml mm it ls b lt lu ju mn lv lw jx mo ld mp mq mr lh ms mt mu ll mv mw mx ma im bi translated">将terminationGracePeriodSeconds设置为工作进程处理您的消息所需的最长时间，甚至可以更长一些。这里最好保守一点。然后，一旦不再有消息被处理，就通过挂钩生命周期事件来控制更早的删除。</p><p id="af23" class="pw-post-body-paragraph ml mm it ls b lt my ju mn lv mz jx mo ld na mq mr lh nb mt mu ll nc mw mx ma im bi translated">在生产环境中实施该解决方案使我能够部署新的工作映像版本，而不必担心正在运行的任务被中断。</p><p id="723e" class="pw-post-body-paragraph ml mm it ls b lt my ju mn lv mz jx mo ld na mq mr lh nb mt mu ll nc mw mx ma im bi translated">你如何运行你的Symfony信使工人？</p><h1 id="85ef" class="nd kv it bd kw ne nf ng kz nh ni nj lc jz nk ka lg kc nl kd lk kf nm kg lo nn bi translated">成为Kubernetes认证</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><a href="https://killer.sh"><div class="gh gi oc"><img src="../Images/cf3901a56841fcb55f9e4e17b9f07672.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7Kbj17_6VncUuoBqNsAzzg.png"/></div></a><figcaption class="od oe gj gh gi of og bd b be z dk translated"><a class="ae mf" href="https://killer.sh" rel="noopener ugc nofollow" target="_blank"> https://killer.sh </a></figcaption></figure></div></div>    
</body>
</html>