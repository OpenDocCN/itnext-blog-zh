<html>
<head>
<title>Lessons learned from previous projects</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从以前的项目中吸取的经验教训</h1>
<blockquote>原文：<a href="https://itnext.io/lessons-learned-previous-projects-50fb6357737a?source=collection_archive---------4-----------------------#2022-03-13">https://itnext.io/lessons-learned-previous-projects-50fb6357737a?source=collection_archive---------4-----------------------#2022-03-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/75fa3c04770239436d6a1eb8c5fd3e02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ORuTyGEH9w7meNKo_7LFnQ.jpeg"/></div></div></figure><p id="b59f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">软件开发的一个令人兴奋的部分是，在某个时间点被一致认为是好的实践可能在几年后变得更加模糊。甚至是完全错误的。然而，你通常需要随着时间的推移多次这样做才能实现。以下是我在Java项目中的经验。</p><h1 id="edd8" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">分层包装</h1><p id="0b32" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">当我开始我的Java开发生涯时，每个项目都按层组织它们的类——控制器、服务和Dao(存储库)。典型项目的结构如下所示:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="fe9f" class="mi kx iq me b gy mj mk l ml mm">ch.frankel<br/>  ├─ controller<br/>  │  ├─ FirstController<br/>  │  └─ SecondController<br/>  ├─ service<br/>  │  ├─ FirstService<br/>  │  └─ SecondService<br/>  └─ dao<br/>     ├─ FirstDao<br/>     └─ SecondDao</span></pre><p id="8bd4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这种方法有两个主要缺点:</p><ul class=""><li id="e11e" class="mn mo iq ka b kb kc kf kg kj mp kn mq kr mr kv ms mt mu mv bi translated">从可见性的角度来看，要使用包外的类，您需要将它们标记为<code class="fe mw mx my me b">public</code>。<code class="fe mw mx my me b">FirstController</code>用的是<code class="fe mw mx my me b">FirstService</code>，因此后者必然是<code class="fe mw mx my me b">public</code>。因此，任何其他类都可以使用它，而我希望它只用于与“第一个”相关的类。</li><li id="4f56" class="mn mo iq ka b kb mz kf na kj nb kn nc kr nd kv ms mt mu mv bi translated">如果您想要拆分应用程序，您首先需要分析依赖关系，以理解包之间的耦合。</li></ul><p id="a733" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了解决这些问题，我发现按功能打包更加合适:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="422e" class="mi kx iq me b gy mj mk l ml mm">ch.frankel<br/>  ├─ first<br/>  │  ├─ FirstController<br/>  │  ├─ FirstService<br/>  │  └─ FirstDao<br/>  └─  second<br/>     ├─ SecondController<br/>     ├─ SecondService<br/>     └─ SecondDao</span></pre><p id="f52d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这样，控制器就是<code class="fe mw mx my me b">public</code>，代表了特性中的入口点。服务和Dao是“实现细节”:它们具有<code class="fe mw mx my me b">package</code>可见性，并且只能从它们的包内部访问。</p><p id="5206" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">作为一个额外的好处，如果你需要分割你的代码，你只需要通过包来完成。</p><h1 id="47cd" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">盲目服从优质工具</h1><p id="d87e" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">很久以前，我发现自己在使用一个名为Hammurapi的质量工具。声明一下，它仍然有一个<a class="ae ne" href="http://www.hammurapi.biz/hammurapi-biz/ef/xmenu/hammurapi-group/products/hammurapi/index.html" rel="noopener ugc nofollow" target="_blank">在线状态</a>，即使感觉它已经很久没有更新了。无论如何，当我在我的代码库上运行引擎时，报告最多的违规是缺少公共方法上的JavaDocs。鉴于所有的getters和setters都是公共的，我得到了很多。</p><p id="23f3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过程序自动添加JavaDocs很容易:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="23d5" class="mi kx iq me b gy mj mk l ml mm">/**<br/> Get the &lt;code&gt;foo&lt;/code&gt;.</span><span id="2353" class="mi kx iq me b gy nf mk l ml mm"> @return Current value of &lt;code&gt;foo&lt;/code&gt;<br/>*/<br/>public Foo getFoo() {<br/>  return foo;<br/>}</span><span id="61b7" class="mi kx iq me b gy nf mk l ml mm">/**<br/> Set the &lt;code&gt;foo&lt;/code&gt;.</span><span id="2f8d" class="mi kx iq me b gy nf mk l ml mm"> @param foo New value of &lt;code&gt;foo&lt;/code&gt;<br/>*/<br/>public void setFoo(Foo foo) {<br/>    this.foo = foo;<br/>}</span></pre><p id="a155" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它满足了我喜欢绿色支票的一面。然而，没有任何附加价值。</p><p id="b32d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">事实上，大多数优质工具的投资回报率都很低。这并不是因为你使用了制表符而不是空格，你的项目质量急剧下降。代码质量很难定义，衡量起来很复杂，用自动化的方式来做更是如此。</p><p id="c8ae" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">虽然我不是说要避免质量工具，但是要小心他们给你的<a class="ae ne" href="https://blog.frankel.ch/metrics" rel="noopener ugc nofollow" target="_blank">度量</a>。工程师和经理喜欢度量标准，但它可能会将您的团队/组织带到您不想去的地方，即使是出于最好的意图。</p><h1 id="96d8" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">安装员</h1><p id="c89a" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">创建一个类后，Java开发人员总是为它生成访问器，<em class="ng">即</em>，getters和setters。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="aaf3" class="mi kx iq me b gy mj mk l ml mm">public class Money {</span><span id="443b" class="mi kx iq me b gy nf mk l ml mm">    private final Currency currency;<br/>    private BigDecimal amount;</span><span id="7349" class="mi kx iq me b gy nf mk l ml mm">    public Currency getCurrency() {<br/>        return currency;<br/>    }</span><span id="3188" class="mi kx iq me b gy nf mk l ml mm">    public BigDecimal getAmount() {<br/>        return balance;<br/>    }</span><span id="7383" class="mi kx iq me b gy nf mk l ml mm">    public void setAmount(BigDecimal amount) {<br/>        this.amount = amount;<br/>    }<br/>}</span><span id="85af" class="mi kx iq me b gy nf mk l ml mm">public class Account {</span><span id="c162" class="mi kx iq me b gy nf mk l ml mm">    private Money balance;</span><span id="fde1" class="mi kx iq me b gy nf mk l ml mm">    public Currency getBalance() {<br/>        return balance;<br/>    }</span><span id="26f9" class="mi kx iq me b gy nf mk l ml mm">    public BigDecimal getBalance() {<br/>        return balance;<br/>    }</span><span id="13dc" class="mi kx iq me b gy nf mk l ml mm">    public void setBalance(BigDecimal balance) {<br/>        this.balance = balance;<br/>    }<br/>}</span></pre><p id="b002" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这就像巴甫洛夫反射。更糟糕的是，它是<a class="ae ne" href="https://stackoverflow.com/questions/3295496/what-is-a-javabean-exactly#answer-3295517" rel="noopener ugc nofollow" target="_blank"> JavaBean </a>约定的一部分，所以很多工具依赖于它们:ORM框架、序列化库、<em class="ng">例如</em> Jackson、映射工具、<em class="ng">例如</em> MapStruct等等。</p><p id="52e3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，如果你依赖这些工具中的任何一个，你就别无选择。如果没有，那么你大概要想一想，到底要不要走这条路。</p><p id="f069" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面是上述类的一个替代(和简化)设计:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="ae6c" class="mi kx iq me b gy mj mk l ml mm">class Account {</span><span id="fc54" class="mi kx iq me b gy nf mk l ml mm">    // Field and getter<br/>    // NO SETTER!</span><span id="8e2d" class="mi kx iq me b gy nf mk l ml mm">    public BigDecimal creditFrom(Account account, Money amount) {<br/>        // Check that currencies are compatible<br/>        // Do the credit<br/>    }</span><span id="1d64" class="mi kx iq me b gy nf mk l ml mm">    public BigDecimal debitFrom(Account account, Money amount) {<br/>        // Check that currencies are compatible<br/>        // Do the debit<br/>    }<br/>}</span></pre><p id="13ae" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请注意，getter替代方案会使设计更加复杂，但没有多少额外的好处。如果它们不公开私有数据——不可变对象或副本，我愿意保留它们。</p><h1 id="8ab5" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">抽象无处不在</h1><p id="73e2" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">我在enterprise中学到的第一课是，“优秀”的开发人员总是围绕以下三个组件来设计他们的实现:</p><figure class="lz ma mb mc gt jr gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/ca8a7d4e8238b426b0d67c769a0eae80.png" data-original-src="https://miro.medium.com/v2/resize:fit:406/format:webp/0*lL79L1tcRvWYiE5b.png"/></div></figure><p id="fa80" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">问题是<code class="fe mw mx my me b">FooImpl</code>是唯一的<code class="fe mw mx my me b">Foo</code>实现，当您需要命名类时，这变得很明显。最常见的方案是在抽象类前面加上<code class="fe mw mx my me b">Abstract</code>，在具体类后面加上<code class="fe mw mx my me b">Impl</code>。发现问题的另一种方法是在哪里实现该方法:在抽象类和具体类之间，没有简单的方法来决定最佳位置。</p><p id="52aa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">抽象降低了耦合度。然而，应用程序中的耦合比库中的耦合影响要小得多。</p><h1 id="68af" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">数据传输对象</h1><p id="457b" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">我用DTO已经很久了。我最早的一篇博文<a class="ae ne" href="https://blog.frankel.ch/automated-beans-conversion/" rel="noopener ugc nofollow" target="_blank">实际上是关于dto、bean映射和自动化映射过程的</a><a class="ae ne" href="https://github.com/DozerMapper/dozer" rel="noopener ugc nofollow" target="_blank"> Dozer </a>库。我甚至记得一位建筑师同事建议我为每一层设计一个专用的类:</p><ul class=""><li id="67e2" class="mn mo iq ka b kb kc kf kg kj mp kn mq kr mr kv ms mt mu mv bi translated">DAO层的实体</li><li id="5a6c" class="mn mo iq ka b kb mz kf na kj nb kn nc kr nd kv ms mt mu mv bi translated">同名图层的服务对象</li><li id="d4f2" class="mn mo iq ka b kb mz kf na kj nb kn nc kr nd kv ms mt mu mv bi translated">查看控制器层的对象</li></ul><p id="a362" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此外，因为PKs不应该泄漏到数据库之外，所以我们有一个专用的标识符列来传递。</p><p id="6715" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我听到你说过度工程了吗？嗯，你可能没有完全错。</p><p id="e1ef" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这让我想到了dto。如果您的视图与基础表非常不同，那么它们可能是个好主意。然而，在我工作过的大多数应用程序中，情况并非如此。他们完美地模仿了数据库结构。</p><p id="165b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这种情况下，我可能会倾向于这篇<a class="ae ne" href="https://blog.frankel.ch/alternatives-dto/" rel="noopener ugc nofollow" target="_blank">上一篇文章</a>中列出的技术之一。</p><h1 id="6c17" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">结论</h1><p id="fc0a" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">在这篇文章中，我描述了五种我可能不会再使用的技巧，或者至少在应用它们时要非常小心。</p><p id="b1ab" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你活的时间越长，你可能犯的错误就越多。这个想法是基于你的经验，以避免重复同样的错误。正如拉丁语所说的那样，<em class="ng"> errare humanum est，sed perseverare恶魔。</em></p><ul class=""><li id="19e7" class="mn mo iq ka b kb kc kf kg kj mp kn mq kr mr kv ms mt mu mv bi translated"><a class="ae ne" href="https://blog.frankel.ch/quality-tools-humble-servants-or-tyrans/" rel="noopener ugc nofollow" target="_blank">质量工具:卑微的仆人还是暴君？</a></li><li id="e909" class="mn mo iq ka b kb mz kf na kj nb kn nc kr nd kv ms mt mu mv bi translated"><a class="ae ne" href="https://blog.frankel.ch/encapsulation-dont-think-means-think-means/" rel="noopener ugc nofollow" target="_blank">封装:我不认为它的意思是你想的那样</a></li><li id="22d6" class="mn mo iq ka b kb mz kf na kj nb kn nc kr nd kv ms mt mu mv bi translated"><a class="ae ne" href="https://blog.frankel.ch/are-you-guilty-of-overengineering/" rel="noopener ugc nofollow" target="_blank">你是否犯了过度工程的罪？</a></li><li id="bd3f" class="mn mo iq ka b kb mz kf na kj nb kn nc kr nd kv ms mt mu mv bi translated"><a class="ae ne" href="https://blog.frankel.ch/alternatives-dto/" rel="noopener ugc nofollow" target="_blank">dto的替代品</a></li></ul></div><div class="ab cl ni nj hu nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="ij ik il im in"><p id="4e1c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="ng">原载于</em> <a class="ae ne" href="https://blog.frankel.ch/lessons-learned-previous-projects/" rel="noopener ugc nofollow" target="_blank"> <em class="ng">一个Java极客</em></a><em class="ng">2022年3月13日</em></p></div></div>    
</body>
</html>