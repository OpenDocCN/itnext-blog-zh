<html>
<head>
<title>A Tutorial about Deciding the best Singleton Approach in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于在Python中决定最佳单例方法的教程</h1>
<blockquote>原文：<a href="https://itnext.io/deciding-the-best-singleton-approach-in-python-65c61e90cdc4?source=collection_archive---------1-----------------------#2022-01-02">https://itnext.io/deciding-the-best-singleton-approach-in-python-65c61e90cdc4?source=collection_archive---------1-----------------------#2022-01-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="61cb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">1994年，单体设计模式诞生了。根据GoF的书，它是四种创造性的设计模式之一，意在将一个类的实例化限制为一个实例。激发这种模式的是日志记录或数据库系统等用例，在这些用例中，您需要单个协调器实例。</p><p id="3649" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这篇文章是关于在python中实现单例设计模式的最佳方法。</p><p id="4959" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> TLDR </strong>:元类方法似乎是这里给出的三种方法中最好的选择。它在可测试性方面超越了装饰方法——因为它更容易测试——并且在可读性、可重用性和可测试性方面消灭了传统方法。</p></div><div class="ab cl kl km hu kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="ij ik il im in"><p id="4151" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里给出的全部代码(和测试)可以在Replit编码平台中获得。</p><div class="ks kt gp gr ku kv"><a href="https://replit.com/@PauloMiguel1/design-pattern-creational-singleton" rel="noopener  ugc nofollow" target="_blank"><div class="kw ab fo"><div class="kx ab ky cl cj kz"><h2 class="bd ir gy z fp la fr fs lb fu fw ip bi translated">设计模式创造单例</h2><div class="lc l"><h3 class="bd b gy z fp la fr fs lb fu fw dk translated">以下是在python中实现单例设计模式的四种最常见的方式</h3></div><div class="ld l"><p class="bd b dl z fp la fr fs lb fu fw dk translated">replit.com</p></div></div><div class="le l"><div class="lf l lg lh li le lj lk kv"/></div></div></a></div><p id="8bfc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Udemy上有一个很棒的在线课程，它更详细地解释了如何用python实现每个设计模式。我强烈推荐。</p><p id="52fe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae ll" href="https://www.udemy.com/course/design-patterns-python/" rel="noopener ugc nofollow" target="_blank">https://www.udemy.com/course/design-patterns-python/</a></p></div><div class="ab cl kl km hu kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="ij ik il im in"><p id="d875" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Python提供了许多方法来实现它，三种最常见的方法是使用元类、装饰器或通过分配实现(也称为经典单例)。为了决定哪种方法是最好的，我从可读性、可重用性和可测试性的角度比较了这三种方法。</p><p id="fcc0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里给出的用例是一个简单数据库连接的实现，该连接仅限于单个实例。<code class="fe lm ln lo lp b">Database</code>是目标类，为了让它工作，它在实例化期间需要一个URL，供<code class="fe lm ln lo lp b">connect</code>方法使用。</p><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="lv lw l"/></div><figcaption class="lx ly gj gh gi lz ma bd b be z dk translated">这是我想限制为单个实例的目标类</figcaption></figure><h1 id="c2ab" class="mb mc iq bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">通过元类的单例</h1><p id="5f57" class="pw-post-body-paragraph jn jo iq jp b jq mz js jt ju na jw jx jy nb ka kb kc nc ke kf kg nd ki kj kk ij bi translated">元类提供了一种在创建过程中自动改变类的特殊方法。它可以指定该类的行为方式。</p><p id="4e30" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以我可以创建一个元类，如果它已经存在，就避免构造目标类的对象。<code class="fe lm ln lo lp b">__call__</code>将会是派生类构造的编排者，可以肯定的是<code class="fe lm ln lo lp b">__init__</code>只会被调用一次。</p><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="lv lw l"/></div><figcaption class="lx ly gj gh gi lz ma bd b be z dk translated">通过元类实现单例</figcaption></figure><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="lv lw l"/></div></figure><h1 id="0cdd" class="mb mc iq bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">单例通过装饰器</h1><p id="99ea" class="pw-post-body-paragraph jn jo iq jp b jq mz js jt ju na jw jx jy nb ka kb kc nc ke kf kg nd ki kj kk ij bi translated">2003年，通过PEP<a class="ae ll" href="https://www.python.org/dev/peps/pep-0318/" rel="noopener ugc nofollow" target="_blank">318</a>——函数和方法的装饰器，装饰器语法被引入Python。python中的装饰器是对函数和方法的扩展。这意味着它甚至可以在不修改原始扩展代码的情况下添加功能。</p><p id="5656" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要构建一个，我只需要创建一个函数的函数，它将返回一个类的单个实例。然后，在我们的目标类中应用<code class="fe lm ln lo lp b">@singleton</code>语法修饰。</p><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="lv lw l"/></div><figcaption class="lx ly gj gh gi lz ma bd b be z dk translated">通过装饰器实现单例</figcaption></figure><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="lv lw l"/></div></figure><h1 id="3c7a" class="mb mc iq bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">经典单例</h1><p id="b0d4" class="pw-post-body-paragraph jn jo iq jp b jq mz js jt ju na jw jx jy nb ka kb kc nc ke kf kg nd ki kj kk ij bi translated">经典的方法包括在目标类中构建单例。每当实例化时，<code class="fe lm ln lo lp b">__new__</code>和<code class="fe lm ln lo lp b">__init__</code>都会被调用。前者是创建对象的时候，后者是初始化对象。</p><p id="9471" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">知道我给<code class="fe lm ln lo lp b">__new__</code>分配了目标类的构造，而<code class="fe lm ln lo lp b">__init__</code>只是确保它只初始化属性一次。</p><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="lv lw l"/></div><figcaption class="lx ly gj gh gi lz ma bd b be z dk translated">通过经典方法实现单例</figcaption></figure><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="lv lw l"/></div></figure><h1 id="bc14" class="mb mc iq bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">决定最佳方法</h1><p id="4063" class="pw-post-body-paragraph jn jo iq jp b jq mz js jt ju na jw jx jy nb ka kb kc nc ke kf kg nd ki kj kk ij bi translated">最后，重要的是拥有可维护的代码。为了做到这一点，我考虑了使代码可维护的三个标准:可读性、可重用性和可测试性。</p><h2 id="04a2" class="ne mc iq bd md nf ng dn mh nh ni dp ml jy nj nk mp kc nl nm mt kg nn no mx np bi translated">可读性分数</h2><ol class=""><li id="5162" class="nq nr iq jp b jq mz ju na jy ns kc nt kg nu kk nv nw nx ny bi translated">元类:太好了</li><li id="4c19" class="nq nr iq jp b jq nz ju oa jy ob kc oc kg od kk nv nw nx ny bi translated">装饰者:太好了</li><li id="32f9" class="nq nr iq jp b jq nz ju oa jy ob kc oc kg od kk nv nw nx ny bi translated">经典:不太好</li></ol><p id="1d8c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">关于可读性，元类和装饰器方法比经典方法更清楚地表达了它们的意图。</p><p id="413c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">仅仅通过阅读目标类的第一行，你就会意识到该类的单例行为。然而，经典的方法是隐式的，所以你需要真正阅读实现来理解这个类是单例的。</p><h2 id="b2ea" class="ne mc iq bd md nf ng dn mh nh ni dp ml jy nj nk mp kc nl nm mt kg nn no mx np bi translated">可重用性得分</h2><ol class=""><li id="81d2" class="nq nr iq jp b jq mz ju na jy ns kc nt kg nu kk nv nw nx ny bi translated">元类:太好了</li><li id="29db" class="nq nr iq jp b jq nz ju oa jy ob kc oc kg od kk nv nw nx ny bi translated">装饰者:太好了</li><li id="65a8" class="nq nr iq jp b jq nz ju oa jy ob kc oc kg od kk nv nw nx ny bi translated">经典:不太好</li></ol><p id="bcad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">关于可重用性，你可以在许多类中使用元类和装饰器。它们独立于目标类，这使得它们可以重用。</p><p id="203d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，经典的方法是与目标类高度耦合的，所以如果你想有另一个单独的类，你必须复制相同的代码。</p><h2 id="7ca0" class="ne mc iq bd md nf ng dn mh nh ni dp ml jy nj nk mp kc nl nm mt kg nn no mx np bi translated">测试性得分</h2><ol class=""><li id="c3a5" class="nq nr iq jp b jq mz ju na jy ns kc nt kg nu kk nv nw nx ny bi translated">元类:太好了</li><li id="eb29" class="nq nr iq jp b jq nz ju oa jy ob kc oc kg od kk nv nw nx ny bi translated">装饰者:太好了</li><li id="bf00" class="nq nr iq jp b jq nz ju oa jy ob kc oc kg od kk nv nw nx ny bi translated">经典:不太好</li></ol><p id="ea4c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">关于可测试性，期望用有效和无效的URL测试<code class="fe lm ln lo lp b">Database</code>，并检查它在<code class="fe lm ln lo lp b">connect</code>期间的行为。第一个测试<code class="fe lm ln lo lp b">test_connect__when_url_is_valid_returns_success</code>应该返回成功，但是<code class="fe lm ln lo lp b">test_connect__when_url_is_invalid_raise_error</code>应该由于无效的URL而引发一个错误。</p><p id="7fac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">休斯顿，我们有麻烦了。通过运行测试集，我意识到当它们一起运行时，其中一个测试总是会失败。这是因为两者都期望目标类的不同状态，如果我们保持单例行为，每个测试集都将有第一个测试用例创建的实例(有效的或者无效的)。</p><p id="e005" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，解决方案是模仿单例行为，因为我们的目标只是测试<code class="fe lm ln lo lp b">Database</code>类的逻辑。</p><p id="4218" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">看看经典的方法，我不能嘲笑单例，因为它与类高度耦合。在这种情况下，甚至“嘲笑”单身行为也没有意义，因为这也属于<code class="fe lm ln lo lp b">Database</code>的职责。</p><p id="658b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用装饰器方法，我能够轻松地移除单例行为。使用库<code class="fe lm ln lo lp b"><a class="ae ll" href="https://pypi.org/project/undecorated/" rel="noopener ugc nofollow" target="_blank">undecorated</a></code>,我移除了装饰模式，可以轻松运行整个测试集。</p><p id="87fa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">至于元类，那就更简单了，我只需要测试没有实现singleton的<code class="fe lm ln lo lp b">_Database</code>类(记住，只有<code class="fe lm ln lo lp b">DatabaseSingleton</code>有)</p><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="lv lw l"/></div><figcaption class="lx ly gj gh gi lz ma bd b be z dk translated">测试单例元类方法</figcaption></figure><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="lv lw l"/></div></figure><h1 id="efc5" class="mb mc iq bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">最佳选择:通过元类的单例</h1><p id="7801" class="pw-post-body-paragraph jn jo iq jp b jq mz js jt ju na jw jx jy nb ka kb kc nc ke kf kg nd ki kj kk ij bi translated">元类方法似乎是三种方法中最好的，因为它比装饰方法更容易测试，并且在可读性、可重用性和可测试性方面比经典方法好得多。</p></div></div>    
</body>
</html>