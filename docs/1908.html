<html>
<head>
<title>Responsive Background Images Using React Hooks🍍</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用React挂钩的响应背景图像🍍</h1>
<blockquote>原文：<a href="https://itnext.io/responsive-background-images-using-react-hooks-941af365ea1f?source=collection_archive---------1-----------------------#2019-02-22">https://itnext.io/responsive-background-images-using-react-hooks-941af365ea1f?source=collection_archive---------1-----------------------#2019-02-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="4461" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">了解新的React效应——以及现实生活中的状态挂钩。</em></p><p id="e85b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">处理全屏背景图像可能会很困难。我经常发现很少有全屏图像在横向和纵向上都很好看，所以我喜欢根据视口宽度使用不同的图像。通常我会让CSS中的媒体查询来处理网站的响应，但有时图像URL只在JavaScript中可用，例如，如果通过Ajax请求加载。</p><p id="1971" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">面对React应用程序中的这些问题，我决定尝试新的<a class="ae km" href="https://reactjs.org/docs/hooks-overview.html" rel="noopener ugc nofollow" target="_blank"> Hooks API </a>来解决它们。有了React钩子，我们既可以订阅视窗大小的变化，又可以根据屏幕的宽度设置合适的背景图像！🎉</p><p id="701a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我的React应用程序中，我选择了一个适合桌面屏幕的背景图像和另一个适合移动设备的背景图像，按照这样的设计:</p><div class="kn ko kp kq gt ab cb"><figure class="kr ks kt ku kv kw kx paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><img src="../Images/eb46f527fa703bbb62ed09f8cbf539cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:480/format:webp/1*JzPim0t5MLzqNlFIDkXCQQ.png"/></div></figure><figure class="kr ks le ku kv kw kx paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><img src="../Images/ca5b09f0bdf4e45988e2a375dc20c779.png" data-original-src="https://miro.medium.com/v2/resize:fit:1522/format:webp/1*RZIzlTaD6PGhzITgdSpp7g.png"/></div><figcaption class="lf lg gj gh gi lh li bd b be z dk lj di lk ll translated">窄屏幕使用适合纵向的图像，宽屏幕使用横向图像</figcaption></figure></div><p id="c4e5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是我的React组件。注意这是一个f<em class="kl">functional组件，</em>因为钩子不能与类组件一起工作。小于650像素的屏幕将使用适合移动设备的图像。更宽的屏幕将使用桌面图像。</p><figure class="kn ko kp kq gt ks"><div class="bz fp l di"><div class="lm ln l"/></div></figure><p id="4797" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我也有一些基本的CSS来使背景图像全屏显示并定位文本:</p><figure class="kn ko kp kq gt ks"><div class="bz fp l di"><div class="lm ln l"/></div></figure><p id="2a11" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当组件第一次呈现时，即使没有挂钩，这也很好，但是如果我开始重新调整窗口大小，即使低于650px断点，图像url也不会改变。为了获得这个期望的副作用，我们需要通过使用<a class="ae km" href="https://reactjs.org/docs/hooks-effect.html" rel="noopener ugc nofollow" target="_blank">效果钩子</a>将一个监听器连接到窗口的调整大小事件。</p><h1 id="a18b" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">效果挂钩</h1><p id="7f9a" class="pw-post-body-paragraph jn jo iq jp b jq mm js jt ju mn jw jx jy mo ka kb kc mp ke kf kg mq ki kj kk ij bi translated">效果挂钩<code class="fe mr ms mt mu b">useEffect</code>，让我们在React功能组件中执行副作用。有了这个钩子，我只需要添加一次事件侦听器，它就会在每次组件呈现时运行。它基本上相当于一个类组件的<code class="fe mr ms mt mu b">componentDidMount </code>和<code class="fe mr ms mt mu b">componentDidUpdate</code>生命周期方法的组合。下面是我的应用程序组件内部的效果:</p><pre class="kn ko kp kq gt mv mu mw mx aw my bi"><span id="7ba5" class="mz lp iq mu b gy na nb l nc nd">useEffect(() =&gt; {        <br/>  window.addEventListener('resize', handleWindowResize);         <br/>});</span></pre><p id="6311" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我还想在组件卸载时删除事件侦听器。在类组件中，这将在<code class="fe mr ms mt mu b">componentWillUnmount</code>方法中完成。有了效果钩子，我们可以将所有与副作用相关的代码放在一个地方——因为<code class="fe mr ms mt mu b">useEffect</code>的返回值充当了一个清理方法。看起来是这样的:</p><pre class="kn ko kp kq gt mv mu mw mx aw my bi"><span id="e53f" class="mz lp iq mu b gy na nb l nc nd">useEffect(() =&gt; {        <br/>  window.addEventListener('resize', handleWindowResize);</span><span id="fa1c" class="mz lp iq mu b gy ne nb l nc nd">  return () =&gt; {            <br/>    window.removeEventListener('resize', handleWindowResize);  <br/>  }  <br/>});</span></pre><p id="b68a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">默认情况下，效果挂钩在组件每次挂载和更新时都会运行。但这在我的情况下是不必要的。为了解决这个问题，我们将使用第二个参数useEffect，这是一个依赖关系数组。因为我对我的钩子没有依赖性，所以我将一个空数组作为第二个参数传递，这使得副作用只在组件装载和卸载时运行，这正是我们想要的:</p><pre class="kn ko kp kq gt mv mu mw mx aw my bi"><span id="74b7" class="mz lp iq mu b gy na nb l nc nd">useEffect(() =&gt; {        <br/>  window.addEventListener('resize', handleWindowResize);</span><span id="1805" class="mz lp iq mu b gy ne nb l nc nd">  return () =&gt; {            <br/>    window.removeEventListener('resize', handleWindowResize);      <br/>  }  <br/>}, []); //empty array makes side effect only run on mount and unmount</span></pre><h1 id="9ac0" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">州钩</h1><p id="5892" class="pw-post-body-paragraph jn jo iq jp b jq mm js jt ju mn jw jx jy mo ka kb kc mp ke kf kg mq ki kj kk ij bi translated">在我的<code class="fe mr ms mt mu b">handleWindowResize </code>函数中，我现在想用新的值<code class="fe mr ms mt mu b">window.innerWidth</code>更新组件的状态。但是打住，这是一个功能组件，那么不重构到一个类组件，怎么改变它的状态呢？答案是:与<a class="ae km" href="https://reactjs.org/docs/hooks-state.html" rel="noopener ugc nofollow" target="_blank">状态挂钩。</a></p><p id="6f33" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">状态挂钩允许我们甚至在功能组件中使用组件状态。用<code class="fe mr ms mt mu b">useState </code>声明状态变量的方式如下:</p><pre class="kn ko kp kq gt mv mu mw mx aw my bi"><span id="26ae" class="mz lp iq mu b gy na nb l nc nd">const [windowWidth, setWindowWidth ] = useState(window.innerWidth);</span></pre><p id="42ae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">数组中的第一项<code class="fe mr ms mt mu b">windowWidth</code>，相当于类组件中的<code class="fe mr ms mt mu b">this.state.windowWidth </code>。第二项<code class="fe mr ms mt mu b">setWindowWidth</code>，是setter函数，相当于类组件中的<code class="fe mr ms mt mu b">setState({ windowWidth: window.innerWidth })</code>。<code class="fe mr ms mt mu b">useState</code>的唯一参数是特定状态变量的初始值，在我的例子中是窗口的初始宽度。</p><p id="9a55" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，这就是<code class="fe mr ms mt mu b">handleWindowResize</code>函数的样子，我在我的<code class="fe mr ms mt mu b">useEffect</code>钩子内部声明了它。它调用setter函数来更新<code class="fe mr ms mt mu b">windowWidth</code>状态:</p><pre class="kn ko kp kq gt mv mu mw mx aw my bi"><span id="2e9a" class="mz lp iq mu b gy na nb l nc nd">useEffect(() =&gt; {<br/>  const handleWindowResize = () =&gt; {<br/>    <!-- -->setWindowWidth<!-- -->(<!-- -->window<!-- -->.<!-- -->innerWidth<!-- -->);<br/>  }</span><span id="2c74" class="mz lp iq mu b gy ne nb l nc nd">  window.addEventListener('resize', handleWindowResize);</span><span id="0d1c" class="mz lp iq mu b gy ne nb l nc nd">  return () =&gt; {            <br/>    window.removeEventListener('resize', handleWindowResize);      <br/>  }  <br/>}, []);</span></pre><p id="8956" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="kl"> Edit </em> </strong> <em class="kl">:在上面的代码部分中，看起来setWindowWidth是useEffect钩子的依赖项，因为它是在钩子外部声明的。虽然它确实在技术上是一个依赖项，并且我们可以在我们的依赖数组中指定它，但我们实际上并不需要这样做，因为useState中的值被React保证是静态的</em> <a class="ae km" href="https://overreacted.io/a-complete-guide-to-useeffect/" rel="noopener ugc nofollow" target="_blank"> <em class="kl">。</em> </a></p><p id="f19c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我的React组件现在看起来像这样，同时使用了状态挂钩和效果挂钩:</p><figure class="kn ko kp kq gt ks"><div class="bz fp l di"><div class="lm ln l"/></div></figure><p id="8f37" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，每次调整窗口大小时，状态变量<code class="fe mr ms mt mu b">windowWidth</code>都会更新！🎉</p><h1 id="f22c" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">定制挂钩</h1><p id="0358" class="pw-post-body-paragraph jn jo iq jp b jq mm js jt ju mn jw jx jy mo ka kb kc mp ke kf kg mq ki kj kk ij bi translated">应用程序中可能还有其他组件需要了解窗口宽度。为了避免在多个组件中编写相同的代码，我们可以提取处理副作用和有状态逻辑的代码，并创建一个<a class="ae km" href="https://reactjs.org/docs/hooks-custom.html" rel="noopener ugc nofollow" target="_blank">定制钩子</a>。自定义钩子只是一个调用其他React钩子的JavaScript函数。根据React文档，函数的名称应该以“use”开头。我决定调用我的自定义钩子<code class="fe mr ms mt mu b">useWindowWidth</code>,现在它开始工作了:</p><figure class="kn ko kp kq gt ks"><div class="bz fp l di"><div class="lm ln l"/></div></figure><h1 id="dd82" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">裁决</h1><p id="0449" class="pw-post-body-paragraph jn jo iq jp b jq mm js jt ju mn jw jx jy mo ka kb kc mp ke kf kg mq ki kj kk ij bi translated">当我第一次看到React Hooks的文档时，我不确定它们在我的日常工作中会有多大用处，但是现在我已经开始在项目中引入它们，尤其是效果Hook变得非常有吸引力。我喜欢与一个副作用相关的所有代码都保存在同一个地方，而不是分散在不同的生命周期方法中。与创建具有相同逻辑的类组件相比，要编写的代码要少得多。语法对我来说还是有点怪，但我猜这只是偏好和习惯的问题。</p><p id="ab1a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">希望随着钩子的使用越来越频繁，我会发现更多的好处和用例。如果没有，至少知道我们现在可以选择在React中处理状态和副作用时使用功能组件或类组件是件好事。</p></div></div>    
</body>
</html>