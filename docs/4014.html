<html>
<head>
<title>Building your First async fluent API using interface extension methods pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用接口扩展方法模式构建您的第一个异步fluent API</h1>
<blockquote>原文：<a href="https://itnext.io/building-your-first-async-fluent-api-using-interface-extension-methods-pattern-4baaf8a55c5a?source=collection_archive---------3-----------------------#2020-04-11">https://itnext.io/building-your-first-async-fluent-api-using-interface-extension-methods-pattern-4baaf8a55c5a?source=collection_archive---------3-----------------------#2020-04-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/77449c481e5fc56866de34ba78638473.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sXO3lbPj9YKYuSSRer2ZEg.png"/></div></div></figure><p id="e488" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Fluent接口是一个高级的API设计，真正实现了对方法和方法链的扩展。fluent API最著名的例子是IEnumerable的linq扩展方法。</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="b4b0" class="lf lg iq lb b gy lh li l lj lk">var passed=Students.Where(s=&gt;s.Passed).Select(s=&gt;s.Name).ToList();</span></pre><p id="661a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在异步编程中，async/await、fluent APIs由于其热构建默认任务对象的性质而受到限制，在本文中，我们将克服这个问题，并构建一个允许fluent扩展方法的小型库。</p><p id="6c14" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">举个例子，</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="a5ef" class="lf lg iq lb b gy lh li l lj lk">var data=await GetDataAsync()<br/>         .AsRepeatable(TimeSpan.FromSeconds(10))<br/>         .FirstOrDefaultAsync(data=&gt;data.Any());</span></pre><p id="81a5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">另一个例子可能是</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="9e16" class="lf lg iq lb b gy lh li l lj lk">var data=await GetNewsAsync()<br/>         .Where(newsList=&gt;newsList.Date&gt;=DateTime.Today)<br/>         .SelectMany(newsList=&gt;newsList.NewsItems)<br/>         .ToList();</span></pre><p id="b30e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">只是给你一个如何使用命令式方法编写这段代码的概念</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="8699" class="lf lg iq lb b gy lh li l lj lk"> var newsList=await GetNewsAsync();<br/> if(newsList.Date&gt;=DateTime.Today)<br/>    {<br/>       return newsList.Select(news=&gt;news.NewsItems).ToList();<br/>    }<br/>else<br/>       return new List&lt;NewsItem&gt;();</span></pre><p id="6ac3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可以选择你喜欢的代码风格，如果你喜欢第二种，你可以停止阅读这篇文章，因为在文章的其余部分，我们将扩展c sharp语言，使第一种适用。</p></div><div class="ab cl ll lm hu ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="ij ik il im in"><p id="1dbd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">很好，你决定继续显示你是一个非常优雅的软件工程师，所以请葡萄你的咖啡，你也可以邀请我</p><div class="ls lt gp gr lu lv"><a href="https://ko-fi.com/ahmedfouad" rel="noopener  ugc nofollow" target="_blank"><div class="lw ab fo"><div class="lx ab ly cl cj lz"><h2 class="bd ir gy z fp ma fr fs mb fu fw ip bi translated">给艾哈迈德·福阿德买杯咖啡。ko-fi.com/ahmedfouad</h2><div class="mc l"><h3 class="bd b gy z fp ma fr fs mb fu fw dk translated">我是PlanRadar的一名软件工程师，目前居住在奥地利的维也纳。我的兴趣…</h3></div><div class="md l"><p class="bd b dl z fp ma fr fs mb fu fw dk translated">ko-fi.com</p></div></div><div class="me l"><div class="mf l mg mh mi me mj jw lv"/></div></div></a></div><h1 id="bc74" class="mk lg iq bd ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng bi translated">步骤1:将你的异步任务<t>转换成任务<option/></t></h1><p id="2558" class="pw-post-body-paragraph jy jz iq ka b kb nh kd ke kf ni kh ki kj nj kl km kn nk kp kq kr nl kt ku kv ij bi translated">这将帮助我们摆脱NullReferenceExceptions，只关注扩展方法。</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="fc7d" class="lf lg iq lb b gy lh li l lj lk">public static  Func&lt;Task&lt;Option&lt;T&gt;&gt;&gt; ToOption&lt;T&gt;(this Func&lt;Task&lt;T&gt;&gt; context)<br/>{<br/>     return new Func&lt;Task&lt;Option&lt;T&gt;&gt;&gt;(async () =&gt;{<br/>     try<br/>       {<br/>          var result = await context.Invoke();<br/>          return result.SomeNotNull();<br/>       }<br/>     catch (Exception e)<br/>       {<br/>          return Option.None&lt;T&gt;();<br/>       }});</span><span id="f31c" class="lf lg iq lb b gy nm li l lj lk">}</span></pre><p id="585d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个方法只是调用异步方法和返回选项。当值为null或发生异常时为None，当有值时为some。</p><p id="3977" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将需要安装选项类型掘金包</p><div class="ls lt gp gr lu lv"><a href="https://www.nuget.org/packages/Optional/" rel="noopener  ugc nofollow" target="_blank"><div class="lw ab fo"><div class="lx ab ly cl cj lz"><h2 class="bd ir gy z fp ma fr fs mb fu fw ip bi translated">可选4.0.0</h2><div class="mc l"><h3 class="bd b gy z fp ma fr fs mb fu fw dk translated">Optional是一个健壮的选项/可能是C#的类型。</h3></div><div class="md l"><p class="bd b dl z fp ma fr fs mb fu fw dk translated">www.nuget.org</p></div></div><div class="me l"><div class="nn l mg mh mi me mj jw lv"/></div></div></a></div><h1 id="56d6" class="mk lg iq bd ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng bi translated">步骤2:构建一个包装类，我们将在其中实现我们的扩展方法</h1><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="ad7b" class="lf lg iq lb b gy lh li l lj lk">public class ExtendedTask&lt;T&gt;<br/>    {<br/>        private readonly Func&lt;Task&lt;Option&lt;T&gt;&gt;&gt; _taskOption;<br/>        public ExtendedTask(Func&lt;Task&lt;T&gt;&gt; task)<br/>        {<br/>            _taskOption = task.ToOption();<br/>        }<br/>        public ExtendedTask(Func&lt;Task&lt;Option&lt;T&gt;&gt;&gt; task)<br/>        {<br/>            _taskOption = task;<br/>        }<br/>    }</span></pre><p id="a1f3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从这里可以很容易地实现我们的扩展方法，我们只是将实现委托给选项类型。</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="8806" class="lf lg iq lb b gy lh li l lj lk">public ExtendedTask&lt;T&gt; Where(Func&lt;T,bool&gt; condition)<br/>        {<br/>            var conditionedTask = _taskOption.Select(func =&gt; new Func&lt;Task&lt;Option&lt;T&gt;&gt;&gt;(async () =&gt;<br/>            {<br/>                var result = await func.Invoke();<br/>                return result.Where(condition);<br/>            }));<br/>            <br/>            return new ExtendedTask&lt;T&gt;(conditionedTask);<br/>        }</span></pre><p id="48fa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当条件满足时，它将返回新的扩展任务<t>的值，否则返回None的扩展任务<t>。</t></t></p><p id="2f57" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们将使用相同的策略实现select方法和select async方法。</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="e6d0" class="lf lg iq lb b gy lh li l lj lk">public ExtendedTask&lt;TP&gt; Select&lt;TP&gt;(Func&lt;T,TP&gt; selector)<br/>        {<br/>            var conditionedTask = _taskOption.Select(func =&gt; new <br/>            Func&lt;Task&lt;Option&lt;TP&gt;&gt;&gt;(async () =&gt;<br/>            {<br/>                var result = await func.Invoke();<br/>                <br/>                return result.Select(selector);<br/>            }));</span><span id="1fa9" class="lf lg iq lb b gy nm li l lj lk">          return new ExtendedTask&lt;TP&gt;(conditionedTask);<br/>        }</span><span id="e418" class="lf lg iq lb b gy nm li l lj lk">public ExtendedTask&lt;TP&gt; SelectAsync&lt;TP&gt;(Func&lt;T, Task&lt;TP&gt;&gt; selector)<br/>        {<br/>            var conditionedTask = _taskOption.Select(func =&gt; new  <br/>            Func&lt;Task&lt;Option&lt;TP&gt;&gt;&gt;(async () =&gt;<br/>            {<br/>                var result = await func.Invoke();</span><span id="805c" class="lf lg iq lb b gy nm li l lj lk">                var <a class="ae no" href="http://twitter.com/select" rel="noopener ugc nofollow" target="_blank">@select</a> = await result.Select(selector.Invoke)<br/>                 .ValueOr(()=&gt;Task.FromResult(default(TP)));</span><span id="1f29" class="lf lg iq lb b gy nm li l lj lk">                return <a class="ae no" href="http://twitter.com/select" rel="noopener ugc nofollow" target="_blank">@select</a>.SomeWhen(p =&gt;<br/>                {<br/>                    var b = p.Equals(default(TP));<br/>                    return !b;<br/>                });<br/>            }));</span></pre><h1 id="4c22" class="mk lg iq bd ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng bi translated">步骤3:实现AsTask()方法</h1><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="6448" class="lf lg iq lb b gy lh li l lj lk">public async Task&lt;T&gt; AsTask()<br/>        {<br/>            return (await _taskOption.Select(async task =&gt; await <br/>                    task())).ValueOrDefault();<br/>        }</span></pre><p id="eb5c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个方法简单地返回一个执行修饰任务的新任务，并且当值为None时简单地返回T的默认值。</p><h1 id="c5c6" class="mk lg iq bd ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng bi translated">步骤4:实现AsRepeatable()方法</h1><p id="ca7e" class="pw-post-body-paragraph jy jz iq ka b kb nh kd ke kf ni kh ki kj nj kl km kn nk kp kq kr nl kt ku kv ij bi translated">因为可重复方法是将标量任务<t>转换为矢量IAsyncEnumerable <t>的转换方法</t></t></p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="5b76" class="lf lg iq lb b gy lh li l lj lk">public  IAsyncEnumerable&lt;T&gt; AsRepeatable()<br/>        {<br/>            return new TaskAsyncEnumerable&lt;T&gt;( _taskOption);<br/>        }<br/>        public IAsyncEnumerable&lt;T&gt; AsRepeatable(TimeSpan timeSpan)<br/>        {<br/>            return new TaskAsyncEnumerable&lt;T&gt;(_taskOption ,timeSpan);<br/>        }</span></pre><p id="b882" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面是taskasyncenumable<t>的实现</t></p><figure class="kw kx ky kz gt jr"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="23d4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">非常简单，枚举器将在迭代时继续执行任务，只有当迭代停止或值变为null时才会停止。</p><h1 id="fac4" class="mk lg iq bd ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng bi translated">第五步:让我们试试</h1><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="b39b" class="lf lg iq lb b gy lh li l lj lk">var getDataAsync = new ExtendedTask&lt;News&gt;(GetDataAsync);<br/>var data = await getDataAsync<br/>                .AsRepeatable(TimeSpan.FromSeconds(1))<br/>                .FirstOrDefaultAsync(data =&gt; data.Items.Any());</span></pre><h1 id="5764" class="mk lg iq bd ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng bi translated">第六步</h1><p id="a109" class="pw-post-body-paragraph jy jz iq ka b kb nh kd ke kf ni kh ki kj nj kl km kn nk kp kq kr nl kt ku kv ij bi translated">如果你喜欢这篇文章，请分享它，在媒体和twitter上关注我，以获得我即将发布的</p><div class="ls lt gp gr lu lv"><a href="https://twitter.com/MCC_Ahmed" rel="noopener  ugc nofollow" target="_blank"><div class="lw ab fo"><div class="lx ab ly cl cj lz"><h2 class="bd ir gy z fp ma fr fs mb fu fw ip bi translated">艾哈迈德·福阿德</h2><div class="mc l"><h3 class="bd b gy z fp ma fr fs mb fu fw dk translated">艾哈迈德·福阿德的最新推文(@MCC_Ahmed)。我是PlanRadar的一名软件工程师，目前住在维也纳…</h3></div><div class="md l"><p class="bd b dl z fp ma fr fs mb fu fw dk translated">twitter.com</p></div></div><div class="me l"><div class="nr l mg mh mi me mj jw lv"/></div></div></a></div><p id="26d5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">给我咖啡钱</p><div class="ls lt gp gr lu lv"><a href="https://ko-fi.com/ahmedfouad" rel="noopener  ugc nofollow" target="_blank"><div class="lw ab fo"><div class="lx ab ly cl cj lz"><h2 class="bd ir gy z fp ma fr fs mb fu fw ip bi translated">给艾哈迈德·福阿德买杯咖啡。ko-fi.com/ahmedfouad</h2><div class="mc l"><h3 class="bd b gy z fp ma fr fs mb fu fw dk translated">我是PlanRadar的一名软件工程师，目前居住在奥地利的维也纳。我的兴趣…</h3></div><div class="md l"><p class="bd b dl z fp ma fr fs mb fu fw dk translated">ko-fi.com</p></div></div><div class="me l"><div class="mf l mg mh mi me mj jw lv"/></div></div></a></div></div></div>    
</body>
</html>