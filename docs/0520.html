<html>
<head>
<title>React Router Simple Starter Guide</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React路由器简单入门指南</h1>
<blockquote>原文：<a href="https://itnext.io/react-router-simple-starter-guide-c6477695908c?source=collection_archive---------0-----------------------#2018-03-25">https://itnext.io/react-router-simple-starter-guide-c6477695908c?source=collection_archive---------0-----------------------#2018-03-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/73f0b1949a4226dbb5c11ba1385e0f58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-1lKb19YvVExb6MCCNOYcg.jpeg"/></div></div></figure><h1 id="82af" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">我们正在建造的东西</h1><figure class="kw kx ky kz gt jr"><div class="bz fp l di"><div class="la lb l"/></div></figure><p id="71cb" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">没什么特别的，只是一个简单的react路由器例子，如果你想看代码的最终版本，请随意克隆来自<a class="ae ma" href="https://github.com/Colour-Full/react-router-simple-starter" rel="noopener ugc nofollow" target="_blank"> <strong class="le ir"> github </strong> </a>的回购</p><h1 id="eb0c" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated"><strong class="ak">安装依赖关系</strong></h1><p id="cf4e" class="pw-post-body-paragraph lc ld iq le b lf mb lh li lj mc ll lm ln md lp lq lr me lt lu lv mf lx ly lz ij bi translated">你需要在你的机器上安装Node，但是因为你正在读一篇关于React的文章，我想你已经知道了。</p><p id="dd3e" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">首先我们将使用<a class="ae ma" href="https://github.com/facebook/create-react-app" rel="noopener ugc nofollow" target="_blank"><strong class="le ir">react create app</strong></a>来获得我们的项目设置</p><pre class="kw kx ky kz gt mg mh mi mj aw mk bi"><span id="e223" class="ml jz iq mh b gy mm mn l mo mp">npx create-react-app simple-router</span></pre><p id="48e1" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">这将在名为<strong class="le ir"> simple-router的文件夹中创建我们的新项目。</strong>让<code class="fe mq mr ms mh b"><strong class="le ir">cd</strong></code>进入<code class="fe mq mr ms mh b"><strong class="le ir">simple-router</strong></code>并安装react路由器的网页版</p><pre class="kw kx ky kz gt mg mh mi mj aw mk bi"><span id="50a8" class="ml jz iq mh b gy mm mn l mo mp">npm install react-router-dom --save</span></pre><p id="c5aa" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">好了，既然我们已经得到了所有需要的东西，我们要做的就是从create-react-app提供的<strong class="le ir"> src </strong>和<strong class="le ir"> public </strong>文件夹中清除所有文件，这样我们就可以从头开始了。</p><h1 id="0008" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated"><strong class="ak">获取我们的静态HTML </strong></h1><p id="bcc1" class="pw-post-body-paragraph lc ld iq le b lf mb lh li lj mc ll lm ln md lp lq lr me lt lu lv mf lx ly lz ij bi translated">首先在<strong class="le ir">公开</strong>我们将创建一个全新的<strong class="le ir">index.html</strong>并添加以下内容:</p><figure class="kw kx ky kz gt jr"><div class="bz fp l di"><div class="mt lb l"/></div></figure><p id="4623" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">就这样，这是我们这个项目需要的所有HTML。从现在开始，一切都是关于JavaScript的。</p><h1 id="ead4" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated"><strong class="ak">构建组件</strong></h1><p id="18c2" class="pw-post-body-paragraph lc ld iq le b lf mb lh li lj mc ll lm ln md lp lq lr me lt lu lv mf lx ly lz ij bi translated">回到我们的<strong class="le ir"> src </strong>文件夹，我们将添加一个<strong class="le ir"> index.js </strong>文件:</p><figure class="kw kx ky kz gt jr"><div class="bz fp l di"><div class="mt lb l"/></div></figure><p id="2998" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">如果你仔细观察，你会看到我们正在导入一些css，但现在让我们继续关注组件，我们将在一会儿处理样式。</p><p id="07b9" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">好的，我们显然需要一个<strong class="le ir">导航</strong>组件，所以让我们把它添加到我们的<strong class="le ir"> src </strong>中</p><figure class="kw kx ky kz gt jr"><div class="bz fp l di"><div class="mt lb l"/></div></figure><p id="ee51" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">我们正在导入一些我们还没有构建的、易于修复的组件:</p><figure class="kw kx ky kz gt jr"><div class="bz fp l di"><div class="mt lb l"/></div></figure><figure class="kw kx ky kz gt jr"><div class="bz fp l di"><div class="mt lb l"/></div></figure><figure class="kw kx ky kz gt jr"><div class="bz fp l di"><div class="mt lb l"/></div></figure><p id="abc0" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">没有什么令人兴奋的只是几个非常简单的组件。</p><h1 id="7e92" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated"><strong class="ak">打扮自己</strong></h1><p id="0fd3" class="pw-post-body-paragraph lc ld iq le b lf mb lh li lj mc ll lm ln md lp lq lr me lt lu lv mf lx ly lz ij bi translated">还记得我说过这一切都是关于JavaScript的吗？好吧，差不多，我们会很快添加一些风格，在一天结束时，没有人真的希望他们的应用程序是丑陋的。在我们信任的<strong class="le ir"> src </strong>文件夹中添加一个新的index.css文件:</p><figure class="kw kx ky kz gt jr"><div class="bz fp l di"><div class="mt lb l"/></div></figure><p id="efaa" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">现在，如果您从终端运行<code class="fe mq mr ms mh b">npm start</code>并转到<a class="ae ma" href="http://localhost:3000/" rel="noopener ugc nofollow" target="_blank"> http://localhost:3000/ </a>，您应该会看到类似这样的内容:</p><figure class="kw kx ky kz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mu"><img src="../Images/6a700057bbed6891d470bca1e7cbe935.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pIMHknniGgeT2bpxpsKOUw.png"/></div></div></figure><h1 id="52c1" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">回到路线上</h1><p id="d158" class="pw-post-body-paragraph lc ld iq le b lf mb lh li lj mc ll lm ln md lp lq lr me lt lu lv mf lx ly lz ij bi translated">事情看起来很好，但我们仍然没有做任何路由。如果你点击那些闪亮的链接，什么也不会发生。</p><p id="08cb" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">反应路由器救援。</p><p id="b231" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">首先回到<strong class="le ir"> Nav.jsx </strong>我们将导入以下内容:</p><pre class="kw kx ky kz gt mg mh mi mj aw mk bi"><span id="0799" class="ml jz iq mh b gy mm mn l mo mp">import {</span><span id="7a90" class="ml jz iq mh b gy mv mn l mo mp">Route,</span><span id="b30c" class="ml jz iq mh b gy mv mn l mo mp">NavLink,</span><span id="cad6" class="ml jz iq mh b gy mv mn l mo mp">BrowserRouter</span><span id="e4df" class="ml jz iq mh b gy mv mn l mo mp">} from "react-router-dom";</span></pre><p id="a375" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">自从React路由器V4以来，我们处理的只是React组件。组件有三种:<strong class="le ir">路由器</strong>、<strong class="le ir">路由匹配</strong>和<strong class="le ir">路由渲染道具。</strong></p><p id="007b" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated"><strong class="le ir"> BrowserRouter </strong>是一个<strong class="le ir"> Router </strong>组件，它将为我们创建一个专门的历史对象。基本上，这将允许我们的用户使用浏览器按钮通过我们的应用程序或网站后退和前进，并总是到达他们先前离开的地方。这个组件应该是我们应用程序的根，这就是为什么我们要用它来包装我们的<strong class="le ir"> Nav </strong>组件:</p><pre class="kw kx ky kz gt mg mh mi mj aw mk bi"><span id="0b04" class="ml jz iq mh b gy mm mn l mo mp">&lt;BrowserRouter&gt;<br/>&lt;div&gt;       <br/>&lt;h1&gt;React Router Simple Starter&lt;/h1&gt;            <br/>    &lt;ul className="header"&gt;<br/>       &lt;li&gt;&lt;a className="active" href="/"&gt;Home&lt;/a&gt;&lt;/li&gt;<br/>       &lt;li&gt;&lt;a href="/blog"&gt;Stuff&lt;/a&gt;&lt;/li&gt;<br/>       &lt;li&gt;&lt;a href="/contact"&gt;Contact&lt;/a&gt;&lt;/li&gt;<br/>    &lt;/ul&gt;<br/>&lt;div className="content"&gt;&lt;/div&gt;    <br/>&lt;/div&gt;  <br/>&lt;/BrowserRouter&gt;</span></pre><p id="527a" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">需要说明的是，React Router<strong class="le ir">browser Router</strong>和<strong class="le ir"> HashRouter中有两个<strong class="le ir"> Router </strong>组件。根据官方文件:</strong></p><blockquote class="mw mx my"><p id="bb77" class="lc ld mz le b lf lg lh li lj lk ll lm na lo lp lq nb ls lt lu nc lw lx ly lz ij bi translated">如果您有一个响应请求的服务器，您应该使用一个<code class="fe mq mr ms mh b">&lt;BrowserRouter&gt;</code>,如果您使用一个静态文件服务器，您应该使用一个<code class="fe mq mr ms mh b">&lt;HashRouter&gt;</code></p></blockquote><p id="3989" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">或者更简单地说，<strong class="le ir"> BrowserRouter </strong>是你在客户端最常使用的，而<strong class="le ir"> HashRouter </strong>通常用于服务器端渲染。</p><p id="56d4" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">这一切都很棒，但如果我们启动应用程序并点击链接，仍然什么也不会发生。</p><p id="ba58" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">不要惊慌，这是正常的，要让它工作，我们需要抓住我们的<strong class="le ir"> NavLink </strong>组件:</p><pre class="kw kx ky kz gt mg mh mi mj aw mk bi"><span id="ad87" class="ml jz iq mh b gy mm mn l mo mp">&lt;BrowserRouter&gt;<br/>&lt;div&gt;       <br/>&lt;h1&gt;React Router Simple Starter&lt;/h1&gt;            <br/>    &lt;ul className="header"&gt;<br/>       &lt;li&gt;&lt;NavLink to="/"&gt;Home&lt;/NavLink&gt;&lt;/li&gt;<br/>       &lt;li&gt;&lt;NavLink to="/blog"&gt;Stuff&lt;/a&gt;&lt;/li&gt;<br/>       &lt;li&gt;&lt;NavLink to="/contact"&gt;Contact&lt;/a&gt;&lt;/li&gt;<br/>    &lt;/ul&gt;<br/>&lt;div className="content"&gt;&lt;/div&gt;    <br/>&lt;/div&gt;  <br/>&lt;/BrowserRouter&gt;</span></pre><p id="2779" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated"><strong class="le ir"> NavLink </strong>组件是<strong class="le ir"> Link </strong>组件的样式化版本，当它与当前URL匹配时，它将向呈现的元素添加样式化属性。默认的类名是<code class="fe mq mr ms mh b">active</code>,这就是为什么我们不再需要class name属性，我们需要将<code class="fe mq mr ms mh b">href</code>属性改为<code class="fe mq mr ms mh b">to</code>,没有双关语。</p><p id="a0bb" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">但是你可能会问自己<strong class="le ir">链接</strong>组件是做什么的，React路由器文档再次给出了答案:</p><blockquote class="mw mx my"><p id="7ede" class="lc ld mz le b lf lg lh li lj lk ll lm na lo lp lq nb ls lt lu nc lw lx ly lz ij bi translated">在应用程序中提供声明性的、可访问的导航。</p></blockquote><p id="9619" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">太酷了，让我们点击那些闪亮的导航链接…</p><p id="79e6" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">别这么快，我们还没完成。为了让一切正常工作，我们需要将一个<strong class="le ir">路线匹配</strong>组件引入到我们的导航中。首先，让我们快速浏览一下文档对这些类型的组件的描述:</p><blockquote class="mw mx my"><p id="d174" class="lc ld mz le b lf lg lh li lj lk ll lm na lo lp lq nb ls lt lu nc lw lx ly lz ij bi translated">路线匹配是通过比较<code class="fe mq mr ms mh b">&lt;Route&gt;</code>的<code class="fe mq mr ms mh b">path</code>道具和当前位置的<code class="fe mq mr ms mh b">pathname</code>来完成的。当一个<code class="fe mq mr ms mh b">&lt;Route&gt;</code>匹配时，它将呈现它的内容，当它不匹配时，它将呈现<code class="fe mq mr ms mh b">null</code>。没有路径的<code class="fe mq mr ms mh b">&lt;Route&gt;</code>总是匹配的。</p></blockquote><p id="7471" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">好吧，让它简单一点。当您点击一个<strong class="le ir"> NavLink </strong>组件时，这将更新浏览器url以匹配与传递给该组件的<code class="fe mq mr ms mh b">to</code> porp相同的路径。例如，如果我们点击</p><pre class="kw kx ky kz gt mg mh mi mj aw mk bi"><span id="5b11" class="ml jz iq mh b gy mm mn l mo mp">&lt;li&gt;&lt;NavLink to="/blog"&gt;Stuff&lt;/a&gt;&lt;/li&gt;</span></pre><p id="9f46" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">我们浏览器中的url将变为<code class="fe mq mr ms mh b">myapp.com/blog</code>。然后，React Router将寻找传递给<strong class="le ir"> Route </strong>组件的匹配路径，并显示我们在该路径上设置的任何组件。</p><p id="5b66" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">这听起来甚至让我很困惑，所以让我们写一些实际代码。希望这将增加一些清晰度:</p><pre class="kw kx ky kz gt mg mh mi mj aw mk bi"><span id="516e" class="ml jz iq mh b gy mm mn l mo mp">&lt;BrowserRouter&gt;<br/>&lt;div&gt;<br/>&lt;h1&gt;React Router Simple Starter&lt;/h1&gt;<br/>  &lt;ul className="header"&gt;<br/>    &lt;li&gt;&lt;NavLink exact to="/"&gt;Home&lt;/NavLink&gt; &lt;/li&gt;<br/>    &lt;li&gt;&lt;NavLink to="/Blog"&gt;Blog&lt;/NavLink&gt;&lt;/li&gt;<br/>    &lt;li&gt;&lt;NavLink to="/Contact"&gt;Contact&lt;/NavLink&gt;&lt;/li&gt;<br/>  &lt;/ul&gt;<br/>&lt;div className="content"&gt;<br/>  &lt;Route path="/" component={Home} /&gt;<br/>  &lt;Route path="/blog" component={Blog} /&gt;<br/>  &lt;Route path="/contact" component={Contact} /&gt;<br/>&lt;/div&gt;<br/>&lt;/div&gt;<br/>&lt;/BrowserRouter&gt;</span></pre><p id="ee84" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">这里发生的事情是，当浏览器url与页面上的<code class="fe mq mr ms mh b">path</code>属性匹配时，我们告诉React Router显示传递给<code class="fe mq mr ms mh b">component</code>属性的组件。</p><p id="3af6" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated"><code class="fe mq mr ms mh b">component</code>道具是我们之前提到的<strong class="le ir">路线渲染道具</strong>的一部分。对于如何为给定<strong class="le ir">路径</strong>渲染组件，有三个合适的选择:<code class="fe mq mr ms mh b">component</code>、<code class="fe mq mr ms mh b">render</code>和<code class="fe mq mr ms mh b">children</code>。对于这个启动项目，我们不需要考虑<strong class="le ir">渲染</strong>和<strong class="le ir">子</strong>道具。</p><p id="0379" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated"><strong class="le ir"> <em class="mz">边注</em></strong><em class="mz">:React路由器提供的</em> <strong class="le ir"> <em class="mz">路由匹配</em> </strong> <em class="mz">组件，还有</em> <strong class="le ir"> <em class="mz">交换机</em> </strong> <em class="mz">组件，不过这个我们会在我已经规划好的一些未来高级路由文章中再看。</em></p><h1 id="d4f7" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">是时候点击一些链接了</h1><p id="7af9" class="pw-post-body-paragraph lc ld iq le b lf mb lh li lj mc ll lm ln md lp lq lr me lt lu lv mf lx ly lz ij bi translated">最后，我们可以启动我们的服务器，进入我们的应用程序，开始点击链接。</p><p id="c75e" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">但是，等一下…有些事情似乎不太对劲。在主页上看起来很棒，但是当我们去博客或联系页面时，我们仍然可以看到主页上显示的内容。</p><figure class="kw kx ky kz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nd"><img src="../Images/de0b50bf3037a084f8bca2a36c02e8dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iKmhfn00M-3kMyMJpClMhg.png"/></div></div></figure><p id="9ed1" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">这是因为加载我们的<strong class="le ir"> Home </strong>组件的路径是<code class="fe mq mr ms mh b">/</code>。我们的<strong class="le ir">博客</strong>和<strong class="le ir">联系人</strong>组件的路径中也包含了<code class="fe mq mr ms mh b">/</code>字符。这意味着我们的<strong class="le ir"> Home </strong>组件总是匹配我们试图导航到的任何路径。解决方法很简单。在代表我们家内容的Route组件中，我们将添加<code class="fe mq mr ms mh b">exact</code>道具。所以我们的<strong class="le ir"> Nav.jsx </strong>文件的最终版本应该是这样的:</p><figure class="kw kx ky kz gt jr"><div class="bz fp l di"><div class="mt lb l"/></div></figure><p id="92dd" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">就这样，您现在已经掌握了使用React Router在React应用程序中构建路线的知识。</p><p id="d2ee" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">感谢您的阅读！我希望这篇文章对你有所帮助，并且你已经学到了一些新的东西。像往常一样，如果你有任何问题或建议，欢迎在评论中分享。</p></div></div>    
</body>
</html>