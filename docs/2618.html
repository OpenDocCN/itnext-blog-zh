<html>
<head>
<title>Manipulating Private Fields in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Go中操作私有字段</h1>
<blockquote>原文：<a href="https://itnext.io/manipulating-private-fields-in-go-4da4ca525717?source=collection_archive---------1-----------------------#2019-06-25">https://itnext.io/manipulating-private-fields-in-go-4da4ca525717?source=collection_archive---------1-----------------------#2019-06-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/72def74d107bfb9d29b978daca38690b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eDuyL7l8N39gsDb-KFLtog.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@tinaflour?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">克里斯蒂娜面粉</a></figcaption></figure><p id="8776" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在计算机编程的世界里，有一些事情被认为是禁忌。通常应该避免的事情。除非你有一个真正的好理由，否则你不应该做的事情。其中之一就是访问和操作代码库的私有成员。让我们来看看一个人如何在围棋中做出这样的事情。</p><h1 id="87f9" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">我说的私人成员是什么意思？</h1><p id="c4ce" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">在Go中，我们认为事物(变量、函数、方法、结构字段)要么是<em class="me">导出的</em>(公有)，要么是<em class="me">未导出的</em>(私有)。这由名称的第一个字符是大写还是小写<em class="me">来表示。</em>让事情不出口的主要原因是隐藏实现细节。这与抽象接口背后的行为的想法是一样的；你只需要关心你真正关心的事情，而不是所有的细节。例如，让我们看看<em class="me">字符串的godoc。构建器:</em></p><blockquote class="mf mg mh"><p id="4adb" class="kd ke me kf b kg kh ki kj kk kl km kn mi kp kq kr mj kt ku kv mk kx ky kz la ij bi translated">构建器用于使用Write方法高效地构建字符串。它最大限度地减少了内存复制。零值随时可以使用。不要复制非零生成器。</p></blockquote><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="45a4" class="mu lc iq mq b gy mv mw l mx my">type Builder struct {<br/>        // contains filtered or unexported fields<br/>}</span></pre><p id="8324" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如我们从godoc中看到的，这个结构似乎包含一些未导出的字段。大多数人关心这些领域是什么吗？没有。他们只关心<em class="me">构建器</em>正在帮助他们节省一些内存分配。但是假设我们真的在乎，那么我们看看实际的代码，看看这个结构对我们隐藏了什么。</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="b42d" class="mu lc iq mq b gy mv mw l mx my">type Builder struct {<br/>	addr *Builder // of receiver, to detect copies by value<br/>        buf  []byte<br/>}</span></pre><p id="e789" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">图像我们有一个非常好的用例，我们需要访问和操作内部<em class="me"> buf </em>字段的值。我们会怎么做？在一些编程语言中，你只需要使用反射就可以了。如果你需要做的只是访问字段，你可以通过使用Go中的<em class="me"> reflect </em>包来访问它。但这还不够好。我们想变得更邪恶一点，操纵缓冲区的值。要在围棋中做到这一点，我们需要看一看…</p><h1 id="896c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">危险的</h1><p id="0358" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">有了像unsafe这样的包名，你就知道事情要变得有趣了。这个包允许我们做什么？来自godoc:</p><blockquote class="mz"><p id="24de" class="na nb iq bd nc nd ne nf ng nh ni la dk translated">Package unsafe包含绕过Go程序类型安全的操作。</p><p id="e97b" class="na nb iq bd nc nd ne nf ng nh ni la dk translated">导入unsafe的包可能是不可移植的，不受Go 1兼容性指南的保护。</p></blockquote><p id="3657" class="pw-post-body-paragraph kd ke iq kf b kg nj ki kj kk nk km kn ko nl kq kr ks nm ku kv kw nn ky kz la ij bi translated">呜，听起来很有趣！这个包提供了一个<em class="me">不安全。指针</em>表示…</p><blockquote class="mf mg mh"><p id="5d1a" class="kd ke me kf b kg kh ki kj kk kl km kn mi kp kq kr mj kt ku kv mk kx ky kz la ij bi translated">…允许程序破解类型系统，读写任意内存。应该非常小心地使用它。</p></blockquote><p id="6171" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi">😈</p><p id="b1e8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我告诉你如何使用它。</p><h1 id="f5fa" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">示例时间</h1><p id="2724" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">下面是一个使用<em class="me">不安全</em>包设置未导出字段值的例子。在下面的例子中，你会发现一行一行的分析到底是怎么回事。</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="3788" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我来帮你从上到下分解一下。</p><h2 id="050c" class="mu lc iq bd ld nq nr dn lh ns nt dp ll ko nu nv lp ks nw nx lt kw ny nz lx oa bi translated">第9行</h2><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="65ac" class="mu lc iq mq b gy mv mw l mx my">const ptrSize = unsafe.Sizeof(new(int))</span></pre><p id="a56a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里我们要找出一个整数的大小。这将因底层系统的架构而异。这个值对我们很重要，因为int的大小等于用来表示Go中内存地址的大小。</p><h2 id="f4cb" class="mu lc iq bd ld nq nr dn lh ns nt dp ll ko nu nv lp ks nw nx lt kw ny nz lx oa bi translated">第12–13行</h2><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="add7" class="mu lc iq mq b gy mv mw l mx my">bs := make([]byte, 0, 7)<br/>bs = append(bs, 'u', 'n', 's', 'a', 'f', 'e')</span></pre><p id="2a6e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们声明一个缓冲区，其容量比放入其中的字节数多1。额外的空间是为稍后将被写入的一个额外字节节省空间。</p><h2 id="dc1f" class="mu lc iq bd ld nq nr dn lh ns nt dp ll ko nu nv lp ks nw nx lt kw ny nz lx oa bi translated">第15–16行</h2><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="cf9b" class="mu lc iq mq b gy mv mw l mx my">var sb strings.Builder <br/>p := unsafe.Pointer(&amp;sb)</span></pre><p id="49f5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这就是事情开始变得有趣的地方。首先我们的<em class="me">建造者</em>被声明。然后我们用<em class="me">不安全</em>包得到一个<em class="me">不安全。指针</em>指向<em class="me"> sb。变量<em class="me"> p </em>代表<em class="me"> sb </em>在内存中的位置。该变量将在下一步中使用</em></p><h2 id="8a50" class="mu lc iq bd ld nq nr dn lh ns nt dp ll ko nu nv lp ks nw nx lt kw ny nz lx oa bi translated">第17行(其中%#$！变得真实)</h2><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="7b28" class="mu lc iq mq b gy mv mw l mx my">*(*[]byte)(unsafe.Pointer(uintptr(p) + uintptr(ptrSize))) = bs</span></pre><blockquote class="mz"><p id="978f" class="na nb iq bd nc nd ob oc od oe of la dk translated">那团热是什么意思</p></blockquote><p id="58d1" class="pw-post-body-paragraph kd ke iq kf b kg nj ki kj kk nk km kn ko nl kq kr ks nm ku kv kw nn ky kz la ij bi translated">电梯间距:我们将<em class="me"> sb </em>的未导出<em class="me"> buf </em>设置为我们声明为<em class="me"> bs的字节片。</em></p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="og np l"/></div></figure><p id="e0b0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我知道这一行发生了很多事情，所以让我来帮你进一步分析一下。</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="7362" class="mu lc iq mq b gy mv mw l mx my">unsafe.Pointer(uintptr(p) + uintptr(ptrSize))</span></pre><p id="0a71" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的代码使用了<em class="me"> unsafe。指针</em>我们在前一行中得到，将它转换成一个<em class="me"> uintptr </em>并增加指针的大小到那个内存地址。然后我们得到<em class="me">不安全。指针</em>指向那个存储单元。这就是所谓的指针算法。我们知道<em class="me">字符串的内存块在哪里。构建器</em>开始(它的内存地址是<em class="me"> p </em>记住)。然后我们利用我们对内存布局的了解，对于<em class="me">构建器</em>结构，转移到另一个内存地址。只是提醒一下:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="d7c6" class="mu lc iq mq b gy mv mw l mx my">type Builder struct {<br/>	addr *Builder<br/>        buf  []byte<br/>}</span></pre><p id="98e7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们想将我们的内存地址移过<em class="me"> addr </em>并指向<em class="me"> buf </em>。<em class="me"> addr </em>是指针，所以我们把指针的大小加到<em class="me"> sb </em>的内存地址的开头。现在我们应该指向<em class="me"> buf </em>。让我们来分解这条线的其余部分。</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="6222" class="mu lc iq mq b gy mv mw l mx my">*(*[]byte)(unsafe.Pointer(uintptr(p) + uintptr(ptrSize))) = bs</span></pre><p id="91a9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">剩下的只是做一些造型让类型系统开心。我们知道这个<em class="me">不安全。指针</em>指向一个字节片。然后，我们需要取消引用该指针，以使我们的最终类型为<em class="me"> []byte。</em>一旦我们有了正确的类型，我们就可以将那个<em class="me">[]字节</em> ( <em class="me">构建器</em><em class="me"/>未导出字段<em class="me"> buf </em> ) <em class="me"> </em>设置为我们声明的字节片<em class="me"> bs。</em></p><p id="a98c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">剩下的台词只是证明了<em class="me"> bs </em>和<em class="me"> sb </em>中的底层<em class="me"> buf </em>两者是一体的。附加到一个会附加到两个(尽管你会注意到由于片头的<a class="ae kc" href="https://blog.golang.org/slices" rel="noopener ugc nofollow" target="_blank">复制，每个的长度不同)。如果你想稍微修改一下代码，你可以在操场上运行这个例子。</a></p><h1 id="2a8e" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="3092" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">你现在知道如何在围棋中击败私人访问了。不仅如此，你还知道如何操纵那些私人成员。在“真实世界”中，你会需要做这种事情吗？大概不会。但是你能做到这一点真的很酷！😎只要记住…</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="oh np l"/></div></figure><p id="d6b7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你能走到这一步，谢谢你。🙌</p></div></div>    
</body>
</html>