<html>
<head>
<title>Exploring the CSS Paint API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">探索CSS画图API</h1>
<blockquote>原文：<a href="https://itnext.io/https-medium-com-bobrov1989-exploring-the-css-paint-api-e3ab26d59218?source=collection_archive---------3-----------------------#2018-11-05">https://itnext.io/https-medium-com-bobrov1989-exploring-the-css-paint-api-e3ab26d59218?source=collection_archive---------3-----------------------#2018-11-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/215c016961946bf88d6baeca6b26a87f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FJNhwMWv4SfweqlYmapNUA@2x.jpeg"/></div></div></figure><div class=""/><p id="022f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">CSS Paint API是Houdini项目的第一部分，可在浏览器的稳定版本中使用。It谷歌Chrome团队在3月6日将其添加到Chrome 65中。这就是为什么这是一个很好的时间去尝试和开始实验。我想让你开始做自己的实验。</p><h1 id="10f3" class="kw kx jb bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">胡迪尼是什么？</h1><p id="1565" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">在我们开始探索CSS Paint API之前，让我简单介绍一下Houdini项目。我不会说太多的细节，但是如果你想了解更多，我会给你提供资源链接。</p><p id="b55f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，Houdini是一组API，允许您与CSS引擎内部进行交互。不幸的是，在此之前，我们仅限于通过JavaScript使用CSSOM (CSS对象模型)的某个部分。所以我们可以用JS尝试polyfill CSS，但是要在浏览器渲染stage之后。并且在改变之后，浏览器需要再次执行屏幕渲染。但是有了Houdini，我们可以像对待JS一样扩展样式。</p><p id="1b4a" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Houdini APIs在这里与CSS解析器、CSSOM、级联、布局、绘画和复合渲染阶段一起工作。API有两大类:CSS属性&amp;值和工作小程序。worklets涵盖了渲染状态访问:布局、绘制和合成。当属性和值关注于解析器扩展时，使用CSSOM和cascade。你可以在这里查看每个API <a class="ae lz" href="https://ishoudinireadyyet.com/" rel="noopener ugc nofollow" target="_blank">的浏览器实现状态，在这里</a>查看更多相关信息<a class="ae lz" href="https://developers.google.com/web/updates/2016/05/houdini" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="8a25" class="kw kx jb bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">CSS画图小工具</h1><p id="3339" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">CSS画图API是一种worklets，你怎么能理解它的名字与画图渲染过程。它是做什么的？它允许你用JavaScript创建自定义的CSS函数来绘制图像作为背景。然后对任何需要图像的CSS属性使用这个函数。比如你可以用它来做<code class="fe ma mb mc md b">background-image</code>、<code class="fe ma mb mc md b">border-image</code>或者<code class="fe ma mb mc md b">list-style-image</code>。但更令人兴奋的是，它还可以用于自定义CSS属性，我们稍后将回到它们。</p><p id="1c2f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于用JavaScript画图，您允许使用受限版本的Canvas API。为什么有限？出于安全原因，您不能从图像中读取像素或呈现文本。但是你可以画圆弧，矩形，路径等等。</p><h1 id="26ed" class="kw kx jb bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">为什么我们需要CSS画图API？</h1><p id="e33d" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">目前我脑海中有几个用例:</p><ol class=""><li id="cab0" class="me mf jb ka b kb kc kf kg kj mg kn mh kr mi kv mj mk ml mm bi translated">CSS polyfill——当然，我们可以用JavaScript为CSS编写poly fill，但就可用性和性能而言，这不是一个好主意。你可以在这里读到一些关于那个<a class="ae lz" href="https://philipwalton.com/articles/the-dark-side-of-polyfilling-css/" rel="noopener ugc nofollow" target="_blank">的想法。但是CSS Paint是一个很好的选择，例如，看看<code class="fe ma mb mc md b">conic-gradient</code> </a><a class="ae lz" href="https://lab.iamvdo.me/houdini/conic-gradient" rel="noopener ugc nofollow" target="_blank"> polyfill示例</a>。</li><li id="ab60" class="me mf jb ka b kb mn kf mo kj mp kn mq kr mr kv mj mk ml mm bi translated">减少DOM节点数量——有时我们需要添加虚拟的DOM节点，比如仅仅为了视觉效果的<code class="fe ma mb mc md b">span</code>。此外，一些动画可能需要额外的元素。找实现材质设计的画师【涟漪】<a class="ae lz" href="https://lab.iamvdo.me/houdini/ripple" rel="noopener ugc nofollow" target="_blank">动画</a>。在原始材质设计库中，它为该动画创建了两个额外的<code class="fe ma mb mc md b">span</code>元素，而使用worklet则不需要这样做。现在假设页面上有10个具有“涟漪”效果的按钮，CSS paint为您节省了20个DOM节点。</li><li id="b375" class="me mf jb ka b kb mn kf mo kj mp kn mq kr mr kv mj mk ml mm bi translated">花哨的背景——你可以用不同寻常的图案和背景为最终用户创造某种新的体验。好在它们不会影响性能，可以作为渐进增强的一部分。</li></ol><h1 id="ce19" class="kw kx jb bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">如何在样式中使用CSS画图？</h1><p id="e972" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">要在样式表中使用自定义画图，您需要使用<code class="fe ma mb mc md b">paint</code>函数，并传递您的画图名称，以及任何接下来需要的参数。下面是它可能的样子:</p><figure class="ms mt mu mv gt is"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="2505" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上面的例子中，我们使用了名为<code class="fe ma mb mc md b">my-custom-paint</code>的自定义画图，接下来让我们想象它允许我们传递额外的参数，比如颜色:</p><figure class="ms mt mu mv gt is"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="0d3f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">看起来和我们的一些CSS内置函数也很相似，比如<code class="fe ma mb mc md b">linear-gradient</code>:</p><figure class="ms mt mu mv gt is"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="e066" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于<code class="fe ma mb mc md b">paint</code>只是CSS声明的一个值，所以对于带有纯色或图像的旧浏览器来说很容易将其退回:</p><figure class="ms mt mu mv gt is"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="1d44" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">或者我们可以检查CSS中的浏览器支持:</p><figure class="ms mt mu mv gt is"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="f3a6" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这种情况下，不支持CSS Paint API的浏览器将忽略最后一个<code class="fe ma mb mc md b">background-image</code>声明，而使用一些静态图像。</p><p id="6bce" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是，如果我们将创建一些广泛使用的画师，这将是伟大的自动化回退插入，因为人类可能会忘记它。我有一个好消息要告诉你，PostCSS可以用一个插件为我们做这件事。要编写这样一个插件，我们不需要很多行代码。PostCSS为我们提供了一堆方便的助手工具来遍历CSS AST(抽象语法树)并操作它。下面是这样一个插件的例子，它用一个作为<code class="fe ma mb mc md b">fallbackValue</code>选项传递的静态回退值来替换自定义绘画:</p><figure class="ms mt mu mv gt is"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="0d8d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个插件将遍历所有CSS规则，然后遍历其中的所有声明。它查找<code class="fe ma mb mc md b">my-css-paint</code>调用，并在替换值之前插入克隆的语句以进行回退。不是那个🚀科学，不是吗？</p><h1 id="a002" class="kw kx jb bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">如何创建自定义CSS画图？</h1><p id="8b02" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">那么如何创建自定义CSS画图呢？只需三个步骤:</p><ol class=""><li id="ebc7" class="me mf jb ka b kb kc kf kg kj mg kn mh kr mi kv mj mk ml mm bi translated">声明一个自定义绘制类</li><li id="7e84" class="me mf jb ka b kb mn kf mo kj mp kn mq kr mr kv mj mk ml mm bi translated">注册油漆</li><li id="5aa8" class="me mf jb ka b kb mn kf mo kj mp kn mq kr mr kv mj mk ml mm bi translated">加载工作流</li></ol><p id="41bc" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以，首先我们要声明CSS画图类。它应该是一个带有<code class="fe ma mb mc md b">paint</code>方法的JavaScript类。我们稍后将探讨这种方法及其参数，现在只看基本实现:</p><figure class="ms mt mu mv gt is"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="b0c4" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">之后我们需要注册新定义的画师:</p><figure class="ms mt mu mv gt is"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="9c36" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们使用了<code class="fe ma mb mc md b">registerPaint</code>函数，将paint name作为第一个参数，将我们的类引用作为第二个参数。在这里，我想注意到我们的paint模块文件与类和注册调用有一个单独的上下文。这意味着我们不能访问全局浏览器范围内的任何函数或变量，甚至不能加载任何依赖脚本。</p><p id="61de" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，最后一步是加载worklet，这样之后，您就可以在样式表中使用它了:</p><figure class="ms mt mu mv gt is"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="9d08" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，我们检查<code class="fe ma mb mc md b">paintWorklet</code>在浏览器中是否可用，然后注册我们的自定义画图，调用<code class="fe ma mb mc md b">CSS.paintWorklet</code>上唯一可用的方法<code class="fe ma mb mc md b">addModule</code>。它接受一个参数——我们的worklet JavaScript文件的路径。在这里，您还可以通过一个额外的<code class="fe ma mb mc md b">else</code>语句选择CSS Paint的基于JavaScript的回退。</p><p id="8a31" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里应该如何看待最终结果:</p><figure class="ms mt mu mv gt is"><div class="bz fp l di"><div class="mw mx l"/></div></figure><h1 id="bc06" class="kw kx jb bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">实践</h1><p id="8cb0" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">画图API介绍完后，最好的想法就是尝试一下。让我们从第一个例子开始——创建一个绘制几个圆圈作为背景的画师。首先，让我们为paint定义一个类并注册它:</p><figure class="ms mt mu mv gt is"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="e41d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们用名为<code class="fe ma mb mc md b">paint</code>的方法创建了<code class="fe ma mb mc md b">CirclesPainter</code>类。这个方法接受两个参数:<code class="fe ma mb mc md b">ctx</code>和<code class="fe ma mb mc md b">geom</code>对象，前者是我们的画布上下文，后者由两个属性组成。<code class="fe ma mb mc md b">geom</code>包含我们画布表面的<code class="fe ma mb mc md b">width</code>和<code class="fe ma mb mc md b">height</code>。然后使用我们的上下文，我们在循环中画四个圆，并用蓝色填充它们。最后，我们在页面上加载我们的工作流:</p><figure class="ms mt mu mv gt is"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="74f2" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了使用它，我们用类名<code class="fe ma mb mc md b">circles</code>创建了简单的<code class="fe ma mb mc md b">div</code>，并在样式表中添加了后续规则:</p><figure class="ms mt mu mv gt is"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="5111" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以我们把它做成方形，并添加黑色作为老浏览器的备用颜色。就是这样！你可以在GitHub上查看<a class="ae lz" href="https://vitaliy-bobrov.github.io/css-paint-demos/hello-world/" rel="noopener ugc nofollow" target="_blank">结果</a>和<a class="ae lz" href="https://github.com/vitaliy-bobrov/css-paint-demos/tree/master/src/hello-world" rel="noopener ugc nofollow" target="_blank">代码</a>。这是演示:</p><figure class="ms mt mu mv gt is"><div class="bz fp l di"><div class="my mx l"/></div></figure><p id="90a2" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我现在要提到的一件事是，我们没有添加任何resize事件监听器，但是浏览器会在任何布局改变时自动调用<code class="fe ma mb mc md b">paint</code>方法。当前的Chrome实现使用主UI线程进行绘画渲染，但在未来，它将使用一个单独的线程。可以想象一些沉重的动画或者背景，对主线程的影响为零。这将是一个巨大的性能提升！</p><p id="48f9" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您的背景可能是响应性的，这种响应性取决于元素本身的大小，没有任何关于<code class="fe ma mb mc md b">resize</code>事件的监听器。直到<code class="fe ma mb mc md b">element queries</code>还在提议你可以根据元素大小生成不同的图片。用<a class="ae lz" href="https://github.com/vitaliy-bobrov/css-paint-demos/tree/master/src/responsive" rel="noopener ugc nofollow" target="_blank">源代码</a>试用<a class="ae lz" href="https://vitaliy-bobrov.github.io/css-paint-demos/responsive/" rel="noopener ugc nofollow" target="_blank">这个例子</a>。当元素改变尺寸时，我们用另一种颜色填充我们的圆。</p><p id="8051" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这一切都很好，但接下来我想让我们的绘画可配置。所以让我介绍几个CSS变量:</p><ul class=""><li id="2626" class="me mf jb ka b kb kc kf kg kj mg kn mh kr mi kv mz mk ml mm bi translated"><code class="fe ma mb mc md b">--circles-offset</code>–控制圆圈之间的距离</li><li id="6901" class="me mf jb ka b kb mn kf mo kj mp kn mq kr mr kv mz mk ml mm bi translated"><code class="fe ma mb mc md b">--circles-count</code>–表示要渲染的圆的数量</li><li id="e9e1" class="me mf jb ka b kb mn kf mo kj mp kn mq kr mr kv mz mk ml mm bi translated"><code class="fe ma mb mc md b">--circles-opacity</code>–改变圆圈的不透明度</li></ul><p id="905f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有了这些变量，我们就能创造出一些可以随时间变化的模式。为了访问painter类中的CSS变量，我们需要定义名为<code class="fe ma mb mc md b">inputProperties</code>的静态属性。它应该是我们希望在<code class="fe ma mb mc md b">paint</code>方法中定位的CSS属性和变量的<code class="fe ma mb mc md b">Array</code>。对数组中的每个属性进行更改，浏览器将为我们调用render，而无需任何额外的代码行。下面是更新后的<code class="fe ma mb mc md b">CirclesPainter</code>:</p><figure class="ms mt mu mv gt is"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="3f4c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以我们为<code class="fe ma mb mc md b">inputProperties</code>添加了getter，它返回我们想要使用的CSS变量列表。然后，我们可以访问我们用<code class="fe ma mb mc md b">props</code>参数订阅的所有属性。它包含带有值的属性的CSS映射。我们用变量名调用<code class="fe ma mb mc md b">get</code>方法来获取它的值作为<code class="fe ma mb mc md b">string</code>。此外，我们定义了一些缺省值，即使它们没有在样式中指定。我们用这个值来动态渲染圆形。</p><p id="79df" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们应该用变量来更新样式:</p><figure class="ms mt mu mv gt is"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="8c2c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在此检查<a class="ae lz" href="https://github.com/vitaliy-bobrov/css-paint-demos/tree/master/src/circles-with-params" rel="noopener ugc nofollow" target="_blank">代码</a>和<a class="ae lz" href="https://vitaliy-bobrov.github.io/css-paint-demos/circles-with-params/" rel="noopener ugc nofollow" target="_blank">结果</a>。</p><figure class="ms mt mu mv gt is"><div class="bz fp l di"><div class="na mx l"/></div></figure><p id="e8c4" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于GitHub演示，我添加了一个简单的脚本来连接CSS变量和输入控件，你可以在这里找到它<a class="ae lz" href="https://github.com/vitaliy-bobrov/css-paint-demos/blob/master/src/js/update-css-variable.js" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="d488" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以现在我们可以在运行时修改渲染参数，只需用CSS或JavaScript更新变量。但是如果我们看看像<code class="fe ma mb mc md b">linear-gradient</code>这样的内置CSS函数，它们接受传递额外的参数给函数本身:</p><figure class="ms mt mu mv gt is"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="46ac" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们是否也可以为自定义绘画实现相同的行为？答案是——是的！为此，我们需要使用另一个Houdini API，它仍然是Chrome中的一个实验。它被称为CSS类型化OM，它允许你使用内置的CSS引擎类型，如颜色，图像，长度等。然后我们可以将它们作为参数传递给<code class="fe ma mb mc md b">paint</code>函数。</p><p id="c917" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于功能现在仍处于实验阶段，我们需要在Chrome中启用“实验网络平台功能”标志。转到<code class="fe ma mb mc md b">chrome://flags/#enable-experimental-web-platform-features</code>并启用它。</p><p id="0999" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">之后，我们应该向我们的paint类添加一个新的静态属性— <code class="fe ma mb mc md b">inputArguments</code>。像<code class="fe ma mb mc md b">inputProperties</code>一样，它订阅对所列参数的任何更改，但应该包含一组CSS类型。让我们用参数替换CSS变量:</p><figure class="ms mt mu mv gt is"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="97cf" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以我们的<code class="fe ma mb mc md b">CirclesPainter</code>现在包括了包含三个参数的<code class="fe ma mb mc md b">inputArguments</code>列表:<code class="fe ma mb mc md b">&lt;number&gt;</code>、<code class="fe ma mb mc md b">&lt;number&gt;</code>和<code class="fe ma mb mc md b">&lt;percentage&gt;</code>。您可能会提到CSS类型的语法-<code class="fe ma mb mc md b">&lt;type name&gt;</code>。此外，您可以在TypeScript–<code class="fe ma mb mc md b">&lt;number | percentage&gt;</code>中以尽可能相似的方式接受类型联合。你可以在“CSS值和单位”规范草案<a class="ae lz" href="https://drafts.csswg.org/css-values-4" rel="noopener ugc nofollow" target="_blank">中找到所有可用的类型。</a></p><p id="1219" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后在<code class="fe ma mb mc md b">paint</code>方法中，我们得到了类似于JavaScript函数<code class="fe ma mb mc md b">arguments</code>对象的<code class="fe ma mb mc md b">args</code>参数，但是只有<code class="fe ma mb mc md b">Array</code>包含了<code class="fe ma mb mc md b">CSSUnitValue</code>对象。每个单元对象由两个属性<code class="fe ma mb mc md b">value</code>和<code class="fe ma mb mc md b">unit</code>组成。所以在我们的例子中，我们访问了每个参数的所有值。我们应该修改我们的CSS来使用它:</p><figure class="ms mt mu mv gt is"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="2dc6" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在此查看<a class="ae lz" href="https://github.com/vitaliy-bobrov/css-paint-demos/tree/master/src/circles-with-args" rel="noopener ugc nofollow" target="_blank">代码</a>和<a class="ae lz" href="https://vitaliy-bobrov.github.io/css-paint-demos/circles-with-args/" rel="noopener ugc nofollow" target="_blank">结果</a>。</p><h1 id="cff7" class="kw kx jb bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">动画片</h1><p id="c767" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">这很酷，但是我们如何为一个画家创造动画呢？正如我之前所说的，我们的worklets在一个单独的上下文中执行，没有<code class="fe ma mb mc md b">requestAnimationFrame</code>甚至没有<code class="fe ma mb mc md b">setTimeout</code>函数。如何实现动画？第一种解决方案是使用CSS变量。让我们试着用CSS来制作动画:</p><figure class="ms mt mu mv gt is"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="815d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">而且…这个解决方案不会像我们预期的那样工作。它只是在50%点将不透明度从1切换到0。但是为什么呢？答案很简单，所有CSS变量都只是字符串，它们类似于SASS或更低版本中的变量——变量被简单的字符串插值替换为值。为了制作动画，一些CSS属性浏览器需要应用插值函数，但它不知道如何将一个字符串插值到另一个字符串。它有唯一的内置功能来动画颜色，长度，数字，但不是字符串。这就是为什么它只在50%切换值。在这种情况下，我们可以使用<code class="fe ma mb mc md b">requestAnimationFrame</code>用JavaScript动画化变量。这样的脚本可能如下所示:</p><figure class="ms mt mu mv gt is"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="a118" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">不太好，我们能做得更好吗？是的，使用自定义属性API。这个API现在也在Chrome的旗帜下，所以不要忘记启用它。它允许我们用类似于变量的语法注册自定义CSS属性，但这次是用分配给它的CSS类型。因此，浏览器将有一个关于如何动画的想法，我们可以使用CSS动画和过渡！</p><p id="f019" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以要注册自定义属性，我们需要调用<code class="fe ma mb mc md b">CSS.registerProperty</code>并传递options对象:</p><figure class="ms mt mu mv gt is"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="d780" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如你所看到的，我们需要用<code class="fe ma mb mc md b">name</code>选项给属性命名。然后我们用<code class="fe ma mb mc md b">syntax</code>属性指定它的类型，另外我们说子节点和初始值不会100%继承它。</p><p id="aefb" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">之后，我们可以在样式表中使用新创建的自定义属性:</p><figure class="ms mt mu mv gt is"><div class="bz fp l di"><div class="mw mx l"/></div></figure><figure class="ms mt mu mv gt is"><div class="bz fp l di"><div class="my mx l"/></div></figure><p id="cf61" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们可以使用<code class="fe ma mb mc md b">transition</code>平滑地改变圆形的不透明度。在这里查看<a class="ae lz" href="https://github.com/vitaliy-bobrov/css-paint-demos/tree/master/src/circles-animation-with-custom-property" rel="noopener ugc nofollow" target="_blank">代码</a>和<a class="ae lz" href="https://vitaliy-bobrov.github.io/css-paint-demos/circles-animation-with-custom-property/" rel="noopener ugc nofollow" target="_blank">结果</a>。</p><h1 id="8895" class="kw kx jb bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">结论</h1><p id="e2cb" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">今天开始学习CSS画图API，探索如何创建自己的画图，如何使用输入属性和参数，CSS变量和自定义属性，以及如何制作动画。在下一篇文章中，我将使用从那篇文章中获得的知识实现更多的生产就绪示例。如果你正在使用最新的Chrome阅读这篇文章，你可能会提到我正在使用定制油漆来制作材料设计背景，你可以在这里查看<a class="ae lz" href="https://vitaliy-bobrov.github.io/css-paint-demos/md-bg/" rel="noopener ugc nofollow" target="_blank">和查看</a><a class="ae lz" href="https://github.com/vitaliy-bobrov/css-paint-demos/tree/master/src/md-bg" rel="noopener ugc nofollow" target="_blank">代码</a>。自己尝试CSS画图API吧！</p><h1 id="dec7" class="kw kx jb bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">资源</h1><ul class=""><li id="be33" class="me mf jb ka b kb lu kf lv kj nb kn nc kr nd kv mz mk ml mm bi translated"><a class="ae lz" href="https://developers.google.com/web/updates/2018/01/paintapi" rel="noopener ugc nofollow" target="_blank">开发者谷歌</a></li><li id="367f" class="me mf jb ka b kb mn kf mo kj mp kn mq kr mr kv mz mk ml mm bi translated"><a class="ae lz" href="https://drafts.css-houdini.org/css-paint-api/​" rel="noopener ugc nofollow" target="_blank">胡迪尼选秀</a></li><li id="0145" class="me mf jb ka b kb mn kf mo kj mp kn mq kr mr kv mz mk ml mm bi translated"><a class="ae lz" href="https://www.w3.org/TR/css-paint-api-1/​" rel="noopener ugc nofollow" target="_blank"> W3C CSS画稿</a></li><li id="2018" class="me mf jb ka b kb mn kf mo kj mp kn mq kr mr kv mz mk ml mm bi translated"><a class="ae lz" href="https://lab.iamvdo.me/houdini/" rel="noopener ugc nofollow" target="_blank">演示</a></li><li id="fb8e" class="me mf jb ka b kb mn kf mo kj mp kn mq kr mr kv mz mk ml mm bi translated"><a class="ae lz" href="https://vitaliy-bobrov.github.io/css-paint-demos/​" rel="noopener ugc nofollow" target="_blank">我的演示</a></li></ul></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><p id="4992" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="nl">原载于</em><a class="ae lz" href="https://vitaliy-bobrov.github.io/blog/exploring-the-css-paint-api/" rel="noopener ugc nofollow" target="_blank"><em class="nl">vitaliy-bobrov . github . io</em></a><em class="nl">。</em></p></div></div>    
</body>
</html>