<html>
<head>
<title>Five minutes to understand async and defer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">五分钟了解异步和延迟</h1>
<blockquote>原文：<a href="https://itnext.io/five-minutes-to-understand-async-and-defer-67719f289680?source=collection_archive---------5-----------------------#2018-03-11">https://itnext.io/five-minutes-to-understand-async-and-defer-67719f289680?source=collection_archive---------5-----------------------#2018-03-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/3058740061a2d6b5576e49a1998aa761.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q7nb-owwLC4MMYZTlyFZ7w.png"/></div></div></figure><h1 id="9100" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">脚本标签</h1><p id="881c" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">当我们想在网页中插入脚本时，标准的方式是使用脚本标签(即<script>)。人们对脚本标签的第一印象是— &lt;strong class="ky ir"&gt;屏蔽&lt;/strong&gt;。这本书&lt;a class="ae lu" href="https://www.amazon.com/High-Performance-Web-Sites-Essential/dp/0596529309/ref=sr_1_1?s=books&amp;amp;ie=UTF8&amp;amp;qid=1521248657&amp;amp;sr=1-1&amp;amp;keywords=high+performance+websites" rel="noopener ugc nofollow" target="_blank"&gt;高性能网站&lt;/a&gt;规则6建议将脚本放在html主体的底部。本文将研究将脚本放在不同的位置如何影响性能，以及&lt;em class="lv"&gt; async &lt;/em&gt;和&lt;em class="lv"&gt; defer &lt;/em&gt;属性如何为脚本标签工作。&lt;/root&gt;</script></p><p id="1068" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">首先，当一个脚本在html页面中被引用时，浏览器会为您做两件事:</p><ul class=""><li id="74bf" class="mb mc iq ky b kz lw ld lx lh md ll me lp mf lt mg mh mi mj bi translated">检索/加载脚本内容，这是非阻塞的！</li><li id="4701" class="mb mc iq ky b kz mk ld ml lh mm ll mn lp mo lt mg mh mi mj bi translated">运行脚本内容，这是屏蔽！</li></ul><p id="d678" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">假设页面上有两个脚本:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="e4ca" class="my jz iq mu b gy mz na l nb nc">//script1.js<br/>let t1 = +new Date;<br/>console.log('script1 is running at', t1);</span><span id="8b19" class="my jz iq mu b gy nd na l nb nc">console.log('script1 element', document.getElementById('load-experiment'));<br/>while((+new Date) - t1 &lt; 1000) {<br/>    // delay 1 seconds<br/>}<br/>console.log('script1 finishes running at', +new Date);</span><span id="6027" class="my jz iq mu b gy nd na l nb nc">//script2.js<br/>let t2 = +new Date;<br/>console.log('script2 is running at', t2);</span><span id="1870" class="my jz iq mu b gy nd na l nb nc">console.log('script2 element', document.getElementById('load-experiment'));<br/>while((+new Date) - t2 &lt; 2000) {<br/>    // delay 2 seconds<br/>}<br/>console.log('script2 finishes running at', +new Date);</span></pre><h1 id="2f32" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">将脚本标签放在头部</h1><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="9fcd" class="my jz iq mu b gy mz na l nb nc">&lt;!--all-in-head.html--&gt;<br/>&lt;html&gt;<br/>    &lt;head&gt;<br/>        &lt;title&gt; test js tag async and defer attributes&lt;/title&gt;<br/>        &lt;script src='./script1.js'&gt;&lt;/script&gt;<br/>        &lt;script src='./script2.js'&gt;&lt;/script&gt;<br/>    &lt;/head&gt;<br/>    &lt;body&gt;<br/>        &lt;h1 id='load-experiment'&gt; hello world &lt;/h1&gt;<br/>    &lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="50ee" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">控制台输出:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="b358" class="my jz iq mu b gy mz na l nb nc">script1 is running at 1496747869008<br/>script1.js:4 script1 element null<br/>script1.js:8 script1 finishes running at 1496747870008<br/>script2.js:2 script2 is running at 1496747870009<br/>script2.js:4 script2 element null<br/>script2.js:8 script2 finishes running at 1496747872009</span></pre><p id="bece" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">结论:</p><ul class=""><li id="2742" class="mb mc iq ky b kz lw ld lx lh md ll me lp mf lt mg mh mi mj bi translated">当我们在浏览器中打开html时，我们可以注意到页面加载的延迟。页面在正确呈现之前会变成空白。这是因为两个脚本的运行阻塞了DOM呈现。</li><li id="a1d1" class="mb mc iq ky b kz mk ld ml lh mm ll mn lp mo lt mg mh mi mj bi translated">当脚本运行时，它们无法获取DOM元素(即document . getelementbyid(' load-experiment ')为空)。这是因为脚本是在DOM呈现之前运行的。</li><li id="fa2e" class="mb mc iq ky b kz mk ld ml lh mm ll mn lp mo lt mg mh mi mj bi translated">脚本本身是互相屏蔽的。它们按照html中指定的顺序运行。Script2在script1完成运行后运行。</li></ul><h1 id="12da" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">将脚本标签放在正文的底部</h1><p id="a525" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">这是《高性能网站》一书第六条规则的建议。</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="69f2" class="my jz iq mu b gy mz na l nb nc">&lt;!--all-in-body.html--&gt;<br/>&lt;html&gt;<br/>    &lt;head&gt;<br/>        &lt;title&gt; test js tag async and defer attributes&lt;/title&gt;<br/>    &lt;/head&gt;<br/>    &lt;body&gt;<br/>        &lt;h1 id='load-experiment'&gt; hello world &lt;/h1&gt;<br/>        &lt;script src='./script1.js'&gt;&lt;/script&gt;<br/>        &lt;script src='./script2.js'&gt;&lt;/script&gt;<br/>    &lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="f395" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">控制台输出:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="350e" class="my jz iq mu b gy mz na l nb nc">script1 is running at 1496751597679<br/>script1.js:4 script1 element &lt;h1 id=​"load-experiment"&gt;​ hello world ​&lt;/h1&gt;​<br/>script1.js:8 script1 finishes running at 1496751598679<br/>script2.js:2 script2 is running at 1496751598680<br/>script2.js:4 script2 element &lt;h1 id=​"load-experiment"&gt;​ hello world ​&lt;/h1&gt;​<br/>script2.js:8 script2 finishes running at 1496751600680</span></pre><p id="6574" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">结论:</p><ul class=""><li id="263a" class="mb mc iq ky b kz lw ld lx lh md ll me lp mf lt mg mh mi mj bi translated">在浏览器中打开页面时没有页面延迟和空白页面，因为脚本是在DOM准备好之后放置/运行的。</li><li id="c24c" class="mb mc iq ky b kz mk ld ml lh mm ll mn lp mo lt mg mh mi mj bi translated">脚本可以正确地获取DOM元素。</li><li id="da30" class="mb mc iq ky b kz mk ld ml lh mm ll mn lp mo lt mg mh mi mj bi translated">脚本本身互相阻塞，和第一个例子一样。</li></ul><p id="0b06" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">然而，将所有脚本放在body的底部有时并不适合一些特定的实际情况。例如，如果我们的目标是计算页面的ATF[<a class="ae lu" href="https://en.wikipedia.org/wiki/Above_the_fold" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Above_the_fold</a>]，我们不能简单地等待DOM的渲染。我们必须预先加载并运行一些脚本，然后在ATF准备好的时候触发ATF标记，这肯定是在DOM为具有滚动内容的网页做好准备之前。所以，想出下一个解决方案似乎也在情理之中。</p><h1 id="d69c" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">根据需求将脚本分别放在头部和身体中。</h1><p id="5476" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">把需要预运行的脚本放在头部，其他的放在身体的底部。例如</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="6a96" class="my jz iq mu b gy mz na l nb nc">&lt;html&gt; <br/>    &lt;head&gt; <br/>        &lt;script src="headScripts.js"&gt;&lt;/scripts&gt; <br/>    &lt;/head&gt; <br/>    &lt;body&gt;<br/>        &lt;h1 id='load-experiment'&gt; hello world &lt;/h1&gt;<br/>        &lt;script src="bodyScripts.js"&gt;&lt;/script&gt; <br/>    &lt;/body&gt;<br/>&lt;/html&gt;</span></pre><h1 id="f2c9" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">推迟！</h1><p id="c27f" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">将脚本放在主体底部的主要缺点是，脚本只有在DOM呈现后才能被检索/加载。正如我们所说，检索/加载脚本内容是非阻塞的，而运行脚本内容是阻塞的部分。如果我们可以在DOM渲染时检索/加载脚本，而不是等待DOM完成渲染，那么我们就可以提高web性能。这非常有效，尤其是当脚本很大的时候。这就是为什么引入了<em class="lv">延迟</em>的原因。<em class="lv">延迟</em>同时加载脚本，但是只在DOM准备好之后运行脚本。</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="9221" class="my jz iq mu b gy mz na l nb nc">&lt;!--defer.html--&gt;<br/>&lt;html&gt;<br/>    &lt;head&gt;<br/>        &lt;title&gt; test js tag async and defer attributes&lt;/title&gt;<br/>        &lt;script defer src='./script1.js'&gt;&lt;/script&gt;<br/>        &lt;script defer src='./script2.js'&gt;&lt;/script&gt;<br/>    &lt;/head&gt;<br/>    &lt;body&gt;<br/>        &lt;h1 id='load-experiment'&gt; hello world &lt;/h1&gt;<br/>    &lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="dc75" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">控制台输出:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="f840" class="my jz iq mu b gy mz na l nb nc">script1 is running at 1496760312686<br/>script1.js:4 script1 element &lt;h1 id=​"load-experiment"&gt;​ hello world ​&lt;/h1&gt;​<br/>script1.js:8 script1 finishes running at 1496760313686<br/>script2.js:2 script2 is running at 1496760313686<br/>script2.js:4 script2 element &lt;h1 id=​"load-experiment"&gt;​ hello world ​&lt;/h1&gt;​<br/>script2.js:8 script2 finishes running at 1496760315686</span></pre><p id="9bc2" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">结论:</p><ul class=""><li id="5a39" class="mb mc iq ky b kz lw ld lx lh md ll me lp mf lt mg mh mi mj bi translated">结果和把脚本放在主体的底部是一样的。我们可以从结果中得出结论，脚本是在DOM准备好之后运行的，因为我们确实可以获取DOM元素。</li><li id="f2d0" class="mb mc iq ky b kz mk ld ml lh mm ll mn lp mo lt mg mh mi mj bi translated">甚至<em class="lv">延迟的</em>脚本也遵循html中指定的顺序规则，脚本1在脚本2之后运行。</li></ul><h1 id="d0f7" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">异步！</h1><p id="38fb" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">网页通常包含一些严格独立的附加功能，而不是必须具备的功能，例如某些页面上的评论和聊天功能。由于特征是独立的，它们没有运行顺序的限制。在这种情况下，我们可以使用<em class="lv">异步</em></p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="6f9b" class="my jz iq mu b gy mz na l nb nc">&lt;!--async.html--&gt;<br/>&lt;html&gt;<br/>    &lt;head&gt;<br/>        &lt;title&gt; test js tag async and defer attributes&lt;/title&gt;<br/>    &lt;/head&gt;<br/>    &lt;body&gt;<br/>        &lt;h1 id='load-experiment'&gt; hello world &lt;/h1&gt;<br/>        &lt;script async src='./script1.js'&gt;&lt;/script&gt;<br/>        &lt;script async src='./script2.js'&gt;&lt;/script&gt;<br/>    &lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="5d4c" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">刷新页面时，我们可以观察到不同的控制台输出:</p><ul class=""><li id="da90" class="mb mc iq ky b kz lw ld lx lh md ll me lp mf lt mg mh mi mj bi translated">脚本1和脚本2的运行顺序不同</li><li id="4991" class="mb mc iq ky b kz mk ld ml lh mm ll mn lp mo lt mg mh mi mj bi translated">提取DOM元素的结果不一致</li></ul><p id="82fc" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">由于异步脚本不能保证运行顺序，这通常是潜在隐藏错误的来源。在使用async之前要三思，确保这些脚本是严格独立的。</p><h1 id="4002" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">结论</h1><p id="f388" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">导入脚本的一般规则是:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="0188" class="my jz iq mu b gy mz na l nb nc">&lt;html&gt; <br/>    &lt;head&gt; <br/>        &lt;!--headScripts.js is the script that has to be loaded and run before DOM is ready--&gt;<br/>        &lt;script src="headScripts.js"&gt;&lt;/scripts&gt; <br/>        &lt;!--bodyScripts.js loads first and runs after DOM is ready--&gt;<br/>        &lt;script defer src="bodyScripts.js"&gt;&lt;/script&gt; <br/>    &lt;/head&gt; <br/>    &lt;body&gt;<br/>        &lt;!--body content--&gt;<br/>        &lt;h1 id='load-experiment'&gt; hello world &lt;/h1&gt;<br/>        &lt;!--independent scripts，nice-to-have --&gt;<br/>        &lt;script async src="forumWidget.js"&gt;&lt;/script&gt;<br/>        &lt;script async src="chatWidget.js"&gt;&lt;/script&gt;<br/>    &lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="4431" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated"><a class="ae lu" href="https://github.com/n0ruSh/the-art-of-reading/tree/master/javascript/Async%20Javascript/defer-async" rel="noopener ugc nofollow" target="_blank">代码示例</a></p><h1 id="c7cd" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">参考</h1><ul class=""><li id="0963" class="mb mc iq ky b kz la ld le lh ne ll nf lp ng lt mg mh mi mj bi translated"><a class="ae lu" href="https://www.amazon.com/Async-JavaScript-Responsive-Pragmatic-Express-ebook/dp/B00AKM4RVG" rel="noopener ugc nofollow" target="_blank">异步JavaScript </a></li><li id="ecb3" class="mb mc iq ky b kz mk ld ml lh mm ll mn lp mo lt mg mh mi mj bi translated"><a class="ae lu" href="https://www.amazon.com/High-Performance-Web-Sites-Essential/dp/0596529309/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1521248657&amp;sr=1-1&amp;keywords=high+performance+websites" rel="noopener ugc nofollow" target="_blank">高性能网站</a></li></ul><h1 id="4ece" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">通知；注意</h1><ul class=""><li id="055a" class="mb mc iq ky b kz la ld le lh ne ll nf lp ng lt mg mh mi mj bi translated">读书笔记系列如果想关注最新的新闻/文章，请<a class="ae lu" href="https://github.com/n0ruSh/the-art-of-reading" rel="noopener ugc nofollow" target="_blank">【观看】</a>订阅。</li></ul></div></div>    
</body>
</html>