<html>
<head>
<title>Implementing a Frontend with Micro-Components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用微元件实现前端</h1>
<blockquote>原文：<a href="https://itnext.io/micro-frontend-941a5f1a3e72?source=collection_archive---------3-----------------------#2019-09-08">https://itnext.io/micro-frontend-941a5f1a3e72?source=collection_archive---------3-----------------------#2019-09-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="0ab5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在你给我这个表情之前…</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/73356d7d432f11d807b3ce30427fe60f.png" data-original-src="https://miro.medium.com/v2/resize:fit:870/1*Xg_9jr2FrjAeDoPnusHoUw.gif"/></div></div></figure><p id="aa86" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">微服务的概念最近引起了相当多的关注，并在网飞等企业公司中获得了越来越多的关注。这是将你的后端服务分割成彼此独立的小块的想法。这种模式通常与统治后端很长时间的单一应用程序相比较。我认为微组件架构与微服务架构有着相同的目标和许多相同的好处，但是实现方式略有不同。</p><p id="8f69" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么，当我说<em class="kx">微型元件</em>时，我指的是什么呢？我将它描述为一个前端架构，一个更大的应用程序被分解成许多独立的小组件，它们不知道应用程序中的其他组件。如果你做过任何SPA开发(Angular，React，Vue等)，这种模式对“父与子”组件通信模式来说会很熟悉。</p><blockquote class="ky kz la"><p id="60fb" class="jn jo kx jp b jq jr js jt ju jv jw jx lb jz ka kb lc kd ke kf ld kh ki kj kk ij bi translated">我将它描述为一个前端架构，一个更大的应用程序被分解成许多独立的小组件，它们不知道应用程序中的其他组件。</p></blockquote></div><div class="ab cl le lf hu lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="ij ik il im in"><h1 id="ca16" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">概观</h1><p id="39da" class="pw-post-body-paragraph jn jo iq jp b jq mj js jt ju mk jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">在概述微组件架构是如何实现的，或者至少是我是如何做到的之前，让我解释一下实现微组件架构的好处。</p><ul class=""><li id="9a97" class="mo mp iq jp b jq jr ju jv jy mq kc mr kg ms kk mt mu mv mw bi translated">每个组件都归一个开发者所有</li><li id="44ab" class="mo mp iq jp b jq mx ju my jy mz kc na kg nb kk mt mu mv mw bi translated">每个组件都设计为独立运行，不知道谁是父组件(可能是应用程序或另一个组件)</li><li id="a893" class="mo mp iq jp b jq mx ju my jy mz kc na kg nb kk mt mu mv mw bi translated">可以更新应用程序以使用组件的新版本，而无需更改代码(假设输入和输出通信没有改变)</li></ul><p id="0cae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后一点对我来说是最重要的。我的团队能够在他们自己的领域中开发组件，发布代码，并在我们的CI/CD中重建父应用程序以反映这些变化。</p></div><div class="ab cl le lf hu lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="ij ik il im in"><h1 id="92f0" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">高水平（位）</h1><p id="87b5" class="pw-post-body-paragraph jn jo iq jp b jq mj js jt ju mk jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">我的具体例子，我将在下面解释，使用<strong class="jp ir"> Vue.js </strong>。但是，您可以使用Angular或React完成相同的操作。Vue.js有一个非常简单的创建“库”的过程，这是如何生成和使用微组件的组件的基础。最重要的是，对于我们的特定项目，有一个使用Vue.js的非功能性需求。</p><p id="fbaa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是一个普通的单片应用程序的样子。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/fbc8ce1b0d545a39573d03ae141ada51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1124/format:webp/1*T_s7rByHyagZe2niZfsxNg.png"/></div></figure><p id="0ab7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有一个没有组件的应用程序，所有组件都在一个代码库中。现在这里是微组件模式。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nd"><img src="../Images/ceb9f5682c4aab40617e0a207da8a9ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pPGlcwLOK6W2BPYIbB6Zgg.png"/></div></div></figure><p id="c750" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可以看到上面有更多的线。紫色线条表示与已发布的NPM包的连接。当然，NPM注册中心需要是私有的，除非你希望你的企业代码对全世界公开。我们使用本地服务器上的<a class="ae ne" href="https://verdaccio.org/" rel="noopener ugc nofollow" target="_blank"> Verdaccio </a>作为我们的私有注册中心。</p><p id="da63" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">黑线代表到存储库的连接(我们使用的是Bitbucket)。</p><p id="3ba4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里我想指出一个小小的警告。请注意每一行的黑线和紫线是如何汇聚成一条线的，因此，一个存储库包含四个组件，一个包包含四个组件(数字4是任意的)。我们决定将同样关注的组件存储到相同的回购协议和包中，因为我们知道我们总共有近40个组件，管理40个回购协议和40个包会很麻烦。稍后我会解释这是如何工作的。最终，如果你愿意的话，你可以将每个组件分解成一个单独的回购和包装。</p></div><div class="ab cl le lf hu lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="ij ik il im in"><h1 id="9f59" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">密码</h1><p id="6f9c" class="pw-post-body-paragraph jn jo iq jp b jq mj js jt ju mk jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">下面的图片和代码将是如何工作的一瞥。</p><p id="add8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是同一存储库中多个组件的文件夹结构，以及它们是如何从包中导出以供使用的。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/0b2b075a5c24416f2aa3579d68e2f69d.png" data-original-src="https://miro.medium.com/v2/resize:fit:578/format:webp/1*Xo0OJjrj7J-K9sfJjxmtkw.png"/></div></figure><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ng"><img src="../Images/d522a4dd324017e8600f2e2a5e8106be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8F1LOgXCfdAlzQ74furf0g.png"/></div></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk translated">索引. js</figcaption></figure><p id="d74f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">“选项”这个词是任意的。对于我们的客户来说，这是一个商业术语，但是你可以用“组件”来替换它，因为这就是每个选项的含义。每个组件都有自己的文件夹，在那里它是完全独立的。它进行所有自己的API调用，检索所有自己的环境变量，并为通信公开输入和输出。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nl"><img src="../Images/8d4d3781f2ce6b9d979eb01148da4ecf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6qLQ9Pmw1i3rU3XsIoeQzw.png"/></div></div></figure><p id="eb81" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<em class="kx"> package.json </em>中，<code class="fe nm nn no np b">build-option:all-options</code>运行Vue.js CLI命令，从<em class="kx"> index.js </em>导出的所有组件中创建一个库。然后所有代码都放在<em class="kx"> dist </em>文件夹中。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/2456cb6671134cda5c965225735d2f6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:616/format:webp/1*_oVHqDCP4hmL8LKqsDvZ7Q.png"/></div></figure><p id="ee09" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后我们运行<code class="fe nm nn no np b">npm publish</code>将组件上传到我们的私有注册中心。从那里我们可以运行<code class="fe nm nn no np b">npm i --save &lt;package-name&gt;</code>在我们的应用程序中使用这个包，然后我们像对待其他NPM包一样对待它。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/4be6db2ca7f2f8d74aa523b3f86b19b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:760/format:webp/1*Eks17eGZcHO5ilGkfOyk6g.png"/></div></figure><p id="1aa2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就这么简单。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/a321ee26ed3d2560ef6a2f760698ab62.png" data-original-src="https://miro.medium.com/v2/resize:fit:718/1*MT7DlVHgHt9W1p3nTsSpPQ.gif"/></div></figure><p id="bf13" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">开个玩笑，当然还有更多要考虑的:</p><p id="7432" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kx">如何测试每个组件？</em></p><p id="c876" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我创建了“操场”来测试每个组件，这样操场就非常类似于应用程序将如何使用组件。运行<code class="fe nm nn no np b">vue serve</code>在localhost:8080上启动组件进行测试。</p><p id="301c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kx">你如何应对环境？这些包是预先构建的，那么它们如何在构建之前切换环境变量呢？</em></p><p id="fd2f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是我遇到的最困难的问题，在数小时的各种方法之后，我能够在一个预构建的包中完成动态设置环境变量。我可能会写一篇后续文章，介绍我是如何完成的。</p><p id="faa4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可能还有很多问题，我很乐意在评论中回答。我的联系方式也在最下面。</p></div><div class="ab cl le lf hu lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="ij ik il im in"><h1 id="18c9" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">最后的想法和收获</h1><p id="11e4" class="pw-post-body-paragraph jn jo iq jp b jq mj js jt ju mk jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">我越来越喜欢这个架构，但是我没有忘记你可能会遇到的问题。</p><ul class=""><li id="6dfa" class="mo mp iq jp b jq jr ju jv jy mq kc mr kg ms kk mt mu mv mw bi translated">只有当你的包不改变主要版本(例如<code class="fe nm nn no np b">1.2.3 -&gt; 2.0.0</code>)时，在不对应用程序进行代码修改的情况下开始新的构建才有效。如果你改变了一个组件的主要版本，那么你需要更新你的应用程序的<em class="kx">包中的那个组件的版本。</em></li><li id="ac39" class="mo mp iq jp b jq mx ju my jy mz kc na kg nb kk mt mu mv mw bi translated">根据您的CI/CD产品，部署过程会有所不同，但是，在不同的CI/CD产品中，部署过程应该非常相似。我们利用詹金斯。例如，要使用私有npm注册表，您必须公开一个<em class="kx">。npmrc </em>文件在构建的根目录下。实现这一点可能因不同的CI/CD而异。</li><li id="fac8" class="mo mp iq jp b jq mx ju my jy mz kc na kg nb kk mt mu mv mw bi translated">你需要100%致力于这个架构。一只脚进，一只脚出是不行的。</li><li id="921f" class="mo mp iq jp b jq mx ju my jy mz kc na kg nb kk mt mu mv mw bi translated">我可能会说服你不要在较小的项目中使用这种架构，因为好处无法克服复杂性。务必评估微组件架构是否适合您的业务和技术需求。</li></ul><p id="9bd9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">再说一遍，这是为了什么？我们的开发人员可以编写彼此独立的组件，我们可以在不更改任何代码的情况下将更新推送到我们的应用程序，并且所有组件都是为重用而设计的，可以在任何数量的应用程序中使用。</p><h1 id="36fd" class="ll lm iq bd ln lo nt lq lr ls nu lu lv lw nv ly lz ma nw mc md me nx mg mh mi bi translated">关于我</h1><p id="e877" class="pw-post-body-paragraph jn jo iq jp b jq mj js jt ju mk jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">我在南卡罗来纳州格林维尔的一家软件工程咨询公司<a class="ae ne" href="https://orangebees.com/" rel="noopener ugc nofollow" target="_blank"> Orange Bees </a>担任首席工程师。我写得棱角分明。NET应用，在Azure架构项目(Azure Developer Associate认证)，涉猎ElasticSearch和node . js<br/>你可以在<a class="ae ne" href="https://www.linkedin.com/in/james-l-gross/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上找我。</p></div></div>    
</body>
</html>