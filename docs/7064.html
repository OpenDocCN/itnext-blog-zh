<html>
<head>
<title>Patch an NPM dependency with yarn</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用纱线修补NPM附属品</h1>
<blockquote>原文：<a href="https://itnext.io/patch-an-npm-dependency-with-yarn-ddde2e194576?source=collection_archive---------1-----------------------#2022-05-30">https://itnext.io/patch-an-npm-dependency-with-yarn-ddde2e194576?source=collection_archive---------1-----------------------#2022-05-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/1686d623a2dcb20251e0e92d95efa0f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*H113wSmxl4TEdbl0.jpg"/></div></div></figure><p id="631e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当您在第三方依赖关系中遇到错误时，通常您只有有限的选项来修复它。</p><p id="ec0d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以直接修改依赖项的本地代码并进行新的构建。如果这是一个严重的bug，并且你必须尽快修复它，那么这个方法是有效的。但是，这不是最好的选择，因为您将在下一次<code class="fe kw kx ky kz b">yarn</code>或<code class="fe kw kx ky kz b">npm</code>安装时丢失修复。此外，您将无法与您的团队共享修复。</p><p id="bc61" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">另一种选择是派生包，修复bug，并创建一个pull请求。此时，您可以更新您的项目依赖项并使用您的fork，直到包的维护者批准它并发布新版本。</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="d63e" class="li lj iq kz b gy lk ll l lm ln">"dependencies": {<br/>  "buggy-package": "your_user/buggy-package#bugfix"<br/>}</span></pre><p id="a1fd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这看起来是一个不错的选择，现在您的团队成员将在更新项目依赖关系时获得修复。不利的一面是，您必须维护fork并确保它是最新的。</p><p id="3881" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们有更好的选择吗？是的，我们有。我们可以使用yarn v2.0.0中引入的<code class="fe kw kx ky kz b">yarn patch</code>命令。这允许您即时对您的依赖项进行修复，而无需派生包。</p><p id="033c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们以<code class="fe kw kx ky kz b">remix-run</code>框架为例。在开发过程中，我发现了会话存储的一个问题。我打开了一个<a class="ae lo" href="https://github.com/remix-run/remix/pull/3113" rel="noopener ugc nofollow" target="_blank"> pull请求</a>来修复它，然后我使用命令直接在项目中修补这个包:</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="7e04" class="li lj iq kz b gy lk ll l lm ln">yarn patch @remix-run/node@npm:1.5.1 </span><span id="207a" class="li lj iq kz b gy lp ll l lm ln">➤ YN0000: Package @remix-run/node@npm:1.5.1 got extracted with success! <br/>➤ YN0000: You can now edit the following folder: /private/var/folders/xm/qntd4h_97zn6w88tc95bsvxc0000gp/T/xfs-bfc9a229/user <br/>➤ YN0000: Once you are done run yarn patch-commit -s /private/var/folders/xm/qntd4h_97zn6w88tc95bsvxc0000gp/T/xfs-bfc9a229/user and Yarn will store a patchfile based on your changes. ➤ YN0000: Done in 0s 68ms</span></pre><p id="2e2e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">提取包后，我们可以打开创建的文件夹，并在那里进行更改。一个缺点是，你必须修改产品代码，这可能是缩小和难以调试。在我的例子中，是对<code class="fe kw kx ky kz b">fileStorage</code>模块的简单改变。</p><p id="b697" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下一步是使用之前在控制台中显示的命令提交补丁</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="1d16" class="li lj iq kz b gy lk ll l lm ln">yarn patch-commit -s /private/var/folders/xm/qntd4h_97zn6w88tc95bsvxc0000gp/T/xfs-bfc9a229/user</span></pre><p id="4e20" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此时，我们应该在<code class="fe kw kx ky kz b">package.json</code>中看到以下变化</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="5629" class="li lj iq kz b gy lk ll l lm ln">"resolutions" : { <br/>   "@remix-run/node@1.5.1" : "patch:@remix-      run/node@npm:1.5.1#.yarn/patches/@remix-run-node-npm-1.5.1-51061cf212.patch" <br/>}</span></pre><p id="b394" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<code class="fe kw kx ky kz b">.yarn/patches</code>中，你会找到补丁文件。</p><p id="b62a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用这种方法的好处是您的团队可以审查补丁，与fork相比，它不需要应用额外的工作。这应该用于关键的修复，如果你需要一个新的特性，我建议你用分叉来代替。另外，不要忘记打开一个问题，并在实际的包中创建一个拉式请求。</p></div></div>    
</body>
</html>