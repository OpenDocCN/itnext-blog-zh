# 微服务—方式和原因

> 原文：<https://itnext.io/microservice-how-why-cc40ca95d9f0?source=collection_archive---------3----------------------->

微服务是当今行业的热词。几乎每个人都想将他们的系统迁移到基于微服务的架构，这样他们就可以用它创造奇迹。但是，在我们开始之前，我们应该停下来想一想。我们只是在随大流吗？这对我的产品有帮助吗？最重要的是，我们真的要转向微服务了吗——还是只是把一个正常工作的企业搞乱了？

微服务背后的所有炒作都是有充分理由的。但是，只有当我们能够真正理解本质并将其应用到我们的架构中时，它才有意义——而不仅仅是语法。在云上部署、分成小部分或者仅仅使用 Spring Boot 和 Dockers 都不能构成微服务架构。

那么，什么才是好的微服务架构呢？要理解这一点，必须理解微服务架构的核心原则。我们必须了解为什么要引入微服务，以及我们试图用微服务解决什么问题。然后我们可以自省，了解我们的架构是否真的解决了这些问题。

这个博客可以给你一个微服务背后的几个关键原则的简要概述。

![](img/40c2d70982fae485388f7b60cc633bfb.png)

# 微服务

引入微服务是为了实现快速灵活的变化。在真正基于微服务的架构中，我们应该能够用增强版本更新和替换任何服务，而不会影响其他服务；任何用户故事的改变应该只影响一个微服务。我们到了吗？

为了实现这一点，该体系结构应遵循以下原则:

## 1.单一业务功能

微服务应该实现单一的业务功能。现在，“单一业务功能”是一个模糊的短语。对于一个局外人来说，制作一部电影是一个单一的商业职能。对于一个内部人员来说，这是一项涉及各种不同任务的巨大努力。

任何业务功能都是相当相似的。那么，我们如何决定“单一业务功能”对单一专用微服务的需求是否正确呢？当我们在企业应用程序上工作时，这是一个常见的设计问题——我们有各种各样的功能。任何函数都希望其他函数在黑盒中出现。但是，它们都太大，无法集成到单个微服务中。

这种问题的典型解决方案是一个树形结构——其中一个微服务作为一个微服务块的网关，微服务块可以进一步分裂。这种模块化应该继续分裂，直到一行代码。在一个设计良好的代码中，任何一行代码都应该包含该功能的一个独特方面。

现在，我们有另一个问题！当然，我们不能继续将我们的微服务分割到那种程度。我们什么时候停止拆分微服务？
理想情况下，微服务应该定义一个可以独立于其他服务而改变的功能。如果我们注意到几个微服务总是一起变化，我们应该知道我们搞砸了。

如果我们注意到几乎每个变化都有微服务变化；它只通过改变一小部分代码来改变——我们又搞砸了。

## 2.快速故障和安全故障

如果微服务遇到问题，它应该很快意识到这一点，并且应该优雅地失败——而不会使系统崩溃。如果我们的问题沿着几个微服务级联，这意味着我们的设计有问题。

理想情况下，我们的微服务应该以这样一种方式进行布局，即一个服务可以包含一个问题。但这并不意味着微服务试图掩盖其问题。如果它不能完成自己的工作，它就失败了。它很快就失效了。它作为服务是失败的。并且，系统的其余部分应该能够考虑这个问题。

在这里，问题不是异常，它只是我们的代码设计处理的另一种情况。现在，如果微服务处理大量功能，它将有许多失败的原因。失败会影响许多不应该影响的功能。

另一方面，如果微服务太薄，我们将有许多微服务因为一个问题而失败。无论哪种情况，我们都搞砸了。

## 3.松散耦合

像大多数设计概念一样，这也是一个模糊的短语。“松”有多松？我们怎么知道自己够宽松？在真正意义上，松散耦合的服务应该在发现时进行通信，而不是在调用时进行通信。理想情况下，一对松散耦合的微服务不应该共享一行代码。

这在现实生活中不会发生。如果在 Spring Boot 开发两个微服务，它们自然会共享弹簧罐。这很好，因为两个微服务都不希望对方使用它。按照设计，每个微服务在代码上应该是独立的。

不共享代码并不意味着微服务之间的代码重复。重点是，两个微服务不应该需要相同的代码。如果我们注意到代码的重复，我们应该知道我们的设计是错误的。从真正的意义上来说，松耦合意味着基于功能和标准的耦合，而不是相互认可的接口。因此，我们可以看到典型的微服务使用 REST API 进行通信。它们使用基于功能的发现进行通信，而不是直接调用。

这种“松散”耦合是有代价的——将特定于实现的数据结构转换成标准外部 API 的代价。微服务太多，不可能有这么松的耦合。即使我们能做到，那也会使我们的许多代码忙于这种翻译，而不是致力于真正的功能。

当然，如果我们只有很少的几块，我们就会有一堆乱七八糟的巨石——这违背了我们的目的。因此，确定一组能够独立协作的最佳微服务非常重要。

## 4.抽象和独立

这不仅限于微服务。抽象可能是任何设计中最重要的方面。无论我们使用什么样的架构模式，抽象在一个好的设计中是必不可少的。

抽象到底是什么？按照抽象原则，任何代码单元都应该完成自己的工作，而不需要依赖于它是如何完成工作的。
这是什么意思？考虑简单的 System.out.println()。我们需要研究它是如何工作的吗？我们知道它是什么，但不知道它是如何做到的。任何设计良好的代码块都应该输出“什么”而不是“如何”。

如果我们需要研究功能是如何实现的，这意味着功能没有很好地实现。随着模块规模的增加，这变得越来越重要。随着模块规模的增加,“做什么”和“如何做”之间的差距也在增加。

用户验证服务应该验证用户并返回是或否。其他人不应该关心它是如何做到这一点的。它可能使用关系数据库或基于文档的数据库，或者只是一个平面文件。它可能使用 Java 或 Python 或 JavaScript——或者只是汇编代码！系统的其余部分不应该依赖于这些方面中的任何一个。它应该只是遵循定义的接口。

如果没有发生这种情况，如果一个微服务依赖于另一个微服务如何完成它的工作，这意味着该微服务没有抽象功能。这意味着它们不是独立的，设计是混乱的。

## 5.独立的 CI/CD 和集群

在大型企业中，每项服务都以不同的速度发展。如果系统设计得很好，大多数的改变都局限于很少的服务。正因为如此，一项服务的改变不应该要求我们去接触其他服务。只有当我们为每个微服务提供独立的 CI/CD 时，这才有可能实现。

同样，每个微服务都有自己的负载模式。随着企业的扩展，一些服务保持相同的负载，而另一些服务增长非常快。如果我们把它们放在一起，就会导致某些服务的能力过剩，或者其他服务的匮乏。