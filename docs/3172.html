<html>
<head>
<title>Redux-Observable’s best-practice is an anti-pattern.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Redux-Observable的最佳实践是一种反模式。</h1>
<blockquote>原文：<a href="https://itnext.io/the-best-practice-anti-pattern-5e8bd873aadf?source=collection_archive---------3-----------------------#2019-10-16">https://itnext.io/the-best-practice-anti-pattern-5e8bd873aadf?source=collection_archive---------3-----------------------#2019-10-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/5e37836519d39aed9c45a2ddcd11d10c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bd9qdLieds7Z0IbM"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated"><a class="ae jd" href="https://unsplash.com/@worthyofelegance?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">亚历克斯</a>在<a class="ae jd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><div class=""/><div class=""><h2 id="6da0" class="pw-subtitle-paragraph kd jf jg bd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dk translated">从不同的角度看待事物。</h2></div><p id="2535" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我遇到过这样一种情况，我提出的一个想法被称为反模式。实际上，我的印象是这是一种最佳实践，而当前的做事方式会适得其反。</p><p id="b82d" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这个问题是关于Redux-Observable及其动作的自动调度。我开始使用<strong class="kx jh"> Redux-Observable </strong>已经快2年了。在那段时间里，我已经解决了很多难题，并且习惯了用疯狂的方式来编写复杂的可观测量。</p><p id="9e49" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">到目前为止，我做了一些事情来改善体验:</p><ul class=""><li id="566f" class="lr ls jg kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated"><a class="ae jd" rel="noopener ugc nofollow" target="_blank" href="/redux-observable-without-redux-ff4a2b5a4b39">消除冗余</a>的需要。</li><li id="448e" class="lr ls jg kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated"><a class="ae jd" href="https://github.com/redux-observable/redux-observable/pull/674" rel="noopener ugc nofollow" target="_blank">增加更好的错误记录</a>。</li><li id="bbae" class="lr ls jg kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">将长的内部变量分解成单独的函数(通常会增加不必要的间接性)。</li></ul><p id="7c4d" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">编写复杂的史诗在生产应用程序中很常见。很难跟踪什么时候执行了哪些操作，尤其是对团队中的新成员，并且很难跟踪当您继续创建越来越多的内部观察时发生了什么。</p><p id="91b9" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我最近参与了一个使用Redux-Thunk的项目，我惊讶地发现分派动作是如此容易。我知道大多数人都是这样开始的，但我不是。</p><p id="73c3" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">虽然我绝对不喜欢让一些动作创建者返回承诺的做法，但我确实很重视在你需要时<strong class="kx jh">调度的能力。</strong></p><p id="e97d" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">主要好处？您的代码更简单，更易于维护，并且位于左侧。代码越多，要处理的闭包就越多，也就越难找出在哪里调用了什么。这也被称为回调地狱。</p><p id="4246" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Observables应该是回调的替代方案，但是如果没有调度的方法，你最终会得到很长的圣诞树管道。我还发现，将大量可重复观察的史诗分解成运算符和可观察对象会增加不必要的间接性。</p><p id="2706" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我要用更好的方法来证明这一点。但是要注意，这种更好的方式被认为是一种<a class="ae jd" href="https://twitter.com/_jayphelps/status/1184300479809015808" rel="noopener ugc nofollow" target="_blank">反模式</a>。我不是想嘲笑杰伊·菲尔普斯或其他致力于Redux-Observable的人，我只是想对一个非常重要的建筑决策提出强烈的反对意见。</p><h1 id="d1d8" class="mf mg jg bd mh mi mj mk ml mm mn mo mp km mq kn mr kp ms kq mt ks mu kt mv mw bi translated">删除最佳实践？</h1><p id="e52d" class="pw-post-body-paragraph kv kw jg kx b ky mx kh la lb my kk ld le mz lg lh li na lk ll lm nb lo lp lq ij bi translated">我将浏览一下从<a class="ae jd" href="https://github.com/redux-observable/redux-observable/pull/346" rel="noopener ugc nofollow" target="_blank">PR删除对Redux的</a> <code class="fe nc nd ne nf b"><a class="ae jd" href="https://github.com/redux-observable/redux-observable/pull/346" rel="noopener ugc nofollow" target="_blank">store</a></code>的访问的更新片段。</p><p id="304a" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这可能是你在<strong class="kx jh"> v0 </strong>中看到的:</p><figure class="ng nh ni nj gt is"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="b620" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果你正在写这样的史诗，你需要重新考虑你的策略。一个动作使用<code class="fe nc nd ne nf b">store.dispatch</code>显式分派，而另一个使用Redux-Observable的自动分派(分派任何通过管道的东西)。</p><p id="616d" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">有两种做事方式不是一个好的模式。为了让每个人都简单，你需要有一种做事的方式。</p><p id="dc3d" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">你以前用过AngularJS吗？有3种不同的几乎相同的数据管理方式(服务、工厂、提供商)，几乎每篇文章都谈到了它们。可悲的是，没有人对“为什么”给出一个好的解释。从我参与的项目来看，每个人都同意使用一种方法，这使得事情变得简单。</p><p id="0c60" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当Redux-Observable转到<strong class="kx jh"> v1 </strong>时，它也切换到具有自动分派动作的单一方法:</p><figure class="ng nh ni nj gt is"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="9605" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这两个例子非常简单。听一个动作，同时输出两件事情。基于这些例子，这种改变看起来没什么大不了的，但这并不是我工作过的项目中大多数史诗的样子。如果这些能代表大多数史诗的样子，这篇文章就不会存在了。</p><p id="5b42" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在失去<code class="fe nc nd ne nf b">store</code>的时候，另一个选择是<code class="fe nc nd ne nf b">state$</code>。这肯定是优越的，因为你可以直接订阅它。但是我们也失去了<code class="fe nc nd ne nf b">dispatch</code>。</p><p id="8701" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最近，我一直在想，对自动调度的依赖可能是反模式的。</p><p id="00b6" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们看一下<a class="ae jd" href="https://en.wikipedia.org/wiki/Anti-pattern" rel="noopener ugc nofollow" target="_blank">反模式的定义</a>:</p><blockquote class="nm nn no"><p id="e385" class="kv kw np kx b ky kz kh la lb lc kk ld nq lf lg lh nr lj lk ll ns ln lo lp lq ij bi translated"><em class="jg">反模式是对重复出现的问题的常见反应，通常是无效的，并且有可能产生非常不利的后果。</em></p></blockquote><p id="598e" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我提出的方法会增加生产力(在我看来)，而不是像自动调度那样降低生产力。我会陈述我的观点，但最终，你会是法官。</p><h1 id="8c44" class="mf mg jg bd mh mi mj mk ml mm mn mo mp km mq kn mr kp ms kq mt ks mu kt mv mw bi translated">真正的问题是</h1><p id="4d04" class="pw-post-body-paragraph kv kw jg kx b ky mx kh la lb my kk ld le mz lg lh li na lk ll lm nb lo lp lq ij bi translated">当我开始使用Redux-Observable时，<code class="fe nc nd ne nf b">store</code>仍然可用，但我被告知v1将改变它的工作方式。我没有学习旧的方法，而是使用新的模式创建了自己的API兼容的<code class="fe nc nd ne nf b">combineEpics</code>函数，并在v1发布时切换到官方的函数。</p><p id="d2a9" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">正因为如此，我从来不知道之前发生了什么，所以我从来没有真正考虑过任何与我被告知的不同的事情。</p><p id="ef35" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">从教授Redux-Observable到noobs，我发现很难解释自动分派的概念。一旦学会了，概念就简单了，但是自己写那个代码？那真的很难。这也是Redux-Observable的Gitter 上最常见的问题之一。</p><p id="5148" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在我看来，Redux-Observable是最好的包装器RxJS，这是一个杀手级应用程序，它使每个人都可以使用复杂的应用程序。要理解自动调度，你必须真正掌握RxJS，这与你想要的杀手级应用相反。</p><p id="7c23" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当使用自动调度编写复杂的史诗时，您知道如何通过将管道分成许多更小的并行管道来将多个动作传递到一个管道。在大多数情况下，您订阅了一个<code class="fe nc nd ne nf b">action$</code>管道，但是您将它分成了许多其他管道，每个管道发送自己的动作，这些动作会被自动分派。</p><p id="861b" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下面是一个例子:</p><figure class="ng nh ni nj gt is"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="3289" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我知道很多人不垂直写代码，但我会。这样写有很多好处，但这超出了本文的范围。我想提供至少一个典型项目中的例子:</p><figure class="ng nh ni nj gt is"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="df0b" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这两个例子都不太清楚；尤其是对一个RxJS noob。我不知道分派了什么(除了我明确地定义了分派发生的地点和时间。这将epic从3个管道减少到2个管道，我们的最大跳转级别从10级减少到7级。这大大增加了可读性！</p><p id="5062" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们还能够将<code class="fe nc nd ne nf b">fetchUserSucceeded</code>和<code class="fe nc nd ne nf b">setLoaded</code>移出AJAX管道，因为<code class="fe nc nd ne nf b">catchError</code>的输出不再有机会通过它们。</p><p id="cb0c" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">除了比之前稍微长一点的<code class="fe nc nd ne nf b">catchError</code>之外，我们的其他逻辑都减少了不少。我们可以通过创建自己的<code class="fe nc nd ne nf b">catchError</code>包装器来简化这一点:</p><figure class="ng nh ni nj gt is"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="f2ce" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">根据我的经验，这是前端应用程序中非常标准的史诗。根据项目的需要，我已经写了许多更疯狂的程序，内部可观察的程序变得难以处理。</p><p id="b32a" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在过去的项目中，缺乏<code class="fe nc nd ne nf b">dispatch</code>功能实际上使我远离了从单个epic调度多个动作(Redux-Observable的好处之一)，因为它增加了复杂性并降低了可读性。</p><p id="2983" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一部分来自创造许多内在的可观察性，另一部分是派遣的不确定性。有时你认为一个动作正在被分派，但后来发现它没有。如果我直接调用<code class="fe nc nd ne nf b">dispatch</code>，我就不会遇到这种情况。这是非常确定的。</p><p id="5943" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">另一个例子</p><figure class="ng nh ni nj gt is"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="fd02" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们还应该看看相反的例子。与其听一个可观察，调度多个动作，不如听多个动作，调度一次，效果如何？</p><p id="4765" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这个例子中，唯一改变的是<code class="fe nc nd ne nf b">map(pong)</code>。现在它看起来像这样:</p><p id="e683" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">没那么干净。我用这个例子来说明<code class="fe nc nd ne nf b">dispatch</code>并不总是最干净的选择，但至少它不会让事情变得更糟。</p><h1 id="5854" class="mf mg jg bd mh mi mj mk ml mm mn mo mp km mq kn mr kp ms kq mt ks mu kt mv mw bi translated">你可能会认为在<code class="fe nc nd ne nf b">dispatch</code>中包装函数就像你在React-Redux的<code class="fe nc nd ne nf b">mapToDispatch</code>参数中看到的那样会解决这个问题。我会提出相反的观点。这个函数所做的只是让我们更难搞清楚到底发生了什么。毫不奇怪，在hooks版本中它被删除了。</h1><p id="dd23" class="pw-post-body-paragraph kv kw jg kx b ky mx kh la lb my kk ld le mz lg lh li na lk ll lm nb lo lp lq ij bi translated">另一个提议</p><figure class="ng nh ni nj gt is"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="2918" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">史诗般的争论</p><figure class="ng nh ni nj gt is"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="7050" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，史诗有三个参数，<code class="fe nc nd ne nf b">action$</code>、<code class="fe nc nd ne nf b">state$</code>和<code class="fe nc nd ne nf b">dependencies</code>。如果你要传入多个参数，我更喜欢把它们作为一个单独的对象:</p><p id="1156" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">有了对象，你不必知道顺序，所以你可以只解构你需要的。它们有点难以记忆，但你可能不应该记忆你的史诗。还有，<code class="fe nc nd ne nf b">dependencies</code>是一个对象，我看不出为什么<code class="fe nc nd ne nf b">action$</code>和<code class="fe nc nd ne nf b">state$</code>一定要排除在外。</p><h1 id="7b21" class="mf mg jg bd mh mi mj mk ml mm mn mo mp km mq kn mr kp ms kq mt ks mu kt mv mw bi translated">如果epics接受单个对象，我们可以动态地改变Redux-Observable API，而不需要完全重写所有epics。例如，如果旧版本的Redux-Observable在一个对象中传递了<code class="fe nc nd ne nf b">store</code>,那么当<code class="fe nc nd ne nf b">state$</code>到来时，您就不必预先更改任何东西。</h1><h2 id="51f6" class="nt mg jg bd mh nu nv dn ml nw nx dp mp le ny nz mr li oa ob mt lm oc od mv oe bi translated">现在有了多个参数，改变epic API就困难多了；因此，添加<code class="fe nc nd ne nf b">dispatch</code>需要从第三个参数中抓取一个对象。</h2><p id="678d" class="pw-post-body-paragraph kv kw jg kx b ky mx kh la lb my kk ld le mz lg lh li na lk ll lm nb lo lp lq ij bi translated">从不自动调度</p><figure class="ng nh ni nj gt is"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="13bf" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果<code class="fe nc nd ne nf b">dispatch</code>是Redux-Observable的一部分，自动调度应该被阻止并完全删除。随着时间的推移，用两种方法做同样的事情会使代码更难维护。</p><p id="df5a" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">虽然这在今天可能很难做到，但是您总是可以关闭您的<code class="fe nc nd ne nf b">rootEpic</code>并添加<code class="fe nc nd ne nf b">ignoreElements()</code>到其中，而无需更改任何其他代码。</p><p id="a39f" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当然，这将导致相当多的问题，所以像这样的解决方案可能会更好:</p><h2 id="eaa3" class="nt mg jg bd mh nu nv dn ml nw nx dp mp le ny nz mr li oa ob mt lm oc od mv oe bi translated">有了这些代码，你可以与你当前的代码库集成，并随着时间的推移将<code class="fe nc nd ne nf b">dispatch</code>添加到epics中。</h2><p id="27df" class="pw-post-body-paragraph kv kw jg kx b ky mx kh la lb my kk ld le mz lg lh li na lk ll lm nb lo lp lq ij bi translated">工作示例</p><p id="4695" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">对于一个将<code class="fe nc nd ne nf b">dispatch</code>作为依赖项的工作示例，您可以使用这个CodeSandbox:</p><p id="25a7" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">专家假说</p><figure class="ng nh ni nj gt is"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="2b1d" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">用Redux-Observable的人不都应该是RxJS专家吗？不。这个库太棒了，我讨厌它只限于了解他们的东西的人和团队。为什么要让事情变得不必要的困难呢？</p><h2 id="23f2" class="nt mg jg bd mh nu nv dn ml nw nx dp mp le ny nz mr li oa ob mt lm oc od mv oe bi translated">引自<a class="ae jd" href="https://redux-observable.js.org/docs/basics/Epics.html" rel="noopener ugc nofollow" target="_blank">可重复观察的文件</a>:</h2><p id="0ffc" class="pw-post-body-paragraph kv kw jg kx b ky mx kh la lb my kk ld le mz lg lh li na lk ll lm nb lo lp lq ij bi translated"><em class="jg"> Redux-observable(因为RxJS)真正在复杂的异步/副作用方面大放异彩。如果您对RxJS还不熟悉，您可以考虑使用redux-thunk来处理简单的副作用，然后使用redux-observable来处理复杂的事情。这样你就可以保持高效率，并在工作中学习RxJS。redux-thunk学习和使用起来要简单得多，但这也意味着它的功能要弱得多。当然，如果你已经像我们一样热爱Rx，你很可能会用它来做任何事情！</em></p><figure class="ng nh ni nj gt is"><div class="bz fp l di"><div class="of nl l"/></div></figure><h1 id="c97d" class="mf mg jg bd mh mi mj mk ml mm mn mo mp km mq kn mr kp ms kq mt ks mu kt mv mw bi translated">在我看来，Redux-Observable取代了Redux-Thunk。我甚至用Redux-Observable编写了整个应用程序，除此之外什么都没有。</h1><p id="037d" class="pw-post-body-paragraph kv kw jg kx b ky mx kh la lb my kk ld le mz lg lh li na lk ll lm nb lo lp lq ij bi translated">按照这种逻辑，Redux-Observable既强大又复杂。如果我们能够显著降低复杂性并保持高水平的能力，会怎么样？你甚至需要建议Redux-Thunk吗？</p><p id="26aa" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">结论</p><blockquote class="nm nn no"><p id="91bb" class="kv kw np kx b ky kz kh la lb lc kk ld nq lf lg lh nr lj lk ll ns ln lo lp lq ij bi translated">我真的很喜欢Redux-Observable提高了我编写异步模块的能力。令人惊讶的是，我无意中发现了<a class="ae jd" href="https://medium.com/@Sawtaytoes/redux-without-state-15e2f839055c" rel="noopener">面向消息编程</a>的实现，却没有意识到这一点。</p></blockquote><p id="f5ae" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">经过近两年的使用，<a class="ae jd" href="https://www.youtube.com/watch?v=v4z2OufSSYY" rel="noopener ugc nofollow" target="_blank">做了一次演讲</a>，<a class="ae jd" rel="noopener ugc nofollow" target="_blank" href="/redux-observable-can-solve-your-state-problems-15b23a9649d7">写了许多文章</a>，并在许多生产项目中使用它，我对<em class="np">真正的</em>反模式有了不同的结论。</p><p id="1ecf" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">有可能我完全错了。也许这个想法根本就不怎么样，我也没有看到什么重要的东西。如果是这样的话，<strong class="kx jh">我很乐意得到一些强硬的反馈和批评</strong>。你喜欢这个想法还是你知道一些我不知道的事情？</p><h1 id="d6ad" class="mf mg jg bd mh mi mj mk ml mm mn mo mp km mq kn mr kp ms kq mt ks mu kt mv mw bi translated">我肯定不知道人们在<code class="fe nc nd ne nf b">dispatch</code>被移除之前会陷入什么样的奇怪境地，但我知道它的移除会显著增加许多已经很复杂的史诗的复杂性。这就是我想要解决的问题，我所知道的最好的方法是把一个想法放在那里，看看我是否能得到任何合理的反对意见。</h1><p id="26a8" class="pw-post-body-paragraph kv kw jg kx b ky mx kh la lb my kk ld le mz lg lh li na lk ll lm nb lo lp lq ij bi translated">更多阅读</p><p id="ec5c" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果你喜欢你所读的，请查看我关于类似的令人大开眼界的主题的其他文章:</p><p id="3399" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><a class="ae jd" rel="noopener ugc nofollow" target="_blank" href="/redux-observable-can-solve-your-state-problems-15b23a9649d7"> Redux-Observable将解决你的状态问题</a></p><p id="a68c" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><a class="ae jd" rel="noopener ugc nofollow" target="_blank" href="/the-definitive-guide-to-callbacks-in-javascript-44a39c065292">回访:权威指南</a></p><h1 id="395a" class="mf mg jg bd mh mi mj mk ml mm mn mo mp km mq kn mr kp ms kq mt ks mu kt mv mw bi translated"><a class="ae jd" rel="noopener ugc nofollow" target="_blank" href="/promises-the-definitive-guide-6a49e0dbf3b7">承诺:权威指南</a></h1><p id="519e" class="pw-post-body-paragraph kv kw jg kx b ky mx kh la lb my kk ld le mz lg lh li na lk ll lm nb lo lp lq ij bi translated"><a class="ae jd" rel="noopener ugc nofollow" target="_blank" href="/an-emoji-lovers-guide-to-functional-programming-part-1-241d8d4c9223">带有表情符号的函数式编程基础知识</a></p><ul class=""><li id="0eff" class="lr ls jg kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated"><em class="np">原载于2019年10月16日</em><a class="ae jd" href="https://dev.to/sawtaytoes/the-best-practice-anti-pattern-jj6" rel="noopener ugc nofollow" target="_blank"><em class="np">https://dev . to</em></a><em class="np">。</em></li><li id="5581" class="lr ls jg kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi"><a class="ae jd" rel="noopener ugc nofollow" target="_blank" href="/the-definitive-guide-to-callbacks-in-javascript-44a39c065292">Callbacks: The Definitive Guide</a></li><li id="ea95" class="lr ls jg kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi"><a class="ae jd" rel="noopener ugc nofollow" target="_blank" href="/promises-the-definitive-guide-6a49e0dbf3b7">Promises: The Definitive Guide</a></li><li id="3dc2" class="lr ls jg kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi"><a class="ae jd" rel="noopener ugc nofollow" target="_blank" href="/an-emoji-lovers-guide-to-functional-programming-part-1-241d8d4c9223">Functional Programming Basics w/ Emojis</a></li></ul></div><div class="ab cl og oh hu oi" role="separator"><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol"/></div><div class="ij ik il im in"><p id="1eb0" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi"><em class="np">Originally published at </em><a class="ae jd" href="https://dev.to/sawtaytoes/the-best-practice-anti-pattern-jj6" rel="noopener ugc nofollow" target="_blank"><em class="np">https://dev.to</em></a><em class="np"> on October 16, 2019.</em></p></div></div>    
</body>
</html>