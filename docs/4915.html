<html>
<head>
<title>Getting Started with Chaos Mesh and Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">混沌网格和Kubernetes入门</h1>
<blockquote>原文：<a href="https://itnext.io/getting-started-with-chaos-mesh-and-kubernetes-bfd98d25d481?source=collection_archive---------0-----------------------#2020-10-23">https://itnext.io/getting-started-with-chaos-mesh-and-kubernetes-bfd98d25d481?source=collection_archive---------0-----------------------#2020-10-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/2c94b9abc63837540fce17c1f81f27b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*W_0hjvwqxUuWvosc"/></div></div></figure><h1 id="79b6" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">什么是混沌工程？</h1><p id="9d0f" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">混沌工程是一门在生产中对软件系统进行实验的学科，目的是建立对系统承受动荡和意外情况能力的信心。更多细节请参考<a class="ae lu" href="https://en.wikipedia.org/wiki/Chaos_engineering" rel="noopener ugc nofollow" target="_blank">混沌工程</a>。</p><p id="d191" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">混沌实验在生产环境中执行，这为面向客户的停机留出了空间。虽然必须考虑到短期的负面影响，但爆炸半径或实验产生的辐射必须最小化并得到控制。</p><h1 id="538d" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated"><strong class="ak">什么是混沌网？</strong></h1><p id="8fe9" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">混沌网格是<a class="ae lu" href="https://landscape.cncf.io/selected=chaos-mesh" rel="noopener ugc nofollow" target="_blank">云本地计算基金会(CNCF) </a>主持的项目。</p><blockquote class="ma"><p id="f4ee" class="mb mc iq bd md me mf mg mh mi mj lt dk translated">混沌网格是一个云原生的混沌工程平台，在Kubernetes环境中编排混沌。</p></blockquote><p id="b039" class="pw-post-body-paragraph kw kx iq ky b kz mk lb lc ld ml lf lg lh mm lj lk ll mn ln lo lp mo lr ls lt ij bi translated">Chaos Mesh是一个多功能的混沌工程解决方案，其特点是针对Kubernetes上的复杂系统提供全方位的故障注入方法，涵盖Pod、网络、文件系统甚至内核中的故障。</p><p id="01df" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">现在让我们看看混沌网格的组成部分:</p><ul class=""><li id="e587" class="mp mq iq ky b kz lv ld lw lh mr ll ms lp mt lt mu mv mw mx bi translated"><strong class="ky ir">混沌算子</strong>:混沌编排的核心部件。完全开源。</li><li id="b4a4" class="mp mq iq ky b kz my ld mz lh na ll nb lp nc lt mu mv mw mx bi translated"><strong class="ky ir"> Chaos Dashboard </strong>:用于管理、设计、监控混沌实验的Web UI正在开发中。</li></ul><h1 id="b80c" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated"><strong class="ak">混沌网格的架构</strong></h1><p id="3c78" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">在幕后，混沌网格使用<a class="ae lu" href="https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/" rel="noopener ugc nofollow" target="_blank">自定义资源定义</a> (CRD)来定义混沌对象。</p><p id="6e70" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">混沌网格的整体架构非常简单，组件位于Kubernetes之上，我们可以使用YAML文件或混沌网格仪表板上的表单来指定场景。</p><p id="747c" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">有一个混沌守护进程，在网络、Cgroup等上作为拥有特权系统权限的守护进程运行。对于特定的节点。</p><figure class="ne nf ng nh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nd"><img src="../Images/319122185e1fd83d94e8d9cc1c0c8f0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v44fKaxmb7n_BZOdwBxxQQ.png"/></div></div></figure><h1 id="3af3" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated"><strong class="ak">混沌网格中的故障注入场景</strong></h1><p id="9d66" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">混沌运算符使用<a class="ae lu" href="https://kubernetes.io/docs/tasks/access-kubernetes-api/custom-resources/custom-resource-definitions/" rel="noopener ugc nofollow" target="_blank">自定义资源定义(CRD) </a>来定义混沌对象。当前的实现支持六种类型的用于故障注入的CRD对象，即PodChaos、NetworkChaos、IOChaos、TimeChaos、StressChaos和KernelChaos，它们对应于以下主要动作(实验):</p><ul class=""><li id="c413" class="mp mq iq ky b kz lv ld lw lh mr ll ms lp mt lt mu mv mw mx bi translated"><strong class="ky ir"> pod-kill </strong>:选定的Pod被杀死(可能需要ReplicaSet或类似的东西来确保Pod将被重启)。</li><li id="0860" class="mp mq iq ky b kz my ld mz lh na ll nb lp nc lt mu mv mw mx bi translated"><strong class="ky ir"> Pod-failure </strong>:所选择的Pod在指定的时间内不可用。</li><li id="fe57" class="mp mq iq ky b kz my ld mz lh na ll nb lp nc lt mu mv mw mx bi translated"><strong class="ky ir">集装箱-杀死</strong>:在选定的箱中杀死选定的集装箱。</li><li id="ae04" class="mp mq iq ky b kz my ld mz lh na ll nb lp nc lt mu mv mw mx bi translated"><strong class="ky ir">网络混乱</strong>:延迟、复制等网络混乱。</li><li id="65ac" class="mp mq iq ky b kz my ld mz lh na ll nb lp nc lt mu mv mw mx bi translated"><strong class="ky ir">网络分区</strong>:模拟网络分区。</li><li id="0ed6" class="mp mq iq ky b kz my ld mz lh na ll nb lp nc lt mu mv mw mx bi translated"><strong class="ky ir"> IO混乱</strong>:模拟I/O延迟、读写错误等文件系统故障。</li><li id="7701" class="mp mq iq ky b kz my ld mz lh na ll nb lp nc lt mu mv mw mx bi translated"><strong class="ky ir">时间混乱</strong>:选中的pod会被注入时钟偏移。</li><li id="decf" class="mp mq iq ky b kz my ld mz lh na ll nb lp nc lt mu mv mw mx bi translated"><strong class="ky ir"> CPU-burn </strong>:模拟所选pod应力的CPU。</li><li id="c315" class="mp mq iq ky b kz my ld mz lh na ll nb lp nc lt mu mv mw mx bi translated"><strong class="ky ir">记忆烧录</strong>:模拟所选pod应力的记忆。</li><li id="2778" class="mp mq iq ky b kz my ld mz lh na ll nb lp nc lt mu mv mw mx bi translated"><strong class="ky ir">内核混乱</strong>:选中的pod会被注入(slab，bio等)错误。</li></ul><h1 id="55c8" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated"><strong class="ak">在Kubernetes上安装</strong></h1><p id="58ba" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">这个博客将使用本地Kubernetes集群，在您的工作站上使用Kind，所以您可以使用Kind或Minikube来安装混沌网格。</p><h2 id="8f69" class="ni jz iq bd ka nj nk dn ke nl nm dp ki lh nn no km ll np nq kq lp nr ns ku nt bi translated">先决条件</h2><p id="e035" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">在部署之前，确保<a class="ae lu" href="https://docs.docker.com/install/" rel="noopener ugc nofollow" target="_blank"> Docker </a>已经安装并运行在您的本地机器上。</p><h2 id="7f9c" class="ni jz iq bd ka nj nk dn ke nl nm dp ki lh nn no km ll np nq kq lp nr ns ku nt bi translated">安装混沌网格</h2><p id="fc22" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我们将直接使用Chaos Mesh repo提供的安装脚本，该脚本将引导Kind集群并在其上安装Chaos Mesh。</p><pre class="ne nf ng nh gt nu nv nw nx aw ny bi"><span id="d8ca" class="ni jz iq nv b gy nz oa l ob oc">$ curl -sSL <a class="ae lu" href="https://mirrors.chaos-mesh.org/v1.0.1/install.sh" rel="noopener ugc nofollow" target="_blank">https://mirrors.chaos-mesh.org/v1.0.1/install.sh</a> | bash -s —-local kind</span></pre><p id="5f07" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">如果您已经安装了大于0.7版本的Kind，那么脚本将继续运行，否则它将安装一个新版本。</p><p id="8162" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">脚本运行输出将如下图所示</p><pre class="ne nf ng nh gt nu nv nw nx aw ny bi"><span id="7059" class="ni jz iq nv b gy nz oa l ob oc">Install kubectl client<br/>kubectl Version 1.18.8 has been installed<br/>Install Kind tool<br/>Kind Version 0.8.1 has been installed<br/>Install local Kubernetes kind<br/>No kind clusters found.<br/>Clean data dir: /Users/rbanka/kind/kind/data<br/>start to create kubernetes cluster kindCreating cluster "kind" ...<br/>DEBUG: docker/images.go:58] Image: kindest/node:v1.17.2 present locally<br/> ✓ Ensuring node image (kindest/node:v1.17.2) 🖼<br/> ✓ Preparing nodes 📦 📦 📦 📦<br/> ✓ Writing configuration 📜<br/> ✓ Starting control-plane 🕹️<br/> ✓ Installing CNI 🔌<br/> ✓ Installing StorageClass 💾<br/> ✓ Joining worker nodes 🚜<br/>Set kubectl context to "kind-kind"<br/>You can now use your cluster with:</span><span id="6afe" class="ni jz iq nv b gy od oa l ob oc">kubectl cluster-info --context kind-kind</span><span id="1079" class="ni jz iq nv b gy od oa l ob oc">Thanks for using kind! 😊<br/>Install Chaos Mesh chaos-mesh<br/>customresourcedefinition.apiextensions.k8s.io/iochaos.chaos-mesh.org created<br/>customresourcedefinition.apiextensions.k8s.io/kernelchaos.chaos-mesh.org created<br/>customresourcedefinition.apiextensions.k8s.io/networkchaos.chaos-mesh.org created<br/>customresourcedefinition.apiextensions.k8s.io/podchaos.chaos-mesh.org created<br/>customresourcedefinition.apiextensions.k8s.io/podiochaos.chaos-mesh.org created<br/>customresourcedefinition.apiextensions.k8s.io/podnetworkchaos.chaos-mesh.org created<br/>customresourcedefinition.apiextensions.k8s.io/stresschaos.chaos-mesh.org created<br/>customresourcedefinition.apiextensions.k8s.io/timechaos.chaos-mesh.org created<br/>namespace/chaos-testing created<br/>serviceaccount/chaos-controller-manager created<br/>secret/chaos-mesh-webhook-certs created<br/>clusterrole.rbac.authorization.k8s.io/chaos-mesh:chaos-controller-manager-target-namespace created<br/>clusterrole.rbac.authorization.k8s.io/chaos-mesh:chaos-controller-manager-cluster-level created<br/>clusterrolebinding.rbac.authorization.k8s.io/chaos-mesh:chaos-controller-manager-cluster-level created<br/>clusterrolebinding.rbac.authorization.k8s.io/chaos-mesh:chaos-controller-manager-target-namespace created<br/>role.rbac.authorization.k8s.io/chaos-mesh:chaos-controller-manager-control-plane created<br/>rolebinding.rbac.authorization.k8s.io/chaos-mesh:chaos-controller-manager-control-plane created<br/>service/chaos-dashboard created<br/>service/chaos-mesh-controller-manager created<br/>daemonset.apps/chaos-daemon created<br/>deployment.apps/chaos-dashboard created<br/>deployment.apps/chaos-controller-manager created<br/>mutatingwebhookconfiguration.admissionregistration.k8s.io/chaos-mesh-mutation created<br/>validatingwebhookconfiguration.admissionregistration.k8s.io/chaos-mesh-validation created<br/>Waiting for pod running<br/>chaos-controller-manager-754d4f7585-h9p4c   0/1   ContainerCreating   0     10s<br/>Waiting for pod running<br/>chaos-controller-manager-754d4f7585-h9p4c   0/1   ContainerCreating   0     21s<br/>Waiting for pod running<br/>chaos-controller-manager-754d4f7585-h9p4c   0/1   ContainerCreating   0     31s<br/>Waiting for pod running<br/>Chaos Mesh chaos-mesh is installed successfully</span></pre><p id="c15c" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated"><strong class="ky ir">为了验证</strong>我们的组件是否运行在Kubernetes集群上，我们可以使用:</p><pre class="ne nf ng nh gt nu nv nw nx aw ny bi"><span id="af7e" class="ni jz iq nv b gy nz oa l ob oc">$ kubectl get pod -n chaos-testing</span></pre><p id="70a4" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">输出，如果一切顺利，看起来会像</p><pre class="ne nf ng nh gt nu nv nw nx aw ny bi"><span id="2482" class="ni jz iq nv b gy nz oa l ob oc">$ kubectl get pods -n chaos-testing<br/>NAME                                        READY   STATUS    RESTARTS   AGE<br/>chaos-controller-manager-754d4f7585-h9p4c   1/1     Running   0          7h9m<br/>chaos-daemon-94687                          1/1     Running   0          7h9m<br/>chaos-daemon-k7pnj                          1/1     Running   0          7h9m<br/>chaos-daemon-tfgp6                          1/1     Running   0          7h9m<br/>chaos-dashboard-6fdb79c549-vmvtp            1/1     Running   0          7h9m</span></pre><p id="5eab" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">我们可以看到3个组件处于运行状态，控制器、仪表板和混沌守护进程作为守护进程集。</p><p id="e123" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">让我们沿着它检查不同的CRD，哪一个混沌网格在集群上产生</p><pre class="ne nf ng nh gt nu nv nw nx aw ny bi"><span id="e7b9" class="ni jz iq nv b gy nz oa l ob oc">$ kubectl get crds<br/>NAME                             CREATED AT<br/>iochaos.chaos-mesh.org           2020-10-22T09:15:05Z<br/>kernelchaos.chaos-mesh.org       2020-10-22T09:15:05Z<br/>networkchaos.chaos-mesh.org      2020-10-22T09:15:05Z<br/>podchaos.chaos-mesh.org          2020-10-22T09:15:05Z<br/>podiochaos.chaos-mesh.org        2020-10-22T09:15:05Z<br/>podnetworkchaos.chaos-mesh.org   2020-10-22T09:15:05Z<br/>stresschaos.chaos-mesh.org       2020-10-22T09:15:05Z<br/>timechaos.chaos-mesh.org         2020-10-22T09:15:05Z</span></pre><p id="d093" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">这些CRD代表了上面详细提到的各种故障注入场景。</p><h2 id="2aaa" class="ni jz iq bd ka nj nk dn ke nl nm dp ki lh nn no km ll np nq kq lp nr ns ku nt bi translated">访问混沌网格仪表板</h2><p id="b634" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">为了访问仪表板，我们将使用Kube代理，或者您甚至可以在Loadbalancer上公开它。</p><p id="8063" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">让我们使用以下命令在混沌网格仪表板上标识容器端口:</p><pre class="ne nf ng nh gt nu nv nw nx aw ny bi"><span id="006c" class="ni jz iq nv b gy nz oa l ob oc">$ kubectl get deploy chaos-dashboard -n chaos-testing -o=jsonpath="{.spec.template.spec.containers[0].ports[0].containerPort}{'\n'}"</span></pre><p id="2c71" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">输出显示仪表板正在侦听的端口</p><pre class="ne nf ng nh gt nu nv nw nx aw ny bi"><span id="d1e3" class="ni jz iq nv b gy nz oa l ob oc">2333</span></pre><p id="bc72" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">让我们将一个本地端口转发到pod上的端口，我们可以从上面的<code class="fe oe of og nv b">get pods</code>输出中获得Pod名称。</p><pre class="ne nf ng nh gt nu nv nw nx aw ny bi"><span id="f7d0" class="ni jz iq nv b gy nz oa l ob oc">$ kubectl port-forward -n chaos-testing <!-- -->chaos-dashboard-6fdb79c549-vmvtp<!-- --> 8888:2333</span></pre><p id="a3f2" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">您可以访问<a class="ae lu" href="http://localhost:8888" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">上的仪表板http://localhost:8888 </strong> </a></p><figure class="ne nf ng nh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oh"><img src="../Images/1d5d48ddbee1b6551375a38116f9e6fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uhA9iw9nGgAHeZjlg7d3pw.png"/></div></div></figure><p id="62b5" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">我们可以从仪表板上看到，还没有创建实验。</p><h2 id="4f83" class="ni jz iq bd ka nj nk dn ke nl nm dp ki lh nn no km ll np nq kq lp nr ns ku nt bi translated">创造第一个混沌实验</h2><p id="f4a9" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">对于一个测试场景，我们将使用名称空间选择器来定义创建混乱的范围。</p><p id="902e" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">在这个场景中，我们将在一个名称空间中为一个pod配置Chaos，它将被调度为每隔<code class="fe oe of og nv b">1 minute</code>一次杀死一个Pod。在这个例子中，应用程序没有标签选择器，因此它可以在多次部署的情况下杀死任何Pod。</p><p id="831e" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">在我们的配置中，我们可以有<a class="ae lu" href="https://chaos-mesh.org/docs/user_guides/experiment_scope" rel="noopener ugc nofollow" target="_blank">个不同的范围</a>。</p><p id="b5cf" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">让我们克隆我们的示例存储库来获得YAML文件</p><pre class="ne nf ng nh gt nu nv nw nx aw ny bi"><span id="b8b8" class="ni jz iq nv b gy nz oa l ob oc">$ git clone <a class="ae lu" href="https://github.com/ronakbanka/chaos-mesh-examples.git" rel="noopener ugc nofollow" target="_blank">https://github.com/ronakbanka/chaos-mesh-examples.git</a></span><span id="3b38" class="ni jz iq nv b gy od oa l ob oc">$ cd pod-chaos</span></pre><p id="ac8b" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">使用Kubectl <code class="fe oe of og nv b">namespace-selector</code>定义文件应用，这将创建3个资源</p><ul class=""><li id="bca9" class="mp mq iq ky b kz lv ld lw lh mr ll ms lp mt lt mu mv mw mx bi translated">按名称命名空间<code class="fe oe of og nv b">appns</code></li><li id="e732" class="mp mq iq ky b kz my ld mz lh na ll nb lp nc lt mu mv mw mx bi translated">使用<code class="fe oe of og nv b">nginx</code>映像部署3个副本。</li><li id="0594" class="mp mq iq ky b kz my ld mz lh na ll nb lp nc lt mu mv mw mx bi translated">使用podchaos.chaos-mesh.org CRD的混沌对象</li></ul><pre class="ne nf ng nh gt nu nv nw nx aw ny bi"><span id="5917" class="ni jz iq nv b gy nz oa l ob oc">$ kubectl apply -f pod-namespace-selector.yml</span><span id="4d61" class="ni jz iq nv b gy od oa l ob oc">namespace/appns created<br/>deployment.apps/nginx created<br/>podchaos.chaos-mesh.org/pod-kill-example created</span></pre><p id="edf5" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">现在让我们在Chaos Mesh仪表板上验证这个实验，使用上面的<a class="ae lu" href="#2aaa" rel="noopener ugc nofollow">步骤访问仪表板。</a></p><figure class="ne nf ng nh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oi"><img src="../Images/73e62124380473973001ff32a84ecc27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vcdMgEiqMeOF_-ohcVRcdw.png"/></div></div></figure><p id="3626" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">您可以看到您的实验已经创建并显示在仪表板上。</p><p id="b673" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">点击<code class="fe oe of og nv b">pod-kill-example</code>旁边的<code class="fe oe of og nv b">DETAIL</code>按钮，获取我们实验的详细信息。</p><figure class="ne nf ng nh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oj"><img src="../Images/a94443c252c5de44509362ceab8d375f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*72UqDoD9OWFFfPZcxH2QfQ.png"/></div></div></figure><p id="8388" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">细节基本上是相同的，在我们的YAML文件中有关于PodChaos对象的，如果你看一下这个文件</p><pre class="ne nf ng nh gt nu nv nw nx aw ny bi"><span id="8740" class="ni jz iq nv b gy nz oa l ob oc">apiVersion: chaos-mesh.org/v1alpha1<br/>kind: PodChaos<br/>metadata:<br/>  name: pod-kill-example<br/>  namespace: chaos-testing<br/>spec:<br/>  action: pod-kill<br/>  mode: one<br/>  selector:<br/>    namespaces:<br/>      - appns<br/>  scheduler:<br/>    cron: "<a class="ae lu" href="http://twitter.com/every" rel="noopener ugc nofollow" target="_blank">@every</a> 1m"</span></pre><h2 id="c414" class="ni jz iq bd ka nj nk dn ke nl nm dp ki lh nn no km ll np nq kq lp nr ns ku nt bi translated">验证分离舱故障实验</h2><p id="78f4" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">现在让我们在终端上使用<code class="fe oe of og nv b">kubectl</code> CLI来验证pod故障</p><ul class=""><li id="151d" class="mp mq iq ky b kz lv ld lw lh mr ll ms lp mt lt mu mv mw mx bi translated">初态</li></ul><pre class="ne nf ng nh gt nu nv nw nx aw ny bi"><span id="2ca2" class="ni jz iq nv b gy nz oa l ob oc">$ kubectl get pods -n appns -w<br/>NAME                     READY   STATUS    RESTARTS   AGE<br/>nginx-86c57db685-57l8j   1/1     Running   0          7s<br/>nginx-86c57db685-mf2m9   1/1     Running   0          5m7s<br/>nginx-86c57db685-szvqx   1/1     Running   0          3m7s</span></pre><ul class=""><li id="d4f8" class="mp mq iq ky b kz lv ld lw lh mr ll ms lp mt lt mu mv mw mx bi translated">中间状态</li></ul><pre class="ne nf ng nh gt nu nv nw nx aw ny bi"><span id="4e17" class="ni jz iq nv b gy nz oa l ob oc">nginx-86c57db685-mf2m9   1/1     Terminating   0          6m<br/>nginx-86c57db685-26cs9   0/1     Pending       0          0s<br/>nginx-86c57db685-26cs9   0/1     Pending       0          0s<br/>nginx-86c57db685-mf2m9   1/1     Terminating   0          6m<br/>nginx-86c57db685-26cs9   0/1     ContainerCreating   0          0s<br/>nginx-86c57db685-26cs9   1/1     Running             0          4s</span></pre><p id="03fd" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">我们可以清楚的看到nginx-86c57db685-mf2m9正在得到<code class="fe oe of og nv b">terminated</code>，nginx-86 c 57 db 685–26cs 9正在得到<code class="fe oe of og nv b">created</code>。</p><ul class=""><li id="26dd" class="mp mq iq ky b kz lv ld lw lh mr ll ms lp mt lt mu mv mw mx bi translated">末态</li></ul><pre class="ne nf ng nh gt nu nv nw nx aw ny bi"><span id="7ad6" class="ni jz iq nv b gy nz oa l ob oc">$ kubectl get pods -n appns<br/>NAME                     READY   STATUS    RESTARTS   AGE<br/>nginx-86c57db685-skcfv   1/1     Running   0          118s<br/>nginx-86c57db685-szvqx   1/1     Running   0          9m58s<br/>nginx-86c57db685-znk4r   1/1     Running   0          58s</span></pre><p id="2c43" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">我们可以看到此时有两个重新创建的豆荚。此外，我们可以在实验细节下查看混沌网格仪表板上的事件。</p><figure class="ne nf ng nh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ok"><img src="../Images/431429e6d1c866bb86cda3858cad429e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ckodb-KPVdcYbStLtPDiuQ.png"/></div></div></figure><h2 id="781a" class="ni jz iq bd ka nj nk dn ke nl nm dp ki lh nn no km ll np nq kq lp nr ns ku nt bi translated">清理设置</h2><p id="9463" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">执行以下步骤来清理设置和卸载组件，以及类集群。</p><pre class="ne nf ng nh gt nu nv nw nx aw ny bi"><span id="708e" class="ni jz iq nv b gy nz oa l ob oc">$ kubectl delete ns chaos-testing</span><span id="9152" class="ni jz iq nv b gy od oa l ob oc">$ kind delete cluster --name=kind</span></pre><p id="0bf8" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">我们可以使用混沌网格创建各种失败场景，我将在接下来的几篇博客中分享。</p><p id="308f" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">更多文档和参考</p><ul class=""><li id="8137" class="mp mq iq ky b kz lv ld lw lh mr ll ms lp mt lt mu mv mw mx bi translated"><a class="ae lu" href="https://chaos-mesh.org/docs/" rel="noopener ugc nofollow" target="_blank">混沌网文档</a></li><li id="de61" class="mp mq iq ky b kz my ld mz lh na ll nb lp nc lt mu mv mw mx bi translated"><a class="ae lu" href="https://chaos-mesh.org/interactiveTutorial" rel="noopener ugc nofollow" target="_blank">互动教程尝试混沌网格</a></li><li id="a44f" class="mp mq iq ky b kz my ld mz lh na ll nb lp nc lt mu mv mw mx bi translated"><a class="ae lu" href="https://chaos-mesh.org/docs/use_cases/multi_data_centers" rel="noopener ugc nofollow" target="_blank">多数据网络延迟场景</a></li></ul></div></div>    
</body>
</html>