<html>
<head>
<title>Rethinking REST Practices</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反思休息实践</h1>
<blockquote>原文：<a href="https://itnext.io/rethinking-rest-practices-1efc56418980?source=collection_archive---------1-----------------------#2018-04-24">https://itnext.io/rethinking-rest-practices-1efc56418980?source=collection_archive---------1-----------------------#2018-04-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f05f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用AWS AppSync的GraphQL简介</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/45f29145fcee99ac9c98d42cf1bd983b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_2qqWl6CmMXOPune."/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">这是API开发…</figcaption></figure><blockquote class="kv"><p id="158f" class="kw kx iq bd ky kz la lb lc ld le lf dk translated">最终，您会意识到API开发只不过是列表操作。</p></blockquote><h1 id="9ad2" class="lg lh iq bd li lj lk ll lm ln lo lp lq jw lr jx ls jz lt ka lu kc lv kd lw lx bi translated">思考数据的更好方式</h1><h2 id="d143" class="ly lh iq bd li lz ma dn lm mb mc dp lq md me mf ls mg mh mi lu mj mk ml lw mm bi translated">结局是尽人皆知的</h2><p id="6678" class="pw-post-body-paragraph mn mo iq mp b mq mr jr ms mt mu ju mv md mw mx my mg mz na nb mj nc nd ne lf ij bi translated">数据传输的基本前提，包括请求和接收列表。这很简单，但它触及到了我们开发使用web服务传递数据的技术和最佳实践的根本原因。RESTful APIs已经发展到可以满足全球众多个人、创业公司和企业的需求。它们有用、高效，围绕它们的概念也相对标准化。如果您不知道如何创建一个API，您可以很快找到构建一个可以满足您需求的优秀API的信息。这时候事情就复杂了…</p><p id="4bc4" class="pw-post-body-paragraph mn mo iq mp b mq nf jr ms mt ng ju mv md nh mx my mg ni na nb mj nj nd ne lf ij bi translated">如果你开始钻研REST，你会意识到抛出列表有更多的意义。许多人在开发API时都会遇到一些常见的问题，您也会遇到许多其他人曾经遇到过的问题，例如:</p><ul class=""><li id="68f6" class="nk nl iq mp b mq nf mt ng md nm mg nn mj no lf np nq nr ns bi translated">你应该多严格地遵守休息原则？你如何决定哪些算？</li><li id="dc3b" class="nk nl iq mp b mq nt mt nu md nv mg nw mj nx lf np nq nr ns bi translated">你应该如何处理版本控制？你应该烦恼吗？</li><li id="9d12" class="nk nl iq mp b mq nt mt nu md nv mg nw mj nx lf np nq nr ns bi translated">你想如何组织你的对象？什么样的数据形式最适合您的API的客户端？</li><li id="e9d0" class="nk nl iq mp b mq nt mt nu md nv mg nw mj nx lf np nq nr ns bi translated">您是否向用户发送了适当的数据？你在给他们发送他们不需要的信息吗？</li><li id="fede" class="nk nl iq mp b mq nt mt nu md nv mg nw mj nx lf np nq nr ns bi translated">关于相关或层次数据，他们是否能够从嵌套结构中高效地查询他们需要的内容？</li><li id="ec4f" class="nk nl iq mp b mq nt mt nu md nv mg nw mj nx lf np nq nr ns bi translated">用户是否能够很容易地找出哪些API端点是可用的，以及应该如何使用它们？</li></ul><p id="3345" class="pw-post-body-paragraph mn mo iq mp b mq nf jr ms mt ng ju mv md nh mx my mg ni na nb mj nj nd ne lf ij bi translated">有许多方法可以实现这些，归结起来就是传达给定端点将返回或接受的结构。这里所做的选择产生的一连串问题将从后端波及到客户端。第二个问题是，这些问题和选择并不罕见。这些问题的答案都遵循最佳实践。但是，当试图构建一个灵活的、工作良好的API时，仍然存在许多模糊之处。这些是通常被容忍的情况。</p><p id="3935" class="pw-post-body-paragraph mn mo iq mp b mq nf jr ms mt ng ju mv md nh mx my mg ni na nb mj nj nd ne lf ij bi translated">如果你还没有猜到，有一个解决方案可以将我们从休息的教条中解放出来，并允许我们以一种声明性的、强大的、有趣的T2方式来解决所有这些问题。这个解决方案就是<strong class="mp ir"> GraphQL </strong>。</p><h2 id="381c" class="ly lh iq bd li lz ma dn lm mb mc dp lq md me mf ls mg mh mi lu mj mk ml lw mm bi translated">规格和结构</h2><p id="a28a" class="pw-post-body-paragraph mn mo iq mp b mq mr jr ms mt mu ju mv md mw mx my mg mz na nb mj nc nd ne lf ij bi translated">GraphQL首先是一个规范。它使您的数据交互成为声明性的。该规范的实现需要创建一个描述数据类型(更具体地说，是形状)的模式，该模式向API的客户端公开。它不是数据库的替代品，也不是一个对象关系映射系统——它是一套工具，用来替代(我们将在后面看到，增强)传统的REST API。这可以与您可能已经用来与数据交互的所有业务层和软件层结合使用。</p><p id="e12e" class="pw-post-body-paragraph mn mo iq mp b mq nf jr ms mt ng ju mv md nh mx my mg ni na nb mj nj nd ne lf ij bi translated">交互采取的形式是发送到传统上单个GraphQL端点的查询。您可能经常看到这个端点类似于www.mysite.com/graphql.的一个<strong class="mp ir">客户端</strong>(您的应用程序)可以向<strong class="mp ir">服务器</strong>发送包含<strong class="mp ir">查询</strong>(获取数据)和<strong class="mp ir">突变</strong>(操作数据)的请求。GraphQL服务器接收到一个<strong class="mp ir">查询</strong>或<strong class="mp ir">变异</strong>并将其分解成组成部分，数据<strong class="mp ir">被解析</strong>并发回。它可以被分解，因为GraphQL服务器使用一个<strong class="mp ir">模式</strong>来了解它可以解析的不同<strong class="mp ir">类型的数据</strong>以及哪些<strong class="mp ir">解析器</strong>用于那些<strong class="mp ir">类型</strong>。</p><p id="71a4" class="pw-post-body-paragraph mn mo iq mp b mq nf jr ms mt ng ju mv md nh mx my mg ni na nb mj nj nd ne lf ij bi translated">哇哦。那里有很多。让我们把它分解开来，从最基本的开始。</p><h1 id="38a3" class="lg lh iq bd li lj lk ll lm ln lo lp lq jw nz jx ls jz oa ka lu kc ob kd lw lx bi translated">从类型生成</h1><p id="839b" class="pw-post-body-paragraph mn mo iq mp b mq mr jr ms mt mu ju mv md mw mx my mg mz na nb mj nc nd ne lf ij bi translated">使用GraphQL时释放的所有强大功能的基础都归结于类型。这使得您的API调用具有结构化的性质。这允许服务器智能地返回符合该结构的数据。这允许客户端自省该数据，以发现允许它使用的结构。这种自省提供的开发体验和工具远远超出了传统REST API所允许的生成文档。</p><blockquote class="kv"><p id="8e81" class="kw kx iq bd ky kz oc od oe of og lf dk translated">默认情况下，内省、工具化和缺乏仪式意味着更少的愚蠢。</p></blockquote><p id="5df2" class="pw-post-body-paragraph mn mo iq mp b mq oh jr ms mt oi ju mv md oj mx my mg ok na nb mj ol nd ne lf ij bi translated">REST API中存在的许多问题要么是不可能的，要么至少不容易重现。许多通常被容忍的情况消失了。让我们通过查看一些基本的类型示例来更深入地了解这些思想。</p><p id="ecd8" class="pw-post-body-paragraph mn mo iq mp b mq nf jr ms mt ng ju mv md nh mx my mg ni na nb mj nj nd ne lf ij bi translated">下面是一个包含标题、描述和评级的<code class="fe om on oo op b">Game</code>基本类型的例子。</p><pre class="kg kh ki kj gt oq op or os aw ot bi"><span id="c11b" class="ly lh iq op b gy ou ov l ow ox">type Game {<br/>  title: String!<br/>  description: String<br/>  rating: Int!<br/>}</span></pre><p id="267a" class="pw-post-body-paragraph mn mo iq mp b mq nf jr ms mt ng ju mv md nh mx my mg ni na nb mj nj nd ne lf ij bi translated">该类型声明声明了在查询或变异中引用游戏时可以返回的对象类型。<code class="fe om on oo op b">title</code>被声明为<code class="fe om on oo op b">String!</code>——这意味着该值应该是一个字符串，感叹号意味着该值不可为空(也就是必需的)。这表示当游戏类型被检索或创建时，该契约将被强制执行，并生成一个错误，表示该值不存在。</p><p id="a021" class="pw-post-body-paragraph mn mo iq mp b mq nf jr ms mt ng ju mv md nh mx my mg ni na nb mj nj nd ne lf ij bi translated">默认情况下，GraphQL中有五种标量类型。这些包括<code class="fe om on oo op b">String</code>、<code class="fe om on oo op b">Int</code>、<code class="fe om on oo op b">Float</code>、<code class="fe om on oo op b">Boolean</code>和<code class="fe om on oo op b">ID</code>。模式中声明的所有类型都归结于这些(在自定义服务器实现中，您可以实现自己的类型)。这意味着所有用户定义的类型，比如上面的<code class="fe om on oo op b">Game</code>类型，必须提供<strong class="mp ir">解析器</strong>，以便可以从服务、数据库或其他数据源收集数据。</p><h1 id="8730" class="lg lh iq bd li lj lk ll lm ln lo lp lq jw nz jx ls jz oa ka lu kc ob kd lw lx bi translated">下决心者</h1><p id="8f58" class="pw-post-body-paragraph mn mo iq mp b mq mr jr ms mt mu ju mv md mw mx my mg mz na nb mj nc nd ne lf ij bi translated">解析器用于检索或操作由类型定义的数据。例如，我们上面列出的<code class="fe om on oo op b">Game</code>类型可能有一个解析器，它从一个表中查询所有游戏的数据库。它可能调用一个服务，该服务又调用一个查询该表的DAO层。它甚至可能有一个解析器，调用REST API返回游戏列表。解析器应该做的就是关心它被定义要解析的数据类型。这样，他们可以将任何数据源或服务整合到一个统一的API中。</p><blockquote class="kv"><p id="8eb7" class="kw kx iq bd ky kz oc od oe of og lf dk translated">解析器通过解析来自服务、DAO甚至其他REST API的类型来提供适应性强的API表面。</p></blockquote><p id="fea3" class="pw-post-body-paragraph mn mo iq mp b mq oh jr ms mt oi ju mv md oj mx my mg ok na nb mj ol nd ne lf ij bi translated">这是关键。这种基于类型的方法让您可以将数据更多地看作是桶或列表，而不是结构之间的关系。类型之间的关系可以建立在松散耦合的可能性中，而不是强耦合的结果中。我们稍后将回到这个区别。</p><h1 id="4b32" class="lg lh iq bd li lj lk ll lm ln lo lp lq jw nz jx ls jz oa ka lu kc ob kd lw lx bi translated">查询和突变</h1><p id="f632" class="pw-post-body-paragraph mn mo iq mp b mq mr jr ms mt mu ju mv md mw mx my mg mz na nb mj nc nd ne lf ij bi translated">查询和突变是GraphQL实现中两种可能的交互类型。查询从服务器请求数据。突变通过引起副作用和返回结果来与数据交互。它们依赖解析器对数据进行操作。它们提供了客户端用来与数据交互的API接口。让我们来看一些基础知识。</p><h2 id="403d" class="ly lh iq bd li lz ma dn lm mb mc dp lq md me mf ls mg mh mi lu mj mk ml lw mm bi translated">问题</h2><p id="4554" class="pw-post-body-paragraph mn mo iq mp b mq mr jr ms mt mu ju mv md mw mx my mg mz na nb mj nc nd ne lf ij bi translated">让我们看一个使用我们之前定义的游戏类型来获取游戏列表的查询的基本示例。</p><pre class="kg kh ki kj gt oq op or os aw ot bi"><span id="d8c7" class="ly lh iq op b gy ou ov l ow ox">allGames {<br/>  title<br/>  description<br/>  rating<br/>}</span></pre><p id="32e7" class="pw-post-body-paragraph mn mo iq mp b mq nf jr ms mt ng ju mv md nh mx my mg ni na nb mj nj nd ne lf ij bi translated">这是GraphQL服务器可以解析的基本请求的结构。这告诉服务器运行模式中定义的<code class="fe om on oo op b">allGames</code>查询，并返回每个游戏的<code class="fe om on oo op b">title</code>、<code class="fe om on oo op b">description</code>和<code class="fe om on oo op b">rating</code>属性。这使用由模式为<code class="fe om on oo op b">allGames</code>查询定义的解析器从数据源实际获取数据。</p><h2 id="750a" class="ly lh iq bd li lz ma dn lm mb mc dp lq md me mf ls mg mh mi lu mj mk ml lw mm bi translated">突变</h2><p id="35b7" class="pw-post-body-paragraph mn mo iq mp b mq mr jr ms mt mu ju mv md mw mx my mg mz na nb mj nc nd ne lf ij bi translated">这是一个创造游戏的基本突变的例子。</p><pre class="kg kh ki kj gt oq op or os aw ot bi"><span id="8578" class="ly lh iq op b gy ou ov l ow ox">createGame (<br/>  title: String!, <br/>  description: String, <br/>  rating: Int! ) <br/>{<br/>  title<br/>  description<br/>  rating<br/>}</span></pre><p id="81e3" class="pw-post-body-paragraph mn mo iq mp b mq nf jr ms mt ng ju mv md nh mx my mg ni na nb mj nj nd ne lf ij bi translated">这个例子展示了如何定义一个接受<code class="fe om on oo op b">title</code>、<code class="fe om on oo op b">description</code>和<code class="fe om on oo op b">rating</code>作为变量的突变。这个<code class="fe om on oo op b">createGame</code>变异的解析器将负责获取变量并将它们插入到一个表中，调用服务，或者处理变异所需要的操作。该操作将完成并返回插入的数据。</p><p id="9105" class="pw-post-body-paragraph mn mo iq mp b mq nf jr ms mt ng ju mv md nh mx my mg ni na nb mj nj nd ne lf ij bi translated">我们将稍微深入了解一下查询和突变。接下来，让我们讨论一下所有这些概念是如何在客户机和服务器上结合在一起的。</p><h1 id="8523" class="lg lh iq bd li lj lk ll lm ln lo lp lq jw nz jx ls jz oa ka lu kc ob kd lw lx bi translated">客户端和服务器</h1><h2 id="649d" class="ly lh iq bd li lz ma dn lm mb mc dp lq md me mf ls mg mh mi lu mj mk ml lw mm bi translated">客户</h2><p id="d116" class="pw-post-body-paragraph mn mo iq mp b mq mr jr ms mt mu ju mv md mw mx my mg mz na nb mj nc nd ne lf ij bi translated">客户端有点超出了本文的范围。简单地说，它可以从简单的HTML页面发送POST或GET请求到使用GraphQL客户端库，比如<a class="ae oy" href="https://www.apollographql.com/client/" rel="noopener ugc nofollow" target="_blank"> Apollo </a>。我们将在以后的帖子中讨论这个问题…</p><h2 id="961b" class="ly lh iq bd li lz ma dn lm mb mc dp lq md me mf ls mg mh mi lu mj mk ml lw mm bi translated">计算机网络服务器</h2><p id="fd71" class="pw-post-body-paragraph mn mo iq mp b mq mr jr ms mt mu ju mv md mw mx my mg mz na nb mj nc nd ne lf ij bi translated">GraphQL服务器是API的主干。这就是接收请求并处理它们以返回数据或执行变异的部分。这可以是自定义实现(<a class="ae oy" href="https://github.com/graphql/graphql-js" rel="noopener ugc nofollow" target="_blank">节点</a>，<a class="ae oy" href="https://github.com/graphql-dotnet/graphql-dotnet" rel="noopener ugc nofollow" target="_blank">)。Net </a>、<a class="ae oy" href="http://graphql-java.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank"> Java </a>等……)或者托管服务实例(比如<a class="ae oy" href="https://aws.amazon.com/appsync/" rel="noopener ugc nofollow" target="_blank"> AppSync </a>或者<a class="ae oy" href="https://www.graph.cool/" rel="noopener ugc nofollow" target="_blank"> Graphcool </a>)。</p><p id="a4ea" class="pw-post-body-paragraph mn mo iq mp b mq nf jr ms mt ng ju mv md nh mx my mg ni na nb mj nj nd ne lf ij bi translated">对于传统的REST API，您可能有一系列端点来定义客户端可以请求的数据。当您向特定端点发送请求时，作为响应接收的数据或执行的操作由服务器提前定义。这与GraphQL端点形成鲜明对比，因为您发送的任何特定请求都是基于该请求中包含的内容进行处理的。服务器通过描述响应的<em class="ny">可能性</em>而不是响应本身来处理这个问题。客户端负责根据允许的查询和变化请求它需要的内容或它想要执行的操作。</p><blockquote class="kv"><p id="e88a" class="kw kx iq bd ky kz oc od oe of og lf dk translated">查询不描述返回的内容。相反，它描述了什么<em class="oz">可以被</em>返回。合同不是一组数据，合同是数据的一种形式。</p></blockquote><p id="515f" class="pw-post-body-paragraph mn mo iq mp b mq oh jr ms mt oi ju mv md oj mx my mg ok na nb mj ol nd ne lf ij bi translated">您选择的实现将负责解析这些操作并对它们做出反应。让我们通过用AWS AppSync启动我们自己的实例来看看这在实践中意味着什么。</p><p id="f230" class="pw-post-body-paragraph mn mo iq mp b mq nf jr ms mt ng ju mv md nh mx my mg ni na nb mj nj nd ne lf ij bi translated">更多将在<a class="ae oy" href="https://medium.com/@mwarger/go-forth-and-appsync-34450c277075" rel="noopener">的下一部</a>中出现。看看吧！</p><h1 id="fd20" class="lg lh iq bd li lj lk ll lm ln lo lp lq jw nz jx ls jz oa ka lu kc ob kd lw lx bi translated">最后</h1><p id="95b8" class="pw-post-body-paragraph mn mo iq mp b mq mr jr ms mt mu ju mv md mw mx my mg mz na nb mj nc nd ne lf ij bi translated">我认为在大多数情况下，GraphQL客观上是RESTful APIs的更好替代方案。它的灵活性在其类型系统和支持的技术中表现得最为突出。这带来了优秀的工具、美妙的开发体验和传统API开发无法比拟的快速迭代周期。我们将很快检查AWS AppSync，看看它与传统的REST API相比如何— <a class="ae oy" href="https://twitter.com/mwarger" rel="noopener ugc nofollow" target="_blank">如果您想知道下一篇文章何时发布，请在Twitter @ m larger</a>上关注我。有关使用GraphQL开发API的更多信息，请查看<a class="ae oy" href="https://www.howtographql.com/" rel="noopener ugc nofollow" target="_blank"> HowToGraphQL </a>。如果您有任何问题或意见，请在下面留下。</p></div><div class="ab cl pa pb hu pc" role="separator"><span class="pd bw bk pe pf pg"/><span class="pd bw bk pe pf pg"/><span class="pd bw bk pe pf"/></div><div class="ij ik il im in"><blockquote class="ph pi pj"><p id="a761" class="mn mo ny mp b mq nf jr ms mt ng ju mv pk nh mx my pl ni na nb pm nj nd ne lf ij bi translated">我叫Mat Warger，是<a class="ae oy" href="http://www.keyholesoftware.com" rel="noopener ugc nofollow" target="_blank"> Keyhole软件</a>的开发人员。这里的想法是我自己的。</p><p id="0e5f" class="mn mo ny mp b mq nf jr ms mt ng ju mv pk nh mx my pl ni na nb pm nj nd ne lf ij bi translated">如果你喜欢这篇文章，请为它鼓掌并分享给你的朋友。我喜欢写令人兴奋的新技术，所以如果你愿意，也可以关注这里或twitter！</p></blockquote><h2 id="443b" class="ly lh iq bd li lz ma dn lm mb mc dp lq md me mf ls mg mh mi lu mj mk ml lw mm bi translated">感谢您的阅读！</h2></div></div>    
</body>
</html>