<html>
<head>
<title>JavaScript’s Async/Await versus Promises: The Great Debate</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript的异步/等待与承诺:大辩论</h1>
<blockquote>原文：<a href="https://itnext.io/javascripts-async-await-versus-promise-the-great-debate-6308cb2e10b3?source=collection_archive---------0-----------------------#2019-05-12">https://itnext.io/javascripts-async-await-versus-promise-the-great-debate-6308cb2e10b3?source=collection_archive---------0-----------------------#2019-05-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><h1 id="d25f" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">做好准备，你们正在步入雷区</h1><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ko"><img src="../Images/d346696b0cd657e5ae2da79e5df683dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*Sy_9C5J4oUykmW5T8WCIMA.jpeg"/></div></figure><h1 id="cc65" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">引发这场大火的火花</h1><p id="4485" class="pw-post-body-paragraph kw kx it ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi lu translated"><span class="l lv lw lx bm ly lz ma mb mc di">几周前的一天，在工作中，我正在做自己的事情，写一些React代码，提交拉请求，而我团队中的另一个开发人员实际上向我们的代码库扔了一颗手榴弹。</span></p><p id="563b" class="pw-post-body-paragraph kw kx it ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt im bi translated">他问了一个看似温和的问题，关于为什么我们在JavaScript中继续使用<a class="ae mi" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" rel="noopener ugc nofollow" target="_blank">承诺</a>而不是更新的ECMAScript 17版本<a class="ae mi" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function" rel="noopener ugc nofollow" target="_blank"> async /await </a>。🚨乍一看，这似乎是足够无辜的。</p><p id="9fb5" class="pw-post-body-paragraph kw kx it ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt im bi translated">让我告诉你，通常情况下，我完全支持在JavaScript中使用新的热门技术(特别是当它内置在语言中并且大多数现代浏览器都支持<a class="ae mi" href="https://caniuse.com/#search=async" rel="noopener ugc nofollow" target="_blank">——看看你持续的不遵从性，Internet Explorer)，但是即使我听说过async/await的伟大之处，我也没有真正使用过它。</a></p><p id="a6c0" class="pw-post-body-paragraph kw kx it ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt im bi translated">我真的没有看到async/await的任何好处超过使用承诺——它们最终都完成了同样的事情:以高性能、一致的方式处理异步数据调用。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/8b2dd504950e14d09f60ec545089a79b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1342/format:webp/1*SCNrG5GXdNkh87yLOn6glw.png"/></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">所有的承诺，所有的时间。</figcaption></figure><p id="800d" class="pw-post-body-paragraph kw kx it ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt im bi translated">我喜欢承诺，我对<code class="fe mo mp mq mr b">.then()</code>的语法、<code class="fe mo mp mq mr b">.catch()</code>的错误处理以及所有这些都很满意，切换需要重写我们的应用程序当前进行的许多异步调用。因此，在我根除团队以传统承诺形式编写的所有艰苦工作之前，我想找到一些超越“这是ES7，它是更新的”的理由，以跳转到async/await。</p><p id="c1bd" class="pw-post-body-paragraph kw kx it ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt im bi translated">所以，我开始学习。</p><blockquote class="ms"><p id="e07b" class="mt mu it bd mv mw mx my mz na nb lt dk translated">今天，我将比较在JavaScript应用程序中选择promises或async/await来满足异步数据需求的好处(和个人偏好)。</p></blockquote><h1 id="e09f" class="jq jr it bd js jt ju jv jw jx jy jz ka kb nc kd ke kf nd kh ki kj ne kl km kn bi translated">JavaScript异步数据处理(或缺乏异步数据处理)简史</h1><p id="d5ec" class="pw-post-body-paragraph kw kx it ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在我详细介绍promises和async/await之前，我想回到JavaScript的一个黑暗时代，那时异步数据获取是一个更大的问题，较少的解决方案被称为<a class="ae mi" href="https://javascript.info/callbacks" rel="noopener ugc nofollow" target="_blank">回调</a>。</p><h2 id="f2cd" class="nf jr it bd js ng nh dn jw ni nj dp ka lh nk nl ke ll nm nn ki lp no np km nq bi translated">AJAX和回调</h2><p id="4b95" class="pw-post-body-paragraph kw kx it ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">AJAX代表异步JavaScript和XML，回调是JavaScript中处理异步调用的一种OG方式。归结起来，就是当一个函数应该在另一个函数已经执行完之后<strong class="ky iu">执行的时候——因此得名‘回调’。</strong></p><p id="c629" class="pw-post-body-paragraph kw kx it ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt im bi translated"><strong class="ky iu">简单来说就是回调</strong></p><p id="fb70" class="pw-post-body-paragraph kw kx it ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt im bi translated">第一个函数通常会返回第二个函数需要执行某种操作的数据，与Java等多线程语言不同，单线程的<a class="ae mi" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop" rel="noopener ugc nofollow" target="_blank"> JavaScript事件循环</a>会将第一个函数推送到调用堆栈并执行它，一旦完成其请求，就从调用堆栈中弹出该函数调用，并继续运行，同时将队列中等待的其他操作推送到调用堆栈(这使用户界面看起来不像是冻结的)。然后，当来自另一个服务器的响应(异步数据)返回时，它被添加到队列中，当事件循环看到堆栈为空时，它最终会将该响应推送到调用堆栈，调用堆栈会将该响应作为回调函数执行。</p><p id="533f" class="pw-post-body-paragraph kw kx it ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt im bi translated">虽然这篇文章不是关于回调的，所以我不会讲太多细节，但是这里有一个例子说明了带有回调函数的JavaScript事件是什么样子的。</p><p id="5355" class="pw-post-body-paragraph kw kx it ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt im bi translated"><strong class="ky iu">传统JavaScript回调示例</strong></p><pre class="kp kq kr ks gt nr mr ns nt aw nu bi"><span id="447b" class="nf jr it mr b gy nv nw l nx ny">// the original function to call</span><span id="530a" class="nf jr it mr b gy nz nw l nx ny">function orderFood(food, callback) {<br/>  alert(`Ordering my ${food} at the counter.`);<br/>  callback();<br/>}</span><span id="5456" class="nf jr it mr b gy nz nw l nx ny">// the callback once the order's up</span><span id="fd9f" class="nf jr it mr b gy nz nw l nx ny">function alertFoodReady(){<br/>  alert(`Order's ready for pickup`);<br/>}</span><span id="b016" class="nf jr it mr b gy nz nw l nx ny">// calling the function and adding the callback as the second <br/>// parameter</span><span id="0327" class="nf jr it mr b gy nz nw l nx ny"><strong class="mr iu">orderFood('burger', alertFoodReady);</strong></span></pre><p id="822b" class="pw-post-body-paragraph kw kx it ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt im bi translated">这是一个非常简单的例子，公平地说，它只显示了“快乐之路”——回调起作用时的路径，食物已经准备好，可以拿走了。</p><p id="e7f3" class="pw-post-body-paragraph kw kx it ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt im bi translated">这里没有涉及到错误处理，也没有举例说明当有很多很多的异步依赖项嵌套在一起时会发生什么。这被JavaScript开发人员亲切地称为“回调地狱”或“末日金字塔”。</p><h2 id="f86b" class="nf jr it bd js ng nh dn jw ni nj dp ka lh nk nl ke ll nm nn ki lp no np km nq bi translated">回调地狱</h2><p id="26ca" class="pw-post-body-paragraph kw kx it ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面是回调地狱的一个例子。这是一场噩梦，不要试图否认。当多个函数需要来自其他函数的数据来完成它们的工作时，就会发生这种情况。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ob oc di od bf oe"><div class="gh gi oa"><img src="../Images/17d2b84b797a124ea8f125a939d62f8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YCh1fXt_Ycf-00a9E88-Hg.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">回调地狱的一个完美例子:一个回调，在一个回调中，在另一个回调中永恒。</figcaption></figure><p id="f410" class="pw-post-body-paragraph kw kx it ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt im bi translated">如果你想错误地处理它，或者试图在混乱中添加一些新功能，请便。</p><p id="2878" class="pw-post-body-paragraph kw kx it ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt im bi translated">然而，我不会做任何事情，所以让我们同意AJAX和回调曾经是处理异步数据的一种方式，但它们不再是事实上的方式。接下来我会向你们展示更好的解决方案。让我们继续承诺。</p><h1 id="6c76" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">承诺承诺</h1><p id="8cad" class="pw-post-body-paragraph kw kx it ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Mozilla在定义承诺方面做得非常好，所以我将使用他们的定义作为对承诺的第一次介绍。</p><blockquote class="of og oh"><p id="0ea3" class="kw kx oi ky b kz md lb lc ld me lf lg oj mf lj lk ok mg ln lo ol mh lr ls lt im bi translated">一个<code class="fe mo mp mq mr b"><a class="ae mi" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" rel="noopener ugc nofollow" target="_blank">Promise</a></code>是一个对象，代表一个异步操作的最终完成或失败…本质上，一个承诺是一个返回的对象，你给它附加回调，而不是把回调传递给一个函数。— Mozilla Docs，使用承诺</p></blockquote><p id="0664" class="pw-post-body-paragraph kw kx it ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt im bi translated">下面是另一个名为<code class="fe mo mp mq mr b">createAudioFileAsync()</code>的异步回调函数的例子。它接受三个参数:<code class="fe mo mp mq mr b">audioSettings</code>、一个<code class="fe mo mp mq mr b">successCallback</code>和一个<code class="fe mo mp mq mr b">failureCallback</code>。</p><p id="0253" class="pw-post-body-paragraph kw kx it ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt im bi translated"><strong class="ky iu">传统JavaScript回调示例</strong></p><pre class="kp kq kr ks gt nr mr ns nt aw nu bi"><span id="758f" class="nf jr it mr b gy nv nw l nx ny">function successCallback(result) {<br/>  console.log("Audio file ready at URL: " + result);<br/>}<br/><br/>function failureCallback(error) {<br/>  console.log("Error generating audio file: " + error);<br/>}<br/><br/>createAudioFileAsync(audioSettings, successCallback, failureCallback);</span></pre><p id="7f39" class="pw-post-body-paragraph kw kx it ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt im bi translated">仅仅一个异步数据调用就需要很多函数和代码。</p><p id="fba9" class="pw-post-body-paragraph kw kx it ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt im bi translated">这是同样的功能的简写，当它被转换成承诺时。</p><p id="1780" class="pw-post-body-paragraph kw kx it ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt im bi translated"><strong class="ky iu">带有回调的JavaScript Promise示例</strong></p><pre class="kp kq kr ks gt nr mr ns nt aw nu bi"><span id="af41" class="nf jr it mr b gy nv nw l nx ny">createAudioFileAsync(audioSettings)<br/>  .then(successCallback, failureCallback);</span></pre><p id="387c" class="pw-post-body-paragraph kw kx it ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt im bi translated">你觉得这样更好吗？对我来说它看起来更好。但是等等，还有更多。成功和失败回调都在<code class="fe mo mp mq mr b">.then()</code>内，可以改为:</p><p id="5228" class="pw-post-body-paragraph kw kx it ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt im bi translated"><strong class="ky iu">现代JavaScript Promise示例</strong></p><pre class="kp kq kr ks gt nr mr ns nt aw nu bi"><span id="01d4" class="nf jr it mr b gy nv nw l nx ny">createAudioFileAsync(audioSettings)<br/>  .then(successCallback)<br/>  .catch(failureCallback);</span></pre><p id="ff68" class="pw-post-body-paragraph kw kx it ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt im bi translated">即使这样，也可以通过将原来的<code class="fe mo mp mq mr b">successCallback()</code>和<code class="fe mo mp mq mr b">failureCallback()</code>功能替换为ES6箭头功能来再次现代化。</p><p id="d061" class="pw-post-body-paragraph kw kx it ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt im bi translated"><strong class="ky iu"> ES6箭头功能承诺示例</strong></p><pre class="kp kq kr ks gt nr mr ns nt aw nu bi"><span id="03fc" class="nf jr it mr b gy nv nw l nx ny">createAudioFileAsync(audioSettings)<br/>  .then(result =&gt; console.log(`Audio file ready at URL: ${result}`)<br/>  .catch(error =&gt; console.log(`Error generating audio file: ${error}`);</span></pre><p id="08b7" class="pw-post-body-paragraph kw kx it ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt im bi translated">这现在看起来是一个小的改进，但是一旦你开始将承诺链接在一起，或者在前进之前等待多个承诺解决，在最后有一个单独的<code class="fe mo mp mq mr b">.catch()</code>块来处理任何内部出错的事情，是非常方便的。继续读下去，我会告诉你的。</p><h2 id="9f0f" class="nf jr it bd js ng nh dn jw ni nj dp ka lh nk nl ke ll nm nn ki lp no np km nq bi translated">承诺优于回访</h2><p id="3c83" class="pw-post-body-paragraph kw kx it ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">除了更清晰的语法之外，承诺比回调更有优势。</p><ul class=""><li id="a842" class="om on it ky b kz md ld me lh oo ll op lp oq lt or os ot ou bi translated">在异步操作成功或失败后，添加了<code class="fe mo mp mq mr b"><a class="ae mi" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then" rel="noopener ugc nofollow" target="_blank">then()</a></code>甚至<em class="oi">的回调将被调用，如上。</em></li><li id="133f" class="om on it ky b kz ov ld ow lh ox ll oy lp oz lt or os ot ou bi translated">通过多次调用<code class="fe mo mp mq mr b"><a class="ae mi" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then" rel="noopener ugc nofollow" target="_blank">then()</a></code>可以添加多个回调。每个回调都按照它们被插入的顺序一个接一个地执行(这就是我前面提到的链接)。</li><li id="c808" class="om on it ky b kz ov ld ow lh ox ll oy lp oz lt or os ot ou bi translated">在失败后，可以将事件<em class="oi">链接在一起，即<code class="fe mo mp mq mr b">catch</code>，这对于完成新的动作是有用的，即使在动作链失败后也是如此。</em></li><li id="2691" class="om on it ky b kz ov ld ow lh ox ll oy lp oz lt or os ot ou bi translated"><code class="fe mo mp mq mr b">Promise.all()</code>返回一个单个的<code class="fe mo mp mq mr b"><a class="ae mi" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" rel="noopener ugc nofollow" target="_blank">Promise</a></code>,当作为可迭代对象传递的所有承诺都已解析时，或者当可迭代对象不包含承诺时，该单个的【】解析。回调做不到这一点。</li><li id="3037" class="om on it ky b kz ov ld ow lh ox ll oy lp oz lt or os ot ou bi translated">承诺通过捕捉所有错误，甚至抛出的异常和编程错误，解决了回调末日金字塔的一个根本缺陷。这对于异步操作的功能组合至关重要。</li></ul><p id="039c" class="pw-post-body-paragraph kw kx it ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt im bi translated">要备份某个时刻，通常需要背靠背执行两个或更多异步操作，其中每个后续操作在前一个操作成功时开始，并带有前一个步骤的结果。这可以通过<a class="ae mi" href="https://javascript.info/promise-chaining" rel="noopener ugc nofollow" target="_blank">承诺链</a>来实现。</p><p id="4d42" class="pw-post-body-paragraph kw kx it ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt im bi translated">在过去，当回调相互依赖信息时，我们进入了回调地狱。见下文(也请注意，必须为每次回调添加的倍数<code class="fe mo mp mq mr b">failureCallbacks</code>)。</p><p id="f602" class="pw-post-body-paragraph kw kx it ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt im bi translated"><strong class="ky iu">传统的嵌套回调链示例</strong></p><pre class="kp kq kr ks gt nr mr ns nt aw nu bi"><span id="e249" class="nf jr it mr b gy nv nw l nx ny">doSomething(function(result) {<br/>  doSomethingElse(result, function(newResult) {<br/>    doThirdThing(newResult, function(finalResult) {<br/>      console.log('Got the final result: ' + finalResult);<br/>    }, failureCallback);<br/>  }, failureCallback);<br/>}, failureCallback);</span></pre><p id="1c79" class="pw-post-body-paragraph kw kx it ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt im bi translated">随着承诺链的引入，这个“末日金字塔”变成了你在下面看到的样子(见最后一个<code class="fe mo mp mq mr b">failureCallback</code>实例的改进)。</p><p id="e7e0" class="pw-post-body-paragraph kw kx it ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt im bi translated"><strong class="ky iu">新承诺链示例</strong></p><pre class="kp kq kr ks gt nr mr ns nt aw nu bi"><span id="4130" class="nf jr it mr b gy nv nw l nx ny">doSomething()<br/>.then(function(result) {<br/>  return doSomethingElse(result);<br/>})<br/>.then(function(newResult) {<br/>  return doThirdThing(newResult);<br/>})<br/>.then(function(finalResult) {<br/>  console.log('Got the final result: ' + finalResult);<br/>})<br/>.catch(failureCallback);</span></pre><p id="601a" class="pw-post-body-paragraph kw kx it ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt im bi translated">随着ES6 arrow函数的出现，下一个例子中的代码变得更加紧凑。</p><p id="5c19" class="pw-post-body-paragraph kw kx it ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt im bi translated"><strong class="ky iu"> ES6箭头功能承诺链示例</strong></p><pre class="kp kq kr ks gt nr mr ns nt aw nu bi"><span id="3153" class="nf jr it mr b gy nv nw l nx ny">doSomething()<br/>.then(result =&gt; doSomethingElse(result))<br/>.then(newResult =&gt; doThirdThing(newResult))<br/>.then(finalResult =&gt; {<br/>  console.log(`Got the final result: ${finalResult}`);<br/>})<br/>.catch(failureCallback);</span></pre><p id="fbff" class="pw-post-body-paragraph kw kx it ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt im bi translated">不错吧。</p><p id="bc22" class="pw-post-body-paragraph kw kx it ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt im bi translated">注意，对于箭头函数，<code class="fe mo mp mq mr b">return</code>语句不需要传递结果，而是通过<a class="ae mi" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions" rel="noopener ugc nofollow" target="_blank">隐式返回</a>返回结果。</p><p id="d833" class="pw-post-body-paragraph kw kx it ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt im bi translated">同样地，有时你需要两个或更多不相关的承诺来解决所有问题，然后再继续前进，这就是<code class="fe mo mp mq mr b"><a class="ae mi" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all" rel="noopener ugc nofollow" target="_blank">Promise.all()</a></code>成为神赐的地方。</p><p id="7ddc" class="pw-post-body-paragraph kw kx it ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt im bi translated"><strong class="ky iu"> Promise.all()例</strong></p><pre class="kp kq kr ks gt nr mr ns nt aw nu bi"><span id="738e" class="nf jr it mr b gy nv nw l nx ny">var promise1 = Promise.resolve(3);<br/>var promise2 = 42;<br/>var promise3 = new Promise(function(resolve, reject) {<br/>  setTimeout(resolve, 100, 'foo');<br/>});</span><span id="7612" class="nf jr it mr b gy nz nw l nx ny">Promise.all([promise1, promise2, promise3]).then(function(values) {<br/>  console.log(values);<br/>});<br/>// expected output: Array [3, 42, "foo"]</span></pre><p id="6aa0" class="pw-post-body-paragraph kw kx it ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt im bi translated">只需将这三个承诺作为数组传递给<code class="fe mo mp mq mr b">Promise.all()</code>，该承诺会一直等待，直到这三个承诺都解决了，然后才进入语句的<code class="fe mo mp mq mr b">.then()</code>部分。</p><p id="2ae6" class="pw-post-body-paragraph kw kx it ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt im bi translated">我希望看到试镜能优雅地做到这一点。</p><h2 id="01bf" class="nf jr it bd js ng nh dn jw ni nj dp ka lh nk nl ke ll nm nn ki lp no np km nq bi translated">承诺FTW？</h2><p id="9977" class="pw-post-body-paragraph kw kx it ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这就是我的团队在React应用程序中编写的那种代码。它干净、简洁、易读(在我看来)，我看不出有什么问题。然后我研究了异步等待。</p><h1 id="8eb6" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">ECMAScript 17的新热点:异步/等待</h1><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi pa"><img src="../Images/a9b377c9f5fbaee6dd9c0a50ff5aaae5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*nuUXRudPEsTs_Q9EcwletA.jpeg"/></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">异步/等待的承诺。看到我做了什么吗？😏</figcaption></figure><p id="534f" class="pw-post-body-paragraph kw kx it ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt im bi translated">我再一次向Mozilla寻求async和await的最简洁的定义。</p><blockquote class="of og oh"><p id="7a55" class="kw kx oi ky b kz md lb lc ld me lf lg oj mf lj lk ok mg ln lo ol mh lr ls lt im bi translated"><code class="fe mo mp mq mr b"><strong class="ky iu">async function</strong></code>声明定义了一个<strong class="ky iu">异步函数</strong>，它返回一个<code class="fe mo mp mq mr b"><a class="ae mi" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/AsyncFunction" rel="noopener ugc nofollow" target="_blank">AsyncFunction</a></code>对象。异步函数是通过事件循环异步操作的函数，使用隐式的<code class="fe mo mp mq mr b"><a class="ae mi" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" rel="noopener ugc nofollow" target="_blank">Promise</a></code>返回结果。但是使用异步函数的代码的语法和结构更像是使用标准的同步函数…</p><p id="695c" class="kw kx oi ky b kz md lb lc ld me lf lg oj mf lj lk ok mg ln lo ol mh lr ls lt im bi translated">一个<code class="fe mo mp mq mr b">async</code>函数可以包含一个<code class="fe mo mp mq mr b"><a class="ae mi" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await" rel="noopener ugc nofollow" target="_blank">await</a></code>表达式，该表达式暂停异步函数的执行并等待传递的<code class="fe mo mp mq mr b">Promise</code>的解析，然后恢复<code class="fe mo mp mq mr b">async</code>函数的执行并返回解析后的值。— Mozilla Docs，异步函数</p></blockquote><p id="36ac" class="pw-post-body-paragraph kw kx it ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt im bi translated">虽然这对您来说可能有意义，但我通常从查看代码中受益，以真正了解它的要点。这里有几个代码示例，这样您就可以自己看到不同之处了。</p><p id="24cc" class="pw-post-body-paragraph kw kx it ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt im bi translated"><strong class="ky iu">基于承诺的示例</strong></p><p id="ea4f" class="pw-post-body-paragraph kw kx it ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt im bi translated">这里有一个基于承诺的<code class="fe mo mp mq mr b">fetch()</code>电话的例子。</p><pre class="kp kq kr ks gt nr mr ns nt aw nu bi"><span id="080e" class="nf jr it mr b gy nv nw l nx ny">function logFetch(url) {<br/>  return fetch(url)<br/>    .then(response =&gt; response.text())<br/>    .then(text =&gt; {<br/>      console.log(text);<br/>    }).catch(err =&gt; {<br/>      console.error('fetch failed', err);<br/>    });<br/>}</span></pre><p id="b80e" class="pw-post-body-paragraph kw kx it ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt im bi translated">好吧，对我来说这很简单。</p><p id="650c" class="pw-post-body-paragraph kw kx it ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt im bi translated"><strong class="ky iu">异步/等待示例</strong></p><p id="428c" class="pw-post-body-paragraph kw kx it ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt im bi translated">这是同一个调用的异步/等待版本。</p><pre class="kp kq kr ks gt nr mr ns nt aw nu bi"><span id="6b44" class="nf jr it mr b gy nv nw l nx ny">async function logFetch(url) {<br/>  try {<br/>    const response = await fetch(url);<br/>    console.log(await response.text());<br/>  }<br/>  catch (err) {<br/>    console.log('fetch failed', err);<br/>  }<br/>}</span></pre><p id="298b" class="pw-post-body-paragraph kw kx it ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt im bi translated">这看起来也很容易理解，但是更加简洁。</p><h2 id="2a48" class="nf jr it bd js ng nh dn jw ni nj dp ka lh nk nl ke ll nm nn ki lp no np km nq bi translated">异步/等待承诺的优点</h2><p id="3ef8" class="pw-post-body-paragraph kw kx it ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这有什么大不了的？</p><blockquote class="ms"><p id="1fe0" class="mt mu it bd mv mw mx my mz na nb lt dk translated">实际上，这似乎可以归结为async/await实际上是承诺的语法糖，<em class="pb">因为它仍然使用承诺。</em></p></blockquote><figure class="pd pe pf pg ph kt gh gi paragraph-image"><div class="gh gi pc"><img src="../Images/d004fe847deafc94b289246b45293ac4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1136/format:webp/1*m5ssulLI_LCagFa13zNJ-g.jpeg"/></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">到头来都是承诺！</figcaption></figure><p id="9d46" class="pw-post-body-paragraph kw kx it ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt im bi translated">不过，对语法的改变是它对许多人的吸引力开始变得明显的地方。</p><ul class=""><li id="f4e5" class="om on it ky b kz md ld me lh oo ll op lp oq lt or os ot ou bi translated">使用异步函数的代码的语法和结构更像是使用标准的同步函数。</li><li id="10ca" class="om on it ky b kz ov ld ow lh ox ll oy lp oz lt or os ot ou bi translated">在上面的例子中，<code class="fe mo mp mq mr b">logFetch()</code>函数的行数是相同的，但是所有的回调都消失了。这使得它更容易阅读，特别是对于那些不太熟悉承诺的人。</li><li id="fc5b" class="om on it ky b kz ov ld ow lh ox ll oy lp oz lt or os ot ou bi translated">另一个有趣的花絮是，你的任何事情<code class="fe mo mp mq mr b">await</code>都要经过<code class="fe mo mp mq mr b">Promise.resolve()</code>(对我们来说，通常是<code class="fe mo mp mq mr b">.then(result)</code>承诺的解析)，所以你可以安全地<code class="fe mo mp mq mr b">await</code>非本地承诺。那很酷。</li><li id="7f9f" class="om on it ky b kz ov ld ow lh ox ll oy lp oz lt or os ot ou bi translated">您可以安全地将async/await与<code class="fe mo mp mq mr b">Promise.all()</code>结合起来，在继续前进之前等待多个异步调用返回。</li></ul><p id="5b63" class="pw-post-body-paragraph kw kx it ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt im bi translated">为了展示另一个更复杂的async/await示例(更好地展示了新语法的可读性)，这里有一段返回最终结果大小的流代码。</p><p id="398f" class="pw-post-body-paragraph kw kx it ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt im bi translated"><strong class="ky iu">第二个</strong> <strong class="ky iu">基于承诺的例子</strong></p><pre class="kp kq kr ks gt nr mr ns nt aw nu bi"><span id="962c" class="nf jr it mr b gy nv nw l nx ny">function getResponseSize(url) {<br/>  return fetch(url).then(response =&gt; {<br/>    const reader = response.body.getReader();<br/>    let total = 0;<br/><br/>    return reader.read().then(function processResult(result) {<br/>      if (result.done) return total;<br/><br/>      const value = result.value;<br/>      total += value.length;<br/>      console.log('<strong class="mr iu">Promise-Based Example</strong>', value);<br/><br/>      return reader.read().then(processResult);<br/>    })<br/>  });<br/>}</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi pa"><img src="../Images/bfd7de5aae8818032700882e82d2fa90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*tCu2Uls2jsBB2hZggVWRgQ.jpeg"/></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">我，第一眼看到上面的代码。</figcaption></figure><p id="75f1" class="pw-post-body-paragraph kw kx it ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt im bi translated">它看起来相当优雅，但是在你最终理解它在做什么之前，你必须盯着代码看很久。这是同样的代码，但是使用了async/await。</p><p id="d5f4" class="pw-post-body-paragraph kw kx it ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt im bi translated"><strong class="ky iu">第二个异步/等待示例</strong></p><pre class="kp kq kr ks gt nr mr ns nt aw nu bi"><span id="a8ed" class="nf jr it mr b gy nv nw l nx ny">async function getResponseSize(url) {<br/>  const response = await fetch(url);<br/>  const reader = response.body.getReader();<br/>  let result = await reader.read();<br/>  let total = 0;<br/><br/>  while (!result.done) {<br/>    const value = result.value;<br/>    total += value.length;<br/>    console.log('Data received', value);<br/>    // get the next result<br/>    result = await reader.read();<br/>  }<br/><br/>  return total;<br/>}</span></pre><p id="eaf6" class="pw-post-body-paragraph kw kx it ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt im bi translated">好了，现在我对async/await语法的可读性有了更好的理解。这些代码更容易阅读，我同意这一点。事实上，我可以把它和<code class="fe mo mp mq mr b">Promise.all()</code>结合起来，这也很棒。</p><blockquote class="of og oh"><p id="34fc" class="kw kx oi ky b kz md lb lc ld me lf lg oj mf lj lk ok mg ln lo ol mh lr ls lt im bi translated">但是，要改变整个代码库中所有基于承诺的调用，我需要对开发人员来说更有说服力，而不仅仅是可读性……我需要冷酷的、硬的、性能驱动的好处。</p></blockquote><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi pi"><img src="../Images/313690aa20e41b3daec9fd64a0ab527d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1180/format:webp/1*2o48VfZ748mIj0xByN6_MA.png"/></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">说服我重构一切。</figcaption></figure><h2 id="238c" class="nf jr it bd js ng nh dn jw ni nj dp ka lh nk nl ke ll nm nn ki lp no np km nq bi translated">银弹时刻:当Async/Await赢得胜利</h2><p id="fd72" class="pw-post-body-paragraph kw kx it ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里有一篇<a class="ae mi" href="https://v8.dev/blog/fast-async" rel="noopener ugc nofollow" target="_blank">文章</a>真正改变了我的想法，它来自一个团队，该团队实际构建并维护了运行我所有Chrome浏览器的JavaScript V8引擎。</p><blockquote class="ms"><p id="4de1" class="mt mu it bd mv mw mx my mz na nb lt dk translated">这篇文章总结了如何对ECMAScript规范进行一些微小的更改，并删除两个时间微标记，实际上让"<code class="fe mo mp mq mr b"><strong class="ak">async</strong></code> <strong class="ak"> / </strong> <code class="fe mo mp mq mr b"><strong class="ak">await</strong></code> <strong class="ak">"在所有JavaScript引擎中胜过现在手写的promise代码，"</strong>。</p></blockquote><p id="bdee" class="pw-post-body-paragraph kw kx it ky b kz pj lb lc ld pk lf lg lh pl lj lk ll pm ln lo lp pn lr ls lt im bi translated">是的，你没看错。<strong class="ky iu">V8团队做出了改进，使得async/await函数运行<em class="oi">比JavaScript引擎中的传统承诺</em>更快。</strong></p><p id="6c14" class="pw-post-body-paragraph kw kx it ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt im bi translated">这就是我需要的所有证据。它在浏览器中实际运行速度更快？帮我报名吧。</p><h1 id="3195" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">结论</h1><p id="25e1" class="pw-post-body-paragraph kw kx it ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">承诺和异步/等待完成同样的事情。它们使得检索和处理异步数据变得更加容易。它们消除了对回调的需要，简化了错误处理，减少了无关代码，使等待多个并发调用返回变得容易，并且使在调用之间添加额外代码变得轻而易举。</p><p id="912e" class="pw-post-body-paragraph kw kx it ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt im bi translated">我对重写我们所有使用async/await的传统承诺是否值得持观望态度，<em class="oi">直到</em>我(从JavaScript V8运行时引擎的维护者那里)得知<strong class="ky iu">他们实际上已经</strong> <strong class="ky iu">更新了引擎，以更好地处理async/await调用，而不是承诺。</strong></p><p id="4157" class="pw-post-body-paragraph kw kx it ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt im bi translated">如果我们的应用程序可以从简单的代码语法变化中获得性能提升，我会像这样赢得任何一天。我的最终目标始终是更好的最终用户体验。</p><p id="149e" class="pw-post-body-paragraph kw kx it ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt im bi translated">过几周再来看看，我会写关于JavaScript、ES6或其他与web开发相关的东西，所以请关注我，这样你就不会错过了。</p><p id="c003" class="pw-post-body-paragraph kw kx it ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt im bi translated">感谢您的阅读，我希望这有助于您做出更明智的决定:您更喜欢哪种语法风格:promises还是async/await，这样您就可以在代码库中使用一致的异步数据处理策略。如果你觉得有帮助，请与你的朋友分享！</p><p id="b968" class="pw-post-body-paragraph kw kx it ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt im bi translated">如果你喜欢读这篇文章，你可能也会喜欢我的其他博客:</p><ul class=""><li id="0216" class="om on it ky b kz md ld me lh oo ll op lp oq lt or os ot ou bi translated"><a class="ae mi" rel="noopener ugc nofollow" target="_blank" href="/keep-code-consistent-across-developers-the-easy-way-with-prettier-eslint-60bb7e91b76c">用更漂亮的&amp; ESLint </a>保持开发人员之间的代码一致</li><li id="bdc1" class="om on it ky b kz ov ld ow lh ox ll oy lp oz lt or os ot ou bi translated"><a class="ae mi" rel="noopener ugc nofollow" target="_blank" href="/settings-sync-with-vs-code-c3d4f126989">通过设置同步</a>,将您的VS代码配置轻松带到任何地方</li><li id="ff53" class="om on it ky b kz ov ld ow lh ox ll oy lp oz lt or os ot ou bi translated"><a class="ae mi" rel="noopener ugc nofollow" target="_blank" href="/how-eslint-makes-me-a-better-react-developer-237fb14c00ae">ESLint如何让我成为更好的React开发人员</a></li></ul><p id="fe77" class="pw-post-body-paragraph kw kx it ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt im bi translated"><strong class="ky iu">参考资料和更多资源:</strong></p><ul class=""><li id="e420" class="om on it ky b kz md ld me lh oo ll op lp oq lt or os ot ou bi translated">JavaScript Promises，MDN Docs:<a class="ae mi" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/Docs/Web/JavaScript/Reference/Global _ Objects/Promise</a></li><li id="8f88" class="om on it ky b kz ov ld ow lh ox ll oy lp oz lt or os ot ou bi translated">使用承诺，MDN Docs:<a class="ae mi" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/Docs/Web/JavaScript/Guide/Using _ Promises</a></li><li id="3b1b" class="om on it ky b kz ov ld ow lh ox ll oy lp oz lt or os ot ou bi translated">Promise.all()，MDN Docs:<a class="ae mi" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/Docs/Web/JavaScript/Reference/Global _ Objects/Promise/all</a></li><li id="3a89" class="om on it ky b kz ov ld ow lh ox ll oy lp oz lt or os ot ou bi translated">Async Await，MDN Docs:<a class="ae mi" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/Docs/Web/JavaScript/Reference/Statements/async _ function</a></li><li id="14b9" class="om on it ky b kz ov ld ow lh ox ll oy lp oz lt or os ot ou bi translated">AJAX，W3Schools Docs:【https://www.w3schools.com/php/php_ajax_intro.asp T2】</li><li id="bbe4" class="om on it ky b kz ov ld ow lh ox ll oy lp oz lt or os ot ou bi translated">JavaScript事件循环，MDN Docs:<a class="ae mi" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/Docs/Web/JavaScript/Event Loop</a></li><li id="46c2" class="om on it ky b kz ov ld ow lh ox ll oy lp oz lt or os ot ou bi translated">回调，JavaScript信息:<a class="ae mi" href="https://javascript.info/callbacks" rel="noopener ugc nofollow" target="_blank">https://javascript.info/callbacks</a></li><li id="9514" class="om on it ky b kz ov ld ow lh ox ll oy lp oz lt or os ot ou bi translated">V8开发者博客，更快的异步功能和承诺:<a class="ae mi" href="https://v8.dev/blog/fast-async" rel="noopener ugc nofollow" target="_blank">https://v8.dev/blog/fast-async</a></li></ul></div></div>    
</body>
</html>