<html>
<head>
<title>Internationalization in Angular and React Applications — A Comparison</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Angular和React应用程序的国际化—比较</h1>
<blockquote>原文：<a href="https://itnext.io/internationalization-in-angular-and-react-applications-a-comparison-93883f4e1cdb?source=collection_archive---------1-----------------------#2018-10-24">https://itnext.io/internationalization-in-angular-and-react-applications-a-comparison-93883f4e1cdb?source=collection_archive---------1-----------------------#2018-10-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/46b22f4e39db475802e9b6b0a631214c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1146/format:webp/1*mUkVy9Z2jk0NVC9m82i06w.png"/></div></figure><p id="39c8" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在本文中，我们将探讨React和Angular应用程序在国际化方面的比较(<code class="fe ks kt ku kv b">i18n</code>)。我们将用英语创建一个示例应用程序，然后将内容转换成不同的语言环境。本文不会深入讨论这两个框架的细节，而是关注它们促进<code class="fe ks kt ku kv b">i18n</code>的能力和易用性。</p><h1 id="343b" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">目录</h1><ol class=""><li id="7246" class="lu lv iq jw b jx lw kb lx kf ly kj lz kn ma kr mb mc md me bi translated">设定目标</li><li id="52ab" class="lu lv iq jw b jx mf kb mg kf mh kj mi kn mj kr mb mc md me bi translated">理解术语</li><li id="a82e" class="lu lv iq jw b jx mf kb mg kf mh kj mi kn mj kr mb mc md me bi translated">在角度应用程序中实现国际化</li><li id="c5e7" class="lu lv iq jw b jx mf kb mg kf mh kj mi kn mj kr mb mc md me bi translated">在React应用程序中实现国际化</li><li id="fdff" class="lu lv iq jw b jx mf kb mg kf mh kj mi kn mj kr mb mc md me bi translated">警告和比较</li></ol><h1 id="c486" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">设定目标</h1><p id="2a2f" class="pw-post-body-paragraph ju jv iq jw b jx lw jz ka kb lx kd ke kf mk kh ki kj ml kl km kn mm kp kq kr ij bi translated">在我们开始编码和深入研究任何细节之前，为本文创建一个目标是很重要的。到本文结束时，我们将实现以下目标:</p><ol class=""><li id="048e" class="lu lv iq jw b jx jy kb kc kf mn kj mo kn mp kr mb mc md me bi translated">创建一个没有国际化的Angular和React应用程序，然后将它们转换成一个能够处理多种语言的应用程序。</li><li id="856d" class="lu lv iq jw b jx mf kb mg kf mh kj mi kn mj kr mb mc md me bi translated">确定以最小开销为应用程序提供服务的方式。</li><li id="8cc0" class="lu lv iq jw b jx mf kb mg kf mh kj mi kn mj kr mb mc md me bi translated">比较和对比每个框架的<code class="fe ks kt ku kv b">i18n</code>功能和易用性。</li></ol><h1 id="b4d9" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">理解术语</h1><p id="0b58" class="pw-post-body-paragraph ju jv iq jw b jx lw jz ka kb lx kd ke kf mk kh ki kj ml kl km kn mm kp kq kr ij bi translated">首先，我们需要定义将在本文中使用的术语:</p><p id="5663" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">区域设置</strong>:用户已经配置或预配置的地理区域或一组设置，例如<code class="fe ks kt ku kv b">en-US</code>是指美国区域设置的美式英语，而<code class="fe ks kt ku kv b">en-GB</code>是指英国区域设置的英式英语。</p><p id="1f3b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">国际化:</strong>应用程序支持多种语言环境的能力。</p><p id="e298" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">本地化</strong>:将(国际化的)应用程序翻译成不同的语言环境。</p><h1 id="8c16" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">在角度应用程序中实现国际化</h1><p id="4ddb" class="pw-post-body-paragraph ju jv iq jw b jx lw jz ka kb lx kd ke kf mk kh ki kj ml kl km kn mm kp kq kr ij bi translated">在添加国际化之前，我们需要创建一个包含一些基本路由和内容的裸应用程序。我们将使用Angular CLI创建一个新的应用程序:</p><pre class="mq mr ms mt gt mu kv mv mw aw mx bi"><span id="3991" class="my kx iq kv b gy mz na l nb nc">ng new ng-internationalization</span></pre><p id="ab3d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">并添加一些组件:</p><pre class="mq mr ms mt gt mu kv mv mw aw mx bi"><span id="ad9d" class="my kx iq kv b gy mz na l nb nc">ng g component home</span><span id="6017" class="my kx iq kv b gy nd na l nb nc">ng g component settings</span><span id="968a" class="my kx iq kv b gy nd na l nb nc">ng g component about</span></pre><p id="8037" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">然后，在<code class="fe ks kt ku kv b">src/app</code>文件夹中创建一个名为<code class="fe ks kt ku kv b">app.routing.module.ts</code>的文件，并设置到达这些新创建的组件所需的基本路由，如下所示:</p><figure class="mq mr ms mt gt jr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="eed3" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">最后，将新创建的<code class="fe ks kt ku kv b">AppRoutingModule</code>包含在<code class="fe ks kt ku kv b">BrowserModule</code>之后的<code class="fe ks kt ku kv b">imports</code>部分的<code class="fe ks kt ku kv b">app.module.ts</code>中的主应用模块中。此外，在我们的<code class="fe ks kt ku kv b">app.component.html</code>中添加链接，根据路线定义导航到这些组件。</p><figure class="mq mr ms mt gt jr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="73ab" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">有了中的这些变化，我们的基本应用程序就可以启动了。这也是向我们的主页添加一些内容的好时机，稍后我们将对这些内容进行本地化:</p><figure class="mq mr ms mt gt jr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="4bdc" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们在组件中初始化这些变量:</p><figure class="mq mr ms mt gt jr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="5651" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">从项目的根目录运行命令<code class="fe ks kt ku kv b">npm start</code>并导航到<a class="ae ng" href="http://localhost:4200" rel="noopener ugc nofollow" target="_blank"> http://localhost:4200 </a>来查看您的应用程序运行情况。</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi nh"><img src="../Images/f0a76019ec3ee98e3a283a9bcf998e11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oWiCb5FKd07G-R_6kOTQ7Q.png"/></div></div></figure><h2 id="60a5" class="my kx iq bd ky nm nn dn lc no np dp lg kf nq nr lk kj ns nt lo kn nu nv ls nw bi translated">添加国际化</h2><p id="b888" class="pw-post-body-paragraph ju jv iq jw b jx lw jz ka kb lx kd ke kf mk kh ki kj ml kl km kn mm kp kq kr ij bi translated">现在我们已经有了基础应用程序，由于Angular 提供的开箱即用的<code class="fe ks kt ku kv b"><a class="ae ng" href="https://angular.io/guide/i18n" rel="noopener ugc nofollow" target="_blank">i18n</a></code> <a class="ae ng" href="https://angular.io/guide/i18n" rel="noopener ugc nofollow" target="_blank">支持，启用<code class="fe ks kt ku kv b">i18n</code>所需的更改相当简单。</a></p><p id="5cba" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">整个过程可以分为三个简单的步骤:</p><ol class=""><li id="3fb3" class="lu lv iq jw b jx jy kb kc kf mn kj mo kn mp kr mb mc md me bi translated">标记可翻译的内容并生成翻译</li><li id="44d2" class="lu lv iq jw b jx mf kb mg kf mh kj mi kn mj kr mb mc md me bi translated">生成特定于语言环境的包</li><li id="ff93" class="lu lv iq jw b jx mf kb mg kf mh kj mi kn mj kr mb mc md me bi translated">创建一个服务器，根据所请求的语言环境来识别和提供正确的内容</li></ol><p id="d641" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">标记可翻译内容</strong></p><p id="4738" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">为了本地化应用程序，我们需要标记所有需要翻译的文本。在过去的Angular版本(即1.x版本，又名AngularJS)中，我们被迫创建一个<code class="fe ks kt ku kv b">json</code>文件，其中包含我们的各种英语翻译文本，然后将它们提供给翻译人员，翻译人员会将它们转换成我们需要的任何语言。然后，我们有能力在我们的应用程序中动态切换语言，这是使用<code class="fe ks kt ku kv b">translation</code>指令解决的。</p><p id="4f67" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在Angular的最新版本中，情况有所不同。我们仍然可以使用旧的翻译方式，使用像<a class="ae ng" href="http://www.ngx-translate.com/" rel="noopener ugc nofollow" target="_blank"> ngx-translate </a>这样的库。然而，不管国际化如何，我们都希望提前启用<code class="fe ks kt ku kv b">AOT</code>构建，即<a class="ae ng" href="https://angular.io/guide/aot-compiler" rel="noopener ugc nofollow" target="_blank">编译的代码，这样我们就可以从最终的分发包中删除任何不必要的负载/代码(如编译器、附加翻译文件等)。这样做的缺点是，我们最终每个地区只有一个分发文件夹。对于本文，我们假设我们的生产应用程序在AOT模式下运行。</a></p><p id="b966" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们首先需要使用<code class="fe ks kt ku kv b">i18n</code>指令标记要翻译的文本。使用该指令非常简单，我们只需要以下面的格式提供值，整个事情都是可选的。</p><pre class="mq mr ms mt gt mu kv mv mw aw mx bi"><span id="57a3" class="my kx iq kv b gy mz na l nb nc">i18n="Meaning | Description @@UniqueIDToIdentifyThisElement"</span></pre><figure class="mq mr ms mt gt jr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="7511" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">一旦我们标记了需要翻译的整个文本，我们可以运行Angular CLI提供的<code class="fe ks kt ku kv b">xi18n</code>命令，以3种支持的格式(XLF、XLF2或XMB)中的任何一种生成翻译文件，并将其传递给翻译人员。生成的文件还保存翻译的上下文，如翻译id的位置、含义和描述。</p><p id="2168" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">只要<code class="fe ks kt ku kv b">@@id</code>没有被删除或更改，翻译就可以在整个应用程序中移动和重用。在我们的例子中，我们的基本语言环境是英语，也就是说，当我们编码时，我们在模板中用英语书写文本，所以当我们生成翻译文件时，我们希望表示相同的内容。这可以通过用正确的区域扩展名标记文件来轻松完成:</p><pre class="mq mr ms mt gt mu kv mv mw aw mx bi"><span id="09cb" class="my kx iq kv b gy mz na l nb nc">ng xi18n --output-path locale --out-file messages.en.xlf</span></pre><p id="284b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">运行这个命令会在<code class="fe ks kt ku kv b">src/locale</code>文件夹下创建XML文件<code class="fe ks kt ku kv b">messages.en.xlf</code>。</p><p id="fbe7" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">使用这个翻译文件作为默认文件的一个注意事项是Angular需要一个基本的<code class="fe ks kt ku kv b">messages.xlf</code>文件，我们已经将其重命名为<code class="fe ks kt ku kv b">messages.en.xlf </code>。因此，为了弥补这一点，我们只需将翻译添加到与源文件相同的<code class="fe ks kt ku kv b">en</code>语言环境文件中，例如，如果我们有一个标签为<code class="fe ks kt ku kv b">Home</code>的<code class="fe ks kt ku kv b">source</code>节点，我们需要在生成的XML文件中创建一个标签相同的<code class="fe ks kt ku kv b">target</code>节点。</p><figure class="mq mr ms mt gt jr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="fdf3" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">注意，在这种情况下，所有的<code class="fe ks kt ku kv b">sources</code>和<code class="fe ks kt ku kv b">target</code>节点都是相同的文本。</p><p id="f037" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果我们现在希望添加一种额外的语言，比如法语，我们只需要获得新的<code class="fe ks kt ku kv b">xlf</code>文件。在我们的示例应用程序中，由于我们没有真正的翻译人员，我们可以简单地将英文的<code class="fe ks kt ku kv b">xlf</code>文件复制粘贴到一个名为<code class="fe ks kt ku kv b">messages.fr.xlf</code>的新文件中，然后添加<code class="fe ks kt ku kv b">FR-</code>来表示法文翻译。</p><figure class="mq mr ms mt gt jr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><blockquote class="nx ny nz"><p id="d23a" class="ju jv oa jw b jx jy jz ka kb kc kd ke ob kg kh ki oc kk kl km od ko kp kq kr ij bi translated">注意，目标节点与前缀为<code class="fe ks kt ku kv b">FR-</code>的源节点相同。</p></blockquote><p id="6286" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">生成特定于语言环境的包</strong></p><p id="5b22" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">为了构建代码，我们通常使用接受可选参数的<code class="fe ks kt ku kv b">ng build</code>命令。在这种情况下，让我们假设在开发过程中，我们只希望使用英语版本的应用程序。我们做这个假设是为了避免改变<code class="fe ks kt ku kv b">angular.json</code>文件。</p><p id="56de" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">可以更新<code class="fe ks kt ku kv b">angular.json</code>文件来创建多个概要文件，用于构建和运行具有不同地区的应用程序，如此处的<a class="ae ng" href="https://angular.io/guide/i18n#merge-with-the-aot-compiler" rel="noopener ugc nofollow" target="_blank">所示</a>。</p><p id="d4d8" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们将创建一个小脚本，通过向<code class="fe ks kt ku kv b">ng build</code>命令传递可选的特定于语言环境的参数，为我们支持的所有语言环境创建构建。</p><p id="8438" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们首先将受支持的地区列表作为<code class="fe ks kt ku kv b">allLocales</code>添加到<code class="fe ks kt ku kv b">package.json</code>文件中，这将作为我们的应用程序前进的唯一来源。</p><figure class="mq mr ms mt gt jr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="05d0" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们现在可以在自定义构建脚本中使用它:</p><figure class="mq mr ms mt gt jr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="f3eb" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">上面脚本中最重要的一行是我们运行build命令的地方，该命令带有所有自定义的、特定于语言环境的参数:</p><pre class="mq mr ms mt gt mu kv mv mw aw mx bi"><span id="0530" class="my kx iq kv b gy mz na l nb nc">ng build <br/>    --aot <br/>    --base-href=/${locale}/ <br/>    ${args} <br/>    --i18n-file src/locale/messages.${locale}.xlf <br/>    --i18n-format xlf <br/>    --i18n-locale ${locale} <br/>    --output-path dist/${locale}/</span></pre><p id="8125" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们正在创建AOT构建，将应用程序的基本href设置为区域名称，这确保了来自特定于区域的模板的每个请求都将区域作为请求的前缀。</p><p id="cef0" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">要生成特定于语言环境的构建，运行带有可选的<code class="fe ks kt ku kv b">prod</code>标志的以下命令:</p><pre class="mq mr ms mt gt mu kv mv mw aw mx bi"><span id="edb1" class="my kx iq kv b gy mz na l nb nc">npm run build -- --prod</span></pre><p id="c499" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">当构建成功运行时，它会记录以下内容:</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi oe"><img src="../Images/6782e98b9ec981da36ec945157f595ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H6X_yG9ByFEPgOG-ZisAkw.png"/></div></div></figure><p id="a0f5" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们还可以通过打开<code class="fe ks kt ku kv b">dist</code>文件夹并验证任何语言环境的基本href路径来验证构建的结果:</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi of"><img src="../Images/cbeb7d781ff1f7b962b64c235475fe7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*skL-EGXNj-VO5dbLV4TcXA.png"/></div></div></figure><p id="d307" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">创建服务器</strong></p><p id="a415" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">既然我们已经准备好了特定于语言环境的包，我们需要一个服务器来检查来自浏览器的请求，然后根据请求的语言环境提供内容，或者将用户默认为一个预先确定的语言环境(假设为<code class="fe ks kt ku kv b">en</code>)。</p><p id="ec22" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">为此，我们将使用一个Express服务器，它有一个中间件来实现我们的语言环境逻辑:</p><figure class="mq mr ms mt gt jr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="f45b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们简单地分解传入的请求，以确定该请求是否具有现有的区域设置、未知的区域设置，或者它是否是加载索引页面的基本请求，然后相应地处理它。我们还为每个受支持的地区生成一个静态路径，并确保它们指向<code class="fe ks kt ku kv b">dist</code>下的正确文件夹。</p><p id="7379" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">为了测试更改，从项目的根目录运行<code class="fe ks kt ku kv b">node server.js</code>，我们可以看到应用程序从端口3000开始。</p><p id="3174" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">打开<code class="fe ks kt ku kv b"><a class="ae ng" href="http://localhost:3000" rel="noopener ugc nofollow" target="_blank">http://localhost:3000</a></code>，我们可以看到它从<code class="fe ks kt ku kv b">dist/en/</code>加载内容，这是在没有指定区域设置的情况下的默认设置，URL现在包含了<code class="fe ks kt ku kv b">/en/</code>，因为基本路径被设置为<code class="fe ks kt ku kv b">/en/</code>:</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div class="gh gi og"><img src="../Images/56723d1af1c90cf437df06fb9a81ca77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1238/format:webp/1*iEgQ7NoVLYvHGWLKJ7XlkA.png"/></div></figure><p id="668d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们也可以更改URL中的路径，从法语语言环境加载:</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/d0653b220c26066114ca36edf05219a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1340/format:webp/1*UXZntKnRtri-FhIWO1bGbQ.png"/></div></figure><p id="bdc8" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们可以看到，它不仅按预期加载了翻译，还获得了我们使用的日期、数字和货币管道的本地化值，这要感谢我们在生成构建时传入的<code class="fe ks kt ku kv b">--i18n-locale</code>标志。</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi oi"><img src="../Images/94b5a528cf92e95115fa32fd97ca50e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*AfiJvlSce7w4lf-PrbzeHg.gif"/></div></div></figure><h1 id="f90b" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">在React应用程序中实现国际化</h1><p id="bf49" class="pw-post-body-paragraph ju jv iq jw b jx lw jz ka kb lx kd ke kf mk kh ki kj ml kl km kn mm kp kq kr ij bi translated">在Angular应用程序的情况下，我们需要首先设置基本项目，该项目有3条路线和一些主页上的基本本地化内容。</p><p id="e628" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们将使用<code class="fe ks kt ku kv b">create-react-app</code>来建立项目:</p><pre class="mq mr ms mt gt mu kv mv mw aw mx bi"><span id="0498" class="my kx iq kv b gy mz na l nb nc">create-react-app react-internationalization<br/>cd react-internationalization</span></pre><p id="1b23" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">然后，创建3个组件Home、Settings和About，现在看起来是一样的。</p><figure class="mq mr ms mt gt jr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="cfe2" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在家用组件中，我们将添加一些细微差别，就像我们在上面的角度示例中所做的那样:</p><figure class="mq mr ms mt gt jr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="2b41" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们现在可以通过使用<code class="fe ks kt ku kv b">react-router</code>和<code class="fe ks kt ku kv b">react-router-dom</code>从模板中调用这些组件作为路由，所以让我们安装这些组件:</p><pre class="mq mr ms mt gt mu kv mv mw aw mx bi"><span id="7082" class="my kx iq kv b gy mz na l nb nc">npm i -S react-router react-router-dom</span></pre><p id="bd90" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">并更新我们的<code class="fe ks kt ku kv b">App.js</code>文件:</p><figure class="mq mr ms mt gt jr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="ca04" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">为了模块化，我们将路线导出到它们自己的文件中:</p><figure class="mq mr ms mt gt jr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="2354" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">最后，将主应用程序打包到<code class="fe ks kt ku kv b">BrowserRouter</code>中，我们就可以开始了:</p><figure class="mq mr ms mt gt jr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><h2 id="c6ee" class="my kx iq bd ky nm nn dn lc no np dp lg kf nq nr lk kj ns nt lo kn nu nv ls nw bi translated">添加国际化</h2><p id="ae15" class="pw-post-body-paragraph ju jv iq jw b jx lw jz ka kb lx kd ke kf mk kh ki kj ml kl km kn mm kp kq kr ij bi translated">我们的基本应用程序现在可以国际化了。与大多数React项目一样，我们首先需要选择一个允许我们执行国际化的库。这无论如何都不是负面的，因为这就是React的本意。在本文中，我们将使用提供消息本地化所需组件的<a class="ae ng" href="https://www.npmjs.com/package/react-intl" rel="noopener ugc nofollow" target="_blank"> react-intl </a>和帮助生成翻译文件的<a class="ae ng" href="https://www.npmjs.com/package/react-intl-translations-manager" rel="noopener ugc nofollow" target="_blank">react-intl-translations-manager</a>。</p><pre class="mq mr ms mt gt mu kv mv mw aw mx bi"><span id="9356" class="my kx iq kv b gy mz na l nb nc">yarn add react-intl &amp;&amp; yarn add --dev react-intl-translations-manager</span></pre><p id="53ff" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">与Angular相比，React应用程序的流程没有那么复杂，因为它只需要我们做两件事:</p><ol class=""><li id="8fab" class="lu lv iq jw b jx jy kb kc kf mn kj mo kn mp kr mb mc md me bi translated">标记应用程序中的可翻译内容</li><li id="48f0" class="lu lv iq jw b jx mf kb mg kf mh kj mi kn mj kr mb mc md me bi translated">为区域设置生成翻译</li></ol><p id="f45f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">标记可翻译内容</strong></p><p id="6b77" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">为了将内容标记为可翻译，我们将使用之前安装的翻译管理器。首先，我们需要标记内容，这需要我们将所有文本转换成一个JSON对象，该对象有一个与之相关联的<code class="fe ks kt ku kv b">id</code>。因此，对于我们现有的内容，我们需要将其转换成如下所示的内容，放在<code class="fe ks kt ku kv b">src/translations/extractedMessages</code>下的一个文件中:</p><figure class="mq mr ms mt gt jr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="a9d9" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在模板上，我们只需要引用使用<code class="fe ks kt ku kv b">FormattedMessage</code>组件为每个消息定义的<code class="fe ks kt ku kv b">id</code>:</p><figure class="mq mr ms mt gt jr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="ce1d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">要结合这两者，我们需要使用<code class="fe ks kt ku kv b">react-intl</code> babel插件，它需要所有<code class="fe ks kt ku kv b">extractedMessages</code>的路径，也就是我们之前创建的<code class="fe ks kt ku kv b">App.json</code>文件的路径。要调用插件，用新的babel配置更新<code class="fe ks kt ku kv b">package.json</code>:</p><figure class="mq mr ms mt gt jr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="635d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe ks kt ku kv b">enforceDescription</code>标志防止在App.json文件中的每个元素没有提供描述的情况下出现警告消息。</p><p id="3bca" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">因此，我们做了必要的更改，将内容标记为可供翻译。</p><p id="a8a3" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">为区域设置生成翻译</strong></p><p id="c4a8" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们现在已经准备好为每个地区生成翻译了。类似于Angular应用程序，让我们用一个名为<code class="fe ks kt ku kv b">allLocales</code>的属性来更新我们的<code class="fe ks kt ku kv b">package.json</code>文件，该属性列出了我们希望支持的所有可能的地区。现在分别是<code class="fe ks kt ku kv b">en</code>和<code class="fe ks kt ku kv b">fr</code>。</p><p id="6f46" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">要生成翻译，我们可以使用在项目根目录下创建的一个小脚本，该脚本调用如下所示的翻译管理器，其中包含我们选择的本地文件、我们输入的提取翻译消息和我们输出的目标文件夹:</p><figure class="mq mr ms mt gt jr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="0227" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">要调用它，只需运行<code class="fe ks kt ku kv b">node translationRunner.js</code>，这将生成我们的<code class="fe ks kt ku kv b">en.json</code>和<code class="fe ks kt ku kv b">fr.json</code>文件，如下所示:</p><figure class="mq mr ms mt gt jr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="9985" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">类似地，即使fr.json文件也有相同的内容需要翻译，但是，我们将添加<code class="fe ks kt ku kv b">FR-</code>来表示两者之间的区别:</p><figure class="mq mr ms mt gt jr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="b85e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">为了现在使用这些翻译，我们准备修改应用程序的根，并根据用户的选择提供必要的翻译。</p><p id="43c1" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在此之前，我们还有几项任务要做:</p><ol class=""><li id="6c8c" class="lu lv iq jw b jx jy kb kc kf mn kj mo kn mp kr mb mc md me bi translated">在locale文件夹下创建一个<code class="fe ks kt ku kv b">index.js</code>文件，该文件可以导出所有可用的翻译消息(本例中为<code class="fe ks kt ku kv b">en.json</code>和<code class="fe ks kt ku kv b">fr.json</code>)。</li><li id="cfdb" class="lu lv iq jw b jx mf kb mg kf mh kj mi kn mj kr mb mc md me bi translated">更新<code class="fe ks kt ku kv b">Home.js</code>以使用<code class="fe ks kt ku kv b">FormattedDate</code>和<code class="fe ks kt ku kv b">FormattedNumber</code>组件以及<code class="fe ks kt ku kv b">FormattedMessage</code>组件，从而根据所选的语言环境显示正确的格式。</li></ol><figure class="mq mr ms mt gt jr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="ce6d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">对于货币字段，我们使用了名为USD的自定义格式来表示货币是USD，这不是react-intl库中内置的东西，但是它们为我们提供了创建和管理自己的格式的能力，这些格式实际上是可以传递给<code class="fe ks kt ku kv b">react-intl</code>提供者的JavaScript对象:</p><figure class="mq mr ms mt gt jr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="18e4" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">然后我们可以将它嵌入到index.js文件中，以组合所有内容:</p><figure class="mq mr ms mt gt jr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="297f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们现在可以运行应用程序，并且可以动态切换区域设置并重新呈现整个应用程序:</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi oj"><img src="../Images/141f179efcafebd68e4db93b259cc011.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Lkh-gOfpUDCwHyppolWzNA.gif"/></div></div></figure><h1 id="226e" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">警告和比较</h1><p id="7087" class="pw-post-body-paragraph ju jv iq jw b jx lw jz ka kb lx kd ke kf mk kh ki kj ml kl km kn mm kp kq kr ij bi translated">既然我们的应用程序都按预期运行，让我们讨论一下每种方法中的一些注意事项:</p><ol class=""><li id="fb3c" class="lu lv iq jw b jx jy kb kc kf mn kj mo kn mp kr mb mc md me bi translated">在我看来，这并不是最糟糕的主意，因为在运行时没有开销。另一方面，React仍然必须评估和重新评估由<code class="fe ks kt ku kv b">react-intl</code>提供的所有额外组件(我确信它在引擎盖下有某种形式的记忆)。</li><li id="e791" class="lu lv iq jw b jx mf kb mg kf mh kj mi kn mj kr mb mc md me bi translated">与React不同，Angular <code class="fe ks kt ku kv b">i18n</code>在尝试切换用户区域设置时需要刷新整个页面。根据个人喜好，这可能是优点也可能是缺点。</li><li id="544f" class="lu lv iq jw b jx mf kb mg kf mh kj mi kn mj kr mb mc md me bi translated">在Angular的例子中，我们需要添加一个服务器，它可以根据所选的语言环境来处理和提供正确的分发文件。这意味着增加代码、测试等，你的应用不再是一个静态的捆绑包，更容易部署。</li><li id="afa4" class="lu lv iq jw b jx mf kb mg kf mh kj mi kn mj kr mb mc md me bi translated">Angular提供了一些公共管道，如数字、货币和日期，它们在内部处理所有特定于地区的变化，不像<code class="fe ks kt ku kv b">react-intl</code>那样，有时我们需要根据我们的用例和地区提供定制的格式。</li><li id="070e" class="lu lv iq jw b jx mf kb mg kf mh kj mi kn mj kr mb mc md me bi translated">在Angular应用程序中，如果我们改变默认的输出文件名，我们需要手动将<code class="fe ks kt ku kv b">targets</code>添加到XLF文件中，这很不理想，并且在有许多可翻译字段的情况下很痛苦。</li><li id="d1d8" class="lu lv iq jw b jx mf kb mg kf mh kj mi kn mj kr mb mc md me bi translated">在Angular的例子中，我们需要依赖ngx-translate这样的库来提供缺失的功能，比如翻译模板中没有的字符串。使其成为开箱即用的有利选择<code class="fe ks kt ku kv b">i18n</code>。关注<a class="ae ng" href="https://github.com/angular/angular/issues/11405" rel="noopener ugc nofollow" target="_blank">这个公开的GitHub问题</a>以了解更多信息，并查看一些可能的解决方法。</li><li id="13e4" class="lu lv iq jw b jx mf kb mg kf mh kj mi kn mj kr mb mc md me bi translated">Angular和React应用程序模板都被翻译专用代码污染了，这些代码要么是<code class="fe ks kt ku kv b">i18n</code>指令，要么是附加组件的使用。</li><li id="ff0a" class="lu lv iq jw b jx mf kb mg kf mh kj mi kn mj kr mb mc md me bi translated">最终发行版的大约包大小(整个包的)比较如下(没有源地图。样式和功能尽可能相似):</li></ol><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi ok"><img src="../Images/fccb1757ded618feb9ce9413fcaa8114.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O1FTKNCOPLV9WYpedtYogg.png"/></div></div></figure><blockquote class="nx ny nz"><p id="69ff" class="ju jv oa jw b jx jy jz ka kb kc kd ke ob kg kh ki oc kk kl km od ko kp kq kr ij bi translated">该示例的Angular版本是在新的Ivy编译器推出之前完成的，启用Ivy的有效负载大小可能会有所不同，因为它现在是开箱即用的。</p></blockquote><p id="2960" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这两个示例项目的代码库都可以在这里找到:<a class="ae ng" href="https://github.com/40x/ng-internationalization" rel="noopener ugc nofollow" target="_blank"> Angular </a>，<a class="ae ng" href="https://github.com/40x/react-internationalization" rel="noopener ugc nofollow" target="_blank"> React </a>。</p></div><div class="ab cl ol om hu on" role="separator"><span class="oo bw bk op oq or"/><span class="oo bw bk op oq or"/><span class="oo bw bk op oq"/></div><div class="ij ik il im in"><p id="e643" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><em class="oa">如果你喜欢这个博客，一定要为它鼓掌，</em> <a class="ae ng" href="https://medium.com/@kashyap.mukkamala" rel="noopener"> <em class="oa">阅读更多</em> </a> <em class="oa">或者关注我的</em><a class="ae ng" href="https://www.linkedin.com/in/kashyap-mukkamala/" rel="noopener ugc nofollow" target="_blank"><em class="oa">LinkedIn</em></a><em class="oa">和</em><a class="ae ng" href="https://twitter.com/JSSculptor" rel="noopener ugc nofollow" target="_blank"><em class="oa">Twitter</em></a><em class="oa">。</em></p></div></div>    
</body>
</html>