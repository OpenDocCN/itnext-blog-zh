<html>
<head>
<title>Running Spring Boot Apps? Start Tracing with OpenTelemetry in Minutes!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">运行Spring Boot应用程序？用OpenTelemetry在几分钟内开始追踪！</h1>
<blockquote>原文：<a href="https://itnext.io/running-spring-boot-apps-start-tracing-with-opentelemetry-in-minutes-a5d3dffc1ce1?source=collection_archive---------0-----------------------#2021-11-09">https://itnext.io/running-spring-boot-apps-start-tracing-with-opentelemetry-in-minutes-a5d3dffc1ce1?source=collection_archive---------0-----------------------#2021-11-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/8964a3253413616dc24ac63b28db7edf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oyO5dvCvyoDwPHilDAEOPw.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">使用OpenTelemetry的分布式跟踪(无供应商限制！)—从左顺时针:Elastic APM、Honeycomb和Grafana Tempo</figcaption></figure><p id="5531" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">说真的。在Spring Boot应用程序中启用分布式跟踪就像添加一些依赖项一样简单。但这种情况已经持续了相当长一段时间。那么有什么新的讨论呢？</p><p id="a63e" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">打开遥测。</p><p id="fceb" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">OpenTelemetry(或简称OTEL)已经设法发展成为一个开放标准，正在被这个生态系统中的所有主要参与者采用。这允许您通过一组多语言服务来跟踪请求，而不必绑定到供应商的实现。</p><p id="5e7c" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如果您正在编写一个Spring Boot应用程序(或任何其他框架)，您应该考虑使用OpenTelemetry进行跟踪的<em class="ld"> </em>。</p><p id="da37" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">OTEL图书馆提供各种不同成熟度的语言。你可以在<a class="ae le" href="https://opentelemetry.io/docs/" rel="noopener ugc nofollow" target="_blank"> OTEL文档</a>找到更多关于它的信息。</p><p id="7600" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在这篇博客中，我将向您展示如何在Spring Boot启用追踪，并展示开放标准的威力。</p><h2 id="e85f" class="lf lg it bd lh li lj dn lk ll lm dp ln kq lo lp lq ku lr ls lt ky lu lv lw lx bi translated">春云侦探+ OpenTelemetry</h2><p id="59cb" class="pw-post-body-paragraph kf kg it kh b ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky mc la lb lc im bi translated">OpenTelemetry提供了一个代理(JAR ),用于与Java应用程序连接，以生成跟踪。但是谁真的想和代理商打交道呢？感谢Spring Cloud Sleuth抽象，它将仪器委托给OpenTelemetry，并允许我们快速启动和运行。</p><p id="c90f" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">下面是如何在现有的Spring Boot应用程序上启用它:</p><figure class="md me mf mg gt ju"><div class="bz fp l di"><div class="mh mi l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">使用Spring Cloud Sleuth和OpenTelemetry启用跟踪</figcaption></figure><p id="d1c1" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">参见要点上的<a class="ae le" href="https://gist.github.com/xsreality/d8508c5ef82b05f07acb1da0485fb7dc#gistcomment-3945863" rel="noopener ugc nofollow" target="_blank">第一条注释</a>以获得依赖关系的解释。</p><p id="2306" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这足以生成跨度。实际生成的内容取决于所使用的Spring特性。休息控制器？✅.RestTemplate/WebClient？✅.春季数据JPA/JDBC？✅.阿帕奇卡夫卡？✅.查看<a class="ae le" href="https://docs.spring.io/spring-cloud-sleuth/docs/current-SNAPSHOT/reference/html/integrations.html" rel="noopener ugc nofollow" target="_blank"> Sleuth集成</a>的完整列表。注意，这些都是即将到来的Spring Boot 2.6版本的一部分。</p><p id="353f" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">让我们通过一个例子来看看它是如何工作的。</p><h2 id="c55d" class="lf lg it bd lh li lj dn lk ll lm dp ln kq lo lp lq ku lr ls lt ky lu lv lw lx bi translated">示例1:通过HTTP调用进行通信的服务</h2><figure class="md me mf mg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mj"><img src="../Images/21a39727b2eb77ec84ab91b3492b8113.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ozDnJ36G9DCxBLtg3fxJ3w.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">通过HTTP通信的服务</figcaption></figure><ol class=""><li id="ce6b" class="mk ml it kh b ki kj km kn kq mm ku mn ky mo lc mp mq mr ms bi translated">HTTP服务1对HTTP服务2进行<code class="fe mt mu mv mw b">GET</code>调用。</li><li id="e203" class="mk ml it kh b ki mx km my kq mz ku na ky nb lc mp mq mr ms bi translated">HTTP服务2向whatthecommit.com发出一个<code class="fe mt mu mv mw b">GET</code>呼叫。</li><li id="e69c" class="mk ml it kh b ki mx km my kq mz ku na ky nb lc mp mq mr ms bi translated">HTTP服务2将来自whatthecommit.com的响应返回给HTTP服务1。</li></ol><p id="ae61" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">源代码可在https://github.com/xsreality/spring-boot-tracing-demo<a class="ae le" href="https://github.com/xsreality/spring-boot-tracing-demo" rel="noopener ugc nofollow" target="_blank">获得</a>。</p><p id="0a8f" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">运行应用程序会创建跟踪和跨度id，这些id通过<a class="ae le" href="http://logback.qos.ch/manual/mdc.html" rel="noopener ugc nofollow" target="_blank">回退MDC </a>包含在日志行中。如下所示:</p><pre class="md me mf mg gt nc mw nd ne aw nf bi"><span id="4a0e" class="lf lg it mw b gy ng nh l ni nj">2021-11-06 00:10:02.278  INFO [http-service2,8a45749d445c4e5c4846c931d7f488c5,36a8075ff900ddd4] 9068 --- [nio-8081-exec-1] com.example.HomeController : Another bug bites the dust</span></pre><p id="8ad0" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如果您的应用程序使用定制的日志模式，并且您在日志中看不到跟踪id，那么切换到Spring使用的默认模式，或者至少使用<code class="fe mt mu mv mw b">LOG_LEVEL_PATTERN</code>变量:</p><pre class="md me mf mg gt nc mw nd ne aw nf bi"><span id="f80e" class="lf lg it mw b gy ng nh l ni nj">&lt;property name="CONSOLE_LOG_PATTERN"<br/>          value="%clr(%d{yyyy-MM-dd HH:mm:ss.SSS}){faint} %clr(${LOG_LEVEL_PATTERN:-%5p}) %clr(${PID:- }){magenta} %clr(---){faint} %clr([%15.15t]){faint} %clr(%-40.40logger{39}){cyan} %clr(:){faint} %m%n${LOG_EXCEPTION_CONVERSION_WORD:-%wEx}"/&gt;</span></pre><p id="ab3b" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">跟踪和Span ID生成确认了使用OTEL进行跟踪是可行的。这是通过理解OTEL跨度的工具可视化后的效果。</p><figure class="md me mf mg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nk"><img src="../Images/7f8caf3a1a706782d0c63e3840bc2383.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R2MBy7avVjvz9hp7K8Kq4g.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">用蜂巢可视化HTTP上的痕迹</figcaption></figure><p id="8950" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">不要担心，我们马上会看到如何导出跨度。</p><h2 id="cb7e" class="lf lg it bd lh li lj dn lk ll lm dp ln kq lo lp lq ku lr ls lt ky lu lv lw lx bi translated">示例2:通过Apache Kafka进行通信的服务</h2><figure class="md me mf mg gt ju gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/563a5e2eadc77a0aee8ffc8895b03f0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1314/format:webp/1*CfbG-uTg47sLUkTYoubwXg.png"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">通过Apache Kafka进行通信的服务</figcaption></figure><ol class=""><li id="453d" class="mk ml it kh b ki kj km kn kq mm ku mn ky mo lc mp mq mr ms bi translated">卡夫卡制片人给whatthecommit.com打了一个<code class="fe mt mu mv mw b">GET</code>电话。</li><li id="1fa8" class="mk ml it kh b ki mx km my kq mz ku na ky nb lc mp mq mr ms bi translated">卡夫卡制作人<em class="ld">制作</em>阿帕奇卡夫卡第一步的回应。</li><li id="cae7" class="mk ml it kh b ki mx km my kq mz ku na ky nb lc mp mq mr ms bi translated">卡夫卡消费者<em class="ld">消费</em>来自阿帕奇卡夫卡的消息。</li><li id="4c6b" class="mk ml it kh b ki mx km my kq mz ku na ky nb lc mp mq mr ms bi translated">消费后，卡夫卡消费者将记录存储在H2的内存DB中。</li></ol><p id="2697" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu">注:</strong>通过阿帕奇卡夫卡和JDBC查询捕捉踪迹需要Spring Boot 2.6和Spring Cloud 2021.0，后者截至2021年11月8日尚未发布。但是发布在即，我很高兴能分享新的功能！</p><p id="f68a" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">JDBC查询跟踪需要包括一个额外的库来代理JDBC数据源。您有两个选项— <a class="ae le" href="https://github.com/p6spy/p6spy" rel="noopener ugc nofollow" target="_blank"> p6spy </a>和<a class="ae le" href="https://github.com/ttddyy/datasource-proxy" rel="noopener ugc nofollow" target="_blank">数据源代理</a>。当我在一个JDBC重型应用程序中使用后者时，遇到了一些奇怪的问题。P6Spy完美地为我工作。但是我知道的还不够多，不能推荐一个胜过另一个。检查<a class="ae le" href="https://github.com/xsreality/spring-boot-tracing-demo/blob/main/otel-kafka/kafkaservice2/pom.xml#L29" rel="noopener ugc nofollow" target="_blank"> pom.xml </a>以获得要包含的确切依赖关系。</p><h1 id="b4a9" class="nm lg it bd lh nn no np lk nq nr ns ln nt nu nv lq nw nx ny lt nz oa ob lw oc bi translated">将跨度导出到仪器后端</h1><p id="1352" class="pw-post-body-paragraph kf kg it kh b ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky mc la lb lc im bi translated">未出口的跨度就像未开封的糖果盒。它们需要由一个仪器后端来消费，以便充分享受。这就是OTEL开放标准的闪光点。任何支持OTEL协议(OTLP)的系统都可以用于导出轨迹。越来越多的系统增加了对OTEL的支持，所以我们有选择了！在这里，我将向您展示3种工具——蜂巢、Grafana Tempo和弹性APM。让我们将第二个例子的痕迹导出到Honeycomb并检查可视化效果。</p><p id="3028" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">导出跨度很容易。只需在application.yaml中添加以下属性</p><pre class="md me mf mg gt nc mw nd ne aw nf bi"><span id="7f43" class="lf lg it mw b gy ng nh l ni nj">spring.sleuth.otel.exporter.otlp.endpoint: https://api.honeycomb.io<br/>spring.sleuth.otel.exporter.otlp.headers.x-honeycomb-team: xxx<br/>spring.sleuth.otel.exporter.otlp.headers.x-honeycomb-dataset: dataset</span></pre><p id="54b2" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">你必须在蜂巢注册一个账户(这是免费的！)并创建数据集和API键。</p><figure class="md me mf mg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi od"><img src="../Images/e7f22dab987c28ca65fdd561389d01c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eWuBKsrOXSCQKtrNPTyaSA.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">可视化《蜂巢》中阿帕奇卡夫卡的痕迹</figcaption></figure><figure class="md me mf mg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oe"><img src="../Images/2c023083c974690277862db95c27b5f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CCSPoXKW6zCmcU3hh0iM-Q.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">跨度属性</figcaption></figure><p id="1469" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">单击任意跨度以查看属性。例如，<code class="fe mt mu mv mw b">insert</code> span具有<code class="fe mt mu mv mw b">jdbc.query</code>属性，该属性捕获精确的查询。</p><p id="a520" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">让我们看看这些跨度在Grafana Tempo中是什么样的。您可以在Grafana Cloud上注册以获取配置值。设置以下属性:</p><pre class="md me mf mg gt nc mw nd ne aw nf bi"><span id="04d0" class="lf lg it mw b gy ng nh l ni nj">spring.sleuth.otel.exporter.otlp.endpoint=https://tempo-eu-west-0.grafana.net<br/>spring.sleuth.otel.exporter.otlp.headers.authorization=Basic MTA5...</span></pre><figure class="md me mf mg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi of"><img src="../Images/5cceb8d6145d3065e92e2b944e8c05b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p3JA-lAYtsjMbyDtmmvyqA.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">在格拉法纳节奏中想象阿帕奇卡夫卡的痕迹</figcaption></figure><p id="d999" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如果您已经为日志准备好了弹性堆栈，那么您也可以导出跟踪。</p><pre class="md me mf mg gt nc mw nd ne aw nf bi"><span id="8c3e" class="lf lg it mw b gy ng nh l ni nj">spring.sleuth.otel.exporter.otlp.endpoint=https://xxx.azure.elastic-cloud.com<br/>spring.sleuth.otel.exporter.otlp.headers.authorization=Bearer XXX</span></pre><figure class="md me mf mg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi og"><img src="../Images/571219cddcff0e0272af5fd65df0f559.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dYw1r8hI3UedMC5RRKwxhA.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">在弹性APM中可视化阿帕奇卡夫卡上的痕迹</figcaption></figure><figure class="md me mf mg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oh"><img src="../Images/069e24e7e65b94f0939aafb45ed79f95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LdH0b161g2KV0aP90zwUaw.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">弹性APM中的服务地图</figcaption></figure><p id="99cf" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">弹性APM在服务地图页面上显示服务之间的依赖关系。具有随机名称的服务是数据库，不确定它为什么不这样识别它。</p><p id="7780" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这就是如何使用OpenTelemetry来避免供应商锁定！</p><p id="c046" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">就个人而言，我喜欢对蜂巢的解释，因为它允许按照您的意愿查询和聚集span属性。我很想在实际生产中尝试一下。</p><h1 id="ec7a" class="nm lg it bd lh nn no np lk nq nr ns ln nt nu nv lq nw nx ny lt nz oa ob lw oc bi translated">很高兴知道</h1><h2 id="a71d" class="lf lg it bd lh li lj dn lk ll lm dp ln kq lo lp lq ku lr ls lt ky lu lv lw lx bi translated">基于跟踪ID比率的采样</h2><p id="0bf0" class="pw-post-body-paragraph kf kg it kh b ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky mc la lb lc im bi translated">当我研究这个主题时，有一件事难倒了我，那就是并不是所有的跟踪都被导出到仪器后端。只是在执行了几次服务之后，我才导出了一个跟踪。这是相当恼人的，直到我偶然发现了一个与采样有关的重要配置。</p><p id="1c73" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">使用Spring Cloud Sleuth OTel时，默认情况下只有1/10的痕迹被导出！这是因为基于<a class="ae le" href="https://github.com/open-telemetry/opentelemetry-java/blob/main/sdk/trace/src/main/java/io/opentelemetry/sdk/trace/samplers/TraceIdRatioBasedSampler.java" rel="noopener ugc nofollow" target="_blank">跟踪ID比率的</a>采样正在使用，配置的默认值<code class="fe mt mu mv mw b">spring.sleuth.otel.config.trace-id-ratio-based</code>被设置为<code class="fe mt mu mv mw b">0.1</code>！虽然这适用于高流量的生产，以避免跟踪系统过载和影响应用程序的性能，但在测试时，您确实希望看到导出的每个跟踪。所以，现在就把配置设为<code class="fe mt mu mv mw b">1.0</code>，以后再感谢我吧！在这里<a class="ae le" href="https://github.com/open-telemetry/opentelemetry-java/blob/main/sdk/trace/src/main/java/io/opentelemetry/sdk/trace/samplers/TraceIdRatioBasedSampler.java" rel="noopener ugc nofollow" target="_blank">阅读更多信息</a>和<a class="ae le" href="https://spring-cloud-incubator.github.io/spring-cloud-sleuth-otel/docs/current/reference/html/appendix.html#common-application-properties" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><h2 id="dd80" class="lf lg it bd lh li lj dn lk ll lm dp ln kq lo lp lq ku lr ls lt ky lu lv lw lx bi translated">OTEL Java工具库的稳定发布</h2><p id="1ee7" class="pw-post-body-paragraph kf kg it kh b ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky mc la lb lc im bi translated">OTEL Java库没有被标记为稳定的。您可以在下面的链接跟踪剩余项目的进度。在我写这篇文章的时候，99个任务中的96个已经完成了，所以我们已经很接近了！</p><div class="oi oj gp gr ok ol"><a href="https://github.com/open-telemetry/opentelemetry-java-instrumentation/issues/2713" rel="noopener  ugc nofollow" target="_blank"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd iu gy z fp oq fr fs or fu fw is bi translated">将所有仪器转换为新的仪器API版本#2713 …</h2><div class="os l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">跟踪/讨论将新仪器转换为#2596中定义的仪器API的问题。请添加您的…</h3></div><div class="ot l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">github.com</p></div></div><div class="ou l"><div class="ov l ow ox oy ou oz jz ol"/></div></div></a></div><h2 id="d899" class="lf lg it bd lh li lj dn lk ll lm dp ln kq lo lp lq ku lr ls lt ky lu lv lw lx bi translated">跟踪没有参数值的JDBC查询</h2><p id="d9c4" class="pw-post-body-paragraph kf kg it kh b ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky mc la lb lc im bi translated">当使用<a class="ae le" href="https://github.com/p6spy/p6spy" rel="noopener ugc nofollow" target="_blank"> p6spy </a>跟踪JDBC查询时，默认情况下，查询将包括参数值。在大多数情况下，这可能不是一个好主意，因为数据可能是敏感的，您不希望它在您的数据库之外的任何地方。通过将配置<code class="fe mt mu mv mw b">spring.sleuth.jdbc.p6spy.tracing.include-parameter-values</code>设置为<code class="fe mt mu mv mw b">false</code>，可以用<code class="fe mt mu mv mw b">?</code>替换参数值。</p><p id="757e" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">所以你不会抓住<code class="fe mt mu mv mw b">insert into commit (commit_message, id) values (‘The universe is possible ‘, 4497884046194566862)</code>，而是会抓住<code class="fe mt mu mv mw b">insert into commit (commit_message, id) values (?, ?)</code>。</p><h2 id="8cd0" class="lf lg it bd lh li lj dn lk ll lm dp ln kq lo lp lq ku lr ls lt ky lu lv lw lx bi translated">限制JDBC追踪范围</h2><p id="617b" class="pw-post-body-paragraph kf kg it kh b ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky mc la lb lc im bi translated">弹簧侦探JDBC捕捉到三种类型的痕迹——<code class="fe mt mu mv mw b">query</code>、<code class="fe mt mu mv mw b">fetch</code>和<code class="fe mt mu mv mw b">connection</code>。<code class="fe mt mu mv mw b">query</code>轨迹很有趣，应该总是被捕获，但是我没有发现<code class="fe mt mu mv mw b">fetch</code>和<code class="fe mt mu mv mw b">connection</code>轨迹那么有趣。您可以通过配置<code class="fe mt mu mv mw b">spring.sleuth.jdbc.includes</code>选择要捕获的轨迹。因此，为了只捕获JDBC查询，将配置设置为<code class="fe mt mu mv mw b">query</code>。</p><h2 id="de02" class="lf lg it bd lh li lj dn lk ll lm dp ln kq lo lp lq ku lr ls lt ky lu lv lw lx bi translated">延伸《卡夫卡的消费者》中的痕迹</h2><p id="77aa" class="pw-post-body-paragraph kf kg it kh b ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky mc la lb lc im bi translated">目前，Kafka消费者跟踪有一个限制，即自动关闭范围，这意味着跟踪消息的处理将产生一个新的跟踪ID，而不是继续现有的跟踪。你可以在下面的链接找到更多关于它的细节和修复。这里有一个<a class="ae le" href="https://github.com/xsreality/spring-boot-tracing-demo/blob/main/otel-kafka/kafkaservice2/src/main/java/com/example/service2/TracingConsumer.java#L31" rel="noopener ugc nofollow" target="_blank">工作实例</a>。</p><div class="oi oj gp gr ok ol"><a href="https://github.com/spring-cloud-incubator/spring-cloud-sleuth-otel/issues/65#issuecomment-933256945" rel="noopener  ugc nofollow" target="_blank"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd iu gy z fp oq fr fs or fu fw is bi translated">traceId没有在kafka第65期spring-cloud-incubator/spring-cloud-sleuth-otel上传播</h2><div class="os l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="ot l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">github.com</p></div></div><div class="ou l"><div class="pa l ow ox oy ou oz jz ol"/></div></div></a></div><h1 id="0dcb" class="nm lg it bd lh nn no np lk nq nr ns ln nt nu nv lq nw nx ny lt nz oa ob lw oc bi translated">结论</h1><p id="9e28" class="pw-post-body-paragraph kf kg it kh b ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky mc la lb lc im bi translated">如您所见，Spring Cloud Sleuth和OpenTelemetry是一个强大的组合，可以利用您现有的Spring Boot应用程序，为您提供超越日志和指标的洞察力。如果您还没有探索分布式跟踪，现在是时候这样做了。你的备用泳池会感谢你的！</p><h1 id="36eb" class="nm lg it bd lh nn no np lk nq nr ns ln nt nu nv lq nw nx ny lt nz oa ob lw oc bi translated">资源</h1><ol class=""><li id="1c51" class="mk ml it kh b ki ly km lz kq pb ku pc ky pd lc mp mq mr ms bi translated">此处显示的所有示例均可在<a class="ae le" href="https://github.com/xsreality/spring-boot-tracing-demo" rel="noopener ugc nofollow" target="_blank">https://github.com/xsreality/spring-boot-tracing-demo</a>获得</li><li id="b83b" class="mk ml it kh b ki mx km my kq mz ku na ky nb lc mp mq mr ms bi translated"><a class="ae le" href="https://spring-cloud-incubator.github.io/spring-cloud-sleuth-otel/docs/current/reference/html/index.html" rel="noopener ugc nofollow" target="_blank">春云侦探OTel文档</a></li><li id="e0d8" class="mk ml it kh b ki mx km my kq mz ku na ky nb lc mp mq mr ms bi translated">跟踪OTEL Java Instrumentation工作在<a class="ae le" href="https://github.com/open-telemetry/opentelemetry-java-instrumentation/issues/2713" rel="noopener ugc nofollow" target="_blank">https://github . com/open-telemetry/open telemetry-Java-Instrumentation/issues/2713</a></li><li id="7f01" class="mk ml it kh b ki mx km my kq mz ku na ky nb lc mp mq mr ms bi translated"><a class="ae le" href="https://docs.spring.io/spring-cloud-sleuth/docs/current-SNAPSHOT/reference/html/integrations.html" rel="noopener ugc nofollow" target="_blank">在<strong class="kh iu">即将发布的Spring Cloud 2021.0中支持Spring Cloud Sleuth </strong></a>的集成。* </li></ol></div></div>    
</body>
</html>