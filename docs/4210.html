<html>
<head>
<title>Build a Single Page Web app using the DOM and JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用DOM和JavaScript构建单页面Web应用程序</h1>
<blockquote>原文：<a href="https://itnext.io/build-a-single-page-web-app-javascript-and-the-dom-90c99b08f8a9?source=collection_archive---------0-----------------------#2020-05-17">https://itnext.io/build-a-single-page-web-app-javascript-and-the-dom-90c99b08f8a9?source=collection_archive---------0-----------------------#2020-05-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="e519" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这里，您将使用最少的HTML创建一个动态web应用程序，而不是使用文档对象模型(DOM)和JavaScript</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/63ef509a36cbed24af4a38c96ff89ba2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*saGKCIH6gX-iW3bXQve-Tg.jpeg"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">单页应用程序没有你想象的那么复杂。恰恰相反。</figcaption></figure><p id="2955" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为什么？为什么我不能只写HTML，CSS，把它们链接在一起，我就有我的网站了？！是的，是的，看起来我把事情做得比需要的更复杂，但是单页应用程序的效率可以在开发动态web应用程序时节省时间，尤其是在进行更改时。</p><p id="8f6b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">解决这个问题有很多角度，最明显的是从浏览器的角度(例如chrome、Firefox……)。如果你有一个动态的web应用程序，它有很多页面，可能在某个地方有重复的代码(比如导航栏、页脚等等)。当您浏览这些页面时，浏览器每次都会刷新页面，重新加载上一页已经加载的内容。这只是浏览器的额外工作，会导致糟糕的用户体验；页面重新加载所浪费的几秒钟可能会促成或破坏对客户的销售。</p><p id="88fb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是单页应用程序派上用场的地方。如果您只需要根据用户的操作用新信息更新站点的一部分，那么您可以不重新加载页面，而只需获取数据并将其添加到页面上。我们开始吧。</p><p id="db0b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为你的主页创建一个模板，将首先加载的模板，我们将只在这一个基础上构建。就叫它index.html吧</p><pre class="km kn ko kp gt lb lc ld le aw lf bi"><span id="4f82" class="lg lh iq lc b gy li lj l lk ll">&lt;-- in index.html --&gt;<br/>&lt;html&gt;<br/>  &lt;head&gt;<br/>    &lt;meta charset="utf-8"&gt;<br/>    &lt;title&gt;Navigation Example&lt;/title&gt;<br/>  &lt;/head&gt;<br/>  &lt;body&gt;<br/>    &lt;a href=""&gt;Home&lt;/a&gt;<br/>    &lt;a href=""&gt;About&lt;/a&gt;<br/>    &lt;a href=""&gt;Contact&lt;/a&gt;<br/><br/>  &lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="e582" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">假设你已经知道HTML，你会知道' a '标签是链接。如果我们把URL放在href属性中，这些通常会把你引导到网站的另一个页面。</p><p id="63b4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是由于我们只处理单页应用程序，我们不希望页面重载。我们可以在URL中添加一个片段标识符，它将被添加到查询字符串的末尾，而不需要重新加载页面。让我们执行以下操作:</p><pre class="km kn ko kp gt lb lc ld le aw lf bi"><span id="ab62" class="lg lh iq lc b gy li lj l lk ll">&lt;-- in index.html --&gt;<br/>&lt;html&gt;<br/>  &lt;head&gt;<br/>    &lt;meta charset="utf-8"&gt;<br/>    &lt;title&gt;Navigation Example&lt;/title&gt;<br/>  &lt;/head&gt;<br/>  &lt;body&gt;<br/>    &lt;a href="#home"&gt;Home&lt;/a&gt;<br/>    &lt;a href="#about"&gt;About&lt;/a&gt;<br/>    &lt;a href="#contact"&gt;Contact&lt;/a&gt;<br/><br/>  &lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="b2d8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">片段标识符(#home、#about等)仅用于标识文档的一部分，如锚。启动index.html并点击链接。您的url中的URL将会改变，但页面不会重新加载。</p><p id="6d5e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在是JavaScript。我们可以使用事件监听器监听这些变化，当它们发生时，我们可以相应地修改页面。</p><p id="a6a8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">创建一个名为main.js的新文件，并使用脚本标签将index.html链接到该文件。</p><pre class="km kn ko kp gt lb lc ld le aw lf bi"><span id="2ad2" class="lg lh iq lc b gy li lj l lk ll">// in main.js<br/><br/>console.log(location.hash)</span></pre><p id="a145" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">console.log将把括号内的值打印到控制台。要查看控制台，请在您的浏览器页面上单击右键，然后单击“检查元素”，尽管它可能因您的浏览器而异。众所周知，Chrome开发工具是开发者的最爱。</p><p id="efe4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">location.hash是我们之前讨论过的片段标识符。如果我们在查询字符串(url)的末尾添加一个散列，并按enter键，控制台将打印出片段标识符。酷，但这没有帮助。让我们尝试以下方法:</p><pre class="km kn ko kp gt lb lc ld le aw lf bi"><span id="257d" class="lg lh iq lc b gy li lj l lk ll">// This will listen for the fragment identifier change<br/>window.addEventListener("hashchange", function() {<br/>  console.log(location.hash);<br/>});</span></pre><p id="374b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我们有了一个事件监听器，正如其名称所表明的那样——它是一个等待事件的函数！在事件侦听器中，我们等待一个“hashchange”，这意味着每当URL中的片段标识符发生变化时，这个函数就会被激活。</p><p id="3ccf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果单击home链接，事件监听器将被激活，因为url现在有了一个不同的片段标识符。使用location.hash获取该值，并将其输出到控制台。尝试一下，看看每次点击链接时，每个片段标识符是如何打印到控制台上的。</p><p id="e7de" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在console.log有点无聊，但对于尝试一些东西来说总是好的——但是让我们实际上把它输出到页面上让每个人都看到。首先，让我们回到index.html，为未来的文本创建一个占位符。</p><pre class="km kn ko kp gt lb lc ld le aw lf bi"><span id="eabb" class="lg lh iq lc b gy li lj l lk ll">&lt;-- in index.html --&gt;<br/><br/>&lt;html&gt;<br/>  &lt;head&gt;<br/>    &lt;meta charset="utf-8"&gt;<br/>    &lt;title&gt;Navigation Example&lt;/title&gt;<br/>  &lt;/head&gt;<br/>  &lt;body&gt;<br/>    &lt;a href="#home"&gt;Home&lt;/a&gt;<br/>    &lt;a href="#about"&gt;About&lt;/a&gt;<br/>    &lt;a href="#contact"&gt;Contact&lt;/a&gt;<br/><br/>    &lt;div id="app"&gt;&lt;/div&gt;<br/>    &lt;script src="main.js"&gt;&lt;/script&gt;<br/>  &lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="e2ae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我添加了一个id为app的div元素。这是空白的，稍后我们会把东西放进去。把它想象成一个空盒子，它现在是空的，但是你可以随时把它装起来，或者把它拆开，装上你喜欢的任何东西。让我们用JS打包一些文本</p><pre class="km kn ko kp gt lb lc ld le aw lf bi"><span id="6c8a" class="lg lh iq lc b gy li lj l lk ll">// in main.js<br/><br/>window.addEventListener("hashchange", function (){<br/>  var contentDiv = document.getElementById("app");<br/>  contentDiv.innerHTML = location.hash;<br/>});</span></pre><p id="8eee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">复制代码并进入浏览器。当您单击一个链接时，页面应该在文档上显示片段标识符，而不需要重新加载页面。简单。</p><p id="df1c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们现在唯一的问题是，当我们进入像yourdocument.html#about这样的页面时，事件监听器将无法工作，因为文档已经加载。发现问题？即使有一个片段标识符，我们也会有一个空白页。我们希望页面基于片段标识符加载内容，即使不使用事件监听器。看看下面。</p><pre class="km kn ko kp gt lb lc ld le aw lf bi"><span id="fe63" class="lg lh iq lc b gy li lj l lk ll">// in main.js<br/>function loadContent(){<br/>  var contentDiv = document.getElementById("app");<br/>  contentDiv.innerHTML = location.hash;<br/>}<br/><br/>window.addEventListener("hashchange", function (){<br/>  loadContent();<br/>});<br/><br/>loadContent();</span></pre><p id="0f21" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好多了。我们有一个名为loadContent的新函数，它完成了我们在事件监听器中所做的工作。这很好，因为现在我们可以在文档加载时通过声明函数名loadContent()来调用它。我们也可以在事件监听器中调用这个函数，以避免重复代码。</p><p id="494e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">看一下代码，看看是否可以修改得更多，特别是在事件监听器中。看一看:</p><pre class="km kn ko kp gt lb lc ld le aw lf bi"><span id="60af" class="lg lh iq lc b gy li lj l lk ll">// in main.js<br/>function loadContent(){<br/>  var contentDiv = document.getElementById("app");<br/>  contentDiv.innerHTML = location.hash;<br/>}<br/><br/><br/>window.addEventListener("hashchange", loadContent);<br/><br/>loadContent();</span></pre><p id="7492" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们正在取得进展，但我们仍然有一个小问题，没有片段标识符的第一页是空白的，但它应该是home，对吗？请执行以下操作:</p><pre class="km kn ko kp gt lb lc ld le aw lf bi"><span id="eb64" class="lg lh iq lc b gy li lj l lk ll">// in main.js<br/>function loadContent(){<br/>  var contentDiv = document.getElementById("app");<br/>  contentDiv.innerHTML = location.hash;<br/>}<br/><br/>if(!location.hash) {<br/>  location.hash = "#home";<br/>}<br/><br/>loadContent();<br/><br/>window.addEventListener("hashchange", loadContent)</span></pre><p id="d756" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们现在有一个if语句。让我们孤立地来看:</p><pre class="km kn ko kp gt lb lc ld le aw lf bi"><span id="cd2e" class="lg lh iq lc b gy li lj l lk ll">if(!location.hash){<br/>    location.hash = "#home";<br/>}</span></pre><p id="3bc2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这基本上是说‘如果没有位置散列，就把位置散列设为# home。’的！在location.hash的前面对表达式求反。</p><p id="7822" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还有另一件事要解决:我们不想打印出带有页面的散列符号。我们用一个叫substr的JS方法把它拿出来。</p><pre class="km kn ko kp gt lb lc ld le aw lf bi"><span id="40e2" class="lg lh iq lc b gy li lj l lk ll">// in main.js<br/>function loadContent(){<br/>  var contentDiv = document.getElementById("app"),<br/><br/>      // This gets rid of the first character of the string<br/>      fragmentId = location.hash.substr(1);<br/><br/>  contentDiv.innerHTML = fragmentId;<br/>}<br/><br/>if(!location.hash) {<br/>  location.hash = "#home";<br/>}<br/><br/><br/>loadContent();<br/><br/>window.addEventListener("hashchange", loadContent)</span></pre><p id="84da" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">substr方法删除字符串的第一个字母，并返回其余的字母。这导致从片段标识符中删除#号。</p><p id="8ece" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">打印出片段标识符很好，但是有点无聊，没有令人兴奋的内容来真正展示你的网站。</p><pre class="km kn ko kp gt lb lc ld le aw lf bi"><span id="7364" class="lg lh iq lc b gy li lj l lk ll">function getContent(fragmentId){<br/><br/>// lets do some custom content for each page of your website<br/>  var pages = {<br/>    home: "This is the Home page. Welcome to my site.",<br/>    about: "This page will describe what my site is about",<br/>    contact: "Contact me on this page if you have any questions"<br/>  };<br/><br/>// look up what fragment you are searching for in the object<br/>  return pages[fragmentId];<br/>}<br/><br/>function loadContent(){<br/><br/>  var contentDiv = document.getElementById("app"),<br/>      fragmentId = location.hash.substr(1);<br/><br/>  contentDiv.innerHTML = getContent(fragmentId);<br/>}<br/><br/>if(!location.hash) {<br/>  location.hash = "#home";<br/>}<br/><br/>loadContent();<br/><br/>window.addEventListener("hashchange", loadContent)</span></pre><p id="b1dc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里我们有一个名为getContent的新函数。它需要一个片段的参数。在这个函数内部，我们有一个JS对象，它就像一个字典。它由键值对填充，比如一个单词和一个描述。在我们的例子中，是页面名称和与之相关的内容。我已将对象命名为页面。</p><p id="5738" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在函数的底部，我们通过向partials对象传递fragmentId的值来搜索它(这是我们所在的页面)。然后浏览器遍历partials对象并返回匹配的值。我们离动态网站又近了一步。</p><p id="7fd5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于本教程的最后一步，让我们更改getContent函数，使其包含一个回调函数，从而使程序中的函数异步运行。如果你现在不明白，不要担心。简而言之，你想让你的程序尽可能高效。我们更喜欢异步(同时)运行函数，尽量减少浪费的时间。这是一个很难理解的复杂概念——所以如果你不能马上理解，不要担心，如果你想了解更多，做一些研究。</p><pre class="km kn ko kp gt lb lc ld le aw lf bi"><span id="afc3" class="lg lh iq lc b gy li lj l lk ll">function getContent(fragmentId, callback){<br/><br/>  var pages = {<br/>    home: "This is the Home page. Welcome to my site.",<br/>    about: "This page will describe what my site is about",<br/>    contact: "Contact me on this page if you have any questions"<br/>  };<br/><br/>  callback(pages[fragmentId]);<br/>}<br/><br/><br/><br/>function loadContent(){<br/><br/>  var contentDiv = document.getElementById("app"),<br/>      fragmentId = location.hash.substr(1);<br/><br/>  getContent(fragmentId, function (content) {<br/>    contentDiv.innerHTML = content;<br/>  });<br/><br/>}<br/><br/>if(!location.hash) {<br/>  location.hash = "#home";<br/>}<br/><br/>loadContent();<br/><br/>window.addEventListener("hashchange", loadContent)</span></pre><p id="b9bb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">回调在getContent方法中。当调用getContent时，该函数继续完成它的工作，同时获取内容放入HTML页面。围绕这个概念，看看你能构建多大的单页应用程序。</p></div></div>    
</body>
</html>