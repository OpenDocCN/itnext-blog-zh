<html>
<head>
<title>Minimally Privileged Containers in OpenShift — An Example using a Logging Agent</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">OpenShift中的最低特权容器—使用日志代理的示例</h1>
<blockquote>原文：<a href="https://itnext.io/minimally-privileged-containers-in-openshift-an-example-using-a-logging-agent-872e21fdce86?source=collection_archive---------3-----------------------#2021-09-28">https://itnext.io/minimally-privileged-containers-in-openshift-an-example-using-a-logging-agent-872e21fdce86?source=collection_archive---------3-----------------------#2021-09-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="b01c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我和一个同事最近有一个在OpenShift集群上运行日志收集代理的任务，一个关键要求是以尽可能小的访问权限运行代理。具体来说，我们需要运行这个代理:</p><ul class=""><li id="d0db" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated">在非特权容器中(即没有在容器的<code class="fe ku kv kw kx b">securityContext</code>规范中设置<code class="fe ku kv kw kx b">privileged: true</code>)</li><li id="a774" class="kl km iq jp b jq ky ju kz jy la kc lb kg lc kk kq kr ks kt bi translated">作为非超级用户(作为UID不是0的用户)</li></ul><p id="d7ab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是尽管以最小特权运行，这个代理仍然必须能够收集来自<code class="fe ku kv kw kx b">hostMount</code>的日志——意思是来自底层工作节点上的文件系统。</p><p id="7f28" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这不是Kubernetes世界中的新问题或用例。例如，LogDNA提供了<a class="ae ld" href="https://github.com/logdna/logdna-agent-v2/blob/master/docs/OPENSHIFT.md#run-as-non-root" rel="noopener ugc nofollow" target="_blank">指令</a>，用于在“常规”Kubernetes和Openshift… <em class="le">上以非根用户身份运行他们的代理，但是</em>他们仍然指定他们的代理必须在特权容器中运行。那对我们来说不是一个可行的选择。</p><h1 id="b0c7" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">谁是负责人？</h1><p id="70d1" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">这篇文章的副标题可能是“两个…不，三个…不，四个…访问控制机制的故事”Kubernetes的用户可能已经非常熟悉常规的Unix文件系统访问控制机制。更高级的用户/开发人员可能也熟悉通过系统<a class="ae ld" href="https://man7.org/linux/man-pages/man7/capabilities.7.html" rel="noopener ugc nofollow" target="_blank">功能</a>的自主访问控制的Linux实现，它基本上将root的超级权限细分为更小、更窄的定制包，可以为需要提升访问权限的进程启用。</p><p id="7c44" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当然，Kubernetes本身引入了容器的<a class="ae ld" href="https://kubernetes.io/docs/tasks/configure-pod-container/security-context/" rel="noopener ugc nofollow" target="_blank"> securityContext </a>和<a class="ae ld" href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/" rel="noopener ugc nofollow" target="_blank"> serviceAccount </a>等构造。</p><p id="b0f3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，更复杂的是OpenShift。OpenShift要求worker节点启用<a class="ae ld" href="https://www.redhat.com/en/topics/linux/what-is-selinux" rel="noopener ugc nofollow" target="_blank"> SELinux </a>(安全增强的Linux)，这在现有DAC机制之上强加了一个强制访问控制(MAC)层(*nix权限+系统功能)。</p><p id="cc6a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后是OpenShift的<code class="fe ku kv kw kx b">SecurityContextConstraints (SCC)</code>，它是一个Kubernetes资源，定义了pod准入控制器在启动pod时使用的约束。pod中每个容器的<code class="fe ku kv kw kx b">securityContext</code>与SCC进行比较——违反将导致pod不被允许启动。此外，SCC实际上可以强制对容器进行某些更改，比如强制添加或删除特定的Linux系统功能。</p><p id="3690" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于试图确定如何最好地确保他/她的应用程序以所需的访问权限运行的应用程序开发人员来说，所有这些加起来可能是一幅相当混乱的画面。</p><h1 id="4447" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">将碎片拼在一起</h1><p id="c6d9" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">让多种不同的机制协同工作有点像撬锁——你必须让所有的制动栓和内部零件对齐，才能让锁打开，但如果哪怕只有一个小零件错位，整个机制都不会正常工作。</p><figure class="mj mk ml mm gt mn gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/f86838346d0251288c9936b50dfd4291.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/format:webp/1*Fd1YDyp_WWpIYHAkIGt0vw.png"/></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">想象一下，打开一扇由Kubernetes、Linux和SELinux保护的门…</figcaption></figure><p id="1afa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在接下来的章节中，我们将逐一介绍这两个用例，重点是如何确保容器有足够的访问权限，而不需要过分宽松的配置。</p><p id="64cf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后一点很关键——通过以root用户身份运行某个进程或积极开放目录权限来“让事情运转起来”是很诱人的。但是我们希望<em class="le">以应用程序工作所需的绝对最低访问级别运行我们的应用程序</em>。在一般实践中，这是一个很好的规则，我们都应该避免只是按下永远诱人的简单按钮的诱惑。毕竟，懒惰是恶意行为者成功攻击的基础。</p><h1 id="138d" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">以非root用户身份运行容器</h1><p id="be17" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">第一个挑战是使我们的应用程序——在我们的例子中是一个日志收集代理——能够在不以root用户身份运行的情况下访问和读取日志文件。这包括两个部分:作为非root UID(除0以外的UID)运行，并启用所需的访问级别。</p><p id="9466" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在标准的Kubernetes环境中，将容器作为非根UID运行非常简单。您可以简单地在容器的<code class="fe ku kv kw kx b">securityContext</code>中指定UID:</p><pre class="mj mk ml mm gt mu kx mv mw aw mx bi"><span id="0a7f" class="my lg iq kx b gy mz na l nb nc">securityContext:<br/>  runAsUser: 10000<br/>  runAsGroup: 10000</span></pre><p id="463e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这里，我已经指定了我的容器将在UID为<code class="fe ku kv kw kx b">10000</code>和GID为相同值的情况下运行。不要求这些条目映射到底层操作系统已知的用户(例如，不要求相应的条目存在于<code class="fe ku kv kw kx b">/etc/passwd</code>或<code class="fe ku kv kw kx b">/etc/group</code>)。</p><p id="8a4e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是这个userid能够读取日志文件(或者访问应用程序需要访问的任何其他主机文件)吗？例如，在我们的worker主机上，logs目录是用权限<code class="fe ku kv kw kx b">770</code>设置的:</p><pre class="mj mk ml mm gt mu kx mv mw aw mx bi"><span id="5bfc" class="my lg iq kx b gy mz na l nb nc">drwxr-x---. 16 root root 4096 Sep  9 14:09 /var/log</span></pre><p id="9551" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么如何让一个容器化的应用程序访问这个目录的文件或者子目录呢？一个选项是<code class="fe ku kv kw kx b">initContainer</code>(在常规应用程序容器之前，每个pod实例运行一次)，以root用户身份运行，更改该目录的权限。但这基本上绕过了我们试图遵守的限制。当然，<code class="fe ku kv kw kx b">initContainer</code>只运行一次，不会成为攻击目标(假设使用<code class="fe ku kv kw kx b">initContainer</code>运行某种一次性设置代码的正常做法，在我们的例子中是一个基本的shell脚本)，但它仍然…不一致，相当难看。而如果<code class="fe ku kv kw kx b">/var/log</code>下有子目录呢？在这种情况下，我基本上是在劫持构建和配置我们的工人映像的团队的决策，这并不是我真正想要做的。</p><p id="4dac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">幸运的是，Linux提供了系统功能，我在上面提到过。我不会在这里讨论所有的细节，但是对于可能不熟悉它们的应用程序开发人员来说，花时间阅读它们并理解基础知识是值得的—从这里的手册页<a class="ae ld" href="https://man7.org/linux/man-pages/man7/capabilities.7.html" rel="noopener ugc nofollow" target="_blank">开始</a>。这样做的目的是将root的权限细分为内聚的、粒度更细的包，每个包都可以针对给定的应用程序或工作负载单独启用/禁用。在我们的例子中，我们想要的功能是<code class="fe ku kv kw kx b">CAP_DAC_READ_SEARCH</code>——这个功能在启用时，允许进程在试图读取文件或列出/访问目录时忽略权限。(在您应该说“嘿，现在您的代理可以读取任何内容了”…在我们稍后讨论SELinux之前，请保持这种想法。)</p><p id="a81e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为我们的用例启用功能的过程有两个部分:第一，我们必须将该功能标记为允许二进制可执行文件使用，第二，我们必须在运行二进制文件时明确请求该功能。首先，我们将这个命令添加到我们的<code class="fe ku kv kw kx b">Dockerfile</code>:</p><pre class="mj mk ml mm gt mu kx mv mw aw mx bi"><span id="46bd" class="my lg iq kx b gy mz na l nb nc">RUN setcap "cap_dac_read_search+eip" /usr/local/bin/logging-agent</span></pre><p id="09d8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="le">注意:解释</em> <code class="fe ku kv kw kx b"><em class="le">+eip</em></code> <em class="le">后缀的重要性超出了本文的范围——这个后缀与用于计算任何给定流程允许/启用什么功能的算法有关，这在我前面提到的手册页中有描述，但是您可以在这篇博文</em>  <em class="le">中找到一个非常好的、更实用的解释。</em></p><p id="aef6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我们运行我们的容器时，我们通过更新我们的<code class="fe ku kv kw kx b">securityContext</code>请求将功能添加到流程中，如下所示:</p><pre class="mj mk ml mm gt mu kx mv mw aw mx bi"><span id="cdcd" class="my lg iq kx b gy mz na l nb nc">securityContext:<br/>  runAsUser: 10000<br/>  runAsGroup: 10000<br/>  <strong class="kx ir">capabilities:<br/>    add:<br/>    - DAC_READ_SEARCH</strong></span></pre><h2 id="c800" class="my lg iq bd lh nd ne dn ll nf ng dp lp jy nh ni lt kc nj nk lx kg nl nm mb nn bi translated">那么，我们取得了什么成就？</h2><p id="de07" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">至此，我们已经使我们的容器能够作为非根用户运行，并且仍然可以访问它需要在Kubernetes worker主机上读取的任何日志文件和/或目录。但是我们还有两个问题没有解决。首先，我们违反了一个关键原则，特别是只使用所需的最低访问权限的原则。幸运的是，SELinux为我们提供了一个解决方案。不幸的是，这也使事情变得复杂。另一个是，不幸的是，这在OpenShift上实际上是行不通的——open shift添加了额外的限制，这些限制有助于(通过限制工作负载在没有额外配置的情况下可以做什么)和阻碍(出于完全相同的原因)。所以现在我们必须转向这些额外的层。</p><h1 id="146b" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">OpenShift和SecurityContextConstraints</h1><p id="82f2" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">OpenShift引入了一种特殊的资源，称为<code class="fe ku kv kw kx b">SecurityContextConstraints</code>(以下简称SCC)，正是这样——对容器的<code class="fe ku kv kw kx b">securityContext</code>所允许的一组约束。它实际上比<code class="fe ku kv kw kx b">securityContext</code>的范围更广SCC可以限制允许pod访问的卷的类型、pod可以使用的主机功能，甚至可以限制pod的容器可以使用的Linux系统功能。</p><p id="54b4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">考虑SCC资源的一种方式是将其与Linux系统功能相比较——就像SYSCAP机制被用来更好地控制超级用户权限一样，SCC对属于<code class="fe ku kv kw kx b">privileged</code>容器的大部分内容提供了更好的控制。SCC建立在<a class="ae ld" href="https://kubernetes.io/docs/concepts/security/pod-security-standards/" rel="noopener ugc nofollow" target="_blank"> Kubernetes安全策略</a>的基础上，pod准入控制器通常使用这些策略来防止pod请求(和接收)过多的特权。一些关于SCC的好读物通常可以在OpenShift的博客文章和文档中找到。实际上想要使用他们自己的SCC的开发人员/管理员应该通读<a class="ae ld" href="https://docs.openshift.com/container-platform/4.7/rest_api/security_apis/securitycontextconstraints-security-openshift-io-v1.html" rel="noopener ugc nofollow" target="_blank"> API文档</a>，并且可能查看<code class="fe ku kv kw kx b">oc explain securitycontextconstraints</code>的输出。</p><h2 id="9dd3" class="my lg iq bd lh nd ne dn ll nf ng dp lp jy nh ni lt kc nj nk lx kg nl nm mb nn bi translated">配置我们自己的安全上下文约束</h2><p id="93d1" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">到现在为止，我将把它作为一条信条，我们都同意特权容器(任何在它的<code class="fe ku kv kw kx b">securityContext</code>中带有<code class="fe ku kv kw kx b">privileged: true</code>的容器)应该不惜任何代价避免。特权模式使容器能够利用(在某些情况下，操纵)几乎任何底层系统功能—网络、存储等。—这给系统安全性和完整性带来了巨大的风险。</p><p id="085e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是我们确实需要比常规应用程序工作负载更多的访问——我们需要能够从工作主机的文件系统中读取日志文件——所以诀窍是如何在不将我们的容器置于<code class="fe ku kv kw kx b">privileged</code>模式的情况下实现这一点？在我们的例子中，我们需要配置<code class="fe ku kv kw kx b">SecurityContextConstraints</code>来给我们这个访问权限，但仅此而已。</p><p id="e406" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">OpenShift目前附带九(9)种预配置的SCC类型。您不应该修改它们，因为它们中的许多已经被OpenShift系统pods使用。相反，找到看起来最接近你想要的那个，复制一份，然后修改它:</p><pre class="mj mk ml mm gt mu kx mv mw aw mx bi"><span id="a0fa" class="my lg iq kx b gy mz na l nb nc">$ oc get scc hostmount-anyuid -o yaml &gt; myscc.yaml</span></pre><p id="f6d5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这里，我们选择了<code class="fe ku kv kw kx b">hostmount-anyuid</code> SCC作为最有可能的匹配——它允许装载主机卷，以及作为任何用户id运行。看起来很合适，对吧？嗯……不完全是。这个SCC既过于宽松(它允许容器请求我们不希望我们的代理拥有的系统功能)，又不够宽松(它不允许我们迫切需要的功能)。该SCC包括以下几行:</p><pre class="mj mk ml mm gt mu kx mv mw aw mx bi"><span id="c7b7" class="my lg iq kx b gy mz na l nb nc">allowedCapabilities: null<br/>requiredDropCapabilities:<br/>- MKNOD</span></pre><p id="2820" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第一行表示应用此SCC的任何pod都只能使用默认情况下允许的那些系统功能。您可以在<a class="ae ld" href="https://docs.docker.com/engine/reference/run/#runtime-privilege-and-linux-capabilities" rel="noopener ugc nofollow" target="_blank"> Docker文档</a>中找到这些功能的列表，重要的是，该列表<em class="le">不</em>包括<code class="fe ku kv kw kx b">DAC_READ_SEARCH</code>。所以首先，我们需要将它添加到列表<code class="fe ku kv kw kx b">allowedCapabilities</code>(这是一个数组变量):</p><pre class="mj mk ml mm gt mu kx mv mw aw mx bi"><span id="24bd" class="my lg iq kx b gy mz na l nb nc">allowedCapabilities:<br/>- DAC_READ_SEARCH</span></pre><p id="e70c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，注意在<code class="fe ku kv kw kx b">requiredDropCapabilities</code>下面列出的唯一功能是<code class="fe ku kv kw kx b">MKNOD</code>——这里列出的功能会自动从pod/container中删除，即使它们在默认情况下是允许的，即使容器请求它们。因此，您可以使用这个变量来指定由特定SCC管理的pod应该<em class="le">永远不具备</em>的能力。您想要禁止的内容可能因使用情形而异，但是在我们的情况下，我们决定将其修改为:</p><pre class="mj mk ml mm gt mu kx mv mw aw mx bi"><span id="f7b6" class="my lg iq kx b gy mz na l nb nc">requiredDropCapabilities:<br/>- MKNOD<br/><strong class="kx ir">- FSETID<br/>- KILL<br/>- NET_BIND_SERVICE<br/>- NET_RAW</strong></span></pre><p id="c483" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一些与网络相关的功能实际上是多余的，因为我们的SCC已经在其他地方指定:</p><pre class="mj mk ml mm gt mu kx mv mw aw mx bi"><span id="4047" class="my lg iq kx b gy mz na l nb nc">allowHostIPC: false<br/>allowHostNetwork: false<br/>allowHostPorts: false</span></pre><p id="ee10" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但格外小心也无妨。主要的收获是，即使是在SCC中，也有可能指定矛盾的设置，所以在设计时必须小心。我们现在需要添加的最后一件事是一个设置，以确保我们的pod可以实际使用这个SCC。</p><h2 id="5056" class="my lg iq bd lh nd ne dn ll nf ng dp lp jy nh ni lt kc nj nk lx kg nl nm mb nn bi translated">为pod选择SCC</h2><p id="534c" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">OpenShift决定哪个SCC与pod一起使用的方式看起来有点复杂，但是对于我们的目的来说，它并没有那么复杂。每个SCC都被授权给一个或多个用户和/或<code class="fe ku kv kw kx b">serviceaccounts</code>。当您通过联系API(例如使用<code class="fe ku kv kw kx b">kubectl</code>)来部署pod时，您是以特定用户的身份这样做的。除非您在pod规范中指定了<code class="fe ku kv kw kx b">serviceaccount</code>，否则它将在有问题的名称空间的默认<code class="fe ku kv kw kx b">serviceaccount</code>下运行。用于请求pod和<code class="fe ku kv kw kx b">serviceaccount</code>的用户将分别被授权使用一些SCC集合(可以是空集，在这种情况下，pod将被完全禁止)。准入控制器将构建这两个集合的并集，然后确定是否至少有一个来自该并集的SCC允许pod运行。如果有一个以上的SCC，则控制器将按优先级(一个值，默认为<code class="fe ku kv kw kx b">null</code>(有效0)，可在SCC定义中指定，较高的值优先)对有效SCC进行排序。当不止一个SCC具有相同的优先级时，它们将从最严格到最不严格排序，然后根据需要按名称排序。我们大多数人应该这样想:“使用最严格的SCC，它仍然允许pod中的所有容器运行。”</p><p id="d24c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="le">注意:使用</em> <code class="fe ku kv kw kx b"><em class="le">oc</em></code> <em class="le">部署pod时要小心——您通常以集群管理员的身份执行此操作，因此具有更高的权限——除其他外，它会自动导致准入控制器在候选列表中包含限制较少的SCC。确保使用您的CI链</em>所使用的用户来测试您的pod是否能够正确运行。</p><p id="2b10" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们在pod规范中指定了<code class="fe ku kv kw kx b">serviceaccount</code>，因此我们可以通过在SCC yaml的<code class="fe ku kv kw kx b">users</code>部分列出它来授权该帐户使用我们的SCC:</p><pre class="mj mk ml mm gt mu kx mv mw aw mx bi"><span id="6d7b" class="my lg iq kx b gy mz na l nb nc">users:<br/>- system:serviceaccount:logger-agent:agent</span></pre><p id="1f41" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这保证了当我们试图运行我们的pod时，准入控制器将至少找到这个SCC，从而允许我们的pod运行。</p><h1 id="f168" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">SELinux</h1><p id="d3f9" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">所以在我们的情况下，我们认为我们已经做了足够的工作来让我们的代理工作。我们已经为代理提供了所需的SYSCAP，以允许它遍历日志目录，并且我们已经指定了一个SCC，它将允许我们的pod以所需的访问级别运行，但仅此而已。</p><p id="0910" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">剧透提醒:没那么多。我们没有考虑到这样一个事实，即OpenShift需要启用SELinux，并且SELinux对进程与文件交互的能力施加了另一层限制。我们能够通过登录到worker节点并使用<code class="fe ku kv kw kx b">ausearch</code>查看主机审计日志，寻找<code class="fe ku kv kw kx b">AVC</code>消息(在我们的例子中，这表示当进程试图读取文件时访问被拒绝)来解决这个问题。</p><p id="50aa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">SELinux将进程分类为它所谓的<em class="le">域</em>，将文件/目录分类为<em class="le">类型</em>。域和类型的命名通常采用<code class="fe ku kv kw kx b">some_label_t</code>的形式——常量是后缀<code class="fe ku kv kw kx b">_t</code>(包括域)。您可以通过在worker主机上运行<code class="fe ku kv kw kx b">ps -Z</code>来查看进程的域:</p><pre class="mj mk ml mm gt mu kx mv mw aw mx bi"><span id="4f51" class="my lg iq kx b gy mz na l nb nc">sh# ps -Z -C crio<br/>LABEL                              PID TTY          TIME CMD<br/>system_u:system_r:container_runtime_t:s0 97341 ? 41-16:00:20 crio</span></pre><p id="37ba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe ku kv kw kx b">crio</code>进程是一个容器，因此默认情况下运行在一个域<code class="fe ku kv kw kx b">container_runtime_t</code>中。除非另外指定，否则任何容器都将使用该域运行。我们想要读取的文件呢——例如<code class="fe ku kv kw kx b">/var/log</code>目录？</p><pre class="mj mk ml mm gt mu kx mv mw aw mx bi"><span id="000b" class="my lg iq kx b gy mz na l nb nc">sh# ls -Z -d /var/log<br/>drwxr-xr-x. root root system_u:object_r:var_log_t:s0   /var/log</span></pre><p id="ee0d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们在这里可以看到,<code class="fe ku kv kw kx b">/var/log</code>目录有一个类型<code class="fe ku kv kw kx b">var_log_t</code>，事实上它下面的大多数文件和目录都是这样。对我们来说，最重要的文件是那些在<code class="fe ku kv kw kx b">/var/log/containers</code>下的文件——这些文件是实际日志文件的符号链接，它们本身在<code class="fe ku kv kw kx b">/var/log/pods/$PODNAME</code>下。因为Kubernetes以这种方式记录日志，单个代理可以在新文件出现在<code class="fe ku kv kw kx b">/var/log/containers</code>下时获取它们，而不必检测新的pod子目录。不幸的是，默认的SELinux安全策略不允许域<code class="fe ku kv kw kx b">container_runtime_t</code>下的进程访问主机文件系统上的任何东西(当然也不允许<code class="fe ku kv kw kx b">var_log_t</code>对象)。碰巧的是，SELinux提供了另一个名为<code class="fe ku kv kw kx b">container_logreader_t</code>的域。该域可以访问类型为<code class="fe ku kv kw kx b">container_log_t</code>的文件(类型为<code class="fe ku kv kw kx b">/var/log/pods/$PODNAME</code>下的实际日志文件)。为了强制pod容器在特定的域中运行，我们在SCC对象中指定它(来回的交互可能感觉很复杂):</p><pre class="mj mk ml mm gt mu kx mv mw aw mx bi"><span id="1c2d" class="my lg iq kx b gy mz na l nb nc">seLinuxContext:<br/>  type: MustRunAs<br/>  seLinuxOptions:<br/>    type: container_logreader_t</span></pre><p id="acd6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以我们用上面的内容更新了我们的SCC，并重新创建了我们的代理pod。它起作用了……算是吧。嗯，一点也不。我们所缺少的是，尽管这些文件属于<code class="fe ku kv kw kx b">container_logreader_t</code>域可以访问的类型，但是<em class="le">到这些文件的符号链接属于不同的类型，我们的域</em> <strong class="jp ir"> <em class="le">无法读取</em> </strong> <em class="le">。</em>事实证明，我们实际上必须更深入地了解SELinux访问控制机制，并配置一些自定义规则来实现这一点，我们最终做到了。关于配置SELinux授权规则的详细讨论超出了本文的范围(这足以保证有一篇自己的文章，我的同事正在写那篇文章——一旦他写好了，我会在这里链接到它)。</p><h2 id="4656" class="my lg iq bd lh nd ne dn ll nf ng dp lp jy nh ni lt kc nj nk lx kg nl nm mb nn bi translated">重叠机制</h2><p id="ca2b" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">您可能还记得，启用<code class="fe ku kv kw kx b">DAC_READ_SEARCH</code>系统功能允许进程在读取文件/目录时忽略文件权限。这似乎是一件坏事，对不对？这似乎允许一个进程在文件系统中漫游，不受约束，能够访问它想要的任何文件。但是，在我们的例子中，它允许我们避免修改文件权限和/或所有权，这是一件好事。但是……这是一个很大的权限。</p><p id="3769" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是SELinux出手相救的地方。在<code class="fe ku kv kw kx b">container_logreader_t</code>域下运行(使用我们对SELinux授权策略的更新)<em class="le">只有</em>允许我们访问<code class="fe ku kv kw kx b">var_log_t</code>和<code class="fe ku kv kw kx b">container_log_t</code>类型的对象(文件/目录)——而且这些只能在从<code class="fe ku kv kw kx b">/var/log</code>开始的树中找到。因此，SELinux和Linux系统功能的结合允许我们读取该目录下的文件，而不必担心和/或更改它们的权限/所有权。这就是我们想要的。它还防止我们的进程读取该目录之外的任何内容——这也是我们想要的。</p><h1 id="2d53" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">外卖食品</h1><p id="ff77" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">您应该从所有这些中得出的要点是，配置一个安全运行的pod，同时保持其功能是一个您需要整体处理的主题。花时间阅读文档，熟悉文档，然后花时间试验SCC，看看什么可行，什么不可行。如果您需要从底层主机访问文件，那么您也需要进入SELinux。但是总是花时间停下来问自己，“我真正想要完成的是什么？”OpenShift和SELinux为Kubernetes添加了一些非常强大的功能，可以帮助您实现更加健壮的安全状态。但是，如果您不花时间预先计划您需要做什么，这可能会非常复杂和令人沮丧，部署者可能会倾向于恢复坏习惯，如以root和/或特权模式运行容器，即使有更好的替代方案。</p></div></div>    
</body>
</html>