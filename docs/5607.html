<html>
<head>
<title>Graphing Xcode project dependencies — Introducing XCGrapher</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">绘制Xcode项目依赖关系XCGrapher简介</h1>
<blockquote>原文：<a href="https://itnext.io/graphing-xcode-project-dependencies-introducing-xcgrapher-cb99aa0a325e?source=collection_archive---------1-----------------------#2021-04-15">https://itnext.io/graphing-xcode-project-dependencies-introducing-xcgrapher-cb99aa0a325e?source=collection_archive---------1-----------------------#2021-04-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="48d9" class="pw-subtitle-paragraph jr ip iq bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">最近，我们一直在将我们的(许多)内部库从CocoaPods迁移到Swift包。为了全面了解我们的进展，我构建了一个新工具，随后学到了一些对我来说新的东西:在运行时动态加载Swift库！</h2></div><p id="0ca9" class="pw-post-body-paragraph kj kk iq kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">这是一篇有点长的文章，所以为了吊起你的胃口，这里列出了我们将要讨论的部分内容(有时非常详细) :</p><ul class=""><li id="9055" class="lf lg iq kl b km kn kp kq ks lh kw li la lj le lk ll lm ln bi translated">💡我为什么创建<code class="fe jn jo jp jq b">xcgrapher</code>以及它是如何工作的</li><li id="db6a" class="lf lg iq kl b km lo kp lp ks lq kw lr la ls le lk ll lm ln bi translated">👨‍💻如何写一个<code class="fe jn jo jp jq b">xcgrapher</code>插件</li><li id="074d" class="lf lg iq kl b km lo kp lp ks lq kw lr la ls le lk ll lm ln bi translated">👨‍🔧如何阻止Swift编译器篡改函数名</li><li id="0b56" class="lf lg iq kl b km lo kp lp ks lq kw lr la ls le lk ll lm ln bi translated">🧙‍♂️如何在运行时加载和执行外部动态库中的代码</li><li id="3ca1" class="lf lg iq kl b km lo kp lp ks lq kw lr la ls le lk ll lm ln bi translated">🍺如何通过自制软件分发Swift包</li><li id="8e55" class="lf lg iq kl b km lo kp lp ks lq kw lr la ls le lk ll lm ln bi translated">🕵️‍♂️如何看到和改变动态库路径嵌入在二进制</li></ul><p id="0bd1" class="pw-post-body-paragraph kj kk iq kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">搜索上面的表情符号跳转到一个章节！</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi lt"><img src="../Images/bf2962ffe02786dbb7fc739b52647e24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*LXyUr3o_7ynpy2qL"/></div></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">下面是xcgrapher可以为您提供的开箱即用功能</figcaption></figure><h1 id="ec59" class="mj mk iq bd ml mm mn mo mp mq mr ms mt ka mu kb mv kd mw ke mx kg my kh mz na bi translated">💡模块迁移混乱</h1><p id="c753" class="pw-post-body-paragraph kj kk iq kl b km nb jv ko kp nc jy kr ks nd ku kv kw ne ky kz la nf lc ld le ij bi translated">将10多个定制CocoaPods迁移到Swift包是一项棘手的任务，尤其是当它们相互依赖并且都由三个iOS/tvOS应用程序项目使用时。决定迁移的顺序和确定哪些依赖项会很快受到影响变得很困难，所以用一个图表来显示谁依赖谁听起来是一个很好的主意。</p><p id="183e" class="pw-post-body-paragraph kj kk iq kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">似乎有各种各样的依赖绘图工具已经可用，但没有一个满足我的所有要求。出于我的目的，绘图工具必须:</p><ul class=""><li id="f0fb" class="lf lg iq kl b km kn kp kq ks lh kw li la lj le lk ll lm ln bi translated">在模块级而不是类级绘制图形</li><li id="5214" class="lf lg iq kl b km lo kp lp ks lq kw lr la ls le lk ll lm ln bi translated">支持私人/内部图书馆</li><li id="a9c1" class="lf lg iq kl b km lo kp lp ks lq kw lr la ls le lk ll lm ln bi translated">在单个图表中显示Swift包和CocoaPods</li></ul></div><div class="ab cl ng nh hu ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="ij ik il im in"><h1 id="f5f0" class="mj mk iq bd ml mm nn mo mp mq no ms mt ka np kb mv kd nq ke mx kg nr kh mz na bi translated">查找导入的模块</h1><p id="56c8" class="pw-post-body-paragraph kj kk iq kl b km nb jv ko kp nc jy kr ks nd ku kv kw ne ky kz la nf lc ld le ij bi translated">最初，我用<code class="fe jn jo jp jq b">objdump</code>(稍后会有更多介绍)作为展示二进制文件依赖于什么库的一种方式，然而很快就发现并不是所有的情况都可以用这种方式解决。由于每个模块导入都由一行代码表示，如<code class="fe jn jo jp jq b">import MyModule</code> …看起来行动的过程就是简单地让工具读取这些导入。</p><h2 id="037a" class="ns mk iq bd ml nt nu dn mp nv nw dp mt ks nx ny mv kw nz oa mx la ob oc mz od bi translated">读取Xcode目标的编译源列表</h2><p id="8289" class="pw-post-body-paragraph kj kk iq kl b km nb jv ko kp nc jy kr ks nd ku kv kw ne ky kz la nf lc ld le ij bi translated">如果你和任何规模的团队一起做过Xcode项目，那么在解决合并冲突的时候，你无疑必须处理读取<code class="fe jn jo jp jq b">project.pbxproj</code>文件的头痛问题。我不想花时间去破译它的格式，只是为了得到一个编译源代码的列表，所以幸运的是<a class="ae oe" href="https://github.com/CocoaPods/Xcodeproj" rel="noopener ugc nofollow" target="_blank"> Cocoapods团队有一个工具</a>来与它交互。</p><pre class="lu lv lw lx gt of jq og oh aw oi bi"><span id="7e2e" class="ns mk iq jq b gy oj ok l ol om">require 'xcodeproj'</span><span id="d011" class="ns mk iq jq b gy on ok l ol om">Xcodeproj::Project.open("SomeApp.xcodeproj")<br/>    .targets<br/>    .filter do |target|<br/>        target.name == "SomeApp"<br/>    end<br/>    .first<br/>    .source_build_phase.files.to_a<br/>    .each do |file| <br/>        puts file.file_ref.real_path.to_s <br/>    end</span></pre><p id="fe8e" class="pw-post-body-paragraph kj kk iq kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">这个脚本…是用Ruby写的。这很烦人，因为Ruby意味着Gems，Gems意味着Bundler，Bundler意味着过于频繁地对Rbenv设置进行故障排除。但是……大多数iOS工程师已经为CocoaPods做了所有这些工作，这比解析pbxproj要好，所以我把它压缩成一个可shell化的一行程序，并且<a class="ae oe" href="https://github.com/maxchuquimia/xcgrapher/blob/d5b410f1f42bb95ce51453da539834d3678d85a4/Sources/XCGrapherLib/ShellTasks/Xcodeproj.swift#L20" rel="noopener ugc nofollow" target="_blank">那个</a>就是目前在<code class="fe jn jo jp jq b">xcgrapher</code>中使用的:</p><pre class="lu lv lw lx gt of jq og oh aw oi bi"><span id="d095" class="ns mk iq jq b gy oj ok l ol om"><strong class="jq ir">$</strong> ruby -r xcodeproj -e 'Xcodeproj::Project.open("XXX").targets.filter do |t| t.name == "YYY" end.first.source_build_phase.files.to_a.each do |f| puts f.file_ref.real_path.to_s end'</span></pre><p id="19fa" class="pw-post-body-paragraph kj kk iq kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">现在继续。</p><h2 id="a27f" class="ns mk iq bd ml nt nu dn mp nv nw dp mt ks nx ny mv kw nz oa mx la ob oc mz od bi translated">查找导入</h2><p id="833b" class="pw-post-body-paragraph kj kk iq kl b km nb jv ko kp nc jy kr ks nd ku kv kw ne ky kz la nf lc ld le ij bi translated">这相对简单:遍历编译源列表，找到所有带有<code class="fe jn jo jp jq b">import Something</code>的行，并将所有的<code class="fe jn jo jp jq b">Something</code>编译到一个列表中。导入有多种方式，包括:</p><pre class="lu lv lw lx gt of jq og oh aw oi bi"><span id="e162" class="ns mk iq jq b gy oj ok l ol om">import Module<br/>@testable import Module<br/>import class Module.Class<br/>@_exported import Module</span></pre><p id="72df" class="pw-post-body-paragraph kj kk iq kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">我尽可能多地解释了这些，然后是一些。查看<a class="ae oe" href="https://github.com/maxchuquimia/xcgrapher/blob/master/Sources/XCGrapherLib/ImportFinder.swift" rel="noopener ugc nofollow" target="_blank"> ImportFinder </a>获取完整列表。</p><h2 id="2d58" class="ns mk iq bd ml nt nu dn mp nv nw dp mt ks nx ny mv kw nz oa mx la ob oc mz od bi translated">在Swift包裹中查找进口</h2><p id="c743" class="pw-post-body-paragraph kj kk iq kl b km nb jv ko kp nc jy kr ks nd ku kv kw ne ky kz la nf lc ld le ij bi translated">同样的<code class="fe jn jo jp jq b">ImportFinder</code>代码需要在每个Swift软件包上运行。据我所知，没有简单的方法列出Xcode项目所依赖的所有Swift包，因为我也不希望我的工具在读取每个包的源代码之前必须克隆每个包的正确提交，所以我选择了简单的<a class="ae oe" href="https://github.com/maxchuquimia/xcgrapher/blob/d5b410f1f42bb95ce51453da539834d3678d85a4/Sources/XCGrapherLib/ShellTasks/Xcodebuild.swift#L39" rel="noopener ugc nofollow" target="_blank">运行xcodebuild </a>并解析其输出以找到本地包克隆。</p><p id="95ee" class="pw-post-body-paragraph kj kk iq kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">一旦知道了每个包的克隆目录，获得每个目标的源文件列表就很容易了！</p><pre class="lu lv lw lx gt of jq og oh aw oi bi"><span id="3556" class="ns mk iq jq b gy oj ok l ol om"><strong class="jq ir">$</strong> swift package -—package-path /path/to/clone describe -—type json</span></pre><p id="a93a" class="pw-post-body-paragraph kj kk iq kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">然后前面提到的<code class="fe jn jo jp jq b">ImportFinder</code>可以用来读取每个包装产品中的所有进口商品。</p><h2 id="ee00" class="ns mk iq bd ml nt nu dn mp nv nw dp mt ks nx ny mv kw nz oa mx la ob oc mz od bi translated">在椰子中寻找进口</h2><p id="641b" class="pw-post-body-paragraph kj kk iq kl b km nb jv ko kp nc jy kr ks nd ku kv kw ne ky kz la nf lc ld le ij bi translated">这对我来说不是一个优先考虑的问题，因为我们正在远离cocoa pods——事实上，<code class="fe jn jo jp jq b">xcgrapher</code>目前主要面向只使用Swift包的项目。编译已知CocoaPods列表的最简单方法是解析<code class="fe jn jo jp jq b">Podfile.lock</code>:如果您对此感兴趣，那么请在这里查看实现<a class="ae oe" href="https://github.com/maxchuquimia/xcgrapher/blob/master/Sources/XCGrapherLib/DependencyManagers/CocoapodsManager.swift" rel="noopener ugc nofollow" target="_blank"/>。</p></div><div class="ab cl ng nh hu ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="ij ik il im in"><h1 id="3c98" class="mj mk iq bd ml mm nn mo mp mq no ms mt ka np kb mv kd nq ke mx kg nr kh mz na bi translated">用GraphViz绘图</h1><p id="d89a" class="pw-post-body-paragraph kj kk iq kl b km nb jv ko kp nc jy kr ks nd ku kv kw ne ky kz la nf lc ld le ij bi translated">一旦编译了所有导入模块的列表，那么<code class="fe jn jo jp jq b">xcgrapher</code>将遍历它们，并将它们与其他模块进行匹配。实际的绘图是通过使用有向图的<a class="ae oe" href="https://graphviz.org/" rel="noopener ugc nofollow" target="_blank"> GraphViz </a>完成的。有向图是一种用于指定图上“节点”之间“边”的格式(箭头在<strong class="kl ir">di</strong>rected-<strong class="kl ir">graph</strong>中):</p><pre class="lu lv lw lx gt of jq og oh aw oi bi"><span id="5f47" class="ns mk iq jq b gy oj ok l ol om">digraph XCGrapher {<br/><br/>  graph [ nodesep = 0.5, ranksep = 4, overlap = false, splines = true ]<br/>  node [ shape = box ]<br/><br/>  "Algorithms" -&gt; "RealModule"<br/>  "Charts" -&gt; "Algorithms"<br/>  "RealModule" -&gt; "_NumericsShims"<br/>  "RealmSwift" -&gt; "Realm"<br/>  "SomeApp" -&gt; "Charts"<br/>  "SomeApp" -&gt; "Lottie"<br/>  "SomeApp" -&gt; "RealmSwift"<br/><br/>}</span></pre><p id="67a5" class="pw-post-body-paragraph kj kk iq kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">如果你想亲自尝试，只需用<code class="fe jn jo jp jq b">brew install graphviz</code>然后用<code class="fe jn jo jp jq b">dot -T png -o output.png digraph.txt</code>从包含上述内容的文本文件中生成一个PNG图像。当在本地运行<code class="fe jn jo jp jq b">xcgrapher</code>时，你的有向图存储在<code class="fe jn jo jp jq b">/tmp/xcgrapher.dot</code>。</p><p id="6261" class="pw-post-body-paragraph kj kk iq kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">这是最简单的例子。GraphViz的功能非常非常多。一定要去看看！</p><div class="oo op gp gr oq or"><a href="https://graphviz.org/" rel="noopener  ugc nofollow" target="_blank"><div class="os ab fo"><div class="ot ab ou cl cj ov"><h2 class="bd ir gy z fp ow fr fs ox fu fw ip bi translated">Graphviz图形可视化软件</h2><div class="oy l"><h3 class="bd b gy z fp ow fr fs ox fu fw dk translated">请加入Graphviz论坛提问，讨论Graphviz。Graphviz是开源的图形可视化工具…</h3></div><div class="oz l"><p class="bd b dl z fp ow fr fs ox fu fw dk translated">graphviz.org</p></div></div><div class="pa l"><div class="pb l pc pd pe pa pf md or"/></div></div></a></div></div><div class="ab cl ng nh hu ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="ij ik il im in"><h1 id="7675" class="mj mk iq bd ml mm nn mo mp mq no ms mt ka np kb mv kd nq ke mx kg nr kh mz na bi translated">👨‍💻使用XCGrapher插件创建自定义图表</h1><p id="5602" class="pw-post-body-paragraph kj kk iq kl b km nb jv ko kp nc jy kr ks nd ku kv kw ne ky kz la nf lc ld le ij bi translated">我们才刚刚开始。</p><p id="a0d2" class="pw-post-body-paragraph kj kk iq kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">如果你想画别的东西呢？例如，我们的项目使用自定义属性包装器<code class="fe jn jo jp jq b">@Injected</code>作为将依赖项注入类实例的方式。哪些类需要哪些注入的图表在将来也会有用…</p><p id="d1b5" class="pw-post-body-paragraph kj kk iq kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">您可以使用一个<code class="fe jn jo jp jq b">xcgrapher</code>插件来完成这些定制任务，而不是编写上面描述的所有模板。</p><h2 id="4d1e" class="ns mk iq bd ml nt nu dn mp nv nw dp mt ks nx ny mv kw nz oa mx la ob oc mz od bi translated">插件结构</h2><p id="9d47" class="pw-post-body-paragraph kj kk iq kl b km nb jv ko kp nc jy kr ks nd ku kv kw ne ky kz la nf lc ld le ij bi translated"><code class="fe jn jo jp jq b">xcgrapher</code>插件只是编译成动态库的Swift包，依赖于<code class="fe jn jo jp jq b">XCGrapherPluginSupport</code>:</p><pre class="lu lv lw lx gt of jq og oh aw oi bi"><span id="da3a" class="ns mk iq jq b gy oj ok l ol om">let package = Package(<br/>    name: "MyPlugin",<br/>    products: [<br/>        .library(<br/>            name: "MyPlugin",<br/>            type: .dynamic, <br/>            targets: ["MyPlugin"]<br/>        ),<br/>    ],<br/>    dependencies: [<br/>        .package(<br/>            url: "https://github.com/maxchuquimia/XCGrapherPluginSupport.git", <br/>            from: "0.0.6"<br/>        ),<br/>    ],<br/>    targets: [<br/>        .target(<br/>            name: "MyPlugin", <br/>            dependencies: [<br/>                .product(<br/>                    name: "XCGrapherPluginSupport",<br/>                    package: "xcgrapher"<br/>                )<br/>            ]<br/>        ),<br/>    ]<br/>)</span></pre><p id="6bf1" class="pw-post-body-paragraph kj kk iq kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">在包中你可以<code class="fe jn jo jp jq b">import XCGrapherPluginSupport</code>和子类<code class="fe jn jo jp jq b">XCGrapherPlugin</code>。然后，您可以覆盖函数来帮助构建您的图形:</p><p id="5590" class="pw-post-body-paragraph kj kk iq kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated"><code class="fe jn jo jp jq b"><strong class="kl ir">override func process(file: XCGrapherFile) throws -&gt; [Any] { ... }</strong><br/></code>该函数为项目中的每个源文件调用一次，为Swift包依赖关系中的每个源文件调用一次(如果<code class="fe jn jo jp jq b">--spm</code>传递给<code class="fe jn jo jp jq b">xcgrapher</code>)。模型<code class="fe jn jo jp jq b">XCGrapherFile</code>包含关于源文件的便利信息，然后你可以用你自己的方式解析它(见<a class="ae oe" href="https://github.com/maxchuquimia/XCGrapherPluginSupport/tree/master/Sources/XCGrapherPluginSupport/XCGrapherFile.swift" rel="noopener ugc nofollow" target="_blank">XCGrapherFile</a><em class="pg">)</em>。</p><p id="8b24" class="pw-post-body-paragraph kj kk iq kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated"><code class="fe jn jo jp jq b"><strong class="kl ir">override func process(library: XCGrapherImport) throws -&gt; [Any] { ... }</strong><br/></code>这个函数在你的项目中的每一个<code class="fe jn jo jp jq b">import SomeLibrary</code>行被调用一次(取决于传递给<code class="fe jn jo jp jq b">xcgrapher</code>的标志)。<code class="fe jn jo jp jq b">SomeLibrary</code>以<code class="fe jn jo jp jq b">XCGrapherImport</code>模式为代表。可用参数见<a class="ae oe" href="https://github.com/maxchuquimia/XCGrapherPluginSupport/tree/master/Sources/XCGrapherPluginSupport/XCGrapherImport.swift" rel="noopener ugc nofollow" target="_blank"> XCGrapherImport </a>。</p><p id="fd10" class="pw-post-body-paragraph kj kk iq kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated"><code class="fe jn jo jp jq b"><strong class="kl ir">override func makeArrows(from results: [Any]) throws -&gt; [XCGrapherArrow]<br/></strong></code>上面列出的处理函数返回的数组将被连接并传递给你，以便在<code class="fe jn jo jp jq b">makeArrows(from:)</code>函数中进行最终合并。在这里，你应该按照你认为合适的方式遍历<code class="fe jn jo jp jq b">results</code>，以便返回一个<code class="fe jn jo jp jq b">XCGrapherArrow</code>模型的列表，这些模型将被传递给GraphViz并被绘制到<code class="fe jn jo jp jq b">xcgrapher</code>的<code class="fe jn jo jp jq b">--output</code> PNG文件中。</p><p id="edbb" class="pw-post-body-paragraph kj kk iq kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated"><em class="pg">我在这里选择使用</em> <code class="fe jn jo jp jq b"><em class="pg">Any</em></code> <em class="pg">是为了给你这个插件构建者尽可能多的灵活性。强制插件成为</em> <code class="fe jn jo jp jq b"><em class="pg">XCGrapherPlugin</em></code> <em class="pg">的子类，而不是任何符合协议的对象，这是另一个战略决策，使插件构建者的生活更容易，因为有些棘手的事情需要以后做——继续阅读！</em></p><p id="aae1" class="pw-post-body-paragraph kj kk iq kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">因此，如果您想要绘制每个文件(包括Swift包)中的所有<code class="fe jn jo jp jq b">@Injected</code>行，您需要做的就是解析<code class="fe jn jo jp jq b">process(file:)</code>中的<code class="fe jn jo jp jq b">file</code>，返回您自己的表示<code class="fe jn jo jp jq b">@Injected</code>关系的对象，然后在<code class="fe jn jo jp jq b">makeArrows(from:)</code>函数中将该对象转换为<code class="fe jn jo jp jq b">XCGrapherArrow</code>！</p><h2 id="ab3b" class="ns mk iq bd ml nt nu dn mp nv nw dp mt ks nx ny mv kw nz oa mx la ob oc mz od bi translated">👨‍🔧避免混乱的函数名</h2><p id="921f" class="pw-post-body-paragraph kj kk iq kl b km nb jv ko kp nc jy kr ks nd ku kv kw ne ky kz la nf lc ld le ij bi translated">你有没有在Xcode的调试器中编辑过一些东西，并注意到一个类的名字看起来… <em class="pg">混乱不堪</em>？例如，考虑以下Swift文件:</p><pre class="lu lv lw lx gt of jq og oh aw oi bi"><span id="5f04" class="ns mk iq jq b gy oj ok l ol om"><em class="pg">// doSomething.swift</em></span><span id="ae7a" class="ns mk iq jq b gy on ok l ol om">public func <!-- -->thisFunctionDoesSomething<!-- -->() {<br/>    print("doing something...")<br/>}</span></pre><p id="0946" class="pw-post-body-paragraph kj kk iq kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">如果您要将这个<code class="fe jn jo jp jq b">doSomething.swift</code>编译成一个动态库:</p><pre class="lu lv lw lx gt of jq og oh aw oi bi"><span id="4790" class="ns mk iq jq b gy oj ok l ol om"><strong class="jq ir">$</strong> swiftc -emit-library -module-name libDoSomething doSomething.swift</span></pre><p id="4b54" class="pw-post-body-paragraph kj kk iq kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">然后使用<code class="fe jn jo jp jq b">nm</code>打印出结果dylib中的所有符号，您可以看到我们的函数名称<code class="fe jn jo jp jq b">thisFunctionDoesSomething()</code>不再是我们所期望的:</p><pre class="lu lv lw lx gt of jq og oh aw oi bi"><span id="a6e3" class="ns mk iq jq b gy oj ok l ol om"><strong class="jq ir">$</strong> nm -an liblibDoSomething.dylib <br/>                 U _$sSS21_builtinStringLiteral17utf8CodeUnitCount7isASCIISSBp_BwBi1_tcfC<br/>                 U _$sSSN<br/>                 U _$ss27_allocateUninitializedArrayySayxG_BptBwlF<br/>                 U _$ss5print_9separator10terminatoryypd_S2StF<br/>                 U _$sypN<br/>                 U _swift_bridgeObjectRelease<br/>                 U dyld_stub_binder<br/>0000000000003e50 T <strong class="jq ir">_$s14libDoSomething016thisFunctionDoesC0yyF</strong><br/>0000000000003f00 t _$ss5print_9separator10terminatoryypd_S2StFfA0_<br/>0000000000003f20 t _$ss5print_9separator10terminatoryypd_S2StFfA1_<br/>0000000000003fa8 s ___swift_reflection_version<br/>0000000000008020 d __dyld_private</span></pre><blockquote class="ph pi pj"><p id="1803" class="kj kk pg kl b km kn jv ko kp kq jy kr pk kt ku kv pl kx ky kz pm lb lc ld le ij bi translated">Swift编译器将被破坏的名称发送到二进制映像中，以对运行时实例化和反射的类型引用进行编码。在二进制文件中，这些混乱的名称可能会嵌入指向运行时数据结构的指针，以便更有效地表示本地定义的类型。<br/>—<a class="ae oe" href="https://github.com/apple/swift/blob/main/docs/ABI/Mangling.rst" rel="noopener ugc nofollow" target="_blank">https://github . com/apple/swift/blob/main/docs/ABI/mangling . rst</a></p></blockquote><p id="a59a" class="pw-post-body-paragraph kj kk iq kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">简而言之，名称管理允许编译器以确定的方式为函数生成新名称——这很重要，因为它允许我们开发人员编写(例如)两个同名的函数(每次我们在子类中覆盖函数时都会这样做)。</p><p id="4143" class="pw-post-body-paragraph kj kk iq kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">为了避免在Swift中混淆，我们可以使用<code class="fe jn jo jp jq b">@_cdecl</code>属性来指定编译器应该为被注释的函数存储的确切符号名:</p><pre class="lu lv lw lx gt of jq og oh aw oi bi"><span id="1c39" class="ns mk iq jq b gy oj ok l ol om"><em class="pg">// doSomething.swift</em></span><span id="e187" class="ns mk iq jq b gy on ok l ol om"><strong class="jq ir">@_cdecl("thisFunctionDoesSomething")</strong><br/>public func thisFunctionDoesSomething() {<br/>    print("doing something...")<br/>}</span></pre><p id="b095" class="pw-post-body-paragraph kj kk iq kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">现在，当我们编译并列出dylib二进制文件中的符号时，我们可以清楚地看到我们的函数名！</p><pre class="lu lv lw lx gt of jq og oh aw oi bi"><span id="443c" class="ns mk iq jq b gy oj ok l ol om"><strong class="jq ir">$</strong> swiftc -emit-library -module-name libDoSomething doSomething.swift<br/><strong class="jq ir">$</strong> nm -an liblibDoSomething.dylib <br/>                 U _$sSS21_builtinStringLiteral17utf8CodeUnitCount7isASCIISSBp_BwBi1_tcfC<br/>                 U _$sSSN<br/>                 U _$ss27_allocateUninitializedArrayySayxG_BptBwlF<br/>                 U _$ss5print_9separator10terminatoryypd_S2StF<br/>                 U _$sypN<br/>                 U _swift_bridgeObjectRelease<br/>                 U dyld_stub_binder<br/>0000000000003e40 T _<strong class="jq ir">thisFunctionDoesSomething</strong><br/>0000000000003e50 T _$s14libDoSomething016thisFunctionDoesC0yyF<br/>0000000000003f00 t _$ss5print_9separator10terminatoryypd_S2StFfA0_<br/>0000000000003f20 t _$ss5print_9separator10terminatoryypd_S2StFfA1_<br/>0000000000003fa8 s ___swift_reflection_version<br/>0000000000008020 d __dyld_private</span></pre><p id="e205" class="pw-post-body-paragraph kj kk iq kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">在运行时加载库时，我们需要在编译符号之前知道它们的名称，这样我们就可以调用它们——所以在创建自定义<code class="fe jn jo jp jq b">XCGrapherPlugin</code>子类的插件dylib中注释一个函数是必须的:</p><pre class="lu lv lw lx gt of jq og oh aw oi bi"><span id="1a87" class="ns mk iq jq b gy oj ok l ol om">@_cdecl("makeXCGrapherPlugin")                       <br/>public func makeXCGrapherPlugin() -&gt; UnsafeMutableRawPointer {<br/>    Unmanaged.passRetained(MyPlugin()).toOpaque()                       }</span></pre><p id="de8b" class="pw-post-body-paragraph kj kk iq kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">我们在这里使用<code class="fe jn jo jp jq b">UnsafeMutableRawPointer</code>,因为我们正在做Dodgy Things，而Swift编译器不希望对大量可能出错的事情负责。</p><blockquote class="ph pi pj"><p id="02e3" class="kj kk pg kl b km kn jv ko kp kq jy kr pk kt ku kv pl kx ky kz pm lb lc ld le ij bi translated"><strong class="kl ir">那是斯威夫特高举双手后退……“嘿，你自己看着办吧，伙计”</strong><br/>——我的同事在我向他展示了实现之后</p></blockquote><p id="44f2" class="pw-post-body-paragraph kj kk iq kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">(实际上<code class="fe jn jo jp jq b">@_cdecl</code>将函数标记为C声明，所以我们需要使用C兼容的返回值。有一些关于让它得到官方支持的讨论，希望它能很快实现！)</p><h2 id="6031" class="ns mk iq bd ml nt nu dn mp nv nw dp mt ks nx ny mv kw nz oa mx la ob oc mz od bi translated">编译动态库</h2><p id="e438" class="pw-post-body-paragraph kj kk iq kl b km nb jv ko kp nc jy kr ks nd ku kv kw ne ky kz la nf lc ld le ij bi translated">像构建任何Swift包一样构建库:</p><pre class="lu lv lw lx gt of jq og oh aw oi bi"><span id="179b" class="ns mk iq jq b gy oj ok l ol om"><strong class="jq ir">$</strong> swift build -c release --disable-sandbox</span></pre><p id="39df" class="pw-post-body-paragraph kj kk iq kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">然后该库被保存到<code class="fe jn jo jp jq b">./.build/release/libMyPlugin.dylib</code></p><h2 id="e101" class="ns mk iq bd ml nt nu dn mp nv nw dp mt ks nx ny mv kw nz oa mx la ob oc mz od bi translated">🧙‍♂️在运行时加载动态库</h2><p id="1257" class="pw-post-body-paragraph kj kk iq kl b km nb jv ko kp nc jy kr ks nd ku kv kw ne ky kz la nf lc ld le ij bi translated">现在我们已经将dylib存储在磁盘上，回到主代码中，我们可以将它的路径传递给<code class="fe jn jo jp jq b">dlopen()</code>，并检索指向前面标有<code class="fe jn jo jp jq b">@_cdecl("makeXCGrapherPlugin")</code>的函数的符号:</p><pre class="lu lv lw lx gt of jq og oh aw oi bi"><span id="988a" class="ns mk iq jq b gy oj ok l ol om">let path = "/path/to/libMyPlugin.dylib"<br/>let openResult = dlopen(path, RTLD_NOW|RTLD_LOCAL)<br/>guard openResult != nil else { ... }<br/>defer { dlclose(openResult) }</span><span id="8dd5" class="ns mk iq jq b gy on ok l ol om">let symbol = dlsym(openResult, "makeXCGrapherPlugin")</span></pre><p id="99e8" class="pw-post-body-paragraph kj kk iq kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">如果你想了解<code class="fe jn jo jp jq b">RTLD_NOW</code>和<code class="fe jn jo jp jq b">RTLD_LOCAL</code>(我知道你不想！)，那么<a class="ae oe" href="https://pubs.opengroup.org/onlinepubs/009696699/functions/dlopen.html" rel="noopener ugc nofollow" target="_blank">这里</a>有一些信息给你。我似乎记得读到过，可能实际上并不需要<code class="fe jn jo jp jq b">RTLD_LOCAL</code>，因为它是默认的，除非你指定<code class="fe jn jo jp jq b">RTLD_GLOBAL</code> …但是我在网上看到的一半Swift例子都使用它，所以我现在把它留在这里。更多的是关于我不知道我是否应该删除的东西。</p><p id="b749" class="pw-post-body-paragraph kj kk iq kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">无论如何，我们可以将该符号转换为与动态库中的Dodgy Things函数具有相同签名的函数:</p><pre class="lu lv lw lx gt of jq og oh aw oi bi"><span id="6b0b" class="ns mk iq jq b gy oj ok l ol om">typealias MakeFunc = @convention(c) () -&gt; UnsafeMutableRawPointer</span><span id="1201" class="ns mk iq jq b gy on ok l ol om">let makePlugin = unsafeBitCast(symbol, to: MakeFunc.self)</span></pre><p id="21d5" class="pw-post-body-paragraph kj kk iq kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">最后调用函数得到动态库中定义的<code class="fe jn jo jp jq b">XCGrapherPlugin</code>子类的一个实例！</p><pre class="lu lv lw lx gt of jq og oh aw oi bi"><span id="ca03" class="ns mk iq jq b gy oj ok l ol om">let pluginPointer = makeXCGrapherPlugin()<br/>let plugin = Unmanaged&lt;XCGrapherPlugin&gt;.fromOpaque(pluginPointer)<br/>    .takeRetainedValue()</span></pre><blockquote class="ph pi pj"><p id="9f98" class="kj kk pg kl b km kn jv ko kp kq jy kr pk kt ku kv pl kx ky kz pm lb lc ld le ij bi translated"><strong class="kl ir">耶哇。这比我想象的简单多了<br/> </strong> —我的同事(同一个同事)</p></blockquote><p id="8b47" class="pw-post-body-paragraph kj kk iq kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">要使用新创建的<code class="fe jn jo jp jq b">xcgrapher</code>插件，请将其路径传递给<code class="fe jn jo jp jq b">xcgrapher</code>工具的<code class="fe jn jo jp jq b">--plugin</code>选项。</p><h2 id="8ae2" class="ns mk iq bd ml nt nu dn mp nv nw dp mt ks nx ny mv kw nz oa mx la ob oc mz od bi translated">实例和参考</h2><p id="e185" class="pw-post-body-paragraph kj kk iq kl b km nb jv ko kp nc jy kr ks nd ku kv kw ne ky kz la nf lc ld le ij bi translated"><code class="fe jn jo jp jq b">xcgrapher</code>的动态库加载代码可以在这里查看<a class="ae oe" href="https://github.com/maxchuquimia/xcgrapher/blob/master/Sources/XCGrapherLib/PluginSupport/PluginLoader.swift" rel="noopener ugc nofollow" target="_blank">。图形模块导入的默认行为是作为一个独立的插件实现的，可以在这里查看</a><a class="ae oe" href="https://github.com/maxchuquimia/xcgrapher/tree/master/Sources/XCGrapherModuleImportPlugin" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="76fe" class="pw-post-body-paragraph kj kk iq kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">我第一次从<a class="ae oe" href="https://theswiftdev.com/building-and-loading-dynamic-libraries-at-runtime-in-swift/" rel="noopener ugc nofollow" target="_blank">这篇</a>精彩的文章中了解到以这种方式加载库——他们的方法和我的有点不同，所以如果你想了解更多，请阅读一下！最后，<a class="ae oe" href="https://developer.apple.com/library/archive/documentation/DeveloperTools/Conceptual/DynamicLibraries/100-Articles/DynamicLibraryUsageGuidelines.html#//apple_ref/doc/uid/TP40001928-SW10" rel="noopener ugc nofollow" target="_blank">这里</a>是一些关于<code class="fe jn jo jp jq b">dlopen()</code>和朋友的官方文献。</p></div><div class="ab cl ng nh hu ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="ij ik il im in"><h1 id="3846" class="mj mk iq bd ml mm nn mo mp mq no ms mt ka np kb mv kd nq ke mx kg nr kh mz na bi translated">出版</h1><p id="83c5" class="pw-post-body-paragraph kj kk iq kl b km nb jv ko kp nc jy kr ks nd ku kv kw ne ky kz la nf lc ld le ij bi translated">构建工具的最后一步是使其易于安装。在macOS世界中，这意味着通过<code class="fe jn jo jp jq b">brew</code>来安装它。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi pn"><img src="../Images/375d89b35d86b725983995e73797381c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*PMQbS1DEjlv3dEX5"/></div></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated"><a class="ae oe" href="https://www.jspowerhour.com/comics/263" rel="noopener ugc nofollow" target="_blank">https://www.jspowerhour.com/comics/263</a></figcaption></figure><p id="c3c4" class="pw-post-body-paragraph kj kk iq kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">如果你想安装<code class="fe jn jo jp jq b">xcgrapher</code>，你需要先添加我的水龙头。</p><pre class="lu lv lw lx gt of jq og oh aw oi bi"><span id="39e2" class="ns mk iq jq b gy oj ok l ol om"><strong class="jq ir">$</strong> brew tap maxchuquimia/scripts<br/><strong class="jq ir">$</strong> brew install xcgrapher<br/><em class="pg"># If you don’t use CocoaPods you’ll also need to </em><a class="ae oe" href="https://github.com/CocoaPods/Xcodeproj" rel="noopener ugc nofollow" target="_blank"><em class="pg">install Xcodeproj</em></a><em class="pg">.</em></span></pre><p id="63f5" class="pw-post-body-paragraph kj kk iq kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">我选择使用我自己的水龙头，而不是将其添加到brew主水龙头，因为我不太喜欢像家酿和CocoaPods那样保持一切集中(出于速度原因)。我个人希望Swift包裹永远不要走这条路…</p><h2 id="3c09" class="ns mk iq bd ml nt nu dn mp nv nw dp mt ks nx ny mv kw nz oa mx la ob oc mz od bi translated">编译、安装和嵌入式动态库路径</h2><p id="4133" class="pw-post-body-paragraph kj kk iq kl b km nb jv ko kp nc jy kr ks nd ku kv kw ne ky kz la nf lc ld le ij bi translated">生成可执行文件的Swift包实际上与任何brew可安装工具没有什么不同:只需构建二进制文件并将其移动到由<code class="fe jn jo jp jq b">brew</code>指定的位置。我使用了一个Makefile来完成这项工作:</p><pre class="lu lv lw lx gt of jq og oh aw oi bi"><span id="7808" class="ns mk iq jq b gy oj ok l ol om">prefix ?= /usr/local<br/>bindir = $(prefix)/bin<br/>libdir = $(prefix)/lib<br/>buildroot = $(shell swift build -c release --show-bin-path)<br/><br/>configure:<br/>	echo "let DEFAULT_PLUGIN_LOCATION=\"$(libdir)/libXCGrapherModuleImportPlugin.dylib\"" &gt; Sources/xcgrapher/Generated.swift<br/><br/>build: configure<br/>	swift build -c release --disable-sandbox<br/><br/>install: build<br/>	mkdir -p "$(bindir)"<br/>	mkdir -p "$(libdir)"<br/>	install "$(buildroot)/xcgrapher" "$(bindir)"<br/>	install "$(buildroot)/libXCGrapherPluginSupport.dylib" "$(libdir)"<br/>	install "$(buildroot)/libXCGrapherModuleImportPlugin.dylib" "$(libdir)"<br/>	install_name_tool -change "$(buildroot)/libXCGrapherPluginSupport.dylib" "$(libdir)/libXCGrapherPluginSupport.dylib" "$(bindir)/xcgrapher"<br/><br/>uninstall:<br/>	rm -rf "$(bindir)/xcgrapher"<br/>	rm -rf "$(libdir)/libXCGrapherPluginSupport.dylib"<br/>	rm -rf "$(libdir)/libXCGrapherModuleImportPlugin.dylib"<br/><br/>clean:<br/>	rm -rf .build<br/>	rm Sources/xcgrapher/Generated.swift<br/><br/>.PHONY: build install uninstall clean configure</span></pre><p id="5f2b" class="pw-post-body-paragraph kj kk iq kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">这里发生了一些事情！首先是一些定义，然后是几个步骤:</p><p id="710a" class="pw-post-body-paragraph kj kk iq kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated"><strong class="kl ir">前缀？= /usr/local <br/></strong></p><p id="2a86" class="pw-post-body-paragraph kj kk iq kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated"><strong class="kl ir"> bindir </strong>和<strong class="kl ir"> libdir <br/>和</strong>这两个变量定义了二进制文件和库应该安装的目录。</p><p id="2a2d" class="pw-post-body-paragraph kj kk iq kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated"><strong class="kl ir"> buildroot <br/> </strong>这个变量被设置为<code class="fe jn jo jp jq b">swift build -c release --show-bin-path</code>的输出——这是<code class="fe jn jo jp jq b">swift build</code>在编译时将工件写入的目录。</p><p id="8315" class="pw-post-body-paragraph kj kk iq kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated"><strong class="kl ir">配置:</strong><br/><code class="fe jn jo jp jq b">configure</code>目标将预测的dylib安装路径写入<code class="fe jn jo jp jq b">xcgrapher</code>的包内的文件中。然后在编译时获得，生成的<code class="fe jn jo jp jq b">DEFAULT_PLUGIN_LOCATION</code>变量被用作<code class="fe jn jo jp jq b">--plugin</code>参数的默认值。</p><p id="5ed9" class="pw-post-body-paragraph kj kk iq kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated"><strong class="kl ir">构建:</strong><br/><code class="fe jn jo jp jq b">build</code>目标首先运行配置步骤。然后使用<code class="fe jn jo jp jq b">mkdir -p</code>确保二进制和库目录存在。第一个<code class="fe jn jo jp jq b">install</code>命令安全地将<code class="fe jn jo jp jq b">xcgrapher</code>二进制文件复制到二进制文件目录，第二个和第三个<code class="fe jn jo jp jq b">install</code>命令将<code class="fe jn jo jp jq b">libXCGrapherPluginSupport.dylib</code>和<code class="fe jn jo jp jq b">libXCGrapherModuleImportPlugin.dylib</code>复制到库目录。</p><p id="c4f6" class="pw-post-body-paragraph kj kk iq kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated"><strong class="kl ir">🕵️‍♂️install _ name _ tool<br/></strong><code class="fe jn jo jp jq b">install_name_tool</code>是一个有趣的命令:它打开一个二进制文件(第三个参数)并将匹配第一个参数的dylib路径更改为第二个参数的路径。使用<code class="fe jn jo jp jq b">install_name_tool</code>似乎是马特·汤普森(一个可靠的知识来源)推荐的<a class="ae oe" href="https://nshipster.com/homebrew/" rel="noopener ugc nofollow" target="_blank">这里是</a>，但是在他的文章中他并没有详细说明在什么情况下需要它。所以，我当然决定调查一下。</p><p id="f5d1" class="pw-post-body-paragraph kj kk iq kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">让我们看看<code class="fe jn jo jp jq b">xcgrapher</code>依赖的所有动态库(注意<code class="fe jn jo jp jq b">/usr/local/bin/xcgrapher</code>是<code class="fe jn jo jp jq b">xcgrapher</code>二进制安装的路径) :</p><pre class="lu lv lw lx gt of jq og oh aw oi bi"><span id="a435" class="ns mk iq jq b gy oj ok l ol om"><strong class="jq ir">$</strong> objdump -p /usr/local/bin/xcgrapher<br/><br/>/usr/local/bin/xcgrapher:    file format Mach-O 64-bit x86-64<br/><br/>Mach header<br/>      magic cputype cpusubtype  caps    filetype ncmds sizeofcmds      flags<br/>MH_MAGIC_64  X86_64        ALL  0x00     EXECUTE    30       4240   NOUNDEFS DYLDLINK TWOLEVEL PIE<br/>Load command 0<br/>&lt;redacted&gt;<br/>&lt;redacted&gt;<br/>&lt;redacted&gt;<br/>Load command 13<br/>          cmd LC_LOAD_DYLIB<br/>      cmdsize 56<br/>         name /usr/lib/libobjc.A.dylib (offset 24)<br/>   time stamp 2 Thu Jan  1 10:00:02 1970<br/>      current version 228.0.0<br/>compatibility version 1.0.0<br/>Load command 14<br/>          cmd LC_LOAD_DYLIB<br/>      cmdsize 56<br/>         name /usr/lib/libSystem.B.dylib (offset 24)<br/>   time stamp 2 Thu Jan  1 10:00:02 1970<br/>      current version 1292.60.1<br/>compatibility version 1.0.0<br/>Load command 15<br/>          cmd LC_LOAD_DYLIB<br/>      cmdsize 64<br/>         name @rpath/libXCGrapherPluginSupport.dylib (offset 24)<br/>   time stamp 2 Thu Jan  1 10:00:02 1970<br/>      current version 0.0.0<br/>compatibility version 0.0.0<br/>Load command 16<br/>          cmd LC_LOAD_DYLIB<br/>      cmdsize 96<br/>         name /System/Library/Frameworks/Foundation.framework/Versions/C/Foundation (offset 24)<br/>   time stamp 2 Thu Jan  1 10:00:02 1970<br/>      current version 1770.255.0<br/>&lt;redacted&gt;<br/>&lt;redacted&gt;<br/>&lt;redacted&gt;</span></pre><p id="3eaa" class="pw-post-body-paragraph kj kk iq kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">好的，让我们再试一次，这次进行一些过滤(只打印匹配<code class="fe jn jo jp jq b">LC_LOAD_DYLIB</code>及其后两行的行) :</p><pre class="lu lv lw lx gt of jq og oh aw oi bi"><span id="5d9f" class="ns mk iq jq b gy oj ok l ol om"><strong class="jq ir">$</strong> objdump -p /usr/local/bin/xcgrapher | grep LC_LOAD_DYLIB -A 2<br/>          cmd LC_LOAD_DYLIB<br/>      cmdsize 56<br/>         name /usr/lib/libobjc.A.dylib (offset 24)<br/>--<br/>          cmd LC_LOAD_DYLIB<br/>      cmdsize 56<br/>         name /usr/lib/libSystem.B.dylib (offset 24)<br/>--<br/>          cmd LC_LOAD_DYLIB<br/>      cmdsize 64<br/><strong class="jq ir">         name @rpath/libXCGrapherPluginSupport.dylib (offset 24)</strong><br/>--<br/>          cmd LC_LOAD_DYLIB<br/>      cmdsize 96<br/>         name /System/Library/Frameworks/Foundation.framework/Versions/C/Foundation (offset 24)<br/>--<br/>          cmd LC_LOAD_DYLIB<br/>      cmdsize 64<br/>         name /usr/lib/swift/libswiftCore.dylib (offset 24)<br/>--<br/>          cmd LC_LOAD_DYLIB<br/>      cmdsize 64<br/>         name /usr/lib/swift/libswiftDarwin.dylib (offset 24)<br/>--<br/>          cmd LC_LOAD_DYLIB<br/>      cmdsize 64<br/>         name /usr/lib/swift/libswiftFoundation.dylib (offset 24)</span></pre><p id="3da9" class="pw-post-body-paragraph kj kk iq kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">在这里，你可以清楚地看到<code class="fe jn jo jp jq b">xcgrapher</code>需要的所有dylibs包括我们自己的<code class="fe jn jo jp jq b">libXCGrapherPluginSupport</code>(注意，这不是我们在运行时加载的插件本身:这是定义我们之前谈到的超类<code class="fe jn jo jp jq b">XCGrapherPlugin</code>的包)。</p><p id="11eb" class="pw-post-body-paragraph kj kk iq kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated"><code class="fe jn jo jp jq b">libXCGrapherPluginSupport</code>没有像其他库一样给出完整的路径:而是以<code class="fe jn jo jp jq b">@rpath</code>开始！这是一个<a class="ae oe" href="https://developer.apple.com/library/archive/documentation/DeveloperTools/Conceptual/DynamicLibraries/100-Articles/RunpathDependentLibraries.html" rel="noopener ugc nofollow" target="_blank">特殊的宏</a>，它允许我们<em class="pg">避免</em>不得不做的事情，比如使用<code class="fe jn jo jp jq b">install_name_tool</code>并使我们开发者能够分发带有dylibs的程序。事实上，Makefile中的<code class="fe jn jo jp jq b">install_name_tool</code>命令似乎完全没有用，因为它试图匹配<code class="fe jn jo jp jq b">.build/release/libXCGrapherPluginSupport.dylib</code>而不是<code class="fe jn jo jp jq b">@rpath/libXCGrapherPluginSupport.dylib</code>。</p><p id="70ed" class="pw-post-body-paragraph kj kk iq kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">改变应该加载的dylib路径的真正方法是:</p><pre class="lu lv lw lx gt of jq og oh aw oi bi"><span id="0c07" class="ns mk iq jq b gy oj ok l ol om"><strong class="jq ir">$ </strong>install_name_tool -change "@rpath/libXCGrapherPluginSupport.dylib" "/new/dylib/path/something.dylib" /usr/local/bin/xcgrapher</span></pre><p id="41c2" class="pw-post-body-paragraph kj kk iq kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">现在，当我们再次搜索已加载的库时:</p><pre class="lu lv lw lx gt of jq og oh aw oi bi"><span id="b23a" class="ns mk iq jq b gy oj ok l ol om"><strong class="jq ir">$</strong> objdump -p /usr/local/bin/xcgrapher | grep LC_LOAD_DYLIB -A 2<br/>          cmd LC_LOAD_DYLIB<br/>      cmdsize 56<br/>         name /usr/lib/libobjc.A.dylib (offset 24)<br/>--<br/>          cmd LC_LOAD_DYLIB<br/>      cmdsize 56<br/>         name /usr/lib/libSystem.B.dylib (offset 24)<br/>--<br/>          cmd LC_LOAD_DYLIB<br/>      cmdsize 56<br/><strong class="jq ir">         name /new/dylib/path/something.dylib (offset 24)</strong><br/>--<br/>          cmd LC_LOAD_DYLIB<br/>      cmdsize 96<br/>         name /System/Library/Frameworks/Foundation.framework/Versions/C/Foundation (offset 24)<br/>--<br/>          cmd LC_LOAD_DYLIB<br/>      cmdsize 64<br/>         name /usr/lib/swift/libswiftCore.dylib (offset 24)<br/>--<br/>          cmd LC_LOAD_DYLIB<br/>      cmdsize 64<br/>         name /usr/lib/swift/libswiftDarwin.dylib (offset 24)<br/>--<br/>          cmd LC_LOAD_DYLIB<br/>      cmdsize 64<br/>         name /usr/lib/swift/libswiftFoundation.dylib (offset 24)</span></pre><p id="fdac" class="pw-post-body-paragraph kj kk iq kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated"><code class="fe jn jo jp jq b">libXCGrapherPluginSupport.dylib</code>不见踪影。如果我们现在尝试运行<code class="fe jn jo jp jq b">xcgrapher</code>，我们会得到一个我们中的一些人可能很熟悉的错误:</p><pre class="lu lv lw lx gt of jq og oh aw oi bi"><span id="11c8" class="ns mk iq jq b gy oj ok l ol om"><strong class="jq ir">$</strong> xcgrapher <br/>dyld: Library not loaded: /new/dylib/path/something.dylib<br/>  Referenced from: /usr/local/bin/xcgrapher<br/>  Reason: image not found<br/>Abort trap: 6</span></pre><p id="e51e" class="pw-post-body-paragraph kj kk iq kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">我在Makefile中留下<code class="fe jn jo jp jq b">install_name_tool</code>的原因主要是担心我缺乏这方面的知识。也许马特知道一些我不知道的事情，也许在他的机器上运行<code class="fe jn jo jp jq b">swift build</code>时，就不用<code class="fe jn jo jp jq b">@rpath</code>宏了？我这里只有两台电脑可以测试安装，也许如果我在第三台电脑上试一试，就会需要它了？现在，我要留着它。</p><p id="d6f2" class="pw-post-body-paragraph kj kk iq kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">无论如何，回到遍历Makefile。</p><p id="fb46" class="pw-post-body-paragraph kj kk iq kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated"><strong class="kl ir">卸载:<br/></strong><code class="fe jn jo jp jq b">uninstall</code>目标从您的机器上删除二进制文件和库。</p><p id="335f" class="pw-post-body-paragraph kj kk iq kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated"><strong class="kl ir">清除:</strong><br/><code class="fe jn jo jp jq b">clean</code>目标清除任何由<code class="fe jn jo jp jq b">build</code>步骤创建的工件。</p><p id="0bc9" class="pw-post-body-paragraph kj kk iq kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated"><strong class="kl ir">。假的<br/> </strong>这定义了一个不是文件的目标列表(据我所知<code class="fe jn jo jp jq b">make</code>实际上是关于创建文件的，所以我们需要确保它不会被我们所写的内容所混淆——更多关于那个<a class="ae oe" href="https://www.gnu.org/software/make/manual/html_node/Phony-Targets.html" rel="noopener ugc nofollow" target="_blank">在这里</a>)。</p><h2 id="11ca" class="ns mk iq bd ml nt nu dn mp nv nw dp mt ks nx ny mv kw nz oa mx la ob oc mz od bi translated">🍺自制配方</h2><p id="2d7a" class="pw-post-body-paragraph kj kk iq kl b km nb jv ko kp nc jy kr ks nd ku kv kw ne ky kz la nf lc ld le ij bi translated"><code class="fe jn jo jp jq b">brew</code>命令读取一个“公式”,该公式定义了安装命令需要做的事情。<code class="fe jn jo jp jq b">xcgrapher</code>的公式看起来是这样的:</p><pre class="lu lv lw lx gt of jq og oh aw oi bi"><span id="4b8b" class="ns mk iq jq b gy oj ok l ol om">class Xcgrapher &lt; Formula<br/>  desc "Framework-level dependency graph generator for Xcode projects "<br/>  homepage "https://github.com/maxchuquimia/xcgrapher"<br/>  url "https://github.com/maxchuquimia/xcgrapher.git",<br/>      :tag =&gt; "0.0.8", :revision =&gt; "d5b410f1f42bb95ce51453da539834d3678d85a4"<br/>  head "https://github.com/maxchuquimia/xcgrapher.git"<br/><br/>  depends_on :xcode =&gt; ["12.4", :build]<br/>  depends_on "graphviz"<br/><br/>  def install<br/>    system "make", "install", "prefix=#{prefix}"<br/>  end<br/><br/>end</span></pre><p id="9fed" class="pw-post-body-paragraph kj kk iq kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">首先，定义关于源代码和版本的信息。然后<code class="fe jn jo jp jq b">depends_on</code>确保Xcode存在，并在必要时安装<code class="fe jn jo jp jq b">graphviz</code>(记住，<code class="fe jn jo jp jq b">xcgrapher</code>需要GraphViz' <code class="fe jn jo jp jq b">dot</code>命令)。然后<code class="fe jn jo jp jq b">install</code>函数在项目克隆的目录中调用<code class="fe jn jo jp jq b">make install</code>。</p><p id="2266" class="pw-post-body-paragraph kj kk iq kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">正如本文前面提到的，<code class="fe jn jo jp jq b">prefix=#{prefix}</code>是Makefile中的<code class="fe jn jo jp jq b">prefix</code>变量被覆盖的地方。通过使用公式的前缀而不是我们在Makefile中编写的常量<code class="fe jn jo jp jq b">/usr/local</code>,我们允许Homebrew优雅地管理安装。在我的例子中<code class="fe jn jo jp jq b">prefix</code>变成了<code class="fe jn jo jp jq b">/usr/local/Cellar/xcgrapher/0.0.8</code>。不过不用担心，brew象征性地将所有东西都链接到了<code class="fe jn jo jp jq b">/usr/local </code>(这就是为什么我可以在前面的例子中使用<code class="fe jn jo jp jq b">/usr/local/bin/xcgrapher</code>)。</p><p id="36dc" class="pw-post-body-paragraph kj kk iq kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated"><code class="fe jn jo jp jq b">xcgrapher</code>的公式发表在<a class="ae oe" href="https://github.com/maxchuquimia/homebrew-scripts" rel="noopener ugc nofollow" target="_blank">我的tap </a>。最简单的定制tap是以你的名字命名的GitHub repo，名为<code class="fe jn jo jp jq b">hombrew-scripts</code>，公式存储在<code class="fe jn jo jp jq b">Formula</code>目录中。当然，在某些情况下，它会变得更加复杂:在这里<a class="ae oe" href="https://github.com/Homebrew/brew/blob/master/docs/How-to-Create-and-Maintain-a-Tap.md" rel="noopener ugc nofollow" target="_blank">阅读全部内容</a>。</p></div><div class="ab cl ng nh hu ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="ij ik il im in"><h1 id="0947" class="mj mk iq bd ml mm nn mo mp mq no ms mt ka np kb mv kd nq ke mx kg nr kh mz na bi translated">dlclose(本文)</h1><p id="2017" class="pw-post-body-paragraph kj kk iq kl b km nb jv ko kp nc jy kr ks nd ku kv kw ne ky kz la nf lc ld le ij bi translated">感谢您读到这里！我希望<code class="fe jn jo jp jq b">xcgrapher</code>在某些方面对你有用，即使它只是一个完全不同的东西的起点。</p><div class="oo op gp gr oq or"><a href="https://github.com/maxchuquimia/xcgrapher" rel="noopener  ugc nofollow" target="_blank"><div class="os ab fo"><div class="ot ab ou cl cj ov"><h2 class="bd ir gy z fp ow fr fs ox fu fw ip bi translated">maxchuquimia/xcgrapher</h2><div class="oy l"><h3 class="bd b gy z fp ow fr fs ox fu fw dk translated">默认情况下，xcgrapher是Xcode项目的框架级依赖图生成器。它通过读取本地…</h3></div><div class="oz l"><p class="bd b dl z fp ow fr fs ox fu fw dk translated">github.com</p></div></div><div class="pa l"><div class="po l pc pd pe pa pf md or"/></div></div></a></div><p id="8180" class="pw-post-body-paragraph kj kk iq kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">我会把<code class="fe jn jo jp jq b">xcgrapher --help</code>留给你——但是现在，晚安:)</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi pp"><img src="../Images/32b21a2dc9c252ac114f018693f16305.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kCAYl251pFaNaKheSbAN3A.png"/></div></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">制图快乐！</figcaption></figure></div></div>    
</body>
</html>