<html>
<head>
<title>Exploring web APIs Observers — real life examples explained!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">探索web APIs观察者——解释真实生活中的例子！</h1>
<blockquote>原文：<a href="https://itnext.io/exploring-web-apis-observers-real-life-examples-explained-ed194477314?source=collection_archive---------5-----------------------#2019-10-21">https://itnext.io/exploring-web-apis-observers-real-life-examples-explained-ed194477314?source=collection_archive---------5-----------------------#2019-10-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/eb40b43f818633332453152ef565efc0.png" data-original-src="https://miro.medium.com/v2/resize:fit:828/format:webp/1*-40mHdj_z0elvJzqNFukUw.png"/></div></figure><p id="dd6a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果你喜欢一头扎进<a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/API" rel="noopener ugc nofollow" target="_blank"> mdn </a>的话，你很可能认识一些以“观察者”结尾的web APIs。</p><p id="59e4" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这些观察器是相对较新的web APIs(除了变异观察器之外)，<strong class="jw ir">它们中的一些并不被所有的浏览器</strong>支持，通常用于<strong class="jw ir">观察<strong class="jw ir">目标元素</strong>的某个状态</strong>，并在检测到该状态时采取行动(通过运行观察回调)，一些解决了web传统的知道何时发生变化的方法(例如，元素/树的变化，元素在视口中的可见性等)..)由于<a class="ae ks" href="https://gist.github.com/paulirish/5d52fb081b3570c81e3a" rel="noopener ugc nofollow" target="_blank">计算</a>会影响性能(例如，通过触发回流/重绘)，因此成本可能很高。</p><h2 id="832b" class="kt ku iq bd kv kw kx dn ky kz la dp lb kf lc ld le kj lf lg lh kn li lj lk ll bi translated">不同观察者共享的相似性/惯例:</h2><p id="c9cf" class="pw-post-body-paragraph ju jv iq jw b jx lm jz ka kb ln kd ke kf lo kh ki kj lp kl km kn lq kp kq kr ij bi translated">所有都以相同的方式构造——构造函数排除观察回调，并返回观察器的实例，以便在需要时开始观察。都有"<strong class="jw ir"> observe() </strong>"和"<strong class="jw ir"> disconnect() </strong>"方法，但是它们不共享同一个接口，各自实现自己的接口。</p><h2 id="8188" class="kt ku iq bd kv kw kx dn ky kz la dp lb kf lc ld le kj lf lg lh kn li lj lk ll bi translated">基于W3C/标准规范的快速概述:</h2><figure class="ls lt lu lv gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi lr"><img src="../Images/f286be2a1515b639d9ae0045d223b2e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RQCKBjKDHaOP2QWMMACjpg.png"/></div></div></figure><h1 id="07f5" class="ma ku iq bd kv mb mc md ky me mf mg lb mh mi mj le mk ml mm lh mn mo mp lk mq bi translated">交叉观测器</h1><p id="45d6" class="pw-post-body-paragraph ju jv iq jw b jx lm jz ka kb ln kd ke kf lo kh ki kj lp kl km kn lq kp kq kr ij bi translated">理解元素(HTML/SVG)相对于其宿主元素(或顶级根)的<strong class="jw ir">可见性的现代异步方式。</strong></p><p id="8dc4" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">mdn中提到的常见使用案例:</p><ul class=""><li id="a00a" class="mr ms iq jw b jx jy kb kc kf mt kj mu kn mv kr mw mx my mz bi translated">页面滚动时图像或其他内容的延迟加载。</li><li id="c6ce" class="mr ms iq jw b jx na kb nb kf nc kj nd kn ne kr mw mx my mz bi translated">实现“无限滚动”网站，当你滚动的时候，越来越多的内容被加载和呈现，这样用户就不需要翻页了。</li><li id="32e4" class="mr ms iq jw b jx na kb nb kf nc kj nd kn ne kr mw mx my mz bi translated">报告广告的可见性，以便计算广告收入。</li><li id="361e" class="mr ms iq jw b jx na kb nb kf nc kj nd kn ne kr mw mx my mz bi translated">根据用户是否会看到结果来决定是否执行任务或动画过程。</li></ul><p id="fcb8" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">以下是我在一个用于加载和播放特效动画的角度库上使用它的方法。(<a class="ae ks" href="https://github.com/Sentinel-One/lottie" rel="noopener ugc nofollow" target="_blank">一个洛蒂网包装器</a></p><pre class="ls lt lu lv gt nf ng nh ni aw nj bi"><span id="b70a" class="kt ku iq ng b gy nk nl l nm nn"><strong class="ng ir">private </strong>playAnimationOnlyWhenElementAppears() {<br/>  <strong class="ng ir">if </strong>(!(<strong class="ng ir">'IntersectionObserver' in <em class="no">window</em></strong>)) {<br/>    <strong class="ng ir">return</strong>;<br/>  }<br/>  <strong class="ng ir">if </strong>(<strong class="ng ir">this</strong>.<strong class="ng ir">options</strong>.<strong class="ng ir">loop</strong>) {<br/>    <strong class="ng ir">this</strong>.<strong class="ng ir">observer </strong>= <strong class="ng ir">new <em class="no">IntersectionObserver</em></strong>((entries) =&gt; {<br/>      <strong class="ng ir">for </strong>(<strong class="ng ir">const </strong>entry <strong class="ng ir">of </strong>entries) {<br/>        <strong class="ng ir">if </strong>(entry.<strong class="ng ir">intersectionRatio </strong>!== 0) {<br/>          <strong class="ng ir">this</strong>.<strong class="ng ir">animationInstance</strong>.play();<br/>        } <strong class="ng ir">else </strong>{<br/>          <strong class="ng ir">this</strong>.<strong class="ng ir">animationInstance</strong>.pause();<br/>        }<br/>      }<br/>    });<br/>    <strong class="ng ir">this</strong>.<strong class="ng ir">observer</strong>.observe(<strong class="ng ir">this</strong>.<strong class="ng ir">lottieContainer</strong>.<strong class="ng ir">nativeElement</strong>);<br/>  }<br/>}</span><span id="7681" class="kt ku iq ng b gy np nl l nm nn">ngOnDestroy(): <strong class="ng ir">void </strong>{<br/>  <strong class="ng ir">this</strong>.<strong class="ng ir">animationInstance </strong>&amp;&amp; <strong class="ng ir">this</strong>.<strong class="ng ir">animationInstance</strong>.destroy();<br/>  <strong class="ng ir">this</strong>.<strong class="ng ir">observer </strong>&amp;&amp; <strong class="ng ir">this</strong>.<strong class="ng ir">observer</strong>.disconnect();<br/>}</span></pre><p id="a0a6" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">**仅供参考，如果您熟悉Angular，您可能知道它使用zone.js修补了一些web API，因此它可以拦截异步操作并触发对它的更改检测，Angular还修补了<strong class="jw ir"> IntersectionObserver </strong>。</p><h1 id="b443" class="ma ku iq bd kv mb mc md ky me mf mg lb mh mi mj le mk ml mm lh mn mo mp lk mq bi translated">突变观察者</h1><p id="b8e0" class="pw-post-body-paragraph ju jv iq jw b jx lm jz ka kb ln kd ke kf lo kh ki kj lp kl km kn lq kp kq kr ij bi translated">让我们观察对<a class="ae ks" href="https://developer.mozilla.org/en-US/docs/DOM" rel="noopener ugc nofollow" target="_blank"> DOM </a>树所做的改变，DOM突变将被报告给观察者的<code class="fe nq nr ns ng b">callback.</code></p><p id="af1a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">用户可以指定他想要向回调报告哪些变更(类型为<code class="fe nq nr ns ng b"><strong class="jw ir">MutationObserverInit) </strong>e.g. childList</code>、<code class="fe nq nr ns ng b">attributes</code>和/或<code class="fe nq nr ns ng b">characterData.</code>)</p><p id="7d5c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">下面是<a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver" rel="noopener ugc nofollow" target="_blank"> <strong class="jw ir"> <em class="no">变异观察器</em></strong></a><strong class="jw ir"><em class="no"/></strong>在<a class="ae ks" href="https://github.com/microsoft/vscode/blob/6cc1cdba5b6a9c391275e357b82cc208fff034d2/src/vs/workbench/contrib/terminal/browser/terminalWidgetManager.ts#L36" rel="noopener ugc nofollow" target="_blank"> vscode编辑器</a>中的使用方法:</p><pre class="ls lt lu lv gt nf ng nh ni aw nj bi"><span id="1376" class="kt ku iq ng b gy nk nl l nm nn"><strong class="ng ir">private </strong>_initTerminalHeightWatcher(terminalWrapper: <strong class="ng ir"><em class="no">HTMLElement</em></strong>) {<br/>  <em class="no">// Watch the xterm.js viewport for style changes and do a layout if it changes<br/>  </em><strong class="ng ir">this</strong>.<strong class="ng ir">_xtermViewport </strong>= &lt;HTMLElement&gt;terminalWrapper.querySelector(<strong class="ng ir">'.xterm-viewport'</strong>);<br/>  <strong class="ng ir">if </strong>(!<strong class="ng ir">this</strong>._xtermViewport) {<br/>    <strong class="ng ir">return</strong>;<br/>  }<br/>  <strong class="ng ir">const </strong>mutationObserver = <strong class="ng ir">new <em class="no">MutationObserver</em></strong>(() =&gt; <strong class="ng ir">this</strong>._refreshHeight());<br/>  mutationObserver.observe(<strong class="ng ir">this</strong>._xtermViewport, { <strong class="ng ir">attributes</strong>: <strong class="ng ir">true</strong>, <strong class="ng ir">attributeFilter</strong>: [<strong class="ng ir">'style'</strong>] });<br/>}</span></pre><ul class=""><li id="ea67" class="mr ms iq jw b jx jy kb kc kf mt kj mu kn mv kr mw mx my mz bi translated">分配<strong class="jw ir">的结果。xterm-viewport </strong>元素查询to _xtermViewport。</li><li id="bcaa" class="mr ms iq jw b jx na kb nb kf nc kj nd kn ne kr mw mx my mz bi translated">实例化一个新的mutationObserver，向其传递_refreshHeight()回调。</li><li id="1cbd" class="mr ms iq jw b jx na kb nb kf nc kj nd kn ne kr mw mx my mz bi translated">调用mutationObserver.observe()方法，将_xtermViewport作为更改的目标，并将option对象配置为观察属性更改，特别是监视“style”属性。</li></ul><p id="3553" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">所以基本上当_xtermViewport.style发生变化时，就会调用_refreshHeight()。请注意，本例中的实例只能在该函数中引用，因此实际上观察者总是观察变化，不需要断开它(基本清理..).</p><h1 id="f840" class="ma ku iq bd kv mb mc md ky me mf mg lb mh mi mj le mk ml mm lh mn mo mp lk mq bi translated">resize观察者</h1><p id="cb18" class="pw-post-body-paragraph ju jv iq jw b jx lm jz ka kb ln kd ke kf lo kh ki kj lp kl km kn lq kp kq kr ij bi translated">用于观察元素大小变化的API。</p><blockquote class="nt nu nv"><p id="a567" class="ju jv no jw b jx jy jz ka kb kc kd ke nw kg kh ki nx kk kl km ny ko kp kq kr ij bi translated">ResizeObserver可以观察不同种类的CSS大小:</p><p id="2e7b" class="ju jv no jw b jx jy jz ka kb kc kd ke nw kg kh ki nx kk kl km ny ko kp kq kr ij bi translated"><code class="fe nq nr ns ng b"><a class="ae ks" href="https://drafts.csswg.org/resize-observer/#dom-resizeobserverboxoptions-border-box" rel="noopener ugc nofollow" target="_blank">border-box</a></code>:CSS2中定义的<a class="ae ks" href="https://www.w3.org/TR/CSS21/box.html#box-border-area" rel="noopener ugc nofollow" target="_blank">框边界区域</a>的大小。</p><p id="569b" class="ju jv no jw b jx jy jz ka kb kc kd ke nw kg kh ki nx kk kl km ny ko kp kq kr ij bi translated"><code class="fe nq nr ns ng b"><a class="ae ks" href="https://drafts.csswg.org/resize-observer/#dom-resizeobserverboxoptions-content-box" rel="noopener ugc nofollow" target="_blank">content-box</a></code>:CSS2中定义的<a class="ae ks" href="https://drafts.csswg.org/css-box-3/#content-area" rel="noopener ugc nofollow" target="_blank">内容区</a>的大小。</p></blockquote><p id="6f9f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">与其他观察器类似，resize也由接受观察<strong class="jw ir">回调</strong>的构成。用<a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver" rel="noopener ugc nofollow" target="_blank"> resizeObserver </a>。observe(target)方法我们可以开始跟踪目标的尺寸变化。</p><p id="aaf8" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">因为它还在草案中，并不是所有的浏览器都支持它，所以我看过的开源项目的“ToDo”注释或自述文件中经常提到它。</p><p id="d4c6" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">一个以很酷的方式使用resizeObserver来检测组件调整大小的项目的例子是:<a class="ae ks" href="https://github.com/maslianok/react-resize-detector" rel="noopener ugc nofollow" target="_blank"> react-resize-detector </a>，它公开了一个将被用作客户端组件宿主的组件，用户应该将检测到调整大小时运行的回调传递给它:</p><pre class="ls lt lu lv gt nf ng nh ni aw nj bi"><span id="091f" class="kt ku iq ng b gy nk nl l nm nn"><strong class="ng ir">const </strong>handle = getHandle(refreshMode);<br/><strong class="ng ir">this</strong>.<strong class="ng ir">resizeHandler </strong>= handle<br/>  ? handle(<strong class="ng ir">this</strong>.createResizeHandler, refreshRate, refreshOptions)<br/>  : <strong class="ng ir">this</strong>.createResizeHandler;<br/><br/><strong class="ng ir">this</strong>.<strong class="ng ir">resizeObserver </strong>= <strong class="ng ir">new </strong>ResizeObserver(<strong class="ng ir">this</strong>.resizeHandler);</span></pre><ul class=""><li id="d892" class="mr ms iq jw b jx jy kb kc kf mt kj mu kn mv kr mw mx my mz bi translated">将resizeObserver分配给一个新实例，传递一个处理程序</li></ul><pre class="ls lt lu lv gt nf ng nh ni aw nj bi"><span id="b76b" class="kt ku iq ng b gy nk nl l nm nn">toggleObserver = type =&gt; {<br/>  <strong class="ng ir">const </strong>element = <strong class="ng ir">this</strong>.getElement();<br/>  <strong class="ng ir">if </strong>(!element || !<strong class="ng ir">this</strong>.resizeObserver[type]) <strong class="ng ir">return</strong>;<br/><br/>  <strong class="ng ir">this</strong>.resizeObserver[type](element);<br/>};</span></pre><ul class=""><li id="7e8f" class="mr ms iq jw b jx jy kb kc kf mt kj mu kn mv kr mw mx my mz bi translated">ToggleObserver()用于在元素存在时开始和停止观察元素。</li></ul><pre class="ls lt lu lv gt nf ng nh ni aw nj bi"><span id="b9cd" class="kt ku iq ng b gy nk nl l nm nn">componentDidMount() {<br/>  <strong class="ng ir">this</strong>.toggleObserver(<strong class="ng ir">'observe'</strong>);<br/>}<br/><br/>componentWillUnmount() {<br/>  <strong class="ng ir">this</strong>.toggleObserver(<strong class="ng ir">'unobserve'</strong>);<br/><br/>  <strong class="ng ir">this</strong>.rafClean();<br/><br/>  <strong class="ng ir">this</strong>.cancelHandler();<br/><br/>  <strong class="ng ir">this</strong>.<strong class="ng ir">unmounted </strong>= <strong class="ng ir">true</strong>;<br/>}</span></pre><ul class=""><li id="1717" class="mr ms iq jw b jx jy kb kc kf mt kj mu kn mv kr mw mx my mz bi translated">观察器将在组件启动时开始观察变化，并在组件终止时暂停观察。</li></ul><h1 id="926c" class="ma ku iq bd kv mb mc md ky me mf mg lb mh mi mj le mk ml mm lh mn mo mp lk mq bi translated">性能观察者</h1><blockquote class="nt nu nv"><p id="b31d" class="ju jv no jw b jx jy jz ka kb kc kd ke nw kg kh ki nx kk kl km ny ko kp kq kr ij bi translated"><code class="fe nq nr ns ng b"><strong class="jw ir">PerformanceObserver</strong></code>界面用于<em class="iq">观察</em>性能测量事件，并在新的<a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/API/PerformanceEntry" rel="noopener ugc nofollow" target="_blank">性能条目</a>记录在浏览器的<em class="iq">性能时间线</em>中时得到通知</p></blockquote><p id="3c42" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/API/PerformanceObserver" rel="noopener ugc nofollow" target="_blank"> performanceObserver </a>的不同之处在于，我们不会使用它来帮助开发更好的“产品智能”UI组件，它将在UI逻辑的“外部”使用，以监控/测试/测量性能指标来改进我们的应用程序，我们可能希望通过发送到分析工具(如google analytics)来实时跟踪这些指标，就像这篇<a class="ae ks" href="https://developers.google.com/web/fundamentals/performance/user-centric-performance-metrics" rel="noopener ugc nofollow" target="_blank">帖子</a>中所建议的那样。</p><pre class="ls lt lu lv gt nf ng nh ni aw nj bi"><span id="4ed6" class="kt ku iq ng b gy nk nl l nm nn"><strong class="ng ir">const </strong>observer = <strong class="ng ir">new <em class="no">PerformanceObserver</em></strong>((list) =&gt; {<br/>  <strong class="ng ir">for </strong>(<strong class="ng ir">const </strong>entry <strong class="ng ir">of </strong>list.getEntries()) {<br/>    <em class="no">// `entry` is a PerformanceEntry instance.<br/>    </em><strong class="ng ir"><em class="no">console</em></strong>.log(entry.<strong class="ng ir">entryType</strong>);<br/>    <strong class="ng ir"><em class="no">console</em></strong>.log(entry.<strong class="ng ir">startTime</strong>); <em class="no">// DOMHighResTimeStamp<br/>    </em><strong class="ng ir"><em class="no">console</em></strong>.log(entry.<strong class="ng ir">duration</strong>); <em class="no">// DOMHighResTimeStamp<br/>  </em>}<br/>});<br/><br/><em class="no">// Start observing the entry types you care about.<br/></em>observer.observe({<strong class="ng ir">entryTypes</strong>: [<strong class="ng ir">'resource'</strong>, <strong class="ng ir">'paint'</strong>]});</span></pre><ul class=""><li id="04fc" class="mr ms iq jw b jx jy kb kc kf mt kj mu kn mv kr mw mx my mz bi translated">在上面的代码片段中，我们可以看到observer的用法与其他类似，不同之处在于没有元素目标，而是我们观察<code class="fe nq nr ns ng b"><a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/API/PerformanceEntry" rel="noopener ugc nofollow" target="_blank"><strong class="jw ir">PerformanceEnties</strong></a><strong class="jw ir">.</strong></code></li></ul><pre class="ls lt lu lv gt nf ng nh ni aw nj bi"><span id="18c0" class="kt ku iq ng b gy nk nl l nm nn"><strong class="ng ir">const </strong>observer = <strong class="ng ir">new <em class="no">PerformanceObserver</em></strong>((list) =&gt; {<br/>  <strong class="ng ir">for </strong>(<strong class="ng ir">const </strong>entry <strong class="ng ir">of </strong>list.getEntries()) {<br/>    ga(<strong class="ng ir">'send'</strong>, <strong class="ng ir">'event'</strong>, {<br/>      <strong class="ng ir">eventCategory</strong>: <strong class="ng ir">'Performance Metrics'</strong>,<br/>      <strong class="ng ir">eventAction</strong>: <strong class="ng ir">'longtask'</strong>,<br/>      <strong class="ng ir">eventValue</strong>: <strong class="ng ir"><em class="no">Math</em></strong>.round(entry.<strong class="ng ir">startTime </strong>+ entry.<strong class="ng ir">duration</strong>),<br/>      <strong class="ng ir">eventLabel</strong>: <strong class="ng ir"><em class="no">JSON</em></strong>.stringify(entry.attribution),<br/>    });<br/>  }<br/>});<br/><br/>observer.observe({<strong class="ng ir">entryTypes</strong>: [<strong class="ng ir">'longtask'</strong>]});</span></pre><ul class=""><li id="c4cb" class="mr ms iq jw b jx jy kb kc kf mt kj mu kn mv kr mw mx my mz bi translated">在上面的代码片段中，我们看到了一个检测longtask并将其报告给分析工具的尝试，<a class="ae ks" href="https://w3c.github.io/longtasks/#sec-TaskAttributionTiming" rel="noopener ugc nofollow" target="_blank">entry . attribute</a>将告诉我们哪个帧上下文负责长任务(“<code class="fe nq nr ns ng b">iframe</code>”、“<code class="fe nq nr ns ng b">embed</code>”或“<code class="fe nq nr ns ng b">object</code>”)。</li></ul><p id="8d94" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">就这样，我希望你喜欢这篇文章，</p><p id="fd33" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">欢迎大家分享，并在stackblitz:)或<a class="ae ks" href="https://github.com/LironHazan/dom-apis-typed/blob/master/dom-observers-apis/combined-observers.ts" rel="noopener ugc nofollow" target="_blank"> git repo </a>中玩转以下可运行的例子。</p><p id="d5ec" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">干杯，勒荣。</p><figure class="ls lt lu lv gt jr"><div class="bz fp l di"><div class="nz oa l"/></div></figure></div></div>    
</body>
</html>