<html>
<head>
<title>Differences between WebSockets and Socket.IO</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">WebSockets和Socket的区别。超正析象管(Image Orthicon)</h1>
<blockquote>原文：<a href="https://itnext.io/differences-between-websockets-and-socket-io-a9e5fa29d3dc?source=collection_archive---------0-----------------------#2021-05-10">https://itnext.io/differences-between-websockets-and-socket-io-a9e5fa29d3dc?source=collection_archive---------0-----------------------#2021-05-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="4978" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">WebSockets和Socket。IO可能是现代网络中实现实时通信的两种最流行的解决方案。但是它们有什么不同呢？</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/04dc2823b050f317cfd001079fb4d53c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WhygUke4VhWyLnqgVXXRrw.png"/></div></div></figure><p id="1081" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在构建实时应用程序时，有时您必须选择如何实现客户机和服务器之间的实时数据交换。WebSockets和Socket。IO可能是现代网络中实现实时通信的两种最流行的解决方案。但是我们应该选择哪一个呢？这两种技术有什么区别？让我们来了解一下！</p><h1 id="09da" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">WebSockets</h1><p id="4633" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">当谈到WebSockets时，我们指的是通过单一TCP连接提供全双工通信通道的web通信协议。简而言之，它允许客户机和服务器之间以最小的开销进行交互，允许我们构建利用实时通信优势的应用程序。</p><p id="ca63" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如，想象一下如果你正在构建一个聊天应用程序:你需要尽快地接收和发送数据，对吗？嗯，这是WebSockets的正确工作！您可以打开一个TCP连接并共享数据，只要您需要，就让它保持打开状态。</p><p id="8241" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">WebSockets最早出现在2010年的Google Chrome 4中，第一个RFC ( <a class="ae md" href="https://tools.ietf.org/html/rfc6455" rel="noopener ugc nofollow" target="_blank"> RFC 6455 </a>)已经在一年后的2011年发布。</p><p id="9b7a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">WebSockets的优秀用例包括:</p><ul class=""><li id="6d39" class="me mf it js b jt ju jx jy kb mg kf mh kj mi kn mj mk ml mm bi translated">聊天应用程序</li><li id="2062" class="me mf it js b jt mn jx mo kb mp kf mq kj mr kn mj mk ml mm bi translated">多人游戏</li><li id="3231" class="me mf it js b jt mn jx mo kb mp kf mq kj mr kn mj mk ml mm bi translated">协作编辑</li><li id="e8c5" class="me mf it js b jt mn jx mo kb mp kf mq kj mr kn mj mk ml mm bi translated">社交订阅源</li><li id="538b" class="me mf it js b jt mn jx mo kb mp kf mq kj mr kn mj mk ml mm bi translated">基于位置的应用</li></ul><p id="c5c5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">还有很多。</p><h1 id="371a" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">插座。超正析象管(Image Orthicon)</h1><p id="1e35" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">插座。IO是建立在WebSocket…和其他技术之上的JavaScript库。事实上，它在可用的时候使用WebSockets，但是它也准备使用其他技术，比如Flash Socket、AJAX Long Polling、AJAX Multipart Stream等等；允许插座。在不支持WebSockets的上下文中使用IO。Ably博客中有一篇<a class="ae md" href="https://www.ably.io/concepts/socketio" rel="noopener ugc nofollow" target="_blank">的精彩文章，深入描述了它的特点。</a></p><h1 id="f268" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">WebSocket和Socket的区别。超正析象管(Image Orthicon)</h1><p id="ba8d" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">插座的主要优点。web套接字上的IO有:</p><ul class=""><li id="287a" class="me mf it js b jt ju jx jy kb mg kf mh kj mi kn mj mk ml mm bi translated">不像WebSocket，Socket。IO允许您向所有连接的客户端广播消息。例如，如果您正在编写一个聊天应用程序，并且希望通知所有连接的客户端有一个新用户加入了聊天，那么您可以很容易地将该消息一次性广播给所有人。使用普通WebSocket，您需要一个所有连接的客户端的列表，然后直接一个接一个地发送消息。</li><li id="50d2" class="me mf it js b jt mn jx mo kb mp kf mq kj mr kn mj mk ml mm bi translated">代理和负载平衡器使得WebSockets难以实现和扩展。插座。IO支持这些现成的技术。</li><li id="e842" class="me mf it js b jt mn jx mo kb mp kf mq kj mr kn mj mk ml mm bi translated">之前说了，插座。当客户端不支持时，IO可以回退到WebSockets之外的技术。</li><li id="e0c0" class="me mf it js b jt mn jx mo kb mp kf mq kj mr kn mj mk ml mm bi translated">如果(由于某种原因)WebSocket连接断开，它不会自动重新连接…但是猜猜会发生什么？插座。木卫一为你处理！</li><li id="2237" class="me mf it js b jt mn jx mo kb mp kf mq kj mr kn mj mk ml mm bi translated">插座。IO APIs是为了更容易使用而构建的。</li></ul><p id="8303" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以，看来那个插座。木卫一有点像“实时通信的天堂”，对吗？实际上，使用普通WebSockets有一些很好的理由。</p><p id="1aa4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，现在所有的现代浏览器都支持WebSockets。插座。IO使用了更多的样板代码和资源来使它退回到其他技术。大多数时候，你不需要这种程度的支持。甚至在网络流量方面，Socket。IO要贵得多。事实上，对于普通的WebSockets，浏览器可能只需要运行两个请求:</p><ul class=""><li id="8e5b" class="me mf it js b jt ju jx jy kb mg kf mh kj mi kn mj mk ml mm bi translated">对HTML页面的<code class="fe ms mt mu mv b">GET</code>请求</li><li id="57a2" class="me mf it js b jt mn jx mo kb mp kf mq kj mr kn mj mk ml mm bi translated">到WebSocket的<code class="fe ms mt mu mv b">UPGRADE</code>连接</li></ul><p id="664c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">仅此而已。您已经准备好开始与服务器进行实时通信了！但是插座呢。木卫一？</p><ul class=""><li id="9e05" class="me mf it js b jt ju jx jy kb mg kf mh kj mi kn mj mk ml mm bi translated">HTML页面的<code class="fe ms mt mu mv b">GET</code>请求</li><li id="5291" class="me mf it js b jt mn jx mo kb mp kf mq kj mr kn mj mk ml mm bi translated">插座。IO客户端库(<a class="ae md" href="https://bundlephobia.com/result?p=socket.io@2.3.0" rel="noopener ugc nofollow" target="_blank"> 207kb </a>)</li><li id="d314" class="me mf it js b jt mn jx mo kb mp kf mq kj mr kn mj mk ml mm bi translated">三个长轮询Ajax请求</li><li id="a209" class="me mf it js b jt mn jx mo kb mp kf mq kj mr kn mj mk ml mm bi translated">与WebSocket的<code class="fe ms mt mu mv b">UPGRADE</code>连接</li></ul><p id="1c5b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这个世界上，我们使用许多JavaScript代码，库也在大幅减轻它们的重量……207 kb太多了！那么所有这些请求呢？真是浪费网络流量！</p><p id="5f92" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">甚至有一个名为<code class="fe ms mt mu mv b">websocket-vs-socket.io</code>的<code class="fe ms mt mu mv b">npm</code>包(见这里的<a class="ae md" href="https://www.npmjs.com/package/websocket-vs-socket.io" rel="noopener ugc nofollow" target="_blank"/>)被用来比较这两种技术的网络流量:</p><p id="177d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">WebSocket网络流量:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mw"><img src="../Images/2abe0f4b589dea761a6383d031ad0d3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FM149H85RmSKcGqZwzrA0A.png"/></div></div></figure><p id="1c62" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">插座。IO网络流量:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mw"><img src="../Images/ff972b5402be9b6b292d2bfc66d5ab97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wBX_hNNxNeVGVIHJKeXQLA.png"/></div></div></figure><p id="b4b3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">多么巨大的差异啊！</p><h1 id="e72f" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">编写实时代码</h1><p id="3b89" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">到目前为止，我们只是在纸上看到了一些差异，但在编写实时应用程序时，它们有什么不同呢？</p><p id="3e41" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">简单的WebSocket服务器在下面的Node.js程序中，我们创建了一个暴露在端口<code class="fe ms mt mu mv b">3001</code>上的WebSocket服务器。每次客户端连接时，我们都会为其会话分配一个唯一的ID。当客户端发送消息时，我们将用下面的格式回复:<code class="fe ms mt mu mv b">[&lt;client-id&gt;]: &lt;message&gt;</code>这样他就知道消息已经成功发送了。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="2130" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">太好了！但是，如果我想将该消息广播给每个连接的客户端，该怎么办呢？WebSockets默认不支持消息广播！没错，但是消息广播仍然很容易用普通的WebSockets实现:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="8bfc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如此简单！如您所见，<code class="fe ms mt mu mv b">WebSocket.Server</code>跟踪每一个连接的客户端，因此我们可以循环访问它们并向每个人发送所需的消息！我们刚刚实现了有史以来最简单的聊天服务器！你可以用任何WebSocket客户端测试上面的代码，无论是在<a class="ae md" href="https://websocket-client.com/" rel="noopener ugc nofollow" target="_blank">桌面</a>上还是通过<a class="ae md" href="https://chrome.google.com/webstore/detail/browser-websocket-client/mdmlhchldhfnfnkfmljgeinlffmdgkjo" rel="noopener ugc nofollow" target="_blank"> Chrome扩展</a>。</p><p id="7fe4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">简单插座。IO服务器好了，这简直太容易了！但是插座。IO承诺让它变得更简单！我们应该如何用那个库实现同一个服务器？</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="24c7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">哇！将近一半的WebSocket服务器代码！如你所见，有了插座。IO native <code class="fe ms mt mu mv b">broadcast</code>方法，我们不会将消息发送回发送方；出于这个原因，我们需要手动将该消息发送给客户端。</p><p id="1464" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是有一个问题:你不能在一个标准的WebSocket客户端上测试它(正如我们在前面的例子中看到的)。那是因为(之前说过)，Socket。IO不使用普通的WebSockets，而是混合多种技术来支持尽可能多的客户端(并避免某些问题，如上所述)。那么如何测试它呢？</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="bcd7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你需要使用插座。IO客户端。在上面的例子中，我们使用了一个CDN交付的客户端，它允许我们在一个网络浏览器上进行一些快速和肮脏的测试。</p><p id="c99f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">正如你所看到的，这两个例子可能看起来没有什么不同…但是当谈到兼容性时，你必须记住这个插座。IO将始终使用它自己的客户端库，所以除了web开发之外，您将无法使用它。这对于WebSockets来说是不正确的，web sockets可以用来解决大量的问题，例如p2p通信、实时服务器到服务器的数据传输等等。</p><h1 id="d033" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">要记住的事情</h1><p id="b9d0" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">正如我们在开头已经看到的，有许多问题需要解决。木卫一试图解决。</p><ul class=""><li id="417f" class="me mf it js b jt ju jx jy kb mg kf mh kj mi kn mj mk ml mm bi translated">水平缩放。假设您的聊天应用取得了很大成功，您需要添加另一台服务器和一个负载平衡器来处理所有请求。嗯，如果您在“<code class="fe ms mt mu mv b">server 1</code>”上打开一个连接，但是负载均衡器将您切换到“【T3”)，您将得到以下错误:“【T4”。插座。IO使用cookie解决了这个问题(或者基于它们的起始地址路由连接)，但是WebSockets没有提供现成的替代机制。</li><li id="0dca" class="me mf it js b jt mn jx mo kb mp kf mq kj mr kn mj mk ml mm bi translated">表演。正如我们之前说过的，插座。IO在普通的WebSockets传输层上提供了多个抽象层。它还将强制JSON打包，以便将真实的二进制数据从客户机发送到服务器(反之亦然)。如果您需要达到这种性能水平，您需要定制库来避免这种特定的行为。有了普通的WebSockets，你就不会有这个问题。那么，我该选择什么呢？</li></ul><p id="c42d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个问题没有简单的答案。插座。木卫一肯定会让事情变得简单一些；你不必担心与负载平衡器相关的问题、连接失败和消息广播…但是你确定你真的需要这些功能吗？只有插座。光是IO客户端库就比React，Redux，React-Redux打包在一起还重。你确定不能用浏览器原生WebSocket API吗？</p><p id="459d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">另一件要记住的事情是插座。在服务器端实现的IO是一个定制的库/框架，在大多数情况下，由于Socket应用的抽象，您并没有遵循传统的WebSocket逻辑。木卫一本身。如果你正在重构Node.js微服务(比如说)到Go、Elixir、Java或任何其他语言，你将不得不重写套接字背后的大部分逻辑。IO行为来实现与普通WebSockets相同的结果。例如，考虑用Socket向每个连接的客户机广播一条消息。IO只是一种方法(<code class="fe ms mt mu mv b">.broadcast</code>)，但是在普通的WebSockets中，你必须自己实现它，所以你必须重新思考它的工作方式。所以也许，从头开始使用vanilla WebSockets是值得的，这样会更容易用其他语言重构、扩展或实现新功能(如果你正在编写微服务/lambdas等)。).</p><p id="27ae" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">那么，你会为你的下一个实时应用选择什么呢？</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><a href="https://github.com/sponsors/micheleriva"><div class="gh gi mz"><img src="../Images/e05f00ed2cddfd2907284cb397168c3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xAIiY1uBKSNdw12oq2BbjA.png"/></div></a></figure></div></div>    
</body>
</html>