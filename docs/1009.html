<html>
<head>
<title>Understand CircuitBreaker Design pattern with simple practical example</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过简单的实例理解断路器设计模式</h1>
<blockquote>原文：<a href="https://itnext.io/understand-circuitbreaker-design-pattern-with-simple-practical-example-92a752615b42?source=collection_archive---------0-----------------------#2018-07-04">https://itnext.io/understand-circuitbreaker-design-pattern-with-simple-practical-example-92a752615b42?source=collection_archive---------0-----------------------#2018-07-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="25e2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">“当屎发生时”的设计模式</strong></p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/3deb241cf107b1dc2fd8cbddbb905da9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D0bzjo5T95kKMJx6kowwnw.jpeg"/></div></div></figure><h1 id="06f8" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">问题陈述</h1><p id="a5b5" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">我们有一个有两个API的<code class="fe ma mb mc md b">serviceA</code></p><ul class=""><li id="5ca0" class="me mf iq jp b jq jr ju jv jy mg kc mh kg mi kk mj mk ml mm bi translated"><code class="fe ma mb mc md b">/data</code>这取决于<code class="fe ma mb mc md b">serviceB</code></li><li id="5449" class="me mf iq jp b jq mn ju mo jy mp kc mq kg mr kk mj mk ml mm bi translated"><code class="fe ma mb mc md b">/data2</code>不依赖任何外部服务</li></ul><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ms"><img src="../Images/1ca95e22a58ef4737035a7808254a304.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zn5gq19i2aa4BETAabGfoQ.png"/></div></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">应用断路器模式的用例</figcaption></figure><p id="be5c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们试着实现这个场景，看看它如何影响我们的整个系统。完整的源代码可以在<a class="ae mx" href="https://github.com/abhinavdhasmana/circuitBreaker" rel="noopener ugc nofollow" target="_blank"> Github </a>上找到。</p><h1 id="96e9" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">不带断路器</h1><p id="91e5" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated"><code class="fe ma mb mc md b">serviceB</code>实现下图。API将对前5分钟的请求返回5秒的延迟响应。它运行在端口8000上。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="my mz l"/></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">服务b:模拟延迟响应</figcaption></figure><p id="6084" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe ma mb mc md b">serviceA</code>将向<code class="fe ma mb mc md b">serviceB</code>发出http请求的实现</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="my mz l"/></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">服务a:调用受影响的服务a</figcaption></figure><p id="d0d6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将使用<code class="fe ma mb mc md b"><a class="ae mx" href="https://jmeter.apache.org/" rel="noopener ugc nofollow" target="_blank">jMeter</a></code>来模拟负载。几秒钟之内，<code class="fe ma mb mc md b">serviceA</code>就会资源匮乏。所有请求都在等待http请求完成。第一个API将开始抛出错误，最终会崩溃，因为它将达到其最大堆大小。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi na"><img src="../Images/3d5b51d2e36a7356f1599e47fd92c6c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bTVshX9tURJtMMLpANfkVw.png"/></div></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">失败API的jMeter报告</figcaption></figure><pre class="km kn ko kp gt nb md nc nd aw ne bi"><span id="6cbd" class="nf ky iq md b gy ng nh l ni nj">&lt;--- Last few GCs ---&gt;</span><span id="8848" class="nf ky iq md b gy nk nh l ni nj">[90303:0x102801600]    90966 ms: Mark-sweep 1411.7 (1463.4) -&gt; 1411.3 (1447.4) MB, 1388.3 / 0.0 ms  (+ 0.0 ms in 0 steps since start of marking, biggest step 0.0 ms, walltime since start of marking 1388 ms) last resort GC in old space requested<br/>[90303:0x102801600]    92377 ms: Mark-sweep 1411.3 (1447.4) -&gt; 1411.7 (1447.4) MB, 1410.9 / 0.0 ms  last resort GC in old space requested</span><span id="c94c" class="nf ky iq md b gy nk nh l ni nj">&lt;--- JS stacktrace ---&gt;</span><span id="b405" class="nf ky iq md b gy nk nh l ni nj">==== JS stack trace =========================================</span><span id="e998" class="nf ky iq md b gy nk nh l ni nj">Security context: 0x2c271c925ee1 &lt;JSObject&gt;<br/>    1: clone [/Users/abhinavdhasmana/Documents/Personal/sourcecode/circuitBreaker/client/node_modules/hoek/lib/index.js:~20] [pc=0x10ea64e3ebcb](this=0x2c2775156bd9 &lt;Object map = 0x2c276089fe19&gt;,obj=0x2c277be1e761 &lt;WritableState map = 0x2c27608b1329&gt;,seen=0x2c2791b76f41 &lt;Map map = 0x2c272c2848d9&gt;)<br/>    2: clone [/Users/abhinavdhasmana//circuitBreaker/client/node_modul...</span></pre><p id="9919" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，不是一个，我们有两个服务不工作。这将在整个系统中升级，整个基础设施将会崩溃。</p><h1 id="56fe" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">为什么我们需要断路器</h1><p id="4bab" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">如果<code class="fe ma mb mc md b">serviceB</code>停机，<code class="fe ma mb mc md b">serviceA</code>仍应尝试恢复，并尝试执行以下操作之一:</p><ul class=""><li id="9c50" class="me mf iq jp b jq jr ju jv jy mg kc mh kg mi kk mj mk ml mm bi translated"><strong class="jp ir">自定义回退:</strong>尝试从其他来源获取相同的数据。如果不可能，使用它自己的缓存值。</li><li id="b873" class="me mf iq jp b jq mn ju mo jy mp kc mq kg mr kk mj mk ml mm bi translated"><strong class="jp ir">快速失败:</strong>如果<code class="fe ma mb mc md b">serviceA</code>知道<code class="fe ma mb mc md b">serviceB</code>宕机，等待超时消耗自身资源是没有意义的。它应该尽快返回“知道”<code class="fe ma mb mc md b">serviceB</code>已关闭</li><li id="d32a" class="me mf iq jp b jq mn ju mo jy mp kc mq kg mr kk mj mk ml mm bi translated"><strong class="jp ir">不崩溃:</strong>正如我们在这个案例中看到的，<code class="fe ma mb mc md b">serviceA</code>本不应该崩溃。</li><li id="8487" class="me mf iq jp b jq mn ju mo jy mp kc mq kg mr kk mj mk ml mm bi translated"><strong class="jp ir">自动修复:</strong>定期检查<code class="fe ma mb mc md b">serviceB</code>是否再次工作。</li><li id="8bb4" class="me mf iq jp b jq mn ju mo jy mp kc mq kg mr kk mj mk ml mm bi translated">其他API应该工作:所有其他API应该继续工作。</li></ul><h1 id="4dcf" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">什么是断路器设计？</h1><p id="fff4" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">背后的想法很简单:</p><ul class=""><li id="912b" class="me mf iq jp b jq jr ju jv jy mg kc mh kg mi kk mj mk ml mm bi translated">一旦<code class="fe ma mb mc md b">serviceA</code>“知道”<code class="fe ma mb mc md b">serviceB</code>停机，就不需要向<code class="fe ma mb mc md b">serviceB</code>提出请求。<code class="fe ma mb mc md b">serviceA </code>应尽快返回缓存数据或超时错误。这是电路的<strong class="jp ir">开路</strong>状态</li><li id="dfbc" class="me mf iq jp b jq mn ju mo jy mp kc mq kg mr kk mj mk ml mm bi translated">一旦<code class="fe ma mb mc md b">serviceA</code>知道<code class="fe ma mb mc md b">serviceB</code>到了，我们就可以<strong class="jp ir">闭合</strong>电路，以便再次向<code class="fe ma mb mc md b">serviceB</code>发出请求。</li><li id="00c1" class="me mf iq jp b jq mn ju mo jy mp kc mq kg mr kk mj mk ml mm bi translated">定期对<code class="fe ma mb mc md b">serviceB</code>进行新的调用，看看它是否成功返回结果。这种状态是<strong class="jp ir">半开</strong>。</li></ul><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ms"><img src="../Images/5a16cc9bc05604d17ad3fcf430b4a846.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_CfHNLcJMm9IGw-mv6A7Vg.png"/></div></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">断路器处于打开位置</figcaption></figure><p id="6379" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是我们电路状态图的样子</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nl"><img src="../Images/ccbe10cdf3a19a674881c236b86278a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xqXzOFOCg-a8bRcH6t1jGw.png"/></div></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">断路器状态图</figcaption></figure><h1 id="c3be" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">用断路器实现</h1><p id="ddf7" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">让我们实现一个<code class="fe ma mb mc md b">circuitBreaker</code>来进行GET http调用。我们的简单<code class="fe ma mb mc md b">circuitBreaker</code>需要三个参数</p><ul class=""><li id="6f0f" class="me mf iq jp b jq jr ju jv jy mg kc mh kg mi kk mj mk ml mm bi translated">在我们打开电路之前应该发生多少次故障。</li><li id="ae8f" class="me mf iq jp b jq mn ju mo jy mp kc mq kg mr kk mj mk ml mm bi translated">一旦电路处于打开状态，我们应该在多长时间后重试失败的服务？</li><li id="ee9a" class="me mf iq jp b jq mn ju mo jy mp kc mq kg mr kk mj mk ml mm bi translated">在我们的例子中，API请求的超时。</li></ul><p id="a93f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有了这些信息，我们就可以创建我们的<code class="fe ma mb mc md b">circuitBreaker</code>类了。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="my mz l"/></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">断路器类及其构造函数</figcaption></figure><p id="7024" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，让我们实现一个调用API到<code class="fe ma mb mc md b">serviceB</code>的函数。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="my mz l"/></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">断路器呼叫功能</figcaption></figure><p id="dfcc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们实现所有相关的功能。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="my mz l"/></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">具有所有关于状态、故障和复位的功能</figcaption></figure><p id="9088" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下一步是修改我们的<code class="fe ma mb mc md b">serviceA</code>。我们将把我们的调用包装在我们刚刚创建的<code class="fe ma mb mc md b">circuitBreaker</code>中。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="0824" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">与之前的代码相比，此代码中需要注意的重要更改:</p><ul class=""><li id="48f4" class="me mf iq jp b jq jr ju jv jy mg kc mh kg mi kk mj mk ml mm bi translated">我们正在初始化断路器<code class="fe ma mb mc md b">const circuitBreaker = new CircuitBreaker(3000, 5, 2000);</code></li><li id="f039" class="me mf iq jp b jq mn ju mo jy mp kc mq kg mr kk mj mk ml mm bi translated">我们通过断路器调用API<code class="fe ma mb mc md b">const response = await circuitBreaker.call(‘http://0.0.0.0:8000/flakycall');</code></li></ul><p id="ec13" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就是这样！现在让我们再次运行jMeter测试，我们可以看到我们的<code class="fe ma mb mc md b">serviceA</code>没有崩溃，我们的错误率已经显著下降。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nm"><img src="../Images/a990647149d782b54020fa866f0088c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0tldWGpZs-yqwlqp5PZdzg.png"/></div></div></figure><h1 id="ae84" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">进一步阅读</h1><ul class=""><li id="9cb2" class="me mf iq jp b jq lv ju lw jy nn kc no kg np kk mj mk ml mm bi translated">马丁·福勒谈<a class="ae mx" href="https://martinfowler.com/bliki/CircuitBreaker.html" rel="noopener ugc nofollow" target="_blank">断路器</a></li><li id="72a4" class="me mf iq jp b jq mn ju mo jy mp kc mq kg mr kk mj mk ml mm bi translated">网飞:<a class="ae mx" href="https://medium.com/netflix-techblog/making-the-netflix-api-more-resilient-a8ec62159c2d" rel="noopener">让网飞API更有弹性</a></li><li id="7be5" class="me mf iq jp b jq mn ju mo jy mp kc mq kg mr kk mj mk ml mm bi translated">网飞:<a class="ae mx" href="https://medium.com/netflix-techblog/fault-tolerance-in-a-high-volume-distributed-system-91ab4faae74a" rel="noopener">大容量分布式系统中的容错</a></li></ul></div></div>    
</body>
</html>