<html>
<head>
<title>Docker Basics Explained</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Docker基础解释</h1>
<blockquote>原文：<a href="https://itnext.io/docker-skyrocketed-my-teams-productivity-e19cd89a23ea?source=collection_archive---------3-----------------------#2021-01-13">https://itnext.io/docker-skyrocketed-my-teams-productivity-e19cd89a23ea?source=collection_archive---------3-----------------------#2021-01-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="734a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">记录这个，记录那个，记录一切。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/206942efa170f5649140ee3b37e5965b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CjO8lpH_M88CnqAYlyBMTA.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">Guillaume Bolduc 在<a class="ae ky" href="https://unsplash.com/s/photos/container?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="0169" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi lv translated">大约两年前，我开始听到越来越多关于Docker的消息。最终，我听到了太多关于Docker的讨论，以至于我不得不更深入地研究它，了解fuzz是关于什么的。</p><p id="0f39" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我唯一的遗憾是没有早点学会。它对我的日常工作帮助很大，我真的相信Docker是每个开发人员都应该学习的东西。</p><p id="95e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们先来谈谈Docker是什么，它是用来做什么的，以及如何使用它。我们还将构建自己的图像来演示用法。我们还将尝试在docker-compose中使用我们自己的图像。希望它能说服一些人开始使用Docker。</p><h2 id="ac54" class="me mf it bd mg mh mi dn mj mk ml dp mm li mn mo mp lm mq mr ms lq mt mu mv mw bi translated">Docker是什么？</h2><p id="e039" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">Docker用于创建<strong class="lb iu">容器化软件</strong>。这意味着我们可以创建一套标准化的软件，可以在任何有docker-engine的地方部署和运行。这样做的结果是，如果有人经历了在docker映像中安装我们想要的软件的麻烦，我们就不必重做了。</p><p id="0c0f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是我能想到的解释docker的最简单的方法，docker是安装在容器中的一套预装软件。这就是你开始体验和学习docker所需要知道的一切。</p><p id="f300" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你对docker是什么以及其内部运作的更深入的知识感兴趣，最好在docker网站上阅读。</p><p id="8814" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面说一些Docker世界需要理解的词汇。</p><h2 id="8e2a" class="me mf it bd mg mh mi dn mj mk ml dp mm li mn mo mp lm mq mr ms lq mt mu mv mw bi translated">图像</h2><p id="37e5" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">图像是容器应该包含的文件的预设设置。有人制作了一个包含预装软件的映像。它可以在CentOS图像或任何东西上安装Elasticsearch。然后这个软件被构建成一个映像，可以部署给任何想要安装Elasticsearch的人。</p><blockquote class="nc nd ne"><p id="9022" class="kz la nf lb b lc ld ju le lf lg jx lh ng lj lk ll nh ln lo lp ni lr ls lt lu im bi translated">Docker容器映像是一个轻量级的、独立的、可执行的软件包，包括运行应用程序所需的一切:代码、运行时、系统工具、系统库和设置。</p></blockquote><p id="2da2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有两种<a class="ae ky" href="https://docs.docker.com/develop/develop-images/baseimages/" rel="noopener ugc nofollow" target="_blank">图像</a></p><ul class=""><li id="940a" class="nj nk it lb b lc ld lf lg li nl lm nm lq nn lu no np nq nr bi translated"><strong class="lb iu">基础图像</strong>—docker提供的保留的最小图像。通过使用“从头开始”来定义基础映像。当我们说最小的时候，它确实是最小的。如果你在scratch的基础上创建了一个新的映像，并且没有添加任何东西，那么它就是0B。</li><li id="66e8" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu no np nq nr bi translated"><strong class="lb iu">父映像</strong> —当我们使用另一个已经创建的映像作为新映像的基础时。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/b2ee6aad351c2849c66989657f72fa30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9HfNnFCjerXcWpGiKxFllw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">显示基本图像的图片，大小为0 B。</figcaption></figure><p id="4b2d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<strong class="lb iu"> docker build </strong>命令构建图像。图像被赋予名称和标签。这个名称就是图像的名称，比如postgresql。标签是由分号附加的版本或其他信息。<br/>构建图像的示例如下</p><pre class="kj kk kl km gt ny nz oa ob aw oc bi"><span id="241c" class="me mf it nz b gy od oe l of og">sudo docker build -t customImage:0.1 .</span></pre><p id="4434" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们看到的是正在运行的命令docker build，-t标志指定了标签。在我们的例子中，它是一个名为customImage的映像，版本为0.1。</p><h2 id="01c1" class="me mf it bd mg mh mi dn mj mk ml dp mm li mn mo mp lm mq mr ms lq mt mu mv mw bi translated">容器</h2><p id="8e13" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">容器是当用户启动一个图像时，这个容器上的文件是基于所使用的图像的。</p><blockquote class="nc nd ne"><p id="de67" class="kz la nf lb b lc ld ju le lf lg jx lh ng lj lk ll nh ln lo lp ni lr ls lt lu im bi translated">容器图像在运行时成为容器</p></blockquote><p id="fbd3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<strong class="lb iu"> docker run </strong>命令创建容器。因此，要将我们的customImage:0.1转换成一个容器，我们应该这样运行它。</p><pre class="kj kk kl km gt ny nz oa ob aw oc bi"><span id="39c5" class="me mf it nz b gy od oe l of og">sudo docker run customImage</span></pre><h2 id="c899" class="me mf it bd mg mh mi dn mj mk ml dp mm li mn mo mp lm mq mr ms lq mt mu mv mw bi translated">码头枢纽</h2><p id="c61a" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated"><a class="ae ky" href="https://hub.docker.com/search?q=&amp;type=image" rel="noopener ugc nofollow" target="_blank"> Docker hub </a>是Docker图片的储存库。在这里，我们会发现其他人创造的图像，随时可供我们使用。</p><p id="5be5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">想想Docker的GitHub。</strong></p><p id="fdc5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当你需要一个新软件的时候，这是一个很好的地方。有大量的可用，而且都是免费的！</p><p id="0ca4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">想象一下我有多惊讶，Postgres是最受欢迎的形象。说真的，你试过装吗？我大概做了20-30次，总是有问题。但不再是了，我现在有了漂亮的码头工人。</p></div><div class="ab cl oh oi hx oj" role="separator"><span class="ok bw bk ol om on"/><span class="ok bw bk ol om on"/><span class="ok bw bk ol om"/></div><div class="im in io ip iq"><h1 id="7dda" class="oo mf it bd mg op oq or mj os ot ou mm jz ov ka mp kc ow kd ms kf ox kg mv oy bi translated">为什么是docker？</h1><p id="bde3" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">我最喜欢用现实生活中的场景来解释这一点。在我开始在我所有的项目中使用Docker之前，我花了很多时间安装和配置不同的软件。当时我从事许多小项目，根据项目的不同，我必须安装所有需要的软件。或者如果另一个项目已经在使用我需要重新配置的软件。</p><h2 id="87f6" class="me mf it bd mg mh mi dn mj mk ml dp mm li mn mo mp lm mq mr ms lq mt mu mv mw bi translated">时间消耗</h2><p id="f68f" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">所以有一周我在做一个使用Elasticsearch的项目，第二周我需要PostgreSQL，第三周是Redis。这种情况一直持续，最糟糕的是，每次我有一个新项目，我都必须重新配置。一个项目需要PostgreSQL以这种或那种方式配置。我花了很多时间管理每个项目的设置。这不是没有意义的，我的bash和makefile技能大幅提高，但仍然消耗了很多时间。让我们不要谈论我的开发服务器上的环境变量和端口管理。</p><p id="7a06" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Docker <strong class="lb iu">以一种超级简单、易于管理、令人敬畏的方式</strong>解决了所有这些问题。我不记得上次我必须安装一个软件是什么时候了。我已经竭尽全力了。</p><p id="fa1d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">需要PostgreSQL，太好了，给你。<br/>还需要什么吗，太好了，有人可能也打败了你，并在Dockerhub上传了一张图片。</p><p id="35d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在项目之间切换时，我不需要管理多个PostgreSQL或任何软件实例的配置，一切都在我的docker文件中。并且它们不会冲突，因为它们都运行在它们的容器环境中。</p><h2 id="97c9" class="me mf it bd mg mh mi dn mj mk ml dp mm li mn mo mp lm mq mr ms lq mt mu mv mw bi translated">测试</h2><p id="bb61" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">我喜欢单元测试。它们非常适合测试低级函数和精确的代码行。</p><p id="f27d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但我也喜欢在真实的环境中测试，它能让我平静下来。我可能知道这个特定的SQL查询在到达数据库时会工作，但是我喜欢在“真实环境”中测试我的应用程序。</p><p id="c13e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这也更容易，我知道我们可以在测试中模拟我们的数据库。但是运行一个真正的数据库并对其执行真正的查询要容易得多。如果我没有使用Docker，我不会推荐这样做。在Docker之前，我建议使用mock，但是现在运行一个测试数据库是如此简单，没有理由不这样做。(我已经准备好面对仇恨邮件和死亡威胁)</p><p id="00f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Docker允许我们轻松快捷地复制我们的应用程序将要生活的真实环境。稍后我将详细讨论这一点。</p><h2 id="70ba" class="me mf it bd mg mh mi dn mj mk ml dp mm li mn mo mp lm mq mr ms lq mt mu mv mw bi translated">部署</h2><p id="0df8" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">这可能会耗费时间，但值得多写一章。</p><p id="cc25" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我对docker狂热之前，我通常在我的项目中存储一个供应商目录。该目录包含所有需要的依赖项、正确版本的驱动程序和库。我就是这样发现解决很多部署问题的。但这并不总是有帮助，一些客户希望软件在Windows上运行，一些在Linux上运行，另一个在mac上运行。因此，我们要么通过在供应商内部添加更多依赖项来支持这一点，要么在复杂的<a class="ae ky" href="https://semaphoreci.com/blog/cicd-pipeline" rel="noopener ugc nofollow" target="_blank"> CI/CD管道</a>中创建交叉构建。现在你仍然应该运行CI/CD，但是它们变得容易多了，至少在我看来是这样的。</p><p id="e157" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为什么这么问？正如前面提到的，只要有docker引擎，docker映像可以在任何计算机上运行。而且它们对许多操作系统都是可用的。</p><p id="4c71" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这方面的一个例子是我的工作流，我使用centOS，我倾向于用它作为我的docker图像的基础。</p><p id="cb34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以我们在基于centOS的docker映像上构建我们的应用程序。这个映像可以通过docker<a class="ae ky" href="https://www.docker.com/blog/preview-linux-containers-on-windows/" rel="noopener ugc nofollow" target="_blank">发布到windows电脑</a>上并启动，它就可以工作了。它将会工作，因为我们的映像包含所有需要的软件。</p><h2 id="fa29" class="me mf it bd mg mh mi dn mj mk ml dp mm li mn mo mp lm mq mr ms lq mt mu mv mw bi translated">可量测性</h2><p id="1608" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">容器不仅易于部署，而且非常轻量级，易于扩展。说真的，我见过大小为50-100 MB的docker图像，用于完全运行的应用程序。</p><p id="62c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有很好的工具可以让我们扩展应用程序。</p><p id="71b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有<a class="ae ky" href="https://docs.docker.com/engine/swarm/swarm-tutorial/scale-service/" rel="noopener ugc nofollow" target="_blank"> docker-swarm </a>，还有<a class="ae ky" href="https://kubernetes.io" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>。还有很多，但我提到这两个是因为我已经对它们进行了实战测试，对结果很满意。</p><h2 id="7965" class="me mf it bd mg mh mi dn mj mk ml dp mm li mn mo mp lm mq mr ms lq mt mu mv mw bi translated">了不起</h2><p id="113d" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">我说过Docker很棒吗？</p><h1 id="23e5" class="oo mf it bd mg op oz or mj os pa ou mm jz pb ka mp kc pc kd ms kf pd kg mv oy bi translated">如何对接？</h1><p id="2e52" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">所以现在我们知道了开始使用docker所需要的一切。首先，你需要<a class="ae ky" href="https://docs.docker.com/engine/install/" rel="noopener ugc nofollow" target="_blank">安装docker </a>。在该链接中找到您当前的操作系统，并按照说明进行操作。我将在我的例子中使用CentOS。</p><pre class="kj kk kl km gt ny nz oa ob aw oc bi"><span id="3c50" class="me mf it nz b gy od oe l of og">sudo yum install -y yum-utils<br/>sudo yum-config-manager \ --add-repo \ <a class="ae ky" href="https://download.docker.com/linux/centos/" rel="noopener ugc nofollow" target="_blank">https://download.docker.com/linux/centos/</a><br/>sudo yum install docker-ce docker-ce-cli</span><span id="6676" class="me mf it nz b gy pe oe l of og">sudo systemctl start docker</span><span id="1362" class="me mf it nz b gy pe oe l of og">sudo systemctl enable docker</span></pre><p id="3165" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过运行以下命令，确保您的安装工作正常。</p><pre class="kj kk kl km gt ny nz oa ob aw oc bi"><span id="942a" class="me mf it nz b gy od oe l of og">sudo docker run hello-world</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pf"><img src="../Images/ab35168b5d1e038194ddecb7a398ac29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uzjjWE0WtXo_eenhCAJx9w.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">Hello-world docker的输出</figcaption></figure><h2 id="6d3f" class="me mf it bd mg mh mi dn mj mk ml dp mm li mn mo mp lm mq mr ms lq mt mu mv mw bi translated">了解Dockerfile</h2><p id="3bbf" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">Dockerfile是一个纯文本文件，它给出了在构建图像时我们的图像应该做什么的说明。关于这一点有很多要学的，但是在这篇文章中我将只回顾其中的要点。</p><p id="d44a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">docker中的图像是分层构建的。构建期间运行的每个命令都会添加一个额外的层。所以我们的图像实际上只是一系列的图层。Dockerfile文件定义了这些层。</p><p id="832e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Dockerfile使用它所在的路径作为所谓的<strong class="lb iu">上下文</strong>。上下文是Dockerfile的位置中的所有文件或目录。如果有您不希望docker文件包含在上下文中的文件或目录，您可以创建一个名为<strong class="lb iu">的文件。dockerignore </strong>(有点像gitignore)。<strong class="lb iu">。dockerignore </strong>是一个文本文件，每行包含一个文件名或一个要避免的文件模式的正则表达式。</p><p id="e28e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Docker实际上<a class="ae ky" href="https://docs.docker.com/engine/reference/builder/#:~:text=A%20Dockerfile%20is%20a%20text,command%2Dline%20instructions%20in%20succession." rel="noopener ugc nofollow" target="_blank">警告用户</a>不要将docker文件存储在你的主机的根目录中，因为整个硬盘驱动器都将包含在上下文中。这并不意味着整个硬盘将被插入到构建的映像中，只是插入到构建上下文中，使得所有文件在构建期间都可用。</p><p id="4a4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有docker文件都基于来自语句的<strong class="lb iu">开始构建它们的映像。FROM定义了使用什么样的图像作为基础，这意味着在FROM之后运行的任何命令都会给我们的图像添加层。</strong></p><p id="2667" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们回顾一下docker文件中一些最常见的命令。完整的清单可在码头工人网站上找到。</p><ul class=""><li id="7a5e" class="nj nk it lb b lc ld lf lg li nl lm nm lq nn lu no np nq nr bi translated"><strong class="lb iu">运行</strong> —运行用于根据镜像所基于的操作系统执行命令。对于Linux它是Bash，对于windows它是cmd。</li><li id="1cbe" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu no np nq nr bi translated"><strong class="lb iu"> ENV </strong> —用于在容器内部分配环境变量。</li><li id="f061" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu no np nq nr bi translated"><strong class="lb iu">标签</strong> —用于向容器添加元数据。来自父图像的标签被继承。</li><li id="2f11" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu no np nq nr bi translated"><strong class="lb iu">复制</strong> —将文件从主机复制到容器。只能从主机复制文件。</li><li id="a469" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu no np nq nr bi translated"><strong class="lb iu">添加</strong>——非常类似于COPY，它也将文件复制到我们的容器中。不同之处在于，ADD还可以通过URL使用远程文件。它还可以将本地焦油提取到容器中。</li><li id="f1a3" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu no np nq nr bi translated"><strong class="lb iu"> ARG </strong> —构建映像的人可以在构建时设置的变量。在构建过程中，可以在docker文件中使用ARGS，但是在构建映像之后，除非重新构建映像，否则不能使用或更改它们。</li><li id="75d7" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu no np nq nr bi translated"><strong class="lb iu">卷</strong> —在主机和容器之间添加一个挂载点。语法是卷路径。这通常在容器重启之间持久化数据时使用，例如数据库。实际数据存储在主机上，但在容器中使用。</li><li id="45b8" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu no np nq nr bi translated"><strong class="lb iu"> EXPOSE </strong> —告诉Docker引擎容器正在监听特定的端口和协议。格式是端口协议(udp/tcp)</li><li id="77b6" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu no np nq nr bi translated"><strong class="lb iu"> CMD </strong> —定义Docker容器在启动时应该运行的命令和参数。这通常指向带有一组缺省值的二进制文件。当允许用户更改命令时，应该使用CMD。</li><li id="bb85" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu no np nq nr bi translated">入口点——通常在容器应该作为可执行文件运行时使用。它的功能与CMD相同，但是如果使用ENTRYPOINT，用户不允许更改该命令。</li><li id="4fbc" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu no np nq nr bi translated"><strong class="lb iu"> WORKDIR </strong> —设置命令运行的路径。所以如果设置为/app，就像运行cd /app一样。</li></ul><h2 id="86ac" class="me mf it bd mg mh mi dn mj mk ml dp mm li mn mo mp lm mq mr ms lq mt mu mv mw bi translated">建立我们的第一个形象</h2><p id="2e4f" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">让我们从建立我们的第一个图像开始。</p><p id="8ddc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先创建一个新文件夹和一个名为<strong class="lb iu"> Dockerfile </strong>的文件。如果没有指定，Docker将在当前目录中搜索名为Dockerfile的文件。</p><pre class="kj kk kl km gt ny nz oa ob aw oc bi"><span id="5030" class="me mf it nz b gy od oe l of og">mkdir docker<br/>touch Dockerfile</span></pre><p id="0df0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在你需要决定你的起点是什么。我说的起点是指我们将使用什么样的形象作为新形象的基础。基地的一切都将被复制到我们的图像中。如果我们想真正拥有完全的控制权，我们也可以从头开始。我不建议从一个基础图像开始，而是使用一个叫做多重构建的东西，我将在最后展示。我不推荐它的原因是scratch没有任何可用的东西，甚至没有bash。如果您的整个应用程序都是一个二进制文件，这没问题。</p><p id="3d8d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，我们将构建一个超级简单的应用程序，当我们访问一个URL时，它将打印hello-world。我们想把重点放在docker的功能上，而不是我们将要构建的令人惊叹的应用程序。<br/>我们将基于我们的图像<strong class="lb iu"> golang:1.5，</strong>这是一个包含编程语言golang的图像，当我们访问某个URL时，我们将使用它来打印hello world。</p><p id="fbc0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以检查golang:1.5与docker <strong class="lb iu">检查</strong>也看看是什么形象。Inspect将打印关于图像的信息。打印出来的信息很多，所以阅读起来需要一些理解。阅读信息我们可以看到，该映像是一个Linux OS，他们设置了一些环境变量，并将一个Golang二进制文件放入/usr/local/bin。</p><pre class="kj kk kl km gt ny nz oa ob aw oc bi"><span id="b44a" class="me mf it nz b gy od oe l of og">sudo docker inspect golang:1.5</span></pre><p id="507a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在任何文本编辑器中打开docker文件，让我们开始构建一些东西。<br/>我们将使用<strong class="lb iu">标签</strong>来添加关于维护者是谁的元数据。<br/>接下来，我们需要用<strong class="lb iu"> RUN </strong>创建一个文件夹，我们将在其中存储我们的应用程序，用<strong class="lb iu"> COPY将所需文件从我们的主机复制到容器中。</strong>用<strong class="lb iu"> WORKDIR </strong>移动到那个目录，用<strong class="lb iu"> RUN、</strong>编译我们的应用程序，最后我们需要用<strong class="lb iu"> CMD </strong>执行我们的应用程序。</p><p id="3a0c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我的docker文件看起来像这样</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pg ph l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">我当前的docker文件，我们继续构建Golang图像，并在其中添加我们的应用程序。</figcaption></figure><p id="8a9e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们运行<strong class="lb iu"> docker build，</strong>来构建图像，我将把我的图像命名为learndocker:0.1。</p><pre class="kj kk kl km gt ny nz oa ob aw oc bi"><span id="f000" class="me mf it nz b gy od oe l of og">sudo docker build -t learndocker:0.1 .</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pi"><img src="../Images/d88b195f3a80045c81a29b5f01eb6f07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mmZPfa6E20Pq43m5cUmPaw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">一个例子，我们可以看到层的图像被附加</figcaption></figure><p id="9fb8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">成功了吗？<strong class="lb iu">当然不是</strong>，我们正试图将一个名为main.go的文件从我们的主机复制到我们的目录中。那个文件不存在，所以创建一个并将下面的要点复制到其中。要点是一个用Go编写的超级瘦Hello world HTTP服务器。如果你没有安装Go，不要担心，你的Docker镜像会安装。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pg ph l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">从Docker打印Hello的瘦HTTP服务器</figcaption></figure><p id="25e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们重新运行build命令，看看会发生什么，我也将使用images命令打印我们所有的当前图像。</p><pre class="kj kk kl km gt ny nz oa ob aw oc bi"><span id="cda9" class="me mf it nz b gy od oe l of og">sudo docker build -t learndocker:0.1 .<br/>sudo docker images</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pj"><img src="../Images/5091537121bd82124fc44633b6c34554.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c_ZLSY7PeEDcgVCKFR9dBw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">我们可以看到，我们的映像已创建，大小为732 MB</figcaption></figure><p id="dd08" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">太好了，我们开始吧。我将在构建时使用<strong class="lb iu">名称</strong>标志。我喜欢能够通过名字而不是ID来删除我的容器。现在我们不需要删除任何容器，因为我们将使用<strong class="lb iu"> rm </strong>标志。rm标志使容器在退出时自我删除。</p><pre class="kj kk kl km gt ny nz oa ob aw oc bi"><span id="dde0" class="me mf it nz b gy od oe l of og">sudo docker run --rm --name learndocker learndocker:0.1</span><span id="3d17" class="me mf it nz b gy pe oe l of og"># If you dont run --rm, make sure to delete the container after exit<br/>sudo docker rm -f learndocker</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pk"><img src="../Images/7cc1f55ec150f50d8987c4a3e842e63b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1384/format:webp/1*eKwUvA16ocQqg4AZUwIlVQ.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">容器的输出</figcaption></figure><p id="ca3a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您会看到容器将一个错误输出到控制台。我们看到这一点是因为我们运行了连接到我们终端的容器。如果您添加了<strong class="lb iu"> -d </strong>标志，容器将在后台运行。这很常见，我们会错过容器的输出。这就是为什么我还要运行<strong class="lb iu"> docker日志</strong>来检查错误。Docker日志是一种查看容器输出到stdout的内容的方式。我通常设置一个<strong class="lb iu"> Filebeat </strong>来读取我的docker日志，并将它们输出到一个<strong class="lb iu"> Elasticsearch中。</strong></p><p id="07e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，让我们修复错误。为此，我们需要了解<strong class="lb iu">环境变量。</strong>在Go代码中，我们使用环境变量<strong class="lb iu"> PORT </strong>来确定托管HTTP服务器的端口。因为Docker容器没有那个设置，所以它不会工作。所以我们需要使用<strong class="lb iu"> ENV </strong>命令来添加它。</p><p id="f32e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过设置<strong class="lb iu"> -e </strong>标志将它添加到我们的运行命令中。</p><pre class="kj kk kl km gt ny nz oa ob aw oc bi"><span id="9e94" class="me mf it nz b gy od oe l of og">sudo docker run --name dockerlearn -e PORT=8080 dockerlearn:0.1</span></pre><p id="e75c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这不是很用户友好，因为它要求我们的用户知道这一点，所以让我们改为添加一个默认的docker文件。这样，只有当我们需要定制它时，我们才需要配置它。</p><p id="4059" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们将<strong class="lb iu"> ENV </strong>命令和<strong class="lb iu"> ARG </strong>命令添加到Dockerfile文件中。我们将允许图像的维护者在构建应用程序时设置默认端口，但也允许用户用环境变量覆盖默认端口。<strong class="lb iu"> ARG </strong>用于提供构建变量，<strong class="lb iu"> ENV </strong>用于运行时变量。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pg ph l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">在这个docker文件中，我们为主机端口设置了一个默认值</figcaption></figure><p id="e46f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在重建映像并再次运行它。您应该不会再看到错误。您可以通过添加<strong class="lb iu"> build-arg </strong>标志来更改默认端口</p><pre class="kj kk kl km gt ny nz oa ob aw oc bi"><span id="a381" class="me mf it nz b gy od oe l of og">sudo docker build -t learndocker:0.1 --build-arg port=8080 .</span></pre><p id="998c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尝试在浏览器中访问<a class="ae ky" href="http://localhost:8080" rel="noopener ugc nofollow" target="_blank"> localhost:8080 </a>。如果您更改了端口，请记住在URL中更改端口。</p><p id="4624" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Auch，没起作用？</p><p id="d87e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是因为HTTP服务器只为拥有本地主机的容器服务。一开始使用Docker可能会令人困惑，但是我发现总是把容器想象成另一台服务器/计算机是有帮助的。这在技术上是不正确的，但它有助于理解为什么事情不工作。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pl"><img src="../Images/2e8b34cf9b965d8007028ab24aacc3ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0r8Sci0U63CcnnRKwrMXHw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">看到港口了吗？没有向我们的主机开放的端口</figcaption></figure><p id="830f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要<strong class="lb iu">将我们将要托管的端口</strong>映射到我们主机上的一个端口，以便能够访问它。如果你在Dockerfile章节的时候注意了，你可能会想跑去Dockerfile并添加一个<strong class="lb iu"> EXPOSE 8080 </strong>。我们将这样做，除了我们将公开环境变量集。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pg ph l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">这是我们的新docker文件，我们在其中公开了端口。</figcaption></figure><p id="39aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">重新构建应用程序并启动它。</p><pre class="kj kk kl km gt ny nz oa ob aw oc bi"><span id="b262" class="me mf it nz b gy od oe l of og">sudo docker build -t learndocker:0.1 --build-arg port=8080 .<br/>sudo docker run --rm --name learndocker -e PORT=8080 -d learndocker:0.1</span></pre><p id="3855" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还是不行？这是因为EXPOSE命令实际上只用于为docker引擎记录容器正在监听的端口。要访问公开的端口，我们需要在运行容器时映射它。<strong class="lb iu">在运行容器时使用<strong class="lb iu"> -p </strong>标志将主机端口绑定到容器</strong>。没有必要重建图像，我们没有改变任何东西。仅将运行命令修改为以下内容。p命令接受HOSTPORT:CONTAINERPORT并绑定它们。</p><pre class="kj kk kl km gt ny nz oa ob aw oc bi"><span id="4b76" class="me mf it nz b gy od oe l of og">sudo docker run --rm --name learndocker -p 8082:8080 -e PORT=8080 -d learndocker:0.1</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pm"><img src="../Images/648b783f4a6421f21a22f1fb93ea5896.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sact5rkWOy3dzLCHK1tufw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">我们可以看到端口8080/tcp是公开的，但只是针对容器本身。</figcaption></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pn"><img src="../Images/c6cfc76c5c6937b28cb145dc498cda39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HOUnI7xueCvbDm9MCj5dww.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">添加-p标志后，我们可以看到它实际上映射了我的主机8082 -&gt;8080</figcaption></figure><p id="5d53" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">这次不耍花招</strong>，访问<a class="ae ky" href="http://localhost:8082" rel="noopener ugc nofollow" target="_blank"> localhost:8082 </a>就可以了。</p><h2 id="4146" class="me mf it bd mg mh mi dn mj mk ml dp mm li mn mo mp lm mq mr ms lq mt mu mv mw bi translated">通过多重构建优化我们的形象</h2><p id="7226" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">所以Docker的一个非常酷的特性来了。我们可以使用多阶段构建来优化和最小化我们的映像。这个想法是，您使用一个父映像，执行一些操作，然后您可以使用您的新映像，并从它复制任何需要的东西到另一个映像。</p><p id="c70e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这听起来很复杂，但却出奇的简单。</p><p id="8f39" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在这里要做的是使用Golang映像来构建我们的二进制HTTP服务器，然后将该二进制文件复制到Docker基本映像中。这个图像很大，叫做Scratch。</p><p id="dfc8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下要点显示了我们更新的docker文件。我会在要点的评论中解释所有新行的情况。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pg ph l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">多阶段构建示例</figcaption></figure><p id="c2e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们建立我们的新形象，并审查它。我已经将更新后的Docker配置放到了一个新的Docker文件中，以进行分隔，这次我还将更新版本标签。</p><pre class="kj kk kl km gt ny nz oa ob aw oc bi"><span id="fd51" class="me mf it nz b gy od oe l of og">sudo docker build -t learndocker:0.2 --build-arg port=8080 --file MultiBuildDocker.docker .<br/>sudo docker images</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi po"><img src="../Images/ea53b9b09a9141b74c7f9acc1bedc66a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iSvXl9UEgwBVHu_5UCFA7Q.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">你可以看到使用或不使用多重构建的大小差异。</figcaption></figure><p id="c728" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你现在有了一个巨大的容器，大小为<strong class="lb iu">6.44 MB。</strong>信不信由你，有一些技巧可以让它变得更小，但它们与Golang非常相关。我们可以改变编译器，删除不必要的依赖，如CGO，但我们不会在这里讨论。您可以尝试运行新的learndocker:0.2映像。不过这次你要靠自己了，应该很简单。</p><h2 id="fb79" class="me mf it bd mg mh mi dn mj mk ml dp mm li mn mo mp lm mq mr ms lq mt mu mv mw bi translated">清理未使用的图像</h2><p id="9c83" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">如果你一直按照我现在所做的去做，我们将会有一些未使用的图片占据不必要的空间。</p><pre class="kj kk kl km gt ny nz oa ob aw oc bi"><span id="dca6" class="me mf it nz b gy od oe l of og">sudo docker images</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pp"><img src="../Images/71277e41d2b824d05fb353ab28f9ff5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RCBmIvB1GFisVBZ6BEJsXw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">图像结果，当我们覆盖它们时，图像被设置为名称<none>和标签<none>。</none></none></figcaption></figure><p id="c0c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，运行images命令会显示在主机上构建或下载的所有映像。我们可以看到名为<strong class="lb iu"> &lt;无&gt;的图像。</strong>如果您使用与现有图像相同的名称和标签重建图像，就会发生这种情况。</p><p id="eea9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们确保没有容器在运行，然后删除未使用的图像。</p><pre class="kj kk kl km gt ny nz oa ob aw oc bi"><span id="b679" class="me mf it nz b gy od oe l of og">sudo docker container ps</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pq"><img src="../Images/21f44cb819fc83385ca120a3bc0c88be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1-VkDPJ9vL5SB7gjum5G7g.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">显示我们的容器正在运行，容器ID或名称用于删除它。</figcaption></figure><p id="a9c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这向我们显示了任何正在运行的容器以及关于它们的一些信息。让我们使用ID或Name字段将其删除。</p><pre class="kj kk kl km gt ny nz oa ob aw oc bi"><span id="db61" class="me mf it nz b gy od oe l of og">sudo docker container rm learndocker</span></pre><p id="efb4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> docker容器rm </strong>移除单个容器，使用-f强制。这甚至会删除正在运行的容器。如果你有很多容器在运行，或者有很多图像，你可以使用<strong class="lb iu">系统修剪。</strong>系统修剪将删除任何未使用的图像，任何创建的网络，非常适合清理我们的混乱。</p><pre class="kj kk kl km gt ny nz oa ob aw oc bi"><span id="33c4" class="me mf it nz b gy od oe l of og">sudo docker system prune</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pr"><img src="../Images/edb77c0b7c642828a722cfea620667db.png" data-original-src="https://miro.medium.com/v2/resize:fit:952/format:webp/1*rTZ40QgfWLALx2-AT7cYSw.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">清理不用的容器和图像很快，但是要小心使用！</figcaption></figure><h2 id="be3d" class="me mf it bd mg mh mi dn mj mk ml dp mm li mn mo mp lm mq mr ms lq mt mu mv mw bi translated">docker-撰写</h2><p id="08f4" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">我建议每个容器运行一个软件。运行多个容器的开销很低，所以不需要分离。</p><p id="d7fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">只运行一个容器是有用的，但是对于一个完整的应用程序，我们通常需要更多的容器。很多时候，假设我们需要不止一个容器是安全的，比如一个数据库和一个应用程序。这就是docker-compose发挥作用的地方。</p><p id="2795" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Docker-compose用于<strong class="lb iu">运行几个容器。如果需要的话，它有助于在容器之间建立共享网络，以及许多额外的事情。它还帮助我们运行构建命令，并且运行容器变得更加容易。事实上，我多次使用docker compose，即使我只有一个容器。这也使得使用Docker更容易，存储配置比修改命令行参数容易得多。</strong></p><p id="42c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用此<a class="ae ky" href="https://docs.docker.com/compose/install/" rel="noopener ugc nofollow" target="_blank">链接</a>安装docker-compose。</p><p id="68b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当使用docker-compose时，你只需要运行两个命令。</p><p id="0d83" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">sudo docker-compose up ，它将创建容器，运行你的配置，创建网络，挂载文件，你可以用docker做的任何事情。但这一切都将基于一个简单的YAML。</p><p id="305b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> sudo docker-compose down </strong>关闭并清理所有需要的东西。</p><p id="16c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们构建一个新的docker-compose.yaml，它将为我们的HTTP图像和PostgreSQL提供服务。我选择PostgreSQL是因为我真的需要展示用docker设置它是多么容易。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pg ph l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">gist展示了一个docker-compose设置，它在同一个网络上运行我们的图像和postgres</figcaption></figure><p id="3f95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你复制粘贴要点，然后开始docker-compose。等待它建立和设置好一切，然后你就可以访问<a class="ae ky" href="http://localhost:8082" rel="noopener ugc nofollow" target="_blank"> localhost:8082 </a>。</p><pre class="kj kk kl km gt ny nz oa ob aw oc bi"><span id="0064" class="me mf it nz b gy od oe l of og">sudo docker-compose up</span></pre><p id="f680" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">比运行<strong class="lb iu"> docker构建和docker运行</strong>更容易，对吗？<br/>你也可以看到，如果你运行，我们不会重新创建不必要的图像</p><pre class="kj kk kl km gt ny nz oa ob aw oc bi"><span id="f00e" class="me mf it nz b gy od oe l of og">sudo docker-compose down<br/>sudo docker images </span></pre><p id="9220" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是docker-compose。使用它，它很神奇，很有帮助。另外，不要忘记设置PostgreSQL是多么容易。现在我们还没有真正尝试过，你可以自己做，或者相信我。通过暴露的端口8083很容易访问它。</p></div><div class="ab cl oh oi hx oj" role="separator"><span class="ok bw bk ol om on"/><span class="ok bw bk ol om on"/><span class="ok bw bk ol om"/></div><div class="im in io ip iq"><p id="e597" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是我认为你需要开始探索和使用Docker的要点。希望这篇文章至少对你有一点帮助。Docker中还有很多值得探索的地方，但我认为最好熟悉一些基础知识，并在出现问题时使用他们的文档。</p><p id="5852" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么，你还在等什么？</p><blockquote class="ps"><p id="7f32" class="pt pu it bd pv pw px py pz qa qb lu dk translated">走出去，记录世界！</p></blockquote></div></div>    
</body>
</html>