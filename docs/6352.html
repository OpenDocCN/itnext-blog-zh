<html>
<head>
<title>Zero cost abstractions in Rust</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Rust中的零成本抽象</h1>
<blockquote>原文：<a href="https://itnext.io/zero-cost-abstractions-in-rust-26d058eb1724?source=collection_archive---------1-----------------------#2021-10-23">https://itnext.io/zero-cost-abstractions-in-rust-26d058eb1724?source=collection_archive---------1-----------------------#2021-10-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="9f00" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你好，</p><p id="2e8e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这篇文章中，我们将讨论Rust中的零成本抽象。</p><p id="83d3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个帖子的视频版本也有<a class="ae kl" href="https://youtu.be/yKA9PCvzbqA" rel="noopener ugc nofollow" target="_blank">可用</a>。</p><p id="0978" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是首先，我们需要问这个问题什么是零成本抽象？</p><p id="7749" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如C++编程语言的创始人所说:</p><p id="6269" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="km"> C++实现遵循零开销原则:</em></p><ol class=""><li id="77bd" class="kn ko iq jp b jq jr ju jv jy kp kc kq kg kr kk ks kt ku kv bi translated"><em class="km">不用的东西，不用付钱</em></li><li id="36b6" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk ks kt ku kv bi translated">你所使用的，你不可能比手工编码更好了。</li></ol><p id="a09c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是让我们更深入地挖掘每一点。</p><p id="2c4b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">想象一下Golang goroutines，每个Golang二进制程序都带有一个调度程序和一个运行时，其中包含了管理goroutines的代码，无论您是否使用它们，因此我们可以说Golang goroutines不是零成本的，因为即使您不使用它们，您也在为它们付费。现在比较一下Rust Async/Await，如果你明确地说你想要Async特性，runtime只是捆绑了。</p><p id="fc2f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们已经知道了第一个陈述，让我们看看第二个。</p><p id="b174" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在Golang和几乎所有主流语言中，有一个概念叫做接口，这是一种为不同类型定义共享行为的方式，但Golang实现接口和Rust实现特征(Rust Interfaces)的方式略有不同。在Golang中，正如这里详细解释的<a class="ae kl" href="https://research.swtch.com/interfaces" rel="noopener ugc nofollow" target="_blank"/>每个接口变量由两部分构成，</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi lb"><img src="../Images/f453a43d3bfce5c0fbf1f0505f735f75.png" data-original-src="https://miro.medium.com/v2/resize:fit:972/format:webp/1*g8Ij9ya0sjUkjj4i00HTKg.png"/></div></figure><p id="60e6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一部分保存接口的元数据(方法列表和签名)，另一部分是指向该接口的实际实现的指针。</p><p id="6e67" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在考虑这段代码</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="lj lk l"/></div></figure><p id="3975" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">两个变量a和b看起来一样，因为它们都有相同的数据，但在运行时它们的行为不同，如果你在a上调用String()方法，它是静态分派的，几乎没有额外的成本，但如果你在b上调用String()方法，你首先在接口包装器内对指针进行解引用，正如我们在上面的图片中看到的那样，所以通过在Go中使用接口，你在运行时会获得额外的成本。添加到您的代码中的代码并不是最快的实现，您可以通过移除接口并直接调用String()方法来手工编码它(当然，您会失去接口的好处。我只是说还有一个更快的实现，你可以自己编写，Rust中零成本抽象的另一个例子是迭代器特性。</p><p id="a4e9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是C++/Rust如何处理这种情况呢？最终，这两种编程语言将零成本抽象作为自己的核心价值。</p><p id="01d0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">再来说说铁锈。</p><p id="0f01" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Rust具有类似于接口的特性，请看下面的代码。</p><p id="8fd1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://gist.github.com/amirrezaask/34c9b401a35c7fce86ddc194d4ec51b4#file-trait-rs" rel="noopener ugc nofollow" target="_blank"> Rust零成本抽象(github.com)</a></p><p id="0e99" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如你在上面的代码中看到的，我们有几乎与Golang版本相同的东西，我们有一个trait(接口)和一个使用该trait作为输入的函数，但不同的是，当rust被编译时，该trait方法调用变成了一个静态调度，使用一种称为“单态化”的方法，这基本上意味着对于每个trait impl块，rust编译器将生成一个单独版本的函数，该函数将类型作为参数，例如对于我们的struct:</p><p id="347c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://gist.github.com/amirrezaask/34c9b401a35c7fce86ddc194d4ec51b4#file-trait_cmpl-rs-L1-L3" rel="noopener ugc nofollow" target="_blank"> Rust零成本抽象(github.com)</a></p><p id="f0ce" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们有其他实现，它也会生成其他函数。然后Rust compiler用调用这些生成的函数替换所有对trait方法的调用，这样trait就像函数一样便宜。</p><p id="d2d5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我希望这篇文章能帮助你更好地理解什么是零成本抽象，以及其中一些是如何在Rust中实现的。</p><p id="c5f7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后的话:</p><p id="14c4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">零成本抽象是Rust语言的核心价值，知道它们是什么以及它们如何工作有助于我们理解语言。</p></div></div>    
</body>
</html>