<html>
<head>
<title>How I Merged Django ORM with SQLAlchemy for Easier Data Analysis</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我如何将Django ORM与SQLAlchemy合并，以便更容易地进行数据分析</h1>
<blockquote>原文：<a href="https://itnext.io/how-i-merged-django-orm-with-sqlalchemy-for-easier-data-analysis-6ccf64484cab?source=collection_archive---------0-----------------------#2018-11-20">https://itnext.io/how-i-merged-django-orm-with-sqlalchemy-for-easier-data-analysis-6ccf64484cab?source=collection_archive---------0-----------------------#2018-11-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/4e05628df58f210f3ce0445017474d10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Gfli9wIQ_XjzRfpGohY2jQ.png"/></div></div></figure><blockquote class="jy"><p id="6364" class="jz ka iq bd kb kc kd ke kf kg kh ki dk translated">注意:由于降价，代码示例可能显示不正确。我建议<a class="ae kj" href="https://djangostars.com/blog/merging-django-orm-with-sqlalchemy-for-easier-data-analysis/?utm_source=medium&amp;utm_medium=itnext.io&amp;utm_campaign=djangoorm&amp;utm_content=continue%20reading" rel="noopener ugc nofollow" target="_blank">继续阅读我们博客</a>上的原始文章，以确保所有示例都能正确显示。</p></blockquote><p id="cc88" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ki ij bi translated">用Django框架开发产品通常简单明了；优秀的文档，许多现成的工具，大量的开源库和大型社区。Django ORM完全控制SQL层，防止您出错，并控制查询的底层细节，因此您可以花更多时间用Python代码设计和构建应用程序结构。然而，有时这种行为可能会造成伤害——例如，当您正在构建一个与数据分析相关的项目时。用Django构建高级查询并不容易；如果不在某处记录或打印生成的SQL查询，就很难阅读(用Python)和理解SQL级别的内容。此外，这样的查询可能不够高效，所以当您将更多的数据加载到DB中进行处理时，这将对您产生不利影响。在某个时刻，您会发现自己通过Django cursor做了太多的原始SQL，这时您应该休息一下，看看另一个有趣的工具，它位于ORM层和原始SQL查询层之间。</p><p id="fc4d" class="pw-post-body-paragraph kk kl iq km b kn lh kp kq kr li kt ku kv lj kx ky kz lk lb lc ld ll lf lg ki ij bi translated">正如你在文章标题中看到的，我们成功地将Django ORM和SQLAlchemy Core混合在一起，我们对结果非常满意。我们构建了一个应用程序，通过将数据汇总到图表和表格中，根据吞吐量/效率/员工成本进行评分，并突出显示异常值来帮助分析EMR系统产生的数据，从而优化诊所的业务流程并节省资金。</p><h1 id="d9f1" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">把Django ORM和SQLAlchemy混在一起有什么意义？</h1><p id="5a06" class="pw-post-body-paragraph kk kl iq km b kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld mo lf lg ki ij bi translated">我们从Django ORM中走出来完成这个任务有几个原因:</p><ul class=""><li id="6032" class="mp mq iq km b kn lh kr li kv mr kz ms ld mt ki mu mv mw mx bi translated">对于ORM world，一个对象就是数据库中的一条记录，但是这里我们只处理聚合数据。</li><li id="c21b" class="mp mq iq km b kn my kr mz kv na kz nb ld nc ki mu mv mw mx bi translated">一些聚合非常棘手，Django ORM功能不足以满足需求。老实说，有时在一些简单的情况下，很难(甚至不可能)让ORM完全按照您想要的方式产生SQL查询，当您处理一个<strong class="km ir">大数据</strong>时，它会对性能产生很大影响。</li><li id="9510" class="mp mq iq km b kn my kr mz kv na kz nb ld nc ki mu mv mw mx bi translated">如果您正在通过Django ORM构建高级查询，那么很难阅读和理解Python中的这类查询，也很难预测哪个SQL查询将被生成并处理给数据库。</li></ul><p id="0d2d" class="pw-post-body-paragraph kk kl iq km b kn lh kp kq kr li kt ku kv lj kx ky kz lk lb lc ld ll lf lg ki ij bi translated">值得一提的是，我们还建立了第二个数据库，由Django ORM处理，以涵盖其他web应用程序相关的任务和业务逻辑需求，它很好地做到了这一点。Django ORM正从一个版本发展到另一个版本，提供越来越多的功能。例如，在最近的版本中，添加了许多简洁的功能，如支持<a class="ae kj" href="https://docs.djangoproject.com/en/1.11/ref/models/expressions/#subquery-expressions" rel="noopener ugc nofollow" target="_blank">子查询表达式</a>或<a class="ae kj" href="https://docs.djangoproject.com/en/2.1/ref/models/database-functions/#window-functions" rel="noopener ugc nofollow" target="_blank">窗口函数</a>以及许多其他功能，如果您的问题比修复几个查询更复杂，那么您一定要在使用原始SQL或查看SQLAlchemy等工具之前尝试一下这些功能。</p><p id="0115" class="pw-post-body-paragraph kk kl iq km b kn lh kp kq kr li kt ku kv lj kx ky kz lk lb lc ld ll lf lg ki ij bi translated">这就是为什么我们决定看看SQLAlchemy。它由两部分组成— ORM和Core。SQLAlchemy ORM类似于Django ORM，但同时，它们又有所不同。与Django的活动记录方法相比，SQLAlchemy ORM使用了不同的概念，即数据映射器。就你在Django上构建项目而言，你绝对不应该切换ORM(如果你没有非常特殊的原因要这么做)，因为你想使用Django REST框架、Django-admin和其他与Django模型相关的好东西。</p><p id="13ee" class="pw-post-body-paragraph kk kl iq km b kn lh kp kq kr li kt ku kv lj kx ky kz lk lb lc ld ll lf lg ki ij bi translated">SQLAlchemy的第二部分称为核心。它位于高级ORM和低级SQL之间。核心非常强大灵活；它让您能够构建任何您想要的SQL查询，当您在Python中看到这样的查询时，很容易理解发生了什么。例如，请看文档中的一个示例查询:</p><pre class="nd ne nf ng gt nh ni nj nk aw nl bi"><span id="5e8a" class="nm ln iq ni b gy nn no l np nq">q = session.query(User).filter(User.name.like('e%')).\  <br/>    limit(5).from_self().\<br/>    join(User.addresses).filter(Address.email.like('q%')).\<br/>    order_by(User.name)</span></pre><p id="ffe1" class="pw-post-body-paragraph kk kl iq km b kn lh kp kq kr li kt ku kv lj kx ky kz lk lb lc ld ll lf lg ki ij bi translated">这将导致</p><pre class="nd ne nf ng gt nh ni nj nk aw nl bi"><span id="5421" class="nm ln iq ni b gy nn no l np nq">SELECT anon_1.user_id AS anon_1_user_id,  <br/>       anon_1.user_name AS anon_1_user_name<br/>FROM (SELECT "user".id AS user_id, "user".name AS user_name  <br/>FROM "user"  <br/>WHERE "user".name LIKE :name_1  <br/> LIMIT :param_1) AS anon_1<br/>JOIN address ON anon_1.user_id = address.user_id  <br/>WHERE address.email LIKE :email_1 ORDER BY anon_1.user_name</span></pre><p id="720c" class="pw-post-body-paragraph kk kl iq km b kn lh kp kq kr li kt ku kv lj kx ky kz lk lb lc ld ll lf lg ki ij bi translated"><strong class="km ir"> <em class="nr">注意</em> </strong>:有了这样的技巧，我们就不会陷入<code class="fe ns nt nu ni b">N+1 problem</code> : <code class="fe ns nt nu ni b">from_select</code>对查询做了一个额外的<code class="fe ns nt nu ni b">SELECT</code>包装，所以我们先减少行数(通过<code class="fe ns nt nu ni b">LIKE</code>和<code class="fe ns nt nu ni b">LIMIT</code>)，然后才加入地址信息。</p><h1 id="d5fa" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">如何混合Django应用程序和SQLALchemy</h1><p id="dbbe" class="pw-post-body-paragraph kk kl iq km b kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld mo lf lg ki ij bi translated">因此，如果您感兴趣并想尝试将SQLAlchemy与Django应用程序混合使用，这里有一些提示可以帮助您。</p><p id="469f" class="pw-post-body-paragraph kk kl iq km b kn lh kp kq kr li kt ku kv lj kx ky kz lk lb lc ld ll lf lg ki ij bi translated">首先，你需要<a class="ae kj" href="http://docs.sqlalchemy.org/en/latest/core/engines.html#engine-configuration" rel="noopener ugc nofollow" target="_blank">用Engine创建</a>一个全局变量，但是与DB的实际连接将在第一次<code class="fe ns nt nu ni b">connect</code>或<code class="fe ns nt nu ni b">execute</code>调用时建立。</p><pre class="nd ne nf ng gt nh ni nj nk aw nl bi"><span id="eebb" class="nm ln iq ni b gy nn no l np nq">sa_engine = create_engine(settings.DB_CONNECTION_URL, pool_recycle=settings.POOL_RECYCLE)</span></pre><p id="ac70" class="pw-post-body-paragraph kk kl iq km b kn lh kp kq kr li kt ku kv lj kx ky kz lk lb lc ld ll lf lg ki ij bi translated">创建<em class="nr">引擎接受连接的附加配置。MySQL/MariaDB/AWS Aurora(MySQL兼容)有一个交互式</em>超时设置，默认为8h，所以如果没有pool_recycle额外参数，你会变得很烦人<code class="fe ns nt nu ni b">SQLError: (OperationalError) (2006, ‘MySQL server has gone away’)</code>。所以<code class="fe ns nt nu ni b">POOL_RECYCLE</code>应该比<code class="fe ns nt nu ni b">interactive_timeout</code>小。例如它的一半:<code class="fe ns nt nu ni b">POOL_RECYCLE = 4 * 60 * 60</code></p><p id="60c4" class="pw-post-body-paragraph kk kl iq km b kn lh kp kq kr li kt ku kv lj kx ky kz lk lb lc ld ll lf lg ki ij bi translated">下一步是构建您的查询。根据您的应用程序架构，您可以使用 <code class="fe ns nt nu ni b">Table</code>和<code class="fe ns nt nu ni b">Column</code>类来声明表和字段<a class="ae kj" href="http://docs.sqlalchemy.org/en/latest/core/metadata.html" rel="noopener ugc nofollow" target="_blank">(这些类也可以用于ORM)，或者如果您的应用程序已经以另一种方式存储了表和列名，您可以通过table ( <code class="fe ns nt nu ni b">table_name</code>)和column ( <code class="fe ns nt nu ni b">col_name</code>)函数(如此处的</a><a class="ae kj" href="http://docs.sqlalchemy.org/en/latest/core/selectable.html#sqlalchemy.sql.expression.table" rel="noopener ugc nofollow" target="_blank">所示</a>)就地完成。</p><p id="02d3" class="pw-post-body-paragraph kk kl iq km b kn lh kp kq kr li kt ku kv lj kx ky kz lk lb lc ld ll lf lg ki ij bi translated">在我们的应用程序中，我们选择了第二个选项，因为我们在自己的声明性语法中存储了关于聚合、公式和格式的信息。然后，我们构建了一个层，它读取这样的结构并根据提供的指令执行查询。</p><p id="3949" class="pw-post-body-paragraph kk kl iq km b kn lh kp kq kr li kt ku kv lj kx ky kz lk lb lc ld ll lf lg ki ij bi translated">当您的查询准备好时，只需调用<code class="fe ns nt nu ni b">sa_engine.execute(query)</code>。游标将一直打开，直到您读取所有数据或者显式关闭它。</p><p id="b8da" class="pw-post-body-paragraph kk kl iq km b kn lh kp kq kr li kt ku kv lj kx ky kz lk lb lc ld ll lf lg ki ij bi translated">有一件很烦的事情值得一提。正如<a class="ae kj" href="http://docs.sqlalchemy.org/en/latest/faq/sqlexpressions.html#how-do-i-render-sql-expressions-as-strings-possibly-with-bound-parameters-inlined" rel="noopener ugc nofollow" target="_blank">文档所说的</a>，SQLAlchemy进行查询字符串化的能力有限，所以不容易得到最终要执行的查询。您可以单独打印查询:</p><pre class="nd ne nf ng gt nh ni nj nk aw nl bi"><span id="2f77" class="nm ln iq ni b gy nn no l np nq">print(query)</span><span id="39cb" class="nm ln iq ni b gy nv no l np nq">SELECT  <br/>role_group_id, role_group_name, nr_patients  <br/>FROM "StaffSummary"  <br/>WHERE day &gt;= :day_1 AND day &lt;= :day_2 AND location_id = :location_id_1 AND service_id = :service_id_1</span></pre><p id="c29e" class="pw-post-body-paragraph kk kl iq km b kn lh kp kq kr li kt ku kv lj kx ky kz lk lb lc ld ll lf lg ki ij bi translated">(这个看起来没有那么可怕，但是对于更复杂的查询，它可能有大约20多个占位符，手动填充这些占位符非常烦人而且非常耗时，以便稍后在SQL控制台中播放。)</p><p id="9502" class="pw-post-body-paragraph kk kl iq km b kn lh kp kq kr li kt ku kv lj kx ky kz lk lb lc ld ll lf lg ki ij bi translated">如果您只有字符串和数字要插入到查询中，这将为您工作</p><pre class="nd ne nf ng gt nh ni nj nk aw nl bi"><span id="5097" class="nm ln iq ni b gy nn no l np nq">print(s.compile(compile_kwargs={"literal_binds": True}))</span></pre><p id="d909" class="pw-post-body-paragraph kk kl iq km b kn lh kp kq kr li kt ku kv lj kx ky kz lk lb lc ld ll lf lg ki ij bi translated">对于约会来说，这样的伎俩是行不通的。StackOverflow上有一个关于如何实现预期结果的讨论，但是解决方案看起来没有吸引力。</p><p id="48f3" class="pw-post-body-paragraph kk kl iq km b kn lh kp kq kr li kt ku kv lj kx ky kz lk lb lc ld ll lf lg ki ij bi translated">另一种选择是通过数据库配置将查询记录到文件中，但是在这种情况下，您可能会面临另一个问题；如果Django ORM也连接到这个数据库，就很难找到想要调试的查询。</p><h2 id="acab" class="nm ln iq bd lo nw nx dn ls ny nz dp lw kv oa ob ma kz oc od me ld oe of mi og bi translated">你可能也喜欢</h2><div class="oh oi gp gr oj ok"><a href="https://djangostars.com/blog/debugging-python-applications-with-pdb/?utm_source=medium&amp;utm_medium=itnext.io&amp;utm_campaign=djangoorm&amp;utm_content=you%20may%20also%20like1" rel="noopener  ugc nofollow" target="_blank"><div class="ol ab fo"><div class="om ab on cl cj oo"><h2 class="bd ir gy z fp op fr fs oq fu fw ip bi translated">用pdb调试Python应用程序</h2><div class="or l"><h3 class="bd b gy z fp op fr fs oq fu fw dk translated">调试并不是一个新技巧——大多数开发人员都在工作中积极地使用它。当然，每个人都有自己的方法…</h3></div><div class="os l"><p class="bd b dl z fp op fr fs oq fu fw dk translated">djangostars.com</p></div></div><div class="ot l"><div class="ou l ov ow ox ot oy jw ok"/></div></div></a></div><div class="oh oi gp gr oj ok"><a href="https://djangostars.com/blog/django-performance-optimization-tips/?utm_source=medium&amp;utm_medium=itnext.io&amp;utm_campaign=djangoorm&amp;utm_content=you%20may%20also%20like2" rel="noopener  ugc nofollow" target="_blank"><div class="ol ab fo"><div class="om ab on cl cj oo"><h2 class="bd ir gy z fp op fr fs oq fu fw ip bi translated">Django性能优化技巧</h2><div class="or l"><h3 class="bd b gy z fp op fr fs oq fu fw dk translated">当开发人员接到一个在Django上进行性能优化的任务时，我经常会遇到这种情况…</h3></div><div class="os l"><p class="bd b dl z fp op fr fs oq fu fw dk translated">djangostars.com</p></div></div><div class="ot l"><div class="oz l ov ow ox ot oy jw ok"/></div></div></a></div><h1 id="b948" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">测试</h1><p id="f233" class="pw-post-body-paragraph kk kl iq km b kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld mo lf lg ki ij bi translated">注意:Pytest <a class="ae kj" href="http://pytest-django.readthedocs.io/en/latest/database.html#tests-requiring-multiple-databases" rel="noopener ugc nofollow" target="_blank"> multidb注意</a>说“目前pytest-django没有明确支持django的多数据库支持。不过，您可以使用普通的Django TestCase实例来使用它的multi_db支持。”</p><p id="6e24" class="pw-post-body-paragraph kk kl iq km b kn lh kp kq kr li kt ku kv lj kx ky kz lk lb lc ld ll lf lg ki ij bi translated">那么这意味着什么——不支持？默认情况下，Django将为<code class="fe ns nt nu ni b">DATABASES</code>定义中列出的每个db创建并删除(在所有测试结束时)一个测试数据库。这个特性也能与<code class="fe ns nt nu ni b">pytests</code>完美配合。</p><p id="adcb" class="pw-post-body-paragraph kk kl iq km b kn lh kp kq kr li kt ku kv lj kx ky kz lk lb lc ld ll lf lg ki ij bi translated">Django <code class="fe ns nt nu ni b">TestCase</code>和<code class="fe ns nt nu ni b">TransactionTestCase</code>与<code class="fe ns nt nu ni b">multi_db=True</code>能够在测试之间清除多个数据库中的数据。也可以通过<code class="fe ns nt nu ni b">django-fixtures</code>将数据加载到第二个数据库中，但最好使用<a class="ae kj" href="https://model-mommy.readthedocs.io/en/latest/basic_usage.html" rel="noopener ugc nofollow" target="_blank">型号<em class="nr">妈咪</em> </a> <em class="nr">或</em> <a class="ae kj" href="https://model-mommy.readthedocs.io/en/latest/basic_usage.html" rel="noopener ugc nofollow" target="_blank"> <em class="nr">工厂</em>男孩</a>来代替，它们不受该属性的影响。</p><p id="03c3" class="pw-post-body-paragraph kk kl iq km b kn lh kp kq kr li kt ku kv lj kx ky kz lk lb lc ld ll lf lg ki ij bi translated">在<a class="ae kj" href="https://github.com/pytest-dev/pytest-django/issues/76" rel="noopener ugc nofollow" target="_blank"> pytest-django讨论</a>中有一些建议如何解决这个问题并使<code class="fe ns nt nu ni b">multi_db</code>能够继续pytesting。</p><p id="8f3e" class="pw-post-body-paragraph kk kl iq km b kn lh kp kq kr li kt ku kv lj kx ky kz lk lb lc ld ll lf lg ki ij bi translated">有一个重要的建议——对于有Django模型的表，您应该通过Django-ORM将数据保存到DB。否则，您将在编写测试时面临问题。<code class="fe ns nt nu ni b">TestCase</code>将无法回滚在Django DB连接之外发生的其他事务。如果您遇到这种情况，您可以将<code class="fe ns nt nu ni b">TransactionalTestCase</code>与<code class="fe ns nt nu ni b">multi_db=True</code>一起用于触发功能的测试，这将通过SQLAlchemy连接产生DB写入，但是请记住，这种测试比常规的<code class="fe ns nt nu ni b">TestCase</code>要慢。</p><p id="97c0" class="pw-post-body-paragraph kk kl iq km b kn lh kp kq kr li kt ku kv lj kx ky kz lk lb lc ld ll lf lg ki ij bi translated">另外，另一个场景也是可能的——您只有一个数据库中的Django-models，并且您通过SQLAlchemy使用第二个数据库。这种情况下，<code class="fe ns nt nu ni b">multi_db</code>根本不影响你。在这种情况下，您需要编写一个pytest-fixture(或者在<code class="fe ns nt nu ni b">setUp</code>中作为mixin和触发器逻辑，如果您使用unittests的话),它将从SQL文件创建DB结构。这样的文件应该在<code class="fe ns nt nu ni b">CREATE TABLE</code>之前包含<code class="fe ns nt nu ni b">DROP TABLE IF EXISTS</code>语句。这个fixture应该被应用到每个操作这个数据库的测试用例中。其他设备可以将数据加载到创建的表中。</p><p id="e4e4" class="pw-post-body-paragraph kk kl iq km b kn lh kp kq kr li kt ku kv lj kx ky kz lk lb lc ld ll lf lg ki ij bi translated">注意:这样的测试会比较慢，因为每次测试都要重新创建表。理想情况下，应该创建一次表(声明为<code class="fe ns nt nu ni b">@pytest.fixture(scope='session', autouse=True)</code>)，并且每个事务应该回滚每个测试的数据。这并不容易实现，因为不同的连接:Django &amp; SQLAlchemy或SQLAlchemy连接池的不同连接，例如，在您的测试中，您启动事务，用测试数据填充DB，然后运行测试并回滚事务(它没有被提交)。但是在测试过程中，您的应用程序代码可能会像connection.execute(query)一样对数据库进行查询，这些查询是在创建测试数据的事务之外执行的。因此，使用默认的事务隔离级别，应用程序将看不到任何数据，只能看到空表。对于SQLAlchemy连接，可以将事务隔离级别更改为<code class="fe ns nt nu ni b">READ UNCOMMITTED</code>，一切都将按预期工作，但这绝对不是一个解决方案。</p><h1 id="1fd7" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">结论</h1><p id="20aa" class="pw-post-body-paragraph kk kl iq km b kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld mo lf lg ki ij bi translated">综上所述，SQLAlchemy Core是一个很棒的工具，它让您更接近SQL，并让您理解和完全控制查询。如果您正在构建需要高级聚合的应用程序(或其中的一部分),那么作为Django ORM工具的替代，值得一试SQLAlchemy核心功能。</p><p id="02da" class="pw-post-body-paragraph kk kl iq km b kn lh kp kq kr li kt ku kv lj kx ky kz lk lb lc ld ll lf lg ki ij bi translated">请继续阅读，了解如何更轻松地为数据分析项目构建高级查询。了解我们如何设法混合Django ORM和SQLAlchemy Core，以及我们从中获得了什么。</p><figure class="nd ne nf ng gt jr gh gi paragraph-image"><a href="https://djangostars.com/services/python-django-development/?utm_source=medium&amp;utm_medium=itnext.io&amp;utm_campaign=djangoorm&amp;utm_content=banner_end"><div class="gh gi pa"><img src="../Images/45a1ce60def7b50ffe2311c7a897d600.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DdZ7gDbH7I9rnq7Z2xauiA.png"/></div></a></figure><blockquote class="pb pc pd"><p id="7b16" class="kk kl nr km b kn lh kp kq kr li kt ku pe lj kx ky pf lk lb lc pg ll lf lg ki ij bi translated">这篇关于<a class="ae kj" href="https://djangostars.com/blog/merging-django-orm-with-sqlalchemy-for-easier-data-analysis/?utm_source=medium&amp;utm_medium=itnext.io&amp;utm_campaign=djangoorm&amp;utm_content=Merging%20Django%20ORM" rel="noopener ugc nofollow" target="_blank"> <strong class="km ir">合并Django ORM </strong> </a>的文章最初发布在<strong class="km ir"> Django Stars博客</strong>上。</p></blockquote><blockquote class="jy"><p id="b4ea" class="jz ka iq bd kb kc kd ke kf kg kh ki dk translated">如果你觉得这篇文章有用，请点击👏下面的按钮:)</p></blockquote><figure class="ph pi pj pk pl jr"><div class="bz fp l di"><div class="pm pn l"/></div></figure></div></div>    
</body>
</html>