<html>
<head>
<title>An Object-Oriented pattern for JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript的面向对象模式</h1>
<blockquote>原文：<a href="https://itnext.io/an-object-oriented-pattern-for-javascript-54e80b9e8cc8?source=collection_archive---------1-----------------------#2018-09-07">https://itnext.io/an-object-oriented-pattern-for-javascript-54e80b9e8cc8?source=collection_archive---------1-----------------------#2018-09-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/eb3fe2aa9626fd10614ef8162263ffbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2fAzTN2OUulEGLg4ALEKGA.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">在图案中定向的对象</figcaption></figure><p id="510a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">JavaScript绝对不是传统的面向对象语言，不管它看起来有多像。它属于一种叫做“<a class="ae la" href="https://en.wikipedia.org/wiki/Prototype-based_programming" rel="noopener ugc nofollow" target="_blank">原型</a>语言的类，在这种语言中只有对象，没有类，一个叫做“委托”的过程代替了OO程序员所理解的继承。</p><p id="5d42" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="lb">(作为题外话，这类语言包括漂亮极简的</em><a class="ae la" href="https://www.lua.org/" rel="noopener ugc nofollow" target="_blank"><em class="lb">【Lua】</em></a><em class="lb">，如果你通过奇妙的</em><a class="ae la" href="https://love2d.org/" rel="noopener ugc nofollow" target="_blank"><em class="lb">love 2d</em></a><em class="lb">框架做过游戏编程，你可能会遇到过)。</em></p><p id="ace5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">因此，来自传统面向对象背景的我们这些老家伙有时很难正确地思考这种语言。当我第一次开始为真正的浏览器编写JavaScript时(即不仅仅是为HTML添加一些装饰，而是适当的客户端软件开发)，我发现很难得到好的建议和例子来以一种我可以理解的方式组织我的代码，并让我在一个新的环境中获得我多年的OO经验。</p><p id="177e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我阅读了“<a class="ae la" href="https://www.amazon.co.uk/JavaScript-Good-Parts-Douglas-Crockford/dp/0596517742" rel="noopener ugc nofollow" target="_blank"> JavaScript:好的部分</a>”，并获得了一些关于对象构造的提示，但有几种方法可以做到这一点，似乎没有一种方法是<strong class="ke ir">的</strong>方法，所有的方法都感觉很尴尬。经过大量的反复试验，我已经确定了一种编程模式，这种模式允许我以面向对象程序员非常熟悉的风格编写我的JavaScript，同时仍然利用JavaScript在客户端为我们提供的所有好处。这篇文章概述了这种风格。</p><p id="a046" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我意识到有很多方法可以达到类似的目标。当然，这是编程的本质。你可以使用<a class="ae la" href="https://coffeescript.org/" rel="noopener ugc nofollow" target="_blank"><em class="lb">Coffee Script</em></a><em class="lb">或者其他</em> <a class="ae la" href="https://github.com/jashkenas/coffeescript/wiki/list-of-languages-that-compile-to-js" rel="noopener ugc nofollow" target="_blank"> <em class="lb"> JavaScript元语言</em> </a> <em class="lb">中的任何一种，或者你可以从其他角度用纯JavaScript来解决同样的问题。我在这里提出的绝不是唯一的方法，但如果它符合你的思维方式，可能对你有价值)。</em></p><h1 id="bc40" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">命名空间</h1><p id="8c54" class="pw-post-body-paragraph kc kd iq ke b kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv me kx ky kz ij bi translated">如果您来自Java或Python之类的语言，您将习惯于可以从中导入特性的包或模块。JavaScript并没有这个特性，但是我们可以模仿它，使用类似字典的结构来组织我们的代码。例如，假设我们想要定义一个名为<code class="fe mf mg mh mi b">ooj</code>(面向对象的JavaScript)的模块，并用对象和函数填充它，那么我们可以这样做:</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="8f7d" class="mr ld iq mi b gy ms mt l mu mv">var ooj = {<br/>  MyObject : function() {}<br/>  myFunction : function() {}<br/>}</span></pre><p id="e1b9" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">然后，您可以通过引用完整的名称空间或包路径:<code class="fe mf mg mh mi b">ooj.MyObject</code>或<code class="fe mf mg mh mi b">ooj.myFunction</code>来访问这个模块的元素。</p><h1 id="8335" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">“类”和对象构造</h1><p id="6802" class="pw-post-body-paragraph kc kd iq ke b kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv me kx ky kz ij bi translated">JavaScript有一个<code class="fe mf mg mh mi b">new</code>关键字，它从一个函数构造一个新的对象。不过，提供一个函数作为构造函数来包装构造机制是很常见的。下面是一个简单的函数构造另一个对象的例子:</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="616d" class="mr ld iq mi b gy ms mt l mu mv">var ooj = {<br/>  newMagicObject : function(params) {<br/>    return new ooj.MagicObject(params)<br/>  }</span><span id="e528" class="mr ld iq mi b gy mw mt l mu mv">  MagicObject : function(params) {<br/>    // object implementation<br/>  }<br/>}</span></pre><p id="ea13" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">要获得<code class="fe mf mg mh mi b">MagicObject</code>的实例，我们只需要调用<code class="fe mf mg mh mi b">ooj.newMagicObject()</code>。这使用<code class="fe mf mg mh mi b">new</code>关键字和提供的<code class="fe mf mg mh mi b">params</code>实例化了<code class="fe mf mg mh mi b">MagicObject</code>。现在这看起来微不足道，但是不久我们将使构造函数更加复杂，这种分离将变得值得。</p><h1 id="dfda" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated"><strong class="ak">方法和属性</strong></h1><p id="7872" class="pw-post-body-paragraph kc kd iq ke b kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv me kx ky kz ij bi translated">一旦我们以这种方式定义了我们的对象和它们的构造，我们就可以用一种对开发人员非常友好的方式编写内部结构。</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="81d7" class="mr ld iq mi b gy ms mt l mu mv">MagicObject : function(params) {<br/>  this.passedParameter = params.passedParameter;<br/>  this._internalAttribute = "internal attribute";</span><span id="37e6" class="mr ld iq mi b gy mw mt l mu mv">  this.init = function() {<br/>    // initialise this object<br/>  }</span><span id="f2f8" class="mr ld iq mi b gy mw mt l mu mv">  this.method = function() {<br/>    // instance method<br/>  }</span><span id="610d" class="mr ld iq mi b gy mw mt l mu mv">  this.init();<br/>}</span></pre><p id="0510" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们简单地用<code class="fe mf mg mh mi b">this</code>作为所有内部属性的前缀，在对象实例上设置它们。因为JavaScript不关心你给对象附加什么样的属性，所以我们可以把它用于属性和方法。在构造对象后，调用者可以使用所有这些属性:</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="0796" class="mr ld iq mi b gy ms mt l mu mv">var mo = ooj.newMagicObject({passedParameter: "hello"});<br/>console.log(mo.passedParameter);<br/>mo.method();</span></pre><p id="9099" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">没有像Java中那样的<strong class="ke ir"> public </strong>和<strong class="ke ir"> private </strong>属性的概念，我采用了Pythonic式的方法，在内部的、本质上是私有的属性前面加上一个下划线，像<code class="fe mf mg mh mi b">_internalAttribute</code>。</p><p id="3793" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">最后要注意的是，对象定义以调用<code class="fe mf mg mh mi b">this.init()</code>结束。我决定在对象本身中包含特定于对象的初始化，而不是在构造函数中。这意味着构造函数可以非常纯粹和简单，并且不太了解对象的实际内部结构。代价是你要负责在对象定义的末尾调用任何初始化函数<em class="lb">。</em></p><h1 id="ade2" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">继承和对超级的调用</h1><p id="8e22" class="pw-post-body-paragraph kc kd iq ke b kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv me kx ky kz ij bi translated">接下来，我们想添加一些继承的概念，在构造之前，我们通过将类的<code class="fe mf mg mh mi b">prototype</code>指定给父类的<em class="lb">实例</em>来实现。当我们这样做的时候，父类上任何没有被子类覆盖的函数都会在调用子类时被执行。<code class="fe mf mg mh mi b">this</code>的上下文和代码的整体行为将完全等同于传统的OO对象:</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="ef45" class="mr ld iq mi b gy ms mt l mu mv">var ooj = {<br/>  newBaiscObject : function(params) {<br/>    return new ooj.BasicObject();<br/>  },<br/>  BasicObject : function(params) {<br/>    // parent object<br/>    this.basicFunction = function() {}<br/>  }</span><span id="6fb4" class="mr ld iq mi b gy mw mt l mu mv">  newMagicObject : function(params) {<br/>    ooj.MagicObject.prototype = ooj.newBasicObject();<br/>    return new ooj.MagicObject(params)<br/>  }<br/>  MagicObject : function(params) {<br/>    // child object<br/>    this.magicFunction = function() {}<br/>  }<br/>}</span></pre><p id="c36f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在，当我们构造一个<code class="fe mf mg mh mi b">newMagicObject</code>时，我们得到一个<code class="fe mf mg mh mi b">MagicObject</code>，它的原型是<code class="fe mf mg mh mi b">BasicObject</code>。这意味着我们可以做到:</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="225e" class="mr ld iq mi b gy ms mt l mu mv">var mo = ooj.newMagicObject()<br/>mo.basicFunction()</span></pre><p id="c7ce" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">注意<code class="fe mf mg mh mi b">BasicObject</code>可以反过来定义它自己的原型，等等，只要你需要。这提供了一个任意深度的单一继承模型。</p><p id="7f78" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">最后，我们需要引入在父对象上调用函数的概念。到目前为止，当子对象覆盖函数时，子对象完全屏蔽了父对象的行为。如果我们的<code class="fe mf mg mh mi b">MagicObject</code>覆盖了上面的<code class="fe mf mg mh mi b">basicFunction</code>，那么就不再可能访问<code class="fe mf mg mh mi b">BasicObject</code>上的<code class="fe mf mg mh mi b">basicFunction</code>的实现。</p><p id="98fe" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">为了调用父对象的实现，我们需要能够向父对象的不同实例发送函数调用，但是使用正确的<code class="fe mf mg mh mi b">this</code>值。我们将重构上面所做的，并引入一个处理对象构造的<code class="fe mf mg mh mi b">instantiate</code>函数。在这个函数中，我们还将存储一个对父对象的构造函数的引用，这样我们以后可以再次使用它。</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="4c55" class="mr ld iq mi b gy ms mt l mu mv">instantiate : function(clazz, params, protoConstructor) {<br/>    if (params === undefined) { params = {} }<br/>    if (protoConstructor) {<br/>        clazz.prototype = protoConstructor(params);<br/>    }<br/>    var inst = new clazz(params);<br/>    if (protoConstructor) {<br/>        inst.__proto_constructor__ = protoConstructor;<br/>    }<br/>    return inst;<br/>}</span></pre><p id="593d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这将执行以下操作:</p><ul class=""><li id="b45c" class="mx my iq ke b kf kg kj kk kn mz kr na kv nb kz nc nd ne nf bi translated">设置<code class="fe mf mg mh mi b">params</code>(如果尚未设置)</li><li id="c178" class="mx my iq ke b kf ng kj nh kn ni kr nj kv nk kz nc nd ne nf bi translated">构造原型并将其附加到未实例化的对象(我们现在认为它是一个“类”)</li><li id="50c0" class="mx my iq ke b kf ng kj nh kn ni kr nj kv nk kz nc nd ne nf bi translated">用关键字<code class="fe mf mg mh mi b">new</code>构造新的对象</li><li id="19a8" class="mx my iq ke b kf ng kj nh kn ni kr nj kv nk kz nc nd ne nf bi translated">在新对象实例<code class="fe mf mg mh mi b">__proto_constructor__</code>的自定义变量中附加对原型构造函数的引用。</li></ul><p id="3309" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在我们可以稍微简化和改进我们的<code class="fe mf mg mh mi b">ooj</code>库:</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="b234" class="mr ld iq mi b gy ms mt l mu mv">var ooj = {<br/>  instantiate : function(...) { ... }</span><span id="8738" class="mr ld iq mi b gy mw mt l mu mv">  newBaiscObject : function(params) {<br/>    return ooj.instantiate(ooj.BasicObject, params)<br/>  },<br/>  BasicObject : function(params) {<br/>    // parent object<br/>  }</span><span id="cacd" class="mr ld iq mi b gy mw mt l mu mv">  newMagicObject : function(params) {<br/>    return ooj.instantiate(ooj.MagicObject, <br/>                           params, <br/>                           ooj.newBasicObject)<br/>  }<br/>  MagicObject : function(params) {<br/>    // child object<br/>  }<br/>}</span></pre><p id="69ae" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">当我们调用<code class="fe mf mg mh mi b">newMagicObject</code>时，它将在属性<code class="fe mf mg mh mi b">__proto_constructor__</code>中引用<code class="fe mf mg mh mi b">ooj.newBasicObject</code>。</p><p id="45d4" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在我们准备实现对父类的调用:</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="6397" class="mr ld iq mi b gy ms mt l mu mv">up : function(inst, fn, args) {<br/>    var parent = inst.__proto_constructor__();<br/>    parent[fn].apply(inst, args);<br/>},</span></pre><p id="c922" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">当我们想要调用原型上的任何函数时，我们必须实例化原型的一个新实例，通过<code class="fe mf mg mh mi b">__proto_constructor__</code>中的函数，然后是<code class="fe mf mg mh mi b">apply</code>中的参数。这确保了<code class="fe mf mg mh mi b">this</code>仍然是对当前实例的引用，而不是对新实例的引用，所以应用到对象的任何更改都是对正确的对象进行的。</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="e037" class="mr ld iq mi b gy ms mt l mu mv">var ooj = {<br/>  instantiate: function(...) { ... },<br/>  up : function(...) { ... },</span><span id="6048" class="mr ld iq mi b gy mw mt l mu mv">  newBaiscObject : function(params) {<br/>    return ooj.instantiate(ooj.BasicObject, params)<br/>  },<br/>  BasicObject : function(params) {<br/>    this.basicFunction = function(args) {<br/>      console.log("upped!")<br/>    }<br/>  }</span><span id="1778" class="mr ld iq mi b gy mw mt l mu mv">  newMagicObject : function(params) {<br/>    return ooj.instantiate(ooj.MagicObject, <br/>                           params, <br/>                           ooj.newBasicObject)<br/>  }<br/>  MagicObject : function(params) {<br/>    this.basicFunction = function(args) {<br/>      ooj.up(this, "basicFunction", args)<br/>    }<br/>  }<br/>}</span></pre><p id="74bc" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">当我们在<code class="fe mf mg mh mi b">MagicObject</code>上执行<code class="fe mf mg mh mi b">basicFunction</code>时，它也会在<code class="fe mf mg mh mi b">BasicObject</code>上执行<code class="fe mf mg mh mi b">basicFunction</code>，并打印到控制台:</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="a09c" class="mr ld iq mi b gy ms mt l mu mv">var mo = ooj.newMagicObject()<br/>mo.basicFunction()</span><span id="1198" class="mr ld iq mi b gy mw mt l mu mv">&gt;&gt;&gt; "upped!"</span></pre><h1 id="8d35" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">在上下文中调用对象方法</h1><p id="119b" class="pw-post-body-paragraph kc kd iq ke b kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv me kx ky kz ij bi translated">当你在处理程序性的代码时，所有这些面向对象的东西都很棒，但是JavaScript不是这样的。函数在异步上下文中被调用，如事件、AJAX请求、定时执行(例如使用<code class="fe mf mg mh mi b">setTimeout</code>)，或者作为任意进程中的回调。在这些情况下，我们如何在正确的上下文中调用特定对象实例上的特定方法呢？如果我们能够做到这一点，我们将发现自己拥有一种非常强大的方法，可以使用对象将应用程序状态保存在内存中，这些对象可以直接响应外部调用，从而使我们能够将页面元素与控制它们的对象直接关联起来。</p><p id="1ca9" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">实现这一点的方法是使用一个闭包，来保存对对象的引用以及事件被触发时要调用的方法。</p><p id="9ec3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们应该讨论两种方法:</p><ol class=""><li id="e085" class="mx my iq ke b kf kg kj kk kn mz kr na kv nb kz nl nd ne nf bi translated">实际处理事件的方法</li><li id="e048" class="mx my iq ke b kf ng kj nh kn ni kr nj kv nk kz nl nd ne nf bi translated">由任意外部进程使用指定参数调用的方法</li></ol><p id="718b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">第一个很简单:</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="732e" class="mr ld iq mi b gy ms mt l mu mv">eventClosure : function(obj, fn) {<br/>    return function(event) {<br/>        event.preventDefault();<br/>        obj[fn](this);<br/>    }<br/>}</span></pre><p id="9b80" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这在对象和函数名周围创建了一个闭包，然后当事件处理程序收集事件时，它可以将事件直接传递给对象。例如(使用jQuery进行事件绑定):</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="d490" class="mr ld iq mi b gy ms mt l mu mv">var ooj = {<br/>  eventClosure : function(...) { ... }</span><span id="f9d9" class="mr ld iq mi b gy mw mt l mu mv">  newMagicObject : function(params) { ... }<br/>  MagicObject : function(params) {<br/>    this.clickHandler = function(event) {<br/>      // do stuff with the event itself<br/>    }<br/>  }<br/>}</span><span id="a3a3" class="mr ld iq mi b gy mw mt l mu mv">var mo = ooj.newMagicObject();<br/>$(".mylink").on("click", ooj.eventClosure(mo, "clickHandler"))</span></pre><p id="98c0" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">更普遍使用的第二个闭包要求我们更多地考虑如何处理参数。通常我们更喜欢在类似于<code class="fe mf mg mh mi b">params</code>字典的对象中使用参数，但是异步过程(比如AJAX请求，或者第三方库中的回调)可能有自己的做事方式。这是一个创建闭包的函数，它为我们提供了几种智能处理参数的方法:</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="834c" class="mr ld iq mi b gy ms mt l mu mv">methodClosure : function(obj, fn, args) {<br/>    return function() {<br/>        if (args) {<br/>            var params = {};<br/>            for (var i = 0; i &lt; args.length; i++) {<br/>                if (arguments.length &gt; i) {<br/>                    params[args[i]] = arguments[i];<br/>                }<br/>            }<br/>            obj[fn](params);<br/>        } else {<br/>            var theArgs = Array.prototype.slice.apply(arguments);<br/>            obj[fn].apply(obj, theArgs);<br/>        }<br/>    }<br/>}</span></pre><p id="3771" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">首先看这个函数的后半部分，如果闭包没有给出一个<code class="fe mf mg mh mi b">args</code>参数，这意味着我们将按原样传递来自调用者的参数。在这种情况下，我们只需利用函数中的<code class="fe mf mg mh mi b">arguments</code>属性，将它们转换成数组，并在正确的上下文中将它们应用于对象上的函数。因此</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="3d2f" class="mr ld iq mi b gy ms mt l mu mv">methodClosure(this, "function")(arg1, arg2, arg3)</span></pre><p id="4399" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">导致调用:</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="74c6" class="mr ld iq mi b gy ms mt l mu mv">this.function(arg1, arg2, arg3)</span></pre><p id="e516" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">但是，如果我们为闭包提供了<code class="fe mf mg mh mi b">args</code>参数，那么调用者提供的参数将与参数值一一匹配，并转换成一个字典(忽略任何额外的参数)。所以:</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="d74a" class="mr ld iq mi b gy ms mt l mu mv">methodClosure(this, "function", ["one", "two"])(arg1, arg2, arg3)</span></pre><p id="98f5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">导致调用:</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="4cc4" class="mr ld iq mi b gy ms mt l mu mv">this.function({one: arg1, two: arg2})</span></pre><p id="731c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在我们可以创建闭包并将其传递给我们喜欢的任何流程:</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="85b3" class="mr ld iq mi b gy ms mt l mu mv">var ooj = {<br/>  methodClosure : function(...) { ... }</span><span id="fcf1" class="mr ld iq mi b gy mw mt l mu mv">  newMagicObject : function(params) { ... }<br/>  MagicObject : function(params) {<br/>    this.doMagic = function(params) {<br/>      console.log(params.abera);<br/>      console.log(params.cadabera);<br/>    }<br/>  }<br/>}</span><span id="c41d" class="mr ld iq mi b gy mw mt l mu mv">var mo = ooj.newMagicObject();<br/>var callback = ooj.methodClosure(mo, "doMagic", <br/>                                 ["abera", "cadabera"]);<br/>someAsyncFunction(callback);</span></pre></div><div class="ab cl nm nn hu no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="ij ik il im in"><p id="e7bb" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">使用这种整体模式和少量支持代码，我们实现了以下目标:</p><ul class=""><li id="608c" class="mx my iq ke b kf kg kj kk kn mz kr na kv nb kz nc nd ne nf bi translated">一个干净的对象构造模式</li><li id="3c50" class="mx my iq ke b kf ng kj nh kn ni kr nj kv nk kz nc nd ne nf bi translated">支持调用父类的单一继承机制</li><li id="355a" class="mx my iq ke b kf ng kj nh kn ni kr nj kv nk kz nc nd ne nf bi translated">以清晰一致的方式声明对象属性和方法的能力</li><li id="df6a" class="mx my iq ke b kf ng kj nh kn ni kr nj kv nk kz nc nd ne nf bi translated">一种将事件直接传递给对象的方式</li><li id="7fdd" class="mx my iq ke b kf ng kj nh kn ni kr nj kv nk kz nc nd ne nf bi translated">一种通过适当的参数处理将任意异步/解耦请求传递给对象中特定方法的方式</li></ul><p id="77aa" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">此外，在后台有一个隐藏的要求，即这些对象应该在您的普通浏览器JavaScript控制台和调试器中表现良好。这种方法正是这样做的，当我们在断点上暂停时，您可以从调用堆栈中看到，您可以清楚地看到代码中的位置和对象类型:</p><figure class="mj mk ml mm gt jr gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/b8c99e27954064e675cf5c83e2da49dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1258/format:webp/1*7gzwL9pKWmnDtcghN1QaaA.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">暂停在断点上查看对象时调用堆栈</figcaption></figure><p id="f593" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">将来我会写一篇博文，提供一些真实世界的工作示例，让您感受到这种方法与良好的代码组织相结合的强大力量。</p><p id="3dee" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="lb">理查德是</em> <a class="ae la" href="https://cottagelabs.com" rel="noopener ugc nofollow" target="_blank"> <em class="lb">山寨实验室</em> </a> <em class="lb">的创始人和高级合伙人，这是一家专注于数据生命周期所有方面的软件开发咨询公司。他偶尔会在推特上发</em><a class="ae la" href="https://twitter.com/richard_d_jones" rel="noopener ugc nofollow" target="_blank"><em class="lb">@ Richard _ d _ Jones</em></a></p></div></div>    
</body>
</html>