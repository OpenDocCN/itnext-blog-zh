<html>
<head>
<title>Building and deploying Gatsby sites with GitHub actions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用GitHub操作构建和部署Gatsby站点</h1>
<blockquote>原文：<a href="https://itnext.io/building-and-deploying-gatsby-sites-with-github-actions-97f7387551ca?source=collection_archive---------6-----------------------#2019-10-10">https://itnext.io/building-and-deploying-gatsby-sites-with-github-actions-97f7387551ca?source=collection_archive---------6-----------------------#2019-10-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/ea8a0b3639787a039b80e54bbe44e2b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PbV7w68m9xqoposPkQJlrw.png"/></div></div></figure><p id="97b3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">GitHub actions目前处于<a class="ae kw" href="https://github.com/features/actions" rel="noopener ugc nofollow" target="_blank"> beta </a>阶段，我是有幸获得beta版的人之一。出于各种原因，我决定将我的博客的整个构建过程切换到GitHub actions——让我们来谈谈为什么以及如何用actions构建和部署Gatsby站点。</p><h1 id="d45d" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">为什么呢？</h1><p id="3ca0" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">如果你只是对实际的指南感兴趣，你可以跳过这一部分——但我想解释为什么彻底检查我的构建过程——和这篇文章——从来没有计划过，为什么它们仍然是强制性的。</p><p id="b414" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">已经一个多月没有新帖子了。但不是因为我没有写任何新帖子——事实上我甚至发布了一些新帖子——他们只是从未见过世面。<em class="ma">什么？！</em></p><p id="cde2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">与许多Gatsby网站不同，我没有托管在Netlify、GitHub页面或任何其他官方文件中描述的托管选项上。我的博客和所有相关工具(评论系统，时事通讯等。)都托管在<a class="ae kw" href="https://uberspace.de/en/" rel="noopener ugc nofollow" target="_blank"> Uberspace </a>上。我真的很喜欢他们，由于他们的大力支持，一个伟大的<a class="ae kw" href="https://uberspace.de/en/product/#prices" rel="noopener ugc nofollow" target="_blank">定价模型</a>可能会被采纳到你的预算中，事实上我可以用SSH访问服务器并且可以自己做很多事情。在控制你的服务器方面没有花哨的界面，大多数事情都是在你的控制台上完成的——我喜欢它。</p><p id="d82c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我换成盖茨比的时候，我需要做一些工作，以便在我发布新帖子的时候能够自动重建我的博客。这项工作包括一个webhook，它触发了一个简单的shell脚本，该脚本在每次被调用时都会重新构建和部署我的站点。负责构建和部署站点的shell脚本非常简单:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="951c" class="mk ky iq mg b gy ml mm l mn mo">#!/bin/bash</span><span id="280a" class="mk ky iq mg b gy mp mm l mn mo">set -o errexit</span><span id="1d9e" class="mk ky iq mg b gy mp mm l mn mo">cd ~/blog<br/>rm -rf .cache</span><span id="40bc" class="mk ky iq mg b gy mp mm l mn mo">if [ "$1" == "fully" ]; then<br/>  rm -rf node_modules<br/>  git pull<br/>  ~/.yarn/bin/yarn install --production=true --pure-lockfile<br/>fi</span><span id="143b" class="mk ky iq mg b gy mp mm l mn mo">~/bin/gatsby build<br/>rm -rf ~/blog_backup<br/>cp -R &lt;path&gt;/html ~/blog_backup<br/>rsync -avu --delete ~/blog/public/ ~/html</span></pre><p id="a179" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有时(主要是在添加新功能时)我需要完全重建博客，包括从Git获取新的源文件和安装新的依赖项。因为这需要很长时间，所以它是可选的，可以在执行脚本时通过可选的<code class="fe mq mr ms mg b">fully</code>参数触发。</p><p id="8a10" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个脚本是调用webhook时执行的脚本链的一部分。webhook本身调用了一个脚本，该脚本将上述脚本的输出传送到一个文件中，该文件在完成后会给我发送一封邮件。这样，每当触发重建时，我可以很容易地检查是否一切正常。</p><p id="e5d0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于现场控制台输出之类的东西来说，这不是一个花哨的解决方案，但它确实有效。</p><h1 id="3d82" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">问题是</h1><p id="f977" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">发布关于<a class="ae kw" href="https://nehalist.io/software-spotlight-tmux" rel="noopener ugc nofollow" target="_blank"> tmux </a>的帖子一周后，我想发布一个新帖子。大多数时间，我点击“发布”按钮后大约十分钟，网络钩子就完成了，我收到了邮件，告诉我一切都很顺利，我的博客也更新了最新的帖子。</p><p id="dcf1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="ma">这次不行。</em></p><p id="145a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将近一个小时后，仍然没有邮件，我进入我的服务器，查看发生了什么。最后一次构建的输出是:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="5b87" class="mk ky iq mg b gy ml mm l mn mo">[&lt;user&gt;@&lt;server&gt; blog]$ ~/bin/gatsby build<br/>success open and validate gatsby-configs - 1.622 s<br/>success load plugins - 22.156 s<br/>success onPreInit - 0.018 s<br/>success delete html and css files from previous builds - 0.261 s<br/>success initialize cache - 0.020 s<br/>success copy gatsby files - 0.575 s<br/>success onPreBootstrap - 0.098 s<br/>success source and transform nodes - 0.861 s<br/>success building schema - 1.085 s<br/>success createPages - 0.284 s<br/>success createPagesStatefully - 0.146 s<br/>success onPreExtractQueries - 0.012 s<br/>success update schema - 0.037 s<br/>success extract queries from components - 0.432 s<br/>success write out requires - 0.007 s<br/>success write out redirect data - 0.003 s<br/>success Build manifest and related icons - 0.921 s<br/>success onPostBootstrap - 1.478 s<br/>⠀<br/>info bootstrap finished - 92.619 s<br/>⠀<br/>success run static queries - 0.036 s — 3/3 101.33 queries/second<br/>⠼ Building production JavaScript and CSS bundles<br/>Killed</span></pre><p id="0a3a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="ma">被杀？对不起，小家伙。</em></p><p id="f07b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">经过一番<a class="ae kw" href="https://manual.uberspace.de/basics-resources.html" rel="noopener ugc nofollow" target="_blank">研究</a>后，我发现Uberpsace会杀死占用超过1.5 GB内存的进程。额外的研究表明，我的构建过程在这一点上占用了高达1.7 GB的内存，这也是它被终止的原因。</p><p id="3928" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我联系了Uberspace的支持者，他们建议使用<code class="fe mq mr ms mg b">--max-old-space-size=1024</code>标志来防止Node占用太多的内存——但遗憾的是，这没有成功。我明白一个主持人不能提供一个无止境的记忆来源-但这确实是一个大问题；此时我无法改变我博客上的任何东西。</p><p id="fe39" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我不得不重新思考我的整个构建过程。我查找了不同的选项，比如AWS、GitHub页面，甚至是本地构建和通过容器部署——但是它们都有一些我不习惯的缺点。</p><p id="cfb5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在某个时候，我想用GitHub的动作来建立我的博客并将其部署到Uberspace。这将提供每月2000分钟的构建时间，以及高达<a class="ae kw" href="https://help.github.com/en/articles/virtual-environments-for-github-actions#supported-virtual-environments-and-hardware-resources" rel="noopener ugc nofollow" target="_blank"> 7 GB的内存</a>——这肯定可以完成任务。</p><p id="7a32" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">经过一些工作，我的博客终于完成了:我的博客现在通过行动在GitHub上建立(并测试)，最后被部署到我的Uberspace上，这意味着我现在可以重新开始写内容了。<em class="ma">万岁！</em></p><h1 id="a64c" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">GitHub操作</h1><p id="d9ec" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">我的GitHub操作包括一个多步骤的工作，从签出存储库到通过Docker和<code class="fe mq mr ms mg b">rsnyc</code>部署构建的站点。</p><p id="16b6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们来看看工作流程(位于<code class="fe mq mr ms mg b">.github/workflows/workflow.yml</code>):</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="b8dc" class="mk ky iq mg b gy ml mm l mn mo">name: Update blog</span><span id="ae24" class="mk ky iq mg b gy mp mm l mn mo">on: [push, repository_dispatch]</span><span id="477d" class="mk ky iq mg b gy mp mm l mn mo">jobs:<br/>  update:<br/>    runs-on: ubuntu-latest<br/>    steps:<br/>      - uses: actions/checkout@v1</span><span id="1de9" class="mk ky iq mg b gy mp mm l mn mo">- name: Set Node.js<br/>        uses: actions/setup-node@master<br/>        with:<br/>          node-version: 10.x</span><span id="f1b0" class="mk ky iq mg b gy mp mm l mn mo">- name: Install dependencies<br/>        run: yarn install --prod --pure-lockfile</span><span id="799f" class="mk ky iq mg b gy mp mm l mn mo">- name: Lint<br/>        run: yarn run lint</span><span id="63fc" class="mk ky iq mg b gy mp mm l mn mo">- name: Build<br/>        run: yarn run build<br/>        env:<br/>          GHOST_API_URL: "<a class="ae kw" href="https://ghost.nehalist.io" rel="noopener ugc nofollow" target="_blank">https://ghost.nehalist.io</a>"<br/>          GHOST_CONTENT_API_KEY: ${{ secrets.ghost_content_api_key }}<br/>          GATSBY_ENV: "prod"<br/>          GATSBY_CARRAWAY_URL: "<a class="ae kw" href="https://carraway.nehalist.io" rel="noopener ugc nofollow" target="_blank">https://carraway.nehalist.io</a>"<br/>          GATSBY_COMMENTO_URL: "<a class="ae kw" href="http://comments.nehalist.io" rel="noopener ugc nofollow" target="_blank">http://comments.nehalist.io</a>"<br/>          GA_TRACKING_ID: "UA-40873708-1"</span><span id="d9e9" class="mk ky iq mg b gy mp mm l mn mo">- name: Deploy<br/>        run: docker-compose run deploy<br/>        env:<br/>          DEPLOY_KEY: ${{ secrets.deploy_key }}</span></pre><p id="ed31" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">步骤相当简单:</p><ul class=""><li id="789c" class="mt mu iq ka b kb kc kf kg kj mv kn mw kr mx kv my mz na nb bi translated">查看存储库</li><li id="a203" class="mt mu iq ka b kb nc kf nd kj ne kn nf kr ng kv my mz na nb bi translated">版本处的设置节点<code class="fe mq mr ms mg b">10.x</code></li><li id="416d" class="mt mu iq ka b kb nc kf nd kj ne kn nf kr ng kv my mz na nb bi translated">通过<code class="fe mq mr ms mg b">yarn</code>安装依赖项</li><li id="e554" class="mt mu iq ka b kb nc kf nd kj ne kn nf kr ng kv my mz na nb bi translated">清理所有文件</li><li id="f4e4" class="mt mu iq ka b kb nc kf nd kj ne kn nf kr ng kv my mz na nb bi translated">构建网站</li><li id="0745" class="mt mu iq ka b kb nc kf nd kj ne kn nf kr ng kv my mz na nb bi translated">通过自定义容器进行部署</li></ul><p id="02a1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">关键字<code class="fe mq mr ms mg b">on</code>指定我们的动作何时被触发——在本例中，它在<code class="fe mq mr ms mg b">push</code>和<code class="fe mq mr ms mg b">repository_dispatch</code>被触发。</p><p id="df92" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mq mr ms mg b">repository_dispatch</code>乍一看可能不明显；但这是为了能够在外部调用它(比如URL)。这将变得很重要，因为每当一个新帖子发布时，这个webhook就会被调用，它会向GitHub发送一个<code class="fe mq mr ms mg b">cURL</code>请求，并触发<code class="fe mq mr ms mg b">repository_dispatch</code>事件。</p><blockquote class="nh ni nj"><p id="3396" class="jy jz ma ka b kb kc kd ke kf kg kh ki nk kk kl km nl ko kp kq nm ks kt ku kv ij bi translated"><strong class="ka ir"> <em class="iq">重要</em> </strong> <em class="iq">:仅在</em> <code class="fe mq mr ms mg b"><em class="iq">master</em></code> <em class="iq">分支上触发</em> <code class="fe mq mr ms mg b"><em class="iq">repository_dispatch</em></code> <em class="iq">(文档中提到的</em> <strong class="ka ir"> <em class="iq">不是</em> </strong> <em class="iq">)。获得这种知识花费了我一生的大量时间。</em></p></blockquote><p id="f599" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">更有趣的事情发生在构建和部署步骤中。但是，在仔细研究它们是如何工作的之前，让我们简单地谈谈行动中的秘密。</p><h1 id="4a80" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">秘密</h1><p id="0413" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">秘密，比如你的SSH密钥或者你的API密钥，应该<em class="ma">永远不要</em>存储在你的存储库中。相反，您可以使用存储库机密(位于“机密”的存储库设置中)。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nn"><img src="../Images/7287bf48cc881c925180ad8842373427.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*sD3f8Decp0-az8y8.png"/></div></div></figure><p id="fbc2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这些机密不会打印在您的操作控制台输出中，一旦添加，用户根本无法读取。当涉及到通过<code class="fe mq mr ms mg b">rsync</code>进行部署时，这一点尤其重要:我们将使用SSH密钥来访问服务器，因此如果有人访问到这个秘密，那就真的<em class="ma">糟糕了。</em></p><blockquote class="nh ni nj"><p id="a21a" class="jy jz ma ka b kb kc kd ke kf kg kh ki nk kk kl km nl ko kp kq nm ks kt ku kv ij bi translated">对于这样的事情，没有理由不使用秘密；即使你的网站是在一个私有的仓库里，只有你可以像我一样访问。</p></blockquote><h1 id="493b" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">建设网站</h1><p id="5726" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">让我们仔细看看构建步骤:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="cdad" class="mk ky iq mg b gy ml mm l mn mo">- name: Build<br/>        run: yarn run build<br/>        env:<br/>          GHOST_API_URL: "<a class="ae kw" href="https://ghost.nehalist.io" rel="noopener ugc nofollow" target="_blank">https://ghost.nehalist.io</a>"<br/>          GHOST_CONTENT_API_KEY: ${{ secrets.ghost_content_api_key }}<br/>          GATSBY_ENV: "prod"<br/>          GATSBY_CARRAWAY_URL: "<a class="ae kw" href="https://carraway.nehalist.io" rel="noopener ugc nofollow" target="_blank">https://carraway.nehalist.io</a>"<br/>          GATSBY_COMMENTO_URL: "<a class="ae kw" href="https://comments.nehalist.io" rel="noopener ugc nofollow" target="_blank">https://comments.nehalist.io</a>"<br/>          GA_TRACKING_ID: "UA-40873708-1"</span></pre><p id="32d5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我的站点使用了一堆环境变量(通过<code class="fe mq mr ms mg b">process.env.&lt;variable&gt;</code>)——因为我为生产和开发环境使用了不同的源——这可以通过工作流步骤中的<code class="fe mq mr ms mg b">env</code>键轻松设置。</p><p id="eb8a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要访问<code class="fe mq mr ms mg b">env</code>变量中的秘密，你可以简单地使用<code class="fe mq mr ms mg b">${{ secrets.&lt;your-secret&gt; }}</code>。</p><h1 id="8170" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">部署站点</h1><p id="461d" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">更有趣的部分是站点是如何部署的。我们工作流程中的步骤非常简单:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="18a3" class="mk ky iq mg b gy ml mm l mn mo">- name: Deploy<br/>        run: docker-compose run deploy<br/>        if: github.ref == 'refs/heads/master'<br/>        env:<br/>          DEPLOY_KEY: ${{ secrets.deploy_key }}</span></pre><p id="5276" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该步骤仅在我们处于<code class="fe mq mr ms mg b">master</code>时执行</p><p id="54a2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是正如你在<code class="fe mq mr ms mg b">run</code>键中看到的，我们不只是调用一个简单的命令，而是使用<code class="fe mq mr ms mg b">docker-compose</code>来运行我们自己的docker容器进行部署。让我们来分析一下，看看这里发生了什么！</p><blockquote class="nh ni nj"><p id="f489" class="jy jz ma ka b kb kc kd ke kf kg kh ki nk kk kl km nl ko kp kq nm ks kt ku kv ij bi translated"><em class="iq">你可能想去掉</em> <code class="fe mq mr ms mg b"><em class="iq">if</em></code> <em class="iq">子句，把不同的refs部署到不同的位置；但是这绝对超出了这篇文章的范围。</em></p></blockquote><h1 id="7613" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">码头工人</h1><p id="fe8c" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">我们首先需要看的是我们的<code class="fe mq mr ms mg b">docker-compose.yml</code>文件:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="fc71" class="mk ky iq mg b gy ml mm l mn mo">version: '3'</span><span id="9c79" class="mk ky iq mg b gy mp mm l mn mo">services:<br/>  deploy:<br/>    image: "instrumentisto/rsync-ssh"<br/>    volumes:<br/>      - .:/home/site<br/>    working_dir: /home/site<br/>    environment:<br/>      deploy_key: $DEPLOY_KEY<br/>    command: sh scripts/deploy.sh</span></pre><blockquote class="nh ni nj"><p id="9b83" class="jy jz ma ka b kb kc kd ke kf kg kh ki nk kk kl km nl ko kp kq nm ks kt ku kv ij bi translated"><em class="iq">没有</em> <code class="fe mq mr ms mg b"><em class="iq">docker-compose</em></code> <em class="iq">你可能可以做所有的docker事情——但是我已经习惯了，基本上总是用docker和Docker Compose。</em></p></blockquote><p id="d841" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将在部署中使用的图像是<code class="fe mq mr ms mg b"><a class="ae kw" href="https://hub.docker.com/r/instrumentisto/rsync-ssh/" rel="noopener ugc nofollow" target="_blank">instrumentisto/rsync-ssh</a></code>，它提供了一个安装了<code class="fe mq mr ms mg b">rsync</code>的小容器。</p><p id="1987" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你不知道<code class="fe mq mr ms mg b">rsync</code>:它基本上只是同步文件。在我们的例子中:它将我们在GitHub上构建的Gatsby站点中的<code class="fe mq mr ms mg b">public</code>目录同步到我们自己的服务器上，该站点将在那里托管。</p><p id="c79e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mq mr ms mg b">volumes</code>和<code class="fe mq mr ms mg b">working_dir</code>正是我们的站点将被安装在容器内的位置。</p><p id="c9d7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里更有趣的部分是<code class="fe mq mr ms mg b">environment</code>和<code class="fe mq mr ms mg b">command</code>。使用的环境变量来自<a class="ae kw" href="https://help.github.com/en/articles/virtual-environments-for-github-actions#default-environment-variables" rel="noopener ugc nofollow" target="_blank"> GitHub本身</a>，其中<code class="fe mq mr ms mg b">deploy_key</code>是我们从<code class="fe mq mr ms mg b">workflow.yml</code>中得到的。在看一看在<code class="fe mq mr ms mg b">command</code>内调用的脚本之前，我们先来谈谈SSH密钥。</p><h1 id="4ed2" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">SSH密钥</h1><p id="9b5e" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">如前所述，我们将利用SSH密钥进行部署。</p><p id="f909" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们要做的是生成一个SSH密钥对(由私有和公共密钥组成)。<em class="ma">公钥</em>将被添加到我们的服务器中，而<em class="ma">私钥</em>将在我们的docker容器中用于<code class="fe mq mr ms mg b">rsync</code>。因为我们<strong class="ka ir">从来不</strong>想把私钥透露给别人，所以我们打算用GitHub secrets来做这件事。</p><p id="3911" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们从生成密钥开始:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="998a" class="mk ky iq mg b gy ml mm l mn mo">ssh-keygen -t rsa -b 4096 -C "&lt;your mail&gt;"</span></pre><p id="6813" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这将生成一个公共和私有的ssh密钥。因为您不会直接使用这些键(并且在我们完成后会被删除)，所以将它们放在默认SSH目录之外的其他地方可能会有用，以防止弄乱您现有的SSH键。</p><p id="5316" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果一切都解决了，你应该有两个文件:<code class="fe mq mr ms mg b">id_rsa</code>和<code class="fe mq mr ms mg b">id_rsa.pub</code>(或者你叫它们什么)。<code class="fe mq mr ms mg b">id_rsa</code>是你的<em class="ma">私钥</em>，而<code class="fe mq mr ms mg b">id_rsa.pub</code>是你的公钥。首先让我们把你的公钥添加到我们的服务器上；</p><p id="68cf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">复制您的<em class="ma">公共</em>密钥、<code class="fe mq mr ms mg b">id_rsa.pub</code>文件的内容(例如通过<code class="fe mq mr ms mg b">xclip -sel clip id_rsa.pub</code>)并将其添加到您的服务器<code class="fe mq mr ms mg b">authorized_keys</code>文件中(在我的例子中，该文件位于<code class="fe mq mr ms mg b">/home/$USER/.ssh</code>)。</p><p id="70ca" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后将你的<em class="ma">私有</em>密钥<code class="fe mq mr ms mg b">id_rsa</code>的内容复制到你的GitHub secrets中。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi no"><img src="../Images/6b9259a36efc97dfea14a4a19138f1a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*uWhOOpMpkh80cu3I.png"/></div></div></figure><p id="77cf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个密钥将在Docker容器中用来访问您的服务器。</p><h1 id="9294" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">部署脚本</h1><p id="c8b9" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">我们需要查看的最后一个文件是由我们工作流中的Docker容器调用的<code class="fe mq mr ms mg b">deploy.sh</code>文件:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="06c5" class="mk ky iq mg b gy ml mm l mn mo">#!/bin/sh</span><span id="01b7" class="mk ky iq mg b gy mp mm l mn mo"># Instantly exists our script whenever an error occurs<br/>set -e</span><span id="abb4" class="mk ky iq mg b gy mp mm l mn mo"># Pipe our environmental SSH key variable into a file<br/>mkdir -p $HOME/.ssh<br/>echo "${deploy_key}" &gt; $HOME/.ssh/deploy_key<br/>chmod 600 $HOME/.ssh/deploy_key # SSH keys need to be readonly</span><span id="5f6d" class="mk ky iq mg b gy mp mm l mn mo"># Where to deploy our site on our server<br/>target="~/html"</span><span id="c186" class="mk ky iq mg b gy mp mm l mn mo"># The actual rsync<br/>sh -c "rsync -azh -e 'ssh -i $HOME/.ssh/deploy_key -o StrictHostKeyChecking=no' public/* --rsync-path='mkdir -p ${target} &amp;&amp; rsync' &lt;user&gt;@&lt;server&gt;:${target}"</span><span id="df52" class="mk ky iq mg b gy mp mm l mn mo"># Remove our deploy_key again since it's no longer needed<br/>rm $HOME/.ssh/deploy_key</span></pre><p id="4b85" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">起初，<code class="fe mq mr ms mg b">rsync</code>命令可能看起来有点疯狂；</p><ul class=""><li id="05ab" class="mt mu iq ka b kb kc kf kg kj mv kn mw kr mx kv my mz na nb bi translated"><code class="fe mq mr ms mg b">-azh</code>用于使用存档模式(<code class="fe mq mr ms mg b">-a</code>)、传输过程中压缩数据(<code class="fe mq mr ms mg b">-z</code>)、保留硬链接(<code class="fe mq mr ms mg b">-h</code>)。所有参数见<a class="ae kw" href="https://www.computerhope.com/unix/rsync.htm" rel="noopener ugc nofollow" target="_blank">此处</a>。</li><li id="a4b2" class="mt mu iq ka b kb nc kf nd kj ne kn nf kr ng kv my mz na nb bi translated"><code class="fe mq mr ms mg b">-e</code>用于设置<code class="fe mq mr ms mg b">ssh</code>命令(使用我们的<code class="fe mq mr ms mg b">deploy_key</code>，不进行严格的主机密钥检查，如果我们要信任服务器，主机密钥检查会提示我们)。</li><li id="3e6c" class="mt mu iq ka b kb nc kf nd kj ne kn nf kr ng kv my mz na nb bi translated"><code class="fe mq mr ms mg b">--rsync-path</code>是一个创建缺失父目录的巧妙小技巧(参见这篇<a class="ae kw" href="http://www.schwertly.com/2013/07/forcing-rsync-to-create-a-remote-path-using-rsync-path/" rel="noopener ugc nofollow" target="_blank">帖子</a>)。</li></ul><p id="9f38" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，每次执行GitHub操作时，您的博客都会直接部署到您的主机上。我们还缺少的最后一件事是创建一个webhook，每当有新帖子发布时触发我们的操作。</p><h1 id="3bd4" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">从外部触发动作</h1><p id="3f44" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">从外部触发动作实际上是利用<code class="fe mq mr ms mg b"><a class="ae kw" href="https://help.github.com/en/articles/events-that-trigger-workflows#external-events-repository_dispatch" rel="noopener ugc nofollow" target="_blank">repository_dispatch</a></code>事件来完成的。</p><blockquote class="nh ni nj"><p id="23f6" class="jy jz ma ka b kb kc kd ke kf kg kh ki nk kk kl km nl ko kp kq nm ks kt ku kv ij bi translated"><em class="iq">别忘了:</em> <code class="fe mq mr ms mg b"><em class="iq">repository_dispatch</em></code> <em class="iq">事件只对</em> <code class="fe mq mr ms mg b"><em class="iq">master</em></code> <em class="iq">分支有效！</em></p></blockquote><p id="cd7c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">触发该动作的最简单方法是通过cURL:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="796f" class="mk ky iq mg b gy ml mm l mn mo">curl -v -X POST -u "&lt;username&gt;:&lt;access-token&gt;" -H "Accept: application/vnd.github.everest-preview+json" -H "Content-Type: application/json" --data '{"event_type":"update"}' <a class="ae kw" href="https://api.github.com/repos/" rel="noopener ugc nofollow" target="_blank">https://api.github.com/repos/</a>&lt;username&gt;/&lt;repo-name&gt;/dispatches</span></pre><p id="36f2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果——你肯定应该——你正在使用双因素认证，你将需要一个具有<code class="fe mq mr ms mg b">repo</code>权限的<a class="ae kw" href="https://github.com/settings/tokens" rel="noopener ugc nofollow" target="_blank">个人访问令牌</a>。</p><p id="766e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">调用这个命令将触发我们的操作，我们的站点将被重新构建和部署。</p><p id="bb13" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你正在使用Ghost，你不能在一篇文章发表后执行<code class="fe mq mr ms mg b">cURL</code>命令，而是发送一个<a class="ae kw" href="https://ghost.org/docs/api/v2/webhooks/" rel="noopener ugc nofollow" target="_blank">文章请求到一个用户定义的URL </a>。在这种情况下，编写一个非常小的PHP脚本来执行<code class="fe mq mr ms mg b">cURL</code>命令并触发动作是非常简单的；</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="4f9f" class="mk ky iq mg b gy ml mm l mn mo">&lt;?php</span><span id="731b" class="mk ky iq mg b gy mp mm l mn mo">$key = $_GET['key'];</span><span id="a20b" class="mk ky iq mg b gy mp mm l mn mo">if ($key !== 'f4aOLlmN3') {<br/>    exit('Nope.');<br/>}</span><span id="2cdf" class="mk ky iq mg b gy mp mm l mn mo">$curl = curl_init();<br/>curl_setopt($curl, CURLOPT_URL, '<a class="ae kw" href="https://api.github.com/repos/" rel="noopener ugc nofollow" target="_blank">https://api.github.com/repos/</a>&lt;username&gt;/&lt;repository&gt;/dispatches');<br/>curl_setopt($curl, CURLOPT_RETURNTRANSFER, true);<br/>curl_setopt($curl, CURLOPT_HTTPAUTH, CURLAUTH_BASIC);<br/>curl_setopt($curl, CURLOPT_HTTPHEADER, [<br/>    'Authorization: token &lt;access-token&gt;',<br/>    'Accept: application/vnd.github.everest-preview+json',<br/>    'User-Agent: &lt;username&gt;',<br/>]);<br/>curl_setopt($curl, CURLOPT_POST, true);<br/>curl_setopt($curl, CURLOPT_POSTFIELDS, json_encode([<br/>    'event_type' =&gt; 'update'<br/>]));</span><span id="c5fa" class="mk ky iq mg b gy mp mm l mn mo">$content = curl_exec($curl);<br/>curl_close($curl);</span><span id="6dc5" class="mk ky iq mg b gy mp mm l mn mo">// we could var_dump($content) here or whatever</span></pre><p id="6161" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">不要忘记替换脚本中的所有占位符</p><p id="1887" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可能注意到的第一件事是<code class="fe mq mr ms mg b">$key</code>部分；这只是为了防止钩子被任何人触发。这是保护你的脚本的非常简单的方法。这个脚本只能通过<code class="fe mq mr ms mg b">webhook.php?key=f4aOLlmN3</code>调用——其他的都不会触发动作。</p><p id="88c6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">其他一切都是基本的PHP <code class="fe mq mr ms mg b">cURL</code>疯狂。头部包含您的访问令牌，并将<code class="fe mq mr ms mg b">User-Agent</code>设置为<a class="ae kw" href="https://developer.github.com/v3/#user-agent-required" rel="noopener ugc nofollow" target="_blank">您的用户名</a>，这是GitHub所要求的。</p><p id="0b20" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在您可以设置您的CMS向该脚本发送请求(不要忘记URL中的<code class="fe mq mr ms mg b">key</code>！)你的动作就会被触发。</p><h1 id="3ca9" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">结论</h1><p id="18fc" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">如果一切配置正确，你的站点现在可以在GitHub上构建，然后部署到你的服务器上。这就是花式酷炫，<em class="ma">不是吗？！</em></p><p id="a10e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于GitHub actions仍处于测试阶段，未来可能会有所变化——但这篇文章的基本概念应该始终有效，应该在能力建设方面留出更多空间。</p></div><div class="ab cl np nq hu nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="ij ik il im in"><p id="0d93" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你喜欢这篇文章，请留下👏，关注我上 <a class="ae kw" href="https://twitter.com/nehalist" rel="noopener ugc nofollow" target="_blank"> <em class="ma">推特</em> </a> <em class="ma">并订阅</em> <a class="ae kw" href="https://nehalist.io/newsletter/" rel="noopener ugc nofollow" target="_blank"> <em class="ma">我的快讯</em> </a> <em class="ma">。本帖原载于</em><a class="ae kw" href="https://nehalist.io/building-and-deploying-gatsby-sites-with-github-actions" rel="noopener ugc nofollow" target="_blank"><em class="ma">nehalist . io</em></a><em class="ma">。</em></p></div></div>    
</body>
</html>