<html>
<head>
<title>How to cold start fast a java service on k8s (EKS)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在k8s (EKS)上冷启动快速java服务</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-cold-start-fast-a-java-service-on-k8s-eks-3a7b4450845d?source=collection_archive---------0-----------------------#2020-04-17">https://itnext.io/how-to-cold-start-fast-a-java-service-on-k8s-eks-3a7b4450845d?source=collection_archive---------0-----------------------#2020-04-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/e7fab6ae3d10da1a5b78731a74ad578c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VECY6zzF9kQ00nA7"/></div></div></figure></div><div class="ab cl jy jz hu ka" role="separator"><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd"/></div><div class="ij ik il im in"><p id="37aa" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">在k8s和微服务时代，快速启动非常重要，尤其是如果您的集群运行在spot实例上，而且如果您希望轻松地向外扩展，在数据库故障转移甚至您自己的服务内存泄漏后重新启动。</p><p id="7db3" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">CPU分数/毫核/纳米核是java的东西，它的echo系统不是为其设计和优化的。例如像<a class="ae ld" href="https://github.com/netty/netty" rel="noopener ugc nofollow" target="_blank"> Netty </a>这样的库，它使用可用处理器的数量来决定多事件循环的大小，或者<a class="ae ld" href="https://github.com/brettwooldridge/HikariCP" rel="noopener ugc nofollow" target="_blank"> HikaeriCP </a>这样一个流行的jdbc连接池，它使用处理器的数量来决定连接池的大小。所有这些工具和JVM本身都进行了优化，以调整线程与处理器的最佳比例，从而充分利用CPU并减少线程上下文切换。JVM使用可用内核的数量来决定GC线程和编译器线程(jit线程)的数量，所有这些线程都在争夺CPU。但是他们共用200个k8s毫核会怎么样呢？实质上，docker CPU分配机制会限制请求的CPU资源多于分配的资源的容器，这将导致线程阻塞和执行缓慢，pods crashLoopBackOff，甚至会导致k8s HPA(水平pod自动缩放器)唤醒并调度更多的pods(因为它们使用了太多的CPU ),这可能会导致更多的CPU限制…</p><p id="5514" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">我们遇到的问题如下:</p><p id="237b" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">在我工作的<a class="ae ld" href="https://www.ourbond.com/" rel="noopener ugc nofollow" target="_blank">邦德</a>公司，我们用科特林语写作，我们在服务部署方面遇到了一些问题。</p><p id="f4ff" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">有时我们的服务几乎需要一分钟才能启动，起初我们并不担心，但后来我们注意到服务在启动时有一个CPU峰值，这有时会导致k8s HPA启动额外的不必要的pod，有时会导致启动额外的节点。CPU峰值还会导致部署时间的显著延迟，通常需要100毫秒的请求可能需要几秒钟。</p><p id="1c8a" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">为了更好地理解和衡量java服务在EC2实例上k8s节点的pod中的容器中引导时会发生什么，只有上帝和amazon知道物理位置，我们需要回答以下问题:</p><ul class=""><li id="c307" class="le lf iq kh b ki kj km kn kq lg ku lh ky li lc lj lk ll lm bi translated">如何测量启动一个java*容器所需的时间？(* open JDK:8-阿尔卑斯山图片)</li><li id="5b3c" class="le lf iq kh b ki ln km lo kq lp ku lq ky lr lc lj lk ll lm bi translated">如何衡量JVM启动所需的时间/资源？</li><li id="1991" class="le lf iq kh b ki ln km lo kq lp ku lq ky lr lc lj lk ll lm bi translated">如何测量启动java HTTP服务器所需的时间</li></ul><p id="d157" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">对于这个例子，我将使用一个简单的vert.x/netty webserver，它用kotlin编写，并编译成java8字节码:</p><h1 id="96cb" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">测量pod准备就绪所需的时间:</h1><figure class="mq mr ms mt gt jr"><div class="bz fp l di"><div class="mu mv l"/></div><figcaption class="mw mx gj gh gi my mz bd b be z dk translated">计算pod预定时间和就绪时间之间的时间。</figcaption></figure><p id="5c36" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">对一个pod的所有实例进行平均将产生一个引导时间的仪表板。(强烈推荐有一个)</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi na"><img src="../Images/a139695f12c186a9a7deb09784097f43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GVemn_Mo21KjDutl7f3nZg.png"/></div></div><figcaption class="mw mx gj gh gi my mz bd b be z dk translated">pod平均启动时间(秒)—越快越好</figcaption></figure><p id="5f64" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">这个时间是以下内容的总和:</p><ul class=""><li id="dd91" class="le lf iq kh b ki kj km kn kq lg ku lh ky li lc lj lk ll lm bi translated">k8s pod引导时间</li><li id="8298" class="le lf iq kh b ki ln km lo kq lp ku lq ky lr lc lj lk ll lm bi translated">jvm引导</li><li id="ff75" class="le lf iq kh b ki ln km lo kq lp ku lq ky lr lc lj lk ll lm bi translated">服务器引导</li></ul><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nb"><img src="../Images/02b30d9a77c5eda68cbdb669669c44ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LwFd6SXahzf98WL92PWGOQ.png"/></div></div></figure><p id="668b" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">关于jit，ClassLoader加载在main方法中导入或使用的字节码，然后对其进行编译。main方法调用的代码越多，发生的类加载和编译就越多。这在引导阶段使用了大量的CPU，因为要编译成千上万的方法，所以在某种程度上预计会出现CPU高峰。</p><h1 id="a8bf" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">启动示例服务</h1><figure class="mq mr ms mt gt jr"><div class="bz fp l di"><div class="mu mv l"/></div><figcaption class="mw mx gj gh gi my mz bd b be z dk translated">网络服务器</figcaption></figure><p id="77c5" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">上面的例子给出了下面的资源和部署。</p><figure class="mq mr ms mt gt jr"><div class="bz fp l di"><div class="mu mv l"/></div><figcaption class="mw mx gj gh gi my mz bd b be z dk translated">deployment.yml的片段</figcaption></figure><p id="1e54" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">它花费了7秒钟，在引导的第一秒钟，CPU使用率为100%。</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/0c6e68c997d9c1deb1f7ebc5fb2b555d.png" data-original-src="https://miro.medium.com/v2/resize:fit:596/format:webp/1*RQTyXMK1TtQOZWX2nzx37g.png"/></div><figcaption class="mw mx gj gh gi my mz bd b be z dk translated">道钉</figcaption></figure><p id="8889" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">这让我相信JVM需要更多的CPU，它正在被节流。所以我尝试了不同的CPU限制。</p><h1 id="632e" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">不同的CPU限制产生了以下结果</h1><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nd"><img src="../Images/feb3dccb5cde097a193de7cc7868bcea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yiGCE2iw_a5cRPYtcgIeJA.png"/></div></div><figcaption class="mw mx gj gh gi my mz bd b be z dk translated">服务引导时间/ pod CPU限制</figcaption></figure><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ne"><img src="../Images/690bc12d04bb6d28900ee197741dca5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fxzZNMihcN7OeffASoJnVg.png"/></div></div><figcaption class="mw mx gj gh gi my mz bd b be z dk translated">引导前几秒钟的CPU使用情况</figcaption></figure><p id="43d6" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">由于koltin被编译成java8字节码，我首先怀疑JVM不知道它在容器中运行。</p><p id="7dbe" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">由于<a class="ae ld" href="https://github.com/eclipse-vertx/vert.x/tree/master/src/main/java/io/vertx/core" rel="noopener ugc nofollow" target="_blank"> vert.x </a>和<a class="ae ld" href="https://github.com/netty/netty" rel="noopener ugc nofollow" target="_blank"> netty </a>都使用<code class="fe nf ng nh ni b">Runtime.getRuntime().availableProcessors()</code>来确定默认的事件循环大小和其他资源，如果JVM看到主机CPU并认为它运行在<code class="fe nf ng nh ni b">m5.xlarge aws ec2 instance (4 cores)</code>上，这可能解释了CPU峰值。</p><p id="bb75" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">但这不是原因。我使用下面的JVM标志<code class="fe nf ng nh ni b">- XX:+UnlockExperimentalVMOptions -XX:+UseCGroupMemoryLimitForHeap</code>,当在云中打印可用处理器和ram的数量时，它显示1个CPU和0.25G ram。</p><h1 id="c5d8" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">在第一秒收集pod指标</h1><p id="1630" class="pw-post-body-paragraph kf kg iq kh b ki nj kk kl km nk ko kp kq nl ks kt ku nm kw kx ky nn la lb lc ij bi translated">如果您试图运行<code class="fe nf ng nh ni b">kubectl top pod ${PODID}</code>，您将得到以下“错误:指标尚不可用”</p><p id="cc29" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">另一种方法是通过运行以下命令直接从k8s指标服务获取指标:</p><figure class="mq mr ms mt gt jr"><div class="bz fp l di"><div class="mu mv l"/></div><figcaption class="mw mx gj gh gi my mz bd b be z dk translated">直接调用k8指标服务(在pod引导的前几秒内不可用)</figcaption></figure><p id="2585" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">或者简单地使用k8s dashboard，请注意，它也不显示前几秒钟的CPU使用情况</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi no"><img src="../Images/900af959faf2d7d2808648d414b8d6c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wJyc8vSpt4rF8A-iDDgkCA.png"/></div></div><figcaption class="mw mx gj gh gi my mz bd b be z dk translated">k8s仪表板(请注意，cpu使用率仅在20秒后出现)</figcaption></figure><p id="b49f" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">这并不完美，但足以在引导期间获得pod的CPU使用估计。</p><h1 id="b35b" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">启动时间分解</h1><ul class=""><li id="873b" class="le lf iq kh b ki nj km nk kq np ku nq ky nr lc lj lk ll lm bi translated">pod计划运行容器</li></ul><p id="b8d6" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">为了测量这一点，您需要从<strong class="kh ir"> PodScheduled </strong>事件的纪元秒中减去启动JVM的bash脚本第一行的纪元秒。</p><p id="d3f4" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">通过将<code class="fe nf ng nh ni b">echo "starting jvm $(date +%s)"</code>添加到<code class="fe nf ng nh ni b"><strong class="kh ir">dockerfile</strong></code>入口点的第一行，您将获得第一个，下面的将提供最后一个。</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/11ef64b328158f17b4ca44329dc2a0f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:978/format:webp/1*Nou8RB9WYBfGcBBYMFAsXA.png"/></div><figcaption class="mw mx gj gh gi my mz bd b be z dk translated">pod预定时间戳</figcaption></figure><ul class=""><li id="1c34" class="le lf iq kh b ki kj km kn kq lg ku lh ky li lc lj lk ll lm bi translated">启动jvm</li></ul><p id="869d" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">主方法的第一行— <code class="fe nf ng nh ni b">println("starting application ${now().epochSecond}")</code>减去上述<code class="fe nf ng nh ni b">echo "starting jvm $(date +%s)" </code>由docker入口点记录的时间</p><ul class=""><li id="c281" class="le lf iq kh b ki kj km kn kq lg ku lh ky li lc lj lk ll lm bi translated">启动web服务器</li></ul><p id="3578" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">main方法的第一行减去第一次准备就绪+活性检查的时间戳。</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/3261e8df7686724062a3ed380f1bc1cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1028/format:webp/1*YE_RvnAVhXhToJS0Z5TJLQ.png"/></div><figcaption class="mw mx gj gh gi my mz bd b be z dk translated">记录第一次就绪检查的时间戳</figcaption></figure><p id="5186" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">通过运行<strong class="kh ir"> kubectl logs $PODNAME </strong>，您可以获得启动服务的日志，并获得计算所需的时间戳。</p><h1 id="b6d8" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">生产设置</h1><p id="7572" class="pw-post-body-paragraph kf kg iq kh b ki nj kk kl km nk ko kp kq nl ks kt ku nm kw kx ky nn la lb lc ij bi translated">上面的示例vanilla应用程序比生产服务要简单得多，因为生产服务有更多的依赖项(要加载更多的jar)，更大的映像大小和更多要在bootstrap上做的事情。所以在现实生活中，容器和JVM的启动时间可能会更长。</p><h1 id="bd89" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">HPA微调</h1><p id="31df" class="pw-post-body-paragraph kf kg iq kh b ki nj kk kl km nk ko kp kq nl ks kt ku nm kw kx ky nn la lb lc ij bi translated">随着我增加CPU限制，pod启动时间得到了改善，但有时HPA创建的pod比预期的要多。<a class="ae ld" href="https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/#algorithm-details" rel="noopener ugc nofollow" target="_blank">来自k8s文档</a></p><blockquote class="nu nv nw"><p id="8899" class="kf kg nx kh b ki kj kk kl km kn ko kp ny kr ks kt nz kv kw kx oa kz la lb lc ij bi translated">由于技术上的限制，HorizontalPodAutoscaler控制器在确定是否搁置某些CPU指标时，无法准确地确定pod准备就绪的第一时间。相反，如果一个Pod未准备好，并且在启动后的一段可配置的短时间内转换为未准备好，它会将其视为“尚未准备好”。该值配置有—水平-吊舱-自动缩放-初始-就绪-延迟标志，其默认值为30秒</p></blockquote><p id="318e" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">将初始延迟设置为一个较大的时间段应该会为您的服务在初始CPU消耗阶段提供更多的宽限期。对于JAVA服务，我将这个值设置为1分钟。</p><p id="7a87" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">遗憾的是，在撰写本文时，EKS还不支持该标志。</p><h1 id="60cf" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">CPU过度使用</h1><p id="0129" class="pw-post-body-paragraph kf kg iq kh b ki nj kk kl km nk ko kp kq nl ks kt ku nm kw kx ky nn la lb lc ij bi translated">增加CPU限制会造成CPU过度使用，从而导致问题。为了避免达到将pod从集群中逐出以实现高CPU使用率的程度，请降低您的HPA targetAverageUtilization。例如，如果一个服务的预期CPU使用率低于250毫核，而您给它一个1000毫核的CPU限制，那么将targetAverageUtilization设置为50甚至更低是合理的。</p><h1 id="edc3" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">摘要</h1><p id="b788" class="pw-post-body-paragraph kf kg iq kh b ki nj kk kl km nk ko kp kq nl ks kt ku nm kw kx ky nn la lb lc ij bi translated">增加java服务的CPU限制会使它启动得更快，但是会造成CPU过载，需要小心管理。</p><h1 id="7f9b" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">改善启动时间的其他方法</h1><ul class=""><li id="b21b" class="le lf iq kh b ki nj km nk kq np ku nq ky nr lc lj lk ll lm bi translated">然而，使用<a class="ae ld" href="https://www.graalvm.org/" rel="noopener ugc nofollow" target="_blank"> GraalVM </a>，在与运行时DI工具和netty(使用JNI)的冲突中存在反射和JNI限制。</li><li id="1201" class="le lf iq kh b ki ln km lo kq lp ku lq ky lr lc lj lk ll lm bi translated">除HPA之外的垂直pod自动缩放，以避免增加CPU限制。然而，在撰写本文时，这仍然是实验性的，还没有准备好投入生产。</li><li id="8ac5" class="le lf iq kh b ki ln km lo kq lp ku lq ky lr lc lj lk ll lm bi translated">升级到java 11及更高版本，不过提升应该有限。因为JVM启动时间对服务的引导时间影响最小。</li></ul><h1 id="5902" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">资源</h1><ul class=""><li id="68df" class="le lf iq kh b ki nj km nk kq np ku nq ky nr lc lj lk ll lm bi translated"><a class="ae ld" href="https://www.datadoghq.com/blog/how-to-collect-and-graph-kubernetes-metrics/" rel="noopener ugc nofollow" target="_blank">调用k8s度量服务</a></li><li id="5131" class="le lf iq kh b ki ln km lo kq lp ku lq ky lr lc lj lk ll lm bi translated"><a class="ae ld" href="https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/#algorithm-details" rel="noopener ugc nofollow" target="_blank"> k8s hpa </a></li><li id="b3d9" class="le lf iq kh b ki ln km lo kq lp ku lq ky lr lc lj lk ll lm bi translated"><a class="ae ld" href="https://github.com/netty/netty" rel="noopener ugc nofollow" target="_blank">内蒂</a></li><li id="3240" class="le lf iq kh b ki ln km lo kq lp ku lq ky lr lc lj lk ll lm bi translated"><a class="ae ld" href="https://github.com/eclipse-vertx/vert.x" rel="noopener ugc nofollow" target="_blank">垂直x </a></li><li id="3ba8" class="le lf iq kh b ki ln km lo kq lp ku lq ky lr lc lj lk ll lm bi translated"><a class="ae ld" href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/g1_gc_tuning.html" rel="noopener ugc nofollow" target="_blank"> java GC调优</a></li><li id="c3aa" class="le lf iq kh b ki ln km lo kq lp ku lq ky lr lc lj lk ll lm bi translated"><a class="ae ld" href="https://aboullaite.me/understanding-jit-compiler-just-in-time-compiler/" rel="noopener ugc nofollow" target="_blank"> JIT微调</a></li><li id="c43e" class="le lf iq kh b ki ln km lo kq lp ku lq ky lr lc lj lk ll lm bi translated"><a class="ae ld" href="https://github.com/brettwooldridge/HikariCP" rel="noopener ugc nofollow" target="_blank"> HicariCP </a></li><li id="7045" class="le lf iq kh b ki ln km lo kq lp ku lq ky lr lc lj lk ll lm bi translated"><a class="ae ld" href="https://www.graalvm.org/" rel="noopener ugc nofollow" target="_blank"> GraalVM </a></li><li id="2972" class="le lf iq kh b ki ln km lo kq lp ku lq ky lr lc lj lk ll lm bi translated"><a class="ae ld" href="https://github.com/oracle/graal/blob/master/substratevm/LIMITATIONS.md" rel="noopener ugc nofollow" target="_blank"> GraalVM java限制</a></li></ul></div></div>    
</body>
</html>