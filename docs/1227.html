<html>
<head>
<title>Logging Best Practices for Kubernetes using Elasticsearch, Fluent Bit and Kibana</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Elasticsearch、Fluent Bit和Kibana记录Kubernetes的最佳实践</h1>
<blockquote>原文：<a href="https://itnext.io/logging-best-practices-for-kubernetes-using-elasticsearch-fluent-bit-and-kibana-be9b7398dfee?source=collection_archive---------1-----------------------#2018-08-16">https://itnext.io/logging-best-practices-for-kubernetes-using-elasticsearch-fluent-bit-and-kibana-be9b7398dfee?source=collection_archive---------1-----------------------#2018-08-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/026a996b15667db9d1b7adda44670627.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pDEkCCstGCwGqPPpNQJoGg.png"/></div></div></figure><p id="1df3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">日志记录是我们作为开发人员拥有的最强大的工具之一。当生产中出现问题时，开发人员的第一个问题通常是——“你能把日志发给我吗？”。原始日志包含有用的信息，但可能很难解析。因此，在大规模操作系统时，使用结构化日志记录可以大大提高日志的有用性。使用一个公共结构使得日志更容易搜索，也使得日志的自动处理更容易。</p><p id="c3c7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在Giant Swarm，我们在整个控制平面使用结构化日志记录来为客户管理Kubernetes集群。我们用EFK栈来做这件事，它由<a class="ae kw" href="https://github.com/elastic/elasticsearch" rel="noopener ugc nofollow" target="_blank"> Elasticsearch </a>、<a class="ae kw" href="https://fluentbit.io/" rel="noopener ugc nofollow" target="_blank"> Fluent Bit </a>和<a class="ae kw" href="https://github.com/elastic/kibana" rel="noopener ugc nofollow" target="_blank"> Kibana </a>组成。EFK堆栈基于广泛使用的ELK堆栈，它使用Logstash而不是Fluent Bit或Fluentd。</p><p id="68dd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这篇文章解释了我们在构建日志时遵循的一些最佳实践，以及我们如何使用EFK堆栈来管理它们。很快，我们还将为我们的客户提供托管日志基础设施，作为<a class="ae kw" href="https://blog.giantswarm.io/managed-cloud-native-stack/" rel="noopener ugc nofollow" target="_blank">托管云原生堆栈</a>的一部分。</p><h1 id="93f9" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">我们如何写日志</h1><p id="3b3e" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">我们的控制平面由多个微服务和Kubernetes操作员组成。提醒一下，Kubernetes中的操作符是一个自定义控制器，与一个CRD(自定义资源定义)配对，它扩展了Kubernetes API。</p><p id="c39b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于我们的微服务，我们在基于<a class="ae kw" href="https://github.com/go-kit/kit" rel="noopener ugc nofollow" target="_blank"> Go-Kit </a>的<a class="ae kw" href="https://github.com/giantswarm/microkit" rel="noopener ugc nofollow" target="_blank">微工具包</a>框架中开发它们。我们的操作符是使用我们的<a class="ae kw" href="https://github.com/giantswarm/operatorkit" rel="noopener ugc nofollow" target="_blank"> operatorkit </a>框架开发的。这些框架都使用我们的微日志库。因为我们所有的日志都流经一个库，所以我们可以用额外的数据来丰富日志。这也使得我们的日志结构非常一致。</p><p id="415f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，我们可以将像租户集群的ID这样的数据添加到Golang上下文中，并在操作符代码中传递。我们用它来创建一个到操作员正在处理的CR(自定义资源)的自链接。这与Kubernetes API公开的self-links方法相同，并且使日志更容易阅读。</p><h1 id="2282" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">我们记录的内容</h1><p id="e4ed" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">我们的日志使用JSON格式，这使得Fluent Bit更容易处理它们。这也意味着存储在Elasticsearch中的数据更加结构化。我们对日志级别(例如调试或错误)和日志消息使用一种非常标准的格式。对于错误，我们添加一个带有完整调用堆栈的堆栈条目。</p><p id="0601" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们使用前面描述的框架，用额外的信息来丰富日志消息，例如时间戳、自链接或操作者正在处理的事件(例如创建或更新)。</p><h1 id="dd49" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">弹性搜索</h1><p id="bfd3" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">Elasticsearch是EFK堆栈的核心。这是一个基于Lucene搜索引擎的NoSQL数据库。它作为搜索引擎的出身也使它擅长查询日志数据。它可以接收大量数据，高效存储数据并快速执行查询。在EFK堆栈中，Elasticsearch用于日志存储，并从日志发送器Fluent接收日志数据。日志数据存储在Elasticsearch索引中，由Kibana查询。</p><p id="5af1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如你所料，我们使用Kubernetes部署了Elasticsearch。我们为客户管理的每个控制平面都有自己的Elasticsearch部署。这将它与所有其他控制平面隔离开来。在AWS和Azure上，我们使用带有持久卷的云存储来存储索引数据。在内部控制平面中，数据存储在物理存储上。</p><h1 id="c331" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">流畅位</h1><p id="fe90" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">日志记录是云原生应用程序的一个领域，其中有许多选项。我们目前使用Fluent Bit，但我们之前评估过许多其他选项，包括Logstash(非常流行的ELK堆栈中的L)和Filebeat，后者是来自Elastic.co的轻量级日志传送程序。</p><p id="172e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们最初排除了Logstash和Filebeat，因为与Kubernetes元数据的集成不是很先进。所以我们开始使用Fluentd实现。Fluentd 是一个日志运送器，有很多插件。它提供了一个统一的日志记录层，将数据转发给Elasticsearch。这也是CNCF的一个项目，因其Kubernetes和Docker集成而闻名，这对我们都很重要。</p><p id="1ddc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Fluentd使用Ruby和Ruby Gems来配置其500多个插件。由于Ruby是一种解释型语言，它也大量使用C扩展来解析日志文件和转发数据，以提供必要的速度。然而，由于我们接收的日志量，我们遇到了性能问题，因此我们评估了相关的Fluent Bit项目。</p><p id="806b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Fluent Bit只在C中实现，与Fluentd相比，它的功能有限。然而，在我们的例子中，它提供了我们需要的所有功能，我们对性能非常满意。我们将Fluent Bit作为守护程序集部署到控制平面集群中的所有节点。每个节点上的Fluent Bit pods装载主机的Docker日志，使我们能够访问集群中所有容器的日志。</p><p id="9dce" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这里，我要感谢Eduardo Silva，他是Fluent Bit的维护者之一，在我们进行集成时，他回答了我们很多问题。</p><h1 id="ae74" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">日志保留—管理员</h1><p id="1324" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">日志记录很棒，但是它会很快用完大量的磁盘空间。因此，拥有一个好的日志保留策略是必不可少的。Fluent Bit对此有所帮助，因为它在Elasticsearch中创建了每日指数。我们在Kubernetes中有一个每日cron作业，它删除超过n天的索引。cron作业调用管理器组件来删除旧的索引。</p><p id="9bb5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有一个来自Elastic.co的策展人组件，但我们使用自己的简单版本，满足我们的要求。GitHub<a class="ae kw" href="https://github.com/giantswarm/curator" rel="noopener ugc nofollow" target="_blank">giants warm/策展人</a>上有。删除索引是磁盘I/O的一个密集过程，因此我们使用的另一个技巧是在不寻常的时间(如02:35)运行cron作业，而不是在02:00——这避免了与其他计划任务的冲突。</p><h1 id="89fa" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">基巴纳</h1><p id="e061" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">Kibana为栈提供UI，前端和查询引擎用于查询Elasticsearch中的日志。Kibana支持Lucene查询语法以及它自己的使用JSON的扩展查询DSL。另一个很好的特性是对在仪表板中使用的可视化的内置支持。</p><p id="4046" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们面临的一个挑战是如何配置Kibana。我们在每个控制平面中运行一个Kibana实例，我们希望它们都与相同的基本配置保持同步。这包括在Kibana中设置索引模式，它应该搜索哪些Elasticsearch索引。</p><p id="97fd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们使用的是Kibana 6，直到最近它还没有一个<a class="ae kw" href="https://github.com/elastic/beats/pull/4413" rel="noopener ugc nofollow" target="_blank">文档化的配置API </a>。所以我们写了一个简单的边车<a class="ae kw" href="https://github.com/giantswarm/kibana-sidecar" rel="noopener ugc nofollow" target="_blank">来设置配置。这工作得很好，但是需要适应每个版本的Kibana。Elastic.co最近发布了用于配置的</a><a class="ae kw" href="https://www.elastic.co/guide/en/kibana/6.3/saved-objects-api.html" rel="noopener ugc nofollow" target="_blank">保存对象API </a>的文档，将来可能会升级到这个版本。</p><h1 id="eb0f" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">结论</h1><p id="4c2e" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">在本帖中，我们向您展示了如何使用结构化日志记录和EFK堆栈来为我们的客户管理Kubernetes集群。在构建云原生应用程序时，有许多日志记录选项。我们评估了几个选项，找到了一套适合我们的工具。</p><p id="058a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，EFK和麋鹿栈的好处之一是它们非常灵活。因此，如果你想使用不同的日志存储工具，如<a class="ae kw" href="https://kafka.apache.org/" rel="noopener ugc nofollow" target="_blank">Kafka</a>——你只需配置Fluent来传输到Kafka。这也适用于第三方日志存储提供商，如DataDog和Splunk。如果Filebeat或Logstash更适合您的需要，您也可以使用不同的日志传送程序。</p><p id="0c53" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">很快，我们还将向我们的客户提供托管日志记录基础设施，作为<a class="ae kw" href="https://blog.giantswarm.io/managed-cloud-native-stack/" rel="noopener ugc nofollow" target="_blank">托管云原生堆栈</a>的一部分。这将让我们的客户利用EFK堆栈提供的丰富功能。但是，它将完全由我们管理，利用我们在生产中运行EFK堆栈的运营知识。在这里申请免费试用<a class="ae kw" href="https://giantswarm.io/" rel="noopener ugc nofollow" target="_blank">巨型蜂群基础设施</a>。</p><p id="af6e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由<a class="ae kw" href="https://twitter.com/rossf7?lang=en" rel="noopener ugc nofollow" target="_blank">罗斯·费尔班克斯</a> —平台工程师@ <a class="ae kw" href="https://giantswarm.io/" rel="noopener ugc nofollow" target="_blank">巨型蜂群</a>撰写</p><div class="ma mb gp gr mc md"><a href="https://twitter.com/rossf7" rel="noopener  ugc nofollow" target="_blank"><div class="me ab fo"><div class="mf ab mg cl cj mh"><h2 class="bd ir gy z fp mi fr fs mj fu fw ip bi translated">罗斯·费尔班克斯(@rossf7) |推特</h2><div class="mk l"><h3 class="bd b gy z fp mi fr fs mj fu fw dk translated">罗斯·费尔班克斯的最新推文(@rossf7)。平台工程师@giantswarm -对云本地基础架构、数据感兴趣…</h3></div><div class="ml l"><p class="bd b dl z fp mi fr fs mj fu fw dk translated">twitter.com</p></div></div><div class="mm l"><div class="mn l mo mp mq mm mr jw md"/></div></div></a></div></div></div>    
</body>
</html>