<html>
<head>
<title>Sangria WebSocket Subscription with Apollo, RxJs and Hyperapp V2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">向Apollo、RxJs和Hyperapp V2订购Sangria WebSocket</h1>
<blockquote>原文：<a href="https://itnext.io/sangria-websocket-subscription-with-apollo-rxjs-and-hyperapp-v2-40d6dfdb5342?source=collection_archive---------1-----------------------#2018-12-16">https://itnext.io/sangria-websocket-subscription-with-apollo-rxjs-and-hyperapp-v2-40d6dfdb5342?source=collection_archive---------1-----------------------#2018-12-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="fbee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你知道为了运行Apollo订阅，GraphQL服务器应该通过<a class="ae kl" href="https://github.com/apollographql/subscriptions-transport-ws/blob/master/PROTOCOL.md" rel="noopener ugc nofollow" target="_blank"> WebSocket协议</a>实现GraphQL吗？</p><p id="6ac3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">之前，我曾与实现该协议的GraphQL服务器合作，例如:节点服务器使用<a class="ae kl" href="https://github.com/apollographql/subscriptions-transport-ws" rel="noopener ugc nofollow" target="_blank">订阅-传输-ws </a>，药剂服务器使用<a class="ae kl" href="https://github.com/absinthe-graphql/absinthe-socket" rel="noopener ugc nofollow" target="_blank">苦艾酒-插座</a>，我将它们与VanillaJS、React和Angular前端集成在一起。没问题！</p><p id="631b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最近，我收到了一个从Scala GraphQL实现— <a class="ae kl" href="https://github.com/sangria-graphql/sangria" rel="noopener ugc nofollow" target="_blank"> sangria </a>消费订阅的要求。原来在sangria中可以实现WebSocket订阅(见<a class="ae kl" href="https://github.com/sangria-graphql/sangria-subscriptions-example" rel="noopener ugc nofollow" target="_blank">sangria-subscriptions-example</a>分支<a class="ae kl" href="https://github.com/sangria-graphql/sangria-subscriptions-example/tree/trbngr-websockets" rel="noopener ugc nofollow" target="_blank">https://github . com/sangria-graph QL/sangria-subscriptions-example/tree/TRB ngr-web sockets</a>)<strong class="jp ir">但是没有实现GraphQL WebSocket协议</strong>Apollo订阅就不行了。</p><p id="d488" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为我别无选择，只能集成，所以我必须实现一个简单的WebSocket Apollo订阅链接。完整的客户端代码可以在Github<a class="ae kl" href="https://github.com/ipassynk/sangria-apollo-websocket-example" rel="noopener ugc nofollow" target="_blank">sangria-Apollo-web socket-example</a>找到，服务器代码可以在<a class="ae kl" href="https://github.com/sangria-graphql/sangria-subscriptions-example/tree/trbngr-websockets" rel="noopener ugc nofollow" target="_blank">https://Github . com/sangria-graph QL/sangria-subscriptions-example/tree/trbngr-web sockets</a>找到</p><h2 id="8119" class="km kn iq bd ko kp kq dn kr ks kt dp ku jy kv kw kx kc ky kz la kg lb lc ld le bi translated">基本Apollo WebSocket链接</h2><p id="1b6c" class="pw-post-body-paragraph jn jo iq jp b jq lf js jt ju lg jw jx jy lh ka kb kc li ke kf kg lj ki kj kk ij bi translated">下面是带有http和订阅链接的基本Apollo客户机设置。WebSocketBasicLink函数将创建一个基本的web套接字链接。由于这是标准的阿波罗代码，所以我不会详细介绍这个设置。</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="d4d7" class="km kn iq lp b gy lt lu l lv lw"><strong class="lp ir">function </strong>createSangriaLink() {<br/>  <strong class="lp ir">return new </strong>WebSocketBasicLink({ uri: "ws://localhost:8080/graphql" });<br/>}<br/><br/><strong class="lp ir">const </strong>wsLink = createSangriaLink();<br/><strong class="lp ir">const </strong>link = split(<br/>  ({ query }) =&gt; {<br/>    <strong class="lp ir">const </strong>{ kind, operation } = getMainDefinition(query);<br/>    <strong class="lp ir">return </strong>kind === "OperationDefinition" &amp;&amp; operation === "subscription";<br/>  },<br/>  wsLink,<br/>  createHttpLink({ uri: "http://localhost:8080/graphql" })<br/>);<br/><br/><strong class="lp ir">const </strong>client = <strong class="lp ir">new </strong>ApolloClient({<br/>  link: link,<br/>  cache: <strong class="lp ir">new </strong>InMemoryCache()<br/>});</span></pre><p id="c7ec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们实现WebSocketBasicLink。作为任何Apollo链接，它应该扩展ApolloLink类。为了使用WebSocket，我使用了RxJs webSocket subject。你可以在<a class="ae kl" href="https://medium.com/p/17125c6f2159?source=post_stats_page---------------------------" rel="noopener">用RxJS处理WebSocket错误</a>阅读我关于RxJS和WebSocket实现的博客</p><p id="5578" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是:</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="7f6c" class="km kn iq lp b gy lt lu l lv lw"><strong class="lp ir">class </strong>WebSocketBasicLink <strong class="lp ir">extends </strong>ApolloLink {<br/>  constructor({ uri }) {<br/>    <strong class="lp ir">super</strong>();<br/><br/>    <strong class="lp ir">this</strong>.requester = operation =&gt; {<br/>      <strong class="lp ir">return new </strong>LinkObservable(observer =&gt; {<br/>        <strong class="lp ir">const </strong>query = print(operation.query);<br/>        <strong class="lp ir">const </strong>subject = webSocket(uri);<br/>        subject.next({ query });<br/><br/>        <strong class="lp ir">const </strong>sub = subject.subscribe(<br/>          data =&gt; observer.next(data),<br/>          error =&gt; observer.error(error),<br/>          () =&gt; observer.complete()<br/>        );<br/><br/>        <strong class="lp ir">return </strong>() =&gt; {<br/>          <strong class="lp ir">if </strong>(!sub.closed) {<br/>            sub.unsubscribe();<br/>          }<br/>        };<br/>      });<br/>    };<br/>  }<br/><br/>  request(op) {<br/>    <strong class="lp ir">return this</strong>.requester(op);<br/>  }<br/>}</span></pre><h2 id="53a7" class="km kn iq bd ko kp kq dn kr ks kt dp ku jy kv kw kx kc ky kz la kg lb lc ld le bi translated">让我们测试一下</h2><p id="200f" class="pw-post-body-paragraph jn jo iq jp b jq lf js jt ju lg jw jx jy lh ka kb kc li ke kf kg lj ki kj kk ij bi translated">现在我们准备运行解决方案。我们将使用:</p><ol class=""><li id="b280" class="lx ly iq jp b jq jr ju jv jy lz kc ma kg mb kk mc md me mf bi translated">GraphiQL可用于向Sangria服务器发送新数据:</li></ol><figure class="lk ll lm ln gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi mg"><img src="../Images/68d10afc8a79424e245318540fb148cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lScUAqwguDNYxVE9KPHDqA.png"/></div></div></figure><p id="d09a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2.上面创建的Apollo客户端通过WebSocket订阅接收事件。</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="6bc9" class="km kn iq lp b gy lt lu l lv lw"><strong class="lp ir">const </strong>query = `<br/>  subscription NewAuthors {<br/>    authorCreated {<br/>      id<br/>      version<br/>      firstName<br/>      lastName<br/>    }<br/>  }<br/>`;</span><span id="bfa4" class="km kn iq lp b gy mo lu l lv lw">client.subscribe({<br/>    query: gql`<br/>      ${query}<br/>    `,<br/>    fetchPolicy: "no-cache"<br/>  })<br/>).subscribe(msg =&gt; {<br/>  console.log(msg);<br/>});</span></pre><p id="437e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">3.Chrome Inspect -&gt; Network -&gt;WS监控webSocket流量。您可以观察客户端和服务器相互传递的消息。</p><figure class="lk ll lm ln gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi mp"><img src="../Images/3ce72804ce9e0ad4809df5070613c1bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wlELZ-zJ69wVZviQZVldvQ.png"/></div></div></figure><h2 id="1f97" class="km kn iq bd ko kp kq dn kr ks kt dp ku jy kv kw kx kc ky kz la kg lb lc ld le bi translated">超app</h2><p id="c2a2" class="pw-post-body-paragraph jn jo iq jp b jq lf js jt ju lg jw jx jy lh ka kb kc li ke kf kg lj ki kj kk ij bi translated">这个解决方案很有效，作为奖励，我决定添加一个简单的UI来显示消息和控制订阅。我每天都用React和Angular，所以我想试试别的。经过快速的研究，我发现了一个有趣的框架来为我的简单UI进行实验。目前，他们正在积极开发具有效果、动作和订阅API的框架的V2(【https://github.com/jorgebucaran/hyperapp/pull/726】)。订阅这是我的任务所需要的。另外<a class="ae kl" href="https://github.com/jorgebucaran/hyperapp" rel="noopener ugc nofollow" target="_blank"> hyperapp </a>看起来和Elm相似，并且允许使用JSX进行查看。</p><p id="087e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">15分钟后，我的用户界面准备就绪。</p><figure class="lk ll lm ln gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi mq"><img src="../Images/7c9619fce0ff2bb11ddcaeebc1b1a9eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YSRL58o-h4NYH6lXxgreww.png"/></div></div></figure><p id="4569" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是一个HyperApp订阅，可以将收到的消息添加到一个集合中进行显示。如果你有使用NGRX或redux-observable的经验，这些术语对你来说应该很熟悉。</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="a260" class="km kn iq lp b gy lt lu l lv lw"><strong class="lp ir">const </strong>effect = <strong class="lp ir">function</strong>(props, dispatch) {<br/>  <strong class="lp ir">const </strong>sub = from(<br/>    client.subscribe({<br/>      query: gql`<br/>        ${query}<br/>      `,<br/>      fetchPolicy: "no-cache"<br/>    })<br/>  ).subscribe(msg =&gt; {<br/>    <strong class="lp ir">const </strong>{<br/>      data: {<br/>        authorCreated: { firstName, lastName }<br/>      }<br/>    } = msg;<br/>    dispatch(props.action, { firstName, lastName });<br/>  });<br/><br/>  <strong class="lp ir">return </strong>() =&gt; sub.unsubscribe();<br/>};<br/><br/><strong class="lp ir">const </strong>AddMessage = (state, message) =&gt;<br/>  Object.assign({}, state, { messages: [...state.messages, message] });<br/><br/><strong class="lp ir">export const </strong>apolloSubscription = props =&gt; ({<br/>  effect: effect,<br/>  action: AddMessage<br/>});</span></pre></div></div>    
</body>
</html>