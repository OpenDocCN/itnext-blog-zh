<html>
<head>
<title>Protect OutSystems REST APIs using OpenID Connect</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用OpenID Connect保护外部系统REST APIs</h1>
<blockquote>原文：<a href="https://itnext.io/protect-outsystems-rest-apis-using-openid-connect-87a2ac7575c1?source=collection_archive---------4-----------------------#2022-10-16">https://itnext.io/protect-outsystems-rest-apis-using-openid-connect-87a2ac7575c1?source=collection_archive---------4-----------------------#2022-10-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="a6d3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本文中，我们将研究如何使用OpenID Connect保护暴露的OutSystems REST API端点。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/f5411e5b68fd33bc8e9506a11496b490.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7GFuZrcnUlIzpYuWs3sATw.png"/></div></div></figure></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><p id="d4f8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">OpenID Connect是基于OAuth 2.0框架的身份层。它允许应用程序(客户端)对用户进行身份验证。实际的身份验证是由一个名为OpenID provider的中央服务执行的。在成功的<strong class="jp ir">认证</strong>之后，提供商发布身份、访问和刷新令牌。访问令牌可用于<strong class="jp ir">授权</strong>应用程序访问资源(API)。</p><p id="5796" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当然，这只是一个粗略的解释，我强烈建议在将OAuth 2.0和OpenID Connect应用于生产环境之前，先对它们有一个很好的理解。一个很好的起点是下面这篇由身份管理平台提供商首席执行官<a class="le lf ep" href="https://medium.com/u/b1c144048921?source=post_page-----87a2ac7575c1--------------------------------" rel="noopener" target="_blank">特拉维斯·斯潘塞</a>撰写的文章。</p><div class="lh li gp gr lj lk"><a href="https://nordicapis.com/api-security-oauth-openid-connect-depth/" rel="noopener  ugc nofollow" target="_blank"><div class="ll ab fo"><div class="lm ab ln cl cj lo"><h2 class="bd ir gy z fp lp fr fs lq fu fw ip bi translated">API安全性:深入研究OAuth和OpenID连接</h2><div class="lr l"><h3 class="bd b gy z fp lp fr fs lq fu fw dk translated">OAuth 2和OpenID Connect是保护API的基础。为了保护您的服务公开的数据，您…</h3></div><div class="ls l"><p class="bd b dl z fp lp fr fs lq fu fw dk translated">nordicapis.com</p></div></div><div class="lt l"><div class="lu l lv lw lx lt ly kv lk"/></div></div></a></div><p id="e5b3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Curity在medium.com上发表关于身份和访问管理的各种主题的文章。</p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><p id="08b2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本演练中，我们将使用以下内容</p><ul class=""><li id="5144" class="lz ma iq jp b jq jr ju jv jy mb kc mc kg md kk me mf mg mh bi translated"><strong class="jp ir"> OutSystems </strong>(当然)——这里我们公开了一个示例REST API端点，并执行一个定制的身份验证，获取客户端应用程序发送的每个请求的访问令牌。我们将验证该令牌，并尝试使用相应的OutSystems用户帐户登录。我们将在后面看到何时以及为什么需要后者。</li><li id="af53" class="lz ma iq jp b jq mi ju mj jy mk kc ml kg mm kk me mf mg mh bi translated"><strong class="jp ir"> Postman </strong> —我们将使用<a class="ae lg" href="https://www.postman.com/" rel="noopener ugc nofollow" target="_blank"> Postman </a>作为我们的客户端应用程序。这比设置示例(如ReactJS应用程序)更容易。Postman具有多种功能，包括一个集成的向导来获取OpenID连接令牌。</li><li id="54c6" class="lz ma iq jp b jq mi ju mj jy mk kc ml kg mm kk me mf mg mh bi translated"><strong class="jp ir"> AWS Cognito </strong> —在本文中，我们使用AWS Cognito作为我们的身份提供者。Cognito将识别和验证用户，并向邮递员发放访问令牌。随意使用任何其他OAuth 2.0 / OpenID Connect支持的身份提供者(<a class="ae lg" href="https://www.curity.io" rel="noopener ugc nofollow" target="_blank"> Curity </a>、<a class="ae lg" href="https://www.auth0.com" rel="noopener ugc nofollow" target="_blank"> Auth0 </a>、<a class="ae lg" href="https://www.okta.com" rel="noopener ugc nofollow" target="_blank"> Okta </a>、<a class="ae lg" href="https://www.keycloak.org/" rel="noopener ugc nofollow" target="_blank"> KeyCloak </a>、<a class="ae lg" href="https://duendesoftware.com/" rel="noopener ugc nofollow" target="_blank"> IdentityServer4 </a>以及许多其他商业和开源身份提供者)。概念是相同的，但是您必须自己找出在哪里配置客户端和用户😒。</li></ul><blockquote class="mn mo mp"><p id="c437" class="jn jo mq jp b jq jr js jt ju jv jw jx mr jz ka kb ms kd ke kf mt kh ki kj kk ij bi translated">像AWS Cognito这样的身份提供者很容易设置。这就是我们在本文中使用它的原因。但是它们不提供与上面更成熟的身份提供者相同的功能。您的安全需求越高，或者您的(API)环境越复杂，您就需要越多的功能。就我个人而言，我喜欢使用开源产品KeyCloak。</p></blockquote><p id="5c4e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">除了Postman和对AWS Cognito(或任何其他身份提供者)的访问，您还需要将以下<a class="ae lg" href="https://www.outsystems.com/forge/" rel="noopener ugc nofollow" target="_blank"> OutSystems Forge </a>组件下载到您的开发环境中。</p><div class="lh li gp gr lj lk"><a href="https://www.outsystems.com/forge/component-overview/1853/jwt" rel="noopener  ugc nofollow" target="_blank"><div class="ll ab fo"><div class="lm ab ln cl cj lo"><h2 class="bd ir gy z fp lp fr fs lq fu fw ip bi translated">JWT</h2><div class="lr l"><h3 class="bd b gy z fp lp fr fs lq fu fw dk translated">用于处理服务器端OAuth身份验证中使用的JSON Web令牌的库。目前，该组件允许生成…</h3></div><div class="ls l"><p class="bd b dl z fp lp fr fs lq fu fw dk translated">www.outsystems.com</p></div></div><div class="lt l"><div class="mu l lv lw lx lt ly kv lk"/></div></div></a></div><p id="7b20" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">joo Almeida的这个组件带来了我们解码和验证访问令牌所需的一切。在Forge上留下评论和星星👌</p><p id="74b3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">伴随这篇文章，我还在OutSystems Forge上发布了一个示例服务<strong class="jp ir">。请安装它，以及我们使用此服务来测试和解释所涉及的步骤。</strong></p><div class="lh li gp gr lj lk"><a href="https://www.outsystems.com/forge/component-overview/13934/protect-exposed-rest-api-using-openid-connect" rel="noopener  ugc nofollow" target="_blank"><div class="ll ab fo"><div class="lm ab ln cl cj lo"><h2 class="bd ir gy z fp lp fr fs lq fu fw ip bi translated">使用OpenID Connect保护公开的REST API</h2><div class="lr l"><h3 class="bd b gy z fp lp fr fs lq fu fw dk translated">示例服务展示了如何在公开的REST APIs上解码和验证OpenID Connect访问令牌。</h3></div><div class="ls l"><p class="bd b dl z fp lp fr fs lq fu fw dk translated">www.outsystems.com</p></div></div><div class="lt l"><div class="mv l lv lw lx lt ly kv lk"/></div></div></a></div></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><p id="0f37" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我在本文中展示的模式是使用OAuth2 / OpenID Connect的客户端到服务器API通信中最常用的模式。总体流程如下。</p><ul class=""><li id="0709" class="lz ma iq jp b jq jr ju jv jy mb kc mc kg md kk me mf mg mh bi translated">您有一个客户端应用程序(例如，ReactJS单一应用程序)，该应用程序已向您的身份提供者注册。</li><li id="aab0" class="lz ma iq jp b jq mi ju mj jy mk kc ml kg mm kk me mf mg mh bi translated">用户启动应用程序，单击登录按钮，然后被重定向到身份提供者的登录页面。</li><li id="52a7" class="lz ma iq jp b jq mi ju mj jy mk kc ml kg mm kk me mf mg mh bi translated">用户在身份提供者处成功登录后，用户被重定向回应用程序，客户端应用程序从身份提供者处获取访问令牌。(这里的流程稍微复杂一点)</li><li id="eb99" class="lz ma iq jp b jq mi ju mj jy mk kc ml kg mm kk me mf mg mh bi translated">然后，客户端应用程序使用访问令牌从REST API获取数据。</li><li id="91c9" class="lz ma iq jp b jq mi ju mj jy mk kc ml kg mm kk me mf mg mh bi translated">REST API对接收到的令牌进行解码。然后，它验证一个或多个标头信息，如颁发者、目标受众、过期时间，最重要的是令牌的签名。</li><li id="91b1" class="lz ma iq jp b jq mi ju mj jy mk kc ml kg mm kk me mf mg mh bi translated">可选地，API验证所谓的作用域——与访问令牌一起传递——并检查作用域是否匹配所请求的API端点资源。虽然不是本文的一部分。</li><li id="fd96" class="lz ma iq jp b jq mi ju mj jy mk kc ml kg mm kk me mf mg mh bi translated">如果一切都有效，REST API将返回请求的数据。</li></ul><p id="cddf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一些附加信息</p><ul class=""><li id="1890" class="lz ma iq jp b jq jr ju jv jy mb kc mc kg md kk me mf mg mh bi translated">只有客户端应用程序必须向身份提供者注册。对于其他需求，将REST API注册为身份提供者的资源服务器<strong class="jp ir">可能</strong>是有用的。但是本文中没有涉及到。</li><li id="b321" class="lz ma iq jp b jq mi ju mj jy mk kc ml kg mm kk me mf mg mh bi translated">您的身份提供者使用只有身份提供者知道的私钥对访问令牌的有效负载进行签名，并将该签名附加到访问令牌。您使用相应的公钥来验证签名。大多数身份提供者通过JSON Web Key服务端点共享他们的公钥。正如我们将看到的那样，AWS Cognito正在这样做。如果您可以验证您的签名(您的API)知道您收到的有效负载是未修改的，并且是由身份提供者签名的，那么您可以信任它。</li><li id="26df" class="lz ma iq jp b jq mi ju mj jy mk kc ml kg mm kk me mf mg mh bi translated">有时您会读到向用户颁发了访问令牌。这不是真的。正确的说法是用户(在身份提供者处)同意客户端应用程序可以使用身份提供者提供的访问令牌代表用户做“事情”。</li><li id="06b4" class="lz ma iq jp b jq mi ju mj jy mk kc ml kg mm kk me mf mg mh bi translated">OpenID Connect身份提供者向客户端应用程序颁发多个令牌(身份令牌、访问令牌、刷新令牌)。只有访问令牌与访问API资源相关。访问令牌必须包含所有必要的信息(称为声明),以标识用户(如果需要)并授权访问公开的资源。</li></ul></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><p id="bc4e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是让我们结束理论部分，从如何在外部系统中实现开始。这是我们要做的</p><ul class=""><li id="f044" class="lz ma iq jp b jq jr ju jv jy mb kc mc kg md kk me mf mg mh bi translated">创建一个AWS Cognito用户池，创建一个示例用户，并将Postman注册为客户端应用程序。</li><li id="d7e7" class="lz ma iq jp b jq mi ju mj jy mk kc ml kg mm kk me mf mg mh bi translated">配置Postman集合以获取访问令牌。</li><li id="e2a2" class="lz ma iq jp b jq mi ju mj jy mk kc ml kg mm kk me mf mg mh bi translated">在公开的REST API中配置一个定制的身份验证流，以处理检索到的访问令牌。</li></ul></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h1 id="7fc7" class="mw mx iq bd my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt bi translated">AWS Cognito —创建用户池</h1><p id="0428" class="pw-post-body-paragraph jn jo iq jp b jq nu js jt ju nv jw jx jy nw ka kb kc nx ke kf kg ny ki kj kk ij bi translated">登录AWS控制台，切换到Cognito服务。点击<strong class="jp ir">创建用户池</strong>。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nz"><img src="../Images/4e89df9b1facb4daef8dbc51268410a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V8tnNwUU2oMem6gjGZMcaw.png"/></div></div><figcaption class="oa ob gj gh gi oc od bd b be z dk translated">认知登录体验</figcaption></figure><p id="a9a9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">勾选<strong class="jp ir">用户名</strong>登录选项和<strong class="jp ir">允许用户用首选用户名</strong>登录。</p><p id="2833" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这在认知上有点奇怪。与其他身份提供者一样，使用Cognito无法配置哪些属性(声明)是访问令牌的一部分。Cognito中的一个访问令牌只包括用户名声明。</p><blockquote class="mn mo mp"><p id="7830" class="jn jo mq jp b jq jr js jt ju jv jw jx mr jz ka kb ms kd ke kf mt kh ki kj kk ij bi translated">如果您在此屏幕上只选择了Email，那么Cognito会为用户生成一个唯一的标识符(不可修改),该标识符也将成为用户名。</p></blockquote><p id="60c9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">稍后，在OutSystems中，我们需要查询Users实体以找到匹配的OutSystems用户，因此我们需要username声明中的值与Users实体记录中的值相匹配。(我们将使用电子邮件地址)</p><p id="0a23" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过检查<strong class="jp ir">用户名</strong>和<strong class="jp ir">允许用户使用首选用户名</strong>登录，我们可以直接配置用户名值，我们只需在那里输入电子邮件地址。这仍然允许用户使用他们的电子邮件地址登录。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi oe"><img src="../Images/21bcfe7fb98c713bba82c05c2f06c710.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AkESh0cQRXC_i6aE6wfzXw.png"/></div></div><figcaption class="oa ob gj gh gi oc od bd b be z dk translated">认知密码策略</figcaption></figure><p id="2abf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在多因素身份验证中，通过选择<strong class="jp ir">无MFA </strong>选项禁用MFA要求。取消选择<strong class="jp ir">启用自助账户恢复</strong>。点击<strong class="jp ir">下一个</strong>。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi oe"><img src="../Images/2fe665507894b463c8e919bc755bd668.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*apGKHAmZA-owPgOcXngeWA.png"/></div></div><figcaption class="oa ob gj gh gi oc od bd b be z dk translated">认知自助服务</figcaption></figure><p id="32b2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">取消选择<strong class="jp ir">启用自注册</strong>和<strong class="jp ir">允许Cognito自动发送消息进行验证和确认</strong>。对于这篇文章，我们将不允许一个未知的用户注册一个帐户。相反，我们将自行提供和确认用户帐户。点击<strong class="jp ir">下一步</strong>。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi of"><img src="../Images/f7c0c8e553b84b221503ce18e1b7647c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wVdsQc0doJO1evVpRPhBYA.png"/></div></div><figcaption class="oa ob gj gh gi oc od bd b be z dk translated">认知电子邮件通知</figcaption></figure><p id="6dc8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">选择<strong class="jp ir">用Cognito </strong>发送电子邮件(虽然我们不会发送任何电子邮件，但必须在此进行配置)。点击<strong class="jp ir">下一个</strong>。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi og"><img src="../Images/35bc3d427e8a1eed9d1dc8f7315d570c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GOBPAQ_XPFtXp0nKMzYG-w.png"/></div></div><figcaption class="oa ob gj gh gi oc od bd b be z dk translated">认知用户池配置</figcaption></figure><p id="521c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">输入您选择的<strong class="jp ir">用户池名称</strong>和<strong class="jp ir">认知域</strong>前缀。</p><p id="4986" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里的助手要求我们也创建一个客户机应用程序注册(我们的Postman客户机)。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi oh"><img src="../Images/4603c9a43879b7642798e8f7475f3d26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hkxTnv89wXpAWTex8NTUaQ.png"/></div></div><figcaption class="oa ob gj gh gi oc od bd b be z dk translated">Cognito客户端应用程序</figcaption></figure><p id="9d6f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">选择<strong class="jp ir">保密客户端</strong>，输入<strong class="jp ir"> App客户端</strong>名称。确保选择了<strong class="jp ir">生成客户端密码</strong>。</p><p id="adca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还必须在这里添加一个<strong class="jp ir">回调URL </strong>。身份验证成功后，用户被重定向回应用程序。身份提供者检查请求的URL是否在配置的列表中，然后才执行重定向。</p><p id="1f11" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Postman为我们提供了一个重定向URL，但是现在只需输入<a class="ae lg" href="https://placeholder" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir">https://placeholder</strong></a>(我们稍后在配置Postman时会更改它)，然后单击<strong class="jp ir">下一个</strong>。</p><p id="e9ed" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<strong class="jp ir">查看和创建</strong>页面查看您的选择，然后点击<strong class="jp ir">创建用户池</strong>。</p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h1 id="e96c" class="mw mx iq bd my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt bi translated">AWS Cognito —创建用户</h1><p id="2868" class="pw-post-body-paragraph jn jo iq jp b jq nu js jt ju nv jw jx jy nw ka kb kc nx ke kf kg ny ki kj kk ij bi translated">在用户池概览中，单击您创建的用户池。</p><p id="eb0d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<strong class="jp ir">用户</strong>选项卡中点击<strong class="jp ir">创建用户</strong>按钮。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi of"><img src="../Images/027ecfaaf50706faab962eaa12439a58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1-R93X5myY7nR_LUbRbntA.png"/></div></div><figcaption class="oa ob gj gh gi oc od bd b be z dk translated">认知创建用户</figcaption></figure><p id="71be" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">输入您的用户的<strong class="jp ir">电子邮件地址</strong>作为<strong class="jp ir">用户名</strong>。稍后，我们将使用该地址在OutSystems用户提供者中查找相应的用户，因此要确保您在这里输入的地址<strong class="jp ir">在OutSystems中已经存在</strong>。</p><p id="0802" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">设置临时密码</strong>。这只是初始密码。当用户第一次登录时，必须更改密码。</p><p id="0631" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">点击<strong class="jp ir">创建用户</strong>。</p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h1 id="7d04" class="mw mx iq bd my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt bi translated">AWS cogni to-Postman应用程序客户端信息</h1><p id="dbfe" class="pw-post-body-paragraph jn jo iq jp b jq nu js jt ju nv jw jx jy nw ka kb kc nx ke kf kg ny ki kj kk ij bi translated">选择<strong class="jp ir">应用集成</strong>选项卡，向下滚动至<strong class="jp ir">应用客户端和分析</strong>。单击我们在创建用户池时添加的Postman客户端条目。</p><p id="08b4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<strong class="jp ir"> App客户端信息下</strong>切换<strong class="jp ir">显示客户端秘密</strong>。让页面保持打开状态，因为在配置Postman时，我们很快会需要<strong class="jp ir"> ClientID </strong>和<strong class="jp ir">客户端机密</strong>。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi oi"><img src="../Images/49fff5669bca2109fad756bb399558f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B2a7y0THLUAY3qnm9vrWwA.png"/></div></div><figcaption class="oa ob gj gh gi oc od bd b be z dk translated">认知客户端应用程序信息</figcaption></figure></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h1 id="9608" class="mw mx iq bd my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt bi translated">邮递员—创建收藏</h1><p id="8b94" class="pw-post-body-paragraph jn jo iq jp b jq nu js jt ju nv jw jx jy nw ka kb kc nx ke kf kg ny ki kj kk ij bi translated">打开Postman，在<strong class="jp ir">收藏</strong>选项卡中点击<strong class="jp ir">新建- &gt;收藏</strong>。为该系列输入您选择的<strong class="jp ir">名称</strong>。</p><p id="f1be" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在集合视图中，首先转到变量选项卡，添加两个变量</p><ul class=""><li id="c248" class="lz ma iq jp b jq jr ju jv jy mb kc mc kg md kk me mf mg mh bi translated"><strong class="jp ir"> ClientID </strong> —将AWS Cognito的<strong class="jp ir"> App客户端信息</strong>中的<strong class="jp ir">客户端ID </strong>值复制到<strong class="jp ir">初始值</strong></li><li id="e149" class="lz ma iq jp b jq mi ju mj jy mk kc ml kg mm kk me mf mg mh bi translated"><strong class="jp ir"> ClientSecret </strong> —将AWS Cognito的<strong class="jp ir"> App客户端信息</strong>中的<strong class="jp ir">客户端秘密</strong>值复制到<strong class="jp ir">初始值</strong></li></ul><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi oj"><img src="../Images/7e149da5cac34e0399539c68eb743381.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ydHjcoEvLYsgeA9-xUdugg.png"/></div></div><figcaption class="oa ob gj gh gi oc od bd b be z dk translated">邮递员集合变量</figcaption></figure><p id="c2a0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">点击<strong class="jp ir">保存</strong>按钮，切换到<strong class="jp ir">授权</strong>页签。</p><p id="2e3c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<strong class="jp ir">授权</strong>选项卡中，从<strong class="jp ir">类型</strong>下拉列表中选择<strong class="jp ir"> OAuth 2.0 </strong>。</p><p id="baad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在配置选项中</p><ul class=""><li id="cd95" class="lz ma iq jp b jq jr ju jv jy mb kc mc kg md kk me mf mg mh bi translated">为令牌输入一个<strong class="jp ir">名称</strong>。可以是任何东西。</li><li id="43ab" class="lz ma iq jp b jq mi ju mj jy mk kc ml kg mm kk me mf mg mh bi translated">确保<strong class="jp ir">授权码</strong>被选为<strong class="jp ir">授权类型</strong>。</li><li id="fd51" class="lz ma iq jp b jq mi ju mj jy mk kc ml kg mm kk me mf mg mh bi translated">在<strong class="jp ir">客户端ID </strong>中输入您创建的变量<strong class="jp ir"> {{ClientID}} </strong></li><li id="3866" class="lz ma iq jp b jq mi ju mj jy mk kc ml kg mm kk me mf mg mh bi translated">在<strong class="jp ir">客户端密码</strong>中输入您创建的变量<strong class="jp ir"> {{ClientSecret}} </strong></li><li id="0dca" class="lz ma iq jp b jq mi ju mj jy mk kc ml kg mm kk me mf mg mh bi translated">在<strong class="jp ir">验证URL </strong>中，输入您的认知域，然后输入<strong class="jp ir"> /oauth2/authorize </strong></li><li id="0b30" class="lz ma iq jp b jq mi ju mj jy mk kc ml kg mm kk me mf mg mh bi translated">在<strong class="jp ir">访问令牌URL </strong>中，输入您的认知域，后跟<strong class="jp ir">/oauth 2/令牌</strong></li></ul><p id="8055" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你会在<strong class="jp ir">域</strong>下<strong class="jp ir">用户池</strong>的<strong class="jp ir">应用集成</strong>标签中找到你的Cognito域。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ok"><img src="../Images/27f79942ad2082197bce6b7641f36198.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7Ce1C7LmUug4tqupidu52w.png"/></div></div><figcaption class="oa ob gj gh gi oc od bd b be z dk translated">认知域信息</figcaption></figure><p id="7e12" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它遵循以下命名约定</p><pre class="km kn ko kp gt ol om on oo aw op bi"><span id="e141" class="oq mx iq om b gy or os l ot ou">https://&lt;your subdomain&gt;.&lt;your region&gt;.amazoncognito.com</span></pre><p id="3102" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上面的示例截图翻译过来就是</p><ul class=""><li id="4578" class="lz ma iq jp b jq jr ju jv jy mb kc mc kg md kk me mf mg mh bi translated"><strong class="jp ir">认证网址</strong>—https://osdemorest . Auth . eu-central-1 . Amazon cognito . com/oauth 2/authorize</li><li id="f63b" class="lz ma iq jp b jq mi ju mj jy mk kc ml kg mm kk me mf mg mh bi translated"><strong class="jp ir">访问令牌URL</strong>—https://osdemorest . auth . eu-central-1 . amazoncognito . com/oauth 2/Token</li><li id="156a" class="lz ma iq jp b jq mi ju mj jy mk kc ml kg mm kk me mf mg mh bi translated">选中复选框<strong class="jp ir">使用浏览器授权</strong></li><li id="7a53" class="lz ma iq jp b jq mi ju mj jy mk kc ml kg mm kk me mf mg mh bi translated">复制<strong class="jp ir">回调URL </strong>的值</li></ul><p id="5c45" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">回到我们的AWS Cognito Postman客户端应用程序配置，单击<strong class="jp ir">托管UI部分</strong>中的<strong class="jp ir">编辑</strong>按钮。</p><p id="a53d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">用复制的值覆盖<strong class="jp ir">允许的回调URL</strong>下的<a class="ae lg" href="https://placeholder" rel="noopener ugc nofollow" target="_blank"> https://placeholder </a>。然后点击<strong class="jp ir">保存更改</strong>。</p><p id="6d0d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您在Postman中的授权配置现在应该是这样的。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/40e84a6ed55e49a9aa39542b9b42a370.png" data-original-src="https://miro.medium.com/v2/resize:fit:1060/format:webp/1*IBbifirDIuQUgNKYre8MnA.png"/></div><figcaption class="oa ob gj gh gi oc od bd b be z dk translated">邮递员集合授权配置</figcaption></figure><p id="2970" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">保存</strong>收藏。</p><p id="d72d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">点击<strong class="jp ir">获取新的访问令牌</strong>按钮。Postman会打开一个浏览器窗口，您会被重定向到默认的AWS Cognito登录页面。使用您之前创建的用户登录。最后，你会被要求打开邮递员。邮递员将显示检索到的令牌。点击<strong class="jp ir">使用令牌按钮</strong>保存。</p><p id="3936" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将令牌存储在Postman中，并用于与此集合关联的所有REST调用。默认情况下，将始终使用最后检索到的令牌。</p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h1 id="3b84" class="mw mx iq bd my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt bi translated">外部系统—服务配置示例</h1><p id="c83f" class="pw-post-body-paragraph jn jo iq jp b jq nu js jt ju nv jw jx jy nw ka kb kc nx ke kf kg ny ki kj kk ij bi translated">如果您还没有从OutSystems Forge下载示例服务，请现在就下载。在我们尝试之前，你必须配置模块的一些站点属性。这些是</p><ul class=""><li id="ffdf" class="lz ma iq jp b jq jr ju jv jy mb kc mc kg md kk me mf mg mh bi translated">IDPIssuer  —该场地拥有URI。它用于验证访问令牌的颁发者(iss)声明。</li><li id="a212" class="lz ma iq jp b jq mi ju mj jy mk kc ml kg mm kk me mf mg mh bi translated"><strong class="jp ir"> IDPJWKS </strong> —可以检索签名验证的公钥的端点。</li></ul><p id="d9b4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您将需要您的AWS用户池ID来构建URIs。这可以在您的用户池的概览页面中找到。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ow"><img src="../Images/aabccb7661c13c39c7a352f6a1af6493.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YMXdYUWzNVAW6p3N5FAu1g.png"/></div></div><figcaption class="oa ob gj gh gi oc od bd b be z dk translated">用户池概述</figcaption></figure><p id="1d14" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<strong class="jp ir"> OutSystems服务中心</strong>中，打开示例服务的模块<strong class="jp ir"> OpenIDRESTAPI </strong>并配置两个站点属性。</p><pre class="km kn ko kp gt ol om on oo aw op bi"><span id="d294" class="oq mx iq om b gy or os l ot ou">IDPIssuer<br/>https://cognito-idp.<strong class="om ir">&lt;region&gt;</strong>.amazonaws.com/<strong class="om ir">&lt;user pool id&gt;</strong></span><span id="a301" class="oq mx iq om b gy ox os l ot ou">IDPJWKS<br/>https://cognito-idp.<strong class="om ir">&lt;region&gt;</strong>.amazonaws.com/<strong class="om ir">&lt;user pool id&gt;</strong>/.well-known/jwks.json</span></pre></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h1 id="e3ad" class="mw mx iq bd my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt bi translated">邮递员-查询示例服务</h1><p id="d402" class="pw-post-body-paragraph jn jo iq jp b jq nu js jt ju nv jw jx jy nw ka kb kc nx ke kf kg ny ki kj kk ij bi translated">在Postman中添加一个新的<strong class="jp ir">请求</strong>到你的收藏中，并给它一个名字，例如<strong class="jp ir">获取我的个人资料</strong>。</p><p id="dbd7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">检查<strong class="jp ir">方法</strong>是否设置为<strong class="jp ir">获取</strong>。</p><p id="634b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">作为端点URL输入</p><pre class="km kn ko kp gt ol om on oo aw op bi"><span id="9adb" class="oq mx iq om b gy or os l ot ou">https://&lt;your OutSystems environment&gt;/OpenIDRESTAPI/rest/Profile/Me</span></pre><p id="901b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">点击<strong class="jp ir">保存</strong>按钮。</p><p id="f76a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">尝试使用<strong class="jp ir">发送</strong>按钮查询服务。如果您在我们配置集合<strong class="jp ir">授权</strong>时请求的令牌仍然有效，您应该会看到以下响应</p><pre class="km kn ko kp gt ol om on oo aw op bi"><span id="644b" class="oq mx iq om b gy or os l ot ou">{<br/>  "Name": &lt;Name of the user as stored in OutSystems User Provider&gt;,<br/>  "Email": &lt;Email address of user as stored in OutSystems User Provider&gt;<br/>}</span></pre><p id="1c8e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果出现错误，首先从集合的<strong class="jp ir">授权</strong>选项卡请求一个新令牌，然后重试。</p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h1 id="014d" class="mw mx iq bd my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt bi translated">外部系统—示例服务演练</h1><p id="f5bb" class="pw-post-body-paragraph jn jo iq jp b jq nu js jt ju nv jw jx jy nw ka kb kc nx ke kf kg ny ki kj kk ij bi translated">示例服务公开了一个端点(<strong class="jp ir"> Me </strong>)。在这里，使用设置为<strong class="jp ir"> GetUserId() </strong>函数的过滤器查询<strong class="jp ir"> Users </strong>实体。</p><p id="8b9e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">服务本身设置为<strong class="jp ir">自定义</strong>认证。在<strong class="jp ir">on认证</strong>流程中，完成以下工作。</p><ul class=""><li id="197e" class="lz ma iq jp b jq jr ju jv jy mb kc mc kg md kk me mf mg mh bi translated">我们使用来自<strong class="jp ir"> HTTPRequestHandler </strong>模块的<strong class="jp ir"> GetRequestHeader </strong>动作来检索授权头。</li><li id="d9e5" class="lz ma iq jp b jq mi ju mj jy mk kc ml kg mm kk me mf mg mh bi translated">报头包含值<strong class="jp ir">载体</strong>，后跟实际令牌。我们使用<strong class="jp ir"> String_Split </strong>从<strong class="jp ir"> Text </strong>模块中分离出单词Bearer和令牌。</li></ul><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi oy"><img src="../Images/0cd70094cf309a2d958ad49eedf8b421.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l931TSfQpUKIZY2A0Es_0A.png"/></div></div><figcaption class="oa ob gj gh gi oc od bd b be z dk translated">自定义身份验证</figcaption></figure><ul class=""><li id="61a2" class="lz ma iq jp b jq jr ju jv jy mb kc mc kg md kk me mf mg mh bi translated">使用来自JWT模块的<strong class="jp ir">ReadTokenWithoutValidation</strong>我们解码令牌。这是必要的，这样我们就可以获得AWS Cognito使用哪个私钥对令牌有效负载进行签名的信息。</li><li id="e9e4" class="lz ma iq jp b jq mi ju mj jy mk kc ml kg mm kk me mf mg mh bi translated">我们使用提取的密钥Id查询JWKS端点，以使用来自JWT模块的<strong class="jp ir"> GetJwkFromJwksEndpoint </strong>服务器操作检索公钥。</li><li id="2a0a" class="lz ma iq jp b jq mi ju mj jy mk kc ml kg mm kk me mf mg mh bi translated">然后我们使用来自JWT模块的<strong class="jp ir"> ReadAndValidateToken </strong>服务器动作来验证令牌，包括令牌的<strong class="jp ir">到期</strong>、发布者<strong class="jp ir">和签名<strong class="jp ir"/>。</strong></li></ul><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi oz"><img src="../Images/9617e064a87596c23d54c369f2d6cc4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lV31mfVL2ZC006Oxoh8rjQ.png"/></div></div><figcaption class="oa ob gj gh gi oc od bd b be z dk translated">自定义身份验证</figcaption></figure><ul class=""><li id="afd8" class="lz ma iq jp b jq jr ju jv jy mb kc mc kg md kk me mf mg mh bi translated">最后，我们使用<strong class="jp ir"> ListFilter </strong>服务器动作过滤<strong class="jp ir">用户名</strong>声明的访问令牌声明。我们尝试使用聚合来查找现有的OutSystems用户，如果找到，我们使用来自<strong class="jp ir">系统</strong>模块的<strong class="jp ir">登录</strong>服务器动作来执行用户id的<strong class="jp ir">非持久</strong>登录。</li></ul><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi pa"><img src="../Images/a0f721a1c9daeaf3fa36c192e4ac3732.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jo5ejDL3sclhsIk0swMAng.png"/></div></div><figcaption class="oa ob gj gh gi oc od bd b be z dk translated">自定义身份验证</figcaption></figure><blockquote class="mn mo mp"><p id="b1e1" class="jn jo mq jp b jq jr js jt ju jv jw jx mr jz ka kb ms kd ke kf mt kh ki kj kk ij bi translated">每当出现错误或验证失败时，我们设置结果状态代码403(禁止)，并通过引发异常退出。</p></blockquote><p id="4fe4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">仅此而已。概括来说，自定义身份验证流程中的步骤包括:</p><ul class=""><li id="d374" class="lz ma iq jp b jq jr ju jv jy mb kc mc kg md kk me mf mg mh bi translated">从授权头中检索访问令牌</li><li id="487a" class="lz ma iq jp b jq mi ju mj jy mk kc ml kg mm kk me mf mg mh bi translated">解码令牌以获取公钥id</li><li id="bd36" class="lz ma iq jp b jq mi ju mj jy mk kc ml kg mm kk me mf mg mh bi translated">从JWKS端点下载公钥</li><li id="0f97" class="lz ma iq jp b jq mi ju mj jy mk kc ml kg mm kk me mf mg mh bi translated">验证令牌</li><li id="e502" class="lz ma iq jp b jq mi ju mj jy mk kc ml kg mm kk me mf mg mh bi translated">查找OutSystems用户并执行登录</li></ul></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h1 id="afa8" class="mw mx iq bd my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt bi translated">笔记</h1><p id="de6b" class="pw-post-body-paragraph jn jo iq jp b jq nu js jt ju nv jw jx jy nw ka kb kc nx ke kf kg ny ki kj kk ij bi translated">正如您自己可能已经发现的那样，这个流程并没有优化。我试图用最简单的方式展示相关的步骤。虽然已经够复杂了。尤其是如果你以前没有使用过OAuth2 / OpenID Connect。</p><p id="d358" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">按照计划同步JWKS端点签名公钥并使用缓存的值进行令牌验证是有意义的。这稍微减少了延迟。</p><p id="4377" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，令牌缓存也很有意义，您可以在实体中存储令牌签名、其到期时间和相应的OutSystems用户id。每当您检索一个令牌时，您都会查找缓存的条目来比较签名并直接登录用户。这也减少了一点流量。</p><p id="b827" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此示例显示了如何使用来自您信任的颁发者的公钥仅在后端验证令牌。这对于大多数用例来说已经足够了。还有另一种称为<strong class="jp ir">令牌自省</strong>的方法，您将令牌发送给身份提供者进行验证。这支持其他用例，如令牌撤销。如果您有这样的需求，您需要一个更成熟的身份提供者，因为AWS Cognito还没有实现令牌自省OAuth2规范。</p><p id="4832" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当然还有更多…</p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><p id="89d7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">感谢您的阅读。我希望你喜欢它，并且我已经很好地解释了重要的部分。如果没有，请告诉我😊</p><p id="1150" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您在启动和运行时遇到困难，请使用<a class="ae lg" href="https://www.outsystems.com/forums" rel="noopener ugc nofollow" target="_blank"> OutSystems论坛</a>获得帮助。非常欢迎对如何改进这篇文章提出建议。通过我的<a class="ae lg" href="https://www.outsystems.com/profile/0qginuc0j5/overview" rel="noopener ugc nofollow" target="_blank"> OutSystems档案</a>给我发消息，或者直接在medium上回复。</p><p id="6c1d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你喜欢我的文章，请留下一些掌声。关注我并订阅，以便在我发布新文章时收到通知。低编码快乐！</p></div></div>    
</body>
</html>