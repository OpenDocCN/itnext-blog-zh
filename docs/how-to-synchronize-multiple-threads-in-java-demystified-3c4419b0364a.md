# 如何在 Java 中同步多线程——揭秘

> 原文：<https://itnext.io/how-to-synchronize-multiple-threads-in-java-demystified-3c4419b0364a?source=collection_archive---------0----------------------->

每当有人让你**写一个多线程应用**的时候，你会害怕吗？我曾经。我已经尝试阅读各种书籍，但仍然有相同的恐惧盛行，直到我试图实现它们，并与它们玩耍。它们非常令人兴奋，会提出许多好奇的问题，最好的部分是调试它们。

在本文中，我们将讨论使用 Java 线程的线程同步，并用一个非常简单的例子来阐明我们的概念。唯一的先决条件是理解基本的 Java 语法和关于 Java 线程的初步知识(或者，你可以快速参考[这个](https://medium.com/@madhupathy/a-beginners-guide-to-java-part-3-of-3-f0c9ba3648b1))。所以，让我们跳进去吧！

![](img/9005ba73c6804efabd694f858e2743f7.png)

嗯...不是那些线！学分:[阿米拉里](https://unsplash.com/@amir_v_ali)

线程是轻量级进程，可以以分时方式并行执行。它们是程序将自己分成两个或更多同时(或*伪同时*)运行的任务的一种方式。线程和进程因操作系统而异，但通常，一个线程包含在一个进程中，同一进程中的不同线程共享相同的资源，而同一多任务操作系统中的不同进程则不共享。

Java 通过使用**同步块**提供了一种创建线程和同步其任务的方法。让我们从我们的例子开始。

我们将使用一个计数器类，它只有一个成员变量 **count** 和一个方法 **incr()** ，该方法将 count 变量的值递增 1。

```
class Counter{
  int count;
  public void incr(){ count++; }
}
```

在 **main()** 中，我们使用 ***Runnable*** 对象并覆盖 **run()** 方法来创建一个线程 **t1** ，在其中我们将 count 的值递增 100 次。

应该会打印`Count = 100`吧？但事实并非如此。暂停，想一会儿！

**main()** 方法也运行在一个线程上，这个线程是 JVM 创建的 Java 中的默认主线程。当我们的线程 t1 在循环内部 0 到 100 之间的某个位置时，主线程继续前进(*它不等待*)并在那个实例打印 count **的值。非常迷人的东西。**

我们希望程序等待线程 t1 完成它的执行。我们将利用线程的 **join()** 方法，这将确保 ***t1*** 在程序执行 ***下一条指令*** 之前终止。此外，它还抛出需要处理的**中断异常**。

酷！它根据我们的需要打印`Count = 100`。现在让我们**将它带到下一个级别**并添加另一个可以并行运行的线程。

我们定义了另一个线程 t2，它做的事情和 t1 一样。现在*两者都将计数器递增 1000 倍*，那么我们预期的正确值应该是 2000。轻松点。

在您的本地系统上运行上面的 Java 程序**(在线编译器很慢，可能会给出意想不到的结果)，您会发现 count 的打印值**小于 2000** 。**

为什么会这样？

操作`count++`是**而不是原子**，在底层，机器需要为这一行代码发出多条指令。可能发生的情况是，当线程 t1 将计数器从 1000 递增到 1001 时，并且在它被更新到 1001 之前，线程 t2 访问计数器并且再次将其从 1000 递增到 1001。因此，在大多数情况下，我们得到的值小于或等于 2000。我们可以借助于 **synchronized 关键字来处理这个问题。**

使 **incr()** 方法同步将确保只有一个线程可以使用该方法，其他线程必须等待。从而使其成为线程安全的。

因此，计数器产生的输出是 2000，仍然需要 **join()** 方法，因为我们希望打印语句等到线程 t1 和 t2 的执行都结束。

## 语法概述

我们知道如何在 Java 中同步多个线程。让我们来看看一些语法。比如我们在同步对象的时候(比方说， **sync_obj** )。

```
synchronized (sync_obj){
  // code
  // more code ..
  // Access shared resources
  ...
}
```

有时，我们需要同步**方法**，也许是为了防止它被两个或更多线程同时调用。例如，我们想要同步 **my_func()** 方法。

```
public synchronized void my_func(){
  // code
  // more code ..
  // Access shared resources
  ...
}
```

此外，有时我们可能需要同步方法的一部分，如下所示。

```
public void my_func(){
  System.out.println("Hello World!");
  ...
  synchronized (**this**){
    ...
    // Access shared resources
    ...
  }
  ...
  System.out.println("Goodbye!");
}
```

有了这么多的知识，您现在已经做好了准备，可以在 Java 中深入研究和试验多线程程序了。一路平安！

![](img/01e10a351d0411ece0c13c99630e1643.png)

来源: [Unsplash](https://unsplash.com/photos/A7_JA-0djb4)

如果这篇文章对你有帮助，请考虑鼓掌。祝您愉快！:)