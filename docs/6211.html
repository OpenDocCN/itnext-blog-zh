<html>
<head>
<title>OPA — Generating Constraint/ConstraintTemplates</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">OPA生成约束/约束模板</h1>
<blockquote>原文：<a href="https://itnext.io/opa-generating-constraint-constrainttemplates-aac1a34302c0?source=collection_archive---------3-----------------------#2021-09-20">https://itnext.io/opa-generating-constraint-constrainttemplates-aac1a34302c0?source=collection_archive---------3-----------------------#2021-09-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/45b5ff5711efedcf785b355d5170ea22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oS1USu98ab97Cn38CeBtSA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">konstraint标志</figcaption></figure><p id="f9cc" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">最近，我开始使用开放策略代理(OPA)网关守护设备编写要在Kubernetes集群上实施的策略。该过程包括使用减压阀语言创建策略/断言，然后将逻辑打包到OPA CRD的:</p><ul class=""><li id="303f" class="la lb iq ke b kf kg kj kk kn lc kr ld kv le kz lf lg lh li bi translated"><strong class="ke ir"> ConstraintTemplate </strong> —具有rego逻辑的资源，并定义策略是否具有输入参数(由约束提供)。</li><li id="f341" class="la lb iq ke b kf lj kj lk kn ll kr lm kv ln kz lf lg lh li bi translated"><strong class="ke ir">约束</strong> —定义什么资源类型将触发ConstraintTemplate中定义的策略的评估。此外，这是您可以向策略参数传递值的地方。</li></ul><p id="f928" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我面临的挑战之一是将我的减压阀逻辑嵌入到ConstraintTemplate中。我经历了几次反复，想分享一下最终的选择。</p><p id="c217" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">方法1——我最初从一个带有sed命令的原始bash脚本开始。这是一个糟糕的方法，因为它没有验证YAML。它充其量是hacky。它主要读取. spec.targets.rego中的值，该值被设置为文件名。然后，我会读取该文件并将其加载到YAML中。</p><p id="32e9" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">方法2——在与我的Google客户工程师交谈时，她向我介绍了一个用于Forsetti策略的python脚本，它也是基于OPA的。我不得不根据自己的需要做一些小的更新。虽然这有效，但我必须继续维护这个脚本。来源:<a class="ae lo" href="https://github.com/GoogleCloudPlatform/policy-library/blob/master/scripts/inline_rego.py" rel="noopener ugc nofollow" target="_blank">https://github . com/Google cloud platform/policy-library/blob/master/scripts/inline _ rego . py</a></p><p id="9bb0" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">方法3——灵光一现，一位同行在<a class="ae lo" href="https://github.com/plexsystems/konstraint" rel="noopener ugc nofollow" target="_blank"> github </a>上发现了这块宝石。konstraint是一个可以执行以下操作的实用程序:</p><ul class=""><li id="963a" class="la lb iq ke b kf kg kj kk kn lc kr ld kv le kz lf lg lh li bi translated">生成约束模板</li><li id="406c" class="la lb iq ke b kf lj kj lk kn ll kr lm kv ln kz lf lg lh li bi translated">生成约束(仅当模板中没有参数时)</li><li id="5573" class="la lb iq ke b kf lj kj lk kn ll kr lm kv ln kz lf lg lh li bi translated">生成文档—使用类似于Javadoc的注释和文档格式，自动生成文档</li></ul><p id="3a59" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">基于konstraint提供的价值，我决定使用它来减少我个人管理的代码量</p><h1 id="4a09" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">生成约束模板/约束</h1><p id="5be4" class="pw-post-body-paragraph kc kd iq ke b kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ij bi translated">要生成YAML内容，请运行konstraint create。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="a029" class="nb lq iq mx b gy nc nd l ne nf">konstraint create opa --output yaml</span></pre><p id="291f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">它遵循一些惯例:</p><ul class=""><li id="56d0" class="la lb iq ke b kf kg kj kk kn lc kr ld kv le kz lf lg lh li bi translated">opa/ folder下的文件夹名称将驱动为ConstraintTemplate生成的CRD的名称。</li><li id="1a08" class="la lb iq ke b kf lj kj lk kn ll kr lm kv ln kz lf lg lh li bi translated">避免在文件夹名称中使用下划线，以符合kubernetes对所有资源强制执行的DNS命名标准。</li><li id="c4ee" class="la lb iq ke b kf lj kj lk kn ll kr lm kv ln kz lf lg lh li bi translated">生成的文件将如下所示</li></ul><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="257a" class="nb lq iq mx b gy nc nd l ne nf">constraint_&lt;folder_name&gt;.yaml<br/>template_&lt;folder_name&gt;.yaml</span></pre><p id="6a7a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如上所述，如果您有带参数的策略，将不会生成约束。你需要自己管理它们。您将看到一条警告:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="54ab" class="nb lq iq mx b gy nc nd l ne nf">WARN[0000] skipping constraint generation due to use of parameters name=&lt;policy name&gt; src=opa/&lt;folder&gt;/&lt;file&gt;.rego</span></pre><p id="41f6" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">要生成ConstraintTemplate / Constraint，请在包定义之前创建一个文档块。它看起来会像这样:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="dcb9" class="nb lq iq mx b gy nc nd l ne nf"># @title this is a basic title for my policy<br/>#<br/># This is the longer explanation of my policy details <br/># and the opinions it enforces<br/># @enforcement deny  # This is the default, but could be dryrun</span><span id="29d6" class="nb lq iq mx b gy ng nd l ne nf"># The line below is used to generate the constraint by linking the resource types of interest to the policy<br/># @kinds core/pod bigquerydatasets.crnm.cloud.google.com/BigQueryDataset</span><span id="4815" class="nb lq iq mx b gy ng nd l ne nf"># The line below defines parameters for the ConstraintTemplate. As such, you need to define the Constraints yourself.<br/># @parameter &lt;name&gt; array string<br/># @parameter resource_types array string</span></pre><p id="e857" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">更多信息，请参考konstraint <a class="ae lo" href="https://github.com/plexsystems/konstraint/blob/main/docs/constraint_creation.md" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><h1 id="060a" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">生成文档</h1><p id="9181" class="pw-post-body-paragraph kc kd iq ke b kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ij bi translated">要生成文档，请运行konstraint doc命令。它将从当前目录中扫描，以查找带有violation[]条目(匹配OPA框架/预期)的rego文件。</p><p id="6f95" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">因此，它将使用从rego代码中提取的信息创建一个policies.md。这些细节将是未来博客文章的基础。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="4997" class="nb lq iq mx b gy nc nd l ne nf">konstraint doc --no-rego</span></pre><h1 id="f3cf" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">结论</h1><p id="4f20" class="pw-post-body-paragraph kc kd iq ke b kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ij bi translated">konstraint超出了我的预期，帮助我实现了尽可能自动化的目标。如果没有它或我的临时方法，我将不得不构建rego文件并手动将其复制到ConstraintTemplates中。绝对不是一个可持续的方法。</p><p id="72f6" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">系统生成的文档是最棒的……是下一篇博客的焦点。</p></div></div>    
</body>
</html>