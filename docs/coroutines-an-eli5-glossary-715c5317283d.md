# 协程:ELI5 词汇表

> 原文：<https://itnext.io/coroutines-an-eli5-glossary-715c5317283d?source=collection_archive---------0----------------------->

S 简单、简短、快速——这个术语表最适合用作协程的介绍，或者快速提醒您在使用协程时应该了解的内容。

![](img/ee2f2c9712c58d8b9c37449fd1305f80.png)

埃里克·汤普金斯在 [Unsplash](https://unsplash.com/s/photos/circus?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上的照片

在我们开始之前，让我们弄清楚一件事:这并不是对 Kotlin 协程的深入指导。不会有深入的源代码或一个 1000 字的段落来解释为什么事情会这样。虽然知道这些都很重要，但它们根本不是这篇文章的主题。

这是一个非常方便的小参考文档，当你深陷协程，突然忘记了`async`和`launch`之间的区别时，你可以翻阅一下。

## 目录

我试图制作一个功能性的内容，但显然链接就是不工作。

1.  [什么是协程？](#5519)
    1.1 [关于暂停功能](#abb3)
    1.2 的说明。我一直听说的工作是什么？
2.  [什么是协程？](#69d9)
    2.1。[协程范围—准备就绪…](#f5a1)
    2.2。[协程上下文—设置这一切…](#3733)
    2.3。协程生成器——我们出发了！
3.  [启动器:启动 vs 异步](#42e8)
    3.1。[关于例外和取消的说明](#a570)
4.  [切换上下文，或者如何从 UI 跳转到 IO，然后再返回](#236c)

# 什么是协程？

正如 Kotlin 博士所说，协程就像一个轻量级线程。一次发射 10 000 枚导弹不会比预期的更多，它们会起作用的。

## 关于暂停函数的一个注记

Kotlin 协同程序依赖于挂起函数——带有修饰符`suspend` *的函数。*一个常见的错误是，仅仅因为函数是挂起的，就认为它是自动异步的。

事实并非如此。挂起函数仅仅意味着函数可以在某个时刻被挂起，*但这并不是必须的。*

更多关于阻塞和暂停的细节在这里。

*了解更多…*

您可能想知道轻量级线程到底是什么。如果你很好奇，想绕道走，可以看看这些视频:[这里](https://www.youtube.com/watch?v=_hfBv0a09Jc)，这里[这里](https://www.youtube.com/watch?v=a3agLJQ6vt8)，这里[这里](https://www.youtube.com/watch?v=YrrUCSi72E8)。

## 我一直听说的工作是怎么回事？

每次由`launch`或`async`启动协程时，结果返回值是一个作业。Job 告诉您协程是否正在运行，这意味着您可以使用它来操纵协程的生命周期(例如，取消它)，以及它与另一个线程的关系。

使用 Job 而不仅仅是`launch`*-*-ing 或者`async` -ing 你的协程可以让你对协程本身有更多的控制。一般来说，工作是很有帮助的，但是，对于这个特殊的术语表来说有点多。

*了解更多…*

当您希望尽可能控制您的协程时，作业尤其有价值。你可以在这里找到更深入的解释。

# 什么构成了协程？

没有这三位就没有协程:作用域、上下文和构建器。你可以把它们看作是现成的语句。范围在准备，背景在设置，一个建造者最终出发并完成任务。

让我们一个一个地检查它们。

## 协程作用域—准备就绪…

协程作用域处理协程的生命周期，即 ***和*何时结束。****

> *作用域就像一个(马戏团)帐篷——每个协程都在里面执行，当帐篷倒下时，里面的所有东西也倒下。*

*这主要归功于 Kotlin 的结构化并发。我们不会在这里深入讨论这个问题，但是一个非常简单的观点是，如果一个特定范围内的任何协程失败，所有的工作都会被取消。你可以通过一种叫做`SupervisorJob`的特殊工作来逃避这个问题。我们不会在这篇文章中讨论这个问题。*

*创建作用域的最简单方法是这样的:*

*现在我们有了一个瞄准镜！这里的工作是当我们需要时，我们可以很容易地取消作用域，这里的`Dispatchers.Main`是说用于代码执行的线程将是 UI 线程。*

*稍后，我们想要取消我们的`circusTent`范围内所有协程的执行。因为我们定义了一个我们自己的作业并将其传递给了作用域，所以我们稍后要做的就是调用*

```
*eveningShow.cancel()*
```

*马戏团帐篷里正在进行的任何工作都将被取消。*

*这里需要注意的一点是,`CoroutineScope`构造函数只接受一个参数——协程上下文。*

*这意味着，我们可以像这样编写与上面相同的代码:*

**了解更多…**

*在这里阅读更多关于结构化并发的文章(我强烈建议你这样做)。*

*如果你对主管工作感兴趣，看看这篇文章。*

*`CoroutineScope`和`coroutineScope`实际上是不同的。前者是一个构造函数，在创建父子协程层次结构时，您可以将后者视为一个助手(它必须一如既往地在某种范围内)。在[文档](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html)中有一些关于它的小东西。关于何时使用`coroutineScope`合适的另一个例子是这里的。*

## *协程上下文—设置一切…*

*一个上下文负责告诉你的协程 ***它应该在哪里执行*** 。*

> *所以，再次使用马戏团帐篷的比喻，上下文就像马戏团的老板，他负责告诉小丑、杂技演员和其他表演者他们应该在哪里工作。老板，如果你愿意的话。
> 就像在现实生活中一样，你的老板是个多头，他也可能会改变。*

*上下文本身实际上是对`CoroutineContext.Elements` *的包装。*这些元素中的每一个(这么多的头)负责协程的组成部分:*

*   *如前所述，你可以使用作业来控制协程的生命周期，也就是取消它。*
*   *分派器
    分派器记录哪个线程上启动了什么，哪个线程应该被使用，以及如何回到适当的线程。
    整个事情依赖于一个`ContinuationInterceptor`are——一个紧密跟随协程延续的机制(更深入的解释，再一次，太多了，无法放进这个小小的手工词汇表中)。*
*   *异常处理程序
    非常简单明了——它处理协程中的任何异常。*

*如果我们看一下我们的`circusTent`范围，我们注意到我们可以添加一个`CoroutineExceptionHandler` *:**

***上下文切换**是协程不可分割的一部分。在我们介绍了协程启动程序及其类型之后，我们将回到这个问题，并更仔细地研究一下调度程序。*

**了解更多…**

*要找出调度程序和上下文背后的具体细节，请查看教程 *中的第 6 章和第 7 章。你也可以查看[文档](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines/-continuation-interceptor/)。**

## *协程构建器—我们出发了！*

*构建器，你的`launch`和`async` *，* **创建**协程，并使其中的代码能够执行。*

> *建筑工人是舞台，马戏团演员是你的代码。*
> 
> *不可思议的 Melrosas(你的代码)只有在一切都准备好了之后才会骑着他们的自行车走钢丝:一个帐篷(协程范围)，一个马戏团团长或任何其他类型的老板(协程上下文)，以及舞台本身(协程构建者)。*

*![](img/a89b113ae9a265baae51cb06c2c767c9.png)*

*[美国国会图书馆](https://unsplash.com/@libraryofcongress?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)在 [Unsplash](https://unsplash.com/s/photos/circus?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 拍摄的照片*

# **启动器:启动 vs 异步**

*两人都是建筑工人。两者都启动协程。一旦你启动它们，它们就会执行你的代码。那么，有什么区别呢？*

*最明显的一个是`async`根据 Futures/Promises 原理运行，它返回一个`Deferred<T>`对象——这个对象携带一个在异步块中计算的值(注意，Deferred 实现了 Job，所以两种“类型”的协程仍然以某种方式返回一个 Job)。*

*`launch`其实没有这样的东西——它只有一份工作。一个`launch`不会返回一个“正确的”计算值。*

*所以异步和启动的区别主要在于**暂停点**和**异常处理**。*

*让我们来看看悬挂点。*

*当像这样启动一个协程时:*

*我们在 2 点上暂停上面的代码。首先，我们在等待`isOnHighWire`的结果时冻结一切，然后我们在`isRidingBike`再次做同样的事情。*

> *一旦在协程作用域内，代码就按顺序执行*，除非另有说明。**

**如果我们使用*异步:***

**我们现在只有一个暂停点——当我们返回最终值时。**

> **我们现在有了一个协同程序范围内的代码的 ***并发*** 执行。**

## **关于例外和取消的说明**

**当谈到`launch` vs `async` *，*时，每一个都以不同的方式处理异常。**

**`launch`总是立即抛出异常，而在`async`中触发的异常直到你调用`await()` *才会抛出。*如果你不小心的话，在使用`async` *的时候，你可能最终会悄悄地抛出异常。***

**正确处理帖子中的异常，所以我们现在不会深入讨论。**

**鉴于这篇文章已经太长了，我们将简单地讨论一下取消协程时最重要的部分:**

*   **一旦协程的作用域被取消，它也将被取消。除非你使用现成的示波器(像 Android 的`viewModelScope`)，否则你负责调用`cancel`**
*   **如果父协程被取消，协程层次结构中的任何子协程都将被取消。**
*   **如果您想在一个子进程失败时避开父进程的取消，请使用`SupervisorJob`。**

***了解更多信息***

**对于异常处理，[文档](https://kotlinlang.org/docs/reference/coroutines/exception-handling.html)给出了很好的解释，你也可以通过教程查看 Kotlin [协程的第 8 章。](https://www.goodreads.com/book/show/50033186-kotlin-coroutines-by-tutorials-first-edition)**

**关于协程取消，请参考同一本书的第 9 章，您也可以在此处查看文章[、](https://medium.com/androiddevelopers/cancellation-in-coroutines-aa6b90163629)以及文档中的资源。**

# **切换上下文，或者如何从 UI 跳到 IO，然后再跳回来**

**还记得我们说过的马戏团老板吗？**

**说到上下文切换，可以说协程上下文中最重要的元素是调度程序。**

**调度程序负责你的协程在哪里执行。决定协程如何耗尽可用资源、在哪个线程池的哪个线程上执行的是调度程序。**

**因此，如果协程上下文是我们马戏团团长的身体，那么调度员实际上就是大脑。**

**![](img/aabd877c8bccc45fdca60baf40a5d753.png)**

**有趣的事实:克里斯汀·米歇尔·威尔逊是林林兄弟马戏团 146 年历史上的第一位女领班！**

**有两种主要类型的调度程序:受限的和非受限的。前者总是依赖于预定义的系统上下文，而后者则不依赖。**

*   **受限调度程序包括:主调度程序、io 调度程序和默认调度程序**
*   **未限制的调度程序为:未限制**

**这里有一些关于他们的小东西:**

## **调度员。主要的**

*   **意味着在 UI 线程上工作**
*   **非常简单的操作**

## **调度员。超正析象管(Image Orthicon)**

*   **处理输入/输出**
*   **磁盘、数据库、网络操作等等**
*   **绑定到 JVM →不能在 Kotlin/JS 或 Kotlin/Native 项目上使用它**

## **调度员。默认**

*   **每当您不指定调度程序时使用**
*   **推荐用于 CPU 密集型操作(排序列表，Android 的 DiffUtil 等。)**
*   **由工作线程支持；它的任务数量等于系统的内核数量(至少 2 个)**

## **调度员。自由的**

*   **为协程创建新线程或在当前线程中工作；大多数情况下，它会在当时使用它的线程上运行**
*   **不可预知的**

**现在让我们开始切换！**

**![](img/0c825e8e2decc40aa5ef99cc83a19400.png)**

**不可思议的 Melrosas 是我们希望在协程中执行的代码的替身**

**我们将使用出色的 Melrosas 作为我们希望在协程范围内执行的代码的替身。**

**我们已经创建了在 UI 线程上执行的作用域，`circusTent` *，*——这代表了公众可以看到的一切。但是梅尔罗萨一家需要在上台前做好准备。**

**这是一项费力的任务，需要花费太多的时间，而且无论如何，没有人真的想看到梅尔罗萨在彼此之间斗嘴，就像他们在每次表演之前所做的那样——有人的服装总是被撕破，有人的化妆品总是不见了，也许有人仍然对在木星的那段时间感到愤怒，当时某个人不得不开了一个伤人的玩笑。**

**为了让所有这些远离观众，马戏团团长命令梅尔罗萨夫妇在后台做准备。**

> **如果我们想要执行繁重的操作(例如，从 API 获取数据)，然后在 UI 线程上显示它，同时防止 UI 冻结，这也是我们需要做的。**

**这就是为什么我们上下文切换，就像这样:**

**记住，*作用域内的一切都是顺序发生的。*在上面的例子中，我们有一个暂停点——当梅尔罗萨准备他们的高空钢丝表演时。**

**[*with context*](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-context.html)*是一个暂停调用，所以在它完成之前不会移动到下一行。与常规的`launch`不同，就像`async`一样，它也可以返回一个计算值。***

***如果梅尔罗萨斯在登台前需要完成多项任务，我们决定多次使用`withContext`，代码将按顺序执行*，*可能会降低速度和效率。***

***如果我们想让 Melrosas 并发执行所有准备任务，我们需要使用`async`，就像这样:***

***我们可以使用`async`告诉梅尔罗萨斯在准备好高空钢丝的同时*准备好自己，而不是等待高空钢丝准备好(暂停代码)，然后再次等待梅尔罗萨斯穿上服装(另一个暂停点)。****

> ***切换上下文时使用`async`使我们在作用域内只有一个暂停点，而不是多个。***

***你的协程初级读本就差不多了！***

***当谈到协程时，有太多很酷的东西需要发现，但是这篇文章应该在您开始自己的探索之前为您提供一些基础知识。***

*****这个术语表哪里出错了*****

***这个术语表主要是对 Kotlin 的协程的简化，如果您打算使用它们，它会向您提供最基本的知识。如果有帮助就鼓掌吧！***

***然而，如果你注意到这篇文章中的一些信息是错误的，请在评论中告诉我。我一定会相应地更新帖子:)***

## ***来源:***

***1.疯狂的谷歌搜索。[kot Lin Coroutines by Tutorials](https://www.goodreads.com/book/show/50033186-kotlin-coroutines-by-tutorials-first-edition)，这是我极力推荐的一本书，也是我能够写出这整本书的原因
3。[科特林文件](https://kotlinlang.org/docs/reference/coroutines/coroutines-guide.html)***

## ***关于马戏团的一个注记***

***如果你对马戏团感兴趣，我可以推荐:***

***1.乔·尼克尔的《杂耍的秘密》2。多米尼克·简多和诺埃尔·丹尼尔创作的 19 世纪 70 年代至 1950 年的马戏团。罗伯特·波格丹一世的《畸形秀:展示人类的古怪行为以获取娱乐和利润》***