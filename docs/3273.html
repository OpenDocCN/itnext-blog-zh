<html>
<head>
<title>Build FFmpeg WebAssembly version (= ffmpeg.wasm): Part.5 ffmpeg.wasm v0.3 — pre-js and live streaming (OUTDATED)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建FFmpeg WebAssembly版本(= FFmpeg . wasm):part . 5 FFmpeg . wasm v 0.3—js之前和直播(已过时)</h1>
<blockquote>原文：<a href="https://itnext.io/build-ffmpeg-webassembly-version-ffmpeg-js-part-5-ffmpeg-js-v0-3-pre-js-and-live-streaming-c1498939a74c?source=collection_archive---------4-----------------------#2019-11-10">https://itnext.io/build-ffmpeg-webassembly-version-ffmpeg-js-part-5-ffmpeg-js-v0-3-pre-js-and-live-streaming-c1498939a74c?source=collection_archive---------4-----------------------#2019-11-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div class="gh gi jq"><img src="../Images/8c0c378d4f8e771bf56ebf20e4685f63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*bJYwDAe6Hj59mpHZr46olQ.png"/></div></figure><p id="616f" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">以前的故事:<a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/build-ffmpeg-webassembly-version-ffmpeg-js-part-4-ffmpeg-js-v0-2-web-worker-and-libx264-d0596f1beb4e">构建FFmpeg WebAssembly版本(= FFmpeg . js):part . 4 FFmpeg . js v 0.2—Web Worker和Libx264 </a></p><p id="e1a2" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在这一部分，您将学习:</p><ol class=""><li id="2007" class="kw kx it jz b ka kb ke kf ki ky km kz kq la ku lb lc ld le bi translated">使用<code class="fe lf lg lh li b">--pre-js</code>重新定义模块中的功能</li><li id="1c99" class="kw kx it jz b ka lj ke lk ki ll km lm kq ln ku lb lc ld le bi translated">使用带网络摄像头的<code class="fe lf lg lh li b">ffmpeg.js</code></li></ol></div><div class="ab cl lo lp hx lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="im in io ip iq"><h1 id="92e1" class="lv lw it bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">使用<code class="fe lf lg lh li b">--pre-js</code>重新定义模块中的功能</h1><p id="3839" class="pw-post-body-paragraph jx jy it jz b ka mt kc kd ke mu kg kh ki mv kk kl km mw ko kp kq mx ks kt ku im bi translated">FFmpeg有大量的输出，它包含了重要的信息，比如视频的元数据，编码器/解码器的输出和任务的进度。默认情况下，这些信息是从原生C库<code class="fe lf lg lh li b">printf</code> / <code class="fe lf lg lh li b">sprintf</code>中打印出来的，虽然你可以在DevTools中看到，但不能用JavaScript操作。</p><p id="d194" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">幸运的是，在Emscripten中，我们可以用<code class="fe lf lg lh li b">--pre-js</code>或<code class="fe lf lg lh li b">--post-js</code>重新定义<a class="ae kv" href="https://emscripten.org/docs/api_reference/module.html" rel="noopener ugc nofollow" target="_blank">的一些默认函数</a>的行为。对于上面的场景，我们需要重新定义的函数是<code class="fe lf lg lh li b">Module['printErr']</code>(因为FFmpeg的输出使用了<code class="fe lf lg lh li b">stderr</code>)并用<code class="fe lf lg lh li b">--pre-js</code>添加到我们的ffmpeg.js中。</p><p id="a429" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">以下是我学到一些经验，供你参考:</p><ul class=""><li id="c857" class="kw kx it jz b ka kb ke kf ki ky km kz kq la ku my lc ld le bi translated">在<code class="fe lf lg lh li b">--pre-js</code>中只能使用ES5语法(无箭头函数，const，let)</li><li id="4cc8" class="kw kx it jz b ka lj ke lk ki ll km lm kq ln ku my lc ld le bi translated">您需要添加额外的宏来防止您的代码被闭包编译器移除(这里我不使用闭包编译器)</li></ul><p id="24da" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">下面是ffmpeg.js中使用的电流<code class="fe lf lg lh li b">prepend.js</code>:</p><figure class="mz na nb nc gt ju"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="03a1" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们实际上定义了一个新的函数<code class="fe lf lg lh li b">setLogger</code>来注册我们的自定义记录器函数，并重新定义了两个现有的函数<code class="fe lf lg lh li b">print</code>和<code class="fe lf lg lh li b">printErr</code>。有了这个prepend.js，现在我们可以轻松地操作FFmpeg的输出消息，并开发更多的功能(如进度条)。</p><p id="5ffd" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在构建脚本中添加<code class="fe lf lg lh li b">--pre-js</code>很简单(第54行):</p><figure class="mz na nb nc gt ju"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="20fe" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">现在我们在模块对象中有了<code class="fe lf lg lh li b">setLogger</code>，我们可以在初始化后使用它(第13行):</p><figure class="mz na nb nc gt ju"><div class="bz fp l di"><div class="nd ne l"/></div></figure><h1 id="6943" class="lv lw it bd lx ly nf ma mb mc ng me mf mg nh mi mj mk ni mm mn mo nj mq mr ms bi translated">使用带网络摄像头的<code class="fe lf lg lh li b">ffmpeg.js</code></h1><p id="86e9" class="pw-post-body-paragraph jx jy it jz b ka mt kc kd ke mu kg kh ki mv kk kl km mw ko kp kq mx ks kt ku im bi translated">在这里，我想描述如何使用ffmpeg与直播流，这里我们使用网络摄像头为例，但大多数情况下应该有类似的工作流程。</p><p id="b815" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">基本工作流程是:</p><ol class=""><li id="ba0b" class="kw kx it jz b ka kb ke kf ki ky km kz kq la ku lb lc ld le bi translated">使用MediaRecorder API将流保存到Blob</li><li id="cdf4" class="kw kx it jz b ka lj ke lk ki ll km lm kq ln ku lb lc ld le bi translated">将Blob转换为Uint8Array数据</li><li id="99e5" class="kw kx it jz b ka lj ke lk ki ll km lm kq ln ku lb lc ld le bi translated">使用ffmpeg.js对Uint8Array数据进行代码转换</li></ol><p id="e05c" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">步骤1 .使用<code class="fe lf lg lh li b">getUserMedia</code>访问网络摄像头(需要https协议)</p><pre class="mz na nb nc gt nk li nl nm aw nn bi"><span id="fb72" class="no lw it li b gy np nq l nr ns">&lt;video id="webcam" width="320px" height="180px"&gt;&lt;/video&gt;<br/>&lt;script&gt;<br/>const webcam = document.getElementById('webcam');<br/>(async () =&gt; {<br/>  webcam.srcObject = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });<br/>  await webcam.play();<br/>})();<br/>&lt;/script&gt;</span></pre><p id="e1bd" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">步骤2使用<code class="fe lf lg lh li b">MediaRecorder</code>记录组块</p><pre class="mz na nb nc gt nk li nl nm aw nn bi"><span id="9896" class="no lw it li b gy np nq l nr ns">const startRecording = () =&gt; {<br/>  const rec = new MediaRecorder(webcam.srcObject);<br/>  const chunks = [];<br/>  rec.ondataavailable = e =&gt; chunks.push(e.data);<br/>  rec.onstop = async () =&gt; {<br/>    transcode(new Uint8Array(await (new Blob(chunks)).arrayBuffer()));<br/>  };<br/>  rec.start();<br/>};</span></pre><p id="797f" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">步骤3:重复使用前一部分中的代码转换进行代码转换。</p><p id="8e7a" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">查看下面的CodePen以获得完整代码和现场演示:</p><figure class="mz na nb nc gt ju"><div class="bz fp l di"><div class="nt ne l"/></div></figure><p id="fd76" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在第5部分中，我们已经学习了如何使用<code class="fe lf lg lh li b">--pre-js</code>来重新定义/扩展模块的功能，并介绍了一个如何在直播场景中使用ffmpeg的例子。</p><p id="9f24" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">对于第6部分，我们将深入研究文件系统:<a class="ae kv" href="https://medium.com/@jeromewus/build-ffmpeg-webassembly-version-ffmpeg-js-part-6-a-deep-dive-into-file-system-56eba10067ca" rel="noopener">构建FFmpeg WebAssembly版本(= ffmpeg.js):第6部分深入研究文件系统</a></p><p id="cfdd" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">存储库:</p><ul class=""><li id="e432" class="kw kx it jz b ka kb ke kf ki ky km kz kq la ku my lc ld le bi translated">ffmpeg-core . js:<a class="ae kv" href="https://github.com/ffmpegjs/FFmpeg" rel="noopener ugc nofollow" target="_blank">https://github.com/ffmpegjs/FFmpeg</a></li><li id="7dc2" class="kw kx it jz b ka lj ke lk ki ll km lm kq ln ku my lc ld le bi translated">ffmpeg . js:<a class="ae kv" href="https://github.com/ffmpegjs/ffmpeg.js" rel="noopener ugc nofollow" target="_blank">https://github.com/ffmpegjs/ffmpeg.js</a></li></ul></div></div>    
</body>
</html>