<html>
<head>
<title>Web3: Managing Address Differences In Different Networks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Web3:管理不同网络中的地址差异</h1>
<blockquote>原文：<a href="https://itnext.io/web3-managing-address-differences-in-different-networks-d4f3cc0e1ae5?source=collection_archive---------3-----------------------#2022-01-17">https://itnext.io/web3-managing-address-differences-in-different-networks-d4f3cc0e1ae5?source=collection_archive---------3-----------------------#2022-01-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/53f5708c79a522c716934a6449df8bfa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8j7Ul-fIsGuPP2jW_iziHw.jpeg"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">寻找正确的地址有时会很棘手</figcaption></figure><ul class=""><li id="0e2c" class="jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">开发人员经常1)在本地，2)在测试网上，3)在主网上测试他们的代码</li><li id="4015" class="jy jz iq ka b kb kq kd kr kf ks kh kt kj ku kl km kn ko kp bi translated">智能合同的地址在每个网络上通常是不同的</li><li id="f4dc" class="jy jz iq ka b kb kq kd kr kf ks kh kt kj ku kl km kn ko kp bi translated">管理和切换这些地址有时会很麻烦和混乱</li></ul><p id="bbb0" class="pw-post-body-paragraph kv kw iq ka b kb kc kx ky kd ke kz la kf lb lc ld kh le lf lg kj lh li lj kl ij bi translated">在开发智能合同或dApp时，您可能会在不同的网络上进行测试，为部署到MainNet做准备。一个典型的周期可能包括测试</p><ol class=""><li id="3c59" class="jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl lk kn ko kp bi translated">在本地</li><li id="5ecf" class="jy jz iq ka b kb kq kd kr kf ks kh kt kj ku kl lk kn ko kp bi translated">在测试网上</li><li id="e0e7" class="jy jz iq ka b kb kq kd kr kf ks kh kt kj ku kl lk kn ko kp bi translated">在主网上</li></ol><p id="5676" class="pw-post-body-paragraph kv kw iq ka b kb kc kx ky kd ke kz la kf lb lc ld kh le lf lg kj lh li lj kl ij bi translated">如果您的协定与其他智能协定交互，则您可能需要根据您所在的网络来更改代码中引用的地址。</p><p id="73ea" class="pw-post-body-paragraph kv kw iq ka b kb kc kx ky kd ke kz la kf lb lc ld kh le lf lg kj lh li lj kl ij bi translated">比如说…</p><ul class=""><li id="0fb4" class="jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">如果您的合同与UniSwap或PancakeSwap之类的交换进行交互，您可能需要使用不同的地址，这取决于您是从TestNet还是MainNet进行测试。</li><li id="8364" class="jy jz iq ka b kb kq kd kr kf ks kh kt kj ku kl km kn ko kp bi translated">也许你正在建造一个带有ERC20令牌的NFT。本地部署和部署到真实网络时，令牌的地址会有所不同。</li></ul><p id="d347" class="pw-post-body-paragraph kv kw iq ka b kb kc kx ky kd ke kz la kf lb lc ld kh le lf lg kj lh li lj kl ij bi translated">本文就如何简化代码库中这些不同地址的管理提供了一些提示和建议。我们将关注Solidity中的智能契约开发和JavaScript中的单元测试/dApp开发。</p><h1 id="cf4e" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">不要硬编码地址；将它们传递给构造函数</h1><p id="02ba" class="pw-post-body-paragraph kv kw iq ka b kb mj kx ky kd mk kz la kf ml lc ld kh mm lf lg kj mn li lj kl ij bi translated">尽可能避免硬编码地址。当开发一个与另一个智能合约交互的智能合约时(假设是一个ERC20令牌)，您的第一个想法可能是，“<em class="mo">这个令牌已经部署在MainNet上，所以我将把地址设置为</em> <code class="fe mp mq mr ms b"><em class="mo">constant</em></code> <em class="mo">，以稍微简化我的代码。”</em></p><p id="cf88" class="pw-post-body-paragraph kv kw iq ka b kb kc kx ky kd ke kz la kf lb lc ld kh le lf lg kj lh li lj kl ij bi translated">然而，您确实<strong class="ka ir"> <em class="mo">而不是</em> </strong>想要这样做，因为您将设置您的代码在MainNet之外的任何地方都不工作。</p><p id="d80e" class="pw-post-body-paragraph kv kw iq ka b kb kc kx ky kd ke kz la kf lb lc ld kh le lf lg kj lh li lj kl ij bi translated">有时，开发人员会在测试时进入他们的智能合约代码并注释/取消注释地址，这取决于他们测试的网络。</p><pre class="mt mu mv mw gt mx ms my mz aw na bi"><span id="8ed0" class="nb lm iq ms b gy nc nd l ne nf">contract MyToken is ERC20 {<br/>   // TestNet<br/>   address public uniswapRouter = 0x…456; <br/>   address public devAddress = 0x…de2;   </span><span id="eac0" class="nb lm iq ms b gy ng nd l ne nf">   // MainNet<br/>   //address public uniswapRouter = 0x…789; <br/>   //address public devAddress = 0x…de3;<br/>   <br/>   constructor() ERC20(“MyToken”, “MTOK”) { }<br/>}</span></pre><p id="3f3e" class="pw-post-body-paragraph kv kw iq ka b kb kc kx ky kd ke kz la kf lb lc ld kh le lf lg kj lh li lj kl ij bi translated">如果你养成了像这样修改代码的习惯，你就有可能忘记注释掉正确的代码，并在你的智能契约中引入一个bug。这种方法还有其他令人头疼的问题，比如需要重新编译代码，每次都必须进入文件，滚动到正确的位置并更改代码。</p><p id="ff94" class="pw-post-body-paragraph kv kw iq ka b kb kc kx ky kd ke kz la kf lb lc ld kh le lf lg kj lh li lj kl ij bi translated">相反，通过构造函数将您需要的所有地址传递到智能协定中。这将允许您将代码部署到本地计算机或TestNet，并设置您需要使用的地址，而无需更改您的智能协定代码。</p><pre class="mt mu mv mw gt mx ms my mz aw na bi"><span id="a54a" class="nb lm iq ms b gy nc nd l ne nf">contract MyToken is ERC20 {<br/>   address public uniswapRouter;<br/>   address public devAddress;</span><span id="44e6" class="nb lm iq ms b gy ng nd l ne nf">   constructor(address _uniswapRouter, address _devAddress) <br/>        ERC20(“MyToken”, “MTOK”) {<br/>      uniswapRouter = _uniswapRouter;<br/>      devAddress = _devAddress; <br/>   }<br/>}</span></pre><h1 id="8ef9" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">如果您必须硬编码地址，请提供一种方法来更改它们</h1><p id="a137" class="pw-post-body-paragraph kv kw iq ka b kb mj kx ky kd mk kz la kf ml lc ld kh mm lf lg kj mn li lj kl ij bi translated">如果您已经决定必须对地址进行硬编码，请尝试提供一个函数来允许以编程方式更改它们。这样，当您在本地或TestNet上进行测试时，您可以调用该函数来适当地更新地址。</p><p id="d71d" class="pw-post-body-paragraph kv kw iq ka b kb kc kx ky kd ke kz la kf lb lc ld kh le lf lg kj lh li lj kl ij bi translated">如果选择这种方法，一定要对函数应用适当的安全性，比如只允许契约的所有者调用它。</p><pre class="mt mu mv mw gt mx ms my mz aw na bi"><span id="0c17" class="nb lm iq ms b gy nc nd l ne nf">function setUniswapRouter(address _uniswapRouter) external onlyOwner {<br/>   uniswapRouter = _uniswapRouter;<br/>}</span><span id="cf6b" class="nb lm iq ms b gy ng nd l ne nf">function setDevAddress(address _devAddress) external onlyOwner <br/>{<br/>   devAddress = _devAddress;<br/>}</span></pre><h1 id="1237" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">将地址存储在配置文件中</h1><p id="bf27" class="pw-post-body-paragraph kv kw iq ka b kb mj kx ky kd mk kz la kf ml lc ld kh mm lf lg kj mn li lj kl ij bi translated">地址实际上是配置数据，因此它们属于配置文件。</p><p id="0f11" class="pw-post-body-paragraph kv kw iq ka b kb kc kx ky kd ke kz la kf lb lc ld kh le lf lg kj lh li lj kl ij bi translated">如果您使用Hardhat/JavaScript来执行单元测试或部署您的智能契约，那么一个<code class="fe mp mq mr ms b">.json</code>文件是存储地址的一个好选择。您可以这样格式化它:</p><pre class="mt mu mv mw gt mx ms my mz aw na bi"><span id="dfd1" class="nb lm iq ms b gy nc nd l ne nf">module.exports = {<br/>   “LOCAL”: {<br/>      uniswapRouter: “0x…123”,<br/>      devAddress: “0x…de1”<br/>   },   </span><span id="fe86" class="nb lm iq ms b gy ng nd l ne nf">   “TEST”: {<br/>      uniswapRouter: “0x…456”,<br/>      devAddress: “0x…de2”<br/>   },</span><span id="0542" class="nb lm iq ms b gy ng nd l ne nf">   “MAIN”: {<br/>      uniswapRouter: “0x…789”,<br/>      devAddress: “0x…de3”<br/>   }<br/>}</span></pre><p id="142c" class="pw-post-body-paragraph kv kw iq ka b kb kc kx ky kd ke kz la kf lb lc ld kh le lf lg kj lh li lj kl ij bi translated">然后，在部署您的智能合同时，您可能会执行以下操作:</p><pre class="mt mu mv mw gt mx ms my mz aw na bi"><span id="b8f6" class="nb lm iq ms b gy nc nd l ne nf">const NETWORK = "LOCAL";<br/>const uniswapRouter = require("./config")[NETWORK].uniswapRouter;<br/>const devAddress = require("./config")[NETWORK].devAddress;<br/>//<br/>// ...<br/>//<br/>const myToken = await MyToken.deploy(uniswapRouter, devAddress);</span></pre><p id="f09b" class="pw-post-body-paragraph kv kw iq ka b kb kc kx ky kd ke kz la kf lb lc ld kh le lf lg kj lh li lj kl ij bi translated">现在你需要做的就是切换顶部的<code class="fe mp mq mr ms b">NETWORK</code>常量来使用指定网络中的地址。您也可以设置您的代码接受命令行参数，类似于Hardhat接受参数的方式。</p><p id="3fdd" class="pw-post-body-paragraph kv kw iq ka b kb kc kx ky kd ke kz la kf lb lc ld kh le lf lg kj lh li lj kl ij bi translated">如果您有dApp，您可以使用相同的技术在测试期间轻松地在网络之间切换。</p><p id="c103" class="pw-post-body-paragraph kv kw iq ka b kb kc kx ky kd ke kz la kf lb lc ld kh le lf lg kj lh li lj kl ij bi translated">通过修改上面的<code class="fe mp mq mr ms b">NETWORK</code>常数，你仍然在改变代码。然而，这种方法与在智能契约或dApp代码中更改代码有几个重要的区别。</p><p id="f3ab" class="pw-post-body-paragraph kv kw iq ka b kb kc kx ky kd ke kz la kf lb lc ld kh le lf lg kj lh li lj kl ij bi translated">1.您没有修改<em class="mo">生产代码</em>。与修改部署后无法更改的智能联系人相比，修改帮助您运行单元测试的脚本的风险要小得多。</p><p id="9eea" class="pw-post-body-paragraph kv kw iq ka b kb kc kx ky kd ke kz la kf lb lc ld kh le lf lg kj lh li lj kl ij bi translated">2.您正在一个更常见的地方进行更改。或者，至少比在代码文件中间更常见，可能有数百行代码深。</p><p id="517e" class="pw-post-body-paragraph kv kw iq ka b kb kc kx ky kd ke kz la kf lb lc ld kh le lf lg kj lh li lj kl ij bi translated">3.您正在进行<em class="mo">一项</em>更改(在“本地”、“测试”、“主”等之间切换。).而不是对每个地址进行单独的修改(在我们的例子中，1)注释掉<code class="fe mp mq mr ms b">uniswapRouter</code>和2)注释掉<code class="fe mp mq mr ms b">devAddress</code>。</p><h1 id="60b6" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">结论</h1><p id="0fef" class="pw-post-body-paragraph kv kw iq ka b kb mj kx ky kd mk kz la kf ml lc ld kh mm lf lg kj mn li lj kl ij bi translated">尽可能避免硬编码地址。虽然一旦部署了智能契约，它的地址就永远不会改变，因此是“常数”，但它不是常数，就像<code class="fe mp mq mr ms b">PI</code>是常数一样；该地址仅在特定网络范围内保持不变。</p><p id="e5c6" class="pw-post-body-paragraph kv kw iq ka b kb kc kx ky kd ke kz la kf lb lc ld kh le lf lg kj lh li lj kl ij bi translated">通过将地址设置为可配置的，使您的代码更容易使用，更重要的是，更容易测试。</p><p id="0f76" class="pw-post-body-paragraph kv kw iq ka b kb kc kx ky kd ke kz la kf lb lc ld kh le lf lg kj lh li lj kl ij bi">__</p><p id="5965" class="pw-post-body-paragraph kv kw iq ka b kb kc kx ky kd ke kz la kf lb lc ld kh le lf lg kj lh li lj kl ij bi translated">如果你需要开发下一个Web3应用程序的帮助，请查看10x development(<a class="ae nh" href="https://10xdevelopment.com/" rel="noopener ugc nofollow" target="_blank">https://10xdevelopment.com/</a>)。</p></div></div>    
</body>
</html>