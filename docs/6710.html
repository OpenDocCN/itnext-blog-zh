<html>
<head>
<title>Building Micronaut applications with Micronaut Mongo Reative</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Micronaut Mongo Reative构建Micronaut应用程序</h1>
<blockquote>原文：<a href="https://itnext.io/building-micronaut-applications-with-micronaut-mongo-reative-9c418b403bc1?source=collection_archive---------3-----------------------#2022-02-05">https://itnext.io/building-micronaut-applications-with-micronaut-mongo-reative-9c418b403bc1?source=collection_archive---------3-----------------------#2022-02-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="50f2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本帖中，我们将探讨Micronaut Mongo的反应特性。与数据JPA和R2dbc不同，Mongo Reactive特性不是Micronaut数据项目的一部分。Micronaut Mongo Reactive是官方Mongo Java驱动程序的一个轻量级包装器，提供从应用程序属性自动配置<code class="fe kl km kn ko b">MongoClient</code>。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi kp"><img src="../Images/1448c5af1e79724399f97ac0b484465c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HcHUQFoIAU88lHg24zJINA.jpeg"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">由<a class="ae lf" href="https://unsplash.com/@fabianmardi?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Fabian Mardi </a>在<a class="ae lf" href="https://unsplash.com/s/photos/snow?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="5a35" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">入门指南</h1><p id="1f02" class="pw-post-body-paragraph jn jo iq jp b jq me js jt ju mf jw jx jy mg ka kb kc mh ke kf kg mi ki kj kk ij bi translated">打开浏览器，导航到<a class="ae lf" href="https://micronaut.io/launch" rel="noopener ugc nofollow" target="_blank"> Micronaut Launch </a>为这篇文章生成一个新的项目框架。在此页面上选择以下项目。</p><ul class=""><li id="de0f" class="mj mk iq jp b jq jr ju jv jy ml kc mm kg mn kk mo mp mq mr bi translated">Java版本:<strong class="jp ir"> 17 </strong></li><li id="b13e" class="mj mk iq jp b jq ms ju mt jy mu kc mv kg mw kk mo mp mq mr bi translated">语言:<strong class="jp ir"> Java </strong></li><li id="6b02" class="mj mk iq jp b jq ms ju mt jy mu kc mv kg mw kk mo mp mq mr bi translated">构建工具:<strong class="jp ir"> Gradle </strong></li><li id="efbf" class="mj mk iq jp b jq ms ju mt jy mu kc mv kg mw kk mo mp mq mr bi translated">测试框架:<strong class="jp ir">斯波克</strong></li><li id="1f36" class="mj mk iq jp b jq ms ju mt jy mu kc mv kg mw kk mo mp mq mr bi translated">包含特性:<strong class="jp ir">蒙哥反应</strong>等。</li></ul><p id="1425" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">点击<strong class="jp ir">生成项目</strong>按钮，生成一个项目档案，下载后解压到磁盘，导入到你的IDE，比如IDEA。</p><p id="6631" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在前面的例子中，我们使用JUnit和Kotest作为测试框架，在这个例子中，我们改用Spock和Groovy来编写测试。</p><p id="0008" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">创建一个Mongo文档实体类。</p><pre class="kq kr ks kt gt mx ko my mz aw na bi"><span id="64e5" class="nb lh iq ko b gy nc nd l ne nf">@Data<br/>@Builder<br/>@NoArgsConstructor<br/>@AllArgsConstructor(staticName = "of")<br/>public class Customer {<br/>    private ObjectId id;<br/>    private String name;<br/>    private int age;<br/>    private Address address;</span><span id="1d86" class="nb lh iq ko b gy ng nd l ne nf">    public static Customer of(String name, int age, Address address) {<br/>        return Customer.of(null, name, age, address);<br/>    }<br/>}</span></pre><p id="eb1e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe kl km kn ko b">Address</code>是一个嵌入在<code class="fe kl km kn ko b">Customer</code>文档中的文档。</p><pre class="kq kr ks kt gt mx ko my mz aw na bi"><span id="67a7" class="nb lh iq ko b gy nc nd l ne nf">@Data<br/>@Builder<br/>@NoArgsConstructor<br/>@AllArgsConstructor(staticName = "of")<br/>public class Address {<br/>    private String street;<br/>    private String city;<br/>    private String zip;<br/>}</span></pre><p id="1804" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">创建一个<code class="fe kl km kn ko b">Repository</code>类来对<code class="fe kl km kn ko b">Customer</code>执行CRUD操作。</p><pre class="kq kr ks kt gt mx ko my mz aw na bi"><span id="0477" class="nb lh iq ko b gy nc nd l ne nf">@Singleton<br/>@RequiredArgsConstructor<br/>@Slf4j<br/>public class CustomerRepository {<br/>    private final MongoClient mongoClient;<br/>    private final DefaultMongoConfiguration mongoConfiguration;</span><span id="27a0" class="nb lh iq ko b gy ng nd l ne nf">    public Flux&lt;Customer&gt; findAll() {<br/>        return Flux.from(customersCollection().find());<br/>    }</span><span id="0cb8" class="nb lh iq ko b gy ng nd l ne nf">    public Mono&lt;Customer&gt; findById(ObjectId id) {<br/>        return Mono.from(customersCollection().find(Filters.eq(id)));<br/>    }</span><span id="9bbd" class="nb lh iq ko b gy ng nd l ne nf">    public Mono&lt;ObjectId&gt; insertOne(Customer data) {<br/>        return Mono.from(customersCollection().insertOne(data, new InsertOneOptions().bypassDocumentValidation(false)))<br/>                .mapNotNull(result -&gt; result.getInsertedId().asObjectId().getValue());<br/>    }</span><span id="97e0" class="nb lh iq ko b gy ng nd l ne nf">    public Mono&lt;Map&lt;Integer, BsonValue&gt;&gt; insertMany(List&lt;Customer&gt; data) {<br/>        return Mono.from(customersCollection().insertMany(data, new InsertManyOptions().bypassDocumentValidation(false).ordered(true)))<br/>                .map(InsertManyResult::getInsertedIds);<br/>    }</span><span id="f13a" class="nb lh iq ko b gy ng nd l ne nf">    public Mono&lt;Long&gt; deleteById(ObjectId id) {<br/>        return Mono.from(customersCollection().deleteOne(Filters.eq(id), new DeleteOptions()))<br/>                .map(DeleteResult::getDeletedCount);<br/>    }</span><span id="3627" class="nb lh iq ko b gy ng nd l ne nf">    public void init() {<br/>        var people = List.of(<br/>                Customer.of("Charles Babbage", 45, Address.of("5 Devonshire Street", "London", "W11")),<br/>                Customer.of("Alan Turing", 28, Address.of("Bletchley Hall", "Bletchley Park", "MK12")),<br/>                Customer.of("Timothy Berners-Lee", 61, Address.of("Colehill", "Wimborne", null))<br/>        );<br/>        Mono.from(customersCollection().drop())<br/>                .then()<br/>                .thenMany(this.insertMany(people))<br/>                .subscribe(<br/>                        result -&gt; result.forEach((key, value) -&gt; log.debug("saved key: {}, value: {}", key, value)),<br/>                        error -&gt; log.debug("initialization failed: {}", error),<br/>                        () -&gt; log.debug("done")<br/>                );<br/>    }</span><span id="cb3a" class="nb lh iq ko b gy ng nd l ne nf">    public Mono&lt;Long&gt; deleteAll() {<br/>        return Mono.from(customersCollection().deleteMany(Filters.empty(), new DeleteOptions()))<br/>                .map(DeleteResult::getDeletedCount);<br/>    }</span><span id="d442" class="nb lh iq ko b gy ng nd l ne nf">    private MongoCollection&lt;Customer&gt; customersCollection() {<br/>        return mongoClient<br/>                .getDatabase("userdb")<br/>                .getCollection("customers", Customer.class);<br/>    }</span><span id="9ac1" class="nb lh iq ko b gy ng nd l ne nf">}</span></pre><p id="bfa5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当<em class="nh"> application.yml </em>中设置了<code class="fe kl km kn ko b">mongo.uri</code>时，有一个<strong class="jp ir">反应</strong> <code class="fe kl km kn ko b">MongoClient</code> bean可用。</p><p id="337d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上面的代码中:</p><ul class=""><li id="7f5e" class="mj mk iq jp b jq jr ju jv jy ml kc mm kg mn kk mo mp mq mr bi translated"><code class="fe kl km kn ko b">customersCollection()</code>方法定义了一个映射到<code class="fe kl km kn ko b">Customer</code>类的Mongo集合。正如你所看到的，在<code class="fe kl km kn ko b">Customer</code>类中定义了一个<code class="fe kl km kn ko b">ObjectId</code> id字段，当保存一个客户实例时，它会为其生成一个新的ObjectId，并自动保存到MongoDB中的<em class="nh">客户</em>文档<code class="fe kl km kn ko b">_id</code>中。</li><li id="f566" class="mj mk iq jp b jq ms ju mt jy mu kc mv kg mw kk mo mp mq mr bi translated"><code class="fe kl km kn ko b">MongoClient</code>提供了CRUD操作的方法，但是它是基于<em class="nh">反应流</em>API的。这里我们在这个项目中使用反应器API，我们使用<code class="fe kl km kn ko b">Mono</code>和<code class="fe kl km kn ko b">Flux</code>将操作结果包装成反应器友好的API。</li></ul><p id="65b5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们创建一个测试来测试<code class="fe kl km kn ko b">CustomerRepository</code>。</p><pre class="kq kr ks kt gt mx ko my mz aw na bi"><span id="b724" class="nb lh iq ko b gy nc nd l ne nf">@MicronautTest(startApplication = false)<br/>@Slf4j<br/>class CustomerRepositorySpec extends Specification {</span><span id="b3de" class="nb lh iq ko b gy ng nd l ne nf">    @Inject<br/>    EmbeddedApplication&lt;?&gt; application</span><span id="6252" class="nb lh iq ko b gy ng nd l ne nf">    @Inject<br/>    CustomerRepository customerRepository;</span><span id="9595" class="nb lh iq ko b gy ng nd l ne nf">    def setup() {<br/>        CountDownLatch latch = new CountDownLatch(1)<br/>        customerRepository.deleteAll()<br/>                .doOnTerminate(_ -&gt; latch.countDown())<br/>                .subscribe(it -&gt; log.debug "deleted customers: {}", it)<br/>        latch.await(1000, TimeUnit.MILLISECONDS)<br/>    }</span><span id="f949" class="nb lh iq ko b gy ng nd l ne nf">    void 'application is not running'() {<br/>        expect:<br/>        !application.running<br/>    }</span><span id="cf11" class="nb lh iq ko b gy ng nd l ne nf">    void 'test findAll'() {<br/>        given:<br/>        this.customerRepository.insertMany(List.of(Customer.of("Jack", 40, null)))<br/>                .block(Duration.ofMillis(5000L))</span><span id="574f" class="nb lh iq ko b gy ng nd l ne nf">        when:<br/>        def result = this.customerRepository.findAll()</span><span id="1379" class="nb lh iq ko b gy ng nd l ne nf">        then:<br/>        StepVerifier.create(result)<br/>                .expectNextMatches(it -&gt; it.name == "Jack")<br/>                .expectComplete()<br/>                .verify()<br/>    }<br/>}</span></pre><p id="f441" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了测试持久层，我们不需要一个正在运行的服务器。所以将<code class="fe kl km kn ko b">startApplication = false</code>添加到<code class="fe kl km kn ko b">MicronautTest</code>注释中。</p><p id="770e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通常，Spock测试被称为<code class="fe kl km kn ko b">Specfication</code>，你可以在你的测试中覆盖生命周期方法，比如<code class="fe kl km kn ko b">setup</code>、<code class="fe kl km kn ko b">setupSpec</code>等。每个测试都遵循BDD模式，也就是<code class="fe kl km kn ko b">given</code> / <code class="fe kl km kn ko b">when</code> / <code class="fe kl km kn ko b">then </code>模式。</p><p id="c4c0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上面的代码中，我们覆盖了<code class="fe kl km kn ko b">setup</code>方法并清除了数据库中的数据。然后创建一个测试来验证插入和查找操作，在<code class="fe kl km kn ko b">then</code>块中，我们使用<code class="fe kl km kn ko b">StepVerify</code>来断言反应流中的结果。</p><p id="ecf2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您想要启动一个Testcontainers Docker来服务所需的Mongo数据库，请尝试使用<code class="fe kl km kn ko b">Shared</code>和<code class="fe kl km kn ko b">AutoCleanup</code>注释定义一个Mongo容器实例，并覆盖<code class="fe kl km kn ko b">setupSpec</code>来启动Mongo服务，并确保它可用于本规范中的所有测试。</p><pre class="kq kr ks kt gt mx ko my mz aw na bi"><span id="2245" class="nb lh iq ko b gy nc nd l ne nf">@Shared<br/>@AutoCleanup<br/>GenericContainer mongo = new GenericContainer("mongo")<br/>    .withExposedPorts(27017)</span><span id="5267" class="nb lh iq ko b gy ng nd l ne nf">def setupSpec() {        <br/>    mongo.start()<br/>}</span></pre><p id="ea8d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">像前面的例子一样，我们可以创建一个bean来监听一个<code class="fe kl km kn ko b">ServerStartupEvent</code>来初始化一些用于测试的样本数据。</p><pre class="kq kr ks kt gt mx ko my mz aw na bi"><span id="1965" class="nb lh iq ko b gy nc nd l ne nf">@Singleton<br/>@Requires(notEnv = "mock")<br/>@Slf4j<br/>@RequiredArgsConstructor<br/>public class DataInitializer {<br/>    private final CustomerRepository customerRepository;</span><span id="ac08" class="nb lh iq ko b gy ng nd l ne nf">    @EventListener<br/>    public void onStart(ServerStartupEvent event) {<br/>        log.debug("starting data initialization...");<br/>        this.customerRepository.init();<br/>    }<br/>}</span></pre><p id="fc22" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">尝试创建一个控制器来公开RESTful APIs。</p><pre class="kq kr ks kt gt mx ko my mz aw na bi"><span id="3d83" class="nb lh iq ko b gy nc nd l ne nf">@Controller("/customers")<br/>@RequiredArgsConstructor<br/>@Slf4j<br/>public class CustomerController {<br/>    private final CustomerRepository customerRepository;</span><span id="73d1" class="nb lh iq ko b gy ng nd l ne nf">    @Get(uri = "/", produces = {MediaType.APPLICATION_JSON})<br/>    public Flux&lt;?&gt; all() {<br/>        return this.customerRepository.findAll();<br/>    }</span><span id="f194" class="nb lh iq ko b gy ng nd l ne nf">    @Get(uri = "/{id}", produces = {MediaType.APPLICATION_JSON})<br/>    public Mono&lt;MutableHttpResponse&lt;Customer&gt;&gt; byId(@PathVariable ObjectId id) {<br/>        return this.customerRepository.findById(id)<br/>                .map(HttpResponse::ok)<br/>                .switchIfEmpty(Mono.just(notFound()));<br/>    }</span><span id="192d" class="nb lh iq ko b gy ng nd l ne nf">    @Post(uri = "/", consumes = {MediaType.APPLICATION_JSON})<br/>    public Mono&lt;HttpResponse&lt;?&gt;&gt; create(@Body Customer data) {<br/>        return this.customerRepository.insertOne(data)<br/>                .map(id -&gt; created(URI.create("/customers/" + id.toHexString())));<br/>    }</span><span id="6d8e" class="nb lh iq ko b gy ng nd l ne nf">    @Delete(uri = "/{id}")<br/>    public Mono&lt;HttpResponse&lt;?&gt;&gt; delete(@PathVariable ObjectId id) {<br/>        return this.customerRepository.deleteById(id)<br/>                .map(deleted -&gt; {<br/>                    if (deleted &gt; 0) {<br/>                        return noContent();<br/>                    } else {<br/>                        return notFound();<br/>                    }<br/>                });<br/>    }<br/>}</span></pre><p id="7369" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了处理请求路径中的<code class="fe kl km kn ko b">ObjectId</code>，创建一个<code class="fe kl km kn ko b">TypeConverter</code>来将id从字符串类型转换为<code class="fe kl km kn ko b">ObjectId</code>。</p><pre class="kq kr ks kt gt mx ko my mz aw na bi"><span id="40a4" class="nb lh iq ko b gy nc nd l ne nf">@Singleton<br/>public class StringToObjectIdConverter implements TypeConverter&lt;String, ObjectId&gt; {</span><span id="82f9" class="nb lh iq ko b gy ng nd l ne nf">    @Override<br/>    public Optional&lt;ObjectId&gt; convert(String object, Class&lt;ObjectId&gt; targetType, ConversionContext context) {<br/>        return Optional.of(new ObjectId(object));<br/>    }<br/>}</span></pre><p id="eace" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了在HTTP响应中将<code class="fe kl km kn ko b">Customer</code>的id ( <code class="fe kl km kn ko b">ObjectId</code>类型)序列化为字符串，创建一个<code class="fe kl km kn ko b">JsonSerializer</code>来定制序列化过程。应用时，id字段被序列化为十六进制字符串，而不是JSON对象。</p><pre class="kq kr ks kt gt mx ko my mz aw na bi"><span id="2fbe" class="nb lh iq ko b gy nc nd l ne nf">@Singleton<br/>public class ObjectIdJsonSerializer extends JsonSerializer&lt;ObjectId&gt; {<br/>    <br/>    @Override<br/>    public void serialize(ObjectId value, JsonGenerator gen, SerializerProvider serializers) throws IOException {<br/>        gen.writeString(value.toHexString());<br/>    }<br/>}</span></pre><p id="eff6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为<code class="fe kl km kn ko b">CustomerController</code>创建一个测试。</p><pre class="kq kr ks kt gt mx ko my mz aw na bi"><span id="b542" class="nb lh iq ko b gy nc nd l ne nf">@MicronautTest(environments = ["mock"])<br/>class CustomerControllerSpec extends Specification {</span><span id="5f40" class="nb lh iq ko b gy ng nd l ne nf">    @Inject<br/>    EmbeddedApplication&lt;?&gt; application</span><span id="f680" class="nb lh iq ko b gy ng nd l ne nf">    @Inject<br/>    @Client("/")<br/>    ReactorHttpClient client</span><span id="d909" class="nb lh iq ko b gy ng nd l ne nf">    @Inject<br/>    CustomerRepository customerRepository</span><span id="60d3" class="nb lh iq ko b gy ng nd l ne nf">    def 'test it works'() {<br/>        expect:<br/>        application.running<br/>    }</span><span id="2015" class="nb lh iq ko b gy ng nd l ne nf">    void 'get all customers'() {<br/>        given:<br/>        1 * customerRepository.findAll() &gt;&gt; Flux.just(Customer.of(ObjectId.get(), "Jack", 40, null), Customer.of(ObjectId.get(), "Rose", 20, null))</span><span id="dfdd" class="nb lh iq ko b gy ng nd l ne nf">        when:<br/>        Flux&lt;HttpResponse&lt;String&gt;&gt; resFlux = client.exchange(HttpRequest.GET("/customers"), String).log()</span><span id="01d0" class="nb lh iq ko b gy ng nd l ne nf">        then:<br/>        //1 * customers.findAll() &gt;&gt; Flux.just(Customer.of(ObjectId.get(), "Jack", 40, null), Customer.of(ObjectId.get(), "Rose", 20, null))<br/>        StepVerifier.create(resFlux)<br/>        //.expectNextCount(1)<br/>                .consumeNextWith(s -&gt; {<br/>                    assert s.getStatus() == HttpStatus.OK<br/>                    assert s.body().contains('Jack')<br/>                })<br/>                .expectComplete()<br/>                .verify()<br/>    }</span><span id="59a0" class="nb lh iq ko b gy ng nd l ne nf">    void 'create a new customer'() {<br/>        given:<br/>        def objId = ObjectId.get()<br/>        1 * customerRepository.insertOne(_) &gt;&gt; Mono.just(objId)</span><span id="0c08" class="nb lh iq ko b gy ng nd l ne nf">        when:<br/>        def body = Customer.of(null, "Jack", 40, null)<br/>        Flux&lt;HttpResponse&lt;String&gt;&gt; resFlux = client.exchange(HttpRequest.POST("/customers", body), String).log()</span><span id="45a0" class="nb lh iq ko b gy ng nd l ne nf">        then:<br/>        StepVerifier.create(resFlux)<br/>                .consumeNextWith(s -&gt; {<br/>                    assert s.getStatus() == HttpStatus.CREATED<br/>                    assert s.header("Location") == '/customers/' + objId.toHexString()<br/>                })<br/>                .expectComplete()<br/>                .verify()<br/>    }</span><span id="7da5" class="nb lh iq ko b gy ng nd l ne nf">    void 'get customer by id '() {<br/>        given:<br/>        1 * customerRepository.findById(_) &gt;&gt; Mono.just(Customer.of(ObjectId.get(), "Jack", 40, null))</span><span id="ebc7" class="nb lh iq ko b gy ng nd l ne nf">        when:<br/>        Flux&lt;HttpResponse&lt;String&gt;&gt; resFlux = client.exchange(HttpRequest.GET("/customers/" + ObjectId.get().toHexString()), String).log()</span><span id="02c0" class="nb lh iq ko b gy ng nd l ne nf">        then:<br/>        StepVerifier.create(resFlux)<br/>                .consumeNextWith(s -&gt; {<br/>                    assert s.getStatus() == HttpStatus.OK<br/>                    assert s.body().contains('Jack')<br/>                })<br/>                .expectComplete()<br/>                .verify()<br/>    }</span><span id="0b31" class="nb lh iq ko b gy ng nd l ne nf">    void 'get customer by none-existing id '() {<br/>        given:<br/>        1 * customerRepository.findById(_) &gt;&gt; Mono.empty()</span><span id="c841" class="nb lh iq ko b gy ng nd l ne nf">        when:<br/>        Flux&lt;HttpResponse&lt;String&gt;&gt; resFlux = client.exchange(HttpRequest.GET("/customers/" + ObjectId.get().toHexString()), String).log()</span><span id="6e93" class="nb lh iq ko b gy ng nd l ne nf">        then:<br/>        StepVerifier.create(resFlux)<br/>                .consumeErrorWith(error -&gt; {<br/>                    assert error instanceof HttpClientResponseException<br/>                    assert (error as HttpClientResponseException).status == HttpStatus.NOT_FOUND<br/>                })<br/>                .verify()<br/>    }</span><span id="8893" class="nb lh iq ko b gy ng nd l ne nf">    void 'delete customer by id '() {<br/>        given:<br/>        1 * customerRepository.deleteById(_) &gt;&gt; Mono.just(1L)</span><span id="de7c" class="nb lh iq ko b gy ng nd l ne nf">        when:<br/>        Flux&lt;HttpResponse&lt;String&gt;&gt; resFlux = client.exchange(HttpRequest.DELETE("/customers/" + ObjectId.get().toHexString()), String).log()</span><span id="4bc2" class="nb lh iq ko b gy ng nd l ne nf">        then:<br/>        StepVerifier.create(resFlux)<br/>                .consumeNextWith(s -&gt; {<br/>                    assert s.getStatus() == HttpStatus.NO_CONTENT<br/>                })<br/>                .expectComplete()<br/>                .verify()<br/>    }</span><span id="6b54" class="nb lh iq ko b gy ng nd l ne nf">    void 'delete customer by none-existing id '() {<br/>        given:<br/>        1 * customerRepository.deleteById(_) &gt;&gt; Mono.just(0L)</span><span id="5eda" class="nb lh iq ko b gy ng nd l ne nf">        when:<br/>        Flux&lt;HttpResponse&lt;String&gt;&gt; resFlux = client.exchange(HttpRequest.DELETE("/customers/" + ObjectId.get().toHexString()), String).log()</span><span id="4b7a" class="nb lh iq ko b gy ng nd l ne nf">        then:<br/>        StepVerifier.create(resFlux)<br/>                .consumeErrorWith(error -&gt; {<br/>                    assert error instanceof HttpClientResponseException<br/>                    assert (error as HttpClientResponseException).status == HttpStatus.NOT_FOUND<br/>                })<br/>                .verify()<br/>    }</span><span id="0f1e" class="nb lh iq ko b gy ng nd l ne nf">    @MockBean(CustomerRepository)<br/>    CustomerRepository mockedCustomerRepository() {// must use explicit type declaration<br/>        Mock(CustomerRepository)<br/>    }<br/>}</span></pre><p id="21ca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这个测试中，我们为<code class="fe kl km kn ko b">CustomerRepository</code>创建了一个模拟bean，注意你必须显式声明类型。注意，在<code class="fe kl km kn ko b">given</code>块中，与Mockito略有不同，它在一个地方设置了假设和断言。</p><p id="1549" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Mongo的另一个伟大特性是Gridfs支持。对于那些家庭使用的云应用程序，它是AWS S3存储服务的简单替代方案。</p><p id="a68b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们将创建一个简单的上传和下载端点，将二进制数据存储到Mongo Gridfs存储中，并从Gridfs存储中检索它。</p><p id="2b64" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先声明一个<code class="fe kl km kn ko b">GridFSBucket</code> bean。</p><pre class="kq kr ks kt gt mx ko my mz aw na bi"><span id="66f8" class="nb lh iq ko b gy nc nd l ne nf">@Factory<br/>public class GridFSConfig {</span><span id="4b69" class="nb lh iq ko b gy ng nd l ne nf">    @Bean<br/>    GridFSBucket gridFSBucket(MongoClient client) {<br/>        return GridFSBuckets.create(client.getDatabase("photos"))<br/>                .withChunkSizeBytes(4096)<br/>                //.withReadConcern(ReadConcern.MAJORITY)<br/>                .withWriteConcern(WriteConcern.MAJORITY);<br/>    }<br/>}</span></pre><p id="4f72" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在创建一个控制器来处理文件的上传和下载。</p><pre class="kq kr ks kt gt mx ko my mz aw na bi"><span id="3eab" class="nb lh iq ko b gy nc nd l ne nf">@Controller("/photos")<br/>@RequiredArgsConstructor<br/>@Slf4j<br/>public class PhotoController {</span><span id="7800" class="nb lh iq ko b gy ng nd l ne nf">    private final GridFSBucket bucket;</span><span id="fb7e" class="nb lh iq ko b gy ng nd l ne nf">    @Post(uri = "/", consumes = {MediaType.MULTIPART_FORM_DATA})<br/>    public Mono&lt;HttpResponse&lt;?&gt;&gt; upload(StreamingFileUpload file) {<br/>        var filename = file.getFilename();<br/>        var name = file.getName();<br/>        var contentType = file.getContentType();<br/>        var size = file.getSize();<br/>        log.debug("uploading file...\n filename:{},\n name:{},\n contentType: {},\n size: {} ", filename, name, contentType, size);<br/>        var options = new GridFSUploadOptions();<br/>        contentType.ifPresent(c -&gt; options.metadata(new Document("contentType", c)));<br/>        return Mono.from(this.bucket.uploadFromPublisher(<br/>                                filename,<br/>                                Mono.from(file).mapNotNull(partData -&gt; {<br/>                                    try {<br/>                                        return partData.getByteBuffer();<br/>                                    } catch (IOException e) {<br/>                                        e.printStackTrace();<br/>                                    }<br/>                                    return null;<br/>                                }),<br/>                                options<br/>                        )<br/>                )<br/>                .map(ObjectId::toHexString)<br/>                .map(id -&gt; ok(Map.of("id", id)));<br/>    }</span><span id="1987" class="nb lh iq ko b gy ng nd l ne nf">    @Get(uri = "/{id}", produces = {MediaType.APPLICATION_OCTET_STREAM})<br/>    public Mono&lt;HttpResponse&lt;?&gt;&gt; download(@PathVariable ObjectId id) {<br/>        return Mono.from(this.bucket.downloadToPublisher(id))<br/>                .map(HttpResponse::ok);<br/>    }</span><span id="e864" class="nb lh iq ko b gy ng nd l ne nf">    @Delete(uri = "/{id}")<br/>    public Mono&lt;HttpResponse&lt;?&gt;&gt; delete(@PathVariable ObjectId id) {<br/>        return Mono.from(this.bucket.delete(id))<br/>                .map(v -&gt; noContent());<br/>    }<br/>}</span></pre><p id="0742" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要上传文件，使用<code class="fe kl km kn ko b">bucket.uploadFromPublisher</code>将上传数据传输到Gridfs bucket中。要下载文件，调用<code class="fe kl km kn ko b">downloadToPublisher</code>将数据读入<code class="fe kl km kn ko b">ByteBuffer </code>并发送HTTP响应。要从存储桶中删除它，只需调用delete方法。</p><h2 id="6146" class="nb lh iq bd li ni nj dn lm nk nl dp lq jy nm nn lu kc no np ly kg nq nr mc ns bi translated">从我的Github获取完整的<a class="ae lf" href="https://github.com/hantsy/micronaut-sandbox/tree/master/album-service" rel="noopener ugc nofollow" target="_blank">源代码</a>。</h2></div></div>    
</body>
</html>