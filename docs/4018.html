<html>
<head>
<title>FlutterVita : Gunshots App</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">FlutterVita:枪声应用</h1>
<blockquote>原文：<a href="https://itnext.io/fluttervita-gunshots-app-f00e9235c3e3?source=collection_archive---------7-----------------------#2020-04-11">https://itnext.io/fluttervita-gunshots-app-f00e9235c3e3?source=collection_archive---------7-----------------------#2020-04-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/b740f1d4eed3fc6d816f0853a90cae2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:716/1*OgHriL19-QEIEL4WRCAqbg.gif"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">枪声应用</figcaption></figure><blockquote class="jy jz ka"><p id="5d1e" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我会尽量每周发表一篇新文章。下次见。🤓</p></blockquote><p id="1008" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">是的，这是我在2月9日说过的话。我太擅长信守诺言了。因此，我借此机会给自己一个每周两篇文章的挑战，直到WFH日结束。让我们看看我这次得分有多低。</p><p id="8caf" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">我们将建立的应用程序主要是初学者的学习活动。在这一课中，我们将学习许多不同的概念—</p><ol class=""><li id="3c4a" class="ld le iq ke b kf kg kj kk la lf lb lg lc lh kz li lj lk ll bi translated">从资产加载图像</li><li id="93c5" class="ld le iq ke b kf lm kj ln la lo lb lp lc lq kz li lj lk ll bi translated">播放资源中的音频</li><li id="1f3e" class="ld le iq ke b kf lm kj ln la lo lb lp lc lq kz li lj lk ll bi translated">使用堆栈和定位部件</li><li id="cd12" class="ld le iq ke b kf lm kj ln la lo lb lp lc lq kz li lj lk ll bi translated">学习关于容器约束行为的非常具体的事情。</li></ol><p id="98a3" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">这个app更像是一个增量项目。我会继续在这个应用程序中添加东西，并不断用我的作品更新你们。所以让我们开始吧。</p><p id="3a01" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">在开始编写代码之前，我们应该总是后退一步，思考我们将如何构建它。你头脑中的一个小的初始计划，包含基本的布局，状态将如何改变，什么事件将更新用户界面等等。让我和你们分享我的思考过程——</p><p id="58f3" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated"><em class="kd">嗯，所以这个想法当然是在我点击屏幕的任何地方显示一个枪伤标记。对于枪伤我可以用一张图片。此外，为了更新UI，我需要重新构建将在其中显示图像的小部件。那个小部件应该覆盖整个屏幕。因此，用户的每一次点击都会导致这个屏幕大小的小部件的重建，其中有这些枪击图像作为它的子对象。好吧，那我们开始吧。</em></p><figure class="lr ls lt lu gt jr"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="a7ba" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated"><strong class="ke ir">什么是可以扩展到最大尺寸，有多个子控件，并且可以将这些子控件放在其中的精确位置，而不用关心轴或方向的小部件？<br/> </strong>这可以通过组合<code class="fe lx ly lz ma b"><a class="ae mb" href="https://api.flutter.dev/flutter/widgets/Stack-class.html" rel="noopener ugc nofollow" target="_blank">Stack</a></code>和<code class="fe lx ly lz ma b"><a class="ae mb" href="https://api.flutter.dev/flutter/widgets/Positioned-class.html" rel="noopener ugc nofollow" target="_blank">Positioned</a></code>小部件来实现。<br/>让我们看看文档对这两个人说了些什么—</p><blockquote class="jy jz ka"><p id="c83c" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">stack——相对于其盒子的边缘定位其子部件的小部件。如果你想用一种简单的方式重叠几个孩子，这个类是很有用的，例如有一些文本和一个图像，用一个渐变和一个按钮覆盖在底部。</p><p id="f83a" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">定位——控制<a class="ae mb" href="https://api.flutter.dev/flutter/widgets/Stack-class.html" rel="noopener ugc nofollow" target="_blank">堆栈</a>的子堆栈定位的小部件。</p></blockquote><p id="0e54" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">所以现在我们知道如何在<code class="fe lx ly lz ma b">Stack</code>中定位图像。我们将使用定位小部件的<code class="fe lx ly lz ma b">top</code>、<code class="fe lx ly lz ma b">left</code>、<code class="fe lx ly lz ma b">bottom</code>和<code class="fe lx ly lz ma b">right</code>属性在堆栈中定位我们的图像。</p><p id="eded" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated"><strong class="ke ir">但是，堆栈是如何占据整个屏幕面积的呢？<br/> </strong>栈有一个属性叫做<code class="fe lx ly lz ma b">fit</code>属性。它负责将约束从父级传递到堆栈。这基本上意味着，堆栈应该如何根据可用空间调整自身的大小。堆栈应该占用它需要的最小空间，还是应该只占用所有的空间。如果<code class="fe lx ly lz ma b">fit</code>属性被设置为<code class="fe lx ly lz ma b">StackFit.expand</code>，那么堆栈会占用它所能占用的所有空间。</p><p id="2a18" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">好了，我们知道如何在堆栈中定位我们的图像，我们知道如何让堆栈占据所有可用空间，但是现在，我如何加载枪伤标记图像？<br/> 我选择的图片来自<a class="ae mb" href="https://www.freepngimg.com/png/25053-gunshot-hd" rel="noopener ugc nofollow" target="_blank">freepngimg.com</a>。<br/>从资产中加载图像是非常简单的方法。首先，创建下面的路径<code class="fe lx ly lz ma b">assets/images/</code>并添加gunshot.png。然后在<code class="fe lx ly lz ma b">pubspec.yaml</code>文件中的<code class="fe lx ly lz ma b">assets</code>节点下添加<code class="fe lx ly lz ma b">assets/images/gunshot.png</code>。现在，我们都准备好使用图像了。我们将借助<code class="fe lx ly lz ma b">Image</code> (Image.asset constructor)小部件来加载图像。</p><p id="0cc3" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">这就是我们的代码应该看起来的样子，如果我们急着定位一个图像的话—</p><figure class="lr ls lt lu gt jr"><div class="bz fp l di"><div class="mc lw l"/></div></figure><figure class="lr ls lt lu gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi md"><img src="../Images/c75a8b38b340ea5b15dc122902dd2ea5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*phlBK7URIr9BRP68u4gWzg.png"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">这是上面的代码在你的手机上的样子。</figcaption></figure><p id="c12c" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">您可能会注意到图像的<code class="fe lx ly lz ma b">fit</code>属性。<code class="fe lx ly lz ma b">BoxFit.cover</code>调整图像大小，使其尽可能大，同时在给定的限制内保持宽高比。</p><p id="f395" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">好吧，我明白了，但是我如何在每次屏幕点击时添加图像呢？<br/> 我们要做的就是在栈中增加更多的子栈，只需重建栈即可。为了重建堆栈，我们可以调用<code class="fe lx ly lz ma b">setState()</code>方法。<code class="fe lx ly lz ma b">setState()</code>方法重新构建调用它的小部件。<br/>要将孩子添加到堆栈中，我们只需创建一个列表，将该列表分配给<code class="fe lx ly lz ma b">children</code>字段，只要发生屏幕点击，就将<code class="fe lx ly lz ma b">Image</code>追加到该列表中。</p><p id="6dfa" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">好的，那么我如何了解屏幕点击呢？我如何知道点击事件发生的位置？<br/>  <code class="fe lx ly lz ma b">GestureDetector</code>是你要找的widget。它甚至为你提供了<code class="fe lx ly lz ma b">TapDetails</code>。<code class="fe lx ly lz ma b">TapDetails</code>包含全局坐标和相对坐标。</p><p id="bbae" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">嗯，能不能用代码表示一下？<br/> 在这里——</p><figure class="lr ls lt lu gt jr"><div class="bz fp l di"><div class="mc lw l"/></div></figure><p id="d4b9" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">这段代码中有几件事需要注意—</p><ol class=""><li id="5403" class="ld le iq ke b kf kg kj kk la lf lb lg lc lh kz li lj lk ll bi translated">我用的是<code class="fe lx ly lz ma b">onTapDown</code>物业而不是<code class="fe lx ly lz ma b">onTap</code>物业。这是因为<code class="fe lx ly lz ma b">TapDetails</code>可用于<code class="fe lx ly lz ma b">onTapDown</code>回调，而非<code class="fe lx ly lz ma b">onTap</code>回调。</li><li id="4ee1" class="ld le iq ke b kf lm kj ln la lo lb lp lc lq kz li lj lk ll bi translated"><code class="fe lx ly lz ma b">top</code>和<code class="fe lx ly lz ma b">left</code>值减去25.0。这是因为<code class="fe lx ly lz ma b">Image</code>的左上角将位于<code class="fe lx ly lz ma b">Positioned</code>小部件指定的点。因此，要将图像放在点击的中心，我们需要设置<code class="fe lx ly lz ma b">Positioned</code>小部件的值，使<code class="fe lx ly lz ma b">Image</code>的中心位于点击的顶部。</li><li id="1ee5" class="ld le iq ke b kf lm kj ln la lo lb lp lc lq kz li lj lk ll bi translated">这段代码不能像预期的那样工作。如果你尝试点击屏幕，将不会有任何反应。这是因为当第一次创建<code class="fe lx ly lz ma b">Stack</code>时，它没有<code class="fe lx ly lz ma b">children</code>。所以，<code class="fe lx ly lz ma b">Stack</code>里面没什么可渲染的。许多小部件在Flutter中的工作方式是，它们需要有一个子部件或属性，这样它们就可以根据max约束来调整大小。现在，<code class="fe lx ly lz ma b">Container</code>也是这样的小部件，但是将一个<code class="fe lx ly lz ma b">color</code>传递给一个<code class="fe lx ly lz ma b">Stack</code>内的<code class="fe lx ly lz ma b">Container</code>允许用最大可用约束来呈现<code class="fe lx ly lz ma b">Container</code>。<br/>因此，代码做了一点小小的改动。只需在空的<code class="fe lx ly lz ma b">_gunshots</code>列表中添加一个<code class="fe lx ly lz ma b">Container</code>即可。</li></ol><pre class="lr ls lt lu gt mi ma mj mk aw ml bi"><span id="83ab" class="mm mn iq ma b gy mo mp l mq mr">@override<br/><strong class="ma ir">void </strong>initState<strong class="ma ir"><em class="kd">() {<br/>  </em>super</strong>.initState<strong class="ma ir"><em class="kd">()</em></strong>;<br/>  <strong class="ma ir">this</strong>.<strong class="ma ir">_gunshots </strong>= <strong class="ma ir"><em class="kd">&lt;</em></strong>Widget<strong class="ma ir"><em class="kd">&gt;[<br/>    </em></strong>Container<strong class="ma ir"><em class="kd">(</em></strong>color: Colors.<em class="kd">white</em>,<strong class="ma ir"><em class="kd">)<br/>  ]</em></strong>;<br/><strong class="ma ir"><em class="kd">}</em></strong></span></pre><p id="ecee" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated"><strong class="ke ir">嗯，我想现在我们只剩下声音部分了？<br/> </strong>是的，声音部分再次类似于我们做图像加载部分的方式。但是这一次，我们需要一个依赖来减轻我们的工作。<br/>我们将使用<a class="ae mb" href="https://pub.dev/packages/audioplayers" rel="noopener ugc nofollow" target="_blank">音频播放器</a>依赖。首先，我们将创建一个<code class="fe lx ly lz ma b">assets/sounds/</code>路径，并在其中添加我们的gunshot.mp3文件。然后我们在代码中创建一个<code class="fe lx ly lz ma b">AudioCache</code>对象，只要需要播放音频就调用<code class="fe lx ly lz ma b">play</code>方法。在play方法中指定音频文件的路径时要小心，默认情况下它会添加一个<code class="fe lx ly lz ma b">assets/</code>前缀。</p><p id="f68b" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">这是最终的代码—</p><figure class="lr ls lt lu gt jr"><div class="bz fp l di"><div class="mc lw l"/></div></figure><blockquote class="ms"><p id="9eb6" class="mt mu iq bd mv mw mx my mz na nb kz dk translated">非常感谢您阅读这篇文章。我鼓励你用一种不同的方法来构建它(我将在下一篇文章中讨论)，或者用你从中学到的东西来构建别的东西。☕ <br/>请在评论中分享你的想法和建议。<br/>到那时，快乐飘飘。🍺</p></blockquote></div></div>    
</body>
</html>