<html>
<head>
<title>React Performance: How to avoid redundant re-renders</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应性能:如何避免冗余的重新渲染</h1>
<blockquote>原文：<a href="https://itnext.io/react-performance-how-to-avoid-redundant-re-renders-6a33618d92a3?source=collection_archive---------3-----------------------#2022-01-30">https://itnext.io/react-performance-how-to-avoid-redundant-re-renders-6a33618d92a3?source=collection_archive---------3-----------------------#2022-01-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/fc6109a4b840a6f86fb36e61d39bf31f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BLVW2RFElo0EtYMRfMRVpQ.png"/></div></div></figure><p id="b807" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">冗余重渲染是React中的常见问题。如果不认真对待，这个问题会迅速恶化您的应用程序的性能。</p><p id="a3c6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">通过理解和实现这些实践，您可以避免该问题并保持渲染过程平稳运行。</p><h1 id="039a" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">备忘录和使用回拨</h1><p id="0f6d" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">让我们先来看看你的主要工具箱，它可以减少重复渲染:<code class="fe mc md me mf b">memo</code>和<code class="fe mc md me mf b">useCallback</code>。您应该知道这些实用函数是如何工作的，以便能够优化React性能。</p><p id="6d1a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">memo 是React library提供的一个实用方法，用来记忆组件的状态，使它们只在道具改变时才渲染。您需要做的就是用函数包装您的组件声明:</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mh"><img src="../Images/d5723c699cac6e0f802e4f9332ce55b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Cuk-HMKBTQYqlkHyz2ua_Q.png"/></div></div></figure><p id="58a0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，<code class="fe mc md me mf b">ListItem</code>组件将不再像它的父组件那样重新渲染。只有当传递给它的道具改变时，<code class="fe mc md me mf b">ListItem</code>才会重新渲染。这在处理大型列表时尤其有用。每当父列表的状态发生变化时，列表项不会重新呈现。这种调整可以极大地提高用户界面的性能。</p><p id="fc56" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">那么<a class="ae mg" href="https://reactjs.org/docs/hooks-reference.html#usecallback" rel="noopener ugc nofollow" target="_blank"> useCallback </a>呢？在前面的例子中，我们的<code class="fe mc md me mf b">ListItem</code>没有收到任何事件处理程序道具。然而，将事件处理程序从父级传递到子级是一种常见的模式，毫无疑问，在使用React时会经常用到。</p><p id="bf7c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然而，将事件处理程序传递给内存化组件有一个小问题。事件处理程序通常在父组件内部声明，这意味着它们将在每次父组件声明时重新呈现。这将使用<code class="fe mc md me mf b">memo</code>包装我们的子组件变得无用，因为事件处理程序道具无论如何都会导致它每次都被重新渲染。</p><p id="0f82" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这就是<code class="fe mc md me mf b">useCallback</code>的用武之地。这个实用程序方法返回它接收到的任何回调函数的记忆版本。只有当您提供的依赖项发生变化时，它才会重新计算您传递的函数值。</p><p id="1fac" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们看看如何使用<code class="fe mc md me mf b">useCallback</code>向<code class="fe mc md me mf b">ListItem</code>传递一个事件处理程序，而不会导致多余的重新呈现:</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mm"><img src="../Images/0a035b5701de4dc2e23caa9089301864.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OHyP8p_IEK56sas9eDyIyQ.png"/></div></div></figure><p id="712d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在上面的例子中，我们用<code class="fe mc md me mf b">useCallback</code>包装了<code class="fe mc md me mf b">handleClick</code>事件处理程序。<code class="fe mc md me mf b">useCallback</code>将在初始渲染后记忆我们的处理函数。下一次我们的父列表重新呈现时<code class="fe mc md me mf b">useCallback</code>将返回我们的处理函数的相同记忆版本。<code class="fe mc md me mf b">ListItem</code>组件将因此避免多余的重新渲染，因为它的属性都没有改变。</p><p id="56b5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">注意:</strong>无论何时使用<code class="fe mc md me mf b">memo</code>来减少组件的重渲染，一定要用<code class="fe mc md me mf b">useCallback</code>包装组件接收的事件处理器属性。否则，你的努力是徒劳的。</p><h1 id="35cf" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">对你的组件要决定的事情要有辨别力</h1><p id="7f90" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">无论何时创建React组件，都要记住所给上下文的范围。问问你自己，组件是否真的应该对某些事情做出决定。</p><p id="d487" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">例如，组件很少需要决定它们是否应该呈现自己。通常最好由父组件来做这个决定。</p><p id="acb4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在呈现列表时，宁可严格提供列表项运行所需的道具。尽量避免将父级的任何状态变量传递给子级。传递父级的状态变量将导致所有列表项在变量每次更改时重新呈现。随着你的清单越来越大，这种负面影响会越来越大。</p><p id="3b9c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">相反，尝试根据父对象的更新状态派生出一个基本道具。这样，子组件只需要在图元改变时重新渲染。</p><p id="902e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们来看一个例子:</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mn"><img src="../Images/38df68632f1e7ae493696000294eb8e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VEdcGO-VjE1nDyaOiUndRw.png"/></div></div></figure><p id="9a2f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里我们有一个<code class="fe mc md me mf b">ListItem</code>，用于显示<code class="fe mc md me mf b">List</code>中的项目。<code class="fe mc md me mf b">ListItem</code>接受<code class="fe mc md me mf b">id</code>、<code class="fe mc md me mf b">selectedId</code>和<code class="fe mc md me mf b">title</code>属性。我们还在每次<code class="fe mc md me mf b">ListItem</code>渲染时将“渲染”一词输出到控制台，以查看它渲染了多少次。请注意，我们还用<code class="fe mc md me mf b">memo</code>包装了<code class="fe mc md me mf b">ListItem</code>，以减少每个项目的重新渲染次数。</p><p id="8e47" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了这个例子，我们在<code class="fe mc md me mf b">useEffect</code>中设置<code class="fe mc md me mf b">selectedItemId</code>到<code class="fe mc md me mf b">2</code>。这样做将在初始渲染后触发父组件的另一次重新渲染。</p><p id="d6d7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">运行上面的例子后，控制台将总共输出单词“Render”6次:在每个列表项的初始呈现期间输出3次，在调用<code class="fe mc md me mf b">setSelectedItemId</code>时再输出3次。</p><p id="5f5b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在让我们看看如何避免多余的渲染:</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mn"><img src="../Images/d376791124873f3d6b1c94459c647331.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ihnDkqX0wsmc_cfTlBmwag.png"/></div></div></figure><p id="b7f3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这个例子中，<code class="fe mc md me mf b">ListItem</code>接收<code class="fe mc md me mf b">isSelected</code>属性，让它知道项目是否被选中。现在由父<code class="fe mc md me mf b">List</code>组件做出决定。因此，单词“Rendered”将只打印4次。这是因为没有选择的项目没有重新渲染，因为它们的道具都没有改变。</p><p id="de68" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">虽然将渲染数量从6个减少到4个似乎没什么大不了的，但是当您处理渲染大量数据并具有相当大的组件树的大型列表时，使用这种方法可以显著提高它们的性能。</p><h1 id="939c" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">使用扁平的道具和基本体</h1><p id="999a" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">这条建议与前一条有关。当传递复杂的数据结构作为道具时，尽量传递扁平化和简化的版本，而不是整个对象。</p><p id="c734" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">更好的是，尝试从数据结构中提取组件需要的字段作为原始道具。这将使将来优化组件的性能变得更加容易。</p><p id="4ce5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我告诉你我的意思。假设我们有一个显示用户信息的<code class="fe mc md me mf b">Profile</code>组件:</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mn"><img src="../Images/676ad16d9c372f092d81a8b64bc06802.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8_qUhq2fstqTyv8wCW8U1A.png"/></div></div></figure><p id="1e5b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这个组件没什么特别可怕的。但是，我们应该问自己:“我们真的需要整个传递整个用户对象吗？”</p><p id="93c0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因为我们只使用了对象中的两个字段，所以我们可以接受它们作为原始道具:</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mn"><img src="../Images/5922ada98883304a65a526abf96aed86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yXTuO4DEPWLPAbgJSC4xzQ.png"/></div></div></figure><p id="f201" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果<code class="fe mc md me mf b">user</code>对象被重新创建，这很容易在组件的生命周期内发生多次，这不会导致我们的<code class="fe mc md me mf b">Profile</code>组件被重新渲染。<code class="fe mc md me mf b">Profile</code>不在乎<code class="fe mc md me mf b">user</code>对象是否被重新创建，只要<code class="fe mc md me mf b">title</code>和<code class="fe mc md me mf b">name</code>字段的值保持不变。现在用<code class="fe mc md me mf b">memo</code>包装<code class="fe mc md me mf b">Profile</code>就容易多了。</p><h1 id="442f" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">小心使用效果</h1><p id="7f8a" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated"><a class="ae mg" href="https://reactjs.org/docs/hooks-reference.html#useeffect" rel="noopener ugc nofollow" target="_blank">使用效果</a>是你如何进入组件的生命周期。然而，我经常看到它被用在本可以避免的地方。我认为过度使用<code class="fe mc md me mf b">useEffect</code>的主要问题是你的应用会充满意想不到的副作用，这可能会导致冗余的重新渲染，或者更糟糕的是，冗余的服务器调用。</p><p id="1425" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们看一个例子。假设我们有一个显示用户资料的<code class="fe mc md me mf b">UserList</code>组件。您可以展开每个配置文件以查看更多信息:</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mo"><img src="../Images/b34cc6665077617a87ba2828752ebf30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TUaWoFQAm-BYdk1n2bd3qA.png"/></div></div></figure><p id="9235" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在上面的代码中，我们使用<code class="fe mc md me mf b">useEffect</code>来跟踪何时应该获取额外的信息，但是这有必要吗？一个更简单、更经得起未来考验的解决方案是在扩展点击处理程序中获取附加信息:</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mo"><img src="../Images/c2172534949ed29c9c643ece79672d6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xXJCb3R830nO8xoopS8Zbg.png"/></div></div></figure><p id="b41f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这样做更好的主要原因是，随着组件复杂性的增加，你可能会引入其他逻辑来改变<code class="fe mc md me mf b">selectedUserId</code>，但不一定需要请求额外的信息。如果您不小心，您可能会在不希望的情况下触发请求。</p><p id="2ee9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">经常使用<code class="fe mc md me mf b">useEffect</code>是合理的，甚至可能是唯一可行的解决方案。也就是说，如果你需要<code class="fe mc md me mf b">useEffect</code>，我建议仔细检查一下。有时候你可以依靠其他更安全的触发器，比如用户动作。</p><h1 id="d32e" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">结论</h1><p id="610f" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">在这篇文章中，我们看了一些优化React渲染过程的实践。通过遵循这些提示，您可以避免不必要的重新渲染，并提高应用程序的性能。希望你觉得有用！</p><p id="e4ce" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你想了解更多关于编写更好的React代码的技巧，可以看看我的另一篇文章“<a class="ae mg" href="https://isamatov.com/simple-tips-for-writing-clean-react-components/" rel="noopener ugc nofollow" target="_blank">编写干净React组件的简单技巧</a>”。</p><p id="6693" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你想获得更多的网络开发、反馈和打字技巧，可以考虑<a class="ae mg" href="https://twitter.com/IskanderSamatov" rel="noopener ugc nofollow" target="_blank">在Twitter上关注我，</a>我在那里分享我学到的东西。<br/>快乐编码！</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><p id="9ccd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="mw">原载于2022年1月30日https://isamatov.com</em><a class="ae mg" href="https://isamatov.com/react-avoid-redundant-renders/" rel="noopener ugc nofollow" target="_blank"><em class="mw"/></a><em class="mw">。</em></p></div></div>    
</body>
</html>