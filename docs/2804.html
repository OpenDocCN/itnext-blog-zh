<html>
<head>
<title>5 TypeScript tips to improve your applications</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">改进应用程序的5个打字技巧</h1>
<blockquote>原文：<a href="https://itnext.io/5-typescript-tips-to-improve-your-applications-e882d69592bd?source=collection_archive---------2-----------------------#2019-08-06">https://itnext.io/5-typescript-tips-to-improve-your-applications-e882d69592bd?source=collection_archive---------2-----------------------#2019-08-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/103b91c6b9b6dad05b1f41ad29d6328f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7jB5g9iVa6HwfuyiY3mrTA.png"/></div></div></figure><p id="5f3b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">尽管我几乎每天都用TypeScript工作，但我还是经常学到一些新东西。我真的很喜欢用它工作，并且尽可能地充分利用它——有一点是肯定的:TypeScript可以做很多事情。</p><p id="7a05" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里是我从过去的经历中学到的一些东西，它们帮助我改进了我的应用程序，并最终成为一名更好的TypeScript开发人员。</p><h1 id="2fb7" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">实用程序类型</h1><p id="4555" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">TypeScript提供了一些现成的有用类型——它们被称为<em class="kw">实用类型</em>并且可以在<a class="ae ma" href="https://www.typescriptlang.org/docs/handbook/utility-types.html" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="a8ee" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我个人最喜欢的类型之一是<code class="fe mb mc md me b">Readonly&lt;T&gt;</code>类型使得<code class="fe mb mc md me b">T</code>的所有属性都是只读的，这使得帮助你维护<a class="ae ma" href="https://en.wikipedia.org/wiki/Immutable_object" rel="noopener ugc nofollow" target="_blank">的不变性</a>变得很容易。</p><p id="d9ff" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">另一个方便的类型是<code class="fe mb mc md me b">Required&lt;T&gt;</code>,它提供所有必需的属性。</p><p id="d0ec" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">还有更多类似于<code class="fe mb mc md me b">Pick&lt;T, K&gt;</code>的东西，它创建一种从另一种类型中选取属性的<em class="kw">类型，<code class="fe mb mc md me b">NonNullable&lt;T&gt;</code>从属性中移除<code class="fe mb mc md me b">null</code>和<code class="fe mb mc md me b">undefined</code>，<code class="fe mb mc md me b">Exclude&lt;T, U&gt;</code>从一种类型中移除属性，还有更多——去<a class="ae ma" href="https://www.typescriptlang.org/docs/handbook/utility-types.html" rel="noopener ugc nofollow" target="_blank">看看</a>吧，它们真的很有用。</em></p><h1 id="f657" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">用unknown代替any</h1><p id="d1c1" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">很多时候，如果您没有确切的类型信息，您可能会选择<code class="fe mb mc md me b">any</code>。这实际上完全没问题——直到TypeScript 3.0引入了新的<code class="fe mb mc md me b">unknown</code>类型，即<em class="kw">“类型安全对应的</em><code class="fe mb mc md me b"><em class="kw">any</em></code><em class="kw"/>”(正如TypeScript 所描述的<a class="ae ma" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-0.html#new-unknown-top-type" rel="noopener ugc nofollow" target="_blank">)。</a></p><p id="11d5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">就像<code class="fe mb mc md me b">any</code>类型一样，你可以给<code class="fe mb mc md me b">unknown</code>类型分配任何你想要的东西——但是你不能像<code class="fe mb mc md me b">any</code>类型那样用它做<em class="kw">任何</em>事情:</p><pre class="mf mg mh mi gt mj me mk ml aw mm bi"><span id="53cb" class="mn ky iq me b gy mo mp l mq mr">const imUnknown: unknown = "hello there";<br/>const imAny: any = "hello there";</span><span id="1c1f" class="mn ky iq me b gy ms mp l mq mr">imUnknown.toUpperCase(); // error: object is of type "unknown"<br/>imAny.toUpperCase(); // totally fine</span></pre><p id="a1bf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此<code class="fe mb mc md me b">unknown</code>由于其<em class="kw">未知的</em>性质而阻止对其调用任何方法。另外将<code class="fe mb mc md me b">unknown</code>类型分配给其他类型也是不可能的:</p><pre class="mf mg mh mi gt mj me mk ml aw mm bi"><span id="4835" class="mn ky iq me b gy mo mp l mq mr">let a: unknown = "hello world";<br/>let b: string;</span><span id="4f22" class="mn ky iq me b gy ms mp l mq mr">b = a; // error: a is unknown hence it's not possible to assign it to `string`</span></pre><p id="1ad7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通常情况下，你刚刚声明的变量<code class="fe mb mc md me b">any</code>实际上是<code class="fe mb mc md me b">unknown</code>——这可以防止错误的赋值或者在不知道它提供了什么方法的情况下调用它的方法。</p><p id="2465" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">关于<code class="fe mb mc md me b">unknown</code>类型的更多信息，请参见此处的<a class="ae ma" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-0.html#new-unknown-top-type" rel="noopener ugc nofollow" target="_blank"/>。</p><h1 id="96b6" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">查找类型</h1><p id="62aa" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">查找类型是帮助您找到所需内容的一种简洁的方式。让我们假设您有一个具有动态数量属性的对象，并希望从中获得一个特定的属性，很有可能通过以下方式实现:</p><pre class="mf mg mh mi gt mj me mk ml aw mm bi"><span id="4d9c" class="mn ky iq me b gy mo mp l mq mr">const persons = {<br/>  john: { surname: 'Doe' },<br/>  bob: { surname: 'The builder' }<br/>};</span><span id="bda1" class="mn ky iq me b gy ms mp l mq mr">persons.john; // equals { surname: 'Doe' }</span></pre><p id="afbc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是有一个问题:如果<code class="fe mb mc md me b">john</code>属性不存在怎么办？您的应用程序很可能悲惨地死亡——但这可以通过TypeScript来避免！</p><p id="be79" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过实现一个非常小的助手，我们能够防止这种情况:</p><pre class="mf mg mh mi gt mj me mk ml aw mm bi"><span id="a638" class="mn ky iq me b gy mo mp l mq mr">function getProperty&lt;T, K extends keyof T&gt;(obj: T, key: K) {<br/>    return obj[key];  // Inferred type is T[K]<br/>}</span></pre><p id="06d0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过使用这个助手，我们可以确保在使用它时属性存在:</p><pre class="mf mg mh mi gt mj me mk ml aw mm bi"><span id="38ea" class="mn ky iq me b gy mo mp l mq mr">function getProperty&lt;T, K extends keyof T&gt;(obj: T, key: K) {<br/>    return obj[key];  // Inferred type is T[K]<br/>}</span><span id="377a" class="mn ky iq me b gy ms mp l mq mr">const persons = {<br/>    john: { surname: 'Doe' },<br/>    bob: { surname: 'The builder' }<br/>};</span><span id="c78a" class="mn ky iq me b gy ms mp l mq mr">getProperty(persons, 'bob');<br/>getProperty(persons, 'john');<br/>getProperty(persons, 'someoneelse'); // Error: Argument of type "someonelse" is not assignable to parameter of type "bob" | "john"</span></pre><p id="6374" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在类中使用这种方法可能很常见，这使得<code class="fe mb mc md me b">obj</code>参数过时了。它可能被实现为一个getter，用于获取我们想要知道哪些元素可用的特定项目。在这种情况下，我们将使用一种相当不常见的语法:</p><pre class="mf mg mh mi gt mj me mk ml aw mm bi"><span id="c16f" class="mn ky iq me b gy mo mp l mq mr">class PersonList {<br/>  persons = {<br/>    john: { surname: 'Doe' },<br/>    bob: { surname: 'The Builder' }<br/>  }<br/>  <br/>  getPerson(name: keyof PersonList['persons']) {<br/>    return this.persons[name];<br/>  }<br/>}</span></pre><p id="3a98" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mb mc md me b">keyof PersonList['persons']</code>可能不是你每天都能看到的。</p><p id="4c33" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这会导致调用<code class="fe mb mc md me b">personList.getPerson('john')</code>完全正常，而<code class="fe mb mc md me b">personList.getPerson('jane')</code>会失败，因为没有可用的<code class="fe mb mc md me b">jane</code>键。</p><h1 id="b7f1" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">扩展第三方库</h1><p id="5b63" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">如果你曾经想要扩展一个第三方库，但是受到那个库的公共API的限制，那么模块扩充就是你正在寻找的。但是你什么时候想要那个？</p><p id="7ac8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">假设我们有一个角度应用程序，我们想命名我们的路线。默认情况下，Angular接口不提供<code class="fe mb mc md me b">name</code>属性——这正是模块扩充派上用场的地方。</p><p id="8c92" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过在Angular项目的根中创建一个<code class="fe mb mc md me b">typings.d.ts</code>,我们可以简单地告诉TypeScript我们想要一个额外的、可选的属性来存储名称:</p><pre class="mf mg mh mi gt mj me mk ml aw mm bi"><span id="e920" class="mn ky iq me b gy mo mp l mq mr">import {Route} from '<a class="ae ma" href="http://twitter.com/angular/router" rel="noopener ugc nofollow" target="_blank">@angular/router</a>';</span><span id="ef35" class="mn ky iq me b gy ms mp l mq mr">declare module '<a class="ae ma" href="http://twitter.com/angular/router" rel="noopener ugc nofollow" target="_blank">@angular/router</a>' {<br/>  interface Route {<br/>    name?: string;<br/>  }<br/>}</span></pre><p id="2da5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">重要的是从<code class="fe mb mc md me b">@angular/router</code>导入，以便TypeScript注册剩余的属性。</p><p id="3ca7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们可以简单地为我们的路线添加一个名称:</p><pre class="mf mg mh mi gt mj me mk ml aw mm bi"><span id="e5a3" class="mn ky iq me b gy mo mp l mq mr">const routes: Routes = [<br/>  {<br/>    path: '',<br/>    name: 'theMightyDashboard',<br/>    component: DashboardComponent<br/>  },<br/>];</span></pre><p id="96f8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，可以通过注入<code class="fe mb mc md me b">ActivatedRoute</code>在我们的组件中使用:</p><pre class="mf mg mh mi gt mj me mk ml aw mm bi"><span id="69d2" class="mn ky iq me b gy mo mp l mq mr">constructor(private route: ActivatedRoute) {<br/>  console.log(route.routeConfig.name); // logs `theMightyDashboard`!<br/>}</span></pre><h1 id="916c" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">ES类型</h1><p id="c906" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">我经常看到除了本机es元素之外，大多数内容都被正确键入的类型脚本代码。想想类似<a class="ae ma" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map" rel="noopener ugc nofollow" target="_blank">地图</a> s、<a class="ae ma" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" rel="noopener ugc nofollow" target="_blank">无极</a> s、<a class="ae ma" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array" rel="noopener ugc nofollow" target="_blank">阵法</a> s、<a class="ae ma" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects" rel="noopener ugc nofollow" target="_blank">所有那种玩意儿</a>。但是TypeScript为这些对象提供了现成的类型；</p><p id="67bb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，地图确实提供了泛型来定义地图的内容。所以不要</p><pre class="mf mg mh mi gt mj me mk ml aw mm bi"><span id="cc68" class="mn ky iq me b gy mo mp l mq mr">const map = new Map(); <br/>map.set('name', 'John Doe');</span></pre><p id="02b6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以通过指定映射键<em class="kw">和</em>值的类型来改进这一点:</p><pre class="mf mg mh mi gt mj me mk ml aw mm bi"><span id="0289" class="mn ky iq me b gy mo mp l mq mr">const map: Map&lt;string, string&gt; = new Map(); <br/>map.set('name', 'John Doe');</span></pre><p id="8aa1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这可以防止我们意外添加不允许的类型:</p><pre class="mf mg mh mi gt mj me mk ml aw mm bi"><span id="149e" class="mn ky iq me b gy mo mp l mq mr">const map: Map&lt;string, string&gt; = new Map();<br/>map.set('name', 123); // error: 123 is not a string</span></pre><p id="fa28" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这同样适用于<code class="fe mb mc md me b">Set</code>:</p><pre class="mf mg mh mi gt mj me mk ml aw mm bi"><span id="3dc3" class="mn ky iq me b gy mo mp l mq mr">const set: Set&lt;number&gt; = new Set(); set.add(123); // Ok! set.add('whatever'); // Type error</span></pre><p id="1f45" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">或本机数组:</p><pre class="mf mg mh mi gt mj me mk ml aw mm bi"><span id="ce1b" class="mn ky iq me b gy mo mp l mq mr">const elements: Array&lt;{ name: string }&gt; = []; <br/>elements.push({ name: 'John Doe' }); // Ok! <br/>elements.push('John Doe'); // Type error</span></pre><p id="8e9c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你想看看所有可用的型号，请查看<a class="ae ma" href="https://github.com/microsoft/TypeScript/blob/master/lib/lib.es5.d.ts" rel="noopener ugc nofollow" target="_blank"> ES5 </a>和<a class="ae ma" href="https://github.com/microsoft/TypeScript/blob/master/lib/lib.es6.d.ts" rel="noopener ugc nofollow" target="_blank"> ES6 </a>的官方型号(或所有<a class="ae ma" href="https://github.com/microsoft/TypeScript/tree/master/lib" rel="noopener ugc nofollow" target="_blank">其他规格</a>)。</p><h1 id="cf91" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">还有别的吗？</h1><p id="768b" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">正如开头所说，TypeScript可以做很多事情，有时很难保持最新。如果你真的喜欢TypeScript的某些东西，但你并不是每天都能看到，请在评论中告诉我！</p></div><div class="ab cl mt mu hu mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ij ik il im in"><p id="6d20" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你喜欢这篇文章，请留下👏，关注我上 <a class="ae ma" href="https://twitter.com/nehalist" rel="noopener ugc nofollow" target="_blank"> <em class="kw">推特</em> </a> <em class="kw">并订阅</em> <a class="ae ma" href="https://nehalist.io/newsletter/" rel="noopener ugc nofollow" target="_blank"> <em class="kw">我的快讯</em> </a> <em class="kw">。本帖原载于2019年8月6日</em> <a class="ae ma" href="https://nehalist.io/5-typescript-tips-to-improve-your-architecture" rel="noopener ugc nofollow" target="_blank"> <em class="kw">我的博客</em> </a> <em class="kw">。</em></p></div></div>    
</body>
</html>