<html>
<head>
<title>Fun CSharp: Pure, Lazy and Async pipeline creation.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">趣味CSharp:纯、懒、异步管道创建。</h1>
<blockquote>原文：<a href="https://itnext.io/fun-csharp-pure-lazy-and-async-pipeline-creation-204923eb6e14?source=collection_archive---------1-----------------------#2020-04-25">https://itnext.io/fun-csharp-pure-lazy-and-async-pipeline-creation-204923eb6e14?source=collection_archive---------1-----------------------#2020-04-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/7e4747411825928bc6ee1cea56fba9f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6zEzBYn4gyRJFU4rctOZzg.jpeg"/></div></div></figure><p id="6367" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">几天前，我需要创建一个异步管道，它由相互叠加的动作(方法)组成。我还希望这条管道的构建不会产生任何副作用，包括<em class="kw">异常</em>、对象状态突变、IO操作等等。我有函数合成的需求，但也想要一元合成(Kleisli合成)，并且不想使用<em class="kw">任务。运行</em>，我不喜欢在ASP.NET应用程序中这样做。</p><p id="89a4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在用IO Monad编写了JavaScript之后，我决定用C#做一些类似的事情，这满足了我的需求。我想出了一个初步的实现，我把它叫做<em class="kw"> AsyncLazyPipeline </em>。我不太擅长给东西命名，所以如果你能想到一个更好的名字，请随时给我你的建议。我做了一些研究，看看是否有我可以使用的东西，我发现的是一个混合了<em class="kw">Lazy&lt;T&gt;T7】和<em class="kw"> Tasks </em>的实现，但是一方面使用了<em class="kw"> Task。另一方面，Run </em>并没有满足我在上面段落中表达的所有需求。你可以在这里<a class="ae kx" href="https://gist.github.com/ericrey85/da9671a22234ef981e5ee3653face4af#file-asynclazypipeline-cs" rel="noopener ugc nofollow" target="_blank">找到<strong class="ka ir">asynclazypipeline . cs</strong>https://gist . github . com/ericrey 85/da 9671 a 22234 ef 981 e 5 ee 3653 face 4 af # file-asynclazypipeline-cs</a>。</em></p><p id="2cca" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了展示如何使用这个类，我创建了一个POC，它由一个简单的域类(<em class="kw"> Item </em>)、一个应用服务(<em class="kw"> ItemService </em>)和几个补充类组成，我们将在本文中看到。继续之前，请确保在浏览器中打开gist链接。</p><p id="f4e4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> AsyncLazyPipeline成员描述:</strong></p><p id="31b3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kw">表达式</em>:该属性将保存所有传递到管道中的动作(方法)的组合。你可以这样想:给定两个函数/方法g和f，以及一个初始值x，形式为<em class="kw"> f(g(x)) </em>的组合意味着执行<em class="kw"> g(x) </em>，并将结果传递给<em class="kw"> f </em>(也执行它)。用JavaScript术语来说，它也可能是类似于<em class="kw"> pipe(g，f)(x) </em>或<em class="kw"> compose(f，g)(x) </em>的东西。这个<em class="kw">表达式</em>属性将代表那个组合，我所说的管道。一旦你看到代码示例，你就会明白了。</p><p id="3e59" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kw">构造器</em>:你不需要显式调用它，它正被<em class="kw"> CreatePipeLine </em>用来创建管道。</p><p id="bb75" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kw"> Flatten: </em>执行表达式属性中的委托，给消费者一个<em class="kw">任务&lt; T &gt; </em>，表示此时<em class="kw">异步</em>流水线<em class="kw">。</em></p><p id="cbf1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kw">选择</em>:有两个。它们允许您传递将在当前管道末端通过管道传递的委托，也就是说，将在已经排队的委托之后执行的委托。</p><p id="713b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kw"> SelectMany </em>:你还会看到其中的两种方法。其中一个只有一个参数，相当于函数式程序员所知的函数<em class="kw"> bind/chain/flatMap </em>。它允许你做一些类似于<em class="kw"> Select </em>方法之一的事情，但是它作为参数接收的委托的签名是不同的，这个委托返回一个<em class="kw"> AsyncLazyPipeline </em>的实例。最后一个<em class="kw"> SelectMany </em>，带两个参数，允许C#中的LINQ查询语法，这在函数式编程世界中称为Monadic/Kleisli复合。同样，一旦你看到代码，它会变得更加清晰。</p><p id="a7c9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">添加两个接口只是为了向您展示管道的创建者(<em class="kw"> ItemService </em>)如何与其他类进行交互。其中一个(<em class="kw">IO operations</em>)具有返回<em class="kw"> Task &lt; T &gt; </em>的方法(在产品代码中，这些方法可能属于某个存储库、外观、IO执行类等)。另一个接口(<em class="kw">ifinalnotappender</em>)有一个返回<em class="kw">AsyncLazyPipeline&lt;t source&gt;</em>的方法，它向您展示了如何进行一元合成。你将在gist URL上看到的另一个文件是<em class="kw"> ObjectExtensions </em>，它只是将任何对象转换成包装该对象的<em class="kw"> Task &lt; T &gt; </em>的一个更短的方法。这将在编写非<em class="kw">异步</em>委托时派上用场。</p><p id="d610" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我还想提一下，在<em class="kw"> AsyncLazyPipeline.cs </em>中还有另一个类，<em class="kw"> CreatePipeLine </em>。这是一个简单的静态类，作为一个工厂来创建<em class="kw">AsyncLazyPipeline&lt;t source&gt;</em>实例，而不必处理通用参数<em class="kw"> TSource </em>。</p><p id="a703" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">项目服务:</strong></p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="277a" class="lh li iq ld b gy lj lk l ll lm">public class ItemService<br/>{<br/>   private IFinalNoteAppender NoteAppender { get; }<br/>   private IOperations Operations { get; }<br/>  <br/>   public ItemService(IOperations operations, <br/>                      IFinalNoteAppender noteAppender)<br/>   {<br/>      NoteAppender = noteAppender;<br/>      Operations = operations;<br/>   }</span><span id="9779" class="lh li iq ld b gy ln lk l ll lm">   public Task&lt;Item&gt; AddNotesToItem()<br/>   {<br/>      var combineNotes = CreatePipeLine<br/>                   .With(Operations.GetFirstFileNote)<br/>                   .Select(Operations.CombineWithSecondFileNote);</span><span id="f1a5" class="lh li iq ld b gy ln lk l ll lm">      var appendLastNote =<br/>          from notes in combineNotes<br/>          from finalNote in NoteAppender.AppendFinalText(notes)<br/>          select finalNote;</span><span id="1a00" class="lh li iq ld b gy ln lk l ll lm">      var combinedOperations = appendLastNote<br/>                   .Select(new Item().AddNotes);</span><span id="253a" class="lh li iq ld b gy ln lk l ll lm">      return combinedOperations.Flatten();<br/>    }<br/>}</span></pre><p id="cb85" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">看看这个类唯一的方法，AddNotesToItem。第一步是从一个文件中获取一个注释，然后将这一步与从第二个文件中获取另一个注释并将这两个注释附加在一起的步骤结合起来。变量<em class="kw"> combineNotes </em>的类型为<em class="kw">AsyncLazyPipeline&lt;string&gt;</em>，这意味着如果您在此时执行管道，您将获得一个<em class="kw">字符串</em>。接下来，您可以看到我一直在谈论的一元合成(LINQ查询语法)。这就像你在对着<em class="kw">ienumbiable&lt;T&gt;T45】做，只不过你不是，你是在对着<em class="kw">asynclazy pipeline&lt;T source&gt;</em>做。</em></p><p id="3e44" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，<em class="kw"> appendLastNote </em>表示获取已经附加到彼此的前两个音符并向它们添加最后一个音符的操作。看<em class="kw">落款人的签名。AppendFinalText </em>:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="73e8" class="lh li iq ld b gy lj lk l ll lm">AsyncLazyPipeline&lt;string&gt; AppendFinalText(string value)</span></pre><p id="9a77" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这意味着管道将在某个时候执行这个方法，并将存储在notes中的值传递给这个方法(在LINQ查询中)。然后，我们使用<em class="kw"> Select </em>方法的版本，它没有采用<em class="kw"> async </em>委托，而是采用sync委托，来创建一个<em class="kw">项目</em>，并向其中添加现在已处理的注释。变量<em class="kw"> combinedOperations </em>表示当该管道的消费者决定执行它时需要发生的一切。最后一点代码(对<em class="kw"> Flatten </em>的调用)确保这个消费者可以访问一个<em class="kw">任务&lt;项目&gt;T15】，而不是<em class="kw"> Func &lt;任务&lt;项目&gt; &gt; </em>，尽管如果您更喜欢它(或者更适合您的场景)，您可以返回后者而不是前者。</em></p><p id="f1bf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">假设您有一个控制台应用程序，或者一个ASP.NET核心控制器，或者任何其他使用<em class="kw"> ItemService </em>的调用者，您可能会有这样的代码(为了演示的目的进行了简化，在生产中应该真正使用构造注入):</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="7b7a" class="lh li iq ld b gy lj lk l ll lm">var service = new ItemService(new Operations(),<br/>                              new FinalNoteAppender());</span><span id="02db" class="lh li iq ld b gy ln lk l ll lm">var pipeline = service.AddNotesToItem();</span></pre><p id="0fba" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">完成此操作后，整个管道将已建成，但还没有发生任何事情。没有IO从文件中读取注释，没有异常，甚至没有创建<em class="kw">项目</em>对象。整个管道都已构建，没有对任何系统状态进行更改。</p><p id="b8e8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该管道的结构是纯的，<em class="kw"> AddNotesToItem </em>方法是纯的。你可以想叫多少次就叫多少次，你不会观察到副作用或不同的行为。这对于单元测试来说是一个好消息，对于纯函数/方法擅长的其他事情来说也是如此，我需要一篇文章来讨论这些事情，但是至少我可以说它们是函数式编程的核心及其好处。</p><p id="4747" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，当您准备好开始工作，当您准备好释放您的代码并让您的系统在世界上享有它应得的声誉时，您只需:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="4021" class="lh li iq ld b gy lj lk l ll lm">var item = await pipeline;</span></pre><p id="7c9e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这一行将让管道执行每一个进入它的操作。如果在任何一个被组合的方法中抛出任何异常，它也会爆炸，所以一定要记住这一点。</p><p id="02bd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意，当使用<em class="kw"> Select </em>和第一个<em class="kw"> SelectMany </em>方法(带一个参数的方法)时，在流水线执行过程中，只有一个值被传入传入委托。这是您在设计中可能需要考虑的问题。尽管允许一元合成的<em class="kw"> SelectMany </em>重载允许您在LINQ查询中使用任何<em class="kw">asynclazy pipeline&lt;t source&gt;</em>返回方法，不管它有多少个参数。</p><p id="0492" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后一句话；本文介绍的方法还可以为您提供很好的可重用性。asynclazy pipeline&lt;t source&gt;不仅允许您编写方法，还允许您编写<em class="kw">asynclazy pipeline&lt;t source&gt;实例。</em>这意味着您可以创建子管道，这些子管道可以根据您的意愿进行重用和组合，以形成更复杂的管道。</p><p id="d3c7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">编码快乐！</p></div></div>    
</body>
</html>