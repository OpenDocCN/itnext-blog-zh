<html>
<head>
<title>Dynamically Update Positions During Drag Using react-beautiful-dnd</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用react-beautiful-dnd在拖动过程中动态更新位置</h1>
<blockquote>原文：<a href="https://itnext.io/dynamically-update-positions-during-drag-using-react-beautiful-dnd-4a986d704c2e?source=collection_archive---------2-----------------------#2019-02-22">https://itnext.io/dynamically-update-positions-during-drag-using-react-beautiful-dnd-4a986d704c2e?source=collection_archive---------2-----------------------#2019-02-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><h1 id="683c" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">什么是react-beautiful-dnd？</h1><p id="72c0" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">react-beautiful-dnd是一个用于ReactJS的拖放库。它是超级强大的，给你一个开箱即用的可用性吨。你可以在这里阅读更多信息<a class="ae lm" href="https://github.com/atlassian/react-beautiful-dnd" rel="noopener ugc nofollow" target="_blank">。本文假设您对这个库有一个基本的了解，并且希望能够添加一些漂亮的修饰功能。在本例中，它在拖动动作期间动态显示项目的位置，如下所示！我们开始吧！</a></p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi ln"><img src="../Images/e83869de7fc3749aede422c283836f3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*OxQoi2_wPK_791hM37tR3Q.gif"/></div></div></figure><h1 id="3626" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">react-beautiful-dnd拖的时候到底在干嘛？</h1><p id="9b9b" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">首先，为了简单起见，从现在开始我将把react-beautiful-dnd称为dnd。</p><p id="0c86" class="pw-post-body-paragraph ko kp it kq b kr lz kt ku kv ma kx ky kz mb lb lc ld mc lf lg lh md lj lk ll im bi translated">至于dnd如何处理传递给它的数据，标准情况下，我们在这里使用的是一个DragDropContext组件，它有一个由Draggables数组填充的Droppable。例如，上述组件的代码如下:</p><pre class="lo lp lq lr gt me mf mg mh aw mi bi"><span id="337f" class="mj jr it mf b gy mk ml l mm mn">&lt;DragDropContext onDragEnd={this.onDragEnd}&gt;</span><span id="36be" class="mj jr it mf b gy mo ml l mm mn">  &lt;Droppable droppableId="droppable"&gt;</span><span id="5ba8" class="mj jr it mf b gy mo ml l mm mn">  {provided =&gt; (</span><span id="ad80" class="mj jr it mf b gy mo ml l mm mn">    &lt;div ref={provided.innerRef}&gt;</span><span id="0482" class="mj jr it mf b gy mo ml l mm mn">    {this.state.content.map((c, index) =&gt; (</span><span id="72a6" class="mj jr it mf b gy mo ml l mm mn">      &lt;Draggable key={c.id} draggableId={c.id} index={index}&gt;</span><span id="f510" class="mj jr it mf b gy mo ml l mm mn">      {(provided, snapshot) =&gt; (</span><span id="8fd5" class="mj jr it mf b gy mo ml l mm mn">       &lt;ContentWrapper</span><span id="4796" class="mj jr it mf b gy mo ml l mm mn">        ref={provided.innerRef}</span><span id="6a4d" class="mj jr it mf b gy mo ml l mm mn">        {...provided.draggableProps}</span><span id="a802" class="mj jr it mf b gy mo ml l mm mn">        {...provided.dragHandleProps}</span><span id="c8bf" class="mj jr it mf b gy mo ml l mm mn">       &gt;</span><span id="fc6c" class="mj jr it mf b gy mo ml l mm mn">        &lt;ContentBlock</span><span id="7453" class="mj jr it mf b gy mo ml l mm mn">         content={c}</span><span id="d1a8" class="mj jr it mf b gy mo ml l mm mn">         displayPosition={index + 1}</span><span id="9149" class="mj jr it mf b gy mo ml l mm mn">        /&gt;</span><span id="1b6e" class="mj jr it mf b gy mo ml l mm mn">      &lt;/ContentWrapper&gt;</span><span id="d63e" class="mj jr it mf b gy mo ml l mm mn">     )}</span><span id="5538" class="mj jr it mf b gy mo ml l mm mn">    &lt;/Draggable&gt;</span><span id="f576" class="mj jr it mf b gy mo ml l mm mn">   ))}</span><span id="a566" class="mj jr it mf b gy mo ml l mm mn">  &lt;/ContentWrapper&gt;</span><span id="c1fa" class="mj jr it mf b gy mo ml l mm mn">  )}</span><span id="b8ec" class="mj jr it mf b gy mo ml l mm mn">  &lt;/Droppable&gt;</span><span id="407e" class="mj jr it mf b gy mo ml l mm mn">&lt;/DragDropContext&gt;</span></pre><p id="8fb6" class="pw-post-body-paragraph ko kp it kq b kr lz kt ku kv ma kx ky kz mb lb lc ld mc lf lg lh md lj lk ll im bi translated">** <code class="fe mp mq mr mf b">ContentWrapper</code>和<code class="fe mp mq mr mf b">ContentBlock</code>都是<a class="ae lm" href="https://github.com/styled-components/styled-components" rel="noopener ugc nofollow" target="_blank">样式化的组件</a>，为本文中的示例提供了美学外观。他们俩只是一个风格的<code class="fe mp mq mr mf b">div</code></p><p id="4bc0" class="pw-post-body-paragraph ko kp it kq b kr lz kt ku kv ma kx ky kz mb lb lc ld mc lf lg lh md lj lk ll im bi translated"><code class="fe mp mq mr mf b">displayPosition</code>这里只是该项在数组+ 1中的索引，所以对于数组<code class="fe mp mq mr mf b">[A, B, C]</code>来说，各自的显示位置是<code class="fe mp mq mr mf b">A: 1, B: 2, C: 3</code></p><p id="da19" class="pw-post-body-paragraph ko kp it kq b kr lz kt ku kv ma kx ky kz mb lb lc ld mc lf lg lh md lj lk ll im bi translated">我们使用<code class="fe mp mq mr mf b">this.state.content</code>作为我们的数据数组。当您拖动时，dnd会更新数组的顺序以反映这些更改。为了保存，您需要做的就是在<code class="fe mp mq mr mf b">&lt;DragDropContext&gt;</code>上挂接<code class="fe mp mq mr mf b">onDragEnd</code>事件并更新状态。类似于:</p><pre class="lo lp lq lr gt me mf mg mh aw mi bi"><span id="1056" class="mj jr it mf b gy mk ml l mm mn">onDragEnd = result =&gt; {</span><span id="9c83" class="mj jr it mf b gy mo ml l mm mn">  if (!result.destination) {</span><span id="20e5" class="mj jr it mf b gy mo ml l mm mn">    return</span><span id="11d6" class="mj jr it mf b gy mo ml l mm mn">  }</span><span id="2afa" class="mj jr it mf b gy mo ml l mm mn">  const content = reorder(this.state.content, result.source.index,   result.destination.index)</span><span id="16fe" class="mj jr it mf b gy mo ml l mm mn">  this.setState({ content })</span><span id="179a" class="mj jr it mf b gy mo ml l mm mn">}</span></pre><p id="efbc" class="pw-post-body-paragraph ko kp it kq b kr lz kt ku kv ma kx ky kz mb lb lc ld mc lf lg lh md lj lk ll im bi translated">太好了！这是一个函数，它根据一个元素的移动来改变一个数组。这是函数:</p><pre class="lo lp lq lr gt me mf mg mh aw mi bi"><span id="3439" class="mj jr it mf b gy mk ml l mm mn">const reorder = (list, startIndex, endIndex) =&gt; {</span><span id="1d9d" class="mj jr it mf b gy mo ml l mm mn">  const result = Array.from(list)</span><span id="a545" class="mj jr it mf b gy mo ml l mm mn">  const [removed] = result.splice(startIndex, 1)</span><span id="a856" class="mj jr it mf b gy mo ml l mm mn">  result.splice(endIndex, 0, removed)</span><span id="56e1" class="mj jr it mf b gy mo ml l mm mn">  return result</span><span id="f44f" class="mj jr it mf b gy mo ml l mm mn">}</span></pre><p id="b738" class="pw-post-body-paragraph ko kp it kq b kr lz kt ku kv ma kx ky kz mb lb lc ld mc lf lg lh md lj lk ll im bi translated">好了，这是一大堆连续的代码，让我们绕回来。当我们拖动时，只有这些而没有更新，我们在这里会有什么？</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi ms"><img src="../Images/aad2f28ad2d628b9ead283ad4cd93e4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*nNqIfszJCBW0DjMf65biqg.gif"/></div></div></figure><p id="d712" class="pw-post-body-paragraph ko kp it kq b kr lz kt ku kv ma kx ky kz mb lb lc ld mc lf lg lh md lj lk ll im bi translated">厉害！拖动结束后，我们调用<code class="fe mp mq mr mf b">onDragEnd</code>，它又调用<code class="fe mp mq mr mf b">reorder</code>。Reorder将根据拖动的结果改变我们的数组，瞧！我们完成拖动，数组被重新排序，我们把它提交给state。决定<code class="fe mp mq mr mf b">displayPosition</code>在重新渲染时更新的索引。</p><p id="a06c" class="pw-post-body-paragraph ko kp it kq b kr lz kt ku kv ma kx ky kz mb lb lc ld mc lf lg lh md lj lk ll im bi translated">因此，要在拖动时让它工作，我们所要做的就是添加与<code class="fe mp mq mr mf b">onDragEnd</code>完全相同的函数，并在<code class="fe mp mq mr mf b">onDragUpdate</code>事件上调用它，对吗？让我们将<code class="fe mp mq mr mf b">onDragEnd</code>重新命名为<code class="fe mp mq mr mf b">onDrag</code>，这样更具包容性，并将其添加到:</p><pre class="lo lp lq lr gt me mf mg mh aw mi bi"><span id="d869" class="mj jr it mf b gy mk ml l mm mn">&lt;DragDropContext onDragUpdate={this.onDrag} onDragEnd={this.onDrag}&gt;</span></pre><p id="65b1" class="pw-post-body-paragraph ko kp it kq b kr lz kt ku kv ma kx ky kz mb lb lc ld mc lf lg lh md lj lk ll im bi translated">太好了，让我们看看实际情况:</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi ln"><img src="../Images/07c13b88f2bf9cc6dc454a2967acf1b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*DKAeF4fg4-b9Vw4_94C6IQ.gif"/></div></div></figure><p id="7def" class="pw-post-body-paragraph ko kp it kq b kr lz kt ku kv ma kx ky kz mb lb lc ld mc lf lg lh md lj lk ll im bi translated">哇哦。到底发生了什么事？？基本上，你的数组在两个地方被修改(从dnd和从你的<code class="fe mp mq mr mf b">onDrag</code>中的<code class="fe mp mq mr mf b">setState</code>)，在状态改变时被重新渲染，尽管已经在拖动动作中，这些都产生了一些相当不可靠的副作用。最重要的是，当我们完成时，数字甚至不正确。那么我们该如何应对呢？</p><h1 id="1bb7" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">分离拖动处理程序</h1><p id="af3e" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">首先，让我们把我们的<code class="fe mp mq mr mf b">onDrag</code>函数恢复成<code class="fe mp mq mr mf b">onDragEnd</code>函数，我们就恢复了原来的功能。让我们也创建一个新的<code class="fe mp mq mr mf b">onDragUpdate</code>函数，我们暂时将它留空。</p><h1 id="80fa" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">将displayPosition添加为单独的属性</h1><p id="a3ce" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">从index中导出<code class="fe mp mq mr mf b">displayPosition</code>工作得很好，但是问题是我们在拖动过程中不断地重新计算。让我们把它从渲染中提取出来，放到每一项内容的一个新键中。</p><pre class="lo lp lq lr gt me mf mg mh aw mi bi"><span id="688d" class="mj jr it mf b gy mk ml l mm mn">const resetDisplayPositions = list =&gt; {</span><span id="2075" class="mj jr it mf b gy mo ml l mm mn">  const resetList = list.map((c, index) =&gt; {</span><span id="d503" class="mj jr it mf b gy mo ml l mm mn">    const slide = c</span><span id="bfb6" class="mj jr it mf b gy mo ml l mm mn">    slide.displayPosition = index + 1</span><span id="420a" class="mj jr it mf b gy mo ml l mm mn">    return slide</span><span id="46df" class="mj jr it mf b gy mo ml l mm mn">  })</span><span id="5271" class="mj jr it mf b gy mo ml l mm mn">  return resetList</span><span id="97de" class="mj jr it mf b gy mo ml l mm mn">}</span></pre><p id="a47a" class="pw-post-body-paragraph ko kp it kq b kr lz kt ku kv ma kx ky kz mb lb lc ld mc lf lg lh md lj lk ll im bi translated">这是在数组中的每一项上创建一个<code class="fe mp mq mr mf b">displayPosition</code>键，对应的值为<code class="fe mp mq mr mf b">index + 1</code>。如果我们在初始化时运行它，我们就可以一直拥有这个密钥:</p><pre class="lo lp lq lr gt me mf mg mh aw mi bi"><span id="b0e7" class="mj jr it mf b gy mk ml l mm mn">getContent = () =&gt; resetDisplayPositions(this.props.content)</span><span id="a7e8" class="mj jr it mf b gy mo ml l mm mn">constructor(props) {</span><span id="e4cb" class="mj jr it mf b gy mo ml l mm mn">  super(props)</span><span id="68bb" class="mj jr it mf b gy mo ml l mm mn">  this.state = {</span><span id="2413" class="mj jr it mf b gy mo ml l mm mn">    content: this.getContent(),</span><span id="72b8" class="mj jr it mf b gy mo ml l mm mn">  }</span><span id="d624" class="mj jr it mf b gy mo ml l mm mn">}</span></pre><p id="d0e5" class="pw-post-body-paragraph ko kp it kq b kr lz kt ku kv ma kx ky kz mb lb lc ld mc lf lg lh md lj lk ll im bi translated">好了，我们已经把它提取出来了，但是现在它只在组件初始化的时候被调用，而我们需要在每次重新排序的时候更新它们。所以我们只需要在<code class="fe mp mq mr mf b">reorder()</code>中添加一个调用</p><pre class="lo lp lq lr gt me mf mg mh aw mi bi"><span id="4cc1" class="mj jr it mf b gy mk ml l mm mn">const reorder = (list, startIndex, endIndex) =&gt; {</span><span id="26a5" class="mj jr it mf b gy mo ml l mm mn">  const result = Array.from(list)</span><span id="cc9f" class="mj jr it mf b gy mo ml l mm mn">  const [removed] = result.splice(startIndex, 1)</span><span id="339d" class="mj jr it mf b gy mo ml l mm mn">  result.splice(endIndex, 0, removed)</span><span id="99ba" class="mj jr it mf b gy mo ml l mm mn">  return resetDisplayPositions(result)</span><span id="98a2" class="mj jr it mf b gy mo ml l mm mn">}</span></pre><p id="b34b" class="pw-post-body-paragraph ko kp it kq b kr lz kt ku kv ma kx ky kz mb lb lc ld mc lf lg lh md lj lk ll im bi translated">好了，我们完全回到了原来的功能，我们已经提取了<code class="fe mp mq mr mf b">displayPosition</code>。让我们转到<code class="fe mp mq mr mf b">onDragUpdate</code></p><h1 id="8f62" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">onDragUpdate</h1><p id="44f4" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">好的，我们知道我们想要更新<code class="fe mp mq mr mf b">displayPosition</code>，但是在我们更新的时候不更新数组的底层顺序(一旦拖动完成，我们将调用<code class="fe mp mq mr mf b">reorder()</code>)。每当被拖动的项目改变位置时，就会触发<code class="fe mp mq mr mf b">onDragUpdate</code>,所以让我们想一想当这种情况发生时我们需要改变什么:</p><ul class=""><li id="b69b" class="mt mu it kq b kr lz kv ma kz mv ld mw lh mx ll my mz na nb bi translated">被拖动项目的<code class="fe mp mq mr mf b">displayPosition</code>需要改变</li><li id="09bd" class="mt mu it kq b kr nc kv nd kz ne ld nf lh ng ll my mz na nb bi translated">被拖动项目传递的项目也需要其<code class="fe mp mq mr mf b">displayPosition</code>改变</li></ul><p id="61ff" class="pw-post-body-paragraph ko kp it kq b kr lz kt ku kv ma kx ky kz mb lb lc ld mc lf lg lh md lj lk ll im bi translated">太好了！我们开始吧。让我们从基础开始，处理结果中是否缺少目的地:</p><pre class="lo lp lq lr gt me mf mg mh aw mi bi"><span id="059a" class="mj jr it mf b gy mk ml l mm mn">onDragUpdate = result =&gt; {</span><span id="f2a4" class="mj jr it mf b gy mo ml l mm mn">  if (!result.destination) return</span><span id="66fd" class="mj jr it mf b gy mo ml l mm mn">  const { content } = this.state</span><span id="7e9c" class="mj jr it mf b gy mo ml l mm mn">  const dragged = content[result.source.index]</span><span id="262e" class="mj jr it mf b gy mo ml l mm mn">  const previousDraggedIndex = dragged.displayPosition</span></pre><p id="74e2" class="pw-post-body-paragraph ko kp it kq b kr lz kt ku kv ma kx ky kz mb lb lc ld mc lf lg lh md lj lk ll im bi translated">酷，现在让我们将拖动项的<code class="fe mp mq mr mf b">displayPosition</code>设置为新的索引。</p><pre class="lo lp lq lr gt me mf mg mh aw mi bi"><span id="b016" class="mj jr it mf b gy mk ml l mm mn">dragged.displayPosition = result.destination.index + 1</span></pre><p id="aee0" class="pw-post-body-paragraph ko kp it kq b kr lz kt ku kv ma kx ky kz mb lb lc ld mc lf lg lh md lj lk ll im bi translated">半路上！现在让我们改变被跳过的项目。有一个地方有点棘手，那就是方向取决于拖动的方向，所以让我们取出索引差来得到1或-1。这总是绝对值为1，因为每次更新时都会调用它。</p><pre class="lo lp lq lr gt me mf mg mh aw mi bi"><span id="50d8" class="mj jr it mf b gy mk ml l mm mn">const draggedIndexDifference = dragged.displayPosition - previousDraggedIndex</span></pre><p id="b8a6" class="pw-post-body-paragraph ko kp it kq b kr lz kt ku kv ma kx ky kz mb lb lc ld mc lf lg lh md lj lk ll im bi translated">好了，现在剩下唯一要做的就是遍历数组，更改受影响的幻灯片并更新状态！</p><pre class="lo lp lq lr gt me mf mg mh aw mi bi"><span id="32f3" class="mj jr it mf b gy mk ml l mm mn">const updatedContent = content.map((c, index) =&gt; {</span><span id="50aa" class="mj jr it mf b gy mo ml l mm mn">  const slide = c</span><span id="7579" class="mj jr it mf b gy mo ml l mm mn">  if (slide.displayPosition === result.destination.index + 1 &amp;&amp; index !== result.source.index) {</span><span id="5999" class="mj jr it mf b gy mo ml l mm mn">    slide.displayPosition -= draggedIndexDifference</span><span id="9e19" class="mj jr it mf b gy mo ml l mm mn">  }</span><span id="e690" class="mj jr it mf b gy mo ml l mm mn">  return slide</span><span id="76c9" class="mj jr it mf b gy mo ml l mm mn">})</span></pre><p id="5e45" class="pw-post-body-paragraph ko kp it kq b kr lz kt ku kv ma kx ky kz mb lb lc ld mc lf lg lh md lj lk ll im bi translated">这里只有一张幻灯片受到影响，因为我们在这里检查两件事:</p><ul class=""><li id="20f6" class="mt mu it kq b kr lz kv ma kz mv ld mw lh mx ll my mz na nb bi translated">如果幻灯片的<code class="fe mp mq mr mf b">displayPosition</code>是被拖动的幻灯片所在的位置(这样我们就可以把范围缩小到被拖动和受影响的幻灯片)</li><li id="4ce8" class="mt mu it kq b kr nc kv nd kz ne ld nf lh ng ll my mz na nb bi translated">如果一个幻灯片不是被拖动的幻灯片，我们只剩下受影响的幻灯片为被拖动的幻灯片让路</li></ul><p id="d602" class="pw-post-body-paragraph ko kp it kq b kr lz kt ku kv ma kx ky kz mb lb lc ld mc lf lg lh md lj lk ll im bi translated">如果阻力向上，该幻灯片的新<code class="fe mp mq mr mf b">displayPosition</code>增加1，反之，如果阻力向下，则增加1。我们剩下的就是重置状态(记住，数组的顺序没有改变，只是相关的displayPositions没有改变)。这是该函数的最终版本:</p><pre class="lo lp lq lr gt me mf mg mh aw mi bi"><span id="95b1" class="mj jr it mf b gy mk ml l mm mn">onDragUpdate = result =&gt; {</span><span id="b354" class="mj jr it mf b gy mo ml l mm mn">  if (!result.destination) {</span><span id="ba24" class="mj jr it mf b gy mo ml l mm mn">    return</span><span id="3ce2" class="mj jr it mf b gy mo ml l mm mn">  }</span><span id="d284" class="mj jr it mf b gy mo ml l mm mn">  const { content } = this.state</span><span id="ba8b" class="mj jr it mf b gy mo ml l mm mn">  const dragged = content[result.source.index]</span><span id="07e3" class="mj jr it mf b gy mo ml l mm mn">  const previousDraggedIndex = dragged.displayPosition</span><span id="4791" class="mj jr it mf b gy mo ml l mm mn">  dragged.displayPosition = result.destination.index + 1</span><span id="888e" class="mj jr it mf b gy mo ml l mm mn">  const draggedIndexDifference = dragged.displayPosition - previousDraggedIndex</span><span id="9ab9" class="mj jr it mf b gy mo ml l mm mn">  const updatedContent = content.map((c, index) =&gt; {</span><span id="9baf" class="mj jr it mf b gy mo ml l mm mn">    const slide = c</span><span id="72c3" class="mj jr it mf b gy mo ml l mm mn">    if (slide.displayPosition === result.destination.index + 1 &amp;&amp; index !== result.source.index) {</span><span id="f13f" class="mj jr it mf b gy mo ml l mm mn">      slide.displayPosition -= draggedIndexDifference</span><span id="a931" class="mj jr it mf b gy mo ml l mm mn">    }</span><span id="04a7" class="mj jr it mf b gy mo ml l mm mn">    return slide</span><span id="070e" class="mj jr it mf b gy mo ml l mm mn">  })</span><span id="0d44" class="mj jr it mf b gy mo ml l mm mn">  this.setState({</span><span id="ff48" class="mj jr it mf b gy mo ml l mm mn">    content: updatedContent,</span><span id="4c3b" class="mj jr it mf b gy mo ml l mm mn">  })</span><span id="3e39" class="mj jr it mf b gy mo ml l mm mn">}</span></pre><p id="74d7" class="pw-post-body-paragraph ko kp it kq b kr lz kt ku kv ma kx ky kz mb lb lc ld mc lf lg lh md lj lk ll im bi translated">这给了我们顶部的全功能风格！</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi ln"><img src="../Images/e83869de7fc3749aede422c283836f3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*OxQoi2_wPK_791hM37tR3Q.gif"/></div></div></figure><h1 id="3d4c" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">概述</h1><p id="cc3e" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">所以让我们用简单的英语快速回顾一下这里发生的事情的步骤(你有上面所有的代码！)</p><ul class=""><li id="3e08" class="mt mu it kq b kr lz kv ma kz mv ld mw lh mx ll my mz na nb bi translated">在初始渲染一个对象数组时，一个<code class="fe mp mq mr mf b">displayPosition</code>的键被放在每个值为<code class="fe mp mq mr mf b">index + 1</code>的对象上</li><li id="7f8b" class="mt mu it kq b kr nc kv nd kz ne ld nf lh ng ll my mz na nb bi translated">那个<code class="fe mp mq mr mf b">displayPosition</code>用来显示一个项目在数组中的位置</li><li id="9770" class="mt mu it kq b kr nc kv nd kz ne ld nf lh ng ll my mz na nb bi translated">拖动时，<code class="fe mp mq mr mf b">displayPosition</code>在<code class="fe mp mq mr mf b">onDragUpdate</code>事件期间更新</li><li id="95e7" class="mt mu it kq b kr nc kv nd kz ne ld nf lh ng ll my mz na nb bi translated">当拖动完成时，整个数组在<code class="fe mp mq mr mf b">onDragEnd</code>事件期间被重新排序</li><li id="1ffb" class="mt mu it kq b kr nc kv nd kz ne ld nf lh ng ll my mz na nb bi translated">在<code class="fe mp mq mr mf b">reorder</code>期间，显示位置被重置为索引+ 1</li></ul><p id="f146" class="pw-post-body-paragraph ko kp it kq b kr lz kt ku kv ma kx ky kz mb lb lc ld mc lf lg lh md lj lk ll im bi translated">就是这样！希望你发现这是有益的和快乐的拖动！</p></div></div>    
</body>
</html>