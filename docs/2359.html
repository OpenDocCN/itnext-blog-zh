<html>
<head>
<title>Building a Blazor Wizard with Razor components.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Razor组件构建Blazor向导。</h1>
<blockquote>原文：<a href="https://itnext.io/building-a-blazor-wizard-with-razor-components-23d652ff06e9?source=collection_archive---------0-----------------------#2019-05-11">https://itnext.io/building-a-blazor-wizard-with-razor-components-23d652ff06e9?source=collection_archive---------0-----------------------#2019-05-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="908a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本文中，我们将使用Razor组件为Blazor构建一个向导。我的文章的重点是客户端Blazor和MVVM，但这篇文章是专门关于Razor组件和向导，我们应该可以在任何Blazor应用程序中使用。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/8686cfd665f32462b6a7ba17426b12e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K-wx9Fsh2nXJ6qAiXqz3KA.png"/></div></div></figure><p id="346a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本文的源代码是针对。网芯3预览版4。预览版5于上周发布，但没有重大变化，如果需要，应该很容易更新到预览版5。所有文章和源代码可能会再次更新。网芯3预览版6发布。本文起点的源代码位于我在GitHub上的BlazorMVVM存储库中。</p><div class="kx ky gp gr kz la"><a href="https://github.com/lchendricks/BlazorMVVM" rel="noopener  ugc nofollow" target="_blank"><div class="lb ab fo"><div class="lc ab ld cl cj le"><h2 class="bd ir gy z fp lf fr fs lg fu fw ip bi translated">lchendrick s/blazormvm</h2><div class="lh l"><h3 class="bd b gy z fp lf fr fs lg fu fw dk translated">一个客户端Blazor MVVM实现。通过在…上创建帐户，为lchendricks/BlazorMVVM的开发做出贡献</h3></div><div class="li l"><p class="bd b dl z fp lf fr fs lg fu fw dk translated">github.com</p></div></div><div class="lj l"><div class="lk l ll lm ln lj lo kv la"/></div></div></a></div><p id="2f8d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本文的起点是ArticleSeven分支或4.7版本。本文的最终代码将作为article分支和4.8版本提交。</p><p id="17d2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您想阅读我们构建模型和视图模型的前一篇文章，然后在视图中手动构建向导，可以通过以下链接阅读:</p><div class="kx ky gp gr kz la"><a rel="noopener  ugc nofollow" target="_blank" href="/building-a-wizard-in-blazor-with-components-and-mvvm-96219a7b221c"><div class="lb ab fo"><div class="lc ab ld cl cj le"><h2 class="bd ir gy z fp lf fr fs lg fu fw ip bi translated">用组件和MVVM在Blazor中构建向导。</h2><div class="lh l"><h3 class="bd b gy z fp lf fr fs lg fu fw dk translated">这是关于在客户端Blazor中实现MVVM的一种方法的系列文章中的第七篇。如果你愿意…</h3></div><div class="li l"><p class="bd b dl z fp lf fr fs lg fu fw dk translated">itnext.io</p></div></div><div class="lj l"><div class="lp l ll lm ln lj lo kv la"/></div></div></a></div><p id="1230" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">今天，我们将使用一个由可重用的Razor组件构建的向导来替换视图中的大部分内容。除了重命名视图模型中的一个字段之外，不会对模型和视图模型进行任何更改。我们将重构视图，使我们的向导完全由Razor组件标签构建。</p><h1 id="11c0" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">为什么要使用组件？</h1><p id="0115" class="pw-post-body-paragraph jn jo iq jp b jq mo js jt ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated">首先要问的问题是，我们为什么要这样做？为了了解我们将要做的事情，让我们看一下使用Telerik datagrid所需的标记:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="ae97" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这六行标记允许开发人员利用Telerik在他们的数据网格上所做的所有工作，而不需要任何关于网格如何在幕后工作的知识。它还可以很容易地看出数据源是什么，以及网格将显示两列以及这两列是什么。所以使用组件的好处是双重的:</p><ol class=""><li id="b4df" class="mv mw iq jp b jq jr ju jv jy mx kc my kg mz kk na nb nc nd bi translated">我们可以将代码封装成一个可重用的组件，通过标记可以很容易地访问它。</li><li id="e4a0" class="mv mw iq jp b jq ne ju nf jy ng kc nh kg ni kk na nb nc nd bi translated">通过有意义的嵌套标签和绑定，我们的标记变得更容易阅读。</li></ol><p id="a836" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们回顾一下我们在上一篇文章中构建的向导，它大约有143行代码，包括进度条。这些行中有许多是重复了8次的完全相同的标记行；向导的每个步骤一次。如果我们能够正确地将向导封装到嵌套的组件中，我们将会有更少的代码行，我们的视图将会更具可读性。</p><h1 id="2108" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">启动向导</h1><p id="c341" class="pw-post-body-paragraph jn jo iq jp b jq mo js jt ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated">首先，我们需要决定如何将向导的各个部分组合在一起。在我们的起点，向导上方有一个进度条，向导本身是一个<code class="fe nj nk nl nm b">switch()</code>语句，它封装了组成向导的8张卡片。每张卡片都包含一个控件，用于接收用户的输入。我们今天的目标是提出一个嵌套组件方案，它将复制所有这些，同时最大限度地减少重复标记，并仍然保持相同的功能。我们想出的组件的结构最终会是这样的:</p><pre class="km kn ko kp gt nn nm no np aw nq bi"><span id="afdc" class="nr lr iq nm b gy ns nt l nu nv">&lt;Wizard&gt;<br/>   &lt;InputCard&gt;<br/>      &lt;InputControl/&gt;<br/>   &lt;/InputCard&gt;<br/>&lt;Wizard&gt;</span></pre><p id="d495" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们已经有了在上一篇文章中使用的输入控件、单选按钮列表和数字输入。这意味着我们应该能够构建一个向导组件和一个输入卡组件，并使一切正常工作。</p><p id="3f66" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在Components文件夹中创建一个新的Razor视图，并将其命名为Wizard.Razor。我们将进度条放入该控件中，并将previous和next按钮从卡片中移出并放入该控件中。这两个元素的代码与我们现有视图中的几乎相同，只是我们需要删除对ViewModel的所有引用。我们希望能够在任何地方使用这个组件，所以我们不能指望有一个包含我们需要的所有字段的视图模型，每个需要的字段都将作为参数传入。我们的向导组件的开始看起来像这样:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="cd58" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这种标记很容易理解。我们有一个进度条和两个按钮，并绑定所需的属性和事件来处理控件。这就引出了一个问题。一旦我们创建了输入卡，如何让它在向导中显示出来呢？</p><h1 id="6f8f" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">子内容和RenderFragment</h1><p id="cbc0" class="pw-post-body-paragraph jn jo iq jp b jq mo js jt ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated">如果我们希望一些标记或另一个组件作为我们正在构建的组件的一部分被嵌套，那么编写一些标记来做到这一点是很容易的。</p><pre class="km kn ko kp gt nn nm no np aw nq bi"><span id="ffb8" class="nr lr iq nm b gy ns nt l nu nv">&lt;OurComponent&gt;<br/>   &lt;SomeNestedComponent /&gt;<br/>   This is plain text but it is nested content too!<br/>&lt;/OurComponent&gt;</span></pre><p id="5e21" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们需要的是在组件中为嵌套内容提供一个占位符，以及将该内容传递给组件的方法。Blazor通过一个名为ChildContent的特殊组件参数为我们提供了这种能力。我们嵌套在标记组件中的所有内容都被传递给ChildContent。为了使用这个参数，我们必须显式地声明它，并赋予它RenderFragment类型。如果我们将ChildContent添加到向导的进度条和按钮之间，我们的标记现在看起来像这样:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="9d30" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">ChildContent使用@ markup就像传递给组件的任何其他参数一样。所有标记就绪后，向导的输入参数如下所示:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="1cf0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们有3个变量，嵌套内容的RenderFragment和按钮点击的两个EventCallback委托。</p><h1 id="a37d" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">构建输入卡组件</h1><p id="a077" class="pw-post-body-paragraph jn jo iq jp b jq mo js jt ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated">现在我们可以在向导中嵌套内容了，让我们构建输入卡来嵌套内容。我们将不再使用<code class="fe nj nk nl nm b">switch</code>语句，所以我们将设计我们的输入卡，我们将它们都声明为向导的嵌套元素，但仅当它们是向导的活动步骤时才呈现。这意味着输入卡的整个标记将被包装在一个<code class="fe nj nk nl nm b">@if()</code>语句中。卡片的内容将与我们在标记中重复8次的卡片相同，只是有一些小的变化。首先，我们将用参数替换标题、标题和文本，这样每一步都可以将显示的内容传递给它。其次，我们已经从卡片上删除了按钮，因为它们现在是向导父控件的一部分。最后，我们将在卡中有一个ChildContent占位符，这样我们就可以使用标记将用户输入嵌套在卡中。</p><p id="5768" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">考虑到所有这些，在我们的组件文件夹中创建一个新的Razor视图，并将其命名为WizardInputCard.razor。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="3986" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">WizardStep作为在我们的视图中声明的卡片的实际步骤号传入。CurrentStep是从ViewModel传入的。当这两个值相等时，卡由客户端呈现。需要<code class="fe nj nk nl nm b">switch</code>语句的功能现在被封装到卡中。我们的输入卡也有一个RenderFragment参数，这样它可以显示绑定到ChildContent的嵌套内容。</p><h1 id="8ccb" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">构建新向导</h1><p id="9c62" class="pw-post-body-paragraph jn jo iq jp b jq mo js jt ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated">进入CvdRisk.razor，删除或注释掉<br/>(第9行)之后的所有内容。现在为向导添加标记，并将输入值绑定到ViewModel中的值。我们的视图现在看起来是这样的:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="1d89" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们现在启动应用程序并导航到计算器，我们将会看到一个空的进度条和两个禁用的导航按钮。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nw"><img src="../Images/1a81832fba571aac694669f4a144231e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nt1f5rs4PEdr5v8fZF6KOQ.png"/></div></div></figure><p id="e3e2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我们将在向导中嵌套一张卡片，然后在其中嵌套我们的用户输入。在我们的向导中添加以下嵌套标记:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="c9e9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里，我们向输入卡传递了四个静态输入，以及一个来自ViewModel的字段。这个字段过去被称为<code class="fe nj nk nl nm b">Step</code>，但是现在已经被重命名为<code class="fe nj nk nl nm b">CurrentStep</code>，以使代码更加清晰。众所周知，命名事物是很难的，这也是为什么我们可以在Visual Studio中右键单击rename。如果我们再次启动风险向导，我们现在可以看到我们的输入卡以及单选按钮列表。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nx"><img src="../Images/e1609a4061954a7b07d3d08c179dfc4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QIGjw6IYGHQtWl3qnLt81g.png"/></div></div></figure><p id="551d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以选择性别，甚至点击下一步。这使得我们的输入卡消失了，因为我们还没有声明第二步。</p><p id="1e15" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为我们已经有了一个完全正常工作的计算器，向导的其余部分只是重复添加7个WizardInputCard标签，只是改变我们传入的静态内容以及嵌套适当的控件。当我们拥有全部8张卡时，我们的视图现在看起来像这样:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="b531" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">视图的代码现在明显更短，可读性更好。我们还可以选择创建和切换不同的WizardInput组件，与我们的卡一起使用或代替我们的卡。</p><h1 id="0fec" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">包扎</h1><p id="3c54" class="pw-post-body-paragraph jn jo iq jp b jq mo js jt ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated">今天，我们使用可重复使用的剃须刀组件创建了一个Blazor向导。我们看到了这是如何消除冗余代码并使我们的标记更具可读性的。我们还看到了使用ChildContent和RenderFragment嵌套我们自己的组件是多么容易。如果你对这篇文章有任何问题或评论，你可以在Twitter上找到我。</p></div></div>    
</body>
</html>