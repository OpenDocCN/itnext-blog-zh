<html>
<head>
<title>How to optimize MongoDB &amp; Mongoose for Performance</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何优化MongoDB &amp; Mongoose的性能</h1>
<blockquote>原文：<a href="https://itnext.io/performance-tips-for-mongodb-mongoose-190732a5d382?source=collection_archive---------0-----------------------#2019-08-02">https://itnext.io/performance-tips-for-mongodb-mongoose-190732a5d382?source=collection_archive---------0-----------------------#2019-08-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="be60" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何让您的MongoDB/mongose查询更快？</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/0fec4747525482161331346cfd1fbc70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1054/format:webp/1*Ipg_guKJO2MwacQ_3amxGw.jpeg"/></div></figure><p id="4d6d" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">表演是避免不必要工作的艺术。这些是我关于优化MongoDB查询的发现，你可以滚动下面的性能测试和结果。</p><h2 id="283b" class="lj lk iq bd ll lm ln dn lo lp lq dp lr kw ls lt lu la lv lw lx le ly lz ma mb bi translated"><strong class="ak"> 1。对GET操作使用精益查询</strong></h2><p id="7220" class="pw-post-body-paragraph kn ko iq kp b kq mc jr ks kt md ju kv kw me ky kz la mf lc ld le mg lg lh li ij bi translated">这可能是提高查询性能的最佳方法。mongose允许您在查询末尾添加<code class="fe mh mi mj mk b">.lean()</code>,通过返回普通的JSON对象而不是mongose文档，极大地提高了查询的性能。</p><p id="2d0f" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">来自<a class="ae ml" href="https://mongoosejs.com/docs/tutorials/lean.html" rel="noopener ugc nofollow" target="_blank">猫鼬医生靠</a></p><blockquote class="mm mn mo"><p id="d151" class="kn ko mp kp b kq kr jr ks kt ku ju kv mq kx ky kz mr lb lc ld ms lf lg lh li ij bi translated">默认情况下，mongose查询返回一个<a class="ae ml" href="https://mongoosejs.com/docs/api.html#Document" rel="noopener ugc nofollow" target="_blank">mongose</a><code class="fe mh mi mj mk b"><a class="ae ml" href="https://mongoosejs.com/docs/api.html#Document" rel="noopener ugc nofollow" target="_blank">Document</a></code><a class="ae ml" href="https://mongoosejs.com/docs/api.html#Document" rel="noopener ugc nofollow" target="_blank">类</a>的实例。文档比普通的JavaScript对象要重得多，因为它们有许多内部状态用于变更跟踪。启用<code class="fe mh mi mj mk b">lean</code>选项告诉mongose跳过实例化一个完整的mongose文档，只给你POJO。</p><p id="7dd1" class="kn ko mp kp b kq kr jr ks kt ku ju kv mq kx ky kz mr lb lc ld ms lf lg lh li ij bi translated"><a class="ae ml" href="https://mongoosejs.com/docs/api.html#query_Query-lean" rel="noopener ugc nofollow" target="_blank">精益选项</a>告诉Mongoose跳过<a class="ae ml" href="https://mongoosejs.com/docs/api.html#model_Model.hydrate" rel="noopener ugc nofollow" target="_blank">补水</a>结果文档。这使得查询更快，占用的内存更少，但是结果文档是普通的旧JavaScript对象(POJOs)，<strong class="kp ir">而不是</strong><a class="ae ml" href="https://mongoosejs.com/docs/documents.html" rel="noopener ugc nofollow" target="_blank">mongose文档</a>。"</p></blockquote><p id="d4de" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">然而，这是有代价的，这意味着精益医生没有:</p><ul class=""><li id="fefa" class="mt mu iq kp b kq kr kt ku kw mv la mw le mx li my mz na nb bi translated">更改跟踪</li><li id="4fb3" class="mt mu iq kp b kq nc kt nd kw ne la nf le ng li my mz na nb bi translated">铸造和验证</li><li id="9171" class="mt mu iq kp b kq nc kt nd kw ne la nf le ng li my mz na nb bi translated">Getters和setters</li><li id="9ef9" class="mt mu iq kp b kq nc kt nd kw ne la nf le ng li my mz na nb bi translated">虚拟(包括“id”)</li><li id="cc39" class="mt mu iq kp b kq nc kt nd kw ne la nf le ng li my mz na nb bi translated"><code class="fe mh mi mj mk b">save()</code>功能</li></ul><p id="10c7" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">因此，对于不使用<code class="fe mh mi mj mk b">.save()</code>或virtuals的GET端点和<code class="fe mh mi mj mk b">.find()</code>操作来说，它通常是最佳的。</p><h2 id="846e" class="lj lk iq bd ll lm ln dn lo lp lq dp lr kw ls lt lu la lv lw lx le ly lz ma mb bi translated">2.为您的查询创建自定义索引</h2><p id="98f7" class="pw-post-body-paragraph kn ko iq kp b kq mc jr ks kt md ju kv kw me ky kz la mf lc ld le mg lg lh li ij bi translated">MongoDB允许您在模式中的其他属性上创建索引，而不是默认的“_id”索引。这样，您的文档就可以根据数据库中定义的属性进行索引，以便更快地访问。</p><p id="1388" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">您还可以创建多个属性的复合索引。如果您通过多个字段进行查询，这将非常有用。假设你有一些数据库，你想找到所有灭绝的动物，你可能会写这样的查询<code class="fe mh mi mj mk b">Model.find({type: “Animal”, status: “extinct"})</code></p><p id="be8c" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">MongoDB将不得不查看所有文档以找到符合这个标准的文档，为了优化这个查询，您可以通过添加<code class="fe mh mi mj mk b">ModelSchema.index({type: 1, status: 1})</code>为“type”和“status”创建一个复合索引。现在MongoDB将在哪里查看找到相关文档。</p><p id="6dbf" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">“1”或“-1”表示属性的排序顺序。字段添加到索引中的顺序很重要。关于指数的更详细的解释，见<a class="ae ml" href="https://mongoosejs.com/docs/guide.html#indexes" rel="noopener ugc nofollow" target="_blank">https://mongoosejs.com/docs/guide.html#indexes</a>和<a class="ae ml" href="https://docs.mongodb.com/manual/indexes/" rel="noopener ugc nofollow" target="_blank">https://docs.mongodb.com/manual/indexes/</a></p><h2 id="db26" class="lj lk iq bd ll lm ln dn lo lp lq dp lr kw ls lt lu la lv lw lx le ly lz ma mb bi translated">3.最小化数据库请求(避免。如果可能，填充()</h2><p id="7351" class="pw-post-body-paragraph kn ko iq kp b kq mc jr ks kt md ju kv kw me ky kz la mf lc ld le mg lg lh li ij bi translated">你做的请求越多，你的应用程序响应时间就越慢。尽可能减少数据库查询，将它们组合在一起，或者通过消除重复或不必要的数据库操作来完全避免它们。您还可以在redis 中缓存您的数据库结果。</p><p id="45f2" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">尝试以一种方式定义你的模式，这样你就不必太依赖于<code class="fe mh mi mj mk b">.populate()</code>和模型之间的双向关系。因为这是NoSQL数据库不太理想的地方。您在模型中添加的每个属性都将从查询中返回，因此，如果您在这些字段中有一个数组或嵌套对象，您的文档将很容易变大，从而降低查询的性能。</p><p id="e462" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">如果您的文档包含一组对其他模型的引用，并且您使用。populate()来连接集合之间的数据，使用<code class="fe mh mi mj mk b">.populate()</code>将需要运行额外的查询来获取数组中的实际文档，这类似于为每个文档的每个id运行额外的查询。如果真的有必要，最好选择使用<code class="fe mh mi mj mk b">.aggregate()</code>而不是<code class="fe mh mi mj mk b">.populate()</code>。</p><h2 id="8b16" class="lj lk iq bd ll lm ln dn lo lp lq dp lr kw ls lt lu la lv lw lx le ly lz ma mb bi translated">4.使用。选择()以选择要返回的特定属性</h2><p id="16da" class="pw-post-body-paragraph kn ko iq kp b kq mc jr ks kt md ju kv kw me ky kz la mf lc ld le mg lg lh li ij bi translated">当在数据库中查询文档时，查询将返回整个文档，但有时您的大型文档包含许多字段，并且字段是如上所述的数组/对象，您实际上不需要使用所有返回的属性。</p><p id="7f56" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">为了防止数据库做额外的工作来返回这些字段，增加返回文档的大小，您可以使用mongose<code class="fe mh mi mj mk b">.select()</code>来包含/排除您希望查询返回的字段，具体如下:</p><pre class="kg kh ki kj gt nh mk ni nj aw nk bi"><span id="e711" class="lj lk iq mk b gy nl nm l nn no">Model.find({type: "Animal"}).select({name: 1})</span></pre><p id="6131" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">Protip:如果您使用的是GraphQL，这种方法会非常有效，因此您可以确切地知道客户端请求了哪些字段，并可以从数据库中选择这些字段。我在这里写了另一篇关于这个的文章</p><div class="np nq gp gr nr ns"><a href="https://medium.com/faun/graphql-performance-tip-database-projection-82795e434b44" rel="noopener follow" target="_blank"><div class="nt ab fo"><div class="nu ab nv cl cj nw"><h2 class="bd ir gy z fp nx fr fs ny fu fw ip bi translated">Apollo GraphQL性能提示:从数据库中选择所有请求的字段</h2><div class="nz l"><h3 class="bd b gy z fp nx fr fs ny fu fw dk translated">当您知道客户的需求时，为什么要从数据库中取出一整行呢？</h3></div><div class="oa l"><p class="bd b dl z fp nx fr fs ny fu fw dk translated">medium.com</p></div></div><div class="ob l"><div class="oc l od oe of ob og kl ns"/></div></div></a></div><h2 id="2588" class="lj lk iq bd ll lm ln dn lo lp lq dp lr kw ls lt lu la lv lw lx le ly lz ma mb bi translated">5.并行运行数据库操作</h2><p id="596a" class="pw-post-body-paragraph kn ko iq kp b kq mc jr ks kt md ju kv kw me ky kz la mf lc ld le mg lg lh li ij bi translated">每当人们使用async/await时，我在NodeJS代码中看到的一个常见错误是，人们在不需要的时候一个接一个地运行操作。例如:</p><pre class="kg kh ki kj gt nh mk ni nj aw nk bi"><span id="a49b" class="lj lk iq mk b gy nl nm l nn no">const user = new User({name: "bob"})<br/>const post = new Post({title: "hello"})</span><span id="00d1" class="lj lk iq mk b gy oh nm l nn no">await user.save()<br/>await post.save()</span></pre><p id="e48e" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">没有理由要等到用户被保存后才保存帖子。相反，可以使用<code class="fe mh mi mj mk b">Promise.all</code>并行运行数据库操作，如下所示:</p><pre class="kg kh ki kj gt nh mk ni nj aw nk bi"><span id="5284" class="lj lk iq mk b gy nl nm l nn no">const [user, post] = await Promise.all([user.save(), post.save()])</span></pre><p id="b6e6" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">虽然这可能会提高api级别的性能，但我们仍然对数据库执行两个请求，所以如果您想批量执行多个操作，使用<code class="fe mh mi mj mk b">insertMany()</code>或<code class="fe mh mi mj mk b">bulkWrite()</code>会更好。</p><h2 id="cf6a" class="lj lk iq bd ll lm ln dn lo lp lq dp lr kw ls lt lu la lv lw lx le ly lz ma mb bi translated">6.缓存/重用mongoose连接</h2><p id="d24b" class="pw-post-body-paragraph kn ko iq kp b kq mc jr ks kt md ju kv kw me ky kz la mf lc ld le mg lg lh li ij bi translated">确保不要在每次想要从数据库中插入/查询某些内容时或者每次触发端点时都连接和断开数据库。相反，你应该在应用程序开始时连接一次，然后重复使用这个连接。</p><p id="95ef" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">这是因为建立一个新的TCP连接在时间、网络请求和内存方面都很昂贵，而且一个新的连接意味着MongoDB要使用数据库上的内存创建一个新的线程。</p></div><div class="ab cl oi oj hu ok" role="separator"><span class="ol bw bk om on oo"/><span class="ol bw bk om on oo"/><span class="ol bw bk om on"/></div><div class="ij ik il im in"><h1 id="8d12" class="op lk iq bd ll oq or os lo ot ou ov lr jw ow jx lu jz ox ka lx kc oy kd ma oz bi translated">让我们编写一些性能测试来看看结果</h1><p id="263f" class="pw-post-body-paragraph kn ko iq kp b kq mc jr ks kt md ju kv kw me ky kz la mf lc ld le mg lg lh li ij bi translated">这些技巧能在多大程度上提高您的查询性能？让我们通过编写一些脚本来测试这些差异。</p><p id="4eca" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我运行了MongoDB的本地安装，并编写了一个NodeJS脚本，该脚本使用由<a class="ae ml" href="https://github.com/boo1ean/casual" rel="noopener ugc nofollow" target="_blank"> casual </a>随机生成的用户列表填充数据库。目标是找到年龄超过22岁的用户。</p><p id="eea3" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我用不同的方式编写了这个查询，结合了上面提到的方法，并在两个不同的数据库集合上使用相同的数据集进行了测试。一个集合有“年龄”属性的索引，而另一个没有。使用<code class="fe mh mi mj mk b">console.time()</code> API测量结果，使用NodeJS (v12.7.0)和mongose(v 5 . 6 . 7)的最新版本运行测试。</p><p id="ab53" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">首先让我们从我们的模式开始，这里我定义了用户集合/模式，其中一个在age属性上有一个索引，而其他的没有。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="pb pc di pd bf pe"><div class="gh gi pa"><img src="../Images/3edf22d11e8941f53f948ae6ce515b20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VElBX7vztYrh2480Ux5LMw.png"/></div></div></figure><p id="b951" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">现在让我们编写一些代码，用随机数据填充数据库。我使用了<a class="ae ml" href="https://github.com/boo1ean/casual" rel="noopener ugc nofollow" target="_blank"> casual </a>库，它非常方便地生成语义模拟数据</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="pb pc di pd bf pe"><div class="gh gi pf"><img src="../Images/cb558febd4e0c8fa347e220edcedf8e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*66c9oPK6Dp_fRT8kebIF1g.png"/></div></div></figure><p id="14d9" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">现在数据库已经准备好了，让我们编写查询</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="pb pc di pd bf pe"><div class="gh gi pg"><img src="../Images/65a15a735563a3bf73ad1b8a6638f4e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tSRB1Be3MUY-BNA_HXvtvA.png"/></div></div></figure></div><div class="ab cl oi oj hu ok" role="separator"><span class="ol bw bk om on oo"/><span class="ol bw bk om on oo"/><span class="ol bw bk om on"/></div><div class="ij ik il im in"><h1 id="c0cf" class="op lk iq bd ll oq or os lo ot ou ov lr jw ow jx lu jz ox ka lx kc oy kd ma oz bi translated">绩效结果和观察</h1><p id="c510" class="pw-post-body-paragraph kn ko iq kp b kq mc jr ks kt md ju kv kw me ky kz la mf lc ld le mg lg lh li ij bi translated"><strong class="kp ir"> <em class="mp">拥有1k用户</em></strong><br/>default _ query:135.646 ms<br/>query _ With _ index:168.763 ms<br/>query _ With _ select:27.781 ms<br/>query _ With _ select _ index:55.686 ms<br/>lean _ query:7.191 ms<br/>lean _ With _ index:7.341 ms<br/>lean _ With _ select:</p><p id="b587" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><strong class="kp ir"> <em class="mp">数据库中有10k用户</em> </strong></p><p id="d8b4" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">default _ query:323.278 ms<br/>query _ with _ index:355.693 ms<br/>query _ with _ select:212.403 ms<br/>query _ with _ select _ index:183.736 ms<br/>lean _ query:92.935 ms<br/>lean _ with _ index:92.755 ms<br/>lean _ with _ select:36.175 ms<br/>lean _ select _ index</p><p id="2a0f" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><strong class="kp ir"> <em class="mp">拥有100K用户的数据库</em></strong><br/>default _ query:2425.857 ms<br/>query _ With _ index:2371.716 ms<br/>query _ With _ select:1580.393 ms<br/>query _ With _ select _ index:1583.015 ms<br/>lean _ query:858.839 ms<br/>lean _ With _ index:944</p><p id="8582" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">正如您所看到的，使用<code class="fe mh mi mj mk b">.lean()</code> <code class="fe mh mi mj mk b">.select()</code>和<code class="fe mh mi mj mk b">Schema.index({})</code>的优化版查询比默认查询快了大约10倍，这是一个巨大的胜利！</p><p id="8969" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><code class="fe mh mi mj mk b">.lean()</code>似乎对性能的影响最大，其次是<code class="fe mh mi mj mk b">.select()</code>，我的自定义索引在这种情况下没有帮助的原因是因为我的索引<a class="ae ml" href="https://docs.mongodb.com/manual/tutorial/create-queries-that-ensure-selectivity" rel="noopener ugc nofollow" target="_blank">不够有选择性</a>，因为它只减少了50%的扫描文档数量。</p><p id="cd63" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">你可以找到用于这些测试的脚本，你甚至可以在这里自己尝试一下<a class="ae ml" href="https://github.com/khaledosman/mongo-performance-expirements" rel="noopener ugc nofollow" target="_blank">https://github . com/Khaled Osman/mongo-performance-exp rements</a></p></div></div>    
</body>
</html>