<html>
<head>
<title>Optimize your docker containers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">优化您的docker容器</h1>
<blockquote>原文：<a href="https://itnext.io/optimize-your-docker-containers-6255545dfa54?source=collection_archive---------1-----------------------#2022-10-22">https://itnext.io/optimize-your-docker-containers-6255545dfa54?source=collection_archive---------1-----------------------#2022-10-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="b502" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可能已经构建容器很长时间了，在您以前的所有构建中，安全性和/或容器的大小并不是优先考虑的问题。但是如果你现在来到这里，你会优先考虑这些话题。</p><p id="dae1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我们可以首先关注容器大小，为此，我们在这里讨论几个选项。</p><p id="c65d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">-建立在最小的基础映像上。<br/> -使用多阶段构建。<br/> -用静态链接的应用程序创建容器。</p><h1 id="6cd0" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">建立在最小基础图像上</h1><p id="7e6f" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">而不是用ubuntu，debian等大图。，这可能是一个巨大的图像，我们可以使用一些替代方案，让我们从一个小得多的基础上开始。</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="1c1f" class="lx km iq lt b gy ly lz l ma mb">debian latest d91720f514f7 124MB<br/>ubuntu latest 216c552ea5ba 77.8MB</span><span id="e07f" class="lx km iq lt b gy mc lz l ma mb">alpine latest 9c6f07244728 5.54MB<br/>gcr.io/distroless/static-debian11 latest 561bdfb51245 2.35MB</span></pre><p id="e859" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">alpine和google distroless容器比ubuntu或debian小得多。</p><p id="6332" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在google distroless容器的例子中，唯一的问题是该容器的包管理，因为它没有任何包管理器，另一个“缺失”的东西是一个外壳。但是对于几个运行时，它们有大量的基本映像。</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="4ec0" class="lx km iq lt b gy ly lz l ma mb">gcr.io/distroless/static-debian11<br/>gcr.io/distroless/base-debian11<br/>gcr.io/distroless/cc-debian11<br/>gcr.io/distroless/python3-debian11<br/>gcr.io/distroless/java-base-debian11<br/>gcr.io/distroless/java11-debian11<br/>gcr.io/distroless/java17-debian11<br/>gcr.io/distroless/nodejs-debian11</span></pre><p id="e992" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">另一方面，Alpine是一个发行版容器。因此，它有一个包管理器和一个外壳，但它足够小，可以使用基本容器。</p><p id="e59a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们从一个简单的应用程序开始，你可以在这里看到应用程序<a class="ae md" href="https://github.com/highercomve/better-container-example" rel="noopener ugc nofollow" target="_blank">的源代码。默认情况下，应用程序将在端口5000中公开一个web应用程序，其中包含系统的一般信息。</a></p><p id="24f8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">！【】(<a class="ae md" href="https://cdn-images-1.medium.com/max/1024/1*qj4qPO7l7DVa22cekRCcHg.png" rel="noopener">https://cdn-images-1 . medium . com/max/1024/1 * QJ 4 qpo 7 l 7 dva 22 cekrcchg . png</a>)</p><p id="f8bc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们从构建这个容器的基本方式开始，会是这样的。</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="e189" class="lx km iq lt b gy ly lz l ma mb">FROM golang<br/>WORKDIR /app<br/>COPY . /app/<br/>RUN go mod download; \<br/>    CGO_ENABLED=0 go build -ldflags=”-s -w” -o bce -v .<br/>EXPOSE 5000<br/>ENTRYPOINT [“/app/bce”]</span></pre><p id="91e0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在此之后，我们可以使用以下命令来构建容器:</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="b44a" class="lx km iq lt b gy ly lz l ma mb">docker build -t highercomve/bce .</span></pre><p id="d04f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在此之后，我们将以1.02GB的容器大小结束。</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="9818" class="lx km iq lt b gy ly lz l ma mb">highercomve/bce latest 614d597dbfb5 4 seconds ago 1.02GB</span></pre><p id="fcc8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">听起来不太好。现在让我们将基础容器从<strong class="jp ir"> golang </strong>改为<strong class="jp ir"> golang:alpine </strong>。</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="2cc0" class="lx km iq lt b gy ly lz l ma mb">FROM golang:alpine<br/>WORKDIR /app<br/>COPY . /app/<br/>RUN go mod download; \<br/>    CGO_ENABLED=0 go build -ldflags=”-s -w” -o bce -v .<br/>EXPOSE 5000<br/>ENTRYPOINT [“/app/bce”]</span></pre><p id="0a75" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">只有这一点改变，我们现在只有375MB</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="309a" class="lx km iq lt b gy ly lz l ma mb">highercomve/bce latest 1fb5114c906e About a minute ago 375MB</span></pre><p id="5eeb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">同样的容器，同样的应用，少了很多空间。</p><h1 id="7e86" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">使用多阶段构建</h1><p id="83fc" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">现在，我们可以做的第二个优化是使用多阶段构建。为此，我们需要在FROM命令中标记stage的名称，然后我们使用另一个base作为容器的最终运行时。</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="5589" class="lx km iq lt b gy ly lz l ma mb">FROM golang:alpine as builder # FIRST STAGE<br/>WORKDIR /app<br/>COPY . /app/<br/>RUN go mod download; \<br/>    CGO_ENABLED=0 go build -ldflags=”-s -w” -o bce -v .</span><span id="8051" class="lx km iq lt b gy mc lz l ma mb">FROM gcr.io/distroless/static-debian11<br/>WORKDIR /app<br/>COPY — from=builder /app/bce /app/bce # IMPORT FROM THAT STAGE<br/>COPY static /app/static/<br/>COPY templates /app/templates/<br/>EXPOSE 5000<br/>ENTRYPOINT [“/app/bce”]</span></pre><p id="f038" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，在这个变化之后，我们可以看到差异将是巨大的，因为最终的图像大小只有8.73MB。</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="6b0b" class="lx km iq lt b gy ly lz l ma mb">highercomve/bce latest e68c3ebb73e8 About a minute ago 8.73MB</span></pre><h1 id="25c7" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">用静态链接的应用程序创建容器</h1><p id="cb90" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">您可以做的另一件事是使用链接的库构建应用程序，并使用临时基础容器。</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="8c70" class="lx km iq lt b gy ly lz l ma mb">FROM golang:alpine as builder<br/>WORKDIR /app<br/>COPY . /app/<br/>RUN go mod download; \<br/> CGO_ENABLED=0 go build -ldflags=”-s -w -extldflags=-static” -o bce -v .</span><span id="b1e6" class="lx km iq lt b gy mc lz l ma mb">FROM scratch<br/>WORKDIR /app<br/>COPY — from=builder /app/bce /app/bce<br/>COPY static /app/static/<br/>COPY templates /app/templates/<br/>EXPOSE 5000<br/>ENTRYPOINT [“/app/bce”]</span></pre><p id="0832" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">随着这一变化，我们将再减少2MB的大小</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="6cc6" class="lx km iq lt b gy ly lz l ma mb">highercomve/bce latest f32c277bf5a6 7 seconds ago 6.39MB</span></pre><p id="0b9b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，作为奖励，我们将添加如何使用这种技术来建立一个多拱建立容器。也许你有同样的应用，但是需要在arm或者riscv架构下运行。为此我们可以使用docker<a class="ae md" href="https://github.com/docker/buildx](https://github.com/docker/buildx)." rel="noopener ugc nofollow" target="_blank">https://github.com/docker/buildx</a>的buildx插件。</p><p id="f0d4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于同一个容器，我将使用两个由buildx注入的参数。</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="856c" class="lx km iq lt b gy ly lz l ma mb">ARG TARGETPLATFORM<br/>ARG BUILDPLATFORM</span></pre><p id="7740" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">并允许我们决定如何为golang配置环境变量。我将使用这个build.sh脚本将buildx注入的目标平台变量映射到用于构建的golang环境变量。</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="a27c" class="lx km iq lt b gy ly lz l ma mb">#!/bin/sh<br/>set -e</span><span id="7649" class="lx km iq lt b gy mc lz l ma mb">echo "Building for $TARGETPLATFORM" <br/>export CGO_ENABLED=0</span><span id="269d" class="lx km iq lt b gy mc lz l ma mb">case "$TARGETPLATFORM" in<br/> "linux/arm/v6"*)<br/>  export GOOS=linux GOARCH=arm GOARM=6<br/>  ;;<br/> "linux/arm/v7"*)<br/>  export GOOS=linux GOARCH=arm GOARM=7<br/>  ;;<br/> "linux/arm64"*)<br/>  export GOOS=linux GOARCH=arm64 GOARM=7<br/>  ;;<br/> "linux/386"*)<br/>  export GOOS=linux GOARCH=386<br/>  ;;<br/> "linux/amd64"*)<br/>  export GOOS=linux GOARCH=amd64<br/>  ;;<br/> "linux/mips"*)<br/>  export GOOS=linux GOARCH=mips<br/>  ;;<br/> "linux/mipsle"*)<br/>  export GOOS=linux GOARCH=mipsle<br/>  ;;<br/> "linux/mips64"*)<br/>  export GOOS=linux GOARCH=mips64<br/>  ;;<br/> "linux/mips64le"*)<br/>  export GOOS=linux GOARCH=mips64le<br/>  ;;<br/> "linux/riscv64"*)<br/>  export GOOS=linux GOARCH=riscv64<br/>  ;;<br/> *)<br/>  echo "Unknown machine type: $machine"<br/>  echo "Building using host architecture"<br/>esac</span><span id="b296" class="lx km iq lt b gy mc lz l ma mb">go mod download<br/>go build -ldflags="-s -w -extldflags=-static" -o bce -v .</span></pre><p id="085f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们需要确定一件事，编译过程需要在与构建容器的主机相同的架构中运行，否则，我们可能会因为仿真而损失性能。为此，我们可以使用docker文件上定义中<strong class="jp ir">的<strong class="jp ir">构建平台</strong>参数。</strong></p><p id="05f6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">类似这样的。</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="3546" class="lx km iq lt b gy ly lz l ma mb">FROM — platform=$BUILDPLATFORM golang:alpine as builder<br/>ARG TARGETPLATFORM<br/>ARG BUILDPLATFORM<br/>WORKDIR /app<br/>COPY . /app/<br/>RUN /app/build.sh</span><span id="908a" class="lx km iq lt b gy mc lz l ma mb">FROM scratch<br/>WORKDIR /app<br/>COPY — from=builder /app/bce /app/bce<br/>COPY static /app/static/<br/>COPY templates /app/templates/<br/>EXPOSE 5000<br/>ENTRYPOINT [“/app/bce”]</span></pre><p id="1680" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有了这个新的Dockerfile文件，我们可以使用buildx插件来构建容器。</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="71be" class="lx km iq lt b gy ly lz l ma mb">docker buildx build — platform linux/arm64 -t highercomve/bce — load .</span></pre><p id="7a02" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里我们为build命令引入3个新参数:</p><p id="bdc7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">- platform:在这里我们可以定义一个由几个架构的coma分隔的列表<br/> - load:这个参数配置docker buildx在构建过程完成后将映像加载到我们的本地docker环境。<br/> - push:这将在构建过程完成后将所有容器映像推送到docker hub。</p><p id="e120" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以在一个命令中构建几个平台，然后推送到docker hub。</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="8679" class="lx km iq lt b gy ly lz l ma mb">docker buildx build — platform linux/arm64,linux/amd64,linux/arm — push -t highercomve/bce .</span></pre><figure class="lo lp lq lr gt mf gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi me"><img src="../Images/227190b456cf2c59d7676daf39d35653.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qCs8HhPHH1tb0p635A78TA.png"/></div></div></figure><p id="7755" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Docker hub将支持具有多种架构的一个映像，当一些设备使用其中一种架构时，将毫无问题地获得正确的映像。</p><p id="1dd6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们想测试运行在一个不同于我们系统的架构上的容器，我们需要加载qemu二进制文件。</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="108e" class="lx km iq lt b gy ly lz l ma mb">docker run — rm — privileged multiarch/qemu-user-static — reset -p yes</span></pre><p id="a41e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后用我们喜欢的平台运行容器</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="b3d0" class="lx km iq lt b gy ly lz l ma mb">docker run -it -p 5000:5000 — platform linux/arm64 highercomve/bce</span></pre><p id="590b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这个例子中，网页的输出应该是这样的</p><figure class="lo lp lq lr gt mf gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi me"><img src="../Images/b91ee86d8622d533341a93757fcec8bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XJ6iWw0hrGMlNJuASVD5_w.png"/></div></div></figure><p id="fa69" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我希望这对你有用，并帮助你维护更优化的容器</p><p id="3e50" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">愿原力与你同在</p></div></div>    
</body>
</html>