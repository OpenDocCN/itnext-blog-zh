<html>
<head>
<title>How I exploited an arbitrary code execution vulnerability in fast-redact</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我如何利用快速修订中的任意代码执行漏洞</h1>
<blockquote>原文：<a href="https://itnext.io/how-i-exploited-a-remote-code-execution-vulnerability-in-fast-redact-9e69fa35572f?source=collection_archive---------1-----------------------#2018-05-29">https://itnext.io/how-i-exploited-a-remote-code-execution-vulnerability-in-fast-redact-9e69fa35572f?source=collection_archive---------1-----------------------#2018-05-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/10df1d60ca81da99646fcde45289e818.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*eRy7dUrdAbeKPjNa.jpg"/></div></div></figure><h1 id="2178" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">介绍</h1><p id="dad3" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">这是一个关于我如何在GitHub上的开源库<a class="ae lv" href="https://github.com/davidmarkclements/fast-redact" rel="noopener ugc nofollow" target="_blank">快速修订</a>的代码审查期间发现一个<em class="lu">不那么微不足道的</em> JavaScript代码注入，以及我如何将它变成一个完全有效的任意命令执行的故事。<em class="lu">并非无足轻重的</em>来自于这样一个事实，即注入的代码正在通过<a class="ae lv" href="https://nodejs.org/api/vm.html" rel="noopener ugc nofollow" target="_blank"> Node.js vm模块</a>创建的沙箱中进行评估。</p><h1 id="eef3" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">发现</h1><p id="eceb" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">修复前的源代码如下所示:</p><figure class="lw lx ly lz gt jr"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="5924" class="pw-post-body-paragraph kw kx iq ky b kz mc lb lc ld md lf lg lh me lj lk ll mf ln lo lp mg lr ls lt ij bi translated">如果使用该库的开发人员未经净化就传递用户输入，攻击者最终可以获得对“expr”变量的控制。</p><p id="789c" class="pw-post-body-paragraph kw kx iq ky b kz mc lb lc ld md lf lg lh me lj lk ll mf ln lo lp mg lr ls lt ij bi translated">这在存储库的<a class="ae lv" href="https://github.com/davidmarkclements/fast-redact/blob/master/readme.md" rel="noopener ugc nofollow" target="_blank"> README.md </a>文件中的<a class="ae lv" href="https://github.com/davidmarkclements/fast-redact/blob/master/readme.md#caveat" rel="noopener ugc nofollow" target="_blank">行181 </a>处有说明。(<em class="lu">原文如此！</em>)</p><blockquote class="mh mi mj"><p id="1f41" class="kw kx lu ky b kz mc lb lc ld md lf lg mk me lj lk ml mf ln lo mm mg lr ls lt ij bi translated">正如在方法中提到的，<code class="fe mn mo mp mq b">paths</code>数组输入在初始化时被动态编译成一个函数。虽然已经对<code class="fe mn mo mp mq b">paths</code>数组进行了严格的测试，以发现开发人员的任何错误，但是强烈建议不要让用户输入直接提供任何要编辑的路径。不能保证允许用户输入<code class="fe mn mo mp mq b">paths</code>不会暴露攻击媒介。</p></blockquote><h1 id="35e5" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">剥削</h1><p id="d17d" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我们可以看到,' expr '在字符串连接中被使用了两次。这允许简单的JavaScript代码注入，但是为了成功利用，我们需要:</p><ol class=""><li id="d94d" class="mr ms iq ky b kz mc ld md lh mt ll mu lp mv lt mw mx my mz bi translated"><strong class="ky ir">使注入起作用</strong>:这并不简单，因为同一个变量在代理上使用了点标记，并作为计算键的一部分。为了能够在不关心语法的情况下装载任意的负载，我们需要访问函数构造器。</li><li id="7aa7" class="mr ms iq ky b kz na ld nb lh nc ll nd lp ne lt mw mx my mz bi translated"><strong class="ky ir">逃离沙箱</strong>:为了逃离沙箱，我们需要能够要求一些有用的Node.js模块来触发任意命令的执行。` require '本身是不可用的，所以我们需要解决这个问题，以便产生进程。</li></ol><h1 id="ffcf" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">概念证明</h1><p id="7dc9" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">经过大约两个小时的研究，我发现了一些有趣的有效载荷。我们先来看如何求解1。第二。描述中引用。</p><ol class=""><li id="828f" class="mr ms iq ky b kz mc ld md lh mt ll mu lp mv lt mw mx my mz bi translated">这里的问题是，我们需要提供一个静态有效并最终在运行时部分有效的“expr”字符串，以便触发任意的JavaScript代码注入。这不是小事，因为我们需要同时提供点符号的有效标识符和计算的密钥，并且可能触发任意代码执行。如果我们打破常规，看看JavaScript语法提供了什么，我们可能会注意到我们可以使用` &amp;&amp; '操作符来注入有效的代码。现在我们意识到了这一点，我们可以提供一个有效的有效载荷，而不是点符号的有效标识符，并使用一个<a class="ae lv" href="https://developer.mozilla.org/en-US/docs/Glossary/IIFE" rel="noopener ugc nofollow" target="_blank">生命</a>来定义和调用一个函数。</li><li id="aa72" class="mr ms iq ky b kz na ld nb lh nc ll nd lp ne lt mw mx my mz bi translated">一旦我们实现了任意代码执行，我们就需要逃离沙箱。正如我们可以看到的，用户提供的代码正在新的上下文中进行评估，但没有“use strict”指令，因此“this”可用于沙箱内运行的代码。这将是我们的函数构造函数的关键，我们可以通过` this . constructor . constructor(" console . log(' OUCH ')")触发任意代码执行。现在，我们可以不受有效负载语法限制地执行任意代码，我们可以继续寻找一种方法来逃离沙盒上下文，它不提供“require”。为了实现任意命令的执行，我们将依赖于使用“binding”函数的全局“process”变量来要求内部模块，以便有一个工作的“spawnSync()”。这种技术的详细描述可以在这里找到:<a class="ae lv" href="https://capacitorset.github.io/mathjs/" rel="noopener ugc nofollow" target="_blank">我们如何利用math.js中的一个远程代码执行漏洞</a>。</li></ol><p id="f2b0" class="pw-post-body-paragraph kw kx iq ky b kz mc lb lc ld md lf lg lh me lj lk ll mf ln lo lp mg lr ls lt ij bi translated">在我们修复了所有东西之后，我们生成反向shell的最终有效负载将如下所示:</p><figure class="lw lx ly lz gt jr"><div class="bz fp l di"><div class="ma mb l"/></div></figure><h1 id="b1ac" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">有趣的有效载荷</h1><ul class=""><li id="3381" class="mr ms iq ky b kz la ld le lh nf ll ng lp nh lt ni mx my mz bi translated">拒绝服务:<code class="fe mn mo mp mq b">while (1) 0</code></li><li id="50dd" class="mr ms iq ky b kz na ld nb lh nc ll nd lp ne lt ni mx my mz bi translated">阅读<code class="fe mn mo mp mq b">/etc/passwd</code></li></ul><figure class="lw lx ly lz gt jr"><div class="bz fp l di"><div class="ma mb l"/></div></figure><h1 id="b7b7" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">时间表</h1><ul class=""><li id="64f3" class="mr ms iq ky b kz la ld le lh nf ll ng lp nh lt ni mx my mz bi translated">2018/5/28 18:30 —通过代码审查发现的漏洞</li><li id="236f" class="mr ms iq ky b kz na ld nb lh nc ll nd lp ne lt ni mx my mz bi translated">2018/5/28 20:30 —反向外壳已生成</li><li id="552a" class="mr ms iq ky b kz na ld nb lh nc ll nd lp ne lt ni mx my mz bi translated">2018/5/28 23:00 —通知供应商</li><li id="a85d" class="mr ms iq ky b kz na ld nb lh nc ll nd lp ne lt ni mx my mz bi translated">2018/5/29 00:00 —供应商确认的漏洞</li><li id="0bce" class="mr ms iq ky b kz na ld nb lh nc ll nd lp ne lt ni mx my mz bi translated">2018/5/29 02:00—<a class="ae lv" href="https://github.com/davidmarkclements/fast-redact/commit/e67a1e6c8ed827bbc4be329cdd928d96829efa50" rel="noopener ugc nofollow" target="_blank">GitHub上发布的第一个修复</a></li></ul><h1 id="5cb1" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">追踪</h1><p id="9082" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">在查看博客帖子后，供应商要求包含以下声明:</p><blockquote class="mh mi mj"><p id="1f4b" class="kw kx lu ky b kz mc lb lc ld md lf lg mk me lj lk ml mf ln lo mm mg lr ls lt ij bi translated">作者没有将此归类为安全漏洞，因为明确的文档必须来自可信方</p></blockquote></div></div>    
</body>
</html>