<html>
<head>
<title>Multiple Spring Boot applications in the same project</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">同一项目中的多个Spring Boot应用程序</h1>
<blockquote>原文：<a href="https://itnext.io/multiple-spring-boot-apps-same-project-f6208d1a97d9?source=collection_archive---------4-----------------------#2021-12-05">https://itnext.io/multiple-spring-boot-apps-same-project-f6208d1a97d9?source=collection_archive---------4-----------------------#2021-12-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/fb2616aadf012f900b01723dc46bb152.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BtV8PxOWi5UGKkKcJEdhdg.jpeg"/></div></div></figure><p id="f944" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我经常在我的演示中使用Spring Boot框架。最新的也没什么不同。它展示了如何使用两种不同的代码路径实现CQRS:</p><ul class=""><li id="01dc" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv lc ld le lf bi translated">命令部分通过<a class="ae kw" href="https://spring.io/projects/spring-data-jpa" rel="noopener ugc nofollow" target="_blank"> Spring Data JPA </a>实现</li><li id="dfa0" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">查询部分通过<a class="ae kw" href="https://www.jooq.org/" rel="noopener ugc nofollow" target="_blank"> jOOQ </a></li></ul><p id="f3b0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我的用例是一个银行应用程序，它提供了一个REST层，允许客户调用任何部分。使用<code class="fe ll lm ln lo b">curl</code>演示查询部分非常简单，因为URL并不复杂:</p><pre class="lp lq lr ls gt lt lo lu lv aw lw bi"><span id="3dcd" class="lx ly iq lo b gy lz ma l mb mc">curl localhost:8080/balance/123          // 1</span></pre><ol class=""><li id="f6aa" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv md ld le lf bi translated">查询账户<code class="fe ll lm ln lo b">123</code>的余额</li></ol><p id="609c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">另一方面，创建一个新的操作，<em class="me">，例如</em>，一个信用，需要将数据传递给<code class="fe ll lm ln lo b">curl</code>。虽然这样做是可行的，但是有效载荷本身的结构<em class="me">很复杂，因为它是JSON的一部分。因此，使用<code class="fe ll lm ln lo b">curl</code>在现场观众面前演示命令部分是有风险的。我倾向于避免不必要的风险，所以我考虑了一些替代方案。</em></p><p id="b342" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我的第一个想法是提前准备命令，在演示过程中进行复制粘贴。我想做几个不同的手术，所以我必须:</p><ul class=""><li id="fb35" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv lc ld le lf bi translated">要么准备一个命令，粘贴它并在运行它之前更改它</li><li id="3b26" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">或者准备所有不同的命令</li></ul><p id="0c92" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对我来说，两者都太尴尬了。</p><p id="d741" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">另一个选择是在同一个项目中创建另一个<code class="fe ll lm ln lo b">@SpringBootApplication</code>注释类:</p><pre class="lp lq lr ls gt lt lo lu lv aw lw bi"><span id="ae66" class="lx ly iq lo b gy lz ma l mb mc">@SpringBootApplication<br/>public class GeneratorApplication {</span><span id="c83a" class="lx ly iq lo b gy mf ma l mb mc">    @Bean<br/>    public CommandLineRunner run() {<br/>        var template = new RestTemplate();<br/>        return args -&gt; {<br/>            var operation = generateRandomOperation();          // 1<br/>            LongStream.range(0, Long.parseLong(args[0]))        // 2<br/>                .forEach(<br/>                    operation -&gt; template.postForObject(        // 3<br/>                        "http://localhost:8080/operation",<br/>                        operation,<br/>                        Object.class));<br/>        };<br/>    }</span><span id="9902" class="lx ly iq lo b gy mf ma l mb mc">    public static void main(String[] args) {<br/>        new SpringApplicationBuilder(GeneratorApplication.class)<br/>                .run(args);<br/>    }<br/>}</span></pre><ol class=""><li id="6a5d" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv md ld le lf bi translated">不知何故，生成一个随机的<code class="fe ll lm ln lo b">Operation</code></li><li id="dd3d" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv md ld le lf bi translated">从参数中获取调用次数</li><li id="cb4a" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv md ld le lf bi translated">调用主web应用程序的URL</li></ol><p id="f2e2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我在另一个web应用程序之后启动这个应用程序时，它失败了。这有两个原因:</p><ol class=""><li id="761f" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv md ld le lf bi translated">两个应用程序共享同一个Maven POM。当<code class="fe ll lm ln lo b">spring-boot-starter-web</code>在类路径上时，生成器应用程序试图启动Tomcat。它失败是因为第一个应用程序绑定了默认端口。</li><li id="6394" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv md ld le lf bi translated">默认情况下，Spring Boot依赖于组件扫描。因此，web应用程序扫描生成器应用程序及其声明的beans并创建它们。可以这样重新定义一些beans。然而，webapp也创建了上面的<code class="fe ll lm ln lo b">CommandLineRunner</code> bean。因此，当它的服务器还没有准备好的时候，它就“向自己发布”。</li></ol><p id="82f2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最直接的解决方案是将每个应用程序的类移动到它们自己专用的Maven模块中。您需要在每个模块中创建一个POM，只包含必要的依赖项。另外，我需要在webapp的runner中使用几个类。虽然我可以在其他模块中复制它们，但这是额外的工作和复杂性。</p><p id="f28b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了防止类路径扫描，我们将每个应用程序类移动到它的包中。请注意，当包有父子关系时，它不起作用:它们必须是兄弟。</p><p id="2ee4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了创建特定类的beans，我们需要依赖特定的注释，这取决于它们的性质:</p><ul class=""><li id="7061" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv lc ld le lf bi translated">对于JPA实体，<code class="fe ll lm ln lo b">@EntityScan</code>，指向要扫描的包</li><li id="01b0" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">对于JPA存储库，<code class="fe ll lm ln lo b">@EnableJpaRepositories</code>，指向要扫描的包</li><li id="ca6e" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">对于其他类，<code class="fe ll lm ln lo b">@Import</code>指向生成bean的类</li></ul><p id="7c09" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后一步是阻止生成器应用程序启动web服务器。您可以在启动应用程序时对其进行配置。</p><pre class="lp lq lr ls gt lt lo lu lv aw lw bi"><span id="b8b8" class="lx ly iq lo b gy lz ma l mb mc">@SpringBootApplication<br/>@EnableJpaRepositories("org.hazelcast.cqrs")                    // 1<br/>@EntityScan("org.hazelcast.cqrs")                               // 2<br/>public class GeneratorApplication {</span><span id="cdf4" class="lx ly iq lo b gy mf ma l mb mc">    public static void main(String[] args) {<br/>        new SpringApplicationBuilder(GeneratorApplication.class)<br/>                .web(WebApplicationType.NONE)                   // 3<br/>                .run(args);<br/>    }</span><span id="9e86" class="lx ly iq lo b gy mf ma l mb mc">    // Command-line runner<br/>}</span></pre><ol class=""><li id="7e10" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv md ld le lf bi translated">扫描JPA存储库</li><li id="8d0c" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv md ld le lf bi translated">扫描JPA实体</li><li id="bc19" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv md ld le lf bi translated">阻止web服务器启动</li></ol><p id="72e5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它像预期的那样工作，我们最终可以获得设置的好处。</p><p id="cc3f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于现实世界的应用程序，您可能会创建一个自动执行的JAR。您需要开发一种在构建期间配置主类的方法，每个应用程序一个。我认为最好不要这样做，把它作为一个演示版。</p><ul class=""><li id="509c" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv lc ld le lf bi translated"><a class="ae kw" href="https://docs.spring.io/spring-boot/docs/2.6.x/reference/htmlsingle/#howto.application.non-web-application" rel="noopener ugc nofollow" target="_blank">创建一个非网络应用</a></li><li id="3723" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated"><a class="ae kw" href="https://docs.spring.io/spring-boot/docs/2.6.x/reference/htmlsingle/#howto.data-access.spring-data-repositories" rel="noopener ugc nofollow" target="_blank">使用Spring数据仓库</a></li><li id="aa1f" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated"><a class="ae kw" href="https://docs.spring.io/spring-boot/docs/2.6.x/reference/htmlsingle/#howto.data-access.separate-entity-definitions-from-spring-configuration" rel="noopener ugc nofollow" target="_blank">将@Entity定义从弹簧配置中分离出来</a></li><li id="5208" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated"><a class="ae kw" href="https://docs.spring.io/spring-boot/docs/2.6.x/reference/htmlsingle/#using.configuration-classes.importing-additional-configuration" rel="noopener ugc nofollow" target="_blank">导入附加配置类</a></li></ul></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><p id="04e2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="me">原载于</em> <a class="ae kw" href="https://blog.frankel.ch/multiple-spring-boot-apps-same-project/" rel="noopener ugc nofollow" target="_blank"> <em class="me">一个Java极客</em></a><em class="me">2021年12月5日</em></p></div></div>    
</body>
</html>