<html>
<head>
<title>Facebook Stock Prediction Using Python &amp; Machine Learning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">利用Python和机器学习进行脸书股票预测</h1>
<blockquote>原文：<a href="https://itnext.io/facebook-stock-prediction-bcfc676bc611?source=collection_archive---------2-----------------------#2019-07-01">https://itnext.io/facebook-stock-prediction-bcfc676bc611?source=collection_archive---------2-----------------------#2019-07-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="8c6a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">支持向量回归</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/bef1f2bea34c8ca7a6d9b81a246d5186.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4eTf8vKqHI1pUl5qchf06g.png"/></div></div></figure><p id="5567" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本文中，我将向您展示如何使用称为支持向量回归(SVR)的机器学习算法创建自己的股票预测Python程序。该程序将读取脸书(FB)的股票数据，并根据当天的价格进行预测。</p><p id="858e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">试图预测股票市场或股票价格的方向是极其困难的，但是在这篇文章中我会尝试一下。即使对统计学和概率有很好理解的人也很难做到这一点。</p><blockquote class="la lb lc"><p id="6a11" class="jq jr ld js b jt ju jv jw jx jy jz ka le kc kd ke lf kg kh ki lg kk kl km kn im bi translated"><strong class="js iu"> <em class="it">免责声明</em> </strong> <em class="it">:本文材料纯属教育性质，不应作为专业投资建议。自行决定投资。</em></p></blockquote><p id="ea20" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">支持向量回归(SVR) </strong>是一种<strong class="js iu">支持向量机，</strong>是一种监督学习算法，用于分析<a class="ae lh" href="https://en.wikipedia.org/wiki/Regression_analysis" rel="noopener ugc nofollow" target="_blank">回归</a>分析的数据。1996年，这个版本的回归SVM是由Christopher J. C. Burges，Vladimir N. Vapnik，Harris Drucker，Alexander J. Smola和Linda Kaufman提出的。由SVR产生的模型仅依赖于训练数据的子集，因为用于建立模型的成本函数忽略了任何接近模型预测的训练数据。</p><h1 id="f893" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">支持向量机的优点:</h1><ol class=""><li id="bfc0" class="mg mh it js b jt mi jx mj kb mk kf ml kj mm kn mn mo mp mq bi translated">在高维空间是有效的。</li><li id="7476" class="mg mh it js b jt mr jx ms kb mt kf mu kj mv kn mn mo mp mq bi translated">它工作得很好，有清晰的分离边界。</li><li id="4db8" class="mg mh it js b jt mr jx ms kb mt kf mu kj mv kn mn mo mp mq bi translated">这在维数大于样本数的情况下是有效的。</li></ol><h1 id="9ae2" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">支持向量机回归缺点:</h1><ol class=""><li id="b0f6" class="mg mh it js b jt mi jx mj kb mk kf ml kj mm kn mn mo mp mq bi translated">当我们有大的数据集时，它表现不好。</li><li id="4d5e" class="mg mh it js b jt mr jx ms kb mt kf mu kj mv kn mn mo mp mq bi translated">如果数据集有噪声(大量额外的无意义信息)，则性能较低。</li></ol><h1 id="cea8" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">内核类型:</h1><ol class=""><li id="ad9b" class="mg mh it js b jt mi jx mj kb mk kf ml kj mm kn mn mo mp mq bi translated">线性的</li><li id="494f" class="mg mh it js b jt mr jx ms kb mt kf mu kj mv kn mn mo mp mq bi translated">多项式</li><li id="6bd2" class="mg mh it js b jt mr jx ms kb mt kf mu kj mv kn mn mo mp mq bi translated">径向基函数</li><li id="bcf8" class="mg mh it js b jt mr jx ms kb mt kf mu kj mv kn mn mo mp mq bi translated">乙状结肠的</li></ol><p id="cdfc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你不想读这篇文章，想要一个视频演示，你可以看看下面的<a class="ae lh" href="https://youtu.be/C64BIMx7Slw" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu"> YouTube视频</strong> </a>。它详细介绍了本文中的所有内容，即使您的计算机上没有安装编程语言Python，也可以帮助您轻松地开始编写自己的机器学习模型。或者两者都可以作为学习机器学习的辅助材料！</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mw mx l"/></div></figure><h1 id="2f1c" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">开始编程:</h1><p id="1eb1" class="pw-post-body-paragraph jq jr it js b jt mi jv jw jx mj jz ka kb my kd ke kf mz kh ki kj na kl km kn im bi translated">在编写一行代码之前，我喜欢做的第一件事是在注释中描述代码的作用。这样我可以回顾我的代码，并确切地知道它做了什么。</p><pre class="kp kq kr ks gt nb nc nd ne aw nf bi"><span id="bfaa" class="ng lj it nc b gy nh ni l nj nk"><em class="ld">#Description: This program predicts the price of FB stock for a specific day</em><br/><em class="ld">#             using the Machine Learning algorithm called </em><br/><em class="ld">#             Support Vector Regression (SVR) Model</em></span></pre><p id="f0fe" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在导入包以使编写程序更容易。</p><pre class="kp kq kr ks gt nb nc nd ne aw nf bi"><span id="54cd" class="ng lj it nc b gy nh ni l nj nk"><em class="ld">#import the packages<br/></em><strong class="nc iu">from</strong> <strong class="nc iu">sklearn.svm</strong> <strong class="nc iu">import</strong> SVR<br/><strong class="nc iu">import</strong> <strong class="nc iu">numpy</strong> <strong class="nc iu">as</strong> <strong class="nc iu">np<br/>import</strong> <strong class="nc iu">pandas</strong> <strong class="nc iu">as</strong> <strong class="nc iu">pd</strong><br/><strong class="nc iu">import</strong> <strong class="nc iu">matplotlib.pyplot</strong> <strong class="nc iu">as</strong> <strong class="nc iu">plt<br/></strong>plt.style.use('fivethirtyeight')</span></pre><p id="b04f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我将把从<a class="ae lh" href="https://finance.yahoo.com/quote/FB/history?p=FB" rel="noopener ugc nofollow" target="_blank">finance.yahoo.com</a>获得的脸书(FB)股票数据加载到一个名为“df”的变量中，df是data frame的缩写。然后，我将打印前7行数据</p><p id="f05e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">注:</strong>这是雅虎过去30天的数据，2019年5月1日至2019年5月31日。<br/>记住市场只在工作日开放。</p><pre class="kp kq kr ks gt nb nc nd ne aw nf bi"><span id="8ca3" class="ng lj it nc b gy nh ni l nj nk"><em class="ld">#Load the data</em><br/><em class="ld">#from google.colab import files # Use to load data on Google Colab</em><br/><em class="ld">#uploaded = files.upload() # Use to load data on Google Colab</em><br/>df = pd.read_csv('FB_Stock.csv')<br/>df</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/365e85701a7e664cad1e5b42c7221717.png" data-original-src="https://miro.medium.com/v2/resize:fit:1386/format:webp/1*9Rf0_xLtG_b8JCAs2bJ_AA.png"/></div></figure><p id="83a3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">获取数据集中的行数和列数，以查看每一行的计数。有22行和7列数据。</p><pre class="kp kq kr ks gt nb nc nd ne aw nf bi"><span id="338b" class="ng lj it nc b gy nh ni l nj nk"><em class="ld">#Get the number of rows and columns in the data set</em> <br/>df.shape</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/0b6a154f9e67dea0a450fd0d98c2cbcf.png" data-original-src="https://miro.medium.com/v2/resize:fit:138/format:webp/1*xO7A0MEd3ZfMvjugF_bHgQ.png"/></div><figcaption class="nn no gj gh gi np nq bd b be z dk translated">数据集中的22行和7列</figcaption></figure><p id="f0a7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">打印最后一行数据(这将是我们测试的数据)。请注意，日期是2019年5月31日，所以这一天是31日。这将是模型的输入，用于预测调整后的收盘价177.470001美元。</p><pre class="kp kq kr ks gt nb nc nd ne aw nf bi"><span id="a884" class="ng lj it nc b gy nh ni l nj nk"><em class="ld">#Print the last row of data (this will be the data that we test on)</em><br/>actual_price = df.tail(1)<br/>actual_price</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/044a9e5b14b94015c44765d84aa80a6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1372/format:webp/1*v29XLj_MG4IQ5UwvOqMQnw.png"/></div></figure><p id="283e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通过将变量设置为空列表，创建将用作独立和从属数据集的变量。</p><p id="d8ee" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通过获取除最后一行之外的所有数据来重新创建数据框，我稍后将使用最后一行来测试模型，并将缺少最后一行的新数据存储回“df”中。然后打印新数据集的行数和列数。</p><pre class="kp kq kr ks gt nb nc nd ne aw nf bi"><span id="ca1a" class="ng lj it nc b gy nh ni l nj nk"><em class="ld">#Get all of the data except for the last row</em><br/>df = df.head(len(df)-1)<br/>print(df)<br/>print(df.shape)</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/f8943f7daac7f098d804aff5f44d9169.png" data-original-src="https://miro.medium.com/v2/resize:fit:1324/format:webp/1*zYcZjUvtKqLfoTAHzRqHDg.png"/></div><figcaption class="nn no gj gh gi np nq bd b be z dk translated">新的数据集</figcaption></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/66fd266df5d58c84f256c2cd5b50b26f.png" data-original-src="https://miro.medium.com/v2/resize:fit:132/format:webp/1*npxYa8rHpQVb-XuSbaqNtg.png"/></div><figcaption class="nn no gj gh gi np nq bd b be z dk translated">少了一行的新数据。21行7列</figcaption></figure><pre class="kp kq kr ks gt nb nc nd ne aw nf bi"><span id="8874" class="ng lj it nc b gy nh ni l nj nk"><em class="ld">#Create the lists / X and y data set</em><br/>days = list()<br/>adj_close_prices = list()</span></pre><p id="2487" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">从日期列获取所有行，将其存储到名为“df_days”的变量中，从调整收盘价格列获取所有行，并将数据存储到名为“df_adj_close_price”的变量中。</p><pre class="kp kq kr ks gt nb nc nd ne aw nf bi"><span id="d13e" class="ng lj it nc b gy nh ni l nj nk">df_days = df.loc[:,'Date']<br/>df_adj_close = df.loc[:,'Adj Close Price']</span></pre><p id="d3b3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">创建独立数据集“X ”,并将数据存储在变量“days”中。<br/>创建相关数据集‘y’并将数据存储在变量‘adj _ close _ prices’中。两者都可以通过将数据附加到每个列表中来完成。</p><p id="c18e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">注意:</strong>对于独立的数据集，我们只需要日期中的某一天，所以我使用split函数来获取这一天，并将其转换为一个整数，同时将数据追加到列表中。</p><pre class="kp kq kr ks gt nb nc nd ne aw nf bi"><span id="1644" class="ng lj it nc b gy nh ni l nj nk">#Create the independent data set 'X' as days<br/>for day in df_days:<br/>   days.append( [int(day.split('/')[1]) ] )</span><span id="2d15" class="ng lj it nc b gy nu ni l nj nk">#Create the dependent data set 'y' as prices<br/>for adj_close_price in df_adj_close:<br/>   adj_close_prices.append(float(adj_close_price))</span></pre><p id="bd9b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">查看数据集中记录了哪些日期。</p><pre class="kp kq kr ks gt nb nc nd ne aw nf bi"><span id="faaf" class="ng lj it nc b gy nh ni l nj nk">print(days)</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nv"><img src="../Images/b05ddac245421cc2ca6c73b18bee77ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NtH8S5G-u5SUa-55In6cIg.png"/></div></div><figcaption class="nn no gj gh gi np nq bd b be z dk translated">数据集中记录的天数</figcaption></figure><p id="d08c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我将使用三种不同的内核创建和训练三种不同的支持向量回归(SVR)模型，以查看哪一种性能最好。</p><pre class="kp kq kr ks gt nb nc nd ne aw nf bi"><span id="7acd" class="ng lj it nc b gy nh ni l nj nk">#Create and train an SVR model using a linear kernel<br/>lin_svr = SVR(kernel='linear', C=1000.0)<br/>lin_svr.fit(days,adj_close_prices)</span><span id="f0bc" class="ng lj it nc b gy nu ni l nj nk">#Create and train an SVR model using a polynomial kernel<br/>poly_svr = SVR(kernel='poly', C=1000.0, degree=2)<br/>poly_svr.fit(days, adj_close_prices)</span><span id="a0fd" class="ng lj it nc b gy nu ni l nj nk">#Create and train an SVR model using a RBF kernel<br/>rbf_svr = SVR(kernel='rbf', C=1000.0, gamma=0.15)<br/>rbf_svr.fit(days, adj_close_prices)</span></pre><p id="df37" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后但并非最不重要的是，我将在图上绘制模型，以查看哪个模型最适合，并返回当天的预测。</p><pre class="kp kq kr ks gt nb nc nd ne aw nf bi"><span id="3e0f" class="ng lj it nc b gy nh ni l nj nk">#Plot the models on a graph to see which has the best fit<br/>plt.figure(figsize=(16,8))<br/>plt.scatter(days, adj_close_prices, color = 'black', label='Data')<br/>plt.plot(days, rbf_svr.predict(days), color = 'green', label='RBF Model')<br/>plt.plot(days, poly_svr.predict(days), color = 'orange', label='Polynomial Model')<br/>plt.plot(days, lin_svr.predict(days), color = 'blue', label='Linear Model')<br/>plt.xlabel('Days')<br/>plt.ylabel('Adj Close Price')<br/>plt.title('Support Vector Regression')<br/>plt.legend()<br/>plt.show()</span></pre><p id="7ea1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下图中最好的模型似乎是<strong class="js iu"> RBF </strong>，它是一种支持向量回归模型，使用一种称为径向基函数的核。然而，这个图表可能会产生误导。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nw"><img src="../Images/2bcda4677204b6477e446a52bd8100ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fbBarWwfcRZlVhT2NWoYjg.png"/></div></div></figure><p id="f297" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我可以开始做我的FB价格预测了。回想原始数据集中遗漏的最后一行数据，日期是05–31–2019，因此日期是31。这将是预测调整后收盘价<strong class="js iu"> $177.470001 </strong>的模型输入。</p><p id="5984" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以现在我将通过给模型赋值31来预测价格。</p><pre class="kp kq kr ks gt nb nc nd ne aw nf bi"><span id="562c" class="ng lj it nc b gy nh ni l nj nk">day = [[31]]<br/>print('The RBF SVR predicted price:',rbf_svr.predict(day))<br/>print('The linear SVR predicted price',lin_svr.predict(day))<br/>print('The polynomial SVR predicted price',poly_svr.predict(day))</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/6614365ae9f541e5e1d5708061902621.png" data-original-src="https://miro.medium.com/v2/resize:fit:776/format:webp/1*6zcZfB5e2HDK6x8tk7A-jQ.png"/></div></figure><p id="1be9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">多项式SVR模型预测第31天的价格为<strong class="js iu"> $180.39533267 </strong>，这与<strong class="js iu"> $177.470001 </strong>的实际价格非常接近。在这种情况下，最佳模型似乎是多项式SVR。就这样，你完成了创建SVR程序来预测FB股票！</p><p id="6b4a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你有兴趣阅读更多关于机器学习的内容，以便立即开始处理问题和示例，那么我强烈建议你查看<a class="ae lh" href="https://www.amazon.com/gp/product/1491962291?ie=UTF8&amp;tag=medium074-20&amp;camp=1789&amp;linkCode=xm2&amp;creativeASIN=1491962291" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu">使用Scikit-Learn和TensorFlow进行机器学习实践:构建智能系统的概念、工具和技术</strong> </a>。这是一本帮助初学者学习如何编写机器学习程序和理解机器学习概念的好书。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><a href="https://www.amazon.com/gp/product/1491962291/ref=as_li_tl?ie=UTF8&amp;tag=medium074-20&amp;camp=1789&amp;creative=9325&amp;linkCode=as2&amp;creativeASIN=1491962291&amp;linkId=b7cc2001f37665b84139089c59ef8571"><div class="gh gi ny"><img src="../Images/1c76ef57958bdd4cc146d282c7210ac0.png" data-original-src="https://miro.medium.com/v2/resize:fit:868/format:webp/1*3lz1m4uotU9HRQNNFMftIw.png"/></div></a><figcaption class="nn no gj gh gi np nq bd b be z dk translated"><a class="ae lh" href="https://www.amazon.com/gp/product/1491962291?ie=UTF8&amp;tag=medium074-20&amp;camp=1789&amp;linkCode=xm2&amp;creativeASIN=1491962291" rel="noopener ugc nofollow" target="_blank">使用Scikit-Learn和TensorFlow进行机器实践学习:构建智能系统的概念、工具和技术</a></figcaption></figure><p id="5e3b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">感谢你阅读这篇文章，希望对你有所帮助！如果你喜欢这篇文章，并发现它很有帮助，请留下一些掌声，以示感谢。坚持学习，如果你喜欢机器学习、数学、计算机科学、编程或算法分析，请访问并订阅我的<a class="ae lh" href="https://www.youtube.com/channel/UCaV_0qp2NZd319K4_K8Z5SQ" rel="noopener ugc nofollow" target="_blank"> YouTube </a>频道(<a class="ae lh" href="https://www.youtube.com/channel/UCaV_0qp2NZd319K4_K8Z5SQ" rel="noopener ugc nofollow" target="_blank">randers 112358</a>&amp;<a class="ae lh" href="https://www.youtube.com/channel/UCbmb5IoBtHZTpYZCDBOC1CA" rel="noopener ugc nofollow" target="_blank">compsci 112358</a>)。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nz"><img src="../Images/f1de98b2890a22af6b24bea87fcb5518.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L0M9fEe55Tiv3DrX6Knwuw.jpeg"/></div></div></figure></div></div>    
</body>
</html>