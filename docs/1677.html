<html>
<head>
<title>Developing React custom hooks for abortable async functions with AbortController</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用AbortController为abortable异步函数开发React自定义钩子</h1>
<blockquote>原文：<a href="https://itnext.io/developing-react-custom-hooks-for-abortable-async-functions-with-abortcontroller-1f2091b5a1c3?source=collection_archive---------1-----------------------#2018-12-31">https://itnext.io/developing-react-custom-hooks-for-abortable-async-functions-with-abortcontroller-1f2091b5a1c3?source=collection_archive---------1-----------------------#2018-12-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="9b0b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">寻求反应钩的可能性。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/d7705ecf0227d6f5e83195dd29e5ff09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nC8NG0kizkqsDNkpiEarkQ.png"/></div></div></figure><p id="de38" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我的上一篇文章中，我介绍了定制钩子<code class="fe lb lc ld le b">useAsyncTask</code>如何用AbortController处理异步函数，并演示了一个typeahead搜索示例。在本文中，我解释了关于<code class="fe lb lc ld le b">useAsyncTask</code>的实现。</p><h2 id="498c" class="lf lg it bd lh li lj dn lk ll lm dp ln kb lo lp lq kf lr ls lt kj lu lv lw lx bi translated">概述</h2><p id="4eb4" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">JavaScript promise是不可放弃的。fetch API是基于promise的，因此你不能在纯JavaScript中取消它。为了取消<code class="fe lb lc ld le b">fetch</code>，DOM规范引入了<code class="fe lb lc ld le b">AbortController</code>。AbortController是一个通用接口，不是<code class="fe lb lc ld le b">fetch</code>专用的。从技术上讲，我们可以用它来取消承诺，如果有一种简单的方法来处理可移植的异步函数就好了。在React世界中，我们期待着Hooks API的出现。我已经开始了一个项目，为可移植的异步函数实现定制钩子。</p><div class="md me gp gr mf mg"><a href="https://github.com/dai-shi/react-hooks-async" rel="noopener  ugc nofollow" target="_blank"><div class="mh ab fo"><div class="mi ab mj cl cj mk"><h2 class="bd iu gy z fp ml fr fs mm fu fw is bi translated">戴式/反应式挂钩异步</h2><div class="mn l"><h3 class="bd b gy z fp ml fr fs mm fu fw dk translated">带React钩子的异步函数库——Dai-Shi/React-Hooks-async</h3></div><div class="mo l"><p class="bd b dl z fp ml fr fs mm fu fw dk translated">github.com</p></div></div><div class="mp l"><div class="mq l mr ms mt mp mu ky mg"/></div></div></a></div><div class="md me gp gr mf mg"><a href="https://www.npmjs.com/package/react-hooks-async" rel="noopener  ugc nofollow" target="_blank"><div class="mh ab fo"><div class="mi ab mj cl cj mk"><h2 class="bd iu gy z fp ml fr fs mm fu fw is bi translated">反应-钩子-异步</h2><div class="mn l"><h3 class="bd b gy z fp ml fr fs mm fu fw dk translated">一个带React钩子的可移植异步函数库</h3></div><div class="mo l"><p class="bd b dl z fp ml fr fs mm fu fw dk translated">www.npmjs.com</p></div></div><div class="mp l"><div class="mv l mr ms mt mp mu ky mg"/></div></div></a></div><h2 id="9ac8" class="lf lg it bd lh li lj dn lk ll lm dp ln kb lo lp lq kf lr ls lt kj lu lv lw lx bi translated"><code class="fe lb lc ld le b">useAsyncTask</code>的实施</h2><p id="2720" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated"><code class="fe lb lc ld le b">useAsyncTask</code>钩子是为了创建一个可以由<code class="fe lb lc ld le b">useAsyncRun</code>启动的异步任务，我们将在本文稍后描述。要创建一个异步任务，需要传递一个接收AbortController实例并返回abortable承诺的函数。作为一个具体的例子，我们稍后描述如何为<code class="fe lb lc ld le b">fetch</code>实现一个定制钩子。</p><p id="44d3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">代码的主要部分如下。</p><pre class="kp kq kr ks gt mw le mx my aw mz bi"><span id="e252" class="lf lg it le b gy na nb l nc nd">const useAsyncTask = (func, inputs) =&gt; {<br/>  const forceUpdate = <strong class="le iu">useForceUpdate</strong>();<br/>  const task = <strong class="le iu">useRef</strong>({});<br/>  const newTask = <strong class="le iu">useMemo</strong>(() =&gt; <strong class="le iu">createTask</strong>(func, (t) =&gt; {<br/>    if (task.current &amp;&amp; task.current.taskId === t.taskId) {<br/>      task.current = t;<br/>      <strong class="le iu">forceUpdate</strong>();<br/>    }<br/>  }), <strong class="le iu">inputs</strong>);<br/>  if (task.current &amp;&amp; task.current.taskId !== newTask.taskId) {<br/>    task.current = newTask;<br/>  }<br/>  <strong class="le iu">useEffect</strong>(() =&gt; {<br/>    const cleanup = () =&gt; { task.current = null; };<br/>    return cleanup;<br/>  }, <strong class="le iu">[]</strong>);<br/>  return task.current;<br/>};</span></pre><p id="dd6b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">阅读这段代码需要注意三点:</p><ul class=""><li id="d67e" class="ne nf it js b jt ju jx jy kb ng kf nh kj ni kn nj nk nl nm bi translated"><code class="fe lb lc ld le b">task</code>对象由<code class="fe lb lc ld le b">useRef</code>定义，重渲染由<code class="fe lb lc ld le b">forceUpdate</code>控制。</li><li id="a34f" class="ne nf it js b jt nn jx no kb np kf nq kj nr kn nj nk nl nm bi translated"><code class="fe lb lc ld le b">createTask</code>是核心部分，在第二个参数中取一个回调函数，用<code class="fe lb lc ld le b">useMemo</code>调用，只有<code class="fe lb lc ld le b">inputs</code>被改变。</li><li id="f260" class="ne nf it js b jt nn jx no kb np kf nq kj nr kn nj nk nl nm bi translated"><code class="fe lb lc ld le b">useEffect</code>是清理<code class="fe lb lc ld le b">task</code>对象，以便卸载后不尝试渲染。</li></ul><p id="642c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe lb lc ld le b">useForceUpdate</code>挂钩是通用挂钩，通过以下实施。</p><pre class="kp kq kr ks gt mw le mx my aw mz bi"><span id="bc51" class="lf lg it le b gy na nb l nc nd">const forcedReducer = state =&gt; !state;<br/>const useForceUpdate = () =&gt; useReducer(forcedReducer, false)[1];</span></pre><p id="c551" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe lb lc ld le b">createTask</code>的代码有点长。</p><pre class="kp kq kr ks gt mw le mx my aw mz bi"><span id="3fcc" class="lf lg it le b gy na nb l nc nd">const createTask = (func, notifyUpdate) =&gt; {<br/>  const <strong class="le iu">taskId</strong> = Symbol(`async_task_id_${idCounter += 1}`);<br/>  let abortController = null;<br/>  let task = {<br/>    taskId,<br/>    started: false,<br/>    pending: true,<br/>    error: null,<br/>    result: null,<br/>    <strong class="le iu">start</strong>: async () =&gt; {<br/>      if (task.started) return;<br/>      abortController = new AbortController();<br/>      task = { ...task, started: true };<br/>      <strong class="le iu">notifyUpdate(task);</strong><br/>      try {<br/>        const result = <strong class="le iu">await func(abortController)</strong>;<br/>        task = { ...task, pending: false, result };<br/>      } catch (e) {<br/>        task = { ...task, pending: false, error: e };<br/>      }<br/>      <strong class="le iu">notifyUpdate(task);</strong><br/>    },<br/>    <strong class="le iu">abort</strong>: () =&gt; {<br/>      if (abortController) {<br/>        abortController.abort();<br/>      }<br/>    },<br/>  };<br/>  return task;<br/>};</span></pre><ul class=""><li id="4135" class="ne nf it js b jt ju jx jy kb ng kf nh kj ni kn nj nk nl nm bi translated">对象具有<code class="fe lb lc ld le b">taskId</code>和四个属性:<code class="fe lb lc ld le b">started</code>、<code class="fe lb lc ld le b">pending</code>、<code class="fe lb lc ld le b">error</code>和<code class="fe lb lc ld le b">result</code>。</li><li id="4708" class="ne nf it js b jt nn jx no kb np kf nq kj nr kn nj nk nl nm bi translated">除此之外，<code class="fe lb lc ld le b">task</code>对象还包含控制执行的<code class="fe lb lc ld le b">start()</code>和<code class="fe lb lc ld le b">abort()</code>功能。</li><li id="6a11" class="ne nf it js b jt nn jx no kb np kf nq kj nr kn nj nk nl nm bi translated">调用<code class="fe lb lc ld le b">start()</code>时，根据异步状态变化回呼<code class="fe lb lc ld le b">notifyChange()</code>。</li><li id="7d28" class="ne nf it js b jt nn jx no kb np kf nq kj nr kn nj nk nl nm bi translated">第一个参数<code class="fe lb lc ld le b">func</code>是接收AbortController实例并返回承诺的函数。<code class="fe lb lc ld le b">func</code>负责正确处理AbortController。</li></ul><h2 id="2269" class="lf lg it bd lh li lj dn lk ll lm dp ln kb lo lp lq kf lr ls lt kj lu lv lw lx bi translated">useAsyncRun的实现</h2><p id="0c0c" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated"><code class="fe lb lc ld le b">useAsyncTask</code>挂钩只是为了创建一个异步任务并使其准备好启动。<code class="fe lb lc ld le b">useAsyncRun</code>挂钩是实际启动异步任务的挂钩。我们将逻辑拆分为两个挂钩的原因是允许组合多个异步任务。<code class="fe lb lc ld le b">useAsyncCombineSeq</code> hook是用于合并的，但我们在本文中不再赘述。</p><p id="2200" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个代码相当简单。</p><pre class="kp kq kr ks gt mw le mx my aw mz bi"><span id="d0e2" class="lf lg it le b gy na nb l nc nd">const useAsyncRun = (asyncTask) =&gt; {<br/>  useEffect(() =&gt; {<br/>    if (asyncTask) {<br/>      asyncTask.start();<br/>    }<br/>    const cleanup = () =&gt; {<br/>      if (asyncTask) {<br/>        asyncTask.abort();<br/>      }<br/>    };<br/>    return cleanup;<br/>  }, <strong class="le iu">[asyncTask &amp;&amp; asyncTask.taskId]</strong>);<br/>};</span></pre><p id="c16f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">简称为<code class="fe lb lc ld le b">start()</code>和<code class="fe lb lc ld le b">abort()</code>。请注意，输入数组被传递给了<code class="fe lb lc ld le b">useEffect</code>的第二个参数。</p><h2 id="2551" class="lf lg it bd lh li lj dn lk ll lm dp ln kb lo lp lq kf lr ls lt kj lu lv lw lx bi translated">useAsyncTaskFetch的实现</h2><p id="3ad4" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated"><code class="fe lb lc ld le b">useAsyncTaskFetch</code>挂钩是<code class="fe lb lc ld le b">useAsyncTask</code>的包装功能。基本实现如下。功能齐全的是GitHub存储库中的<a class="ae la" href="https://github.com/dai-shi/react-hooks-async/blob/master/src/use-async-task-fetch.js" rel="noopener ugc nofollow" target="_blank">(此处为</a>)。</p><pre class="kp kq kr ks gt mw le mx my aw mz bi"><span id="bf84" class="lf lg it le b gy na nb l nc nd">const useAsyncTaskFetch = url =&gt; useAsyncTask(<br/>  async (<strong class="le iu">abortController</strong>) =&gt; {<br/>    const response = await fetch(url, {<br/>      <strong class="le iu">signal: abortController.signal,</strong><br/>    });<br/>    if (!response.ok) {<br/>      throw new Error(response.statusText);<br/>    }<br/>    const body = await response.json();<br/>    return body;<br/>  },<br/>  <strong class="le iu">[url]</strong>,<br/>);</span></pre><p id="535e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">注意，AbortController信号被传递到<code class="fe lb lc ld le b">fetch</code>。这是因为Fetch API支持AbortController。对其他人来说，你需要实现处理它。比如这里可以看看<code class="fe lb lc ld le b">useAsyncTaskAxios</code>是如何实现<a class="ae la" href="https://github.com/dai-shi/react-hooks-async/blob/master/src/use-async-task-axios.js" rel="noopener ugc nofollow" target="_blank">的。</a></p><h2 id="9093" class="lf lg it bd lh li lj dn lk ll lm dp ln kb lo lp lq kf lr ls lt kj lu lv lw lx bi translated">摘要</h2><p id="d4b2" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">本文展示了如何实现<code class="fe lb lc ld le b">useAsyncTask</code>和其他挂钩。我希望他们在使用AbortController的约定上是直截了当的。我正在寻找除<code class="fe lb lc ld le b">fetch</code>之外的其他使用案例，如果有任何反馈，我将非常乐意。</p></div></div>    
</body>
</html>