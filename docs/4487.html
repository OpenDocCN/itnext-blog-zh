<html>
<head>
<title>Evolution of Pattern Matching up until C# 8.0</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C# 8.0之前模式匹配的发展</h1>
<blockquote>原文：<a href="https://itnext.io/evolution-of-pattern-matching-until-c-8-0-3345f8cd6306?source=collection_archive---------3-----------------------#2020-07-10">https://itnext.io/evolution-of-pattern-matching-until-c-8-0-3345f8cd6306?source=collection_archive---------3-----------------------#2020-07-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/3e270b0df6b53bbe7d49d17cbdb1ea43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*COPSdyGD2tRugbtbeSI_pA.png"/></div></div></figure><p id="0c50" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kw" href="https://gist.github.com/dimitris-papadimitriou-chr/abbe9fa04008a6d2667e1467435c0a27" rel="noopener ugc nofollow" target="_blank">来源</a></p><p id="5e67" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">什么是模式匹配？假设你有一个简单的形状层次结构</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="0bbe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在如果我给一个<code class="fe ld le lf lg b">Shape </code>变量赋值。我可以指定矩形或圆形。这里我将选择矩形</p><p id="13a9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe ld le lf lg b"><strong class="ka ir">Shape </strong>shape = new <strong class="ka ir">Rectangle </strong>{ Width = 100, Height = 100, };</code></p><blockquote class="lh li lj"><p id="9c26" class="jy jz lk ka b kb kc kd ke kf kg kh ki ll kk kl km lm ko kp kq ln ks kt ku kv ij bi translated">你如何在运行时知道我放入了什么形状？T11】</p></blockquote><p id="1e69" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">这是模式匹配想要解决的底层问题。我们将看到C# 8.0如何最终更接近于一种处理这个问题的函数式方法。</strong></p><p id="40d6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这里，我们将看到如何基于形状类型获得不同描述的不同方法。</p><h1 id="9083" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">1.使用Is关键字</h1><p id="41c7" class="pw-post-body-paragraph jy jz iq ka b kb mm kd ke kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv ij bi translated">我们可以使用if语句来处理一些非常基本的事情<strong class="ka ir">:</strong></p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div></figure><h1 id="39eb" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">2.使用switch语句</h1><p id="6bf0" class="pw-post-body-paragraph jy jz iq ka b kb mm kd ke kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv ij bi translated">从C# 7.0开始，我们可以使用switch语句来分隔子类型:</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div></figure><h1 id="1356" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">3.使用多态性</h1><p id="0fe1" class="pw-post-body-paragraph jy jz iq ka b kb mm kd ke kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv ij bi translated">是的，通过使用多态，我们可以通过调用多态方法来区分变量被赋给了哪种<code class="fe ld le lf lg b">Shape </code>类型:</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="1916" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">现在所有的箱子都移到了每个类里面。</strong></p><pre class="kx ky kz la gt mr lg ms mt aw mu bi"><span id="de33" class="mv lp iq lg b gy mw mx l my mz">var description = shape.GetShapeDescription();</span></pre><h1 id="70c1" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">4.我们可以使用自定义模式匹配</h1><p id="3b1c" class="pw-post-body-paragraph jy jz iq ka b kb mm kd ke kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv ij bi translated">现在我们将重构前面的多态性案例，以便抽象出多态性的机制！！</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="5551" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们有这个<strong class="ka ir"> MatchWith方法，我们可以用它来分离案例</strong></p><pre class="kx ky kz la gt mr lg ms mt aw mu bi"><span id="e01f" class="mv lp iq lg b gy mw mx l my mz">public abstract T <strong class="lg ir">MatchWith</strong>&lt;T&gt;(<br/>              Func&lt;Rectangle, T&gt; <strong class="lg ir">rectangleCase</strong>, <br/>              Func&lt;Circle, T&gt; circleCase);</span></pre><p id="1721" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将这样使用它:</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="1994" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以看到这与switch语句相同:</p><pre class="kx ky kz la gt mr lg ms mt aw mu bi"><span id="cb99" class="mv lp iq lg b gy mw mx l my mz">string GetShapeDescription(Shape shape)<br/>{<br/> switch (shape)<br/>  {<br/>   case Circle c:<br/>      return $"found a circle with radius {c.Radius}";<br/>   case Rectangle s:<br/>      return $"Found {s.Height }x {s.Width} rectangle";<br/>   default:<br/>      throw new System.Exception(nameof(shape));<br/>   }<br/> };</span></pre><p id="e62c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在进化的最后一步</p><h1 id="590a" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">5.使用C# 8.0模式匹配</h1><p id="ddb3" class="pw-post-body-paragraph jy jz iq ka b kb mm kd ke kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv ij bi translated">我们最终可以使用switch关键字的另一种语法进行模式匹配，而不需要之前的自定义实现:</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="a9e3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">习惯这种语法需要一些时间，但是很容易掌握。如您所见，您可以访问子类的公共属性:</p><pre class="kx ky kz la gt mr lg ms mt aw mu bi"><span id="6cbd" class="mv lp iq lg b gy mw mx l my mz">shape switch<br/> {<br/>   Rectangle { <strong class="lg ir">Height: var h</strong>, <strong class="lg ir">Width: var w </strong>} <br/>              =&gt; $"Found {h }x {w} rectangle",<br/>   Circle { <strong class="lg ir">Radius: var r</strong> } <br/>              =&gt; $"found a circle with radius {r}",<br/>}</span></pre><p id="f36a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">再举一个例子。假设我们想要缩放形状，我们可以写这个函数作为利用模式匹配的扩展</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="11af" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">像这样使用它:</p><p id="d3a4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe ld le lf lg b">var t1 = shape.<strong class="ka ir">Scale</strong>(x =&gt; x*x);</code></p><p id="ecff" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">总之:</strong></p><p id="06e1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">C#模式匹配最后带来了另一个<strong class="ka ir">功能特性</strong>，它将帮助C#开发者更自然地编写功能代码。</p></div></div>    
</body>
</html>