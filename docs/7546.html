<html>
<head>
<title>How to Build Interactive Charts in Flutter</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Flutter中创建交互式图表</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-build-interactive-charts-in-flutter-e317492d5ba1?source=collection_archive---------1-----------------------#2022-10-31">https://itnext.io/how-to-build-interactive-charts-in-flutter-e317492d5ba1?source=collection_archive---------1-----------------------#2022-10-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/5d5d765395839b6538e510e55a2ee1fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eZBYKduFDLAiCWbdpuV2rQ.jpeg"/></div></div></figure><p id="54d4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">交互在数据可视化中总是很重要。Flutter制图库<a class="ae kw" href="https://github.com/entronad/graphic" rel="noopener ugc nofollow" target="_blank"> Graphic </a>有一个精心设计的交互系统，用于各种交互图表。</p><p id="ded3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个系统是建立在几个概念之上的，当你学习这些概念时，你会发现在<a class="ae kw" href="https://github.com/entronad/graphic" rel="noopener ugc nofollow" target="_blank">图形</a>中处理交互非常容易和灵活。有些概念很新颖，但是很直观，容易理解。</p><p id="ad70" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">本文将介绍这些概念，以帮助您在Flutter中使用<a class="ae kw" href="https://github.com/entronad/graphic" rel="noopener ugc nofollow" target="_blank">图形</a>构建交互式图表。</p><h1 id="2fd4" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">手势</h1><p id="4907" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">作为一个触摸优先的GUI框架，Flutter中的交互是基于手势的。</p><p id="2437" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">手势系统有两层。第一层包含描述指针(例如，触摸、鼠标和触控笔)在屏幕上的位置和移动的原始指针事件。第二层有<em class="ma">手势</em>，描述由一个或多个指针移动组成的语义动作。请注意，手势不仅包括触摸，还包括多平台上的所有其他指针类型。</p><p id="4f63" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于<a class="ae kw" href="https://github.com/entronad/graphic" rel="noopener ugc nofollow" target="_blank"> Graphic </a>是一个小部件级别的可视化库，我们选择手势层作为交互系统的基础。<a class="ae kw" href="https://pub.dev/documentation/graphic/latest/graphic/Gesture-class.html" rel="noopener ugc nofollow" target="_blank">手势</a>类携带关于手势的信息。主要用于<a class="ae kw" href="https://pub.dev/documentation/graphic/latest/graphic/GestureSignal-class.html" rel="noopener ugc nofollow" target="_blank">手势信号</a>中</p><p id="a80a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在Flutter中广泛使用的处理手势的小工具是<a class="ae kw" href="https://api.flutter.dev/flutter/widgets/GestureDetector-class.html" rel="noopener ugc nofollow" target="_blank">手势检测器</a>。它在其回调属性中定义了所有的手势类型(像<a class="ae kw" href="https://api.flutter.dev/flutter/widgets/GestureDetector-class.html" rel="noopener ugc nofollow" target="_blank"> onTap </a>)，开发人员对它们很熟悉。所以<a class="ae kw" href="https://github.com/entronad/graphic" rel="noopener ugc nofollow" target="_blank">图形</a>继承了这个分类法。<a class="ae kw" href="https://github.com/entronad/graphic" rel="noopener ugc nofollow" target="_blank">图形</a>的<a class="ae kw" href="https://pub.dev/documentation/graphic/latest/graphic/GestureType.html" rel="noopener ugc nofollow" target="_blank">手势类型</a>与它们在手势检测器中对应的回调属性具有相同的名称(没有<code class="fe mb mc md me b">on</code>前缀)和含义，例如<code class="fe mb mc md me b">GestureType.tap</code>到<code class="fe mb mc md me b">GestureDetector.onTap</code>。这使得<a class="ae kw" href="https://github.com/entronad/graphic" rel="noopener ugc nofollow" target="_blank">图形</a>与Flutter手势系统保持一致，对开发者友好。</p><h1 id="38e5" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">信号</h1><p id="5923" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">为了表示交互，有两个抽象层次:<em class="ma">信号</em>和<em class="ma">选择</em>。这两个概念都是指织女星，然而在<a class="ae kw" href="https://github.com/entronad/graphic" rel="noopener ugc nofollow" target="_blank">图</a>中还是有一些区别的。</p><p id="5951" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kw" href="https://pub.dev/documentation/graphic/latest/graphic/Signal-class.html" rel="noopener ugc nofollow" target="_blank">信号在其他一些系统中也被称为“事件”。当用户或外部更改与图表交互时会发出这些事件。它们携带着相互作用的信息。信号主要用于更新器，如</a><a class="ae kw" href="https://pub.dev/documentation/graphic/latest/graphic/RectCoord/horizontalRangeUpdater.html" rel="noopener ugc nofollow" target="_blank">rect coord . horizontal range updater</a>，或内部触发选择。</p><p id="b354" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">虽然名称相同，但<a class="ae kw" href="https://github.com/entronad/graphic" rel="noopener ugc nofollow" target="_blank">图形</a>中的信号与织女星中的<a class="ae kw" href="https://vega.github.io/vega/docs/signals/" rel="noopener ugc nofollow" target="_blank">信号含义不同。在Vega中，信号是将可视化参数化的动态变量，这意味着无论是否有交互，它们都会持久地提供值。但是在</a><a class="ae kw" href="https://github.com/entronad/graphic" rel="noopener ugc nofollow" target="_blank">图形</a>中，信号是交互的化身，所以它们只在被触发时发生，并且携带交互的全部信息，而不仅仅是一个变量值。</p><p id="65d6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">除了用于用户交互的<a class="ae kw" href="https://pub.dev/documentation/graphic/latest/graphic/GestureSignal-class.html" rel="noopener ugc nofollow" target="_blank">手势信号</a>，还有用于影响图表的外部变化的<a class="ae kw" href="https://pub.dev/documentation/graphic/latest/graphic/ChangeDataSignal-class.html" rel="noopener ugc nofollow" target="_blank"> ChangeDataSignal </a>和<a class="ae kw" href="https://pub.dev/documentation/graphic/latest/graphic/ResizeSignal-class.html" rel="noopener ugc nofollow" target="_blank"> ResizeSignal </a>，也是广义的“交互”。</p><p id="207c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在内部，不同的信号，无论其种类或发射器，都将由缩减器广播给所有的信号更新器。这使得开发人员可以不受约束地决定更新程序将对哪个信号做出响应。</p><h1 id="a29b" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">选择</h1><p id="df57" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated"><a class="ae kw" href="https://pub.dev/documentation/graphic/latest/graphic/Selection-class.html" rel="noopener ugc nofollow" target="_blank">选择</a>是手势驱动的数据查询。它们是信号的结果。当选择被触发时，数据元组变成选中或未选中状态，因此如果定义了<code class="fe mb mc md me b">Attr.onSelection</code>，可能会导致它们的美学属性改变。</p><p id="b2e4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kw" href="https://github.com/entronad/graphic" rel="noopener ugc nofollow" target="_blank">图形</a>中的选择规则主要来源于Vega-Lite 中的<a class="ae kw" href="https://vega.github.io/vega-lite/docs/selection.html" rel="noopener ugc nofollow" target="_blank">选择，所以有</a><a class="ae kw" href="https://pub.dev/documentation/graphic/latest/graphic/IntervalSelection-class.html" rel="noopener ugc nofollow" target="_blank">inter selection</a>和<a class="ae kw" href="https://pub.dev/documentation/graphic/latest/graphic/PointSelection-class.html" rel="noopener ugc nofollow" target="_blank"> PointSelection </a>。</p><p id="4329" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">与大多数其他可视化库不同，<a class="ae kw" href="https://github.com/entronad/graphic" rel="noopener ugc nofollow" target="_blank">图形</a>中的选择是在数据值空间中测试的，而不是通过图形形状交集。指针坐标将被转换成每个维度的数据值，这些值将在数据列表中搜索以找到结果。这种方法更加“数据驱动”，在大数据中的表现优于形状相交测试。</p><p id="2653" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一般来说，信号是原始的，使用起来更灵活，而选择则更简洁，侧重于数据域。</p><h1 id="afba" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">更新程序</h1><p id="5407" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">在<a class="ae kw" href="https://github.com/entronad/graphic" rel="noopener ugc nofollow" target="_blank">图</a>中，交互如何影响图表的基本思想是，它们不直接向图表提供值，而是更新图表中现有的属性值，并导致反应式呈现。属性值的计算和更新在不同的运算符中，初始值(通常在规范中指明)将被保留:</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div class="gh gi mf"><img src="../Images/da206cc07063d95b68416228a50905c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:910/format:webp/1*Tdlm3OAzoD7Ru1cgBz5w2w.jpeg"/></div></figure><p id="fff4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">更新器是根据交互更新属性值的回调函数，如<a class="ae kw" href="https://pub.dev/documentation/graphic/latest/graphic/RectCoord/horizontalRangeUpdater.html" rel="noopener ugc nofollow" target="_blank">rect coord . horizontalangeupdater</a>或<a class="ae kw" href="https://pub.dev/documentation/graphic/latest/graphic/Attr/updaters.html" rel="noopener ugc nofollow" target="_blank"> Attr.updaters </a>。由于有两种交互，相应的也有两种更新器，<a class="ae kw" href="https://pub.dev/documentation/graphic/latest/graphic/SignalUpdater.html" rel="noopener ugc nofollow" target="_blank"> SignalUpdater </a>和<a class="ae kw" href="https://pub.dev/documentation/graphic/latest/graphic/SelectionUpdater.html" rel="noopener ugc nofollow" target="_blank"> SelectionUpdater </a>:</p><pre class="mg mh mi mj gt mk me ml mm aw mn bi"><span id="6443" class="mo ky iq me b gy mp mq l mr ms">SignalUpdater&lt;V&gt; = V Function(<br/>  V initialValue,<br/>  V preValue,<br/>  Signal signal<br/>)<br/>​<br/>SelectionUpdater&lt;V&gt; = V Function(<br/>  V initialValue<br/>)</span></pre><h1 id="7618" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">互动渠道</h1><p id="0bff" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">对于常见的交互情况，上面的特性就足够了。但是我们引入了<em class="ma">交互通道</em>用于高级用途。</p><p id="dc3e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">交互通道是与图表进行双向交流的一种方式。你可以通过它输入和输出交互信息。也就是说，您可以手动向图表发出信号或选择，并在信号或选择发生时从图表中得到注意。它使得对交互的控制更加灵活和精确。</p><p id="05ba" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了实现这一点，我们考虑了函数反应式编程(FRP)的思想。幸运的是，Dart语言内置了<a class="ae kw" href="https://dart.dev/tutorials/language/streams" rel="noopener ugc nofollow" target="_blank">异步流系统</a>，这是FRP的一个简单实现。<a class="ae kw" href="https://api.dart.dev/stable/2.18.3/dart-async/StreamController-class.html" rel="noopener ugc nofollow" target="_blank"> StreamController </a>类可以起到交互通道的作用。</p><p id="b6af" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">图表耦合是展示交互渠道优势的一个很好的领域。想想看，有两个不同的图表，耦合意味着当与一个图表交互时，另一个图表的行为相同，反之亦然。</p><p id="c3e7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，两个图表分别显示一只股票的价格和成交量，触摸其中一个图表以显示辅助线，另一个应显示相同的内容:</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/bca7ac02f0e0946a0c6c754443a1a550.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/1*XIX0un1pxoUCzflfXx58PQ.gif"/></div></figure><p id="5216" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你只需要让两个图表共享同一个手势信号通道，它们就会共享所有手势，没有任何多余的输入输出属性:</p><pre class="mg mh mi mj gt mk me ml mm aw mn bi"><span id="b67d" class="mo ky iq me b gy mp mq l mr ms">final priceVolumeChannel = StreamController&lt;GestureSignal&gt;.broadcast();<br/>​<br/>// the price chart<br/>Chart(<br/>  ...<br/>  gestureChannel: priceVolumeChannel,<br/>)<br/>​<br/>// the volume chart<br/>Chart(<br/>  ...<br/>  gestureChannel: priceVolumeChannel,<br/>)</span></pre><p id="6239" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">另一个例子是两个图表总是选择同一天:</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/a009e7d3037a90f3697b935fac30a78d.png" data-original-src="https://miro.medium.com/v2/resize:fit:796/1*NLCqJSvJyXGI2PGi-jcbMQ.gif"/></div></figure><p id="4238" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">两个元素的共享选择通道将会:</p><pre class="mg mh mi mj gt mk me ml mm aw mn bi"><span id="cd10" class="mo ky iq me b gy mp mq l mr ms">final heatmapChannel = StreamController&lt;Selected?&gt;.broadcast();<br/>​<br/>// the above chart<br/>Chart(<br/>  ...<br/>  elements: [PolygonElement(<br/>    selectionChannel: heatmapChannel,<br/>  )]<br/>)<br/>​<br/>// the below chart<br/>Chart(<br/>  ...<br/>  elements: [PolygonElement(<br/>    selectionChannel: heatmapChannel,<br/>  )]<br/>)</span></pre><p id="671f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面两个例子的完整代码这里是<a class="ae kw" href="https://github.com/entronad/graphic/blob/main/example/lib/pages/interaction_channel_dynamic.dart" rel="noopener ugc nofollow" target="_blank">这里是</a>。</p></div></div>    
</body>
</html>