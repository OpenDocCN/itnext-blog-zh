<html>
<head>
<title>You Might Not Need PropTypes in React: An Introduction to ARCcore Filter</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在React:arc core过滤器简介中，您可能不需要PropTypes</h1>
<blockquote>原文：<a href="https://itnext.io/https-medium-com-phil-kahrl-you-might-not-need-proptypes-in-react-2363a4b4179b?source=collection_archive---------0-----------------------#2018-03-01">https://itnext.io/https-medium-com-phil-kahrl-you-might-not-need-proptypes-in-react-2363a4b4179b?source=collection_archive---------0-----------------------#2018-03-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/></div><div class="ab cl jn jo hu jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ij ik il im in"><figure class="jv jw jx jy gt jz gh gi paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="gh gi ju"><img src="../Images/f1c3b5512b6feeaf19cbee9f50544722.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ycfrn4npxGJ8a6B8cA6F0Q.jpeg"/></div></div><figcaption class="kg kh gj gh gi ki kj bd b be z dk translated">滤镜让我们在嘈杂的世界里看清事物。</figcaption></figure><p id="f527" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated"><a class="ae li" href="https://www.linkedin.com/cws/share?url=https%3A%2F%2Fitnext.io%2Fhttps-medium-com-phil-kahrl-you-might-not-need-proptypes-in-react-2363a4b4179b" rel="noopener ugc nofollow" target="_blank"> <em class="lj">点击这里在LinkedIn </em>上分享这篇文章</a></p><p id="6416" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated"><a class="ae li" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank"> React库</a>在网络开发者中变得非常受欢迎。React经常使用的一个有用的附件是<a class="ae li" href="https://reactjs.org/docs/typechecking-with-proptypes.html" rel="noopener ugc nofollow" target="_blank"> PropTypes </a>，这是一种在运行时断言React组件需要什么类型的数据才能正确呈现的方法。运行时断言(如PropTypes)独立于构建时类型检查，对于测试和调试非常有用，并将大大降低复杂应用程序的维护成本。在本文中，我将首先讨论React PropTypes，然后讨论如何使用<a class="ae li" href="https://encapsule.io/docs/ARCcore/filter" rel="noopener ugc nofollow" target="_blank"> ARCcore过滤器库</a>做出类似但更好的断言。到本文结束时，您将了解如何使用ARCcore。Filter为任何JavaScript函数提供声明性类型检查，以使您的应用程序更加健壮和可维护。</p><p id="d3b3" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">首先，让我们通过一个简单的例子来讨论React属性类型。我们的示例由一个React组件组成，该组件接受一组props数据。数组中的每个对象都有一个“名称”和一个“url”成员，该组件呈现一个列表，其中列表中的每个项目都包含一个指向url的链接，该链接带有名称的链接文本。参见代码沙箱中的<a class="ae li" href="https://codesandbox.io/s/8zrjojjl2" rel="noopener ugc nofollow" target="_blank">示例代码，如下所示:</a></p><figure class="jv jw jx jy gt jz"><div class="bz fp l di"><div class="lk ll l"/></div></figure><p id="aa49" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">在该示例中,“ImageList”组件通过使用PropTypes声明来验证它正在接收数组；</p><pre class="jv jw jx jy gt lm ln lo lp aw lq bi"><span id="8ed3" class="lr ls iq ln b gy lt lu l lv lw">static propTypes = {</span><span id="25f6" class="lr ls iq ln b gy lx lu l lv lw">  renderData: PropTypes.objectOf(</span><span id="35b2" class="lr ls iq ln b gy lx lu l lv lw">    PropTypes.arrayOf(</span><span id="26ca" class="lr ls iq ln b gy lx lu l lv lw">    PropTypes.shape({</span><span id="c9b6" class="lr ls iq ln b gy lx lu l lv lw">      url: PropTypes.string.isRequired,</span><span id="3852" class="lr ls iq ln b gy lx lu l lv lw">      name: PropTypes.string.isRequired</span><span id="cd7e" class="lr ls iq ln b gy lx lu l lv lw">    })</span><span id="6821" class="lr ls iq ln b gy lx lu l lv lw">  ))};</span></pre><p id="70f1" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">使用PropTypes声明，如果向组件传递的参数不是“renderData”属性的数组，或者如果数组的元素不包含字符串“url”和“name ”,控制台将记录一个错误，警告我违反了组件的数据协定。</p><p id="fe7b" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">您可以通过将第6行的prop类型更改为:</p><pre class="jv jw jx jy gt lm ln lo lp aw lq bi"><span id="5148" class="lr ls iq ln b gy lt lu l lv lw">renderData: PropTypes.objectOf(PropTypes.object)</span></pre><p id="7050" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">重新加载页面，查看JavaScript控制台，您会看到如下错误:</p><pre class="jv jw jx jy gt lm ln lo lp aw lq bi"><span id="3ee8" class="lr ls iq ln b gy lt lu l lv lw">Warning: Failed prop type: Invalid prop `renderData.imageList` of type `array` supplied to `ImageList`, expected `object`. in ImageList (created by App) in App</span></pre><p id="47e1" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">因为我想对PropTypes进行深度类型检查，所以我需要使用PropTypes的“shape”函数。</p><pre class="jv jw jx jy gt lm ln lo lp aw lq bi"><span id="880d" class="lr ls iq ln b gy lt lu l lv lw">PropTypes.shape({</span><span id="6699" class="lr ls iq ln b gy lx lu l lv lw">    url: PropTypes.string.isRequired,</span><span id="1462" class="lr ls iq ln b gy lx lu l lv lw">    name: PropTypes.string.isRequired</span><span id="99c0" class="lr ls iq ln b gy lx lu l lv lw">})</span></pre><p id="9d11" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated"><a class="ae li" href="https://encapsule.io/docs/ARCcore/filter" rel="noopener ugc nofollow" target="_blank"> ARCcore过滤器</a>库提供了一种更好的方法，通过它的“过滤器规范”机制来指定对象形状。描述ImageList组件所需数据的筛选器规范示例如下所示:</p><pre class="jv jw jx jy gt lm ln lo lp aw lq bi"><span id="62b0" class="lr ls iq ln b gy lt lu l lv lw">inputFilterSpec: {</span><span id="bfd2" class="lr ls iq ln b gy lx lu l lv lw">  ____label: "ImageList filter spec",</span><span id="a39b" class="lr ls iq ln b gy lx lu l lv lw">  ____description: "Filter spec for props for the image list view",</span><span id="717d" class="lr ls iq ln b gy lx lu l lv lw">  ____types: "jsObject", //The entity below is an object</span><span id="b990" class="lr ls iq ln b gy lx lu l lv lw">  imageList: {</span><span id="6927" class="lr ls iq ln b gy lx lu l lv lw">    ____types: "jsArray",  //The object has an imageList array</span><span id="a1ac" class="lr ls iq ln b gy lx lu l lv lw">    element: {</span><span id="13f3" class="lr ls iq ln b gy lx lu l lv lw">      ____types: "jsObject",  //Each array element must be an object</span><span id="fd43" class="lr ls iq ln b gy lx lu l lv lw">      url: {</span><span id="2ab8" class="lr ls iq ln b gy lx lu l lv lw">        ____accept: "jsString" //The object has a string 'url'</span><span id="e088" class="lr ls iq ln b gy lx lu l lv lw">       },</span><span id="17c0" class="lr ls iq ln b gy lx lu l lv lw">       name: {</span><span id="a5fd" class="lr ls iq ln b gy lx lu l lv lw">         ____accept: "jsString" //The object has a string 'name'</span><span id="34f8" class="lr ls iq ln b gy lx lu l lv lw">       }</span><span id="7c3e" class="lr ls iq ln b gy lx lu l lv lw">     }</span><span id="5fcf" class="lr ls iq ln b gy lx lu l lv lw">   }</span><span id="716f" class="lr ls iq ln b gy lx lu l lv lw">}</span></pre><p id="11e8" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated"><a class="ae li" href="https://encapsule.io/docs/ARCcore/filter/specs" rel="noopener ugc nofollow" target="_blank">过滤器规范</a>只是一个JavaScript对象。对象中以<em class="lj"> quanderscore </em> "____ "开头的字段有特殊的含义。前两个字段' ___label '和' ____description '是描述过滤器规格的可选字段。下一个字段:</p><pre class="jv jw jx jy gt lm ln lo lp aw lq bi"><span id="6126" class="lr ls iq ln b gy lt lu l lv lw">____types: “jsObject”</span></pre><p id="30cc" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">表示下面要描述的东西是一个物体。该对象被进一步指定，因为它将包含一个名为“imageList”的成员，并且该列表的每个元素将包含“url”和“name”的键，这两个键都是字符串。过滤器规范的格式将让我们指定任意复杂的对象，通过查看过滤器规范，我们可以很容易地看到该对象的形状。</p><p id="f808" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">使用对象而不是嵌套函数来指定输入有几个优点。一个是对象只是数据，而不是代码，这使得规范是声明性的。不需要为对象编写测试，解析对象(ARCcore过滤器)的代码有自己的测试，以确保根据过滤器规格正确验证输入。对象易于阅读，可以根据需要导入、序列化、通过网络发送和共享。</p><p id="3417" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">过滤器规格只是对象，本身不做任何事情，但作为功能的一部分来实现一个<a class="ae li" href="https://encapsule.io/docs/ARCcore/filter" rel="noopener ugc nofollow" target="_blank"> ARCcore过滤器</a>。ARCcore Filter只是一个函数包装器；它有两种滤波器规格，一种用于输入，一种用于输出。它还具有接受输入、产生和输出的身体功能。由于我们只对这个例子中的类型验证感兴趣，我们可以创建一个带有空体函数的过滤器，使用上面的过滤器规范来进行类型验证。</p><p id="829f" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">使用上面的过滤器规范，我可以编写一个简单的ARCcore过滤器，在一个自定义验证器中调用它，我可以将它用于我的组件PropType。参见<a class="ae li" href="https://codesandbox.io/s/zx48po911m" rel="noopener ugc nofollow" target="_blank">这里的代码沙箱示例</a>，也如下所示。</p><figure class="jv jw jx jy gt jz"><div class="bz fp l di"><div class="lk ll l"/></div><figcaption class="kg kh gj gh gi ki kj bd b be z dk translated">带有使用ARCcore过滤器实现的自定义验证器的PropType示例。</figcaption></figure><p id="2838" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">在进一步讨论之前，我们先来详细讨论一下什么是ARCcore滤波器。</p><ol class=""><li id="73dc" class="ly lz iq km b kn ko kr ks kv ma kz mb ld mc lh md me mf mg bi translated">ARCcore过滤器是一种复合函数(函数链)。每次调用过滤器时都会调用三个函数。一个函数根据inputFilterSpec验证输入，另一个函数是过滤器的编写器提供的bodyFunction，第三个函数根据outputFilterSpec验证body函数的输出。</li><li id="fce7" class="ly lz iq km b kn mh kr mi kv mj kz mk ld ml lh md me mf mg bi translated">要创建新的过滤器，您需要调用工厂函数“arccore.filter.create”(上面代码中的第3行)。工厂函数被传递一个对象，该对象包括输入和输出过滤器规范、主体函数和一些其他元数据，包括唯一标识符(第4行)以及名称和描述(第4和第5行)。与过滤器类似，过滤器的工厂函数返回一个带有“错误”和“结果”成员的对象。</li><li id="762b" class="ly lz iq km b kn mh kr mi kv mj kz mk ld ml lh md me mf mg bi translated">过滤器总是返回带有“结果”和“错误”成员的对象。如果错误成员为非空，则可以使用结果。</li><li id="96ef" class="ly lz iq km b kn mh kr mi kv mj kz mk ld ml lh md me mf mg bi translated">调用过滤器的模式是通过请求方法将数据传递给过滤器，检查是否有错误，如果错误为空，则使用结果。</li><li id="aa5c" class="ly lz iq km b kn mh kr mi kv mj kz mk ld ml lh md me mf mg bi translated">过滤器的有用工作是通过实现body函数来完成的。在这个例子中，bodyFunction很简单，因为我们只对输入的类型验证感兴趣。</li></ol><p id="6429" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">使用ARCcore过滤器为PropTypes创建一个自定义验证器可以省去为类型检查编写实际函数的工作。Filter Spec本身只是一个对象，所以现在我的类型检查变成了声明性的，我可以指定任何复杂程度的类型检查。</p><p id="2742" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">要了解类型验证是如何工作的，请参见上面的沙箱。在“App.js”中，更改数组中的一个对象，如第6行所示:</p><pre class="jv jw jx jy gt lm ln lo lp aw lq bi"><span id="4fdf" class="lr ls iq ln b gy lt lu l lv lw">{</span><span id="a66e" class="lr ls iq ln b gy lx lu l lv lw">name-1: "cat",</span><span id="022c" class="lr ls iq ln b gy lx lu l lv lw">url: "https://static.pexels.com/photos/20787/pexels-photo.jpg"</span><span id="b10b" class="lr ls iq ln b gy lx lu l lv lw">}</span></pre><p id="91f6" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">现在，其中一个对象的成员是“名称-1”，而不是“名称”。重新加载渲染页面将在控制台中产生以下错误:</p><pre class="jv jw jx jy gt lm ln lo lp aw lq bi"><span id="2004" class="lr ls iq ln b gy lt lu l lv lw">Warning: Failed prop type: Filter [3RR5VT_5TBWuzX_VhMG4dQ::ImageDisplayPropsFilter] failed while normalizing request input. Error at path '~.imageList[0].name': Value of type 'jsUndefined' not in allowed type set [jsString].     in ImageList (created by App)     in App</span></pre><p id="e81d" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">该消息告诉您数据中违反了什么约束，以及违反来自哪个过滤器。消息中operationId的存在使得即使在大型代码库中也能够容易地找到过滤器。</p><p id="f13d" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">所以现在我们有了深度类型验证，可以通过修改过滤器规范来轻松更改。Filter的另一个特性是，它不通过任何不在Filter规范中的内容，换句话说，它过滤掉不需要的成员，同时验证需要的成员。</p><p id="57e2" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">这可能是宣布胜利和停止写作的好时机，但只有一个问题。PropTypes和ARCcore Filter之间有很多重叠。如果您为React组件声明了一个PropType，那么当React开始呈现该组件时，If首先调用一个函数来验证props，然后它调用该组件作为一个函数来实际呈现。以类似的方式，如果您有一个过滤器，首先调用一个函数来验证输入，然后对该输入运行一个函数，返回一个结果。具有PropTypes的React组件和ARCcore过滤器都在做同样的事情，因为它们将函数链接在一起；一个函数用于验证输入，另一个函数用于实际操作并返回结果。除了在应用程序中复制功能，我们还可以做得更好，那么为什么不干脆用Filter做所有的事情，完全不用PropTypes呢？我们可以简单地创建一个过滤器，使用上面的过滤器规范，它有一个body函数，使用导入到过滤器中的原始组件返回呈现的内容。现在，任何想要呈现ImageList的组件都可以简单地调用我们创建的过滤器(呈现过滤器)，而不是直接调用ImageList。通过调用渲染过滤器，我们可以保证传递正确类型的数据，并处理任何错误。我们使用渲染过滤器的应用程序可以在下面的代码沙箱中看到:</p><figure class="jv jw jx jy gt jz"><div class="bz fp l di"><div class="lk ll l"/></div><figcaption class="kg kh gj gh gi ki kj bd b be z dk translated">使用ARCcore过滤器进行渲染消除了对属性类型的需求</figcaption></figure><p id="62a5" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">在上述沙箱的“App.js”中，注意调用过滤器并使用三元运算符呈现结果的模式。</p><pre class="jv jw jx jy gt lm ln lo lp aw lq bi"><span id="a5e5" class="lr ls iq ln b gy lt lu l lv lw">const renderingResponse = ImageListRenderingFilter.request({</span><span id="9ee7" class="lr ls iq ln b gy lx lu l lv lw">    imageList: images</span><span id="1fca" class="lr ls iq ln b gy lx lu l lv lw">});</span><span id="5867" class="lr ls iq ln b gy lx lu l lv lw">const renderResult = renderingResponse.error ? (</span><span id="595b" class="lr ls iq ln b gy lx lu l lv lw">    &lt;div&gt;{renderingResponse.error}&lt;/div&gt;</span><span id="408d" class="lr ls iq ln b gy lx lu l lv lw">) : (</span><span id="167b" class="lr ls iq ln b gy lx lu l lv lw">    renderingResponse.result</span><span id="f342" class="lr ls iq ln b gy lx lu l lv lw">);</span><span id="2426" class="lr ls iq ln b gy lx lu l lv lw">return &lt;div&gt;{renderingResponse.result}&lt;/div&gt;;</span></pre><p id="a418" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">我们通过调用“请求”函数将数据传递给过滤器。该请求返回一个带有“结果”和“错误”成员的对象。如果“错误”不为空，我们将得到一个可以使用的“结果”。这种模式积极地检测错误，并以一致的方式报告它们。这类似于我们在为组件使用PropTypes时的模式，只是我们对此更加明确。</p><p id="3046" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">到目前为止，我们已经讨论了PropTypes和ARCcore Filter，下面是两者之间的比较。</p><h2 id="ad88" class="lr ls iq bd mm mn mo dn mp mq mr dp ms kv mt mu mv kz mw mx my ld mz na nb nc bi translated">在调用函数之前使用函数链来验证输入？</h2><p id="86db" class="pw-post-body-paragraph kk kl iq km b kn nd kp kq kr ne kt ku kv nf kx ky kz ng lb lc ld nh lf lg lh ij bi translated">两者都这样做。</p><h2 id="9b7a" class="lr ls iq bd mm mn mo dn mp mq mr dp ms kv mt mu mv kz mw mx my ld mz na nb nc bi translated">声明有效输入的方式？</h2><p id="3870" class="pw-post-body-paragraph kk kl iq km b kn nd kp kq kr ne kt ku kv nf kx ky kz ng lb lc ld nh lf lg lh ij bi translated">PropTypes:可用简单类型、嵌套函数或编写自定义函数。</p><p id="a894" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">ARCCore过滤器:使用对象进行声明</p><h2 id="2e5f" class="lr ls iq bd mm mn mo dn mp mq mr dp ms kv mt mu mv kz mw mx my ld mz na nb nc bi translated">可以用在哪里？</h2><p id="0a71" class="pw-post-body-paragraph kk kl iq km b kn nd kp kq kr ne kt ku kv nf kx ky kz ng lb lc ld nh lf lg lh ij bi translated">PropTypes:测试环境中React组件上的props。</p><p id="f284" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">ARCcore过滤器:JavaScript中的任何地方。</p><h2 id="8361" class="lr ls iq bd mm mn mo dn mp mq mr dp ms kv mt mu mv kz mw mx my ld mz na nb nc bi translated">错误处理？</h2><p id="ed47" class="pw-post-body-paragraph kk kl iq km b kn nd kp kq kr ne kt ku kv nf kx ky kz ng lb lc ld nh lf lg lh ij bi translated">PropTypes:仅在开发环境中将错误记录到控制台。</p><p id="ba94" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">ARCcore Filter:强制程序员显式处理错误。</p><p id="2bd9" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">简而言之，ARCcore Filter类似于PropTypes，只是它是一种更通用的解决方案，并且以声明方式执行数据验证。</p><h1 id="b473" class="ni ls iq bd mm nj nk nl mp nm nn no ms np nq nr mv ns nt nu my nv nw nx nb ny bi translated">过滤器规格有趣的事实</h1><p id="8167" class="pw-post-body-paragraph kk kl iq km b kn nd kp kq kr ne kt ku kv nf kx ky kz ng lb lc ld nh lf lg lh ij bi translated">您可以为单个成员指定多个允许的类型，例如:</p><pre class="jv jw jx jy gt lm ln lo lp aw lq bi"><span id="4fe9" class="lr ls iq ln b gy lt lu l lv lw">____accept: ['jsString', 'jsNull', 'jsUndefined']</span></pre><p id="e9db" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">您可以为树的任何部分指定默认值:</p><pre class="jv jw jx jy gt lm ln lo lp aw lq bi"><span id="ad8d" class="lr ls iq ln b gy lt lu l lv lw">____types: 'jsObject',<br/>____defaultValue: {foo: {bar: 'baz'}, {aNumber: 1}},</span></pre><p id="2c77" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">以上对于生成符合规范的数据集非常方便。</p><p id="8e64" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">您可以指定一组允许的值:</p><pre class="jv jw jx jy gt lm ln lo lp aw lq bi"><span id="d398" class="lr ls iq ln b gy lt lu l lv lw">____inValueSet: ['ready', 'waiting', 'error']</span></pre><p id="b0c4" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">或范围:</p><pre class="jv jw jx jy gt lm ln lo lp aw lq bi"><span id="5845" class="lr ls iq ln b gy lt lu l lv lw">____inRangeInclusive: { begin: 0, end: 100 }</span></pre><p id="01bb" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">更多细节见F <a class="ae li" href="https://encapsule.io/docs/ARCcore/filter/specs" rel="noopener ugc nofollow" target="_blank">过滤器规格文件</a>。</p><h2 id="bb94" class="lr ls iq bd mm mn mo dn mp mq mr dp ms kv mt mu mv kz mw mx my ld mz na nb nc bi translated">运行时断言的优势</h2><p id="6505" class="pw-post-body-paragraph kk kl iq km b kn nd kp kq kr ne kt ku kv nf kx ky kz ng lb lc ld nh lf lg lh ij bi translated">上面的例子是一个基本的例子，通过编写一个“渲染过滤器”可以用ARCcore过滤器做什么。ARCcore Filter提供了一个内置运行时断言的函数包装器。向代码中添加运行时断言最初会增加更多的工作量，但从长期来看会降低代码库的总拥有成本。请考虑以下几点:</p><ol class=""><li id="103a" class="ly lz iq km b kn ko kr ks kv ma kz mb ld mc lh md me mf mg bi translated">您的大部分精力不是花在编写代码的前期成本上，而是花在维护代码上。如果事情尽可能明确，包括明确的错误处理和类型声明，代码的维护和调试就会容易得多。</li><li id="76c8" class="ly lz iq km b kn mh kr mi kv mj kz mk ld ml lh md me mf mg bi translated">web应用程序的祸根是不一致性。许多web应用程序似乎使用无效数据，并且只会以难以调试的微妙方式显示错误。调试行为不一致的应用程序是极其困难和耗时的。</li><li id="d80e" class="ly lz iq km b kn mh kr mi kv mj kz mk ld ml lh md me mf mg bi translated">许多数据依赖是通过异步请求来满足的，在异步请求中，静态类型不提供任何安全性。</li><li id="fe6e" class="ly lz iq km b kn mh kr mi kv mj kz mk ld ml lh md me mf mg bi translated">轻松做出断言的能力使得测试更加容易，只有测试才能保证代码中没有错误。</li><li id="24d1" class="ly lz iq km b kn mh kr mi kv mj kz mk ld ml lh md me mf mg bi translated">生产应用程序中的运行时断言提供了一种优雅地处理错误的方法。</li></ol><p id="390f" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">以下是ARCcore过滤器可用于的一些其他用途:</p><ol class=""><li id="af37" class="ly lz iq km b kn ko kr ks kv ma kz mb ld mc lh md me mf mg bi translated">在web应用程序中的呈现组件和异步API之间建立显式数据协定。</li><li id="a8a6" class="ly lz iq km b kn mh kr mi kv mj kz mk ld ml lh md me mf mg bi translated">构建防止退化的共享组件库。</li><li id="8406" class="ly lz iq km b kn mh kr mi kv mj kz mk ld ml lh md me mf mg bi translated">组成复杂的对象层次结构。</li><li id="3f38" class="ly lz iq km b kn mh kr mi kv mj kz mk ld ml lh md me mf mg bi translated">用基于消息的路由构建插件系统。</li></ol><p id="dc2b" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">到目前为止，您应该对ARCcore Filter的工作原理有所了解，它可以用来改进JavaScript中的任何代码库。本文中提供的示例只是ARCcore Filter的皮毛。更多关于ARCcore Filter以及其他有用库的信息可以在<a class="ae li" href="https://encapsule.io" rel="noopener ugc nofollow" target="_blank"> encapsule.io </a>找到。</p></div></div>    
</body>
</html>