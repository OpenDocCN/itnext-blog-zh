<html>
<head>
<title>JavaScript Event Listeners: Delegation vs. Closures</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript事件监听器:委托与闭包</h1>
<blockquote>原文：<a href="https://itnext.io/javascript-event-listeners-delegation-vs-closures-8fe52ac49872?source=collection_archive---------2-----------------------#2019-09-28">https://itnext.io/javascript-event-listeners-delegation-vs-closures-8fe52ac49872?source=collection_archive---------2-----------------------#2019-09-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="246b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何向一组重复的DOM元素添加事件侦听器</h2></div></div><div class="ab cl kf kg hu kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="ij ik il im in"><p id="3ac4" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">我在JavaScript-land的年轻旅程中遇到的一个常见任务是向重复的DOM元素添加事件侦听器。例如，如果我们在DOM上有一个带有一串<li>的列表，我们可能希望当我们点击它时，其中一个</li><li>会发生一些事情。也许我们想改变</li><li>的颜色，或者制作动画，甚至从DOM中移除它。我们需要一种方法来监听每个</li><li>上的事件，然后能够根据哪个</li><li>被点击来执行适当的动作。根据我的经验，有两种好方法可以做到这一点:使用一种叫做委托的方法，以及利用闭包。在这篇文章中，我将简要介绍每种方法，解释它们的区别，最后深入研究一些代码。</li></p><h1 id="37d1" class="li lj iq bd lk ll lm ln lo lp lq lr ls jw lt jx lu jz lv ka lw kc lx kd ly lz bi translated">什么是委托？</h1><p id="7895" class="pw-post-body-paragraph km kn iq ko b kp ma jr kr ks mb ju ku kv mc kx ky kz md lb lc ld me lf lg lh ij bi translated">当我们使用委托时，我们<strong class="ko ir">委托</strong>监听单个父元素的事件任务，该父元素包含我们想要处理事件的所有其他元素。如果我们有一个包含许多&lt; li &gt;的&lt; ul &gt;，并且我们想要监听每个&lt; li &gt;上的事件，我们可以在整个&lt; ul &gt;上放置一个事件监听器，从而将每个&lt; li &gt;的事件监听任务委托给整个&lt; ul &gt;。然后，当用户点击&lt; ul &gt;时，在执行任何任务之前，我们首先检查他们是否点击了&lt; li &gt;(而不是&lt; ul &gt;中的其他元素/空格)。这里非常重要的一点是，我们找到了我们所有的&lt; li &gt;的最小稳定父节点。如果我们的&lt; ul &gt;在HTML上，我们可以更有信心它——以及事件监听器——将一直在那里，而&lt; li &gt; s是动态的，可能来来去去。<br/> <em class="mf">(关于事件委托的更详细解释，请查看本文</em> <a class="ae mg" href="https://medium.com/@bretdoucette/part-4-what-is-event-delegation-in-javascript-f5c8c0de2983" rel="noopener"> <em class="mf">。</em> </a> <em class="mf"> ) </em></p><h1 id="5596" class="li lj iq bd lk ll lm ln lo lp lq lr ls jw lt jx lu jz lv ka lw kc lx kd ly lz bi translated">什么是终结？</h1><p id="2eb8" class="pw-post-body-paragraph km kn iq ko b kp ma jr kr ks mb ju ku kv mc kx ky kz md lb lc ld me lf lg lh ij bi translated">闭包是JavaScript和许多其他编程语言的重要组成部分。不涉及太多细节，闭包控制哪些变量可用于特定函数。记住，对于事件监听器，我们传递一个回调函数作为参数。根据我们定义事件监听器的位置，它的回调函数将访问不同的变量。如果我们有一个获取后端数据的代码块，并为每段数据创建一个新的&lt; li &gt;，我们也可以在同一个代码块中为每个&lt; li &gt;附加一个事件监听器。如果我们这样做，<strong class="ko ir">的每个事件监听器的回调函数都将访问我们用来制作【李】&gt; </strong>的具体数据。现在可能还不清楚，但是稍后您将通过编码示例了解为什么这很有用。<br/> ( <em class="mf">闭包是事件侦听器之外的一个非常重要的概念，在许多编程语言中都很普遍。关于JavaScript中闭包的更多信息，请阅读本文</em><a class="ae mg" href="https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-closure-b2f0d2152b36" rel="noopener"><em class="mf"/></a><em class="mf">。)</em></p><h1 id="797b" class="li lj iq bd lk ll lm ln lo lp lq lr ls jw lt jx lu jz lv ka lw kc lx kd ly lz bi translated">有什么区别？</h1><p id="cdc7" class="pw-post-body-paragraph km kn iq ko b kp ma jr kr ks mb ju ku kv mc kx ky kz md lb lc ld me lf lg lh ij bi translated">委托和使用闭包之间有一些关键的区别——有些很明显，有些不太明显:</p><ol class=""><li id="e7a4" class="mh mi iq ko b kp kq ks kt kv mj kz mk ld ml lh mm mn mo mp bi translated">委托只创建一个事件监听器，而利用闭包会导致每个元素都有一个事件监听器<em class="mf">(例如，每个&lt; li &gt;)。</em></li><li id="a65b" class="mh mi iq ko b kp mq ks mr kv ms kz mt ld mu lh mm mn mo mp bi translated">因为委托只使用一个事件侦听器，所以它使用的内存很少。当使用闭包时，每个新的事件侦听器(以及事件侦听器中定义的任何回调函数)都有自己的一块内存，因此使用了更多的内存空间。</li><li id="47f5" class="mh mi iq ko b kp mq ks mr kv ms kz mt ld mu lh mm mn mo mp bi translated">通过委托，事件侦听器被附加到一个稳定的HTML元素。当使用闭包时，事件侦听器通常被附加到动态DOM元素上，这使得它们不太稳定。</li><li id="2abb" class="mh mi iq ko b kp mq ks mr kv ms kz mt ld mu lh mm mn mo mp bi translated">对于委托，我们需要以一种允许我们跟踪信息的方式设置我们的代码，否则事件侦听器的回调函数将无法访问这些信息。使用闭包的事件侦听器更有针对性，我们不必担心我们的代码跟踪信息，因为如果我们做得对，事件侦听器的回调将已经有了它需要的信息。</li></ol><p id="f194" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">根据应用程序的规模，内存问题可能会变得非常重要，但对于大多数简单的应用程序来说，这不是一个大问题。最后一点是我倾向于尽可能使用闭包的原因。下面的编码示例将很好地说明这一点。</p><h1 id="b04c" class="li lj iq bd lk ll lm ln lo lp lq lr ls jw lt jx lu jz lv ka lw kc lx kd ly lz bi translated">给我看看代码</h1><figure class="mw mx my mz gt na gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi mv"><img src="../Images/d049a7406ca7009b09cf49b7e6ebe8dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*uYrBdWrF6W_3M_ue.png"/></div></div></figure><p id="bb56" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">让我们用这两种方法来解决同一个任务。该任务将是上面的<ul> / <li>示例的稍微复杂的版本，但是它将更好地解释两种方法之间的差异。它还将展示我们可能希望在前端应用程序中构建的更真实的功能。</li></ul></p><p id="bf96" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">任务是:我们有一个装箱单应用程序，允许用户跟踪他们需要为旅行打包的物品。在页面加载时，用户应该可以在新的&lt; li &gt;中看到页面上显示的每个项目。每个&lt;李&gt;都应该带有一个删除&lt;按钮&gt;，这样当用户打包该物品时，就可以通过点击删除按钮来删除该物品。</p><p id="fd0a" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">对于这个任务，让我们假设在我们的HTML中有下面的<ul>元素:</ul></p><pre class="mw mx my mz gt nh ni nj nk aw nl bi"><span id="38d2" class="nm lj iq ni b gy nn no l np nq">&lt;ul id="items-list"&gt;<br/>    // &lt;li&gt;s will go here<br/>&lt;/ul&gt;</span></pre><p id="1018" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">好了，我们开始吧！</p><h2 id="c68f" class="nm lj iq bd lk nr ns dn lo nt nu dp ls kv nv nw lu kz nx ny lw ld nz oa ly ob bi translated">使用委托</h2><p id="834f" class="pw-post-body-paragraph km kn iq ko b kp ma jr kr ks mb ju ku kv mc kx ky kz md lb lc ld me lf lg lh ij bi translated">当我们创建所有新元素并将所有内容添加到DOM中时，我们的DOM应该有一个基本结构:</p><pre class="mw mx my mz gt nh ni nj nk aw nl bi"><span id="8e0f" class="nm lj iq ni b gy nn no l np nq">&lt;ul id="items-list"&gt;<br/>    &lt;li&gt;Item 1&lt;button&gt;x&lt;/button&gt;&lt;/li&gt;<br/>    &lt;li&gt;Item 2&lt;button&gt;x&lt;/button&gt;&lt;/li&gt;<br/>    &lt;li&gt;Item 3&lt;button&gt;x&lt;/button&gt;&lt;/li&gt;<br/>    ...<br/>&lt;/ul&gt;</span></pre><p id="927e" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">如果所有用户的项目都存储在我们的后端，那么要生成上面的DOM，我们可能要做这样的事情:</p><pre class="mw mx my mz gt nh ni nj nk aw nl bi"><span id="d4ee" class="nm lj iq ni b gy nn no l np nq">const itemsUl = document.querySelector("#items-list");</span><span id="1695" class="nm lj iq ni b gy oc no l np nq">fetch("http://localhost:3000/items")<br/>.then(res =&gt; res.json())<br/>.then(itemsArr =&gt; {<br/>    itemsArr.forEach(item =&gt; {<br/>        let itemLi = document.createElement("li");<br/>        itemLi.innerText = item.name;<br/>        itemsUl.append(itemLi);<br/>        <br/>        let deleteButton = document.createElement("button");<br/>        deleteButton.innerText = "x";<br/>        itemLi.append(deleteButton);<br/>    });<br/>});</span></pre><p id="dcb7" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">现在，我们想要监听<li>中的删除<button>的点击。所以我们找到所有删除<buttons>(来自源HTML的<ul>)的最小稳定父节点，并给它一个事件监听器:</ul></buttons></button></li></p><pre class="mw mx my mz gt nh ni nj nk aw nl bi"><span id="245c" class="nm lj iq ni b gy nn no l np nq">itemsUl.addEventListener("click", evt =&gt; {</span><span id="62b0" class="nm lj iq ni b gy oc no l np nq">});</span></pre><p id="42bf" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">然后，我们检查被点击的是否是一个<button>:</button></p><pre class="mw mx my mz gt nh ni nj nk aw nl bi"><span id="eacc" class="nm lj iq ni b gy nn no l np nq">itemsUl.addEventListener("click", evt =&gt; {<br/>    if (evt.target.tagName === "BUTTON") {</span><span id="381c" class="nm lj iq ni b gy oc no l np nq">    };<br/>});</span></pre><p id="eb76" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">现在，如果点击了delete <button>，我们希望<strong class="ko ir">从数据库和DOM中删除相关的条目。</strong>要从数据库中删除，我们需要对服务器进行适当的提取。如果我们假设我们的后端是RESTful的，我们的获取看起来会像这样:</button></p><pre class="mw mx my mz gt nh ni nj nk aw nl bi"><span id="057d" class="nm lj iq ni b gy nn no l np nq">itemsUl.addEventListener("click", evt =&gt; {<br/>    if (evt.target.tagName === "BUTTON") {<br/>        fetch("http://localhost:3000/items/*item id*", {<br/>            method: "DELETE"<br/>        });<br/>    };<br/>});</span></pre><p id="9994" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">但是等等，放在获取url中的商品id是什么？我们如何找到它？嗯，我们可能有几种方法可以做到这一点，但我认为最简单的方法是在制作时给每个&lt;按钮&gt;添加一个<a class="ae mg" href="https://developer.mozilla.org/en-US/docs/Learn/HTML/Howto/Use_data_attributes" rel="noopener ugc nofollow" target="_blank">数据属性</a>，然后给该属性赋予一个等于相关项目id的值。为此，我们在制作每个&lt;按钮&gt;时添加一行代码:</p><pre class="mw mx my mz gt nh ni nj nk aw nl bi"><span id="a6bd" class="nm lj iq ni b gy nn no l np nq">deleteButton.dataset.itemId = item.id;</span></pre><p id="73b5" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">所以现在原始块看起来像这样:</p><pre class="mw mx my mz gt nh ni nj nk aw nl bi"><span id="a30e" class="nm lj iq ni b gy nn no l np nq">const itemsUl = document.querySelector("#items-list");</span><span id="f7bf" class="nm lj iq ni b gy oc no l np nq">fetch("http://localhost:3000/items")<br/>.then(res =&gt; res.json())<br/>.then(itemsArr =&gt; {<br/>    itemsArr.forEach(item =&gt; {<br/>        let itemLi = document.createElement("li");<br/>        itemLi.innerText = item.name;<br/>        itemsUl.append(itemLi);<br/>        <br/>        let deleteButton = document.createElement("button");<br/>        deleteButton.innerText = "x";<br/>        deleteButton.dataset.itemId = item.id;<br/>        itemLi.append(deleteButton);<br/>    });<br/>});</span></pre><p id="89f7" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">现在，当我们单击删除<button>时，我们可以访问关联项目的id，并可以在我们对服务器的提取中使用它:</button></p><pre class="mw mx my mz gt nh ni nj nk aw nl bi"><span id="3d03" class="nm lj iq ni b gy nn no l np nq">itemsUl.addEventListener("click", evt =&gt; {<br/>    if (evt.target.tagName === "BUTTON") {<br/>        let id = evt.target.dataset.itemId;<br/>        fetch(`http://localhost:3000/items/${id}`, {<br/>            method: "DELETE"<br/>        });<br/>    };<br/>});</span></pre><p id="2e23" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">完美。假设我们的后端工作正常，这应该会从数据库中删除该项目。现在(<a class="ae mg" href="https://medium.com/@duncandevs/ui-rendering-optimistic-vs-pessimistic-e8e0f4df264" rel="noopener">悲观地</a>)将&lt;李&gt;从DOM中移除:</p><pre class="mw mx my mz gt nh ni nj nk aw nl bi"><span id="096c" class="nm lj iq ni b gy nn no l np nq">itemsUl.addEventListener("click", evt =&gt; {<br/>    if (evt.target.tagName === "BUTTON") {<br/>        let id = evt.target.dataset.itemId;<br/>        fetch(`http://localhost:3000/items/${id}`, {<br/>            method: "DELETE"<br/>        })<br/>        .then(() =&gt; {<br/>            let li = evt.target.parentNode;<br/>            li.remove();<br/>        });<br/>    };<br/>});</span></pre><p id="be7a" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">我们找到了<button>的父节点，也就是项目<li>，然后从DOM中移除整个</li><li>。将所有内容放在一起，我们的最终代码如下所示:</li></button></p><pre class="mw mx my mz gt nh ni nj nk aw nl bi"><span id="5d45" class="nm lj iq ni b gy nn no l np nq">const itemsUl = document.querySelector("#items-list");</span><span id="1d43" class="nm lj iq ni b gy oc no l np nq">fetch("http://localhost:3000/items")<br/>.then(res =&gt; res.json())<br/>.then(itemsArr =&gt; {<br/>    itemsArr.forEach(item =&gt; {<br/>        let itemLi = document.createElement("li");<br/>        itemLi.innerText = item.name;<br/>        itemsUl.append(itemLi);<br/>        <br/>        let deleteButton = document.createElement("button");<br/>        deleteButton.innerText = "x";<br/>        deleteButton.dataset.itemId = item.id;<br/>        itemLi.append(deleteButton);<br/>    });<br/>});</span><span id="ea90" class="nm lj iq ni b gy oc no l np nq">itemsUl.addEventListener("click", evt =&gt; {<br/>    if (evt.target.tagName === "BUTTON") {<br/>        let id = evt.target.dataset.itemId;<br/>        fetch(`http://localhost:3000/items/${id}`, {<br/>            method: "DELETE"<br/>        })<br/>        .then(() =&gt; {<br/>            let li = evt.target.parentNode;<br/>            li.remove();<br/>        });<br/>    };<br/>});</span></pre><h2 id="f190" class="nm lj iq bd lk nr ns dn lo nt nu dp ls kv nv nw lu kz nx ny lw ld nz oa ly ob bi translated">使用闭包</h2><p id="0dae" class="pw-post-body-paragraph km kn iq ko b kp ma jr kr ks mb ju ku kv mc kx ky kz md lb lc ld me lf lg lh ij bi translated">首先，我们的代码看起来与之前非常相似:</p><pre class="mw mx my mz gt nh ni nj nk aw nl bi"><span id="8dde" class="nm lj iq ni b gy nn no l np nq">const itemsUl = document.querySelector("#items-list");</span><span id="c420" class="nm lj iq ni b gy oc no l np nq">fetch("http://localhost:3000/items")<br/>.then(res =&gt; res.json())<br/>.then(itemsArr =&gt; {<br/>    itemsArr.forEach(item =&gt; {<br/>        let itemLi = document.createElement("li");<br/>        itemLi.innerText = item.name;<br/>        itemsUl.append(itemLi);<br/>        <br/>        let deleteButton = document.createElement("button");<br/>        deleteButton.innerText = "x";<br/>        itemLi.append(deleteButton);<br/>    };<br/>});</span></pre><p id="ef86" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">但是，我们不必在<button>上添加数据属性来存储特定商品的id。原因将随着我们添加代码而变得清晰(剧透:这与闭包有关)。接下来，让我们在创建delete <button>之后，在<strong class="ko ir"> forEach </strong>块中放置一个事件监听器:</button></button></p><pre class="mw mx my mz gt nh ni nj nk aw nl bi"><span id="e770" class="nm lj iq ni b gy nn no l np nq">const itemsUl = document.querySelector("#items-list");</span><span id="101d" class="nm lj iq ni b gy oc no l np nq">fetch("http://localhost:3000/items")<br/>.then(res =&gt; res.json())<br/>.then(itemsArr =&gt; {<br/>    itemsArr.forEach(item =&gt; {<br/>        let itemLi = document.createElement("li");<br/>        itemLi.innerText = item.name;<br/>        itemsUl.append(itemLi);<br/>        <br/>        let deleteButton = document.createElement("button");<br/>        deleteButton.innerText = "x";<br/>        itemLi.append(deleteButton);</span><span id="580c" class="nm lj iq ni b gy oc no l np nq">        deleteButton.addEventListener("click", () =&gt; {</span><span id="cff3" class="nm lj iq ni b gy oc no l np nq">        });<br/>    });<br/>});</span></pre><p id="2006" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">将事件监听器放在这里给我们带来了几个好处。首先，我们不必像委托时那样检查被点击的东西是否真的是删除按钮<button>，因为我们在每个删除按钮上放置了一个监听器<em class="mf">。第二，因为事件监听器的回调函数的定义在<strong class="ko ir"> forEach </strong>块中，所以它<em class="mf">关闭了</em>块，这意味着它可以访问块中的所有内容。这反过来帮助我们完成两个任务，第一个任务是将正确的id放入我们获取的url中，以便从数据库中删除商品:</em></button></p><pre class="mw mx my mz gt nh ni nj nk aw nl bi"><span id="86e4" class="nm lj iq ni b gy nn no l np nq">const itemsUl = document.querySelector("#items-list");</span><span id="e1fe" class="nm lj iq ni b gy oc no l np nq">fetch("http://localhost:3000/items")<br/>.then(res =&gt; res.json())<br/>.then(itemsArr =&gt; {<br/>    itemsArr.forEach(item =&gt; {<br/>        let itemLi = document.createElement("li");<br/>        itemLi.innerText = item.name;<br/>        itemsUl.append(itemLi);<br/>        <br/>        let deleteButton = document.createElement("button");<br/>        deleteButton.innerText = "x";<br/>        vLi.append(deleteButton);</span><span id="f564" class="nm lj iq ni b gy oc no l np nq">        deleteButton.addEventListener("click", () =&gt; {<br/>            fetch(`http://localhost:3000/items/${item.id}`, {<br/>                method: "DELETE"<br/>            });<br/>        });<br/>    });<br/>});</span></pre><p id="09ca" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">因为我们可以访问<strong class="ko ir"> item </strong>变量(这是我们在<strong class="ko ir"> forEach </strong>中迭代的来自后端的数据)，所以我们可以很容易地提取它的id，并将其放入url中进行获取。这将从数据库中删除该项目，然后从DOM中删除它:</p><pre class="mw mx my mz gt nh ni nj nk aw nl bi"><span id="e370" class="nm lj iq ni b gy nn no l np nq">const itemsUl = document.querySelector("#items-list");</span><span id="b333" class="nm lj iq ni b gy oc no l np nq">fetch("http://localhost:3000/items")<br/>.then(res =&gt; res.json())<br/>.then(itemsArr =&gt; {<br/>    itemsArr.forEach(item =&gt; {<br/>        let itemLi = document.createElement("li");<br/>        itemLi.innerText = item.name;<br/>        itemsUl.append(itemLi);<br/>        <br/>        let deleteButton = document.createElement("button");<br/>        deleteButton.innerText = "x";<br/>        itemLi.append(deleteButton);</span><span id="b533" class="nm lj iq ni b gy oc no l np nq">        deleteButton.addEventListener("click", () =&gt; {<br/>            fetch(`http://localhost:3000/items/${item.id}`, {<br/>                method: "DELETE"<br/>            })<br/>            .then(() =&gt; itemLi.remove());<br/>        });<br/>    });<br/>});</span></pre><p id="1978" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">请注意，我们不必像委托那样通过查找delete按钮的父节点来访问<li>。在这里，我们可以访问</li><li>，因为回调函数在我们的<strong class="ko ir">中。然后()</strong>在我们的事件侦听器的回调函数上关闭，该函数在我们的<strong class="ko ir"> itemLi </strong>变量所在的整个<strong class="ko ir"> forEach </strong>语句上关闭。</li></p><p id="e8e9" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">在我看来，最酷的部分是，尽管每个<li>、删除<button>和事件监听器都是在同一个代码块中创建的，但是代码的每次迭代都是一个新的<em class="mf">词法环境</em>，其中有新的变量和新的回调函数。更简单的说，每次迭代都是它自己的闭包！这很棒，对吧？</button></li></p><figure class="mw mx my mz gt na gh gi paragraph-image"><div class="gh gi od"><img src="../Images/48ee0219018a67a6e3ffd98de3b4991e.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/0*jyKgAFmWJ5-DVnvq.gif"/></div></figure><p id="8c5a" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">非常整洁。</p><h2 id="ea0f" class="nm lj iq bd lk nr ns dn lo nt nu dp ls kv nv nw lu kz nx ny lw ld nz oa ly ob bi translated">需要考虑的事项</h2><p id="321e" class="pw-post-body-paragraph km kn iq ko b kp ma jr kr ks mb ju ku kv mc kx ky kz md lb lc ld me lf lg lh ij bi translated">这两种方法都是完全有效的，但是根据我们使用的方法，我们必须在构建其余功能时记住一些事情。</p><p id="4a82" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">当我们使用委托时，我们找到了delete的父节点<button>(也就是item <li>)以便将其从DOM中移除。但是如果由于某种原因<button>的父节点因为我们(或我们的项目伙伴或同事或任何其他人)将来编写的代码而改变，我们将会有一些问题。同样，如果<li>和<button>被移出父<ul>，我们的事件监听器将永远不知道<button>何时被点击。</button></ul></button></li></button></li></button></p><p id="5f6a" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">当我们使用闭包向每个<button>添加单独的事件侦听器时，我们将这些事件侦听器绑定到特定的DOM元素。但是这些DOM元素和侦听器并不稳定。例如，如果我们通过<strong class="ko ir">改变<ul>或<li>的内部HTML。innerHTML = </li></ul></strong>或<strong class="ko ir">。innerHTML += </strong>，我们将失去那些事件监听器。这是使用<strong class="ko ir">的危险。innerHTML </strong>一般来说，在这里非常普遍。</button></p><h2 id="a168" class="nm lj iq bd lk nr ns dn lo nt nu dp ls kv nv nw lu kz nx ny lw ld nz oa ly ob bi translated">最后的想法</h2><p id="5aa5" class="pw-post-body-paragraph km kn iq ko b kp ma jr kr ks mb ju ku kv mc kx ky kz md lb lc ld me lf lg lh ij bi translated">就像JavaScript中的任何东西一样，有多种方法可以监听DOM元素重复实例上的事件。这里讨论的两种方法，委托和利用闭包，都是很好的选择。对于大多数应用程序来说，这两种方法都可以，选择权在你。比选择更重要的是知道你为什么做那个选择，并且理解那个选择如何影响你的应用程序的其余部分。</p></div></div>    
</body>
</html>