<html>
<head>
<title>Fun CSharp: Doing LINQ to Tasks, because Task is a Monad.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">好玩的CSharp:给任务做LINQ，因为任务是单子。</h1>
<blockquote>原文：<a href="https://itnext.io/fun-csharp-doing-linq-to-tasks-because-task-is-a-monad-2fd87a310a03?source=collection_archive---------0-----------------------#2020-04-10">https://itnext.io/fun-csharp-doing-linq-to-tasks-because-task-is-a-monad-2fd87a310a03?source=collection_archive---------0-----------------------#2020-04-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/34a289069acfbc6f55db13915960702c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x_6Mz3s_G8qOAN6_bGG4Zg.jpeg"/></div></div></figure><p id="2114" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我已经考虑了一段时间我下一篇文章的主题，我必须承认，即使我有很多想法，我也不知道该用哪一个。前几天看了一个知名的<strong class="ka ir"> C#/。NET </strong>架构师在一次演示会上公开表示，<strong class="ka ir"> C#/。NET </strong>没有任何类似“单子、部分应用、涂抹等”的花哨东西我感到内心有一团火在燃烧，我知道这将引导我写下一篇文章。</p><p id="0785" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">。NET </strong>充满了<strong class="ka ir">单子</strong>，一些例子有<strong class="ka ir">IEnumerable&lt;T&gt;T9】，<em class="kw">数组</em>，<strong class="ka ir">任务</strong>等等。你也可以在C#中进行局部应用和涂抹(我已经做过很多次了),这并没有什么特别的。如果你没有受过高级思维训练，或者你已经完成了大部分命令式C#/，你的大脑很难首先从这个角度思考。NET编程。慢慢地，当然是坏的，微软已经把更多的功能结构带入平台，这让我很高兴；作为一个函数式JavaScript爱好者，能够在<strong class="ka ir"> C# </strong>中做类似的事情是很好的。</strong></p><p id="8d2a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果想查看维基百科对<strong class="ka ir"> Monad </strong>的定义，可以随意访问:<a class="ae kx" href="https://en.wikipedia.org/wiki/Monad_(functional_programming)" rel="noopener ugc nofollow" target="_blank">https://en . Wikipedia . org/wiki/Monad _(functional _ programming)</a>。每当我谈论函数式编程概念时，我都尽量不要太专业，也不要对定义吹毛求疵，我尽量像在和一个五岁的孩子谈论编程一样解释事情。所以，如果这个孩子问我:什么是<strong class="ka ir">单子</strong>？我可能会说:“它就像一个芒果”。你可以买一个芒果，放在袋子里，放在你的车里，开回家，洗干净，但是在你把皮剥掉，接触到“肉”之前，它并没有太大的用处。以类似的方式，您可以传递<em class="kw">数组</em>、<em class="kw">任务</em>、<em class="kw">字典</em>，但是最终，为了让它们有用，您需要访问它们的底层内容(您需要剥芒果皮)。所有这些类型还为您提供了与其底层内容进行交互的方法。</p><p id="78ba" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，以<strong class="ka ir">IEnumerable&lt;T&gt;T1】为例，它充当了<strong class="ka ir"> T. </strong>类型的一些数据的“容器”<strong class="ka ir"> </strong>。此外，您并不真正需要使用命令式<strong class="ka ir"> for </strong>和/或<strong class="ka ir"> foreach </strong>循环来遍历底层数据。您可以使用所有的<em class="kw">扩展方法</em> <strong class="ka ir">。NET </strong>为您提供的，以便与它的内容进行交互。因此，用非常简单的术语来说，一个<strong class="ka ir">单子</strong>，是一个包装器类型，它有内置的功能让你处理它的内容。老实说，为了让某样东西成为单子，它必须遵循一定的法则(如果没有这些法则，会有多有趣)，但是讨论这个问题超出了本文的范围。</strong></p><p id="fd5f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">回到芒果的类比，例如，当你<em class="kw">等待</em>它或者访问它的<em class="kw">结果</em>属性时，你“剥离”一个<strong class="ka ir">任务</strong>。为了更准确地进行类比，你可以考虑洋葱而不是芒果，因为<strong class="ka ir">单子</strong>可以有几个包装层，就像<em class="kw">任务</em>的<em class="kw">数组</em>的<em class="kw">数组</em>。</p><p id="6dea" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> C#/。NET </strong>内置了对<em class="kw"/><strong class="ka ir">，</strong>一元合成的支持，也许我不会试图定义这个术语，或者把你带到一个令人困惑的链接，我会用代码向你展示我的意思。</p><p id="1511" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们创建这个简单的<em class="kw">类:</em></p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="0ce3" class="lh li iq ld b gy lj lk l ll lm">public class TaskCreator<br/>{<br/>  public async <em class="kw">Task</em>&lt;<em class="kw">int</em>&gt; CreateTask1() =&gt; await Task.FromResult(4);</span><span id="7b70" class="lh li iq ld b gy ln lk l ll lm">  public async <em class="kw">Task</em>&lt;<em class="kw">int</em>&gt; CreateTask2() =&gt; await Task.FromResult(6);</span><span id="6b61" class="lh li iq ld b gy ln lk l ll lm">  public async <em class="kw">Task</em>&lt;<em class="kw">string</em>&gt; CreateTask3()<br/>  =&gt; await Task.FromResult("The result is: ");<br/>}</span></pre><p id="9e72" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它包含3个<strong class="ka ir">任务</strong>——返回方法，在实际的产品代码中，这些方法还可以处理文件系统、数据库、网络调用等等。接下来，我将在<strong class="ka ir">任务</strong> <em class="kw">类</em>中添加三个<em class="kw">扩展方法</em>。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="9338" class="lh li iq ld b gy lj lk l ll lm">public static class TaskExtensions<br/>{<br/>  public static async Task&lt;B&gt; Bind&lt;A, B&gt;(<br/>     this Task&lt;A&gt; @this, Func&lt;A, Task&lt;B&gt;&gt; fn)<br/>  =&gt; await fn(await @this);</span><span id="9347" class="lh li iq ld b gy ln lk l ll lm">  public static async Task&lt;B&gt; Map&lt;A, B&gt;(<br/>     this Task&lt;A&gt; @this, Func&lt;A, B&gt; fn)<br/>  =&gt; await Task.FromResult(fn(await @this));</span><span id="667d" class="lh li iq ld b gy ln lk l ll lm">  public static Task&lt;C&gt; SelectMany&lt;A, B, C&gt;(<br/>     this Task&lt;A&gt; @this, Func&lt;A, Task&lt;B&gt;&gt; fn, Func&lt;A, B, C&gt; select)<br/>  =&gt; @this.Bind(a =&gt; fn(a).Map(b =&gt; select(a, b)));<br/>}</span></pre><p id="6dab" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们增加了<em class="kw">地图</em>、<em class="kw">绑定</em>和<em class="kw">选择多项。Map </em>是一个非常方便的方法，你可以修改它以用于任何类型的对象，而不仅仅是<strong class="ka ir">单子</strong>，它类似于“我将从一个对象<em class="kw"> a开始，</em>我将对它应用你传递给我的函数，然后我将给你对象<em class="kw"> b </em>”。当你看到一个<strong class="ka ir">单子</strong>和一个<em class="kw">映射函数</em>(同样遵循一定的数学法则)时，你就在一个<strong class="ka ir">仿函数</strong>面前。<em class="kw">绑定</em>方法(也称为<em class="kw">链</em>)类似于<em class="kw">映射</em>，但是可以看到，在<strong class="ka ir"><em class="kw">Func&lt;&gt;</em></strong><em class="kw"/>中传递的是一个<strong class="ka ir">任务&lt;&gt;</strong>而不是仅仅一个<strong class="ka ir"/>。<em class="kw">选择多</em>就是<strong class="ka ir">。NET </strong>对<em class="kw">一元合成</em>的支持，事不宜迟，我就给你看看那是什么样子(剧透提醒:这种表情你已经很熟悉了)。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="5c0d" class="lh li iq ld b gy lj lk l ll lm">public async <em class="kw">Task</em>&lt;<em class="kw">string</em>&gt; CoolMonadicComposition()<br/>{<br/>  var taskCreator = new <em class="kw">TaskCreator</em>();</span><span id="0c69" class="lh li iq ld b gy ln lk l ll lm">  var result = from a in taskCreator.CreateTask1()<br/>               from b in taskCreator.CreateTask2()<br/>               from c in taskCreator.CreateTask3()<br/>               select c + (b + a);<br/> <br/>  return await result;<br/>}</span></pre><p id="b9e2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你认为<em class="kw"> LINQ查询语法</em>是<strong class="ka ir"> IEnumerable/IQueryable </strong>独有的，你会大吃一惊。您可以在<strong class="ka ir"> C#/中的任何<strong class="ka ir">单子</strong>中使用这个<em class="kw">单子组合</em>语法。网</strong>。实际上我是从<a class="ae kx" href="https://gist.github.com/johnazariah/d95c03e2c56579c11272a647bab4bc38" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/johnazariah/d 95 c 03 e 2c 56579 c 11272 a 647 Bab 4 BC 38</a>得到这个想法的，它是<strong class="ka ir">也许是</strong>单子的一部分。我现在已经用几个<strong class="ka ir">做了类似的事情。NET </strong> <strong class="ka ir">单子</strong>，内置的和自定义的，包括著名的<em class="kw"> Result &lt; TSuccess，TFailure &gt; </em> <strong class="ka ir">单子</strong>用在<strong class="ka ir"> C# </strong>(我很喜欢的一种编码风格)中面向铁路的编程。</p><p id="e481" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上面最后这段代码中需要注意的一点是，如果属于<em class="kw"> TaskCreator </em>的三个<strong class="ka ir">Task</strong>-return方法中的任何一个抛出<strong class="ka ir">异常</strong>，它将在您<em class="kw">等待</em> <em class="kw">结果</em>时传播，请记住这一点。</p><p id="b571" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">花点时间去理解三个<em class="kw">扩展方法</em>里面发生了什么，如果你一开始不能理解，坚持做下去直到你理解为止，当这种情况发生时，我向你保证这将是非常有益的。</p><h2 id="4f7a" class="lh li iq bd lo lp lq dn lr ls lt dp lu kj lv lw lx kn ly lz ma kr mb mc md me bi translated"><em class="mf">更新:</em></h2><p id="c91d" class="pw-post-body-paragraph jy jz iq ka b kb mg kd ke kf mh kh ki kj mi kl km kn mj kp kq kr mk kt ku kv ij bi translated">为了帮助您理解我们对<em class="kw"> SelectMany </em>的实现，我想向您展示一下如果我们没有<em class="kw"> LINQ查询语法，我们如何编写同样的<em class="kw">一元复合</em>会很好。</em>为了完整起见，我将包括第一种方法，但将其注释掉。正如您将从下面的代码中推断的那样，您可以在您的<em class="kw">一元合成</em>中拥有任意多的<em class="kw">一元表达式</em>。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="43ec" class="lh li iq ld b gy lj lk l ll lm">// var result = from a in taskCreator.CreateTask1()<br/>//              from b in taskCreator.CreateTask2()<br/>//              from c in taskCreator.CreateTask3()<br/>//              select c + (a + b);</span><span id="2c6c" class="lh li iq ld b gy ln lk l ll lm">var result = taskCreator<br/> .CreateTask1()<br/> .SelectMany(_ =&gt; taskCreator.CreateTask2(), (a, b) =&gt; new { a, b })<br/> .SelectMany(_ =&gt; taskCreator.CreateTask3(),<br/>            (param1, d) =&gt; d + (param1.a + param1.b));</span><span id="5a94" class="lh li iq ld b gy ln lk l ll lm">return await result;</span></pre><p id="b1ef" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">顺便说一下，在幕后，<strong class="ka ir"> C# </strong>编译器将上面注释掉的<em class="kw"> LINQ查询</em>(这个语法只是语法糖)<em class="kw"> </em>转换成它下面的代码(显式使用<em class="kw"> SelectMany </em>)。如果你在你的<em class="kw"> LINQ查询</em>中使用了比我们上面使用的更多的表达式，编译器将开始在结果代码<em class="kw">中使用<em class="kw">透明标识符</em>。</em></p><p id="3659" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">编码快乐！</p></div></div>    
</body>
</html>