<html>
<head>
<title>Error handling with Angular 6 and ngx-formly</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Angular 6和ngx-formly的错误处理</h1>
<blockquote>原文：<a href="https://itnext.io/error-handling-with-angular-6-and-ngx-formly-8272a3aa7871?source=collection_archive---------0-----------------------#2018-11-06">https://itnext.io/error-handling-with-angular-6-and-ngx-formly-8272a3aa7871?source=collection_archive---------0-----------------------#2018-11-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/839d2fab6599d91d034d9ea635556a5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tp9lipRFB-xXpRhMTXR-qw.png"/></div></div></figure><p id="0366" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">ngx-formly 提供了一种在Angular 6中创建表单的简单且更好的方法，但其官方文档中的错误处理部分已经过时。本帖用<code class="fe kx ky kz la b">ngx-formly</code>总结错误处理技巧。</p><p id="dcb9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本帖中，我们假设一个表单字段配置如下:</p><pre class="lb lc ld le gt lf la lg lh aw li bi"><span id="955d" class="lj lk iq la b gy ll lm l ln lo">fields: FormlyFieldConfig[] = [<br/>    {<br/>        key: 'name',<br/>        type: 'input',<br/>        templateOptions: {<br/>            type: 'text',<br/>            label: 'Name',<br/>        },<br/>    }<br/>];</span></pre><p id="c16b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们使用的软件包版本有:</p><ul class=""><li id="17ca" class="lp lq iq ka b kb kc kf kg kj lr kn ls kr lt kv lu lv lw lx bi translated"><code class="fe kx ky kz la b">@angular/core@^6.0.3</code></li><li id="eab8" class="lp lq iq ka b kb ly kf lz kj ma kn mb kr mc kv lu lv lw lx bi translated"><code class="fe kx ky kz la b">@ngx-formly/core@^4.7.2</code>，<code class="fe kx ky kz la b">@ngx-formly/material@^4.7.2</code></li><li id="43b2" class="lp lq iq ka b kb ly kf lz kj ma kn mb kr mc kv lu lv lw lx bi translated"><code class="fe kx ky kz la b">@angular/material@^6.4.1</code></li></ul><h1 id="e34a" class="md lk iq bd me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz bi translated">前端验证</h1><p id="e03f" class="pw-post-body-paragraph jy jz iq ka b kb na kd ke kf nb kh ki kj nc kl km kn nd kp kq kr ne kt ku kv ij bi translated">ngx-formly有内置的前端验证，非常容易使用。它的官方文件<a class="ae kw" href="https://formly-js.github.io/ngx-formly/guide/validation" rel="noopener ugc nofollow" target="_blank">提到了解决方案</a>但是似乎过时了，而且字段与实际类型不匹配。</p><p id="8b58" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">基本上有两个步骤来进行前端验证:</p><ol class=""><li id="936d" class="lp lq iq ka b kb kc kf kg kj lr kn ls kr lt kv nf lv lw lx bi translated">定义验证器，</li><li id="5698" class="lp lq iq ka b kb ly kf lz kj ma kn mb kr mc kv nf lv lw lx bi translated">为验证器定义错误消息。</li></ol><p id="6c3d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">假设我们要验证的名字不应该超过100个字符。首先，添加一个<code class="fe kx ky kz la b">validators</code>配置到配置字段:</p><pre class="lb lc ld le gt lf la lg lh aw li bi"><span id="0c96" class="lj lk iq la b gy ll lm l ln lo">validators: {<br/>    maxlength: ctrl =&gt; ctrl.value &amp;&amp; ctrl.value &lt;= 100,<br/>},</span></pre><p id="191a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一个<code class="fe kx ky kz la b">validators</code> config是一个对象，其中的键是一个任意的名称，值是一个验证函数。验证功能应该是:</p><ul class=""><li id="a11d" class="lp lq iq ka b kb kc kf kg kj lr kn ls kr lt kv lu lv lw lx bi translated">参数:<code class="fe kx ky kz la b">(ctrl: FormControl)</code>，正在验证的表单控件通过</li><li id="55dc" class="lp lq iq ka b kb ly kf lz kj ma kn mb kr mc kv lu lv lw lx bi translated">返回值:<code class="fe kx ky kz la b">boolean</code>，返回验证是否成功</li></ul><p id="83ce" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，添加一个<code class="fe kx ky kz la b">validation</code>配置来定义验证失败时的错误消息:</p><pre class="lb lc ld le gt lf la lg lh aw li bi"><span id="078b" class="lj lk iq la b gy ll lm l ln lo">validation: {<br/>    messages: {<br/>        maxlength: 'The max length is 100 characters',<br/>    }<br/>},</span></pre><p id="2e60" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe kx ky kz la b">validation.messages</code>是为每个验证器定义错误消息的对象。它的键应该是在<code class="fe kx ky kz la b">validators</code>中定义的验证器名称，它的值是作为错误消息的<code class="fe kx ky kz la b">string</code>。</p><p id="a028" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，最终的表单配置应该如下所示:</p><pre class="lb lc ld le gt lf la lg lh aw li bi"><span id="4d7c" class="lj lk iq la b gy ll lm l ln lo">fields: FormlyFieldConfig[] = [<br/>    {<br/>        key: 'name',<br/>        type: 'input',<br/>        templateOptions: {<br/>            type: 'text',<br/>            label: 'Name',<br/>        },<br/>        validators: {<br/>            maxlength: ctrl =&gt; ctrl.value &amp;&amp; ctrl.value &lt;= 100,<br/>        },<br/>        validation: {<br/>            messages: {<br/>                maxlength: 'The max length is 100 characters',<br/>            }<br/>        },<br/>    }<br/>];</span></pre><p id="5a70" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一个特殊的内置验证器是<code class="fe kx ky kz la b">required</code>。它应该在<code class="fe kx ky kz la b">templateOptions</code>中设置为<code class="fe kx ky kz la b">required: true</code>，并且需要一个<code class="fe kx ky kz la b">validation.messages</code>对象中的<code class="fe kx ky kz la b">required: 'errmsg'</code>。因此，要使上述示例成为必需的，您应该编写:</p><pre class="lb lc ld le gt lf la lg lh aw li bi"><span id="674b" class="lj lk iq la b gy ll lm l ln lo">fields: FormlyFieldConfig[] = [<br/>    {<br/>        key: 'name',<br/>        type: 'input',<br/>        templateOptions: {<br/>            type: 'text',<br/>            label: 'Name',<br/>            required: true,<br/>        },<br/>        validators: {<br/>            maxlength: ctrl =&gt; ctrl.value &amp;&amp; ctrl.value &lt;= 100,<br/>            required: 'This field is required.',<br/>        },<br/>        validation: {<br/>            messages: {<br/>                maxlength: 'The max length is 100 characters',<br/>            }<br/>        },<br/>    }<br/>];</span></pre><p id="98f8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，要在表单无效时禁用提交按钮，应该在提交按钮中使用<code class="fe kx ky kz la b">[disabled]="!form.valid"</code>(其中<code class="fe kx ky kz la b">form</code>是<code class="fe kx ky kz la b">ngx-formly</code>使用的<code class="fe kx ky kz la b">FormGroup</code>对象)。</p><h1 id="371a" class="md lk iq bd me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz bi translated">后端验证</h1><p id="f61d" class="pw-post-body-paragraph jy jz iq ka b kb na kd ke kf nb kh ki kj nc kl km kn nd kp kq kr ne kt ku kv ij bi translated">并非所有的字段标准都可以在前端进行验证，在某些情况下，后端会返回一些错误。</p><p id="61b1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">假设后端返回的错误具有以下格式(这是<a class="ae kw" href="http://www.django-rest-framework.org/" rel="noopener ugc nofollow" target="_blank"> django-rest-framework </a>的标准格式):</p><pre class="lb lc ld le gt lf la lg lh aw li bi"><span id="9710" class="lj lk iq la b gy ll lm l ln lo">{<br/>    "name": [<br/>        "Name contains invalid characters."<br/>    ]<br/>}</span></pre><p id="fa00" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于后端不返回错误类型(<code class="fe kx ky kz la b">name</code>是字段名)，我们假设后端返回的所有错误都是<code class="fe kx ky kz la b">other</code>类型。在前端，在错误处理程序中使用以下代码将错误设置为表单:</p><pre class="lb lc ld le gt lf la lg lh aw li bi"><span id="211d" class="lj lk iq la b gy ll lm l ln lo">_.forEach(this.form.controls, (ctrl, name) =&gt; {<br/>    if (errors[name]) {<br/>        ctrl.setErrors({ other: errors[name] });<br/>    }<br/>}</span></pre><p id="6561" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里的<code class="fe kx ky kz la b">_</code>是<a class="ae kw" href="https://lodash.com/" rel="noopener ugc nofollow" target="_blank">洛达什</a>图书馆。我们通过调用<code class="fe kx ky kz la b">_.forEach(this.form.controls)</code>迭代所有的表单控件，然后为服务器返回错误的表单控件调用<code class="fe kx ky kz la b">ctrl.setErrors({ error_type: error_message })</code>。</p><p id="2de8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我们需要让formly知道如何显示<code class="fe kx ky kz la b">other</code>类型的错误信息。就像我们对<code class="fe kx ky kz la b">maxlength</code>类型错误所做的一样，我们向<code class="fe kx ky kz la b">validation.messages</code>添加另一个字段:</p><pre class="lb lc ld le gt lf la lg lh aw li bi"><span id="55f7" class="lj lk iq la b gy ll lm l ln lo">validation: {<br/>    messages: {<br/>        maxlength: 'The max length is 100 characters',<br/>        <strong class="la ir">other: (err, field) =&gt; err,</strong><br/>    }<br/>},</span></pre><p id="8b28" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了显示服务器返回的内容，我们使用了一个用于类型的函数，而不是像在<code class="fe kx ky kz la b">maxlength</code>中那样使用固定的字符串。函数签名是:</p><ul class=""><li id="8232" class="lp lq iq ka b kb kc kf kg kj lr kn ls kr lt kv lu lv lw lx bi translated">参数:<code class="fe kx ky kz la b">(error_message, error_field)</code>。<code class="fe kx ky kz la b">error_message</code>是<code class="fe kx ky kz la b">ctrl.setErrors({ error_type: error_message })</code>传递的消息，<code class="fe kx ky kz la b">error_field</code>是对表单控件的引用。</li><li id="edb9" class="lp lq iq ka b kb ly kf lz kj ma kn mb kr mc kv lu lv lw lx bi translated">返回值:一个字符串，将显示在字段下方的实际错误消息。</li></ul><p id="609e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在后端错误消息可以正确显示了。</p><h1 id="d39c" class="md lk iq bd me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz bi translated">全局错误消息</h1><p id="e9b3" class="pw-post-body-paragraph jy jz iq ka b kb na kd ke kf nb kh ki kj nc kl km kn nd kp kq kr ne kt ku kv ij bi translated">到目前为止，我们只在每个字段中设置错误消息，当多个字段具有相同的错误消息配置时，这可能会很麻烦。我们可以将常见的错误信息移动到formly的全局配置中，这样就不需要逐个字段地设置它们。</p><p id="dba1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在您的<code class="fe kx ky kz la b">app.module.ts</code>(即导入<code class="fe kx ky kz la b">FormlyModule</code>的地方)中添加以下代码，这样就不需要为每个字段设置错误信息:</p><pre class="lb lc ld le gt lf la lg lh aw li bi"><span id="969c" class="lj lk iq la b gy ll lm l ln lo">FormlyModule.forRoot({<br/>    validationMessages: [<br/>        { name: 'required', message: 'This field is required' },<br/>        { name: 'other', message: (err, field) =&gt; err },<br/>    ],<br/>}),</span></pre><p id="be49" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">就是这样！</p></div><div class="ab cl ng nh hu ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="ij ik il im in"><p id="7bad" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这篇文章来自我自己的经历，希望它能帮助那些也在使用formly并且因为缺少文档而苦苦挣扎的人。喜欢就给我鼓掌。</p></div></div>    
</body>
</html>