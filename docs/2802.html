<html>
<head>
<title>Generic repository pattern using Dapper</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Dapper的通用存储库模式</h1>
<blockquote>原文：<a href="https://itnext.io/generic-repository-pattern-using-dapper-bd48d9cd7ead?source=collection_archive---------0-----------------------#2019-08-06">https://itnext.io/generic-repository-pattern-using-dapper-bd48d9cd7ead?source=collection_archive---------0-----------------------#2019-08-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="b349" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">更新:与此同时，我已经创建了通用资源库项目，可以在以下github<a class="ae ko" href="https://github.com/bolicd/dapper-extensions" rel="noopener ugc nofollow" target="_blank">https://github.com/bolicd/dapper-extensions</a>以及2个nuget包中找到:<a class="ae ko" href="https://www.nuget.org/packages/DapperGenericRepository/" rel="noopener ugc nofollow" target="_blank">https://www.nuget.org/packages/DapperGenericRepository/</a></p><p id="55b7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在Dapper中实现存储库模式有很多方法。在这篇博客中，我将解释什么是存储库模式，以及如何在C#中使用反射来实现它。</p><p id="fcbb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在网上搜索时，我发现了各种各样的实现，但没有一个是令人满意的——主要是因为必须手动输入表名/字段名，工作单元的实现过于复杂等等。</p><p id="2a59" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">类似的知识库，正如这里所介绍的，正在生产CQRS/专家系统中使用，效果很好。</p><p id="bcf5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">尽管这里描述的用例非常“独特”，但我认为这个存储库的实现可以应用于大多数关系型数据库系统，只需最少的重构。</p><p id="9661" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">什么是知识库模式？</strong></p><p id="6497" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当谈到仓库模式时，区分仓库的<strong class="js iu"> DDD实现</strong>和<strong class="js iu">通用仓库</strong>模式是很重要的。</p><p id="7db1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">通用存储库</strong>是一个简单的契约，定义为基于每个对象的接口。这意味着一个存储库对象与数据库中的一个表相关。</p><p id="3ad0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> DDD存储库</strong>模式使用聚合根对象，并将其保存在一个或多个表中，或者事件源被用作事件存储中的一系列事件。所以在这种情况下，存储库实际上不是与一个数据库相关，而是与一个可以映射到一个或多个表的聚合根相关。由于阻抗不匹配效应，这是一个复杂的过程，ORM可以更好地处理这一问题，但<em class="kp">这不是我们的用例。</em></p><p id="e96e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通用存储库UML图:</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi kq"><img src="../Images/814b775dcdd6a970168373d5f9b24e08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GYJWdVcUk3jBAEMS"/></div></div></figure><ul class=""><li id="8a12" class="lc ld it js b jt ju jx jy kb le kf lf kj lg kn lh li lj lk bi translated"><em class="kp"> GenericRepository抽象类</em>实现<em class="kp"> IGenericRepository </em>接口。所有共享的功能都在这个类中实现。</li><li id="53f5" class="lc ld it js b jt ll jx lm kb ln kf lo kj lp kn lh li lj lk bi translated">is specific repository接口应该有特定用例所需的方法(如果有的话)</li><li id="8df8" class="lc ld it js b jt ll jx lm kb ln kf lo kj lp kn lh li lj lk bi translated"><em class="kp"> SpecificRepository类</em>继承自<em class="kp"> GenericRepository </em>抽象类，实现<em class="kp">isspecific repository</em>中的任何特定方法。</li></ul><p id="cdac" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">工作单元和事务处理</strong></p><p id="679f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">工作单元模式为多个存储库对象实现单个事务，确保所有的插入/更新/删除语句按顺序自动执行。</p><p id="c979" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我将不使用工作单元，而是使用更新/插入方法直接保存每个存储库。这样做的原因是这些存储库是为下面详述的特定用例而设计的。</p><p id="bb11" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所有事务处理都是通过将多个存储库命令包装到。NET事务对象。这在不增加额外复杂性的情况下提供了更多的灵活性。</p><p id="7daf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">储存库实现</strong></p><p id="51d3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们首先定义接口:</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="550e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">仓库类的引导代码负责创建<em class="kp"> SqlConnection </em>对象并打开与数据库的连接。之后，Dapper将利用这个连接对数据库执行SQL查询。</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="lq lr l"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">通用知识库抽象类引导代码</figcaption></figure><p id="5829" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">确保您有名为MainDb的连接字符串。我使用的是Visual Studio提供的MSSQL LocalDb，lite MSSQL版本数据库。</p><pre class="kr ks kt ku gt lw lx ly lz aw ma bi"><span id="09da" class="mb mc it lx b gy md me l mf mg">&lt;add name="MainDb"<br/>connectionString="Data Source=(localdb)\mssqllocaldb;Integrated Security=true;Initial Catalog=dapper-examples;"<br/>providerName="System.Data.SqlClient"/&gt;</span></pre><p id="13f6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">除了Insert和Update之外，使用Dapper实现这些方法中的大多数都非常简单。</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="72ac" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于<strong class="js iu"> SaveRangeAsync </strong>，提供了保存到数据库的项目列表，并返回保存的项目数。这可以通过在事务对象中包装foreach来实现。</p><p id="2c6f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">实现插入和更新查询</strong></p><p id="31e6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">实现<strong class="js iu">插入</strong>和<strong class="js iu">更新</strong>需要更多的工作。总体思路是使用<em class="kp">反射</em>并从模型类中提取字段名，然后基于字段名生成插入/更新查询。<strong class="js iu"> <em class="kp">字段名将被用作Dapper的参数名，因此确保DAO类字段名与实际表中的列名相同很重要。</em> </strong></p><p id="6365" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这两种情况下，想法是相同的:接受作为输入参数提供的对象，并生成带参数的SQL查询字符串。唯一的变化是生成、插入或更新不同的查询。</p><p id="73f9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这两种方法都使用反射从模型对象中提取字段名。这个类可以是静态的，因为它不使用任何实例变量，也是为了提高性能。</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="68c0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这样做的是使用反射将属性名称列表提取到<em class="kp">列表&lt;字符串&gt; </em>中。它不会提取标有“忽略描述”属性的字段。</p><p id="cee8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一旦我们有了这个列表，我们就可以迭代它并生成实际的查询:</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="c381" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">更新方法有一些小差异:</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="6ed5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里我们需要注意的另外一件事是，如果没有找到要更新的记录会发生什么。对此有几种解决方案，一些包括抛出一个异常，另一些返回空对象或以某种方式通知调用代码更新没有完成。</p><p id="66f2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这种情况下，我们依赖于Dappers executeAsync方法，该方法返回int，即受影响的行数。</p><p id="fbf7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通用存储库用法示例:</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="d8e8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">CQRS/ES架构中的用例</strong></p><p id="4c42" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">CQRS代表命令查询责任分离，是一种架构模式，它将读模型与写模型分开。我们的想法是拥有两个模型，它们可以独立扩展，并针对读取或写入进行了优化。</p><p id="a8bb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Event Sourcing(ES)是一种模式，它规定对象的状态作为事件列表保存在数据库中，并且可以在以后通过按顺序应用这些事件来重建到最新状态。</p><p id="f9fe" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我不会深入解释这两种模式是什么以及如何实现它们，而是专注于我在一个项目中处理过的特定用例:<em class="kp">如何利用数据映射器Dapper和通用存储库模式，将关系数据库(MSSQL)用于读取模型和事件存储。我还将简要地介绍使用相同的通用存储库的事件源。</em></p><p id="e6be" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">示例架构:</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi mh"><img src="../Images/040a70d0bfbbc62c9a8404103193d154.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TtrsXgXsjEEG1lPZ4ysXbQ.jpeg"/></div></div></figure><p id="d897" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在进一步讨论之前，让我们考虑一下为什么在这种特殊情况下使用数据映射器比使用ORM更有利:</p><p id="534d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">事件源中的阻抗不匹配</strong></p><p id="b09c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对象-关系阻抗不匹配是指在面向对象编程语言中表示来自关系数据库的数据的一系列问题。</p><p id="4190" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">阻抗不匹配有很大的相关成本。原因是开发人员必须既了解关系模型又了解面向对象模型。对象关系映射器(ORM)用于缓解这个问题，但不能消除它。它们也倾向于引入新的问题:像EF的虚拟财产要求、私有财产映射问题、污染域模型等。</p><p id="b48e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当在事件存储中使用使用事件作为存储机制时，<strong class="js iu">没有阻抗不匹配</strong>！<em class="kp">原因是事件是领域概念，直接保存在事件存储中，不需要任何对象关系映射。因此，使用ORM的需求是最小的，使用Dapper/Generic repository变得更加实用。</em></p><p id="5032" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">数据库模型考虑事项</strong></p><p id="3b32" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这个用例中，MSSQL将用于写入和读取端，这增加了dapper存储库的可重用性，因为它可以用于读取和写入端。</p><p id="7503" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">主键考虑</strong></p><p id="28f7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这个例子中，我使用了Guid(。NET Guid和uniqueidentifier MSSQL数据类型)作为主键标识符。也可以是其他的东西，比如long，int，或者string。</p><p id="2583" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在任何情况下，这都需要在Dapper存储库上做一些额外的工作。首先，接口需要更改以接受额外的主键类型。然后，根据类型，可能需要做一些额外的工作来修改生成的查询。</p><p id="9f14" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">将多个列作为主键也意味着一些额外的工作，在这种情况下，使用dapper/generic repository模式可能会适得其反。在这种情况下，我们应该选择使用完全成熟的ORM！</p><p id="5e22" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">带Dapper的散装嵌件</strong></p><p id="72c7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Dapper不适合批量插入，即。执行大量INSERT语句。原因是<em class="kp"> ExecuteAsync </em>方法，内部会使用<em class="kp"> foreach循环</em>生成insert语句并执行它们。对于大量记录，这不是最佳选择，我建议使用SQL批量复制(链接)功能或允许批量复制的dapper扩展(其商业扩展),或者简单地绕过Dapper直接处理数据库。</p><p id="8714" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">交易处理</strong></p><p id="d67f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">应用事务的用例是自动保存到多个表中。保存到事件存储中可以是这样的例子:<em class="kp">作为一个事务保存到AggregateRoot表和Events表中。</em></p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/897fc89c0083389ea3455831113c4237.png" data-original-src="https://miro.medium.com/v2/resize:fit:1038/0*oZPUbZPtbKVEcyoK"/></div></figure><p id="2b0c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">应该在命令级别(在CQRS命令实现中)或在存储库内部手动控制事务。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/a254769c498e0dee6f124b5def361e27.png" data-original-src="https://miro.medium.com/v2/resize:fit:556/format:webp/1*sVZtOeM0vHnx5bE_-1unXA.jpeg"/></div></figure><p id="76f6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个有两张桌子的例子的灵感来自格雷格·杨的设计，可以在这里找到:<a class="ae ko" href="https://cqrs.files.wordpress.com/2010/11/cqrs_documents.pdf" rel="noopener ugc nofollow" target="_blank">https://cqrs.files.wordpress.com/2010/11/cqrs_documents.pdf</a></p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="e332" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果没有找到聚合根，则创建它并将其插入aggregate root表中。之后，每个事件被转换为域事件并保存到事件表中。所有这些都包装在事务中，作为原子操作，要么失败，要么成功。请注意，事务具有transactionscopeasyncflow option。Enabled选项，允许事务调用其主体内部的异步代码。</p><p id="e528" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">结论</strong></p><p id="ed49" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里的实现可以进一步优化，以用于CQRS/ES系统，但是这超出了本文的范围。这种实现提供了足够的灵活性，只需向存储库添加定制的SQL查询，就可以轻松地用新功能扩展所需的特定存储库。</p></div></div>    
</body>
</html>