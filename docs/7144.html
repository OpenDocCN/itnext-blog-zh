<html>
<head>
<title>Kotlin Coroutines vs Java Virtual Threads — A good story, but just that…</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kotlin协同程序vs Java虚拟线程——一个好故事，但仅此而已…</h1>
<blockquote>原文：<a href="https://itnext.io/kotlin-coroutines-vs-java-virtual-threads-a-good-story-but-just-that-91038c7d21eb?source=collection_archive---------0-----------------------#2022-06-25">https://itnext.io/kotlin-coroutines-vs-java-virtual-threads-a-good-story-but-just-that-91038c7d21eb?source=collection_archive---------0-----------------------#2022-06-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/3853b6518055de9eb2a0c77f1ad48b3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v9NsocUM3Wj_84ZMVoTgcQ.jpeg"/></div></div></figure></div><div class="ab cl kb kc hx kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="im in io ip iq"><p id="41bf" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi lg translated"><span class="l lh li lj bm lk ll lm ln lo di">在</span>这篇文章中，我们将对<strong class="kk iu"> JVM </strong>中的<strong class="kk iu">协程</strong>也称为<strong class="kk iu">延续</strong>的两种不同实现进行反复试验。这些是<strong class="kk iu"> Java虚拟线程</strong>，它们是<strong class="kk iu"> Project Loom </strong>和<strong class="kk iu"> Kotlin协程</strong>的一部分，作为<strong class="kk iu">DSL</strong>在<strong class="kk iu"> JVM </strong>上运行。由于这篇文章的性质，它将受到频繁的审查。支持代码位于<a class="ae lp" href="https://github.com/jesperancinha/good-story" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上。</p><h1 id="9366" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">一点历史</h1><p id="a73d" class="pw-post-body-paragraph ki kj it kk b kl mo kn ko kp mp kr ks kt mq kv kw kx mr kz la lb ms ld le lf im bi lg translated">在最近几年，如果你在<strong class="kk iu"> JVM </strong>周围工作，你一定会注意到一个新的玩家来到了<strong class="kk iu"> JVM </strong>世界。输入<strong class="kk iu">科特林</strong>。长话短说，<strong class="kk iu">科特林</strong>始于<strong class="kk iu">杰特布雷恩R &amp; D部，</strong>因<strong class="kk iu">科特林</strong>岛<strong class="kk iu">岛</strong>位于<strong class="kk iu">圣彼得堡附近而得名。</strong></p><p id="da24" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">这是目前为止简短的<strong class="kk iu">科特林</strong>故事。但是为了理解今年(2022年)我们在哪里以及我们已经走了多远，我们需要沿着记忆的轨迹，理解<strong class="kk iu"> Java </strong>是如何发展的，以及从<strong class="kk iu"> Java </strong>衍生的其他语言是何时以及如何繁荣的。这样，我们可以有一个更好的画面，并得出更明智的结论。</p><figure class="mu mv mw mx gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mt"><img src="../Images/b2e8bf78adf0ff88fef4c690a84bdf1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FCFOVskv7RkJOnJ2_dJ0Mw.png"/></div></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated"><strong class="bd ls">Java/kot Lin/Scala的简短年表</strong></figcaption></figure><p id="5ec0" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi lg translated">在我们继续之前，我们必须向那些负责任的人致敬，根据扩展文档，是他们开始了这场JVM革命。许多人认为詹姆斯·高斯林是<strong class="kk iu"> Java </strong>和<strong class="kk iu"> JVM </strong>的发明者。没有他，在JVM之上的任何后来的发明都是不可能的。同理，<strong class="kk iu">马丁·奥德斯基</strong>差不多就是<strong class="kk iu"> Scala </strong>的发明者。最后，对于<strong class="kk iu">科特林</strong>，我们只能说负责进一步开发的<strong class="kk iu"> JetBrains </strong>团队的组长是<strong class="kk iu">德米特里·杰梅罗夫</strong>。</p><p id="af54" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi lg translated">上面的表格是一个简短的概述，总结了三种语言历史上的主要亮点，这三种语言共享一个共同的生态系统，即<strong class="kk iu"> Java虚拟机</strong>。<strong class="kk iu"> Java </strong>存在于<strong class="kk iu"> 1995 </strong>之前，<strong class="kk iu"> Scala </strong>存在于<strong class="kk iu"> 2001年，</strong>和<strong class="kk iu"> Kotlin </strong>存在于<strong class="kk iu"> 2010 </strong>年。<strong class="kk iu"> Java </strong>是最古老的<strong class="kk iu"/><strong class="kk iu">JVM语言</strong>，最新的<strong class="kk iu">是<strong class="kk iu"> Kotlin </strong>。<strong class="kk iu"> Java </strong>比<strong class="kk iu"> Kotlin </strong>早开始至少<strong class="kk iu"> 15 </strong>年，而<strong class="kk iu"> Scala </strong>比<strong class="kk iu"> Kotlin </strong>早开始<strong class="kk iu"> 9 </strong>年。</strong></p><p id="07fd" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi lg translated"><span class="l lh li lj bm lk ll lm ln lo di">我</span>找不到确切的位置，但是检查项目<strong class="kk iu">的提交时</strong>我可以看到第一次提交发生在<strong class="kk iu"> 2007年</strong>。这告诉我们的是，<strong class="kk iu">织机</strong>的想法很可能是在今年前后开始的。<strong class="kk iu"> Loom </strong>是一个项目，非常像<strong class="kk iu"> Kotlin </strong>中的<strong class="kk iu">协程</strong>，专注于通过将<strong class="kk iu">系统线程</strong>分割成单独的独立进程来最大限度地利用它们。Loom调用这些进程<strong class="kk iu">虚拟线程</strong>。在<strong class="kk iu"> Kotlin </strong>中，一个用<strong class="kk iu">协程</strong>支持同样想法的实验版本在<strong class="kk iu"> 2018 </strong>中发布。<strong class="kk iu">项目织机</strong>在<strong class="kk iu"> Java </strong>计划在<strong class="kk iu"> 2022 </strong>发布。</p><p id="e346" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi lg translated">关于科特林，很难确定创造一种新语言的动机到底是什么。我能找到的最好的是“<strong class="kk iu"> <em class="nc">需要添加的新功能</em> </strong>”。在本文中，我想与你分享我对<strong class="kk iu"> Kotlin协同程序</strong>和<strong class="kk iu"> Java虚拟线程</strong>的发现，然后揭示我得出的一个伟大结论。</p><p id="ab76" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi lg translated">我本人从来没有加入过Java Loom团队，也没有加入过Kotlin Coroutines团队。我在源代码信息、国际会议视频和论文的基础上完成了这篇文章。</p><p id="7c8c" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi lg translated">在我们继续之前，协程很久以前就被发明了，但是，如果你还不知道的话，这里有一个伟大的启示。他们确实很老了，实际上比<strong class="kk iu"> 1958 </strong>还要老。这只是这个术语由<a class="ae lp" href="https://en.wikipedia.org/wiki/Donald_Knuth" rel="noopener ugc nofollow" target="_blank">唐纳德·克努特</a>和<a class="ae lp" href="https://en.wikipedia.org/wiki/Melvin_Conway" rel="noopener ugc nofollow" target="_blank">梅尔文·康威</a>创造的一年。在这里，人们已经创建了自己的实现，例如，<a class="ae lp" href="https://github.com/codecop/Conways-Squasher-Coroutine" rel="noopener ugc nofollow" target="_blank">this</a>by<strong class="kk iu"><em class="nc">codecop</em></strong>。</p><h1 id="e16c" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">动机</h1><p id="d919" class="pw-post-body-paragraph ki kj it kk b kl mo kn ko kp mp kr ks kt mq kv kw kx mr kz la lb ms ld le lf im bi lg translated">多年来，软件工程已经发生了变化，毫无疑问，每个人都在努力让一切变得更好。我们希望更容易地创建软件并使我们的代码工作。为了做到这一点，我们创造了语法和语义，使我们的开发更加简单。当<strong class="kk iu"> Kotlin </strong>出现的时候，我几乎立刻就被它在许多层面上优于<strong class="kk iu"> Java </strong>的想法所打动。这就是Kotlin社区所提倡的。几个月后，我意识到一些事情挫败了我兴奋的原因。随着时间的推移，我越来越觉得科特林语只是另一种语言，这可能是它令人兴奋的真正原因，因为它与众不同。<strong class="kk iu">新事物</strong>打破常规，为创造力腾出空间。有一件事我没有改变主意，那就是用正确的方法，Kotlin可以产生比Java漂亮得多的代码。但是美是我不想在这篇文章里讨论的。这篇文章真正关注的是性能。我们不打算单独讨论<strong class="kk iu"> Kotlin </strong>和<strong class="kk iu"> Java </strong>。我们将讨论两个实现，它们利用了<strong class="kk iu">系统线程</strong>和一个叫做协程的非常古老的概念。在<strong class="kk iu"> Java中，</strong>这在<strong class="kk iu"> project Loom </strong>中被称为<strong class="kk iu">虚拟线程</strong>，在<strong class="kk iu"> Kotlin </strong>中，这被称为……嗯……<strong class="kk iu">协程</strong>。当我们在两边的代码中前进时，我们会停下来，相互比较代码，看看有什么不同。但首先，让我们深入一点理论，以准确理解我们在谈论什么，讨论为什么这不是一场革命，以及为什么花了这么多时间让语言开发接口和语义，以便能够更有效地使用系统线程。</p><h1 id="b90e" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">协程是什么？</h1><p id="164f" class="pw-post-body-paragraph ki kj it kk b kl mo kn ko kp mp kr ks kt mq kv kw kx mr kz la lb ms ld le lf im bi lg translated"><span class="l lh li lj bm lk ll lm ln lo di">如果</span>我们取<strong class="kk iu">协程</strong>的字面意思，纯粹在语义层面上，我们得到<strong class="kk iu">协同</strong>和<strong class="kk iu">例程</strong>。所以，一个例程就是一些运行的指令。一个<strong class="kk iu">协程</strong>是<strong class="kk iu">一起运行的东西。</strong>运行，在这种情况下，字面意思是<strong class="kk iu">暂停</strong>原始程序，并允许一个完全不同的程序开始，然后恢复<strong class="kk iu">原始程序</strong>。</p><p id="d7ac" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi lg translated"><span class="l lh li lj bm lk ll lm ln lo di">为了</span>说明这一点，我回到了1985年，在互联网的帮助下，我用<strong class="kk iu"> C++ </strong>创建了一个小程序，显示了一些关于用环氧树脂创建桌子的说明<strong class="kk iu">(如果你想创建一个真正的环氧树脂桌子，请不要遵循这些说明，用环氧树脂创建桌子需要安全装置和保护，所以先获得通知</strong>)。为什么<strong class="kk iu"> C++ </strong>？为什么不呢？此外，我认为从一个中立点开始是非常重要的。如果我们把这些基本的东西做对了，那么我们就能一帆风顺！这是主程序:</p><figure class="mu mv mw mx gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nd"><img src="../Images/89176c97eb68b5696e3399dc86c4e733.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MKA10QxF_amUwKr9QpISTg.png"/></div></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated"><strong class="bd ls">主环氧工作台程序</strong></figcaption></figure><p id="4a75" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi lg translated">现在，我们有一堆案例(确切地说是10个)，这段代码看起来并没有显示太多。目前我们确实有一些东西应该引起你的注意，那就是<strong class="kk iu"><em class="nc">pthread _ self()</em></strong>。另一件事是<strong class="kk iu"><em class="nc">【1，11】</em></strong><em class="nc"/>，这些都包含在<strong class="kk iu"> for-loop </strong>的验证检查中。让我们深入研究这种方法:</p><figure class="mu mv mw mx gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ne"><img src="../Images/3dff1b285c9ab38802c8db1b2e49a156.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zg0I4C1pb1xzSfL6XVW2xg.png"/></div></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated"><strong class="bd ls">流程</strong></figcaption></figure><p id="e21b" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi lg translated"><span class="l lh li lj bm lk ll lm ln lo di"> S </span> o，在这里，我们有一个奇怪的<code class="fe nf ng nh ni b"><strong class="kk iu">switch-case</strong></code>。我们将<strong class="kk iu"> 1 </strong>赋值给<strong class="kk iu"> 0的情况条件内的状态。</strong>这导致主线程在返回之前分裂。从技术上来说，它没有分裂成2个，但是它在运行时挂起，以允许另一个启动。这意味着当程序运行到<code class="fe nf ng nh ni b"> <strong class="kk iu"><em class="nc">return i</em></strong></code>时，它将暂停自己，<code class="fe nf ng nh ni b"><strong class="kk iu"><em class="nc">thread</em></strong></code>将首先运行主<strong class="kk iu"> <em class="nc"> for循环</em> </strong>中的内容，然后它将结束运行<strong class="kk iu"> <em class="nc"> case 1 </em> </strong>中的内容。在<strong class="kk iu"> C++中看到这一点，</strong>这可能看起来非常违反直觉，但如果我们运行代码，我们会看到这种现象发生，我们还可以看到，尽管主线程已经挂起和恢复了不同的例程，但它们都挂在同一个线程上:</p><figure class="mu mv mw mx gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nj"><img src="../Images/803b7a696044830f3d92bbc8c5dcdcb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N4bwVp2ZHy8llZjfWxS4LA.png"/></div></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated"><strong class="bd ls">深度代码分析</strong></figcaption></figure><p id="3526" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi lg translated"><span class="l lh li lj bm lk ll lm ln lo di">所以</span>这就是一个<strong class="kk iu">协程</strong>的本质。在这个<strong class="kk iu"> C++ </strong>的例子中，一切都是异步运行的。也有许多方法来实现协程。什么项目<strong class="kk iu">织机</strong>和<strong class="kk iu"> Kotlin协同程序</strong>在<strong class="kk iu">2000年代</strong>十年的下半年被视为金矿，是为了探索这一点并以一种<strong class="kk iu"><em class="nc"/></strong>的异步方式实现<strong class="kk iu"><em class="nc"/></strong>。这两种语言都已经发展了，并且在它们各自的实现上仍然运行着实验性的特性。然而，<strong class="kk iu"> Java </strong>仍然处于<strong class="kk iu"> EAB(早期访问构建)</strong>阶段，尽管它在本世纪后五年已经开始了它的开发<strong class="kk iu">。</strong></p><h1 id="cc0d" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">Java虚拟线程</h1><p id="59ef" class="pw-post-body-paragraph ki kj it kk b kl mo kn ko kp mp kr ks kt mq kv kw kx mr kz la lb ms ld le lf im bi lg translated">为了讨论Java虚拟线程，我们必须熟悉一些基本概念:纤程、延续，当然还有虚拟线程。</p><ul class=""><li id="1596" class="nk nl it kk b kl km kp kq kt nm kx nn lb no lf np nq nr ns bi translated"><strong class="kk iu">纤程</strong>:非常明确的说，<strong class="kk iu">纤程</strong>只是虚拟线程的另一种说法。这没什么神奇的</li><li id="3e33" class="nk nl it kk b kl nt kp nu kt nv kx nw lb nx lf np nq nr ns bi translated"><strong class="kk iu">虚拟线程</strong>:这样命名是为了更好地指代它们的实际行为。对于开发人员来说，线程(<strong class="kk iu">平台或系统线程</strong>)和<strong class="kk iu">虚拟线程</strong>(由独立执行的载体线程运行，允许更多进程运行)之间没有明显的区别</li><li id="baa9" class="nk nl it kk b kl nt kp nu kt nv kx nw lb nx lf np nq nr ns bi translated"><strong class="kk iu">载体线程</strong>:这个术语最初似乎是由hip和occurrence使用的，看起来是指<strong class="kk iu">平台线程</strong>或<strong class="kk iu">系统线程的另一种方式。然而，它确实有比这重要得多的作用。一个<strong class="kk iu">载体线程</strong>是一个<strong class="kk iu">虚拟线程</strong>执行的地方。当我们研究代码时，这变得更加明显，我们将在下面进一步讨论。</strong></li><li id="145c" class="nk nl it kk b kl nt kp nu kt nv kx nw lb nx lf np nq nr ns bi translated"><strong class="kk iu">延续:纤程</strong>和<strong class="kk iu">虚拟线程</strong>为<code class="fe nf ng nh ni b"><strong class="kk iu"><em class="nc">continuations</em></strong></code>。延续就是在产生一个结果后，允许我们继续的东西。这是所有虚拟线程及其工作方式的最底层。我们之前已经看到了协程是如何工作的。这正是<strong class="kk iu">延续</strong>的工作方式。事实上，<strong class="kk iu">协程</strong>只是<strong class="kk iu">延续</strong>的另一个名字。在本文开头示例的代码中，有两个虚拟线程。一个在执行开始时，另一个在我们以文本开始时:“<strong class="kk iu">结束步骤</strong>”。</li></ul><h1 id="3391" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">什么是Java虚拟线程？</h1><p id="b52c" class="pw-post-body-paragraph ki kj it kk b kl mo kn ko kp mp kr ks kt mq kv kw kx mr kz la lb ms ld le lf im bi lg translated"><span class="l lh li lj bm lk ll lm ln lo di">在</span>这一点上，从上面，我想你已经非常清楚这整个<strong class="kk iu">延续</strong>和<strong class="kk iu">协程</strong>是关于什么的了。同样的事情，对不对？理论看似一样，实现却不一样。在这个阶段，让我们来看看<strong class="kk iu">虚拟线程</strong>实现的一些亮点(至少在我看来是这样的):</p><figure class="mu mv mw mx gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ny"><img src="../Images/9f5578c8fdd76f429ccb89b1438348fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Sm-5noF-5tS-GEppPQXQvQ.png"/></div></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated"><strong class="bd ls">启动织机JDK19中的虚拟线程</strong></figcaption></figure><p id="fbce" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi lg translated">在这一点上，什么也没有发生。我们接收一个普通的runnable，然后进入这个方法。我们已经在<code class="fe nf ng nh ni b">JDK19</code>中执行了，这个代码只是<code class="fe nf ng nh ni b">JDK19</code>代码。一旦到达那里，Loom就创建一个<strong class="kk iu"> <em class="nc">虚拟线程</em> </strong>并启动它。当我们以这种方式启动一个虚拟线程时，我们通过使前两个参数为空，第三个参数为0，第四个参数为我们的<strong class="kk iu">任务</strong>。让我们先深入到<strong class="kk iu"> <em class="nc">虚拟线程</em> </strong>中，看看我们是否看到了与我们所看到和了解到的什么是延续有丝毫相似之处的迹象:</p><figure class="mu mv mw mx gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nz"><img src="../Images/24209d389b29cff4c171c1b66fefa4b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U2EcFnMR_2eNuQ_vukLdvw.png"/></div></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated"><strong class="bd ls">JDK织机19中静态调用的虚拟线程构造器</strong></figcaption></figure><p id="ee4f" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi lg translated"><span class="l lh li lj bm lk ll lm ln lo di">在</span>这种情况下，这意味着我们创建一个虚拟线程，没有调度程序，没有名字，没有特征。当然，这意味着什么？也许在这里我们可以跳过一些步骤，但是线程初始化会给它分配一个<strong class="kk iu"> <em class="nc"> id </em> </strong>而没有<strong class="kk iu"> <em class="nc">特征</em> </strong>。因为我们没有给它一个名字，我们的<strong class="kk iu"> <em class="nc">线程</em> </strong>将不能用一个名字来标识。至少默认情况下没有。在启动我们的线程之前，我们得到一个<strong class="kk iu"> <em class="nc">调度器</em> </strong>。在这一部分中，我们将遇到一些代码，它们确保我们从<strong class="kk iu">系统线程</strong>中获得一个合适的<strong class="kk iu"> <em class="nc">调度程序</em> </strong>，或者从<strong class="kk iu"> <em class="nc">虚拟线程</em> </strong>中获得一个合适的线程。我们似乎有两种类型的调度程序。一个用于虚拟线程，另一个用于系统线程。这些看起来实际上是可以重用的。新的<strong class="kk iu"> <em class="nc">调度器</em> </strong>只有在构造函数中没有给出<strong class="kk iu"> <em class="nc">调度器</em> </strong>的情况下才会被赋值，它是基于父线程即当前线程来赋值的。一旦我们有了调度器，我们就可以最终用当前的<strong class="kk iu"> <em class="nc">虚拟线程</em> </strong>创建一个延续(<strong class="kk iu"><em class="nc">vthread continuation</em></strong>),并传递我们给定的可运行的<strong class="kk iu"> <em class="nc">任务</em> </strong>。最后，我们给<code class="fe nf ng nh ni b"><strong class="kk iu"><em class="nc">runContinuation</em></strong></code>属性分配了<code class="fe nf ng nh ni b"><strong class="kk iu"><em class="nc">runContinuation</em></strong></code> lambda，以便稍后能够执行它。</p><p id="596f" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi lg translated"><span class="l lh li lj bm lk ll lm ln lo di">所以</span>现在我们已经创建了一个<strong class="kk iu">虚拟线程</strong>，它带有<strong class="kk iu">平台线程</strong>的<strong class="kk iu">调度器</strong>，没有名称，一个<strong class="kk iu"> id </strong>，以及0个特征，我们已经为它分配了一个<strong class="kk iu">延续</strong>，并且已经为<code class="fe nf ng nh ni b"><strong class="kk iu">runContinuation</strong></code>属性分配了<code class="fe nf ng nh ni b"><strong class="kk iu">runContinuation</strong></code>λ。我们刚刚创建的调度器是一个<code class="fe nf ng nh ni b"><strong class="kk iu"><em class="nc">ForkJoinPool</em></strong></code>，默认创建的<code class="fe nf ng nh ni b"><strong class="kk iu"><em class="nc">parallelisation</em></strong></code>级别相当于机器提供的<code class="fe nf ng nh ni b"><strong class="kk iu"><em class="nc">CPU’s</em></strong></code>的数量，还有一个<code class="fe nf ng nh ni b"><strong class="kk iu"><em class="nc">maximum worker pool of 256</em></strong></code>。</p><p id="f9b6" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">从这里开始，描述发生了什么变得相当复杂，因为这涉及到相当多的本机代码调用，我对此了解不多，并且与本文无关。然而，与本文相关的是虚拟线程在其生命周期中所经历的状态。虚拟线程可能会经历以下状态(它们都是<strong class="kk iu"> int </strong>值):</p><ul class=""><li id="04cd" class="nk nl it kk b kl km kp kq kt nm kx nn lb no lf np nq nr ns bi translated"><strong class="kk iu">新0 </strong>:线程开始状态。</li><li id="ce84" class="nk nl it kk b kl nt kp nu kt nv kx nw lb nx lf np nq nr ns bi translated"><strong class="kk iu">启动1 </strong>:虚拟线程<strong class="kk iu">已经启动。</strong></li><li id="a609" class="nk nl it kk b kl nt kp nu kt nv kx nw lb nx lf np nq nr ns bi translated"><strong class="kk iu"> Runnable 2 </strong>:线程<strong class="kk iu">卸载</strong>，这个状态可以分配给一个状态<strong class="kk iu">产出</strong>的线程。线程此时没有运行。</li><li id="1926" class="nk nl it kk b kl nt kp nu kt nv kx nw lb nx lf np nq nr ns bi translated"><strong class="kk iu">运转3 </strong>:螺纹为<strong class="kk iu">运转</strong>并<strong class="kk iu">安装</strong></li><li id="dc71" class="nk nl it kk b kl nt kp nu kt nv kx nw lb nx lf np nq nr ns bi translated"><strong class="kk iu">暂停4 </strong>:开始禁用线程进行调度，除非线程有<strong class="kk iu">许可</strong>。</li><li id="e85a" class="nk nl it kk b kl nt kp nu kt nv kx nw lb nx lf np nq nr ns bi translated"><strong class="kk iu">停5 </strong>:在状态<strong class="kk iu">停</strong>和<strong class="kk iu">让出</strong>后，螺纹得到<strong class="kk iu">停</strong>。<strong class="kk iu">停放</strong>换句话说，就是等待调度。</li><li id="a6e7" class="nk nl it kk b kl nt kp nu kt nv kx nw lb nx lf np nq nr ns bi translated"><strong class="kk iu">钉住6 </strong>:当被<strong class="kk iu">同步</strong>进程延迟，或者执行一些虚拟线程<strong class="kk iu">不支持</strong> <strong class="kk iu">操作</strong>时，如一些<strong class="kk iu"> IO </strong>操作的情况，线程得到<strong class="kk iu">钉住</strong>。其他<strong class="kk iu"> IO </strong>操作以非阻塞方式执行。更准确地说，钉住是一种不允许虚拟线程卸载的方法，如果它正在等待一个尚不可用的对象。</li><li id="1032" class="nk nl it kk b kl nt kp nu kt nv kx nw lb nx lf np nq nr ns bi translated"><strong class="kk iu">放弃7 </strong>:线程得到<strong class="kk iu">卸载</strong>以便<strong class="kk iu">放弃</strong>它对<strong class="kk iu">处理器</strong>的控制，然后当它被允许再次这样做时，它再次得到<strong class="kk iu">装载</strong>。换句话说，它只是返回了<strong class="kk iu">载体线程。</strong>这也是语境切换的一种形式。用(0)睡觉会立即触发这种状态。</li><li id="f788" class="nk nl it kk b kl nt kp nu kt nv kx nw lb nx lf np nq nr ns bi translated"><strong class="kk iu">终止99 </strong> : <strong class="kk iu">虚拟线程的最终</strong>状态。不会再用了。</li><li id="3f40" class="nk nl it kk b kl nt kp nu kt nv kx nw lb nx lf np nq nr ns bi translated"><strong class="kk iu">挂起256 </strong>:卸载后虚拟线程可以<strong class="kk iu">挂起</strong>。</li><li id="e1ab" class="nk nl it kk b kl nt kp nu kt nv kx nw lb nx lf np nq nr ns bi translated"><strong class="kk iu">可运行暂停</strong>:螺纹可以是<strong class="kk iu">可运行</strong>和<strong class="kk iu">暂停</strong>。</li><li id="43c6" class="nk nl it kk b kl nt kp nu kt nv kx nw lb nx lf np nq nr ns bi translated"><strong class="kk iu">停悬</strong>:螺纹可以<strong class="kk iu">停</strong>和<strong class="kk iu">悬</strong>。</li></ul><p id="1a08" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi lg translated">当一个虚拟线程需要睡眠时，它会执行一个<code class="fe nf ng nh ni b"><strong class="kk iu"><em class="nc">delay</em></strong></code>操作。这需要一种叫做<strong class="kk iu">的东西产生</strong>。通过执行<strong class="kk iu">产生</strong>，我们从当前系统线程中卸载当前虚拟线程，并将其控制权让给另一个虚拟线程。</p><p id="4747" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">如果我们正在执行一个阻塞操作，而线程正在阻塞，一个系统线程将被阻塞，但其他的不会。这意味着，比如说。如果您有12个内核，其中11个将用于管理虚拟线程，但只有1个会被阻塞等待。当使用一些在本机代码中阻塞的操作时，会发生阻塞操作，例如使用<code class="fe nf ng nh ni b"><strong class="kk iu"><em class="nc">synchronized</em></strong></code>和<code class="fe nf ng nh ni b"><strong class="kk iu"><em class="nc">Object.wait()</em></strong></code>会导致线程被锁定</p><figure class="mu mv mw mx gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oa"><img src="../Images/41d1a7f5f44b38ce70eddfe06f3cf734.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jWopk5tZOO7XYp1LMF9EUQ.png"/></div></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated"><strong class="bd ls">织机中延续产量<em class="ob">JDK 19</em>T58】</strong></figcaption></figure><p id="8682" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi lg translated">T4:休眠是虚拟线程暂停执行的一种方式。它的行为与运行在<code class="fe nf ng nh ni b"><strong class="kk iu"><em class="nc">synchronised</em></strong></code>代码上的另一个虚拟线程不同。对于这种组合，我们需要另一个叫做<code class="fe nf ng nh ni b"><strong class="kk iu"><em class="nc">VirtualThread.java</em></strong></code>停车的概念:</p><figure class="mu mv mw mx gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oc"><img src="../Images/4a9a99b2cc4be5a18a13a6ff6be0b6d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pSjswwCiw6rc5Tn0qof1KQ.png"/></div></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated"><strong class="bd ls">织机JDK19 </strong>停车</figcaption></figure><p id="e7a5" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi lg translated">当我们使用某种被调度的进程时，例如，一个队列或某些IO操作，就会发生阻塞。如果它们不能运行并且不得不阻塞本地进程，如提到的<code class="fe nf ng nh ni b"><strong class="kk iu">synchronised</strong></code>测试用例，它们将从<strong class="kk iu">停止</strong>状态变为<strong class="kk iu">固定:</strong></p><figure class="mu mv mw mx gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi od"><img src="../Images/27a8ac1fa49e8d9a1b3921e0c3b9517d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ppm1E4Z5xMy418H4QUl4Mw.png"/></div></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated"><strong class="bd ls">织布机中的固定JDK19 </strong></figcaption></figure><p id="b0c0" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">我用测试用例<strong class="kk iu"> <em class="nc">提供了一个例子</em></strong></p><figure class="mu mv mw mx gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oe"><img src="../Images/d9605e2042e4a47f6437878f9003ff78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OKBMyHNv_sisZsZk-Rdv1Q.png"/></div></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated"><strong class="bd ls">在JDK19 </strong>中诱发牵制的例子</figcaption></figure><p id="267e" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">然而，停车是一种很奇怪的状态，我无法再现它。这与这个变量<strong class="kk iu"><em class="nc">notifyJvmtiEvents</em></strong>有关，这个变量显然对使用原生方法的<strong class="kk iu"> <em class="nc">挂载</em> </strong>和<strong class="kk iu"> <em class="nc">卸载</em> </strong>做了一些事情。根据文献记载，<strong class="kk iu"> Parked </strong>是一种状态，标识调度程序中不做任何事情并等待轮到<strong class="kk iu"> Unparked </strong>并被<strong class="kk iu">调度程序</strong>获取的线程。这应该是<strong class="kk iu"> JVM </strong>可以管理的解除阻塞操作的情况，即本机独立。</p><h1 id="f306" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">科特林协程</h1><p id="1704" class="pw-post-body-paragraph ki kj it kk b kl mo kn ko kp mp kr ks kt mq kv kw kx mr kz la lb ms ld le lf im bi lg translated"><span class="l lh li lj bm lk ll lm ln lo di">正如我们之前看到的</span>一样，<strong class="kk iu">协程</strong>与<strong class="kk iu">虚拟线程</strong>非常相似。两者理论上其实没有太大区别。然而，它们的实现确实不同。但是在像我们之前使用虚拟线程一样深入研究它们之前，让我们先熟悉一下<strong class="kk iu"> <em class="nc"> Kotlin </em> </strong>世界的一些术语:</p><ol class=""><li id="3dae" class="nk nl it kk b kl km kp kq kt nm kx nn lb no lf of nq nr ns bi translated"><strong class="kk iu">挂起</strong>:指创建协程的行为。一种称为挂起的方法，只在协程上下文中运行。在执行过程中，此上下文可能会切换到另一个上下文。</li><li id="b900" class="nk nl it kk b kl nt kp nu kt nv kx nw lb nx lf of nq nr ns bi translated">延迟:延迟有点像睡眠，但是只要我们告诉它，它就会暂停或中止正在运行的协程</li><li id="f76b" class="nk nl it kk b kl nt kp nu kt nv kx nw lb nx lf of nq nr ns bi translated"><strong class="kk iu">协程:</strong>就像<strong class="kk iu">虚拟线程</strong>一样，<strong class="kk iu">协程</strong>运行在平台线程上。它还可以自动<strong class="kk iu">切换内容</strong>。</li></ol><h1 id="72cb" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">什么是科特林协程</h1><p id="d3f5" class="pw-post-body-paragraph ki kj it kk b kl mo kn ko kp mp kr ks kt mq kv kw kx mr kz la lb ms ld le lf im bi lg translated">正如你现在可能已经发现的，otlin仍然只不过是一个简单的DSL，它支持一些新的语法，目的是让程序员更容易构建他们的应用程序。当第一次解释<strong class="kk iu">代码</strong>和<strong class="kk iu">字节码</strong>时，这会带来一点混乱。因此，在我们最喜欢的IDE上点击<strong class="kk iu"><em class="nc">startVirtualThread</em></strong>而不是<strong class="kk iu"> Java </strong>这样的东西，在<strong class="kk iu"> Kotlin的情况下，</strong>我们需要找到一种方法来输入<strong class="kk iu"> suspend </strong>代码。我们先看一个这样的例子:</p><figure class="mu mv mw mx gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi og"><img src="../Images/2206a20c0c3c69c9a4b327a69771a902.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w59GmCxeUMjqGavmTQZsHA.png"/></div></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated"><strong class="bd ls">协程的例子</strong></figcaption></figure><p id="4001" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi lg translated">根据你的IDE，你会找到不同的方法来做下面的事情。在<strong class="kk iu"> Intellij </strong>中，幸运的是，有一个工具允许我们查看编译后的<strong class="kk iu">字节码:</strong></p><figure class="mu mv mw mx gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oh"><img src="../Images/892753fb52b5dafbae6823a35aed77c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X6gb9vpKCn6k1rBbY30qTQ.png"/></div></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated"><strong class="bd ls">IntelliJ中的Kotlin工具</strong></figcaption></figure><p id="ff0e" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi lg translated">从这里开始，我们可以点击按钮<strong class="kk iu">反编译</strong>:</p><figure class="mu mv mw mx gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oi"><img src="../Images/fc792391a5bb3bef6b5aca22fe8d9fb5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7SV0eEtTjAdaSNanBEGVTA.png"/></div></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated"><strong class="bd ls">反编译代码</strong></figcaption></figure><p id="72a7" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi lg translated"><span class="l lh li lj bm lk ll lm ln lo di">答</span>我们终于得到了这种代码:</p><figure class="mu mv mw mx gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ne"><img src="../Images/38d5897b661faa05c5a20bc3b80e396c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HifqRF0LPhPhi6gAVlf-jg.png"/></div></div></figure><p id="dc8f" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi lg translated"><span class="l lh li lj bm lk ll lm ln lo di"> P </span>莱蒂凌乱对吗？嗯，这是我们目前的方式，在2022年，把<strong class="kk iu"> Kotlin </strong>代码反编译成<strong class="kk iu"> Java </strong>代码。它本质上并不是真正的Java代码，但是它给了我们一个窗口，让我们了解事情是如何被真正翻译成JVM的。如果我们想跳过这些步骤，看看代码是如何编译的，那么你可能需要使用命令行。出于好奇，如果您确实在命令行中列出了<strong class="kk iu">目标</strong>目录中的文件，您会看到比您通常在编译后的<strong class="kk iu"> Java </strong>类中看到的更多的文件:</p><figure class="mu mv mw mx gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oj"><img src="../Images/42031afb1946e2f3474bf4f26fac41a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ebLUtAifKdmQ1XTEDdjuvw.png"/></div></div></figure><p id="3b8f" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi lg translated"><span class="l lh li lj bm lk ll lm ln lo di"> N </span>注意到我们有<strong class="kk iu">相当</strong>一个<strong class="kk iu">少数</strong>类和一些带有实际<strong class="kk iu">方法</strong>名称的类。看起来不太好，但是<strong class="kk iu"> Kotlin </strong>这样做是因为<strong class="kk iu"> Kotlin </strong>是在<strong class="kk iu"> Java </strong>之上的一层。换句话说，它是一种<strong class="kk iu"> DSL </strong> ( <strong class="kk iu">领域特定语言</strong>)。这意味着我们不会像从Java代码中得到的那样得到T21字节码类。最后，你不需要Java代码，因为字节码是编译时生成的。另一个奇怪的事实是，当你用<strong class="kk iu">默认</strong>使用<strong class="kk iu"> Intellij </strong>时，你并没有真正看到所有这些文件。你唯一看到的是以一种<strong class="kk iu">解读</strong>的方式与他们相对应的科特林人。</p><p id="a483" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi lg translated">无论如何，让我们回到反编译的代码。你注意到我们正在使用一个<strong class="kk iu">延续</strong>吗？我们以前在<strong class="kk iu"> Java </strong>中见过，对吗？让我们像在<strong class="kk iu"> Java </strong>中一样深入研究它:</p><figure class="mu mv mw mx gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ne"><img src="../Images/9dfa725e7977eef1fc65a72608547356.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UxqHCuGYF2s4t-eSt2pEKw.png"/></div></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated"><strong class="bd ls">延续在科特林</strong></figcaption></figure><p id="e1ae" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi lg translated"><span class="l lh li lj bm lk ll lm ln lo di">我们</span>看到一个<code class="fe nf ng nh ni b"><strong class="kk iu"><em class="nc">Continuation</em></strong></code> <strong class="kk iu"> </strong>是一个接口，它有一个<code class="fe nf ng nh ni b"><strong class="kk iu"><em class="nc">CoroutineContext</em></strong></code>和一个<code class="fe nf ng nh ni b"><strong class="kk iu"><em class="nc">resumeWith</em></strong></code>函数。</p><p id="4191" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi lg translated"><span class="l lh li lj bm lk ll lm ln lo di"> A </span>这确实是我们在评估协程时所能做到的最大限度，因为整个库都是用<strong class="kk iu"> Kotlin </strong>源代码开发的，这使得我们很难看出这些代码是如何被翻译成<strong class="kk iu"> Java </strong>的。我想我想说的是，在这一点上，Kotlin协同程序看起来与Java虚拟线程没有太大的不同。但是，另一方面，仅仅因为源代码是用<strong class="kk iu"> Kotlin、</strong>编写的，并不意味着我们不能阅读它。所以让我们试试。</p><figure class="mu mv mw mx gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oc"><img src="../Images/f6ba50a9ef1793bab6be8e51b9600cbb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nouXCEsqG-7mvLjQEvVlTw.png"/></div></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated"><strong class="bd ls">安全延续</strong></figcaption></figure><p id="5035" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi lg translated"><span class="l lh li lj bm lk ll lm ln lo di"> S </span> <strong class="kk iu"> afeContinuation </strong>是<strong class="kk iu"> <em class="nc"> Continuation </em> </strong>的实现。<strong class="kk iu"> <em class="nc"> expect </em> </strong>是一个关键字，在Kotlin中的使用方式与<strong class="kk iu"> native </strong>相同。换句话说，在<strong class="kk iu"> Kotlin </strong>中，这仅仅意味着实现依赖于平台，当然，也不容易访问它。在<strong class="kk iu">协程</strong>代码中，理解任何东西都变得相当困难。在<strong class="kk iu"> Java </strong>中，我可以调试整个<strong class="kk iu"> JDK </strong>，而在<strong class="kk iu"> Kotlin </strong>中，这变得相当困难，我假设这与这样一个事实有关，即<strong class="kk iu"> suspend </strong>被解释为<strong class="kk iu"> Intellij </strong>中的关键字，而不是普通代码。因此，我们并没有那么容易调试像<strong class="kk iu"> <em class="nc">延续</em> </strong>这样的东西。<strong class="kk iu">但是坚持住</strong>！当然，我们可以！。使用<strong class="kk iu"> Kotlin </strong>，就像使用<strong class="kk iu"> Java一样，</strong>我们有时需要猜测代码将落入何处。所以我们采取一个<strong class="kk iu">的胡乱猜测</strong>通过打开<strong class="kk iu"> <em class="nc">运行</em> </strong>的方法在<strong class="kk iu"><em class="nc">dispatched task . kt:</em></strong></p><figure class="mu mv mw mx gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ne"><img src="../Images/e3e639c2122805dd67e758140e0e523c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DZCk6d10nVdONYgUUtsQuw.png"/></div></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated"><strong class="bd ls"> DispatchedTask运行方法</strong></figcaption></figure><p id="2ae0" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi lg translated">如果你运行我的例子，你会看到代码在这里。这个分派的任务允许我们的<strong class="kk iu">协程</strong>运行。</p><p id="1da3" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi lg translated">在 Kotlin中，我们可以用几种方式启动<strong class="kk iu">协程</strong>。我们可以在一个函数中使用<strong class="kk iu"> <em class="nc">挂起</em> </strong>并得到调用它的东西，我们可以用<code class="fe nf ng nh ni b"><strong class="kk iu"><em class="nc">withContext</em></strong></code> <strong class="kk iu"> <em class="nc"> </em> </strong>启动一个协程上下文，我们可以使用<code class="fe nf ng nh ni b"><strong class="kk iu"><em class="nc">runBlocking</em></strong></code> <strong class="kk iu"> <em class="nc">，</em> </strong>加上许多其他方式来实现它们。在我们的测试示例中，我们使用了如下内容:</p><figure class="mu mv mw mx gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ne"><img src="../Images/b9274dcb94ba7937c85197afcb379401.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2Ym5rMseA5YIu3H8v8kPIw.png"/></div></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated"><strong class="bd ls">创建科特林协程的例子</strong></figcaption></figure><p id="b7b9" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi lg translated">我可以帮助你找出协程从哪里开始。在本例中，我们实际上创建了3个协程:</p><ul class=""><li id="7677" class="nk nl it kk b kl km kp kq kt nm kx nn lb no lf np nq nr ns bi translated"><code class="fe nf ng nh ni b"><strong class="kk iu"><em class="nc">suspend</em></strong></code> <strong class="kk iu"> </strong>用调用者的上下文创建一个协程</li><li id="9dd3" class="nk nl it kk b kl nt kp nu kt nv kx nw lb nx lf np nq nr ns bi translated"><code class="fe nf ng nh ni b"><strong class="kk iu"><em class="nc">GlobalScope.launch</em></strong></code>，将在全局上下文中启动协程(强烈建议不要)。总是建议使用<strong class="kk iu"> <em class="nc">协程范围</em> </strong>来代替。</li><li id="267c" class="nk nl it kk b kl nt kp nu kt nv kx nw lb nx lf np nq nr ns bi translated"><code class="fe nf ng nh ni b"><strong class="kk iu"><em class="nc">withContext(IO)</em></strong></code>将在IO环境中创建一个协程。</li></ul><p id="d131" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi lg translated"><span class="l lh li lj bm lk ll lm ln lo di"> T </span> he关键字<code class="fe nf ng nh ni b"><strong class="kk iu"><em class="nc">suspend</em></strong></code> <strong class="kk iu">，</strong>创建一个协程。我们在例子中看不到它。它与父函数<code class="fe nf ng nh ni b"><strong class="kk iu"><em class="nc">suspend fun generalTest()</em></strong></code>相关联。为此，请在代码中查找这个示例。然后我们开始新的<code class="fe nf ng nh ni b"><strong class="kk iu"><em class="nc">GlobalScope</em></strong></code>。<code class="fe nf ng nh ni b"><strong class="kk iu"><em class="nc">GlobalScope</em></strong></code> <strong class="kk iu"> </strong>将用全局上下文启动一个协程。当然，在它下面，我们可以用<code class="fe nf ng nh ni b"><strong class="kk iu"><em class="nc">withContext(IO)</em></strong></code> <strong class="kk iu">启动另一个协程。</strong></p><figure class="mu mv mw mx gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ok"><img src="../Images/fc75dbf7bc382d1767f804e41fd364cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*juXSEjyaHcviq7qk_wdvww.png"/></div></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated"><strong class="bd ls">在Kotlin协同程序库中启动代码</strong></figcaption></figure><p id="5c30" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi lg translated"><span class="l lh li lj bm lk ll lm ln lo di">对<code class="fe nf ng nh ni b"><strong class="kk iu"><em class="nc">Tasks.kt</em></strong></code>处协程实现的</span>深入探究，让我们知道协程有一个<strong class="kk iu">模式</strong>和一个<strong class="kk iu">状态</strong>。</p><p id="1942" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi lg translated"><span class="l lh li lj bm lk ll lm ln lo di">一个</span>协程可以有这些<strong class="kk iu">模式</strong>:</p><ul class=""><li id="c05a" class="nk nl it kk b kl km kp kq kt nm kx nn lb no lf np nq nr ns bi translated"><strong class="kk iu"> TASK_NON_BLOCKIN 0: </strong>任务是CPU绑定的，不会阻塞。</li><li id="45d8" class="nk nl it kk b kl nt kp nu kt nv kx nw lb nx lf np nq nr ns bi translated"><strong class="kk iu">任务_大概_阻塞:1 </strong>:任务大概会阻塞。这就像一个提示，就像我们在虚拟线程中看到的一样，这将让调度程序知道可能需要一个系统线程。</li></ul><p id="22da" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi lg translated"><span class="l lh li lj bm lk ll lm ln lo di"/></p><ul class=""><li id="cebe" class="nk nl it kk b kl km kp kq kt nm kx nn lb no lf np nq nr ns bi translated"><strong class="kk iu"> CPU_ACQUIRED </strong>:获取一个CPU令牌，用它尝试以非阻塞的方式执行一个任务。</li><li id="94e4" class="nk nl it kk b kl nt kp nu kt nv kx nw lb nx lf np nq nr ns bi translated"><strong class="kk iu">阻塞:</strong>任务正在阻塞，唯一允许阻塞的<strong class="kk iu"> <em class="nc">模式</em> </strong>是<strong class="kk iu">任务_可能_阻塞。</strong></li><li id="067a" class="nk nl it kk b kl nt kp nu kt nv kx nw lb nx lf np nq nr ns bi translated"><strong class="kk iu">暂停:</strong>它暂停一个线程，就像我们之前看到的，暂停发生在线程不能被临时执行的时候。</li><li id="5e36" class="nk nl it kk b kl nt kp nu kt nv kx nw lb nx lf np nq nr ns bi translated">休眠:它保持休眠状态，直到它可以执行另一个任务。这与<strong class="kk iu">停车</strong>不同，因为<strong class="kk iu">停车</strong>意味着工人已经负责一项任务。</li><li id="b4ab" class="nk nl it kk b kl nt kp nu kt nv kx nw lb nx lf np nq nr ns bi translated"><strong class="kk iu">终止:</strong>这是工作者的最后状态</li></ul><p id="b644" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi lg translated"><span class="l lh li lj bm lk ll lm ln lo di"> F </span>最后，<strong class="kk iu">协程</strong>在<strong class="kk iu"><em class="nc">dispatchedcoroutine . kt</em></strong>中有这些状态:</p><ul class=""><li id="8914" class="nk nl it kk b kl km kp kq kt nm kx nn lb no lf np nq nr ns bi translated"><strong class="kk iu">恢复2: </strong>仅在协程仍未<strong class="kk iu">决定</strong>时可能设置。协调官正在执行死刑</li><li id="3723" class="nk nl it kk b kl nt kp nu kt nv kx nw lb nx lf np nq nr ns bi translated"><strong class="kk iu">暂停1: </strong>仅在协程仍未<strong class="kk iu">决定</strong>时可能设置。协程被挂起。</li><li id="405a" class="nk nl it kk b kl nt kp nu kt nv kx nw lb nx lf np nq nr ns bi translated"><strong class="kk iu">未定0: </strong>协程的初始状态(在源代码中也称为<strong class="kk iu"> <em class="nc"> _decision </em> </strong>)</li></ul><p id="8e8a" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi lg translated">这些是我们启动协程时常见的状态。在设计时，我们并不真正关心<strong class="kk iu">工人</strong>如何做它的事情，我们也绝对不关心<strong class="kk iu">模式</strong>。然而，了解这些关于<strong class="kk iu">协程</strong>的<strong class="kk iu">基本</strong> <strong class="kk iu">概念</strong>或者至少意识到它们的存在会非常有帮助。</p><p id="96c7" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi lg translated"><span class="l lh li lj bm lk ll lm ln lo di">作为</span>的概括，协程可以从<strong class="kk iu"> <em class="nc">暂停</em> </strong>功能、<code class="fe nf ng nh ni b"><strong class="kk iu"><em class="nc">withContext</em></strong></code>或<strong class="kk iu">启动开始。</strong> <code class="fe nf ng nh ni b"><strong class="kk iu"><em class="nc">withContext</em></strong></code>和<code class="fe nf ng nh ni b"><strong class="kk iu"><em class="nc">launch</em></strong></code>不能在协程上下文之外工作。如果你需要创建这样的上下文，那么你需要使用类似于<code class="fe nf ng nh ni b"><strong class="kk iu"><em class="nc">runBlocking</em></strong></code>或者<code class="fe nf ng nh ni b"><strong class="kk iu"><em class="nc">suspend</em></strong></code> <strong class="kk iu"> <em class="nc"> </em> </strong>的函数。</p><h1 id="a517" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated"><strong class="ak">虚拟线程和协程的相似性</strong></h1><p id="8b37" class="pw-post-body-paragraph ki kj it kk b kl mo kn ko kp mp kr ks kt mq kv kw kx mr kz la lb ms ld le lf im bi lg translated"><span class="l lh li lj bm lk ll lm ln lo di">现在我们已经检查了代码，让我们通过深入理论来理解它。关于<strong class="kk iu">协程</strong>和<strong class="kk iu"> java虚拟线程</strong>的理论几乎可以在互联网上的任何地方找到，我进行测试的repo包含了许多关于它的信息的链接。在这一点上，我们需要知道的关于这两种实现的最基本的东西是:</span></p><ol class=""><li id="f703" class="nk nl it kk b kl km kp kq kt nm kx nn lb no lf of nq nr ns bi translated">两者都是基于<strong class="kk iu"> 1958 </strong>发明的原始协程原理。这确实不是什么新概念</li><li id="ff0c" class="nk nl it kk b kl nt kp nu kt nv kx nw lb nx lf of nq nr ns bi translated">两者都是基于这样的想法，你可以<strong class="kk iu">挂起</strong>一个<strong class="kk iu">函数运行时</strong>来为另一个<strong class="kk iu">函数运行时</strong><strong class="kk iu"/>让路。</li><li id="0026" class="nk nl it kk b kl nt kp nu kt nv kx nw lb nx lf of nq nr ns bi translated">两者都使用<strong class="kk iu">钉住、休眠、</strong>和<strong class="kk iu">停放</strong>等概念在主线程上实现了<code class="fe nf ng nh ni b"><strong class="kk iu"><em class="nc">suspend</em></strong></code>和<code class="fe nf ng nh ni b"><strong class="kk iu"><em class="nc">waiting</em></strong></code>的思想。</li><li id="89df" class="nk nl it kk b kl nt kp nu kt nv kx nw lb nx lf of nq nr ns bi translated">两者都由<strong class="kk iu"> JVM </strong>管理，而不是由<strong class="kk iu">系统</strong>管理</li><li id="32f1" class="nk nl it kk b kl nt kp nu kt nv kx nw lb nx lf of nq nr ns bi translated">两者都避免创建全新的<strong class="kk iu">平台</strong>线程，并利用已经运行的线程。它们是在线程池中启动的。<strong class="kk iu">用于Java虚拟线程的ForkJoinPool</strong>和<strong class="kk iu">协同程序调度器</strong>用于<strong class="kk iu"> Kotlin协同程序</strong>。</li><li id="4458" class="nk nl it kk b kl nt kp nu kt nv kx nw lb nx lf of nq nr ns bi translated">尽管我们只能拥有与我们的<strong class="kk iu"> CPU内核</strong>一样多的<strong class="kk iu">平台</strong> <strong class="kk iu">线程</strong>，但我们可以启动不同的进程，其<strong class="kk iu">并行化水平</strong>最高可达我们拥有的<strong class="kk iu">内核数量</strong>，并同时启动我们想要的尽可能多的进程，直到我们的机器能够处理的极限。我们更多地并行执行的错觉是通过不允许系统线程尽可能阻塞而产生的。</li><li id="763f" class="nk nl it kk b kl nt kp nu kt nv kx nw lb nx lf of nq nr ns bi translated">严格来说，两人都不睡觉。最起码他们不会在<code class="fe nf ng nh ni b"><strong class="kk iu"><em class="nc">blocking</em></strong></code> <strong class="kk iu"> </strong>状态下睡觉。在Java中，这是通过<code class="fe nf ng nh ni b"><strong class="kk iu"><em class="nc">Thread.sleep</em></strong></code>无缝完成的，它使用非阻塞技术，给线程一个<strong class="kk iu">暂停</strong>状态，并给它一个<strong class="kk iu">许可</strong>。<strong class="kk iu">停车</strong>意味着睡眠，而<strong class="kk iu">解锁</strong>意味着<strong class="kk iu">醒来</strong>。在Kotlin中，延迟确保当前执行得到调度<strong class="kk iu">稍后执行。但是深入探究让我们看到<strong class="kk iu">停车</strong>和<strong class="kk iu">解锁</strong>也是实现的一部分。</strong></li><li id="c82c" class="nk nl it kk b kl nt kp nu kt nv kx nw lb nx lf of nq nr ns bi translated">两者有不同的方式来做<strong class="kk iu">牵制</strong>。在Java中，钉住是为了将一个线程紧紧地固定在它的载体线程上。这发生在同步方法中。在Kotlin协同程序中，执行<strong class="kk iu">被固定</strong>到一个CPU线程上。挂起和恢复操作将确保协程将在同一线程上运行，直到结束。同样，Kotlin也有同步方法，当然，他们也使用<strong class="kk iu">牵制</strong></li><li id="bd25" class="nk nl it kk b kl nt kp nu kt nv kx nw lb nx lf of nq nr ns bi translated">在这两种情况下，线程都是本机线程的薄薄的包装。</li></ol><h1 id="3d18" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">Java虚拟线程测试实现</h1><p id="91dc" class="pw-post-body-paragraph ki kj it kk b kl mo kn ko kp mp kr ks kt mq kv kw kx mr kz la lb ms ld le lf im bi lg translated">为了执行这些测试集，我创建了一个框架，它允许我在时间和空间上测量具有不同复杂性的不同方法的运行时间。这个想法是给不同种类的进程足够的变化，并看看当同时部署几个虚拟线程时所有的变化是如何进行的。对于这些测试，我对测量一个特定虚拟线程执行所花费的时间不感兴趣。相反，我想衡量整体，看看它是如何发挥出来的。用于性能测量的代码还包含报告代码、文件管理代码和CSV文件生成算法，以帮助确定一个时间点允许部署多少java虚拟线程。让我们看一下接收lambda作为参数的方法，该参数包括其他参数，以便执行、实施和测量每个单独测试的持续时间:</p><figure class="mu mv mw mx gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ol"><img src="../Images/6f74b4a6bd8afba2c543ccf4b85b1797.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r3PRV9rihZbjOp5Mh4odKA.png"/></div></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated"><strong class="bd ls">在Java中执行单独测试</strong></figcaption></figure><p id="11f0" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi lg translated"><span class="l lh li lj bm lk ll lm ln lo di">所以</span>我在这里创造的只是一种方法，灵感来自我从<strong class="kk iu">科特林</strong>那里学到的一些东西。让我们分别来看看它们</p><ul class=""><li id="54b5" class="nk nl it kk b kl km kp kq kt nm kx nn lb no lf np nq nr ns bi translated"><code class="fe nf ng nh ni b"><strong class="kk iu"><em class="nc">testName</em></strong></code> <strong class="kk iu"> </strong>只是一种方法的名称</li><li id="9527" class="nk nl it kk b kl nt kp nu kt nv kx nw lb nx lf np nq nr ns bi translated"><code class="fe nf ng nh ni b"><strong class="kk iu"><em class="nc">methodName</em></strong></code>是一个参数，它让我们知道我们正在测试什么方法。在<strong class="kk iu"> Kotlin </strong>中，我们将在后面看到，我们可以通过反射轻松地获得方法名，而没有太多麻烦。但是在Java<strong class="kk iu">中，我仍然不得不硬编码方法名，并把它作为一个输入参数，这是一个快速的双赢解决方案。</strong></li><li id="8f9a" class="nk nl it kk b kl nt kp nu kt nv kx nw lb nx lf np nq nr ns bi translated"><code class="fe nf ng nh ni b"><strong class="kk iu"><em class="nc">timeComplexity</em></strong></code> <strong class="kk iu"> </strong>实际上是一个<strong class="kk iu">字符串</strong>，您可以在其中放置您想要的任何内容，但是它是用来表示被测试方法的<strong class="kk iu">大O符号</strong>。这对于了解方法复杂性是否会对性能产生影响非常重要</li><li id="d422" class="nk nl it kk b kl nt kp nu kt nv kx nw lb nx lf np nq nr ns bi translated"><code class="fe nf ng nh ni b"><strong class="kk iu"><em class="nc">spaceComplexity</em></strong></code> <strong class="kk iu"> </strong>也是字面上的一个<strong class="kk iu">字符串</strong>但是在这里，是用来表示空间复杂度的</li><li id="6a78" class="nk nl it kk b kl nt kp nu kt nv kx nw lb nx lf np nq nr ns bi translated"><code class="fe nf ng nh ni b"><strong class="kk iu"><em class="nc">sampleTest</em></strong></code>只是一个供应商，所以我们在日志中看到了单个测试的输出片段</li><li id="2f90" class="nk nl it kk b kl nt kp nu kt nv kx nw lb nx lf np nq nr ns bi translated"><code class="fe nf ng nh ni b"><strong class="kk iu"><em class="nc">toTest</em></strong></code>是要运行的实际测试吗</li><li id="a8bd" class="nk nl it kk b kl nt kp nu kt nv kx nw lb nx lf np nq nr ns bi translated"><code class="fe nf ng nh ni b"><strong class="kk iu"><em class="nc">repeats</em></strong></code>是它将运行的次数</li></ul><p id="e02a" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi lg translated"><span class="l lh li lj bm lk ll lm ln lo di"> J </span>为了清楚起见，<code class="fe nf ng nh ni b"><strong class="kk iu"><em class="nc">timeComplexity</em></strong></code>和<code class="fe nf ng nh ni b"><strong class="kk iu"><em class="nc">spaceComplexity</em></strong></code>应以渐进的方式进行测试，从小输入到缓慢增加的输入。将来的某个时候，我的网站<a class="ae lp" href="http://joaofilipesabinoesperancinha.nl" rel="noopener ugc nofollow" target="_blank">http://joaofilipesabinoesperancinha . nl</a>将会提供这一进展。由于个人电脑的限制，进行进展测试有点困难，所以这两个因素在本文的结果中并没有起到重要作用。在我为本文创建的<a class="ae lp" href="https://github.com/jesperancinha/good-story" rel="noopener ugc nofollow" target="_blank">项目中，每个方法的单独实现应该很容易阅读。</a></p><p id="2747" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated"><strong class="kk iu"><em class="nc">startProcessAsync</em></strong>是调用startVirtualThread方法的地方:</p><figure class="mu mv mw mx gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ne"><img src="../Images/71c92721bed34f6012b60e3659edf95e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0M56yudMTwgS_p-_2pG3aw.png"/></div></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated"><strong class="bd ls"> <em class="ob"> startProcessAsync测试虚拟线程</em> </strong></figcaption></figure><h1 id="9beb" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">空降到科罗特斯</h1><p id="5674" class="pw-post-body-paragraph ki kj it kk b kl mo kn ko kp mp kr ks kt mq kv kw kx mr kz la lb ms ld le lf im bi lg translated">与<strong class="kk iu"> Java虚拟线程</strong>相比，C  oroutines有一个稍微复杂一点的范例。这是因为它为你提供了不同的<strong class="kk iu">选项</strong>来启动它们。<strong class="kk iu"> Java虚拟线程</strong>也有这个功能，但是<strong class="kk iu"> Kotlin </strong>更进一步，通过改变自己的语法来适应这些变化。然而它的<strong class="kk iu">复杂性</strong>使得它相当<strong class="kk iu">复杂</strong>。对我来说，这非常有趣，但是对于一般的开发人员来说，这可能有点过了。简而言之，<strong class="kk iu"> Kotlin </strong> <strong class="kk iu">协程</strong>允许你异步启动一个<strong class="kk iu">执行，等待返回对象</strong>，同样的事情<strong class="kk iu">不等待返回对象</strong>，<strong class="kk iu">挂起当前的协程，转而执行另一个</strong>，在<strong class="kk iu">不同的</strong>或<strong class="kk iu">相同的</strong>上下文中，它有<strong class="kk iu"> 4个不同的抽象</strong>用于运行 它允许你以<strong class="kk iu">延迟</strong>的名义<strong class="kk iu">睡眠</strong>，这是<strong class="kk iu">调度</strong>一个最终的睡眠动作，它允许你创建特殊的<strong class="kk iu"> IO特定上下文</strong>并启用协程功能。 这些是我们在这一部分将要学习的基础知识。现在，让我们看看以下内容:</p><figure class="mu mv mw mx gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi om"><img src="../Images/072467b6d3347367903040dfabbc5aad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a0R0AOnYJam0Imd8R45bXA.png"/></div></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated"><strong class="bd ls">运行协程的多种方式</strong></figcaption></figure><p id="c5fc" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi lg translated"><span class="l lh li lj bm lk ll lm ln lo di"> Y </span>你会在许多教程中发现，人们使用<strong class="kk iu">线状曲线</strong>来表示协程的工作方式。我以前也这样做过，但在我看来，这可能有点误导。或者你可以争辩说，这只是对初学者的介绍。然而，协程并不像<strong class="kk iu"> <em class="nc">线程</em> </strong>那样工作，尽管在代码的某些地方你可能会有这样的印象。在这一点上，如果你读了上面所有的内容，你可能已经明白我为什么这么说了。如果你运行位于类<strong class="kk iu"><em class="nc">coroutineshortexplained . kt</em></strong><em class="nc">，</em>中的上述代码，你会看到这些代码大部分运行在线程<strong class="kk iu"> main </strong>上。所以你可能会问自己，为什么在一个线程中，我们可以等待<strong class="kk iu"> 2秒</strong>然后<strong class="kk iu"> 2秒，</strong>然后整个过程正好需要<strong class="kk iu"> 2秒来执行</strong>？这是因为与<code class="fe nf ng nh ni b"><strong class="kk iu"><em class="nc">Thread.sleep</em></strong></code> <strong class="kk iu"> </strong>(对于协程)不同的是，<code class="fe nf ng nh ni b"><strong class="kk iu"><em class="nc">delay</em></strong></code> <strong class="kk iu"> </strong>操作将当前的协程安排在稍后执行，而<strong class="kk iu">将它驻留在</strong>中。这将释放主线程以继续执行。当<strong class="kk iu"> 2秒</strong>过去后，协程<strong class="kk iu">解锁</strong>并再次启动。对于<strong class="kk iu"> <em class="nc"> async，</em> </strong>我们做的和<strong class="kk iu"> launch </strong>一样，但是在这种情况下，无论接收者返回什么，我们都返回。在这种情况下，只是一个<strong class="kk iu">单元</strong>，因为它不返回任何内容。最后，我们遇到了<code class="fe nf ng nh ni b"><strong class="kk iu"><em class="nc">withContext</em></strong></code>，它的作用是将<strong class="kk iu"> 500 </strong> <strong class="kk iu"> ms </strong>加到这个函数的总等待时间上。原因是<code class="fe nf ng nh ni b"><strong class="kk iu"><em class="nc">withContext</em></strong></code>执行上下文切换。它挂起调用的协程并运行它的执行，在执行结束时返回给调用者。不管运行它的系统线程是什么，都会发生这种情况。这就是为什么当我们运行整个代码时，我们在运行时得到大约<strong class="kk iu">3500</strong>T52】ms:</p><figure class="mu mv mw mx gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi on"><img src="../Images/2d935472928e55761e18cb09e5a20fdf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zg26bxs2lYFtg5twXcPL9A.png"/></div></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated"><strong class="bd ls">运行简短协程的结果示例</strong></figcaption></figure><p id="97cc" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi lg translated">这些是基本的，但是了解不同的上下文有什么作用也很重要:</p><ul class=""><li id="44c1" class="nk nl it kk b kl km kp kq kt nm kx nn lb no lf np nq nr ns bi translated"><strong class="kk iu"> IO </strong>:这个上下文在阻塞操作期间管理协程的方式与Java虚拟线程在<strong class="kk iu">钉住</strong>期间的方式相同。<strong class="kk iu"> </strong>你可以在执行结果2中看到这一点。它专门用于<strong class="kk iu"> IO </strong>操作期间，以便在可能的情况下，允许<strong class="kk iu"> IO </strong>操作以非阻塞方式执行。</li><li id="2788" class="nk nl it kk b kl nt kp nu kt nv kx nw lb nx lf np nq nr ns bi translated"><strong class="kk iu">默认</strong>:它至少使用2个内核才能工作，并且默认使用一个线程池，其中包含的线程数与可用内核数一样多。您可以在7号执行结果中看到这一点。如果可能的话，它将使用来自可用JVM线程池的不同线程。否则，它将使用第一个。</li><li id="467c" class="nk nl it kk b kl nt kp nu kt nv kx nw lb nx lf np nq nr ns bi translated"><strong class="kk iu">未受限</strong>:表示调度器不一定会继续在同一个线程上执行。您可以在执行结果6中看到这一点。它的标准是使用第一个可用的线程，使它非常快。这个线程和<code class="fe nf ng nh ni b"><strong class="kk iu"><em class="nc">Default</em></strong></code> <strong class="kk iu">，</strong>的细微区别在于<code class="fe nf ng nh ni b"><strong class="kk iu"><em class="nc">Default</em></strong></code>如果可能的话会选择第一个不同的线程，而<code class="fe nf ng nh ni b"><strong class="kk iu"><em class="nc">Unconfined</em></strong></code>允许调度程序选择任何第一个可用的线程。</li><li id="f994" class="nk nl it kk b kl nt kp nu kt nv kx nw lb nx lf np nq nr ns bi translated"><strong class="kk iu"> Main: </strong>这个是平台相关的，不一定要存在。它有时被称为特定于<strong class="kk iu"> Android的上下文</strong>，但实际上，它只是指运行它的平台定义它的<strong class="kk iu">实现。</strong></li></ul><p id="ab7f" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi lg translated"><span class="l lh li lj bm lk ll lm ln lo di">在</span>项目织机中，<code class="fe nf ng nh ni b"><strong class="kk iu"><em class="nc">Thread.sleep</em></strong></code>，不能再被认为是阻塞操作。至少不是严格意义上的。然而，当运行Kotlin协同程序时，执行线程是<strong class="kk iu">而不是</strong>被认为是<strong class="kk iu">虚拟线程</strong>。它反而是由<strong class="kk iu">kot Lin</strong><strong class="kk iu">coroutines</strong>核心库提供的一个<strong class="kk iu"> <em class="nc"> Worker </em> </strong>。<code class="fe nf ng nh ni b"><strong class="kk iu"><em class="nc">Worker</em></strong></code>是<code class="fe nf ng nh ni b"><strong class="kk iu"><em class="nc">Thread</em></strong></code> <strong class="kk iu"> </strong>接口的一个实现，因此<code class="fe nf ng nh ni b"><strong class="kk iu"><em class="nc">Worker</em></strong></code>是一个协程，它也是<code class="fe nf ng nh ni b"><strong class="kk iu"><em class="nc">Thread</em></strong></code> <strong class="kk iu">，</strong>但是因为它不是<code class="fe nf ng nh ni b"><strong class="kk iu"><em class="nc">VirtualThread</em></strong></code>的类型，所以它不会被<strong class="kk iu">安排</strong>休眠，而是仍然阻塞整个执行:</p><figure class="mu mv mw mx gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oo"><img src="../Images/6d1c8143b71eb1d6545aaf62798bd731.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z8WCyO1yplN7KjhxjyKJ3w.png"/></div></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated"><strong class="bd ls">在织布机项目中休眠一个虚拟线程——JDK 19</strong></figcaption></figure><h1 id="ea1f" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">协程测试实现</h1><p id="1a59" class="pw-post-body-paragraph ki kj it kk b kl mo kn ko kp mp kr ks kt mq kv kw kx mr kz la lb ms ld le lf im bi lg translated">协程测试函数的实现与它的java方法对应物非常相似，但是我们快速浏览一下它是很重要的:</p><figure class="mu mv mw mx gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi op"><img src="../Images/89b724444cb78d2b01c92f605fed462d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Va1r0Eo3mt-Zn5CpH6tXgg.png"/></div></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated"><strong class="bd ls">在Kotlin中执行单独测试</strong></figcaption></figure><p id="2967" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi lg translated"><span class="l lh li lj bm lk ll lm ln lo di">A</span>l虽然这位看起来一样，但是有一点小区别。因为我们希望将数据保存到一个文件中，并且我们希望这些数据都是非阻塞的，所以我们在<strong class="kk iu"> IO </strong>上下文下用一个协程开始整个过程。一旦我们做到了这一点，我们就可以开始在异步上下文中测试这个方法了:</p><figure class="mu mv mw mx gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oq"><img src="../Images/13977c4958c7df8194465bd8db780d68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6sBB-VnMRwVbUM3K8-Qj-A.png"/></div></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated"><strong class="bd ls">在Kotlin执行个人测试</strong></figcaption></figure><h1 id="21bd" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">测试前</h1><p id="b177" class="pw-post-body-paragraph ki kj it kk b kl mo kn ko kp mp kr ks kt mq kv kw kx mr kz la lb ms ld le lf im bi lg translated">让这篇文章很难写的一个原因是要清楚地解释这里的目标。我是否在尝试测量虚拟线程相对于<strong class="kk iu">协程</strong>的性能，反之亦然？绝对的！<strong class="kk iu">虚拟线程</strong>和<strong class="kk iu">协程</strong>是用来解决性能问题的吗？简短的回答是一个巨大的<strong class="kk iu">不</strong>！<strong class="kk iu">长回答</strong>是<strong class="kk iu">复杂</strong>。延续组织正在解决的问题是我们的资源短缺。通过让<strong class="kk iu"> JVM </strong>处理<strong class="kk iu">并发</strong>，我们现在可以用<strong class="kk iu">结构化并发</strong>的方式编写代码，我们被允许<strong class="kk iu">同时触发几个进程</strong>，我们可以<a class="ae lp" href="http://libdill.org/structured-concurrency.html" rel="noopener ugc nofollow" target="_blank">封装它们</a>。</p><p id="65e4" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">解释为什么<strong class="kk iu"> Java虚拟线程</strong>和<strong class="kk iu"> Kotlin协同程序</strong>允许我们以结构化并发方式编程，这本身就是一篇全新的文章，但我认为如果我们在简短的定义中使用我们的常识，我们就可以立即明白为什么会这样:</p><blockquote class="or os ot"><p id="6d41" class="ki kj nc kk b kl km kn ko kp kq kr ks ou ku kv kw ov ky kz la ow lc ld le lf im bi translated"><a class="ae lp" href="http://libdill.org/structured-concurrency.html" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu">结构化并发意味着并发函数的生存期被干净地嵌套</strong> </a></p></blockquote><p id="4597" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">我们<strong class="kk iu">触发它们</strong>，但是我们不一定开始<strong class="kk iu">运行它们</strong>。<strong class="kk iu">平台线程</strong>是非常昂贵的进程，会占用<strong class="kk iu">空间</strong>、<strong class="kk iu">和启动时间</strong>，并且它们受限于你的机器的<strong class="kk iu">内核</strong>的数量。这在实践中意味着什么，并且作为延续的任何实现的结果，是我们突然有了如此多的资源，以至于现在已经有人在谈论并发和异步编程是否值得努力。我的测试所做的是允许我<strong class="kk iu">耗尽资源</strong>直到讨论双方的实现都受到挑战。这就是性能测试的用武之地。<strong class="kk iu">当资源耗尽时，管理延续</strong>需要以智能的方式完成，这就是为什么我强调这两个实现。我可以发现<strong class="kk iu">协程</strong>比<strong class="kk iu">虚拟线程</strong>好得多，或者我可以发现<strong class="kk iu">虚拟线程</strong>好得多。或者，也许我会发现实际上没有什么不同，因为我们已经看到这两种实现之间似乎没有什么大的不同。</p><p id="fde5" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi lg translated">当然，为了能够生成这样的测试，这里构建了许多代码。如果您在应用程序的根目录下运行<code class="fe nf ng nh ni b"><strong class="kk iu">make clean build-run</strong></code>，您将会看到一个<code class="fe nf ng nh ni b"><strong class="kk iu">dump</strong></code>目录被生成。在里面你会发现两个目录<code class="fe nf ng nh ni b"><strong class="kk iu">java</strong></code>和<code class="fe nf ng nh ni b"><strong class="kk iu">kotlin</strong></code>。这是我们测试结果的来源。在每种情况下都会生成两种类型的文件。有一个可读的<code class="fe nf ng nh ni b"><strong class="kk iu">mardown</strong></code>文件和几个相当不可读的<code class="fe nf ng nh ni b"><strong class="kk iu">csv</strong></code>文件。这些<code class="fe nf ng nh ni b"><strong class="kk iu">csv</strong></code>文件是成对创建的。一个文件包含方法名，另一个包含方法名但以<strong class="kk iu"> -ms. </strong>结尾，第一个文件的前两列包含<strong class="kk iu">开始</strong>和<strong class="kk iu">结束</strong>时间戳，每个<code class="fe nf ng nh ni b"><strong class="kk iu">virtual-thread</strong></code> <strong class="kk iu"> / </strong> <code class="fe nf ng nh ni b"><strong class="kk iu">coroutine</strong></code>。第三列包含执行该进程的<strong class="kk iu">运行线程</strong>的名称。</p><p id="077b" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi lg translated"><span class="l lh li lj bm lk ll lm ln lo di"> F </span>最后，在<strong class="kk iu">根</strong>上，生成另一个<code class="fe nf ng nh ni b"><strong class="kk iu">markdown</strong></code>文件，里面有一个简短的比较报告，尽可能的在<code class="fe nf ng nh ni b"><strong class="kk iu">Java</strong></code>和<code class="fe nf ng nh ni b"><strong class="kk iu">Kotlin</strong></code>中，关于以相同方式实现的不同方法。这个文件叫做<code class="fe nf ng nh ni b"><strong class="kk iu">Log.md.</strong></code></p><p id="1b34" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi lg translated">但是我们仍然要看看这两种技术理论背后的另一种可视化。这个想法是你可以在暂停之前的执行的同时执行其他的东西。虚拟线程的工作方式有点像这样，这只是一个过于简化的表示:</p><figure class="mu mv mw mx gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ox"><img src="../Images/cad1a71ff381d2969ed2ec41ab8d0026.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uNl1S15cSI_r4QFyAW3Abg.png"/></div></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated"><strong class="bd ls">解释虚拟线程</strong></figcaption></figure><p id="f133" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">协程程序实际上给出了相同类型的结构，这也只是另一个过于简化的例子:</p><figure class="mu mv mw mx gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ox"><img src="../Images/9b05e52bf13e1a5b5d299d1d31ec3805.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UdC-DUGnEKe9FLDVPT7dcQ.png"/></div></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated"><strong class="bd ls">解释协程</strong></figcaption></figure><p id="ef48" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi lg translated"><span class="l lh li lj bm lk ll lm ln lo di"> T </span>在这两种情况下唯一发生的事情是在可用线程之间进行<strong class="kk iu">切换</strong>，而不管它们是如何在一个<strong class="kk iu">低级别</strong>上实现的。在仅使用<strong class="kk iu">平台</strong> <strong class="kk iu">线程</strong>的并发环境中，没有上下文切换，因此进行阻塞调用总是意味着在被允许继续之前等待阻塞调用完成。<strong class="kk iu">协程</strong>或<strong class="kk iu">延续</strong>通过确保我们尽可能避免任何阻塞来最大限度地探索<strong class="kk iu">线程</strong>。如果我们正在等待一个阻塞调用，那么当我们完成时，我们将返回到那个协同程序，但是同时我们只是让另一个协同程序在另一个线程中或者甚至在同一个线程上移动。这使得我们现在能够以一种<strong class="kk iu">结构化并发</strong>的方式来实现，如果我们愿意的话，这是我们仍然需要在代码中显式地做的事情。</p><p id="7fbe" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">它们在低层次上可能是不同的，但我看到的是，在高层次上，<strong class="kk iu"> Kotlin协同程序</strong>和<strong class="kk iu"> Java虚拟线程</strong>(过去也称为<strong class="kk iu">纤程</strong>)是完全一样的东西。</p><p id="c733" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">为了让这篇文章更有趣一点，我把所有这些算法都会遇到的数据源做成一个小的发展中的小说。时间越长，这两种不同的实现就越难工作。这部小小说讲述了一个名叫露西的女人，当生活变得对她来说太艰难时，她努力回到积极的生活中，并面对她留下的挑战。这些都可以在<a class="ae lp" href="https://github.com/jesperancinha/good-story" rel="noopener ugc nofollow" target="_blank">项目库</a>中的<code class="fe nf ng nh ni b"><strong class="kk iu">GoodStory.md</strong></code> <strong class="kk iu"> </strong>文件中找到。</p><blockquote class="or os ot"><p id="cb31" class="ki kj nc kk b kl km kn ko kp kq kr ks ou ku kv kw ov ky kz la ow lc ld le lf im bi translated">这个故事的灵感来自我自己的个人生活。这个故事围绕着露西展开，她是一个寻找生命意义的年轻女人，仍然肩负着整个世界的重量，但仍然有着强烈的心跳，提醒她还没有结束。生活仍然有很多东西可以提供给露西。这个故事是用虚构的神和人物以隐喻的方式讲述的。它包含了感觉的物化以及它们如何显化。</p></blockquote><h1 id="5f6c" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">试验结果</h1><p id="3091" class="pw-post-body-paragraph ki kj it kk b kl mo kn ko kp mp kr ks kt mq kv kw kx mr kz la lb ms ld le lf im bi lg translated"><span class="l lh li lj bm lk ll lm ln lo di">正如我之前提到的</span>，运行这些测试的最佳方式是通过命令行，但是您也可以通过<strong class="kk iu"> <em class="nc"> IntelliJ </em> </strong>来运行它们。</p><p id="9ad1" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi lg translated"><span class="l lh li lj bm lk ll lm ln lo di">如果</span>你通过<strong class="kk iu"> <em class="nc"> Intellij </em> </strong>运行它们，你将需要运行至少两个主类。一个用于<strong class="kk iu"> Java </strong>，另一个用于<strong class="kk iu"> Kotlin </strong>。它们分别是<strong class="kk iu">GoodStoryJava.java</strong>和<strong class="kk iu"> GoodStoryKotlin.kt. </strong>我们需要用这些参数运行它们:</p><pre class="mu mv mw mx gt oy ni oz pa aw pb bi"><span id="3879" class="pc lr it ni b gy pd pe l pf pg">-f docs/good.story/GoodStory.md -lf Log.md  -dump dump</span></pre><p id="b20d" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi lg translated">特别是对于Java，我们必须启用JDK19特性:</p><pre class="mu mv mw mx gt oy ni oz pa aw pb bi"><span id="3f78" class="pc lr it ni b gy pd pe l pf pg">--enable-preview</span></pre><p id="62f2" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi lg translated"><span class="l lh li lj bm lk ll lm ln lo di">如果</span>你有<strong class="kk iu"> VisualVM </strong>请让它同时运行。我能够在<strong class="kk iu">虚拟虚拟机</strong>崩溃之前抓拍这些快照:</p><figure class="mu mv mw mx gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ph"><img src="../Images/5e31c9dc1e18fc45ba4569310acd2b39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fD_1qRORN60_Xnd1-d3R2Q.png"/></div></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated"><strong class="bd ls"> Java虚拟线程捕获</strong></figcaption></figure><p id="4c4f" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi lg translated">我能够用同样的方式为Kotlin协同程序项目捕捉到这一点:</p><figure class="mu mv mw mx gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi pi"><img src="../Images/68c5f1e91c1ea945cd60d4aabda25c8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S_zc5D_icmi7N5CbeqV9kw.png"/></div></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated"><strong class="bd ls">科特林协程俘获</strong></figcaption></figure><p id="e932" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi lg translated">这里有几个区别，但那只是名字上的区别。在两次捕获之间，我们为Java虚拟线程获得了<strong class="kk iu">ForkJoinPool-1-worker-N</strong>，为<strong class="kk iu"> Kotlin </strong>协程获得了<strong class="kk iu">default dispatcher-worker-N</strong>。这些工作器负责协调协程、协程上下文、上下文切换，并将协程分配给系统线程。Java <strong class="kk iu"> ForkJoinPool </strong>开始设置最大<strong class="kk iu"> 256 </strong>个工人。<strong class="kk iu">协同程序调度器</strong>从<strong class="kk iu"> 2097150 </strong>工人的最大设置开始。</p><p id="c30d" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi lg translated">我已经创建了一些CSV文件来了解在任何给定时间有多少虚拟线程或协程在执行。这是不准确的，原因是因为他们假设这两种过程连续运行，并且每次连续运行时从不切换上下文。然而，我们现在知道这并不总是正确的。不管怎样，值得努力去研究它们。如果我们看看我们在这两个项目中运行的最繁重的流程之一。例如，让我们检查方法/函数发生了什么:<code class="fe nf ng nh ni b"><strong class="kk iu"><em class="nc">repetitionCount</em></strong></code>。这个方法检查有多少单词重复了不止一次。这意味着如果我们发现两个单词“狗”,那么这就是1次重复。每发现一只“狗”,我们就在计数上加一。如果我们查看Java的计数生成，我们会发现在任何给定时间活动虚拟线程的数量是<strong class="kk iu"> 12 </strong>:</p><figure class="mu mv mw mx gt ju gh gi paragraph-image"><div class="gh gi pj"><img src="../Images/0d438479d8d5a650d87b0354da978a2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:828/format:webp/1*cTj6DyU5xVW65XWQQBnkkQ.png"/></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated"><strong class="bd ls">Java虚拟线程的重复计数</strong></figcaption></figure><p id="f9e0" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi lg translated">或者科特林我们发现了一些东西。我们看到，在任何给定的时间，活动协同程序的数量上升到<strong class="kk iu"> 63 </strong>:</p><figure class="mu mv mw mx gt ju gh gi paragraph-image"><div class="gh gi pk"><img src="../Images/07f767eae2ad440df574f61020421095.png" data-original-src="https://miro.medium.com/v2/resize:fit:820/format:webp/1*JMcMi6kfhjGJmJZl4WWN_g.png"/></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated"><strong class="bd ls">科特林协程的重复计数</strong></figcaption></figure><p id="43dd" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi lg translated">这是如何发生的？嗯，对于<strong class="kk iu"> Java虚拟线程</strong>，在一个给定的时间只有<strong class="kk iu"> 12是活动的</strong>是完全合理的。对于科特林协同程序来说，这很奇怪。在这种情况下，我真的不清楚发生了什么，但我猜测这个<strong class="kk iu"> 63号</strong>只是一个误导性的结果，因为如果协程在运行过程中改变上下文，或者如果出于某种原因它得到了<strong class="kk iu">挂起</strong>，那么，当然，开始和结束<strong class="kk iu">时间戳</strong>将包含比通常更长的<strong class="kk iu">增量</strong>，并且该结果将不适用于最初的假设，即<strong class="kk iu">异步</strong>处理我们应该告诉已经得到<strong class="kk iu"> 12 </strong>或更少，因为这是我的机器有多少核心。不是<strong class="kk iu"> 63 </strong>！此时此刻我只能祈祷。</p><p id="f3cb" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi lg translated"><span class="l lh li lj bm lk ll lm ln lo di"> F </span>最后，让我们来看看一般的结果，我们可以比较每一个实现的算法的<strong class="kk iu"> 10000 </strong>次重复的不同运行:</p><figure class="mu mv mw mx gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi pl"><img src="../Images/b22140063893387c46883401b5ee01db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xRzYAiCEvMgodBBD7qhZ4g.png"/></div></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated"><strong class="bd ls">某一时间点的结果帧</strong></figcaption></figure><p id="5f5c" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi lg translated">查看表格我们会发现，在几乎所有的情况下，在<strong class="kk iu">方法/函数</strong>中投入一万个<strong class="kk iu">虚拟线程</strong>或<strong class="kk iu">协程</strong>的时间并没有太大的不同。事实上，拉近镜头几乎让我们认为<strong class="kk iu"> project Loom </strong>在性能方面似乎更好。反正还不足以下结论。此时，我已经用尽了我的本地机器的极限，它在这些测试中已经足够工作了。在我的整个测试中，有迹象表明<strong class="kk iu"> Project Loom的虚拟线程</strong>似乎确实比<strong class="kk iu">协程</strong>执行得更好，但是，正如我之前提到的，这并不是一个明确的结论。这只是一种关联，一种想法。我仍然不能肯定地证明一个比另一个更好。我能够证明的是，在我目前的当地环境中，没有任何事情，绝对没有任何事情让我怀疑这些解决同样问题的方法。这两者在同一水平上看起来都不错，这一点表明Java虚拟线程做得更好仍然只是一个迹象。这只是一个指示的另一个原因是，我已经能够在其他场合运行这些相同的测试，所有的<strong class="kk iu">协程实现</strong>都比<strong class="kk iu"> Java虚拟线程</strong>做得更好。只是频率似乎更有利于<strong class="kk iu"> Java虚拟线程</strong>，但这不是得出任何结论的材料。也许，不能得出任何结论本身就是一个结论，但我让你决定。</p><h1 id="89a7" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">结论</h1><p id="6f5b" class="pw-post-body-paragraph ki kj it kk b kl mo kn ko kp mp kr ks kt mq kv kw kx mr kz la lb ms ld le lf im bi lg translated">当我比较<strong class="kk iu">延续</strong>这一相同思想的两种实现时，我实际上并没有看到任何重大的不同。我发现Kotlin协同程序和Java虚拟线程都是伟大的技术。当用<strong class="kk iu">协程</strong>耗尽系统，并迫使各种算法开始行动来<strong class="kk iu">优化</strong>时，我没有看到任何性能上的重大差异。</p><p id="a7c5" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi lg translated">事情是这样的。<strong class="kk iu">科特林</strong>会留在这里<strong class="kk iu">爪哇</strong>也会留在这里。我写这篇文章的目的是引导双方进行讨论，以更好地了解两种语言都有什么。<strong class="kk iu"> Kotlin </strong>是<strong class="kk iu"> 2010 </strong>的<strong class="kk iu">发明</strong>而<strong class="kk iu"> Java </strong>自<strong class="kk iu"> 1995 </strong>就存在。同理，<strong class="kk iu"> Scala </strong>被创建，<strong class="kk iu"> Kotlin </strong>也被创建来“<strong class="kk iu"> <em class="nc">提供</em> </strong>之前没有的特性”。嗯，这对我来说是一颗难以下咽的药丸。你知道为什么吗？因为在Kotlin 中可用的一切，以及我们在kot Lin<strong class="kk iu">中所说的<strong class="kk iu">需要的</strong>，我总是发现在Java<strong class="kk iu">中也可以得到！只是风格不同而已。这从我们现在所说的<strong class="kk iu">惯用Kotlin </strong>到我们现在所说的<strong class="kk iu">惯用Java </strong>。</strong></strong></p><p id="542b" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi lg translated">从2014年<strong class="kk iu">到2014年</strong>Java 8我们已经开始担心缺乏更好的解决方案。<strong class="kk iu"> Lambdas </strong>做与<strong class="kk iu">完全相同的事情，而</strong>和<strong class="kk iu">做{} while，</strong>以同样的方式，<strong class="kk iu">接收器</strong>在<strong class="kk iu"> Kotlin </strong>中做。他们让一切都慢得要命！只有在为<strong class="kk iu">高可用性</strong>应用程序实现算法时，或者在<strong class="kk iu">黑客</strong>网站上做关于<strong class="kk iu">大O符号的练习时，你才会意识到这一点。</strong>这可能有点夸张，但嘿，我也喜欢这两者带来的<strong class="kk iu">优雅</strong>，所以<strong class="kk iu">我也大量使用它们</strong>，说实话，但我的观点是它们不是一切。当我们投资于<strong class="kk iu">序列、</strong> <strong class="kk iu"> lambdas、接收器和map-reduce操作时，</strong>我们在某种程度上惩罚了性能。有关系吗？它只在重要的时候才重要，所以我最好的建议是成为这方面的专家。我们都真心喜欢<strong class="kk iu"> Lambdas </strong>和<strong class="kk iu">receiver</strong>，但是不要让它们成为你日常编码生活中的一个愤怒点，因为有时候，老一套的<strong class="kk iu">可以带来真正的不同。</strong></p><p id="927e" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi lg translated"><span class="l lh li lj bm lk ll lm ln lo di">如果</span>我们谈论，例如，Java中的<strong class="kk iu">扩展函数</strong>比<strong class="kk iu">静态方法</strong>更好，那也不是一个很好的观点。当我看到这些讨论或者当我把<strong class="kk iu">拖进</strong>时，我通常观察到的是一方对其选择的语言极其热衷，但在我看来，真正发生的只是人们捍卫他们的个人偏好。对我来说，我更倾向于客观，我看不到任何客观的关于这些语言的东西。他们只是不同而已。太棒了！</p><p id="2aef" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi lg translated">从很多方面来说，J  <strong class="kk iu"> ava </strong>都是<strong class="kk iu"> Scala </strong>和<strong class="kk iu"> Kotlin </strong>的父代。我认为想要或希望科特林接管Java有点愚蠢。我个人认为所有的语言都应该存在，我们应该向所有的语言学习，因为它们不同但最终做得一样的原则正是让我们保持活跃并让我们理解关于代码的不同观点的相同原则。我不希望<strong class="kk iu"> Java、Kotlin、</strong>或者<strong class="kk iu"> Scala </strong>消失。我希望所有这些语言和其他语言也能进化。我想向他们所有人学习。嘿，还记得我在一台<strong class="kk iu"> ZX-Spectrum 48K机器上用橡胶键</strong>开始用磁带编程吗？那是在我80年代末。这可能与当今世界无关，但有了这一参考，我就能更好地理解我们所处的位置，我们过去和现在面临的问题，以及我们将来可能会发现的问题。更多的语言给世界带来的丰富多彩经常被忽视。</p></div><div class="ab cl kb kc hx kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="im in io ip iq"><p id="7625" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi lg translated"><span class="l lh li lj bm lk ll lm ln lo di">我</span>可以一直写下去，但是我真正想对这篇文章说的是简单明了的。Kotlin 是一个新玩家，而<strong class="kk iu">协程</strong>实现<strong class="kk iu">也是。我们都爱他们。但是无论如何，我看不到这些技术相对于Java虚拟线程的工程附加值。我认为<strong class="kk iu"> Kotlin </strong>与众不同，这给<strong class="kk iu"> JVM </strong>增添了新的味道。然而，我所知道的每一个关于科特林的评论家，事实证明我也能看到同样的事情发生在Java和T21身上。同样，对于每一个关于Kotlin的赞美，我都能在Java中找到完全相同的。只是好像风格不太一样。当然，许多东西没有集成到<strong class="kk iu"> Java SDK、</strong>中，但是<strong class="kk iu"> Kotlin </strong>仍然只是在<strong class="kk iu"> JVM </strong> <strong class="kk iu">之上的<strong class="kk iu"> DSL </strong>。这意味着如果我在<strong class="kk iu"> Java </strong>中使用类似<strong class="kk iu"> Lombok </strong>的东西，我可能会拥有同样的权利？只是另一个<strong class="kk iu"> DSL </strong>，就像<strong class="kk iu">科特林</strong>一样。嗯，很多读到这里的人会竭力反对说<strong class="kk iu"> Lombok </strong>是“一个糟糕的想法”，然后我会说“但是我们现在已经在<strong class="kk iu"> Java </strong>中有了<code class="fe nf ng nh ni b"><strong class="kk iu">record’s</strong></code>”然后你会说“是的，但是<strong class="kk iu">数据类</strong>一起做所有这些，你可以让一切<strong class="kk iu">不可变</strong>，它看起来好多了！”。这太棒了，我同意最后一句话。科特林</strong>确实更好看。是吗？也许我更喜欢使用注释，也许我更喜欢使用<code class="fe nf ng nh ni b">@Builder</code>而不是<code class="fe nf ng nh ni b">data class</code>，也许我想被提醒，在单个<strong class="kk iu">数据</strong>关键字后面，我得到一个<strong class="kk iu">散列实现</strong>，一个<strong class="kk iu">等于</strong>，<strong class="kk iu">getter</strong>和<strong class="kk iu">setter，</strong>，如果我在我的所有属性上使用<code class="fe nf ng nh ni b"><strong class="kk iu"><em class="nc">val</em></strong></code> <strong class="kk iu"> it </strong>，那么我得到一个<strong class="kk iu">不可变的</strong>这就是我认为<strong class="kk iu"> Kotlin </strong>是天才语言的地方。我仍然不清楚它给代码增加了什么工程上的好处，然而，通过依靠我们的直觉和当前的趋势，它找到了一个黄金机会来填补许多开发人员和工程师目前面临的一个可感知的差距。<strong class="kk iu">样板、重复代码、困难代码、工程费用等</strong>等。此外，在确保结构化并发性方面，它提供了一种令人惊叹的编程风格。当然还有我们想做一些刺激和新奇的事情的愿望。新的语法和新的语义创造了一个全新的游戏场，这是一件积极的事情。</strong></p></div><div class="ab cl kb kc hx kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="im in io ip iq"><p id="9700" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi lg translated">在我看来，从严格的工程意义上来说，<strong class="kk iu"> Kotlin </strong>和<strong class="kk iu"> Java </strong>都比对方好。你当然可能不同意。我认为如果你来自一个Android背景的人，那么你会比我有更多的话要说。我非常清楚<strong class="kk iu"> Kotlin </strong>已经被<strong class="kk iu"> Android </strong>开发者广泛接受。我觉得不错。我的观点(或缺乏观点)来自于<strong class="kk iu">仅服务实现</strong>的角度。Android 确实有更多的功能，所以我不得不放弃对它的评论。就目前而言，是这样。</p><p id="36f4" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">如果你必须选择一项新技术，我的建议是，选择你最喜欢的。我很怀疑你能从语言本身中找到任何性能上的好处。也要和你的团队保持一致。如果他们对科特林有热情，那就去吧。如果他们对Java有热情，那就去做吧。在激情中，你会发现最大的生产力。如果你想追求一些高效的东西，而<strong class="kk iu">是你唯一关心的</strong>，那么<strong class="kk iu">在这个</strong>上有一个非常广泛的共识，你可能想要<strong class="kk iu">远离任何一开始就与JVM相关的东西</strong>。在<strong class="kk iu"> JVM </strong>中启动和运行可能很困难，这就是为什么许多人转向<strong class="kk iu">本地</strong>解决方案的原因。我还想指出的是，协程有时会在多线程和提供更多线程的<strong class="kk iu">上下文中讨论。那只是<strong class="kk iu">而不是</strong>的情况。围绕<strong class="kk iu">协程</strong>的范例本质上与<strong class="kk iu">反应式编程</strong>更相关，而不是其他任何东西。我这样说的原因是因为协程更有效地利用了<strong class="kk iu">系统/平台线程</strong>。然而，这听起来可能与<strong class="kk iu">多线程</strong>有关，但事实并非如此。这只是一种避免线程无缘无故暂停的方法，如果你愿意的话，就像过去那样。无论你决定使用<strong class="kk iu"> Kotlin协程</strong>还是即将到来的<strong class="kk iu">虚拟线程，这完全取决于你。</strong></strong></p></div><div class="ab cl kb kc hx kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="im in io ip iq"><p id="1d81" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi lg translated">认为<strong class="kk iu"> Java </strong>必须抵御<strong class="kk iu"> Kotlin </strong>或<strong class="kk iu"> Kotlin </strong>可能代表着对<strong class="kk iu"> Java </strong>的威胁的想法是我写这篇文章的最初动机，这是因为，就像<strong class="kk iu"> Lucy </strong>的故事有一天会展现出来一样，有时我们只是互相讲述非常好的故事，但它们最终毫无意义。当我醒来的时候，我个人会继续用我喜欢的任何语言编程。在工作中，我坚持按计划行事。在我的<strong class="kk iu">空闲时间，尽管</strong>，我只是选择<strong class="kk iu">我当时想做的任何事情</strong>，这包括<strong class="kk iu"> Java、Kotlin、Scala、Go、Rust、Python、Ruby、PHP、Javascript等等。</strong></p><p id="a844" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">正如我在引言中提到的，鉴于这篇文章的实验性质，它将会受到更频繁的评论。</p><p id="aabf" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">我已经将这个应用程序的所有源代码放在了GitLab 中</p><p id="f1c6" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">我希望你能像我喜欢写这篇文章一样喜欢它。</p><p id="bfd3" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">我很想听听你的想法，所以请在下面留下你的评论。</p><p id="110e" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">感谢您的阅读！</p><h1 id="ebda" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">参考</h1><div class="pm pn gp gr po pp"><a href="https://blogs.oracle.com/javamagazine/post/going-inside-javas-project-loom-and-virtual-threads" rel="noopener  ugc nofollow" target="_blank"><div class="pq ab fo"><div class="pr ab ps cl cj pt"><h2 class="bd iu gy z fp pu fr fs pv fu fw is bi translated">走进Java的项目织机和虚拟线程</h2><div class="pw l"><h3 class="bd b gy z fp pu fr fs pv fu fw dk translated">下载本文的PDF让我们谈谈Project Loom，它正在探索新的Java语言特性、API和…</h3></div><div class="px l"><p class="bd b dl z fp pu fr fs pv fu fw dk translated">blogs.oracle.com</p></div></div><div class="py l"><div class="pz l qa qb qc py qd jz pp"/></div></div></a></div><div class="pm pn gp gr po pp"><a href="https://wiki.openjdk.java.net/display/loom/Main" rel="noopener  ugc nofollow" target="_blank"><div class="pq ab fo"><div class="pr ab ps cl cj pt"><h2 class="bd iu gy z fp pu fr fs pv fu fw is bi translated">主要的</h2><div class="pw l"><h3 class="bd b gy z fp pu fr fs pv fu fw dk translated">x86-64上的Mac和Linux此时最有价值的贡献方式是尝试当前的原型和…</h3></div><div class="px l"><p class="bd b dl z fp pu fr fs pv fu fw dk translated">wiki.openjdk.java.net</p></div></div></div></a></div><div class="pm pn gp gr po pp"><a href="https://cr.openjdk.java.net/~rpressler/loom/Loom-Proposal.html" rel="noopener  ugc nofollow" target="_blank"><div class="pq ab fo"><div class="pr ab ps cl cj pt"><h2 class="bd iu gy z fp pu fr fs pv fu fw is bi translated">织机提案. md</h2><div class="pw l"><h3 class="bd b gy z fp pu fr fs pv fu fw dk translated">Project Loom的任务是使并发应用程序的编写、调试、分析和维护变得更加容易</h3></div><div class="px l"><p class="bd b dl z fp pu fr fs pv fu fw dk translated">cr.openjdk.java.net</p></div></div></div></a></div><div class="pm pn gp gr po pp"><a href="https://kotlinlang.org/docs/coroutines-overview.html" rel="noopener  ugc nofollow" target="_blank"><div class="pq ab fo"><div class="pr ab ps cl cj pt"><h2 class="bd iu gy z fp pu fr fs pv fu fw is bi translated">协同程序|科特林</h2><div class="pw l"><h3 class="bd b gy z fp pu fr fs pv fu fw dk translated">异步或非阻塞编程是开发领域的一个重要部分。创建服务器端时…</h3></div><div class="px l"><p class="bd b dl z fp pu fr fs pv fu fw dk translated">kotlinlang.org</p></div></div><div class="py l"><div class="qe l qa qb qc py qd jz pp"/></div></div></a></div><div class="pm pn gp gr po pp"><a href="https://paluch.biz/blog/183-carrier-kernel-thread-pinning-of-virtual-threads-project-loom.html" rel="noopener  ugc nofollow" target="_blank"><div class="pq ab fo"><div class="pr ab ps cl cj pt"><h2 class="bd iu gy z fp pu fr fs pv fu fw is bi translated">虚拟线程的载体内核线程锁定(Project Loom)</h2><div class="pw l"><h3 class="bd b gy z fp pu fr fs pv fu fw dk translated">在我之前的博文中，我开始了一个使用Project Loom的实验。这篇文章概述了利用…</h3></div><div class="px l"><p class="bd b dl z fp pu fr fs pv fu fw dk translated">paluch.biz</p></div></div><div class="py l"><div class="qf l qa qb qc py qd jz pp"/></div></div></a></div><div class="pm pn gp gr po pp"><a href="https://blog.devgenius.io/java-virtual-threads-715c162c6c39" rel="noopener  ugc nofollow" target="_blank"><div class="pq ab fo"><div class="pr ab ps cl cj pt"><h2 class="bd iu gy z fp pu fr fs pv fu fw is bi translated">Java虚拟线程</h2><div class="pw l"><h3 class="bd b gy z fp pu fr fs pv fu fw dk translated">我们将不再编写丑陋的异步代码。也许吧。</h3></div><div class="px l"><p class="bd b dl z fp pu fr fs pv fu fw dk translated">blog.devgenius.io</p></div></div><div class="py l"><div class="qg l qa qb qc py qd jz pp"/></div></div></a></div></div></div>    
</body>
</html>