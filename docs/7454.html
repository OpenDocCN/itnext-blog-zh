<html>
<head>
<title>What Makes LISP Unique?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">LISP的独特之处是什么？</h1>
<blockquote>原文：<a href="https://itnext.io/what-makes-lisp-unique-8a0576b42293?source=collection_archive---------1-----------------------#2022-09-28">https://itnext.io/what-makes-lisp-unique-8a0576b42293?source=collection_archive---------1-----------------------#2022-09-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="eb7a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">探索LISP的同象性特征，以及它如何使LISP更像是一种语言</h2></div><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="ab gu cl kn"><img src="../Images/5747caec8c28acafa4da73190d45c460.png" data-original-src="https://miro.medium.com/v2/format:webp/1*_XEK5hMqdyjVw0GzQu-KUw.png"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">医学博士康拉德·巴斯基设计的外星人口齿不清吉祥物</figcaption></figure><p id="a0fc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi lq translated"><span class="l lr ls lt bm lu lv lw lx ly di"> T </span> he LISP编程语言及其衍生出来的Scheme、Clojure等，有一个特性让我很着迷，叫做同象性。</p><p id="6139" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这意味着在LISP中代码被表示为数据，因此可以像数据一样被操作和修改。要真正体会这样一个简单语句的深刻含义，需要阅读一本书并编写自己的LISP代码。你可能没有时间做这些，所以让我通过这篇短文给你一点提示或直觉。</p><p id="4b74" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">理解LISP总是从理解LISP构建的核心数据结构——链表开始。理解一种语言依赖于理解一种数据结构，这似乎有点奇怪，但是请耐心听我说。</p><p id="15b3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面的LISP代码定义了一个包含一个整数、一个字符串、一个布尔值、一个浮点数和一个字符的链表。注意LISP表达式是如何以括号开始和结束的。LISP因大量的括号而臭名昭著。</p><pre class="ki kj kk kl gt lz ma mb mc aw md bi"><span id="d799" class="me mf it ma b gy mg mh l mi mj">(list 43 "hello" true 2.5 'c')</span></pre><p id="4a82" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">请注意，为了使LISP代码示例更容易阅读，我冒昧地对布尔值和字符使用了类似C的语法。标准LISP将使用不同的语法。</p><p id="0fe5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">链表由节点组成，其中每个节点可以指向另一个节点。它还有一个储存数据的单元格。但这也可以是指向另一个列表的指针。因此，我们可以有列表的列表，这些列表也可以是列表的列表。</p><pre class="ki kj kk kl gt lz ma mb mc aw md bi"><span id="68c0" class="me mf it ma b gy mg mh l mi mj">(list 34 (list "hello" true) (list 2.5 'c'))</span></pre><p id="426a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，可以用这种方式表达复杂的数据结构和树结构。如果你对编译器的工作原理有所了解，你就会知道当它解析代码时，会产生一个抽象的语法树。在主流编程语言中，你可能会有一个表达式，比如<code class="fe mk ml mm ma b">y = 4*(2 + x)</code>。它可以用下面的语法树来表示。</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="ab gu cl kn"><img src="../Images/c77e13e07b9782f547ef6c440570a289.png" data-original-src="https://miro.medium.com/v2/format:webp/1*fsdcfOyVNUcJFqAeP5N-jw.png"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">表达式y = 4*(2 + x)的抽象语法树(AST)</figcaption></figure><p id="3b2e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">写LISP代码的时候，基本上就是直接创建这个抽象语法树。原则上，您可以像任何其他数据结构一样重新排列和转换这样的代码树。</p><p id="9595" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们举一个例子来说明LISP代码表示方法的普遍性。考虑一个用c语言编写的<em class="mn"> Hello World </em>程序。抽象语法树(AST)，即代表这个程序的数据结构，并不是显而易见的。</p><pre class="ki kj kk kl gt lz ma mb mc aw md bi"><span id="db68" class="me mf it ma b gy mg mh l mi mj">#include &lt;stdio.h&gt;<br/><br/>int main () {<br/>    printf("hello, world\n");<br/>    return 0;<br/>}</span></pre><p id="2e6c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，也有LISP风格的C语言版本，可以让你用LISP语法编写这个<em class="mn"> Hello World </em>程序(我们称之为s表达式)。请注意代码的语法结构变得更加清晰。</p><pre class="ki kj kk kl gt lz ma mb mc aw md bi"><span id="4491" class="me mf it ma b gy mg mh l mi mj">(import cstdio)<br/><br/>(def main (fn extern-c int (void)<br/>  (printf "hello, world\n")))</span></pre><p id="b275" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们看另一个C代码片段来帮助澄清。下面的代码定义了一个名为<code class="fe mk ml mm ma b">Point</code>的新复合类型，它有两个整数字段<code class="fe mk ml mm ma b">x</code>和<code class="fe mk ml mm ma b">y</code>。</p><pre class="ki kj kk kl gt lz ma mb mc aw md bi"><span id="112b" class="me mf it ma b gy mg mh l mi mj">struct Point {<br/>    int x;<br/>    int y;<br/>};</span></pre><p id="cb82" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以使用s表达式来表达相同的类型定义，如下所示。</p><pre class="ki kj kk kl gt lz ma mb mc aw md bi"><span id="d180" class="me mf it ma b gy mg mh l mi mj">(def Point (struct intern (<br/>    (x int) <br/>    (y int)<br/>)))</span></pre><p id="decc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我要带着这个去哪里？为什么要用这种看似丑陋和笨拙的语法编写代码呢？使用s表达式的好处是代码变得有规律。例如，在这个类型定义中，可以清楚地看到代码被定义为一个列表，其中前两个元素是<code class="fe mk ml mm ma b">def</code>和<code class="fe mk ml mm ma b">Point</code>。第三个元素是以元素<code class="fe mk ml mm ma b">struct</code>和<code class="fe mk ml mm ma b">intern</code>开始的另一个列表。内部列表有第三个元素，这是一个包含所有复合类型字段的列表。</p><p id="5873" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">好吧，那又怎样？这个新语法给了我什么？让我给你举个例子:如果代码放在一个文件中，其他LISP代码可以将代码作为数据加载并转换它。代码可以像任何其他链表一样迭代<code class="fe mk ml mm ma b">Point</code>定义代码。可以替换、插入或移动元素。</p><p id="3341" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里有一个问题:在LISP中，你不需要把代码放在一个单独的文件中来实现这一点。使用引号，代码可以作为数据直接放在其他LISP代码中。请允许我用一个简单的代码示例来说明。数学表达式<code class="fe mk ml mm ma b">4 + x</code>用LISP写成:</p><pre class="ki kj kk kl gt lz ma mb mc aw md bi"><span id="18e2" class="me mf it ma b gy mg mh l mi mj">(+ 4 x)</span></pre><p id="310f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在LISP中，如果我想定义一个值为10的变量<code class="fe mk ml mm ma b">y</code>，我写:</p><pre class="ki kj kk kl gt lz ma mb mc aw md bi"><span id="d68f" class="me mf it ma b gy mg mh l mi mj">(defvar y 10)</span></pre><p id="6260" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">稍后，我可以使用<code class="fe mk ml mm ma b">setf</code>命令修改<code class="fe mk ml mm ma b">y</code>变量:</p><pre class="ki kj kk kl gt lz ma mb mc aw md bi"><span id="d512" class="me mf it ma b gy mg mh l mi mj">(setf y 5)</span></pre><p id="8df1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">列表中的第三个元素不必是数字。我们可以在里面放任何东西，甚至是一列代码。但是我们如何避免代码被评估呢？下面的代码将首先计算<code class="fe mk ml mm ma b">3 + 4</code>并将结果值7存储在<code class="fe mk ml mm ma b">y</code>变量中。</p><pre class="ki kj kk kl gt lz ma mb mc aw md bi"><span id="334a" class="me mf it ma b gy mg mh l mi mj">(setf y (+ 3 4))</span></pre><p id="67b8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">解决方法是引用列表。引用将表达式转换为常规列表数据。我们现在将代码<code class="fe mk ml mm ma b">(+ 3 4)</code>存储在<code class="fe mk ml mm ma b">y</code>变量中，而不是将值7存储在<code class="fe mk ml mm ma b">y</code>变量中。</p><pre class="ki kj kk kl gt lz ma mb mc aw md bi"><span id="b4c9" class="me mf it ma b gy mg mh l mi mj">(setf y '(+ 3 4))</span></pre><p id="e595" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">使用一个LISP交互式REPL环境(读取-评估-打印-循环)，如<a class="ae mo" href="https://www.sbcl.org" rel="noopener ugc nofollow" target="_blank">SBCL</a>(Steel Bank Common LISP)，我们可以检查并评估这个变量:</p><pre class="ki kj kk kl gt lz ma mb mc aw md bi"><span id="e798" class="me mf it ma b gy mg mh l mi mj">sbcl&gt; (setf y '(+ 3 4))<br/>(+ 3 4)<br/><br/>sbcl&gt; y<br/>=&gt; (+ 3 4)<br/><br/>sbcl&gt; (eval y)<br/>=&gt; 7</span></pre><p id="22e0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以使用<code class="fe mk ml mm ma b">cons</code>函数分多个步骤拼凑这样一个列表。函数的作用是:在列表的开头添加一个节点。在下面的代码中，我们将值3添加到列表<code class="fe mk ml mm ma b">(5 8)</code>中。</p><pre class="ki kj kk kl gt lz ma mb mc aw md bi"><span id="bac9" class="me mf it ma b gy mg mh l mi mj">sbcl&gt; (cons 3 '(5 8))<br/>=&gt; (3 5 8)</span></pre><p id="64d5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您可以使用这种方法来组合列表中的代码片段。例如，在下面的REPL会话中，我们使用<code class="fe mk ml mm ma b">first</code>函数从存储在变量<code class="fe mk ml mm ma b">y</code>中的代码中挑选出第一个元素。第一个元素是<code class="fe mk ml mm ma b">+</code>操作符。接下来，我们使用<code class="fe mk ml mm ma b">cons</code>函数将该操作符添加到数字4和5的列表中。</p><pre class="ki kj kk kl gt lz ma mb mc aw md bi"><span id="5953" class="me mf it ma b gy mg mh l mi mj">sbcl&gt; (cons (first y) '(4 5))<br/>=&gt; (+ 4 5)</span></pre><p id="f440" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如您所见，这些操作产生的表达式<code class="fe mk ml mm ma b">4 + 5</code>在LISP中写成<code class="fe mk ml mm ma b">(+ 4 5)</code>。接下来，我们可以使用<code class="fe mk ml mm ma b">eval</code>函数计算刚刚创建的表达式，并产生值9。</p><pre class="ki kj kk kl gt lz ma mb mc aw md bi"><span id="3717" class="me mf it ma b gy mg mh l mi mj">sbcl&gt; (eval (cons (first y) '(4 5)))<br/>=&gt; 9</span></pre><p id="e028" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">LISP同象性比我在这个故事中展示的要多得多。我们只是触及了表面。但重点是向您展示，通过将任何代码放入s表达式中，您可以轻松地转换和操作这些代码。</p><p id="3aac" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这种方法允许您将前面展示的LISP风格的C代码放在常规的LISP代码中，并对该代码执行转换。然后，生成的代码可以输入到一个程序中，如<a class="ae mo" href="https://github.com/kiselgra/c-mera" rel="noopener ugc nofollow" target="_blank"> C-Mera </a>，该程序会将LISP风格的C代码转换成可以编译的普通C代码。下面是一个使用s表达式实现Unix <a class="ae mo" href="https://en.wikipedia.org/wiki/Wc_(Unix)" rel="noopener ugc nofollow" target="_blank"> wc </a> shell命令的实际例子。</p><pre class="ki kj kk kl gt lz ma mb mc aw md bi"><span id="2a9e" class="me mf it ma b gy mg mh l mi mj">(include &lt;stdio.h&gt;)<br/><br/>(function main () -&gt; int<br/>  (decl ((int c)<br/>         (int nl = 0))<br/>    (while (!= (set c (getchar)) EOF)<br/>      (if (== c #\newline)<br/>          ++nl))<br/>    (printf "%d\\n" nl)<br/>    (return 0)))</span></pre><p id="7123" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae mo" href="https://github.com/kiselgra/c-mera" rel="noopener ugc nofollow" target="_blank"> C-Mera </a>程序会将其转换成C代码。我们使用<code class="fe mk ml mm ma b">cm</code>命令将文件<code class="fe mk ml mm ma b">wc-l.lisp</code>中的s表达式源代码转换成C代码。</p><pre class="ki kj kk kl gt lz ma mb mc aw md bi"><span id="79e1" class="me mf it ma b gy mg mh l mi mj">$ ls<br/>wc-l.lisp<br/>$ cm c wc-l.lisp<br/>#include &lt;stdio.h&gt;<br/><br/>int main(void)<br/>{<br/>        int c;<br/>        int nl = 0;<br/>        while ((c = getchar()) != EOF) {<br/>                if (c == '\n') <br/>                        ++nl;<br/>        }<br/>        printf("%d\n", nl);<br/>}</span></pre><p id="17ff" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有人可能想知道走这条弯路有什么好处。其中一个优点是可以利用LISP的能力来修改和生成代码，以减少样板代码。</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="ab gu cl kn"><img src="../Images/24eaee4c57c40a10ebdf68a58d435897.png" data-original-src="https://miro.medium.com/v2/format:webp/1*sQ28_UR0FHsveo78hABuBQ.jpeg"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">针对PS2的Jak和Daxter系列中的Jak 3是使用LISP语言GOAL制作的。</figcaption></figure><p id="eec6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这种能力是LISP不仅仅被认为是一种语言的原因之一，它更像是一个创建自己语言的完整系统。一个现实世界的例子是视频游戏制作公司<a class="ae mo" href="https://en.wikipedia.org/wiki/Naughty_Dog" rel="noopener ugc nofollow" target="_blank">顽皮狗</a>用来为Playstation制作游戏的<a class="ae mo" href="https://en.wikipedia.org/wiki/Game_Oriented_Assembly_Lisp" rel="noopener ugc nofollow" target="_blank"> GOAL(面向游戏的汇编LISP) </a>语言。例如，PlayStation 2 <a class="ae mo" href="https://en.wikipedia.org/wiki/Jak_and_Daxter" rel="noopener ugc nofollow" target="_blank"> Jak和Daxter </a>游戏就是用GOAL制作的。游戏的LISP代码被转换成Playstation汇编代码，而不是输出C代码。这种方法的美妙之处在于，他们可以使用现有的商业LISP环境创建整个汇编程序，比如<a class="ae mo" href="https://en.wikipedia.org/wiki/Allegro_Common_Lisp" rel="noopener ugc nofollow" target="_blank"> Allegro Common Lisp </a>。在LISP开发环境中，操作目标代码变得很容易。它已经有了LISP设计的s表达式。所有为Allegro设计的工具和编辑器都可以很容易地与GOAL一起使用，因为它们都使用相同的s表达式。</p><p id="9acc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为s表达式设计的编辑器可以变得非常强大。普通的编辑器是用来处理行和列的，但是当处理s表达式时，你可以考虑一个父、子和兄弟的树形结构。热键用于在兄弟姐妹之间跳转，跳转到父级，或者选择或删除子级或兄弟姐妹。</p><h1 id="19a7" class="mp mf it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">LISP在现实世界中的使用</h1><p id="acf7" class="pw-post-body-paragraph ku kv it kw b kx ng ju kz la nh jx lc ld ni lf lg lh nj lj lk ll nk ln lo lp im bi translated">LISP的强大之处很大一部分在于它有些陌生的语法。实现一个LISP解析器和一个LISP语言是非常容易的，这就是为什么你会发现很多早期的软件都是用LISP作为脚本语言。你可能已经知道EMACS编辑器使用LISP作为脚本语言是出了名的。Autodesk的计算机辅助设计(CAD)工具AutoCAD 以使用LISP作为脚本语言而闻名。</p><p id="bd28" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">LISP作为解析其他语言的语言也非常有用。对于编程语言设计人员来说，一个聪明的策略是首先将语言语法转换成LISP语法，然后让LISP语言接管剩下的解析和代码生成工作。一种叫做<a class="ae mo" href="https://julialang.org" rel="noopener ugc nofollow" target="_blank"> Julia </a>的现代高性能JIT编译动态语言使用了这种策略。在引擎盖下，一个名为<a class="ae mo" href="https://github.com/JeffBezanson/femtolisp" rel="noopener ugc nofollow" target="_blank"> Femtolisp </a>的最小LISP实现用于处理Julia代码。</p><p id="3e48" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Julia潜在的LISP传统在许多方面都是可见的。Julia有一个<code class="fe mk ml mm ma b">Meta.show_sexpr</code>函数，可以让你看到一个Julia表达式被转换成什么s表达式。甚至有一个叫做<a class="ae mo" href="https://juliapackages.com/p/lispsyntax" rel="noopener ugc nofollow" target="_blank"> LispSyntax </a>的Julia包，它允许你在Julia交互式REPL环境中用LISP语法编写Julia代码。它添加了一个名为<code class="fe mk ml mm ma b">jλ</code>的新REPL模式，该模式接受LISP语法。下面是一个在REPL会话中使用LISP语法在Julia中实现斐波那契函数的例子。</p><pre class="ki kj kk kl gt lz ma mb mc aw md bi"><span id="aaec" class="me mf it ma b gy mg mh l mi mj">jλ&gt; (defn fib [a] <br/>      (if (&lt; a 2) <br/>        a <br/>        (+ (fib (- a 1)) (fib (- a 2)))))<br/><br/>jλ&gt; (fib 10)<br/>55</span></pre><p id="cc9f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我想以说LISP可能不是一种你最终会专业使用的语言来结束我的演讲，但是它有点像是一种每一个对计算机科学认真的人都应该在他们的一生中学习一次的语言。LISP就像基础知识。不了解LISP，你不可能真正了解我们的领域。</p><h1 id="4b1d" class="mp mf it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">资源</h1><p id="e468" class="pw-post-body-paragraph ku kv it kw b kx ng ju kz la nh jx lc ld ni lf lg lh nj lj lk ll nk ln lo lp im bi translated">如果您对探索LISP和类似LISP的语言(如Scheme)更感兴趣，我已经添加了一些链接，指向这些年来我发现有用的东西。</p><ul class=""><li id="39fa" class="nl nm it kw b kx ky la lb ld nn lh no ll np lp nq nr ns nt bi translated"><a class="ae mo" href="https://www.amazon.com/Land-Lisp-Learn-Program-Game/dp/1593272812" rel="noopener ugc nofollow" target="_blank">LISP之地:学习用Lisp编程，一次一个游戏</a>——Conrad Barski的Lisp书，提供了一种有趣的学习Lisp编程的方式。说真的，我读这本书很开心。</li><li id="45ec" class="nl nm it kw b kx nu la nv ld nw lh nx ll ny lp nq nr ns nt bi translated"><a class="ae mo" href="https://mitp-content-server.mit.edu/books/content/sectbyfn/books_pres_0/6515/sicp.zip/index.html" rel="noopener ugc nofollow" target="_blank">巫师之书</a> —其实名为<em class="mn">计算机程序的结构与解释</em>是一本经典。这是那种每个认真对待编程的人一生中都应该读一次的书。这是那种让你大吃一惊的书。此外，它还介绍了LISP的一个函数变体Scheme。</li><li id="3a18" class="nl nm it kw b kx nu la nv ld nw lh nx ll ny lp nq nr ns nt bi translated"><a class="ae mo" href="https://racket-lang.org" rel="noopener ugc nofollow" target="_blank">rack</a>—如果你对函数式LISP编程很认真，那么rack是你今天能找到的最令人愉快和用户友好的Scheme语言之一。它带有一个很棒的图形IDE，叫做DrRacket，非常适合初学者。</li><li id="297b" class="nl nm it kw b kx nu la nv ld nw lh nx ll ny lp nq nr ns nt bi translated">制作Crash Bandicoot<a class="ae mo" href="https://all-things-andy-gavin.com/2011/02/02/making-crash-bandicoot-part-1/" rel="noopener ugc nofollow" target="_blank">——Andy Gavin讲述了他和顽皮狗的Jason Rubin如何使用他们自己的LISP语言GOOL和GOAL开发Crash Bandicoot、Jax和Daxter。</a></li></ul></div></div>    
</body>
</html>