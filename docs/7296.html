<html>
<head>
<title>Which isolation level to use in sharded MySQL (on Vitess)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在分片的MySQL中使用哪个隔离级别</h1>
<blockquote>原文：<a href="https://itnext.io/which-isolation-level-to-use-in-sharded-mysql-on-vitess-ff8d77486281?source=collection_archive---------0-----------------------#2022-08-13">https://itnext.io/which-isolation-level-to-use-in-sharded-mysql-on-vitess-ff8d77486281?source=collection_archive---------0-----------------------#2022-08-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="201f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦您的服务起飞并快速增长，您必须为主<em class="kl"> MySQL </em>引入一个横向扩展解决方案。最常见且久经考验的方法是分片。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi km"><img src="../Images/dd1be35d7ee9553c36b9bc01f8c0f49e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1212/format:webp/0*UvFG1nWrxwc-7j0r.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">参考文献。<a class="ae ky" href="https://nadermedhatthoughts.medium.com/understand-database-sharding-the-good-and-ugly-868aa1cbc94c" rel="noopener">https://nadermedhatthoughts . medium . com/understand-database-sharding-the-good-and-ugly-868 aa 1 CBC 94 c</a></figcaption></figure><p id="c4c2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae ky" href="https://parallel.chat/" rel="noopener ugc nofollow" target="_blank">由于我们已经观察到写流量上升趋势</a>有一段时间了，我们的工程团队开始研究实施分片的各种选项。经过一些简单的研究，Vitess对于我们构建在Rails上的系统来说看起来不错。你真幸运！Vitess是一个位于web服务器和MySQL集群之间的中间件，因此您不必自己编写分片逻辑。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gh gi kz"><img src="../Images/c1fc3898588c42d3374748d81a379a09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*nMd5AIWLJZH_OnWG.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">参考文献。<a class="ae ky" href="https://vitess.io/docs/14.0/overview/architecture/" rel="noopener ugc nofollow" target="_blank">https://vitess.io/docs/14.0/overview/architecture/</a></figcaption></figure><p id="5f7c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好了，现在是时候仔细阅读官方文档，评估将我们的独立主MySQL ( <em class="kl"> InnoDB </em>)调整为在<em class="kl"> Vitess </em>上的主MySQL集群的可行性了。在这个过程中，我发现了一个神秘的兼容性警告如下。</p><blockquote class="le lf lg"><p id="6012" class="jn jo kl jp b jq jr js jt ju jv jw jx lh jz ka kb li kd ke kf lj kh ki kj kk ij bi translated"><a class="ae ky" href="https://vitess.io/docs/13.0/reference/compatibility/mysql-compatibility/" rel="noopener ugc nofollow" target="_blank"> Vitess在执行跨分片查询时提供了READ COMMITTED语义。这与MySQL不同，MySQL默认为可重复读取。</a></p></blockquote><p id="9651" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">乍看之下，我把这种单挑当成小事丢弃了。但后来，我同事的以下问题引起了我的注意，因为它值得仔细了解:</p><blockquote class="lk"><p id="6bea" class="ll lm iq bd ln lo lp lq lr ls lt kk dk translated"><strong class="ak">到底什么是<em class="lu">读提交的</em>语义？</strong>和我们熟悉的<em class="lu">读提交</em>隔离级别或者<em class="lu">可重复读</em>隔离级别有区别吗？</p></blockquote><p id="5f92" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">对于不了解最新数据库的应用程序开发人员来说，要回答这个看似高度相关的问题，我将介绍:</p><ul class=""><li id="bf80" class="ma mb iq jp b jq jr ju jv jy mc kc md kg me kk mf mg mh mi bi translated"><strong class="jp ir">被迫使用低于<em class="kl">可重复读取</em>的保证的可能后果</strong>。您的应用程序可能会无意中依赖于此默认隔离级别。</li><li id="52bd" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk mf mg mh mi bi translated"><strong class="jp ir">观察由<em class="kl"> READ COMMITTED </em>语义引起的</strong>变化，同时比较一个分片MySQL集群和一个独立MySQL。</li><li id="5716" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk mf mg mh mi bi translated"><strong class="jp ir">在引入像Vitess这样的分片中间件之前和之后，决定使用哪个隔离级别</strong>。</li></ul><h1 id="6ad1" class="mo mp iq bd mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj nk nl bi translated">为什么隔离级别很重要？</h1><p id="9b4b" class="pw-post-body-paragraph jn jo iq jp b jq nm js jt ju nn jw jx jy no ka kb kc np ke kf kg nq ki kj kk ij bi translated">事务隔离就是缩写<a class="ae ky" href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_acid" rel="noopener ugc nofollow" target="_blank"> <em class="kl">酸</em> </a>中的<em class="kl"> I </em>。通过锁定机制，事务在进行过程中不会相互干扰。</p><p id="e4ff" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">隔离级别是为了提高性能而牺牲较少保证的设置。<em class="kl"> SQL:1992 </em>标准定义了四个隔离级别:<em class="kl">未提交读、提交读、可重复读、</em>和<em class="kl">可序列化</em>。一般来说，<em class="kl"> READ UNCOMMITTED </em>被认为保障太少，反之，<em class="kl"> SERIALIZABLE </em>被认为过于严格。这就是为什么PostgreSQL和MySQL (InnoDB)的默认隔离级别分别是<em class="kl">提交读取和</em>可重复读取。</p><p id="5966" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="kl"> READ COMMITTED </em>隔离级别保证事务看到数据库的最新提交视图</strong>。与<em class="kl"> READ UNCOMMITTED </em>隔离级别不同，您不会读取可能稍后回滚的数据。</p><p id="08c8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">假设我们有一个用户表。</p><pre class="kn ko kp kq gt nr ns nt nu aw nv bi"><span id="cd3d" class="nw mp iq ns b gy nx ny l nz oa"><strong class="ns ir">CREATE TABLE</strong> `users` (<br/>  `id` int(2) NOT NULL AUTO_INCREMENT,<br/>  `name` varchar(25) COLLATE utf8mb4_unicode_ci NOT NULL,<br/>   PRIMARY KEY (`id`)) <br/>ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;</span></pre><p id="4941" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">两个并发事务访问同一个表。</p><pre class="kn ko kp kq gt nr ns nt nu aw nv bi"><span id="6b23" class="nw mp iq ns b gy nx ny l nz oa">// Transaction 1<br/>ActiveRecord::Base.transaction<br/>  user2 = User.find(2)</span><span id="4cd8" class="nw mp iq ns b gy ob ny l nz oa">  // &lt;- Transaction 2 updated the user3 from charlie to chris at    <br/>  // this point</span><span id="1fed" class="nw mp iq ns b gy ob ny l nz oa">  user3 = User.find(3) // charlie or chris?<br/>end</span></pre><p id="1f5a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在下图中，并发事务看到另一个事务所做的实时更改。<em class="kl">事务1 </em>获得<em class="kl">克里斯</em>作为最新提交的名称，即使<em class="kl">事务2 </em>在<em class="kl">事务1之后开始。</em></p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gh gi oc"><img src="../Images/fba6e47548c9147cc98f64ec39123b97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aAJGTGM6Fa2V_5L5wpcq5w.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">读取时序图表中提交的视图</figcaption></figure><p id="8e7d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="kl">可重复读取</em>隔离级别保证事务看到第一次读取所获得的数据库快照的提交视图。</strong>与<em class="kl">提交读取</em>隔离级别不同，在事务中的某一点读取的数据与在事务中的另一点读取的数据相同。</p><p id="2056" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们再次尝试之前的场景，但是将隔离级别更改为<em class="kl">可重复读取</em>。并发事务看到在每个事务内拍摄的快照的提交视图。<em class="kl">事务1 </em>得到<em class="kl">查理，</em>而不是<em class="kl">克里斯，</em>因为<em class="kl">事务1 </em>在<em class="kl">事务2之前开始。</em>换句话说，这两个并发事务是串行执行的。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gh gi oc"><img src="../Images/3a2071ccf0096c11229533e94afcbe51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y0Fa-wNrsriiUieaCwWchQ.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">时序图表中的可重复读取视图</figcaption></figure><p id="c5bf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">请注意，快照是由表拍摄的，而不是由行或数据库拍摄的。</strong>对表的第一次读取会创建一个新的表快照。如上图所示，<em class="kl">事务1 </em>在发出<em class="kl">SELECT name FROM users WHERE id = 2</em>时，创建了<em class="kl"> users </em>表的快照。事务结束后，快照将被删除。</p><p id="71dd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在许多情况下，由快照读取特性支持的一致读取使我们的生活更加轻松。假设您添加了一个新的API端点，用户可以通过它加入一个特定的聊天组。下面的代码显示了<em class="kl"> check_in </em> API创建了一个新的<em class="kl"> chat_group_user </em>并返回了<em class="kl"> chat_group </em>，包括其所有的<em class="kl"> chat_group_users </em>。</p><pre class="kn ko kp kq gt nr ns nt nu aw nv bi"><span id="27ab" class="nw mp iq ns b gy nx ny l nz oa">def check_in<br/>  // Transaction 1<br/>  ActiveRecord::Base.transaction<br/>    chat_group_user = <a class="ae ky" href="http://twitter.com/chat_group_room" rel="noopener ugc nofollow" target="_blank">@chat_group</a>.chat_group_users.build(user: <br/>    current_user)<br/>    chat_group_user.save!</span><span id="e304" class="nw mp iq ns b gy ob ny l nz oa">    // &lt;- Transaction 2 forcefully checked out the chat_group_user <br/>    // at this point. It can happen due to the sudden disconnection.</span><span id="705f" class="nw mp iq ns b gy ob ny l nz oa">    render json: <a class="ae ky" href="http://twitter.com/chat_group_room" rel="noopener ugc nofollow" target="_blank">@chat_group</a>, serializer: ChatGroupSerializer, <br/>    include:[:chat_group_users]<br/>  end<br/>end</span></pre><blockquote class="lk"><p id="bca0" class="ll lm iq bd ln lo od oe of og oh kk dk translated">我们最近在生产中遇到的困难引出了这个例子。我们期望响应将请求者作为新的chat_group_user，因为check_in API刚刚成功返回200。但是，这取决于你的隔离级别。</p></blockquote><p id="a1a6" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">有了<em class="kl">可重复读取</em>，一旦找到了chat_group_user，就不用担心事务内的删除了。您的API的逻辑和响应是一致的，就好像没有并发删除一样。使用提交的<em class="kl">读取</em>，API逻辑可能基于数据的存在，而API响应可能基于数据的移除。尽管这种不一致反映了实际情况，但它却是一个令人讨厌的小故障，因为这种罕见的不一致在开发过程中不值得注意。</p><p id="f1f7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">改变隔离级别会导致不同的后果。</strong>虽然将<em class="kl">提交读取</em>升级为<em class="kl">可重复读取</em>意味着性能降低，但将<em class="kl">可重复读取</em>降级为<em class="kl">提交读取</em>会导致保证降低。考虑到成熟的应用程序可能会无意中依赖于快照读取特性，您最好在降级之前为意外行为做好准备。</p><h1 id="41e4" class="mo mp iq bd mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj nk nl bi translated">Vitess提供了什么读提交语义？</h1><p id="f132" class="pw-post-body-paragraph jn jo iq jp b jq nm js jt ju nn jw jx jy no ka kb kc np ke kf kg nq ki kj kk ij bi translated">这是否意味着<em class="kl"> Vitess </em>在每个MySQL数据库上隐式地将您的隔离级别设置为<em class="kl"> READ COMMITTED </em>？</p><blockquote class="lk"><p id="4f08" class="ll lm iq bd ln lo lp lq lr ls lt kk dk translated">我的同事<a class="ae ky" href="https://github.com/cou929" rel="noopener ugc nofollow" target="_blank"> cou929 </a>对此进行了调查，发现<em class="lu"> Vitess </em>并不会改变隔离级别。</p></blockquote><p id="bd79" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">那么，文档是不是错了，因为在引入了<em class="kl"> Vitess </em>之后，我们仍然有一堆<em class="kl">可重复读取的</em> MySQL数据库？嗯…</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="a297" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我重读这句话时，我注意到文档提到了条件“<em class="kl">当执行跨分片查询</em>时。”这意味着<em class="kl"> Vitess </em>不会改变行为，除非是跨片查询。</p><blockquote class="le lf lg"><p id="bd90" class="jn jo kl jp b jq jr js jt ju jv jw jx lh jz ka kb li kd ke kf lj kh ki kj kk ij bi translated"><a class="ae ky" href="https://vitess.io/docs/13.0/reference/compatibility/mysql-compatibility/" rel="noopener ugc nofollow" target="_blank"> Vitess在执行跨分片查询时提供读提交语义。</a></p></blockquote><p id="a13a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当目标数据存储在多个名为<em class="kl">碎片</em>的MySQL数据库中时，我们需要执行跨碎片查询。我们如何实现碎片快照的一致视图，就好像碎片是一个MySQL数据库一样？仅仅通过水平排列MySQL数据库来创建一致的视图是不可能的，即使每个MySQL的隔离级别都是<em class="kl">可重复读取</em>。这是因为每个快照都是在不同的时间拍摄的。</p><p id="48c2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们观察事务在一个点从一个碎片读取，在另一个点从另一个碎片读取。<strong class="jp ir"> </strong> <em class="kl"> Vitess </em>允许你运行如下相同的应用程序代码，即使你把一个表分成两个部分表。</p><pre class="kn ko kp kq gt nr ns nt nu aw nv bi"><span id="df80" class="nw mp iq ns b gy nx ny l nz oa">// Virtual Transaction 1<br/>ActiveRecord::Base.transaction<br/>  user2 = User.find(2)</span><span id="5e9f" class="nw mp iq ns b gy ob ny l nz oa">  // &lt;- Transaction 2 updated the user3 in Database 2 from charlie <br/>  // to chris at this point</span><span id="9129" class="nw mp iq ns b gy ob ny l nz oa">  user3 = User.find(3) // charlie or chris<br/>end</span></pre><p id="89f5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">虽然这是一个方便的抽象，但是您应该知道V <em class="kl">虚拟事务1 </em>包含两个物理事务，分别指向<em class="kl">数据库1 </em>和<em class="kl">数据库2 </em>中的每个<em class="kl">用户</em>表。因此，上面的代码实际上是以如下方式执行的:</p><pre class="kn ko kp kq gt nr ns nt nu aw nv bi"><span id="f67c" class="nw mp iq ns b gy nx ny l nz oa">// Transaction 1 in Database 1<br/>ActiveRecord::Base.transaction<br/>  user2 = User.find(2)</span><span id="bf70" class="nw mp iq ns b gy ob ny l nz oa">  // &lt;- Transaction 2 updated the user3 in Database 2 from    <br/>  // charlie to chris at this point<br/>  <br/>  // Transaction 1 in Database 2<br/>  ActiveRecord::Base.connected_to(role: :database2) do  <br/>    user3 = User.find(3)<br/>  end<br/>end</span></pre><p id="4a2a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如下图所示，事务会看到每个分片的最新提交视图，直到分片在第一次读取时获取其快照。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gh gi ok"><img src="../Images/5008448a28c9cca078c810e079e0f99f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iCPWJH3vtLWn_tgSP6Km8g.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">时序图表中的读取提交语义+可重复读取视图</figcaption></figure><p id="b63d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="kl"> READ COMMITTED </em>语义代表了碎片的不一致视图。</strong>结合<em class="kl">可重复读取</em>隔离级别，事务看到的是碎片快照的不一致视图。此外，值得注意的是，这个例子的结果(<em class="kl"> chris </em>，而不是<em class="kl"> charlie </em>)与独立MySQL设置为<em class="kl"> READ COMMITTED </em>隔离级别的情况相同。</p><h1 id="dd8d" class="mo mp iq bd mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj nk nl bi translated">对分片使用哪种隔离级别？</h1><p id="6474" class="pw-post-body-paragraph jn jo iq jp b jq nm js jt ju nn jw jx jy no ka kb kc np ke kf kg nq ki kj kk ij bi translated">没有一种适合所有分布式隔离级别的解决方案，因为即使一个数据库也有四种隔离级别。您的里程可能会有所不同。</p><p id="bef7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当您的应用程序对<em class="kl"> READ COMMITTED </em>隔离级别感到满意时，您是幸运的。从理论上讲，<em class="kl">读提交的</em>语义不会使<em class="kl">读提交的</em>事务的保证更少。你最好坚持下去。</p><p id="fd58" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当您的应用依赖于<em class="kl">可重复读取</em>隔离级别时，您需要做好准备。<em class="kl">读提交</em>语义使得<em class="kl">可重复读</em>事务的保证更少。但是，怎么不那么有保障呢？这取决于你的应用程序的用途。</p><p id="093f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">不太有保证的<em class="kl">可重复读取</em>仍然可以防止大部分的不一致，</strong>比如API逻辑和串行化器之间的不一致，正如我之前提到的。最后，只要逻辑部分在碎片上创建所有快照，序列化部分稍后引用这些快照，就不会有不一致。</p><p id="e90b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">另一方面，你的报告功能可能会打折扣。假设您想通过批处理脚本连接order表和item_info表来报告订购商品的统计数据。如果在创建报告时更新了item_info表，该怎么办？如果没有分片，为报告而运行的事务看不到最新的更改，因此报告结果是一致的，就好像更新是在报告之后执行的一样，这意味着两个并发事务被序列化。一旦item_info表被分成item_info_1和item_info_2表，您的批处理脚本就不能像以前一样访问item_info表的整个快照。可以根据旧的项目信息和新的信息混合来制作您的报告。</p><pre class="kn ko kp kq gt nr ns nt nu aw nv bi"><span id="698f" class="nw mp iq ns b gy nx ny l nz oa">// Transaction 1<br/>ActiveRecord::Base.transaction<br/>  orders = Order.where(created_at: <a class="ae ky" href="http://twitter.com/report_begin" rel="noopener ugc nofollow" target="_blank">@report_begin</a>..<a class="ae ky" href="http://twitter.com/report_end" rel="noopener ugc nofollow" target="_blank">@report_end</a>)<br/>  orders.each do |order|<br/>    items = ItemInfo.where(id: order.item_ids)<br/>    // &lt;- Transaction 2 can change some item_info before <br/>    // Transaction 1 takes a snapshot in shards<br/>  end<br/>end</span></pre><p id="1755" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">当您有时间进行分片前的准备时，在特定会话</strong>  <strong class="jp ir">内，将您的单个MySQL数据库降级为<em class="kl"> READ COMMITTED </em>隔离级别，并将其更改为<em class="kl"> REPEATABLE READ </em>隔离级别</strong> <a class="ae ky" href="https://dev.mysql.com/doc/refman/8.0/en/set-transaction.html" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">会更安全。</strong>您可以采取这一步骤，在分割之前减轻和控制风险。此外，在分片之前将级别设置为<em class="kl"> READ COMMITTED </em>让您有机会发现您的应用程序真正需要的级别。</a></p><p id="5270" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您的应用程序不能容忍这种不太可靠的隔离级别，该怎么办？如果一个更高的层次，简称为<em class="kl">可重复读取</em>语义，是您的应用程序的严格要求，您应该考虑NewSQL。对于一个流行的MySQL兼容数据库，<a class="ae ky" href="https://docs.pingcap.com/tidb/dev/transaction-isolation-levels" rel="noopener ugc nofollow" target="_blank"> TiDB支持<em class="kl">可重复读取</em>语义</a>。</p><h1 id="d332" class="mo mp iq bd mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj nk nl bi translated">包扎</h1><p id="6864" class="pw-post-body-paragraph jn jo iq jp b jq nm js jt ju nn jw jx jy no ka kb kc np ke kf kg nq ki kj kk ij bi translated">分片数据库不能保证<em class="kl">可重复读取</em>隔离级别作为一个整体，即使每个数据库都被设置为相同的级别。Vitess称之为不太有保证的隔离级别<em class="kl">读提交</em>语义。</p><p id="fdbb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我通过重温关于隔离级别的<em class="kl"> SQL:1992 </em>标准，观察发出跨分片查询的事务，并检查与您的应用程序需求相对应的隔离级别，揭示了这种后果的规模。</p></div></div>    
</body>
</html>