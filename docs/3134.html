<html>
<head>
<title>Storing JSON in Postgres using Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Node.js在Postgres中存储JSON</h1>
<blockquote>原文：<a href="https://itnext.io/storing-json-in-postgres-using-node-js-c8ff50337013?source=collection_archive---------0-----------------------#2019-10-10">https://itnext.io/storing-json-in-postgres-using-node-js-c8ff50337013?source=collection_archive---------0-----------------------#2019-10-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/ce931d3e75a6519cb51f1653e27b85f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8bkBRx4Qa6c4GZhB145VpA.jpeg"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated"><a class="ae jg" href="https://unsplash.com/@ladybugz_?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">布兹</a>女士在<a class="ae jg" href="https://unsplash.com/images/animals/elephant?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><div class=""/><p id="1376" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让MongoDB这样的NoSQL数据库如此受欢迎的一个原因是，当您需要的时候，只需添加一个JSON就可以了。然而，您可能没有意识到的是，Postgres对JSON的支持几乎一样好。除了在字段中抛出一些JSON之外，您还可以使用所有常见的SQL操作来查询它。你得到<code class="fe le lf lg lh b">JOIN</code> s，交易，指数等。</p><h1 id="32ce" class="li lj jj bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">JSON与JSONB</h1><p id="9e61" class="pw-post-body-paragraph kg kh jj ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">向postgres添加JSON字段时，第一步是在JSON和JSONB之间做出决定。我给你简单说一下:</p><blockquote class="ml"><p id="ba9d" class="mm mn jj bd mo mp mq mr ms mt mu ld dk translated">永远用JSONB，千万不要用JSON</p></blockquote><p id="e605" class="pw-post-body-paragraph kg kh jj ki b kj mv kl km kn mw kp kq kr mx kt ku kv my kx ky kz mz lb lc ld im bi translated">JSONB就像JSON一样，只是它不存储JSON的实际字符串，而是存储一个有效的二进制表示。您可能想要存储JSON的唯一原因是，如果您想要跟踪原始JSON序列化中的空白。这应该是不需要的，如果你想要JSON的“漂亮”视图，你可以使用<code class="fe le lf lg lh b">JSON.stringify</code>来美化它。我无法想象为什么你会需要原来的空白。</p><h1 id="1493" class="li lj jj bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">创建表</h1><p id="e8aa" class="pw-post-body-paragraph kg kh jj ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">既然已经决定使用<code class="fe le lf lg lh b">JSONB</code>作为格式，就可以像平常一样创建表格了。</p><pre class="na nb nc nd gt ne lh nf ng aw nh bi"><span id="ed8e" class="ni lj jj lh b gy nj nk l nl nm"><strong class="lh jk">CREATE</strong> <strong class="lh jk">TABLE</strong> my_data (<br/>  id <strong class="lh jk">TEXT NOT NULL PRIMARY KEY</strong>,<br/>  data <strong class="lh jk">JSONB NOT NULL</strong><br/>);</span></pre><p id="a564" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这创建了一个表，它有一个名为<code class="fe le lf lg lh b">id</code>的主键，类型为<code class="fe le lf lg lh b">TEXT</code>，还有一个<code class="fe le lf lg lh b">data</code>列来存储我们的JSON数据。</p><h1 id="92fd" class="li lj jj bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">读取和写入JSON数据</h1><p id="5ecf" class="pw-post-body-paragraph kg kh jj ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">如果您使用的是<code class="fe le lf lg lh b"><a class="ae jg" href="https://www.atdatabases.org/docs/pg" rel="noopener ugc nofollow" target="_blank">@databases/pg</a></code>客户端，您可以像读取任何其他值一样读取和写入Postgres数据:</p><pre class="na nb nc nd gt ne lh nf ng aw nh bi"><span id="70ea" class="ni lj jj lh b gy nj nk l nl nm"><strong class="lh jk">import</strong> connect, {sql} <strong class="lh jk">from</strong> '@databases/pg';</span><span id="27bc" class="ni lj jj lh b gy nn nk l nl nm"><strong class="lh jk">const</strong> db = connect();</span><span id="f250" class="ni lj jj lh b gy nn nk l nl nm"><strong class="lh jk">export</strong> <strong class="lh jk">async</strong> <strong class="lh jk">function</strong> get(id) {<br/>  <strong class="lh jk">const</strong> [row] = <strong class="lh jk">await</strong> db.query(<br/>    sql`<br/>      <strong class="lh jk">SELECT</strong> data<br/>      <strong class="lh jk">FROM</strong> my_data<br/>      <strong class="lh jk">WHERE</strong> id=${id}<br/>    `<br/>  );<br/>  <strong class="lh jk">return</strong> row ? row.data : null;<br/>}</span><span id="912d" class="ni lj jj lh b gy nn nk l nl nm"><strong class="lh jk">export</strong> <strong class="lh jk">async</strong> <strong class="lh jk">function</strong> set(id, value) {<br/>  <strong class="lh jk">await</strong> db.query(sql`<br/>    <strong class="lh jk">INSERT</strong> <strong class="lh jk">INTO</strong> my_data (id, data)<br/>    <strong class="lh jk">VALUES</strong> (${id}, ${value})<br/>    <strong class="lh jk">ON</strong> <strong class="lh jk">CONFLICT</strong> id<br/>    <strong class="lh jk">DO</strong> <strong class="lh jk">UPDATE</strong> <strong class="lh jk">SET</strong> data = EXCLUDED.data;<br/>  `);<br/>}</span></pre><p id="ee1d" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这为使用postgres数据库的JSON blobs提供了一个简单的键值存储。</p><h1 id="2759" class="li lj jj bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">查询JSON</h1><p id="964a" class="pw-post-body-paragraph kg kh jj ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">假设我们在“NoSQL博客数据库”中存储了一些博客文章:</p><pre class="na nb nc nd gt ne lh nf ng aw nh bi"><span id="8b15" class="ni lj jj lh b gy nj nk l nl nm"><strong class="lh jk">await</strong> set('post-a', {<br/>  author: 'ForbesLindesay',<br/>  title: 'Post A',<br/>  body: 'This post is about the letter A',<br/>});</span><span id="6a57" class="ni lj jj lh b gy nn nk l nl nm"><strong class="lh jk">await</strong> set('post-b', {<br/>  author: 'ForbesLindesay',<br/>  title: 'Post B',<br/>  body: 'This post is about the letter B',<br/>});</span><span id="e682" class="ni lj jj lh b gy nn nk l nl nm"><strong class="lh jk">await</strong> set('post-a-rebuttal', {<br/>  author: 'JoeBloggs',<br/>  title: 'Post A - Rebuttal',<br/>  body: 'Forbes was wrong about the letter A',<br/>});</span></pre><p id="119b" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在假设我们想在<code class="fe le lf lg lh b">ForbesLindesay</code>之前获得所有博客文章的列表。author字段隐藏在JSONB字段中，但这并不意味着我们不能在查询中使用它。</p><pre class="na nb nc nd gt ne lh nf ng aw nh bi"><span id="788f" class="ni lj jj lh b gy nj nk l nl nm"><strong class="lh jk">export</strong> <strong class="lh jk">async</strong> <strong class="lh jk">function</strong> listByAuthor(author) {<br/>  <strong class="lh jk">return</strong> <strong class="lh jk">await</strong> db.query(<br/>    sql`<br/>      <strong class="lh jk">SELECT</strong> data<br/>      <strong class="lh jk">FROM</strong> my_data<br/>      <strong class="lh jk">WHERE<br/>        </strong>data -&gt;&gt; 'author'<br/>          = ${author}<br/>    `<br/>  );<br/>}</span></pre><p id="08aa" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这里，<code class="fe le lf lg lh b">-&gt;&gt;</code>操作符的意思是“获取这个属性的值”。只有当值是字符串、数字或布尔值时，它才起作用。如果值是另一个对象，就必须使用<code class="fe le lf lg lh b">-&gt;</code>操作符，意思是“以JSON的形式获取这个属性的值”。</p><p id="cb77" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">很明显，这意味着您可以在这里使用SQL的全部功能，但仅举另一个例子，我们可以获得所有作者的列表:</p><pre class="na nb nc nd gt ne lh nf ng aw nh bi"><span id="2b58" class="ni lj jj lh b gy nj nk l nl nm"><strong class="lh jk">export</strong> <strong class="lh jk">async</strong> <strong class="lh jk">function</strong> getAuthors() {<br/>  <strong class="lh jk">return</strong> (<strong class="lh jk">await</strong> db.query(<br/>    sql`<br/>      <strong class="lh jk">SELECT</strong> <strong class="lh jk">DISTINCT<br/>        </strong>data -&gt;&gt; 'author' as author<br/>      <strong class="lh jk">FROM</strong> my_data<br/>    `<br/>  )).map(({author}) =&gt; author);<br/>}</span></pre><p id="b912" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里，我们从数据中提取作者，然后使用SQL的<code class="fe le lf lg lh b">DISTINCT</code>操作符只返回每个作者一次。</p><h1 id="5613" class="li lj jj bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">结论</h1><p id="9bd1" class="pw-post-body-paragraph kg kh jj ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">在Postgres中，您可以像使用任何其他值一样使用JSON，为JSON blobs建立一个类似NoSQL的商店并将其用作整个数据库会很容易。这不一定意味着你<strong class="ki jk">应该</strong>。这个JSON数据完全是无模式的，所以在将它插入数据库之前，正确地验证它是否匹配任何预期的结构是非常重要的。当您需要存储大型JSON结构并且您还不确定如何查询它们时，这非常有用，但是在大多数情况下，我仍然建议在SQL中使用显式字段，并使用连接来存储嵌套列表等。</p></div></div>    
</body>
</html>