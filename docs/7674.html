<html>
<head>
<title>Why you don’t need observable inputs in your Angular components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么在角度分量中不需要可观测的输入</h1>
<blockquote>原文：<a href="https://itnext.io/why-you-dont-need-observable-inputs-in-your-angular-components-25e74cfe234d?source=collection_archive---------1-----------------------#2022-12-15">https://itnext.io/why-you-dont-need-observable-inputs-in-your-angular-components-25e74cfe234d?source=collection_archive---------1-----------------------#2022-12-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/b7d6957110b783c678bb4055212f2d87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cYqtsZruzDIBxihx0N8Gww.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">“一对塞特”，亚历山大·波普，1913年</figcaption></figure><p id="9ffd" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我曾经试验并构建了几个组件，所有的组件都可以被观察到。为此，我必须使用setters并订阅收到的observables。如果Angular支持“可观察的输入”,我就不用这么做了，但是我发现了为什么你不应该把可观察的输入传递给<code class="fe la lb lc ld b">@Inputs</code>,即使Angular支持它。</p><h1 id="2f6a" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">避免可观察输入的原因</h1><h2 id="1247" class="mc lf iq bd lg md me dn lk mf mg dp lo kn mh mi ls kr mj mk lw kv ml mm ma mn bi translated">⊖降低了可重用性</h2><p id="5090" class="pw-post-body-paragraph kc kd iq ke b kf mo kh ki kj mp kl km kn mq kp kq kr mr kt ku kv ms kx ky kz ij bi translated">具有可观察输入的组件或指令的每个“消费者”都应该以可观察值的形式提供值——但通常情况并非如此，值只是原语或对象，因此您必须专门为该组件创建可观察值。有些情况下，您将组件嵌入到您无法修改的组件中。</p><h2 id="f93f" class="mc lf iq bd lg md me dn lk mf mg dp lo kn mh mi ls kr mj mk lw kv ml mm ma mn bi translated">⊖不可预测通知</h2><p id="1a3c" class="pw-post-body-paragraph kc kd iq ke b kf mo kh ki kj mp kl km kn mq kp kq kr mr kt ku kv ms kx ky kz ij bi translated">当您的组件订阅Observable时，它可能会有一些缓冲值，但这并不能保证——而且它可能会因冻结的UI部件或永无休止的旋转而产生令人讨厌的错误。</p><p id="ef97" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果您需要读取/合并来自多个输入的值，这种情况尤其容易遇到——只要一个没有缓冲值的可观察值就可能冻结整个链。</p><p id="f644" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在框架层面上，Angular可以将<code class="fe la lb lc ld b">startWith(undefined)</code>添加到操作中，但是要做到这一点，您的代码不应该有类似<code class="fe la lb lc ld b">if (value==null) return;</code>的东西。此外，您的代码应该准备好处理多个缓冲值。</p><h2 id="2f65" class="mc lf iq bd lg md me dn lk mf mg dp lo kn mh mi ls kr mj mk lw kv ml mm ma mn bi translated">⊖多重订阅可能会产生问题</h2><p id="ef61" class="pw-post-body-paragraph kc kd iq ke b kf mo kh ki kj mp kl km kn mq kp kq kr mr kt ku kv ms kx ky kz ij bi translated">很简单的例子:</p><pre class="mt mu mv mw gt mx ld my bn mz na bi"><span id="d269" class="nb lf iq ld b be nc nd l ne nf">getUsers() {<br/>  return this.http.get('/users');<br/>}<br/><br/>const users$ = getUsers();<br/><br/>getCoordinates(element) {<br/>  return someHeavyDOMCalculations(element);<br/>}<br/><br/>const coordinates$ = getCoordinates(this.element$);</span></pre><p id="fbf5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">但是如果您使用<code class="fe la lb lc ld b">users$</code>或<code class="fe la lb lc ld b">coordinates$</code>作为可观察输入的值，那么每次使用都会创建一个新的订阅(并且在每个组件中创建多个订阅非常容易)。如果应用了<code class="fe la lb lc ld b">ngFor</code>或<code class="fe la lb lc ld b">ngIf</code>,事情会迅速增加，性能下降会变得很明显。</p><p id="26a9" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在<code class="fe la lb lc ld b">users$</code>的情况下，很容易发现问题，像<code class="fe la lb lc ld b">getUsers()</code>这样的大多数方法会将<code class="fe la lb lc ld b">shareReplay()</code>添加到观察链中。但这只是一个简化的例子——在许多现实生活中，很容易找到一个例子，其中observable没有针对多个订阅者进行优化。</p><p id="2a7f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这不仅仅是性能问题——一些可观察到的问题可能会产生副作用，并修改数据——在这种情况下，损坏的数据比XHR请求或布局回流的瀑布更危险。</p><h2 id="4634" class="mc lf iq bd lg md me dn lk mf mg dp lo kn mh mi ls kr mj mk lw kv ml mm ma mn bi translated">⊖可观测量会产生误差</h2><p id="bd34" class="pw-post-body-paragraph kc kd iq ke b kf mo kh ki kj mp kl km kn mq kp kq kr mr kt ku kv ms kx ky kz ij bi translated">可观察输入期待一个理想的场景——第一个值被缓冲，只有一个缓冲值，可观察输入准备好被多播，不会意外发送“完成”通知，并且永远不会发出错误。</p><p id="c2dd" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">您必须为每个可观察到的输入编写一些样板代码来处理所有的边缘情况，其中一些是框架无法为您处理的。</p><h2 id="c2ac" class="mc lf iq bd lg md me dn lk mf mg dp lo kn mh mi ls kr mj mk lw kv ml mm ma mn bi translated">⊖输入可以被替换</h2><p id="4030" class="pw-post-body-paragraph kc kd iq ke b kf mo kh ki kj mp kl km kn mq kp kq kr mr kt ku kv ms kx ky kz ij bi translated">与任何其他输入一样，可观察输入可以在运行时被替换——可能会创建一个新的可观察输入，并且您的代码必须处理重新订阅和实现正确更新的所有影响。如果你使用类似于<code class="fe la lb lc ld b">combineLatest()</code>的东西来处理多个不同的输入，事情可能会变得复杂。</p><h1 id="2544" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">解决办法</h1><p id="058d" class="pw-post-body-paragraph kc kd iq ke b kf mo kh ki kj mp kl km kn mq kp kq kr mr kt ku kv ms kx ky kz ij bi translated">有一个健壮的、经过战斗考验的简单解决方案:<strong class="ke ir"> setters + store </strong>。</p><p id="8e25" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在一些简单的情况下，您可以只使用<a class="ae ng" href="https://rxjs.dev/api/index/class/BehaviorSubject" rel="noopener ugc nofollow" target="_blank"> BehaviorSubject </a>而不是某个状态管理库中的存储，但前提是您不需要同时使用多个输入。</p><p id="801d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">简化示例:</p><pre class="mt mu mv mw gt mx ld my bn mz na bi"><span id="ddc4" class="nb lf iq ld b be nc nd l ne nf">@Component({<br/>  ...<br/>  providers: [ExampleComponentStore]<br/>})<br/>export class ExampleComponent {<br/>    protected readonly store = inject(ExampleComponentStore);<br/><br/>    @Input() set id(id: number) {<br/>        this.store.patchState({id});<br/>    }<br/>}</span></pre><p id="c219" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">就是这样！</p><p id="1ed1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">即使多个输入将被更改，您也可以使用您喜欢的存储功能来正确处理它。</p><p id="132f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如何将存储添加到组件取决于您(以及您喜欢的库)。这个例子的要点是:只需使用setter修改状态。</p><p id="3296" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">Setters提供了一个额外的好处:可观察值可以不止一次地产生值——如果可观察输入被Angular本身转换为原始值，开发人员将只读取第一个值，而连续的值将会丢失(没有那么多组件观察ngOnChanges)。使用setters，您的组件将被迫在每次输入改变时更新其状态。</p><p id="3bbf" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">Chau Tran有一个相同技术的例子:</p><figure class="mt mu mv mw gt jr"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="0e3d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">使用这种技术，您的组件将保持可重用，将对输入变化做出反应，并将避免所有可观察到的输入的缺陷。</p></div></div>    
</body>
</html>