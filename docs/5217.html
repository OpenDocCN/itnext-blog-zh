<html>
<head>
<title>Re: Avoid backing properties for LiveData and StateFlow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于:避免支持LiveData和StateFlow的属性</h1>
<blockquote>原文：<a href="https://itnext.io/re-avoid-backing-properties-for-livedata-and-stateflow-2160cab96b56?source=collection_archive---------2-----------------------#2021-01-14">https://itnext.io/re-avoid-backing-properties-for-livedata-and-stateflow-2160cab96b56?source=collection_archive---------2-----------------------#2021-01-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="ef20" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最近我偶然发现了Danny Preussler的这篇文章，这让我思考，如果利用Kotlin的特性，是否有更好的方法来避免背景字段。</p><p id="d4ef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我想到了一个主意，虽然我不认为后台字段是如此邪恶，以至于需要不惜一切代价避免它们，但对我来说，围绕这个主题玩一会儿还是很有趣的。虽然我不一定推荐使用这种避免支持字段的方式，但展示这种想法并在Kotlin中展示一些鲜为人知的技巧可能会很有趣。</p><p id="d096" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">读完这篇文章后，我的第一个想法是，是否有任何方法可以利用Kotlin中的<code class="fe km kn ko kp b">Delegate</code>模式来避免后台字段。我受到了Jetpack Compose中的<code class="fe km kn ko kp b">mutableStateOf()</code>的启发，它在<code class="fe km kn ko kp b">ViewModel</code>中启用了这种语法:</p><pre class="kq kr ks kt gt ku kp kv kw aw kx bi"><span id="3225" class="ky kz iq kp b gy la lb l lc ld">var someState by mutableStateOf(1)<br/>  private set</span></pre><p id="1e25" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这很棒，因为它只允许在<code class="fe km kn ko kp b">ViewModel</code>中改变状态，视图层没有修改状态的选项，只能看到最新的值。</p><p id="4e44" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们能不能利用这种方法为<code class="fe km kn ko kp b">LiveData&lt;T&gt;</code>或<code class="fe km kn ko kp b">StateFlow&lt;T&gt;</code>避免写后台字段？</p><p id="98dd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">事实证明这并不容易。为了实现这种功能，Jetpack compose在自己的定制类型<code class="fe km kn ko kp b">MutableState&lt;T&gt;</code>和<code class="fe km kn ko kp b">State&lt;T&gt;</code>上使用扩展函数，如下所示:</p><pre class="kq kr ks kt gt ku kp kv kw aw kx bi"><span id="f773" class="ky kz iq kp b gy la lb l lc ld">@Suppress(<strong class="kp ir">"NOTHING_TO_INLINE"</strong>)<br/><strong class="kp ir">inline operator fun </strong>&lt;T&gt; State&lt;T&gt;.getValue(thisObj: Any?, property: KProperty&lt;*&gt;): T = <strong class="kp ir">value</strong></span><span id="9fc0" class="ky kz iq kp b gy le lb l lc ld">@Suppress(<strong class="kp ir">"NOTHING_TO_INLINE"</strong>)<br/><strong class="kp ir">inline operator fun </strong>&lt;T&gt; MutableState&lt;T&gt;.setValue(thisObj: Any?, property: KProperty&lt;*&gt;, value: T) {<br/>    <strong class="kp ir">this</strong>.<strong class="kp ir">value </strong>= value<br/>}</span></pre><p id="5735" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="lf">注意:我不知道在Kotlin中可以用这种方式覆盖setter和getter！这是通过浏览Jetpack Compose代码库学到的很好的一课。</em></p><p id="19f0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而问题是，访问<code class="fe km kn ko kp b">someState</code>值直接返回值，而不是<code class="fe km kn ko kp b">MutableState&lt;T&gt;</code>的实例，也不是<code class="fe km kn ko kp b">State</code>。在我们的例子中，如果我们想这样包装<code class="fe km kn ko kp b">LiveData&lt;T&gt;</code>,无论如何都不可能观察到它，因为它是不可访问的。</p><p id="bb24" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么这种语法是不可能存在的吗？</p><p id="1be9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">嗯，有一些变通办法。</p><p id="1bcf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">可以创建一个委托，为<code class="fe km kn ko kp b">LiveData&lt;T&gt;</code>设置一个setter和getter，这将允许在ViewModel中限制<code class="fe km kn ko kp b">set</code>为<code class="fe km kn ko kp b">private</code>。</p><p id="ab83" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">乍一看，这可能不是很有帮助，因为我们不想一直覆盖保存状态的<code class="fe km kn ko kp b">LiveData</code>实例。但是无论如何我们可以利用它:</p><pre class="kq kr ks kt gt ku kp kv kw aw kx bi"><span id="9dea" class="ky kz iq kp b gy la lb l lc ld">fun &lt;T&gt; liveDataDelegate(defaultValue: T): ReadWriteProperty&lt;Any, LiveData&lt;T&gt;&gt; = object : ReadWriteProperty&lt;Any, LiveData&lt;T&gt;&gt; {<br/>    private val liveData: MutableLiveData&lt;T&gt; = MutableLiveData(defaultValue)<br/><br/>    override fun getValue(thisRef: Any, property: KProperty&lt;*&gt;): LiveData&lt;T&gt; = liveData<br/><br/>    override fun setValue(thisRef: Any, property: KProperty&lt;*&gt;, value: LiveData&lt;T&gt;) {<br/>        liveData.postValue(value.value!!)<br/>    }<br/>}</span><span id="8a13" class="ky kz iq kp b gy le lb l lc ld">class MyViewModel : ViewModel() {<br/>    var state by <em class="lf">liveDataDelegate</em>(1)<br/>        private set</span><span id="1742" class="ky kz iq kp b gy le lb l lc ld">    fun updateState(newValue: Int) {<br/>        state = MutableLiveData(newValue)<br/>    }<br/>}</span></pre><p id="efec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们使用<code class="fe km kn ko kp b">ReadWriteProperty&lt;&gt;</code>委托，它使用<code class="fe km kn ko kp b">MutableLiveData</code>的实例作为后台字段，当我们想要向它提交新值时，我们将新值包装到<code class="fe km kn ko kp b">MutableLiveData</code>的新实例中，而<code class="fe km kn ko kp b">ReadWriteProperty</code>委托打开该值并将其提交到其底层的<code class="fe km kn ko kp b">MutableLiveData</code>属性中。</p><p id="da81" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个委托的Getter返回<code class="fe km kn ko kp b">MutableLiveData</code>的底层实例，但是只将其公开为<code class="fe km kn ko kp b">LiveData</code>。这样仍然可以观察到<code class="fe km kn ko kp b">LiveData</code>，但仅限于对<code class="fe km kn ko kp b">MyViewModel</code>进行修改。</p><p id="807d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好的，但是这条线<code class="fe km kn ko kp b">state = MutableLiveData(newValue)</code>有点难看，所以我们能做得稍微好一点吗？</p><p id="51a2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以利用扩展函数来获得稍微简洁的语法，最终得到这个最终解决方案:</p><pre class="kq kr ks kt gt ku kp kv kw aw kx bi"><span id="e889" class="ky kz iq kp b gy la lb l lc ld">fun &lt;T&gt; liveDataDelegate(defaultValue: T): ReadWriteProperty&lt;Any, LiveData&lt;T&gt;&gt; = object : ReadWriteProperty&lt;Any, LiveData&lt;T&gt;&gt; {<br/>    private val liveData: MutableLiveData&lt;T&gt; = MutableLiveData(defaultValue)<br/><br/>    override fun getValue(thisRef: Any, property: KProperty&lt;*&gt;): LiveData&lt;T&gt; = liveData<br/><br/>    override fun setValue(thisRef: Any, property: KProperty&lt;*&gt;, value: LiveData&lt;T&gt;) {<br/>        liveData.postValue((value as WrapLiveData&lt;T&gt;).startValue)<br/>    }<br/>}<br/><br/>private class WrapLiveData&lt;T&gt;(val startValue: T): LiveData&lt;T&gt;(startValue)<br/>fun &lt;T&gt; T.post(): LiveData&lt;T&gt; = WrapLiveData(this)</span><span id="5f2e" class="ky kz iq kp b gy le lb l lc ld">class MyViewModel : ViewModel() {<br/>    var state by <em class="lf">liveDataDelegate</em>(1)<br/>        private set</span><span id="0d94" class="ky kz iq kp b gy le lb l lc ld">fun updateState(newValue: Int) {<br/>        state = newValue.post()<br/>    }<br/>}</span></pre><h2 id="ae9b" class="ky kz iq bd lg lh li dn lj lk ll dp lm jy ln lo lp kc lq lr ls kg lt lu lv lw bi translated">结束语</h2><p id="2a7c" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">我不太相信到处都写<code class="fe km kn ko kp b">state = newValue.post()</code>比有一个支持字段更方便。然而，至少在我看来，这可能比实现一个<code class="fe km kn ko kp b">ViewModel</code>的接口要稍微方便一些。也许这一点我也错了。:-)我只是想提出解决这个问题的另一种方法。与此同时，就我个人而言，我很高兴使用backing field，但我很高兴有这个机会与代表们一起玩，作为解决这个问题的另一种方法，并在这个过程中学习一些新的东西。</p></div></div>    
</body>
</html>