<html>
<head>
<title>Laravel: Free 2FA for all your users</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Laravel:为所有用户提供免费的2FA</h1>
<blockquote>原文：<a href="https://itnext.io/laravel-free-two-factor-authentication-5a4be723dfa7?source=collection_archive---------2-----------------------#2020-02-10">https://itnext.io/laravel-free-two-factor-authentication-5a4be723dfa7?source=collection_archive---------2-----------------------#2020-02-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="196a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">“我要用21点和赌棍建一个我自己的主题公园”</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3896282da8374336cc2150cbc6a0b28f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2btRuYrhqO_snCeV"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">莫妮卡·索罗在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="c594" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">嗨！我来自未来。</p><p id="b4fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你应该使用<a class="ae ky" href="https://github.com/Laragear/TwoFactor" rel="noopener ugc nofollow" target="_blank"> Laragear双因子</a>。别担心，工作原理差不多，但是它积极支持和兼容新的Laravel版本。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="94e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">目前还没有很多针对PHP的双因素认证包。我发现大多数在两种产品之间有所不同:</p><ul class=""><li id="7ed1" class="md me it lb b lc ld lf lg li mf lm mg lq mh lu mi mj mk ml bi translated">给你所有的OTP工具，这样你就可以通过蛮力把它塞进你的应用程序。</li><li id="6224" class="md me it lb b lc mm lf mn li mo lm mp lq mq lu mi mj mk ml bi translated">把TOTP的逻辑推向任何免费或付费的东西，像<a class="ae ky" href="https://www.twilio.com/authy/pricing" rel="noopener ugc nofollow" target="_blank"> Twilio Authy </a>、<a class="ae ky" href="https://auth0.com/pricing/" rel="noopener ugc nofollow" target="_blank"> Auth0 </a>、<a class="ae ky" href="https://www.onelogin.com/product/pricing" rel="noopener ugc nofollow" target="_blank"> Onelogin </a>、<a class="ae ky" href="https://www.dashlane.com/business/pricing" rel="noopener ugc nofollow" target="_blank"> Dashlane </a>、<a class="ae ky" href="https://1password.com/business/" rel="noopener ugc nofollow" target="_blank"> 1password </a>、<a class="ae ky" href="https://firebase.google.com/docs/auth" rel="noopener ugc nofollow" target="_blank"> Firebase </a>，凡是你能想到的。</li></ul><p id="6dd8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我不反对这两种包装。一点也不。我觉得<a class="ae ky" href="https://github.com/Spomky-Labs/otphp" rel="noopener ugc nofollow" target="_blank"> Spomky Labs的OTP </a>挺全的，<a class="ae ky" href="https://github.com/antonioribeiro/google2fa#qr-code-packages" rel="noopener ugc nofollow" target="_blank"> Antonio Oribeiro的2FA-二维码</a>包里工具很多，但是我只需要一辆自行车，不需要后面全营的坦克。</p><p id="7bbc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想一想，你是在用时间支付<em class="mc">通过自己实现整个事情并将其紧密耦合到你的应用程序代码，或者用金钱支付<em class="mc">为了一个简单的实现并利用服务的逻辑，这也涵盖了“如果”( what if)场景和支持。</em></em></p><p id="57d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我的国家，作为一个穷人，那里的最低工资大约是2美元，从长远来看，为用户的登录付费是不在我的考虑范围之内的。将OTP的整个实现推成只使用两种方法也不是，因为我只需要TOTP，但是仍然有很多很酷的工具。</p><p id="bddd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Reddit 上询问是否有人知道Laravel的插件包，结果没有令人满意的回应后，我决定打开我的编辑器开始编码。而瓦拉，<strong class="lb iu">拉拉加德出生</strong>。</p><blockquote class="mr ms mt"><p id="3258" class="kz la mc lb b lc ld ju le lf lg jx lh mu lj lk ll mv ln lo lp mw lr ls lt lu im bi translated">你只是想要解决方案？<a class="ae ky" href="https://github.com/DarkGhostHunter/Laraguard" rel="noopener ugc nofollow" target="_blank">只要抓住包裹就完事了</a>。</p></blockquote><h1 id="c059" class="mx my it bd mz na nb nc nd ne nf ng nh jz ni ka nj kc nk kd nl kf nm kg nn no bi translated">我是怎么到那里的？这是什么地方？</h1><p id="fe37" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">让我们从基础开始，这样我们就在同一页上了。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/1af0d936f4dcb266fa262b50c77000ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1270/format:webp/1*grgaRsRAOqXBXfCrYqEpTw.png"/></div></figure><p id="2f70" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当另一个人知道某人的密码时，很容易登录并做他们想做的任何事情。为了避免这一点，双因素认证，也称为“2FA”，诞生了。</p><p id="f6a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2FA的概念很简单:用户必须使用另一个“设备”，如电话，确认他是证书的颁发者。如果您从等式中取出密码和设备，则无法进行身份验证。</p><p id="6673" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">许多2FA策略和实现中的一个被称为<a class="ae ky" href="https://en.wikipedia.org/wiki/Time-based_One-time_Password_algorithm" rel="noopener ugc nofollow" target="_blank"> TOTP </a>，即“基于时间的一次性密码”。正如你所读到的，二级密码是由一个只在给定时间段内有效的设备生成的，并且不能使用超过一次，以避免窃听和暴力攻击。</p><p id="8bae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">TOTP机制由三个关键部分组成:</p><ul class=""><li id="f73f" class="md me it lb b lc ld lf lg li mf lm mg lq mh lu mi mj mk ml bi translated">保存共享机密的存储。</li><li id="89ea" class="md me it lb b lc mm lf mn li mo lm mp lq mq lu mi mj mk ml bi translated">验证代码的逻辑。</li><li id="c161" class="md me it lb b lc mm lf mn li mo lm mp lq mq lu mi mj mk ml bi translated">记忆所用代码以避免再次使用的存储器。</li></ul><h2 id="e251" class="nv my it bd mz nw nx dn nd ny nz dp nh li oa ob nj lm oc od nl lq oe of nn og bi translated">添加中间步骤</h2><p id="9ae9" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">在Laravel中实现2FA的问题是认证被创建为仅<strong class="lb iu">一步</strong>。换句话说，一旦凭证被发送，没有办法在认证机制<em class="mc">中优雅地</em>调解:如果这些确实是正确的，用户将被认证，否则不会。句号。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/de6d8474c907d7cb12f966b4545281ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xu-gFPUJFXrmytDzbULldg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">不需要重新布线就能进入下一步？</figcaption></figure><p id="62c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，守卫的<code class="fe oi oj ok ol b">attempt()</code>方法负责在凭证有效时将用户持久化到应用程序中，仅在完全成功时返回<code class="fe oi oj ok ol b">true</code>,或者在失败时返回<code class="fe oi oj ok ol b">false</code>。</p><p id="78cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不过，有一些方法可以添加一个“中间”步骤。</p><p id="8372" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">添加双因素身份验证的最<em class="mc">方法是沿着您想要保护的所有路由插入一个中间件，如果用户使用2FA登录，则保存到会话或缓存中，或者向他询问正确的代码。对我来说，这就像每次你去洗手间的时候，夜总会的保镖都要你出示身份证一样。不用了，谢谢。</em></p><p id="6025" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一种方式，也可能是更合适的方式是处理登录尝试本身。第一种方法是向Guard添加一个宏或新方法，并编辑您的登录控制器，要求Guard在尝试登录用户之前检查2FA。听起来像是一个简单的方法，但是这意味着用一个方法调用来编辑登录控制器，这个方法调用是对<em class="mc">契约</em>之外的会话守卫(或者任何病房)的调用。你换了守卫，2FA就不管用了。</p><blockquote class="mr ms mt"><p id="4557" class="kz la mc lb b lc ld ju le lf lg jx lh mu lj lk ll mv ln lo lp mw lr ls lt lu im bi translated">如果在用户被验证之前，契约有一个回调函数来触发，那就太酷了。在不破坏认证的情况下，我所能做的最好的事情就是<a class="ae ky" href="https://github.com/laravel/framework/pull/31357" rel="noopener ugc nofollow" target="_blank">将经过验证的事件添加到框架中</a>。</p></blockquote><p id="1bb3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，想象一下我们必须做的恶作剧，仅仅是让一个宏检查用户的2FA。是的，因为这发生在任何尝试之前，所以我们总共需要检索用户两次:一次检查2FA，另一次正确验证其余的凭证。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/fa65617fc391e29eac01bb7c24207732.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lCJ2lezzAq9JF2kcx_GH1A.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">用火杀死它。</figcaption></figure><p id="e00e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个解决方案是扩展防护的<code class="fe oi oj ok ol b">attempt()</code>方法，不仅验证用户，还检查2FA。这允许只从用户提供者那里检索用户一次，但问题是我们不知道登录尝试失败的原因，因为我们只收到了<code class="fe oi oj ok ol b">true</code>或<code class="fe oi oj ok ol b">false</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/0fe9067f03d2b7e2c1afff64a0eb8854.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ocr1kTIuuyb61onU4JCBCQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">听起来很正常。提示:不是的。</figcaption></figure><p id="6477" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您想知道尝试失败的原因，您必须在Guard中创建另一个公共方法(在任何契约之外)来检查最后一次尝试失败的原因:如果是因为需要2FA而没有收到代码，则它收到了一个代码并且是错误的，或者其余的凭证是不正确的。</p><p id="e8f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我发现会话防护使用事件。你猜怎么着。</p><p id="3a09" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我用了事件。</p><h1 id="d554" class="mx my it bd mz na nb nc nd ne nf ng nh jz ni ka nj kc nk kd nl kf nm kg nn no bi translated">救援事件！</h1><p id="cae2" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">我的包所做的相对简单:注册一个监听器，该监听器连接到<code class="fe oi oj ok ol b">Validated</code>事件、<a class="ae ky" href="https://github.com/laravel/framework/blob/8cbe385362e6bbbd811c96e11336339da17221ac/src/Illuminate/Auth/SessionGuard.php#L376-L392" rel="noopener ugc nofollow" target="_blank">(已经在Laravel 6.15 </a>中引入)和<code class="fe oi oj ok ol b">Attempting</code>事件。</p><p id="69ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简而言之，一旦使用事件数据检索到用户，我们将确保在继续登录过程之前问他一个代码。我们可以使用侦听器通过强制抛出一个请求这个2FA代码的响应来停止身份验证。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/98b92b4ded2dec8ed0d0250cc94bc09c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HAeM5OaMBriUJKwmqprR3w.png"/></div></div></figure><p id="afcd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们将检查它是否也发布了他的2FA代码，以及继续操作是否正确，否则我们将把他踢出局，要求他提供正确的代码。</p><p id="f27d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就是这样。当然，你必须添加四行代码来实现预期的功能，但是这确实比重新连接整个登录控制器或者编辑保护本身要好。</p><p id="f518" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就这样吗？不，还有更多:</p><ul class=""><li id="93e7" class="md me it lb b lc ld lf lg li mf lm mg lq mh lu mi mj mk ml bi translated">与任何引发事件的守卫合作。</li><li id="05b4" class="md me it lb b lc mm lf mn li mo lm mp lq mq lu mi mj mk ml bi translated">没有中间件。没有控制器。没有路线。</li><li id="337f" class="md me it lb b lc mm lf mn li mo lm mp lq mq lu mi mj mk ml bi translated">带有恢复代码。</li><li id="0a5e" class="md me it lb b lc mm lf mn li mo lm mp lq mq lu mi mj mk ml bi translated">可以“记住”一个设备不要每次都询问2FA代码。</li><li id="8e36" class="md me it lb b lc mm lf mn li mo lm mp lq mq lu mi mj mk ml bi translated">开箱即用的URIs和二维码。</li><li id="8f07" class="md me it lb b lc mm lf mn li mo lm mp lq mq lu mi mj mk ml bi translated">没有讨厌的OTP逻辑，没有人会使用。</li></ul><p id="7f75" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">试一试，然后告诉我你的想法。</p><div class="oo op gp gr oq or"><a href="https://github.com/DarkGhostHunter/Laraguard" rel="noopener  ugc nofollow" target="_blank"><div class="os ab fo"><div class="ot ab ou cl cj ov"><h2 class="bd iu gy z fp ow fr fs ox fu fw is bi translated">黑暗幽灵/拉腊瓜德</h2><div class="oy l"><h3 class="bd b gy z fp ow fr fs ox fu fw dk translated">通过TOTP为您的所有用户提供开箱即用的双重身份认证。此软件包静默启用身份验证…</h3></div><div class="oz l"><p class="bd b dl z fp ow fr fs ox fu fw dk translated">github.com</p></div></div><div class="pa l"><div class="pb l pc pd pe pa pf ks or"/></div></div></a></div></div></div>    
</body>
</html>