<html>
<head>
<title>Prometheus configuration with custom alert labels for platform and application level alerts</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Prometheus配置，带有针对平台和应用级警报的定制警报标签</h1>
<blockquote>原文：<a href="https://itnext.io/prometheus-configuration-with-custom-alert-labels-for-platform-and-application-level-alerts-4a356ed2488d?source=collection_archive---------1-----------------------#2020-10-29">https://itnext.io/prometheus-configuration-with-custom-alert-labels-for-platform-and-application-level-alerts-4a356ed2488d?source=collection_archive---------1-----------------------#2020-10-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="ce34" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最近，我们(我和我的队友<a class="ae kl" href="https://de.linkedin.com/in/markus-bukowski-a0728851" rel="noopener ugc nofollow" target="_blank"> Markus </a>)与一位客户合作开发Kubernetes监控解决方案，我们必须满足以下要求:</p><ol class=""><li id="01b2" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk kr ks kt ku bi translated">部署<a class="ae kl" href="https://prometheus.io" rel="noopener ugc nofollow" target="_blank">普罗米修斯</a>带着简单的生命循环的想法。我所说的简单生命周期是指用最少的努力升级Prometheus实例，并有可重复的部署</li><li id="88d1" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">准备好一套初始警报规则，以满足基本的平台和应用监控需求</li><li id="2938" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">将警报转发给<a class="ae kl" href="https://www.ibm.com/support/knowledgecenter/SSSHTQ/landingpage/NetcoolOMNIbus.html" rel="noopener ugc nofollow" target="_blank"> IBM的Tivoli Netcool/OMNIbus </a>,并附上唯一标识警报来源的标签</li></ol><p id="5c6c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这篇文章中，我们将谈论我们如何想出一个设计来满足上述要求。我们不会在这篇文章中涉及普罗米修斯的基础知识，网上有足够的资源让你自己学习基础知识。</p><p id="e1f0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本文提到的所有文件都可以在<a class="ae kl" href="https://github.com/mcelep/blog/tree/master/prometheus-advanced" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><h2 id="ecf4" class="la lb iq bd lc ld le dn lf lg lh dp li jy lj lk ll kc lm ln lo kg lp lq lr ls bi translated">舵图:库贝-普罗米修斯-斯塔克</h2><p id="d1a0" class="pw-post-body-paragraph jn jo iq jp b jq lt js jt ju lu jw jx jy lv ka kb kc lw ke kf kg lx ki kj kk ij bi translated">为了满足前两个要求，可以使用<a class="ae kl" href="https://github.com/prometheus-community/helm-charts/tree/a3e6d68b12284f26d216250b57b2240cc9519224/charts/kube-prometheus-stack" rel="noopener ugc nofollow" target="_blank"> kube-prometheus-stack </a>。这张舵图以前被命名为<a class="ae kl" href="https://github.com/helm/charts/tree/b9278fa98cef543f5473eb55160eaf45833bc74e/stable/prometheus-operator" rel="noopener ugc nofollow" target="_blank">普罗米修斯-操作员</a>。你可以在这里找到kube-prometheus的细节(包括prometheus操作符，以及其他有用的位)<a class="ae kl" href="https://github.com/prometheus-operator/kube-prometheus" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="5423" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://helm.sh/docs/topics/charts/" rel="noopener ugc nofollow" target="_blank"> Helm charts </a>是目前在Kubernetes上部署软件最常见的方式之一，拥有一个软件的<a class="ae kl" href="https://kubernetes.io/docs/concepts/extend-kubernetes/operator" rel="noopener ugc nofollow" target="_blank">操作员</a>对于升级软件版本、备份/恢复和许多其他通常由软件管理员在第2天手动触发的操作也很方便。</p><h2 id="8171" class="la lb iq bd lc ld le dn lf lg lh dp li jy lj lk ll kc lm ln lo kg lp lq lr ls bi translated">普罗米修斯规则:)</h2><p id="7aae" class="pw-post-body-paragraph jn jo iq jp b jq lt js jt ju lu jw jx jy lv ka kb kc lw ke kf kg lx ki kj kk ij bi translated">kube-Prometheus-stackhelm chart附带的另一个有趣的东西是一组规则，涵盖了Kubernetes平台的大多数常见需求。这里列出了规则<a class="ae kl" href="https://github.com/prometheus-community/helm-charts/tree/a3e6d68b12284f26d216250b57b2240cc9519224/charts/kube-prometheus-stack/templates/prometheus/rules-1.14" rel="noopener ugc nofollow" target="_blank"/>和普罗米修斯规则，它们被简单地包装在一个<a class="ae kl" href="https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/" rel="noopener ugc nofollow" target="_blank">自定义资源</a>中，其类型如下:</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="4d5a" class="la lb iq md b gy mh mi l mj mk">apiVersion: monitoring.coreos.com/v1 <br/>kind: PrometheusRule</span></pre><p id="f840" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">人们应该记住，尽管这些规则从一开始就很好，但通常负责管理K8S平台的团队很可能会决定调整这些规则，添加新的规则，随着时间的推移，在他们认为合适的时候删除一些规则。</p><p id="5156" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此处<a class="ae kl" href="https://github.com/prometheus-community/helm-charts/tree/a3e6d68b12284f26d216250b57b2240cc9519224/charts/kube-prometheus-stack/templates/prometheus/rules-1.14" rel="noopener ugc nofollow" target="_blank">列出的规则</a>涵盖了警报的两个主题。大多数规则都是为了监控Kubernetes平台本身，应该由平台的操作者来负责。但是，也有一些关于K8s上运行的工作负载的规则，例如<a class="ae kl" href="https://github.com/prometheus-community/helm-charts/blob/a3e6d68b12284f26d216250b57b2240cc9519224/charts/kube-prometheus-stack/templates/prometheus/rules-1.14/kubernetes-apps.yaml" rel="noopener ugc nofollow" target="_blank"> kubernetes-apps.yaml </a>。由平台事件触发的警报应该以不同于工作负载警报的方式发送，这就是为什么我们需要区分平台/系统和工作负载。换句话说，根据普罗米修斯规则，应该提醒不同的个人/团队。在本文的其余部分，我们将详细介绍Prometheus是如何配置的，以便始终包含一个带有正确值的自定义标签，即平台ID或工作负载ID。</p><h2 id="db15" class="la lb iq bd lc ld le dn lf lg lh dp li jy lj lk ll kc lm ln lo kg lp lq lr ls bi translated">解决方案设计</h2><p id="d607" class="pw-post-body-paragraph jn jo iq jp b jq lt js jt ju lu jw jx jy lv ka kb kc lw ke kf kg lx ki kj kk ij bi translated">下图展示了整体系统设计:</p><p id="2cb7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">总体目标是区分平台级警报和源自集群上运行的工作负载的警报，即应用程序警报。负责操作K8S集群的团队通常不同于在这些集群上运行工作负载的团队。因此，为了确保警报可以被路由到正确的团队，我们需要一些标识符，可以在Tivoli Netcool/OMNIbus端使用，以进行正确的路由调用。我们不会详细讨论如何配置Tivoli Netcool/OMNIbus来将警报发送给不同的团队。</p><p id="f384" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于Tivoli Netcool/OMNIbus可以接收http调用，我们将使用webhooks从<a class="ae kl" href="https://prometheus.io/docs/alerting/latest/alertmanager/" rel="noopener ugc nofollow" target="_blank"> Prometheus/Alertmanager </a>向Tivoli Netcool/OMNIbus发送警报。在Tivoli端进行正确的路由所需要的唯一东西是一个标签，我们将把它作为警报数据的一部分发送出去。该标签的键被确定为example.com/ci_monitoring的<strong class="jp ir"/>。</p><h2 id="442c" class="la lb iq bd lc ld le dn lf lg lh dp li jy lj lk ll kc lm ln lo kg lp lq lr ls bi translated">规则配置</h2><p id="e9e5" class="pw-post-body-paragraph jn jo iq jp b jq lt js jt ju lu jw jx jy lv ka kb kc lw ke kf kg lx ki kj kk ij bi translated"><a class="ae kl" href="./prometheus-operator/values.yml.j2" rel="noopener ugc nofollow" target="_blank">这个文件</a>包括我们为Prometheus操作员部署设计的定制配置。这是一个jinja模板文件，原因是我们根据目标K8S集群替换了模板中的某些值，如集群名称、容器映像注册表主机名、警报发送目的地(电子邮件、webhook)。所有的舵图表都有一个默认的<em class="ml"> values.yml </em>文件，我们的jinja模板是基于<a class="ae kl" href="https://github.com/prometheus-community/helm-charts/blob/a3e6d68b12284f26d216250b57b2240cc9519224/charts/kube-prometheus-stack/values.yaml" rel="noopener ugc nofollow" target="_blank">这个文件</a>。</p><p id="0e19" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Prometheus operator附带了一组[默认启用]的警报规则(https://github . com/Prometheus-community/helm-charts/blob/564086 af 6157 D2 da 6a 9 a5 f 086010 f1 CB 3a 93 babd/charts/kube-Prometheus-stack/values . YAML # L30)并且由于我们需要覆盖<a class="ae kl" href="https://github.com/prometheus-community/helm-charts/blob/a3e6d68b12284f26d216250b57b2240cc9519224/charts/kube-prometheus-stack/templates/prometheus/rules-1.14/kubernetes-apps.yaml" rel="noopener ugc nofollow" target="_blank">kuberneteapps规则</a>，所以在values文件中包含了以下部分以禁止创建<strong class="jp ir">kuberneteapps</strong></p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="8aac" class="la lb iq md b gy mh mi l mj mk">defaultRules:<br/>  create: true<br/>  rules:<br/>    kubernetesApps: false</span></pre><p id="9fd9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">之后，我们开始添加我们自己版本的<em class="ml"> kubernetesApps </em>规则，下面是一个示例摘录:</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="b7f0" class="la lb iq md b gy mh mi l mj mk">## Provide custom recording or alerting rules to be deployed into the cluster.<br/>additionalPrometheusRules:<br/>  - name: kubernetes-apps<br/>    groups:<br/>      - name: kubernetes-apps<br/>        rules:<br/>        - alert: KubePodCrashLooping-System<br/>          annotations:<br/>            message: Pod {{ $labels.namespace }}/{{ $labels.pod }} ({{ $labels.container<br/>              }}) is restarting {{ printf "%.2f" $value }} times / 5 minutes.<br/>            runbook_url: https://github.com/kubernetes-monitoring/kubernetes-mixin/tree/master/runbook.md#alert-name-kubepodcrashlooping<br/>          expr: rate(kube_pod_container_status_restarts_total{job="kube-state-metrics",<br/>            namespace=~"[% system_namespaces_regex %]"}[15m]) * 60 * 5 &gt; 0<br/>          for: 15m<br/>          labels:<br/>            severity: critical<br/>            label_example_com_ci_monitoring: [% ci_cluster_id %]<br/>        - alert: KubePodCrashLooping<br/>          annotations:<br/>            message: Pod {{ $labels.namespace }}/{{ $labels.pod }} ({{ $labels.container<br/>              }}) is restarting {{ printf "%.2f" $value }} times / 5 minutes.<br/>            runbook_url: https://github.com/kubernetes-monitoring/kubernetes-mixin/tree/master/runbook.md#alert-name-kubepodcrashlooping<br/>          expr: rate(kube_pod_container_status_restarts_total{job="kube-state-metrics",<br/>            namespace!~"[% system_namespaces_regex %]"}[15m]) * 60 * 5 &gt; 0<br/>          for: 15m<br/>          labels:<br/>            severity: critical</span></pre><p id="63cf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">规则基于最初的<a class="ae kl" href="https://github.com/helm/charts/blob/b9278fa98cef543f5473eb55160eaf45833bc74e/stable/prometheus-operator/templates/prometheus/rules-1.14/kubernetes-apps.yaml" rel="noopener ugc nofollow" target="_blank"> kubernetes-apps.yaml </a>，我们为每个规则添加了两个版本。一个用于应用程序命名空间，一个用于系统命名空间。为了控制什么是系统名称空间，我们使用了一个jinja占位符:<code class="fe mm mn mo md b">[% system_namespaces_regex %]</code>，我们为这个占位符使用的值是:<code class="fe mm mn mo md b">default|kube-system|pks-system|monitoring</code>。(有关所有被覆盖的值，请参见“vars/test.yaml”下的文件)</p><p id="9bfd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们为从AlertManager发送到Tivoli端的Prometheus警报添加标签，并确保与应用程序相关的警报查询总是包含该标签。在我们的配置中，这个标签叫做<em class="ml">label _ example _ com _ ci _ monitoring</em>。</p><p id="74ef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于与系统相关的警报，我们包括一个标签来表示集群ID，它同样由jinja占位符<code class="fe mm mn mo md b">[% ci_cluster_id %]</code>控制。以下是相关部分:</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="0d06" class="la lb iq md b gy mh mi l mj mk">- alert: KubePodCrashLooping-System<br/>          annotations:<br/>            message: Pod {{ $labels.namespace }}/{{ $labels.pod }} ({{ $labels.container<br/>              }}) is restarting {{ printf "%.2f" $value }} times / 5 minutes.<br/>            runbook_url: https://github.com/kubernetes-monitoring/kubernetes-mixin/tree/master/runbook.md#alert-name-kubepodcrashlooping<br/>          expr: rate(kube_pod_container_status_restarts_total{job="kube-state-metrics",<br/>            namespace=~"[% system_namespaces_regex %]"}[15m]) * 60 * 5 &gt; 0<br/>          for: 15m<br/>          labels:<br/>            severity: critical<br/>            label_example_com_ci_monitoring: [% ci_cluster_id %]</span></pre><p id="5b0e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于工作负载警报，我们有一种基于集群和名称空间动态自动填充<em class="ml">label _ example _ com _ ci _ monitoring</em>的机制。此外，如果在带有关键字<em class="ml">label _ example _ com _ ci _ monitoring</em>的指标上有一个现有的标签，它将保持原样。在下一节中，我们将解释这种机制是如何工作的。</p><h2 id="cf87" class="la lb iq bd lc ld le dn lf lg lh dp li jy lj lk ll kc lm ln lo kg lp lq lr ls bi translated">附加警报重新标记</h2><p id="64f1" class="pw-post-body-paragraph jn jo iq jp b jq lt js jt ju lu jw jx jy lv ka kb kc lw ke kf kg lx ki kj kk ij bi translated">在helm values文件中，在路径为<em class="ml">prometheus . Prometheus spec . external labels</em>的部分中，我们引入了一些额外的警报重新标记，以便在由该Prometheus实例触发的每个警报上添加一些额外的标签。我们认为K8S集群ID，由jinja占位符(<code class="fe mm mn mo md b">[% ci_cluster_id %]</code>)控制，在将来可以带来很多好处来表示警报的来源。该标签的关键字设置为<em class="ml">label _ example _ com _ ci _ cluster</em>，不与<em class="ml">label _ example _ com _ ci _ monitoring</em>混淆。此标签的目的是始终显示源K8S平台，无论它是系统还是命名空间/工作负载警报。相关配置如下所示:</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="5b5a" class="la lb iq md b gy mh mi l mj mk">prometheusSpec:<br/>    logLevel: info<br/>    externalLabels:<br/>      label_example_com_ci_cluster: [% ci_cluster_id %]</span></pre><p id="1d91" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">path下的以下部分:<em class="ml">Prometheus . Prometheus spec . additionalalertrelabelconfigs</em>控制我们如何控制从AlertManager发出的警报的<a class="ae kl" href="https://prometheus.io/docs/prometheus/latest/configuration/configuration/#alert_relabel_configs" rel="noopener ugc nofollow" target="_blank">重新标记</a>:</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="f2de" class="la lb iq md b gy mh mi l mj mk">additionalAlertRelabelConfigs:<br/>    - source_labels:<br/>        - label_example_com_ci_cluster<br/>      action: replace<br/>      regex: (.*)<br/>      replacement: "[% ci_cluster_id %]"<br/>      target_label: __tmp_monitoring<br/>    - source_labels:<br/>       - namespace<br/>      regex: (.+)<br/>      replacement: "NS-${1}-[% ci_cluster_id %]"<br/>      target_label: __tmp_monitoring<br/>      action: replace<br/>    - source_labels:<br/>        - label_example_com_ci_monitoring<br/>      action: replace<br/>      regex: (.+)<br/>      target_label: __tmp_monitoring<br/>    - source_labels:<br/>        - __tmp_monitoring<br/>      action: replace<br/>      regex: (.*)<br/>      replacement: "$1"<br/>      target_label: label_example_com_ci_monitoring</span></pre><p id="537f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Prometheus重新标记规则的处理顺序与它们在yaml文档中的顺序相同，这使我们能够:</p><ol class=""><li id="ede6" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk kr ks kt ku bi translated">用来自<code class="fe mm mn mo md b">label_example_com_ci_cluster</code>的值填充名为<em class="ml"> __tmp_monitoring </em>的临时变量。</li><li id="76c8" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">如果有一个带关键字<code class="fe mm mn mo md b">namespace</code>的标签，我们取它的值并用它来创建我们自己的表达式<code class="fe mm mn mo md b">"NS-${1}-[% ci_cluster_id %]"</code>。这里的<code class="fe mm mn mo md b">${1}</code>部分捕获名称空间值，第二部分<code class="fe mm mn mo md b">[% ci_cluster_id %]</code>是我们的jinja占位符。</li><li id="c933" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">如果存在名为<em class="ml">label _ example _ com _ ci _ monitoring</em>的现有标签，则将该标签的值放入现有变量:<em class="ml"> __tmp_monitoring </em></li><li id="296a" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">最后，用临时标签值替换标签<em class="ml">标签_示例_ com _ ci _监控</em>。</li></ol><p id="160b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">换句话说，在上面的配置中，我们总是应用一个带有关键字的标签:<em class="ml">label _ example _ com _ ci _ monitoring</em>，这个关键字的值要么是关键字<em class="ml">label _ example _ com _ ci _ monitoring</em>的原始值，如果它存在，如果该标签不存在，我们使用一个模式基于名称空间和集群生成一个值:<code class="fe mm mn mo md b">NS-${1}-[% ci_cluster_id %]</code>如果有一个标签将<em class="ml">名称空间</em>作为其关键字。如果没有带有关键字:<em class="ml">名称空间</em>的标签，那么我们回退到<em class="ml"> ci_cluster_id </em>。</p><p id="80df" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这种情况下，最好提醒您，将数据从Kubernetes抓取到Prometheus时会发生一个转换过程。在这个转换过程中，像<strong class="jp ir">example.com/ci_monitoring</strong>这样的关键字会在Prometheus中被翻译成一个名为<em class="ml">label _ example _ com _ ci _ monitoring</em>的标签。</p><h2 id="efd9" class="la lb iq bd lc ld le dn lf lg lh dp li jy lj lk ll kc lm ln lo kg lp lq lr ls bi translated">持续</h2><p id="1569" class="pw-post-body-paragraph jn jo iq jp b jq lt js jt ju lu jw jx jy lv ka kb kc lw ke kf kg lx ki kj kk ij bi translated">默认情况下，Prometheus操作员舵图带有禁用的永久卷。为了启用和配置持久卷，使用了以下部分:</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="3888" class="la lb iq md b gy mh mi l mj mk">volumeClaimTemplate:<br/>        spec:<br/>          accessModes: ["ReadWriteOnce"]<br/>          resources:<br/>            requests:<br/>              storage: 50Gi</span></pre><p id="294f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此部分可在路径:<em class="ml">Prometheus . prometheusspec . storage spec</em>下找到。我们尚未指定存储类，并假设为群集配置了默认的存储类。或者，在<em class="ml">规范</em>部分，您可以指定一个存储类，如下所示:</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="94a6" class="la lb iq md b gy mh mi l mj mk">volumeClaimTemplate:<br/>        spec:<br/>          accessModes: ["ReadWriteOnce"]<br/>          storageClassName: XYZ<br/>          resources:<br/>            requests:<br/>              storage: 50Gi</span></pre><h2 id="84f8" class="la lb iq bd lc ld le dn lf lg lh dp li jy lj lk ll kc lm ln lo kg lp lq lr ls bi translated">警报管理器配置</h2><p id="9f9c" class="pw-post-body-paragraph jn jo iq jp b jq lt js jt ju lu jw jx jy lv ka kb kc lw ke kf kg lx ki kj kk ij bi translated">以下节选显示了如何配置Prometheus Alertmanager 转发警报:</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="cf0b" class="la lb iq md b gy mh mi l mj mk">alertmanager:<br/>  enabled: true<br/><br/>  config:<br/>    global: {}<br/>    receivers:<br/>    - name: default-receiver<br/>      webhook_configs:<br/>      - url: "[% alertmanager_webhook_url %]"<br/>        send_resolved: true<br/>      email_configs:<br/>      - send_resolved: true<br/>        to: [% alertmanager_smtp_to %]<br/>        from: [% alertmanager_smtp_from %]<br/>        smarthost: [% alertmanager_smtp_host %]<br/>        require_tls: false<br/>    - name: 'null'<br/>    route:<br/>      group_by: ['job']<br/>      group_wait: 30s<br/>      group_interval: 5m<br/>      repeat_interval: 24h<br/>      receiver: default-receiver</span></pre><p id="e63a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上一节中总共配置了2个接收器。第一个叫做<em class="ml">默认接收者</em>，这个有<strong class="jp ir"> web_hook </strong>和<strong class="jp ir"> email </strong>动作，当一个警报被触发时。Webhook集成允许您向任何支持http的端点发送警报，比如IBM Tivoli Netcool/OMNIbus。有关配置webhook监听器的详细信息，请参见此处的<a class="ae kl" href="https://prometheus.io/docs/alerting/latest/configuration/#webhook_config" rel="noopener ugc nofollow" target="_blank">和</a>。在<em class="ml">默认接收者</em>部分，电子邮件是任何点的第二个接收者，如果您可以访问使用smtp协议的电子邮件服务器，这可以是一种快速的测试方式。在测试过程中，如果您想避免向第三方发送警报，您可以使用<code class="fe mm mn mo md b">null</code>接收器。</p><h2 id="69df" class="la lb iq bd lc ld le dn lf lg lh dp li jy lj lk ll kc lm ln lo kg lp lq lr ls bi translated">死亡开关</h2><p id="ad31" class="pw-post-body-paragraph jn jo iq jp b jq lt js jt ju lu jw jx jy lv ka kb kc lw ke kf kg lx ki kj kk ij bi translated">如果prometheus部署在您想要观察的K8S平台上，您可能收不到任何警报，因为如果平台运行不正常或根本不运行，Prometheus可能无法运行。为了解决这个问题，一种常见的模式是让Prometheus定期向在不同故障域中运行的另一个监控平台发送警报(<em class="ml">心跳</em>，因为它在其他一些域中被引用)。这种模式通常被称为‘安全开关’,它由<a class="ae kl" href="https://github.com/prometheus-community/helm-charts/blob/b643f58714a063e5a0ddf6832cd00ed29c0f4fab/charts/kube-prometheus-stack/templates/prometheus/rules-1.14/general.rules.yaml" rel="noopener ugc nofollow" target="_blank">一般规则yaml </a>中的以下部分控制:</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="ad1a" class="la lb iq md b gy mh mi l mj mk">- alert: Watchdog<br/>      annotations:<br/>        message: 'This is an alert meant to ensure that the entire alerting pipeline is functional.<br/>          This alert is always firing, therefore it should always be firing in Alertmanager<br/>          and always fire against a receiver. There are integrations with various notification<br/>          mechanisms that send a notification when this alert is not firing. For example the<br/>          "DeadMansSnitch" integration in PagerDuty.<br/>          '<br/>      expr: vector(1)<br/>      labels:<br/>        severity: none</span></pre><h2 id="8eec" class="la lb iq bd lc ld le dn lf lg lh dp li jy lj lk ll kc lm ln lo kg lp lq lr ls bi translated">行动解决方案</h2><h2 id="b9c6" class="la lb iq bd lc ld le dn lf lg lh dp li jy lj lk ll kc lm ln lo kg lp lq lr ls bi translated">所需工具</h2><ul class=""><li id="9555" class="km kn iq jp b jq lt ju lu jy mp kc mq kg mr kk ms ks kt ku bi translated">Kubernetes CLI</li><li id="5c5e" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk ms ks kt ku bi translated">舵&gt; = 3.2</li><li id="f860" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk ms ks kt ku bi translated">可译剧本</li><li id="7fd6" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk ms ks kt ku bi translated">K8S星团</li></ul><h2 id="5aa4" class="la lb iq bd lc ld le dn lf lg lh dp li jy lj lk ll kc lm ln lo kg lp lq lr ls bi translated">安装Nginx入口控制器</h2><p id="f95b" class="pw-post-body-paragraph jn jo iq jp b jq lt js jt ju lu jw jx jy lv ka kb kc lw ke kf kg lx ki kj kk ij bi translated">运行以下命令安装nginx-ingress:</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="3fa3" class="la lb iq md b gy mh mi l mj mk">ansible-playbook -v playbooks/nginx-ingress.yml -i inventory-local.yaml --extra-vars @vars/test.yml</span></pre><p id="17c6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个剧本将与您执行<code class="fe mm mn mo md b">ansible-playbook</code>二进制文件的本地主机对话，它将:</p><ul class=""><li id="c2df" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk ms ks kt ku bi translated">添加必要的舵repos</li><li id="0a3b" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk ms ks kt ku bi translated">更新舵repos</li><li id="1c2a" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk ms ks kt ku bi translated">安装Nginx入口控制器，我们稍后将在Prometheus安装中使用。</li></ul><h2 id="054d" class="la lb iq bd lc ld le dn lf lg lh dp li jy lj lk ll kc lm ln lo kg lp lq lr ls bi translated">安装普罗米修斯</h2><p id="cc4b" class="pw-post-body-paragraph jn jo iq jp b jq lt js jt ju lu jw jx jy lv ka kb kc lw ke kf kg lx ki kj kk ij bi translated">运行以下命令安装并配置Prometheus及其依赖项:</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="0409" class="la lb iq md b gy mh mi l mj mk">ansible-playbook -v playbooks/prometheus-operator.yml -i inventory-local.yaml --extra-vars @vars/test.yml</span></pre><h2 id="8d47" class="la lb iq bd lc ld le dn lf lg lh dp li jy lj lk ll kc lm ln lo kg lp lq lr ls bi translated">创建webhook列表器</h2><p id="5c4a" class="pw-post-body-paragraph jn jo iq jp b jq lt js jt ju lu jw jx jy lv ka kb kc lw ke kf kg lx ki kj kk ij bi translated">在本节中，我们将运行一个简单的webhook侦听器，它将接收到的http调用的详细信息(包括有效负载)打印到stdout上。以下命令将运行包含webhook侦听器程序的映像。</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="fe83" class="la lb iq md b gy mh mi l mj mk">kubectl -n monitoring create deployment webhook --image=mcelep/python-webhook-listener<br/>kubectl expose deployment/webhook --port 8080</span></pre><h2 id="1aba" class="la lb iq bd lc ld le dn lf lg lh dp li jy lj lk ll kc lm ln lo kg lp lq lr ls bi translated">创建测试应用程序</h2><p id="ecef" class="pw-post-body-paragraph jn jo iq jp b jq lt js jt ju lu jw jx jy lv ka kb kc lw ke kf kg lx ki kj kk ij bi translated">运行以下命令创建一个名为<em class="ml"> test </em>的名称空间，并创建一个名为<em class="ml"> test </em>的部署</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="6591" class="la lb iq md b gy mh mi l mj mk">kubectl create ns test<br/>kubectl -n test create deployment test --image=no-such-image</span></pre><p id="268b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">很快您应该会有一些处于挂起状态的警报，并且在配置的时间量之后(对于<em class="ml"> KubePodNotReady </em>，在<em class="ml"> values.yml.j2 </em>文件中设置为15分钟)应该会有带有正确标签的警报触发。</p><p id="3aa2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我们检查webhook侦听器容器的日志时，我们看到收到了以下数据:</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="9211" class="la lb iq md b gy mh mi l mj mk">{<br/>  "status": "firing",<br/>  "labels": {<br/>    "__tmp_monitoring": "NS-test-CL-XYZ",<br/>    "alertname": "KubePodNotReady",<br/>    "label_example_com_ci_cluster": "CL-XYZ",<br/>    "label_example_com_ci_monitoring": "NS-test-CL-XYZ",<br/>    "namespace": "test",<br/>    "pod": "test-7c8844b6fb-kbj8l",<br/>    "prometheus": "monitoring/platform-kube-prometheus-s-prometheus",<br/>    "severity": "critical"<br/>  },<br/>  "annotations": {<br/>    "message": "Pod test/test-7c8844b6fb-kbj8l has been in a non-ready state for longer than 15 minutes.",<br/>    "runbook_url": "https://github.com/kubernetes-monitoring/kubernetes-mixin/tree/master/runbook.md#alert-name-kubepodnotready"<br/>  },<br/>  "startsAt": "2020-10-29T10:49:18.473Z",<br/>  "endsAt": "0001-01-01T00:00:00Z",<br/>  "generatorURL": "http://prometheus.monitoring.k8s.example.com/graph?g0.expr=sum+by%28namespace%2C+pod%2C+label_example_com_ci_monitoring%29+%28max+by%28namespace%2C+pod%2C+label_example_com_ci_monitoring%29+%28kube_pod_status_phase%7Bjob%3D%22kube-state-metrics%22%2Cnamespace%21~%22default%7Ckube-system%7Cpks-system%7Cmonitoring%22%2Cphase%3D~%22Pending%7CUnknown%22%7D%29+%2A+on%28namespace%2C+pod%29+group_left%28owner_kind%29+max+by%28namespace%2C+pod%2C+owner_kind%2C+label_example_com_ci_monitoring%29+%28kube_pod_owner%7Bowner_kind%21%3D%22Job%22%7D%29%29+%3E+0\\u0026g0.tab=1",<br/>  "fingerprint": "0b23d99b9740b21e"<br/>}</span></pre><p id="f678" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">名称空间<em class="ml">测试</em>，没有带关键字<strong class="jp ir">example.com/ci_monitoring</strong>的标签，因此标签<em class="ml">label _ example _ com _ ci _ monitoring</em>是基于我们的重新标记配置自动生成的，因此得到了集群id和名称空间的组合值。就是这样！我们的端到端解决方案正在发挥作用。</p></div></div>    
</body>
</html>