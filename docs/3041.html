<html>
<head>
<title>How to run stateful Kafka Streams applications on Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Kubernetes上运行有状态的Kafka流应用程序</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-use-kubernetes-to-deploy-stateful-kafka-streams-applications-872c77f03c3a?source=collection_archive---------1-----------------------#2019-09-20">https://itnext.io/how-to-use-kubernetes-to-deploy-stateful-kafka-streams-applications-872c77f03c3a?source=collection_archive---------1-----------------------#2019-09-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b6f3" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">了解运行有状态Kafka流应用程序所需的Kubernetes原语</h2></div><p id="dde0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是一个由三部分组成的博客系列，涵盖了Kafka Streams在Kubernetes上的应用</p><ul class=""><li id="d69f" class="lb lc iq kh b ki kj kl km ko ld ks le kw lf la lg lh li lj bi translated">第1部分— <a class="ae lk" rel="noopener ugc nofollow" target="_blank" href="/learn-how-to-develop-a-kafka-streams-application-for-data-processing-and-deploy-it-to-kubernetes-231d4cbb0688">如何在Kubernetes上运行Kafka Streams应用程序</a></li><li id="6e1b" class="lb lc iq kh b ki ll kl lm ko ln ks lo kw lp la lg lh li lj bi translated">第二部分——这个博客</li><li id="3569" class="lb lc iq kh b ki ll kl lm ko ln ks lo kw lp la lg lh li lj bi translated">第3部分— <a class="ae lk" rel="noopener ugc nofollow" target="_blank" href="/health-checks-for-kafka-streams-application-on-kubernetes-e9c5e8c21b0d">对Kubernetes上的Kafka Streams应用程序进行健康检查</a></li></ul></div><div class="ab cl lq lr hu ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ij ik il im in"><p id="d282" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">很高兴通过<a class="ae lk" href="https://twitter.com/abhi_tweeter" rel="noopener ugc nofollow" target="_blank"> @abhi_tweeter </a>获得反馈或发表评论！</p><p id="03af" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">之前的<a class="ae lk" href="https://medium.com/@abhishek1987/learn-how-to-develop-a-kafka-streams-application-for-data-processing-and-deploy-it-to-kubernetes-231d4cbb0688" rel="noopener">博客</a>中有一篇是关于使用<a class="ae lk" href="https://kafka.apache.org/documentation/streams/" rel="noopener ugc nofollow" target="_blank"> Kafka Streams </a>库构建一个<strong class="kh ir">无状态</strong>流处理应用程序，并以<code class="fe lx ly lz ma b">Deployment</code>对象的形式将其部署到Kubernetes。</p><div class="mb mc gp gr md me"><a href="https://medium.com/@abhishek1987/learn-how-to-develop-a-kafka-streams-application-for-data-processing-and-deploy-it-to-kubernetes-231d4cbb0688" rel="noopener follow" target="_blank"><div class="mf ab fo"><div class="mg ab mh cl cj mi"><h2 class="bd ir gy z fp mj fr fs mk fu fw ip bi translated">了解如何开发用于数据处理的Kafka Streams应用程序并将其部署到Kubernetes</h2><div class="ml l"><h3 class="bd b gy z fp mj fr fs mk fu fw dk translated">本教程将指导您如何使用Kafka流构建一个无状态流处理应用程序…</h3></div><div class="mm l"><p class="bd b dl z fp mj fr fs mk fu fw dk translated">medium.com</p></div></div><div class="mn l"><div class="mo l mp mq mr mn ms mt me"/></div></div></a></div><p id="0890" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这一部分，我们将继续探索卡夫卡溪流和库伯内特斯的有力结合。但是这篇文章是关于有状态的应用程序，以及如何利用特定的Kubernetes原语，使用Azure上的Kubernetes集群来运行它。</p><blockquote class="mu mv mw"><p id="d5a4" class="kf kg mx kh b ki kj jr kk kl km ju kn my kp kq kr mz kt ku kv na kx ky kz la ij bi translated">我马上承认这是一篇略显冗长的博客，但是有很多东西要涵盖和学习！</p></blockquote><p id="bbb9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当您完成此操作时，您将了解以下内容:</p><p id="f415" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="mx">卡夫卡溪流</em></p><ul class=""><li id="988c" class="lb lc iq kh b ki kj kl km ko ld ks le kw lf la lg lh li lj bi translated">什么是卡夫卡溪流？</li><li id="4a8d" class="lb lc iq kh b ki ll kl lm ko ln ks lo kw lp la lg lh li lj bi translated">有状态Kafka流应用程序的概念</li></ul><p id="b67c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="mx">幕后</em></p><ul class=""><li id="9821" class="lb lc iq kh b ki kj kl km ko ld ks le kw lf la lg lh li lj bi translated">使用Kafka流的流处理逻辑的Java代码中发生了什么</li><li id="83fa" class="lb lc iq kh b ki ll kl lm ko ln ks lo kw lp la lg lh li lj bi translated">Kubernetes组件，用于运行有状态的Kafka流应用程序，如<code class="fe lx ly lz ma b">StatefulSet</code>、批量声明模板和其他配置参数，如<code class="fe lx ly lz ma b">Pod</code>反亲缘关系</li><li id="84b4" class="lb lc iq kh b ki ll kl lm ko ln ks lo kw lp la lg lh li lj bi translated">使用<a class="ae lk" href="https://docs.microsoft.com/azure/aks/?WT.mc_id=medium-blog-abhishgu" rel="noopener ugc nofollow" target="_blank"> Azure Kubernetes服务</a>进行容器编排，使用<a class="ae lk" href="https://docs.microsoft.com/azure/virtual-machines/windows/managed-disks-overview?WT.mc_id=medium-blog-abhishgu" rel="noopener ugc nofollow" target="_blank"> Azure磁盘</a>进行持久性存储，这一切是如何设置的</li></ul><p id="2bc8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="mx">如何设置和配置一个</em> <a class="ae lk" href="https://docs.microsoft.com/azure/container-registry/?WT.mc_id=medium-blog-abhishgu" rel="noopener ugc nofollow" target="_blank"> <em class="mx"> Docker容器注册表</em> </a> <em class="mx">和Azure Kubernetes集群</em></p><p id="2bb4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="mx">如何构建&amp;将我们的应用部署到Kubernetes，最后使用Kafka CLI进行测试</em></p><blockquote class="mu mv mw"><p id="133c" class="kf kg mx kh b ki kj jr kk kl km ju kn my kp kq kr mz kt ku kv na kx ky kz la ij bi translated"><em class="iq">源代码是GitHub </em> 上的 <a class="ae lk" href="https://github.com/abhirockzz/kafka-streams-stateful-kubernetes" rel="noopener ugc nofollow" target="_blank"> <em class="iq"/></a></p></blockquote><p id="e537" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们开始吧！</p><figure class="nc nd ne nf gt ng gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/5a8aaf20f25215d9d27c24d91df4f8fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/0*YITHD84f9YYGT-j_.gif"/></div></figure><h1 id="fe56" class="ni nj iq bd nk nl nm nn no np nq nr ns jw nt jx nu jz nv ka nw kc nx kd ny nz bi translated">先决条件:</h1><p id="d3a6" class="pw-post-body-paragraph kf kg iq kh b ki oa jr kk kl ob ju kn ko oc kq kr ks od ku kv kw oe ky kz la ij bi translated">如果你还没有，请<a class="ae lk" href="https://docs.microsoft.com/cli/azure/install-azure-cli?view=azure-cli-latest&amp;WT.mc_id=medium-blog-abhishgu" rel="noopener ugc nofollow" target="_blank">安装Azure CLI </a>和<a class="ae lk" href="https://kubernetes.io/docs/tasks/tools/install-kubectl/" rel="noopener ugc nofollow" target="_blank"> kubectl </a>。流处理app用Java写，用<a class="ae lk" href="https://maven.apache.org/install.html" rel="noopener ugc nofollow" target="_blank"> Maven </a>。您还需要<a class="ae lk" href="https://docs.docker.com/install/" rel="noopener ugc nofollow" target="_blank"> Docker </a>来构建应用程序容器映像。</p><blockquote class="mu mv mw"><p id="082f" class="kf kg mx kh b ki kj jr kk kl km ju kn my kp kq kr mz kt ku kv na kx ky kz la ij bi translated"><em class="iq">本教程假设您有一个Kafka集群，可以从Azure上的Kubernetes集群访问该集群</em></p></blockquote><h1 id="5e1e" class="ni nj iq bd nk nl nm nn no np nq nr ns jw nt jx nu jz nv ka nw kc nx kd ny nz bi translated">卡夫卡溪流</h1><p id="6a01" class="pw-post-body-paragraph kf kg iq kh b ki oa jr kk kl ob ju kn ko oc kq kr ks od ku kv kw oe ky kz la ij bi translated">本节将简要介绍Kafka流，以及在基于Kafka流的应用程序环境中“状态”的含义。</p><h2 id="9797" class="of nj iq bd nk og oh dn no oi oj dp ns ko ok ol nu ks om on nw kw oo op ny oq bi translated">卡夫卡流概述</h2><p id="4641" class="pw-post-body-paragraph kf kg iq kh b ki oa jr kk kl ob ju kn ko oc kq kr ks od ku kv kw oe ky kz la ij bi translated">这是一个简单而轻量级的客户端库，可以很容易地嵌入到任何Java应用程序或微服务中，其中输入和输出数据存储在<a class="ae lk" href="https://kafka.apache.org/" rel="noopener ugc nofollow" target="_blank"> Kafka clusters </a>中。除了Kafka本身和它的分区模型之外，它对其他系统没有外部依赖性，可以水平扩展处理，同时保持强大的排序保证。它支持容错本地状态，采用一次一条记录处理来实现毫秒级处理延迟，并提供必要的流处理原语，以及一个<a class="ae lk" href="https://kafka.apache.org/23/documentation/streams/developer-guide/dsl-api.html" rel="noopener ugc nofollow" target="_blank">高级流DSL </a>和一个<a class="ae lk" href="https://kafka.apache.org/23/documentation/streams/developer-guide/processor-api.html" rel="noopener ugc nofollow" target="_blank">低级处理器API </a>。“状态存储”和<a class="ae lk" href="https://kafka.apache.org/23/documentation/streams/developer-guide/interactive-queries.html" rel="noopener ugc nofollow" target="_blank">交互查询</a>的结合允许你从应用程序外部利用应用程序的状态。</p><h2 id="0f12" class="of nj iq bd nk og oh dn no oi oj dp ns ko ok ol nu ks om on nw kw oo op ny oq bi translated">有状态的Kafka流应用程序</h2><p id="fca0" class="pw-post-body-paragraph kf kg iq kh b ki oa jr kk kl ob ju kn ko oc kq kr ks od ku kv kw oe ky kz la ij bi translated">大多数流处理应用程序需要上下文数据，即状态，例如，为了维护库存中项目的连续计数，您将需要最后一次“计数”，以便计算“当前”计数。</p><p id="44f5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以部署多个Kafka Streams应用程序实例来扩展您的处理。因为每个实例都从一个或多个分区(Kafka主题的)中搅动数据，所以与每个实例相关联的状态都存储在本地(除非您是<code class="fe lx ly lz ma b"><a class="ae lk" href="https://kafka.apache.org/23/javadoc/org/apache/kafka/streams/kstream/GlobalKTable.html" rel="noopener ugc nofollow" target="_blank">GlobalKTable</a></code><a class="ae lk" href="https://kafka.apache.org/23/javadoc/org/apache/kafka/streams/kstream/GlobalKTable.html" rel="noopener ugc nofollow" target="_blank">API</a>——值得一篇专门的博客文章！).Kafka Streams在状态存储的帮助下支持“有状态”处理。通常，它是基于文件系统的(Kafka Streams在内部使用嵌入式的<a class="ae lk" href="http://rocksdb.org/" rel="noopener ugc nofollow" target="_blank"> RocksDB数据库</a>),但是您也可以选择使用内存中的哈希映射，或者使用<a class="ae lk" href="https://kafka.apache.org/23/documentation/streams/developer-guide/processor-api.html" rel="noopener ugc nofollow" target="_blank"> Kafka Streams处理器API </a>的可插拔特性来构建一个定制的实现状态存储。</p><p id="ec2f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">除了存储状态，Kafka Streams还有一个内置的机制，用于这些状态存储的容错。每个状态存储的内容都被备份到一个复制的、<a class="ae lk" href="https://kafka.apache.org/documentation/#compaction" rel="noopener ugc nofollow" target="_blank">日志压缩的Kafka主题</a>。如果您的任何Kafka Streams应用程序实例失败，另一个实例可以出现，从Kafka恢复当前状态并继续处理。除了存储状态，您还可以“查询”这些状态存储。这是另一篇博文的主题——敬请关注！</p><blockquote class="mu mv mw"><p id="c989" class="kf kg mx kh b ki kj jr kk kl km ju kn my kp kq kr mz kt ku kv na kx ky kz la ij bi translated"><em class="iq">请注意，可以调整“容错”行为，即您可以选择不将本地状态存储备份到Kafka </em></p></blockquote><p id="9edc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在您深入了解之前，这里是该解决方案的高级概述</p><figure class="nc nd ne nf gt ng gh gi paragraph-image"><div role="button" tabindex="0" class="os ot di ou bf ov"><div class="gh gi or"><img src="../Images/3fe0f6e23ec01d6b45f03f8723b21c62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*7gy8CkJrxbjpKlW9.jpg"/></div></div></figure><h1 id="d1f2" class="ni nj iq bd nk nl nm nn no np nq nr ns jw nt jx nu jz nv ka nw kc nx kd ny nz bi translated">在幕后</h1><p id="878c" class="pw-post-body-paragraph kf kg iq kh b ki oa jr kk kl ob ju kn ko oc kq kr ks od ku kv kw oe ky kz la ij bi translated">让我们看看流处理代码的作用，然后深入了解Kubernetes原语的一些本质，以及它们在运行“有状态的”Kafka流应用程序时提供的价值。</p><h2 id="0649" class="of nj iq bd nk og oh dn no oi oj dp ns ko ok ol nu ks om on nw kw oo op ny oq bi translated">流处理代码</h2><p id="706a" class="pw-post-body-paragraph kf kg iq kh b ki oa jr kk kl ob ju kn ko oc kq kr ks od ku kv kw oe ky kz la ij bi translated">处理管道执行类似于规范的“字数统计”的事情。它利用了<a class="ae lk" href="https://kafka.apache.org/23/documentation/streams/developer-guide/dsl-api.html" rel="noopener ugc nofollow" target="_blank">高级流DSL </a> API:</p><ul class=""><li id="f678" class="lb lc iq kh b ki kj kl km ko ld ks le kw lf la lg lh li lj bi translated">接收来自输入/源Kafka主题的键值对流，例如<code class="fe lx ly lz ma b">foo:bar</code>、<code class="fe lx ly lz ma b">john:doe</code>、<code class="fe lx ly lz ma b">foo:bazz</code>等。</li><li id="ae35" class="lb lc iq kh b ki ll kl lm ko ln ks lo kw lp la lg lh li lj bi translated">保存和存储键的计数(忽略值)，例如<code class="fe lx ly lz ma b">foo=2</code>、<code class="fe lx ly lz ma b">john=1</code>等。</li><li id="ec51" class="lb lc iq kh b ki ll kl lm ko ln ks lo kw lp la lg lh li lj bi translated">将计数转发到输出Kafka主题(接收器)</li></ul><p id="6457" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请注意，在撰写本文时，最新的Kafka Streams库版本是<code class="fe lx ly lz ma b">2.3.0</code>，这就是该应用程序所使用的版本</p><pre class="nc nd ne nf gt ow ma ox oy aw oz bi"><span id="45df" class="of nj iq ma b gy pa pb l pc pd">&lt;dependency&gt;<br/>        &lt;groupId&gt;org.apache.kafka&lt;/groupId&gt;<br/>        &lt;artifactId&gt;kafka-streams&lt;/artifactId&gt;<br/>        &lt;version&gt;2.3.0&lt;/version&gt;<br/>    &lt;/dependency&gt;</span></pre><p id="acd0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们从一个<code class="fe lx ly lz ma b">StreamsBuilder</code>的实例开始，调用它的<code class="fe lx ly lz ma b">stream</code>方法来挂钩源主题。我们得到的是一个<code class="fe lx ly lz ma b"><a class="ae lk" href="https://kafka.apache.org/23/javadoc/org/apache/kafka/streams/kstream/KStream.html" rel="noopener ugc nofollow" target="_blank">KStream</a></code> <a class="ae lk" href="https://kafka.apache.org/23/javadoc/org/apache/kafka/streams/kstream/KStream.html" rel="noopener ugc nofollow" target="_blank">对象</a>，它表示发送到主题的连续记录流。</p><pre class="nc nd ne nf gt ow ma ox oy aw oz bi"><span id="efd0" class="of nj iq ma b gy pa pb l pc pd">StreamsBuilder builder = new StreamsBuilder();<br/>    KStream&lt;String, String&gt; inputStream = builder.stream(INPUT_TOPIC);</span></pre><p id="c941" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们在输入<code class="fe lx ly lz ma b">KStream</code>上使用<code class="fe lx ly lz ma b"><a class="ae lk" href="https://kafka.apache.org/23/javadoc/org/apache/kafka/streams/kstream/KStream.html#groupByKey--" rel="noopener ugc nofollow" target="_blank">groupByKey</a></code>将记录按照它们当前的键分组到一个<code class="fe lx ly lz ma b"><a class="ae lk" href="https://kafka.apache.org/23/javadoc/org/apache/kafka/streams/kstream/KGroupedStream.html" rel="noopener ugc nofollow" target="_blank">KGroupedStream</a></code>中。为了对键进行计数，我们使用了<code class="fe lx ly lz ma b">count</code>方法(这并不奇怪！).我们也保证字数如<code class="fe lx ly lz ma b">foo=5</code>、<code class="fe lx ly lz ma b">bar=3</code>等。被持久存储到状态存储- <code class="fe lx ly lz ma b"><a class="ae lk" href="https://kafka.apache.org/23/javadoc/org/apache/kafka/streams/kstream/Materialized.html" rel="noopener ugc nofollow" target="_blank">Materialized</a></code>用于描述该状态存储应该如何被持久存储。在这种情况下，选择一个特定的名称，并在KafkaStreams配置中提到磁盘上的确切位置，如下所示:<code class="fe lx ly lz ma b">configurations.put(StreamsConfig.STATE_DIR_CONFIG, "/data/count-store");</code></p><blockquote class="mu mv mw"><p id="a4fd" class="kf kg mx kh b ki kj jr kk kl km ju kn my kp kq kr mz kt ku kv na kx ky kz la ij bi translated"><em class="iq">默认行为是使用RocksDB将状态存储在磁盘上，除非进行了不同的配置</em></p></blockquote><pre class="nc nd ne nf gt ow ma ox oy aw oz bi"><span id="2384" class="of nj iq ma b gy pa pb l pc pd">inputStream.groupByKey()<br/>               .count(Materialized.&lt;String, Long, KeyValueStore&lt;Bytes, byte[]&gt;&gt;as("count-store")<br/>                    .withKeySerde(Serdes.String())<br/>                    .withValueSerde(Serdes.Long()))</span></pre><p id="8245" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，为了便于演示，我们使用<code class="fe lx ly lz ma b">toStream</code>将<code class="fe lx ly lz ma b"><a class="ae lk" href="https://kafka.apache.org/23/javadoc/org/apache/kafka/streams/kstream/KTable.html" rel="noopener ugc nofollow" target="_blank">KTable</a></code>(由<code class="fe lx ly lz ma b">count</code>创建)转换回<code class="fe lx ly lz ma b">KStream</code>，使用<code class="fe lx ly lz ma b"><a class="ae lk" href="https://kafka.apache.org/23/javadoc/org/apache/kafka/streams/kstream/KStream.html#mapValues-org.apache.kafka.streams.kstream.ValueMapper-" rel="noopener ugc nofollow" target="_blank">mapValues</a></code>将<code class="fe lx ly lz ma b">java.lang.Long</code>(即<code class="fe lx ly lz ma b">count</code>数据类型)转换成<code class="fe lx ly lz ma b">String</code>，并将结果传递给输出主题。这只是为了在Kafka CLI中方便使用，以便您能够实际看到每个单词的最终计数。</p><pre class="nc nd ne nf gt ow ma ox oy aw oz bi"><span id="e389" class="of nj iq ma b gy pa pb l pc pd">.toStream()<br/>            .mapValues(new ValueMapper&lt;Long, String&gt;() {<br/>                @Override<br/>                public String apply(Long v) {<br/>                    return String.valueOf(v);<br/>                }<br/>            })<br/>            .to(OUTPUT_TOPIC);</span></pre><p id="f7fe" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这就是建立流和定义逻辑的全部内容。我们使用<code class="fe lx ly lz ma b">StreamsBuilder</code>中的<code class="fe lx ly lz ma b">build</code>方法创建一个<code class="fe lx ly lz ma b"><a class="ae lk" href="https://kafka.apache.org/23/javadoc/org/apache/kafka/streams/Topology.html" rel="noopener ugc nofollow" target="_blank">Topology</a></code>对象，并使用这个对象创建一个<code class="fe lx ly lz ma b"><a class="ae lk" href="https://kafka.apache.org/23/javadoc/org/apache/kafka/streams/KafkaStreams.html" rel="noopener ugc nofollow" target="_blank">KafkaStreams</a></code>实例，它是我们的应用程序本身的表示。我们使用<code class="fe lx ly lz ma b">start</code>方法开始流处理</p><pre class="nc nd ne nf gt ow ma ox oy aw oz bi"><span id="6d4e" class="of nj iq ma b gy pa pb l pc pd">Topology topology = builder.build();<br/>    KafkaStreams streamsApp = new KafkaStreams(topology, getKafkaStreamsConfig());<br/>    streamsApp.start();</span></pre><p id="1422" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lx ly lz ma b">getKafkaStreamsConfig()</code>只是一个帮助器方法，它创建一个<code class="fe lx ly lz ma b"><a class="ae lk" href="https://docs.oracle.com/javase/8/docs/api/java/util/Properties.html?is-external=true" rel="noopener ugc nofollow" target="_blank">Properties</a></code>对象，该对象包含Kafka Streams的特定配置，包括Kafka broker端点等。</p><pre class="nc nd ne nf gt ow ma ox oy aw oz bi"><span id="5888" class="of nj iq ma b gy pa pb l pc pd">static Properties getKafkaStreamsConfig() {<br/>    String kafkaBroker = System.getenv().get(KAFKA_BROKER_ENV_VAR);<br/>    Properties configurations = new Properties();<br/>    configurations.put(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, kafkaBroker + ":9092");<br/>    configurations.put(StreamsConfig.APPLICATION_ID_CONFIG, APP_ID);<br/>    configurations.put(StreamsConfig.DEFAULT_KEY_SERDE_CLASS_CONFIG, Serdes.String().getClass().getName());<br/>    configurations.put(StreamsConfig.DEFAULT_VALUE_SERDE_CLASS_CONFIG, Serdes.String().getClass().getName());<br/>    configurations.put(StreamsConfig.REQUEST_TIMEOUT_MS_CONFIG, "20000");<br/>    configurations.put(StreamsConfig.RETRY_BACKOFF_MS_CONFIG, "500");<br/>    configurations.put(StreamsConfig.STATE_DIR_CONFIG, STATE_STORE_DIR);</span><span id="d91c" class="of nj iq ma b gy pe pb l pc pd">    return configurations;<br/>}</span></pre><h2 id="2454" class="of nj iq bd nk og oh dn no oi oj dp ns ko ok ol nu ks om on nw kw oo op ny oq bi translated">库伯内特原始人</h2><p id="8b22" class="pw-post-body-paragraph kf kg iq kh b ki oa jr kk kl ob ju kn ko oc kq kr ks od ku kv kw oe ky kz la ij bi translated">到目前为止一切顺利！我们有Kafka Streams应用程序生成字数并存储它们。我们可以简单地将它作为Kubernetes <code class="fe lx ly lz ma b">Deployment</code>运行(如前一篇博客中所示)，但是使用一个叫做<code class="fe lx ly lz ma b"><a class="ae lk" href="https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/" rel="noopener ugc nofollow" target="_blank">StatefulSet</a></code>的东西会有一些好处。</p><blockquote class="mu mv mw"><p id="bdf0" class="kf kg mx kh b ki kj jr kk kl km ju kn my kp kq kr mz kt ku kv na kx ky kz la ij bi translated"><code class="fe lx ly lz ma b"><em class="iq">StatefulSet</em></code> <em class="iq">是一个值得一博的话题(或更多！)本身。我们的目标并不是在这篇博客中告诉你关于Kubernetes </em> <code class="fe lx ly lz ma b"><em class="iq">StatefulSet</em></code> <em class="iq"> s的一切，而是提供足够的背景知识，并演示如何将其特性用于有状态Kafka Streams应用程序。</em></p></blockquote><figure class="nc nd ne nf gt ng gh gi paragraph-image"><div class="gh gi pf"><img src="../Images/5916d653aca64fd23aa1af7ddd03f319.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/0*r4Pw4tjxJ3o8bpC2.gif"/></div></figure><p id="f6c0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">什么东西</p><p id="c3cf" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是在Kubernetes中运行有状态工作负载的要点</p><ul class=""><li id="c211" class="lb lc iq kh b ki kj kl km ko ld ks le kw lf la lg lh li lj bi translated"><code class="fe lx ly lz ma b">Pod</code>唯一性——在<code class="fe lx ly lz ma b">StatefulSet</code>中的每个<code class="fe lx ly lz ma b">Pod</code>都是唯一的，并且在重启、重新调度等过程中保持不变。这也适用于联网和通信(Pod间或外部)</li><li id="b071" class="lb lc iq kh b ki ll kl lm ko ln ks lo kw lp la lg lh li lj bi translated">持久存储—使用卷声明模板，您可以为<code class="fe lx ly lz ma b">StatefulSet</code>中的每个<code class="fe lx ly lz ma b">Pod</code>请求存储分配，以便在<code class="fe lx ly lz ma b">Pod</code>和存储介质之间存在一对一的映射</li><li id="86aa" class="lb lc iq kh b ki ll kl lm ko ln ks lo kw lp la lg lh li lj bi translated">受管生命周期—您可以明确如何跨各个阶段管理pod的生命周期，包括启动、更新和删除。<code class="fe lx ly lz ma b">StatefulSet</code>pod可以配置为以有序的方式处理这种情况。</li></ul><blockquote class="mu mv mw"><p id="f15d" class="kf kg mx kh b ki kj jr kk kl km ju kn my kp kq kr mz kt ku kv na kx ky kz la ij bi translated"><em class="iq">所有这些都与一般的</em> <code class="fe lx ly lz ma b"><em class="iq">Deployment</em></code> <em class="iq">形成鲜明对比，后者将pod作为一次性实体处理，没有身份、“稳定”附加存储的概念或有序的生命周期管理。</em></p></blockquote><p id="b257" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">陈述集合:原因</strong></p><p id="b057" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们探讨一下为什么我们要在这个特定的场景中使用<code class="fe lx ly lz ma b">StatefulSet</code>的动机，例如一个有状态的Kafka Streams应用程序。</p><p id="f7b0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如前所述，您可以运行多个Kafka Streams应用程序实例。每个实例处理来自(一个主题的)一个或多个分区的数据，并在本地存储相关的状态。Kafka Streams应用程序还内置了容错和弹性，因为每个状态存储的内容都备份到一个复制的日志压缩Kafka主题中。如果您的任何Kafka Streams应用程序实例失败，另一个实例可以出现，从Kafka恢复当前状态并继续处理。</p><p id="b53b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在问题来了。任何具有相当复杂的拓扑和处理管道的严肃应用程序都会生成大量的“状态”。在这种情况下，常规应用程序操作，如横向扩展或异常情况，如崩溃等。将从Kafka备份主题中触发恢复/刷新状态的过程。这在时间、网络带宽等方面代价很高。使用<code class="fe lx ly lz ma b">StatefulSet</code>，我们可以确保每个<code class="fe lx ly lz ma b">Pod</code>都有一个稳定的存储介质，并且在<code class="fe lx ly lz ma b">StatefulSet</code>的生命周期内保持稳定(不变)。这意味着在重启、升级等之后。(大部分)状态已经存在于本地磁盘上，应用程序只需要从Kafka主题中获取“增量”状态(如果需要)。这反过来意味着状态恢复时间将会更短，或者在少数情况下甚至不需要。</p><blockquote class="mu mv mw"><p id="d847" class="kf kg mx kh b ki kj jr kk kl km ju kn my kp kq kr mz kt ku kv na kx ky kz la ij bi translated"><em class="iq">在本例中，我们将利用</em> <code class="fe lx ly lz ma b"><em class="iq">StatefulSet</em></code> <em class="iq">的前两个特性，即Pod唯一性和稳定持久存储。</em></p></blockquote><p id="0b0e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">陈述集合:如何进行</strong></p><p id="6c0c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">是时候看看怎么做了。让我们从探索我们的应用程序的Kubernetes YAML清单(小块)开始——我们稍后将使用它将应用程序部署到AKS</p><p id="e79b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们定义了我们的<code class="fe lx ly lz ma b">StatefulSet</code> ( <code class="fe lx ly lz ma b">kstreams-count</code>)的名称，并引用了一个<code class="fe lx ly lz ma b"><a class="ae lk" href="https://kubernetes.io/docs/concepts/services-networking/service/#headless-services" rel="noopener ugc nofollow" target="_blank">Headless</a></code> <a class="ae lk" href="https://kubernetes.io/docs/concepts/services-networking/service/#headless-services" rel="noopener ugc nofollow" target="_blank">服务</a> ( <code class="fe lx ly lz ma b">kstreams-count-service</code>)，它负责唯一的网络身份——它与<code class="fe lx ly lz ma b">StatefulSet</code>本身捆绑在一起。</p><pre class="nc nd ne nf gt ow ma ox oy aw oz bi"><span id="7be8" class="of nj iq ma b gy pa pb l pc pd">apiVersion: apps/v1<br/>kind: StatefulSet<br/>metadata:<br/>    name: kstreams-count<br/>spec:<br/>    serviceName: "kstreams-count-service"</span></pre><blockquote class="mu mv mw"><p id="66c9" class="kf kg mx kh b ki kj jr kk kl km ju kn my kp kq kr mz kt ku kv na kx ky kz la ij bi translated"><em class="iq"/><code class="fe lx ly lz ma b"><em class="iq">Headless</em></code><em class="iq">服务应该在</em> <code class="fe lx ly lz ma b"><em class="iq">StatefulSet</em></code>之前创建</p></blockquote><pre class="nc nd ne nf gt ow ma ox oy aw oz bi"><span id="e517" class="of nj iq ma b gy pa pb l pc pd">apiVersion: v1<br/>kind: Service<br/>metadata:<br/>name: kstreams-count-service<br/>labels:<br/>    app: kstreams-count<br/>spec:<br/>clusterIP: None<br/>selector:<br/>    app: kstreams-count</span></pre><p id="a784" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lx ly lz ma b">Pod</code>规范(<code class="fe lx ly lz ma b">spec.containers</code>)指向Docker映像，并定义环境变量<code class="fe lx ly lz ma b">KAFKA_BROKER</code>，该变量将在运行时注入到我们的应用程序中。</p><pre class="nc nd ne nf gt ow ma ox oy aw oz bi"><span id="5838" class="of nj iq ma b gy pa pb l pc pd">spec:<br/>  containers:<br/>  - name: kstreams-count<br/>    image: &lt;to be filled&gt;.azurecr.io/kstreams-count:latest<br/>    env:<br/>      - name: KAFKA_BROKER<br/>        value: [to be filled]</span></pre><p id="e5df" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">除了上述内容，容器规范还定义了持久存储。在这种情况下，这意味着容器将使用稳定的存储介质来存储指定路径中的内容，在这种情况下是<code class="fe lx ly lz ma b">/data/count-store</code>(回想一下，这是在我们的Kafka Streams应用程序中配置的本地状态目录)</p><pre class="nc nd ne nf gt ow ma ox oy aw oz bi"><span id="5779" class="of nj iq ma b gy pa pb l pc pd">volumeMounts:<br/>    - name: count-store<br/>      mountPath: /data/count-store</span></pre><p id="3f6c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种持久存储将如何实现并提供给<code class="fe lx ly lz ma b">Pod</code>？答案就在作为<code class="fe lx ly lz ma b"><a class="ae lk" href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.15/#statefulsetspec-v1-apps" rel="noopener ugc nofollow" target="_blank">StatefulSet</a></code> <a class="ae lk" href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.15/#statefulsetspec-v1-apps" rel="noopener ugc nofollow" target="_blank">规范</a>一部分的批量索赔模板中。将为每个批量索赔模板创建一个<code class="fe lx ly lz ma b"><a class="ae lk" href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.15/#persistentvolumeclaim-v1-core" rel="noopener ugc nofollow" target="_blank">PersistentVolumeClaim</a></code>和<code class="fe lx ly lz ma b"><a class="ae lk" href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.15/#persistentvolume-v1-core" rel="noopener ugc nofollow" target="_blank">PersistentVolume</a></code>。</p><pre class="nc nd ne nf gt ow ma ox oy aw oz bi"><span id="1ae6" class="of nj iq ma b gy pa pb l pc pd">volumeClaimTemplates:<br/>- metadata:<br/>    name: count-store<br/>    spec:<br/>    accessModes: [ "ReadWriteOnce" ]<br/>    resources:<br/>        requests:<br/>        storage: 1Gi</span></pre><p id="57ba" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么存储介质是如何产生的呢？</p><p id="18a8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是由<strong class="kh ir">动态预配置</strong>支持的，它支持按需创建存储卷。否则，集群管理员必须手动配置基于云的存储，然后在Kubernetes中创建等效的<code class="fe lx ly lz ma b">PersistentVolume</code>对象。动态资源调配通过在用户请求时自动调配存储来消除这种情况。</p><p id="21ae" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">动态预配置本身使用一个<code class="fe lx ly lz ma b">StorageClass</code>,它提供了一种使用一组参数以及一个卷插件来描述存储类型的方法，该插件实际上负责存储介质的预配置。Azure Kubernetes服务通过包含两个预播种的存储类，简化了动态配置:</p><ul class=""><li id="cc79" class="lb lc iq kh b ki kj kl km ko ld ks le kw lf la lg lh li lj bi translated"><code class="fe lx ly lz ma b">default</code>存储类:提供由标准硬盘支持的标准<a class="ae lk" href="https://docs.microsoft.com/azure/virtual-machines/windows/disks-types?WT.mc_id=medium-blog-abhishgu#standard-hdd" rel="noopener ugc nofollow" target="_blank"> Azure磁盘</a></li><li id="efb8" class="lb lc iq kh b ki ll kl lm ko ln ks lo kw lp la lg lh li lj bi translated"><code class="fe lx ly lz ma b">managed-premium</code>存储类别:提供由高级固态硬盘支持的高级<a class="ae lk" href="https://docs.microsoft.com/azure/virtual-machines/windows/disks-types?WT.mc_id=medium-blog-abhishgu#premium-ssd" rel="noopener ugc nofollow" target="_blank"> Azure磁盘</a></li></ul><p id="1165" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你可以通过运行<code class="fe lx ly lz ma b">kubectl get storageclass</code>命令来检查</p><pre class="nc nd ne nf gt ow ma ox oy aw oz bi"><span id="bb45" class="of nj iq ma b gy pa pb l pc pd">NAME                PROVISIONER                AGE<br/>default (default)   kubernetes.io/azure-disk   6d10h<br/>managed-premium     kubernetes.io/azure-disk   6d10h</span></pre><blockquote class="mu mv mw"><p id="a0cf" class="kf kg mx kh b ki kj jr kk kl km ju kn my kp kq kr mz kt ku kv na kx ky kz la ij bi translated"><em class="iq">注意</em> <code class="fe lx ly lz ma b"><em class="iq">kubernetes.io/azure-disk</em></code> <em class="iq">是卷插件(provisioner实现)</em></p></blockquote><p id="17b8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为我们在批量索赔模板中没有明确定义的<code class="fe lx ly lz ma b">StorageClass</code>，所以将使用默认的<code class="fe lx ly lz ma b">StorageClass</code>。对于Kafka Streams应用程序的每个实例，将创建一个Azure磁盘实例，并将其挂载到代表该应用程序的<code class="fe lx ly lz ma b">Pod</code>中。</p><p id="cca6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们使用Pod反相似性(与<code class="fe lx ly lz ma b">StatefulSet</code>无关)——这是为了确保我们的应用程序没有两个实例位于同一个节点上。</p><pre class="nc nd ne nf gt ow ma ox oy aw oz bi"><span id="312b" class="of nj iq ma b gy pa pb l pc pd">affinity:<br/>    podAntiAffinity:<br/>      requiredDuringSchedulingIgnoredDuringExecution:<br/>      - labelSelector:<br/>          matchExpressions:<br/>          - key: app<br/>            operator: In<br/>            values:<br/>            - kstreams-count<br/>        topologyKey: "kubernetes.io/hostname"</span></pre><p id="9853" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们继续基础设施的设置。</p><h1 id="66ff" class="ni nj iq bd nk nl nm nn no np nq nr ns jw nt jx nu jz nv ka nw kc nx kd ny nz bi translated">AKS集群设置</h1><p id="7270" class="pw-post-body-paragraph kf kg iq kh b ki oa jr kk kl ob ju kn ko oc kq kr ks od ku kv kw oe ky kz la ij bi translated">你只需要一个命令就可以在Azure上建立一个Kubernetes集群。但是，在此之前，我们必须创建一个资源组</p><pre class="nc nd ne nf gt ow ma ox oy aw oz bi"><span id="bd1e" class="of nj iq ma b gy pa pb l pc pd">export AZURE_SUBSCRIPTION_ID=[to be filled]<br/>export AZURE_RESOURCE_GROUP=[to be filled]<br/>export AZURE_REGION=[to be filled] (e.g. southeastasia)</span></pre><p id="84bc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">切换到您的订阅并调用<code class="fe lx ly lz ma b">az group create</code></p><pre class="nc nd ne nf gt ow ma ox oy aw oz bi"><span id="7503" class="of nj iq ma b gy pa pb l pc pd">az account set -s $AZURE_SUBSCRIPTION_ID<br/>az group create -l $AZURE_REGION -n $AZURE_RESOURCE_GROUP</span></pre><p id="611d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您现在可以调用<code class="fe lx ly lz ma b">az aks create</code>来创建新的集群</p><blockquote class="mu mv mw"><p id="533d" class="kf kg mx kh b ki kj jr kk kl km ju kn my kp kq kr mz kt ku kv na kx ky kz la ij bi translated">为了简单起见，下面的命令创建了一个双节点集群。请根据您的要求随意更改规格</p></blockquote><pre class="nc nd ne nf gt ow ma ox oy aw oz bi"><span id="404b" class="of nj iq ma b gy pa pb l pc pd">export AKS_CLUSTER_NAME=[to be filled]</span><span id="c7fb" class="of nj iq ma b gy pe pb l pc pd">az aks create --resource-group $AZURE_RESOURCE_GROUP --name $AKS_CLUSTER_NAME --node-count 2 --node-vm-size Standard_B2s --node-osdisk-size 30 --generate-ssh-keys</span></pre><p id="5d0c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用<code class="fe lx ly lz ma b">az aks get-credentials</code>获取AKS集群凭证——因此，<code class="fe lx ly lz ma b">kubectl</code>现在将指向您的新集群。你可以证实这一点</p><pre class="nc nd ne nf gt ow ma ox oy aw oz bi"><span id="b8b2" class="of nj iq ma b gy pa pb l pc pd">az aks get-credentials --resource-group $AZURE_RESOURCE_GROUP --name $AKS_CLUSTER_NAME<br/>kubectl get nodes</span></pre><blockquote class="mu mv mw"><p id="a70f" class="kf kg mx kh b ki kj jr kk kl km ju kn my kp kq kr mz kt ku kv na kx ky kz la ij bi translated"><em class="iq">如果你有兴趣学习Kubernetes和Containers使用</em> <a class="ae lk" href="https://azure.microsoft.com/services/kubernetes-service/?WT.mc_id=medium-blog-abhishgu" rel="noopener ugc nofollow" target="_blank"> <em class="iq"> Azure </em> </a> <em class="iq">，只需</em> <a class="ae lk" href="https://azure.microsoft.com/en-us/free/?WT.mc_id=medium-blog-abhishgu" rel="noopener ugc nofollow" target="_blank"> <em class="iq">创建一个</em> <strong class="kh ir"> <em class="iq">免费</em> </strong> <em class="iq">账号</em> </a> <em class="iq">就可以开始了！一个好的起点是使用文档中的</em> <a class="ae lk" href="https://docs.microsoft.com/azure/aks/?WT.mc_id=medium-blog-abhishgu" rel="noopener ugc nofollow" target="_blank"> <em class="iq">快速入门、教程和代码示例</em> </a> <em class="iq">来熟悉该服务。我也强烈推荐查看一下</em> <a class="ae lk" href="https://azure.microsoft.com/resources/kubernetes-learning-path/?WT.mc_id=medium-blog-abhishgu" rel="noopener ugc nofollow" target="_blank"> <em class="iq"> 50天Kubernetes学习路径</em> </a> <em class="iq">。高级用户可能希望参考</em> <a class="ae lk" href="https://docs.microsoft.com/azure/aks/best-practices?WT.mc_id=medium-blog-abhishgu" rel="noopener ugc nofollow" target="_blank"> <em class="iq"> Kubernetes最佳实践</em> </a> <em class="iq">或观看一些</em> <a class="ae lk" href="https://azure.microsoft.com/resources/videos/index/?services=kubernetes-service&amp;WT.mc_id=medium-blog-abhishgu" rel="noopener ugc nofollow" target="_blank"> <em class="iq">视频</em> </a> <em class="iq">以了解演示、主要功能和技术会议。</em></p></blockquote><h1 id="dec3" class="ni nj iq bd nk nl nm nn no np nq nr ns jw nt jx nu jz nv ka nw kc nx kd ny nz bi translated">设置Azure容器注册表</h1><p id="7abc" class="pw-post-body-paragraph kf kg iq kh b ki oa jr kk kl ob ju kn ko oc kq kr ks od ku kv kw oe ky kz la ij bi translated">简单来说，<a class="ae lk" href="https://azure.microsoft.com/services/container-registry/?WT.mc_id=medium-blog-abhishgu" rel="noopener ugc nofollow" target="_blank"> Azure Container Registry </a>(简称<code class="fe lx ly lz ma b">ACR</code>)是云中的一个托管私有Docker注册表，它允许你为所有类型的容器部署构建、存储和管理映像。</p><p id="b4e6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先创建一个ACR实例</p><pre class="nc nd ne nf gt ow ma ox oy aw oz bi"><span id="7b60" class="of nj iq ma b gy pa pb l pc pd">export ACR_NAME=[to be filled]<br/>az acr create --resource-group $AZURE_RESOURCE_GROUP --name $ACR_NAME --sku Basic</span></pre><blockquote class="mu mv mw"><p id="2237" class="kf kg mx kh b ki kj jr kk kl km ju kn my kp kq kr mz kt ku kv na kx ky kz la ij bi translated"><em class="iq">有效的SKU值——</em><code class="fe lx ly lz ma b"><em class="iq">Basic</em></code><em class="iq"/><code class="fe lx ly lz ma b"><em class="iq">Classic</em></code><em class="iq"/><code class="fe lx ly lz ma b"><em class="iq">Premium</em></code><em class="iq"/><code class="fe lx ly lz ma b"><em class="iq">Standard</em></code><em class="iq">。参见</em> <a class="ae lk" href="https://docs.microsoft.com/cli/azure/acr?view=azure-cli-latest&amp;WT.mc_id=medium-blog-abhishgu#az-acr-create" rel="noopener ugc nofollow" target="_blank"> <em class="iq">命令文档</em> </a></p></blockquote><h1 id="4f6e" class="ni nj iq bd nk nl nm nn no np nq nr ns jw nt jx nu jz nv ka nw kc nx kd ny nz bi translated">配置ACR以使用AKS</h1><p id="bb48" class="pw-post-body-paragraph kf kg iq kh b ki oa jr kk kl ob ju kn ko oc kq kr ks od ku kv kw oe ky kz la ij bi translated">要访问存储在ACR中的图像，您必须授予AKS服务主体从ACR提取图像的正确权限。</p><p id="fd3f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">获取与您的AKS集群相关联的服务主体的<code class="fe lx ly lz ma b">appId</code></p><pre class="nc nd ne nf gt ow ma ox oy aw oz bi"><span id="be1a" class="of nj iq ma b gy pa pb l pc pd">AKS_SERVICE_PRINCIPAL_APPID=$(az aks show --name $AKS_CLUSTER_NAME --resource-group $AZURE_RESOURCE_GROUP --query servicePrincipalProfile.clientId -o tsv)</span></pre><p id="1982" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">查找ACR资源ID</p><pre class="nc nd ne nf gt ow ma ox oy aw oz bi"><span id="75a3" class="of nj iq ma b gy pa pb l pc pd">ACR_RESOURCE_ID=$(az acr show --resource-group $AZURE_RESOURCE_GROUP --name $ACR_NAME --query "id" --output tsv)</span></pre><p id="09e0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">授予AKS服务主体<code class="fe lx ly lz ma b">acrpull</code>权限</p><pre class="nc nd ne nf gt ow ma ox oy aw oz bi"><span id="9fee" class="of nj iq ma b gy pa pb l pc pd">az role assignment create --assignee $AKS_SERVICE_PRINCIPAL_APPID --scope $ACR_RESOURCE_ID --role acrpull</span></pre><p id="d51d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">关于这个话题的更多细节，请查看我以前的博客</p><div class="mb mc gp gr md me"><a href="https://medium.com/@abhishek1987/how-to-get-your-kubernetes-cluster-service-principal-and-use-it-to-access-other-azure-services-637f185a5112" rel="noopener follow" target="_blank"><div class="mf ab fo"><div class="mg ab mh cl cj mi"><h2 class="bd ir gy z fp mj fr fs mk fu fw ip bi translated">如何获取你的Kubernetes集群服务主体，并使用它访问其他Azure服务？</h2><div class="ml l"><h3 class="bd b gy z fp mj fr fs mk fu fw dk translated">所以，你在Azure上有一个Kubernetes集群，它需要访问其他Azure服务，如Azure Container…</h3></div><div class="mm l"><p class="bd b dl z fp mj fr fs mk fu fw dk translated">medium.com</p></div></div></div></a></div><p id="d6f5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好了，我们的AKS集群和ACR已经可以使用了！</p><h1 id="64b6" class="ni nj iq bd nk nl nm nn no np nq nr ns jw nt jx nu jz nv ka nw kc nx kd ny nz bi translated">从您的笔记本电脑到云中的Docker注册表</h1><p id="2582" class="pw-post-body-paragraph kf kg iq kh b ki oa jr kk kl ob ju kn ko oc kq kr ks od ku kv kw oe ky kz la ij bi translated">克隆GitHub repo，切换到正确的目录并构建应用程序JAR</p><pre class="nc nd ne nf gt ow ma ox oy aw oz bi"><span id="1e9d" class="of nj iq ma b gy pa pb l pc pd">git clone https://github.com/abhirockzz/kafka-streams-stateful-kubernetes<br/>cd kafka-streams-stateful-kubernetes<br/>mvn clean install</span></pre><blockquote class="mu mv mw"><p id="8411" class="kf kg mx kh b ki kj jr kk kl km ju kn my kp kq kr mz kt ku kv na kx ky kz la ij bi translated"><em class="iq">你应该看到</em> <code class="fe lx ly lz ma b"><em class="iq">target</em></code> <em class="iq">目录中的</em> <code class="fe lx ly lz ma b"><em class="iq">kstreams-count-statefulset-1.0.jar</em></code> <em class="iq"/></p></blockquote><p id="bc4a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是我们的流处理应用程序的<code class="fe lx ly lz ma b">Dockerfile</code></p><pre class="nc nd ne nf gt ow ma ox oy aw oz bi"><span id="365e" class="of nj iq ma b gy pa pb l pc pd">FROM openjdk:8-jre<br/>WORKDIR /<br/>COPY target/kstreams-count-statefulset-1.0.jar /<br/>CMD ["java", "-jar","kstreams-count-statefulset-1.0.jar"]</span></pre><p id="4794" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们现在将构建一个Docker映像…</p><pre class="nc nd ne nf gt ow ma ox oy aw oz bi"><span id="8572" class="of nj iq ma b gy pa pb l pc pd">export DOCKER_IMAGE=kstreams-count<br/>export ACR_SERVER=$ACR_NAME.azurecr.io<br/>docker build -t $DOCKER_IMAGE .</span></pre><p id="0135" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">…并将其推送到<a class="ae lk" href="https://azure.microsoft.com/services/container-registry/?WT.mc_id=medium-blog-abhishgu" rel="noopener ugc nofollow" target="_blank"> Azure容器注册中心</a></p><pre class="nc nd ne nf gt ow ma ox oy aw oz bi"><span id="e303" class="of nj iq ma b gy pa pb l pc pd">az acr login --name $ACR_NAME<br/>docker tag $DOCKER_IMAGE $ACR_SERVER/$DOCKER_IMAGE<br/>docker push $ACR_SERVER/$DOCKER_IMAGE</span></pre><p id="c69b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">完成后，您可以使用<code class="fe lx ly lz ma b">az acr repository list</code>进行确认</p><pre class="nc nd ne nf gt ow ma ox oy aw oz bi"><span id="b97f" class="of nj iq ma b gy pa pb l pc pd">az acr repository list --name $ACR_NAME --output table</span></pre><h1 id="b1e0" class="ni nj iq bd nk nl nm nn no np nq nr ns jw nt jx nu jz nv ka nw kc nx kd ny nz bi translated">部署到Kubernetes</h1><p id="0d56" class="pw-post-body-paragraph kf kg iq kh b ki oa jr kk kl ob ju kn ko oc kq kr ks od ku kv kw oe ky kz la ij bi translated">部署和确认</p><pre class="nc nd ne nf gt ow ma ox oy aw oz bi"><span id="b521" class="of nj iq ma b gy pa pb l pc pd">kubectl apply -f kstreams-count-statefulset.yaml<br/>kubectl get pods -l=app=kstreams-count</span></pre><blockquote class="mu mv mw"><p id="8f3a" class="kf kg mx kh b ki kj jr kk kl km ju kn my kp kq kr mz kt ku kv na kx ky kz la ij bi translated">该应用程序将需要一些时间来启动，因为这也涉及到存储(Azure磁盘)的创建和附加。过一段时间后，你应该会看到两个吊舱处于 <code class="fe lx ly lz ma b"><em class="iq">Running</em></code> <em class="iq">状态</em></p></blockquote><h1 id="7d94" class="ni nj iq bd nk nl nm nn no np nq nr ns jw nt jx nu jz nv ka nw kc nx kd ny nz bi translated">关键时刻到了。</h1><p id="e00f" class="pw-post-body-paragraph kf kg iq kh b ki oa jr kk kl ob ju kn ko oc kq kr ks od ku kv kw oe ky kz la ij bi translated">是时候测试我们的端到端流程了。总结一下:</p><ul class=""><li id="0d5d" class="lb lc iq kh b ki kj kl km ko ld ks le kw lf la lg lh li lj bi translated">您将在本地使用Kafka CLI向输入Kafka主题(<code class="fe lx ly lz ma b">input-topic</code>)生成数据</li><li id="aa2a" class="lb lc iq kh b ki ll kl lm ko ln ks lo kw lp la lg lh li lj bi translated">AKS中的流处理应用程序将搅动数据、存储状态并将其放回另一个Kafka主题</li><li id="0bf5" class="lb lc iq kh b ki ll kl lm ko ln ks lo kw lp la lg lh li lj bi translated">您的本地基于Kafka CLI的消费者进程将从输出主题(<code class="fe lx ly lz ma b">counts-topic</code>)中获取该数据</li></ul><p id="86d5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们先创造卡夫卡的主题</p><pre class="nc nd ne nf gt ow ma ox oy aw oz bi"><span id="f9a4" class="of nj iq ma b gy pa pb l pc pd">export KAFKA_HOME=[kafka installation directory]<br/>export INPUT_TOPIC=input-topic<br/>export OUTPUT_TOPIC=counts-topic</span><span id="c018" class="of nj iq ma b gy pe pb l pc pd">$KAFKA_HOME/bin/kafka-topics.sh --create --topic $INPUT_TOPIC --partitions 4 --replication-factor 1 --bootstrap-server $KAFKA_BROKER<br/>$KAFKA_HOME/bin/kafka-topics.sh --create --topic $OUTPUT_TOPIC --partitions 4 --replication-factor 1 --bootstrap-server $KAFKA_BROKER</span><span id="6863" class="of nj iq ma b gy pe pb l pc pd">$KAFKA_HOME/bin/kafka-topics.sh --list --bootstrap-server $KAFKA_BROKER</span></pre><h2 id="5034" class="of nj iq bd nk og oh dn no oi oj dp ns ko ok ol nu ks om on nw kw oo op ny oq bi translated">启动消费者流程</h2><pre class="nc nd ne nf gt ow ma ox oy aw oz bi"><span id="e4e6" class="of nj iq ma b gy pa pb l pc pd">export KAFKA_HOME=[kafka installation directory]<br/>export KAFKA_BROKER=[kafka broker e.g. localhost:9092]<br/>export OUTPUT_TOPIC=counts-topic</span><span id="9912" class="of nj iq ma b gy pe pb l pc pd">$KAFKA_HOME/bin/kafka-console-consumer.sh --bootstrap-server <br/>$KAFKA_BROKER --topic $OUTPUT_TOPIC --from-beginning --property "print.key=true"</span></pre><h2 id="ae19" class="of nj iq bd nk og oh dn no oi oj dp ns ko ok ol nu ks om on nw kw oo op ny oq bi translated">启动生产者进程(不同的终端)</h2><pre class="nc nd ne nf gt ow ma ox oy aw oz bi"><span id="4e37" class="of nj iq ma b gy pa pb l pc pd">export KAFKA_HOME=[kafka installation directory]<br/>export KAFKA_BROKER=[kafka broker e.g. localhost:9092]<br/>export INPUT_TOPIC=input-topic</span><span id="4d92" class="of nj iq ma b gy pe pb l pc pd">$KAFKA_HOME/bin/kafka-console-producer.sh --broker-list $KAFKA_BROKER --topic $INPUT_TOPIC</span></pre><p id="ef03" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您将看到一个提示，然后您可以开始输入值，例如</p><pre class="nc nd ne nf gt ow ma ox oy aw oz bi"><span id="e750" class="of nj iq ma b gy pa pb l pc pd">&gt; foo:bar<br/>&gt; hello:world<br/>&gt; hello:universe<br/>&gt; foo:baz<br/>&gt; john:doe</span></pre><p id="f3b4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在消费者终端中，您应该看到单词及其各自的计数，例如<code class="fe lx ly lz ma b">foo 2</code>、<code class="fe lx ly lz ma b">hello 2</code>、<code class="fe lx ly lz ma b">john 1</code>等。</p><p id="125c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">随着健全性测试的进行…</p><h2 id="7677" class="of nj iq bd nk og oh dn no oi oj dp ns ko ok ol nu ks om on nw kw oo op ny oq bi translated">…让我们看看AKS集群的状态。</h2><p id="93b2" class="pw-post-body-paragraph kf kg iq kh b ki oa jr kk kl ob ju kn ko oc kq kr ks od ku kv kw oe ky kz la ij bi translated">检查<code class="fe lx ly lz ma b">PersistentVolumeClaim</code> s (PVC)和<code class="fe lx ly lz ma b">PersistentVolume</code>s(PV)——你将有两组独立的PVC-PV对。</p><pre class="nc nd ne nf gt ow ma ox oy aw oz bi"><span id="c254" class="of nj iq ma b gy pa pb l pc pd">kubectl get pv<br/>kubectl get pvc</span></pre><p id="933e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">s的创建意味着Azure磁盘也被创建了。为了检查它们，让我们首先获得AKS节点资源组</p><pre class="nc nd ne nf gt ow ma ox oy aw oz bi"><span id="21a5" class="of nj iq ma b gy pa pb l pc pd">AKS_NODE_RESOURCE_GROUP=$(az aks show --resource-group abhishgu-aks --name abhishgu-aks --query nodeResourceGroup -o tsv)</span></pre><p id="ed40" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">假设这是一个双节点AKS群集，我们将得到四个磁盘—两个节点各一个，两个应用程序实例各一个</p><pre class="nc nd ne nf gt ow ma ox oy aw oz bi"><span id="8e27" class="of nj iq ma b gy pa pb l pc pd">az disk list -g $AKS_NODE_RESOURCE_GROUP</span></pre><blockquote class="mu mv mw"><p id="3aac" class="kf kg mx kh b ki kj jr kk kl km ju kn my kp kq kr mz kt ku kv na kx ky kz la ij bi translated"><em class="iq">您会注意到磁盘的名称与PVC的名称相同</em></p></blockquote><p id="6210" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们深入研究运行我们的应用程序的<code class="fe lx ly lz ma b">Pod</code>的文件系统。<code class="fe lx ly lz ma b">kstreams-count-0</code>是这样一个实例的名字(是的，由于<code class="fe lx ly lz ma b">StatefulSet</code>，这个名字是确定的)。回想一下，我们在应用程序中将<code class="fe lx ly lz ma b">/data/count-store</code>指定为州商店目录，以及应用程序清单的<code class="fe lx ly lz ma b">volumeMounts</code>部分——让我们来看看这个目录。</p><pre class="nc nd ne nf gt ow ma ox oy aw oz bi"><span id="b6a8" class="of nj iq ma b gy pa pb l pc pd">kubectl exec -it kstreams-count-0 -- ls -lrt /data/count-store/counts-app</span></pre><p id="a714" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您会注意到，状态数据分布在多个子目录中，这些子目录的数量等于应用程序实例正在处理的主题分区的数量，例如，如果您有四个分区和两个实例，每个实例将处理来自两个分区的数据</p><pre class="nc nd ne nf gt ow ma ox oy aw oz bi"><span id="67cd" class="of nj iq ma b gy pa pb l pc pd">total 24<br/>drwxr-xr-x 3 root root 4096 Sep 16 11:58 0_0<br/>drwxr-xr-x 3 root root 4096 Sep 16 12:02 0_1</span></pre><blockquote class="mu mv mw"><p id="600f" class="kf kg mx kh b ki kj jr kk kl km ju kn my kp kq kr mz kt ku kv na kx ky kz la ij bi translated"><em class="iq">您可以对第二个实例重复相同的过程，即</em>T5】</p></blockquote><p id="df5e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您使用Kafka CLI列出主题的数量，您还应该看到一个名为<code class="fe lx ly lz ma b">counts-app-counts-store-changelog</code>的主题。这是我们前面讨论过的备份、日志压缩的changelog主题</p><blockquote class="mu mv mw"><p id="8ebe" class="kf kg mx kh b ki kj jr kk kl km ju kn my kp kq kr mz kt ku kv na kx ky kz la ij bi translated"><em class="iq">名称格式为</em> <code class="fe lx ly lz ma b"><em class="iq">&lt;application_name&gt;-&lt;state_store_name&gt;-changelog</em></code></p></blockquote><h1 id="7e23" class="ni nj iq bd nk nl nm nn no np nq nr ns jw nt jx nu jz nv ka nw kc nx kd ny nz bi translated">打扫</h1><p id="72a2" class="pw-post-body-paragraph kf kg iq kh b ki oa jr kk kl ob ju kn ko oc kq kr ks od ku kv kw oe ky kz la ij bi translated">首先删除<code class="fe lx ly lz ma b">StatefulSet</code>和相关的<code class="fe lx ly lz ma b">Headless</code>服务</p><pre class="nc nd ne nf gt ow ma ox oy aw oz bi"><span id="36dc" class="of nj iq ma b gy pa pb l pc pd">kubectl delete -f kstreams-count-statefulset.yaml</span></pre><p id="38f5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">与<code class="fe lx ly lz ma b">PersistentVolumeClaim</code>相关联的<code class="fe lx ly lz ma b">PersistentVolume</code>不会自动删除</p><pre class="nc nd ne nf gt ow ma ox oy aw oz bi"><span id="9375" class="of nj iq ma b gy pa pb l pc pd">kubectl delete pvc</span></pre><p id="50d9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这将触发删除<code class="fe lx ly lz ma b">PersistentVolume</code>和相应的Azure磁盘。你可以证实这一点</p><pre class="nc nd ne nf gt ow ma ox oy aw oz bi"><span id="45e8" class="of nj iq ma b gy pa pb l pc pd">kubectl get pv<br/>az disk list -g $AKS_NODE_RESOURCE_GROUP</span></pre><p id="06c2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，清理您的AKS集群、ACR实例和相关资源</p><pre class="nc nd ne nf gt ow ma ox oy aw oz bi"><span id="107c" class="of nj iq ma b gy pa pb l pc pd">az group delete --name $AZURE_RESOURCE_GROUP --yes --no-wait</span></pre><p id="7f33" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个博客到此为止！如果您觉得它有帮助，请点赞并关注:-)</p></div></div>    
</body>
</html>