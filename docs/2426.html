<html>
<head>
<title>IoT Telemetry Collection using Google Protocol Buffers, Google Cloud Functions, Cloud Pub/Sub, and MongoDB Atlas</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用谷歌协议缓冲区、谷歌云功能、云发布/订阅和MongoDB Atlas进行物联网遥测收集</h1>
<blockquote>原文：<a href="https://itnext.io/iot-telemetry-collection-using-google-protocol-buffers-cloud-functions-pub-sub-and-mongodb-atlas-d5e4ff7ef50e?source=collection_archive---------1-----------------------#2019-05-22">https://itnext.io/iot-telemetry-collection-using-google-protocol-buffers-cloud-functions-pub-sub-and-mongodb-atlas-d5e4ff7ef50e?source=collection_archive---------1-----------------------#2019-05-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/c349cdb9f4e272e4b349fb56a0fd46dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LpkJVgOKiaAJGrcOTUycnw.jpeg"/></div></div></figure><p id="7893" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="kz">使用Google Protocol Buffers的序列化二进制格式通过HTTPS、无服务器Google Cloud Functions、Google Cloud Pub/Sub和GCP的MongoDB Atlas收集物联网传感器遥测数据，作为集成云物联网平台和标准物联网协议的替代方案。使用MongoDB Compass、Jupyter Notebooks和Google的AI平台笔记本等工具聚合、分析和构建机器学习模型。</em></p><h1 id="cc86" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">介绍</h1><p id="1a07" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">大多数占主导地位的云提供商都提供物联网(物联网)和<a class="ae md" href="https://en.wikipedia.org/wiki/Industrial_Internet_of_Things" rel="noopener ugc nofollow" target="_blank"> IIotT </a>(工业物联网)集成服务。亚马逊拥有<a class="ae md" href="https://aws.amazon.com/iot/" rel="noopener ugc nofollow" target="_blank"> AWS物联网</a>，微软Azure拥有包括<a class="ae md" href="https://azure.microsoft.com/en-us/services/iot-central/" rel="noopener ugc nofollow" target="_blank">物联网中心</a>在内的多种产品，IBM的产品包括<a class="ae md" href="https://www.ibm.com/cloud/internet-of-things" rel="noopener ugc nofollow" target="_blank"> IBM Watson物联网平台</a>，阿里云拥有针对不同垂直市场的多种<a class="ae md" href="https://www.alibabacloud.com/solutions/IoT" rel="noopener ugc nofollow" target="_blank">物联网/IIoT解决方案</a>，谷歌提供<a class="ae md" href="https://cloud.google.com/solutions/iot/" rel="noopener ugc nofollow" target="_blank">谷歌云物联网</a>平台。所有这些解决方案都作为工业级、高性能、可扩展的技术堆栈进行销售。它们能够扩展到成千上万的物联网设备或更多设备，以及海量的流遥测。</p><p id="8d17" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在现实中，并不是每个人都需要完全集成的物联网解决方案。学术机构、研究实验室、科技初创企业和许多商业企业希望将云用于物联网应用，但可能尚未准备好完全集成的物联网平台，或者抵制云供应商平台锁定。</p><p id="6f55" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">同样，根据性能要求和应用类型，组织可能不需要或不想使用物联网/IIOT行业标准数据和传输协议，如<a class="ae md" href="http://mqtt.org/" rel="noopener ugc nofollow" target="_blank"> MQTT </a>(消息队列遥测传输)或<a class="ae md" href="https://coap.technology/" rel="noopener ugc nofollow" target="_blank"> CoAP </a>(受限应用协议)，而不是<a class="ae md" href="https://en.wikipedia.org/wiki/User_Datagram_Protocol" rel="noopener ugc nofollow" target="_blank"> UDP </a>(用户数据报协议)。他们可能更喜欢使用TCP通过HTTP传输遥测数据，或者安全地使用<a class="ae md" href="https://en.wikipedia.org/wiki/HTTPS" rel="noopener ugc nofollow" target="_blank"> HTTPS </a> (HTTP over TLS)。</p><h1 id="45cb" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">示范</h1><p id="a6ff" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">在本次演示中，我们将从大量物联网设备传感器收集环境传感器数据，并通过互联网将遥测数据传输到谷歌云。每个物联网设备安装在不同的物理位置。这些设备包含各种常见的传感器，包括湿度和温度、运动和光强。</p><figure class="mf mg mh mi gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi me"><img src="../Images/6bc3a74b01e8a833faf7ec04b6570056.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t3ZLC5wjCaJ2OlqBL7QPWQ.jpeg"/></div></div><figcaption class="mj mk gj gh gi ml mm bd b be z dk translated">本次演示中使用的原型物联网设备</figcaption></figure><p id="95c6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将通过HTTP将传感器遥测数据作为JSON传输到无服务器的谷歌云功能HTTPS端点。然后，我们将转而使用Google的协议缓冲区通过HTTP传输二进制数据。当我们从JSON迁移到Protobuf时，我们应该观察到请求负载中包含的消息大小有所减少，这应该会减少系统延迟和成本。</p><p id="6adc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">云函数通过HTTP接收的数据将异步发布到Google Cloud Pub/Sub。第二个云功能将响应所有发布的事件，并将消息推送到GCP上的MongoDB Atlas。一旦进入Atlas，我们将使用MongoDB Compass、Jupyter笔记本和谷歌的AI平台笔记本等工具，对数据进行聚合、转换、分析和构建机器学习模型。</p><p id="b6e1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于这个演示，HTTP上的JSON的架构如下所示。所有传感器将数据传输到一个单一的云功能HTTPS端点。</p><figure class="mf mg mh mi gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mn"><img src="../Images/e8a705ace20c94e5c1e5626706fb85f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3JqN30t8qxE3QLM-N3NdtQ.png"/></div></div></figure><p id="9bd1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于HTTP上的Protobuf，该架构在演示中将如下所示。每种类型的传感器将数据传输到不同的云功能HTTPS端点。</p><figure class="mf mg mh mi gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mn"><img src="../Images/83e3c151c3f0f2dd3b9de8f3ff192d8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-DYryMhFJSGjeOb8377v-Q.png"/></div></div></figure><p id="aa07" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">虽然云功能会自动水平扩展，以适应接收的遥测数据量所产生的额外负载，但也有其他选项来扩展系统。例如，我们可以为每种传感器类型创建单独的函数和主题/订阅管道。我们还可以根据传感器类型将遥测数据分割成多个MongoDB Atlas集合，而不是一个集合。在所有情况下，我们仍将受益于云功能的水平扩展能力。</p><figure class="mf mg mh mi gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mn"><img src="../Images/c04898f75131fd211a751d3ca05b9966.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IETmR-R18TDSsfLx-290eQ.png"/></div></div></figure><h1 id="b198" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">源代码</h1><p id="f287" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">所有的源代码都可以在GitHub上找到。使用以下命令克隆项目。</p><pre class="mf mg mh mi gt mo mp mq mr aw ms bi"><span id="c36e" class="mt lb it mp b gy mu mv l mw mx">git clone \<br/>  --branch master --single-branch --depth 1 --no-tags \<br/>  <a class="ae md" href="https://github.com/garystafford/iot-protobuf-demo.git" rel="noopener ugc nofollow" target="_blank">https://github.com/garystafford/iot-protobuf-demo.git</a></span></pre><p id="b977" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您需要调整项目的环境变量，以适应您自己的开发和云环境。这篇文章的所有源代码都是用Python写的。它是为Python 3解释器设计的，但是已经使用Python 2解释器进行了测试。该项目的Jupyter笔记本可以在GitHub上的项目中查看，或者使用免费的在线Jupyter <a class="ae md" href="https://nbviewer.jupyter.org/" rel="noopener ugc nofollow" target="_blank"> nbviewer </a>查看。</p><figure class="mf mg mh mi gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi my"><img src="../Images/27700d82f8e305812e17a62dc57402e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q1W6RP9CZgrA_Pjuw3tRPQ.png"/></div></div></figure><h1 id="79f5" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">技术</h1><h2 id="d12e" class="mt lb it bd lc mz na dn lg nb nc dp lk km nd ne lo kq nf ng ls ku nh ni lw nj bi translated">协议缓冲区</h2><p id="3b2c" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">根据Google的说法，<a class="ae md" href="https://developers.google.com/protocol-buffers/" rel="noopener ugc nofollow" target="_blank">协议缓冲区</a> ( <em class="kz">又名Protobuf </em>)是一种语言和平台中立的、高效的、可扩展的自动化机制，用于序列化结构化数据，以用于通信协议、数据存储等。协议缓冲区比XML小3到10倍，快20到100倍。</p><p id="9782" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">每个协议缓冲区消息都是一个小的信息逻辑记录，包含一系列强类型的名称-值对。一旦您定义了消息，您就可以在您的<code class="fe nk nl nm mp b">.proto</code>文件上运行针对您的应用程序语言的<a class="ae md" href="https://developers.google.com/protocol-buffers/docs/encoding" rel="noopener ugc nofollow" target="_blank">协议缓冲编译器</a>来生成数据访问类。</p><h2 id="08f7" class="mt lb it bd lc mz na dn lg nb nc dp lk km nd ne lo kq nf ng ls ku nh ni lw nj bi translated">谷歌云功能</h2><p id="fcb6" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">据谷歌称，<a class="ae md" href="https://cloud.google.com/functions/features/" rel="noopener ugc nofollow" target="_blank">云功能</a>是谷歌的事件驱动、无服务器计算平台。云功能的关键特性包括自动扩展、高可用性、容错、<br/>无需供应、管理、修补或更新服务器，只需<br/>在代码运行时付费，并且它们可以轻松连接和扩展其他云服务。云功能本身支持多种事件类型，包括HTTP、云发布/订阅、云存储和Firebase。目前的语言支持包括Python、Go和Node。</p><h2 id="25bc" class="mt lb it bd lc mz na dn lg nb nc dp lk km nd ne lo kq nf ng ls ku nh ni lw nj bi translated">谷歌云发布/订阅</h2><p id="4bcd" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">根据Google的说法，<a class="ae md" href="https://cloud.google.com/pubsub/docs/overview" rel="noopener ugc nofollow" target="_blank"> Cloud Pub/Sub </a>是一个面向云的企业消息中间件。这是一个可扩展的、持久的事件接收和交付系统。通过提供多对多的异步消息传递，使发送方和接收方分离，它允许独立应用程序之间进行安全和高度可用的通信。云发布/订阅提供低延迟、持久的消息传递，与Google云平台和外部托管的系统集成。</p><h2 id="2194" class="mt lb it bd lc mz na dn lg nb nc dp lk km nd ne lo kq nf ng ls ku nh ni lw nj bi translated">MongoDB地图集</h2><p id="8259" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated"><a class="ae md" href="https://www.mongodb.com/cloud/atlas" rel="noopener ugc nofollow" target="_blank"> MongoDB Atlas </a>是一个完全托管的MongoDB即服务，可在AWS、Azure和GCP上使用。Atlas是一款成熟的SaaS产品，提供高可用性、正常运行时间服务级别协议、弹性可伸缩性、跨区域复制、企业级安全性、LDAP集成、BI连接器等等。</p><p id="7b57" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">MongoDB Atlas目前提供四种<a class="ae md" href="https://www.mongodb.com/cloud/atlas/pricing" rel="noopener ugc nofollow" target="_blank">定价方案</a>，免费、基础、专业和企业。计划范围从最小的、免费的M0大小的MongoDB集群，具有共享RAM和512 MB存储，到大规模的M400 MongoDB集群，具有488 GB的RAM和3 TB的存储。</p><h1 id="ff75" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">云功能的成本效益</h1><p id="aaac" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">在真正的IIoT规模上，谷歌云功能可能不是摄取遥测数据的最高效或最具成本效益的方法。根据谷歌的<a class="ae md" href="https://cloud.google.com/functions/pricing" rel="noopener ugc nofollow" target="_blank">定价模型</a>，你每月可以获得200万次免费的函数调用，每增加100万次调用需要花费0.40美元。总成本还包括内存使用、总计算时间和出站数据传输。如果您的系统由数十或数百个物联网设备组成，云功能可能会证明具有成本效益。</p><p id="1bb9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然而，随着数以千计的设备或更多，每个设备每分钟传输数据多次，你可能很快就会超出谷歌功能的成本效益。在这种情况下，你可能会考虑谷歌的<a class="ae md" href="https://cloud.google.com/solutions/iot/" rel="noopener ugc nofollow" target="_blank">谷歌云物联网</a>平台。或者，你可以用谷歌的产品，如<a class="ae md" href="https://knative.dev/" rel="noopener ugc nofollow" target="_blank"> Knative </a>来构建自己的平台，让你选择使用新发布的<a class="ae md" href="https://cloud.google.com/run/" rel="noopener ugc nofollow" target="_blank"> Cloud Run </a>来完全管理你的容器，或者在你的谷歌Kubernetes引擎集群中使用GKE上的Cloud Run。</p><h1 id="d00f" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">传感器脚本</h1><p id="eaaf" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">对于每种传感器类型，我都开发了单独的Python脚本，在每种物联网设备上运行。每个脚本有两个版本，一个用于HTTP上的JSON，一个用于HTTP上的Protobuf。</p><h1 id="ff35" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">HTTPS上空的JSON</h1><p id="c9ba" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">下面我们看到这个脚本，<a class="ae md" href="https://github.com/garystafford/iot-protobuf-demo/blob/master/sensor_scripts/dht_sensor_http_json.py" rel="noopener ugc nofollow" target="_blank"> dht_sensor_http_json.py </a>，用于通过JSON over HTTP将湿度和温度数据传输到运行在GCP上的Google Cloud函数。JSON请求有效载荷包含时间戳、物联网设备ID、设备类型以及温度和湿度传感器读数。Google Cloud功能的URL存储为环境变量，位于物联网设备的本地，并在部署脚本时设置。</p><pre class="mf mg mh mi gt mo mp mq mr aw ms bi"><span id="4abb" class="mt lb it mp b gy mu mv l mw mx">import json<br/>import logging<br/>import os<br/>import socket<br/>import sys<br/>import time</span><span id="47d6" class="mt lb it mp b gy nn mv l mw mx">import Adafruit_DHT<br/>import requests</span><span id="2a16" class="mt lb it mp b gy nn mv l mw mx"><strong class="mp iu">URL = os.environ.get('GCF_URL')<br/></strong>JWT = os.environ.get('JWT')<br/>SENSOR = Adafruit_DHT.DHT22<br/>TYPE = 'DHT22'<br/>PIN = 18<br/>FREQUENCY = 15<br/></span><span id="86d7" class="mt lb it mp b gy nn mv l mw mx">def main():<br/>    if not URL or not JWT:<br/>        sys.exit("Are the Environment Variables set?")<br/>    get_sensor_data(socket.gethostname())<br/></span><span id="1d58" class="mt lb it mp b gy nn mv l mw mx">def get_sensor_data(device_id):<br/>    while True:<br/>        humidity, temperature = Adafruit_DHT.read_retry(SENSOR, PIN)<br/>        payload = {'device': device_id,<br/>                   'type': TYPE,<br/>                   'timestamp': time.time(),<br/>                   'data': {'temperature': temperature,<br/>                            'humidity': humidity}}<br/>        post_data(payload)<br/>        time.sleep(FREQUENCY)<br/></span><span id="a922" class="mt lb it mp b gy nn mv l mw mx">def post_data(payload):<br/>    payload = json.dumps(payload)</span><span id="7347" class="mt lb it mp b gy nn mv l mw mx">    headers = {<br/>        'Content-Type': 'application/json; charset=utf-8',<br/>        'Authorization': JWT<br/>    }</span><span id="1872" class="mt lb it mp b gy nn mv l mw mx">    try:<br/>        requests.post(URL, json=payload, headers=headers)<br/>    except requests.exceptions.ConnectionError:<br/>        logging.error('Error posting data to Cloud Function!')<br/>    except requests.exceptions.MissingSchema:<br/>        logging.error('Error posting data to Cloud Function! Are Environment Variables set?')<br/></span><span id="dbf7" class="mt lb it mp b gy nn mv l mw mx">if __name__ == '__main__':<br/>    sys.exit(main())</span></pre><h2 id="223c" class="mt lb it bd lc mz na dn lg nb nc dp lk km nd ne lo kq nf ng ls ku nh ni lw nj bi translated">遥测频带</h2><p id="db48" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">尽管传感器能够每分钟产生多次数据，但在本次演示中，传感器遥测被有意限制为每15秒传输一次。在我看来，为了降低系统复杂性、潜在延迟、背压和成本，你应该只在你的要求所规定的频率下产生遥测数据。</p><h2 id="70d3" class="mt lb it bd lc mz na dn lg nb nc dp lk km nd ne lo kq nf ng ls ku nh ni lw nj bi translated">JSON Web令牌</h2><p id="596f" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">为了安全起见，除了Google Cloud函数暴露的HTTPS端点之外，我还使用了一个<a class="ae md" href="https://jwt.io/" rel="noopener ugc nofollow" target="_blank"> JSON Web令牌</a> (JWT)。JSON Web令牌是一种开放的行业标准RFC 7519方法，用于安全地表示双方之间的声明。在这种情况下，JWT用于验证向云功能发送遥测数据的传感器脚本的身份。JWT包含id、密码和有效期，所有这些都用密钥加密，每个云功能都知道该密钥，以便验证物联网设备的身份。如果没有在授权头中传递正确的JWT，对云函数的请求将失败，HTTP状态代码为401 Unauthorized。下面是JWT有效载荷数据的一个例子。</p><pre class="mf mg mh mi gt mo mp mq mr aw ms bi"><span id="d33f" class="mt lb it mp b gy mu mv l mw mx">{<br/>  "sub": "IoT Protobuf Serverless Demo",<br/>  "id": "iot-demo-key",<br/>  "password": "t7J2gaQHCFcxMD6584XEpXyzWhZwRrNJ",<br/>  "iat": 1557407124,<br/>  "exp": 1564664724<br/>}</span></pre><p id="4e7f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这个演示中，我使用jwt.io 创建了一个临时JWT。HTTP函数使用的是<code class="fe nk nl nm mp b">PyJWT</code>，这是一个Python库，允许您对JWT进行编码和解码。<a class="ae md" href="https://pyjwt.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank"> PyJWT </a>库允许该函数从传入请求的授权头中解码并验证JWT(承载令牌)。JWT令牌存储为环境变量。部署说明包含在GitHub <a class="ae md" href="https://github.com/garystafford/iot-protobuf-demo/blob/master/sensor_scripts/deployment_instructions.md" rel="noopener ugc nofollow" target="_blank">项目</a>中。</p><figure class="mf mg mh mi gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi my"><img src="../Images/d1341de23c8ff75866f3a4eaefdd5a6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SaJjxjQIjVKjTRcoQYzMkA.png"/></div></div></figure><h2 id="d250" class="mt lb it bd lc mz na dn lg nb nc dp lk km nd ne lo kq nf ng ls ku nh ni lw nj bi translated">JSON有效负载</h2><p id="0e45" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">下面是一个典型的JSON请求有效负载(漂亮打印的)，包含DHT传感器数据。这一特定消息的大小为148字节。消息格式是有意为读者友好的。我们当然可以缩短消息的关键字段，以额外减少15-20个字节的有效载荷。</p><pre class="mf mg mh mi gt mo mp mq mr aw ms bi"><span id="daf4" class="mt lb it mp b gy mu mv l mw mx">{<br/>  "device": "rp829c7e0e",<br/>  "type": "DHT22",<br/>  "timestamp": 1557585090.476025,<br/>  "data": {<br/>    "temperature": 17.100000381469727,<br/>    "humidity": 68.0999984741211<br/>  }<br/>}</span></pre><h1 id="761a" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">协议缓冲区</h1><p id="6cb8" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">为了演示，我构建了一个协议缓冲文件<code class="fe nk nl nm mp b"><a class="ae md" href="https://github.com/garystafford/iot-protobuf-demo/blob/master/sensors_pb/sensors.proto" rel="noopener ugc nofollow" target="_blank">sensors.proto</a></code>，以支持三种传感器类型的数据输出:数字湿度和温度(DHT)<a class="ae md" href="https://en.wikipedia.org/wiki/Passive_infrared_sensor" rel="noopener ugc nofollow" target="_blank">、无源红外传感器</a> (PIR)和数字光强(DLI)。我正在使用新的<code class="fe nk nl nm mp b"><a class="ae md" href="https://developers.google.com/protocol-buffers/docs/proto3" rel="noopener ugc nofollow" target="_blank">proto3</a></code>版本的协议缓冲语言。我已经创建了一个通用的Protobuf传感器消息模式，在每种消息类型中，变量sensor telemetry存储在嵌套的<code class="fe nk nl nm mp b">data</code>对象中。</p><blockquote class="no"><p id="ff54" class="np nq it bd nr ns nt nu nv nw nx ky dk translated">协议缓冲区比XML小3到10倍，快20到100倍。</p></blockquote><p id="7ad5" class="pw-post-body-paragraph kb kc it kd b ke ny kg kh ki nz kk kl km oa ko kp kq ob ks kt ku oc kw kx ky im bi translated">使用正确的Protobuf <a class="ae md" href="https://developers.google.com/protocol-buffers/docs/proto3#scalar" rel="noopener ugc nofollow" target="_blank">标量值类型</a>来保持编译语言的数值精度是很重要的。为了简单起见，我使用一个<code class="fe nk nl nm mp b">double</code>来表示时间戳，以及湿度和温度的数字读数。或者，您可以选择Google的Protobuf <code class="fe nk nl nm mp b">WellKnownTypes</code>，<a class="ae md" href="https://developers.google.com/protocol-buffers/docs/reference/csharp/class/google/protobuf/well-known-types/timestamp" rel="noopener ugc nofollow" target="_blank"> Timestamp </a>来存储时间戳。</p><pre class="mf mg mh mi gt mo mp mq mr aw ms bi"><span id="9bf4" class="mt lb it mp b gy mu mv l mw mx">syntax = "proto3";</span><span id="34dd" class="mt lb it mp b gy nn mv l mw mx">package sensors;</span><span id="1420" class="mt lb it mp b gy nn mv l mw mx">// DHT22<br/>message SensorDHT {<br/>    string device = 1;<br/>    string type = 2;<br/>    double timestamp = 3;<br/>    DataDHT data = 4;<br/>}</span><span id="70cc" class="mt lb it mp b gy nn mv l mw mx">message DataDHT {<br/>    double temperature = 1;<br/>    double humidity = 2;<br/>}</span><span id="e0b5" class="mt lb it mp b gy nn mv l mw mx">// Onyehn_PIR<br/>message SensorPIR {<br/>    string device = 1;<br/>    string type = 2;<br/>    double timestamp = 3;<br/>    DataPIR data = 4;<br/>}</span><span id="3106" class="mt lb it mp b gy nn mv l mw mx">message DataPIR {<br/>    bool motion = 1;<br/>}</span><span id="10d0" class="mt lb it mp b gy nn mv l mw mx">// Anmbest_MD46N<br/>message SensorDLI {<br/>    string device = 1;<br/>    string type = 2;<br/>    double timestamp = 3;<br/>    DataDLI data = 4;<br/>}</span><span id="37b5" class="mt lb it mp b gy nn mv l mw mx">message DataDLI {<br/>    bool light = 1;<br/>}</span></pre><p id="6c1e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">由于传感器数据将使用Python 3编写的脚本来捕获，因此为Python编译了协议缓冲文件，生成了文件<code class="fe nk nl nm mp b"><a class="ae md" href="https://github.com/garystafford/iot-protobuf-demo/blob/master/sensors_pb/sensors_pb2.py" rel="noopener ugc nofollow" target="_blank">sensors_pb2.py</a></code>。</p><pre class="mf mg mh mi gt mo mp mq mr aw ms bi"><span id="5308" class="mt lb it mp b gy mu mv l mw mx">protoc --python_out=. sensors.proto</span></pre><h1 id="444e" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">HTTPS上的协议缓冲区</h1><p id="be80" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">下面我们看到另一个DHT传感器脚本，<a class="ae md" href="https://github.com/garystafford/iot-protobuf-demo/blob/master/sensor_scripts/dht_sensor_http_pb.py" rel="noopener ugc nofollow" target="_blank"> dht_sensor_http_pb.py </a>，它通过HTTPS将一个基于协议缓冲区的二进制请求有效载荷传输到运行在GCP上的Google Cloud函数。请注意，请求的<code class="fe nk nl nm mp b">Content-Type</code>标题已从<code class="fe nk nl nm mp b">application/json</code>更改为<code class="fe nk nl nm mp b">application/x-protobuf</code>。在这种情况下，相同的数据字段存储在Protobuf的<code class="fe nk nl nm mp b">SensorDHT</code>消息类型(<code class="fe nk nl nm mp b">sensors_pb2.SensorDHT()</code>)的实例中，而不是JSON。注意<code class="fe nk nl nm mp b">import sensors_pb2</code>语句。该语句导入编译后的协议缓冲文件，该文件存储在物联网设备的本地脚本中。</p><pre class="mf mg mh mi gt mo mp mq mr aw ms bi"><span id="3d9e" class="mt lb it mp b gy mu mv l mw mx">import logging<br/>import os<br/>import socket<br/>import sys<br/>import time</span><span id="3f75" class="mt lb it mp b gy nn mv l mw mx">import Adafruit_DHT<br/>import requests<br/><strong class="mp iu">import sensors_pb2</strong></span><span id="99cd" class="mt lb it mp b gy nn mv l mw mx">URL = os.environ.get('GCF_DHT_URL')<br/>JWT = os.environ.get('JWT')<br/>SENSOR = Adafruit_DHT.DHT22<br/>TYPE = 'DHT22'<br/>PIN = 18<br/>FREQUENCY = 15<br/></span><span id="9174" class="mt lb it mp b gy nn mv l mw mx">def main():<br/>    if not URL or not JWT:<br/>        sys.exit("Are the Environment Variables set?")<br/>    get_sensor_data(socket.gethostname())<br/></span><span id="21f6" class="mt lb it mp b gy nn mv l mw mx">def get_sensor_data(device_id):<br/>    while True:<br/>        try:<br/>            humidity, temperature = Adafruit_DHT.read_retry(SENSOR, PIN)</span><span id="b72d" class="mt lb it mp b gy nn mv l mw mx"><strong class="mp iu">            sensor_dht = sensors_pb2.SensorDHT()</strong><br/>            sensor_dht.device = device_id<br/>            sensor_dht.type = TYPE<br/>            sensor_dht.timestamp = time.time()<br/>            sensor_dht.data.temperature = temperature<br/>            sensor_dht.data.humidity = humidity</span><span id="8aef" class="mt lb it mp b gy nn mv l mw mx">            payload = sensor_dht.SerializeToString()</span><span id="2790" class="mt lb it mp b gy nn mv l mw mx">            post_data(payload)<br/>            time.sleep(FREQUENCY)<br/>        except TypeError:<br/>            logging.error('Error getting sensor data!')<br/></span><span id="76f6" class="mt lb it mp b gy nn mv l mw mx">def post_data(payload):<br/>    headers = {<br/><strong class="mp iu">        'Content-Type': 'application/x-protobuf',</strong><br/>        'Authorization': JWT<br/>    }</span><span id="71ad" class="mt lb it mp b gy nn mv l mw mx">    try:<br/>        requests.post(URL, data=payload, headers=headers)<br/>    except requests.exceptions.ConnectionError:<br/>        logging.error('Error posting data to Cloud Function!')<br/>    except requests.exceptions.MissingSchema:<br/>        logging.error('Error posting data to Cloud Function! Are Environment Variables set?')<br/></span><span id="fe3c" class="mt lb it mp b gy nn mv l mw mx">if __name__ == '__main__':<br/>    sys.exit(main())</span></pre><h2 id="fed0" class="mt lb it bd lc mz na dn lg nb nc dp lk km nd ne lo kq nf ng ls ku nh ni lw nj bi translated">Protobuf二进制负载</h2><p id="be57" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">为了理解基于二进制协议缓冲区的有效负载，我们可以将示例<code class="fe nk nl nm mp b">SensorDHT</code>消息作为字节数组写入磁盘上的文件。</p><pre class="mf mg mh mi gt mo mp mq mr aw ms bi"><span id="b03f" class="mt lb it mp b gy mu mv l mw mx">message = sensorDHT.SerializeToString()</span><span id="e326" class="mt lb it mp b gy nn mv l mw mx">binary_file_output = open("./data_binary.txt", "wb")<br/>file_byte_array = bytearray(message)<br/>binary_file_output.write(file_byte_array)</span></pre><p id="ec07" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后，使用<code class="fe nk nl nm mp b">hexdump</code>命令，我们可以查看二进制数据文件的表示。</p><pre class="mf mg mh mi gt mo mp mq mr aw ms bi"><span id="c720" class="mt lb it mp b gy mu mv l mw mx">&gt; hexdump -C data_binary.txt<br/>00000000  0a 08 38 32 39 63 37 65  30 65 12 05 44 48 54 32  |..829c7e0e..DHT2|<br/>00000010  32 1d 05 a0 b9 4e 22 0a  0d ec 51 b2 41 15 cd cc  |2....N"...Q.A...|<br/>00000020  38 42                                             |8B|<br/>00000022</span></pre><p id="ff7e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">二进制数据文件在磁盘上的大小是48字节，相比之下，等效的JSON文件在磁盘上的大小是148字节(大小的32%)。作为测试，我们可以将二进制数据文件作为POST的有效负载发送到云函数，如下所示使用Postman。在传输之前，Postman会将二进制数据文件的内容序列化为二进制字符串。</p><figure class="mf mg mh mi gt ju gh gi paragraph-image"><div class="gh gi od"><img src="../Images/cdf92805ab2c44e84e1969f4a70fe991.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*Tr9g1qho85QiL5EW"/></div></figure><p id="d793" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">类似地，我们可以使用<code class="fe nk nl nm mp b">SerializeToString</code>方法将相同的基于二进制协议缓冲区的<code class="fe nk nl nm mp b">SensorDHT</code>消息序列化为二进制字符串。</p><pre class="mf mg mh mi gt mo mp mq mr aw ms bi"><span id="16b4" class="mt lb it mp b gy mu mv l mw mx">message = sensorDHT.SerializeToString()<br/>print(message)</span></pre><p id="783e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">生成的二进制字符串如下所示。</p><pre class="mf mg mh mi gt mo mp mq mr aw ms bi"><span id="b44d" class="mt lb it mp b gy mu mv l mw mx">b'\n\nrp829c7e0e\x12\x05DHT22\x19c\xee\xbcg\xf5\x8e\xccA"\x12\t\x00\x00\x00\xa0\x99\x191@\x11\x00\x00\x00`f\x06Q@'</span></pre><p id="5227" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">序列化消息的二进制字符串长度是111个字节，因此由Postman发送并由云函数接收的请求有效负载是148个字节，与之相比，JSON有效负载的大小是148个字节(大小的75%)。</p><h2 id="0eed" class="mt lb it bd lc mz na dn lg nb nc dp lk km nd ne lo kq nf ng ls ku nh ni lw nj bi translated">验证Protobuf有效负载</h2><p id="6d7f" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">为了验证Protobuf有效载荷中包含的数据是否与JSON有效载荷相同，我们可以使用Protobuf <code class="fe nk nl nm mp b">ParseFromString</code>方法从序列化的二进制字符串中解析有效载荷。然后我们使用Protobuf <code class="fe nk nl nm mp b">MessageToJson</code>方法将其转换成JSON。</p><pre class="mf mg mh mi gt mo mp mq mr aw ms bi"><span id="250d" class="mt lb it mp b gy mu mv l mw mx">message = sensorDHT.SerializeToString() <br/>message_parsed = sensors_pb2.SensorDHT()<br/>message_parsed.ParseFromString(message)<br/>print(MessageToJson(message_parsed))</span></pre><p id="1e1e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">产生的JSON对象与前面演示中使用JSON over HTTPS发送的JSON有效负载相同。</p><pre class="mf mg mh mi gt mo mp mq mr aw ms bi"><span id="8183" class="mt lb it mp b gy mu mv l mw mx">{<br/>  "device": "rp829c7e0e",<br/>  "type": "DHT22",<br/>  "timestamp": 1557585090.476025,<br/>  "data": {<br/>    "temperature": 17.100000381469727,<br/>    "humidity": 68.0999984741211<br/>  }<br/>}</span></pre><h1 id="9fe8" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">谷歌云功能</h1><p id="04ae" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">谷歌云有一系列功能，特别是四个<a class="ae md" href="https://cloud.google.com/functions/docs/writing/http" rel="noopener ugc nofollow" target="_blank"> HTTP功能</a>，通过HTTP从物联网设备接受传感器数据。每个函数公开一个HTTPS端点。根据Google的说法，当你想通过HTTP(S)请求调用你的函数时，你可以使用HTTP函数。为了允许HTTP语义，HTTP函数签名接受HTTP特定的参数。</p><p id="56d8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下面，我部署了一个接受来自所有传感器类型的JSON传感器遥测的函数，以及Protobuf的三个函数，每个传感器类型一个:DHT、PIR和DLI。</p><figure class="mf mg mh mi gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi od"><img src="../Images/ad916745980a2f432e2f00182d066070.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*ODssBQSlBofrtb0n"/></div></div></figure><h2 id="db45" class="mt lb it bd lc mz na dn lg nb nc dp lk km nd ne lo kq nf ng ls ku nh ni lw nj bi translated">JSON消息处理</h2><p id="cfe1" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">下面，我们看到云函数<a class="ae md" href="https://github.com/garystafford/iot-protobuf-demo/blob/master/cloud_functions/http_json_to_pubsub/main.py" rel="noopener ugc nofollow" target="_blank"> main.py </a>，它处理来自所有传感器类型的传入JSON over HTTPS有效载荷。一旦请求的JWT得到验证，JSON消息有效负载就被序列化为一个字节字符串，并发送到一个常见的Google Cloud发布/订阅主题。请注意，JWT密钥、id和密码以及Google Cloud发布/订阅主题都作为环境变量存储在云函数的本地。在我的测试中，成功执行基于JSON的HTTP函数平均需要9–18毫秒。</p><pre class="mf mg mh mi gt mo mp mq mr aw ms bi"><span id="d9cc" class="mt lb it mp b gy mu mv l mw mx">import logging<br/>import os</span><span id="1b27" class="mt lb it mp b gy nn mv l mw mx">import jwt<br/>from flask import make_response, jsonify<br/>from flask_api import status<br/>from google.cloud import pubsub_v1</span><span id="4b00" class="mt lb it mp b gy nn mv l mw mx">TOPIC = os.environ.get('TOPIC')<br/>SECRET_KEY = os.getenv('SECRET_KEY')<br/>ID = os.getenv('ID')<br/>PASSWORD = os.getenv('PASSWORD')<br/></span><span id="61cd" class="mt lb it mp b gy nn mv l mw mx">def incoming_message(request):<br/>    if not validate_token(request):<br/>        return make_response(jsonify({'success': False}),<br/>                             status.HTTP_401_UNAUTHORIZED,<br/>                             {'ContentType': 'application/json'})</span><span id="1bdd" class="mt lb it mp b gy nn mv l mw mx">    request_json = request.get_json()<br/>    if not request_json:<br/>        return make_response(jsonify({'success': False}),<br/>                             status.HTTP_400_BAD_REQUEST,<br/>                             {'ContentType': 'application/json'})</span><span id="5ef2" class="mt lb it mp b gy nn mv l mw mx">    send_message(request_json)</span><span id="0035" class="mt lb it mp b gy nn mv l mw mx">    return make_response(jsonify({'success': True}),<br/>                         status.HTTP_201_CREATED,<br/>                         {'ContentType': 'application/json'})<br/></span><span id="6f5c" class="mt lb it mp b gy nn mv l mw mx">def validate_token(request):<br/>    auth_header = request.headers.get('Authorization')<br/>    if not auth_header:<br/>        return False<br/>    auth_token = auth_header.split(" ")[1]</span><span id="783d" class="mt lb it mp b gy nn mv l mw mx">    if not auth_token:<br/>        return False<br/>    try:<br/>        payload = jwt.decode(auth_token, SECRET_KEY)<br/>        if payload['id'] == ID and payload['password'] == PASSWORD:<br/>            return True<br/>    except jwt.ExpiredSignatureError:<br/>        return False<br/>    except jwt.InvalidTokenError:<br/>        return False<br/></span><span id="a8bc" class="mt lb it mp b gy nn mv l mw mx">def send_message(message):<br/>    publisher = pubsub_v1.PublisherClient()<br/>    publisher.publish(topic=TOPIC, <br/>                      data=bytes(str(message), 'utf-8'))</span></pre><p id="6402" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用<code class="fe nk nl nm mp b">gcloud functions deploy</code> CLI命令将云功能部署到GCP(我使用Jenkins来自动化部署)。我已经将部署命令包装到bash脚本中。该脚本还复制了一个通用环境变量YAML文件，由云函数使用。每个功能都有一个<a class="ae md" href="https://github.com/garystafford/iot-protobuf-demo/blob/master/cloud_functions/http_json_to_pubsub/deploy_function.sh" rel="noopener ugc nofollow" target="_blank">部署脚本</a>，包含在项目中。</p><pre class="mf mg mh mi gt mo mp mq mr aw ms bi"><span id="b54c" class="mt lb it mp b gy mu mv l mw mx"># get latest env vars file<br/>cp -f ./../env_vars_file/env.yaml .</span><span id="77d1" class="mt lb it mp b gy nn mv l mw mx"># deploy function<br/>gcloud functions deploy http_json_to_pubsub \<br/>  --runtime python37 \<br/>  --trigger-http \<br/>  --region us-central1 \<br/>  --memory 256 \<br/>  --entry-point incoming_message \<br/><strong class="mp iu">  --env-vars-file env.yaml</strong></span></pre><p id="9313" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用一个<code class="fe nk nl nm mp b"><a class="ae md" href="https://github.com/garystafford/iot-protobuf-demo/blob/master/cloud_functions/http_pb_dht_to_pubsub/.gcloudignore" rel="noopener ugc nofollow" target="_blank">.gcloudignore</a></code>文件，<code class="fe nk nl nm mp b">gcloud functions deploy</code> CLI命令部署三个文件:云函数(<code class="fe nk nl nm mp b">main.py</code>)、必需的Python包文件(<code class="fe nk nl nm mp b">requirements.txt</code>)、环境变量文件(<code class="fe nk nl nm mp b">env.yaml</code>)。Google使用<code class="fe nk nl nm mp b"><a class="ae md" href="https://github.com/garystafford/iot-protobuf-demo/blob/master/cloud_functions/http_pb_dht_to_pubsub/requirements.txt" rel="noopener ugc nofollow" target="_blank">requirements.txt</a></code>文件自动安装依赖项。</p><h2 id="b067" class="mt lb it bd lc mz na dn lg nb nc dp lk km nd ne lo kq nf ng ls ku nh ni lw nj bi translated">Protobuf消息处理</h2><p id="1310" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">下面，我们看到云函数，<a class="ae md" href="https://github.com/garystafford/iot-protobuf-demo/blob/master/cloud_functions/http_pb_dht_to_pubsub/main.py" rel="noopener ugc nofollow" target="_blank"> main.py </a>，它处理来自DHT传感器类型的传入Protobuf over HTTPS有效载荷。HTTP函数收到传感器数据Protobuf消息有效负载后，会将其反序列化为JSON，然后序列化为一个字节字符串。然后，该字节串被发送到Google Cloud发布/订阅主题。在我的测试中，基于Protobuf的HTTP函数平均需要7-14毫秒才能成功执行。</p><p id="ac42" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">和以前一样，注意<code class="fe nk nl nm mp b">import sensors_pb2</code>语句。该语句导入编译后的协议缓冲文件，该文件存储在物联网设备的本地脚本中。它用于将序列化的消息解析成其原始的Protobuf的<code class="fe nk nl nm mp b">SensorDHT</code>消息类型。</p><pre class="mf mg mh mi gt mo mp mq mr aw ms bi"><span id="f3dd" class="mt lb it mp b gy mu mv l mw mx">import logging<br/>import os</span><span id="2e43" class="mt lb it mp b gy nn mv l mw mx">import jwt<br/><strong class="mp iu">import sensors_pb2</strong><br/>from flask import make_response, jsonify<br/>from flask_api import status<br/>from google.cloud import pubsub_v1<br/>from google.protobuf.json_format import MessageToJson</span><span id="9549" class="mt lb it mp b gy nn mv l mw mx">TOPIC = os.environ.get('TOPIC')<br/>SECRET_KEY = os.getenv('SECRET_KEY')<br/>ID = os.getenv('ID')<br/>PASSWORD = os.getenv('PASSWORD')<br/></span><span id="2426" class="mt lb it mp b gy nn mv l mw mx">def incoming_message(request):<br/>    if not validate_token(request):<br/>        return make_response(jsonify({'success': False}),<br/>                             status.HTTP_401_UNAUTHORIZED,<br/>                             {'ContentType': 'application/json'})</span><span id="39f3" class="mt lb it mp b gy nn mv l mw mx">    data = request.get_data()<br/>    if not data:<br/>        return make_response(jsonify({'success': False}),<br/>                             status.HTTP_400_BAD_REQUEST,<br/>                             {'ContentType': 'application/json'})</span><span id="5f39" class="mt lb it mp b gy nn mv l mw mx">    sensor_pb = sensors_pb2.SensorDHT()<br/>    sensor_pb.ParseFromString(data)<br/>    sensor_json = MessageToJson(sensor_pb)<br/>    send_message(sensor_json)</span><span id="2981" class="mt lb it mp b gy nn mv l mw mx">    return make_response(jsonify({'success': True}),<br/>                         status.HTTP_201_CREATED,<br/>                         {'ContentType': 'application/json'})<br/></span><span id="f8b2" class="mt lb it mp b gy nn mv l mw mx">def validate_token(request):<br/>    auth_header = request.headers.get('Authorization')<br/>    if not auth_header:<br/>        return False<br/>    auth_token = auth_header.split(" ")[1]</span><span id="7e7a" class="mt lb it mp b gy nn mv l mw mx">    if not auth_token:<br/>        return False<br/>    try:<br/>        payload = jwt.decode(auth_token, SECRET_KEY)<br/>        if payload['id'] == ID and payload['password'] == PASSWORD:<br/>            return True<br/>    except jwt.ExpiredSignatureError:<br/>        return False<br/>    except jwt.InvalidTokenError:<br/>        return False<br/></span><span id="733b" class="mt lb it mp b gy nn mv l mw mx">def send_message(message):<br/>    publisher = pubsub_v1.PublisherClient()<br/>    publisher.publish(topic=TOPIC, data=bytes(message, 'utf-8'))</span></pre><h1 id="0ce7" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">云发布/订阅功能</h1><p id="d276" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">除了HTTP功能，演示还使用了由<a class="ae md" href="https://cloud.google.com/functions/docs/calling/pubsub" rel="noopener ugc nofollow" target="_blank">谷歌云发布/订阅触发器</a>触发的功能。根据<a class="ae md" href="https://cloud.google.com/functions/docs/calling/pubsub" rel="noopener ugc nofollow" target="_blank">谷歌</a>的说法，云功能可以由发布到与该功能相同的GCP项目中的云发布/订阅主题的消息触发。该函数自动订阅主题。下面我们看到该功能已经自动订阅了<code class="fe nk nl nm mp b">iot-data-demo</code>云发布/订阅话题。</p><figure class="mf mg mh mi gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi od"><img src="../Images/8bbd57a5cc71d2da1b0bf0ef5ef85b17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*UCKSAesnKhACvqBE"/></div></div></figure><h1 id="2bc3" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">向MongoDB Atlas发送遥测数据</h1><p id="d44c" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">公共云函数由发布到Cloud Pub/Sub的消息触发，然后将消息发送到MongoDB Atlas。将云发布/订阅消息重新格式化为<a class="ae md" href="http://bsonspec.org/" rel="noopener ugc nofollow" target="_blank"> BSON </a>(二进制JSON)只需要很少的清理工作。有趣的是，根据<a class="ae md" href="http://bsonspec.org/" rel="noopener ugc nofollow" target="_blank">bsonspec.org</a>的说法，BSON可以被比作垫子的内部变化，就像最初的垫子一样。BSON比Proto col Buf fers更少模式，这使它在灵活性方面有优势，但在空间效率方面稍有劣势(BSON在序列化数据中的字段名方面有优势)。</p><p id="e0d6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">该函数使用<a class="ae md" href="https://api.mongodb.com/python/current/index.html#" rel="noopener ugc nofollow" target="_blank"> PyMongo </a>连接到MongoDB Atlas。根据他们的网站，PyMongo是一个Python发行版，包含了使用MongoDB的工具，是使用Python中的MongoDB的推荐方法。</p><pre class="mf mg mh mi gt mo mp mq mr aw ms bi"><span id="d6e3" class="mt lb it mp b gy mu mv l mw mx">import base64<br/>import json<br/>import logging<br/>import os<br/><strong class="mp iu">import pymongo</strong></span><span id="8ebb" class="mt lb it mp b gy nn mv l mw mx">MONGODB_CONN = os.environ.get('MONGODB_CONN')<br/>MONGODB_DB = os.environ.get('MONGODB_DB')<br/>MONGODB_COL = os.environ.get('MONGODB_COL')<br/></span><span id="d0eb" class="mt lb it mp b gy nn mv l mw mx">def read_message(event, context):<br/>    message = base64.b64decode(event['data']).decode('utf-8')<br/>    message = message.replace("'", '"')<br/>    message = message.replace('True', 'true')<br/>    message = json.loads(message)</span><span id="5ce7" class="mt lb it mp b gy nn mv l mw mx">    client = pymongo.MongoClient(MONGODB_CONN)<br/>    db = client[MONGODB_DB]<br/>    col = db[MONGODB_COL]<br/>    col.insert_one(message)</span></pre><p id="14d6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">该函数响应发布的事件，并将消息发送到MongoDB Atlas集群，该集群运行在与云函数和发布/订阅主题相同的区域us-central1中。下面，我们看到了在配置Atlas集群时可用的当前选项。</p><figure class="mf mg mh mi gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi od"><img src="../Images/b48e80abcc8ffdd435a5583b64f672b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*xiS7fH7hf8MttyZc"/></div></div></figure><p id="c64b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">MongoDB Atlas提供了一个丰富的基于web的UI，用于管理和监控MongoDB集群、数据库、集合、安全性和性能。</p><figure class="mf mg mh mi gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi od"><img src="../Images/25b19036928c70fee2b04756852a1396.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*yC0TMw9Ythu-cfyW"/></div></div></figure><p id="270b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">尽管云发布/订阅Atlas函数的执行时间比HTTP函数长，但通过将云发布/订阅主题、云函数和MongoDB Atlas集群放在同一个GCP区域中，延迟大大降低。跨区域执行时间高达500-600毫秒，而同区域执行时间平均为200-225毫秒。选择性能更高的Atlas集群可能会导致更低的函数执行时间。</p><figure class="mf mg mh mi gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi od"><img src="../Images/7b7512e581a666d96714f4f873249b4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*5pSZI3AzRfS7qmZV"/></div></div></figure><h1 id="41db" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">使用MongoDB Compass聚合数据</h1><p id="784e" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">MongoDB Compass是一个免费、方便的桌面应用程序，用于与您的MongoDB数据库进行交互。您可以查看收集的传感器数据，查看消息(文档)模式，管理索引，并构建复杂的MongoDB <a class="ae md" href="https://docs.mongodb.com/manual/aggregation/" rel="noopener ugc nofollow" target="_blank">聚合</a>。</p><figure class="mf mg mh mi gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi od"><img src="../Images/7136e4a142525e280b2dc09194e12eec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*zommbavEG2LE4H4a"/></div></div></figure><figure class="mf mg mh mi gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi od"><img src="../Images/69c7788d96b9697478c0227151b2697a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*MV-5UNi73-kos-Lf"/></div></div></figure><figure class="mf mg mh mi gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi od"><img src="../Images/fa4a8bbbaeabdfb30924689d48bcebb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*80UeL2RghC2WsPcy"/></div></div></figure><p id="3c41" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当执行分析或机器学习时，我主要使用MongoDB Compass来预览捕获的遥测数据，并构建<a class="ae md" href="https://docs.mongodb.com/manual/aggregation/#aggregation-framework" rel="noopener ugc nofollow" target="_blank">聚合管道</a>。聚合操作处理数据记录并返回计算结果。这一功能节省了大量时间，过滤和准备数据以供进一步分析、可视化和使用<a class="ae md" href="https://jupyter.org/" rel="noopener ugc nofollow" target="_blank"> Jupyter笔记本</a>进行机器学习。</p><figure class="mf mg mh mi gt ju gh gi paragraph-image"><div class="gh gi od"><img src="../Images/150f0cacaf2e904b59e9a057905154a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*ccR9TKhaiFCsgcRL"/></div></figure><p id="8fa3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">聚合管道可以直接导出到Java、Node、C#和Python 3。导出的聚合管道代码可以直接放入您的Python应用程序和<a class="ae md" href="https://jupyter.org/" rel="noopener ugc nofollow" target="_blank"> Jupyter笔记本</a>中。</p><figure class="mf mg mh mi gt ju gh gi paragraph-image"><div class="gh gi od"><img src="../Images/d32336330ac9708fa4f6768e8282983d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*lWa5X5LtNptBqaCY"/></div></figure><p id="6caa" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下面，从MongoDB Compass导出的聚合管道代码用于将结果集直接加载到一个<a class="ae md" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.html" rel="noopener ugc nofollow" target="_blank"> Pandas DataFrame </a>中。这种特殊的聚合返回特定物联网设备在72小时内的时序DHT传感器数据。</p><pre class="mf mg mh mi gt mo mp mq mr aw ms bi"><span id="0430" class="mt lb it mp b gy mu mv l mw mx">DEVICE_1 = 'rp59adf374'<br/>pipeline = [<br/>    {<br/>        '$match': {<br/>            'type': 'DHT22', <br/>            'device': DEVICE_1, <br/>            'timestamp': {<br/>                '$gt': 1557619200,<br/>                '$lt': 1557792000<br/>            }<br/>        }<br/>    }, {<br/>        '$project': {<br/>            '_id': 0,<br/>            'timestamp': 1, <br/>            'temperature': '$data.temperature', <br/>            'humidity': '$data.humidity'<br/>        }<br/>    }, {<br/>        '$sort': {<br/>            'timestamp': 1<br/>        }<br/>    }<br/>]<br/>aggResult = iot_data.aggregate(pipeline)<br/>df1 = pd.DataFrame(list(aggResult))</span></pre><h1 id="ccba" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">MongoDB Atlas性能</h1><p id="4e4e" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">在这次演示中，我能够从基于Python3的Jupyter笔记本电脑上持续查询MongoDB Atlas集合中的近70k个文档，以获得包含3天(72小时)数字温度和湿度数据的结果集，大约10.2k个文档，平均时间为825毫秒。这是从我的本地开发笔记本电脑到位于不同地理区域的GCP上运行的MongoDB Atlas的往返行程。</p><p id="bf9f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">GCP上的查询时间要快得多，比如在谷歌的人工智能平台上运行JupyterLab中的笔记本时，或者在Atlas上运行PySpark作业时。直接在谷歌的人工智能平台上运行相同的Jupyter笔记本，相同的MongoDB Atlas查询平均需要450毫秒，而不是825毫秒(快了1.83倍)。这是跨越两个不同的GCP地区；相同地区的时间应该更快。</p><figure class="mf mg mh mi gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi od"><img src="../Images/77ee841c893ff28c4ec58107058da7be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*sx1Yi7s8VFL7YjQV"/></div></div></figure><h1 id="bad4" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">GCP可观测性</h1><p id="9818" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">观察系统的Google Cloud功能有几个选择，Google Cloud Pub/Sub，MongoDB Atlas。如上所示，GCP云函数界面可以让您看到各个函数在不同时间间隔内的执行情况、执行时间、内存使用情况和活动实例。</p><p id="26f8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了更详细地查看Google Cloud Functions和Google Cloud Pub/Sub，我使用<a class="ae md" href="https://cloud.google.com/stackdriver/" rel="noopener ugc nofollow" target="_blank"> Stackdriver </a>构建了两个定制仪表板。根据谷歌的说法，Stackdriver聚合了来自基础设施的指标、日志和事件，为开发者和运营商提供了一组丰富的可观察信号。我构建了一个定制的Stackdriver云功能仪表板(如下所示)和一个云发布/订阅主题和订阅仪表板。</p><p id="1eb5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于函数，我选择显示执行时间、内存使用量、执行次数和网络出口，所有这些都显示在一个单一的窗格中，使用四个图表。下面，我使用第95百分位平均值进行监控。第95个百分位数表明，95%的时间里，观察值低于该数值，而其余5%的时间里，观察值高于该数值。</p><figure class="mf mg mh mi gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi od"><img src="../Images/54e80556dd0a30c3b7b90943d6f7f266.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*-1WWzmPvXqEt7CLq"/></div></div></figure><h1 id="3df9" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">使用Jupyter笔记本进行数据分析</h1><p id="db97" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">据jupyter.org的<a class="ae md" href="https://jupyter.org/" rel="noopener ugc nofollow" target="_blank">称，Jupyter Notebook是一个开源的网络应用程序，允许你创建和分享包含实时代码、方程式、可视化和叙述性文本的文档。用途包括数据清理和转换、数值模拟、统计建模、数据可视化、机器学习等等。Jupyter笔记本的广泛使用显著增长，因为大数据、AI和ML都经历了爆发式增长。</a></p><h2 id="b38d" class="mt lb it bd lc mz na dn lg nb nc dp lk km nd ne lo kq nf ng ls ku nh ni lw nj bi translated">皮查姆</h2><p id="3c52" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">JetBrains <a class="ae md" href="https://www.jetbrains.com/pycharm" rel="noopener ugc nofollow" target="_blank"> PyCharm </a>，我最喜欢的Python IDE，与Jupyter笔记本<a class="ae md" href="https://jupyter-notebook.readthedocs.io/en/stable/notebook.html#" rel="noopener ugc nofollow" target="_blank">直接集成。事实上，PyCharm对专业版的最新更新极大地增强了这些集成。PyCharm在IDE和</a><a class="ae md" href="https://jupyter-notebook.readthedocs.io/en/stable/notebook.html#" rel="noopener ugc nofollow" target="_blank"> Jupyter Notebook </a> web浏览器界面中提供往返编辑。PyCharm允许您运行和调试笔记本中的单个单元。PyCharm自动为您打开的笔记本启动<a class="ae md" href="https://jupyter-notebook.readthedocs.io/en/stable/public_server.html" rel="noopener ugc nofollow" target="_blank"> Jupyter服务器</a>和相应的内核。我最喜欢的功能之一是PyCharm的变量查看器自动跟踪变量的当前值。</p><figure class="mf mg mh mi gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi od"><img src="../Images/99e2691e684ff8f207ed108aa345f6c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*cks0zG_guwt_Owlo"/></div></div></figure><p id="61e7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下面，我们看到示例分析笔记本，包含在演示的项目中，显示在PyCharm 19.1.2(专业版)中。要在PyCharm中有效地使用笔记本电脑，确实需要全尺寸显示器。在使用PyCharm拥挤的笔记本UI的笔记本电脑上工作是可行的，但肯定不如在更大的显示器上工作有效。</p><figure class="mf mg mh mi gt ju gh gi paragraph-image"><div class="gh gi od"><img src="../Images/fa5602dc25a02dde8adb641ceeedfee0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*XKl1SWJrp1DcqWQ3"/></div></figure><h2 id="bb74" class="mt lb it bd lc mz na dn lg nb nc dp lk km nd ne lo kq nf ng ls ku nh ni lw nj bi translated">Jupyter笔记本服务器</h2><p id="1366" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">下面，我们看到同样的分析笔记本，如上面PyCharm中所示，在Jupyter Notebook Server的基于web的客户端界面中打开，在开发工作站上本地运行。基于web浏览器的界面还为笔记本开发提供了丰富的功能。</p><p id="6bf3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在笔记本中，我们能够再次使用<a class="ae md" href="https://api.mongodb.com/python/current/index.html#" rel="noopener ugc nofollow" target="_blank"> PyMongo </a>查询MongoDB Atlas中的数据，并将结果集加载到Panda DataFrames中。对于笔记本，作为硬编码值和环境变量的替代，我使用了<a class="ae md" href="https://pypi.org/project/python-dotenv/" rel="noopener ugc nofollow" target="_blank"> python-dotenv </a> Python包。这个包允许我将环境变量放在一个公共的<code class="fe nk nl nm mp b">.env</code>文件中，并从任何笔记本中引用它们。这个包有许多管理环境变量的选项。</p><figure class="mf mg mh mi gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi od"><img src="../Images/00ac733713339099ed55931c307dc171.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*fRFjj2ivNkHOEb7C"/></div></div></figure><p id="567d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后我们可以使用一些常见的框架来分析数据，包括<a class="ae md" href="https://pandas.pydata.org/" rel="noopener ugc nofollow" target="_blank"> Pandas </a>、<a class="ae md" href="https://matplotlib.org/" rel="noopener ugc nofollow" target="_blank"> Matplotlib </a>、<a class="ae md" href="https://www.scipy.org/" rel="noopener ugc nofollow" target="_blank"> SciPy </a>、<a class="ae md" href="https://spark.apache.org/docs/latest/api/python/index.html" rel="noopener ugc nofollow" target="_blank"> PySpark </a>和<a class="ae md" href="https://www.numpy.org/" rel="noopener ugc nofollow" target="_blank"> NumPy </a>等等。下面，我们看到来自同一物联网设备上四个不同传感器的时间序列数据。综合这些数据，我们可以研究一个环境变量对另一个环境变量的因果影响，例如光线对温度或湿度的影响。</p><figure class="mf mg mh mi gt ju gh gi paragraph-image"><div class="gh gi od"><img src="../Images/5ab01106f3bee43bdd313f287981f299.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*FcZxdSUilGBxm6Uo"/></div></figure><p id="fd3c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下面，我们可以使用直方图来显示给定器件位置在<br/>时间间隔内的温度频率。</p><figure class="mf mg mh mi gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi od"><img src="../Images/f9d8302fc0e3e293482795f9e82cd407.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*Ft_8l7g12LOD71Z5"/></div></div></figure><h2 id="bec3" class="mt lb it bd lc mz na dn lg nb nc dp lk km nd ne lo kq nf ng ls ku nh ni lw nj bi translated">使用Jupyter笔记本的机器学习</h2><p id="b23a" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">除了数据分析，我们还可以将Jupyter笔记本与<a class="ae md" href="https://scikit-learn.org/stable/" rel="noopener ugc nofollow" target="_blank"> scikit-learn </a>等工具配合使用，以基于我们的传感器遥测技术构建机器学习模型。<a class="ae md" href="https://scikit-learn.org/stable/" rel="noopener ugc nofollow" target="_blank"> Scikit-learn </a>是一套Python中的机器学习工具，构建于NumPy、SciPy和matplotlib之上。下面，我在谷歌的<a class="ae md" href="https://cloud.google.com/ai-platform/" rel="noopener ugc nofollow" target="_blank">人工智能平台</a>和scikit-learn上使用了JupyterLab，根据传感器数据建立了几个模型。</p><figure class="mf mg mh mi gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi od"><img src="../Images/9bd582dc6810e35ae3c0658e35562739.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*Dng5zLIGd6BBi3LC"/></div></div></figure><figure class="mf mg mh mi gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi od"><img src="../Images/9d88a73c2b87c7b44bb3df3636b0a2ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*jgWYw5nBWh6jS7ZP"/></div></div></figure><p id="c9fe" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用scikit-learn，我们可以构建模型来预测诸如哪个物联网设备生成了特定的温度和湿度读数，或者在给定时间、设备位置和外部环境变量的情况下预测温度和湿度，或者发现传感器遥测中的异常。</p><p id="a69b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Scikit-learn可以使用来自多个物联网设备的数据轻松构建随机训练和测试数据集，从而构建模型，如下所示。</p><figure class="mf mg mh mi gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi od"><img src="../Images/7f20711ad278d891d50170ba7cd9f595.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*2_r4N5FYMHVcofiS"/></div></div></figure><p id="46c9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">该项目包括一个Jupyter笔记本，演示如何使用传感器数据建立几个ML模型。在本演示中用于构建分类模型的监督学习算法的例子包括<a class="ae md" href="https://en.wikipedia.org/wiki/Support-vector_machine" rel="noopener ugc nofollow" target="_blank">支持向量机</a>(SVM)<a class="ae md" href="https://en.wikipedia.org/wiki/K-nearest_neighbors_algorithm" rel="noopener ugc nofollow" target="_blank"><em class="kz">k</em>-最近邻</a> ( <em class="kz"> k </em> -NN)，以及<a class="ae md" href="https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.RandomForestClassifier.html" rel="noopener ugc nofollow" target="_blank">随机森林分类器</a>。</p><figure class="mf mg mh mi gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi od"><img src="../Images/dd6b418bd650ce6b0adf57de4e85e003.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*j2N_LBJULArVdP22"/></div></div></figure><p id="723d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">拥有来自多个传感器的数据，我们能够通过向我们的训练数据添加额外的分类(离散)特征来丰富ML模型。例如，我们可以观察光线、运动和一天中的时间对温度和湿度的影响。</p><figure class="mf mg mh mi gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi od"><img src="../Images/c07b5924d51550fd5831a3241c0bde77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*SucaeeuhdxRtm42v"/></div></div></figure><h1 id="fbca" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">结论</h1><p id="736f" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">希望这篇文章展示了如何在谷歌云平台上使用HTTPS上的谷歌协议缓冲区、无服务器谷歌云功能、云发布/订阅和MongoDB Atlas有效地收集物联网设备的遥测数据。一旦捕获到遥测数据，就可以使用MongoDB Compass和Jupyter Notebooks等常用工具轻松地对其进行汇总和分析。此外，我们使用这些数据和工具来构建用于预测和异常检测的机器学习模型。</p><p id="6ddd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="kz">本文表达的所有观点都是我个人的观点，不一定代表我现在或过去的雇主或他们的客户的观点。</em></p><p id="f12b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="kz">图片:</em> <a class="ae md" href="https://www.123rf.com/profile_everythingpossible" rel="noopener ugc nofollow" target="_blank"> <em class="kz">一切可能</em></a><em class="kz">123RF.com</em></p></div></div>    
</body>
</html>