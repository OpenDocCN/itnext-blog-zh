<html>
<head>
<title>A modern guide to Events in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript事件现代指南</h1>
<blockquote>原文：<a href="https://itnext.io/a-modern-guide-to-events-in-javascript-90ef314679a5?source=collection_archive---------6-----------------------#2019-08-19">https://itnext.io/a-modern-guide-to-events-in-javascript-90ef314679a5?source=collection_archive---------6-----------------------#2019-08-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="deab" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">事件是如何通过DOM元素传播的？有没有办法让它为我们所用？</h2></div><h1 id="eea0" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">什么是事件？</h1><blockquote class="kx ky kz"><p id="9c59" class="la lb lc ld b le lf jr lg lh li ju lj lk ll lm ln lo lp lq lr ls lt lu lv lw ij bi translated"><em class="iq">事件是对象，实现了</em> <a class="ae lx" href="https://dom.spec.whatwg.org/#interface-event" rel="noopener ugc nofollow" target="_blank"> <em class="iq">事件接口</em> </a></p></blockquote><p id="3ab0" class="pw-post-body-paragraph la lb iq ld b le lf jr lg lh li ju lj ly ll lm ln lz lp lq lr ma lt lu lv lw ij bi translated">这些对象由用户代理(或应用程序本身)分派，并由<a class="ae lx" href="https://dom.spec.whatwg.org/#concept-event-listener" rel="noopener ugc nofollow" target="_blank">事件监听器</a>处理。事件负责处理用户交互或网络活动。有不同类型的事件，但如果您愿意，您可以在<a class="ae lx" href="https://developer.mozilla.org/en-US/docs/Web/API/Event#Introduction" rel="noopener ugc nofollow" target="_blank"> MDN </a>上查看。我们必须关注事件是如何通过DOM传播的。</p><h1 id="58ff" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">事件传播</h1><p id="d669" class="pw-post-body-paragraph la lb iq ld b le mb jr lg lh mc ju lj ly md lm ln lz me lq lr ma mf lu lv lw ij bi translated">首先，我们必须创建一些简单的DOM来解释事件传播</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="d0b0" class="mp kg iq ml b gy mq mr l ms mt">&lt;div id="container"&gt;<br/>  &lt;div id="dataContainer"&gt;<br/>    &lt;div id="clickedData"&gt;&lt;/div&gt;<br/>  &lt;/div&gt;<br/>  &lt;button id="dataSubmitter"&gt;Add Data&lt;/button&gt;<br/>&lt;/div&gt;</span></pre><figure class="mg mh mi mj gt mv gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/780433a671c4e64a466ecd09f17ada96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1042/format:webp/0*b2enKpdme4D1MyqY.png"/></div></figure><p id="dde8" class="pw-post-body-paragraph la lb iq ld b le lf jr lg lh li ju lj ly ll lm ln lz lp lq lr ma lt lu lv lw ij bi translated">为了处理事件，我们需要添加一些事件监听器。在VanillaJS中要做到这一点，我们必须获取DOM元素并对其调用<code class="fe my mz na ml b">addEventListener</code>。DOM元素正在实现EventTarget接口，因此，我们可以访问<code class="fe my mz na ml b">addEventListener(type, callback, options)</code>和<code class="fe my mz na ml b">removeEventListener(type, callback, options)</code>方法。</p><ul class=""><li id="7e98" class="nb nc iq ld b le lf lh li ly nd lz ne ma nf lw ng nh ni nj bi translated"><strong class="ld ir">类型</strong> —事件的名称</li><li id="cafb" class="nb nc iq ld b le nk lh nl ly nm lz nn ma no lw ng nh ni nj bi translated"><strong class="ld ir">回调</strong> —要调用的函数</li><li id="7bcb" class="nb nc iq ld b le nk lh nl ly nm lz nn ma no lw ng nh ni nj bi translated"><strong class="ld ir">选项</strong> —改变默认监听器行为的对象</li></ul><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="1586" class="mp kg iq ml b gy mq mr l ms mt">const button = document.getElementById('dataSubmitter');</span><span id="783c" class="mp kg iq ml b gy np mr l ms mt">button.addEventListener('click', e =&gt; {<br/>  console.log('clicked');<br/>});</span></pre><p id="5e30" class="pw-post-body-paragraph la lb iq ld b le lf jr lg lh li ju lj ly ll lm ln lz lp lq lr ma lt lu lv lw ij bi translated">在调用了<code class="fe my mz na ml b">addEventListener</code>之后，我们在那个元素(按钮)上的<strong class="ld ir">事件监听器列表</strong>中添加了一个监听器。该列表是零个或多个事件侦听器的列表，这意味着您可以为同一事件添加更多侦听器。</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="657d" class="mp kg iq ml b gy mq mr l ms mt">const button = document.getElementById('dataSubmitter');</span><span id="4746" class="mp kg iq ml b gy np mr l ms mt">button.addEventListener('click', e =&gt; {<br/>  console.log('clicked first');<br/>});<br/>button.addEventListener('click', e =&gt; {<br/>  console.log('clicked second');<br/>});</span></pre><p id="d8e9" class="pw-post-body-paragraph la lb iq ld b le lf jr lg lh li ju lj ly ll lm ln lz lp lq lr ma lt lu lv lw ij bi translated">在这种情况下，当<code class="fe my mz na ml b">click</code>事件被调度时，侦听器将按照它们被分配的顺序被调用(我们将在控制台中看到<code class="fe my mz na ml b">clicked first</code>和<code class="fe my mz na ml b">clicked second</code>)。</p><p id="55f0" class="pw-post-body-paragraph la lb iq ld b le lf jr lg lh li ju lj ly ll lm ln lz lp lq lr ma lt lu lv lw ij bi translated">每个人都知道点击我们的按钮(2个控制台日志)后会发生什么，但是为了显示事件如何通过我们的DOM树传播，我们必须添加更多的侦听器</p><figure class="mg mh mi mj gt mv gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/198a84bae9a6db580a5844e2942c4799.png" data-original-src="https://miro.medium.com/v2/resize:fit:1162/format:webp/0*QtuanMpBkLnOtPKp.png"/></div></figure><p id="35af" class="pw-post-body-paragraph la lb iq ld b le lf jr lg lh li ju lj ly ll lm ln lz lp lq lr ma lt lu lv lw ij bi translated">而现在用户交互事件之后是<strong class="ld ir">通过DOM向上冒泡</strong></p><figure class="mg mh mi mj gt mv gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/a5a8f918b5fb751dfab32dde3d14bb41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1162/0*CCa3ENZRFMuf9O8d.gif"/></div></figure><p id="ccf1" class="pw-post-body-paragraph la lb iq ld b le lf jr lg lh li ju lj ly ll lm ln lz lp lq lr ma lt lu lv lw ij bi translated">这个过程被称为<strong class="ld ir">冒泡</strong>并且很容易理解，但这不是全部路径。每个事件都从树的顶部开始其路径。这个过程被称为<strong class="ld ir">捕获</strong>，为了访问<strong class="ld ir">捕获</strong>阶段的事件，我们必须创建带有额外选项的监听器，作为第三个参数传递。</p><p id="b140" class="pw-post-body-paragraph la lb iq ld b le lf jr lg lh li ju lj ly ll lm ln lz lp lq lr ma lt lu lv lw ij bi translated"><code class="fe my mz na ml b">capture: true</code>通知我们的监听器监听<strong class="ld ir">阶段1或2 </strong>中的事件。每个事件有3个阶段:</p><ul class=""><li id="39cc" class="nb nc iq ld b le lf lh li ly nd lz ne ma nf lw ng nh ni nj bi translated"><strong class="ld ir">捕捉(1) </strong> —下树</li><li id="07ab" class="nb nc iq ld b le nk lh nl ly nm lz nn ma no lw ng nh ni nj bi translated"><strong class="ld ir">关于目标(2) </strong> —这是不言自明的</li><li id="2db3" class="nb nc iq ld b le nk lh nl ly nm lz nn ma no lw ng nh ni nj bi translated"><strong class="ld ir">泡泡(3) </strong> —上树</li></ul><p id="aa3d" class="pw-post-body-paragraph la lb iq ld b le lf jr lg lh li ju lj ly ll lm ln lz lp lq lr ma lt lu lv lw ij bi translated">现在让我们看看我们的事件是如何传播的(事件类型旁边的数字是添加事件侦听器的顺序)。</p><figure class="mg mh mi mj gt mv gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/bbe03b079dcfca47d40070ca6073f9e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1262/0*zOgW5QUP5_zncloY.gif"/></div></figure><p id="867f" class="pw-post-body-paragraph la lb iq ld b le lf jr lg lh li ju lj ly ll lm ln lz lp lq lr ma lt lu lv lw ij bi translated">在点击事件被调度后，它在<code class="fe my mz na ml b">body</code>级别以<code class="fe my mz na ml b">eventPhase === 1</code>开始。之后，它在树中传播，直到到达它的目标(按钮)。</p><p id="58a3" class="pw-post-body-paragraph la lb iq ld b le lf jr lg lh li ju lj ly ll lm ln lz lp lq lr ma lt lu lv lw ij bi translated">在按钮级别，相位变为<strong class="ld ir"> 2 </strong>，我们可以发现异常行为。如果你仔细观察监听器被调用的顺序(<code class="fe my mz na ml b">button</code>，首先我们调用负责<strong class="ld ir">冒泡</strong>事件的事件监听器，然后监听器负责<strong class="ld ir">捕获</strong>。一开始可能看起来很奇怪，但是在<code class="fe my mz na ml b">button</code>级别，我们的事件不在任何一个阶段。正因为如此，我们的侦听器是按照创建的顺序被执行的。在目标阶段的<strong class="ld ir">中，监听器类型无关紧要。</strong></p><p id="e5f2" class="pw-post-body-paragraph la lb iq ld b le lf jr lg lh li ju lj ly ll lm ln lz lp lq lr ma lt lu lv lw ij bi translated">之后，我们的事件以与前一个例子相同的方式冒泡。</p><h1 id="4a28" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">如何阻止事件传播？</h1><p id="0ae4" class="pw-post-body-paragraph la lb iq ld b le mb jr lg lh mc ju lj ly md lm ln lz me lq lr ma mf lu lv lw ij bi translated">有时我们希望事件位于树的特定点。为此，我们需要使用<code class="fe my mz na ml b">e.stopPropagation()</code>或<code class="fe my mz na ml b">e.stopImmediatePropagation()</code>。这些函数防止其他侦听器被同一个事件调用。</p><h2 id="4650" class="mp kg iq bd kh ns nt dn kl nu nv dp kp ly nw nx kr lz ny nz kt ma oa ob kv oc bi translated">停止传播()</h2><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="8d1b" class="mp kg iq ml b gy mq mr l ms mt">const button = document.getElementById('dataSubmitter');</span><span id="dcf5" class="mp kg iq ml b gy np mr l ms mt">button.addEventListener('click', e =&gt; {<br/>  console.log('clicked first');<br/>  e.stopPropagation();<br/>});<br/>button.addEventListener('click', e =&gt; {<br/>  console.log('clicked second');<br/>});<br/>button.addEventListener(<br/>  'click',<br/>  e =&gt; {<br/>    console.log("button capture 'click'");<br/>  },<br/>  {<br/>    capture: true,<br/>  }<br/>);</span></pre><figure class="mg mh mi mj gt mv gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/1ff3162ecaf84d15393d203d5400a5d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1262/0*igu8Ko20E2PQvKUQ.gif"/></div></figure><p id="f613" class="pw-post-body-paragraph la lb iq ld b le lf jr lg lh li ju lj ly ll lm ln lz lp lq lr ma lt lu lv lw ij bi translated">即使我们在第一个侦听器中调用<code class="fe my mz na ml b">stopPropagation()</code>，所有分配给当前元素的侦听器都会被调用。事件不会传播到另一个<code class="fe my mz na ml b">EventTarget</code>。我们可以在我们的任何一个侦听器中调用<code class="fe my mz na ml b">stopPropagation()</code>，它不一定是目标，甚至不一定是冒泡的阶段。如果你想阻止事件到达目标，你可以在一个监听<strong class="ld ir">捕获</strong>阶段的监听器中调用<code class="fe my mz na ml b">stopPropagation</code>。</p><h2 id="4afb" class="mp kg iq bd kh ns nt dn kl nu nv dp kp ly nw nx kr lz ny nz kt ma oa ob kv oc bi translated">stopImmediatePropagation()</h2><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="96b3" class="mp kg iq ml b gy mq mr l ms mt">const button = document.getElementById('dataSubmitter');</span><span id="3911" class="mp kg iq ml b gy np mr l ms mt">button.addEventListener('click', e =&gt; {<br/>  console.log('clicked first');<br/>  e.stopImmediatePropagation();<br/>});<br/>button.addEventListener('click', e =&gt; {<br/>  console.log('clicked second');<br/>});<br/>button.addEventListener(<br/>  'click',<br/>  e =&gt; {<br/>    console.log("button capture 'click'");<br/>  },<br/>  {<br/>    capture: true,<br/>  }<br/>);</span></pre><figure class="mg mh mi mj gt mv gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/f0a90bc29283bba17d52ad63cb5cc59c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1262/0*wGnopz0MsJ-xlIAY.gif"/></div></figure><p id="59be" class="pw-post-body-paragraph la lb iq ld b le lf jr lg lh li ju lj ly ll lm ln lz lp lq lr ma lt lu lv lw ij bi translated">你可能已经发现了不同之处。<code class="fe my mz na ml b">stopImmediatePropagation</code>在调用它的同一个侦听器上停止传播。如果我们在<code class="fe my mz na ml b">click (2)</code>内部调用它，那么传播在<code class="fe my mz na ml b">click (2)</code>处停止，并且不执行<code class="fe my mz na ml b">click (3)</code>。在元素上处理多个侦听器时，您应该意识到这种差异。</p><h2 id="2703" class="mp kg iq bd kh ns nt dn kl nu nv dp kp ly nw nx kr lz ny nz kt ma oa ob kv oc bi translated">预防默认()</h2><p id="2c60" class="pw-post-body-paragraph la lb iq ld b le mb jr lg lh mc ju lj ly md lm ln lz me lq lr ma mf lu lv lw ij bi translated">很好的提一下<code class="fe my mz na ml b">preventDefault</code>法。在现代框架中，这样做很常见:</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="3e1f" class="mp kg iq ml b gy mq mr l ms mt">e.preventDefault();<br/>e.stopPropagation();</span></pre><p id="bf28" class="pw-post-body-paragraph la lb iq ld b le lf jr lg lh li ju lj ly ll lm ln lz lp lq lr ma lt lu lv lw ij bi translated">很多人都在这样做，甚至不知道为什么。您知道<code class="fe my mz na ml b">stopPropagation()</code>正在阻止一个事件通过事件监听器。另一方面，<code class="fe my mz na ml b">preventDefault</code>告诉浏览器不要执行它的默认行为。</p><p id="88b1" class="pw-post-body-paragraph la lb iq ld b le lf jr lg lh li ju lj ly ll lm ln lz lp lq lr ma lt lu lv lw ij bi translated"><a class="ae lx" href="https://codesandbox.io/s/awesome-wildflower-z3wn2?fontsize=14" rel="noopener ugc nofollow" target="_blank">https://codesandbox.io/s/awesome-wildflower-z3wn2</a></p><p id="5d75" class="pw-post-body-paragraph la lb iq ld b le lf jr lg lh li ju lj ly ll lm ln lz lp lq lr ma lt lu lv lw ij bi translated">如果我们从复选框中调用<code class="fe my mz na ml b">click</code>事件上的<code class="fe my mz na ml b">preventDefault()</code>，那么浏览器不会将我们的复选框更改为选中状态。我们可以手动处理我们的事件(例如，改为应用自定义操作)。这对于提交表单也很有帮助。在大多数流行的库中，我们实际上不希望表单元素发送HTML。我们希望手动处理表单数据，应用验证，解析并在发送前添加一些额外的数据。</p><h1 id="762b" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">手动调度事件</h1><p id="d435" class="pw-post-body-paragraph la lb iq ld b le mb jr lg lh mc ju lj ly md lm ln lz me lq lr ma mf lu lv lw ij bi translated">我以前说过，事件不一定要由浏览器创建，我们可以创建它们。为此，我们必须创建新的<code class="fe my mz na ml b">CustomEvent</code>实例和<code class="fe my mz na ml b">dispatchEvent</code>。<code class="fe my mz na ml b"><a class="ae lx" href="https://dom.spec.whatwg.org/#interface-customevent" rel="noopener ugc nofollow" target="_blank">CustomEvent</a></code>基本上是相同的标准<code class="fe my mz na ml b">Event</code>，但是在<code class="fe my mz na ml b">options</code>对象中有一个名为<code class="fe my mz na ml b">details</code>的附加属性。该属性用于存储自定义数据。</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="036b" class="mp kg iq ml b gy mq mr l ms mt">const clickedData = document.getElementById('clickedData');<br/>const dataEvent = new CustomEvent('addData', {<br/>  detail: { test: 'test2' },<br/>});</span><span id="c70c" class="mp kg iq ml b gy np mr l ms mt">clickedData.dispatchEvent(dataEvent);</span></pre><p id="b7ee" class="pw-post-body-paragraph la lb iq ld b le lf jr lg lh li ju lj ly ll lm ln lz lp lq lr ma lt lu lv lw ij bi translated">让我们将监听器添加到我们的树中，以监听我们的自定义事件</p><figure class="mg mh mi mj gt mv gh gi paragraph-image"><div role="button" tabindex="0" class="oe of di og bf oh"><div class="gh gi od"><img src="../Images/3e2134b9676185c4e526d8ed3f1c3531.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*pPy-jfhi5zYkRVKC.png"/></div></div></figure><p id="f398" class="pw-post-body-paragraph la lb iq ld b le lf jr lg lh li ju lj ly ll lm ln lz lp lq lr ma lt lu lv lw ij bi translated">当我们的代码被执行时会发生什么？</p><figure class="mg mh mi mj gt mv gh gi paragraph-image"><div role="button" tabindex="0" class="oe of di og bf oh"><div class="gh gi od"><img src="../Images/ad2326927c398251df6a76c1c0d05c47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Uu7kblyzxRAbwi9Z.gif"/></div></div></figure><p id="76c4" class="pw-post-body-paragraph la lb iq ld b le lf jr lg lh li ju lj ly ll lm ln lz lp lq lr ma lt lu lv lw ij bi translated">等等第二，为什么没有冒泡？！在我们的例子中，事件停留在目标阶段的<strong class="ld ir">上。原因是默认情况下，所有使用<code class="fe my mz na ml b">new CustomEvent()</code>创建的事件都将<code class="fe my mz na ml b">bubbles</code>设置为<code class="fe my mz na ml b">false</code>。</strong></p><p id="38c6" class="pw-post-body-paragraph la lb iq ld b le lf jr lg lh li ju lj ly ll lm ln lz lp lq lr ma lt lu lv lw ij bi translated">要启用此事件的冒泡，我们必须使用<code class="fe my mz na ml b">options</code>对象创建它:</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="230c" class="mp kg iq ml b gy mq mr l ms mt">new CustomEvent('addData', {<br/>  bubbles: true,<br/>  detail: { test: 'test2' },<br/>});</span></pre><figure class="mg mh mi mj gt mv gh gi paragraph-image"><div role="button" tabindex="0" class="oe of di og bf oh"><div class="gh gi od"><img src="../Images/ad118f453377c435ebd1f2af97a1f9d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*S1inFXR-zlyGcxdy.gif"/></div></div></figure><blockquote class="kx ky kz"><p id="92ee" class="la lb lc ld b le lf jr lg lh li ju lj lk ll lm ln lo lp lq lr ls lt lu lv lw ij bi translated"><em class="iq">使用</em> <code class="fe my mz na ml b"><em class="iq">CustomEvent</em></code> <em class="iq">不是强制性的。如果你愿意，你可以创建</em> <code class="fe my mz na ml b"><em class="iq">new Event()</em></code> <em class="iq">的实例，并使用它进行传播。</em></p></blockquote><h1 id="0d2c" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">当我们需要使用自定义事件时。</h1><p id="f836" class="pw-post-body-paragraph la lb iq ld b le mb jr lg lh mc ju lj ly md lm ln lz me lq lr ma mf lu lv lw ij bi translated">我认为向元素发送数据是显而易见的。React的HOCs(高阶组件)就是一个很好的例子，它向您展示了为什么您可能想要与事件传播挂钩。想象一下，一个应用程序有多层逻辑包裹着你的表单。它可能看起来像这样:</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="32fb" class="mp kg iq ml b gy mq mr l ms mt">&lt;div id="app"&gt;<br/>  &lt;div id="addUserData"&gt;<br/>    &lt;div id="prefillAfterReset"&gt;<br/>      &lt;form&gt;<br/>        {...}<br/>      &lt;/form&gt;<br/>    &lt;/div&gt;<br/>  &lt;/div&gt;<br/>&lt;/div&gt;</span></pre><p id="42f8" class="pw-post-body-paragraph la lb iq ld b le lf jr lg lh li ju lj ly ll lm ln lz lp lq lr ma lt lu lv lw ij bi translated">在这种情况下，我们甚至可以在表单的<code class="fe my mz na ml b">submit</code>和<code class="fe my mz na ml b">reset</code>事件到达我们的表单组件之前挂钩到它们，并在提交/重置表单时添加/修改数据。我并不是说要实现这样的行为，因为有更好的方法来实现它。</p><p id="d6d2" class="pw-post-body-paragraph la lb iq ld b le lf jr lg lh li ju lj ly ll lm ln lz lp lq lr ma lt lu lv lw ij bi translated">如果你想玩事件，请检查这个沙盒</p><p id="83c1" class="pw-post-body-paragraph la lb iq ld b le lf jr lg lh li ju lj ly ll lm ln lz lp lq lr ma lt lu lv lw ij bi translated">https://codesandbox.io/s/blissful-wilson-6ce25<a class="ae lx" href="https://codesandbox.io/s/blissful-wilson-6ce25?fontsize=14" rel="noopener ugc nofollow" target="_blank"/></p></div><div class="ab cl oi oj hu ok" role="separator"><span class="ol bw bk om on oo"/><span class="ol bw bk om on oo"/><span class="ol bw bk om on"/></div><div class="ij ik il im in"><p id="4d64" class="pw-post-body-paragraph la lb iq ld b le lf jr lg lh li ju lj ly ll lm ln lz lp lq lr ma lt lu lv lw ij bi translated"><em class="lc">最初发布于</em><a class="ae lx" href="https://erdem.pl/2019/08/a-modern-guide-to-events-in-java-script" rel="noopener ugc nofollow" target="_blank"><em class="lc">https://erdem . pl</em></a><em class="lc">。</em></p></div></div>    
</body>
</html>