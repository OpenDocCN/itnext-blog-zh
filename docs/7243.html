<html>
<head>
<title>Steps to emulate kubernetes Pod Network</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">模拟kubernetes Pod网络的步骤</h1>
<blockquote>原文：<a href="https://itnext.io/steps-to-emulate-pod-network-1c34209d0f53?source=collection_archive---------1-----------------------#2022-07-27">https://itnext.io/steps-to-emulate-pod-network-1c34209d0f53?source=collection_archive---------1-----------------------#2022-07-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="2288" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">网络是Kubernetes的支柱，但要准确理解它是如何工作的是一个挑战。有4个不同的网络问题需要解决:</p><blockquote class="kl km kn"><p id="3b4a" class="jn jo ko jp b jq jr js jt ju jv jw jx kp jz ka kb kq kd ke kf kr kh ki kj kk ij bi translated">高度耦合的容器到容器通信:这通过<a class="ae ks" href="https://kubernetes.io/docs/concepts/workloads/pods/" rel="noopener ugc nofollow" target="_blank"> Pods </a>和localhost/127.0.0.1环回接口通信来解决。</p><p id="d9dd" class="jn jo ko jp b jq jr js jt ju jv jw jx kp jz ka kb kq kd ke kf kr kh ki kj kk ij bi translated">点对点通信:我们将模拟这种通信的一个实现。</p><p id="1163" class="jn jo ko jp b jq jr js jt ju jv jw jx kp jz ka kb kq kd ke kf kr kh ki kj kk ij bi translated">吊舱到服务的通信:这由<a class="ae ks" href="https://kubernetes.io/docs/concepts/services-networking/service/" rel="noopener ugc nofollow" target="_blank">服务</a>负责。</p><p id="c03c" class="jn jo ko jp b jq jr js jt ju jv jw jx kp jz ka kb kq kd ke kf kr kh ki kj kk ij bi translated">外部到服务的通信:这由<a class="ae ks" href="https://kubernetes.io/docs/concepts/services-networking/service/" rel="noopener ugc nofollow" target="_blank">服务</a>负责。</p></blockquote><p id="aa1f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Kubernetes集群中有3个网络:</p><ol class=""><li id="b8a4" class="kt ku iq jp b jq jr ju jv jy kv kc kw kg kx kk ky kz la lb bi translated">连接Kubernetes集群节点池的所有主机/服务器/虚拟机/节点的主机网络。</li><li id="5033" class="kt ku iq jp b jq lc ju ld jy le kc lf kg lg kk ky kz la lb bi translated">连接节点池中相同节点或不同节点上所有单元的单元网络。</li><li id="82af" class="kt ku iq jp b jq lc ju ld jy le kc lf kg lg kk ky kz la lb bi translated"><a class="ae ks" rel="noopener ugc nofollow" target="_blank" href="/inspecting-and-understanding-service-network-dfd8c16ff2c5">服务网络</a>用于连接应用程序，而无需担心pod的pod IPs会迎合各自的应用程序。</li></ol><h2 id="c353" class="lh li iq bd lj lk ll dn lm ln lo dp lp jy lq lr ls kc lt lu lv kg lw lx ly lz bi translated">这篇文章的目的</h2><p id="6787" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">许多博主发表了许多很好的帖子，详细解释了pod网络。我想提几个，如果你感兴趣，你可能会喜欢<a class="ae ks" href="https://sookocheff.com/post/kubernetes/understanding-kubernetes-networking-model/#kubernetes-networking-model" rel="noopener ugc nofollow" target="_blank">“Kubernetes网络模型指南”</a>和<a class="ae ks" href="https://medium.com/google-cloud/understanding-kubernetes-networking-pods-7117dd28727" rel="noopener">“了解Kubernetes网络:pods”</a>。</p><p id="5095" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我为什么写这篇文章？因为当我试图寻找一个展示如何模拟pod网络的帖子时，我没有找到一个全面的。</p><p id="146f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有多种方法可以满足Kubernetes对pod网络的要求。我们主要可以根据pod网络地址空间是节点池子网的一部分还是Pod网络地址空间是独立的并且不是节点池子网的一部分来区分它们。我们将努力仿效后者。</p><p id="e5b3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有多种方法可以实现地址空间独立且不属于节点池子网的pod网络。最常用的是“基本网络”,使用Linux桥和用户定义的路由以及IP转发。<a class="ae ks" href="https://cloud.google.com/kubernetes-engine/docs/how-to/routes-based-cluster" rel="noopener ugc nofollow" target="_blank"> GKE基于路由的</a>集群(当网络策略被禁用时)和Azure <a class="ae ks" href="https://docs.microsoft.com/en-us/azure/aks/configure-kubenet" rel="noopener ugc nofollow" target="_blank"> AKS kubenet </a>使用相同的技术来实现pod联网。</p><p id="d921" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将使用Linux命令模拟没有Kubernetes的pod网络。基本上，当一个pod在一个集群节点上被调度时，我们将做一个"<a class="ae ks" href="https://www.cni.dev/docs/" rel="noopener ugc nofollow" target="_blank"> b </a> ridge "类型的插件在这个节点上被kubelet要求做的事情。我将介绍在后台完成的每个步骤，并提到用于实现相同目的的命令。</p><h1 id="603f" class="mf li iq bd lj mg mh mi lm mj mk ml lp mm mn mo ls mp mq mr lv ms mt mu ly mv bi translated">Pod网络</h1><p id="b983" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">基本要求:</p><ol class=""><li id="56dc" class="kt ku iq jp b jq jr ju jv jy kv kc kw kg kx kk ky kz la lb bi translated">pod中的容器应该能够相互通信。</li><li id="6ed1" class="kt ku iq jp b jq lc ju ld jy le kc lf kg lg kk ky kz la lb bi translated">每个Pod都应该有一个IP地址。</li><li id="fb8d" class="kt ku iq jp b jq lc ju ld jy le kc lf kg lg kk ky kz la lb bi translated">每个pod应该能够与同一节点上的所有其他Pod通信。</li><li id="34c8" class="kt ku iq jp b jq lc ju ld jy le kc lf kg lg kk ky kz la lb bi translated">每个pod应该能够与Kubernetes集群的节点池中的任何其他节点上的其他pod进行通信，而无需NAT。</li></ol><h2 id="3c72" class="lh li iq bd lj lk ll dn lm ln lo dp lp jy lq lr ls kc lt lu lv kg lw lx ly lz bi translated">测试配置</h2><ol class=""><li id="6ec5" class="kt ku iq jp b jq ma ju mb jy mw kc mx kg my kk ky kz la lb bi translated">我们有两个节点node01 (10.128.0.2)和node02 (10.128.0.3)(虚拟机在GCP或Azure中调配)</li><li id="f02b" class="kt ku iq jp b jq lc ju ld jy le kc lf kg lg kk ky kz la lb bi translated">主机网络CIDR 10.128.0.0/24</li><li id="1fe5" class="kt ku iq jp b jq lc ju ld jy le kc lf kg lg kk ky kz la lb bi translated">Pod网络CIDR 192.168.0.0/16，即节点01的CIDR 192.168.1.0/24和节点02的CIDR 192.168.2.0/24，依此类推(对于其他节点，如果添加到群集)</li></ol><h1 id="3b0d" class="mf li iq bd lj mg mh mi lm mj mk ml lp mm mn mo ls mp mq mr lv ms mt mu ly mv bi translated">Pod网络仿真</h1><p id="73ec" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated"><a class="ae ks" href="https://www.redhat.com/sysadmin/7-linux-namespaces" rel="noopener ugc nofollow" target="_blank"> Linux名称空间</a>(特别是<a class="ae ks" href="https://linuxhint.com/use-linux-network-namespace/" rel="noopener ugc nofollow" target="_blank">网络名称空间</a>)使得实现这些需求变得容易。网络名称空间一被调度就被分配给一个pod，这是由Kubelet完成的。这意味着每个pod有一个网络名称空间。</p><p id="f795" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们从一个节点开始，即节点01(10.128.0.2)。在一个网络名称空间内监听的任何两个进程都可以使用环回接口(localhost/127.0.0.1)相互连接，<strong class="jp ir">这解决了第一个要求。</strong></p><figure class="na nb nc nd gt ne gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/8c1a0aad5ff5ebecb6bfad3944957079.png" data-original-src="https://miro.medium.com/v2/resize:fit:1284/format:webp/1*s9JTM5SshhqJiTOEMztZ9w.png"/></div></figure><pre class="na nb nc nd gt nh ni nj nk aw nl bi"><span id="a8fc" class="lh li iq ni b gy nm nn l no np"><em class="ko"># create namespaces on node01</em></span><span id="94dd" class="lh li iq ni b gy nq nn l no np">ip netns add redapp<br/>ip netns add blueapp<br/>ip netns</span></pre><p id="7482" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以使用一个充当虚拟交换机的Linux桥来连接两个名称空间。它工作在OSI模型的第2层，这意味着它使用ARP协议来识别连接到它的设备(名称空间的接口)。对于主机虚拟机(节点)，网桥就像任何其他网络接口一样。我们给网桥分配一个IP地址。所以每个主机节点有一个网桥。</p><pre class="na nb nc nd gt nh ni nj nk aw nl bi"><span id="16d3" class="lh li iq ni b gy nm nn l no np"><em class="ko"># create virtual switch (bridge)</em></span><span id="f0c9" class="lh li iq ni b gy nq nn l no np">ip link add bridge-if1 type bridge<br/>ip link set dev bridge-if1 up<br/>ip link</span><span id="035d" class="lh li iq ni b gy nq nn l no np"><em class="ko"># create peered veth for each namepsace</em></span><span id="af1b" class="lh li iq ni b gy nq nn l no np">ip link add veth-blue1 type veth peer name veth-blue1-br1<br/>ip link add veth-red1 type veth peer name veth-red1-br1</span><span id="ec15" class="lh li iq ni b gy nq nn l no np"><em class="ko"># attach pipe to namespace and bridge</em></span><span id="fe66" class="lh li iq ni b gy nq nn l no np">ip link set veth-blue1-br1 master bridge-if1<br/>ip link set veth-red1-br1 master bridge-if1<br/>ip link set veth-red1 netns redapp<br/>ip link set veth-blue1 netns blueapp</span></pre><p id="a672" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了给网桥附加一个名称空间，我们创建一个带有veth对等体的虚拟以太网接口(veth ),然后将veth附加到名称空间，将veth对等体附加到网桥。然后，我们将IP地址分配给veth(在CIDR范围内，与网桥IP相同)，它将成为使用该网络名称空间的pod的IP。<strong class="jp ir">这满足了拥有独特IP的第二个要求</strong>。如何分配这些IP取决于我们使用的pod网络类型，尤其是IPAM (IP地址管理)插件。我们手动分配它们，就像主机本地IPAM插件一样。我们对每个节点中的每个pod的名称空间进行同样的操作。</p><pre class="na nb nc nd gt nh ni nj nk aw nl bi"><span id="cc15" class="lh li iq ni b gy nm nn l no np"><em class="ko"># assign IP addr to interfaces and bridge</em></span><span id="24a6" class="lh li iq ni b gy nq nn l no np">ip addr add 192.168.1.10/24 dev bridge-if1<br/>ip -n redapp addr add 192.168.1.11/24 dev veth-red1<br/>ip -n blueapp addr add 192.168.1.12/24 dev veth-blue1</span><span id="ccbb" class="lh li iq ni b gy nq nn l no np"><em class="ko"># start the interfaces</em></span><span id="a352" class="lh li iq ni b gy nq nn l no np">ip -n redapp link set veth-red1 up<br/>ip -n blueapp link set veth-blue1 up<br/>ip link set dev veth-blue1-br1 up<br/>ip link set dev veth-red1-br1 up</span></pre><figure class="na nb nc nd gt ne gh gi paragraph-image"><div role="button" tabindex="0" class="ns nt di nu bf nv"><div class="gh gi nr"><img src="../Images/a1b97781e2b8ebd580d13b69c523f606.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B19fVzX1v36kVNFon8cGSw.png"/></div></div></figure><p id="1bbf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在名称空间连接到桥之后，与名称空间相关的接口可以相互通信。这满足了同一节点上的<strong class="jp ir">pod(在名称空间中)能够相互通信的第三个要求</strong>。</p><p id="90e9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Linux内核路由设置为一个简单的路由器，将网桥连接到主机网络。去往192.168.1.0/24的任何数据包被路由到网桥，而去往任何其他目的地(包括其他节点上的pod)的任何数据包被从eth0/ens4路由到主机网络。为了使名称空间能够连接到外部世界，我们需要将流量从eth0/ens4路由出去，为此，我们必须创建一个路由规则，并使网桥成为每个主机中名称空间的默认网关。</p><pre class="na nb nc nd gt nh ni nj nk aw nl bi"><span id="5081" class="lh li iq ni b gy nm nn l no np">#add deafult gateway route for each namespace</span><span id="9c08" class="lh li iq ni b gy nq nn l no np">ip netns exec blueapp ip route add default via 192.168.1.10 dev veth-blue1<br/>ip netns exec redapp ip route add default via 192.168.1.10 dev veth-red1</span></pre><p id="0963" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们剩下最后一个要求，即<strong class="jp ir">每个pod应该能够与Kubernetes集群的节点池中的任何其他节点上的其他pod通信。为此，让我们添加另一个节点node02。请确保在具有不同IP地址和Pod网络cidr的node02上运行上述所有命令。</strong></p><figure class="na nb nc nd gt ne gh gi paragraph-image"><div role="button" tabindex="0" class="ns nt di nu bf nv"><div class="gh gi nw"><img src="../Images/c22a1ec3f354612b35980b90c00b2917.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ntX77kyYRNp_PtuivwTm7Q.png"/></div></div></figure><p id="8c5e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这在我看来更有趣，因为<strong class="jp ir">主机网络对pod网络一无所知。它只知道每个节点的接口eth0/ens4的IP地址以及与它们相关联的路由。</strong></p><p id="f4b4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，如果节点01上的pod尝试向节点02上的pod发送流量，它必须使用主机网络。例如，一个数据包从redapp netns (192.168.1.11)开始，想要到达node02 (192.168.2.11)上的redapp netns。由于默认网关是网桥IP (192.168.1.10 ),它会转到网桥，Linux内核路由会将它转发到eth0/ens4接口，在那里它会找到主机的默认网关，并被路由到主机网络，但是主机网络没有针对该目的地址的路由，并且不知道如何处理该数据包。</p><figure class="na nb nc nd gt ne gh gi paragraph-image"><div role="button" tabindex="0" class="ns nt di nu bf nv"><div class="gh gi nw"><img src="../Images/04a27be607a7e74a3602326737fde862.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H7EkV_xHHjsM3GN-C2KcdQ.png"/></div></div></figure><p id="886c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们必须做两件事(AKS Kubnet和GKE基于路由的集群会自动处理此事)</p><ol class=""><li id="7e74" class="kt ku iq jp b jq jr ju jv jy kv kc kw kg kx kk ky kz la lb bi translated"><strong class="jp ir">在每台主机的eth0/ens4接口上启用IP转发</strong>。要将虚拟机用作路由的下一跳，虚拟机需要接收目的地不是其自身的数据包。因为它转发这些数据包，它们的来源将不同于它们自己的内部IP。为此，您必须为虚拟机启用IP转发。在Azure中，您可以在附加到节点的NIC的“配置”中启用它。对于GCP虚拟机，请遵循l <a class="ae ks" href="https://cloud.google.com/vpc/docs/using-routes#canipforward" rel="noopener ugc nofollow" target="_blank">墨水</a>。在所有节点上，以root身份执行“<em class="ko">sysctl-w net . IP v4 . IP _ forward = 1</em>”。</li><li id="f192" class="kt ku iq jp b jq lc ju ld jy le kc lf kg lg kk ky kz la lb bi translated"><strong class="jp ir">需要将用户定义的路由添加到每个pod cidr的主机子网，以将流量导向相应的节点</strong>。以下是路线的大概样子。<em class="ko">(下一跳的目的地地址可能与我们的情况不同，以下快照仅用于说明目的)</em></li></ol><figure class="na nb nc nd gt ne gh gi paragraph-image"><div role="button" tabindex="0" class="ns nt di nu bf nv"><div class="gh gi nx"><img src="../Images/87770c1a072a2be55a8021c9b95c721e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DTLz-fHbYxSbTgJYOojMig.jpeg"/></div></div><figcaption class="ny nz gj gh gi oa ob bd b be z dk translated">蔚蓝航线</figcaption></figure><figure class="na nb nc nd gt ne gh gi paragraph-image"><div role="button" tabindex="0" class="ns nt di nu bf nv"><div class="gh gi oc"><img src="../Images/494a37006e6865006132b3040d35fa6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9i0GW1_PeYgRjXDKVwU0lA.png"/></div></div><figcaption class="ny nz gj gh gi oa ob bd b be z dk translated">GCP航线</figcaption></figure><p id="2d07" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">完成后，流量可以在node01上的pod和node02上的pod之间自由流动，反之亦然，这<strong class="jp ir">满足了第四个要求</strong>。我们连接了两个pod cidr 192 . 168 . 1 . 0/24(node 01)和192.168.2.0/24 (node02)，如果需要，我们可以添加更多节点，每个pod CIDR都是192.168.x.0/128(其中x必须不同于已经获得的值)。通过连接来自所有节点的pod cidr，我们得到cidr为198.16.0.0/16的pod网络。</p><figure class="na nb nc nd gt ne gh gi paragraph-image"><div role="button" tabindex="0" class="ns nt di nu bf nv"><div class="gh gi nw"><img src="../Images/7797ab3b8bf1ccf0769b3e8dc71f8970.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d1jhHXdjX3s4Uwkmb0YZGw.png"/></div></div></figure><p id="3353" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，用户定义的路由是特定于子网的，<strong class="jp ir">更广泛的网络仍然不知道如何处理进出pod IPs的数据包</strong>。这可以用SNAT来解决。配置Linux内核(使用iptables ),以便从pod到集群网络外部的IP地址的任何连接都被源NAT，以使用托管pod的节点的IP地址。由于更广泛的网络知道节点IPs，因此它可以在更广泛的网络中正常地路由流量。任何与连接相关联的返回流量都被Linux内核自动映射回原始的pod IP地址，因此pod不知道发生了什么。</p><pre class="na nb nc nd gt nh ni nj nk aw nl bi"><span id="505c" class="lh li iq ni b gy nm nn l no np">#on node01<br/>iptables -t nat -A POSTROUTING -s 192.168.1.0/24 -d 10.130.0.10/32 -j MASQUERADE</span></pre><figure class="na nb nc nd gt ne gh gi paragraph-image"><div role="button" tabindex="0" class="ns nt di nu bf nv"><div class="gh gi nw"><img src="../Images/b9748febb5c78f7bc0977fea33f26866.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_tgySHaXQQq8LbE4jbSMnQ.png"/></div></div></figure><h2 id="4b6e" class="lh li iq bd lj lk ll dn lm ln lo dp lp jy lq lr ls kc lt lu lv kg lw lx ly lz bi translated">测试连通性</h2><p id="de26" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">我们将在node01的redapp网络名称空间中启动一个简单的http服务器，以模拟在pod中运行并在端口8000监听的容器</p><pre class="na nb nc nd gt nh ni nj nk aw nl bi"><span id="c30f" class="lh li iq ni b gy nm nn l no np">#setup for test on node01<br/>apt-get update -y<br/>apt-get install python3 -y</span><span id="0714" class="lh li iq ni b gy nq nn l no np">ip netns exec redapp python3 -m http.server 8000</span></pre><p id="de74" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">案例1:pod中的容器应该能够相互通信。</p><pre class="na nb nc nd gt nh ni nj nk aw nl bi"><span id="80df" class="lh li iq ni b gy nm nn l no np">ip netns exec redapp curl http://127.0.0.1:8000</span></pre><p id="c901" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">情况2:每个pod应该能够与同一节点上的所有其他Pod通信。</p><pre class="na nb nc nd gt nh ni nj nk aw nl bi"><span id="fffe" class="lh li iq ni b gy nm nn l no np">#on node01</span><span id="8019" class="lh li iq ni b gy nq nn l no np">ip netns exec blueapp ping 192.168.1.11<br/>ip netns exec blueapp curl http://192.168.1.11:8000</span></pre><p id="f94a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">案例3:每个pod应该能够与Kubernetes集群的节点池中的任何其他节点上的其他pod进行通信，而不需要NAT。</p><pre class="na nb nc nd gt nh ni nj nk aw nl bi"><span id="08a2" class="lh li iq ni b gy nm nn l no np">#on node02</span><span id="d4ae" class="lh li iq ni b gy nq nn l no np">ip netns exec blueapp ping 192.168.1.11<br/>ip netns exec blueapp curl <a class="ae ks" href="http://192.168.1.11:8000" rel="noopener ugc nofollow" target="_blank">http://192.168.1.11:8000</a><br/>ip netns exec redapp ping 192.168.1.11<br/>ip netns exec redapp curl <a class="ae ks" href="http://192.168.1.11:8000" rel="noopener ugc nofollow" target="_blank">http://192.168.1.11:8000</a></span></pre><p id="c419" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">确保GCP防火墙允许进入192.168.1.0/24的流量。Azure中默认没有防火墙，所以在这种情况下不需要任何操作。</p><figure class="na nb nc nd gt ne gh gi paragraph-image"><div role="button" tabindex="0" class="ns nt di nu bf nv"><div class="gh gi od"><img src="../Images/01d3efbe349a22b7f7eeeae03bdf57bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gU3nNXwjwJ6maYxDmPKTNA.png"/></div></div></figure><p id="8c4e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">情况4:所有集群节点都能够连接到pod</p><pre class="na nb nc nd gt nh ni nj nk aw nl bi"><span id="f583" class="lh li iq ni b gy nm nn l no np">#on node02</span><span id="c067" class="lh li iq ni b gy nq nn l no np">ping 192.168.1.11<br/>curl <a class="ae ks" href="http://192.168.1.11:8000" rel="noopener ugc nofollow" target="_blank">http://192.168.1.11:8000</a></span><span id="ce76" class="lh li iq ni b gy nq nn l no np">#on node01</span><span id="3365" class="lh li iq ni b gy nq nn l no np">ping 192.168.1.11<br/>curl <a class="ae ks" href="http://192.168.1.11:8000" rel="noopener ugc nofollow" target="_blank">http://192.168.1.11:8000</a></span></pre><p id="126f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">情况5:如果来自更广泛网络的VM1 (10.130.0.10)想要连接到运行在redapp命名空间中的webapp怎么办？更广泛的网络没有已知的redapp命名空间(pod IP 192.168.1.11)的路由。要么我们必须添加一条路由到更广阔的网络，要么我们可以使用DNAT(目的地NAT ),因为10.130.0.10能够连接到主机IP (10.128.0.2)。</p><pre class="na nb nc nd gt nh ni nj nk aw nl bi"><span id="4a71" class="lh li iq ni b gy nm nn l no np">#on node01<br/>iptables -t nat -A PREROUTING -j DNAT -p tcp --dport 30001 -d 10.128.0.2 --to-destination 192.168.1.11:8000</span></pre><p id="4412" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要在Kubernetes集群之外的虚拟机)上进行测试，请尝试以下操作</p><pre class="na nb nc nd gt nh ni nj nk aw nl bi"><span id="f28b" class="lh li iq ni b gy nm nn l no np">#on VM1</span><span id="7be2" class="lh li iq ni b gy nq nn l no np">ping 192.168.1.11<br/>curl <a class="ae ks" href="http://10.128.0.2:30001" rel="noopener ugc nofollow" target="_blank">http://10.128.0.2:30001</a></span></pre><p id="f9e3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在应该可以了。</p><p id="b8ed" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是pod网络的最简单实现。Kubernetes的<a class="ae ks" href="https://kubernetes.io/docs/concepts/cluster-administration/networking/" rel="noopener ugc nofollow" target="_blank">官方文档</a>讨论了其他实现。</p><p id="a0d8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了便于测试，我创建了一个脚本，您可以用它来创建桥、添加名称空间、删除名称空间和删除桥。所有你需要的是在GCP或Azure在同一个子网的2个微型虚拟机。</p><figure class="na nb nc nd gt ne"><div class="bz fp l di"><div class="oe of l"/></div></figure></div><div class="ab cl og oh hu oi" role="separator"><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol"/></div><div class="ij ik il im in"><p id="f0be" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请阅读我的其他文章，并分享您的反馈。如果你喜欢分享的内容，请点赞、评论并订阅新文章。请阅读我的其他文章，并分享您的反馈。如果你喜欢分享的内容，请点赞、评论并订阅新文章。</p></div></div>    
</body>
</html>