<html>
<head>
<title>Angular — Create your own Modal Boxes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">角度(angular )-创建自己的模态框</h1>
<blockquote>原文：<a href="https://itnext.io/angular-create-your-own-modal-boxes-20bb663084a1?source=collection_archive---------0-----------------------#2018-03-05">https://itnext.io/angular-create-your-own-modal-boxes-20bb663084a1?source=collection_archive---------0-----------------------#2018-03-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/2efc7cb19288d9d5dd48ac8db1e56a1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AJgPhU6aP9CpZ88j0vwrAQ.png"/></div></div></figure><p id="1c4b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kw" href="https://www.linkedin.com/cws/share?url=https%3A%2F%2Fitnext.io%2Fangular-create-your-own-modal-boxes-20bb663084a1" rel="noopener ugc nofollow" target="_blank"> <em class="kx">点击这里在LinkedIn上分享这篇文章</em> </a></p><p id="bfd0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现代网站有模态，要么向用户显示一些信息，要么从用户那里获取一些信息。如果你不知道什么是模态，下面是它的样子:</p><figure class="kz la lb lc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ky"><img src="../Images/28f684f9144b3462f7eb709cef917e16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Phi_0zYrngXM0ZicOJKdZA.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">登录模式框</figcaption></figure><p id="a1fb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有一些库允许你使用引导模式或其他模式类型。然而，您的web应用程序不太可能需要第三方库提供的所有特性。没有必要增加几个模态屏幕的包大小，您自己就可以轻松完成。</p><figure class="kz la lb lc gt jr gh gi paragraph-image"><div class="gh gi lh"><img src="../Images/1b0eb55c90839e1140d253959b7049cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:980/1*4INr8D4PvF8kdQfBsCp7dg.gif"/></div></figure><h2 id="8ab4" class="li lj iq bd lk ll lm dn ln lo lp dp lq kj lr ls lt kn lu lv lw kr lx ly lz ma bi translated"><strong class="ak">一个模态盒的积木</strong></h2><ol class=""><li id="ee86" class="mb mc iq ka b kb md kf me kj mf kn mg kr mh kv mi mj mk ml bi translated">将用户的注意力引向模态并隐藏背景的覆盖图。这只是一个简单的<code class="fe mm mn mo mp b">div</code>在屏幕上延伸，背景颜色是透明的。(不透明度&lt;1)<br/>T1】</li><li id="ec01" class="mb mc iq ka b kb mq kf mr kj ms kn mt kr mu kv mi mj mk ml bi translated">模态容器。这是一个简单的<code class="fe mm mn mo mp b">div</code>,它将在屏幕上显示模态组件时携带模态组件本身。如果用户决定关闭模态，这个<code class="fe mm mn mo mp b">div</code>容器将是空的。稍后我们将看到如何将我们的组件添加到这个<code class="fe mm mn mo mp b">div</code>容器中。<br/> <code class="fe mm mn mo mp b"><strong class="ka ir">&lt;div id=”modal-container&gt;&lt;/div&gt;</strong></code></li><li id="11b5" class="mb mc iq ka b kb mq kf mr kj ms kn mt kr mu kv mi mj mk ml bi translated">模态本身。由于这是一个有角度的帖子，这将是一个独立的组件，有自己的html，css和javascript。</li></ol><h2 id="4956" class="li lj iq bd lk ll lm dn ln lo lp dp lq kj lr ls lt kn lu lv lw kr lx ly lz ma bi translated">我们将要使用的方法概述</h2><p id="8c99" class="pw-post-body-paragraph jy jz iq ka b kb md kd ke kf me kh ki kj mv kl km kn mw kp kq kr mx kt ku kv ij bi translated">首先，我们将创建必要的服务来创建一个显示模态的系统化方法。我们将创建两个服务，即:</p><ol class=""><li id="d5ee" class="mb mc iq ka b kb kc kf kg kj my kn mz kr na kv mi mj mk ml bi translated">Dom服务</li><li id="8d29" class="mb mc iq ka b kb mq kf mr kj ms kn mt kr mu kv mi mj mk ml bi translated">模态服务</li></ol><blockquote class="nb nc nd"><p id="fbc6" class="jy jz kx ka b kb kc kd ke kf kg kh ki ne kk kl km nf ko kp kq ng ks kt ku kv ij bi translated">记得将服务作为提供者添加到必要的模块中</p></blockquote><p id="b770" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Dom服务，顾名思义，将负责从<code class="fe mm mn mo mp b">#modal-container</code>中创建和移除动态创建的组件(如上所述)。</p><p id="0d0a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">模态服务将使用Dom服务来初始化模态窗口或者销毁它。</p><p id="00eb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们很快就会详细讨论这两个问题。</p><p id="1df2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是首先让我们看看我们的<code class="fe mm mn mo mp b">app.component.html</code>文件</p><figure class="kz la lb lc gt jr"><div class="bz fp l di"><div class="nh ni l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">app.component.html</figcaption></figure><p id="7ad0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们应该把注意力集中在这个文件末尾的两个div上。第一个div <code class="fe mm mn mo mp b">#modal-container</code>是一个容器，我们动态生成的组件将在其中生存，直到它被用户杀死。</p><blockquote class="nb nc nd"><p id="9dbd" class="jy jz kx ka b kb kc kd ke kf kg kh ki ne kk kl km nf ko kp kq ng ks kt ku kv ij bi translated">O <!-- -->一次只能有一个组件存在于<code class="fe mm mn mo mp b">#modal-container</code>中，因为屏幕上一次只能有一个模态窗口</p></blockquote><p id="a0a9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第二个div是<code class="fe mm mn mo mp b">#overlay</code> div。这是使模态窗口后面的内容变暗的原因。它上面还有一个click事件，负责关闭模态。这当然是可选的。</p><p id="747a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意这两个div都有类<code class="fe mm mn mo mp b">hidden</code>。这个类隐藏了应用程序开始时的两个div，因为我们不想在用户登陆页面时显示一个模态窗口。当然，如果这是你想要的，那么你不应该使用<code class="fe mm mn mo mp b">hidden</code>类。</p><p id="26f4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">既然我们已经讨论了隐藏类，现在是时候看看我们将在设置中使用的css类了</p><figure class="kz la lb lc gt jr"><div class="bz fp l di"><div class="nh ni l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">应用程序.组件. css</figcaption></figure><p id="9e91" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这些css属性可以根据您的需要进行调整。但是它给了你一个基本的模态窗口和一个覆盖。</p><p id="a6f0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来我们要看的是组件本身，我们将在<code class="fe mm mn mo mp b">#modal-container</code> div中显示它。在本例中，我将其命名为<strong class="ka ir">样本组件</strong>。它只会显示一些文本。但是你可以在模态中显示任何组件，所以可能性是无限的。</p><figure class="kz la lb lc gt jr"><div class="bz fp l di"><div class="nj ni l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">样本组件</figcaption></figure><p id="86ba" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这里你可以看到javascript，HTML和CSS。当用户按下关闭按钮时，模态使用我们接下来将创建的<code class="fe mm mn mo mp b">ModalService</code>调用<code class="fe mm mn mo mp b">destroy()</code>方法来关闭模态。</p><p id="f93e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们先看看<code class="fe mm mn mo mp b">DomService</code>，因为它将用于<code class="fe mm mn mo mp b">ModalService</code></p><figure class="kz la lb lc gt jr"><div class="bz fp l di"><div class="nh ni l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">dom.service.ts</figcaption></figure><p id="b102" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这项服务很大，所以让我们一步一步来看。</p><p id="9d31" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该服务包含Angular提供的三项服务，即:</p><ol class=""><li id="c698" class="mb mc iq ka b kb kc kf kg kj my kn mz kr na kv mi mj mk ml bi translated"><a class="ae kw" href="https://angular.io/api/core/ComponentFactoryResolver" rel="noopener ugc nofollow" target="_blank">组件因子分解器</a></li><li id="c9d8" class="mb mc iq ka b kb mq kf mr kj ms kn mt kr mu kv mi mj mk ml bi translated"><a class="ae kw" href="https://angular.io/api/core/ApplicationRef" rel="noopener ugc nofollow" target="_blank">应用参考</a></li><li id="ca71" class="mb mc iq ka b kb mq kf mr kj ms kn mt kr mu kv mi mj mk ml bi translated"><a class="ae kw" href="https://angular.io/api/core/Injector" rel="noopener ugc nofollow" target="_blank">喷油器</a></li></ol><figure class="kz la lb lc gt jr gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/678710b35e895c956e1c6049366f2237.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*VYdDA3z8BKUQIk_5QRJKoQ.jpeg"/></div></figure><p id="d7a6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">谈论这些不在本文范围内。然而，你可以通过谷歌来更好地理解它们。如果你有一些角度的经验，理解它们不会是一个问题。记住<code class="fe mm mn mo mp b">DomService</code>的职责是动态创建组件，并在DOM中添加/删除组件。</p><p id="ff71" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该服务有两个公共方法，即:</p><ol class=""><li id="83c4" class="mb mc iq ka b kb kc kf kg kj my kn mz kr na kv mi mj mk ml bi translated"><code class="fe mm mn mo mp b">appendComponentTo()</code></li><li id="a3c1" class="mb mc iq ka b kb mq kf mr kj ms kn mt kr mu kv mi mj mk ml bi translated"><code class="fe mm mn mo mp b">removeComponent()</code></li></ol><p id="d4a8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们看看第一种方法。这个方法接受三个参数。<code class="fe mm mn mo mp b">parentId</code>，在这种情况下将是<code class="fe mm mn mo mp b">#modal-container</code>，因为组件的父组件将是我们的模态容器。第二个论点是<code class="fe mm mn mo mp b">child</code>。这是组件本身。第三个是<code class="fe mm mn mo mp b">childConfig</code>。这是一个包含输入和输出的对象，将被传递给<code class="fe mm mn mo mp b">child</code>组件。这部分不用担心，很快就说得通了。代码被注释了，所以理解它应该不成问题。但是，有几行我想看一下。</p><pre class="kz la lb lc gt nl mp nm nn aw no bi"><span id="129a" class="li lj iq mp b gy np nq l nr ns">this.childComponentRef = childComponentRef;</span></pre><p id="a37f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这条线很重要。<code class="fe mm mn mo mp b">this.childComponentRef</code>是服务上的私有属性，由<code class="fe mm mn mo mp b">removeComponent()</code>公共方法访问。正如我们前面所说的，一次只向用户显示一个模态窗口，这意味着在<code class="fe mm mn mo mp b">#modal-container</code>中只能存在一个组件。该组件在创建时存储在<code class="fe mm mn mo mp b">this.childComponentRef</code>变量中。在您的应用中，您可以将该变量视为<strong class="ka ir">当前活动模态分量</strong>。</p><p id="54be" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个方法的最后一行，<code class="fe mm mn mo mp b">document.getElementById(parentId).appendChild(childDomElem)</code>将组件附加到<code class="fe mm mn mo mp b">#parentId</code> div中。</p><p id="8598" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第二个公共方法是<code class="fe mm mn mo mp b">removeComponent()</code>方法。这种方法破坏了<strong class="ka ir">电流有效模态分量</strong>。它还将它从组件树中删除，这样angular就知道在发生变化检测时不检查它。为了理解变更检测，我推荐Pascal Precht的这篇文章。</p><p id="d984" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们要看的下一个服务是<code class="fe mm mn mo mp b">ModalService</code>。</p><figure class="kz la lb lc gt jr"><div class="bz fp l di"><div class="nh ni l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">modal.service.ts</figcaption></figure><p id="a976" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这项服务非常简单。它又有两个公共方法，即:<br/> 1。<code class="fe mm mn mo mp b">init()</code></p><p id="f195" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">2.<code class="fe mm mn mo mp b">destroy()</code></p><p id="c37c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mm mn mo mp b">init()</code>方法采用3个输入初始化模态窗口，即:</p><ol class=""><li id="59a2" class="mb mc iq ka b kb kc kf kg kj my kn mz kr na kv mi mj mk ml bi translated">成分</li><li id="16b8" class="mb mc iq ka b kb mq kf mr kj ms kn mt kr mu kv mi mj mk ml bi translated">输入</li><li id="2238" class="mb mc iq ka b kb mq kf mr kj ms kn mt kr mu kv mi mj mk ml bi translated">输出</li></ol><p id="c9af" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">init方法使用DomService将组件附加到DOM和角度组件树中。然后，我们通过使用<code class="fe mm mn mo mp b">.show</code>类来显示模态和覆盖。</p><p id="2d78" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mm mn mo mp b">destroy()</code>方法破坏组件并隐藏模态和覆盖。</p><p id="7bb0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这就完成了设置的主要部分。</p><figure class="kz la lb lc gt jr gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/18ba3c14644c9daed2a8c9eb55c0640a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*nIHlu6vTdPUSq3nfEC1q6g.jpeg"/></div></figure><h2 id="624f" class="li lj iq bd lk ll lm dn ln lo lp dp lq kj lr ls lt kn lu lv lw kr lx ly lz ma bi translated">入口组件</h2><p id="2dda" class="pw-post-body-paragraph jy jz iq ka b kb md kd ke kf me kh ki kj mv kl km kn mw kp kq kr mx kt ku kv ij bi translated">我们不应该忘记的另一件事是在模块的<code class="fe mm mn mo mp b">entryComponents</code>中添加<code class="fe mm mn mo mp b">SampleComponent</code>。</p><figure class="kz la lb lc gt jr"><div class="bz fp l di"><div class="nh ni l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">应用程序模块</figcaption></figure><p id="3829" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mm mn mo mp b">entryComponents</code>用于定义最初在html中找不到的组件，这些组件是用<code class="fe mm mn mo mp b">ComponentFactoryResolver</code>动态创建的。为了让angular编译，它需要在模块中使用这个提示。由于我们的<code class="fe mm mn mo mp b">SampleComponent</code>将被动态添加到DOM中，我们需要在NgModule装饰器中提到它。</p><h2 id="6801" class="li lj iq bd lk ll lm dn ln lo lp dp lq kj lr ls lt kn lu lv lw kr lx ly lz ma bi translated">把这些都用上</h2><p id="a891" class="pw-post-body-paragraph jy jz iq ka b kb md kd ke kf me kh ki kj mv kl km kn mw kp kq kr mx kt ku kv ij bi translated">在这里，我将向您展示如何使用您创建的新模态服务。您所需要做的就是将ModalService导入到您希望从中显示模式的组件中。然后只需调用服务上的init()方法，并传递想要显示的组件。现在就这么简单。</p><figure class="kz la lb lc gt jr"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="cef7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以将输入/输出作为第二个和第三个参数传递给组件。在这个例子中，我在这里传递了一个输入对象。</p><figure class="kz la lb lc gt jr gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/b42c713d0c636e2b010821a85ebeec61.png" data-original-src="https://miro.medium.com/v2/resize:fit:596/format:webp/1*Eu0S4FmNTju7E_T9a3qqzA.jpeg"/></div></figure><h2 id="ccb0" class="li lj iq bd lk ll lm dn ln lo lp dp lq kj lr ls lt kn lu lv lw kr lx ly lz ma bi translated">响应性</h2><p id="b858" class="pw-post-body-paragraph jy jz iq ka b kb md kd ke kf me kh ki kj mv kl km kn mw kp kq kr mx kt ku kv ij bi translated">要使模态具有响应性，可以很容易地通过媒体查询来实现。我可以在另一篇文章中谈论响应性，但这很简单，你可以在网上找到大量的资源来做这件事。</p><h2 id="2ec0" class="li lj iq bd lk ll lm dn ln lo lp dp lq kj lr ls lt kn lu lv lw kr lx ly lz ma bi translated">结论</h2><p id="e685" class="pw-post-body-paragraph jy jz iq ka b kb md kd ke kf me kh ki kj mv kl km kn mw kp kq kr mx kt ku kv ij bi translated">请记住，所有这些努力的目的是不要导入一个完全成熟的模态库，它可能会有bug或大量额外的开销，而这些在您的应用程序中可能并不需要。这样，随着需求的变化，您可以扩展您的迷你模型库。</p><p id="3d51" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我希望这对你们有帮助。干杯！</p></div></div>    
</body>
</html>