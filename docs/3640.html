<html>
<head>
<title>Building a static blog site with Markdown and Next.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Markdown和Next.js构建静态博客网站</h1>
<blockquote>原文：<a href="https://itnext.io/building-a-static-blog-site-with-markdown-and-next-js-702c515389b3?source=collection_archive---------2-----------------------#2020-01-22">https://itnext.io/building-a-static-blog-site-with-markdown-and-next-js-702c515389b3?source=collection_archive---------2-----------------------#2020-01-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/60b6ce3cb3088a4b83d5f4623432cf59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vPjKNWCkZ4Bp2pMp2oUesA.jpeg"/></div></div></figure><p id="51b2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最近，我们看到了新技术的出现，以及开发工具和服务的发展，其规模之大，是我们作为开发人员十年前只能梦想的。</p><p id="39cd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们现在可以使用高质量的开源库(在<strong class="kd iu"> JavaScript </strong>中)和开箱即用的漂亮UI库来构建非常丰富的内容网站。使web开发人员的工作更容易，使我们能够在更短的时间内交付高质量的产品，并专注于功能、内容和缩短生产时间等。</p><p id="cb7c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">有了所有的开发工具和服务，我们可以在不需要服务器的情况下建立一个完整的网站，我们开始怀疑，在某些情况下，在云中部署静态内容(<strong class="kd iu"> CDN </strong>实例)并通过持续部署进行更新(<strong class="kd iu"> CD </strong>)就足够了。</p><p id="292a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">另一方面，静态站点生成器和<strong class="kd iu"> SSR </strong> [ ]框架解决了<strong class="kd iu"> SPA </strong>诞生以来所遭遇的问题之一。使用单页面应用程序在社交媒体上分享时，很难获得搜索引擎优化或特定子页面的预览，这可以通过预渲染和/或服务器端[ ]轻松完成。</p><p id="686a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">此外，SSR和静态页面很少比SPA更快，因为与JS捆绑包大小相比，从引导程序到单个页面应用程序上的完整呈现所需的API的连续调用减少了从服务器呈现的降价。</p><h1 id="9835" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">构建静态博客网站</h1><p id="4a92" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">今天我们将使用<a class="ae mc" href="https://en.wikipedia.org/wiki/Markdown" rel="noopener ugc nofollow" target="_blank"> Markdown </a>和一个奇妙的SSR React框架<a class="ae mc" href="https://nextjs.org/" rel="noopener ugc nofollow" target="_blank"> Next.js </a>来构建一个静态博客网站</p><p id="bd54" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于这个项目，我们将使用以下软件包:</p><ul class=""><li id="7ce7" class="md me it kd b ke kf ki kj km mf kq mg ku mh ky mi mj mk ml bi translated"><a class="ae mc" href="https://github.com/facebook/react" rel="noopener ugc nofollow" target="_blank">React</a>UI的声明性JS库。</li><li id="acae" class="md me it kd b ke mm ki mn km mo kq mp ku mq ky mi mj mk ml bi translated"><a class="ae mc" href="https://github.com/zeit/next.js" rel="noopener ugc nofollow" target="_blank"> Next.js </a>同构在服务器和浏览器上反应</li><li id="e1c1" class="md me it kd b ke mm ki mn km mo kq mp ku mq ky mi mj mk ml bi translated"><a class="ae mc" href="https://github.com/mui-org/material-ui" rel="noopener ugc nofollow" target="_blank"> Material-UI </a>华丽的UI设计开箱</li><li id="4bd1" class="md me it kd b ke mm ki mn km mo kq mp ku mq ky mi mj mk ml bi translated"><a class="ae mc" href="https://github.com/mdx-js/mdx" rel="noopener ugc nofollow" target="_blank">MDX</a>“JSX为雄心勃勃的项目降价。”</li><li id="92d7" class="md me it kd b ke mm ki mn km mo kq mp ku mq ky mi mj mk ml bi translated"><a class="ae mc" href="https://github.com/lukeed/clsx" rel="noopener ugc nofollow" target="_blank"> clsx </a>“一个用于有条件地构造<code class="fe mr ms mt mu b">className</code>字符串的小工具”</li></ul><p id="a5cf" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这个项目的源代码库可以在这里<a class="ae mc" href="https://github.com/sepineda/blog-next" rel="noopener ugc nofollow" target="_blank">获得。</a></p><h2 id="ab54" class="mv la it bd lb mw mx dn lf my mz dp lj km na nb ln kq nc nd lr ku ne nf lv ng bi translated">入门指南</h2><p id="f41f" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">让我们首先为我们的项目创建一个新目录，初始化一个<code class="fe mr ms mt mu b">package.json</code>文件，然后安装React和Next.js包，</p><pre class="nh ni nj nk gt nl mu nm nn aw no bi"><span id="2b1f" class="mv la it mu b gy np nq l nr ns">mkdir blog-next<br/>cd blog-next<br/>npm init -y<br/>npm install --save react react-dom next</span></pre><p id="09c9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，JS内置了路由器系统，可以开箱即用；我们需要创建一个<code class="fe mr ms mt mu b">pages</code>目录，</p><pre class="nh ni nj nk gt nl mu nm nn aw no bi"><span id="b4ad" class="mv la it mu b gy np nq l nr ns">mkdir pages</span></pre><p id="1deb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">随着我们构建博客应用程序的进展，我们将添加新的页面作为React jsx组件。</p><p id="a708" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们也在给<code class="fe mr ms mt mu b">package.json</code>添加一些脚本，</p><pre class="nh ni nj nk gt nl mu nm nn aw no bi"><span id="4b8f" class="mv la it mu b gy np nq l nr ns">"scripts": {<br/>  "dev":<br/>  "next",<br/>  "build": "next build",<br/>  "start": "next start"<br/>}</span></pre><p id="9c7c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">分别以开发模式、构建静态内容和生产模式启动。</p><h2 id="5022" class="mv la it bd lb mw mx dn lf my mz dp lj km na nb ln kq nc nd lr ku ne nf lv ng bi translated">使组件与材料反应-用户界面</h2><p id="ac2b" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">继续元件库选择选项(<strong class="kd iu"> Material-UI </strong>)，首先安装元件库安装，</p><pre class="nh ni nj nk gt nl mu nm nn aw no bi"><span id="e739" class="mv la it mu b gy np nq l nr ns">yarn add @material-ui/core</span></pre><p id="5c4f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在我们需要做一些修改，这些修改适用于我们站点中所有提供的页面。由于Material UI和其他react库依赖于JavaScript(Material-UI的CSS-in-JS)中的样式引擎，因此不需要Next.js中默认提供的内置<code class="fe mr ms mt mu b">jss-server-side</code>功能。为了修改这一点，我们通过在<code class="fe mr ms mt mu b">/pages/_app.js</code>添加一个页面来覆盖配置，</p><pre class="nh ni nj nk gt nl mu nm nn aw no bi"><span id="a6af" class="mv la it mu b gy np nq l nr ns">import React, { useEffect } from 'react';<br/>import Head from 'next/head';<br/>import { ThemeProvider } from '<a class="ae mc" href="http://twitter.com/material" rel="noopener ugc nofollow" target="_blank">@material</a>-ui/core/styles';<br/>import CssBaseline from '<a class="ae mc" href="http://twitter.com/material" rel="noopener ugc nofollow" target="_blank">@material</a>-ui/core/CssBaseline';<br/>import PropTypes from 'prop-types';<br/>import theme from '../components/theme';</span><span id="89ba" class="mv la it mu b gy nt nq l nr ns">function MyApp({ Component, pageProps }) {<br/>  useEffect(() =&gt; {<br/>    // Remove the server-side injected CSS.<br/>    const jssStyles = document.querySelector('#jss-server-side');<br/>    if (jssStyles) {<br/>      jssStyles.parentElement.removeChild(jssStyles);<br/>    }<br/>  }, []);<br/>  return (<br/>    &lt;React.Fragment&gt;<br/>      &lt;Head&gt;<br/>        &lt;title&gt;My Next Blog&lt;/title&gt;<br/>        &lt;meta<br/>          name="viewport"<br/>          content="minimum-scale=1, initial-scale=1, width=device-width"<br/>        /&gt;<br/>      &lt;/Head&gt;<br/>      &lt;ThemeProvider theme={theme}&gt;<br/>        &lt;CssBaseline /&gt;<br/>        &lt;Component {...pageProps} /&gt;<br/>      &lt;/ThemeProvider&gt;<br/>    &lt;/React.Fragment&gt;<br/>  );<br/>}</span><span id="0b6d" class="mv la it mu b gy nt nq l nr ns">MyApp.propTypes={<br/>  Component: PropTypes.oneOfType([PropTypes.node, PropTypes.func]),<br/>  pageProps: PropTypes.object<br/>}</span><span id="6ceb" class="mv la it mu b gy nt nq l nr ns">export default MyApp;</span></pre><p id="aeec" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">正如你可能注意到的，我们还添加了一个<code class="fe mr ms mt mu b">ThemeProvider</code>来为Material-UI定制主题。所以下一步是创建一个新的文件夹<code class="fe mr ms mt mu b">/components</code>来添加新的公共组件，同时创建一个新的<code class="fe mr ms mt mu b">theme.js</code>文件，</p><pre class="nh ni nj nk gt nl mu nm nn aw no bi"><span id="a197" class="mv la it mu b gy np nq l nr ns">import { createMuiTheme } from '<a class="ae mc" href="http://twitter.com/material" rel="noopener ugc nofollow" target="_blank">@material</a>-ui/core/styles';<br/>import { red } from '<a class="ae mc" href="http://twitter.com/material" rel="noopener ugc nofollow" target="_blank">@material</a>-ui/core/colors';</span><span id="a8db" class="mv la it mu b gy nt nq l nr ns">// Create a theme instance.<br/>const theme = createMuiTheme({<br/>  palette: {<br/>    primary: {<br/>      main: '#283E4A',<br/>    },<br/>    secondary: {<br/>      main: '#19857b',<br/>    },<br/>    error: {<br/>      main: red.A400,<br/>    },<br/>    background: {<br/>      default: '#F5F5F5',<br/>    },<br/>  },<br/>});</span><span id="239b" class="mv la it mu b gy nt nq l nr ns">export default theme;</span></pre><p id="093f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">有了这些变化，我们就可以开始用材料设计构建布局和新组件了👌。</p><h2 id="af31" class="mv la it bd lb mw mx dn lf my mz dp lj km na nb ln kq nc nd lr ku ne nf lv ng bi translated">网站布局</h2><p id="50b5" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">我们博客站点的布局包括一个navbar，其中有指向主页的邮件链接(title)和一个about链接，一个专题博客文章的部分标题，以及一个两列网格显示卡片，上面有标题、发表日期和每篇文章的内容摘要，</p><figure class="nh ni nj nk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nu"><img src="../Images/7d6f9ae6ec755bd5cfc7dcbe6472b9d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DbRwcRWOogM2aitYAi1R-Q.png"/></div></div></figure><p id="a3a6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们需要定义的第一个组件是<code class="fe mr ms mt mu b">/pages/index.jsx</code>，这也将是我们在<code class="fe mr ms mt mu b">my-domain.com/</code>的登录页面，其中<code class="fe mr ms mt mu b">my-domain</code>是生产领域，如果我们在开发中，则简称为<code class="fe mr ms mt mu b">localhost:3000</code>。然后如下定义索引页，</p><pre class="nh ni nj nk gt nl mu nm nn aw no bi"><span id="fdcf" class="mv la it mu b gy np nq l nr ns">import React from 'react';<br/>import {<br/>  Container,<br/>  Typography,<br/>  Box,<br/>  Grid,<br/>  CssBaseline<br/>} from '<a class="ae mc" href="http://twitter.com/material" rel="noopener ugc nofollow" target="_blank">@material</a>-ui/core';<br/>import { makeStyles } from '<a class="ae mc" href="http://twitter.com/material" rel="noopener ugc nofollow" target="_blank">@material</a>-ui/core/styles';<br/>import Header from '../components/Header';<br/>import PostCard from '../components/PostCard';<br/>import blogPosts from '../data/blog-posts';<br/>import Footer from '../components/Footer';</span><span id="cc1e" class="mv la it mu b gy nt nq l nr ns">const useStyles = makeStyles({<br/>  container: {<br/>    minHeight: '80vh'<br/>  }<br/>});</span><span id="0d8a" class="mv la it mu b gy nt nq l nr ns">const Index = () =&gt; {<br/>  const classes = useStyles();<br/>  return (<br/>    &lt;React.Fragment&gt;<br/>      &lt;CssBaseline /&gt;<br/>      &lt;Header /&gt;<br/>      &lt;Container maxWidth="lg" className={classes.container}&gt;<br/>        &lt;Box my={4} display="flex" justifyContent="center"&gt;<br/>          &lt;Typography variant="h4" component="h1" gutterBottom&gt;<br/>            Featured Blog posts<br/>          &lt;/Typography&gt;<br/>        &lt;/Box&gt;<br/>        &lt;Grid container spacing={4}&gt;<br/>          {blogPosts.map(post =&gt; (<br/>            &lt;PostCard key={post.title} post={post} /&gt;<br/>          ))}<br/>        &lt;/Grid&gt;<br/>      &lt;/Container&gt;<br/>      &lt;Footer title="My Blog" description="Hi there, this is my blog!" /&gt;<br/>    &lt;/React.Fragment&gt;<br/>  );<br/>};</span><span id="986f" class="mv la it mu b gy nt nq l nr ns">export default Index;</span></pre><p id="78ea" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里我们使用了<code class="fe mr ms mt mu b">/components</code>目录中的其他组件，比如顶部导航面板的<code class="fe mr ms mt mu b">Header</code>，或者底部面板的<code class="fe mr ms mt mu b">Footer</code>。这些组件相对较小且简单；你可以在我的<a class="ae mc" href="https://github.com/sepineda/blog-next" rel="noopener ugc nofollow" target="_blank"> Github repo </a>看看这些组件。但我想对第三个组件<code class="fe mr ms mt mu b">PostCard</code>和导入的数组<code class="fe mr ms mt mu b">blogPosts</code>做更多的阐述，因为它们是微博引擎的核心元素。</p><p id="ee7e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">先来看看<code class="fe mr ms mt mu b">PostCard.jsx</code>，</p><pre class="nh ni nj nk gt nl mu nm nn aw no bi"><span id="7cb2" class="mv la it mu b gy np nq l nr ns">import React from 'react';<br/>import { makeStyles } from '<a class="ae mc" href="http://twitter.com/material" rel="noopener ugc nofollow" target="_blank">@material</a>-ui/core/styles';<br/>import { Typography, Grid, Card, CardContent } from '<a class="ae mc" href="http://twitter.com/material" rel="noopener ugc nofollow" target="_blank">@material</a>-ui/core';<br/>import PropTypes from 'prop-types';<br/>import Link from './Link';</span><span id="12d1" class="mv la it mu b gy nt nq l nr ns">const useStyles = makeStyles({<br/>  card: {<br/>    display: 'flex'<br/>  },<br/>  cardDetails: {<br/>    flex: 1<br/>  }<br/>});</span><span id="85db" class="mv la it mu b gy nt nq l nr ns">const PostCard = ({ post }) =&gt; {<br/>  const classes = useStyles();<br/>  return (<br/>    &lt;Grid item xs={12} md={6}&gt;<br/>      &lt;Link href={post.path}&gt;<br/>        &lt;Card className={classes.card}&gt;<br/>          &lt;div className={classes.cardDetails}&gt;<br/>            &lt;CardContent&gt;<br/>              &lt;Typography component="h2" variant="h5"&gt;<br/>                {post.title}<br/>              &lt;/Typography&gt;<br/>              &lt;Typography variant="subtitle1" color="textSecondary"&gt;<br/>                {post.publishedAt}<br/>              &lt;/Typography&gt;<br/>              &lt;Typography variant="subtitle1" paragraph&gt;<br/>                {post.summary}<br/>              &lt;/Typography&gt;<br/>              &lt;Typography variant="subtitle1" color="primary"&gt;<br/>                Continue reading...<br/>              &lt;/Typography&gt;<br/>            &lt;/CardContent&gt;<br/>          &lt;/div&gt;<br/>        &lt;/Card&gt;<br/>      &lt;/Link&gt;<br/>    &lt;/Grid&gt;<br/>  );<br/>}</span><span id="69b1" class="mv la it mu b gy nt nq l nr ns">PostCard.propTypes={<br/>  post: PropTypes.object<br/>}</span><span id="569e" class="mv la it mu b gy nt nq l nr ns">export default PostCard;</span></pre><p id="9944" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是一个需要包含标题、发布日期、路径或href和摘要的属性<code class="fe mr ms mt mu b">post</code>的组件，正如我们在布局图中看到的。</p><h2 id="dba3" class="mv la it bd lb mw mx dn lf my mz dp lj km na nb ln kq nc nd lr ku ne nf lv ng bi translated">在Next.js中设置降价配置</h2><p id="20cc" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">因此，我们需要以某种方式将我们在Markdown中写的博客文章的这些属性提供给<code class="fe mr ms mt mu b">PostCard</code>组件，以便在页面上显示预览。我们如何做到这一点？。嗯，答案是我们的站点是静态的，所以我们只是从文件系统中读取它们！。</p><p id="56d2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">但在此之前，我们需要安装和配置我们将用来与Markdown一起工作的包:<a class="ae mc" href="https://mdxjs.com/getting-started/next" rel="noopener ugc nofollow" target="_blank"> MDX </a>，幸运的是它已经准备好与Next.js一起工作了。</p><p id="be7f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们为next.js添加了next和一个插件，</p><pre class="nh ni nj nk gt nl mu nm nn aw no bi"><span id="6b9c" class="mv la it mu b gy np nq l nr ns">yarn add @next/mdx @mdx-js/loader</span></pre><p id="10b1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后创建文件<code class="fe mr ms mt mu b">/next.config.js</code>并包含这些内容，</p><pre class="nh ni nj nk gt nl mu nm nn aw no bi"><span id="a33a" class="mv la it mu b gy np nq l nr ns">const withMDX = require('<a class="ae mc" href="http://twitter.com/next/mdx" rel="noopener ugc nofollow" target="_blank">@next/mdx</a>')({<br/>  extension: /\.mdx?$/<br/>});</span><span id="58dd" class="mv la it mu b gy nt nq l nr ns">module.exports = withMDX({<br/>  pageExtensions: ['js', 'jsx', 'md', 'mdx']<br/>});</span></pre><p id="26a0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这告诉next自动导入扩展名为<code class="fe mr ms mt mu b">.md</code>的文件，并像处理JSX文件一样处理它们，我们会看到我们的帖子实际上是两者，一个JSX React组件，同时也是一个Markdown文件。</p><p id="55a4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在让我们定义JavaScript实用程序来加载markdown中的文章。让我们创建一个文件夹<code class="fe mr ms mt mu b">/data</code>并在文件<code class="fe mr ms mt mu b">get-blog-posts.js</code>中，</p><pre class="nh ni nj nk gt nl mu nm nn aw no bi"><span id="d6ae" class="mv la it mu b gy np nq l nr ns">const fs = require('fs');<br/>const path = require('path');</span><span id="c320" class="mv la it mu b gy nt nq l nr ns">const META = /export\s+const\s+meta\s+=\s+(\{(\n|.)*?\n\})/;<br/>const DIR = path.join(process.cwd(), './pages/blog/');<br/>const files = fs<br/>  .readdirSync(DIR)<br/>  .filter((file) =&gt; file.endsWith('.md'));</span><span id="8c5e" class="mv la it mu b gy nt nq l nr ns">module.exports = files<br/>  .map(file =&gt; {<br/>    const name = path.join(DIR, file);<br/>    const contents = fs.readFileSync(name, 'utf8');<br/>    const match = META.exec(contents);</span><span id="71fe" class="mv la it mu b gy nt nq l nr ns">if (!match || typeof match[1] !== 'string')<br/>      throw new Error(`${name} needs to export const meta = {}`);</span><span id="ffcc" class="mv la it mu b gy nt nq l nr ns">const meta = eval('(' + match[1] + ')');</span><span id="5d92" class="mv la it mu b gy nt nq l nr ns">return {<br/>        ...meta,<br/>        path: '/blog/' + file.replace(/\.mdx?$/, '')<br/>      };<br/>  })<br/>  .filter((meta) =&gt; meta.published)<br/>  .sort((a, b) =&gt; new Date(b.publishedAt) - new Date(a.publishedAt));</span></pre><p id="0a47" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这个函数在文件夹<code class="fe mr ms mt mu b">/pages/blog/</code>中查找任何扩展名为<code class="fe mr ms mt mu b">.md</code>的文件，在每个文件中，它需要一个名为<code class="fe mr ms mt mu b">meta</code>的对象，这个对象存放了文章的属性(标题、路径、摘要和发布日期)，这是函数最终导出的内容。</p><p id="1fe2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后让我们看看博客帖子展示是什么样子的，</p><pre class="nh ni nj nk gt nl mu nm nn aw no bi"><span id="914e" class="mv la it mu b gy np nq l nr ns">import BlogPost from '../../components/BlogPost';</span><span id="7e86" class="mv la it mu b gy nt nq l nr ns">export const meta = {<br/>  published: true,<br/>  publishedAt: '2019-01-15',<br/>  title: 'This is my very first blog post',<br/>  summary:<br/>    'I am learning how to build a blog using Markdown in a static web page build on top of Next.js'<br/>};</span><span id="1b74" class="mv la it mu b gy nt nq l nr ns">export default ({ children }) =&gt; &lt;BlogPost meta={meta}&gt;{children}&lt;/BlogPost&gt;;</span><span id="e455" class="mv la it mu b gy nt nq l nr ns">Lorem ipsum dolor sit amet, consectetur adipiscing elit. Quisque maximus pellentesque dolor non egestas. In sed tristique elit. Cras vehicula, nisl vel ultricies gravida, augue nibh laoreet arcu, et tincidunt augue dui non elit. Vestibulum semper posuere magna, quis molestie mauris faucibus ut. Praesent ornare velit sit amet enim semper lacinia. Aenean nec sem lacus. Cras porta nunc nec leo lacinia sagittis. Aliquam ornare gravida cursus. Etiam ultrices massa quis erat scelerisque rhoncus. Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia Curae; Proin lacinia sodales augue, non mattis ipsum pretium non. Morbi vehicula tempor blandit. Nam rhoncus, massa a maximus imperdiet, tortor risus aliquet tortor, nec lacinia eros nisi volutpat massa. Maecenas ut augue ipsum.</span></pre><p id="3d57" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是在<code class="fe mr ms mt mu b">/pages/blog/my-first-post.md</code>的一篇文章的第一部分(注意，我在页面中添加了一个子目录<code class="fe mr ms mt mu b">blog</code>，以将文章与其他页面分开)。它从导入一个React组件<code class="fe mr ms mt mu b">BlogPost</code>开始，这是博客内容的框架，我们马上就会看到。然后我们有了包含博文元数据的元对象，这个JSX文件的默认导出(一个react组件)，最后是博文内容！就这样，我们在博客上写了一篇文章，简单明了。🙂</p><h2 id="be5b" class="mv la it bd lb mw mx dn lf my mz dp lj km na nb ln kq nc nd lr ku ne nf lv ng bi translated">处理静态资源</h2><p id="7074" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">回到我们在索引页面上的文章预览，我们现在应该能够导入元数据并在卡片中显示它。然而，我们仍然需要一个额外的步骤，因为我们处理静态数据，导入应该发生在编译时，而常规的<code class="fe mr ms mt mu b">import</code>不会起作用，因为当它在浏览器中执行时，它会试图将服务器中的数据带出来。这个挑战的解决方案是什么？在提供给客户端之前，我们会在服务器上预先评估<code class="fe mr ms mt mu b">get-blog-posts.js</code>给出的内容。为此，我们将使用babel中可用的几个插件:<code class="fe mr ms mt mu b">babel-plugin-macros</code>和<code class="fe mr ms mt mu b">babel-plugin-preval</code>，</p><pre class="nh ni nj nk gt nl mu nm nn aw no bi"><span id="a47b" class="mv la it mu b gy np nq l nr ns">yarn add --dev babel-plugin-macros babel-plugin-preval</span></pre><p id="3092" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">添加一个文件<code class="fe mr ms mt mu b">.babelrc</code>和内容，</p><pre class="nh ni nj nk gt nl mu nm nn aw no bi"><span id="5900" class="mv la it mu b gy np nq l nr ns">{<br/>  "presets": ["next/babel"],<br/>  "plugins": ["macros"]<br/>}</span></pre><p id="1fb9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们在<code class="fe mr ms mt mu b">/data/blog-posts.js</code>添加了一个文件，这就是奇迹发生的地方，</p><pre class="nh ni nj nk gt nl mu nm nn aw no bi"><span id="2ae4" class="mv la it mu b gy np nq l nr ns">import preval from "babel-plugin-preval/macro";</span><span id="30c3" class="mv la it mu b gy nt nq l nr ns">module.exports = preval`module.exports = require('./get-blog-posts.js');`;</span></pre><p id="3209" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最后一行预先评估了由<code class="fe mr ms mt mu b">get-blog-posts.js</code>获取的内容，所以我们实际上是在导出元对象的数组，而不是获取它们的函数。</p><h2 id="aad9" class="mv la it bd lb mw mx dn lf my mz dp lj km na nb ln kq nc nd lr ku ne nf lv ng bi translated">将博客文章显示为独立页面</h2><p id="df8c" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">最后，我们将看到一篇博文会是什么样子</p><figure class="nh ni nj nk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nv"><img src="../Images/c79d13ded38d603988bc89b38842109d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oMtjgB2fyL2jBnI6gum6ZA.png"/></div></div></figure><p id="4ebc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">索引页上有导航和页脚面板。此外，在左上角有一个“回到博客”的链接，以返回到登录页面，在帖子的下半部分有几个链接，以转到上一个和/或下一个博客，我们需要在这里再次使用。</p><pre class="nh ni nj nk gt nl mu nm nn aw no bi"><span id="b477" class="mv la it mu b gy np nq l nr ns">import React, { Fragment } from 'react';<br/>import Link from './Link';<br/>import Header from './Header';<br/>import blogposts from '../data/blog-posts';<br/>import { Container, Box, Typography } from '<a class="ae mc" href="http://twitter.com/material" rel="noopener ugc nofollow" target="_blank">@material</a>-ui/core';<br/>import Footer from './Footer';</span><span id="ed2b" class="mv la it mu b gy nt nq l nr ns">const NextPost = ({ href, position, title }) =&gt; (<br/>  &lt;Link href={href}&gt;<br/>    {position}{' '}<br/>    &lt;Typography variant="h6" component="h6"&gt;<br/>      {title}<br/>    &lt;/Typography&gt;<br/>  &lt;/Link&gt;<br/>);</span><span id="f3f8" class="mv la it mu b gy nt nq l nr ns">const BlogPost = ({ meta, children }) =&gt; {<br/>  const current = blogposts.map(({ title }) =&gt; title).indexOf(meta.title);<br/>  const next = blogposts[current - 1];<br/>  const prev = blogposts[current + 1];</span><span id="a526" class="mv la it mu b gy nt nq l nr ns">return (<br/>    &lt;Fragment&gt;<br/>      &lt;Header /&gt;<br/>      &lt;Container maxWidth="md"&gt;<br/>        &lt;Box my={4}&gt;<br/>          &lt;Link href="/"&gt;{'&lt; '} BACK TO BLOG&lt;/Link&gt;<br/>        &lt;/Box&gt;<br/>        &lt;Typography variant="h4" component="h1" gutterBottom&gt;<br/>          {meta.title}<br/>        &lt;/Typography&gt;<br/>        {children}<br/>        &lt;hr /&gt;<br/>        &lt;Box my={4} display="flex" justifyContent="center"&gt;<br/>          &lt;Box mx={4}&gt;<br/>            {prev &amp;&amp; (<br/>              &lt;NextPost<br/>                href={prev.path}<br/>                position="&lt; Previous post"<br/>                title={prev.title}<br/>              /&gt;<br/>            )}<br/>          &lt;/Box&gt;<br/>          &lt;Box mx={4}&gt;<br/>            {next &amp;&amp; (<br/>              &lt;NextPost<br/>                href={next.path}<br/>                position="Next post &gt;"<br/>                title={next.title}<br/>              /&gt;<br/>            )}<br/>          &lt;/Box&gt;<br/>        &lt;/Box&gt;<br/>      &lt;/Container&gt;<br/>      &lt;Footer title="My Blog" description="Hi there, this is my blog!" /&gt;<br/>    &lt;/Fragment&gt;<br/>  );<br/>};</span><span id="ed71" class="mv la it mu b gy nt nq l nr ns">export default BlogPost;</span></pre><p id="a891" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">…这就是了！。你现在可以开始写你的博客了。🙌🏼</p><p id="0dc5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你想上线，在zeit.com<a class="ae mc" href="https://zeit.co/" rel="noopener ugc nofollow" target="_blank">有一个很好的托管选项，在那里你可以非常快速地部署你的项目，直接与GitHub集成CD，你甚至不需要信用卡就可以启动。</a></p><p id="c737" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">谢谢你阅读我的博客！。请关注我的<a class="ae mc" href="https://epineda.dev/contact" rel="noopener ugc nofollow" target="_blank">频道</a>的最新动态。干杯！。</p><p id="6c16" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">[ ]，[ ]: <a class="ae mc" href="https://www.toptal.com/front-end/client-side-vs-server-side-pre-rendering" rel="noopener ugc nofollow" target="_blank">客户端vs服务器端vs Web应用预渲染</a>。</p></div></div>    
</body>
</html>