<html>
<head>
<title>A better approach for testing your Redux code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">测试Redux代码的更好方法</h1>
<blockquote>原文：<a href="https://itnext.io/a-better-approach-for-testing-your-redux-code-62b46ddb9e3c?source=collection_archive---------4-----------------------#2019-11-27">https://itnext.io/a-better-approach-for-testing-your-redux-code-62b46ddb9e3c?source=collection_archive---------4-----------------------#2019-11-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/ad148ac2904d8f65b18bf7d5eca687c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Trjj7GkU53PlLHTANgu6rQ.jpeg"/></div></div></figure><div class=""/><p id="0a11" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">贝娄的文章之前已经发表在我的博客上:</p><div class="is it gp gr iu kz"><a href="https://blog.henriquebarcelos.dev/a-better-approach-for-testing-your-redux-code-ck3dnpqnu00uro4s178b8aw3e" rel="noopener  ugc nofollow" target="_blank"><div class="la ab fo"><div class="lb ab lc cl cj ld"><h2 class="bd jf gy z fp le fr fs lf fu fw jd bi translated">测试Redux代码的更好方法</h2><div class="lg l"><h3 class="bd b gy z fp le fr fs lf fu fw dk translated">TL；当测试Redux时，这里有一些准则:Vanilla Redux Redux中最小的独立单元是整个…</h3></div><div class="lh l"><p class="bd b dl z fp le fr fs lf fu fw dk translated">henriquebarcelos.dev</p></div></div><div class="li l"><div class="lj l lk ll lm li ln ja kz"/></div></div></a></div><p id="e4cd" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我最终会把我所有的内容都转移到Medium那里，所以如果你喜欢你在这里读到的东西，就跟着我去那里吧。我可能也会更经常地发帖。</p><h1 id="f192" class="lo lp je bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">TL；速度三角形定位法(dead reckoning)</h1><p id="65cc" class="pw-post-body-paragraph kb kc je kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated">在测试Redux时，这里有一些指导原则:</p><h1 id="41b3" class="lo lp je bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">香草冰淇淋</h1><ul class=""><li id="6023" class="mr ms je kd b ke mm ki mn km mt kq mu ku mv ky mw mx my mz bi translated">Redux中最小的独立单元是整个状态片。单元测试应该作为一个整体与之交互。</li><li id="371f" class="mr ms je kd b ke na ki nb km nc kq nd ku ne ky mw mx my mz bi translated">孤立地测试还原器、动作创建器和选择器是没有意义的。由于它们彼此紧密耦合，隔离给我们带来的价值微乎其微。</li><li id="a411" class="mr ms je kd b ke na ki nb km nc kq nd ku ne ky mw mx my mz bi translated">测试应该以与应用程序相同的方式与Redux slice交互。创建者和选择器，而不必单独编写针对他们的测试。</li><li id="f9bc" class="mr ms je kd b ke na ki nb km nc kq nd ku ne ky mw mx my mz bi translated">避免像针对状态对象的<code class="fe nf ng nh ni b">toEqual</code> / <code class="fe nf ng nh ni b">toDeepEqual</code>这样的断言，因为它们会在测试和状态结构之间产生耦合。</li><li id="2c74" class="mr ms je kd b ke na ki nb km nc kq nd ku ne ky mw mx my mz bi translated">使用选择器为您提供了运行简单断言所需的粒度。</li><li id="3ad8" class="mr ms je kd b ke na ki nb km nc kq nd ku ne ky mw mx my mz bi translated">选择器和动作创建器应该很无聊，所以不会需要测试。</li><li id="8f08" class="mr ms je kd b ke na ki nb km nc kq nd ku ne ky mw mx my mz bi translated">您的切片在某种程度上相当于一个纯函数，这意味着您不需要任何模拟工具来测试它。</li></ul><h1 id="761b" class="lo lp je bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">Redux + <code class="fe nf ng nh ni b">redux-thunk</code></h1><ul class=""><li id="238a" class="mr ms je kd b ke mm ki mn km mt kq mu ku mv ky mw mx my mz bi translated">调度thunks没有任何直接效果。只有在thunk被调用之后，我们才会有使我们的应用程序工作所需的副作用。</li><li id="89e8" class="mr ms je kd b ke na ki nb km nc kq nd ku ne ky mw mx my mz bi translated">在这里，你可以使用存根，间谍，有时模仿(但<a class="ae nj" href="https://medium.com/javascript-scene/mocking-is-a-code-smell-944a70c90a6a" rel="noopener">不要滥用模仿</a>)。</li><li id="afca" class="mr ms je kd b ke na ki nb km nc kq nd ku ne ky mw mx my mz bi translated">由于thunks的构造方式，测试它们的唯一方法是测试它们的实现细节。</li><li id="d6a7" class="mr ms je kd b ke na ki nb km nc kq nd ku ne ky mw mx my mz bi translated">测试thunk的策略是设置存储，调度thunk，然后断言它是否按照您期望的顺序调度了您期望的操作。</li></ul><p id="c8ce" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我创建了一个<a class="ae nj" href="https://github.com/hbarcelos/better-redux-tests" rel="noopener ugc nofollow" target="_blank">回购</a>来实现上面的想法。</p></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><h1 id="6272" class="lo lp je bd lq lr nr lt lu lv ns lx ly lz nt mb mc md nu mf mg mh nv mj mk ml bi translated">介绍</h1><p id="4429" class="pw-post-body-paragraph kb kc je kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated">作为一名软件工程师，我总是想方设法提高自己的技能。这并不容易。一点也不。编码已经够难了。编写好的代码更难。</p><p id="0db9" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后还有测试。我想每次我开始一个新项目时——无论是专业的还是仅仅为了好玩——我应该如何测试我的代码变化的想法。每一个。单身。时间。这不一定是一件坏事，因为不同的问题需要不同的解决方案，但这仍然让我有点好奇。</p><h1 id="ba7f" class="lo lp je bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">测试的问题是</h1><p id="657b" class="pw-post-body-paragraph kb kc je kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated">作为一名TDD实践者，我了解到我们编写测试的主要原因不是为了断言代码的正确性——这只是一个很酷的副作用。首先编写测试的最大好处是，它可以指导您设计接下来要编写的代码。如果有些东西很难测试，可能有更好的方法来实现它。</p><p id="aced" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然而，如果你已经这样做了一段时间，你会意识到写好的测试和写产品代码一样难。有时甚至更难。编写测试需要时间。额外的时间是你的客户或你公司的商务人员不会轻易给你的。</p><figure class="ny nz oa ob gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nx"><img src="../Images/3e2e7388896fb9c092d3ecf2709388a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*6T1fuRRIf2sNTN__.jpeg"/></div></div><figcaption class="oc od gj gh gi oe of bd b be z dk translated">没人有时间做那个！(图片由Unsplash上的Aron Visuals提供)</figcaption></figure><p id="7059" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">而且越来越糟。即使您能够编写适当的测试，在您正在工作的产品/项目的整个生命周期中，需求将会改变，新的场景将会出现。编写太多的测试，使它们非常复杂，应用程序中的任何微小变化都需要花费很大的努力才能使所有的测试再次通过。古怪的测试是另一个问题。当它失败时，你不知道要开始修复它。您可能只需要重新运行测试套件，如果它通过了，您就可以开始了。</p><figure class="ny nz oa ob gt iv gh gi paragraph-image"><div class="gh gi og"><img src="../Images/628cd22c43ef00a413d504f1b7599529.png" data-original-src="https://miro.medium.com/v2/resize:fit:920/format:webp/0*5I6EB-vuj8VEwxRt.jpeg"/></div><figcaption class="oc od gj gh gi oe of bd b be z dk translated">薛定谔的测试:有时候他们失败了，有时候他们通过了，但是你不能确定(图片由齐杰在Flickr上提供)</figcaption></figure><p id="5085" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">但是您如何知道您是否正在编写好的测试呢？到底什么才是好的测试？</p><h1 id="4fac" class="lo lp je bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">测试学校</h1><p id="27e1" class="pw-post-body-paragraph kb kc je kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated">在被称为伦敦学派和底特律测试学派的两种不同思潮之间存在着长期的争论。</p><p id="104c" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">总结他们的差异，底特律认为软件应该自下而上构建，强调设计模式，而<a class="ae nj" href="https://en.wikipedia.org/wiki/Black-box_testing" rel="noopener ugc nofollow" target="_blank">测试应该尽可能少地了解实现</a>，几乎没有或根本没有存根/模仿，伦敦主张设计应该自上而下，使用外部约束作为起点，通过大量使用存根/模仿来确保测试套件之间的最大隔离，这有一个副作用<a class="ae nj" href="https://en.wikipedia.org/wiki/White-box_testing" rel="noopener ugc nofollow" target="_blank">必须知道测试主题是如何实现的</a>。</p><p id="54bd" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是一个非常简短的总结——甚至冒着因为简洁而出错的风险——但是你可以找到更多关于这个二十年前的难题的好参考资料<a class="ae nj" href="https://github.com/testdouble/contributing-tests/wiki/Detroit-school-TDD" rel="noopener ugc nofollow" target="_blank">这里</a>，这里<a class="ae nj" href="https://github.com/testdouble/contributing-tests/wiki/London-school-TDD" rel="noopener ugc nofollow" target="_blank">这里</a>和<a class="ae nj" href="https://medium.com/@adrianbooth/test-driven-development-wars-detroit-vs-london-classicist-vs-mockist-9956c78ae95f" rel="noopener">这里</a>。</p><h1 id="f358" class="lo lp je bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">真实世界中的测试</h1><p id="efdc" class="pw-post-body-paragraph kb kc je kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated">那么伦敦人和德特罗提人谁是对的呢？<a class="ae nj" href="https://blog.ncrunch.net/post/london-tdd-vs-detroit-tdd.aspx" rel="noopener ugc nofollow" target="_blank">他们俩和他们俩都不同时</a>。在我成为专业软件工程师的近5年时间里，我了解到，教条主义不会让你在现实世界中走得太远，在现实世界中，项目应该交付，产品预期应该匹配，你有账单要付。</p><p id="cad6" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">你真正需要的是能够两全其美地利用<a class="ae nj" href="https://blog.ncrunch.net/post/london-tdd-vs-detroit-tdd.aspx" rel="noopener ugc nofollow" target="_blank">和</a>。明智地使用它。</p><p id="55c9" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们生活在一个似乎每个人都痴迷于~近乎~完美的代码覆盖的世界，而<a class="ae nj" href="https://github.com/testdouble/contributing-tests/wiki/Redundant-Coverage" rel="noopener ugc nofollow" target="_blank">冗余覆盖</a>的问题却很少被提及——很难找到讨论这个问题的在线参考资料。如果你滥用测试，当你的需求突然改变的时候，你可能会很难过。</p><p id="60e5" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最后，我们不是靠写测试赚钱的，我们是靠通过代码解决别人的问题赚钱的。编写测试是昂贵的，并且不会给客户/用户增加<strong class="kd jf">可感知的</strong>价值。有人可能会说测试增加了价值，但以我的个人经验，很难让非技术人员相信这一点。</p><p id="4df2" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">作为软件工程师，我们应该努力编写最少数量的测试，对代码质量和正确性产生足够的信心——“足够”是<a class="ae nj" href="https://medium.com/javascript-scene/why-cutting-costs-is-expensive-how-9-hour-software-engineers-cost-boeing-billions-b76dbe571957" rel="noopener">高度依赖于上下文</a>。</p><h1 id="976d" class="lo lp je bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">根据文件重复测试</h1><p id="3f71" class="pw-post-body-paragraph kb kc je kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated">众所周知，Redux有非常好的文档。事实上这是真的。这里不仅有API文档和一些快速示例，还有一些有价值的最佳实践建议，甚至还有一些链接，指向关于Redux及其生态系统的更深入的讨论。</p><p id="20b9" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然而，我认为<a class="ae nj" href="https://redux.js.org/recipes/writing-tests" rel="noopener ugc nofollow" target="_blank">“编写测试”</a>部分还有待改进。</p><h1 id="4fbb" class="lo lp je bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">测试动作创建者</h1><p id="11a5" class="pw-post-body-paragraph kb kc je kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated">文档中的这一部分从动作创建者开始。</p><pre class="ny nz oa ob gt oh ni oi oj aw ok bi"><span id="48fb" class="ol lp je ni b gy om on l oo op">export function addTodo(text) {<br/>  return {<br/>    type: 'ADD_TODO',<br/>    text<br/>  }<br/>}</span></pre><p id="f397" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后我们可以这样测试它:</p><pre class="ny nz oa ob gt oh ni oi oj aw ok bi"><span id="135e" class="ol lp je ni b gy om on l oo op">import * as actions from '../../actions/TodoActions'<br/>import * as types from '../../constants/ActionTypes'</span><span id="1a9e" class="ol lp je ni b gy oq on l oo op">describe('actions', () =&gt; {<br/>  it('should create an action to add a todo', () =&gt; {<br/>    const text = 'Finish docs'<br/>    const expectedAction = {<br/>      type: types.ADD_TODO,<br/>      text<br/>    }<br/>    expect(actions.addTodo(text)).toEqual(expectedAction)<br/>  })<br/>})</span></pre><p id="b4e9" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">虽然测试是正确的并且顺利通过，但是这里的根本问题是<strong class="kd jf">它没有增加多少价值</strong>。你的常规动作创建者应该是<strong class="kd jf">非常无聊的</strong>，几乎是声明性代码。你不需要为此做测试。</p><p id="abf3" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">此外，如果你使用像<code class="fe nf ng nh ni b"><a class="ae nj" href="https://github.com/pauldijou/redux-act" rel="noopener ugc nofollow" target="_blank">redux-act</a></code>或Redux自己的<code class="fe nf ng nh ni b"><a class="ae nj" href="https://github.com/reduxjs/redux-toolkit" rel="noopener ugc nofollow" target="_blank">@reduxjs/toolkit</a></code>这样的助手库——你<strong class="kd jf">应该</strong>——那么完全没有理由为它们编写测试，因为你的测试将测试助手库本身，它们已经被测试过了，更重要的是，它们甚至不属于你。</p><p id="eba5" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">由于动作创作者在真实的应用程序中可能非常多产，他们需要的测试量是巨大的。</p><blockquote class="or os ot"><p id="a8d2" class="kb kc nw kd b ke kf kg kh ki kj kk kl ou kn ko kp ov kr ks kt ow kv kw kx ky im bi translated">但是我们怎么能确定我们简单的动作创作者没有包含像打字错误这样的愚蠢错误呢？</p></blockquote><p id="749b" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">请原谅我。稍后会详细介绍。</p><h1 id="be66" class="lo lp je bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">测试减速器</h1><p id="5634" class="pw-post-body-paragraph kb kc je kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated">在Redux中，reducers是一个给定状态和动作的函数，应该产生一个全新的状态，而不改变原来的状态。减速器是纯函数。纯功能对测试人员来说就像天堂。这应该很简单，对吧？</p><p id="a52d" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">文件给我们举了以下例子:</p><pre class="ny nz oa ob gt oh ni oi oj aw ok bi"><span id="98e9" class="ol lp je ni b gy om on l oo op">import { ADD_TODO } from '../constants/ActionTypes'</span><span id="24af" class="ol lp je ni b gy oq on l oo op">const initialState = [<br/>  {<br/>    text: 'Use Redux',<br/>    completed: false,<br/>    id: 0<br/>  }<br/>]</span><span id="c8b5" class="ol lp je ni b gy oq on l oo op">export default function todos(state = initialState, action) {<br/>  switch (action.type) {<br/>    case ADD_TODO:<br/>      return [<br/>        {<br/>          id: state.reduce((maxId, todo) =&gt; Math.max(todo.id, maxId), -1) + 1,<br/>          completed: false,<br/>          text: action.text<br/>        },<br/>        ...state<br/>      ]</span><span id="3450" class="ol lp je ni b gy oq on l oo op">    default:<br/>      return state<br/>  }<br/>}</span></pre><p id="3d0a" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后是测试:</p><pre class="ny nz oa ob gt oh ni oi oj aw ok bi"><span id="b932" class="ol lp je ni b gy om on l oo op">describe('todos reducer', () =&gt; {<br/>  it('should return the initial state', () =&gt; {<br/>    expect(reducer(undefined, {})).toEqual([<br/>      {<br/>        text: 'Use Redux',<br/>        completed: false,<br/>        id: 0<br/>      }<br/>    ])<br/>  })</span><span id="ab9a" class="ol lp je ni b gy oq on l oo op">  it('should handle ADD_TODO', () =&gt; {<br/>    expect(<br/>      reducer([], {<br/>        type: types.ADD_TODO,<br/>        text: 'Run the tests'<br/>      })<br/>    ).toEqual([<br/>      {<br/>        text: 'Run the tests',<br/>        completed: false,<br/>        id: 0<br/>      }<br/>    ])</span><span id="1405" class="ol lp je ni b gy oq on l oo op">    expect(<br/>      reducer(<br/>        [<br/>          {<br/>            text: 'Use Redux',<br/>            completed: false,<br/>            id: 0<br/>          }<br/>        ],<br/>        {<br/>          type: types.ADD_TODO,<br/>          text: 'Run the tests'<br/>        }<br/>      )<br/>    ).toEqual([<br/>      {<br/>        text: 'Run the tests',<br/>        completed: false,<br/>        id: 1<br/>      },<br/>      {<br/>        text: 'Use Redux',<br/>        completed: false,<br/>        id: 0<br/>      }<br/>    ])<br/>  })<br/>})</span></pre><p id="319a" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们忽略这样一个事实，即建议的测试用例<em class="nw">“应该处理ADD _ TODO”</em>实际上是两个捆绑在一起的测试——这可能会让一些测试狂热者抓狂。即使在这种情况下，我认为最好有不同的测试用例——一个用于空列表，另一个用于有初始值的列表——有时这也很好。</p><p id="4487" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这些测试的真正问题是<strong class="kd jf">它们与减速器</strong>的内部结构紧密耦合。更准确地说，上面的测试通过那些<code class="fe nf ng nh ni b">.toEqual()</code>断言耦合到状态对象结构。</p><p id="09b5" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">虽然这个例子相当简单，但是Redux中给定片的状态随着时间的推移而改变是很常见的，因为新的需求到来，并且需要发生一些不可预见的交互。如果我们像上面那样编写测试，它们将很快成为维护的噩梦。状态结构的任何微小变化都需要更新几个测试用例。</p><blockquote class="or os ot"><p id="4a1f" class="kb kc nw kd b ke kf kg kh ki kj kk kl ou kn ko kp ov kr ks kt ow kv kw kx ky im bi translated">那么我们到底应该如何编写这些测试呢？</p></blockquote><h1 id="bf3f" class="lo lp je bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">以正确的方式测试Redux</h1><p id="228e" class="pw-post-body-paragraph kb kc je kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated"><strong class="kd jf">免责声明:</strong>我并不是说这是测试您的Redux应用程序的最佳或唯一方式，但是我最近得出结论，按照我下面建议的方式进行会产生我所知道的最佳成本效益。如果你碰巧知道更好的方法，请通过评论、Twitter、电子邮件或吸烟标志联系我。</p><p id="e663" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下面是Redux应用程序的一个流行的文件夹结构，它与许多教程甚至官方文档中的文件夹结构非常相似:</p><pre class="ny nz oa ob gt oh ni oi oj aw ok bi"><span id="0b1a" class="ol lp je ni b gy om on l oo op">src<br/>└── store<br/>    ├── auth<br/>    │   ├── actions.js<br/>    │   ├── actionTypes.js<br/>    │   └── reducer.js<br/>    └── documents<br/>        ├── actions.js<br/>        ├── actionTypes.js<br/>        └── reducer.js</span></pre><p id="aa6b" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果您像我一样，喜欢将测试文件与源代码放在一起，这种结构鼓励您拥有以下内容:</p><pre class="ny nz oa ob gt oh ni oi oj aw ok bi"><span id="19b4" class="ol lp je ni b gy om on l oo op">src<br/>└── store<br/>    ├── auth<br/>    │   ├── actions.js<br/>    │   ├── actions.test.js<br/>    │   ├── actionTypes.js<br/>    │   ├── reducer.js<br/>    │   └── reducer.test.js<br/>    └── documents<br/>        ├── actions.js<br/>        ├── actions.test.js<br/>        ├── actionTypes.js<br/>        ├── reducer.js<br/>        └── reducer.test.js</span></pre><p id="5bee" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我已经省略了<code class="fe nf ng nh ni b">actionTypes</code>测试，因为这些文件完全是声明性的。然而，我已经解释了为什么动作创建者应该是纯声明性的，因此也不应该被测试。这让我们测试唯一的减速器本身，但这似乎不太正确。</p><p id="03b4" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里的问题是我们所理解的Redux中的<em class="nw">“单位”</em>。大多数人倾向于把上面的每一个单独的文件看作一个单元。我相信这是一种误解。动作、动作类型和减速器<strong class="kd jf">必须</strong>紧密耦合才能正常工作。对我来说，孤立地测试这些“组件”没有意义。它们都需要组合在一起形成一个片(例如:上面的<code class="fe nf ng nh ni b">auth</code>和<code class="fe nf ng nh ni b">documents</code>，我认为这是Redux架构中最小的独立片。</p><p id="5b11" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">出于这个原因，我发现了<a class="ae nj" href="https://github.com/erikras/ducks-modular-redux" rel="noopener ugc nofollow" target="_blank">鸭子</a>的模式，尽管<a class="ae nj" href="https://twitter.com/dan_abramov/status/738405796770353152" rel="noopener ugc nofollow" target="_blank">有一些警告</a>。Ducks的作者主张关于单个切片(他们称之为<em class="nw">“duck”</em>)的所有东西都应该放在一个文件中，并遵循定义良好的导出结构。</p><p id="2665" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我通常有一个更像这样的结构:</p><pre class="ny nz oa ob gt oh ni oi oj aw ok bi"><span id="09a8" class="ol lp je ni b gy om on l oo op">src<br/>└── modules<br/>    ├── auth<br/>    │   ├── authSlice.js<br/>    │   └── authSlice.test.js<br/>    └── documents<br/>        ├── documentsSlice.js<br/>        └── documentsSlice.test.js</span></pre><p id="1028" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在的想法是尽可能编写最少的测试，同时对某个特定部分按预期工作有很大的信心。Redux首先存在的原因是为了帮助我们操纵状态，为我们的应用程序状态提供一个单一的位置。</p><p id="a5d1" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">换句话说，Redux为我们提供的价值是从一个集中的位置(称为存储)读写状态的能力。由于Redux基于<a class="ae nj" href="https://facebook.github.io/flux/" rel="noopener ugc nofollow" target="_blank">通量架构</a>，其常规流程大致如下:</p><figure class="ny nz oa ob gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ox"><img src="../Images/ea2d29593facdec8b529187037d07f92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ikFaqT-P5Dyy5FuJ.png"/></div></div><figcaption class="oc od gj gh gi oe of bd b be z dk translated">媒介上的流动建筑</figcaption></figure><h1 id="42fb" class="lo lp je bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">冗余测试策略</h1><p id="8b11" class="pw-post-body-paragraph kb kc je kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated">在一天结束时，我们想要测试的是我们是否正确地通过调度操作写入和从存储中读取。我们这样做的方法是给定一个初始状态，我们分派一些动作给存储，让reducer工作，然后我们检查状态，看看是否进行了我们期望的更改。</p><p id="8316" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然而，我们如何做到这一点，同时避免将测试与状态对象结构相结合的陷阱呢？简单。<a class="ae nj" href="https://medium.com/javascript-scene/10-tips-for-better-redux-architecture-69250425af44#975e" rel="noopener">始终使用选择器</a>。甚至那些看起来很蠢的。</p><p id="9076" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">选择器是你用来读取数据的公共API。它们可以封装您的状态内部结构，并以应用程序需要的粒度只公开应用程序需要的数据。<a class="ae nj" href="https://github.com/reduxjs/reselect" rel="noopener ugc nofollow" target="_blank">您也可以通过记忆</a>获得计算数据并优化它。同样，action creators是它写数据的公共API。</p><p id="4c48" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">还在迷茫？让我们使用<code class="fe nf ng nh ni b"><a class="ae nj" href="https://redux-toolkit.js.org/" rel="noopener ugc nofollow" target="_blank">@reduxjs/toolkit.</a></code>来尝试一些代码</p><p id="81ac" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">以下是我的验证片段:</p><pre class="ny nz oa ob gt oh ni oi oj aw ok bi"><span id="ac16" class="ol lp je ni b gy om on l oo op">import { createSlice, createSelector } from '@reduxjs/toolkit';</span><span id="7b9c" class="ol lp je ni b gy oq on l oo op">export const initialState = {<br/>  userName: '',<br/>  token: '',<br/>};</span><span id="1d24" class="ol lp je ni b gy oq on l oo op">const authSlice = createSlice({<br/>  name: 'auth',<br/>  initialState,<br/>  reducers: {<br/>    signIn(state, action) {<br/>      const { token, userName } = action.payload;</span><span id="0212" class="ol lp je ni b gy oq on l oo op">      state.token = token;<br/>      state.userName = userName;<br/>    },<br/>  },<br/>});</span><span id="5956" class="ol lp je ni b gy oq on l oo op">export const { signIn } = authSlice.actions;</span><span id="7cd9" class="ol lp je ni b gy oq on l oo op">export default authSlice.reducer;</span><span id="aaea" class="ol lp je ni b gy oq on l oo op">export const selectToken = state =&gt; state.auth.token;<br/>export const selectUserName = state =&gt; state.auth.userName;<br/>export const selectIsAuthenticated = createSelector([selectToken], token =&gt; token !== '');</span></pre><p id="b5c7" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这个文件没有什么特别的。我使用的是<code class="fe nf ng nh ni b">createSlice</code>助手，它为我节省了很多样板代码。导出结构或多或少遵循了Ducks模式，主要区别在于我没有显式导出动作类型，因为它们是在动作创建者的<code class="fe nf ng nh ni b">type</code>属性中定义的(例如:<code class="fe nf ng nh ni b">signIn.type</code>返回<code class="fe nf ng nh ni b">'auth/signIn'</code>)。</p><p id="21ea" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在使用<code class="fe nf ng nh ni b"><a class="ae nj" href="https://jestjs.io/" rel="noopener ugc nofollow" target="_blank">jest</a></code>实现测试套件:</p><pre class="ny nz oa ob gt oh ni oi oj aw ok bi"><span id="c236" class="ol lp je ni b gy om on l oo op">import reducer, { initialState, signIn, selectToken, selectName, selectIsAuthenticated } from './authSlice';</span><span id="6fd3" class="ol lp je ni b gy oq on l oo op">describe('auth slice', () =&gt; {<br/>  describe('reducer, actions and selectors', () =&gt; {<br/>    it('should return the initial state on first run', () =&gt; {<br/>      // Arrange<br/>      const nextState = initialState;</span><span id="705c" class="ol lp je ni b gy oq on l oo op">      // Act<br/>      const result = reducer(undefined, {});</span><span id="b884" class="ol lp je ni b gy oq on l oo op">      // Assert<br/>      expect(result).toEqual(nextState);<br/>    });</span><span id="d0f6" class="ol lp je ni b gy oq on l oo op">    it('should properly set the state when sign in is made', () =&gt; {<br/>      // Arrange<br/>      const data = {<br/>        userName: 'John Doe',<br/>        token: 'This is a valid token. Trust me!',<br/>      };</span><span id="383b" class="ol lp je ni b gy oq on l oo op">      // Act<br/>      const nextState = reducer(initialState, signIn(data));</span><span id="b087" class="ol lp je ni b gy oq on l oo op">      // Assert<br/>      const rootState = { auth: nextState };<br/>      expect(selectIsAuthenticated(rootState)).toEqual(true);<br/>      expect(selectUserName(rootState)).toEqual(data.userName);<br/>      expect(selectToken(rootState)).toEqual(data.token);<br/>    });<br/>  });<br/>});</span></pre><p id="3c2e" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">第一个测试用例(<code class="fe nf ng nh ni b">'should return the initial state on first run'</code>)只是为了确保切片文件的定义没有问题。注意，我使用了我说过不应该使用的<code class="fe nf ng nh ni b">.toEqual()</code>断言。然而，在这种情况下，由于断言是针对常数<code class="fe nf ng nh ni b">initialState</code>的，并且没有突变，所以每当状态形状改变时，<code class="fe nf ng nh ni b">initialState</code>一起改变，因此该测试将自动被“固定”。</p><p id="7d25" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">第二个测试用例是我们感兴趣的。从初始状态开始，我们用预期的有效负载“分派”一个<code class="fe nf ng nh ni b">signIn</code>动作。然后我们检查产生的状态是否是我们所期望的。然而，我们只使用选择器。这样，我们的测试与实现更加分离</p><p id="deaa" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果您的切片变得更大，通过在测试状态转换时使用选择器，您还可以获得另一个优势:您可以只使用那些受您调度的动作影响的选择器，而可以忽略其他任何东西。如果您针对完整的切片状态树进行断言，您仍然需要在断言中声明那些不相关的状态属性。</p><p id="8e63" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">观察力敏锐的读者可能已经注意到，这种测试方式更像源自底特律学校的那种。没有嘲笑，存根，间谍或任何东西。由于reducers只是简单的纯函数，使用它们是没有意义的。</p><p id="89e1" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然而，这个切片太简单了。认证通常与一些后端服务联系在一起，这意味着我们必须管理后端服务和我们的应用程序之间的通信，也就是说，我们必须处理副作用和加载状态。事情开始变得更加复杂。</p><h1 id="a5b5" class="lo lp je bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">测试更真实的切片</h1><p id="632e" class="pw-post-body-paragraph kb kc je kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated">第一步是将我们的<code class="fe nf ng nh ni b">signIn</code>行动拆分成三个新的:<code class="fe nf ng nh ni b">signInStart</code>、<code class="fe nf ng nh ni b">signInSuccess</code>和<code class="fe nf ng nh ni b">signInFailure</code>。名称应该是不言自明的。之后，我们的状态需要处理加载状态和最终的错误。</p><p id="3646" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">以下是进行了这些更改的一些代码:</p><pre class="ny nz oa ob gt oh ni oi oj aw ok bi"><span id="0477" class="ol lp je ni b gy om on l oo op">import { createSlice, createSelector } from '@reduxjs/toolkit';</span><span id="42aa" class="ol lp je ni b gy oq on l oo op">export const initialState = {<br/>  isLoading: false,<br/>  user: {<br/>    userName: '',<br/>    token: '',<br/>  },<br/>  error: null,<br/>};</span><span id="7fc4" class="ol lp je ni b gy oq on l oo op">const authSlice = createSlice({<br/>  name: 'auth',<br/>  initialState,<br/>  reducers: {<br/>    signInStart(state, action) {<br/>      state.isLoading = true;<br/>      state.error = null;<br/>    },<br/>    signInSuccess(state, action) {<br/>      const { token, userName } = action.payload;</span><span id="c826" class="ol lp je ni b gy oq on l oo op">      state.user = { token, userName };<br/>      state.isLoading = false;<br/>      state.error = null;<br/>    },<br/>    signInFailure(state, action) {<br/>      const { error } = action.payload;</span><span id="9b40" class="ol lp je ni b gy oq on l oo op">      state.error = error;<br/>      state.user = {<br/>        userName: '',<br/>        token: '',<br/>      };<br/>      state.isLoading = false;<br/>    },<br/>  },<br/>});</span><span id="e89d" class="ol lp je ni b gy oq on l oo op">export const { signInStart, signInSuccess, signInFailure } = authSlice.actions;</span><span id="d191" class="ol lp je ni b gy oq on l oo op">export default authSlice.reducer;</span><span id="c9f2" class="ol lp je ni b gy oq on l oo op">export const selectToken = state =&gt; state.auth.user.token;<br/>export const selectUserName = state =&gt; state.auth.user.userName;<br/>export const selectError = state =&gt; state.auth.error;<br/>export const selectIsLoading = state =&gt; state.auth.isLoading;<br/>export const selectIsAuthenticated = createSelector([selectToken], token =&gt; token !== '');</span></pre><p id="5936" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">你可能注意到的第一件事是我们的状态形状改变了。我们将<code class="fe nf ng nh ni b">userName</code>和<code class="fe nf ng nh ni b">token</code>嵌套在一个<code class="fe nf ng nh ni b">user</code>属性中。如果我们没有创建选择器，这会破坏所有依赖于这个切片的测试和代码。然而，因为我们有选择器，我们需要做的唯一改变是在<code class="fe nf ng nh ni b">selectToken</code>和<code class="fe nf ng nh ni b">selectUserName</code>中。</p><p id="d396" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">请注意，我们的测试套件现在完全崩溃了，但这是因为我们从根本上改变了切片。不过，修复它并不难:</p><pre class="ny nz oa ob gt oh ni oi oj aw ok bi"><span id="5ac4" class="ol lp je ni b gy om on l oo op">describe('auth slice', () =&gt; {<br/>  describe('reducer, actions and selectors', () =&gt; {<br/>    it('should return the initial state on first run', () =&gt; {<br/>      // Arrange<br/>      const nextState = initialState;</span><span id="982f" class="ol lp je ni b gy oq on l oo op">      // Act<br/>      const result = reducer(undefined, {});</span><span id="c178" class="ol lp je ni b gy oq on l oo op">      // Assert<br/>      expect(result).toEqual(nextState);<br/>    });</span><span id="26ff" class="ol lp je ni b gy oq on l oo op">    it('should properly set loading and error state when a sign in request is made', () =&gt; {<br/>      // Arrange</span><span id="4d3a" class="ol lp je ni b gy oq on l oo op">      // Act<br/>      const nextState = reducer(initialState, signInStart());</span><span id="02e4" class="ol lp je ni b gy oq on l oo op">      // Assert<br/>      const rootState = { auth: nextState };<br/>      expect(selectIsAuthenticated(rootState)).toEqual(false);<br/>      expect(selectIsLoading(rootState)).toEqual(true);<br/>      expect(selectError(rootState)).toEqual(null);<br/>    });</span><span id="6169" class="ol lp je ni b gy oq on l oo op">    it('should properly set loading, error and user information when a sign in request succeeds', () =&gt; {<br/>      // Arrange<br/>      const payload = { token: 'this is a token', userName: 'John Doe' };</span><span id="1c8f" class="ol lp je ni b gy oq on l oo op">      // Act<br/>      const nextState = reducer(initialState, signInSuccess(payload));</span><span id="1b27" class="ol lp je ni b gy oq on l oo op">      // Assert<br/>      const rootState = { auth: nextState };<br/>      expect(selectIsAuthenticated(rootState)).toEqual(true);<br/>      expect(selectToken(rootState)).toEqual(payload.token);<br/>      expect(selectUserName(rootState)).toEqual(payload.userName);<br/>      expect(selectIsLoading(rootState)).toEqual(false);<br/>      expect(selectError(rootState)).toEqual(null);<br/>    });</span><span id="605e" class="ol lp je ni b gy oq on l oo op">    it('should properly set loading, error and remove user information when sign in request fails', () =&gt; {<br/>      // Arrange<br/>      const error = new Error('Incorrect password');</span><span id="59b3" class="ol lp je ni b gy oq on l oo op">      // Act<br/>      const nextState = reducer(initialState, signInFailure({ error: error.message }));</span><span id="20d5" class="ol lp je ni b gy oq on l oo op">      // Assert<br/>      const rootState = { auth: nextState };<br/>      expect(selectIsAuthenticated(rootState)).toEqual(false);<br/>      expect(selectToken(rootState)).toEqual('');<br/>      expect(selectUserName(rootState)).toEqual('');<br/>      expect(selectIsLoading(rootState)).toEqual(false);<br/>      expect(selectError(rootState)).toEqual(error.message);<br/>    });<br/>  });<br/>});</span></pre><p id="62ec" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">请注意，<code class="fe nf ng nh ni b">signInStart</code>对新状态的断言较少，因为当前的<code class="fe nf ng nh ni b">userName</code>和<code class="fe nf ng nh ni b">token</code>对它无关紧要。到目前为止，其他一切都与我们所讨论的一致。</p><p id="b7c3" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">还有另一个可能被忽视的微妙之处。尽管测试的主要焦点是缩减器，但是它们最终也测试了动作创建者。那些愚蠢的错误，比如打字错误，会在这里被发现，所以我们不需要写一套单独的测试来防止它们发生。</p><p id="cd36" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">选择器也是如此。简单的选择器是纯粹的声明性代码。用<code class="fe nf ng nh ni b">createSelector</code>从<a class="ae nj" href="https://github.com/reduxjs/reselect" rel="noopener ugc nofollow" target="_blank">重选</a>创建的派生数据的记忆选择器也不应被测试。在减速器测试中会发现错误。</p><p id="e598" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">例如，如果我们在重构状态形状后忘记更改<code class="fe nf ng nh ni b">selectUserName</code>和<code class="fe nf ng nh ni b">selectToken</code>，并让它们保持如下状态:</p><pre class="ny nz oa ob gt oh ni oi oj aw ok bi"><span id="172c" class="ol lp je ni b gy om on l oo op">// should be state.auth.user.token<br/>export const selectToken = state =&gt; state.auth.token;</span><span id="4392" class="ol lp je ni b gy oq on l oo op">// should be state.auth.user.userName<br/>export const selectUserName = state =&gt; state.auth.userName;</span></pre><p id="152a" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这种情况下，上述所有测试用例都将失败。</p><h1 id="366b" class="lo lp je bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">测试副作用</h1><p id="e049" class="pw-post-body-paragraph kb kc je kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated">我们正在努力，但我们的部分还没有完成。它缺少编排登录流和与后端服务API通信的部分。</p><p id="60a7" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Redux本身故意不处理副作用。为了能够做到这一点，您需要一个Redux中间件来为您处理。虽然你可以<a class="ae nj" href="https://redux.js.org/introduction/ecosystem#side-effects" rel="noopener ugc nofollow" target="_blank">选择你自己的毒药</a>，<code class="fe nf ng nh ni b">@reduxjs/toolkit</code>已经和<code class="fe nf ng nh ni b">redux-thunk</code>一起发货了，所以这就是我们将要使用的。</p><p id="e44d" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这种情况下，Redux docs实际上有一个<a class="ae nj" href="https://redux.js.org/recipes/writing-tests#async-action-creators" rel="noopener ugc nofollow" target="_blank">非常好的例子</a>，所以我基本上采用了它并适应了我们的用例。</p><p id="df25" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在我们的<code class="fe nf ng nh ni b">authSlice.js</code>中，我们简单地加上:</p><pre class="ny nz oa ob gt oh ni oi oj aw ok bi"><span id="b371" class="ol lp je ni b gy om on l oo op">// ...<br/>import api from '../../api';</span><span id="fa9a" class="ol lp je ni b gy oq on l oo op">// ...<br/>export const signIn = ({ email, password }) =&gt; async dispatch =&gt; {<br/>  try {<br/>    dispatch(signInStart());<br/>    const { token, userName } = await api.signIn({<br/>      email,<br/>      password,<br/>    });<br/>    dispatch(signInSuccess({ token, userName }));<br/>  } catch (error) {<br/>    dispatch(signInFailure({ error }));<br/>  }<br/>};</span></pre><p id="f795" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">请注意，<code class="fe nf ng nh ni b">signIn</code>函数几乎就像一个动作创建器，然而，它不是返回动作对象，而是返回一个接收调度函数作为参数的函数。这是当用户在我们的应用程序中单击“登录”按钮时触发的“动作”。</p><p id="69fd" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这意味着像<code class="fe nf ng nh ni b">signIn</code>这样的函数对应用程序非常重要，因此，应该对它们进行测试。然而，我们如何在与<code class="fe nf ng nh ni b">api</code>模块隔离的情况下进行测试呢？输入模拟和存根。</p><p id="219f" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">由于这基本上是一个编排组件，我们对它的可见效果不感兴趣。相反，我们感兴趣的是根据API的响应从thunk内部分派的操作。</p><p id="08a4" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">所以我们可以像这样修改测试文件:</p><pre class="ny nz oa ob gt oh ni oi oj aw ok bi"><span id="5188" class="ol lp je ni b gy om on l oo op">import configureMockStore from 'redux-mock-store';<br/>import thunk from 'redux-thunk';<br/>// ...<br/>import api from '../../api';</span><span id="200e" class="ol lp je ni b gy oq on l oo op">jest.mock('../../api');</span><span id="4337" class="ol lp je ni b gy oq on l oo op">const mockStore = configureMockStore([thunk]);</span><span id="6b3b" class="ol lp je ni b gy oq on l oo op">describe('thunks', () =&gt; {<br/>    it('creates both signInStart and signInSuccess when sign in succeeds', async () =&gt; {<br/>      // Arrange<br/>      const requestPayload = {<br/>        email: 'john.doe@example.com',<br/>        password: 'very secret',<br/>      };<br/>      const responsePayload = {<br/>        token: 'this is a token',<br/>        userName: 'John Doe',<br/>      };<br/>      const store = mockStore(initialState);<br/>      api.signIn.mockResolvedValueOnce(responsePayload);</span><span id="dec9" class="ol lp je ni b gy oq on l oo op">      // Act<br/>      await store.dispatch(signIn(requestPayload));</span><span id="a09d" class="ol lp je ni b gy oq on l oo op">      // Assert<br/>      const expectedActions = [signInStart(), signInSuccess(responsePayload)];<br/>      expect(store.getActions()).toEqual(expectedActions);<br/>    });</span><span id="a491" class="ol lp je ni b gy oq on l oo op">    it('creates both signInStart and signInFailure when sign in fails', async () =&gt; {<br/>      // Arrange<br/>      const requestPayload = {<br/>        email: 'john.doe@example.com',<br/>        password: 'wrong passoword',<br/>      };<br/>      const responseError = new Error('Invalid credentials');<br/>      const store = mockStore(initialState);<br/>      api.signIn.mockRejectedValueOnce(responseError);</span><span id="b4e0" class="ol lp je ni b gy oq on l oo op">      // Act<br/>      await store.dispatch(signIn(requestPayload));</span><span id="fa28" class="ol lp je ni b gy oq on l oo op">      // Assert<br/>      const expectedActions = [signInStart(), signInFailure({ error: responseError })];<br/>      expect(store.getActions()).toEqual(expectedActions);<br/>    });<br/>  });</span></pre><p id="e46c" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因此，与更容易用底特律学派的方法来测试的reducers不同，我们利用伦敦学派的风格来测试我们的思维，因为这是有意义的。</p><p id="c0a5" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因为我们正在测试实现细节，所以无论何时代码发生变化，我们的测试都必须反映出来。在真实的应用程序中，成功登录后，您可能希望将用户重定向到某个地方。如果我们使用类似于<a class="ae nj" href="https://github.com/supasate/connected-react-router" rel="noopener ugc nofollow" target="_blank"> connected-react-router </a>的东西，我们会得到这样的代码:</p><pre class="ny nz oa ob gt oh ni oi oj aw ok bi"><span id="89c3" class="ol lp je ni b gy om on l oo op">+import { push } from 'connected-react-router';<br/> // ...<br/> import api from '../../api';</span><span id="f2e5" class="ol lp je ni b gy oq on l oo op"> // ...<br/>     const { token, userName } = await api.signIn({<br/>       email,<br/>       password,<br/>     });<br/>     dispatch(signInSuccess({ token, userName }));<br/>+    dispatch(push('/'));<br/>   } catch (error) {<br/>     dispatch(signInFailure({ error }));<br/>   }<br/> // ...</span></pre><p id="b642" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后，我们更新测试用例的断言部分:</p><pre class="ny nz oa ob gt oh ni oi oj aw ok bi"><span id="cc10" class="ol lp je ni b gy om on l oo op">+import { push } from 'connected-react-router';<br/> // ...</span><span id="2f10" class="ol lp je ni b gy oq on l oo op"> // Assert<br/> const expectedActions = [<br/>   signInStart(),<br/>   signInSuccess(responsePayload),<br/>+  push('/')<br/> ];<br/> expect(store.getActions()).toEqual(expectedActions);<br/> // ...</span></pre><p id="a234" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这通常是对<code class="fe nf ng nh ni b">redux-thunk</code>的批评，但是如果你决定使用它，这是一个你必须处理的权衡。</p><h1 id="3f11" class="lo lp je bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">结论</h1><p id="862c" class="pw-post-body-paragraph kb kc je kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated">当涉及到现实世界时，没有单一的编写测试的最佳方法。我们可以也应该利用底特律和伦敦的风格来有效地测试你的应用程序。</p><p id="7839" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于行为像纯函数的组件，即给定一些输入，产生一些确定性的输出，底特律风格大放异彩。我们的测试可以更粗一点，因为拥有完美的隔离并不会给它们增加多少价值。我们应该在哪里划清界限？像大多数好问题一样，答案是“视情况而定”。</p><p id="860a" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在Redux中，我得出的结论是片是存在的最小独立单元。为它们的子组件编写独立的测试毫无意义，比如reducers、action creators和selectors。我们一起测试它们。如果它们中的任何一个坏了，测试会告诉我们，并且很容易找出是哪一个。</p><p id="6ab5" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">另一方面，当我们的组件仅仅是为了编排的目的而存在时，那么伦敦风格的测试就是一种方法。由于我们正在测试实现细节，测试应该尽可能地细粒度，利用模拟、存根、间谍和我们需要的任何东西。然而，这带来了更难维护的负担。</p><p id="a995" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当使用<code class="fe nf ng nh ni b">redux-thunk</code>时，我们应该测试的是我们的thunk以我们期望的相同顺序分派适当的动作。像<code class="fe nf ng nh ni b"><a class="ae nj" href="https://github.com/dmitry-zaets/redux-mock-store" rel="noopener ugc nofollow" target="_blank">redux-mock-store</a></code>这样的助手简化了我们的任务，因为它比Redux本地存储暴露了更多的存储内部状态。</p><p id="929c" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">那是所有的人！</p></div></div>    
</body>
</html>