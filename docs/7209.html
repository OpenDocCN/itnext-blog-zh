<html>
<head>
<title>Organizing Tests in Julia</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Julia中组织测试</h1>
<blockquote>原文：<a href="https://itnext.io/organizing-tests-in-julia-c3de1e43d6ab?source=collection_archive---------1-----------------------#2022-07-16">https://itnext.io/organizing-tests-in-julia-c3de1e43d6ab?source=collection_archive---------1-----------------------#2022-07-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a964" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Julia测试框架与Python、Go和Java中流行的测试框架的比较</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6c58ff5ab98d6b8bfba3862808bac618.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dvuJMXsK6BBJbXZ7OTSOFg.png"/></div></div></figure><p id="7ed9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi lq translated"><span class="l lr ls lt bm lu lv lw lx ly di"> M </span> AYBE你已经熟悉了Python、Java、Go等其他语言的测试框架。现在，您希望加快Julia中的测试速度。在这个故事中，我们将探索测试与您可能已经习惯的测试有何相似和不同之处。</p><p id="303c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在讨论Julia中的测试之前，我将快速概述一些主流编程语言的流行测试框架中的测试。我们将与Julia捆绑的测试框架进行对比，它基于嵌套测试集的概念。这是一种非常灵活的方法，但如果您以前从未遇到过，可能会感到困惑。</p><p id="9990" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">请继续阅读这个故事:<a class="ae lz" href="https://erikexplores.substack.com/p/julia-test-organizing" rel="noopener ugc nofollow" target="_blank">埃里克探索了</a></p><h1 id="1f57" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">pytest——Python中的单元测试</h1><p id="41d1" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated"><a class="ae lz" href="https://docs.pytest.org/en/7.1.x/" rel="noopener ugc nofollow" target="_blank"> Pytest </a>是Python常用的测试框架。这里，我们只需在代表测试的函数前面加上<code class="fe mx my mz na b">test_</code>，如下所示:</p><pre class="kj kk kl km gt nb na nc nd aw ne bi"><span id="9277" class="nf mb it na b gy ng nh l ni nj"># Python - capitalize.py file<br/>def capital_case(x):<br/>    return x.capitalize()<br/><br/>def test_capital_case():<br/>    assert capital_case('semaphore') == 'Semaphore'<br/>    <br/># intentionally not working<br/>def test_defective():<br/>    assert "hello".upper() == "heLLO"</span></pre><p id="81c8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我故意让一个测试失败，所以你可以看到失败的测试是如何显示的。我们可以在一个有多个测试文件的目录中运行<code class="fe mx my mz na b">pytest</code>或者直接指定一个文件进行测试，就像这个例子中一样。</p><pre class="kj kk kl km gt nb na nc nd aw ne bi"><span id="4f76" class="nf mb it na b gy ng nh l ni nj">❯ pytest capitalize.py<br/>===================== test session starts =====================<br/>platform darwin -- Python 3.8.12, pytest-7.1.2, pluggy-1.0.0<br/>rootdir: /Users/erikengheim/Development/Python/example<br/>collected 2 items<br/><br/>capitalize.py .F                                        [100%]<br/><br/>========================== FAILURES ===========================<br/>_______________________ test_defective ________________________<br/><br/>    def test_defective():<br/>&gt;       assert "hello".upper() == "heLLO"<br/>E       AssertionError: assert 'HELLO' == 'heLLO'<br/>E         - heLLO<br/>E         + HELLO<br/><br/>capitalize.py:9: AssertionError<br/>=================== short test summary info ===================<br/>FAILED capitalize.py::test_defective - AssertionError: asser...<br/>================= 1 failed, 1 passed in 0.11s =================</span></pre><h1 id="c15c" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">Go中的单元测试</h1><p id="c31d" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">你可以找到很多主流语言的单元测试，但是我关注的是众所周知的简单框架，所以对于Go，我们来看看内置的单元测试框架，它在Go开发者中仍然非常流行。</p><p id="9ee8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">它基于将每个测试函数命名为<code class="fe mx my mz na b">TestXXX(t *testing.T)</code>的简单思想，其中<code class="fe mx my mz na b">XXX</code>被替换为您想要测试的任何东西。您需要接受一个类型为<code class="fe mx my mz na b">*testing.T</code>的参数来与测试框架通信。</p><pre class="kj kk kl km gt nb na nc nd aw ne bi"><span id="ef47" class="nf mb it na b gy ng nh l ni nj">// Go - foobar_test.go file<br/>package main<br/><br/>import "testing"<br/><br/>func TestCapitalize(t *testing.T) {<br/>    total := Sum(5, 5)<br/>    if total != 10 {<br/>       t.Errorf("Sum was incorrect, got: %d, want: %d.", total, 10)<br/>    }<br/>}<br/><br/>// deliberately made to fail<br/>func TestDefective(t *testing.T) {<br/>    total := Sum(5, 5)<br/>    if total != 10 {<br/>       t.Errorf("Sum was incorrect, got: %d, want: %d.", total, 10)<br/>    }<br/>}</span></pre><p id="fc45" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于Go测试，你把它们放在一个以<code class="fe mx my mz na b">_test</code>结尾的文件中，比如<code class="fe mx my mz na b">foobar_test.go</code>。我们让最后一个测试失败了，所以你可以看到Go的输出。</p><pre class="kj kk kl km gt nb na nc nd aw ne bi"><span id="f125" class="nf mb it na b gy ng nh l ni nj">❯ go test<br/>--- FAIL: TestDefective (0.00s)<br/>    foobar_test.go:23: Uppercase incorrect, got: HELLO, want: heLLO.<br/>FAIL<br/>exit status 1<br/>FAIL	github.com/ordovician/dummy	0.120s</span></pre><p id="f374" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这将查找以<code class="fe mx my mz na b">_test.go</code>结尾的文件，并以<code class="fe mx my mz na b">Test</code>前缀对待每个函数，以<code class="fe mx my mz na b">testing.T</code>类型参数作为测试。</p><h1 id="b2dc" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">JUnit——Java中的单元测试</h1><p id="208e" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated"><a class="ae lz" href="https://junit.org/junit4/" rel="noopener ugc nofollow" target="_blank"> JUnit </a>在Java世界占据统治地位。每个测试都存储在测试类的方法中。注意这与Python和Go有什么不同，Python和Go使用免费函数而不是测试类。</p><pre class="kj kk kl km gt nb na nc nd aw ne bi"><span id="844c" class="nf mb it na b gy ng nh l ni nj">// Java - MyTests.java file<br/>public class MyTests {<br/><br/>    @Test<br/>    public void multiplicationOfZeroIntegersShouldReturnZero() {<br/>        MyClass tester = new MyClass(); // MyClass is tested<br/><br/>        // assert statements<br/>        assertEquals(0, tester.multiply(10, 0), "10 x 0 must be 0");<br/>        assertEquals(0, tester.multiply(0, 10), "0 x 10 must be 0");<br/>        assertEquals(0, tester.multiply(0, 0), "0 x 0 must be 0");<br/>    }<br/>}</span></pre><p id="7ec9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后这些类被放入一个测试套件中；因此，您可以避免创建大量的测试类:</p><pre class="kj kk kl km gt nb na nc nd aw ne bi"><span id="6a4b" class="nf mb it na b gy ng nh l ni nj">// Java - JUnit test suite<br/>@RunWith(Suite.class)<br/>@SuiteClasses({<br/>        MyClassTest.class,<br/>        MySecondClassTest.class })<br/><br/>public class AllTests {<br/><br/>}</span></pre><h1 id="53f9" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">使用Julia测试集进行测试</h1><p id="610c" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">在Julia中，我们摒弃了测试方法、测试类和测试套件之间的人为分离。相反，所有的东西都被融合到一个叫做<code class="fe mx my mz na b">testset</code>的概念中。这些比你在其他框架中发现的更灵活，这就是为什么来自其他框架的开发人员可能会对Julia中松散得多的组织感到不舒服。</p><p id="0532" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在朱丽亚，一切都自由得多。您可以根据自己的偏好和风格定制测试框架。这是可能的，因为测试集可以嵌套。</p><p id="bd9e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里有一个来自我的<a class="ae lz" href="https://github.com/ordovician/LittleManComputer.jl" rel="noopener ugc nofollow" target="_blank">小人电脑(LMC)汇编器</a>的例子，你可以在<a class="ae lz" href="https://github.com/ordovician/LittleManComputer.jl" rel="noopener ugc nofollow" target="_blank"> Github </a>上找到它来更详细地查看测试。</p><pre class="kj kk kl km gt nb na nc nd aw ne bi"><span id="3e7f" class="nf mb it na b gy ng nh l ni nj">@testset "Disassembler tests" begin<br/>   <br/>    @testset "Without operands" begin<br/>        @test disassemble(901) == "INP"<br/>        @test disassemble(902) == "OUT"<br/>        @test disassemble(000) == "HLT"                                     <br/>    end<br/>    <br/>    @testset "With operands" begin<br/>        @test disassemble(105) == "ADD 5"<br/>        @test disassemble(112) == "ADD 12"<br/>        @test disassemble(243) == "SUB 43"<br/>        @test disassemble(399) == "STA 99"<br/>        @test disassemble(510) == "LDA 10"<br/>        @test disassemble(600) == "BRA 0"<br/>        @test disassemble(645) == "BRA 45"<br/>        @test disassemble(782) == "BRZ 82"                                        <br/>    end   <br/>end</span></pre><p id="c913" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于每个主要的软件组件，我定义了一个测试集。让我举一些例子:汇编器、反汇编器和模拟器都由不同的测试集表示。这些测试集中的每一个都有测试该组件各个方面的子测试集。</p><p id="83dd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，Julia <code class="fe mx my mz na b">@testset</code>对应于一个测试函数和一个测试类，以及一个测试套件。</p><h2 id="1e7c" class="nf mb it bd mc nk nl dn mg nm nn dp mk ld no np mm lh nq nr mo ll ns nt mq nu bi translated">在测试集中放什么</h2><p id="d281" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">对于单元测试中应该包含什么有不同的想法。许多人坚信每次测试只测试一个特定的东西的原则。测试集的Julia惯例是每个测试集都有一个相关测试的集合。只需查看Julia标准库中的真实测试就能很好地理解这一点。</p><p id="8623" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我在这里作为例子展示的测试集将会被我缩短一些，因为展示每个测试的完整长度并没有什么特别的价值。</p><pre class="kj kk kl km gt nb na nc nd aw ne bi"><span id="b0b2" class="nf mb it na b gy ng nh l ni nj"># Julia - abstractarray.jl tests<br/><br/>A = rand(5,4,3)<br/>@testset "Bounds checking" begin<br/>    @test checkbounds(Bool, A, 1, 1, 1) == true<br/>    @test checkbounds(Bool, A, 5, 4, 3) == true<br/>    @test checkbounds(Bool, A, 0, 1, 1) == false<br/>    @test checkbounds(Bool, A, 1, 0, 1) == false<br/>    @test checkbounds(Bool, A, 1, 1, 0) == false<br/>end<br/><br/>@testset "vector indices" begin<br/>    @test checkbounds(Bool, A, 1:5, 1:4, 1:3) == true<br/>    @test checkbounds(Bool, A, 0:5, 1:4, 1:3) == false<br/>    @test checkbounds(Bool, A, 1:5, 0:4, 1:3) == false<br/>    @test checkbounds(Bool, A, 1:5, 1:4, 0:3) == false<br/>end</span></pre><p id="92db" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意，为<code class="fe mx my mz na b">abstractarray.jl</code>定义的测试旨在检查几个相关的事情。此外，没有固定装置。我们简单地将被反复测试的数组<code class="fe mx my mz na b">A</code>放在测试集之外。这使得它在每个测试中都可用。我们将在以后探索固定装置的替代品。</p><p id="7d36" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们再举一个例子，看看对由<code class="fe mx my mz na b">Char</code>类型代表的单个字符的测试。</p><pre class="kj kk kl km gt nb na nc nd aw ne bi"><span id="9318" class="nf mb it na b gy ng nh l ni nj"># Julia - char.jl tests<br/>@testset "basic properties" begin<br/><br/>    @test typemin(Char) == Char(0)<br/>    @test ndims(Char) == 0<br/>    @test getindex('a', 1) == 'a'<br/>    @test_throws BoundsError getindex('a', 2)<br/>    # This is current behavior, but it seems questionable<br/>    @test getindex('a', 1, 1, 1) == 'a'<br/>    @test_throws BoundsError getindex('a', 1, 1, 2)<br/><br/>    @test 'b' + 1 == 'c'<br/>    @test typeof('b' + 1) == Char<br/>    @test 1 + 'b' == 'c'<br/>    @test typeof(1 + 'b') == Char<br/>    @test 'b' - 1 == 'a'<br/>    @test typeof('b' - 1) == Char<br/><br/>    @test widen('a') === 'a'<br/>    # just check this works<br/>    @test_throws Base.CodePointError Base.code_point_err(UInt32(1))<br/>end<br/><br/>@testset "issue #14573" begin<br/>    array = ['a', 'b', 'c'] + [1, 2, 3]<br/>    @test array == ['b', 'd', 'f']<br/>    @test eltype(array) == Char<br/><br/>    array = [1, 2, 3] + ['a', 'b', 'c']<br/>    @test array == ['b', 'd', 'f']<br/>    @test eltype(array) == Char<br/><br/>    array = ['a', 'b', 'c'] - [0, 1, 2]<br/>    @test array == ['a', 'a', 'a']<br/>    @test eltype(array) == Char<br/>end</span></pre><p id="54e4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">同样，您可以观察到相关的测试被分组到测试集中。我添加了第二个测试集，以证明Julia开发人员遵循了关于bug修复的流行建议:每当修复一个bug时，创建一个单元测试，它可以捕捉任何重新引入该bug的代码修改。有了这样的实践，我们可以更容易地避免代码质量的退化。</p><h2 id="6b76" class="nf mb it bd mc nk nl dn mg nm nn dp mk ld no np mm lh nq nr mo ll ns nt mq nu bi translated">嵌套测试集</h2><p id="cc42" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">包含您正在测试的代码的测试集也可以包含其他测试集。这里有一个测试中的例子，测试中使用了<code class="fe mx my mz na b">Dict</code>类型来表示Julia中的一个字典。</p><pre class="kj kk kl km gt nb na nc nd aw ne bi"><span id="a455" class="nf mb it na b gy ng nh l ni nj"># Julia - dict.jl tests<br/><br/>@testset "Dict" begin<br/>    h = Dict()<br/>    for i=1:10000<br/>        h[i] = i+1<br/>    end<br/>    for i=1:10000<br/>        @test (h[i] == i+1)<br/>    end<br/>    for i=1:2:10000<br/>        delete!(h, i)<br/>    end<br/>    <br/>    h = Dict{Any,Any}("a" =&gt; 3)<br/>    @test h["a"] == 3<br/>    h["a","b"] = 4<br/>    @test h["a","b"] == h[("a","b")] == 4<br/>    h["a","b","c"] = 4<br/>    @test h["a","b","c"] == h[("a","b","c")] == 4<br/><br/>    @testset "eltype, keytype and valtype" begin<br/>        @test eltype(h) == Pair{Any,Any}<br/>        @test keytype(h) == Any<br/>        @test valtype(h) == Any<br/><br/>        td = Dict{AbstractString,Float64}()<br/>        @test eltype(td) == Pair{AbstractString,Float64}<br/>        @test keytype(td) == AbstractString<br/>        @test valtype(td) == Float64<br/>        @test keytype(Dict{AbstractString,Float64}) === AbstractString<br/>        @test valtype(Dict{AbstractString,Float64}) === Float64<br/>    end<br/>end</span></pre><p id="dab9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">代码显示，在内部测试集中测试的名为<code class="fe mx my mz na b">h</code>的字典实际上是在外部测试集中首先定义的。</p><h2 id="b943" class="nf mb it bd mc nk nl dn mg nm nn dp mk ld no np mm lh nq nr mo ll ns nt mq nu bi translated">使用For循环重复测试</h2><p id="6865" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">在Julia中，使用循环对不同类型的数据重复测试是很容易的。</p><pre class="kj kk kl km gt nb na nc nd aw ne bi"><span id="8fb0" class="nf mb it na b gy ng nh l ni nj">let x = Dict(3=&gt;3, 5=&gt;5, 8=&gt;8, 6=&gt;6)<br/>    pop!(x, 5)<br/>    for k in keys(x)<br/>        Dict{Int,Int}(x)<br/>        @test k in [3, 8, 6]<br/>    end<br/>end</span></pre><p id="26e9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们甚至可以循环整个测试集本身。这里，我们对<code class="fe mx my mz na b">==</code>和<code class="fe mx my mz na b">isequal</code>函数运行相同的测试:</p><pre class="kj kk kl km gt nb na nc nd aw ne bi"><span id="c143" class="nf mb it na b gy ng nh l ni nj">@testset "equality" for eq in (isequal, ==)<br/>    @test  eq(Dict(), Dict())<br/>    @test  eq(Dict(1 =&gt; 1), Dict(1 =&gt; 1))<br/>    @test !eq(Dict(1 =&gt; 1), Dict())<br/>    @test !eq(Dict(1 =&gt; 1), Dict(1 =&gt; 2))<br/>    @test !eq(Dict(1 =&gt; 1), Dict(2 =&gt; 1))<br/>end</span></pre><h1 id="43cd" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">如何在Julia中编写Fixtures</h1><p id="0b80" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">人工测试框架有夹具的概念。Fixtures表示我们希望在多个测试中重复使用的初始化数据。Julia的开发人员认为，仅仅为了处理这个特殊的用例而创造一个独特的概念是过度工程化的。相反，Julia开发人员相信明确地创建可重用数据。许多支持夹具的测试框架以隐含的方式创建这些夹具。</p><h2 id="7c57" class="nf mb it bd mc nk nl dn mg nm nn dp mk ld no np mm lh nq nr mo ll ns nt mq nu bi translated">创建不可变夹具</h2><p id="1406" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">如果您从来没有修改过您的fixture，那么您可以简单地将fixture创建为一个对象，在使用该fixture的所有测试之外。在这种情况下，<code class="fe mx my mz na b">A</code>数组是不可变的(它不会改变),我们在边界检查测试和向量索引测试中都使用了它。</p><pre class="kj kk kl km gt nb na nc nd aw ne bi"><span id="5682" class="nf mb it na b gy ng nh l ni nj">A = rand(5,4,3)<br/>@testset "Bounds checking" begin<br/>    @test checkbounds(Bool, A, 1, 1, 1) == true<br/>    @test checkbounds(Bool, A, 5, 4, 3) == true<br/>end<br/><br/>@testset "vector indices" begin<br/>    @test checkbounds(Bool, A, 1:5, 1:4, 1:3) == true<br/>    @test checkbounds(Bool, A, 0:5, 1:4, 1:3) == false<br/>end</span></pre><h2 id="ab55" class="nf mb it bd mc nk nl dn mg nm nn dp mk ld no np mm lh nq nr mo ll ns nt mq nu bi translated">创建可变装置</h2><p id="3aa7" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">有时我们测试的功能需要改变一个对象。在这种情况下，我们不能在多个测试中重用同一个对象，因为每个测试都可能修改fixture对象，并使其在下一个测试中处于未知状态。在这种情况下，我们定义一个函数来创建fixture对象。使用夹具的每个测试都将调用创建夹具的函数。在本例中，<code class="fe mx my mz na b">test_array</code>是一个创建夹具的函数。</p><pre class="kj kk kl km gt nb na nc nd aw ne bi"><span id="86f9" class="nf mb it na b gy ng nh l ni nj">test_array() = rand(5,4,3)<br/><br/>@testset "Bounds checking" begin<br/>      A = test_array()<br/>    @test checkbounds(Bool, A, 1, 1, 1) == true<br/>    @test checkbounds(Bool, A, 5, 4, 3) == true<br/>end<br/><br/>@testset "vector indices" begin<br/>      A = test_array()<br/>    @test checkbounds(Bool, A, 1:5, 1:4, 1:3) == true<br/>    @test checkbounds(Bool, A, 0:5, 1:4, 1:3) == false<br/>end</span></pre><h1 id="3957" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">更进一步</h1><p id="5ae8" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">想在Julia中了解更多关于测试的知识吗？阅读Julia关于测试的官方文档:<a class="ae lz" href="https://docs.julialang.org/en/v1/stdlib/Test/" rel="noopener ugc nofollow" target="_blank">单元测试</a>。</p><p id="ac15" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有许多我没有介绍的特性可能值得进一步探讨:</p><ul class=""><li id="124b" class="nw nx it kw b kx ky la lb ld ny lh nz ll oa lp ob oc od oe bi translated"><a class="ae lz" href="https://docs.julialang.org/en/v1/stdlib/Test/" rel="noopener ugc nofollow" target="_blank">中断测试</a> <code class="fe mx my mz na b">@test_broken</code> -将测试标记为持续中断。</li><li id="8ad1" class="nw nx it kw b kx of la og ld oh lh oi ll oj lp ob oc od oe bi translated"><a class="ae lz" href="https://docs.julialang.org/en/v1/stdlib/Test/#Creating-Custom-AbstractTestSet-Types" rel="noopener ugc nofollow" target="_blank">AbstractTestSet</a>type——定制测试记录的方式。</li></ul></div></div>    
</body>
</html>