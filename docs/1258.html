<html>
<head>
<title>Don’t fear the HOC, when writing React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">不要害怕特设，写作时要有所反应</h1>
<blockquote>原文：<a href="https://itnext.io/dont-fear-the-hoc-when-writing-react-5875513ce34e?source=collection_archive---------8-----------------------#2018-08-22">https://itnext.io/dont-fear-the-hoc-when-writing-react-5875513ce34e?source=collection_archive---------8-----------------------#2018-08-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/bdd30ed69afb2ae28e88dbbccc981aec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nzSx8iOEcudbLAgu22wJWw.png"/></div></div></figure><p id="eca4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我开始在我的代码中使用<strong class="ka ir">函数式编程(FP) </strong>时，我也开始以不同的方式思考。当某件事情完成并运行时，我不断地问自己，“我能用更优雅的代码得到同样的结果吗？”。当然，我一直在重构我的代码，但是自从我在FP的影响下，<strong class="ka ir">这种在编码时追求纯洁、简单和骄傲的感觉</strong>更加相关。</p><p id="75e6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如<a class="ae kw" href="https://reactjs.org/docs/higher-order-components.html" rel="noopener ugc nofollow" target="_blank">官方文档</a>中所说:<em class="kx">一个HOC是一个接受一个组件并返回一个新组件</em>的函数，显然他们在这个过程中做了一些事情，通常他们通过执行一些额外的逻辑向目标组件添加一些属性，允许他们重用HOC包含的代码。</p><p id="67e7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">本文假装是对任何感兴趣的人的粗略介绍和参考，不仅是为了理解它们是什么，也是为了分享我在真实例子中使用<em class="kx">高阶元件(HOC) </em>的经验。</p><h1 id="719b" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">当我们使用hoc时</h1><p id="d487" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">我从一开始就在没有注意的情况下使用了<strong class="ka ir"> HOCs </strong>，当你开始将第三方的common集成到你的代码中时，可以找到简单的例子，比如<em class="kx"> Redux </em>或<em class="kx"> graphql </em>。</p><p id="7f4a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我将粘贴一段代码，使用<em class="kx"> graphql </em>和<em class="kx"> Apollo </em>从会话中查询和获取用户数据，以及一个简单验证码的基本逻辑。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="8202" class="mk kz iq mg b gy ml mm l mn mo">import React from 'react';<br/>import PropTypes from 'prop-types';<br/>// eslint-disable-next-line<br/>import { Meteor } from 'meteor/meteor';<br/>import gql from 'graphql-tag';<br/>import { graphql, withApollo } from 'react-apollo';<br/><br/>import LoggedApp from './LoggedApp';<br/>import Logging from './Logging';<br/><br/>const App = props =&gt; {<br/>  const { data, client } = props;<br/>  // Skipping the execution if data is not loaded<br/>  if (data.loading) return null;<br/>  // We show the LoggedApp  or Logging one depending if the user is logged<br/>  return data.user._id ? &lt;LoggedApp {...props} /&gt; : &lt;Logging client={client} /&gt;;<br/>};<br/><br/>const userQuery = gql`<br/>  query User {<br/>    user {<br/>      _id<br/>      alias<br/>    }<br/>    users {<br/>      _id<br/>      alias<br/>    }<br/>  }<br/>`;<br/><br/>export default graphql(userQuery)(withApollo(App));</span></pre><p id="d770" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里，我们没有直接导出<code class="fe mp mq mr mg b">App</code>组件用于我们应用程序的其他部分，而是使用2个hoc，一个注入<code class="fe mp mq mr mg b">graphql</code>查询，另一个注入<code class="fe mp mq mr mg b">Apollo</code>来管理查询。因此，在这个简单的例子中，除了2个hoc之外，没有人使用。</p><p id="726b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在他们的<a class="ae kw" href="https://www.apollographql.com/docs/react/essentials/get-started.html" rel="noopener ugc nofollow" target="_blank">官方文档</a>中有更多关于如何在你的应用中使用Apollo的细节。</p><p id="a352" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">作为一个真正高层次的总结，我们可以说<strong class="ka ir"> HOCs返回我们的组件，给它们添加一些特殊的属性，把你从包含在HOC </strong>中的逻辑中抽象出来。</p><h1 id="3d0f" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">项目环境示例</h1><p id="8ff7" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">所以在理解了hoc可以给你的代码带来的好处之后，当我看到一个好机会的时候，我会在我的代码中使用它们。这里我会试着解释一个清晰的情况。</p><p id="f251" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<a class="ae kw" href="https://precursive.com/" rel="noopener ugc nofollow" target="_blank">precurive</a>中，我们使用<strong class="ka ir">React</strong>+<a class="ae kw" href="https://react.lightningdesignsystem.com/" rel="noopener ugc nofollow" target="_blank">Design System React</a>(一个我们用来呈现<a class="ae kw" href="https://www.lightningdesignsystem.com/" rel="noopener ugc nofollow" target="_blank"> Lightning </a>调度页面的库)。这个库是Lightning的<strong class="ka ir"> React </strong>实现，因为它可以在不同的环境中使用，我们需要指定我们在哪里找到图标资产(SVG)。</p><p id="bc52" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们用<a class="ae kw" href="https://react.lightningdesignsystem.com/components/icon-settings/" rel="noopener ugc nofollow" target="_blank">图标设置</a>做这个配置，一个组件，这个组件被用作你的根组件的包装器，所有嵌套的组件将使用它来知道在哪里找到图标资产。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="a68b" class="mk kz iq mg b gy ml mm l mn mo">// imports...<br/><br/>const sagaMiddleware = createSagaMiddleware();<br/><br/>// Creating enhancers to connect our middleware (saga and asyncDispatchMiddleware)<br/>// and adding devtools in elegant way<br/>const enhancer = composeWithDevTools(applyMiddleware(sagaMiddleware));<br/><br/>const store = createStore(reducers, {}, enhancer);<br/><br/>// We load the configuration of the icons differently depending if we have<br/>// or not the local environment icons available from _slds<br/>const IconConfiguration =<br/>  process.env.NODE_ENV === 'development' ? (<br/>    // eslint-disable-next-line<br/>    const actionSprite = require('@salesforce-ux/icons/dist/salesforce-lightning-design-system-icons/action-sprite/svg/symbols.svg');<br/>    // eslint-disable-next-line<br/>    const customSprite = require('@salesforce-ux/icons/dist/salesforce-lightning-design-system-icons/custom-sprite/svg/symbols.svg');<br/>    // eslint-disable-next-line<br/>    const doctypeSprite = require('@salesforce-ux/icons/dist/salesforce-lightning-design-system-icons/doctype-sprite/svg/symbols.svg');<br/>    // eslint-disable-next-line<br/>    const standardSprite = require('@salesforce-ux/icons/dist/salesforce-lightning-design-system-icons/standard-sprite/svg/symbols.svg');<br/>    // eslint-disable-next-line<br/>    const utilitySprite = require('@salesforce-ux/icons/dist/salesforce-lightning-design-system-icons/utility-sprite/svg/symbols.svg');<br/>    &lt;IconSettings<br/>      actionSprite={actionSprite}<br/>      customSprite={customSprite}<br/>      doctypeSprite={doctypeSprite}<br/>      standardSprite={standardSprite}<br/>      utilitySprite={utilitySprite}<br/>    &gt;<br/>      &lt;App /&gt;<br/>    &lt;/IconSettings&gt;<br/>  ) : (<br/>    &lt;IconSettings iconPath="/_slds/icons"&gt;<br/>      &lt;App /&gt;<br/>    &lt;/IconSettings&gt;<br/>  );<br/><br/>sagaMiddleware.run(rootSaga);<br/>render(&lt;Provider store={store}&gt;{IconConfiguration}&lt;/Provider&gt;, document.getElementById('app'));</span></pre><p id="5c32" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，基本上你可以看到，根据环境，当应用程序部署在Salesforce中时，我们通过<em class="kx">加载SVG需要</em>或中继到Salesforce资产(<strong class="ka ir">如果图标已经在Lightning Experience中加载，为什么要将它们加载到我们的静态资源中</strong>)。</p><blockquote class="ms mt mu"><p id="0c37" class="jy jz kx ka b kb kc kd ke kf kg kh ki mv kk kl km mw ko kp kq mx ks kt ku kv ij bi translated"><em class="iq">注意我在if语句中使用了require，这样我只在开发环境中获取那些SVG，避免将它们包含在要部署的包中。</em></p></blockquote><h1 id="b324" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">要解决的问题</h1><p id="85ad" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">前面的代码可以工作，但是我们有两个问题。</p><ul class=""><li id="6161" class="my mz iq ka b kb kc kf kg kj na kn nb kr nc kv nd ne nf ng bi translated">首先，我们的代码可以被隔离在图标配置之外，它完全独立于应用程序的初始化。</li><li id="2fcb" class="my mz iq ka b kb nh kf ni kj nj kn nk kr nl kv nd ne nf ng bi translated">第二，如果我们想在应用程序的不同部分使用这段代码(有其他根组件要挂载)…那么我们必须复制并粘贴代码，而<strong class="ka ir">这从来都不是一个选项</strong>。</li></ul><h1 id="6249" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">使用HOC的解决方案</h1><p id="29b3" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">那么为什么不使用一个特设来隔离这个<code class="fe mp mq mr mg b">IconSettings</code>组件的创建逻辑，听起来像是一个很好的用例，你不觉得吗？</p><p id="c7f3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">实际上，HOCs的解决方案是我们必须返回一个包装到<code class="fe mp mq mr mg b">IconSettings</code>组件中的新组件的唯一工具(该组件需要设置为包装器)</p><p id="896d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以我用这段代码创建了一个名为<code class="fe mp mq mr mg b">iconifyComponent</code>的新组件。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="ab49" class="mk kz iq mg b gy ml mm l mn mo">import React from 'react';<br/><br/>import { IconSettings } from '@salesforce/design-system-react';<br/><br/>/**<br/> * HOC to wrap the IconSettings logic and reuse when need to be reused (on salesforce environment)<br/> * We load the configuration of the icons differently depending if we have<br/> * or not the local environment icons available from _slds<br/> */<br/>export function iconifyComponent(WrappedComponent) {<br/>  return function WrappingComponent(props) {<br/>    if (process.env.NODE_ENV === 'development') {<br/>      // eslint-disable-next-line<br/>      const actionSprite = require('@salesforce-ux/icons/dist/salesforce-lightning-design-system-icons/action-sprite/svg/symbols.svg');<br/>      // eslint-disable-next-line<br/>      const customSprite = require('@salesforce-ux/icons/dist/salesforce-lightning-design-system-icons/custom-sprite/svg/symbols.svg');<br/>      // eslint-disable-next-line<br/>      const doctypeSprite = require('@salesforce-ux/icons/dist/salesforce-lightning-design-system-icons/doctype-sprite/svg/symbols.svg');<br/>      // eslint-disable-next-line<br/>      const standardSprite = require('@salesforce-ux/icons/dist/salesforce-lightning-design-system-icons/standard-sprite/svg/symbols.svg');<br/>      // eslint-disable-next-line<br/>      const utilitySprite = require('@salesforce-ux/icons/dist/salesforce-lightning-design-system-icons/utility-sprite/svg/symbols.svg');<br/>      return (<br/>        &lt;IconSettings<br/>          actionSprite={actionSprite}<br/>          customSprite={customSprite}<br/>          doctypeSprite={doctypeSprite}<br/>          standardSprite={standardSprite}<br/>          utilitySprite={utilitySprite}<br/>        &gt;<br/>          &lt;WrappedComponent {...props} /&gt;<br/>        &lt;/IconSettings&gt;<br/>      );<br/>    }<br/>    return (<br/>      &lt;IconSettings iconPath="/_slds/icons"&gt;<br/>        &lt;WrappedComponent {...props} /&gt;<br/>      &lt;/IconSettings&gt;<br/>    );<br/>  };<br/>}</span></pre><p id="b49c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，在我们的入口点，我们可以使用HOC来抽象图标配置，并使它非常漂亮，优雅和清晰。</p><p id="afc1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们的入口点(<code class="fe mp mq mr mg b">index.js</code>)中使用创建的<code class="fe mp mq mr mg b">iconifyComponent</code>，我们得到了类似这样的东西:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="e909" class="mk kz iq mg b gy ml mm l mn mo">// more imports...<br/>import { iconifyComponent } from './data/iconifyComponent';<br/><br/>const sagaMiddleware = createSagaMiddleware();<br/><br/>// Creating enhancers to connect our middleware (saga and asyncDispatchMiddleware)<br/>// and adding devtools in elegant way<br/>const enhancer = composeWithDevTools(applyMiddleware(sagaMiddleware));<br/><br/>const store = createStore(reducers, {}, enhancer);<br/>const AppIconized = iconifyComponent(App);<br/><br/>sagaMiddleware.run(rootSaga);<br/>const AppIconized = iconifyComponent(App);<br/>render(<br/>  &lt;Provider store={store}&gt;<br/>    &lt;AppIconized /&gt;<br/>  &lt;/Provider&gt;,<br/>  document.getElementById('app')<br/>);</span></pre><p id="de8f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">🤩很性感，你不觉得吗？如果现在，我们需要在应用程序的任何其他部分使用相同的图标配置(如果有另一个根应用程序)，我们可以再次使用HOC，忘记细节。</p><h1 id="64ed" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">结论</h1><p id="60c8" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">和生活中的所有事情一样，我们不应该在代码中滥用hoc的用法，并尝试在有意义的时候编写它们，但另一方面，我们在React环境中的工具中提供了一个非常优雅的解决方案。</p><p id="0f8f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">那么，告诉我你对这个用例的想法，以及在你的代码中使用hoc的想法。</p><p id="c1a3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">回头见！</p></div><div class="ab cl nm nn hu no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="ij ik il im in"><p id="4eba" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kx">最初发表于</em><a class="ae kw" href="https://robertovg.com/blog/don-t-fear-the-hoc-when-writing-react" rel="noopener ugc nofollow" target="_blank"><em class="kx">【robertovg.com】</em></a><em class="kx">。</em></p></div></div>    
</body>
</html>