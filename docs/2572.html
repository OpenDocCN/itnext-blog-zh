<html>
<head>
<title>Angular: Effective Component Patterns</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">角度:有效组件模式</h1>
<blockquote>原文：<a href="https://itnext.io/angular-effective-component-patterns-f5f7f08e2072?source=collection_archive---------0-----------------------#2019-06-17">https://itnext.io/angular-effective-component-patterns-f5f7f08e2072?source=collection_archive---------0-----------------------#2019-06-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c30e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在组件之间共享数据</h2></div><p id="3d6d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我构建了一个示例Angular应用程序，显示了四种组件模式。这些模式对于在组件之间共享数据既简单又有效。我们将使用这些模式的具体例子来说明如何使用它们。</p><p id="d950" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae le" href="https://github.com/Everduin94/component-communication-patterns" rel="noopener ugc nofollow" target="_blank">在Github上下载源代码🚀</a></p><p id="b3de" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae le" href="https://stackblitz.com/edit/erxk-component-communication" rel="noopener ugc nofollow" target="_blank">在Stackblitz现场测试🚀</a></p><p id="deb6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将涵盖:</p><ul class=""><li id="9412" class="lf lg it kk b kl km ko kp kr lh kv li kz lj ld lk ll lm ln bi translated">将数据从父组件传递到子组件</li><li id="29a0" class="lf lg it kk b kl lo ko lp kr lq kv lr kz ls ld lk ll lm ln bi translated">在同级组件之间传递数据</li><li id="eb81" class="lf lg it kk b kl lo ko lp kr lq kv lr kz ls ld lk ll lm ln bi translated">将数据从一个组件传递到一个不相关的组件。</li><li id="c201" class="lf lg it kk b kl lo ko lp kr lq kv lr kz ls ld lk ll lm ln bi translated">父组件和子组件之间的多向数据传递</li></ul><h1 id="88ed" class="lt lu it bd lv lw lx ly lz ma mb mc md jz me ka mf kc mg kd mh kf mi kg mj mk bi translated">父子模式</h1><p id="a607" class="pw-post-body-paragraph ki kj it kk b kl ml ju kn ko mm jx kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">我们可以根据组件在DOM中的位置实现不同的模式。每当我们需要促进两个组件之间的通信时，我们可以根据它们之间的关系来实现其中一个模式。</p><p id="47a9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当一个元素(子元素)位于另一个元素(父元素)内部时，就存在父子关系。我们的父到子示例将是一个“服务条款”复选框，它将在悬停时显示工具提示。选中该框后，工具提示的消息将会改变。</p><figure class="mr ms mt mu gt mv gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi mq"><img src="../Images/4b39ea4bef994182b1556eccbf836d62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*xmiN9XAvjyR9e0n8zXuEBQ.gif"/></div></div></figure><h2 id="4509" class="nc lu it bd lv nd ne dn lz nf ng dp md kr nh ni mf kv nj nk mh kz nl nm mj nn bi translated">主体和可观察的——维护和发出状态变化</h2><p id="6641" class="pw-post-body-paragraph ki kj it kk b kl ml ju kn ko mm jx kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">我们所有的模式都将利用从BehaviorSubject创建的一个<code class="fe no np nq nr b">BehaviorSubject/state</code>和一个<code class="fe no np nq nr b">Observable/eventStream$</code>。这允许我们在行为主体中保持状态，并通过可观察对象发出对该状态的改变。<a class="ae le" href="http://reactivex.io/rxjs/manual/overview.html#observable" rel="noopener ugc nofollow" target="_blank">【1.1】</a><a class="ae le" href="http://reactivex.io/rxjs/manual/overview.html#behaviorsubject" rel="noopener ugc nofollow" target="_blank">【1.2】</a></p><p id="693e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">提示:利用一个<strong class="kk iu">私有行为主体</strong>和一个<strong class="kk iu">公共可观察对象</strong>允许我们<strong class="kk iu">锁定对我们状态的访问并防止过度修改</strong>。</p><figure class="mr ms mt mu gt mv"><div class="bz fp l di"><div class="ns nt l"/></div><figcaption class="nu nv gj gh gi nw nx bd b be z dk translated">parent.component.ts | ToS复选框☑</figcaption></figure><p id="4430" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们可以<strong class="kk iu">利用与RxJS的角度事件绑定来触发对我们的状态/数据的更新</strong>。每当父节点的输入被改变或与鼠标交互时，父节点状态将被更新。<a class="ae le" href="https://angular.io/guide/user-input" rel="noopener ugc nofollow" target="_blank">【2】</a></p><p id="fe2a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们所有的模式都将利用角度事件绑定和类似的RxJS。关键的区别在于组件如何接收可观察值，或者它们如何相互传递状态变化。</p><figure class="mr ms mt mu gt mv"><div class="bz fp l di"><div class="ns nt l"/></div><figcaption class="nu nv gj gh gi nw nx bd b be z dk translated">parent.component.html | tos复选框☑</figcaption></figure><h2 id="d13f" class="nc lu it bd lv nd ne dn lz nf ng dp md kr nh ni mf kv nj nk mh kz nl nm mj nn bi translated">@Input —接收子组件中的更改</h2><p id="14d2" class="pw-post-body-paragraph ki kj it kk b kl ml ju kn ko mm jx kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">在初始化时，我们的父节点将使用<code class="fe no np nq nr b">@Input</code>把它的可观察值传递给我们的子节点。一旦输入被初始化，<strong class="kk iu">子进程将通过我们的异步管道订阅接收父进程状态的任何变化。</strong><a class="ae le" href="https://angular.io/api/core/Input" rel="noopener ugc nofollow" target="_blank">【3】</a></p><p id="6644" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">利用这种模式，我们的组件现在完全是反应式的。这简化了在调试或将来进行修改时使用组件的工作。</p><figure class="mr ms mt mu gt mv"><div class="bz fp l di"><div class="ns nt l"/></div><figcaption class="nu nv gj gh gi nw nx bd b be z dk translated">child.component.html |工具提示</figcaption></figure><h2 id="24ce" class="nc lu it bd lv nd ne dn lz nf ng dp md kr nh ni mf kv nj nk mh kz nl nm mj nn bi translated">可观察值和@Input的交替使用</h2><p id="054e" class="pw-post-body-paragraph ki kj it kk b kl ml ju kn ko mm jx kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">我们可以使用一个异步管道将值从父对象传递给子对象，而不是传递整个可观察对象。使用——基于偏好，或者一个比另一个更适合特定需求。**</p><figure class="mr ms mt mu gt mv"><div class="bz fp l di"><div class="ns nt l"/></div><figcaption class="nu nv gj gh gi nw nx bd b be z dk translated">parent.component.html</figcaption></figure><figure class="mr ms mt mu gt mv"><div class="bz fp l di"><div class="ns nt l"/></div><figcaption class="nu nv gj gh gi nw nx bd b be z dk translated">child.component.html</figcaption></figure><h1 id="76c4" class="lt lu it bd lv lw lx ly lz ma mb mc md jz me ka mf kc mg kd mh kf mi kg mj mk bi translated">兄弟模式</h1><p id="7466" class="pw-post-body-paragraph ki kj it kk b kl ml ju kn ko mm jx kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">当多个元素共享一个公共父元素时，就存在兄弟关系。我们的兄弟组件示例将是一个改变显示颜色的颜色选择器。在这个例子中，只有我们的颜色选择器会更新状态。然而，利用这种模式，任何数量的兄弟都可以更新状态。</p><figure class="mr ms mt mu gt mv gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi gj"><img src="../Images/2237358126af953ad84a9b8f0f860641.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*8op7I2TdAS2Lwna03zR4tA.gif"/></div></div></figure><h2 id="f8c4" class="nc lu it bd lv nd ne dn lz nf ng dp md kr nh ni mf kv nj nk mh kz nl nm mj nn bi translated">容器和指令——促进沟通</h2><p id="86dd" class="pw-post-body-paragraph ki kj it kk b kl ml ju kn ko mm jx kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">在兄弟组件之间传递数据；我们将把它们包装在一个容器中，比如div或ng-container，并对容器应用角度指令。<strong class="kk iu">该指令将作为兄弟之间的父指令或中介</strong>,用于相互传递状态/数据。</p><p id="c516" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">类似于我们的亲子模式，我们仍然使用私有行为主体。但是，我们将向兄弟节点公开更新状态的方法。这允许兄弟姐妹向我们的行为主体发送新数据，而无需直接访问它。</p><figure class="mr ms mt mu gt mv"><div class="bz fp l di"><div class="ns nt l"/></div><figcaption class="nu nv gj gh gi nw nx bd b be z dk translated">parent.directive.ts</figcaption></figure><h2 id="97a0" class="nc lu it bd lv nd ne dn lz nf ng dp md kr nh ni mf kv nj nk mh kz nl nm mj nn bi translated">注入指令—访问状态</h2><p id="8cc8" class="pw-post-body-paragraph ki kj it kk b kl ml ju kn ko mm jx kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">我们的兄弟组件注入父指令<a class="ae le" href="https://angular.io/guide/dependency-injection" rel="noopener ugc nofollow" target="_blank">【4】</a>。这给了他们引用我们指令的可观察值<code class="fe no np nq nr b">color$</code>的能力。为了访问从<code class="fe no np nq nr b">color$</code>发出的值，我们将利用异步管道。理想情况下，只要适用，我们都希望使用异步管道。<a class="ae le" href="https://medium.com/better-programming/angular-rxjs-async-pipe-deep-dive-2510b56f793a" rel="noopener">【5】(我的文章:异步管道深潜)</a></p><figure class="mr ms mt mu gt mv"><div class="bz fp l di"><div class="ns nt l"/></div><figcaption class="nu nv gj gh gi nw nx bd b be z dk translated">儿童-两个.组件. ts | child-two.component.html |颜色选择器</figcaption></figure><p id="b6ce" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以添加任意多的兄弟姐妹。我们只需将兄弟元素添加到容器中，它将能够发送和接收来自其他组件的数据。</p><figure class="mr ms mt mu gt mv"><div class="bz fp l di"><div class="ns nt l"/></div><figcaption class="nu nv gj gh gi nw nx bd b be z dk translated">app.component.html</figcaption></figure><h1 id="44ee" class="lt lu it bd lv lw lx ly lz ma mb mc md jz me ka mf kc mg kd mh kf mi kg mj mk bi translated">无关模式</h1><p id="0c7a" class="pw-post-body-paragraph ki kj it kk b kl ml ju kn ko mm jx kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">没有共同父元素的元素被认为是不相关的。我们的例子是一个按钮和一个toast消息，它们不共享一个公共的父类或包装器。我们将利用角度服务来促进两个组件之间的数据共享。</p><figure class="mr ms mt mu gt mv gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/870e680492e06a4e2aae5fb7b6e2fb99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1320/1*93OmNGcGTAkJX0Nb_ciWKA.gif"/></div></figure><h2 id="444d" class="nc lu it bd lv nd ne dn lz nf ng dp md kr nh ni mf kv nj nk mh kz nl nm mj nn bi translated">注入服务访问状态</h2><p id="803f" class="pw-post-body-paragraph ki kj it kk b kl ml ju kn ko mm jx kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">这种模式类似于兄弟模式。关键的区别在于，我们使用了角度服务，而不是角度指令。该服务的优势在于我们不再需要在同一个容器中包含两个组件。</p><p id="6f31" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">与指令相比，如果我们需要服务的多个实例，服务的一个潜在缺点是增加了复杂性。在这个场景中，我们只需要服务的一个实例。</p><figure class="mr ms mt mu gt mv"><div class="bz fp l di"><div class="ns nt l"/></div><figcaption class="nu nv gj gh gi nw nx bd b be z dk translated">toast.service.ts</figcaption></figure><p id="a943" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">每当<code class="fe no np nq nr b">ActivatorComponent</code>对<code class="fe no np nq nr b">ToastService</code>进行更新时，<code class="fe no np nq nr b">ToastComponent</code>将通过服务接收更新。在这个场景中不需要@Input，因为一切都是通过服务实现的。</p><figure class="mr ms mt mu gt mv"><div class="bz fp l di"><div class="ns nt l"/></div><figcaption class="nu nv gj gh gi nw nx bd b be z dk translated">activator.component.ts | Button</figcaption></figure><figure class="mr ms mt mu gt mv"><div class="bz fp l di"><div class="ns nt l"/></div><figcaption class="nu nv gj gh gi nw nx bd b be z dk translated">toast.component.ts | Toast</figcaption></figure><h1 id="1ee6" class="lt lu it bd lv lw lx ly lz ma mb mc md jz me ka mf kc mg kd mh kf mi kg mj mk bi translated">多方向数据</h1><p id="eaea" class="pw-post-body-paragraph ki kj it kk b kl ml ju kn ko mm jx kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">我们的最后一个模式将以一个带有多个子元素的父元素为特色。父节点将能够将状态/数据向下传递给子节点，子节点将能够将状态/数据向上传递回父节点。</p><figure class="mr ms mt mu gt mv gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi nz"><img src="../Images/1019b0babe0962b0974c460dd5c13b2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*xDco8R74-0aNoYrSCAsMqQ.gif"/></div></div></figure><h2 id="97df" class="nc lu it bd lv nd ne dn lz nf ng dp md kr nh ni mf kv nj nk mh kz nl nm mj nn bi translated">主体和可观察的——维护和发出状态变化</h2><p id="b112" class="pw-post-body-paragraph ki kj it kk b kl ml ju kn ko mm jx kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">类似于父-子模式，我们将利用一个私有行为主体和一个公共可观察对象来维护状态并将变化发送给子对象。</p><figure class="mr ms mt mu gt mv"><div class="bz fp l di"><div class="ns nt l"/></div><figcaption class="nu nv gj gh gi nw nx bd b be z dk translated">多父组件</figcaption></figure><h2 id="0166" class="nc lu it bd lv nd ne dn lz nf ng dp md kr nh ni mf kv nj nk mh kz nl nm mj nn bi translated">@Output —接收父组件中的更改</h2><p id="3ba4" class="pw-post-body-paragraph ki kj it kk b kl ml ju kn ko mm jx kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">这是使我们的模式具有多向性的关键区别。</p><p id="69bc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">我们利用@Output来允许我们的子组件向我们的父组件发出事件/状态。</strong><a class="ae le" href="https://angular.io/api/core/Output" rel="noopener ugc nofollow" target="_blank">【6】</a></p><p id="9eec" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这个场景中，我们将用一个<code class="fe no np nq nr b">EventEmitter</code>来代替我们的可观察对象。将EventEmitter与@Output一起使用是一种常见的做法，并得到文档的支持。</p><figure class="mr ms mt mu gt mv"><div class="bz fp l di"><div class="ns nt l"/></div><figcaption class="nu nv gj gh gi nw nx bd b be z dk translated">multi-parent.component.html | multi-child.component.html</figcaption></figure><p id="f10f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我们的EventEmitter发出一个值时，就会调用<code class="fe no np nq nr b">done($event)</code>方法。<code class="fe no np nq nr b">$event</code>将包含从EventEmitter发出的任何状态/数据。</p><p id="cd12" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了维护状态并在子对象和父对象中使用该值，我们向BehaviorSubject发出关于更改的事件。如果我们不需要维护状态，我们可以省略BehaviorSubject，只使用EventEmitter。**</p><figure class="mr ms mt mu gt mv"><div class="bz fp l di"><div class="ns nt l"/></div><figcaption class="nu nv gj gh gi nw nx bd b be z dk translated">多子组件</figcaption></figure><h1 id="bc40" class="lt lu it bd lv lw lx ly lz ma mb mc md jz me ka mf kc mg kd mh kf mi kg mj mk bi translated">摘要</h1><ul class=""><li id="704a" class="lf lg it kk b kl ml ko mm kr oa kv ob kz oc ld lk ll lm ln bi translated"><strong class="kk iu">父到子模式:</strong>利用父中的Subject和Observable以及子中的@Input来促进从父向子发送数据</li><li id="0dc3" class="lf lg it kk b kl lo ko lp kr lq kv lr kz ls ld lk ll lm ln bi translated"><strong class="kk iu">兄弟模式:</strong>主体和可观察对象存在于一个指令中，该指令充当兄弟之间发送和接收数据的中介</li><li id="706e" class="lf lg it kk b kl lo ko lp kr lq kv lr kz ls ld lk ll lm ln bi translated"><strong class="kk iu">不相关模式:</strong>主体和可观察对象生活在服务中，组件不必共享父组件或容器</li><li id="43cd" class="lf lg it kk b kl lo ko lp kr lq kv lr kz ls ld lk ll lm ln bi translated"><strong class="kk iu">多向父子模式:</strong>与父子模式相同。将@Output添加到子组件，以便将状态/事件发送回父组件。</li></ul></div><div class="ab cl od oe hx of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="im in io ip iq"><blockquote class="ok ol om"><p id="35e7" class="ki kj on kk b kl km ju kn ko kp jx kq oo ks kt ku op kw kx ky oq la lb lc ld im bi translated">☁️<a class="ae le" href="https://flotes.app" rel="noopener ugc nofollow" target="_blank">flotes</a>——尝试演示，不需要登录。或者免费报名。Flotes是我记笔记和高效学习的方式，即使在我很忙的时候。</p></blockquote><figure class="mr ms mt mu gt mv gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi or"><img src="../Images/8e468f6e74135bbbc2ecbfce7e2db2bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wGqAj2R16w33dIiKDnHEUA.png"/></div></div><figcaption class="nu nv gj gh gi nw nx bd b be z dk translated"><a class="ae le" href="https://flotes.app" rel="noopener ugc nofollow" target="_blank"> Flotes </a></figcaption></figure><h1 id="eeba" class="lt lu it bd lv lw lx ly lz ma mb mc md jz me ka mf kc mg kd mh kf mi kg mj mk bi translated">资源/参考资料</h1><p id="998d" class="pw-post-body-paragraph ki kj it kk b kl ml ju kn ko mm jx kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">[1.1]<a class="ae le" href="http://reactivex.io/rxjs/manual/overview.html#observable" rel="noopener ugc nofollow" target="_blank">http://reactivex.io/rxjs/manual/overview.html#observable</a></p><p id="525a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">【1.2】<a class="ae le" href="http://reactivex.io/rxjs/manual/overview.html#behaviorsubject" rel="noopener ugc nofollow" target="_blank">http://react vex . io/rxjs/manual/overview . html # behavior subject</a></p><p id="d533" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae le" href="https://angular.io/guide/user-input" rel="noopener ugc nofollow" target="_blank">https://angular.io/guide/user-input</a></p><p id="81cf" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">[3]<a class="ae le" href="https://angular.io/api/core/Input" rel="noopener ugc nofollow" target="_blank">https://angular.io/api/core/Input</a></p><p id="fec0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae le" href="https://angular.io/guide/dependency-injection" rel="noopener ugc nofollow" target="_blank">https://angular.io/guide/dependency-injection</a></p><p id="0b1e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">[5]我的文章:<a class="ae le" href="https://medium.com/better-programming/angular-rxjs-async-pipe-deep-dive-2510b56f793a" rel="noopener">https://medium . com/better-programming/angular-rxjs-async-pipe-deep-dive-2510 b 56 f 793 a</a></p><p id="77d1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae le" href="https://angular.io/api/core/Output" rel="noopener ugc nofollow" target="_blank">https://angular.io/api/core/Output</a></p><p id="08b5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">* —组件/元素可互换使用。当引用DOM: element中的关系或位置时。当提到数据使用或代码时:组件<br/> ** —感谢那些提供反馈的人</p></div></div>    
</body>
</html>