<html>
<head>
<title>Refactoring AJAX Calls and Observables</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">重构AJAX调用和观察值</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-safely-refactor-old-code-part-3-f285a6200988?source=collection_archive---------5-----------------------#2018-11-24">https://itnext.io/how-to-safely-refactor-old-code-part-3-f285a6200988?source=collection_archive---------5-----------------------#2018-11-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/246f23de581fe85bf5aff779b63d4940.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*aKZyWoz_2iZsGAHr"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">由<a class="ae jd" href="https://unsplash.com/@rossf?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">罗斯·芬登</a>在<a class="ae jd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><div class=""/><div class=""><h2 id="397f" class="pw-subtitle-paragraph ke jf jg bd b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv dk translated">安全重构旧代码:第3部分</h2></div><p id="4ecc" class="pw-post-body-paragraph kw kx jg ky b kz la ki lb lc ld kl le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个系列中，我们一步步地回顾安全重构旧代码的概念设计模式。我编写本指南是为了适应任何类型的重构场景，示例项目是Node.js with RxJS。</p><p id="e749" class="pw-post-body-paragraph kw kx jg ky b kz la ki lb lc ld kl le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls">这是关于安全重构代码的3部分系列文章的最后一篇文章</em><em class="ls">:</em></p><ul class=""><li id="cbba" class="lt lu jg ky b kz la lc ld lf lv lj lw ln lx lr ly lz ma mb bi translated"><a class="ae jd" href="https://medium.com/@Sawtaytoes/how-to-safely-refactor-old-code-part-1-a1a853263fec" rel="noopener"> <em class="ls">第1部分:防止现有系统的突破性变化</em> </a></li><li id="26b2" class="lt lu jg ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated"><a class="ae jd" href="https://medium.com/@Sawtaytoes/how-to-safely-refactor-old-code-part-2-2d09451b4e8f" rel="noopener"> <em class="ls">第二部分:不要只是重构，要让它具有可维护性</em> </a></li><li id="1d1b" class="lt lu jg ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated"><a class="ae jd" href="https://medium.com/@Sawtaytoes/how-to-safely-refactor-old-code-part-3-f285a6200988" rel="noopener"> <em class="ls">第3部分:重构AJAX调用和观察对象</em> </a></li></ul><h1 id="8682" class="mh mi jg bd mj mk ml mm mn mo mp mq mr kn ms ko mt kq mu kr mv kt mw ku mx my bi translated">我们的故事到此为止</h1><p id="1a49" class="pw-post-body-paragraph kw kx jg ky b kz mz ki lb lc na kl le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">我们终于开始了大量的重构工作，但是现在我们需要通过重构AJAX调用和可观察的方法来完成它。</p><h1 id="8c48" class="mh mi jg bd mj mk ml mm mn mo mp mq mr kn ms ko mt kq mu kr mv kt mw ku mx my bi translated">AJAX方法的单元测试</h1><p id="ed83" class="pw-post-body-paragraph kw kx jg ky b kz mz ki lb lc na kl le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated"><code class="fe ne nf ng nh b">doScaryLightFlash</code>是一个不使用依赖注入的数据获取函数。正因为如此，我们真的没有办法对这个函数进行单元测试，或者阻止它实际进行AJAX调用。</p><figure class="ni nj nk nl gt is"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="229d" class="pw-post-body-paragraph kw kx jg ky b kz la ki lb lc ld kl le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对我们来说，重构唯一真正重要的部分是<code class="fe ne nf ng nh b">fetch</code>调用，因为这阻止了我们编写单元测试。我们最好的办法是用我们在<a class="ae jd" href="https://medium.com/@Sawtaytoes/how-to-safely-refactor-old-code-part-2-2d09451b4e8f" rel="noopener"> <strong class="ky jh">第二部分</strong> </a>中所用的相同方式来处理函数组合的依赖注入。</p><figure class="ni nj nk nl gt is"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="85d9" class="pw-post-body-paragraph kw kx jg ky b kz la ki lb lc ld kl le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">尽管这很简单，但它使我们有可能编写所有的单元测试，并最终用我们选择的任何库(包括单元测试的fetch模拟库)来切换节点获取。</p><p id="157b" class="pw-post-body-paragraph kw kx jg ky b kz la ki lb lc ld kl le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">看起来是这样的:</p><figure class="ni nj nk nl gt is"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="e1ae" class="pw-post-body-paragraph kw kx jg ky b kz la ki lb lc ld kl le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我使用fetch-mock是因为这是我能找到的最流行的解决方案。这些测试没什么特别的。如果我们得到一个HTTP 202，我想知道它没有错误。虽然它可能不会，但如果它得到了400分，它应该会失败。因为这不是我们的API，我们只需要确保我们正在进行正确的数据调用。我们甚至可以验证正文和URL是否与我们的期望值相匹配，但是对于这个项目来说，这并不重要。</p><h1 id="f18e" class="mh mi jg bd mj mk ml mm mn mo mp mq mr kn ms ko mt kq mu kr mv kt mw ku mx my bi translated">完事了吗？</h1><p id="4f54" class="pw-post-body-paragraph kw kx jg ky b kz mz ki lb lc na kl le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">我可以就此打住，但是<code class="fe ne nf ng nh b">createScaryLightFlasher</code>可以在未来受益于更多的配置。请记住，我们希望将它变成一个npm包，因此我们必须考虑其他用户的需求。</p><p id="6e70" class="pw-post-body-paragraph kw kx jg ky b kz la ki lb lc ld kl le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您想让多个灯组同时运行闪光器，当前功能将LIFX选择器硬编码在<code class="fe ne nf ng nh b">config</code>中，不允许任何定制。该代码不应该驻留在数据提取器函数中。理想情况下，LIFX选择器值位于应用程序的大图部分，我们使用RxJS来处理如何复制AJAX调用。</p><p id="235d" class="pw-post-body-paragraph kw kx jg ky b kz la ki lb lc ld kl le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们已经有了单元测试，我们可以安全地重构这个函数来获得更多的选项。在这种情况下，我们想要定制的只是LIFX选择器，这样任何人都可以调用这个灯光闪烁函数，并以他们想要的任何闪烁配置传递任何灯光配置。</p><p id="753e" class="pw-post-body-paragraph kw kx jg ky b kz la ki lb lc ld kl le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是最后一次重构:</p><figure class="ni nj nk nl gt is"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="e148" class="pw-post-body-paragraph kw kx jg ky b kz la ki lb lc ld kl le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，<code class="fe ne nf ng nh b">lifxSelector</code>被传递给获取调用。因此，我们能够对其进行定制。如果有人正在使用这个库，现在他们可以传入任何他们想要的选择器，而不必使用来自<code class="fe ne nf ng nh b">config</code>的单个值。</p><h1 id="2242" class="mh mi jg bd mj mk ml mm mn mo mp mq mr kn ms ko mt kq mu kr mv kt mw ku mx my bi translated">最终确定工作示例</h1><p id="af61" class="pw-post-body-paragraph kw kx jg ky b kz mz ki lb lc na kl le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">我们最不想重构的是最外部的可观察性。它每10秒钟检查一次是否是万圣节。与其这样，为什么不设置一个可观察的计时器，在万圣节的时候启动，然后在这段时间内间隔10秒钟。时间超出范围后，切换回下一年的原始计时器可观察值。这样，你可以让应用全年运行，而不必担心它每10秒钟就要做一些事情。</p><p id="985f" class="pw-post-body-paragraph kw kx jg ky b kz la ki lb lc ld kl le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">看起来是这样的:</p><figure class="ni nj nk nl gt is"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="142c" class="pw-post-body-paragraph kw kx jg ky b kz la ki lb lc ld kl le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是一次彻底的重构，需要很多改变；新功能和其他更新。这也意味着外部可观察对象现在有大量的逻辑，也需要单元测试，因为以前，外部可观察对象非常简单。现在，它正在做递归和设置等待计时器。</p><p id="f8fe" class="pw-post-body-paragraph kw kx jg ky b kz la ki lb lc ld kl le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当然，这是正确的解决方案，但是现在逻辑更复杂了，还有更多的需要测试。如果我让它保持原样，我们就不会有这么复杂的应用程序，也不需要对外部可观察对象进行单元测试。这些是重构时要记住的事情。</p><p id="fb17" class="pw-post-body-paragraph kw kx jg ky b kz la ki lb lc ld kl le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我更喜欢当前的版本，但是我把旧版本留在README中作为一个更简单的例子，因为这个版本需要更多的时间来理解，并且没有单元测试，它也是未经测试的。</p><h1 id="7c78" class="mh mi jg bd mj mk ml mm mn mo mp mq mr kn ms ko mt kq mu kr mv kt mw ku mx my bi translated">结论</h1><p id="2b5a" class="pw-post-body-paragraph kw kx jg ky b kz mz ki lb lc na kl le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">重构工作量很大。你真的需要确保你有所有必要的业务需求。一旦为现有代码编写了自动化测试，进行重构就容易多了，但是最重要的是弄清楚在哪里花时间编写测试，并以最小的改动获得可测试的代码。</p><p id="dc02" class="pw-post-body-paragraph kw kx jg ky b kz la ki lb lc ld kl le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你想亲自体验lifx-万圣节，你可以在npm 上找到<a class="ae jd" href="https://www.npmjs.com/package/lifx-halloween" rel="noopener ugc nofollow" target="_blank">套餐。</a></p><figure class="ni nj nk nl gt is"><div class="bz fp l di"><div class="no nn l"/></div></figure><h1 id="a559" class="mh mi jg bd mj mk ml mm mn mo mp mq mr kn ms ko mt kq mu kr mv kt mw ku mx my bi translated">更多阅读</h1><p id="94c3" class="pw-post-body-paragraph kw kx jg ky b kz mz ki lb lc na kl le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">如果你喜欢你所读的，你也应该看看我关于智能家居和函数式编程的其他文章:</p><ul class=""><li id="d972" class="lt lu jg ky b kz la lc ld lf lv lj lw ln lx lr ly lz ma mb bi translated"><a class="ae jd" href="https://medium.com/flicblog/flic-buttons-and-the-observable-customization-using-rxjs-2214bc53d407" rel="noopener"> RxJS和可观察的Flic按钮</a></li><li id="2eb2" class="lt lu jg ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated"><a class="ae jd" href="https://medium.com/flicblog/controlling-iot-devices-with-the-flic-of-a-button-1349c81bddef" rel="noopener">轻触按钮控制物联网设备</a></li><li id="e22a" class="lt lu jg ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated">函数式编程的表情爱好者指南:第一部分</li></ul></div></div>    
</body>
</html>