<html>
<head>
<title>Graph Query Language Comparison: Gremlin vs Cypher vs nGQL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">图查询语言对比:Gremlin vs Cypher vs nGQL</h1>
<blockquote>原文：<a href="https://itnext.io/graph-query-language-comparison-gremlin-vs-cypher-vs-ngql-3680cf830f8b?source=collection_archive---------4-----------------------#2022-08-29">https://itnext.io/graph-query-language-comparison-gremlin-vs-cypher-vs-ngql-3680cf830f8b?source=collection_archive---------4-----------------------#2022-08-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/6d62db9849541862c02fefa8dfe90933.png" data-original-src="https://miro.medium.com/v2/resize:fit:1060/format:webp/0*dVJ2j2ThrAAVy0Jk.png"/></div></figure><h1 id="5c66" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">要比较哪些图形查询语言</h1><figure class="kt ku kv kw gt jr gh gi paragraph-image"><div class="gh gi ks"><img src="../Images/5c814dc0c2621eb44484ddc6d76b4c75.png" data-original-src="https://miro.medium.com/v2/resize:fit:730/format:webp/0*crJhVbz9SzL9ITx9.png"/></div></figure><h2 id="2f2a" class="kx jv iq bd jw ky kz dn ka la lb dp ke lc ld le ki lf lg lh km li lj lk kq ll bi translated">小妖精</h2><p id="f218" class="pw-post-body-paragraph lm ln iq lo b lp lq lr ls lt lu lv lw lc lx ly lz lf ma mb mc li md me mf mg ij bi translated">Gremlin 是由Apache TinkerPop开发的一种图形遍历语言，已经被许多图形数据库解决方案所采用。可以是<strong class="lo ir">的陈述性</strong>，也可以是<strong class="lo ir">的祈使性</strong>。</p><p id="e4b0" class="pw-post-body-paragraph lm ln iq lo b lp mi lr ls lt mj lv lw lc mk ly lz lf ml mb mc li mm me mf mg ij bi translated">Gremlin基于Groovy，但有许多语言变体，允许开发人员用许多现代编程语言(如Java、JavaScript、Python、Scala、Clojure和Groovy)原生编写Gremlin查询。</p><p id="f8a1" class="pw-post-body-paragraph lm ln iq lo b lp mi lr ls lt mj lv lw lc mk ly lz lf ml mb mc li mm me mf mg ij bi translated"><strong class="lo ir">支持的图数据库</strong> : Janus Graph、InfiniteGraph、Cosmos DB、DataStax Enterprise(5.0+)和亚马逊Neptune。</p><h2 id="a1bb" class="kx jv iq bd jw ky kz dn ka la lb dp ke lc ld le ki lf lg lh km li lj lk kq ll bi translated">赛弗</h2><p id="89d5" class="pw-post-body-paragraph lm ln iq lo b lp lq lr ls lt lu lv lw lc lx ly lz lf ma mb mc li md me mf mg ij bi translated"><a class="ae mh" href="https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=13&amp;cad=rja&amp;uact=8&amp;ved=2ahUKEwi5-ZfEtfvnAhWSad4KHTDpClwQFjAMegQIBRAB&amp;url=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FCypher&amp;usg=AOvVaw3rCtDns3Bbr5mIuBpSN4hr" rel="noopener ugc nofollow" target="_blank"> Cypher </a>是一种声明式图形查询语言，允许在属性图中进行富有表现力和高效的数据查询。</p><p id="7385" class="pw-post-body-paragraph lm ln iq lo b lp mi lr ls lt mj lv lw lc mk ly lz lf ml mb mc li mm me mf mg ij bi translated">这种语言是用SQL的强大功能设计的。Cypher语言的关键字不区分大小写，但是属性、标签、关系类型和变量区分大小写。</p><p id="98a6" class="pw-post-body-paragraph lm ln iq lo b lp mi lr ls lt mj lv lw lc mk ly lz lf ml mb mc li mm me mf mg ij bi translated"><strong class="lo ir">支持的图形数据库</strong> : Neo4j、AgensGraph和RedisGraph</p><h2 id="f1d7" class="kx jv iq bd jw ky kz dn ka la lb dp ke lc ld le ki lf lg lh km li lj lk kq ll bi translated">nGQL</h2><p id="629b" class="pw-post-body-paragraph lm ln iq lo b lp lq lr ls lt lu lv lw lc lx ly lz lf ma mb mc li md me mf mg ij bi translated"><a class="ae mh" href="https://nebula-graph.io" rel="noopener ugc nofollow" target="_blank"> <strong class="lo ir"> NebulaGraph </strong> </a>引入了自己的查询语言<a class="ae mh" href="https://docs.nebula-graph.io/manual-EN/1.overview/1.concepts/2.nGQL-overview/" rel="noopener ugc nofollow" target="_blank"> nGQL </a>，这是一种声明式的、文本化的查询语言，类似于SQL，但是是为图形设计的。</p><p id="8ea7" class="pw-post-body-paragraph lm ln iq lo b lp mi lr ls lt mj lv lw lc mk ly lz lf ml mb mc li mm me mf mg ij bi translated">nGQL语言的关键字是区分大小写的，它支持语句合成，因此不需要嵌入语句。</p><p id="31e7" class="pw-post-body-paragraph lm ln iq lo b lp mi lr ls lt mj lv lw lc mk ly lz lf ml mb mc li mm me mf mg ij bi translated"><strong class="lo ir">支持图形数据库</strong>:星云图</p><h1 id="9231" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">术语比较</h1><p id="cd9b" class="pw-post-body-paragraph lm ln iq lo b lp lq lr ls lt lu lv lw lc lx ly lz lf ma mb mc li md me mf mg ij bi translated">在比较这三种图查询语言之前，我们先来看看它们的术语和概念。下表解释了这些语言如何定义节点和边:</p><figure class="kt ku kv kw gt jr gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/e605ce48dbc522eaa33cda6ef26a069a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/1*npGkVeIdMOZl7zAQ4D3F9g.png"/></div></figure><p id="992b" class="pw-post-body-paragraph lm ln iq lo b lp mi lr ls lt mj lv lw lc mk ly lz lf ml mb mc li mm me mf mg ij bi translated">语法比较— CRUD</p><p id="6594" class="pw-post-body-paragraph lm ln iq lo b lp mi lr ls lt mj lv lw lc mk ly lz lf ml mb mc li mm me mf mg ij bi translated">了解了Gremlin、Cypher和nGQL中的常用术语后，让我们来看看这些图形查询语言的一般语法。</p><p id="3ad6" class="pw-post-body-paragraph lm ln iq lo b lp mi lr ls lt mj lv lw lc mk ly lz lf ml mb mc li mm me mf mg ij bi translated">本节将分别带您了解Gremlin、Cypher和nGQL的基本CRUD语法。</p><h2 id="3008" class="kx jv iq bd jw ky kz dn ka la lb dp ke lc ld le ki lf lg lh km li lj lk kq ll bi translated">图表</h2><p id="84c7" class="pw-post-body-paragraph lm ln iq lo b lp lq lr ls lt lu lv lw lc lx ly lz lf ma mb mc li md me mf mg ij bi translated">关于如何创建图形空间，请参考以下示例。我们省略了Cypher，因为在向图形数据库添加任何数据之前，您不需要创建图形空间。</p><pre class="kt ku kv kw gt mo mp mq mr aw ms bi"><span id="0270" class="kx jv iq mp b gy mt mu l mv mw"># Create a graph that Gremlin can traverse<br/>g = TinkerGraph.open().traversal()</span><span id="e9ae" class="kx jv iq mp b gy mx mu l mv mw"># Create a graph space in nGQL<br/>CREATE SPACE gods</span></pre><h2 id="7bec" class="kx jv iq bd jw ky kz dn ka la lb dp ke lc ld le ki lf lg lh km li lj lk kq ll bi translated">顶点</h2><p id="c325" class="pw-post-body-paragraph lm ln iq lo b lp lq lr ls lt lu lv lw lc lx ly lz lf ma mb mc li md me mf mg ij bi translated">我们都知道图是由节点和边组成的。Cypher中的一个节点在Gremlin和nGQL中称为顶点。边是两个节点之间的连接。</p><p id="a901" class="pw-post-body-paragraph lm ln iq lo b lp mi lr ls lt mj lv lw lc mk ly lz lf ml mb mc li mm me mf mg ij bi translated">参考下面分别在这些查询语言中插入新顶点的例子。</p><pre class="kt ku kv kw gt mo mp mq mr aw ms bi"><span id="41a9" class="kx jv iq mp b gy mt mu l mv mw"># Insert vertex in Gremlin<br/>g.addV(vertexLabel).property()</span><span id="3154" class="kx jv iq mp b gy mx mu l mv mw"># Insert vertex in Cypher<br/>CREATE (:nodeLabel {property})</span><span id="c299" class="kx jv iq mp b gy mx mu l mv mw"># Insert vertex in nGQL<br/>INSERT VERTEX tagName (propNameList) VALUES vid:(tagKey propValue)</span></pre><p id="4072" class="pw-post-body-paragraph lm ln iq lo b lp mi lr ls lt mj lv lw lc mk ly lz lf ml mb mc li mm me mf mg ij bi translated">顶点类型</p><p id="63b9" class="pw-post-body-paragraph lm ln iq lo b lp mi lr ls lt mj lv lw lc mk ly lz lf ml mb mc li mm me mf mg ij bi translated">节点/顶点可以有类型。它们在Gremlin和Cypher中称为标签，在nGQL中称为标签。</p><p id="50e6" class="pw-post-body-paragraph lm ln iq lo b lp mi lr ls lt mj lv lw lc mk ly lz lf ml mb mc li mm me mf mg ij bi translated">一个顶点类型可以有多个属性。例如，顶点类型<em class="my">人物</em>有两个属性，即<em class="my">姓名</em>和<em class="my">年龄</em>。</p><figure class="kt ku kv kw gt jr gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/6dbf12812c42cc62f4d582051697ecdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1162/format:webp/0*Dac6susSUsKudD9_.png"/></div></figure><pre class="kt ku kv kw gt mo mp mq mr aw ms bi"><span id="5b24" class="kx jv iq mp b gy mt mu l mv mw">Create Vertex Type</span></pre><p id="3387" class="pw-post-body-paragraph lm ln iq lo b lp mi lr ls lt mj lv lw lc mk ly lz lf ml mb mc li mm me mf mg ij bi translated">请参考下面的顶点类型创建示例。我们省略了Cypher，因为在插入数据之前不需要标签。</p><pre class="kt ku kv kw gt mo mp mq mr aw ms bi"><span id="8101" class="kx jv iq mp b gy mt mu l mv mw"># Create vertex type in Gremlin<br/>g.addV(vertexLabel).property()</span><span id="a8d3" class="kx jv iq mp b gy mx mu l mv mw"># Create vertex type in nGQL<br/>CREATE tagName(PropNameList)</span></pre><p id="0950" class="pw-post-body-paragraph lm ln iq lo b lp mi lr ls lt mj lv lw lc mk ly lz lf ml mb mc li mm me mf mg ij bi translated">注意，Gremlin和nGQL都支持IF NOT EXISTS。该关键字自动检测相应的顶点类型是否存在。如果它不存在，则创建一个新的。否则，不会创建任何顶点类型。</p><pre class="kt ku kv kw gt mo mp mq mr aw ms bi"><span id="c63a" class="kx jv iq mp b gy mt mu l mv mw">Show Vertex Types</span></pre><p id="1d01" class="pw-post-body-paragraph lm ln iq lo b lp mi lr ls lt mj lv lw lc mk ly lz lf ml mb mc li mm me mf mg ij bi translated">创建顶点类型后，您可以使用以下查询来显示它们。他们将列出所有标签/标记，而不是某些标签/标记。</p><pre class="kt ku kv kw gt mo mp mq mr aw ms bi"><span id="aeb2" class="kx jv iq mp b gy mt mu l mv mw"># Show vertex types in Gremlin<br/>g.V().label().dedup();</span><span id="963f" class="kx jv iq mp b gy mx mu l mv mw"># Show vertex types in Cypher method 1<br/>MATCH (n) <br/>RETURN DISTINCT labels(n)<br/># Show vertex types in Cypher method 2<br/>CALL db.labels();</span><span id="6c4e" class="kx jv iq mp b gy mx mu l mv mw"># Show vertex types in nGQL<br/>SHOW TAGS</span></pre><p id="1505" class="pw-post-body-paragraph lm ln iq lo b lp mi lr ls lt mj lv lw lc mk ly lz lf ml mb mc li mm me mf mg ij bi translated">顶点上的污垢</p><p id="f690" class="pw-post-body-paragraph lm ln iq lo b lp mi lr ls lt mj lv lw lc mk ly lz lf ml mb mc li mm me mf mg ij bi translated">本节介绍使用三种查询语言对顶点进行的基本CRUD操作。</p><pre class="kt ku kv kw gt mo mp mq mr aw ms bi"><span id="6563" class="kx jv iq mp b gy mt mu l mv mw">Insert Vertices</span><span id="8bf4" class="kx jv iq mp b gy mx mu l mv mw"># Insert vertex of certain type in Gremlin<br/>g.addV(String vertexLabel).property()</span><span id="996a" class="kx jv iq mp b gy mx mu l mv mw"># Insert vertex of certain type in Cypher<br/>CREATE (node:label) </span><span id="371f" class="kx jv iq mp b gy mx mu l mv mw"># Insert vertex of certain type in nGQL<br/>INSERT VERTEX &lt;tag_name&gt; (prop_name_list) VALUES &lt;vid&gt;:(prop_value_list)</span><span id="c109" class="kx jv iq mp b gy mx mu l mv mw">Get Vertices</span><span id="210c" class="kx jv iq mp b gy mx mu l mv mw"># Fetch vertices in Gremlin<br/>g.V(&lt;vid&gt;)</span><span id="1c01" class="kx jv iq mp b gy mx mu l mv mw"># Fetch vertices in Cypher<br/>MATCH (n) <br/>WHERE condition<br/>RETURN properties(n)</span><span id="433d" class="kx jv iq mp b gy mx mu l mv mw"># Fetch vertices in nGQL<br/>FETCH PROP ON &lt;tag_name&gt; &lt;vid&gt;</span><span id="2682" class="kx jv iq mp b gy mx mu l mv mw">Delete Vertices</span><span id="7aa0" class="kx jv iq mp b gy mx mu l mv mw"># Delete vertex in Gremlin<br/>g.V(&lt;vid&gt;).drop()</span><span id="7006" class="kx jv iq mp b gy mx mu l mv mw"># Delete a vertex in Cypher<br/>MATCH (node:label) <br/>DETACH DELETE node</span><span id="5c21" class="kx jv iq mp b gy mx mu l mv mw"># Delete vertex in nGQL<br/>DELETE VERTEX &lt;vid&gt;</span><span id="0d28" class="kx jv iq mp b gy mx mu l mv mw">Update a Vertex's Property</span></pre><p id="ff11" class="pw-post-body-paragraph lm ln iq lo b lp mi lr ls lt mj lv lw lc mk ly lz lf ml mb mc li mm me mf mg ij bi translated">本节将向您展示如何更新顶点的属性。</p><pre class="kt ku kv kw gt mo mp mq mr aw ms bi"><span id="a455" class="kx jv iq mp b gy mt mu l mv mw"># Update vertex in Gremlin<br/>g.V(&lt;vid&gt;).property()</span><span id="d636" class="kx jv iq mp b gy mx mu l mv mw"># Update vertex in Cypher<br/>SET n.prop = V</span><span id="d2e2" class="kx jv iq mp b gy mx mu l mv mw"># Update vertex in nGQL<br/>UPDATE VERTEX &lt;vid&gt; SET &lt;update_columns&gt;</span></pre><p id="f8fa" class="pw-post-body-paragraph lm ln iq lo b lp mi lr ls lt mj lv lw lc mk ly lz lf ml mb mc li mm me mf mg ij bi translated">Cypher和nGQL都使用关键字SET来设置顶点类型，只是nGQL中增加了UPDATE关键字来标识操作。Gremlin的操作类似于上面提到的抓取顶点，只是增加了改变属性的操作。</p><h2 id="078d" class="kx jv iq bd jw ky kz dn ka la lb dp ke lc ld le ki lf lg lh km li lj lk kq ll bi translated">优势</h2><p id="e9c3" class="pw-post-body-paragraph lm ln iq lo b lp lq lr ls lt lu lv lw lc lx ly lz lf ma mb mc li md me mf mg ij bi translated">本节介绍边上的基本CRUD操作。</p><p id="3e75" class="pw-post-body-paragraph lm ln iq lo b lp mi lr ls lt mj lv lw lc mk ly lz lf ml mb mc li mm me mf mg ij bi translated">边缘类型</p><p id="fbcb" class="pw-post-body-paragraph lm ln iq lo b lp mi lr ls lt mj lv lw lc mk ly lz lf ml mb mc li mm me mf mg ij bi translated">像顶点一样，边也可以有类型。</p><pre class="kt ku kv kw gt mo mp mq mr aw ms bi"><span id="b913" class="kx jv iq mp b gy mt mu l mv mw"># Create an edge type in Gremlin<br/>g.edgeLabel()</span><span id="73af" class="kx jv iq mp b gy mx mu l mv mw"># Create an edge type in nGQL<br/>CREATE EDGE edgeTypeName(propNameList)</span></pre><p id="bddc" class="pw-post-body-paragraph lm ln iq lo b lp mi lr ls lt mj lv lw lc mk ly lz lf ml mb mc li mm me mf mg ij bi translated">边缘有污垢</p><pre class="kt ku kv kw gt mo mp mq mr aw ms bi"><span id="962e" class="kx jv iq mp b gy mt mu l mv mw">Insert Edges of Certain Types</span></pre><p id="41a8" class="pw-post-body-paragraph lm ln iq lo b lp mi lr ls lt mj lv lw lc mk ly lz lf ml mb mc li mm me mf mg ij bi translated">插入边类似于插入顶点。Cypher用-[]--&gt;和nGQL分别用-&gt;表示边。Gremlin使用关键字to()来指示边方向。</p><p id="7636" class="pw-post-body-paragraph lm ln iq lo b lp mi lr ls lt mj lv lw lc mk ly lz lf ml mb mc li mm me mf mg ij bi translated">缺省情况下，三种语言中的边都是定向的。下面左边的图表是有向边，而右边的图表是无向边。</p><figure class="kt ku kv kw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi na"><img src="../Images/675a899c180088cbce1afc94375495c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*3ewrtLEkMtYutLsl.png"/></div></div></figure><pre class="kt ku kv kw gt mo mp mq mr aw ms bi"><span id="4ff3" class="kx jv iq mp b gy mt mu l mv mw"># Insert edge of certain type in Gremlin<br/>g.addE(String edgeLabel).from(v1).to(v2).property()</span><span id="0865" class="kx jv iq mp b gy mx mu l mv mw"># Insert edge of certain type in Cypher<br/>CREATE (&lt;node1-name&gt;:&lt;label1-name&gt;)-<br/>  [(&lt;relationship-name&gt;:&lt;relationship-label-name&gt;)]<br/>  -&gt;(&lt;node2-name&gt;:&lt;label2-name&gt;)</span><span id="07ae" class="kx jv iq mp b gy mx mu l mv mw"># Insert edge of certain type in nGQL<br/>INSERT EDGE &lt;edge_name&gt; ( &lt;prop_name_list&gt; ) VALUES &lt;src_vid&gt; -&gt; &lt;dst_vid&gt;: ( &lt;prop_value_list&gt; )</span><span id="c81d" class="kx jv iq mp b gy mx mu l mv mw">Delete Edges</span><span id="453a" class="kx jv iq mp b gy mx mu l mv mw"># Delete edge in Gremlin<br/>g.E(&lt;eid&gt;).drop()</span><span id="5777" class="kx jv iq mp b gy mx mu l mv mw"># Delete edge in Cypher<br/>MATCH (&lt;node1-name&gt;:&lt;label1-name&gt;)-[r:relationship-label-name]-&gt;()<br/>DELETE r</span><span id="f261" class="kx jv iq mp b gy mx mu l mv mw"># Delete edge in nGQL<br/>DELETE EDGE &lt;edge_type&gt; &lt;src_vid&gt; -&gt; &lt;dst_vid&gt;</span><span id="e4af" class="kx jv iq mp b gy mx mu l mv mw">Fetch Edges</span><span id="c685" class="kx jv iq mp b gy mx mu l mv mw"># Fetch edges in Gremlin<br/>g.E(&lt;eid&gt;)</span><span id="d3af" class="kx jv iq mp b gy mx mu l mv mw"># Fetch edges in Cypher<br/>MATCH (n)-[r:label]-&gt;()<br/>WHERE condition<br/>RETURN properties(r)</span><span id="ebaa" class="kx jv iq mp b gy mx mu l mv mw"># Fetch edges in nGQL<br/>FETCH PROP ON &lt;edge_name&gt; &lt;src_vid&gt; -&gt; &lt;dst_vid&gt;</span></pre><h2 id="3ec6" class="kx jv iq bd jw ky kz dn ka la lb dp ke lc ld le ki lf lg lh km li lj lk kq ll bi translated">其他操作</h2><p id="f2b8" class="pw-post-body-paragraph lm ln iq lo b lp lq lr ls lt lu lv lw lc lx ly lz lf ma mb mc li md me mf mg ij bi translated">除了顶点和边上常见的CRUD，我们还将向您展示三种图形查询语言中的一些组合查询。</p><p id="bea8" class="pw-post-body-paragraph lm ln iq lo b lp mi lr ls lt mj lv lw lc mk ly lz lf ml mb mc li mm me mf mg ij bi translated">遍历边缘</p><pre class="kt ku kv kw gt mo mp mq mr aw ms bi"><span id="f687" class="kx jv iq mp b gy mt mu l mv mw"># Traverse edges with specified vertices in Gremlin<br/>g.V(&lt;vid&gt;).outE(&lt;edge&gt;)</span><span id="7665" class="kx jv iq mp b gy mx mu l mv mw"># Traverse edges with specified vertices in Cypher<br/>Match (n)-&gt;[r:label]-&gt;[]<br/>WHERE id(n) = vid<br/>RETURN r</span><span id="df0d" class="kx jv iq mp b gy mx mu l mv mw"># Traverse edges with specified vertices in nGQL<br/>GO FROM &lt;vid&gt; OVER &lt;edge&gt;</span></pre><p id="a315" class="pw-post-body-paragraph lm ln iq lo b lp mi lr ls lt mj lv lw lc mk ly lz lf ml mb mc li mm me mf mg ij bi translated">反向遍历边</p><p id="ff21" class="pw-post-body-paragraph lm ln iq lo b lp mi lr ls lt mj lv lw lc mk ly lz lf ml mb mc li mm me mf mg ij bi translated">在反向遍历中，GremlIn用in表示反转，Cypher用</p><pre class="kt ku kv kw gt mo mp mq mr aw ms bi"><span id="be04" class="kx jv iq mp b gy mt mu l mv mw"># Traverse edges reversely with specified vertices Gremlin<br/>g.V(&lt;vid&gt;).in(&lt;edge&gt;)</span><span id="9783" class="kx jv iq mp b gy mx mu l mv mw"># Traverse edges reversely with specified vertices Cypher<br/>MATCH (n)&lt;-[r:label]-()</span><span id="0006" class="kx jv iq mp b gy mx mu l mv mw"># Traverse edges reversely with specified vertices nGQL<br/>GO FROM &lt;vid&gt;  OVER &lt;edge&gt; REVERSELY</span></pre><p id="88ad" class="pw-post-body-paragraph lm ln iq lo b lp mi lr ls lt mj lv lw lc mk ly lz lf ml mb mc li mm me mf mg ij bi translated">Traverse edges bidirectionally</p><p id="8f55" class="pw-post-body-paragraph lm ln iq lo b lp mi lr ls lt mj lv lw lc mk ly lz lf ml mb mc li mm me mf mg ij bi translated">If the edge direction is <a class="ae mh" href="https://www.google.com/search?q=irrelevant&amp;spell=1&amp;sa=X&amp;ved=2ahUKEwjR1fPGovvnAhUsIDQIHXSzDRIQkeECKAB6BAgOECs" rel="noopener ugc nofollow" target="_blank">不相关</a>(两个方向都可以)，Gremlin都用thE()，Cypher use -[]-，nGQL用关键字BIDIRECT。</p><pre class="kt ku kv kw gt mo mp mq mr aw ms bi"><span id="18b1" class="kx jv iq mp b gy mt mu l mv mw"># Traverse edges reversely with specified vertices Gremlin<br/>g.V(&lt;vid&gt;).bothE(&lt;edge&gt;)</span><span id="1973" class="kx jv iq mp b gy mx mu l mv mw"># Traverse edges reversely with specified vertices Cypher<br/>MATCH (n)-[r:label]-()</span><span id="9f26" class="kx jv iq mp b gy mx mu l mv mw"># Traverse edges reversely with specified vertices nGQL<br/>GO FROM &lt;vid&gt;  OVER &lt;edge&gt; BIDIRECT</span></pre><p id="bb77" class="pw-post-body-paragraph lm ln iq lo b lp mi lr ls lt mj lv lw lc mk ly lz lf ml mb mc li mm me mf mg ij bi translated">沿指定边查询N跳</p><p id="38b4" class="pw-post-body-paragraph lm ln iq lo b lp mi lr ls lt mj lv lw lc mk ly lz lf ml mb mc li mm me mf mg ij bi translated">Gremlin和nGQL分别用时间和步长来表示N跳。Cypher使用关系*N。</p><pre class="kt ku kv kw gt mo mp mq mr aw ms bi"><span id="cbd5" class="kx jv iq mp b gy mt mu l mv mw"># Query N hops along specified edge in Gremlin<br/>g.V(&lt;vid&gt;).repeat(out(&lt;edge&gt;)).times(N)</span><span id="4a4b" class="kx jv iq mp b gy mx mu l mv mw"># Query N hops along specified edge in Cypher<br/>MATCH (n)-[r:label*N]-&gt;()<br/>WHERE condition<br/>RETURN r</span><span id="74c2" class="kx jv iq mp b gy mx mu l mv mw"># Query N hops along specified edge in nGQL<br/>GO N STEPS FROM &lt;vid&gt; OVER &lt;edge&gt;</span></pre><p id="f088" class="pw-post-body-paragraph lm ln iq lo b lp mi lr ls lt mj lv lw lc mk ly lz lf ml mb mc li mm me mf mg ij bi translated">查找两个顶点之间的路径</p><pre class="kt ku kv kw gt mo mp mq mr aw ms bi"><span id="1686" class="kx jv iq mp b gy mt mu l mv mw"># Find paths between two vertices in Gremlin<br/>g.V(&lt;vid&gt;).repeat(out()).until(&lt;vid&gt;).path()</span><span id="3d7f" class="kx jv iq mp b gy mx mu l mv mw"># Find paths between two vertices in Cypher<br/>MATCH p =(a)-[.*]-&gt;(b)<br/>WHERE condition<br/>RETURN p</span><span id="0c69" class="kx jv iq mp b gy mx mu l mv mw"># Find paths between two vertices in nGQL<br/>FIND ALL PATH FROM &lt;vid&gt; TO &lt;vid&gt; OVER *</span></pre><h1 id="19af" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">示例查询</h1><p id="cf31" class="pw-post-body-paragraph lm ln iq lo b lp lq lr ls lt lu lv lw lc lx ly lz lf ma mb mc li md me mf mg ij bi translated">本节介绍一些演示查询。</p><h2 id="c070" class="kx jv iq bd jw ky kz dn ka la lb dp ke lc ld le ki lf lg lh km li lj lk kq ll bi translated">演示模型:神的图形</h2><p id="8868" class="pw-post-body-paragraph lm ln iq lo b lp lq lr ls lt lu lv lw lc lx ly lz lf ma mb mc li md me mf mg ij bi translated">本节中的示例广泛使用了分布有<a class="ae mh" href="https://janusgraph.org/" rel="noopener ugc nofollow" target="_blank">杰纳斯图</a>的玩具图，称为<a class="ae mh" href="https://docs.janusgraph.org/#getting-started" rel="noopener ugc nofollow" target="_blank"> <em class="my">天神图</em> </a>，如下图所示。</p><p id="336f" class="pw-post-body-paragraph lm ln iq lo b lp mi lr ls lt mj lv lw lc mk ly lz lf ml mb mc li mm me mf mg ij bi translated">这个例子描述了罗马万神殿的存在和地点之间的关系。</p><figure class="kt ku kv kw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi na"><img src="../Images/7bc483d84b34ba27770c095d85d3d438.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*5kV0CufLshzWglAm.png"/></div></div></figure><h2 id="c5a5" class="kx jv iq bd jw ky kz dn ka la lb dp ke lc ld le ki lf lg lh km li lj lk kq ll bi translated">插入数据</h2><pre class="kt ku kv kw gt mo mp mq mr aw ms bi"><span id="c2a2" class="kx jv iq mp b gy mt mu l mv mw"># Inserting vertices<br/>## nGQL<br/>nebula&gt; INSERT VERTEX character(name, age, type) VALUES hash("saturn"):("saturn", 10000, "titan"), hash("jupiter"):("jupiter", 5000, "god");<br/>## Gremlin<br/>gremlin&gt; saturn = g.addV("character").property(T.id, 1).property('name', 'saturn').property('age', 10000).property('type', 'titan').next();<br/>==&gt;v[1]<br/>gremlin&gt; jupiter = g.addV("character").property(T.id, 2).property('name', 'jupiter').property('age', 5000).property('type', 'god').next();<br/>==&gt;v[2]<br/>gremlin&gt; prometheus = g.addV("character").property(T.id, 31).property('name',  'prometheus').property('age', 1000).property('type', 'god').next();<br/>==&gt;v[31]<br/>gremlin&gt; jesus = g.addV("character").property(T.id, 32).property('name',  'jesus').property('age', 5000).property('type', 'god').next();<br/>==&gt;v[32]<br/>## Cypher<br/>cypher&gt; CREATE (src:character {name:"saturn", age: 10000, type:"titan"})<br/>cypher&gt; CREATE (dst:character {name:"jupiter", age: 5000, type:"god"})</span><span id="7c1f" class="kx jv iq mp b gy mx mu l mv mw"># Inserting edges<br/>## nGQL<br/>nebula&gt; INSERT EDGE father() VALUES hash("jupiter")-&gt;hash("saturn"):();<br/>## Gremlin<br/>gremlin&gt; g.addE("father").from(jupiter).to(saturn).property(T.id, 13);<br/>==&gt;e[13][2-father-&gt;1]<br/>## Cypher<br/>cypher&gt; CREATE (src)-[rel:father]-&gt;(dst)</span></pre><h2 id="633e" class="kx jv iq bd jw ky kz dn ka la lb dp ke lc ld le ki lf lg lh km li lj lk kq ll bi translated">删除</h2><pre class="kt ku kv kw gt mo mp mq mr aw ms bi"><span id="cec6" class="kx jv iq mp b gy mt mu l mv mw"># nGQL<br/>nebula&gt; DELETE VERTEX hash("prometheus");<br/># Gremlin<br/>gremlin&gt; g.V(prometheus).drop();<br/># Cypher<br/>cypher&gt; MATCH (n:character {name:"prometheus"}) DETACH DELETE n</span></pre><h2 id="d443" class="kx jv iq bd jw ky kz dn ka la lb dp ke lc ld le ki lf lg lh km li lj lk kq ll bi translated">更新</h2><pre class="kt ku kv kw gt mo mp mq mr aw ms bi"><span id="1ecf" class="kx jv iq mp b gy mt mu l mv mw"># nGQL<br/>nebula&gt; UPDATE VERTEX hash("jesus") SET character.type = 'titan';<br/># Gremlin<br/>gremlin&gt; g.V(jesus).property('age', 6000);<br/>==&gt;v[32]<br/># Cypher<br/>cypher&gt; MATCH (n:character {name:"jesus"}) SET n.type = 'titan';</span></pre><h2 id="6cf7" class="kx jv iq bd jw ky kz dn ka la lb dp ke lc ld le ki lf lg lh km li lj lk kq ll bi translated">获取/读取</h2><pre class="kt ku kv kw gt mo mp mq mr aw ms bi"><span id="b622" class="kx jv iq mp b gy mt mu l mv mw"># nGQL<br/>nebula&gt; FETCH PROP ON character hash("saturn");<br/>===================================================<br/>| character.name | character.age | character.type |<br/>===================================================<br/>| saturn         | 10000         | titan          |<br/>---------------------------------------------------<br/># Gremlin<br/>gremlin&gt; g.V(saturn).valueMap();<br/>==&gt;[name:[saturn],type:[titan],age:[10000]]<br/># Cypher<br/>cypher&gt; MATCH (n:character {name:"saturn"}) RETURN properties(n)<br/>  ╒════════════════════════════════════════════╕<br/>  │"properties(n)"                             │<br/>  ╞════════════════════════════════════════════╡<br/>  │{"name":"saturn","type":"titan","age":10000}│<br/>  └────────────────────────────────────────────┘</span></pre><h2 id="e787" class="kx jv iq bd jw ky kz dn ka la lb dp ke lc ld le ki lf lg lh km li lj lk kq ll bi translated">找到赫拉克勒斯父亲的名字</h2><pre class="kt ku kv kw gt mo mp mq mr aw ms bi"><span id="adcc" class="kx jv iq mp b gy mt mu l mv mw"># nGQL<br/>nebula&gt;  LOOKUP ON character WHERE character.name == 'hercules' | \<br/>      -&gt; GO FROM $-.VertexID OVER father YIELD $$.character.name;<br/>=====================<br/>| $$.character.name |<br/>=====================<br/>| jupiter           |<br/>---------------------<br/># Gremlin<br/>gremlin&gt; g.V().hasLabel('character').has('name','hercules').out('father').values('name');<br/>==&gt;jupiter<br/># Cypher<br/>cypher&gt; MATCH (src:character{name:"hercules"})-[:father]-&gt;(dst:character) RETURN dst.name<br/>      ╒══════════╕<br/>      │"dst.name"│<br/>      ╞══════════╡<br/>      │"jupiter" │<br/>      └──────────┘</span></pre><h2 id="57cd" class="kx jv iq bd jw ky kz dn ka la lb dp ke lc ld le ki lf lg lh km li lj lk kq ll bi translated">找到赫拉克勒斯祖父的名字</h2><pre class="kt ku kv kw gt mo mp mq mr aw ms bi"><span id="d828" class="kx jv iq mp b gy mt mu l mv mw"># nGQL<br/>nebula&gt; LOOKUP ON character WHERE character.name == 'hercules' | \<br/>     -&gt; GO 2 STEPS FROM $-.VertexID OVER father YIELD $$.character.name;<br/>=====================<br/>| $$.character.name |<br/>=====================<br/>| saturn            |<br/>---------------------<br/># Gremlin<br/>gremlin&gt; g.V().hasLabel('character').has('name','hercules').out('father').out('father').values('name');<br/>==&gt;saturn<br/># Cypher<br/>cypher&gt; MATCH (src:character{name:"hercules"})-[:father*2]-&gt;(dst:character) RETURN dst.name<br/>      ╒══════════╕<br/>      │"dst.name"│<br/>      ╞══════════╡<br/>      │"saturn"  │<br/>      └──────────┘</span></pre><h2 id="6bf2" class="kx jv iq bd jw ky kz dn ka la lb dp ke lc ld le ki lf lg lh km li lj lk kq ll bi translated">找出年龄大于100岁的人物</h2><pre class="kt ku kv kw gt mo mp mq mr aw ms bi"><span id="84db" class="kx jv iq mp b gy mt mu l mv mw"># nGQL<br/>nebula&gt; LOOKUP ON character WHERE character.age &gt; 100 YIELD character.name, character.age;<br/>=========================================================<br/>| VertexID             | character.name | character.age |<br/>=========================================================<br/>| 6761447489613431910  | pluto          | 4000          |<br/>---------------------------------------------------------<br/>| -5860788569139907963 | neptune        | 4500          |<br/>---------------------------------------------------------<br/>| 4863977009196259577  | jupiter        | 5000          |<br/>---------------------------------------------------------<br/>| -4316810810681305233 | saturn         | 10000         |<br/>---------------------------------------------------------<br/># Gremlin<br/>gremlin&gt; g.V().hasLabel('character').has('age',gt(100)).values('name');<br/>==&gt;saturn<br/>==&gt;jupiter<br/>==&gt;neptune<br/>==&gt;pluto<br/># Cypher<br/>cypher&gt; MATCH (src:character) WHERE src.age &gt; 100 RETURN src.name<br/>      ╒═══════════╕<br/>      │"src.name" │<br/>      ╞═══════════╡<br/>      │  "saturn" │<br/>      ├───────────┤<br/>      │ "jupiter" │<br/>      ├───────────┤<br/>      │ "neptune" │<br/>      │───────────│<br/>      │  "pluto"  │<br/>      └───────────┘</span></pre><h2 id="6ed8" class="kx jv iq bd jw ky kz dn ka la lb dp ke lc ld le ki lf lg lh km li lj lk kq ll bi translated">找出布鲁托的同居者，不包括布鲁托本人</h2><pre class="kt ku kv kw gt mo mp mq mr aw ms bi"><span id="f431" class="kx jv iq mp b gy mt mu l mv mw"># nGQL<br/>nebula&gt;  GO FROM hash("pluto") OVER lives YIELD lives._dst AS place | GO FROM $-.place OVER lives REVERSELY WHERE \<br/>$$.character.name != "pluto" YIELD $$.character.name AS cohabitants;<br/>===============<br/>| cohabitants |<br/>===============<br/>| cerberus    |<br/>---------------<br/># Gremlin<br/>gremlin&gt; g.V(pluto).out('lives').in('lives').where(is(neq(pluto))).values('name');<br/>==&gt;cerberus<br/># Cypher<br/>cypher&gt; MATCH (src:character{name:"pluto"})-[:lives]-&gt;()&lt;-[:lives]-(dst:character) RETURN dst.name<br/>      ╒══════════╕<br/>      │"dst.name"│<br/>      ╞══════════╡<br/>      │"cerberus"│<br/>      └──────────┘</span></pre><h2 id="4795" class="kx jv iq bd jw ky kz dn ka la lb dp ke lc ld le ki lf lg lh km li lj lk kq ll bi translated">布鲁托的兄弟</h2><pre class="kt ku kv kw gt mo mp mq mr aw ms bi"><span id="488f" class="kx jv iq mp b gy mt mu l mv mw"># which brother lives in which place?<br/>## nGQL<br/>nebula&gt; GO FROM hash("pluto") OVER brother YIELD brother._dst AS god | \<br/>GO FROM $-.god OVER lives YIELD $^.character.name AS Brother, $$.location.name AS Habitations;<br/>=========================<br/>| Brother | Habitations |<br/>=========================<br/>| jupiter | sky         |<br/>-------------------------<br/>| neptune | sea         |<br/>-------------------------<br/>## Gremlin<br/>gremlin&gt; g.V(pluto).out('brother').as('god').out('lives').as('place').select('god','place').by('name');<br/>==&gt;[god:jupiter, place:sky]<br/>==&gt;[god:neptune, place:sea]<br/>## Cypher<br/>cypher&gt; MATCH (src:Character{name:"pluto"})-[:brother]-&gt;(bro:Character)-[:lives]-&gt;(dst)<br/>RETURN bro.name, dst.name<br/>      ╒═════════════════════════╕<br/>      │"bro.name"    │"dst.name"│<br/>      ╞═════════════════════════╡<br/>      │ "jupiter"    │  "sky"   │<br/>      ├─────────────────────────┤<br/>      │ "neptune"    │ "sea"    │<br/>      └─────────────────────────┘</span></pre><p id="4cdd" class="pw-post-body-paragraph lm ln iq lo b lp mi lr ls lt mj lv lw lc mk ly lz lf ml mb mc li mm me mf mg ij bi translated">除了三种图形查询语言中的基本操作之外，我们还将研究这些语言中高级操作的另一个比较。敬请期待！</p></div></div>    
</body>
</html>