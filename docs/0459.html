<html>
<head>
<title>Dispatching Actions from Child Components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从子组件调度操作</h1>
<blockquote>原文：<a href="https://itnext.io/dispatching-actions-from-child-components-bd292a51f176?source=collection_archive---------0-----------------------#2018-03-13">https://itnext.io/dispatching-actions-from-child-components-bd292a51f176?source=collection_archive---------0-----------------------#2018-03-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/675fa1d0c5df15190f61fb593df2af4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-THkzJOGCB7vV7UTFpneMQ.jpeg"/></div></div></figure><div class=""/><p id="847a" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在React-Redux设置中，我们有使用connect注释连接到store的容器。该容器包含视图或其他子组件。子组件可以从视图向下n层。并且通常需要子组件来分派动作。</p><h2 id="90be" class="kw kx jb bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">我已经讨论了实现这一点的4种方法:</h2><ol class=""><li id="dbbb" class="lp lq jb ka b kb lr kf ls kj lt kn lu kr lv kv lw lx ly lz bi translated">直接方法(不太正确的方法…)</li><li id="0cef" class="lp lq jb ka b kb ma kf mb kj mc kn md kr me kv lw lx ly lz bi translated">通过调度功能作为道具(好吧，但仍然不是一个好主意..)</li><li id="e414" class="lp lq jb ka b kb ma kf mb kj mc kn md kr me kv lw lx ly lz bi translated">将回调函数传递给child(差不多了，但是稍后事情会变得混乱……)</li><li id="a287" class="lp lq jb ka b kb ma kf mb kj mc kn md kr me kv lw lx ly lz bi translated">带有枚举的单个回调函数(我建议的解决方案…)</li></ol><h2 id="0d46" class="kw kx jb bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated"><strong class="ak">直接进场</strong></h2><p id="4e03" class="pw-post-body-paragraph jy jz jb ka b kb lr kd ke kf ls kh ki kj mf kl km kn mg kp kq kr mh kt ku kv ij bi translated">因此，要从任何组件调度操作，您需要访问调度函数。因此，首先想到的是将connect注释放在子组件中，并分派操作。</p><figure class="mj mk ml mm gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mi"><img src="../Images/3bb0781d5bd8c31b2f04be0a230956da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nwBY-K3jd_TGCeq6IxjRBA.jpeg"/></div></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">直接从子组件调用动作</figcaption></figure><p id="2b13" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc">但是，有几个问题:</strong></p><ol class=""><li id="c1fb" class="lp lq jb ka b kb kc kf kg kj mr kn ms kr mt kv lw lx ly lz bi translated">子组件成为智能组件。</li><li id="feff" class="lp lq jb ka b kb ma kf mb kj mc kn md kr me kv lw lx ly lz bi translated">重用子组件变得很困难。</li><li id="efda" class="lp lq jb ka b kb ma kf mb kj mc kn md kr me kv lw lx ly lz bi translated">所有子组件都需要知道动作类型和redux存储结构</li><li id="2d71" class="lp lq jb ka b kb ma kf mb kj mc kn md kr me kv lw lx ly lz bi translated">让每个组件访问存储不是一个合适的react-redux架构。</li></ol></div><div class="ab cl mu mv hu mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="ij ik il im in"><h2 id="050b" class="kw kx jb bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">通过调度功能作为道具</h2><p id="8a22" class="pw-post-body-paragraph jy jz jb ka b kb lr kd ke kf ls kh ki kj mf kl km kn mg kp kq kr mh kt ku kv ij bi translated">将分派功能从容器传递到子功能可以解决让我们的每个子组件都成为智能组件的问题。</p><p id="56db" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc">T5】my container . jsxT7】</strong></p><pre class="mj mk ml mm gt nc nd ne nf aw ng bi"><span id="589f" class="kw kx jb nd b gy nh ni l nj nk">@connect(store =&gt; ({ myStore: store.myStore }))<br/>class MyContainer extends Component {</span><span id="ac84" class="kw kx jb nd b gy nl ni l nj nk">render() {<br/>    return (<br/>      &lt;MyComponent<br/>        <strong class="nd jc">dispatch={this.props.dispatch}</strong><br/>      /&gt;<br/>  }<br/>}</span></pre><p id="5003" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc"><em class="nb">my components . jsx</em></strong></p><pre class="mj mk ml mm gt nc nd ne nf aw ng bi"><span id="c47f" class="kw kx jb nd b gy nh ni l nj nk">class MyComponent extends Component {<br/>  static propTypes = {<br/>    dispatch: PropsTypes.func,<br/>  }</span><span id="4a75" class="kw kx jb nd b gy nl ni l nj nk">  onButtonClick = () = {<br/>    this.props.dispatch(MyActions.BUTTON_CLICKED, data);<br/>  }</span><span id="b481" class="kw kx jb nd b gy nl ni l nj nk">  render() {<br/>    return (<br/>      &lt;div&gt;<br/>        &lt;button onClick={this.onButtonClick}&gt;        <br/>        // implement component view<br/>      &lt;/div&gt;<br/>    )<br/>  }<br/>}</span></pre><figure class="mj mk ml mm gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nm"><img src="../Images/bc758ff4ccb3379865ca0c8cbba1feb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dIVc4mUYED52QkDswbChAg.jpeg"/></div></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">将分派直接传递给所有子动作和调用动作</figcaption></figure><p id="a715" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这种方法中，我们不再需要将子组件声明为智能组件，并且该组件可以重用，但是它仍然无法解决其他问题:</p><ol class=""><li id="fa22" class="lp lq jb ka b kb kc kf kg kj mr kn ms kr mt kv lw lx ly lz bi translated">子组件仍然需要知道redux结构和动作类型。</li><li id="5bd0" class="lp lq jb ka b kb ma kf mb kj mc kn md kr me kv lw lx ly lz bi translated">父节点将无法控制子节点的功能。</li></ol></div><div class="ab cl mu mv hu mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="ij ik il im in"><h2 id="c7ed" class="kw kx jb bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated"><strong class="ak">将回调函数传递给子组件</strong></h2><p id="09b8" class="pw-post-body-paragraph jy jz jb ka b kb lr kd ke kf ls kh ki kj mf kl km kn mg kp kq kr mh kt ku kv ij bi translated">牢记好的实践，我们应该只从容器中调用所有的动作。为此，我们可以将回调函数作为道具传递给子组件。所以每个子组件都有一个在prop-types中定义的回调函数列表。父节点可以将函数引用传递给子节点。</p><p id="4f80" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc"><em class="nb">my container . jsx</em></strong></p><pre class="mj mk ml mm gt nc nd ne nf aw ng bi"><span id="0cbe" class="kw kx jb nd b gy nh ni l nj nk">@connect(store =&gt; ({ myStore: store.myStore }))<br/>class MyContainer extends Component {</span><span id="4517" class="kw kx jb nd b gy nl ni l nj nk">  onTaskStart = (payload) =&gt; {<br/>    this.props.dispatch(MyActionTypes.TASK_START, payload);<br/>  }</span><span id="16b9" class="kw kx jb nd b gy nl ni l nj nk">  onTaskEnd = (payload) =&gt; {<br/>    this.props.dispatch(MyActionTypes.TASK_END, payload);<br/>  }</span><span id="5704" class="kw kx jb nd b gy nl ni l nj nk">  render() {<br/>    return (<br/>      &lt;MyComponent<br/>        <strong class="nd jc">onTaskStart={this.onTaskStart}<br/>        onTaskEnd={this.onTaskEnd}</strong><br/>      /&gt;<br/>  }<br/>}</span></pre><p id="2ff6" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc"><em class="nb">my component . jsx</em></strong></p><pre class="mj mk ml mm gt nc nd ne nf aw ng bi"><span id="e0f8" class="kw kx jb nd b gy nh ni l nj nk">class MyComponent extends Component {<br/>  static propTypes = {<br/>    onTaskStart: PropsTypes.func,<br/>    onTaskEnd: PropTypes.func,<br/>  }</span><span id="1d78" class="kw kx jb nd b gy nl ni l nj nk">  render() {<br/>    return (<br/>      &lt;div&gt;<br/>        // implement component view<br/>      &lt;/div&gt;<br/>    )<br/>  }<br/>}</span></pre><figure class="mj mk ml mm gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nn"><img src="../Images/31792c12524ec8e9ed275dc5c0c5e8ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wA0j_PxJ2qgSg0aZjNtOQA.jpeg"/></div></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">将每个动作的回调函数分别从容器传递给子动作</figcaption></figure><p id="beac" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这给了我们一些优势</p><ol class=""><li id="1be7" class="lp lq jb ka b kb kc kf kg kj mr kn ms kr mt kv lw lx ly lz bi translated">子组件可以通过其属性类型清楚地指定它向父组件公开的所有任务或功能。</li><li id="8c15" class="lp lq jb ka b kb ma kf mb kj mc kn md kr me kv lw lx ly lz bi translated">孩子不需要担心动作的功能或调用哪个动作。</li><li id="8fac" class="lp lq jb ka b kb ma kf mb kj mc kn md kr me kv lw lx ly lz bi translated">父母可以选择实现或忽略某些功能。</li><li id="dea4" class="lp lq jb ka b kb ma kf mb kj mc kn md kr me kv lw lx ly lz bi translated">子组件可以根据需要使用prop-type来强制实现某些功能。</li></ol><p id="601e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">虽然这有时是大多数开发人员的首选方法，但您很快就会遇到一些明显的缺点:</p><ol class=""><li id="54c2" class="lp lq jb ka b kb kc kf kg kj mr kn ms kr mt kv lw lx ly lz bi translated">随着功能的增加，将如此多的函数引用从容器传递到子组件看起来很糟糕。</li><li id="168d" class="lp lq jb ka b kb ma kf mb kj mc kn md kr me kv lw lx ly lz bi translated">当子组件超过一层或两层时，想象通过所有层传递所有的函数引用属性。</li><li id="fa7a" class="lp lq jb ka b kb ma kf mb kj mc kn md kr me kv lw lx ly lz bi translated">在一个内部子组件中添加一个功能需要将容器中的所有组件更改为该子组件文件。对于任何中等规模的项目容器来说，孩子可以很容易地超过3级，到这个时候，你已经敲你的头或放弃。</li></ol></div><div class="ab cl mu mv hu mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="ij ik il im in"><h2 id="a92d" class="kw kx jb bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">带有枚举的单个回调函数</h2><p id="f25f" class="pw-post-body-paragraph jy jz jb ka b kb lr kd ke kf ls kh ki kj mf kl km kn mg kp kq kr mh kt ku kv ij bi translated">查看以前的实现，我想提出一个解决方案，它具有像调度一样的单个函数回调的优点，并且将控制权交给父组件，同时不需要进行太多的代码更改来在任何子组件中添加新功能。我是这样实现的:</p><p id="c42f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc">T3】my container . jsxT5】</strong></p><pre class="mj mk ml mm gt nc nd ne nf aw ng bi"><span id="7e48" class="kw kx jb nd b gy nh ni l nj nk">@connect(store =&gt; ({ myStore: store.myStore }))<br/>class MyContainer extends Component {</span><span id="4378" class="kw kx jb nd b gy nl ni l nj nk">  <strong class="nd jc">callbackHandler = (type, data) =&gt; {<br/>    switch(type) {<br/>      // will come to back to this later on<br/>    }<br/>  }</strong></span><span id="d1e9" class="kw kx jb nd b gy nl ni l nj nk">  render() {<br/>    return (<br/>      &lt;<strong class="nd jc">MyMainView</strong><br/>        <strong class="nd jc">callbackHanlder={this.callbackHandler}</strong><br/>      /&gt;<br/>    }<br/>  }<br/>}</span></pre><p id="dd6d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">MyContainer连接到存储并访问调度功能。它不是传递分派函数本身，而是传递一个函数引用callbackHandler()。</p><p id="a7e3" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc"> <em class="nb"> MyMainView.jsx </em> </strong></p><pre class="mj mk ml mm gt nc nd ne nf aw ng bi"><span id="d692" class="kw kx jb nd b gy nh ni l nj nk">import { <br/>  CALLBACK_ENUMS,<br/>}, ChildComponent from './MyChildComponent.jsx';</span><span id="eb1c" class="kw kx jb nd b gy nl ni l nj nk">// merged list of all possible enums, also from child<br/><strong class="nd jc">const VIEW_CALLBACK_ENUMS = {<br/>  ...CALLBACK_ENUMS,<br/>  MAIN_VIEW_TASK: 'MY_MAIN_VIEW/MAIN_VIEW_TASK',<br/>};</strong></span><span id="9641" class="kw kx jb nd b gy nl ni l nj nk">class MyMainView extends Component {</span><span id="9043" class="kw kx jb nd b gy nl ni l nj nk">  // handle only the requst from the child compoenents<br/>  // it either choose to bubble to the parent or choose to stop the request<br/>  // it can manipulate the data passed to parent if required.<br/>  <br/>  <strong class="nd jc">viewCallBackHandler = (type, data) =&gt; {<br/>    switch(type) {<br/>      case CALLBACK_ENUMS.CHILD_MAIN_TASK:<br/>        </strong>// manipulate data if required<strong class="nd jc"><br/>        this.props.callbackHandler(type, data);<br/>        break;</strong></span><span id="de21" class="kw kx jb nd b gy nl ni l nj nk"><strong class="nd jc">      case CALLBACK_ENUMS.CHILD_SECONDARY_TASK:<br/>        </strong>// choose to ignore this action<strong class="nd jc"><br/>        break;</strong></span><span id="196c" class="kw kx jb nd b gy nl ni l nj nk"><strong class="nd jc">      default:<br/>        </strong>// bubble up all other actions to parent<strong class="nd jc"><br/>        this.props.callbackHandler(type, data);<br/>      }<br/>  };</strong></span><span id="45c0" class="kw kx jb nd b gy nl ni l nj nk">  onViewButtonClick = () =&gt; {<br/>    this.props.callbackHandler(<br/>      VIEW_CALLBACK_ENUMS.MAIN_VIEW_TASK,<br/>      data,<br/>    );<br/>  };</span><span id="0c1d" class="kw kx jb nd b gy nl ni l nj nk">render() {<br/>    return (<br/>      &lt;div&gt;<br/>        &lt;Button <br/>          onClick={this.onViewButtonClick}<br/>        &gt;<br/>          Main Container Button<br/>        &lt;/Button&gt;<br/>        &lt;ChildCompoenent <br/>          <strong class="nd jc">callbackHandler={this.viewCallBackHandler}</strong><br/>          // callbackHandler={this.props.callbackHandler}<br/>          // if parent need not filter out child's requests<strong class="nd jc"> </strong><br/>        /&gt; <br/>      &lt;/div&gt;<br/>    )<br/>  }<br/>}</span><span id="cde5" class="kw kx jb nd b gy nl ni l nj nk">export default MyMainView;<br/>export {<br/>  VIEW_CALLBACK_ENUMS as CALLBACK_ENUMS,<br/>};</span></pre><p id="887a" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">MyMainView可以包含子组件以及它自己的具有功能的视图。viewCallbackHandler充当子容器和父容器之间的中间过滤器。它是可选的，可以删除。在这种情况下，props中的callbackHandler可以直接传递给孩子。这个过滤函数可以在将数据传递给父对象之前处理数据，甚至可以选择忽略某些请求。默认情况下，此函数中未显式处理的任何请求都会传递给父级。所有请求都可以由类型唯一标识，该类型是在组件本身中描述的枚举。</p><p id="6ea7" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里要注意的另一件事是VIEW_CALLBACK_ENUMS如何合并子元素及其自身的所有enum。这确保了所有级别的所有子组件的所有枚举都被合并并传递到父容器。</p><p id="7cf4" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc"><em class="nb">mychildcomponent . jsx</em></strong></p><pre class="mj mk ml mm gt nc nd ne nf aw ng bi"><span id="de06" class="kw kx jb nd b gy nh ni l nj nk">// list of all possible enums in child<br/><strong class="nd jc">const VIEW_CALLBACK_ENUMS = {<br/>  CHILD_MAIN_TASK: 'MY_CHILD/CHILD_MAIN_TASK',<br/>  CHILD_SECONDARY_TASK: 'MY_CHILD/CHILD_SECONDARY_TASK',<br/>};</strong></span><span id="107f" class="kw kx jb nd b gy nl ni l nj nk">class MyChildComponent extends Component {</span><span id="ca34" class="kw kx jb nd b gy nl ni l nj nk">  onMainButtonClick = () =&gt; {<br/>    <strong class="nd jc">this.props.callbackHandler(<br/>      VIEW_CALLBACK_ENUMS.CHILD_MAIN_TASK,<br/>      data,<br/>    );</strong><br/>  };</span><span id="b958" class="kw kx jb nd b gy nl ni l nj nk">  onSecondaryButtonClick = () =&gt; {<br/>    <strong class="nd jc">this.props.callbackHandler(<br/>      VIEW_CALLBACK_ENUMS.CHILD_SECONDARY_TASK,<br/>      data,<br/>    );</strong><br/>  };</span><span id="01e7" class="kw kx jb nd b gy nl ni l nj nk">  render() {<br/>    return (<br/>      &lt;div&gt;<br/>        &lt;Button <br/>          onClick={this.onMainButtonClick}<br/>        &gt;<br/>          Child Main Button<br/>        &lt;/Button&gt;<br/>        &lt;Button <br/>          onClick={this.onSecondaryButtonClick}<br/>        &gt;<br/>          Child Secondary Button<br/>        &lt;/Button&gt;<br/>      &lt;/div&gt;<br/>    )<br/>  }<br/>}</span><span id="550f" class="kw kx jb nd b gy nl ni l nj nk">export default MyChildComponent;<br/>export {<br/>  VIEW_CALLBACK_ENUMS as CALLBACK_ENUMS,<br/>};</span></pre><p id="83da" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">MyChildComponent只导出了自己的一组枚举。所有动作都由props中的callbackHandler函数处理。子节点不需要知道父节点如何处理这些动作，也不需要知道redux结构或任何动作类型。</p><p id="c099" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">MyChildComponent只是一个可重用的视图组件，它的所有操作都由函数callbackHandler作为props传递，所有功能类型都作为枚举导出。</p><p id="0eb6" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc"> <em class="nb">现在让我们回到MyContainer.jsx callbackHandler函数:</em> </strong></p><pre class="mj mk ml mm gt nc nd ne nf aw ng bi"><span id="49e8" class="kw kx jb nd b gy nh ni l nj nk">import { CALLBACK_ENUMS }, MyMainView from './MyMainView.jsx';</span><span id="6d92" class="kw kx jb nd b gy nl ni l nj nk">// ...</span><span id="d9a7" class="kw kx jb nd b gy nl ni l nj nk">callbackHandler = (type, data) =&gt; {<br/>  switch(type) {<br/>     case CALLBACK_ENUMS.CHILD_MAIN_TASK:<br/>        this.props.dispatch(MyActions.childMainTask(data);<br/>        break;<strong class="nd jc"><br/></strong><br/>     case CALLBACK_ENUMS.MAIN_VIEW_TASK:<br/>        this.props.dispatch(MyActions.childMainTask(data);<br/>        break;</span><span id="3074" class="kw kx jb nd b gy nl ni l nj nk">  }<br/>}</span></pre><figure class="mj mk ml mm gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi no"><img src="../Images/ea2de633893a2a701d0be0f17917cb94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LZXqVuDxEma5bU0B3t9mYQ.jpeg"/></div></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">将一个回调函数从容器向下传递给所有子容器</figcaption></figure><p id="f642" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你想知道优势吗？</p><ol class=""><li id="2eff" class="lp lq jb ka b kb kc kf kg kj mr kn ms kr mt kv lw lx ly lz bi translated">子组件现在是哑组件，不需要知道redux结构或动作类型。</li><li id="9f91" class="lp lq jb ka b kb ma kf mb kj mc kn md kr me kv lw lx ly lz bi translated">子组件可以在任何地方轻松重用，因为它们不依赖于任何严格的动作类型。</li><li id="3bd9" class="lp lq jb ka b kb ma kf mb kj mc kn md kr me kv lw lx ly lz bi translated">如果你想添加一个功能到下三层的子容器中，你只需要在子容器和主容器中进行修改。只要不想过滤或操纵动作数据，所有的中间级别都不必担心。</li><li id="dddb" class="lp lq jb ka b kb ma kf mb kj mc kn md kr me kv lw lx ly lz bi translated">父组件可以选择对来自子组件的任何预处理或阻止操作进行过滤。</li><li id="0725" class="lp lq jb ka b kb ma kf mb kj mc kn md kr me kv lw lx ly lz bi translated">父容器可以跟踪从它的视图传递的所有动作。</li><li id="89f9" class="lp lq jb ka b kb ma kf mb kj mc kn md kr me kv lw lx ly lz bi translated">父容器可以从所有级别访问其子容器的所有枚举。因此，我们可以很容易地了解这个视图实现了哪些功能。</li><li id="3ede" class="lp lq jb ka b kb ma kf mb kj mc kn md kr me kv lw lx ly lz bi translated">所有动作最终只能从容器中调度。世界终于又好了！！！</li></ol><h2 id="b786" class="kw kx jb bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">结论</h2><p id="add1" class="pw-post-body-paragraph jy jz jb ka b kb lr kd ke kf ls kh ki kj mf kl km kn mg kp kq kr mh kt ku kv ij bi translated">在一个中等规模的项目中，这种方法非常适合我。特别是在添加新功能时会变得非常混乱，这种方法只需要在两个文件中进行更改。它把所有的动作调用放在一个地方，用枚举和所有子组件的适当公开的功能来保持代码的整洁。</p></div></div>    
</body>
</html>