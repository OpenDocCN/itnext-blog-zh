<html>
<head>
<title>Chat in 30 minutes with ReactNative and Firebase, seriously! Pt. 2.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在30分钟内与ReactNative和Firebase聊天，认真！角。2.</h1>
<blockquote>原文：<a href="https://itnext.io/chat-in-30-minutes-with-reactnative-and-firebase-seriously-pt-2-1994d2401774?source=collection_archive---------2-----------------------#2019-05-03">https://itnext.io/chat-in-30-minutes-with-reactnative-and-firebase-seriously-pt-2-1994d2401774?source=collection_archive---------2-----------------------#2019-05-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/c0c0a0111993520240f1337c07766c9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JRZMtQogufnpFUTVWJYnFg.jpeg"/></div></div></figure></div><div class="ab cl jy jz hu ka" role="separator"><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd"/></div><div class="ij ik il im in"><p id="3238" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated"><em class="ld">结语。</em></p><p id="9689" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">之前我们为我们的聊天创建了标记，你可以在这里找到文章<a class="ae le" href="https://medium.com/@andriidrozdov/chat-in-30-minutes-with-reactnative-and-firebase-seriously-pt-1-1712a18f7c8a" rel="noopener"/>。现在，我们将绑定我们的标记并安装带有逻辑的Firebase包。</p></div><div class="ab cl jy jz hu ka" role="separator"><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd"/></div><div class="ij ik il im in"><h1 id="55ce" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">第四集。简单聊天教程前情提要。</h1><p id="031a" class="pw-post-body-paragraph kf kg iq kh b ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky mh la lb lc ij bi translated">我们的目标:</p><figure class="mj mk ml mm gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mi"><img src="../Images/ffe5f0df8dad18e4ee3ee35df851bc7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*pCV152ky-64BfMF8eZvFEg.gif"/></div></div></figure><p id="fadc" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">小，提醒一下，这是我们的项目结构:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="8f0c" class="ms lg iq mo b gy mt mu l mv mw">|- /SimpleChat<br/>|  |- /src<br/>|  |  |- /components<br/>|  |  |  |- /common<br/>|  |  |  |  |- /Button<br/>|  |  |  |  |  |- /index.js<br/>|  |  |  |  |  |- /styles.js<br/>|  |  |  |  |- /Loader<br/>|  |  |  |  |  |- /index.js<br/>|  |  |  |  |  |- /styles.js<br/>|  |  |  |- /HooksExample<br/>|  |  |  |  |- /index.js<br/>|  |  |  |  |- /reducers.js<br/>|  |  |  |- /Input<br/>|  |  |  |  |- /index.js<br/>|  |  |  |  |- /styles.js<br/>|  |  |  |- /Message<br/>|  |  |  |  |- /index.js<br/>|  |  |  |  |- /styles.js<br/>|  |  |- /constants<br/>|  |  |  |- /collection.js<br/>|  |  |  |- /index.js<br/>|  |  |- /services<br/>|  |  |  |- /index.js<br/>|  |  |  |- /FirebaseService.js<br/>|  |  |- /styles<br/>|  |  |  |- /chat-room.js<br/>|  |  |  |- /colors.js<br/>|  |  |  |- /index.js<br/>|  |  |- /index.js<br/>|  |  |- /contexts.js</span></pre><p id="261a" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">如果您尚未完成标记，请<a class="ae le" href="https://medium.com/@andriidrozdov/chat-in-30-minutes-with-reactnative-and-firebase-seriously-pt-1-1712a18f7c8a" rel="noopener">导航至第1部分</a>，并执行以下操作:)</p></div><div class="ab cl jy jz hu ka" role="separator"><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd"/></div><div class="ij ik il im in"><h1 id="f741" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">第五集。FirebaseService。</h1><p id="3f17" class="pw-post-body-paragraph kf kg iq kh b ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky mh la lb lc ij bi translated">现在，我们将创建您的主类来与Firebase应用程序进行通信。</p><p id="c7a3" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">在<code class="fe mx my mz mo b">/constants/collections.js</code>中定义我们的系列:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="d3c1" class="ms lg iq mo b gy mt mu l mv mw"><em class="ld">export default </em>{<br/>  MESSAGES: 'messages'<br/>}</span></pre><p id="c558" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">并在<code class="fe mx my mz mo b">/constants/index.js</code>中导出以便于访问:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="003a" class="ms lg iq mo b gy mt mu l mv mw"><em class="ld">export </em>COLLECTIONS <em class="ld">from </em>'./collections'</span></pre><p id="ae46" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">现在我们准备实施<code class="fe mx my mz mo b">FirebaseService.js</code>:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="577b" class="ms lg iq mo b gy mt mu l mv mw"><em class="ld">import </em>firebase <em class="ld">from </em>'react-native-firebase'<br/><em class="ld">import </em>{ COLLECTIONS } <em class="ld">from </em>'../constants'<br/><br/><em class="ld">export default class </em>FirebaseService {<br/>  auth = firebase.auth()<br/><br/>  firestore = firebase.firestore()<br/><br/>  messageRef = <em class="ld">this</em>.firestore.collection(COLLECTIONS.MESSAGES);<br/><br/>  <em class="ld">async </em>signIn () {<br/>    <em class="ld">try </em>{<br/>      <em class="ld">const </em>response = <em class="ld">await this</em>.auth.signInAnonymously()<br/>      <em class="ld">return </em>{ user: response.user }<br/>    } <em class="ld">catch </em>(error) {<br/>      <em class="ld">return </em>{ error }<br/>    }<br/>  }<br/><br/>  <em class="ld">async </em>fetchMessages () {<br/>    <em class="ld">const </em>messages = <em class="ld">await this</em>.messageRef<br/>      .orderBy('created_at', 'desc')<br/>      .limit(10)<br/>      .get()<br/><br/>    <em class="ld">return </em>messages.docs<br/>  }<br/><br/>  <em class="ld">async </em>createMessage ({ message, uid }) {<br/>    <em class="ld">await this</em>.messageRef.add({<br/>      message,<br/>      user_id: uid,<br/>      created_at: <em class="ld">new </em>Date()<br/>    })<br/>  }<br/>}</span></pre><p id="e6c4" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">让我向您介绍一下代码:</p><p id="570a" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated"><code class="fe mx my mz mo b">auth = firebase.auth()</code>和<code class="fe mx my mz mo b">firestore = firebase.firestore()</code>即使引擎盖下的Firebase库缓存<code class="fe mx my mz mo b">auth()</code>和<code class="fe mx my mz mo b">firestore()</code>初始化实例我最好还是把实例保存到变量里，以防万一。</p><p id="acb3" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">由于我们只有一个集合，我缓存了集合的路径，只是为了避免每次都调用查询构建器。</p><p id="91af" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated"><code class="fe mx my mz mo b">signIn</code> —也许在您的应用程序中，您不需要登录，因为在真实的项目中，您可能拥有自己的授权。在这种情况下，我只是进行匿名授权，只是为了获取用户的唯一UID，在Firebase集合中标识用户。</p><p id="35d2" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated"><code class="fe mx my mz mo b">fetchMessages</code> —按特定顺序获取最后10条消息的功能。我们需要这个顺序来保证信息在聊天中的适当位置。我们将消息限制在10条以内有两个目的:</p><ol class=""><li id="8946" class="na nb iq kh b ki kj km kn kq nc ku nd ky ne lc nf ng nh ni bi translated">我们将把它作为初始载荷</li><li id="f188" class="na nb iq kh b ki nj km nk kq nl ku nm ky nn lc nf ng nh ni bi translated">我们只是确保，然后我们将获取新消息并过滤旧消息，以防web套接字没有传递一些消息(是的，在引擎盖下，Firebase使用web套接字进行服务器到客户端的通信)。</li></ol><p id="7b20" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated"><code class="fe mx my mz mo b">createMessage</code> —创建消息的功能。请注意，我使用的UID是通过Firebase登录方法检索的，如果您有一个真正的后端来使用您的数据库<code class="fe mx my mz mo b">user_id</code>，并且您的奇怪后端人员可以从后端访问用户消息，这将是一个很好的例子。</p><p id="553b" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">现在导出我们的类，<strong class="kh ir">不要忘记</strong>初始化我们的<code class="fe mx my mz mo b">FirebaseService</code>类的一个新实例:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="3426" class="ms lg iq mo b gy mt mu l mv mw"><em class="ld">import </em>FirebaseService <em class="ld">from </em>'./FirebaseService'<br/><br/><em class="ld">const </em>firebaseService = <em class="ld">new </em>FirebaseService()<br/><br/><em class="ld">export </em>{<br/>  firebaseService<br/>}</span></pre></div><div class="ab cl jy jz hu ka" role="separator"><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd"/></div><div class="ij ik il im in"><h1 id="ecd4" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">第六集。用户上下文。</h1><p id="7943" class="pw-post-body-paragraph kf kg iq kh b ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky mh la lb lc ij bi translated">你可以在这里阅读上下文。基本上就是一种不用每次手动传递道具就可以通过树传递道具的方式。</p><p id="652c" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">现在，我们将在boot上创建一个用户或者用<code class="fe mx my mz mo b">Firebase.auth()</code>在数据库中找到它，如果你已经有了后端，你可以跳过这个教程，如果没有，你知道:)</p><p id="9286" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">我们需要在<code class="fe mx my mz mo b">src</code>文件夹下创建一个新文件，命名为<code class="fe mx my mz mo b">contexts.js</code>:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="c827" class="ms lg iq mo b gy mt mu l mv mw"><em class="ld">import </em>{ createContext } <em class="ld">from </em>'react'<br/><br/><em class="ld">export const </em>UserContext = createContext(<em class="ld">null</em>)</span></pre><p id="d5dc" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">我们需要将它导入到我们的根<code class="fe mx my mz mo b">/src/index.js</code>文件中，并且我们需要确保我们的州中有UID。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="bbde" class="ms lg iq mo b gy mt mu l mv mw"><em class="ld">import </em>React, { useState, useEffect } <em class="ld">from </em>'react'<br/><em class="ld">import </em>{ Alert } <em class="ld">from </em>'react-native'<br/><br/><em class="ld">import </em>Loader <em class="ld">from </em>'./components/common/Loader'<br/><em class="ld">import </em>HooksExample <em class="ld">from </em>'./components/HooksExample'<br/><br/><em class="ld">import </em>{ UserContext } <em class="ld">from </em>'./contexts'<br/><em class="ld">import </em>{ firebaseService } <em class="ld">from </em>'./services'<br/><br/><em class="ld">export default function </em>App () {<br/>  <em class="ld">const </em>[user, setUser] = useState(<em class="ld">null</em>)<br/><br/>  useEffect(<br/>    <em class="ld">function </em>() {<br/>      firebaseService.signIn()<br/>        .then(({ user, error }) =&gt; {<br/>          <em class="ld">if </em>(error) {<br/>            Alert.alert('Something went wrong')<br/>            <em class="ld">return<br/>          </em>}<br/><br/>          setUser(user)<br/>        })<br/>    },<br/>    [<em class="ld">false</em>]<br/>  )<br/><br/>  <em class="ld">if </em>(!user) {<br/>    <em class="ld">return </em>&lt;Loader /&gt;<br/>  }<br/><br/>  <em class="ld">return </em>(<br/>    &lt;UserContext.Provider <em class="ld">value</em>={user}&gt;<br/>      &lt;HooksExample /&gt;<br/>    &lt;/UserContext.Provider&gt;<br/>  )<br/>}</span></pre><p id="0dd4" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated"><em class="ld">注意:钩子不能异步，所以我们需要使用</em> <code class="fe mx my mz mo b"><em class="ld">then</em></code> <em class="ld">函数来解析我们的承诺。因为我们已经构建了一个包装器，所以我们不需要</em> <code class="fe mx my mz mo b"><em class="ld">catch</em></code> <em class="ld">块，因为我们确保我们的</em> <code class="fe mx my mz mo b"><em class="ld">FirebaseSerivce.signIn</em></code> <em class="ld">将只成功解析承诺。</em></p></div><div class="ab cl jy jz hu ka" role="separator"><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd"/></div><div class="ij ik il im in"><h1 id="4f1f" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">第七集。消息创建。</h1><p id="476f" class="pw-post-body-paragraph kf kg iq kh b ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky mh la lb lc ij bi translated">我们已经构建了<code class="fe mx my mz mo b">Input</code>组件，我们需要用逻辑填充它:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="5930" class="ms lg iq mo b gy mt mu l mv mw"><em class="ld">import </em>React, { useCallback, useState, useContext } <em class="ld">from </em>'react'<br/><em class="ld">import </em>{ View, TextInput } <em class="ld">from </em>'react-native'<br/><br/><em class="ld">import </em>{ firebaseService } <em class="ld">from </em>'../../services'<br/><em class="ld">import </em>{ UserContext } <em class="ld">from </em>'../../contexts'<br/><br/><em class="ld">import </em>Button <em class="ld">from </em>'../common/Button'<br/><em class="ld">import </em>Loader <em class="ld">from </em>'../common/Loader'<br/><br/><em class="ld">import </em>styles <em class="ld">from </em>'./styles'<br/><br/><em class="ld">export default function </em>Input () {<br/>  <em class="ld">const </em>{ uid } = useContext(UserContext)<br/>  <em class="ld">const </em>[isLoading, setIsLoading] = useState(<em class="ld">false</em>)<br/>  <em class="ld">const </em>[message, setMessage] = useState('')<br/><br/>  <em class="ld">const </em>handlePress = useCallback(<br/>    <em class="ld">function </em>() {<br/>      setIsLoading(<em class="ld">true</em>)<br/>      firebaseService<br/>        .createMessage({ message, uid })<br/>        .then(<em class="ld">function </em>() {<br/>          setIsLoading(<em class="ld">false</em>)<br/>          setMessage('')<br/>        })<br/>    },<br/>    [message]<br/>  )<br/><br/>  <em class="ld">return </em>(<br/>    &lt;View <em class="ld">style</em>={styles.container}&gt;<br/>      &lt;View <em class="ld">style</em>={styles.inputContainer}&gt;<br/>        &lt;TextInput <em class="ld">style</em>={styles.input} <em class="ld">value</em>={message} <em class="ld">onChangeText</em>={setMessage} <em class="ld">placeholder</em>="Write you message" /&gt;<br/>      &lt;/View&gt;<br/><br/>      &lt;Button <em class="ld">text</em>="Send" <em class="ld">onPress</em>={handlePress} <em class="ld">disabled</em>={isLoading} /&gt;<br/><br/>      {isLoading &amp;&amp; &lt;Loader /&gt;}<br/>    &lt;/View&gt;<br/>  )<br/>}</span></pre><p id="b9bb" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">让我向您介绍一下代码:</p><p id="7a3b" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated"><code class="fe mx my mz mo b">useContext(UserContext)</code> —我们用特殊的钩子<code class="fe mx my mz mo b">useContext</code>告诉React我们想要使用我们之前在根<code class="fe mx my mz mo b">index.js</code>中定义的上下文。如果我们使用一个类组件，我们需要创建一个特殊的函数来访问类组件中的上下文:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="1e68" class="ms lg iq mo b gy mt mu l mv mw"><em class="ld">static </em>contextType = UserContext;</span></pre><p id="8a58" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">现在我们将能够使用<code class="fe mx my mz mo b">this.context</code>访问我们的用户。</p><p id="d1da" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated"><code class="fe mx my mz mo b">isLoading</code>状态值只是阻止我们的按钮被双击的一种方式。</p><p id="5170" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated"><code class="fe mx my mz mo b">message</code> —是我们从<code class="fe mx my mz mo b">TextInput</code>接收的字符串。</p><p id="d716" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">这是我们的媒体处理员。这里我们调用我们的<code class="fe mx my mz mo b">FirebaseService</code>来创建一个消息。我们需要用<code class="fe mx my mz mo b">then</code>解析承诺，以避免React钩子中的<code class="fe mx my mz mo b">async</code>函数。</p></div><div class="ab cl jy jz hu ka" role="separator"><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd"/></div><div class="ij ik il im in"><h1 id="381e" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">第八集。获取和订阅消息。</h1><p id="b921" class="pw-post-body-paragraph kf kg iq kh b ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky mh la lb lc ij bi translated">现在我们可以创建新消息了，让我们更新我们的<code class="fe mx my mz mo b">HooksExample</code>组件(在<code class="fe mx my mz mo b">HooksExample</code>文件夹中的<code class="fe mx my mz mo b">index.js</code>文件):</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="22c0" class="ms lg iq mo b gy mt mu l mv mw"><em class="ld">import </em>React, { useEffect, useReducer, useContext } <em class="ld">from </em>'react'<br/><em class="ld">import </em>{ FlatList, SafeAreaView, View } <em class="ld">from </em>'react-native'<br/><br/><em class="ld">import </em>{ firebaseService } <em class="ld">from </em>'../../services'<br/><em class="ld">import </em>{ UserContext } <em class="ld">from </em>'../../contexts'<br/><br/><em class="ld">import </em>Input <em class="ld">from </em>'../Input'<br/><em class="ld">import </em>Message <em class="ld">from </em>'../Message'<br/><br/><em class="ld">import </em>{ messagesReducer } <em class="ld">from </em>'./reducers'<br/><em class="ld">import </em>{ chatRoomStyles <em class="ld">as </em>styles } <em class="ld">from </em>'../../styles'<br/><br/><em class="ld">export default function </em>HooksExample () {<br/>  <em class="ld">const </em>{ uid } = useContext(UserContext)<br/>  <em class="ld">const </em>[messages, dispatchMessages] = useReducer(messagesReducer, [])<br/><br/>  useEffect(<br/>    <em class="ld">function </em>() {<br/>      <em class="ld">return </em>firebaseService.messageRef<br/>        .orderBy('created_at', 'desc')<br/>        .onSnapshot(<em class="ld">function </em>(snapshot) {<br/>          dispatchMessages({ type: 'add', payload: snapshot.docs })<br/>        })<br/>    },<br/>    [<em class="ld">false</em>]<br/>  )<br/><br/>  <em class="ld">return </em>(<br/>    &lt;SafeAreaView&gt;<br/>      &lt;View <em class="ld">style</em>={styles.messagesContainer}&gt;<br/>        &lt;FlatList<br/>          <em class="ld">inverted<br/>          data</em>={messages}<br/>          <em class="ld">keyExtractor</em>={<em class="ld">function </em>(item) {<br/>            <em class="ld">return </em>item.id<br/>          }}<br/>          <em class="ld">renderItem</em>={<em class="ld">function </em>({ item }) {<br/>            <em class="ld">const </em>data = item.data()<br/>            <em class="ld">const </em>side = data.user_id === uid ? 'right' : 'left'<br/><br/>            <em class="ld">return </em>(<br/>              &lt;Message <em class="ld">side</em>={side} <em class="ld">message</em>={data.message} /&gt;<br/>            )<br/>          }}<br/>        /&gt;<br/>      &lt;/View&gt;<br/><br/>      &lt;View <em class="ld">style</em>={styles.inputContainer}&gt;<br/>        &lt;Input /&gt;<br/>      &lt;/View&gt;<br/>    &lt;/SafeAreaView&gt;<br/>  )<br/>}</span></pre><p id="5cb9" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">并立即创建<code class="fe mx my mz mo b">reducers.js</code>:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="c6bd" class="ms lg iq mo b gy mt mu l mv mw"><em class="ld">import </em>{ unionWith } <em class="ld">from </em>'lodash'<br/><br/><em class="ld">export function </em>messagesReducer (state, action) {<br/>  <em class="ld">switch </em>(action.type) {<br/>    <em class="ld">case </em>'add':<br/>      <em class="ld">return </em>unionWith(state, action.payload, <em class="ld">function </em>(a, b) {<br/>        <em class="ld">return </em>a.id === b.id<br/>      }).sort(<em class="ld">function </em>(a, b) {<br/>        <em class="ld">const </em>aData = a.data()<br/>        <em class="ld">const </em>bData = b.data()<br/><br/>        <em class="ld">return </em>bData.created_at.seconds - aData.created_at.seconds<br/>      })<br/>    <em class="ld">default</em>:<br/>      <em class="ld">throw new </em>Error('Action type is not implemented!')<br/>  }<br/>}</span></pre><p id="f8d9" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">让我们浏览一下代码，从我们的<code class="fe mx my mz mo b">reducers.js</code>文件开始。你可以在这里阅读更多关于<code class="fe mx my mz mo b">useReducer</code><a class="ae le" href="https://reactjs.org/docs/hooks-reference.html#usereducer" rel="noopener ugc nofollow" target="_blank"/>。基本上，这是一个我们放置复杂逻辑的钩子方式。</p><p id="fed3" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">这里我使用<code class="fe mx my mz mo b">lodash</code>函数<code class="fe mx my mz mo b">unionWith</code>从两个数组中只获取唯一的消息，然后进行排序，以防我们的联合会破坏正确的顺序。</p><p id="e6de" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated"><code class="fe mx my mz mo b">useEffect</code> —你可以称之为生命周期法。你可以在这里阅读更多<a class="ae le" href="https://reactjs.org/docs/hooks-reference.html#useeffect" rel="noopener ugc nofollow" target="_blank"/>。当组件第一次挂载时，这个函数将被调用，我们将订阅更改并获取订阅时的最后10条消息记录。</p><p id="05ca" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated"><strong class="kh ir">重要提示:</strong>在<code class="fe mx my mz mo b">useEffect</code>中，我们返回我们的监听器，这一步需要在组件卸载时取消订阅。</p><p id="a8aa" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">现在，转到我们的<code class="fe mx my mz mo b">FlatList</code>:</p><ol class=""><li id="d7ba" class="na nb iq kh b ki kj km kn kq nc ku nd ky ne lc nf ng nh ni bi translated">从底部开始物品是<code class="fe mx my mz mo b">inverted</code></li><li id="835d" class="na nb iq kh b ki nj km nk kq nl ku nm ky nn lc nf ng nh ni bi translated"><code class="fe mx my mz mo b">data</code> —是我们的消息数组</li><li id="f571" class="na nb iq kh b ki nj km nk kq nl ku nm ky nn lc nf ng nh ni bi translated"><code class="fe mx my mz mo b">keyExtrator</code> — uniq键，在我们的例子中是<code class="fe mx my mz mo b">Firebase</code>记录ID</li><li id="75cd" class="na nb iq kh b ki nj km nk kq nl ku nm ky nn lc nf ng nh ni bi translated">组件呈现之前的小逻辑<code class="fe mx my mz mo b">item.data()</code>——是一种检索记录字段的方法。然后我们检查该消息是否属于当前用户，如果消息属于当前用户，我们将<code class="fe mx my mz mo b">side</code> prop作为<code class="fe mx my mz mo b">right</code>传递，否则我们将它作为<code class="fe mx my mz mo b">left</code>传递</li></ol></div><div class="ab cl jy jz hu ka" role="separator"><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd"/></div><div class="ij ik il im in"><p id="b144" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">如果你做的一切都是正确的，你会收到一个完整的工作聊天。恭喜你。</p></div><div class="ab cl jy jz hu ka" role="separator"><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd"/></div><div class="ij ik il im in"><p id="42a9" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated"><em class="ld">开场白。</em></p><p id="5c7f" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">如你所见，一切都很简单，不需要任何奇怪的后端人员，开发速度快，易于维护。</p><p id="f022" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated"><a class="ae le" href="https://github.com/tech-by-andrii/chat-in-30-minutes-with-react-native-and-firebase" rel="noopener ugc nofollow" target="_blank"> <em class="ld">链接到知识库。</em>T29】</a></p><p id="c29d" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated"><em class="ld">存储库中的项目已经有了一个安装Firebase应用程序，您可以克隆这个存储库并进行试验。</em></p><p id="5d75" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated"><strong class="kh ir">关注我了解更多！</strong></p></div></div>    
</body>
</html>