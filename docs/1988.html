<html>
<head>
<title>Infinite component scrolling with React.lazy and IntersectionObserver</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用React.lazy和IntersectionObserver进行无限组件滚动</h1>
<blockquote>原文：<a href="https://itnext.io/infinite-component-scrolling-with-react-lazy-and-intersectionobserver-7774c03b08f2?source=collection_archive---------0-----------------------#2019-03-08">https://itnext.io/infinite-component-scrolling-with-react-lazy-and-intersectionobserver-7774c03b08f2?source=collection_archive---------0-----------------------#2019-03-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/198a6581167d94facbcf6949e0b050da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nFPLbURDxgYzJZpTf_CutA.jpeg"/></div></div></figure><div class=""/><p id="b892" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在之前的<a class="ae kz" rel="noopener ugc nofollow" target="_blank" href="/infinite-scrolling-dynamic-module-loading-the-intersection-observer-api-1f17186c7a8d">帖子</a>中，我简要地写了如何使用IntersectionObserver API进行分析和动态模块加载，但是我没有提供任何具体的例子。在这篇文章中，我想实际展示如何用这个相当新的API实现上述目标。</p><p id="7aef" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd jf">免责声明:</strong>这里我使用React与<a class="ae kz" href="https://webpack.js.org/guides/code-splitting/" rel="noopener ugc nofollow" target="_blank"> Webpack </a>一起使用，但同样可以在Vue以及Angular和其他捆绑器如<a class="ae kz" href="https://parceljs.org/code_splitting.html" rel="noopener ugc nofollow" target="_blank"> parcel.js </a>中实现。</p><p id="8d1b" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最近，React发布了版本<a class="ae kz" href="https://github.com/facebook/react/blob/master/CHANGELOG.md#1663-november-12-2018" rel="noopener ugc nofollow" target="_blank"> 16.6.3 </a>，该版本为我们提供了开箱即用的代码拆分支持，尽管对服务器端渲染的支持不可用，并且有其他实现，但出于我们的目的，我们将使用React.lazy和React . junction。关于API细节的更多细节可以参考<a class="ae kz" href="https://reactjs.org/docs/code-splitting.html#reactlazy" rel="noopener ugc nofollow" target="_blank">此处</a>。</p><p id="79ae" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于那些不熟悉代码分割或在运行时动态加载模块的人来说，理解这样做的主要目的之一是允许开发人员将他们的代码库分割成更小的块，通常由关注点、路径或功能来分隔。按路线划分应用程序是向用户发送较小的包的良好开端，反过来，只根据单个用户的需求向用户发送代码。如果他们从来没有访问过你的应用程序的一部分，无论是出于选择还是出于某种约束，比如权限限制，那么他们不会因为交互时间变慢或数据传输受限而受到惩罚。</p><p id="e2bc" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">React文档对优势的解释如下…</p><blockquote class="la lb lc"><p id="e1a7" class="kb kc ld kd b ke kf kg kh ki kj kk kl le kn ko kp lf kr ks kt lg kv kw kx ky im bi translated">对你的应用进行代码拆分可以帮助你“延迟加载”用户当前需要的东西，这可以极大地提高你的应用的性能。虽然你没有减少应用程序中的总代码量，但你避免了加载用户可能永远不需要的代码，并减少了初始加载期间所需的代码量。</p></blockquote></div><div class="ab cl lh li hx lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="im in io ip iq"><p id="1fab" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">那么，非基于路径或页面的代码分割的实际用例如何呢？当用户在应用程序中导航单个视图或路径时，我们如何动态加载代码呢？</p><p id="fbc3" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在我目前的公司<a class="ae kz" href="http://fanai.io/" rel="noopener ugc nofollow" target="_blank"> FanAI </a>，我们遇到了一个使用积极模块加载的用例，它帮助我们加快了应用程序的性能，并允许我们推迟大量的前期计算。我们发现，随着我们的应用程序增长，并继续变得更加复杂，我们的长滚动视图，其中包含许多不同的数据可视化，开始感到非常缓慢。大多数可视化效果都位于文件夹之下，并不总是与用户交互。此外，许多可视化调用各种api端点来获取数据，并且当这些api响应被解析并且可视化被呈现时，它们都在竞争动画和布局改变。</p><p id="acbb" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">随着React的加入。我们现在能够按需加载这些不同的可视化，但大多数例子只是使用基于路径的加载或基于用户的动作来触发动态导入。我们需要一种在用户浏览单个视图时拉入代码的方法，更确切地说，是一种在用户滚动时加载代码的方法。这就是我们能够实现和利用IntersectionObserver api的地方。</p></div><div class="ab cl lh li hx lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="im in io ip iq"><p id="ef98" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用React.lazy和React实现动态代码拆分。悬念是相当直截了当的，<a class="ae kz" href="https://reactjs.org/docs/code-splitting.html#reactlazy" rel="noopener ugc nofollow" target="_blank">文档</a>更深入地阐述了这个主题，但一个非常简单的实现可以实现如下:</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="409e" class="lx ly je lt b gy lz ma l mb mc">const OtherComponent = React.lazy(() =&gt; import('./OtherComponent'));<br/><br/>function MyComponent() {<br/>  return (<br/>    &lt;div&gt;<br/>      &lt;Suspense fallback={&lt;div&gt;Loading...&lt;/div&gt;}&gt;<br/>        &lt;OtherComponent /&gt;<br/>      &lt;/Suspense&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre><p id="e2ae" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">上面的代码使用React.lazy，它将一个函数作为唯一的输入，该函数调用一个动态导入，然后该动态导入返回一个解析为包含React组件的模块的承诺。</p><p id="c19e" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">好了，现在让我们进入我们建造的细节。在下面的代码片段中，我们只是在进行设置。我们将默认的相交状态设置为false，创建一个ref，它稍后将被用作<a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API#Creating_an_intersection_observer" rel="noopener ugc nofollow" target="_blank">目标</a>元素，在其中观察与根元素相关的相交。如果没有指定或者如果<code class="fe md me mf lt b">null</code>，根元素又默认为浏览器视窗。</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="9996" class="lx ly je lt b gy lz ma l mb mc">state = {<br/>  hasIntersected: false<br/>};</span><span id="29c7" class="lx ly je lt b gy mg ma l mb mc">targetContainerRef = React.createRef();</span><span id="ef70" class="lx ly je lt b gy mg ma l mb mc">options = {<br/>  root: this.props.root || null,<br/>  rootMargin: this.props.margin || "0px",<br/>  threshold: this.props.threshold || 0<br/>};</span><span id="5d01" class="lx ly je lt b gy mg ma l mb mc">observer;</span></pre><p id="af78" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来我们设置我们的订阅，当交集发生时，它将调用我们的回调<code class="fe md me mf lt b">this.load</code>:</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="cdf3" class="lx ly je lt b gy lz ma l mb mc">componentDidMount() {<br/>  this.observer = new IntersectionObserver(this.load, this.options);<br/>  this.observer.observe(this.targetContainerRef.current);<br/>}</span><span id="9175" class="lx ly je lt b gy mg ma l mb mc">componentWillUnmount() {<em class="ld"><br/>  </em>this.observer.unobserve(this.targetContainerRef.current);<br/>}</span></pre><p id="ab4f" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最后，当观察到交叉事件时，我们告诉观察者实际要做什么。我们的第一个条件告诉观察者，一旦出现交叉路口，就停止倾听。这就是我们想要的动态模块加载。</p><p id="284a" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当您希望在每次触发交叉点事件时触发回调时，第二个条件非常有用。我们用它来无限加载图像和搜索结果，因为这允许我们对后端服务进行额外的调用，例如每次用户滚动到列表底部时。对于第二个场景，唯一需要记住的是，您可能需要跟踪滚动的方向，因为您可能只想在相交发生在特定方向时触发回调。</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="8a28" class="lx ly je lt b gy lz ma l mb mc">load = (entries) =&gt; {</span><span id="a89c" class="lx ly je lt b gy mg ma l mb mc">  const { onIntersection, continueObserving } = this.props;</span><span id="1a14" class="lx ly je lt b gy mg ma l mb mc"><em class="ld">  </em>if (!continueObserving &amp;&amp; !this.state.hasIntersected) {<br/>    const entry = <br/>      entries.find(<br/>        entry =&gt; entry.target === this.targetContainerRef.current<br/>      );</span><span id="11ab" class="lx ly je lt b gy mg ma l mb mc">    if (entry &amp;&amp; entry.isIntersecting) {<br/>      this.setState({ hasIntersected: true });<br/>      onIntersection &amp;&amp; onIntersection(entries);<em class="ld"><br/>      </em>this.observer.unobserve(this.targetContainerRef.current);<br/>    }<em class="ld"><br/>  </em>} else if (continueObserving &amp;&amp; onIntersection) {<br/>      onIntersection(entries);<br/>  }<br/>};</span></pre><p id="2cbb" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们需要将IntersectionObserver组件与React.Suspense结合使用。</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="da15" class="lx ly je lt b gy lz ma l mb mc">&lt;IntersectionObserver&gt;<br/>  &lt;DynamicModule<br/>    placeholder={&lt;Placeholder /&gt;}<br/>    component={() =&gt; import("./path/to/asyncComponent")}<br/>  /&gt;<br/>&lt;/IntersectionObserver&gt;</span></pre><p id="1910" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">上面的代码包装了一个组件，该组件在挂载时调用组件函数prop。当交集发生时，我们的<code class="fe md me mf lt b">&lt;IntersectionObserver /&gt;</code>组件只在内部呈现其子组件。当这种情况发生时，<br/> <code class="fe md me mf lt b">&lt;DynamicModule /&gt;</code>组件在挂载时会在内部执行以下操作:</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="8e62" class="lx ly je lt b gy lz ma l mb mc">componentDidMount() {<br/>  this.setState({<br/>    Component: lazy(this.props.component),<br/>    initializing: true<br/>  });<br/>}</span></pre><p id="a946" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">上面的代码利用了React.lazy api，然后它在运行时拉入我们的组件，这只有在用户将该组件滚动到视图中时才会发生！要体验这些组件并了解更多细节，请查看下面的codesandbox。</p><figure class="lo lp lq lr gt iv"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="bdf5" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">除了上面的例子，如果你想看看无限滚动如何与<code class="fe md me mf lt b">&lt;IntersectionObserver /&gt;</code>组件一起工作，你可以简单地把它附加到你的可滚动容器的底部，并传递给它一个onIntersection()回调和一个设置为true的continueObserving属性，如果你想在每次<code class="fe md me mf lt b">&lt;IntersectionObserver /&gt;</code>与你的根元素相交时触发一个回调。</p><p id="d5e7" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">通过实现上述组件，我们能够推迟工作，这反过来又加快了我们的初始页面加载时间，因为我们交付的包要小得多。此外，它提高了应用程序的感知性能，因为我们只在实际需要时加载单个组件模块，而且因为这些模块依赖于外部数据服务，所以模块块的加载和来自API的异步响应配合得非常好。对于用户来说，这似乎是一回事，他们无法察觉模块的加载和api解析的加载状态之间的差异。这对我们来说是双赢，更重要的是对我们的用户来说！</p><p id="3929" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我希望以上有意义，为了我和整个社区的利益，请随时提供任何反馈。编码快乐！🙌 🙌 🙌</p></div></div>    
</body>
</html>