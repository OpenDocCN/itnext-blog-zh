<html>
<head>
<title>Using an Angular Directive to Extend a Third-Party Component</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用角度指令扩展第三方组件</h1>
<blockquote>原文：<a href="https://itnext.io/using-an-angular-directive-to-extend-a-third-party-component-39f0f46a4e0?source=collection_archive---------4-----------------------#2021-09-06">https://itnext.io/using-an-angular-directive-to-extend-a-third-party-component-39f0f46a4e0?source=collection_archive---------4-----------------------#2021-09-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="14b2" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">我增加了模式切换到一个原始日历！🤘</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/bcc0aa1b8ca01ac0830fe700757a2d31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*A_IJ_SGmv3le0kQGiGfJZw.jpeg"/></div><figcaption class="kn ko gj gh gi kp kq bd b be z dk translated">图片来源:<a class="ae kr" href="https://petapixel.com/2016/02/25/dogs-trained-studio-photographers/" rel="noopener ugc nofollow" target="_blank">千万亿像素</a></figcaption></figure><h1 id="fae4" class="ks kt iq bd ku kv kw kx ky kz la lb lc jw ld jx le jz lf ka lg kc lh kd li lj bi translated">挑战</h1><p id="3361" class="pw-post-body-paragraph lk ll iq lm b ln lo jr lp lq lr ju ls lt lu lv lw lx ly lz ma mb mc md me mf ij bi translated">我最近有一个需求，需要在页面上添加一个日期选择器，允许用户选择单个日期或日期范围。</p><p id="2915" class="pw-post-body-paragraph lk ll iq lm b ln mg jr lp lq mh ju ls lt mi lv lw lx mj lz ma mb mk md me mf ij bi translated">在我们的应用程序中，我们已经使用了<a class="ae kr" href="https://www.primefaces.org/primeng/showcase/#/calendar" rel="noopener ugc nofollow" target="_blank"> PrimeNG Calendar </a>组件，该组件具有一个<code class="fe ml mm mn mo b">selectionMode</code>属性，用于配置datepicker以接受单个日期、多个日期或一个日期范围。</p><p id="5951" class="pw-post-body-paragraph lk ll iq lm b ln mg jr lp lq mh ju ls lt mi lv lw lx mj lz ma mb mk md me mf ij bi translated">遗憾的是，该组件没有提供一种内置的方式来切换模式。</p><p id="dfb4" class="pw-post-body-paragraph lk ll iq lm b ln mg jr lp lq mh ju ls lt mi lv lw lx mj lz ma mb mk md me mf ij bi translated">是时候发挥创造力了！🤔</p><h1 id="7b83" class="ks kt iq bd ku kv kw kx ky kz la lb lc jw ld jx le jz lf ka lg kc lh kd li lj bi translated">目标</h1><p id="2712" class="pw-post-body-paragraph lk ll iq lm b ln lo jr lp lq lr ju ls lt lu lv lw lx ly lz ma mb mc md me mf ij bi translated">日历组件如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/6ca01ce8a976f3ca1dc9d940da3a3385.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*Mvi2_DshMHeAMOEhKyfkpA.png"/></div></figure><p id="c9ed" class="pw-post-body-paragraph lk ll iq lm b ln mg jr lp lq mh ju ls lt mi lv lw lx mj lz ma mb mk md me mf ij bi translated">我认为页脚按钮栏是放置模式开关的完美地方。所以我的目标变成了这样:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/e51eda1d3d8233fb387023db10a971a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*KyMpJJu9O7zt2I10uODKEA.png"/></div></figure><h1 id="5c08" class="ks kt iq bd ku kv kw kx ky kz la lb lc jw ld jx le jz lf ka lg kc lh kd li lj bi translated">方法</h1><p id="7df9" class="pw-post-body-paragraph lk ll iq lm b ln lo jr lp lq lr ju ls lt lu lv lw lx ly lz ma mb mc md me mf ij bi translated">因为我需要操作DOM，所以一个<a class="ae kr" href="https://angular.io/api/core/Directive" rel="noopener ugc nofollow" target="_blank">指令</a>似乎是这项工作的合适工具。</p><p id="1d98" class="pw-post-body-paragraph lk ll iq lm b ln mg jr lp lq mh ju ls lt mi lv lw lx mj lz ma mb mk md me mf ij bi translated">这是我开始使用的模板:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="1073" class="pw-post-body-paragraph lk ll iq lm b ln mg jr lp lq mh ju ls lt mi lv lw lx mj lz ma mb mk md me mf ij bi translated">下一个决定:如何以及在哪里定义我将插入到日历中的自定义日期和日期范围按钮？</p><h2 id="b23a" class="ms kt iq bd ku mt mu dn ky mv mw dp lc lt mx my le lx mz na lg mb nb nc li nd bi translated">选项</h2><p id="360b" class="pw-post-body-paragraph lk ll iq lm b ln lo jr lp lq lr ju ls lt lu lv lw lx ly lz ma mb mc md me mf ij bi translated">我想到了两个选择:</p><ol class=""><li id="1c74" class="ne nf iq lm b ln mg lq mh lt ng lx nh mb ni mf nj nk nl nm bi translated">在模板中将它们定义为HTML，并让指令从那里引用它们</li><li id="61f8" class="ne nf iq lm b ln nn lq no lt np lx nq mb nr mf nj nk nl nm bi translated">使用<a class="ae kr" href="https://angular.io/api/core/Renderer2" rel="noopener ugc nofollow" target="_blank">渲染器</a>在指令类中以编程方式创建它们</li></ol><p id="c5db" class="pw-post-body-paragraph lk ll iq lm b ln mg jr lp lq mh ju ls lt mi lv lw lx mj lz ma mb mk md me mf ij bi translated">使用选项#1，为按钮构建标记会更干净、更容易(至少在我看来——当使用标记时，我通常更喜欢在。html文件)。</p><p id="c2f1" class="pw-post-body-paragraph lk ll iq lm b ln mg jr lp lq mh ju ls lt mi lv lw lx mj lz ma mb mk md me mf ij bi translated">但是对于选项#2，该指令将更加独立，您可以将它附加到整个应用程序的多个模板中的<code class="fe ml mm mn mo b">p-calendar</code>实例，而不需要在每个模板中添加额外的按钮标记来支持它。</p><h2 id="f10f" class="ms kt iq bd ku mt mu dn ky mv mw dp lc lt mx my le lx mz na lg mb nb nc li nd bi translated">第一次切割:选项1</h2><p id="dc0a" class="pw-post-body-paragraph lk ll iq lm b ln lo jr lp lq lr ju ls lt lu lv lw lx ly lz ma mb mc md me mf ij bi translated">对于我的第一次切割，我选择了选项#1，这也是本文将要介绍的内容。</p><p id="d15d" class="pw-post-body-paragraph lk ll iq lm b ln mg jr lp lq mh ju ls lt mi lv lw lx mj lz ma mb mk md me mf ij bi translated">我选择了那个选项，因为在我的情况下，我们有自己的自定义Angular wrapper组件围绕着<code class="fe ml mm mn mo b">p-calendar</code>，并且那个自定义组件是在整个应用程序中被实例化的，而不是<code class="fe ml mm mn mo b">p-calendar</code>，所以我可以只在那个自定义组件的模板中定义按钮标记，而不必再做一次。</p><p id="75e5" class="pw-post-body-paragraph lk ll iq lm b ln mg jr lp lq mh ju ls lt mi lv lw lx mj lz ma mb mk md me mf ij bi translated">然而，我后来也实现了选项#2，只是为了启发自己，看看它是如何比较的。两个实现的链接(以及我后来想到的使用组件和CDK门户的第三个实现！)都在文末。</p><h1 id="2925" class="ks kt iq bd ku kv kw kx ky kz la lb lc jw ld jx le jz lf ka lg kc lh kd li lj bi translated">实施</h1><p id="b9d9" class="pw-post-body-paragraph lk ll iq lm b ln lo jr lp lq lr ju ls lt lu lv lw lx ly lz ma mb mc md me mf ij bi translated">下面是自定义包装组件模板中定义的按钮标记的样子，就在<code class="fe ml mm mn mo b">p-calendar</code>旁边:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="92d0" class="pw-post-body-paragraph lk ll iq lm b ln mg jr lp lq mh ju ls lt mi lv lw lx mj lz ma mb mk md me mf ij bi translated">在第4行，我将指令<code class="fe ml mm mn mo b">calendarModeToggle</code>附加到<code class="fe ml mm mn mo b">p-calendar</code>上，并向其中传递了对按钮包装元素<code class="fe ml mm mn mo b">modeToggle</code>的引用。</p><p id="59f8" class="pw-post-body-paragraph lk ll iq lm b ln mg jr lp lq mh ju ls lt mi lv lw lx mj lz ma mb mk md me mf ij bi translated">我将按钮包装在一个<code class="fe ml mm mn mo b">div</code>中，其中包含一个用于必要样式的<code class="fe ml mm mn mo b">style</code>标签，将标记和样式放在一个地方。</p><p id="4744" class="pw-post-body-paragraph lk ll iq lm b ln mg jr lp lq mh ju ls lt mi lv lw lx mj lz ma mb mk md me mf ij bi translated">我将那个包装器<code class="fe ml mm mn mo b">div</code>放在一个HTML <code class="fe ml mm mn mo b"><a class="ae kr" href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/template" rel="noopener ugc nofollow" target="_blank">template</a></code>标签中，这样它就可以通过一个<a class="ae kr" href="https://angular.io/guide/template-reference-variables" rel="noopener ugc nofollow" target="_blank">模板引用变量</a>被指令访问，但不会呈现在页面上。</p><p id="9681" class="pw-post-body-paragraph lk ll iq lm b ln mg jr lp lq mh ju ls lt mi lv lw lx mj lz ma mb mk md me mf ij bi translated">最后，我将模板引用变量<code class="fe ml mm mn mo b">#modeToggle</code>附加到包装器<code class="fe ml mm mn mo b">div</code>上，这样我就可以将引用传递到指令中。</p><h1 id="8693" class="ks kt iq bd ku kv kw kx ky kz la lb lc jw ld jx le jz lf ka lg kc lh kd li lj bi translated">指令设置</h1><p id="1ca7" class="pw-post-body-paragraph lk ll iq lm b ln lo jr lp lq lr ju ls lt lu lv lw lx ly lz ma mb mc md me mf ij bi translated">下面是指令类的样子，将包装器<code class="fe ml mm mn mo b">div</code>作为输入:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="e464" class="pw-post-body-paragraph lk ll iq lm b ln mg jr lp lq mh ju ls lt mi lv lw lx mj lz ma mb mk md me mf ij bi translated">如果您不熟悉这种模式…如果您的指令使用属性选择器，并且您为该指令创建了一个与选择器同名的<code class="fe ml mm mn mo b">@Input()</code>(在本例中为<code class="fe ml mm mn mo b">calendarModeToggle</code>)，您可以将该指令附加到一个元素<em class="ns">上，然后</em>在一个方便的步骤中向其传递一些东西，就像我们在<code class="fe ml mm mn mo b">p-calendar</code>上所做的那样:</p><pre class="kg kh ki kj gt nt mo nu nv aw nw bi"><span id="1409" class="ms kt iq mo b gy nx ny l nz oa">[calendarModeToggle]="modeToggle"</span></pre><h1 id="d2c8" class="ks kt iq bd ku kv kw kx ky kz la lb lc jw ld jx le jz lf ka lg kc lh kd li lj bi translated">插入自定义按钮</h1><p id="3a64" class="pw-post-body-paragraph lk ll iq lm b ln lo jr lp lq lr ju ls lt lu lv lw lx ly lz ma mb mc md me mf ij bi translated">既然指令已经控制了<code class="fe ml mm mn mo b">div.toggle-wrapper</code>，下一步就是让它将这些按钮插入到日历的按钮栏中。</p><p id="dddf" class="pw-post-body-paragraph lk ll iq lm b ln mg jr lp lq mh ju ls lt mi lv lw lx mj lz ma mb mk md me mf ij bi translated">这就是DOM操纵发挥作用的地方！</p><p id="68f8" class="pw-post-body-paragraph lk ll iq lm b ln mg jr lp lq mh ju ls lt mi lv lw lx mj lz ma mb mk md me mf ij bi translated">日历组件的按钮栏如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="oc od di oe bf of"><div class="gh gi ob"><img src="../Images/953be97aeebfce20afb16d92e860d65e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JK79w9P54gKZz5XCEvbJTA.png"/></div></div></figure><p id="d7ea" class="pw-post-body-paragraph lk ll iq lm b ln mg jr lp lq mh ju ls lt mi lv lw lx mj lz ma mb mk md me mf ij bi translated">为了在今天和清除按钮之间插入我的切换按钮，我转向Angular的<a class="ae kr" href="https://angular.io/api/core/Renderer2" rel="noopener ugc nofollow" target="_blank">渲染器2 </a>。</p><h2 id="34da" class="ms kt iq bd ku mt mu dn ky mv mw dp lc lt mx my le lx mz na lg mb nb nc li nd bi translated">收听日期选择器节目</h2><p id="5485" class="pw-post-body-paragraph lk ll iq lm b ln lo jr lp lq lr ju ls lt lu lv lw lx ly lz ma mb mc md me mf ij bi translated">由于日历的datepicker并不总是显示——仅当控件被选中时——指令需要挂钩到日历的<code class="fe ml mm mn mo b">onShow</code>事件，并在每次显示datepicker时插入自定义按钮。</p><p id="fd1e" class="pw-post-body-paragraph lk ll iq lm b ln mg jr lp lq mh ju ls lt mi lv lw lx mj lz ma mb mk md me mf ij bi translated">为此，我们将日历实例注入到指令的构造函数中，并订阅它的<code class="fe ml mm mn mo b">onShow</code>事件:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="6edd" class="pw-post-body-paragraph lk ll iq lm b ln mg jr lp lq mh ju ls lt mi lv lw lx mj lz ma mb mk md me mf ij bi translated">当显示datepicker时，我们调用指令的<code class="fe ml mm mn mo b">addToggleButtonToButtonBar()</code>方法，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="9248" class="pw-post-body-paragraph lk ll iq lm b ln mg jr lp lq mh ju ls lt mi lv lw lx mj lz ma mb mk md me mf ij bi translated">注意，该方法首先检查<code class="fe ml mm mn mo b">this.buttons</code>是否已经存在。</p><p id="0bc5" class="pw-post-body-paragraph lk ll iq lm b ln mg jr lp lq mh ju ls lt mi lv lw lx mj lz ma mb mk md me mf ij bi translated">这是因为，即使在单击日历和选择日期时，日历组件的datepicker部分被插入或从DOM中删除，日历组件本身仍然存在，因此我们的指令也是如此——该指令不会在每次显示datepicker时重新实例化。</p><p id="97fc" class="pw-post-body-paragraph lk ll iq lm b ln mg jr lp lq mh ju ls lt mi lv lw lx mj lz ma mb mk md me mf ij bi translated">因此，我们只需要<em class="ns">定义</em>按钮<em class="ns">一次</em>，但是每次显示日期选择器时，我们都需要<em class="ns">将它们重新插入到按钮栏<em class="ns">中。</em></em></p><h1 id="15a8" class="ks kt iq bd ku kv kw kx ky kz la lb lc jw ld jx le jz lf ka lg kc lh kd li lj bi translated">赋予按钮权力</h1><p id="5c5b" class="pw-post-body-paragraph lk ll iq lm b ln lo jr lp lq lr ju ls lt lu lv lw lx ly lz ma mb mc md me mf ij bi translated">接下来，我需要连接按钮点击，这样他们就可以改变日历选择模式。</p><p id="6e0b" class="pw-post-body-paragraph lk ll iq lm b ln mg jr lp lq mh ju ls lt mi lv lw lx mj lz ma mb mk md me mf ij bi translated">为此，我使用了Render2的<code class="fe ml mm mn mo b"><a class="ae kr" href="https://angular.io/api/core/Renderer2#listen" rel="noopener ugc nofollow" target="_blank">listen</a></code>方法:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="73f1" class="pw-post-body-paragraph lk ll iq lm b ln mg jr lp lq mh ju ls lt mi lv lw lx mj lz ma mb mk md me mf ij bi translated"><code class="fe ml mm mn mo b">listen</code>方法返回一个“unlisten”函数来释放处理程序。我将那些“未被监听”的函数存储在一个名为<code class="fe ml mm mn mo b">stopListening</code>的数组中，这样当指令被销毁时我就可以调用它们，以免导致内存泄漏。👼</p><p id="efc3" class="pw-post-body-paragraph lk ll iq lm b ln mg jr lp lq mh ju ls lt mi lv lw lx mj lz ma mb mk md me mf ij bi translated">点击监听器调用指示方法<code class="fe ml mm mn mo b">setMode</code>，传入选中的模式和对点击按钮的引用。<code class="fe ml mm mn mo b">setMode</code>方法看起来像这样:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="743f" class="pw-post-body-paragraph lk ll iq lm b ln mg jr lp lq mh ju ls lt mi lv lw lx mj lz ma mb mk md me mf ij bi translated">我们显式地将日历的<code class="fe ml mm mn mo b">selectionMode</code>设置为选中模式，然后向选中的按钮添加一个CSS类，这样我们就可以高亮显示它。</p><p id="648d" class="pw-post-body-paragraph lk ll iq lm b ln mg jr lp lq mh ju ls lt mi lv lw lx mj lz ma mb mk md me mf ij bi translated">对于按钮点击，可选的第三个参数<code class="fe ml mm mn mo b">clearSelection</code>被设置为<code class="fe ml mm mn mo b">true</code>，以便当我们改变模式时，我们清除任何当前的日期选择。(您很快就会明白为什么这是一个默认为<code class="fe ml mm mn mo b">false</code>的可选标志。)</p><h1 id="568d" class="ks kt iq bd ku kv kw kx ky kz la lb lc jw ld jx le jz lf ka lg kc lh kd li lj bi translated">棘手的考虑</h1><p id="007d" class="pw-post-body-paragraph lk ll iq lm b ln lo jr lp lq lr ju ls lt lu lv lw lx ly lz ma mb mc md me mf ij bi translated">在实现过程中出现了几个棘手的场景:</p><ul class=""><li id="6c9e" class="ne nf iq lm b ln mg lq mh lt ng lx nh mb ni mf og nk nl nm bi translated">如果你已经导航到不同的月份或年份，改变模式会触发用户不友好的跳转到当前月份，要求你重新导航回到你所在的位置</li><li id="d126" class="ne nf iq lm b ln nn lq no lt np lx nq mb nr mf og nk nl nm bi translated">在日期范围模式下单击“今天”按钮无法正常工作，因为它是单个日期</li></ul><h2 id="ae7d" class="ms kt iq bd ku mt mu dn ky mv mw dp lc lt mx my le lx mz na lg mb nb nc li nd bi translated">不友好地跳转到当前月份</h2><p id="c794" class="pw-post-body-paragraph lk ll iq lm b ln lo jr lp lq lr ju ls lt lu lv lw lx ly lz ma mb mc md me mf ij bi translated">当改变模式时，指令触发当前日期选择的清除。这种清除又会导致日历组件触发跳转到当前月份，这是不可取的。所以我需要解决这个问题。</p><p id="7ff1" class="pw-post-body-paragraph lk ll iq lm b ln mg jr lp lq mh ju ls lt mi lv lw lx mj lz ma mb mk md me mf ij bi translated">该指令的<code class="fe ml mm mn mo b">clearDateSelection</code>方法在模式改变时被调用，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="444a" class="pw-post-body-paragraph lk ll iq lm b ln mg jr lp lq mh ju ls lt mi lv lw lx mj lz ma mb mk md me mf ij bi translated">它只是使用日历组件的<code class="fe ml mm mn mo b">writeValue</code>方法，传递给它<code class="fe ml mm mn mo b">null</code>来清除任何选择的值。</p><p id="326c" class="pw-post-body-paragraph lk ll iq lm b ln mg jr lp lq mh ju ls lt mi lv lw lx mj lz ma mb mk md me mf ij bi translated">那是简单的部分！</p><p id="3f2c" class="pw-post-body-paragraph lk ll iq lm b ln mg jr lp lq mh ju ls lt mi lv lw lx mj lz ma mb mk md me mf ij bi translated">棘手的部分来了，当我注意到，如果我已经改变到一个不同的月份，然后<em class="ns">改变模式，我会自动回到当前月份。不是很友好的用户体验。</em></p><p id="c865" class="pw-post-body-paragraph lk ll iq lm b ln mg jr lp lq mh ju ls lt mi lv lw lx mj lz ma mb mk md me mf ij bi translated">所以我不得不钻研日历的源代码来找出如何防止这种情况。</p><h2 id="49b1" class="ms kt iq bd ku mt mu dn ky mv mw dp lc lt mx my le lx mz na lg mb nb nc li nd bi translated">撤消跳转到当前月份</h2><p id="1e40" class="pw-post-body-paragraph lk ll iq lm b ln lo jr lp lq lr ju ls lt lu lv lw lx ly lz ma mb mc md me mf ij bi translated">事实证明，没有办法在不修改源代码的情况下<em class="ns">阻止</em>它，但是有一种方法可以使用日历的<code class="fe ml mm mn mo b">createMonths</code>方法立即<em class="ns">撤销</em>它，该方法设置当前显示的月/年。</p><p id="fdda" class="pw-post-body-paragraph lk ll iq lm b ln mg jr lp lq mh ju ls lt mi lv lw lx mj lz ma mb mk md me mf ij bi translated">所以现在，在清除选择的日期之前，我将当前选择的月份和年份存储在本地变量中。我从日历的<code class="fe ml mm mn mo b">currentMonth</code>和<code class="fe ml mm mn mo b">currentYear</code>属性中得到这些。</p><p id="e3d6" class="pw-post-body-paragraph lk ll iq lm b ln mg jr lp lq mh ju ls lt mi lv lw lx mj lz ma mb mk md me mf ij bi translated">然后，在清除之后，我会查看这些日历属性是否发生了变化。如果有，我就调用日历的<code class="fe ml mm mn mo b">createMonths</code>方法，恢复之前选择的月份和年份，完全不影响用户。💪 🤓</p><h2 id="3589" class="ms kt iq bd ku mt mu dn ky mv mw dp lc lt mx my le lx mz na lg mb nb nc li nd bi translated">点击今天按钮</h2><p id="4706" class="pw-post-body-paragraph lk ll iq lm b ln lo jr lp lq lr ju ls lt lu lv lw lx ly lz ma mb mc md me mf ij bi translated">需要处理的最后一件棘手的事情是单击Today按钮。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/f3d150d7e500b672c7ec2d3fa3de9e00.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*kXynpAS_XdQpNFjyR4n-9A.png"/></div></figure><p id="37e8" class="pw-post-body-paragraph lk ll iq lm b ln mg jr lp lq mh ju ls lt mi lv lw lx mj lz ma mb mk md me mf ij bi translated">如果在日历处于日期范围模式时单击了“今天”按钮，我们需要切换到日期模式。</p><p id="988c" class="pw-post-body-paragraph lk ll iq lm b ln mg jr lp lq mh ju ls lt mi lv lw lx mj lz ma mb mk md me mf ij bi translated">方便的是，日历组件公开了一个我们可以订阅的<code class="fe ml mm mn mo b">onTodayClick</code>事件。我在<code class="fe ml mm mn mo b">ngOnInit</code>中补充说:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="bee3" class="pw-post-body-paragraph lk ll iq lm b ln mg jr lp lq mh ju ls lt mi lv lw lx mj lz ma mb mk md me mf ij bi translated">下面是<code class="fe ml mm mn mo b">handleTodayClick</code>方法的样子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="dfe4" class="pw-post-body-paragraph lk ll iq lm b ln mg jr lp lq mh ju ls lt mi lv lw lx mj lz ma mb mk md me mf ij bi translated">当日历处于“范围”模式时，它的<code class="fe ml mm mn mo b">value</code>属性是一个数组而不是单个值。第一个和最后一个选定的日期成为数组中的第一个和第二个元素。</p><p id="a623" class="pw-post-body-paragraph lk ll iq lm b ln mg jr lp lq mh ju ls lt mi lv lw lx mj lz ma mb mk md me mf ij bi translated">当在“范围”模式下单击“今天”按钮时，今天的日期成为数组中的第一个元素。</p><p id="b757" class="pw-post-body-paragraph lk ll iq lm b ln mg jr lp lq mh ju ls lt mi lv lw lx mj lz ma mb mk md me mf ij bi translated">因此，在第6行，我们重新分配了日历的<code class="fe ml mm mn mo b">value</code>属性，将其设置为该日期，因此将其从一个数组更改为一个日期值。如果日历已经处于“单一”模式，我们就会处于这种状态。</p><p id="a12d" class="pw-post-body-paragraph lk ll iq lm b ln mg jr lp lq mh ju ls lt mi lv lw lx mj lz ma mb mk md me mf ij bi translated">然后我们隐藏覆盖/日期选择器，这将触发一个淡出动画。</p><p id="549a" class="pw-post-body-paragraph lk ll iq lm b ln mg jr lp lq mh ju ls lt mi lv lw lx mj lz ma mb mk md me mf ij bi translated">然后，经过一小段时间的延迟(原因见下文)，我们使用指令的<code class="fe ml mm mn mo b">setMode</code>方法将模式设置为“single ”,但没有可选的第三个<code class="fe ml mm mn mo b">clearSelection</code>参数，因为我们只是设置了日历的<code class="fe ml mm mn mo b">value</code>属性，我们不想清除它。</p><p id="8e9b" class="pw-post-body-paragraph lk ll iq lm b ln mg jr lp lq mh ju ls lt mi lv lw lx mj lz ma mb mk md me mf ij bi translated">最后，我们调用日历的<code class="fe ml mm mn mo b">writeValue</code>方法，向其传递我们刚刚设置的<code class="fe ml mm mn mo b">value</code>属性，即今天的日期。</p><h2 id="1822" class="ms kt iq bd ku mt mu dn ky mv mw dp lc lt mx my le lx mz na lg mb nb nc li nd bi translated">为什么耽搁了？</h2><p id="75ea" class="pw-post-body-paragraph lk ll iq lm b ln lo jr lp lq lr ju ls lt lu lv lw lx ly lz ma mb mc md me mf ij bi translated">我加上这个小小的延迟纯粹是为了美观。</p><p id="99e7" class="pw-post-body-paragraph lk ll iq lm b ln mg jr lp lq mh ju ls lt mi lv lw lx mj lz ma mb mk md me mf ij bi translated">它工作得很好，没有延迟，但是，点击今天，你会立即看到选择高亮从日期范围跳到日期，这让我感到有点奇怪和不和谐。通过添加小的延迟来考虑覆盖淡入淡出动画时间，高亮跳跃变得非常微妙，甚至不明显。</p><h1 id="43dd" class="ks kt iq bd ku kv kw kx ky kz la lb lc jw ld jx le jz lf ka lg kc lh kd li lj bi translated">最终产品</h1><p id="cb29" class="pw-post-body-paragraph lk ll iq lm b ln lo jr lp lq lr ju ls lt lu lv lw lx ly lz ma mb mc md me mf ij bi translated">结果是这样的:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/ffa8741416013b02642079b0eb7aca7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:790/1*UHbEO3lgsftNJPuaihXajw.gif"/></div></figure><p id="98aa" class="pw-post-body-paragraph lk ll iq lm b ln mg jr lp lq mh ju ls lt mi lv lw lx mj lz ma mb mk md me mf ij bi translated">为了防止切换按钮水平移动，当选择被改变并且被选择的按钮被加粗时，我不得不玩他们的<code class="fe ml mm mn mo b">letter-spacing</code>。</p><p id="0e14" class="pw-post-body-paragraph lk ll iq lm b ln mg jr lp lq mh ju ls lt mi lv lw lx mj lz ma mb mk md me mf ij bi translated">在样式中，我为非粗体和粗体按钮设置了<code class="fe ml mm mn mo b">letter-spacing</code>,这样它们的总宽度就相同了:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="aeb9" class="pw-post-body-paragraph lk ll iq lm b ln mg jr lp lq mh ju ls lt mi lv lw lx mj lz ma mb mk md me mf ij bi translated">如果没有这些，它看起来就会像这样，这有点滑稽，也不专业:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/b1e2f4763e5f56c48c9f9ddfcfb11c2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:794/1*_X9ewGSfv935CJA_DOhwzQ.gif"/></div></figure><h1 id="389c" class="ks kt iq bd ku kv kw kx ky kz la lb lc jw ld jx le jz lf ka lg kc lh kd li lj bi translated">链接</h1><p id="d76b" class="pw-post-body-paragraph lk ll iq lm b ln lo jr lp lq lr ju ls lt lu lv lw lx ly lz ma mb mc md me mf ij bi translated">以下是这一增强的三种不同实现的链接。</p><h2 id="04eb" class="ms kt iq bd ku mt mu dn ky mv mw dp lc lt mx my le lx mz na lg mb nb nc li nd bi translated">1.带有模板中定义的按钮的指令</h2><ul class=""><li id="608f" class="ne nf iq lm b ln lo lq lr lt oj lx ok mb ol mf og nk nl nm bi translated"><a class="ae kr" href="https://stackblitz.com/edit/primeng-calendar-demo-with-selectionmode-toggle-directiv-ytrnb6?file=src%2Fapp%2Fcalendar-mode-toggle.directive.ts" rel="noopener ugc nofollow" target="_blank">工作栈利兹</a></li><li id="afad" class="ne nf iq lm b ln nn lq no lt np lx nq mb nr mf og nk nl nm bi translated"><a class="ae kr" href="https://github.com/mikejacobson/primeng-calendar-mode-toggle-directive" rel="noopener ugc nofollow" target="_blank"> GitHub回购</a></li></ul><h2 id="aab6" class="ms kt iq bd ku mt mu dn ky mv mw dp lc lt mx my le lx mz na lg mb nb nc li nd bi translated">2.指令，带有以编程方式定义的按钮</h2><ul class=""><li id="2193" class="ne nf iq lm b ln lo lq lr lt oj lx ok mb ol mf og nk nl nm bi translated"><a class="ae kr" href="https://stackblitz.com/edit/primeng-calendar-demo-with-selectionmode-toggle-directive?file=src%2Fapp%2Fcalendar-mode-toggle.directive.ts" rel="noopener ugc nofollow" target="_blank">工作堆栈宽度</a></li><li id="b069" class="ne nf iq lm b ln nn lq no lt np lx nq mb nr mf og nk nl nm bi translated"><a class="ae kr" href="https://github.com/mikejacobson/primeng-calendar-mode-toggle-directive-using-renderer" rel="noopener ugc nofollow" target="_blank"> GitHub回购</a></li></ul><h2 id="b87f" class="ms kt iq bd ku mt mu dn ky mv mw dp lc lt mx my le lx mz na lg mb nb nc li nd bi translated">3.使用CDK门户将按钮导入日历的组件</h2><ul class=""><li id="1a52" class="ne nf iq lm b ln lo lq lr lt oj lx ok mb ol mf og nk nl nm bi translated"><a class="ae kr" href="https://stackblitz.com/edit/primeng-calendar-with-selectionmode-toggle-using-cdk-portal?file=src%2Fapp%2Fcalendar-mode-toggle-buttons.component.ts" rel="noopener ugc nofollow" target="_blank">工作堆栈宽度</a></li><li id="52de" class="ne nf iq lm b ln nn lq no lt np lx nq mb nr mf og nk nl nm bi translated"><a class="ae kr" href="https://github.com/mikejacobson/primeng-calendar-mode-toggle-component-using-cdk-portal" rel="noopener ugc nofollow" target="_blank"> GitHub回购</a></li></ul><p id="5a4c" class="pw-post-body-paragraph lk ll iq lm b ln mg jr lp lq mh ju ls lt mi lv lw lx mj lz ma mb mk md me mf ij bi translated">CDK门户实现的repo是一个真正可运行的Angular应用程序，而另外两个只是存储和共享代码的地方。</p><h1 id="8c38" class="ks kt iq bd ku kv kw kx ky kz la lb lc jw ld jx le jz lf ka lg kc lh kd li lj bi translated">最后的想法和警告</h1><p id="31a2" class="pw-post-body-paragraph lk ll iq lm b ln lo jr lp lq lr ju ls lt lu lv lw lx ly lz ma mb mc md me mf ij bi translated">我意识到这种增强的一部分依赖于第三方组件的内部实现细节，这些细节在未来可能只需要一个小的或补丁版本的变动就能改变。</p><p id="79df" class="pw-post-body-paragraph lk ll iq lm b ln mg jr lp lq mh ju ls lt mi lv lw lx mj lz ma mb mk md me mf ij bi translated">不过，在我的例子中，这是一个本质上的内部工具，依赖版本受到严格控制，升级经过全面测试。所以我不担心PrimeNG可能改变他们的内部实现，在我们没有注意到的情况下破坏它，并且在它进入生产之前有机会修复它。</p><p id="3eb8" class="pw-post-body-paragraph lk ll iq lm b ln mg jr lp lq mh ju ls lt mi lv lw lx mj lz ma mb mk md me mf ij bi translated">但是，在您自己的项目中使用这种方法之前，请记住这一点！</p><p id="9154" class="pw-post-body-paragraph lk ll iq lm b ln mg jr lp lq mh ju ls lt mi lv lw lx mj lz ma mb mk md me mf ij bi translated">感谢阅读！😺</p></div></div>    
</body>
</html>