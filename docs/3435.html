<html>
<head>
<title>Using Component Slots in VueJS — An Overview</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在VueJS中使用组件插槽—概述</h1>
<blockquote>原文：<a href="https://itnext.io/using-component-slots-in-vuejs-an-overview-9e0ed8537b2c?source=collection_archive---------1-----------------------#2019-12-16">https://itnext.io/using-component-slots-in-vuejs-an-overview-9e0ed8537b2c?source=collection_archive---------1-----------------------#2019-12-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/3a12e598ebdaca626b63204596aae227.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Y2dCY8E2QtQMUBh3"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">由<a class="ae jg" href="https://unsplash.com/@lucabravo?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">卢卡·布拉沃</a>在<a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><div class=""/><p id="2cea" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">插槽是Vue中组件向子组件注入内容的另一种方式。这是使用模板代码实现的。</p><p id="5cb5" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">就最终输出而言，插槽执行的功能类似于Vue中的props从父组件向子组件获取数据。</p><p id="9852" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，props将数据值传递给组件，而slots只能直接传递模板代码。我认为根据具体情况，这会带来一些好处:</p><ul class=""><li id="483b" class="le lf jj ki b kj kk kn ko kr lg kv lh kz li ld lj lk ll lm bi translated">你的子组件更容易重用——你可以传递给它不同的组件，而不用担心格式/数据值的一致性</li><li id="aa2a" class="le lf jj ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">更加灵活的是<strong class="ki jk"/>——你不必总是填充每个值，而对于props，你需要担心使用<code class="fe ls lt lu lv b">v-if</code>来检查值是否存在</li><li id="f1b0" class="le lf jj ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">这可能是个人的事情，但是我认为子组件看起来更有<strong class="ki jk">可读性</strong></li></ul><p id="8909" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我认为最好的理解老虎机的方法是看一个如何使用它们的例子，以及实际发生了什么。</p><h1 id="2da1" class="lw lx jj bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">最简单的用例</h1><p id="e29c" class="pw-post-body-paragraph kg kh jj ki b kj mu kl km kn mv kp kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">从slots开始是一个典型的用例，在这个用例中，我们简单地在子组件中声明一个<code class="fe ls lt lu lv b">slot</code>,并使用父组件注入内容。</p><p id="b6df" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们去看看。首先，让我们设置一个名为<code class="fe ls lt lu lv b">MyContainer.vue</code>的父组件</p><pre class="mz na nb nc gt nd lv ne nf aw ng bi"><span id="7b4d" class="nh lx jj lv b gy ni nj l nk nl">&lt;template&gt;<br/>   &lt;div&gt;<br/>     &lt;my-button&gt;Click Me!&lt;/my-button&gt;<br/>   &lt;/div&gt;<br/>&lt;/template&gt;</span></pre><p id="b7ab" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，让我们设置一个子组件<code class="fe ls lt lu lv b">MyButton.vue</code>组件。</p><pre class="mz na nb nc gt nd lv ne nf aw ng bi"><span id="3365" class="nh lx jj lv b gy ni nj l nk nl">&lt;template&gt;<br/>   &lt;div&gt;<br/>     &lt;slot&gt;&lt;/slot&gt;<br/>   &lt;/div&gt;<br/>&lt;/template&gt;</span></pre><p id="960e" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当MyButton.vue呈现时，<code class="fe ls lt lu lv b">&lt;slot&gt;</code>将被<code class="fe ls lt lu lv b">Click Me!</code>替换——来自父内容的<strong class="ki jk">。</strong></p><p id="05b2" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你可以从父组件传递任何类型的模板，不一定只是文本。它可以是一个字体很棒的图标，图像，甚至是另一个组件。</p><h1 id="6f8c" class="lw lx jj bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">需要多个插槽？说出他们的名字。</h1><p id="fbbe" class="pw-post-body-paragraph kg kh jj ki b kj mu kl km kn mv kp kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">组织基于插槽的组件系统的最佳方式是将您的插槽命名为。这样，您可以确保将内容注入到组件的正确部分。</p><p id="628d" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如您所料，这是通过向您的子组件中的<code class="fe ls lt lu lv b">slot</code>添加一个<strong class="ki jk">名称属性</strong>来完成的。然后，要从父元素添加内容，只需创建另一个<code class="fe ls lt lu lv b">&lt;template&gt;</code>元素，并在名为<code class="fe ls lt lu lv b">v-slot</code>的属性中传递名称</p><p id="ecd1" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们来看看实际情况。</p><pre class="mz na nb nc gt nd lv ne nf aw ng bi"><span id="0021" class="nh lx jj lv b gy ni nj l nk nl">// BoxElement.vue<br/>&lt;template&gt;<br/>   &lt;div&gt;<br/>      &lt;slot name='header'&gt;&lt;/slot&gt;<br/>      &lt;slot name='content'&gt;&lt;/slot&gt;<br/>   &lt;/div&gt;<br/>&lt;/template&gt;</span></pre><p id="9daf" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后是父组件。</p><pre class="mz na nb nc gt nd lv ne nf aw ng bi"><span id="5ccf" class="nh lx jj lv b gy ni nj l nk nl">&lt;template&gt;<br/>   &lt;div&gt; <br/>      &lt;box-element&gt;    <br/>         &lt;template v-slot:header&gt;<br/>            This will be injected as the header slot.<br/>         &lt;/template&gt;<br/>         &lt;template v-slot:content&gt;<br/>            This will be the content of the element<br/>         &lt;/template&gt;<br/>      &lt;/box-element&gt;  <br/>   &lt;/div&gt;<br/>&lt;/template&gt;</span></pre><p id="f4c5" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意:如果一个插槽没有命名。它的名字只是<code class="fe ls lt lu lv b">default</code></p><h1 id="0918" class="lw lx jj bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">传递数据作用域槽</h1><p id="539b" class="pw-post-body-paragraph kg kh jj ki b kj mu kl km kn mv kp kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">关于插槽的另一个巧妙之处是，您可以让父组件<strong class="ki jk">访问子组件内部的数据</strong>。</p><p id="55f9" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果子组件使用一个数据对象来决定它显示什么，我们可以让数据<strong class="ki jk">对父组件</strong>可见，并在传递注入的内容时使用它。</p><p id="e499" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们再来看一个例子。</p><p id="1622" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们在子组件<code class="fe ls lt lu lv b">Article.vue</code>中有这个文章标题槽—在这种情况下，我们的后备数据是文章标题。</p><pre class="mz na nb nc gt nd lv ne nf aw ng bi"><span id="5e18" class="nh lx jj lv b gy ni nj l nk nl">&lt;div&gt;<br/>   &lt;slot name='header'&gt;<br/>      {{article.title}}<br/>   &lt;/slot&gt;<br/>&lt;/div&gt;</span></pre><p id="2a7b" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在让我们继续看父组件。如果我们想改变内容来显示文章的描述，会发生什么？我们不能这样做，因为我们的父组件<strong class="ki jk">不能访问其子组件<code class="fe ls lt lu lv b">Article.vue</code>中的文章对象</strong></p><p id="0952" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">谢天谢地，Vue可以很容易地处理这种情况。我们可以用一个简单的<code class="fe ls lt lu lv b"> v-bind</code>将数据从子插槽绑定到父模板</p><p id="f985" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们来看看我们修改后的div。</p><pre class="mz na nb nc gt nd lv ne nf aw ng bi"><span id="a842" class="nh lx jj lv b gy ni nj l nk nl">&lt;div&gt;<br/>   &lt;slot name='header' v-bind:article='article'&gt;<br/>      {{article.title}}<br/>   &lt;/slot&gt;<br/>&lt;/div&gt;</span></pre><p id="1cf5" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那里。我们的父组件可以访问该属性。现在，让我们看看如何访问它。</p><p id="a7f6" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">类似于使用props向组件传递数据时，我们的子组件传递一个<strong class="ki jk"> props对象</strong>，所有有界属性都作为子对象。</p><p id="ac13" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们所要做的就是在模板中命名这个对象，然后我们就可以访问它们了。我们暂时将它命名为<code class="fe ls lt lu lv b">articleInfo</code>，但这只是一个变量，所以你可以使用任何你想要的东西。</p><pre class="mz na nb nc gt nd lv ne nf aw ng bi"><span id="426d" class="nh lx jj lv b gy ni nj l nk nl">&lt;div&gt;<br/>   &lt;article v-slot:header='articleInfo'&gt;<br/>      // we have access to the article object now!<br/>      {{ articleInfo.article header }}<br/>   &lt;/article&gt;<br/>&lt;/div&gt;</span></pre><p id="a08f" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">简单对吗？</p><h1 id="2e02" class="lw lx jj bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">使用插槽使组件更加灵活</h1><p id="ae57" class="pw-post-body-paragraph kg kh jj ki b kj mu kl km kn mv kp kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">Props是重用组件的一种很好的方式，但是根据您的用例，它们有其局限性。Props倾向于在具有相同格式和内容的组件中工作得最好，但是只是值不同。</p><p id="5840" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有时你需要让你的组件更加灵活和适应:也许你想让一些组件有某些部分，而根据它在哪个页面，你想删除其他部分。</p><p id="a408" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通过使用插槽注入内容，可以更容易地切换组件的内容，而不必担心使用模板逻辑如<code class="fe ls lt lu lv b">v-if</code>和<code class="fe ls lt lu lv b">v-else</code>来处理呈现。</p><h1 id="cc57" class="lw lx jj bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">这是所有的乡亲</h1><p id="ba41" class="pw-post-body-paragraph kg kh jj ki b kj mu kl km kn mv kp kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">我希望这篇小文章能帮助你了解一些使用slots来组织你的Vue项目的可能性。</p><p id="421e" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">和往常一样，要了解更多信息和技术细节，请查看<a class="ae jg" href="https://vuejs.org/v2/guide/components-slots.html" rel="noopener ugc nofollow" target="_blank"> Vue文档</a>。</p><p id="2bde" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">编码快乐！</p></div></div>    
</body>
</html>