<html>
<head>
<title>Yes, this is how to cache pages by url with Vue, Vue Router and Keep Alive</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">是的，这就是如何缓存网页的网址与Vue，Vue路由器和保持活力</h1>
<blockquote>原文：<a href="https://itnext.io/yes-this-is-how-to-cache-pages-by-url-with-vue-vue-router-and-keep-alive-component-697ed76896e8?source=collection_archive---------2-----------------------#2019-04-02">https://itnext.io/yes-this-is-how-to-cache-pages-by-url-with-vue-vue-router-and-keep-alive-component-697ed76896e8?source=collection_archive---------2-----------------------#2019-04-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="00b4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在过去，Ionic 1对我来说是最好的混合移动框架。有两个原因:</p><ul class=""><li id="47ee" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated">用户界面和内置组件非常棒，而且功能齐全</li><li id="51e8" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">路由器上的每路由高速缓存系统是一个省时的系统</li></ul><p id="6a17" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当您创建移动体验时，您知道带宽是一个真正的问题，因此，您不希望您的用户一直看到加载器。您希望尽可能少地调用API。</p><p id="eca0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当你的用户看到一个页面，导航出去，然后回来，你不希望在大多数情况下重新加载内容，因为内容可能没有在你的用户的会话中改变。</p><p id="37f3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在脸书应用程序上，每个视图大部分时间都被缓存。</p><p id="ed1e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">可惜我在Vue路由器里没有发现任何内置的缓存系统。</p><p id="da4b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我详细分解一下:</p><ul class=""><li id="7b4f" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated">我有一个组件显示一个<strong class="jp ir">动漫</strong>项目</li><li id="ac40" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">我将这个组件链接到一个路由器，路径是:<strong class="jp ir"> /anime/:id </strong></li><li id="d84b" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">在组件中，我通过ID进行API调用来显示内容</li><li id="6035" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">如果我去<strong class="jp ir"> /anime/1 </strong>，组件被创建并渲染</li><li id="3487" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">如果我去<strong class="jp ir"> /home </strong>，然后回到<strong class="jp ir"> /anime/1 </strong>，<br/>组件被重新渲染，没有缓存</li></ul><p id="b069" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们能解决这个问题吗？是的，我看到你来了:</p><blockquote class="kz la lb"><p id="a357" class="jn jo lc jp b jq jr js jt ju jv jw jx ld jz ka kb le kd ke kf lf kh ki kj kk ij bi translated">您可以使用<strong class="jp ir"> keep-alive </strong>组件进行缓存</p></blockquote><p id="5d0b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这只是部分正确。让我们看看<strong class="jp ir"> keep-alive </strong>是如何工作的。</p><p id="6679" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> keep-alive </strong>组件缓存<strong class="jp ir">整个组件</strong>，而不是根据其URL呈现的组件。<br/>为什么？因为<strong class="jp ir"> keep-alive </strong>没有绑定到Vue路由器，它是Vue本身的内置组件，所以它与路由器的状态没有直接联系。</p><p id="76c1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">保活</strong>产生以下行为:</p><ul class=""><li id="ee12" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated">我去<strong class="jp ir"> /anime/1 </strong>，组件被创建、渲染并保持活动</li><li id="1cfe" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">我去<strong class="jp ir">/首页</strong>，然后回到<strong class="jp ir">/动漫/3 </strong>，<br/>页面会显示<strong class="jp ir">/动漫/1 </strong>的内容</li></ul><blockquote class="kz la lb"><p id="4c77" class="jn jo lc jp b jq jr js jt ju jv jw jx ld jz ka kb le kd ke kf lf kh ki kj kk ij bi translated">确保在转到一个动漫URL之前总是转到<strong class="jp ir"> /home </strong>，因为尽管使用了<strong class="jp ir"> keep-alive </strong>，当Vue路由器从<strong class="jp ir"> /anime/1 </strong>转到<strong class="jp ir"> /anime/2 </strong>时，它并没有改变组件，只是改变了URL。要修补这个问题，您需要<strong class="jp ir">观察</strong><strong class="jp ir">$ route</strong>属性，并相应地更新您的组件，但是在这个例子中这是不必要的。如果你想挖掘它:<a class="ae lg" href="https://router.vuejs.org/guide/essentials/dynamic-matching.html#reacting-to-params-changes" rel="noopener ugc nofollow" target="_blank">点击这里</a>。</p></blockquote><p id="763b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">没有<strong class="jp ir">保活</strong>的例子:<a class="ae lg" href="https://jsfiddle.net/darkylmnx/ey9acx1z/30" rel="noopener ugc nofollow" target="_blank">见</a>例子。<br/>示例同<strong class="jp ir">保活</strong> : <a class="ae lg" href="https://jsfiddle.net/darkylmnx/ey9acx1z/29" rel="noopener ugc nofollow" target="_blank">参见示例</a>。</p><p id="4317" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">可以看到，<strong class="jp ir"> keep-alive </strong>组件创建缓存，但是现在所有的URL<strong class="jp ir">/anime/:id</strong>都会显示第一个缓存的动漫页面的内容。</p><p id="e393" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如何才能避免这种情况？通过使用<strong class="jp ir">路由器视图</strong>上的<strong class="jp ir">键</strong>支柱。</p><p id="0b1f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae lg" href="https://jsfiddle.net/darkylmnx/ey9acx1z/28/" rel="noopener ugc nofollow" target="_blank"> E </a>带<strong class="jp ir">键</strong>道具示例:<a class="ae lg" href="https://jsfiddle.net/darkylmnx/ey9acx1z/31" rel="noopener ugc nofollow" target="_blank">见示例</a>。</p><p id="8a9b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为什么这能解决我们所有的问题？要完全理解为什么，你需要理解<strong class="jp ir">键</strong>道具在Vue中的作用以及<strong class="jp ir">路由器视图</strong>是如何工作的。</p><p id="c566" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">键</strong>道具用于区分虚拟DOM中的相同元素。</p><p id="1aaf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">路由器-视图</strong>是<strong class="jp ir">的高级版本&lt;组件是=… / &gt; </strong>。<br/>知道了，<strong class="jp ir"> </strong>当你从<strong class="jp ir"> /a </strong>到<strong class="jp ir"> /b </strong>的时候，<strong class="jp ir">组件A </strong>和<strong class="jp ir">组件B </strong>被交换，一个替换另一个在虚拟DOM中的相同位置。<br/>这就是为什么当你从<strong class="jp ir"> /anime/1 </strong>移动到<strong class="jp ir"> /anime/2 </strong>时，路由器不会破坏组件来重新创建它，因为对于Vue来说，两者使用的是同一个组件，所以没有必要破坏它重新创建。</p><p id="f217" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们给<strong class="jp ir">路由器视图</strong>添加了一个<strong class="jp ir">键</strong>道具，基本上就是说:</p><blockquote class="kz la lb"><p id="cd01" class="jn jo lc jp b jq jr js jt ju jv jw jx ld jz ka kb le kd ke kf lf kh ki kj kk ij bi translated">考虑到每个键的每个<strong class="jp ir">路由器视图</strong>是一个不同的组件</p></blockquote><p id="a189" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，由于我们的<strong class="jp ir"> keep-alive </strong>组件，它将按键缓存每个组件，因为在我们的例子中每个键是一个URL，它将按URL进行缓存:)</p><p id="1a75" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我来分解一下:</p><ul class=""><li id="71f6" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated">在<strong class="jp ir"> /home </strong>上，<strong class="jp ir"> keep-alive </strong>缓存<strong class="jp ir">&lt;router-view key = "/home "/&gt;<br/></strong>，它评估为Home组件<strong class="jp ir">&lt;Home key = "/Home "/&gt;</strong></li><li id="0e4c" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">在<strong class="jp ir"> /anime/1 </strong>上，它缓存了<strong class="jp ir">&lt;router-view key = "/Anime/1 "/&gt;<br/></strong>，它评估为动画组件<strong class="jp ir">&lt;Anime key = "/Anime/1 "/&gt;</strong></li><li id="2cdb" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">在<strong class="jp ir"> /anime/5 </strong>上，缓存了<strong class="jp ir">&lt;router-view key = "/Anime/5 "/&gt;<br/></strong>，其求值为动漫组件<strong class="jp ir">&lt;Anime key = "/Anime/5 "/&gt;</strong></li><li id="4d8a" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">当回到<strong class="jp ir"> /anime/1 </strong>时，显示绑定到<strong class="jp ir"> key="/anime/1" </strong>的缓存</li></ul><p id="99c4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里，<strong class="jp ir"> keep-alive </strong>认为<strong class="jp ir">&lt;anime key = "/anime/1 "/&gt;</strong>和<br/><strong class="jp ir">&lt;anime key = "/anime/5 "/&gt;</strong>是“不一样的组件”，因为用<strong class="jp ir"> key </strong>道具我们是在明确地说“它们不一样”。</p><p id="5038" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这种情况下，你甚至可以直接从<strong class="jp ir"> /anime/1 </strong>转到<strong class="jp ir"> /anime/5 </strong>，因为现在，每个URL将在第一次强制重新渲染，但会被缓存以供下次渲染。</p><h2 id="1d57" class="lh li iq bd lj lk ll dn lm ln lo dp lp jy lq lr ls kc lt lu lv kg lw lx ly lz bi translated">摘要</h2><ul class=""><li id="36b2" class="kl km iq jp b jq ma ju mb jy mc kc md kg me kk kq kr ks kt bi translated">在<strong class="jp ir"> router-view </strong>周围添加<strong class="jp ir"> keep-alive </strong>来缓存每个页面组件</li><li id="1b38" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">在<strong class="jp ir"> router-view </strong>上添加一个<strong class="jp ir"> key </strong> prop，用<strong class="jp ir"> URL作为值</strong>，告诉Vue如果<strong class="jp ir">组件是相同的但是key是不同的</strong></li></ul><p id="1bed" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是你所需要的，现在你有了每个页面的URL缓存(在内存中)。<a class="ae lg" href="https://jsfiddle.net/darkylmnx/ey9acx1z/31" rel="noopener ugc nofollow" target="_blank">https://jsfiddle.net/darkylmnx/ey9acx1z/31</a></p><p id="b56b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">明智地使用它，因为它适用于特定的用例，并且您需要在需要时处理缓存失效。</p></div><div class="ab cl mf mg hu mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ij ik il im in"><p id="a003" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">奖励1: </strong>你可以使用<strong class="jp ir"> keep-alive </strong>组件上的<strong class="jp ir"> max </strong>道具来限制缓存物品的数量。这将很容易使缓存失效。<a class="ae lg" href="https://jsfiddle.net/darkylmnx/ey9acx1z/32/" rel="noopener ugc nofollow" target="_blank">https://jsfiddle.net/darkylmnx/ey9acx1z/32/</a>。点击阅读更多关于<strong class="jp ir">最大</strong>道具<a class="ae lg" href="https://vuejs.org/v2/api/#keep-alive" rel="noopener ugc nofollow" target="_blank">的信息。</a></p><p id="deaa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">好处2: </strong>缓存失效确实取决于您的业务逻辑，但让我给你举个简单的例子。你可以使用<strong class="jp ir">实例钩子</strong> <code class="fe mm mn mo mp b">activated</code>和<code class="fe mm mn mo mp b">deactivated</code>来检查用户何时进入一个缓存的组件(因为创建并挂载的组件不会被调用)，并基于一个计数器或某个截止日期重新进行一次API调用，<a class="ae lg" href="https://jsfiddle.net/darkylmnx/ey9acx1z/33/" rel="noopener ugc nofollow" target="_blank">参见示例</a>。</p></div><div class="ab cl mf mg hu mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ij ik il im in"><p id="a6cb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">想要发现新鲜的音乐？检查我的项目<a class="ae lg" href="https://foreignrap.com" rel="noopener ugc nofollow" target="_blank">https://foreignrap.com</a></p><p id="33d0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">PS:如果你想学习如何创建高级组件，可以查看我的课程:<a class="ae lg" href="https://courses.maisonfutari.com/mastering-vue-components-creating-a-ui-library-from-scratch?coupon=PRESALE" rel="noopener ugc nofollow" target="_blank">https://courses . maison futari . com/mastering-vue-components-creating-a-ui-library-from-scratch？优惠券=M </a> EDIUM</p><p id="4cfa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">有50%的折扣，因为你来自这个故事。</strong></p><figure class="mr ms mt mu gt mv gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi mq"><img src="../Images/baca6755350dd84b8ba31696f2c07477.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NTQZUABt1EhJNFCB"/></div></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk translated">保持活力</figcaption></figure></div></div>    
</body>
</html>