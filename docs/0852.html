<html>
<head>
<title>Stable image component with placeholder in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React中带有占位符的稳定图像组件</h1>
<blockquote>原文：<a href="https://itnext.io/stable-image-component-with-placeholder-in-react-7c837b1ebee?source=collection_archive---------2-----------------------#2018-06-09">https://itnext.io/stable-image-component-with-placeholder-in-react-7c837b1ebee?source=collection_archive---------2-----------------------#2018-06-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/d2126a4acae93233e65cd73f9d7ee1c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CLAniSvn4Us6qfef9ukKUw.png"/></div></div></figure><p id="8048" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在大多数情况下，在加载图像时显示占位符是一个好主意，特别是对于慢速网络/设备。要用这样的图像组件构建React应用程序，从React和DOM的角度来看，有几件事情需要考虑。</p><p id="3307" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本文中，我将通过展示用ES6编写的例子来描述如何实现这样一个组件。</p><p id="a54b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">*更新2018/07/21切换到ES6，更新示例使用<code class="fe kw kx ky kz b"><a class="ae la" href="https://www.npmjs.com/package/reenhance-components" rel="noopener ugc nofollow" target="_blank">reenhance-components</a></code>。</p><h1 id="8dd8" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">显示占位符，直到“onload”事件触发</h1><p id="d8f4" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">实现这种行为的最直接的策略是:</p><ol class=""><li id="d641" class="me mf iq ka b kb kc kf kg kj mg kn mh kr mi kv mj mk ml mm bi translated">用<code class="fe kw kx ky kz b">false</code>初始化内部状态</li><li id="e121" class="me mf iq ka b kb mn kf mo kj mp kn mq kr mr kv mj mk ml mm bi translated">设置一个<code class="fe kw kx ky kz b">onLoad</code>事件处理程序，将状态更新为<code class="fe kw kx ky kz b">true</code></li><li id="85fe" class="me mf iq ka b kb mn kf mo kj mp kn mq kr mr kv mj mk ml mm bi translated">让组件根据状态显示占位符或图像。</li></ol><p id="e47f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为占位符必须在页面加载后显示，所以它应该是SVG或数据URI。我们可以在常规的JSX/TSX中嵌入SVG元素，只需将属性<code class="fe kw kx ky kz b">view-box</code>重命名为<code class="fe kw kx ky kz b">viewBox.</code></p><p id="d68f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">状态可以从<code class="fe kw kx ky kz b"><a class="ae la" href="https://www.npmjs.com/package/reenhance-components" rel="noopener ugc nofollow" target="_blank">reenhance-components</a></code>存储在<code class="fe kw kx ky kz b">StateProvider</code>中。它通过嵌入JSX/TSX来提供状态和更新程序。</p><p id="c3ce" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">整个过程可以编码如下:</p><pre class="ms mt mu mv gt mw kz mx my aw mz bi"><span id="d613" class="na lc iq kz b gy nb nc l nd ne">interface OuterProps {<br/>  src: string;<br/>}</span><span id="1b23" class="na lc iq kz b gy nf nc l nd ne">const LoadedState = StateProvider(false);</span><span id="9a24" class="na lc iq kz b gy nf nc l nd ne">const ImageWithLoading = ({ src }) =&gt; (<br/>  &lt;LoadedState&gt;<br/>    {({ state: loaded, setState: setLoaded }) =&gt; (<br/>      &lt;div&gt;<br/>        {!loaded ? (<br/>          &lt;svg width="100" height="100" viewBox="0 0 100 100"&gt;  <br/>            &lt;rect width="100" height="100" rx="10" ry="10" fill="#CCC" /&gt;<br/>          &lt;/svg&gt;<br/>        ) : null}<br/>        &lt;img<br/>          src={src}<br/>          style={!loaded ? { visibility: 'hidden' } : {}}<br/>          onLoad={() =&gt; setLoaded(true)}<br/>        /&gt;<br/>      &lt;/div&gt;<br/>    )}<br/>  &lt;/LoadedState&gt;<br/>);</span></pre><p id="670f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你是否注意到占位符和<code class="fe kw kx ky kz b">img</code>隐藏的方式不同？一旦<code class="fe kw kx ky kz b">loaded</code>变为真，占位符就可以从dom中删除，但是<code class="fe kw kx ky kz b">img</code>必须从开始就存在，以触发<code class="fe kw kx ky kz b">onLoad</code>事件。</p><p id="3397" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">结果会是这样的。</p><figure class="ms mt mu mv gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ng"><img src="../Images/5f4b81d1101bcef3afadc0523a99029a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*coHQKlCMqTx0ZEa2Qxc-5A.gif"/></div></div></figure><p id="1098" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你也可以在这个CodePen里试试。</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="e82f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好看吗？实际上，这还不完善。</p><h1 id="74ea" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">重新装载会导致图像闪烁</h1><p id="e5c6" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">在React应用程序中，UI交互可能会导致应用程序状态的一些更新，从而触发图像组件的重新安装。如果组件被重新安装，<code class="fe kw kx ky kz b">loaded</code>状态将被重置，并导致这样的闪烁。</p><figure class="ms mt mu mv gt jr gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/fff52b7f016e711aec63f849606fbbf3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*JS1Z5nJIhlsEnJul-FG_mQ.gif"/></div></figure><p id="658b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于这个问题我们能做些什么？</p><h1 id="2a52" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">将DOM属性反映到组件状态</h1><p id="638e" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">这种闪烁的发生是因为我们的组件正在等待<code class="fe kw kx ky kz b">load</code>事件，而不管图像是否被*初始*加载。该状态可通过指示元素当前状态的<code class="fe kw kx ky kz b">complete</code> DOM属性获得。</p><p id="bdf4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了访问该属性，我们需要一个对图像元素的引用。从React 16.3开始，使用<code class="fe kw kx ky kz b">createRef</code>是推荐的方式。<code class="fe kw kx ky kz b">ref</code>对象可以从<code class="fe kw kx ky kz b"><a class="ae la" href="https://www.npmjs.com/package/reenhance-components" rel="noopener ugc nofollow" target="_blank">reenhance-components</a></code>存储到<code class="fe kw kx ky kz b">ObjectWatcher</code>观看的&amp;。</p><p id="8be0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一旦<code class="fe kw kx ky kz b">complete</code>可用，该值可用于确定图像是否准备好。下面的代码对此进行了描述:</p><pre class="ms mt mu mv gt mw kz mx my aw mz bi"><span id="bf36" class="na lc iq kz b gy nb nc l nd ne">const { StateProvider, ObjectWatcher } = ReenhanceComponents;</span><span id="6a79" class="na lc iq kz b gy nf nc l nd ne">const LoadedState = StateProvider(false);<br/>const ImageRefWatcher = ObjectWatcher(React.createRef());</span><span id="0ba7" class="na lc iq kz b gy nf nc l nd ne">const ImageWithLoading = ({ src }) =&gt; (<br/>  &lt;LoadedState&gt;<br/>    {({ state: loaded, setState: setLoaded }) =&gt; (<br/>      &lt;ImageRefWatcher watch="current"&gt;<br/>        {(imageRef) =&gt; {<br/>          const complete = imageRef.current &amp;&amp; imageRef.current.complete;</span><span id="dc81" class="na lc iq kz b gy nf nc l nd ne">          return (<br/>            &lt;div&gt;<br/>              {!complete ? (<br/>                &lt;svg width="100" height="100" viewBox="0 0 100 100"&gt;  <br/>                  &lt;rect width="100" height="100" rx="10" ry="10" fill="#CCC" /&gt;<br/>                &lt;/svg&gt;<br/>              ) : null}<br/>              &lt;img<br/>                src={src}<br/>                style={!complete ? { visibility: 'hidden' } : {}}<br/>                ref={imageRef}<br/>                onLoad={() =&gt; setLoaded(true)}<br/>                /&gt;<br/>            &lt;/div&gt;<br/>          );<br/>        }}<br/>      &lt;/ImageRefWatcher&gt;<br/>    )}<br/>  &lt;/LoadedState&gt;<br/>);</span></pre><p id="e4e9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请注意，<code class="fe kw kx ky kz b">loaded</code>状态不再被引用。它只是通过调用<code class="fe kw kx ky kz b">setLoaded</code>来撤销渲染。</p><p id="0f19" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">密码笔在这里。</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="98d8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">运动。</strong></p><p id="8850" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于我们不再引用<code class="fe kw kx ky kz b">loaded</code>状态，我们可以从上面例子中的<code class="fe kw kx ky kz b">ImageWithLoading</code>标签中移除<code class="fe kw kx ky kz b">key</code>属性。移除<code class="fe kw kx ky kz b">key</code>支柱并修改<code class="fe kw kx ky kz b">ImageWithLoading</code>,使其在给出新id时显示占位符。(提示。改变<code class="fe kw kx ky kz b">LoadedState</code>的类型)</p><h1 id="56ca" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="d059" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">React可以很好地处理无状态组件，但是有些HTML元素背后隐藏着状态。如果你理解他们的行为并把他们包起来，你就能完全控制他们。</p><h1 id="aa9a" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">参考</h1><p id="7ba2" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated"><a class="ae la" href="https://stackoverflow.com/questions/12354865/image-onload-event-and-browser-cache" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/12354865/image-onload-event-and-browser-cache</a></p></div></div>    
</body>
</html>