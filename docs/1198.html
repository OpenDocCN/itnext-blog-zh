<html>
<head>
<title>Give your logs more context — Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">给你的日志更多的上下文—第1部分</h1>
<blockquote>原文：<a href="https://itnext.io/give-your-logs-more-context-7b43ea6b4ae6?source=collection_archive---------5-----------------------#2018-08-09">https://itnext.io/give-your-logs-more-context-7b43ea6b4ae6?source=collection_archive---------5-----------------------#2018-08-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="13d6" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何理解Node.js web应用程序日志</h2></div><p id="1baa" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在构建现实世界的应用程序时，日志记录可能是最难做对的事情之一。记录太少，你会盯着屏幕试图理解它们(或从中生成的图表)。记录太多，你最终会迷失在无用信息的沼泽中，仍然不知道是否一切正常或是否有问题。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lb"><img src="../Images/72770ba10150a7dedffb1353cd3e56d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9kNnMDxvO_B3lAuNtaRdmg.jpeg"/></div></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk translated">没有适当上下文的日志看起来像…</figcaption></figure><p id="2163" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lr">第2部分现已推出:</em></p><div class="ls lt gp gr lu lv"><a rel="noopener  ugc nofollow" target="_blank" href="/give-your-logs-more-context-part-2-c2c952724e04"><div class="lw ab fo"><div class="lx ab ly cl cj lz"><h2 class="bd ir gy z fp ma fr fs mb fu fw ip bi translated">给你的日志更多的上下文—第2部分</h2><div class="mc l"><h3 class="bd b gy z fp ma fr fs mb fu fw dk translated">构建上下文记录器</h3></div><div class="md l"><p class="bd b dl z fp ma fr fs mb fu fw dk translated">itnext.io</p></div></div><div class="me l"><div class="mf l mg mh mi me mj ll lv"/></div></div></a></div><p id="c0e8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">具体说到Node.js/Javascript生态系统，三大日志库——<a class="ae mk" href="https://github.com/winstonjs/winston" rel="noopener ugc nofollow" target="_blank">Winston</a>、<a class="ae mk" href="https://github.com/trentm/node-bunyan" rel="noopener ugc nofollow" target="_blank"> Bunyan </a>和<a class="ae mk" href="https://github.com/pinojs/pino" rel="noopener ugc nofollow" target="_blank">Pino</a>——可以帮助你更好地管理上下文，这是好人做不到的。</p><p id="1a6b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于本文，我将使用Pino，但是这些想法可以很容易地复制到Bunyan和Winston(或任何其他主流日志记录实用程序)上。</p><h1 id="3b03" class="mp mq iq bd mr ms mt mu mv mw mx my mz jw na jx nb jz nc ka nd kc ne kd nf ng bi translated">明智地使用日志级别</h1><p id="5655" class="pw-post-body-paragraph kf kg iq kh b ki nh jr kk kl ni ju kn ko nj kq kr ks nk ku kv kw nl ky kz la ij bi translated">Pino有6个默认日志级别，严重性依次为:<code class="fe ml mm mn mo b">trace</code>、<code class="fe ml mm mn mo b">debug</code>、<code class="fe ml mm mn mo b">info</code>、<code class="fe ml mm mn mo b">warn</code>、<code class="fe ml mm mn mo b">error</code>和<code class="fe ml mm mn mo b">fatal</code>。这些级别中的每一个都映射到从<code class="fe ml mm mn mo b">10</code>到<code class="fe ml mm mn mo b">60</code>的整数。这使得以后使用像<code class="fe ml mm mn mo b"><a class="ae mk" href="https://stedolan.github.io/jq/" rel="noopener ugc nofollow" target="_blank">jq</a></code>这样的工具来分析您的日志变得容易:</p><pre class="lc ld le lf gt nm mo nn no aw np bi"><span id="d4ac" class="nq mq iq mo b gy nr ns l nt nu">jq 'select(.level &gt; 40)' # gets ERROR and FATAL logs</span></pre><p id="da96" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">虽然Pino允许您定义自定义日志级别，但我从未见过需要它们的用例，所以我倾向于使用默认的级别。</p><p id="c2fb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通常，对于生产，建议忽略<code class="fe ml mm mn mo b">trace</code>和<code class="fe ml mm mn mo b">debug</code>级别，除非您明确尝试调试一些生产问题。</p><p id="cb0e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Pino有一个<a class="ae mk" href="https://github.com/pinojs/pino/blob/master/docs/api.md#options" rel="noopener ugc nofollow" target="_blank">配置选项</a>，允许您定义生成日志条目所需的最低级别。您可以使用环境变量来避免仅仅为了更改日志级别而进行部署:</p><pre class="lc ld le lf gt nm mo nn no aw np bi"><span id="44cb" class="nq mq iq mo b gy nr ns l nt nu">import pino from 'pino';</span><span id="c37f" class="nq mq iq mo b gy nv ns l nt nu">const logger = pino({<br/>  level: process.env.LOG_LEVEL || 'info'<br/>});</span></pre><h2 id="ea3d" class="nq mq iq bd mr nw nx dn mv ny nz dp mz ko oa ob nb ks oc od nd kw oe of nf og bi translated">经验法则</h2><ul class=""><li id="e6f9" class="oh oi iq kh b ki nh kl ni ko oj ks ok kw ol la om on oo op bi translated">使用<code class="fe ml mm mn mo b">trace</code>进行具有潜在高吞吐量的内部记录。</li><li id="8b80" class="oh oi iq kh b ki oq kl or ko os ks ot kw ou la om on oo op bi translated">将<code class="fe ml mm mn mo b">debug</code>用于您可能需要的最终调试会话，但是记住在您完成后移除它们。</li><li id="8bbe" class="oh oi iq kh b ki oq kl or ko os ks ot kw ou la om on oo op bi translated">将<code class="fe ml mm mn mo b">info</code>用于常规应用程序工作流日志。</li><li id="99bf" class="oh oi iq kh b ki oq kl or ko os ks ot kw ou la om on oo op bi translated">将<code class="fe ml mm mn mo b">warn</code>用于预期的和频繁的错误情况(如用户输入验证)。</li><li id="5d8d" class="oh oi iq kh b ki oq kl or ko os ks ot kw ou la om on oo op bi translated">将<code class="fe ml mm mn mo b">error</code>用于预期但不常见的错误情况(如网络故障、数据库超时)。</li><li id="2d5f" class="oh oi iq kh b ki oq kl or ko os ks ot kw ou la om on oo op bi translated">使用<code class="fe ml mm mn mo b">fatal</code>处理意外错误情况。</li></ul><h1 id="1c50" class="mp mq iq bd mr ms mt mu mv mw mx my mz jw na jx nb jz nc ka nd kc ne kd nf ng bi translated">拥抱请求id</h1><p id="d36f" class="pw-post-body-paragraph kf kg iq kh b ki nh jr kk kl ni ju kn ko nj kq kr ks nk ku kv kw nl ky kz la ij bi translated">当我们仍然在开发应用程序，运行单元/集成测试，手动触发一些请求来查看是否一切都顺利运行时，一切都很好。产生的事件或多或少是按照可预测的顺序发生的，所以很容易理解。</p><p id="3961" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，一旦推出生产版本，事情可能会变得非常疯狂。您的应用程序肯定会处理并发请求。如果有几个异步步骤——比如查询数据库或调用一些外部服务——每个事件的顺序将完全不可预测。在这种情况下，如果您手动检查日志(我们在某些时候都必须这样做😅)，你可能会变得非常沮丧，试图找到一个执行的线程。</p><p id="41bb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一些框架——如<a class="ae mk" href="https://hapijs.com/" rel="noopener ugc nofollow" target="_blank">哈比神</a>——已经为你做好了准备。但是如果你和我一样还依赖好ol '<a class="ae mk" href="https://expressjs.com/" rel="noopener ugc nofollow" target="_blank">' express，</a>你就要自己动手了。定义这样做的中间件非常简单:</p><pre class="lc ld le lf gt nm mo nn no aw np bi"><span id="77fa" class="nq mq iq mo b gy nr ns l nt nu">function setRequestId(generateId) {<br/>  return (req, res, next) =&gt; {<br/>    req.id = generateId();<br/>    next();<br/>  };<br/>}</span></pre><p id="a8fa" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后使用它:</p><pre class="lc ld le lf gt nm mo nn no aw np bi"><span id="4cfc" class="nq mq iq mo b gy nr ns l nt nu">let i = 0;<br/>const generateId = () =&gt; i++;<br/>app.use(setRequestId(generateId));</span></pre><p id="2349" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当然，如果您重启服务器，这种幼稚的实现将不会工作，因为计数器将被重置为<code class="fe ml mm mn mo b">0</code>。对于真实世界的应用程序，建议使用更健壮的ID生成器，比如<a class="ae mk" href="https://github.com/kelektiv/node-uuid" rel="noopener ugc nofollow" target="_blank"> uuid </a>或者我个人选择的<a class="ae mk" href="https://github.com/ericelliott/cuid" rel="noopener ugc nofollow" target="_blank"> cuid </a>。</p><p id="1f4b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您使用微服务架构(或者想要准备好这样做)，您可以通过允许您的服务转发和接收给定的请求ID来利用分布式跟踪:</p><pre class="lc ld le lf gt nm mo nn no aw np bi"><span id="47ea" class="nq mq iq mo b gy nr ns l nt nu">function setDistributedRequestId(generateId) {<br/>  return (req, res, next) =&gt; {<br/>    const reqId = req.get('X-Request-Id') || generateId();</span><span id="8c1c" class="nq mq iq mo b gy nv ns l nt nu">    req.id = reqId;<br/>    res.set('X-RequestId', reqId);</span><span id="abbb" class="nq mq iq mo b gy nv ns l nt nu">    next();<br/>  };<br/>}</span></pre><p id="2f08" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们可以创建另一个记录传入请求的中间件:</p><pre class="lc ld le lf gt nm mo nn no aw np bi"><span id="11b8" class="nq mq iq mo b gy nr ns l nt nu">function logIncomingRequests(logger) {<br/>  return (req, res, next) =&gt; {<br/>    // without custom serializers, we must be explicit<br/>    logger.trace({ req, requestId: req.id}, 'Incoming request');<br/>    next();<br/>  }<br/>}</span></pre><p id="9b2a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">并使用它:</p><pre class="lc ld le lf gt nm mo nn no aw np bi"><span id="db0f" class="nq mq iq mo b gy nr ns l nt nu">import pino from 'pino';</span><span id="7f08" class="nq mq iq mo b gy nv ns l nt nu">// ...</span><span id="2b98" class="nq mq iq mo b gy nv ns l nt nu">app.use(logIncommingRequests(pino()))</span></pre><p id="7dd7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">生成的日志条目如下所示:</p><pre class="lc ld le lf gt nm mo nn no aw np bi"><span id="527f" class="nq mq iq mo b gy nr ns l nt nu">{"level":30, "time":1533749413556, "pid":15377, "hostname":"henrique-pc", "msg":"Incoming request", "req":{"method":"GET", "url":"/", "headers":{"host":"localhost:4004", "user-agent":"curl/7.61.0", "accept":"*/*"}}, <strong class="mo ir">"requestId":1</strong>, "v":1}</span></pre><p id="714f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">到目前为止，一切顺利。我们甚至可以使用<code class="fe ml mm mn mo b"><a class="ae mk" href="https://github.com/pinojs/express-pino-logger" rel="noopener ugc nofollow" target="_blank">express-pino-logger</a></code>来进一步整合记录器和我们的express应用程序。这里的主要问题是请求ID与我们的web层紧密耦合。除非您在express handlers中定义了所有的业务逻辑——我强烈建议您<a class="ae mk" href="https://github.com/i0natan/nodebestpractices/blob/master/sections/projectstructre/createlayers.md" rel="noopener ugc nofollow" target="_blank">请不要</a>——否则您将无法访问其他层中的请求ID值。</p><blockquote class="ov ow ox"><p id="175b" class="kf kg lr kh b ki kj jr kk kl km ju kn oy kp kq kr oz kt ku kv pa kx ky kz la ij bi translated">哦，我可以将id存储在内存或Redis缓存中，然后在其他层中记录内容时检索它！！！</p></blockquote><p id="fcb3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">是啊，不错的尝试。我自己也这么想，但是没用。原因是当你有并发访问时，你无法知道你当前正在处理哪个请求。还是可以？</p><h1 id="601e" class="mp mq iq bd mr ms mt mu mv mw mx my mz jw na jx nb jz nc ka nd kc ne kd nf ng bi translated">满足延续本地存储</h1><p id="060a" class="pw-post-body-paragraph kf kg iq kh b ki nh jr kk kl ni ju kn ko nj kq kr ks nk ku kv kw nl ky kz la ij bi translated">想象一下，每个请求都是一个独立的连接执行路径(函数调用)的“线程”,当原始调用的结果返回时，这个线程就会被丢弃。</p><p id="5581" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">虽然<a class="ae mk" href="https://nodejs.org/en/docs/guides/blocking-vs-non-blocking/" rel="noopener ugc nofollow" target="_blank"> Javascript没有产生处理用户请求的真正线程</a>，但是它通过注册回调来模拟这一点，当函数调用的结果可用时，回调将按正确的顺序被调用。</p><p id="34ff" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">幸运的是，Node.js <a class="ae mk" href="https://nodejs.org/api/async_hooks.html" rel="noopener ugc nofollow" target="_blank">提供了一种方式</a>来通过这个执行“线程”拦截跳转。<a class="ae mk" href="https://github.com/jeff-lewis/cls-hooked" rel="noopener ugc nofollow" target="_blank">延续本地存储</a>(或简称为CLS)利用这种能力在给定的“线程”内保持数据可用。</p><blockquote class="ov ow ox"><p id="459f" class="kf kg lr kh b ki kj jr kk kl km ju kn oy kp kq kr oz kt ku kv pa kx ky kz la ij bi translated">当您在延续本地存储中设置值时，在从原始函数调用的所有函数(同步或异步)执行完毕之前，这些值是可访问的。这包括传递给<code class="fe ml mm mn mo b">process.nextTick</code>和<a class="ae mk" href="https://nodejs.org/api/timers.html" rel="noopener ugc nofollow" target="_blank">定时器函数</a> ( <a class="ae mk" href="https://nodejs.org/api/timers.html#timers_setimmediate_callback_arg" rel="noopener ugc nofollow" target="_blank"> setImmediate </a>、<a class="ae mk" href="https://nodejs.org/api/timers.html#timers_settimeout_callback_delay_arg" rel="noopener ugc nofollow" target="_blank"> setTimeout </a>和<a class="ae mk" href="https://nodejs.org/api/timers.html#timers_setinterval_callback_delay_arg" rel="noopener ugc nofollow" target="_blank"> setInterval </a>)的回调，以及传递给调用本机函数的异步函数的回调(如从<code class="fe ml mm mn mo b">fs</code>、<code class="fe ml mm mn mo b">dns</code>、<code class="fe ml mm mn mo b">zlib</code>和<code class="fe ml mm mn mo b">crypto</code>模块导出的回调)。</p></blockquote><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi pb"><img src="../Images/a64aeab670341c852348ce21012bb13a.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*zpyUnWxz2_uIn2A2usAi3Q.gif"/></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk translated">我第一次发现CLS的时候…</figcaption></figure><p id="a4aa" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">重新定义我们的请求ID中间件，我们将得到类似于:</p><pre class="lc ld le lf gt nm mo nn no aw np bi"><span id="6f3e" class="nq mq iq mo b gy nr ns l nt nu">import { createNamespace } from 'cls-hooked';<br/>import cuid from 'cuid';</span><span id="f3c5" class="nq mq iq mo b gy nv ns l nt nu">const loggerNamespace = createNamespace('logger');</span><span id="d379" class="nq mq iq mo b gy nv ns l nt nu">function clsRequestId(namespace, generateId) {<br/>  return (req, res, next) =&gt; {<br/>    const reqId = req.get('X-Request-Id') || generateId();<br/>    res.set('X-RequestId', reqId);</span><span id="37f9" class="nq mq iq mo b gy nv ns l nt nu">    namespace.run(() =&gt; {<br/>      namespace.set('requestId', reqId);</span><span id="1dfb" class="nq mq iq mo b gy nv ns l nt nu">      next();<br/>    });<br/>  };<br/>}</span><span id="5a90" class="nq mq iq mo b gy nv ns l nt nu">app.use(clsRequestId(loggerNamespace, cuid));</span></pre><p id="0162" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">分解一下:</p><ul class=""><li id="fe38" class="oh oi iq kh b ki kj kl km ko pc ks pd kw pe la om on oo op bi translated"><strong class="kh ir">名称空间</strong>大致相当于关系数据库中的表或文档存储中的集合/键空间的CLS。要创建一个，我们只需要将它标识为一个字符串。</li><li id="8d92" class="oh oi iq kh b ki oq kl or ko os ks ot kw ou la om on oo op bi translated">我们的“高阶”中间件<code class="fe ml mm mn mo b">clsRequestId</code>现在需要两个参数:名称空间和ID生成器函数。</li><li id="6ac5" class="oh oi iq kh b ki oq kl or ko os ks ot kw ou la om on oo op bi translated"><code class="fe ml mm mn mo b">namespace.run</code>是创建新上下文的函数，绑定到执行“线程”。</li><li id="c43b" class="oh oi iq kh b ki oq kl or ko os ks ot kw ou la om on oo op bi translated"><code class="fe ml mm mn mo b">namespace.set</code>将请求ID放入本地存储。</li><li id="1969" class="oh oi iq kh b ki oq kl or ko os ks ot kw ou la om on oo op bi translated"><code class="fe ml mm mn mo b">next</code>将调用下一个快递处理员。<strong class="kh ir">重要提示:</strong>为了让这个工作正常进行，必须在<code class="fe ml mm mn mo b">namespace.run</code>回调函数内部调用<code class="fe ml mm mn mo b">next</code>。</li></ul><p id="95ae" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，每当我们需要访问这个值时，我们可以使用来自<code class="fe ml mm mn mo b">cls-hooked</code>的<code class="fe ml mm mn mo b">getNamespace</code>:</p><pre class="lc ld le lf gt nm mo nn no aw np bi"><span id="de2f" class="nq mq iq mo b gy nr ns l nt nu">import { getNamespace } from 'cls-hooked';<br/>import pino from 'pino';</span><span id="95a8" class="nq mq iq mo b gy nv ns l nt nu">const logger = pino();<br/>loggerNamespace = getNamespace('logger');</span><span id="acda" class="nq mq iq mo b gy nv ns l nt nu">function doStuff() {<br/>    // ...<br/>    logger.info({ requestId: loggerNamespace.get('requestId') }, "Some message");<br/>}</span></pre><p id="3c1a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果函数<code class="fe ml mm mn mo b">doStuff</code>调用最终源自注册了该<code class="fe ml mm mn mo b">clsRequestId</code>中间件的express应用程序的一个处理程序，则该值将可用。</p><p id="6f1d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">把所有东西放在一起:</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="pf pg l"/></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk translated">一个有点做作的例子，但说明了一点…</figcaption></figure><p id="44b5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是用<a class="ae mk" href="https://github.com/mcollina/autocannon" rel="noopener ugc nofollow" target="_blank">auto canon</a>生成的示例输出:</p><pre class="lc ld le lf gt nm mo nn no aw np bi"><span id="77ee" class="nq mq iq mo b gy nr ns l nt nu">$ autocannon -c 2 -a 5 -r 1 http://localhost:4004/</span><span id="cd32" class="nq mq iq mo b gy nv ns l nt nu">{"level":30,"time":1533759930690,"msg":"App is running!","pid":4985,"hostname":"henrique-pc","endpoint":"<a class="ae mk" href="http://localhost:4000" rel="noopener ugc nofollow" target="_blank">http://localhost:4000</a>","v":1}<br/>{"level":30,"time":1533759933634,"msg":"Before","pid":4985,"hostname":"henrique-pc",<strong class="mo ir">"requestId":"cjkll2awx0000uhwg9qh20e0b"</strong>,"v":1}<br/>{"level":30,"time":1533759933636,"msg":"Before","pid":4985,"hostname":"henrique-pc",<strong class="mo ir">"requestId":"cjkll2awz0001uhwgoyiptfxv"</strong>,"v":1}<br/>{"level":30,"time":1533759935531,"msg":"Middle","pid":4985,"hostname":"henrique-pc",<strong class="mo ir">"requestId":"cjkll2awz0001uhwgoyiptfxv"</strong>,"v":1}<br/>{"level":30,"time":1533759939590,"msg":"Middle","pid":4985,"hostname":"henrique-pc",<strong class="mo ir">"requestId":"cjkll2awx0000uhwg9qh20e0b"</strong>,"v":1}<br/>{"level":30,"time":1533759941222,"msg":"After","pid":4985,"hostname":"henrique-pc",<strong class="mo ir">"requestId":"cjkll2awz0001uhwgoyiptfxv"</strong>,"v":1}<br/>{"level":30,"time":1533759941228,"msg":"Before","pid":4985,"hostname":"henrique-pc",<strong class="mo ir">"requestId":"cjkll2grw0002uhwgzz14qyb6"</strong>,"v":1}<br/>{"level":30,"time":1533759943632,"msg":"Before","pid":4985,"hostname":"henrique-pc",<strong class="mo ir">"requestId":"cjkll2imo0003uhwgf4dutgz3"</strong>,"v":1}<br/>{"level":30,"time":1533759946244,"msg":"Middle","pid":4985,"hostname":"henrique-pc",<strong class="mo ir">"requestId":"cjkll2grw0002uhwgzz14qyb6"</strong>,"v":1}<br/>{"level":30,"time":1533759949490,"msg":"After","pid":4985,"hostname":"henrique-pc",<strong class="mo ir">"requestId":"cjkll2awx0000uhwg9qh20e0b"</strong>,"v":1}<br/>{"level":30,"time":1533759951621,"msg":"Middle","pid":4985,"hostname":"henrique-pc",<strong class="mo ir">"requestId":"cjkll2imo0003uhwgf4dutgz3"</strong>,"v":1}<br/>{"level":30,"time":1533759952464,"msg":"After","pid":4985,"hostname":"henrique-pc",<strong class="mo ir">"requestId":"cjkll2grw0002uhwgzz14qyb6"</strong>,"v":1}<br/>{"level":30,"time":1533759953632,"msg":"Before","pid":4985,"hostname":"henrique-pc",<strong class="mo ir">"requestId":"cjkll2qcg0004uhwgnmgztdr7"</strong>,"v":1}<br/>{"level":30,"time":1533759954665,"msg":"Middle","pid":4985,"hostname":"henrique-pc",<strong class="mo ir">"requestId":"cjkll2qcg0004uhwgnmgztdr7"</strong>,"v":1}<br/>{"level":30,"time":1533759955140,"msg":"After","pid":4985,"hostname":"henrique-pc",<strong class="mo ir">"requestId":"cjkll2imo0003uhwgf4dutgz3"</strong>,"v":1}<br/>{"level":30,"time":1533759957183,"msg":"After","pid":4985,"hostname":"henrique-pc",<strong class="mo ir">"requestId":"cjkll2qcg0004uhwgnmgztdr7"</strong>,"v":1}</span></pre><p id="bdd5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您仔细观察，您会发现，尽管logger函数的调用顺序是非线性的，但是每个不同请求的<code class="fe ml mm mn mo b">requestId</code>都是保留的。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi pb"><img src="../Images/195991e66554a99104000aa232a1b3d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*XHiOBAgcGjHBX0qRBTlrXA.gif"/></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk translated">这完全是胡说八道！</figcaption></figure><p id="0868" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，每当您想单独查看单个请求的日志时，您可以再次使用<code class="fe ml mm mn mo b">jq</code>并运行:</p><pre class="lc ld le lf gt nm mo nn no aw np bi"><span id="e5b2" class="nq mq iq mo b gy nr ns l nt nu">jq 'select(.requestId == "cjkll2qcg0004uhwgnmgztdr7")' &lt;log_file&gt;</span></pre><p id="16e3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">输出将是:</p><pre class="lc ld le lf gt nm mo nn no aw np bi"><span id="170f" class="nq mq iq mo b gy nr ns l nt nu">{<br/>  "level": 30,<br/>  "time": 1533759953632,<br/>  "msg": "Before",<br/>  "pid": 4985,<br/>  "hostname": "henrique-pc",<br/>  "requestId": "cjkll2qcg0004uhwgnmgztdr7",<br/>  "v": 1<br/>}<br/>{<br/>  "level": 30,<br/>  "time": 1533759954665,<br/>  "msg": "Middle",<br/>  "pid": 4985,<br/>  "hostname": "henrique-pc",<br/>  "requestId": "cjkll2qcg0004uhwgnmgztdr7",<br/>  "v": 1<br/>}<br/>{<br/>  "level": 30,<br/>  "time": 1533759957183,<br/>  "msg": "After",<br/>  "pid": 4985,<br/>  "hostname": "henrique-pc",<br/>  "requestId": "cjkll2qcg0004uhwgnmgztdr7",<br/>  "v": 1<br/>}</span></pre><h1 id="ecaf" class="mp mq iq bd mr ms mt mu mv mw mx my mz jw na jx nb jz nc ka nd kc ne kd nf ng bi translated">进一步的改进</h1><p id="973b" class="pw-post-body-paragraph kf kg iq kh b ki nh jr kk kl ni ju kn ko nj kq kr ks nk ku kv kw nl ky kz la ij bi translated">虽然这个故事中呈现的结构是可行的，但对于日常使用来说并不实用。像上面的示例代码一样，手动获取名称空间并检索所有需要的值是非常乏味的:</p><pre class="lc ld le lf gt nm mo nn no aw np bi"><span id="c79a" class="nq mq iq mo b gy nr ns l nt nu">const namespace = getNamespace('logger');                                                 logger.info({ requestId: namespace.get('requestId') }, 'Before')</span></pre><p id="7a80" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下次我们将围绕<code class="fe ml mm mn mo b">pino</code>构建一个包装器来透明地处理所有这些。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi ph"><img src="../Images/a745dee3ac3b2ad6fcf07e7695b3b132.png" data-original-src="https://miro.medium.com/v2/resize:fit:476/format:webp/1*IMKw5BAXSjFTA1dy9TAeSg.jpeg"/></div></figure><p id="f318" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">再见！</p></div><div class="ab cl pi pj hu pk" role="separator"><span class="pl bw bk pm pn po"/><span class="pl bw bk pm pn po"/><span class="pl bw bk pm pn"/></div><div class="ij ik il im in"><p id="e1bc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你喜欢你刚刚读的吗？用<a class="ae mk" href="https://tippin.me/@hbarcelos909" rel="noopener ugc nofollow" target="_blank"> tippin.me </a>给我买啤酒。</p></div></div>    
</body>
</html>