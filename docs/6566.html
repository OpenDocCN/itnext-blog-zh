<html>
<head>
<title>The Power of Golang Keyword "defer"</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Golang关键字“推迟”的力量</h1>
<blockquote>原文：<a href="https://itnext.io/the-power-of-golang-keyword-defer-b31bdecf10b6?source=collection_archive---------4-----------------------#2021-12-19">https://itnext.io/the-power-of-golang-keyword-defer-b31bdecf10b6?source=collection_archive---------4-----------------------#2021-12-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jv jw jx jy gh gi paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="gh gi ju"><img src="../Images/b9bf851594c1003219bb9ce9cc82bf85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fG3Y5b8F8hTAcLS5bBurjA.jpeg"/></div></div><figcaption class="kf kg gj gh gi kh ki bd b be z dk translated">照片由<a class="ae kj" href="https://unsplash.com/@karim_manjra?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">卡里姆·曼吉拉</a>在<a class="ae kj" href="https://unsplash.com/s/photos/procrastination?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="39b7" class="pw-post-body-paragraph kk kl it km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">Golang是我现在最喜欢的编程语言之一。它像C一样简单，但像JavaScript一样强大，像Python一样可组合。在过去的三年里，Golang取代Python和Bash成为我最喜欢的“我需要拼凑一个脚本”语言——我经常用它构建小型到企业级的应用程序。</p><p id="0362" class="pw-post-body-paragraph kk kl it km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">我的大学教授一直教导我，一个功能应该只负责一项任务。使用C作为我的第二个“日常”编程语言，我经常遇到再次退出函数时不能释放句柄的问题。所以一个常见的函数是:</p><pre class="li lj lk ll gt lm jt ln lo aw lp bi"><span id="fdf4" class="lq lr it jt b gy ls lt l lu lv">func letsDoSomething() {<br/>    handle := openHandle()</span><span id="2cd0" class="lq lr it jt b gy lw lt l lu lv">    // Do something with the handle<br/>    data := read(handle)</span><span id="c0b9" class="lq lr it jt b gy lw lt l lu lv">    // Do something with the data<br/>    ...</span><span id="50b9" class="lq lr it jt b gy lw lt l lu lv">    // We are done - close handle again<br/>    closeHandle(handle)<br/>}</span></pre><p id="10be" class="pw-post-body-paragraph kk kl it km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">老实说，你多久会忘记关上把手一次？假设您有一个包含多个return语句的函数，您需要在每个return语句之前多次释放句柄。</p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="1672" class="me lr it bd mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na bi translated">推迟救援</h1><p id="1f08" class="pw-post-body-paragraph kk kl it km b kn nb kp kq kr nc kt ku kv nd kx ky kz ne lb lc ld nf lf lg lh im bi translated">现在Golang有一个关键词叫<code class="fe jq jr js jt b">defer</code>。<code class="fe jq jr js jt b">defer</code>推迟一个函数的执行，直到周围的函数退出。所以在我们的例子中，我们可以写:</p><pre class="li lj lk ll gt lm jt ln lo aw lp bi"><span id="6d7c" class="lq lr it jt b gy ls lt l lu lv">func letsDoSomething() {<br/>    handle := openHandle()</span><span id="493c" class="lq lr it jt b gy lw lt l lu lv">    // Let's close the handle once we exit the function<br/>    defer closeHandle(handle)</span><span id="c9c9" class="lq lr it jt b gy lw lt l lu lv">    // Do something with the handle<br/>    data := read(handle)</span><span id="259b" class="lq lr it jt b gy lw lt l lu lv">    // Do something with the data<br/>    ...<br/>}</span></pre><p id="b47a" class="pw-post-body-paragraph kk kl it km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">现在——什么改变了？就代码行而言？没什么。但是我们将执行<code class="fe jq jr js jt b">closeHandle</code>推迟到稍后函数退出时。让我们看一个更复杂的例子:</p><pre class="li lj lk ll gt lm jt ln lo aw lp bi"><span id="5f9c" class="lq lr it jt b gy ls lt l lu lv">func letsDoSomething() error {<br/>    handle := openHandle()</span><span id="2f52" class="lq lr it jt b gy lw lt l lu lv">    // Do something with the handle<br/>    data := read(handle)</span><span id="8fbf" class="lq lr it jt b gy lw lt l lu lv">    switch data {<br/>    case "one":<br/>        closeHandle(handle)<br/>        return fmt.Errorf("an error occured")<br/>    case "two":<br/>        ...<br/>    default:<br/>        closeHandle(handle)<br/>        return fmt.Errorf("data can not be used")</span><span id="e1b5" class="lq lr it jt b gy lw lt l lu lv">    closeHandle(handle)<br/>    return nil<br/>}</span></pre><p id="8e6c" class="pw-post-body-paragraph kk kl it km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">现在我们来看一下这里的代码。我们从之前打开的句柄中读取数据。根据数据，我们要么返回一个错误，要么返回零。然而，我们需要在退出函数之前关闭句柄。在这个简单的例子中，我们需要调用<code class="fe jq jr js jt b">closeHandle</code>三次。让我们与使用<code class="fe jq jr js jt b">defer</code>的版本进行比较。</p><pre class="li lj lk ll gt lm jt ln lo aw lp bi"><span id="7577" class="lq lr it jt b gy ls lt l lu lv">func letsDoSomething() error {<br/>    handle := openHandle()</span><span id="fb9f" class="lq lr it jt b gy lw lt l lu lv">    defer closeHandle(handle)</span><span id="3904" class="lq lr it jt b gy lw lt l lu lv">    // Do something with the handle<br/>    data := read(handle)</span><span id="9ad9" class="lq lr it jt b gy lw lt l lu lv">    switch data {<br/>    case "one":<br/>        return fmt.Errorf("an error occured")<br/>    case "two":<br/>        ...<br/>    default:<br/>        return fmt.Errorf("data can not be used")</span><span id="b42b" class="lq lr it jt b gy lw lt l lu lv">    return nil<br/>}</span></pre><p id="0dfe" class="pw-post-body-paragraph kk kl it km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">不是调用<code class="fe jq jr js jt b">closeHandle</code>三次，我们只调用<code class="fe jq jr js jt b">defer closeHandle(handle)</code>一次，Golang会在我们退出函数后负责调用<code class="fe jq jr js jt b">closeHandle</code>。很方便吧？</p><h1 id="ebb0" class="me lr it bd mf mg ng mi mj mk nh mm mn mo ni mq mr ms nj mu mv mw nk my mz na bi translated">好得难以置信——一些陷阱</h1><p id="ef1e" class="pw-post-body-paragraph kk kl it km b kn nb kp kq kr nc kt ku kv nd kx ky kz ne lb lc ld nf lf lg lh im bi translated"><code class="fe jq jr js jt b">defer</code>很有用，但也很棘手。有些陷阱你需要小心。</p><p id="ffad" class="pw-post-body-paragraph kk kl it km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated"><strong class="km iu"> os。Exit() <br/> </strong>我们来看下面的例子:</p><pre class="li lj lk ll gt lm jt ln lo aw lp bi"><span id="a9e5" class="lq lr it jt b gy ls lt l lu lv">package main</span><span id="4260" class="lq lr it jt b gy lw lt l lu lv">import (<br/> "fmt"<br/>)</span><span id="c5e4" class="lq lr it jt b gy lw lt l lu lv">func main() {</span><span id="a50d" class="lq lr it jt b gy lw lt l lu lv">    defer func() {<br/>        fmt.Println("Defer")<br/>    }()</span><span id="eea4" class="lq lr it jt b gy lw lt l lu lv">    fmt.Println("Main Function")<br/>}</span></pre><p id="95a2" class="pw-post-body-paragraph kk kl it km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">当运行这个简单的例子时，我们确实看到了我们所期望的</p><figure class="li lj lk ll gt jy gh gi paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="gh gi nl"><img src="../Images/e152122dbfe00bdf6f2aa8fa153f17b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sYNwHIs_mU3V-1y2Gj9ZBg.png"/></div></div><figcaption class="kf kg gj gh gi kh ki bd b be z dk translated">上面代码的输出</figcaption></figure><p id="5279" class="pw-post-body-paragraph kk kl it km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">现在让我们添加一行:</p><pre class="li lj lk ll gt lm jt ln lo aw lp bi"><span id="2bd5" class="lq lr it jt b gy ls lt l lu lv">package main</span><span id="207e" class="lq lr it jt b gy lw lt l lu lv">import (<br/> "fmt"<br/> "os"<br/>)</span><span id="06f5" class="lq lr it jt b gy lw lt l lu lv">func main() {</span><span id="9e3e" class="lq lr it jt b gy lw lt l lu lv">    defer func() {<br/>        fmt.Println("Defer")<br/>    }()</span><span id="8864" class="lq lr it jt b gy lw lt l lu lv">    fmt.Println("Main Function")</span><span id="a950" class="lq lr it jt b gy lw lt l lu lv">    os.Exit(1)</span><span id="9e6c" class="lq lr it jt b gy lw lt l lu lv">}</span></pre><p id="c767" class="pw-post-body-paragraph kk kl it km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">现在输出变成了:</p><figure class="li lj lk ll gt jy gh gi paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="gh gi nm"><img src="../Images/db9c42e4c887caf03bcf0fcf14ce442d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RddaZbL5s0sx_bmrK_Oqiw.png"/></div></div><figcaption class="kf kg gj gh gi kh ki bd b be z dk translated">带有操作系统的代码的输出。出口(1)</figcaption></figure><p id="c6e4" class="pw-post-body-paragraph kk kl it km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">这是意料之外的。貌似我们调用<code class="fe jq jr js jt b">os.Exit(1)</code>的时候<code class="fe jq jr js jt b">defer</code>不会被执行。当我们查看https://pkg.go.dev/os#Exit<a class="ae kj" href="https://pkg.go.dev/os#Exit" rel="noopener ugc nofollow" target="_blank">的文件时，上面写着</a></p><blockquote class="nn no np"><p id="086c" class="kk kl nq km b kn ko kp kq kr ks kt ku nr kw kx ky ns la lb lc nt le lf lg lh im bi translated">程序立即终止；延迟功能不会运行。</p></blockquote><p id="4777" class="pw-post-body-paragraph kk kl it km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">好吧——有道理。但是还有什么呢？</p><figure class="li lj lk ll gt jy gh gi paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="gh gi gj"><img src="../Images/5ea69b83e35003c22b2085e726e0f99e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lVGGTLq3kRv17JLuQ01kMg.jpeg"/></div></div><figcaption class="kf kg gj gh gi kh ki bd b be z dk translated">史蒂夫·乔布斯</figcaption></figure><p id="309f" class="pw-post-body-paragraph kk kl it km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">对<code class="fe jq jr js jt b">os.Exit</code>成立的适用于每个立即返回的函数。最常见的功能是:</p><ul class=""><li id="f51e" class="nu nv it km b kn ko kr ks kv nw kz nx ld ny lh nz oa ob oc bi translated">日志。致命/日志。Fatalf</li></ul></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><p id="756b" class="pw-post-body-paragraph kk kl it km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated"><code class="fe jq jr js jt b">defer</code>非常有用，在处理文件、句柄或任何使用后需要手动清理的东西时，可以让你省去一些头痛。它消除了代码重复，使您的代码更加易读和简洁。在使用它的时候，你需要注意一些小陷阱。</p></div></div>    
</body>
</html>