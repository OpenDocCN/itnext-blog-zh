<html>
<head>
<title>From Monoliths To Microservices</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从整体到微服务</h1>
<blockquote>原文：<a href="https://itnext.io/from-monoliths-to-microservices-b6b851ab43e3?source=collection_archive---------2-----------------------#2018-02-25">https://itnext.io/from-monoliths-to-microservices-b6b851ab43e3?source=collection_archive---------2-----------------------#2018-02-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/6a780ce5aca8b93daa3181a8e3a3f61c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Z2mA0RZ6y_h7TWZF."/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated"><a class="ae jd" href="https://unsplash.com/@jeremythomasphoto?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">杰瑞米·托马斯</a>在<a class="ae jd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的《文图拉岩滩上用卵石塔平衡石头》</figcaption></figure><div class=""/><div class=""><h2 id="2013" class="pw-subtitle-paragraph kd jf jg bd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dk translated">只需三个简单的步骤</h2></div><p id="eeee" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><a class="ae jd" href="https://www.linkedin.com/cws/share?url=https%3A%2F%2Fitnext.io%2Ffrom-monoliths-to-microservices-b6b851ab43e3" rel="noopener ugc nofollow" target="_blank"> <em class="lr">点击这里在LinkedIn上分享这篇文章</em> </a></p><p id="a370" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">比方说，在某个阳光明媚的日子，你被要求帮助开发一个现有的应用程序，并让它“<em class="lr">你知道，就像微服务一样”。</em></p><p id="2c67" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后你意识到这个应用程序是一个几年前的基于Java的庞然大物，作为一个<em class="lr"> war </em>文件部署在一个不再热门的应用服务器上，或者它是一个大约2006 <em class="lr"> Lamp </em>堆栈中的PHP应用程序，或者任何其他做很多事情的应用程序，有很多活动的部分，在一些看不见但仁慈的神的帮助下，似乎只是为了一个纯粹的偶然事件而工作。</p><p id="daa4" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">通常，您还会发现，所有这些都是在一个整体代码存储库中提供的，其中的一些部分已经很多年没有使用过了，没有人真正确定它们是否还在使用。但是“你问过弗兰克了吗？”</p><p id="83cd" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">此外，因为monoliths l <a class="ae jd" href="http://gph.is/1DzWYFR" rel="noopener ugc nofollow" target="_blank">长久而繁荣</a>，它们将运行在精心设计的<a class="ae jd" href="http://etherealmind.com/cattle-vs-kittens-on-cloud-platforms-no-one-hears-the-kittens-dying/" rel="noopener ugc nofollow" target="_blank">小型服务器</a>上，这些服务器多年来一直由IT部门充满爱心地管理，每个服务器都有众所周知的名字和固定的IP地址，并且<em class="lr">“请你不要改变这一点！”</em></p><blockquote class="ls lt lu"><p id="8b38" class="kv kw lr kx b ky kz kh la lb lc kk ld lv lf lg lh lw lj lk ll lx ln lo lp lq ij bi translated">在那个阳光明媚的日子里，你最终会开始看到地平线上的乌云迅速逼近，听到远处传来熟悉的隆隆雷声。或者也许你会注意到一股不祥的雾气从地面悄然升起。但是不要害怕，继续读下去。有一条路…</p></blockquote><p id="242a" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">哦，如果你想知道，这不是纯粹的假设。这是我在过去几年里一直在做的事情，我认为我在这方面做得越来越好。实际上，比我想的要好得多，我将分享我的(公认的固执己见的)经验，供某一天可能会发现它有用的读者。</p><p id="bc66" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了让它更有针对性，我会经常提到基于Java或JVM的monoliths，因为我最了解它们，并且许多企业软件都是在JVM上构建的——但是同样的原理也适用于任何东西。</p><p id="25c3" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">诀窍很简单:<em class="lr">集装箱化</em>，<em class="lr">编排</em>，<em class="lr">扼杀</em>。前两步主要是为你提供一种更快迭代到第三步的方法，即<em class="lr">扼杀</em>的那一步。我知道，这听起来有点残忍，<a class="ae jd" href="https://www.martinfowler.com/bliki/StranglerApplication.html" rel="noopener ugc nofollow" target="_blank"> <em class="lr">但是振作起来，这是一个比喻。</em>T11】</a></p><p id="0f0d" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在继续之前，我真的需要在这里添加一些东西。独石有很好的存在理由:它们已经在那里，在生产中运行，由运营团队监控和管理。整块<em class="lr">正在生产</em>。你所要做的就是提交你的代码并添加新的特性，最终，其他人会负责部署它。这是在生产中启动一个新应用程序的摩擦导致的整体悖论，摩擦越大，整体就变得越大。整体越大，就越难频繁推出新功能。</p><p id="72d2" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，让我们开始吧。</p><h1 id="e571" class="ly lz jg bd ma mb mc md me mf mg mh mi km mj kn mk kp ml kq mm ks mn kt mo mp bi translated">第一步:集装箱化</h1><figure class="mr ms mt mu gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mq"><img src="../Images/36b0885ed4d06d1d015fbecda49c4433.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jyrxlBfa13lwxbeq."/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated"><a class="ae jd" href="https://unsplash.com/@guibolduc?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Guillaume Bolduc </a>在<a class="ae jd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上创作的“一堆集装箱形成了一个彩色图案”</figcaption></figure><p id="342a" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">多克是你的朋友。真的。</p><p id="9fb7" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果应用程序运行在某个linux服务器上，那么很有可能你可以让它在Docker中运行。从<a class="ae jd" href="https://hub.docker.com/" rel="noopener ugc nofollow" target="_blank"> <em class="lr"> DockerHub </em> </a>中挑选一个信誉良好的基础形象。往往最简单的方法就是只google <em class="lr"> dockerhub </em>和你想要的语言或者运行时环境，说<a class="ae jd" href="https://www.google.com/search?q=dockerhub+openjdk" rel="noopener ugc nofollow" target="_blank"> <em class="lr"> openjdk </em> </a>(对，不是java)或者<a class="ae jd" href="https://www.google.com/search?q=dockerhub+php" rel="noopener ugc nofollow" target="_blank"> <em class="lr"> php </em> </a>或者<a class="ae jd" href="https://www.google.com/search?q=dockerhub+apache" rel="noopener ugc nofollow" target="_blank"> <em class="lr"> apache </em> </a> <em class="lr">。</em></p><blockquote class="ls lt lu"><p id="95bf" class="kv kw lr kx b ky kz kh la lb lc kk ld lv lf lg lh lw lj lk ll lx ln lo lp lq ij bi translated">读者请注意:如果你是docker的新手，可能是时候继续搜索和学习Docker最佳实践<a class="ae jd" href="https://www.google.com/search?q=docker+best+practices" rel="noopener ugc nofollow" target="_blank"><em class="jg"/></a><em class="jg">。有这么多好的来源，一篇中型文章可能对你来说是不够的。但是你可以把这个加入书签。</em></p></blockquote><p id="131c" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">尽可能保持简单——勇敢一点。不要理会那些会说“<em class="lr">比那个</em>复杂”的人。经常会有年复一年的积累使它变得复杂。你想让它变得更简单。继续走。会有用的。</p><p id="876f" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">你的目标是理解应用程序如何在<em class="lr">生产</em>中运行，而不是在<em class="lr">开发</em>或<em class="lr">试运行</em>或某人的<em class="lr"> IntelliJ </em>或<em class="lr"> Eclipse </em>中运行。如果它是由一个做了很多事情的超级复杂的脚本启动的，只需<em class="lr"> ssh </em>进入生产服务器，并运行<code class="fe mv mw mx my b">ps auxwww|grep java</code>(如果它是一个java应用程序)来查看启动脚本中的所有复杂性最终会达到什么目的(提示，一长串开关和命令行参数)。您还需要查看启动脚本是否在进程中注入了其他东西，比如环境变量，然后只需使用<code class="fe mv mw mx my b">cat /proc/&lt;pid&gt;/environ</code>，其中pid是您通过上面的<code class="fe mv mw mx my b">ps</code>命令获得的。毕竟，Linux是一个好朋友。</p><blockquote class="ls lt lu"><p id="232f" class="kv kw lr kx b ky kz kh la lb lc kk ld lv lf lg lh lw lj lk ll lx ln lo lp lq ij bi translated">(请读者注意:为了方便复制和粘贴，所有截图都链接到一个Github要点)。</p></blockquote><figure class="mr ms mt mu gt is gh gi paragraph-image"><a href="https://gist.github.com/alessandrobologna/4cb81899636d9b523b6eecf491b3510c"><div class="gh gi mz"><img src="../Images/eee4ba4ce7db80e99f754949bd775bc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FPqFwwwplA4jCyewwx3w-g.png"/></div></a><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated"><a class="ae jd" href="https://gist.github.com/alessandrobologna/4cb81899636d9b523b6eecf491b3510c" rel="noopener ugc nofollow" target="_blank">简单的docker entrypoint脚本</a></figcaption></figure><p id="2648" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">编写一个简单的<code class="fe mv mw mx my b">docker-entrypoint.sh</code>脚本来启动这个过程(使用<code class="fe mv mw mx my b">exec</code>，这样您就可以接收来自docker的信号)，并确保您在运行时根据应用程序运行的阶段设置了正确的标志或环境变量。还要确保应用程序需要的每个配置都是从环境中获取的，作为<em class="lr">环境变量</em>，而不是硬编码在映像中。在Docker中，您希望所有环境都有一个单一的映像。</p><p id="8020" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">理想情况下，您的docker文件应该像这个文件一样简单，简单地从一个基本映像继承并复制映像中的可执行代码:</p><figure class="mr ms mt mu gt is gh gi paragraph-image"><a href="https://gist.github.com/alessandrobologna/4e019ed8e8909be53a31528f25c746b1"><div class="gh gi mz"><img src="../Images/31875a494680ff2e2684ce286aa3604a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wPmdG3FgQCXnmisaWnoldg.png"/></div></a><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated"><a class="ae jd" href="https://gist.github.com/alessandrobologna/4e019ed8e8909be53a31528f25c746b1" rel="noopener ugc nofollow" target="_blank">简单的Dockerfile </a></figcaption></figure><p id="5302" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在某些情况下，你需要给图像添加一些其他的包，但是<em class="lr">抵制住把厨房水槽倒在那里的诱惑</em>。这是一种反模式。记住，应该是<em class="lr">简单的</em>。一个docker映像，一个进程，pid为<em class="lr">1，运行所需的资源最少。</em></p><p id="1ef9" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">既然您已经接触了Docker，那么您可能希望将构建工具容器化，以编译您的应用程序可执行文件。如果您的依赖项只是docker映像，并且您不必确保它们在CI/CD提供商的正确版本中可用，那么当您构建持续集成/持续部署管道(简称CI/CD)时，它将会派上用场。</p><p id="96b6" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">例如，如果你只需要Maven(除了<a class="ae jd" href="https://www.youtube.com/watch?v=dsxtImDVMig" rel="noopener ugc nofollow" target="_blank"> <em class="lr">爱</em> </a>)来编译你的monolith，这里有一行程序:</p><pre class="mr ms mt mu gt na my nb nc aw nd bi"><span id="9c92" class="ne lz jg my b gy nf ng l nh ni">docker run -v $PWD:/src -w /src -v $M2_HOME:/root/.m2 maven:3.5.2-slim mvn package</span></pre><p id="4998" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">它将编译您的工件并将其放到您的本地<code class="fe mv mw mx my b">target</code>目录中。很简单，比如“看妈妈，不用手”。</p><p id="134f" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在有趣的部分来了，看看现在包含的巨石是否敢开始:</p><pre class="mr ms mt mu gt na my nb nc aw nd bi"><span id="6969" class="ne lz jg my b gy nf ng l nh ni">docker build -t scary-monolith . &amp;&amp; docker run scary-monolith</span></pre><p id="ff80" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">相信我，这不会是第一次。也许你的<code class="fe mv mw mx my b">docker-entrypoint.sh</code>需要更多的爱。也许应用程序<em class="lr">确实需要安装imagemagick】。不要放弃。修复，冲洗，重复。</em></p><p id="0dca" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最终，可能在不到一天的时间里，这个疯狂复杂的庞然大物，除了在一个精心打扮的小猫服务器上运行，没有人会梦想在任何地方运行，将会软化，并将在你的容器上，在你的2016年MacBook Pro上运行，甚至在Windows上运行(如果必须的话)。</p><p id="56a9" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">是的，它可能会抱怨没有数据库，或者<em class="lr"> memcache </em>，或者<em class="lr"> redis </em>，它会在日志中大发脾气，但是它就在那里，并且正在运行。你屠龙了。</p><p id="a6aa" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在是时候在一个有数据库的环境中测试它了，或者需要运行的任何东西。是的，你可以走docker-compose  的路，但是你需要幸运地找到一种方法来用一组有意义的数据填充这些数据源，而通常情况并非如此。因此，您最好的选择可能是根据您的试运行环境进行测试。标记并推送图像s <em class="lr"> cary-monolith </em>到一个私有的docker注册表，很可能在你自己的云提供商上，然后从任何可以运行它的地方运行它，甚至是你的staging <em class="lr"> VPC </em>中的<em class="lr"> EC2 </em>实例。</p><p id="a922" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这一点上，如果它按照您的预期运行，您可能会尝试将docker run命令添加到您的<code class="fe mv mw mx my b">/etc/rc.local</code>中，并使用<em class="lr">木偶</em>或<em class="lr">主厨</em>或类似的东西来管理部署，但不要这样做。有比这更好的解决方案，这只是第一步。给自己一个祝贺的击掌，带你的同事去喝一杯来庆祝。实至名归。</p></div><div class="ab cl nj nk hu nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="ij ik il im in"><h1 id="b142" class="ly lz jg bd ma mb nq md me mf nr mh mi km ns kn mk kp nt kq mm ks nu kt mo mp bi translated">第二步:编排</h1><figure class="mr ms mt mu gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nv"><img src="../Images/6cbed621f79433ba61cfa6ecbde0bae7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hgHwFe9nL-bHQ4lC."/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">由<a class="ae jd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>的<a class="ae jd" href="https://unsplash.com/@larisabirta?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Larisa Birta </a>拍摄的“一群音乐家演奏弦乐器的模糊镜头”</figcaption></figure><p id="881b" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">容器编排系统就像汽车的道路(和交通灯),没有它们，你的旅程将会崎岖不平，你不会走远，所以你需要一个好的系统。</p><p id="79c0" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">您还需要开始构建一个可以使用它的CI/CD管道，因为很快您还需要快速迭代代码更改。没有它，你永远也不能成功。我保证。</p><p id="597e" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">你可以使用<a class="ae jd" href="https://circleci.com/" rel="noopener ugc nofollow" target="_blank"> <em class="lr"> CircleCI </em> </a>，<a class="ae jd" href="https://travis-ci.com/" rel="noopener ugc nofollow" target="_blank"> <em class="lr"> Travis </em> </a>或者你可以只使用<a class="ae jd" href="https://aws.amazon.com/codebuild/" rel="noopener ugc nofollow" target="_blank"> <em class="lr"> AWS Codebuild </em> </a>如果你使用<a class="ae jd" href="https://github.com/alessandrobologna/aws-codebuild-git" rel="noopener ugc nofollow" target="_blank"> <em class="lr">这个项目</em> </a>来入门(是的，这是一个无耻的外挂)。</p><p id="6f43" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">对于编配，有很多选项，来自各种供应商，但现在是2018年，主角是<a class="ae jd" href="https://kubernetes.io/" rel="noopener ugc nofollow" target="_blank"><em class="lr">【Kubernetes】</em></a><em class="lr"/>(或简称为<em class="lr"><a class="ae jd" href="https://kubernetes.io/docs/concepts/overview/what-is-kubernetes/#what-does-kubernetes-mean-k8s" rel="noopener ugc nofollow" target="_blank"><em class="lr">K8s)。</em>可能有些情况下你可以合理地选择另一个(我也喜欢AWS上的</a><a class="ae jd" href="https://aws.amazon.com/ecs/" rel="noopener ugc nofollow" target="_blank"> <em class="lr">亚马逊ECS </em> </a>的简单性)，但是我认为使用其他人似乎也在使用的东西是有意义的。</em></p><p id="013e" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果你的云提供商提供的话，你可以使用他们的托管版Kubernetes，或者如果你想要更多的控制，还有<a class="ae jd" href="https://github.com/kubernetes/kops" rel="noopener ugc nofollow" target="_blank"> <em class="lr"> Kops </em> </a>。在撰写本文时，谷歌云有一个托管解决方案，<a class="ae jd" href="https://cloud.google.com/kubernetes-engine/" rel="noopener ugc nofollow" target="_blank"> GKE </a>，AWS和Azure有一个与<a class="ae jd" href="https://aws.amazon.com/eks/" rel="noopener ugc nofollow" target="_blank"> EKS </a>和<a class="ae jd" href="https://azure.microsoft.com/en-us/services/container-service/" rel="noopener ugc nofollow" target="_blank"> AKS </a>的预览。但是，我也喜欢Kops。</p><p id="579b" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">要在Kubernetes上运行您的monolith，最起码，您需要定义一个部署，并且很可能还要为它定义一个服务。您将使用YAML清单文件，并使它们参数化，以便配置参数、环境和应用程序机密可以从您的CI/CD管道外部获得。</p><figure class="mr ms mt mu gt is gh gi paragraph-image"><a href="https://gist.github.com/alessandrobologna/aa5959c4fab77c72d4c7ff9bcb7acce3"><div class="gh gi nw"><img src="../Images/e01c0eaec03465cdaa724a4c192fb8c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YTAIM3y2hFmLVFIzxPG7DQ.png"/></div></a><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated"><a class="ae jd" href="https://gist.github.com/alessandrobologna/aa5959c4fab77c72d4c7ff9bcb7acce3" rel="noopener ugc nofollow" target="_blank">简单K8s部署文件</a></figcaption></figure><p id="355e" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在部署定义文件中，您可以定义应用程序的运行时行为:要执行的实例数量、要运行的容器的关联映像名称、运行状况检查的特征、要为其保留的内存和cpu数量，以及最终要注入容器的环境变量。</p><p id="5d63" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">注意，这个示例文件是参数化的，变量名在{ {双花括号}}中。正如我上面提到的，您通常会使用类似于<a class="ae jd" href="https://pypi.python.org/pypi/envtpl" rel="noopener ugc nofollow" target="_blank"><em class="lr"/></a>或某种<em class="lr"> sed </em>的魔法，在部署期间将它们替换为从您的CI/CD配置中获取的实际值。</p><figure class="mr ms mt mu gt is gh gi paragraph-image"><a href="https://gist.github.com/alessandrobologna/36c9170638865aa13b0c4efed2e02c19"><div class="gh gi mz"><img src="../Images/d1ad068b96c38e13759eaab884aa03d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i2ToW2FCV9p-4OnSPneADQ.png"/></div></a><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated"><a class="ae jd" href="https://gist.github.com/alessandrobologna/36c9170638865aa13b0c4efed2e02c19" rel="noopener ugc nofollow" target="_blank">简单K8s服务模板</a></figcaption></figure><p id="fe0f" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，您新容器化的monolith已经在Kubernetes上启动并运行，您可能希望通过将它与一个服务关联起来，使它对全世界可见(或者至少是它的一个可信子集……)。</p><p id="6eaf" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">请注意，这个例子使用了特定于AWS的注释，但是在其他云提供商上也是类似的。清单将定义一个https服务，并使用AWS弹性负载均衡器(是的，目前经典的一个)将其公开到互联网(这就是0.0.0.0/0的意思)，并将其注册到您的DNS中。</p><p id="958f" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">恭喜你。您刚刚构建了一个基本但有效的示例，该示例将在您的Kubernetes集群的已定义名称空间中部署您的应用程序的3个实例，它们带有一个7级负载平衡器，该平衡器使用来自Amazon Certificate Manager的证书终止TLS，并在您的Route53区域中注册了一个DNS条目。</p><p id="75a5" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Kubernetes还将通过HTTP健康检查来检查您的应用程序的健康状态，并将自动终止任何未能正确响应的实例(Kubernetes的说法是Pod ),并在几秒钟内启动一个新的实例。</p><p id="8145" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">希望所有这些现在都在您的CI/CD管道中运行，并且Kubernetes在每次将Pull请求合并到Github中的master时都透明地部署您的应用程序的新版本。</p><p id="8a48" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">换句话说，您可以用几行代码解决和自动化传统基础设施管理中的大量复杂性。太神奇了。Kubernetes提供了令人难以置信的配置和自动化水平，甚至可以处理最复杂的场景。但那是另一个话题了。</p><p id="3114" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">记住，这仍然是你的独石，是时候做下一件事了。</p></div><div class="ab cl nj nk hu nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="ij ik il im in"><h1 id="ee8a" class="ly lz jg bd ma mb nq md me mf nr mh mi km ns kn mk kp nt kq mm ks nu kt mo mp bi translated">勒死</h1><figure class="mr ms mt mu gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nx"><img src="../Images/47516bdf06fa3f3edd7d833427cef476.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*yYqfzTpg5LvjajiC."/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">塞缪尔·泽勒在<a class="ae jd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="dd15" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">是的，这听起来很刺耳。<a class="ae jd" href="https://read.acloud.guru/if-you-cant-strangle-the-monolith-starve-it-to-death-fcc824d3c82" rel="noopener ugc nofollow" target="_blank">其他人提议饿死巨石，而不是</a>，但这似乎并没有温和多少。</p><p id="d53a" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">扼杀者模式已经在<a class="ae jd" href="https://www.google.com/search?q=strangler+pattern" rel="noopener ugc nofollow" target="_blank">许多不同的地方</a>描述过了，所以我可以说这都是关于<em class="lr">逐渐将功能从整体转移到微服务</em>。对于web和API应用程序，这可以通过去除URI空间的碎片，用基本上由反向代理或API网关组成的东西拦截它们，并逐步将流量迁移到一个或多个新的微服务来实现。对于其他类型的应用，这要视情况而定。</p><p id="76ea" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这第三步与编码、重构、抽象、隔离、模块化、在你的应用领域中寻找那些<em class="lr">有界上下文</em>有很大关系。还记得我说过你需要为你的独石准备一个CI/CD管道吗？这就是原因。</p><p id="d1fa" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果没有第1步和第2步，迁移过程可能需要数十年，而且因为部署在<em class="lr">小猫</em>上的单片集成电路也很脆弱，它可能永远不会完成:在第一次生产事故没有在几分钟内解决的时候，有人，通常是你的老板，会停止迁移项目。</p><p id="6e2b" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">换句话说，在开始构建微服务之前，明智的做法是确保您有一个平台，在这个平台上，整体服务和微服务都可以快速迭代，可以对故障具有弹性，并在第一次检测到问题时尽快恢复。<em class="lr">再多的精心计划也无法防止糟糕的事情发生</em>，但是因为你在这里，有Kubernetes为你哼唱和编排，你可以呼吸。现在，您可以开始考虑如何实际构建您的新架构，这不是一项简单的任务。</p><p id="2940" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">您可能必须处理的一个问题是，如何在您的monolith、其后台数据库和您真正想要的每个微服务的全新数据存储之间保持一致的数据。另一个问题是如何防止你新微服务架构变成一个复杂的、纠缠不清的、最终脆弱的有数百个节点和数千个连接的循环图。</p><p id="fb7b" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">提示:事件来源和CQRS。它显然应该有一个自己的职位。</p></div></div>    
</body>
</html>