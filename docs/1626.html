<html>
<head>
<title>Yes, this is how vue-router guards work &amp; when to use them</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">是的，这就是vue路由器防护的工作方式&amp;何时使用它们</h1>
<blockquote>原文：<a href="https://itnext.io/yes-this-is-how-vue-router-guards-work-when-to-use-them-ed7e34946211?source=collection_archive---------0-----------------------#2018-12-15">https://itnext.io/yes-this-is-how-vue-router-guards-work-when-to-use-them-ed7e34946211?source=collection_archive---------0-----------------------#2018-12-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="e80c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">吼吼吼！圣诞快乐！是的，我知道这太早了，但是，在12月25日之前我不会写任何故事，所以提前祝你圣诞快乐。</p><p id="2cbc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，让我们深入主题:Vue路由器警卫。</p><h2 id="e15b" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">什么是Vue路由器？</h2><p id="443c" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">如果你已经知道答案，跳到下一个标题。对于其他人来说，<strong class="jp ir"> Vue Router </strong>在github上也被称为<strong class="jp ir"> vue-router </strong>，是官方的第三方插件，用于处理Vue JS应用的路由/ URL状态。</p><h2 id="c2e8" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">什么是Vue路由器卫士？</h2><p id="95b2" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">基本上，Vue路由器只根据URL为您切换组件。例如，它不处理对服务器的AJAX调用或基于角色的身份验证保护。为什么？仅仅因为这不是它的初衷。</p><p id="d423" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是！它有<strong class="jp ir">护板</strong>，我们也可以称之为<strong class="jp ir">挂钩</strong>，你可以插在上面。</p><p id="1c91" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Vue路由器有3种防护装置:</p><ul class=""><li id="1fa2" class="lj lk iq jp b jq jr ju jv jy ll kc lm kg ln kk lo lp lq lr bi translated">全局守卫(在实例上)<br/> -每次URL改变<br/> 时这些都被调用<strong class="jp ir">-守卫:<a class="ae ls" href="https://jsfiddle.net/darkylmnx/xo5ra1jt/" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> b </strong> </a> <strong class="jp ir">每次</strong>、<strong class="jp ir">解析</strong>、<strong class="jp ir">每次</strong>之后</strong></li><li id="10d9" class="lj lk iq jp b jq lt ju lu jy lv kc lw kg lx kk lo lp lq lr bi translated">路线守卫(在路线定义上)<br/> -这些仅在相关路线匹配<br/> 时调用<strong class="jp ir">-守卫:<strong class="jp ir">在进入</strong>之前</strong></li><li id="8c3c" class="lj lk iq jp b jq lt ju lu jy lv kc lw kg lx kk lo lp lq lr bi translated">路由组件保护<br/> -这些<strong class="jp ir">仅在路由组件被使用/未被使用时调用<br/> </strong> -保护:<strong class="jp ir"> beforeRouteEnter，beforeRouteUpdate，beforeRouteLeave </strong></li></ul><p id="e3a3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">注</strong>:除了每个后面的<strong class="jp ir">外，所有的防护都是“异步”的。它们是按顺序调用的，因此，你需要显式调用“<strong class="jp ir"> next() </strong>”方法告诉路由器你完成了，他可以继续这个序列。<br/>这也被称为<strong class="jp ir">中间件模式</strong>。</strong></p><p id="5599" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">换句话说，守卫可以阻止或确认URL更改。</p><p id="0f50" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">注2 </strong>:只有与路线相关的组件才会调用它们的保护装置。没有出现在路由定义中的子组件不会调用它们的保护，因为路由器不知道它们。</p><h2 id="c07a" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">何时使用它们中的每一个？</h2><p id="3c33" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">首先，让我们看看它们被调用的顺序。<br/>假设我们从<strong class="jp ir">"/</strong>导航到<strong class="jp ir"> "/contact" </strong>:</p><ol class=""><li id="3ddf" class="lj lk iq jp b jq jr ju jv jy ll kc lm kg ln kk ly lp lq lr bi translated"><strong class="jp ir"> beforeRouteLeave </strong> —调用<strong class="jp ir">“/”路径组件</strong></li><li id="bcc8" class="lj lk iq jp b jq lt ju lu jy lv kc lw kg lx kk ly lp lq lr bi translated"><strong class="jp ir">每次</strong>之前——新导航开始时，全局称为<strong class="jp ir"/></li><li id="38e5" class="lj lk iq jp b jq lt ju lu jy lv kc lw kg lx kk ly lp lq lr bi translated"><strong class="jp ir">输入</strong>之前——当<strong class="jp ir">“/contact”路径</strong>匹配时调用</li><li id="cb47" class="lj lk iq jp b jq lt ju lu jy lv kc lw kg lx kk ly lp lq lr bi translated"><strong class="jp ir"> beforeRouteEnter </strong> —当<strong class="jp ir"> "/contact "路由组件</strong>匹配时调用</li><li id="df82" class="lj lk iq jp b jq lt ju lu jy lv kc lw kg lx kk ly lp lq lr bi translated"><strong class="jp ir"> beforeResolve </strong> —当路由组件保护完成时全局调用<strong class="jp ir"/></li><li id="0242" class="lj lk iq jp b jq lt ju lu jy lv kc lw kg lx kk ly lp lq lr bi translated"><strong class="jp ir"> afterEach </strong> —当所有事情都解决后，全局称为<strong class="jp ir"/></li></ol><p id="e8e1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，假设我们从<strong class="jp ir"> "/page/1" </strong>导航到<strong class="jp ir"> "/page/2" </strong>，相同的路由和组件将被<strong class="jp ir">重用</strong>，只有URL发生了变化:</p><ol class=""><li id="1f9e" class="lj lk iq jp b jq jr ju jv jy ll kc lm kg ln kk ly lp lq lr bi translated"><strong class="jp ir">before each</strong>——当一个新的导航开始时，全球称为<strong class="jp ir"/></li><li id="ef27" class="lj lk iq jp b jq lt ju lu jy lv kc lw kg lx kk ly lp lq lr bi translated"><strong class="jp ir"> beforeRouteUpdate </strong> —重用时调用<strong class="jp ir">路由组件</strong></li><li id="73c4" class="lj lk iq jp b jq lt ju lu jy lv kc lw kg lx kk ly lp lq lr bi translated"><strong class="jp ir">在解决</strong>之前——当路线组件防护完成时，全局称为<strong class="jp ir"/></li><li id="3d03" class="lj lk iq jp b jq lt ju lu jy lv kc lw kg lx kk ly lp lq lr bi translated"><strong class="jp ir">每次</strong>之后——当所有事情都解决后，统称为<strong class="jp ir"/></li></ol><p id="b735" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">注</strong>:当一个路径组件被重用时，所有的“回车”保护都被跳过。</p><p id="dfd8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">既然我们已经看到了它们的执行顺序，就很容易想象何时使用它们:</p><ul class=""><li id="b77d" class="lj lk iq jp b jq jr ju jv jy ll kc lm kg ln kk lo lp lq lr bi translated">全局守卫:<br/> -不管每个之前的 <br/> - <strong class="jp ir">路径都有<strong class="jp ir">公共逻辑时使用:进入任何路径之前的操作(基于角色的保护…) <br/> - <strong class="jp ir">在解析</strong>之前:完成路径组件守卫</strong>之后的操作<strong class="jp ir"><br/>-<strong class="jp ir">在每个</strong>之后:因为路径已完全解析(跟踪页面浏览量…)而确定路径组件将被实例化时要执行的操作</strong></strong></li><li id="689a" class="lj lk iq jp b jq lt ju lu jy lv kc lw kg lx kk lo lp lq lr bi translated">route guard:<br/>-如果逻辑为<strong class="jp ir">则仅用于特定路由</strong> <br/> - <strong class="jp ir">在进入</strong>之前，不使用全局保护并在其中添加多个条件，而是使用路由保护:预取数据以在存储上设置，任何路由特定的动作，无论是同步还是异步</li><li id="ef81" class="lj lk iq jp b jq lt ju lu jy lv kc lw kg lx kk lo lp lq lr bi translated">路由组件保护:<br/> -当您<strong class="jp ir">需要访问组件实例<br/></strong>-<strong class="jp ir">before route enter</strong>:获取组件呈现前的日期<br/>-<strong class="jp ir">before route update</strong>:当URL改变但组件被重用时更新本地数据，处理组件数据缓存<br/> - <strong class="jp ir"> beforeRouteLeave </strong>:防止用户离开路由组件</li></ul><p id="31ac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">差不多就是这样。我希望你现在明白所有这些保护装置之间的区别以及为什么要使用它们。</p><p id="5615" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">大多数用例将用于数据获取，分析，认证，布局系统或其他基于URL的东西。</p><p id="9a1d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里有一个添加了所有守卫的jsfiddle，看看顺序如何:<br/><a class="ae ls" href="https://jsfiddle.net/darkylmnx/xo5ra1jt/" rel="noopener ugc nofollow" target="_blank">https://jsfiddle.net/darkylmnx/xo5ra1jt/</a><br/>这里有另一个添加了异步守卫的jsfiddle进行比较:<br/><a class="ae ls" href="https://jsfiddle.net/darkylmnx/xo5ra1jt/2/" rel="noopener ugc nofollow" target="_blank">https://jsfiddle.net/darkylmnx/xo5ra1jt/2/</a></p><p id="e350" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">打开控制台查看。</p><p id="23cb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">PS:冬天来了。如果你所在的地方阳光明媚(你好，迈阿密！)我们也有t恤:)</p></div></div>    
</body>
</html>