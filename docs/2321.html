<html>
<head>
<title>Build an anonymous group chat with Angular 7</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Angular 7建立匿名群聊</h1>
<blockquote>原文：<a href="https://itnext.io/build-an-anonymous-group-chat-with-angular-7-5e910f1ccee1?source=collection_archive---------4-----------------------#2019-05-06">https://itnext.io/build-an-anonymous-group-chat-with-angular-7-5e910f1ccee1?source=collection_archive---------4-----------------------#2019-05-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="7c5e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要跟这个帖子，需要一些Angular的基础知识。因为我们用的是Angular，我们还会看到一些打字稿代码。这里的一些基本知识也会有所帮助。人们需要安装<a class="ae ko" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank"> Node 10 </a>或任何更新的版本，才能使用GitHub的示例代码。就这些，有了这个，按照这个教程应该是直截了当的。</p><p id="9258" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将从头开始。如何生成新的角度应用程序？如何<a class="ae ko" href="https://www.cometchat.com/pro" rel="noopener ugc nofollow" target="_blank">在CometChat Pro </a>上创建一个新帐户(免费)以及如何创建一个匿名群聊并在其中发布消息。</p><p id="17b9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们不会过多地关注用户界面，而是更多地关注功能部分，但下面是它最终的样子:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi kp"><img src="../Images/34c69afa598c9b46072956ede5d2d307.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*tpagG4Ip633hTuQc.png"/></div></div></figure><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi lb"><img src="../Images/55e27de83090710f1ae1fb796311d29c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*WigSHU0LJkosjACM.png"/></div></div></figure><p id="50ca" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">代码在<a class="ae ko" href="https://github.com/cometchat-pro-samples/Angular-group-chat" rel="noopener ugc nofollow" target="_blank"> GitHub这里</a>，以防你想直接进入。克隆回购，玩得开心，不要忘记回到文章跟随教程😉</p><h1 id="220a" class="lc ld it bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">新项目</h1><p id="da54" class="pw-post-body-paragraph jq jr it js b jt ma jv jw jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn im bi translated">我们要做的第一件事是创建一个新项目，这样我们就可以在这个令人敬畏的应用程序上工作了。为此，我们需要全球安装的<a class="ae ko" href="https://cli.angular.io/" rel="noopener ugc nofollow" target="_blank">角度控制器</a>:</p><pre class="kq kr ks kt gt mf mg mh mi aw mj bi"><span id="d0c5" class="mk ld it mg b gy ml mm l mn mo">npm install -g @angular/cli</span></pre><p id="6f2a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后我们可以创建项目:</p><pre class="kq kr ks kt gt mf mg mh mi aw mj bi"><span id="bf9c" class="mk ld it mg b gy ml mm l mn mo">ng new AngularChat</span></pre><p id="850c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">或者我们可以使用npx，即<a class="ae ko" href="https://blog.npmjs.org/post/162869356040/introducing-npx-an-npm-package-runner" rel="noopener ugc nofollow" target="_blank">节点包运行器</a>。我们实现了相同的结果，而无需在全球范围内安装任何东西:</p><pre class="kq kr ks kt gt mf mg mh mi aw mj bi"><span id="dd25" class="mk ld it mg b gy ml mm l mn mo">npx @angular/cli new AngularChat</span></pre><p id="c8c7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">遵循交互式安装。当询问您想要使用什么样的样式表格式时，对路由说<strong class="js iu">是，并选择<strong class="js iu"> CSS </strong>。</strong></p><p id="6a99" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这将生成新角度应用所需的所有结构和代码。它还将安装所有的依赖项。一旦命令运行完毕，您就可以在您喜欢的编辑器中打开新文件夹(我喜欢<a class="ae ko" href="https://code.visualstudio.com/" rel="noopener ugc nofollow" target="_blank"> VsCode </a>)。您可以通过运行<code class="fe mp mq mr mg b">npm start</code>或<code class="fe mp mq mr mg b">ng serve</code>来启动本地开发服务器。这两个命令做同样的事情。现在，您可以转到http://localhost:4200并看到应用程序启动并运行。</p><h1 id="b77d" class="lc ld it bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">CometChat Pro帐户</h1><p id="ff1b" class="pw-post-body-paragraph jq jr it js b jt ma jv jw jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn im bi translated">我们需要做的第二件重要的事情，是<strong class="js iu"> <em class="ms">创建一个免费的CometChat Pro账号</em> </strong>。</p><p id="8ae3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">可以去<a class="ae ko" href="https://app.cometchat.com/#/register" rel="noopener ugc nofollow" target="_blank">网站</a>点击上面写着“免费入门”的红色大按钮。一旦你填写了所有需要的信息，你就有了一个试用帐户，并准备好了。</p><p id="c13d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在<a class="ae ko" href="https://app.cometchat.com/#/login" rel="noopener ugc nofollow" target="_blank"> CometChat仪表盘</a>上，您会看到您账户的概况。在“添加新应用程序”对话框中，输入名称并单击加号创建新应用程序。记下应用程序ID，因为我们将使用它与ComeChat API通信。</p><p id="936a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">从左侧菜单，转到API Keys，因为我们必须为我们的应用程序创建一个新的。给它起一个适合你的名字，选择<em class="ms"> Auth Only </em>作为scope。记下这个API键，因为我们将在应用程序中使用它。</p><p id="8feb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">CometChat应用程序有五个用户和一个已经创建的组，所以我们有我们需要的一切。现有用户有:<em class="ms">超级英雄1、超级英雄2、超级英雄3、超级英雄4 </em>自然还有<em class="ms">超级英雄5 </em>。一个符合这五个条件的群体是超群。您可以使用<a class="ae ko" href="https://app.cometchat.com/#/login" rel="noopener ugc nofollow" target="_blank"> CometChat仪表盘</a>查看它们。</p><h1 id="f575" class="lc ld it bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">CometChat SDK</h1><p id="4c15" class="pw-post-body-paragraph jq jr it js b jt ma jv jw jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn im bi translated">有了这些，我们现在将CometChat包添加到我们的应用程序中。这将有助于我们更轻松地使用API。我们可以使用预置的函数来执行我们想要的操作，而不是必须进行所有的调用。</p><p id="cb09" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要添加包运行:</p><pre class="kq kr ks kt gt mf mg mh mi aw mj bi"><span id="9603" class="mk ld it mg b gy ml mm l mn mo">npm install @cometchat-pro/chat</span></pre><p id="16c8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，我们可以在项目中引用该库，并在代码中使用我们需要的任何函数:</p><pre class="kq kr ks kt gt mf mg mh mi aw mj bi"><span id="7c94" class="mk ld it mg b gy ml mm l mn mo">import { CometChat } from '@cometchat-pro/chat';</span></pre><h1 id="66d8" class="lc ld it bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">TypeScript类型定义</h1><p id="4dac" class="pw-post-body-paragraph jq jr it js b jt ma jv jw jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn im bi translated">在撰写本文时，该库还没有TypeScript类型定义。虽然这是可能发生的事情😉。</p><p id="c1c7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所有Angular/TypeScript开发人员都喜欢类型定义。为了更容易理解教程和使用代码，我为我们将要使用的函数创建了几个。</p><p id="36a1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是通过在我们应用程序的<em class="ms"> src </em>文件夹中创建一个新的*.d.ts文件来完成的。当处理代码时，TypeScript编译器将选择它并向我们显示类型定义。这不是你需要做的事情，但是如果你好奇，你可以看看GitHub 上的<a class="ae ko" href="https://github.com/cometchat-pro-samples/Angular-group-chat/blob/dd1f922a57267405b6e819ff8db864152a068460/src/custom-typings.d.ts" rel="noopener ugc nofollow" target="_blank">文件。</a></p><h1 id="a938" class="lc ld it bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">应用程序结构</h1><p id="eba0" class="pw-post-body-paragraph jq jr it js b jt ma jv jw jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn im bi translated">现在让我们考虑一下我们的应用程序，我们想要一个匿名聊天，所以这将是一个组件。但是在我们开始这个组件之前，我们还希望允许用户登录到我们的应用程序。所以我们需要另一个组件。此外，将库的使用包装在服务中也是一种最佳实践，因此我们还需要一个CometChat服务类。</p><p id="9d87" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">记住这一点，我们将使用Angular CLI为我们生成这些组件。如果您在开始时全局安装了CLI，您可以使用<code class="fe mp mq mr mg b">ng</code>命令。如果没有，可以通过运行<code class="fe mp mq mr mg b">npm run ng</code>使用本地安装的。</p><p id="5087" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在生成我们的组件:</p><pre class="kq kr ks kt gt mf mg mh mi aw mj bi"><span id="75d9" class="mk ld it mg b gy ml mm l mn mo">ng generate component components/Login<br/>ng generate component components/GroupView</span></pre><p id="8a35" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们首先传递generate参数，告诉CLI我们想要做什么。然后我们指定我们想要生成的蓝图，在这个例子中是一个组件。然后我们指定组件的名称。在我们的例子中，我还在实际名称前添加了<code class="fe mp mq mr mg b">components/</code>，这样所有的组件都在同一个文件夹中。</p><p id="4b87" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要创建服务类别，请执行以下操作:</p><pre class="kq kr ks kt gt mf mg mh mi aw mj bi"><span id="86b8" class="mk ld it mg b gy ml mm l mn mo">ng generate service services/CometChat</span></pre><p id="7ee0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">和以前一样。这次我们将蓝图更改为service，并为这个类指定了一个services文件夹。</p><p id="ae5c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们已经有了应用程序的结构。</p><h1 id="69ab" class="lc ld it bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">按指定路线发送</h1><p id="eb99" class="pw-post-body-paragraph jq jr it js b jt ma jv jw jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn im bi translated">我们已经有了两个组件，现在我们必须告诉Angular什么时候加载它们。</p><p id="46ba" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我们的App routing模块(app-routing.module.ts)中，我们可以像这样更新路线:</p><pre class="kq kr ks kt gt mf mg mh mi aw mj bi"><span id="0a9e" class="mk ld it mg b gy ml mm l mn mo">const routes: Routes = [<br/>  { path: '', redirectTo: 'login', pathMatch: 'full' },<br/>  { path: 'login', component: LoginComponent },<br/>  { path: 'chat', component: GroupViewComponent },<br/>];</span></pre><p id="904f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第一个是重定向，当我们的应用程序启动时，我们希望转到登录路径。第二个命令告诉Angular，每当我们登录时，我们都希望显示LoginComponent。第二个示例做了同样的事情，但是使用了聊天路径和group view组件。</p><p id="0896" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们现在可以继续在我们的应用程序中实现一些功能。</p><h1 id="9b08" class="lc ld it bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">初始化CometChat</h1><p id="e7e4" class="pw-post-body-paragraph jq jr it js b jt ma jv jw jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn im bi translated">使用CometChat SDK我们需要做的第一件事是<a class="ae ko" href="https://prodocs.cometchat.com/docs/js-quick-start#section-initialize-cometchat" rel="noopener ugc nofollow" target="_blank">初始化它</a>。这必须在调用任何其他方法之前完成。因此，实现它的一个好地方就是我们的应用程序初始化的时候。意思是app组件的<strong class="js iu"> ngOnInit </strong>钩子。</p><p id="aa3b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我们的CometChat服务中，我们创建了一个<strong class="js iu"> init </strong>方法。它只有一个参数，即应用程序ID。在内部，我们将调用CometChat库的<strong class="js iu"> init </strong>方法:</p><pre class="kq kr ks kt gt mf mg mh mi aw mj bi"><span id="56f1" class="mk ld it mg b gy ml mm l mn mo">init(apiKey: string) {<br/>  CometChat.init(apiKey).then(<br/>    msg =&gt; console.log('Initialized succesfull: ', msg),<br/>    err =&gt; console.log('Initialization failed: ', err),<br/>  );<br/>}</span></pre><p id="70ba" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">init方法将返回一个承诺。虽然这不是强制性的，但是使用一个<strong class="js iu">然后</strong>调用来处理结果是一个很好的实践。在成功或失败的情况下打印一些消息对我们来说就足够了，这样可以更容易地调试代码。</p><p id="35ef" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我们的应用程序组件中，我们必须将服务作为参数添加到<strong class="js iu">构造器</strong>中:</p><p id="2c3b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mp mq mr mg b">constructor(private cometChat: CometChatService) {}</code></p><p id="f345" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可以注意到，在名称之前有一个私有访问修饰符。这是TypeScript中的一个小技巧，它允许我们在类中创建一个具有该名称的字段。</p><p id="6c5e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当我们的应用程序启动时，我们可以继续并初始化CometChat，因此在同一个应用程序组件中:</p><pre class="kq kr ks kt gt mf mg mh mi aw mj bi"><span id="5bff" class="mk ld it mg b gy ml mm l mn mo">ngOnInit() {<br/>  this.cometChat.init('CometChatApp ID');<br/>}</span></pre><h1 id="80e2" class="lc ld it bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">全局配置值</h1><p id="6f53" class="pw-post-body-paragraph jq jr it js b jt ma jv jw jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn im bi translated">将全局值保存在同一个文件中是一个好习惯。一个很好的地方是angular环境配置文件(<a class="ae ko" href="https://github.com/Shivangi-cometchat/Angular-group-chat/blob/2b435b7d401a01e5b8df9d98aa4f6bc0ca381bc7/src/environments/environment.ts" rel="noopener ugc nofollow" target="_blank"> environment.ts </a>)。我们已经有了一个名为环境的对象。我们可以用CometChat应用程序id和API键的值在其上添加一个属性:</p><pre class="kq kr ks kt gt mf mg mh mi aw mj bi"><span id="a948" class="mk ld it mg b gy ml mm l mn mo">export const environment = {<br/>  production: false,<br/>  cometChat: {<br/>    apiKey: 'API_KEY_HERE',<br/>    appId: 'APP_ID_HERE',<br/>  }<br/>}</span></pre><p id="00a4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这将允许我们在需要时通过应用程序引用它们。所以在上面的例子中，我们可以做的不是硬编码这个值:</p><pre class="kq kr ks kt gt mf mg mh mi aw mj bi"><span id="48e5" class="mk ld it mg b gy ml mm l mn mo">this.cometChat.init(environment.cometChat.appId);</span></pre><h1 id="7316" class="lc ld it bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">登录组件</h1><p id="5476" class="pw-post-body-paragraph jq jr it js b jt ma jv jw jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn im bi translated">一切都初始化了。现在我们可以继续前进，允许用户对我们的应用程序进行身份验证。</p><p id="dfcf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为此，我们将使用CometChat的<a class="ae ko" href="https://prodocs.cometchat.com/docs/js-quick-start#section-login-your-user" rel="noopener ugc nofollow" target="_blank">登录功能</a>。这允许基于用户id和API密钥对用户进行身份验证。尽管这是一个匿名聊天应用程序，但我们需要对CometChat API进行身份验证，这样我们才能读取和写入与我们的应用程序相关的信息。</p><p id="5082" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我们的CometChat服务中，我们创建了一个新的<strong class="js iu">登录</strong>方法并执行调用:</p><pre class="kq kr ks kt gt mf mg mh mi aw mj bi"><span id="7396" class="mk ld it mg b gy ml mm l mn mo">login(userId: string) {<br/>  return CometChat.login(userId, environment.cometChat.apiKey)<br/>  .then(<br/>    user =&gt; console.log('Login succesfull: ', user),<br/>    err =&gt; console.log('Login failed: ', err),<br/>  );<br/>}</span></pre><p id="ae61" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们传入用户id并使用来自环境对象的API键。和以前一样，我们通过在控制台中写入一些值来处理outcome Promise结果。该方法还返回API调用的结果。我们在这里处理它，但是我们也想知道如果它成功与否，我们在哪里使用它。</p><p id="9a5f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果成功，此方法调用的结果将是登录的用户。拿着它可能会有用。因此，让我们创建一个本地用户属性，并在有响应时分配它。</p><pre class="kq kr ks kt gt mf mg mh mi aw mj bi"><span id="24e8" class="mk ld it mg b gy ml mm l mn mo">user =&gt; {<br/>  console.log('Login succesfull: ', user);<br/>  this.currentUser = user;<br/>}</span></pre><p id="dfcc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有了这个，我们可以继续添加一个输入，用户可以输入一个名字和一个提交按钮。在我们的登录组件html模板中，我们会有这样的代码:</p><pre class="kq kr ks kt gt mf mg mh mi aw mj bi"><span id="e5db" class="mk ld it mg b gy ml mm l mn mo">&lt;label for="userName"&gt;Username&lt;/label&gt;<br/>&lt;input id="userName" type="text" #userName/&gt;<br/>&lt;button&gt;Join chat&lt;/button&gt;</span></pre><p id="9822" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当用户点击<em class="ms">‘加入聊天’</em>按钮时，我们将从输入中获取文本值，并调用我们类中的登录方法。正如我们在应用程序组件中所做的那样。我们必须使用依赖注入来获得CometChat服务的实例:</p><pre class="kq kr ks kt gt mf mg mh mi aw mj bi"><span id="19e2" class="mk ld it mg b gy ml mm l mn mo">constructor(private cometChat: CometChatService, private router: Router) {}</span></pre><p id="ddc5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们还有Angular路由器，因为我们将使用它导航到群聊页面。</p><p id="2e91" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在<strong class="js iu">登录</strong>方法中，我们将调用CometChat服务。如果登录成功，我们会将用户重定向到聊天页面:</p><pre class="kq kr ks kt gt mf mg mh mi aw mj bi"><span id="a9f3" class="mk ld it mg b gy ml mm l mn mo">login(userId: string) {<br/>  this.cometChat<br/>    .login(userId)<br/>    .then(() =&gt; this.router.navigateByUrl('chat'))<br/>}</span></pre><p id="ba28" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果一切正常，一旦用户输入有效的名称并点击join，他们就可以访问我们的组视图组件。</p><h1 id="b8ac" class="lc ld it bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">组视图组件</h1><p id="7afe" class="pw-post-body-paragraph jq jr it js b jt ma jv jw jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn im bi translated">这是我们最复杂的组件，也是大部分动作发生的地方。我们将能够在此处查看消息并撰写新消息。</p><p id="8602" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了使事情变得简单，我们将从模板开始。我们需要一个列表，显示所有的消息和一个按钮输入，允许用户编写新的消息。对于消息列表，我们可以有这样的内容:</p><pre class="kq kr ks kt gt mf mg mh mi aw mj bi"><span id="4963" class="mk ld it mg b gy ml mm l mn mo">&lt;div class="messages"&gt;<br/>  &lt;p&gt;<br/>    &lt;i&gt;{{ message.sender.uid }}&lt;/i&gt; &lt;br /&gt;<br/>    {{ message.text }}<br/>  &lt;/p&gt;<br/>&lt;/div&gt;</span></pre><p id="5c01" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们使用Angular的<a class="ae ko" href="https://angular.io/api/common/NgForOf" rel="noopener ugc nofollow" target="_blank"> ngForOf </a>指令迭代消息集合。对于每封邮件，我们显示发件人的uid。这意味着写消息的用户的名字和消息的文本。</p><p id="404e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们还使用<a class="ae ko" href="https://angular.io/api/common/NgClass" rel="noopener ugc nofollow" target="_blank"> ngClass指令</a>将css类仅添加到登录用户编写的消息中。这是我们在大多数聊天应用中习以为常的。通常，它们有不同的颜色或放在屏幕上的不同位置。</p><p id="1baa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为此，我们需要在我们的类中定义属性:</p><pre class="kq kr ks kt gt mf mg mh mi aw mj bi"><span id="3ffc" class="mk ld it mg b gy ml mm l mn mo">messages = [];<br/>    <br/>get currentUser() {<br/>  return this.chatService.currentUser;<br/>}</span></pre><p id="7523" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这里，我们可以看到，在执行登录时，我们实际上使用了存储的currentUser。</p><p id="1bc9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">和前面一样，CometChat服务作为参数添加到构造函数中:</p><pre class="kq kr ks kt gt mf mg mh mi aw mj bi"><span id="642f" class="mk ld it mg b gy ml mm l mn mo">constructor(private chatService: CometChatService) {}</span></pre><p id="5007" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">好，现在我们也必须显示一些信息🙂。这有两个部分，我们需要获取以前写的现有消息。之后，我们需要为任何可能到达的新消息注册一个监听器。</p><h1 id="3901" class="lc ld it bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">以前的消息</h1><p id="b2fd" class="pw-post-body-paragraph jq jr it js b jt ma jv jw jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn im bi translated">要获取消息，我们需要构建类似查询的东西，并指定我们想要检索的内容。SDK的<a class="ae ko" href="https://prodocs.cometchat.com/docs/js-messaging#section-fetch-messages" rel="noopener ugc nofollow" target="_blank"> MessagesRequestBuilder </a>类允许我们这样做。</p><p id="522b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们在类似fluent的API中有不同的方法，允许我们为请求设置不同的属性:</p><ul class=""><li id="886e" class="mt mu it js b jt ju jx jy kb mv kf mw kj mx kn my mz na nb bi translated">要检索的消息数</li><li id="1273" class="mt mu it js b jt nc jx nd kb ne kf nf kj ng kn my mz na nb bi translated">用户或组id</li><li id="0470" class="mt mu it js b jt nc jx nd kb ne kf nf kj ng kn my mz na nb bi translated">时间戳或消息id等过滤方法</li></ul><p id="f75a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我们的例子中，我们希望从一个组中获取消息，所以我们只需要指定组id。好吧，也许增加一个限制也是明智的😃。在我们设置了所有想要的属性后，我们可以调用<strong class="js iu"> build </strong>方法。这将创建查询并返回一个MessageRequest实例，我们可以用它来获取消息:</p><pre class="kq kr ks kt gt mf mg mh mi aw mj bi"><span id="3262" class="mk ld it mg b gy ml mm l mn mo">getPreviousMessages(groupId: string) {<br/>  const messageRequest = new CometChat.MessagesRequestBuilder()<br/>    .setGUID(groupId)<br/>    .setLimit(100)<br/>    .build();<br/>    return messageRequest.fetchPrevious();<br/>}</span></pre><p id="ec6e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">消息请求类有两个方法:<strong class="js iu"> fetchNext </strong>和<strong class="js iu"> fetchPrevious。</strong>顾名思义，next将在过滤器后得到消息，类似于大于。Previous将获取之前或低于之前的消息。</p><p id="d64a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我们的例子中，我们没有设置任何过滤器，所以这两个过滤器中的任何一个都应该工作。上面的方法被添加到CometChat服务类中。我们可以在组视图组件中调用它来获取以前的消息:</p><pre class="kq kr ks kt gt mf mg mh mi aw mj bi"><span id="a3ce" class="mk ld it mg b gy ml mm l mn mo">this.chatService<br/>  .getPreviousMessages('supergroup')<br/>  .then(messages =&gt; (this.messages = messages))</span></pre><p id="4d49" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当我们得到响应时，我们将消息分配给本地属性。Angular会注意到有新的东西，并用新的值呈现我们的组件。</p><h1 id="22ce" class="lc ld it bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">消息监听器</h1><p id="442e" class="pw-post-body-paragraph jq jr it js b jt ma jv jw jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn im bi translated">我们已经有了以前写的消息，但我们还想显示新来的实时消息。当我们看着屏幕时，其他用户可能写的消息。为了获得它们，我们需要注册一个<a class="ae ko" href="https://prodocs.cometchat.com/docs/js-messaging#section-receive-messages" rel="noopener ugc nofollow" target="_blank">消息监听器</a>。为此，我们需要一个惟一的监听器ID。与聊天链接到的屏幕或应用程序部分相关的内容。然后，我们可以使用MessageListener类为不同类型的消息注册处理程序:</p><pre class="kq kr ks kt gt mf mg mh mi aw mj bi"><span id="5108" class="mk ld it mg b gy ml mm l mn mo">listenForMessages(listenerId: string, onMessageReceived: (msg: any) =&gt; void) {<br/>  CometChat.addMessageListener(<br/>    listenerId,<br/>    new CometChat.MessageListener({<br/>      onTextMessageReceived: onMessageReceived,<br/>    })<br/>  );<br/>}</span></pre><p id="1228" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">目前，我们只关心短信。那是我们唯一注册的听众。但是对于其他类型，它也有类似于<em class="ms"> onMediaMessageReceived </em>和<em class="ms"> onCustomMessageReceived </em>的属性。</p><p id="2211" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">将上述方法添加到CometChat服务类后，我们可以在我们的组视图组件中使用它。在我们读完所有以前的信息后，我们可以收听新的信息:</p><pre class="kq kr ks kt gt mf mg mh mi aw mj bi"><span id="565f" class="mk ld it mg b gy ml mm l mn mo">this.chatService.listenForMessages(this.listenerId, msg =&gt; this.messages.push(msg));</span></pre><p id="1b68" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们有一份本地房产清单。值为“Web_App_Listener_Group_ID”，但是您可以使用几乎任何您想要的值。对于我们的应用程序来说，这应该是一个惟一的值，但是因为我们只有一个侦听器，所以我们是安全的。作为一种方法，我们传递一个函数，该函数将接受任何新消息并将其添加到我们的消息数组中。同样，这将触发组件被渲染，我们将在屏幕上看到新的消息。</p><p id="d3cc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当不再需要消息侦听器时，最好将其删除。让我们开始吧。</p><p id="4d96" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我们的CometChat服务中，我们添加了<strong class="js iu"> remove </strong>方法:</p><pre class="kq kr ks kt gt mf mg mh mi aw mj bi"><span id="be07" class="mk ld it mg b gy ml mm l mn mo">removeListener(listenerId: string) {<br/>  CometChat.removeMessageListener(listenerId);<br/>}</span></pre><p id="2aec" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我们的组视图组件中，我们为销毁事件添加了一个处理程序，并在那里调用它:</p><pre class="kq kr ks kt gt mf mg mh mi aw mj bi"><span id="802a" class="mk ld it mg b gy ml mm l mn mo">ngOnDestroy(): void {<br/>  this.chatService.removeListener(this.listenerId);<br/>}</span></pre><h1 id="540c" class="lc ld it bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">添加新邮件</h1><p id="eb79" class="pw-post-body-paragraph jq jr it js b jt ma jv jw jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn im bi translated">我们需要做的最后一部分是编写新消息并将它们发送到服务器。</p><p id="8c04" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，我们需要用输入和按钮更新模板:</p><pre class="kq kr ks kt gt mf mg mh mi aw mj bi"><span id="0414" class="mk ld it mg b gy ml mm l mn mo">&lt;div class="messageInput"&gt;<br/>  &lt;input type="text" placeholder="enter a text message" #messageText /&gt;<br/>  &lt;button (click)="sendMessage(messageText.value); messageText.value = ''"&gt;<br/>    Send<br/>  &lt;/button&gt;<br/>&lt;/div&gt;</span></pre><p id="b409" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当用户点击“发送”按钮时，我们从输入中提取文本，并调用我们的类中的<strong class="js iu"> sendMessage </strong>方法。另外，我们还清除了输入值，允许用户编写新消息。</p><p id="77e6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要发送消息，我们必须使用<a class="ae ko" href="https://prodocs.cometchat.com/docs/js-messaging#section-send-a-text-message" rel="noopener ugc nofollow" target="_blank"> sendMessage函数</a>。在我们发送消息之前，我们必须创建它:</p><pre class="kq kr ks kt gt mf mg mh mi aw mj bi"><span id="f94c" class="mk ld it mg b gy ml mm l mn mo">const message = new CometChat.TextMessage(<br/>  receiverId,<br/>  text,<br/>  CometChat.MESSAGE_TYPE.TEXT,<br/>  CometChat.RECEIVER_TYPE.GROUP<br/>);</span></pre><p id="5f6b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是一个如何发送短信的例子。第一个值receiverId是我们要向其发送消息的用户或组Id。第二，也是最简单的一个，是消息的文本内容。</p><p id="d21e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第三个是消息的类型，在我们的例子中是文本。它也可以是文件、图像、视频或音频。</p><p id="c2bb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后一个值表示接收者的类型，可以是用户或组。在我们的例子中是一组。</p><p id="7cd9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一旦创建了消息，我们就将它发送到服务器:</p><pre class="kq kr ks kt gt mf mg mh mi aw mj bi"><span id="f81f" class="mk ld it mg b gy ml mm l mn mo">CometChat.sendMessage(message);</span></pre><p id="84a9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是在CometChat服务类中实现的<strong class="js iu"> sendMessage </strong>函数。你可以在这里看一下<a class="ae ko" href="https://github.com/cometchat-pro-samples/Angular-group-chat" rel="noopener ugc nofollow" target="_blank">的代码。</a></p><p id="8baa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有了这个函数，我们可以转到我们的组视图组件，并在那里实现<strong class="js iu"> sendMessage </strong>函数:</p><pre class="kq kr ks kt gt mf mg mh mi aw mj bi"><span id="7335" class="mk ld it mg b gy ml mm l mn mo">sendMessage(message: string) {<br/>  this.chatService.sendMessage('supergroup', message);<br/>}</span></pre><p id="8052" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有一点要记住。用户发送的消息将不会返回到我们已经注册的消息侦听器中。要在发送后在屏幕上看到它们，我们必须手动将它们添加到消息数组中:</p><pre class="kq kr ks kt gt mf mg mh mi aw mj bi"><span id="0aa6" class="mk ld it mg b gy ml mm l mn mo">this.messages.push({<br/>  text: message,<br/>  sender: { uid: this.currentUser.uid }<br/>});</span></pre><p id="78e4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">就是这样！现在我们可以在超级群里收发信息了🙂。</p><h1 id="bcef" class="lc ld it bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">结论</h1><p id="87c0" class="pw-post-body-paragraph jq jr it js b jt ma jv jw jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn im bi translated">这是一种用Angular和CometChat创建通用匿名聊天应用程序的方法。您已经了解了在角度上下文中使用CometChat的基本知识。现在，您可以在此基础上扩展您的应用程序，使其具备全新的功能。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi lb"><img src="../Images/f93e4de2b7ee47678db286d1721da7bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*N01OSRy1hoF-6YgI.png"/></div></div></figure><p id="7e6f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">GitHub 上的<a class="ae ko" href="https://github.com/cometchat-pro-samples/Angular-group-chat" rel="noopener ugc nofollow" target="_blank">示例代码包含了更多的错误处理和一些基本的css来使一切变得更加整洁。不要犹豫，去看看吧😉。</a></p><p id="f8fb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">关注这个博客，获得更多关于如何使用CometChat的教程和技巧。</p></div></div>    
</body>
</html>