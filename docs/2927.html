<html>
<head>
<title>Setting up AdonisJs websockets (with React app demo)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">设置AdonisJs websockets(带React应用程序演示)</h1>
<blockquote>原文：<a href="https://itnext.io/setting-up-adonisjs-websockets-with-react-app-demo-27bb0bb7500f?source=collection_archive---------0-----------------------#2019-09-01">https://itnext.io/setting-up-adonisjs-websockets-with-react-app-demo-27bb0bb7500f?source=collection_archive---------0-----------------------#2019-09-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/a1ecdf1d8bbb4e1e1e15913fea5a6bbb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nLSaZbaoaaU4-b2tzEPHRw.png"/></div></div></figure><p id="0264" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kw">本文致力于设置AdonisJs websocket客户端&amp;服务器API。最后，您会发现一个monorepo的链接，其中包含工作示例代码(以及CI/CD脚本！)和一个现场演示应用程序。</em></p><p id="df1b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kw">它是为那些已经对AdonisJs(或Node.js)有经验并有所反应的读者而写的。这里不解释基础，只解释websocket相关逻辑。</em></p><p id="783a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi">—</p><p id="4b3c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi kx translated">让AdonisJs套接字运行起来并不是世界上最容易的事情，但是当尝试新事物时却是如此。我觉得文档有点薄，因此这篇文章有例子。我希望我能帮助那些像我一样挣扎的人。</p><p id="c405" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们不会一步一步地创建新的REST API。相反，我将介绍我对这个演示应用程序的想法:</p><blockquote class="lg lh li"><p id="bc49" class="jy jz kw ka b kb kc kd ke kf kg kh ki lj kk kl km lk ko kp kq ll ks kt ku kv ij bi translated">假设你有多个聊天室。每个聊天室都有多条消息，用户当然可以发布新消息。前端通过websocket通信接收由服务器广播的新消息。</p></blockquote><p id="06ba" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这为我们带来了一个基本的REST API结构(无认证):</p><ul class=""><li id="8f39" class="lm ln iq ka b kb kc kf kg kj lo kn lp kr lq kv lr ls lt lu bi translated">帖子<code class="fe lv lw lx ly b">/rooms</code> —创建一个新聊天室</li><li id="54c6" class="lm ln iq ka b kb lz kf ma kj mb kn mc kr md kv lr ls lt lu bi translated">GET <code class="fe lv lw lx ly b">/rooms/:uuid</code> —选择并返回一个现有聊天室及其消息</li><li id="83a7" class="lm ln iq ka b kb lz kf ma kj mb kn mc kr md kv lr ls lt lu bi translated">POST <code class="fe lv lw lx ly b">/rooms/:uuid</code> —在房间中创建新消息，<strong class="ka ir">根据房间ID向主题广播消息</strong>(意味着只有房间ID的订阅者收到消息)</li></ul><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi me"><img src="../Images/ab2c3b16a746a1fb863d5e2f1881b763.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Bp7vzDhOdN1sycTuJc4wvw.png"/></div></div><figcaption class="mj mk gj gh gi ml mm bd b be z dk translated">你可以使用邮递员使用<a class="ae mn" href="https://adonis-sockets-api.herokuapp.com/rooms" rel="noopener ugc nofollow" target="_blank">https://adonis-sockets-api.herokuapp.com/rooms</a>来尝试一下</figcaption></figure><h1 id="084e" class="mo mp iq bd mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj nk nl bi translated">准备后端以广播消息</h1><p id="db2a" class="pw-post-body-paragraph jy jz iq ka b kb nm kd ke kf nn kh ki kj no kl km kn np kp kq kr nq kt ku kv ij bi translated">我将参考AdonisJs的官方文档。我们希望您已经生成了AdonisJs项目，因为我们将遵循该结构。</p><h2 id="0d3f" class="nr mp iq bd mq ns nt dn mu nu nv dp my kj nw nx nc kn ny nz ng kr oa ob nk oc bi translated">安装依赖项</h2><p id="c086" class="pw-post-body-paragraph jy jz iq ka b kb nm kd ke kf nn kh ki kj no kl km kn np kp kq kr nq kt ku kv ij bi translated">要安装WebSocket Provider，您需要在adonis项目根目录下运行<br/> <code class="fe lv lw lx ly b">adonis install @adonisjs/websocket</code>。</p><p id="d8b0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">(抄袭自<a class="ae mn" href="https://adonisjs.com/docs/4.1/websocket" rel="noopener ugc nofollow" target="_blank">https://adonisjs.com/docs/4.1/websocket</a>)</p><ol class=""><li id="e574" class="lm ln iq ka b kb kc kf kg kj lo kn lp kr lq kv od ls lt lu bi translated"><code class="fe lv lw lx ly b">config/socket.js</code>包含WebSocket服务器<strong class="ka ir">配置</strong>。</li><li id="f277" class="lm ln iq ka b kb lz kf ma kj mb kn mc kr md kv od ls lt lu bi translated"><code class="fe lv lw lx ly b">start/socket.js</code>启动WebSocket服务器并注册<strong class="ka ir">通道</strong>。</li><li id="3175" class="lm ln iq ka b kb lz kf ma kj mb kn mc kr md kv od ls lt lu bi translated"><code class="fe lv lw lx ly b">start/wsKernel.js</code> <strong class="ka ir">注册中间件</strong>执行频道订阅。</li></ol><p id="27b2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，在<code class="fe lv lw lx ly b">start/app.js</code>文件中注册提供者:</p><pre class="mf mg mh mi gt oe ly of og aw oh bi"><span id="dcab" class="nr mp iq ly b gy oi oj l ok ol">const providers = [<br/>  '@adonisjs/websocket/providers/WsProvider'<br/>]</span></pre><p id="b410" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，指示<a class="ae mn" href="https://adonisjs.com/docs/4.1/ignitor" rel="noopener ugc nofollow" target="_blank">点火器</a>引导根<code class="fe lv lw lx ly b">server.js</code>文件中的WebSocket服务器:</p><pre class="mf mg mh mi gt oe ly of og aw oh bi"><span id="b946" class="nr mp iq ly b gy oi oj l ok ol">const { Ignitor } = require('@adonisjs/ignitor')</span><span id="2d67" class="nr mp iq ly b gy om oj l ok ol">new Ignitor(require('@adonisjs/fold'))<br/>   .appRoot(__dirname)<br/>   .<strong class="ly ir">wsServer()</strong> // boot the WebSocket server<br/>   .fireHttpServer()<br/>   .catch(console.error)</span></pre><p id="9b2b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi">—</p><h2 id="4f6e" class="nr mp iq bd mq ns nt dn mu nu nv dp my kj nw nx nc kn ny nz ng kr oa ob nk oc bi translated">实际代码</h2><p id="3d43" class="pw-post-body-paragraph jy jz iq ka b kb nm kd ke kf nn kh ki kj no kl km kn np kp kq kr nq kt ku kv ij bi translated">您可以在<code class="fe lv lw lx ly b">start/socket.js</code>文件中注册套接字通道。我的看起来像这样:</p><pre class="mf mg mh mi gt oe ly of og aw oh bi"><span id="f119" class="nr mp iq ly b gy oi oj l ok ol"><strong class="ly ir">'use strict'<br/><br/>const <em class="kw">Ws </em></strong>= <strong class="ly ir">use</strong>(<strong class="ly ir">'Ws'</strong>)<br/><br/><strong class="ly ir"><em class="kw">Ws<br/>  </em></strong>.<strong class="ly ir">channel</strong>(<strong class="ly ir">'room:*'</strong>, <strong class="ly ir">'RoomUpdateController'</strong>)<br/>  <em class="kw">// .middleware(['auth'])</em></span></pre><p id="ee27" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如你所见，我指的是一个控制器，而不是在<code class="fe lv lw lx ly b">socket.js</code>文件中写所有的逻辑。这是可选的，我更喜欢控制器结构来保持我的项目逻辑分离，易于回溯。</p><p id="8b43" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">需要注意的是<code class="fe lv lw lx ly b">.channel('room:*')</code>部分——这是您将订阅的频道。由于我将订阅不同的房间(基于他们的ID)，我需要<code class="fe lv lw lx ly b">:*</code>动态参数。</p><p id="a0e2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">还有一条评论线写着<code class="fe lv lw lx ly b">// .middleware(['auth'])</code>。<strong class="ka ir">我们不会做任何授权用户检查</strong>，但是如果你想做这些，这是你如何在<a class="ae mn" href="https://adonisjs.com/docs/4.1/websocket-server" rel="noopener ugc nofollow" target="_blank">https://adonisjs.com/docs/4.1/websocket-server</a>注册中间件的进一步说明。</p><p id="73f4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi">—</p><p id="c6f9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，让我们生成我们引用的控制器—</p><p id="8df0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe lv lw lx ly b">adonis make:controller RoomUpdate --type=ws</code></p><p id="33a7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我的RoomUpdateController的内容如下所示:</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="on oo l"/></div></figure><ul class=""><li id="afb1" class="lm ln iq ka b kb kc kf kg kj lo kn lp kr lq kv lr ls lt lu bi translated"><code class="fe lv lw lx ly b">constructor()</code>将通过控制台日志提醒我们已经进行了新的订阅——其中<code class="fe lv lw lx ly b">socket.topic</code>将是我们订阅的房间ID。</li><li id="4117" class="lm ln iq ka b kb lz kf ma kj mb kn mc kr md kv lr ls lt lu bi translated">当从客户端接收到<strong class="ka ir">消息时,<code class="fe lv lw lx ly b">onMessage()</code>会提醒我们——我们不会从客户端应用程序发出消息，只会从服务器发出消息。如果你想测试它，它就在那里。</strong></li><li id="f26e" class="lm ln iq ka b kb lz kf ma kj mb kn mc kr md kv lr ls lt lu bi translated">每当客户端关闭连接时,<code class="fe lv lw lx ly b">onClose()</code>会提醒我们。用这个来测试你是否真的关闭了连接。</li></ul><h2 id="ef05" class="nr mp iq bd mq ns nt dn mu nu nv dp my kj nw nx nc kn ny nz ng kr oa ob nk oc bi translated">广播本身</h2><p id="7d4c" class="pw-post-body-paragraph jy jz iq ka b kb nm kd ke kf nn kh ki kj no kl km kn np kp kq kr nq kt ku kv ij bi translated">我们的websocket逻辑似乎已经设置好了——我们已经安装了所有的东西，我们已经在<code class="fe lv lw lx ly b">start/socket.js</code>文件中注册了通道，我们已经将它链接到一个控制器，并在其中编写了一些基本的监听逻辑。现在我们去广播新消息吧！</p><p id="25f9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于本文演示了单向websocket通信(服务器→客户端)，<strong class="ka ir">一旦用户在房间</strong>发布新消息，我们就会广播消息。您可以在本文末尾链接的示例源代码中找到所有的API逻辑。现在，我将只关注createMessage端点。</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="on oo l"/></div><figcaption class="mj mk gj gh gi ml mm bd b be z dk translated">app/controller/Http/room controller . js</figcaption></figure><p id="8a22" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是从我的包含API逻辑的<code class="fe lv lw lx ly b">RoomController.js</code>文件中摘录的。我只展示了<code class="fe lv lw lx ly b">createMessage()</code>方法，因为它是唯一一种广播方法。</p><p id="a583" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe lv lw lx ly b">createMessage()</code>返回结果(创建的消息对象)，但我们将在客户端应用程序中忽略它，而是通过套接字通信接收新消息。如果您删除这一行并返回一个简单的200代码，应该没有什么变化。</p><p id="a16a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意被调用的<code class="fe lv lw lx ly b">broadcast()</code>函数——它是从执行大部分魔法的<code class="fe lv lw lx ly b">socket.utils</code>文件中导出的。让我们深入研究一下。</p><p id="991e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi">—</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="46fa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个<code class="fe lv lw lx ly b">broadcast</code>功能是根据我们的需求量身定制的。它预计:</p><ul class=""><li id="cafd" class="lm ln iq ka b kb kc kf kg kj lo kn lp kr lq kv lr ls lt lu bi translated">一个<code class="fe lv lw lx ly b">id</code>作为第一个参数，这将是我们的房间ID (uuid) —我们需要它作为动态主题参数，因为我们只想将消息广播到一个房间。</li><li id="e24f" class="lm ln iq ka b kb lz kf ma kj mb kn mc kr md kv lr ls lt lu bi translated">一个允许客户端分离处理逻辑的<code class="fe lv lw lx ly b">type</code>字符串——我们在控制器中使用了<code class="fe lv lw lx ly b">room:newMessage</code>字符串。这可以很容易地扩展到各种类型，如<code class="fe lv lw lx ly b">room:deleteMessage</code>或<code class="fe lv lw lx ly b">room:editMessage</code>，允许前端根据类型决定如何处理传入的数据(我们将在后面看到这一点)。</li><li id="b97b" class="lm ln iq ka b kb lz kf ma kj mb kn mc kr md kv lr ls lt lu bi translated">一个将被广播的<code class="fe lv lw lx ly b">data</code>，在我们的例子中是<code class="fe lv lw lx ly b">message</code>对象。</li></ul><ol class=""><li id="f9e6" class="lm ln iq ka b kb kc kf kg kj lo kn lp kr lq kv od ls lt lu bi translated">我们想要访问我们主题的频道，即<code class="fe lv lw lx ly b">room:*</code>。如果没有频道，我们就无法继续，因为我们找不到我们的话题。</li><li id="4b5b" class="lm ln iq ka b kb lz kf ma kj mb kn mc kr md kv od ls lt lu bi translated">我们根据收到的<code class="fe lv lw lx ly b">id</code>找到主题。同样，如果没有主题，我们就不能继续(这意味着客户端没有正确连接，或者根本没有连接)。</li><li id="35a5" class="lm ln iq ka b kb lz kf ma kj mb kn mc kr md kv od ls lt lu bi translated">一旦我们有了主题，我们就广播数据—我们可以从3种方式中选择通信:<br/> - <em class="kw">发出</em> —仅将消息发送给产生请求的客户端<br/> - <em class="kw">广播</em> —将消息发送给除之外的所有人，产生请求的客户端<br/> - <em class="kw">广播给所有人</em> —将消息发送给收听所述主题的<strong class="ka ir">所有人</strong>。</li></ol><blockquote class="op"><p id="3dc2" class="oq or iq bd os ot ou ov ow ox oy kv dk translated">我们使用的是<code class="fe lv lw lx ly b">broadcastToAll</code>方法，因此无论您是否在房间里制作消息，客户端都没有区别。它只是接收一条消息并显示它。</p></blockquote><p id="1ce3" class="pw-post-body-paragraph jy jz iq ka b kb oz kd ke kf pa kh ki kj pb kl km kn pc kp kq kr pd kt ku kv ij bi translated">现在，所有3种方法都需要两个参数— <code class="fe lv lw lx ly b">event</code>和<code class="fe lv lw lx ly b">data</code>。</p><ul class=""><li id="01fc" class="lm ln iq ka b kb kc kf kg kj lo kn lp kr lq kv lr ls lt lu bi translated">我总是使用字符串“message”作为<code class="fe lv lw lx ly b">event</code>参数。我发现这更容易，因为我总是听客户端的<code class="fe lv lw lx ly b">message</code>，不必担心过于复杂的事情。</li><li id="f597" class="lm ln iq ka b kb lz kf ma kj mb kn mc kr md kv lr ls lt lu bi translated">我的<code class="fe lv lw lx ly b">data</code>参数是一个连接的对象——由类型属性(<code class="fe lv lw lx ly b">room:newMessage</code>)和由<code class="fe lv lw lx ly b">broadcast()</code> socket util函数接收的数据组成。</li></ul><p id="2164" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由<code class="fe lv lw lx ly b">broadcastToAll()</code>函数接收的<code class="fe lv lw lx ly b">data</code>对象一旦被连接，看起来就像这样:</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="on oo l"/></div><figcaption class="mj mk gj gh gi ml mm bd b be z dk translated">客户端收到消息后会看到什么</figcaption></figure><p id="162a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi">—</p><h1 id="d15d" class="mo mp iq bd mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj nk nl bi translated">准备客户端接收消息</h1><p id="6897" class="pw-post-body-paragraph jy jz iq ka b kb nm kd ke kf nn kh ki kj no kl km kn np kp kq kr nq kt ku kv ij bi translated"><em class="kw">我不会深入研究GET和POST请求来与API通信，也不会深入研究React语法。最后，您的前端是用什么创建的并不重要，重要的是如何接收消息，这在所有框架中都非常相似。</em></p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi pe"><img src="../Images/e8eea0ca6a63f762f9695e1378771193.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vR0yqzEnGdEDbVf6V5emTQ.png"/></div></div></figure><p id="02e7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">运行演示前端应用程序，<code class="fe lv lw lx ly b">cd frontend</code>、<code class="fe lv lw lx ly b">yarn install</code>和<code class="fe lv lw lx ly b">yarn start</code>。如果你想创建自己的应用程序，用<code class="fe lv lw lx ly b">npx create-react-app frontend</code>生成一个。</p><p id="ed78" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我的演示前端的流程如下:</p><ol class=""><li id="96b0" class="lm ln iq ka b kb kc kf kg kj lo kn lp kr lq kv od ls lt lu bi translated">我们创建一个房间并等待响应。成功创建聊天室后，用户将被重定向到新的空聊天室。</li><li id="6ba9" class="lm ln iq ka b kb lz kf ma kj mb kn mc kr md kv od ls lt lu bi translated">一旦你进入这个聊天室，一个套接字连接就被初始化了。</li><li id="a084" class="lm ln iq ka b kb lz kf ma kj mb kn mc kr md kv od ls lt lu bi translated">信息表单希望您填写您的<strong class="ka ir">姓名</strong>和您想要发送的<strong class="ka ir">信息</strong>。除非这两个都填写了，否则邮件不会发送到服务器。</li><li id="8679" class="lm ln iq ka b kb lz kf ma kj mb kn mc kr md kv od ls lt lu bi translated">一旦您发送了一条消息(按下回车键)，<strong class="ka ir">消息</strong>字段将被清除。<strong class="ka ir">名称</strong>字段保持填充状态。</li><li id="57e3" class="lm ln iq ka b kb lz kf ma kj mb kn mc kr md kv od ls lt lu bi translated">来自服务器<strong class="ka ir">的响应被忽略</strong>。</li><li id="a70f" class="lm ln iq ka b kb lz kf ma kj mb kn mc kr md kv od ls lt lu bi translated">由于这个连接，您应该会收到一个传入的套接字消息。这就是前端处理传入数据的方式，忽略来自服务器的响应，不等待任何数据。</li><li id="1d25" class="lm ln iq ka b kb lz kf ma kj mb kn mc kr md kv od ls lt lu bi translated"><em class="kw">你可以在各种选项卡上打开房间，打开你的浏览器控制台观看数据流。</em></li></ol><h2 id="ebc5" class="nr mp iq bd mq ns nt dn mu nu nv dp my kj nw nx nc kn ny nz ng kr oa ob nk oc bi translated">实际代码</h2><p id="86ba" class="pw-post-body-paragraph jy jz iq ka b kb nm kd ke kf nn kh ki kj no kl km kn np kp kq kr nq kt ku kv ij bi translated">我们最感兴趣的是发生连接的<code class="fe lv lw lx ly b">Room.js</code>组件文件。由于处理程序链接和useEffect()以及穷举dep的性质，我们将使用传统的<code class="fe lv lw lx ly b">React.Component</code>。</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="2570" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们一步一步来:</p><ol class=""><li id="7a90" class="lm ln iq ka b kb kc kf kg kj lo kn lp kr lq kv od ls lt lu bi translated">我们正在从<code class="fe lv lw lx ly b">lib/socket</code>文件夹导入一个<code class="fe lv lw lx ly b">connection</code>变量。尽可能外包不同的逻辑是我的习惯。</li><li id="0a9d" class="lm ln iq ka b kb lz kf ma kj mb kn mc kr md kv od ls lt lu bi translated">我们在组件外部定义了一个<code class="fe lv lw lx ly b">subscription</code>变量。我们需要它在组件的任何地方都可以访问，这样我们就可以关闭连接。</li><li id="0888" class="lm ln iq ka b kb lz kf ma kj mb kn mc kr md kv od ls lt lu bi translated">在<code class="fe lv lw lx ly b">componentDidMount()</code>时，我们通过运行<code class="fe lv lw lx ly b">connection.connect()</code>连接到我们的websocket服务器。</li><li id="6ffe" class="lm ln iq ka b kb lz kf ma kj mb kn mc kr md kv od ls lt lu bi translated">然后我们通过运行<code class="fe lv lw lx ly b">connection.subscribe()</code>进行订阅，并将结果存储在<code class="fe lv lw lx ly b">subscription</code>变量中。</li><li id="d386" class="lm ln iq ka b kb lz kf ma kj mb kn mc kr md kv od ls lt lu bi translated"><code class="fe lv lw lx ly b">connection.subscribe()</code>需要两个参数——一个<em class="kw">主题</em>(如<code class="fe lv lw lx ly b">room:123</code>)和一个<em class="kw">句柄</em>。</li><li id="d629" class="lm ln iq ka b kb lz kf ma kj mb kn mc kr md kv od ls lt lu bi translated"><strong class="ka ir">我们将</strong> <code class="fe lv lw lx ly b"><strong class="ka ir">this.handleMessageAdd</strong></code> <strong class="ka ir">作为处理程序参数传递。</strong>这意味着每当接收到所述订阅中的消息时，数据将被传递给处理函数。</li><li id="c065" class="lm ln iq ka b kb lz kf ma kj mb kn mc kr md kv od ls lt lu bi translated">我们获取现有的信息，以防我们打开一个已经装满信息的房间。</li><li id="2114" class="lm ln iq ka b kb lz kf ma kj mb kn mc kr md kv od ls lt lu bi translated">在<code class="fe lv lw lx ly b">componentWillUnmount()</code>之后，我们使用存储的订阅变量并关闭连接。</li><li id="3ed5" class="lm ln iq ka b kb lz kf ma kj mb kn mc kr md kv od ls lt lu bi translated">然后是<code class="fe lv lw lx ly b">handleMessageAdd</code>方法，它期待一条消息，并根据<strong class="ka ir">消息的类型</strong>(您可以看到开关)决定如何处理传入的数据。我们现在只添加了一条新消息(<code class="fe lv lw lx ly b">room:newMessage</code>)，但是你可以随意扩展。如您所见，有一个<code class="fe lv lw lx ly b">this.setState()</code>调用，它将新消息添加到旧消息的数组中，这触发了消息的呈现。</li></ol><p id="bf35" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi">—</p><p id="b9b4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如所料，神奇的事情发生在<code class="fe lv lw lx ly b">lib/socket.js</code>文件中。让我们来看看内容:</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="on oo l"/></div><figcaption class="mj mk gj gh gi ml mm bd b be z dk translated">lib/socket.js</figcaption></figure><p id="129a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，我们需要安装adonis websocket客户端包。输入<code class="fe lv lw lx ly b">yarn add @adonisjs/websocket-client</code>继续。</p><h2 id="16b7" class="nr mp iq bd mq ns nt dn mu nu nv dp my kj nw nx nc kn ny nz ng kr oa ob nk oc bi translated">请注意connect()方法</h2><p id="48a4" class="pw-post-body-paragraph jy jz iq ka b kb nm kd ke kf nn kh ki kj no kl km kn np kp kq kr nq kt ku kv ij bi translated">我们尝试使用<code class="fe lv lw lx ly b">this.ws = Ws(...).connect()</code>进行连接。</p><p id="4967" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">重要的是，如果您在本地运行后端，套接字协议将是<code class="fe lv lw lx ly b">ws://</code>，如果您使用演示heroku应用程序，协议将是<code class="fe lv lw lx ly b">wss://</code>。这就是为什么我为它创建了一个单独的util函数。</p><p id="14cb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你也可以看到我正在使用的<code class="fe lv lw lx ly b">process.env.REACT_APP_API_URL</code>是我的<strong class="ka ir">adonis-sockets-api.herokuapp.com</strong>。如果只在本地提供后端服务，也可以使用env变量或只使用静态字符串。您需要知道的是，这是连接到websocket通道的实际URL，因此它需要是正确的。</p><p id="7148" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我的完整网址是这样的:<strong class="ka ir">WSS://Adonis-sockets-API . heroku app . com/</strong><em class="kw">(也可以用这个)</em>。</p><p id="fe53" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在您的情况下，如果您在本地运行它，它可能类似于:<strong class="ka ir"> ws://localhost:3333/ </strong></p><p id="14bd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">还有注释的<code class="fe lv lw lx ly b">// .withApiToken()</code>行，如果您想使用auth socket中间件，可以使用它。您需要提供存储的令牌，以便它作为服务器websocket连接的一部分发送。</p><p id="d65a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi">—</p><h2 id="02dc" class="nr mp iq bd mq ns nt dn mu nu nv dp my kj nw nx nc kn ny nz ng kr oa ob nk oc bi translated">下一件有趣的事情是subscribe()方法</h2><p id="7ed7" class="pw-post-body-paragraph jy jz iq ka b kb nm kd ke kf nn kh ki kj no kl km kn np kp kq kr nq kt ku kv ij bi translated">我们接收<code class="fe lv lw lx ly b">channel</code>和<code class="fe lv lw lx ly b">handler</code>参数，它们将是我们的“<strong class="ka ir"> room:*uuid </strong>”(例如“room:123”)字符串和处理函数。</p><p id="64ad" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将连接存储在一个<code class="fe lv lw lx ly b">result</code>变量中，并处理传入的事件:</p><pre class="mf mg mh mi gt oe ly of og aw oh bi"><span id="1ff6" class="nr mp iq ly b gy oi oj l ok ol"><strong class="ly ir">const </strong>result = <strong class="ly ir">this</strong>.<strong class="ly ir">ws</strong>.subscribe(channel); // this is our connection, we retry each second if we don't have it yet<br/><br/>result.on(<strong class="ly ir">'message'</strong>, message =&gt; {<br/>  <strong class="ly ir"><em class="kw">console</em></strong>.log(<strong class="ly ir">'Incoming'</strong>, message);<br/>  handler(message)<br/>});<br/><br/>result.on(<strong class="ly ir">'error'</strong>, (error) =&gt; {<br/>  <strong class="ly ir"><em class="kw">console</em></strong>.error(error)<br/>});<br/><br/><strong class="ly ir">return </strong>result</span></pre><p id="4e25" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你还记得，我说过我把所有东西都叫做“消息”服务器端。我决定这样做，这样我就可以在一个单独的处理程序中拥有我所有的逻辑，这个处理程序就是<code class="fe lv lw lx ly b">result.on('message', data =&gt; handler(data))</code>。这使得将数据传递给我的组件<code class="fe lv lw lx ly b">handleMessageAdd</code>处理程序并在所述处理程序中分离不同的消息类型逻辑变得容易。</p><p id="832b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当然，采用哪种方法取决于你自己。</p><p id="ccc5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将在<em class="kw">传入的</em>消息和<em class="kw">错误</em>上显示console.log()。</p><blockquote class="lg lh li"><p id="4d25" class="jy jz kw ka b kb kc kd ke kf kg kh ki lj kk kl km lk ko kp kq ll ks kt ku kv ij bi translated">前端这边应该就这样了。最重要的是处理连接的<code class="fe lv lw lx ly b">lib/socket.js</code>文件和连接并处理接收消息的组件，当然可以是多个组件。</p></blockquote><p id="4e66" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以根据自己的意愿扩展这个应用程序，提供身份验证、消息删除、房间名称、房间编辑等功能。</p><p id="4aec" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi">—</p><p id="cce1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有用的来源:</p><ul class=""><li id="a5da" class="lm ln iq ka b kb kc kf kg kj lo kn lp kr lq kv lr ls lt lu bi translated">演示应用—<a class="ae mn" href="https://adonis-sockets-frontend.herokuapp.com/#/" rel="noopener ugc nofollow" target="_blank">https://adonis-sockets-frontend.herokuapp.com/</a>(打开你的控制台！)——<em class="kw">你可能会经历10秒钟的加载时间，因为这些应用程序是托管在Heroku上的。</em></li><li id="0c9c" class="lm ln iq ka b kb lz kf ma kj mb kn mc kr md kv lr ls lt lu bi translated">单一回购来源—<a class="ae mn" href="https://gitlab.com/djanoskova/adonisjs-sockets-monorepo" rel="noopener ugc nofollow" target="_blank">https://gitlab.com/djanoskova/adonisjs-sockets-monorepo</a></li><li id="fb54" class="lm ln iq ka b kb lz kf ma kj mb kn mc kr md kv lr ls lt lu bi translated">套接字上的AdonisJs文档—<a class="ae mn" href="https://adonisjs.com/docs/4.1/websocket" rel="noopener ugc nofollow" target="_blank">https://adonisjs.com/docs/4.1/websocket</a>，<a class="ae mn" href="https://adonisjs.com/docs/4.1/websocket-server" rel="noopener ugc nofollow" target="_blank">https://adonisjs.com/docs/4.1/websocket-server</a></li><li id="ab40" class="lm ln iq ka b kb lz kf ma kj mb kn mc kr md kv lr ls lt lu bi translated">评论！问你需要什么，给别人提建议。</li></ul><p id="9893" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">感谢您的阅读。一如既往，祝你好运，鼓励你继续努力！🎉</p></div></div>    
</body>
</html>