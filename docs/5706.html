<html>
<head>
<title>Expanding Single Page Apps into multiple Browser Windows — Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将单页应用扩展到多个浏览器窗口——第2部分</h1>
<blockquote>原文：<a href="https://itnext.io/expanding-single-page-apps-into-multiple-browser-windows-part-2-2619ab40361d?source=collection_archive---------2-----------------------#2021-05-07">https://itnext.io/expanding-single-page-apps-into-multiple-browser-windows-part-2-2619ab40361d?source=collection_archive---------2-----------------------#2021-05-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="7879" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">包括跨浏览器窗口懒惰加载的CSS增量更新</p><p id="d5e7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这篇文章介绍了一种突破性的新方法，关于我们如何进一步提高基于web的前端的渲染性能，因为我们将根据需要延迟加载CSS。</p><h1 id="f980" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">内容</h1><ol class=""><li id="70d5" class="lj lk iq jp b jq ll ju lm jy ln kc lo kg lp kk lq lr ls lt bi translated">介绍</li><li id="c9d7" class="lj lk iq jp b jq lu ju lv jy lw kc lx kg ly kk lq lr ls lt bi translated">neo.mjs中的三种不同环境</li><li id="164c" class="lj lk iq jp b jq lu ju lv jy lw kc lx kg ly kk lq lr ls lt bi translated">OOP为什么会“过时”？</li><li id="ea6d" class="lj lk iq jp b jq lu ju lv jy lw kc lx kg ly kk lq lr ls lt bi translated">跨浏览器窗口CSS增量更新</li><li id="fc83" class="lj lk iq jp b jq lu ju lv jy lw kc lx kg ly kk lq lr ls lt bi translated">这是如何工作的？</li><li id="aa65" class="lj lk iq jp b jq lu ju lv jy lw kc lx kg ly kk lq lr ls lt bi translated">接下来是什么？</li><li id="7d89" class="lj lk iq jp b jq lu ju lv jy lw kc lx kg ly kk lq lr ls lt bi translated">呼吁行动！</li></ol><h1 id="83a3" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">1.介绍</h1><p id="0040" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">自从我写完第1部分已经有一段时间了。如果你错过了，它绝对值得一读:</p><div class="mc md gp gr me mf"><a href="https://medium.com/swlh/expanding-single-page-apps-into-multiple-browser-windows-e6d9bd155d59" rel="noopener follow" target="_blank"><div class="mg ab fo"><div class="mh ab mi cl cj mj"><h2 class="bd ir gy z fp mk fr fs ml fu fw ip bi translated">将单页应用程序扩展到多个浏览器窗口</h2><div class="mm l"><h3 class="bd b gy z fp mk fr fs ml fu fw dk translated">内容</h3></div><div class="mn l"><p class="bd b dl z fp mk fr fs ml fu fw dk translated">medium.com</p></div></div><div class="mo l"><div class="mp l mq mr ms mo mt mu mf"/></div></div></a></div><p id="53e6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">neo.mjs 项目已经发展了很多。让我们再来看看多窗口covid dashboard应用程序:</p><figure class="mw mx my mz gt na"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="4846" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">应用程序工作人员仍然是主角。在<a class="ae mv" href="https://github.com/neomjs/neo" rel="noopener ugc nofollow" target="_blank"> neo.mjs </a>中，我们不仅仅是将昂贵的任务转移到<a class="ae mv" href="https://developer.mozilla.org/en-US/docs/Web/API/Worker" rel="noopener ugc nofollow" target="_blank">专用</a>或<a class="ae mv" href="https://developer.mozilla.org/en-US/docs/Web/API/SharedWorker" rel="noopener ugc nofollow" target="_blank">共享工人</a>中。相反，您的应用程序和组件实际上就在那里。我们可以将主线程描述为“渲染工人”。Main只有42KB的代码，用于创建工人、操作DOM和委托UI事件。</p><p id="af56" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您关注app worker控制台，您会看到我们现在正在根据需要为新视图延迟加载JS模块。当将现有的组件树移动到不同的窗口时，我们不需要再次加载它们。我们也不需要为我们的视图创建新的JS实例，我们实际上重用了现有的实例。</p><p id="a9aa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在创建新的主题引擎之前,<a class="ae mv" href="https://github.com/neomjs/neo" rel="noopener ugc nofollow" target="_blank"> neo.mjs </a>项目使用的是单片CSS输出，这与Javascript端的美丽工作方式并不相称。</p><p id="8313" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您对如何使用来自文件缓冲区的<code class="fe nd ne nf ng b">sass.render()</code>创建一个定制的SCSS版本感兴趣，请随意阅读我以前的文章。</p><p id="8291" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本文还包含关于<a class="ae mv" href="https://github.com/neomjs/neo" rel="noopener ugc nofollow" target="_blank"> neo.mjs </a> SCSS结构的一般信息(例如，解释不同的模式→使用包含或不包含CSS变量来构建SCSS)。</p><div class="mc md gp gr me mf"><a rel="noopener  ugc nofollow" target="_blank" href="/how-to-create-a-file-by-file-custom-scss-build-including-dependencies-using-postcss-and-optional-c83f8e5677d8"><div class="mg ab fo"><div class="mh ab mi cl cj mj"><h2 class="bd ir gy z fp mk fr fs ml fu fw ip bi translated">如何创建一个文件由文件自定义SCSS建立包括依赖关系，使用postcss和可选的…</h2><div class="mm l"><h3 class="bd b gy z fp mk fr fs ml fu fw dk translated">虽然这听起来像是一个常见的问题，但我无法在网上找到一个好的解决方案。所以我想写作…</h3></div><div class="mn l"><p class="bd b dl z fp mk fr fs ml fu fw dk translated">itnext.io</p></div></div><div class="mo l"><div class="nh l mq mr ms mo mt mu mf"/></div></div></a></div><p id="6ee4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有了粒度CSS输出，我们现在可以根据需要延迟加载基于类的CSS文件:</p><figure class="mw mx my mz gt na"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="f104" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此时你可能会想:“嗯，我也可以使用<a class="ae mv" href="https://github.com/webpack/webpack" rel="noopener ugc nofollow" target="_blank"> webpack </a>创建CSS分割块，这有什么大不了的？”</p><p id="df9f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是正确的，但是请等待多窗口上下文:)</p><h1 id="8c96" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">2.neo.mjs中的三种不同环境</h1><p id="d273" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">我得到的反馈是一些基本概念还不太清楚。在我们进入“好东西”之前，让我们简短地介绍一下，以确保我们在同一页上。</p><p id="006a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">万一你打开网上的例子【https://neomjs.github.io/pages/<br/>T3</p><p id="afaa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您将看到三种不同的模式:</p><figure class="mw mx my mz gt na gh gi paragraph-image"><div role="button" tabindex="0" class="nj nk di nl bf nm"><div class="gh gi ni"><img src="../Images/e08bf87faa7df78a19ab1ab3d675c5e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wuqO0BwaL_6PcH-rtuuF1Q.png"/></div></div></figure><p id="cc01" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> dist/production <br/> </strong>我们在JS端使用基于<a class="ae mv" href="https://github.com/webpack/webpack" rel="noopener ugc nofollow" target="_blank"> webpack </a>的构建。即使在不同的应用程序中，我们也会得到缩小的分割块。CSS输出也会缩小。两者都没有源映射。这是您完成开发后部署的最快版本。</p><p id="b5bf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> dist/development <br/> </strong>如果你使用的是Angular、React或Vue，这就是你习惯称之为开发模式的东西。这是一个没有缩小的基于webpack的构建，包含JS端的源代码图，让你能够看到实际上潜在的错误发生在哪里。</p><p id="e518" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">开发模式<br/> </strong>这是<a class="ae mv" href="https://github.com/neomjs/neo" rel="noopener ugc nofollow" target="_blank"> neo.mjs </a>的独特之处。您可以直接在浏览器中运行真正的代码。如果您更改了您的代码库，您会立即得到这些更改。不需要构建、移植或热模块替换。你可以100%确定没有外部因素导致bug。</p><p id="bcf3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将UI开发带回浏览器不仅仅是一个浪漫的想法。浏览器已经准备好了。你也应该这样。</p><h1 id="a4df" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">3.OOP为什么会“过时”？</h1><p id="868a" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">我们可以扩展课程。这允许我们添加新方法、覆盖方法、添加和更改类字段。这样可以减少很多冗余。你可以使用工厂设计模式来接近它，但在大项目中它会弄得一团糟。</p><p id="b7f3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在ES6类系统之上添加一个配置系统使得扩展类更加强大。我们可以批量更新配置，减少对vdom引擎的调用。</p><p id="583e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我经历过许多处理内存泄漏的高调项目。经常发生的情况是，开发人员在创建组件方面做得很好，但是忽略了析构方面。比如使用数据存储，并且在需要时不销毁它。</p><p id="f7e5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么，哪里出了问题？</p><p id="0bb5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">真正的问题是声明性的(模板驱动的)库和框架。其中一些提供了一个<code class="fe nd ne nf ng b">Component.render()</code>方法，允许您定义标记，包括匹配组件名称的定制标签。调用<code class="fe nd ne nf ng b">render()</code>将为使用的定制标签创建JS实例。再次调用<code class="fe nd ne nf ng b">render()</code>将销毁以前的实例并创建新的实例。</p><p id="347c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在猜猜如果你改变状态会发生什么？对，这个就叫<code class="fe nd ne nf ng b">render()</code>。内存泄漏的乘数，在我看来，这也是函数式编程流行的关键原因之一。</p><p id="4462" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于JS一方负责的编程方法来说，这是一个非常不同的故事。在<a class="ae mv" href="https://github.com/neomjs/neo" rel="noopener ugc nofollow" target="_blank"> neo.mjs </a>中调用<code class="fe nd ne nf ng b">Component.render()</code>既不会创建也不会销毁任何js实例。如果你想做这件事，什么时候做都是你在掌控之中。这使得“重用组件(JS实例)”成为可能，这也是我在提到跨不同浏览器窗口移动组件树时经常提到的，即使这样也会保留相同的JS实例。</p><p id="cd0e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你的零件值得比单程票更多的爱。用了<strong class="jp ir">右</strong>，OOP没毛病。</p><h1 id="032a" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">4.跨浏览器窗口CSS增量更新</h1><p id="90d8" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">回到多窗口covid应用程序。如果您查看不同的入口点:</p><p id="3989" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae mv" href="https://github.com/neomjs/neo/tree/dev/apps/sharedcovid" rel="noopener ugc nofollow" target="_blank"> apps/sharedcovid </a>、<a class="ae mv" href="https://github.com/neomjs/neo/tree/dev/apps/sharedcovidchart" rel="noopener ugc nofollow" target="_blank"> apps/sharedcovidchart </a>、<a class="ae mv" href="https://github.com/neomjs/neo/tree/dev/apps/sharedcovidgallery" rel="noopener ugc nofollow" target="_blank">apps/sharedcovidgallery</a>等。</p><p id="ac8d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您会注意到，只有第一个(主)应用程序包含多个视图和控制器。所有子应用程序只包含一个空的视口。</p><figure class="mw mx my mz gt na"><div class="bz fp l di"><div class="no nc l"/></div></figure><p id="eca3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们要将视图移动到不同的浏览器窗口中，我们只需使用:</p><pre class="mw mx my mz gt np ng nq nr aw ns bi"><span id="0b56" class="nt km iq ng b gy nu nv l nw nx">parentView.remove(view, false); // false keeps the instance alive<br/>me.getMainView(appName).add(view);</span></pre><p id="ee52" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">真的就这么简单。</p><p id="ce2f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，在子应用程序的CSS方面，我们希望最初加载视口(和父链)的文件，一旦我们从主应用程序动态地移动视图，此时就加载丢失的CSS文件。</p><p id="3ec0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用弹出窗口显示有点棘手(没有增加延迟)，所以我使用普通窗口来显示它。我还添加了一个3s的延迟来使它更加清晰:</p><figure class="mw mx my mz gt na"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="b6b8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在可能最令人印象深刻的演示是在跨浏览器窗口拖放演示中使用CSS delta更新。</p><p id="9f7d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个应用程序需要一点调整:当在一个窗口中开始拖动操作时，我们在拖动到另一个窗口时创建一个拖动代理元素(节点)。拖动代理基于对话框样式。然而，我们很可能还没有在“window2”中创建对话框。</p><p id="a9ff" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不过，我们可以用一行代码来解决这个问题:</p><pre class="mw mx my mz gt np ng nq nr aw ns bi"><span id="7589" class="nt km iq ng b gy nu nv l nw nx"><strong class="ng ir"><em class="ny">Neo</em></strong>.currentWorker.insertThemeFiles(dockedWindowAppName, <strong class="ng ir"><em class="ny">Neo</em></strong>.<strong class="ng ir"><em class="ny">dialog</em></strong>.Base.prototype);</span></pre><p id="7ee1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您查看控制台日志(网络→ CSS)，您会看到当代理进入window2时，对话框样式被加载到window 2中。</p><p id="310d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">放下时，窗口还会加载对话框内容样式(文本字段)。在window2中启动拖动操作将加载真正的拖动代理CSS(以前不需要)。进一步的拖放操作不需要加载文件(没有增量)。</p><figure class="mw mx my mz gt na"><div class="bz fp l di"><div class="nb nc l"/></div></figure><h1 id="8a01" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">5.这是如何工作的？</h1><p id="9913" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">具有挑战性的部分无疑是生成基于文件的CSS输出。你可以在顶部的文章链接中深入了解细节。</p><p id="8706" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我需要对源地图做一点“猴子修补”。行号并不总是正确的，所以我们需要确保内容文件之前的文件缓冲区以一行结束(首先删除注释，然后删除换行符)。地图还显示“stdin”而不是文件名。通过调整内部数组集映射很容易修复。</p><p id="5b10" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae mv" href="https://github.com/neomjs/neo/blob/dev/buildScripts/buildThemes.js#L264" rel="noopener ugc nofollow" target="_blank">dev/build scripts/build themes . js # L264</a></p><p id="af03" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对这个文件更重要的补充是生成一个基于JSON的文件结构图:</p><figure class="mw mx my mz gt na gh gi paragraph-image"><div role="button" tabindex="0" class="nj nk di nl bf nm"><div class="gh gi nz"><img src="../Images/52429a1ef04012af405da16b4a96dd56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qmukYEpUnNTKFsFHkZKC-A.png"/></div></div></figure><p id="e936" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">(现实中被缩小了。)</p><p id="eda5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的应用程序工作人员现在需要加载这个文件(或者不使用CSS变量的版本)一次，即使在使用多个窗口时也是如此。</p><p id="1178" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于文件可能在第一个组件需要CSS之后到达，所以我也在app worker中添加了一个缓存映射。</p><p id="ad52" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">像<code class="fe nd ne nf ng b">component.Base</code>这样的类正在使用一个<code class="fe nd ne nf ng b">appName_</code>配置。如果有变化，它将触发:</p><figure class="mw mx my mz gt na"><div class="bz fp l di"><div class="no nc l"/></div></figure><p id="c52e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们创建一个类的新实例，或者将一个现有实例插入到一个<code class="fe nd ne nf ng b">container.Base</code>中，就会发生这种情况。</p><figure class="mw mx my mz gt na"><div class="bz fp l di"><div class="no nc l"/></div></figure><p id="46d1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该类将更新直接子项。因此，当我们将任何类型的组件树插入到一个新的应用程序(不同的浏览器窗口)中时，所有子项都将获得新的<code class="fe nd ne nf ng b">appName</code>，从而在新的主线程中加载它们的CSS文件(如果需要的话)。</p><p id="cbc7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">应用程序工作人员执行以下操作:</p><figure class="mw mx my mz gt na"><div class="bz fp l di"><div class="no nc l"/></div></figure><p id="aeaa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果这个类有CSS文件，它会检查cssMap。它还检查原型链(例如，<code class="fe nd ne nf ng b">button.Split</code>可以使用<code class="fe nd ne nf ng b">button.Base</code>的样式)。</p><p id="10aa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">添加文件将向地图添加一个标志，以确保它不会在给定范围(应用程序)内加载多次。</p><figure class="mw mx my mz gt na gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/ee3578db499161a324eeda27c1d88225.png" data-original-src="https://miro.medium.com/v2/resize:fit:1162/format:webp/1*L8_bsJLSyxBuEy2MadKh_w.png"/></div></figure><p id="a436" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这已经是我们启用跨窗口CSS增量更新所需要的全部了。</p><h1 id="a190" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">6.接下来是什么？</h1><p id="573c" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">为了完成v2.1版本，我仍然需要增强使用<a class="ae mv" href="https://github.com/neomjs/neo" rel="noopener ugc nofollow" target="_blank"> neo.mjs </a>作为节点模块的工作区，以便在这个级别上启用主题化。</p><p id="b401" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">工作区应该包含它们自己的resources/scss文件夹，所以构建需要将这里生成的文件添加到混合文件中。</p><p id="25f3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我可以创建一个快速指南，介绍如何在工作区内创建应用程序，在那里创建自定义组件并对它们进行样式化。如果你对此感兴趣，请告诉我！</p><p id="8dab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我收到了一些关于JSDoc和jsdoc-x的依赖警告。这两个项目都不再被维护，这是一个问题。他们正在使用包含不推荐使用的包的依赖关系，包括安全问题。我们可能只是将它们分叉，以确定手动调整依赖关系是否可以解决这个问题。如果没有，我们可能需要切换到其他东西或者创建一个定制的文档注释解析引擎。在这个问题上的帮助是赞赏的。</p><p id="6959" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">总的来说，我喜欢创造一些闪亮的新组件，但我试图保持专注于基础。含义:推动核心和生态系统，让你更容易创建自己的组件和应用。</p><h1 id="1236" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">7.呼吁行动！</h1><p id="62e0" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">大多数示例应用程序的初始渲染速度明显加快。不要相信我的话，你自己看吧:</p><div class="mc md gp gr me mf"><a href="https://github.com/neomjs/neo" rel="noopener  ugc nofollow" target="_blank"><div class="mg ab fo"><div class="mh ab mi cl cj mj"><h2 class="bd ir gy z fp mk fr fs ml fu fw ip bi translated">近地天体</h2><div class="mm l"><h3 class="bd b gy z fp mk fr fs ml fu fw dk translated">neo.mjs使您能够使用一个以上的CPU创建可扩展的高性能应用程序，而无需使用…</h3></div><div class="mn l"><p class="bd b dl z fp mk fr fs ml fu fw dk translated">github.com</p></div></div><div class="mo l"><div class="ob l mq mr ms mo mt mu mf"/></div></div></a></div><p id="a9ec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您需要帮助，欢迎加入neo.mjs Slack频道:</p><p id="75ac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">https://join.slack.com/t/neotericjs/<a class="ae mv" href="https://join.slack.com/t/neotericjs/shared_invite/enQtNDk2NjEwMTIxODQ2LWRjNGQ3ZTMzODRmZGM2NDM2NzZmZTMzZmE2YjEwNDM4NDhjZDllNWY2ZDkwOWQ5N2JmZWViYjYzZTg5YjdiMDc" rel="noopener ugc nofollow" target="_blank"/></p><p id="aa73" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我这边时间有限，但是我喜欢给好奇的开发者指出正确的方向。</p><p id="59b7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你的公司确实需要帮助创建一个原型应用程序来弄清楚neo.mjs在他们的场景中是如何发挥作用的，只需ping我。</p><p id="2196" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">作为麻省理工学院许可的开源项目，neo.mjs依赖于您的支持。你可以影响路线图。我在v2发布公告中列出了几个潜在的项目:</p><div class="mc md gp gr me mf"><a rel="noopener  ugc nofollow" target="_blank" href="/the-webworkers-driven-ui-framework-neo-mjs-version-2-release-announcement-b91b476d6f16"><div class="mg ab fo"><div class="mh ab mi cl cj mj"><h2 class="bd ir gy z fp mk fr fs ml fu fw ip bi translated">webworkers驱动的UI框架neo.mjs第2版发布公告</h2><div class="mm l"><h3 class="bd b gy z fp mk fr fs ml fu fw dk translated">新产品的概念必须是颠覆性的，否则就没什么必要。然而，使用它们的方法…</h3></div><div class="mn l"><p class="bd b dl z fp mk fr fs ml fu fw dk translated">itnext.io</p></div></div><div class="mo l"><div class="oc l mq mr ms mo mt mu mf"/></div></div></a></div><p id="e548" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你想看某个特定主题的新文章，欢迎你为它创建门票:【github.com/neomjs/neo/issues<a class="ae mv" href="https://github.com/neomjs/neo/issues" rel="noopener ugc nofollow" target="_blank"/></p><p id="9093" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">问候&amp;快乐编码，<br/>托拜厄斯</p><p id="09eb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">预览图像:</p><figure class="mw mx my mz gt na gh gi paragraph-image"><div role="button" tabindex="0" class="nj nk di nl bf nm"><div class="gh gi od"><img src="../Images/08935673d65af776dcdfd74e2c7edc9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uNhGZG6mEaHRixQoiSf1_Q.png"/></div></div></figure></div></div>    
</body>
</html>