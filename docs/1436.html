<html>
<head>
<title>A Beginner’s Guide to Understanding JavaScript Closures</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解JavaScript闭包的初学者指南</h1>
<blockquote>原文：<a href="https://itnext.io/a-beginners-guide-to-understanding-javascript-closures-b5eb57fdbeb4?source=collection_archive---------4-----------------------#2018-10-13">https://itnext.io/a-beginners-guide-to-understanding-javascript-closures-b5eb57fdbeb4?source=collection_archive---------4-----------------------#2018-10-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/ba0fbc1c27e01249b18e6538b846d4e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AJWhia2_QH77RYEWhsLsWA.jpeg"/></div></div></figure><p id="b803" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">闭包是大多数JavaScript访谈中会出现的话题之一。刚刚起步的开发人员通常害怕它们(我知道我曾经害怕过)，但是没有理由害怕。就像递归一样，闭包可能会被过度解释，这让它们听起来很复杂，但在本质上，它们再简单不过了。我会用6行写一个来证明。</p><h1 id="4d91" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">一个非常基本的结束</h1><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="a123" class="mh lb it md b gy mi mj l mk ml">function outside() { <br/>  let x = 2<br/>  return function inside(y) {<br/>    return x * y<br/>  } <br/>}</span></pre><p id="8bc9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">嘣。这是一个简短的例子，因为闭包只是:</p><blockquote class="mm mn mo"><p id="b26a" class="kb kc mp kd b ke kf kg kh ki kj kk kl mq kn ko kp mr kr ks kt ms kv kw kx ky im bi translated">一个函数内部的另一个函数:1)使用其父作用域中的变量，2)向外界公开。</p></blockquote><p id="c247" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">“暴露”部分是我们使用闭包的一个重要原因。通过只公开函数，而不公开它使用的变量，我们实质上使它们成为私有的。但是在我们讨论闭包的用途之前，让我们先讨论一下如何创建一个闭包。</p><h1 id="afed" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">分解它</h1><p id="06fd" class="pw-post-body-paragraph kb kc it kd b ke mt kg kh ki mu kk kl km mv ko kp kq mw ks kt ku mx kw kx ky im bi translated">在这两个函数中，让我们先看看<code class="fe my mz na md b">outside</code>。在这个函数的范围内，会发生两件事:我们定义一个变量<code class="fe my mz na md b">x</code>为2，我们定义一个名为<code class="fe my mz na md b">inside</code>的函数，然后返回<em class="mp">定义</em>。返回它是“奇怪”的部分，因为我们通常不返回函数定义，我们只是调用它们。如果我们调用<code class="fe my mz na md b">outside()</code>，你可以看到<code class="fe my mz na md b">inside</code>的定义就是我们得到的:</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="c007" class="mh lb it md b gy mi mj l mk ml">outside()             <br/>//  <em class="mp">f </em>inside(y) {     <br/>//    return x * y <br/>//  }</span></pre><p id="6099" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">你可能以前见过类似的东西；函数定义是当我们忘记用<code class="fe my mz na md b">()</code>调用函数时的返回值:</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="01c6" class="mh lb it md b gy mi mj l mk ml">function example() {<br/>  return "My example value" <br/>}</span><span id="f258" class="mh lb it md b gy nb mj l mk ml">example<br/>// <em class="mp">f </em>example() {<br/>//    return "My example value"<br/>// }<br/> <br/>// What I MEANT to type was: <br/>example()<br/>// My example value</span></pre><p id="5f56" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因此，如果返回一个函数的计算值或其定义之间的唯一区别是<code class="fe my mz na md b">()</code>，如果我们添加另一个<code class="fe my mz na md b">()</code>，会发生什么？</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="2be5" class="mh lb it md b gy mi mj l mk ml">outside()(4)<br/>// 8</span></pre><p id="87ad" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们现在实际上调用了<code class="fe my mz na md b">inside</code>函数。返回一个函数定义，然后我们简单地调用这个返回值。下面是一些伪代码来说明这种关系:</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="df9e" class="mh lb it md b gy mi mj l mk ml">// if: <br/>outside() is: function inside(y) { <br/>                return x * y<br/>              } </span><span id="8f7a" class="mh lb it md b gy nb mj l mk ml">// then that means:<br/>outside()(5) is: inside(5)</span></pre><p id="0509" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">那个双<code class="fe my mz na md b">()</code>看起来很奇怪，所以通常人们会这样做:</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="f2ab" class="mh lb it md b gy mi mj l mk ml">let myClosure = outside() <br/>myClosure(5)<br/>// 10</span><span id="1eef" class="mh lb it md b gy nb mj l mk ml">// remember myClosure is outside(), <br/>// so then this is still the same thing:<br/> <br/>myClosure(5) === outside()(5)<br/>// true </span></pre><h1 id="39b3" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">x呢？</h1><p id="3834" class="pw-post-body-paragraph kb kc it kd b ke mt kg kh ki mu kk kl km mv ko kp kq mw ks kt ku mx kw kx ky im bi translated">闭包最好的部分是<code class="fe my mz na md b">x</code>，因为我们创建了一个变量，程序的其他部分无法触及，但我们仍然可以使用。这就是闭包的强大之处:它让我们创建除了闭包本身之外不能被任何函数修改或访问的值。</p><p id="fe27" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这样做的原因是因为作用域可以访问其父级中的值，但不能访问其子级中的值。<code class="fe my mz na md b">x</code>是在<code class="fe my mz na md b">inside</code>的父作用域中定义的，所以<code class="fe my mz na md b">inside</code>仍然可以访问它并乘以<code class="fe my mz na md b">y</code>。然而，唯一暴露于全局范围的是<code class="fe my mz na md b">inside</code>、<em class="mp">而不是</em>变量<code class="fe my mz na md b">x</code>的定义。这意味着在我们的整个程序中，我们与<code class="fe my mz na md b">x</code>交互的唯一方式是使用闭包。看看这段<strong class="kd iu">没有</strong>使用闭包的代码:</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="63d8" class="mh lb it md b gy mi mj l mk ml">let x = 2 // global scope<br/>function inside(y) {<br/>  return x * y  // reaching up to global scope<br/>}<br/>inside(4)<br/>// 8</span><span id="765d" class="mh lb it md b gy nb mj l mk ml">// but we can change the 'x'<br/>// variable in the global scope and <br/>// alter inside()'s behavior</span><span id="1cc9" class="mh lb it md b gy nb mj l mk ml">x = 5<br/>inside(4)<br/>// 20</span></pre><p id="9198" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们试着做同样的事情，但是这次用闭包来保护我们的<code class="fe my mz na md b">x</code>:</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="9c0f" class="mh lb it md b gy mi mj l mk ml">function outside() {          <br/>  let x = 2                    <br/>  return function inside(y) {  <br/>    return x * y               <br/>  }                    <br/>}</span><span id="79c2" class="mh lb it md b gy nb mj l mk ml">let myClosure = outside()</span><span id="d4c8" class="mh lb it md b gy nb mj l mk ml">myClosure(5)                   <br/>// 10</span><span id="7974" class="mh lb it md b gy nb mj l mk ml">x = 4<br/>// this is not the same 'x' variable: <br/><br/>myClosure(5)<br/>// 10      // notice how it's still 10 </span></pre><p id="f888" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe my mz na md b">x</code>是在我们的<code class="fe my mz na md b">outside</code>函数中定义的，所以全局范围内的任何东西都无法深入其中并改变它。当我们试图将<code class="fe my mz na md b">x</code>重新赋值为4时，这实际上是一个不同的<code class="fe my mz na md b">x</code>变量，它现在单独存在于我们的全局范围内，根本不影响<code class="fe my mz na md b">myClosure</code>的工作方式。</p><p id="e867" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">正如你所看到的，闭包的基础很简单:它们只依赖于作用域能够向上延伸，而不能向下延伸。现在你已经知道了基础知识，试着学习一下<a class="ae kz" href="https://blog.mgechev.com/2012/08/29/self-invoking-functions-in-javascript-or-immediately-invoked-function-expression/" rel="noopener ugc nofollow" target="_blank">如何立即调用函数表达式(iife)</a>使用闭包来创建一些简单而有用的东西:<a class="ae kz" href="https://www.w3schools.com/js/js_function_closures.asp" rel="noopener ugc nofollow" target="_blank">一个不可触及的计数器</a>。</p><p id="df0a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">大家编码快乐，</p><p id="60a5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">迈克</p></div></div>    
</body>
</html>