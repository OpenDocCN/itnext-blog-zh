<html>
<head>
<title>Build FFmpeg WebAssembly version (= ffmpeg.wasm): Part.2 Compile with Emscripten</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建FFmpeg WebAssembly版本(= ffmpeg.wasm):第2部分用Emscripten编译</h1>
<blockquote>原文：<a href="https://itnext.io/build-ffmpeg-webassembly-version-ffmpeg-js-part-2-compile-with-emscripten-4c581e8c9a16?source=collection_archive---------3-----------------------#2019-10-13">https://itnext.io/build-ffmpeg-webassembly-version-ffmpeg-js-part-2-compile-with-emscripten-4c581e8c9a16?source=collection_archive---------3-----------------------#2019-10-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div class="gh gi jq"><img src="../Images/8c0c378d4f8e771bf56ebf20e4685f63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*bJYwDAe6Hj59mpHZr46olQ.png"/></div></figure><blockquote class="jx jy jz"><p id="4554" class="ka kb kc kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="it"> 2020/9更新:修改故事，使其在MacOS中工作。</em></p><p id="f2d0" class="ka kb kc kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">2020/2/11更新:从这个故事的反应来看，目前遵循指令在Mac环境下不起作用。我无法解决这个问题，因为我没有自己的问题。在Mac中最简单的方法就是在虚拟机中安装像Ubuntu一样的linux发行版。</p></blockquote><p id="ee8c" class="pw-post-body-paragraph ka kb it kd b ke kf kg kh ki kj kk kl kz kn ko kp la kr ks kt lb kv kw kx ky im bi translated">上一个故事:<a class="ae lc" href="https://medium.com/@jeromewus/build-ffmpeg-webassembly-version-ffmpeg-js-part-1-preparation-ed12bf4c8fac" rel="noopener">构建FFmpeg WebAssembly版本(= ffmpeg.wasm): Part.1准备</a></p><blockquote class="jx jy jz"><p id="103d" class="ka kb kc kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">从这里开始，事情将变得更加复杂和难以理解，如果你不知道发生了什么，你可能需要谷歌背景知识(或者你可以留下回答来问我)。</p><p id="6924" class="ka kb kc kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">此外，为了使本教程更有用，我试着写下我如何解决每个问题的细节，希望它能帮助你建立你选择的库。</p></blockquote><p id="5505" class="pw-post-body-paragraph ka kb it kd b ke kf kg kh ki kj kk kl kz kn ko kp la kr ks kt lb kv kw kx ky im bi translated">在这一部分，您将学习:</p><ol class=""><li id="f775" class="ld le it kd b ke kf ki kj kz lf la lg lb lh ky li lj lk ll bi translated">如何使用Docker设置脚本环境</li><li id="ad45" class="ld le it kd b ke lm ki ln kz lo la lp lb lq ky li lj lk ll bi translated"><code class="fe lr ls lt lu b">emconfigure</code>和<code class="fe lr ls lt lu b">emmake</code>的用法</li><li id="e12e" class="ld le it kd b ke lm ki ln kz lo la lp lb lq ky li lj lk ll bi translated">如何修复用Emscripten编译FFmpeg时的问题</li></ol></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="77a2" class="mc md it bd me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz bi translated">如何使用Docker设置脚本环境</h1><p id="05cd" class="pw-post-body-paragraph ka kb it kd b ke na kg kh ki nb kk kl kz nc ko kp la nd ks kt lb ne kw kx ky im bi translated">在<a class="ae lc" href="https://medium.com/@jeromewus/build-ffmpeg-webassembly-version-ffmpeg-js-part-1-preparation-ed12bf4c8fac" rel="noopener">构建FFmpeg WebAssembly版本(= ffmpeg.wasm): Part.1准备</a>中，我们已经用GCC构建了FFmpeg的原始版本，现在我们转而使用Emscripten。</p><p id="d440" class="pw-post-body-paragraph ka kb it kd b ke kf kg kh ki kj kk kl kz kn ko kp la kr ks kt lb kv kw kx ky im bi translated">我们要用的emscripten的版本是1 . 39 . 18(trz ECI/Emscripten:1 . 39 . 18-upstream)，你可以通过<a class="ae lc" href="https://emscripten.org/docs/getting_started/downloads.html#installation-instructions" rel="noopener ugc nofollow" target="_blank">官方教程</a>安装Emscripten(本教程中我们是<a class="ae lc" href="https://github.com/mymindstorm/setup-emsdk" rel="noopener ugc nofollow" target="_blank">setup-EMS dk</a>Github Actions in MAC OS)或者从docker hub拉Emscripten镜像。</p><pre class="nf ng nh ni gt nj lu nk nl aw nm bi"><span id="9c00" class="nn md it lu b gy no np l nq nr">$ docker pull trzeci/emscripten:1.39.18-upstream</span></pre><blockquote class="jx jy jz"><p id="f6ba" class="ka kb kc kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这可能需要几分钟的时间，因为映像的大小约为1 GB。</p></blockquote><p id="fc58" class="pw-post-body-paragraph ka kb it kd b ke kf kg kh ki kj kk kl kz kn ko kp la kr ks kt lb kv kw kx ky im bi translated">然后我们需要更新<code class="fe lr ls lt lu b">build-with-docker.sh</code>如下:</p><figure class="nf ng nh ni gt ju"><div class="bz fp l di"><div class="ns nt l"/></div></figure><blockquote class="jx jy jz"><p id="ff15" class="ka kb kc kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">第8行不是必需的，但是它可以帮助您在后续构建中加快速度。</p></blockquote><p id="bc46" class="pw-post-body-paragraph ka kb it kd b ke kf kg kh ki kj kk kl kz kn ko kp la kr ks kt lb kv kw kx ky im bi translated">下一步我们要做的是找到用emscripten构建FFmpeg的配置，这是一个试错的过程，需要挖掘文档和耐心。</p><h1 id="92e2" class="mc md it bd me mf nu mh mi mj nv ml mm mn nw mp mq mr nx mt mu mv ny mx my mz bi translated"><code class="fe lr ls lt lu b">emconfigure </code>和<code class="fe lr ls lt lu b">emmake &amp; </code>的用法如何修复用Emscripten编译FFmpeg时的问题</h1><p id="d7b0" class="pw-post-body-paragraph ka kb it kd b ke na kg kh ki nb kk kl kz nc ko kp la nd ks kt lb ne kw kx ky im bi translated">让我们开始寻找正确配置的旅程。在Part.1中，它以<code class="fe lr ls lt lu b">./configure --disable-x86asm</code>开头，要用emscripten来做，需要把它改成<code class="fe lr ls lt lu b">emconfigure ./configure --disable-x86asm</code>。(有关emconfigure的详细信息，请查看此处的<a class="ae lc" href="https://emscripten.org/docs/compiling/Building-Projects.html#integrating-with-a-build-system" rel="noopener ugc nofollow" target="_blank"/>)由于我们正在进行交叉编译，因此需要添加交叉编译标志来明确告知FFmpeg。</p><p id="7820" class="pw-post-body-paragraph ka kb it kd b ke kf kg kh ki kj kk kl kz kn ko kp la kr ks kt lb kv kw kx ky im bi translated">下面我们来更新一下<code class="fe lr ls lt lu b">build.sh</code>吧:</p><figure class="nf ng nh ni gt ju"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="2482" class="pw-post-body-paragraph ka kb it kd b ke kf kg kh ki kj kk kl kz kn ko kp la kr ks kt lb kv kw kx ky im bi translated">神奇的是，没有任何错误，所以我们只需要输入<code class="fe lr ls lt lu b">emmake make -j</code>就可以得到FFmpeg.wasm了吗？不幸的是，答案是否定的，<code class="fe lr ls lt lu b">emconfigure</code>最重要的任务之一就是将编译器从gcc替换为emcc(或者g++替换为em++)，但是在<code class="fe lr ls lt lu b">./configure</code>的输出中，我们仍然得到gcc作为我们的编译器。</p><pre class="nf ng nh ni gt nj lu nk nl aw nm bi"><span id="3087" class="nn md it lu b gy no np l nq nr">emscripten sdl2-config called with /emsdk_portable/emscripten/tag-1.38.45/system/bin/sdl2-config --cflags                            <br/>emscripten sdl2-config called with /emsdk_portable/emscripten/tag-1.38.45/system/bin/sdl2-config --libs                               <br/>install prefix            /usr/local                                                                                                   <br/>source path               .                                                                                                                <br/>C compiler                gcc             # Should be emcc                                                                                             <br/>C library                 glibc                                                                                                           <br/>ARCH                      x86 (generic)                                                                                                     <br/>big-endian                no                                                                                                            <br/>runtime cpu detection     yes                                                                                                         <br/>standalone assembly       no                                                                                                            <br/>x86 assembler             nasm</span></pre><p id="d136" class="pw-post-body-paragraph ka kb it kd b ke kf kg kh ki kj kk kl kz kn ko kp la kr ks kt lb kv kw kx ky im bi translated">每个自动化工具都有其局限性，在这种情况下，我们需要手动操作。让我们检查一下是否有任何论点可以拯救我们。</p><pre class="nf ng nh ni gt nj lu nk nl aw nm bi"><span id="b90b" class="nn md it lu b gy no np l nq nr">$ ./configure --help</span></pre><p id="80f7" class="pw-post-body-paragraph ka kb it kd b ke kf kg kh ki kj kk kl kz kn ko kp la kr ks kt lb kv kw kx ky im bi translated">在<code class="fe lr ls lt lu b">Toolchain options</code>下，有参数分配编译器使用。</p><pre class="nf ng nh ni gt nj lu nk nl aw nm bi"><span id="ac38" class="nn md it lu b gy no np l nq nr">root@57ab95def750:/src# ./configure --help<br/>Usage: configure [options]<br/>Options: [defaults in brackets after descriptions]</span><span id="acb9" class="nn md it lu b gy nz np l nq nr">Help options:<br/>...<br/>Toolchain options:                                                                                                             <br/>...<br/>  --nm=NM                  use nm tool NM [nm -g]<br/>  --ar=AR                  use archive tool AR [ar]<br/>  --as=AS                  use assembler AS []<br/>  --ln_s=LN_S              use symbolic link tool LN_S [ln -s -f]<br/>  --strip=STRIP            use strip tool STRIP [strip]<br/>  --windres=WINDRES        use windows resource compiler WINDRES [windres]<br/>  --x86asmexe=EXE          use nasm-compatible assembler EXE [nasm]<br/>  --cc=CC                  use C compiler CC [gcc]<br/>  --cxx=CXX                use C compiler CXX [g++]<br/>  --objcc=OCC              use ObjC compiler OCC [gcc]<br/>  --dep-cc=DEPCC           use dependency generator DEPCC [gcc]<br/>  --nvcc=NVCC              use Nvidia CUDA compiler NVCC [nvcc]<br/>  --ld=LD                  use linker LD []<br/>...</span></pre><p id="d2f2" class="pw-post-body-paragraph ka kb it kd b ke kf kg kh ki kj kk kl kz kn ko kp la kr ks kt lb kv kw kx ky im bi translated">让我们在<code class="fe lr ls lt lu b">build.sh</code>中将这些参数传递给emscripten进行编译:</p><figure class="nf ng nh ni gt ju"><div class="bz fp l di"><div class="ns nt l"/></div></figure><blockquote class="jx jy jz"><p id="67cb" class="ka kb kc kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于本机版本，请确保<code class="fe lr ls lt lu b">llvm-ranlib</code>、<code class="fe lr ls lt lu b">llvm-as</code>和<code class="fe lr ls lt lu b">llvm-nm</code>存在。如果没有，您可以在<code class="fe lr ls lt lu b">$EMSDK_ROOT/upstream/bin</code>中找到它们。</p></blockquote><p id="21a5" class="pw-post-body-paragraph ka kb it kd b ke kf kg kh ki kj kk kl kz kn ko kp la kr ks kt lb kv kw kx ky im bi translated">有了这些参数，<code class="fe lr ls lt lu b">./configure</code>将会花费更多的时间来运行，但是你最终会得到想要的输出。</p><pre class="nf ng nh ni gt nj lu nk nl aw nm bi"><span id="6bf7" class="nn md it lu b gy no np l nq nr">emscripten sdl2-config called with /emsdk_portable/emscripten/tag-1.39.18/system/bin/sdl2-config --cflags                            <br/>emscripten sdl2-config called with /emsdk_portable/emscripten/tag-1.39.18/system/bin/sdl2-config --libs                                     <br/>install prefix            /usr/local                                                                                                   <br/>source path               .                                                                                                         <br/>C compiler                emcc         # emcc as expected                                                                                    <br/>C library                                                                                                                          <br/>ARCH                      x86 (generic)                                                                                                     <br/>big-endian                no                                                                                                              <br/>runtime cpu detection     yes                                                                                                             <br/>standalone assembly       no</span></pre><p id="3360" class="pw-post-body-paragraph ka kb it kd b ke kf kg kh ki kj kk kl kz kn ko kp la kr ks kt lb kv kw kx ky im bi translated">在<code class="fe lr ls lt lu b">build.sh</code>的末尾添加<code class="fe lr ls lt lu b">emmake make -j4</code>(您可以将并行度提高到类似<code class="fe lr ls lt lu b">-j8</code>或简单地使用<code class="fe lr ls lt lu b">-j</code>来使用所有内核):</p><figure class="nf ng nh ni gt ju"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="2935" class="pw-post-body-paragraph ka kb it kd b ke kf kg kh ki kj kk kl kz kn ko kp la kr ks kt lb kv kw kx ky im bi translated">并且在执行后会立即失败:</p><pre class="nf ng nh ni gt nj lu nk nl aw nm bi"><span id="14be" class="nn md it lu b gy no np l nq nr">...<br/>./libavutil/x86/timer.h:39:24: error: invalid output constraint '=a' in asm<br/>                     : "=a" (a), "=d" (d));<br/>                       ^</span></pre><p id="1c8b" class="pw-post-body-paragraph ka kb it kd b ke kf kg kh ki kj kk kl kz kn ko kp la kr ks kt lb kv kw kx ky im bi translated">从输出消息中，我们可以确定该错误与asm有关。打开<code class="fe lr ls lt lu b">./libavutil/x86/timer.h</code>，我们可以确认问题是由x86内联汇编引起的，它与WebAssembly不兼容，因此解决方案是在<code class="fe lr ls lt lu b">build.sh</code>中禁用它:</p><figure class="nf ng nh ni gt ju"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="6bf8" class="pw-post-body-paragraph ka kb it kd b ke kf kg kh ki kj kk kl kz kn ko kp la kr ks kt lb kv kw kx ky im bi translated">它工作并继续编译，直到我们遇到另一个错误:</p><pre class="nf ng nh ni gt nj lu nk nl aw nm bi"><span id="0292" class="nn md it lu b gy no np l nq nr">...<br/>CC libavfilter/dnn/dnn_backend_native_layers.o<br/>In file included from libavfilter/aeval.c:26:<br/>In file included from ./libavutil/avassert.h:31:<br/>In file included from ./libavutil/avutil.h:296:<br/>In file included from ./libavutil/common.h:533:<br/>In file included from ./libavutil/internal.h:176:<br/>./libavutil/libm.h:54:32: error: static declaration of 'cbrt' follows non-static declaration<br/>static av_always_inline double cbrt(double x)<br/>                               ^<br/>/emsdk_portable/upstream/emscripten/system/include/libc/math.h:151:13: note: previous declaration is here<br/>double      cbrt(double);<br/>            ^<br/>In file included from libavfilter/aeval.c:26:</span></pre><p id="6ad7" class="pw-post-body-paragraph ka kb it kd b ke kf kg kh ki kj kk kl kz kn ko kp la kr ks kt lb kv kw kx ky im bi translated">这一次根本原因不是那么明显，所以我们需要更深入地挖掘在<code class="fe lr ls lt lu b">./configure</code>期间出了什么问题。一个非常有用的检查文件是<code class="fe lr ls lt lu b">ffbuild/config.log</code>，它包含了<code class="fe lr ls lt lu b">./configure</code>期间的日志，大多数时候你可以在那里找到根本原因。</p><p id="e48f" class="pw-post-body-paragraph ka kb it kd b ke kf kg kh ki kj kk kl kz kn ko kp la kr ks kt lb kv kw kx ky im bi translated">通过在<code class="fe lr ls lt lu b">config.log</code>中搜索<code class="fe lr ls lt lu b">cbrt</code>，我们发现错误信息如下:</p><pre class="nf ng nh ni gt nj lu nk nl aw nm bi"><span id="4b97" class="nn md it lu b gy no np l nq nr">...<br/>check_mathfunc cbrt 1                                                                                                                             test_ld cc                                                                                                                                        test_cc                                                                                                                                           BEGIN /tmp/ffconf.syfN4Irw/test.c                                                                                                                     1 #include &lt;math.h&gt;                                                                                                                               2 float foo(float f, float g) { return cbrt(f); }                                                                                             <br/>    3 int main(void){ return (int) foo; }                                                                                                         <br/>END /tmp/ffconf.syfN4Irw/test.c                                                                                                                   <br/>emcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c11 -fomit-frame-pointer -pthread -c -o /tmp/ffconf.syfN4Irw/test.o /tmp/ffconf.syfN4Irw/test.c                                                                                  emcc -Wl,-z,noexecstack -o /tmp/ffconf.syfN4Irw/test /tmp/ffconf.syfN4Irw/test.o                                                                  wasm-ld: error: 'atomics' feature is used by /tmp/ffconf.syfN4Irw/test.o, so --shared-memory must be used<br/>...                                         </span></pre><p id="ad83" class="pw-post-body-paragraph ka kb it kd b ke kf kg kh ki kj kk kl kz kn ko kp la kr ks kt lb kv kw kx ky im bi translated">该测试试图检查cbrt是否在环境中工作，但是由于<code class="fe lr ls lt lu b">atomics</code>特性出错而失败。使用<code class="fe lr ls lt lu b">pthread</code>时会询问<code class="fe lr ls lt lu b">atomics</code>，所以让我们添加<code class="fe lr ls lt lu b">pthread</code>标志。(查看<a class="ae lc" href="https://emscripten.org/docs/porting/pthreads.html" rel="noopener ugc nofollow" target="_blank">此处</a>了解更多关于pthread标志的详细信息)</p><p id="dde1" class="pw-post-body-paragraph ka kb it kd b ke kf kg kh ki kj kk kl kz kn ko kp la kr ks kt lb kv kw kx ky im bi translated">更新<code class="fe lr ls lt lu b">build.sh</code>:</p><figure class="nf ng nh ni gt ju"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="9559" class="pw-post-body-paragraph ka kb it kd b ke kf kg kh ki kj kk kl kz kn ko kp la kr ks kt lb kv kw kx ky im bi translated">它工作并继续编译，直到我们遇到另一个错误:</p><pre class="nf ng nh ni gt nj lu nk nl aw nm bi"><span id="29a5" class="nn md it lu b gy no np l nq nr">...<br/>LD      ffplay_g                                                                                                                                  emcc: warning: ignoring unsupported linker flag: `-rpath-link=:libpostproc:libswresample:libswscale:libavfilter:libavdevice:libavformat:libavcodec:libavutil:libavresample` [-Wlinkflags]                                                                                                           <br/>7 warnings generated.                                                      <br/>wasm-ld: error: initial memory too small, 19491744 bytes needed<br/>...                    <br/>make: *** [Makefile:114: ffplay_g] Error 1<br/>make: *** Waiting for unfinished jobs....<br/>emcc: warning: ignoring unsupported linker flag: `-rpath-link=:libpostproc:libswresample:libswscale:libavfilter:libavdevice:libavformat:libavcodec<br/>:libavutil:libavresample` [-Wlinkflags]<br/>...</span></pre><p id="9764" class="pw-post-body-paragraph ka kb it kd b ke kf kg kh ki kj kk kl kz kn ko kp la kr ks kt lb kv kw kx ky im bi translated">这次的问题是由于初始内存太小(在Emscripten中默认只有16 MB，这里最小的是19+ MB)，所以我们需要通过传递<code class="fe lr ls lt lu b">-s INITIAL_MEMORY=33554432</code> (32 MB)将初始内存提高到一个更高的值。</p><figure class="nf ng nh ni gt ju"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="e4a4" class="pw-post-body-paragraph ka kb it kd b ke kf kg kh ki kj kk kl kz kn ko kp la kr ks kt lb kv kw kx ky im bi translated">修复后仍有一个错误:</p><pre class="nf ng nh ni gt nj lu nk nl aw nm bi"><span id="77ed" class="nn md it lu b gy no np l nq nr">LD      ffplay_g<br/>emcc: warning: ignoring unsupported linker flag: `-rpath-link=:libpostproc:libswresample:libswscale:libavfilter:libavdevice:libavformat:libavcodec:libavutil:libavresample` [-Wlinkflags]<br/>6 warnings generated.<br/>LD      ffmpeg_g<br/>emcc: warning: ignoring unsupported linker flag: `-rpath-link=:libpostproc:libswresample:libswscale:libavfilter:libavdevice:libavformat:libavcodec:libavutil:libavresample` [-Wlinkflags]<br/>9 warnings generated.<br/>LD      ffprobe_g<br/>emcc: warning: ignoring unsupported linker flag: `-rpath-link=:libpostproc:libswresample:libswscale:libavfilter:libavdevice:libavformat:libavcodec:libavutil:libavresample` [-Wlinkflags]<br/>STRIP   ffmpeg<br/>strip:ffmpeg_g: file format not recognized<br/>make: *** [Makefile:107: ffmpeg] Error 1<br/>make: *** Waiting for unfinished jobs....</span></pre><p id="5a94" class="pw-post-body-paragraph ka kb it kd b ke kf kg kh ki kj kk kl kz kn ko kp la kr ks kt lb kv kw kx ky im bi translated">由于我们无法剥离(因为它不是有效的二进制格式，所以有意义)，让我们简单地用<code class="fe lr ls lt lu b">--disable-stripping</code>禁用剥离，并再次生成:</p><figure class="nf ng nh ni gt ju"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="22d8" class="pw-post-body-paragraph ka kb it kd b ke kf kg kh ki kj kk kl kz kn ko kp la kr ks kt lb kv kw kx ky im bi translated">最后，我们成功地完成了<code class="fe lr ls lt lu b">emmake make -j</code>部分，您可以看到根文件夹中生成的ffplay / ffplay_g、ffprobe / ffprobe_g和ffmpeg / ffmpeg_g。它看起来很完美，但是有一个怪异的<code class="fe lr ls lt lu b">_g</code>后缀使得输出文件是这样的:</p><ul class=""><li id="d861" class="ld le it kd b ke kf ki kj kz lf la lg lb lh ky oa lj lk ll bi translated">ffmpeg</li><li id="af47" class="ld le it kd b ke lm ki ln kz lo la lp lb lq ky oa lj lk ll bi translated">ffmpeg_g</li><li id="e4ba" class="ld le it kd b ke lm ki ln kz lo la lp lb lq ky oa lj lk ll bi translated">ffmpeg_g.wasm</li><li id="b6c3" class="ld le it kd b ke lm ki ln kz lo la lp lb lq ky oa lj lk ll bi translated">ffmpeg_g.worker.js</li></ul><p id="5488" class="pw-post-body-paragraph ka kb it kd b ke kf kg kh ki kj kk kl kz kn ko kp la kr ks kt lb kv kw kx ky im bi translated">这里的ffmpeg和ffmpeg_g实际上都是js文件，理想的命名如下:</p><ul class=""><li id="d8cd" class="ld le it kd b ke kf ki kj kz lf la lg lb lh ky oa lj lk ll bi translated">ffmpeg / ffmpeg_g =&gt; ffmpeg.js</li><li id="7a23" class="ld le it kd b ke lm ki ln kz lo la lp lb lq ky oa lj lk ll bi translated">ffmpeg_g.wasm =&gt; ffmpeg.wasm</li><li id="9f5d" class="ld le it kd b ke lm ki ln kz lo la lp lb lq ky oa lj lk ll bi translated">ffmpeg _ g . worker . js = &gt; ffmpeg . worker . js</li></ul><p id="186e" class="pw-post-body-paragraph ka kb it kd b ke kf kg kh ki kj kk kl kz kn ko kp la kr ks kt lb kv kw kx ky im bi translated">要解决这个问题，我们需要自己构建它。构建ffmpeg的命令可以通过运行<code class="fe lr ls lt lu b">emmake make -n</code>来提取:</p><pre class="nf ng nh ni gt nj lu nk nl aw nm bi"><span id="cbfe" class="nn md it lu b gy no np l nq nr">...<br/>printf "LD\t%s\n" ffmpeg_g; emcc -Llibavcodec -Llibavdevice -Llibavfilter -Llibavformat -Llibavresample -Llibavutil -Llibpostproc -Llibswscale -Llibswresample -Wl,--as-needed -Wl,-z,noexecstack -Wl,--warn-common -Wl,-rpath-link=libpostproc:libswresample:libswscale:libavfilter:libavdevice:libavformat:libavcodec:libavutil:libavresample -Qunused-arguments   -o ffmpeg_g fftools/ffmpeg_opt.o fftools/ffmpeg_filter.o fftools/ffmpeg_hw.o fftools/cmdutils.o fftools/ffmpeg.o  -lavdevice -lavfilter -lavformat -lavcodec -lswresample -lswscale -lavutil  -lm -pthread -lm -lm -pthread -lm -lm -lm -pthread -lm<br/>printf "CP\t%s\n" ffmpeg; cp -p ffmpeg_g ffmpeg<br/>...</span></pre><p id="9e7e" class="pw-post-body-paragraph ka kb it kd b ke kf kg kh ki kj kk kl kz kn ko kp la kr ks kt lb kv kw kx ky im bi translated">稍微清理一下:</p><pre class="nf ng nh ni gt nj lu nk nl aw nm bi"><span id="5d54" class="nn md it lu b gy no np l nq nr">emcc \<br/>  -I. -I./fftools \<br/>  -Llibavcodec -Llibavdevice -Llibavfilter -Llibavformat -Llibavresample -Llibavutil -Llibpostproc -Llibswscale -Llibswresample \<br/>  -Qunused-arguments \<br/>  -o ffmpeg_g fftools/ffmpeg_opt.o fftools/ffmpeg_filter.o fftools/ffmpeg_hw.o fftools/cmdutils.o fftools/ffmpeg.o \<br/>  -lavdevice -lavfilter -lavformat -lavcodec -lswresample -lswscale -lavutil -lm</span></pre><p id="b96a" class="pw-post-body-paragraph ka kb it kd b ke kf kg kh ki kj kk kl kz kn ko kp la kr ks kt lb kv kw kx ky im bi translated">因为我们正在构建我们自己的版本，所以让我们在<code class="fe lr ls lt lu b">./configure</code>步骤中添加<code class="fe lr ls lt lu b">--disable-programs</code>和<code class="fe lr ls lt lu b">--disable-doc</code>来加速构建，并且在构建ffmpeg时添加一些必要的标志</p><figure class="nf ng nh ni gt ju"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="93ab" class="pw-post-body-paragraph ka kb it kd b ke kf kg kh ki kj kk kl kz kn ko kp la kr ks kt lb kv kw kx ky im bi translated">让我们创建一个<a class="ae lc" href="https://github.com/ffmpegwasm/FFmpeg/blob/n4.3.1-p2/wasm/basic.html" rel="noopener ugc nofollow" target="_blank">basic.html</a>来测试ffmpeg.wasm是否工作:</p><figure class="nf ng nh ni gt ju"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="8be7" class="pw-post-body-paragraph ka kb it kd b ke kf kg kh ki kj kk kl kz kn ko kp la kr ks kt lb kv kw kx ky im bi translated">运行轻量级web服务器(例如<code class="fe lr ls lt lu b">python3 -m http.server 3000</code>)并访问网页(例如<code class="fe lr ls lt lu b"><a class="ae lc" href="http://localhost:8000/test.html)" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/basic.html</a></code> <a class="ae lc" href="http://localhost:8000/test.html)" rel="noopener ugc nofollow" target="_blank"> ) </a>并打开Chrome DevTools。</p><figure class="nf ng nh ni gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="oc od di oe bf of"><div class="gh gi ob"><img src="../Images/3cb0946317e0325fa3d83367be938f8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N1KJtAcdlhYBzJ2XSv3XGA.png"/></div></div></figure><p id="61c2" class="pw-post-body-paragraph ka kb it kd b ke kf kg kh ki kj kk kl kz kn ko kp la kr ks kt lb kv kw kx ky im bi translated">你可以看到它的输出类似于原始的FFmpeg，这给了我们一个很好的起点来完善我们的ffmpeg.wasm库。</p><p id="a396" class="pw-post-body-paragraph ka kb it kd b ke kf kg kh ki kj kk kl kz kn ko kp la kr ks kt lb kv kw kx ky im bi translated">你可以访问这里的知识库，看看它是如何详细工作的:<a class="ae lc" href="https://github.com/ffmpegwasm/FFmpeg/tree/n4.3.1-p2" rel="noopener ugc nofollow" target="_blank">https://github.com/ffmpegwasm/FFmpeg/tree/n4.3.1-p2</a></p><p id="f4e2" class="pw-post-body-paragraph ka kb it kd b ke kf kg kh ki kj kk kl kz kn ko kp la kr ks kt lb kv kw kx ky im bi translated">并且可以在这里随意下载建造神器:【https://github.com/ffmpegwasm/FFmpeg/releases/tag/n4.3.1-p2 T2】</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="fd9c" class="pw-post-body-paragraph ka kb it kd b ke kf kg kh ki kj kk kl kz kn ko kp la kr ks kt lb kv kw kx ky im bi translated">如何打磨和创建一个“真正的”ffmpeg.wasm库，请看本系列故事的<a class="ae lc" href="https://medium.com/@jeromewus/build-ffmpeg-webassembly-version-ffmpeg-js-part-3-ffmpeg-js-v0-1-0-transcoding-avi-to-mp4-f729e503a397" rel="noopener">构建FFmpeg WebAssembly版本(= FFmpeg . wasm):part . 3 FFmpeg . wasm v 0.1—将avi转码为mp4 </a>。😃</p></div></div>    
</body>
</html>