<html>
<head>
<title>How JS become multi-threaded?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JS如何变成多线程？</h1>
<blockquote>原文：<a href="https://itnext.io/how-js-becomes-multi-threaded-d54000d2daa0?source=collection_archive---------0-----------------------#2019-08-09">https://itnext.io/how-js-becomes-multi-threaded-d54000d2daa0?source=collection_archive---------0-----------------------#2019-08-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/c1fa4ca6a2670e1ac827df8b769106b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*waXB6-ws3VVYX6d06eSVvg.jpeg"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">图片来自playembbeded.com</figcaption></figure><div class=""/><div class=""><h2 id="5606" class="pw-subtitle-paragraph kc je jf bd b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dk translated">我们如何在我们的服务器或用户的浏览器上执行高成本的操作？JavaScript中的多线程技术来拯救我们了！</h2></div><blockquote class="ku kv kw"><p id="733d" class="kx ky kz la b lb lc kg ld le lf kj lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">这是高级职员，你并不真的需要它来成为伟大的开发者，所以如果你一开始没有得到所有的东西也不要担心。阅读这篇文章会让你比90%的JS开发者更清楚</p></blockquote><p id="f682" class="pw-post-body-paragraph kx ky jf la b lb lc kg ld le lf kj lg lu li lj lk lv lm ln lo lw lq lr ls lt ij bi translated">多年来，JavaScript一直被认为是缓慢的，并且主要被用作显示网页内容的“助手”。这种情况在2010年左右发生了变化，类似AngularJS或BackboneJS这样的框架开始出现。开发者和公司开始意识到你可以在用户的电脑上执行复杂的操作。但是随着前端代码越来越多，一些页面开始变慢。</p><p id="c7d9" class="pw-post-body-paragraph kx ky jf la b lb lc kg ld le lf kj lg lu li lj lk lv lm ln lo lw lq lr ls lt ij bi translated">主要原因是JS是单线程的。我们甚至有循环，但这对长时间执行的函数没有帮助。你仍然可以用一些计算阻塞用户的线程。主要目标是达到60FPS(每秒帧数)。这意味着在下一帧之前，你只有16毫秒的时间来执行你的代码。</p><p id="c148" class="pw-post-body-paragraph kx ky jf la b lb lc kg ld le lf kj lg lu li lj lk lv lm ln lo lw lq lr ls lt ij bi translated">这个问题的解决方案是使用<a class="ae lx" href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API" rel="noopener ugc nofollow" target="_blank"> Web Workers </a>，在这里你可以执行长时间运行的任务，而不会影响执行的主线程。工人只有一个主要问题，发送数据…</p><h1 id="1f61" class="ly lz jf bd ma mb mc md me mf mg mh mi kl mj km mk ko ml kp mm kr mn ks mo mp bi translated">我们如何与员工交换数据？</h1><p id="e126" class="pw-post-body-paragraph kx ky jf la b lb mq kg ld le mr kj lg lu ms lj lk lv mt ln lo lw mu lr ls lt ij bi translated">对于那些刚刚接触worker的人来说，主线程和worker之间的通信通常是这样的:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="c96a" class="ne lz jf na b gy nf ng l nh ni">// main.js<br/>const myWorker = new Worker('worker.js');</span><span id="a21e" class="ne lz jf na b gy nj ng l nh ni">myWorker.onmessage = function(e) {<br/>  doSthWithResult(e.data);<br/>};</span><span id="002e" class="ne lz jf na b gy nj ng l nh ni">myWorker.postMessage({<br/>  attr1: 'data1',<br/>  attr2: 'data2',<br/>});// worker.js<br/>onmessage = function(e) {<br/>  // Message received from main thread in e.data<br/>  postMessage(getResultOfComplexOperation(e.data));<br/>};</span></pre><p id="aa92" class="pw-post-body-paragraph kx ky jf la b lb lc kg ld le lf kj lg lu li lj lk lv lm ln lo lw lq lr ls lt ij bi translated">如您所见，有许多数据是双向发送的。在这个例子中，我们发送一个简单的对象，它不会导致任何性能问题。但是如果你试图通过一个有几千个键的物体，它会变慢。为什么？因为每次我们向Worker发送东西时，都要调用<a class="ae lx" href="http://w3c.github.io/html/infrastructure.html#safe-passing-of-structured-data" rel="noopener ugc nofollow" target="_blank">结构化克隆算法</a>来克隆那个对象。对于那些不想阅读整个spec :P的人来说，它只是遍历一个给定的对象并创建它的克隆。</p><p id="58db" class="pw-post-body-paragraph kx ky jf la b lb lc kg ld le lf kj lg lu li lj lk lv lm ln lo lw lq lr ls lt ij bi translated">在这一点上，你可能会注意到我们会遇到什么样的问题。当经常发送大的数据结构或小的数据结构时，我们等待响应的时间可能会超过16ms。下面是在我的电脑上完成的一个简单的基准测试:</p><figure class="mv mw mx my gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nk"><img src="../Images/3057827c1bd9de656dac35f4d0d8ada5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*skhe3m_lPoVbL1Ae.png"/></div></div></figure><figure class="mv mw mx my gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nl"><img src="../Images/0664432cdd6ee3e6f61caaee850ce4e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:120/0*N0tDZmg_v6d5sNF_"/></div></div></figure><figure class="mv mw mx my gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nk"><img src="../Images/896ca97e019fd6b72d2ff69deb06a6b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*W9wqzLMilO02aAF-.png"/></div></div></figure><p id="97e9" class="pw-post-body-paragraph kx ky jf la b lb lc kg ld le lf kj lg lu li lj lk lv lm ln lo lw lq lr ls lt ij bi translated">感谢<a class="ae lx" href="https://github.com/JamesMilnerUK" rel="noopener ugc nofollow" target="_blank">詹姆斯·米尔纳</a>为网络工作者创造<a class="ae lx" href="https://github.com/JamesMilnerUK/webworker-perf" rel="noopener ugc nofollow" target="_blank">基准，如果你愿意，你可以在你的浏览器上试试看结果。</a></p><p id="b22c" class="pw-post-body-paragraph kx ky jf la b lb lc kg ld le lf kj lg lu li lj lk lv lm ln lo lw lq lr ls lt ij bi translated">几年前(2016年)有一个总是解析对象<code class="fe nm nn no na b">JSON.stringify(objectToSend)</code>的想法。原因是发送字符串比发送对象快得多。现在情况已经不同了(如前所述)。</p><p id="f712" class="pw-post-body-paragraph kx ky jf la b lb lc kg ld le lf kj lg lu li lj lk lv lm ln lo lw lq lr ls lt ij bi translated">这些结果仅针对一条消息，请记住，在大多数情况下，您希望在一个帧中发送多条消息。即使100k keys对象的大小可能看起来很大，但如果你花时间张贴1k keys对象(在我的机器上为0.725ms * 2)并张贴10次，你将获得14.5ms。</p><h1 id="5f51" class="ly lz jf bd ma mb mc md me mf mg mh mi kl mj km mk ko ml kp mm kr mn ks mo mp bi translated">我们该如何改进我们的流程呢？</h1><p id="2bda" class="pw-post-body-paragraph kx ky jf la b lb mq kg ld le mr kj lg lu ms lj lk lv mt ln lo lw mu lr ls lt ij bi translated">人们可能会说JS是多线程的(因为它有工作线程),但我认为真正的多线程需要的不仅仅是在不同的线程上执行部分代码的能力。那就是共享记忆。如果我每次都必须复制和粘贴我的整个数据结构，我想做一些改变。它挫败了在不同的工人身上运行它的整个想法。但是像往常一样，有一个解决方案，叫做<a class="ae lx" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer" rel="noopener ugc nofollow" target="_blank"> SharedArrayBuffer </a>。</p><p id="2b87" class="pw-post-body-paragraph kx ky jf la b lb lc kg ld le lf kj lg lu li lj lk lv lm ln lo lw lq lr ls lt ij bi translated">截至目前，Chrome、Firefox和Node (=&gt;8.10.x)都支持该功能。你可能会问，为什么只有这些浏览器？原因是，2018年1月有一个名为<a class="ae lx" href="https://meltdownattack.com/" rel="noopener ugc nofollow" target="_blank">幽灵</a>的漏洞，它基本上迫使所有主要浏览器从引擎中删除该功能。Chrome在V67中重新引入了它，但一些浏览器只是推迟了实现(Edge，Safari)。</p><p id="f467" class="pw-post-body-paragraph kx ky jf la b lb lc kg ld le lf kj lg lu li lj lk lv lm ln lo lw lq lr ls lt ij bi translated">好吧，但是<code class="fe nm nn no na b">SharedArrayBuffer</code>到底是什么？如果你愿意，你可以检查一下<a class="ae lx" href="http://www.ecma-international.org/ecma-262/#sec-sharedarraybuffer-objects" rel="noopener ugc nofollow" target="_blank">规范</a>，但是从那里得到解释是很费时间的。MDN用更简单的方式解释它:</p><blockquote class="ku kv kw"><p id="2e91" class="kx ky kz la b lb lc kg ld le lf kj lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated"><em class="jf">SharedArrayBuffer对象用于表示通用的、固定长度的原始二进制数据缓冲区</em></p></blockquote><p id="4775" class="pw-post-body-paragraph kx ky jf la b lb lc kg ld le lf kj lg lu li lj lk lv lm ln lo lw lq lr ls lt ij bi translated">这将如何帮助我解决数据问题？我们可以在两端更新相同的共享内存，而不是从主线程发送和复制数据。首先，您需要找出缓冲区和实际数组之间的区别:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="b2c6" class="ne lz jf na b gy nf ng l nh ni">// main.js</span><span id="36e1" class="ne lz jf na b gy nj ng l nh ni">// Create Buffer for 32 16-bit integers<br/>const myBuffer = new SharedArrayBuffer(Int16Array.BYTES_PER_ELEMENT * 32);</span><span id="9683" class="ne lz jf na b gy nj ng l nh ni">// create array available in main thread using our buffer<br/>const mainThreadArray = new Int16Array(myBuffer);</span><span id="9767" class="ne lz jf na b gy nj ng l nh ni">// post our buffer to Worker<br/>myWorker.postMessage(myBuffer);</span></pre><p id="ee3a" class="pw-post-body-paragraph kx ky jf la b lb lc kg ld le lf kj lg lu li lj lk lv lm ln lo lw lq lr ls lt ij bi translated">当worker在其线程上接收到缓冲区时，我们可以使用相同的缓冲区创建另一个数组</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="701d" class="ne lz jf na b gy nf ng l nh ni">// worker.js<br/>const workerArray = new Int16Array(e.data);</span></pre><p id="042f" class="pw-post-body-paragraph kx ky jf la b lb lc kg ld le lf kj lg lu li lj lk lv lm ln lo lw lq lr ls lt ij bi translated">现在我们在两个线程中都引用了同一个内存，剩下唯一要做的就是更新这些值。</p><h1 id="9267" class="ly lz jf bd ma mb mc md me mf mg mh mi kl mj km mk ko ml kp mm kr mn ks mo mp bi translated"><a class="ae lx" href="http://www.ecma-international.org/ecma-262/#sec-atomics-object" rel="noopener ugc nofollow" target="_blank">原子学</a>为胜！</h1><p id="d153" class="pw-post-body-paragraph kx ky jf la b lb mq kg ld le mr kj lg lu ms lj lk lv mt ln lo lw mu lr ls lt ij bi translated">当在多个线程之间共享内存时，我们可能会遇到<a class="ae lx" href="https://en.wikipedia.org/wiki/Race_condition" rel="noopener ugc nofollow" target="_blank">竞争条件</a>问题。简而言之，竞争条件是多个线程试图同时更改相同的数据。这就像如果你家里有多个电灯开关。如果两个人想做同样的动作(关灯)，那个动作的结果不会像他们预期的那样(灯保持开着)。我知道这个解释不能完全解释什么是竞争条件，但是现在不是做这个的时间和地点。</p><blockquote class="ku kv kw"><p id="f5f8" class="kx ky kz la b lb lc kg ld le lf kj lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated"><em class="jf">Atomics对象提供了在共享内存阵列单元上不可分割地(原子地)操作的函数，以及让代理等待和分派原始事件的函数。当与规程一起使用时，原子函数允许通过共享内存进行通信的多代理程序以一种很好理解的顺序执行，即使是在并行CPU上。</em></p></blockquote><p id="1871" class="pw-post-body-paragraph kx ky jf la b lb lc kg ld le lf kj lg lu li lj lk lv lm ln lo lw lq lr ls lt ij bi translated">这是当前JS规范(ECMA-262，第10版，2019年6月)的定义。换句话说，原子允许您对共享数据进行可预测的操作。好了，让我们写一些代码:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="cec8" class="ne lz jf na b gy nf ng l nh ni">// main.js<br/>const worker = new Worker('worker.js');</span><span id="2efd" class="ne lz jf na b gy nj ng l nh ni">// Create Buffer for 32 16-bit integers<br/>const myBuffer = new SharedArrayBuffer(Int16Array.BYTES_PER_ELEMENT * 32);</span><span id="56c9" class="ne lz jf na b gy nj ng l nh ni">// create array available in main thread using our buffer<br/>const mainThreadArray = new Int16Array(myBuffer);<br/>for (let i = 0; i &lt; mainThreadArray.length; i += 1) {<br/>  Atomics.store(mainThreadArray, i, i + 5);<br/>}</span><span id="694b" class="ne lz jf na b gy nj ng l nh ni">worker.postMessage(myBuffer);// worker.js<br/>self.onmessage = event =&gt; {<br/>  const workerThreadArray = new Int16Array(event.data);<br/>  for (let i = 0; i &lt; workerThreadArray.length; i += 1) {<br/>    const currentVal = Atomics.load(workerThreadArray, i);<br/>    console.log(`Index ${i} has value: ${currentVal}`);<br/>  }<br/>};</span></pre><p id="762a" class="pw-post-body-paragraph kx ky jf la b lb lc kg ld le lf kj lg lu li lj lk lv lm ln lo lw lq lr ls lt ij bi translated">该代码的结果只是32个控制台日志(<code class="fe nm nn no na b">workerThreadArray.length</code>是32)和来自我们缓冲区的值。</p><p id="01f0" class="pw-post-body-paragraph kx ky jf la b lb lc kg ld le lf kj lg lu li lj lk lv lm ln lo lw lq lr ls lt ij bi translated">你可以在<a class="ae lx" href="https://codesandbox.io/s/competent-gould-r2mzv?fontsize=14&amp;module=%2Fsrc%2Findex.js&amp;view=editor" rel="noopener ugc nofollow" target="_blank"> codesandbox </a>上自己检查一下(记得打开开发工具而不是内置控制台，因为他们的控制台不记录工作线程)。</p><p id="0b05" class="pw-post-body-paragraph kx ky jf la b lb lc kg ld le lf kj lg lu li lj lk lv lm ln lo lw lq lr ls lt ij bi translated">如果简单的读/写还不够，那么你可以做更多的事情:</p><h2 id="38bb" class="ne lz jf bd ma np nq dn me nr ns dp mi lu nt nu mk lv nv nw mm lw nx ny mo nz bi translated"><a class="ae lx" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Atomics/exchange" rel="noopener ugc nofollow" target="_blank">交换</a></h2><p id="56ec" class="pw-post-body-paragraph kx ky jf la b lb mq kg ld le mr kj lg lu ms lj lk lv mt ln lo lw mu lr ls lt ij bi translated">存储新值时接收以前的值。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="e2a1" class="ne lz jf na b gy nf ng l nh ni">// worker.js<br/>self.onmessage = event =&gt; {<br/>  const workerThreadArray = new Int16Array(event.data);<br/>  for (let i = 0; i &lt; workerThreadArray.length; i += 1) {<br/>    const previousValue = Atomics.exchange(workerThreadArray, i, 0);<br/>    console.log(`Index ${i} had value: ${previousValue}`);<br/>  }<br/>};</span></pre><h2 id="0ebf" class="ne lz jf bd ma np nq dn me nr ns dp mi lu nt nu mk lv nv nw mm lw nx ny mo nz bi translated"><a class="ae lx" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Atomics/compareExchange" rel="noopener ugc nofollow" target="_blank">比较交换</a></h2><p id="72cd" class="pw-post-body-paragraph kx ky jf la b lb mq kg ld le mr kj lg lu ms lj lk lv mt ln lo lw mu lr ls lt ij bi translated">像<code class="fe nm nn no na b">exchange</code>一样工作，但是只有在匹配时才替换值</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="4738" class="ne lz jf na b gy nf ng l nh ni">// worker.js<br/>self.onmessage = event =&gt; {<br/>  const workerThreadArray = new Int16Array(event.data);<br/>  // Remember that value at position 0 is 5 (i + 5)<br/>  const previousValue1 = Atomics.compareExchange(workerThreadArray, 0, 5, 2);<br/>  console.log(`Index 0 has value: ${Atomics.load(workerThreadArray, 0)}`);<br/>  console.log(`Value received: ${previousValue1}`);<br/>  const previousValue2 = Atomics.compareExchange(workerThreadArray, 0, 5, 1);<br/>  console.log(`Index 0 has value: ${Atomics.load(workerThreadArray, 0)}`);<br/>  console.log(`Value received: ${previousValue2}`);<br/>};</span></pre><p id="8930" class="pw-post-body-paragraph kx ky jf la b lb lc kg ld le lf kj lg lu li lj lk lv lm ln lo lw lq lr ls lt ij bi translated">它将打印:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="506c" class="ne lz jf na b gy nf ng l nh ni">Index 0 has value: 2 <br/>Value received: 5 <br/>Index 0 has value: 2 <br/>Value received: 2</span></pre><p id="c25c" class="pw-post-body-paragraph kx ky jf la b lb lc kg ld le lf kj lg lu li lj lk lv lm ln lo lw lq lr ls lt ij bi translated">因为默认值是<code class="fe nm nn no na b">5</code>，所以第一次运行匹配值(第二个参数)并用<code class="fe nm nn no na b">2</code>(第三个参数)替换它。所以函数返回前一个值(就像在<code class="fe nm nn no na b">exchange</code>中一样)。下一次运行失败，因为现有值不是<code class="fe nm nn no na b">5</code>，所以函数返回一个现有值，而不是用<code class="fe nm nn no na b">1</code>替换它。</p><p id="033d" class="pw-post-body-paragraph kx ky jf la b lb lc kg ld le lf kj lg lu li lj lk lv lm ln lo lw lq lr ls lt ij bi translated">以下是Atomics上所有可用操作的列表(截至2019年7月):</p><ul class=""><li id="68cf" class="oa ob jf la b lb lc le lf lu oc lv od lw oe lt of og oh oi bi translated"><a class="ae lx" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Atomics/add" rel="noopener ugc nofollow" target="_blank">增加</a></li><li id="9010" class="oa ob jf la b lb oj le ok lu ol lv om lw on lt of og oh oi bi translated"><a class="ae lx" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Atomics/sub" rel="noopener ugc nofollow" target="_blank">子</a></li><li id="44bc" class="oa ob jf la b lb oj le ok lu ol lv om lw on lt of og oh oi bi translated"><a class="ae lx" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Atomics/and" rel="noopener ugc nofollow" target="_blank">和</a></li><li id="66c2" class="oa ob jf la b lb oj le ok lu ol lv om lw on lt of og oh oi bi translated"><a class="ae lx" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Atomics/or" rel="noopener ugc nofollow" target="_blank">或</a></li><li id="8bf6" class="oa ob jf la b lb oj le ok lu ol lv om lw on lt of og oh oi bi translated"><a class="ae lx" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Atomics/xor" rel="noopener ugc nofollow" target="_blank">异或</a></li><li id="7ddf" class="oa ob jf la b lb oj le ok lu ol lv om lw on lt of og oh oi bi translated"><a class="ae lx" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Atomics/exchange" rel="noopener ugc nofollow" target="_blank">交换</a></li><li id="9353" class="oa ob jf la b lb oj le ok lu ol lv om lw on lt of og oh oi bi translated"><a class="ae lx" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Atomics/compareExchange" rel="noopener ugc nofollow" target="_blank">比较交换</a></li><li id="cffb" class="oa ob jf la b lb oj le ok lu ol lv om lw on lt of og oh oi bi translated"><a class="ae lx" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Atomics/load" rel="noopener ugc nofollow" target="_blank">负载</a></li><li id="d181" class="oa ob jf la b lb oj le ok lu ol lv om lw on lt of og oh oi bi translated"><a class="ae lx" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Atomics/store" rel="noopener ugc nofollow" target="_blank">商店</a></li></ul><h1 id="4b0d" class="ly lz jf bd ma mb mc md me mf mg mh mi kl mj km mk ko ml kp mm kr mn ks mo mp bi translated">可观的？</h1><p id="9ff5" class="pw-post-body-paragraph kx ky jf la b lb mq kg ld le mr kj lg lu ms lj lk lv mt ln lo lw mu lr ls lt ij bi translated">原子不仅限于读/写操作。有时多线程操作需要您观察和响应变化。这就是为什么引入了像<code class="fe nm nn no na b">wait</code>和<code class="fe nm nn no na b">notify</code>这样的函数。</p><h2 id="15ca" class="ne lz jf bd ma np nq dn me nr ns dp mi lu nt nu mk lv nv nw mm lw nx ny mo nz bi translated">等待(仅适用于Int32Array)</h2><p id="3d02" class="pw-post-body-paragraph kx ky jf la b lb mq kg ld le mr kj lg lu ms lj lk lv mt ln lo lw mu lr ls lt ij bi translated">如果你熟悉<code class="fe nm nn no na b">await</code>，那么你可以把它当作“有条件的”<code class="fe nm nn no na b">await</code>。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="4aaa" class="ne lz jf na b gy nf ng l nh ni">// worker.js<br/>const result = Atomics.wait(workerThreadArray, 0, 5);<br/>console.log(result);</span></pre><p id="fb97" class="pw-post-body-paragraph kx ky jf la b lb lc kg ld le lf kj lg lu li lj lk lv lm ln lo lw lq lr ls lt ij bi translated">这段代码将一直等待，直到有人通知有变化。为此，你必须从另一个线程调用<code class="fe nm nn no na b">notify</code>(当前线程被阻塞)。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="f240" class="ne lz jf na b gy nf ng l nh ni">// main.js<br/>Atomics.notify(mainThreadArray, 0, 1);</span></pre><p id="faef" class="pw-post-body-paragraph kx ky jf la b lb lc kg ld le lf kj lg lu li lj lk lv lm ln lo lw lq lr ls lt ij bi translated">在这种情况下,<code class="fe nm nn no na b">wait</code>返回<code class="fe nm nn no na b">ok</code>,因为值没有变化。代码将像在<code class="fe nm nn no na b">await</code>情况下一样进行。</p><p id="f099" class="pw-post-body-paragraph kx ky jf la b lb lc kg ld le lf kj lg lu li lj lk lv lm ln lo lw lq lr ls lt ij bi translated">返回信息有三种类型<code class="fe nm nn no na b">ok</code>、<code class="fe nm nn no na b">not-equal</code>和<code class="fe nm nn no na b">timed-out</code>。第一个被覆盖，第二个在等待期间值发生变化时返回。当我们将第四个参数传递给<code class="fe nm nn no na b">wait</code>函数时，可以返回第三个参数</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="ebf1" class="ne lz jf na b gy nf ng l nh ni">// worker.js<br/>const result = Atomics.wait(workerThreadArray, 0, 5, 1000);<br/>console.log(result);</span></pre><p id="23ef" class="pw-post-body-paragraph kx ky jf la b lb lc kg ld le lf kj lg lu li lj lk lv lm ln lo lw lq lr ls lt ij bi translated">1000毫秒后<code class="fe nm nn no na b">wait</code>返回<code class="fe nm nn no na b">timed-out</code>，此时没有其他原因导致其停止。</p><p id="e19f" class="pw-post-body-paragraph kx ky jf la b lb lc kg ld le lf kj lg lu li lj lk lv lm ln lo lw lq lr ls lt ij bi translated">关于<code class="fe nm nn no na b">notify</code>，我觉得还有一点需要补充。函数调用中的第3个参数负责通知几个等待的代理。如果你想通知他们所有人，只需将值设置为<code class="fe nm nn no na b">+Infinity</code>或留空(默认为<code class="fe nm nn no na b">+Infinity</code>)。</p><p id="1065" class="pw-post-body-paragraph kx ky jf la b lb lc kg ld le lf kj lg lu li lj lk lv lm ln lo lw lq lr ls lt ij bi translated">原子中还有一个函数叫做<a class="ae lx" href="http://www.ecma-international.org/ecma-262/#sec-atomics.islockfree" rel="noopener ugc nofollow" target="_blank"> Atomics.isLockFree(size) </a>，但是我们不打算在这里讨论它。</p><h1 id="9d81" class="ly lz jf bd ma mb mc md me mf mg mh mi kl mj km mk ko ml kp mm kr mn ks mo mp bi translated">弦乐呢？</h1><p id="91f5" class="pw-post-body-paragraph kx ky jf la b lb mq kg ld le mr kj lg lu ms lj lk lv mt ln lo lw mu lr ls lt ij bi translated">目前，还不支持字符串，但是通常使用的解决方案是将字符串解析成数字表示。我知道这不是最好的解决方案，但是在我们得到字符串支持之前，我们必须处理它:(</p><h1 id="2561" class="ly lz jf bd ma mb mc md me mf mg mh mi kl mj km mk ko ml kp mm kr mn ks mo mp bi translated">结论</h1><p id="1313" class="pw-post-body-paragraph kx ky jf la b lb mq kg ld le mr kj lg lu ms lj lk lv mt ln lo lw mu lr ls lt ij bi translated">JavaScript中的多线程现在是真实的。您可以将工作卸载到多个线程中，并在它们之间共享内存。老实说，几年前我真的不确定这是否可能。主要是因为JS规范。我认为<code class="fe nm nn no na b">SharedArrayBuffers</code>和多线程的想法是有益的，尤其是对于NodeJS服务。我知道对<a class="ae lx" href="https://nodejs.org/api/worker_threads.html" rel="noopener ugc nofollow" target="_blank">工作线程</a>的支持仍处于试验阶段(Node 12.6.0 ),但只要稍加努力，我们就能创建高效的服务。我认为在不久的将来，我们会在网络上看到越来越多的多线程解决方案。</p></div><div class="ab cl oo op hu oq" role="separator"><span class="or bw bk os ot ou"/><span class="or bw bk os ot ou"/><span class="or bw bk os ot"/></div><div class="ij ik il im in"><p id="65ca" class="pw-post-body-paragraph kx ky jf la b lb lc kg ld le lf kj lg lu li lj lk lv lm ln lo lw lq lr ls lt ij bi translated"><em class="kz">最初发布于</em><a class="ae lx" href="https://erdem.pl/2019/07/how-js-becomes-multi-threaded" rel="noopener ugc nofollow" target="_blank"><em class="kz">https://erdem . pl</em></a><em class="kz">。</em></p></div></div>    
</body>
</html>