<html>
<head>
<title>Monitor your Asus router in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Python中监控您的华硕路由器</h1>
<blockquote>原文：<a href="https://itnext.io/monitor-your-asus-router-in-python-171693465fc1?source=collection_archive---------4-----------------------#2021-07-26">https://itnext.io/monitor-your-asus-router-in-python-171693465fc1?source=collection_archive---------4-----------------------#2021-07-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="26b6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用华硕路由器的可用但未记录的web API来监控使用情况和性能。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/f703c7ba8110eab6e46b53f9cb4bea24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6UcXBSenJhSipmcZUjFVQQ.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">拉斯·金勒拍摄的照片(图片来源:<a class="ae lb" href="https://unsplash.com/@larskienle" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></figcaption></figure><p id="ad1c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我家网络的心脏是一台华硕RT-AC68U路由器。要监控它的运行和健康状况，可以使用华硕路由器App。该应用程序提供了关于连接性、连接设备等的良好概述。它甚至有一个漂亮的图表显示实时交通状况。</p><p id="50e9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么，我们如何在自己的应用程序和脚本中使用这些信息呢？没有文档化的web或REST接口可用，但当应用程序可以获取数据时，我们不也可以吗？我们的第一步是在Android设备上使用数据包嗅探器，看看我们是否能看到发生了什么。这比预期的要容易得多…</p><p id="28f6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当应用启动时，端点<em class="lc"> /login.cgi </em>被调用。在这次登录之后，端点<em class="lc"> /appGet </em>被使用不同的有效负载调用多次。有效载荷似乎标识了可以调用的消息。请注意，我们只能这样做，因为路由器不使用SSL，它们是普通的、老式的HTTP请求。安全方面的问题；您网络上的任何人都可以从您的应用程序中看到登录凭据，并使用它们来访问路由器。</p><h2 id="56d2" class="ld le iq bd lf lg lh dn li lj lk dp ll jy lm ln lo kc lp lq lr kg ls lt lu lv bi translated">执行登录</h2><p id="c3a1" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">但是在我们变得过于热情之前，让我们首先尝试执行一个成功的登录调用。检查捕获的包，我们看到</p><pre class="km kn ko kp gt mb mc md me aw mf bi"><span id="5c4b" class="ld le iq mc b gy mg mh l mi mj">REQUEST<br/>=======<br/>POST /login.cgi HTTP/1.1<br/>Host: &lt;ROUTER IP&gt;<br/>Accept: */*<br/>Authorization: Basic &lt;AUTHKEY&gt;<br/>User-Agent: asusrouter-Android-DUTUtil-1.0.0.201<br/>Content-Length: 44<br/>Content-Type: application/x-www-form-urlencoded</span><span id="025c" class="ld le iq mc b gy mk mh l mi mj">Payload:<br/>login_authorization=&lt;AUTHKEY&gt;</span><span id="836c" class="ld le iq mc b gy mk mh l mi mj">REPLY<br/>=====<br/>HTTP/1.0 200 OK<br/>Model_Name: RT-AC66U_B1<br/>Content-Type: application/json:charset=UTF-8<br/>Set-cookie: asus_token=&lt;TOKEN&gt;; HttpOnly;<br/>....</span><span id="9b57" class="ld le iq mc b gy mk mh l mi mj">{ <br/>  "asus_token": "&lt;TOKEN&gt;"<br/>}</span></pre><p id="379f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">似乎我们可以使用<em class="lc"> /login.cgi </em>端点从路由器获得一个令牌。有效负载让我想起了在其他网站上看到的Base64编码的用户名/密码。这是一种非常常见的认证形式。</p><p id="2920" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，让我们尝试从路由器获取一个令牌:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="d689" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们尝试在路由器的ip地址上调用<em class="lc"> /login.cgi </em>端点。HTTP请求的有效负载包含登录授权，如数据包捕获中所示。我们需要将账户信息&lt;用户名&gt; : &lt;密码&gt;转换成Base64编码字符串。首先，我们用<em class="lc">str . encode(‘ascii’)将字符串编码成一个字节数组。</em>该字节数组使用<em class="lc"> base64.b64encode() </em>进行Base64编码。为了创建这个编码字节数组的字符串表示形式，该数组被编码为ascii字符串。这个ascii字符串(名为<em class="lc"> login </em>)被添加到登录请求的有效负载中。用户名和密码与登录路由器web界面时相同。</p><p id="7e92" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第一次尝试没有使用标题，导致了一个HTML错误页面:</p><pre class="km kn ko kp gt mb mc md me aw mf bi"><span id="bb88" class="ld le iq mc b gy mg mh l mi mj">&lt;HTML&gt;&lt;HEAD&gt;&lt;script&gt;top.location.href='/Main_Login.asp';&lt;/script&gt;<br/>&lt;/HEAD&gt;&lt;/HTML&gt;</span></pre><p id="fd13" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我们查看捕获的包时，我们看到一个非常具体的用户代理，指定了某种Android客户端。添加此用户代理会产生上面的代码并成功执行，从而从路由器产生一个令牌供进一步使用:</p><pre class="km kn ko kp gt mb mc md me aw mf bi"><span id="11f0" class="ld le iq mc b gy mg mh l mi mj">{ "asus_token":"&lt;token&gt;" }</span></pre><h2 id="4643" class="ld le iq bd lf lg lh dn li lj lk dp ll jy lm ln lo kc lp lq lr kg ls lt lu lv bi translated">从路由器获取信息</h2><p id="4146" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">现在我们有了一个令牌，让我们看看是否可以从路由器获得任何信息。网络嗅探器中的第一个请求显示了一个<em class="lc"> uptime() </em>调用。该呼叫作为<em class="lc">挂钩</em>被发送到端点<em class="lc"> /appGet.cgi </em>。</p><pre class="km kn ko kp gt mb mc md me aw mf bi"><span id="6bc0" class="ld le iq mc b gy mg mh l mi mj">REQUEST<br/>=======<br/>POST /appGet.cgi HTTP/1.1<br/>Host: 192.168.2.1<br/>Accept: */*<br/>user-Agent: asusrouter-Android-DUTUtil-1.0.0.245<br/>cookie: asus_token=wwyCQ78dUYSXY7VSfjdS4fqwuEy8npj<br/>Content-Length: 220<br/>Content-Type: application/x-www-form-urlencoded</span><span id="5b48" class="ld le iq mc b gy mk mh l mi mj">Payload:<br/>hook=uptime();</span><span id="622a" class="ld le iq mc b gy mk mh l mi mj">REPLY<br/>=====<br/>Server: httpd/2.0<br/>Cache-Control: no-store, no-cache, no-store, must-revalidate<br/>Pragma: no-cache, no-cache<br/>Model_Name: RT-AC66U_B1<br/>Date: Sat, 24 Jul 2021 15:27:26 GMT<br/>Expires: 0<br/>Content-Type: application/json;charset=UTF-8<br/>Connection: close</span><span id="c9f7" class="ld le iq mc b gy mk mh l mi mj">{<br/>  "uptime":Sat, 24 Jul 2021 17:27:26 +0200(558288 secs since boot)<br/>}</span></pre><p id="5c4e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们试着调用这个函数:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="6741" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们使用类似于"<em class="lc"> hook=uptime() </em>"的有效负载调用endpoint /appGet.cgi，同时使用与第一次调用相同的用户代理并添加<em class="lc"> asus_token </em>作为cookie，我们获得以下结果:</p><pre class="km kn ko kp gt mb mc md me aw mf bi"><span id="92a3" class="ld le iq mc b gy mg mh l mi mj">{<br/>"uptime":Sat, 24 Jul 2021 17:27:26 +0200(558288 secs since boot)<br/>}</span></pre><p id="662a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">厉害！我们现在能够从我们的华硕路由器检索信息！一些测试表明，使用与调用端点完全相同的头进行登录至关重要。检查包嗅探器，我们确定以下方法:</p><pre class="km kn ko kp gt mb mc md me aw mf bi"><span id="db55" class="ld le iq mc b gy mg mh l mi mj">uptime()<br/>memory_usage()<br/>cpu_usage()<br/>get_clientlist()<br/>netdev(appobj)<br/>wanlink()<br/>nvram_get(time_zone|time_zone_dst|time_zone_x|time_zone_dstoff|<br/>          time_zone|ntp_server0|acs_dfs|productid|apps_sq|<br/>          lan_hwaddr|lan_ipaddr|lan_proto|x_Setting|label_mac|<br/>          lan_netmask|lan_gateway|http_enable|https_lanport<br/>          wl0_country_code|wl1_country_code|wps_enable|wps_sta_pin<br/>          enable_samba|st_samba_mode|enable_ftp|st_ftp_mode)<br/>dhcpLeaseMacList()<br/></span></pre><p id="a8e8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">很可能会有更多的钩子可用，更多的选项，尤其是<em class="lc"> nvram_get </em>钩子。</p><h2 id="8200" class="ld le iq bd lf lg lh dn li lj lk dp ll jy lm ln lo kc lp lq lr kg ls lt lu lv bi translated">网络带宽</h2><p id="c371" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">利用识别出的钩子，我们已经构建了一些很好的函数，例如，一个带宽计算器，其数据来自钩子<em class="lc"> netdev(appobj): </em></p><pre class="km kn ko kp gt mb mc md me aw mf bi"><span id="253c" class="ld le iq mc b gy mg mh l mi mj">{<br/>  'netdev': {<br/>    'INTERNET_rx': '0x3f4b8f6e',<br/>    'INTERNET_tx': '0xc06bba74',<br/>    'BRIDGE_rx': '0x253239bec',<br/>    'BRIDGE_tx': '0x1add76312',<br/>    'WIRED_rx': '0xa1097d399',<br/>    'WIRED_tx': '0x191085a63',<br/>    'WIRELESS0_rx': '0x51340e36',<br/>    'WIRELESS0_tx': '0x110b00a5',<br/>    'WIRELESS1_rx': '0x3e3e76cc',<br/>    'WIRELESS1_tx': '0x66f13802'<br/>  }<br/>}</span></pre><p id="f36f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这些数字表示通过WAN连接、网桥连接、有线连接和无线连接发送和接收的数据量。多次调用该方法显示，数字只会增加，因此它似乎是一个连续的摘要。这些数字每两秒钟更新一次。</p><p id="fb8a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一些计算表明，十六进制数代表总字节数。将差值乘以8得到位，除以(1024*1024)得到兆位，最后除以2得到每秒，得到的数字与应用程序给出的带宽使用量相同。</p><p id="3f0a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，计算WAN网络流量的代码是:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ml mm l"/></div></figure><pre class="km kn ko kp gt mb mc md me aw mf bi"><span id="40b5" class="ld le iq mc b gy mg mh l mi mj">TX Mbit/s : 0.09597015380859375<br/>RX Mbit/s : 1.3212623596191406</span></pre><h2 id="81af" class="ld le iq bd lf lg lh dn li lj lk dp ll jy lm ln lo kc lp lq lr kg ls lt lu lv bi translated">创建RouterInfo类</h2><p id="b3f5" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">创建一个助手类<strong class="jp ir"> RouterInfo </strong>，以方便使用路由器功能。初始化之后，它提供了对路由器细节的访问，包括一些简化用户工作的附加方法。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="800d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在创建时，创建类并从路由器获得令牌。路由器的IP和该令牌被存储以供其他用户使用。创建一个私有的<em class="lc"> __get() </em>方法，该方法包含调用路由器钩子函数的通用代码。该类的所有方法都使用它。完整的类可以在Github上找到:<a class="ae lb" href="https://github.com/lmeulen/AsusRouterMonitor" rel="noopener ugc nofollow" target="_blank">LME ulen/AsusRouterMonitor</a>。</p><p id="d830" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一个示例方法是<em class="lc"> get_uptime() </em>方法。实现首先通过<em class="lc"> __get() </em>方法调用钩子<em class="lc"> uptime() </em>。结果有点奇怪:</p><pre class="km kn ko kp gt mb mc md me aw mf bi"><span id="bfe1" class="ld le iq mc b gy mg mh l mi mj">{\n"uptime":Sat, 24 Jul 2021 17:27:26 +0200(558288 secs since boot)\n}</span></pre><p id="7d66" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在将它返回给调用者之前，以秒为单位的最后启动时间和正常运行时间被分成两个不同的字段。上次启动时间是“:”和“(”之间的字符串，而正常运行时间是“(”和第一个空格之间的部分。带有这两个字段的JSON被创建并返回给调用者。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="2695" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在编写<strong class="jp ir">的时候，RouterInfo </strong>类有以下方法:</p><pre class="km kn ko kp gt mb mc md me aw mf bi"><span id="4bbe" class="ld le iq mc b gy mg mh l mi mj">get_uptime           - Uptime and last time of boot<br/>get_uptime_secs      - Uptime<br/>get_memory_usage     - Memory usage statistics<br/>get_cpu_usage        - CPU usage statistics<br/>get_settings         - get set of most important router settings<br/>get_clients_fullinfo - All info of all connected clients<br/>get_clients_info     - Get most important info on all clients<br/>get_client_info(cid) - Get info of specified client (MAC address)<br/>get_traffic_total    - Total network usage since last boot<br/>get_traffic          - Current network usage and total usage<br/>get_status_wan       - Get WAN status info<br/>is_wan_online        - WAN connected True/False<br/>get_lan_ip_adress    - Get router IP address for LAN<br/>get_lan_netmask      - Get network mask for LAN<br/>get_lan_gateway      - Get gateway address for LAN<br/>get_dhcp_list        - List of DHCP leases given out<br/>get_online_clients   - Get list of online clients (MAC address)<br/>get_clients_info     - Get most important info on all clients<br/>get_client_info(cid) - Get info of specified client (MAC address)</span></pre><p id="a40d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">随着时间的推移，这个类将会被其他钩子和用户友好的函数所扩展。关注<a class="ae lb" href="https://github.com/lmeulen/AsusRouterMonitor" rel="noopener ugc nofollow" target="_blank">lmeulen/AsusRouterMonito</a>r保持最新。</p><h2 id="f866" class="ld le iq bd lf lg lh dn li lj lk dp ll jy lm ln lo kc lp lq lr kg ls lt lu lv bi translated">可能的使用案例</h2><p id="b163" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">那么我们能利用这些信息做什么呢？浮现在脑海中的一些想法是:</p><ul class=""><li id="2643" class="mn mo iq jp b jq jr ju jv jy mp kc mq kg mr kk ms mt mu mv bi translated"><strong class="jp ir">网络监控</strong> —定期从路由器获取最重要的统计数据，将其存储在InfluxDB中，并创建一个Grafana仪表板来监控您的网络信息。</li><li id="8356" class="mn mo iq jp b jq mw ju mx jy my kc mz kg na kk ms mt mu mv bi translated"><strong class="jp ir">检查设备状态</strong> —检查特定设备是否在线，并将其用于家庭自动化。例如，当智能手机在线时，一个人在家。或者在重要设备离线时收到通知</li><li id="8288" class="mn mo iq jp b jq mw ju mx jy my kc mz kg na kk ms mt mu mv bi translated"><strong class="jp ir">监控您的ISP </strong> —跟踪您的ISP提供的WAN连接的可靠性</li><li id="bb6f" class="mn mo iq jp b jq mw ju mx jy my kc mz kg na kk ms mt mu mv bi translated"><strong class="jp ir">网络分析</strong> —你的网络感觉拥挤吗？找到最大的数据用户并验证网络和WAN容量。</li><li id="0014" class="mn mo iq jp b jq mw ju mx jy my kc mz kg na kk ms mt mu mv bi translated"><strong class="jp ir">监控连接的设备</strong> —监控所有连接的设备，并在未知设备连接时发出警报。</li></ul><h2 id="4d54" class="ld le iq bd lf lg lh dn li lj lk dp ll jy lm ln lo kc lp lq lr kg ls lt lu lv bi translated">最后的话</h2><p id="c3f8" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">我希望你喜欢这篇文章。要获得灵感，请查看我的其他文章:</p><ul class=""><li id="74af" class="mn mo iq jp b jq jr ju jv jy mp kc mq kg mr kk ms mt mu mv bi translated"><a class="ae lb" href="https://towardsdatascience.com/side-by-side-comparison-of-strings-in-python-b9491" rel="noopener" target="_blank">Python中字符串的并排比较</a></li><li id="de19" class="mn mo iq jp b jq mw ju mx jy my kc mz kg na kk ms mt mu mv bi translated"><a class="ae lb" href="https://towardsdatascience.com/remove-personal-information-from-text-with-python-232cb69cf074" rel="noopener" target="_blank">用Python删除文本中的个人信息</a></li><li id="4ebe" class="mn mo iq jp b jq mw ju mx jy my kc mz kg na kk ms mt mu mv bi translated"><a class="ae lb" href="https://towardsdatascience.com/parallel-web-requests-in-python-4d30cc7b8989" rel="noopener" target="_blank">使用Python的并行web请求</a></li><li id="2a67" class="mn mo iq jp b jq mw ju mx jy my kc mz kg na kk ms mt mu mv bi translated">所有公共交通工具都通向乌得勒支，而不是罗马</li><li id="475c" class="mn mo iq jp b jq mw ju mx jy my kc mz kg na kk ms mt mu mv bi translated"><a class="ae lb" href="https://towardsdatascience.com/visualization-of-travel-times-with-otp-and-qgis-3947d3698042" rel="noopener" target="_blank">使用OTP和QGIS可视化行程时间</a></li></ul><p id="bb73" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你喜欢这个故事，请点击关注按钮！ </p><p id="825e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="lc">免责声明:本文包含的观点和意见仅归作者所有。</em></p></div></div>    
</body>
</html>