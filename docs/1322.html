<html>
<head>
<title>Write Modularized Code to Clean up your JavaScript imports!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编写模块化代码来清理您的JavaScript导入！</h1>
<blockquote>原文：<a href="https://itnext.io/write-modularized-code-to-clean-up-your-javascript-imports-525dd3f7dc08?source=collection_archive---------6-----------------------#2018-09-10">https://itnext.io/write-modularized-code-to-clean-up-your-javascript-imports-525dd3f7dc08?source=collection_archive---------6-----------------------#2018-09-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/346624539a5b1b8341166664eea7da8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9OiXFTtWfHLPA6icz-0aLw.jpeg"/></div></div></figure><p id="ec58" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这篇文章中，我将教你一个漂亮的小技巧，如果你还没有这样做的话，你绝对应该使用它来清理你的JavaScript导入。</p><p id="ba5a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我最近在YouTube上制作了一个关于Sub Rendering React Components的视频，这个视频是基于我在这里写的一篇博文。一些很酷的人评论了这个视频，因为他通过评论(暗示暗示，眨眼，轻推轻推)变得很酷。无论如何，大声喊出来那个自称“Max Equation”的酷哥。他留下了这条鼓舞人心的评论，激励我写下了这篇博文:</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi kx"><img src="../Images/6a0748fc3f1911436e5c511a383f9c4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YHLn1DZSjbo5615Y"/></div></div></figure><p id="6c98" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我将在其他时间讨论将TypeScript与ReactJS集成。但是在这篇文章中，我想谈谈模块化JavaScript函数和类的概念！</p><h1 id="528a" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">JavaScript中模块化是什么意思？</h1><p id="350f" class="pw-post-body-paragraph jy jz iq ka b kb ma kd ke kf mb kh ki kj mc kl km kn md kp kq kr me kt ku kv ij bi translated">这是一种奇特但简单的技术，它利用了ES6附带的<code class="fe mf mg mh mi b">import</code>和<code class="fe mf mg mh mi b">export</code>功能。我在我的React工作中经常使用它，但是它可以在任何JavaScript框架中使用。</p><p id="2633" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了解释这个概念，我们首先需要浏览一下ES6导入和导出是如何工作的。让我们看一个简单的无状态函数式React组件的例子，它呈现了一个<code class="fe mf mg mh mi b">Header</code>、<code class="fe mf mg mh mi b">Content</code>和<code class="fe mf mg mh mi b">Footer</code>组件。这些组件被定义在<code class="fe mf mg mh mi b">components</code>文件夹中的三个独立文件中。<code class="fe mf mg mh mi b">components</code>文件夹与我们的简单组件在同一个目录级别上，出于演示目的，我们称之为<code class="fe mf mg mh mi b">MyComponent</code>。下面是我们对<code class="fe mf mg mh mi b">MyComponent</code>的实现:</p><pre class="ky kz la lb gt mj mi mk ml aw mm bi"><span id="3f7e" class="mn ld iq mi b gy mo mp l mq mr">import React from 'react';<br/>import Header from './components/header;<br/>import Content from './components/content;<br/>import Footer from './components/footer;</span><span id="1c3a" class="mn ld iq mi b gy ms mp l mq mr">const MyComponent = () =&gt; (<br/>  &lt;&gt;<br/>    &lt;Header /&gt;<br/>    &lt;Content /&gt;<br/>    &lt;Footer /&gt;<br/>  &lt;/&gt;<br/>);</span><span id="443d" class="mn ld iq mi b gy ms mp l mq mr">export default MyComponent;</span></pre><p id="8834" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我想把重点放在这个组件的<code class="fe mf mg mh mi b">import</code>部分，所以我把它保持得非常简单。如果你不熟悉<code class="fe mf mg mh mi b">&lt;&gt;...&lt;/&gt;</code>语法，那么<a class="ae kw" href="https://www.barrymichaeldoyle.com/fragment" rel="noopener ugc nofollow" target="_blank">看看我关于React片段的帖子</a>。</p><p id="290d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在示例中，<code class="fe mf mg mh mi b">Header</code>、<code class="fe mf mg mh mi b">Content</code>和<code class="fe mf mg mh mi b">Footer</code>组件具有非常相似的实现。让我们把重点放在<code class="fe mf mg mh mi b">Header</code>组件上。这个<code class="fe mf mg mh mi b">Header</code>组件或者是在<code class="fe mf mg mh mi b">components</code>文件夹中名为<code class="fe mf mg mh mi b">header.js</code>的文件中的默认导出函数。否则，它是默认的导出函数，保存在<code class="fe mf mg mh mi b">components</code>文件夹中名为<code class="fe mf mg mh mi b">header</code>的文件夹内的<code class="fe mf mg mh mi b">index.js</code>文件中。好吧，这是一个口…你还在我身边吗？</p><p id="a5fd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">基本上对<code class="fe mf mg mh mi b">'./header'</code>的引用要么是一个<code class="fe mf mg mh mi b">header.js</code>文件，要么是一个<code class="fe mf mg mh mi b">header</code>文件夹中的<code class="fe mf mg mh mi b">index.js</code>文件。如果你现在不明白，我不知道还能说什么。几天后我会制作一个YouTube视频来解释这个问题。你可以通过这个链接订阅它。</p><h1 id="9e12" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">导出默认值与导出命名函数/类</h1><p id="3b3c" class="pw-post-body-paragraph jy jz iq ka b kb ma kd ke kf mb kh ki kj mc kl km kn md kp kq kr me kt ku kv ij bi translated">还记得我说过这些导入的组件是导出它们的文件的默认导出函数吗？好吧，让我们看一下<code class="fe mf mg mh mi b">header.js</code>文件来理解我的意思:</p><pre class="ky kz la lb gt mj mi mk ml aw mm bi"><span id="8a4c" class="mn ld iq mi b gy mo mp l mq mr">const Header = () =&gt; &lt;div&gt;Header&lt;/div&gt;;</span><span id="bcb2" class="mn ld iq mi b gy ms mp l mq mr">export default Header;</span></pre><p id="1eb8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们<code class="fe mf mg mh mi b">export default Header;</code>，所以当我们在我们的主组件中导入它时，我们像这样导入它:</p><pre class="ky kz la lb gt mj mi mk ml aw mm bi"><span id="2c38" class="mn ld iq mi b gy mo mp l mq mr">import Header from './components/header';</span></pre><p id="b492" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您不必总是导出默认值。然而，一个普遍接受的最佳实践是每个文件有一个函数或类，并且默认导出那个函数或类。您也可以将<code class="fe mf mg mh mi b">Header</code>函数导出为命名导出，如下所示:</p><pre class="ky kz la lb gt mj mi mk ml aw mm bi"><span id="75fc" class="mn ld iq mi b gy mo mp l mq mr">const Header = () =&gt; &lt;div&gt;Header&lt;/div&gt;;</span><span id="a383" class="mn ld iq mi b gy ms mp l mq mr">export Header; // See the 'default' keyword is removed</span></pre><p id="ee5d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您也可以导出它，命名如下:</p><pre class="ky kz la lb gt mj mi mk ml aw mm bi"><span id="787c" class="mn ld iq mi b gy mo mp l mq mr">export const Header = () =&gt; &lt;div&gt;Header&lt;/div&gt;;</span></pre><p id="29fd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这对我们在主组件中导入<code class="fe mf mg mh mi b">Header</code>的实现意味着什么？因为它现在是一个命名的导出，所以您需要使用像这样的花括号来导入它:</p><pre class="ky kz la lb gt mj mi mk ml aw mm bi"><span id="fd0b" class="mn ld iq mi b gy mo mp l mq mr">import { Header } from './components/header';</span></pre><p id="5aab" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是正如我提到的，建议每个文件有一个类或函数，并且这个类或函数应该是默认导出的。</p><h2 id="76c6" class="mn ld iq bd le mt mu dn li mv mw dp lm kj mx my lq kn mz na lu kr nb nc ly nd bi translated">那么导出命名的函数和类有什么意义呢？</h2><p id="0cf3" class="pw-post-body-paragraph jy jz iq ka b kb ma kd ke kf mb kh ki kj mc kl km kn md kp kq kr me kt ku kv ij bi translated">这是事情变酷的地方。假设我们很懒，我们决定不为我们的<code class="fe mf mg mh mi b">Header</code>、<code class="fe mf mg mh mi b">Content</code>和<code class="fe mf mg mh mi b">Footer</code>组件、#screwbestpractices创建单独的文件。如果我们像下面这个例子一样，把它们都导出到组件文件夹中的一个<code class="fe mf mg mh mi b">index.js</code>文件中，会怎么样呢？</p><pre class="ky kz la lb gt mj mi mk ml aw mm bi"><span id="7171" class="mn ld iq mi b gy mo mp l mq mr">export const Header = () =&gt; &lt;div&gt;Header&lt;/div&gt;;<br/>export const Content = () =&gt; &lt;div&gt;Content&lt;/div&gt;;<br/>export const Footer = () =&gt; &lt;div&gt;Footer&lt;/div&gt;;</span></pre><p id="6d4c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这很酷，现在我们可以像这样将它们导入我们的主组件:</p><pre class="ky kz la lb gt mj mi mk ml aw mm bi"><span id="f489" class="mn ld iq mi b gy mo mp l mq mr">import { Header, Content, Footer } from './components';</span></pre><p id="8445" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">出于学习的目的，如果我们做同样的事情，但是像这样导出缺省值<code class="fe mf mg mh mi b">Header</code>:</p><pre class="ky kz la lb gt mj mi mk ml aw mm bi"><span id="9458" class="mn ld iq mi b gy mo mp l mq mr">const Header = () =&gt; &lt;div&gt;Header&lt;/div&gt;;<br/>export const Content = () =&gt; &lt;div&gt;Content&lt;/div&gt;;<br/>export const Footer = () =&gt; &lt;div&gt;Footer&lt;/div&gt;;<br/>export default Header;</span></pre><p id="d728" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后我们将它导入到我们的主组件中，如下所示:</p><pre class="ky kz la lb gt mj mi mk ml aw mm bi"><span id="e5b8" class="mn ld iq mi b gy mo mp l mq mr">import Header, { Content, Footer } from './components';</span></pre><h2 id="805d" class="mn ld iq bd le mt mu dn li mv mw dp lm kj mx my lq kn mz na lu kr nb nc ly nd bi translated">更多进出口小技巧:</h2><p id="2a8a" class="pw-post-body-paragraph jy jz iq ka b kb ma kd ke kf mb kh ki kj mc kl km kn md kp kq kr me kt ku kv ij bi translated">最后一件事。从技术上讲，您可以将默认导出的类命名为您想要的任何名称。例如，您可以像这样导入相同的内容:</p><pre class="ky kz la lb gt mj mi mk ml aw mm bi"><span id="c26c" class="mn ld iq mi b gy mo mp l mq mr">import RandomOtherName, { Content, Footer } from './components';</span></pre><p id="2ea1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">或者，您可以将默认导出命名为已命名导入中的其他内容，如下所示:</p><pre class="ky kz la lb gt mj mi mk ml aw mm bi"><span id="b2ba" class="mn ld iq mi b gy mo mp l mq mr">import { default as Header, Content, Footer } from './components';</span></pre><p id="020d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">也就是说，从技术上讲，您不必命名默认导出。您可以像这样默认导出您的<code class="fe mf mg mh mi b">Header</code>组件:</p><pre class="ky kz la lb gt mj mi mk ml aw mm bi"><span id="615b" class="mn ld iq mi b gy mo mp l mq mr">export const Content = () =&gt; &lt;div&gt;Content&lt;/div&gt;;<br/>export const Footer = () =&gt; &lt;div&gt;Footer&lt;/div&gt;;<br/>export default () =&gt; &lt;div&gt;Header&lt;/div&gt;;</span></pre><p id="5da7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这样做仍然可以让我上面提到的那些导入技术工作。</p><p id="9d8f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对，我想这就是你需要知道的关于在ES6中导入和导出JavaScript模块的所有内容。但是当涉及到编写干净和可维护的代码时，这些实践中的大多数都不是很好。如果你看过我其他的帖子。你会知道我一直在编写干净、可读和可维护的代码。因此，让我们以讨论如何以一种干净有效的方式导入和导出我们的组件作为结束。</p><h1 id="a8ae" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">模块化代码正在运行！</h1><p id="216a" class="pw-post-body-paragraph jy jz iq ka b kb ma kd ke kf mb kh ki kj mc kl km kn md kp kq kr me kt ku kv ij bi translated">正如我一遍又一遍说过的。为一个函数或类创建一个文件是普遍接受的最佳实践。因此，在我们最初的例子中，我们从不同的文件导入默认的导出函数，我们已经实现了最佳实践。它是这样实现的:</p><pre class="ky kz la lb gt mj mi mk ml aw mm bi"><span id="b32c" class="mn ld iq mi b gy mo mp l mq mr">import Header from './components/header';<br/>import Content from './components/content';<br/>import Footer from './components/footer';</span></pre><p id="f2ee" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是正确的，但是你是否注意到了另一个被我们忽略的普遍接受的最佳实践？如果你在想“干”这个词，那你就对了！“干”代表“不要重复自己”。你可以在这里看到一个共同的模式。我们从同一个文件夹导入多个函数，但是它们在不同的文件中。我们能在这做点什么吗？</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/629a3c00ebd59152794feabce6bffe75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*HJtMTHj1d6quIbOKq4CjPg.gif"/></div></figure><p id="0d55" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们把所有的技术和我们在这里所拥有的放在一起，我们可以做一些神奇的事情！记得我们所有的功能都在<code class="fe mf mg mh mi b">components</code>文件夹里吧？如果一切保持原样，并在我们的<code class="fe mf mg mh mi b">components</code>文件夹中添加一个<code class="fe mf mg mh mi b">index.js</code>文件，将我们所有的默认函数作为命名函数导出到一个地方，会怎么样？那是一个绝妙的主意！我们可以像这样轻松地做到:</p><pre class="ky kz la lb gt mj mi mk ml aw mm bi"><span id="ebe4" class="mn ld iq mi b gy mo mp l mq mr">export { default as Header } from './header';<br/>export { default as Content } from './content';<br/>export { default as Footer } from './footer';</span></pre><p id="9e7c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，您可以将它们全部导入主组件，如下所示:</p><pre class="ky kz la lb gt mj mi mk ml aw mm bi"><span id="3b56" class="mn ld iq mi b gy mo mp l mq mr">import { Header, Content, Footer } from './components';</span></pre><p id="bb3b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是一种以有组织的方式导入和导出文件的更干净的方式。使用这种技术引用类和函数要容易得多。</p><h2 id="a652" class="mn ld iq bd le mt mu dn li mv mw dp lm kj mx my lq kn mz na lu kr nb nc ly nd bi translated">另一个可以使用这项技术的地方</h2><p id="5205" class="pw-post-body-paragraph jy jz iq ka b kb ma kd ke kf mb kh ki kj mc kl km kn md kp kq kr me kt ku kv ij bi translated">我发现这个技巧对于将许多辅助函数分割成多个文件而不是将它们都保存在一个文件中非常方便。这使得在IDE中导航时更容易找到您的助手函数，也更容易确定单元测试助手的范围。</p><h1 id="5b25" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">结论</h1><p id="606d" class="pw-post-body-paragraph jy jz iq ka b kb ma kd ke kf mb kh ki kj mc kl km kn md kp kq kr me kt ku kv ij bi translated">我们已经讲了很多，我希望你已经学到了很多。如果你已经知道了这个技巧，那么我希望你可以用这篇文章来教导你的同事和朋友。</p><p id="e370" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我写这类帖子的灵感来自于<a class="ae kw" href="https://amzn.to/2LxtXDo" rel="noopener ugc nofollow" target="_blank">Code Complete:A Practical Handbook of Software Construction，第二版</a>。这本书是包括我自己在内的许多开发者成长的催化剂。如果你没有一本，我强烈建议你帮自己一个忙，弄一本！</p><p id="c02f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">反正！如果你喜欢这个帖子，请留下一些赞和掌声。如果你想了解我的更多内容，请务必关注我的<a class="ae kw" href="https://www.facebook.com/barrymichaeldoyle" rel="noopener ugc nofollow" target="_blank">脸书</a>、<a class="ae kw" href="https://twitter.com/barrymdoyle" rel="noopener ugc nofollow" target="_blank">推特</a>、<a class="ae kw" href="https://medium.com/@barrymdoyle" rel="noopener">媒体</a>、<a class="ae kw" href="https://www.youtube.com/barrymichaeldoyle?sub_confirmation=1" rel="noopener ugc nofollow" target="_blank"> YouTube </a>和<a class="ae kw" href="https://www.linkedin.com/in/barry-michael-doyle-11369683/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>。</p><p id="9ed4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">编码快乐！</p></div><div class="ab cl nf ng hu nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ij ik il im in"><p id="c6d7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="nm">原载于2018年9月10日</em><a class="ae kw" href="https://www.barrymichaeldoyle.com/modularizing/" rel="noopener ugc nofollow" target="_blank"><em class="nm">www.barrymichaeldoyle.com</em></a><em class="nm">。</em></p></div></div>    
</body>
</html>