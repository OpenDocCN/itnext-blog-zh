<html>
<head>
<title>Callbacks: The Definitive Guide</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">回调:权威指南</h1>
<blockquote>原文：<a href="https://itnext.io/the-definitive-guide-to-callbacks-in-javascript-44a39c065292?source=collection_archive---------0-----------------------#2019-03-02">https://itnext.io/the-definitive-guide-to-callbacks-in-javascript-44a39c065292?source=collection_archive---------0-----------------------#2019-03-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/58d7723b2513905529fac2dfdcd8fc12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZcAVLAfcH5gZcVppRykWmg.png"/></div></div></figure><div class=""/><div class=""><h2 id="406e" class="pw-subtitle-paragraph jy ja jb bd b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp dk translated">了解异步的真正方法</h2></div><p id="8e3a" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><em class="lm">我不想指名道姓，但我读过的许多关于JavaScript中的异步的文章，尤其是那些在ES2015 (ES6)推出时的文章，都是完全错误的。我将通过展示对JavaScript中async工作方式的真实理解来澄清这个错误。</em></p><p id="25f4" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><em class="lm">这一系列文章基于我做的一个关于Redux-Observable </em>  <em class="lm">的演讲中的一张幻灯片。我想更进一步，解释异步是如何工作的，以及为什么它是JavaScript编码的基础。</em></p><h1 id="b0ff" class="lo lp jb bd lq lr ls lt lu lv lw lx ly kh lz ki ma kk mb kl mc kn md ko me mf bi translated">最强大的方法</h1><p id="5553" class="pw-post-body-paragraph kq kr jb ks b kt mg kc kv kw mh kf ky kz mi lb lc ld mj lf lg lh mk lj lk ll ij bi translated">回调——或者回调函数——被许多不真正理解JavaScript中异步的人所厌恶。到目前为止，它们是语言中最强大、最神奇的部分；事实上，JavaScript中所有其他形式的异步都是基于回调的。</p><p id="8182" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">试镜不烂吗？不，它们是JavaScript的命脉，但是它们确实给JS初学者带来了一个问题。不记得为什么了，刚开始用JS的时候，我就想办法<code class="fe ml mm mn mo b">sleep</code>或者<code class="fe ml mm mn mo b">wait</code>。相反，我被<code class="fe ml mm mn mo b">setTimeout</code>的复杂迂回所困。如今，情况完全相反，但那是因为，一旦我学会了如何使用回调，它们就变得越来越强大。</p><p id="dc72" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">然后就是缺少一个返回值。另一个问题是。常规函数有时缺少返回值，但是对于异步回调，如果你返回值，这个值通常不存在。实际上，获取这些返回值是可能的，但前提是回调是同步的。你会在承诺、观察、甚至像<code class="fe ml mm mn mo b">map</code>、<code class="fe ml mm mn mo b">filter</code>和<code class="fe ml mm mn mo b">reduce</code>这样的<code class="fe ml mm mn mo b">Array.prototype</code>函数中到处看到这种同步回调行为。</p><h1 id="fc91" class="lo lp jb bd lq lr ls lt lu lv lw lx ly kh lz ki ma kk mb kl mc kn md ko me mf bi translated">回调也是同步的</h1><p id="e831" class="pw-post-body-paragraph kq kr jb ks b kt mg kc kv kw mh kf ky kz mi lb lc ld mj lf lg lh mk lj lk ll ij bi translated">虽然回调通常被认为是异步的，但是它们也可以同步执行:</p><figure class="mp mq mr ms gt is"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="144c" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">如果你已经明白了这一点，通过在代码末尾调用另一个函数，而不是使用回调，这真的会变得更容易:</p><figure class="mp mq mr ms gt is"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="b129" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">如果不是异步的，为什么还要使用回调呢？在这个更简单的例子中，非回调的例子看起来更容易阅读，但是有些时候你可能想一般化一些代码，这就是数据发挥作用的地方。</p><h1 id="4fc8" class="lo lp jb bd lq lr ls lt lu lv lw lx ly kh lz ki ma kk mb kl mc kn md ko me mf bi translated">带数据的回调</h1><p id="cab9" class="pw-post-body-paragraph kq kr jb ks b kt mg kc kv kw mh kf ky kz mi lb lc ld mj lf lg lh mk lj lk ll ij bi translated">也许你有一个通用的方法将一些数据传递回你的回调函数。如果是这样的话，你会突然明白为什么要使用回调函数而不是直接调用函数了。</p><p id="93ce" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">但即使如此，大多数人也不会这样做，除非他们正在编写库。</p><figure class="mp mq mr ms gt is"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="3cf7" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">注意在<code class="fe ml mm mn mo b">logDataSynchronously</code>中，你的函数只能记录数据。之后绝对无处可去。我们可以通过将日志操作移出并返回数据来改进这个功能。然后我们可以调用它并记录我们收到的信息:</p><figure class="mp mq mr ms gt is"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="fbd1" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我们已经做得很好了，但是我们写的是我们的函数如何给我们数据，而不是让它给我们数据。我过去曾经写过很多这样的代码，正如你将看到的，它有一些限制。</p><h2 id="50e0" class="mv lp jb bd lq mw mx dn lu my mz dp ly kz na nb ma ld nc nd mc lh ne nf me ng bi translated">回调更有力量</h2><p id="8ac8" class="pw-post-body-paragraph kq kr jb ks b kt mg kc kv kw mh kf ky kz mi lb lc ld mj lf lg lh mk lj lk ll ij bi translated">在旧的JavaScript应用程序中，你不希望函数是全局可用的，所以传递函数的最好方法是使用回调。同样，如果你做任何单元测试，依赖注入<strong class="ks jc">会因为回调而变得更加容易。</strong></p><p id="c8eb" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这就是为什么我认为<code class="fe ml mm mn mo b">getDataSynchronously</code>可以通过成为基于回调的<code class="fe ml mm mn mo b">giveDataSychronously</code>来改进:</p><figure class="mp mq mr ms gt is"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="2b2e" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">除了我们现在正在传递<code class="fe ml mm mn mo b">data</code>的事实之外，我们的代码与最初的回调示例相比几乎没有变化。</p><p id="41eb" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">虽然考虑起来可能有些奇怪，<code class="fe ml mm mn mo b">giveDataSynchronously</code>可能是同步的，也可能是异步的，你甚至不需要知道。这就是它的美妙之处。你的代码是一样的。然而，并不是每个开发者都同意这一点。JS初学者受害最深，因为同步和异步回调的处理方式不同。这些是一些令人沮丧的“有时有效，有时无效”情况的原因。</p><p id="3294" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">如果你习惯于从回调的角度考虑问题，那么从抓住问题的角度来看就不用那么担心了，因为同步回调通常会返回值，而异步回调则不会。就这么简单。</p><p id="37c5" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">在一个完全不同的世界里，如果你曾经为谷歌的Chrome浏览器开发过插件，你会注意到一些API接受回调，既返回一个同步值，又异步调用其他回调函数。可笑！这是一场噩梦，会让你的代码变得不必要的复杂。</p><h1 id="93d5" class="lo lp jb bd lq lr ls lt lu lv lw lx ly kh lz ki ma kk mb kl mc kn md ko me mf bi translated">回调地狱！</h1><p id="25b8" class="pw-post-body-paragraph kq kr jb ks b kt mg kc kv kw mh kf ky kz mi lb lc ld mj lf lg lh mk lj lk ll ij bi translated">任何回调链都有成为回调地狱的可能。当您创建大量匿名(未命名)函数作为回调函数，这些函数调用需要另一个回调的函数时，就会出现这种情况，依此类推:</p><figure class="mp mq mr ms gt is"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="3388" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">如果您命名所有这些函数，而不是保持匿名，您不仅陈述了它们的用途，而且完全消除了回调——见鬼:</p><figure class="mp mq mr ms gt is"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="055c" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这是一种说法。回调——地狱无疑使事情更难阅读，因为它们可以跳出来很远。不过，我有不同的看法。有一堆间接就更糟了。</p><p id="1571" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">没有这些递归作用域，您就无法知道您的消息来自哪个服务器或哪个连接。现在，您必须使用函数闭包来保留状态:</p><figure class="mp mq mr ms gt is"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="3978" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">恭喜你。你使得你的应用程序很难被任何人维护(包括6个月后的你)。祝你好运！我以前做过类似的事情，当时我的计算逻辑对于回调来说太多了——见鬼，但更好的是，我重构了它，改用observables，彻底解决了这个问题。</p><p id="682a" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这是一个范围问题。因为callback-hell允许容易地确定范围，所以它消除了许多由命名回调-hell引起的间接性。现在你必须查看所有的代码库，找出这些函数来自哪里，它们做什么。在很多项目中，大多数我参与过的项目(包括我自己的项目)，像这样的回调往往分散在一堆文件中。你需要看的越少，它们越通用(意味着你更经常看到它们)，就越好。</p><p id="d0dd" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">与所有其他异步方法的线性管道不同，您处理的是一个函数调用另一个函数，然后这个函数又调用另一个函数。这几乎就像一个千行函数的复杂性。所有这些都非常令人惊讶，因为从技术上讲，回调是函数式程序员的首选工具，而fp应该让你的代码更容易理解。这就是为什么可观测量是回调的更好版本。它们使你的代码更具可读性，更容易理解，并且允许函数式编程。</p><h1 id="737a" class="lo lp jb bd lq lr ls lt lu lv lw lx ly kh lz ki ma kk mb kl mc kn md ko me mf bi translated">异步回调</h1><p id="2cbc" class="pw-post-body-paragraph kq kr jb ks b kt mg kc kv kw mh kf ky kz mi lb lc ld mj lf lg lh mk lj lk ll ij bi translated">如前所述，同步回调是异步回调。但是那些看起来像什么？使回调异步的那个<code class="fe ml mm mn mo b">// Do some processing...</code>注释中发生了什么？</p><pre class="mp mq mr ms gt nh mo ni nj aw nk bi"><span id="dd76" class="mv lp jb mo b gy nl nm l nn no">setTimeout</span></pre><p id="8aa6" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">没错。几乎所有的异步都与<code class="fe ml mm mn mo b">setTimeout</code>有关。甚至<code class="fe ml mm mn mo b">setInterval</code>都可以用<code class="fe ml mm mn mo b">setTimeout</code>建造。它们被称为调度器，因为它们允许您将它们的执行时间指定为“在这个函数之后的某个时间”，一直到整数max。</p><p id="db04" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">考虑调度器的另一种方式是并发性。通过异步执行任务，您甚至可以在一个线程中同时运行许多任务。太棒了。</p><p id="defd" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">在Node.js中，这被称为<a class="ae ln" href="https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/" rel="noopener ugc nofollow" target="_blank">事件循环</a>。事实上，Node.js有办法操纵用<code class="fe ml mm mn mo b">process.nextTick</code>处理回调的顺序，这可以根据你如何使用它来优先考虑或显著减慢你的应用程序。</p><p id="9b7f" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">在JavaScript中，几乎所有需要将数据拉入或推出应用的东西都是异步的，因为它们不会在同一个线程中运行；因此，它的执行速度无法确定。如果它是同步的，比如渲染到DOM或者处理<code class="fe ml mm mn mo b">localStorage</code>，那么是的，你的应用程序的性能会受到影响。</p><h1 id="2022" class="lo lp jb bd lq lr ls lt lu lv lw lx ly kh lz ki ma kk mb kl mc kn md ko me mf bi translated">试着捕捉错误</h1><p id="09df" class="pw-post-body-paragraph kq kr jb ks b kt mg kc kv kw mh kf ky kz mi lb lc ld mj lf lg lh mk lj lk ll ij bi translated">另一个问题是回调不适用于<code class="fe ml mm mn mo b">try</code> - <code class="fe ml mm mn mo b">catch</code>。这并不完全正确，您可以在回调函数中使用它们，但是如果您将接受回调的函数包装在<code class="fe ml mm mn mo b">try</code> - <code class="fe ml mm mn mo b">catch</code>中，它不会在您的回调或接受函数中捕获错误。这是一个巨大的初学者沙坑，你应该知道。</p><p id="7778" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">以这个函数为例:</p><figure class="mp mq mr ms gt is"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="558b" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">它会抛出一个错误。你可以用<code class="fe ml mm mn mo b">try</code> - <code class="fe ml mm mn mo b">catch</code>包起来没问题。让我们将这个相同的函数放在一个异步回调中:</p><figure class="mp mq mr ms gt is"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="d96b" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">为了捕捉错误，您必须将您的<code class="fe ml mm mn mo b">try</code> - <code class="fe ml mm mn mo b">catch</code>移动到回调函数本身:</p><figure class="mp mq mr ms gt is"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="1f19" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">虽然，如果你的回调是同步的，那么你的<strong class="ks jc"> <em class="lm">可以用<code class="fe ml mm mn mo b">try</code>-<code class="fe ml mm mn mo b">catch</code></em></strong><em class="lm"/>捕捉错误:</p><figure class="mp mq mr ms gt is"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="d804" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这是另一个初学者的陷阱，但也是一个甚至会绊倒JS老手的陷阱，因为它太容易出错了。正如我所展示的，如果你习惯于同步回调，那么当你编写异步回调时，你可能没有意识到你使用<code class="fe ml mm mn mo b">try</code> - <code class="fe ml mm mn mo b">catch</code>的老方法是行不通的。突然，你创造了一个反模式。</p><h1 id="eb92" class="lo lp jb bd lq lr ls lt lu lv lw lx ly kh lz ki ma kk mb kl mc kn md ko me mf bi translated">结论</h1><p id="e5f1" class="pw-post-body-paragraph kq kr jb ks b kt mg kc kv kw mh kf ky kz mi lb lc ld mj lf lg lh mk lj lk ll ij bi translated">与任何其他异步处理程序相比，回调的好处如下:</p><ul class=""><li id="05b4" class="np nq jb ks b kt ku kw kx kz nr ld ns lh nt ll nu nv nw nx bi translated">随着时间的推移，可以接收零个或多个值。</li><li id="a41b" class="np nq jb ks b kt ny kw nz kz oa ld ob lh oc ll nu nv nw nx bi translated">可以接收零个或多个参数。</li><li id="9c98" class="np nq jb ks b kt ny kw nz kz oa ld ob lh oc ll nu nv nw nx bi translated">允许不返回任何内容或数据和错误。</li><li id="b973" class="np nq jb ks b kt ny kw nz kz oa ld ob lh oc ll nu nv nw nx bi translated">有点容易取消(这取决于实现)。</li></ul><p id="a0b0" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这些优点允许大量的通用性，同样的通用性允许所有形式的异步都基于回调。</p><p id="5e61" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">另一方面，大多数回调都需要一些样板文件，就像Node.js中的那些一样，但是因为它们是固有的函数，所以您可以像这样围绕样板文件进行编写:</p><figure class="mp mq mr ms gt is"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="fec8" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这样，我们首先通过将函数<code class="fe ml mm mn mo b">doTheThing</code>作为回调传入来调用<code class="fe ml mm mn mo b">handleError</code>。它返回一个监听<code class="fe ml mm mn mo b">error</code>和<code class="fe ml mm mn mo b">…args</code>的新函数。当一个函数返回另一个类似于<code class="fe ml mm mn mo b">handleError</code>的函数时，它被称为一个闭包，允许我们将<code class="fe ml mm mn mo b">handleError</code>和<code class="fe ml mm mn mo b">doTheThing</code>组合成<code class="fe ml mm mn mo b">'event'</code>触发时发生的事情的一部分。虽然从未被称为回调异常，但这允许我们管理样板文件——在这种情况下处理错误——而不必复制粘贴一堆代码。</p><h2 id="72f5" class="mv lp jb bd lq mw mx dn lu my mz dp ly kz na nb ma ld nc nd mc lh ne nf me ng bi translated">缺乏标准(通过设计)</h2><p id="b0f8" class="pw-post-body-paragraph kq kr jb ks b kt mg kc kv kw mh kf ky kz mi lb lc ld mj lf lg lh mk lj lk ll ij bi translated">作为一名开发人员，你也可能会对你正在处理的回调感到非常困惑。如果是你自己做的，你需要标准化它的工作方式，因为在Node.js中，错误是第一个参数，而对于DOM事件回调，它们有一个特定的取消方式。</p><p id="14b4" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">其他回调，比如在<code class="fe ml mm mn mo b">Array.prototype.map</code>中发现的那些，传递多个参数，比如索引和原始数组。你必须意识到那些是被传入的，否则你的<code class="fe ml mm mn mo b">…args</code>会引起问题。</p><p id="f3b2" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">所以尽管它们无处不在，我还是会限制它们的使用。只有两种方法超越了回调:可观察对象和生成器。原生JS承诺是另一个怪物，虽然很方便，但由于它们是语言的一部分，它们目前还没有比回调好多少，事实上，还可能更差。</p><h1 id="115a" class="lo lp jb bd lq lr ls lt lu lv lw lx ly kh lz ki ma kk mb kl mc kn md ko me mf bi translated">更多阅读</h1><p id="2cee" class="pw-post-body-paragraph kq kr jb ks b kt mg kc kv kw mh kf ky kz mi lb lc ld mj lf lg lh mk lj lk ll ij bi translated">我还会收到更多这样的异步文章！下一个是关于承诺的:</p><p id="1522" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><a class="ae ln" rel="noopener ugc nofollow" target="_blank" href="/promises-the-definitive-guide-6a49e0dbf3b7">承诺:权威指南</a></p><p id="40ee" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">如果你喜欢你所读的，请查看我关于类似的令人大开眼界的主题的其他文章:</p><ul class=""><li id="e350" class="np nq jb ks b kt ku kw kx kz nr ld ns lh nt ll nu nv nw nx bi translated"><a class="ae ln" rel="noopener ugc nofollow" target="_blank" href="/feature-flags-be-truly-agile-820ff50294c">特性标志:真正敏捷</a></li><li id="f767" class="np nq jb ks b kt ny kw nz kz oa ld ob lh oc ll nu nv nw nx bi translated">用食物表情符号制作便便</li><li id="86a2" class="np nq jb ks b kt ny kw nz kz oa ld ob lh oc ll nu nv nw nx bi translated"><a class="ae ln" rel="noopener ugc nofollow" target="_blank" href="/async-react-using-react-router-suspense-a86ade1176dc">使用React路由器的异步React&amp;暂停</a></li><li id="8184" class="np nq jb ks b kt ny kw nz kz oa ld ob lh oc ll nu nv nw nx bi translated"><a class="ae ln" rel="noopener ugc nofollow" target="_blank" href="/using-transducers-to-speed-up-javascript-arrays-92677d000096">使用转换器加速JavaScript数组</a></li></ul></div></div>    
</body>
</html>