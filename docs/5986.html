<html>
<head>
<title>Benchmark PostgreSQL: cross between native versus Docker</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基准PostgreSQL:native与Docker的交叉</h1>
<blockquote>原文：<a href="https://itnext.io/benchmark-postgresql-cross-between-native-versus-docker-a96df9a45014?source=collection_archive---------0-----------------------#2021-07-19">https://itnext.io/benchmark-postgresql-cross-between-native-versus-docker-a96df9a45014?source=collection_archive---------0-----------------------#2021-07-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/e149e12337fd3396af9d81410ad00d4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2GJlNSclyKh-lQWiMiMQgA.png"/></div></div></figure><p id="6d97" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">几个月前，我做了两个基准测试。第一个测试了三个数据库引擎，第二个只测试了PostgreSQL。</p><p id="c728" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您可以在下面的两个链接中找到这些基准。两篇文章都是彼得·贾霍达写的。</p><div class="lb lc gp gr ld le"><a rel="noopener  ugc nofollow" target="_blank" href="/benchmark-databases-in-docker-mysql-postgresql-sql-server-7b129368eed7"><div class="lf ab fo"><div class="lg ab lh cl cj li"><h2 class="bd iu gy z fp lj fr fs lk fu fw is bi translated">Docker中的基准数据库:MySQL、PostgreSQL、SQL Server</h2><div class="ll l"><h3 class="bd b gy z fp lj fr fs lk fu fw dk translated">加上MariaDB、Percona和TimescaleDB</h3></div><div class="lm l"><p class="bd b dl z fp lj fr fs lk fu fw dk translated">itnext.io</p></div></div><div class="ln l"><div class="lo l lp lq lr ln ls jz le"/></div></div></a></div><div class="lb lc gp gr ld le"><a rel="noopener  ugc nofollow" target="_blank" href="/benchmark-postgresql-docker-versus-native-2dde6b5a8552"><div class="lf ab fo"><div class="lg ab lh cl cj li"><h2 class="bd iu gy z fp lj fr fs lk fu fw is bi translated">在所有三个系统上测试PostgreSQL:Docker与native</h2><div class="ll l"><h3 class="bd b gy z fp lj fr fs lk fu fw dk translated">使用所有PGTune设置</h3></div><div class="lm l"><p class="bd b dl z fp lj fr fs lk fu fw dk translated">itnext.io</p></div></div><div class="ln l"><div class="lt l lp lq lr ln ls jz le"/></div></div></a></div><p id="6d0f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因为有一些关于这个基准的想法，我决定再做一个。这一次，我们将只在linux机器上使用AWS测试PostgreSQL 13，测试将使用与以前相同的代码。</p><p id="4d4a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">我们将进行四项测试:</strong></p><ul class=""><li id="16de" class="lu lv it kd b ke kf ki kj km lw kq lx ku ly ky lz ma mb mc bi translated">数据库本机运行，程序本机运行</li><li id="e817" class="lu lv it kd b ke md ki me km mf kq mg ku mh ky lz ma mb mc bi translated">数据库在Docker中运行，程序在本地运行</li><li id="da09" class="lu lv it kd b ke md ki me km mf kq mg ku mh ky lz ma mb mc bi translated">数据库运行在Docker中，程序运行在Docker中</li><li id="c126" class="lu lv it kd b ke md ki me km mf kq mg ku mh ky lz ma mb mc bi translated">数据库在本地运行，程序在Docker中运行</li></ul><p id="212b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我预计不会有重大差异，但数字会告诉我们更多。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="2e02" class="mp mq it bd mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm bi translated">在AWS中准备linux机器</h1><p id="1b5e" class="pw-post-body-paragraph kb kc it kd b ke nn kg kh ki no kk kl km np ko kp kq nq ks kt ku nr kw kx ky im bi translated">对于这个特定的测试，选择了T2 . micro:1x CPU和1GB RAM，符合自由层的条件。连接到正在运行的机器后，我们可以查看信息，看看运行的是什么。</p><figure class="nt nu nv nw gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ns"><img src="../Images/447a57f68b96e6e9ae5d481bf9a7c0b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AXdK8h5B3lIb6vvzOjrVfQ.png"/></div></div></figure><p id="5dcd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">第一步，你的云机器运行后，就是安装Docker: </strong></p><ul class=""><li id="f671" class="lu lv it kd b ke kf ki kj km lw kq lx ku ly ky lz ma mb mc bi translated">更新机器运行<code class="fe nx ny nz oa b">sudo yum update -y</code></li><li id="4ad9" class="lu lv it kd b ke md ki me km mf kq mg ku mh ky lz ma mb mc bi translated">使用<code class="fe nx ny nz oa b">sudo yum install docker -y</code>安装Docker</li><li id="d5f8" class="lu lv it kd b ke md ki me km mf kq mg ku mh ky lz ma mb mc bi translated">使用<code class="fe nx ny nz oa b">sudo systemctl enable docker</code>启用Docker</li><li id="f4bd" class="lu lv it kd b ke md ki me km mf kq mg ku mh ky lz ma mb mc bi translated">使用<code class="fe nx ny nz oa b">sudo systemctl start docker</code>启动Docker</li><li id="3568" class="lu lv it kd b ke md ki me km mf kq mg ku mh ky lz ma mb mc bi translated">使用<code class="fe nx ny nz oa b">sudo usermod -a -G docker ec2-user</code>将您的用户添加到docker组</li></ul><p id="8a88" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">运行<code class="fe nx ny nz oa b">sudo docker</code>命令检查Docker是否正在运行(应该是)。然后注销并再次连接，使用户组更改生效。</p><p id="0841" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">第二步是在Docker中运行Postgres</strong></p><p id="370d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在使用Docker真的很简单。只需使用这个命令(注意Docker中的Postgres将运行在端口5433上，从外面看是这样的) :</p><pre class="nt nu nv nw gt ob oa oc od aw oe bi"><span id="0fc3" class="of mq it oa b gy og oh l oi oj">docker run — name postgres -e POSTGRES_PASSWORD=password -p 5433:5432 -v postgres_data:/var/lib/postgresql/data -d postgres:alpine</span></pre><p id="a263" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用<code class="fe nx ny nz oa b">docker ps -a</code>检查Docker运行中的Postgres 13。</p><p id="30ca" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后使用<code class="fe nx ny nz oa b">CREATE DATABASE benchmark</code>连接并创建新的数据库。</p><p id="6a66" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">第三步是本地运行Postgres 13</strong></p><p id="155a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用<code class="fe nx ny nz oa b">sudo amazon-linux-extras install epel</code>启用EPL库</p><p id="b2f0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">添加存储库使用</p><pre class="nt nu nv nw gt ob oa oc od aw oe bi"><span id="7a7c" class="of mq it oa b gy og oh l oi oj">sudo tee /etc/yum.repos.d/pgdg.repo&lt;&lt;EOF [pgdg13] name=PostgreSQL 13 for RHEL/CentOS 7 - x86_64 baseurl=https://download.postgresql.org/pub/repos/yum/13/redhat/rhel-7-x86_64 enabled=1 gpgcheck=0</span></pre><p id="f717" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用<code class="fe nx ny nz oa b">sudo yum install postgresql13 postgresql13-server -y</code>安装postgres</p><p id="4bef" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">初始化数据库<code class="fe nx ny nz oa b">using sudo /usr/pgsql-13/bin/postgresql-13-setup initdb</code></p><p id="1e9d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用<code class="fe nx ny nz oa b">sudo systemctl enable — now postgresql-13</code>启动服务</p><p id="f55d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用<code class="fe nx ny nz oa b">systemctl status postgresql-13</code>检查其运行情况</p><p id="cc29" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">创建数据库基准并将postgres用户密码更改为<code class="fe nx ny nz oa b">password</code></p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="d02d" class="mp mq it bd mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm bi translated">运行基准程序</h1><p id="1126" class="pw-post-body-paragraph kb kc it kd b ke nn kg kh ki no kk kl km np ko kp kq nq ks kt ku nr kw kx ky im bi translated">我们将再次使用相同的程序，但我们将为所有四种配置进行更改。</p><p id="e759" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">数据库原生程序将使用此连接字符串(127.0.0.1和5432):</p><pre class="nt nu nv nw gt ob oa oc od aw oe bi"><span id="aa07" class="of mq it oa b gy og oh l oi oj">user=postgres password=password dbname=benchmark host=127.0.0.1 port=5432 sslmode=disable</span></pre><p id="82aa" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Docker中的数据库原生程序将使用此连接字符串(127.0.0.1，但5433):</p><pre class="nt nu nv nw gt ob oa oc od aw oe bi"><span id="ff21" class="of mq it oa b gy og oh l oi oj">user=postgres password=password dbname=benchmark host=127.0.0.1 port=5433 sslmode=disable</span></pre><p id="4ba2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">docker中的程序到Docker中的数据库将使用这个连接字符串(从Docker内部使用<code class="fe nx ny nz oa b">docker inspect postgres</code>和5432找到databaseIpAddress):</p><pre class="nt nu nv nw gt ob oa oc od aw oe bi"><span id="76eb" class="of mq it oa b gy og oh l oi oj">user=postgres password=password dbname=benchmark host={databaseIpAddress} port=5432 sslmode=disable</span></pre><p id="4734" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">docker到数据库本地的程序将使用这个连接字符串(127.0.0.1和5432)并使用<code class="fe nx ny nz oa b">--network=”host”</code>运行Docker镜像:</p><pre class="nt nu nv nw gt ob oa oc od aw oe bi"><span id="146d" class="of mq it oa b gy og oh l oi oj">user=postgres password=password dbname=benchmark host=127.0.0.1 port=5432 sslmode=disable</span></pre></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="1a73" class="mp mq it bd mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm bi translated">结果</h1><p id="5890" class="pw-post-body-paragraph kb kc it kd b ke nn kg kh ki no kk kl km np ko kp kq nq ks kt ku nr kw kx ky im bi translated">这是这四项测试的结果。</p><figure class="nt nu nv nw gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ok"><img src="../Images/5ef49a975192faaf41bd96cc9f1dcd7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YiRJu353TwNs4gbY1tmeQA.png"/></div></div><figcaption class="ol om gj gh gi on oo bd b be z dk translated">所有结果都以秒为单位</figcaption></figure><p id="a7e1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">所有的结果都在一个图表里。</p><figure class="nt nu nv nw gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi op"><img src="../Images/dde400ed68ac9f6e3c03fe13a7034b49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TqvHPDq0DwJeB1ywbBn9hA.png"/></div></div><figcaption class="ol om gj gh gi on oo bd b be z dk translated">所有结果都是以秒为单位的，越长越糟</figcaption></figure><p id="09df" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如您所见，无论数据库是否运行在Docker中，从数据库中读取数据几乎没有区别。程序是否在Docker中运行也没有区别。</p><p id="a1f8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然而<strong class="kd iu">有一些问题</strong>，如果你在Docker中运行一个数据库，而程序在Docker之外运行。</p><p id="d6cc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我又进行了几次特定的测试，结果还是一样。当在Docker中运行数据库，而程序(与该数据库通信的程序)在Docker之外运行时，写入速度会明显变慢。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="7dbd" class="mp mq it bd mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm bi translated">摘要</h1><p id="1ae8" class="pw-post-body-paragraph kb kc it kd b ke nn kg kh ki no kk kl km np ko kp kq nq ks kt ku nr kw kx ky im bi translated">在Docker中运行数据库没有问题，从速度上来说。但是，如果你这样做，请考虑运行所有的程序(服务，网络服务器等。)，它们与这个数据库通信，在Docker中运行它们。</p><h1 id="d88d" class="mp mq it bd mr ms oq mu mv mw or my mz na os nc nd ne ot ng nh ni ou nk nl nm bi translated">更新</h1><p id="b2eb" class="pw-post-body-paragraph kb kc it kd b ke nn kg kh ki no kk kl km np ko kp kq nq ks kt ku nr kw kx ky im bi translated">一些人在reddit上对这篇文章做出了回应，并对有问题的事情做出了一些可能的解释。</p><p id="6f5d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">第一个解释是，我没有正确使用postgres容器上的卷。我应该把它映射到某个合适的目录。但我认为这没有意义，因为postgres_data默认情况下自动映射到/var/lib/docker/volumes/{ something }，所以我看不出有必要将其映射到(如建议的)/var/lib/postgres/data。这两个目录都在同一个挂载卷上，我不认为改变会影响这个问题。</p><p id="4cd2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">第二个解释是，使用alpine版本的Postgres是使用不同的编译器编译的，Postgres在Linux上本地运行。这可能是真(我打赌这是真的)，但同样，这也应该影响docker程序 docker数据库的行为。但事实并非如此。</p><p id="76c8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我对此的解释是:Docker和世界其他地方之间的网络接口是导致这种轻微开销的原因，因为这个问题只出现在本地程序 Docker数据库之间，并且只在编写时出现。因为这些写入是通过连续和独立的10 000次插入来完成的，所以我认为Docker和世界其他地方之间的网络接口在这种情况下是一个瓶颈。</p></div></div>    
</body>
</html>