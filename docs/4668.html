<html>
<head>
<title>Functions as dependencies in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift中的依赖功能</h1>
<blockquote>原文：<a href="https://itnext.io/functions-as-dependencies-in-swift-2bc382f9475d?source=collection_archive---------1-----------------------#2020-08-19">https://itnext.io/functions-as-dependencies-in-swift-2bc382f9475d?source=collection_archive---------1-----------------------#2020-08-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/eb9a22f66afa8ff477a726f71c678895.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yzELdeqG7-3Bqxshpw2dbQ.png"/></div></div></figure><h1 id="a9c1" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">介绍</h1><p id="38cd" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">在一个应用程序中实现一个架构可能是一个挑战。有我们可以遵循的规则(坚实、干净的架构)和指导我们的模式(MVVM、MVP、MVI、Redux……)但是有时候，我们认为已经很好建立的东西应该后退一步。</p><p id="ebe7" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">最近，我在开发一个依赖于使用<a class="ae lz" href="https://en.wikipedia.org/wiki/Higher-order_function" rel="noopener ugc nofollow" target="_blank">高阶自由函数</a>的应用程序时就遇到了这种情况。</p><p id="582c" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">在这篇文章中，我将试着把你从点燃对高阶自由函数的渴望的火花引导到关于依赖注入的实现。</p><h1 id="d694" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">依赖注入</h1><p id="edc5" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">依赖注入是一种处于众所周知的软件工程最佳实践十字路口的技术:抽象和分离、单一责任、依赖倒置。它提供了灵活且可测试的实现。</p><p id="2983" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">本文假设依赖注入的优点已经被接受。我们将看到依赖注入和高阶函数是如何很好地结合在一起的。</p><h1 id="1f5a" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">以传统方式实现</h1><p id="1d97" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">在本文的剩余部分，我们将关注一个UsersRepository对象，该对象从Rest API中获取用户，并在返回之前过滤掉用户。为了演示的目的，这个API的所有端点都返回用户，但是根据获取的路由不同，返回的方式也不同。</p><p id="990a" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">为此，UsersRepository将被注入一个ApiService协议，其目的是提供一种从Rest端点获取用户的方法:</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ma"><img src="../Images/9bce41f4790e2e27e6461c90e4ddeb83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vnt96aoR07q-5bFy85gEfg.png"/></div></div></figure><p id="6647" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">这是一个非常常见的实现。当然，在现实生活的实现中，我们会尝试通过使用泛型类型和约束来使ApiService更加通用和安全。</p><p id="fc5a" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">正如我在介绍中所说的，让我们再想一想…为什么是养蜂服务？</p><p id="9993" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">事实上，我们只是想检索用户，存储库并不关心他们来自哪里，这是一个实现细节。Rest API是众多方法中的一种。</p><p id="1f5e" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">一种简单的方法是将ApiService重构为更通用的DataProvider协议。</p><p id="cc93" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">但是它的定义呢？</p><ul class=""><li id="5b83" class="mf mg iq ky b kz lu ld lv lh mh ll mi lp mj lt mk ml mm mn bi translated">“获取”功能不再有实际意义</li><li id="65d4" class="mf mg iq ky b kz mo ld mp lh mq ll mr lp ms lt mk ml mm mn bi translated">“route”参数在API上下文之外变得无关紧要</li><li id="4efc" class="mf mg iq ky b kz mo ld mp lh mq ll mr lp ms lt mk ml mm mn bi translated">“ApiError”类型太具体了</li></ul><p id="9388" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">当然，我们可以找到一种方法来选择更多任何用途的名称和数据结构，但我邀请你寻找另一种方法。</p><h1 id="a73c" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">注入功能</h1><p id="7808" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">毕竟，用户存储库只依赖任何一个发布者来完成它的工作，对吗？</p><p id="889d" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">将这个发布者作为依赖项直接注入的诱惑很大，但是我们不应该这样做。直接注入意味着在注入过程的早期构建这个发布者，这可能会导致不必要的副作用:可能需要时间来构建，或者需要解决其他依赖关系？用户存储库不知道这一点，也无法对此做出假设。发布器应该只在需要的时候构建。</p><p id="1758" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">如果我们不能注入发布者，我们可以注入一个构建它的函数👍，并在我们方便的时候执行。</p><p id="af2d" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">那我们试试吧。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mt"><img src="../Images/a6eefe3fe3d2971231d4bcd091f57ca6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zilThdfI1Td4mOrJ4RXHgw.png"/></div></div></figure><p id="3a58" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我们在这里做了什么:</p><ul class=""><li id="f3d3" class="mf mg iq ky b kz lu ld lv lh mh ll mi lp mj lt mk ml mm mn bi translated">为了便于阅读，我们声明了一个描述函数签名的typealias</li><li id="0486" class="mf mg iq ky b kz mo ld mp lh mq ll mr lp ms lt mk ml mm mn bi translated">我们已经注入了函数</li><li id="9098" class="mf mg iq ky b kz mo ld mp lh mq ll mr lp ms lt mk ml mm mn bi translated">我们用这个函数代替了ApiService</li><li id="e85c" class="mf mg iq ky b kz mo ld mp lh mq ll mr lp ms lt mk ml mm mn bi translated">发布者签名有一点改变，从AnyPublisher 变成AnyPublisher 。由于错误类型的原因，我们不想在这里泄露实现细节。</li></ul><p id="5630" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">到目前为止还不错…但是我们用来传递给fetch函数的路径呢？事实上，我们不再需要它了，因为它是特定于蜜蜂服务的；然而，我们将在本文的后面讨论这一点。</p><p id="ff20" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">额外的好处是，我们还可以注入过滤功能，这样我们就可以根据上下文改变它的行为(例如，过滤器可能在开发、QA或生产环境之间有所不同)。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mu"><img src="../Images/dc2f6cba03ae46f6e98bdad1d1362270.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2HSiXDiNOujDebhtGtCO5g.png"/></div></div></figure><p id="bdcc" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我们再次利用typealiases来传递函数。当使用函数作为依赖项时，这几乎是强制性的。</p><p id="9c82" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">当我们这样做的时候，也许我们可以把我们的思考推得更远一点，向函数的系统化使用迈出最后一步。</p><p id="ae5d" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">为什么我们需要一个存储库？通常，存储库模式用于对一个实体的所有CRUD操作进行分组。我们可以假设一个用户存储库有几个加载、更新和删除功能。一旦实现，这些功能将需要一定数量的依赖项。我们将最终得到一个初始化器，它将所有需要的函数作为参数，然而根据我们想要完成的特性，我们可能只需要其中的一部分。这不是最佳的。</p><p id="52f6" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">摆脱存储库意味着每个功能(加载、更新、删除……)都是自支持的，并且只被注入所需的依赖项。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/310d3126a410fab9e751fa94c6f4e578.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zhY4tfcbXk8BdLw8OuyKtg.png"/></div></div></figure><p id="d09e" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">在这里，我们有一个100%的自主功能。为了清楚起见，我们可以将整个内容包装在一个名称空间中，以缩短一些名称:</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/da63e42bd73e63a8386b53c40a52797e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kzxRg5h8dYvf1dDtTSK2Gw.png"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">我们还可以为filterFunction参数设置一个默认值，以使API更加简洁</figcaption></figure><h1 id="9e1b" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">对单元测试的积极影响</h1><p id="fe99" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">让我们回到最初的UsersRepository实现。为了对loadUsers函数进行单元测试，我们必须创建一个模拟的ApiService来满足初始化器的需求。被模仿的ApiService应该能够成功或失败，以便测试loadUsers函数的输出。</p><p id="7621" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">在不幸的情况下，ApiService也需要自己的依赖项，那么我们将被迫实现另一个模拟的依赖项。如果我们将这种策略应用到整个应用程序中，我们最终可能会得到一个复杂的模拟对象层次结构。</p><p id="7682" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">当使用函数作为依赖项时，我们当然仍然需要模拟，但是它们通常非常小、简单并且就在单元测试旁边定义:</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nb"><img src="../Images/3817f6d4cb940753dbc5edceb2703d94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9lIiQL2AJIYi28vSp1tTGw.png"/></div></div></figure><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mt"><img src="../Images/feba57a29cd892eba2ded7a1fcf9db62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WpTj9CUWrE7qHOgxrmqpRw.png"/></div></div></figure><p id="432b" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">单元测试非常容易想象、编写和阅读。就个人而言，我发现这种技术是达到高(且有意义的)代码覆盖率的非常好的工具。我认为当使用TDD方法时，它会有很大帮助。</p><h1 id="6219" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">函数式编程的一个技巧</h1><p id="544a" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">您还记得UsersRepository的最初实现吗:它使用ApiService来获取由路由定义的端点。即使这已经被注入函数带来的抽象所抹去，最终我们仍然需要提供一个可以真实检索用户的函数。依赖注入机制负责提供兼容的具体实现。</p><p id="c918" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我们有一个ApiService供我们使用，但是获取定义与我们需要的签名不匹配:</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nc"><img src="../Images/66d7da8178104f931bd992d20935041c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wMA-I_Cu6Q_PooIp5WvKsw.png"/></div></div></figure><p id="8c33" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我们需要在这里执行两项更改:</p><ul class=""><li id="558e" class="mf mg iq ky b kz lu ld lv lh mh ll mi lp mj lt mk ml mm mn bi translated">删除路线参数</li><li id="e838" class="mf mg iq ky b kz mo ld mp lh mq ll mr lp ms lt mk ml mm mn bi translated">更改错误类型</li></ul><p id="3c49" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">为了删除路由参数，我们可以借用函数式编程中的一些技术，如部分函数或currying。</p><p id="9fb8" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">这里我们将使用部分函数，尽管currying也是一个合理的选择。</p><p id="554d" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">将一个函数部分化就像对编译器说嘿，我知道这个函数的一些参数，我可以马上设置它们，但是其余的参数仍然没有定义，请给我一个只接受这些参数的函数，这样我以后就可以调用它了！</p><p id="f0cd" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">让我们看一个例子😏。</p><p id="1146" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">dumbFunction是一个接受两个参数并返回一个布尔值的函数。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nd"><img src="../Images/94b57442c8ab091d6ba9996a13de84ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mQIzwndvp3LdIjJIId1c3A.png"/></div></div></figure><p id="59cb" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我们可以将该函数部分化，以便能够冻结第一个参数，并返回一个只接受第二个参数的函数。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ne"><img src="../Images/0da35224bdc44a41c3246eaa9f893e30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o7IrAASRM93HvqtAaNm5fA.png"/></div></div></figure><p id="084f" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">现在，我们可以使用只有一个参数的部分化对应函数，而不是使用带有两个参数的函数“dumbFunction”</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nf"><img src="../Images/e5a19b2b01404faa7df5f65c2c4a60ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KRdEMGwhpnWLqq61G9jZxA.png"/></div></div></figure><p id="ee15" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">这有点像如果我们执行了第一个参数的依赖注入，部分化已经捕获了它。</p><p id="ecc1" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">当然，我们不能为代码库中的每个函数编写一个局部化的版本。有一种方法可以使它具有任意数量的参数。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ng"><img src="../Images/95107f1cc31fd67ce1b4efd5cbdf88ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hTeDUR18NqDijVXsQju2ew.png"/></div></div></figure><p id="be70" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我们可以根据需要编写任意多版本的部分函数。</p><p id="8603" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">你明白我在说什么吗？我们从有两个参数的函数变成了只有一个参数的函数。然后，我们可以从一个有参数的函数到一个没有参数的函数！</p><p id="3231" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">让我们回到<em class="nh"> ApiService.fetch </em>函数，并对其应用部分化:</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ni"><img src="../Images/e65a53eada291bffdfadac79d805c2d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IBv4Klq8KRqeT_-c6gcV3w.png"/></div></div></figure><p id="ced1" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我们现在有一个带有签名的部分化函数:</p><p id="8d5f" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky ir">()-&gt;any publisher&lt;【User】，ApiError &gt; </strong>，路线参数已被部分化捕获，将在执行<strong class="ky ir">部分化功能时使用。</strong></p><p id="269f" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我们就快成功了，我们需要做的就是隐藏ApiError，幸运的是，Combine可以帮助我们:</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nj"><img src="../Images/5db00612984705a4a50f85d4d01086ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6w_HaZ0RcoJTjTkN3YkOBA.png"/></div></div></figure><p id="141a" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我们有我们的依赖！retrieveUsersFunction函数签名如下:</p><p id="b892" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky ir"> () - &gt; AnyPublisher &lt;【用户】，Swift。&gt;错误</strong></p><p id="5d19" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我们可以在<em class="nh"> Users.load </em>函数中注入它👌。</p><h1 id="a127" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">总结</h1><h2 id="6ad6" class="nk jz iq bd ka nl nm dn ke nn no dp ki lh np nq km ll nr ns kq lp nt nu ku nv bi translated">1:使用函数作为依赖项:</h2><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/da63e42bd73e63a8386b53c40a52797e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kzxRg5h8dYvf1dDtTSK2Gw.png"/></div></div></figure><h2 id="f60a" class="nk jz iq bd ka nl nm dn ke nn no dp ki lh np nq km ll nr ns kq lp nt nu ku nv bi translated">2:使用部分化来建立依赖关系:</h2><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nj"><img src="../Images/5db00612984705a4a50f85d4d01086ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6w_HaZ0RcoJTjTkN3YkOBA.png"/></div></div></figure><h2 id="0f58" class="nk jz iq bd ka nl nm dn ke nn no dp ki lh np nq km ll nr ns kq lp nt nu ku nv bi translated">3:注入依赖性</h2><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nw"><img src="../Images/bb63b73a7e1ef8d940a8876df5e4329c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o-P2ItdwAG2_ZCaxTU8A_A.png"/></div></div></figure><p id="82ea" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">最微妙的部分是第二部分，因为它需要一些管道和样板文件，但它应该被隔离在代码中专门用于依赖注入的特定区域，例如Swinject程序集。</p><h1 id="19c9" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">结论</h1><p id="73c3" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">尽管注入传统的数据结构非常好，并且符合最佳实践，但是注入函数有两个主要好处:</p><ul class=""><li id="5b25" class="mf mg iq ky b kz lu ld lv lh mh ll mi lp mj lt mk ml mm mn bi translated">这让我们重新认识到泄露实现细节是多么容易，以及我们如何避免它。我们对依赖关系了解得越少越好。我想这完美地说明了德米特里定律</li><li id="7140" class="mf mg iq ky b kz mo ld mp lh mq ll mr lp ms lt mk ml mm mn bi translated">这使得单元测试更容易编写、阅读和推理</li></ul><p id="f37c" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">到处使用函数可能会有一些不愉快的方面，比如使签名难以阅读。但这是我们可以通过使用typealiases轻松解决的问题。</p><p id="1a06" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">到处使用函数也打开了函数式编程的大门。我们品尝了它的部分，但这是一个全新的世界，你应该轻轻地探索。</p><p id="ad2c" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">感谢阅读。当然，也可以随意评论，敬请关注。</p><h1 id="b9d5" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">奖励:Swinject和函数的注入</h1><p id="4640" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">Swinject是Swift社区中一个完善的依赖注入框架。它用于注册和解析配方以构建您的依赖项。但是注册和解析函数呢？</p><p id="ef51" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">没有什么比另一个<strong class="ky ir"> (String) - &gt; String </strong>函数更像一个<strong class="ky ir"> (String) - &gt; String </strong>函数了吧！</p><p id="ea95" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">如果我们需要解析一个已经用同一个签名注册了几次的函数，会发生什么？</p><p id="8169" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">Swinject提供了一种通过使用唯一名称来区分注册服务的方法。如果我们想在我们的<strong class="ky ir"> (String) - &gt; String </strong>案例中使用它，我们将得到类似这样的结果:</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nx"><img src="../Images/739f71adb22e80ff86439470938080ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RB3rQR9u0uE2NIuY_bJjbw.png"/></div></div></figure><p id="0184" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">说到解决问题:</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ny"><img src="../Images/696b8084a3327339e6c466c97b2d7ecb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t0N-mN44sBS2jI8RYWBX7A.png"/></div></div></figure><p id="706d" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">虽然这没有什么错，但读起来有点难看。我们可以用一个将函数签名和它的名字分组的协议来改进这一点:</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nz"><img src="../Images/b35469a58b060d7325ecf1e8dcc39596.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*unbIo6QXzhTl19zSR-rQCQ.png"/></div></div></figure><p id="0e35" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">至此，Swinject程序集现在变成了:</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oa"><img src="../Images/1fefa77c219e607b05fba66d56526c6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G8JG4EoJ0zKn62-fmKHo3Q.png"/></div></div></figure><p id="ed93" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">说到解决问题:</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ni"><img src="../Images/55b1a713a22520b445b10259f7cd8cf5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rZkHzWfpySzmn54OBLZ1fA.png"/></div></div></figure><p id="8358" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">即使我们在这方面没有赢得太多，我们也让函数注册/解析看起来像任何传统的数据结构用法。它消除了注入函数中的一个痛点，这个痛点可能会阻止您尝试这种技术😏。</p></div></div>    
</body>
</html>