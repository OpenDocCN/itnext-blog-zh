<html>
<head>
<title>How to Refactor Ruby on Rails Controllers Using Blocks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用块重构Ruby on Rails控制器</h1>
<blockquote>原文：<a href="https://itnext.io/refactoring-ruby-on-rails-controllers-using-blocks-bf78b1b292ca?source=collection_archive---------3-----------------------#2019-07-31">https://itnext.io/refactoring-ruby-on-rails-controllers-using-blocks-bf78b1b292ca?source=collection_archive---------3-----------------------#2019-07-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="a4f3" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">重构</h2><div class=""/><div class=""><h2 id="436e" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">使用服务对象和成功或失败模块来帮助您编写可维护的ruby on rails控制器</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/dd6fc3418cc8425123acfd018ef66f2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tHubC0dgQdr_66PhoOPkPQ.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">Francisco Jacquier 在<a class="ae lh" href="https://unsplash.com/search/photos/lego?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的背景照片</figcaption></figure><h1 id="59ad" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">什么是服务对象？</h1><p id="a1be" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">简单地说，它是一个普通的ruby对象，只有一个用途。就像一把椅子。它只能让人坐在上面。句号。这有很多原因。它使任何人都更容易理解它做什么，同时也使编写测试更容易。</p><blockquote class="mw mx my"><p id="7498" class="ma mb mz mc b md na kd mf mg nb kg mi nc nd ml mm ne nf mp mq ng nh mt mu mv im bi translated">I <!-- --> nsight:我在编写可维护代码的这些年中学到的一件事是，通过将软件开发世界中的对象与现实世界中的对象联系起来，可以更好地理解和编写这些对象。就像你不希望你的电炉顶也作为你的办公桌(火灾隐患！)，创建只为单一目的服务的对象才有意义。</p></blockquote><p id="dc00" class="pw-post-body-paragraph ma mb it mc b md na kd mf mg nb kg mi mj nd ml mm mn nf mp mq mr nh mt mu mv im bi translated">下面是一个简单的ruby服务对象类的例子，它只创建帖子。我们将进一步阐述这一点，以展示我们如何利用这个简单的类，使用成功或失败块来重构您的rails控制器。</p><pre class="ks kt ku kv gt ni nj nk bn nl nm bi"><span id="c9d2" class="nn lj it nj b be no np l nq nr">class CreatePost<br/>  attr_reader :subject, :body<br/>  def initialize(subject:,body:)<br/>    @subject = subject<br/>    @body    = body<br/>  end<br/>  <br/>  def call<br/>    Post.create!({ subject: subject, body: body })<br/>  end<br/>end</span></pre><blockquote class="mw mx my"><p id="df43" class="ma mb mz mc b md na kd mf mg nb kg mi nc nd ml mm ne nf mp mq ng nh mt mu mv im bi translated">提示:尽量总是用动词来命名服务对象(例如，创建、构建、更新等)。)它迫使你专注于对象的动作和目的。也使得任何人都很难添加不属于那里的业务逻辑。</p></blockquote><h1 id="4e80" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">为什么是服务对象？</h1><p id="b6a9" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">封装业务逻辑，同时保持它与Rails框架的其余部分隔离，使它成为一个组件，您可以在应用程序中的其他地方重用它。假设您需要在您的控制器和API端点中应用相同的业务逻辑，您可以重用相同的服务对象，并自由决定您希望如何响应请求(即，在您的控制器中，您可以重定向用户，而在您的API端点中，您可以发送回JSON响应)</p><p id="1050" class="pw-post-body-paragraph ma mb it mc b md na kd mf mg nb kg mi mj nd ml mm mn nf mp mq mr nh mt mu mv im bi translated">此外，它使得测试您的业务逻辑更加容易，因为您不必为控制器或API设置任何额外的开销来测试业务逻辑。</p><p id="8835" class="pw-post-body-paragraph ma mb it mc b md na kd mf mg nb kg mi mj nd ml mm mn nf mp mq mr nh mt mu mv im bi translated">事不宜迟，让我们直接进入成功或失败模块。</p><h1 id="d011" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">臃肿的控制器动作</h1><p id="2c47" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">下面是一个包含业务逻辑的控制器操作的简单示例，我们稍后可以将其重构为服务对象:</p><pre class="ks kt ku kv gt ni nj nk bn nl nm bi"><span id="12e2" class="nn lj it nj b be no np l nq nr">class PostsController &lt; ApplicationController<br/>  def create<br/>    @post = Post.new(post_params)<br/>    if @post.save<br/>      send_email<br/>      track_activity<br/>      redirect_to posts_path, notice: 'Successfully created post.'<br/>    else<br/>      render :new<br/>    end<br/>  end<br/>end</span></pre><h1 id="9628" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">成败阻碍救援</h1><p id="f987" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">我第一次遇到这种技术是在窥视“<a class="ae lh" href="https://github.com/activeadmin/inherited_resources" rel="noopener ugc nofollow" target="_blank">inherited _ resources</a>”gem的时候。我感兴趣的是关于如何使用成功或失败块来覆盖默认的继承资源操作的部分。以下是来自<a class="ae lh" href="https://github.com/activeadmin/inherited_resources#overwriting-actions" rel="noopener ugc nofollow" target="_blank">自述文件</a>的片段:</p><pre class="ks kt ku kv gt ni nj nk bn nl nm bi"><span id="a505" class="nn lj it nj b be no np l nq nr">class ProjectsController &lt; InheritedResources::Base<br/>  def update<br/>    update! do |success, failure|<br/>      failure.html { redirect_to project_url(@project) }<br/>    end<br/>  end<br/>end</span></pre><p id="f4f4" class="pw-post-body-paragraph ma mb it mc b md na kd mf mg nb kg mi mj nd ml mm mn nf mp mq mr nh mt mu mv im bi translated">下面是代码所做工作的高级概述。当对项目资源进行更新时，如果更新失败，它将通过重定向到项目资源的显示页面来调用失败响应。但是，如果更新成功，它将默认为重定向到项目索引页面的正常流程(这就是默认情况下继承的资源所做的)。在封装业务逻辑的同时，允许我们控制对每一个成功和失败的场景做什么有助于简化我们的控制器逻辑。</p><p id="15e2" class="pw-post-body-paragraph ma mb it mc b md na kd mf mg nb kg mi mj nd ml mm mn nf mp mq mr nh mt mu mv im bi translated">让我们使用我们之前的服务对象示例，通过一些调整，使用更简化的实现逻辑(与在<a class="ae lh" href="https://github.com/activeadmin/inherited_resources/blob/master/lib/inherited_resources/base_helpers.rb#L257" rel="noopener ugc nofollow" target="_blank">继承资源</a>中使用的逻辑相比)来实现相同的结果</p><p id="4f94" class="pw-post-body-paragraph ma mb it mc b md na kd mf mg nb kg mi mj nd ml mm mn nf mp mq mr nh mt mu mv im bi translated">这是我们的控制器动作的重构版本，以及服务对象和实现这一点所必需的其他类。</p><pre class="ks kt ku kv gt ni nj nk bn nl nm bi"><span id="9ff1" class="nn lj it nj b be no np l nq nr"># app/controllers/posts_controller.rb<br/>class PostsController &lt; ApplicationController<br/>  def create<br/>    @post = Post.new(post_params)<br/>    CreatePost.call(@post) do |success, failure|<br/>      success.call { redirect_to posts_path, notice: 'Successfully created post.' }<br/>      failure.call { render :new }<br/>    end<br/>  end<br/>end<br/><br/># app/services/create_post.rb<br/>class CreatePost<br/>  attr_reader :post<br/><br/>  def self.call(post, &amp;block)<br/>    new(post).call(&amp;block)<br/>  end<br/><br/>  def initialize(post)<br/>    @post = post<br/>  end<br/>  private_class_method :new<br/><br/>  def call(&amp;block)<br/>    if post.save<br/>      send_email<br/>      track_activity<br/>      yield(Trigger, NoTrigger)<br/>    else<br/>      yield(NoTrigger, Trigger)<br/>    end<br/>  end<br/><br/>  def send_email<br/>    # Send email to all followers<br/>  end<br/><br/>  def track_activity<br/>    # Track in activity feed<br/>  end<br/>end<br/><br/># app/services/trigger.rb<br/>class Trigger<br/>  def self.call<br/>    yield<br/>  end<br/>end<br/><br/># app/services/no_trigger.rb<br/>class NoTrigger<br/>  def self.call<br/>    # Do nothing<br/>  end<br/>endThe CreatePost#call instance method (line 25) essentially accepts a block of code with success and failure as arguments (Line 5)</span></pre><p id="c432" class="pw-post-body-paragraph ma mb it mc b md na kd mf mg nb kg mi mj nd ml mm mn nf mp mq mr nh mt mu mv im bi translated">我们可以传递一个<code class="fe ns nt nu nj b">Trigger</code>或<code class="fe ns nt nu nj b">NoTrigger</code>类对象作为<code class="fe ns nt nu nj b">success</code>参数。如果给<code class="fe ns nt nu nj b">success</code>参数一个<code class="fe ns nt nu nj b"> Trigger</code>类，那么将产生给<code class="fe ns nt nu nj b">success.call</code>的块，它将用户请求重定向到posts索引页面以及一个成功通知。然而，如果<code class="fe ns nt nu nj b">success</code>参数被赋予一个<code class="fe ns nt nu nj b">NoTrigger</code>类，赋予它的块将不会被调用，因为<code class="fe ns nt nu nj b">NoTrigger.call</code>类方法什么也不做。这整个逻辑也适用于<code class="fe ns nt nu nj b">failure</code>参数。</p><p id="f0f0" class="pw-post-body-paragraph ma mb it mc b md na kd mf mg nb kg mi mj nd ml mm mn nf mp mq mr nh mt mu mv im bi translated">你不喜欢积木吗？</p><h1 id="052c" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">额外资源</h1><p id="6b4c" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">Blocks、procs和lambdas可能有些令人困惑，但是当你最终掌握这个概念时，它们可以成为一个非常强大和灵活的工具，帮助你编写更简单和更好的代码。如果您想了解更多信息，这里有一些有用的资源:</p><ul class=""><li id="6bea" class="nv nw it mc b md na mg nb mj nx mn ny mr nz mv oa ob oc od bi translated"><a class="ae lh" href="https://blog.appsignal.com/2018/09/04/ruby-magic-closures-in-ruby-blocks-procs-and-lambdas.html" rel="noopener ugc nofollow" target="_blank">https://blog . app signal . com/2018/09/04/ruby-magic-closures-in-ruby-blocks-procs-and-lambdas . html</a></li><li id="caba" class="nv nw it mc b md oe mg of mj og mn oh mr oi mv oa ob oc od bi translated"><a class="ae lh" href="https://www.rubyguides.com/2016/02/ruby-procs-and-lambdas/" rel="noopener ugc nofollow" target="_blank">https://www.rubyguides.com/2016/02/ruby-procs-and-lambdas/</a></li><li id="0de0" class="nv nw it mc b md oe mg of mj og mn oh mr oi mv oa ob oc od bi translated">https://pragprog.com/book/btrubyclo/mastering-ruby-closures<a class="ae lh" href="https://pragprog.com/book/btrubyclo/mastering-ruby-closures" rel="noopener ugc nofollow" target="_blank"/></li></ul></div><div class="ab cl oj ok hx ol" role="separator"><span class="om bw bk on oo op"/><span class="om bw bk on oo op"/><span class="om bw bk on oo"/></div><div class="im in io ip iq"><p id="4e3b" class="pw-post-body-paragraph ma mb it mc b md na kd mf mg nb kg mi mj nd ml mm mn nf mp mq mr nh mt mu mv im bi translated">希望你喜欢读我的文章。我热爱重构代码，希望以后能分享更多的重构技巧。像往常一样，如果你有任何可以帮助我改进帖子的反馈或建议，请随时发表评论。</p><p id="69f7" class="pw-post-body-paragraph ma mb it mc b md na kd mf mg nb kg mi mj nd ml mm mn nf mp mq mr nh mt mu mv im bi translated">下次见。干杯。</p></div></div>    
</body>
</html>