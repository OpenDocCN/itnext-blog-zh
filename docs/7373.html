<html>
<head>
<title>Understanding the Visual Studio Docker FastMode integration</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解Visual Studio Docker快速模式集成</h1>
<blockquote>原文：<a href="https://itnext.io/understanding-the-visual-studio-docker-fastmode-integration-c0bccc08b8f9?source=collection_archive---------0-----------------------#2022-09-04">https://itnext.io/understanding-the-visual-studio-docker-fastmode-integration-c0bccc08b8f9?source=collection_archive---------0-----------------------#2022-09-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div class="gh gi ir"><img src="../Images/9fd6889977b61b764a713f0052bc5524.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/format:webp/1*e8u6teTHyalPejIBauj4Jw.png"/></div></figure><div class=""/><p id="ca92" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">任何IDE中我最喜欢的特性之一就是无缝Docker如何与。NET)项目。它最大的优点是在一个隔离的、可复制的环境中运行一个应用程序是多么简单。如果你正确地坚持下去，所有那些“在我的机器上工作”的问题都将成为过去。</p><p id="99d8" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">当您创建一个简单的控制台应用程序时，您只需右键单击该项目，“添加-&gt; Docker支持”，VS将为您生成一个Docker文件。如果您现在运行Docker启动配置，VS将为您构建一个映像，您可以运行和调试项目，而无需任何额外的工作。(我将在另一篇文章中介绍docker-compose集成)</p><p id="621b" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在我看来，VS已经钉死了这个特性。VS为你做的工作量是惊人的。看起来没什么大不了的，但是VS并不是简单地构建docker文件并运行它，它使用了许多聪明的技巧来保持构建的速度。此外，VS还在上面添加了一个调试器。这听起来很简单，但是你需要记住，docker容器只不过是一台远程机器，如果你曾经手动设置过远程调试，你肯定知道为什么你应该对此心存感激。</p><p id="0d86" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在这篇文章中，我想讨论和研究Docker集成的所有特性，尤其是它的快速性。有一堆很酷的技巧要学，关于Docker和。网！</p><h1 id="9981" class="kv kw ja bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">Docker快速模式</h1><p id="7562" class="pw-post-body-paragraph jx jy ja jz b ka lt kc kd ke lu kg kh ki lv kk kl km lw ko kp kq lx ks kt ku im bi translated">“Fastmode”是围绕快速调试容器中的软件而构建的整个设置的名称。</p><p id="c077" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">让我们从Linux容器的docker文件开始:</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="a388" class="mh kw ja md b gy mi mj l mk ml">#See <a class="ae mm" href="https://aka.ms/containerfastmode" rel="noopener ugc nofollow" target="_blank">https://aka.ms/containerfastmode</a> to understand how Visual Studio uses this Dockerfile to build your images for faster debugging.</span><span id="ca80" class="mh kw ja md b gy mn mj l mk ml">FROM mcr.microsoft.com/dotnet/runtime:6.0 AS base<br/>WORKDIR /app</span><span id="8ae8" class="mh kw ja md b gy mn mj l mk ml">FROM mcr.microsoft.com/dotnet/sdk:6.0 AS build<br/>WORKDIR /src<br/>COPY ["DockerSample/DockerSample.csproj", "DockerSample/"]<br/>RUN dotnet restore "DockerSample/DockerSample.csproj"<br/>COPY . .<br/>WORKDIR "/src/DockerSample"<br/>RUN dotnet build "DockerSample.csproj" -c Release -o /app/build</span><span id="71d4" class="mh kw ja md b gy mn mj l mk ml">FROM build AS publish<br/>RUN dotnet publish "DockerSample.csproj" -c Release -o /app/publish /p:UseAppHost=false</span><span id="c9ae" class="mh kw ja md b gy mn mj l mk ml">FROM base AS final<br/>WORKDIR /app<br/>COPY --from=publish /app/publish .<br/>ENTRYPOINT ["dotnet", "DockerSample.dll"]</span></pre><p id="e2e3" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">如果你不熟悉这个Dockerfile设置:它被称为多阶段构建。每个FROM指令都会添加一个具有潜在不同基础图像的新图层。在这个具体的例子中，我们创建了一个运行时映像作为“基础”，以及一个“构建”映像。构建映像将接收所需的文件和nuget恢复，然后dotnet构建项目。之后，我们进行网络发布。发布映像的工件将被复制到运行时映像。</p><p id="c78c" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">结果是一个运行时映像，其中复制了剥离下来的工件。我们没有保留sdk映像，所以生成的映像要小得多。在最后一幅图像上，我们将入口点设置为“dotnet DockerSample.dll ”,以便启动应用程序。</p><p id="1e62" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">然而，当在“调试”模式下构建项目时，您会注意到“容器工具”输出在构建阶段后停止，除非另外配置。</p><p id="15b0" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">因此，目前我们所拥有的只是一个dotnet运行时映像，里面没有任何东西。</p><p id="bcab" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">您还会注意到该项目是在本地构建的。如果我们的项目是使用dotnet build在一个容器上构建的，那么所有的工件都将驻留在您的容器上，而不是您的主机上。然而，在我们的例子中,/bin和/obj文件夹将在您的主机上结束，所以没有在容器上进行构建。</p><p id="2e28" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在容器工具的后续步骤中，您可以看到Visual Studio下载(并确保)GetVsDbg.ps1脚本，该脚本下载VsDbg调试实用工具。但是，它不会被下载到任何容器中，而是在您的主机上。</p><p id="7acc" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">建立了容器和vsdbg之后，下一步将会把整个设置粘在一起。在容器工具中，您可以看到该命令。</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="3cb3" class="mh kw ja md b gy mi mj l mk ml">docker run -dt -v "C:\Users\...\vsdbg\vs2017u5:/remote_debugger:rw" -v "D:\...\DockerSample\DockerSample:/app" -v "D:\...\DockerSample:/src/" -v "C:\Users\...\.nuget\packages\:/root/.nuget/fallbackpackages" -v "D:\Programs\VS2022\Components\NuGetPackages:/root/.nuget/fallbackpackages2" -e "DOTNET_USE_POLLING_FILE_WATCHER=1" -e "NUGET_PACKAGES=/root/.nuget/fallbackpackages" -e "NUGET_FALLBACK_PACKAGES=/root/.nuget/fallbackpackages;/root/.nuget/fallbackpackages2" --name DockerSample --entrypoint tail dockersample:dev -f /dev/null</span></pre><p id="41f5" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">要解开的东西太多了，但让我们一步一步来看:</p><ol class=""><li id="75bd" class="mo mp ja jz b ka kb ke kf ki mq km mr kq ms ku mt mu mv mw bi translated">“docker run -dt”将运行一个带有伪终端的分离容器</li><li id="c303" class="mo mp ja jz b ka mx ke my ki mz km na kq nb ku mt mu mv mw bi translated">下一个卷装载循环回到之前运行的Vsdbg步骤。这是远程调试器，我们现在通过使用卷挂载将它传递到容器上。</li><li id="f099" class="mo mp ja jz b ka mx ke my ki mz km na kq nb ku mt mu mv mw bi translated">现在，我们将安装驻留在主机上的构建工件。</li><li id="ef47" class="mo mp ja jz b ka mx ke my ki mz km na kq nb ku mt mu mv mw bi translated">下一步—将Nuget包添加到容器中。注意到我们是如何通过简单地挂载和镜像所有已经可用的东西来慢慢构建一个与你的设备非常相似的环境的吗？</li><li id="ec24" class="mo mp ja jz b ka mx ke my ki mz km na kq nb ku mt mu mv mw bi translated">在所有挂载都完成后，将设置一些环境变量，尤其重要的是NUGET_PACKAGES和NUGET_FALLBACK_PACKAGES，它们是全局环境变量，用于将nuget cli指向它可以从中获取相应包的文件夹。</li><li id="291d" class="mo mp ja jz b ka mx ke my ki mz km na kq nb ku mt mu mv mw bi translated">使用“tail”命令运行容器。</li></ol><p id="9aa7" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">如果我们在相应的容器上运行“docker inspect <id>”,我们可以看到如下装载，如预期的那样:</id></p><figure class="ly lz ma mb gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi nc"><img src="../Images/8cc89478b543ed407bfccad952ba44c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uxw1l7R-5p5k9-n7CYdXxw.png"/></div></div></figure><p id="448d" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">好了，现在我们有了一个正在运行的容器，其中有很多先决条件，但是由于tail命令，它基本上只是在空转。</p><p id="1d6b" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">一旦我们在Visual Studio中按下F5，接下来就会发生。此时，VS Docker集成将继续进行，并检查容器id。</p><p id="e567" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">一旦获得ID，VS将运行以下命令:</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="ee41" class="mh kw ja md b gy mi mj l mk ml">docker exec -i {containerId} dotnet DockerSample.dll</span></pre><p id="b323" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">就是这样！由于我们所做的所有卷安装，VS已经在我们的容器上启动了应用程序。</p><p id="d3f1" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">除了启动应用程序之外，VS现在还可以连接到我们放在容器上的vsdbg应用程序，并启动一个调试会话。</p><p id="0477" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这就是当你在Visual Studio中对Docker项目按F5键时，我们最终得到的结果。</p><p id="3ad1" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这比最初听起来要多得多！</p><h1 id="b091" class="kv kw ja bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">逮到你了</h1><p id="63c9" class="pw-post-body-paragraph jx jy ja jz b ka lt kc kd ke lu kg kh ki lv kk kl km lw ko kp kq lx ks kt ku im bi translated">有一些关于整个设置的问题，知道这些是很有用的。</p><ul class=""><li id="9934" class="mo mp ja jz b ka kb ke kf ki mq km mr kq ms ku nh mu mv mw bi translated">您的应用程序不会进行任何热重新加载，一旦您希望看到更改，就需要重新启动</li><li id="1c2d" class="mo mp ja jz b ka mx ke my ki mz km na kq nb ku nh mu mv mw bi translated">在你停止调试后，容器仍然会运行<strong class="jz jb">！但是，一旦您停止了Visual Studio中的调试会话，您的应用程序也将停止。</strong></li><li id="dadd" class="mo mp ja jz b ka mx ke my ki mz km na kq nb ku nh mu mv mw bi translated">在“发布”模式下，这些神奇的事情都不会发生，取而代之的是，docker文件会定期构建。</li></ul><p id="c183" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">总而言之，Visual Studio做得很好，为我们做了所有这些事情。</p><p id="3a93" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在另一篇文章中，我将研究VS如何与集成的docker-compose fastmode一起工作，这是另一个魔术！</p></div></div>    
</body>
</html>