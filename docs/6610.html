<html>
<head>
<title>How does a middleware pipeline implementation look like?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">中间件管道实现看起来像什么？</h1>
<blockquote>原文：<a href="https://itnext.io/how-does-a-middleware-pipeline-implementation-look-like-ceffc1129093?source=collection_archive---------4-----------------------#2022-01-04">https://itnext.io/how-does-a-middleware-pipeline-implementation-look-like-ceffc1129093?source=collection_archive---------4-----------------------#2022-01-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div class="gh gi ir"><img src="../Images/75c2b1f8da88a7bb8f734b80abb4d9df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/format:webp/1*0piCvPwbgTnP4mCWOfCgXw.jpeg"/></div></figure><div class=""/><p id="c0eb" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">今天我通读了Asp.Net中间件管道文档，通读过程中，我对<em class="kv">如何</em>使用管道的解释感到满意，但另一方面，我真的很好奇这样一个管道的实现会是什么样子。</p><p id="1fd3" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">你知道，使用一些东西是等式的一部分，但是你自己建造它并正确理解正在发生的事情会更好地促进理解。</p><p id="c860" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><strong class="jz jb">什么是中间件管道？</strong></p><p id="9b6e" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">通过下图，中间件管道非常容易理解:</p><figure class="kx ky kz la gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="gh gi kw"><img src="../Images/7d0420ba178bf8a194670af5ac9f7fac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*acRJQL67faS2dlAOWZFP_w.png"/></div></div></figure><p id="1c5b" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">整个管道由<strong class="jz jb"> n </strong>个中间件组成，通常有一个输入和一个输出。每个中间件可以对输入执行工作，或者基于输入执行工作，然后用相同的参数调用下一个中间件。</p><p id="42b4" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">然而，中间件也可以决定不将调用委托给下一步。想象一下Asp.Net核心中间件，它处理模型绑定、路由、安全等等。如果路由中间件确定没有匹配的路由，它可能会使管道短路，并立即返回。</p><p id="145e" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">那么，这在代码中是什么样子的呢？</p><p id="225c" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">通常，如果你只是简单地使用一个中间件，例如在Asp.Net核心中，你会继续添加<strong class="jz jb">应用。在你的启动中使用((ctx，next) = &gt; …) </strong>。</p><p id="34a0" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">然而，我们希望从头开始构建我们自己的“基本”中间件管道。</p><p id="0d25" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">首先，让我们定义一个我们希望通过管道拖动的简单上下文:</p><pre class="kx ky kz la gt lf lg lh li aw lj bi"><span id="675f" class="lk ll ja lg b gy lm ln l lo lp">public class Context<br/>{<br/>    public int CurrentUserId { get; set; }<br/>    public string DynamicString { get; set; }<br/>}</span></pre><p id="1e61" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">很简单。</p><p id="7a45" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">接下来，我们已经进入正题了。我们需要定义一个委托，我们期望我们的中间件处理程序来完成这个委托。我们的委托应该返回一个任务，以允许实现者轻松地使用异步。对于参数，委托应该明确地接收上下文以在管道中拖动，以及在需要时调用的“<em class="kv"> next </em>”回调。这也可以通过<em class="kv">功能&lt;来完成。&gt; </em>，我决定定义一个合适的委托来增强最终产品的可读性。这是我们的代表:</p><pre class="kx ky kz la gt lf lg lh li aw lj bi"><span id="1a2e" class="lk ll ja lg b gy lm ln l lo lp">public delegate Task MiddlewareDelegate(Context context, Func&lt;Task&gt; next);</span></pre><p id="2515" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">太棒了。既然我们有了管道的粗略异常值，现在我们需要构建“管道”本身。为此，我们希望有一个小的provider类来存储所有的回调，并允许注册和最终执行整个设置。</p><pre class="kx ky kz la gt lf lg lh li aw lj bi"><span id="3ff3" class="lk ll ja lg b gy lm ln l lo lp">public class BasicMiddlewareProvider<br/>{<br/>    private readonly Queue&lt;MiddlewareDelegate&gt; _middleWares = new();</span><span id="eec8" class="lk ll ja lg b gy lq ln l lo lp">    public BasicMiddlewareProvider Use(MiddlewareDelegate step)<br/>    {<br/>        _middleWares.Enqueue(step);<br/>        return this;<br/>    }</span><span id="b300" class="lk ll ja lg b gy lq ln l lo lp">    public async Task Run(Context context)<br/>    {<br/>        if (_middleWares.Any())<br/>        {<br/>            await RunInternal(context);<br/>        }<br/>    }</span><span id="cf07" class="lk ll ja lg b gy lq ln l lo lp">    private async Task RunInternal(Context context)<br/>    {<br/>        if (_middleWares.TryDequeue(out var middleware))<br/>        {<br/>            await middleware(context, () =&gt; RunInternal(context));<br/>        }<br/>    }<br/>}</span></pre><p id="ffbd" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">一点一点地看，我们有几个兴趣点。</p><ol class=""><li id="87de" class="lr ls ja jz b ka kb ke kf ki lt km lu kq lv ku lw lx ly lz bi translated">首先，我们有一个MiddlewareDelegates队列。这就是我前面提到的，我们需要将注册的代表存储在某个地方。队列在这里是一个很好的数据结构，因为中间件注册的自然流程是基于入队的顺序执行的。但是，如果应该重用提供程序，列表可能会更好，因为不会从列表中删除项目。</li><li id="1669" class="lr ls ja jz b ka ma ke mb ki mc km md kq me ku lw lx ly lz bi translated">接下来，我们的注册方法，叫做“使用”。这只是将中间件放入队列中，为了使它成为一个流畅的API(稍后您将看到这一点)，我们返回<em class="kv"> this。</em></li><li id="78bd" class="lr ls ja jz b ka ma ke mb ki mc km md kq me ku lw lx ly lz bi translated"><em class="kv"> Run </em>方法是有趣的地方。这开始了我们管道的实际执行。显然，只有当至少注册了一个中间件时，才会出现这种情况。</li><li id="439c" class="lr ls ja jz b ka ma ke mb ki mc km md kq me ku lw lx ly lz bi translated"><em class="kv"> RunInternal </em>从将第一个中间件代理从队列中取出开始。我们现在调用这个中间件，向它传递上下文，以及一个回调，该回调再次递归调用<em class="kv"> RunInternal </em>。现在，执行一个中间件步骤，一旦它调用回调，我们就让下一个中间件出队。这种情况一直发生，直到我们的队列为空，我们的管道完成——太好了！否则，如果没有调用回调，我们也将简单地到达方法的结尾，并停止执行。</li></ol><p id="4ddf" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这基本上就是所有的魔法了！使用它相当简单:</p><pre class="kx ky kz la gt lf lg lh li aw lj bi"><span id="adaa" class="lk ll ja lg b gy lm ln l lo lp">await new BasicMiddlewareProvider()<br/> .Use(async (ctx, next) =&gt;<br/> {<br/>  ctx.DynamicString = "Hello World";<br/>  await next();<br/> })<br/> .Use(async (ctx, next) =&gt;<br/> {<br/>  if (ctx.DynamicString == "Hello World")<br/>  {<br/>   Console.WriteLine("Hello World indeed");<br/>  }</span><span id="0229" class="lk ll ja lg b gy lq ln l lo lp">await next();<br/> })<br/> .Use((_, _) =&gt;<br/> {<br/>  Console.WriteLine("Let's stop here");<br/>  return Task.CompletedTask;<br/> })<br/> .Use((_, _) =&gt;<br/> {<br/>  Console.WriteLine("Do I still live?");<br/>  return Task.CompletedTask;<br/> })<br/> .Run(new Context());</span><span id="17bc" class="lk ll ja lg b gy lq ln l lo lp">// Output:<br/>Hello World indeed<br/>Let's stop here</span></pre><p id="0048" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这就是流畅API的回报所在——我们可以在这里进行连锁注册。如您所见，第一步执行，并将属性设置为“Hello World”。由于该步骤调用了<em class="kv">下一个</em>回调，我们继续第二个回调(这是我们让下一个中间件出列的地方)。由于“Hello World really”打印出来，我们还可以验证传递的上下文确实是我们在前面的步骤中修改的那个。太好了！</p><p id="21ca" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在下一步中，我们决定只打印一些东西，然后返回一个完成的任务。如您所见，我们再次使用<strong class="jz jb">而不是</strong>调用next，因此在这里停止了链——下一个打印没有发生。</p><p id="676b" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">毕竟，这是一个非常简单的管道，但它应该传达出正在发生的事情的大致想法。唯一神奇的步骤是传递一个回调来继续这个链。</p><p id="c77d" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><strong class="jz jb">如果我需要更多的输入怎么办？</strong></p><p id="b0d8" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">委托回调很好，但有时您需要更严格的类型。幸运的是，将整个设置移植到一个界面非常容易。</p><pre class="kx ky kz la gt lf lg lh li aw lj bi"><span id="eabc" class="lk ll ja lg b gy lm ln l lo lp">public interface IMiddleware<br/>{<br/>    Task Execute(Context context, Func&lt;Task&gt; next);<br/>}</span><span id="cb26" class="lk ll ja lg b gy lq ln l lo lp">public class ConcreteMiddleware : IMiddleware<br/>{<br/>    private readonly int _newContextValue;</span><span id="451e" class="lk ll ja lg b gy lq ln l lo lp">    public ConcreteMiddleware(int newContextValue) =&gt; _newContextValue = newContextValue;</span><span id="b63a" class="lk ll ja lg b gy lq ln l lo lp">    public async Task Execute(Context context, Func&lt;Task&gt; next)<br/>    {<br/>        if (context.CurrentUserId == _newContextValue)<br/>        {<br/>            Console.WriteLine($"Typed middleware hit its end - {context.CurrentUserId}");<br/>            return;<br/>        }</span><span id="a087" class="lk ll ja lg b gy lq ln l lo lp">        Console.WriteLine($"Typed middleware CurrentUserId {context.CurrentUserId}");<br/>        context.CurrentUserId = _newContextValue;</span><span id="daf8" class="lk ll ja lg b gy lq ln l lo lp">        await next();<br/>    }<br/>}</span><span id="4463" class="lk ll ja lg b gy lq ln l lo lp">public class TypedMiddlewareProvider<br/>{<br/>    private readonly Queue&lt;IMiddleware&gt; _middlewares = new();</span><span id="edf2" class="lk ll ja lg b gy lq ln l lo lp">    public TypedMiddlewareProvider Use(IMiddleware middleware)<br/>    {<br/>        _middlewares.Enqueue(middleware);<br/>        return this;<br/>    }</span><span id="0a46" class="lk ll ja lg b gy lq ln l lo lp">    public async Task Run(Context context)<br/>    {<br/>        if (_middlewares.Any())<br/>        {  <br/>            await RunInternal(context);<br/>        }<br/>    }</span><span id="f89c" class="lk ll ja lg b gy lq ln l lo lp">    private async Task RunInternal(Context context)<br/>    {<br/>        if (_middlewares.TryDequeue(out var middleware))<br/>        {<br/>            await middleware!.Execute(context, () =&gt; RunInternal(context));<br/>       }<br/>    }<br/>}</span></pre><p id="5195" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">使用起来也非常简单明了:</p><pre class="kx ky kz la gt lf lg lh li aw lj bi"><span id="1fc6" class="lk ll ja lg b gy lm ln l lo lp">await new TypedMiddlewareProvider()<br/> .Use(new ConcreteMiddleware(1))<br/> .Use(new ConcreteMiddleware(2))<br/> .Use(new ConcreteMiddleware(2))<br/> .Use(new ConcreteMiddleware(3))<br/> .Run(new Context());</span><span id="af5f" class="lk ll ja lg b gy lq ln l lo lp">// Output<br/>Typed middleware CurrentUserId 0<br/>Typed middleware CurrentUserId 1<br/>Typed middleware hit its end - 2</span></pre><p id="aeb3" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们再一次看到管道的工作方式是一样的——我们也可以提前返回这里，并且上下文被适当地拖动</p><p id="63a0" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">太棒了。这就是全部内容——理解的关键是深入了解回调设置，但一旦完成，一切就相当容易掌握了。</p><p id="3d67" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">以下是用于示例的代码:<a class="ae mf" href="https://github.com/Sossenbinder/CSharpMiddleWareExample" rel="noopener ugc nofollow" target="_blank">https://github.com/Sossenbinder/CSharpMiddleWareExample</a></p></div></div>    
</body>
</html>