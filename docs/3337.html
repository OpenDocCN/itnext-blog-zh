<html>
<head>
<title>Use HTTP Client Factory with NSwag Generated Classes in ASP.NET Core 3</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在ASP.NET核心3中使用HTTP客户端工厂和NSwag生成的类</h1>
<blockquote>原文：<a href="https://itnext.io/use-http-client-factory-with-nswag-generated-classes-in-asp-net-core-3-c1dd66ee004c?source=collection_archive---------1-----------------------#2019-11-25">https://itnext.io/use-http-client-factory-with-nswag-generated-classes-in-asp-net-core-3-c1dd66ee004c?source=collection_archive---------1-----------------------#2019-11-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="0911" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上周的帖子中，<a class="ae kl" href="https://elanderson.net/2019/11/using-nswag-to-generate-c-client-classes-for-asp-net-core-3/" rel="noopener ugc nofollow" target="_blank">使用NSwag为ASP.NET核心3 </a>生成C#客户端类，我们留下了一个可用的客户端，但我们错过了使用ASP.NET核心提供的一些功能，如<a class="ae kl" href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/http-requests?view=aspnetcore-3.0" rel="noopener ugc nofollow" target="_blank"> HTTP客户端工厂</a>和利用<a class="ae kl" href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection" rel="noopener ugc nofollow" target="_blank">依赖注入</a>。</p><h2 id="e079" class="km kn iq bd ko kp kq dn kr ks kt dp ku jy kv kw kx kc ky kz la kg lb lc ld le bi translated">对NSwag客户端生成的更改</h2><p id="92d9" class="pw-post-body-paragraph jn jo iq jp b jq lf js jt ju lg jw jx jy lh ka kb kc li ke kf kg lj ki kj kk ij bi translated">这篇文章仅仅指出了帮助利用上述ASP.NET核心特性所需的区别，并不是使用NSwag的完整演练。如果你需要这篇文章内容的参考，请确保阅读上周的文章。</p><p id="8ff7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上周的文章中需要做的一个改变是检查<strong class="jp ir">为客户端类</strong>生成接口。</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="gh gi lk"><img src="../Images/c9020aeff27d0dbdd3b135340b9eb793.png" data-original-src="https://miro.medium.com/v2/resize:fit:1252/format:webp/0*UleFTV-2cc5nJu6t.png"/></div></figure><p id="556c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过以上检查，可以重新生成客户端类，并更新消费应用程序中的文件。</p><h2 id="dd76" class="km kn iq bd ko kp kq dn kr ks kt dp ku jy kv kw kx kc ky kz la kg lb lc ld le bi translated">使用HTTP客户端工厂和依赖注入</h2><p id="b876" class="pw-post-body-paragraph jn jo iq jp b jq lf js jt ju lg jw jx jy lh ka kb kc li ke kf kg lj ki kj kk ij bi translated">在消费应用程序中，我们需要在<strong class="jp ir"> Startup </strong>类的<strong class="jp ir"> ConfigureServices </strong>函数中添加以下内容，以便专门为我们的Contacts API添加一个HTTP客户端，并通过依赖注入系统使其可用。</p><pre class="ll lm ln lo gt ls lt lu lv aw lw bi"><span id="f5f5" class="km kn iq lt b gy lx ly l lz ma">services.AddHttpClient&lt;IContactsClient, ContactsClient&gt;(client =&gt; <br/>           client.BaseAddress = new Uri("https://localhost:5001"));</span></pre><p id="7b46" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于生产应用程序，我建议使用配置系统来存储API的URL，而不是像上面那样硬编码。</p><p id="9683" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如用法，我使用的是<strong class="jp ir">索引模型</strong>。首先，添加一个类级别的字段来保存我们的API客户端，并通过构造函数注入客户端。</p><pre class="ll lm ln lo gt ls lt lu lv aw lw bi"><span id="3d60" class="km kn iq lt b gy lx ly l lz ma">private readonly IContactsClient _contactsClient;<br/><br/>public IndexModel(ILogger&lt;IndexModel&gt; logger, IContactsClient contactsClient)<br/>{<br/>    _logger = logger;<br/>    _contactsClient = contactsClient;<br/>}</span></pre><p id="1876" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们有了一个类级别的contacts客户端，我们可以使用它从我们的API获取数据。以下示例使用客户端从API获取所有联系人，并将它们存储在一个变量中。</p><pre class="ll lm ln lo gt ls lt lu lv aw lw bi"><span id="dd79" class="km kn iq lt b gy lx ly l lz ma">public async Task OnGet()<br/>{<br/>    var contacts = await _contactsClient.GetContactsAsync();<br/>}</span></pre><h2 id="4aa8" class="km kn iq bd ko kp kq dn kr ks kt dp ku jy kv kw kx kc ky kz la kg lb lc ld le bi translated">包扎</h2><p id="b072" class="pw-post-body-paragraph jn jo iq jp b jq lf js jt ju lg jw jx jy lh ka kb kc li ke kf kg lj ki kj kk ij bi translated">我强烈推荐使用这种风格的客户端，而不是直接使用HTTP客户端。如果您做一些搜索，您会发现管理HTTP客户端的生命周期。NET之前，HTTP客户端工厂是一个很容易搞砸的东西。</p><p id="7df5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以下发布的内容用作参考:</p><p id="c0a0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://stu.dev/generating-typed-client-for-httpclientfactory-with-nswag/" rel="noopener ugc nofollow" target="_blank">使用NSwag生成用于HttpClientFactory的类型化客户端</a> <br/> <a class="ae kl" href="https://github.com/dmitry-pavlov/openapi-connected-service/blob/master/docs/How-to-Add-Generated-HttpClient-to-ASPNETCore-Dependency-Injection.MD" rel="noopener ugc nofollow" target="_blank">如何将生成的HttpClient添加到ASP.NET核心依赖注入</a></p></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><p id="87b4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mi">原载于</em> <a class="ae kl" href="https://elanderson.net/2019/11/use-http-client-factory-with-nswag-generated-classes-in-asp-net-core-3/" rel="noopener ugc nofollow" target="_blank"> <em class="mi">埃里克·安德森</em> </a> <em class="mi">。</em></p></div></div>    
</body>
</html>