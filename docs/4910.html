<html>
<head>
<title>Bela Lugosi’s Thread</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">贝拉·路高西的线</h1>
<blockquote>原文：<a href="https://itnext.io/bela-lugosis-thread-c3e8d1a5090e?source=collection_archive---------5-----------------------#2020-10-21">https://itnext.io/bela-lugosis-thread-c3e8d1a5090e?source=collection_archive---------5-----------------------#2020-10-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="bcaf" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">或者为什么上下文是golang中的吸血鬼</h2></div><p id="96be" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le">(本博客由https://creativecommons.org/licenses/by/4.0/</em><a class="ae lf" href="https://creativecommons.org/licenses/by/4.0/" rel="noopener ugc nofollow" target="_blank">授权，</a><em class="le">所有代码由https://www.apache.org/licenses/LICENSE-2.0</em><a class="ae lf" href="https://www.apache.org/licenses/LICENSE-2.0" rel="noopener ugc nofollow" target="_blank"><em class="le"/></a><em class="le">授权)</em></p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi lg"><img src="../Images/baf492377fdcfb4e3e8993d003ed7a1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jrQlAI4KylSssR3SMkY-aQ.png"/></div></div></figure><h2 id="f7f1" class="ls lt it bd lu lv lw dn lx ly lz dp ma kr mb mc md kv me mf mg kz mh mi mj mk bi translated">介绍</h2><p id="36e0" class="pw-post-body-paragraph ki kj it kk b kl ml ju kn ko mm jx kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">继续我上一篇关于actor模式的文章，深入了解该实现的一个侧面细节是很重要的。在这两个解决方案中，我都利用了go上下文。这个在2014年引入的对象是处理goroutine取消和请求处理程序协调的惯用方法。参见(<a class="ae lf" href="https://blog.golang.org/context" rel="noopener ugc nofollow" target="_blank">https://blog.golang.org/context</a>)。</p><p id="3986" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">考虑以下代码:</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi mq"><img src="../Images/c0202213d96f5ef5f51ec4e3c46a6536.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vcsU7K-vqN2BYibOW42HUA.png"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">最直接的解决方案</figcaption></figure><p id="4937" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这种抽象将延迟加载io。write closes具有提供的open函数，允许线程写入。到目前为止，没有使用上下文，互斥体提供同步。现在考虑这段代码被用在必须在截止日期内处理数据的代码中。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi mv"><img src="../Images/3612d06c4f497205290c5f86d3b79088.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zf0zC_xajiEvH6-TcfRfhg.png"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">应该没问题</figcaption></figure><p id="b9a6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le"> verify() </em>函数看起来是这样的，并在整个示例中使用:</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/082a25ddb212e392e2647feb461c8ca8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1322/format:webp/1*hS1dSIWEU6jQC_ePp5UeBg.png"/></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">剧透:完工街区的条件在以后变得很重要</figcaption></figure><p id="d9dc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们有一个测试编写器，它以某种方式计算对<em class="le"> Write </em>的调用次数，并为Write和Close提供可调延迟。我们设置的最后期限是1.5 *次迭代(以毫秒为单位)，每次写入花费1毫秒，关闭花费不到一半的迭代(以毫秒为单位)(想象正在发生刷新)。我们运行测试，一切都通过了:</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/6e437bbe60ea5e534bb4930a5229c5ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1214/format:webp/1*GMCrHFsWPH2vO8yKVbKFnA.png"/></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">工作一次并被缓存，就像任何好的测试一样</figcaption></figure><p id="8128" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一切正常，所以我签入我的代码。几天后，我所有的同事都开始抱怨单元测试管道失败，说我的测试不可靠。为了找出我的测试出了什么问题，我试着以50为计数运行，并发现了以下情况:</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi my"><img src="../Images/4f70425390de0da2e9fd9264b9c34e4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IYUyZBlqY468WId09gCsMg.png"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">签入这样做的代码会减少您的实际寿命</figcaption></figure><p id="b33d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">9/50的测试运行失败。它们不仅会失败，而且会在写入之后、关闭方法理论上将数据同步到磁盘之前失败。</p><h2 id="3f92" class="ls lt it bd lu lv lw dn lx ly lz dp ma kr mb mc md kv me mf mg kz mh mi mj mk bi translated">古怪的测试还是古怪的代码？</h2><p id="7fab" class="pw-post-body-paragraph ki kj it kk b kl ml ju kn ko mm jx kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">怎么会这样呢？测试似乎“大部分时间”都能通过。有两个因素在起作用:</p><ol class=""><li id="edc4" class="mz na it kk b kl km ko kp kr nb kv nc kz nd ld ne nf ng nh bi translated">调度程序不保证goroutines按照代码中的顺序运行。</li><li id="3b2c" class="mz na it kk b kl ni ko nj kr nk kv nl kz nm ld ne nf ng nh bi translated">延迟按堆栈顺序运行，因此<em class="le">关闭</em>功能在测试结束前运行。</li></ol><p id="3f08" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一种选择是放宽最后期限，但我可以想象15%的缓冲是我所能期待的极限。我必须<em class="le"> Close() </em>否则我可能会丢失所有数据，但最后一次写入可能会在下一个时间间隔重试。为了解决这个问题，我首先向我的API引入一个上下文。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/949010efb1f878ca6f304fb4985999a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1384/format:webp/1*jb7Fp1M4OR-hLMRsfj8q2Q.png"/></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">我的IDE不理解嵌入式结构</figcaption></figure><p id="0abb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le"> Close </em>方法没有改变，所以即使上下文过期，我们写的所有东西都会被刷新到磁盘。为了模拟这种情况，我引入了一个“最坏情况”的上下文，它将给予<em class="le"> Close() </em>方法足够长的时间来刷新，即使一些写操作会失败:</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi no"><img src="../Images/2a1c1c5f4d713bddb45a626c030140c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1374/format:webp/1*MyALDncNpMj_W2J69r_DSA.png"/></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">写操作会立即取消，对吗？</figcaption></figure><p id="aacc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">测试失败了，而且现在看起来更糟。不再有迟到的<em class="le">结束</em>电话，但是我们经常不能把所有事情都写下来。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi np"><img src="../Images/ccdcc0866564b988a866f1e9d41a0038.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6dDrzTuWGkep9eR0YNZLiA.png"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">比晚冲水好？</figcaption></figure><p id="5391" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">尽管时间应该允许我们完成所有写入，但仍有10%的数据丢失。面对这一现实，我们希望为写入引入更多的goroutines，以保证尽可能多的写入操作得以完成。</p><h2 id="9c10" class="ls lt it bd lu lv lw dn lx ly lz dp ma kr mb mc md kv me mf mg kz mh mi mj mk bi translated">穿线很容易(也很天真)</h2><p id="7730" class="pw-post-body-paragraph ki kj it kk b kl ml ju kn ko mm jx kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">修改后的主循环是一个标准的fork/join模式，我也决定尝试一下并收紧时间。如果每次写入都是并行的，那么最坏的情况应该是上下文截止时间:</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/36aa471cd6725a4b4ea87198ebcc7ddd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1326/format:webp/1*LHnI8CnfO6C4vQ0vJskFHQ.png"/></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">啊，就像以前一样</figcaption></figure><p id="eaf1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为这是显式线程化的，所以测试运行时使用了竞争检测器来检查我们的工作，我们得到了以下奇怪的结果:</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi nr"><img src="../Images/8ea6bcb71255d330f099adc4b48da1f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P8FM9xrINs6d37wN_ImWsw.png"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">我能因为额外的写作得到额外的学分吗？</figcaption></figure><p id="cea2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们对性能进行了如此大的改进，以至于在某些情况下，我们传递的信息超出了预期。种族探测器显示没有种族存在，但我们显然没有得到额外的学分。我们可以容忍写入丢失，但这种溢出是值得关注的。</p><p id="1acb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这一问题的原因是由埃德格·迪克斯特拉在1965年提出的“沉睡的理发师问题”。引用<a class="ae lf" href="https://en.wikipedia.org/wiki/Sleeping_barber_problem" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Sleeping_barber_problem</a></p><blockquote class="ns nt nu"><p id="08bd" class="ki kj le kk b kl km ju kn ko kp jx kq nv ks kt ku nw kw kx ky nx la lb lc ld im bi translated">这个类比是基于一个假设的理发店，只有一个理发师。理发师在理发室有一把理发椅，在等候室里有许多椅子。当理发师剪完一个顾客的头发后，他把顾客打发走，然后去等候室看看是否还有其他人在等着。如果有的话，他会把其中一个带到椅子上，给他们剪头发。如果没有，他就回到椅子上，睡在里面。</p><p id="2977" class="ki kj le kk b kl km ju kn ko kp jx kq nv ks kt ku nw kw kx ky nx la lb lc ld im bi translated">每位顾客到达时，都想看看理发师在做什么。如果理发师在睡觉，顾客叫醒他，然后坐在理发室的椅子上。如果理发师在理发，顾客就呆在等候室。如果候诊室里有一把空椅子，顾客就坐在上面等待轮到他们。如果没有空椅子，顾客就会离开。</p></blockquote><p id="2b65" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这种情况下,“客户”就是上下文。虽然这种天真的方法看似可行，但存在一个关键问题。调度器在每次上下文切换时引入不确定的等待周期。这里有一个这样的开关:</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/0b8ff3a5bd6ddc58da04ff08924c4183.png" data-original-src="https://miro.medium.com/v2/resize:fit:1178/format:webp/1*dhUd_oIh8odAZkCJp_FIng.png"/></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">每次调用锁或与通道交互都会创建上下文切换，但这不是必须的</figcaption></figure><p id="9f0d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在<em class="le">锁定</em>。执行<em class="le">写</em>的线程可以在检查上下文和获取<em class="le">锁</em>之间等待无限长的时间。由于这个原因，一个写入器可以写入到<em class="le"> io。在上下文关闭后很久，write closer</em>；这是在重复测试中观察到的。显然，这种并行性的尝试并没有像预期的那样工作。</p><p id="b68e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我能想象你在问自己:吸血鬼在哪里？理发师和顾客都不是夜间的动物。</p><h2 id="5905" class="ls lt it bd lu lv lw dn lx ly lz dp ma kr mb mc md kv me mf mg kz mh mi mj mk bi translated">从不同的角度思考语境</h2><p id="3c6b" class="pw-post-body-paragraph ki kj it kk b kl ml ju kn ko mm jx kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">把上面的错误放在一边，让我们看看golang中上下文的特征:</p><ul class=""><li id="6856" class="mz na it kk b kl km ko kp kr nb kv nc kz nd ld nz nf ng nh bi translated">所有上下文都来自后台()。</li><li id="11fc" class="mz na it kk b kl ni ko nj kr nk kv nl kz nm ld nz nf ng nh bi translated">所有上下文都是线程安全的。</li><li id="10b6" class="mz na it kk b kl ni ko nj kr nk kv nl kz nm ld nz nf ng nh bi translated">Background()永远不会消失，但是从Background()创建的上下文有一个生命周期(取消、超时、截止日期)。</li><li id="3de2" class="mz na it kk b kl ni ko nj kr nk kv nl kz nm ld nz nf ng nh bi translated">新上下文可以来自其他上下文，它们继承父生命周期以及自己的生命周期。</li><li id="e6a5" class="mz na it kk b kl ni ko nj kr nk kv nl kz nm ld nz nf ng nh bi translated">当父母去世时，所有的孩子/孙子/后代都会死去。</li><li id="0a3a" class="mz na it kk b kl ni ko nj kr nk kv nl kz nm ld nz nf ng nh bi translated">孩子可能会死，但对父母没有任何影响。</li><li id="a18c" class="mz na it kk b kl ni ko nj kr nk kv nl kz nm ld nz nf ng nh bi translated">子上下文从父上下文继承值。</li><li id="839f" class="mz na it kk b kl ni ko nj kr nk kv nl kz nm ld nz nf ng nh bi translated">一旦你的产品中有了上下文，它们就会迅速传播开来。</li></ul><p id="ed50" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里是吸血鬼类比的开始。有一个“不可杀死的”上下文叫做<em class="le">背景</em>，所有其他上下文都从它们那里获得力量。<em class="le">背景</em>没有价值，没有期限，但却是层级的根，不可知但不可杀死。随着上下文的创建，它们已经设置了生存期。孩子的死亡对父母(或祖父母)没有影响。然而，父母(或祖父母)的死亡会结束所有的后代。</p><p id="58e8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当它们被视为管理线程生存期的工具时，这一切都是有意义的。如果线程的生命可以与上下文的生命联系在一起，那么我们就可以精确地控制线程的层次结构。但是它们为什么会传播呢？为此，我们回到例子。</p><h2 id="10c8" class="ls lt it bd lu lv lw dn lx ly lz dp ma kr mb mc md kv me mf mg kz mh mi mj mk bi translated">习惯性地使用上下文</h2><p id="e340" class="pw-post-body-paragraph ki kj it kk b kl ml ju kn ko mm jx kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">在我们的第一次尝试中，我们将对我们的界面做一些小的改动:</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/9853d269a9fe94cd473c8d9587f99832.png" data-original-src="https://miro.medium.com/v2/resize:fit:1314/format:webp/1*Gs5RsbN9LmFJcpeNfKgdrQ.png"/></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">结果可以被延迟，它们在返回信道上被传送</figcaption></figure><p id="b67b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">新函数有一个goroutine来处理IO(锁现在在私有成员函数内部),这个例程看起来非常不同:</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/63af2320df6e2712e10c85481860a5cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1234/format:webp/1*inPFsRsLGeCUT9PcqnGe-A.png"/></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">ctx。Err()仅在我们知道上下文已经完成()时使用</figcaption></figure><p id="3976" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意，对上下文的检查是通过“done”完成的，并且是在临界区(不再是整个函数)内完成的。通过在获得锁之后检查，理发师可以睡得更安稳一点。<em class="le"> ctx </em>也在测试代码中扩散:</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/63af2320df6e2712e10c85481860a5cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1234/format:webp/1*inPFsRsLGeCUT9PcqnGe-A.png"/></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">这就够了吗？</figcaption></figure><p id="4cd2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">结果呢？异步写入程序是否修复了“丢失的时间”,同时防止在取消后发生写入？</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi oc"><img src="../Images/21bf9f48acc84face9fa240a4717d78e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NyFXWDTXUVHqhF1uiQPAmw.png"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">总是推动你的测试直到它们崩溃</figcaption></figure><p id="295b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们肯定离解决方案更近了。早期的方法在10或50次尝试后都失败了，但是200次尝试还是不够的。应该可以连续运行几个小时而不出错。</p><h2 id="d238" class="ls lt it bd lu lv lw dn lx ly lz dp ma kr mb mc md kv me mf mg kz mh mi mj mk bi translated">背景和行为者</h2><p id="fbd2" class="pw-post-body-paragraph ki kj it kk b kl ml ju kn ko mm jx kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">像我以前的工作一样，我们转向actor模式来减少线程和上下文切换，以努力获得目标性能。在这里，潜在的“吸血鬼”性质的背景正在显示。上下文并不直接存储在对象中(这是不好的)，但是现在甚至构造函数也接受上下文。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi od"><img src="../Images/6decba535be6817966b9ae20a74fd354.png" data-original-src="https://miro.medium.com/v2/resize:fit:1292/format:webp/1*2pSc1Z3upZH6AXNgOeaU2g.png"/></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">一点也不像原作</figcaption></figure><p id="3e71" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请求现在是成熟的承诺，因此<em class="le"> Then() </em>函数也可以接受上下文:</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/3884ef8461e713b90ab605828532754c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1214/format:webp/1*B1Tyn85LXTL31JJ67c3zXg.png"/></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">这个承诺没有遵循接受lambda函数的javascript模式</figcaption></figure><p id="932f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le">写</em>和<em class="le">关</em>方法现在都接受一个上下文。私有的“closeall”函数现在已经很纯粹了(技术上来说，它甚至不需要接收器)。没有一个方法是指针接收器，因为互斥体也消失了:</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/3a492d3717577c0ed5b7950b353a2ac7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1384/format:webp/1*kfaILCZInDA5ZjpLYAF5Mg.png"/></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">拿一个背景来说，所有酷的孩子都在这么做</figcaption></figure><p id="42d6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，actor的私有资源和主循环在<em class="le"> start </em>中:</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/99505ce4e52a8ff0c0b0088502c1a8ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1228/format:webp/1*nFwvOjaZegpnuE5EhEl4fg.png"/></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">对象映射不再是编写器的成员，而是存在于堆栈中</figcaption></figure><p id="8ba1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">演员确实有缺点。演员有更多的“启动成本”。在测试场景中，这可能会被放大。单例模式可以用于许多这样的解决方案(特别是<em class="le">context writer</em>)，它是最适合参与者的模式。一旦参与者处于全局状态，就可以向其写入数据并关闭资源，而无需担心消费者之间的竞争和引入瓶颈。虽然这个实现没有演示下一个级别，即每个命名资源都被隔离到它们自己的goroutines中，但是上一篇文章已经对此进行了更详细的介绍。因此，非单例解决方案不如<em class="le">context writer</em>(后者的启动成本低得多):</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi of"><img src="../Images/760872e520d4b8bc95a122d5b024bd7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Eipa78HtVm-J6DR8_3UQFA.png"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">为什么又要麻烦演员呢？</figcaption></figure><h2 id="a2ff" class="ls lt it bd lu lv lw dn lx ly lz dp ma kr mb mc md kv me mf mg kz mh mi mj mk bi translated">“不是所有的全局变量都是单例变量，也不是所有的单例变量都是全局变量”</h2><p id="d09e" class="pw-post-body-paragraph ki kj it kk b kl ml ju kn ko mm jx kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">在这种情况下，采用<em class="le"> ActorWriter </em>的隐式singleton，并冒险使其成为singleton会有所收获:</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi og"><img src="../Images/bb455d26ee9dfcd4153816ee746750df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/1*s_ntLX7oWPmi95CL2By16Q.png"/></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">向我的大学数据结构老师道歉</figcaption></figure><p id="3b53" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有了它，我们可以运行无数次迭代，知道契约不会被破坏，我们将有效地利用资源:</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi oh"><img src="../Images/4cdc77e1cad470fdada02977232ec1ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XYSX-11SmuFM2OAEsgXwGw.png"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">1000够了吧？</figcaption></figure><h2 id="8fc8" class="ls lt it bd lu lv lw dn lx ly lz dp ma kr mb mc md kv me mf mg kz mh mi mj mk bi translated">结论</h2><p id="c76b" class="pw-post-body-paragraph ki kj it kk b kl ml ju kn ko mm jx kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">虽然最初可能会觉得繁琐，但上下文——以及使用它们的模式——将成为golang中线程管理的关键。gRPC等服务已经广泛使用它们。当你选择吸血鬼的时候，他们会扩散，如果当你使用的API已经被激活的时候，他们被忽略了，你会受到伤害。单纯依靠<em class="le"> ctx。Err() </em>会在没有考虑上下文的代码中引入错误。拥抱上下文，同时用goroutine/channel模式重构代码，将解决许多这样的问题。</p><p id="0479" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">golang的最终目的是让线程化和线程间消息传递成为程序的核心机制，这样，随着内核数量的增加，代码的性能也会提高(通常无需重新编译)。用这些模式编写的更强、更快、更通用的程序需要一个系统来管理线程，而线程的线程和上下文就是根据这一点专门设计的。在他们的帮助下，程序员不需要关心底层库如何处理线程安全性和并行性。</p><p id="50e6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例子都是在Apache 2.0许可下授权的，可以在https://github.com/weberr13/ChannelsForNothing/的<a class="ae lf" href="https://github.com/weberr13/ChannelsForNothing/" rel="noopener ugc nofollow" target="_blank">获得</a></p></div></div>    
</body>
</html>