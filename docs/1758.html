<html>
<head>
<title>Setting Up Swagger to API Test In a JavaScript Application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在JavaScript应用程序中设置Swagger进行API测试</h1>
<blockquote>原文：<a href="https://itnext.io/setting-up-swagger-in-a-node-js-application-d3c4d7aa56d4?source=collection_archive---------1-----------------------#2019-01-21">https://itnext.io/setting-up-swagger-in-a-node-js-application-d3c4d7aa56d4?source=collection_archive---------1-----------------------#2019-01-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><h1 id="727c" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">Spring Boot让Swagger APIs看起来很容易，Node.js就不那么容易了。</h1><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ko"><img src="../Images/c086190142417c026563026933a0760e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1380/format:webp/1*aKVg84SP5oPV9fwOnbl6yQ.png"/></div></figure><p id="039c" class="pw-post-body-paragraph kw kx it ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi lu translated"><span class="l lv lw lx bm ly lz ma mb mc di">如果</span>你和我一样，曾经使用过不附带UI的REST API(应用程序接口),你可能不止一次困惑于API需要什么输入和标记来返回你所期望的数据，而不是一些神秘的400 HTTP错误消息。</p><p id="3f6e" class="pw-post-body-paragraph kw kx it ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有时我不知道是否需要某种授权头(或者如何发送)，API是否会接受<code class="fe md me mf mg b">post</code>或<code class="fe md me mf mg b">put</code>(以及什么是必需的，什么是可选的)，以及它是否接受<code class="fe md me mf mg b">application/json</code>或其他XML格式的编码。</p><p id="20ee" class="pw-post-body-paragraph kw kx it ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从等式中去掉一些不确定性不是很好吗？如果不是面对一个空空的邮递员或失眠的应用程序等着你去配置它并为它提供它需要的一切，而是一个API route告诉你它到底需要什么，这不是很好吗？请求体与查询参数、整数与字符串、JWT验证头与cookie——所有这些，只是布局，所有可能的路径都是可见的。</p><p id="2ef9" class="pw-post-body-paragraph kw kx it ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">听起来好得难以置信？不是的。</p><blockquote class="mh"><p id="6b90" class="mi mj it bd mk ml mm mn mo mp mq lt dk translated">在我加入目前的开发团队之前，我不知道有这样一个神奇的API助手存在，但它确实存在。而且叫<a class="ae mr" href="https://swagger.io/" rel="noopener ugc nofollow" target="_blank">霸气</a>。</p></blockquote><p id="a2dd" class="pw-post-body-paragraph kw kx it ky b kz ms lb lc ld mt lf lg lh mu lj lk ll mv ln lo lp mw lr ls lt im bi translated">我将在下面给出所有的细节，但这里有一个例子可以说明Swagger可以为您的web应用程序的API路由提供什么。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi mx"><img src="../Images/152a3e002c33831a8c344282ed31a71c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xhvyEKG3BzeAXLHWM6GuCg.png"/></div></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk translated">是的，在Swagger的帮助下，您的API可以如此可爱，按字母顺序排列并进行颜色编码。</figcaption></figure><h1 id="2bd5" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">认识一下斯瓦格，你的API的新朋友</h1><p id="45cf" class="pw-post-body-paragraph kw kx it ky b kz ng lb lc ld nh lf lg lh ni lj lk ll nj ln lo lp nk lr ls lt im bi translated">斯瓦格的维基百科页面对此做了最好的总结:</p><blockquote class="nl nm nn"><p id="1de3" class="kw kx no ky b kz la lb lc ld le lf lg np li lj lk nq lm ln lo nr lq lr ls lt im bi translated">Swagger是一个开源软件框架，由一个大型工具生态系统支持，帮助开发人员设计、构建、记录和使用RESTful Web服务。虽然大多数用户通过Swagger UI工具来识别Swagger，但Swagger工具集包括对自动化文档、代码生成和测试用例生成的支持。— <a class="ae mr" href="https://en.wikipedia.org/wiki/Swagger_(software)" rel="noopener ugc nofollow" target="_blank">维基百科，Swagger(软件)</a></p></blockquote><p id="e1be" class="pw-post-body-paragraph kw kx it ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果现在还不明白，请继续阅读。一旦你在实践中看到它，它就会变得有意义。</p><p id="f667" class="pw-post-body-paragraph kw kx it ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Swagger最可爱的一点是，它可以用于几乎任何编程语言:从JavaScript到Haskell，再到C++和Python，再到Rust，这个列表还可以继续下去。<a class="ae mr" href="https://github.com/swagger-api/swagger-codegen" rel="noopener ugc nofollow" target="_blank">支持的语言</a>数量实在惊人。</p><p id="4f61" class="pw-post-body-paragraph kw kx it ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我第一次接触Swagger是通过Java的Spring Boot应用程序。通过在<code class="fe md me mf mg b">build.gradle</code>依赖项中包含一行:<code class="fe md me mf mg b">compile(‘io.springfox:springfox-swagger-ui:2.9.2’)</code>，在Java配置文件中包含一个注释:<code class="fe md me mf mg b">@EnableSwagger2</code>，在<code class="fe md me mf mg b">application.yml</code>中包含<code class="fe md me mf mg b">swagger.basePackage</code>的位置，一旦Spring Boot应用程序编译并运行，您就拥有了一个漂亮的API UI。</p><p id="9e73" class="pw-post-body-paragraph kw kx it ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在浏览器中输入类似于<a class="ae mr" href="http://localhost:8081/swagger-ui.html." rel="noopener ugc nofollow" target="_blank">http://localhost:8081/Swagger-UI . html</a>的内容就可以到达Swagger UI。然后，瞧，您已经为您的API服务获得了一个交互式的、基于浏览器的UI，您可以随心所欲地进行测试。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi ns"><img src="../Images/270c8311208a8e5a79f5b7f06a9d7642.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bBdn_8nZmIH4-MPCdKRvhw.png"/></div></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk translated">下面是我打开Spring Boot Swagger HTML页面时看到的一个例子。</figcaption></figure><p id="9234" class="pw-post-body-paragraph kw kx it ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Swagger向用户展示了项目中的路由，它准确地显示了数据的形状以及每个参数所需的属性类型，它让您知道是否需要标题以及它们的确切类型，请求体或查询参数是可选的还是必需的，以及可能的HTTP响应方法和每种方法的含义。这太不可思议了——仅仅对我的Java代码做了三点小小的更新。</p><p id="42d0" class="pw-post-body-paragraph kw kx it ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于Spring Boot来说，这似乎是小菜一碟，我(天真地)认为用我的<a class="ae mr" href="https://github.com/paigen11/mysql-registration-passport" rel="noopener ugc nofollow" target="_blank">全栈、MERN、JavaScript </a>应用程序实现Swagger会一样容易。我真傻…</p><h1 id="9d93" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">JavaScript中的Swagger，有一个NPM包可以实现，对吗？</h1><p id="c5a4" class="pw-post-body-paragraph kw kx it ky b kz ng lb lc ld nh lf lg lh ni lj lk ll nj ln lo lp nk lr ls lt im bi translated">嗯，这个问题的简短答案是:是的。这个问题更长的答案是:有很多包。最长的回答就是我现在要告诉你的。</p><p id="ca69" class="pw-post-body-paragraph kw kx it ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">不像Spring Boot，它有一个事实上的Swagger包，JavaScript和Swagger的世界更加支离破碎。从我对NPM和互联网的探索来看，似乎并不只有一个答案可以生成神气活现的文档，并以我熟悉并喜欢的UI格式显示它们。</p><p id="e0aa" class="pw-post-body-paragraph kw kx it ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所以我阅读了一些博客，阅读了一些关于OpenAPI规范(以前称为Swagger规范)的文档，并在了解到没有为JavaScript维护的Swagger文档生成器时，我最终决定使用<a class="ae mr" href="https://www.npmjs.com/package/swagger-jsdoc" rel="noopener ugc nofollow" target="_blank"> Swagger JSDoc </a>来为我的路线创建我的Swagger文档，并将其与<a class="ae mr" href="https://www.npmjs.com/package/swagger-ui-express" rel="noopener ugc nofollow" target="_blank"> Swagger UI Express </a>相结合，以在浏览器中生成UI界面。让我告诉你更多关于这些模块的信息。</p><h2 id="d6be" class="nt jr it bd js nu nv dn jw nw nx dp ka lh ny nz ke ll oa ob ki lp oc od km oe bi translated">Swagger JSDoc</h2><p id="42a3" class="pw-post-body-paragraph kw kx it ky b kz ng lb lc ld nh lf lg lh ni lj lk ll nj ln lo lp nk lr ls lt im bi translated">Swagger JSDoc自己的话再一次最好地描述了这一点:</p><blockquote class="nl nm nn"><p id="410e" class="kw kx no ky b kz la lb lc ld le lf lg np li lj lk nq lm ln lo nr lq lr ls lt im bi translated"><strong class="ky iu"> swagger-jsdoc </strong>使您能够在代码中使用<code class="fe md me mf mg b"><a class="ae mr" href="http://usejsdoc.org/" rel="noopener ugc nofollow" target="_blank">JSDoc</a></code>注释来集成<a class="ae mr" href="http://swagger.io/" rel="noopener ugc nofollow" target="_blank"> Swagger </a>。只需在你的文档块上添加<code class="fe md me mf mg b">@swagger</code>并声明你的代码在YAML符合OpenAPI规范的含义。—NPM斯瓦格JSDoc</p></blockquote><p id="8484" class="pw-post-body-paragraph kw kx it ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这意味着，在每个现有的API路由之上，您用<code class="fe md me mf mg b">@swagger</code>注释为该路由编写YAML风格的Swagger规范(所以缩进和冒号都算在内),然后这个模块将把它翻译成由我的第二个模块:Swagger UI Express呈现的UI。</p><p id="f023" class="pw-post-body-paragraph kw kx it ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个模块对于已经编写好的API也特别好(我的项目恰好就是这样)。我是在事后才添加Swagger文档的——而不是在我第一次构建应用程序时作为初始架构的一部分。</p><blockquote class="nl nm nn"><p id="408c" class="kw kx no ky b kz la lb lc ld le lf lg np li lj lk nq lm ln lo nr lq lr ls lt im bi translated"><code class="fe md me mf mg b">swagger-jsdoc</code>项目假设您希望以某种方式记录您现有的/生活的/工作的代码，以“赋予它生命”,生成一个规范，然后可以输入到其他Swagger工具中，而不是相反。—NPM斯瓦格JSDoc</p></blockquote><p id="526f" class="pw-post-body-paragraph kw kx it ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我在这个过程中早点决定添加Swagger，我会查看<a class="ae mr" href="http://swagger.io/swagger-editor/" rel="noopener ugc nofollow" target="_blank"> Swagger编辑器</a>或<a class="ae mr" href="http://swagger-node" rel="noopener ugc nofollow" target="_blank"> Swagger节点</a>。</p><h2 id="ea1a" class="nt jr it bd js nu nv dn jw nw nx dp ka lh ny nz ke ll oa ob ki lp oc od km oe bi translated">Swagger UI Express</h2><p id="340f" class="pw-post-body-paragraph kw kx it ky b kz ng lb lc ld nh lf lg lh ni lj lk ll nj ln lo lp nk lr ls lt im bi translated">与Swagger JSDoc相比，Swagger UI Express文档要简单得多，因为真正具有挑战性的部分是编写Swagger规范。</p><p id="a994" class="pw-post-body-paragraph kw kx it ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">正如Swagger UI Express的文档所说，它</p><blockquote class="nl nm nn"><p id="7e79" class="kw kx no ky b kz la lb lc ld le lf lg np li lj lk nq lm ln lo nr lq lr ls lt im bi translated">向您的express应用程序添加中间件，以服务绑定到您的Swagger文档的Swagger UI。这相当于在应用程序中托管的API的动态文档。—NPM斯瓦格UI快递公司</p></blockquote><p id="92bd" class="pw-post-body-paragraph kw kx it ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">基本上，您按照规定的公式将Swagger文档输入到Swagger UI Express模块，然后它生成HTML UI。幸运的是，关于如何做到这一点的文档是最新的，也是准确的。这让事情变得非常简单。</p><p id="beda" class="pw-post-body-paragraph kw kx it ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，我已经介绍了两个解决方案的更多背景知识，我选择了这两个解决方案来使Swagger与JavaScript一起工作，更具体地说，是我的Express/Node.js服务器应用程序，是时候讨论如何实现它了。</p><h1 id="0007" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">让我们用JavaScript设置Swagger，能有多难？</h1><p id="6d08" class="pw-post-body-paragraph kw kx it ky b kz ng lb lc ld nh lf lg lh ni lj lk ll nj ln lo lp nk lr ls lt im bi translated">一旦我掌握了如何编写路由规范，实现Swagger就不是太难了，但是从最简单的部分开始，我将首先检查Swagger UI Express和Swagger JSDoc服务器设置。</p><p id="6e3c" class="pw-post-body-paragraph kw kx it ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你想下载我的整个项目并在本地运行它，或者只是看看源代码，这里有一个到<a class="ae mr" href="https://github.com/paigen11/mysql-registration-passport" rel="noopener ugc nofollow" target="_blank"> repo </a>的链接。</p><h2 id="39a4" class="nt jr it bd js nu nv dn jw nw nx dp ka lh ny nz ke ll oa ob ki lp oc od km oe bi translated">Server.js安装程序</h2><p id="43ef" class="pw-post-body-paragraph kw kx it ky b kz ng lb lc ld nh lf lg lh ni lj lk ll nj ln lo lp nk lr ls lt im bi translated"><code class="fe md me mf mg b"><strong class="ky iu">Server.js</strong></code></p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi of"><img src="../Images/e0f3e99fb18461b01ea7b6a2dddc2b7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i7MZgJLJInK9Lah3cfxWcQ.png"/></div></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk translated">下面是我完整的server.js文件，它初始化了Swagger JSDoc和Swagger UI Express。</figcaption></figure><p id="63b0" class="pw-post-body-paragraph kw kx it ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以上是我的完整<code class="fe md me mf mg b">server.js</code>文件的一个镜头，由<a class="ae mr" href="https://marketplace.visualstudio.com/items?itemName=pnp.polacode" rel="noopener ugc nofollow" target="_blank"> Polacode </a>提供。然而，你需要关注的是照片的这一部分。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi of"><img src="../Images/dbe3864f78e2c45ab83860242d510cfc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C20LN-_2dx8BiWXvUc-tJA.png"/></div></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk translated">这就是Swagger UI Express将Swagger JSDoc的swaggerSpec转换成一个漂亮的浏览器UI的神奇之处。</figcaption></figure><p id="d2cb" class="pw-post-body-paragraph kw kx it ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如你所见，<code class="fe md me mf mg b">swaggerJSDoc</code>和<code class="fe md me mf mg b">swaggerUiExpress</code>都被导入到文件中(如果你像我一样选择不在Node.js中使用ES6 transpiler，也可以用<code class="fe md me mf mg b">require</code>来完成)。</p><p id="8607" class="pw-post-body-paragraph kw kx it ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后创建<code class="fe md me mf mg b">swaggerDefinition</code>对象(这是<code class="fe md me mf mg b">swagger-jsdoc</code>所需设置的一部分)。它的属性包括<code class="fe md me mf mg b">info</code>像app的<code class="fe md me mf mg b">title</code>，一个<code class="fe md me mf mg b">version</code>和一个<code class="fe md me mf mg b">description</code>。它还需要一个<code class="fe md me mf mg b">host</code>(在我的例子中，端口3003是从我的Docker容器为API公开的端口)和一个<code class="fe md me mf mg b">basePath</code>。因为我也有一些只有当用户使用有效的JWT令牌登录时才可以访问的路由，所以我还必须用<code class="fe md me mf mg b">bearerAuth</code>信息创建一个<code class="fe md me mf mg b">securityDefinitions</code>对象:<code class="fe md me mf mg b">type</code>、<code class="fe md me mf mg b">name</code>、<code class="fe md me mf mg b">scheme</code>和<code class="fe md me mf mg b">in</code>。</p><p id="729e" class="pw-post-body-paragraph kw kx it ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面是我的<code class="fe md me mf mg b">swaggerDefinition</code>的一段代码，供参考。</p><pre class="kp kq kr ks gt og mg oh oi aw oj bi"><span id="e1d1" class="nt jr it mg b gy ok ol l om on">const<em class="no"> swaggerDefinition </em>=<em class="no"> </em>{<br/>  <em class="no">info</em>:<em class="no"> </em>{<br/>    <em class="no">title</em>:<em class="no"> </em>'MySQL Registration Swagger API',<br/>    <em class="no">version</em>:<em class="no"> </em>'1.0.0',<br/>    <em class="no">description</em>:<em class="no"> </em>'Endpoints to test the user registration routes',<br/>  },<br/>  <em class="no">host</em>:<em class="no"> </em>'localhost:3003',<br/>  <em class="no">basePath</em>:<em class="no"> </em>'/',<br/>  <em class="no">securityDefinitions</em>:<em class="no"> </em>{<br/>    <em class="no">bearerAuth</em>:<em class="no"> </em>{<br/>      <em class="no">type</em>:<em class="no"> </em>'apiKey',<br/>      <em class="no">name</em>:<em class="no"> </em>'Authorization',<br/>      <em class="no">scheme</em>:<em class="no"> </em>'bearer',<br/>      <em class="no">in</em>:<em class="no"> </em>'header',<br/>    },<br/>  },<br/>};</span></pre><p id="806a" class="pw-post-body-paragraph kw kx it ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一旦定义好了，它就被集合到另一个名为<code class="fe md me mf mg b">options</code>的对象中，这个对象包含了路由文件的路径。在我的例子中，我有一个名为<code class="fe md me mf mg b">routes</code>的文件夹，它们都在那里，所以我告诉Swagger去那里找。</p><pre class="kp kq kr ks gt og mg oh oi aw oj bi"><span id="b18d" class="nt jr it mg b gy ok ol l om on">const<em class="no"> options </em>=<em class="no"> </em>{<br/>  swaggerDefinition,<br/>  <em class="no">apis</em>:<em class="no"> </em>['./routes/*.js'],<br/>};</span></pre><p id="4e80" class="pw-post-body-paragraph kw kx it ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">之后，<code class="fe md me mf mg b">swaggerSpec</code>变量被初始化，将<code class="fe md me mf mg b">options</code>对象包装在<code class="fe md me mf mg b">swaggerJSDoc()</code>中。然后，给Express服务器一个路径来查看由<code class="fe md me mf mg b">swaggerSpec</code>创建的完整的<code class="fe md me mf mg b">swagger.json</code>模式。</p><pre class="kp kq kr ks gt og mg oh oi aw oj bi"><span id="6324" class="nt jr it mg b gy ok ol l om on">const<em class="no"> swaggerSpec </em>=<em class="no"> </em>swaggerJSDoc(options);</span><span id="fbdb" class="nt jr it mg b gy oo ol l om on">app<em class="no">.</em>get('/swagger.json', function(req, res) {<br/>  res<em class="no">.</em>setHeader('Content-Type', 'application/json');<br/>  res<em class="no">.</em>send(swaggerSpec);<br/>});</span></pre><p id="ed46" class="pw-post-body-paragraph kw kx it ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但对我来说，这是次要的，因为下面的代码实际上将<code class="fe md me mf mg b">swaggerSpec</code>和<code class="fe md me mf mg b">swaggerUi</code>模块结合在一起，创建了我所熟悉和喜爱的Swagger UI。</p><pre class="kp kq kr ks gt og mg oh oi aw oj bi"><span id="1279" class="nt jr it mg b gy ok ol l om on">app<em class="no">.</em>use('/api-docs', swaggerUi<em class="no">.</em>serve, swaggerUi<em class="no">.</em>setup(swaggerSpec));</span></pre><p id="6cf6" class="pw-post-body-paragraph kw kx it ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对，就这样。这比我最初想的要复杂一点，但是正如我所说的，设置这一切的文档很不错，如果你遇到困难，有像这样的教程可以帮助你。</p><h2 id="354f" class="nt jr it bd js nu nv dn jw nw nx dp ka lh ny nz ke ll oa ob ki lp oc od km oe bi translated">用户模式</h2><p id="f9d6" class="pw-post-body-paragraph kw kx it ky b kz ng lb lc ld nh lf lg lh ni lj lk ll nj ln lo lp nk lr ls lt im bi translated">在我引用我的<code class="fe md me mf mg b">User</code>对象编写我的路由之前，我需要进入实际的对象声明文件，并告诉Swagger是什么组成了我的用户。在那之后，我将能够在不同的路径中引用该模式和那些定义属性的模式，以确保一切顺利。</p><p id="4998" class="pw-post-body-paragraph kw kx it ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我使用Sequelize作为我的MySQL数据库的ORM，因此我为此定义了一个<code class="fe md me mf mg b">User</code>模式。如果你想了解更多关于Sequelize的知识，你可以阅读我写的这篇博文。</p><p id="56b2" class="pw-post-body-paragraph kw kx it ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是我的<code class="fe md me mf mg b">user.js</code>文件最终的样子。之间的一切</p><pre class="kp kq kr ks gt og mg oh oi aw oj bi"><span id="5c8f" class="nt jr it mg b gy ok ol l om on">/**<br/> * @swagger <br/> * schema definition info goes here...<br/> */</span></pre><p id="2e63" class="pw-post-body-paragraph kw kx it ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">是将在我的路线中引用的模式定义的一部分。</p><p id="2b40" class="pw-post-body-paragraph kw kx it ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe md me mf mg b"><strong class="ky iu">user.js</strong></code></p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi op"><img src="../Images/770f92378de5b3b896aed5440894a467.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HchZ0RinEgiXUSw-fpq7Yw.png"/></div></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk translated">这是我的用户对象和</figcaption></figure><p id="1974" class="pw-post-body-paragraph kw kx it ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如您所见，对象的每个属性都被命名为(<code class="fe md me mf mg b">id</code>、<code class="fe md me mf mg b">username</code>、<code class="fe md me mf mg b">resetPasswordToken</code>等)。)，及其数据类型(<code class="fe md me mf mg b">string</code>、<code class="fe md me mf mg b">integer</code>等)。)就定义在它的下面。最后要注意的是<code class="fe md me mf mg b">required</code>对象的属性。对我来说，这些与具有需求<code class="fe md me mf mg b">allowNull: false</code>的实际<code class="fe md me mf mg b">User</code>对象的属性相匹配。那就是我app的<code class="fe md me mf mg b">username</code>、<code class="fe md me mf mg b">password</code>、<code class="fe md me mf mg b">email</code>。</p><h2 id="9593" class="nt jr it bd js nu nv dn jw nw nx dp ka lh ny nz ke ll oa ob ki lp oc od km oe bi translated">路线模式</h2><p id="8547" class="pw-post-body-paragraph kw kx it ky b kz ng lb lc ld nh lf lg lh ni lj lk ll nj ln lo lp nk lr ls lt im bi translated">接下来要讨论的是为每条路线编写Swagger文档。</p><p id="ee86" class="pw-post-body-paragraph kw kx it ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我的应用程序中实际上有九条不同的路线，但是我将展示其中三条的文档。</p><p id="b1f7" class="pw-post-body-paragraph kw kx it ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一个是不需要授权的路由，第二个需要JWT令牌进行授权，第三个需要一个不同的随机生成的字符串来验证它是合法的。当我到达那里时，我会更详细地解释那一个。</p><p id="52ae" class="pw-post-body-paragraph kw kx it ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe md me mf mg b"><strong class="ky iu">loginUser.js</strong></code> <strong class="ky iu"> —不安全路线</strong></p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi op"><img src="../Images/a6a52425f888172a1ae40ecda95afd86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7OZSYWX2xnWdykOsFKVZjQ.png"/></div></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk translated">不安全路线的Swagger文档示例。</figcaption></figure><p id="8b04" class="pw-post-body-paragraph kw kx it ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我的第一个Swagger文档示例是一个不安全的路由:确切地说，是我的用户登录路由。同样，所有的Swagger文档都是以这种方式编写的，并且<strong class="ky iu">要注意:空格/缩进和冒号确实很重要</strong>。</p><pre class="kp kq kr ks gt og mg oh oi aw oj bi"><span id="bd91" class="nt jr it mg b gy ok ol l om on">/**<br/> * @swagger<br/> * documentation for route goes here...<br/> */</span></pre><p id="2b9c" class="pw-post-body-paragraph kw kx it ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Swagger文档是按照<a class="ae mr" href="https://docs.ansible.com/ansible/latest/reference_appendices/YAMLSyntax.html" rel="noopener ugc nofollow" target="_blank"> YAML风格</a>编写的，所以它关心每一行的正确缩进，并且它还关心大多数行都有冒号——如果空格被去掉或者冒号丢失，运行节点服务器代码的终端将抛出错误，直到它被修复(在我浏览的过程中，这让我犯了几次错误)。</p><p id="1d80" class="pw-post-body-paragraph kw kx it ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是我完整的Swagger文档的代码片段。</p><pre class="kp kq kr ks gt og mg oh oi aw oj bi"><span id="d917" class="nt jr it mg b gy ok ol l om on">/**<br/><em class="no">* </em>@swagger<br/><em class="no">* /loginUser:<br/>*   post:<br/>*     tags:<br/>*       - Users<br/>*     name: Login<br/>*     summary: Logs in a user<br/>*     consumes:<br/>*       - application/json<br/>*     parameters:<br/>*       - name: body<br/>*         in: body<br/>*         schema:<br/>*           $ref: '#/definitions/User'<br/>*           type: object<br/>*           properties:<br/>*             username:<br/>*               type: string<br/>*             password:<br/>*               type: string<br/>*               format: password<br/>*         required:<br/>*           - username<br/>*           - password<br/>*     responses:<br/>*       200:<br/>*         description: User found and logged in successfully<br/>*       401:<br/>*         description: Bad username, not found in db<br/>*       403:<br/>*         description: Username and password don't match<br/></em>*/</span></pre><p id="e8ff" class="pw-post-body-paragraph kw kx it ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">正如您所看到的，首先定义路由(实际的URL路由Swagger在浏览器中运行时必须命中)，然后定义HTTP调用的类型(<code class="fe md me mf mg b">get</code>、<code class="fe md me mf mg b">post</code>等)。).</p><p id="4129" class="pw-post-body-paragraph kw kx it ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe md me mf mg b">summary</code>部分出现在UI中的路线旁边，它很好地描述了路线的用途。</p><p id="69b0" class="pw-post-body-paragraph kw kx it ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果定义了许多不同的模式，<code class="fe md me mf mg b">tags</code>部分在组织不同的路由组时会更有用。因为我只有<code class="fe md me mf mg b">users</code>对我来说没多大关系。</p><p id="9ff5" class="pw-post-body-paragraph kw kx it ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果除了JSON之外还有别的东西被生产或消费，那就定义了。</p><p id="42ac" class="pw-post-body-paragraph kw kx it ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后用户将要输入的参数被布置在下面。因为我的JSON是在请求体中传递的，所以定义了<code class="fe md me mf mg b">in: body</code>。如果在查询参数中传递，它会改为说<code class="fe md me mf mg b">in: query</code>。</p><p id="0cfc" class="pw-post-body-paragraph kw kx it ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">用<code class="fe md me mf mg b">$ref: '#/definitions/User'</code>定义和引用的<code class="fe md me mf mg b">user</code>对象仅有的两个属性是<code class="fe md me mf mg b">username</code>和<code class="fe md me mf mg b">password</code>。因为这两者都是该路由工作所必需的，所以在下面设置了<code class="fe md me mf mg b">required</code>字段，并且引用了这两个属性(注意，必须与<code class="fe md me mf mg b">schema</code>列内联，以使必需字段在Swagger中生效)。</p><p id="64f8" class="pw-post-body-paragraph kw kx it ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，我们期望从服务器得到的HTTP响应都有详细的描述。它们很容易理解。</p><p id="26d9" class="pw-post-body-paragraph kw kx it ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，我已经介绍了一条不安全的路线，让我们继续介绍JWT的安全路线。</p><p id="ed12" class="pw-post-body-paragraph kw kx it ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe md me mf mg b"><strong class="ky iu">findUsers.js</strong></code> <strong class="ky iu"> —安全路线</strong></p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi op"><img src="../Images/038e3539e21e87e7a8df4d1a433b8e83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JAB0NnOVZ_2u6izkbaig3A.png"/></div></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk translated">JWT安全路线的大摇大摆文件。</figcaption></figure><p id="3ff4" class="pw-post-body-paragraph kw kx it ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这条路线是我的<code class="fe md me mf mg b">findUser</code>路线，它在用户登录后被触发，配置文件页面组件开始安装在客户端，从数据库收集所有用户信息。</p><p id="eb3e" class="pw-post-body-paragraph kw kx it ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于这个路由的Swagger文档，它再次定义了URL路径、文章类型、标签、摘要、生产/消费规格、参数等。</p><p id="1a15" class="pw-post-body-paragraph kw kx it ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">不同的是，这个路径包含了<code class="fe md me mf mg b">security</code>字段，这是我在<code class="fe md me mf mg b">server.js</code>文件中设置的<code class="fe md me mf mg b">securityDefinitions</code>重新发挥作用的地方。我在客户机和服务器之间来回传递JWT (JSON Web Token ),以验证用户的权限和授权，因此通过包含</p><pre class="kp kq kr ks gt og mg oh oi aw oj bi"><span id="98fb" class="nt jr it mg b gy ok ol l om on">/**<br/> * @swagger<br/> * ...<br/> * security:<br/> *   - bearerAuth: []<br/> * ...<br/> */</span></pre><p id="742a" class="pw-post-body-paragraph kw kx it ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它保护路由，并要求用户在成功拨打电话之前加入JWT。<code class="fe md me mf mg b">bearerAuth</code>是我在<code class="fe md me mf mg b">server.js</code>文件中命名的对象，你可以随意命名它，这两者只需要在服务器和路由文件中匹配，所以Swagger知道如何正确地形成请求。</p><p id="3e16" class="pw-post-body-paragraph kw kx it ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一旦JWT令牌被传入，请求被发送，我拥有的Passport.js中间件就获取授权头，解码JWT令牌并验证它是好的。如果你想了解更多关于用Reactjs / Node.js项目设置Passport的信息，你可以在这里阅读我的博客文章<a class="ae mr" rel="noopener ugc nofollow" target="_blank" href="/implementing-json-web-tokens-passport-js-in-a-javascript-application-with-react-b86b1f313436"/>。</p><p id="e387" class="pw-post-body-paragraph kw kx it ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是Swagger文档的代码片段，我想指出一些与之前不同的地方。</p><pre class="kp kq kr ks gt og mg oh oi aw oj bi"><span id="4c96" class="nt jr it mg b gy ok ol l om on">/**<br/><em class="no">* </em>@swagger<br/><em class="no">* /findUser:<br/>*   get:<br/>*     tags:<br/>*       - Users<br/>*     name: Find user<br/>*     summary: Finds a user<br/>*     security:<br/>*       - bearerAuth: []<br/>*     consumes:<br/>*       - application/json<br/>*     produces:<br/>*       - application/json<br/>*     parameters:<br/>*       - in: query<br/>*         name: username<br/>*         schema:<br/>*           type: string<br/>*         required:<br/>*           - username<br/>*     responses:<br/>*       200:<br/>*         description: A single user object<br/>*         schema:<br/>*           $ref: '#/definitions/User'<br/>*       401:<br/>*         description: No auth token<br/></em>*/</span></pre><p id="3c61" class="pw-post-body-paragraph kw kx it ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">除了<code class="fe md me mf mg b">security</code>选项，另一个区别是参数。正如我在前面提到的，如果用户输入是通过请求的查询参数，而不是请求体，那么参数看起来会有一点点不同。</p><p id="02fb" class="pw-post-body-paragraph kw kx it ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面是需要关注的部分——在<code class="fe md me mf mg b">parameters</code>下，<code class="fe md me mf mg b">-in</code>字段变成了<code class="fe md me mf mg b">query</code>而不是<code class="fe md me mf mg b">body</code>。这告诉Swagger传递请求的查询参数中需要的任何属性。</p><pre class="kp kq kr ks gt og mg oh oi aw oj bi"><span id="3df1" class="nt jr it mg b gy ok ol l om on">/** <br/> * @swagger<br/> * ...<br/> * parameters:<br/> *   - in: query<br/> * ...<br/> */</span></pre><p id="2f38" class="pw-post-body-paragraph kw kx it ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">另一件需要注意的事情是在文档底部的<code class="fe md me mf mg b">responses</code>部分。对于200 HTTP响应，它实际上会产生一个保存所有用户信息的<code class="fe md me mf mg b">application/json</code>对象。我需要引用用户模式，以便Swagger理解如何映射它接收到的响应对象，而不必再次写出所有的对象属性。</p><pre class="kp kq kr ks gt og mg oh oi aw oj bi"><span id="46a1" class="nt jr it mg b gy ok ol l om on"><em class="no">/** <br/>* @swagger <br/>* ...<br/>*     responses:<br/>*       200:<br/>*         description: A single user object<br/>*         schema:<br/>*           $ref: '#/definitions/User' <br/>* ...<br/></em>*/</span></pre><p id="dedc" class="pw-post-body-paragraph kw kx it ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">很好，现在我已经用Swagger详细描述了一条安全路线和一条不安全路线，现在是第三条稍微不同的路线的时候了。一封与密码重置邮件重合的邮件。</p><p id="1937" class="pw-post-body-paragraph kw kx it ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe md me mf mg b"><strong class="ky iu">resetPassword.js</strong></code> <strong class="ky iu"> —随机生成的字符串路径</strong></p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi oq"><img src="../Images/d81a61088660a2c96f666952ef113efe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tT0z6i4uKGkWCzHqgXQxkA.png"/></div></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk translated">安全路由的Swagger文档，需要一个随机生成的字符串。</figcaption></figure><p id="a82c" class="pw-post-body-paragraph kw kx it ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是我将在这里介绍的最后一个路由示例，如果您想查看我的所有路由(包括所有基本的CRUD功能和一些功能)，您可以查看我的<a class="ae mr" href="https://github.com/paigen11/mysql-registration-passport" rel="noopener ugc nofollow" target="_blank"> Github repo </a>。</p><p id="8b2f" class="pw-post-body-paragraph kw kx it ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我之所以包括这个，是因为这个路由实际上需要一个没有过期的随机生成的字符串，如果用户忘记了他们的登录密码，这个字符串将在电子邮件的正文中发送给用户。有点不同，也有点棘手，所以我觉得值得一试。</p><p id="2ba8" class="pw-post-body-paragraph kw kx it ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你想了解更多关于使用Node发送密码重置邮件的信息，你可以看看我写的这个<a class="ae mr" rel="noopener ugc nofollow" target="_blank" href="/password-reset-emails-in-your-react-app-made-easy-with-nodemailer-bb27968310d7">博客</a>。</p><p id="327b" class="pw-post-body-paragraph kw kx it ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面是Swagger文档的代码片段。</p><pre class="kp kq kr ks gt og mg oh oi aw oj bi"><span id="2467" class="nt jr it mg b gy ok ol l om on">/**<br/><em class="no">* </em>@swagger<br/><em class="no">* /reset:<br/>*   get:<br/>*     tags:<br/>*       - Users<br/>*     name: Reset Password Link<br/>*     summary: Create validation string in reset password link to verify user's allowed to reset their password<br/>*     consumes:<br/>*       - application/json<br/>*     parameters:<br/>*       - name: resetPasswordToken<br/>*         in: query<br/>*         schema:<br/>*           type: string<br/>*         required:<br/>*           - resetPasswordToken<br/>*     responses:<br/>*       '200':<br/>*         description: User's password reset link is valid<br/>*       '403':<br/>*         description: Password reset link is invalid or has expired<br/></em>*/</span></pre><p id="c07d" class="pw-post-body-paragraph kw kx it ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你真的看不出有什么大的区别，但是你会注意到，在<code class="fe md me mf mg b">parameters</code>下面的<code class="fe md me mf mg b">in</code>引用了一个<code class="fe md me mf mg b">query</code> param agin，这意味着需要包含发送到用户电子邮件地址的URL链接所附带的随机字符串，以验证密码重置是否得到授权。</p><p id="590b" class="pw-post-body-paragraph kw kx it ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我将在测试部分展示这个，它应该更有意义。</p><h2 id="3498" class="nt jr it bd js nu nv dn jw nw nx dp ka lh ny nz ke ll oa ob ki lp oc od km oe bi translated">总结一下</h2><p id="3f40" class="pw-post-body-paragraph kw kx it ky b kz ng lb lc ld nh lf lg lh ni lj lk ll nj ln lo lp nk lr ls lt im bi translated">现在，您已经看到了如何在JavaScript项目中设置<code class="fe md me mf mg b">swagger-jsdoc</code>和<code class="fe md me mf mg b">swagger-ui-express</code>。我修改了主<code class="fe md me mf mg b">server.js</code>文件，向<code class="fe md me mf mg b">User</code>对象模式添加了一个数据模型，并为三个单独的Node.js路径编写了Swagger文档。</p><p id="8f9d" class="pw-post-body-paragraph kw kx it ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了达到这一点，我最后参考了大量的OpenAPI规范文档和关于两个NPM模块的文档。不要害怕使用它们——它们实际上非常好，并且有大量的东西可以添加，使你的Swagger文档更加有用。</p><p id="25b1" class="pw-post-body-paragraph kw kx it ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">好了，说完了。让我们继续测试浏览器中的API。</p><h1 id="89dc" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">在浏览器中测试Swagger</h1><p id="dafe" class="pw-post-body-paragraph kw kx it ky b kz ng lb lc ld nh lf lg lh ni lj lk ll nj ln lo lp nk lr ls lt im bi translated">通过Swagger在浏览器中测试API对我来说实际上是一个非常好的练习，因为它发现了我在代码中犯的一些逻辑错误，并迫使我重新思考我是如何处理某些情况的(比如从服务器向客户端发送错误代码和消息)。</p><p id="b644" class="pw-post-body-paragraph kw kx it ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，首先，启动整个应用程序或API，无论你选择哪个。我喜欢直接加载全部内容，因为我写了一个单独的<code class="fe md me mf mg b">docker-compose.yml</code>文件，通过在终端中初始的<code class="fe md me mf mg b">docker-compose build</code>之后写<code class="fe md me mf mg b">docker-compose up</code>来处理所有的事情。</p><p id="d804" class="pw-post-body-paragraph kw kx it ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一旦api启动并运行，您就可以访问浏览器内界面，方法是将这个URL放入:<a class="ae mr" href="http://localhost:3003/api-docs/" rel="noopener ugc nofollow" target="_blank">http://localhost:3003/API-docs/</a>—至少，这是我的API的Docker容器运行的外部端口，并且“/API-docs/”URL路径是我在<code class="fe md me mf mg b">server.js</code> Swagger UI Express设置中指定的。</p><pre class="kp kq kr ks gt og mg oh oi aw oj bi"><span id="bdd3" class="nt jr it mg b gy ok ol l om on">app<em class="no">.</em>use('/api-docs', swaggerUi<em class="no">.</em>serve, swaggerUi<em class="no">.</em>setup(swaggerSpec));</span></pre><p id="f24c" class="pw-post-body-paragraph kw kx it ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您使用了不同的东西，请参考该URL路由。</p><p id="e6ba" class="pw-post-body-paragraph kw kx it ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，如果一切按计划进行，您应该会看到这样的屏幕。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi mx"><img src="../Images/152a3e002c33831a8c344282ed31a71c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xhvyEKG3BzeAXLHWM6GuCg.png"/></div></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk translated">这是我第一次点击URL时我的Swagger界面的样子。</figcaption></figure><p id="5541" class="pw-post-body-paragraph kw kx it ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">此时，您可以单击任何链接并测试您的API端点。我将首先测试我的<code class="fe md me mf mg b">/loginUser</code>端点。</p><p id="6825" class="pw-post-body-paragraph kw kx it ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所以我点击了那个帖子，点击了展开视图右上角的“试用”按钮，然后用有效的用户名和密码替换了两个“字符串”占位符(这将使用<code class="fe md me mf mg b">/registerUser</code>路径在数据库中创建)，并点击了下面的蓝色大“执行”按钮。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi or"><img src="../Images/80c61707077e1d4dd23ba66a8c3c5ced.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tnvRQZsPPWHmnfLvcTwSEQ.png"/></div></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk translated">填写请求正文(注意正文旁边的“*required”。</figcaption></figure><p id="0ed0" class="pw-post-body-paragraph kw kx it ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如上图所示，我们的请求主体输入是必需的(“*required”)，因此如果它们保留为空字符串，您将从API返回403“缺少凭据”响应。</p><p id="a0e6" class="pw-post-body-paragraph kw kx it ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我在Swagger文档中写下的所有响应代码都是为了解密刚刚发生的事情。下面是一个成功的200 HTTP登录响应的样子。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi os"><img src="../Images/b346037ea9c8841e961057d5e884ed54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sYI4PycJQHEQeaPFrVzcbw.png"/></div></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk translated">一个成功的200 HTTP响应。</figcaption></figure><p id="3d05" class="pw-post-body-paragraph kw kx it ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当在中输入有效的用户名和密码时，您可以从<code class="fe md me mf mg b">Curl</code>请求框中看到，该框显示了对API的确切调用(在调试不工作的调用时很有帮助)，<code class="fe md me mf mg b">/loginUser</code>路由返回一个带有<code class="fe md me mf mg b">token</code>属性的响应主体对象，该属性是JWT令牌，将存储在客户端的本地存储中，并在每个安全路由调用的授权头中传回。</p><p id="30f7" class="pw-post-body-paragraph kw kx it ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我现在将展示如何测试其中一条路线。我会用<code class="fe md me mf mg b">/findUser</code>路线。首先，从登录端点返回的<code class="fe md me mf mg b">token</code>属性中复制值，然后打开<code class="fe md me mf mg b">/findUser</code>输入，单击输入框右上角的小锁。这将为您打开一个输入JWT令牌字符串的模式。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi ot"><img src="../Images/e0bed42742abdbb327d58a76f90707b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2bPoyU6N_g-C6_5B30OHPQ.png"/></div></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk translated">JWT授权模式</figcaption></figure><p id="8d44" class="pw-post-body-paragraph kw kx it ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在“值”输入框中输入<code class="fe md me mf mg b">JWT &lt;token string&gt;</code>。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi ou"><img src="../Images/673d10e8b3ccc5a1d21f46061cf92f6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QCg9JoRqbhv7eKkN0Adq2A.png"/></div></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk translated">在输入框中添加“JWT <token string="">”并点击“授权”按钮。</token></figcaption></figure><p id="0f30" class="pw-post-body-paragraph kw kx it ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于我的特定应用程序，伴随每个请求的授权头需要在实际的JWT字符串之前加上<code class="fe md me mf mg b">JWT</code>。这个引用就是Passport如何找到正确的头字符串来解码和验证用户是否被授权。<strong class="ky iu">它必须包含在此格式中，此API调用才能工作。</strong>完成后，点击“授权”按钮，该路线的小锁图标将被锁定，您可以填写用户信息并测试您的呼叫。</p><p id="9533" class="pw-post-body-paragraph kw kx it ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是这个安全路由上的200 HTTP响应的样子。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi ov"><img src="../Images/c06df0b24d78b35410d1e82510c6c508.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rDmmFpNQIrcRIzmrUtmGXQ.png"/></div></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk translated">使用“授权”报头中的JWT令牌成功调用安全路由。</figcaption></figure><p id="2a1a" class="pw-post-body-paragraph kw kx it ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe md me mf mg b">Curl</code>请求框显示了带有用户名查询参数的路由，它显示了我在路由的锁中输入的授权JWT令牌，这是返回<code class="fe md me mf mg b">User</code>对象所需要的。如果没有JWT令牌，或者令牌无效，将发送401或403 HTTP响应。</p><p id="a9bd" class="pw-post-body-paragraph kw kx it ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我将展示的最后一个请求是一个处理密码重置电子邮件的Swagger请求(我在这里写的是关于实现<a class="ae mr" rel="noopener ugc nofollow" target="_blank" href="/password-reset-emails-in-your-react-app-made-easy-with-nodemailer-bb27968310d7"/>)。这个有点复杂，因为发送到用户电子邮件地址以重置密码的URL链接包含验证其有效性所需的查询字符串，并且只能在接下来的10分钟内有效。</p><p id="51b0" class="pw-post-body-paragraph kw kx it ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，如果用户将密码重置电子邮件发送到他们的收件箱，他们会收到一封带有如下图所示链接的电子邮件。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi ow"><img src="../Images/1a4a1a955d6957adcac345faa571dc42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*taQPuXNZK67VPjHne30cFA.png"/></div></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk translated">用户收到的重置邮件——末尾的随机字符串是Swagger需要的。</figcaption></figure><p id="16d3" class="pw-post-body-paragraph kw kx it ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从这里开始，用户需要复制<code class="fe md me mf mg b">/reset/</code>之后的字符串，并在发送后10分钟内将其粘贴到swagger <code class="fe md me mf mg b">/reset</code>路由中。这个随机生成的字符串附有一个时间戳，授权的一部分包括对照数据库检查字符串和时间戳。</p><p id="f6b0" class="pw-post-body-paragraph kw kx it ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果两者对该用户都有效，那么通过Swagger的成功验证应该是这样的。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi ox"><img src="../Images/a9f608f53535df6818e51b0e7ba03f39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*spTdQ9mx96n5wmv75lXk1w.png"/></div></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk translated">成功的200响应验证该用户的密码重置令牌有效，这允许他们到达安全路由以重置其密码。</figcaption></figure><p id="ec62" class="pw-post-body-paragraph kw kx it ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果字符串无效或者链接过期，Swagger会显示这条消息。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi oy"><img src="../Images/a52ab234d1fb2bdca18417ebcd7600db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EmwhacncGi7gfnpcaVARlg.png"/></div></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk translated">如果用户提交无效或已过期的密码重置令牌，将会出现403错误。</figcaption></figure><p id="3f85" class="pw-post-body-paragraph kw kx it ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我的朋友们，这就是你如何在浏览器中使用Swagger的便捷界面来测试你的API。</p><h1 id="c51a" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">结论</h1><p id="ea5f" class="pw-post-body-paragraph kw kx it ky b kz ng lb lc ld nh lf lg lh ni lj lk ll nj ln lo lp nk lr ls lt im bi translated">这就是如何在用于浏览器内API测试的JavaScript / Node.js应用程序中实现Swagger。初始设置并不像Java那样简单，但是对于JavaScript这样的解释型语言来说，一旦我掌握了其中的窍门，就真的不难了。</p><p id="149e" class="pw-post-body-paragraph kw kx it ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">过几周再来看看，我会写一些关于Reactjs或者其他与web开发相关的东西，所以请关注我，这样你就不会错过了。</p><p id="c003" class="pw-post-body-paragraph kw kx it ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">感谢您的阅读，我希望这能帮助您更轻松地记录和测试您自己的web应用程序。非常感谢鼓掌和分享！</p><p id="b968" class="pw-post-body-paragraph kw kx it ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="ky iu">如果你喜欢读这篇文章，你可能也会喜欢我的其他一些博客:</strong></p><ul class=""><li id="0216" class="oz pa it ky b kz la ld le lh pb ll pc lp pd lt pe pf pg ph bi translated"><a class="ae mr" rel="noopener ugc nofollow" target="_blank" href="/the-absolute-easiest-way-to-debug-node-js-with-vscode-2e02ef5b1bad">调试Node.js最简单的方法——用VS代码</a></li><li id="aae6" class="oz pa it ky b kz pi ld pj lh pk ll pl lp pm lt pe pf pg ph bi translated"><a class="ae mr" rel="noopener ugc nofollow" target="_blank" href="/keep-code-consistent-across-developers-the-easy-way-with-prettier-eslint-60bb7e91b76c">用更漂亮的&amp; ESLint </a>保持开发人员之间的代码一致</li><li id="ff53" class="oz pa it ky b kz pi ld pj lh pk ll pl lp pm lt pe pf pg ph bi translated"><a class="ae mr" rel="noopener ugc nofollow" target="_blank" href="/password-reset-emails-in-your-react-app-made-easy-with-nodemailer-bb27968310d7">使用Nodemailer简化React应用程序中的密码重置电子邮件</a></li></ul><p id="fe77" class="pw-post-body-paragraph kw kx it ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="ky iu">参考资料和更多资源:</strong></p><ul class=""><li id="b79d" class="oz pa it ky b kz la ld le lh pb ll pc lp pd lt pe pf pg ph bi translated">https://github.com/paigen11/mysql-registration-passport MERN JavaScript App回购:<a class="ae mr" href="https://github.com/paigen11/mysql-registration-passport" rel="noopener ugc nofollow" target="_blank"/></li><li id="e5fe" class="oz pa it ky b kz pi ld pj lh pk ll pl lp pm lt pe pf pg ph bi translated">霸气:【https://swagger.io/】T4</li><li id="72c7" class="oz pa it ky b kz pi ld pj lh pk ll pl lp pm lt pe pf pg ph bi translated">维基百科，Swagger(软件):<a class="ae mr" href="https://en.wikipedia.org/wiki/Swagger_(software)" rel="noopener ugc nofollow" target="_blank">https://en . Wikipedia . org/wiki/Swagger _(软件)</a></li><li id="d368" class="oz pa it ky b kz pi ld pj lh pk ll pl lp pm lt pe pf pg ph bi translated">OpenAPI规范(Swagger Specification):<a class="ae mr" href="https://swagger.io/docs/specification/about/" rel="noopener ugc nofollow" target="_blank">https://swagger.io/docs/specification/about/</a></li><li id="dd52" class="oz pa it ky b kz pi ld pj lh pk ll pl lp pm lt pe pf pg ph bi translated">https://www.npmjs.com/package/swagger-jsdoc NPM斯瓦格JSDoc:<a class="ae mr" href="https://www.npmjs.com/package/swagger-jsdoc" rel="noopener ugc nofollow" target="_blank"/></li><li id="4b40" class="oz pa it ky b kz pi ld pj lh pk ll pl lp pm lt pe pf pg ph bi translated">斯瓦格UI快递，https://www.npmjs.com/package/swagger-ui-express NPM:<a class="ae mr" href="https://www.npmjs.com/package/swagger-ui-express" rel="noopener ugc nofollow" target="_blank"/></li><li id="a4b6" class="oz pa it ky b kz pi ld pj lh pk ll pl lp pm lt pe pf pg ph bi translated">YAML Sytnax参考:<a class="ae mr" href="https://docs.ansible.com/ansible/latest/reference_appendices/YAMLSyntax.html" rel="noopener ugc nofollow" target="_blank">https://docs . ansi ble . com/ansi ble/latest/reference _ appendencies/yamlsyntax . html</a></li></ul></div></div>    
</body>
</html>