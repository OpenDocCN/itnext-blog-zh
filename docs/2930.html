<html>
<head>
<title>Light Authentication with Node.js, express and external authentication provider</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Node.js、express和外部身份验证提供程序进行简单身份验证</h1>
<blockquote>原文：<a href="https://itnext.io/https-medium-com-yarindeoh-light-authentication-with-nodejs-express-and-external-provider-3ad65e637608?source=collection_archive---------3-----------------------#2019-09-01">https://itnext.io/https-medium-com-yarindeoh-light-authentication-with-nodejs-express-and-external-provider-3ad65e637608?source=collection_archive---------3-----------------------#2019-09-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="9fd6" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">有多少次你被要求“创建一个工具”或“自动化一个过程”？可能很多，从那时起，你是如何管理你的认证的？本指南可以帮助您轻松地将身份验证添加到应用程序中。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/9757ac245276db9ead318ec381951462.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ztOLe3R1czY4ZLR7IpleLQ.png"/></div></div></figure><h1 id="f9d9" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">动机</h1><p id="086d" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">开发内部工具时，您可能有三种选择:</p><ol class=""><li id="a5ab" class="mf mg iq ll b lm mh lp mi ls mj lw mk ma ml me mm mn mo mp bi translated">您的应用程序正在运行，没有用户验证阶段。</li><li id="14bd" class="mf mg iq ll b lm mq lp mr ls ms lw mt ma mu me mm mn mo mp bi translated">你的生态系统已经有了一种认证“微服务”,可以提供你所需要的一切。</li><li id="deaa" class="mf mg iq ll b lm mq lp mr ls ms lw mt ma mu me mm mn mo mp bi translated">您可以使用外部身份验证提供程序(如吉拉)创建轻型身份验证代理，该提供程序支持单个域内多个应用程序的SSO。(耶，现在谁没有吉拉账户呢？)</li></ol><p id="6505" class="pw-post-body-paragraph lj lk iq ll b lm mh jr lo lp mi ju lr ls mv lu lv lw mw ly lz ma mx mc md me ij bi translated">当谈到内部工具时，您仍然倾向于采用标准的、安全的身份验证和最佳实践。您可能希望管理权限和访问控制、用户的视图和组，并确保API调用是安全的。</p><p id="75d8" class="pw-post-body-paragraph lj lk iq ll b lm mh jr lo lp mi ju lr ls mv lu lv lw mw ly lz ma mx mc md me ij bi translated">你猜对了，我们将讨论选项3！</p><p id="b8ab" class="pw-post-body-paragraph lj lk iq ll b lm mh jr lo lp mi ju lr ls mv lu lv lw mw ly lz ma mx mc md me ij bi translated">使用Node.js和外部身份验证提供者创建一个轻量级身份验证服务将允许您避免使用任何类型的存储/数据库组件，您将无需处理组和权限逻辑、令牌化<strong class="ll ir"> </strong>和其他“无聊”的安全特性。</p><p id="fb28" class="pw-post-body-paragraph lj lk iq ll b lm mh jr lo lp mi ju lr ls mv lu lv lw mw ly lz ma mx mc md me ij bi translated">使用外部认证提供商，如<a class="ae my" href="https://developer.atlassian.com/server/crowd/crowd-rest-apis/" rel="noopener ugc nofollow" target="_blank"> Atlassian Crowd Rest API </a>将为您提供一个可视化门户，您可以在其中轻松管理您的用户、组和权限，甚至可以从不同的应用程序导出现有的吉拉帐户/组。</p><p id="1fa3" class="pw-post-body-paragraph lj lk iq ll b lm mh jr lo lp mi ju lr ls mv lu lv lw mw ly lz ma mx mc md me ij bi translated">我发现的唯一缺点是你依赖于第三方提供商。但是，当你想到它有多普遍，以及你能得到的所有这些免费和酷的特性时，权衡就很明显了。</p><h1 id="2753" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">体系结构</h1><h2 id="23c1" class="mz ks iq bd kt na nb dn kx nc nd dp lb ls ne nf ld lw ng nh lf ma ni nj lh nk bi translated">高层建筑</h2><p id="da20" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">我们在游戏中有4个玩家:</p><ul class=""><li id="a606" class="mf mg iq ll b lm mh lp mi ls mj lw mk ma ml me nl mn mo mp bi translated"><strong class="ll ir">前端</strong>——代表所有UI组件和用户视角。</li><li id="e1b5" class="mf mg iq ll b lm mq lp mr ls ms lw mt ma mu me nl mn mo mp bi translated"><strong class="ll ir">后端服务器</strong>——响应业务逻辑调用。</li><li id="2fdb" class="mf mg iq ll b lm mq lp mr ls ms lw mt ma mu me nl mn mo mp bi translated"><strong class="ll ir"> Web服务器</strong> -中间层组件，用作代理，与现场的所有其他组件通信。</li><li id="1c12" class="mf mg iq ll b lm mq lp mr ls ms lw mt ma mu me nl mn mo mp bi translated"><strong class="ll ir">认证提供者</strong>——外部提供者，如<a class="ae my" href="https://developer.atlassian.com/server/crowd/crowd-rest-apis/" rel="noopener ugc nofollow" target="_blank"> Atlassian Crowd Rest API </a>。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/bd28c9f7fcd166989964c78272c8b93b.png" data-original-src="https://miro.medium.com/v2/resize:fit:942/format:webp/1*Gu5pzWiT-INXHtaO8_yf3g.png"/></div></figure><p id="60b0" class="pw-post-body-paragraph lj lk iq ll b lm mh jr lo lp mi ju lr ls mv lu lv lw mw ly lz ma mx mc md me ij bi translated">该系统的目的是在认证问题上提供一个真实的来源，该来源仅由web服务器中间件使用。</p><p id="9c2c" class="pw-post-body-paragraph lj lk iq ll b lm mh jr lo lp mi ju lr ls mv lu lv lw mw ly lz ma mx mc md me ij bi translated">所有请求将从前端寻址到/代理路由器。/proxy/*请求将根据请求的路径进行管理。代理路由器将接受请求，通过身份验证提供者对其进行身份验证，与后端服务器通信，并将响应发送回前端。</p><h2 id="98b9" class="mz ks iq bd kt na nb dn kx nc nd dp lb ls ne nf ld lw ng nh lf ma ni nj lh nk bi translated">序列图</h2><p id="d248" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated"><strong class="ll ir">登录</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/4eb69d57e45f243becc324f15157db42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1262/format:webp/1*O8go_QU2_OaCAICkLrzn6A.png"/></div></figure><p id="eedb" class="pw-post-body-paragraph lj lk iq ll b lm mh jr lo lp mi ju lr ls mv lu lv lw mw ly lz ma mx mc md me ij bi translated">一个新用户正在启动登录页面，插入用户名和密码。API请求正在发送到web服务器，该服务器正在使用提供的凭据创建会话。身份验证提供程序使用包含用户令牌的会话对象进行响应。web服务器将加密的令牌发送到FE，FE将其保存在本地存储中。</p><p id="b76e" class="pw-post-body-paragraph lj lk iq ll b lm mh jr lo lp mi ju lr ls mv lu lv lw mw ly lz ma mx mc md me ij bi translated">如果是登录页面中的返回用户，FE将发送一个包含已保存令牌的身份验证请求，并在验证通过时重定向到应用程序。</p><p id="18e9" class="pw-post-body-paragraph lj lk iq ll b lm mh jr lo lp mi ju lr ls mv lu lv lw mw ly lz ma mx mc md me ij bi translated"><strong class="ll ir">认证失败</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi no"><img src="../Images/05d529bd66aac47f2d64a6e9a4598128.png" data-original-src="https://miro.medium.com/v2/resize:fit:1386/format:webp/1*ZT4qpyCQPb9O5frWCad2RQ.png"/></div></figure><p id="e0ac" class="pw-post-body-paragraph lj lk iq ll b lm mh jr lo lp mi ju lr ls mv lu lv lw mw ly lz ma mx mc md me ij bi translated">所有Rest请求都将使用用户令牌发送到web服务器。Web服务器将发送带有令牌的身份验证请求，并将错误响应发送回FE，FE将重定向到登录页面并清除其本地存储。</p><p id="8545" class="pw-post-body-paragraph lj lk iq ll b lm mh jr lo lp mi ju lr ls mv lu lv lw mw ly lz ma mx mc md me ij bi translated"><strong class="ll ir">认证成功</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/ed20334e120310173850fb3c64d4d1cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RHXiHxUuLmaTmCsGki1gxg.png"/></div></div></figure><p id="aba3" class="pw-post-body-paragraph lj lk iq ll b lm mh jr lo lp mi ju lr ls mv lu lv lw mw ly lz ma mx mc md me ij bi translated">当web服务器收到经过验证的令牌响应时，它会根据请求的路径url和有效负载来处理原始请求。</p><h1 id="0f3c" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">给我看一些代码</h1><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div><figcaption class="ns nt gj gh gi nu nv bd b be z dk translated">server.js</figcaption></figure><p id="45ab" class="pw-post-body-paragraph lj lk iq ll b lm mh jr lo lp mi ju lr ls mv lu lv lw mw ly lz ma mx mc md me ij bi translated">带有代理路由器的基本Node.js express服务器。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div><figcaption class="ns nt gj gh gi nu nv bd b be z dk translated">proxy.js</figcaption></figure><p id="7600" class="pw-post-body-paragraph lj lk iq ll b lm mh jr lo lp mi ju lr ls mv lu lv lw mw ly lz ma mx mc md me ij bi translated">代理路由器将获得所有方法请求并处理它们，除了/proxy/api请求，它将由一个名为login的子路由器处理。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div><figcaption class="ns nt gj gh gi nu nv bd b be z dk translated">login.js</figcaption></figure><p id="42c0" class="pw-post-body-paragraph lj lk iq ll b lm mh jr lo lp mi ju lr ls mv lu lv lw mw ly lz ma mx mc md me ij bi translated">你需要创建一个群组服务器(<a class="ae my" href="https://confluence.atlassian.com/crowd/installing-crowd-and-crowdid-191862.html" rel="noopener ugc nofollow" target="_blank">按照吉拉的指示</a>)。并根据您的应用程序需求进行配置。</p><p id="9a13" class="pw-post-body-paragraph lj lk iq ll b lm mh jr lo lp mi ju lr ls mv lu lv lw mw ly lz ma mx mc md me ij bi translated">对于上面的例子，我使用了<a class="ae my" href="https://github.com/ghengeveld/atlassian-crowd-client#atlassian-crowd-client" rel="noopener ugc nofollow" target="_blank"> atlassian-crowd-client </a>，这是一个基于promise的客户端库，用于从Node与Atlassian Crowd服务器通信，用ES6编写。它只为我处理响应和错误，如果你愿意，你可以直接与<a class="ae my" href="https://docs.atlassian.com/atlassian-crowd/3.1.2/REST/?_ga=2.133030030.1220822418.1564918095-843970779.1553945401#admin/1.0/auditlog-getConfiguration" rel="noopener ugc nofollow" target="_blank">Crowd REST API</a>通信。</p><h1 id="d8f7" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">摘要</h1><p id="7d64" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">这段代码是轻量级的！您可以轻松地为您的内部工具创建认证服务，并获得一些免费的和很酷的功能，这些功能将允许您像专业人士一样以安全的方式管理您的应用程序。</p><p id="94b9" class="pw-post-body-paragraph lj lk iq ll b lm mh jr lo lp mi ju lr ls mv lu lv lw mw ly lz ma mx mc md me ij bi translated">PM提问和<strong class="ll ir">在twitter上关注我</strong><a class="ae my" href="https://twitter.com/DekelYarin" rel="noopener ugc nofollow" target="_blank"><strong class="ll ir">@ DekelYarin</strong></a><strong class="ll ir">。</strong></p></div></div>    
</body>
</html>