<html>
<head>
<title>Helm 3 — Secrets management, an alternative approach</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">掌舵3 —秘密管理，一种替代方法</h1>
<blockquote>原文：<a href="https://itnext.io/helm-3-secrets-management-4f23041f05c3?source=collection_archive---------0-----------------------#2021-04-27">https://itnext.io/helm-3-secrets-management-4f23041f05c3?source=collection_archive---------0-----------------------#2021-04-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/dcda151be4d4c287372b82b3010ad989.png" data-original-src="https://miro.medium.com/v2/resize:fit:1120/format:webp/1*aY8QVdazCAm-fCL03zR0Rw.png"/></div></figure><p id="cf08" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在Kubernetes中有许多管理秘密的方法，有些方法比其他方法简单，但当我在工作中为我的项目研究这个主题时，我发现许多这些方法都有缺点。当在任何现代软件系统中管理你的秘密时，你需要考虑许多重要的方面。对我的项目来说，这些是最重要的:</p><ol class=""><li id="fc8d" class="ks kt iq jw b jx jy kb kc kf ku kj kv kn kw kr kx ky kz la bi translated">所有的秘密都必须存储在版本控制中。对于任何基于Helm的部署来说，这都是一个至关重要的方面，在我看来，如果您的任何管道步骤涉及手动干预，即填充机密，您将有效地削弱自动化CD管道的优势。</li><li id="d33f" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated"><strong class="jw ir">所有打包的舵图必须加密。</strong>为您的项目将您的图表发布到图表博物馆时，重要的是不要公开存储任何秘密。这意味着在你打包图表并把它放进图表博物馆之前，秘密必须被加密。相反，机密应该只在安装/升级阶段的运行时解密。</li><li id="57ed" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated"><strong class="jw ir">统治他们的工具——头盔！</strong>对我来说，另一个更私人的要求是只依靠Helm。以<a class="ae lg" href="https://github.com/jkroepke/helm-secrets" rel="noopener ugc nofollow" target="_blank">掌舵秘笈</a>为例；非CNCF项目往往会在一段时间后被扔进垃圾堆，或者转向不同的方向。当核心软件升级出现不兼容时，依赖小的边缘工具又回来咬我，让你陷入困境。</li></ol><h1 id="af19" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">探索现有工具</h1><p id="3d6b" class="pw-post-body-paragraph ju jv iq jw b jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn mj kp kq kr ij bi translated">在开始构建任何自己的工具或脚本之前，了解已经存在的东西是很重要的。对于基于头盔的Kubernetes装置，有多种选择:</p><h2 id="7966" class="mk li iq bd lj ml mm dn ln mn mo dp lr kf mp mq lv kj mr ms lz kn mt mu md mv bi translated"><strong class="ak">掌舵秘笈</strong></h2><p id="6131" class="pw-post-body-paragraph ju jv iq jw b jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn mj kp kq kr ij bi translated"><a class="ae lg" href="https://github.com/jkroepke/helm-secrets" rel="noopener ugc nofollow" target="_blank">这是赫尔姆</a>最知名的秘密管理工具之一。简而言之，这个工具加密Helm中的特定值文件。任何以前缀“secrets”开头的值文件在签入Git之前都会被完全加密。</p><p id="fb18" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">缺点:</p><ul class=""><li id="b675" class="ks kt iq jw b jx jy kb kc kf ku kj kv kn kw kr mw ky kz la bi translated">这个工具有一个主要缺点；即多值文件。这个工具允许你在安装/升级头盔时使用一个包装器，比如“头盔秘密升级”。主要问题是Helm目前不支持打包图表中的多个值文件。如果程序包图表中有多个值文件，首先需要提取该图表，然后通过命令行传递多个值。这不优雅。</li><li id="2370" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr mw ky kz la bi translated">通过将所有秘密限制在它自己的文件中，您失去了值文件的可读性。如果您有多组设置(就像我的项目一样)，将秘密移动到它们自己的文件中会导致可读性的损失，最终导致维护的损失。我不得不承认，这很可能是一种个人偏好，让事情保持在一起。</li></ul><h2 id="8635" class="mk li iq bd lj ml mm dn ln mn mo dp lr kf mp mq lv kj mr ms lz kn mt mu md mv bi translated">哈希公司金库</h2><p id="4e51" class="pw-post-body-paragraph ju jv iq jw b jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn mj kp kq kr ij bi translated">Hashicorp的Vault 可能是与Kubernetes合作时最常见的秘密管理解决方案之一。我不打算详细介绍Vault能做什么，但对我来说，Kubernetes集群中的Vault面临着先有鸡还是先有蛋的问题…</p><p id="9594" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">缺点:</p><ul class=""><li id="bb2e" class="ks kt iq jw b jx jy kb kc kf ku kj kv kn kw kr mw ky kz la bi translated">也就是说，什么填充了Vault？如果手动这样做，就无法将机密管理集成到CI/CD管道中。自动化不是我决定研究的东西，因为从Helm集成到Vault的本地工具不存在，所以必须找到一个定制的解决方案。</li><li id="8361" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr mw ky kz la bi translated">需要安装一个Vault实例。从表面上看，这当然不是问题，但是如果您只有少量的秘密，那么设置一个需要在启动时自动解封的Vault实例可能是一个相当棘手的解决方案。</li></ul><h1 id="ef7e" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">自定义解决方案</h1><p id="eeb2" class="pw-post-body-paragraph ju jv iq jw b jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn mj kp kq kr ij bi translated">鉴于上述解决方案的一些局限性，我决定更深入地研究本机Helm功能中内置的加密/解密选项。谢天谢地，Helm有两个方便的<a class="ae lg" href="https://helm.sh/docs/chart_template_guide/function_list/#cryptographic-and-security-functions" rel="noopener ugc nofollow" target="_blank">内置函数</a>。这些功能，加密和解密，允许在Helm的秘密管理。综上所述，我提出的解决方案借用了<a class="ae lg" href="https://github.com/jkroepke/helm-secrets" rel="noopener ugc nofollow" target="_blank">掌舵秘笈</a>中的一些概念，如下所示:</p><h2 id="9491" class="mk li iq bd lj ml mm dn ln mn mo dp lr kf mp mq lv kj mr ms lz kn mt mu md mv bi translated">1.舵图</h2><p id="e923" class="pw-post-body-paragraph ju jv iq jw b jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn mj kp kq kr ij bi translated">首先，我开始写一个小的舵图，它包含三个可能的值，如下面的值文件中所列。这个舵图使用了一个基本的配置图，我只用于输出(我们不会使用配置图)</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="447d" class="mk li iq nc b gy ng nh l ni nj">aesKey: set<br/>valueToEncrypt: set<br/>valueToDecrypt: set</span></pre><p id="d586" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">配置图如下所示:</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="4919" class="mk li iq nc b gy ng nh l ni nj"><strong class="nc ir">apiVersion</strong>: v1<br/><strong class="nc ir">kind</strong>: ConfigMap<br/>  <strong class="nc ir">name</strong>: game-config<br/><strong class="nc ir">data</strong>:<br/>  <strong class="nc ir">encryptedValue</strong>: {{ encryptAES .Values.valueToEncrypt (.Values.aesKey | b64dec)}}<br/>  <strong class="nc ir">decryptedValue</strong>: {{ .Values.valueToDecrypt | decryptAES (.Values.aesKey | b64dec) }}</span></pre><p id="1b77" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这个舵图满足了我的第三个要求——使用本地工具。使用Helm加密/解密机密的另一个原因是底层Go引擎对AES加密和解密的实现与OpenSSL加密的AES机密不兼容。换句话说，Helm将无法解密OpenSSL加密的秘密。</p><h2 id="e454" class="mk li iq bd lj ml mm dn ln mn mo dp lr kf mp mq lv kj mr ms lz kn mt mu md mv bi translated"><strong class="ak"> 2。包装脚本</strong></h2><p id="ad5e" class="pw-post-body-paragraph ju jv iq jw b jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn mj kp kq kr ij bi translated">接下来，我编写了一个名为secure.sh的包装器脚本，它利用了上面指定的舵图。该脚本采用以下参数:</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="5f2a" class="mk li iq nc b gy ng nh l ni nj">Options:<br/>-e    Encrypt a Helm chart's values file<br/>-d    Decrypt a Helm chart's values file<br/>-c    Clean the working directory<br/>-w    Overwrite values file with encrypted values file</span><span id="c58d" class="mk li iq nc b gy nk nh l ni nj">Flags:<br/>-p    The path to a Helm chart<br/>-k    The AES key (used in both encryptions and decryption)<br/>-x    Prefix of the key names to encrypt (defaults to "encrypted")</span></pre><p id="8dcf" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">当指定<em class="nl"> -e </em> (encrypt)选项时，该脚本将在values.yaml文件中搜索所有以关键字“encrypted”开头的密钥。这可以用<em class="nl"> -x </em>标志来改变。一个名为<em class="nl"> values.enc.yaml </em>的新文件被创建，所有密钥都被加密。下面显示了一个加密执行示例:</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="6c29" class="mk li iq nc b gy ng nh l ni nj">secure.sh -e -p /path/to/chart -k fTjWnZr4u7x!A%D*G-KaNdRgUkXp2s5v</span></pre><p id="36b8" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这种方法的好处是，加密的值存储在与所有其他秘密相同的 values.yaml文件中。</p><p id="7ab4" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">要用加密值覆盖值文件，需要执行以下命令:</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="fd8a" class="mk li iq nc b gy ng nh l ni nj">secure.sh -w -p /path/to/chart</span></pre><p id="b659" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">解密加密图表时，会生成一个<em class="nl"> values.dec.yaml </em>文件。可以运行以下命令来生成此文件:</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="9c91" class="mk li iq nc b gy ng nh l ni nj">secure.sh -d -p /path/to/chart -k fTjWnZr4u7x!A%D*G-KaNdRgUkXp2s5v</span></pre><p id="ba68" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">解密后的文件可用于解决密码问题、与其他文件进行比较等。</p><p id="1cc5" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">最后，可以使用以下命令清理临时文件:</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="00b0" class="mk li iq nc b gy ng nh l ni nj">secure.sh -w -p /path/to/chart</span></pre><h2 id="e755" class="mk li iq bd lj ml mm dn ln mn mo dp lr kf mp mq lv kj mr ms lz kn mt mu md mv bi translated">3.Git配置</h2><p id="f002" class="pw-post-body-paragraph ju jv iq jw b jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn mj kp kq kr ij bi translated">配置的倒数第二部分是确保Git不会意外签入任何临时文件。这可以通过将文件<em class="nl"> values.enc.yaml </em>和<em class="nl"> values.dec.yaml </em>添加到<em class="nl">来实现。gitignore项目中的</em>文件。如果您忘记清理任何文件，可以肯定Git将跳过这些文件。</p><p id="c94f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">最后，如果您使用CI/CD管道来安装您的Helm charts，您可以存储AES密钥，该密钥将加密和解密您的敏感机密作为管道机密，并将其作为命令行参数传递给管道中的包装器。如果你正在使用Gitlab，在Gitlab变量中放置秘密时，一定要检查“屏蔽”选项，并确定你的团队中谁可以访问这些变量。请注意，Gitlab中的掩码变量不能包含非base64编码的字符。因此，上述示例首先从base64解码AES密钥。</p><h1 id="5587" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">结论</h1><p id="3aa3" class="pw-post-body-paragraph ju jv iq jw b jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn mj kp kq kr ij bi translated">我通常不提倡编写自己的工具。在大多数情况下，利用现有的工具来完成大多数事情是可能的。然而，尽管如此，这个工具解决了我们项目中的许多问题。</p><ul class=""><li id="533f" class="ks kt iq jw b jx jy kb kc kf ku kj kv kn kw kr mw ky kz la bi translated">我们能够加密存储在我们的舵图中的秘密。</li><li id="217f" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr mw ky kz la bi translated">我们能够将舵图打包并上传到海图博物馆，所有的秘密都被加密。</li><li id="edbf" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr mw ky kz la bi translated">我们能够将加密的秘密存储在Git中，而不用担心我们的秘密会以明文形式存储。</li><li id="3aad" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr mw ky kz la bi translated">当我们使用一个自定义脚本时，这个脚本相当简单明了，只是简单地包装了本地/内置的Helm功能。</li></ul><p id="f9d9" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><em class="nl"> 27/04/2021注:一旦我修复了一个小bug并使其更加人性化，我会把这个插件上传到Github。</em></p><p id="a1f1" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><em class="nl">25/07/2021——你现在可以找到这个插件@ </em> <a class="ae lg" href="https://github.com/chris-parker-za/helm-encryption" rel="noopener ugc nofollow" target="_blank">克里斯-帕克-扎/赫尔姆-加密(github.com)</a></p></div></div>    
</body>
</html>