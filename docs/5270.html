<html>
<head>
<title>Use Puppeteer and Nodejs to take screenshots and PDFs — as a Service</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Puppeteer和Nodejs来截图和pdf——作为一项服务</h1>
<blockquote>原文：<a href="https://itnext.io/use-puppeteer-and-nodejs-to-take-screenshots-and-pdfs-as-a-service-242c207ab851?source=collection_archive---------3-----------------------#2021-01-29">https://itnext.io/use-puppeteer-and-nodejs-to-take-screenshots-and-pdfs-as-a-service-242c207ab851?source=collection_archive---------3-----------------------#2021-01-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="70ff" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">你有没有想过一个简单的解决方案，以编程方式创建截图？</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/58ab924b4352f8ee699dd64a1c386cd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5NgR35ht5FKleOWt_65wtw.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">在<a class="ae kv" href="https://unsplash.com/s/photos/printing?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上<a class="ae kv" href="https://unsplash.com/@bank_phrom?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">银行Phrom </a>拍摄的照片</figcaption></figure><p id="17d9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">作为一名开发人员，我想创建一个简单的服务，创建动态网站，并通过截图和PDF轻松共享。我本可以创建一个简单的NodeJS应用程序(<a class="ae kv" href="https://thenextweb.com/syndication/2021/01/10/how-to-turn-web-pages-into-pdfs-with-puppeteer-and-nodejs/" rel="noopener ugc nofollow" target="_blank">，就像本文</a>中描述的那样)来一次性解决问题，但是我想:“为什么不把它变成一个简单的服务呢？”。</p><p id="af6e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">基础部分——一个简单的NodeJS应用程序生成一个由木偶师控制的无头浏览器来从网站上捕捉屏幕截图和图像——已经就绪，但现在我想让它更加通用和易于使用。</p><h2 id="2979" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">什么是多一点？</h2><ul class=""><li id="316a" class="ml mm iq ky b kz mn lc mo lf mp lj mq ln mr lr ms mt mu mv bi translated">一个简单明了的API</li><li id="5d13" class="ml mm iq ky b kz mw lc mx lf my lj mz ln na lr ms mt mu mv bi translated">参数验证</li><li id="d1ca" class="ml mm iq ky b kz mw lc mx lf my lj mz ln na lr ms mt mu mv bi translated">证明文件</li><li id="c46e" class="ml mm iq ky b kz mw lc mx lf my lj mz ln na lr ms mt mu mv bi translated">测试</li><li id="3dfb" class="ml mm iq ky b kz mw lc mx lf my lj mz ln na lr ms mt mu mv bi translated">安全考虑</li><li id="7f5e" class="ml mm iq ky b kz mw lc mx lf my lj mz ln na lr ms mt mu mv bi translated">Docker图像</li><li id="5fe0" class="ml mm iq ky b kz mw lc mx lf my lj mz ln na lr ms mt mu mv bi translated">简单部署到例如Heroku</li></ul><h2 id="346d" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">API</h2><p id="e3da" class="pw-post-body-paragraph kw kx iq ky b kz mn jr lb lc mo ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">我决定用ExpressJS生成一个简单的NodeJS服务。很简单，由两个端点组成:<strong class="ky ir"> /api/shot </strong>和<strong class="ky ir"> /api/pdf </strong>。</p><p id="d019" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我使用<a class="ae kv" href="https://www.npmjs.com/package/apidoc" rel="noopener ugc nofollow" target="_blank"> apidoc </a>在我的代码内创建文档，一旦我构建了文档，它就可以在<strong class="ky ir"> /docs </strong> ( <a class="ae kv" href="https://the-snap.herokuapp.com/docs/" rel="noopener ugc nofollow" target="_blank">预览</a>)下获得。</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="a5c2" class="ls lt iq nf b gy nj nk l nl nm">//...<br/>/**<br/> * @api {get} /pdf obtain a pdf of a page<br/> * @apiName TakeScreenshot<br/> * @apiGroup PDF<br/> * @apiVersion 1.0.0<br/> *<br/> * @apiParam {String} url a url to be looked up<br/> * @apiParam {Number} [w] width of the viewport<br/> * @apiParam {Number} [h] height of the viewport<br/> * @apiParam {String} [d] device to use for the viewport - overwrites other v/h parameters<br/> *<br/> * @apiSuccess {File} pdf the generated pdf<br/> * @apiError {Object} Errors returned errors<br/> */<br/>//...</span></pre><p id="0826" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="nn">文件</em></p><p id="abf6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">除了文档之外，我决定使用<a class="ae kv" href="https://www.npmjs.com/package/ajv" rel="noopener ugc nofollow" target="_blank"> ajv </a>进行参数验证，因为它非常快并且维护良好。模式位于schema.js中，非常简单。</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="f7f3" class="ls lt iq nf b gy nj nk l nl nm">const { devices } = require('./util');<br/><br/>const screenshotSchema = {<br/>  title: 'Page screenshot',<br/>  description: 'Take screenshot of a page',<br/>  type: 'object',<br/>  properties: {<br/>    url: {<br/>      type: 'string',<br/>      format: 'uri',<br/>      pattern: '^(https?|http?)://',<br/>      minLength: 1,<br/>      maxLength: 255,<br/>    },<br/>    selector: {<br/>      type: 'string',<br/>      minLength: 1,<br/>      maxLength: 255,<br/>    },<br/>  },<br/>  required: ['url'],<br/>};<br/><br/>const pdfSchema = {<br/>  title: 'PDF page print',<br/>  description: 'Take pdf of a page',<br/>  type: 'object',<br/>  properties: {<br/>    url: {<br/>      type: 'string',<br/>      format: 'uri',<br/>      pattern: '^(https?|http?)://',<br/>      minLength: 1,<br/>      maxLength: 255,<br/>    },<br/>    w: {<br/>      type: 'integer',<br/>      minimum: 1,<br/>      maximum: 12288,<br/>    },<br/>    h: {<br/>      type: 'integer',<br/>      minimum: 1,<br/>      maximum: 12288,<br/>    },<br/>    d: {<br/>      type: 'string',<br/>      enum: Object.keys(devices),<br/>    },<br/>  },<br/>  required: ['url'],<br/>};<br/><br/>module.exports = { screenshotSchema, pdfSchema };</span></pre><p id="4992" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我只需要确保用每个端点的模式验证我的请求参数。</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="450a" class="ls lt iq nf b gy nj nk l nl nm">//...<br/>router.get('/shot', async (req, res) =&gt; {<br/>  const validate = ajv.compile(screenshotSchema);<br/>  const result = await validate(req.query);<br/>  if (!result) {<br/>    const errors = await parseAJVErrors(validate.errors);<br/>    // return with the validation errors<br/>    return res.status(400).json({ errors });<br/>  }<br/>  const { url, selector } = req.query;<br/>//use the params now</span></pre><p id="cd47" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="nn">参数验证</em></p><p id="20c9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我们希望有一个简单的API——只有两个端点回复GET请求。一份截图可在<em class="nn"> /api/shot </em>获取，另一份pdf可在<em class="nn"> /api/pdf </em>获取。当我们处理GET请求时，我们只支持查询参数。</p><p id="2fae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="nn">简单的应用编程接口</em></p><h1 id="d1c8" class="no lt iq bd lu np nq nr lx ns nt nu ma jw nv jx md jz nw ka mg kc nx kd mj ny bi translated">测试</h1><p id="f481" class="pw-post-body-paragraph kw kx iq ky b kz mn jr lb lc mo ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">这是一个关键的区别，不仅要将项目发布为开源项目，而且还要有一组测试，其他人可以通过运行测试来验证功能。</p><p id="5a8d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我决定在这个项目中尝试一下<a class="ae kv" href="https://github.com/avajs/ava" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"/></a>，我不得不承认，它为你的主要功能提供了一个真实的体验。</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="c5b9" class="ls lt iq nf b gy nj nk l nl nm">const test = require('ava');<br/>const { shot: screenshot, pdf } = require('./capture');<br/>const fs = require('fs');<br/><br/>test('create screenshots', async (t) =&gt; {<br/>  const screenshotBuffer = await screenshot({ url: 'https://www.google.com' });<br/>  t.assert(<br/>    screenshotBuffer.toString('binary').length &gt; 1,<br/>    'Should have generated a screenshot',<br/>  );<br/>});<br/>test('create screenshot by selector', async (t) =&gt; {<br/>  const screenshotSelectorBuffer = await screenshot({<br/>    url: 'https://card-joy.web.app/v?img=c1&amp;t=Merry%20Christmas!&amp;p=topLeft',<br/>    selector: '#root &gt; div &gt; div &gt; div &gt; img',<br/>  });<br/>  t.assert(<br/>    screenshotSelectorBuffer.toString('binary').length &gt; 1,<br/>    'Should have generated a screenshot',<br/>  );<br/>});<br/>test('create pdf', async (t) =&gt; {<br/>  const generated = await pdf({ url: 'https://www.google.com' });<br/>  t.assert(generated.length &gt; 0, 'Should have generated a pdf');<br/>});</span></pre><p id="f97e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我将package.json中的测试命令设置为<em class="nn">“test”:“ava—verbose”</em>—使用verbose来获取每个测试用例的更多信息。</p><p id="deec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="nn">测试</em></p><h1 id="fdb8" class="no lt iq bd lu np nq nr lx ns nt nu ma jw nv jx md jz nw ka mg kc nx kd mj ny bi translated">安全性</h1><p id="aeb3" class="pw-post-body-paragraph kw kx iq ky b kz mn jr lb lc mo ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">由于这是一项服务，可以作为单一用途的微服务轻松地纳入现有项目，我决定使用<a class="ae kv" href="https://www.npmjs.com/package/helmet" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">头盔</strong> </a>来保护Express应用程序，该应用程序设置了各种HTTP头以减少常见的安全隐患。</p><p id="4e50" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后但同样重要的是，我添加了速率限制，默认为每个IP每15分钟20个请求，并存储在内存中。</p><p id="e428" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="nn">涵盖的常见安全隐患</em></p><h1 id="c5a5" class="no lt iq bd lu np nq nr lx ns nt nu ma jw nv jx md jz nw ka mg kc nx kd mj ny bi translated">部署</h1><p id="618d" class="pw-post-body-paragraph kw kx iq ky b kz mn jr lb lc mo ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">这项服务可以很容易地用docker运行。该映像包包括chrome浏览器在内的所有依赖项。</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="8c89" class="ls lt iq nf b gy nj nk l nl nm">$ docker run -it --rm -p 3000:3000 chrkaatz/the-snap</span></pre><p id="5057" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">或者如果你已经有了一个Heroku帐号，你可以使用项目上的<em class="nn">部署到Heroku </em>按钮。</p><p id="be3c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于设置，我添加了包含以下内容的<em class="nn"> app.json </em>,以使用Nodejs和一个Buildpack来支持在Heroku中使用puppeteer。</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="93f1" class="ls lt iq nf b gy nj nk l nl nm">{<br/>    "name": "The Snap",<br/>    "description": "A simple service to obtain screenshots and PDFs from pages",<br/>    "repository": "https://github.com/chrkaatz/the-snap",<br/>    "logo": "https://github.com/chrkaatz/the-snap/raw/main/logo.png",<br/>    "keywords": ["node", "puppeteer", "screenshot", "api", "pdf"],<br/>    "buildpacks": [<br/>        {<br/>            "url": "heroku/nodejs"<br/>        },<br/>        {<br/>          "url": "https://buildpack-registry.s3.amazonaws.com/buildpacks/jontewks/puppeteer.tgz"<br/>        }<br/>    ],<br/>    "env": {<br/>        "HUSKY": {<br/>            "description": "Disable git hooks managed by husky",<br/>            "value": "0"<br/>        }<br/>    }<br/>  }</span></pre><p id="813e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="nn">部署</em></p><h1 id="adf6" class="no lt iq bd lu np nq nr lx ns nt nu ma jw nv jx md jz nw ka mg kc nx kd mj ny bi translated">密码</h1><p id="31d9" class="pw-post-body-paragraph kw kx iq ky b kz mn jr lb lc mo ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">在https://github.com/chrkaatz/the-snap可以找到源代码，在https://the-snap.herokuapp.com/<a class="ae kv" href="https://the-snap.herokuapp.com/" rel="noopener ugc nofollow" target="_blank">可以找到工作版本。</a></p><p id="879d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后说明:主页是用<a class="ae kv" href="https://github.com/andybrewer/mvp" rel="noopener ugc nofollow" target="_blank"> MVP.css </a>做的，用起来超级简单。只花了5分钟…</p></div></div>    
</body>
</html>