<html>
<head>
<title>Heap (Priority Queue) — Identify Pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">堆(优先级队列)—识别模式</h1>
<blockquote>原文：<a href="https://itnext.io/heap-priority-queue-identify-pattern-aaedda7b3f6b?source=collection_archive---------6-----------------------#2022-07-04">https://itnext.io/heap-priority-queue-identify-pattern-aaedda7b3f6b?source=collection_archive---------6-----------------------#2022-07-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><h1 id="2706" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">介绍</h1><p id="e943" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">这是一种特殊的队列，称为修道院队列。它保持对一组对象的跟踪，其中每个对象都有一个键(优先级),以有效地维持像插入、删除和基于该优先级查找或查找特定对象这样的功能。最小堆和最大堆都是优先级队列，这取决于如何定义它们的优先级顺序。</p><p id="e408" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated"><strong class="kn ir">传统队列</strong></p><ul class=""><li id="7a35" class="lo lp iq kn b ko lj ks lk kw lq la lr le ls li lt lu lv lw bi translated">基于位置(前/后)访问/排序项目</li><li id="cc39" class="lo lp iq kn b ko lx ks ly kw lz la ma le mb li lt lu lv lw bi translated">它不关心物品的价值</li></ul><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi mc"><img src="../Images/2e748bfa6a6ea86815bc0fabdc187eeb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Yk3wtKGqE0yTIrg0rXqIVQ.png"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">图1:传统队列</figcaption></figure><p id="d5ec" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated"><strong class="kn ir">优先队列</strong></p><ul class=""><li id="a6a2" class="lo lp iq kn b ko lj ks lk kw lq la lr le ls li lt lu lv lw bi translated">项目的顺序是基于价值的。(最小值或最大值)。</li><li id="3e81" class="lo lp iq kn b ko lx ks ly kw lz la ma le mb li lt lu lv lw bi translated">物品以某种任意的顺序到达。</li><li id="e121" class="lo lp iq kn b ko lx ks ly kw lz la ma le mb li lt lu lv lw bi translated">总是产生最小值的堆称为最小堆。</li><li id="2759" class="lo lp iq kn b ko lx ks ly kw lz la ma le mb li lt lu lv lw bi translated">总是产生最大值的堆称为最大堆。</li><li id="9956" class="lo lp iq kn b ko lx ks ly kw lz la ma le mb li lt lu lv lw bi translated">当删除一个项目时，需要根据实现获得最小值或最大值。</li><li id="7e50" class="lo lp iq kn b ko lx ks ly kw lz la ma le mb li lt lu lv lw bi translated">它导致一个排序列表。</li></ul><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi ms"><img src="../Images/394b9a301aed74a9d66d5f4c5daf1505.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WWw4bBUtrWSre_lJ3m3J-g.png"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">图2:优先级队列</figcaption></figure><p id="1fd2" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">优先级队列的真实示例:</p><ul class=""><li id="30df" class="lo lp iq kn b ko lj ks lk kw lq la lr le ls li lt lu lv lw bi translated"><strong class="kn ir">医院急诊排队</strong> : →患者排队中，情况最危急的患者排在第一位。</li><li id="d8d7" class="lo lp iq kn b ko lx ks ly kw lz la ma le mb li lt lu lv lw bi translated">寻找最近的餐馆、酒店、厕所等。</li><li id="c155" class="lo lp iq kn b ko lx ks ly kw lz la ma le mb li lt lu lv lw bi translated">航空公司在“经济舱”之前让“头等舱”的乘客登机。</li></ul><h1 id="9a8d" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">优先级队列的效率</h1><p id="ae56" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">基于排序后的数组:</p><ul class=""><li id="b4f9" class="lo lp iq kn b ko lj ks lk kw lq la lr le ls li lt lu lv lw bi translated">Insert() → O(n)</li><li id="826d" class="lo lp iq kn b ko lx ks ly kw lz la ma le mb li lt lu lv lw bi translated">Top() → O(1)</li><li id="e907" class="lo lp iq kn b ko lx ks ly kw lz la ma le mb li lt lu lv lw bi translated">Pop() → O(1)</li></ul><p id="f2bf" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">基于未排序的数组:</p><ul class=""><li id="0041" class="lo lp iq kn b ko lj ks lk kw lq la lr le ls li lt lu lv lw bi translated">Insert() → O(1)</li><li id="4dac" class="lo lp iq kn b ko lx ks ly kw lz la ma le mb li lt lu lv lw bi translated">Top() → O(n)</li><li id="23ff" class="lo lp iq kn b ko lx ks ly kw lz la ma le mb li lt lu lv lw bi translated">Pop() → O(n)</li></ul><h1 id="903b" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">堆数据结构</h1><p id="9c87" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">堆数据结构为优先级队列提供了有效的实现。它通常是通过使用二叉树来构建的。在二叉树中，对于两个子树，每个父树都小于(如果是最小堆)或大于(如果是最大堆)。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi mt"><img src="../Images/57f89a88b695ce03ff2c7e68d7c3c6a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IwrOByYJ20tbFLxhEzZdHA.png"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">图3:最小堆</figcaption></figure><h2 id="45ae" class="mu jo iq bd jp mv mw dn jt mx my dp jx kw mz na kb la nb nc kf le nd ne kj nf bi translated">堆成一棵树</h2><p id="1648" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">一棵完整的二叉树可以被建模为一个数组。假设它从索引1开始，其中:</p><ul class=""><li id="f293" class="lo lp iq kn b ko lj ks lk kw lq la lr le ls li lt lu lv lw bi translated">父代(i) = i/2</li><li id="ecb8" class="lo lp iq kn b ko lx ks ly kw lz la ma le mb li lt lu lv lw bi translated">LeftChild(p) = 2 * p</li><li id="5518" class="lo lp iq kn b ko lx ks ly kw lz la ma le mb li lt lu lv lw bi translated">RightChild(p) = 2 * p + 1</li></ul><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi ng"><img src="../Images/dd2d9e0c3bb6d2d010deff7eb810c31a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SHrbXtddRlo4qUnw11IjBA.png"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">图4:最小堆构造</figcaption></figure><p id="d46e" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">这里，一个节点的键≤大于其子节点的键(min-heap)。</p><h2 id="db8a" class="mu jo iq bd jp mv mw dn jt mx my dp jx kw mz na kb la nb nc kf le nd ne kj nf bi translated">堆操作</h2><p id="05c4" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">下面是堆操作:</p><ul class=""><li id="b591" class="lo lp iq kn b ko lj ks lk kw lq la lr le ls li lt lu lv lw bi translated">构建最大堆/平均堆:→它从一个未排序的数组中产生一个最大堆或最小堆。</li><li id="275b" class="lo lp iq kn b ko lx ks ly kw lz la ma le mb li lt lu lv lw bi translated">max heapify/min heapify: →它纠正根子树中对堆属性的单个违反。</li><li id="f646" class="lo lp iq kn b ko lx ks ly kw lz la ma le mb li lt lu lv lw bi translated">插入，提取最大值，堆排序</li></ul><h2 id="47cf" class="mu jo iq bd jp mv mw dn jt mx my dp jx kw mz na kb la nb nc kf le nd ne kj nf bi translated">最大值</h2><p id="d9dc" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">让我们取一个如下所示的数组:</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi nh"><img src="../Images/2fdd554c37e432fc0ffa7304aa76894b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HXXIsbkHJIMM40D9ccDLJQ.png"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">图5:最大堆的数组</figcaption></figure><p id="ddbe" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">上述数组的最大值:</p><p id="c209" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">步骤0:</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi ni"><img src="../Images/bcb96ba0112e9e0105b44ddf5138c387.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JiUjX0izbAovQGhwfBp8bw.png"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">图5: Heapify</figcaption></figure><p id="3a11" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">第一步:</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi nj"><img src="../Images/776d8e1659c263597fa3478e291203a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AkxebWbHu0BSFqNcZGzu6Q.png"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">图6: Heapify</figcaption></figure><p id="cf94" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">第三步:</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi nk"><img src="../Images/e291e0b0ff08f6316adcecf310b682d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qGzvZf10c7d33uRq6RBukg.png"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">图7: Heapify</figcaption></figure><p id="1db9" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">构建最大堆的伪代码:</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi nl"><img src="../Images/9ba5d0321d82ef47f305b0d5e6589dc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QRXrpa_A9lG3lieMqFbZ8g.png"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">图8:构造最大堆的伪代码</figcaption></figure><p id="3716" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">代码实现:</p><pre class="md me mf mg gt nm nn no np aw nq bi"><span id="8fe8" class="mu jo iq nn b gy nr ns l nt nu"># <strong class="nn ir">Max Heap</strong></span><span id="18c0" class="mu jo iq nn b gy nv ns l nt nu">nums = [12, 11, 13, 5, 6, 7]</span><span id="d2e4" class="mu jo iq nn b gy nv ns l nt nu">def maxHeap(nums):<br/>    n = len(nums)<br/>    for i in range(n//2-1, -1, -1):<br/>        heapify(nums, n, i)</span><span id="be9e" class="mu jo iq nn b gy nv ns l nt nu">def heapify(nums, n, i):<br/>    largest = i<br/>    left = 2 * i + 1<br/>    right = 2 * i + 2<br/>    <br/>    if (left &lt; n and nums[largest] &lt; nums[left]):<br/>        largest = left<br/>    <br/>    if (right &lt; n and nums[largest] &lt; nums[right]):<br/>        largest = right<br/>    <br/>    if (i != largest):<br/>        nums[i], nums[largest] = nums[largest], nums[i]<br/>        heapify(nums, n, largest)</span><span id="c153" class="mu jo iq nn b gy nv ns l nt nu">if __name__ == '__main__':<br/>    maxHeap(nums)<br/>    print(nums)</span></pre><h1 id="df6c" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">基于优先级队列或最小堆/最大堆的问题和解决方案</h1><p id="2776" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">有许多问题是通过最小堆或最大堆来解决的。</p><h2 id="8a53" class="mu jo iq bd jp mv mw dn jt mx my dp jx kw mz na kb la nb nc kf le nd ne kj nf bi translated">数组中第k个最大的元素</h2><p id="bb88" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">给定一个整数数组<code class="fe nw nx ny nn b">nums</code>和一个整数<code class="fe nw nx ny nn b">k</code>，返回数组中最大的元素<em class="nz"/><code class="fe nw nx ny nn b">kth</code>。</p><p id="b727" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">注意，它是排序顺序中最大的元素<code class="fe nw nx ny nn b">kth</code>，而不是<code class="fe nw nx ny nn b">kth</code> distinct元素。</p><p id="8b7f" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">示例:</p><pre class="md me mf mg gt nm nn no np aw nq bi"><span id="7fd2" class="mu jo iq nn b gy nr ns l nt nu"><strong class="nn ir">Input:</strong> nums = [3,2,1,5,6,4], k = 2<br/><strong class="nn ir">Output:</strong> 5</span></pre><p id="e467" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated"><strong class="kn ir">解决方案:</strong></p><pre class="md me mf mg gt nm nn no np aw nq bi"><span id="823f" class="mu jo iq nn b gy nr ns l nt nu">class Solution(object):<br/>    def findKthLargest(self, nums, k):<br/>        """<br/>        :type nums: List[int]<br/>        :type k: int<br/>        :rtype: int<br/>        """<br/>        n = len(nums)<br/>        minHeap = []<br/>        <br/>        for i in range(0, k):<br/>            minHeap.append(nums[i])<br/>            <br/>        for i in range(k, n):<br/>            minHeap.sort()<br/>            if minHeap[0] &gt; nums[i]:<br/>                continue<br/>            else:<br/>                minHeap.pop(0)<br/>                minHeap.append(nums[i])<br/>        <br/>        print(minHeap)<br/>        minHeap.sort()<br/>        return minHeap[0]</span></pre><h2 id="5575" class="mu jo iq bd jp mv mw dn jt mx my dp jx kw mz na kb la nb nc kf le nd ne kj nf bi translated">从数据流中查找中值</h2><p id="6420" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><strong class="kn ir">中值</strong>是有序整数列表中的中间值。如果列表的大小是偶数，则没有中间值，中间值是两个中间值的平均值。</p><ul class=""><li id="6f87" class="lo lp iq kn b ko lj ks lk kw lq la lr le ls li lt lu lv lw bi translated">例如，对于<code class="fe nw nx ny nn b">arr = [2,3,4]</code>，中位数是<code class="fe nw nx ny nn b">3</code>。</li><li id="6921" class="lo lp iq kn b ko lx ks ly kw lz la ma le mb li lt lu lv lw bi translated">比如对于<code class="fe nw nx ny nn b">arr = [2,3]</code>，中位数是<code class="fe nw nx ny nn b">(2 + 3) / 2 = 2.5</code>。</li></ul><p id="ca4e" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">实现MedianFinder类:</p><ul class=""><li id="0efb" class="lo lp iq kn b ko lj ks lk kw lq la lr le ls li lt lu lv lw bi translated"><code class="fe nw nx ny nn b">MedianFinder()</code>初始化<code class="fe nw nx ny nn b">MedianFinder</code>对象。</li><li id="c198" class="lo lp iq kn b ko lx ks ly kw lz la ma le mb li lt lu lv lw bi translated"><code class="fe nw nx ny nn b">void addNum(int num)</code>将数据流中的整数<code class="fe nw nx ny nn b">num</code>添加到数据结构中。</li><li id="23d9" class="lo lp iq kn b ko lx ks ly kw lz la ma le mb li lt lu lv lw bi translated"><code class="fe nw nx ny nn b">double findMedian()</code>返回到目前为止所有元素的中值。将接受实际答案的<code class="fe nw nx ny nn b">10-5</code>范围内的答案。</li></ul><p id="e2b8" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">示例:</p><pre class="md me mf mg gt nm nn no np aw nq bi"><span id="b9bf" class="mu jo iq nn b gy nr ns l nt nu"><strong class="nn ir">Input</strong><br/>["MedianFinder", "addNum", "addNum", "findMedian", "addNum", "findMedian"]<br/>[[], [1], [2], [], [3], []]<br/><strong class="nn ir">Output</strong><br/>[null, null, null, 1.5, null, 2.0]</span></pre><p id="0295" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated"><strong class="kn ir">解决方案:</strong></p><pre class="md me mf mg gt nm nn no np aw nq bi"><span id="e3f8" class="mu jo iq nn b gy nr ns l nt nu">import heapq</span><span id="bb08" class="mu jo iq nn b gy nv ns l nt nu">class MedianFinder(object):</span><span id="e0b5" class="mu jo iq nn b gy nv ns l nt nu">def __init__(self):<br/>        self.max = []<br/>        self.min = []</span><span id="e37d" class="mu jo iq nn b gy nv ns l nt nu">def addNum(self, num):<br/>        """<br/>        :type num: int<br/>        :rtype: None<br/>        """<br/>        heapq.heappush(self.max, -num)<br/>        heapq.heappush(self.min, -(heapq.heappop(self.max)))<br/>        <br/>        if len(self.max) &lt; len(self.min):<br/>            heapq.heappush(self.max, -heapq.heappop(self.min))</span><span id="5895" class="mu jo iq nn b gy nv ns l nt nu">def findMedian(self):<br/>        """<br/>        :rtype: float<br/>        """<br/>        if len(self.max) &gt; len(self.min):<br/>            return -(self.max[0])<br/>        else:<br/>            return ((float(-self.max[0]))+ float(self.min[0]))/2</span><span id="f75c" class="mu jo iq nn b gy nv ns l nt nu"># Your MedianFinder object will be instantiated and called as such:<br/># obj = MedianFinder()<br/># obj.addNum(num)<br/># param_2 = obj.findMedian()</span></pre><h2 id="343b" class="mu jo iq bd jp mv mw dn jt mx my dp jx kw mz na kb la nb nc kf le nd ne kj nf bi translated">前K个频繁元素</h2><p id="06d6" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">给定一个整数数组<code class="fe nw nx ny nn b">nums</code>和一个整数<code class="fe nw nx ny nn b">k</code>，返回<em class="nz"/><code class="fe nw nx ny nn b">k</code><em class="nz">最频繁出现的元素</em>。您可以在<strong class="kn ir">中以任意顺序</strong>返回答案。</p><p id="d356" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated"><strong class="kn ir">举例:</strong></p><pre class="md me mf mg gt nm nn no np aw nq bi"><span id="ee6b" class="mu jo iq nn b gy nr ns l nt nu"><strong class="nn ir">Input:</strong> nums = [1,1,1,2,2,3], k = 2<br/><strong class="nn ir">Output:</strong> [1,2]<br/></span></pre><p id="224e" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated"><strong class="kn ir">解决方案:</strong></p><pre class="md me mf mg gt nm nn no np aw nq bi"><span id="42aa" class="mu jo iq nn b gy nr ns l nt nu">class Solution:<br/>    def topKFrequent(self, nums: List[int], k: int) -&gt; List[int]:<br/>        hashmap = {}<br/>        for num in nums:<br/>            if num in hashmap:<br/>                hashmap[num] += 1<br/>            else:<br/>                hashmap[num] = 1<br/>                <br/>        heap = []<br/>        for key in hashmap:<br/>            heapq.heappush(heap, (-hashmap[key], key))<br/>        <br/>        res = []<br/>        for _ in range(k):<br/>            popped = heapq.heappop(heap)<br/>            res.append(popped[1])<br/>        <br/>        return res</span></pre><h2 id="5dac" class="mu jo iq bd jp mv mw dn jt mx my dp jx kw mz na kb la nb nc kf le nd ne kj nf bi translated">设计推特</h2><p id="ee9b" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">设计一个简化版本的Twitter，用户可以发布推文，关注/取消关注另一个用户，并能够在用户的新闻提要中看到最近的推文。</p><p id="d4a2" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">实现<code class="fe nw nx ny nn b">Twitter</code>类:</p><ul class=""><li id="4beb" class="lo lp iq kn b ko lj ks lk kw lq la lr le ls li lt lu lv lw bi translated">初始化你的twitter对象。</li><li id="7bc9" class="lo lp iq kn b ko lx ks ly kw lz la ma le mb li lt lu lv lw bi translated"><code class="fe nw nx ny nn b">void postTweet(int userId, int tweetId)</code>由用户<code class="fe nw nx ny nn b">userId</code>撰写ID为<code class="fe nw nx ny nn b">tweetId</code>的新推文。对这个函数的每次调用都有一个唯一的<code class="fe nw nx ny nn b">tweetId</code>。</li><li id="2643" class="lo lp iq kn b ko lx ks ly kw lz la ma le mb li lt lu lv lw bi translated"><code class="fe nw nx ny nn b">List&lt;Integer&gt; getNewsFeed(int userId)</code>在用户的新闻提要中检索<code class="fe nw nx ny nn b">10</code>最近的tweet IDs。新闻提要中的每一项都必须由用户关注的用户或用户自己发布。推文必须按照从最近到最近的顺序排序<strong class="kn ir">。</strong></li><li id="7cba" class="lo lp iq kn b ko lx ks ly kw lz la ma le mb li lt lu lv lw bi translated"><code class="fe nw nx ny nn b">void follow(int followerId, int followeeId)</code>ID为<code class="fe nw nx ny nn b">followerId</code>的用户开始关注ID为<code class="fe nw nx ny nn b">followeeId</code>的用户。</li><li id="f1b6" class="lo lp iq kn b ko lx ks ly kw lz la ma le mb li lt lu lv lw bi translated">ID为<code class="fe nw nx ny nn b">followerId</code>的用户开始取消关注ID为<code class="fe nw nx ny nn b">followeeId</code>的用户。</li></ul><p id="75f2" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">示例:</p><pre class="md me mf mg gt nm nn no np aw nq bi"><span id="710e" class="mu jo iq nn b gy nr ns l nt nu"><strong class="nn ir">Input</strong><br/>["Twitter", "postTweet", "getNewsFeed", "follow", "postTweet", "getNewsFeed", "unfollow", "getNewsFeed"]<br/>[[], [1, 5], [1], [1, 2], [2, 6], [1], [1, 2], [1]]<br/><strong class="nn ir">Output</strong><br/>[null, null, [5], null, null, [6, 5], null, [5]]<br/><br/><strong class="nn ir">Explanation</strong><br/>Twitter twitter = new Twitter();<br/>twitter.postTweet(1, 5); // User 1 posts a new tweet (id = 5).<br/>twitter.getNewsFeed(1);  // User 1's news feed should return a list with 1 tweet id -&gt; [5]. return [5]<br/>twitter.follow(1, 2);    // User 1 follows user 2.<br/>twitter.postTweet(2, 6); // User 2 posts a new tweet (id = 6).<br/>twitter.getNewsFeed(1);  // User 1's news feed should return a list with 2 tweet ids -&gt; [6, 5]. Tweet id 6 should precede tweet id 5 because it is posted after tweet id 5.<br/>twitter.unfollow(1, 2);  // User 1 unfollows user 2.<br/>twitter.getNewsFeed(1);  // User 1's news feed should return a list with 1 tweet id -&gt; [5], since user 1 is no longer following user 2.</span></pre><p id="b067" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated"><strong class="kn ir">解决方案:</strong></p><pre class="md me mf mg gt nm nn no np aw nq bi"><span id="8ace" class="mu jo iq nn b gy nr ns l nt nu">from heapq import *</span><span id="bc1a" class="mu jo iq nn b gy nv ns l nt nu">class Twitter(object):</span><span id="1aca" class="mu jo iq nn b gy nv ns l nt nu">def __init__(self):<br/>        """<br/>        Initialize your data structure here.<br/>        """<br/>        self.following = {}<br/>        self.tweets = {}<br/>        self.count = 0</span><span id="ab03" class="mu jo iq nn b gy nv ns l nt nu">def postTweet(self, userId, tweetId):<br/>        """<br/>        Compose a new tweet.<br/>        :type userId: int<br/>        :type tweetId: int<br/>        :rtype: None<br/>        """<br/>        self.count -= 1<br/>        if userId in self.tweets:<br/>            self.tweets[userId].append((self.count, tweetId))<br/>        else:<br/>            self.tweets[userId] = [(self.count, tweetId)]</span><span id="87e4" class="mu jo iq nn b gy nv ns l nt nu">def getNewsFeed(self, userId):<br/>        """<br/>        Retrieve the 10 most recent tweet ids in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent.<br/>        :type userId: int<br/>        :rtype: List[int]<br/>        """<br/>        heap = []<br/>        <br/>        if userId in self.tweets:<br/>            heap.extend(self.tweets[userId])<br/>        <br/>        following = self.following.get(userId, [])<br/>        for ids in following:<br/>            if ids in following:<br/>                if ids != userId:<br/>                    tweetData = self.tweets.get(ids, [])<br/>                    heap.extend(tweetData)<br/>        <br/>        heapq.heapify(heap)<br/>        res = []<br/>        while heap and len(res) &lt; 10:<br/>            item = heapq.heappop(heap)<br/>            res.append(item[1])<br/>        <br/>        return res</span><span id="9d29" class="mu jo iq nn b gy nv ns l nt nu">def follow(self, followerId, followeeId):<br/>        """<br/>        Follower follows a followee. If the operation is invalid, it should be a no-op.<br/>        :type followerId: int<br/>        :type followeeId: int<br/>        :rtype: None<br/>        """<br/>        if followerId in self.following:<br/>            self.following[followerId].add(followeeId)<br/>        else:<br/>            self.following[followerId] = {followeeId}</span><span id="a39a" class="mu jo iq nn b gy nv ns l nt nu">def unfollow(self, followerId, followeeId):<br/>        """<br/>        Follower unfollows a followee. If the operation is invalid, it should be a no-op.<br/>        :type followerId: int<br/>        :type followeeId: int<br/>        :rtype: None<br/>        """<br/>        if followerId in self.following:<br/>            if followeeId in self.following[followerId]:<br/>                self.following[followerId].remove(followeeId)</span><span id="60ca" class="mu jo iq nn b gy nv ns l nt nu"># Your Twitter object will be instantiated and called as such:<br/># obj = Twitter()<br/># obj.postTweet(userId,tweetId)<br/># param_2 = obj.getNewsFeed(userId)<br/># obj.follow(followerId,followeeId)<br/># obj.unfollow(followerId,followeeId)</span></pre><h2 id="3dbb" class="mu jo iq bd jp mv mw dn jt mx my dp jx kw mz na kb la nb nc kf le nd ne kj nf bi translated">排序矩阵中的第k个最小元素</h2><p id="86f3" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">给定一个<code class="fe nw nx ny nn b">n x n</code> <code class="fe nw nx ny nn b">matrix</code>，其中每行和每列都按升序排序，返回矩阵中的 <code class="fe nw nx ny nn b">kth</code> <em class="nz">最小元素<em class="nz">。</em></em></p><p id="ac49" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">请注意，它是排序顺序中的<code class="fe nw nx ny nn b">kth</code>最小元素<strong class="kn ir">，而不是<code class="fe nw nx ny nn b">kth</code> <strong class="kn ir">相异</strong>元素。</strong></p><p id="5df9" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">你必须找到一个内存复杂度优于<code class="fe nw nx ny nn b">O(n2)</code>的解决方案。</p><p id="a881" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">示例:</p><pre class="md me mf mg gt nm nn no np aw nq bi"><span id="704b" class="mu jo iq nn b gy nr ns l nt nu"><strong class="nn ir">Input:</strong> matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8<br/><strong class="nn ir">Output:</strong> 13<br/><strong class="nn ir">Explanation:</strong> The elements in the matrix are [1,5,9,10,11,12,13,<strong class="nn ir">13</strong>,15], and the 8th smallest number is 13</span></pre><p id="936a" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated"><strong class="kn ir">解决方案:</strong></p><pre class="md me mf mg gt nm nn no np aw nq bi"><span id="5721" class="mu jo iq nn b gy nr ns l nt nu">import heapq</span><span id="6e04" class="mu jo iq nn b gy nv ns l nt nu">class Solution(object):<br/>    def kthSmallest(self, matrix, k):<br/>        """<br/>        :type matrix: List[List[int]]<br/>        :type k: int<br/>        :rtype: int<br/>        """<br/>        r = len(matrix)<br/>        c = len(matrix[0])<br/>        <br/>        heap = []<br/>        for i in range(r):<br/>            heapq.heappush(heap, (matrix[i][0], i, 0))<br/>        <br/>        while k &gt; 1:<br/>            item, row, col = heapq.heappop(heap)<br/>            if (col + 1) &lt; c:<br/>                heapq.heappush(heap, (matrix[row][col+1], row, col+1))<br/>            <br/>            k -=1<br/>            <br/>        return heap[0][0]</span></pre><h2 id="a6b1" class="mu jo iq bd jp mv mw dn jt mx my dp jx kw mz na kb la nb nc kf le nd ne kj nf bi translated">按频率排序字符</h2><p id="072e" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">给定一个字符串<code class="fe nw nx ny nn b">s</code>，根据字符的<strong class="kn ir">频率</strong>按<strong class="kn ir">降序</strong>排序。一个字符的<strong class="kn ir">频率</strong>就是它在字符串中出现的次数。</p><p id="e80b" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">返回<em class="nz">排序后的字符串</em>。如果有多个答案，返回<em class="nz">其中任何一个</em>。</p><p id="1e73" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">示例:</p><pre class="md me mf mg gt nm nn no np aw nq bi"><span id="8d33" class="mu jo iq nn b gy nr ns l nt nu"><strong class="nn ir">Input:</strong> s = "tree"<br/><strong class="nn ir">Output:</strong> "eert"<br/><strong class="nn ir">Explanation:</strong> 'e' appears twice while 'r' and 't' both appear once.<br/>So 'e' must appear before both 'r' and 't'. Therefore "eetr" is also a valid answer.</span></pre><p id="77f3" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated"><strong class="kn ir">解决方案:</strong></p><pre class="md me mf mg gt nm nn no np aw nq bi"><span id="4850" class="mu jo iq nn b gy nr ns l nt nu">import heapq</span><span id="40a1" class="mu jo iq nn b gy nv ns l nt nu">class Solution(object):<br/>    def frequencySort(self, s):<br/>        """<br/>        :type s: str<br/>        :rtype: str<br/>        """<br/>        freq = {}<br/>        for char in s:<br/>            if char in freq:<br/>                freq[char] += 1<br/>            else:<br/>                freq[char] = 1<br/>        <br/>        heap = []<br/>        for char, count in freq.items():<br/>            heapq.heappush(heap, (-count, char))<br/>        <br/>        result = ''<br/>        while heap:<br/>            count, char = heapq.heappop(heap)<br/>            result += (char * -count)<br/>        <br/>        return result</span></pre><h2 id="21d9" class="mu jo iq bd jp mv mw dn jt mx my dp jx kw mz na kb la nb nc kf le nd ne kj nf bi translated">相对等级</h2><p id="2608" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">给你一个大小为<code class="fe nw nx ny nn b">n</code>的整数数组<code class="fe nw nx ny nn b">score</code>，其中<code class="fe nw nx ny nn b">score[i]</code>是<code class="fe nw nx ny nn b">ith</code>运动员在比赛中的分数。所有分数保证<strong class="kn ir">唯一</strong>。</p><p id="6f02" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">运动员根据他们的分数排名<strong class="kn ir">到</strong>，其中<code class="fe nw nx ny nn b">1st</code>名运动员得分最高，<code class="fe nw nx ny nn b">2nd</code>名运动员得分最高，<code class="fe nw nx ny nn b">2nd</code>名运动员得分最高，以此类推。每位运动员的名次决定了他们的排名:</p><ul class=""><li id="7d9d" class="lo lp iq kn b ko lj ks lk kw lq la lr le ls li lt lu lv lw bi translated">第<code class="fe nw nx ny nn b">1st</code>名运动员的名次是<code class="fe nw nx ny nn b">"Gold Medal"</code>。</li><li id="eb41" class="lo lp iq kn b ko lx ks ly kw lz la ma le mb li lt lu lv lw bi translated">第<code class="fe nw nx ny nn b">2nd</code>名运动员的名次是<code class="fe nw nx ny nn b">"Silver Medal"</code>。</li><li id="9a40" class="lo lp iq kn b ko lx ks ly kw lz la ma le mb li lt lu lv lw bi translated">第<code class="fe nw nx ny nn b">3rd</code>名运动员的名次是<code class="fe nw nx ny nn b">"Bronze Medal"</code>。</li><li id="de8a" class="lo lp iq kn b ko lx ks ly kw lz la ma le mb li lt lu lv lw bi translated">对于<code class="fe nw nx ny nn b">4th</code>位到<code class="fe nw nx ny nn b">nth</code>位运动员，他们的名次是他们的名次(即<code class="fe nw nx ny nn b">xth</code>位运动员的名次是<code class="fe nw nx ny nn b">"x"</code>)。</li></ul><p id="d31f" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">返回一个大小为<code class="fe nw nx ny nn b">n</code>的数组<code class="fe nw nx ny nn b">answer</code>，其中<code class="fe nw nx ny nn b">answer[i]</code>是<code class="fe nw nx ny nn b">ith</code>运动员的<strong class="kn ir">排名</strong>。</p><p id="ea14" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">示例:</p><pre class="md me mf mg gt nm nn no np aw nq bi"><span id="99bf" class="mu jo iq nn b gy nr ns l nt nu"><strong class="nn ir">Input:</strong> score = [5,4,3,2,1]<br/><strong class="nn ir">Output:</strong> ["Gold Medal","Silver Medal","Bronze Medal","4","5"]<br/><strong class="nn ir">Explanation:</strong> The placements are [1st, 2nd, 3rd, 4th, 5th].</span></pre><p id="7719" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated"><strong class="kn ir">解决方案:</strong></p><pre class="md me mf mg gt nm nn no np aw nq bi"><span id="09e4" class="mu jo iq nn b gy nr ns l nt nu">class Solution(object):<br/>    def findRelativeRanks(self, score):<br/>        """<br/>        :type score: List[int]<br/>        :rtype: List[str]<br/>        """<br/>        heap = [(-num, i) for i, num in enumerate(score)]<br/>        heapq.heapify(heap)<br/>        <br/>        n = len(score)<br/>        res = [0] * n<br/>        count = 1<br/>        <br/>        while heap:<br/>            num, i = heapq.heappop(heap)<br/>            if count == 1:<br/>                res[i] = "Gold Medal"<br/>            elif count == 2:<br/>                res[i] = "Silver Medal"<br/>            elif count == 3:<br/>                res[i] = "Bronze Medal"<br/>            else:<br/>                res[i] = str(count)<br/>            <br/>            count += 1<br/>        <br/>        return res</span></pre><h2 id="80af" class="mu jo iq bd jp mv mw dn jt mx my dp jx kw mz na kb la nb nc kf le nd ne kj nf bi translated">课程表三</h2><p id="56bc" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">从<code class="fe nw nx ny nn b">1</code>到<code class="fe nw nx ny nn b">n</code>有<code class="fe nw nx ny nn b">n</code>不同的在线课程。给你一个数组<code class="fe nw nx ny nn b">courses</code>，其中<code class="fe nw nx ny nn b">courses[i] = [durationi, lastDayi]</code>表示<code class="fe nw nx ny nn b">ith</code>课程应该连续<strong class="kn ir">进行</strong>天<code class="fe nw nx ny nn b">durationi</code>并且必须在<code class="fe nw nx ny nn b">lastDayi</code>之前或当天完成。</p><p id="c769" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">你将在<code class="fe nw nx ny nn b">1st</code>日开始，你不能同时选两门或更多的课程。</p><p id="5d01" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">返回<em class="nz">你可以选修的最大课程数</em>。</p><p id="9a60" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">示例:</p><pre class="md me mf mg gt nm nn no np aw nq bi"><span id="c35c" class="mu jo iq nn b gy nr ns l nt nu"><strong class="nn ir">Input:</strong> courses = [[100,200],[200,1300],[1000,1250],[2000,3200]]<br/><strong class="nn ir">Output:</strong> 3<br/>Explanation: <br/>There are totally 4 courses, but you can take 3 courses at most:<br/>First, take the 1st course, it costs 100 days so you will finish it on the 100th day, and ready to take the next course on the 101st day.<br/>Second, take the 3rd course, it costs 1000 days so you will finish it on the 1100th day, and ready to take the next course on the 1101st day. <br/>Third, take the 2nd course, it costs 200 days so you will finish it on the 1300th day. <br/>The 4th course cannot be taken now, since you will finish it on the 3300th day, which exceeds the closed date.</span></pre><p id="b48e" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated"><strong class="kn ir">解决方案:</strong></p><pre class="md me mf mg gt nm nn no np aw nq bi"><span id="f2e7" class="mu jo iq nn b gy nr ns l nt nu">class Solution(object):<br/>    def scheduleCourse(self, courses):<br/>        """<br/>        :type courses: List[List[int]]<br/>        :rtype: int<br/>        """<br/>        courses.sort(key=lambda c: c[1])<br/>        <br/>        A, curr = [], 0<br/>        for dur, ld in courses:<br/>            heapq.heappush(A,-dur)<br/>            curr += dur<br/>            if curr &gt; ld: curr += heapq.heappop(A)<br/>                <br/>        return len(A)</span></pre><h2 id="8321" class="mu jo iq bd jp mv mw dn jt mx my dp jx kw mz na kb la nb nc kf le nd ne kj nf bi translated">查找K个最近的元素</h2><p id="4ee0" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">给定一个<strong class="kn ir">排序的</strong>整数数组<code class="fe nw nx ny nn b">arr</code>，两个整数<code class="fe nw nx ny nn b">k</code>和<code class="fe nw nx ny nn b">x</code>，返回数组中与<code class="fe nw nx ny nn b">x</code>最接近的<code class="fe nw nx ny nn b">k</code>整数。结果也应该按升序排序。</p><p id="c55f" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">整数<code class="fe nw nx ny nn b">a</code>比整数<code class="fe nw nx ny nn b">b</code>更接近于<code class="fe nw nx ny nn b">x</code>，如果:</p><ul class=""><li id="6028" class="lo lp iq kn b ko lj ks lk kw lq la lr le ls li lt lu lv lw bi translated"><code class="fe nw nx ny nn b">|a - x| &lt; |b - x|</code>，或者</li><li id="316f" class="lo lp iq kn b ko lx ks ly kw lz la ma le mb li lt lu lv lw bi translated"><code class="fe nw nx ny nn b">|a - x| == |b - x|</code>和<code class="fe nw nx ny nn b">a &lt; b</code></li></ul><p id="b7bc" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">示例:</p><pre class="md me mf mg gt nm nn no np aw nq bi"><span id="5c33" class="mu jo iq nn b gy nr ns l nt nu"><strong class="nn ir">Input:</strong> arr = [1,2,3,4,5], k = 4, x = 3<br/><strong class="nn ir">Output:</strong> [1,2,3,4]</span></pre><p id="6f96" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated"><strong class="kn ir">解决方案:</strong></p><pre class="md me mf mg gt nm nn no np aw nq bi"><span id="2130" class="mu jo iq nn b gy nr ns l nt nu">import heapq<br/>class Solution(object):<br/>    def findClosestElements(self, arr, k, x):<br/>        """<br/>        :type arr: List[int]<br/>        :type k: int<br/>        :type x: int<br/>        :rtype: List[int]<br/>        """<br/>        if len(arr) &lt; k:<br/>            return []<br/>        <br/>        heap = []<br/>        <br/>        for item in arr:<br/>            val = abs(x - item)<br/>            if len(heap) &lt; k:<br/>                heapq.heappush(heap, (-1* val, item))<br/>            else:<br/>                if (-1 * heap[0][0] &gt; val):<br/>                    heapq.heappop(heap)<br/>                    heapq.heappush(heap, (-1 * val, item))<br/>                    <br/>        return sorted([val for _, val in heap])</span></pre><h2 id="8862" class="mu jo iq bd jp mv mw dn jt mx my dp jx kw mz na kb la nb nc kf le nd ne kj nf bi translated">前K个常用词</h2><p id="071c" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">给定一个字符串数组<code class="fe nw nx ny nn b">words</code>和一个整数<code class="fe nw nx ny nn b">k</code>，返回<em class="nz"/><code class="fe nw nx ny nn b">k</code><em class="nz">最频繁出现的字符串</em>。</p><p id="43e7" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">将按<strong class="kn ir">排序</strong>的答案<strong class="kn ir">返回，频率</strong>从高到低。将出现频率相同的单词按其<strong class="kn ir">字典顺序</strong>排序。</p><p id="5359" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">示例:</p><pre class="md me mf mg gt nm nn no np aw nq bi"><span id="8e29" class="mu jo iq nn b gy nr ns l nt nu"><strong class="nn ir">Input:</strong> words = ["i","love","leetcode","i","love","coding"], k = 2<br/><strong class="nn ir">Output:</strong> ["i","love"]<br/><strong class="nn ir">Explanation:</strong> "i" and "love" are the two most frequent words.<br/>Note that "i" comes before "love" due to a lower alphabetical order.</span></pre><p id="181b" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated"><strong class="kn ir">解决方案:</strong></p><pre class="md me mf mg gt nm nn no np aw nq bi"><span id="1cb0" class="mu jo iq nn b gy nr ns l nt nu">class Solution(object):<br/>    def topKFrequent(self, words, k):<br/>        """<br/>        :type words: List[str]<br/>        :type k: int<br/>        :rtype: List[str]<br/>        """<br/>        d = {}<br/>        for item in words:<br/>            if item not in d:<br/>                d[item] = 1<br/>            else:<br/>                d[item] += 1<br/>        <br/>        heap = []<br/>        for word, count in d.items():<br/>            heapq.heappush(heap, (-count, word))<br/>        <br/>        data = [heapq.heappop(heap)[-1] for _ in range(k)]<br/>        return data</span></pre><h2 id="5764" class="mu jo iq bd jp mv mw dn jt mx my dp jx kw mz na kb la nb nc kf le nd ne kj nf bi translated">流中的第k个最大元素</h2><p id="4f42" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">设计一个类来找出流中最大的元素。请注意，它是排序顺序中最大的<code class="fe nw nx ny nn b">kth</code>元素，而不是<code class="fe nw nx ny nn b">kth</code> distinct元素。</p><p id="2239" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">实现<code class="fe nw nx ny nn b">KthLargest</code>类:</p><ul class=""><li id="d7b6" class="lo lp iq kn b ko lj ks lk kw lq la lr le ls li lt lu lv lw bi translated"><code class="fe nw nx ny nn b">KthLargest(int k, int[] nums)</code>用整数<code class="fe nw nx ny nn b">k</code>和整数流<code class="fe nw nx ny nn b">nums</code>初始化对象。</li><li id="d687" class="lo lp iq kn b ko lx ks ly kw lz la ma le mb li lt lu lv lw bi translated"><code class="fe nw nx ny nn b">int add(int val)</code>将整数<code class="fe nw nx ny nn b">val</code>附加到流中，并返回代表流中最大元素<code class="fe nw nx ny nn b">kth</code>的元素。</li></ul><p id="7ee9" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">示例:</p><pre class="md me mf mg gt nm nn no np aw nq bi"><span id="7e89" class="mu jo iq nn b gy nr ns l nt nu"><strong class="nn ir">Input</strong><br/>["KthLargest", "add", "add", "add", "add", "add"]<br/>[[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]]<br/><strong class="nn ir">Output</strong><br/>[null, 4, 5, 5, 8, 8]<br/><br/><strong class="nn ir">Explanation</strong><br/>KthLargest kthLargest = new KthLargest(3, [4, 5, 8, 2]);<br/>kthLargest.add(3);   // return 4<br/>kthLargest.add(5);   // return 5<br/>kthLargest.add(10);  // return 5<br/>kthLargest.add(9);   // return 8<br/>kthLargest.add(4);   // return 8</span></pre><p id="a40d" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated"><strong class="kn ir">解决方案:</strong></p><pre class="md me mf mg gt nm nn no np aw nq bi"><span id="d8ca" class="mu jo iq nn b gy nr ns l nt nu">import heapq</span><span id="dcd6" class="mu jo iq nn b gy nv ns l nt nu">class KthLargest(object):</span><span id="1d3f" class="mu jo iq nn b gy nv ns l nt nu">def __init__(self, k, nums):<br/>        """<br/>        :type k: int<br/>        :type nums: List[int]<br/>        """<br/>        self.heap = []<br/>        self.k = k<br/>        <br/>        for num in nums:<br/>            self.add(num)</span><span id="0af6" class="mu jo iq nn b gy nv ns l nt nu">def add(self, val):<br/>        """<br/>        :type val: int<br/>        :rtype: int<br/>        """<br/>        heapq.heappush(self.heap, val)<br/>        <br/>        if len(self.heap) &gt; self.k:<br/>            heapq.heappop(self.heap)<br/>        <br/>        return self.heap[0]</span><span id="4476" class="mu jo iq nn b gy nv ns l nt nu"># Your KthLargest object will be instantiated and called as such:<br/># obj = KthLargest(k, nums)<br/># param_1 = obj.add(val)</span></pre><h2 id="f414" class="mu jo iq bd jp mv mw dn jt mx my dp jx kw mz na kb la nb nc kf le nd ne kj nf bi translated">重组字符串</h2><p id="62f9" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">给定一个字符串<code class="fe nw nx ny nn b">s</code>，重新排列<code class="fe nw nx ny nn b">s</code>的字符，使任意两个相邻的字符不相同。</p><p id="7c0c" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">返回<em class="nz">任何可能的重排</em> <code class="fe nw nx ny nn b">s</code> <em class="nz">或者返回</em> <code class="fe nw nx ny nn b">""</code> <em class="nz">如果不可能</em>。</p><p id="9a7d" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">示例:</p><pre class="md me mf mg gt nm nn no np aw nq bi"><span id="cea8" class="mu jo iq nn b gy nr ns l nt nu"><strong class="nn ir">Input:</strong> s = "aab"<br/><strong class="nn ir">Output:</strong> "aba"</span></pre><p id="bd4f" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated"><strong class="kn ir">解决方案:</strong></p><pre class="md me mf mg gt nm nn no np aw nq bi"><span id="61fa" class="mu jo iq nn b gy nr ns l nt nu">import heapq</span><span id="50f7" class="mu jo iq nn b gy nv ns l nt nu">class Solution(object):<br/>    def reorganizeString(self, s):<br/>        """<br/>        :type s: str<br/>        :rtype: str<br/>        """<br/>        d = {}<br/>        for item in s:<br/>            if item not in d:<br/>                d[item] = 1<br/>            else:<br/>                d[item] += 1<br/>                <br/>        heap = []<br/>        for char, count in d.items():<br/>            heapq.heappush(heap, (-count, char))<br/>            <br/>        res = ''<br/>        prev_count = 0<br/>        prev_char = ''<br/>        while len(heap) &gt; 0:<br/>            count, char = heapq.heappop(heap)<br/>            res += char<br/>            <br/>            if prev_count &lt; 0:<br/>                heapq.heappush(heap, (prev_count, prev_char))<br/>            <br/>            prev_count = count + 1<br/>            prev_char = char<br/>            <br/>            <br/>        if len(res) == len(s):<br/>            return res<br/>        <br/>        return ""</span></pre><h2 id="7172" class="mu jo iq bd jp mv mw dn jt mx my dp jx kw mz na kb la nb nc kf le nd ne kj nf bi translated">K站以内最便宜的航班</h2><p id="cae0" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">有许多航班将城市连接起来。给你一个数组<code class="fe nw nx ny nn b">flights</code>，其中<code class="fe nw nx ny nn b">flights[i] = [fromi, toi, pricei]</code>表示有一个从城市<code class="fe nw nx ny nn b">fromi</code>到城市<code class="fe nw nx ny nn b">toi</code>的航班，费用为<code class="fe nw nx ny nn b">pricei</code>。</p><p id="925f" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">同样给你三个整数<code class="fe nw nx ny nn b">src</code>、<code class="fe nw nx ny nn b">dst</code>、<code class="fe nw nx ny nn b">k</code>，返回<strong class="kn ir"> <em class="nz">最便宜的价格</em> </strong> <em class="nz">从</em> <code class="fe nw nx ny nn b">src</code> <em class="nz">到</em> <code class="fe nw nx ny nn b">dst</code> <em class="nz">最多有</em> <code class="fe nw nx ny nn b">k</code> <em class="nz">个止损点。</em>如果没有这条路线，返回<em class="nz"> </em> <code class="fe nw nx ny nn b">-1</code>。</p><p id="963b" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">示例:</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi oa"><img src="../Images/3adaf68173d4794a85528eacad092223.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cdkxZ43DlWRmAn6Mkb4fwQ.png"/></div></div></figure><p id="8dd1" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated"><strong class="kn ir">解决方案:</strong></p><pre class="md me mf mg gt nm nn no np aw nq bi"><span id="389f" class="mu jo iq nn b gy nr ns l nt nu">class Solution(object):<br/>    def findCheapestPrice(self, n, flights, src, dst, k):<br/>        """<br/>        :type n: int<br/>        :type flights: List[List[int]]<br/>        :type src: int<br/>        :type dst: int<br/>        :type k: int<br/>        :rtype: int<br/>        """<br/>        graph = defaultdict(list)<br/>        <br/>        for a, b, price in flights:<br/>            graph[a].append((b, price))<br/>        <br/>        node2minNstop = {i: float("inf") for i in range(n)}<br/>        pq = [(0, src, -1)]<br/>        while pq:<br/>            dist_from_src, node, n_stops = heappop(pq)<br/>            if node == dst:<br/>                return dist_from_src<br/>   # skip current iteration if number of stops exceeds maximum<br/>   # or we can reach current node with fewer stops. Suppose we've<br/>   # visited this node before, by the property of Dijkstra we must have found<br/>   # a path with lower cost to this node before. The only reason we might want<br/>   # to visit it again is if we can visit it with fewer stops. If this is not the case, we<br/>   # skip.<br/>            if n_stops &gt;= min(k, node2minNstop[node]):<br/>                continue<br/>            node2minNstop[node] = n_stops<br/>            for neighbor, dist_to_neighbor in graph[node]:<br/>                heappush(pq, (dist_from_src+dist_to_neighbor, neighbor, n_stops+1))<br/>                    <br/>        return -1</span></pre><h2 id="27b6" class="mu jo iq bd jp mv mw dn jt mx my dp jx kw mz na kb la nb nc kf le nd ne kj nf bi translated">对数组排序</h2><p id="4a18" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">给定一个整数数组<code class="fe nw nx ny nn b">nums</code>，按升序对数组排序。</p><p id="91f9" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">示例:</p><pre class="md me mf mg gt nm nn no np aw nq bi"><span id="5347" class="mu jo iq nn b gy nr ns l nt nu"><strong class="nn ir">Input:</strong> nums = [5,2,3,1]<br/><strong class="nn ir">Output:</strong> [1,2,3,5]</span></pre><p id="3c32" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated"><strong class="kn ir">解决方案:</strong></p><pre class="md me mf mg gt nm nn no np aw nq bi"><span id="b420" class="mu jo iq nn b gy nr ns l nt nu">class Solution(object):<br/>    def sortArray(self, nums):<br/>        """<br/>        :type nums: List[int]<br/>        :rtype: List[int]<br/>        """<br/>        n = len(nums)<br/>        for i in range(n//2-1, -1, -1):<br/>            self.heapify(nums, n, i)<br/>            <br/>        for i in range(n-1, 0, -1):<br/>            nums[i], nums[0] = nums[0], nums[i]<br/>            self.heapify(nums, i, 0)<br/>        <br/>        return nums<br/>        <br/>    def heapify(self, arr, n, i):<br/>        largest = i<br/>        l = 2* i + 1<br/>        r = 2 * i + 2<br/>        <br/>        if l &lt; n and arr[largest] &lt; arr[l]:<br/>            largest = l<br/>        <br/>        if r &lt; n and arr[largest] &lt; arr[r]:<br/>            largest = r<br/>            <br/>        if largest != i:<br/>            arr[i], arr[largest] = arr[largest], arr[i]<br/>            self.heapify(arr, n, largest)</span></pre><h2 id="554c" class="mu jo iq bd jp mv mw dn jt mx my dp jx kw mz na kb la nb nc kf le nd ne kj nf bi translated">k个离原点最近的点</h2><p id="e9a5" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">给定一个<code class="fe nw nx ny nn b">points</code>数组，其中<code class="fe nw nx ny nn b">points[i] = [xi, yi]</code>代表<strong class="kn ir"> X-Y </strong>平面上的一个点和一个整数<code class="fe nw nx ny nn b">k</code>，返回离原点<code class="fe nw nx ny nn b">(0, 0)</code>最近的<code class="fe nw nx ny nn b">k</code>点。</p><p id="8396" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated"><strong class="kn ir"> X-Y </strong>平面上两点之间的距离为欧氏距离(即<code class="fe nw nx ny nn b">√(x1 - x2)2 + (y1 - y2)2</code>)。</p><p id="e0d1" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">您可以在<strong class="kn ir">中以任何顺序</strong>返回答案。答案是<strong class="kn ir">保证</strong>是<strong class="kn ir">唯一的</strong>(除了它所在的顺序)。</p><p id="fc56" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">示例:</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi ob"><img src="../Images/78931d869c30b690e6488f051fde3345.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JESuXutzpfpFqeZnYn-X_g.png"/></div></div></figure><p id="6579" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated"><strong class="kn ir">解决方案:</strong></p><pre class="md me mf mg gt nm nn no np aw nq bi"><span id="4bdc" class="mu jo iq nn b gy nr ns l nt nu">import heapq</span><span id="450e" class="mu jo iq nn b gy nv ns l nt nu">class Solution(object):<br/>    def kClosest(self, points, k):<br/>        """<br/>        :type points: List[List[int]]<br/>        :type k: int<br/>        :rtype: List[List[int]]<br/>        """<br/>        heap = []<br/>        <br/>        for point in points:<br/>            distance = self.findDistance(point[0], point[1])<br/>            heapq.heappush(heap, (distance, point))<br/>            <br/>        lst = []<br/>        while k &gt; 0:<br/>            count, item = heapq.heappop(heap)<br/>            lst.append(item)<br/>            k -= 1<br/>            <br/>        return lst<br/>            <br/>        <br/>    <br/>    def findDistance(self, x, y):<br/>        return (x**2 + y**2)</span></pre><h2 id="22b3" class="mu jo iq bd jp mv mw dn jt mx my dp jx kw mz na kb la nb nc kf le nd ne kj nf bi translated">最后一石重量</h2><p id="f462" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">给你一个整数数组<code class="fe nw nx ny nn b">stones</code>，其中<code class="fe nw nx ny nn b">stones[i]</code>是<code class="fe nw nx ny nn b">ith</code>宝石的重量。</p><p id="ba4d" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">我们在用石头玩游戏。在每一轮，我们选择最重的两块石头并一起打碎。假设最重的两块石头的重量为<code class="fe nw nx ny nn b">x</code>，T4的重量为<code class="fe nw nx ny nn b">x &lt;= y</code>。这次粉碎的结果是:</p><ul class=""><li id="d8ed" class="lo lp iq kn b ko lj ks lk kw lq la lr le ls li lt lu lv lw bi translated">如果<code class="fe nw nx ny nn b">x == y</code>，两块石头都被摧毁，并且</li><li id="dd4e" class="lo lp iq kn b ko lx ks ly kw lz la ma le mb li lt lu lv lw bi translated">如果<code class="fe nw nx ny nn b">x != y</code>，重量<code class="fe nw nx ny nn b">x</code>的石头被破坏，重量<code class="fe nw nx ny nn b">y</code>的石头有了新的重量<code class="fe nw nx ny nn b">y - x</code>。</li></ul><p id="af07" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">游戏结束，最多剩下<strong class="kn ir">一块</strong>石头。</p><p id="436e" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">返回最后剩余石头的重量。如果没有剩余的石头，返回<code class="fe nw nx ny nn b">0</code>。</p><p id="a6f3" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">示例:</p><pre class="md me mf mg gt nm nn no np aw nq bi"><span id="e615" class="mu jo iq nn b gy nr ns l nt nu"><strong class="nn ir">Input:</strong> stones = [2,7,4,1,8,1]<br/><strong class="nn ir">Output:</strong> 1<br/><strong class="nn ir">Explanation:</strong> <br/>We combine 7 and 8 to get 1 so the array converts to [2,4,1,1,1] then,<br/>we combine 2 and 4 to get 2 so the array converts to [2,1,1,1] then,<br/>we combine 2 and 1 to get 1 so the array converts to [1,1,1] then,<br/>we combine 1 and 1 to get 0 so the array converts to [1] then that's the value of the last stone.</span></pre><p id="286e" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated"><strong class="kn ir">解决方案:</strong></p><pre class="md me mf mg gt nm nn no np aw nq bi"><span id="b4ec" class="mu jo iq nn b gy nr ns l nt nu">class Solution(object):<br/>    def lastStoneWeight(self, stones):<br/>        """<br/>        :type stones: List[int]<br/>        :rtype: int<br/>        """<br/>        if not stones:<br/>            return 0<br/>        <br/>        negWeights = [-weight for weight in stones]<br/>        heapq.heapify(negWeights)<br/>        <br/>        while len(negWeights) &gt; 1:<br/>            heaviest = -heapq.heappop(negWeights)<br/>            secondHeaviest = -heapq.heappop(negWeights)<br/>            <br/>            if heaviest == secondHeaviest:<br/>                continue<br/>            else:<br/>                add = secondHeaviest - heaviest<br/>                heapq.heappush(negWeights, add)<br/>                <br/>        if len(negWeights) &gt; 0:<br/>            return -negWeights[0]<br/>        return 0</span></pre><h2 id="ee98" class="mu jo iq bd jp mv mw dn jt mx my dp jx kw mz na kb la nb nc kf le nd ne kj nf bi translated">远程条形码</h2><p id="b430" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在一个仓库里，有一排条形码，其中<code class="fe nw nx ny nn b">ith</code>条形码是<code class="fe nw nx ny nn b">barcodes[i]</code>。</p><p id="2f34" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">重新排列条形码，使相邻的两个条形码不相等。你可以返回任何答案，并保证有答案存在。</p><p id="93cb" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">示例:</p><pre class="md me mf mg gt nm nn no np aw nq bi"><span id="958d" class="mu jo iq nn b gy nr ns l nt nu"><strong class="nn ir">Input:</strong> barcodes = [1,1,1,2,2,2]<br/><strong class="nn ir">Output:</strong> [2,1,2,1,2,1]</span></pre><p id="8acc" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated"><strong class="kn ir">解决方案:</strong></p><pre class="md me mf mg gt nm nn no np aw nq bi"><span id="0b91" class="mu jo iq nn b gy nr ns l nt nu">import heapq</span><span id="30b4" class="mu jo iq nn b gy nv ns l nt nu">class Solution(object):<br/>    def rearrangeBarcodes(self, barcodes):<br/>        """<br/>        :type barcodes: List[int]<br/>        :rtype: List[int]<br/>        """<br/>        count, pq, ans = {}, [], []<br/>        for num in barcodes:<br/>            if num in count:<br/>                count[num] += 1<br/>            else:<br/>                count[num] = 1<br/>                <br/>        for n, c in count.items():<br/>            heapq.heappush(pq, (-c, n))<br/>        <br/>        prev_cnt, prev_num = 0, 0<br/>        <br/>        while pq:<br/>            cnt, num = heapq.heappop(pq)<br/>            if prev_cnt:<br/>                heapq.heappush(pq, (prev_cnt, prev_num))<br/>            <br/>            ans.append(num)<br/>            prev_cnt, prev_num = cnt+1, num<br/>            <br/>        return ans</span></pre><h2 id="5fbf" class="mu jo iq bd jp mv mw dn jt mx my dp jx kw mz na kb la nb nc kf le nd ne kj nf bi translated">用多重和构造目标阵列</h2><p id="3e84" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">给你一个n个整数的数组<code class="fe nw nx ny nn b">target</code>。从由<code class="fe nw nx ny nn b">n</code> 1组成的起始数组<code class="fe nw nx ny nn b">arr</code>中，您可以执行以下程序:</p><ul class=""><li id="d441" class="lo lp iq kn b ko lj ks lk kw lq la lr le ls li lt lu lv lw bi translated">设<code class="fe nw nx ny nn b">x</code>是当前数组中所有元素的总和。</li><li id="70e4" class="lo lp iq kn b ko lx ks ly kw lz la ma le mb li lt lu lv lw bi translated">选择索引<code class="fe nw nx ny nn b">i</code>，使<code class="fe nw nx ny nn b">0 &lt;= i &lt; n</code>将索引<code class="fe nw nx ny nn b">i</code>处的<code class="fe nw nx ny nn b">arr</code>的值设置为<code class="fe nw nx ny nn b">x</code>。</li><li id="2278" class="lo lp iq kn b ko lx ks ly kw lz la ma le mb li lt lu lv lw bi translated">您可以根据需要多次重复此过程。</li></ul><p id="46f7" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">如果可以从 <code class="fe nw nx ny nn b">arr</code> <em class="nz">构造</em> <code class="fe nw nx ny nn b">target</code> <em class="nz">数组，则返回<code class="fe nw nx ny nn b">true</code> <em class="nz">，否则返回</em> <code class="fe nw nx ny nn b">false</code>。</em></p><p id="0261" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">示例:</p><pre class="md me mf mg gt nm nn no np aw nq bi"><span id="06ab" class="mu jo iq nn b gy nr ns l nt nu"><strong class="nn ir">Input:</strong> target = [9,3,5]<br/><strong class="nn ir">Output:</strong> true<br/><strong class="nn ir">Explanation:</strong> Start with arr = [1, 1, 1] <br/>[1, 1, 1], sum = 3 choose index 1<br/>[1, 3, 1], sum = 5 choose index 2<br/>[1, 3, 5], sum = 9 choose index 0<br/>[9, 3, 5] Done</span></pre><p id="5401" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated"><strong class="kn ir">解决方案:</strong></p><pre class="md me mf mg gt nm nn no np aw nq bi"><span id="89fa" class="mu jo iq nn b gy nr ns l nt nu">class Solution(object):<br/>    def isPossible(self, target):<br/>        """<br/>        :type target: List[int]<br/>        :rtype: bool<br/>        """<br/>        n = len(target)<br/>        total = sum(target)<br/>        h = []<br/>        for e in target:<br/>            heappush(h, -e)<br/>        while True:<br/>            cur_max = -heappop(h) <br/>            if total == n: return True<br/>            if total - cur_max == 0: <br/>                return False<br/>            remainder = total % (total - cur_max ) if total %(total - cur_max) else total - cur_max <br/>            if remainder == cur_max: <br/>                return False<br/>            heappush(h, -remainder)<br/>            total += - cur_max + remainder</span></pre><h2 id="2f89" class="mu jo iq bd jp mv mw dn jt mx my dp jx kw mz na kb la nb nc kf le nd ne kj nf bi translated">数组中两个元素的最大乘积</h2><p id="4c58" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">给定整数数组<code class="fe nw nx ny nn b">nums</code>，你将选择该数组的两个不同的索引<code class="fe nw nx ny nn b">i</code>和<code class="fe nw nx ny nn b">j</code>。<em class="nz">返回</em>的最大值<code class="fe nw nx ny nn b">(nums[i]-1)*(nums[j]-1)</code>。</p><p id="1692" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">示例:</p><pre class="md me mf mg gt nm nn no np aw nq bi"><span id="31eb" class="mu jo iq nn b gy nr ns l nt nu"><strong class="nn ir">Input:</strong> nums = [3,4,5,2]<br/><strong class="nn ir">Output:</strong> 12 <br/><strong class="nn ir">Explanation:</strong> If you choose the indices i=1 and j=2 (indexed from 0), you will get the maximum value, that is, (nums[1]-1)*(nums[2]-1) = (4-1)*(5-1) = 3*4 = 12.</span></pre><p id="ed86" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated"><strong class="kn ir">解决方案:</strong></p><pre class="md me mf mg gt nm nn no np aw nq bi"><span id="366d" class="mu jo iq nn b gy nr ns l nt nu">class Solution(object):<br/>    def maxProduct(self, nums):<br/>        """<br/>        :type nums: List[int]<br/>        :rtype: int<br/>        """<br/>        temp = [-x for x in nums]<br/>        heapq.heapify(temp)<br/>    <br/>        while len(temp) &gt; 0:<br/>            first = -heapq.heappop(temp)<br/>            second = -heapq.heappop(temp)<br/>            mul = (first - 1) * (second - 1)<br/>            return mul</span></pre><h2 id="73e8" class="mu jo iq bd jp mv mw dn jt mx my dp jx kw mz na kb la nb nc kf le nd ne kj nf bi translated">最大概率路径</h2><p id="21f4" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">给你一个由<code class="fe nw nx ny nn b">n</code>个节点(索引为0)组成的无向加权图，由一个边列表表示，其中<code class="fe nw nx ny nn b">edges[i] = [a, b]</code>是一条连接节点<code class="fe nw nx ny nn b">a</code>和<code class="fe nw nx ny nn b">b</code>的无向边，成功穿越该边的概率为<code class="fe nw nx ny nn b">succProb[i]</code>。</p><p id="5df7" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">给定两个节点<code class="fe nw nx ny nn b">start</code>和<code class="fe nw nx ny nn b">end</code>，找出从<code class="fe nw nx ny nn b">start</code>到<code class="fe nw nx ny nn b">end</code>成功概率最大的路径，并返回其成功概率。</p><p id="e65f" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">如果没有从<code class="fe nw nx ny nn b">start</code>到<code class="fe nw nx ny nn b">end</code>的路径，<strong class="kn ir">返回0 </strong>。如果您的答案与正确答案最多相差<strong class="kn ir"> 1e-5 </strong>，您的答案将被接受。</p><p id="6c7c" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">示例:</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi oc"><img src="../Images/e46384defd447249c6a59f9d14cb7c23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7Vj1EJVHACRho5KQ-ECe3g.png"/></div></div></figure><p id="b264" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated"><strong class="kn ir">解决方案:</strong></p><pre class="md me mf mg gt nm nn no np aw nq bi"><span id="b566" class="mu jo iq nn b gy nr ns l nt nu">class Solution(object):<br/>    def maxProbability(self, n, edges, succProb, start, end):<br/>        """<br/>        :type n: int<br/>        :type edges: List[List[int]]<br/>        :type succProb: List[float]<br/>        :type start: int<br/>        :type end: int<br/>        :rtype: float<br/>        """<br/>        graph = [{} for i in range(n)]<br/>        for i in range(len(edges)):<br/>            i, j = edges.pop()<br/>            graph[i][j] = graph[j][i] = succProb.pop()<br/>        <br/>        queue = [(-1, start)]<br/>        visited = set()<br/>        <br/>        while queue:<br/>            p, i = heappop(queue)<br/>            <br/>            if i == end:<br/>                return -p<br/>            <br/>            if i not in visited:<br/>                visited.add(i)<br/>            <br/>            for j, q in graph[i].items():<br/>                if j not in visited:<br/>                    heappush(queue, (p*q, j))<br/>                    <br/>        return 0.0</span></pre><h2 id="4013" class="mu jo iq bd jp mv mw dn jt mx my dp jx kw mz na kb la nb nc kf le nd ne kj nf bi translated">你能到达的最远的建筑</h2><p id="2c27" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">给你一个表示建筑物高度的整数数组<code class="fe nw nx ny nn b">heights</code>，有的<code class="fe nw nx ny nn b">bricks</code>，有的<code class="fe nw nx ny nn b">ladders</code>。</p><p id="8853" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">你通过建造<code class="fe nw nx ny nn b">0</code>开始你的旅程，并通过使用砖块或梯子移动到下一个建筑。</p><p id="2d76" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">当从建筑<code class="fe nw nx ny nn b">i</code>移动到建筑<code class="fe nw nx ny nn b">i+1</code>(<strong class="kn ir">0-索引</strong>)时，</p><ul class=""><li id="0d7d" class="lo lp iq kn b ko lj ks lk kw lq la lr le ls li lt lu lv lw bi translated">如果当前建筑的高度大于或等于下一个建筑的高度，你不需要梯子或砖块。</li><li id="15a5" class="lo lp iq kn b ko lx ks ly kw lz la ma le mb li lt lu lv lw bi translated">如果当前建筑的高度比下一个建筑的高度低，你可以使用一个梯子或者砖块。</li></ul><p id="e695" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated"><em class="nz">返回你能到达的最远的建筑指数(0-指数),如果你最佳地使用给定的梯子和砖块。</em></p><p id="a9b4" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">示例:</p><pre class="md me mf mg gt nm nn no np aw nq bi"><span id="2e83" class="mu jo iq nn b gy nr ns l nt nu"><strong class="nn ir">Input:</strong> heights = [4,2,7,6,9,14,12], bricks = 5, ladders = 1<br/><strong class="nn ir">Output:</strong> 4<br/><strong class="nn ir">Explanation:</strong> Starting at building 0, you can follow these steps:<br/>- Go to building 1 without using ladders nor bricks since 4 &gt;= 2.<br/>- Go to building 2 using 5 bricks. You must use either bricks or ladders because 2 &lt; 7.<br/>- Go to building 3 without using ladders nor bricks since 7 &gt;= 6.<br/>- Go to building 4 using your only ladder. You must use either bricks or ladders because 6 &lt; 9.<br/>It is impossible to go beyond building 4 because you do not have any more bricks or ladders.</span></pre><p id="01cf" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated"><strong class="kn ir">解决方案:</strong></p><pre class="md me mf mg gt nm nn no np aw nq bi"><span id="0e0c" class="mu jo iq nn b gy nr ns l nt nu">class Solution(object):<br/>    def furthestBuilding(self, heights, bricks, ladders):<br/>        """<br/>        :type heights: List[int]<br/>        :type bricks: int<br/>        :type ladders: int<br/>        :rtype: int<br/>        """<br/>        laddersUsed = []</span><span id="00b4" class="mu jo iq nn b gy nv ns l nt nu">for i in range(len(heights) - 1):<br/>            diff = heights[i + 1] - heights[i]<br/>            if diff &lt;= 0:<br/>                continue<br/>            <br/>            heapq.heappush(laddersUsed, diff)<br/>            if ladders:<br/>                ladders -= 1<br/>                continue<br/>            <br/>            bricks -= heapq.heappop(laddersUsed)<br/>            if bricks &lt; 0:<br/>                return i<br/>        <br/>        return len(heights) - 1</span></pre><h2 id="1c76" class="mu jo iq bd jp mv mw dn jt mx my dp jx kw mz na kb la nb nc kf le nd ne kj nf bi translated">K次增量后的最大乘积</h2><p id="3ed0" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">给你一个非负整数数组<code class="fe nw nx ny nn b">nums</code>和一个整数<code class="fe nw nx ny nn b">k</code>。在一次操作中，你可以从<code class="fe nw nx ny nn b">nums</code>中选择<strong class="kn ir">任何一个</strong>元素，<strong class="kn ir">用<code class="fe nw nx ny nn b">1</code>将</strong>递增。</p><p id="575c" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">返回<em class="nz"/><strong class="kn ir"><em class="nz">最大值</em> </strong> <em class="nz"> </em> <strong class="kn ir"> <em class="nz">乘积</em></strong><em class="nz"/><code class="fe nw nx ny nn b">nums</code><em class="nz"/><strong class="kn ir"><em class="nz">后最多</em> </strong> <em class="nz"> </em> <code class="fe nw nx ny nn b">k</code> <em class="nz">运算。</em>既然答案可能很大，那就返回吧<strong class="kn ir">模</strong> <code class="fe nw nx ny nn b">109 + 7</code>。请注意，您应该在取模之前将乘积最大化。</p><p id="1038" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">示例:</p><pre class="md me mf mg gt nm nn no np aw nq bi"><span id="fcd7" class="mu jo iq nn b gy nr ns l nt nu"><strong class="nn ir">Input:</strong> nums = [0,4], k = 5<br/><strong class="nn ir">Output:</strong> 20<br/><strong class="nn ir">Explanation:</strong> Increment the first number 5 times.<br/>Now nums = [5, 4], with a product of 5 * 4 = 20.<br/>It can be shown that 20 is maximum product possible, so we return 20.<br/>Note that there may be other ways to increment nums to have the maximum product.</span></pre><p id="508a" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated"><strong class="kn ir">解决方案:</strong></p><pre class="md me mf mg gt nm nn no np aw nq bi"><span id="327d" class="mu jo iq nn b gy nr ns l nt nu">import heapq</span><span id="79af" class="mu jo iq nn b gy nv ns l nt nu">class Solution(object):<br/>    def maximumProduct(self, nums, k):<br/>        """<br/>        :type nums: List[int]<br/>        :type k: int<br/>        :rtype: int<br/>        """<br/>        heapq.heapify(nums)<br/>        <br/>        for _ in range(k):<br/>            item = heapq.heappop(nums)<br/>            heapq.heappush(nums,  item + 1)<br/>            <br/>        product = 1<br/>        mod = 10 ** 9 + 7<br/>        <br/>        for num in nums:<br/>            product  = (product * num) % mod<br/>        <br/>        return product</span></pre><h2 id="4947" class="mu jo iq bd jp mv mw dn jt mx my dp jx kw mz na kb la nb nc kf le nd ne kj nf bi translated">到达拐角所需的最小障碍移除</h2><p id="0d21" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">给你一个大小为<code class="fe nw nx ny nn b">m x n</code>的<strong class="kn ir"> 0索引的</strong> 2D整数数组<code class="fe nw nx ny nn b">grid</code>。每个单元格有两个值之一:</p><ul class=""><li id="4987" class="lo lp iq kn b ko lj ks lk kw lq la lr le ls li lt lu lv lw bi translated"><code class="fe nw nx ny nn b">0</code>代表一个<strong class="kn ir">空的</strong>单元格，</li><li id="f9ce" class="lo lp iq kn b ko lx ks ly kw lz la ma le mb li lt lu lv lw bi translated"><code class="fe nw nx ny nn b">1</code>表示一个<strong class="kn ir">障碍物</strong>可以被移除。</li></ul><p id="9984" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">您可以在空单元格之间上下左右移动。</p><p id="d256" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">返回<em class="nz"/><strong class="kn ir"><em class="nz">最小</em> </strong> <em class="nz">数量</em> <strong class="kn ir"> <em class="nz">障碍</em> </strong> <em class="nz">到</em> <strong class="kn ir"> <em class="nz">去掉</em> </strong> <em class="nz">这样就可以从左上角的</em> <code class="fe nw nx ny nn b">(0, 0)</code>移动到右下角的 <code class="fe nw nx ny nn b">(m - 1, n - 1)</code>。</p><p id="a097" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">示例:</p><pre class="md me mf mg gt nm nn no np aw nq bi"><span id="c083" class="mu jo iq nn b gy nr ns l nt nu"><strong class="nn ir">Input:</strong> grid = [[0,1,1],[1,1,0],[1,1,0]]<br/><strong class="nn ir">Output:</strong> 2<br/><strong class="nn ir">Explanation:</strong> We can remove the obstacles at (0, 1) and (0, 2) to create a path from (0, 0) to (2, 2).<br/>It can be shown that we need to remove at least 2 obstacles, so we return 2.<br/>Note that there may be other ways to remove 2 obstacles to create a path.</span></pre><p id="dbae" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated"><strong class="kn ir">解决方案:</strong></p><pre class="md me mf mg gt nm nn no np aw nq bi"><span id="9e12" class="mu jo iq nn b gy nr ns l nt nu">class Solution(object):<br/>    def minimumObstacles(self, grid):<br/>        """<br/>        :type grid: List[List[int]]<br/>        :rtype: int<br/>        """<br/>        m, n = len(grid), len(grid[0])<br/>        # minimum removed obstacles table<br/>        dp = [[float('inf') for _ in range(n)] for _ in range(m)]<br/>        dp[0][0] = grid[0][0]<br/>        <br/>        # removed obstacles count, i, j<br/>        heap = [(0, 0, 0)]<br/>  <br/>        while heap:<br/>            removed, i, j = heappop(heap)<br/>            if i == m-1 and j == n-1:<br/>                return removed<br/>            <br/>            for ii, jj in [(i, j+1), (i+1, j), (i, j-1), (i-1, j)]:<br/>                if (0 &lt;= ii &lt; m and 0 &lt;= jj &lt; n) and grid[ii][jj] + removed &lt; dp[ii][jj]:<br/>                    dp[ii][jj] = grid[ii][jj] + removed<br/>                    heappush(heap, (dp[ii][jj], ii, jj))<br/>        return dp[-1][-1]</span></pre><h2 id="395f" class="mu jo iq bd jp mv mw dn jt mx my dp jx kw mz na kb la nb nc kf le nd ne kj nf bi translated">合并k个排序列表</h2><p id="2eca" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">给你一个<code class="fe nw nx ny nn b">k</code>链表<code class="fe nw nx ny nn b">lists</code>的数组，每个链表按升序排序。</p><p id="07d3" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated"><em class="nz">将所有链表合并成一个排序后的链表并返回。</em></p><p id="175f" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated"><strong class="kn ir">例1: </strong></p><pre class="md me mf mg gt nm nn no np aw nq bi"><span id="3f43" class="mu jo iq nn b gy nr ns l nt nu"><strong class="nn ir">Input:</strong> lists = [[1,4,5],[1,3,4],[2,6]]<br/><strong class="nn ir">Output:</strong> [1,1,2,3,4,4,5,6]<br/><strong class="nn ir">Explanation:</strong> The linked-lists are:<br/>[<br/>  1-&gt;4-&gt;5,<br/>  1-&gt;3-&gt;4,<br/>  2-&gt;6<br/>]<br/>merging them into one sorted list:<br/>1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</span></pre><p id="c259" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated"><strong class="kn ir">解决方案</strong></p><pre class="md me mf mg gt nm nn no np aw nq bi"><span id="0b8a" class="mu jo iq nn b gy nr ns l nt nu">import heapq</span><span id="1728" class="mu jo iq nn b gy nv ns l nt nu"># Definition for singly-linked list.<br/># class ListNode(object):<br/>#     def __init__(self, val=0, next=None):<br/>#         self.val = val<br/>#         self.next = next<br/>class Solution(object):<br/>    def mergeKLists(self, lists):<br/>        """<br/>        :type lists: List[ListNode]<br/>        :rtype: ListNode<br/>        """<br/>        heap = []<br/>        <br/>        for item in lists:<br/>            while item:<br/>                heapq.heappush(heap, item.val)<br/>                item = item.next<br/>        <br/>        result = None<br/>        head = None<br/>        <br/>        while heap:<br/>            item = heapq.heappop(heap)<br/>            if not result:<br/>                result = ListNode(item)<br/>                head = result<br/>            else:<br/>                result.next = ListNode(item)<br/>                result = result.next<br/>        <br/>        return head</span></pre><h2 id="9481" class="mu jo iq bd jp mv mw dn jt mx my dp jx kw mz na kb la nb nc kf le nd ne kj nf bi translated">滑动窗口最大值</h2><p id="781f" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">给你一个整数数组<code class="fe nw nx ny nn b">nums</code>，有一个大小为<code class="fe nw nx ny nn b">k</code>的滑动窗口，它从数组的最左边移动到最右边。您只能在窗口中看到<code class="fe nw nx ny nn b">k</code>数字。每次滑动窗口向右移动一个位置。</p><p id="b491" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">返回<em class="nz">最大滑动窗口</em>。</p><p id="eddc" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated"><strong class="kn ir">例1: </strong></p><pre class="md me mf mg gt nm nn no np aw nq bi"><span id="4831" class="mu jo iq nn b gy nr ns l nt nu"><strong class="nn ir">Input:</strong> nums = [1,3,-1,-3,5,3,6,7], k = 3<br/><strong class="nn ir">Output:</strong> [3,3,5,5,6,7]<br/><strong class="nn ir">Explanation:</strong> <br/>Window position                Max<br/>---------------               -----<br/>[1  3  -1] -3  5  3  6  7       <strong class="nn ir">3</strong><br/> 1 [3  -1  -3] 5  3  6  7       <strong class="nn ir">3</strong><br/> 1  3 [-1  -3  5] 3  6  7      <strong class="nn ir"> 5</strong><br/> 1  3  -1 [-3  5  3] 6  7       <strong class="nn ir">5</strong><br/> 1  3  -1  -3 [5  3  6] 7       <strong class="nn ir">6</strong><br/> 1  3  -1  -3  5 [3  6  7]      <strong class="nn ir">7</strong></span></pre><p id="89c5" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated"><strong class="kn ir">解决方案</strong></p><pre class="md me mf mg gt nm nn no np aw nq bi"><span id="766f" class="mu jo iq nn b gy nr ns l nt nu">class Solution(object):<br/>    def maxSlidingWindow(self, nums, k):<br/>        """<br/>        :type nums: List[int]<br/>        :type k: int<br/>        :rtype: List[int]<br/>        """<br/>        maxHeap = [];<br/>        windowStart = 0;<br/>        result = [];<br/>        n = len(nums)<br/>        <br/>        for i in range(n):<br/>            heapq.heappush(maxHeap, (-nums[i], i));<br/>            <br/>            if i - windowStart + 1 &gt; k:<br/>                while len(maxHeap) &gt; 0 and maxHeap[0][1] &lt;= windowStart:<br/>                    heapq.heappop(maxHeap);<br/>                windowStart += 1;<br/>                    <br/>            if i - windowStart + 1 == k:               <br/>                result.append(-maxHeap[0][0]);<br/>                <br/>        return result;</span></pre><h2 id="9be1" class="mu jo iq bd jp mv mw dn jt mx my dp jx kw mz na kb la nb nc kf le nd ne kj nf bi translated">找出总和最小的K对</h2><p id="78f7" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">给你两个整数数组<code class="fe nw nx ny nn b">nums1</code>和<code class="fe nw nx ny nn b">nums2</code>，按<strong class="kn ir">升序排列</strong>和一个整数<code class="fe nw nx ny nn b">k</code>。</p><p id="9119" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">定义一个对<code class="fe nw nx ny nn b">(u, v)</code>，它由第一个数组中的一个元素和第二个数组中的一个元素组成。</p><p id="40c7" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">返回<em class="nz">和</em>最小的 <code class="fe nw nx ny nn b">k</code> <em class="nz">对</em> <code class="fe nw nx ny nn b">(u1, v1), (u2, v2), ..., (uk, vk)</code> <em class="nz">。</em></p><p id="62bc" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated"><strong class="kn ir">例1: </strong></p><pre class="md me mf mg gt nm nn no np aw nq bi"><span id="fb5f" class="mu jo iq nn b gy nr ns l nt nu"><strong class="nn ir">Input:</strong> nums1 = [1,7,11], nums2 = [2,4,6], k = 3<br/><strong class="nn ir">Output:</strong> [[1,2],[1,4],[1,6]]<br/><strong class="nn ir">Explanation:</strong> The first 3 pairs are returned from the sequence: [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]</span></pre><p id="0406" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated"><strong class="kn ir">解决方案</strong></p><pre class="md me mf mg gt nm nn no np aw nq bi"><span id="4667" class="mu jo iq nn b gy nr ns l nt nu">import heapq</span><span id="bd29" class="mu jo iq nn b gy nv ns l nt nu">class Solution(object):<br/>    def kSmallestPairs(self, nums1, nums2, k):<br/>        """<br/>        :type nums1: List[int]<br/>        :type nums2: List[int]<br/>        :type k: int<br/>        :rtype: List[List[int]]<br/>        """<br/>        n1 = len(nums1)<br/>        n2 = len(nums2)<br/>        maxHeap = []<br/>        <br/>        for i in range(0, min(k, n1)):<br/>            for j in range(0, min(k, n2)):<br/>                total = nums1[i] + nums2[j]<br/>                <br/>                if len(maxHeap) &lt; k:<br/>                    heapq.heappush(maxHeap, [-total, nums1[i], nums2[j]])<br/>                else:<br/>                    if total &gt; -maxHeap[0][0]:<br/>                        break<br/>                    <br/>                    heapq.heappush(maxHeap, [-total, nums1[i], nums2[j]])<br/>                    <br/>                    heapq.heappop(maxHeap)<br/>        <br/>        result = []<br/>        while maxHeap:<br/>            popped = heapq.heappop(maxHeap)<br/>            result.append([popped[1], popped[2]])<br/>        <br/>        return result</span></pre><h2 id="2b1e" class="mu jo iq bd jp mv mw dn jt mx my dp jx kw mz na kb la nb nc kf le nd ne kj nf bi translated">矩阵中K个最弱的行</h2><p id="2f26" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">你会得到一个由<code class="fe nw nx ny nn b">1</code>(代表士兵)和<code class="fe nw nx ny nn b">0</code>(代表平民)组成的<code class="fe nw nx ny nn b">m x n</code>二元矩阵<code class="fe nw nx ny nn b">mat</code>。士兵被安置在平民的前面。也就是说，所有的<code class="fe nw nx ny nn b">1</code>将出现在每行所有<code class="fe nw nx ny nn b">0</code>的左侧的<strong class="kn ir">处。</strong></p><p id="7f86" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">如果下列情况之一成立，则行<code class="fe nw nx ny nn b">i</code>比行<code class="fe nw nx ny nn b">j</code>弱<strong class="kn ir">:</strong></p><ul class=""><li id="f9f2" class="lo lp iq kn b ko lj ks lk kw lq la lr le ls li lt lu lv lw bi translated">第<code class="fe nw nx ny nn b">i</code>行的士兵数量少于第<code class="fe nw nx ny nn b">j</code>行的士兵数量。</li><li id="8371" class="lo lp iq kn b ko lx ks ly kw lz la ma le mb li lt lu lv lw bi translated">两排士兵人数相同，且<code class="fe nw nx ny nn b">i &lt; j</code>。</li></ul><p id="1a06" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">返回<em class="nz">矩阵中</em> <code class="fe nw nx ny nn b">k</code> <em class="nz"> </em> <strong class="kn ir"> <em class="nz">最弱</em> </strong> <em class="nz">行的索引，从最弱到最强</em>。</p><p id="fe3f" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated"><strong class="kn ir">例一:</strong></p><pre class="md me mf mg gt nm nn no np aw nq bi"><span id="886e" class="mu jo iq nn b gy nr ns l nt nu"><strong class="nn ir">Input:</strong> mat = <br/>[[1,1,0,0,0],<br/> [1,1,1,1,0],<br/> [1,0,0,0,0],<br/> [1,1,0,0,0],<br/> [1,1,1,1,1]], <br/>k = 3<br/><strong class="nn ir">Output:</strong> [2,0,3]</span></pre><p id="ee59" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated"><strong class="kn ir">解决方案</strong></p><pre class="md me mf mg gt nm nn no np aw nq bi"><span id="03c4" class="mu jo iq nn b gy nr ns l nt nu">class Solution(object):<br/>    def kWeakestRows(self, mat, k):<br/>        """<br/>        :type mat: List[List[int]]<br/>        :type k: int<br/>        :rtype: List[int]<br/>        """<br/>        hashMap = {}<br/>        <br/>        for i in range(len(mat)):<br/>            hashMap[i] = mat[i].count(1)<br/>        <br/>        minHeap = []<br/>        <br/>        for rowId, num in hashMap.items():<br/>            heapq.heappush(minHeap, (num, rowId))<br/>            <br/>        lst = []<br/>        while k &gt; 0:<br/>            popped = heapq.heappop(minHeap)<br/>            lst.append(popped[1])<br/>            k -= 1<br/>        <br/>        return lst</span></pre><h2 id="892e" class="mu jo iq bd jp mv mw dn jt mx my dp jx kw mz na kb la nb nc kf le nd ne kj nf bi translated">对角线导线II</h2><p id="95cb" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">给定一个2D整数数组<code class="fe nw nx ny nn b">nums</code>，按对角线顺序返回 <code class="fe nw nx ny nn b">nums</code> <em class="nz">的所有元素<em class="nz">，如下图</em> .3所示</em></p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi od"><img src="../Images/44a661b7aa3049ad999af952731165f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tUW1jhV9r665G7y6rTozUg.png"/></div></div></figure><p id="3066" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated"><strong class="kn ir">解决方案</strong></p><pre class="md me mf mg gt nm nn no np aw nq bi"><span id="2be2" class="mu jo iq nn b gy nr ns l nt nu">class Solution(object):<br/>    def findDiagonalOrder(self, nums):<br/>        """<br/>        :type nums: List[List[int]]<br/>        :rtype: List[int]<br/>        """<br/>        heap = []<br/>        <br/>        for i in range(len(nums)):<br/>            for j in range(len(nums[i])):<br/>                heapq.heappush(heap, [i+j, j, i])<br/>        <br/>        result = []<br/>        <br/>        while len(heap) &gt; 0:<br/>            popped = heapq.heappop(heap)<br/>            result.append(nums[popped[2]][popped[1]])<br/>        <br/>        return result</span></pre><h2 id="abca" class="mu jo iq bd jp mv mw dn jt mx my dp jx kw mz na kb la nb nc kf le nd ne kj nf bi translated">优先级分配</h2><p id="9cc1" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">人力资源管理员创建了一个队列，列出了所有当前的合规性问题及其优先级。优先级范围从1到99。创建一个重新分配优先级的算法，使分配的最大优先级值最小化，同时保持所有问题之间的优先级顺序相同。</p><p id="339f" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated"><strong class="kn ir">例</strong> <br/>优先级= [1，4，8，4]</p><p id="1634" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated"><strong class="kn ir">输出</strong>:<br/>【1，2，3，2】</p><p id="144d" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated"><strong class="kn ir">解决方案</strong></p><pre class="md me mf mg gt nm nn no np aw nq bi"><span id="ac30" class="mu jo iq nn b gy nr ns l nt nu"># Priorities</span><span id="b350" class="mu jo iq nn b gy nv ns l nt nu">priorities = [1, 3, 7, 3]</span><span id="47e9" class="mu jo iq nn b gy nv ns l nt nu">def getPriorities(priorities):<br/>    n = len(priorities)<br/>    heap = []<br/>    <br/>    for i in range(n):<br/>        heapq.heappush(heap, (priorities[i], i))<br/>    <br/>    priority = 0<br/>    prevNumber = 0<br/>    <br/>    while len(heap) &gt; 0:<br/>        popped = heapq.heappop(heap)<br/>        <br/>        if prevNumber != popped[0]:<br/>            priority += 1<br/>            prevNumber = popped[0]<br/>        <br/>        priorities[popped[1]] = priority<br/>    <br/>    return priorities<br/>        <br/>        <br/>if __name__ == '__main__':<br/>    result = getPriorities(priorities)<br/>    print(result)</span></pre><h2 id="4b7d" class="mu jo iq bd jp mv mw dn jt mx my dp jx kw mz na kb la nb nc kf le nd ne kj nf bi translated">结论</h2><p id="994b" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在开始解决任何问题陈述之前，理解和识别数据结构和算法的模式是非常重要的。模式识别使解决方案变得简单。最小堆或最大堆或优先级队列也是一个棘手的概念。</p></div></div>    
</body>
</html>