<html>
<head>
<title>Seccomp in Kubernetes — Part 2: Crafting custom seccomp profiles for your applications</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes中的Seccomp—第2部分:为您的应用程序制作定制的sec comp配置文件</h1>
<blockquote>原文：<a href="https://itnext.io/seccomp-in-kubernetes-part-2-crafting-custom-seccomp-profiles-for-your-applications-c28c658f676e?source=collection_archive---------0-----------------------#2020-05-27">https://itnext.io/seccomp-in-kubernetes-part-2-crafting-custom-seccomp-profiles-for-your-applications-c28c658f676e?source=collection_archive---------0-----------------------#2020-05-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/12fdf7c3b9e666d1725a9fb2601f779b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fNqW6bkjbsq627DyfwPQgw.png"/></div></div></figure><div class=""/><div class=""><h2 id="2921" class="pw-subtitle-paragraph jy ja jb bd b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp dk translated">这是关于如何在不诉诸魔法或巫术的情况下为您的工作负载获得出色的seccomp配置文件的系列文章中的第二篇。这次要亲自动手了！</h2></div><p id="2424" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">在本系列第1部分的<a class="ae lm" rel="noopener ugc nofollow" target="_blank" href="/seccomp-in-kubernetes-part-i-7-things-you-should-know-before-you-even-start-97502ad6b6d6">之后，我们应该能够切换齿轮并开始创建一些seccomp配置文件。提醒一下，如果您关注最低权限、范围良好的概要文件，您可能会关注在容器级别应用它们。否则，你可能会以更大的轮廓告终，正如我在本期</a>的<a class="ae lm" href="https://github.com/kubernetes/kubernetes/issues/84623" rel="noopener ugc nofollow" target="_blank">中强调的那样。</a></p><h1 id="f174" class="ln lo jb bd lp lq lr ls lt lu lv lw lx kh ly ki lz kk ma kl mb kn mc ko md me bi translated">我该从何说起呢？</h1><p id="3c63" class="pw-post-body-paragraph kq kr jb ks b kt mf kc kv kw mg kf ky kz mh lb lc ld mi lf lg lh mj lj lk ll ij bi translated">seccomp配置文件只不过是一个系统调用的列表，这些系统调用具有与之相关的操作，这可以有效地将它列为黑名单或白名单，后者是推荐的方法。</p><p id="762a" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">获取应用程序在幕后进行的所有系统调用的列表是问题所在。主要原因是:</p><ul class=""><li id="87dd" class="mk ml jb ks b kt ku kw kx kz mm ld mn lh mo ll mp mq mr ms bi translated">您的应用程序中可能有很少执行的边缘场景，这可能需要非常具体的系统调用。只有在评估整个执行路径时，才能检测到这些系统调用。</li><li id="ff81" class="mk ml jb ks b kt mt kw mu kz mv ld mw lh mx ll mp mq mr ms bi translated">您的依赖项也可能会进行系统调用。从与应用程序相关的依赖项中精确地枚举执行路径可能不是一件小事。</li><li id="3325" class="mk ml jb ks b kt mt kw mu kz mv ld mw lh mx ll mp mq mr ms bi translated">在“投诉模式”(即使用动作<code class="fe my mz na nb b">SCMP_ACT_LOG</code>)下运行您的配置文件可能不会记录所有系统调用。</li><li id="ce07" class="mk ml jb ks b kt mt kw mu kz mv ld mw lh mx ll mp mq mr ms bi translated">使用seccomp配置文件运行且没有任何错误的容器，<em class="nc">可能仍会</em>阻止合法调用，这可能会导致长时间运行时出现问题。</li></ul><h1 id="92b4" class="ln lo jb bd lp lq lr ls lt lu lv lw lx kh ly ki lz kk ma kl mb kn mc ko md me bi translated">好吧，但是我该怎么做呢？</h1><p id="ce10" class="pw-post-body-paragraph kq kr jb ks b kt mf kc kv kw mg kf ky kz mh lb lc ld mi lf lg lh mj lj lk ll ij bi translated">有几种不同的方法可以帮助列出应用程序的系统调用。没有一个是完美的，但结合起来就足够好了。下面是我偶然发现的一些例子:</p><h1 id="81c3" class="ln lo jb bd lp lq lr ls lt lu lv lw lx kh ly ki lz kk ma kl mb kn mc ko md me bi translated">1.通过跟踪或BPF附加到进程</h1><p id="7ba3" class="pw-post-body-paragraph kq kr jb ks b kt mf kc kv kw mg kf ky kz mh lb lc ld mi lf lg lh mj lj lk ll ij bi translated">像<code class="fe my mz na nb b">strace</code>这样的工具允许你执行一个命令并理解它发出的所有系统调用。如果您要创建一个配置文件来允许一个容器对一个网站执行ping操作，那么<code class="fe my mz na nb b">strace</code>命令应该是这样的:</p><pre class="nd ne nf ng gt nh nb ni nj aw nk bi"><span id="181c" class="nl lo jb nb b gy nm nn l no np">strace -fqc ping -c 20 <a class="ae lm" href="http://www.google.com" rel="noopener ugc nofollow" target="_blank">www.google.com</a></span><span id="57eb" class="nl lo jb nb b gy nq nn l no np">% time     seconds  usecs/call     calls    errors syscall<br/>------ ----------- ----------- --------- --------- ----------------<br/> 29.55    0.000078           4        20        11 openat<br/> 14.02    0.000037           9         4         4 socket<br/> 11.74    0.000031           3        12           mprotect<br/>  6.06    0.000016           2         7           read<br/>  5.68    0.000015           1        17           mmap<br/>  5.68    0.000015           3         5           capget<br/>  4.92    0.000013          13         1           munmap<br/>  3.79    0.000010           1         9           fstat<br/>  3.41    0.000009           9         1           write<br/>  3.41    0.000009           1         9           close<br/>  2.65    0.000007           2         3           brk<br/>  2.65    0.000007           4         2           prctl<br/>  2.27    0.000006           3         2           getuid<br/>  1.52    0.000004           4         1           setuid<br/>  1.52    0.000004           4         1           capset<br/>  1.14    0.000003           3         1           geteuid<br/>  0.00    0.000000           0         9         9 access<br/>  0.00    0.000000           0         1           execve<br/>  0.00    0.000000           0         3           fcntl<br/>  0.00    0.000000           0         1           arch_prctl<br/>------ ----------- ----------- --------- --------- ----------------<br/>100.00    0.000264                   109        24 total</span></pre><p id="ae95" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这不会产生非常精确的结果。例如，<code class="fe my mz na nb b">capset</code>和<code class="fe my mz na nb b">setuid</code>并不是容器执行该命令的必要系统调用，我们将在后面看到。</p><p id="7337" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">类似的方法是使用<a class="ae lm" href="https://github.com/containers/oci-seccomp-bpf-hook" rel="noopener ugc nofollow" target="_blank"> OCI赛康BPF钩</a>，它将通过OCI钩触发，使用BPF检查您的集装箱。当你在运行容器的时候有一堆测试用例时，这是非常有用的。</p><p id="0251" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">但是，我不建议在生产环境中运行这个来生成您的seccomp概要文件。这是因为为了检查您的工作负载而给予第三方容器高权限(即<code class="fe my mz na nb b">CAP_SYS_ADMIN</code>)会产生相反的效果，因此您可以使用最低特权配置文件运行自己的应用程序。</p><p id="386b" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">当您的用例非常具体时(例如<code class="fe my mz na nb b">ping</code>)，这两种方法都会很有帮助。但是后者可能更适合复杂的应用程序。</p><h1 id="6159" class="ln lo jb bd lp lq lr ls lt lu lv lw lx kh ly ki lz kk ma kl mb kn mc ko md me bi translated">2.检查代码/中间语言</h1><p id="b62c" class="pw-post-body-paragraph kq kr jb ks b kt mf kc kv kw mg kf ky kz mh lb lc ld mi lf lg lh mj lj lk ll ij bi translated">另一种方法是检查应用程序的代码或其程序集，试图枚举所有正在进行的系统调用。不过，我不建议手动这么做。</p><p id="76df" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我为golang二进制文件创建了一个简单的应用程序,结果如下:</p><pre class="nd ne nf ng gt nh nb ni nj aw nk bi"><span id="e51e" class="nl lo jb nb b gy nm nn l no np">$ <strong class="nb jc">zaz seccomp main</strong><br/>{<br/>    "defaultAction": "SCMP_ACT_ERRNO",<br/>    "architectures": [<br/>        "SCMP_ARCH_X86_64",<br/>        "SCMP_ARCH_X86",<br/>        "SCMP_ARCH_X32"<br/>    ],<br/>    "syscalls": [<br/>        {<br/>            "names": [<br/>                "arch_prctl",<br/>                "bind",<br/>                "close",<br/>                "epoll_ctl",<br/>                "exit_group",<br/>                "fcntl",<br/>                "fstat",<br/>                "futex",<br/>                "getpgrp",<br/>                "getpid",<br/>                "gettid",<br/>                "madvise",<br/>                "mmap",<br/>                "openat",<br/>                "read",<br/>                "readlinkat",<br/>                "rt_sigaction",<br/>                "rt_sigprocmask",<br/>                "sched_yield",<br/>                "setsockopt",<br/>                "tgkill",<br/>                "write"<br/>            ],<br/>            "action": "SCMP_ACT_ALLOW"<br/>        }<br/>    ]<br/>}</span></pre><p id="99e8" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">该应用代码是:</p><pre class="nd ne nf ng gt nh nb ni nj aw nk bi"><span id="7605" class="nl lo jb nb b gy nm nn l no np">package main</span><span id="b3b0" class="nl lo jb nb b gy nq nn l no np">import (<br/>        "fmt"<br/>        "net/http"<br/>        "os"<br/>)</span><span id="2ea8" class="nl lo jb nb b gy nq nn l no np">func main() {<br/>        val := os.Getenv("test")<br/>        fmt.Printf("contents of $test: %s\n", val)</span><span id="2256" class="nl lo jb nb b gy nq nn l no np">fs := http.FileServer(http.Dir("."))<br/>        http.Handle("/fs/", http.StripPrefix("/fs/", fs))<br/>        http.HandleFunc("/", rootHandler)</span><span id="f8be" class="nl lo jb nb b gy nq nn l no np">fmt.Println("server started at port 8088")<br/>        err := http.ListenAndServe(":8088", nil)<br/>        if err != nil {<br/>                panic(err)<br/>        }<br/>}</span><span id="b035" class="nl lo jb nb b gy nq nn l no np">func rootHandler(w http.ResponseWriter, r *http.Request) {<br/>        fmt.Fprintf(w, "Hello...")<br/>}</span></pre><p id="2d8a" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">稍后我将在容器中使用它。作为参考，下面是我使用的Dockerfile:</p><pre class="nd ne nf ng gt nh nb ni nj aw nk bi"><span id="bc10" class="nl lo jb nb b gy nm nn l no np">FROM golang:1.14 as build<br/>WORKDIR /go/src/webapi</span><span id="7682" class="nl lo jb nb b gy nq nn l no np">ADD . .<br/>RUN go build -o app main.go</span><span id="4ab9" class="nl lo jb nb b gy nq nn l no np">FROM golang:1.14<br/>WORKDIR /go/src/webapi</span><span id="a9b2" class="nl lo jb nb b gy nq nn l no np">ENV test=somevalue<br/>COPY --from=build /go/src/webapi/app .</span><span id="b337" class="nl lo jb nb b gy nq nn l no np">CMD ["/go/src/webapi/app"]</span></pre><p id="38d0" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">回到我们的例子，<code class="fe my mz na nb b">zaz</code>遍历了应用程序及其依赖项的“执行路径”。对于依赖项，它只考虑了将由您的执行路径执行的代码部分。</p><p id="e08b" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">结果似乎是一个良好的开端，然而，这并不是全貌。对于您的最终概要文件，您可能还需要添加运行基本映像所需的系统调用，我将在“制作seccomp概要文件”一节中介绍。</p><h1 id="ec1d" class="ln lo jb bd lp lq lr ls lt lu lv lw lx kh ly ki lz kk ma kl mb kn mc ko md me bi translated">3.抱怨模式</h1><p id="1096" class="pw-post-body-paragraph kq kr jb ks b kt mf kc kv kw mg kf ky kz mh lb lc ld mi lf lg lh mj lj lk ll ij bi translated">Seccomp还支持“抱怨模式”，在这种模式下，它记录被调用的系统调用，而不是阻塞它们。</p><p id="c6c2" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">尝试从该模式获取配置文件的一个常见问题是，默认情况下它是节流的。为了最大限度地利用它，我建议调整日志节流，这样您可以获得比平时更多的调用。在Ubuntu上，您可以使用以下命令检查/调整节流:</p><pre class="nd ne nf ng gt nh nb ni nj aw nk bi"><span id="9cea" class="nl lo jb nb b gy nm nn l no np"><strong class="nb jc"># List existing configuration</strong><br/>$ sudo sysctl -a | grep net.core.message<br/>net.core.message_burst = 10<br/>net.core.message_cost = 5</span><span id="8c4c" class="nl lo jb nb b gy nq nn l no np"><strong class="nb jc"># Set burst and cost to zero</strong><br/>sudo sysctl -w net.core.message_burst=0<br/>sudo sysctl -w net.core.message_cost=0</span></pre><p id="0dad" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">在这种情况下，只需定义默认操作即可创建“投诉模式”seccomp配置文件:</p><pre class="nd ne nf ng gt nh nb ni nj aw nk bi"><span id="1fad" class="nl lo jb nb b gy nm nn l no np">{<br/>    "defaultAction": "SCMP_ACT_LOG"<br/>}</span></pre><p id="478a" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">请注意，不阻止高风险呼叫，可能会使您的主机容易受到恶意容器的攻击。因此，请谨慎使用。一个潜在的方法是阻止高风险的呼叫，同时记录所有其他内容。</p><p id="abfd" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">使用“抱怨模式”查找系统调用的过程是:</p><p id="7bef" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><strong class="ks jc"> A .使用配置文件运行容器:</strong></p><pre class="nd ne nf ng gt nh nb ni nj aw nk bi"><span id="587a" class="nl lo jb nb b gy nm nn l no np">docker run --rm --security-opt=<strong class="nb jc">seccomp=complain-mode.json</strong> --security-opt=<strong class="nb jc">no-new-privileges</strong> --expose 8088 --<strong class="nb jc">cap-drop=ALL</strong> sampleweb:latest</span></pre><p id="a836" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">请注意，在上面的例子中，我是用no-new-privileges运行的，放弃了所有功能，并使用先前创建的概要文件。您的工作负载可能需要一些功能，如果不需要，请养成总是放弃它们的习惯。</p><p id="9b6b" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><strong class="ks jc"> B .对应用程序运行测试:</strong></p><pre class="nd ne nf ng gt nh nb ni nj aw nk bi"><span id="9b7f" class="nl lo jb nb b gy nm nn l no np">curl <a class="ae lm" href="http://172.17.0.2:8088" rel="noopener ugc nofollow" target="_blank">http://172.17.0.2:8088</a><br/>curl <a class="ae lm" href="http://172.17.0.2:8088/fs/" rel="noopener ugc nofollow" target="_blank">http://172.17.0.2:8088/fs/</a></span></pre><p id="4cd0" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">在这里，我只是评估我的两个端点。</p><p id="1f4b" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><strong class="ks jc"> C .评估记录的呼叫:</strong></p><pre class="nd ne nf ng gt nh nb ni nj aw nk bi"><span id="a8af" class="nl lo jb nb b gy nm nn l no np">grep audit /var/log/syslog | grep "webapi/app"</span></pre><p id="e621" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">结果应该是这样的:</p><figure class="nd ne nf ng gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nr"><img src="../Images/bdd3b73ebb23bde7ed0383d0e15bed14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1sJz8okV5Dg6nrMbw7fz5g.png"/></div></div></figure><p id="bbba" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">要轻松提取所有这些系统调用ID，您可以通过使用您在syslog上找到的PID来使用<code class="fe my mz na nb b">zaz</code>:</p><figure class="nd ne nf ng gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ns"><img src="../Images/6f4485c4e5d3ce35e8e496f443b814c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ieNN2wR0HNIxk0esbC5w1w.png"/></div></div></figure><p id="afde" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><strong class="ks jc"> D .修改配置文件:</strong></p><p id="01a4" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">使用allow操作将找到的所有系统调用添加到一个节中:</p><pre class="nd ne nf ng gt nh nb ni nj aw nk bi"><span id="6ad1" class="nl lo jb nb b gy nm nn l no np">{<br/>    "defaultAction": "SCMP_ACT_LOG",<br/>    "architectures": [<br/>        "SCMP_ARCH_X86_64",<br/>        "SCMP_ARCH_X86",<br/>        "SCMP_ARCH_X32"<br/>    ],<br/>    "syscalls": [<br/>        {<br/>            "names": [<br/>                "accept4",<br/>                "access",<br/>                "brk",<br/>                "close",<br/>                "epoll_ctl",<br/>                "execve",<br/>                "fstat",<br/>                "futex",<br/>                "getsockname",<br/>                "mmap",<br/>                "nanosleep",<br/>                "openat",<br/>                "setsockopt"<br/>            ],<br/>            "action": "SCMP_ACT_ALLOW"<br/>        }<br/>    ]<br/>}</span></pre><p id="0928" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这将确保seccomp只记录不在您的允许列表中的呼叫。</p><p id="87c5" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><strong class="ks jc"> E .从步骤A重新开始:</strong></p><p id="6b2e" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">不幸的是，在使用“抱怨模式”时，并不是所有的系统调用都会被一次记录下来。因此，您可能需要多次重复此过程，直到syslog上不再记录新条目。</p><p id="286e" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">此时，您可以将日志限制设置恢复为其原始值:</p><pre class="nd ne nf ng gt nh nb ni nj aw nk bi"><span id="dd80" class="nl lo jb nb b gy nm nn l no np"><strong class="nb jc"># Reset burst and cost to original values</strong><br/>sudo sysctl -w net.core.message_burst=10<br/>sudo sysctl -w net.core.message_cost=5</span></pre><p id="7fde" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">值得注意的是，没有记录条目并不意味着您捕获了应用程序所依赖的所有系统调用，这就是这种方法本身并不完美的原因。</p><h1 id="e0ad" class="ln lo jb bd lp lq lr ls lt lu lv lw lx kh ly ki lz kk ma kl mb kn mc ko md me bi translated">4.强力</h1><p id="c933" class="pw-post-body-paragraph kq kr jb ks b kt mf kc kv kw mg kf ky kz mh lb lc ld mi lf lg lh mj lj lk ll ij bi translated">使用前三种方法有时不足以制作赛康公司简介。考虑到这一点，我在<code class="fe my mz na nb b"><a class="ae lm" href="https://github.com/pjbgf/zaz" rel="noopener ugc nofollow" target="_blank">zaz</a></code>上创建了一个模块，它使用蛮力来达到给定工作负载所需的最小系统调用。</p><p id="4705" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">在执行过程中，它将尝试使用所有允许的系统调用运行容器，除了被评估的系统调用。如果它出错，<code class="fe my mz na nb b">zaz</code>会将它标记为一个必要的调用，并在结束时返回。</p><p id="cc12" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">它最有用的例子是当试图获得基本图像的最小轮廓时:</p><figure class="nd ne nf ng gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nt"><img src="../Images/b1de1ca5fdb601cce70d1d7b261d1556.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZJXNoJQrZ_gpQDEapI4xIA.png"/></div></div><figcaption class="nu nv gj gh gi nw nx bd b be z dk translated">像<code class="fe my mz na nb b">ubuntu</code>或<code class="fe my mz na nb b">alpine</code>这样的基础映像可能有不同的seccomp需求。</figcaption></figure><p id="8219" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">它还支持在映像内部执行给定的命令:</p><figure class="nd ne nf ng gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ny"><img src="../Images/be91ac52a0e8e12ad21b8324f271743c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g8r_6PU1Y_vthFTOWtg9Cg.png"/></div></div></figure><p id="96a6" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">但是为命令生成的配置文件可能不如简单基本映像那样准确。当这个<a class="ae lm" href="https://github.com/pjbgf/zaz/issues/7" rel="noopener ugc nofollow" target="_blank">问题</a>解决后，这种情况可能会改变。</p><h1 id="219f" class="ln lo jb bd lp lq lr ls lt lu lv lw lx kh ly ki lz kk ma kl mb kn mc ko md me bi translated">制作Seccomp档案——将它们混合在一起</h1><p id="eecf" class="pw-post-body-paragraph kq kr jb ks b kt mf kc kv kw mg kf ky kz mh lb lc ld mi lf lg lh mj lj lk ll ij bi translated">要获得细粒度的seccomp配置文件，您必须将上述几种方法结合起来。下面是我上面提到的应用程序的一个例子:</p><ol class=""><li id="8be7" class="mk ml jb ks b kt ku kw kx kz mm ld mn lh mo ll nz mq mr ms bi translated"><strong class="ks jc">应用分析</strong></li></ol><p id="2a1c" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">使用<code class="fe my mz na nb b">zaz seccomp BINARY</code>对应用进行概要分析:</p><pre class="nd ne nf ng gt nh nb ni nj aw nk bi"><span id="788c" class="nl lo jb nb b gy nm nn l no np">{"defaultAction":"SCMP_ACT_ERRNO","architectures":["SCMP_ARCH_X86_64","SCMP_ARCH_X86","SCMP_ARCH_X32"],"syscalls":[{"names":["arch_prctl","bind","close","epoll_ctl","exit_group","fcntl","fstat","futex","getpgrp","getpid","gettid","madvise","mmap","openat","read","readlinkat","rt_sigaction","rt_sigprocmask","sched_yield","setsockopt","tgkill","write"],"action":"SCMP_ACT_ALLOW"}]}</span></pre><p id="07bb" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">尝试使用生成的概要文件执行容器。它会失败，并显示以下错误:</p><pre class="nd ne nf ng gt nh nb ni nj aw nk bi"><span id="8633" class="nl lo jb nb b gy nm nn l no np">$ docker run --rm --security-opt=<strong class="nb jc">seccomp=webapp.json</strong> --security-opt=<strong class="nb jc">no-new-privileges</strong> --expose 8088 --<strong class="nb jc">cap-drop=ALL</strong> sampleweb:latest</span><span id="cc69" class="nl lo jb nb b gy nq nn l no np">standard_init_linux.go:211: exec user process caused “operation not permitted”</span></pre><p id="a516" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><strong class="ks jc"> 2。基础图像分析</strong></p><p id="5cb6" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">获取基础映像所需的系统调用，在本例中是golang:1.14: <code class="fe my mz na nb b">zaz seccomp docker golang:1.14</code>:</p><pre class="nd ne nf ng gt nh nb ni nj aw nk bi"><span id="c7df" class="nl lo jb nb b gy nm nn l no np">{"defaultAction":"SCMP_ACT_ERRNO","architectures":["SCMP_ARCH_X86_64","SCMP_ARCH_X86","SCMP_ARCH_X32"],"syscalls":[{"names":["arch_prctl","bind","clock_gettime","close","connect","dup2","epoll_pwait","execve","exit","exit_group","fcntl","futex","getpid","getsockname","getuid","ioctl","mprotect","nanosleep","open","poll","read","recvfrom","rt_sigaction","rt_sigprocmask","rt_sigreturn","sendto","set_tid_address","setitimer","setsockopt","socket","write","writev"],"action":"SCMP_ACT_ALLOW"}]}</span></pre><p id="5639" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">将它们添加到现有的配置文件中。再次运行应用程序仍然会产生错误:</p><pre class="nd ne nf ng gt nh nb ni nj aw nk bi"><span id="a1ca" class="nl lo jb nb b gy nm nn l no np">$ docker run --rm --security-opt=<strong class="nb jc">seccomp=webapp.json</strong> --security-opt=<strong class="nb jc">no-new-privileges</strong> --expose 8088 --<strong class="nb jc">cap-drop=ALL</strong> sampleweb:latest</span><span id="e924" class="nl lo jb nb b gy nq nn l no np">fatal error: uname failed<br/>runtime: panic before malloc heap initialized</span><span id="f1a9" class="nl lo jb nb b gy nq nn l no np">runtime stack:<br/>runtime.throw(0x6fd6de, 0xc)<br/>        /usr/local/go/src/runtime/panic.go:1116 +0x72...</span></pre><p id="e124" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><strong class="ks jc"> 3。以投诉模式运行</strong></p><p id="0ecd" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">将配置文件的默认操作更改为<code class="fe my mz na nb b">SCMP_ACT_LOG</code>，并再次运行应用程序。对应用程序运行一些请求并获取进程ID:</p><pre class="nd ne nf ng gt nh nb ni nj aw nk bi"><span id="2ee3" class="nl lo jb nb b gy nm nn l no np">curl <a class="ae lm" href="http://172.17.0.6:8088" rel="noopener ugc nofollow" target="_blank">http://172.17.0.6:8088</a><br/>curl <a class="ae lm" href="http://172.17.0.6:8088/fs/" rel="noopener ugc nofollow" target="_blank">http://172.17.0.6:8088/fs/</a><br/>grep audit /var/log/syslog | grep "webapi/app"</span></pre><p id="ef6f" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">运行<code class="fe my mz na nb b">zaz seccomp --log-file=/var/log/syslog PID</code>产生几个更多的调用:</p><pre class="nd ne nf ng gt nh nb ni nj aw nk bi"><span id="580e" class="nl lo jb nb b gy nm nn l no np">{"defaultAction":"SCMP_ACT_ERRNO","architectures":["SCMP_ARCH_X86_64","SCMP_ARCH_X86","SCMP_ARCH_X32"],"syscalls":[{"names":["accept4","getdents64","newfstatat"],"action":"SCMP_ACT_ALLOW"}]}</span></pre><p id="f32e" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">将新呼叫添加到配置文件中，然后再次运行应用程序。这个过程会持续几次，对我来说是两次:</p><pre class="nd ne nf ng gt nh nb ni nj aw nk bi"><span id="51a7" class="nl lo jb nb b gy nm nn l no np"># First result<br/>{"defaultAction":"SCMP_ACT_ERRNO","architectures":["SCMP_ARCH_X86_64","SCMP_ARCH_X86","SCMP_ARCH_X32"],"syscalls":[{"names":["access","brk","mlock","munmap","prlimit64","sched_getaffinity","set_robust_list","uname"],"action":"SCMP_ACT_ALLOW"}]}</span><span id="aa90" class="nl lo jb nb b gy nq nn l no np"># Second result<br/>{"defaultAction":"SCMP_ACT_ERRNO","architectures":["SCMP_ARCH_X86_64","SCMP_ARCH_X86","SCMP_ARCH_X32"],"syscalls":[{"names":["clone","sigaltstack"],"action":"SCMP_ACT_ALLOW"}]}</span></pre><p id="1c46" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">将这些电话添加到配置文件中。重试时，syslog上将不会出现新条目。</p><p id="e038" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><strong class="ks jc"> 4。处理未解决的错误</strong></p><p id="f0d9" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">将默认动作改为<code class="fe my mz na nb b">SCMP_ACT_ERRNO</code>。再次运行应用程序，它仍然不工作。关于<code class="fe my mz na nb b">epollcreate</code>的错误抱怨:</p><pre class="nd ne nf ng gt nh nb ni nj aw nk bi"><span id="bd6d" class="nl lo jb nb b gy nm nn l no np">$ docker run --rm --security-opt=<strong class="nb jc">seccomp=webapp.json</strong> --security-opt=<strong class="nb jc">no-new-privileges</strong> --expose 8088 --<strong class="nb jc">cap-drop=ALL</strong> sampleweb:latest</span><span id="470a" class="nl lo jb nb b gy nq nn l no np">runtime: epollcreate failed with 1<br/>fatal error: runtime: netpollinit failed</span><span id="b4e7" class="nl lo jb nb b gy nq nn l no np">goroutine 1 [running]:<br/>runtime.throw(0x70261e, 0x1b)<br/>        /usr/local/go/src/runtime/panic.go:1116 +0x72...</span></pre><p id="72ea" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">将syscalls <code class="fe my mz na nb b">epoll_create</code>和<code class="fe my mz na nb b">epoll_wait</code>添加到配置文件中，然后重试。出现了一个新错误:</p><pre class="nd ne nf ng gt nh nb ni nj aw nk bi"><span id="0bbd" class="nl lo jb nb b gy nm nn l no np">$ docker run --rm --security-opt=<strong class="nb jc">seccomp=webapp.json</strong> --security-opt=<strong class="nb jc">no-new-privileges</strong> --expose 8088 --<strong class="nb jc">cap-drop=ALL</strong> sampleweb:latest</span><span id="7fec" class="nl lo jb nb b gy nq nn l no np">runtime: pipe failed with 1<br/>fatal error: runtime: pipe failed</span><span id="465d" class="nl lo jb nb b gy nq nn l no np">goroutine 1 [running]:<br/>runtime.throw(0x6fff05, 0x14)<br/>        /usr/local/go/src/runtime/panic.go:1116 +0x72...</span></pre><p id="b65e" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">将<code class="fe my mz na nb b">pipe</code>和<code class="fe my mz na nb b">pipe2</code>添加到配置文件，然后重试。<br/>这一次的错误报告了缺少监听套接字的权限:</p><pre class="nd ne nf ng gt nh nb ni nj aw nk bi"><span id="4eac" class="nl lo jb nb b gy nm nn l no np">$ docker run --rm --security-opt=<strong class="nb jc">seccomp=webapp.json</strong> --security-opt=<strong class="nb jc">no-new-privileges</strong> --expose 8088 --<strong class="nb jc">cap-drop=ALL</strong> sampleweb:latest</span><span id="b404" class="nl lo jb nb b gy nq nn l no np">panic: listen tcp :8088: socket: operation not permitted</span><span id="d186" class="nl lo jb nb b gy nq nn l no np">goroutine 1 [running]:<br/>main.main()<br/>        /go/src/webapi/main.go:20 +0x246</span></pre><p id="3e17" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">将<code class="fe my mz na nb b">listen</code>和<code class="fe my mz na nb b">socket</code>添加到配置文件，然后重试。终于成功了！</p><pre class="nd ne nf ng gt nh nb ni nj aw nk bi"><span id="3c83" class="nl lo jb nb b gy nm nn l no np">$ docker run --rm --security-opt=<strong class="nb jc">seccomp=webapp.json</strong> --security-opt=<strong class="nb jc">no-new-privileges</strong> --expose 8088 --<strong class="nb jc">cap-drop=ALL</strong> sampleweb:latest</span><span id="d696" class="nl lo jb nb b gy nq nn l no np">contents of $test: somevalue<br/>server started at port 8088</span></pre><p id="8590" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">对我来说最后一秒钟是:</p><pre class="nd ne nf ng gt nh nb ni nj aw nk bi"><span id="a5a8" class="nl lo jb nb b gy nm nn l no np">{<br/>    "defaultAction": "SCMP_ACT_ERRNO",<br/>    "architectures": [<br/>        "SCMP_ARCH_X86_64",<br/>        "SCMP_ARCH_X86",<br/>        "SCMP_ARCH_X32"<br/>    ],<br/>    "syscalls": [<br/>        {<br/>            "names": [                "arch_prctl","bind","clock_gettime","close","connect","dup2","epoll_pwait","execve","exit","exit_group","fcntl","futex","getpid","getsockname","getuid","ioctl","mprotect","nanosleep","open","poll","read","recvfrom","rt_sigaction","rt_sigprocmask","rt_sigreturn","sendto","set_tid_address","setitimer","setsockopt","socket","write","writev",</span><span id="f1eb" class="nl lo jb nb b gy nq nn l no np">"arch_prctl","bind","close","epoll_ctl","exit_group","fcntl","fstat","futex","getpgrp","getpid","gettid","madvise","mmap","openat","read","readlinkat","rt_sigaction","rt_sigprocmask","sched_yield","setsockopt","tgkill","write",</span><span id="40e0" class="nl lo jb nb b gy nq nn l no np">"accept4","getdents64","newfstatat",<br/>                "access","brk","mlock","munmap","prlimit64","sched_getaffinity","set_robust_list","uname",<br/>                "clone","sigaltstack",<br/>                "epoll_create", "epoll_wait",<br/>                "pipe", "pipe2",<br/>                "listen", "socket"<br/>            ],<br/>            "action": "SCMP_ACT_ALLOW"<br/>        }<br/>    ]<br/>}</span></pre><p id="c943" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我没有清理它以删除重复的调用，因为我想弄清楚哪些系统调用来自哪个交互，但是您可以在自己的界面上随意这么做。:)</p><p id="d6c6" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这个例子关注一个简单的web golang应用程序，它不需要极高的特权。但是，同样的原则也可以用于其他特权更高的工作负载。</p><h1 id="923d" class="ln lo jb bd lp lq lr ls lt lu lv lw lx kh ly ki lz kk ma kl mb kn mc ko md me bi translated">或者，使用通用配置文件模板:</h1><p id="4956" class="pw-post-body-paragraph kq kr jb ks b kt mf kc kv kw mg kf ky kz mh lb lc ld mi lf lg lh mj lj lk ll ij bi translated">在开发过程中不断地经历这个过程对于增加的安全性好处来说可能代价太高——比较非常严格的概要文件和比<code class="fe my mz na nb b">runtime/default</code>更严格的通用概要文件。</p><p id="4da1" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">如果您的应用程序正在积极开发中，或者您没有时间深入了解非常详细的配置文件，您可以使用基于您正在使用的应用程序类型的通用模板。如果您有几个类似的应用程序——具有相似依赖关系和行为的web APIs，这可能特别有用。</p><p id="dad9" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">为了更容易地创建这样的概要文件，我在<code class="fe my mz na nb b">zaz</code>上添加了一个模块来返回web应用程序的通用概要文件:</p><pre class="nd ne nf ng gt nh nb ni nj aw nk bi"><span id="85ec" class="nl lo jb nb b gy nm nn l no np">zaz seccomp template web</span></pre><p id="cac6" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这已经过golang应用程序的测试，运行良好。显然，一些工作负载可能需要额外的调用。如果你是这种情况，创建一个新的<a class="ae lm" href="https://github.com/pjbgf/zaz/issues/new/choose" rel="noopener ugc nofollow" target="_blank">问题</a>，我会确保它对社区来说足够通用。；)</p><p id="6b75" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">如果情况变得更糟，您可以简单地使用<code class="fe my mz na nb b">runtime/default</code>直到您的应用程序足够稳定，值得创建一个特定的seccomp概要文件。</p><h1 id="b462" class="ln lo jb bd lp lq lr ls lt lu lv lw lx kh ly ki lz kk ma kl mb kn mc ko md me bi translated">关键要点</h1><p id="4800" class="pw-post-body-paragraph kq kr jb ks b kt mf kc kv kw mg kf ky kz mh lb lc ld mi lf lg lh mj lj lk ll ij bi translated">现在应该很清楚，构建seccomp配置文件不是一项简单的任务，但希望使用上面的不同工具会有所帮助。在此练习中，值得一提的要点是:</p><ul class=""><li id="2c16" class="mk ml jb ks b kt ku kw kx kz mm ld mn lh mo ll mp mq mr ms bi translated">对于稳定的应用程序，最好使用粒度配置文件，否则您的工作负载可能会在生产中因边缘情况而中断。</li><li id="e769" class="mk ml jb ks b kt mt kw mu kz mv ld mw lh mx ll mp mq mr ms bi translated">当执行seccomp时，<strong class="ks jc">无错误</strong>或<strong class="ks jc">无记录违规</strong>，并不意味着没有调用系统调用。</li><li id="a700" class="mk ml jb ks b kt mt kw mu kz mv ld mw lh mx ll mp mq mr ms bi translated">当您的依赖关系发生变化时，您可能需要检查您的seccomp档案。</li><li id="daf9" class="mk ml jb ks b kt mt kw mu kz mv ld mw lh mx ll mp mq mr ms bi translated">一些基本映像可能比其他映像需要更多的系统调用。</li></ul><p id="cf3f" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">创建和维护您的seccomp配置文件是减少您的攻击面的方法之一。这可能有助于您检测您的<a class="ae lm" rel="noopener ugc nofollow" target="_blank" href="/golang-stop-trusting-your-dependencies-a4c916533b04">依赖项是否开始做它们不应该做的事情</a>。</p><h1 id="20cd" class="ln lo jb bd lp lq lr ls lt lu lv lw lx kh ly ki lz kk ma kl mb kn mc ko md me bi translated">下一步是什么…？</h1><p id="ac0b" class="pw-post-body-paragraph kq kr jb ks b kt mf kc kv kw mg kf ky kz mh lb lc ld mi lf lg lh mj lj lk ll ij bi translated">最近，我开始和一群热衷于让seccomp在Kubernetes上更容易使用的人一起工作。我们正在创建seccomp-operator，这将使用户更容易管理他们的seccomp配置文件。如果你对此感兴趣，请加入Kubernetes slack频道:<a class="ae lm" href="https://kubernetes.slack.com/archives/C013FQNB0A2" rel="noopener ugc nofollow" target="_blank"> seccomp-operator </a>。</p></div><div class="ab cl oa ob hu oc" role="separator"><span class="od bw bk oe of og"/><span class="od bw bk oe of og"/><span class="od bw bk oe of"/></div><div class="ij ik il im in"><p id="6dcd" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">关于这个主题，我还想介绍很多，所以请继续关注。</p></div></div>    
</body>
</html>