<html>
<head>
<title>Angular 6|7 RxJS 6 In-Depth Tutorial &amp; Example</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Angular 6|7 RxJS 6深入教程和示例</h1>
<blockquote>原文：<a href="https://itnext.io/angular-6-7-rxjs-6-in-depth-tutorial-example-83e897e5699?source=collection_archive---------3-----------------------#2019-02-21">https://itnext.io/angular-6-7-rxjs-6-in-depth-tutorial-example-83e897e5699?source=collection_archive---------3-----------------------#2019-02-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="0213" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本教程中，我们将学习在Angular 6或Angular 7中使用RxJS 6库。我们将了解:</p><ul class=""><li id="c350" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated">如何导入Observable类和其他操作符。</li><li id="97b9" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">如何订阅和退订Observables？</li><li id="8270" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">如何导入调用运算符并用<code class="fe kz la lb lc b">pipe()</code>函数进行链式连接？</li><li id="a838" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">我们还将看到如何使用异步管道从Angular模板订阅Observables。</li><li id="636a" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">最后，我们将看到如何使用一些流行的可管道化操作符，如<code class="fe kz la lb lc b">tap()</code>、<code class="fe kz la lb lc b">map()</code>和<code class="fe kz la lb lc b">filter()</code>，以及它们在RxJS 6中的新导入路径。</li></ul><blockquote class="ld le lf"><p id="e6a2" class="jn jo lg jp b jq jr js jt ju jv jw jx lh jz ka kb li kd ke kf lj kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="iq">注</em> </strong> <em class="iq">:本教程适用于角度6和角度7。</em></p></blockquote><p id="918d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本教程中，我们将开始了解什么是反应式编程、异步操作和数据流，以及它们与RxJS库的关系。然后我们将看到RxJS <code class="fe kz la lb lc b">Observable</code>的概念和例子，各种类型的可观察值，例如:</p><ul class=""><li id="b887" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated"><code class="fe kz la lb lc b">Subject</code>，</li><li id="ac05" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated"><code class="fe kz la lb lc b">BehaviorSubject</code>和<code class="fe kz la lb lc b">ReplaySubject</code>，</li><li id="a114" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">单播和多播可观测量，</li><li id="46b0" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">冷观和热观等。</li></ul><p id="e499" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们将了解什么是RxJS运算符，以及一些常见运算符的示例，如<code class="fe kz la lb lc b">tap()</code>、<code class="fe kz la lb lc b">map()</code>、<code class="fe kz la lb lc b">filter()</code>、<code class="fe kz la lb lc b">share()</code>等。最后，我们将看到Angular如何使用RxJS Observable来进行异步编程。</p><h1 id="fd9f" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">什么是反应式编程</h1><figure class="mj mk ml mm gt mn gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi mi"><img src="../Images/5fb8ce0f7aad14ca5f952987bb83b291.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*7ICMcW4eCJz4fjeI.jpg"/></div></div></figure><p id="b0e6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们从不同的来源来看看反应式编程的定义。</p><p id="4835" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是Andre Staltz,<a class="ae mu" href="https://cycle.js.org/" rel="noopener ugc nofollow" target="_blank">cycle . js</a>(一个可预测代码的功能性和反应性JavaScript框架)的创建者对它的定义:</p><blockquote class="ld le lf"><p id="e7a7" class="jn jo lg jp b jq jr js jt ju jv jw jx lh jz ka kb li kd ke kf lj kh ki kj kk ij bi translated"><em class="iq">反应式编程是用异步数据流编程</em></p></blockquote><p id="e7dc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这意味着当您编写处理异步操作和数据流的代码时，您正在进行反应式编程。</p><p id="7f63" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，这是来自<a class="ae mu" href="https://en.wikipedia.org/wiki/Reactive_programming" rel="noopener ugc nofollow" target="_blank">维基百科</a>的更深入的定义:</p><blockquote class="ld le lf"><p id="80c3" class="jn jo lg jp b jq jr js jt ju jv jw jx lh jz ka kb li kd ke kf lj kh ki kj kk ij bi translated">在计算中，反应式编程是一种声明式编程范例，涉及数据流和变化的传播。</p></blockquote><p id="3be5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这意味着反应式编程是一种声明式(相对于过程式)的编程风格，适用于数据流。</p><p id="4435" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">关于反应式编程和数据流的详细指南，请查看:<a class="ae mu" href="https://gist.github.com/staltz/868e7e9bc2a7b8c1f754" rel="noopener ugc nofollow" target="_blank">你错过的反应式编程介绍</a>。</p><p id="e22c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">什么是流</strong></p><p id="fd09" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">流是反应式编程中的一个基本概念，所以在我们进一步讨论之前，有必要看一下它的定义。</p><figure class="mj mk ml mm gt mn gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/c356445048a950eb61fe01493b7b9d73.png" data-original-src="https://miro.medium.com/v2/resize:fit:844/format:webp/0*lkdE5vqvHv8h-ipj.jpeg"/></div></figure><p id="beeb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在所有的定义中，我们已经看到了<strong class="jp ir">流这个词。</strong></p><p id="4f76" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么什么是溪流呢？</p><p id="1555" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">简单来说:</p><blockquote class="ld le lf"><p id="b063" class="jn jo lg jp b jq jr js jt ju jv jw jx lh jz ka kb li kd ke kf lj kh ki kj kk ij bi translated"><em class="iq">流是指数据超时的值。</em></p></blockquote><p id="6ffb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们稍后会看到，可观测量和流是非常相关的概念。</p><h1 id="eee6" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">什么是RxJS</h1><p id="bc86" class="pw-post-body-paragraph jn jo iq jp b jq mw js jt ju mx jw jx jy my ka kb kc mz ke kf kg na ki kj kk ij bi translated">现在，我们已经看到了反应式编程和数据流的概念，让我们看看RxJS是什么。</p><figure class="mj mk ml mm gt mn gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/091219050fe04496f2dcc3299f5b53ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/0*x30E7qVOzhUUqAAJ.jpg"/></div></figure><p id="5904" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">RxJS 是一个受web开发人员欢迎的库。它提供了用于处理事件和数据流的功能性和反应性编程模式，并且已经集成到许多web开发库和框架中，例如Angular。</p><p id="a6ba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">RxJS使得JavaScript开发人员使用可组合的可观察对象而不是回调和承诺来编写异步代码变得容易。</p><p id="4174" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">RxJS代表JavaScript的反应式扩展，它实际上在Java、Python、Ruby和PHP等其他编程语言中都有实现。它也适用于Android等平台。查看<a class="ae mu" href="http://reactivex.io/languages.html" rel="noopener ugc nofollow" target="_blank">支持的语言和平台的完整列表</a>。</p><p id="fef5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">RxJS v6是目前RxJS的稳定版本，它与RxJS v5有许多突破性的变化。你可以从这个官方的<a class="ae mu" href="https://github.com/ReactiveX/rxjs/blob/master/docs_app/content/guide/v6/migration.md" rel="noopener ugc nofollow" target="_blank">迁移指南</a>中查看更多关于变化以及如何从旧版本迁移的信息。</p><p id="e191" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">与之前的RxJS 5版本相比，RxJS 6有许多优势，例如:</p><ul class=""><li id="e66f" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated">库的包大小更小，</li><li id="f357" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">最新版本的性能更好，</li><li id="b203" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">RxJS 6 Observable遵循<a class="ae mu" href="https://github.com/zenparsing/es-observable" rel="noopener ugc nofollow" target="_blank"> Observable Spec提案</a>，</li><li id="6af9" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">最新版本提供了更好的可调试性，</li><li id="0b38" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">更好的模块化架构，</li><li id="547d" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">是向后兼容的。</li></ul><h1 id="25fb" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">如何安装和使用RxJS</h1><p id="ce4b" class="pw-post-body-paragraph jn jo iq jp b jq mw js jt ju mx jw jx jy my ka kb kc mz ke kf kg na ki kj kk ij bi translated">RxJS是一个JavaScript库，这意味着您可以像安装其他库一样安装它:</p><p id="39c7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">通过npm使用RxJS和ES6</strong></p><p id="fe3c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在您的项目中，您可以运行以下命令来安装RxJS:</p><p id="46e7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，您可以从<code class="fe kz la lb lc b">rxjs</code>包或子包(如<code class="fe kz la lb lc b">rxjs/operators</code>)中导入您想要使用的符号:</p><pre class="mj mk ml mm gt nc lc nd ne aw nf bi"><span id="3148" class="ng ll iq lc b gy nh ni l nj nk">import { Observable, Subscriber } from 'rxjs'; <br/>import { tap, map, filter } from 'rxjs/operators';</span></pre><p id="3ef2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们从<code class="fe kz la lb lc b">rxjs</code>导入了<code class="fe kz la lb lc b">Observable</code>和<code class="fe kz la lb lc b">Subscriber</code>符号，从<code class="fe kz la lb lc b">rxjs/operators</code>导入了<code class="fe kz la lb lc b">tap</code>、<code class="fe kz la lb lc b">map</code>和<code class="fe kz la lb lc b">filter</code>运算符。</p><p id="ecbb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们稍后会看到这些符号是什么，以及如何在您的角度应用中使用它们。</p><p id="2b85" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">使用CDN中的RxJS</strong></p><p id="eff5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您还可以在HTML文档中使用<code class="fe kz la lb lc b">&lt;script&gt;</code>来使用来自<a class="ae mu" href="https://unpkg.com/rxjs/bundles/rxjs.umd.min.js" rel="noopener ugc nofollow" target="_blank"> CDN </a>的RxJS:</p><pre class="mj mk ml mm gt nc lc nd ne aw nf bi"><span id="6c23" class="ng ll iq lc b gy nh ni l nj nk">&lt;script src="https://unpkg.com/rxjs/bundles/rxjs.umd.min.js"&gt;&lt;/script&gt;</span></pre><blockquote class="ld le lf"><p id="e5fb" class="jn jo lg jp b jq jr js jt ju jv jw jx lh jz ka kb li kd ke kf lj kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="iq">注意</em> </strong> <em class="iq">:请注意在Angular 6 &amp; 7中，RxJS 6已经包含在你的项目中，所以不需要手动安装。</em></p></blockquote><h1 id="d089" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">RxJS 6中的可观察对象、观察者和订阅是什么</h1><p id="2a86" class="pw-post-body-paragraph jn jo iq jp b jq mw js jt ju mx jw jx jy my ka kb kc mz ke kf kg na ki kj kk ij bi translated">RxJS使用可观察的概念来处理和使用异步的和基于事件的代码。</p><p id="acd2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">异步一词来源于异步。在计算机编程中，下面是来自<a class="ae mu" href="https://en.wikipedia.org/wiki/Asynchrony_(computer_programming)" rel="noopener ugc nofollow" target="_blank">维基百科</a>的异步的定义:</p><blockquote class="ld le lf"><p id="8b3e" class="jn jo lg jp b jq jr js jt ju jv jw jx lh jz ka kb li kd ke kf lj kh ki kj kk ij bi translated"><em class="iq">异步，在计算机程序设计中，是指独立于主程序流程的事件的发生以及处理这类事件的方式。这些可能是“外部”事件，例如信号的到达，或者由程序发起的与程序执行同时发生的动作，而不需要程序阻塞来等待结果。</em></p></blockquote><p id="cfd1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">读完这个定义后，您可能已经得出了异步对于计算机和编程有多重要的结论！</p><p id="bf32" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们简单点！</p><p id="0ad5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">异步</strong>代码与<strong class="jp ir">同步</strong>代码相反，后者是你第一次接触编程时思考代码的原始方式。</p><p id="3438" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当你的代码按顺序运行时，也就是按源代码中出现的顺序一条指令接一条指令地运行时，它就是同步的。</p><p id="c9bd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，让我们考虑这个简单的JavaScript代码:</p><pre class="mj mk ml mm gt nc lc nd ne aw nf bi"><span id="2220" class="ng ll iq lc b gy nh ni l nj nk">const foo = "foo" //1 <br/>const bar = "bar" //2 <br/>const foobar = foo + bar //3 <br/>console.log(foobar) //4</span></pre><p id="4b77" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">浏览器将从第1行到第4行逐行运行这个同步代码，首先分配<code class="fe kz la lb lc b">foo</code>和<code class="fe kz la lb lc b">bar</code>变量，连接它们并在控制台中显示<code class="fe kz la lb lc b">foobar</code>变量。</p><p id="61aa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">JavaScript还支持编写代码的<strong class="jp ir">异步</strong>方法，这很有意义，因为你需要在浏览器中响应用户事件，但是当你编写代码时，你实际上并不知道用户何时与你的应用程序交互(以及以何种顺序交互)。</p><p id="8536" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这最初是使用回调来实现的，您需要在代码中定义回调，并指定何时调用它们。</p><p id="f9e2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，下面的异步代码将显示<strong class="jp ir">你点击了按钮！</strong>当用户点击由<code class="fe kz la lb lc b">mybutton</code>标识符标识的按钮时:</p><pre class="mj mk ml mm gt nc lc nd ne aw nf bi"><span id="7a4e" class="ng ll iq lc b gy nh ni l nj nk">document.getElementById('mybutton').addEventListener('click', () =&gt; { <br/>    console.log("You clicked the button!") <br/>})</span></pre><p id="196a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe kz la lb lc b">addEventListener()</code>方法的第二个参数是回调。</p><p id="5912" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您还可以使用回调来处理不涉及DOM的异步操作。例如，以下代码可用于向web服务器发送HTTP POST请求:</p><pre class="mj mk ml mm gt nc lc nd ne aw nf bi"><span id="f5df" class="ng ll iq lc b gy nh ni l nj nk">const xhr = new XMLHttpRequest() <br/>xhr.onreadystatechange = () =&gt; { if (xhr.readyState === 4) {      <br/>    xhr.status === 200 ? console.log(xhr.responseText) :   <br/>    console.error('error') <br/>} <br/>} </span><span id="9ff8" class="ng ll iq lc b gy nl ni l nj nk">xhr.open('POST', 'your.server.com') <br/>xhr.send()</span></pre><p id="de7c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是在JavaScript中执行著名的Ajax调用的方式。</p><p id="1ff5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">其实，<a class="ae mu" href="https://en.wikipedia.org/wiki/Ajax_(programming)" rel="noopener ugc nofollow" target="_blank"> Ajax </a>本身就代表了<strong class="jp ir"> A </strong>同步<strong class="jp ir">J</strong>avaScript<strong class="jp ir">A</strong>nd<strong class="jp ir">X</strong>ML。</p><blockquote class="ld le lf"><p id="aed8" class="jn jo lg jp b jq jr js jt ju jv jw jx lh jz ka kb li kd ke kf lj kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="iq">注</em> </strong> <em class="iq">:发送HTTP请求(这是web应用程序中的一个常见操作)本质上是一个异步操作，因为请求到达服务器需要时间，然后服务器会将响应发送回您的客户端应用程序。与此同时，应用程序需要响应其他操作，执行其他任务，并且只在收到服务器响应时才进行处理。</em></p></blockquote><p id="274e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你曾经广泛地使用过回调，你会注意到它们的一个问题。他们很难追踪！</p><p id="ee2d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当你编写复杂的应用程序时，你通常会以编写多层嵌套的回调函数(回调函数中的回调函数)而告终。这就是所谓的<a class="ae mu" href="https://stackoverflow.com/questions/25098066/what-is-callback-hell-and-how-and-why-rx-solves-it" rel="noopener ugc nofollow" target="_blank">回调地狱</a>。</p><p id="3384" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现代JavaScript引入了其他方法或抽象来处理异步操作(不使用太多回调)，如承诺和Async/Await。</p><p id="a638" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">承诺已在<a class="ae mu" href="https://www.ecma-international.org/ecma-262/6.0/" rel="noopener ugc nofollow" target="_blank"> ES6 </a> (JS 2015)中介绍。</p><p id="6b11" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Async/await已经在ES8 (JS 2017)中引入，它实际上是承诺之上的语法糖，帮助开发人员以看起来同步的方式编写带有承诺的异步代码。</p><p id="b234" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是承诺实际上类似于回调，在某种程度上有相同的嵌套问题。</p><p id="7cfe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于开发人员总是在寻找更好的解决方案，我们现在有了使用<a class="ae mu" href="https://en.wikipedia.org/wiki/Observer_pattern" rel="noopener ugc nofollow" target="_blank">观察者</a>软件模式的可观察对象。</p><blockquote class="ld le lf"><p id="1bee" class="jn jo lg jp b jq jr js jt ju jv jw jx lh jz ka kb li kd ke kf lj kh ki kj kk ij bi translated">观察者模式是一种软件设计模式，在这种模式中，一个名为subject的对象维护一个名为observer的依赖者列表，并自动通知它们任何状态变化，通常是通过调用它们的方法之一。 <a class="ae mu" href="https://en.wikipedia.org/wiki/Observer_pattern" rel="noopener ugc nofollow" target="_blank"> <em class="iq">观察者模式</em> </a> <em class="iq">。</em></p></blockquote><p id="be6f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Observables在<a class="ae mu" href="http://reactivex.io/" rel="noopener ugc nofollow" target="_blank">react vex</a>项目中实现，该项目有多种语言的实现。RxJS是JavaScript实现。</p><blockquote class="ld le lf"><p id="8838" class="jn jo lg jp b jq jr js jt ju jv jw jx lh jz ka kb li kd ke kf lj kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="iq">注意</em> </strong> <em class="iq"> : Observables在其他很多库中都有实现，比如</em><a class="ae mu" href="https://github.com/zenparsing/zen-observable" rel="noopener ugc nofollow" target="_blank"><em class="iq">Zen-observable</em></a><em class="iq">和</em><a class="ae mu" href="https://github.com/staltz/xstream" rel="noopener ugc nofollow" target="_blank"><em class="iq">xstream</em></a><em class="iq">但是RxJS Observables在JavaScript中最受欢迎。</em></p><p id="307f" class="jn jo lg jp b jq jr js jt ju jv jw jx lh jz ka kb li kd ke kf lj kh ki kj kk ij bi translated"><em class="iq"> Observables还不是JavaScript的内置特性，但是有一个</em> <a class="ae mu" href="https://tc39.github.io/proposal-observable/" rel="noopener ugc nofollow" target="_blank"> <em class="iq">提议</em> </a> <em class="iq">将它们添加到EcmaScript中。</em></p></blockquote><p id="bf94" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，什么是RxJS可观测值？</p><p id="699a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">可观察对象是一个实体，它随着时间的推移异步地发出(或发布)多个数据值(数据流)。</p><p id="77da" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是来自<a class="ae mu" href="https://rxjs.dev/guide/overview" rel="noopener ugc nofollow" target="_blank"> RxJS文档</a>的可观察值的定义</p><blockquote class="ld le lf"><p id="bce4" class="jn jo lg jp b jq jr js jt ju jv jw jx lh jz ka kb li kd ke kf lj kh ki kj kk ij bi translated"><em class="iq"> Observable表示未来值或事件的可调用集合的概念。</em></p></blockquote><p id="8506" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">观察员和订阅者</strong></p><p id="6f1e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在使用Observables时，还会用到一些相关的概念，即<strong class="jp ir">观察者</strong>和<strong class="jp ir">订阅</strong>。</p><p id="1ae6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">观察者也被称为监听器(或消费者)，因为他们可以监听或订阅来获取观察到的数据。</p><p id="6519" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从RxJS文档中:</p><blockquote class="ld le lf"><p id="d6ba" class="jn jo lg jp b jq jr js jt ju jv jw jx lh jz ka kb li kd ke kf lj kh ki kj kk ij bi translated"><em class="iq"> Observer是一个回调集合，它知道如何监听可观察对象传递的值。</em></p></blockquote><p id="a2f9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae mu" href="http://reactivex.io/rxjs/class/es6/Subscription.js%7ESubscription.html" rel="noopener ugc nofollow" target="_blank">订阅</a>是当你订阅一个可观察对象时返回的对象。它们包含许多方法，比如<code class="fe kz la lb lc b">unsubscribe()</code>方法，您可以调用该方法来取消接收来自可观察对象的已发布值。</p><p id="cf62" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">来自官方文件:</p><blockquote class="ld le lf"><p id="4052" class="jn jo lg jp b jq jr js jt ju jv jw jx lh jz ka kb li kd ke kf lj kh ki kj kk ij bi translated"><em class="iq">订阅代表一个可观察的执行，主要用于取消执行。</em></p></blockquote><h1 id="2877" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">RxJS中的主题是什么</h1><p id="04fd" class="pw-post-body-paragraph jn jo iq jp b jq mw js jt ju mx jw jx jy my ka kb kc mz ke kf kg na ki kj kk ij bi translated"><a class="ae mu" href="https://rxjs-dev.firebaseapp.com/guide/subject" rel="noopener ugc nofollow" target="_blank">主题</a>是一种特殊类型的可观察对象，观察者也可以订阅它来接收发布的值，但有一点不同:<strong class="jp ir">这些值被多播给许多观察者</strong>。</p><blockquote class="ld le lf"><p id="833b" class="jn jo lg jp b jq jr js jt ju jv jw jx lh jz ka kb li kd ke kf lj kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="iq">注意</em></strong><em class="iq">:RxJS可观测默认为单播。</em></p></blockquote><p id="d41f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">单播仅仅意味着每个订阅的观察器具有可观察的独立执行，而多播意味着可观察的执行由多个观察器共享。</p><blockquote class="ld le lf"><p id="b7fb" class="jn jo lg jp b jq jr js jt ju jv jw jx lh jz ka kb li kd ke kf lj kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="iq">注</em> </strong> <em class="iq">:被摄体类似于角度事件发射器。</em></p></blockquote><p id="3c79" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，当使用主题而不是普通的观察对象时，所有订阅的观察对象将获得相同的发射数据值。</p><blockquote class="ld le lf"><p id="f4d4" class="jn jo lg jp b jq jr js jt ju jv jw jx lh jz ka kb li kd ke kf lj kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="iq">注</em> </strong> <em class="iq">:受试者也是观察者，即他们也可以订阅其他可观察数据，并收听已发布的数据。</em></p></blockquote><p id="0052" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">冷热可观测量</strong></p><p id="a952" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">与常规的可观测物体不同，这些物体被称为<strong class="jp ir">热点</strong>。热可观察对象甚至在任何观察者订阅它之前就开始发出事件，这意味着如果观察者没有在正确的时间订阅，他们可能会丢失以前发出的值，而当至少有一个观察者订阅时，<strong class="jp ir">冷</strong>可观察对象开始发出值。</p><blockquote class="ld le lf"><p id="cff0" class="jn jo lg jp b jq jr js jt ju jv jw jx lh jz ka kb li kd ke kf lj kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="iq">注意</em> </strong> <em class="iq">:您可以使用</em> <code class="fe kz la lb lc b"><em class="iq">asObservable()</em></code> <em class="iq">方法将一个主题转换为唯一一个可观察对象。</em></p></blockquote><h1 id="192f" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">RxJS' <code class="fe kz la lb lc b">BehaviorSubject</code>和<code class="fe kz la lb lc b">ReplaySubject</code></h1><p id="17bc" class="pw-post-body-paragraph jn jo iq jp b jq mw js jt ju mx jw jx jy my ka kb kc mz ke kf kg na ki kj kk ij bi translated">RxJS提供了另外两种类型的科目:<code class="fe kz la lb lc b">BehaviorSubject</code>和<code class="fe kz la lb lc b">ReplaySubject</code>。</p><p id="a68b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于普通主题，稍后订阅的观察器将不会收到在订阅之前发出的数据值。在许多情况下，这不是我们想要实现的行为。这可以用<code class="fe kz la lb lc b">BehaviorSubject</code>和<code class="fe kz la lb lc b">ReplaySubject</code>解决。</p><p id="65b5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe kz la lb lc b">ReplaySubject</code>使用一个缓冲区来保存发出的值，并在订阅新的观察器时重新发出它们。</p><p id="0aa0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe kz la lb lc b">BehaviorSubject</code>的工作方式与<code class="fe kz la lb lc b">ReplaySubject</code>相似，但只是重新发出最后一次发出的值。</p><h1 id="8989" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">如何创建RxJS可观察值</h1><p id="23e1" class="pw-post-body-paragraph jn jo iq jp b jq mw js jt ju mx jw jx jy my ka kb kc mz ke kf kg na ki kj kk ij bi translated">您可以使用<code class="fe kz la lb lc b">Observable.create()</code>方法创建一个RxJS可观察对象，该方法采用一个带有<code class="fe kz la lb lc b">observer</code>参数的函数。然后，您可以订阅返回的可观察实例。</p><p id="7f0a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">除了静态<code class="fe kz la lb lc b">create()</code>方法之外，还有许多其他方法来创建可观测量:</p><ul class=""><li id="95de" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated">从被调用的实例(源)创建新的可观察对象的<code class="fe kz la lb lc b">lift()</code>实例方法，</li><li id="9ed3" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">创建单值可观察值的<code class="fe kz la lb lc b">of()</code>算子。接下来我们会看到一个例子，</li><li id="e8ec" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated"><code class="fe kz la lb lc b">interval(interval)</code>操作符，它创建一个可观察的对象，发出一个无限的数字序列。每个数字以恒定的时间间隔(以秒为单位)发出，</li><li id="b851" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated"><a class="ae mu" href="http://reactivex.io/documentation/operators/timer.html" rel="noopener ugc nofollow" target="_blank"> timer() </a>运算符，它返回一个可观察值，在指定的时间后，在每个指定的持续时间内按顺序发出数字，</li><li id="fed1" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated"><code class="fe kz la lb lc b">from()</code>方法从一个数组或承诺中创建一个可观察值，</li><li id="2e2a" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">从DOM事件创建可观察对象的<code class="fe kz la lb lc b">fromEvent()</code>方法，</li><li id="018b" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated"><code class="fe kz la lb lc b">ajax()</code>方法创建了一个发送Ajax请求的Observable。</li></ul><p id="5e65" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">稍后我们将通过示例来了解这些创建方法。</p><h1 id="ca1a" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">如何订阅RxJS观察</h1><p id="e2c3" class="pw-post-body-paragraph jn jo iq jp b jq mw js jt ju mx jw jx jy my ka kb kc mz ke kf kg na ki kj kk ij bi translated">在创建了一个<code class="fe kz la lb lc b">Observable</code>之后，您可以在返回<code class="fe kz la lb lc b">Subscription</code>实例的实例上使用<code class="fe kz la lb lc b">subscribe()</code>方法来订阅它。</p><h1 id="9b6b" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">RxJS可观察值的简单示例</h1><p id="b9f9" class="pw-post-body-paragraph jn jo iq jp b jq mw js jt ju mx jw jx jy my ka kb kc mz ke kf kg na ki kj kk ij bi translated">现在让我们看一个创建和使用可观察对象的简单例子。</p><p id="c9f4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先让我们创建一个可观察的:</p><pre class="mj mk ml mm gt nc lc nd ne aw nf bi"><span id="8f87" class="ng ll iq lc b gy nh ni l nj nk">let ob$ = Observable.create((observer) =&gt; { <br/>    observer.next("A new value!"); <br/>});</span></pre><p id="a37d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们创建了一个<code class="fe kz la lb lc b">ob$</code>可观察对象，并定义了我们的可观察对象应该在传入方法的主体中执行的逻辑。</p><p id="8b78" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这个例子中，可观察对象将简单地发出<strong class="jp ir">一个新值！</strong>对订阅观察者的价值。</p><blockquote class="ld le lf"><p id="66df" class="jn jo lg jp b jq jr js jt ju jv jw jx lh jz ka kb li kd ke kf lj kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="iq">注</em> </strong> <em class="iq">:美元符号只是一种命名变量的约定，用于保存可观测量的实例。</em></p></blockquote><p id="d6b5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们调用observer对象的<code class="fe kz la lb lc b">next()</code>方法来通知它可用的值。</p><blockquote class="ld le lf"><p id="b66f" class="jn jo lg jp b jq jr js jt ju jv jw jx lh jz ka kb li kd ke kf lj kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="iq">注意</em> </strong> <em class="iq">:所有观察者对象都必须有</em><code class="fe kz la lb lc b"><em class="iq">next()</em></code><em class="iq"/><code class="fe kz la lb lc b"><em class="iq">complete()</em></code><em class="iq"/><code class="fe kz la lb lc b"><em class="iq">error()</em></code><em class="iq">等方法的集合。这使得可观测量可以与它们交流。</em></p><p id="6693" class="jn jo lg jp b jq jr js jt ju jv jw jx lh jz ka kb li kd ke kf lj kh ki kj kk ij bi translated"><em class="iq">观察对象使用</em> <code class="fe kz la lb lc b"><em class="iq">next()</em></code> <em class="iq">方法将值(发布值)传递给订阅的观察对象。</em></p></blockquote><p id="bc68" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，让我们创建一个观察者对象:</p><pre class="mj mk ml mm gt nc lc nd ne aw nf bi"><span id="fece" class="ng ll iq lc b gy nh ni l nj nk">let observer = { next: data =&gt; console.log( 'Data received: ', data), complete: data =&gt; console.log('Completed'), };</span></pre><p id="c802" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">观察者是一个普通的JavaScript对象，它包含诸如<code class="fe kz la lb lc b">next()</code>、<code class="fe kz la lb lc b">complete()</code>和<code class="fe kz la lb lc b">error()</code>之类的方法。这意味着它知道如何从可观察对象那里得到通知。</p><blockquote class="ld le lf"><p id="85d1" class="jn jo lg jp b jq jr js jt ju jv jw jx lh jz ka kb li kd ke kf lj kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="iq">注意</em> </strong> <em class="iq">:除了</em><code class="fe kz la lb lc b"><em class="iq">next()</em></code><em class="iq"/><code class="fe kz la lb lc b"><em class="iq">complete()</em></code><em class="iq"/><code class="fe kz la lb lc b"><em class="iq">error()</em></code><em class="iq">之外，还可以给观察者对象添加其他自定义属性和方法。</em></p></blockquote><p id="26cc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，让我们订阅我们的<code class="fe kz la lb lc b">ob$</code>可观察值并返回一个<code class="fe kz la lb lc b">Subscription</code>:</p><pre class="mj mk ml mm gt nc lc nd ne aw nf bi"><span id="ceb2" class="ng ll iq lc b gy nh ni l nj nk">let subscription = ob$.subscribe(observer);</span></pre><p id="c3b4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦您订阅了<code class="fe kz la lb lc b">ob$</code> Observable，您将在控制台中获得以下输出:</p><pre class="mj mk ml mm gt nc lc nd ne aw nf bi"><span id="aa4b" class="ng ll iq lc b gy nh ni l nj nk">Data received: A new value!</span></pre><h1 id="8f2f" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">RxJS运算符</h1><p id="01cf" class="pw-post-body-paragraph jn jo iq jp b jq mw js jt ju mx jw jx jy my ka kb kc mz ke kf kg na ki kj kk ij bi translated">RxJS提供了可观察概念的实现，还提供了各种允许您组合可观察对象的操作符。</p><p id="f672" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">操作符提供了一种声明性的方式来执行复杂的异步操作。</p><p id="ef92" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">操作符通过观察发出的值并对它们应用预期的转换来处理源可观察对象，然后返回带有修改值的新可观察对象。</p><p id="e93a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有许多RxJS运算符，例如:</p><ul class=""><li id="d25d" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated"><code class="fe kz la lb lc b">tap()</code>，</li><li id="2bd2" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated"><code class="fe kz la lb lc b">map()</code>，</li><li id="6ba5" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated"><code class="fe kz la lb lc b">filter()</code>，</li><li id="b27f" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated"><code class="fe kz la lb lc b">concat()</code>，</li><li id="0bc6" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated"><code class="fe kz la lb lc b">share()</code>，</li><li id="42c5" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated"><code class="fe kz la lb lc b">retry()</code>，</li><li id="dbe9" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated"><code class="fe kz la lb lc b">catchError()</code>，</li><li id="e4ed" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated"><code class="fe kz la lb lc b">switchMap()</code>，</li><li id="5037" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">以及<code class="fe kz la lb lc b">flatMap()</code>等。</li></ul><h1 id="99e6" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">管道:组合多个运算符</h1><p id="fd99" class="pw-post-body-paragraph jn jo iq jp b jq mw js jt ju mx jw jx jy my ka kb kc mz ke kf kg na ki kj kk ij bi translated">RxJS提供了两个版本的<code class="fe kz la lb lc b">pipe()</code>函数:独立的函数和<code class="fe kz la lb lc b">Observable</code>接口上的方法。</p><p id="3729" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以使用<code class="fe kz la lb lc b">pipe()</code>函数/方法来组合多个运算符。例如:</p><pre class="mj mk ml mm gt nc lc nd ne aw nf bi"><span id="3d3a" class="ng ll iq lc b gy nh ni l nj nk">import { filter, map } from 'rxjs/operators'; </span><span id="2244" class="ng ll iq lc b gy nl ni l nj nk">const squareOf2 = of(1, 2, 3, 4, 5,6).pipe( filter(num =&gt; num % 2 === 0), map(num =&gt; num * num)); </span><span id="1740" class="ng ll iq lc b gy nl ni l nj nk">squareOf2.subscribe( (num) =&gt; console.log(num));</span></pre><p id="faf3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe kz la lb lc b">of()</code>方法将从<code class="fe kz la lb lc b">1, 2, 3, 4, 5,6</code>数字创建并返回一个可观察值，而<code class="fe kz la lb lc b">pipe()</code>方法将对每个发出的值应用<code class="fe kz la lb lc b">filter()</code>和<code class="fe kz la lb lc b">map()</code>运算符。</p><h1 id="2b50" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">如何在角度上使用可观测量</h1><p id="eabf" class="pw-post-body-paragraph jn jo iq jp b jq mw js jt ju mx jw jx jy my ka kb kc mz ke kf kg na ki kj kk ij bi translated">Angular使用RxJS Observable作为其许多API的内置类型，例如:</p><ul class=""><li id="bd2a" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated">方法返回观察值，只有当你订阅返回的观察值时，实际的请求才会被发送。</li><li id="89de" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">路由器在多个地方使用可观测数据，例如:</li><li id="7c0d" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">路由器实例的<code class="fe kz la lb lc b"><a class="ae mu" href="https://angular.io/api/router/Router#events" rel="noopener ugc nofollow" target="_blank">events</a></code>是监听路由器上事件的可观察对象。</li><li id="f172" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">此外，<code class="fe kz la lb lc b">ActivatedRoute</code>(包含与路由器出口上当前加载的组件相关联的路由信息)具有许多可观察的属性，例如路由参数的<code class="fe kz la lb lc b">params</code>和<code class="fe kz la lb lc b">paramMap</code>。</li></ul><p id="1b92" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们假设，您有一个Angular组件和作为<code class="fe kz la lb lc b">router</code>注入的路由器服务。这个来自<a class="ae mu" href="https://stackoverflow.com/questions/33520043/how-to-detect-a-route-change-in-angular" rel="noopener ugc nofollow" target="_blank"> StackOverflow </a>的例子向您展示了如何订阅路由器事件来检测路由变化:</p><pre class="mj mk ml mm gt nc lc nd ne aw nf bi"><span id="ca10" class="ng ll iq lc b gy nh ni l nj nk">import { Component } from '@angular/core'; <br/>import { Router, Event, NavigationStart, NavigationEnd, NavigationError } from '@angular/router';<br/>@Component({<br/>    selector: 'app-root',<br/>    template: `&lt;router-outlet&gt;&lt;/router-outlet&gt;`<br/>})<br/>export class AppComponent {<br/>    constructor(private router: Router) {<br/>        this.router.events.subscribe((event: Event) =&gt; {<br/>            if (event instanceof NavigationStart) {<br/>                console.log("Navigation start");<br/>            }<br/>            if (event instanceof NavigationEnd) {<br/>                console.log("Navigation end");<br/>            }<br/>            if (event instanceof NavigationError) {<br/><br/>                console.log(event.error);<br/>            }<br/>        });<br/>   }<br/>}</span></pre><ul class=""><li id="99b9" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated">反应式表单模块使用反应式编程和观察值来监听用户输入。</li><li id="a5d2" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">组件中的<code class="fe kz la lb lc b">@output()</code>装饰器接受一个<code class="fe kz la lb lc b">EventEmitter</code>实例。<code class="fe kz la lb lc b">EventEmitter</code>是RxJS可观测的子类。</li></ul><h1 id="bad4" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">如何在你的角码中使用RxJS 6可观测</h1><p id="2123" class="pw-post-body-paragraph jn jo iq jp b jq mw js jt ju mx jw jx jy my ka kb kc mz ke kf kg na ki kj kk ij bi translated">Angular对所有异步事件使用Observables(用RxJS库实现)。如果您使用Angular CLI 6|7，RxJS 6将默认安装在您的项目中。</p><p id="2aa4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">否则，您可以使用以下命令通过npm安装它:</p><pre class="mj mk ml mm gt nc lc nd ne aw nf bi"><span id="034d" class="ng ll iq lc b gy nh ni l nj nk">$ npm install rxjs --save</span></pre><p id="0a0b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了能够在代码中使用可观察符号，首先需要导入它:</p><pre class="mj mk ml mm gt nc lc nd ne aw nf bi"><span id="5d08" class="ng ll iq lc b gy nh ni l nj nk">import { Observable } from 'rxjs';</span></pre><p id="9424" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是RxJS 6中不同于RxJS 5的新导入路径。</p><h1 id="8d44" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">使用HttpClient模块和Observables</h1><p id="864f" class="pw-post-body-paragraph jn jo iq jp b jq mw js jt ju mx jw jx jy my ka kb kc mz ke kf kg na ki kj kk ij bi translated">默认情况下，新的Angular <code class="fe kz la lb lc b">HttpClient</code>适用于可观测量。<code class="fe kz la lb lc b">get()</code>、<code class="fe kz la lb lc b">post()</code>、<code class="fe kz la lb lc b">put()</code>、<code class="fe kz la lb lc b">delete()</code>等方法返回一个可观察接口的实例。</p><p id="d46b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">HTTP请求仅在我们订阅可观察对象时发送。</p><p id="3ffa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是一个发出HTTP请求的示例:</p><pre class="mj mk ml mm gt nc lc nd ne aw nf bi"><span id="d6d8" class="ng ll iq lc b gy nh ni l nj nk">getItems(): Observable&lt;Item[]&gt; {<br/>   return this.httpClient.get&lt;Item[]&gt;(this.itemUrl);<br/>}</span></pre><p id="ee95" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们假设您已经将<code class="fe kz la lb lc b">HttpClient</code>服务注入为<em class="lg"> httpClient </em>。</p><h1 id="cd91" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">使用<code class="fe kz la lb lc b">Observable</code>和<code class="fe kz la lb lc b">AsyncPipe</code></h1><p id="d3f0" class="pw-post-body-paragraph jn jo iq jp b jq mw js jt ju mx jw jx jy my ka kb kc mz ke kf kg na ki kj kk ij bi translated">Angular <code class="fe kz la lb lc b">AsyncPipe</code>订阅Observable并返回发射的数据。比如说。假设我们有这个方法:</p><pre class="mj mk ml mm gt nc lc nd ne aw nf bi"><span id="4230" class="ng ll iq lc b gy nh ni l nj nk">getItems(): Observable {<br/>  this.items$ = this.httpClient.get(this.itemUrl);<br/>}</span></pre><p id="d7c8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe kz la lb lc b">items$</code>变量属于可观察类型。</p><p id="1fc7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在组件上调用<code class="fe kz la lb lc b">getItems()</code>方法后，我们可以使用组件模板中的<code class="fe kz la lb lc b">async</code>管道来订阅返回的可观察对象:</p><h1 id="f54e" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">订阅Observables</h1><p id="a46b" class="pw-post-body-paragraph jn jo iq jp b jq mw js jt ju mx jw jx jy my ka kb kc mz ke kf kg na ki kj kk ij bi translated">Observables用于更好地支持事件处理、异步编程和处理多个值。当您定义一个可观察对象来为消费者发布一些值时，这些值直到您实际订阅该可观察对象时才会发出。</p><p id="10ad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">订阅可观察对象的消费者不断接收值，直到可观察对象完成或消费者取消订阅可观察对象。</p><p id="b93c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们从定义一个提供更新流的可观察对象开始</p><h1 id="37c5" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">使用<code class="fe kz la lb lc b">map()</code>操作符</h1><p id="87f1" class="pw-post-body-paragraph jn jo iq jp b jq mw js jt ju mx jw jx jy my ka kb kc mz ke kf kg na ki kj kk ij bi translated"><code class="fe kz la lb lc b">map()</code>操作符类似于<code class="fe kz la lb lc b">Array.map()</code>方法。它让您将可观察到的响应映射到其他值。例如:</p><pre class="mj mk ml mm gt nc lc nd ne aw nf bi"><span id="c9c4" class="ng ll iq lc b gy nh ni l nj nk">import { Observable} from 'rxjs';<br/>import { map } from 'rxjs/operators';<br/>getItems(): Observable&gt; {<br/>  return this.aService.getItems().pipe(map(response =&gt; response.data));<br/>}</span></pre><p id="ad8f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe kz la lb lc b">getItems()</code>方法返回一个可观察值。我们使用<code class="fe kz la lb lc b">map()</code>操作符返回响应对象的<code class="fe kz la lb lc b">data</code>属性。</p><p id="30e7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">操作符使我们能够将可观察流的响应映射到<code class="fe kz la lb lc b">data</code>值。</p><p id="fa15" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们从<code class="fe kz la lb lc b">rxjs/operators</code>包中导入可管道化的操作符<code class="fe kz la lb lc b">map()</code>，并使用<code class="fe kz la lb lc b">pipe()</code>方法(它采用可变数量的可管道化操作符)来包装操作符。</p><h1 id="841a" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">使用<code class="fe kz la lb lc b">filter()</code>操作符</h1><p id="52f8" class="pw-post-body-paragraph jn jo iq jp b jq mw js jt ju mx jw jx jy my ka kb kc mz ke kf kg na ki kj kk ij bi translated"><code class="fe kz la lb lc b">filter()</code>操作符类似于<code class="fe kz la lb lc b">Array.filter()</code>方法。它让你过滤可观察的流并返回另一个可观察的。例如:</p><pre class="mj mk ml mm gt nc lc nd ne aw nf bi"><span id="75ae" class="ng ll iq lc b gy nh ni l nj nk">import { Observable} from 'rxjs';<br/>import { filter } from 'rxjs/operators';<br/><br/>filter(): Observable&lt;Array&lt;any&gt;&gt; {<br/><br/>  return this.aService.getItems()<br/>    .pipe(<br/>      filter(response =&gt; response.code === 200));<br/>}</span></pre><p id="1a25" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当HTTP响应的状态代码是200时，我们使用<code class="fe kz la lb lc b">filter()</code>操作符只向可观察流的观察者发出通知。</p><h1 id="8fb0" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">结论</h1><p id="3640" class="pw-post-body-paragraph jn jo iq jp b jq mw js jt ju mx jw jx jy my ka kb kc mz ke kf kg na ki kj kk ij bi translated">在本教程中，您已经了解了反应式编程、数据流和RxJS 6。</p><p id="422c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您已经了解了反应式编程是关于用异步数据流编码的，RxJS是实现Observables和observer模式的最流行的实现。</p><p id="58b3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您已经了解了什么是可观察对象——随着时间的推移异步发出或发布值的对象。</p><p id="5d99" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你已经学习了观察体和订阅等观察体的相关概念——观察体是监听和消费观察体发布的值的对象，订阅是从<code class="fe kz la lb lc b">subscribe()</code>方法返回的对象(它们通常用于取消观察体对观察体的订阅)。</p><p id="b5e7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您还学习了特殊类型的观察对象，如主题、行为主题(<code class="fe kz la lb lc b">BehaviorSubject</code>)和重放主题(<code class="fe kz la lb lc b">ReplaySubject</code>)，以及单播和多播观察对象之间的区别。提醒一下，一个多播可观察对象在它的所有观察者之间共享它的执行。</p><p id="4d81" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您了解了冷可观测量和热可观测量——热可观测量是指可观测量在获得任何订阅之前就开始发布值。</p><p id="5b86" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您了解了RxJS操作符，这些操作符是用于组合观察值并处理其数据流的方法。</p><p id="48df" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，您了解到Angular 6 &amp; 7使用RxJS v6来处理许多常用模块中的异步操作和API(而不是回调或承诺)，如<code class="fe kz la lb lc b">HttpClient</code>、<code class="fe kz la lb lc b">Router</code>和<code class="fe kz la lb lc b">ReactiveForms</code>。</p></div></div>    
</body>
</html>