<html>
<head>
<title>Part 2: Creating the Microservice Application with the Cloud-Native Stack</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">第2部分:使用云原生堆栈创建微服务应用程序</h1>
<blockquote>原文：<a href="https://itnext.io/part-2-creating-the-microservice-application-with-the-cloud-native-stack-5a3f4ab412c9?source=collection_archive---------4-----------------------#2020-06-29">https://itnext.io/part-2-creating-the-microservice-application-with-the-cloud-native-stack-5a3f4ab412c9?source=collection_archive---------4-----------------------#2020-06-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><a href="https://www.giantswarm.io/"><div class="gh gi jn"><img src="../Images/44730719f2c0e2d48131b0e22e6fe1ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Of7aRZ7YOwZGUKYJAmCJfQ.jpeg"/></div></a></figure><p id="46fa" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><em class="ks">关于如何使用基于Kubernetes的平台轻松获得集中式日志记录、更好的安全性、性能指标和身份验证的深入系列。这是我们教程的第二部分。如果你还没看过，请查看第1部分，</em> <a class="ae kt" href="https://www.giantswarm.io/blog/how-the-cloud-native-stack-helps-writing-minimal-microservices/" rel="noopener ugc nofollow" target="_blank"> <em class="ks">云原生栈如何帮助编写最小微服务。</em> </a></p><h1 id="9f32" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">介绍</h1><p id="3e02" class="pw-post-body-paragraph ju jv iq jw b jx ls jz ka kb lt kd ke kf lu kh ki kj lv kl km kn lw kp kq kr ij bi translated">在这一节中，我们将重点关注应用程序的创建。我们将从需求和架构开始，然后转向实际的代码。请注意，我们在<a class="ae kt" href="https://www.giantswarm.io/blog/how-the-cloud-native-stack-helps-writing-minimal-microservices/" rel="noopener ugc nofollow" target="_blank">第1部分</a>中准备的与云原生平台集成的代码几乎没有任何变化。</p><h1 id="021f" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">要求</h1><p id="6aaa" class="pw-post-body-paragraph ju jv iq jw b jx ls jz ka kb lt kd ke kf lu kh ki kj lv kl km kn lw kp kq kr ij bi translated">为了展示我们基于Kubernetes的平台可以为应用程序开发人员提供什么，我们将在微服务架构中创建一个典型的“待办事项”应用程序。</p><p id="0917" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">让我们从我们对它的要求开始。</p><p id="db21" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">创建待办事项列表管理应用程序，该应用程序:</p><ul class=""><li id="b664" class="lx ly iq jw b jx jy kb kc kf lz kj ma kn mb kr mc md me mf bi translated">允许用户创建、删除和更新待办事项条目。</li><li id="f9ed" class="lx ly iq jw b jx mg kb mh kf mi kj mj kn mk kr mc md me mf bi translated">将所有待办事项条目保存在一个列表中。</li><li id="887f" class="lx ly iq jw b jx mg kb mh kf mi kj mj kn mk kr mc md me mf bi translated">应用程序的每个用户都有自己的列表，并且只能访问自己创建的条目。</li><li id="a2b4" class="lx ly iq jw b jx mg kb mh kf mi kj mj kn mk kr mc md me mf bi translated">组件需要是可伸缩的。</li><li id="733d" class="lx ly iq jw b jx mg kb mh kf mi kj mj kn mk kr mc md me mf bi translated">日志需要以JSON格式的结构化方式提供。</li><li id="3477" class="lx ly iq jw b jx mg kb mh kf mi kj mj kn mk kr mc md me mf bi translated">因为目标平台是Kubernetes，所以我们需要支持<a class="ae kt" href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/" rel="noopener ugc nofollow" target="_blank">就绪探测</a>。</li><li id="211e" class="lx ly iq jw b jx mg kb mh kf mi kj mj kn mk kr mc md me mf bi translated">为了便于配置，需要使用环境变量来配置组件。</li></ul><h1 id="e331" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">体系结构</h1><p id="17e7" class="pw-post-body-paragraph ju jv iq jw b jx ls jz ka kb lt kd ke kf lu kh ki kj lv kl km kn lw kp kq kr ij bi translated">既然我们已经有了我们的需求，是时候将我们的焦点转移到应用程序的架构上了。我们将创建两个主要组件，并使用MySQL数据库作为它们的持久数据存储。</p><p id="ba52" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这个想法如下图所示:</p><figure class="mm mn mo mp gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi ml"><img src="../Images/827bcc3105d8985870fe1972ba711b74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*3pb85Ju-zrU-1A4D.png"/></div></div></figure><p id="d382" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们的应用程序将提供一个基于HTTP的REST接口。向客户端公开API是绿色的“API服务”层的任务。这一层将负责处理HTTP请求、验证它们、记录所有请求并提供身份验证。当我们从客户端抽象出来时，这个API可以被任何可以发送HTTP请求的东西使用，包括移动、web甚至CLI应用程序。</p><p id="e9b7" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">为了限制这篇博客的范围，我们不会实现实际的客户端，我们将只使用<code class="fe mu mv mw mx b">curl</code>命令来测试API。我们还只在普通HTTP上公开API，当然，这在生产中是不可接受的，但是我们还是要稍微限制一下范围。这也将使测试更容易，将我们从关心HTTPS证书中解放出来。</p><p id="6c99" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在上面的架构图中，API服务是我们系统的网关。当一个请求通过这个网关时，在它的后面是不同微服务的土地，它们合作提供必要的服务。在我们的例子中，应用程序非常简单，整个业务逻辑由一个名为“todo manager”的服务提供。为了更好地展示Kubernetes平台如何允许您部署和管理多协议多语言解决方案，我们在这里将通信协议切换到gRPC。因为我们希望我们的“todo服务”是无状态的并且易于扩展，所以它不会保留任何持久数据。这项任务将委托给我们注入到解决方案中的MySQL数据库。</p><h1 id="95d7" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">履行</h1><p id="5e15" class="pw-post-body-paragraph ju jv iq jw b jx ls jz ka kb lt kd ke kf lu kh ki kj lv kl km kn lw kp kq kr ij bi translated">如果您对实现细节不感兴趣，只想构建并运行应用程序，那么代码已经在存储库中了，所以请跳到构建应用程序。</p><p id="28d2" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们需要实现两个服务，一个是HTTP服务器，一个是gRPC。我们将两者都使用Golang，因为它非常适合我们基于Kubernetes的环境，并且我们可以使用一些现有的工具和库以非常有效的方式创建我们的代码。这里我不会涉及每一行代码，只指出一些比较重要的部分。</p><p id="176e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">让我们从一些基本的东西开始:我们两个服务的通信契约。</p><p id="b012" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们需要为我们的两个微服务定义一个通信接口。首先，让我们定义REST API网关将服务于客户端的JSON请求和响应。我们唯一的资源叫做todo:</p><p id="cd39" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">每当我们的客户端处理一个待办事项或待办事项列表时，都会发送该对象。请注意两件事。ID由服务填充，客户端从不设置ID。其次，我们这里没有任何业主信息。现在，我们跳过REST层中的身份验证。尽管如此，我们还是希望在我们的应用程序中包含所有者信息处理，如需求中所述。将来，当REST层中添加了身份验证时，我们将从HTTP请求上下文中获得真实的用户名信息。现在，我们将在代码中以<a class="ae kt" href="https://github.com/giantswarm/giantswarm-todo-app/blob/4a78dbc3c544b6a3ee7081b19d5600c4eba5aae4/api-server/pkg/todo/routes.go#L19" rel="noopener ugc nofollow" target="_blank">常量用户名的形式使用一个简单的占位符:</a></p><p id="28b5" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们的API端点使用典型的REST方法，我们给它们都加上前缀“v1/todo ”,然后公开:</p><ul class=""><li id="ea15" class="lx ly iq jw b jx jy kb kc kf lz kj ma kn mb kr mc md me mf bi translated">POST到“/”—创建新请求(接受todo结构并返回ToDo结构)</li><li id="9a8b" class="lx ly iq jw b jx mg kb mh kf mi kj mj kn mk kr mc md me mf bi translated">转到“/”—列出单个用户的所有待办事项(待办事项列表)(不接受任何参数并返回待办事项的JSON列表)</li><li id="ba49" class="lx ly iq jw b jx mg kb mh kf mi kj mj kn mk kr mc md me mf bi translated">GET to "/{ todo ID } "-获取具有给定ID的单个ToDo(不接受参数并返回ToDo)</li><li id="ec47" class="lx ly iq jw b jx mg kb mh kf mi kj mj kn mk kr mc md me mf bi translated">PUT to“/{ todo ID }”—更新具有给定ID的单个todo(接受todo并返回todo)</li><li id="3161" class="lx ly iq jw b jx mg kb mh kf mi kj mj kn mk kr mc md me mf bi translated">DELETE to“/{ todoID }”—删除具有给定ID的单个todo(不接受任何参数，并返回一个简单的JSON响应，其中包含一个名为“success”的布尔字段)。</li></ul><p id="2dc8" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这个REST API的详细信息在“<a class="ae kt" href="https://github.com/giantswarm/giantswarm-todo-app/blob/blog_v1/api-server/pkg/todo/routes.go" rel="noopener ugc nofollow" target="_blank">API-server/pkg/todo/routes . go</a>”和“<a class="ae kt" href="https://github.com/giantswarm/giantswarm-todo-app/blob/blog_v1/api-server/pkg/todo/model.go" rel="noopener ugc nofollow" target="_blank">API-server/pkg/todo/model . go</a>”中。</p><p id="f212" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们的第二个接口是在api-server和todo-manager服务之间。这个是基于gRPC的，所以整个接口是用<a class="ae kt" href="https://developers.google.com/protocol-buffers/docs/proto3" rel="noopener ugc nofollow" target="_blank"> protobuf语法</a>描述的:</p><p id="d869" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">正如您在这里所看到的(todo-manager/pkg/proto/todo . proto)，我们将REST接口直接映射到gRPC调用，只需记住将“所有者”信息添加到每个请求中，这样ToDo-manager就可以按所有权过滤ToDo条目。</p><p id="f15b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们的API服务器非常简单。它的主要目的是充当REST端点和gRPC微服务之间的网关。通常，这种网关还集成了认证和授权、速率限制、API密钥等。目前，我们的网关将保持非常简单，只将请求传递给微服务。在讨论接口时，我们已经讨论了api-server/pkg/todo/model.go”文件。“<a class="ae kt" href="https://github.com/giantswarm/giantswarm-todo-app/blob/blog_v1/todo-manager/pkg/proto/todo.pb.go" rel="noopener ugc nofollow" target="_blank">todo-manager/pkg/proto/todo . Pb . go</a>”有很多代码，但都是自动生成的。这就是protobuf和gRPC的工作方式:它们使用“<a class="ae kt" href="https://github.com/giantswarm/giantswarm-todo-app/blob/blog_v1/todo-manager/pkg/proto/todo.proto" rel="noopener ugc nofollow" target="_blank">todo-manager/pkg/proto/todo . proto</a>”文件为您生成服务器和客户端存根。这里，我们使用生成的客户端将REST API调用传递给gRPC。gRPC客户端在“<a class="ae kt" href="https://github.com/giantswarm/giantswarm-todo-app/blob/4a78dbc3c544b6a3ee7081b19d5600c4eba5aae4/api-server/pkg/todo/routes.go#L30" rel="noopener ugc nofollow" target="_blank">API-server/pkg/todo/routes . go:L30</a>”中连接到gRPC服务器，REST API映射到<a class="ae kt" href="https://github.com/giantswarm/giantswarm-todo-app/blob/4a78dbc3c544b6a3ee7081b19d5600c4eba5aae4/api-server/pkg/todo/routes.go#L42" rel="noopener ugc nofollow" target="_blank">第42行</a>中的gRPC。请注意，我们禁用了gRPC TLS安全性(<a class="ae kt" href="https://github.com/giantswarm/giantswarm-todo-app/blob/4a78dbc3c544b6a3ee7081b19d5600c4eba5aae4/api-server/pkg/todo/routes.go#L28" rel="noopener ugc nofollow" target="_blank">第28行</a>)。我们将依靠我们的链接器来提供加密。</p><h1 id="9e32" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">待办事项管理器</h1><p id="7cdd" class="pw-post-body-paragraph ju jv iq jw b jx ls jz ka kb lt kd ke kf lu kh ki kj lv kl km kn lw kp kq kr ij bi translated">这个微服务的目的很简单:从gRPC调用中获取数据，检查所有权，并从数据库中获取数据。为了使最后一部分尽可能简短，我们在这里使用了<a class="ae kt" href="http://gorm.io/docs/" rel="noopener ugc nofollow" target="_blank"> gorm.io </a>映射器。我们用来将数据映射到数据库的对象位于“<a class="ae kt" href="https://github.com/giantswarm/giantswarm-todo-app/blob/blog_v1/todo-manager/pkg/server/model.go" rel="noopener ugc nofollow" target="_blank">todo-manager/pkg/server/model . go</a>”中。我们只需要知道数据库在哪里——这是"<a class="ae kt" href="https://github.com/giantswarm/giantswarm-todo-app/blob/blog_v1/todo-manager/pkg/server/config.go" rel="noopener ugc nofollow" target="_blank">todo-manager/pkg/server/Config . go</a>"中Config结构的作用。它从环境变量中加载我们的配置并存储它们。实际的请求服务逻辑在"<a class="ae kt" href="https://github.com/giantswarm/giantswarm-todo-app/blob/4a78dbc3c544b6a3ee7081b19d5600c4eba5aae4/todo-manager/pkg/server/server.go#L46" rel="noopener ugc nofollow" target="_blank">todo-manager/pkg/server/server . go "中，从L46 </a>开始。有一点可能很奇怪，那就是我们如何发送对“<a class="ae kt" href="https://github.com/giantswarm/giantswarm-todo-app/blob/4a78dbc3c544b6a3ee7081b19d5600c4eba5aae4/todo-manager/pkg/server/server.go#L61" rel="noopener ugc nofollow" target="_blank"> ListTodos() </a>”调用的响应。这就是所谓的gRPC流响应。利用这一点，服务器可以在对象集合变得可用时就开始发送它们，而不必等待整个列表都可用(在我们的代码中并非如此)。此外，使用流响应，gRPC客户机可以在第一个元素可用时立即开始处理列表中的元素。</p><figure class="mm mn mo mp gt jr gh gi paragraph-image"><a href="https://www.giantswarm.io/guide-cloud-native-stack?utm_campaign=Blog%20CTA%20Conversion&amp;utm_source=Cloud%20native%20stack%20guide_Blog&amp;utm_medium=Blog%20CTA&amp;utm_term=cloud%20native%20stack%20guide"><div class="gh gi my"><img src="../Images/d7568fdff4f24d79424f0759e0f34959.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ryllQrb5CO5mmyUE.jpg"/></div></a></figure><h1 id="0228" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">构建应用程序</h1><p id="3c68" class="pw-post-body-paragraph ju jv iq jw b jx ls jz ka kb lt kd ke kf lu kh ki kj lv kl km kn lw kp kq kr ij bi translated">对于我们的两个go项目，我们都提供了Makefile，这使得构建项目更加容易。它还在编译成二进制文件之前在Go代码中注入版本、提交和构建日期，因此我们可以更好地识别我们正在部署的软件的版本。因此，要构建我们的go二进制文件，我们只需在“api-server”和“todo-manager”目录中运行<code class="fe mu mv mw mx b">make</code>。</p><p id="fe1f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">下一步是构建docker图像，我们将在我们的Kubernetes平台上运行这些图像。问题是我们需要在以后让这些图像对我们的minikube集群可用。通常，这是通过使用图像注册表来完成的:我们构建图像，将它们推送到注册表，然后Kubernetes集群中的容器运行时在启动应用程序时从注册表中提取它们。这里，我们将使用一个不需要外部注册表的更简单的解决方案。使用minikube，我们的整个集群只有一个docker实例作为容器运行时，运行在minikube创建的虚拟机中。这个docker可以通过网络获得，所以我们可以从本地系统内docker安装中远程使用它。为此，我们只需要让我们的本地docker客户机与一个远程(minikube) docker服务器而不是本地服务器进行对话。为了进行配置，我们需要一些环境变量来指向minikube的docker。</p><p id="1454" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">幸运的是，minikube为此提供了一个现成的命令:</p><p id="bc9d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在我们可以建立docker图像并直接保存在minikube的Docker中。同样，在“api-server”和“todo-manager”目录中运行<code class="fe mu mv mw mx b">make docker-build</code>。完成后，我们的图像就准备好了，并呈现在Kubernetes集群中。通过运行<code class="fe mu mv mw mx b">docker images</code>进行验证。现在是时候部署我们的应用程序了。</p><p id="f6fd" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在本系列的第3部分，我们将关注<a class="ae kt" href="https://www.giantswarm.io/blog/part-3-deploying-the-application-with-helm" rel="noopener ugc nofollow" target="_blank">如何使用Helm部署应用程序。</a></p><h1 id="5d78" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">关于巨型蜂群</h1><p id="e91f" class="pw-post-body-paragraph ju jv iq jw b jx ls jz ka kb lt kd ke kf lu kh ki kj lv kl km kn lw kp kq kr ij bi translated">当在生产环境中运行Kubernetes集群时，您会意识到您将需要更多，有时甚至更多，而不仅仅是一个集群。您不仅需要关心部署，还需要关心升级、安全问题和监控。</p><p id="c50d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这就是Giant Swarm可以提供帮助的地方——我们提供托管的Kubernetes集群，因此您不必担心自己管理它们。我们还提供托管应用，即众所周知的云原生项目，我们可以在您的Kubernetes集群上为您运行这些项目，从而创建一个完全托管的云原生平台。</p><p id="a115" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">由<a class="ae kt" href="https://twitter.com/piontec" rel="noopener ugc nofollow" target="_blank">尤卡兹·piątkowski</a>:<strong class="jw ir"/>kubernetes平台架构师@ <a class="ae kt" href="https://twitter.com/giantswarm" rel="noopener ugc nofollow" target="_blank">巨型蜂群</a>撰写</p></div></div>    
</body>
</html>