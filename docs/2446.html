<html>
<head>
<title>Four patterns for global state with React hooks: Context or Redux</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带有React钩子的全局状态的四种模式:上下文或Redux</h1>
<blockquote>原文：<a href="https://itnext.io/four-patterns-for-global-state-with-react-hooks-context-or-redux-cbc2dc787380?source=collection_archive---------1-----------------------#2019-05-26">https://itnext.io/four-patterns-for-global-state-with-react-hooks-context-or-redux-cbc2dc787380?source=collection_archive---------1-----------------------#2019-05-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="33c2" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">我开发的库</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0267faf10e6be4c5b9c9d0f2fa2a190b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tcDsQQ_-IXNl3X6bbWm6aQ.jpeg"/></div></div></figure><h1 id="1905" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">介绍</h1><p id="e9c4" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">当您开始开发React应用程序时，全局状态或共享状态是最大的问题之一。该不该用Redux？钩子提供了类似Redux的解决方案吗？我想展示使用Redux的四种模式。这是我个人的观点，主要针对新的应用。</p><h1 id="4193" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">模式1:正确传球</h1><p id="7671" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">有些人可能认为它不会扩展，但是最基本的模式仍然应该是适当的传递。如果应用程序足够小，在父组件中定义本地状态，然后简单地将它传递给子组件。我可以忍受两级通过，意味着一个中间组件。</p><pre class="kj kk kl km gt mi mj mk ml aw mm bi"><span id="d2e8" class="mn kv it mj b gy mo mp l mq mr">const Parent = () =&gt; {<br/>  const [stateA, dispatchA] = useReducer(reducerA, initialStateA);<br/>  return (<br/>    &lt;&gt;<br/>      &lt;Child1 stateA={stateA} dispatchA={dispatchA} /&gt;<br/>      &lt;Child2 stateA={stateA} dispatchA={dispatchA} /&gt;<br/>    &lt;/&gt;<br/>  );<br/>};</span><span id="2501" class="mn kv it mj b gy ms mp l mq mr">const Child1 = ({ stateA, dispatchA }) =&gt; (<br/>  ...<br/>);</span><span id="6ff0" class="mn kv it mj b gy ms mp l mq mr">const Child2 = ({ stateA, dispatchA }) =&gt; (<br/>  &lt;&gt;<br/>    &lt;GrandChild stateA={stateA} dispatchA={dispatchA} /&gt;<br/>  &lt;/&gt;<br/>);</span><span id="237e" class="mn kv it mj b gy ms mp l mq mr">const GrandChild = ({ stateA, dispatchA }) =&gt; (<br/>  ...<br/>);</span></pre><h1 id="ab26" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">模式2:上下文</h1><p id="af34" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">如果一个应用程序需要在两层以上的组件之间共享状态，那么就该引入上下文了。上下文本身不提供全局状态功能，但是结合本地状态并通过上下文传递可以完成这项工作。</p><pre class="kj kk kl km gt mi mj mk ml aw mm bi"><span id="c839" class="mn kv it mj b gy mo mp l mq mr">const ContextA = createContext(null);</span><span id="b07c" class="mn kv it mj b gy ms mp l mq mr">const Parent = () =&gt; {<br/>  const [stateA, dispatchA] = useReducer(reducerA, initialStateA);<br/>  const valueA = useMemo(() =&gt; [stateA, dispatchA], [stateA]);<br/>  return (<br/>    &lt;ContextA.Provider value={valueA}&gt;<br/>      &lt;Child1 /&gt;<br/>    &lt;/ContextA.Provider&gt;<br/>  );<br/>};</span><span id="caa9" class="mn kv it mj b gy ms mp l mq mr">const Child1 = () =&gt; (<br/>  &lt;GrandChild1 /&gt;<br/>);</span><span id="f80b" class="mn kv it mj b gy ms mp l mq mr">const GrandChild1 = () =&gt; (<br/>  &lt;GrandGrandChild1 /&gt;<br/>);</span><span id="3bba" class="mn kv it mj b gy ms mp l mq mr">const GrandGrandChild1 = () =&gt; {<br/>  const [stateA, dispatchA] = useContext(ContextA);<br/>  return (<br/>    ...<br/>  );<br/>};</span></pre><p id="407b" class="pw-post-body-paragraph lm ln it lo b lp mt ju lr ls mu jx lu lv mv lx ly lz mw mb mc md mx mf mg mh im bi translated">注意，如果<code class="fe my mz na mj b">stateA</code>改变了，所有带有<code class="fe my mz na mj b">useContext(ContextA)</code>的组件都会重新渲染，即使只是状态的很小一部分。因此，不建议将上下文用于多种用途。</p><h1 id="dd6c" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">模式3:多重上下文</h1><p id="5627" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">使用多个上下文是很好的，并且更推荐用来分离关注点。上下文不必是应用范围的，它们可以用于组件树的一部分。只有当你的上下文可以在你的应用中的任何地方使用时，在根定义它们才是一个好的理由。</p><pre class="kj kk kl km gt mi mj mk ml aw mm bi"><span id="94e2" class="mn kv it mj b gy mo mp l mq mr">const ContextA = createContext(null);<br/>const ContextB = createContext(null);<br/>const ContextC = createContext(null);</span><span id="6672" class="mn kv it mj b gy ms mp l mq mr">const App = () =&gt; {<br/>  const [stateA, dispatchA] = useReducer(reducerA, initialStateA);<br/>  const [stateB, dispatchB] = useReducer(reducerB, initialStateB);<br/>  const [stateC, dispatchC] = useReducer(reducerC, initialStateC);<br/>  const valueA = useMemo(() =&gt; [stateA, dispatchA], [stateA]);<br/>  const valueB = useMemo(() =&gt; [stateB, dispatchB], [stateB]);<br/>  const valueC = useMemo(() =&gt; [stateC, dispatchC], [stateC]);<br/>  return (<br/>    &lt;ContextA.Provider value={valueA}&gt;<br/>      &lt;ContextB.Provider value={valueB}&gt;<br/>        &lt;ContextC.Provider value={valueC}&gt;<br/>          ...<br/>        &lt;/ContextC.Provider&gt;<br/>      &lt;/ContextB.Provider&gt;<br/>    &lt;/ContextA.Provider&gt;<br/>  );<br/>};</span><span id="6393" class="mn kv it mj b gy ms mp l mq mr">const Component1 = () =&gt; {<br/>  const [stateA, dispatchA] = useContext(ContextA);<br/>  return (<br/>    ...<br/>  );<br/>};</span></pre><p id="66c5" class="pw-post-body-paragraph lm ln it lo b lp mt ju lr ls mu jx lu lv mv lx ly lz mw mb mc md mx mf mg mh im bi translated">如果我们有更多的上下文，这会有点混乱。是时候介绍一些库了。有几个库支持多个上下文，其中一些提供了hooks API。</p></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><p id="6bae" class="pw-post-body-paragraph lm ln it lo b lp mt ju lr ls mu jx lu lv mv lx ly lz mw mb mc md mx mf mg mh im bi translated">我一直在开发这样一个库，叫做“react-hooks-global-state”。</p><div class="ni nj gp gr nk nl"><a href="https://github.com/dai-shi/react-hooks-global-state" rel="noopener  ugc nofollow" target="_blank"><div class="nm ab fo"><div class="nn ab no cl cj np"><h2 class="bd iu gy z fp nq fr fs nr fu fw is bi translated">戴式/反应钩式-全局-状态</h2><div class="ns l"><h3 class="bd b gy z fp nq fr fs nr fu fw dk translated">与钩子API反应的简单全局状态。通过创造一个新的世界，为Dai-Shi/react-hooks-global-state的发展作出贡献</h3></div><div class="nt l"><p class="bd b dl z fp nq fr fs nr fu fw dk translated">github.com</p></div></div><div class="nu l"><div class="nv l nw nx ny nu nz ks nl"/></div></div></a></div><p id="b52c" class="pw-post-body-paragraph lm ln it lo b lp mt ju lr ls mu jx lu lv mv lx ly lz mw mb mc md mx mf mg mh im bi translated">这是它看起来的示例代码。</p><pre class="kj kk kl km gt mi mj mk ml aw mm bi"><span id="79f3" class="mn kv it mj b gy mo mp l mq mr">import { createGlobalState } from 'react-hooks-global-state';</span><span id="7d11" class="mn kv it mj b gy ms mp l mq mr">const initialState = { <br/>  a: ...,<br/>  b: ...,<br/>  c: ...,<br/>};<br/>const { GlobalStateProvider, useGlobalState } = createGlobalState(initialState);</span><span id="8e3c" class="mn kv it mj b gy ms mp l mq mr">const App = () =&gt; (<br/>  &lt;GlobalStateProvider&gt;<br/>    ...<br/>  &lt;/GlobalStateProvider&gt;<br/>);</span><span id="5784" class="mn kv it mj b gy ms mp l mq mr">const Component1 = () =&gt; {<br/>  const [valueA, updateA] = useGlobalState('a');<br/>  return (<br/>    ...<br/>  );<br/>};</span></pre><p id="d216" class="pw-post-body-paragraph lm ln it lo b lp mt ju lr ls mu jx lu lv mv lx ly lz mw mb mc md mx mf mg mh im bi translated">这个库中至少有一个警告。它使用了一个名为<code class="fe my mz na mj b">observedBits</code>的未记录的特性，不仅不稳定，而且有其局限性，这个库只有在子状态(如<code class="fe my mz na mj b">a</code>、<code class="fe my mz na mj b">b</code>、<code class="fe my mz na mj b">c</code>)的数量等于或小于31时才有效。</p><h1 id="0d45" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">模式4: Redux</h1><p id="5d02" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">多上下文的最大限制是分派功能也是分离的。如果你的应用程序变得很大，需要用一个动作更新几个上下文，那么是时候引入Redux了。(或者，实际上您可以为一个事件分派多个动作，我个人非常不喜欢这种模式。)</p><p id="4c7e" class="pw-post-body-paragraph lm ln it lo b lp mt ju lr ls mu jx lu lv mv lx ly lz mw mb mc md mx mf mg mh im bi translated">有各种各样的库可以将Redux与hooks一起使用，官方react-redux即将发布其hooks API。</p></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><p id="dfd4" class="pw-post-body-paragraph lm ln it lo b lp mt ju lr ls mu jx lu lv mv lx ly lz mw mb mc md mx mf mg mh im bi translated">因为我在这个领域投入了大量的精力，所以让我介绍一下我的库“reactive-react-redux”。</p><div class="ni nj gp gr nk nl"><a href="https://github.com/dai-shi/reactive-react-redux" rel="noopener  ugc nofollow" target="_blank"><div class="nm ab fo"><div class="nn ab no cl cj np"><h2 class="bd iu gy z fp nq fr fs nr fu fw is bi translated">代时/反应-反应-还原</h2><div class="ns l"><h3 class="bd b gy z fp nq fr fs nr fu fw dk translated">用React钩子和代理绑定React Redux。通过创造一个新的环境，为dai-shi/reactive-react-redux的发展做出贡献</h3></div><div class="nt l"><p class="bd b dl z fp nq fr fs nr fu fw dk translated">github.com</p></div></div><div class="nu l"><div class="oa l nw nx ny nu nz ks nl"/></div></div></a></div><p id="0278" class="pw-post-body-paragraph lm ln it lo b lp mt ju lr ls mu jx lu lv mv lx ly lz mw mb mc md mx mf mg mh im bi translated">与传统的react-redux不同，这个库不需要<code class="fe my mz na mj b">mapStateToProps</code>或选择器。您可以简单地使用Redux中的全局状态，该库使用Proxy跟踪状态使用情况以进行优化。</p><p id="1b76" class="pw-post-body-paragraph lm ln it lo b lp mt ju lr ls mu jx lu lv mv lx ly lz mw mb mc md mx mf mg mh im bi translated">这是它看起来的示例代码。</p><pre class="kj kk kl km gt mi mj mk ml aw mm bi"><span id="9368" class="mn kv it mj b gy mo mp l mq mr">import { createStore } from 'redux';<br/>import {<br/>  ReduxProvider,<br/>  useReduxDispatch,<br/>  useReduxState,<br/>} from 'reactive-react-redux';</span><span id="775e" class="mn kv it mj b gy ms mp l mq mr">const initialState = {<br/>  a: ...,<br/>  b: ...,<br/>  c: ...,<br/>};</span><span id="bc33" class="mn kv it mj b gy ms mp l mq mr">const reducer = (state = initialState, action) =&gt; {<br/>  ...<br/>};</span><span id="06f8" class="mn kv it mj b gy ms mp l mq mr">const store = createStore(reducer);</span><span id="abeb" class="mn kv it mj b gy ms mp l mq mr">const App = () =&gt; (<br/>  &lt;ReduxProvider store={store}&gt;<br/>    ...<br/>  &lt;/ReduxProvider&gt;<br/>);</span><span id="5ed7" class="mn kv it mj b gy ms mp l mq mr">const Component1 = () =&gt; {<br/>  const { a } = useReduxState();<br/>  const dispatch = useReduxDispatch();<br/>  return (<br/>    ...<br/>  );<br/>};</span></pre><h1 id="0511" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">最后的想法</h1><p id="83a0" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">对于中型到大型的应用程序，单个事件可能会改变状态的几个部分，从而改变用户界面。因此，在这种情况下，使用Redux(或任何种类的应用程序状态管理)似乎是很自然的。</p><p id="12b4" class="pw-post-body-paragraph lm ln it lo b lp mt ju lr ls mu jx lu lv mv lx ly lz mw mb mc md mx mf mg mh im bi translated">然而，apollo-client和即将推出的react-cache将扮演数据管理的角色，UI状态管理的角色将变得更小。在这种情况下，多上下文模式可能对中等应用更有意义。</p></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><p id="8f85" class="pw-post-body-paragraph lm ln it lo b lp mt ju lr ls mu jx lu lv mv lx ly lz mw mb mc md mx mf mg mh im bi translated"><em class="ob">原载于2019年5月27日【https://blog.axlight.com】<a class="ae oc" href="https://blog.axlight.com/posts/four-patterns-for-global-state-with-react-hooks-context-or-redux/" rel="noopener ugc nofollow" target="_blank"><em class="ob"/></a><em class="ob">。</em></em></p></div></div>    
</body>
</html>