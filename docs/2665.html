<html>
<head>
<title>Functional Sentiment Analysis in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的功能情感分析</h1>
<blockquote>原文：<a href="https://itnext.io/functional-sentiment-analysis-in-javascript-754f58628746?source=collection_archive---------2-----------------------#2019-07-07">https://itnext.io/functional-sentiment-analysis-in-javascript-754f58628746?source=collection_archive---------2-----------------------#2019-07-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/48bdaf311e25516c6a24bfa1de021f31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rCZlyOBYpls-X5ISkSsk1g.png"/></div></div></figure><figure class="kb kc kd ke gt ju gh gi paragraph-image"><a href="https://www.jsmonday.dev/articles/21/functional-sentiment-analysis-in-javascript"><div class="gh gi jq"><img src="../Images/e6537356ea1f5f0a5ca99effd13b9bcf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ph4ke1672cns05b2S7PbMg.png"/></div></a></figure><p id="67e1" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">假设你有一个很受欢迎的博客，你想知道某个帖子上所有评论的情绪。<br/>我们可以很容易地用<strong class="kh iu"> Brain.js </strong>建立一个神经网络(我不久前写了一篇关于这个的文章<a class="ae ld" href="https://medium.com/openmindonline/emotion-detection-with-javascript-neural-networks-5a408f84eb75" rel="noopener"><strong class="kh iu">)，但是我们有一个更简单的情感分析的替代方法:AFINN </strong> </a>字典。</p><p id="6388" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu"> AFINN Dictionary </strong>是由<strong class="kh iu">Finn RUP Nielsen</strong>用一个介于<code class="fe le lf lg lh b">-5</code>和<code class="fe le lf lg lh b">5</code>之间的整数手动评估的英语术语列表(但是你可以很容易地找到其他语言的对应词)。<br/>当一个术语被评为高等级(例如，“<strong class="kh iu">杰出”</strong>被评为<code class="fe le lf lg lh b">5</code>)，这意味着它是非常积极的。相反，当一个术语被评为低等级时，意味着它非常负面。</p><p id="ce7b" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">所以如果给定的文本在情感分析后给出<code class="fe le lf lg lh b">5</code>、<code class="fe le lf lg lh b">10</code>、<code class="fe le lf lg lh b">2</code>的结果，就意味着具有积极的情绪。<br/>否则有负一。</p><h1 id="2a70" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">构建分析器</h1><p id="762e" class="pw-post-body-paragraph kf kg it kh b ki mg kk kl km mh ko kp kq mi ks kt ku mj kw kx ky mk la lb lc im bi translated">首先，我们需要AFINN字典。我做了一个JSON版本，可以在这里 访问<a class="ae ld" href="https://api.myjson.com/bins/1aoxir" rel="noopener ugc nofollow" target="_blank"> <strong class="kh iu">。<br/>如您所见，这是一个巨大的对象，其中每个键都是一个术语，其评级是一个值，让我们先睹为快:</strong></a></p><figure class="kb kc kd ke gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ml"><img src="../Images/ab24491216faf617345c3a900465bce4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uHkX0l-zZ3_we9Gzn1a4zw.png"/></div></div></figure><p id="5c6e" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">现在我们需要创建分析器本身。这个算法非常简单:我们只需要标记我们的输入文本，并将每个单词与其对应的AFINN值相关联。</p><p id="ba31" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">因此，首先，让我们创建一个函数来标记我们的文本:</p><figure class="kb kc kd ke gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ml"><img src="../Images/3fc85e01ba955bf1ba390a756f209f16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u2ZZrOTbjcKLE0TVLjiq8g.png"/></div></div></figure><p id="dcd2" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">额外提示:我是正则表达式的超级粉丝，但是我注意到使用正则表达式拆分一个大文本非常慢。出于这个原因，在上面的函数中，我使用了一个空白字符来分割它，这有点不太优雅，但是速度更快！(<a class="ae ld" href="http://jsben.ch/stCQ1" rel="noopener ugc nofollow" target="_blank"><strong class="kh iu"/></a>)</p><p id="1ade" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">接下来，我们需要删除每个非单词字符。例如，现在我们可能有一个如下所示的数组:</p><figure class="kb kc kd ke gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ml"><img src="../Images/3d7504b6e1a3b9121e3100a1ce609410.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LYYCLRICLb1hi3-_E1QgKQ.png"/></div></div></figure><p id="de79" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">但是你可以看到，<code class="fe le lf lg lh b">"happy!"</code>字符串包含一个感叹号，需要删除。否则，我们将无法在AFINN对象中找到单词“happy ”:</p><figure class="kb kc kd ke gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ml"><img src="../Images/a0a4ecb4d10f3c2c3baf42967555e7c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qC01evdN3K15wLVC0qQnaQ.png"/></div></div></figure><p id="2384" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我知道我们以前说过正则表达式很慢。但是这里出现了计算机科学中一个有趣的概念:<strong class="kh iu">干净代码</strong>。<br/>我们可以使用多个<code class="fe le lf lg lh b">replace</code>语句来编写上面的函数，但是作为一个解决方案会有多脏呢？<br/>与<code class="fe le lf lg lh b">tokenize</code>函数不同，为了获得可维护性、可读性和更干净的代码，我们自愿采用了一个性能较低的解决方案……这完全值得！</p><p id="9523" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如果你不熟悉RegEx，在我们的<code class="fe le lf lg lh b">word.replace</code>语句中，我们刚刚说过检测每个非单词字符并删除它。</p><p id="86bb" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">很好，现在我们需要使用AFINN字典为每个单词分配一个比率。另一个问题来了:我们应该使用循环、递归、高阶函数(<a class="ae ld" href="https://medium.com/openmindonline/jsmonday01-the-awesome-map-method-dfaae3233ae2" rel="noopener"> <strong class="kh iu">)吗？贴图方法</strong> </a>)？</p><p id="a51a" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">答案是:看情况。<br/>循环非常高效，但是难以阅读和维护。<br/>递归更容易阅读和维护，但是有一些已知的<a class="ae ld" href="https://medium.com/openmindonline/js-monday-06-adopting-memory-safe-recursion-d26dcee409c9" rel="noopener"> <strong class="kh iu">内存相关的</strong> </a>和<a class="ae ld" href="https://medium.com/openmindonline/improve-performances-using-memoization-b01963dd3624" rel="noopener"> <strong class="kh iu">性能</strong> </a>问题。</p><p id="28ad" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我个人倾向于使用<code class="fe le lf lg lh b">.map</code>方法，原因有二:</p><ol class=""><li id="f1d2" class="mm mn it kh b ki kj km kn kq mo ku mp ky mq lc mr ms mt mu bi translated">它有助于采用功能方法解决问题。</li><li id="27ff" class="mm mn it kh b ki mv km mw kq mx ku my ky mz lc mr ms mt mu bi translated">它是内存安全的。</li><li id="0256" class="mm mn it kh b ki mv km mw kq mx ku my ky mz lc mr ms mt mu bi translated">它使代码更容易阅读。</li></ol><p id="4b7e" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">同样，我们没有采用最快的解决方案是有原因的:编写更好的代码库。</p><figure class="kb kc kd ke gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ml"><img src="../Images/09f5d12928bf2a255d8e1d517c6564da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BQvm0N2bYoWlWOrWg_eL6w.png"/></div></div></figure><p id="53cf" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">嘿嘿嘿这是怎么回事？！我们只是声明了一个简单的<code class="fe le lf lg lh b">rateWord</code>函数，它检查给定的单词是否是AFINN字典的一部分。如果是这样的话，我们就从字典中取is rate，否则我们就把<code class="fe le lf lg lh b">0</code>赋值为rate。那么我们现在有什么？</p><figure class="kb kc kd ke gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ml"><img src="../Images/8275f3ae390cacf53a570f1bb77f226d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nHNrhy1J5M14Q295fFMLvg.png"/></div></div></figure><p id="0b22" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们现在能够利用<a class="ae ld" href="https://medium.com/openmindonline/js-monday-09-understanding-functors-43a426d34e26" rel="noopener"> <strong class="kh iu">函子</strong> </a>的优势，并连接多个<code class="fe le lf lg lh b">map</code>方法，以检索表示文本中每个单词的值数组:</p><figure class="kb kc kd ke gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ml"><img src="../Images/3421e79875c3d524d01107d654ab3955.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*27XiiUrIhyZubaKjIOl8Ug.png"/></div></div></figure><p id="cb20" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">所以现在我们有了一个很容易求和的整数数组…这个和就是我们的结果！</p><figure class="kb kc kd ke gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ml"><img src="../Images/0f62c24c081734cff05629a0d7ec0730.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6kEvkdVXsMrgI10CgIu9mA.png"/></div></div></figure><p id="a8e0" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这实际上是我们需要的最后一个函数。让我们使用<code class="fe le lf lg lh b"><a class="ae ld" href="https://medium.com/openmindonline/js-monday-08-reduce-eff9fac970b5" rel="noopener"><strong class="kh iu">reduce</strong></a></code>方法将所有东西放在一起:</p><figure class="kb kc kd ke gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ml"><img src="../Images/40baec6148f52b18139d01db283ed966.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qai29z9N7kVyjqiJjxn4Bg.png"/></div></div></figure><p id="bc0b" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">仅此而已！让我们做一些快速的情绪分析:</p><figure class="kb kc kd ke gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ml"><img src="../Images/5db6a5215cae28fe696f6001a618e6f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C69hMwqA3NJq3_WUTiR8EA.png"/></div></div></figure><p id="8c98" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">效果非常好！<br/>那么，在构建这个简单的情感分析器时，我们学到了什么？</p><p id="6659" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu">函数方法</strong>帮助我们编写更易维护和测试的代码。<br/>当你作为一名程序员工作时，你会花大部分时间阅读你现有的代码。浪费时间阅读糟糕的代码会降低你的工作效率，并且很容易让你在代码库中引入一些错误。<br/>我们今天写的每一个函数<strong class="kh iu">都是一个纯函数</strong>，可以很容易地用确定性的方式测试。<br/>代码流易于遵循和扩展，当我们需要对现有代码库进行一些更改或添加一些新功能时，这将使我们更加高效。</p><figure class="kb kc kd ke gt ju gh gi paragraph-image"><a href="https://www.patreon.com/micheleriva"><div class="gh gi jq"><img src="../Images/1d13568a8fcabc28ce13a025619f4395.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f9h_lzrNtzZes9EM6oiedA.png"/></div></a></figure></div></div>    
</body>
</html>