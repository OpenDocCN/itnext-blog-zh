<html>
<head>
<title>A Template for Creating a Full Stack Web Application with Flask, NPM, Webpack, and Reactjs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Flask、NPM、Webpack和Reactjs创建全栈Web应用程序的模板</h1>
<blockquote>原文：<a href="https://itnext.io/a-template-for-creating-a-full-stack-web-application-with-flask-npm-webpack-and-reactjs-be2294b111bd?source=collection_archive---------0-----------------------#2018-10-08">https://itnext.io/a-template-for-creating-a-full-stack-web-application-with-flask-npm-webpack-and-reactjs-be2294b111bd?source=collection_archive---------0-----------------------#2018-10-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/a618d174eb7351087d82873a51ec56e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iU6gXIYGrGN2LapwCrDGlw.jpeg"/></div></div></figure><p id="b969" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为什么有些人比其他人更成功？为什么有些人比大多数人赚更多的钱，过更快乐的生活，在同样的时间里完成更多的事情？真正的“成功秘诀”是什么？</p><p id="28e9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">除非你成为一个实干家而不是思想家，否则你会发现很难完成任何有意义的事情。创建全栈web应用程序的能力将使您能够自由地快速实现您的伟大想法，并让每个人都能看到，因为我们都知道我们的世界是由互联网驱动的。</p><p id="bb45" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">本文的目的是帮助你用Python Flask服务器和React前端</strong>启动自己的全栈web应用。这篇文章适合任何对编程和技术有基本了解的人，他们想探索一下<a class="ae kw" href="https://www.fullstackpython.com/flask.html" rel="noopener ugc nofollow" target="_blank"> python-flask </a>、<a class="ae kw" href="https://www.npmjs.com/" rel="noopener ugc nofollow" target="_blank"> npm </a>、<a class="ae kw" href="https://webpack.js.org/" rel="noopener ugc nofollow" target="_blank"> webpack </a>和<a class="ae kw" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank"> reactjs </a>构建全栈web应用程序的美妙之处。</p><p id="bfc8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个博客将会详细介绍这个GitHub链接<a class="ae kw" href="https://github.com/Eyongkevin/hello_template" rel="noopener ugc nofollow" target="_blank">中的实现。然而，如果你跟随这篇博文，你会收获更多。</a></p><h2 id="5de2" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">文件夹和文件组织</h2><p id="a296" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">我们将从组织项目的文件和文件夹开始。有效地组织静态文件，比如JavaScript、样式表、图像等等，一直是所有web框架关心的问题。Flask推荐了一种在我们的应用程序中组织静态文件的特定方法</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="032f" class="kx ky iq ma b gy me mf l mg mh">.<br/>├── hello_template<br/>    ├── configurations.py<br/>    ├── __init__.py<br/>    ├── README.md<br/>    ├── run.py<br/>    └── templates<br/>        ├── hello<br/>        │   ├── __init__.py<br/>        │   └── views.py<br/>        ├── __init__.py<br/>        ├── public<br/>        │   ├── css<br/>        │   ├── fonts<br/>        │   ├── images<br/>        │   └── js<br/>        └── static<br/>            ├── index.html<br/>            ├── __init__.py<br/>            ├── js<br/>               ├── components<br/>               ├── index.jsx<br/>               └── routes.js<br/>            </span></pre><p id="b0f8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们以模块化的方式安排了我们的应用程序。我们通过使用文件夹中的<code class="fe mi mj mk ma b">__init__.py</code>文件实现了这一点，这些文件将被用作模块。</p><h2 id="2162" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">烧瓶配置</h2><figure class="lv lw lx ly gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ml"><img src="../Images/c71deab87006a76da600dd5f27a2a9bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:876/format:webp/1*6m1XMrrK4GX8Ydlhwixy-w.png"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">烧瓶蟒</figcaption></figure><blockquote class="mq mr ms"><p id="4e8a" class="jy jz mt ka b kb kc kd ke kf kg kh ki mu kk kl km mv ko kp kq mw ks kt ku kv ij bi translated">Flask是一个基于Werkzeug、Jinja2和good intentions的Python微框架</p></blockquote><p id="f0d2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">为什么微？</strong>简单来说就是Flask旨在保持框架核心小但高度可扩展的事实。这使得编写应用程序或扩展非常容易和灵活，并使开发人员能够为他们的应用程序选择所需的配置，而不会对数据库、模板引擎等的选择施加任何限制。</p><p id="0238" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里我假设您已经设置了Python环境。如果没有，按照这个<a class="ae kw" href="https://realpython.com/installing-python/" rel="noopener ugc nofollow" target="_blank">链接</a>来安装python并做好准备。让我们通过运行下面的命令<code class="fe mi mj mk ma b">pip install Flask</code>继续安装Flask</p><p id="5de8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了确保一切正常，让我们创建一个快速简单的基于Flask的web应用程序。复制下面的代码并粘贴到<code class="fe mi mj mk ma b">hello_template/run.py</code>文件中并保存。</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="d41c" class="kx ky iq ma b gy me mf l mg mh">from flask import Flask<br/>app = Flask(__name__)<br/><a class="ae kw" href="http://twitter.com/app" rel="noopener ugc nofollow" target="_blank">@app</a>.route('/')<br/>def hello_world():<br/> return 'Hello to the World of Flask!'<br/>if __name__ == '__main__':<br/> app.run()</span></pre><blockquote class="mq mr ms"><p id="fa73" class="jy jz mt ka b kb kc kd ke kf kg kh ki mu kk kl km mv ko kp kq mw ks kt ku kv ij bi translated">在这段代码以及本文的任何其他代码中，确保在适当的地方缩进代码</p></blockquote><p id="6633" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在根目录<code class="fe mi mj mk ma b">hello_template/</code>中打开一个终端，执行下面的命令来运行应用程序:<br/> <code class="fe mi mj mk ma b">python run.py</code> <br/>如果一切正常，你会得到一个地址<code class="fe mi mj mk ma b"><a class="ae kw" href="http://127.0.0.1:5000/" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:5000/</a></code>，你可以在你最喜欢的浏览器中打开它，看到我们的应用程序正在运行。</p><figure class="lv lw lx ly gt jr gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/ee790c9efbfd3ee188dacb90dd24cc19.png" data-original-src="https://miro.medium.com/v2/resize:fit:612/format:webp/1*WmrN4kQ8hqH11D6TZJlmtw.png"/></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">我们在Chrome上运行的Flask应用程序</figcaption></figure><blockquote class="mq mr ms"><p id="1e1a" class="jy jz mt ka b kb kc kd ke kf kg kh ki mu kk kl km mv ko kp kq mw ks kt ku kv ij bi translated">要查看Flask依赖的所有包，你可以用命令<code class="fe mi mj mk ma b">pip install -U flask.</code>安装Flask，<code class="fe mi mj mk ma b">-U</code>指的是升级安装。同样，这会列出Flask依赖的所有包，恰好是<code class="fe mi mj mk ma b">flask, Werkzeug, Jinja2, itsdangerous</code>，和<code class="fe mi mj mk ma b">markupsafe</code>。如果缺少其中任何一个，烧瓶都不会工作</p></blockquote><p id="acec" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">基于类的设置:</strong>我们应该记住这只是一个模板，然而，随着项目变大，您可以有不同的部署模式，例如生产、测试、试运行等等，其中每个模式可以有几个不同的配置设置，而一些设置将保持不变。<br/>对于这个项目，我们将使用基于类的设置，其中我们将有一个默认的设置基类，其他类可以继承这个基类并覆盖或添加特定于部署的配置变量。</p><p id="0c7e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">打开<code class="fe mi mj mk ma b">hello_template/configurations.py</code>文件，粘贴以下代码。</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="0ee5" class="kx ky iq ma b gy me mf l mg mh">class BaseConfig(object):<br/> '''<br/> Base config class<br/> '''<br/> DEBUG = True<br/> TESTING = False</span><span id="772c" class="kx ky iq ma b gy my mf l mg mh">class ProductionConfig(BaseConfig):<br/> """<br/> Production specific config<br/> """<br/> DEBUG = False</span><span id="b8a6" class="kx ky iq ma b gy my mf l mg mh">class DevelopmentConfig(BaseConfig):<br/> """<br/> Development environment specific configuration<br/> """<br/> DEBUG = True<br/> TESTING = True</span></pre><p id="d989" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，在通过<code class="fe mi mj mk ma b">hello_template/run.py</code>中的<code class="fe mi mj mk ma b">from_object()</code>加载应用程序的配置时，我们可以使用前面的任何类，如下所示:</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="6e01" class="kx ky iq ma b gy me mf l mg mh">from templates import app<br/><strong class="ma ir">#Load this config object for development mode<br/>app.config.from_object('configurations.DevelopmentConfig')</strong><br/>app.run()</span></pre><blockquote class="mq mr ms"><p id="b904" class="jy jz mt ka b kb kc kd ke kf kg kh ki mu kk kl km mv ko kp kq mw ks kt ku kv ij bi translated">启用调试模式将使服务器在任何代码更改的情况下重新加载自己，并且它还在出错时提供了非常有用的Werkzeug调试器。</p><p id="4ee1" class="jy jz mt ka b kb kc kd ke kf kg kh ki mu kk kl km mv ko kp kq mw ks kt ku kv ij bi translated">另外，注意这里我们从模板中导入了<code class="fe mi mj mk ma b">app</code>。我们将在<code class="fe mi mj mk ma b">hello_template/templates/</code>文件夹的<code class="fe mi mj mk ma b">__init__.py</code>文件中定义我们的<code class="fe mi mj mk ma b">app object</code>。这里的导入是可能的，因为我们已经以模块化的方式安排了我们的应用程序</p></blockquote><p id="b44d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">加载静态文件:</strong>如果在应用的根级存在一个名为<code class="fe mi mj mk ma b">static</code>的文件夹，也就是和<code class="fe mi mj mk ma b">run.py</code>在同一个级别，那么Flask会自动读取该文件夹的内容，不需要任何额外的配置。或者，在<code class="fe mi mj mk ma b">hello_template/templates/__init__.py</code>文件中定义应用程序时，我们可以向应用程序对象提供一个名为<code class="fe mi mj mk ma b">static_folder </code>的参数</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="5001" class="kx ky iq ma b gy me mf l mg mh">from flask import Flask</span><span id="7b2d" class="kx ky iq ma b gy my mf l mg mh">app = Flask(__name__,<br/> static_folder = './public',<br/> template_folder="./static")</span><span id="4f29" class="kx ky iq ma b gy my mf l mg mh">import templates.hello.views</span></pre><p id="58ce" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，我们将有一个空的<code class="fe mi mj mk ma b">hello_template/templates/hello/__init__.py</code>文件，仅仅是为了使包含的文件夹成为Python包。最后，<code class="fe mi mj mk ma b">hello_template/templates/hello/views.py</code>将是:</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="296d" class="kx ky iq ma b gy me mf l mg mh">from templates import app<br/>from flask import render_template</span><span id="1523" class="kx ky iq ma b gy my mf l mg mh"><a class="ae kw" href="http://twitter.com/app" rel="noopener ugc nofollow" target="_blank">@app</a>.route('/')<br/><a class="ae kw" href="http://twitter.com/app" rel="noopener ugc nofollow" target="_blank">@app</a>.route('/hello')<br/>def index():<br/> return render_template("index.html")</span></pre><blockquote class="mq mr ms"><p id="e470" class="jy jz mt ka b kb kc kd ke kf kg kh ki mu kk kl km mv ko kp kq mw ks kt ku kv ij bi translated">我们可以识别出<code class="fe mi mj mk ma b">hello_template/templates/__init__.py</code>和<code class="fe mi mj mk ma b">hello_template/templates/hello/views.py</code>之间的循环导入，在前者中，我们从后者导入视图，在后者中，我们从前者导入应用程序。所以，这实际上使得两个模块相互依赖。</p></blockquote><p id="3d9e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们的hello文件夹中，我们使用视图来呈现一个HTML文件，每当它看到url <code class="fe mi mj mk ma b">/</code>和<code class="fe mi mj mk ma b">/hello</code>的末尾时就会显示这个文件。因此，正常的执行过程将是:</p><ul class=""><li id="68e3" class="mz na iq ka b kb kc kf kg kj nb kn nc kr nd kv ne nf ng nh bi translated">从<code class="fe mi mj mk ma b"><em class="mt">hello_template/</em>run.py</code>启动应用程序</li><li id="0e7e" class="mz na iq ka b kb ni kf nj kj nk kn nl kr nm kv ne nf ng nh bi translated"><code class="fe mi mj mk ma b">hello_template/run.py</code>从<code class="fe mi mj mk ma b"><em class="mt">hello_template/templates/__init__.py</em></code>导入app</li><li id="4739" class="mz na iq ka b kb ni kf nj kj nk kn nl kr nm kv ne nf ng nh bi translated"><code class="fe mi mj mk ma b">hello_template/templates/__init__.py</code>初始化应用程序并导入所有视图</li><li id="e36d" class="mz na iq ka b kb ni kf nj kj nk kn nl kr nm kv ne nf ng nh bi translated"><code class="fe mi mj mk ma b">hello_template/templates/hello/views.py</code>监听url <code class="fe mi mj mk ma b">/</code>和<code class="fe mi mj mk ma b">/hello</code>并呈现一个html文件。</li></ul><p id="ddea" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们使用<code class="fe mi mj mk ma b">render_template(“index.html”)</code>来呈现HTML文件，而不是从Python中生成HTML，这一点都不好玩，而且实际上相当麻烦，因为你必须自己进行HTML转义来保证应用程序的安全。我们会注意到，我们已经用<code class="fe mi mj mk ma b">template_folder=”./static”,</code>配置了我们的应用程序，因此静态文件夹将包含我们的HTML模板文件，无需再次指定路径即可直接加载。你可以从<a class="ae kw" href="http://flask.pocoo.org/docs/1.0/quickstart/#rendering-templates" rel="noopener ugc nofollow" target="_blank">这里</a>阅读更多内容</p><blockquote class="mq mr ms"><p id="e00c" class="jy jz mt ka b kb kc kd ke kf kg kh ki mu kk kl km mv ko kp kq mw ks kt ku kv ij bi translated"><code class="fe mi mj mk ma b">hello_template/templates/hello/views.py</code>是反应特异。我们将在后面介绍如何安装React</p></blockquote><p id="003d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">使用蓝图使我们的web应用模块化:</strong>蓝图是Flask中的一个概念，它有助于使更大的应用真正模块化。它实际上是一组可以在应用程序上注册的操作，并表示如何构造或构建应用程序。我们将修改视图以使用蓝图工作。</p><p id="911b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，我们的<code class="fe mi mj mk ma b">hello_template/templates/__init__.py </code>将修改为</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="b80c" class="kx ky iq ma b gy me mf l mg mh">from flask import Flask</span><span id="9770" class="kx ky iq ma b gy my mf l mg mh">app = Flask(__name__,<br/> static_folder = './public',<br/> template_folder="./static")</span><span id="0634" class="kx ky iq ma b gy my mf l mg mh"><strong class="ma ir">from templates.hello.views import hello_blueprint</strong></span><span id="c08d" class="kx ky iq ma b gy my mf l mg mh"><strong class="ma ir"># register the blueprints<br/>app.register_blueprint(hello_blueprint)</strong></span></pre><p id="db36" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，将<code class="fe mi mj mk ma b"><em class="mt">hello_template/templates/hello/views.py</em></code> <em class="mt"> </em>修改为</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="5a7b" class="kx ky iq ma b gy me mf l mg mh"><strong class="ma ir">from flask import render_template, Blueprint</strong></span><span id="9f57" class="kx ky iq ma b gy my mf l mg mh"><strong class="ma ir">hello_blueprint = Blueprint('hello',__name__)</strong></span><span id="b21b" class="kx ky iq ma b gy my mf l mg mh"><a class="ae kw" href="http://twitter.com/portfolio_blueprint" rel="noopener ugc nofollow" target="_blank"><strong class="ma ir">@hello_blueprint</strong></a><strong class="ma ir">.route('/')<br/></strong><a class="ae kw" href="http://twitter.com/portfolio_blueprint" rel="noopener ugc nofollow" target="_blank"><strong class="ma ir">@hello_blueprint</strong></a><strong class="ma ir">.route('/hello')</strong><br/>def index():<br/> return render_template("index.html")</span></pre><blockquote class="mq mr ms"><p id="c7f3" class="jy jz mt ka b kb kc kd ke kf kg kh ki mu kk kl km mv ko kp kq mw ks kt ku kv ij bi translated">我们已经在视图文件中定义了一个蓝图，这里不再需要app对象，我们的完整路由是在名为<code class="fe mi mj mk ma b">hello_blueprint</code>的蓝图上定义的。所以我们没有用<code class="fe mi mj mk ma b"><a class="ae kw" href="http://twitter.com/app" rel="noopener ugc nofollow" target="_blank">@app</a>.route</code>，而是用了<code class="fe mi mj mk ma b"><a class="ae kw" href="http://twitter.com/hello_blueprint" rel="noopener ugc nofollow" target="_blank">@hello_blueprint</a>.route</code>。相同的蓝图被导入<code class="fe mi mj mk ma b">hello_template/templates/__init__.py</code>并在应用对象上注册。根据经验，每个视图都应该有自己的蓝图。</p></blockquote><h2 id="42de" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">安装和配置Webpack</h2><figure class="lv lw lx ly gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nn"><img src="../Images/fc243bc932963850bbcfe26f67506d59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2k0wlJ8mz_siwrNQbvHADw.png"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">webpack如何工作的图示来自其官方网站<a class="ae kw" href="https://webpack.js.org/" rel="noopener ugc nofollow" target="_blank"/></figcaption></figure><p id="e3b0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kw" href="https://webpack.js.org/" rel="noopener ugc nofollow" target="_blank"> webpack </a>是一个模块捆绑器，将用于<a class="ae kw" href="https://reactjs.org/docs/introducing-jsx.html" rel="noopener ugc nofollow" target="_blank"> JSX </a>转换和模块/依赖捆绑。模块的使用通过将JavaScript代码分成多个文件来帮助组织代码，每个文件声明自己的依赖项。然后，模块捆绑器会自动按照正确的加载顺序将所有内容打包在一起。</p><p id="cc85" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">处理这个中间步骤的很多工具，包括<a class="ae kw" href="https://gruntjs.com/" rel="noopener ugc nofollow" target="_blank">咕噜</a>、<a class="ae kw" href="https://gulpjs.com/" rel="noopener ugc nofollow" target="_blank">大口</a>和<a class="ae kw" href="https://brunch.io/" rel="noopener ugc nofollow" target="_blank">早午餐</a>等等。但是总的来说，React社区已经将webpack作为这项工作的首选工具。</p><p id="e8bb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">安装Webpack </strong>:可以通过<code class="fe mi mj mk ma b">npm</code>安装Webpack。使用<code class="fe mi mj mk ma b">npm install -g webpack</code>进行全局安装，或者使用<code class="fe mi mj mk ma b">npm install — save-dev webpack.</code>将其作为依赖项添加到您的项目中</p><p id="c6e4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这个项目中，我们将添加webpack作为依赖项。所以我们首先创建一个<code class="fe mi mj mk ma b">hello_template/templates/static/package.json</code>文件。要创建这个文件，您可以在<code class="fe mi mj mk ma b">hello_template/templates/static/</code>文件夹中打开一个终端并运行命令<code class="fe mi mj mk ma b">npm init</code></p><blockquote class="mq mr ms"><p id="368b" class="jy jz mt ka b kb kc kd ke kf kg kh ki mu kk kl km mv ko kp kq mw ks kt ku kv ij bi translated"><code class="fe mi mj mk ma b">package.json</code>文件是一个标准的npm清单，它保存了关于项目的各种信息，让开发人员指定依赖项(可以自动下载和安装)并定义脚本任务。</p></blockquote><p id="c640" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mi mj mk ma b">init</code>命令会问你一系列关于你的项目的问题(比如项目名称、描述、作者信息等等)。).</p><p id="e9e3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">准备好package.json文件后，安装<strong class="ka ir"> webpack </strong>和<strong class="ka ir"> webpack cli </strong>,其中包含</p><p id="16b5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mi mj mk ma b">npm install --save-dev webpack &amp;&amp; npm install -D webpack-cli</code></p><blockquote class="mq mr ms"><p id="d496" class="jy jz mt ka b kb kc kd ke kf kg kh ki mu kk kl km mv ko kp kq mw ks kt ku kv ij bi translated"><strong class="ka ir">注意</strong>:我们要用<code class="fe mi mj mk ma b">npm</code>做的每一个安装都应该在<code class="fe mi mj mk ma b">package.json</code>所在的<code class="fe mi mj mk ma b">hello_template/templates/static/</code>目录下打开的终端上。</p></blockquote><p id="ecad" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">定义配置文件</strong>:web pack的基本命令行语法是“<code class="fe mi mj mk ma b">webpack {entry file} {destination for bundled file}</code>”。Webpack要求您只指向一个条目文件——它会自动找出项目的所有依赖项。此外，如果您没有像我们这样全局安装webpack，您将需要引用项目的<code class="fe mi mj mk ma b">node_modules</code>文件夹中的webpack命令。该命令将如下所示:<br/> <code class="fe mi mj mk ma b">node_modules/.bin/webpack js/index.jsx public/bundle.js</code></p><p id="723e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，webpack有许多不同的高级选项，并允许使用加载器和插件对加载的模块进行转换。尽管可以像上面一样在命令行中使用webpack的所有选项，但是这个过程会变得很慢并且容易出错。更好的方法是定义一个配置文件——一个简单的JavaScript模块，您可以在其中放置与您的构建相关的所有信息。</p><p id="b254" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">创建一个文件<code class="fe mi mj mk ma b"><em class="mt">hello_template/templates/static/</em>webpack.config.js</code>。它必须引用入口文件和捆绑文件的目标，如下所示:</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="9e2e" class="kx ky iq ma b gy me mf l mg mh">const webpack = require('webpack');<br/>const resolve = require('path').resolve;</span><span id="2217" class="kx ky iq ma b gy my mf l mg mh">const config = {<br/> entry: __dirname + '/js/index.jsx',<br/> output:{<br/>      path: resolve('../public'),<br/>      filename: 'bundle.js',<br/>      publicPath: resolve('../public')</span><span id="a791" class="kx ky iq ma b gy my mf l mg mh">},<br/> resolve: {<br/>  extensions: ['.js','.jsx','.css']<br/> },<br/>};</span><span id="c7c0" class="kx ky iq ma b gy my mf l mg mh">module.exports = config;</span></pre><blockquote class="mq mr ms"><p id="a31b" class="jy jz mt ka b kb kc kd ke kf kg kh ki mu kk kl km mv ko kp kq mw ks kt ku kv ij bi translated"><code class="fe mi mj mk ma b">__dirname </code>是一个node.js全局变量，包含当前正在执行的脚本所在的目录名。</p><p id="9932" class="jy jz mt ka b kb kc kd ke kf kg kh ki mu kk kl km mv ko kp kq mw ks kt ku kv ij bi translated">由webpack创建的<code class="fe mi mj mk ma b">bundle.js</code>文件将存储在公共文件夹中，如上面的<code class="fe mi mj mk ma b">path: resolve('../public')</code>所示。</p></blockquote><p id="c30e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">添加运行命令</strong>:为了让开发过程更加流畅，我们将在package.json文件中添加一些运行命令<em class="mt"> (build、dev-build、</em>和<em class="mt"> watch </em>)。</p><p id="651c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="mt">构建</em>用于生产构建，<em class="mt">开发构建</em>用于非精简构建。<em class="mt"> Watch </em>类似于<em class="mt"> dev-build </em>，额外的好处是它可以监控你的项目文件。任何更改的文件都将自动重建，刷新浏览器将显示您刚才所做的更改。</p><p id="2f7c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是package.json</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="4ece" class="kx ky iq ma b gy me mf l mg mh">{<br/>  "name": "hello_template",<br/>  "version": "1.0.0",<br/>  "description": "A template for creating a full stack wep app with Flask, NPM, Webpack, and Reactjs",<br/>  "main": "index.js",<br/>  "scripts": {<br/>    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1",<br/><strong class="ma ir">    "build": "webpack -p --progress --config webpack.config.js",<br/>    "dev-build": "webpack --progress -d --config webpack.config.js",<br/>    "watch": "webpack --progress -d --config webpack.config.js --watch"</strong><br/>  },<br/>  "repository": {<br/>    "type": "git",<br/>    "url": "git+<a class="ae kw" href="https://github.com/Eyongkevin/my-portfolio.git" rel="noopener ugc nofollow" target="_blank">https://github.com/Eyongkevin/my-portfolio.git</a>"<br/>  },<br/>  "keywords": [<br/>    "portfolio",<br/>    "template",<br/>    "python",<br/>    "react",<br/>    "npm",<br/>    "webpack"<br/>  ],<br/>  "author": "Eyong Kevin",<br/>  "license": "ISC",<br/>  "bugs": {<br/>    "url": "<a class="ae kw" href="https://github.com/Eyongkevin/my-portfolio/issues" rel="noopener ugc nofollow" target="_blank">https://github.com/Eyongkevin/my-portfolio/issues</a>"<br/>  },<br/>  "homepage": "<a class="ae kw" href="https://github.com/Eyongkevin/my-portfolio#readme" rel="noopener ugc nofollow" target="_blank">https://github.com/Eyongkevin/my-portfolio#readme</a>",<br/>  "devDependencies": {<br/>    "webpack": "^4.19.1",<br/>    "webpack-cli": "^3.1.0"<br/>  },<br/>}</span></pre><blockquote class="mq mr ms"><p id="b4cd" class="jy jz mt ka b kb kc kd ke kf kg kh ki mu kk kl km mv ko kp kq mw ks kt ku kv ij bi translated">您的<code class="fe mi mj mk ma b">package.json</code>可能与我的不同，因为您可能在使用<code class="fe mi mj mk ma b">npm init</code>创建此文件时提供了答案</p><p id="9081" class="jy jz mt ka b kb kc kd ke kf kg kh ki mu kk kl km mv ko kp kq mw ks kt ku kv ij bi translated">你可能会注意到我的个人信息的一些变量，如<code class="fe mi mj mk ma b">url</code>、<code class="fe mi mj mk ma b">author</code>和<code class="fe mi mj mk ma b">homepage</code>。您可能希望将其更改为您自己的个人信息。</p></blockquote><p id="bf09" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">生成源地图</strong>:web pack最重要和最常用的配置之一是<a class="ae kw" href="https://blog.teamtreehouse.com/introduction-source-maps" rel="noopener ugc nofollow" target="_blank">源地图</a>。虽然将项目的所有JavaScript模块打包到一个(或几个)捆绑文件中以便在浏览器上使用有很多优点，但一个明显的缺点是，在浏览器中调试时，您将无法引用原始文件中的原始代码。准确定位您试图调试的代码映射到您最初创作的代码的位置变得非常困难。这就是源映射的用武之地——源映射提供了一种将捆绑文件中的代码映射回其原始源文件的方法，使得代码在浏览器中可读且更易于调试。</p><p id="fcac" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了配置Webpack来生成指向原始文件的源映射，我们使用了<code class="fe mi mj mk ma b"> devtool</code>设置。它有许多选项，但对于这个项目，我们将使用'【T1]'作为它生成一个完整的源地图。虽然它有一些缺点，但我们将只在开发模式中使用它。</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="8d4c" class="kx ky iq ma b gy me mf l mg mh">const webpack = require('webpack');<br/>const resolve = require('path').resolve;</span><span id="25c6" class="kx ky iq ma b gy my mf l mg mh">const config = {<br/> <strong class="ma ir">devtool: 'eval-source-map',</strong><br/> entry: __dirname + '/js/index.jsx',<br/> output:{<br/>      path: resolve('../public'),<br/>      filename: 'bundle.js',<br/>      publicPath: resolve('../public')</span><span id="161e" class="kx ky iq ma b gy my mf l mg mh">},<br/> resolve: {<br/>  extensions: ['.js','.jsx','.css']<br/> },<br/>};</span><span id="ec84" class="kx ky iq ma b gy my mf l mg mh">module.exports = config;</span></pre><blockquote class="mq mr ms"><p id="7793" class="jy jz mt ka b kb kc kd ke kf kg kh ki mu kk kl km mv ko kp kq mw ks kt ku kv ij bi translated">devtool甚至有更快的选项。虽然速度更快，但这些<br/>选项不会将捆绑代码直接映射到原始的源文件<br/>，并且更适合构建时间<br/>受到关注的大型项目。您可以在<br/> webpack的<a class="ae kw" href="https://webpack.js.org/configuration/devtool/" rel="noopener ugc nofollow" target="_blank">文档</a>中了解更多可用选项</p></blockquote><p id="8565" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">加载器</strong>:web pack最激动人心的特性之一就是加载器。通过使用加载器，webpack可以在加载源文件时通过外部脚本和工具对其进行预处理，以应用各种更改和转换。这种转换在很多情况下都很有用，例如将JSON文件解析成普通的JavaScript，或者将下一代的JavaScript代码转换成当前浏览器可以理解的普通JavaScript。可以在<code class="fe mi mj mk ma b">webpack.config.js</code>中的<code class="fe mi mj mk ma b">modules</code>键下配置装载机。</p><p id="2271" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">装载机配置设置包括:</p><ul class=""><li id="05d2" class="mz na iq ka b kb kc kf kg kj nb kn nc kr nd kv ne nf ng nh bi translated"><strong class="ka ir"> test </strong>:一个正则表达式，匹配应该通过这个加载器运行的文件扩展名(必需)。</li><li id="084e" class="mz na iq ka b kb ni kf nj kj nk kn nl kr nm kv ne nf ng nh bi translated"><strong class="ka ir">加载器</strong>:加载器名称(必填)。</li><li id="cce5" class="mz na iq ka b kb ni kf nj kj nk kn nl kr nm kv ne nf ng nh bi translated"><strong class="ka ir">包含/排除</strong>:手动设置加载器应该显式添加或忽略哪些文件夹和文件的可选设置。</li><li id="7b41" class="mz na iq ka b kb ni kf nj kj nk kn nl kr nm kv ne nf ng nh bi translated"><strong class="ka ir">查询</strong>:查询设置可用于将附加选项传递给加载器。</li></ul><p id="aef4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这个项目中，我们将使用babel作为我们的加载器，将React的JSX转换为普通的JavaScript，如下所示:</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="20ca" class="kx ky iq ma b gy me mf l mg mh">const webpack = require('webpack');</span><span id="ccee" class="kx ky iq ma b gy my mf l mg mh">const config = {<br/>        devtool: 'eval-source-map',<br/> entry: __dirname + '/js/index.jsx',<br/> output:{<br/>  path: __dirname + '/dist',<br/>  filename: 'bundle.js',</span><span id="c7ae" class="kx ky iq ma b gy my mf l mg mh">},<br/> resolve: {<br/>  extensions: ['.js','.jsx','.css']<br/> },<br/><strong class="ma ir"> module: {<br/>  rules: [<br/>  {<br/>   test: /\.jsx?/,<br/>   loader: 'babel-loader',<br/>   exclude: /node_modules/,<br/>  }]<br/> }</strong><br/>};</span><span id="69aa" class="kx ky iq ma b gy my mf l mg mh">module.exports = config;</span></pre><blockquote class="mq mr ms"><p id="df3f" class="jy jz mt ka b kb kc kd ke kf kg kh ki mu kk kl km mv ko kp kq mw ks kt ku kv ij bi translated">上面代码中使用的加载程序是“<code class="fe mi mj mk ma b">Babel</code>”。下面继续看如何安装和配置babel。</p><p id="61d7" class="jy jz mt ka b kb kc kd ke kf kg kh ki mu kk kl km mv ko kp kq mw ks kt ku kv ij bi translated">我们在这里排除了<code class="fe mi mj mk ma b">node_modules</code>,因为我们不希望babel转换任何节点模块，从而加快加载速度。</p></blockquote><h2 id="570a" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">添加巴别塔支持</h2><figure class="lv lw lx ly gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi no"><img src="../Images/d40d38f57fb6a8b5429532d47b0c1764.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dsl1xwvGdfdt8iBc_Z-j3g.png"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">Babel如何将下一代Javascript转换为浏览器兼容的Javascript的代码示例，如<a class="ae kw" href="https://babeljs.io/" rel="noopener ugc nofollow" target="_blank"> Babel网站</a>所示</figcaption></figure><p id="114f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kw" href="https://babeljs.io/" rel="noopener ugc nofollow" target="_blank"> Babel </a>是一个JavaScript编译和工具平台。它让你；</p><ul class=""><li id="10ac" class="mz na iq ka b kb kc kf kg kj nb kn nc kr nd kv ne nf ng nh bi translated">使用下一版本的JavaScript (ES6、ES2015、ES2016等)，尚不完全受所有浏览器支持</li><li id="b231" class="mz na iq ka b kb ni kf nj kj nk kn nl kr nm kv ne nf ng nh bi translated">使用JavaScript语法扩展，比如React的JSX</li></ul><p id="3fc8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">虽然babel是一个独立的工具，我们将在这个项目中使用它作为一个加载器，因为它与Webpack配合得非常好。</p><p id="db7b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">巴别塔分布在不同的npm模块中。核心功能在“<code class="fe mi mj mk ma b">babel-core</code>”NPM包中可用，与webpack的集成通过“<code class="fe mi mj mk ma b">babel-loader</code>”NPM包可用，对于我们希望代码可用的每种类型的功能和扩展，我们将需要安装一个单独的包(最常见的是<code class="fe mi mj mk ma b">babel-preset-es2015</code>和<code class="fe mi mj mk ma b">babel-preset-react</code>，分别用于编译ES6和React的JSX)。</p><p id="aff3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">打开一个终端目录下的<code class="fe mi mj mk ma b"><em class="mt">hello_template/templates/static/</em></code> <em class="mt">和I</em>install babel和这个项目需要的所有特性作为开发依赖，命令:<br/> <code class="fe mi mj mk ma b">npm install --save-dev babel-core babel-loader babel-preset-es2015 babel-preset-react</code></p><p id="8d87" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们已经安装了babel，我们可以通过在<code class="fe mi mj mk ma b"> webpack.config.js</code>文件中添加预置来使我们的项目使用ES6模块和语法，以及JSX。</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="7012" class="kx ky iq ma b gy me mf l mg mh">const webpack = require('webpack');</span><span id="b532" class="kx ky iq ma b gy my mf l mg mh">const config = {<br/>        devtool: 'eval-source-map',<br/> entry: __dirname + '/js/index.jsx',<br/> output:{<br/>  path: __dirname + '/dist',<br/>  filename: 'bundle.js',</span><span id="23fa" class="kx ky iq ma b gy my mf l mg mh">},<br/> resolve: {<br/>  extensions: ['.js','.jsx','.css']<br/> },<br/> module: {<br/>  rules: [<br/>  {<br/>   test: /\.jsx?/,<br/>   loader: 'babel-loader',<br/>   exclude: /node_modules/,<br/><strong class="ma ir">   query:{<br/>     presets: ['react','es2015']<br/>   }<br/></strong>  }]<br/> }<br/>};</span><span id="8c2c" class="kx ky iq ma b gy my mf l mg mh">module.exports = config;</span></pre><p id="36a7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，许多开发人员选择创建一个单独的babel资源配置——即一个<code class="fe mi mj mk ma b">.babelrc</code>文件(带有一个前导点)。到目前为止，我们仅有的特定于巴别塔的配置是presents定义——这可能无法证明创建特定于巴别塔的配置文件是正确的。但是由于额外的webpack和babel特性会随着时间的推移而增加，我们最好使用babel配置文件。</p><p id="fd9f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<code class="fe mi mj mk ma b"><em class="mt">hello_template/templates/static/</em></code>目录中创建一个<code class="fe mi mj mk ma b">.babelrc</code>文件:<br/>在Linux中，您可以使用<code class="fe mi mj mk ma b">gedit .babelrc</code> <br/>这将创建一个未保存的文件，您可以在其中填入下面的代码并保存</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="c995" class="kx ky iq ma b gy me mf l mg mh">{<br/> “presets”: [“react”, “es2015”]</span><span id="a52f" class="kx ky iq ma b gy my mf l mg mh">}</span></pre><blockquote class="mq mr ms"><p id="0120" class="jy jz mt ka b kb kc kd ke kf kg kh ki mu kk kl km mv ko kp kq mw ks kt ku kv ij bi translated">Babel将在正在传输的文件的当前目录中寻找一个<code class="fe mi mj mk ma b"> .babelrc</code>。如果不存在，它将沿着目录树向上移动，直到找到一个<code class="fe mi mj mk ma b">.babelrc,</code>或一个带有<code class="fe mi mj mk ma b">“babel”: {}</code>散列的<code class="fe mi mj mk ma b">package.json</code>。你可以从<a class="ae kw" href="https://babeljs.io/docs/en/config-files#file-relative-configuration" rel="noopener ugc nofollow" target="_blank">官网</a>了解更多</p></blockquote><h2 id="c263" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">添加反应堆</h2><figure class="lv lw lx ly gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi np"><img src="../Images/8933e4fa3854e49902a096a7f2866351.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y6C4nSvy2Woe0m7bWEn4BA.png"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">Reactjs徽标</figcaption></figure><p id="307a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">React是脸书创建的一个开源项目。它提供了一种用JavaScript构建用户界面的新方法。</p><p id="a1e1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在有很多JavaScript MVC框架。那么，为什么脸书build React，为什么我们要在这个项目中使用它呢？</p><ul class=""><li id="a66e" class="mz na iq ka b kb kc kf kg kj nb kn nc kr nd kv ne nf ng nh bi translated"><strong class="ka ir">反应式渲染很简单</strong>:大多数JavaScript框架使用数据绑定来保持界面与状态同步，这在可维护性、可伸缩性和性能方面都有缺点。React允许您以声明的方式编写组件的外观和行为。而当数据发生变化时，React在概念上再次渲染整个界面。从概念上来说，它使用内存中的轻量级DOM表示，称为“<code class="fe mi mj mk ma b">virtual DOM</code>”。</li><li id="2111" class="mz na iq ka b kb ni kf nj kj nk kn nl kr nm kv ne nf ng nh bi translated"><strong class="ka ir">使用纯JavaScript的面向组件开发:</strong>在React应用中，一切都是由组件构成的，组件是自包含的、关注点特定的构建块。它允许一种“分而治之”的方法，其中没有特定的部分需要特别复杂。因此，很容易用更小的组件创建复杂的、功能更丰富的组件。这些组件是用普通的JavaScript编写的，而不是模板语言，这给了你一个全功能的编程语言来呈现视图，因为模板语言可能是有限的</li></ul><p id="0e2f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">安装Node.js </strong>:要继续操作，您需要安装Node.js。JavaScript天生就是在浏览器上运行的，但是Node.js使得在本地计算机和服务器上运行JavaScript程序成为可能。如果你还没有安装Node.js，现在可以在这里下载Windows、Mac或Linux的安装程序来安装。</p><p id="3e3f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">安装React:在</strong> <code class="fe mi mj mk ma b">hello_template/templates/static/</code>打开一个终端，运行命令</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="f84e" class="kx ky iq ma b gy me mf l mg mh">$ npm i react react-dom --save-dev</span></pre><p id="c810" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">创造。js和。jsx文件</strong>:我们记得我们的<code class="fe mi mj mk ma b">hello_template/templates/__init__.py</code>文件从<code class="fe mi mj mk ma b">hello_template/templates/hello/</code>文件夹中导入了我们的视图。hello文件夹中的<code class="fe mi mj mk ma b"> view.py</code>文件将监听一个url并呈现一个模板文件<code class="fe mi mj mk ma b">‘index.html</code>，该文件位于<code class="fe mi mj mk ma b">hello_template/templates/static/</code>目录中。这个HTML文件几乎是空的，它只是加载捆绑的javaScript并提供一个Div来呈现react组件。</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="bc87" class="kx ky iq ma b gy me mf l mg mh">&lt;!— index.html —&gt;<br/>&lt;html&gt;<br/>  &lt;head&gt;<br/>    &lt;meta charset="utf-8"&gt;<br/>    &lt;!-- Latest compiled and minified bootstrap CSS --&gt;<br/>    &lt;link rel="stylesheet" href="<a class="ae kw" href="https://maxcdn.bootstrapcdn.com/bootstrap/latest/css/bootstrap.min.css" rel="noopener ugc nofollow" target="_blank">https://maxcdn.bootstrapcdn.com/bootstrap/latest/css/bootstrap.min.css</a>"&gt;<br/>    &lt;title&gt;Creating a Full-Stack Python Application with Flask, NPM, React.js and Webpack&lt;/title&gt;<br/>  &lt;/head&gt;<br/>  &lt;body&gt;<br/>    &lt;div id="content" /&gt;<br/>    &lt;script src="public/bundle.js" type="text/javascript"&gt;&lt;/script&gt;<br/>  &lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="24df" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个HTML文件的位置在<code class="fe mi mj mk ma b">hello_template/templates/__init__.py</code>中用变量<code class="fe mi mj mk ma b">template_folder='./static</code>指定</p><blockquote class="mq mr ms"><p id="2db9" class="jy jz mt ka b kb kc kd ke kf kg kh ki mu kk kl km mv ko kp kq mw ks kt ku kv ij bi translated">这里的<code class="fe mi mj mk ma b"> bundle.js</code>文件是webpack的单个JavaScript文件，包含所有按正确顺序打包的模块。其位置在<code class="fe mi mj mk ma b">hello_template/templates/__init__.py </code>中被指定为<code class="fe mi mj mk ma b">static_folder=’./public’</code></p></blockquote><p id="bd7f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们将用一个简单的React应用程序填充文件<code class="fe mi mj mk ma b"><em class="mt">hello_template/templates/static/js/</em>index.jsx</code>，并让它将路由器文件<code class="fe mi mj mk ma b"><em class="mt">hello_template/templates/static/js/</em>routes.js</code>中的适当组件加载到我们的<code class="fe mi mj mk ma b">index.html</code>文件中</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="cc18" class="kx ky iq ma b gy me mf l mg mh">import React from 'react';<br/>import ReactDOM from 'react-dom';<br/>import routes from "./routes";</span><span id="10b4" class="kx ky iq ma b gy my mf l mg mh">ReactDOM.render(routes, document.getElementById("content"));</span></pre><p id="2b72" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的<code class="fe mi mj mk ma b">hello<em class="mt">_template/templates/static/js/</em>routes.js </code>文件将完成调用适当组件的工作，并因此显示我们的"<strong class="ka ir"> Hello React！</strong>"消息。</p><p id="3f44" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">安装react路由器:</strong> React路由器是向React应用程序添加路由的最流行的解决方案。它通过将组件与路由相关联(在任何嵌套级别)来保持UI与URL同步。当用户更改URL时，组件会自动卸载和装载。</p><p id="e920" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">路由器是一个外部库，它必须与npm一起安装(以及历史库，这是一个反应路由器对等依赖项</p><p id="8240" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用npm:</p><p id="33be" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mi mj mk ma b">$ npm install --save react-router-dom history</code></p><p id="7c93" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将以下代码添加到<code class="fe mi mj mk ma b">routes.js</code>文件中:</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="8de5" class="kx ky iq ma b gy me mf l mg mh">import React from 'react';<br/>import { HashRouter, Route, hashHistory } from 'react-router-dom';<br/>import Home from './components/Home';<br/>// import more components<br/>export default (<br/>    &lt;HashRouter history={hashHistory}&gt;<br/>     &lt;div&gt;<br/>      &lt;Route path='/' component={Home} /&gt;<br/>     &lt;/div&gt;<br/>    &lt;/HashRouter&gt;<br/>);</span></pre><blockquote class="mq mr ms"><p id="5fcb" class="jy jz mt ka b kb kc kd ke kf kg kh ki mu kk kl km mv ko kp kq mw ks kt ku kv ij bi translated"><code class="fe mi mj mk ma b">routes.js</code>从<code class="fe mi mj mk ma b">hello<em class="iq">_template/templates/static/js</em>/components/Home.jsx</code>导入了<code class="fe mi mj mk ma b">Home</code>类，所以这个类需要被导出才能导入。</p><p id="a45d" class="jy jz mt ka b kb kc kd ke kf kg kh ki mu kk kl km mv ko kp kq mw ks kt ku kv ij bi translated">记得我们说过<code class="fe mi mj mk ma b">index.html</code>文件包含一个Div，在其中呈现react组件。我们看到<code class="fe mi mj mk ma b">index.html</code>有一个Id为“<code class="fe mi mj mk ma b">content</code>”的Div，其中<code class="fe mi mj mk ma b">index.jsx</code>呈现来自<code class="fe mi mj mk ma b">routes.js</code>的路线</p></blockquote><p id="f1d9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> React组件</strong>:在React应用程序中，一切都是由组件组成的，这些组件是自包含的、特定于关注点的构建块。使用组件开发应用程序允许“分而治之”的方法，其中没有特定的部分需要特别复杂。它们很小，因为它们可以组合，所以很容易用更小的组件创建复杂的、功能更丰富的组件。</p><p id="f28c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用React组件架构有一些优点，例如:</p><ul class=""><li id="0c31" class="mz na iq ka b kb kc kf kg kj nb kn nc kr nd kv ne nf ng nh bi translated">它支持使用相同的原则为Web以及原生iOS和Android视图呈现HTML</li><li id="27c9" class="mz na iq ka b kb ni kf nj kj nk kn nl kr nm kv ne nf ng nh bi translated">事件在所有浏览器和设备中以一致、符合标准的方式运行，自动使用委托。</li><li id="4f08" class="mz na iq ka b kb ni kf nj kj nk kn nl kr nm kv ne nf ng nh bi translated">React组件可以在服务器上呈现，以获得SEO和感知性能</li></ul><p id="6a8e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，React组件只是React UIs的构建块，它只是由一个JavaScript类和一个返回组件UI描述的render方法组成。</p><p id="937b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这个项目中，我们将只创建一个组件来描述我们的web应用程序主页。然而，我们应该为每个UI创建一个组件，它将负责描述指定的UI。</p><p id="5f03" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将以下代码输入到<code class="fe mi mj mk ma b"><em class="mt">hello_template/templates/static/js/components/Home.jsx</em></code> <em class="mt"> </em>文件中</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="62ce" class="kx ky iq ma b gy me mf l mg mh">import React, { Component } from 'react';<br/>export default class Home extends Component {<br/>    render() {<br/>       return (<br/>          &lt;h1&gt;Hello React!&lt;/h1&gt;<br/>       )<br/>    }<br/>}</span></pre><blockquote class="mq mr ms"><p id="fb47" class="jy jz mt ka b kb kc kd ke kf kg kh ki mu kk kl km mv ko kp kq mw ks kt ku kv ij bi translated">我们可以注意到JavaScript代码中间的HTML标签。如前所述，React对JavaScript有一个语法扩展，叫做JSX，它让我们可以编写内嵌代码的XML(以及HTML)。因此，我们使用巴别塔将JSX转换成普通的JavaScript。</p></blockquote><p id="4693" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">样式表</strong> : Webpack提供了两个加载器来处理样式表:<code class="fe mi mj mk ma b">css-loader</code>和<code class="fe mi mj mk ma b">style-loader</code>。每个加载器处理不同的任务:当css加载器寻找<code class="fe mi mj mk ma b"><a class="ae kw" href="http://twitter.com/import" rel="noopener ugc nofollow" target="_blank">@import</a></code>和<code class="fe mi mj mk ma b">url </code>语句并解析它们时，样式加载器将所有计算出的样式规则添加到页面中。结合在一起，这些加载器使您能够将样式表嵌入到Webpack JavaScript包中。</p><p id="1c26" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">用npm安装css加载器和样式加载器</p><p id="9c31" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mi mj mk ma b">npm install — save-dev style-loader css-loader</code></p><p id="2bb0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">依次更新webpack配置文件，如下所示:</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="72d6" class="kx ky iq ma b gy me mf l mg mh">const webpack = require('webpack');<br/>const config = {<br/>        devtool: 'eval-source-map',<br/> entry: __dirname + '/js/index.jsx',<br/> output:{<br/>  path: __dirname + '/dist',<br/>  filename: 'bundle.js',<br/>},<br/> resolve: {<br/>  extensions: ['.js','.jsx','.css']<br/> },<br/> module: {<br/>  rules: [<br/>  {<br/>   test: /\.jsx?/,<br/>   loader: 'babel-loader',<br/>   exclude: /node_modules/,<br/>  },<br/><strong class="ma ir">  {<br/>         test: /\.css$/,<br/>         loader: 'style-loader!css-loader?modules'<br/>  }</strong>]<br/>}<br/>};<br/>module.exports = config;</span></pre><blockquote class="mq mr ms"><p id="fe16" class="jy jz mt ka b kb kc kd ke kf kg kh ki mu kk kl km mv ko kp kq mw ks kt ku kv ij bi translated">感叹号("！")可以在加载器配置中用来将不同的加载器链接到相同的文件类型</p><p id="8460" class="jy jz mt ka b kb kc kd ke kf kg kh ki mu kk kl km mv ko kp kq mw ks kt ku kv ij bi translated">从webpack v4中，自动加载器模块名称扩展已被删除。引用装载机时不再可能省略<code class="fe mi mj mk ma b">-loader</code>扩展。所以不是以前的<code class="fe mi mj mk ma b">loader: style!css</code>现在是<br/> <code class="fe mi mj mk ma b">loader: ‘style-loader! css-loader</code></p></blockquote><p id="0210" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们写一个简单的css文件来说明。将下面的代码复制到文件<code class="fe mi mj mk ma b"><em class="mt">hello_template/templates/public/css/main.css</em></code></p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="8064" class="kx ky iq ma b gy me mf l mg mh">html {<br/> box-sizing: border-box;<br/> -ms-text-size-adjust: 100%;<br/> -webkit-text-size-adjust: 100%;<br/>}<br/>*, *:before, *:after {<br/> box-sizing: inherit;<br/>}<br/>body {<br/> margin: 0;<br/> font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;<br/>}<br/>h1, h2, h3, h4, h5, h6, p, ul {<br/> margin: 0;<br/> padding: 0;<br/>}</span></pre><p id="a204" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，我们应该记住，Webpack从其配置文件中定义的条目文件开始，并通过遵循诸如import、require、url等语句来构建所有的依赖树。这意味着主CSS文件也必须导入到应用程序中的某个地方，以便webpack能够找到它。</p><p id="7b92" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们将我们的<code class="fe mi mj mk ma b">main.css</code>导入到<code class="fe mi mj mk ma b">index.html</code>中</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="0a50" class="kx ky iq ma b gy me mf l mg mh">&lt;!- index.html -&gt;<br/>&lt;html&gt;<br/>  &lt;head&gt;<br/>    &lt;meta charset="utf-8"&gt;<br/>    &lt;!-- Latest compiled and minified bootstrap CSS --&gt;<br/>    &lt;link rel="stylesheet" href="<a class="ae kw" href="https://maxcdn.bootstrapcdn.com/bootstrap/latest/css/bootstrap.min.css" rel="noopener ugc nofollow" target="_blank">https://maxcdn.bootstrapcdn.com/bootstrap/latest/css/bootstrap.min.css</a>"&gt;<br/>    <strong class="ma ir">&lt;link rel="stylesheet" href="public/css/main.css"&gt;</strong><br/>    &lt;title&gt;Creating a Full-Stack Python Application with Flask, NPM, React.js and Webpack&lt;/title&gt;<br/>  &lt;/head&gt;<br/>  &lt;body&gt;<br/>    &lt;div id="content" /&gt;<br/>    &lt;script src="public/bundle.js" type="text/javascript"&gt;&lt;/script&gt;<br/>  &lt;/body&gt;<br/>&lt;/html&gt;</span></pre><h2 id="40f9" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">运行应用程序</h2><figure class="lv lw lx ly gt jr gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/1e734017c6dfc2298058812c3e051fef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1098/format:webp/1*0Yl4jXjYNa2oN7CqBf_VhQ.png"/></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">我们在Firefox网络浏览器上运行的网络应用</figcaption></figure><p id="2043" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">打开<code class="fe mi mj mk ma b">hello_template/templates/static/</code>文件夹中的终端，启动开发观察服务器</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="7968" class="kx ky iq ma b gy me mf l mg mh">npm run watch</span></pre><blockquote class="mq mr ms"><p id="582f" class="jy jz mt ka b kb kc kd ke kf kg kh ki mu kk kl km mv ko kp kq mw ks kt ku kv ij bi translated">如果你在这里得到一个类似于**的错误<strong class="ka ir"><em class="iq">NPM warn babel-loader @ 8 . 0 . 2需要一个对等的</em></strong><a class="ae kw" href="http://twitter.com/babel/core" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir"><em class="iq">@ babel/core</em></strong></a><strong class="ka ir"><em class="iq">@⁷.0.0但是没有一个被安装</em>。</strong> **，那么您应该将您的babel-loader降级到7.x，如下所示:</p><p id="fe04" class="jy jz mt ka b kb kc kd ke kf kg kh ki mu kk kl km mv ko kp kq mw ks kt ku kv ij bi translated"><code class="fe mi mj mk ma b">npm install babel-loader@^7 --save-dev</code></p></blockquote><p id="13cd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这个项目的根目录下打开一个终端，启动python服务器</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="747a" class="kx ky iq ma b gy me mf l mg mh">python run.py</span></pre><p id="666f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果一切正常，您将获得一个地址<code class="fe mi mj mk ma b"><a class="ae kw" href="http://127.0.0.1:5000/" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:5000/</a></code>，您可以在您最喜欢的浏览器中打开该地址，并看到我们的应用程序运行并显示"<strong class="ka ir"> Hello React！</strong></p><h2 id="9402" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">仅此而已。您刚刚创建了您的<strong class="ak"> <em class="nr">基本全栈应用</em> </strong>。</h2><p id="f6fa" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">谢谢你的时间，我会相应地更新这篇文章。你可以通过评论、建议和分享这篇文章来做出贡献，这样我们就可以一起教育这个世界。</p><p id="7224" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi ns translated"><span class="l nt nu nv bm nw nx ny nz oa di">答</span>同样，如果你喜欢这篇文章，你可能想继续学习这篇文章<a class="ae kw" rel="noopener ugc nofollow" target="_blank" href="/react-and-flask-full-stack-web-app-component-oriented-and-data-driven-dd60e005266">这里</a>，在这里我们将看到如何使我们的web应用程序<strong class="ka ir">面向组件</strong>和<strong class="ka ir">数据驱动</strong></p><p id="4470" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我会发布更多这样的文章，所以请确保你在媒体上关注我，这样你就不会错过我的任何新发布。</p></div></div>    
</body>
</html>