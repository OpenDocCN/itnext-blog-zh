<html>
<head>
<title>Protobuf and Null Support</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Protobuf和Null支持</h1>
<blockquote>原文：<a href="https://itnext.io/protobuf-and-null-support-1908a15311b6?source=collection_archive---------0-----------------------#2020-02-25">https://itnext.io/protobuf-and-null-support-1908a15311b6?source=collection_archive---------0-----------------------#2020-02-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div class="gh gi ir"><img src="../Images/60701c57eb492c253f3a3c2ef980fe6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*MyJgYiRqsj7CNrKEgdVTOw.jpeg"/></div><figcaption class="iy iz gj gh gi ja jb bd b be z dk translated">图片由<a class="ae jc" href="https://pixabay.com/users/tpsdave-12019/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=92358" rel="noopener ugc nofollow" target="_blank">大卫·马克</a>从<a class="ae jc" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=92358" rel="noopener ugc nofollow" target="_blank">皮克斯拜</a>拍摄</figcaption></figure><div class=""/><p id="da45" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">假设您有以下协议缓冲区/ gRPC定义:</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="af95" class="lj lk jf lf b gy ll lm l ln lo">service MyDataService {<br/>  rpc UpateMyData (UpdateMyDataRequest) <br/>     returns (UpdateMyDataResponse);<br/>}</span><span id="f4c2" class="lj lk jf lf b gy lp lm l ln lo">message MyData {<br/>  int32 id = 1;<br/>  string stringValue = 2;<br/>  SubData subData = 3;<br/>}<br/><br/>message SubData {<br/> int64 bigValue = 1;<br/>}</span><span id="fd64" class="lj lk jf lf b gy lp lm l ln lo">message UpdateMyDataRequest {<br/>  MyData update = 1;<br/>}</span></pre><p id="bf90" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">现在假设您想要删除<em class="lq"> MyData.stringValue </em>的数据库条目</p><p id="27f1" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">您的第一种方法可能是这样的:</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="f5e8" class="lj lk jf lf b gy ll lm l ln lo">UpdateMyDataRequest request = UpdateMyDataRequest.<em class="lq">newBuilder</em>()<br/>  .setUpdate(MyData.<em class="lq">newBuilder</em>()<br/>    .setId(id)<br/>    .setStringValue(null)<br/>  )<br/><br/>serviceFutureStub.update(request)</span></pre><p id="c20a" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">只有当你开始运行时，你才会得到一个NullPointerException。</p><p id="ba42" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">默认情况下，在协议生成的MessageTypes中设置任何值都会引发NullPointerException。另一方面，所有get方法都不会返回null。如果它们未被设置，get将返回一个默认值。</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="360a" class="lj lk jf lf b gy ll lm l ln lo">UpdateMyDataRequest.<em class="lq">newBuilder</em>().build().getStringValue() == ""</span></pre><h2 id="5995" class="lj lk jf bd lr ls lt dn lu lv lw dp lx kn ly lz ma kr mb mc md kv me mf mg mh bi translated">如何用协议缓冲区发送空值？</h2><p id="e95b" class="pw-post-body-paragraph kc kd jf ke b kf mi kh ki kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz im bi translated">让我用我自己的问题来回答你的问题。</p><p id="eac5" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated"><strong class="ke jg">空是什么意思？</strong></p><p id="0843" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">问题是null在不同的上下文中可能有不同的含义:</p><ul class=""><li id="c713" class="mn mo jf ke b kf kg kj kk kn mp kr mq kv mr kz ms mt mu mv bi translated">空就是空</li><li id="8127" class="mn mo jf ke b kf mw kj mx kn my kr mz kv na kz ms mt mu mv bi translated">Null是未设置的/可选的</li><li id="4460" class="mn mo jf ke b kf mw kj mx kn my kr mz kv na kz ms mt mu mv bi translated">Null是默认值</li><li id="7903" class="mn mo jf ke b kf mw kj mx kn my kr mz kv na kz ms mt mu mv bi translated">Null与其他值相混淆</li></ul><p id="46c5" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">为了避免这种混淆，Protobuf团队决定不序列化空值。相反，protobuf迫使您使用几种显式策略，从而避免Protobuf / gRPC API中的任何语义混乱。</p><p id="2554" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">在接下来的小节中，我们将讨论上面概述的每一个空用例，以及如何用Protobuf来表示它们。</p><p id="b46a" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">我们将专注于原型3。Proto2还有其他的语义，我们在这里就不赘述了。</p><h2 id="7f60" class="lj lk jf bd lr ls lt dn lu lv lw dp lx kn ly lz ma kr mb mc md kv me mf mg mh bi translated">首先是一些基本知识</h2><p id="d24f" class="pw-post-body-paragraph kc kd jf ke b kf mi kh ki kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz im bi translated">所有字段都是:</p><ol class=""><li id="592d" class="mn mo jf ke b kf kg kj kk kn mp kr mq kv mr kz nb mt mu mv bi translated">可选择的</li><li id="6b03" class="mn mo jf ke b kf mw kj mx kn my kr mz kv na kz nb mt mu mv bi translated">从不为空</li><li id="b86b" class="mn mo jf ke b kf mw kj mx kn my kr mz kv na kz nb mt mu mv bi translated">用默认值(0、空字符串等)初始化</li></ol></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h1 id="02f2" class="nj lk jf bd lr nk nl nm lu nn no np lx nq nr ns ma nt nu nv md nw nx ny mg nz bi translated">Null是Null:Null值模式之一</h1><p id="e1f3" class="pw-post-body-paragraph kc kd jf ke b kf mi kh ki kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz im bi translated">有时，null是一个有效值。例如，null可用于从数据库列中删除值。在本例中，假设我们希望允许消费者将<em class="lq"> MyData.stringValue </em>设置为null。</p><p id="be62" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">Json等效MyData对象:</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="7213" class="lj lk jf lf b gy ll lm l ln lo">{<br/>  "id": 123<br/>  "stringValue": null<br/>}</span></pre><p id="f833" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">正如我们前面提到的，我们不能将一个值设置为null。因此，我们需要通过其他方式来跟踪空信息。我们可以通过引入可空类型来做到这一点。熟悉<a class="ae jc" href="https://kotlinlang.org/docs/reference/null-safety.html" rel="noopener ugc nofollow" target="_blank">科特林的人会认出这种模式</a>。</p><p id="2b26" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated"><strong class="ke jg">原型定义:</strong></p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="b902" class="lj lk jf lf b gy ll lm l ln lo">syntax = "proto3";<br/><br/>package io.github.efenglu.protobuf.examples.oneof;<br/><br/>option java_multiple_files = true;<br/><br/>import "google/protobuf/struct.proto";<br/><br/>service MyDataService {<br/>  rpc UpateMyData (UpdateMyDataRequest) <br/>     returns (UpdateMyDataResponse);<br/>}<br/><br/>message MyData {<br/>  int32 intValue = 1;<br/>  NullableString stringValue = 2;<br/>  NullableSubData subData = 3;<br/>}<br/><br/>message SubData {<br/>  int64 bigValue = 1;<br/>}<br/><br/>message NullableSubData {<br/>  oneof kind {<br/>    google.protobuf.NullValue null = 1;<br/>    SubData data = 2;<br/>  }<br/>}<br/><br/>message NullableString {<br/>  oneof kind {<br/>    google.protobuf.NullValue null = 1;<br/>    string data = 2;<br/>  }<br/>}<br/><br/>message UpdateMyDataRequest {<br/> MyData data = 1;<br/>}<br/><br/><br/>message UpdateMyDataResponse {<br/><br/>}</span></pre><p id="b510" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">您会注意到两种新的“可空”类型:</p><ul class=""><li id="124f" class="mn mo jf ke b kf kg kj kk kn mp kr mq kv mr kz ms mt mu mv bi translated">可空字符串</li><li id="2f14" class="mn mo jf ke b kf mw kj mx kn my kr mz kv na kz ms mt mu mv bi translated">NullableSubData</li></ul><p id="97ce" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">这些类型由一个<a class="ae jc" href="https://developers.google.com/protocol-buffers/docs/proto#oneof" rel="noopener ugc nofollow" target="_blank">或一个</a>组成，有两个可能的值:</p><ul class=""><li id="6428" class="mn mo jf ke b kf kg kj kk kn mp kr mq kv mr kz ms mt mu mv bi translated">空</li><li id="4d45" class="mn mo jf ke b kf mw kj mx kn my kr mz kv na kz ms mt mu mv bi translated">非空对象</li></ul><p id="077f" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">oneof帮助我们强制数据不能同时为空和非空。</p><p id="c1b4" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">下面是java客户端如何使用生成的代码:</p><p id="4bb3" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated"><strong class="ke jg">发送空值:</strong></p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="6ae7" class="lj lk jf lf b gy ll lm l ln lo">UpdateMyDataRequest request = UpdateMyDataRequest.<em class="lq">newBuilder</em>()<br/>  .setData(MyData.<em class="lq">newBuilder</em>()<br/>    .setStringValue(NullableString.<em class="lq">newBuilder</em>()<br/>      .<strong class="lf jg">setNull(NullValue.<em class="lq">NULL_VALUE</em>)<br/></strong>      .build()<br/>    )<br/>    .setSubData(NullableSubData.<em class="lq">newBuilder</em>()<br/>      .<strong class="lf jg">setNull(NullValue.<em class="lq">NULL_VALUE</em>)</strong><br/>      .build()<br/>    ).build()<br/>).build();<br/><br/>service.upateMyData(request);</span></pre><p id="3ac9" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">注意这里我们调用了<em class="lq"> setNull </em>来表明我们有意发送一个空值。</p><p id="7f21" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated"><strong class="ke jg">客户端发送非空值:</strong></p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="09c9" class="lj lk jf lf b gy ll lm l ln lo">UpdateMyDataRequest request = UpdateMyDataRequest.<em class="lq">newBuilder</em>()<br/>  .setData(MyData.<em class="lq">newBuilder</em>()<br/>    .setStringValue(NullableString.<em class="lq">newBuilder</em>()<br/>      <strong class="lf jg">.setData("hello")</strong><br/>      .build()<br/>    )<br/>    .setSubData(NullableSubData.<em class="lq">newBuilder</em>()<br/>      .<strong class="lf jg">setData</strong>(SubData.<em class="lq">newBuilder</em>()<br/>        .setBigValue(1234567)<br/>      .build()<br/>    ).build()<br/>  ).build()<br/>).build();<br/><br/>service.upateMyData(request);</span></pre><p id="44a8" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">注意在这个客户端代码中，我们如何调用<em class="lq"> setData </em>来发送实际数据。</p><p id="e0e9" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated"><strong class="ke jg">服务器实现:</strong></p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="29df" class="lj lk jf lf b gy ll lm l ln lo">if (request.hasData()) {<br/><br/>  if (request.getData().hasStringValue()) {<br/>    final String nullableString;<br/>    if (request.getData().getStringValue().hasNull()) {<br/>      nullableString = null;<br/>    } else {<br/>      nullableString = request.getData()<br/>        .getStringValue()<br/>        .getData();<br/>      }<br/>  }<br/><br/>  if (request.getData().hasSubData()) {<br/>    final SubData nullableSubData;<br/>    if (request.getData().getSubData().hasNull()) {<br/>      nullableSubData = null;<br/>    } else {<br/>      nullableSubData = request.getData()<br/>       .getSubData()<br/>       .getData();<br/>    }<br/>  }<br/><br/>}</span></pre><p id="2c5a" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">请注意我们如何确保该值为null/non null，以及客户端实际上已经设置了该值。</p><p id="1aac" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated"><strong class="ke jg">优点:</strong></p><ul class=""><li id="c7c9" class="mn mo jf ke b kf kg kj kk kn mp kr mq kv mr kz ms mt mu mv bi translated">可空值的类型安全，为可空值创建不同的MessageType</li><li id="ecb8" class="mn mo jf ke b kf mw kj mx kn my kr mz kv na kz ms mt mu mv bi translated">非常明确，确保null是一个设定值</li></ul><p id="e640" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated"><strong class="ke jg">缺点:</strong></p><ul class=""><li id="1e88" class="mn mo jf ke b kf kg kj kk kn mp kr mq kv mr kz ms mt mu mv bi translated">需要空值消息类型</li><li id="e9cf" class="mn mo jf ke b kf mw kj mx kn my kr mz kv na kz ms mt mu mv bi translated">对许多类型来说不太好</li></ul></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h2 id="5b98" class="lj lk jf bd lr ls lt dn lu lv lw dp lx kn ly lz ma kr mb mc md kv me mf mg mh bi translated">Null作为可选:字段掩码模式</h2><p id="a1e0" class="pw-post-body-paragraph kc kd jf ke b kf mi kh ki kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz im bi translated">这在客户端只需要更新对象的一部分时，或者在创建返回部分填充对象的查询/搜索参数时非常有用。</p><p id="338d" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">这里，null用于表示不应被解释的缺失信息。也就是说，值为空不是因为我们希望它为空，它为空是因为我们不在乎。您通常会在json字段的遗漏中看到这一点。</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="a431" class="lj lk jf lf b gy ll lm l ln lo">{<br/> "id": 123<br/> -- ommited "stringValue" --<br/>}</span></pre><p id="7535" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">我们将对proto做类似的事情，只是我们也将明确地告诉服务器我们实际上忽略了哪些字段。</p><p id="331a" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated"><strong class="ke jg">原型定义:</strong></p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="c050" class="lj lk jf lf b gy ll lm l ln lo">service MyDataService {<br/>  rpc Update (UpdateMyDataRequest) returns (UpdateMyDataResponse);<br/>  rpc List (ListMyDataRequest) returns (ListMyDataResponse);<br/>}<br/><br/>message MyData {<br/>  int32 id = 1;<br/>  string stringValue = 2;<br/>  SubData subData = 3;<br/>}<br/><br/>message SubData {<br/>  int64 bigValue = 1;<br/>}<br/><br/>message UpdateMyDataRequest {<br/>  MyData update = 1;<br/>  <strong class="lf jg">google.protobuf.FieldMask field_mask = 2;</strong><br/>}<br/><br/>message UpdateMyDataResponse {<br/>  MyData new_data = 1;<br/>}<br/><br/>message ListMyDataRequest {<br/>  int32 id = 1;<br/>  <strong class="lf jg">google.protobuf.FieldMask field_mask = 2;</strong><br/>}<br/><br/>message ListMyDataResponse {<br/>  repeated MyData data = 1;<br/>}</span></pre><p id="f4d0" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">请注意，<em class="lq"> UpdateMyDataRequest </em>和<em class="lq"> ListMyDataRequest </em>有一个FieldMask字段。这是一种特殊的类型，它将传达数据中的哪些字段应该受到关注。</p><p id="c630" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated"><strong class="ke jg">示例客户端用法:</strong></p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="e937" class="lj lk jf lf b gy ll lm l ln lo">MyData <strong class="lf jg">sendUpdate</strong>(int id, String value) {<br/>  UpdateMyDataRequest request = UpdateMyDataRequest.<em class="lq">newBuilder</em>()<br/>    .setUpdate(MyData.<em class="lq">newBuilder</em>()<br/>      .setId(id)<br/>      .setStringValue(value)<br/>    )<br/>    .setFieldMask(FieldMaskUtil.<em class="lq">fromFieldNumbers</em>(<br/>      MyData.class, <br/>      MyData.<em class="lq">STRINGVALUE_FIELD_NUMBER</em>)<br/>    )<br/>    .build();<br/><br/>  return serviceFutureStub.update(request).getNewData();<br/>}<br/><br/>List&lt;MyData&gt; <strong class="lf jg">listOnlySubData</strong>(int id) {<br/>  ListMyDataRequest request = ListMyDataRequest.<em class="lq">newBuilder</em>()<br/>    .setId(id)<br/>    .setFieldMask(FieldMaskUtil.<em class="lq">fromFieldNumbers</em>(<br/>      MyData.class, <br/>      MyData.<em class="lq">SUBDATA_FIELD_NUMBER</em>)<br/>    )<br/>    .build();<br/><br/>  return serviceFutureStub.list(request).getDataList();<br/>}</span></pre><p id="7398" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated"><strong class="ke jg">示例服务器实现:</strong></p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="9241" class="lj lk jf lf b gy ll lm l ln lo">@Override<br/>public void update(<br/>  UpdateMyDataRequest request,<br/>  StreamObserver&lt;UpdateMyDataResponse&gt; responseObserver<br/>) {<br/><br/>  MyData updateData = request.getUpdate();<br/>  FieldMask fieldMask = request.getFieldMask();<br/><br/>  <strong class="lf jg">// Fetch exiting Values</strong><br/>  MyData existing = repo.readData(updateData.getId());<br/>  MyData.Builder builder = existing.toBuilder();<br/><br/>  <strong class="lf jg">// Update only the fields listed in the fieldmask</strong><br/>  FieldMaskUtil.<em class="lq">merge</em>(fieldMask, updateData, builder);<br/><br/>  <strong class="lf jg">// Store the result</strong><br/>  repo.writeData(builder.build());<br/><br/>  <strong class="lf jg">// Send the new state back</strong><br/>  responseObserver.onNext(UpdateMyDataResponse.<em class="lq">newBuilder</em>()<br/>    .setNewData(builder)<br/>    .build()<br/>  );<br/>}</span></pre><p id="13f3" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated"><strong class="ke jg">更新中的通知:</strong></p><ol class=""><li id="5429" class="mn mo jf ke b kf kg kj kk kn mp kr mq kv mr kz nb mt mu mv bi translated">获取我们想要更新的对象的现有值</li><li id="91f1" class="mn mo jf ke b kf mw kj mx kn my kr mz kv na kz nb mt mu mv bi translated">转变为建设者</li><li id="08a4" class="mn mo jf ke b kf mw kj mx kn my kr mz kv na kz nb mt mu mv bi translated">使用字段掩码Util将输入数据合并到构建器中</li><li id="7751" class="mn mo jf ke b kf mw kj mx kn my kr mz kv na kz nb mt mu mv bi translated">存储新状态</li><li id="2468" class="mn mo jf ke b kf mw kj mx kn my kr mz kv na kz nb mt mu mv bi translated">返回新值</li></ol><p id="215a" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated"><em class="lq"> FieldMaskUtil </em>将只从输入请求中复制字段掩码中列出的字段，并保留任何其他字段的现有值。</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="26d8" class="lj lk jf lf b gy ll lm l ln lo">@Override<br/>public void <strong class="lf jg">list</strong>(<br/>  ListMyDataRequest request,<br/>  StreamObserver&lt;ListMyDataResponse&gt; responseObserver<br/>) {<br/>  int id = request.getId();<br/>  FieldMask fieldMask = request.getFieldMask();</span><span id="3c9d" class="lj lk jf lf b gy lp lm l ln lo">  <strong class="lf jg">// Fetch the list</strong><br/>  List&lt;MyData&gt; result = repo.listData(id);<br/><br/>  ListMyDataResponse.Builder response = <br/>    ListMyDataRespons.<em class="lq">newBuilder</em>();</span><span id="f43b" class="lj lk jf lf b gy lp lm l ln lo">  MyData.Builder builder = MyData.<em class="lq">newBuilder</em>();</span><span id="2ebd" class="lj lk jf lf b gy lp lm l ln lo">  for (MyData data : result) {<br/>    builder.clear();<br/><br/>    <strong class="lf jg">// Use the field mask to send back ONLY the data requested</strong><br/>    FieldMaskUtil.<em class="lq">merge</em>(fieldMask, data, builder);<br/><br/>    response.addData(builder);<br/>  }<br/><br/>  <strong class="lf jg">// Send the filtered list back</strong><br/>  responseObserver.onNext(response.build());<br/>}</span></pre><p id="570e" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">这里有很多相同的，只是我们返回一个过滤值。</p><ol class=""><li id="b736" class="mn mo jf ke b kf kg kj kk kn mp kr mq kv mr kz nb mt mu mv bi translated">获取列表</li><li id="d10e" class="mn mo jf ke b kf mw kj mx kn my kr mz kv na kz nb mt mu mv bi translated">对于每个列表元素，过滤元素以仅返回请求的字段</li><li id="3c69" class="mn mo jf ke b kf mw kj mx kn my kr mz kv na kz nb mt mu mv bi translated">返回过滤列表</li></ol><p id="491e" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated"><strong class="ke jg">优点:</strong></p><ol class=""><li id="63e4" class="mn mo jf ke b kf kg kj kk kn mp kr mq kv mr kz nb mt mu mv bi translated">简明代码</li><li id="a8e4" class="mn mo jf ke b kf mw kj mx kn my kr mz kv na kz nb mt mu mv bi translated">更容易测试</li></ol><p id="423c" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated"><strong class="ke jg">缺点:</strong></p><ol class=""><li id="516f" class="mn mo jf ke b kf kg kj kk kn mp kr mq kv mr kz nb mt mu mv bi translated">字段掩码的概念可能很难理解</li><li id="a2f1" class="mn mo jf ke b kf mw kj mx kn my kr mz kv na kz nb mt mu mv bi translated">要求客户手动将字段调出到字段掩码中，这看起来可能是重复的</li><li id="43fb" class="mn mo jf ke b kf mw kj mx kn my kr mz kv na kz nb mt mu mv bi translated">字段的语义契约可以被打破</li></ol></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h2 id="33e4" class="lj lk jf bd lr ls lt dn lu lv lw dp lx kn ly lz ma kr mb mc md kv me mf mg mh bi translated">Null为可选:有模式</h2><p id="85f7" class="pw-post-body-paragraph kc kd jf ke b kf mi kh ki kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz im bi translated">最后一种模式是大多数人在谈到protobuf时的出发点。非原语消息类型中的每个字段都生成一个“<em class="lq"> has </em>方法，该方法返回一个<strong class="ke jg">布尔值</strong>。如果已经设置了值<em class="lq"/>，则该方法返回true。我们可以利用这个特性来查看消费者何时“设定了一个值”。然后我们可以推断未设置的字段不重要。</p><p id="da2f" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">现在这只适用于非原始类型，即消息类型。如果您需要原语的这种行为，Proto3为所有原语类型提供了包装器。</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="ebdd" class="lj lk jf lf b gy ll lm l ln lo">...<br/><br/><strong class="lf jg">import "google/protobuf/wrappers.proto";</strong><br/><br/>service MyDataService {<br/>  rpc Update (UpdateMyDataRequest) returns (UpdateMyDataResponse);<br/>}</span><span id="a4c4" class="lj lk jf lf b gy lp lm l ln lo">...</span><span id="2140" class="lj lk jf lf b gy lp lm l ln lo">message UpdateMyDataRequest {<br/>  int32 id = 1;<br/>  <strong class="lf jg">google.protobuf.StringValue stringValue = 2;</strong><br/>  UpdateSubData subData = 3;<br/>}<br/><br/>message UpdateSubData {<br/>  <strong class="lf jg">google.protobuf.Int64Value bigValue = 1;</strong><br/>}</span><span id="1f24" class="lj lk jf lf b gy lp lm l ln lo">...</span></pre><p id="1288" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">注意<em class="lq">Google/proto buf/wrappers . proto</em>和<em class="lq">Google . proto buf . string value</em>和<em class="lq">Google . proto buf . int 64 value</em>的导入。这些字段不再是原语，因此将生成一个“<em class="lq"> has </em>”方法。</p><p id="154b" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated"><strong class="ke jg">客户端使用:</strong></p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="56ae" class="lj lk jf lf b gy ll lm l ln lo">void update() {<br/>  service.update(UpdateMyDataRequest.<em class="lq">newBuilder</em>()<br/>    .setStringValue(<strong class="lf jg">StringValue.<em class="lq">of</em>("customValue")</strong>)<br/>    .build()<br/>  );<br/>}</span></pre><p id="48c9" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">在这里，客户端设置他们想要使用的字段。一个警告是字符串值字段必须用一个<em class="lq"> StringValue </em>对象填充，如上所示。</p><p id="6f68" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">熟悉Java预自动装箱的人会认识到这种模式。</p><p id="c1bb" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated"><strong class="ke jg">服务器实现:</strong></p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="9a00" class="lj lk jf lf b gy ll lm l ln lo">@Override<br/>public void update(<br/>  UpdateMyDataRequest request,<br/>  StreamObserver&lt;UpdateMyDataResponse&gt; responseObserver) {<br/><br/>  <strong class="lf jg">// Fetch exiting Values</strong><br/>  MyData existing = repo.readData(request.getId());<br/>  MyData.Builder builder = existing.toBuilder();<br/><br/>  <strong class="lf jg">// Update Fields as necessary</strong><br/>  if (request.hasStringValue()) {<br/>    builder.setStringValue(request.getStringValue().getValue());<br/>  }<br/><br/>  if (request.hasSubData()) {<br/>    if (request.getSubData().hasBigValue()) {<br/>      builder.setSubData(<br/>        builder.getSubData().toBuilder()<br/>          .setBigValue(request.getSubData()<br/>            .getBigValue()<br/>            .getValue()<br/>          )<br/>        );<br/>      }<br/>  }<br/><br/>  repo.writeData(builder.build());<br/><br/>  responseObserver.onNext(UpdateMyDataResponse.<em class="lq">newBuilder</em>()<br/>    .setNewData(builder)<br/>    .build()<br/>  );<br/>}</span></pre><p id="67e0" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">服务器实现也非常相似。然而，与将字段合并委托给<strong class="ke jg">字段相反，我们必须手动合并字段。</strong></p><ol class=""><li id="ae69" class="mn mo jf ke b kf kg kj kk kn mp kr mq kv mr kz nb mt mu mv bi translated">获取现有对象</li><li id="4148" class="mn mo jf ke b kf mw kj mx kn my kr mz kv na kz nb mt mu mv bi translated">转换为构建器</li><li id="3e8f" class="mn mo jf ke b kf mw kj mx kn my kr mz kv na kz nb mt mu mv bi translated">对于每个字段和递归字段，检查has并根据需要进行赋值</li><li id="e92c" class="mn mo jf ke b kf mw kj mx kn my kr mz kv na kz nb mt mu mv bi translated">存储值</li><li id="69ad" class="mn mo jf ke b kf mw kj mx kn my kr mz kv na kz nb mt mu mv bi translated">返回新值</li></ol><p id="1547" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated"><strong class="ke jg">优点:</strong></p><ol class=""><li id="1ce0" class="mn mo jf ke b kf kg kj kk kn mp kr mq kv mr kz nb mt mu mv bi translated">概念上容易理解</li><li id="add3" class="mn mo jf ke b kf mw kj mx kn my kr mz kv na kz nb mt mu mv bi translated">小型客户端代码</li></ol><p id="2209" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated"><strong class="ke jg">缺点:</strong></p><ol class=""><li id="65e6" class="mn mo jf ke b kf kg kj kk kn mp kr mq kv mr kz nb mt mu mv bi translated">服务器实现容易中断:错过一个已经，或添加一个字段和合并被打破</li><li id="6614" class="mn mo jf ke b kf mw kj mx kn my kr mz kv na kz nb mt mu mv bi translated">有许多分支的大型服务器代码</li></ol></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h1 id="3ba9" class="nj lk jf bd lr nk nl nm lu nn no np lx nq nr ns ma nt nu nv md nw nx ny mg nz bi translated">空反模式:默认值</h1><p id="7449" class="pw-post-body-paragraph kc kd jf ke b kf mi kh ki kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz im bi translated">我们已经讨论了您“应该”使用的几种模式及其优缺点。现在我们来讨论一个你不应该使用的模式！</p><p id="3c39" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">对照默认值检查该值。</p><p id="6190" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">你可能会说。</p><blockquote class="oa ob oc"><p id="941e" class="kc kd lq ke b kf kg kh ki kj kk kl km od ko kp kq oe ks kt ku of kw kx ky kz im bi translated">哦，如果值是default，那么我知道这个值没有被设置，因此是null。</p></blockquote><p id="b81e" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated"><strong class="ke jg">假的！</strong></p><ul class=""><li id="627e" class="mn mo jf ke b kf kg kj kk kn mp kr mq kv mr kz ms mt mu mv bi translated">消费者可能已经将该值设置为默认值</li><li id="39ce" class="mn mo jf ke b kf mw kj mx kn my kr mz kv na kz ms mt mu mv bi translated">Proto3不允许你提供缺省值，它们只是典型的缺省值(0，"")，因此有点模糊</li></ul><p id="9096" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">不要自作聪明，把值当值就行了。</p><p id="69e7" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">不要试图从缺省值中为原始类型创建自己的"<em class="lq"> has" </em>"。使用“<em class="lq"> has </em>”方法和原始包装器。</p></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h1 id="78f9" class="nj lk jf bd lr nk nl nm lu nn no np lx nq nr ns ma nt nu nv md nw nx ny mg nz bi translated">空反模式:空字符串</h1><p id="26b3" class="pw-post-body-paragraph kc kd jf ke b kf mi kh ki kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz im bi translated">看到此代码的图像:</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="7122" class="lj lk jf lf b gy ll lm l ln lo">String value;<br/>if (value != null) {<br/>  // insert value into database<br/>}</span></pre><p id="d34f" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">看这里有什么不对。</p><ul class=""><li id="7c27" class="mn mo jf ke b kf kg kj kk kn mp kr mq kv mr kz ms mt mu mv bi translated">空字符串“”的值是什么？</li><li id="9cf6" class="mn mo jf ke b kf mw kj mx kn my kr mz kv na kz ms mt mu mv bi translated">或者如果值都是空白" "，该怎么办？</li></ul><p id="6616" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">Protobuf将字符串视为原始类型，因此它们不能为空。不要检查字符串是否为空，而是使用标准库，如apache commons，来检查字符串是否为空。</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="417b" class="lj lk jf lf b gy ll lm l ln lo">String value;<br/>if (StringUtils.isNotBlank(value)) {<br/>  // insert value into database<br/>}</span></pre><p id="7832" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">很明显，如果值不为空，将会插入该值。</p></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h1 id="b5d1" class="nj lk jf bd lr nk nl nm lu nn no np lx nq nr ns ma nt nu nv md nw nx ny mg nz bi translated">高级用例</h1><p id="e1cf" class="pw-post-body-paragraph kc kd jf ke b kf mi kh ki kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz im bi translated">我们的团队希望通过我们的“零支持”更进一步。我们创建了定制的协议代码生成插件来定制生成的代码以适应我们的目的。</p><p id="891b" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">我们增加了对以下内容的支持:</p><ul class=""><li id="f05f" class="mn mo jf ke b kf kg kj kk kn mp kr mq kv mr kz ms mt mu mv bi translated">可选退货类型</li></ul><p id="1933" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">我们还分叉了协议生成器，以允许:</p><ul class=""><li id="a639" class="mn mo jf ke b kf kg kj kk kn mp kr mq kv mr kz ms mt mu mv bi translated">get上的空检查</li><li id="89df" class="mn mo jf ke b kf mw kj mx kn my kr mz kv na kz ms mt mu mv bi translated">允许设置空值来清除该值</li><li id="0bf7" class="mn mo jf ke b kf mw kj mx kn my kr mz kv na kz ms mt mu mv bi translated">创建了一个"<em class="lq">有"</em>的方法用于原语类型</li></ul><p id="23d0" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">看看我的另一篇关于如何创建自己的协议插件的文章。</p><div class="is it gp gr iu og"><a rel="noopener  ugc nofollow" target="_blank" href="/customizing-grpc-generated-code-5909a2551ca1"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd jg gy z fp ol fr fs om fu fw je bi translated">定制gRPC生成的代码</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">如何定制gRPC生成的代码</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">itnext.io</p></div></div><div class="op l"><div class="oq l or os ot op ou iw og"/></div></div></a></div></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><p id="039a" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">总而言之。是的，这是真的，协议缓冲区不支持空值。然而，从大局来看，事情并没有那么糟糕。</p><p id="9435" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">协议缓冲迫使你问:</p><ul class=""><li id="3390" class="mn mo jf ke b kf kg kj kk kn mp kr mq kv mr kz ms mt mu mv bi translated">你是如何使用价值的？</li><li id="df65" class="mn mo jf ke b kf mw kj mx kn my kr mz kv na kz ms mt mu mv bi translated">我在这里用null想表达什么？</li><li id="3962" class="mn mo jf ke b kf mw kj mx kn my kr mz kv na kz ms mt mu mv bi translated">我可以不用null的模糊性来表达这个吗？</li></ul><p id="9a0b" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">查看与本文相关的完整示例:</p><div class="is it gp gr iu og"><a href="https://github.com/efenglu/protobuf_null" rel="noopener  ugc nofollow" target="_blank"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd jg gy z fp ol fr fs om fu fw je bi translated">efenglu/protobuf_null</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">Protobuf和空值序列化的示例用例我的Medium文章中引用了这些示例。</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">github.com</p></div></div><div class="op l"><div class="ov l or os ot op ou iw og"/></div></div></a></div></div></div>    
</body>
</html>