<html>
<head>
<title>Clean Code Checklist in Angular ✔️</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">角度✔️中的清洁代码清单</h1>
<blockquote>原文：<a href="https://itnext.io/clean-code-checklist-in-angular-%EF%B8%8F-10d4db877f74?source=collection_archive---------0-----------------------#2018-11-07">https://itnext.io/clean-code-checklist-in-angular-%EF%B8%8F-10d4db877f74?source=collection_archive---------0-----------------------#2018-11-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/7594137f293b4daad1fda083a05a7208.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XZiWn4Ej-ZfJ6Pxj-b9AkQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">格伦·卡斯滕斯-彼得斯在<a class="ae kc" href="https://unsplash.com/search/photos/structure?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="5a30" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated"><strong class="ak">简介</strong></h1><p id="37de" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">Angular已经迅速发展成为构建前端、跨平台web应用程序的最流行的框架之一。它提供了许多开箱即用的特性，比如路由系统、依赖注入框架、表单处理等。Angular还强制您同时使用TypeScript和RxJS，因为它已经是Angular生态系统的一部分。这种广泛的功能使Angular成为大型企业解决方案的良好候选。</p><p id="6529" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">虽然Angular是一个非常强大的框架，具有广泛的工具包，但它很难掌握，尤其是如果它是您的第一个JavaScript框架。为了降低复杂性，我决定整理一份干净的代码清单，其中包括我个人对编写干净的、可投入生产的Angular代码的建议。</p><h1 id="a4d6" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated"><strong class="ak">背景</strong></h1><p id="7bdb" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">随着我们成为更好的开发人员，构建和组织代码变得越来越重要。我们希望编写的代码能够提高可读性、可伸缩性、可维护性和性能，并最大限度地减少调试时间。</p><p id="1401" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">正如马丁·戈尔丁所说:</p><blockquote class="me mf mg"><p id="892e" class="lb lc mh ld b le lz lg lh li ma lk ll mi mb lo lp mj mc ls lt mk md lw lx ly ij bi translated">编写代码的时候，要把最终维护你的代码的人想象成一个知道你住哪儿的暴力精神病患者。</p></blockquote><p id="c8d9" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">听起来令人不安，但这并没有减少信息的真实性。程序员才是真正的作者，其他开发者才是他们的目标受众。试图理解别人的代码所花费的时间占据了我们日常工作的很大一部分。因此，我们应该有意识地努力提高代码的质量。这对于创建一个成功的、可维护的产品是必不可少的。</p><h1 id="291b" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated"><strong class="ak">风格指南</strong></h1><p id="b627" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">在Angular中寻找最佳实践的逻辑起点是<a class="ae kc" href="https://angular.io/guide/styleguide" rel="noopener ugc nofollow" target="_blank"> Angular风格指南</a>。这是一个关于语法、惯例和应用程序结构的固执己见的指南。《风格指南》介绍了首选的约定，并举例说明了为什么应该使用它们。</p><h1 id="3050" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">角度CLI</h1><p id="0810" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated"><a class="ae kc" href="https://cli.angular.io/" rel="noopener ugc nofollow" target="_blank"> Angular CLI </a>是创建和使用Angular应用程序的绝佳工具。它消除了手动创建每个文件的繁琐工作，从而提高了工作效率。只需几个命令，您就可以:</p><ul class=""><li id="d452" class="ml mm iq ld b le lz li ma lm mn lq mo lu mp ly mq mr ms mt bi translated">从头开始创建项目</li><li id="5b0d" class="ml mm iq ld b le mu li mv lm mw lq mx lu my ly mq mr ms mt bi translated">脚手架组件、指令和服务</li><li id="3058" class="ml mm iq ld b le mu li mv lm mw lq mx lu my ly mq mr ms mt bi translated">Lint您的代码</li><li id="f7fe" class="ml mm iq ld b le mu li mv lm mw lq mx lu my ly mq mr ms mt bi translated">为应用服务</li><li id="48c9" class="ml mm iq ld b le mu li mv lm mw lq mx lu my ly mq mr ms mt bi translated">运行单元测试和端到端测试</li></ul><p id="6e5f" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">你可以在这里找到更多关于Angular CLI <a class="ae kc" href="https://www.intertech.com/Blog/angular-tutorial-getting-started-with-the-angular-cli/" rel="noopener ugc nofollow" target="_blank">的信息。</a></p><h1 id="a156" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated"><strong class="ak">文件夹结构</strong></h1><p id="1bd7" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">随着应用程序规模的增长，建立一个便于管理和维护代码库的结构非常重要。无论你决定使用哪种结构，保持一致并选择整个团队都满意的结构是很重要的。</p><p id="a3a9" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">文章“<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/choosing-a-highly-scalable-folder-structure-in-angular-d987de65ec7">如何为你的Angular项目</a>定义一个高度可伸缩的文件夹结构”讨论了这些主题，并且可以在决定你自己的结构时作为一个参考点。</p><h1 id="81d2" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated"><strong class="ak">编写可读代码</strong></h1><p id="326e" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">如果你希望重构尽可能高效，拥有可读的代码是很重要的。可读的代码更容易理解，这使得调试、维护和扩展变得容易。</p><h2 id="8036" class="mz ke iq bd kf na nb dn kj nc nd dp kn lm ne nf kr lq ng nh kv lu ni nj kz nk bi translated"><strong class="ak">文件名</strong></h2><p id="87c9" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">添加新文件时，请注意您决定使用的文件名。文件名应该一致，并用点分隔来描述特征。</p><pre class="nl nm nn no gt np nq nr ns aw nt bi"><span id="7cbd" class="mz ke iq nq b gy nu nv l nw nx">|-- my-feature.component.ts<br/>or<br/>|-- my-service.service.ts</span></pre><h2 id="3b3e" class="mz ke iq bd kf na nb dn kj nc nd dp kn lm ne nf kr lq ng nh kv lu ni nj kz nk bi translated"><strong class="ak">变量和函数名</strong></h2><p id="28a1" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">您需要命名变量和函数，以便下一个开发人员理解它们。描述性强，使用有意义的名称——清晰胜于简洁<em class="mh">。</em></p><p id="9416" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">这将帮助我们避免编写这样的函数:</p><pre class="nl nm nn no gt np nq nr ns aw nt bi"><span id="daf5" class="mz ke iq nq b gy nu nv l nw nx">function div(x, y)) {<br/> const val = x / y;<br/> return val;<br/>}</span></pre><p id="83c9" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">希望更像这样:</p><pre class="nl nm nn no gt np nq nr ns aw nt bi"><span id="c76e" class="mz ke iq nq b gy nu nv l nw nx">function divide(divident, divisor) {<br/>  const quotient = divident / divisor;<br/>  return quotient;<br/>}</span></pre><h2 id="0f3e" class="mz ke iq bd kf na nb dn kj nc nd dp kn lm ne nf kr lq ng nh kv lu ni nj kz nk bi translated"><strong class="ak">写小的纯函数</strong></h2><p id="d82a" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">当我们编写函数来执行一些业务逻辑时，我们应该保持它们小而干净。小功能更容易测试和维护。当你开始注意到你的函数变得冗长和混乱时，把一些逻辑抽象成一个新的逻辑可能是个好主意。</p><p id="bf48" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">这避免了像这样的功能:</p><pre class="nl nm nn no gt np nq nr ns aw nt bi"><span id="17f8" class="mz ke iq nq b gy nu nv l nw nx">addOrUpdateData(data: Data, status: boolean) {<br/>  if (status) {<br/>    return this.http.post&lt;Data&gt;(url, data)<br/>      .pipe(this.catchHttpErrors());<br/>  }<br/>  return this.http.put&lt;Data&gt;(`${url}/${data.id}`, data)<br/>    .pipe(this.catchHttpErrors());<br/>  }<br/>}</span></pre><p id="b539" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">希望更像这样:</p><pre class="nl nm nn no gt np nq nr ns aw nt bi"><span id="3054" class="mz ke iq nq b gy nu nv l nw nx">addData(data: Data) {<br/>  return this.http.post&lt;Data&gt;(url, data)<br/>    .pipe(this.catchHttpErrors());<br/>}</span><span id="022b" class="mz ke iq nq b gy ny nv l nw nx">updateData(data: Data) {<br/>  return this.http.put&lt;Data&gt;(`${url}/${data.id}`, data)<br/>    .pipe(this.catchHttpErrors());<br/>}</span></pre><h2 id="4e98" class="mz ke iq bd kf na nb dn kj nc nd dp kn lm ne nf kr lq ng nh kv lu ni nj kz nk bi translated"><strong class="ak">删除未使用的代码</strong></h2><p id="b4f2" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">知道一段代码是否被使用是非常有价值的。如果您让未使用的代码留下来，那么在将来，很难或者几乎不可能确定它是否被真正使用。因此，您应该优先删除未使用的代码。</p><h2 id="8658" class="mz ke iq bd kf na nb dn kj nc nd dp kn lm ne nf kr lq ng nh kv lu ni nj kz nk bi translated"><strong class="ak">避免代码注释</strong></h2><p id="fb67" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">虽然有评论的情况，但你真的应该尽量避免。你不希望你的注释弥补你在代码中表达信息的失败。注释应该随着代码的更新而更新，但是更好的利用时间的方法是编写代码来解释它自己。不准确的评论比根本没有评论更糟糕，正如匿名的所说:</p><blockquote class="me mf mg"><p id="d9d3" class="lb lc mh ld b le lz lg lh li ma lk ll mi mb lo lp mj mc ls lt mk md lw lx ly ij bi translated">代码从不说谎，注释会。</p></blockquote><p id="e54a" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">这样可以避免编写这样的代码:</p><pre class="nl nm nn no gt np nq nr ns aw nt bi"><span id="91b9" class="mz ke iq nq b gy nu nv l nw nx">// check if meal is healthy or not<br/>if (meal.calories &lt; 1000 &amp;&amp;<br/>    meal.hasVegetables) {<br/>  ...<br/>}</span></pre><p id="8391" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">希望更像这样:</p><pre class="nl nm nn no gt np nq nr ns aw nt bi"><span id="03d1" class="mz ke iq nq b gy nu nv l nw nx">if (meal.isHealthy()) {<br/> ...<br/>}</span></pre><h1 id="140e" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated"><strong class="ak">关注点分离</strong></h1><p id="a2e7" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">Angular是围绕关注点的分离而构建的。这是一种设计模式，它使我们的代码更容易维护和扩展，更具可重用性和可测试性。它帮助我们封装和限制组件的逻辑，以满足模板的实际需要，仅此而已。关注点分离是用Angular编写干净代码的核心，并使用以下规则集:</p><ul class=""><li id="c60d" class="ml mm iq ld b le lz li ma lm mn lq mo lu mp ly mq mr ms mt bi translated">将应用程序分成多个模块。项目变得更有组织性、可维护性、可读性和可重用性，并且我们能够延迟加载特性。</li></ul><pre class="nl nm nn no gt np nq nr ns aw nt bi"><span id="b25b" class="mz ke iq nq b gy nu nv l nw nx">|-- modules<br/>|    |-- home<br/>|    |     |-- home.spec|module|component|scss||routing.module|.ts<br/>|    |-- about<br/>|    |     |-- about.spec|module|component|scss|routin.module|.ts</span></pre><ul class=""><li id="7ca3" class="ml mm iq ld b le lz li ma lm mn lq mo lu mp ly mq mr ms mt bi translated">当我们发现自己需要在应用程序其他部分重用业务逻辑时，我们应该考虑创建一个服务。服务是Angular的核心部分，也是放置可重用业务逻辑的好地方。服务最常见的用例是HTTP相关的事件。通过使用一个服务来管理我们的HTTP调用，我们确切地知道哪里需要进行更改，并且这些是唯一受影响的行。</li></ul><p id="9521" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated"><em class="mh">快提示！您还可以创建一个API服务，为您处理大量与HTTP相关的逻辑。我推荐看看</em> <a class="ae kc" href="https://github.com/gothinkster/angular-realworld-example-app/blob/master/src/app/core/services/api.service.ts" rel="noopener ugc nofollow" target="_blank"> <em class="mh">这个</em> </a> <em class="mh"> GitHub-example。</em></p><ul class=""><li id="ff9f" class="ml mm iq ld b le lz li ma lm mn lq mo lu mp ly mq mr ms mt bi translated">您应该为您的应用程序创建一个类似“公共框架”的东西，在其中包含公共组件。当您不想让相同的代码污染您的组件时，这很方便。因为Angular不允许我们在不同的模块之间直接导入组件，所以我们需要将这些组件放在共享模块中。</li></ul><pre class="nl nm nn no gt np nq nr ns aw nt bi"><span id="c8e7" class="mz ke iq nq b gy nu nv l nw nx">// src/app/shared/components/reusable/resuable.component</span><span id="a4b3" class="mz ke iq nq b gy ny nv l nw nx">...</span><span id="dc57" class="mz ke iq nq b gy ny nv l nw nx">export class ReusableComponent implements OnInit {<br/>  @Input() title: string;<br/>  @Input() body: string;<br/> <br/>  @Output() buttonClick = new EventEmitter();</span><span id="127b" class="mz ke iq nq b gy ny nv l nw nx">  constructor() { }</span><span id="bcda" class="mz ke iq nq b gy ny nv l nw nx">  ngOnInit() {}</span><span id="f9db" class="mz ke iq nq b gy ny nv l nw nx">  onButtonClick(){<br/>    this.buttonClick.emit('Button was clicked');<br/>  }<br/>}</span><span id="1320" class="mz ke iq nq b gy ny nv l nw nx">--------------------------------------------------------------------</span><span id="cf87" class="mz ke iq nq b gy ny nv l nw nx">// You can then use this component directly inside the components of<br/>// your choice</span><span id="d4b3" class="mz ke iq nq b gy ny nv l nw nx">// src/app/some/some.component</span><span id="30b5" class="mz ke iq nq b gy ny nv l nw nx">@Component({<br/>  selector: 'app-some',<br/>  template: `&lt;app-reusable [title]="'Awesome title!'"<br/>               [body]="'Lorem ipsum'"<br/>               (buttonClick)="buttonClick($event)&gt;<br/>             &lt;/app-reusable&gt;`,<br/>})<br/>export class SomeComponent implements OnInit {</span><span id="d69b" class="mz ke iq nq b gy ny nv l nw nx">  constructor() {}</span><span id="7e8c" class="mz ke iq nq b gy ny nv l nw nx">  ngOnInit() {}</span><span id="5aa0" class="mz ke iq nq b gy ny nv l nw nx">  public buttonClick(e){<br/>    console.log(e);<br/>  }<br/>}</span></pre><p id="2a8b" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated"><em class="mh">快速提示！我们可以通过使用</em> <code class="fe nz oa ob nq b"><em class="mh">ng-content</em></code> <em class="mh">标签来控制“父”组件的HTML内容。阅读更多关于内容投影用</em> <code class="fe nz oa ob nq b"><em class="mh">ng-content</em></code> <em class="mh"> </em> <a class="ae kc" href="https://codecraft.tv/courses/angular/components/content-projection/" rel="noopener ugc nofollow" target="_blank"> <em class="mh">这里用</em> </a> <em class="mh">。</em></p><ul class=""><li id="d839" class="ml mm iq ld b le lz li ma lm mn lq mo lu mp ly mq mr ms mt bi translated">当我们发现自己处于多个HTML元素共享相同行为的情况时(例如，点击时某段文本被高亮显示)，我们应该考虑使用属性指令。属性指令用于改变HTML元素的行为或外观。</li></ul><h1 id="7ca1" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated"><strong class="ak">利用打字稿</strong></h1><p id="e027" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">TypeScript是JavaScript的超集，主要提供静态类型、类和接口。Angular是基于TypeScript构建的，因此，将TypeScript与Angular结合使用是一种愉快的体验。它为我们提供了先进的自动完成，快速导航和重构。拥有这样的工具不应该被认为是理所当然的。</p><p id="8a3f" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">要充分利用TypeScript:</p><ul class=""><li id="ed4c" class="ml mm iq ld b le lz li ma lm mn lq mo lu mp ly mq mr ms mt bi translated">我们应该总是使用接口来强制类实现声明的函数和属性。</li></ul><pre class="nl nm nn no gt np nq nr ns aw nt bi"><span id="16bf" class="mz ke iq nq b gy nu nv l nw nx">// .../burger.model.ts<br/>export interface Burger {<br/>  name: string;<br/>  calories: number;<br/>}</span><span id="4278" class="mz ke iq nq b gy ny nv l nw nx">// .../show-burger.component.ts<br/>this.burger: Burger;</span></pre><ul class=""><li id="0aac" class="ml mm iq ld b le lz li ma lm mn lq mo lu mp ly mq mr ms mt bi translated">我们应该利用类型联合和交集。这在处理来自API的数据时非常方便。</li></ul><pre class="nl nm nn no gt np nq nr ns aw nt bi"><span id="115f" class="mz ke iq nq b gy nu nv l nw nx">export interface Burger {<br/>  ...,<br/>  bestBefore: string | Date;<br/>}</span></pre><p id="9603" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated"><em class="mh">快速提示！我们应该总是用不同于“any”的类型定义来声明变量和常量。严格类型的代码不容易出错。</em></p><h1 id="be64" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated"><strong class="ak">使用TSLint </strong></h1><p id="dd47" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">极大地改善开发体验的一种方法是使用TSLint。这是一个静态代码分析工具，我们在软件开发中使用它来检查TypeScript代码是否符合编码规则。有了这些规则，当你做错事的时候会给你一个错误。</p><h2 id="e9ad" class="mz ke iq bd kf na nb dn kj nc nd dp kn lm ne nf kr lq ng nh kv lu ni nj kz nk bi translated"><a class="ae kc" href="https://www.npmjs.com/package/tslint-config-prettier" rel="noopener ugc nofollow" target="_blank">带TSLint更漂亮</a></h2><p id="030d" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">可以把TSLint和beauty结合起来。Prettier是一个神奇的工具，它通过解析代码并重新打印代码来加强一致的风格，并且有自己的规则。使用TSLint进行更漂亮的设置为您的应用程序打下了坚实的基础，因为您不再需要手动维护您的代码样式。Prettier负责代码格式化，TSLint处理剩下的部分。</p><h2 id="5392" class="mz ke iq bd kf na nb dn kj nc nd dp kn lm ne nf kr lq ng nh kv lu ni nj kz nk bi translated"><a class="ae kc" href="https://www.npmjs.com/package/husky" rel="noopener ugc nofollow" target="_blank">皮棉带粗</a></h2><p id="3d87" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">即使有了这些规则，也很难维持下去。在将代码投入生产之前，您很容易忘记运行这些命令，这将导致错误的结果。解决这个问题的一种方法是使用husky。Husky允许我们在提交暂存文件之前运行自定义脚本，从而保持我们的生产代码整洁有序。</p><h1 id="600d" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">RxJS以角度表示</h1><p id="4fcb" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">RxJS是一个反应式编程库，允许我们处理异步数据流。Angular与RxJS打包在一起，因此充分利用它是我们的巨大优势。</p><h2 id="bf8e" class="mz ke iq bd kf na nb dn kj nc nd dp kn lm ne nf kr lq ng nh kv lu ni nj kz nk bi translated">可管道化运算符</h2><p id="40fd" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">RxJS 5.5引入了可管道操作符。这种基于管道的可观察组合方法允许我们在每个操作符的基础上进行导入，而不是导入所有内容。可管道化操作符也有树摇动的优势，允许我们构建自己的定制操作符，而不需要扩展<code class="fe nz oa ob nq b">Observable.prototype</code>。</p><p id="0b32" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">这将帮助我们避免编写这样的代码:</p><pre class="nl nm nn no gt np nq nr ns aw nt bi"><span id="bf05" class="mz ke iq nq b gy nu nv l nw nx">...</span><span id="4f0c" class="mz ke iq nq b gy ny nv l nw nx">const name = this.loadEmployees()<br/>  .map(employee =&gt; employee.name)<br/>  .catch(error =&gt; Rx.Observable.of(null));</span></pre><p id="06d4" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">希望更像这样:</p><pre class="nl nm nn no gt np nq nr ns aw nt bi"><span id="345f" class="mz ke iq nq b gy nu nv l nw nx">const name = this.loadEmployees()<br/>    .pipe(<br/>      map(employee =&gt; employee.name),<br/>      catchError(error =&gt; of(null))<br/>    );</span></pre><h2 id="6262" class="mz ke iq bd kf na nb dn kj nc nd dp kn lm ne nf kr lq ng nh kv lu ni nj kz nk bi translated">在模板中订阅</h2><p id="b396" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">想象一下我们需要订阅多个流的情况。手动将每个属性映射到相应的值，并在组件被破坏时手动取消订阅，这将是一件令人头疼的事情。</p><p id="f7b2" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">使用异步管道，我们可以直接在模板中订阅流，而不必将结果存储在中间属性中。当组件被销毁时，订阅将终止，这使得订阅处理更容易，并有助于代码更干净。</p><p id="2363" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">这将帮助我们避免编写这样的代码:</p><pre class="nl nm nn no gt np nq nr ns aw nt bi"><span id="bdfd" class="mz ke iq nq b gy nu nv l nw nx">@Component({<br/>  ...<br/>  template: `&lt;items [items]="item"&gt;`<br/>})<br/>class AppComponent {<br/>  items: Item[];</span><span id="bc31" class="mz ke iq nq b gy ny nv l nw nx">  constructor(private itemService: ItemService) {}</span><span id="be00" class="mz ke iq nq b gy ny nv l nw nx">  ngOnInit() {<br/>    this.loadItems()<br/>      .pipe(<br/>        map(items =&gt; this.items = items;<br/>      ).subscribe();<br/>  }</span><span id="567b" class="mz ke iq nq b gy ny nv l nw nx">  loadItems(): Observable&lt;Item[]&gt; {<br/>    return this.itemService.findItems();<br/>  }<br/>}</span></pre><p id="5526" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">希望更像这样:</p><pre class="nl nm nn no gt np nq nr ns aw nt bi"><span id="55e5" class="mz ke iq nq b gy nu nv l nw nx">@Component({<br/>    ...<br/>    template: `&lt;items [items]="items$ | async"&gt;&lt;/items&gt;`<br/>})<br/>class AppComponent {<br/>  items$: Observable&lt;Item[]&gt;;<br/><br/>  constructor(private itemService: ItemService) {}</span><span id="a755" class="mz ke iq nq b gy ny nv l nw nx">  ngOnInit() {<br/>    this.items = this.loadItems();<br/>  }</span><span id="46ea" class="mz ke iq nq b gy ny nv l nw nx">  loadItems(): Observable&lt;Item[]&gt; {<br/>    return this.itemService.findItems();<br/>  }<br/>}</span></pre><h2 id="866a" class="mz ke iq bd kf na nb dn kj nc nd dp kn lm ne nf kr lq ng nh kv lu ni nj kz nk bi translated">避免内存泄漏</h2><p id="5483" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">虽然Angular在使用异步管道时负责取消订阅，但当我们自己必须这样做时，它很快就变得一团糟。未能取消订阅将导致内存泄漏，因为可观察的流是开放的。</p><p id="3e74" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">解决方案是用<code class="fe nz oa ob nq b">takeUntil</code>操作符组合我们的订阅，并使用一个在组件被破坏时发出值的subject。这将完成可观察链，导致流取消订阅。</p><p id="dec8" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">这有助于我们避免编写这样代码:</p><pre class="nl nm nn no gt np nq nr ns aw nt bi"><span id="02f4" class="mz ke iq nq b gy nu nv l nw nx">this.itemService.findItems()<br/>  .pipe(<br/>    map((items: Item[]) =&gt; items),<br/>  ).subscribe()</span></pre><p id="4430" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">希望更像这样:</p><pre class="nl nm nn no gt np nq nr ns aw nt bi"><span id="5a7b" class="mz ke iq nq b gy nu nv l nw nx">  private unsubscribe$: Subject&lt;void&gt; = new Subject&lt;void&gt;();</span><span id="b3de" class="mz ke iq nq b gy ny nv l nw nx">  ...</span><span id="d0dd" class="mz ke iq nq b gy ny nv l nw nx">   this.itemService.findItems()<br/>    .pipe(<br/>       map(value =&gt; value.item)<br/>       takeUntil(this._destroyed$)<br/>     )<br/>    .subscribe();</span><span id="0dcf" class="mz ke iq nq b gy ny nv l nw nx">  ...</span><span id="9e2c" class="mz ke iq nq b gy ny nv l nw nx">  public ngOnDestroy(): void {<br/>    this.unsubscribe$.next();<br/>    this.unsubscribe$.complete();<br/>    this.unsubscribe$.unsubscribe();<br/>  }</span></pre><p id="5164" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated"><em class="mh">快速提示！现在，我们有了另一种方法来实现这一点，这就是所谓的子链接。是沃德贝尔</em>  <em class="mh">为方便退订开发的</em> <a class="ae kc" href="https://www.npmjs.com/package/subsink" rel="noopener ugc nofollow" target="_blank"> <em class="mh">库。</em></a></p><h2 id="fdaf" class="mz ke iq bd kf na nb dn kj nc nd dp kn lm ne nf kr lq ng nh kv lu ni nj kz nk bi translated">不要使用嵌套订阅</h2><p id="c1ae" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">有些情况下，您可能需要使用来自多个可观察流的数据。在这种情况下，通常应该尽量避免所谓的嵌套订阅。嵌套订阅变得难以理解，并可能带来意想不到的副作用。我们应该使用像<code class="fe nz oa ob nq b">switchMap</code>、<code class="fe nz oa ob nq b">forkJoin</code>和<code class="fe nz oa ob nq b">combineLatest</code>这样的可链接方法来压缩我们的代码。</p><p id="dd4c" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">这将帮助我们避免编写这样的代码:</p><pre class="nl nm nn no gt np nq nr ns aw nt bi"><span id="5524" class="mz ke iq nq b gy nu nv l nw nx">this.returnsObservable1(...)<br/>  .subscribe(<br/>    success =&gt; {<br/>      this.returnsObservable2(...)<br/>        .subscribe(<br/>          success =&gt; {<br/>            this.returnsObservable3(...)<br/>              .subscribe(<br/>                success =&gt; {<br/>                   ...<br/>                },</span></pre><p id="3f16" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">希望更像这样:</p><pre class="nl nm nn no gt np nq nr ns aw nt bi"><span id="b1c6" class="mz ke iq nq b gy nu nv l nw nx">this.returnsObservable1(...)<br/>  .pipe(<br/>    flatMap(success =&gt; this.returnObservable2(...),<br/>    flatMap(success =&gt; this.returnObservable3(...)<br/>   )<br/>   .subscribe(success =&gt; {...});</span></pre><p id="159d" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated"><em class="mh">+快速提示！在处理多个流时，对于何时使用合适的操作符可能会产生混淆。我推荐看看这篇关于这个话题的文章。</em></p><h2 id="5ae4" class="mz ke iq bd kf na nb dn kj nc nd dp kn lm ne nf kr lq ng nh kv lu ni nj kz nk bi translated">RxJS中的主题</h2><p id="86f5" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">一个主体既是被观察者又是观察者。因为主题允许我们将数据发送到可观察的流中，所以人们倾向于滥用它们。这在不熟悉RxJS的开发人员中尤其流行。为了确定什么时候是使用主语的好时机，我们首先要看看什么是主语，什么不是主语。</p><p id="89de" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">是什么科目<strong class="ld ir">:</strong></p><ul class=""><li id="592d" class="ml mm iq ld b le lz li ma lm mn lq mo lu mp ly mq mr ms mt bi translated">主题是多播的，这意味着您可以在一个观察者上创建多个订阅。您可以用<code class="fe nz oa ob nq b">next()</code>方法通知列表中的所有观察者。这是RxJS中主语的主要用法。</li><li id="4b79" class="ml mm iq ld b le mu li mv lm mw lq mx lu my ly mq mr ms mt bi translated">由于主体同时实现了可观察性和观察者，它们适用于输入和输出事件。</li></ul><p id="2e66" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">哪些科目<strong class="ld ir">不是</strong>:</p><ul class=""><li id="ad1d" class="ml mm iq ld b le lz li ma lm mn lq mo lu mp ly mq mr ms mt bi translated">RxJS科目不能重复使用。不允许对已完成的主题调用<code class="fe nz oa ob nq b">next()</code>方法。</li></ul><p id="f1a1" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated"><em class="mh">快速提示！除了普通科目之外，还有一些特殊类型的科目，如异步科目、行为科目和重放科目。你可以在这里</em>  <em class="mh">阅读更多关于那些类型的科目</em> <a class="ae kc" href="https://alligator.io/rxjs/subjects/" rel="noopener ugc nofollow" target="_blank"> <em class="mh">。</em></a></p><h1 id="163a" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated"><strong class="ak">清理带有路径别名的导入</strong></h1><p id="c7b0" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">考虑这样一种情况，您需要在应用程序层次结构的底层导入一些东西。这将导致一个如下所示的导入语句:</p><pre class="nl nm nn no gt np nq nr ns aw nt bi"><span id="56d7" class="mz ke iq nq b gy nu nv l nw nx">import 'reusableComponent' from '../../../shared/components/reusable/reusable.component.ts';</span></pre><p id="9b5f" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">然后假设您需要更改这个文件的位置。然后，您必须更新使用该功能的每个文件的路径。这听起来不是很有效率吧？</p><p id="85b8" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">我们可以通过使用别名引用我们的文件来清理这些导入，如下所示:</p><pre class="nl nm nn no gt np nq nr ns aw nt bi"><span id="d387" class="mz ke iq nq b gy nu nv l nw nx">import 'reusableComponent' from '@app/shared/components/reusable.component.ts';</span></pre><p id="3937" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">为了能够做到这一点，我们需要在我们的<code class="fe nz oa ob nq b">tsconfig.json</code>文件中添加一个<code class="fe nz oa ob nq b">baseUrl</code>和期望的<code class="fe nz oa ob nq b">paths</code>:</p><pre class="nl nm nn no gt np nq nr ns aw nt bi"><span id="9c6b" class="mz ke iq nq b gy nu nv l nw nx">{<br/>  "compilerOptions": {<br/>    ...<br/>    "baseUrl": "src",<br/>    "paths": {<br/>      "@app:": ["@app/*"]<br/>    }<br/>  }<br/>}</span></pre><p id="cfa0" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">最常见的导入用例是来自核心和共享模块的组件和服务。为了避免写出这些特性的完整路径，我们将创建多个<code class="fe nz oa ob nq b">index.ts</code>-文件，导出这些特性:</p><pre class="nl nm nn no gt np nq nr ns aw nt bi"><span id="a6fb" class="mz ke iq nq b gy nu nv l nw nx">// src/app/shared/components/index.ts</span><span id="1e4e" class="mz ke iq nq b gy ny nv l nw nx">export * from './reusable/reusable.component.ts';</span><span id="248a" class="mz ke iq nq b gy ny nv l nw nx">// src/app/shared</span><span id="44fc" class="mz ke iq nq b gy ny nv l nw nx">export * from '/components';</span></pre><p id="a70e" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">我们现在可以像这样引用文件导入:</p><pre class="nl nm nn no gt np nq nr ns aw nt bi"><span id="5e2e" class="mz ke iq nq b gy nu nv l nw nx">import 'ReusableComponent' from '@app/shared/';</span></pre><p id="b258" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated"><em class="mh">快速提示！在共享模块或核心模块中使用路径别名导入服务或组件时要小心。这可能会导致“循环依赖”。在那些情况下，你需要写完整的路径。</em></p><h1 id="0bf9" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">用动画为你的应用增添趣味</h1><p id="a736" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">动画被定义为从初始状态到最终状态的过渡。它是任何现代web应用程序不可或缺的一部分。动画不仅帮助我们创建了一个伟大的用户界面，而且还使应用程序变得有趣和好玩。一个结构良好的动画可以让用户参与到应用程序中，并增强用户体验。</p><h1 id="701f" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated"><strong class="ak">懒惰加载你的模块</strong></h1><p id="f436" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">如果您使用多模块架构，延迟加载您的模块可能是个好主意。只有用于向用户显示初始内容的特征模块应该被同步加载。使用延迟加载的优点是，在用户实际访问路由之前，模块不会被加载。这有助于通过只加载我们当前展示的模块来减少总的启动时间。</p><h1 id="a0d5" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">减少最终束尺寸</h1><p id="539e" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">包的大小对应用程序的性能有很大的影响。这不仅仅是下载速度的问题，我们发送到浏览器的所有JavaScript都需要经过解析和编译才能执行。检查我们的包可能很困难，但是当我们看到膨胀来自哪里时就容易多了。<code class="fe nz oa ob nq b">webpack-bundle-analyzer</code>插件允许我们可视化生产构建的内容。</p><h1 id="7315" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated"><strong class="ak">状态管理</strong></h1><p id="edc6" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">当构建大型、复杂的应用程序时，其中有大量来自和去往数据库的信息，并且状态在多个组件之间共享，您可能会开始考虑添加状态管理库。通过使用状态管理库，您能够将应用程序状态保存在一个地方，这减少了组件之间的通信，并使您的应用程序更可预测、更易于理解。</p><h1 id="7945" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated"><strong class="ak">结论</strong></h1><p id="6e4d" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">Angular是一个非常强大的框架，有很多功能。但是如果你是这个游戏的新手，它所有不同的选项和诸如此类的东西会让你不知所措。希望通过遵循这里概述的指南，一些概念对您来说变得更加清晰。虽然没有关于如何编写干净代码的蓝图，但是这里有一些关键的要点:</p><p id="092a" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated"><strong class="ld ir">编写可读代码</strong>。专注于编写易于理解的代码。</p><p id="59d1" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated"><strong class="ld ir">关注点分离</strong>。封装和限制组件、服务和指令中的逻辑。每个文件应该只负责一个功能。</p><p id="807b" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated"><strong class="ld ir">利用打字稿</strong>。TypeScript提供了高级自动完成、导航和重构功能。拥有这样的工具不应该被认为是理所当然的。</p><p id="4b1a" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated"><strong class="ld ir">使用TSLint </strong>。TSLint检查TypeScript代码是否符合现有的编码规则。再加上漂亮和沙哑，这是一个很好的工作流程。</p><p id="00d3" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated"><strong class="ld ir"> RxJS角度</strong>。RxJS附带Angular，充分利用它对我们来说是一大优势。</p><p id="3425" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated"><strong class="ld ir">清理带有路径别名的导入</strong>。我们可以通过使用路径别名来引用我们的文件，从而大大清理我们的导入。</p><p id="176e" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated"><strong class="ld ir">懒惰加载你的模块</strong>。惰性加载通过只加载我们当前展示的模块来帮助我们减少应用程序的启动时间。</p><p id="c731" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated"><strong class="ld ir">状态管理(如有必要)</strong>。状态管理是一个很好的工具，但是应该只用于大型复杂的应用程序，其中多个组件共享相同的状态。</p><p id="8a73" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">关于此主题的其他有用资源:</p><ul class=""><li id="d907" class="ml mm iq ld b le lz li ma lm mn lq mo lu mp ly mq mr ms mt bi translated">https://medium . freecodecamp . org/best-practices-for-a-clean-and-performant-angular-application-288 e7b 39 eb6f</li><li id="9a49" class="ml mm iq ld b le mu li mv lm mw lq mx lu my ly mq mr ms mt bi translated"><a class="ae kc" href="https://code-maze.com/angular-best-practices/" rel="noopener ugc nofollow" target="_blank">https://code-maze.com/angular-best-practices/</a></li><li id="39c9" class="ml mm iq ld b le mu li mv lm mw lq mx lu my ly mq mr ms mt bi translated"><a class="ae kc" href="https://github.com/ryanmcdermott/clean-code-javascript" rel="noopener ugc nofollow" target="_blank">https://github.com/ryanmcdermott/clean-code-javascript</a></li></ul></div><div class="ab cl oc od hu oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="ij ik il im in"><p id="f211" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated"><em class="mh">我就这样了。如果您能就这些指南给我一些反馈，我将不胜感激。你有其他的推荐吗？你会做些不同的事情吗？</em></p></div></div>    
</body>
</html>