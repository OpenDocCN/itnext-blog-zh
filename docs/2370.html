<html>
<head>
<title>Laravel: The Power of Authentication [Part 3]</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Laravel:认证的力量(第3部分)</h1>
<blockquote>原文：<a href="https://itnext.io/laravel-the-power-of-authentication-part-3-d691224f3afb?source=collection_archive---------3-----------------------#2019-05-13">https://itnext.io/laravel-the-power-of-authentication-part-3-d691224f3afb?source=collection_archive---------3-----------------------#2019-05-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4a4b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">忘记使用您的控制器来手动登录您的用户，学习真正的方法！。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/7097f7ad07e7beb98c89f61c38fc6b1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5_kRBd_tIVM3qLYU"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@cytonn_photography?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Cytonn摄影</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="400f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">作为我的文章<a class="ae kv" href="https://medium.com/@DarkGhostHunter/laravel-making-your-own-passwordless-auth-guard-b7740c89adf8" rel="noopener">关于认证如何在Laravel </a>中工作的<em class="ls">的后续</em>，这里我将写一下认证机制的活动部分，比如认证中间件、防护、驱动程序、用户提供者和可认证者。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><p id="59a4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://medium.com/p/f2386eaebcad/" rel="noopener">我们理解所有的运动部件</a>，但是我们需要把它们粘在一起。在第三部分也是最后一部分，我们将通过在应用程序中注册它们并使用配置来了解如何做到这一点。</p><p id="707e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种粘合是由<code class="fe ma mb mc md b"><a class="ae kv" href="https://github.com/laravel/framework/blob/master/src/Illuminate/Auth/AuthManager.php" rel="noopener ugc nofollow" target="_blank">AuthManager</a></code>悄悄完成的，这是一种负责注册和实例化身份验证防护的服务，就像开箱即用的那些一样，它使用配置文件来知道到底在做什么，否则它将绕着圈子运行。</p><h1 id="e0cc" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated">了解配置</h1><p id="f6b0" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">该配置以一种简单的方式工作:您注册一个防护名称，比如“web ”,然后设置防护驱动程序和将与该防护一起使用的提供者(不是用户提供者),默认情况下分别是“session”和“users”。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/938a6043ea2a1f2bd2aab0a44c8f9c16.png" data-original-src="https://miro.medium.com/v2/resize:fit:908/format:webp/1*fForDQ_ZQxneC6J6UE4e5g.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">config/auth.php</figcaption></figure><p id="78ec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，在您的代码中，您可以检查一个用户是否通过其名称<code class="fe ma mb mc md b">Auth::guard('web')-&gt;check()</code>被验证进入一个特定的守卫。</p><p id="8f71" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，配置需要一个缺省值，当您没有在代码中发出保护名时，将会使用这个缺省值。幸运的是，这是在第一个键中设置的，对于简单的应用程序来说很好。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/621e0da964eeae7e85119665a7bf0a6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:768/format:webp/1*kbBBGBDki4JiNtExiAemWQ.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">config/auth.php</figcaption></figure><p id="2524" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">回到防护配置，提供者在这个配置文件中注册。这个提供者键的目的之一是封装真正的用户提供者，并将配置数组传递给它。例如，<code class="fe ma mb mc md b">users</code>提供者使用<code class="fe ma mb mc md b">eloquent</code>作为用户提供者，它接收整个密钥配置，其中包含<code class="fe ma mb mc md b">model</code>密钥，该密钥将用于知道从数据库中检索哪个模型。</p><p id="fc3a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">没有必要为您的其他模型创建另一个身份验证机制或提供程序；您可以在这里更改它，这样就设置好了。</p><h1 id="7568" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated">注册自定义身份验证防护驱动程序和用户提供程序</h1><p id="7e67" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">假设我们已经创建了一种方法，通过请求中的特殊头来验证用户，并从外部API中提取用户。让我们称它们为<code class="fe ma mb mc md b">HeaderGuard</code>，它实际上是守卫驱动程序，以及<code class="fe ma mb mc md b">ApiUserProvider</code>，它将从外部API拉用户。</p><p id="eb01" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们已经把它们放在代码中的某个地方了，我们需要把它们注册到应用程序中，否则它永远不知道什么时候使用它。关于<a class="ae kv" href="https://laravel.com/docs/5.8/authentication#adding-custom-guards" rel="noopener ugc nofollow" target="_blank">添加新的保护驱动</a>和<a class="ae kv" href="https://laravel.com/docs/5.8/authentication#adding-custom-user-providers" rel="noopener ugc nofollow" target="_blank">注册自定义用户提供者</a>的文档非常简单。</p><h2 id="1491" class="nd mf iq bd mg ne nf dn mk ng nh dp mo lf ni nj mq lj nk nl ms ln nm nn mu no bi translated">注册割台防护装置</h2><p id="ccb7" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">在<a class="ae kv" href="https://github.com/laravel/laravel/blob/master/app/Providers/AuthServiceProvider.php" rel="noopener ugc nofollow" target="_blank">我们的</a> <code class="fe ma mb mc md b"><a class="ae kv" href="https://github.com/laravel/laravel/blob/master/app/Providers/AuthServiceProvider.php" rel="noopener ugc nofollow" target="_blank">AuthServiceProvider</a></code>中，我们将使用服务容器注册我们的<code class="fe ma mb mc md b">HeaderGuard</code>，而不是手动实例化它——你可以这样做，但我认为这种方式更方便。这将简化我们注入任何我们的安全驱动程序可以使用的服务的工作，例如，请求和各自的用户提供者。</p><p id="5ef4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果有一天或下一分钟，我们想在我们的防护中添加一个服务，比如缓存管理器，我们只需简单地改变我们防护中的<code class="fe ma mb mc md b">_construct</code>方法参数，然后就到此为止。</p><pre class="kg kh ki kj gt np md nq nr aw ns bi"><span id="9416" class="nd mf iq md b gy nt nu l nv nw">Auth::extend('header', function ($app, $name, array $config) {<br/>    return $app-&gt;make(\App\Auth\HeaderGuard::class, [        <br/>        <!-- -->'name' =&gt; $name,<br/>        'config' =&gt; $config,<br/>        'provider' =&gt; $app['auth']-&gt;createUserProvider(<br/>            $config['provider'] ?? null<br/>        )<br/>    ]);<br/>});</span></pre><p id="cfff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意，我们手动告诉服务容器使用AuthManager的<code class="fe ma mb mc md b">createUserProvider</code>来解析我们的<code class="fe ma mb mc md b">HeaderGuard</code>中的<code class="fe ma mb mc md b">$provider</code>。该方法根据给定的名称创建用户提供程序，如果没有设置名称，它将使用默认名称。</p><p id="17bb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们已经有了我们的防护驱动程序，我们可以通过在我们的配置文件中编写<code class="fe ma mb mc md b">header</code>作为我们的“驱动程序”来使用它，但是它仍然会从数据库中获取用户，因为它使用<code class="fe ma mb mc md b">users</code>提供程序，并且它使用<code class="fe ma mb mc md b">eloquent</code>用户提供程序从数据库中获取用户。我们不想那样！</p><h2 id="9891" class="nd mf iq bd mg ne nf dn mk ng nh dp mo lf ni nj mq lj nk nl ms ln nm nn mu no bi translated">注册用户提供者</h2><p id="9ff1" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">现在我们需要注册我们的<code class="fe ma mb mc md b">ApiUserProvider</code>。这可以通过添加以下内容来实现:</p><pre class="kg kh ki kj gt np md nq nr aw ns bi"><span id="4eac" class="nd mf iq md b gy nt nu l nv nw">Auth::<!-- -->provider('external-api', function ($app, $config) {<br/>    return $app-&gt;make(\App\Auth\ApiUserProvider::class, [<br/>        'config' =&gt; $config,<br/>    ]);<br/>});</span></pre><p id="736a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这段代码将把<code class="fe ma mb mc md b">external-api</code>用户提供者附加到返回<code class="fe ma mb mc md b">ApiUserProvider</code>的闭包上，这个闭包也由服务容器解析。</p><p id="cd0e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">顺便说一下，这些闭包将被注册在一个名为<code class="fe ma mb mc md b">customCreators</code>和<code class="fe ma mb mc md b">customProviderCreators</code>的数组中，该数组位于<a class="ae kv" href="https://github.com/laravel/framework/blob/master/src/Illuminate/Auth/AuthManager.php" rel="noopener ugc nofollow" target="_blank"/><code class="fe ma mb mc md b"><a class="ae kv" href="https://github.com/laravel/framework/blob/master/src/Illuminate/Auth/AuthManager.php" rel="noopener ugc nofollow" target="_blank">AuthManager</a></code><a class="ae kv" href="https://github.com/laravel/framework/blob/master/src/Illuminate/Auth/AuthManager.php" rel="noopener ugc nofollow" target="_blank">类</a>中。</p><p id="c3fa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就个人而言，我喜欢一种不太直接的注册服务的方式(除非必要)。在本例中，我“优化”了新的安全驱动程序和用户提供程序的注册，方法是在服务解决之前<a class="ae kv" href="https://laravel.com/docs/5.8/container#container-events" rel="noopener ugc nofollow" target="_blank">推送这些注册</a>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="cbed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我没有在每次应用程序启动时解析<code class="fe ma mb mc md b">AuthManager</code>服务，而是使用服务提供者的<code class="fe ma mb mc md b">register()</code>方法。在这里，我告诉服务容器只在需要使用认证机制时添加我们的驱动程序和用户提供者。</p><p id="d857" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这样就不需要像在公共路由中那样调用认证中间件；我们可以跳过实例化Auth Manager和每个使用它的类。酷，<em class="ls">玛尔性能</em>！</p><h2 id="3a73" class="nd mf iq bd mg ne nf dn mk ng nh dp mo lf ni nj mq lj nk nl ms ln nm nn mu no bi translated">把两者都当作守卫</h2><p id="c33e" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">现在这些都设置好了，我们只需要在配置中添加它们。我们可以只改变驱动程序和现有的警卫提供者，或命名我们自己的。我将选择后者，并且不将if设置为缺省值，因为我将对其他路由集使用该保护。</p><pre class="kg kh ki kj gt np md nq nr aw ns bi"><span id="e7c6" class="nd mf iq md b gy nt nu l nv nw">'guards' =&gt; [</span><span id="cea9" class="nd mf iq md b gy nz nu l nv nw">    // ...</span><span id="fc8a" class="nd mf iq md b gy nz nu l nv nw">    'remote' =&gt; [<br/>        'driver' =&gt; 'header',<br/>        'provider' =&gt; 'external-provider',<br/>    ],</span><span id="c32e" class="nd mf iq md b gy nz nu l nv nw">    'providers' =&gt; [</span><span id="a975" class="nd mf iq md b gy nz nu l nv nw">        // ...</span><span id="dac5" class="nd mf iq md b gy nz nu l nv nw">        'external-provider' =&gt; [<br/>            'driver' =&gt; 'external-api',<br/>        ],</span><span id="443e" class="nd mf iq md b gy nz nu l nv nw">    ],</span><span id="c172" class="nd mf iq md b gy nz nu l nv nw">],</span></pre><p id="73ea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，一切都准备好了，用你这样的警惕:</p><pre class="kg kh ki kj gt np md nq nr aw ns bi"><span id="eaff" class="nd mf iq md b gy nt nu l nv nw">Route::prefix('external')<br/>    -&gt;middleware('auth:remote')<br/>    -&gt;group(function() {</span><span id="ae80" class="nd mf iq md b gy nz nu l nv nw">        Route::get('/'-&gt;uses(function () {<br/>            // ...<br/>        });</span><span id="0f23" class="nd mf iq md b gy nz nu l nv nw">        Route::get('dashboard')-&gt;uses(function () {<br/>            // ...<br/>        });</span><span id="040a" class="nd mf iq md b gy nz nu l nv nw">});</span></pre></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><p id="d7ab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">差不多就是这样。同样，试图重新发明轮子并在控制器中创建自己的认证逻辑是一种糟糕的做法。使用这些移动的齿轮，你就不需要在你的代码中做更多的改变。<a class="ae kv" href="https://www.youtube.com/watch?v=4u0NRgMyzEM" rel="noopener ugc nofollow" target="_blank">这样就可以了</a>。</p><p id="7050" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">希望你已经学到了一些东西，可以用在你未来的项目中。下次见。</p></div></div>    
</body>
</html>