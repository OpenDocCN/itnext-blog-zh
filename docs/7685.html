<html>
<head>
<title>Angular and SPAs - Caching for the REAL need for speed?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">角度缓存和SPAs缓存是为了真正的速度需求吗？</h1>
<blockquote>原文：<a href="https://itnext.io/angular-and-spas-caching-for-the-real-need-for-speed-d2ca1b1227f8?source=collection_archive---------1-----------------------#2022-12-20">https://itnext.io/angular-and-spas-caching-for-the-real-need-for-speed-d2ca1b1227f8?source=collection_archive---------1-----------------------#2022-12-20</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><h1 id="84f4" class="jo jp ir bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">绩效需要理解绩效</h1><figure class="kn ko kp kq gu kr gi gj paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gi gj km"><img src="../Images/ce31d529db61f7f0f4384a233207c5c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*toYA7OnJvfzMrPilIYwnDw.jpeg"/></div></div><figcaption class="ky kz gk gi gj la lb bd b be z dk translated">👍耶！更快…</figcaption></figure><p id="28cf" class="pw-post-body-paragraph lc ld ir le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ik bi translated"><strong class="le is">警告</strong>:这篇文章非常固执己见。你可能不同意我的许多欣赏，这绝对没关系。</p><p id="80b0" class="pw-post-body-paragraph lc ld ir le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ik bi translated">大多数前端框架教程会教你如何使用它们，通常会跳过一些面对现实世界挑战时不得不考虑的事情。性能是其中的一个话题，通常我们都知道web应用程序的运行速度有多快。<br/>当现实世界的应用程序达到重要的规模和复杂性时，性能是必须的<strong class="le is"/>，客户<strong class="le is">必须</strong>在浏览我们的web应用程序时拥有良好的性能体验。</p><p id="dffd" class="pw-post-body-paragraph lc ld ir le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ik bi translated">在本文中，我将写一些可能影响您的web应用程序性能/速度的事情，其中大部分都与Angular SPA高度相关，但是您可以对本文进行推断，并尝试将这些概念应用到您喜欢的SPA框架中。</p><h1 id="5dfb" class="jo jp ir bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">是什么造就了水疗表演？</h1><p id="c46a" class="pw-post-body-paragraph lc ld ir le b lf ma lh li lj mb ll lm ln mc lp lq lr md lt lu lv me lx ly lz ik bi translated">首先，我们来思考一下与app无关的事情:</p><ul class=""><li id="40ee" class="mf mg ir le b lf lg lj lk ln mh lr mi lv mj lz mk ml mm mn bi translated">快速用户计算机(大量内存和处理器)</li><li id="3e24" class="mf mg ir le b lf mo lj mp ln mq lr mr lv ms lz mk ml mm mn bi translated">快速服务器(大量内存和处理器)</li><li id="1a75" class="mf mg ir le b lf mo lj mp ln mq lr mr lv ms lz mk ml mm mn bi translated">高网络速度</li><li id="9a6d" class="mf mg ir le b lf mo lj mp ln mq lr mr lv ms lz mk ml mm mn bi translated"><em class="mt">“我在localhost上的测试:4200跑得超快”</em> 🤌 c 'mmon…</li></ul><p id="755a" class="pw-post-body-paragraph lc ld ir le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ik bi translated">好了，，看到这里的问题了吗？如果你的绩效评估只考虑这些因素，你就错过了一些要点。</p><p id="1003" class="pw-post-body-paragraph lc ld ir le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ik bi translated">再补充一些app相关的东西:</p><ol class=""><li id="10ca" class="mf mg ir le b lf lg lj lk ln mh lr mi lv mj lz mu ml mm mn bi translated"><a class="ae mv" href="https://angular.io/guide/lazy-loading-ngmodules" rel="noopener ugc nofollow" target="_blank">惰性加载模块</a></li><li id="0116" class="mf mg ir le b lf mo lj mp ln mq lr mr lv ms lz mu ml mm mn bi translated">任何UX技巧，如无限分页，或图像或不可见内容的交集观察者</li><li id="fec4" class="mf mg ir le b lf mo lj mp ln mq lr mr lv ms lz mu ml mm mn bi translated">小型CSS包(例如使用<a class="ae mv" href="https://tailwindcss.com/" rel="noopener ugc nofollow" target="_blank">顺风CSS </a></li><li id="6958" class="mf mg ir le b lf mo lj mp ln mq lr mr lv ms lz mu ml mm mn bi translated">小型API操作(在后端)</li><li id="8df0" class="mf mg ir le b lf mo lj mp ln mq lr mr lv ms lz mu ml mm mn bi translated"><a class="ae mv" href="https://dev.to/this-is-angular/how-caching-data-in-angular-with-rxjs-27mj" rel="noopener ugc nofollow" target="_blank">缓存SPA上的可缓存API请求</a></li></ol><p id="fd60" class="pw-post-body-paragraph lc ld ir le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ik bi translated">以及如何破坏您的应用速度和性能提升:</p><ol class=""><li id="efaa" class="mf mg ir le b lf lg lj lk ln mh lr mi lv mj lz mu ml mm mn bi translated">你的模块太大(或者内部不好，比如<code class="fe mw mx my mz b">import * from library;</code>)。不管你有多懒，它们还是很大，或者发育得很糟糕。</li><li id="410d" class="mf mg ir le b lf mo lj mp ln mq lr mr lv ms lz mu ml mm mn bi translated">超过5MB图像的交叉点观察器(已经看到…)，或者超过40个并发API请求是不好的。</li><li id="756d" class="mf mg ir le b lf mo lj mp ln mq lr mr lv ms lz mu ml mm mn bi translated">你可能认为顺风会导致很小的CSS包。如果您在所有SCSS文件中使用<code class="fe mw mx my mz b">@apply</code>，将无法正常工作。(在你的HTML模板中，顺风会变得非常冗长，但是相信我，一旦编译完成，最终的<code class="fe mw mx my mz b">styles.css</code>文件会非常小)</li><li id="8876" class="mf mg ir le b lf mo lj mp ln mq lr mr lv ms lz mu ml mm mn bi translated">API操作可以很小，但也应该快速响应。</li><li id="4b28" class="mf mg ir le b lf mo lj mp ln mq lr mr lv ms lz mu ml mm mn bi translated">缓存所有的东西！</li></ol><figure class="kn ko kp kq gu kr gi gj paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gi gj na"><img src="../Images/06da22c0c7faa7b08e711a5d70e3fc00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7EN2HBLdbvTkQWlIbaIcaA.jpeg"/></div></div><figcaption class="ky kz gk gi gj la lb bd b be z dk translated">没那么快，快</figcaption></figure><p id="dadd" class="pw-post-body-paragraph lc ld ir le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ik bi translated">我有意跳过一些通常有助于性能追求的其他好的开发实践。</p></div><div class="ab cl nb nc hv nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ik il im in io"><h1 id="da5e" class="jo jp ir bd jq jr ni jt ju jv nj jx jy jz nk kb kc kd nl kf kg kh nm kj kk kl bi translated">简要了解棱角造型</h1><p id="9898" class="pw-post-body-paragraph lc ld ir le b lf ma lh li lj mb ll lm ln mc lp lq lr md lt lu lv me lx ly lz ik bi translated">大多数典型的角度构建会导致:</p><ul class=""><li id="2d3d" class="mf mg ir le b lf lg lj lk ln mh lr mi lv mj lz mk ml mm mn bi translated">单个<code class="fe mw mx my mz b">index.html</code>文件</li><li id="520f" class="mf mg ir le b lf mo lj mp ln mq lr mr lv ms lz mk ml mm mn bi translated">单个散列的<code class="fe mw mx my mz b">styles.css</code>文件(类似于<code class="fe mw mx my mz b">styles.1234abcdrandomhash.css</code>)</li><li id="d7d0" class="mf mg ir le b lf mo lj mp ln mq lr mr lv ms lz mk ml mm mn bi translated">许多“<em class="mt">散列的</em>”。<em class="mt"> js </em>文件</li><li id="1105" class="mf mg ir le b lf mo lj mp ln mq lr mr lv ms lz mk ml mm mn bi translated">一个<em class="mt">资产</em>文件夹</li></ul><figure class="kn ko kp kq gu kr gi gj paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gi gj nn"><img src="../Images/5718fea07109f879f5eafd924a3994ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lWvR-KJuvsBAiSG5hykOPA.jpeg"/></div></div><figcaption class="ky kz gk gi gj la lb bd b be z dk translated">真实管线的角度构建示例</figcaption></figure><p id="b989" class="pw-post-body-paragraph lc ld ir le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ik bi translated">文件名中的<em class="mt">散列</em>意味着<em class="mt">缓存破坏</em>，这意味着一个特定的文件可以被另一个具有另一个散列的文件替换。也许该文件将被缓存在浏览器中，或者从服务器获得<em class="mt"> cache-control </em>头，但是它可能被另一个文件替换，具有另一个散列。例如:</p><ul class=""><li id="9c1c" class="mf mg ir le b lf lg lj lk ln mh lr mi lv mj lz mk ml mm mn bi translated"><strong class="le is">第一次编译</strong> : <code class="fe mw mx my mz b">user.modules.ts</code> - &gt;编译到- &gt; <code class="fe mw mx my mz b">105.123bcdsomeuglyhash.js</code></li><li id="f6f7" class="mf mg ir le b lf mo lj mp ln mq lr mr lv ms lz mk ml mm mn bi translated"><strong class="le is">第二次编译</strong> : <code class="fe mw mx my mz b">user.modules.ts</code> - &gt;编译到-&gt;-<code class="fe mw mx my mz b">207.345qweanotheruglyhash.js</code></li><li id="d524" class="mf mg ir le b lf mo lj mp ln mq lr mr lv ms lz mk ml mm mn bi">…</li><li id="9d9a" class="mf mg ir le b lf mo lj mp ln mq lr mr lv ms lz mk ml mm mn bi translated"><strong class="le is">第n次编译</strong> : <code class="fe mw mx my mz b">user.modules.ts</code> - &gt;编译到-&gt;-<code class="fe mw mx my mz b">654.978poisomeotheruglyhash.js</code></li></ul><p id="3399" class="pw-post-body-paragraph lc ld ir le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ik bi translated">还有一些其他的选项允许Angular编译时不需要散列或者保持一个用户友好的名字。为此，你将不得不阅读一些<a class="ae mv" href="https://angular.io/guide/workspace-config" rel="noopener ugc nofollow" target="_blank">角度文档</a>并多次拧紧你的<code class="fe mw mx my mz b">angular.json</code>文件(我通常几乎每天都这样做😥).</p></div><div class="ab cl nb nc hv nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ik il im in io"><h1 id="fa29" class="jo jp ir bd jq jr ni jt ju jv nj jx jy jz nk kb kc kd nl kf kg kh nm kj kk kl bi translated">缓存还是不缓存，这是个问题…</h1><p id="c760" class="pw-post-body-paragraph lc ld ir le b lf ma lh li lj mb ll lm ln mc lp lq lr md lt lu lv me lx ly lz ik bi translated"><code class="fe mw mx my mz b">index.html</code>没有哈希，这是在服务器上部署Angular应用时的关键知识。索引文件保留它的文件名，所以如果这个文件以任何方式被缓存，它将检索缓存的内容。</p><ul class=""><li id="87c5" class="mf mg ir le b lf lg lj lk ln mh lr mi lv mj lz mk ml mm mn bi translated"><strong class="le is"><em class="mt"/></strong>:从任何缓存中检索文件都非常快</li><li id="2738" class="mf mg ir le b lf mo lj mp ln mq lr mr lv ms lz mk ml mm mn bi translated"><strong class="le is"> <em class="mt">真正不好的事情</em> </strong>:文件内容可能已经过时，所以很多app脚本不会存在，而且肯定会因为编译app时产生的哈希不同而加载失败。</li></ul><p id="ed6b" class="pw-post-body-paragraph lc ld ir le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ik bi translated">你所有的速度提升都可能以一个无法运行的网络应用程序告终。不太好。</p><p id="d6d1" class="pw-post-body-paragraph lc ld ir le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ik bi translated">通常的建议是<code class="fe mw mx my mz b">index.html</code>文件不需要以任何方式从服务器缓存。这意味着从服务器提供带有这些头的<code class="fe mw mx my mz b">index.html</code>文件:</p><pre class="kn ko kp kq gu no mz np bn nq nr bi"><span id="f150" class="ns jp ir mz b be nt nu l nv nw">Cache-Control: no-cache, no-store, must-revalidate<br/>Expires: 0<br/>Pragma: no-cache</span></pre><figure class="kn ko kp kq gu kr gi gj paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gi gj nx"><img src="../Images/58c5425692d14018b07b49187f88207c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rhyxq4oUjFIqyVrG9UgHJA.jpeg"/></div></div><figcaption class="ky kz gk gi gj la lb bd b be z dk translated">关于如何在Express应用程序上设置标题的示例</figcaption></figure><p id="dca4" class="pw-post-body-paragraph lc ld ir le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ik bi translated">缓存<code class="fe mw mx my mz b">index.html</code>文件只会导致头痛、脚本加载错误(HTTP状态<em class="mt"> 404 </em>文件未找到)和可怕的UX。</p><blockquote class="ny nz oa"><p id="8b99" class="lc ld mt le b lf lg lh li lj lk ll lm ob lo lp lq oc ls lt lu od lw lx ly lz ik bi translated">但是index.html文件是一个静态资源，静态资源必须被缓存。不是吗？</p></blockquote><p id="9771" class="pw-post-body-paragraph lc ld ir le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ik bi translated">静态资源，如图像或其他一些第三方脚本，可能会包括在网站上(并没有在编译散列)，是的，同意。静态HTML文件的内容是不变的(如联系表格页面)，同意。<br/>但是在这种情况下(或者任何带有某种文件哈希逻辑的编译SPA)，我们可以争论它是好是坏。</p><h2 id="024d" class="oe jp ir bd jq of og dn ju oh oi dp jy ln oj ok kc lr ol om kg lv on oo kk op bi translated">我们如何解决<code class="fe mw mx my mz b">index.html</code>缓存问题？(我仍然希望将其缓存为静态资源)</h2><p id="b51c" class="pw-post-body-paragraph lc ld ir le b lf ma lh li lj mb ll lm ln mc lp lq lr md lt lu lv me lx ly lz ik bi translated">唯一的方法是物理存储每一个旧的散列文件(包括<em class="mt"> javascript </em>和<em class="mt"> css </em>)，以确保即使是从某处加载的旧的和过时的<code class="fe mw mx my mz b">index.html</code>文件，也会加载它需要的每一个旧的和过时的<em class="mt"> javascript </em>和<em class="mt"> css </em>文件。</p><h2 id="b814" class="oe jp ir bd jq of og dn ju oh oi dp jy ln oj ok kc lr ol om kg lv on oo kk op bi translated">大问题</h2><p id="666b" class="pw-post-body-paragraph lc ld ir le b lf ma lh li lj mb ll lm ln mc lp lq lr md lt lu lv me lx ly lz ik bi translated">每次部署应用程序时，它的编译都会添加一堆新文件，因为<strong class="le is">编译之间的哈希永远不会相同</strong>。当然，<code class="fe mw mx my mz b">index.html</code>文件和任何其他静态非散列文件将被替换，但你的应用程序肯定会重复一些模块，文件名不同，但仍然是同一个模块。<br/>几个部署之后，你会拖着大量的<em class="mt">宇宙垃圾</em>，如果你没有一个重置策略，为了删除不用的和/或过时的文件，你会很快填满你的硬盘。</p><p id="8464" class="pw-post-body-paragraph lc ld ir le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ik bi translated">好吧，硬盘不是问题，因为“<em class="mt">存储很便宜</em>”。我们来抛几个数字:</p><ul class=""><li id="2d69" class="mf mg ir le b lf lg lj lk ln mh lr mi lv mj lz mk ml mm mn bi translated">20 MB左右大小的应用程序(真实世界的应用程序，还记得吗？)</li><li id="ad96" class="mf mg ir le b lf mo lj mp ln mq lr mr lv ms lz mk ml mm mn bi translated">每天1次部署(每月- 20次部署，仅考虑工作日)</li></ul><figure class="kn ko kp kq gu kr gi gj paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gi gj oq"><img src="../Images/82d3ddbe1f4833fa05d124336ca5d797.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NhZ8Ts1Xe0SlreW2Ljzo6g.png"/></div></div><figcaption class="ky kz gk gi gj la lb bd b be z dk translated">错过了80年代的Peavey T-40低音</figcaption></figure><p id="52c6" class="pw-post-body-paragraph lc ld ir le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ik bi translated">为你的后端考虑<em class="mt"> node_modules </em>(真实世界的应用，记得吗？)，几个月后，您的应用程序就可以吃掉一个<em class="mt">起始层部署实例</em>中的所有空间。宇宙垃圾是一个问题。</p><p id="4c02" class="pw-post-body-paragraph lc ld ir le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ik bi translated">所以…，缓存是好的，但是你必须知道缓存什么，以及如何缓存。</p><p id="938a" class="pw-post-body-paragraph lc ld ir le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ik bi translated">曾经有一段时间，所有的开发人员都在网上跑来跑去，只是为了展示谁跑得最快。有一个不受欢迎的库叫做<strong class="le is"><em class="mt">basket . js</em></strong>(<a class="ae mv" href="https://github.com/addyosmani/basket.js" rel="noopener ugc nofollow" target="_blank">https://github.com/addyosmani/basket.js</a>)，在对性能的永恒追求中，旨在改进它将所有脚本存储在<em class="mt"> localstorage </em>中。好主意，直到你试图在隐姓埋名模式导航。</p><h2 id="6aa5" class="oe jp ir bd jq of og dn ju oh oi dp jy ln oj ok kc lr ol om kg lv on oo kk op bi translated">服务人员呢？</h2><p id="0052" class="pw-post-body-paragraph lc ld ir le b lf ma lh li lj mb ll lm ln mc lp lq lr md lt lu lv me lx ly lz ik bi translated">和缓存我们的<code class="fe mw mx my mz b">index.html</code>文件一样的问题。你可以做一个很好的配置来定义一个性能标准。但是如果你的网络应用不是以前的<strong class="le is"> <em class="mt"> PWA </em> </strong>，你将会试图加载旧的脚本，最糟糕的是，由于你的应用不能自我更新，这将是一个真正的<em class="mt"> PITA </em>试图保持你的应用没有错误，由于脚本没有找到错误。对你的用户体验来说很糟糕。去过那里，做过那件事，遭受过…</p></div><div class="ab cl nb nc hv nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ik il im in io"><h1 id="4f86" class="jo jp ir bd jq jr ni jt ju jv nj jx jy jz nk kb kc kd nl kf kg kh nm kj kk kl bi translated">这个特定的应用程序是否需要缓存以提高速度？</h1><p id="e305" class="pw-post-body-paragraph lc ld ir le b lf ma lh li lj mb ll lm ln mc lp lq lr md lt lu lv me lx ly lz ik bi translated">在回答这个问题之前，我们先回答另一个问题:</p><p id="0351" class="pw-post-body-paragraph lc ld ir le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ik bi translated">我们正在开发什么类型的应用程序？T11】</p><ul class=""><li id="2801" class="mf mg ir le b lf lg lj lk ln mh lr mi lv mj lz mk ml mm mn bi translated">是<strong class="le is">网站</strong>吗？</li><li id="ef33" class="mf mg ir le b lf mo lj mp ln mq lr mr lv ms lz mk ml mm mn bi translated">是<strong class="le is">公共</strong> web应用吗？(公共的意思是不需要用户注册)</li><li id="f039" class="mf mg ir le b lf mo lj mp ln mq lr mr lv ms lz mk ml mm mn bi translated">是<strong class="le is">私有</strong>应用吗？(需要用户注册，或者主应用入口是一个<em class="mt">登录屏幕</em>)</li></ul><p id="268d" class="pw-post-body-paragraph lc ld ir le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ik bi translated"><strong class="le is"> <em class="mt">边问</em> </strong>:这是一款在SEO上占点便宜还是高<a class="ae mv" href="https://www.webpagetest.org/" rel="noopener ugc nofollow" target="_blank">网页速度</a> / <a class="ae mv" href="https://gtmetrix.com/" rel="noopener ugc nofollow" target="_blank"> GT Metrix </a> / <a class="ae mv" href="https://pagespeed.web.dev/" rel="noopener ugc nofollow" target="_blank">灯塔</a>排名的app？</p><p id="e35e" class="pw-post-body-paragraph lc ld ir le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ik bi translated">几个事实:</p><ul class=""><li id="6b56" class="mf mg ir le b lf lg lj lk ln mh lr mi lv mj lz mk ml mm mn bi translated">用户输入(打字、滚动、点击)平均需要大约300毫秒(100毫秒被理解为瞬时<a class="ae mv" href="https://www.nngroup.com/articles/response-times-3-important-limits/" rel="noopener ugc nofollow" target="_blank">)</a></li><li id="152c" class="mf mg ir le b lf mo lj mp ln mq lr mr lv ms lz mk ml mm mn bi translated">普通用户每分钟阅读230个单词</li><li id="81e8" class="mf mg ir le b lf mo lj mp ln mq lr mr lv ms lz mk ml mm mn bi translated">Angular(和大多数SPA框架)使用<em class="mt">空闲时间</em>来下载任何延迟的脚本</li><li id="4c8a" class="mf mg ir le b lf mo lj mp ln mq lr mr lv ms lz mk ml mm mn bi translated">只有QA用户(或者你自己开发团队中的人)倾向于在页面完全加载之前进行极快的导航、滚动或点击。所以这种行为<em class="mt">当然可以发生</em>，但不是以你预期的频率。</li></ul><p id="a7d2" class="pw-post-body-paragraph lc ld ir le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ik bi translated">混合两个列表:</p><ul class=""><li id="dea1" class="mf mg ir le b lf lg lj lk ln mh lr mi lv mj lz mk ml mm mn bi translated"><strong class="le is"> <em class="mt">网站</em> </strong>？耶！，绝对，全部缓存，或者大部分缓存。搜索引擎优化，性能，用户界面UX，速度排名，一切都意味着改善。</li><li id="ae1b" class="mf mg ir le b lf mo lj mp ln mq lr mr lv ms lz mk ml mm mn bi translated"><strong class="le is"> <em class="mt">公共网络应用</em> </strong>？耶！主要是因为它像一个网站，但有“<em class="mt">类似应用程序的功能</em>”。</li><li id="88b0" class="mf mg ir le b lf mo lj mp ln mq lr mr lv ms lz mk ml mm mn bi translated"><strong class="le is"> <em class="mt">私人应用</em> </strong>？这一点我们可以争论。我会说缓存没关系，因为没有搜索引擎优化或页面速度的损失。<strong class="le is">这里真正重要的是最终用户获得最新、更新版本的已部署应用。</strong></li></ul><figure class="kn ko kp kq gu kr gi gj paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gi gj na"><img src="../Images/8993c4176babd72f31eae24e6a76be72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TuII9kqb8RNVg-f_zicK9A.jpeg"/></div></div><figcaption class="ky kz gk gi gj la lb bd b be z dk translated">20%必须更快，永远…</figcaption></figure><p id="ee78" class="pw-post-body-paragraph lc ld ir le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ik bi translated">那么…，<strong class="le is">由于缓存，加载时间增加了200毫秒，这真的是性能提升吗？我的意思是除了你自己说“T2”之外。站点加载快200ms】”？这取决于应用程序，以及你的受众；<strong class="le is"> 80%不会注意到，20%会一直要求更快的速度</strong>。</strong></p><h1 id="8a61" class="jo jp ir bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">私有应用的最佳无缓存用户体验</h1><p id="c5ee" class="pw-post-body-paragraph lc ld ir le b lf ma lh li lj mb ll lm ln mc lp lq lr md lt lu lv me lx ly lz ik bi translated">感谢阅读到目前为止。不知道这是否符合你的要求，但也许你应该缓存应用程序(我知道，不是无缓存…)，至少是你的脚本。事情是这样的，作为一个私人应用程序，没有灯塔(或类似的)压力，你可以跳过懒惰加载，预加载所有模块。通过这种方式，用户在浏览应用程序时几乎感觉不到过渡，所有的模块都已经加载好了。</p><h2 id="e41d" class="oe jp ir bd jq of og dn ju oh oi dp jy ln oj ok kc lr ol om kg lv on oo kk op bi translated">如何做到这一点？</h2><pre class="kn ko kp kq gu no mz np bn nq nr bi"><span id="c5d5" class="ns jp ir mz b be nt nu l nv nw">import { RouterModule, Routes, PreloadAllModules } from ‘@angular/router’; <br/>@NgModule({ <br/> imports: [ <br/> RouterModule.forRoot(routes, { preloadingStrategy: PreloadAllModules }) <br/> ], <br/> exports: [RouterModule] <br/>}) <br/>export class AppRoutingModule {}</span></pre><p id="9bb0" class="pw-post-body-paragraph lc ld ir le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ik bi translated">事实是，这最后一条并不是宝贵的建议，但它可能会缓解你的灵魂之火。</p><p id="cdd5" class="pw-post-body-paragraph lc ld ir le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ik bi translated">缓存本身并不能让你的web应用程序快到Lighthouse分，而且有这么多的考虑因素，你可能最终会问自己是否值得用头撞键盘或所有的努力。</p></div></div>    
</body>
</html>