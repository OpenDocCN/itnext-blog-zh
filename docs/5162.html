<html>
<head>
<title>User Configurable Feature Design and Data Architecture</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用户可配置的特征设计和数据架构</h1>
<blockquote>原文：<a href="https://itnext.io/user-configurable-feature-design-and-data-architecture-f9041e8e5e44?source=collection_archive---------4-----------------------#2020-12-28">https://itnext.io/user-configurable-feature-design-and-data-architecture-f9041e8e5e44?source=collection_archive---------4-----------------------#2020-12-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/2d74ea32672cf1bbb8653a9e9025e6c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*0-dy5J-Uud5sqd_Lnw2ZKQ.gif"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">giphy.com</figcaption></figure><p id="7604" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">随着2020年接近尾声，我有时间回顾我曾有机会以某种身份参与的十几个项目。我发现最明显的相似之处是许多项目都有某种形式的数据模式，这些数据模式是围绕用户定义的字段、动态屏幕呈现和/或两者的某种组合而设计的。我将用户可配置的设计描述为驱动逻辑的一组数据，在大多数情况下，可以在以后更改，而不需要更新代码。我参与过的一些项目及其可配置性的例子包括:</p><ul class=""><li id="a999" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">一个相关的评估系统<strong class="ka ir">，其中管理员定义带有问题和评分例外的自定义评估模板</strong>。管理员实时创建新的评估、新的问题和新的评分例外。前端自动显示这些变化，API已经知道如何使用新的逻辑。</li><li id="f1f4" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">一个最小的电子商务网站<strong class="ka ir">，其中的产品选项由管理员</strong>实时定义，而所有这些仍然是一个主产品。管理员还向这些标签添加标签/键和值。每个标签的不同值的每个组合代表一个具有单独SKU的库存项目。我们设计系统的方式允许我们只显示可用的选项组合(例如<em class="lk">红色</em> XL或<em class="lk">绿色</em> SM ),同时验证管理员没有复制现有的选项组合。</li><li id="af70" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">问卷引擎<strong class="ka ir">，管理员在其中定义问题、可用答案和自定义值计算</strong>。管理员创建问题以及每个问题的答案。答案格式取决于问题的类型。并且，可选地，每个问题类型可能具有用于进一步计算所需的其他属性。</li><li id="6842" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">一个工作流和状态跟踪系统<strong class="ka ir">，其中根据“项目”(数据库表)</strong>定义和设置自定义状态。管理员定义了“项目”需要遵循的状态列表以及遵循的顺序。API可以验证流程是否被正确遵循，并且前端相应地显示订单。</li></ul><p id="2cde" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">还有一些其他示例的复杂性更低，但是，许多示例似乎至少有一个小型企业对实时用户可配置数据的需求。当我们第一次处理这些需求时，我们在白板上开了一个很长的设计会议。我们讨论了各种关于数据库模式复杂性、API逻辑复杂性或前端复杂性的问题。对于任何用户配置的设计，我们发现如果设计不正确，整个系统至少有一部分(数据库、API或前端)会比其余部分更复杂。考虑到后者，我们试图平衡这三者，使系统的任何一部分都不会:</p><ol class=""><li id="7aae" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv ll lc ld le bi translated">太难维持了</li><li id="c637" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv ll lc ld le bi translated">对于新开发人员来说，在合理的时间内学习太难了</li><li id="b187" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv ll lc ld le bi translated">陷入困境，未来的需求需要重新设计</li></ol><p id="7c35" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">以下是我们在处理这些新项目时一贯遵循的一些原则和策略。</p><h1 id="eae8" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">验证设计、验证设计和验证设计</h1><p id="aab2" class="pw-post-body-paragraph jy jz iq ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">在开始为项目编写代码之前，验证和重新验证数据库设计模式的重要性怎么强调都不为过。我们已经经历过——时间紧迫、需求不明确，或者仅仅是一个疏忽——设计在项目的后期不能工作，需要返工。我的一些建议是:</p><ul class=""><li id="5051" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">尽可能保持简单。保持表的数量少，代码少。如果您发现自己需要四五个表来支持一个可配置的特性，那么您可能需要重新考虑一下您所做的事情的复杂性。我们的大多数项目只使用一两个表，并通过使用几个架构良好的数据库列获得成功。</li><li id="d66e" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">从你的客户或产品所有者那里引出所有的需求，即使是那些没有说出来的。如果你有一个想法，“我想知道他们是否需要这样做……”，那就去问客户吧。用户配置的设计是最难更改的设计之一。</li><li id="1095" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">画一个流程图。获取项目的所有需求和描述，创建一个示例场景，并运行它。我喜欢在白板上绘制数据库表，并随着过程的进行在下面画线。你会很快发现(使用这种视觉方法)是否有东西丢失或根本没有使用。</li></ul><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi mp"><img src="../Images/1fe5e7dbbca8c1a5225d035add56952f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V0EpLVQ17kN2QFemiO0RPg.jpeg"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">马克·拉贝在<a class="ae my" href="https://unsplash.com/s/photos/whiteboard?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h1 id="fcec" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">降低数据库复杂性的枚举</h1><p id="8861" class="pw-post-body-paragraph jy jz iq ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">如果您不熟悉什么是枚举，下面是一个代码示例:</p><pre class="mq mr ms mt gt mz na nb nc aw nd bi"><span id="b422" class="ne ln iq na b gy nf ng l nh ni">// c# / .NET Core</span><span id="81da" class="ne ln iq na b gy nj ng l nh ni">public enum MyEnum<br/>{<br/>    Text = 0,<br/>    Number = 1,<br/>    Dropdown = 2,<br/>    Radio = 3<br/>}</span></pre><p id="b0b0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">枚举是一组预定义的(在编译期间已知的)值，用于区分某些属性或进程。通常，这些值在数据库中存储为整数。在一些项目中，我们使用EF Core将枚举值转换成字符串(varchar ),因为手动查询和查看带有枚举名称的数据库记录更容易。</p><p id="140d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在问卷引擎中，如上所述，问题类型具有enum属性<code class="fe nk nl nm na b">public QuestionType Type { get; set; }</code>，API逻辑和前端将出于不同的原因使用该属性。API逻辑可能知道验证可选属性，并将这些属性用于某些计算。我们有一个常见的可选属性是<code class="fe nk nl nm na b">public string Pattern { get; set; }</code>来验证用户输入的正则表达式模式。在前端，我们将使用<code class="fe nk nl nm na b">Type</code>属性来确定显示和验证什么组件/表单控件。</p><p id="bbbc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们首先尝试确定所有可能需要的类型，但是，如果忽略了一个类型，简单地添加另一个类型就是在enum文件中添加一行代码，并为附加逻辑添加一个if/case语句。</p><h1 id="32f1" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">JSON字段来降低数据库的复杂性</h1><p id="bfe3" class="pw-post-body-paragraph jy jz iq ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">根据经验，为用户定义的、可配置的字段设计数据库模式通常需要多个小表，这会变得非常复杂、非常快速。JSON字段是抵消数据库设计复杂性的一个很好的方法，EF Core使这变得很容易。下面是我如何将一个<code class="fe nk nl nm na b">IEnumerable</code>或自定义类转换成JSON字符串的例子:</p><pre class="mq mr ms mt gt mz na nb nc aw nd bi"><span id="19b8" class="ne ln iq na b gy nf ng l nh ni">// c# / .NET Core</span><span id="ad30" class="ne ln iq na b gy nj ng l nh ni">protected override void OnModelCreating(ModelBuilder modelBuilder)<br/>{</span><span id="576f" class="ne ln iq na b gy nj ng l nh ni">    modelBuilder.Entity&lt;MyCustomClass&gt;(x =&gt;<br/>    {<br/>        x.Property(y =&gt; y.MyCustomClass)<br/>            .HasConversion(<br/>                y =&gt; JsonConvert.SerializeObject(y, new JsonSerializerSettings { NullValueHandling = NullValueHandling.Ignore }),</span><span id="cc79" class="ne ln iq na b gy nj ng l nh ni">                y =&gt; JsonConvert.DeserializeObject&lt;DepartmentRecord&gt;(y, new JsonSerializerSettings { NullValueHandling = NullValueHandling.Ignore }));<br/>    });</span><span id="48e8" class="ne ln iq na b gy nj ng l nh ni">}</span></pre><p id="733b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">本文开头描述的电子商务示例使用这种技术来保存、显示和验证产品选项。一个产品的示例表可能是这样的:</p><pre class="mq mr ms mt gt mz na nb nc aw nd bi"><span id="a9d1" class="ne ln iq na b gy nf ng l nh ni">// c# / .NET Core</span><span id="ae9e" class="ne ln iq na b gy nj ng l nh ni">public class Product<br/>{<br/>    public int Id { get; set; }</span><span id="747c" class="ne ln iq na b gy nj ng l nh ni">    public Options Options { get; set; }</span><span id="974f" class="ne ln iq na b gy nj ng l nh ni">    ...<br/>}</span><span id="3e97" class="ne ln iq na b gy nj ng l nh ni">public class Options<br/>{<br/>    public string Label { get; set; }</span><span id="2660" class="ne ln iq na b gy nj ng l nh ni">    public List&lt;string&gt; Values { get; set; }<br/>}</span></pre><p id="d340" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将把<code class="fe nk nl nm na b">Options</code>属性转换成一个JSON字符串。纯关系设计的可比方法是创建两个新表；<code class="fe nk nl nm na b">ProductOptionKey</code>和<code class="fe nk nl nm na b">ProductOptionValue</code>，其中<code class="fe nk nl nm na b">ProductOptionValue</code>有一个返回到<code class="fe nk nl nm na b">ProductOptionKey</code>的外键，<code class="fe nk nl nm na b">ProductOptionKey</code>有一个返回到产品的外键。如您所见，这将增加两个数据库表、两个c#服务等..我强烈推荐在有用的地方使用JSON字段，同时确保它们不只是“酷”。</p><h1 id="2861" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">摘要</h1><p id="546c" class="pw-post-body-paragraph jy jz iq ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">我希望这篇文章对任何接近或正在从事需要用户配置设计的项目的人有用。我希望传达的主要观点是简单数据库设计和极端彻底性的重要性。在验证数据库设计的同时这样做将会在现在和将来支持您的项目。我预计2021年至少会有四五个以上的项目以这样或那样的方式需要这种实践，我真的很享受为他们设计这些解决方案的过程。</p><h1 id="e070" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">关于我</h1><p id="8bff" class="pw-post-body-paragraph jy jz iq ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">我在南卡罗来纳州格林维尔的软件工程咨询公司Orange Bees担任首席工程师。我写得棱角分明。NET应用，在Azure架构项目(Azure Developer Associate认证)，涉猎ElasticSearch和node . js<br/>你可以在<a class="ae my" href="https://www.linkedin.com/in/james-l-gross/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上找我。</p></div></div>    
</body>
</html>