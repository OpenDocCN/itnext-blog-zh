# 用单个请求获取 Next.js 中的共享数据

> 原文：<https://itnext.io/fetch-shared-data-in-next-js-with-single-request-833433fa8ed1?source=collection_archive---------1----------------------->

## 看一看在 Next.js 前面有 NodeJS 层的缓存策略

![](img/96aef764a35a409c68a4777516a78322.png)

照片由[戈登工厂](https://unsplash.com/@gordonplant)在 [Unsplash](https://unsplash.com) 拍摄

在回顾我当前项目的构建过程时，我注意到用`getStaticProps`生成页面会对一个端点产生许多请求。对我来说，这不是一个大问题，因为我们的后端相当快，但谷歌搜索这个问题表明，一些人正在努力解决这个问题。例如，如果数据库很慢，或者后端无法处理每秒 100 个请求，问题可能会很严重。所以我决定尝试解决这个问题，并改善我的项目的构建时间。

# 为什么这么多要求？

在深入 Next.js 的构建过程之前，让我们看看另一个静态站点生成器 Gatsby 是如何做类似的事情的。只有当 Next.js 作为一个 SSR 框架启动时，Gatsby 才有一个非常不同于 SSG 的机制。

Gatsby 有几个构建过程步骤，但主要的两个是:提取数据并用数据填充组件，然后呈现。Gatsby 插件通常使用 GraphQL 数据层来存储来自数据源的数据(当然你可以不用 GraphQL 数据层而使用非结构化数据来构建)。Gatsby 运行数据插件，然后它们获取数据并将其放在数据层。然后，它从页面获取 GraphQL 查询，并为模板准备数据。之后，用数据填充组件。这种构建页面的方式看起来简单明了。但是 Next.js 的工作方式正好相反。

正如我之前说过的，Next.js 最初是一个只有 SSR 的框架，后来添加了 SSG 特性。它有 API，在那里你可以得到数据，并把它传递给每一页，但这种方法打破了 SSG 优化。我说的是`getInitialData`用在`_app.js`内部的时候

为了拥有 SSG 页面，我们只使用`getStaticProps`或者只制作没有数据获取的页面。当 Next.js 构建页面时，如果它在页面文件中，它将运行数据获取函数，然后使用这些数据呈现页面。并且该过程一页接一页地重复。因此，如果数据是共享的，它将会在每个页面上被请求。如果应用程序中的页面数量在增加，那么请求的数量也在增加。

我的应用程序要求在每一页上显示城市列表，这些城市应该在服务器上定义。我知道 Gatsby 是如何工作的，并且想添加一个类似的机制，但是更简单，并且没有 GraphQL🙂

# 我的第一次尝试

第一个想法非常简单。例如，当第一个页面调用`fetchCities`时，我将`fetch`返回的承诺保存到模块范围的变量中。当下一页调用`fetchCities`时，我检查我们的变量是否指向承诺，如果是，就返回它。

示例显示了如何在模块范围内保存请求。

概念很简单。我们只是在模块范围内保存请求承诺，然后将其返回给所有后续调用。问题是——这种方法行不通。原因是工人。Next.js 在自己的 worker 中运行每个页面构建。这意味着我无法在页面之间共享数据，并且我无法访问一个无需付出巨大努力就可以在员工之间共享数据的地方。此外，我检查我们的请求在 CI 中是否有效，因为在重新验证时可能会调用`fetchCities`，在这种情况下，我希望每次都能获得新的数据。

# 或许谷歌能帮上忙？

我有更多的想法，但我决定谷歌一下。也许我不是第一个面临这个问题的人。我发现其他人也在思考同样的问题，他们有不同的理由去做这件事。有人刚刚开始使用 Next.js，它的后端无法满足大量的请求。其他人试图从 Gatsby 过渡到 Next，并意识到他们的后端对于 300 RPS 来说不是太快。我知道盖茨比是怎么工作的，因为我在前一份工作中遇到过。盖茨比的做法不同。首先，通过将数据收集到本地缓存来准备构建，在这种情况下，所有资源只提取一次。以便每个页面都能从这个缓存中获取数据。我的想法类似，但我不需要在 Next.js 上添加缓存。

# 在文件中缓存数据

解决这个问题的一个潜在方法是在文件中进行缓存。我们需要在构建过程中增加一个步骤，并编写类似这样的代码。

我们运行获取数据并将其保存到文件中的脚本。这种方法的缺点是，我们需要收集其中的所有端点来获取数据。

一旦收集了数据，我们就可以运行服务器，它将为构建我们的应用程序提供缓存数据。

这些选择都很好，但也有自己的缺点。例如，我们应该收集所有用于缓存的端点并更新它们。或者您应该等到所有资源都被缓存。另一方面，所有资源都缓存在磁盘上，不会留在内存中。我想分享这段代码只是为了向你展示所有的选项。

# 构建时将其缓存在内存中

是的，这是最容易和最快的方法来缓存您的数据，而不是等待任何东西。只需在建造阶段通过不同的`API_PATH`，并在运行`next build`之前运行缓存服务器。

我们服务器的代码可能如下所示:

这个想法和第一个是一样的——我们只是在不同的层次上存储数据。所有请求都将调用我们的缓存代理。当请求被接收时，它被存储在一个映射中，并且对同一资源的所有后续请求将得到相同的响应。它应该非常快，但如果你请求大量数据，你应该小心内存。否则，您可以通过及时缓存数据并将其存储在磁盘而不是内存中，来混合使用这两种方法。

# 结论

实际上，Next.js 团队计划在`_app.js`中增加使用`getStaticProps`的能力。在那之后，整个问题可以不需要任何额外的努力就能解决。我一直在关注这个[讨论](https://github.com/vercel/next.js/discussions/10949#discussioncomment-44898)，但它仍然被搁置。

也许您的数据源也有类似的问题，如果这篇文章对您有所帮助，我会很高兴。目标不仅仅是解决问题，而是尝试使用不同的方法。我希望我展示了一些新的东西，也许它会启发你解决一些问题，做一些“头脑”练习。当您需要缓存数据时，这些示例可能有助于解决其他问题。您可以使用它们，并根据需要进行修改。
[完整示例](https://github.com/akellbl4/cache-proxy)存储在 GitHub 上。