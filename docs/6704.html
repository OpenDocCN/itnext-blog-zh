<html>
<head>
<title>Range &amp; Index — C#8 features under the radar</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">范围和索引—雷达下的C#8特性</h1>
<blockquote>原文：<a href="https://itnext.io/range-index-c-8-features-under-the-radar-c28aaa065d1?source=collection_archive---------0-----------------------#2022-02-04">https://itnext.io/range-index-c-8-features-under-the-radar-c28aaa065d1?source=collection_archive---------0-----------------------#2022-02-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div class="gh gi ir"><img src="../Images/12dace7d6046c029338d7318655231cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:450/format:webp/1*Eq15BNVxrjru85hRgQvpfw.png"/></div></figure><div class=""/><p id="da7c" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">最近，我发了几篇关于C#8中嵌入的一些奇特特性的帖子，但是，我觉得有一个特性非常有用，但是经常被忽略——Range &amp; Index。</p><p id="3a12" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">虽然是许多其他集合的基本构建块，但使用简单数组通常仅限于简单的索引访问。因为数组也实现了IEnumerable，并且能够使用Linq，所以使用起来仍然感觉很舒服，但是如果没有它，除了这个语法之外就没有什么了。</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="d623" class="le lf ja la b gy lg lh l li lj">int[] arr = new int[]{1};</span><span id="2bba" class="le lf ja la b gy lk lh l li lj">Console.WriteLine(arr[0]); //1</span></pre><p id="8c4e" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">然而，随着范围和指数的引入，这种情况发生了巨大变化。让我们来看看。</p><h1 id="7088" class="ll lf ja bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">索引</h1><p id="f4a3" class="pw-post-body-paragraph jx jy ja jz b ka mi kc kd ke mj kg kh ki mk kk kl km ml ko kp kq mm ks kt ku im bi translated">索引是一个非常简单的结构，起初并不清楚为什么它不是一个简单的int。访问带索引的数组将返回</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="3aca" class="le lf ja la b gy lg lh l li lj">Index index = 1;<br/>int[] arr = new int[]{1, 5};<br/>Console.WriteLine(arr[index]); // 5</span></pre><p id="7e41" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">然而，Index的特别之处在于它还允许你定义一个从数组的<strong class="jz jb">端</strong>开始的索引！这是通过使用帽子运算符<strong class="jz jb"> ^ </strong>来实现的，它使得索引读作“获取第n个索引，从末尾开始”。不过有一个奇怪的问题——与前面不同，从后面数从1开始。这是政府有意识的决定。不过是网队。</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="eaec" class="le lf ja la b gy lg lh l li lj">Index index = <strong class="la jb">^</strong>1;<br/>int[] arr = new int[]{1, 5};<br/>Console.WriteLine(arr[index]); // 5</span></pre><p id="9db9" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">足够简单，事实上比通常的<em class="mn"> arr有用得多。长度-1 </em>组合。为了方便起见，编译器会将语法变成这样:</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="63a0" class="le lf ja la b gy lg lh l li lj">Index index = 1;<br/>=&gt; Index index = (Index)1;</span><span id="c144" class="le lf ja la b gy lk lh l li lj">Index reverse = ^1;<br/>=&gt; Index reverse = new Index(1, true);</span></pre><p id="298b" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">注意这里的<em class="mn"> true </em>指的是索引构造器的fromEnd <em class="mn">参数</em>。</p><h1 id="b30c" class="ll lf ja bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">范围</h1><p id="99f3" class="pw-post-body-paragraph jx jy ja jz b ka mi kc kd ke mj kg kh ki mk kk kl km ml ko kp kq mm ks kt ku im bi translated">索引很棒，但是范围才是新工具真正开始发光的地方！</p><p id="f4d1" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">范围又是一个结构，所以你可以赋值甚至传递它——你看到它不仅仅是语法上的糖。</p><p id="3280" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这里有一个简单的例子来说明一个系列的作用:</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="54e9" class="le lf ja la b gy lg lh l li lj">Range range = 1..3;<br/>int[] arr = new int[]{1, 2, 3, 4, 5};<br/>int[] result = arr[range]; // result now contains: [2, 3]</span></pre><p id="acc3" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这已经非常有用了，但是您甚至可以更进一步，将它与hat语法混合使用，将范围限制在从末尾开始的特定索引。不过这需要一点时间来适应，因为在这种情况下，与索引不同，<em class="mn"> ^0 </em>是完全合法的。该范围将评估到，因此它将不会尝试访问实际的<em class="mn"> ^0 </em>位置，这将超出界限(本质上类似于访问<em class="mn"> arr[arr。计数] </em>)。</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="d4fe" class="le lf ja la b gy lg lh l li lj">Range range = 2..^0;<br/>int[] arr = new int[]{1, 2, 3, 4, 5};<br/>int[] result = arr[range]; // result now contains: [3, 4, 5]</span></pre><p id="ac82" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">您甚至根本不必指定开始或结束，甚至可以省略两者:</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="d669" class="le lf ja la b gy lg lh l li lj">int[] arr = new int[]{1, 2, 3, 4, 5};<br/>int[] result = arr[1..]; // result now contains: [2, 3, 4, 5]<br/>int[] result2 = arr[..^1]; // result now contains: [1, 2, 3, 4]<br/>int[] result3 = arr[..]; // result now contains all: [1, 2, 3, 4, 5]</span></pre><p id="332b" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">太棒了。请注意，所有这一切只可能发生在选定的类上，主要是数组、Span <t>和string(因为它是char[])。</t></p><h1 id="a14d" class="ll lf ja bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">有用的用例</h1><p id="4618" class="pw-post-body-paragraph jx jy ja jz b ka mi kc kd ke mj kg kh ki mk kk kl km ml ko kp kq mm ks kt ku im bi translated">虽然不是最闪亮的特性，但它有很好的用例来大大提高代码的可读性。</p><p id="8582" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我最喜欢的用例可能是子字符串。假设我们有一个字符串，想组成一个从0到任意位置的子串。</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="67e7" class="le lf ja la b gy lg lh l li lj">var baseString = "Hello";<br/>var randomEnd = new Random().Next(1, 4);</span><span id="519e" class="le lf ja la b gy lk lh l li lj">Old:<br/>var substringOld = baseString.Substring(0, , baseString.Length - randomEnd);</span><span id="b073" class="le lf ja la b gy lk lh l li lj">New:<br/>var substringNew = baseString[..^randomEnd];</span></pre><p id="e618" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">很方便，对吧？</p><p id="6d02" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">另一个超级有用的用例是使用<em class="mn">跨度&lt; T &gt;。</em>这是一个非常自然的搭配，因为span代表一个连续的内存区域，访问这个内存的一个索引或一个特定的片是一个非常常见的用例。</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="5f7b" class="le lf ja la b gy lg lh l li lj">var baseString = "Hello";<br/>var baseSpan = baseString.AsSpan();<br/>Console.WriteLine(baseSpan[1..3].ToString()); // el</span></pre><p id="7fc5" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">和现代的许多功能一样。Net中，对索引和范围的支持是通过ducktyping实现的。这里有一个很好的总结:<a class="ae mo" href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-8.0/ranges#implicit-index-support" rel="noopener ugc nofollow" target="_blank">https://docs . Microsoft . com/en-us/dot net/cs harp/language-reference/proposals/cs harp-8.0/ranges # implicit-index-support</a>。</p><p id="141e" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">例如，如果您想要一个实现隐式索引支持的自定义类，可以这样做:</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="fb89" class="le lf ja la b gy lg lh l li lj">var customBuffer = new CustomBuffer();<br/>Console.WriteLine(customBuffer[^3]); // 7</span><span id="4727" class="le lf ja la b gy lk lh l li lj">public class CustomBuffer<br/>{<br/>    private int[] _buffer = new int[]{1,2,3,4,5,6,7,8,9};<br/> <br/>    public int Length =&gt; _buffer.Length;<br/> <br/>    public int this [int index] =&gt; _buffer[index];<br/>}</span></pre><p id="17ef" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">除了ducktyping之外，您还可以添加显式支持，当然是通过添加一个索引或范围作为方法参数，或者作为一个直接的索引器。请注意，在这种情况下，我们移除了隐式支持，因为该类不再具有长度属性，并且索引器被更改为接受Index而不是int:</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="d8c4" class="le lf ja la b gy lg lh l li lj">var customBuffer = new CustomBuffer();<br/>Console.WriteLine(customBuffer[^3]); // 7</span><span id="687a" class="le lf ja la b gy lk lh l li lj">public class CustomBuffer<br/>{<br/>    private int[] _buffer = new int[]{1,2,3,4,5,6,7,8,9};<br/> <br/>    public int this [Index index] =&gt; _buffer[index];<br/>}</span></pre><p id="3b62" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">所以，总的来说，这是一个非常好的特性，即使更大的C#8特性，比如可空性，有点抢了风头。</p></div></div>    
</body>
</html>