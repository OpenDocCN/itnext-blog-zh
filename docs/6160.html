<html>
<head>
<title>Parse, don’t validate, incoming data in TypeScript.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">解析而不是验证TypeScript中的传入数据。</h1>
<blockquote>原文：<a href="https://itnext.io/parse-dont-validate-incoming-data-in-typescript-d6d5bfb092c8?source=collection_archive---------2-----------------------#2021-09-05">https://itnext.io/parse-dont-validate-incoming-data-in-typescript-d6d5bfb092c8?source=collection_archive---------2-----------------------#2021-09-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5826" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何使用io-ts、Runtypes和Zod等库来安全地解析应用程序类型中的所有传入和传出数据。</h2></div><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/e20a15926afccc330ac6ea56dcca5590.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tHLB4GRNEQwZ8bdWub1U0A.jpeg"/></div></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk translated">我们离链路层有点远，但最终这是关于我们如何处理我们从互联网上读取和写入的数据。</figcaption></figure><p id="ced9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个人都知道验证用户输入是所有web编程的基础。事实上，所有进入(也许还有离开)你的软件的数据都应该被验证。那么这种对解析它的嘲弄是什么呢？这是什么<a class="ae lv" href="https://lexi-lambda.github.io/blog/2019/11/05/parse-don-t-validate/" rel="noopener ugc nofollow" target="_blank">解析，不验证</a>(你可能想以后再看)的胡言乱语？</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="8c79" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">让我们从一个验证示例开始。</h1><p id="cf95" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">让我们抓住一个流行的JavaScript验证库，比如<a class="ae lv" href="https://github.com/jquense/yup" rel="noopener ugc nofollow" target="_blank">是的</a>。请注意，我们也可以使用其他流行的库，如<a class="ae lv" href="https://github.com/sideway/joi" rel="noopener ugc nofollow" target="_blank"> joi </a>或JSON验证器，如<a class="ae lv" href="https://github.com/ajv-validator/ajv/" rel="noopener ugc nofollow" target="_blank"> ajv </a>来代替，我们要表达的观点仍然保持不变。<em class="na">(编辑:由于一些反馈，最后有一个关于ajv的附录部分)</em></p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nb nc l"/></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk translated">用<a class="ae lv" href="https://github.com/jquense/yup" rel="noopener ugc nofollow" target="_blank">对</a>进行数据验证。</figcaption></figure><p id="cece" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码很好地验证了<code class="fe nd ne nf ng b">data</code>，并确保根据我们的<code class="fe nd ne nf ng b">schema</code>它是有效的。我们有很好的机会创建精确的模式，并且对定制验证逻辑有很好的支持。它也很容易维护，易于重用，扩展等等。那么问题出在哪里？</p><p id="ac73" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第24–27行中，我们可以轻松地处理通过/失败的情况，如果数据有效，则继续我们的业务逻辑(如果无效，则可能返回400错误或类似的错误)。然而，我们的<code class="fe nd ne nf ng b">data</code>仍然没有<em class="na">型</em>。还是<code class="fe nd ne nf ng b">any/unkown</code>。当然，我们可以对它进行类型转换，但这带来了一个问题:我们现在必须手动地分别维护一个<code class="fe nd ne nf ng b">schema</code> <strong class="lb iu">和</strong>一个<code class="fe nd ne nf ng b">type</code>，而且没有什么能真正确保它们匹配。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nb nc l"/></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk translated">谁来确保“用户模式”和“用户类型”保持同步？它们代表的是同一个东西吗？</figcaption></figure><p id="6e34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果有某种方法让<code class="fe nd ne nf ng b">schema</code>和<code class="fe nd ne nf ng b">type</code>总是匹配的话，那么我们就可以像这样声明“验证器”:<br/> <code class="fe nd ne nf ng b">function parseUserData(data: any): UserType | Error</code>。</p><p id="01e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，这样的“验证器”实际上是<strong class="lb iu">将数据解析</strong>成用户类型(这可能会失败，因此会出现错误！)而不仅仅是验证一些东西。所以一般来说解析实际上只是<code class="fe nd ne nf ng b">function &lt;T&gt;parse(x: any, schema): T | Error</code>。</p><p id="7b6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可能也注意到了，在上面的例子中，我们没有给<code class="fe nd ne nf ng b">schema</code>任何类型……我们稍后会回到这个话题。然而，首先让我们看看我们如何首先转向解析。</p><h1 id="01ea" class="md me it bd mf mg nh mi mj mk ni mm mn jz nj ka mp kc nk kd mr kf nl kg mt mu bi translated">那么“解析”到底是什么呢？</h1><p id="a516" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">在我们继续之前，让我们快速澄清什么是解析。</p><blockquote class="nm nn no"><p id="32b1" class="kz la na lb b lc ld ju le lf lg jx lh np lj lk ll nq ln lo lp nr lr ls lt lu im bi translated"><strong class="lb iu"> &gt;解析</strong>、<strong class="lb iu">句法分析</strong>或<strong class="lb iu">句法分析</strong>是对<a class="ae lv" href="https://en.wikipedia.org/wiki/Symbol_(formal)" rel="noopener ugc nofollow" target="_blank">符号</a>的一个<a class="ae lv" href="https://en.wikipedia.org/wiki/String_(computer_science)" rel="noopener ugc nofollow" target="_blank">字符串</a>进行分析的过程，可以是<a class="ae lv" href="https://en.wikipedia.org/wiki/Natural_language" rel="noopener ugc nofollow" target="_blank">自然语言</a>、<a class="ae lv" href="https://en.wikipedia.org/wiki/Computer_languages" rel="noopener ugc nofollow" target="_blank">计算机语言</a>或<a class="ae lv" href="https://en.wikipedia.org/wiki/Data_structure" rel="noopener ugc nofollow" target="_blank">数据结构</a>，符合一个<a class="ae lv" href="https://en.wikipedia.org/wiki/Formal_grammar" rel="noopener ugc nofollow" target="_blank">形式语法</a>的规则。</p><p id="c810" class="kz la na lb b lc ld ju le lf lg jx lh np lj lk ll nq ln lo lp nr lr ls lt lu im bi translated"><em class="it"/><a class="ae lv" href="https://en.wikipedia.org/wiki/Parsing" rel="noopener ugc nofollow" target="_blank"><em class="it">https://en.wikipedia.org/wiki/Parsing</em></a><em class="it"/></p></blockquote><p id="494f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里的关键部分是“<em class="na">分析</em>的过程”和“<em class="na">符合一个</em> [ <em class="na">事物</em> ]的规则”。<em class="na"> Thingy </em>是我们的schema &amp;类型，在这种情况下可以认为构成了我们的<em class="na">形式语法</em>(如果你不知道那是什么意思，不用担心)。<em class="na">分析</em>的过程是我们的代码在试图使数据符合模式&amp;类型时所做的工作。我们之所以说“模式&amp;类型”是因为我们希望它们在某种程度上是同一个东西，而不是两个可能同步也可能不同步的独立的东西。</p><p id="dced" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的例子中，我们将解析JavaScript或JSON对象，它们的具体结构是未知的。解析字符串或二进制数据是另一回事。由于许多不同的数据格式可以很容易地转换成JSON/JavaScript对象，这在web编程中是一个很常见的问题。</p><h1 id="ea91" class="md me it bd mf mg nh mi mj mk ni mm mn jz nj ka mp kc nk kd mr kf nl kg mt mu bi translated">解析，而不是验证，很难</h1><p id="b3fa" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">让我们通过使用前面例子中的<code class="fe nd ne nf ng b">yup</code>以及一些好的类型脚本特性:类型别名和类型保护，将一些未知数据解析到<code class="fe nd ne nf ng b">UserType</code>。这仍然是一种有点手动和冗长的方式来拉取<em class="na">“解析，不验证”</em><em class="na"/>方法，但它已经修复了我们原始解决方案中的一些问题:1)不需要类型转换，或者2)单独维护一个<code class="fe nd ne nf ng b">type</code> + <code class="fe nd ne nf ng b">schema</code>。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="a97b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里发生了什么？</p><ul class=""><li id="9a6b" class="ns nt it lb b lc ld lf lg li nu lm nv lq nw lu nx ny nz oa bi translated"><strong class="lb iu">业务逻辑现在可以将任何数据解析到</strong> <code class="fe nd ne nf ng b"><strong class="lb iu">UserType</strong></code> <strong class="lb iu">。只要记得检查是否有错误就行了。</strong></li><li id="30fa" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated"><strong class="lb iu">我们使用了比</strong> <code class="fe nd ne nf ng b"><strong class="lb iu">string</strong></code> <strong class="lb iu">或</strong> <code class="fe nd ne nf ng b"><strong class="lb iu">number</strong></code> <em class="na"> …更精确的类型。由于类型别名的工作方式，我们的电子邮件类型仍然只是一个字符串，即使我们的类型保护更好。我们稍后再来讨论这个问题。</em></li><li id="2ab8" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated"><strong class="lb iu">容易出错、危险、类型检查不好的代码仅限于类型守卫。让我们好好测试它们，为特定类型编写解析器可以轻而易举地完成:)</strong></li><li id="d5af" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated">TS编译器确保我们的解析器实际工作。在类型检查器的良好支持下，我们可以安全地编写我们的解析器函数。</li><li id="fbc2" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated">编写解析器和类型守卫仍然需要大量的工作。它们看起来也很老套，肯定存在一些带有预建类型保护和工具的库来构建解析器吧？</li></ul><h1 id="9649" class="md me it bd mf mg nh mi mj mk ni mm mn jz nj ka mp kc nk kd mr kf nl kg mt mu bi translated">像你看到了光一样解析</h1><p id="14e4" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">是时候引入一种不同的数据验证库了，它是专门为TypeScript设计的，并且使用了我们在这里介绍的思想。<a class="ae lv" href="https://github.com/pelotom/runtypes" rel="noopener ugc nofollow" target="_blank"> Runtypes </a>、<a class="ae lv" href="https://github.com/colinhacks/zod" rel="noopener ugc nofollow" target="_blank"> Zod </a>以及最后但并非最不重要的<a class="ae lv" href="https://github.com/gcanti/io-ts" rel="noopener ugc nofollow" target="_blank"> io-ts </a>，都是类似的“运行时类型验证器”，可以将你的数据解析成特定的类型(或者失败)。有人称之为(解)序列化，有人称之为编码/解码，有人称之为解析或验证。抛开术语不谈，他们做的事情本质上是一样的。我们来看第一个，runtypes。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nb nc l"/></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk translated">Runtypes并不是最有趣的选择，但是它仍然是一个很好的介绍。</figcaption></figure><ul class=""><li id="2ddb" class="ns nt it lb b lc ld lf lg li nu lm nv lq nw lu nx ny nz oa bi translated">解析变得非常简单和简洁。Runtypes提供了一个为JS对象创建解析器的基本工具箱，甚至近乎优雅。</li><li id="b588" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated"><strong class="lb iu">类型==模式==解析器。</strong> <em class="na">无需分别维护三者。Runtypes对象集类型、模式和解析器于一身！</em></li><li id="e7f4" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated"><strong class="lb iu">我们仍在使用某些类型的防护装置(带约束)。</strong> <em class="na">原始数据验证库仍然包含重要的&amp;有用的验证逻辑，我们可以在这里使用，因为Runtypes附带了非常基本的类型。类型保护是支持TypeScript中“解析，不验证”样式库的语言特性。</em></li><li id="5de7" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated"><strong class="lb iu">。check抛出一个错误，所以不要忘记捕捉它！</strong> <em class="na">我更喜欢处理返回类型，例如</em> <code class="fe nd ne nf ng b"><em class="na">UserType | Error</em></code> <em class="na">而不是，但我们仍然非常接近这里已经很好了。Zod和</em><a class="ae lv" href="https://github.com/ForbesLindesay/funtypes" rel="noopener ugc nofollow" target="_blank"><em class="na">Funtypes</em></a><em class="na">(Runtypes fork)修复这个，不过。</em></li></ul><h1 id="2da0" class="md me it bd mf mg nh mi mj mk ni mm mn jz nj ka mp kc nk kd mr kf nl kg mt mu bi translated">结论</h1><p id="7aef" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated"><em class="na">“解析，不验证”</em>的咒语就是将输入数据解析为特定的类型，或者在解析失败时以可控的方式失败。它是关于在你的代码中使用可信的、安全的和类型化的数据结构，并确保所有输入的数据都在你的程序的边缘被处理。不要将传入的数据深入到代码中，立即解析它，如果需要的话，快速失败。</p><p id="70f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">解析比验证要好，因为解析迫使您显式地处理所有传入的数据。它为您提供了一种类型安全的工作方式，使您很难在应用程序和数据存储中传播恶意内容。然而，解析确实经常包括验证数据。</p><blockquote class="og"><p id="756a" class="oh oi it bd oj ok ol om on oo op lu dk translated">如果你对目前为止所学的内容感到满意，现在是一个很好的时机来点击clap &amp;跟随并尝试Runtypes或Zod！然而，我认为你绝对应该看看下面的奖金部分！</p></blockquote></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="1502" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">额外收获:解析起来就像你看过矩阵一样</h1><p id="5d5a" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">这不会比Runtypes或Zod更短或更容易，但事情变得更加健壮和类型安全。我们还需要更加小心副作用，因为<code class="fe nd ne nf ng b">io-ts</code>(它的表亲<code class="fe nd ne nf ng b">fp-ts</code>)不会让我们得逞。</p><p id="9900" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="na">强制免责声明:有些人会批评</em> <code class="fe nd ne nf ng b"><em class="na">io-ts</em></code> <em class="na">因为它带你下兔子洞到</em> <code class="fe nd ne nf ng b"><em class="na">fp-ts</em></code> <em class="na">。的确，对于许多团队来说，Runtypes或Zod就足够了。然而，我们来这里是为了更深入地探索。</em></p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nb nc l"/></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk translated">我们进入了兔子洞:标记类型，IO解码，…和折叠任一单子！</figcaption></figure><p id="1976" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们得到了Runtypes的所有优点，但是还有一些额外的安全性:</p><ul class=""><li id="be6a" class="ns nt it lb b lc ld lf lg li nu lm nv lq nw lu nx ny nz oa bi translated"><strong class="lb iu">真正独特、具体且可安全重复使用的类型。</strong> <em class="na"> Email是一个实际的Email，不是随便什么字符串。它仍然类似于前面的类型别名+类型保护组合，但是这次有更严格的安全保证。</em></li><li id="292c" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated">UserType有一些很好的工具来接受各种不同的日期显示方式，但是没有默认设置。 <em class="na">提供当前时间默认值实际上会使编解码器变得不纯(您可能需要在测试中模仿</em> <code class="fe nd ne nf ng b"><em class="na">Date</em></code> <em class="na">)。纯编解码器对于可测试性和可预测性是有意义的。如果你感兴趣，这就是为什么</em> <a class="ae lv" href="https://dev.to/gcanti/getting-started-with-fp-ts-io-36p6" rel="noopener ugc nofollow" target="_blank"> <em class="na"> IO单子存在</em> </a> <em class="na">。或者您可以在解码后在逻辑中使用默认值。</em></li><li id="661a" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated"><strong class="lb iu">解析(解码)返回一个必须适当处理的结果。</strong> <em class="na">不然是不会编译的！抛出错误是不安全的，应该返回值。结果实际上是</em> <code class="fe nd ne nf ng b"><em class="na">Either&lt;Left, Right&gt;</em></code> <em class="na">单子，它有一堆有用的功能和属性…但像往常一样，也有一些学习曲线。</em></li></ul><p id="fceb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然<code class="fe nd ne nf ng b">io-ts</code>可以提供更多的安全保证，并迫使开发人员朝着功能纯净的方向努力，但它也带来了额外的负担<code class="fe nd ne nf ng b">fp-ts</code>，并需要学习M-word的意思。</p><blockquote class="og"><p id="8a62" class="oh oi it bd oj ok ol om on oo op lu dk translated">在不久的将来，我会写更多关于io-ts、fp-ts和单子的内容。= &gt;点击拍手按钮并跟随按钮继续收听:)</p></blockquote><p id="f4a3" class="pw-post-body-paragraph kz la it lb b lc oq ju le lf or jx lh li os lk ll lm ot lo lp lq ou ls lt lu im bi translated">发现错误？有问题吗？想打个招呼吗？看看这些:</p><ul class=""><li id="e38b" class="ns nt it lb b lc ld lf lg li nu lm nv lq nw lu nx ny nz oa bi translated"><a class="ae lv" href="https://www.reddit.com/r/typescript/comments/pig0gr/parse_dont_validate_incoming_data_in_typescript/?utm_source=share&amp;utm_medium=web2x&amp;context=3" rel="noopener ugc nofollow" target="_blank">https://www . Reddit . com/r/typescript/comments/pig 0 gr/parse _ dont _ validate _ incoming _ data _ in _ typescript/</a></li><li id="4394" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated"><a class="ae lv" href="https://news.ycombinator.com/item?id=28425435" rel="noopener ugc nofollow" target="_blank">https://news.ycombinator.com/item?id=28425435</a></li></ul><h1 id="7c50" class="md me it bd mf mg nh mi mj mk ni mm mn jz nj ka mp kc nk kd mr kf nl kg mt mu bi translated">附录:带打字稿的ajv</h1><p id="5196" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">ajv库实际上对TypeScript有相当酷的支持，编译器可以帮助你保持类型和JSON模式同步！他们自己的例子演示了这一点，如果提供的<code class="fe nd ne nf ng b">JSONSchemaType </code>定义与<code class="fe nd ne nf ng b">MyData</code>不匹配，那么您将得到编译错误:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi ov"><img src="../Images/e463336c2c27742c32fa28395b147d83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UqHLc6AQhmuM66IemNZwuw.png"/></div></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk translated">ajv有很好的类型脚本支持，编译器可以判断出你的类型和模式是否匹配。</figcaption></figure></div></div>    
</body>
</html>