<html>
<head>
<title>Amazon ECR Cross-Account Access for Containerized Applications on ECS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">针对ECS上的容器化应用程序的Amazon ECR跨帐户访问</h1>
<blockquote>原文：<a href="https://itnext.io/amazon-ecr-cross-account-access-for-containerized-applications-on-ecs-fb88f8f2e988?source=collection_archive---------1-----------------------#2019-10-28">https://itnext.io/amazon-ecr-cross-account-access-for-containerized-applications-on-ecs-fb88f8f2e988?source=collection_archive---------1-----------------------#2019-10-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="84bf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ko">此</em> <a class="ae kp" href="https://garystafford.medium.com/amazon-elastic-container-registry-ecr-cross-account-access-for-ecs-2f90fcb02c80?source=your_stories_page-------------------------------------" rel="noopener"> <em class="ko"> post </em> </a> <em class="ko">有一个2021年4月的更新版本，它使用</em> <a class="ae kp" href="https://docs.aws.amazon.com/cli/latest/userguide/install-cliv2.html" rel="noopener ugc nofollow" target="_blank"> <em class="ko"> AWS CLI版本2 </em> </a> <em class="ko">命令进行ECR和Docker映像的更新版本。请参考这个更新的帖子。</em></p></div><div class="ab cl kq kr hx ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="im in io ip iq"><p id="9462" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最近，有人问我一个问题，关于与另一个AWS帐户共享一个AWS帐户的<a class="ae kp" href="https://aws.amazon.com/ecr/" rel="noopener ugc nofollow" target="_blank">Amazon Elastic Container Registry</a>(ECR)中的Docker图像，该帐户正在使用<a class="ae kp" href="https://aws.amazon.com/fargate/" rel="noopener ugc nofollow" target="_blank"> AWS Fargate </a>部署到<a class="ae kp" href="https://aws.amazon.com/ecs/" rel="noopener ugc nofollow" target="_blank">Amazon Elastic Container Service</a>(ECS)。答案相对简单:使用<a class="ae kp" href="https://docs.aws.amazon.com/AmazonECR/latest/userguide/RepositoryPolicyExamples.html" rel="noopener ugc nofollow" target="_blank"> ECR存储库策略</a>来允许跨账户访问拉取图像。然而，魔鬼总是在<em class="ko">实现</em>细节。构建ECR存储库策略可能取决于您的特定架构、部署工具选择和帐户访问方法。在这篇简短的帖子中，我们将探索一个常见的架构场景，该场景需要配置ECR存储库策略来支持跨AWS帐户共享图像。</p><h1 id="a5dd" class="kx ky it bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">介绍</h1><p id="9dd7" class="pw-post-body-paragraph jq jr it js b jt lv jv jw jx lw jz ka kb lx kd ke kf ly kh ki kj lz kl km kn im bi translated">我经常遇到两种情况，需要在多个<a class="ae kp" href="https://aws.amazon.com/account/" rel="noopener ugc nofollow" target="_blank"> AWS账户</a>之间共享基于ECR的Docker图像。在第一个场景中，供应商希望与他们的客户安全地共享Docker映像。许多流行的容器安全性和可观察性解决方案都是以这种方式运行的。</p><p id="6d27" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面，我们看到一个应用平台由三个容器组成的例子。集装箱的两个图像来自客户自己的ECR存储库(<em class="ko">右侧</em>)。第三个容器的图像来自其供应商的ECR注册表(<em class="ko">左侧</em>)。</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi ma"><img src="../Images/d37277237679cc33d46030b381ca46ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y-9yzygThLVI6ETXahP0EA.png"/></div></div></figure><p id="64dd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在第二个场景中，企业操作多个AWS帐户，以在环境和职责之间创建逻辑安全边界。第一个AWS帐户包含企业的可部署二进制资产，包括ECR映像存储库。企业有额外的帐户，每个帐户对应一个应用程序环境，例如开发、测试、试运行和生产。需要从每个环境(单独的AWS帐户)访问存储库帐户中的ECR映像，通常需要跨越多个AWS区域。</p><p id="be8e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面，我们看到一个例子，其中部署的应用程序平台由三个容器组成，其中所有的映像都来自ECR存储库(<em class="ko">左侧</em>)。映像被拉入生产帐户，以部署到ECS ( <em class="ko">右侧</em>)。</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi ma"><img src="../Images/40bb0841619530eb03a59558d4cf8b19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ACIgoiEf_B5mrVg14bDspQ.png"/></div></div></figure><p id="0db7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本帖中，我们将探讨第一个场景，一个希望与客户安全共享Docker映像的供应商。我们将演示如何使用ECR存储库策略，在AWS帐户之间共享图像，以用于Docker Swarm和ECS与Fargate。为了实现这个场景，我们将使用我已经创建的现有应用程序，一个RESTful的、基于HTTP的NLP(自然语言处理)API，由三个Golang微服务组成。边缘服务<code class="fe mm mn mo mp b">nlp-client</code>与<code class="fe mm mn mo mp b">rake-app</code>服务和<code class="fe mm mn mo mp b">prose-app</code>服务通信。</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi mq"><img src="../Images/3df6ff0a6cc64e764a09b10683dd461e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W6lKVBMRVAEtkbdf4K5SZA.png"/></div></div></figure><p id="e7d7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">演示中的场景是，客户已经开发了基于<code class="fe mm mn mo mp b">nlp-client</code>和<code class="fe mm mn mo mp b">prose-app</code>容器的服务，作为其NLP应用程序的一部分。他们没有开发自己的<a class="ae kp" href="https://github.com/afjoseph/RAKE.Go" rel="noopener ugc nofollow" target="_blank"> RAKE </a>(快速自动关键词提取)算法的实现，而是以Docker镜像的形式从供应商那里获得了一个版本，即<code class="fe mm mn mo mp b">rake-app</code>服务。</p><p id="f054" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">NPL API公开了几个端点，可以通过<code class="fe mm mn mo mp b">nlp-client</code>服务访问。端点对文本执行常见的NLP操作，如提取关键字、标记和实体。点击<code class="fe mm mn mo mp b">/routes</code>端点，所有端点均可见。</p><pre class="mb mc md me gt mr mp ms mt aw mu bi"><span id="c91e" class="mv ky it mp b gy mw mx l my mz">[<br/>  {<br/>    "method": "POST",<br/><strong class="mp iu">    "path": "/tokens",<br/></strong>    "name": "main.getTokens"<br/>  },<br/>  {<br/>    "method": "POST",<br/><strong class="mp iu">    "path": "/entities",<br/></strong>    "name": "main.getEntities"<br/>  },<br/>  {<br/>    "method": "GET",<br/><strong class="mp iu">    "path": "/health",<br/></strong>    "name": "main.getHealth"<br/>  },<br/>  {<br/>    "method": "GET",<br/><strong class="mp iu">    "path": "/routes",<br/></strong>    "name": "main.getRoutes"<br/>  },<br/>  {<br/>    "method": "POST",<br/><strong class="mp iu">    "path": "/keywords",<br/></strong>    "name": "main.getKeywords"<br/>  }<br/>]</span></pre><h1 id="e06c" class="kx ky it bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">要求</h1><p id="6c1f" class="pw-post-body-paragraph jq jr it js b jt lv jv jw jx lw jz ka kb lx kd ke kf ly kh ki kj lz kl km kn im bi translated">为了进行演示，您将需要两个AWS帐户，一个代表供应商，一个代表他们的一个客户。创建额外的AWS帐户相对简单，你需要的只是一个唯一的电子邮件地址(使用Gmail很容易)和一张信用卡。使用<a class="ae kp" href="https://aws.amazon.com/organizations/" rel="noopener ugc nofollow" target="_blank"> AWS组织</a>可以使创建和管理多个帐户的任务变得更加容易。</p><p id="7ff9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我有目的地在每个客户中使用不同的<a class="ae kp" href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Concepts.RegionsAndAvailabilityZones.html" rel="noopener ugc nofollow" target="_blank"> AWS区域</a>来演示如何在AWS客户和区域之间共享ECR图像。你需要一个最新版本的<a class="ae kp" href="https://aws.amazon.com/cli/" rel="noopener ugc nofollow" target="_blank"> AWS CLI </a>和<a class="ae kp" href="https://hub.docker.com/?overlay=onboarding" rel="noopener ugc nofollow" target="_blank"> Docker </a>。最后，您需要对每个AWS帐户有足够的访问权限来创建资源。</p><h1 id="7125" class="kx ky it bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">源代码</h1><p id="e457" class="pw-post-body-paragraph jq jr it js b jt lv jv jw jx lw jz ka kb lx kd ke kf ly kh ki kj lz kl km kn im bi translated">演示的源代码包含在四个公共的GitHub存储库中。第一个存储库包含所有CloudFormation模板和Docker Compose堆栈文件，如下所示。</p><pre class="mb mc md me gt mr mp ms mt aw mu bi"><span id="6131" class="mv ky it mp b gy mw mx l my mz">.<br/>├── LICENSE<br/>├── README.md<br/>├── cfn-templates<br/>│   ├── developer-user-group.yml<br/>│   ├── ecr-repo-not-shared.yml<br/>│   ├── ecr-repo-shared.yml<br/>│   ├── public-subnet-public-loadbalancer.yml<br/>│   └── public-vpc.yml<br/>└── docker<br/>└── stack.yml</span></pre><p id="1efe" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">其他三个GitHub存储库中的每一个都包含一个基于Go的微服务，它们共同组成了NLP应用程序。每个存储库还包含一个Dockerfile文件。</p><pre class="mb mc md me gt mr mp ms mt aw mu bi"><span id="aabc" class="mv ky it mp b gy mw mx l my mz">.<br/><strong class="mp iu">├── Dockerfile</strong><br/>├── LICENSE<br/>├── README.md<br/>├── buildspec.yml<br/><strong class="mp iu">└── main.go</strong></span></pre><p id="2e70" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">克隆四个存储库所需的命令如下:</p><pre class="mb mc md me gt mr mp ms mt aw mu bi"><span id="e77f" class="mv ky it mp b gy mw mx l my mz">git clone --branch master \<br/>    --single-branch --depth 1 --no-tags \<br/>    https://github.com/garystafford/ecr-cross-account-demo.git <br/><br/>git clone --branch master \<br/>    --single-branch --depth 1 --no-tags \<br/>    https://github.com/garystafford/nlp-client.git<br/><br/>git clone --branch master \<br/>    --single-branch --depth 1 --no-tags \<br/>    https://github.com/garystafford/prose-app.git<br/><br/>git clone --branch master \<br/>    --single-branch --depth 1 --no-tags \<br/>    https://github.com/garystafford/rake-app.git</span></pre><p id="5852" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将使用<a class="ae kp" href="https://aws.amazon.com/cloudformation/" rel="noopener ugc nofollow" target="_blank"> AWS CloudFormation </a>在两个AWS帐户中创建必要的资源。对于客户帐户，我们还将使用CloudFormation创建一个<a class="ae kp" href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ECS_clusters.html" rel="noopener ugc nofollow" target="_blank"> ECS集群</a>和一个<a class="ae kp" href="https://docs.aws.amazon.com/AmazonECS/latest/userguide/task_definitions.html" rel="noopener ugc nofollow" target="_blank"> Amazon ECS任务定义</a>。任务定义定义了ECS将如何使用<a class="ae kp" href="https://aws.amazon.com/fargate/" rel="noopener ugc nofollow" target="_blank"> AWS Fargate </a>部署我们的应用程序，该应用程序由三个Docker容器组成。除了ECS，我们还将创建一个<a class="ae kp" href="https://aws.amazon.com/vpc/" rel="noopener ugc nofollow" target="_blank"> Amazon虚拟私有云</a> (VPC)来托管ECS集群和一个面向公众的第7层<a class="ae kp" href="https://aws.amazon.com/elasticloadbalancing/application-load-balancer/" rel="noopener ugc nofollow" target="_blank">应用负载平衡器</a> (ALB)来平衡我们基于ECS的应用。</p><p id="7b25" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在整篇文章中，我将使用基于云的集成开发环境(IDE)AWS cloud 9(T8)来使用AWS CLI执行所有CloudFormation模板。我还将使用Cloud9构建Docker映像并将其推送到ECR存储库。就个人而言，我发现使用Cloud9的独立实例，比使用我的本地工作站，Cloud9更容易在多个AWS帐户和<a class="ae kp" href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_users.html" rel="noopener ugc nofollow" target="_blank"> AWS身份和访问管理(IAM)用户</a>之间切换。方便的是，Cloud9预装了本次演示所需的许多工具。</p><h1 id="b54d" class="kx ky it bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">创建ECR存储库</h1><p id="1639" class="pw-post-body-paragraph jq jr it js b jt lv jv jw jx lw jz ka kb lx kd ke kf ly kh ki kj lz kl km kn im bi translated">在代表供应商的第一个AWS帐户中，我们将执行两个CloudFormation模板。第一个模板<a class="ae kp" href="https://github.com/garystafford/ecr-cross-account-demo/blob/master/developer-user-group.yml" rel="noopener ugc nofollow" target="_blank">developer-User-Group . yml</a>，创建开发IAM组和用户。Developer-01 IAM用户将获得对供应商的<code class="fe mm mn mo mp b">rake-app</code> ECR库的明确访问权。我建议您将<code class="fe mm mn mo mp b">DevUserPassword</code>参数的值改为更安全的值。</p><pre class="mb mc md me gt mr mp ms mt aw mu bi"><span id="de01" class="mv ky it mp b gy mw mx l my mz"># change me<br/>IAM_USER_PSWD=<strong class="mp iu">T0pS3cr3Tpa55w0rD</strong> <br/><br/>aws cloudformation create-stack \<br/>    --stack-name developer-user-group \<br/>    --template-body file://cfn-templates/developer-user-group.yml \<br/>    --parameters \<br/>        ParameterKey=DevUserPassword,ParameterValue=${IAM_USER_PSWD} \<br/>    --capabilities CAPABILITY_NAMED_IAM</span></pre><p id="3bf4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面，我们看到一个结果CloudFormation堆栈的例子，展示了新的开发IAM用户和组。</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div class="gh gi na"><img src="../Images/fea713494e9c60138e53164fb92f4ec5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*ql2uGeOonCtpAAGj"/></div></figure><p id="bf08" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我们将执行第二个CloudFormation模板，<a class="ae kp" href="https://github.com/garystafford/ecr-cross-account-demo/blob/master/ecr-repo-shared.yml" rel="noopener ugc nofollow" target="_blank"> ecr-repo-shared.yml </a>，它将创建供应商的<code class="fe mm mn mo mp b">rake-app</code> ECR映像存储库。<code class="fe mm mn mo mp b">rake-app</code>存储库将存放供应商的<code class="fe mm mn mo mp b">rake-app</code> Docker映像的副本。但是首先，让我们看看用于创建存储库的CloudFormation模板，特别是<code class="fe mm mn mo mp b">RepositoryPolicyText</code>部分。这里我们定义了两个存储库策略:</p><ul class=""><li id="7ada" class="nb nc it js b jt ju jx jy kb nd kf ne kj nf kn ng nh ni nj bi translated"><code class="fe mm mn mo mp b">AllowPushPull</code>策略明确允许Developer-01 IAM用户将映像版本推送到ECR存储库中。我们从之前的CloudFormation堆栈输出中导入Developer-01 IAM用户的导出的<a class="ae kp" href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html" rel="noopener ugc nofollow" target="_blank"> Amazon资源名称</a> (ARN)。我们还允许AWS CodeBuild服务访问ECR库。这就是所谓的服务关联角色。在这篇简短的文章中，我们不会使用代码构建。</li><li id="3db5" class="nb nc it js b jt nk jx nl kb nm kf nn kj no kn ng nh ni nj bi translated"><code class="fe mm mn mo mp b">AllowPull</code>策略允许客户的AWS帐户(<code class="fe mm mn mo mp b">root</code>)中的任何人获取任何版本的映像。他们不能推，只能拉。当然，可以将跨帐户访问限制为特定客户的IAM实体和源IP地址的更细粒度集合。</li></ul><p id="83ac" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">注意<code class="fe mm mn mo mp b">"ecr:GetAuthorizationToken"</code>的政策行动。稍后，当客户需要提取该供应商的映像时，该操作将允许客户的用户登录到供应商的ECR存储库并接收授权令牌。客户检索对指定的集装箱登记处12小时有效的令牌。</p><pre class="mb mc md me gt mr mp ms mt aw mu bi"><span id="c2a0" class="mv ky it mp b gy mw mx l my mz">RepositoryPolicyText:<br/>  Version: '2012-10-17'<br/>  Statement:<br/>    - Sid: AllowPushPull<br/>      Effect: Allow<br/>      Principal:<br/>        Service: codebuild.amazonaws.com<br/>        AWS:<br/>          Fn::ImportValue:<br/>            !Join [':', [!Ref 'StackName', 'DevUserArn']]<br/>      Action:<br/>        - 'ecr:BatchCheckLayerAvailability'<br/>        - 'ecr:BatchGetImage'<br/>        - 'ecr:CompleteLayerUpload'<br/>        - 'ecr:DescribeImages'<br/>        - 'ecr:DescribeRepositories'<br/>        - 'ecr:GetDownloadUrlForLayer'<br/>        - 'ecr:GetRepositoryPolicy'<br/>        - 'ecr:InitiateLayerUpload'<br/>        - 'ecr:ListImages'<br/>        - 'ecr:PutImage'<br/>        - 'ecr:UploadLayerPart'<br/>    - Sid: AllowPull<br/>      Effect: Allow<br/>      Principal:<br/>        AWS: !Join [':', ['arn:aws:iam:', !Ref 'CustomerAccount', 'root']]<br/>      Action:<br/><strong class="mp iu">        - 'ecr:GetAuthorizationToken'<br/></strong>        - 'ecr:BatchCheckLayerAvailability'<br/>        - 'ecr:GetDownloadUrlForLayer'<br/>        - 'ecr:BatchGetImage'<br/>        - 'ecr:DescribeRepositories' <em class="ko"># optional permission</em><br/>        - 'ecr:DescribeImages' <em class="ko"># optional permission</em></span></pre><p id="c701" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在执行下面的命令部署CloudFormation堆栈<a class="ae kp" href="https://github.com/garystafford/ecr-cross-account-demo/blob/master/ecr-repo-shared.yml" rel="noopener ugc nofollow" target="_blank"> ecr-repo-shared.yml </a>之前，用您的伪客户的AWS帐户ID替换下面显示的<code class="fe mm mn mo mp b">CustomerAccount</code>值。</p><pre class="mb mc md me gt mr mp ms mt aw mu bi"><span id="d5a6" class="mv ky it mp b gy mw mx l my mz"># change me<br/>CUSTOMER_ACCOUNT=<strong class="mp iu">999888777666</strong></span><span id="a935" class="mv ky it mp b gy np mx l my mz">REPO_NAME=rake-app <br/><br/>aws cloudformation create-stack \<br/>    --stack-name ecr-repo-${REPO_NAME} \<br/>    --template-body file://cfn-templates/ecr-repo-shared.yml \<br/>    --parameters \<br/>        ParameterKey=CustomerAccount,ParameterValue=${CUSTOMER_ACCOUNT} \<br/>        ParameterKey=RepoName,ParameterValue=${REPO_NAME} \<br/>    --capabilities CAPABILITY_NAMED_IAM</span></pre><p id="43f8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面，我们看到一个显示新ECR存储库的CloudFormation堆栈示例。</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div class="gh gi na"><img src="../Images/e12f71ab87905fd37da8afe9d02fb215.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*umqL7CnRqTASxnG4"/></div></figure><p id="70c0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面，我们看到ECR存储库策略在<code class="fe mm mn mo mp b">rake-app</code>存储库的Permissions选项卡中被正确应用。第一个策略涵盖了Developer-01 IAM用户(称为IAM实体)和AWS代码构建(称为服务主体)。</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div class="gh gi na"><img src="../Images/ae02f3e593977088b5a988471f8601e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*_G4AOpo6fhFyPrsq"/></div></figure><p id="ef80" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第二个策略包括客户的AWS帐户ID。</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div class="gh gi na"><img src="../Images/bc46c4b5540c4f0a6c5f5aa366be942f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*j5PCClGi0TNmI9cf"/></div></figure><p id="4380" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在客户的AWS帐户中重复此过程。首先是CloudFormation模板，<a class="ae kp" href="https://github.com/garystafford/ecr-cross-account-demo/blob/master/developer-user-group.yml" rel="noopener ugc nofollow" target="_blank">Developer-User-Group . yml</a>，包含开发IAM组和Developer-01用户。</p><pre class="mb mc md me gt mr mp ms mt aw mu bi"><span id="6dbe" class="mv ky it mp b gy mw mx l my mz"># change me<br/>IAM_USER_PSWD=<strong class="mp iu">T0pS3cr3Tpa55w0rD</strong> <br/><br/>aws cloudformation create-stack \<br/>    --stack-name developer-user-group \<br/>    --template-body file://cfn-templates/developer-user-group.yml \<br/>    --parameters \<br/>        ParameterKey=DevUserPassword,ParameterValue=${IAM_USER_PSWD} \<br/>    --capabilities CAPABILITY_NAMED_IAM</span></pre><p id="ebf9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我们将执行第二个CloudFormation模板<a class="ae kp" href="https://github.com/garystafford/ecr-cross-account-demo/blob/master/ecr-repo-not-shared.yml" rel="noopener ugc nofollow" target="_blank">ecr-repo-not-shared . yml</a>两次，分别用于客户的两个ECR存储库<code class="fe mm mn mo mp b">nlp-client</code>和<code class="fe mm mn mo mp b">prose-app</code>。首先，让我们看看模板，特别是<code class="fe mm mn mo mp b">RepositoryPolicyText</code>部分。在这个CloudFormation模板中，我们只定义了一个策略。与供应商的策略相同，<code class="fe mm mn mo mp b">AllowPushPull</code>策略明确允许先前创建的Developer-01 IAM用户将映像版本推送到ECR存储库。不需要跨账户访问客户的两个ECR存储库。</p><pre class="mb mc md me gt mr mp ms mt aw mu bi"><span id="fa2b" class="mv ky it mp b gy mw mx l my mz">RepositoryPolicyText:<br/>  Version: '2012-10-17'<br/>  Statement:<br/>    - Sid: AllowPushPull<br/>      Effect: Allow<br/>      Principal:<br/>        Service: codebuild.amazonaws.com<br/>        AWS:<br/>          Fn::ImportValue:<br/>            !Join [':', [!Ref 'StackName', 'DevUserArn']]<br/>      Action:<br/>        - 'ecr:BatchCheckLayerAvailability'<br/>        - 'ecr:BatchGetImage'<br/>        - 'ecr:CompleteLayerUpload'<br/>        - 'ecr:DescribeImages'<br/>        - 'ecr:DescribeRepositories'<br/>        - 'ecr:GetDownloadUrlForLayer'<br/>        - 'ecr:GetRepositoryPolicy'<br/>        - 'ecr:InitiateLayerUpload'<br/>        - 'ecr:ListImages'<br/>        - 'ecr:PutImage'<br/>        - 'ecr:UploadLayerPart'</span></pre><p id="0158" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">执行以下命令创建两个CloudFormation堆栈。堆栈使用相同的模板，不同的堆栈名称和<code class="fe mm mn mo mp b">RepoName</code>参数值。</p><pre class="mb mc md me gt mr mp ms mt aw mu bi"><span id="0560" class="mv ky it mp b gy mw mx l my mz"># nlp-client<br/>REPO_NAME=nlp-client<br/>aws cloudformation create-stack \<br/>    --stack-name ecr-repo-${REPO_NAME} \<br/>    --template-body file://cfn-templates/ecr-repo-not-shared.yml \<br/>    --parameters \<br/>        ParameterKey=RepoName,ParameterValue=${REPO_NAME} \<br/>    --capabilities CAPABILITY_NAMED_IAM<br/>    <br/># prose-app<br/>REPO_NAME=prose-app <br/>aws cloudformation create-stack \<br/>    --stack-name ecr-repo-${REPO_NAME} \<br/>    --template-body file://cfn-templates/ecr-repo-not-shared.yml \<br/>    --parameters \<br/>        ParameterKey=RepoName,ParameterValue=${REPO_NAME} \<br/>    --capabilities CAPABILITY_NAMED_IAM</span></pre><p id="efff" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面，我们看到了两个ECR库的例子。</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div class="gh gi na"><img src="../Images/cbf2d9157c615676276cb99db1215aad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*qZ5JdPIoc6ZFIlKn"/></div></figure><p id="87c7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">此时，我们在两个AWS帐户上有三个ECR存储库，每个都应用了适当的ECR存储库策略。</p><h1 id="b2db" class="kx ky it bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">构建图像并将其推送到ECR</h1><p id="2adf" class="pw-post-body-paragraph jq jr it js b jt lv jv jw jx lw jz ka kb lx kd ke kf ly kh ki kj lz kl km kn im bi translated">接下来，我们将构建三个NLP应用程序映像，并将其推送到相应的ECR存储库中。要确认ECR策略是否正常工作，请以Developer-01 IAM用户身份登录，执行以下命令。请确保用伪供应商的AWS帐户和地区替换下面的变量值。我在整个代码中使用缩写ISV(独立软件供应商)来表示供应商。</p><pre class="mb mc md me gt mr mp ms mt aw mu bi"><span id="19cd" class="mv ky it mp b gy mw mx l my mz"># change me<br/>ISV_ACCOUNT=<strong class="mp iu">111222333444</strong><br/>ISV_ECR_REGION=<strong class="mp iu">us-east-2</strong><br/><br/>aws ecr get-login-password --region ${ISV_ECR_REGION} \<br/>| docker login --username AWS --password-stdin ${ISV_ACCOUNT}.dkr.ecr.${ISV_ECR_REGION}.amazonaws.com</span></pre><p id="6104" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以供应商的Developer-01 IAM用户身份登录，构建Docker映像并将其推送到<code class="fe mm mn mo mp b">rake-app</code>存储库。Dockerfile和Go源代码位于每个GitHub存储库中。通过Go和Docker <a class="ae kp" href="https://docs.docker.com/develop/develop-images/multistage-build/" rel="noopener ugc nofollow" target="_blank">的多阶段构建</a>，我们将基于<a class="ae kp" href="https://hub.docker.com/_/scratch" rel="noopener ugc nofollow" target="_blank"> Scratch </a>，仅使用编译后的Go可执行二进制文件，制作超小的Docker映像。在不到10-20兆字节的大小，推和拉这些Docker图像，甚至跨帐户，是非常快的。</p><pre class="mb mc md me gt mr mp ms mt aw mu bi"><span id="2279" class="mv ky it mp b gy mw mx l my mz">docker build -t ${ISV_ACCOUNT}.dkr.ecr.${ISV_ECR_REGION}.amazonaws.com/rake-app:1.1.0 . --no-cache</span><span id="efe0" class="mv ky it mp b gy np mx l my mz">docker push ${ISV_ACCOUNT}.dkr.ecr.${ISV_ECR_REGION}.amazonaws.com/rake-app:1.1.0</span></pre><p id="96e3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面，我们看到来自供应商的Developer-01 IAM用户登录到<code class="fe mm mn mo mp b">rake-app</code>存储库的输出。</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div class="gh gi na"><img src="../Images/57c6f033eddb249a6a4d31f231288b3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*z9vVeBr7BQO81NYB"/></div></figure><p id="c150" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们看到了供应商开发IAM用户构建的结果，并将Docker映像推送到<code class="fe mm mn mo mp b">rake-app</code>存储库。</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div class="gh gi na"><img src="../Images/a4c9f345c76f159326b28eb20a272afb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*D15jmEs8ieVPHns-"/></div></figure><p id="b3da" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，在作为客户的Developer-01 IAM用户登录后，构建Docker映像并将其推送到ECR <code class="fe mm mn mo mp b">nlp-client</code>和<code class="fe mm mn mo mp b">prose-app</code>存储库。同样，请确保用您的伪客户的AWS帐户和首选地区替换下面的变量值。</p><pre class="mb mc md me gt mr mp ms mt aw mu bi"><span id="a753" class="mv ky it mp b gy mw mx l my mz"># change me<br/>CUSTOMER_ACCOUNT=<strong class="mp iu">999888777666</strong><br/>CUSTOMER_ECR_REGION=<strong class="mp iu">us-west-2</strong><br/><br/>aws ecr get-login-password --region ${CUSTOMER_ECR_REGION} \<br/>| docker login --username AWS --password-stdin ${CUSTOMER_ACCOUNT}.dkr.ecr.${CUSTOMER_ECR_REGION}.amazonaws.com</span><span id="7c9c" class="mv ky it mp b gy np mx l my mz">docker build -t ${CUSTOMER_ACCOUNT}.dkr.ecr.${CUSTOMER_ECR_REGION}.amazonaws.com/nlp-client:1.1.0 . --no-cache</span><span id="cbfe" class="mv ky it mp b gy np mx l my mz">docker push ${CUSTOMER_ACCOUNT}.dkr.ecr.${CUSTOMER_ECR_REGION}.amazonaws.com/nlp-client:1.1.0<br/><br/>docker build -t ${CUSTOMER_ACCOUNT}.dkr.ecr.${CUSTOMER_ECR_REGION}.amazonaws.com/prose-app:1.1.0 . --no-cache</span><span id="3528" class="mv ky it mp b gy np mx l my mz">docker push ${CUSTOMER_ACCOUNT}.dkr.ecr.${CUSTOMER_ECR_REGION}.amazonaws.com/prose-app:1.1.0</span></pre><p id="14b0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">此时，三个ECR存储库中的每一个都有一个Docker映像推送给它们。</p><h1 id="6df2" class="kx ky it bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">本地部署到Docker Swarm</h1><p id="74a1" class="pw-post-body-paragraph jq jr it js b jt lv jv jw jx lw jz ka kb lx kd ke kf ly kh ki kj lz kl km kn im bi translated">作为跨帐户ECS访问的简单演示，我们将从Docker Swarm开始。以客户的Developer-01 IAM用户身份登录，并使用项目中包含的<a class="ae kp" href="https://docs.docker.com/engine/swarm/stack-deploy/" rel="noopener ugc nofollow" target="_blank"> Docker Swarm Stack </a>文件，我们可以在客户的帐户中创建并运行NLP应用程序的本地副本。首先，我们需要登录供应商的ECR存储库，以便从供应商的ECR注册表中提取映像。</p><pre class="mb mc md me gt mr mp ms mt aw mu bi"><span id="ec7b" class="mv ky it mp b gy mw mx l my mz"># change me<br/>ISV_ACCOUNT=<strong class="mp iu">111222333444<br/></strong>ISV_ECR_REGION=<strong class="mp iu">us-east-2<br/><br/></strong>aws ecr get-login \<br/>    --registry-ids ${ISV_ACCOUNT} \<br/>    --region ${ISV_ECR_REGION} \<br/>    --no-include-email</span></pre><p id="a6bd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mm mn mo mp b">aws ecr get-login</code>命令通过返回一个(非常长的)<code class="fe mm mn mo mp b">docker login</code>命令作为响应(下面的<em class="ko">显示为</em>的缩写)来简化登录过程。根据<a class="ae kp" href="https://docs.aws.amazon.com/AmazonECR/latest/APIReference/API_GetAuthorizationToken.html" rel="noopener ugc nofollow" target="_blank"> AWS </a>，为每个指定的注册中心返回的<code class="fe mm mn mo mp b">authorizationToken</code>是一个base64编码的字符串，该字符串可以被解码并在<code class="fe mm mn mo mp b">docker login</code>命令中用于向ECR注册中心进行认证。</p><pre class="mb mc md me gt mr mp ms mt aw mu bi"><span id="5ff9" class="mv ky it mp b gy mw mx l my mz">docker login -u AWS -p eyJwYXlsb2FkI...joidENXMWg1WW0 \<br/>    https://111222333444.dkr.ecr.us-east-2.amazonaws.com</span></pre><p id="3507" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">将整个<code class="fe mm mn mo mp b">docker login</code>命令复制、粘贴并执行回你的终端。下面，我们看到一个登录到供应商ECR存储库的预期终端输出的示例。</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div class="gh gi na"><img src="../Images/7569b9dd3f5d7c1b14804dcf57bc7b73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*hKJG7bcRxMxqlCFU"/></div></figure><p id="db5f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一旦成功登录到供应商的ECR存储库，我们将提取映像。如果您不确定，我们可以使用<code class="fe mm mn mo mp b">docker describe-repositories</code>和<code class="fe mm mn mo mp b">docker describe-images</code>列出您的IAM用户可以访问的跨帐户存储库和图像。</p><pre class="mb mc md me gt mr mp ms mt aw mu bi"><span id="2505" class="mv ky it mp b gy mw mx l my mz">aws ecr describe-repositories \<br/>    --registry-id ${ISV_ACCOUNT} \<br/>    --region ${ISV_ECR_REGION} \<br/>    --repository-name rake-app<br/><br/>aws ecr describe-images \<br/>    --registry-id ${ISV_ACCOUNT} \<br/>    --region ${ISV_ECR_REGION} \<br/>    --repository-name rake-app<br/><br/>docker pull ${ISV_ACCOUNT}.dkr.ecr.${ISV_ECR_REGION}.amazonaws.com/rake-app:1.1.0</span></pre><p id="f98a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">运行以下命令，您应该会看到我们的三个应用程序Docker映像。</p><pre class="mb mc md me gt mr mp ms mt aw mu bi"><span id="d9e9" class="mv ky it mp b gy mw mx l my mz">docker image ls --filter=reference='*amazonaws.com/*'</span></pre><p id="e272" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面，我们看到了一个从拉取图像并列出图像的预期终端输出的例子。</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div class="gh gi na"><img src="../Images/3976bc3f37bc4dd7af1678a9fddafb79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*psezATPUAz013xxs"/></div></figure><h1 id="2d5d" class="kx ky it bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">在本地构建Docker堆栈</h1><p id="77e2" class="pw-post-body-paragraph jq jr it js b jt lv jv jw jx lw jz ka kb lx kd ke kf ly kh ki kj lz kl km kn im bi translated">接下来，构建Docker Swarm堆栈。Docker合成文件<a class="ae kp" href="https://github.com/garystafford/ecr-cross-account-demo/blob/master/stack.yml" rel="noopener ugc nofollow" target="_blank"> stack.yml </a>如下所示。注意图像的位置。</p><pre class="mb mc md me gt mr mp ms mt aw mu bi"><span id="1bb5" class="mv ky it mp b gy mw mx l my mz">version: '3.7'<br/><br/>services:<br/>  nlp-client:<br/>    image: ${CUSTOMER_ACCOUNT}.dkr.ecr.${CUSTOMER_ECR_REGION}.amazonaws.com/nlp-client:1.1.0<br/>    networks:<br/>      - nlp-demo<br/>    ports:<br/>      - 8080:8080<br/>    environment:<br/>      - NLP_CLIENT_PORT<br/>      - RACK_ENDPOINT<br/>      - PROSE_ENDPOINT<br/>      - API_KEY<br/>  rake-app:<br/>    image: ${ISV_ACCOUNT}.dkr.ecr.${ISV_ECR_REGION}.amazonaws.com/rake-app:1.1.0<br/>    networks:<br/>      - nlp-demo<br/>    environment:<br/>      - RAKE_PORT<br/>      - API_KEY<br/>  prose-app:<br/>    image: ${CUSTOMER_ACCOUNT}.dkr.ecr.${CUSTOMER_ECR_REGION}.amazonaws.com/prose-app:1.1.0<br/>    networks:<br/>      - nlp-demo<br/>    environment:<br/>      - PROSE_PORT<br/>      - API_KEY<br/><br/>networks:<br/>  nlp-demo:<br/><br/>volumes:<br/>  data: {}</span></pre><p id="9f61" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">执行以下命令将Docker栈部署到Docker Swarm。同样，请确保用您的伪供应商和客户的AWS帐户和地区替换下面的变量值。此外，API使用API密钥来保护所有三个服务中除了<code class="fe mm mn mo mp b">/health</code>端点之外的所有公开端点。您应该将默认的CloudFormation模板的API Key参数更改为更安全的参数。</p><pre class="mb mc md me gt mr mp ms mt aw mu bi"><span id="54e4" class="mv ky it mp b gy mw mx l my mz"># change me<br/>export ISV_ACCOUNT=<strong class="mp iu">111222333444</strong><br/>export ISV_ECR_REGION=<strong class="mp iu">us-east-2</strong><br/>export CUSTOMER_ACCOUNT=<strong class="mp iu">999888777666</strong><br/>export CUSTOMER_ECR_REGION=<strong class="mp iu">us-west-2</strong></span><span id="4f2d" class="mv ky it mp b gy np mx l my mz">export API_KEY=<strong class="mp iu">SuP3r5eCRetAutHK3y</strong><br/> <br/># don't change me<br/>export NLP_CLIENT_PORT=8080<br/>export RAKE_PORT=8080<br/>export PROSE_PORT=8080<br/>export RACK_ENDPOINT=<a class="ae kp" href="http://rake-app:8080" rel="noopener ugc nofollow" target="_blank">http://rake-app:8080</a><br/>export PROSE_ENDPOINT=<a class="ae kp" href="http://prose-app:8080" rel="noopener ugc nofollow" target="_blank">http://prose-app:8080</a><br/> <br/>docker swarm init <br/>docker stack deploy --compose-file stack.yml nlp</span></pre><p id="33bb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可以使用以下命令检查部署是否成功:</p><pre class="mb mc md me gt mr mp ms mt aw mu bi"><span id="89ce" class="mv ky it mp b gy mw mx l my mz">docker stack ps nlp --no-trunc docker container ls</span></pre><p id="240c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面，我们看到一个预期终端输出的例子。</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div class="gh gi na"><img src="../Images/d91c10634fa861f8287fa8c570d3b6ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*w_knProEJPB9-c7F"/></div></figure><p id="941e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有了Docker栈，可以直接在<code class="fe mm mn mo mp b">localhost:8080</code>上打<code class="fe mm mn mo mp b">nlp-client</code>服务。Fargate要求任务中的每个容器都有唯一的静态端口，与此不同，使用Docker，我们可以选择在同一个端口上运行所有的容器，而不会发生冲突，因为只有<code class="fe mm mn mo mp b">nlp-client</code>服务公开端口<code class="fe mm mn mo mp b">:8080</code>。此外，与ECS不同，堆栈前没有负载平衡器，因为我们的群中只有一个节点，因此每个微服务只有一个容器实例。</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/470f8139772f4f94a9fbf26c9cbd68ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:884/format:webp/1*j0KaDOHgbL7mBcR-U-H55Q.png"/></div></figure><p id="7a4f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了测试图像是否被成功提取以及Docker栈是否正在运行，我们可以对任何API端点执行一个<a class="ae kp" href="https://curl.haxx.se/" rel="noopener ugc nofollow" target="_blank"> curl </a>命令，比如<code class="fe mm mn mo mp b">/keywords</code>。下面，我使用<a class="ae kp" href="https://stedolan.github.io/jq/" rel="noopener ugc nofollow" target="_blank"> jq </a>来打印JSON响应负载。</p><pre class="mb mc md me gt mr mp ms mt aw mu bi"><span id="99f8" class="mv ky it mp b gy mw mx l my mz">#change me<br/>API_KEY=<strong class="mp iu">SuP3r5eCRetAutHK3y</strong><br/><br/>curl -s -X POST \<br/>    "http://localhost:${NLP_CLIENT_PORT}/keywords" \<br/>    -H 'Content-Type: application/json' \<br/>    -H "X-API-Key: ${API_KEY}" \<br/>    -d '{"text": "The Internet is the global system of interconnected computer networks that use the Internet protocol suite to link devices worldwide."}' | jq</span></pre><p id="a9f3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">产生的JSON负载应该类似于下面的输出。这些结果表明<code class="fe mm mn mo mp b">nlp-client</code>服务已经成功到达，并且随后能够与<code class="fe mm mn mo mp b">rake-app</code>服务通信，后者的容器映像来自供应商的ECR存储库。</p><pre class="mb mc md me gt mr mp ms mt aw mu bi"><span id="bff6" class="mv ky it mp b gy mw mx l my mz">[<br/>    {<br/>        "candidate": "interconnected computer networks",<br/>        "score": 9<br/>    },<br/>    {<br/>        "candidate": "link devices worldwide",<br/>        "score": 9<br/>    },<br/>    {<br/>        "candidate": "internet protocol suite",<br/>        "score": 8<br/>    },<br/>    {<br/>        "candidate": "global system",<br/>        "score": 4<br/>    },<br/>    {<br/>        "candidate": "internet",<br/>        "score": 2<br/>    }<br/>]</span></pre><h1 id="ce4a" class="kx ky it bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">创建Amazon ECS环境</h1><p id="2e25" class="pw-post-body-paragraph jq jr it js b jt lv jv jw jx lw jz ka kb lx kd ke kf ly kh ki kj lz kl km kn im bi translated">虽然在本地使用Docker Swarm是理解跨帐户ECR访问如何工作的一种很好的方式，但它不是在AWS平台上部署容器化应用程序的典型用例。更多的时候，你可以使用亚马逊ECS、<a class="ae kp" href="https://aws.amazon.com/eks/" rel="noopener ugc nofollow" target="_blank">亚马逊弹性Kubernetes服务</a> (EKS)，或者企业版的第三方编排器，比如<a class="ae kp" href="https://www.docker.com/products/docker-enterprise" rel="noopener ugc nofollow" target="_blank"> Docker Enterprise </a>、<a class="ae kp" href="https://www.openshift.com/" rel="noopener ugc nofollow" target="_blank"> RedHat OpenShift </a>或者<a class="ae kp" href="https://rancher.com/products/rancher" rel="noopener ugc nofollow" target="_blank"> Rancher </a>。</p><p id="c116" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用CloudFormation和Amazon提供的一些非常方便的<a class="ae kp" href="https://github.com/aws-samples/ecs-refarch-cloudformation" rel="noopener ugc nofollow" target="_blank"> CloudFormation模板</a>作为起点，我们将为我们的应用程序创建一个完整的ECS环境。首先，我们将使用<a class="ae kp" href="https://github.com/garystafford/ecr-cross-account-demo/blob/master/public-vpc.yml" rel="noopener ugc nofollow" target="_blank"> public-vpc.yml </a>模板创建一个VPC来容纳ECS集群，并创建一个面向公众的ALB来呈现基于ECS的应用程序。</p><pre class="mb mc md me gt mr mp ms mt aw mu bi"><span id="a72b" class="mv ky it mp b gy mw mx l my mz">aws cloudformation create-stack \<br/>    --stack-name public-vpc \<br/>    --template-body file://public-vpc.yml \<br/>    --capabilities CAPABILITY_NAMED_IAM</span></pre><p id="124a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我们将使用<a class="ae kp" href="https://github.com/garystafford/ecr-cross-account-demo/blob/master/public-subnet-public-loadbalancer.yml" rel="noopener ugc nofollow" target="_blank">public-subnet-public-load balancer . yml</a>模板创建ECS集群和Amazon ECS任务定义。同样，任务定义定义了ECS将如何使用<a class="ae kp" href="https://aws.amazon.com/fargate/" rel="noopener ugc nofollow" target="_blank"> AWS Fargate </a>部署我们的应用程序。Amazon Fargate允许您运行容器，而不必管理服务器或集群。没有要管理的EC2实例！呜！下面，在CloudFormation模板中，我们看到<code class="fe mm mn mo mp b">TaskDefinition</code>资源的<code class="fe mm mn mo mp b">ContainerDefinitions</code>部分，包含三个容器定义。请注意这三个图像及其ECR位置。</p><pre class="mb mc md me gt mr mp ms mt aw mu bi"><span id="98c5" class="mv ky it mp b gy mw mx l my mz">ContainerDefinitions:<br/>  - Name: nlp-client<br/>    Cpu: 256<br/>    Memory: 1024<br/>    Image: !Join ['.', [!Ref AWS::AccountId, 'dkr.ecr', !Ref AWS::Region, 'amazonaws.com/nlp-client:1.1.0']] <br/>    PortMappings:<br/>      - ContainerPort: !Ref ContainerPortClient<br/>    Essential: true<br/>    LogConfiguration:<br/>      LogDriver: awslogs<br/>      Options:<br/>        awslogs-region: !Ref AWS::Region<br/>        awslogs-group: !Ref CloudWatchLogsGroup<br/>        awslogs-stream-prefix: ecs<br/>    Environment:<br/>      - Name: NLP_CLIENT_PORT<br/>        Value: !Ref ContainerPortClient<br/>      - Name: RACK_ENDPOINT<br/>        Value: !Join [':', ['http://localhost', !Ref ContainerPortRake]] <br/>      - Name: PROSE_ENDPOINT<br/>        Value: !Join [':', ['http://localhost', !Ref ContainerPortProse]] <br/>      - Name: API_KEY<br/>        Value: !Ref ApiKey<br/>  - Name: rake-app<br/>    Cpu: 256<br/>    Memory: 1024<br/>    Image: !Join ['.', [!Ref VendorAccountId, 'dkr.ecr', !Ref VendorEcrRegion, 'amazonaws.com/rake-app:1.1.0']] <br/>    Essential: true<br/>    LogConfiguration:<br/>      LogDriver: awslogs<br/>      Options:<br/>        awslogs-region: !Ref AWS::Region<br/>        awslogs-group: !Ref CloudWatchLogsGroup<br/>        awslogs-stream-prefix: ecs<br/>    Environment:<br/>      - Name: RAKE_PORT<br/>        Value: !Ref ContainerPortRake<br/>      - Name: API_KEY<br/>        Value: !Ref ApiKey<br/>  - Name: prose-app<br/>    Cpu: 256<br/>    Memory: 1024<br/>    Image: !Join ['.', [!Ref AWS::AccountId, 'dkr.ecr', !Ref AWS::Region, 'amazonaws.com/prose-app:1.1.0']] <br/>    Essential: true<br/>    LogConfiguration:<br/>      LogDriver: awslogs<br/>      Options:<br/>        awslogs-region: !Ref AWS::Region<br/>        awslogs-group: !Ref CloudWatchLogsGroup<br/>        awslogs-stream-prefix: ecs<br/>    Environment:<br/>      - Name: PROSE_PORT<br/>        Value: !Ref ContainerPortProse<br/>      - Name: API_KEY<br/>        Value: !Ref ApiKey</span></pre><p id="067c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">执行以下命令，使用CloudFormation模板创建ECS集群和Amazon ECS任务定义。</p><pre class="mb mc md me gt mr mp ms mt aw mu bi"><span id="aa1b" class="mv ky it mp b gy mw mx l my mz"># change me<br/>ISV_ACCOUNT=<strong class="mp iu">111222333444</strong><br/>ISV_ECR_REGION=<strong class="mp iu">us-east-2</strong><br/>API_KEY=<strong class="mp iu">SuP3r5eCRetAutHK3y</strong></span><span id="d06b" class="mv ky it mp b gy np mx l my mz">aws cloudformation create-stack \<br/>    --stack-name public-subnet-public-loadbalancer \<br/>    --template-body file://public-subnet-public-loadbalancer.yml \<br/>    --parameters \<br/>        ParameterKey=VendorAccountId,ParameterValue=${ISV_ACCOUNT} \<br/>        ParameterKey=VendorEcrRegion,ParameterValue=${ISV_ECR_REGION} \<br/>        ParameterKey=AuthKey,ParameterValue=${API_KEY} \<br/>    --capabilities CAPABILITY_NAMED_IAM</span></pre><p id="ad41" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面，我们看到了一个来自CloudFormation管理控制台的预期输出示例。</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div class="gh gi na"><img src="../Images/eb270d0c0f22aecc1039ae134dc9285f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*Yx1ekS_0qhG4OEs9"/></div></figure><p id="7355" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">CloudFormation模板默认不启用<a class="ae kp" href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/ContainerInsights.html" rel="noopener ugc nofollow" target="_blank"> CloudWatch容器洞察</a>。Insights从您的容器化应用程序中收集、汇总和总结指标和日志。要启用洞察，请执行以下命令:</p><pre class="mb mc md me gt mr mp ms mt aw mu bi"><span id="99c9" class="mv ky it mp b gy mw mx l my mz">aws ecs put-account-setting --name "containerInsights" --value "enabled"</span></pre><h1 id="f0e8" class="kx ky it bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">确认交叉账户政策</h1><p id="c702" class="pw-post-body-paragraph jq jr it js b jt lv jv jw jx lw jz ka kb lx kd ke kf ly kh ki kj lz kl km kn im bi translated">如果前面的步骤一切顺利，我们现在应该有一个ECS集群运行我们的容器化应用程序，包括从供应商的Docker映像构建的容器。下面，我们看到了管理控制台中显示的ECS群集示例。</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div class="gh gi na"><img src="../Images/29dee76b93e04601a4a60435df95d59f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*vFzmo_Bp4BWKVlU6"/></div></figure><p id="3b86" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在ECR集群中，我们应该观察到一个正在运行的<a class="ae kp" href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs_services.html" rel="noopener ugc nofollow" target="_blank"> ECS服务</a>。根据AWS，Amazon ECS允许您在Amazon ECS集群中同时运行和维护指定数量的任务定义实例。这叫做服务。</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div class="gh gi na"><img src="../Images/f71a25c4a72202382f602e078106492d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*l6rhE4Bo3dhyAgEy"/></div></figure><p id="fa32" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们在ECS上运行每个容器的两个实例，因此在一个服务中有两个任务副本。每个任务在不同的<a class="ae kp" href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html" rel="noopener ugc nofollow" target="_blank">可用性区域</a>中运行其容器，以获得高可用性。</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div class="gh gi na"><img src="../Images/bafb673695fed05dd0455212ed8718f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*s376pj0GXgExcCa9"/></div></figure><p id="2baf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">深入研究该服务，我们应该注意到与新VPC相关联的新ALB、两个公共子网和相应的安全组。</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div class="gh gi na"><img src="../Images/f20164587b1ec787aaf0065e56953a9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*Bm1gvPRUklROV7Ox"/></div></figure><p id="ccc6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">切换到Task Definitions选项卡，我们应该可以看到您的任务的详细信息。请注意组成应用程序的三个容器。请注意，两个位于客户的ECR存储库中，一个位于供应商的ECR存储库中。</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div class="gh gi na"><img src="../Images/271398093155b86db4ccdcef8aba674c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*tyvW5p45PIUIO4WZ"/></div></figure><p id="e459" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">再深入一点，我们将看到每个容器定义的细节，包括从ECR传递到容器的环境变量，以及在容器中运行的实际Go-binary。</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div class="gh gi na"><img src="../Images/314a4909683d8815c03a1d933a228560.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*BXnZoT_4xDB4-41x"/></div></figure><h1 id="0fa6" class="kx ky it bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">在ECS上实现我们的应用</h1><p id="426d" class="pw-post-body-paragraph jq jr it js b jt lv jv jw jx lw jz ka kb lx kd ke kf ly kh ki kj lz kl km kn im bi translated">在我们之前的Docker Swarm示例中，curl命令是针对<code class="fe mm mn mo mp b">/localhost</code>发出的，而现在我们在基于ECS的应用程序前面有了面向公众的应用程序负载平衡器(ALB)。我们将需要使用您的ALB的DNS名称作为主机，以在ECS上运行我们的应用程序。DNS地址(记录)可以从负载平衡器管理控制台获得，如下所示，或者从<code class="fe mm mn mo mp b">public-vpc</code> CloudFormation堆栈的输出选项卡获得</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div class="gh gi na"><img src="../Images/2eb6ab8769e43eba23af39efd74bc544.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*FSxewsjPVj-gIHa2"/></div></figure><p id="94ff" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">早期Docker Swarm示例和ECS的另一个不同之处是端口。虽然边缘服务<code class="fe mm mn mo mp b">nlp-client</code>运行在端口<code class="fe mm mn mo mp b">:8080</code>上，但是ALB充当反向代理，将请求从ALB上的端口<code class="fe mm mn mo mp b">:80</code>传递到<code class="fe mm mn mo mp b">nlp-client</code>容器实例的端口<code class="fe mm mn mo mp b">:8080</code>(实际上，<a class="ae kp" href="https://aws.amazon.com/blogs/compute/task-networking-in-aws-fargate/" rel="noopener ugc nofollow" target="_blank">共享运行任务的ENI </a>)。为了简洁起见，我没有为ALB设置自定义的DNS名称，也没有像在生产中那样为HTTPS设置。</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div class="gh gi na"><img src="../Images/87586343b89fea0ab3cb94a1c2a3b154.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*VIh_1WARlyyNDFDk"/></div></figure><p id="3880" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了测试我们部署的ECS，我们可以使用像<code class="fe mm mn mo mp b">curl</code>或<a class="ae kp" href="https://www.getpostman.com/" rel="noopener ugc nofollow" target="_blank"> Postman </a>这样的工具来测试API的端点。下面，我们看到一个针对<code class="fe mm mn mo mp b">/tokens</code>端点的POST，使用的是Postman。不要忘记，您将需要添加Auth，即“X-API-Key”标题键/值对。</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div class="gh gi na"><img src="../Images/d21bdf2e5d36504502975b39b4d0d8ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*0EvJ4Z2PuS3PxwTU"/></div></figure><h1 id="28af" class="kx ky it bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">清理</h1><p id="02a2" class="pw-post-body-paragraph jq jr it js b jt lv jv jw jx lw jz ka kb lx kd ke kf ly kh ki kj lz kl km kn im bi translated">要清理演示的AWS资源和Docker堆栈，请在适当的AWS帐户中运行以下脚本。重要的是，与S3类似，在删除存储库之前，您必须首先删除ECR存储库中的所有Docker映像，否则您将收到一个CloudFormation错误。这包括<code class="fe mm mn mo mp b">untagged</code>图像。</p><pre class="mb mc md me gt mr mp ms mt aw mu bi"><span id="4b0a" class="mv ky it mp b gy mw mx l my mz"># customer account only<br/>aws ecr batch-delete-image \<br/>    --repository-name nlp-client \<br/>    --image-ids imageTag=1.1.0<br/><br/>aws ecr batch-delete-image \<br/>    --repository-name prose-app \<br/>    --image-ids imageTag=1.1.0<br/><br/>aws cloudformation delete-stack \<br/>    --stack-name ecr-repo-nlp-client<br/><br/>aws cloudformation delete-stack \<br/>    --stack-name ecr-repo-prose-app<br/><br/>aws cloudformation delete-stack \<br/>    --stack-name public-subnet-public-loadbalancer<br/><br/>aws cloudformation delete-stack \<br/>    --stack-name public-vpc</span><span id="9c36" class="mv ky it mp b gy np mx l my mz">docker stack rm nlp</span><span id="ddbb" class="mv ky it mp b gy np mx l my mz"><br/># vendor account only<br/>aws ecr batch-delete-image \<br/>    --repository-name rake-app \<br/>    --image-ids imageTag=1.1.0<br/><br/>aws cloudformation delete-stack \<br/>    --stack-name ecr-repo-rake-app</span><span id="dfa6" class="mv ky it mp b gy np mx l my mz"><br/># both accounts<br/>aws cloudformation delete-stack \<br/>    --stack-name developer-user-group</span></pre><p id="d978" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在前一篇文章中，我们看到了多个AWS帐户如何共享基于ECR的Docker图像。根据您使用的部署工具，如AWS CodeBuild、AWS CodeDeploy或AWS Elastic Beanstalk，ECR存储库策略的配置有所不同和限制。AWS在他们的文档中很好地提供了一些例子，包括<a class="ae kp" href="https://docs.aws.amazon.com/AmazonECR/latest/userguide/RepositoryPolicyExamples.html" rel="noopener ugc nofollow" target="_blank">亚马逊ECR仓库策略例子</a>和<a class="ae kp" href="https://docs.aws.amazon.com/AmazonECR/latest/userguide/security_iam_id-based-policy-examples.html" rel="noopener ugc nofollow" target="_blank">亚马逊弹性容器注册基于身份的策略例子</a>。</p><p id="8c94" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ko">本文表达的所有观点都是我个人的，不一定代表我现在或过去的雇主或他们的客户的观点。</em></p></div><div class="ab cl kq kr hx ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="im in io ip iq"><p id="9ad2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ko">原载于2019年10月28日</em><a class="ae kp" href="https://programmaticponderings.com/2019/10/28/amazon-ecr-cross-account-access-for-containerized-applications-on-ecs/" rel="noopener ugc nofollow" target="_blank"><em class="ko">http://programmaticponderings.com</em></a><em class="ko">。</em></p></div></div>    
</body>
</html>