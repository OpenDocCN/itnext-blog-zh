<html>
<head>
<title>Getting Started with Roslyn C# Scripting API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Roslyn C#脚本API入门</h1>
<blockquote>原文：<a href="https://itnext.io/getting-start-with-roslyn-c-scripting-api-d2ea10338d2b?source=collection_archive---------1-----------------------#2020-03-03">https://itnext.io/getting-start-with-roslyn-c-scripting-api-d2ea10338d2b?source=collection_archive---------1-----------------------#2020-03-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/68e6afffc4de4830c080239c9dd28d9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_U-IbRFg1-wnx8drORoW6g.png"/></div></div></figure><p id="4b84" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">。NET编译器平台或罗斯林是在市场上一段时间。罗斯林是一套编译器，代码分析API。网络语言。它也是运行时执行动态代码运行时的脚本API。</p><p id="7eb8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当然，并不是所有的平台都支持脚本API，因为它需要桌面。NET Framework 4.6+或。NET Core 1.1(自<a class="ae kz" href="https://www.nuget.org/packages/Microsoft.CodeAnalysis.Scripting/2.0.0-rc3" rel="noopener ugc nofollow" target="_blank"> Roslyn v2.0.0-rc3 </a>，Visual Studio 2017 RC3开始支持)。脚本API不能在UWA和。因为应用程序模型不支持加载运行时生成的代码。虽然最新稳定版的脚本API只支持针对<strong class="kd iu">的项目。网标二</strong>以上。</p></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><h2 id="a179" class="lh li it bd lj lk ll dn lm ln lo dp lp km lq lr ls kq lt lu lv ku lw lx ly lz bi translated">让我们写一点脚本</h2><p id="0003" class="pw-post-body-paragraph kb kc it kd b ke ma kg kh ki mb kk kl km mc ko kp kq md ks kt ku me kw kx ky im bi translated">为了能够在中使用脚本API。NET，<a class="ae kz" href="https://www.nuget.org/packages/Microsoft.CodeAnalysis.CSharp.Scripting/" rel="noopener ugc nofollow" target="_blank">微软。code analysis . cs harp . scripting</a>包必须安装在您的项目上。</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="f570" class="lh li it mk b gy mo mp l mq mr">dotnet add package Microsoft.CodeAnalysis.CSharp.Scripting</span></pre><p id="5d7f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">API本身设计良好，易于使用，几乎涵盖了从添加引用、编译到评估简单代码的大部分场景。您可以在<code class="fe ms mt mu mk b">Micorosft.CodeAnalysis.CSharp.Scripting</code>中访问<code class="fe ms mt mu mk b">CSharpScript</code>类。</p><p id="e296" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在下面的代码中，它读取用户在控制台输入中键入的任何内容，并立即执行并返回结果。</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="ac39" class="lh li it mk b gy mo mp l mq mr">// Nampespace below should be used to use CSharpScript<br/>// using Microsoft.CodeAnalysis.CSharp.Scripting;</span><span id="2547" class="lh li it mk b gy mv mp l mq mr">while(true)<br/>{<br/> var codeToEval = Console.ReadLine();<br/> var result = await CSharpScript.EvaluateAsync(codeToEval);<br/> Console.WriteLine(result);<br/>}</span></pre><figure class="mf mg mh mi gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mw"><img src="../Images/59f713deab4b5ef80341ee3aa2a80eeb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Yt6WcKe0gXNobiLiNwT6Rw.gif"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">示例代码的运行</figcaption></figure><p id="e8db" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe ms mt mu mk b">CsharpScript.EvaluateAsync</code>方法是一种评估字符串代码的异步方法。如果您喜欢强类型eval，可以使用它的泛型方法。</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="99c5" class="lh li it mk b gy mo mp l mq mr">int sum = await CsharpScript.EvaluateAsync&lt;int&gt;("1 + 2");</span></pre><h2 id="a620" class="lh li it bd lj lk ll dn lm ln lo dp lp km lq lr ls kq lt lu lv ku lw lx ly lz bi translated">添加命名空间</h2><p id="506d" class="pw-post-body-paragraph kb kc it kd b ke ma kg kh ki mb kk kl km mc ko kp kq md ks kt ku me kw kx ky im bi translated">正如你在上面的例子中看到的，我使用完全限定来使用像<code class="fe ms mt mu mk b">System.DateTime</code>这样的方法。您可以通过在EvaluateAsync方法中使用<code class="fe ms mt mu mk b">ScriptOptions</code>参数来实现。</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="f437" class="lh li it mk b gy mo mp l mq mr">while(true)<br/>{<br/> var codeToEval = Console.ReadLine();</span><span id="c255" class="lh li it mk b gy mv mp l mq mr">var result = await CSharpScript.EvaluateAsync(codeToEval,  ScriptOptions.Default.WithImports("System")); <br/>     <br/> Console.WriteLine(result);<br/>}</span></pre><p id="80e6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe ms mt mu mk b">ScriptOptions.Default.WithImports("System")</code>将<code class="fe ms mt mu mk b">using System;</code>添加到脚本中。</p><figure class="mf mg mh mi gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nb"><img src="../Images/9c1d3332551ef8e087dc4275babb4423.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m8Xm6eCFkDzrlogmZkiFng.png"/></div></div></figure><p id="c92a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在你可以看到，我对代码进行了无条件评估。</p><h2 id="ad81" class="lh li it bd lj lk ll dn lm ln lo dp lp km lq lr ls kq lt lu lv ku lw lx ly lz bi translated">向脚本中添加类型的成员</h2><p id="4cc6" class="pw-post-body-paragraph kb kc it kd b ke ma kg kh ki mb kk kl km mc ko kp kq md ks kt ku me kw kx ky im bi translated">你们都和<code class="fe ms mt mu mk b">System.Math</code>班合作过。有时，您更喜欢将类成员添加到脚本中直接使用，而不调用它们的类名。例如，而不是<code class="fe ms mt mu mk b">System.Math.Abs</code>只说<code class="fe ms mt mu mk b">Abs</code>。像添加引用一样，如果您使用带有类名的<code class="fe ms mt mu mk b">WithImports</code>，它会添加<code class="fe ms mt mu mk b">using static System.Math;</code>。</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="272f" class="lh li it mk b gy mo mp l mq mr">while(true)<br/>{<br/> var codeToEval = Console.ReadLine();</span><span id="86ed" class="lh li it mk b gy mv mp l mq mr">var result = await CSharpScript.EvaluateAsync(codeToEval, ScriptOptions.Default.WithImports("System.Math"));  <br/>    <br/> Console.WriteLine(result);<br/>}</span></pre><figure class="mf mg mh mi gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi gj"><img src="../Images/6e74a78532d10d178dc219da7ec17229.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zdcykEeONJ7RKAU9m1-UUQ.png"/></div></div></figure><h2 id="f332" class="lh li it bd lj lk ll dn lm ln lo dp lp km lq lr ls kq lt lu lv ku lw lx ly lz bi translated">添加引用</h2><p id="8e1a" class="pw-post-body-paragraph kb kc it kd b ke ma kg kh ki mb kk kl km mc ko kp kq md ks kt ku me kw kx ky im bi translated">使用<code class="fe ms mt mu mk b">WithReferences</code>方法添加引用也很容易。</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="88b3" class="lh li it mk b gy mo mp l mq mr">var result = await CSharpScript.EvaluateAsync("System.Net.Dns.GetHostName()", ScriptOptions.Default.WithReferences(typeof(System.Net.Dns).Assembly));</span></pre></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><h2 id="ffa4" class="lh li it bd lj lk ll dn lm ln lo dp lp km lq lr ls kq lt lu lv ku lw lx ly lz bi translated">前一次评估的持续评估</h2><p id="cf96" class="pw-post-body-paragraph kb kc it kd b ke ma kg kh ki mb kk kl km mc ko kp kq md ks kt ku me kw kx ky im bi translated">在之前的所有样本中，我们只逐行评估，这些样本之间没有任何关联。假设我们想要评估以下输入:</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="0d27" class="lh li it mk b gy mo mp l mq mr">line1: int a = 1;<br/>line2: int b = 2;<br/>line3: int c = a + b ;<br/>line4: Console.WriteLine(c);</span></pre><p id="737c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于这种场景，首先，您使用<code class="fe ms mt mu mk b">RunAsync</code>评估并运行该方法，然后您可以使用<code class="fe ms mt mu mk b">ContinueWithAsync</code>继续相同的上下文。</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="2b8d" class="lh li it mk b gy mo mp l mq mr">var state = await CSharpScript.RunAsync("int a = 1;");</span><span id="f29b" class="lh li it mk b gy mv mp l mq mr">state = await state.ContinueWithAsync("int b = 2;");<br/>state = await state.ContinueWithAsync("int c = a + b;");<br/>state = await state.ContinueWithAsync("c");</span><span id="1e79" class="lh li it mk b gy mv mp l mq mr">Console.WriteLine(state.ReturnValue);</span></pre><p id="0734" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">每当你用RunAsync或ContinueWithAsync评估你的代码时，你可以通过<code class="fe ms mt mu mk b">ReturnValue</code>属性得到值。</p><p id="bafe" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">💡如果被评估的代码没有任何返回值，如<code class="fe ms mt mu mk b">int a =1;</code>,<code class="fe ms mt mu mk b">ReturnValue</code>属性将为空。</p><h2 id="8f24" class="lh li it bd lj lk ll dn lm ln lo dp lp km lq lr ls kq lt lu lv ku lw lx ly lz bi translated">错误处理</h2><p id="aba7" class="pw-post-body-paragraph kb kc it kd b ke ma kg kh ki mb kk kl km mc ko kp kq md ks kt ku me kw kx ky im bi translated">您可以通过一个简单的try-catch块来捕获<code class="fe ms mt mu mk b">CompilationErrorException</code>异常，从而实现错误处理。</p><figure class="mf mg mh mi gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nc"><img src="../Images/c977cd97effd360907ed9d9a0c3930d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ejX_Bp_o1t9GEtk6qQu45w.png"/></div></div></figure><p id="afea" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这个异常类有<code class="fe ms mt mu mk b">Diagnostics</code>属性，有了这个属性，你可以访问所有的编译问题。</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="ac9a" class="lh li it mk b gy mo mp l mq mr">try<br/>{<br/> var result = await CSharpScript.EvaluateAsync(codeToEval);<br/> Console.WriteLine(result);<br/>}<br/>catch (CompilationErrorException e)<br/>{<br/> Console.WriteLine(string.Join(Environment.NewLine, e.Diagnostics));<br/>}</span></pre><p id="e328" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">上面代码的<code class="fe ms mt mu mk b">Diagnostics</code>的结果可能如下图所示:</p><figure class="mf mg mh mi gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nd"><img src="../Images/831e3780988db337ee25dc0e8fb6c5bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TjbKxUiOAsOlWWfZBcPdzg.png"/></div></div></figure><h2 id="6821" class="lh li it bd lj lk ll dn lm ln lo dp lp km lq lr ls kq lt lu lv ku lw lx ly lz bi translated">表演</h2><p id="8fa9" class="pw-post-body-paragraph kb kc it kd b ke ma kg kh ki mb kk kl km mc ko kp kq md ks kt ku me kw kx ky im bi translated">评估的第一次调用总是很慢，您需要在您的项目中考虑它。除了第一次调用之外，它还会在您每次调用内存中的代码时编译和评估代码。</p><p id="1b6b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在需要频繁执行动态代码/脚本的情况下，最好先编译再执行。</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="10f6" class="lh li it mk b gy mo mp l mq mr">// compile once<br/>var script = CSharpScript.Create(code);</span><span id="1f69" class="lh li it mk b gy mv mp l mq mr">// run many times</span><span id="d9c3" class="lh li it mk b gy mv mp l mq mr">for(var i=0;i&lt;100;i++)<br/>   var result = await script.RunAsync();</span></pre><p id="b6f2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在下图中，您可以看到先编译脚本的速度有多快。</p><figure class="mf mg mh mi gt ju gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/8c94c5a10e51cfad9deea17e98b14570.png" data-original-src="https://miro.medium.com/v2/resize:fit:1238/format:webp/1*VnR5Fs0LDadHAMrYW73vbA.png"/></div></figure><h2 id="1e9a" class="lh li it bd lj lk ll dn lm ln lo dp lp km lq lr ls kq lt lu lv ku lw lx ly lz bi translated">使用脚本API的场景</h2><p id="6872" class="pw-post-body-paragraph kb kc it kd b ke ma kg kh ki mb kk kl km mc ko kp kq md ks kt ku me kw kx ky im bi translated">在谈论您未来或当前项目的可能场景之前，我想展示一个GitHub上使用该API的项目列表。</p><figure class="mf mg mh mi gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nf"><img src="../Images/82b395d72886c87eadd3faaaa62ed155.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NK77JXnSlQv4L3S-grFEuw.png"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated"><a class="ae kz" href="https://www.nuget.org/packages/Microsoft.CodeAnalysis.CSharp.Scripting/3.5.0-beta3-final#" rel="noopener ugc nofollow" target="_blank">你可以在NuGet包的GitHub使用部分找到这个列表</a></figcaption></figure><p id="7487" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">想象一下，在你的软件中，你想给你的用户一个机会来创建他们的宏或规则，你不想强迫他们用Visual Studio来发布一个DLL。如果你看上面的图片，你会发现很多可能性。</p><p id="c9d3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对你的C#脚本感到满意。</p><h2 id="daee" class="lh li it bd lj lk ll dn lm ln lo dp lp km lq lr ls kq lt lu lv ku lw lx ly lz bi translated">相关文章</h2><ol class=""><li id="c5ed" class="ng nh it kd b ke ma ki mb km ni kq nj ku nk ky nl nm nn no bi translated"><a class="ae kz" rel="noopener ugc nofollow" target="_blank" href="/hitchhikers-guide-to-the-c-scripting-13e45f753af9">cs harp脚本编写的搭便车指南</a></li></ol></div></div>    
</body>
</html>