<html>
<head>
<title>Enable AWS Elastic Container Registry custom domain and anonymous access over private network</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过专用网络启用AWS弹性容器注册表自定义域和匿名访问</h1>
<blockquote>原文：<a href="https://itnext.io/enable-aws-elastic-container-registry-custom-domain-and-anonymous-access-over-private-network-123d07663709?source=collection_archive---------3-----------------------#2018-04-22">https://itnext.io/enable-aws-elastic-container-registry-custom-domain-and-anonymous-access-over-private-network-123d07663709?source=collection_archive---------3-----------------------#2018-04-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/d1b9ddebd1eceab1b8278610ab05e9ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JH2edbP1F8BcU853J-AbZA.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">詹姆斯·萨顿在<a class="ae kc" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><blockquote class="kd ke kf"><p id="4eef" class="kg kh ki kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated"><a class="ae kc" href="http://https%3A%2F%2Fitnext.io%2Fenable-aws-elastic-container-registry-custom-domain-and-anonymous-access-over-private-network-123d07663709%3Futm_source%3Dmedium_sharelink%26utm_medium%3Dsocial%26utm_campaign%3Dbuffer" rel="noopener ugc nofollow" target="_blank">点击这里在LinkedIn上分享这篇文章</a></p></blockquote><p id="e497" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">几个月前，我们启动了AWS弹性容器注册中心(ECR ),作为供应商解决方案的替代方案，这让我们有些难过。</p><p id="a9a6" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">从运营的角度来看，这非常好，因为一旦您通过生命周期策略将ECR设置为过期并删除历史映像，它就变得几乎无需维护。然而，作为一名开发人员，我们发现这种体验有点违反直觉:</p><ul class=""><li id="0bc0" class="li lj iq kj b kk kl ko kp lf lk lg ll lh lm le ln lo lp lq bi translated">对于不熟悉AWS、跨账户访问和Docker本身的人来说，登录Docker是很难理解的。此外，<a class="ae kc" href="https://medium.com/@xynova/keeping-aws-registry-pull-credentials-fresh-in-kubernetes-2d123f581ca6" rel="noopener"> ECR访问凭证每天都会过期</a>使得初始设置变得更加复杂。</li><li id="7d09" class="li lj iq kj b kk lr ko ls lf lt lg lu lh lv le ln lo lp lq bi translated">注册表URL不是很友好(<strong class="kj ir">[account id]. dkr . ECR . AP-southeast-2 . Amazon AWS . com</strong>)，而且还没有办法定制它。</li><li id="47b1" class="li lj iq kj b kk lr ko ls lf lt lg lu lh lv le ln lo lp lq bi translated">ECR目前不支持为专用网络ip范围配置匿名访问的策略。</li></ul><p id="f84c" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">很明显，我们必须做些什么来让ECR更容易被普通开发者使用。上周，我们终于建立了一个Kubernetes Nginx服务，该服务为ECR提供了一个自定义域名，并允许未经认证的docker从VPCs和OpenVPN中提取内容。</p><p id="a8c4" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">该服务的组成部分如下:</p><ul class=""><li id="a9eb" class="li lj iq kj b kk kl ko kp lf lk lg ll lh lm le ln lo lp lq bi translated">带有标记化Nginx配置文件的ConfigMap，用于按计划使用新ECR凭据和域名进行处理。</li><li id="fb4f" class="li lj iq kj b kk lr ko ls lf lt lg lu lh lv le ln lo lp lq bi translated">代理ECR注册表的Nginx服务。</li><li id="dd80" class="li lj iq kj b kk lr ko ls lf lt lg lu lh lv le ln lo lp lq bi translated">一个CronJob，按计划使用新的pull secrets处理ConfigMap，并退回反向代理服务。</li></ul><h2 id="6c50" class="lw lx iq bd ly lz ma dn mb mc md dp me lf mf mg mh lg mi mj mk lh ml mm mn mo bi translated">配置图</h2><ul class=""><li id="48a6" class="li lj iq kj b kk mp ko mq lf mr lg ms lh mt le ln lo lp lq bi translated">Nginx配置模板(<strong class="kj ir"> aws-registry-proxy-tpl </strong>)极其简单。它代理ECR注册表，强制主机头并为请求设置Docker基本身份验证凭证。(点击此处阅读更多内容<a class="ae kc" href="https://docs.docker.com/registry/recipes/nginx/" rel="noopener ugc nofollow" target="_blank">https://docs.docker.com/registry/recipes/nginx/</a>)</li></ul><figure class="mu mv mw mx gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><h2 id="14a4" class="lw lx iq bd ly lz ma dn mb mc md dp me lf mf mg mh lg mi mj mk lh ml mm mn mo bi translated">Nginx服务</h2><p id="5759" class="pw-post-body-paragraph kg kh iq kj b kk mp km kn ko mq kq kr lf na ku kv lg nb ky kz lh nc lc ld le ij bi translated">代理服务也没什么特别的。它只是一个普通的Nginx Pod(我们碰巧使用Nginx Plus)，通过一个ConfigMap卷加载之前处理过的模板(<strong class="kj ir">AWS-registry-proxy-config</strong>)。Kubernetes Pod的前端是一个服务和一个TLS入口路由。</p><p id="28fe" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">请注意，该规范包含一个imagePullSecrets指令，指向一个<strong class="kj ir">AWS-registry</strong>Kubernetes secret，用于针对ECR进行认证。这个秘密被一个CronJob刷新，我们很快就会看到。</p><figure class="mu mv mw mx gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><h2 id="980b" class="lw lx iq bd ly lz ma dn mb mc md dp me lf mf mg mh lg mi mj mk lh ml mm mn mo bi translated">克朗乔布</h2><p id="a62c" class="pw-post-body-paragraph kg kh iq kj b kk mp km kn ko mq kq kr lf na ku kv lg nb ky kz lh nc lc ld le ij bi translated">最后，我们到达了Kubernetes CronJob，它将所有的碎片粘合在一起:</p><ul class=""><li id="ca40" class="li lj iq kj b kk kl ko kp lf lk lg ll lh lm le ln lo lp lq bi translated">它调用<strong class="kj ir"> aws ecr get-login </strong>命令来获取一个新的ecr令牌。</li><li id="b4dc" class="li lj iq kj b kk lr ko ls lf lt lg lu lh lv le ln lo lp lq bi translated">它将ECR令牌保存为<strong class="kj ir"> aws-registry </strong> pull secret，这样我们就可以提取我们的Nginx-Plus容器(不需要它，因为您使用的是公共映像)。</li><li id="17a2" class="li lj iq kj b kk lr ko ls lf lt lg lu lh lv le ln lo lp lq bi translated">它呈现了<strong class="kj ir">AWS-registry-proxy-TPL</strong>config map模板，并将其保存为Nginx容器使用的<strong class="kj ir">AWS-registry-proxy-config</strong>config map。</li><li id="3079" class="li lj iq kj b kk lr ko ls lf lt lg lu lh lv le ln lo lp lq bi translated">它为Nginx Pod部署创建了一个小的更新，以便Kubernetes对它执行滚动更新。</li></ul><figure class="mu mv mw mx gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="1e8b" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">我一直使用Kubernetes作业来触发模板的第一次执行，因为目前似乎没有办法按需调用Kubernetes CronJob运行。</p><figure class="mu mv mw mx gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><h2 id="67e1" class="lw lx iq bd ly lz ma dn mb mc md dp me lf mf mg mh lg mi mj mk lh ml mm mn mo bi translated">临时演员</h2><p id="e2dc" class="pw-post-body-paragraph kg kh iq kj b kk mp km kn ko mq kq kr lf na ku kv lg nb ky kz lh nc lc ld le ij bi translated">下面是用于运行CronJob的<strong class="kj ir"> xynova/aws-kubectl </strong>容器Dockerfile文件。它基本上将aws-cli、kubectl和<a class="ae kc" href="https://gomplate.hairyhenderson.ca/" rel="noopener ugc nofollow" target="_blank"> gomplate </a>二进制文件组合在一个容器中。</p><figure class="mu mv mw mx gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="12f6" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">对于使用aws-cli请求docker登录命令的容器，它必须在Kubernetes节点上运行，并具有以下角色附加策略。</p><figure class="mu mv mw mx gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><h2 id="565b" class="lw lx iq bd ly lz ma dn mb mc md dp me lf mf mg mh lg mi mj mk lh ml mm mn mo bi translated">包扎</h2><p id="ca43" class="pw-post-body-paragraph kg kh iq kj b kk mp km kn ko mq kq kr lf na ku kv lg nb ky kz lh nc lc ld le ij bi translated">正如您所看到的，只需要一点点路由技巧就可以绕过AWS ECRs的一些限制。对我们来说，这是一个巨大的胜利，因为现在开发人员可以连接到OpenVPN，直接从<strong class="kj ir">registry.shrd.ourdomain.net</strong>获取图像，而无需使用任何黑魔法来验证。</p><p id="f95b" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">干杯</p></div></div>    
</body>
</html>