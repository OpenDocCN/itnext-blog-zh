<html>
<head>
<title>Elastic(autoscaling) Airflow Cluster on Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes上的弹性(自动缩放)气流簇</h1>
<blockquote>原文：<a href="https://itnext.io/elastic-autoscaling-airflow-cluster-in-kubernetes-14c16c73cac9?source=collection_archive---------0-----------------------#2020-04-28">https://itnext.io/elastic-autoscaling-airflow-cluster-in-kubernetes-14c16c73cac9?source=collection_archive---------0-----------------------#2020-04-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="7746" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本文中，我将演示如何构建一个弹性气流集群<strong class="jp ir"><em class="kl"/></strong>，它可以在高负载时向外扩展，在负载低于阈值时安全地<em class="kl"/>向内扩展。</p><blockquote class="km kn ko"><p id="8993" class="jn jo kl jp b jq jr js jt ju jv jw jx kp jz ka kb kq kd ke kf kr kh ki kj kk ij bi translated">如果您想先测试一下，请滚动到setup。</p></blockquote><p id="7c1c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Kubernetes中的自动缩放通过水平Pod自动缩放器来支持。使用HPA，横向扩展非常简单，HPA增加了部署的副本，并且创建了额外的工作人员来分担工作负载。然而，扩大是问题所在，s <a class="ae ks" href="https://github.com/kubernetes/kubernetes/blob/cb719f75aac98ca24224c563d80d1035079885a5/pkg/controller/replicaset/replica_set.go#L604" rel="noopener ugc nofollow" target="_blank">扩大过程通过基于它们在一个节点上的共同位置对它们进行排序来选择要终止的pod。</a>所以，如果有一个worker pod还在做一些处理，就不能保证它不会被终止。</p><p id="88dc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在弹性气流集群中，为了扩大规模，我们需要保证执行某些处理的工作人员不会被终止。只有无所事事的员工才应该被考虑解雇。</p><p id="dc62" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了实现这一点，我创建了两个CRD和两个控制器—<strong class="jp ir">elastic worker</strong>&amp;<strong class="jp ir">elastic worker rautoscaler</strong>，这两个都将在本文后面描述。</p><p id="1534" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个问题还有其他的解决方案，例如，您可以创建Kubernetes job，它会为一组任务运行到完成。随着负荷的增加，创造了更多的工作岗位。然而，这种方法并不是一种通用的解决方案，不能很好地适应具有类似自动缩放需求的其他用例。这里描述的方法是一个通用的实现，可以用作全面生产设置的起点。</p></div><div class="ab cl kt ku hu kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ij ik il im in"><h1 id="b676" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">弹性气流集群架构</h1><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi ly"><img src="../Images/666e0f5534147e856ce4ebbd81e3b646.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JNJRbpZfDQkywx2FykaOPA.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">弹性气流集群架构</figcaption></figure><p id="58cb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">组件描述如下:</p><ul class=""><li id="fc2c" class="mo mp iq jp b jq jr ju jv jy mq kc mr kg ms kk mt mu mv mw bi translated"><strong class="jp ir">气流调度器</strong>解析<a class="ae ks" href="https://airflow.apache.org/docs/stable/concepts.html#dags" rel="noopener ugc nofollow" target="_blank">Dag</a>并将必要的任务添加到RabbitMQ队列中。</li><li id="54c0" class="mo mp iq jp b jq mx ju my jy mz kc na kg nb kk mt mu mv mw bi translated">PostgresDB 保存关于任务、Dag、变量、连接等状态的信息。</li><li id="a36f" class="mo mp iq jp b jq mx ju my jy mz kc na kg nb kk mt mu mv mw bi translated"><strong class="jp ir"> RabbitMQ </strong>将执行命令存储在队列中。</li><li id="d337" class="mo mp iq jp b jq mx ju my jy mz kc na kg nb kk mt mu mv mw bi translated"><a class="ae ks" href="https://docs.celeryproject.org/en/stable/userguide/index.html" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">气流工作者</strong> </a>从RabbitMQ获取命令并执行。</li><li id="6bf6" class="mo mp iq jp b jq mx ju my jy mz kc na kg nb kk mt mu mv mw bi translated"><a class="ae ks" href="https://flower.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> Flower </strong> </a>是一个基于web的工具，用于监控和管理芹菜工人。在我们的设置中，flower还包含额外的脚本来获取每个airflow worker的指标，并将其放入redis db中。</li><li id="d849" class="mo mp iq jp b jq mx ju my jy mz kc na kg nb kk mt mu mv mw bi translated"><strong class="jp ir"> Redis DB </strong>存储每个airflow worker pod的负载指标以及集群总负载的总和。它还存储我们的自定义指标APIServer适配器的所有注册指标。</li><li id="ac6e" class="mo mp iq jp b jq mx ju my jy mz kc na kg nb kk mt mu mv mw bi translated"><strong class="jp ir">定制指标API服务器适配器</strong>是一个基本的定制指标API服务器适配器，分别为给定pod和airflow集群资源的<em class="kl">负载</em>和<em class="kl"> total_cluster_load </em>指标请求提供服务。它从Redis db中检索这些指标。</li><li id="660f" class="mo mp iq jp b jq mx ju my jy mz kc na kg nb kk mt mu mv mw bi translated"><strong class="jp ir"> ElasticWorker控制器</strong>监视种类为<strong class="jp ir"><em class="kl">ElasticWorker(CRD)</em></strong>的对象，并使集群状态与相应elastic worker对象中的规范保持一致。在高层次上，下面是该管制员的职责，</li></ul><p id="e42a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">—创建等于<code class="fe nc nd ne nf b">minReplica</code>的工人舱</p><p id="30fa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">—如果变量<code class="fe nc nd ne nf b">scale&gt;0</code>，创建额外的工人舱。但是要确保吊舱总数不超过<code class="fe nc nd ne nf b">maxReplicas</code></p><p id="6c0f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">——在<code class="fe nc nd ne nf b">scale&lt;0</code>时删除工人舱。pod的删除由策略中定义的比例控制。目前有三种策略，即<a class="ae ks" href="https://github.com/sarweshsuman/elastic-worker-autoscaler/blob/435c159d4b3be0b501230aebaca53c21b6440ef6/api/v1/elasticworker_types.go#L77" rel="noopener ugc nofollow" target="_blank"> ScaleInImmediately </a>、<a class="ae ks" href="https://github.com/sarweshsuman/elastic-worker-autoscaler/blob/435c159d4b3be0b501230aebaca53c21b6440ef6/api/v1/elasticworker_types.go#L81" rel="noopener ugc nofollow" target="_blank"> ScaleInBySelector </a>、<a class="ae ks" href="https://github.com/sarweshsuman/elastic-worker-autoscaler/blob/435c159d4b3be0b501230aebaca53c21b6440ef6/api/v1/elasticworker_types.go#L84" rel="noopener ugc nofollow" target="_blank">ScaleInBySelector</a>，这里我们将使用ScaleInBySelector策略。这确保控制器只删除那些已定义标签集的窗格。它还确保无论标签是否设置，豆荚数都不会低于<code class="fe nc nd ne nf b">minReplicas</code>。</p><pre class="lz ma mb mc gt ng nf nh ni aw nj bi"><span id="6dbc" class="nk lb iq nf b gy nl nm l nn no">apiVersion: elasticcluster.sarweshsuman.com/v1<br/>kind: ElasticWorker<br/>metadata:<br/>  name: elasticworker-sample<br/>spec:<br/>  minReplicas: 2<br/>  maxReplicas: 5<br/>  scaleInPolicy:  <br/>    name: selector<br/>    selector:<br/>      matchLabels:<br/>        <strong class="nf ir"># Only pods with below labels are considered for deletion</strong><br/>        delete: "true"  <br/>  selector:<br/>    matchLabels:<br/>      worker: elastic-workers<br/>  template:<br/>    metadata:<br/>      labels:<br/>        worker: elastic-workers<br/>    spec:<br/>      containers:<br/>      - name: worker-1<br/>        image: busybox:latest<br/>        command: ['sleep','30000']</span></pre><ul class=""><li id="021d" class="mo mp iq jp b jq jr ju jv jy mq kc mr kg ms kk mt mu mv mw bi translated"><strong class="jp ir"> ElasticWorkerAutoscaler控制器</strong>监视实物<strong class="jp ir">T29】elastic workerautoscaler(CRD)</strong>。下面的高层是这个管制员的职责，</li></ul><p id="e455" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">—检索名为referent ElasticWorker对象的资源的指标<code class="fe nc nd ne nf b">total_cluster_load</code>。</p><p id="0411" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">—横向扩展if <code class="fe nc nd ne nf b">total_cluster_load &gt; targetValue</code>。计算新工人pod计数，以将负荷降低到目标值。<a class="ae ks" href="https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/#algorithm-details" rel="noopener ugc nofollow" target="_blank">计算与HPA相同。</a>设置referent ElasticWorker对象的<code class="fe nc nd ne nf b">scale</code>属性，需要额外的工作线程数。</p><p id="7daa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">——放大如果<code class="fe nc nd ne nf b">total_cluster_load &lt; 0.70 * targetValue</code>。如果负载低于阈值，则不会立即开始放大，b <a class="ae ks" href="https://github.com/sarweshsuman/elastic-worker-autoscaler/blob/435c159d4b3be0b501230aebaca53c21b6440ef6/api/v1/elasticworkerautoscaler_types.go#L65" rel="noopener ugc nofollow" target="_blank"> ut，</a> <code class="fe nc nd ne nf b"><a class="ae ks" href="https://github.com/sarweshsuman/elastic-worker-autoscaler/blob/435c159d4b3be0b501230aebaca53c21b6440ef6/api/v1/elasticworkerautoscaler_types.go#L65" rel="noopener ugc nofollow" target="_blank">scaleInBackOff</a></code> <a class="ae ks" href="https://github.com/sarweshsuman/elastic-worker-autoscaler/blob/435c159d4b3be0b501230aebaca53c21b6440ef6/api/v1/elasticworkerautoscaler_types.go#L65" rel="noopener ugc nofollow" target="_blank">周期被取消</a>。默认情况下，它设置为30秒，如果此时间段结束，则执行放大。如果同时<code class="fe nc nd ne nf b">total_cluster_load</code>增加，则ScaleInBackOff周期无效。一旦周期结束，控制器选择那些具有度量<code class="fe nc nd ne nf b">load=0</code>的工人舱。<a class="ae ks" href="https://github.com/sarweshsuman/elastic-worker-autoscaler/blob/435c159d4b3be0b501230aebaca53c21b6440ef6/api/v1/elasticworkerautoscaler_types.go#L52" rel="noopener ugc nofollow" target="_blank">然后它调用请求</a>中的shutdownHttpHook。这个钩子是为这个实现定制的，但是可以通用化。接下来，控制器用终止标签标记pod，最后用适当的值更新<code class="fe nc nd ne nf b">scale</code>,使ElasticWorker控制器改变集群状态。</p><p id="fc30" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">—在过滤器<code class="fe nc nd ne nf b">load=0</code>、<code class="fe nc nd ne nf b">ShutdownHttpHook</code>和<code class="fe nc nd ne nf b">TerminationLabel</code>的帮助下，确保只有那些不做任何事情的气流工人被终止。HttpShutdown挂钩很重要，因为它确保了在ElasticWorker控制器终止任务时，标记为终止airflow workers的<em class="kl">不会从RabbitMQ获取任何任务。</em></p><pre class="lz ma mb mc gt ng nf nh ni aw nj bi"><span id="6cb4" class="nk lb iq nf b gy nl nm l nn no">apiVersion: elasticcluster.sarweshsuman.com/v1<br/>kind: ElasticWorkerAutoscaler<br/>metadata:<br/>  name: elasticworkerautoscaler-sample<br/>spec:<br/>  scaleTargetRef:<br/>    name: elasticworker-sample<br/>    namespace: default<br/>  metricSpec:<br/>    name: total_cluster_load<br/>    <strong class="nf ir"># Has to be same as referent ElasticWorker object name</strong><br/>    resourceName: elasticworker-sample<br/>    namespace: default<br/>  targetValue: 80<br/>  scaleInSpec:<br/>    shutdownHttpHook: <a class="ae ks" href="http://localhost:8888/shutdownpods" rel="noopener ugc nofollow" target="_blank">http://localhost:8888/shutdownpods</a><br/>    podMetricSpec:<br/>      name: load<br/>      namespace: default<br/>    markForTerminationLabel:<br/>      delete: "true"</span></pre></div><div class="ab cl kt ku hu kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ij ik il im in"><h1 id="89fa" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated"><strong class="ak">设置</strong></h1><p id="4c16" class="pw-post-body-paragraph jn jo iq jp b jq np js jt ju nq jw jx jy nr ka kb kc ns ke kf kg nt ki kj kk ij bi translated">elastic worker &amp; elastic worker rautoscaler控制器代码可在此处获得—<a class="ae ks" href="https://github.com/sarweshsuman/elastic-worker-autoscaler" rel="noopener ugc nofollow" target="_blank"><em class="kl">elastic-worker-auto scaler</em></a><em class="kl">。</em></p><p id="06bf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">定制的metric APIServer <strong class="jp ir"> </strong>适配器代码在这里可以找到—<a class="ae ks" href="https://github.com/sarweshsuman/elastic-worker-custommetrics-adapter" rel="noopener ugc nofollow" target="_blank"><em class="kl">elastic-worker-custom metrics—adapter</em></a><em class="kl">。</em></p><p id="3b85" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">按照这里的设置说明</strong>—<a class="ae ks" href="https://github.com/sarweshsuman/elastic-airflow-cluster-k8s-setup-manifests" rel="noopener ugc nofollow" target="_blank">—<em class="kl">弹性-气流-集群-k8s-设置-清单</em> </a> <em class="kl">。</em></p><p id="f831" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在设置和运行测试DAG后，我们可以在flower仪表板中看到统计数据，以确保airflow cluster设置正常。</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi nu"><img src="../Images/dde1d0622b3715f0cf5e5b191a7b7aea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zINq7MThdaFH09pI-5Ekew.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">花卉仪表板</figcaption></figure><p id="52d6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，我们可以用下面的命令启动Kubernetes dashboard并验证它，</p><pre class="lz ma mb mc gt ng nf nh ni aw nj bi"><span id="763a" class="nk lb iq nf b gy nl nm l nn no">minikube dashboard</span></pre><p id="bdea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们在minikube上设置如下:</p><p id="ad59" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">两个附加的名称空间，</p><ul class=""><li id="8413" class="mo mp iq jp b jq jr ju jv jy mq kc mr kg ms kk mt mu mv mw bi translated">弹性工人自动定标系统</li><li id="efde" class="mo mp iq jp b jq mx ju my jy mz kc na kg nb kk mt mu mv mw bi translated">elastic worker-自定义度量</li></ul><p id="3012" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> —名称空间:</strong>elastic worker-custom metrics包含与定制指标相关的pod。</p><p id="7833" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> —名称空间:</strong>elastic-worker-auto scaler-system包含用于<em class="kl"> ElasticWorker </em>和<em class="kl">elastic worker rautoscaler</em>的控制器盒</p><p id="d8fd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">其余的组件在<em class="kl">默认的</em>命名空间中创建。</p><p id="fdbd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以使用以下命令检索ElasticWorker对象，</p><pre class="lz ma mb mc gt ng nf nh ni aw nj bi"><span id="67a3" class="nk lb iq nf b gy nl nm l nn no">kubectl get elasticworkers</span></pre><p id="b2ec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以使用以下命令检索ElasticWorkerAutoscaler对象，</p><pre class="lz ma mb mc gt ng nf nh ni aw nj bi"><span id="c641" class="nk lb iq nf b gy nl nm l nn no">kubectl get elasticworkerautoscalers</span></pre><p id="4092" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在设置已经完成。我们可以从自动缩放测试开始。</p></div><div class="ab cl kt ku hu kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ij ik il im in"><h1 id="cc2d" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">测试</h1><p id="b786" class="pw-post-body-paragraph jn jo iq jp b jq np js jt ju nq jw jx jy nr ka kb kc ns ke kf kg nt ki kj kk ij bi translated">我们已经在设置时使用<a class="ae ks" href="https://github.com/sarweshsuman/elastic-airflow-cluster-k8s-setup-manifests/blob/master/sample-dags/dag_1.py" rel="noopener ugc nofollow" target="_blank"> dag_1 </a>测试了气流群集。如果不是，那么<a class="ae ks" href="https://github.com/sarweshsuman/elastic-airflow-cluster-k8s-setup-manifests" rel="noopener ugc nofollow" target="_blank">到这里用DAG </a>进行测试。我们将在这里使用相同的DAG进行测试。</p><p id="d688" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了测试，我在ElasticWorkerAutoscaler对象中将<a class="ae ks" href="https://github.com/sarweshsuman/elastic-airflow-cluster-k8s-setup-manifests/blob/master/elasticcluster-autoscaler.yaml" rel="noopener ugc nofollow" target="_blank">目标值设置为60。这意味着一旦总群集负载超过60，将开始向外扩展，如果负载低于30，将开始向内扩展。</a></p><p id="32e2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将通过登录到scheduler pod来触发Dag。</p><p id="8cfb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将从测试<strong class="jp ir">横向扩展场景开始。</strong></p><p id="64bb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们的设置中，每个airflow worker的并发性设置为2，这意味着我们总共有2(并发性)*2(工作线程数)= 4个可用的插槽。因此，触发4个Dag将使集群负载上升到100%。</p><p id="561a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这个测试案例中，我们将同时触发10个以上的Dag(即我们需要10个以上的插槽)。这将导致airflow worker集群扩展到maxReplica(即5个副本)。ElasticWorker控制器将确保Worker计数不超过maxReplica，即使负载保持在100%。</p><p id="e6a8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面的截图是开始测试前的气流工人集群。目前，我们有两个工人，所有的位置都是空的。</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi nv"><img src="../Images/bbb410cf2bfef3741af1ad8371b24e28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o96cee_2v1-mW10y9s1_aw.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">kubectl获取豆荚</figcaption></figure><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi nw"><img src="../Images/a7f4a721d731401eb7409c8e0f54abda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IgylBqAmGs9oo2RqisuDYg.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">花卉仪表板</figcaption></figure><p id="7624" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们通过登录到scheduler pod来触发Dag。如果尚未取消暂停DAG，请记住取消暂停。</p><pre class="lz ma mb mc gt ng nf nh ni aw nj bi"><span id="aa71" class="nk lb iq nf b gy nl nm l nn no"><strong class="nf ir">#Login to Scheduler POD<br/></strong>kubectl exec -it airflow-scheduler-76d5df7b9b-mjp25 bash</span><span id="0579" class="nk lb iq nf b gy nx nm l nn no">cd dags<br/><strong class="nf ir">#If you have not unpaused dag_1 already</strong><br/>airflow unpause dag_1</span><span id="76b3" class="nk lb iq nf b gy nx nm l nn no">export COUNT=0<br/>while [[ $COUNT -lt 12 ]];<br/>do<br/>airflow trigger_dag dag_1<br/>COUNT=`expr $COUNT + 1`<br/>done;</span></pre><p id="fdba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">随着负载的增加，我们看到会产生额外的气流工人来处理负载。</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi ny"><img src="../Images/7fd9b1e407543aa7107ac222a03662b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ErMwAXUcBqt072GU7k7Ydg.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">kubectl获取豆荚</figcaption></figure><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi nz"><img src="../Images/b585a01c123ee6531a5768a32a6bb797.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VI4dlG4lxiuSK5Z83NIhEw.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">花卉仪表板</figcaption></figure><p id="dafc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我们触发12个Dag时，创建的额外气流工作线程应该不止3个，但是由于我们将maxReplicas设置为5，ElasticWorker controller没有创建超过5个的工作线程。</p><p id="51e3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的横向扩展方案行得通！！</p><p id="af53" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们将测试<strong class="jp ir">扩展场景。</strong></p><p id="f094" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">之前的测试已经验证了基本的扩展场景</em>。如果我们等待一两分钟并检查集群状态，我们可以看到worker count已经缩减到minReplicas。这是因为负载降至30以下。</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi oa"><img src="../Images/25b35532d1b3cb4263a7be43e7f1d2f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O9--Pw7RAeodtrjLfLrsQA.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">kubectl获取豆荚</figcaption></figure><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi ob"><img src="../Images/0ce9c820c35b60e4709fb1a0f2214174.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NJSyyk5BzRBolSXPTivwPQ.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">花卉仪表板</figcaption></figure><p id="7fc3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还希望验证它是安全的扩展，即当触发扩展时，控制器将终止负载为0的工作线程，而不是仍在执行某些工作的工作线程。</p><p id="9729" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了测试这个场景，我们将使用<a class="ae ks" href="https://github.com/sarweshsuman/elastic-airflow-cluster-k8s-setup-manifests/blob/master/sample-dags/dag_2.py" rel="noopener ugc nofollow" target="_blank"> dag_2 </a>，它的任务将休眠30秒，然后将消息HI记录到文件<code class="fe nc nd ne nf b">/home/airflow/logs/count_hi.txt </code>中。我们将触发DAG 12次，每触发4次后，我们将等待40多秒，然后再次触发。</p><p id="8339" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们在中间等待触发放大。扩展的默认回退时间为30秒，这是为了避免抖动。</p><p id="197e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了最终验证是否所有的任务都运行良好，并且实际执行处理的工人都没有被终止，我们只在输出文件中计算message HI。如果它等于我们触发的Dag数(12 ),那么我们的测试用例将通过。</p><p id="78fa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如下图创建dag_2，</p><pre class="lz ma mb mc gt ng nf nh ni aw nj bi"><span id="6a08" class="nk lb iq nf b gy nl nm l nn no"><strong class="nf ir"># Lets copy the dag_2.py file into minikube VM<br/></strong>minikube ssh<br/>cd dags/<br/>cat&gt;dag_2.py<br/>....PASTE CONTENT FROM SAMPLE DAG....<br/>ctrl-d<br/>logout</span></pre><p id="a951" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从调度程序窗格触发DAG。</p><pre class="lz ma mb mc gt ng nf nh ni aw nj bi"><span id="cde8" class="nk lb iq nf b gy nl nm l nn no"><strong class="nf ir">#Login to Scheduler POD<br/></strong>kubectl exec -it airflow-scheduler-76d5df7b9b-mjp25 bash</span><span id="5163" class="nk lb iq nf b gy nx nm l nn no">cd dags<br/><strong class="nf ir">#If you have not unpaused dag_2 already</strong><br/>airflow unpause dag_2</span><span id="f7c5" class="nk lb iq nf b gy nx nm l nn no">export COUNT=0<br/>while [[ $COUNT -lt 4 ]];<br/>do<br/>airflow trigger_dag dag_2<br/>COUNT=`expr $COUNT + 1`<br/>done;</span><span id="6a6b" class="nk lb iq nf b gy nx nm l nn no">sleep 40</span><span id="9fda" class="nk lb iq nf b gy nx nm l nn no">export COUNT=0<br/>while [[ $COUNT -lt 4 ]];<br/>do<br/>airflow trigger_dag dag_2<br/>COUNT=`expr $COUNT + 1`<br/>done;</span><span id="018d" class="nk lb iq nf b gy nx nm l nn no">sleep 45</span><span id="5e71" class="nk lb iq nf b gy nx nm l nn no">export COUNT=0<br/>while [[ $COUNT -lt 4 ]];<br/>do<br/>airflow trigger_dag dag_2<br/>COUNT=`expr $COUNT + 1`<br/>done;</span></pre><p id="390b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦所有的任务都被处理，我们将对消息HI进行计数。我们将使用scheduler窗格来检查输出文件。</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi oc"><img src="../Images/f45436662c3bf2846254c39cef694755.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yis84Va5C--VJk9AflWXsg.png"/></div></div></figure><p id="84f3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从上面的截图中我们可以看到，消息HI被打印了12次，这与任务的数量相同。</p><p id="3269" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这结束了我们的最后一个测试案例。</p></div><div class="ab cl kt ku hu kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ij ik il im in"><h1 id="4749" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">结论</h1><p id="3621" class="pw-post-body-paragraph jn jo iq jp b jq np js jt ju nq jw jx jy nr ka kb kc ns ke kf kg nt ki kj kk ij bi translated">在本文中，我们看到了如何构建一个<strong class="jp ir">弹性气流集群</strong>，当负载增加到某个阈值以上时，它可以向外扩展；当负载低于某个阈值时，它可以安全地向内扩展。</p><p id="e63c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们使用了两个新的CRD—<strong class="jp ir">elastic worker</strong>和<strong class="jp ir">elastic worker rautoscaler</strong>以及它们各自的控制器来实现这一点。ElasticWorker控制器管理airflow worker副本，并确保它在minReplica和maxReplica之间。ElasticWorkerAutoscaler控制器轮询指标<em class="kl">总集群负载</em>，并计算使集群负载达到指定的<em class="kl">目标值</em>所需的副本。然后，它将referent ElasticWorker对象更新为放大或缩小。</p><p id="664e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">PS:</p><ul class=""><li id="01ef" class="mo mp iq jp b jq jr ju jv jy mq kc mr kg ms kk mt mu mv mw bi translated">两个控制器代码都是原型，它们缺少某些特性，例如，ElasticWorker对象不提供滚动升级。</li><li id="5eb0" class="mo mp iq jp b jq mx ju my jy mz kc na kg nb kk mt mu mv mw bi translated">此处进行的自定义度量设置是为了学习，但对于生产用途，应使用prometheus设置。</li><li id="6d38" class="mo mp iq jp b jq mx ju my jy mz kc na kg nb kk mt mu mv mw bi translated">有关详细信息和更新，您可以参考下面的回购、</li></ul><div class="od oe gp gr of og"><a href="https://github.com/sarweshsuman/elastic-airflow-cluster-k8s-setup-manifests#elastic-airflow-cluster-k8s-setup-manifests" rel="noopener  ugc nofollow" target="_blank"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd ir gy z fp ol fr fs om fu fw ip bi translated">sarweshsuman/elastic-air flow-cluster-k8s-设置-清单</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">此报告包含气流群集组件的dockerfiles/yaml。安装迷你库安装迷你库…</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">github.com</p></div></div><div class="op l"><div class="oq l or os ot op ou mi og"/></div></div></a></div><div class="od oe gp gr of og"><a href="https://github.com/sarweshsuman/elastic-worker-custommetrics-adapter" rel="noopener  ugc nofollow" target="_blank"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd ir gy z fp ol fr fs om fu fw ip bi translated">sarweshsuman/elastic-worker-custom metrics-适配器</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">包含通过Kubernetes中的聚合层启用的弹性工作器自定义指标APIserver适配器的适配器代码…</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">github.com</p></div></div><div class="op l"><div class="ov l or os ot op ou mi og"/></div></div></a></div><div class="od oe gp gr of og"><a href="https://github.com/sarweshsuman/elastic-worker-autoscaler" rel="noopener  ugc nofollow" target="_blank"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd ir gy z fp ol fr fs om fu fw ip bi translated">sarweshsuman/elastic-worker-autoscaler</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">包含协调在Kubernetes中创建的ElasticWorker和ElasticWorkerAutoscaler对象的控制器代码…</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">github.com</p></div></div><div class="op l"><div class="ow l or os ot op ou mi og"/></div></div></a></div></div></div>    
</body>
</html>