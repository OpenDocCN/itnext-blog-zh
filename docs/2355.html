<html>
<head>
<title>Learning Go: MongoDB CRUD with gRPC</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习Go:使用gRPC的MongoDB CRUD</h1>
<blockquote>原文：<a href="https://itnext.io/learning-go-mongodb-crud-with-grpc-98e425aeaae6?source=collection_archive---------0-----------------------#2019-05-10">https://itnext.io/learning-go-mongodb-crud-with-grpc-98e425aeaae6?source=collection_archive---------0-----------------------#2019-05-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/6e5bb387ba03a260a865aa05d1c3c23a.png" data-original-src="https://miro.medium.com/v2/resize:fit:614/format:webp/0*GccK_os7uZumMgFU.png"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">比利时的一只地鼠</figcaption></figure><h1 id="268f" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">去</h1><p id="88a8" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">过去几周，我一直在忙着玩我最喜欢的新玩具:Go。它是谷歌在2007年创建的一种开源编程语言。它在Google中被大量使用，并且在公开发布之前经过了实战测试，到目前为止，它被认为是一种非常稳定的语言。Go试图在人类和机器之间找到一个最佳生产率和性能的中间地带。许多人认为这是后端开发和微服务的未来。</p><p id="c13f" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">虽然Go还相对年轻，但它已经在分布式系统世界中受到了热烈欢迎。Docker，Kubernetes，InfluxDB，Go-Ethereum，…都是内置在Go里的。</p><p id="0696" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">这是经典的“为什么去？”列表:</p><ul class=""><li id="a77b" class="lz ma iq ky b kz lu ld lv lh mb ll mc lp md lt me mf mg mh bi translated">使用GoRoutines和通道的优雅并发</li><li id="3b2e" class="lz ma iq ky b kz mi ld mj lh mk ll ml lp mm lt me mf mg mh bi translated">多核支持</li><li id="961e" class="lz ma iq ky b kz mi ld mj lh mk ll ml lp mm lt me mf mg mh bi translated">非常好的原始CPU和内存性能</li><li id="cee7" class="lz ma iq ky b kz mi ld mj lh mk ll ml lp mm lt me mf mg mh bi translated">类型并不麻烦</li><li id="3814" class="lz ma iq ky b kz mi ld mj lh mk ll ml lp mm lt me mf mg mh bi translated">内置测试框架</li><li id="c4b8" class="lz ma iq ky b kz mi ld mj lh mk ll ml lp mm lt me mf mg mh bi translated">静态代码分析</li><li id="41b4" class="lz ma iq ky b kz mi ld mj lh mk ll ml lp mm lt me mf mg mh bi translated">编译/部署</li></ul><p id="7cdb" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">在这篇博客中，我不会教你如何用go编写“Hello World ”,相反，我们将使用官方的mongodb-go-driver和gRPC编写一个CRUD API。在继续之前，确保你已经安装了Golang、MongoDB、RoboMongo(为了方便使用)和协议缓冲区(链接在下面)。为了从本教程中获得最大收益，你应该熟悉一点Go语法和指针。</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/5cb03ec1fdaebcd85b246a3e289ed9b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1352/0*z27CGh0nvUyvRITs"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">一只明显能举起</figcaption></figure><h1 id="80e2" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">gRPC和HTTP2</h1><p id="571a" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">安息吧，这个街区有一个新的孩子，他叫gRPC。gRPC是一种基于HTTP2的现代协议，它使用一种称为协议缓冲区的强类型二进制数据格式而不是JSON来提供远程过程调用语义。</p><p id="c01b" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">解析JSON是非常CPU密集型的，据估计，对于RESTful服务，它占用了所有CPU资源的45%。结合HTTP/2提供的升级，gRPC API估计比RESTful快<strong class="ky ir">5-25倍</strong>。</p><p id="02a4" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">gRPC是从头开始构建的，以利用HTTP/2带来的所有好东西，并再次经过Google的战斗测试，每秒处理100亿个请求。下面是HTTP/2带来的一些有趣的东西:</p><ul class=""><li id="71d9" class="lz ma iq ky b kz lu ld lv lh mb ll mc lp md lt me mf mg mh bi translated">多路复用(HTTP/1为每个请求打开一个TCP连接)</li><li id="1966" class="lz ma iq ky b kz mi ld mj lh mk ll ml lp mm lt me mf mg mh bi translated">服务器推送</li><li id="b434" class="lz ma iq ky b kz mi ld mj lh mk ll ml lp mm lt me mf mg mh bi translated">报头压缩(HTTP/1中的明文，随每个请求一起发送)</li><li id="8f41" class="lz ma iq ky b kz mi ld mj lh mk ll ml lp mm lt me mf mg mh bi translated">二进制而不是文本(非常适合协议缓冲区)</li><li id="fbd4" class="lz ma iq ky b kz mi ld mj lh mk ll ml lp mm lt me mf mg mh bi translated">SSL是一等公民</li></ul><h1 id="b0c0" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">gRPC与REST</h1><p id="e47a" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">将gRPC与REST进行全面的比较本身就是一篇博文的素材，所以这里有一个概述:</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi ms"><img src="../Images/1c6f95bd35b985651f1f667e09109bff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hZK9yqVzRcITfP0hWXuBxQ.png"/></div></div></figure><h1 id="d5a4" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">协议缓冲区</h1><p id="5338" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">如前所述，协议缓冲区(简称protobufs)是一种强类型、语言和平台中立的二进制数据格式。您可以在一次<em class="mx">中定义您想要的数据结构。proto </em>文件，然后使用特殊生成的源代码轻松地为多种语言创建服务器和客户端存根。proto文件是API契约的标准格式。根据google的说法，<strong class="ky ir">proto buf比XML小3-10倍，快20-100倍。</strong></p><p id="e830" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">协议缓冲区用于在<em class="mx">中定义<strong class="ky ir">消息</strong>(数据、请求和响应)和<strong class="ky ir">服务</strong> (RPC端点)。proto </em>文件。</p><p id="e1a7" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">要了解更多关于协议缓冲区的信息，请查阅大量的<a class="ae my" href="https://developers.google.com/protocol-buffers/docs/overview" rel="noopener ugc nofollow" target="_blank">文档</a>。</p></div><div class="ab cl mz na hu nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ij ik il im in"><h1 id="223c" class="jy jz iq bd ka kb ng kd ke kf nh kh ki kj ni kl km kn nj kp kq kr nk kt ku kv bi translated">言归正传:博客服务API</h1><p id="34f9" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">在这篇博文的剩余部分，我们将为博客服务构建一个简单的CRUD API。由于MongoDB刚刚发布了他们的官方Go驱动程序，我们将使用MongoDB。我们将使用Cobra为客户机创建一个服务器和一个小型CLI应用程序。让我们把手弄脏吧！</p><ul class=""><li id="4d99" class="lz ma iq ky b kz lu ld lv lh mb ll mc lp md lt me mf mg mh bi translated">Cobra还不支持生成子命令的go-modules，因此对于本教程，我们将使用好的ol' $GOPATH:)。</li><li id="27e2" class="lz ma iq ky b kz mi ld mj lh mk ll ml lp mm lt me mf mg mh bi translated">你的文件夹结构应该是这样的:<br/><em class="mx">$ GOPATH</em>/grpc-mongo-crud/<br/>-server<br/>-client<br/>-proto</li><li id="3176" class="lz ma iq ky b kz mi ld mj lh mk ll ml lp mm lt me mf mg mh bi translated">或者，您可以在您的<em class="mx"> $GOPATH </em>中生成子命令文件，并将代码复制粘贴到您自己的存储库中，并使用相对路径(这是我采用的方法)。</li></ul><p id="6e09" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><a class="ae my" href="https://github.com/kyriediculous/go-grpc-mongodb" rel="noopener ugc nofollow" target="_blank">你可以在我的github上找到代码库</a>。</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi nl"><img src="../Images/eae8fbdcbd420b3e12052a709b8574a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xIEsYJplggYmACCp.gif"/></div></div></figure><h1 id="9237" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">1.创建原型文件</h1><p id="4a96" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">在你的<em class="mx"> $GOPATH </em>中建立一个新的工作目录后，在proto文件夹中创建一个新的文件，姑且称之为<em class="mx"> blog.proto </em>。为了简单起见，我们将为每个请求/响应创建单独的消息，尽管有些会重叠。</p><p id="2f3f" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">首先是一些样板文件，表明我们使用protbufs v3，我们的包称为blog，我们生成的go包将称为blogpb(blog protocol buffer的缩写)。</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="699b" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我们需要5个服务，每个服务接收一个请求并返回一个响应:</p><ul class=""><li id="c95b" class="lz ma iq ky b kz lu ld lv lh mb ll mc lp md lt me mf mg mh bi translated">创建博客(一元)</li><li id="cae8" class="lz ma iq ky b kz mi ld mj lh mk ll ml lp mm lt me mf mg mh bi translated">ReadBlog(一元)</li><li id="fa74" class="lz ma iq ky b kz mi ld mj lh mk ll ml lp mm lt me mf mg mh bi translated">更新博客(一元)</li><li id="8967" class="lz ma iq ky b kz mi ld mj lh mk ll ml lp mm lt me mf mg mh bi translated">删除博客(一元)</li><li id="9de2" class="lz ma iq ky b kz mi ld mj lh mk ll ml lp mm lt me mf mg mh bi translated">列表博客(服务器流)</li></ul><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="a07b" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><em class="mx"> CreateBlog、ReadBlog </em>和<em class="mx"> UpdateBlog </em>将在它们的响应中返回一个<em class="mx">博客条目</em>，因此我们需要一个博客消息类型。消息可以嵌套，所以我们可以在请求/响应消息中使用我们的博客消息。</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="b6ad" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky ir">创建博客请求/响应</strong></p><p id="ea52" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">请求和响应都由一个<code class="fe no np nq nr b">Blog</code>消息组成，主要的区别是在请求中，ID将为空，因为它是由MongoDB在数据库中创建文档时创建的。在响应中，将填写ID。</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="eeef" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky ir">更新博客请求/响应</strong></p><p id="3f1a" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">非常类似于CreateBlog，但是我们请求中的Blog消息已经包含了在我们的数据库中查找和更新特定项目的id。响应将返回更新的文档。</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="bade" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky ir"> ReadBlog请求/响应</strong></p><p id="a0df" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我们将保持简单明了，只通过Id搜索博客。不过，也可以使用<a class="ae my" href="https://developers.google.com/protocol-buffers/docs/proto3#using-oneof" rel="noopener ugc nofollow" target="_blank"><em class="mx"/></a><em class="mx">之一在单个请求消息中使用id或标题。</em></p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="7a26" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky ir">删除博客请求/响应</strong></p><p id="ba24" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">请求对象与ReadBlog相同，我们通过id找到Blog并删除它(这里也可以使用oneof)。如果成功，我们返回<code class="fe no np nq nr b">true</code>，否则返回一个错误。</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="1e47" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky ir">列表博客请求/响应</strong></p><p id="91f4" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">这个是特别的，ListBlogs将列出我们数据库中的所有博客。我们以前的所有服务都是一元的，这意味着它们遵循经典的请求/响应机制。当数据很小时，它工作得很好，但是对于大的数据流，它更好。列表博客将使用服务器流；对于一条请求消息，服务器将发回多条博客消息。</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="1a33" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky ir">协议编译器:协议</strong></p><p id="2931" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">现在我们已经创建了我们的<em class="mx">。proto </em>定义是时候在Go中生成我们的客户机和服务器存根了。我们使用结合了protocol-gen-go插件的<a class="ae my" href="https://github.com/golang/protobuf" rel="noopener ugc nofollow" target="_blank">协议缓冲编译器来实现这一点。</a></p><p id="7206" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">您可以检查安装是否成功:</p><pre class="mo mp mq mr gt ns nr nt nu aw nv bi"><span id="7d35" class="nw jz iq nr b gy nx ny l nz oa">$ protoc — version<br/>libprotoc 3.7.1</span></pre><p id="6200" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">如果是的话，你可以把你的原型文件编译成Go stubs，这将会在<code class="fe no np nq nr b">/proto</code>文件夹中产生一个新文件:<code class="fe no np nq nr b">blog.pb.go</code></p><pre class="mo mp mq mr gt ns nr nt nu aw nv bi"><span id="fd2d" class="nw jz iq nr b gy nx ny l nz oa">protoc proto/blog.proto --go_out=plugins=grpc:.</span></pre><p id="6388" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我建议您浏览一下新生成的文件，您将看到服务器和客户机的类型和接口、创建新服务器和客户机的方法、要实例化的类型(请求、响应和博客)以及这些结构的字段的getters。</p><p id="6811" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">您还会在文件的顶部看到这一行，请牢记在心:</p><pre class="mo mp mq mr gt ns nr nt nu aw nv bi"><span id="ab44" class="nw jz iq nr b gy nx ny l nz oa">// Code generated by protoc-gen-go. DO NOT EDIT.</span></pre><h1 id="9acf" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated"><strong class="ak"> 2。服务器实现</strong></h1><p id="6c07" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated"><strong class="ky ir">启动/停止服务器<br/> </strong>首先，我们需要一些样板文件来创建gRPC服务器和mongoDB连接，向控制台提供一些反馈，并通过<em class="mx">关闭挂钩</em>处理用户关闭服务器的操作。</p><p id="22a7" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我们将在我们的main()函数中设置所有这些，您可以自己随意做一些代码拆分和清理工作。</p><ol class=""><li id="1484" class="lz ma iq ky b kz lu ld lv lh mb ll mc lp md lt ob mf mg mh bi translated">当我们使用日志包时，添加文件名和行号标志</li><li id="9a63" class="lz ma iq ky b kz mi ld mj lh mk ll ml lp mm lt ob mf mg mh bi translated">启动我们的监听器</li><li id="e8bb" class="lz ma iq ky b kz mi ld mj lh mk ll ml lp mm lt ob mf mg mh bi translated">启动一个尚未注册服务的新gRPC服务器。</li><li id="ce88" class="lz ma iq ky b kz mi ld mj lh mk ll ml lp mm lt ob mf mg mh bi translated">创建一个博客服务并注册到我们新的gRPC服务器。</li><li id="2a22" class="lz ma iq ky b kz mi ld mj lh mk ll ml lp mm lt ob mf mg mh bi translated">连接到MongoDB。</li><li id="74f4" class="lz ma iq ky b kz mi ld mj lh mk ll ml lp mm lt ob mf mg mh bi translated">接受侦听器上的传入连接</li><li id="0d9d" class="lz ma iq ky b kz mi ld mj lh mk ll ml lp mm lt ob mf mg mh bi translated">处理用户启动的服务器关闭(CTRL+C)</li></ol><p id="8983" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">现在让我们开始创建我们的<code class="fe no np nq nr b">main()</code>函数。</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="8248" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">现在让我们启动一个新的gRPC服务器并注册我们的博客服务。为了实现这一点，我们将使用<em class="mx"> grpc包</em>以及通过编译我们的<em class="mx">创建的<em class="mx"> blogpb包</em>。原型</em>文件。我们的<em class="mx"> blogpb包</em>有一个名为<em class="mx">RegisterBlogServiceServer</em>的方法，该方法接收一个指向新gRPC服务器的指针和一个<em class="mx"> BlogServiceServer结构</em>，该结构遵循我们生成的<em class="mx"> blog.pb.go </em>文件中的<em class="mx"> BlogServiceServer接口</em>。</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="7327" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">干得好！现在我们将创建我们的mongodb连接，所以请确保您已经安装了MongoDB以及我们将使用的官方<a class="ae my" href="https://github.com/mongodb/mongo-go-driver" rel="noopener ugc nofollow" target="_blank"><em class="mx">MongoDB-go-driver</em></a>。如果您曾经使用过另一种语言的mongodb驱动程序，您会发现它非常相似。</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="c493" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">最后但同样重要的是，我们将服务侦听器接受传入的连接，并使用goroutine和channel阻塞主通道，直到用户按下CTRL+C。</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="74ed" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我们完事了。您现在可以启动运行<code class="fe no np nq nr b">go run server/main.go</code>的服务器，但是要确保预先运行<code class="fe no np nq nr b">sudo service mongod start</code>或<em class="mx"> db。Ping() </em>将返回一个错误。然后，您可以通过按CTRL+C关闭服务器。</p><p id="75e6" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">如果一切顺利，您应该会看到如下内容:</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/94ffdd184b5a3fe95f59c65804acb6ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1072/format:webp/1*KamsTX-Chf45NYzxCN0kfw.png"/></div></figure><p id="5da5" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><em class="mx"> **注意:您可能需要在下一节中添加空方法来避免编译错误，因为BlogServiceServer还没有遵循它的接口(在blog.pb.go中)。</em></p><h2 id="dac2" class="nw jz iq bd ka od oe dn ke of og dp ki lh oh oi km ll oj ok kq lp ol om ku on bi translated">创建我们的原型服务处理程序</h2><p id="0687" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">现在我们已经准备好了我们的服务器，是时候为我们在<em class="mx">中定义的服务添加方法了。原型</em>文件。这些方法将我们的BlogServiceServer作为接收方，因此它将遵守它的接口。</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="e6fe" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">在函数体中，我们通常使用以下工作流:</p><p id="2414" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">Protbuf消息(请求)→常规Go结构→转换为BSON + Mongo动作→prot buf消息(响应)</p><p id="994d" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">目前缺少的是表示博客的常规go结构，它可以转换成BSON。所以让我们在main函数之上创建这个类型，并添加一些标签，这样bson包将使用元信息来分配键。</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="d09f" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">现在让我们用<strong class="ky ir"> CreateBlog </strong>方法。它接受一个<em class="mx">上下文</em>和一个请求，在本例中是<em class="mx"> CreateBlogReq。</em>首先，我们将从请求消息中提取博客消息，并将其转换为常规的go结构。使用我们提供的元标签，InsertOne() 将为我们把它转换成<em class="mx"> BSON </em>。来自<em class="mx"> InsertOne() </em>的结果返回我们的<em class="mx">集合</em>中新<em class="mx">文档</em>的<em class="mx">对象ID </em>，然后我们可以将它添加到我们的<em class="mx"> Blog protobuf消息</em>中，以包装在一个<em class="mx"> CreateBlogResponse </em>中。</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="2666" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">接下来我们将执行<strong class="ky ir">read blog()</strong>,<em class="mx">read blogreq</em>将接收博客的<em class="mx">对象ID </em>并从我们的集合中检索该文档。MongoDB <em class="mx"> FindOne() </em>方法接受一个上下文和一个过滤器，这是一个<em class="mx"> BSON文档</em>，通过它的键对其进行过滤。我们只需将找到的文档解码成一个常规的go结构，这样我们就可以将它转换回protobuffer消息。</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="a8a0" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">既然我们可以创建和阅读博客，我们也应该能够删除一个。对于<strong class="ky ir"> DeleteBlog </strong>，我们将使用mongodb <em class="mx"> DeleteOne() </em>方法，该方法接收要移除的文档的对象ID 。如果移除成功，我们将返回一个布尔值，否则返回一个错误。</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="12b9" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">对于我们的最后一个CRUD操作，我们需要方法来<strong class="ky ir">更新博客</strong>。为了简单起见，我们将使用根据我们的请求编码的文档来完全替换集合中的现有文档。在真实的场景中，我们会对参数进行nil检查，以便实际上只更新已填充的字段(使用MongoDB中的set关键字)。第二个怪癖是Mongo的<em class="mx"> FindOneAndUpdate() </em>返回旧文档，所以我们必须显式地告诉它返回新文档。</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="085a" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我们将实现的最后一个方法，<strong class="ky ir"> ListBlogs </strong>，略有不同。我们之前的操作是<em class="mx">一元CRUD操作</em>，这意味着它们使用经典的<em class="mx"> 1响应1请求机制</em>。</p><p id="20b3" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">然而，如果我们想列出所有博客，数据负载可能会变得太大而无法在一个响应中返回，因此我们将通过gRPC实现<strong class="ky ir"> <em class="mx">服务器流</em> </strong>。对于一个列出博客的请求，服务器将保持博客消息的流式传输，直到所有的博客都被发送回客户机。</p><p id="d6d7" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">MongoDB通过其<em class="mx">光标</em>特性在这方面非常有用。MongoDB中的游标是指向查询结果的指针，而不是内存中的所有结果。</p><blockquote class="oo op oq"><p id="5911" class="kw kx mx ky b kz lu lb lc ld lv lf lg or lw lj lk os lx ln lo ot ly lr ls lt ij bi translated">指向查询结果集的指针。客户端可以遍历游标来检索结果。</p></blockquote><p id="ce57" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">所以我们要做的是使用<em class="mx">游标迭代游标。Next() </em>并将每个博客作为消息发送给客户端，直到光标不再显示结果，此时我们将关闭服务器端的流。当您看到代码时，事情变得更加简单:</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="aa71" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">干得好，这就是我们的整个服务器实施。你正在成为一个超级地鼠！接下来，我们将开始使用<a class="ae my" href="https://github.com/spf13/cobra" rel="noopener ugc nofollow" target="_blank"> Cobra </a>开发CLI客户端应用程序。</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/2a26f0b63087da00285d669d29d06682.png" data-original-src="https://miro.medium.com/v2/resize:fit:1162/format:webp/1*MT2x2BRSYyECJEHwVu5JgA.png"/></div></figure><h1 id="f1af" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">3.客户端实现</h1><p id="ac2d" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated"><strong class="ky ir"> Cobra <br/> </strong>如前所述，我们将使用Cobra为我们的客户制作一个CLI应用程序。它附带了一个方便的生成器来为我们生成样板文件。</p><p id="7f4f" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">cobra生成器还不能与go模块一起工作，所以我们将在我们的<em class="mx"> $GOPATH </em>中生成命令文件，然后将它们复制粘贴到我们正在创建项目的<em class="mx"> /client </em>文件夹中(如果您从一开始就在<em class="mx"> $GOPATH </em>中启动，那么您可以从<em class="mx"> /client </em>文件夹中运行生成器)。</p><p id="fe0f" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">首先，安装眼镜蛇。这将在<em class="mx"> $GOPATH/bin </em>中创建一个可执行文件，我们可以在终端的任何地方运行它(如果您的设置正确的话)。</p><pre class="mo mp mq mr gt ns nr nt nu aw nv bi"><span id="4ee4" class="nw jz iq nr b gy nx ny l nz oa">$ go get github.com/spf13/cobra/cobra</span></pre><p id="0a6e" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">一旦Cobra成功安装，我们就可以启动一个新项目。</p><pre class="mo mp mq mr gt ns nr nt nu aw nv bi"><span id="c787" class="nw jz iq nr b gy nx ny l nz oa">$ cobra init</span></pre><p id="6e67" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">这将生成一个<em class="mx"> main.go </em>文件和一个<em class="mx"> /cmd </em>文件夹。main.go文件除了调用位于<em class="mx"> /cmd/root.go中的根命令上的<em class="mx">执行</em>之外不做任何事情。</em></p><p id="d5a6" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">在<em class="mx"> /cmd/root.go </em>中有两件事对我们很重要，那就是<em class="mx"> rootCmd struct </em>(一条<em class="mx">眼镜蛇。Command </em> type)，它包含命令名和描述以及<em class="mx"> init() </em>函数，我们将在这里初始化客户端。由于<em class="mx">子命令</em>被绑定到r <em class="mx"> oot命令</em>，Cobra总是在执行<em class="mx">子命令</em>之前启动一个客户端。</p><p id="26e2" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">为您的根命令命名并提供一些描述:</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="ee0b" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">并初始化客户端:</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="2b19" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">如果我说这是我们客户最难的部分，我不是在开玩笑，非常简单，对吗？您可以随意添加标志或命令来使用Cobra，您也可以使用现成的“帮助”标志。在我们完成的应用程序中，当被调用时，它看起来像这样:</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi ov"><img src="../Images/0d01f6bbb0be9886224a6e8d9b003ab9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RAfJueeaQrkJDOOhtIQEcg.png"/></div></div></figure><p id="469b" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky ir">创建博客命令<br/> </strong>现在我们的根命令已经设置好了，让我们创建第一个子命令，这样我们就可以将博客添加到我们的数据库中了。</p><pre class="mo mp mq mr gt ns nr nt nu aw nv bi"><span id="8288" class="nw jz iq nr b gy nx ny l nz oa">$ cobra add create</span></pre><p id="2da2" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">这将创建一个新文件，<em class="mx"> /cmd/create.go </em>，其布局与<em class="mx"> root.go </em>大致相同。有一个类型为<em class="mx"> cobra的结构。命令</em>和一个<em class="mx"> init() </em>函数。</p><p id="8a0c" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">在<em class="mx"> init </em>()函数中，我们将定义我们的标志。每个博客条目都需要一个作者、标题和内容，所以让我们把这些标志也设为必需的。要添加一个标志，我们首先需要该命令的<em class="mx">标志集</em>，使用<em class="mx"> StringP(name，速记，defaultVal，description) </em>我们可以添加一个有速记的标志(例如，“a”代表“作者”)。在<em class="mx"> init() </em>函数的末尾，我们将子命令绑定到<em class="mx">根</em>。</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="2efc" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">为了运行与create命令相关联的方法，我们的<em class="mx"> cobra。命令</em> struct将获得一个附加属性<em class="mx"> RunE </em>。这允许我们执行一个返回错误的方法，因为记住我们返回的是内部gRPC错误。与命令(<em class="mx">命令)相关联的<em class="mx">标志集</em>。Flags() </em>)允许我们很容易地检索给定标志的参数。</p><p id="3c78" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">从这些标志中，我们可以创建我们的请求，<em class="mx"> CreateBlogReq </em>并在客户端调用<em class="mx"> CreateBlog </em>方法。这将通过网络发送RPC请求并返回一个响应。</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="nm nn l"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">Gist似乎不喜欢正确的对齐方式…</figcaption></figure><p id="7867" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky ir">阅读博客命令</strong> <br/>那很简单吧？让我们继续做一些更简单直接的事情，尤其是现在你已经掌握了窍门！阅读博客的命令；这将接受一个标志，即博客对象Id。</p><p id="072d" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">类似于我们的<em class="mx">创建命令</em>的<em class="mx"> init() </em>函数，我们将为<em class="mx"> id </em>创建我们的标志，并将子命令绑定到我们的根。</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="f5de" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">在我们的命令结构中，我们将设置适当的名称和描述。我们的<em class="mx">符文</em>方法也会类似。我们将从<em class="mx">标志集</em>中检索<em class="mx"> id </em>，从中创建我们的请求(<em class="mx"> ReadBlogReq </em>)并调用RPC调用。</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="cfb3" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky ir">更新博客命令<br/> </strong>在客户端更新博客与创建博客几乎是一样的，只是增加了id标志，因为我们需要告诉mongoDB要更新哪个文档。让我们调用<code class="fe no np nq nr b">cobra add update</code>并编辑生成的文件。</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="99f2" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky ir">删除博客命令<br/> </strong>类似于read命令，该命令采用一个标志，即博客id，并将其从数据库中删除。除了调用的客户端方法之外，代码几乎完全相同。</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="6df1" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky ir">列出博客命令</strong></p><p id="5abc" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">这一个会略有不同，因为如果你记得它是一个使用服务器端流的RPC方法。调用ListBlogs将返回一个grpc客户端流。如果你想了解更多，我建议你查看gRPC包中的界面。但本质上是列出所有的博客，我们将循环，直到我们到达流的末尾。</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="nm nn l"/></div></figure><h1 id="1a60" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">4.收尾工作</h1><p id="cf4e" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">这是一条漫长的道路，但我们已经到了终点。现在，您实际上可以开始使用您制作的CLI应用程序了。如果你已经从你的<em class="mx"> $GOPATH </em>开始工作，你可以<em class="mx">去安装</em>CLI应用程序并直接从终端使用root命令。否则，您可以像这样调用命令:</p><pre class="mo mp mq mr gt ns nr nt nu aw nv bi"><span id="fac6" class="nw jz iq nr b gy nx ny l nz oa">go run client/main.go create -a “Nico Vergauwen” -t “Learning Go” -c “The quick brown fox jumps over the lazy dog”</span></pre><p id="816c" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">就这样，你正在成为Go和gRPC的王者！感谢您的阅读，希望您喜欢！</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/9dc93d1de8dfab4e3b38f9291590b012.png" data-original-src="https://miro.medium.com/v2/resize:fit:472/format:webp/0*jSVdjQX5tDsLhxHw.jpg"/></div></figure></div></div>    
</body>
</html>