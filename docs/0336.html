<html>
<head>
<title>Building a Node.js WebSocket Chat App with Socket.io and React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Socket.io和React构建Node.js WebSocket聊天应用</h1>
<blockquote>原文：<a href="https://itnext.io/building-a-node-js-websocket-chat-app-with-socket-io-and-react-473a0686d1e1?source=collection_archive---------0-----------------------#2018-02-22">https://itnext.io/building-a-node-js-websocket-chat-app-with-socket-io-and-react-473a0686d1e1?source=collection_archive---------0-----------------------#2018-02-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="c8d8" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用JavaScript的Socket.io教程</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/e5dd0ea9f3a4a509feaea312ec7a798e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*r0g6J-HU5etP2ICGB2tEmw.gif"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated"><strong class="bd kv">行尸走肉的味道</strong></figcaption></figure><p id="d488" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae ls" href="https://www.linkedin.com/cws/share?url=https%3A%2F%2Fitnext.io%2Fbuilding-a-node-js-websocket-chat-app-with-socket-io-and-react-473a0686d1e1" rel="noopener ugc nofollow" target="_blank"> <em class="lt">点击这里在LinkedIn </em> </a>上分享这篇文章</p><p id="d2c3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">WebSockets非常有利于在web上构建实时通信或数据流应用程序，例如聊天应用程序和传输图像或其他类型媒体的应用程序。此外，您可以利用浏览器的JavaScript WebSocket API轻松地建立到任何套接字端点的连接。</p><p id="1499" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本教程中，我们将使用<a class="ae ls" href="https://socket.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> socket.io </strong> </a>和<a class="ae ls" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> React </strong> </a>基于WebSockets构建一个简单的聊天应用。和往常一样，完整的源代码可以在<a class="ae ls" href="https://github.com/justadudewhohacks/websocket-chat" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">这里</strong> </a>获得。</p><h1 id="5c63" class="lu lv iq bd kv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">为什么是WebSockets而不是HTTP(S)？</h1><p id="2125" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">使用WebSockets，您可以建立一个持久的连接，这允许客户端和服务器之间的双向通信。现在，你可以在网上找到很多基于REST的API，它们都是建立在HTTP之上的。这些API的使用如下:客户端请求页面或资源，服务器响应(<strong class="ky ir">请求-响应</strong>)。因此，在HTTP上使用WebSockets具有以下优点:</p><h2 id="2d75" class="mq lv iq bd kv mr ms dn lz mt mu dp md lf mv mw mf lj mx my mh ln mz na mj nb bi translated">1.实时通信</h2><p id="e2f6" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">在请求-响应场景中，如果客户机不先请求某些东西，服务器就无法向客户机发送数据。客户端将不得不持续地定期请求更改(<strong class="ky ir">轮询</strong>)，这不是我们所认为的实时。想象一下一个聊天应用，你每30秒才能看到新消息。挺烦的…</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/abd56610d45f1437ad735da6fe8885ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*t05OSlSQqz5p9Gu-LZMEfg.jpeg"/></div></figure><p id="99ba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">服务器可以通过HTTP消息通知客户端新事件。您可以将消息推送给在客户端浏览器中运行的<strong class="ky ir">服务工作者</strong>，或者让客户端订阅<strong class="ky ir">服务器发送的事件</strong> ( <strong class="ky ir"> SSE </strong>)。然而，使用WebSockets，我们可以免费获得这一功能，并可以轻松地将收到的新消息广播给其他连接的客户端。</p><h2 id="e60f" class="mq lv iq bd kv mr ms dn lz mt mu dp md lf mv mw mf lj mx my mh ln mz na mj nb bi translated">2.开销更少</h2><p id="195b" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">HTTP是一种无状态协议，因此HTTP报头的开销被添加到每一条消息中，其大小会变得相当大。这尤其会对负载相对较小的频繁消息产生影响(例如在聊天应用中)。</p><p id="aea5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，HTTP连接通常只在一定数量的请求中保持活动，并在空闲一段时间后关闭。因此，必须频繁地重新建立连接，这由于TCP三次握手(以及在HTTPS的情况下交换证书和密钥对)而引入了初始设置时间。</p><h2 id="0573" class="mq lv iq bd kv mr ms dn lz mt mu dp md lf mv mw mf lj mx my mh ln mz na mj nb bi translated">3.流处理</h2><p id="8057" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">使用WebSockets，人们可以在客户机和服务器之间传输任意大小的二进制数据。因此，它非常适合流处理任务，如图像处理应用程序，这些应用程序可能会来回传输图像或视频数据。</p><p id="56ff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我想你明白了，为什么WebSockets可能有用…</p><h1 id="d88a" class="lu lv iq bd kv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">最后让我们来编写应用程序吧！</h1><p id="f9c6" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">为此，我们将使用<a class="ae ls" href="https://www.npmjs.com/package/socket.io" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> socket.io </strong> </a> npm包，它为我们的聊天服务器提供了node.js WebSocket API，为浏览器端提供了JavaScript客户端。这样，我们就不必发送实际的二进制数据，因为这个包会友好地将我们的数据序列化到JSON中。</p><p id="84ec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面我将详细讨论整个源代码。为了向您介绍socket.io，我将重点介绍应用程序中有趣的部分。</p><h2 id="f321" class="mq lv iq bd kv mr ms dn lz mt mu dp md lf mv mw mf lj mx my mh ln mz na mj nb bi translated">那么，我们要建造什么？</h2><p id="8f66" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">不要太疯狂。一旦客户端连接，我们希望用户能够选择其中一个字符。之后，他或她能够加入和离开聊天室，并向同一聊天室的其他用户发送消息。这里有一个快速演示来形象化我所说的内容:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="edc6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们开始吧！</p><h2 id="0df1" class="mq lv iq bd kv mr ms dn lz mt mu dp md lf mv mw mf lj mx my mh ln mz na mj nb bi translated">侦听传入的套接字连接</h2><p id="1d47" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">在这个例子中，我们将把socket.io附加到一个简单的HTTP服务器上。如果你愿意，你也可以很容易地将socket.io与express结合使用。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nf ne l"/></div></figure><p id="c1e6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用<strong class="ky ir"><em class="lt">io . on(‘连接’，cb) </em> </strong>我们正在监听传入的套接字连接。一旦一个新的客户端连接上，我们就可以将多个事件监听器附加到流上。<strong class="ky ir"> <em class="lt">错误</em> </strong>和<strong class="ky ir"> <em class="lt">断开</em> </strong>事件是预定义的。其他事件是我为实现聊天API而引入的自定义事件。</p><p id="d0ed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">服务器正在监听套接字客户机在端口3000上的连接，我们将在下面做这件事。</p><h2 id="c43c" class="mq lv iq bd kv mr ms dn lz mt mu dp md lf mv mw mf lj mx my mh ln mz na mj nb bi translated">使用客户端连接到套接字服务器</h2><p id="5deb" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">注意，在客户端我们想要要求<strong class="ky ir"><em class="lt">socket . io-client</em></strong>。如果您没有使用bundler(我在这里使用webpack ),您必须将io客户端脚本包含到您的文档中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nf ne l"/></div></figure><p id="5d62" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们的客户端中，我们可以分别用<strong class="ky ir"> <em class="lt"> socket.on </em> </strong>监听事件，用<strong class="ky ir"> <em class="lt"> socket.off </em> </strong>删除事件监听器。稍后我们将使用<strong class="ky ir"><em class="lt">register handler</em></strong>在我们的<strong class="ky ir"> <em class="lt">聊天室</em> </strong>组件中注册一个<strong class="ky ir"><em class="lt">on message received</em></strong>回调，以便更新组件状态并显示收到的新消息。</p><p id="0e84" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用<strong class="ky ir"> <em class="lt"> socket.emit </em> </strong>我们可以发出自定义事件，我们的聊天服务器会监听这些事件。作为第二个参数，我们可以传递实际数据。此外，我们甚至可以通过将回调作为第三个参数传递来实现请求-响应类型的通信，我们可以使用回调在客户机上发出事件后从聊天服务器接收响应，反之亦然。这非常简洁，我们将在后面的例子中大量使用它。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/555cf80ae6f4ed7b28933c6fbe810a14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*H0mCDTWdcO_rmNZTUI8fmw.jpeg"/></div></figure><h2 id="ab6e" class="mq lv iq bd kv mr ms dn lz mt mu dp md lf mv mw mf lj mx my mh ln mz na mj nb bi translated">实现API</h2><p id="fd18" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">在我们的聊天服务器上，我们将跟踪所有连接的客户端和他们选择的角色(<strong class="ky ir"><em class="lt">client manager</em></strong>)以及每个聊天室的状态，例如，加入聊天室的用户列表和发送到该聊天室的所有消息的历史记录(<strong class="ky ir"><em class="lt">chattroom manager</em></strong>)。</p><p id="9533" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们要添加的第一件事，是为客户端选择一个字符的端点:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nf ne l"/></div></figure><p id="7adc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将坚持使用<strong class="ky ir"><em class="lt">【error，result】</em></strong>模式，并在出现错误的情况下，使用错误消息作为第一个参数来调用回调。本质上，我们在这里所做的是检查所选择的角色是否可用，并将客户端分配给该角色，否则用错误消息通知客户端。</p><p id="032c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当用户加入、离开聊天室或发送信息时，更有趣的事情发生了。这些事件的相应处理程序使用以下助手函数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nf ne l"/></div></figure><p id="7462" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它确保所传递的聊天室是有效的，并且预先选择了一个角色，并且“<strong class="ky ir"> <em class="lt">用户离开/加入聊天室”</em> </strong>或者用户发送的消息被添加到聊天室的聊天历史中。此外，我们向聊天室的所有用户广播该事件。</p><p id="8f46" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="lt">聊天室</em> </strong>的实现相当简单:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nf ne l"/></div></figure><p id="3288" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了简单起见，<strong class="ky ir"> <em class="lt"> chatHistory </em> </strong>只是一个数组，我们保存了该聊天室中所有用户的映射，这样我们就可以向<strong class="ky ir"><em class="lt">broadcast message</em></strong>中的所有客户端发出一个<strong class="ky ir"><em class="lt">message</em></strong><strong class="ky ir"><em class="lt"/></strong>事件。</p><p id="4f3f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为实际的处理程序彼此功能相似，所以我在这里只展示连接处理程序:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nf ne l"/></div></figure><p id="1f3d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">处理完事件后，我们将用户添加到聊天室，并用当前的聊天历史进行响应。</p><p id="2728" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，一旦客户端断开连接，我们也会确保将该用户从所有聊天室中删除，并删除客户端信息，这将为其他用户释放角色选择:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nf ne l"/></div></figure><h2 id="9e17" class="mq lv iq bd kv mr ms dn lz mt mu dp md lf mv mw mf lj mx my mh ln mz na mj nb bi translated">在客户端实时显示消息</h2><p id="328d" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">在我们的聊天室组件中，我们添加了以下内容:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nf ne l"/></div></figure><p id="fccc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦我们进入一个新的聊天室，我们在收到一个“<strong class="ky ir"> <em class="lt">加入</em> </strong>”事件后初始化聊天服务器返回的聊天历史。如前所述，当组件挂载时，我们从客户端API在处理程序中注册onMessageReceived回调。一旦注册，客户端将接收聊天服务器广播的消息事件。这样，我们可以用新消息更新组件状态，并立即重新呈现聊天活动。</p><h1 id="061f" class="lu lv iq bd kv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">最后的话</h1><p id="0d6e" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">这已经是我们用WebSockets做的所有有趣的事情了。剩下的就是用<strong class="ky ir">反应</strong>和<strong class="ky ir">材质构建一个UI——UI</strong>。所以如果你对此感兴趣，你可能想看看源代码。除此之外，我希望你在读完这篇教程后对WebSockets和socket.io有信心。编码快乐！</p><p id="7c88" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="lt">如果你喜欢这篇文章，请留下一些掌声，并在medium和/或</em><a class="ae ls" href="https://twitter.com/justadudewhohax" rel="noopener ugc nofollow" target="_blank"><em class="lt">Twitter</em></a><em class="lt">:)上关注我。也可以随意在</em> <a class="ae ls" href="https://github.com/justadudewhohacks/websocket-chat" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="lt"> github资源库</em> </strong> </a> <em class="lt">上留下一颗星星。敬请关注更多教程！</em></p></div></div>    
</body>
</html>