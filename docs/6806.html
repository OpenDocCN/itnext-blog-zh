<html>
<head>
<title>Alternatives to DTO</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">DTO的替代品</h1>
<blockquote>原文：<a href="https://itnext.io/alternative-dto-cb6caf9f4ff8?source=collection_archive---------0-----------------------#2022-03-06">https://itnext.io/alternative-dto-cb6caf9f4ff8?source=collection_archive---------0-----------------------#2022-03-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/5cde6a6869fd6a2691e35bb6d4bb60b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RDH_vWQAHBfjKXqV4t1DbQ.jpeg"/></div></div></figure><p id="3030" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">十多年前，我<a class="ae kw" href="https://blog.frankel.ch/dto-in-anger" rel="noopener ugc nofollow" target="_blank">写过</a>关于DTO:</p><blockquote class="kx ky kz"><p id="b615" class="jy jz la ka b kb kc kd ke kf kg kh ki lb kk kl km lc ko kp kq ld ks kt ku kv ij bi translated"><em class="iq">数据传输对象是在进程间传送数据的对象。使用它的动机是进程间的通信通常依靠远程接口来完成，其中每个调用都是一个昂贵的操作。因为每个调用的大部分开销都与客户端和服务器之间的往返时间有关，所以减少调用次数的一种方法是使用一个对象(d to ),该对象聚集本应由多次调用传输的数据，但只由一次调用提供服务。</em></p><p id="6a4a" class="jy jz la ka b kb kc kd ke kf kg kh ki lb kk kl km lc ko kp kq ld ks kt ku kv ij bi translated"><em class="iq"> — </em> <a class="ae kw" href="https://en.wikipedia.org/wiki/Data_transfer_object" rel="noopener ugc nofollow" target="_blank"> <em class="iq">百科</em> </a></p></blockquote><p id="f6a2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我过去认为(现在仍然认为)这应该成为过去。然而，它的用法似乎仍然很普遍。</p><p id="9c31" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我不否认有一些有效的理由来转换数据。但是，除了传统的DTO流程，还有其他选择:</p><ol class=""><li id="33a3" class="le lf iq ka b kb kc kf kg kj lg kn lh kr li kv lj lk ll lm bi translated">从服务层返回一个业务对象。请注意，在我之前参与的项目中，我们直接将业务对象映射到从数据库中读取的实体。</li><li id="fa88" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated">将业务对象转换为表示层中的DTO</li><li id="173a" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated">从表示层返回DTO</li></ol><h1 id="a5f9" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">返回实体本身</h1><p id="7735" class="pw-post-body-paragraph jy jz iq ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">当实体的属性是需要显示的属性的超集时，不需要聚合其他属性。将实体转化为DTO不仅是矫枉过正。它会影响性能。</p><p id="06dd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这种情况下，最好的方法是返回实体本身。</p><h1 id="c241" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">JPA投影</h1><p id="fa96" class="pw-post-body-paragraph jy jz iq ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">我们在特定的上下文中请求特定的数据。因此，当调用到达数据访问层时，所需数据的范围是完全已知的:执行适合该范围的SQL查询是有意义的。</p><p id="3c8d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为此，JPA提供了预测。本质上，查询中的投影允许精确地选择想要的数据。这里有一个例子:给定一个<code class="fe mv mw mx my b">Person</code>实体类和一个<code class="fe mv mw mx my b">PersonDetails</code>常规类:</p><pre class="mz na nb nc gt nd my ne nf aw ng bi"><span id="65df" class="nh lt iq my b gy ni nj l nk nl">CriteriaQuery&lt;PersonDetails&gt; q = cb.createQuery(PersonDetails.class);<br/>Root&lt;Person&gt; c = q.from(Person.class);<br/>q.select(cb.construct(PersonDetails.class,<br/>  c.get(Person_.firstName),<br/>  c.get(Person_.lastName),<br/>  c.get(Person_.birthdate)<br/>));</span></pre><h1 id="fd8f" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">杰克逊转炉</h1><p id="8a4e" class="pw-post-body-paragraph jy jz iq ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">具体到JSON，我们可以将提供正确数据的过程委托给序列化程序框架，<em class="la">，例如</em> <a class="ae kw" href="https://github.com/FasterXML/jackson" rel="noopener ugc nofollow" target="_blank"> Jackson </a>。其背后的思想如下:主代码照常处理实体，在边缘，Jackson转换器将其转换为所需的JSON结构。</p><p id="f430" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果需要更少的数据，那就太容易了。如果更多，那么转换器需要更多的依赖项来获取数据。当然，如果这些数据来自同一个数据存储，这不是很好，上面的替代方法更合适。如果没有，这是一个选择。</p><h1 id="9349" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">GraphQL</h1><p id="ab61" class="pw-post-body-paragraph jy jz iq ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">最后但同样重要的是，可以返回完整的实体，让客户端决定哪些数据在其上下文中有意义。</p><p id="1c8f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">GraphQL 就是围绕这个想法建立的:脸书创建了它，现在它已经完全开源了。它的主要优点是提供了一个规范，并在此基础上提供了许多特定语言的实现<a class="ae kw" href="http://graphql.github.io/code/#server-libraries" rel="noopener ugc nofollow" target="_blank">。</a></p><blockquote class="kx ky kz"><p id="c0a6" class="jy jz la ka b kb kc kd ke kf kg kh ki lb kk kl km lc ko kp kq ld ks kt ku kv ij bi translated"><em class="iq">你的API的查询语言</em></p><p id="20cc" class="jy jz la ka b kb kc kd ke kf kg kh ki lb kk kl km lc ko kp kq ld ks kt ku kv ij bi translated">GraphQL是一种API查询语言，也是一种用现有数据完成这些查询的运行时语言。GraphQL为API中的数据提供了完整且易于理解的描述，使客户能够准确地要求他们需要的东西，使API更容易随时间发展，并支持强大的开发工具。</p><p id="0c3e" class="jy jz la ka b kb kc kd ke kf kg kh ki lb kk kl km lc ko kp kq ld ks kt ku kv ij bi translated"><em class="iq"> — </em> <a class="ae kw" href="http://graphql.github.io" rel="noopener ugc nofollow" target="_blank"> <em class="iq"> GraphQL网站</em> </a></p></blockquote><h1 id="35d7" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">结论</h1><p id="00c3" class="pw-post-body-paragraph jy jz iq ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">当业务模型和表示模型之间存在差距时，很容易回到古老的“模式”，如DTO。然而，以上任何一种选择都可能更相关。</p><p id="360f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">更进一步:</strong></p><ul class=""><li id="b700" class="le lf iq ka b kb kc kf kg kj lg kn lh kr li kv nm lk ll lm bi translated"><a class="ae kw" href="https://vladmihalcea.com/the-best-way-to-map-a-projection-query-to-a-dto-with-jpa-and-hibernate/" rel="noopener ugc nofollow" target="_blank">将投影查询映射到DTO的最佳方式</a></li><li id="231e" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv nm lk ll lm bi translated"><a class="ae kw" href="https://www.thoughts-on-java.org/entities-dtos-use-projection/" rel="noopener ugc nofollow" target="_blank">实体或dto——何时应使用哪种投影？</a></li><li id="ab2b" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv nm lk ll lm bi translated"><a class="ae kw" href="http://graphql.github.io/" rel="noopener ugc nofollow" target="_blank"> GraphQL </a></li></ul></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><p id="a89f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="la">原载于</em> <a class="ae kw" href="https://blog.frankel.ch/alternatives-dto/" rel="noopener ugc nofollow" target="_blank"> <em class="la">一个Java极客</em></a><em class="la">2022年3月6日</em></p></div></div>    
</body>
</html>