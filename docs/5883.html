<html>
<head>
<title>HMock: First Rate Mocks in Haskell</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">HMock:哈斯克尔一流的模拟</h1>
<blockquote>原文：<a href="https://itnext.io/hmock-first-rate-mocks-in-haskell-e59d7c3b066c?source=collection_archive---------3-----------------------#2021-06-20">https://itnext.io/hmock-first-rate-mocks-in-haskell-e59d7c3b066c?source=collection_archive---------3-----------------------#2021-06-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="c6b4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在今年的Zurihac年底，我发布了HMock 的预览版<a class="ae kl" href="https://hackage.haskell.org/package/HMock-0.1.0.1" rel="noopener ugc nofollow" target="_blank">，这是一个用Haskell进行模拟测试的新库。我们来谈谈这是什么，我为什么写它，以及你如何使用它。</a></p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/469f9e95e86bb49f705c1a5131ca7e1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*yIulRNJ-jQDw5oQp"/></div></div></figure><h1 id="3cb4" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">玩具聊天机器人</h1><p id="33cb" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">假设我想用Haskell写一个聊天机器人。我可能会从几个类型开始，像这样…</p><pre class="kn ko kp kq gt mb mc md me aw mf bi"><span id="53f8" class="mg kz iq mc b gy mh mi l mj mk">newtype <strong class="mc ir">User </strong>= User String deriving (Eq, Show)<br/>data <strong class="mc ir">PermLevel </strong>= Guest | NormalUser | Admin deriving (Eq, Show)<br/>newtype <strong class="mc ir">Room </strong>= Room String deriving (Eq, Show)<br/>data <strong class="mc ir">BannedException</strong> = BannedException deriving (Show)</span><span id="e7f6" class="mg kz iq mc b gy ml mi l mj mk">instance Exception BannedException</span></pre><p id="ebc9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我需要登录聊天服务器，连接到正确的房间，阅读和发送消息…真是一团糟！我可以深入研究并开始用套接字和TCP在<code class="fe mm mn mo mc b">IO</code>中实现，但是构建一个抽象层也不错。我会用一些MTL风格的类型类来做这件事。下面是我的机器人需要做的一些事情。</p><pre class="kn ko kp kq gt mb mc md me aw mf bi"><span id="716e" class="mg kz iq mc b gy mh mi l mj mk">class Monad m =&gt; <strong class="mc ir">MonadAuth</strong> m where<br/>  <strong class="mc ir">login</strong> :: String -&gt; String -&gt; m ()<br/>  <strong class="mc ir">logout</strong> :: m ()<br/>  <strong class="mc ir">hasPermission</strong> :: PermLevel -&gt; m Bool</span><span id="443f" class="mg kz iq mc b gy ml mi l mj mk">class MonadAuth m =&gt; <strong class="mc ir">MonadChat </strong>m where<br/>  <strong class="mc ir">joinRoom</strong> :: String -&gt; m Room<br/>  <strong class="mc ir">leaveRoom</strong> :: Room -&gt; m ()<br/>  <strong class="mc ir">sendChat</strong> :: Room -&gt; String -&gt; m ()<br/>  <strong class="mc ir">pollChat</strong> :: Room -&gt; m (User, String)<br/>  <strong class="mc ir">ban</strong> :: Room -&gt; User -&gt; m ()</span><span id="09b1" class="mg kz iq mc b gy ml mi l mj mk">class Monad m =&gt; <strong class="mc ir">MonadBugReport</strong> m where<br/>  <strong class="mc ir">reportBug</strong> :: String -&gt; m ()</span></pre><p id="7fcf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这样好多了！考虑到正确的原语，我将编写机器人。我不会解释代码，但它在这里。我们的机器人监听聊天，禁止任何淘气的用户，并接受和传递错误报告。</p><pre class="kn ko kp kq gt mb mc md me aw mf bi"><span id="43e9" class="mg kz iq mc b gy mh mi l mj mk">type MonadChatBot m = (MonadChat m, MonadBugReport m)</span><span id="6fff" class="mg kz iq mc b gy ml mi l mj mk"><strong class="mc ir">chatbot </strong>:: (MonadMask m, MonadChatBot m) =&gt; String -&gt; m ()<br/>chatbot roomName = do<br/>  login "HMockBot" "secretish"<br/>  handleRoom roomName `finally` logout</span><span id="f2a2" class="mg kz iq mc b gy ml mi l mj mk"><strong class="mc ir">handleRoom </strong>:: (MonadMask m, MonadChatBot m) =&gt; String -&gt; m ()<br/>handleRoom roomName = do<br/>  room &lt;- joinRoom roomName<br/>  listenAndReply room `finally` leaveRoom room</span><span id="dda9" class="mg kz iq mc b gy ml mi l mj mk"><strong class="mc ir">listenAndReply </strong>:: MonadChatBot m =&gt; Room -&gt; m ()<br/>listenAndReply room = do<br/>  (user, msg) &lt;- pollChat room<br/>  finished &lt;- case words msg of<br/>    ["!hello"] -&gt; sendChat room "Nice to meet you."<br/>    ["!leave"] -&gt; return True<br/>    ("!bug" : ws) -&gt; reportBug (unwords ws) &gt;&gt; return False<br/>    ws | any isFourLetterWord ws -&gt; do<br/>      banIfAdmin room user<br/>      return False<br/>    _ -&gt; return False<br/>  unless finished (listenAndReply room)</span><span id="cab9" class="mg kz iq mc b gy ml mi l mj mk"><strong class="mc ir">isFourLetterWord </strong>:: [Char] -&gt; Bool<br/>isFourLetterWord = (== 4) . length . filter isLetter</span><span id="8032" class="mg kz iq mc b gy ml mi l mj mk"><strong class="mc ir">sendBugReport </strong>:: MonadChatBot m =&gt; Room -&gt; String -&gt; m ()<br/>sendBugReport room bug = do<br/>  reportBug bug<br/>  sendChat room "Thanks for the bug report!"</span><span id="7eb7" class="mg kz iq mc b gy ml mi l mj mk"><strong class="mc ir">banIfAdmin </strong>:: MonadChat m =&gt; Room -&gt; User -&gt; m ()<br/>banIfAdmin room user = do<br/>  isAdmin &lt;- hasPermission Admin<br/>  when isAdmin $ do<br/>    ban room user<br/>    sendChat room "Sorry for the disturbance!"</span></pre><p id="52a4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">太好了，都完成了！但是等等…我怎么知道这面代码墙实际上是正确工作的呢？如果没有这三个类型类的实现，我甚至无法尝试。</p><h1 id="498c" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">测试有效代码</h1><p id="1d49" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">Haskell在构建高度可靠软件的一些技术方面领先于编程行业。Haskellers通常依靠类型系统来验证代码的属性，维护无状态代码和不可变数据以消除许多出现错误的机会，利用纯功能代码快速轻松地进行测试，依靠QuickCheck进行随机属性测试，甚至使用检查测试来检查编译器的属性。Haskell程序员也将尽可能多的逻辑从有效的代码中转移到纯粹的功能性代码中。(上面我真的做得不太好…)</p><p id="ba36" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是有效的代码最终是必要的，这是Haskell使用起来有点困难的测试领域的一个方面。上面的聊天机器人与许多外部系统对话:认证服务器、聊天服务器、错误报告系统，甚至其他人！很难将这些部分(尤其是人)放置在自动化测试的适当位置，所以我们必须找到一种没有它们的测试方法。</p><p id="f8cd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里基本上有两种选择:</p><ul class=""><li id="bfb8" class="mp mq iq jp b jq jr ju jv jy mr kc ms kg mt kk mu mv mw mx bi translated"><em class="my">假货</em>是API的假实现，试图表现得像一个真实的系统，这样你就可以用它们进行测试。</li><li id="9a12" class="mp mq iq jp b jq mz ju na jy nb kc nc kg nd kk mu mv mw mx bi translated"><em class="my">模拟</em>是愚蠢的实现，对系统的预期行为一无所知，但是可以通过<em class="my">测试本身</em>告诉它如何行为。</li></ul><p id="586d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你有一个高质量的假实现，那么你一定要用它来测试！然而，制造一个高质量的赝品需要大量的工作。假货更适合非常稳定的界面。让一个伪代码与快速变化的API保持同步可能需要做大量的工作。这些都是全新的界面，我们预计随着时间的推移会大幅调整。当事情不简单时，您可能会努力编写测试来验证您的行为。网络瘫痪怎么办？如果事务提交失败怎么办？很少用假货掩盖这些案子。</p><p id="739f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以我们盘子里的另一个答案是模仿。这就是我们接下来要找的地方。</p><h1 id="caed" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">关于模仿的一切</h1><p id="ea69" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">mock是一个只做你让它做的事情的对象。它根本没有任何内部逻辑，只是简单地遵循指令，将您正在测试的代码中的调用与脚本中的行进行匹配，并按照要求做出响应。</p><p id="9a2c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是如何用HMock编写一个简单的测试。</p><pre class="kn ko kp kq gt mb mc md me aw mf bi"><span id="ef17" class="mg kz iq mc b gy mh mi l mj mk">makeMockable ''MonadAuth<br/>makeMockable ''MonadChat<br/>makeMockable ''MonadBugReport</span><span id="e6eb" class="mg kz iq mc b gy ml mi l mj mk">runMockT $ do<br/>  expect $ Login "HMock" "secretish"<br/>  expect $ JoinRoom "#haskell" |-&gt; Room "#haskell"<br/>  expect $ PollChat (Room "#haskell")<br/>    |-&gt; (User "Alice", "!hello")<br/>    |-&gt; (User "Bob", "!leave")<br/>  expect $ SendChat (Room "#haskell") "Nice to meet you."<br/>  expect $ LeaveRoom (Room "#haskell")<br/>  expect $ Logout</span><span id="ba1d" class="mg kz iq mc b gy ml mi l mj mk">  chatbot "#haskell"</span></pre><p id="5a68" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以解剖这些部分。</p><ul class=""><li id="6a7f" class="mp mq iq jp b jq jr ju jv jy mr kc ms kg mt kk mu mv mw mx bi translated">前三行是模板Haskell，生成一些样板文件，使这些接口可以模仿。</li><li id="db04" class="mp mq iq jp b jq mz ju na jy nb kc nc kg nd kk mu mv mw mx bi translated"><code class="fe mm mn mo mc b">runMockT</code>运行<code class="fe mm mn mo mc b">MockT</code> monad transformer，它管理测试中所有预期的行为。</li><li id="1a6b" class="mp mq iq jp b jq mz ju na jy nb kc nc kg nd kk mu mv mw mx bi translated">下一个模块设定了期望值。在这里，我们预计会发生几件事:机器人将登录，加入一个房间，两次轮询聊天消息，发送消息，离开房间，然后注销。当一个方法有一个有趣的返回值时，我们用<code class="fe mm mn mo mc b">|-&gt;</code>来说明它应该是什么。</li><li id="54de" class="mp mq iq jp b jq mz ju na jy nb kc nc kg nd kk mu mv mw mx bi translated">最后，我们调用正在测试的实际代码块。代替实际的实现，实现将使用它所使用的接口的模拟。正确的实例由<code class="fe mm mn mo mc b">makeMockable</code>生成。</li><li id="2d9c" class="mp mq iq jp b jq mz ju na jy nb kc nc kg nd kk mu mv mw mx bi translated">当被测代码执行动作时，<code class="fe mm mn mo mc b">MockT</code>将在设定的期望值中查找它们，并按照要求做出响应。当<code class="fe mm mn mo mc b">runMockT</code>结束时，它将检查是否满足了所有期望。</li></ul><h1 id="e148" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">模仿会出什么问题</h1><p id="951e" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">Haskell对模拟测试的问题有一些答案。Alexis King写了一个名为<a class="ae kl" href="https://hackage.haskell.org/package/monad-mock" rel="noopener ugc nofollow" target="_blank"> monad-mock </a>的库，这是我在开始这项工作时研究的。这个周末我还了解到阿克谢·曼卡尔写了<a class="ae kl" href="https://hackage.haskell.org/package/polysemy-mocks" rel="noopener ugc nofollow" target="_blank">多义词模拟</a>来处理这个效果系统。但我创造了不同的东西。</p><p id="54b5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">原因是我认为一个虚弱的嘲讽框架是一个危险的工具。模拟测试可能会在几个方面出错。</p><p id="d3fc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="my">很容易断言太多。</em>假设你的代码通过网络获取两个文件。你关心它们是按什么顺序取来的吗？事实上，你在乎它们被取了多少次吗？也许是这样，但是您真的希望您的测试套件中的每一个测试都失败，仅仅因为您两次获取相同的文件吗？很好地使用mocks需要一种语言，让你对文件说足够多的<em class="my"/>(比如:“如果这个文件被获取，这是将会得到的响应”)，但不要说太多的<em class="my"/>导致脆弱的测试，当对代码进行无害的更改时，测试会中断。</p><p id="ad70" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="my">嘲讽太多容易</em>。您需要模拟您不能用于测试的东西:外部系统、用户等等。用mock建立一个奇特的测试是很常见的，只是意识到你已经告诉mock精确地做你应该测试的事情。很好地使用mocks有时需要精确控制什么被剔除，什么不被剔除。</p><p id="4206" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="my">很容易打破可组合性。主流语言中常用的模拟系统以容易出错而闻名。您可能会添加一个期望，希望它在某个时间触发，结果却意外地在错误的时间触发，将错误的行为注入到您的测试中，随之而来的就是混乱！为了做好测试，你需要一种很好的可组合的语言来描述行为。模拟框架通常依赖于全局状态、总计数等。从测试的一部分向另一部分泄露细节。</em></p><p id="8c97" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">HMock试图解决这些问题。</p><p id="65fc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">像主流编程语言的最佳框架一样，HMock为您提供了一种强大而灵活的语言来设置期望值。您负责:动作是否需要按顺序执行，动作发生的次数是否有限制，参数是被精确检查，完全忽略，还是对照谓词检查。</p><p id="5743" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">HMock还可以让您控制API被模仿的程度，以及这些模仿有多聪明。使用HMock通常是值得的，即使只是设置一个fake，因为用HMock委托方法不需要像新的<code class="fe mm mn mo mc b">MonadChat</code>实现那样定义新的monad类型或transformers，还因为很容易注入故障和测试fake无法处理的其他困难情况。</p><p id="5118" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，与主流语言中的大多数模仿不同，HMock基于基本的可组合的原语语言，如Svenningsson等人在论文<a class="ae kl" href="https://link.springer.com/content/pdf/10.1007%2F978-3-642-54804-8_27.pdf" rel="noopener ugc nofollow" target="_blank"> <em class="my">中描述的一种模仿</em> </a>的表达性语义。事实上，它通过向论文中的集合添加交错重复，实现了一组更具表达性的原语。像选择和重复序列这样的操作可以让你更准确地说出每个操作应该在什么时候发生，这样就不会留下可能在错误的时间意外匹配的期望。你可以很容易地说这样的话:“检查后视镜和系好安全带的顺序并不重要，但在两者都完成之前不要启动汽车，”或者“1040表格或1040EZ表格必须提交，但不能两者都提交”。</p><p id="c7e0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你想看到我上面介绍的聊天机器人的更多测试，我从HMock测试套件的<a class="ae kl" href="https://github.com/cdsmith/HMock/blob/main/test/Demo.hs" rel="noopener ugc nofollow" target="_blank">演示中获得了代码，其中有更多的测试和技术！</a></p><h1 id="c254" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">案例研究</h1><p id="100c" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">我的第一个HMock用例是…HMock本身的测试套件！我真的不希望这样，因为我希望在测试与用户或复杂的外部服务交互的有效系统时需要模拟。但是HMock确实与一个复杂的外部服务交互:GHC！它使用模板Haskell API来实现这一点。</p><p id="c0bd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在测试HMock的过程中，我意识到我想测试一些模板Haskell代码。但是模板Haskell在构建时运行，这有一些缺点:</p><ul class=""><li id="c119" class="mp mq iq jp b jq jr ju jv jy mr kc ms kg mt kk mu mv mw mx bi translated">你只能测试成功的案例。未能构建的测试是不可接受的状态，这意味着不可能在构建时测试失败的使用。</li><li id="d2d4" class="mp mq iq jp b jq mz ju na jy nb kc nc kg nd kk mu mv mw mx bi translated">我非常喜欢hpc，GHC的测试覆盖率报告系统。然而，hpc看不到在构建时运行过的代码，所以产生的覆盖率报告认为第四段代码完全没有经过测试。</li><li id="11e0" class="mp mq iq jp b jq mz ju na jy nb kc nc kg nd kk mu mv mw mx bi translated">有时测试内部方法而不仅仅是顶级声明是有用的。这些在构建时不容易测试。</li></ul><p id="2aae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以我想在IO中运行模板Haskell。嗯，假设有这样一种方法:IO是模板Haskell使用的准类型类的一个实例。但是这是一个相当糟糕的实例，当你试图做一些有趣的事情时，比如查找一个类型或实例，就会抛出错误。我需要更多。事实证明，我能够使用HMock为<em class="my"> Quasi </em>类型类构建一个Mock，并使用它来测试HMock自己的模板Haskell代码。我可以在构建时运行查询，然后用th的lift类将它们的响应提升到运行时，并使用HMock清除准monad来返回那些保存的响应，而不是手工编写每个TH查询的响应。</p><p id="1eca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">结果如下:</p><ul class=""><li id="8fbd" class="mp mq iq jp b jq jr ju jv jy mr kc ms kg mt kk mu mv mw mx bi translated">通过运行我已经开始编写的简单测试，我发现了三个bug。这些大多是错误案例中的错误。</li><li id="a0e1" class="mp mq iq jp b jq mz ju na jy nb kc nc kg nd kk mu mv mw mx bi translated">我可以查看hpc输出，它突出显示了没有被测试的代码部分。通过考虑何时需要该代码，我生成了更多的测试用例，导致在同一天又发现了四个bug。</li><li id="61e2" class="mp mq iq jp b jq mz ju na jy nb kc nc kg nd kk mu mv mw mx bi translated">后来，我能够更快地开发模板Haskell代码，因为我可以编写测试用例来验证TH的行为，运行它们，并断言或检查结果，这种方式在编译时代码中通常很难做到。</li></ul><p id="a048" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">总的来说，这是一个压倒性的成功案例。</p><h1 id="301a" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">状态</h1><p id="7d09" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">HMock现在作为预发布版在Hackage上发布。我称之为预发布的主要原因是它目前只为MTL风格的类型类实现。我想扩展到最常见的效果系统，以及servant，haxl等等。作为这一过程的一部分，我预计会有一些重大的突破性变化。然而，只要您的版本上限适当，现在没有理由不能使用HMock。</p><p id="72d0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">除了上面提到的内容，HMock还实现了以下功能:</p><ul class=""><li id="5bbb" class="mp mq iq jp b jq jr ju jv jy mr kc ms kg mt kk mu mv mw mx bi translated">一种将参数与方法相匹配的谓词的扩展语言，让您可以轻松地隔离可以附加响应的有趣调用。这些谓词适用于各种类型，包括强大的技术，如正则表达式和不区分顺序的容器匹配。</li><li id="62c3" class="mp mq iq jp b jq mz ju na jy nb kc nc kg nd kk mu mv mw mx bi translated">可配置默认值。默认情况下，没有显式响应的方法将根据<code class="fe mm mn mo mc b">Default</code>类返回其默认值。但是您可以为某些或所有调用设置不同的缺省值。</li><li id="3291" class="mp mq iq jp b jq mz ju na jy nb kc nc kg nd kk mu mv mw mx bi translated">每类设置。您可以配置默认行为，并通过编写一个方便的类型类的实例将它们与类型捆绑在一起。</li><li id="a3aa" class="mp mq iq jp b jq mz ju na jy nb kc nc kg nd kk mu mv mw mx bi translated">广泛支持大多数种类的类(包括具有函数依赖关系的多参数类)和大多数方法(包括多态方法，除非返回值是由方法绑定的类型变量)。</li></ul></div></div>    
</body>
</html>