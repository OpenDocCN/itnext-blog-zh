# 在 Go 中操作私有字段

> 原文：<https://itnext.io/manipulating-private-fields-in-go-4da4ca525717?source=collection_archive---------1----------------------->

![](img/72def74d107bfb9d29b978daca38690b.png)

照片由[克里斯蒂娜面粉](https://unsplash.com/@tinaflour?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)

在计算机编程的世界里，有一些事情被认为是禁忌。通常应该避免的事情。除非你有一个真正的好理由，否则你不应该做的事情。其中之一就是访问和操作代码库的私有成员。让我们来看看一个人如何在围棋中做出这样的事情。

# 我说的私人成员是什么意思？

在 Go 中，我们认为事物(变量、函数、方法、结构字段)要么是*导出的*(公有)，要么是*未导出的*(私有)。这由名称的第一个字符是大写还是小写*来表示。*让事情不出口的主要原因是隐藏实现细节。这与抽象接口背后的行为的想法是一样的；你只需要关心你真正关心的事情，而不是所有的细节。例如，让我们看看*字符串的 godoc。构建器:*

> 构建器用于使用 Write 方法高效地构建字符串。它最大限度地减少了内存复制。零值随时可以使用。不要复制非零生成器。

```
type Builder struct {
        // contains filtered or unexported fields
}
```

正如我们从 godoc 中看到的，这个结构似乎包含一些未导出的字段。大多数人关心这些领域是什么吗？没有。他们只关心*构建器*正在帮助他们节省一些内存分配。但是假设我们真的在乎，那么我们看看实际的代码，看看这个结构对我们隐藏了什么。

```
type Builder struct {
	addr *Builder // of receiver, to detect copies by value
        buf  []byte
}
```

图像我们有一个非常好的用例，我们需要访问和操作内部 *buf* 字段的值。我们会怎么做？在一些编程语言中，你只需要使用反射就可以了。如果你需要做的只是访问字段，你可以通过使用 Go 中的 *reflect* 包来访问它。但这还不够好。我们想变得更邪恶一点，操纵缓冲区的值。要在围棋中做到这一点，我们需要看一看…

# 危险的

有了像 unsafe 这样的包名，你就知道事情要变得有趣了。这个包允许我们做什么？来自 godoc:

> Package unsafe 包含绕过 Go 程序类型安全的操作。
> 
> 导入 unsafe 的包可能是不可移植的，不受 Go 1 兼容性指南的保护。

呜，听起来很有趣！这个包提供了一个*不安全。指针*表示…

> …允许程序破解类型系统，读写任意内存。应该非常小心地使用它。

😈

让我告诉你如何使用它。

# 示例时间

下面是一个使用*不安全*包设置未导出字段值的例子。在下面的例子中，你会发现一行一行的分析到底是怎么回事。

我来帮你从上到下分解一下。

## 第 9 行

```
const ptrSize = unsafe.Sizeof(new(int))
```

这里我们要找出一个整数的大小。这将因底层系统的架构而异。这个值对我们很重要，因为 int 的大小等于用来表示 Go 中内存地址的大小。

## 第 12–13 行

```
bs := make([]byte, 0, 7)
bs = append(bs, 'u', 'n', 's', 'a', 'f', 'e')
```

接下来，我们声明一个缓冲区，其容量比放入其中的字节数多 1。额外的空间是为稍后将被写入的一个额外字节节省空间。

## 第 15–16 行

```
var sb strings.Builder 
p := unsafe.Pointer(&sb)
```

这就是事情开始变得有趣的地方。首先我们的*建造者*被声明。然后我们用*不安全*包得到一个*不安全。指针*指向 *sb。变量 *p* 代表 *sb* 在内存中的位置。该变量将在下一步中使用*

## 第 17 行(其中%#$！变得真实)

```
*(*[]byte)(unsafe.Pointer(uintptr(p) + uintptr(ptrSize))) = bs
```

> 那团热是什么意思

电梯间距:我们将 *sb* 的未导出 *buf* 设置为我们声明为 *bs 的字节片。*

我知道这一行发生了很多事情，所以让我来帮你进一步分析一下。

```
unsafe.Pointer(uintptr(p) + uintptr(ptrSize))
```

上面的代码使用了 *unsafe。指针*我们在前一行中得到，将它转换成一个 *uintptr* 并增加指针的大小到那个内存地址。然后我们得到*不安全。指针*指向那个存储单元。这就是所谓的指针算法。我们知道*字符串的内存块在哪里。构建器*开始(它的内存地址是 *p* 记住)。然后我们利用我们对内存布局的了解，对于*构建器*结构，转移到另一个内存地址。只是提醒一下:

```
type Builder struct {
	addr *Builder
        buf  []byte
}
```

我们想将我们的内存地址移过 *addr* 并指向 *buf* 。 *addr* 是指针，所以我们把指针的大小加到 *sb* 的内存地址的开头。现在我们应该指向 *buf* 。让我们来分解这条线的其余部分。

```
*(*[]byte)(unsafe.Pointer(uintptr(p) + uintptr(ptrSize))) = bs
```

剩下的只是做一些造型让类型系统开心。我们知道这个*不安全。指针*指向一个字节片。然后，我们需要取消引用该指针，以使我们的最终类型为 *[]byte。*一旦我们有了正确的类型，我们就可以将那个*[]字节* ( *构建器**未导出字段 *buf* ) 设置为我们声明的字节片 *bs。**

*剩下的台词只是证明了 *bs* 和 *sb* 中的底层 *buf* 两者是一体的。附加到一个会附加到两个(尽管你会注意到由于片头的[复制，每个的长度不同)。如果你想稍微修改一下代码，你可以在操场上运行这个例子。](https://blog.golang.org/slices)*

# *结论*

*你现在知道如何在围棋中击败私人访问了。不仅如此，你还知道如何操纵那些私人成员。在“真实世界”中，你会需要做这种事情吗？大概不会。但是你能做到这一点真的很酷！😎只要记住…*

*如果你能走到这一步，谢谢你。🙌*