<html>
<head>
<title>Automatically building and maintaining GraphQL APIs with PostgreSQL and Postgraphile</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用PostgreSQL和Postgraphile自动构建和维护GraphQL APIs</h1>
<blockquote>原文：<a href="https://itnext.io/automatically-building-and-maintaining-graphql-apis-with-postgresql-and-postgraphile-c497636abd29?source=collection_archive---------1-----------------------#2018-04-04">https://itnext.io/automatically-building-and-maintaining-graphql-apis-with-postgresql-and-postgraphile-c497636abd29?source=collection_archive---------1-----------------------#2018-04-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="e5b2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如今，上市时间是构建新服务的核心性能指标之一。对于大多数服务，至少一些CRUD操作是必要的，并且大多数应用程序可以被描述为显示数据并让用户操作数据的数据驱动应用程序。实现这些CRUD接口并使其保持最新是一项枯燥乏味的任务。大多数框架，如Rails和类似Rails的框架，已经通过为这些步骤提供生成器来帮助程序员自动化任务，但是当底层数据模式改变时，这些框架就会失败。</p><p id="5d1c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这篇文章中，我将展示<a class="ae kl" href="https://www.graphile.org/postgraphile/" rel="noopener ugc nofollow" target="_blank"> Postgraphile </a>如何帮助消除为每个新服务在后端重新创建CRUD接口的枯燥工作，而是专注于提供真正商业价值的功能。</p><p id="34b0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">假设一个经典的三层服务由前端、后端和数据存储组成(是的，如果我们将服务消费者称为“前端”，甚至大多数微服务都是三层应用)。当设计这样的应用程序时，我们通常从后端开始，考虑类和应用程序状态，然后才考虑底层数据和API层。在一个更加功能化的世界中，我们将首先考虑数据本身，以及我们需要如何转换和操作数据来提供业务价值。</p><p id="26b3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们的三层方法中，我们不从中间开始，即后端，而是首先定义我们的数据结构以及它们在数据存储(即数据库)中的关系，然后考虑实现后端和前端需要什么。由于操纵数据的后端功能不提供核心业务价值，操纵数据的实现需要自动化。Postgraphile帮助我们做到了这一点:给定一个(PostgreSQL)数据库，Postgraphile为该数据库提供了一个GraphQL HTTP API，支持认证、授权，并且是可扩展的。</p><p id="3749" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们深入研究示例之前，让我们回顾一下我们为该设置选择了哪种技术以及为什么:</p><h2 id="ce0e" class="km kn iq bd ko kp kq dn kr ks kt dp ku jy kv kw kx kc ky kz la kg lb lc ld le bi translated">数据库:PostgreSQL</h2><p id="41e0" class="pw-post-body-paragraph jn jo iq jp b jq lf js jt ju lg jw jx jy lh ka kb kc li ke kf kg lj ki kj kk ij bi translated">说正经的:PostgreSQL是一个很棒的数据库。对于大多数用例，您应该尽可能选择强一致性和关系。而这正是PostgreSQL给我们提供的。</p><p id="7483" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了支持认证和授权，我们使用了<a class="ae kl" href="https://www.postgresql.org/docs/current/static/database-roles.html" rel="noopener ugc nofollow" target="_blank">角色</a>、<a class="ae kl" href="https://www.postgresql.org/docs/10/static/sql-createpolicy.html" rel="noopener ugc nofollow" target="_blank">行</a>和列级安全策略。通过这种方式，我们可以识别哪个用户当前登录了，以及他们应该看到什么数据(稍后将详细介绍)</p><h2 id="af7d" class="km kn iq bd ko kp kq dn kr ks kt dp ku jy kv kw kx kc ky kz la kg lb lc ld le bi translated">API层:GraphQL</h2><p id="515a" class="pw-post-body-paragraph jn jo iq jp b jq lf js jt ju lg jw jx jy lh ka kb kc li ke kf kg lj ki kj kk ij bi translated">GraphQL是一种用于API的查询语言，与手工构建REST接口相比，它有很多优点。它有一些类似于<a class="ae kl" href="http://www.odata.org/" rel="noopener ugc nofollow" target="_blank"> oData </a>的目标，但不限于SAP和微软泡沫。</p><h2 id="7a68" class="km kn iq bd ko kp kq dn kr ks kt dp ku jy kv kw kx kc ky kz la kg lb lc ld le bi translated">胶水:海报</h2><p id="ad6b" class="pw-post-body-paragraph jn jo iq jp b jq lf js jt ju lg jw jx jy lh ka kb kc li ke kf kg lj ki kj kk ij bi translated">我们的主要目标是减少实现无聊的CRUD操作所需的工作量。Postgraphile更进一步，完全自动化了该功能的创建和维护。</p><p id="a646" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">PostgreSQL将一个到PostgreSQL数据库的连接作为输入，分析它并为数据库提供一个GraphQL API。在开发过程中，Postgraphile还可以观察数据库的变化，并立即更新API。在生产过程中，可以缓存分析结果，以提高毫秒级启动速度(比如在AWS Lambda上)。</p><h1 id="5894" class="lk kn iq bd ko ll lm ln kr lo lp lq ku lr ls lt kx lu lv lw la lx ly lz ld ma bi translated">示例:用于中型克隆的API</h1><p id="83c1" class="pw-post-body-paragraph jn jo iq jp b jq lf js jt ju lg jw jx jy lh ka kb kc li ke kf kg lj ki kj kk ij bi translated">让我们构建一个非常简单的medium克隆:在我们的克隆中，用户可以发布帖子，并可以通过鼓掌对其他帖子进行评级。数据库模式非常简单:我们有一个用户、帖子和掌声表:</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div class="gh gi mb"><img src="../Images/87217f34f92f60a6f69d9d408dfd029b.png" data-original-src="https://miro.medium.com/v2/resize:fit:882/format:webp/1*9HdoRQv_ygBz3CvG-1lxHw.png"/></div><figcaption class="mj mk gj gh gi ml mm bd b be z dk translated">我们的中型克隆的数据库结构</figcaption></figure><p id="1a6b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以下SQL代码为我们创建了模式:</p><figure class="mc md me mf gt mg"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="c5e5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们安装并运行postgraphile(更多细节参见<a class="ae kl" href="https://www.graphile.org/postgraphile/quick-start-guide/" rel="noopener ugc nofollow" target="_blank">快速入门指南</a>):</p><figure class="mc md me mf gt mg"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="8a19" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就这些！让我们安装<a class="ae kl" href="https://github.com/imolorhe/altair" rel="noopener ugc nofollow" target="_blank"> Altair </a>浏览器扩展，而不是使用提供的GraphiQL接口。</p><p id="f2ea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在右边，您可以找到文档浏览器，并看到所有支持的查询和变化。我们已经可以开始查询和修改数据库，但是让我们首先用一些值填充数据库:</p><figure class="mc md me mf gt mg"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="eb17" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们在Altair中尝试几个查询:</p><figure class="mc md me mf gt mg"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="8e22" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">咳咳…我们不想让用户看到密码。咳咳……我们不希望任何人看到这个表格中的任何信息。除此之外，它看起来很棒。让我们尝试获取所有帖子和相应的作者:</p><figure class="mc md me mf gt mg"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="359c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好的。这很好，但是用户不应该看到其他用户未发表的帖子。</p><p id="9dcc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在解决问题之前，让我们注册一个新用户:</p><figure class="mc md me mf gt mg"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="b341" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">很好，但是也许我们不应该这样做，尤其是不要以纯文本格式存储密码！(千万，千万不要这么做！想都别想！)</p><p id="4deb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们已经看到了当前方法的一些问题，我们需要解决哪些问题？</p><ul class=""><li id="e101" class="mp mq iq jp b jq jr ju jv jy mr kc ms kg mt kk mu mv mw mx bi translated">为用户提供创建新帐户的方法</li><li id="a828" class="mp mq iq jp b jq my ju mz jy na kc nb kg nc kk mu mv mw mx bi translated">为用户提供一种登录方式</li><li id="3e11" class="mp mq iq jp b jq my ju mz jy na kc nb kg nc kk mu mv mw mx bi translated">禁止所有人查看用户表</li><li id="46f3" class="mp mq iq jp b jq my ju mz jy na kc nb kg nc kk mu mv mw mx bi translated">客人只能看到已发布的帖子</li><li id="0f36" class="mp mq iq jp b jq my ju mz jy na kc nb kg nc kk mu mv mw mx bi translated">登录的用户只能看到发布的帖子和他们自己的帖子</li></ul><h2 id="7ab5" class="km kn iq bd ko kp kq dn kr ks kt dp ku jy kv kw kx kc ky kz la kg lb lc ld le bi translated">使用Postgraphile进行用户和会话管理</h2><p id="c15c" class="pw-post-body-paragraph jn jo iq jp b jq lf js jt ju lg jw jx jy lh ka kb kc li ke kf kg lj ki kj kk ij bi translated">Postgraphile支持一种非常灵活的会话管理方式:<a class="ae kl" href="https://jwt.io/" rel="noopener ugc nofollow" target="_blank"> JWT </a> (JSON Web Tokens)。我们可以为PostgreSQL提供一个密钥和一个自定义的PostgreSQL数据类型，每当PostgreSQL函数返回该数据类型时，PostgreSQL就会将内容编码为JWT令牌并进行签名。每当请求包含用定义的密钥签名的有效授权头时，Postgraphile就提取该数据并将其存储在PostgreSQL变量中。然后，我们可以在PostgreSQL查询中访问这些数据。</p><p id="99bc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">警告:</strong> JWT代币存在严重问题，应小心使用。更多信息见<a class="ae kl" href="http://cryto.net/~joepie91/blog/2016/06/13/stop-using-jwt-for-sessions/" rel="noopener ugc nofollow" target="_blank">这篇文章</a>。为了简单起见，我们将在这里继续使用它们。请注意，Postgraphile在用作中间件时，可以通过pgSettings选项使用express支持的任何形式的身份验证。(更多信息参见<a class="ae kl" href="https://www.graphile.org/postgraphile/usage-library/" rel="noopener ugc nofollow" target="_blank">文档</a></p><p id="bf02" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从一个例子开始，让我们首先为我们的令牌定义一个数据类型，一个注册和登录函数:</p><figure class="mc md me mf gt mg"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="844b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们定义一个新的类型jwt_token，它由角色、用户id和电子邮件组成。角色字段用于设置当前用户的<a class="ae kl" href="https://www.postgresql.org/docs/current/static/database-roles.html" rel="noopener ugc nofollow" target="_blank"> PostgreSQL角色</a>，其他两个字段都应该很明显。</p><p id="2ec1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们定义两个PLPGSQL函数:SIGNUP和SIGNIN。这些函数返回jwt_token类型，结果将由Postgraphile翻译成jwt令牌。</p><figure class="mc md me mf gt mg"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="73b4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们需要告诉Postgraphile一个密钥和令牌类型的名称:</p><figure class="mc md me mf gt mg"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="552a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们在postgraphile命令中添加了几个标志:</p><ul class=""><li id="5550" class="mp mq iq jp b jq jr ju jv jy mr kc ms kg mt kk mu mv mw mx bi translated"><strong class="jp ir">注意</strong>:每当模式更新时，GraphQL API也会更新，而不需要重新加载服务器</li><li id="a9d8" class="mp mq iq jp b jq my ju mz jy na kc nb kg nc kk mu mv mw mx bi translated"><strong class="jp ir">jwt-token-identifier</strong>:JWT令牌的类型</li><li id="68b1" class="mp mq iq jp b jq my ju mz jy na kc nb kg nc kk mu mv mw mx bi translated"><strong class="jp ir"> jwt-secret </strong>:代表jwt秘密的随机字符串。当您更改该字符串时，所有以前颁发的JWT令牌都将失效</li><li id="975c" class="mp mq iq jp b jq my ju mz jy na kc nb kg nc kk mu mv mw mx bi translated"><strong class="jp ir">默认角色</strong>:没有提供JWT令牌时的默认角色</li><li id="e285" class="mp mq iq jp b jq my ju mz jy na kc nb kg nc kk mu mv mw mx bi translated"><strong class="jp ir">显示错误堆栈</strong>:为了更好的调试</li></ul><p id="68ab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们可以使用注册变异来创建一个新用户:</p><figure class="mc md me mf gt mg"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="b628" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">数据库按预期相应更新；)当我们现在尝试查询任何其他内容时，我们会得到权限错误，因为我们定义了默认角色anonymous，但没有授予anonymous任何内容。我们稍后将回到这一点。</p><p id="0e4a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我们有了JWT代币，我们如何使用它呢？要设置JWT令牌，只需复制它并在Altair中添加一个标题“Authorization ”,带有值“Bearer”和复制的JWT令牌:</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/40d68f9b37dadb40c0fce06e3c8d549f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1210/format:webp/1*nsOcN9VugXsc_CHu2p6Kjg.png"/></div><figcaption class="mj mk gj gh gi ml mm bd b be z dk translated">在Altair中设置授权头</figcaption></figure><p id="756e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">很好，现在我们知道谁登录了，可以开始允许人们访问帖子了。在启动Postgraphile时，我们定义了默认角色是“anonymous ”,但是当用户登录时，我们将角色“medium_user”分配给JWT令牌。现在让我们授予匿名用户和中级用户对posts和claps表的访问权限。匿名用户只允许读取，medium_users可以执行所有CRUD操作:</p><figure class="mc md me mf gt mg"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="ef70" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">太好了！现在每个人都可以查询所有的帖子和掌声，登录用户可以操纵整个数据库。这不是我们想要的。我们需要限制访问已发布的和自己的帖子。此外，我们需要确保用户只能修改他们自己的帖子。</p><p id="bd96" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是首先我们需要一种方法来获取当前用户的id。因此让我们实现一个简单的函数current_user_id():</p><figure class="mc md me mf gt mg"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="485e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果没有给定用户id，此函数返回null，否则返回id。我们需要向这两个角色授予执行权限，以简化后续流程。</p><p id="f99b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，让我们更深入地研究PostgreSQL的<a class="ae kl" href="https://www.postgresql.org/docs/current/static/ddl-rowsecurity.html" rel="noopener ugc nofollow" target="_blank">行级安全策略</a>，以限制访问和修改权限:</p><figure class="mc md me mf gt mg"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="4031" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们现在只允许匿名用户访问已发布的帖子，允许中级用户访问已发布的或自己的帖子。WITH CHECK表达式仅与插入、更新和删除查询相关，并保证当前用户不能创作或删除其他作者的帖子。</p><p id="3c02" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们在Postgres CLI中尝试一下:</p><figure class="mc md me mf gt mg"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="2925" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以看到现在匿名只能看到发布的帖子。对于已登录的用户来说，情况非常相似。</p><p id="c7b3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们通过为claps表创建行级安全策略来完成我们的示例:</p><figure class="mc md me mf gt mg"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="26b9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，我们将在Altair客户端中使用GraphQL尝试一些有趣的查询:</p><figure class="mc md me mf gt mg"><div class="bz fp l di"><div class="mn mo l"/></div></figure><h1 id="adaf" class="lk kn iq bd ko ll lm ln kr lo lp lq ku lr ls lt kx lu lv lw la lx ly lz ld ma bi translated">结论</h1><p id="e354" class="pw-post-body-paragraph jn jo iq jp b jq lf js jt ju lg jw jx jy lh ka kb kc li ke kf kg lj ki kj kk ij bi translated">我们用相对较少的努力创建了一个强大的GraphQL API，它可以很容易地进一步扩展以满足我们的需求。我们没有写一行低级代码，只有几行SQL。Postgraphile需要一些关于API外观的假设。但另一方面也给了我们很大的自由和权力去扩展它。但最重要的是，我们没有编写一行特定于CRUD的代码！这已经为我们完成，并将自动与底层数据库保持同步。</p><p id="2b76" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">考虑到这一点，应该有一种方法以非常相似的方式自动构建前端应用程序。给定一个API，该工具应该创建一个使用该API的前端，并允许用户以预期的方式与之交互。作为开发人员，我们应该停止担心枯燥的CRUD工作和基于表单的应用程序的重新发明，而是关注真正的商业价值，以满足客户和用户的期限和期望。</p><p id="a022" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于未来的开发人员来说，能够自动化大部分数据驱动应用程序的创建和维护将是一项至关重要的技能。只有通过自动化这一过程，我们才能跟上我们自己的想法。</p><p id="6edb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我目前正在考虑如何以端到端的方式做到这一点，也就是说，如何在给定一个数据库的情况下，自动生成操作该数据库的优秀前端应用程序，而不丧失定制和扩展它的能力。我想邀请你和我一起思考这个问题，并期待你的反馈。</p></div></div>    
</body>
</html>