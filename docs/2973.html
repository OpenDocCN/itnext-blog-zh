<html>
<head>
<title>TypeScript: More than Just Types</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript:不仅仅是类型</h1>
<blockquote>原文：<a href="https://itnext.io/typescript-more-than-just-types-238adc4e43c7?source=collection_archive---------4-----------------------#2019-09-09">https://itnext.io/typescript-more-than-just-types-238adc4e43c7?source=collection_archive---------4-----------------------#2019-09-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d689" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">ES6增加了5个出色的功能</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/538be3483f2fe8d05487d294ac476441.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fav1afQja9W5dnJK2RuRgw.png"/></div></div></figure><p id="03ca" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">JavaScript占据了我的心，并且可能永远如此。但是，这并不是说我不知道它的缺点和改进的机会。像大多数语言一样，有一些好的部分，也有一些怪异的部分。虽然我喜欢这种松散类型语言的自由，但我也承认它需要你放弃一些控制权。为了夺回部分控制权，林挺变得相当受欢迎。但是它仍然不能像强类型语言那样给你控制权。幸运的是，我们有打字稿。</p><p id="9969" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您曾经使用过面向对象的语言，TypeScript会感觉非常熟悉——这不是巧合。微软使用C#等语言中的许多相同模式和功能创建了TypeScript(他们也保留了这些模式和功能)。然而，还是有一些不同之处。我喜欢TypeScript的一点是，在所有重要的方面，它仍然<em class="lq">像JavaScript一样。</em></p><p id="c5ca" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">顾名思义，TypeScript对JS的主要补充是<em class="lq">* drumroll *……</em>types！其中包括:<code class="fe lr ls lt lu b">number</code>、<code class="fe lr ls lt lu b">string</code>、<code class="fe lr ls lt lu b">object</code>，甚至还有泛型。然而，我喜欢TypeScript的原因是它对语言的其他补充。增加了一些内容，使JavaScript更具可读性，并鼓励代码的行为更可预测。</p><p id="8005" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在我的团队中，我们已经开始将我们的三个回购转换为TypeScript，在每次转换过程中，我们都很容易发现一些错误，否则很难找到。自从使用了TypeScript，我们的速度更快了，我们的Pull请求变得更加不言自明。</p><p id="48b4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是炒作够了！如果你想看我列出的TypeScript提供的5大附加功能，请继续阅读。</p><h1 id="de5e" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">1.访问修饰符</h1><p id="18df" class="pw-post-body-paragraph ku kv it kw b kx mn ju kz la mo jx lc ld mp lf lg lh mq lj lk ll mr ln lo lp im bi translated">如果你熟悉其他面向对象的语言，比如C#，你肯定会遇到像<code class="fe lr ls lt lu b">public</code>、<code class="fe lr ls lt lu b">private</code>和<code class="fe lr ls lt lu b">protected</code>这样的属性访问关键字。令(许多人)沮丧的是？)开发人员来说，在ES6中将类引入Javascript时，没有访问修饰符。这是Javascript避开了看起来面向对象，但又忠于其原型之间的界限的又一个例子。</p><p id="2373" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">幸运的是，TypeScript引入了所有这三个关键字来提供对类属性访问的更多控制——让您能够决定如何访问类属性。这对项目的未来维护者来说也是一个很好的信号，即某些属性永远不会在创建它们的上下文之外使用。这种微妙的交流本身就为长寿项目创造了奇迹。开发商不再需要搜索所有的物业用途来确定其预期用途。</p><p id="0965" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">截至发布时，普通JavaScript中的所有类属性都是隐式的<code class="fe lr ls lt lu b">public</code>。您可以使用一些模块魔法来创建<code class="fe lr ls lt lu b">private</code>变量的<em class="lq">功能</em>，但是它从来没有像TypeScript的访问修饰符那样优雅地完成工作。有一个向类添加私有属性的提议，但是值得注意的是，在这个阶段，这个提议与TypeScript的实现有很大的不同。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mv"><img src="../Images/8be2b060983fbeb35db9feeffe92a655.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i47V21rtuaN5Jor7XDhMeA.png"/></div></div></figure><pre class="kj kk kl km gt mw lu mx my aw mz bi"><span id="9107" class="na lw it lu b gy nb nc l nd ne">⛔️️<em class="lq"> no output</em></span><span id="e6ad" class="na lw it lu b gy nf nc l nd ne">(Line 17 will result in a TypeScript error because we set the variables <strong class="lu iu">name</strong> and <strong class="lu iu">sizeInMeters</strong> to <em class="lq">private</em>. In that case, even child classes cannot access the variable. This can be fixed by making the variables <em class="lq">protected</em>.)</span></pre><h1 id="bcd8" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">2.只读属性</h1><p id="1051" class="pw-post-body-paragraph ku kv it kw b kx mn ju kz la mo jx lc ld mp lf lg lh mq lj lk ll mr ln lo lp im bi translated">如果一个私有变量有getter但没有setter，它就隐式地变成只读的。然而，TypeScript太棒了，它添加了一个<code class="fe lr ls lt lu b">readonly</code>关键字来显式地创建一个只读的类属性。</p><p id="f3d1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">虽然这个关键字实际上只是语法上的糖，但它非常可爱。它减少了冻结变量值所需编写的代码量。这有助于使您的代码可读性更好，并再次向未来的开发人员清楚地传达您的意图。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mv"><img src="../Images/8be2b060983fbeb35db9feeffe92a655.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i47V21rtuaN5Jor7XDhMeA.png"/></div></div></figure><pre class="kj kk kl km gt mw lu mx my aw mz bi"><span id="2bb4" class="na lw it lu b gy nb nc l nd ne">⛔️️ <em class="lq">no output</em></span><span id="c97b" class="na lw it lu b gy nf nc l nd ne">(This snippet will not compile because we've explicitly told the class that <strong class="lu iu">age</strong> is a <em class="lq">readonly</em> variable.)</span></pre><h1 id="9812" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">3.抽象类和接口</h1><p id="0c54" class="pw-post-body-paragraph ku kv it kw b kx mn ju kz la mo jx lc ld mp lf lg lh mq lj lk ll mr ln lo lp im bi translated">抽象类是JS生态系统的另一个强大补充。如果你不熟悉，你可以把它们看作是部分定义的类。但是，真正的力量在于它们的可扩展性。</p><p id="f0a5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">使用抽象类，您可以定义子类将继承的公共功能。但是，您也可以创建契约，子类<em class="lq">必须满足这些契约才能被实例化。这一切都要追溯到面向对象的继承概念，以及在父类中对公共功能进行分组。</em></p><p id="f07e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最重要的是，这个特性有助于提高代码的可重用性(并且再次清楚地传达了开发人员的意图)。为了在普通JavaScript中实现相同的功能，您必须检查父构造函数中的每个方法，或者实现另一个聪明的解决方案——这两种方法都可能需要大量的注释来解释。</p><p id="ae2b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">TypeScript还增加了对接口的支持，您可能会比抽象类使用更多的接口。它们是您学习使用TypeScript的第一批东西之一，因为它们能够代替<code class="fe lr ls lt lu b">type</code>定义。在比较抽象类和接口时，要记住的最重要的事情是:<em class="lq">接口只定义子类必须实现的方法和属性，而抽象类也可以包括具体的实现逻辑(读:包含代码的方法)。</em>如果这还不清楚，请查看下面的代码，查看两者的示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mv"><img src="../Images/8be2b060983fbeb35db9feeffe92a655.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i47V21rtuaN5Jor7XDhMeA.png"/></div></div></figure><pre class="kj kk kl km gt mw lu mx my aw mz bi"><span id="e9a9" class="na lw it lu b gy nb nc l nd ne">Hi! My name is Home and I'm going 1028.99 mph!</span></pre><h1 id="f774" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">4.名称空间</h1><p id="479a" class="pw-post-body-paragraph ku kv it kw b kx mn ju kz la mo jx lc ld mp lf lg lh mq lj lk ll mr ln lo lp im bi translated">我争论过是否在本文中包含名称空间，因为尽管它们很强大，但它们在TypeScript中的实现有点…笨拙。它们之所以强大，是因为它们可以将常见的逻辑归为一类。您可能会想“是的，但这就是JS模块的用途。”你说得对！然而，名称空间非常棒，因为它们可以跨越多个文件。</p><p id="7021" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，当我说名称空间在TypeScript中很笨拙时，我指的是导入语法。您可能熟悉CommonJS和AMD模块导入语法，但是TypeScript不使用它们。相反，它推出了自己的语法，更像HTML脚本标签，而不是你在Javascript中见过的任何东西。我希望未来版本的TypeScript使用更容易接受的语法。但是现在，这就是我们所拥有的！</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mv"><img src="../Images/8be2b060983fbeb35db9feeffe92a655.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i47V21rtuaN5Jor7XDhMeA.png"/></div></div></figure><pre class="kj kk kl km gt mw lu mx my aw mz bi"><span id="5118" class="na lw it lu b gy nb nc l nd ne">The galaxy is 13.772 billion years old, and contains 100 billion galaxies.<br/>The answer is and always will be 42.</span></pre><h1 id="9d8a" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">5.装修工</h1><p id="410d" class="pw-post-body-paragraph ku kv it kw b kx mn ju kz la mo jx lc ld mp lf lg lh mq lj lk ll mr ln lo lp im bi translated">装饰者是我最喜欢的TypeScript新增功能之一。然而，我应该在使用它们之前提醒你，因为它仍然是一个实验性的特性。而且，我的意思是<em class="lq">非常具有实验性——事实上，你必须用<code class="fe lr ls lt lu b">experimentalDecorators</code>标志明确地启用它。</em></p><p id="1cf4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">自2017年4月以来，Decorators一直是Javascript的拟议补充，但他们目前正处于批准过程的第二阶段——这意味着尽管他们可能会成为官方规范，但最终的实现可能会发生变化。你可以在这里查看当前的提议状态:<a class="ae ms" href="https://github.com/tc39/proposal-decorators" rel="noopener ugc nofollow" target="_blank"> tc39 / proposal-decorators </a>。</p><p id="5581" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">装饰器只是一种用函数名注释代码的方式，以便扩展其功能或提供元数据。这允许你写清楚和简洁的抽象。</p><p id="a38d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您可以在TypeScript中修饰以下内容:</p><ul class=""><li id="1fcb" class="ng nh it kw b kx ky la lb ld ni lh nj ll nk lp nl nm nn no bi translated">类别定义</li><li id="943d" class="ng nh it kw b kx np la nq ld nr lh ns ll nt lp nl nm nn no bi translated">性能</li><li id="89c1" class="ng nh it kw b kx np la nq ld nr lh ns ll nt lp nl nm nn no bi translated">方法</li><li id="9bae" class="ng nh it kw b kx np la nq ld nr lh ns ll nt lp nl nm nn no bi translated">访问器(getter/setter)</li><li id="6896" class="ng nh it kw b kx np la nq ld nr lh ns ll nt lp nl nm nn no bi translated">因素</li></ul><p id="39c0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我描述每种类型的装饰器，这篇文章会变得很长，所以我将把重点放在类定义上。当您想从多个类中抽象出一些公共的构造函数级逻辑时，类定义装饰器非常有用。您最常看到的是在包中使用它们来提供一种简单的方法来扩展您自己的类。</p><p id="21a4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面的例子展示了一个名为<code class="fe lr ls lt lu b">Frozen</code>的装饰函数，它冻结了类的构造函数及其原型。正如您将在下面看到的，所有的类定义装饰器都接受构造函数作为参数。</p><p id="422a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">第一个文件是一个示例<code class="fe lr ls lt lu b">tsconfig.json</code>，它通过将<code class="fe lr ls lt lu b">experimentalDecorators</code>设置为true来启用装饰器。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mv"><img src="../Images/8be2b060983fbeb35db9feeffe92a655.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i47V21rtuaN5Jor7XDhMeA.png"/></div></div></figure><pre class="kj kk kl km gt mw lu mx my aw mz bi"><span id="6b51" class="na lw it lu b gy nb nc l nd ne">⛔️️<em class="lq"> no output</em></span><span id="4262" class="na lw it lu b gy nf nc l nd ne">(The class has been frozen and therefore cannot be modified)</span></pre></div><div class="ab cl nu nv hx nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="im in io ip iq"><p id="d192" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">就是这样！我希望这个快速进入TypeScript的旅程已经激发了您的兴趣。如果你想了解更多关于TypeScript的知识或者开始你自己的项目，我建议你去官方的<a class="ae ms" href="https://www.typescriptlang.org/" rel="noopener ugc nofollow" target="_blank"> TypeScript网站</a>看看。</p><p id="e773" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你喜欢这篇文章，请考虑留下一些掌声，这样我就知道这种类型的内容是有价值的！👏</p></div></div>    
</body>
</html>