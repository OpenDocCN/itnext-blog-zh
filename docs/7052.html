<html>
<head>
<title>Filtering by Dynamic Attributes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">按动态属性过滤</h1>
<blockquote>原文：<a href="https://itnext.io/filtering-by-dynamic-attributes-90ada3504361?source=collection_archive---------0-----------------------#2022-05-27">https://itnext.io/filtering-by-dynamic-attributes-90ada3504361?source=collection_archive---------0-----------------------#2022-05-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/cf734b805a26d448c8ee484356090072.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J3uZ84gvOSaAu4w_ILclEA.png"/></div></div></figure><p id="3d58" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在开发中，有一种非常常见的情况，当需要为一些实体使用动态属性时，甚至更多——实体本身可以是完全动态的。我认为这种应用程序最著名的例子是JIRA，管理员可以添加或删除票证属性，然后每个人都可以使用它们(查看或修改票证的值)。同时，JIRA为使用动态属性过滤和排序票据提供了充足的机会，这表明使用动态属性的工作已深入集成到JIRA数据存储中，否则在处理大量对象时很难获得良好的性能。例如，如果有数千(数百万)个存储的对象(例如，JIRA门票)，并且如果过滤没有在数据存储本身中实现，则有必要将每个对象读入应用存储器，以检查它是否匹配过滤和分类条件。显然，它看起来效率不高。在我参与的几个项目中，我遇到了类似的问题，我想利用这一经验提供一个在我看来非常有效的解决方案。<br/> <em class="kw">注。在下文中，我们将只关注SQL数据库。很可能，许多人会同意这样的说法，即SQL数据库现在仍然是存储应用程序数据的最流行的方式。</em></p><h1 id="1ce8" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">表结构</h1><p id="707e" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">在过滤数据之前，您必须首先弄清楚如何正确地组织SQL表中的数据。在最简单的情况下，动态属性的表结构可能如下所示:</p><ul class=""><li id="997e" class="ma mb iq ka b kb kc kf kg kj mc kn md kr me kv mf mg mh mi bi translated"><strong class="ka ir">产品</strong> —将要扩展动态属性的对象列表</li><li id="b15e" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated"><strong class="ka ir">属性</strong> —动态属性列表(名称和类型)</li><li id="2e58" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated"><strong class="ka ir">产品属性</strong> —产品的动态属性值</li></ul><p id="d5dd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们看一个例子，我们有一个手机型号列表，我们想动态添加一些附加属性，如“供应商”、“内存(Gb)”、“蜂窝协议”、“发布日期”等。</p><p id="af45" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这种情况下，数据可能如下所示:</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mo"><img src="../Images/27116ab65eaa96fd741c982f9e0c782f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zov89k54-remvbmrIXEwbw.png"/></div></div></figure><p id="befb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个简单的结构中有一点可能会导致某些问题——注意，<strong class="ka ir">值</strong>列的类型是字符串。乍一看，这似乎合乎逻辑，因为属性类型可以不同，但是任何类型都可以表示为字符串。但是，就筛选和排序而言，这并不是最佳选择，因为通常情况下，字符串比较与编码值比较并不对应。例如，当比较字符串<em class="kw"> '2.11' </em>和<em class="kw"> '11.2' </em>以及比较数字2.11和11.2时，会得到完全相反的结果——即<em class="kw"> '2.11' </em>比<em class="kw"> '11.2' </em>大，但2.11小于11.2</p><p id="91f6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用字符串的另一个问题是，相同的数据可能以不同的方式编码。我认为许多开发人员都遇到过由不同的日期格式引起的问题:2022年5月29日，2022年5月22日，2022年5月29日——相同的日期，但不同的字符串。</p><p id="6858" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通常，属性值可以是更复杂的结构，如列表，如果它们被编码为单个字符串，这样的值在数据库级别几乎变得无法管理。</p><p id="52c1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">记住以上内容，考虑新的表结构:</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mt"><img src="../Images/81305190ad7957b8299bfe99998b5eb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*32dfW2XYJzwvtz0QkgZgZw.png"/></div></div></figure><p id="602b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，值表(<strong class="ka ir"> ProductAttribute </strong>)中每个属性类型(引用、数字、日期)都有一列。列表值被移到单独的表<strong class="ka ir"> ProductAttributeItem </strong>中。</p><p id="8567" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用该结构，我们可以尝试选择一些符合特定标准的产品。</p><h1 id="c3aa" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">SQL过滤</h1><p id="736f" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">让我们考虑一个“复杂滤波器”，例如:</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mu"><img src="../Images/f2c3d4ca5e375ab9555204d56f6e6642.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FbrV6MGrsIkQHK5RSB3ZOw.png"/></div></div></figure><p id="2fe1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在SQL中，它可以表示为:</p><pre class="mp mq mr ms gt mv mw mx my aw mz bi"><span id="15c5" class="na ky iq mw b gy nb nc l nd ne"><strong class="mw ir">(</strong><br/>  <strong class="mw ir">[1]</strong><em class="kw">/*Vendor*/</em> = <strong class="mw ir">1</strong><em class="kw">/*Apple*/</em> <br/>  <strong class="mw ir">AND</strong><br/>  <strong class="mw ir">[2]</strong><em class="kw">/*Internal Memory*/ </em>&gt;= <strong class="mw ir">64</strong><br/>  <strong class="mw ir">AND</strong> <br/>  <strong class="mw ir">[2]</strong><em class="kw">/*Internal Memory*/</em> &lt;= <strong class="mw ir">256</strong><br/><strong class="mw ir">)<br/>OR<br/>([1]</strong><em class="kw">/*Vendor*/</em> = <strong class="mw ir">2</strong><em class="kw">/*Samsung*/</em><strong class="mw ir">)</strong></span></pre><p id="55e0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">想法是将表达式注入到某个SQL查询中，以便数据库服务器自己进行过滤。为此，它需要:</p><ol class=""><li id="1584" class="ma mb iq ka b kb kc kf kg kj mc kn md kr me kv nf mg mh mi bi translated">分析过滤器中使用了哪些属性</li><li id="fa9e" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv nf mg mh mi bi translated">将一个值表(<strong class="ka ir"> ProductAttribute </strong>)连接到过滤器中出现的唯一属性</li></ol><p id="73f8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">过滤器包含两个属性:</p><ul class=""><li id="2f35" class="ma mb iq ka b kb kc kf kg kj mc kn md kr me kv mf mg mh mi bi translated"><strong class="ka ir"> [1]供应商</strong> —引用枚举</li><li id="79ed" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated"><strong class="ka ir">【2】内部存储器</strong> —编号</li></ul><p id="d9ce" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，最终查询应该包含一个子查询，其中<strong class="ka ir"> ProductAttribute </strong>用适当的列别名连接了两次:</p><pre class="mp mq mr ms gt mv mw mx my aw mz bi"><span id="a2b5" class="na ky iq mw b gy nb nc l nd ne"><strong class="mw ir">SELECT</strong><br/>    [ATTRIBUTES].ProductId<br/><strong class="mw ir">FROM</strong><br/><strong class="mw ir">(</strong><br/>    <strong class="mw ir">SELECT</strong><br/>        [P].ProductId,<br/>        [AT_1].ValueItem <strong class="mw ir">[1]</strong>,<br/>        [AT_2].ValueInt <strong class="mw ir">[2]</strong><br/>    <strong class="mw ir">FROM</strong> Product<br/>        [P]<br/>    <strong class="mw ir">LEFT JOIN</strong> ProductAttribute<br/>        [AT_1] ON<br/>        [AT_1].AttributeId = <strong class="mw ir">1</strong>/*Vendor*/<br/>        AND<br/>        [AT_1].ProductId = [P].ProductId<br/>    <strong class="mw ir">LEFT JOIN</strong> ProductAttribute<br/>        [AT_2] ON<br/>        [AT_2].AttributeId = <strong class="mw ir">2</strong>/*Internal Memory*/<br/>        AND<br/>        [AT_2].ProductId = [P].ProductId<br/><strong class="mw ir">)</strong> [ATTRIBUTES]<br/><strong class="mw ir">WHERE<br/>(</strong><br/>  <strong class="mw ir">[1]</strong><em class="kw">/*Vendor*/</em> = <strong class="mw ir">1</strong><em class="kw">/*Apple*/</em> <br/>  <strong class="mw ir">AND</strong><br/>  <strong class="mw ir">[2]</strong><em class="kw">/*Internal Memory*/ </em>&gt;= <strong class="mw ir">64</strong><br/>  <strong class="mw ir">AND</strong> <br/>  <strong class="mw ir">[2]</strong><em class="kw">/*Internal Memory*/</em> &lt;= <strong class="mw ir">256</strong><br/><strong class="mw ir">)<br/>OR<br/>([1]</strong><em class="kw">/*Vendor*/</em> = <strong class="mw ir">2</strong><em class="kw">/*Samsung*/</em><strong class="mw ir">)</strong></span></pre><p id="a039" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如我们所看到的，原始的过滤表达式(像任何其他具有相同属性的表达式一样)可以注入到查询中，过滤将直接在SQL数据库中执行。除了这个过滤会非常高效(我们会添加索引，对吧？)，我们还能够在排序的数据集中选择一个范围(带有获取偏移量的分页)，如果在应用程序级别进行过滤，这将要求所有数据都在应用程序的内存中。</p><h1 id="34ad" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">构建动态SQL</h1><p id="2d65" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">理论上，这看起来不错，但是不清楚如何在实际应用中使用这种方法，因为必须首先解决以下任务:</p><ol class=""><li id="7e45" class="ma mb iq ka b kb kc kf kg kj mc kn md kr me kv nf mg mh mi bi translated">将过滤标准转换为SQL布尔表达式</li><li id="bf16" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv nf mg mh mi bi translated">使用所有必需的连接准备适当的基本选择查询</li></ol><p id="9604" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您的ORM很难足够灵活来执行这些技巧，想到的第一个想法是将动态sql查询构建为文本，这当然是可能的，但我建议使用一些允许使用SQL语法树的SQL构建器，这将是更安全、更灵活的解决方案。</p><p id="0d6a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此外，作为一个例子，我将使用<a class="ae ng" href="https://github.com/0x1000000/SqExpress" rel="noopener ugc nofollow" target="_blank"> SqExpress </a>库。Net平台。当然，您可以使用其他类似的库——原理是一样的。</p><p id="8d7c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们从构建一个布尔表达式开始:</p><p id="65b0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kw">注意:这里它是硬编码的，但是并不妨碍从一些过滤器模型中动态地创建它。</em></p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="84ef" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">小检查，这是我们想要的:</p><pre class="mp mq mr ms gt mv mw mx my aw mz bi"><span id="ae4d" class="na ky iq mw b gy nb nc l nd ne"><strong class="mw ir">Console</strong>.WriteLine(<strong class="mw ir">TSqlExporter</strong>.Default.ToSql(filter));</span><span id="4514" class="na ky iq mw b gy nj nc l nd ne">//[1]=1 AND [2]&gt;=64 AND [2]&lt;=256 OR [1]=2</span></pre><p id="9c0b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用语法树遍历，我们可以在表达式中找到所有唯一的属性id:</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="a0a0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我们知道所有的属性id时，我们可以读取它们的类型:</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="9175" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，使用过滤表达式中关于属性的信息，我们可以构建一个子查询，其中<strong class="ka ir"> ProductAttribute </strong>表将针对每个唯一属性连接一次:</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="17e5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将所有这些结合在一起:</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="4ea0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这对于简单的属性来说很好，但是如果一个属性是“Set”(值是一组项目)，那么将需要更多的工作。例如，我们希望通过蜂窝协议进行过滤:</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="43e1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要由数据库服务器执行，该过滤查询必须修改如下<strong class="ka ir"> : IN </strong>操作符应替换为<strong class="ka ir"> EXISTS </strong>子查询，以便使用<strong class="ka ir"> ProductAttributeItem </strong>表。这可以通过修改过滤器语法树来实现:</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="nh ni l"/></div></figure><pre class="mp mq mr ms gt mv mw mx my aw mz bi"><span id="4e8e" class="na ky iq mw b gy nb nc l nd ne"><strong class="mw ir">EXISTS</strong><br/><strong class="mw ir">(</strong><br/>  <strong class="mw ir">SELECT</strong> 1 <br/>  <strong class="mw ir">FROM</strong> [dbo].[ProductAttributeItem] <br/>    [A0] <br/>  <strong class="mw ir">WHERE</strong> <br/>     [A0].[AttributeId]=3 <br/><strong class="mw ir">     AND</strong> <br/>     [A0].[ProductId]=[A1].[ProductId] <br/>     <strong class="mw ir">AND</strong> <br/>     [A0].[AttributeItemId] <strong class="mw ir">IN(</strong>3,5<strong class="mw ir">)</strong><br/><strong class="mw ir">)</strong></span></pre><p id="5f72" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">修改后，过滤器可用于查询:</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="nh ni l"/></div></figure></div><div class="ab cl nk nl hu nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="ij ik il im in"><p id="e492" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用上述技术和方法，您不仅可以创建具有动态扩展实体的应用程序，还可以提供丰富的功能来根据各种标准过滤这些实体。</p><p id="4f9a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">链接:</p><ul class=""><li id="5692" class="ma mb iq ka b kb kc kf kg kj mc kn md kr me kv mf mg mh mi bi translated"><a class="ae ng" href="https://github.com/0x1000000/SqGoods" rel="noopener ugc nofollow" target="_blank"> SqGoods </a> —这是一个演示web应用程序，演示动态实体的动态过滤；</li><li id="36e0" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated"><a class="ae ng" href="https://github.com/0x1000000/DynAttDemo" rel="noopener ugc nofollow" target="_blank">本文源代码代码</a></li><li id="e25a" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated"><a class="ae ng" href="https://github.com/0x1000000/SqExpress" rel="noopener ugc nofollow" target="_blank"> SqExpress </a> —文章示例中使用的sql查询构建器。</li></ul></div></div>    
</body>
</html>