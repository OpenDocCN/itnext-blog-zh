<html>
<head>
<title>A Standalone Linux Kernel Module</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">独立的Linux内核模块</h1>
<blockquote>原文：<a href="https://itnext.io/a-standalone-linux-kernel-module-df54283d4803?source=collection_archive---------1-----------------------#2020-05-14">https://itnext.io/a-standalone-linux-kernel-module-df54283d4803?source=collection_archive---------1-----------------------#2020-05-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="9a25" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你曾经为Linux内核编译过一个模块，你可能会看到(或者假设有)在运行阶段<code class="fe kl km kn ko b">make</code>和<code class="fe kl km kn ko b">insmod</code>之间有很多巫术在进行。</p><p id="c75c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">作为对这个过程中所涉及的魔法的一个快速提醒，看一下下面最简单的内核模块及其相应的makefile:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ku kv l"/></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">一个超级简单的模块</figcaption></figure><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ku kv l"/></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">需要一段时间来解释发生了什么</figcaption></figure><p id="faee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">makefile本身相当晦涩，但是<code class="fe kl km kn ko b">make</code>命令才是真正有趣的地方:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi la"><img src="../Images/ebc952e871708a0dfc65c5f465fec13e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1386/format:webp/1*kSwa77l9LZ9BKH_FFqIg_Q.png"/></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">这只是冰山一角</figcaption></figure><p id="68ac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从右边开始，我们看不到“标准”编译调用，包括日常用户几乎没有接触过的目录。running<code class="fe kl km kn ko b">make V=1</code>揭示了堆积如山的调用，其中一些是对与编译无关的二进制文件和脚本的调用。这是怎么回事？</p><p id="569d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe kl km kn ko b">.ko</code>的编译过程可能看起来可怕而复杂，但是通过简单的检查，不难发现到底发生了什么。</p><p id="6e98" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这篇文章中，我们将在不使用任何内核头文件或复杂makefiles的情况下，完成编译内核模块<strong class="jp ir">的旅程。我们的目标是编写一个简短、简单、易于理解的<code class="fe kl km kn ko b">.c</code>文件，当用<code class="fe kl km kn ko b">gcc</code>和一些最小的标志编译时，输出一个可以被<code class="fe kl km kn ko b">insmod</code>编辑的有效的<code class="fe kl km kn ko b">.ko</code>。</strong></p><p id="ab9d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这可以通过几种不同的方法来实现:</p><ul class=""><li id="86dc" class="ld le iq jp b jq jr ju jv jy lf kc lg kg lh kk li lj lk ll bi translated">阅读文档。</li><li id="00a4" class="ld le iq jp b jq lm ju ln jy lo kc lp kg lq kk li lj lk ll bi translated">检查标准编译过程。</li><li id="f0db" class="ld le iq jp b jq lm ju ln jy lo kc lp kg lq kk li lj lk ll bi translated">查看内核源代码，试图理解<code class="fe kl km kn ko b">init_module</code>系统调用(负责加载<code class="fe kl km kn ko b">.ko</code>的那个)做什么。</li></ul><p id="0a0a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是我们选择的方法将是第四种，即<strong class="jp ir">黑盒方式</strong>:修补加载器，查看有效模块，编写无效模块，并尝试做任何看起来可行的事情，直到我们最终成功。</p><p id="eee7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我看来，黑盒是研究未知或未知系统时最有用和最有效的技能，因为通常前一种方法都不适用，或者可能更费时费力。此外，这是最有回报的过程，因为你会毫不费力地得到快速而有趣的回报。</p><p id="0b1f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但首先，我们必须了解什么是内核模块<strong class="jp ir">实际上是</strong>。</p><h1 id="9276" class="lr ls iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">什么是内核模块？</h1><p id="f926" class="pw-post-body-paragraph jn jo iq jp b jq mp js jt ju mq jw jx jy mr ka kb kc ms ke kf kg mt ki kj kk ij bi translated"><code class="fe kl km kn ko b">.ko</code>后缀的意思是“<em class="mu">内核对象</em>”，暗示了模块到底是什么——只是一个<strong class="jp ir"> ELF对象文件</strong>。事实上，在内核版本<code class="fe kl km kn ko b">2.6</code>之前，内核模块使用<code class="fe kl km kn ko b">.o</code>后缀，就像标准的目标文件一样。</p><p id="b490" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么传统的<code class="fe kl km kn ko b">.o</code>文件和<code class="fe kl km kn ko b">.ko</code>文件有什么区别呢？让我们尝试将一个“空”目标文件加载到我们的内核中:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/813dc293b514c3c070e4f640f5883ab7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NB36abcao9gcsONddMAbWw.png"/></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">将“空”目标文件加载到内核失败</figcaption></figure><p id="3235" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对我们来说幸运的是，当涉及到关于模块的错误时，内核是非常描述性的。<code class="fe kl km kn ko b">dmesg</code>显示我们的空目标文件缺少一个叫做<code class="fe kl km kn ko b">.modinfo</code>的部分。让我们将它添加到我们的模块中！</p><p id="233b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最简单的方法是创建任何变量，并使用<code class="fe kl km kn ko b">__attribute__((section(&lt;name&gt;)))</code>告诉<code class="fe kl km kn ko b">gcc</code>将它存储在我们选择的部分中。有关属性的更多信息，请参见<a class="ae mw" href="https://gcc.gnu.org/onlinedocs/gcc-10.1.0/gcc/Common-Variable-Attributes.html" rel="noopener ugc nofollow" target="_blank"> <em class="mu"> gcc文档</em> </a>。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi mx"><img src="../Images/444307f17134d480dc47434882ac11df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PucADo2r55RP2jJT9cHOtw.png"/></div></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">“突出显示”类似于“猫”,但带有语法突出显示！</figcaption></figure><p id="ecde" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">错误改变了！似乎我们的modinfo部分缺少一些名称字段。为了了解如何正确设置该字段，让我们来看一个“真正的”内核模块，来自<code class="fe kl km kn ko b">/lib/modules/$(uname -r)/</code>，使用<code class="fe kl km kn ko b">objdump -s -j .modinfo</code>转储该部分的内容:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/1075d392f0da5355c72c4e72e5941e17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1186/format:webp/1*gjHYiRqCuW5QcvMvJyNvbQ.png"/></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">在麻瓜世界中，使用便捷的“modinfo”命令</figcaption></figure><p id="6509" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">看起来它只是由<code class="fe kl km kn ko b">key=value</code>字符串组成，由<code class="fe kl km kn ko b">null</code>字节分隔。所以让我们添加<code class="fe kl km kn ko b">name</code>字段，看看会发生什么:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi nd"><img src="../Images/701bcbf11cccdd3c0cf95bfadcfa15e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zB7UgbGAGXPfjGFHwdrqqA.png"/></div></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">我庄严宣誓我不怀好意</figcaption></figure><p id="3a6f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">成功了！内核成功地将我们的模块名称识别为<code class="fe kl km kn ko b">standalone</code>！</p><p id="8276" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下一个错误似乎有点晦涩。由于没有从内核得到有用的提示，是时候再次看看一个“真正的”内核模块了。通过使用<code class="fe kl km kn ko b">readelf -S</code>或<code class="fe kl km kn ko b">objdump -h</code>检查其部分，我们发现另一个候选名称相当可疑，可能与加载过程有关:<code class="fe kl km kn ko b">[.rela].gnu.linkonce.this_module</code>。</p><p id="3c6d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">(<code class="fe kl km kn ko b">.rela</code>部分只是该部分值的重定位数据)</p><p id="560a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我的Ubuntu 18.04上，这个段的大小是<code class="fe kl km kn ko b">0x380</code>字节，有两个可重定位的符号:偏移量<code class="fe kl km kn ko b">0x178</code>处的<code class="fe kl km kn ko b">init_module</code>，偏移量<code class="fe kl km kn ko b">0x330</code>处的<code class="fe kl km kn ko b">cleanup_module</code>。转储该节的内容(<code class="fe kl km kn ko b">objdump -s</code>)显示，除了模块名，它在偏移量<code class="fe kl km kn ko b">0x18</code>处大部分被清零。</p><p id="49d1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个部分实际上是来自Linux内核源代码<code class="fe kl km kn ko b">include/linux/module.h</code>的C <code class="fe kl km kn ko b">struct module</code>，作为一个部分嵌入在ELF中。它通常被命名为<code class="fe kl km kn ko b">__this_module</code>，在加载过程中，内核加载程序初始化struct中的其他相关字段。</p><p id="5eb9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是我们没有使用任何内核头文件。幸运的是，我们有所有需要的信息。让我们添加一些<code class="fe kl km kn ko b">init</code>和<code class="fe kl km kn ko b">exit</code>功能，以及相关部分:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ku kv l"/></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">快到了！</figcaption></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi ne"><img src="../Images/da0304ba8a97a72a6cc1c871cfc3d31b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6Rgi8E-MUhC7kyGHv2bGgA.png"/></div></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">Lumos Maxima！</figcaption></figure><p id="5a6a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">(我们使用<code class="fe kl km kn ko b">__attribute__((packed))</code>来强制编译器不要在结构的字段之间添加任何额外的填充，从而强制我们已知的偏移量。)</p><p id="43a8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">令人困惑的是，即使<code class="fe kl km kn ko b">insmod</code>失败了，在<code class="fe kl km kn ko b">dmesg</code>中也没有错误日志。我们可以使用<code class="fe kl km kn ko b">lsmod | grep standalone</code>来验证该模块实际上没有被加载。这是怎么回事？</p><p id="6c62" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通常内核会提醒我们任何丢失的参数，但是很明显，在一些内核配置中，有时对于一些丢失的字段不会显示任何消息。让我们回头看一个真实的内核模块。我们的模块和真实模块之间唯一的主要区别是<code class="fe kl km kn ko b">.modinfo</code>部分中的字段。</p><p id="0c29" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这一部分，我们可以开始一个接一个地复制剩余的字段，直到我们成功或者得到不同的错误消息。然而，对我们来说幸运的是，一个被施了魔法的神谕在晚上悄悄在我们耳边说，我们应该先从复制<code class="fe kl km kn ko b">.vermagic</code>字段开始！</p><p id="c0ea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe kl km kn ko b">vermagic</code>是“Version Magic”的缩写，它是一个字符串，加载程序使用它来检查一个模块是否确实是为那个内核版本编译的。我们可以从为内核编译的模块中提取它的内容，或者，让内核为我们把它吐出来！</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ku kv l"/></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">Makefiles和Charms是我在霍格沃茨最喜欢的两门课</figcaption></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi nf"><img src="../Images/887766c087b40629b3ba01f77968dce1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Gtm7b_qf9Eqi9MOE0wnqNQ.png"/></div></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">谢谢你的提示！</figcaption></figure><p id="f1a3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后一次更改vermagic值会产生:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/3a73c38fe217f2f9fc5d3bbb751e01e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1032/format:webp/1*u1RjpsP8RrX_JNbkis2UKA.png"/></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">成功了！</figcaption></figure><p id="14bd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">…我们完成了！我们成功地将一个模块加载到内核中，不用任何内核头文件就编译了<strong class="jp ir">！</strong></p><p id="0e5a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要完整观看最终的<code class="fe kl km kn ko b">standalone.c</code>文件，请访问<a class="ae mw" href="https://github.com/0xEitan/standalone-ko" rel="noopener ugc nofollow" target="_blank">https://github.com/0xEitan/standalone-ko</a>。</p><h1 id="079a" class="lr ls iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">复杂系统的去神秘化</h1><p id="e8f2" class="pw-post-body-paragraph jn jo iq jp b jq mp js jt ju mq jw jx jy mr ka kb kc ms ke kf kg mt ki kj kk ij bi translated">许多人在面对一个复杂且通常不吸引人的系统时会不知所措。无论是他们正在熟悉的某个collosal项目，还是他们想要编程的未知嵌入式设备，或者一般的Linux内核，潜入深水总是令人生畏的。</p><p id="778b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">尽管我们在这篇文章中没有使用纯黑盒，但我发现像这样的方法在这种情况下非常有效。它可能不会像目前的情况一样产生成功的结果，但它肯定总能揭示重要的见解，并有助于克服面对未知代码库时的第一个障碍。</p><p id="c7da" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">没有什么太复杂而无法理解，只需要用正确的工具去做。</p></div></div>    
</body>
</html>