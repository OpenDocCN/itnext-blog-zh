<html>
<head>
<title>Tips for server-side rendering with React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用React进行服务器端渲染的技巧</h1>
<blockquote>原文：<a href="https://itnext.io/tips-for-server-side-rendering-with-react-e42b1b7acd57?source=collection_archive---------0-----------------------#2018-11-03">https://itnext.io/tips-for-server-side-rendering-with-react-e42b1b7acd57?source=collection_archive---------0-----------------------#2018-11-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/a6a0522ea351d9e00f78fcf9f79d7d0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QvtSaHdquK5FBIFoJ0gc_A.jpeg"/></div></figure><p id="ceac" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">嗨，今天我想分享一些当你用<a class="ae ks" href="https://reactjs.org" rel="noopener ugc nofollow" target="_blank"> React </a>开发服务器端渲染应用的技巧。</p><h2 id="ac17" class="kt ku iq bd kv kw kx dn ky kz la dp lb kf lc ld le kj lf lg lh kn li lj lk ll bi translated">Web API用法</h2><p id="fdbf" class="pw-post-body-paragraph ju jv iq jw b jx lm jz ka kb ln kd ke kf lo kh ki kj lp kl km kn lq kp kq kr ij bi translated">使用<a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/API" rel="noopener ugc nofollow" target="_blank"> Web API </a>时要小心，因为它们不能在服务器端工作。这些是我们通常使用常见Web API:</p><ul class=""><li id="b83a" class="lr ls iq jw b jx jy kb kc kf lt kj lu kn lv kr lw lx ly lz bi translated"><a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model" rel="noopener ugc nofollow" target="_blank"> DOM </a>(文档)</li><li id="5fad" class="lr ls iq jw b jx ma kb mb kf mc kj md kn me kr lw lx ly lz bi translated"><a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/API/Window" rel="noopener ugc nofollow" target="_blank">窗口</a>(窗口、<a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/API/Navigator" rel="noopener ugc nofollow" target="_blank">导航器</a>等)</li><li id="4501" class="lr ls iq jw b jx ma kb mb kf mc kj md kn me kr lw lx ly lz bi translated"><a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/API/Storage" rel="noopener ugc nofollow" target="_blank">存储</a>(本地存储、会话存储等)</li></ul><p id="4b97" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">避免在这些生命周期中使用它们，因为它们是在服务器渲染期间调用的:</p><ul class=""><li id="d092" class="lr ls iq jw b jx jy kb kc kf lt kj lu kn lv kr lw lx ly lz bi translated">构造器</li><li id="c07d" class="lr ls iq jw b jx ma kb mb kf mc kj md kn me kr lw lx ly lz bi translated"><a class="ae ks" href="https://reactjs.org/docs/react-component.html#static-getderivedstatefromprops" rel="noopener ugc nofollow" target="_blank">getDerivedStateFromProps</a></li><li id="1bcc" class="lr ls iq jw b jx ma kb mb kf mc kj md kn me kr lw lx ly lz bi translated">组件将挂载(已弃用)</li></ul><p id="260a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">你可以在<code class="fe mf mg mh mi b"><a class="ae ks" href="https://reactjs.org/docs/react-component.html#componentdidmount" rel="noopener ugc nofollow" target="_blank">componentDidMount</a></code>和<code class="fe mf mg mh mi b"><a class="ae ks" href="https://reactjs.org/docs/react-component.html#componentdidupdate" rel="noopener ugc nofollow" target="_blank">componentDidUpdate</a></code>生命周期以及在<code class="fe mf mg mh mi b">componentDidMount</code>阶段之后运行的任何类方法中安全地完成它。</p><blockquote class="mj mk ml"><p id="ca0d" class="ju jv mm jw b jx jy jz ka kb kc kd ke mn kg kh ki mo kk kl km mp ko kp kq kr ij bi translated">我假设我们使用<code class="fe mf mg mh mi b"><a class="ae ks" href="https://reactjs.org/docs/react-dom-server.html#rendertostring" rel="noopener ugc nofollow" target="_blank">renderToString</a></code>和<code class="fe mf mg mh mi b"><a class="ae ks" href="https://reactjs.org/docs/react-dom-server.html#rendertonodestream" rel="noopener ugc nofollow" target="_blank">renderToNodeStream</a></code> API进行服务器端渲染。<a class="ae ks" href="https://prerender.io/" rel="noopener ugc nofollow" target="_blank">预渲染库</a>不算做SSR，因为只有客户端的生命周期仍然会被执行</p></blockquote><p id="e83d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">所以，你可能会想:</p><blockquote class="mq"><p id="c469" class="mr ms iq bd mt mu mv mw mx my mz kr dk translated">"但是我可以查一下<code class="fe mf mg mh mi b">window</code>是否有空吗？"</p></blockquote><p id="6000" class="pw-post-body-paragraph ju jv iq jw b jx na jz ka kb nb kd ke kf nc kh ki kj nd kl km kn ne kp kq kr ij bi translated">嗯，看情况，但是<strong class="jw ir">不要</strong>这么做！</p><pre class="nf ng nh ni gt nj mi nk nl aw nm bi"><span id="02c7" class="kt ku iq mi b gy nn no l np nq">constructor(props) {<br/>  super(props)<br/>  this.state = {<br/>    data: typeof window !== 'undefined' ? 'client' : 'server'<br/>  }<br/>}</span><span id="1dab" class="kt ku iq mi b gy nr no l np nq">render()<br/>  return &lt;div&gt;{this.state.data}&lt;/div&gt;<br/>}</span></pre><p id="891f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">您将在浏览器控制台上看到以下警告:</p><pre class="nf ng nh ni gt nj mi nk nl aw nm bi"><span id="cbd1" class="kt ku iq mi b gy nn no l np nq">index.js:2178 Warning: Text content did not match. Server: "server" Client: "client"</span></pre><p id="f8b8" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">那么这里出了什么问题呢？这是因为React期望在水合过程中，在<strong class="jw ir">服务器</strong>上呈现的那个<strong class="jw ir">应该与在<strong class="jw ir">客户端</strong>上呈现的</strong>相同。在进行DOM访问/操作之前使用窗口类型检查是可以的，但是要确保它不会影响客户端和服务器之间的渲染差异。</p><p id="373f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">好吧，现在你可能会问:</p><blockquote class="mq"><p id="0467" class="mr ms iq bd mt mu mv mw mx my mz kr dk translated">“但我需要基于窗口/浏览器API进行渲染……”</p></blockquote><p id="b9af" class="pw-post-body-paragraph ju jv iq jw b jx na jz ka kb nb kd ke kf nc kh ki kj nd kl km kn ne kp kq kr ij bi translated">如果在某些情况下，您需要基于DOM对象或Web APIs进行渲染，那么您需要在<code class="fe mf mg mh mi b">componentDidMount</code>生命周期之后进行渲染，并且在服务器上，您可以渲染占位符(加载组件，或者仅仅是<code class="fe mf mg mh mi b">null</code>)</p><pre class="nf ng nh ni gt nj mi nk nl aw nm bi"><span id="7182" class="kt ku iq mi b gy nn no l np nq">constructor(props) {<br/>  super(props)<br/>  this.state = {<br/>    ssrDone: false<br/>  }<br/>}</span><span id="3344" class="kt ku iq mi b gy nr no l np nq">componentDidMount() {<br/>  this.setState({ ssrDone: true, online: navigator.onLine })<br/>}</span><span id="fae0" class="kt ku iq mi b gy nr no l np nq">render() {<br/>  if(!this.state.ssrDone) {<br/>    return (<br/>      &lt;div&gt;loading...&lt;/div&gt;<br/>    )<br/>  }<br/>  return &lt;div&gt;{this.state.online ? 'on' : 'off'}&lt;/div&gt;<br/>}</span></pre><p id="1d44" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这在您使用非SSR友好的第三方React组件时尤其有用(这将在服务器渲染期间引发错误)。<a class="ae ks" href="https://reactjs.org/docs/react-dom.html#hydrate" rel="noopener ugc nofollow" target="_blank">官方React文档</a>也展示了相同的技术(名称为“两遍渲染”)，但它也声明:</p><blockquote class="mq"><p id="a79a" class="mr ms iq bd mt mu mv mw mx my mz kr dk translated">请注意，这种方法会使您的组件变慢，因为它们必须渲染两次，所以请谨慎使用</p></blockquote><p id="82b8" class="pw-post-body-paragraph ju jv iq jw b jx na jz ka kb nb kd ke kf nc kh ki kj nd kl km kn ne kp kq kr ij bi translated">确保<strong class="jw ir">封装了</strong>这些依赖于DOM的组件，这样双重渲染只会发生在它们身上，而不是整个页面。</p><h2 id="d6b4" class="kt ku iq bd kv kw kx dn ky kz la dp lb kf lc ld le kj lf lg lh kn li lj lk ll bi translated">水合警告</h2><p id="946b" class="pw-post-body-paragraph ju jv iq jw b jx lm jz ka kb ln kd ke kf lo kh ki kj lp kl km kn lq kp kq kr ij bi translated">如果你收到一些水合警告，出于某种原因想忽略它们，你可以在元素上使用<code class="fe mf mg mh mi b"><a class="ae ks" href="https://reactjs.org/docs/dom-elements.html#suppresshydrationwarning" rel="noopener ugc nofollow" target="_blank">suppressHydrationWarning</a></code>道具。</p><h2 id="af52" class="kt ku iq bd kv kw kx dn ky kz la dp lb kf lc ld le kj lf lg lh kn li lj lk ll bi translated">奖金</h2><p id="4b77" class="pw-post-body-paragraph ju jv iq jw b jx lm jz ka kb ln kd ke kf lo kh ki kj lp kl km kn lq kp kq kr ij bi translated">使用<code class="fe mf mg mh mi b">ReactDOM.render()</code>来水合服务器渲染的容器是不赞成的，并将在React 17中<strong class="jw ir">移除</strong>。用<code class="fe mf mg mh mi b"><a class="ae ks" href="https://reactjs.org/docs/react-dom.html#hydrate" rel="noopener ugc nofollow" target="_blank">hydrate()</a></code>代替。(摘自<a class="ae ks" href="https://reactjs.org/docs/react-dom.html" rel="noopener ugc nofollow" target="_blank"> React官方文件</a>)</p></div><div class="ab cl ns nt hu nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="ij ik il im in"><p id="ee1e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我想这些都是我的，希望对你们有用。</p><p id="5050" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果你有任何问题或想法，请发帖回复，如果你喜欢，请<strong class="jw ir">拍手分享</strong>给你的朋友！</p><p id="c2b9" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">谢谢你。</p></div></div>    
</body>
</html>