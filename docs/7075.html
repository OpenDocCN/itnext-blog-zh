<html>
<head>
<title>Searching and min-max: The 114 C++ algorithms series</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">搜索和最小-最大:114 C++算法系列</h1>
<blockquote>原文：<a href="https://itnext.io/searching-and-min-max-the-114-c-algorithms-series-8a6ed951ad40?source=collection_archive---------0-----------------------#2022-06-03">https://itnext.io/searching-and-min-max-the-114-c-algorithms-series-8a6ed951ad40?source=collection_archive---------0-----------------------#2022-06-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="2f5f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">欢迎来到114 C++算法系列的第八部分。今天，我们将讨论查找特定元素或计算匹配元素数量的搜索算法和最小-最大算法。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/fceb7c8f6da81e71d78dda0d33d9035f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qL1LR3kNjNh3zqxWboCwFg.png"/></div></div></figure><h1 id="cc3d" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">该系列:</h1><ul class=""><li id="0858" class="lv lw iq jp b jq lx ju ly jy lz kc ma kg mb kk mc md me mf bi translated"><a class="ae mg" rel="noopener ugc nofollow" target="_blank" href="/the-114-standard-c-algorithms-introduction-2a75a2df4300">简介</a></li><li id="9b62" class="lv lw iq jp b jq mh ju mi jy mj kc mk kg ml kk mc md me mf bi translated"><a class="ae mg" rel="noopener ugc nofollow" target="_blank" href="/sorting-partitioning-the-114-c-algorithms-series-6503ad41cede">排序和分割算法</a></li><li id="f0a8" class="lv lw iq jp b jq mh ju mi jy mj kc mk kg ml kk mc md me mf bi translated"><a class="ae mg" rel="noopener ugc nofollow" target="_blank" href="/divide-conquer-and-sets-the-114-c-algorithms-series-d0085a38046e">对排序或分区范围进行操作的算法</a></li><li id="27d1" class="lv lw iq jp b jq mh ju mi jy mj kc mk kg ml kk mc md me mf bi translated"><a class="ae mg" rel="noopener ugc nofollow" target="_blank" href="/transformations-the-114-c-algorithms-series-deacdbd4c373">转换算法</a></li><li id="fb3e" class="lv lw iq jp b jq mh ju mi jy mj kc mk kg ml kk mc md me mf bi translated"><a class="ae mg" rel="noopener ugc nofollow" target="_blank" href="/left-folds-and-other-reductions-the-114-c-algorithms-series-6195724d324">左侧折叠和其他缩减</a></li><li id="e953" class="lv lw iq jp b jq mh ju mi jy mj kc mk kg ml kk mc md me mf bi translated"><a class="ae mg" rel="noopener ugc nofollow" target="_blank" href="/generators-copies-and-moves-the-114-c-algorithms-series-1d0774472877">生成器、复制和移动</a></li><li id="9900" class="lv lw iq jp b jq mh ju mi jy mj kc mk kg ml kk mc md me mf bi translated"><a class="ae mg" rel="noopener ugc nofollow" target="_blank" href="/heap-and-heap-the-114-c-algorithms-series-1d4215ae9f0d">堆和堆</a></li><li id="0bc9" class="lv lw iq jp b jq mh ju mi jy mj kc mk kg ml kk mc md me mf bi translated">搜索和最小值-最大值</li><li id="f1b4" class="lv lw iq jp b jq mh ju mi jy mj kc mk kg ml kk mc md me mf bi translated">结论(即将发布)</li></ul></div><div class="ab cl mm mn hu mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ij ik il im in"><p id="7c32" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们今天将讨论的搜索和最小-最大算法都是线性运算，复杂度为<em class="mt"> O(n) </em>(在单个范围上运算时)或<em class="mt"> O(m*n) </em>(在两个范围上运算时)。我们已经在第三篇文章中介绍了更快的查找算法。</p><h1 id="f6bf" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">找，找_如果，找_如果_不</h1><p id="8667" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy mu ka kb kc mv ke kf kg mw ki kj kk ij bi translated">std::find 算法提供了一个基本的线性搜索。该标准提供了三种变体，一种是按值搜索，另两种是使用谓词的变体。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mx"><img src="../Images/3c90deeeffdf132d145b0b0ab7bdaab6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cVB1GrLSuLw5faVX0M_pVg.png"/></div></div></figure><p id="ab35" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">按值搜索的典型示例是查找分隔符:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="41b8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为<em class="mt"> std::find_if </em>和<em class="mt"> std::find_if_not </em>使用谓词比较元素，所以我们可以搜索值的类别。在这个例子中，我们使用<em class="mt"> std::find_if_not </em>从任意方向查找第一个非空白字符:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="my mz l"/></div></figure><h1 id="cae6" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">相邻_查找，搜索_n</h1><p id="97ef" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy mu ka kb kc mv ke kf kg mw ki kj kk ij bi translated">顾名思义，<em class="mt"> std::adjacent_find </em>在范围内搜索相邻元素。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi na"><img src="../Images/50e0de2d8e7dbd2e46de3de6df88626b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L4lPAAYvawqbo7nRKeFdSQ.png"/></div></div></figure><p id="1945" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">基本版本使用<em class="mt">操作符== </em>或二元谓词(如果提供的话)搜索一对相邻的元素。在任何一种情况下，迭代器都会将该对返回到两个元素中的第一个。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="my mz l"/></div></figure></div><div class="ab cl mm mn hu mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ij ik il im in"><p id="8b11" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果要搜索两个以上连续相等的元素，可以使用<em class="mt"> std::search_n </em>。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nb"><img src="../Images/1e608ad89c092fd6a725e889b335c71b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hPCAno3FJlc08F8-efdC3A.png"/></div></div></figure><p id="3213" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该算法接受所需的实例数和要比较的值。如果找到，使用迭代器将序列返回到序列的第一个元素。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="40f5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，<em class="mt"> std::search_n </em>的行为不符合典型的命名。范围仍然完全使用一个<em class="mt">开始</em>和<em class="mt">结束</em>迭代器来指定。<em class="mt"> _n </em>表示实例的数量。</p><h1 id="f6cd" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">find_first_of</h1><p id="6519" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy mu ka kb kc mv ke kf kg mw ki kj kk ij bi translated">使用<em class="mt"> std::find_if，</em>我们可以很容易地搜索一类元素。然而，有时更方便的是详尽地列出我们正在寻找的元素。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nc"><img src="../Images/30391e9acbf2dafd3f9f8e6c89f42744.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5Vulwq1MDcw3xFnI4433Fg.png"/></div></div></figure><p id="5822" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，我们正在从线性搜索转移到<em class="mt"> O(m*n) </em>时间复杂度，因为对于第一范围的每个元素，我们需要将其与第二范围中的所有元素进行比较(最坏情况)。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="my mz l"/></div></figure><h1 id="3eb9" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">搜索，查找_结束</h1><p id="6699" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy mu ka kb kc mv ke kf kg mw ki kj kk ij bi translated">最后，我们得出在序列中搜索子序列的算法。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi na"><img src="../Images/4d0227000cf66f25ad303987be624ca4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jzt6gbtEN7YsMx_U-6IPdg.png"/></div></div></figure><p id="34ab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mt"> std::search </em>返回子序列的第一个实例，而<em class="mt"> std::find_end </em>返回子序列的最后一个实例。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="my mz l"/></div></figure><h2 id="1bfa" class="nd ky iq bd kz ne nf dn ld ng nh dp lh jy ni nj ll kc nk nl lp kg nm nn lt no bi translated">搜索者</h2><p id="fc87" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy mu ka kb kc mv ke kf kg mw ki kj kk ij bi translated">从C++17开始，我们也可以为搜索算法指定自定义的搜索器。除了基本的一个，标准实现了Boyer-Moore和Boyer-Moore-Horspool字符串搜索器，提供不同的最佳情况、最差情况和平均复杂性。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="my mz l"/></div></figure><h1 id="a79b" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">计数，count_if</h1><p id="90ce" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy mu ka kb kc mv ke kf kg mw ki kj kk ij bi translated"><em class="mt"> std::count </em>和<em class="mt"> std::count_if </em>算法计算匹配元素的数量。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mx"><img src="../Images/a8015e93dd2467bd671bbb01754011a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SjxvMNxY4juxk1tmYdMq6g.png"/></div></div></figure><p id="3f6a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">可以使用值或谓词指定要搜索的元素。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="my mz l"/></div></figure><h1 id="890f" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">相等，不匹配</h1><p id="bf4a" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy mu ka kb kc mv ke kf kg mw ki kj kk ij bi translated">在<a class="ae mg" rel="noopener ugc nofollow" target="_blank" href="/sorting-partitioning-the-114-c-algorithms-series-6503ad41cede">之前的一篇文章</a>中，我们使用<em class="mt">STD::lexicordial _ compare</em>和<em class="mt">STD::lexicordial _ compare _ three _ way</em>讨论了词典比较。<em class="mt"> std::equal </em>和<em class="mt"> std::mismatch </em>算法提供了一个更简单的等式比较，其中<em class="mt"> std::equal </em>返回一个简单的布尔值，而<em class="mt"> std::mismatch </em>返回一对表示不匹配元素的迭代器。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi np"><img src="../Images/e06accd5b0a9eb2a0ee52768692de62c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SEfpqKYp2kGZ0gK87hjOkQ.png"/></div></div></figure><p id="172d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">默认的<em class="mt">操作符== </em>可以被两种算法的二元谓词所取代。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="de8e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mt"> std::mismatch </em>算法返回一对底层元素不匹配的迭代器。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="my mz l"/></div></figure></div><div class="ab cl mm mn hu mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ij ik il im in"><p id="e233" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mt"> std::equal </em>和<em class="mt"> std::mismatch </em>都提供了指定第二范围的两个变量。这里的区别很重要。如果我们使用迭代器指定第二个范围，我们无法检测到范围大小的不匹配。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="my mz l"/></div></figure><h1 id="414b" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">夹子</h1><p id="e10d" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy mu ka kb kc mv ke kf kg mw ki kj kk ij bi translated"><em class="mt"> std::clamp </em>算法是少数不在范围内操作的算法之一。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mx"><img src="../Images/0da66ceb8e8f2241685520718734c4f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YnjlSEiMv9sZ5TaOCNjLzw.png"/></div></div></figure><p id="18ff" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">箝位算法将给定值箝位在提供的最小值和最大值之间:</p><ul class=""><li id="eba8" class="lv lw iq jp b jq jr ju jv jy nq kc nr kg ns kk mc md me mf bi translated">如果<em class="mt">值&lt;最小值</em>，则<em class="mt"> std::clamp </em>返回最小值</li><li id="0786" class="lv lw iq jp b jq mh ju mi jy mj kc mk kg ml kk mc md me mf bi translated">如果<em class="mt">最大值&lt;值</em>，<em class="mt"> std::clamp </em>返回最大值</li><li id="05cf" class="lv lw iq jp b jq mh ju mi jy mj kc mk kg ml kk mc md me mf bi translated">否则，<em class="mt"> std::clamp </em>返回值</li></ul><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="my mz l"/></div></figure><h1 id="63f6" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">最小，最大，最小最大</h1><p id="db1d" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy mu ka kb kc mv ke kf kg mw ki kj kk ij bi translated">第一组最小-最大算法也不对范围进行操作(C++20范围变量除外)。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nc"><img src="../Images/b82acd39fd56119eb36e6332d5bb4a36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Oq5GVlau8RAR-r5dQN5zxQ.png"/></div></div></figure><p id="8242" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">直到C++14，唯一可用的变体只对两个元素进行操作，返回一个const-reference。然后，C++14标准引入了一个在初始化列表上操作的变体，它通过值返回。最后，C++20引入了一个范围变量，它对输入范围进行操作，并按值返回。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="my mz l"/></div></figure><h1 id="01e0" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">最小元素，最大元素，最小最大元素</h1><p id="f35e" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy mu ka kb kc mv ke kf kg mw ki kj kk ij bi translated">最小-最大算法的元素版本在范围上操作，而不是通过常量引用或值返回，返回最小或最大元素的迭代器。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nt"><img src="../Images/9113e54b659521281f747a18d28ebbea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a33EWqzq6ajD3ReaA85zww.png"/></div></div></figure><p id="db9c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所有变量都需要<em class="mt"> forward_range </em>，因为它们将迭代器返回给最小-最大元素，而不是一个值。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="my mz l"/></div></figure><h1 id="9213" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">感谢您的阅读</h1><p id="9f40" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy mu ka kb kc mv ke kf kg mw ki kj kk ij bi translated">本系列还会有一篇文章介绍C++未来版本的特性，所以不要忘了继续关注。</p><p id="095c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我也在YouTube上发布视频。你有问题吗？在Twitter或LinkedIn上联系我。</p></div></div>    
</body>
</html>