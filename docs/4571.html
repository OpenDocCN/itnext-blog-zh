<html>
<head>
<title>Understanding Basic Kubernetes Concepts III — Services Give You Abstraction</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解Kubernetes的基本概念III——服务给你抽象</h1>
<blockquote>原文：<a href="https://itnext.io/understanding-basic-kubernetes-concepts-iii-services-give-you-abstraction-efd80db2465c?source=collection_archive---------9-----------------------#2020-07-27">https://itnext.io/understanding-basic-kubernetes-concepts-iii-services-give-you-abstraction-efd80db2465c?source=collection_archive---------9-----------------------#2020-07-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><a href="http://www.giantswarm.io"><div class="gh gi jn"><img src="../Images/1776925bb7f062b84d7d9141c9ec928a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PqTUOkOG39rWB0Vnw-bMHQ.jpeg"/></div></a></figure><p id="0d8c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这篇文章是一系列关于Kubernetes基本概念的博客文章中的第三篇。在第一篇中，我 <a class="ae kt" href="https://blog.giantswarm.io/understanding-basic-kubernetes-concepts-i-introduction-to-pods-labels-replicas/" rel="noopener ugc nofollow" target="_blank"> <em class="ks">解释了pod、标签和副本集</em> </a> <em class="ks">的概念。在第二篇文章中，</em> <a class="ae kt" href="https://blog.giantswarm.io/understanding-basic-kubernetes-concepts-using-deployments-manage-services-declaratively/" rel="noopener ugc nofollow" target="_blank"> <em class="ks">我们谈到了部署</em> </a> <em class="ks">。这篇文章将详细阐述服务的概念。第四，我们看看</em> <a class="ae kt" href="https://blog.giantswarm.io/understanding-basic-kubernetes-concepts-iv-secrets-and-configmaps/" rel="noopener ugc nofollow" target="_blank"> <em class="ks">秘密和配置图</em> </a> <em class="ks">。在第五篇也是最后一篇文章中，我们将讨论</em> <a class="ae kt" href="https://blog.giantswarm.io/understanding-basic-kubernetes-concepts-v-daemon-sets-and-jobs/" rel="noopener ugc nofollow" target="_blank"> <em class="ks">守护进程集和</em> </a> <em class="ks">作业集。</em></p><p id="3a66" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">到目前为止，您应该对Kubernetes的一些基本原语有了基本的理解。但是，还是有一些概念缺失。其中一个非常核心的问题是，特别是在使用微服务时，在pod(和其他服务)上设置一个抽象层，这样您就可以与它们通信，而不必跟踪每个pod的开始、结束和重新安排。它是Kubernetes中服务发现的基本构件。</p><h1 id="f9dc" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">输入服务</h1><p id="59da" class="pw-post-body-paragraph ju jv iq jw b jx ls jz ka kb lt kd ke kf lu kh ki kj lv kl km kn lw kp kq kr ij bi translated">正如在本系列的第一篇博客文章中提到的，pod是短暂的，必然会被副本集(或复制控制器)动态地终止和启动。因此，与pod或其组通信需要抽象出短暂pod的概念。</p><p id="e0f0" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这就是服务的用武之地。它们是一个基本概念，在使用微服务架构时特别有用，因为它们将各个服务相互分离。例如，访问服务B的服务A不知道B中实际在做什么样的工作，也不知道有多少工作单元，实际的工作单元甚至它们的实现都可能完全改变。</p><h1 id="5847" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">服务如何工作</h1><p id="2804" class="pw-post-body-paragraph ju jv iq jw b jx ls jz ka kb lt kd ke kf lu kh ki kj lv kl km kn lw kp kq kr ij bi translated">服务通过定义一组逻辑单元和访问它们的策略来工作。pod的选择基于标签选择器(我们在第一篇博文中谈到过)。如果您选择多个pod，该服务会自动进行负载平衡，并为它们分配一个(虚拟)服务IP(您也可以手动设置)。</p><p id="cd8d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">您可以使用选择器选择一组窗格，并定义一个<code class="fe lx ly lz ma b">targetPort</code>来访问它们。进一步帮助抽象，这个<code class="fe lx ly lz ma b">targetPort</code>也可以指一个端口的名称，这给你更多的自由来实现服务背后的实际pods。甚至每个pod的端口也可以不同，只要它们具有相同的名称。</p><p id="3fbe" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">此外，服务可以抽象出不是Kubernetes pods的其他种类的后端。例如，您可以抽象出一个服务背后的外部数据库集群。例如，通过这种方式，您可以在开发环境中使用简单的本地数据库，在生产环境中使用专业管理的数据库集群，而不必改变其他服务与该数据库服务的通信方式。</p><p id="3b28" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果您的一些工作负载在您的Kubernetes集群之外运行，即在另一个Kubernetes集群(或<a class="ae kt" href="http://kubernetes.io/docs/user-guide/namespaces/" rel="noopener ugc nofollow" target="_blank">命名空间</a>)上运行，或者甚至完全在Kubernetes之外运行，您也可以使用相同的功能。如果您刚刚开始迁移工作负载，后者尤其有趣。</p><h1 id="7107" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">与服务对话</h1><p id="430f" class="pw-post-body-paragraph ju jv iq jw b jx ls jz ka kb lt kd ke kf lu kh ki kj lv kl km kn lw kp kq kr ij bi translated">您可以通过环境变量或通过<a class="ae kt" href="https://github.com/kubernetes/kubernetes/tree/release-1.2/cluster/addons/dns" rel="noopener ugc nofollow" target="_blank"> DNS </a>来发现集群中的服务并与之对话。后者是一个集群插件，在大多数Kubernetes安装(包括巨型Swarm)中都有OOTB。</p><figure class="mc md me mf gt jr gh gi paragraph-image"><a href="https://www.giantswarm.io/guide-cloud-native-stack?utm_campaign=Blog%20CTA%20Conversion&amp;utm_source=Cloud%20native%20stack%20guide_Blog&amp;utm_medium=Blog%20CTA&amp;utm_term=cloud%20native%20stack%20guide"><div class="gh gi mb"><img src="../Images/07afe8e3b2d49509a8dcf7a8238cefc0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*HaP3em9DgrpEJ9sz.jpg"/></div></a></figure><p id="c3f7" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果您希望使用另一种类型的服务发现，并且不希望该服务提供负载平衡和单一服务IP，可以选择创建一个所谓的“headless”服务。如果您已经在使用服务发现或者想要减少与Kubernetes系统的耦合，那么您可以使用这个。</p><h1 id="a2a2" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">开始</h1><p id="8b71" class="pw-post-body-paragraph ju jv iq jw b jx ls jz ka kb lt kd ke kf lu kh ki kj lv kl km kn lw kp kq kr ij bi translated">现在你对服务的概念有了更多的了解，你应该在官方文档<a class="ae kt" href="http://kubernetes.io/docs/user-guide/services/" rel="noopener ugc nofollow" target="_blank">中仔细阅读它们的用法。然后继续构建一些通过服务相互对话的</a><a class="ae kt" href="https://blog.giantswarm.io/understanding-basic-kubernetes-concepts-using-deployments-manage-services-declaratively/" rel="noopener ugc nofollow" target="_blank">部署</a>。</p><p id="e17b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">提示:如果您有一个服务和一个部署，您通常应该先启动服务，然后再启动部署。您甚至可以通过将两个清单包含在一个YAML文件中，用一个命令来部署它们。你只需要用一条包含<code class="fe lx ly lz ma b">---</code>的线把它们分开。Kubernetes将一个接一个地创建它们。</p><p id="cb0a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">由<a class="ae kt" href="https://twitter.com/puja108" rel="noopener ugc nofollow" target="_blank"> Puja Abbassi </a> : <strong class="jw ir"> </strong>开发者拥护者@ <a class="ae kt" href="https://twitter.com/giantswarm" rel="noopener ugc nofollow" target="_blank">巨型虫群</a>撰写</p></div></div>    
</body>
</html>