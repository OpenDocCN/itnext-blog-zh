<html>
<head>
<title>The maze of Python dependency management</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python依赖管理的迷宫</h1>
<blockquote>原文：<a href="https://itnext.io/maze-python-dependency-management-c30fe1fd2c44?source=collection_archive---------4-----------------------#2022-09-14">https://itnext.io/maze-python-dependency-management-c30fe1fd2c44?source=collection_archive---------4-----------------------#2022-09-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/8b7608ff1177eff0f780a89f3a717f85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RaYICyJsJ6l19J_IaJ0MWg.jpeg"/></div></div></figure><p id="e8d2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">20多年来，我一直为JVM开发代码，首先用Java，然后用Kotlin。然而，JVM不是银弹，<em class="kw">，例如</em>，在脚本中:</p><ol class=""><li id="5c1b" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv lc ld le lf bi translated">虚拟机会产生额外的内存需求</li><li id="6776" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">在许多情况下，脚本运行的时间不够长，无法从性能方面获得任何好处。字节码被解释，永远不会编译成本机代码。</li></ol><p id="f226" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于这些原因，我现在用Python写我的脚本。其中一个从不同来源收集社交媒体指标，并将其存储在BigQuery中进行分析。</p><p id="d9db" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我不是Python开发人员，但我正在学习——艰难地学习。在这篇文章中，我想解释一下Python中的依赖管理。</p><h1 id="5651" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">Python中足够的依赖管理</h1><p id="b60b" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">在JVM上，依赖性管理似乎是一个已经解决的问题。首先，选择您的构建工具，最好是Maven或我不知道名字的替代工具。然后，你声明你的<em class="kw">直接</em>依赖，工具管理间接依赖。这并不意味着没有问题，但你可以或多或少地快速解决它们。</p><p id="ecf9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Python依赖管理是一个完全不同的世界。首先，在Python中，运行时及其依赖项是系统范围的。一个系统只有一个运行时，依赖关系在这个系统的所有项目中共享。因为不可行，所以开始一个新项目首先要做的就是创建一个虚拟环境。</p><blockquote class="mo mp mq"><p id="50c6" class="jy jz kw ka b kb kc kd ke kf kg kh ki mr kk kl km ms ko kp kq mt ks kt ku kv ij bi translated"><em class="iq">这个问题的解决方案是创建一个虚拟环境，一个自包含的目录树，其中包含特定版本Python的Python安装，以及许多附加包。</em></p><p id="0881" class="jy jz kw ka b kb kc kd ke kf kg kh ki mr kk kl km ms ko kp kq mt ks kt ku kv ij bi translated"><em class="iq">不同的应用可以使用不同的虚拟环境。为了解决前面的需求冲突示例，应用程序A可以拥有自己的安装了1.0版的虚拟环境，而应用程序B拥有另一个2.0版的虚拟环境。如果应用程序B需要将库升级到版本3.0，这不会影响应用程序A的环境。</em></p><p id="0494" class="jy jz kw ka b kb kc kd ke kf kg kh ki mr kk kl km ms ko kp kq mt ks kt ku kv ij bi translated"><em class="iq"> — </em> <a class="ae mu" href="https://docs.python.org/3/tutorial/venv.html" rel="noopener ugc nofollow" target="_blank"> <em class="iq">虚拟环境和包</em> </a></p></blockquote><p id="c912" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一旦做到这一点，事情开始认真。</p><p id="354b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Python提供了一个名为<code class="fe mv mw mx my b">pip</code>的现成依赖管理工具:</p><blockquote class="mo mp mq"><p id="14ac" class="jy jz kw ka b kb kc kd ke kf kg kh ki mr kk kl km ms ko kp kq mt ks kt ku kv ij bi translated"><em class="iq">您可以使用名为pip的程序安装、升级和删除软件包。</em></p><p id="a8c8" class="jy jz kw ka b kb kc kd ke kf kg kh ki mr kk kl km ms ko kp kq mt ks kt ku kv ij bi translated"><em class="iq"> — </em> <a class="ae mu" href="https://docs.python.org/3/tutorial/venv.html#managing-packages-with-pip" rel="noopener ugc nofollow" target="_blank"> <em class="iq">用pip </em> </a>管理包</p></blockquote><p id="89b4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">工作流程如下:</p><ul class=""><li id="2fa9" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv mz ld le lf bi translated">用户在虚拟环境中安装所需的依赖关系:</li></ul><p id="b484" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mv mw mx my b">pip install flask</code></p><ul class=""><li id="9d5e" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv mz ld le lf bi translated">安装完所有需要的依赖项后，按照惯例，将它们保存在一个名为<code class="fe mv mw mx my b">requirements.txt</code>的文件中:</li></ul><p id="8770" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mv mw mx my b">pip freeze &gt; requirements.txt</code></p><p id="ee01" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该文件应与常规代码一起保存在个人的VCS中。</p><ul class=""><li id="f0cf" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv mz ld le lf bi translated">其他项目开发人员可以通过将<code class="fe mv mw mx my b">pip</code>指向<code class="fe mv mw mx my b">requirements.txt</code>来安装相同的依赖项:</li></ul><p id="603d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mv mw mx my b">pip install -r requirements.txt</code></p><p id="c77b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面是上述命令产生的<code class="fe mv mw mx my b">requirements.txt</code>:</p><pre class="na nb nc nd gt ne my nf ng aw nh bi"><span id="b7c3" class="ni lm iq my b gy nj nk l nl nm">click==8.1.3<br/>Flask==2.2.2<br/>itsdangerous==2.1.2<br/>Jinja2==3.1.2<br/>MarkupSafe==2.1.1<br/>Werkzeug==2.2.2</span></pre><h1 id="40c4" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">依赖性和传递依赖性</h1><p id="ad4d" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">在描述这个问题之前，我们需要解释什么是<em class="kw">传递</em>依赖。可传递依赖项是项目不直接需要的依赖项，而是项目的一个依赖项，或者一个依赖项的依赖项，一直到下面。在上面的例子中，我添加了<code class="fe mv mw mx my b">flask</code>依赖项，但是<code class="fe mv mw mx my b">pip</code>总共安装了6个依赖项。</p><p id="b343" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以安装<code class="fe mv mw mx my b">deptree</code>依赖来检查依赖树。</p><pre class="na nb nc nd gt ne my nf ng aw nh bi"><span id="2ba2" class="ni lm iq my b gy nj nk l nl nm">pip install deptree<br/>deptree</span></pre><p id="a94d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">输出如下所示:</p><pre class="na nb nc nd gt ne my nf ng aw nh bi"><span id="6779" class="ni lm iq my b gy nj nk l nl nm">Flask==2.2.2  # flask<br/>  Werkzeug==2.2.2  # Werkzeug&gt;=2.2.2<br/>    MarkupSafe==2.1.1  # MarkupSafe&gt;=2.1.1<br/>  Jinja2==3.1.2  # Jinja2&gt;=3.0<br/>    MarkupSafe==2.1.1  # MarkupSafe&gt;=2.0<br/>  itsdangerous==2.1.2  # itsdangerous&gt;=2.0<br/>  click==8.1.3  # click&gt;=8.0<br/># deptree and pip trees</span></pre><p id="dcd7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">内容如下:<code class="fe mv mw mx my b">Flask</code>需要<code class="fe mv mw mx my b">Werkzeug</code>，而<code class="fe mv mw mx my b">Werkzeug</code>又需要<code class="fe mv mw mx my b">MarkupSafe</code>。<code class="fe mv mw mx my b">Werkzeug</code>和<code class="fe mv mw mx my b">MarkupSafe</code>符合我的项目的可传递依赖关系。</p><p id="9177" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">版本部分也很有趣。第一部分提到已安装的版本，而注释部分指的是兼容的版本范围。比如<code class="fe mv mw mx my b">Jinja</code>需要版本<code class="fe mv mw mx my b">3.0</code>或以上，安装的版本是<code class="fe mv mw mx my b">3.1.2</code>。</p><p id="cf99" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">安装的版本是<code class="fe mv mw mx my b">pip</code>在安装时找到的与<em class="kw">兼容的最新</em>版本。<code class="fe mv mw mx my b">pip</code>和<code class="fe mv mw mx my b">deptree</code>了解分布在各库的<code class="fe mv mw mx my b">setup.py</code>文件中的兼容性:</p><blockquote class="mo mp mq"><p id="bcf4" class="jy jz kw ka b kb kc kd ke kf kg kh ki mr kk kl km ms ko kp kq mt ks kt ku kv ij bi translated">安装脚本是使用分发工具构建、分发和安装模块的所有活动的中心。安装脚本的主要目的是向Distutils描述您的模块分布，以便对您的模块进行操作的各种命令做正确的事情。</p><p id="dc7e" class="jy jz kw ka b kb kc kd ke kf kg kh ki mr kk kl km ms ko kp kq mt ks kt ku kv ij bi translated"><em class="iq"> — </em> <a class="ae mu" href="https://docs.python.org/3/distutils/setupscript.html" rel="noopener ugc nofollow" target="_blank"> <em class="iq">编写设置脚本</em> </a></p></blockquote><p id="c708" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里是烧瓶:</p><pre class="na nb nc nd gt ne my nf ng aw nh bi"><span id="d0c5" class="ni lm iq my b gy nj nk l nl nm">from setuptools import setup</span><span id="7094" class="ni lm iq my b gy nn nk l nl nm">setup(<br/>    name="Flask",<br/>    install_requires=[<br/>        "Werkzeug &gt;= 2.2.2",<br/>        "Jinja2 &gt;= 3.0",<br/>        "itsdangerous &gt;= 2.0",<br/>        "click &gt;= 8.0",<br/>        "importlib-metadata &gt;= 3.6.0; python_version &lt; '3.10'",<br/>    ],<br/>    extras_require={<br/>        "async": ["asgiref &gt;= 3.2"],<br/>        "dotenv": ["python-dotenv"],<br/>    },<br/>)</span></pre><h1 id="7941" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">Pip和传递依赖</h1><p id="290c" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">出现这个问题是因为我希望我的依赖项是最新的。为此，我已经配置了Dependabot来监视<code class="fe mv mw mx my b">requirements.txt</code>中列出的新版本的依赖项。当此类事件发生时，它会在我的回购中打开一个PR。大多数时候，PR工作得非常好，但是在少数情况下，当我在合并后运行脚本时会出现错误。它看起来像下面这样:</p><pre class="na nb nc nd gt ne my nf ng aw nh bi"><span id="c214" class="ni lm iq my b gy nj nk l nl nm">ERROR: libfoo 1.0.0 has requirement libbar&lt;2.5,&gt;=2.0, but you'll have libbar 2.5 which is incompatible.</span></pre><p id="1121" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">问题是，Dependabot为每个列出的库打开一个PR。但是可以发布新的库版本，这不在兼容范围之内。</p><p id="d8b9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">想象一下下面的情况。我的项目需要<code class="fe mv mw mx my b">libfoo</code>依赖项。反过来，<code class="fe mv mw mx my b">libfoo</code>需要<code class="fe mv mw mx my b">libbar</code>的依赖。安装时，<code class="fe mv mw mx my b">pip</code>使用最新版本的<code class="fe mv mw mx my b">libfoo</code>和最新的<em class="kw">兼容</em>版本的<code class="fe mv mw mx my b">libbar</code>。由此产生的<code class="fe mv mw mx my b">requirements.txt</code>是:</p><pre class="na nb nc nd gt ne my nf ng aw nh bi"><span id="5085" class="ni lm iq my b gy nj nk l nl nm">libfoo==1.0.0<br/>libbar==2.0</span></pre><p id="0c54" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一切按预期运行。过了一会儿，Dependabot运行后发现<code class="fe mv mw mx my b">libbar</code>发布了新版本<em class="kw">，例如</em>、<code class="fe mv mw mx my b">2.5</code>。忠实地，它打开一个PR来合并以下变更:</p><pre class="na nb nc nd gt ne my nf ng aw nh bi"><span id="9e95" class="ni lm iq my b gy nj nk l nl nm">libfoo==1.0.0<br/>libbar==2.5</span></pre><p id="8ebf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上述问题是否出现完全取决于<code class="fe mv mw mx my b">libfoo 1.0.0</code>如何在<code class="fe mv mw mx my b">setup.py</code>中指定其依赖关系。如果<code class="fe mv mw mx my b">2.5</code>在兼容范围内，则工作；如果没有，就不会。</p><h1 id="24ca" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated"><code class="fe mv mw mx my b">pip-compile</code>去救援</h1><p id="37d8" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated"><code class="fe mv mw mx my b">pip</code>的问题在于它列出了传递依赖和直接依赖。Dependabot然后获取所有依赖项的最新版本，但不验证可传递依赖项版本更新是否在该范围内。它可能会检查，但是<code class="fe mv mw mx my b">requirements.txt</code>文件格式不是结构化的:它不区分直接依赖和传递依赖。显而易见的解决方案是只列出直接依赖关系。</p><p id="73be" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好消息是<code class="fe mv mw mx my b">pip</code>只允许列出直接依赖关系；它会自动安装<a class="ae mu" href="https://disjoint.ca/til/2016/03/18/pip-and-transitive-dependencies/" rel="noopener ugc nofollow" target="_blank">传递依赖关系</a>。坏消息是，我们现在有两个<code class="fe mv mw mx my b">requirements.txt</code>选项，无法区分它们:一些选项只列出直接依赖项，另一些选项列出所有依赖项。</p><p id="0ec5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这需要一个替代方案。<a class="ae mu" href="https://github.com/jazzband/pip-tools" rel="noopener ugc nofollow" target="_blank"> pip-tools </a>有一个:</p><ol class=""><li id="9a24" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv lc ld le lf bi translated">其中一个在一个<code class="fe mv mw mx my b">requirements.in</code>文件中列出了它们的直接依赖关系，该文件的格式与<code class="fe mv mw mx my b">requirements.txt</code>相同</li><li id="cc44" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated"><code class="fe mv mw mx my b">pip-compile</code>工具从<code class="fe mv mw mx my b">requirements.in</code>中生成一个<code class="fe mv mw mx my b">requirements.txt</code>。</li></ol><p id="ef12" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，以我们的烧瓶为例:</p><pre class="na nb nc nd gt ne my nf ng aw nh bi"><span id="52ff" class="ni lm iq my b gy nj nk l nl nm">Flask==2.2.2</span><span id="bc2e" class="ni lm iq my b gy nn nk l nl nm">pip-compile</span><span id="b537" class="ni lm iq my b gy nn nk l nl nm">#<br/># This file is autogenerated by pip-compile with python 3.10<br/># To update, run:<br/>#<br/>#    pip-compile requirements.in<br/>#<br/>click==8.1.3<br/>    # via flask<br/>flask==2.2.2<br/>    # via -r requirements.in<br/>itsdangerous==2.1.2<br/>    # via flask<br/>jinja2==3.1.2<br/>    # via flask<br/>markupsafe==2.1.1<br/>    # via<br/>    #   jinja2<br/>    #   werkzeug<br/>werkzeug==2.2.2<br/>    # via flask</span><span id="0605" class="ni lm iq my b gy nn nk l nl nm">pip install -r requirements.txt</span></pre><p id="ce08" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它有以下好处和后果:</p><ul class=""><li id="aff9" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv mz ld le lf bi translated">生成的<code class="fe mv mw mx my b">requirements.txt</code>包含理解依赖树的注释</li><li id="689f" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv mz ld le lf bi translated">由于<code class="fe mv mw mx my b">pip-compile</code>生成文件，你不应该把它保存在VCS中</li><li id="58e3" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv mz ld le lf bi translated">该项目与依赖于<code class="fe mv mw mx my b">requirements.txt</code>的遗留工具兼容</li><li id="1c6b" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv mz ld le lf bi translated">最后但同样重要的是，它改变了安装工作流程。不是安装软件包然后保存它们，而是首先列出软件包然后安装它们。</li></ul><p id="b62d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">而且，Dependabot可以管理<code class="fe mv mw mx my b">pip-compile</code>的依赖版本升级。</p><h1 id="8acc" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">结论</h1><p id="d37f" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">这篇文章描述了默认的Python依赖管理系统，以及它是如何破坏自动版本升级的。我们继续描述解决问题的<code class="fe mv mw mx my b">pip-compile</code>替代方案。</p><p id="433e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意，Python有一个依赖管理规范，<a class="ae mu" href="https://peps.python.org/pep-0621/" rel="noopener ugc nofollow" target="_blank">PEP 621——将项目元数据存储在pyproject.toml </a>中。它类似于Maven的POM，只是格式不同。这对于我的脚本来说是多余的，因为我不需要分发这个项目。但是要做的话，知道<code class="fe mv mw mx my b">pip-compile</code>是兼容它的。</p><p id="969e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">更进一步:</strong></p><ul class=""><li id="68ef" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv mz ld le lf bi translated"><a class="ae mu" href="https://docs.python.org/3/tutorial/venv.html" rel="noopener ugc nofollow" target="_blank">虚拟环境和包</a></li><li id="7dae" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv mz ld le lf bi translated"><a class="ae mu" href="https://docs.python.org/3/tutorial/venv.html#managing-packages-with-pip" rel="noopener ugc nofollow" target="_blank">使用pip管理包</a></li><li id="8f53" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv mz ld le lf bi translated"><a class="ae mu" href="https://github.com/jazzband/pip-tools" rel="noopener ugc nofollow" target="_blank">画中画工具</a></li><li id="da58" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv mz ld le lf bi translated"><a class="ae mu" href="https://peps.python.org/pep-0621/" rel="noopener ugc nofollow" target="_blank"> PEP 621 —在pyproject.toml中存储项目元数据</a></li></ul></div><div class="ab cl no np hu nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="ij ik il im in"><p id="463c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kw">原载于</em> <a class="ae mu" href="https://blog.frankel.ch/maze-python-dependency-management/" rel="noopener ugc nofollow" target="_blank"> <em class="kw">一个Java极客</em></a><em class="kw">2022年9月11日</em></p></div></div>    
</body>
</html>