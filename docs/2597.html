<html>
<head>
<title>What the heck is this in React ? 🥁🥁(Suspense) 🥁🥁</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">这到底是在反应什么？🥁🥁(Suspense) 🥁🥁</h1>
<blockquote>原文：<a href="https://itnext.io/what-the-heck-is-this-in-react-suspense-c5e641e487a?source=collection_archive---------0-----------------------#2019-06-21">https://itnext.io/what-the-heck-is-this-in-react-suspense-c5e641e487a?source=collection_archive---------0-----------------------#2019-06-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="18bb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">暂停代码分割和数据获取。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/adbaef074fd6517e0dcabf4b0c78f799.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1yD1jhrSV5Kmd7Ee4OMxPg.jpeg"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">诺德伍德主题公司在<a class="ae lb" href="https://unsplash.com/search/photos/slow-loading?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="64da" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在2018年冰岛JSConf期间，<a class="ae lb" href="https://twitter.com/dan_abramov" rel="noopener ugc nofollow" target="_blank">丹·阿布拉莫夫</a>推出了React 16发布后的全新概念。在谈论资源加载时，他展示了一个<em class="lc">占位符</em>组件，呈现一个加载器。到现在一年了，这个组件已经演变成了<strong class="jp ir"> <em class="lc">悬疑</em> </strong>。</p><p id="305c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="lc">悬念</em>在React 16.6中已经发布，但仅针对代码拆分。让我们看看今天如何使用它，以及未来有哪些悬念。</p><h1 id="6e63" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">TL；速度三角形定位法(dead reckoning)</h1><ol class=""><li id="66eb" class="mb mc iq jp b jq md ju me jy mf kc mg kg mh kk mi mj mk ml bi translated"><a class="ae lb" href="#7e67" rel="noopener ugc nofollow"> <em class="lc">暂停</em> </a>暂停你的组件渲染，渲染一个回退组件，直到满足一个条件。例如，它可以在等待资源时呈现加载程序，</li><li id="613b" class="mb mc iq jp b jq mm ju mn jy mo kc mp kg mq kk mi mj mk ml bi translated"><a class="ae lb" href="#4b8b" rel="noopener ugc nofollow">现在- <em class="lc">暂挂</em>进行代码拆分</a>:使用React.lazy +动态导入</li><li id="fb11" class="mb mc iq jp b jq mm ju mn jy mo kc mp kg mq kk mi mj mk ml bi translated"><a class="ae lb" href="#ad68" rel="noopener ugc nofollow">未来- <em class="lc">暂挂</em>获取数据</a>:你的组件抛出一个承诺，被<em class="lc">暂挂抓住，</em>等待它解决。等待时，<em class="lc">暂停</em>渲染一个回退组件。然后你的组件再次被渲染。</li></ol></div><div class="ab cl mr ms hu mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ij ik il im in"><h1 id="7e67" class="ld le iq bd lf lg my li lj lk mz lm ln lo na lq lr ls nb lu lv lw nc ly lz ma bi translated">1.悬念是什么？</h1><p id="ac6e" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy nd ka kb kc ne ke kf kg nf ki kj kk ij bi translated">反应<em class="lc">暂停</em>允许你暂停组件渲染，直到满足一个条件。等待时，会呈现回退组件。基本上有两个主要的使用案例:</p><ul class=""><li id="6264" class="mb mc iq jp b jq jr ju jv jy ng kc nh kg ni kk nj mj mk ml bi translated">代码分割:条件是当用户想要访问你的应用程序时，下载它的一部分，</li><li id="da57" class="mb mc iq jp b jq mm ju mn jy mo kc mp kg mq kk nj mj mk ml bi translated">数据抓取:条件是数据的下载。</li></ul><p id="27c0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这两种情况下，后备组件很可能是加载程序。</p><p id="09ae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要实现这一点，您需要用<em class="lc">暂停</em>组件包装您将要暂停的组件。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nk nl l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">悬念用法示例</figcaption></figure><p id="2ad6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上面的例子中，可以暂停<em class="lc">口袋妖怪列表</em>组件渲染，等待口袋妖怪列表。在暂停期间，渲染一个<em class="lc">加载</em>组件。</p><p id="6f52" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">加载程序不会立即呈现。为了获得更好的用户体验，React在渲染回退之前会增加100毫秒的延迟。当资源很少或网络很快时，这避免了闪烁，在加载程序之后立即呈现真正的组件。</p><p id="f01d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们来看看如何用<em class="lc">悬念</em>进行代码拆分和数据取数。</p><h1 id="4b8b" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">2.代码拆分的当前悬念</h1><p id="b0da" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy nd ka kb kc ne ke kf kg nf ki kj kk ij bi translated"><strong class="jp ir">什么是代码分割？</strong></p><p id="6fbe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">代码分割是一种通过创建多个块而不是一个大的唯一块来减少javascript包大小的技术。</p><p id="2b1f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一种方法是使用打包器，如<a class="ae lb" href="https://webpack.js.org/" rel="noopener ugc nofollow" target="_blank"> Webpack </a>或<a class="ae lb" href="https://parceljs.org/" rel="noopener ugc nofollow" target="_blank"> Parcel </a>，它们会根据<a class="ae lb" href="https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Instructions/import#Imports_dynamiques" rel="noopener ugc nofollow" target="_blank">动态导入</a>的用法自动将包分成块。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nk nl l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">动态导入示例</figcaption></figure><p id="fa15" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上面的例子中，捆绑器将创建一个块，包含<em class="lc"> PokemonList </em>代码(及其导入的依赖项)。在运行时，它将下载块，并返回一个承诺。这个承诺解决口袋妖怪列表组件，这是默认的出口。</p><p id="3193" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">如何利用悬念展示一个装载机？</strong></p><p id="8a8e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">React附带了对惰性组件的支持。<em class="lc"> React.lazy </em>允许您像使用静态导入组件一样使用动态组件，而不是处理动态导入承诺。</p><p id="b678" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们看一些代码。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nk nl l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">代码拆分示例的暂记</figcaption></figure><p id="dc65" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="lc"> React.lazy </em>采用一个将执行动态导入的函数。它返回一个组件，该组件将在第一次呈现时运行该函数。得到的承诺状态被<em class="lc">暂记</em>使用</p><ul class=""><li id="c059" class="mb mc iq jp b jq jr ju jv jy ng kc nh kg ni kk nj mj mk ml bi translated">在块下载期间呈现回退(待定承诺)</li><li id="9f37" class="mb mc iq jp b jq mm ju mn jy mo kc mp kg mq kk nj mj mk ml bi translated">下载后渲染真实的<em class="lc">口袋妖怪列表</em>组件(解决承诺)</li></ul><p id="fc3c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以看到使用<em class="lc">悬念</em>和<em class="lc"> React.lazy </em>进行代码拆分的真正好处。代码在异步时感觉是同步的，我们不必编写大量样板文件来管理动态导入承诺及其组件使用。</p><p id="7b00" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这代表了<em class="lc">悬念</em>的稳定部分。但是它并不局限于代码分割。React核心团队正在使用<em class="lc">悬念</em>获取数据。让我们看看它可能是什么样子。</p><h1 id="ad68" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">3.数据获取的未来悬念</h1><p id="4183" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy nd ka kb kc ne ke kf kg nf ki kj kk ij bi translated"><em class="lc">请记住，数据提取的悬念仍在开发中，api可能会改变。</em></p><h2 id="578b" class="nm le iq bd lf nn no dn lj np nq dp ln jy nr ns lr kc nt nu lv kg nv nw lz nx bi translated"><strong class="ak">无<em class="ny">暂停</em> </strong>的数据提取加载器</h2><p id="e72a" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy nd ka kb kc ne ke kf kg nf ki kj kk ij bi translated">让我们看一个没有<em class="lc">悬念</em>如何处理数据获取加载器的例子。要做到这一点，让我们更深入地了解我们的<em class="lc">口袋妖怪列表</em>组件。我们需要</p><ol class=""><li id="d585" class="mb mc iq jp b jq jr ju jv jy ng kc nh kg ni kk mi mj mk ml bi translated">启动<em class="lc"> isLoading </em>状态，告知正在获取数据，</li><li id="4b34" class="mb mc iq jp b jq mm ju mn jy mo kc mp kg mq kk mi mj mk ml bi translated">从缓存中读取数据，如果不存在，我们将获取它，相应地设置<em class="lc">正在加载</em>状态，</li><li id="7b15" class="mb mc iq jp b jq mm ju mn jy mo kc mp kg mq kk mi mj mk ml bi translated">根据<em class="lc">正在加载</em>状态，渲染<em class="lc">加载</em>或<em class="lc">列表</em>组件。</li></ol><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nk nl l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">PokemonList组件在获取数据时处理加载渲染</figcaption></figure><p id="6408" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里是一个简单的口袋妖怪服务的实现。没什么复杂的，<em class="lc"> get() </em>函数获取数据，并设置缓存值，这是通过<em class="lc"> readCache() </em>函数公开的。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nk nl l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">PokemonService简单实现</figcaption></figure><p id="da62" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们已经可以在我们的组件中处理loader，那么为什么我们将来还要使用<em class="lc">悬念</em>？</p><h2 id="14d1" class="nm le iq bd lf nn no dn lj np nq dp ln jy nr ns lr kc nt nu lv kg nv nw lz nx bi translated"><strong class="ak">带<em class="ny">暂挂</em> </strong>的数据提取加载器</h2><p id="3f5f" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy nd ka kb kc ne ke kf kg nf ki kj kk ij bi translated">让我们看看如何在<em class="lc">悬念</em>中实现同样的行为。我们将从缓存中读取数据。但是如果它不在缓存中，我们就抛出一个获取数据的承诺。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nk nl l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">如果缓存为空，则从缓存中读取会抛出一个承诺</figcaption></figure><p id="23d6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">只要记住<em class="lc">悬念</em>是我们的组件祖先之一</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nk nl l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">笼罩在悬念中的口袋妖怪</figcaption></figure><p id="e0b5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="lc">悬念</em>使用<a class="ae lb" href="https://reactjs.org/docs/error-boundaries.html" rel="noopener ugc nofollow" target="_blank">反应错误边界</a>捕捉抛出的承诺，并为我们设置一个加载状态，渲染回退组件(<em class="lc">加载</em>)。当它被解析后，<em class="lc">口袋妖怪列表</em>组件会被再次渲染。</p><p id="b5b5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以在<em class="lc">口袋妖怪列表</em>代码中看到好处。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="0d84" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不再有<em class="lc">加载</em>状态来初始化和设置，不再有<em class="lc">使用Effect </em>来获取数据，代码只是感觉同步。<em class="lc">悬念</em>处理所有异步状态，协调组件渲染。</p><p id="6147" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让它工作的最后一步，我们需要改变呈现React应用程序的方式，以支持异步功能。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nk nl l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">使用异步功能进行反应渲染</figcaption></figure><p id="40a1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">做出捡球的承诺看起来很奇怪。如果它困扰你，React核心团队正在研究<a class="ae lb" href="https://github.com/facebook/react/tree/master/packages/react-cache" rel="noopener ugc nofollow" target="_blank"> React-cache </a>来管理资源。</p><h2 id="6494" class="nm le iq bd lf nn no dn lj np nq dp ln jy nr ns lr kc nt nu lv kg nv nw lz nx bi translated">通过暂停和反应缓存获取数据</h2><p id="6702" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy nd ka kb kc ne ke kf kg nf ki kj kk ij bi translated"><em class="lc">请记住，react-cache仍在开发中，lib不稳定，api会发生变化。</em></p><p id="6a68" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="lc"> React-cache </em>允许你创建与悬念兼容的资源用于数据获取。让我们看看如何用<em class="lc"> react-cache </em>实现我们的<em class="lc"> PokemonService </em>。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nk nl l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">使用react-cache的口袋妖怪服务</figcaption></figure><p id="8dbc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们调整我们的<em class="lc"> PokemonList </em>组件来适应这个新的服务api。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nk nl l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">使用新口袋妖怪服务的口袋妖怪列表</figcaption></figure><p id="84a8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在引擎盖下，<em class="lc"> react-cache </em>将做我们的旧服务正在做的事情</p><ol class=""><li id="fd0c" class="mb mc iq jp b jq jr ju jv jy ng kc nh kg ni kk mi mj mk ml bi translated">从缓存中返回数据，</li><li id="5986" class="mb mc iq jp b jq mm ju mn jy mo kc mp kg mq kk mi mj mk ml bi translated">如果缓存不包含数据，它将抛出我们在创建资源时设置的获取承诺，</li><li id="3c99" class="mb mc iq jp b jq mm ju mn jy mo kc mp kg mq kk mi mj mk ml bi translated"><em class="lc">悬疑</em>会抓住它，处理加载器渲染。</li></ol></div><div class="ab cl mr ms hu mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ij ik il im in"><h1 id="c3fa" class="ld le iq bd lf lg my li lj lk mz lm ln lo na lq lr ls nb lu lv lw nc ly lz ma bi translated">结论</h1><p id="55f4" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy nd ka kb kc ne ke kf kg nf ki kj kk ij bi translated"><em class="lc">悬念</em>帮助我们协调异步资源与我们的加载器组件渲染。我们已经可以用它来进行代码分割了。</p><p id="e94e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当数据获取的<em class="lc">悬念</em>稳定后，我们将能够<strong class="jp ir">专注于我们的业务特性</strong>。<em class="lc">悬念</em>会替我们做，而不是一边取数据一边写重复的加载器代码。</p><h1 id="61a5" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">谢谢你</h1><p id="708a" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy nd ka kb kc ne ke kf kg nf ki kj kk ij bi translated">非常感谢<a class="ae lb" href="https://www.linkedin.com/in/andreas-nilsson333/" rel="noopener ugc nofollow" target="_blank">安德烈亚斯·尼尔森</a>、<a class="ae lb" href="https://twitter.com/frassinier" rel="noopener ugc nofollow" target="_blank">杨奇煜·拉西尼耶</a>、<a class="ae lb" href="https://twitter.com/romainseb" rel="noopener ugc nofollow" target="_blank">塞巴斯蒂安·罗曼</a>和<a class="ae lb" href="https://www.linkedin.com/in/sebastienlemouillour/" rel="noopener ugc nofollow" target="_blank">塞巴斯蒂安·勒·穆伊尔</a>的校对！</p><h1 id="0e5b" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">参考</h1><ul class=""><li id="4c79" class="mb mc iq jp b jq md ju me jy mf kc mg kg mh kk nj mj mk ml bi translated"><a class="ae lb" href="https://www.youtube.com/watch?v=nLF0n9SACd4" rel="noopener ugc nofollow" target="_blank">丹·阿布拉莫夫在JSConf冰岛2018上的演讲</a></li><li id="aa26" class="mb mc iq jp b jq mm ju mn jy mo kc mp kg mq kk nj mj mk ml bi translated">杰瑞米·华格纳和艾迪·奥斯马尼的代码分解</li><li id="8444" class="mb mc iq jp b jq mm ju mn jy mo kc mp kg mq kk nj mj mk ml bi translated"><a class="ae lb" href="https://reactjs.org/docs/code-splitting.html" rel="noopener ugc nofollow" target="_blank"> React代码拆分文档</a></li><li id="3f45" class="mb mc iq jp b jq mm ju mn jy mo kc mp kg mq kk nj mj mk ml bi translated"><a class="ae lb" href="https://reactjs.org/docs/error-boundaries.html" rel="noopener ugc nofollow" target="_blank"> React错误边界文档</a></li><li id="9096" class="mb mc iq jp b jq mm ju mn jy mo kc mp kg mq kk nj mj mk ml bi translated"><a class="ae lb" href="https://github.com/bvaughn/react/blob/a4603a04ab423d7a11f6c7cc1165fc1b03157e7e/packages/react-cache/src/ReactCache.js#L142" rel="noopener ugc nofollow" target="_blank">React-cache # create _ resource实现</a></li><li id="0af9" class="mb mc iq jp b jq mm ju mn jy mo kc mp kg mq kk nj mj mk ml bi translated"><a class="ae lb" href="https://github.com/jsomsanith/demo-suspense" rel="noopener ugc nofollow" target="_blank">我的github存储库上的悬念示例</a></li></ul><h1 id="6e92" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">关于我</h1><p id="bf0d" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy nd ka kb kc ne ke kf kg nf ki kj kk ij bi translated">我是前端建筑师@Talend。我参与的是<a class="ae lb" href="https://github.com/storybookjs/storybook" rel="noopener ugc nofollow" target="_blank">故事书</a>，是<a class="ae lb" href="https://github.com/storybookjs/storybook/tree/next/addons/a11y" rel="noopener ugc nofollow" target="_blank"> a11y插件</a>，是<a class="ae lb" href="https://github.com/storybookjs/design-system" rel="noopener ugc nofollow" target="_blank">设计系统</a>。</p><p id="448a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在Twitter<a class="ae lb" href="https://twitter.com/jsomsanith" rel="noopener ugc nofollow" target="_blank">上关注我</a>以获得关于React和可访问性的未来文章的通知:</p><ul class=""><li id="32d9" class="mb mc iq jp b jq jr ju jv jy ng kc nh kg ni kk nj mj mk ml bi translated"><a class="ae lb" href="https://medium.com/@jimmy.somsanith/form-accessibility-a-practical-guide-4062b7e2dd14" rel="noopener">表单可访问性:实用指南</a></li></ul></div></div>    
</body>
</html>