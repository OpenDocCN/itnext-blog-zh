<html>
<head>
<title>Go Generics vs Java Generics</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Go泛型vs Java泛型</h1>
<blockquote>原文：<a href="https://itnext.io/go-generics-vs-java-generics-48cbf0e0f333?source=collection_archive---------2-----------------------#2022-07-26">https://itnext.io/go-generics-vs-java-generics-48cbf0e0f333?source=collection_archive---------2-----------------------#2022-07-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2a20" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Java和C#人群已经没有理由讨厌围棋了</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7ef7209ba3cfef39dee58bd4531f49a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-ShhxZjzzONtDF9MODGHgg.png"/></div></div></figure><p id="aa78" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi lq translated">Go是一种让人又爱又恨的语言。因为没有泛型而在Go上扣篮几乎就像是全球开发者社区中的一场体育赛事。随着Go generics的推出，讨厌Go的社区将会遇到一点身份危机。缺乏泛型是每个人都可以团结起来的事情。今天，不仅Go有泛型，而且它们的泛型也非常好。事实上，Go泛型在很多方面都比Java和C#中的泛型要好。</p><p id="717a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们用一个在Go中经常用来演示泛型的简单例子来看看为什么。在前泛型时代，我们可能会像这样在Go中编写一个<code class="fe lz ma mb mc b">Sum</code>函数:</p><pre class="kj kk kl km gt md mc me mf aw mg bi"><span id="9328" class="mh mi it mc b gy mj mk l ml mm"><strong class="mc iu">func</strong> Sum(numbers int) int {<br/>    <strong class="mc iu">var</strong> total int<br/>    <strong class="mc iu">for</strong> _, x := <strong class="mc iu">range</strong> numbers {<br/>        total += x<br/>    }<br/>    <strong class="mc iu">return</strong> total<br/>}</span></pre><p id="f831" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个解决方案是有局限性的，因为我们只能对整数求和。如果我们想对浮点数或复数求和呢？以前，我们必须复制代码。今天，我们可以挥舞着魔法棒写下:</p><pre class="kj kk kl km gt md mc me mf aw mg bi"><span id="79f0" class="mh mi it mc b gy mj mk l ml mm"><strong class="mc iu">type</strong> Number <strong class="mc iu">interface</strong> {<br/>    int16 | int32 | int64 | float32| float64<br/>}<br/><br/><strong class="mc iu">func</strong> Sum[T Number](numbers []T) T {<br/>    var total T<br/>    <strong class="mc iu">for</strong> _, x := <strong class="mc iu">range</strong> numbers {<br/>        total += x<br/>    }<br/>    return total<br/>}</span></pre><p id="4d9c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在代码示例中，我们声明任何不同位长的整数或浮点数类型都满足<code class="fe lz ma mb mc b">Number</code>接口。我们可以通过从<a class="ae mn" href="https://pkg.go.dev/golang.org/x/exp/constraints" rel="noopener ugc nofollow" target="_blank">golang.org/x/exp/constraints</a>包中导入现成的接口来更优雅地实现这段代码:</p><pre class="kj kk kl km gt md mc me mf aw mg bi"><span id="e4de" class="mh mi it mc b gy mj mk l ml mm"><strong class="mc iu">import</strong>  "golang.org/x/exp/constraints"<br/><br/><strong class="mc iu">type</strong> Number <strong class="mc iu">interface</strong> {<br/>	Integer | Float<br/>}</span></pre><p id="2c65" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个代码示例是泛型的一个非常简单和明显的用法。不管我使用什么编程语言，使用泛型处理简单的数据类型，比如整数和浮点数，是我的工作。然而，这个明显有用的代码甚至不可能用Java编写:</p><pre class="kj kk kl km gt md mc me mf aw mg bi"><span id="a4f5" class="mh mi it mc b gy mj mk l ml mm">// Won't compile<br/><strong class="mc iu">static</strong> &lt;T extends Number&gt;  T sum(T[] v) {<br/>    T total = 0;<br/>    <strong class="mc iu">for</strong>(int k = 0; k &lt; v.length; k++) {<br/>        total += v[k];<br/>    }<br/>    <strong class="mc iu">return</strong> total;<br/>}</span></pre><p id="272f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在微软发布下一个版本的C#之前，我相信你也不能在C#中做到这一点。Java和C#都把原始类型变成了二等公民，这使得明显有用的代码不可能在没有丑陋的黑客破坏性能的情况下实现。Go代码示例实际上转化为超高效的机器代码:</p><pre class="kj kk kl km gt md mc me mf aw mg bi"><span id="4c5d" class="mh mi it mc b gy mj mk l ml mm">sum:<br/>    MOVD  ZR, R0       // start index at zero<br/>    MOVD  ZR, R3       // zero out total<br/>    JMP	  compare<br/>    <br/>addup:    <br/>    MOVW  (R1)(R0&lt;&lt;2), R4<br/>    ADD	  $1, R0, R0   // increment index<br/>    ADD	  R4, R3, R3   // add to total<br/><br/>compare:    <br/>    CMP   R0, R2       // are we at end of loop<br/>    BGT	  addup        // branch greater than<br/>    MOVD  R3, R0       // put total in return reg<br/>    RET	  (R30)</span></pre><p id="3698" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">汇编代码是ARM64，使用Go构建工具的交叉编译器功能生成。您可以运行这行代码:</p><pre class="kj kk kl km gt md mc me mf aw mg bi"><span id="7da2" class="mh mi it mc b gy mj mk l ml mm">❯ env GOOS=linux GOARCH=arm64 go build -gcflags -S \ <br/>      generic-sum.go 2&gt; generic-sum.S</span></pre><h2 id="e79b" class="mh mi it bd mo mp mq dn mr ms mt dp mu ld mv mw mx lh my mz na ll nb nc nd ne bi translated">Go和Java中的类型擦除</h2><p id="a274" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated">在Java中，编译后不保留类型信息。我们将这一事实称为<em class="nk">型擦除</em>。下面的代码简单演示了Java中类型擦除的后果。你可以看到，尽管<code class="fe lz ma mb mc b">Array&lt;Integer&gt;</code>和<code class="fe lz ma mb mc b">Array&lt;Float&gt;</code>在运行时应该被视为不同的类型，但Java无法做到这一点。班级也一样。</p><pre class="kj kk kl km gt md mc me mf aw mg bi"><span id="3eec" class="mh mi it mc b gy mj mk l ml mm">public <strong class="mc iu">class</strong> Array&lt;T <strong class="mc iu">extends</strong> Number&gt; {<br/>    // ...<br/>};<br/><br/>Array&lt;Integer&gt; integers = new Array&lt;Integer&gt;();<br/>Array&lt;Float&gt; floats = new Array&lt;Float&gt;();<br/><br/>// evaluates to true<br/><strong class="mc iu">if</strong> (integers.getClass() == floats.getClass()) { <br/>    System.out.println("they're equal");<br/>}</span></pre><p id="0a35" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Go型系统没有这个问题。它在运行时正确地将<code class="fe lz ma mb mc b">Array[int64]</code>和<code class="fe lz ma mb mc b">Array[float64]</code>识别为不同的类型。</p><pre class="kj kk kl km gt md mc me mf aw mg bi"><span id="1511" class="mh mi it mc b gy mj mk l ml mm"><strong class="mc iu">type</strong> Number <strong class="mc iu">interface</strong> {<br/>	int | int64 | uint | float32 | float64<br/>}<br/><br/><strong class="mc iu">type</strong> Array[T Number] <strong class="mc iu">struct </strong>{<br/>	elements []T<br/>}<br/><br/><strong class="mc iu">var</strong> integers Array[int64]<br/><strong class="mc iu">var</strong> floats Array[float64]<br/><br/>// Not equal<br/><strong class="mc iu">if</strong> reflect.TypeOf(integers) == reflect.TypeOf(floats) {<br/>	fmt.Printf("they're equal")<br/>}</span></pre><h2 id="e77d" class="mh mi it bd mo mp mq dn mr ms mt dp mu ld mv mw mx lh my mz na ll nb nc nd ne bi translated">但是Go不允许方法中有类型参数！</h2><p id="0285" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated">对Go泛型的一个常见抱怨是，不能向方法添加新的类型参数。我们这样说到底是什么意思？经常提到的一个例子是，试图向集合类中添加<code class="fe lz ma mb mc b">Map</code>、<code class="fe lz ma mb mc b">Filter</code>和<code class="fe lz ma mb mc b">Reduce</code>方法。</p><p id="d73c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一种幼稚的尝试是将这些函数作为方法添加到自定义集合类型中。下面是这种方法的一个例子。</p><pre class="kj kk kl km gt md mc me mf aw mg bi"><span id="4007" class="mh mi it mc b gy mj mk l ml mm"><strong class="mc iu">package</strong> main<br/><br/><strong class="mc iu">import</strong> "fmt"<br/><br/><strong class="mc iu">type</strong> Array[V any] <strong class="mc iu">struct</strong> {<br/>	elements []V<br/>}<br/><br/><strong class="mc iu">type</strong> Reducer[T, V any] <strong class="mc iu">func</strong>(accum T, value V) T<br/><br/><strong class="mc iu">func</strong> (xs Array[V]) Reduce[T any](f Reducer[T, V]) T {<br/>	<strong class="mc iu">var</strong> accum T<br/>	<strong class="mc iu">for</strong> _, x := <strong class="mc iu">range</strong> xs.elements {<br/>		accum = f(accum, x)<br/>	}<br/>	<strong class="mc iu">return</strong> accum<br/>}<br/><br/><strong class="mc iu">func</strong> adder(accum, x int) int {<br/>	<strong class="mc iu">return</strong> accum + x<br/>}<br/><br/><strong class="mc iu">func</strong> main() {<br/>	numbers := Array{[]int{1, 2, 3, 4, 5}}<br/>	total := numbers.Reduce(adder)<br/><br/>	fmt.Println(total)<br/>}</span></pre><p id="f092" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">程序将无法编译，并显示错误消息:</p><pre class="kj kk kl km gt md mc me mf aw mg bi"><span id="0db5" class="mh mi it mc b gy mj mk l ml mm">reducer.go:11:26: syntax error: method must have no type parameters</span></pre><p id="9f15" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">原因是我们在<code class="fe lz ma mb mc b">Reduce</code>方法上引入了一个类型参数<code class="fe lz ma mb mc b">T</code>。Go不允许向方法中引入新的类型参数。在这种情况下，正确的方法是创建在迭代器上操作的免费函数，这就是我在故事中描述的内容:<a class="ae mn" href="https://erik-engheim.medium.com/generic-map-filter-and-reduce-in-go-3845781a591c" rel="noopener">在Go中进行泛型映射、过滤和归约。</a></p><div class="nl nm gp gr nn no"><a href="https://erik-engheim.medium.com/generic-map-filter-and-reduce-in-go-3845781a591c" rel="noopener follow" target="_blank"><div class="np ab fo"><div class="nq ab nr cl cj ns"><h2 class="bd iu gy z fp nt fr fs nu fu fw is bi translated">Go中的通用映射、过滤和减少</h2><div class="nv l"><h3 class="bd b gy z fp nt fr fs nu fu fw dk translated">使用泛型在Go中实现高阶函数</h3></div><div class="nw l"><p class="bd b dl z fp nt fr fs nu fu fw dk translated">erik-engheim.medium.com</p></div></div><div class="nx l"><div class="ny l nz oa ob nx oc ks no"/></div></div></a></div><p id="7910" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">使用基于迭代器的方法，您可以编写如下所示的代码:</p><pre class="kj kk kl km gt md mc me mf aw mg bi"><span id="7f07" class="mh mi it mc b gy mj mk l ml mm"><strong class="mc iu">var</strong> numbers []int = []int{1, 2, 3, 4, 5}<br/><br/>// Create iterator over a slice of integers<br/>iter := NewSliceIterator(numbers)<br/><br/>// Pick values larger than 3<br/>filtered := Filter(iter, <strong class="mc iu">func</strong>(x int) bool {<br/>	<strong class="mc iu">return</strong> x &gt; 3<br/>})<br/><br/>// Square all values<br/>mapped := Map(filtered, <strong class="mc iu">func</strong>(x int) int {<br/>	<strong class="mc iu">return</strong> x * x<br/>})<br/><br/>// Collect result from collection<br/>result := Collect(mapped)<br/><br/><strong class="mc iu">for</strong> _, x := <strong class="mc iu">range</strong> result {<br/>	fmt.Println(x)<br/>}</span></pre><p id="1429" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通过使用迭代器，您不需要为每个想要支持<code class="fe lz ma mb mc b">Map</code>、<code class="fe lz ma mb mc b">Filter</code>、<code class="fe lz ma mb mc b">Reduce</code>或任何其他算法的集合添加代码。您所需要做的就是为您想要过滤、减少或映射的集合创建一个迭代器类型。功能可以很容易地用包含搜索特定元素的其他算法的独立包来扩展。你甚至可以为不代表集合的东西创建一个迭代器，比如I/O对象。您可以使用不同的迭代器来读取行、字符或标记。这些迭代器可以输入到filter、map和reduce中。</p><p id="a213" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有很多可能性，但在走极端之前，我认为值得记住的是，在Go Go中，路线和渠道通常会给你更多的灵活性。虽然迭代器可以用来创建复杂的数据转换管道，但是它们存在不能并发运行的问题。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl od"><img src="../Images/cfe986531851034bbfb8c9ea9291dd2c.png" data-original-src="https://miro.medium.com/v2/format:webp/1*WkMhAYIfDFa9k1cBaYQ_zw.png"/></div><figcaption class="oe of gj gh gi og oh bd b be z dk translated">过滤、映射和收集可以作为通过通道连接的goroutines运行</figcaption></figure><p id="04d7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">将通过通道消费和生产数据的goroutines链接起来更有效，因为它们原则上可以并行运行。因此，不要试图假装Go是Haskell、OCaml或某种奇特的函数式语言，提醒自己Go是关于并发性和简单性的。Goroutines是地鼠的首选武器。</p><h2 id="2a13" class="mh mi it bd mo mp mq dn mr ms mt dp mu ld mv mw mx lh my mz na ll nb nc nd ne bi translated">结束语</h2><p id="e306" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated">对于阅读这篇文章的Java和C#开发人员，我希望你们不要把我的取笑看得太严重。竞争难道不是开发者世界的乐趣之一吗？</p><p id="09b3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">虽然我认为Go比Java有更好的泛型解决方案，但这最终只是一种主观看法。这取决于你如何构建软件。有些人比其他人更多地使用泛型。我认为Go generics将主要吸引那些实用主义者。对我来说，Go泛型非常适合我通常使用泛型的方式，即使是在比Go更复杂的支持泛型的语言中。</p><p id="942c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我不认为开发者总是使用语言特性是因为他们从中受益，而是因为他们想使用闪亮的新事物。保持事情简单比看起来要困难得多。</p></div></div>    
</body>
</html>