<html>
<head>
<title>PageViewer in SwiftUI aka PageViewController</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SwiftUI中的PageViewer又名PageViewController</h1>
<blockquote>原文：<a href="https://itnext.io/pageviewer-is-swiftui-aka-pageviewcontroller-8a53b1c37970?source=collection_archive---------2-----------------------#2020-01-02">https://itnext.io/pageviewer-is-swiftui-aka-pageviewcontroller-8a53b1c37970?source=collection_archive---------2-----------------------#2020-01-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="bd28" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">做软件开发在大多数应用程序中，有一些简单解释给定应用程序基本功能的入门屏幕。由于SwiftUI已经推出一段时间了，它并不支持这种视图，所以让我向您展示如何使用这个神奇的框架实现UIPageViewController行为！</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/efad38426a5f4919d581e7ed73f77ae5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jQ41W6Sow4gJuq3ZtG-CgA.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">Unsplash.com</figcaption></figure><h2 id="dbad" class="lb lc iq bd ld le lf dn lg lh li dp lj jy lk ll lm kc ln lo lp kg lq lr ls lt bi translated">这篇文章可以在我的博客页面<a class="ae lu" href="https://gregios.eu/2019/12/21/pageviewer-is-swiftui-aka-pageviewcontroller/" rel="noopener ugc nofollow" target="_blank">这里</a>找到！(此处medium不截断gists！)</h2><h2 id="2bbf" class="lb lc iq bd ld le lf dn lg lh li dp lj jy lk ll lm kc ln lo lp kg lq lr ls lt bi translated">项目设置</h2><ol class=""><li id="425b" class="lv lw iq jp b jq lx ju ly jy lz kc ma kg mb kk mc md me mf bi translated">归档新项目</li></ol><p id="7189" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以…是的，我喜欢Swift Playgrounds，但在这种情况下，Playgrounds不能很好地与SwiftUI和DragGesture识别器一起工作，所以本文将在新的SwiftUI项目中实现。</p><h2 id="cd1d" class="lb lc iq bd ld le lf dn lg lh li dp lj jy lk ll lm kc ln lo lp kg lq lr ls lt bi translated">SwiftUI？</h2><p id="9858" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy mg ka kb kc mh ke kf kg mi ki kj kk ij bi translated">SwiftUI定义是一个允许以声明方式构建用户界面的框架。但这意味着什么呢？</p><p id="c596" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一种声明式的思维方式意味着你不必关心告诉应用程序状态的更新。等等……什么？</p><p id="fafe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们假设您想要展示一个电子邮件作者。按照命令式的思维方式，我们将被迫声明一个电子邮件编辑器视图，每当我们想要显示它时，我们都需要调用一些函数来呈现这个视图。然而，声明性的方式允许定义一些属性，这些属性将被电子邮件编辑器视图观察到，无论该视图是否应该被显示。这里最重要的是，你需要一次性申报这个财产，再也不用关心州与州之间的迁移了！</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="7491" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以是的，让我们开始吧！</p><h2 id="cb06" class="lb lc iq bd ld le lf dn lg lh li dp lj jy lk ll lm kc ln lo lp kg lq lr ls lt bi translated">页面视图</h2><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ml mk l"/></div></figure><p id="dbbb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">页面视图确认视图协议，这意味着它将实现“某些视图”类型的属性。</p><p id="7372" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里的一些关键字定义了不透明的结果类型，它是在Swift 5.1中引入的，你可以在这里了解更多信息<a class="ae lu" href="https://docs.swift.org/swift-book/LanguageGuide/OpaqueTypes.html" rel="noopener ugc nofollow" target="_blank">https://docs . Swift . org/Swift-book/language guide/opaquetypes . html</a></p><p id="c003" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们需要定义内部视图属性:</p><ul class=""><li id="d870" class="lv lw iq jp b jq jr ju jv jy mm kc mn kg mo kk mp md me mf bi translated">“图像”对应于UIImage类型，它只显示一幅图像。此图像应用了两个构建器函数:</li><li id="13a1" class="lv lw iq jp b jq mq ju mr jy ms kc mt kg mu kk mp md me mf bi translated">resizable() —这告诉图像适合屏幕</li><li id="c194" class="lv lw iq jp b jq mq ju mr jy ms kc mt kg mu kk mp md me mf bi translated">clipped()-这告诉image它不应该在父视图之外发出刺耳的声音</li></ul><p id="7ca3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">仅此而已。</p><p id="f789" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">PageViewData符合可识别协议。你可以在这里了解更多:【https://nshipster.com/identifiable/】T4</p><p id="5a5c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一般来说，可识别允许SwiftUI引擎通过识别给定视图是否需要从头开始创建或者SwiftUI引擎是否可以重用已经创建的视图来优化内存。</p><h2 id="d247" class="lb lc iq bd ld le lf dn lg lh li dp lj jy lk ll lm kc ln lo lp kg lq lr ls lt bi translated">圆形按钮</h2><p id="c124" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy mg ka kb kc mh ke kf kg mi ki kj kk ij bi translated">这个难题的第二个元素是CircleButton，它是一个比PageView更高级的视图。CircleButton将指示当前显示的页面，并允许用户在页面之间导航。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ml mk l"/></div></figure><p id="914d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以让我们把圆形按钮分成第一部分:</p><ul class=""><li id="12c7" class="lv lw iq jp b jq jr ju jv jy mm kc mn kg mo kk mp md me mf bi translated">@ Binding<strong class="jp ir">var</strong>is selected:Bool</li></ul><p id="7270" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">呼呼，呼呼，@Binding var…那是什么。让我解释一下。@Binding是属性包装器，属性什么…？属性包装是一种通用数据结构，允许您更改属性的读写方式。这里的绑定意味着这个属性可以动态改变，而且SwiftUI会观察到这个属性的任何变化。让我们看看它是怎么做的。</p><p id="d0b0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">圆圈()。前景颜色(<strong class="jp ir">本身</strong>)。isSelected？color . white:color . white . opacity(0.5))</p><p id="31fb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每当self.isSelected属性发生变化时，此圆形视图的前景色将随之更新！斯威夫特UI摇滚，是吗？</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mv mk l"/></div></figure><p id="7aea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">let action只是一个快速的回调函数，当用户点击这个按钮时就会被执行。</p><h2 id="fd8f" class="lb lc iq bd ld le lf dn lg lh li dp lj jy lk ll lm kc ln lo lp kg lq lr ls lt bi translated">SwiperView</h2><p id="0a05" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy mg ka kb kc mh ke kf kg mi ki kj kk ij bi translated">这个视图比其他视图稍微复杂一点，但是没有什么值得你害怕的。让我们从声明所需的属性开始:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ml mk l"/></div></figure><p id="a503" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">属性:</p><ul class=""><li id="2c08" class="lv lw iq jp b jq jr ju jv jy mm kc mn kg mo kk mp md me mf bi translated">信函页面:[页面视图数据]</li><li id="44ed" class="lv lw iq jp b jq mq ju mr jy ms kc mt kg mu kk mp md me mf bi translated">@Binding var index: Int</li><li id="decd" class="lv lw iq jp b jq mq ju mr jy ms kc mt kg mu kk mp md me mf bi translated">@ State private var offset:CG float = 0</li><li id="ab1a" class="lv lw iq jp b jq mq ju mr jy ms kc mt kg mu kk mp md me mf bi translated">@ State private var isuser swiping:Bool = false</li></ul><p id="449f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，在这个视图中引入了一个新的属性包装器，它叫做@State，是一个值的包装器，视图将基于它的当前状态。@State property只能由视图本身编辑，这就是为什么Apple建议总是将State声明为私有财产。您可以在这里查看有关@State属性包装器的更多信息:</p><p id="d7cf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">【https://developer.apple.com/documentation/swiftui/state. T4】</p><ul class=""><li id="a9a4" class="lv lw iq jp b jq jr ju jv jy mm kc mn kg mo kk mp md me mf bi translated">页面表示视图数据元素的集合，允许创建相应的视图</li><li id="7ff9" class="lv lw iq jp b jq mq ju mr jy ms kc mt kg mu kk mp md me mf bi translated">@Binding var index: Int表示显示在屏幕上的页面视图的当前索引</li><li id="fb08" class="lv lw iq jp b jq mq ju mr jy ms kc mt kg mu kk mp md me mf bi translated">@State var offset: CGFloat = 0表示用户在屏幕上滑动时手指在屏幕上的当前偏移量</li><li id="2280" class="lv lw iq jp b jq mq ju mr jy ms kc mt kg mu kk mp md me mf bi translated">@ State private var isuserwisping:Bool允许SwiftUI指示任何正在进行的滑动动作，或者滑动动作结束。</li></ul><p id="0c4c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们可以在SwiperView中声明body</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ml mk l"/></div></figure><p id="1197" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在主体内部，我们声明:</p><ul class=""><li id="5933" class="lv lw iq jp b jq jr ju jv jy mm kc mn kg mo kk mp md me mf bi translated">geometry reader——这个对象只不过是一个允许读取当前容器几何图形的准视图。你可以在这里查看更多关于这个物体的信息:<a class="ae lu" href="https://swiftui-lab.com/geometryreader-to-the-rescue/" rel="noopener ugc nofollow" target="_blank">https://swiftui-lab.com/geometryreader-to-the-rescue/</a></li><li id="2aa6" class="lv lw iq jp b jq mq ju mr jy ms kc mt kg mu kk mp md me mf bi translated">ScrollView —这是SwiftUI对象，直接对应于UIScrollView，并允许更改其内容的偏移量。(我们将会这样做)</li><li id="1f1f" class="lv lw iq jp b jq mq ju mr jy ms kc mt kg mu kk mp md me mf bi translated">HStack —水平堆栈视图。</li><li id="5b40" class="lv lw iq jp b jq mq ju mr jy ms kc mt kg mu kk mp md me mf bi translated">ForEach(self.pages) —这种特殊的循环允许枚举body属性中的对象。它用于创建我们的页面视图对象。</li></ul><p id="b35a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">ScrollView content.offset更新:</p><p id="398a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为我们希望在scrollView中滚动页面视图，所以我们需要控制ScrollView的内容偏移属性。为此，我们将使用一些SwiftUI魔法。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ml mk l"/></div></figure><ul class=""><li id="b110" class="lv lw iq jp b jq jr ju jv jy mm kc mn kg mo kk mp md me mf bi translated">content.offset是一个生成器函数，它允许在滚动视图中指示视图对齐的当前偏移量。</li><li id="5135" class="lv lw iq jp b jq mq ju mr jy ms kc mt kg mu kk mp md me mf bi translated">基于isUserSwipping布尔值计算偏移量。当它为true时，offset从DragGesture.onChanged回调中读取，当用户不交换时，offset等于当前页面索引乘以屏幕宽度。</li><li id="0396" class="lv lw iq jp b jq mq ju mr jy ms kc mt kg mu kk mp md me mf bi translated">。frame定义了scrollView应该适合屏幕，并且在加载时，视图应该是前导对齐的。(如果没有这一行，我们的scrollView将在加载时显示中间的页面视图)</li><li id="94bb" class="lv lw iq jp b jq mq ju mr jy ms kc mt kg mu kk mp md me mf bi translated">。gesture()方法允许为此视图添加手势识别器。</li></ul><p id="5eac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">拖拽手势</p><ul class=""><li id="e10a" class="lv lw iq jp b jq jr ju jv jy mm kc mn kg mo kk mp md me mf bi translated">当用户滑动屏幕时调用onChanged闭包，然后我们将isUserSwiping赋值为true，并根据“value.translation.width”属性计算内容偏移量</li><li id="365f" class="lv lw iq jp b jq mq ju mr jy ms kc mt kg mu kk mp md me mf bi translated">在这里我们需要计算页面视图应该向左还是向右移动，以及下一个索引应该显示在哪个页面上。</li><li id="2c05" class="lv lw iq jp b jq mq ju mr jy ms kc mt kg mu kk mp md me mf bi translated">withAnimation { }告诉SwiftUI这个闭包内的任何更改都应该是动画的</li></ul><h2 id="8101" class="lb lc iq bd ld le lf dn lg lh li dp lj jy lk ll lm kc ln lo lp kg lq lr ls lt bi translated">内容视图</h2><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ml mk l"/></div></figure><p id="bd85" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">内容视图包含:</p><ul class=""><li id="85e4" class="lv lw iq jp b jq jr ju jv jy mm kc mn kg mo kk mp md me mf bi translated">pages-PageViewData对象的数组</li><li id="81ac" class="lv lw iq jp b jq mq ju mr jy ms kc mt kg mu kk mp md me mf bi translated">@State <strong class="jp ir"> private </strong></li></ul><p id="fc6b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在主体内部，我们声明:</p><ul class=""><li id="2dd4" class="lv lw iq jp b jq jr ju jv jy mm kc mn kg mo kk mp md me mf bi translated">z stack——允许在同一轴上对齐其子视图的视图(第二个视图总是在第一个视图之上)</li><li id="2892" class="lv lw iq jp b jq mq ju mr jy ms kc mt kg mu kk mp md me mf bi translated">SwiperView —我们刚刚创建的视图，它显示浏览量</li><li id="fb6e" class="lv lw iq jp b jq mq ju mr jy ms kc mt kg mu kk mp md me mf bi translated">HStack —该堆栈视图将用于显示页面视图导航按钮</li><li id="4e97" class="lv lw iq jp b jq mq ju mr jy ms kc mt kg mu kk mp md me mf bi translated">ForEach(0..<self.pages.count index="" in="" that="" allows="" us="" to="" create="" navigation="" buttons=""/></li><li id="5f3f" class="lv lw iq jp b jq mq ju mr jy ms kc mt kg mu kk mp md me mf bi translated">padding which defines bottom padding for HStack view</li></ul><p id="418e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">And Boom, the effect is magnificent!</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/1e0bce4502bc5cfcb0d85e7036da5777.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*ZLgxbZ_ETuARRrlTPLcvIg.gif"/></div></figure><p id="bd5e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Thanks for ready! Full code can be found <a class="ae lu" href="https://github.com/gregiOS/PageViewer" rel="noopener ugc nofollow" target="_blank">这里</a>！</p></div></div>    
</body>
</html>