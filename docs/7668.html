<html>
<head>
<title>How to Handle Type Conversions with the DynamoDB Go SDK</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用DynamoDB Go SDK处理类型转换</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-handle-type-conversions-with-the-dynamodb-go-sdk-ea3529b64e?source=collection_archive---------1-----------------------#2022-12-13">https://itnext.io/how-to-handle-type-conversions-with-the-dynamodb-go-sdk-ea3529b64e?source=collection_archive---------1-----------------------#2022-12-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/d3d1db3aefd07aca061825ed749f5601.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I9iZqqeLgTCZpLNn5N81Fg.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">DynamoDB Go SDK</figcaption></figure><div class=""/><div class=""><h2 id="a17e" class="pw-subtitle-paragraph kc je jf bd b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dk translated">通过实用的代码示例学习</h2></div><p id="96d7" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><code class="fe lq lr ls lt b">DynamoDB</code>提供了一组<a class="ae lu" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.NamingRulesDataTypes.html" rel="noopener ugc nofollow" target="_blank">丰富的数据类型</a>，包括<code class="fe lq lr ls lt b">String</code> s、<code class="fe lq lr ls lt b">Number</code> s、<code class="fe lq lr ls lt b">Set</code> s、<code class="fe lq lr ls lt b">List</code> s、<code class="fe lq lr ls lt b">Map</code> s等。在用于DynamoDB 的<a class="ae lu" href="https://pkg.go.dev/github.com/aws/aws-sdk-go-v2/service/dynamodb" rel="noopener ugc nofollow" target="_blank"> Go SDK中，</a><a class="ae lu" href="https://pkg.go.dev/github.com/aws/aws-sdk-go-v2/service/dynamodb/types" rel="noopener ugc nofollow" target="_blank">类型</a>包包含这些数据类型的Go表示，而<a class="ae lu" href="https://pkg.go.dev/github.com/aws/aws-sdk-go-v2/feature/dynamodb/attributevalue" rel="noopener ugc nofollow" target="_blank"> attributevalue </a>模块提供了处理Go和<code class="fe lq lr ls lt b">DynamoDB</code>类型的函数。</p><p id="238c" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">这篇博客文章将展示如何在你的应用程序和<code class="fe lq lr ls lt b">DynamoDB</code>中处理Go类型之间的转换。我们将从简单的代码片段开始，介绍一些API构造，并以一个示例结束，说明如何在一个完整的应用程序的上下文中使用这些Go SDK特性(包括代码遍历)。</p><blockquote class="lv lw lx"><p id="6577" class="ku kv ly kw b kx ky kg kz la lb kj lc lz le lf lg ma li lj lk mb lm ln lo lp ij bi translated"><em class="jf">可以参考</em> <a class="ae lu" href="https://github.com/abhirockzz/dynamodb-go-sdk-type-conversion" rel="noopener ugc nofollow" target="_blank"> <em class="jf"> GitHub </em> </a>上的完整代码</p></blockquote><p id="6b64" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">首先，看几个例子。</p><blockquote class="lv lw lx"><p id="a5b4" class="ku kv ly kw b kx ky kg kz la lb kj lc lz le lf lg ma li lj lk mb lm ln lo lp ij bi translated"><em class="jf">请注意，为了保持简洁，下面的代码片段中特意省略了错误处理。</em></p></blockquote></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h1 id="6898" class="mj mk jf bd ml mm mn mo mp mq mr ms mt kl mu km mv ko mw kp mx kr my ks mz na bi translated">从Go类型转换到DynamoDB类型</h1><p id="4e11" class="pw-post-body-paragraph ku kv jf kw b kx nb kg kz la nc kj lc ld nd lf lg lh ne lj lk ll nf ln lo lp ij bi translated"><a class="ae lu" href="https://pkg.go.dev/github.com/aws/aws-sdk-go-v2/feature/dynamodb/attributevalue#Marshal" rel="noopener ugc nofollow" target="_blank"> Marshal </a>系列函数负责这一点。它与基本标量(<code class="fe lq lr ls lt b">int</code>、<code class="fe lq lr ls lt b">uint</code>、<code class="fe lq lr ls lt b">float</code>、<code class="fe lq lr ls lt b">bool</code>、<code class="fe lq lr ls lt b">string</code>)、<code class="fe lq lr ls lt b">map</code>、<code class="fe lq lr ls lt b">slice</code>和<code class="fe lq lr ls lt b">struct</code>一起工作。</p><p id="fc4f" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">要处理标量类型，只需使用(generic) <code class="fe lq lr ls lt b">Marshal</code>函数:</p><pre class="ng nh ni nj gt nk lt nl bn nm nn bi"><span id="b21a" class="no mk jf lt b be np nq l nr ns">func marshalScalars() {<br/> av, err := attributevalue.Marshal("foo")<br/> log.Println(av.(*types.AttributeValueMemberS).Value)<br/><br/> av, err = attributevalue.Marshal(true)<br/> log.Println(av.(*types.AttributeValueMemberBOOL).Value)<br/><br/> av, err = attributevalue.Marshal(42)<br/> log.Println(av.(*types.AttributeValueMemberN).Value)<br/><br/> av, err = attributevalue.Marshal(42.42)<br/> log.Println(av.(*types.AttributeValueMemberN).Value)<br/>}</span></pre><p id="a8e6" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><code class="fe lq lr ls lt b">Marshal</code>将Go数据类型转换为<a class="ae lu" href="https://pkg.go.dev/github.com/aws/aws-sdk-go-v2/service/dynamodb/types#AttributeValue" rel="noopener ugc nofollow" target="_blank">属性值</a>。但是<code class="fe lq lr ls lt b">AttributeValue</code>本身只是一个<code class="fe lq lr ls lt b">interface</code>，需要你将其转换成具体的类型，比如<a class="ae lu" href="https://pkg.go.dev/github.com/aws/aws-sdk-go-v2/service/dynamodb/types#AttributeValueMemberS" rel="noopener ugc nofollow" target="_blank"> AttributeValueMemberS </a>(对于<code class="fe lq lr ls lt b">string</code>)、<a class="ae lu" href="https://pkg.go.dev/github.com/aws/aws-sdk-go-v2/service/dynamodb/types#AttributeValueMemberBOOL" rel="noopener ugc nofollow" target="_blank">AttributeValueMemberBOOL</a>(对于<code class="fe lq lr ls lt b">boolean</code>)等。</p><blockquote class="lv lw lx"><p id="a14a" class="ku kv ly kw b kx ky kg kz la lb kj lc lz le lf lg ma li lj lk mb lm ln lo lp ij bi translated"><em class="jf">如果你试图转换不兼容的类型，SDK会给出一个有用的错误消息。例如</em> <code class="fe lq lr ls lt b"><em class="jf">panic: interface conversion: types.AttributeValue is *types.AttributeValueMemberN, not *types.AttributeValueMemberS</em></code></p></blockquote><p id="9bea" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">使用<code class="fe lq lr ls lt b">slice</code> s和<code class="fe lq lr ls lt b"> map</code> s时，最好使用特定的函数，如<a class="ae lu" href="https://pkg.go.dev/github.com/aws/aws-sdk-go-v2/feature/dynamodb/attributevalue#MarshalList" rel="noopener ugc nofollow" target="_blank">编组列表</a>和<a class="ae lu" href="https://pkg.go.dev/github.com/aws/aws-sdk-go-v2/feature/dynamodb/attributevalue#MarshalMap" rel="noopener ugc nofollow" target="_blank">编组映射</a>:</p><pre class="ng nh ni nj gt nk lt nl bn nm nn bi"><span id="aa5c" class="no mk jf lt b be np nq l nr ns">func marshalSlicesAndMaps() {<br/> avl, err := attributevalue.MarshalList([]string{"foo", "bar"})<br/><br/> for _, v := range avl {<br/>  log.Println(v.(*types.AttributeValueMemberS).Value)<br/> }<br/><br/> avm, err := attributevalue.MarshalMap(map[string]interface{}{"foo": "bar", "boo": "42"})<br/><br/> for k, v := range avm {<br/>  log.Println(k, "=", v.(*types.AttributeValueMemberS).Value)<br/> }<br/>}</span></pre><p id="8d86" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">上面的例子让您了解了如何孤立地处理简单的数据类型。在现实世界的应用程序中，您将利用<em class="ly">复合</em>数据类型来表示您的领域模型——它们很可能是Go <code class="fe lq lr ls lt b">struct</code>的形式。所以让我们看几个例子。</p><h1 id="d7bc" class="mj mk jf bd ml mm nt mo mp mq nu ms mt kl nv km mv ko nw kp mx kr nx ks mz na bi translated">使用Go结构</h1><p id="cd23" class="pw-post-body-paragraph ku kv jf kw b kx nb kg kz la nc kj lc ld nd lf lg lh ne lj lk ll nf ln lo lp ij bi translated">这里有一个简单的例子:</p><pre class="ng nh ni nj gt nk lt nl bn nm nn bi"><span id="ed25" class="no mk jf lt b be np nq l nr ns">type User struct {<br/> Name string<br/> Age  string<br/>}<br/><br/>func marshalStruct() {<br/> user := User{Name: "foo", Age: "42"}<br/><br/> av, err := attributevalue.Marshal(user)<br/><br/> avm := av.(*types.AttributeValueMemberM).Value<br/> log.Println("name", avm["Name"].(*types.AttributeValueMemberS).Value)<br/> log.Println("age", avm["Age"].(*types.AttributeValueMemberS).Value)<br/><br/> avMap, err := attributevalue.MarshalMap(user)<br/><br/> for name, value := range avMap {<br/>  log.Println(name, "=", value.(*types.AttributeValueMemberS).Value)<br/> }<br/>}</span></pre><blockquote class="lv lw lx"><p id="63f1" class="ku kv ly kw b kx ky kg kz la lb kj lc lz le lf lg ma li lj lk mb lm ln lo lp ij bi translated"><em class="jf">注意在处理Go结构时使用</em> <code class="fe lq lr ls lt b"><em class="jf">MarshalMap</em></code> <em class="jf">(而不是</em> <code class="fe lq lr ls lt b"><em class="jf">Marshal</em></code> <em class="jf">)是多么的方便，尤其是当你的应用程序不知道所有的属性名的时候。</em></p></blockquote><p id="9107" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">到目前为止，看起来我们可以处理简单的用例。但是我们可以做得更好。这个例子有一个同质的数据类型，即<code class="fe lq lr ls lt b">struct</code>只有<code class="fe lq lr ls lt b">string</code>类型，这使得迭代结果<code class="fe lq lr ls lt b">map</code>并将值转换为<code class="fe lq lr ls lt b">*types.AttributeValueMemberS</code>变得容易——如果不是这样，你将不得不迭代每一个属性值类型并将它转换为适当的Go类型。这在与其余的<code class="fe lq lr ls lt b">DynamoDB</code>API一起工作时会很明显。例如，<a class="ae lu" href="https://pkg.go.dev/github.com/aws/aws-sdk-go-v2/service/dynamodb#Client.GetItem" rel="noopener ugc nofollow" target="_blank"> GetItem </a>调用的结果(<a class="ae lu" href="https://pkg.go.dev/github.com/aws/aws-sdk-go-v2/service/dynamodb#GetItemOutput" rel="noopener ugc nofollow" target="_blank"> GetItemOutput </a>)包含一个<code class="fe lq lr ls lt b">map[string]types.AttributeValue</code>。</p><p id="7678" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">SDK为我们提供了一种使这变得更加容易的方法！</p><h1 id="d1bb" class="mj mk jf bd ml mm nt mo mp mq nu ms mt kl nv km mv ko nw kp mx kr nx ks mz na bi translated">从DynamoDB转换到Go类型</h1><p id="8056" class="pw-post-body-paragraph ku kv jf kw b kx nb kg kz la nc kj lc ld nd lf lg lh ne lj lk ll nf ln lo lp ij bi translated"><code class="fe lq lr ls lt b">Unmarshal</code>系列函数负责这一点。这是另一个例子:</p><pre class="ng nh ni nj gt nk lt nl bn nm nn bi"><span id="85ee" class="no mk jf lt b be np nq l nr ns">type AdvancedUser struct {<br/> Name         string<br/> Age          int<br/> IsOnline     bool<br/> Favourites   []string<br/> Contact      map[string]string<br/> RegisteredOn time.Time<br/>}<br/><br/>func marshalUnmarshal() {<br/> user := AdvancedUser{<br/>  Name:         "abhishek",<br/>  Age:          35,<br/>  IsOnline:     false,<br/>  Favourites:   []string{"Lost In Translation, The Walking Dead"},<br/>  Contact:      map[string]string{"mobile": "+919718861200", "email": "abhirockzz@gmail.com"},<br/>  RegisteredOn: time.Now(),<br/> }<br/><br/> avMap, err := attributevalue.MarshalMap(user)<br/><br/> var result AdvancedUser<br/> err = attributevalue.UnmarshalMap(avMap, &amp;result)<br/><br/> log.Println("\nname", result.Name, "\nage", result.Age, "\nfavs", result.Favourites)<br/>}</span></pre><p id="981c" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">使用<code class="fe lq lr ls lt b">MarshalMap</code>，我们将<code class="fe lq lr ls lt b">AdvancedUser</code> struct的一个实例转换成了<code class="fe lq lr ls lt b">map[string]types.AttributeValue</code>(假设您得到的是对<code class="fe lq lr ls lt b">GetItem</code> API调用的响应)。现在，我们不用迭代单个的<code class="fe lq lr ls lt b">AttributeValue</code>，而是简单地使用<code class="fe lq lr ls lt b"><a class="ae lu" href="https://pkg.go.dev/github.com/aws/aws-sdk-go-v2/feature/dynamodb/attributevalue#UnmarshalMap" rel="noopener ugc nofollow" target="_blank">UnmarshalMap</a></code>将其转换回Go <code class="fe lq lr ls lt b">struct</code>。</p><p id="5024" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">还有呢！像<code class="fe lq lr ls lt b">UnmarshalListOfMaps</code>这样的实用功能可以方便地与多个<code class="fe lq lr ls lt b">slice</code>一起工作。</p><pre class="ng nh ni nj gt nk lt nl bn nm nn bi"><span id="9e87" class="no mk jf lt b be np nq l nr ns">type AdvancedUser struct {<br/> Name         string<br/> Age          int<br/> IsOnline     bool<br/> Favourites   []string<br/> Contact      map[string]string<br/> RegisteredOn time.Time<br/>}<br/><br/>func marshalUnmarshal() {<br/> user := AdvancedUser{<br/>  Name:         "abhishek",<br/>  Age:          35,<br/>  IsOnline:     false,<br/>  Favourites:   []string{"Lost In Translation, The Walking Dead"},<br/>  Contact:      map[string]string{"mobile": "+919718861200", "email": "abhirockzz@gmail.com"},<br/>  RegisteredOn: time.Now(),<br/> }<br/><br/> avMap, err := attributevalue.MarshalMap(user)<br/><br/> var result AdvancedUser<br/> err = attributevalue.UnmarshalMap(avMap, &amp;result)<br/><br/> log.Println("\nname", result.Name, "\nage", result.Age, "\nfavs", result.Favourites)<br/>}</span></pre><h1 id="05ca" class="mj mk jf bd ml mm nt mo mp mq nu ms mt kl nv km mv ko nw kp mx kr nx ks mz na bi translated">使用struct标记进行自定义</h1><p id="b6cb" class="pw-post-body-paragraph ku kv jf kw b kx nb kg kz la nc kj lc ld nd lf lg lh ne lj lk ll nf ln lo lp ij bi translated"><code class="fe lq lr ls lt b">Marshal</code>和<code class="fe lq lr ls lt b">Unmarshal</code>函数支持<code class="fe lq lr ls lt b">dynamodbav</code> struct标签来控制Go类型和<code class="fe lq lr ls lt b">DynamoDB</code>T21之间的转换。考虑以下<code class="fe lq lr ls lt b">struct</code>:</p><pre class="ng nh ni nj gt nk lt nl bn nm nn bi"><span id="b242" class="no mk jf lt b be np nq l nr ns">type User struct {<br/> Email string `dynamodbav:"email" json:"user_email"`<br/> Age   int    `dynamodbav:"age,omitempty" json:"age,omitempty"`<br/> City  string `dynamodbav:"city" json:"city"`<br/>}</span></pre><p id="09c8" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><code class="fe lq lr ls lt b">dynamodbav</code>派上用场的几个常见场景。</p><p id="cca0" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><strong class="kw jg">自定义属性名称</strong></p><p id="d582" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">比方说，我们有一个以email作为分区键的表。如果没有<code class="fe lq lr ls lt b">dynamodbav:"email"</code>标签，当我们封送<code class="fe lq lr ls lt b">User</code>结构并试图保存在表中时，它将使用<code class="fe lq lr ls lt b">Email</code>(大写)作为属性名- <code class="fe lq lr ls lt b">DynamoDB</code>将不接受这一点，因为<a class="ae lu" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.NamingRulesDataTypes.html#HowItWorks.NamingRules" rel="noopener ugc nofollow" target="_blank">属性名区分大小写</a> - <em class="ly">“所有名称必须使用UTF-8编码，并且区分大小写。”</em></p><blockquote class="lv lw lx"><p id="2e58" class="ku kv ly kw b kx ky kg kz la lb kj lc lz le lf lg ma li lj lk mb lm ln lo lp ij bi translated"><em class="jf">注意，我们也组合了</em> <a class="ae lu" href="https://cs.opensource.google/go/go/+/go1.19:src/encoding/json/encode.go;l=157" rel="noopener ugc nofollow" target="_blank"> <em class="jf"> json标签</em> </a> <em class="jf">(这是完全有效的)——它不是由</em> <code class="fe lq lr ls lt b"><em class="jf">DynamoDB</em></code> <em class="jf">使用，而是在编码和解码数据时由json库使用</em></p></blockquote><p id="3f89" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><strong class="kw jg">处理缺失的属性</strong></p><p id="c8ba" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><code class="fe lq lr ls lt b">DynamoDB</code>是一个NoSQL数据库，表没有固定的模式(除了<code class="fe lq lr ls lt b">partition</code>键和一个可选的<code class="fe lq lr ls lt b">sort</code>键)。例如，用户项目可能<em class="ly">而不是</em>包括年龄属性。通过使用<code class="fe lq lr ls lt b">dynamodbav:"age,omitempty"</code>，如果<code class="fe lq lr ls lt b">Age</code>字段丢失，它将不会被发送到<code class="fe lq lr ls lt b">DynamoDB</code>(它将被忽略)</p><blockquote class="lv lw lx"><p id="f322" class="ku kv ly kw b kx ky kg kz la lb kj lc lz le lf lg ma li lj lk mb lm ln lo lp ij bi translated"><em class="jf">在没有这个标签的情况下，我们的</em> <code class="fe lq lr ls lt b"><em class="jf">DynamoDB</em></code> <em class="jf">记录将把</em> <code class="fe lq lr ls lt b"><em class="jf">Age</em></code> <em class="jf">属性设置为</em><code class="fe lq lr ls lt b"><em class="jf">0</em></code><em class="jf">——取决于您的用例，这可能是也可能不是</em></p></blockquote><p id="fa10" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">要查看这个struct标签的所有使用模式，请参考<a class="ae lu" href="https://pkg.go.dev/github.com/aws/aws-sdk-go-v2/feature/dynamodb/attributevalue#Marshal" rel="noopener ugc nofollow" target="_blank"> Marshal API文档</a>。</p><p id="0f2f" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">如前所述，让我们探索如何将所有这些API用于一个…</p></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h1 id="45fc" class="mj mk jf bd ml mm mn mo mp mq mr ms mt kl mu km mv ko mw kp mx kr my ks mz na bi translated">…端到端示例</h1><p id="786d" class="pw-post-body-paragraph ku kv jf kw b kx nb kg kz la nc kj lc ld nd lf lg lh ne lj lk ll nf ln lo lp ij bi translated">我们将看一个公开带有几个端点的REST API的Go应用程序。它结合了CRUD API(<code class="fe lq lr ls lt b">PutItem</code>、<code class="fe lq lr ls lt b">GetItem</code>等)。)以及上面提到的所有函数/API。</p><h2 id="d2c0" class="ny mk jf bd ml nz oa dn mp ob oc dp mt ld od oe mv lh of og mx ll oh oi mz oj bi translated">尝试应用程序</h2><p id="bd4e" class="pw-post-body-paragraph ku kv jf kw b kx nb kg kz la nc kj lc ld nd lf lg lh ne lj lk ll nf ln lo lp ij bi translated">在我们看到代码之前，让我们快速回顾和测试应用程序公开的端点。您需要安装Go，克隆应用程序并切换到正确的目录。</p><pre class="ng nh ni nj gt nk lt nl bn nm nn bi"><span id="4084" class="no mk jf lt b be np nq l nr ns">git clone https://github.com/abhirockzz/dynamodb-go-sdk-type-conversion<br/>cd dynamodb-go-sdk-type-conversion</span></pre><p id="8ff3" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">首先，创建一个<code class="fe lq lr ls lt b">DynamoDB</code>表(您可以将其命名为users)。使用城市作为<code class="fe lq lr ls lt b">Partition</code>键，电子邮件作为<code class="fe lq lr ls lt b">Sort</code>键。</p><figure class="ng nh ni nj gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ok"><img src="../Images/8be2dec47adaa903cccbc2385f7691d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VAmNNL-WurEZK1tSnkPenQ.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">DynamoDB表(图片由作者提供)</figcaption></figure><p id="03ca" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">你需要一些测试数据。您可以手动这样做，但是我已经包含了一个简单的实用程序，用于在应用程序启动期间播种一些测试数据。要使用它，只需在应用程序启动时设置<code class="fe lq lr ls lt b">SEED_TEST_DATA</code>变量:</p><pre class="ng nh ni nj gt nk lt nl bn nm nn bi"><span id="33c4" class="no mk jf lt b be np nq l nr ns">export SEED_TEST_DATA=true<br/><br/>go run main.go<br/># output<br/>started http server...</span></pre><p id="5d37" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">这将创建<code class="fe lq lr ls lt b">100</code>项目。检查<code class="fe lq lr ls lt b">DynamoDB</code>表以确认:</p><figure class="ng nh ni nj gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ol"><img src="../Images/a78d2f1a841965d68434e612e3d608b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*64bY-QElEAyKI5An-Nk15g.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">DynamoDB表格数据(图片由作者提供)</figcaption></figure><p id="bc47" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">您的应用程序应该在端口<code class="fe lq lr ls lt b">8080</code>可用。您可以使用<code class="fe lq lr ls lt b">curl</code>或任何其他<code class="fe lq lr ls lt b">HTTP</code>客户端来调用端点:</p><pre class="ng nh ni nj gt nk lt nl bn nm nn bi"><span id="50ae" class="no mk jf lt b be np nq l nr ns"># to get all users<br/>curl -i http://localhost:8080/users/<br/><br/># to get all users in a particular city<br/>curl -i http://localhost:8080/users/London<br/><br/># to get a specific user<br/>curl -i "http://localhost:8080/user?city=London&amp;email=user11@foo.com"</span></pre><p id="2ab4" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">为了更好地理解如何使用上述API，让我们简要回顾一下代码的关键部分:</p><h2 id="9000" class="ny mk jf bd ml nz oa dn mp ob oc dp mt ld od oe mv lh of og mx ll oh oi mz oj bi translated">代码遍历</h2><p id="4e61" class="pw-post-body-paragraph ku kv jf kw b kx nb kg kz la nc kj lc ld nd lf lg lh ne lj lk ll nf ln lo lp ij bi translated"><strong class="kw jg">向DynamoDB表添加新项目</strong></p><p id="b101" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">从添加一个<code class="fe lq lr ls lt b">User</code>的HTTP处理程序开始:</p><pre class="ng nh ni nj gt nk lt nl bn nm nn bi"><span id="bf46" class="no mk jf lt b be np nq l nr ns">func (h Handler) CreateUser(rw http.ResponseWriter, req *http.Request) {<br/> var user model.User<br/><br/> err := json.NewDecoder(req.Body).Decode(&amp;user)<br/> if err != nil {// handle error}<br/><br/> err = h.d.Save(user)<br/> if err != nil {// handle error}<br/><br/> err = json.NewEncoder(rw).Encode(user.Email)<br/> if err != nil {// handle error}<br/>}</span></pre><p id="d63e" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">首先，我们将<code class="fe lq lr ls lt b">JSON</code>有效载荷转换成一个<code class="fe lq lr ls lt b">User</code>结构，然后将它传递给<code class="fe lq lr ls lt b">Save</code>函数。</p><pre class="ng nh ni nj gt nk lt nl bn nm nn bi"><span id="28df" class="no mk jf lt b be np nq l nr ns">func (d DB) Save(user model.User) error {<br/><br/> item, err := attributevalue.MarshalMap(user)<br/><br/> if err != nil {// handle error}<br/><br/> _, err = d.client.PutItem(context.Background(), &amp;dynamodb.PutItemInput{<br/>  TableName: aws.String(d.table),<br/>  Item:      item})<br/><br/> if err != nil {// handle error}<br/><br/> return nil<br/>}</span></pre><p id="617f" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">注意如何使用<code class="fe lq lr ls lt b">MarshalMap</code>将<code class="fe lq lr ls lt b">User</code>结构转换成<code class="fe lq lr ls lt b">PutItem</code> API可以接受的<code class="fe lq lr ls lt b">map[string]types.AttributeValue</code>:</p><p id="4146" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><strong class="kw jg">从DynamoDB中获取单品</strong></p><p id="c0e8" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">由于我们的表有一个复合主键(<code class="fe lq lr ls lt b">city</code>是<code class="fe lq lr ls lt b">partition</code>键，<code class="fe lq lr ls lt b">email</code>是<code class="fe lq lr ls lt b">sort</code>键)，我们需要提供这两个键来定位一个特定的用户项:</p><pre class="ng nh ni nj gt nk lt nl bn nm nn bi"><span id="54a6" class="no mk jf lt b be np nq l nr ns">func (h Handler) FetchUser(rw http.ResponseWriter, req *http.Request) {<br/><br/> email := req.URL.Query().Get("email")<br/> city := req.URL.Query().Get("city")<br/><br/> log.Println("getting user with email", email, "in city", city)<br/><br/> user, err := h.d.GetOne(email, city)<br/> if err != nil {// handle error}<br/><br/><br/> err = json.NewEncoder(rw).Encode(user)<br/> if err != nil {// handle error}<br/>}</span></pre><p id="6b9f" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">我们从<code class="fe lq lr ls lt b">HTTP</code>请求的查询参数中提取出<code class="fe lq lr ls lt b">email</code>和<code class="fe lq lr ls lt b">city</code>，并将其传递给数据库层(<code class="fe lq lr ls lt b">GetOne</code>函数)。</p><pre class="ng nh ni nj gt nk lt nl bn nm nn bi"><span id="60b1" class="no mk jf lt b be np nq l nr ns">func (d DB) GetOne(email, city string) (model.User, error) {<br/><br/> result, err := d.client.GetItem(context.Background(),<br/>  &amp;dynamodb.GetItemInput{<br/>   TableName: aws.String(d.table),<br/>   Key: map[string]types.AttributeValue{<br/>    "email": &amp;types.AttributeValueMemberS{Value: email},<br/>    "city":  &amp;types.AttributeValueMemberS{Value: city}},<br/>  })<br/><br/> if err != nil {// handle error}<br/><br/> if result.Item == nil {<br/>  return model.User{}, ErrNotFound<br/> }<br/><br/> var user model.User<br/><br/> err = attributevalue.UnmarshalMap(result.Item, &amp;user)<br/> if err != nil {// handle error}<br/><br/> return user, nil<br/>}</span></pre><p id="9abe" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">我们调用<code class="fe lq lr ls lt b">GetItem</code> API并以<code class="fe lq lr ls lt b">map[string]types.AttributeValue</code>的形式获取结果(通过<code class="fe lq lr ls lt b">GetItemOutput</code>中的<code class="fe lq lr ls lt b">Item</code>属性)。使用<code class="fe lq lr ls lt b">UnmarshalMap</code>将其转换回Go ( <code class="fe lq lr ls lt b">User</code>)结构。</p><blockquote class="lv lw lx"><p id="e508" class="ku kv ly kw b kx ky kg kz la lb kj lc lz le lf lg ma li lj lk mb lm ln lo lp ij bi translated"><em class="jf">注意，</em> <code class="fe lq lr ls lt b"><em class="jf">GetItemInput</em></code> <em class="jf">中的</em> <code class="fe lq lr ls lt b"><em class="jf">Key</em></code> <em class="jf">属性也接受一个</em> <code class="fe lq lr ls lt b"><em class="jf">map[string]types.AttributeValue</em></code> <em class="jf">，但是我们不用</em> <code class="fe lq lr ls lt b"><em class="jf">MarshalMap</em></code> <em class="jf">来创建它</em></p></blockquote><p id="9c68" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><strong class="kw jg">获取多个项目</strong></p><p id="35a8" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">我们可以选择查询特定城市中的所有用户——这是一个非常有效的访问模式，因为“T4”是“T5”键。</p><p id="5fa4" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">HTTP处理函数接受城市作为路径参数，并将其传递给数据库层。</p><pre class="ng nh ni nj gt nk lt nl bn nm nn bi"><span id="7937" class="no mk jf lt b be np nq l nr ns">func (h Handler) FetchUsers(rw http.ResponseWriter, req *http.Request) {<br/> city := mux.Vars(req)["city"]<br/> log.Println("city", city)<br/><br/> log.Println("getting users in city", city)<br/><br/> users, err := h.d.GetMany(city)<br/><br/> if err != nil {<br/>  http.Error(rw, err.Error(), http.StatusInternalServerError)<br/>  return<br/> }<br/><br/> err = json.NewEncoder(rw).Encode(users)<br/> if err != nil {<br/>  http.Error(rw, err.Error(), http.StatusInternalServerError)<br/>  return<br/> }<br/>}</span></pre><p id="4122" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">从那以后，<code class="fe lq lr ls lt b">GetMany</code>函数做所有的工作:</p><pre class="ng nh ni nj gt nk lt nl bn nm nn bi"><span id="a03c" class="no mk jf lt b be np nq l nr ns">func (d DB) GetMany(city string) ([]model.User, error) {<br/><br/> kcb := expression.Key("city").Equal(expression.Value(city))<br/> kce, _ := expression.NewBuilder().WithKeyCondition(kcb).Build()<br/><br/> result, err := d.client.Query(context.Background(), &amp;dynamodb.QueryInput{<br/>  TableName:                 aws.String(d.table),<br/>  KeyConditionExpression:    kce.KeyCondition(),<br/>  ExpressionAttributeNames:  kce.Names(),<br/>  ExpressionAttributeValues: kce.Values(),<br/> })<br/><br/> if err != nil {<br/>  log.Println("Query failed with error", err)<br/>  return []model.User{}, err<br/> }<br/><br/> users := []model.User{}<br/><br/> if len(result.Items) == 0 {<br/>  return users, nil<br/> }<br/><br/> err = attributevalue.UnmarshalListOfMaps(result.Items, &amp;users)<br/> if err != nil {<br/>  log.Println("UnmarshalMap failed with error", err)<br/>  return []model.User{}, err<br/> }<br/><br/> return users, nil<br/>}</span></pre><p id="c52d" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">注意两件事:</p><ul class=""><li id="37d8" class="om on jf kw b kx ky la lb ld oo lh op ll oq lp or os ot ou bi translated">如何使用<code class="fe lq lr ls lt b">KeyConditionExpression</code>(这来自<code class="fe lq lr ls lt b">expressions</code>包)</li><li id="c694" class="om on jf kw b kx ov la ow ld ox lh oy ll oz lp or os ot ou bi translated">更有趣的是，使用<code class="fe lq lr ls lt b">UnmarshalListOfMaps</code>函数直接将一个<code class="fe lq lr ls lt b">[]map[string]types.AttributeValue</code>(dynamo db中的<code class="fe lq lr ls lt b">slice</code>项)转换成一个<code class="fe lq lr ls lt b">User</code> struct的<code class="fe lq lr ls lt b">slice</code>。如果不是这个函数，我们将需要从结果中提取每个项目，即一个<code class="fe lq lr ls lt b">map[string]types.AttributeValue</code>并为每个项目调用<code class="fe lq lr ls lt b">UnmarshalMap</code>。所以这很方便！</li></ul><p id="ff66" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><strong class="kw jg">终于——什么都有了！</strong></p><p id="069b" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><code class="fe lq lr ls lt b">GetAll</code>函数使用<code class="fe lq lr ls lt b">Scan</code>操作来检索<code class="fe lq lr ls lt b">DynamoDB</code>表中的所有记录。</p><blockquote class="lv lw lx"><p id="9f9e" class="ku kv ly kw b kx ky kg kz la lb kj lc lz le lf lg ma li lj lk mb lm ln lo lp ij bi translated"><em class="jf"/><code class="fe lq lr ls lt b"><em class="jf">Scan</em></code><em class="jf">操作遍历整个表(或二级索引),很有可能最终会消耗掉一大块所提供的吞吐量，尤其是在表很大的情况下。应该是你最后的手段——检查</em> <a class="ae lu" href="https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_Query.html" rel="noopener ugc nofollow" target="_blank"> <em class="jf">查询API </em> </a> <em class="jf">(或者</em><a class="ae lu" href="https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_BatchGetItem.html" rel="noopener ugc nofollow" target="_blank"><em class="jf">BatchGetItem</em></a><em class="jf">)是否对你的用例有效。</em></p></blockquote><pre class="ng nh ni nj gt nk lt nl bn nm nn bi"><span id="3ba2" class="no mk jf lt b be np nq l nr ns">func (d DB) GetAll() ([]model.User, error) {<br/><br/> result, err := d.client.Scan(context.Background(), &amp;dynamodb.ScanInput{<br/>  TableName: aws.String(d.table),<br/> })<br/><br/> if err != nil {<br/>  log.Println("Scan failed with error", err)<br/>  return []model.User{}, err<br/> }<br/><br/> users := []model.User{}<br/><br/> err = attributevalue.UnmarshalListOfMaps(result.Items, &amp;users)<br/><br/> if err != nil {<br/>  log.Println("UnmarshalMap failed with error", err)<br/>  return []model.User{}, err<br/> }<br/><br/> return users, nil<br/>}</span></pre></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h1 id="c2d4" class="mj mk jf bd ml mm mn mo mp mq mr ms mt kl mu km mv ko mw kp mx kr my ks mz na bi translated">包裹</h1><p id="436f" class="pw-post-body-paragraph ku kv jf kw b kx nb kg kz la nc kj lc ld nd lf lg lh ne lj lk ll nf ln lo lp ij bi translated">我希望你觉得这很有用，现在你已经知道了<code class="fe lq lr ls lt b">DynamoDB</code> Go SDK中的API可以处理简单的Go类型以及<code class="fe lq lr ls lt b">struct</code>、<code class="fe lq lr ls lt b">map</code>、<code class="fe lq lr ls lt b">slice</code>等。我鼓励你探索一些其他的细微差别，比如如何分别使用<a class="ae lu" href="https://pkg.go.dev/github.com/aws/aws-sdk-go-v2/feature/dynamodb/attributevalue#MarshalWithOptions" rel="noopener ugc nofollow" target="_blank">marshalwithpoptions</a>和<a class="ae lu" href="https://pkg.go.dev/github.com/aws/aws-sdk-go-v2/feature/dynamodb/attributevalue#UnmarshalWithOptions" rel="noopener ugc nofollow" target="_blank">unmarshalwithpoptions</a>定制<code class="fe lq lr ls lt b">Marshal</code>和<code class="fe lq lr ls lt b">Unmarshal</code>特性。</p></div></div>    
</body>
</html>