<html>
<head>
<title>Micro In Action, Coda: Distributed Cron Job</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">微操作，Coda:分布式Cron作业</h1>
<blockquote>原文：<a href="https://itnext.io/micro-in-action-coda-distributed-cron-job-a2b577885b24?source=collection_archive---------2-----------------------#2020-03-07">https://itnext.io/micro-in-action-coda-distributed-cron-job-a2b577885b24?source=collection_archive---------2-----------------------#2020-03-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/a5c15ef350639e3dc20989e6a7b20d47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N36LdoGtII8qmV8dYK_vQw.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">微在行动</figcaption></figure><p id="cee9" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu">2020 . 04 . 29更新:</strong> Micro在v2.5.0中已经移除了cron作业功能，代码示例将不再工作。但是基本原理仍然有效，您可以在etcd的帮助下实现自己的cron作业。</p><p id="c58d" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这是“微在行动”系列的最后一部分。</p><p id="39d6" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在浏览了前几篇文章中关于如何用Micro构建和使用微服务的主题后，现在我们来看最后一个主题:Cron Job。</p><h1 id="7204" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">分布式Cron作业很难</h1><p id="b110" class="pw-post-body-paragraph kf kg it kh b ki mb kk kl km mc ko kp kq md ks kt ku me kw kx ky mf la lb lc im bi translated">几乎每个系统都需要cron作业。他们的作用是做一些后台工作，可能在特定时间做一次，也可能每隔一段时间重复做一次。</p><p id="0a9c" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">当一个系统中只有一个节点时，这非常简单。我们将web服务和守护进程服务放在同一个节点中。只要唯一的节点启动，守护程序服务就会正常工作。</p><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div class="gh gi mg"><img src="../Images/7c6c90b9b697c118f9053b2ad78caabf.png" data-original-src="https://miro.medium.com/v2/resize:fit:816/format:webp/1*W1qscXEMg8MrcIe_rTiA5Q.png"/></div></figure><p id="3f6c" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">但是这在现代系统中很少见，因为我们必须考虑健壮性和可伸缩性。当节点数量超过一个时，你要面对两个问题:<strong class="kh iu">重复执行</strong>和<strong class="kh iu">单点故障</strong>。</p><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ml"><img src="../Images/99ca022774c6a601f5d8c5cf092f557c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1CxJsSvjm5NP6fmI2uDfSg.png"/></div></div></figure><p id="f93b" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如果我们简单地添加更多相同的节点而不做任何修改，这将导致重复执行。我们必须手动处理两个守护进程服务之间的冲突，这很容易出错。</p><p id="751d" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">一些“聪明”的家伙可能会改变他们的架构师，将工作功能从守护进程服务转移到web服务中，并将它们公开为web APIs或gRPC APIs。然后通过操作系统的crontab触发执行:</p><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/421167ea15ba775cb7838bc73c27949a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1234/format:webp/1*rYy8rDLOxEnvI7r-LZ9xfA.png"/></div></figure><p id="86ce" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这种架构的优点是消除了重复执行。当作业被OS crontab触发时，负载平衡器会将作业请求转发到一个节点。但是它仍然遭受单点故障。</p><p id="4259" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">大多数其他替代方案也不能同时解决这两个问题。例如:</p><p id="32cb" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">分离一个守护进程节点。问题:单点故障。</p><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/5359ca0e682052c38b6f05ae3372f928.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*sRAMwAL8ZHUhA84_tzRI0A.png"/></div></figure><p id="9dc8" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">分离多个守护进程节点。问题:重复执行。</p><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mo"><img src="../Images/b782e2d407fe89d62294794fb4525f91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*viKLYdswJnRC-Rae9_mnLw.png"/></div></div></figure><p id="8bab" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">那么，对于这种困境，正确的解决方案是什么呢？简而言之，我们在分布式系统中遇到了一个经典问题:<a class="ae mp" href="https://en.wikipedia.org/wiki/Leader_election" rel="noopener ugc nofollow" target="_blank"><strong class="kh iu"/></a>。</p><p id="4104" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们希望保持我们的服务节点是无状态的和相同的(大部分时间),这使得系统易于扩展。但是在某些情况下，必须在这些节点中选出一个领导节点来完成关键工作。</p><p id="bce2" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们不需要自己实现它，因为许多服务发现系统具有内置的领导者选举功能，例如etcd、zookeeper。</p><p id="a1cd" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">通过Leader Election，我们可以确保我们的cron作业在单个Leader节点上运行(没有重复执行)。并且当leader节点宕机时，另一个节点将接管领导权并运行后续作业(无单点故障)。</p><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mq"><img src="../Images/31a8b93c6809e29e2a53060ac3308360.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GbiAUlVVskPv21cXztreNQ.png"/></div></div></figure><p id="7178" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这正是Micro处理cron作业的方式。</p></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><h1 id="3c77" class="ld le it bd lf lg my li lj lk mz lm ln lo na lq lr ls nb lu lv lw nc ly lz ma bi translated">微型计算机中的Cron作业</h1><p id="7e6f" class="pw-post-body-paragraph kf kg it kh b ki mb kk kl km mc ko kp kq md ks kt ku me kw kx ky mf la lb lc im bi translated">Micro在包<code class="fe nd ne nf ng b">github.com/micro/go-micro/v2/sync</code>中提供了这个特性。</p><p id="18e5" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">和Micro的许多其他特性一样，这是一个“<strong class="kh iu">隐藏的</strong>之一。没有文档，没有测试用例，没有例子。通过源代码学习它，使用时风险自担😂。</p><p id="b559" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">可能<strong class="kh iu"> </strong>这篇文章是目前为止网上唯一的教程。</p><h2 id="22fe" class="nh le it bd lf ni nj dn lj nk nl dp ln kq nm nn lr ku no np lv ky nq nr lz ns bi translated">关键组件</h2><p id="b643" class="pw-post-body-paragraph kf kg it kh b ki mb kk kl km mc ko kp kq md ks kt ku me kw kx ky mf la lb lc im bi translated">这个特性由几个接口和结构组成。</p><p id="58af" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">最重要的组件是接口<code class="fe nd ne nf ng b">sync.Cron</code>:</p><pre class="mh mi mj mk gt nt ng nu nv aw nw bi"><span id="0d1a" class="nh le it ng b gy nx ny l nz oa">// Cron is a distributed scheduler using leader election<br/>// and distributed task runners. It uses the leader and<br/>// task interfaces.<br/>type <strong class="ng iu">Cron</strong> interface {<br/>   <strong class="ng iu">Schedule</strong>(task.Schedule, task.Command) error<br/>}</span></pre><p id="8a6d" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">此接口的唯一方法接受两个参数。</p><p id="a232" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">第一个参数<code class="fe nd ne nf ng b">task.Schedule</code>代表一个任务的调度信息。</p><pre class="mh mi mj mk gt nt ng nu nv aw nw bi"><span id="512e" class="nh le it ng b gy nx ny l nz oa">// Schedule represents a time or interval at which a task should run<br/>type Schedule struct {<br/>   // When to start the schedule. <strong class="ng iu">Zero time means immediately</strong><br/>   <strong class="ng iu">Time</strong> time.Time<br/>   // Non zero interval dictates an ongoing schedule<br/>   <strong class="ng iu">Interval</strong> time.Duration<br/>}</span></pre><p id="53e5" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这个结构中有两个字段，一个是作业的起始点，另一个是执行的间隔。</p><p id="b104" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">第二个参数<code class="fe nd ne nf ng b">task.Command</code>定义了作业命令。它有一个名字和一个函数指针。</p><pre class="mh mi mj mk gt nt ng nu nv aw nw bi"><span id="45ff" class="nh le it ng b gy nx ny l nz oa">// Command to be executed<br/>type Command struct {<br/>   Name string<br/>   Func func() error<br/>}</span></pre><h2 id="289e" class="nh le it bd lf ni nj dn lj nk nl dp ln kq nm nn lr ku no np lv ky nq nr lz ns bi translated">安排工作</h2><p id="b311" class="pw-post-body-paragraph kf kg it kh b ki mb kk kl km mc ko kp kq md ks kt ku me kw kx ky mf la lb lc im bi translated">有了上面提到的组件，我们可以轻松地安排作业:</p><pre class="mh mi mj mk gt nt ng nu nv aw nw bi"><span id="eda7" class="nh le it ng b gy nx ny l nz oa">package main<br/><br/>import (<br/>   "time"<br/><br/>   "github.com/micro/go-micro/v2"<br/>   "github.com/micro/go-micro/v2/<strong class="ng iu">sync</strong>"<br/>   "github.com/micro/go-micro/v2/<strong class="ng iu">sync</strong>/<strong class="ng iu">task</strong>"<br/>   log "github.com/micro/go-micro/v2/logger"<br/>)<br/><br/>func main() {<br/>   // New Service<br/>   service := micro.NewService(<br/>      micro.Name("com.foo.cron.example"), // name the client service<br/>   )<br/>   // Initialise service<br/>   service.Init()<br/><br/>   cron := <strong class="ng iu">sync.NewCron()</strong><br/>   cron.<strong class="ng iu">Schedule</strong>(<br/><strong class="ng iu">      task.Schedule</strong>{Interval: 10 * time.<em class="ob">Second</em>},<br/><strong class="ng iu">      task.Command</strong>{Name: "foo", Func: func() error {<br/>         log.Debug("finish command foo")<br/>         return nil<br/>      }},<br/>   )<br/><br/>   if err := service.Run(); err != nil {<br/>      log.Fatal(err)<br/>   }<br/>}</span></pre><p id="7643" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">像往常一样，我们创建并初始化了一个服务。然后用<code class="fe nd ne nf ng b">sync.NewCron()</code>创建一个<code class="fe nd ne nf ng b">Cron</code>界面。</p><p id="349e" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">之后，我们用<code class="fe nd ne nf ng b">cron.Schedule</code>调度一个简单的作业，每十秒钟打印一行日志。</p><p id="7ede" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">现在让我们开始吧:</p><pre class="mh mi mj mk gt nt ng nu nv aw nw bi"><span id="468a" class="nh le it ng b gy nx ny l nz oa">go run main.go</span><span id="4e67" class="nh le it ng b gy oc ny l nz oa">2020-04-03 18:49:59  level=info Starting [service] com.foo.cron.example<br/>2020-04-03 18:49:59  level=info Server [grpc] Listening on [::]:60752<br/>2020-04-03 18:49:59  level=info Registry [mdns] Registering node: com.foo.cron.example-1ae32da9-97e0-4acb-9f5a-aecdd83d6aa6</span></pre><p id="54fc" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">您可能期望每十秒钟就有一些东西输出到控制台。<strong class="kh iu">但是什么都没有。没有错误，也没有日志。<strong class="kh iu"> </strong>为什么？</strong></p><p id="992e" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">众所周知，Micro有一个约定:所有主要组件都有一个默认的轻量级实现。例如，我们有注册中心的mDNS实现和代理的HTTP实现。我们可以使用所有的功能，没有任何额外的依赖，这简化了本地开发。</p><p id="a8c0" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">但是Cron Job特性打破了这个惯例。使用<code class="fe nd ne nf ng b">sync.Cron</code>前，需要安装<strong class="kh iu"> etcd </strong>。<code class="fe nd ne nf ng b">sync.NewCron</code>的源代码是这样解释的:</p><pre class="mh mi mj mk gt nt ng nu nv aw nw bi"><span id="06a9" class="nh le it ng b gy nx ny l nz oa">func NewCron(opts ...Option) Cron {<br/>   ...<br/>   if options.Leader == nil {<br/>      <strong class="ng iu">options.Leader = etcd.NewLeader()</strong><br/>   }<br/>   ...<br/>}</span></pre><p id="4d83" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如果我们没有提供一个<code class="fe nd ne nf ng b">Leader</code>选项(其类型为<code class="fe nd ne nf ng b">leader.Leader</code>)，那么将会创建一个默认选项(<code class="fe nd ne nf ng b">etcd.NewLeader</code>)。这行代码创建了对etcd的依赖。如果你深究<code class="fe nd ne nf ng b">etcd.NewLeader</code>的代码，你会发现根本原因:</p><pre class="mh mi mj mk gt nt ng nu nv aw nw bi"><span id="c72b" class="nh le it ng b gy nx ny l nz oa">func <strong class="ng iu">NewLeader</strong>(opts ...leader.Option) leader.Leader {<br/>   ...<br/>   if len(endpoints) == 0 {<br/>      <strong class="ng iu">endpoints = []string{"http://127.0.0.1:2379"}</strong><br/>   }<br/>   ...<br/>}</span></pre><p id="c155" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">由于我们没有在127.0.0.1:2379 <strong class="kh iu">、</strong>上提供etcd，因此该作业将永远挂起，<strong class="kh iu">不会有任何错误输出</strong>。</p><p id="2408" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><code class="fe nd ne nf ng b">leader.Leader</code>选项是什么？我们为什么需要它？我们来看看<code class="fe nd ne nf ng b">leader.Leader</code>的定义:</p><pre class="mh mi mj mk gt nt ng nu nv aw nw bi"><span id="f3fb" class="nh le it ng b gy nx ny l nz oa">// Leader provides leadership election<br/>type Leader interface {<br/>   // elect leader<br/>   <strong class="ng iu">Elect</strong>(id string, opts ...ElectOption) (Elected, error)<br/>   // follow the leader<br/>   Follow() chan string<br/>}</span></pre><p id="fc85" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如前一节所述，要运行分布式cron作业，我们需要领导者选举的能力。<code class="fe nd ne nf ng b">leader.Leader</code>为此目的服务。在<code class="fe nd ne nf ng b">sync.Cron</code>的实现中，将调用方法<code class="fe nd ne nf ng b">Leader.Elect</code>来获取实际的领导者。</p><pre class="mh mi mj mk gt nt ng nu nv aw nw bi"><span id="07a8" class="nh le it ng b gy nx ny l nz oa">func (c *syncCron) <strong class="ng iu">Schedule</strong>(s task.Schedule, t task.Command) error {<br/>   id := fmt.Sprintf("%s-%s", s.String(), t.String())<br/><br/>   ...<br/>         e, err := c.opts.Leader.<strong class="ng iu">Elect</strong>(id)<br/>   ...<br/>}</span></pre><p id="83ef" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu">注:</strong>我认为<code class="fe nd ne nf ng b">Leader</code>是一个糟糕命名的例子，而<code class="fe nd ne nf ng b">Elector</code>会是一个更好的选择。</p><p id="7ff1" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">所以我们需要提供一个<code class="fe nd ne nf ng b">Leader</code>来初始化一个<code class="fe nd ne nf ng b">Cron</code>。我们可以选择etcd作为注册表，然后它可以重新用于领导者选举:</p><pre class="mh mi mj mk gt nt ng nu nv aw nw bi"><span id="8931" class="nh le it ng b gy nx ny l nz oa">import (<br/>   ...<br/>   "github.com/micro/go-micro/v2/sync/<strong class="ng iu">leader</strong>"<br/>   "github.com/micro/go-micro/v2/sync/leader/<strong class="ng iu">etcd</strong>"<br/>   ...<br/>)<br/><br/>func main() {<br/>   // New Service<br/>   service := micro.NewService(<br/>      micro.Name("com.foo.cron.example"), // name the client service<br/>   )<br/>   // Initialise service<br/>   service.Init()<br/><br/>   // get etcd node list from registry<br/>   <strong class="ng iu">etcdList</strong> := service.Options().Registry.Options().Addrs<br/>   // build leader<br/>   lead := <strong class="ng iu">etcd.NewLeader</strong>(leader.Nodes(etcdList...))<br/>   <br/>   cron := sync.NewCron(<strong class="ng iu">sync.WithLeader(lead)</strong>)<br/>   cron.Schedule(<br/>      task.Schedule{Interval: 10 * time.<em class="ob">Second</em>},<br/>      task.Command{Name: "foo", Func: func() error {<br/>         log.Info("finish command foo")<br/>         return nil<br/>      }},<br/>   )<br/><br/>   if err := service.Run(); err != nil {<br/>      log.Fatal(err)<br/>   }<br/>}</span></pre><p id="8393" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">然后使用注册表参数运行程序:</p><pre class="mh mi mj mk gt nt ng nu nv aw nw bi"><span id="ae92" class="nh le it ng b gy nx ny l nz oa">go run main.go <strong class="ng iu">--registry=etcd --registry_address=etcd1.foo.com:2379,etcd2.foo.com:2379,etcd3.foo.com:2379</strong><br/>2020-04-03 18:52:46  level=info Starting [service] com.foo.cron.example<br/>2020-04-03 18:52:46  level=info Server [grpc] Listening on [::]:61094<br/>2020-04-03 18:52:46  level=info Registry [etcd] Registering node: com.foo.cron.example-da16c259-302a-4247-83aa-2d0fc1d3a4e2<br/>2020-04-03 18:52:56  level=info <strong class="ng iu">[cron] executing command foo</strong><br/>2020-04-03 18:52:56  level=info <strong class="ng iu">finish command foo</strong><br/>...</span></pre><p id="17fb" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">最后，我们在Micro中引导一个cron作业。</p><p id="e0b2" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu"> Gotcha: </strong>默认情况下，Micro的Cron作业特性依赖于etcd。</p><p id="0386" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">让我们引导另外两个节点(节点B、节点C)。因为第一个节点(节点A)现在是领导者，所以不会对它们执行任何作业。</p><p id="8803" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">然后我们关闭节点A，几秒钟后，领导权将自动转移到节点B或节点C。因此，cron作业将在新的leader节点上运行。</p><p id="5a0c" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这就是我们想要实现的:没有单点故障，没有重复执行。</p><h2 id="db01" class="nh le it bd lf ni nj dn lj nk nl dp ln kq nm nn lr ku no np lv ky nq nr lz ns bi translated">更改作业计划的起点</h2><p id="ba48" class="pw-post-body-paragraph kf kg it kh b ki mb kk kl km mc ko kp kq md ks kt ku me kw kx ky mf la lb lc im bi translated">有时您需要工作在固定时间开始，尝试修改<code class="fe nd ne nf ng b">task.Schedule</code>的<code class="fe nd ne nf ng b">Time</code>字段:</p><pre class="mh mi mj mk gt nt ng nu nv aw nw bi"><span id="2a85" class="nh le it ng b gy nx ny l nz oa">// start from the next New Year's Day<br/>startPoint, _ := time.Parse("2006-01-01", "2021-01-01")<br/>cron.Schedule(<br/>   task.Schedule{<br/><strong class="ng iu">      Time:     startPoint,</strong><br/>      Interval: 10 * time.<em class="ob">Second,<br/>   </em>},<br/>   task.Command{Name: "foo", Func: func() error {<br/>      log.Info("finish command foo")<br/>      return nil<br/>   }},<br/>)</span></pre><p id="8094" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">它会像你期望的那样工作。</p><p id="9e5b" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">但是，如果您希望作业在预定时间后一分钟开始，您可以尝试:</p><pre class="mh mi mj mk gt nt ng nu nv aw nw bi"><span id="67fa" class="nh le it ng b gy nx ny l nz oa">cron.Schedule(<br/>   task.Schedule{<br/>      Time:     <strong class="ng iu">time.Now().Add(time.<em class="ob">Minute</em>),</strong><br/>      Interval: 10 * time.<em class="ob">Second</em>,<br/>   },<br/>   task.Command{Name: "foo", Func: func() error {<br/>      log.Info("finish command foo")<br/>      return nil<br/>   }},<br/>)</span></pre><p id="7371" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">并且<strong class="kh iu">您会感到失望</strong>，因为所有节点上都将出现重复执行。原因在于<code class="fe nd ne nf ng b">sync.Cron</code>和<code class="fe nd ne nf ng b">task.Schedule</code>的实现</p><pre class="mh mi mj mk gt nt ng nu nv aw nw bi"><span id="cb3a" class="nh le it ng b gy nx ny l nz oa">//cron.go<br/>func (c *syncCron) <strong class="ng iu">Schedule</strong>(s task.Schedule, t task.Command) error {<br/>   id := fmt.Sprintf("%s-%s", <strong class="ng iu">s.String()</strong>, t.String())<br/><br/>   ...<br/>         e, err := c.opts.Leader.Elect(<strong class="ng iu">id</strong>)<br/>   ...<br/>}</span><span id="b865" class="nh le it ng b gy oc ny l nz oa">//task.go<br/>func (s Schedule) String() string {<br/>   return fmt.Sprintf("%d-%d", <strong class="ng iu">s.Time.Unix()</strong>, s.Interval)<br/>}</span></pre><p id="f9da" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">选举id取决于<code class="fe nd ne nf ng b">Schedule.String()</code>而<code class="fe nd ne nf ng b">Schedule.String()</code>取决于<code class="fe nd ne nf ng b">Schedule.Time<strong class="kh iu">.</strong></code></p><p id="1346" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">当我们选择相对时间作为起点时，每个节点将形成其唯一的选举id，因为它们可能会在不同的时间戳进行引导。</p><p id="0aa9" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">然后每个节点成为自己选举组的领袖。</p><p id="0ed2" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu">明白了</strong>:千万不要将相对时间指定为工作开始时间。</p></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><h1 id="e6a2" class="ld le it bd lf lg my li lj lk mz lm ln lo na lq lr ls nb lu lv lw nc ly lz ma bi translated">摘要</h1><p id="76d1" class="pw-post-body-paragraph kf kg it kh b ki mb kk kl km mc ko kp kq md ks kt ku me kw kx ky mf la lb lc im bi translated">在分布式系统中实现Cron作业是很棘手的。Micro提供了一个初级而优雅的解决方案。这个解决方案可以覆盖我们的大多数用例，尽管它仍然缺少一些高级特性，比如crontab expression。</p><p id="909d" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">小心那些陷阱，你最终会驯服它们的。这个建议适用于cron作业特性和整个微框架。</p><p id="ab3f" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">所以我要结束这一系列的文章。感谢阅读。</p><p id="ede3" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">写这个系列对我来说也是一个学习的过程。它让我相信<strong class="kh iu"> Micro是一个伟大的工具，它值得你花时间，并且将帮助你以一种极其简单的方式构建分布式系统</strong>。</p><p id="b540" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">它有缺点，但不是不可接受的。随着新版本的发布，它变得越来越好。我的文章基于v2.4.0，我很高兴尝试新版本。(<strong class="kh iu">但是不要急着在生产环境中使用最新版本。如果你看过这个系列，你应该知道原因。)</strong></p><p id="9a44" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">未来，我会继续写关于微的文章，但不是系列。它们将是关注某些特定主题的独立文章。</p><p id="00b7" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如果你想在新文章发表后得到通知，请在Medium/Twitter上关注我(@dche423)。</p><p id="adb9" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">回头见。谢了。</p><p id="77b0" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">—丹·车</p></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><p id="f72e" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">另请参见:</p><ul class=""><li id="90ed" class="od oe it kh b ki kj km kn kq of ku og ky oh lc oi oj ok ol bi translated"><a class="ae mp" rel="noopener ugc nofollow" target="_blank" href="/micro-in-action-getting-started-a79916ae3cac"> Micro In Action，第1部分:入门</a></li><li id="7d60" class="od oe it kh b ki om km on kq oo ku op ky oq lc oi oj ok ol bi translated"><a class="ae mp" rel="noopener ugc nofollow" target="_blank" href="/micro-in-action-part-2-71230f01d6fb"> Micro In Action，第2部分:Bootstrap终极指南</a></li><li id="0c11" class="od oe it kh b ki om km on kq oo ku op ky oq lc oi oj ok ol bi translated"><a class="ae mp" rel="noopener ugc nofollow" target="_blank" href="/micro-in-action-part-3-calling-a-service-55d865928f11"> Micro在行动，第3部分:调用服务</a></li><li id="66ed" class="od oe it kh b ki om km on kq oo ku op ky oq lc oi oj ok ol bi translated"><a class="ae mp" rel="noopener ugc nofollow" target="_blank" href="/micro-in-action-part4-pub-sub-564f3b054ecd">微在行动，第4部分:发布/订阅</a></li><li id="9d5e" class="od oe it kh b ki om km on kq oo ku op ky oq lc oi oj ok ol bi translated"><a class="ae mp" rel="noopener ugc nofollow" target="_blank" href="/micro-in-action-part-5-message-broker-a3decf07f26a"> Micro在行动，第5部分:消息代理</a></li><li id="2d80" class="od oe it kh b ki om km on kq oo ku op ky oq lc oi oj ok ol bi translated"><a class="ae mp" rel="noopener ugc nofollow" target="_blank" href="/micro-in-action-part6-service-discovery-f988988e5936">微在行动，第6部分:服务发现</a></li><li id="03fc" class="od oe it kh b ki om km on kq oo ku op ky oq lc oi oj ok ol bi translated"><a class="ae mp" rel="noopener ugc nofollow" target="_blank" href="/micro-in-action-7-circuit-breaker-rate-limiter-431ccff6a120">微动动作，第7部分:断路器&amp;限速器</a></li><li id="2292" class="od oe it kh b ki om km on kq oo ku op ky oq lc oi oj ok ol bi translated"><a class="ae mp" href="https://medium.com/@dche423/micro-in-action-1be29b057f2d" rel="noopener">微在行动的索引页</a></li></ul></div></div>    
</body>
</html>