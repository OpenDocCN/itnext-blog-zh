<html>
<head>
<title>Tame large React projects by consistently applying these patterns and rules</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过一致地应用这些模式和规则来驯服大型React项目</h1>
<blockquote>原文：<a href="https://itnext.io/tame-large-react-projects-by-consistently-applying-these-patterns-and-rules-b7c70baf5105?source=collection_archive---------0-----------------------#2021-06-17">https://itnext.io/tame-large-react-projects-by-consistently-applying-these-patterns-and-rules-b7c70baf5105?source=collection_archive---------0-----------------------#2021-06-17</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><figure class="it iu gq gs iv iw gi gj paragraph-image"><div role="button" tabindex="0" class="ix iy di iz bf ja"><div class="gi gj is"><img src="../Images/e14aa091fc320221b757feca13fa4b0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5QXdrSUwt8pEsF20RoQUUw.jpeg"/></div></div><figcaption class="jd je gk gi gj jf jg bd b be z dk translated">就像沙子一样，你可以把不同种类的组件放进不同的桶里。(<a class="ae jh" href="https://www.flickr.com/photos/ddebold/15991919514" rel="noopener ugc nofollow" target="_blank">照片由Don DeBold </a>拍摄，并在<a class="ae jh" href="https://creativecommons.org/licenses/by/2.0/" rel="noopener ugc nofollow" target="_blank">许可</a>条款下使用)</figcaption></figure><div class=""/><div class=""><h2 id="bf24" class="pw-subtitle-paragraph kh jj jk bd b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dk translated">维护和处理纯粹和简单的vs显示，以及自我管理的组件</h2></div><p id="ed37" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">作为团队的一员，我最近一直在做一个项目，构建一个React组件库，用于许多相关的企业环境中。作为该过程的一部分，我们发现根据组件从哪里获得数据来对组件进行分类是有意义的。</p><p id="0206" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">我们还确定了一些规则，帮助我们保持组件的一致性和可预测性。</p><h1 id="f070" class="lv lw jk bd lx ly lz ma mb mc md me mf kq mg kr mh kt mi ku mj kw mk kx ml mm bi translated">组件类型</h1><p id="df90" class="pw-post-body-paragraph kz la jk lb b lc mn kl le lf mo ko lh li mp lk ll lm mq lo lp lq mr ls lt lu in bi translated">React组件可以从几个地方获取数据:</p><ol class=""><li id="275d" class="ms mt jk lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated">组件从<code class="fe nb nc nd ne b">props</code>获取<strong class="lb jl">其所有</strong>数据，或者</li><li id="f7e7" class="ms mt jk lb b lc nf lf ng li nh lm ni lq nj lu mx my mz na bi translated">它从<code class="fe nb nc nd ne b">props</code>获得一些数据，从其他地方获得一些<code class="fe nb nc nd ne b">context</code>、<code class="fe nb nc nd ne b">state</code>、<code class="fe nb nc nd ne b">app-state</code>等</li></ol><p id="3d6b" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">进一步缩小范围，我们发现，在仅从<code class="fe nb nc nd ne b">props</code>获取数据的组件集合中，一些可以被视为<em class="nk">纯</em>组件，但是我们也有<em class="nk">可记忆</em>组件，以及<em class="nk">不可记忆</em>组件，并且不是所有的<em class="nk">可记忆</em>组件都一定是<em class="nk">纯</em>。</p><h2 id="49cf" class="nl lw jk bd lx nm nn dn mb no np dp mf li nq nr mh lm ns nt mj lq nu nv ml nw bi translated">纯成分</h2><p id="0422" class="pw-post-body-paragraph kz la jk lb b lc mn kl le lf mo ko lh li mp lk ll lm mq lo lp lq mr ls lt lu in bi translated">一个<em class="nk">纯</em>组件是一个当提供相同的<code class="fe nb nc nd ne b">props</code>时总是呈现相同输出的组件。<em class="nk">纯</em>组件不从除了它们的<code class="fe nb nc nd ne b">props</code>之外的任何地方拉数据，它们不管理任何内部<code class="fe nb nc nd ne b">state</code>，并且，如果<code class="fe nb nc nd ne b">props</code>是简单的，组件可以被<em class="nk">记忆</em>以确保它仅在其<code class="fe nb nc nd ne b">props</code>改变时才重新呈现。<em class="nk">纯</em>成分无副作用。</p><p id="5617" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">例如:</p><pre class="nx ny nz oa gu ob ne oc od aw oe bi"><span id="2223" class="nl lw jk ne b gz of og l oh oi">import { memo } from 'react'<br/>import { string } from 'prop-types'</span><span id="5d66" class="nl lw jk ne b gz oj og l oh oi">const Wylde = ({ city }) =&gt; (<br/>  &lt;div&gt;<br/>    As pure as {city} snow<br/>  &lt;/div&gt;<br/>)<br/>Wylde.propTypes = { city: string.isRequired }</span><span id="9c6e" class="nl lw jk ne b gz oj og l oh oi">export default memo(Wylde)</span></pre><h2 id="170e" class="nl lw jk bd lx nm nn dn mb no np dp mf li nq nr mh lm ns nt mj lq nu nv ml nw bi translated">我说的“简单”是什么意思？</h2><p id="2df8" class="pw-post-body-paragraph kz la jk lb b lc mn kl le lf mo ko lh li mp lk ll lm mq lo lp lq mr ls lt lu in bi translated">React <code class="fe nb nc nd ne b"><a class="ae jh" href="https://reactjs.org/docs/react-api.html#reactmemo" rel="noopener ugc nofollow" target="_blank">memo</a></code>函数将一个<em class="nk">纯</em>组件作为输入，并返回一个相对于<code class="fe nb nc nd ne b">props</code>被<em class="nk">缓存</em>的组件，如果所提供的<code class="fe nb nc nd ne b">prop</code>值自上次渲染后没有改变，则阻止其重新渲染。这是一个很好的优化，但经常被误用。</p><p id="4aab" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">默认情况下，<code class="fe nb nc nd ne b">memo</code>的问题在于，使用简单的<code class="fe nb nc nd ne b">===</code>等式来比较<code class="fe nb nc nd ne b">props</code>。因此，如果你的<code class="fe nb nc nd ne b">prop</code>是一个函数、数组、对象，或者基本上是任何不能通过<code class="fe nb nc nd ne b">===</code>进行比较的东西，那么<code class="fe nb nc nd ne b">memo</code>仍然允许组件重新渲染。</p><h2 id="f163" class="nl lw jk bd lx nm nn dn mb no np dp mf li nq nr mh lm ns nt mj lq nu nv ml nw bi translated">添加杂质</h2><p id="8be9" class="pw-post-body-paragraph kz la jk lb b lc mn kl le lf mo ko lh li mp lk ll lm mq lo lp lq mr ls lt lu in bi translated">你可以提供第二个参数，一个<code class="fe nb nc nd ne b">arePropsEqual</code>函数给<code class="fe nb nc nd ne b">memo</code>函数来覆盖默认行为，但是如果你的比较逻辑比你的渲染代码更复杂，那么这只是浪费时间。如果你的<code class="fe nb nc nd ne b">arePropsEqual</code>函数忽略了任何一个<code class="fe nb nc nd ne b">props</code>，那么你的组件就不再是纯粹的<em class="nk">。</em></p><p id="0f13" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">以下面的组件为例:</p><pre class="nx ny nz oa gu ob ne oc od aw oe bi"><span id="dc38" class="nl lw jk ne b gz of og l oh oi">import { memo } from 'react'<br/>import { string, func } from 'prop-types'</span><span id="2954" class="nl lw jk ne b gz oj og l oh oi">const Clicky = ({ label, onClick }) =&gt; (<br/>  &lt;button onClick={onClick}&gt;{label}&lt;/button&gt;<br/>)<br/>Clicky.propTypes = {<br/>  label: string.isRequired,<br/>  onClick: func.isRequired<br/>}</span><span id="f952" class="nl lw jk ne b gz oj og l oh oi">const arePropsEqual = (prev, next) =&gt;<br/>  prev.label === next.label</span><span id="30c8" class="nl lw jk ne b gz oj og l oh oi">export default memo(Clicky, arePropsEqual)</span></pre><p id="a6d7" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">这只会在<code class="fe nb nc nd ne b">label</code>改变时重新渲染，并且会忽略<code class="fe nb nc nd ne b">onClick</code>函数中的任何差异。这可能会产生意想不到的后果。它不再是一个纯粹的<em class="nk">组件，因为如果你提供一个不同的<code class="fe nb nc nd ne b">onClick</code>函数，你仍然会得到传递给<code class="fe nb nc nd ne b">button</code>的旧函数，因为组件不会重新呈现。</em></p><p id="bd98" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">同样的，对<em class="nk">来说，把一个数组、函数或对象当作道具的组件是没有意义的。</em></p><pre class="nx ny nz oa gu ob ne oc od aw oe bi"><span id="401b" class="nl lw jk ne b gz of og l oh oi">import { memo } from 'react'<br/>import { arrayOf, string } from 'prop-types'</span><span id="59a1" class="nl lw jk ne b gz oj og l oh oi">const Listy = ({ items }) =&gt; (<br/>  &lt;ul&gt;<br/>    {items.map(item =&gt; (<br/>      &lt;li key={item}&gt;{item}&lt;/li&gt;<br/>    )}<br/>  &lt;/ul&gt;<br/>)<br/>Listy.propTypes = { items: arrayOf(string).isRequired }</span><span id="a61d" class="nl lw jk ne b gz oj og l oh oi">const arePropsEqual = (prev, next) =&gt;<br/>  prev.items.reduce((acc, elem, i) =&gt;<br/>    prev.items[i] === next.items[i]<br/>      ? acc<br/>      : [...acc, elem], []).length === 0</span><span id="b059" class="nl lw jk ne b gz oj og l oh oi">export default memo(Listy, arePropsEqual)</span></pre><p id="8181" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">如果列表长于几个条目，那么<code class="fe nb nc nd ne b">Listy</code>组件可能会花更多的时间来比较数组，而不是重新呈现列表。然而它仍然是一个纯粹的组件；只是一个低效的。长的对象列表不应该被传递给一个<em class="nk"> memoised </em>函数。事实上，我认为如果一个组件的任何属性不是布尔值、字符串或数字，你就不应该费心去记忆它。</p><p id="1a98" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">我应用以下分类:组件是</p><ol class=""><li id="ce1a" class="ms mt jk lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated"><em class="nk">简单</em>如果是<em class="nk">记忆</em>纯组件，</li><li id="b26f" class="ms mt jk lb b lc nf lf ng li nh lm ni lq nj lu mx my mz na bi translated"><em class="nk">如果是<em class="nk">纯</em>而不是<em class="nk">记忆</em>则显示</em>，否则</li><li id="a756" class="ms mt jk lb b lc nf lf ng li nh lm ni lq nj lu mx my mz na bi translated">如果它从<code class="fe nb nc nd ne b">props</code>以外的地方获取数据，则它是<em class="nk">自管理的</em>。</li></ol><h1 id="be8f" class="lv lw jk bd lx ly lz ma mb mc md me mf kq mg kr mh kt mi ku mj kw mk kx ml mm bi translated">组件文件结构</h1><p id="1eed" class="pw-post-body-paragraph kz la jk lb b lc mn kl le lf mo ko lh li mp lk ll lm mq lo lp lq mr ls lt lu in bi translated">构建组件库时，以一致的方式对组件的组成部分进行分组非常重要。该库的细节取决于组件是简单的、<em class="nk">显示的</em>还是自管理的<em class="nk">。</em></p><h2 id="e406" class="nl lw jk bd lx nm nn dn mb no np dp mf li nq nr mh lm ns nt mj lq nu nv ml nw bi translated">简单组件</h2><pre class="nx ny nz oa gu ob ne oc od aw oe bi"><span id="59ab" class="nl lw jk ne b gz of og l oh oi">components/Simple/<br/>  index.js<br/>  index.spec.js<br/>  Simple.js<br/>  Simple.spec.js<br/>  Simple.stories.js<br/>  config.js<br/>  utils.js<br/>  utils.spec.js</span></pre><p id="2bc6" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">一个简单的<em class="nk">组件的<code class="fe nb nc nd ne b">index.js</code>文件将被</em></p><pre class="nx ny nz oa gu ob ne oc od aw oe bi"><span id="ccd3" class="nl lw jk ne b gz of og l oh oi">export { default } from './Simple'</span></pre><blockquote class="ok ol om"><p id="9311" class="kz la nk lb b lc ld kl le lf lg ko lh on lj lk ll oo ln lo lp op lr ls lt lu in bi translated">规则:避免从一个文件中导出多个组件。</p></blockquote><p id="4ca9" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><code class="fe nb nc nd ne b">index.spec.js</code>文件将测试底层组件正在被导出。</p><pre class="nx ny nz oa gu ob ne oc od aw oe bi"><span id="6b5a" class="nl lw jk ne b gz of og l oh oi">import Index from '.'<br/>import Simple from './Simple'</span><span id="c28f" class="nl lw jk ne b gz oj og l oh oi">describe('components/Simple', () =&gt; {<br/>  it('is the same component', () =&gt; {<br/>    expect(Index).toBe(Simple)<br/>  })<br/>})</span></pre><p id="16b3" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">实际的<code class="fe nb nc nd ne b">Simple.js</code>必须是一个<em class="nk">纯</em>，<em class="nk">由简单的<code class="fe nb nc nd ne b">props</code>组成的</em>组件。</p><pre class="nx ny nz oa gu ob ne oc od aw oe bi"><span id="885c" class="nl lw jk ne b gz of og l oh oi">import { memo } from 'react'<br/>import { bool, number, string } from 'prop-types'</span><span id="cf2b" class="nl lw jk ne b gz oj og l oh oi">const Simple = ({ small, count, label }) =&gt; small<br/>  ? (<br/>      &lt;div&gt;&lt;span&gt;{count}&lt;/span&gt;&lt;/div&gt;<br/>    )<br/>  : (<br/>      &lt;div&gt;<br/>        &lt;label&gt;{label}&lt;/label&gt;<br/>        &lt;span&gt;{count}&lt;/span&gt;<br/>      &lt;/div&gt;<br/>    )</span><span id="9880" class="nl lw jk ne b gz oj og l oh oi">Simple.propTypes = {<br/>  small: bool,<br/>  count: number.isRequired,<br/>  label: string.isRequired<br/>}<br/>Simple.defaultProps = { small: false }</span><span id="86f8" class="nl lw jk ne b gz oj og l oh oi">export default memo(Simple)</span></pre><p id="820c" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">你会注意到我在上面默认了<code class="fe nb nc nd ne b">small</code>到<code class="fe nb nc nd ne b">false</code>。原因是我一直应用的一条规则，简单来说就是:</p><blockquote class="ok ol om"><p id="c2d4" class="kz la nk lb b lc ld kl le lf lg ko lh on lj lk ll oo ln lo lp op lr ls lt lu in bi translated">规则:所有<code class="fe nb nc nd ne b">boolean</code>道具必须可选，默认为<code class="fe nb nc nd ne b">false</code>。</p></blockquote><p id="0481" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">让你可以像这样使用组件</p><pre class="nx ny nz oa gu ob ne oc od aw oe bi"><span id="dbb7" class="nl lw jk ne b gz of og l oh oi">&lt;Simple count={c} label={l} /&gt;</span></pre><p id="76b1" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">如果你想让它显示<code class="fe nb nc nd ne b">count</code>和<code class="fe nb nc nd ne b">label</code>，或者</p><pre class="nx ny nz oa gu ob ne oc od aw oe bi"><span id="735e" class="nl lw jk ne b gz of og l oh oi">&lt;Simple small count={c} label={l} /&gt;</span></pre><p id="391b" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">如果你想让它只显示<code class="fe nb nc nd ne b">count</code>。</p><p id="3c1e" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><code class="fe nb nc nd ne b">Simple.spec.js</code>简单地测试，给定一个合理的输入范围，它将提供有效的输出。</p><pre class="nx ny nz oa gu ob ne oc od aw oe bi"><span id="292e" class="nl lw jk ne b gz of og l oh oi">import { render } from '@testing-library/react'</span><span id="d6df" class="nl lw jk ne b gz oj og l oh oi">import Simple from './Simple'</span><span id="ff22" class="nl lw jk ne b gz oj og l oh oi">const label = 'some test label'</span><span id="1010" class="nl lw jk ne b gz oj og l oh oi">describe.each`<br/>  small        | count<br/>  ${undefined} | ${0}<br/>  ${false}     | ${1}<br/>  ${true}      | ${2}<br/>`('components/Simple/Simple',<br/>  ({ small, count }) =&gt; {<br/>    let component</span><span id="b42b" class="nl lw jk ne b gz oj og l oh oi">    beforeAll(() =&gt; {<br/>      component = render(&lt;Simple<br/>        small={small}<br/>        count={count}<br/>        label={label}<br/>      /&gt;)<br/>    })</span><span id="3131" class="nl lw jk ne b gz oj og l oh oi">    it('rendered okay', () =&gt; {<br/>      expect(component.toFragment()).toMatchSnapshot()<br/>    })<br/> })</span></pre><p id="049e" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><code class="fe nb nc nd ne b">Simple.stories.js</code>提供了单独演示组件的<a class="ae jh" href="https://storybook.js.org" rel="noopener ugc nofollow" target="_blank">故事书</a>故事。这通常既用于组件的文档，也用于组件开发和维护时的用户验收测试。</p><p id="90b4" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><code class="fe nb nc nd ne b">config.js</code>文件是可选的，用于包含任何组件特定的配置，同样<code class="fe nb nc nd ne b">utils.js</code>也是可选的，用于保存组件可能需要的任何<em class="nk">纯</em>功能。<em class="nk">简单的</em>组件不会有任何<code class="fe nb nc nd ne b">hooks</code>。组件的故事书<code class="fe nb nc nd ne b">stories</code>可能也会访问<code class="fe nb nc nd ne b">config</code>和<code class="fe nb nc nd ne b">utils</code>。</p><h2 id="addc" class="nl lw jk bd lx nm nn dn mb no np dp mf li nq nr mh lm ns nt mj lq nu nv ml nw bi translated">显示组件</h2><p id="3c75" class="pw-post-body-paragraph kz la jk lb b lc mn kl le lf mo ko lh li mp lk ll lm mq lo lp lq mr ls lt lu in bi translated">一个<em class="nk">显示</em>组件的文件夹结构本质上与一个<em class="nk">简单</em>组件相同，只是它可能包括一个可选的<code class="fe nb nc nd ne b">shapes.js</code>文件。</p><pre class="nx ny nz oa gu ob ne oc od aw oe bi"><span id="5df6" class="nl lw jk ne b gz of og l oh oi">components/Display/<br/>  index.js<br/>  index.spec.js<br/>  Display.js<br/>  Display.spec.js<br/>  Display.stories.js<br/>  config.js<br/>  shapes.js<br/>  utils.js<br/>  utils.spec.js</span></pre><p id="f222" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">在我们的<code class="fe nb nc nd ne b">shapes.js</code>中，我们将只导出我们正在展示的东西的形状。</p><pre class="nx ny nz oa gu ob ne oc od aw oe bi"><span id="92bf" class="nl lw jk ne b gz of og l oh oi">import { string } from 'prop-types'</span><span id="5df4" class="nl lw jk ne b gz oj og l oh oi">export const thingShape = {<br/>  id: string.isRequired,<br/>  text: string.isRequired,<br/>  title: string.isRequired<br/>}</span></pre><p id="56d0" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">在这种情况下，<code class="fe nb nc nd ne b">Display.js</code>可能类似于</p><pre class="nx ny nz oa gu ob ne oc od aw oe bi"><span id="f859" class="nl lw jk ne b gz of og l oh oi">import { Fragment } from 'react'<br/>import { arrayOf, func, shape } from 'prop-types'</span><span id="a6e8" class="nl lw jk ne b gz oj og l oh oi">import { thingShape } from './shapes'</span><span id="8aa5" class="nl lw jk ne b gz oj og l oh oi">const Display = ({ things, handleClick }) =&gt; (<br/>  &lt;dl&gt;<br/>    {things.map(({ title, text, id }) =&gt; (<br/>      &lt;Fragment key={id}&gt;<br/>       &lt;dt&gt;<br/>         &lt;button<br/>           type="text"<br/>           onClick={handleClick(id)}<br/>           data-testid={id}<br/>         &gt;<br/>           {title}<br/>         &lt;/button&gt;<br/>       &lt;/dt&gt;<br/>       &lt;dd&gt;{text}&lt;/dd&gt;<br/>      &lt;/Fragment&gt;<br/>     )}<br/>  &lt;/dl&gt;<br/>)<br/>Display.propTypes = {<br/>  things: arrayOf(shape(thingShape)).isRequired,<br/>  handleClick: func.isRequired // id =&gt; evt =&gt; { }<br/>}</span><span id="6609" class="nl lw jk ne b gz oj og l oh oi">export default Display</span></pre><p id="58c1" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">虽然这仍然是一个纯粹的组件，但由于它被提供了一个对象数组和一个函数作为<code class="fe nb nc nd ne b">props</code>，所以不容易被<em class="nk">记忆。</em></p><p id="d0d2" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">像以前一样，我们将像<code class="fe nb nc nd ne b">Display.spec.js</code>一样测试它:</p><pre class="nx ny nz oa gu ob ne oc od aw oe bi"><span id="f24d" class="nl lw jk ne b gz of og l oh oi">import { render, screen, fireEvent } from '@testing-library/react'</span><span id="43e3" class="nl lw jk ne b gz oj og l oh oi">import Display from './Display'</span><span id="e626" class="nl lw jk ne b gz oj og l oh oi">const makeThing = (id, title, text) = ({ id, title, text })<br/>const theThings = [<br/>  makeThing('1', 'One', 'This is the one'),<br/>  makeThing('2', 'Two', 'This is number two'),<br/>  makeThing('3', 'Three', 'The magic number')<br/>]</span><span id="11b5" class="nl lw jk ne b gz oj og l oh oi">describe.each`<br/>  things<br/>  ${[]}<br/>  ${theThings}<br/>`('components/Display/Display',<br/>  ({ things }) =&gt; {<br/>    const onClick = jest.fn()<br/>    const handleClick = jest.fn().mockReturnValue(onClick)<br/>    let component</span><span id="b427" class="nl lw jk ne b gz oj og l oh oi">    beforeAll(() =&gt; {<br/>      component = render(&lt;Display<br/>        things={things}<br/>        handleClick={handleClick}<br/>      /&gt;)<br/>      const firstButton = screen.getByTestId('1')<br/>      fireEvent.click(firstButton)<br/>    })</span><span id="7c1d" class="nl lw jk ne b gz oj og l oh oi">    it('used the click handler', () =&gt; {<br/>      expect(handleClick).toHaveBeenCalled()<br/>    })</span><span id="a6ec" class="nl lw jk ne b gz oj og l oh oi">    it('rendered okay', () =&gt; {<br/>      expect(component.toFragment()).toMatchSnapshot()<br/>    })</span><span id="1168" class="nl lw jk ne b gz oj og l oh oi">    it('clicking worked as expected', () =&gt; {<br/>      expect(onClick).toHaveBeenCalled()<br/>    })<br/> })</span></pre><p id="5a5e" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">同样，<em class="nk">显示</em>组件是<em class="nk">纯</em>组件，因此不会有任何挂钩，但是它们可以引用<em class="nk">纯</em>实用函数和不可变的配置数据。<em class="nk">显示</em>组件会有故事书故事，可以引用本地<code class="fe nb nc nd ne b">utils</code>或<code class="fe nb nc nd ne b">config</code>，本地<code class="fe nb nc nd ne b">utils</code>只是<em class="nk">纯</em>功能，易于测试。</p><h2 id="10d9" class="nl lw jk bd lx nm nn dn mb no np dp mf li nq nr mh lm ns nt mj lq nu nv ml nw bi translated">自我管理的组件</h2><p id="10a3" class="pw-post-body-paragraph kz la jk lb b lc mn kl le lf mo ko lh li mp lk ll lm mq lo lp lq mr ls lt lu in bi translated">最后一类组件不是纯粹的组件。他们可能会跟踪一些内部状态，或者他们可能会从外部应用程序状态(如Redux store或React上下文)引入状态。他们可能会使用像<code class="fe nb nc nd ne b">useEffect</code>这样的钩子，使得组件在安装和卸载时触发副作用。</p><pre class="nx ny nz oa gu ob ne oc od aw oe bi"><span id="37bb" class="nl lw jk ne b gz of og l oh oi">components/SelfManaged/<br/>  index.js<br/>  index.spec.js<br/>  index.stories.js<br/>  SelfManaged.js<br/>  SelfManaged.spec.js<br/>  SelfManaged.stories.js<br/>  config.js<br/>  hooks.js<br/>  hooks.spec.js<br/>  shapes.js<br/>  utils.js<br/>  utils.spec.js<br/>  wrappers.js</span></pre><p id="32d7" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">在<em class="nk">自管理的</em>组件中，最好将它们分离成进行外部数据交互的位，然后该位将数据向下传递给一个<em class="nk">纯</em>组件。在我们的例子中，假设我们有一个组件，它被提供了<code class="fe nb nc nd ne b">Thing</code>的<code class="fe nb nc nd ne b">id</code>，当它被挂载时，它加载<code class="fe nb nc nd ne b">Thing</code>(使用一个钩子)，将加载的数据向下传递到<em class="nk">纯</em> <code class="fe nb nc nd ne b">SelfManaged.js</code>。</p><p id="bd35" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">这就引出了我的下一条规则。</p><blockquote class="ok ol om"><p id="9d1a" class="kz la nk lb b lc ld kl le lf lg ko lh on lj lk ll oo ln lo lp op lr ls lt lu in bi translated">规则:所有没有作为<code class="fe nb nc nd ne b">prop</code>提供的数据必须来自一个钩子。</p></blockquote><p id="98bb" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">通过遵循这条规则，你可以保持组件本身非常简单，并避免任何复杂性。我们这样做的原因是，通常，从事组件工作的开发人员真的不想考虑数据来自哪里。请参阅我关于<a class="ae jh" rel="noopener ugc nofollow" target="_blank" href="/what-are-front-end-service-layers-4dba95db21bb">前端服务层</a>的文章了解更多信息。</p><p id="f1fd" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">所以我们的<code class="fe nb nc nd ne b">index.js</code>会是这样的:</p><pre class="nx ny nz oa gu ob ne oc od aw oe bi"><span id="7996" class="nl lw jk ne b gz of og l oh oi">import { string } from 'prop-types'<br/>import { useThing } from './hooks'</span><span id="a031" class="nl lw jk ne b gz oj og l oh oi">import PureSelfManaged from './SelfManaged'</span><span id="a9e2" class="nl lw jk ne b gz oj og l oh oi">const SelfManaged = ({ id }) =&gt; {<br/>  const thing = useThing(id)</span><span id="bee5" class="nl lw jk ne b gz oj og l oh oi">  return thing ? &lt;PureSelfManaged {...thing} /&gt; : null<br/>}<br/>SelfManaged.propTypes = { id: string.isRequired }</span><span id="92a2" class="nl lw jk ne b gz oj og l oh oi">export default SelfManaged</span></pre><p id="e2da" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">我们将把<code class="fe nb nc nd ne b">useThing</code>如何工作的任何细节放在一边，但是让我们假设它在内部从一个API或者一些异步的东西加载一些数据，所以最初<code class="fe nb nc nd ne b">thing</code>的值是<code class="fe nb nc nd ne b">undefined</code>或者<code class="fe nb nc nd ne b">null</code>，直到它被实际的<code class="fe nb nc nd ne b">thing</code>数据填充。</p><p id="486f" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">您会注意到，我们将<code class="fe nb nc nd ne b">thing</code>数据作为其实际的<code class="fe nb nc nd ne b">props</code>而不是<code class="fe nb nc nd ne b">thing={thing}</code>传递给了<code class="fe nb nc nd ne b">PureSelfManaged</code>组件。这有双重原因。首先，如果<code class="fe nb nc nd ne b">thing</code>的属性很简单，那么我们可以<em class="nk">记忆</em>T5】，其次，当我们为<code class="fe nb nc nd ne b">SelfManged.stories.js</code>制作故事时，我们可以用他们自己的控件拼出单个的<code class="fe nb nc nd ne b">props</code>，而不是只有一个道具。</p><p id="a92b" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">因此，重用上面显示组件中的<code class="fe nb nc nd ne b">shape.js</code>示例，我们可以将<code class="fe nb nc nd ne b">SelfManaged.js</code>定义为:</p><pre class="nx ny nz oa gu ob ne oc od aw oe bi"><span id="d8b0" class="nl lw jk ne b gz of og l oh oi">import { memo } from 'react'</span><span id="ad32" class="nl lw jk ne b gz oj og l oh oi">import { thingShape } from './shapes'</span><span id="7abe" class="nl lw jk ne b gz oj og l oh oi">const SelfManaged = ({ id, title, text }) =&gt; (<br/>  &lt;&gt;<br/>    &lt;dt&gt;<br/>      {title}<br/>      &lt;tt&gt;{id}&lt;/tt&gt;<br/>    &lt;/dt&gt;<br/>    &lt;dd&gt;{text}&lt;/dd&gt;<br/>  &lt;/&gt;<br/>)<br/>SelfManaged.propTypes = { ...thingShape }</span><span id="83eb" class="nl lw jk ne b gz oj og l oh oi">export default memo(SelfManaged)</span></pre><p id="1ed1" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><code class="fe nb nc nd ne b"> index.stories.js</code>可能会使用Storybook <em class="nk"> loaders </em>和<em class="nk">decorator</em>来预加载数据，并将组件包装在任何可能需要的上下文提供者中，以正确地允许<code class="fe nb nc nd ne b">useThing</code>挂钩运行，以及将组件封装在组件可能期望的外部标签(在本例中为<code class="fe nb nc nd ne b">&lt;dl&gt;…&lt;/dl&gt;</code>)中的包装器。<code class="fe nb nc nd ne b">SelfManaged.stories.js</code>将为<code class="fe nb nc nd ne b">thing</code>的每个属性提供控件，并提供相同类型的包装器。为了保持美观和干燥，你可以把普通的包装放在一个共享的<code class="fe nb nc nd ne b">wrappers.js</code>中。</p><h2 id="0dec" class="nl lw jk bd lx nm nn dn mb no np dp mf li nq nr mh lm ns nt mj lq nu nv ml nw bi translated">污染性<em class="oq">纯</em>成分</h2><p id="8802" class="pw-post-body-paragraph kz la jk lb b lc mn kl le lf mo ko lh li mp lk ll lm mq lo lp lq mr ls lt lu in bi translated"><em class="nk">如果纯</em>组件在内部使用<em class="nk">自管理</em>组件，它们就会变得不纯，尽管这通常是不可避免的，但最好承认这一点，并像对待<em class="nk">自管理</em>组件一样对待这些组件，尤其是在为它们编写测试和故事时。</p><h2 id="46a5" class="nl lw jk bd lx nm nn dn mb no np dp mf li nq nr mh lm ns nt mj lq nu nv ml nw bi translated">日期和时间敏感组件</h2><p id="ca30" class="pw-post-body-paragraph kz la jk lb b lc mn kl le lf mo ko lh li mp lk ll lm mq lo lp lq mr ls lt lu in bi translated">假设有一个组件因为过期而突出显示了一个<code class="fe nb nc nd ne b">date</code>。为了测试这一点，您需要为<code class="fe nb nc nd ne b">today</code>提供一个值，否则一旦日期改变，您的快照测试就会失败。</p><pre class="nx ny nz oa gu ob ne oc od aw oe bi"><span id="7faa" class="nl lw jk ne b gz of og l oh oi">import { string } from 'prop-types'<br/>import { useDates } from 'hooks/dates' // omitted for brevity<br/>import Date from 'components/Date' // assume this exists</span><span id="0ff7" class="nl lw jk ne b gz oj og l oh oi">const Due = ({ date, today }) =&gt; (<br/>  const { isBefore } = useDates(today)<br/>  <br/>  return &lt;Date date={date} highlight={!isBefore(date)} /&gt;<br/>}<br/>Due.propTypes = {<br/>  date: string.isRequired, // Zulu Time string<br/>  today: string // only supplied in tests<br/>}<br/>Due.defaultProps = {<br/>  today: undefined<br/>}</span><span id="2b92" class="nl lw jk ne b gz oj og l oh oi">export default Due</span></pre><p id="4719" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">从表面上看，这看起来像是<em class="nk">可记忆的</em>，但这并不是因为<code class="fe nb nc nd ne b">today</code>的值只在测试中提供，通常是<code class="fe nb nc nd ne b">undefined</code>，这意味着它将默认为调用<code class="fe nb nc nd ne b">useDates</code>钩子时<code class="fe nb nc nd ne b">new Date()</code>返回的值，假设<code class="fe nb nc nd ne b">useDates</code>钩子类似于:</p><pre class="nx ny nz oa gu ob ne oc od aw oe bi"><span id="6960" class="nl lw jk ne b gz of og l oh oi">const toDate = d =&gt; d<br/>  ? typeof d === 'string'<br/>    ? new Date(d)<br/>    : d<br/>  : new Date()</span><span id="41f5" class="nl lw jk ne b gz oj og l oh oi">export const useDates = (tDay) =&gt; {<br/>  const today = toDate(tDay)</span><span id="a58e" class="nl lw jk ne b gz oj og l oh oi">  const isBefore = d =&gt; toDate(d).getTime() &lt; today.getTime()</span><span id="c1b4" class="nl lw jk ne b gz oj og l oh oi">  return { isBefore }<br/>}</span></pre><p id="1d87" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">所以我的另一个原则是</p><blockquote class="ok ol om"><p id="4880" class="kz la nk lb b lc ld kl le lf lg ko lh on lj lk ll oo ln lo lp op lr ls lt lu in bi translated">规则:如果它比较日期或时间，那么总是提供<code class="fe nb nc nd ne b">date</code>或<code class="fe nb nc nd ne b">time</code>作为<a class="ae jh" href="https://www.utctime.net/z-time-now" rel="noopener ugc nofollow" target="_blank"> <em class="jk">祖鲁时间</em> </a>字符串，并且总是提供一个值给<code class="fe nb nc nd ne b">today</code>与之比较。</p></blockquote><h2 id="804d" class="nl lw jk bd lx nm nn dn mb no np dp mf li nq nr mh lm ns nt mj lq nu nv ml nw bi translated">字符串可选时</h2><p id="99c3" class="pw-post-body-paragraph kz la jk lb b lc mn kl le lf mo ko lh li mp lk ll lm mq lo lp lq mr ls lt lu in bi translated">想象一个简单的<code class="fe nb nc nd ne b">Button</code>组件，它带有一个可选的<code class="fe nb nc nd ne b">label</code>。</p><pre class="nx ny nz oa gu ob ne oc od aw oe bi"><span id="7fc6" class="nl lw jk ne b gz of og l oh oi">import { func, string } from 'prop-types'</span><span id="6b97" class="nl lw jk ne b gz oj og l oh oi">const Button = ({ label, onClick }) =&gt; (<br/>  &lt;button type="button" onClick={onClick}&gt;{label}&lt;/button&gt;<br/>)<br/>Button.propTypes = {<br/>  label: string,<br/>  onClick: func.isRequired<br/>}<br/>Button.defaultProps = { label: undefined }</span><span id="b3cb" class="nl lw jk ne b gz oj og l oh oi">export default Button</span></pre><p id="d382" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">将标签默认设置为null或''，这很有吸引力，但是这样做可能会引入错误，特别是当您将属性传递到组件树的更深处时。</p><blockquote class="ok ol om"><p id="2fd6" class="kz la nk lb b lc ld kl le lf lg ko lh on lj lk ll oo ln lo lp op lr ls lt lu in bi translated">规则:可选字符串<code class="fe nb nc nd ne b">prop</code>的默认值必须始终为<code class="fe nb nc nd ne b">undefined</code>。</p></blockquote><h1 id="ba63" class="lv lw jk bd lx ly lz ma mb mc md me mf kq mg kr mh kt mi ku mj kw mk kx ml mm bi translated">最后</h1><p id="42d4" class="pw-post-body-paragraph kz la jk lb b lc mn kl le lf mo ko lh li mp lk ll lm mq lo lp lq mr ls lt lu in bi translated">在小型项目中，您可以将组件放在单个文件中，跳过测试，不在故事书中记录组件，以及用各种钩子、实用程序和配置将组件弄乱，但是随着项目的进行，您会后悔的。</p><p id="b0c3" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">更好的做法是按照你想玩的方式来练习，并且从一开始就以一致和结构化的方式来构建你的组件。这意味着每个组件都有一个文件夹，既有一个<code class="fe nb nc nd ne b">index.js</code>文件又有一个<code class="fe nb nc nd ne b">Component.js</code>文件，即使是普通的组件也是如此。</p><h2 id="7f2c" class="nl lw jk bd lx nm nn dn mb no np dp mf li nq nr mh lm ns nt mj lq nu nv ml nw bi translated">组件类型</h2><ol class=""><li id="cde3" class="ms mt jk lb b lc mn lf mo li or lm os lq ot lu mx my mz na bi translated"><em class="nk">简单</em>如果是<em class="nk">记忆</em>纯<em class="nk">组件，</em></li><li id="4164" class="ms mt jk lb b lc nf lf ng li nh lm ni lq nj lu mx my mz na bi translated"><em class="nk">如果是<em class="nk">纯</em>而不是<em class="nk">记忆</em>则显示</em>，否则</li><li id="7b68" class="ms mt jk lb b lc nf lf ng li nh lm ni lq nj lu mx my mz na bi translated">如果它从<code class="fe nb nc nd ne b">props</code>之外的地方获得数据，那么它就是<em class="nk">自管理的</em>。</li></ol><h2 id="6481" class="nl lw jk bd lx nm nn dn mb no np dp mf li nq nr mh lm ns nt mj lq nu nv ml nw bi translated">组件规则。</h2><ol class=""><li id="74cf" class="ms mt jk lb b lc mn lf mo li or lm os lq ot lu mx my mz na bi translated">避免从一个文件中导出多个组件</li><li id="7c7b" class="ms mt jk lb b lc nf lf ng li nh lm ni lq nj lu mx my mz na bi translated">所有布尔值<code class="fe nb nc nd ne b">props</code>必须是可选的，默认为<code class="fe nb nc nd ne b">false</code>。</li><li id="7c58" class="ms mt jk lb b lc nf lf ng li nh lm ni lq nj lu mx my mz na bi translated">所有没有作为<code class="fe nb nc nd ne b">prop</code>提供的数据必须来自一个钩子。</li><li id="1f99" class="ms mt jk lb b lc nf lf ng li nh lm ni lq nj lu mx my mz na bi translated">如果它比较日期或时间，那么总是提供<code class="fe nb nc nd ne b">date</code>或<code class="fe nb nc nd ne b">time</code>作为祖鲁语时间字符串，并且总是提供一个值给<code class="fe nb nc nd ne b">today</code>与之比较。</li><li id="e758" class="ms mt jk lb b lc nf lf ng li nh lm ni lq nj lu mx my mz na bi translated">可选字符串<code class="fe nb nc nd ne b">prop</code>的默认值必须始终为<code class="fe nb nc nd ne b">undefined</code>。</li></ol><h1 id="3a0c" class="lv lw jk bd lx ly lz ma mb mc md me mf kq mg kr mh kt mi ku mj kw mk kx ml mm bi">⚡</h1><h1 id="9859" class="lv lw jk bd lx ly lz ma mb mc md me mf kq mg kr mh kt mi ku mj kw mk kx ml mm bi translated">链接</h1><ul class=""><li id="818b" class="ms mt jk lb b lc mn lf mo li or lm os lq ot lu ou my mz na bi translated"><a class="ae jh" href="https://reactjs.org/docs/react-api.html#reactmemo" rel="noopener ugc nofollow" target="_blank">https://reactjs.org/docs/react-api.html#reactmemo</a></li><li id="16ca" class="ms mt jk lb b lc nf lf ng li nh lm ni lq nj lu ou my mz na bi translated"><a class="ae jh" href="https://storybook.js.org" rel="noopener ugc nofollow" target="_blank">https://storybook.js.org</a></li><li id="3462" class="ms mt jk lb b lc nf lf ng li nh lm ni lq nj lu ou my mz na bi translated"><a class="ae jh" rel="noopener ugc nofollow" target="_blank" href="/what-are-front-end-service-layers-4dba95db21bb">https://it next . io/what-are-front-end-service-layers-4 DBA 95 db 21 bb</a></li><li id="0eba" class="ms mt jk lb b lc nf lf ng li nh lm ni lq nj lu ou my mz na bi translated"><a class="ae jh" href="https://www.utctime.net/z-time-now" rel="noopener ugc nofollow" target="_blank">https://www.utctime.net/z-time-now</a></li></ul><p id="b32a" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">这个规则的例外是，当您将组件分组到<code class="fe nb nc nd ne b">components/index.js</code>中，以便Rollup之类的工具在生成包时使用。</p><p id="1bd8" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi">—</p><p id="f5f2" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">像这样但不是订户？你可以通过<a class="ae jh" href="https://davesag.medium.com/membership" rel="noopener">davesag.medium.com</a>加入来支持作者。</p></div></div>    
</body>
</html>