# 堵塞模式——为颤振建立堵塞

> 原文：<https://itnext.io/bloc-pattern-building-blocs-for-flutter-81a17410b09?source=collection_archive---------0----------------------->

![](img/b466a6568fc9a2c6dcca6355d357554d.png)

图片由[allnewbricks.com](https://www.allnewbricks.com)

*每当你开始研究 Flutter 的架构时，没有办法绕过 BLoC 模式，但是它是如何工作的，我们如何实现它？*

BLoC 代表*业务逻辑组件*，是在 Flutter 架构中比较流行的方法之一。通过在我们的屏幕和数据层之间放置一个块，它让我们有可能在我们的存储库和小部件之间传递数据，并在数据发生变化时更新 UI，而不必手动更新状态。它来自 Android，实际上与我们在本地开发中使用的 ViewModel & LiveData 结构有一些相似之处。

# 获得正确的包

让我们先来看看我们使用了哪些包。由于我们想要观察数据，`rxdart`是一个简单的选择，它提供了我们大多数人都熟悉的基本 Rx 功能。接下来，我们决定用`bloc_provider`包开始实现 BLoCs。

```
rxdart: 0.22.6
bloc_provider: 0.6.2+2
```

现在确保`pub get`和让我们得到编码！

# 创建集团

现在创建一个新类，姑且称之为我们的`LoginBloc`。我们将实现`Bloc`，让我们覆盖`dispose()`方法。在这里，我们将关闭我们的溪流。

# 定义流

现在我们已经有了我们块，我们可以开始定义我们的流了。我们总是从定义私有类型`Subject`开始。

简而言之:`Observable`通常是单行道(监听数据),而`Subject`是双向的:我们可以监听数据，也可以将数据放入其中。

根据我们希望使用私有主题的目的(观察数据或数据输入)，我们将该部分公开为公共变量，这样我们的 UI 就可以访问它。观察数据通常导致`ValueObservable`，数据输入需要`Sink`。

大多数情况下，我们只公开两种类型中的一种，所以我们总是使用一个私有控制器，结合 UI 的公开的`ValueObservable`或`Sink`。

让我们回顾一下，并以此`LoginBloc`为例说明我们刚刚学到的内容:

# 利用我们的集团

我们有自己的 BLoC，但是如何在我们的 UI 中使用它呢？如果我们打开一个屏幕，我们经常会发现一个`Scaffold`作为我们的小部件树的根。现在我们想使用一个块，我们将使`BlocProvider`成为根，并通过它的构建器初始化我们的块:

这样，我们现在已经初始化了我们的程序块，可以通过构建器的参数或通过`context`访问它👌

**观察数据**
观察数据的方式与我们通常在 Flutter 中处理流的方式相同:通过`StreamBuilder`小部件。只需将受数据影响的小部件包装在一个`StreamBuilder`中，监听数据流并处理`snapshot`结果:

现在，每当我们的块中的`loginState`改变时，`StreamBuilder`将再次触发它的`builder`方法，我们可以基于新数据返回一个小部件。

**输入数据** 将数据从我们的 UI 推送到我们的 Bloc 非常简单。还记得我们如何在我们的块中暴露一个`Sink`以便 UI 可以访问它吗？只要从你的 UI 调用 sink，推送一些新的数据，就可以了！假设我们有之前作为示例使用的`login`水槽:

就是这样！当然，您也可以选择将它隐藏在代码块中一个不错的方法后面，并在您的 UI 中引用它。

*就这么定了！区块模式 101，或者至少我们现在在* [*捏*](https://pinch.nl/en/) *如何使用它。我们仍在不断学习和改进我们的方法，但这是一个很好的起点，可以为您的项目打下良好的基础。编码快乐！*