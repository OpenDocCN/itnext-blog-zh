<html>
<head>
<title>Optimizing Open Policy Agent-based Kubernetes Authorization via Go Execution Tracer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过Go Execution Tracer优化基于开放策略代理的Kubernetes授权</h1>
<blockquote>原文：<a href="https://itnext.io/optimizing-open-policy-agent-based-kubernetes-authorization-via-go-execution-tracer-7b439bb5dc5b?source=collection_archive---------5-----------------------#2019-02-25">https://itnext.io/optimizing-open-policy-agent-based-kubernetes-authorization-via-go-execution-tracer-7b439bb5dc5b?source=collection_archive---------5-----------------------#2019-02-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="26fa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如<a class="ae kl" rel="noopener ugc nofollow" target="_blank" href="/kubernetes-authorization-via-open-policy-agent-a9455d9d5ceb"> Kubernetes通过开放策略代理</a>授权所述，OPA可用于在Kubernetes中实施授权和准入策略。不幸的是，根据您的工作负载，在生产中使用时有一些注意事项。这篇博客文章解释了OPA和<a class="ae kl" href="https://github.com/open-policy-agent/gatekeeper" rel="noopener ugc nofollow" target="_blank"> Kubernetes策略控制器</a>(最近被重命名为Gatekeeper)如何针对生产用途进行微调。这个博客基于OPA 0.10.3和我们的<a class="ae kl" href="https://github.com/c445/kubernetes-policy-controller" rel="noopener ugc nofollow" target="_blank">分叉Kubernetes策略控制器</a>(我们还没有迁移到Gatekeeper)。</p><h1 id="c0a5" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">概述</h1><p id="b2e2" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">如下图所示，Kubernetes策略控制器(以及OPA)由Kubernetes API服务器在以下情况下调用:</p><ul class=""><li id="a347" class="lp lq iq jp b jq jr ju jv jy lr kc ls kg lt kk lu lv lw lx bi translated">对于对Kubernetes API服务器的每个授权请求，即几乎每个请求</li><li id="ffd3" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated">可能针对资源上的每次创建/更新/删除，这取决于如何配置变异Webhook</li></ul><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi md"><img src="../Images/26410164c3a1abd0dafb656acc801851.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-s7y7xbncJB7Fqy0Zuxe4A.png"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">概述面向Kubernetes授权和准入的OPA集成</figcaption></figure><p id="4505" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，很明显，如果操作不当，很有可能会引入延迟。以下部分展示了我们如何优化集群的性能。</p><h1 id="823f" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">基线群集</h1><p id="2d61" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">在我们的基线集群中，对Kubernetes API服务器的许多请求来自一个通过CRDs管理舵图部署的运营商。因此会有稳定的请求流，比如创建名称空间、更新服务/部署/状态集，当然还有修改CRDs本身。我将通过<a class="ae kl" href="https://github.com/tsenart/vegeta" rel="noopener ugc nofollow" target="_blank">贝吉塔</a>和以下混合请求再现这个用例:</p><ul class=""><li id="4da5" class="lp lq iq jp b jq jr ju jv jy lr kc ls kg lt kk lu lv lw lx bi translated">75%仅授权请求，例如:列表窗格、获取服务和观察命名空间</li><li id="1cdd" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated">25%的准入请求，例如:更新CRDs、删除部署和更新服务(准入请求在发送到变异Webhook之前也经过授权)</li></ul><p id="818d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用<code class="fe mt mu mv mw b">GO_MAX_PROCS=2</code>运行开放策略代理。贝吉塔用于以下设置:</p><ul class=""><li id="d8e7" class="lp lq iq jp b jq jr ju jv jy lr kc ls kg lt kk lu lv lw lx bi translated">60秒持续时间</li><li id="d552" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated">20个并发连接</li><li id="b3c7" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated">每秒75个请求</li></ul><p id="6263" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从贝吉塔直接调用OPA时测得的基线延迟为:</p><ul class=""><li id="a8fd" class="lp lq iq jp b jq jr ju jv jy lr kc ls kg lt kk lu lv lw lx bi translated">平均值:7.24秒</li><li id="a583" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated">分位数50，95，99，最大值:4.79秒，24.01秒，29.13秒，31.54秒</li><li id="dd6a" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated">大约13%的请求超时</li></ul><h1 id="8bec" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">只将请求发送到实际上应该被验证的MutatingWebhook</h1><p id="5a96" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">显然OPA运行的不是很好。我们发现的第一个问题是，通过MutatingWebhook验证每个对象实际上是不可行的。</p><figure class="me mf mg mh gt mi"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="48f5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，我们将我们的MutatingWebhook限制为只验证我们的OPA策略中实际提到的对象:</p><figure class="me mf mg mh gt mi"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="4ca4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们并不想验证对象的删除，所以现在我们只验证<code class="fe mt mu mv mw b">CREATE</code>和<code class="fe mt mu mv mw b">UPDATE</code>请求。所有其他列出的资源实际上都通过我们的政策进行了验证。一个巨大的性能提升是我们不再需要验证像配置映射这样的资源。通常，许多配置是通过ConfigMaps存储的，当开放策略代理解析所有这些资源时，这会带来巨大的性能损失。特别是，因为OPA为每个查询构建了一个抽象语法树。</p><p id="ca87" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以在改变了变异的WebhookConfiguration之后，我们现在收到的请求越来越少。这些优化的延迟现在是:</p><ul class=""><li id="a236" class="lp lq iq jp b jq jr ju jv jy lr kc ls kg lt kk lu lv lw lx bi translated">平均值:3.22秒</li><li id="ce4a" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated">分位数50，95，99，最大值:1.04秒，11.29秒，13.32秒，16.19秒</li><li id="2017" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated">我们仍然会遇到超时，但只是针对大约0.23%的请求</li></ul><h1 id="7711" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">不要在更新许可请求时发送旧资源</h1><p id="0e49" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">下一个优化处理Kubernetes策略控制器。它向OPA发送如下请求:</p><figure class="me mf mg mh gt mi"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="4558" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每次更新请求时，资源基本上被发送两次给MutatingWebhook。旧版本在<code class="fe mt mu mv mw b">oldObject</code>字段，新版本为<code class="fe mt mu mv mw b">object</code>。因为我们的策略只适用于新的资源，我们从请求中删除了<code class="fe mt mu mv mw b">oldObject</code>。这导致了另一个性能提升，因为我们显著减小了查询大小:</p><ul class=""><li id="470b" class="lp lq iq jp b jq jr ju jv jy lr kc ls kg lt kk lu lv lw lx bi translated">平均值:790毫秒</li><li id="e10b" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated">分位数50，95，99，最大值:13毫秒，3.21秒，3.92秒，4.78秒</li><li id="bee3" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated">没有超时</li></ul><h1 id="68d2" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">去收垃圾</h1><p id="53a7" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">为了找出某些请求缓慢的原因，OPA中添加了跟踪pprof端点的<a class="ae kl" href="https://golang.org/pkg/net/http/pprof/" rel="noopener ugc nofollow" target="_blank">,我们通过</a><a class="ae kl" href="https://blog.gopheracademy.com/advent-2017/go-execution-tracer/" rel="noopener ugc nofollow" target="_blank"> Go执行跟踪器</a>来查看跟踪。</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi mz"><img src="../Images/32cfd76b6dee782839b8c1015602f5df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*89wTn6BsehrC-zrZ0zzsHA.png"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">去追踪GOGC=100</figcaption></figure><p id="0ce2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">值得注意的是，有许多垃圾收集只释放了大约2-5mb的内存。这些大多是从AST解析器内部触发的。当然这需要花费大量的CPU时间。我们还添加了一些<a class="ae kl" href="https://medium.com/observability/debugging-latency-in-go-1-11-9f97a7910d68" rel="noopener">追踪区域</a>。最重要的代码区域是<a class="ae kl" href="https://github.com/open-policy-agent/opa/blob/v0.10.3/server/server.go#L1462-L1463" rel="noopener ugc nofollow" target="_blank">验证</a>和<a class="ae kl" href="https://github.com/open-policy-agent/opa/blob/v0.10.3/server/server.go#L1489" rel="noopener ugc nofollow" target="_blank">执行</a>查询。直方图提供了一些关于实际花费和损失时间的见解。</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi na"><img src="../Images/21e65045e5bda4ea7cec302215caabbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WjAGpvy3CmMuYD7wkoJArg.png"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">GOGC=100的关键代码区域直方图</figcaption></figure><p id="5af2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当深入研究运行缓慢的validate query时，很明显大部分时间都花在了等待调度上:</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi nb"><img src="../Images/d05282bb0b5ad360c2e549adc1b73dfc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xpzDCP5P82tOdrC7q1dhTg.png"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">验证查询的最慢执行时间表</figcaption></figure><p id="8839" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">结论是这一切可能是由非常频繁的GC运行造成的。为了减少GC周期的数量，我们设置了<code class="fe mt mu mv mw b">GOGC=1000</code>。以下是使用新的<code class="fe mt mu mv mw b">GOGC</code>设置运行OPA时的轨迹:</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi nc"><img src="../Images/5deded4155eba84149311a43ec0c289d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2K-0-ufuS6AyIwHYTjbaVg.png"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">去追踪GOGC=1000</figcaption></figure><p id="2c6e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">明显的区别是，我们现在的GC周期少了很多，它们释放了大约30-40mb的内存。我认为在太少的GC周期导致内存使用增加和太多的GC周期降低应用程序速度之间找到平衡点是很重要的。如果<code class="fe mt mu mv mw b">GOGC</code>值设置得太高，那么GC运行的频率就会降低，GC持续时间也会增加，因为有更多的内存可以释放。当GC最终运行时，这可能会导致延迟高峰。验证和执行查询所花费的时间也有所减少:</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi nd"><img src="../Images/7770918d09166ea0fd797c6535b8c3a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KF_Hbs8zrvn_QOe0H7kmuw.png"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">GOGC=1000的关键代码区域直方图</figcaption></figure><p id="4615" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，尽管<code class="fe mt mu mv mw b">GOGC=1000</code>对我们来说似乎是一个不错的值，但这在很大程度上取决于您的工作负载/查询。</p><p id="768f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">延迟时间缩短至:</p><ul class=""><li id="4a9a" class="lp lq iq jp b jq jr ju jv jy lr kc ls kg lt kk lu lv lw lx bi translated">平均值:15毫秒</li><li id="db5b" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated">分位数50，95，99，最大值:13毫秒，26毫秒，41毫秒，175毫秒</li></ul><h1 id="904f" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">优化授权查询格式</h1><p id="035c" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">尽管我们优化了GC，但是仍然有一些请求花费了太多的时间。我们仔细研究了授权查询，因为到目前为止，它们代表了我们对OPA的大多数请求:</p><figure class="me mf mg mh gt mi"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="244d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最初选择这种格式是为了与准入请求具有一致的查询格式。显然，大多数像<code class="fe mt mu mv mw b">resourceAttributes</code>或<code class="fe mt mu mv mw b">user</code>和<code class="fe mt mu mv mw b">group</code>这样的字段都需要做出有用的授权决策。但是也有很多开销，比如深度嵌套结构或者<code class="fe mt mu mv mw b">status</code>和<code class="fe mt mu mv mw b">metadata</code>字段。所以我们把格式精简到最低限度:</p><figure class="me mf mg mh gt mi"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="db00" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">OPA现在应该能够比以前更快地解析这种格式。</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi ne"><img src="../Images/8b083a9b53b21aa89af51e6c02714eb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FX6YVHItlfuxGWVENO1eRw.png"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">使用GOGC=1000进行追踪&amp;优化授权查询</figcaption></figure><p id="b87e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">显著的区别是:</p><ul class=""><li id="cc45" class="lp lq iq jp b jq jr ju jv jy lr kc ls kg lt kk lu lv lw lx bi translated">GC周期比以前少了，因为我们消耗了更少的内存。GC周期之间的时间从250毫秒增加到400毫秒</li><li id="a46a" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated">Goroutines不像以前那样需要等待很长时间才能得到预定。高峰可运行的Goroutines从68个下降到3个，因为我们的大多数请求可以得到更快的处理。</li></ul><p id="6619" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们看一下直方图，我们会看到巨大的改进:</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi nf"><img src="../Images/868b8e868a48f7f1b17540077e313679.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8soeZdOc1No_g9YkOPLqdA.png"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">GOGC=1000的关键代码区域直方图&amp;优化的授权查询</figcaption></figure><p id="8fdd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">延迟改善到:</p><ul class=""><li id="8916" class="lp lq iq jp b jq jr ju jv jy lr kc ls kg lt kk lu lv lw lx bi translated">平均值:9毫秒</li><li id="944f" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated">分位数50，95，99，最大值:6毫秒，24毫秒，42毫秒，90毫秒</li></ul><h1 id="b2c6" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">未来优化:服务器端应用</h1><p id="495d" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">目前，<code class="fe mt mu mv mw b">kubectl apply</code>实现了这样的逻辑，即只有在当前资源和新资源版本之间存在差异时，才应用资源。因为我们在我们的操作符中直接使用了<code class="fe mt mu mv mw b">client-go</code>,并且没有为此实现优化，所以即使没有变化，也会应用大量的资源。所有这些请求都必须通过我们的MutatingWebhook进行验证。一旦<a class="ae kl" href="https://github.com/kubernetes/enhancements/issues/555" rel="noopener ugc nofollow" target="_blank">服务器端应用</a>在Kubernetes中实现，我们希望这些请求不再被发送到变异的Webhook，这将有助于进一步降低延迟。</p><h1 id="13b3" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated"><strong class="ak">结论</strong></h1><p id="2d7f" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">最后，我们获得了将基于OPA的授权投入生产所需的性能。下表显示了优化步骤的概述:</p><figure class="me mf mg mh gt mi"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="4edd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">根据您使用Kubernetes的方式，这种优化可能会在Kubernetes API服务器延迟方面提供巨大的性能改进。</p><p id="4bf5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">感谢我的团队在几天的性能调试中对我的包容:)。对Go execution tracer的所有贡献者来说，这是一个调查Go性能的无价工具。感谢开放策略代理和Kubernetes策略控制器/看门人的所有贡献者。</p></div></div>    
</body>
</html>