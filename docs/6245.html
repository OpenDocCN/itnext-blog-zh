<html>
<head>
<title>Exposing an OutSystems REST service with an OAuth-style authorization</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用OAuth风格的授权公开外部系统REST服务</h1>
<blockquote>原文：<a href="https://itnext.io/exposing-an-outsystems-rest-service-with-an-oauth-style-authorization-fded258cbe14?source=collection_archive---------6-----------------------#2021-09-28">https://itnext.io/exposing-an-outsystems-rest-service-with-an-oauth-style-authorization-fded258cbe14?source=collection_archive---------6-----------------------#2021-09-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="dc07" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">这是一篇关于用</em> <a class="ae km" href="https://www.outsystems.com/" rel="noopener ugc nofollow" target="_blank"> <em class="kl"> OutSystems平台</em> </a> <em class="kl">开发的文章。如果您还没有使用OutSystems进行开发，您应该:)。</em></p><h1 id="0543" class="kn ko iq bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">前言</h1><p id="a855" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">当使用OutSystems平台(此后简称为“OutSystems”)公开REST服务时，没有开箱即用的安全性:任何有权访问端点的人都可以调用该服务。OutSystems允许为基本认证设置用户名和密码，但这是全局的，即每个调用REST服务的人都必须使用该用户名和密码。显然，这不够灵活和安全，所以我怀疑这个选项是否经常使用，除了可能在应用程序之间内部使用。</p><p id="c797" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">任何将被多个用户(或应用程序)使用的现代REST服务都必须具有按用户认证，以便调用的REST方法可以验证用户是有效用户(否则通过返回<a class="ae km" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/403" rel="noopener ugc nofollow" target="_blank"> 403 </a>拒绝访问)，并根据用户的权限返回结果(或允许更新)。</p><p id="4603" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">认证的现代行业标准是<a class="ae km" href="https://oauth.net/2/" rel="noopener ugc nofollow" target="_blank"> OAuth 2.0 </a>，如<a class="ae km" href="https://datatracker.ietf.org/doc/html/rfc6749" rel="noopener ugc nofollow" target="_blank"> RFC 6749 </a>中所述。这个标准描述了认证和授权的流程，涉及一个<em class="kl">资源所有者</em>(公开REST方法的那个)和一个<em class="kl">授权服务器</em>(提供授权的那个)。像所有现代行业标准一样，它相当复杂，但基本要点是资源所有者检查您的凭证，如果正确，提供一个<em class="kl">授权许可</em>，它可以与授权服务器一起使用，为您提供一个<em class="kl">访问令牌</em>。然后，当您对资源所有者进行后续调用时(即，当调用REST方法来检索或存储信息时)，访问令牌被用作授权的证明。</p><p id="f007" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我在寻找一种方法来适当地保护我们的客户门户和我们的后端服务器之间的REST服务时(最初它是基于仅仅在头中交换用户名/密码)，我查看了OAuth 2.0，但是发现它太复杂而不能完全实现。然而，它的基本前提吸引了我，所以我开始自己实现类似的东西，而不完全遵循OAuth 2.0，如上述RFC中所描述的。</p><h1 id="d134" class="kn ko iq bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">JSON Web令牌</h1><p id="ccde" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">OAuth 2.0 <a class="ae km" href="https://datatracker.ietf.org/doc/html/rfc6750" rel="noopener ugc nofollow" target="_blank">描述了所谓的<em class="kl">承载令牌</em>的使用</a>，这是向资源所有者提供上述接入令牌的技术方式。然而，OAuth 2.0没有描述接入/承载令牌的确切格式。接下来是JSON Web令牌，简称JWT。JWT是访问令牌的一种格式(在<a class="ae km" href="https://datatracker.ietf.org/doc/html/rfc7519" rel="noopener ugc nofollow" target="_blank"> RFC 7519 </a>中定义)，但是它提供了许多方便的功能。它是:</p><ul class=""><li id="907f" class="lq lr iq jp b jq jr ju jv jy ls kc lt kg lu kk lv lw lx ly bi translated">自包含:资源提供者检查令牌有效性所需的所有信息都嵌入在令牌本身中；</li><li id="293e" class="lq lr iq jp b jq lz ju ma jy mb kc mc kg md kk lv lw lx ly bi translated">安全:令牌用授权服务器的证书签名。它可以用公钥解密(这样任何有权访问JWT的人都可以阅读它的内容)，但不能用中间人攻击来调节，因为它不能再次加密。</li></ul><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div class="gh gi me"><img src="../Images/476e552e23e292f2c2cef27dadea6471.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/0*eeeO936i7XECDRzV.png"/></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">JWT标志。这一次，一个没有谷歌颜色的标志(我正看着你，Slack)。</figcaption></figure><p id="b079" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一个JWT包含三个不同的部分:一个<em class="kl">报头</em>、一个<em class="kl">有效载荷</em>和一个<em class="kl">签名</em>。顾名思义，信息是使用JSON存储的。完整的JWT有三个Base64编码的部分，每个部分由一个点(“.”分隔).</p><p id="a4c7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">头</strong>是一个所谓的JOSE头(JSON对象签名和加密，在<a class="ae km" href="https://datatracker.ietf.org/doc/html/rfc7515" rel="noopener ugc nofollow" target="_blank"> RFC 7515 </a>中定义),包含关于所使用的签名和加密的信息。它具有以下属性:</p><ul class=""><li id="d499" class="lq lr iq jp b jq jr ju jv jy ls kc lt kg lu kk lv lw lx ly bi translated"><code class="fe mq mr ms mt b">typ</code> —“媒体类型”，总是<code class="fe mq mr ms mt b">JWT</code>；</li><li id="e2a6" class="lq lr iq jp b jq lz ju ma jy mb kc mc kg md kk lv lw lx ly bi translated"><code class="fe mq mr ms mt b">alg</code> —使用的加密算法。可以是<code class="fe mq mr ms mt b">RS256</code>，是带SHA-256的RSA数字签名算法(非对称)，也可以是<code class="fe mq mr ms mt b">HS256</code>，是HMAC·SHA-256(对称)。RS256是API的必由之路，因为你不想与任何使用你的API的人共享一个秘密的加密密钥；</li><li id="ff00" class="lq lr iq jp b jq lz ju ma jy mb kc mc kg md kk lv lw lx ly bi translated"><code class="fe mq mr ms mt b">kid</code> —密钥标识符，一个可选属性，指示加密使用什么密钥。它没有预定义的结构。我使用这个属性来存储证书的指纹，这样我就可以验证是否使用了正确的证书来创建它。我后来了解到,<code class="fe mq mr ms mt b">x5t</code>属性正是为此而提供的，但是我没有费事去改变它。</li></ul><p id="3a04" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">可能有更多的属性，但这是我使用的三个。</p><p id="3a20" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">有效载荷</strong>是最有趣的部分。它包含所谓的<em class="kl">声明</em>，这些声明(我引用jwt.io)是“关于一个实体(通常是用户)和附加数据的声明”。索赔有三种类型:</p><ul class=""><li id="8baf" class="lq lr iq jp b jq jr ju jv jy ls kc lt kg lu kk lv lw lx ly bi translated">注册声明—可选的预定义声明，如发布者、到期时间、主题和受众(见下文)；</li><li id="5388" class="lq lr iq jp b jq lz ju ma jy mb kc mc kg md kk lv lw lx ly bi translated">公共声明——应来自<a class="ae km" href="https://www.iana.org/assignments/jwt/jwt.xhtml" rel="noopener ugc nofollow" target="_blank">预定义列表</a>或被定义为URI的声明。我没有使用任何公开声明；</li><li id="f920" class="lq lr iq jp b jq lz ju ma jy mb kc mc kg md kk lv lw lx ly bi translated">私有声明—交换数据的双方同意的任何自定义声明。我没有使用任何私人声明。</li></ul><p id="7d2d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我只使用注册声明，因为我不需要任何其他声明。我用的是:</p><ul class=""><li id="d0d7" class="lq lr iq jp b jq jr ju jv jy ls kc lt kg lu kk lv lw lx ly bi translated"><code class="fe mq mr ms mt b">iss</code> —签发人，签发方的名称。这可能是你的公司名称，或应用程序的名称等。我使用了公司名称和应用程序的组合；</li><li id="c596" class="lq lr iq jp b jq lz ju ma jy mb kc mc kg md kk lv lw lx ly bi translated"><code class="fe mq mr ms mt b">sub</code> —主题，标识其他声明所涉及的资源。通常这是一个用户标识符。在我的例子中，我使用了公司Id和用户Id的组合，因为我可以在JWT的验证中使用这些值；</li><li id="01eb" class="lq lr iq jp b jq lz ju ma jy mb kc mc kg md kk lv lw lx ly bi translated"><code class="fe mq mr ms mt b">aud</code> —受众，确定JWT的接受者，如你所针对的REST服务或应用。在我的例子中，我使用应用程序代码和我公司的域名组成了一个伪URL，但任何事情都可以；</li><li id="203c" class="lq lr iq jp b jq lz ju ma jy mb kc mc kg md kk lv lw lx ly bi translated"><code class="fe mq mr ms mt b">exp</code> —过期时间，令牌过期的UTC日期/时间，指定为自1970–01–01 00:00:00(UNIX纪元)以来的秒数。过了这个时间，令牌不再有效，必须被拒绝。由于该平台不能很好地处理UTC(至少在服务器端不能)，我只选择了本地时间，因为我不需要跨越时区；</li><li id="7813" class="lq lr iq jp b jq lz ju ma jy mb kc mc kg md kk lv lw lx ly bi translated"><code class="fe mq mr ms mt b">iat</code> —颁发于，颁发令牌的UTC日期/时间，指定为自1970–01–01 00:00:00以来的秒数。我再次编码了本地时间，而不是UTC。</li></ul><p id="1835" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可能会放弃其中的一些声明，但是我发现它们对于验证令牌很有用，并且可以确保我的单个令牌提供者可以用于多个应用程序，而不是一个令牌对所有应用程序都有效。此外，出于安全原因，最好使用只在有限时间内有效的令牌。</p><p id="6106" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">JWT的最后一部分是签名。签名采用前两部分，用分隔点进行Base64编码，并使用加密算法对结果字符串进行加密。加密的结果也是Base64编码的，并添加到前两部分，同样使用点作为分隔符。</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi mu"><img src="../Images/7a984dfe8645c5bead3d0fb58b826b03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gcU8USKEcnPSyabg5cRbaw.png"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">JWT及其零件的示例(来自<a class="ae km" href="https://jwt.io/introduction" rel="noopener ugc nofollow" target="_blank"> jwt.io) </a>。</figcaption></figure><h1 id="5034" class="kn ko iq bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">认证流程</h1><p id="d120" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">如上所述，认证涉及三方:<em class="kl">用户</em>(可能是app)<em class="kl">资源所有者</em>和<em class="kl">授权服务器</em>。首先，用户需要通过提供用户名和密码来登录。这些被发送到验证用户名和密码的授权服务器，并返回一个<em class="kl">授权许可</em>，或者更常见的称为<em class="kl">访问令牌</em>，在我们的例子中是一个JWT。每次调用资源所有者时，都会发送访问令牌，但不会发送用户名/密码。资源所有者负责验证访问令牌，如果有效，则执行所请求的任何动作(例如，数据更新或检索)。</p><p id="5125" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以下流程图显示了该程序(模仿auth0.com的<a class="ae km" href="https://auth0.com/docs/authorization/flows/resource-owner-password-flow" rel="noopener ugc nofollow" target="_blank">程序):</a></p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/ed4f080fc93bcce9f468e89335f26e11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1098/format:webp/1*n0GaXcFSJdB5ksyu7S8ZtA.png"/></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">可视化表示的身份验证流程</figcaption></figure><ol class=""><li id="cd86" class="lq lr iq jp b jq jr ju jv jy ls kc lt kg lu kk na lw lx ly bi translated">用户在登录屏幕上键入他们的用户名/密码；</li><li id="cd2a" class="lq lr iq jp b jq lz ju ma jy mb kc mc kg md kk na lw lx ly bi translated">web应用将用户名/密码发送到授权服务器；</li><li id="3536" class="lq lr iq jp b jq lz ju ma jy mb kc mc kg md kk na lw lx ly bi translated">授权服务器验证用户名/密码，如果有效，则发送访问令牌；</li><li id="696e" class="lq lr iq jp b jq lz ju ma jy mb kc mc kg md kk na lw lx ly bi translated">web应用程序向资源所有者请求数据，同时发送访问令牌进行授权；</li><li id="aabb" class="lq lr iq jp b jq lz ju ma jy mb kc mc kg md kk na lw lx ly bi translated">资源所有者验证访问令牌，如果有效，则发送数据。</li></ol><h1 id="a848" class="kn ko iq bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">实施JWT</h1><p id="3a24" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">至少有一个<a class="ae km" href="https://www.outsystems.com/forge/component-overview/1853/jwt" rel="noopener ugc nofollow" target="_blank">JWT组件</a>在酝酿中，但是它似乎倾向于消费外部服务，而不是自己提供授权服务。因此，我决定从头开始写一切。</p><p id="24ac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我创建了一个用于验证JWT的扩展。该扩展具有以下功能:</p><ul class=""><li id="16dd" class="lq lr iq jp b jq jr ju jv jy ls kc lt kg lu kk lv lw lx ly bi translated">CertificateGet —根据证书主题、存储名称和存储位置从Windows证书存储中检索证书，并返回证书(作为对象)、主题的全名和证书的指纹。</li><li id="e7d6" class="lq lr iq jp b jq lz ju ma jy mb kc mc kg md kk lv lw lx ly bi translated">JwtCreate —基于JOSE标头、JWT声明和证书创建JWT。它通过对标头和声明进行Base64编码，用证书加密结果，然后连接加密的部分(也是Base64编码的)来实现这一点。这里唯一棘手的部分是将输入分段，因为加密是在最大块大小上进行的。</li><li id="b2cc" class="lq lr iq jp b jq lz ju ma jy mb kc mc kg md kk lv lw lx ly bi translated">JwtGetParts —检索和解码(从Base64)JOSE头和JWT声明，并返回它们(作为JSON)。这也可以在使用BinaryData扩展的外部系统中完成，但是我发现在扩展中更容易做到。</li><li id="1150" class="lq lr iq jp b jq lz ju ma jy mb kc mc kg md kk lv lw lx ly bi translated">JwtVerify —通过用提供的证书描述签名并将其与标头和声明进行比较，来验证给定输入是否为有效的JWT。</li></ul><p id="c262" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我创建了一个包含授权服务器和资源所有者使用的实际操作的模块。这些行动是:</p><ul class=""><li id="9cf4" class="lq lr iq jp b jq jr ju jv jy ls kc lt kg lu kk lv lw lx ly bi translated">JsonWebTokenGet —由授权服务器使用，它根据提供的JOSE头、JWT声明和证书返回一个JWT。到期时间戳也是一个输入参数；如果提供了JWT声明的到期时间值(即自1970年1月1日起的秒数),则该操作会计算该值(否则，它会假定已经设置了到期时间)。它使用扩展中的CertificateGet和JwtCreate操作。</li><li id="2ea7" class="lq lr iq jp b jq lz ju ma jy mb kc mc kg md kk lv lw lx ly bi translated">JsonWebTokenVerify —由资源所有者使用，它通过从扩展调用CertificateGet、JwtGetParts和JwtVerify来验证JWT，并输出JOSE头和JWT声明。</li></ul><h1 id="a0c6" class="kn ko iq bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">实现授权服务器</h1><p id="088d" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">实现授权服务器相当简单。我用TokenGet POST方法(相对路径/认证)公开了一个REST服务。它具有以下参数:</p><ul class=""><li id="cec3" class="lq lr iq jp b jq jr ju jv jy ls kc lt kg lu kk lv lw lx ly bi translated">Authorization —应该设置为有效的基本身份验证字符串的标头参数。</li><li id="90ed" class="lq lr iq jp b jq lz ju ma jy mb kc mc kg md kk lv lw lx ly bi translated">应用程序—因为我们对多个应用程序使用同一个授权服务器，所以应用程序代码用于避免令牌允许访问所有应用程序。它是HTTP头中编码为X-Application的头参数。</li></ul><p id="3ea3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果用户名和密码对于给定的应用程序有效，则返回一个JWT。下列索赔包含在JWT索赔中:</p><ul class=""><li id="c19b" class="lq lr iq jp b jq jr ju jv jy ls kc lt kg lu kk lv lw lx ly bi translated">issuer——标识我们的后端服务器的固定字符串；</li><li id="dfbf" class="lq lr iq jp b jq lz ju ma jy mb kc mc kg md kk lv lw lx ly bi translated">受众——标识应用程序的代码；</li><li id="6023" class="lq lr iq jp b jq lz ju ma jy mb kc mc kg md kk lv lw lx ly bi translated">主题——如上所述，公司Id和用户Id的组合；</li><li id="06d6" class="lq lr iq jp b jq lz ju ma jy mb kc mc kg md kk lv lw lx ly bi translated">到期时间——用固定的持续时间计算(通过站点属性配置),因为我们不需要动态持续时间；</li><li id="69a2" class="lq lr iq jp b jq lz ju ma jy mb kc mc kg md kk lv lw lx ly bi translated">颁发时间—颁发令牌的时间。</li></ul><h1 id="1aa1" class="kn ko iq bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">发送令牌</h1><p id="f6db" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">当用户登录我们的客户门户时，用户名和密码会发送到身份验证服务器，如上所述。当访问令牌被返回时，它被存储在一个会话变量中(我们的客户门户仍然使用传统的web，因为它已经存在了几年)。处理登录的模块公开了一个从该会话变量返回令牌的操作。</p><p id="6a63" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当客户门户需要从后端服务器请求数据时，它使用载体认证。与基本身份验证一样，它使用授权头参数，但不是“基本”，而是“载体”一词，后跟一个空格和JWT。我们决定将Authorization头参数添加到所有方法中，尽管回想起来，我们可能已经在On Before请求中将它添加到了头中。</p><h1 id="f4a2" class="kn ko iq bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">令牌验证</h1><p id="5e0f" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">当后端接收到来自客户门户的请求时，它首先通过调用前面提到的JsonWebTokenVerify操作来验证JWT。然后，它对令牌中包含的数据执行有效性检查，方法是验证:</p><ul class=""><li id="552c" class="lq lr iq jp b jq jr ju jv jy ls kc lt kg lu kk lv lw lx ly bi translated">颁发者声明—颁发者必须等于授权服务器颁发的颁发者；</li><li id="36a7" class="lq lr iq jp b jq lz ju ma jy mb kc mc kg md kk lv lw lx ly bi translated">受众声明—应用程序必须等同于处理请求的应用程序；</li><li id="33b6" class="lq lr iq jp b jq lz ju ma jy mb kc mc kg md kk lv lw lx ly bi translated">主题声明—客户Id和用户Id必须有效，并且用户必须能够访问公司的数据；</li><li id="c064" class="lq lr iq jp b jq lz ju ma jy mb kc mc kg md kk lv lw lx ly bi translated">过期时间—如果令牌过期，则请求为denied⁴.</li></ul><p id="4afd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果一切正常，后端将返回请求的数据。</p><h1 id="09af" class="kn ko iq bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">包装它</h1><p id="4057" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">尽管OAuth和JWT是复杂的主题，但是我已经使用JWTs通过OAuth风格的身份验证方案成功地保护了我们的客户门户通信。我希望它能启发您在公开自己的REST服务时使用类似的认证。</p></div><div class="ab cl nb nc hu nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ij ik il im in"><h1 id="49d1" class="kn ko iq bd kp kq ni ks kt ku nj kw kx ky nk la lb lc nl le lf lg nm li lj lk bi translated">密码在哪里？</h1><p id="a07f" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">我故意不把我写的任何代码放进熔炉，有两个原因:</p><ol class=""><li id="b45a" class="lq lr iq jp b jq jr ju jv jy ls kc lt kg lu kk na lw lx ly bi translated">我最初计划将一些代码与现有的JWT库集成在一起(最终没有成功)；</li><li id="3f3a" class="lq lr iq jp b jq lz ju ma jy mb kc mc kg md kk na lw lx ly bi translated">我的代码是面向我们的客户门户的，Forge组件需要一个更灵活的解决方案，例如关于所做的检查。</li></ol><p id="4400" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，由于扩展是最难编写的代码，我将在这里分享一些我编写的C#代码。</p><h2 id="e20b" class="nn ko iq bd kp no np dn kt nq nr dp kx jy ns nt lb kc nu nv lf kg nw nx lj ny bi translated">从证书存储中检索证书</h2><p id="8b11" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">不是JWT特有的，但很有用:</p><pre class="mf mg mh mi gt nz mt oa ob aw oc bi"><span id="befc" class="nn ko iq mt b gy od oe l of og">public void MssCertificateGet(string ssSubjectNamePart, string ssStoreName, string ssStoreLocation, out bool ssIsFound, out object ssCertificate, out string ssSubjectNameFull, out string ssThumbprint)<br/>        {<br/>            ssIsFound = false;<br/>            ssCertificate = null;<br/>            ssSubjectNameFull = "";<br/>            ssThumbprint = "";</span><span id="9ade" class="nn ko iq mt b gy oh oe l of og">var storeName = ssStoreName.Equals("M") ? StoreName.My : StoreName.TrustedPeople;<br/>            var storeLocation = ssStoreLocation.Equals("C") ? StoreLocation.CurrentUser : StoreLocation.LocalMachine;</span><span id="b4f3" class="nn ko iq mt b gy oh oe l of og">X509Store store = new X509Store(storeName, storeLocation);<br/>            store.Open(OpenFlags.ReadOnly | OpenFlags.OpenExistingOnly);</span><span id="9c67" class="nn ko iq mt b gy oh oe l of og">X509Certificate2Collection collection = store.Certificates.Find(X509FindType.FindBySubjectName, ssSubjectNamePart, true);</span><span id="fe52" class="nn ko iq mt b gy oh oe l of og">if (collection.Count == 1)<br/>            {<br/>                ssIsFound = true;<br/>                ssCertificate = collection[0];<br/>                ssSubjectNameFull = collection[0].Subject;<br/>                ssThumbprint = collection[0].Thumbprint;<br/>            }<br/>        } // MssCertificateGet</span></pre><h2 id="1994" class="nn ko iq bd kp no np dn kt nq nr dp kx jy ns nt lb kc nu nv lf kg nw nx lj ny bi translated">创造一个JWT</h2><pre class="mf mg mh mi gt nz mt oa ob aw oc bi"><span id="72a8" class="nn ko iq mt b gy od oe l of og">public void MssJwtCreate(string ssJoseHeader, string ssJwtClaims, object ssCertificate, out string ssJwt)<br/>        {<br/>            var cryptoProvider = ((X509Certificate2)ssCertificate).PrivateKey as RSACryptoServiceProvider;<br/>            if (cryptoProvider == null)<br/>            {<br/>                throw new Exception("Cannot access private key");<br/>            }</span><span id="1a79" class="nn ko iq mt b gy oh oe l of og">AsymmetricCipherKeyPair kp = DotNetUtilities.GetKeyPair(cryptoProvider);</span><span id="9ab8" class="nn ko iq mt b gy oh oe l of og">var encryptEngine = new Pkcs1Encoding(new RsaEngine());<br/>            encryptEngine.Init(true, (RsaKeyParameters)kp.Private);</span><span id="3205" class="nn ko iq mt b gy oh oe l of og">string textToEncrypt = Base64UrlEncoder.Encode(ssJoseHeader) + "." + Base64UrlEncoder.Encode(ssJwtClaims);<br/>            byte[] bytesToEncrypt = new UTF8Encoding().GetBytes(textToEncrypt);</span><span id="202b" class="nn ko iq mt b gy oh oe l of og">var blockSize = encryptEngine.GetInputBlockSize();</span><span id="8695" class="nn ko iq mt b gy oh oe l of og">List&lt;byte&gt; output = new List&lt;byte&gt;();</span><span id="a78a" class="nn ko iq mt b gy oh oe l of og">for (int i = 0; i &lt; bytesToEncrypt.Length; i += blockSize)<br/>            {<br/>                var size = <br/>                    bytesToEncrypt.Length &lt; blockSize ? bytesToEncrypt.Length :<br/>                    i + blockSize &gt; bytesToEncrypt.Length ? bytesToEncrypt.Length - i :<br/>                    blockSize;</span><span id="a66b" class="nn ko iq mt b gy oh oe l of og">output.AddRange(encryptEngine.ProcessBlock(bytesToEncrypt, i, size));<br/>            }<br/>            <br/>            ssJwt = textToEncrypt + "." + Base64UrlEncoder.Encode(output.ToArray());<br/>  } // MssJwtCreate</span></pre><h2 id="b353" class="nn ko iq bd kp no np dn kt nq nr dp kx jy ns nt lb kc nu nv lf kg nw nx lj ny bi translated">验证JWT</h2><pre class="mf mg mh mi gt nz mt oa ob aw oc bi"><span id="6c71" class="nn ko iq mt b gy od oe l of og">public void MssJwtVerify(string ssJwt, object ssCertificate, out string ssJoseHeader, out string ssJwtClaims, out bool ssIsVerified)<br/>        {<br/>            string[] parts = ssJwt.Split('.');<br/>            if (parts.Length != 3)<br/>            {<br/>                throw new Exception("Invalid JWT: doesn't contain three parts");<br/>            }</span><span id="8d23" class="nn ko iq mt b gy oh oe l of og">ssJoseHeader = Base64UrlEncoder.Decode(parts[0]);<br/>            ssJwtClaims = Base64UrlEncoder.Decode(parts[1]);</span><span id="dfee" class="nn ko iq mt b gy oh oe l of og">var c = DotNetUtilities.FromX509Certificate((X509Certificate)ssCertificate);</span><span id="c8fd" class="nn ko iq mt b gy oh oe l of og">var encryptEngine = new Pkcs1Encoding(new RsaEngine());<br/>            encryptEngine.Init(false, (RsaKeyParameters)c.GetPublicKey());</span><span id="adb6" class="nn ko iq mt b gy oh oe l of og">var blockSize = encryptEngine.GetInputBlockSize();</span><span id="286b" class="nn ko iq mt b gy oh oe l of og">byte[] bytesToDecrypt = Base64UrlEncoder.DecodeBytes(parts[2]);<br/>            string output = "";</span><span id="58e4" class="nn ko iq mt b gy oh oe l of og">UTF8Encoding ue = new UTF8Encoding();</span><span id="b486" class="nn ko iq mt b gy oh oe l of og">for (int i = 0; i &lt; bytesToDecrypt.Length; i += blockSize)<br/>            {<br/>                var size =<br/>                    bytesToDecrypt.Length &lt; blockSize ? bytesToDecrypt.Length :<br/>                    i + blockSize &gt; bytesToDecrypt.Length ? bytesToDecrypt.Length - i :<br/>                    blockSize;</span><span id="8615" class="nn ko iq mt b gy oh oe l of og">output += ue.GetString(encryptEngine.ProcessBlock(bytesToDecrypt, i, size));<br/>            }</span><span id="3296" class="nn ko iq mt b gy oh oe l of og">ssIsVerified = output.Equals(parts[0] + "." + parts[1]);</span><span id="a543" class="nn ko iq mt b gy oh oe l of og">} // MssJwtVerify</span></pre></div><div class="ab cl nb nc hu nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ij ik il im in"><p id="7872" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">定义了更多的算法，但这些算法是目前最常用的。</p><p id="e068" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们在本地安装了该平台，可以访问运行该平台的Windows服务器。因此，我们将证书存储在Windows证书存储中。当然，这是不可取的，例如，当您有云基础架构时，有其他方法来提供证书。</p><p id="fc44" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一个<a class="ae km" href="https://en.wikipedia.org/wiki/Basic_access_authentication" rel="noopener ugc nofollow" target="_blank">基本认证</a>字符串以单词“basic”开头，后面是一个空格，再后面是一个Base64编码的用户名和密码字符串，并以冒号(“:”)作为分隔符。如果您允许在用户名和/或密码中使用冒号，您将需要以某种方式对它们进行编码，否则您将无法安全地确定分隔符在哪里。我使用了反斜杠(" \ ")来转义冒号。</p><p id="946b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">⁴Note:目前，我们还没有为过期的代币做准备。理想情况下，当令牌过期时，客户门户会自动请求新令牌，然后重试它发出的呼叫。但是不幸的是，除了为每一个被调用的方法实现这样的功能，使用外部系统是不容易做到的。</p></div></div>    
</body>
</html>