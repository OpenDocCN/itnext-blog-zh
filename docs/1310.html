<html>
<head>
<title>LINQ style declarative and functional programming with JavaScript using currying and generator functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">LINQ风格的声明式和函数式JavaScript编程，使用currying和生成器函数</h1>
<blockquote>原文：<a href="https://itnext.io/linq-style-declarative-and-functional-programming-with-javascript-using-currying-and-generator-9e266e0e32fa?source=collection_archive---------0-----------------------#2018-09-07">https://itnext.io/linq-style-declarative-and-functional-programming-with-javascript-using-currying-and-generator-9e266e0e32fa?source=collection_archive---------0-----------------------#2018-09-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jp jq jr js gh gi paragraph-image"><div role="button" tabindex="0" class="jt ju di jv bf jw"><div class="gh gi jo"><img src="../Images/d631259d529125f0b3d04726ac293aab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Dbl0ocjoiRsYQoTH"/></div></div><figcaption class="jz ka gj gh gi kb kc bd b be z dk translated"><a class="ae kd" href="https://unsplash.com/@jjying?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> JJ英</a>在<a class="ae kd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的“不锈钢链条倾斜移位镜头照片”</figcaption></figure><p id="dd47" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">LINQ是C#最好的特性之一，它提供了一种优雅的方式来编写易于阅读和理解的声明式和函数式代码。</p><p id="66e0" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">有了ES6的一些特性，比如生成器函数和currying等技术，很容易探索用JavaScript采用LINQ风格编程的各种可能性。请注意，使用来自<code class="fe lc ld le lf b">Array</code>对象的<code class="fe lc ld le lf b">map</code>、<code class="fe lc ld le lf b">reduce</code>、<code class="fe lc ld le lf b">filter</code>等内置方法，即使使用ES5 JavaScript也可以编写LINQ风格的代码。像<a class="ae kd" href="https://goo.gl/868bN1" rel="noopener ugc nofollow" target="_blank"> lodash </a>，<a class="ae kd" href="https://goo.gl/YHcEXz" rel="noopener ugc nofollow" target="_blank">understand</a>这样的多个库提供了处理集合和数组的综合方法，它们的编写将性能作为一个关键标准。</p><p id="cd51" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">我在这篇文章后面的目标是展示如何使用这些特性来编写更简洁和可读的代码。</p><blockquote class="lg lh li"><p id="bf8e" class="ke kf lj kg b kh ki kj kk kl km kn ko lk kq kr ks ll ku kv kw lm ky kz la lb ij bi translated">查看<a class="ae kd" href="https://github.com/bhosale-ajay/dotless" rel="noopener ugc nofollow" target="_blank"> dotless </a>，这是一个LINQ风格的JavaScript编程实验库。尝试“npm i dotless”</p></blockquote><h1 id="24aa" class="ln lo iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">Currying</h1><blockquote class="lg lh li"><p id="868e" class="ke kf lj kg b kh ki kj kk kl km kn ko lk kq kr ks ll ku kv kw lm ky kz la lb ij bi translated">Currying <strong class="kg ir"> </strong>是一种将带有多个参数的函数的求值转化为一系列函数的求值的技术，每个函数只有一个参数。— <a class="ae kd" href="https://goo.gl/x9EmgC" rel="noopener ugc nofollow" target="_blank">维基百科</a></p></blockquote><p id="ba04" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">让我们来看看实际情况</p><figure class="ml mm mn mo gt js"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="9dd4" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">正如您在这里看到的，Currying变成了一种方便的技术，可以用来编写可读性和表达性更强的函数。</p><h1 id="a98a" class="ln lo iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">发电机功能</h1><blockquote class="lg lh li"><p id="0642" class="ke kf lj kg b kh ki kj kk kl km kn ko lk kq kr ks ll ku kv kw lm ky kz la lb ij bi translated">生成器函数提供了一种编写定制迭代器的简单方法。使用<code class="fe lc ld le lf b">yield</code>关键字，程序流返回给调用者，所以请注意，使用生成器函数时，执行不是连续的。详情请参考<a class="ae kd" href="https://goo.gl/MMgwwC" rel="noopener ugc nofollow" target="_blank"> Mozilla文档</a>。</p></blockquote><p id="1ad2" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">让我们来看看它的运行，下面的代码摘自<a class="ae kd" href="https://goo.gl/Hk2Hsr" rel="noopener ugc nofollow" target="_blank">这篇文章</a>来自<a class="mr ms ep" href="https://medium.com/u/c359511de780?source=post_page-----9e266e0e32fa--------------------------------" rel="noopener" target="_blank"> Eric Elliott </a>，请参考它以了解更多关于生成器功能和其他ES6特性的细节。</p><figure class="ml mm mn mo gt js"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="674c" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">正如您从输出中看到的，程序流在来自<em class="lj"> Fibonacci </em>函数的<code class="fe lc ld le lf b">while</code>循环和消耗由<em class="lj"> Fibonacci </em>函数返回的生成器的<code class="fe lc ld le lf b">for</code>循环之间切换。</p><p id="0552" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">让我们结合currying和生成器函数来编写一些实用函数。</p><figure class="ml mm mn mo gt js"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="e626" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">让我们使用这些实用函数来编写一些代码</p><figure class="ml mm mn mo gt js"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="2f54" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">像<code class="fe lc ld le lf b">whichAreOdd</code>和<code class="fe lc ld le lf b">takeFour</code>这样的变量在某些情况下可能过于简化，但它们可以帮助重构复杂的代码，以清楚地表达其意图。Currying和generator使得代码可读性更好，同时也使得集合/迭代器的使用更加容易。</p><p id="87d6" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">现在人们可以得出结论，生成器函数是返回数组/集合的函数的替代函数，但它们是根本不同的。生成器函数(一种状态机)返回迭代器(惰性执行)而不是实际的数组，程序流在生成器函数和消费者之间切换。</p><p id="53da" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">生成器函数可以返回无限序列，而消费者只能决定从该序列中只取<em class="lj"> n </em>个项目。</p><p id="46ba" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">让我们将<em class="lj">斐波那契</em>函数与上述效用函数结合起来。</p><figure class="ml mm mn mo gt js"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="4887" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated"><a class="ae kd" href="https://goo.gl/nu9tyX" rel="noopener ugc nofollow" target="_blank">参考此代码笔</a>使用上述代码。我用这种风格来解决从<a class="ae kd" href="https://goo.gl/DuF3ao" rel="noopener ugc nofollow" target="_blank">代码</a>出现以来的编程难题，参考这里的<a class="ae kd" href="https://goo.gl/rxSVsi" rel="noopener ugc nofollow" target="_blank">库。有关详细信息，请查看</a><a class="ae kd" href="https://goo.gl/Pe82jG" rel="noopener ugc nofollow" target="_blank"> LINQ.ts </a>文件，该文件定义了编写表达性代码所需的大多数扩展。</p><p id="0607" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">感谢您的阅读，希望您觉得有用。</p></div></div>    
</body>
</html>