<html>
<head>
<title>Don’t dynamically import code in a directory</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">不要在目录中动态导入代码</h1>
<blockquote>原文：<a href="https://itnext.io/dont-dynamically-import-code-in-a-directory-838cedf9534a?source=collection_archive---------3-----------------------#2020-09-27">https://itnext.io/dont-dynamically-import-code-in-a-directory-838cedf9534a?source=collection_archive---------3-----------------------#2020-09-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="b7de" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一些开发人员正在追随一种趋势，即使用<code class="fe kl km kn ko b">fs</code>模块在NodeJS中按目录导入代码。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ku kv l"/></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">示例文件:src/models/index.js</figcaption></figure><p id="413e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这种方法的好处:</p><ul class=""><li id="56b8" class="la lb iq jp b jq jr ju jv jy lc kc ld kg le kk lf lg lh li bi translated">模块只需存在于一个目录中就可以导入。它们可以用作命名导出。</li></ul><pre class="kp kq kr ks gt lj ko lk ll aw lm bi"><span id="6a51" class="ln lo iq ko b gy lp lq l lr ls">import { users } = from "../models";</span><span id="a6eb" class="ln lo iq ko b gy lt lq l lr ls">or</span><span id="4ed6" class="ln lo iq ko b gy lt lq l lr ls">const { users } = require('../models');</span></pre><ul class=""><li id="27a3" class="la lb iq jp b jq jr ju jv jy lc kc ld kg le kk lf lg lh li bi translated">没有必要更新一个巨大的索引文件。(代码行更少；较少样板文件)</li><li id="682c" class="la lb iq jp b jq lu ju lv jy lw kc lx kg ly kk lf lg lh li bi translated">可能有一个业务或架构需求来实现这一点，这将使本文的其余部分成为一个争论点。</li></ul><blockquote class="lz ma mb"><p id="645c" class="jn jo mc jp b jq jr js jt ju jv jw jx md jz ka kb me kd ke kf mf kh ki kj kk ij bi translated">我错过了什么好处吗？让我知道，我会添加它。我不想通过忽略事实来误导。</p></blockquote><h1 id="e809" class="mg lo iq bd mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc bi translated">为什么不值得</h1><h2 id="ed6b" class="ln lo iq bd mh nd ne dn ml nf ng dp mp jy nh ni mt kc nj nk mx kg nl nm nb nn bi translated">1.该行为是意外的</h2><p id="4720" class="pw-post-body-paragraph jn jo iq jp b jq no js jt ju np jw jx jy nq ka kb kc nr ke kf kg ns ki kj kk ij bi translated">不是所有的开发人员都知道导入技巧，特别是因为它通常仅限于某些目录，比如模型。那些开发者可能会打破现有的模式，直接导入一个模块。</p><pre class="kp kq kr ks gt lj ko lk ll aw lm bi"><span id="d100" class="ln lo iq ko b gy lp lq l lr ls">const users = require("./models/users");</span></pre><p id="9bff" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，另一个开发人员可以为他们的模型复制/粘贴相同的导入，从而在代码库中产生两种不同的模式。</p><h2 id="9a7e" class="ln lo iq bd mh nd ne dn ml nf ng dp mp jy nh ni mt kc nj nk mx kg nl nm nb nn bi translated">2.未使用的文件可以运送给客户</h2><p id="1a3e" class="pw-post-body-paragraph jn jo iq jp b jq no js jt ju np jw jx jy nq ka kb kc nr ke kf kg ns ki kj kk ij bi translated">如果上面的代码示例没有验证扩展，那么可能有一个名为<code class="fe kl km kn ko b">.DS_Store</code>的模块(至少在Mac上)。</p><p id="a787" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一个名为<code class="fe kl km kn ko b">oxford-dictionary.js</code>的大文件会绕过那个过滤器。虽然它可能不会导致错误，但它不必要地增加了代码的大小。这似乎是一个极端的例子(确实如此)，但是在一个目录中有额外的文件并不罕见。许多开发人员将<code class="fe kl km kn ko b">*.spec.js</code>或<code class="fe kl km kn ko b">*.test.js</code>文件放在他们正在测试的代码旁边，以保持代码的可移植性。给定上面的代码示例，这些文件将包含在应用程序中。</p><p id="d29b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">denylist可以过滤掉不想要的文件，但是这又能如何呢？捕捉或调试边缘案例所花费的时间可能比输入<code class="fe kl km kn ko b">module.exports.users = require('./users');</code>或<code class="fe kl km kn ko b">export { default } from './users';</code>所花费的时间还要多</p><p id="32bf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一些树摇动代码捆绑器，像webpack，可能足够聪明去删除不用的文件，或者他们可能太愚蠢去包含你真正想要的文件。</p><h2 id="2300" class="ln lo iq bd mh nd ne dn ml nf ng dp mp jy nh ni mt kc nj nk mx kg nl nm nb nn bi translated">3.存在安全问题</h2><p id="3beb" class="pw-post-body-paragraph jn jo iq jp b jq no js jt ju np jw jx jy nq ka kb kc nr ke kf kg ns ki kj kk ij bi translated">包含代码的策略从allowlist更改为denylist。使用allowlist，只导入您想要包含的模块。denylist在这种情况下是有缺陷的，因为需要考虑要排除的每个名称组合。</p><p id="1c8b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果黑客或心怀不满的员工获得了对服务器的访问权，他们可以在目录中包含<code class="fe kl km kn ko b">bitcoin-miner.js</code>，巧妙地使用您的服务器和进程ID (PID)来运行他们的代码。他们需要做的就是重新开始这个过程。</p><h2 id="aee7" class="ln lo iq bd mh nd ne dn ml nf ng dp mp jy nh ni mt kc nj nk mx kg nl nm nb nn bi translated">4.代码编辑器(ide)找不到你的定义</h2><p id="96eb" class="pw-post-body-paragraph jn jo iq jp b jq no js jt ju np jw jx jy nq ka kb kc nr ke kf kg ns ki kj kk ij bi translated">有些ide，如VSCode，使用静态定义的导入语句来导航代码库。但是，通过文件系统进行动态导入时，一些功能会停止工作:</p><ul class=""><li id="26ef" class="la lb iq jp b jq jr ju jv jy lc kc ld kg le kk lf lg lh li bi translated">编辑器会告诉你没有找到目标模块的定义。</li><li id="dbc6" class="la lb iq jp b jq lu ju lv jy lw kc lx kg ly kk lf lg lh li bi translated"><code class="fe kl km kn ko b">Rename Symbols</code>更改文件名不会更新参照，重命名参照也不会更新文件名。</li><li id="4182" class="la lb iq jp b jq lu ju lv jy lw kc lx kg ly kk lf lg lh li bi translated"><code class="fe kl km kn ko b">Go to References</code>IDE不会知道你的模块用在哪里。就它而言，你的模块不存在。</li><li id="a036" class="la lb iq jp b jq lu ju lv jy lw kc lx kg ly kk lf lg lh li bi translated"><code class="fe kl km kn ko b">Intellisense/Auto-complete</code>从模块导入时，上下文菜单中没有命名导出列表。</li></ul><blockquote class="lz ma mb"><p id="d460" class="jn jo mc jp b jq jr js jt ju jv jw jx md jz ka kb me kd ke kf mf kh ki kj kk ij bi translated">你的IDE或插件能更好地处理这个问题吗？让我知道，我会更新这一部分。</p></blockquote><h2 id="2199" class="ln lo iq bd mh nd ne dn ml nf ng dp mp jy nh ni mt kc nj nk mx kg nl nm nb nn bi translated">5.静态分析和林挺工具分析静态代码</h2><p id="a04d" class="pw-post-body-paragraph jn jo iq jp b jq no js jt ju np jw jx jy nq ka kb kc nr ke kf kg ns ki kj kk ij bi translated">出于与上一点相同的原因，静态分析或林挺工具可能会认为import/require语句无效，因为它们找不到显式的export语句。</p><p id="5565" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">开发人员可能会浪费时间去理解为什么会引入一个bug，结果却发现似乎无害地删除一个“未使用的”导入才是问题所在。</p><blockquote class="lz ma mb"><p id="5257" class="jn jo mc jp b jq jr js jt ju jv jw jx md jz ka kb me kd ke kf mf kh ki kj kk ij bi translated">我说“可能”是因为我只运行了一个林挺工具，而不是一个全功能的静态分析工具来验证。当测试eslint-plugin-import时，只有在当前文件中没有使用导入时，linter才尝试从外部验证模块的存在。然而，我在过去使用其他语言和旧版本的工具(如Codacy)时遇到过这种情况。</p></blockquote><h2 id="8038" class="ln lo iq bd mh nd ne dn ml nf ng dp mp jy nh ni mt kc nj nk mx kg nl nm nb nn bi translated">6.手动搜索定义非常繁琐</h2><p id="2591" class="pw-post-body-paragraph jn jo iq jp b jq no js jt ju np jw jx jy nq ka kb kc nr ke kf kg ns ki kj kk ij bi translated">开发人员可能很难手动找到定义。当搜索像<code class="fe kl km kn ko b">users</code>这样的模型时，可能会有数百个结果。此外，VSCode在主搜索中不包括文件名。因此，找到下面定义的示例用户模型(带有未命名的导出)可能会很困难。</p><pre class="kp kq kr ks gt lj ko lk ll aw lm bi"><span id="fea6" class="ln lo iq ko b gy lp lq l lr ls">module.exports = { // ES6: export default<br/>  create: () =&gt; { ... },<br/>  read: () =&gt; { ... },<br/>  update: () =&gt; { ... },<br/>  delete: () =&gt; { ... }<br/>};</span></pre><p id="7e9c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">(你可以通过<code class="fe kl km kn ko b">Go to File</code>搜索找到它)</p><h2 id="ae6d" class="ln lo iq bd mh nd ne dn ml nf ng dp mp jy nh ni mt kc nj nk mx kg nl nm nb nn bi translated">7.添加一两行代码并不是负担</h2><blockquote class="nt"><p id="5d5f" class="nu nv iq bd nw nx ny nz oa ob oc kk dk translated">事实上，花在阅读和写作上的时间比远远超过10比1。作为编写新代码工作的一部分，我们不断地阅读旧代码。…[因此，]让它容易阅读，就更容易写作。</p><p id="3544" class="nu nv iq bd nw nx ny nz oa ob oc kk dk translated">― <strong class="ak">罗伯特·c·马丁，</strong> <a class="ae od" href="https://www.goodreads.com/work/quotes/3779106" rel="noopener ugc nofollow" target="_blank"> <strong class="ak">干净的代码:敏捷软件技术手册</strong> </a></p></blockquote><p id="a179" class="pw-post-body-paragraph jn jo iq jp b jq oe js jt ju of jw jx jy og ka kb kc oh ke kf kg oi ki kj kk ij bi translated">显式导入模块只需几秒钟，可读性更好。将一个<code class="fe kl km kn ko b">index.js</code>文件视为一个允许列表，而不是样板代码。</p><h2 id="bee1" class="ln lo iq bd mh nd ne dn ml nf ng dp mp jy nh ni mt kc nj nk mx kg nl nm nb nn bi translated">8.删除代码时，您仍然需要更新引用</h2><p id="5432" class="pw-post-body-paragraph jn jo iq jp b jq no js jt ju np jw jx jy nq ka kb kc nr ke kf kg ns ki kj kk ij bi translated">删除<code class="fe kl km kn ko b">users</code>模型时不需要更新<code class="fe kl km kn ko b">models/index.js</code>文件。一些开发人员认为更容易删除代码是一个好处。然而，由于需要手动搜索用法(例如:<code class="fe kl km kn ko b">const { users } = require('./models'); users.create();</code>)，代码删除变得更加困难。因此，这不包括在福利清单中。</p><h2 id="ef2c" class="ln lo iq bd mh nd ne dn ml nf ng dp mp jy nh ni mt kc nj nk mx kg nl nm nb nn bi translated">9.更少的代码行并不总是意味着更好的代码</h2><p id="6b4f" class="pw-post-body-paragraph jn jo iq jp b jq no js jt ju np jw jx jy nq ka kb kc nr ke kf kg ns ki kj kk ij bi translated">一些开发人员将简洁等同于简单。你可以从下面的例子中看出为什么不是这样的。</p><pre class="kp kq kr ks gt lj ko lk ll aw lm bi"><span id="61a9" class="ln lo iq ko b gy lp lq l lr ls">// One line of code<br/>const state = lastLoginTime - now &lt; 1000 ? loginAttempts &gt; 10 ? "Locked" : "Active" : "Inactive"</span></pre></div><div class="ab cl oj ok hu ol" role="separator"><span class="om bw bk on oo op"/><span class="om bw bk on oo op"/><span class="om bw bk on oo"/></div><div class="ij ik il im in"><pre class="lj ko lk ll aw lm bi"><span id="523d" class="ln lo iq ko b gy oq or os ot ou lq l lr ls">// 9 lines of code<br/>let state = "Inactive";</span><span id="99a5" class="ln lo iq ko b gy lt lq l lr ls">if (loginAttempts &gt; 10) {<br/>  state = "Locked";<br/>}</span><span id="e25e" class="ln lo iq ko b gy lt lq l lr ls">if (lastLoginTime - now &lt; 1000) {<br/>  state = "Active"<br/>}</span></pre><p id="15c4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第二个例子比第一个例子长八行，但是更容易理解。</p><h1 id="3ed2" class="mg lo iq bd mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc bi translated">结论</h1><p id="120b" class="pw-post-body-paragraph jn jo iq jp b jq no js jt ju np jw jx jy nq ka kb kc nr ke kf kg ns ki kj kk ij bi translated">虽然自动导入代码看起来很吸引人，但可能不值得引入复杂性。一个让一个开发人员节省30秒的技巧可能会偷走另一个开发人员的一个小时——故障排除。或者，没有时间会因为缺乏意识而被浪费，无关的导入会潜入到产品代码中。</p><blockquote class="lz ma mb"><p id="a32c" class="jn jo mc jp b jq jr js jt ju jv jw jx md jz ka kb me kd ke kf mf kh ki kj kk ij bi translated">虽然这篇文章偏向于一个特定的结果，但事实不应该如此。如果你觉得我遗漏了重要的信息或者夸大了什么，请在评论中告诉我。</p></blockquote></div></div>    
</body>
</html>