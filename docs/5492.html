<html>
<head>
<title>Using async/await inside loops in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在JavaScript中使用async/await内部循环</h1>
<blockquote>原文：<a href="https://itnext.io/using-async-await-inside-loops-in-javascript-5b0ccc9f0ef4?source=collection_archive---------1-----------------------#2021-03-17">https://itnext.io/using-async-await-inside-loops-in-javascript-5b0ccc9f0ef4?source=collection_archive---------1-----------------------#2021-03-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/01c61b9bf5105e9d07b0851fcb85035c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_xOXkK81QhSFoAxOZ7AmFw.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">由<a class="ae kf" href="https://unsplash.com/@layton?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">雷顿钻石</a>在<a class="ae kf" href="/s/photos/marina?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="17da" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">遍历条目和处理异步逻辑(即API调用)可能是我们作为JavaScript开发人员必须执行的两个最常见的任务。在本文中，我们将讨论结合async/await和迭代逻辑的最佳方法。有时，您会希望在for循环(或任何其他类型的循环)中运行异步操作。让我们来看看如何处理这种情况。</p><h1 id="8887" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">按顺序阅读承诺</h1><p id="f516" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">假设我们有一个文件列表，我们想读取并记录序列中每个文件的内容。我们该怎么做？嗯，我们可以在异步函数中使用循环的<strong class="ki iu">。下面是代码片段。</strong></p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="d11b" class="mq lf it mm b gy mr ms l mt mu">async function printFiles () {<br/>  let fileNames = ['picard', 'kirk', 'geordy', 'ryker', 'worf'];<br/>  for (const file of fileNames) {<br/>    const contents = await fs.readFile(file, 'utf8');<br/>    console.log(contents);<br/>  }<br/>}</span></pre><blockquote class="mv mw mx"><p id="0bdf" class="kg kh my ki b kj kk kl km kn ko kp kq mz ks kt ku na kw kx ky nb la lb lc ld im bi translated">💡<em class="it">注意，如果你想按顺序读取文件，你</em> <strong class="ki iu"> <em class="it">不能</em> </strong> <em class="it">使用</em><strong class="ki iu"><em class="it">forEach</em></strong><em class="it">循环。</em></p></blockquote><p id="8d8a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们用一个简单的例子来详细说明这一点。</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="9739" class="mq lf it mm b gy mr ms l mt mu">async function someFunction(items) {<br/>  items.forEach( async(i) =&gt; {<br/>     const res = await someAPICall(i);<br/>     console.log('---&gt;', res);<br/>  });<br/>}</span><span id="cf14" class="mq lf it mm b gy nc ms l mt mu">function someAPICall(param) {<br/>    return new Promise((resolve, reject)=&gt;{<br/>      setTimeout(()=&gt;{<br/>        resolve("Resolved" + param)<br/>      },param);<br/>    })<br/>}</span><span id="ff50" class="mq lf it mm b gy nc ms l mt mu">someFunction(['3000','8000','1000','4000']);</span></pre><p id="0b8c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们有一个简单的异步函数，名为<strong class="ki iu"> someFunction，</strong>，它接受一个数组作为参数，迭代数组，并为每一项发出一个API请求(通过假的API函数)。在这种情况下，我们希望按顺序解析API调用。我们希望我们的输出打印如下</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="66d9" class="mq lf it mm b gy mr ms l mt mu">// expected<br/>3000<br/>8000<br/>1000<br/>4000</span></pre><p id="7239" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们看到的不是这个输出，而是下面的结果</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="541c" class="mq lf it mm b gy mr ms l mt mu">// actual<br/>1000<br/>3000<br/>4000<br/>8000</span></pre><p id="2a72" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">forEach循环不是按顺序运行API调用，而是一个接一个地设置API调用。它不会等待上一个调用结束。这就是为什么我们会得到先解决的承诺。这是我们不能使用forEach循环的主要原因。</p><p id="50be" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">相反，我们可以使用一个<strong class="ki iu"> reduce </strong>函数来迭代数组并依次解析承诺。让我们快速看一个例子。</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="174e" class="mq lf it mm b gy mr ms l mt mu">function testPromise(time) {<br/>  return new Promise((resolve, reject) =&gt; {<br/>    setTimeout(() =&gt; {<br/>      console.log(`Processing ${time}`);<br/>      resolve(time);<br/>    }, time);<br/>  });<br/>}</span><span id="333b" class="mq lf it mm b gy nc ms l mt mu">let result = [3000,2000,1000, 4000].reduce( (accumulatorPromise, nextID) =&gt; {<br/>  return accumulatorPromise.then(() =&gt; {<br/>    return testPromise(nextID);<br/>  });<br/>}, Promise.resolve());</span><span id="c061" class="mq lf it mm b gy nc ms l mt mu">result.then(e =&gt; {<br/>  console.log("All Promises Resolved !!✨")<br/>});</span></pre><p id="1e01" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">很整洁不是吗？另一种解决序列承诺的方法是使用<strong class="ki iu">异步生成器。</strong></p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="281c" class="mq lf it mm b gy mr ms l mt mu">async function* readFiles(files) {<br/>  for(const file of files) {<br/>    yield await readFile(file);<br/>  }<br/>};</span></pre><p id="a7ae" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">生成器和大多数现代浏览器和Node 10及以上版本的支持。你可以在这里了解更多关于Javascript <a class="ae kf" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators" rel="noopener ugc nofollow" target="_blank">中的生成器和迭代器。</a></p><h1 id="dc89" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">并行解决承诺</h1><p id="f305" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">接下来，让我们看看如何并行解决承诺。让我们回到第一个例子。我们现在想并行读取文件，而不是按顺序读取。在这个场景中，我们不关心内容在控制台中的打印顺序。因此，我们可以简单地使用一个<strong class="ki iu"> Promise.all() </strong>函数和一个<strong class="ki iu"> map </strong>。</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="cba7" class="mq lf it mm b gy mr ms l mt mu">async function printFiles () {<br/>  let fileNames = ['picard', 'kirk', 'geordy', 'ryker', 'worf'];<br/>  await Promise.all(fileNames.map(async (file) =&gt; {<br/>    const contents = await fs.readFile(file, 'utf8');<br/>    console.log(contents);<br/>  }));<br/>}</span></pre><p id="e0e3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">每个<code class="fe nd ne nf mm b">async</code>回调函数调用都返回一个承诺，我们用一个Prmiss.all()并行地一次存储和解析它们。</p><p id="ac3a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我希望这篇快速阅读能让您深入了解如何在循环中使用异步代码。今天到此为止，下次再见。</p><p id="3b5b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">参考文献:</strong></p><p id="6348" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae kf" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/JavaScript/Guide/Iterators _ and _ Generators</a></p><p id="b31d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae kf" href="https://stackoverflow.com/questions/37576685/using-async-await-with-a-foreach-loop" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/37576685/using-async-await-with-a-foreach-loop</a></p><p id="dc9b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae kf" href="https://css-tricks.com/why-using-reduce-to-sequentially-resolve-promises-works/" rel="noopener ugc nofollow" target="_blank">https://CSS-tricks . com/why-using-reduce-to-sequentially-resolve-promises-works/</a></p></div></div>    
</body>
</html>