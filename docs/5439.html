<html>
<head>
<title>Revealing the magic of AST by writing babel plugins</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过编写babel插件揭示AST的魔力</h1>
<blockquote>原文：<a href="https://itnext.io/revealing-the-magic-of-ast-by-writing-babel-plugins-11a1af8d70ae?source=collection_archive---------3-----------------------#2021-03-05">https://itnext.io/revealing-the-magic-of-ast-by-writing-babel-plugins-11a1af8d70ae?source=collection_archive---------3-----------------------#2021-03-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/3e0ecbcc15abd84e6fbe580b6adbcc08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*pXjGXzG1LePGKFjw.png"/></div></div></figure><p id="4e4b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当你听到抽象语法树的时候，你脑海中第一个想到的是什么？<br/>与编译器有关？一些复杂的树操作？比特操作？🤔</p><p id="9478" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在我职业生涯的开始，AST看起来像是一个复杂的术语，其中夹杂着低级编译器和转换编译器的魔力。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="0c89" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">💡动机</h1><p id="5998" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">写这篇博客的动机是让每个人都容易理解什么是抽象语法树，以及它们如何在我们日常使用的大多数工具中发挥重要作用。</p><p id="12d1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">无论是babel、webpack、parcel、eslint、codemods、css解析器、js中的CSS——所有这些工具都使用AST的魔力来操纵我们的代码，并将其转换成其他东西。</p><p id="0da1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在本帖中，我们将揭开这个魔法，并在这个过程中学习编写一些超级简单的巴别塔插件。是🎉</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="40e9" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">🤔什么是AST？</h1><p id="2491" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">像每个新概念一样，我们将从一个具体的定义开始。<br/>根据维基百科</p><blockquote class="mj mk ml"><p id="53ab" class="kb kc mm kd b ke kf kg kh ki kj kk kl mn kn ko kp mo kr ks kt mp kv kw kx ky im bi translated"><em class="it">抽象语法树是用编程语言编写的源代码的树表示。树的每个节点表示源代码中出现的一个构造。</em></p></blockquote><p id="5058" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了理解这一点，假设我们在编辑器中编写了一行简单的代码</p><figure class="mq mr ms mt gt ju"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="e034" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是一个非常简单的变量赋值和两个数的相加。<br/>这个简单的操作经历了一个<code class="fe mw mx my mz b">Tokenization</code>和<code class="fe mw mx my mz b">Parsing</code>的过程。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="8ea7" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">🕹️标记化(词法分析)</h1><p id="c063" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">标记化或词法分析是函数将代码作为字符串读取并将其拆分为一系列标记的步骤。</p><p id="5dfc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了简单起见，让我们假设每个令牌都有以下接口</p><figure class="mq mr ms mt gt ju"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="97a6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们的代码经过词法分析的过程，并被分解成记号。</p><figure class="mq mr ms mt gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi na"><img src="../Images/3178b601904b4ae98e792a9e2d288d70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2H8mNacm1uDkrF-WJNwFDQ.png"/></div></div></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="a52a" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">🧵分析(句法分析)</h1><p id="0efe" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">后词法分析给我们一个令牌数组，我们通过AST解析器(babylon或acorn或espree)将它转换成AST节点树，在它们之间建立依赖关系。</p><figure class="mq mr ms mt gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nb"><img src="../Images/60edb4638c9f0620ae5f5c6ba71b06bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I9-as-T6nBQPJhitVQn3sQ.png"/></div></div></figure><p id="59d2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们写的超级简单的代码被转换成一个节点树，我们称之为抽象语法树。</p><p id="009f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">整个树以下面的方式表示为一个json</p><figure class="mq mr ms mt gt ju"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="566d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这个json对象中，我们注意到一个名为<code class="fe mw mx my mz b">type</code>的参数。我们称之为AST节点类型。<br/>存在多种类型的AST节点，对于babel，我们可以参考以下<br/> <a class="ae nc" href="https://babeljs.io/docs/en/babel-types" rel="noopener ugc nofollow" target="_blank"> Babel AST节点类型</a></p><p id="85a0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于espree解析器(eslint使用的那个),我们可以参考这里的<a class="ae nc" href="https://github.com/estree/estree/blob/master/es5.md" rel="noopener ugc nofollow" target="_blank"> Eslint AST节点类型</a></p><p id="9154" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Babel、webpack、parcel和所有这些工具都使用一种通用的方法。他们首先将我们的代码转换成AST树，然后对其应用一些转换(添加、编辑、更新、删除)，从这些转换中创建一个新的树，然后将其转换回人类可读的代码。</p><figure class="mq mr ms mt gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nd"><img src="../Images/d7f09312be62d279f51736a5ddedf091.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rECKTqTkoHwhzZcclBx5lg.png"/></div></div></figure><p id="5347" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了理解特定代码行的AST树表示是什么样子，我建议总是检查<a class="ae nc" href="https://astexplorer.net/" rel="noopener ugc nofollow" target="_blank"> AST Explorer </a></p><p id="813f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，不浪费任何时间，我们将编写我们的第一个巴别塔插件。这个插件将删除我们代码中可能有的任何调试器语句。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="c94d" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">📕Babel插件—删除调试器</h1><p id="1824" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">考虑在您的repo的多个位置使用以下代码</p><figure class="mq mr ms mt gt ju"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="36a5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">很明显，我们不希望这个调试器语句出现在我们的生产应用程序中。<br/>(注意:在现实世界的应用程序中，我们会有一些捆绑器或一些部署管道步骤，可以帮助我们避免这样的错误，但为了这个例子，让我们假设我们没有任何这样的部署管道)。</p><p id="5ead" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">所以我们写了一个巴别塔插件来为我们做同样的事情。</p><h1 id="5b09" class="lg lh it bd li lj ne ll lm ln nf lp lq lr ng lt lu lv nh lx ly lz ni mb mc md bi translated">编写一个巴别塔插件</h1><p id="43d8" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated"><strong class="kd iu">步骤1 </strong>:识别我们想要定位的AST节点类型。如果我们转到AST Explorer并单击第2行，我们会注意到节点类型以黄色突出显示，它显示我们必须定位的AST节点是<code class="fe mw mx my mz b">DebuggerStatement</code>。</p><figure class="mq mr ms mt gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nj"><img src="../Images/708d6ebfb3ca7ceef6963f8d7573544f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AfqGZehT-zVY3hvhABt3tA.png"/></div></div></figure><p id="a8ef" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">第二步</strong>:启动编辑器，创建新文件。姑且称之为<code class="fe mw mx my mz b">removeDebugger.js</code>。这将是我们的插件文件。</p><p id="3899" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">从现在开始，我们编写的每一个巴别塔插件都将遵循一个通用的模式</p><figure class="mq mr ms mt gt ju"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="888b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将返回一个包含另一个嵌套对象的对象，其中包含关键字<code class="fe mw mx my mz b">visitor</code>。由于访问者模式，它被命名为visitor。</p><p id="5f26" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">步骤3 </strong>:我们知道我们希望定位的节点类型是<code class="fe mw mx my mz b">DebuggerStatement</code></p><p id="b666" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">所以我们的代码现在看起来像这样</p><figure class="mq mr ms mt gt ju"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="e848" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们希望定位的每个节点都必须是visitor对象中的一个键。</p><p id="9549" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">步骤4 </strong>:现在这个babel插件剩下的唯一一步就是移除调试器语句节点，我们这样做:</p><figure class="mq mr ms mt gt ju"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="648b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我的朋友是我们的第一个巴别塔插件。</p><p id="9739" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这个babel插件向我们解释了如何通过删除一个节点来操作一个AST。</p><p id="70b1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将学习的下一个插件将向我们解释如何编辑一个现有的节点，并将其转换成其他东西</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="a142" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">📕巴别塔插件—向控制台发出警报</h1><p id="1e67" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">所以在这里我们将把每个<code class="fe mw mx my mz b">alert</code>语句转换成一个<code class="fe mw mx my mz b">console.warn</code>语句。</p><p id="2de4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">所以我们希望修改的代码应该是这样的</p><figure class="mq mr ms mt gt ju"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="7c9b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将把它转换成</p><figure class="mq mr ms mt gt ju"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="9762" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">步骤1 </strong>:识别我们想要定位的AST节点类型。转到AST explorer并复制粘贴我们的<code class="fe mw mx my mz b">from</code>代码，然后点击<code class="fe mw mx my mz b">alert</code>。它将在右侧突出显示节点类型。我们看到现在要定位的节点类型叫做<code class="fe mw mx my mz b">CallExpression</code>。</p><figure class="mq mr ms mt gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nk"><img src="../Images/b1eac0d24243c2c0ba2136b4729f3e7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_U18M92JjLVvlfiGiL8TOw.png"/></div></div></figure><p id="8e06" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">所以任何函数调用都是一个<code class="fe mw mx my mz b">CallExpression</code>，任何对象上的函数调用都被称为<code class="fe mw mx my mz b">MemberExpression</code>。所以<code class="fe mw mx my mz b">alert</code>是<code class="fe mw mx my mz b">CallExpression</code>，<code class="fe mw mx my mz b">console.warn</code>是<code class="fe mw mx my mz b">MemberExpression</code>。</p><p id="24d6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在我们的例子中，MemberExpression总是有一个对象(控制台)和一个属性(警告)。</p><p id="cea9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">步骤2 </strong>:再次启动编辑器，创建新文件。姑且称之为<code class="fe mw mx my mz b">convertAlertToConsole.js</code>。</p><p id="c6c1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">就像在我们用框架代码开始插件之前一样</p><figure class="mq mr ms mt gt ju"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="bbd7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">第三步</strong>:现在我们知道了我们的目标节点是一个<code class="fe mw mx my mz b">CallExpression</code>，让我们来写代码</p><figure class="mq mr ms mt gt ju"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="0db3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">步骤4 </strong>:因为我们不希望将目标指向所有其他的函数调用，所以让我们设置一个if条件来指定我们只希望将名为<code class="fe mw mx my mz b">alert</code>的调用表达式作为目标</p><figure class="mq mr ms mt gt ju"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="a586" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在唯一剩下的部分就是想出用什么来代替它。</p><p id="4b66" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">步骤5 </strong>:我们回到AST explorer，这次复制我们的<code class="fe mw mx my mz b">to</code>代码，点击console.warn会告诉我们，我们需要用另一个调用表达式替换它，因为所有的函数调用都是调用表达式，但是因为这是一个<code class="fe mw mx my mz b">object property function call</code>，这就是为什么它需要一个调用表达式，其中有一个成员表达式作为它的被调用者。</p><figure class="mq mr ms mt gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nl"><img src="../Images/b5631bd2fbfc8299a71690ab6dffddca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pv-LRNzhc_YyOnS_BlEBvQ.png"/></div></div></figure><figure class="mq mr ms mt gt ju"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="7c5e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">仅此而已。我们也写了我们的第二个插件🥳.这一切是不是太简单了？🤗</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="e9cc" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">📕奖励插件——从react应用程序中删除数据测试id</h1><p id="0af7" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">在这种情况下，我们将从react应用程序中移除每个<code class="fe mw mx my mz b">data-test-id</code>属性。由于<code class="fe mw mx my mz b">data-test-id</code>通常只在dev env中需要，我们的插件可以安全地将它从我们的产品包中移除。</p><p id="2297" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">所以我们希望修改的代码应该是这样的</p><figure class="mq mr ms mt gt ju"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="28b6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将把它转换成</p><figure class="mq mr ms mt gt ju"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="711e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">步骤1 </strong>:识别我们想要定位的AST节点类型。转到AST explorer并复制粘贴我们的<code class="fe mw mx my mz b">from</code>代码，然后点击<code class="fe mw mx my mz b">data-test-id</code>。它将在右侧突出显示节点类型。我们看到现在要定位的节点类型叫做<code class="fe mw mx my mz b">JSXAttribute</code>。</p><figure class="mq mr ms mt gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nm"><img src="../Images/3af5b68964948b7249d2bbf1a83f9a2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QJq4URBkq42P3YfsT2h2YA.png"/></div></div></figure><p id="5144" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">第二步:启动你的编辑器，创建一个新文件。姑且称之为<code class="fe mw mx my mz b">removeDataAttribute.js</code>。就像在我们用框架代码开始插件之前一样</p><figure class="mq mr ms mt gt ju"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="e4b4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">第3步</strong>:现在我们知道我们的目标节点是一个<code class="fe mw mx my mz b">JSXAttribute</code>，让我们写代码</p><p id="530c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">所以我们的代码现在看起来像这样</p><figure class="mq mr ms mt gt ju"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="b6c1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">步骤4 </strong>:现在这个babel插件剩下的唯一一步就是移除这个jsx属性节点，我们这样做:</p><figure class="mq mr ms mt gt ju"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="87b9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">仅此而已。我们写了另一个插件🥳.</p><p id="0203" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Github回购:【https://github.com/vivek12345/webcamp-zagreb-demo T2】</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="6693" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">🍬结论</h1><p id="e50f" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">我希望这有助于我们理解AST并不复杂，我们都可以通过制作linter插件或编写babel插件或使用codemods进行大规模重构来改进我们的开发人员工具生态系统。如果你有心情，你也可以用js库写一个css。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="f70d" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">🔗参考</h1><ul class=""><li id="9ae7" class="nn no it kd b ke me ki mf km np kq nq ku nr ky ns nt nu nv bi translated"><a class="ae nc" href="https://medium.com/basecs/leveling-up-ones-parsing-game-with-asts-d7a6fc2400ff" rel="noopener">升级解析游戏</a></li><li id="9670" class="nn no it kd b ke nw ki nx km ny kq nz ku oa ky ns nt nu nv bi translated">费利克斯·克林的《AST探险家》</li><li id="557d" class="nn no it kd b ke nw ki nx km ny kq nz ku oa ky ns nt nu nv bi translated"><a class="ae nc" href="https://github.com/jamiebuilds/babel-handbook" rel="noopener ugc nofollow" target="_blank">巴别塔手册</a></li><li id="29c5" class="nn no it kd b ke nw ki nx km ny kq nz ku oa ky ns nt nu nv bi translated"><a class="ae nc" href="https://lihautan.com/step-by-step-guide-for-writing-a-babel-transformation/" rel="noopener ugc nofollow" target="_blank">一步一步指南写巴别塔改造</a></li><li id="8c81" class="nn no it kd b ke nw ki nx km ny kq nz ku oa ky ns nt nu nv bi translated"><a class="ae nc" href="https://www.youtube.com/watch?v=669ste6xgkks&amp;ab_channel=HasgeekTV" rel="noopener ugc nofollow" target="_blank">AST的神奇之地</a></li></ul></div></div>    
</body>
</html>