<html>
<head>
<title>Kafka-aware security for Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向Kubernetes的Kafka感知安全性</h1>
<blockquote>原文：<a href="https://itnext.io/kafka-aware-security-for-kubernetes-a57b22bd0852?source=collection_archive---------6-----------------------#2020-02-24">https://itnext.io/kafka-aware-security-for-kubernetes-a57b22bd0852?source=collection_archive---------6-----------------------#2020-02-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/be38a30d1ed222bfcbada7fed4507b80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xrugjFO3hrBU3ZuS"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">miosz klin owski在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="ff4c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">说到卡夫卡，细粒度的安全非常重要。通常，流经Kafka的数据来自许多组件，并且通常包含不应该被任何没有特权的人使用的信息。在<a class="ae kc" href="https://cilium.io/" rel="noopener ugc nofollow" target="_blank"> Cilium </a>的帮助下，我们可以直接在Linux内核层实施Kafka感知安全策略，这意味着无需对应用程序代码或容器配置进行任何更改。</p><p id="5c8e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用标准的Kafka设置，任何用户或应用程序都可以向任何主题编写任何消息，以及从任何主题读取数据。</p><p id="6fc4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">保护Kafka的一种典型方法是为每个客户颁发SSL证书，并强制Kafka经纪人验证其有效性。另一个选择是使用SASL，它有几种不同的应用方式(经典用户名/密码，Kerberos等)，但是开始并不容易。这只是身份验证，向授权迈进—事情变得更加复杂(在更大范围内使用kafka-acl命令具有挑战性)。让我们看看怎样才能做到和卡夫卡完全不同，完全独立。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><p id="026e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将使用一个名为Cilium的工具，它使用eBPF技术在一个完全不同的层面上保护Kafka。首先说一下纤毛本身。一个很好的解释是在他们自己的<a class="ae kc" href="https://cilium.io/" rel="noopener ugc nofollow" target="_blank">网站</a>:</p><blockquote class="li lj lk"><p id="8ab5" class="kd ke ll kf b kg kh ki kj kk kl km kn lm kp kq kr ln kt ku kv lo kx ky kz la ij bi translated">现有的Linux网络安全机制(例如，iptables)仅在网络和传输层(即，IP地址和端口)运行，并且缺乏对微服务层的可见性。</p><p id="9d8c" class="kd ke ll kf b kg kh ki kj kk kl km kn lm kp kq kr ln kt ku kv lo kx ky kz la ij bi translated">Cilium为Linux容器框架带来了API感知的网络安全过滤，如<a class="ae kc" href="https://www.docker.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> Docker </strong> </a>和<a class="ae kc" href="https://kubernetes.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> Kubernetes </strong> </a>。使用名为<strong class="kf ir"> eBPF </strong>的新Linux内核技术，Cilium提供了一种简单有效的方法来定义和实施基于容器/pod身份的网络层和应用层安全策略。</p></blockquote><p id="801a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你需要了解的是，Cilium是一个可以安装在Kubernetes上的工具，它使用eBPF来实现下一级或云原生网络过滤。那eBPF是什么？最佳解释:布兰登·格雷格:</p><blockquote class="li lj lk"><p id="abb6" class="kd ke ll kf b kg kh ki kj kk kl km kn lm kp kq kr ln kt ku kv lo kx ky kz la ij bi translated">eBPF 对Linux的作用就像JavaScript对HTML的作用一样。(算是吧。)因此，与静态HTML网站不同，JavaScript让你定义在鼠标点击等事件上运行的迷你程序，这些程序在浏览器中的安全虚拟机中运行。使用eBPF，而不是一个固定的内核，您现在可以编写迷你程序，运行在发送/接收TCP包等事件上，这些事件运行在内核中的安全虚拟机上。实际上，eBPF更像是运行JavaScript的v8虚拟机，而不是JavaScript本身。eBPF是Linux内核的一部分。</p></blockquote><p id="0b27" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么，这一切如何转化为在Kubernetes上保护卡夫卡呢？通过使用eBPF技术，Cilium可以直接与Linux内核对话，并对pod应用安全策略，如“pod X只能从Kafka topic Y读取，pod Z只能向Kafka topic W写入”。所有这些都是通过在我们的Kubernetes集群上应用简单的yaml定义来实现的。</p><figure class="lq lr ls lt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lp"><img src="../Images/de8a5b863e1b81ae40c23437fe87fdd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NXqQcloreLXOCpqn"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">由<a class="ae kc" href="https://unsplash.com/@brazofuerte?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">科林·阿姆斯特朗</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><p id="2263" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们现在已经有足够的理论了，所以让我们进入正题。假设您在Kubernetes集群上运行Kafka集群，那么您需要做的第一件事当然是安装Cilium。我不会在这里讨论它，因为按照<a class="ae kc" href="https://docs.cilium.io/en/v1.7/gettingstarted/#installation" rel="noopener ugc nofollow" target="_blank">纤毛文件</a>上的说明，它是非常简单的。如果您已经安装了Cilium，就可以用一个(或多个)简单的YAML文件来保护您的Kafka集群了。正如我前面提到的“使用标准的Kafka设置，任何用户或应用程序都可以向任何主题编写任何消息，以及从任何主题读取数据”。所以如果你刚刚安装了卡夫卡，它是敞开的。假设我们想要一个只允许写两个特定主题的生产者，和两个只能读两个主题之一的消费者。这是一个非常简单的例子，只是为了向您展示从完全不安全的Kafka集群到完全安全的Kafka集群有多容易。要实现以上目标，我们唯一需要做的就是应用(<em class="ll">ku bectl apply-f make-my-Kafka-secure . yaml</em>)这个简单的YAML文件:</p><figure class="lq lr ls lt gt jr"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="e2f2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么当我们这么做的时候会发生什么呢？Kubernetes将创建一个新的CiliumNetworkPolicy资源，Cilium将获取该资源，然后监控所有Kafka pods(它将通过标签找到它们),并阻止它们执行除YAML文件的规则部分中指定的操作之外的任何操作:</p><figure class="lq lr ls lt gt jr"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="25e4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们回到整个YAML的档案，并把它分解成碎片。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><figure class="lq lr ls lt gt jr"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="bce7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这很简单，对吧？作为任何Kubernetes资源，我们需要在元数据部分指定apiVersion、描述、种类和至少名称。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><figure class="lq lr ls lt gt jr"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="af9a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，在spec部分，我们需要告诉Cilium如何通过在“endpointSelector”中提供Kafka broker的pod标签来找到它。</p><p id="4f0c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后针对该经纪人应用什么规则。在“ingress”&gt;“from endpoint”中，我们指定了我们的客户端——也就是将连接到我们的Kafka集群的pods(因此可以向/从Kafka生产或消费某些东西)。“toPorts”只是告诉Kafka监听哪个端口，然后在规则中，我们基本上告诉“fromEndpoints”中指定的pod将被允许做什么。以下是可能的规则参数的完整列表:</p><div class="lw lx gp gr ly lz"><a href="http://docs.cilium.io/en/latest/policy/language/#kafka-beta" rel="noopener  ugc nofollow" target="_blank"><div class="ma ab fo"><div class="mb ab mc cl cj md"><h2 class="bd ir gy z fp me fr fs mf fu fw ip bi translated">第7层示例- Cilium 1.7.0文档</h2><div class="mg l"><h3 class="bd b gy z fp me fr fs mf fu fw dk translated">第7层策略建立了关于哪些端点可以相互通信的基本连接规则…</h3></div><div class="mh l"><p class="bd b dl z fp me fr fs mf fu fw dk translated">docs.cilium.io</p></div></div></div></a></div></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><p id="9de0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">…对Kubernetes应用Kafka感知的安全策略就是这么简单。像“允许一个pod只在Kafka主题“topicA”上生产，在主题“topicB”上消费”这样的逻辑很容易用纤毛实现。</p><p id="31f1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您还需要记住，无论是容器中的应用程序代码还是pod配置都没有更改，但是我们通过简单地应用YAML配置，获得了对Kafka设置的身份验证和授权的完全控制。最后但同样重要的是，当消费者(或生产者)试图做一些不被允许的事情时，它会收到一条真实的Kafka错误消息，比如:</p><blockquote class="li lj lk"><p id="3d88" class="kd ke ll kf b kg kh ki kj kk kl km kn lm kp kq kr ln kt ku kv lo kx ky kz la ij bi translated">提取相关id为20的元数据时出现警告错误:{ example-TOPIC = TOPIC _ AUTHORIZATION _ FAILED }(org . Apache . Kafka . clients . network client)</p></blockquote><p id="c57d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里我们来了解一下Cilium是如何工作的——它了解群集内的整个流量，并可以相应地保护它。不仅限于卡夫卡，也理解卡夫卡。对于HTTP流量，您可以用几乎相同的方式使用它(想想像“pod A只能在/info端点上对pod B进行GET调用”这样的规则)。如果您对它的所有功能感兴趣，请在Cilium网站上阅读更多内容，或者等待我的下一篇文章；)</p><div class="lw lx gp gr ly lz"><a href="https://cilium.readthedocs.io/en/stable/" rel="noopener  ugc nofollow" target="_blank"><div class="ma ab fo"><div class="mb ab mc cl cj md"><h2 class="bd ir gy z fp me fr fs mf fu fw ip bi translated">欢迎使用Cilium的文档！-纤毛1.7.0文档</h2><div class="mg l"><h3 class="bd b gy z fp me fr fs mf fu fw dk translated">文档分为以下几个部分:</h3></div><div class="mh l"><p class="bd b dl z fp me fr fs mf fu fw dk translated">纤毛。readthedocs.io</p></div></div></div></a></div></div></div>    
</body>
</html>