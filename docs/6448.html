<html>
<head>
<title>Event-Driven Architectures with Kafka and Python — Revision 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Kafka和Python的事件驱动架构—修订版1</h1>
<blockquote>原文：<a href="https://itnext.io/event-driven-architectures-with-kafka-and-python-revision-1-50276d3ee3dd?source=collection_archive---------1-----------------------#2021-11-19">https://itnext.io/event-driven-architectures-with-kafka-and-python-revision-1-50276d3ee3dd?source=collection_archive---------1-----------------------#2021-11-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1cc8" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">入门所需的一切</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/64f41410854877b3e86f4938c33637e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3JGNvKWr225UkGNHJx6bPQ.png"/></div></div></figure><p id="856c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">欢迎来到我的文章<a class="ae lq" rel="noopener ugc nofollow" target="_blank" href="/event-driven-architectures-with-kafka-and-python-41114de4938b">“使用Kafka和Python的事件驱动架构”</a>的第一次修订版。</p><p id="9f41" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在最初的文章中，发出的事件是一个字符串。虽然这对于许多用例来说已经足够了，但是我的大多数用例都需要发送一个自定义类型的对象。</p><p id="e868" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，我修改了代码和教程，使用JSON的对象序列化和反序列化。</p><p id="8494" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当然，还有其他方法来序列化和去序列化数据。一个非常受欢迎的例子是Avro。</p><p id="6c1e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">虽然条条大路通罗马，但让我们从一条路开始，继续本教程。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h2 id="2d61" class="ly lz it bd ma mb mc dn md me mf dp mg ld mh mi mj lh mk ml mm ll mn mo mp mq bi translated">介绍</h2><p id="bf08" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">事件驱动架构在过去几年里已经成为一种事物，Kafka是工具方面事实上的标准。</p><p id="fc2e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这篇文章提供了一个事件驱动架构的完整例子，用Python编写的两个服务实现，这两个服务通过Kafka进行通信。</p><p id="3dd2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">本教程的主要目标是提供一个工作示例，而不涉及太多的细节，在我看来，这不必要地分散了尽快启动和运行“某些东西”的主要任务的注意力。</p><p id="4468" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们主要有几个构件</p><ul class=""><li id="ec8a" class="mw mx it kw b kx ky la lb ld my lh mz ll na lp nb nc nd ne bi translated">基础设施(卡夫卡，动物园管理员)</li><li id="2091" class="mw mx it kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated">生产者(Python服务)</li><li id="38e7" class="mw mx it kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated">消费者(Python服务)</li></ul><p id="939a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">生产者的唯一任务是定期向卡夫卡发送一个事件。这个事件只是带有一个时间戳。消费者的工作是监听这个事件并打印时间戳。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl nk"><img src="../Images/17ff715e3da17157a8c1b8ea7c1e40bd.png" data-original-src="https://miro.medium.com/v2/format:webp/1*xiYifExQ9NGRVDJz7qBoRA.png"/></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated">卡夫卡</figcaption></figure><p id="06a9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">整个实现产生了下面的项目结构。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl nk"><img src="../Images/15fb7d2c1571fba59f33f36e6f34768e.png" data-original-src="https://miro.medium.com/v2/format:webp/1*TImVY5qDiiqHps02kJ7r8g.png"/></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated">项目结构</figcaption></figure><p id="2713" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae lq" href="https://github.com/twissmueller/event-driven-architectures/tree/main/python-tutorial" rel="noopener ugc nofollow" target="_blank"> <strong class="kw iu">完整的代码可以从这里下载。</strong> </a></p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h2 id="9ac8" class="ly lz it bd ma mb mc dn md me mf dp mg ld mh mi mj lh mk ml mm ll mn mo mp mq bi translated">基础设施</h2><p id="bea7" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">尽管有这些服务，但要让基于事件的架构正常运行，只需要两个组件:Kafka和Zookeeper。</p><p id="5ec6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">查看本教程末尾的参考资料部分，获得两者的链接。</p><p id="a6b6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">尽管卡夫卡是交换事件的“主要”部分，但出于几个原因，动物园管理员是需要的。来自动物园管理员网站:</p><blockquote class="np nq nr"><p id="e7fe" class="ku kv ns kw b kx ky ju kz la lb jx lc nt le lf lg nu li lj lk nv lm ln lo lp im bi translated">ZooKeeper是一个集中式服务，用于维护配置信息、命名、提供分布式同步和提供组服务。</p></blockquote><p id="6cf7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面是docker-compose.yml，用于启动和运行:</p><pre class="kj kk kl km gt nw nx ny nz aw oa bi"><span id="974d" class="ly lz it nx b gy ob oc l od oe">version: '3'<br/><br/>services:<br/><br/>    kafka:<br/>      image: wurstmeister/kafka<br/>      container_name: kafka<br/>      ports:<br/>        - "9092:9092"<br/>      environment:<br/>        - KAFKA_ADVERTISED_HOST_NAME=127.0.0.1<br/>        - KAFKA_ADVERTISED_PORT=9092<br/>        - KAFKA_ZOOKEEPER_CONNECT=zookeeper:2181<br/>      depends_on:<br/>        - zookeeper<br/><br/>    zookeeper:<br/>      image: wurstmeister/zookeeper<br/>      ports:<br/>        - "2181:2181"<br/>      environment:<br/>        - KAFKA_ADVERTISED_HOST_NAME=zookeeper</span></pre><p id="9ba3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当这一切就绪时，只需要实现“业务领域”的两个服务。很简单:发送和接收时间戳。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h2 id="8d93" class="ly lz it bd ma mb mc dn md me mf dp mg ld mh mi mj lh mk ml mm ll mn mo mp mq bi translated">代码设置</h2><p id="a0c2" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">有两个Python项目，所有代码都在它们各自的<code class="fe of og oh nx b">main.py</code>中。</p><p id="2a6d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">它们只有一个在它们的<code class="fe of og oh nx b">requirements.txt</code>中定义的依赖项:</p><pre class="kj kk kl km gt nw nx ny nz aw oa bi"><span id="2329" class="ly lz it nx b gy ob oc l od oe">kafka-python==2.0.2</span></pre><p id="31dc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">需要使用以下命令为每个项目安装该依赖项:</p><pre class="kj kk kl km gt nw nx ny nz aw oa bi"><span id="553a" class="ly lz it nx b gy ob oc l od oe">python3 -m pip install -r requirements.txt</span></pre></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h2 id="500d" class="ly lz it bd ma mb mc dn md me mf dp mg ld mh mi mj lh mk ml mm ll mn mo mp mq bi translated">生产者</h2><p id="e729" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">如上所述，生产者正在“生产”时间戳。</p><pre class="kj kk kl km gt nw nx ny nz aw oa bi"><span id="11a4" class="ly lz it nx b gy ob oc l od oe">class TimestampEvent:<br/>    def __init__(self, timestamp):<br/>        self.timestamp = timestamp</span></pre><p id="f66c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这些时间戳正通过卡夫卡发送给每一个有兴趣接收它们的人。</p><pre class="kj kk kl km gt nw nx ny nz aw oa bi"><span id="0962" class="ly lz it nx b gy ob oc l od oe">import json<br/>from kafka import KafkaProducer<br/>from datetime import datetime<br/>from time import sleep<br/><br/>from TimestampEvent import TimestampEvent<br/><br/>producer = KafkaProducer(bootstrap_servers='localhost:9092',<br/>                         value_serializer=lambda x: json.dumps(x.__dict__).encode('utf-8'))<br/><br/>while True:<br/>    timestampEvent = TimestampEvent(datetime.now().strftime("%H:%M:%S"))<br/>    print("Sending: " + timestampEvent.timestamp)<br/>    producer.send('timestamp', timestampEvent)<br/>    sleep(5)</span></pre><p id="efbc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">创建生成器时，我们提供两条信息:</p><ul class=""><li id="28d8" class="mw mx it kw b kx ky la lb ld my lh mz ll na lp nb nc nd ne bi translated"><code class="fe of og oh nx b">bootstrap_servers</code>:去哪里找卡夫卡。这本来是可以省去的，因为<code class="fe of og oh nx b">localhost:9092</code>是默认值。</li><li id="f97c" class="mw mx it kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated"><code class="fe of og oh nx b">value_serializer</code>:信息将如何被编码。</li></ul><p id="c62a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">消息将被发送到<code class="fe of og oh nx b">timestamp</code>主题。这与消费者只能收听来自该主题的消息有关。</p><p id="285a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这就是制作人的全部。对消费者而言…</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h2 id="0474" class="ly lz it bd ma mb mc dn md me mf dp mg ld mh mi mj lh mk ml mm ll mn mo mp mq bi translated">消费者</h2><p id="b877" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">时间戳的数据结构与生产者的数据结构相同。</p><pre class="kj kk kl km gt nw nx ny nz aw oa bi"><span id="c6bf" class="ly lz it nx b gy ob oc l od oe">class TimestampEvent:<br/>    def __init__(self, timestamp):<br/>        self.timestamp = timestamp</span></pre><p id="1f8f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">是时候接收由生产者发出的时间戳了。</p><pre class="kj kk kl km gt nw nx ny nz aw oa bi"><span id="4ca7" class="ly lz it nx b gy ob oc l od oe">from kafka import KafkaConsumer<br/>import json<br/><br/>from TimestampEvent import TimestampEvent<br/><br/>consumer = KafkaConsumer('timestamp',<br/>                         value_deserializer=lambda x: json.loads(x.decode('utf-8')))<br/><br/>for message in consumer:<br/>    timestampEvent = TimestampEvent(**(message.value))<br/>    print("Received: " + timestampEvent.timestamp)</span></pre><p id="a1fb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这一次，我们没有向消费者提供<code class="fe of og oh nx b">bootstrap_servers</code>。它将默认为<code class="fe of og oh nx b">localhost:9092</code>。</p><p id="abbc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">提供的必要参数有:</p><ul class=""><li id="404c" class="mw mx it kw b kx ky la lb ld my lh mz ll na lp nb nc nd ne bi translated">消费者将会听到的话题:<code class="fe of og oh nx b">timestamp</code></li><li id="6a27" class="mw mx it kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated"><code class="fe of og oh nx b">value_deserializer</code>:消息收到后如何解码。</li></ul><p id="602e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在一切都各就各位了。准备好行动了。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h2 id="8523" class="ly lz it bd ma mb mc dn md me mf dp mg ld mh mi mj lh mk ml mm ll mn mo mp mq bi translated">运行示例代码</h2><p id="68a9" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">是时候运行一切了。请记住以下项目结构:</p><pre class="kj kk kl km gt nw nx ny nz aw oa bi"><span id="29fa" class="ly lz it nx b gy ob oc l od oe">event-driven-architectures<br/>- docker-compose.yml<br/>- python-tutorial<br/>-- producer<br/>--- main.py<br/>-- consumer<br/>--- main.py</span></pre><p id="a799" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在目录<code class="fe of og oh nx b">event-driven-architectures</code>中，卡夫卡和动物园管理员正在通过<code class="fe of og oh nx b">docker-compose</code>启动:</p><pre class="kj kk kl km gt nw nx ny nz aw oa bi"><span id="48ab" class="ly lz it nx b gy ob oc l od oe">docker-compose up -d</span></pre><p id="d16a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">切换到<code class="fe of og oh nx b">producer</code>-目录，使用以下命令启动服务:</p><pre class="kj kk kl km gt nw nx ny nz aw oa bi"><span id="1a84" class="ly lz it nx b gy ob oc l od oe">$ source venv/bin/activate<br/>(venv) $ python3 main.py</span></pre><p id="8f48" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后，在新的终端窗口中，切换到<code class="fe of og oh nx b">consumer</code>目录，以同样的方式启动服务:</p><pre class="kj kk kl km gt nw nx ny nz aw oa bi"><span id="8ea5" class="ly lz it nx b gy ob oc l od oe">$ source venv/bin/activate<br/>(venv) $ python3 main.py</span></pre><p id="a5dc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，你应该能看到类似这样的东西。左边是生产者的日志输出，右边是消费者的日志输出。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl nk"><img src="../Images/08cd3c99d13242e364313854fae7df35.png" data-original-src="https://miro.medium.com/v2/format:webp/1*USXyOY5m6BAUnHCCEP1JOw.png"/></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated">终端输出</figcaption></figure><p id="dd47" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你能走到这一步，恭喜你。实际上，坚持到底应该很容易。如果没有，让我知道如何改善这个教程。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h2 id="9a2f" class="ly lz it bd ma mb mc dn md me mf dp mg ld mh mi mj lh mk ml mm ll mn mo mp mq bi translated">清除</h2><p id="28ed" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">完成后，只需输入</p><pre class="kj kk kl km gt nw nx ny nz aw oa bi"><span id="181b" class="ly lz it nx b gy ob oc l od oe">(venv) $ deactivate</span></pre><p id="9609" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Docker服务也仍在运行。这些也需要停止和清理。</p><p id="0767" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面的命令执行以下操作</p><ul class=""><li id="183c" class="mw mx it kw b kx ky la lb ld my lh mz ll na lp nb nc nd ne bi translated">停止所有正在运行的Docker容器</li><li id="41f7" class="mw mx it kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated">删除停止的码头集装箱</li><li id="ba52" class="mw mx it kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated">移除所有卷</li></ul><pre class="kj kk kl km gt nw nx ny nz aw oa bi"><span id="b389" class="ly lz it nx b gy ob oc l od oe">$ docker-compose stop &amp;&amp; docker-compose rm -f &amp;&amp; docker volume prune -f<br/>Stopping kafka                             ... done<br/>Stopping kafka-python-tutorial_zookeeper_1 ... done<br/>Going to remove kafka, kafka-python-tutorial_zookeeper_1<br/>Removing kafka                             ... done<br/>Removing kafka-python-tutorial_zookeeper_1 ... done<br/>Deleted Volumes:<br/>e4380413983bb36f914621dac4019565cd9ed130c04c5336c898874b648c2c92<br/>120ab4ab7e227bdc5ee155d1cc61f29b1b0f8d7ed2fa9ee29deb05c90e33b8fe<br/>0636bf46ec05cdda15deec280cdef672c68366a7d8d57ff424938069498e4063<br/><br/>Total reclaimed space: 67.13MB</span></pre></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h2 id="9c94" class="ly lz it bd ma mb mc dn md me mf dp mg ld mh mi mj lh mk ml mm ll mn mo mp mq bi translated">结论</h2><p id="52a4" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">关于如何使用Kafka和Python创建事件驱动架构的教程到此结束。</p><p id="d7f3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">完整的项目代码可以从这里下载。T15】</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><ul class=""><li id="a7ba" class="mw mx it kw b kx ky la lb ld my lh mz ll na lp nb nc nd ne bi translated">如果你喜欢这个，请<a class="ae lq" href="https://twissmueller.medium.com/" rel="noopener"> <strong class="kw iu">跟我上媒</strong> </a></li><li id="74fb" class="mw mx it kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated"><a class="ae lq" href="https://www.buymeacoffee.com/twissmueller" rel="noopener ugc nofollow" target="_blank"> <strong class="kw iu">给我买杯咖啡</strong> </a>让我继续前进</li><li id="1f29" class="mw mx it kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated">支持我和其他媒体作者<a class="ae lq" href="https://twissmueller.medium.com/membership" rel="noopener"> <strong class="kw iu">在这里报名</strong> </a></li></ul></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h2 id="7ec1" class="ly lz it bd ma mb mc dn md me mf dp mg ld mh mi mj lh mk ml mm ll mn mo mp mq bi translated">资源</h2><ul class=""><li id="f64d" class="mw mx it kw b kx mr la ms ld oi lh oj ll ok lp nb nc nd ne bi translated"><a class="ae lq" href="https://kafka.apache.org" rel="noopener ugc nofollow" target="_blank">阿帕奇卡夫卡</a></li><li id="1050" class="mw mx it kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated"><a class="ae lq" href="https://zookeeper.apache.org" rel="noopener ugc nofollow" target="_blank">阿帕奇动物园管理员</a></li><li id="0fc5" class="mw mx it kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated"><a class="ae lq" href="https://github.com/dpkp/kafka-python" rel="noopener ugc nofollow" target="_blank">卡夫卡-巨蟒</a></li><li id="fc8d" class="mw mx it kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated"><a class="ae lq" href="https://towardsdatascience.com/kafka-python-explained-in-10-lines-of-code-800e3e07dad1" rel="noopener" target="_blank"> Kafka-Python用10行代码解释</a></li><li id="74a8" class="mw mx it kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated"><a class="ae lq" href="https://medium.com/geekculture/streaming-model-inference-using-flask-and-kafka-3476d9ff5ca5" rel="noopener">使用Flask和Kafka的流式模型推断</a></li></ul><div class="ol om gp gr on oo"><a href="https://twissmueller.medium.com/membership" rel="noopener follow" target="_blank"><div class="op ab fo"><div class="oq ab or cl cj os"><h2 class="bd iu gy z fp ot fr fs ou fu fw is bi translated">通过我的推荐链接加入媒体</h2><div class="ov l"><h3 class="bd b gy z fp ot fr fs ou fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="ow l"><p class="bd b dl z fp ot fr fs ou fu fw dk translated">twissmueller.medium.com</p></div></div><div class="ox l"><div class="oy l oz pa pb ox pc ks oo"/></div></div></a></div></div></div>    
</body>
</html>