<html>
<head>
<title>Serverless Framework: Warming up AWS Lambda to avoid “cold start”</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">无服务器框架:预热AWS Lambda以避免“冷启动”</h1>
<blockquote>原文：<a href="https://itnext.io/serverless-framework-warming-up-aws-lambda-to-avoid-cold-start-2be579475531?source=collection_archive---------0-----------------------#2020-02-18">https://itnext.io/serverless-framework-warming-up-aws-lambda-to-avoid-cold-start-2be579475531?source=collection_archive---------0-----------------------#2020-02-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><h1 id="d478" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">目标</h1><p id="738b" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在我之前的教程中，我们开始学习<a class="ae lj" href="http://serverless.com/" rel="noopener ugc nofollow" target="_blank">无服务器框架</a>。特别是在以下方面:</p><ul class=""><li id="5ed2" class="lk ll iq kn b ko lm ks ln kw lo la lp le lq li lr ls lt lu bi translated">"<a class="ae lj" href="https://medium.com/@micheleriso/serverless-framework-deploy-an-http-endpoint-using-nodejs-lambda-on-aws-30558422de1b" rel="noopener">无服务器框架:在AWS </a>上使用NodeJS，Lambda部署HTTP端点"我们已经学习了如何使用<a class="ae lj" href="http://serverless.com/" rel="noopener ugc nofollow" target="_blank">无服务器框架</a>创建一个在NodeJS中实现的<a class="ae lj" href="https://aws.amazon.com/lambda/" rel="noopener ugc nofollow" target="_blank"> AWS Lambda </a> HTTP端点</li><li id="fe0f" class="lk ll iq kn b ko lv ks lw kw lx la ly le lz li lr ls lt lu bi translated">"<a class="ae lj" rel="noopener ugc nofollow" target="_blank" href="/serverless-framework-deploy-a-rest-api-using-aws-lambda-and-dynamodb-9c396a49e52">无服务器框架:使用AWS Lambda和DynamoDB </a>部署REST API "我们已经学习了如何使用Express、无服务器和<a class="ae lj" href="https://aws.amazon.com/api-gateway/" rel="noopener ugc nofollow" target="_blank"> AWS API网关</a>创建和部署具有两个端点(GET、POST)的<a class="ae lj" href="https://en.wikipedia.org/wiki/Representational_state_transfer" rel="noopener ugc nofollow" target="_blank"> REST API </a>，使用无服务器语法提供<a class="ae lj" href="https://aws.amazon.com/dynamodb/" rel="noopener ugc nofollow" target="_blank"> DynamoDB </a>表，并使用<a class="ae lj" href="https://aws.amazon.com/tools/" rel="noopener ugc nofollow" target="_blank"> AWS SDK </a>连接到DynamoDB</li></ul><p id="264f" class="pw-post-body-paragraph kl km iq kn b ko lm kq kr ks ln ku kv kw ma ky kz la mb lc ld le mc lg lh li ij bi translated">今天我们将学习:</p><ul class=""><li id="916f" class="lk ll iq kn b ko lm ks ln kw lo la lp le lq li lr ls lt lu bi translated">什么是AWS Lambda“冷启动”问题</li><li id="c486" class="lk ll iq kn b ko lv ks lw kw lx la ly le lz li lr ls lt lu bi translated">如何使用无服务器框架提供的插件来避免冷“启动问题”</li></ul><h1 id="1ea6" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">什么是“冷启动”问题</h1><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi md"><img src="../Images/366f6fd4999108af1bb5add1b0aead62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*XYr6j30zlfI-4ebH.jpg"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">典型的冷启动问题</figcaption></figure><p id="7a05" class="pw-post-body-paragraph kl km iq kn b ko lm kq kr ks ln ku kv kw ma ky kz la mb lc ld le mc lg lh li ij bi translated">为了理解“冷启动”问题，我们需要更好地研究AWS Lambda函数如何在幕后工作。AWS Lambda让我们部署和运行一些代码，向我们证明了一个高度可扩展的架构，并允许我们消除供应服务器的负担。</p><p id="90c6" class="pw-post-body-paragraph kl km iq kn b ko lm kq kr ks ln ku kv kw ma ky kz la mb lc ld le mc lg lh li ij bi translated">尽管从开发人员的角度来看这是正确的说法，但是一旦Lambda函数被调用，AWS仍然需要动态地提供服务器。特别是，它需要提供一个容器，将提供一个执行代码的容器</p><p id="250d" class="pw-post-body-paragraph kl km iq kn b ko lm kq kr ks ln ku kv kw ma ky kz la mb lc ld le mc lg lh li ij bi translated">当在容器中运行时，该功能被认为是活动的(又名<strong class="kn ir">热</strong>)。一旦不活动一段时间，容器将被终止，功能被认为是<strong class="kn ir">冷</strong></p><p id="593b" class="pw-post-body-paragraph kl km iq kn b ko lm kq kr ks ln ku kv kw ma ky kz la mb lc ld le mc lg lh li ij bi translated">一旦冷却，该功能的执行时间可能会延迟5-10秒，因此会出现“冷启动”问题。</p><blockquote class="mt"><p id="3c97" class="mu mv iq bd mw mx my mz na nb nc li dk translated">“简而言之，冷启动是指触发功能时经历的延迟”</p></blockquote><h1 id="67a8" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy nd ka kb kc ne ke kf kg nf ki kj kk bi translated">等等，为什么要这么久？</h1><p id="11d3" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">当Lambda函数“第一次”被触发时，AWS必须执行整个请求生命周期。事实上，AWS需要一些时间来下载代码、启动新的容器、部署代码、引导运行时并最终运行它。所有这些操作都会延迟总的执行时间</p><p id="7e9f" class="pw-post-body-paragraph kl km iq kn b ko lm kq kr ks ln ku kv kw ma ky kz la mb lc ld le mc lg lh li ij bi translated">请求生命周期优化的责任由AWS和开发人员对半分担</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi ng"><img src="../Images/d651b35f7ad95985423cc8e98d626e6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*9zc-uCCH9lE2zKF5.png"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated"><a class="ae lj" href="https://youtu.be/oQFORsso2go?t=8m5s" rel="noopener ugc nofollow" target="_blank"> AWS Lambda生命周期</a></figcaption></figure><p id="b52f" class="pw-post-body-paragraph kl km iq kn b ko lm kq kr ks ln ku kv kw ma ky kz la mb lc ld le mc lg lh li ij bi translated">从它的角度来看，AWS总是试图优化请求生命周期的这一方面，减少容器的启动时间</p><p id="443c" class="pw-post-body-paragraph kl km iq kn b ko lm kq kr ks ln ku kv kw ma ky kz la mb lc ld le mc lg lh li ij bi translated">从开发人员的角度来看，lambda的执行时间取决于许多因素:</p><ul class=""><li id="aaa3" class="lk ll iq kn b ko lm ks ln kw lo la lp le lq li lr ls lt lu bi translated">使用的语言/运行时:每种语言都有不同的引导时间。例如，Java可能需要300毫秒，而nodejs需要的时间要少得多</li><li id="5240" class="lk ll iq kn b ko lv ks lw kw lx la ly le lz li lr ls lt lu bi translated">代码大小和代码实现:例如，NodeJS项目中使用的节点模块的数量</li><li id="9b5e" class="lk ll iq kn b ko lv ks lw kw lx la ly le lz li lr ls lt lu bi translated">专用于该功能的内存量(MB)</li></ul><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi nh"><img src="../Images/a667f1a452d111b120442c79a863b729.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*PQGvUK6eOflnN-Ms"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">Java和NodeJS的冷启动问题</figcaption></figure><p id="c6ab" class="pw-post-body-paragraph kl km iq kn b ko lm kq kr ks ln ku kv kw ma ky kz la mb lc ld le mc lg lh li ij bi translated">为了优化它，我们可以干预导致延迟的一些因素(例如优化代码、减少包的大小、增加分配的内存、使用不同的语言……)</p><h1 id="4f19" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">如何减少“冷启动”问题？</h1><p id="cd68" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">虽然代码优化可能有助于减少引导时间，但它不会消除当函数<strong class="kn ir">变冷</strong>时AWS启动新容器所需的时间。</p><p id="c029" class="pw-post-body-paragraph kl km iq kn b ko lm kq kr ks ln ku kv kw ma ky kz la mb lc ld le mc lg lh li ij bi translated">相反，如果该功能已经<strong class="kn ir">预热</strong>，它将立即可用，没有明显的延迟。</p><p id="8162" class="pw-post-body-paragraph kl km iq kn b ko lm kq kr ks ln ku kv kw ma ky kz la mb lc ld le mc lg lh li ij bi translated">因此，我们需要找到一种几乎总是有暖lambda函数的方法。</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/4dd61447224daab1396beae49f61e664.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/0*scW-xfPXgOp4ryIq"/></div></figure><p id="1fd4" class="pw-post-body-paragraph kl km iq kn b ko lm kq kr ks ln ku kv kw ma ky kz la mb lc ld le mc lg lh li ij bi translated">保持lambda函数的一种方法是定期调用它们。</p><p id="6704" class="pw-post-body-paragraph kl km iq kn b ko lm kq kr ks ln ku kv kw ma ky kz la mb lc ld le mc lg lh li ij bi translated">为了实现这一点，我们可以配置一个Cloudwatch事件，该事件定期(例如每5分钟)调用一个新的lambda函数。这个lambda触发对我们需要预热的任何lambda的异步调用。</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/99d105341b18dbff0abec7db5f2d8228.png" data-original-src="https://miro.medium.com/v2/resize:fit:938/format:webp/1*zR0W_bDpxo3gR-g1QFtvVA.png"/></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">冷启动还原模式</figcaption></figure><h1 id="56ae" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">如何使用无服务器框架预热lambda函数</h1><p id="2c7a" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">对我们来说幸运的是，有一个方便的插件，称为预热插件，可以从无服务器框架中获得，它只用一行代码就实现了上述实现</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/87f44d3b26ce2ade75d64b1f2a1b6467.png" data-original-src="https://miro.medium.com/v2/resize:fit:700/format:webp/1*hRuwlypJiZluTYOMyiG9kg.jpeg"/></div></figure><p id="40ab" class="pw-post-body-paragraph kl km iq kn b ko lm kq kr ks ln ku kv kw ma ky kz la mb lc ld le mc lg lh li ij bi translated">让我们开始在代码目录中安装插件</p><pre class="me mf mg mh gt nl nm nn no aw np bi"><span id="2815" class="nq jo iq nm b gy nr ns l nt nu">$ <em class="nv">npm install serverless-plugin-warmup --save-dev</em></span></pre><p id="277d" class="pw-post-body-paragraph kl km iq kn b ko lm kq kr ks ln ku kv kw ma ky kz la mb lc ld le mc lg lh li ij bi translated">并在serverless.yml文件的plugins部分添加插件</p><pre class="me mf mg mh gt nl nm nn no aw np bi"><span id="2ba6" class="nq jo iq nm b gy nr ns l nt nu">plugins:</span><span id="75bf" class="nq jo iq nm b gy nw ns l nt nu">- serverless-plugin-warmup</span></pre><p id="1851" class="pw-post-body-paragraph kl km iq kn b ko lm kq kr ks ln ku kv kw ma ky kz la mb lc ld le mc lg lh li ij bi translated">之后，我们需要在任何需要预热的函数中启用插件，使用“warmup: true”参数</p><pre class="me mf mg mh gt nl nm nn no aw np bi"><span id="546f" class="nq jo iq nm b gy nr ns l nt nu">functions:</span><span id="b093" class="nq jo iq nm b gy nw ns l nt nu"> app:</span><span id="9a90" class="nq jo iq nm b gy nw ns l nt nu">  <strong class="nm ir">warmup: true</strong></span><span id="5931" class="nq jo iq nm b gy nw ns l nt nu">  handler: app.server</span><span id="c3cf" class="nq jo iq nm b gy nw ns l nt nu">  events:</span><span id="0b90" class="nq jo iq nm b gy nw ns l nt nu">   - http:</span><span id="bdc4" class="nq jo iq nm b gy nw ns l nt nu">      path: /</span><span id="57a8" class="nq jo iq nm b gy nw ns l nt nu">      method: ANY</span><span id="af64" class="nq jo iq nm b gy nw ns l nt nu">      cors: true</span><span id="38e8" class="nq jo iq nm b gy nw ns l nt nu">   - http:</span><span id="ce9d" class="nq jo iq nm b gy nw ns l nt nu">      path: /{proxy+}</span><span id="bfdd" class="nq jo iq nm b gy nw ns l nt nu">      method: ANY</span><span id="0ccf" class="nq jo iq nm b gy nw ns l nt nu">      cors: true</span></pre><h1 id="aaff" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">部署！</h1><p id="1fa6" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">让我们用已经众所周知的命令<code class="fe nx ny nz nm b">sls deploy</code>再次部署它。这一次，Serverless部署了一个名为我们的lambda +前缀“warmup-plugin”的函数</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi oa"><img src="../Images/e0463644c7ef13bceeb76865b57fdb84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-_hpExo5et2dA4qsYGQ5Og.png"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">AWS Lambda控制台</figcaption></figure><p id="bdad" class="pw-post-body-paragraph kl km iq kn b ko lm kq kr ks ln ku kv kw ma ky kz la mb lc ld le mc lg lh li ij bi translated">使用AWS控制台，我们可以看到预热插件配置了一个Cloudwatch事件，每5分钟运行一次，触发这个新的lambda函数</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi ob"><img src="../Images/c6eff76003b8d2b3dcfcaf28d5378d15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cXhBZwKivaulVCz07hClTg.png"/></div></div></figure><h1 id="deec" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">供应的并发</h1><p id="b640" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在2019年12月的AWS re:Invent上，AWS引入了“供应并发”的概念，允许开发人员消除冷启动问题，指定应该始终保持温暖的Lambda工作器的数量。</p><p id="1e16" class="pw-post-body-paragraph kl km iq kn b ko lm kq kr ks ln ku kv kw ma ky kz la mb lc ld le mc lg lh li ij bi translated">AWS控制台和无服务器框架的配置都很简单。</p><p id="105e" class="pw-post-body-paragraph kl km iq kn b ko lm kq kr ks ln ku kv kw ma ky kz la mb lc ld le mc lg lh li ij bi translated">在第一种情况下，开发人员应该打开Lambda服务页面，一直向下滚动，并设置所需的供应并发数</p><p id="eb51" class="pw-post-body-paragraph kl km iq kn b ko lm kq kr ks ln ku kv kw ma ky kz la mb lc ld le mc lg lh li ij bi translated">在第二种情况下，我们需要将“provisionedConcurrency: 5”参数添加到serverless.yml文件中的函数配置中，其中5是并发warm实例的期望数量</p><pre class="me mf mg mh gt nl nm nn no aw np bi"><span id="b857" class="nq jo iq nm b gy nr ns l nt nu">app:</span><span id="a651" class="nq jo iq nm b gy nw ns l nt nu"> handler: app.server</span><span id="4ddc" class="nq jo iq nm b gy nw ns l nt nu"><strong class="nm ir"> provisionedConcurrency: 5</strong></span><span id="8022" class="nq jo iq nm b gy nw ns l nt nu">...</span></pre><h1 id="837b" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">结论</h1><p id="1d1e" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在本教程中，我们学习了</p><ul class=""><li id="bb73" class="lk ll iq kn b ko lm ks ln kw lo la lp le lq li lr ls lt lu bi translated">AWS Lambda功能的“冷启动”问题是什么</li><li id="3484" class="lk ll iq kn b ko lv ks lw kw lx la ly le lz li lr ls lt lu bi translated">我们如何优化函数引导时间</li><li id="f233" class="lk ll iq kn b ko lv ks lw kw lx la ly le lz li lr ls lt lu bi translated">我们如何使用AWS预热功能</li><li id="3d82" class="lk ll iq kn b ko lv ks lw kw lx la ly le lz li lr ls lt lu bi translated">我们如何使用无服务器框架的预热插件来简化上述要点</li></ul><p id="9b2e" class="pw-post-body-paragraph kl km iq kn b ko lm kq kr ks ln ku kv kw ma ky kz la mb lc ld le mc lg lh li ij bi translated">敬请关注其他关于无服务器框架的教程！</p><p id="f55f" class="pw-post-body-paragraph kl km iq kn b ko lm kq kr ks ln ku kv kw ma ky kz la mb lc ld le mc lg lh li ij bi translated">此处链接到<a class="ae lj" href="https://bitbucket.org/mriso/serverless-aws-nodejs-dynamodb-warmup/src/master/" rel="noopener ugc nofollow" target="_blank">位存储桶回购</a></p></div></div>    
</body>
</html>