<html>
<head>
<title>How Redux Connect compares to the new Redux Hooks.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Redux Connect与新的Redux挂钩的比较。</h1>
<blockquote>原文：<a href="https://itnext.io/how-existing-redux-patterns-compare-to-the-new-redux-hooks-b56134c650d2?source=collection_archive---------1-----------------------#2019-07-31">https://itnext.io/how-existing-redux-patterns-compare-to-the-new-redux-hooks-b56134c650d2?source=collection_archive---------1-----------------------#2019-07-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/fd081a0d06774f9a2aaf3d301105afe5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4khgguJQPxUwKSZH3URgQQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">Redux钩子！</figcaption></figure><p id="fc8d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">因此，自从React发布了他们的hooks API以来，这是一个热门的重新加载分钟，我认为公平地说，社区的大多数人都在玩新的API。如果你还没有看过，我绝对推荐它，因为它们很棒。</p><p id="0d4d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">随着钩子风靡一时，许多流行的库也加入进来，并发布了它们自己的钩子来替代它们当前的方法。一些值得注意的例子包括mobX、react-spring、formik、final-form等等。</p><p id="90a9" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">Redux可能是React最流行的状态管理库，也不例外。最近他们发布了新的7.1.0版本的Hook API，作为<code class="fe la lb lc ld b">connect()</code>高阶组件(HOC)的替代，我很想尝试一下，看看有什么优缺点！</p><p id="9b77" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">基本上，这些新的API允许您订阅Redux存储和调度操作，而不必将组件包装在<code class="fe la lb lc ld b">connect()</code>中</p><p id="77c2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">这些新挂钩是:</strong></p><ol class=""><li id="ffa3" class="le lf iq ke b kf kg kj kk kn lg kr lh kv li kz lj lk ll lm bi translated">使用选择器</li><li id="a74b" class="le lf iq ke b kf ln kj lo kn lp kr lq kv lr kz lj lk ll lm bi translated">使用显示器</li><li id="8037" class="le lf iq ke b kf ln kj lo kn lp kr lq kv lr kz lj lk ll lm bi translated">使用商店</li></ol><p id="0554" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">在本文中，我们将构建:</strong></p><ul class=""><li id="fc4f" class="le lf iq ke b kf kg kj kk kn lg kr lh kv li kz ls lk ll lm bi translated">一辆购物车(因为这是前所未有的……)同时使用了传统的<code class="fe la lb lc ld b">connect</code> HOC和新的Redux挂钩。</li><li id="e324" class="le lf iq ke b kf ln kj lo kn lp kr lq kv lr kz ls lk ll lm bi translated">带有Redux挂钩的购物车和重新选择库的概要。</li></ul><h2 id="628c" class="lt lu iq bd lv lw lx dn ly lz ma dp mb kn mc md me kr mf mg mh kv mi mj mk ml bi translated"><strong class="ak">这篇文章的目的是向你展示:</strong></h2><ol class=""><li id="c687" class="le lf iq ke b kf mm kj mn kn mo kr mp kv mq kz lj lk ll lm bi translated">React组件连接到redux存储的传统方式。</li><li id="4206" class="le lf iq ke b kf ln kj lo kn lp kr lq kv lr kz lj lk ll lm bi translated">我们如何使用新的redux挂钩连接到Redux商店。</li><li id="5134" class="le lf iq ke b kf ln kj lo kn lp kr lq kv lr kz lj lk ll lm bi translated">使用这些钩子的好处和缺点。</li></ol><h2 id="8479" class="lt lu iq bd lv lw lx dn ly lz ma dp mb kn mc md me kr mf mg mh kv mi mj mk ml bi translated">可以在此处找到该存储库</h2><p id="fdb4" class="pw-post-body-paragraph kc kd iq ke b kf mm kh ki kj mn kl km kn mr kp kq kr ms kt ku kv mt kx ky kz ij bi translated"><a class="ae mu" href="https://github.com/terencejeong/redux-hooks-api-play" rel="noopener ugc nofollow" target="_blank">https://github.com/terencejeong/redux-hooks-api-play</a></p><p id="a526" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">请注意，本文并不是要说明哪种方法更好，而是要强调两者之间的区别，并帮助您更好地理解这些新钩子将如何工作。</p><h1 id="da59" class="mv lu iq bd lv mw mx my ly mz na nb mb nc nd ne me nf ng nh mh ni nj nk mk nl bi translated">项目设置</h1><p id="cf84" class="pw-post-body-paragraph kc kd iq ke b kf mm kh ki kj mn kl km kn mr kp kq kr ms kt ku kv mt kx ky kz ij bi translated">我使用create-react-app设置了项目，并启用了typescript标志。如果你不想在typescript中编码，你可以忽略这个标志。</p><p id="99dd" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe la lb lc ld b">yarn create react-app my-store --typescript</code></p><p id="86f7" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">然后，我添加了以下库，因为它们是我们将重点关注的关键库。</p><p id="0714" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe la lb lc ld b">yarn i redux reselect</code></p><h1 id="3166" class="mv lu iq bd lv mw mx my ly mz na nb mb nc nd ne me nf ng nh mh ni nj nk mk nl bi translated">文件结构</h1><p id="5293" class="pw-post-body-paragraph kc kd iq ke b kf mm kh ki kj mn kl km kn mr kp kq kr ms kt ku kv mt kx ky kz ij bi translated">文件结构如下所示</p><figure class="nn no np nq gt jr gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/609f8ece7afc8b3d0542fbae6c75921f.png" data-original-src="https://miro.medium.com/v2/resize:fit:704/format:webp/1*NxONvk7Rw8OlroiWcUtOSw.png"/></div></figure><h1 id="bc71" class="mv lu iq bd lv mw mx my ly mz na nb mb nc nd ne me nf ng nh mh ni nj nk mk nl bi translated">设置Redux商店和产品减少器</h1><p id="b6f8" class="pw-post-body-paragraph kc kd iq ke b kf mm kh ki kj mn kl km kn mr kp kq kr ms kt ku kv mt kx ky kz ij bi translated">现在让我们继续创建我们的Redux存储和产品Redux。我假设读者会理解Redux是如何工作的，所以我就不赘述了。</p><blockquote class="nr ns nt"><p id="b3f0" class="kc kd nu ke b kf kg kh ki kj kk kl km nv ko kp kq nw ks kt ku nx kw kx ky kz ij bi translated"><strong class="ke ir"> <em class="iq">请不要纠结于这里的细节，我只是想让你知道我们的商店会是什么样子，以及我们的组件正在消耗的数据。</em> </strong></p></blockquote><p id="f8c3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在<code class="fe la lb lc ld b">store</code>文件夹中，我们将添加一个<code class="fe la lb lc ld b">index.ts</code>文件。</p><figure class="nn no np nq gt jr"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="a238" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在<code class="fe la lb lc ld b">reducer</code>文件夹中，我们将添加4个文件。</p><ol class=""><li id="10ad" class="le lf iq ke b kf kg kj kk kn lg kr lh kv li kz lj lk ll lm bi translated"><code class="fe la lb lc ld b">index.ts</code></li><li id="9b2a" class="le lf iq ke b kf ln kj lo kn lp kr lq kv lr kz lj lk ll lm bi translated"><code class="fe la lb lc ld b">products.ts</code></li><li id="7e26" class="le lf iq ke b kf ln kj lo kn lp kr lq kv lr kz lj lk ll lm bi translated"><code class="fe la lb lc ld b">productsOld.ts</code></li><li id="0aff" class="le lf iq ke b kf ln kj lo kn lp kr lq kv lr kz lj lk ll lm bi translated"><code class="fe la lb lc ld b">storeHours.ts</code></li></ol><p id="776a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe la lb lc ld b">products.ts</code>文件将是我们的钩子产品列表组件的缩减器，而<code class="fe la lb lc ld b">productsOld.ts</code>文件将是我们的<code class="fe la lb lc ld b">connect</code>特设产品列表组件的缩减器。</p><figure class="nn no np nq gt jr"><div class="bz fp l di"><div class="ny nz l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">index.ts</figcaption></figure><figure class="nn no np nq gt jr"><div class="bz fp l di"><div class="ny nz l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">产品. ts</figcaption></figure><figure class="nn no np nq gt jr"><div class="bz fp l di"><div class="ny nz l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">productsOld.ts</figcaption></figure><figure class="nn no np nq gt jr"><div class="bz fp l di"><div class="ny nz l"/></div></figure><h1 id="2060" class="mv lu iq bd lv mw mx my ly mz na nb mb nc nd ne me nf ng nh mh ni nj nk mk nl bi translated">给我看看Redux钩子！！</h1><p id="523d" class="pw-post-body-paragraph kc kd iq ke b kf mm kh ki kj mn kl km kn mr kp kq kr ms kt ku kv mt kx ky kz ij bi translated">快到了！我们首先需要创建我们的<code class="fe la lb lc ld b">ParentContainer.tsx</code>文件，它将呈现<code class="fe la lb lc ld b">ProductListHooks.tsx</code>文件和<code class="fe la lb lc ld b">ProductListContainer.tsx</code>文件。</p><p id="7b3b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们的<code class="fe la lb lc ld b">ParentContainer.tsx</code>文件将只是简单地呈现ProductList钩子和ProductListContainer以及打开和关闭状态。</p><p id="8890" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">该网站目前看起来像这样。</p><figure class="nn no np nq gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oa"><img src="../Images/18e2db336befb110fde0a9eab66e7099.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*08BJgeBxFV6IuwBc89LCaQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">一些真正坚实的UX/用户界面工作在这里</figcaption></figure><p id="9ab7" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在<code class="fe la lb lc ld b">ProductListContainer.tsx</code>将使用<code class="fe la lb lc ld b">connect</code> HOC连接到Redux商店。从下面的片段中可以看出，这里没有什么复杂的事情。我们只是从redux存储中给出组件状态，并访问dispatch。该组件将从商店中获取产品，映射它们并将其传递给<code class="fe la lb lc ld b">ProductItem.tsx</code>组件，后者将呈现数据。</p><figure class="nn no np nq gt jr"><div class="bz fp l di"><div class="ny nz l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">ProductListContainer.tsx</figcaption></figure><h1 id="caa2" class="mv lu iq bd lv mw mx my ly mz na nb mb nc nd ne me nf ng nh mh ni nj nk mk nl bi translated">Redux钩子！！</h1><p id="d972" class="pw-post-body-paragraph kc kd iq ke b kf mm kh ki kj mn kl km kn mr kp kq kr ms kt ku kv mt kx ky kz ij bi translated">现在让我们展示一下如果使用新的Redux挂钩，上面的组件会是什么样子。</p><figure class="nn no np nq gt jr"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="7e8b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">哦，那有点不同，不是吗！在上面的文件中，我们可以看到我们有两个新的钩子叫做<code class="fe la lb lc ld b">useSelector</code>和<code class="fe la lb lc ld b">useDispatch</code>。</p><p id="b5fa" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">但是在我谈论它们之前，你可以看到这个组件和之前的<code class="fe la lb lc ld b">ProductListContainer.tsx</code>组件非常相似。它只是从商店里拿走产品，对它们进行映射，并将其与<code class="fe la lb lc ld b">dispatch</code>一起传递给<code class="fe la lb lc ld b">ProductItem.tsx</code>。</p><p id="5e18" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在有趣的事情，让我们打破两个新的钩子，好吗？</p><h1 id="29e5" class="mv lu iq bd lv mw mx my ly mz na nb mb nc nd ne me nf ng nh mh ni nj nk mk nl bi translated">使用选择器</h1><p id="b8ce" class="pw-post-body-paragraph kc kd iq ke b kf mm kh ki kj mn kl km kn mr kp kq kr ms kt ku kv mt kx ky kz ij bi translated">这个钩子允许我们使用选择器函数从Redux存储状态中提取数据。选择器函数将使用整个Redux存储状态作为其唯一的参数来调用，并且必须返回组件所使用的状态的相关部分。</p><p id="99bf" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在上面的代码片段中，我们可以看到它从商店返回产品数组。</p><p id="74d0" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在，尽管它做的工作与mapStateToProps相同，但我们必须考虑一些关键的区别。</p><ol class=""><li id="f825" class="le lf iq ke b kf kg kj kk kn lg kr lh kv li kz lj lk ll lm bi translated">选择器可以返回<strong class="ke ir"> <em class="nu">任何值</em> </strong>作为结果，而不仅仅是一个对象。</li><li id="79a5" class="le lf iq ke b kf ln kj lo kn lp kr lq kv lr kz lj lk ll lm bi translated">当一个动作被分派时，<code class="fe la lb lc ld b">useSelector</code>钩子将做一个引用检查，并比较先前的值和当前的结果值。如果它们不同，组件将被强制重新渲染。如果它们相同，组件将不会重新呈现。</li></ol><p id="b0a8" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在，我真的想讨论第二点，因为这是<code class="fe la lb lc ld b">connect</code>和<code class="fe la lb lc ld b">useSelector</code>最大的区别。在Redux中，<code class="fe la lb lc ld b">connect</code>对mapState调用的结果使用浅层相等检查来确定是否需要重新渲染。然而，<code class="fe la lb lc ld b">useSelector</code>使用了一个严格的<code class="fe la lb lc ld b">===</code>引用，这对于我们应该如何实现<code class="fe la lb lc ld b">useSelector</code>有几个影响。</p><h2 id="3b1c" class="lt lu iq bd lv lw lx dn ly lz ma dp mb kn mc md me kr mf mg mh kv mi mj mk ml bi translated"><strong class="ak">但这实际上意味着什么呢？！</strong></h2><p id="dcf2" class="pw-post-body-paragraph kc kd iq ke b kf mm kh ki kj mn kl km kn mr kp kq kr ms kt ku kv mt kx ky kz ij bi translated">让我们仔细看看负责渲染<code class="fe la lb lc ld b">ProductListHooks</code>和<code class="fe la lb lc ld b">ProductListContainer</code>的<code class="fe la lb lc ld b">ParentContainer.tsx</code>文件。您可以看到<code class="fe la lb lc ld b">ParentContainer</code>还通过向商店发送一个动作来显示商店是开门还是关门。</p><figure class="nn no np nq gt jr"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="2291" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">使用devtools中的awesome React Profiler，我们可以看到如果我们点击按钮很多次，会重新呈现什么。</p><figure class="nn no np nq gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ob"><img src="../Images/71f3f1df8a9ed4e899e86bc0f8c14b0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vN7S838RbJ7vSkYVNQlQaw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">ProductListHooks的渲染总数</figcaption></figure><figure class="nn no np nq gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oc"><img src="../Images/df8241c511f614ff6e63b1c005de2f68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FcVmNLpOTpP2S_3FQu3TfQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">ProductListContainer的渲染总数</figcaption></figure><p id="1abb" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如您所见，这是一个巨大的差异！该按钮被点击10次，ProductListHooks总共重新渲染了<strong class="ke ir"> 11次</strong>，而使用<code class="fe la lb lc ld b">connect</code>的ProductListContainer只渲染了<strong class="ke ir">一次！</strong></p><p id="197c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">与<code class="fe la lb lc ld b">connect</code>不同的是，<code class="fe la lb lc ld b">useSelector()</code>钩子不会因为其父组件的重新渲染而阻止组件的重新渲染，即使组件的属性没有改变。</p><p id="0679" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">使用<code class="fe la lb lc ld b">mapState</code>，所有单个字段在一个组合对象中返回。返回的对象是否是新的引用并不重要- <code class="fe la lb lc ld b">connect()</code>只是比较了单个字段。使用<code class="fe la lb lc ld b">useSelector()</code>，每次返回一个新的对象，默认情况下<em class="nu">总是</em>强制重新渲染。</p><h2 id="972f" class="lt lu iq bd lv lw lx dn ly lz ma dp mb kn mc md me kr mf mg mh kv mi mj mk ml bi translated">我们如何解决这个问题？</h2><p id="29e6" class="pw-post-body-paragraph kc kd iq ke b kf mm kh ki kj mn kl km kn mr kp kq kr ms kt ku kv mt kx ky kz ij bi translated">嗯，这种情况下最简单的解决方案是将ProductListHooks组件包装在<code class="fe la lb lc ld b">React.memo</code>中。如果道具没有改变，这允许功能组件在渲染时退出。这很像一个<code class="fe la lb lc ld b">PureComponent</code>或<code class="fe la lb lc ld b">shouldComponentUpdate</code>。</p><p id="3265" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">所以让我们看看如果我们使用<code class="fe la lb lc ld b">React.memo</code>，我们的<code class="fe la lb lc ld b">ProductListHooks.tsx</code>组件会是什么样子。</p><figure class="nn no np nq gt jr"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="9e5b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">那很简单！而现在看看结果，那只是<strong class="ke ir">一人总</strong>的渲染。</p><figure class="nn no np nq gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi od"><img src="../Images/a652cd9aaad17633d04e62a106d8dce7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SIaAGGtj-tIheqhZYQJJtg.png"/></div></div></figure><p id="5dd6" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">另一种方式是<code class="fe la lb lc ld b">useSelector</code>也接受第二个参数，作为一个等式函数。如果等式函数返回false，组件将被强制重新呈现，否则组件将不会重新呈现。我仍在努力解决这个问题，一旦我觉得有了更具体的例子，我会重新调整这个帖子。</p><h1 id="a1f9" class="mv lu iq bd lv mw mx my ly mz na nb mb nc nd ne me nf ng nh mh ni nj nk mk nl bi translated">使用显示器</h1><p id="22e2" class="pw-post-body-paragraph kc kd iq ke b kf mm kh ki kj mn kl km kn mr kp kq kr ms kt ku kv mt kx ky kz ij bi translated">现在这个钩子简单地从Redux store返回一个对<strong class="ke ir"> dispatch </strong>函数的<em class="nu">引用</em>,用于根据需要分派动作。现在，这里有一些需要注意的非常重要的问题。</p><p id="a5f9" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果您查看<code class="fe la lb lc ld b">ProductListHooks.tsx</code>组件，您可以看到我们正在将<code class="fe la lb lc ld b">dispatch</code>传递给子<code class="fe la lb lc ld b">ProductItem</code>组件。让我们仔细看看<code class="fe la lb lc ld b">ProductItem</code>组件。</p><figure class="nn no np nq gt jr"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="1ca4" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在让我们看看，如果我们只为其中一件商品点击“购买一件”按钮，React Profiler会发生什么。</p><figure class="nn no np nq gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oe"><img src="../Images/0ef15d776ae4b34ac1ec7bfc0b6ba318.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NkTHadXsge8GIlbLiz4sOA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">为ProductItem呈现</figcaption></figure><p id="3125" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">您可以看到，该组件不仅重新呈现了所选项目的ProductItem组件，还重新呈现了所有ProductItems组件，即使该项目未被选中。</p><h2 id="4a78" class="lt lu iq bd lv lw lx dn ly lz ma dp mb kn mc md me kr mf mg mh kv mi mj mk ml bi translated">那我们该怎么办？我们不想重新渲染所有的东西:(</h2><p id="0bb5" class="pw-post-body-paragraph kc kd iq ke b kf mm kh ki kj mn kl km kn mr kp kq kr ms kt ku kv mt kx ky kz ij bi translated">不幸的是，每当您想要触发一个动作作为对用户事件的响应时，您就必须创建一个匿名函数，例如:<code class="fe la lb lc ld b">() =&gt; dispatch({type: x, payload: y})</code>。为什么这很重要？因为由于匿名函数的性质，每次重新呈现时，都会创建一个对该函数的新引用。</p><p id="e964" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">当使用<code class="fe la lb lc ld b">dispatch</code>将回调传递给子组件时，建议使用<code class="fe la lb lc ld b">useCallback</code>将其记忆，否则子组件将永远无法受益于<code class="fe la lb lc ld b">shouldComponentUpdate</code>、<code class="fe la lb lc ld b">memo</code>、<code class="fe la lb lc ld b">PureComponent</code>等渲染退出技术。</p><p id="e4d4" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">为了实现这一点，您必须使函数具有相同的引用，这在hooks世界中转化为将整个匿名函数包装在一个<code class="fe la lb lc ld b">useCallback()</code>中。</p><p id="4d82" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们的ProductListHooks容器现在看起来类似于下面的代码片段。您可以看到我们已经将调度功能包装在一个<code class="fe la lb lc ld b">useCallback </code>钩子中。</p><p id="7744" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe la lb lc ld b">useCallback</code>钩子将返回回调的记忆化版本，只有当其中一个依赖关系改变时，这个版本才会改变，在这种情况下是调度。</p><figure class="nn no np nq gt jr"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="9691" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们现在可以利用渲染救助技术<code class="fe la lb lc ld b">memo</code>。查看我们现在得到的ProductItem组件</p><figure class="nn no np nq gt jr"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="2cbb" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在让我们看看React分析器向我们展示了什么。</p><figure class="nn no np nq gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ob"><img src="../Images/238fe963a93532847c943c7806c8c299.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k0S9H-n_qndFu1z9-3Ou1A.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">好多了！</figcaption></figure><p id="09a6" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">是不是很可爱，是不是很精彩！MacBook Pro是唯一被重新渲染的产品，因为它是唯一被选中的产品。</p><p id="7e0e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">最后，我更希望有一个自定义的useDispatch挂钩，可以在整个应用程序中轻松重用。在<code class="fe la lb lc ld b">hooks</code>文件夹中，我将创建一个名为<code class="fe la lb lc ld b">useDispatchToStore</code>的自定义钩子。</p><figure class="nn no np nq gt jr"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="a0c7" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">useDispatchToStore只是一个curried函数，它将接受一个动作类型并返回一个函数，该函数将接受有效负载并将其分派给商店。</p><p id="3b43" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们的<code class="fe la lb lc ld b">ProductListHooks</code>组件现在看起来像下面的代码片段。如你所见，唯一的区别是在useCallback中，我们将依赖项作为一个动作类型，而不是调度函数。</p><figure class="nn no np nq gt jr"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="99ae" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">总之，使用<code class="fe la lb lc ld b">useDispatch</code>钩子你应该遵循以下规则</p><ol class=""><li id="5611" class="le lf iq ke b kf kg kj kk kn lg kr lh kv li kz lj lk ll lm bi translated">如果将分派传递给子进程，请将其包装在useCallback中。</li><li id="8539" class="le lf iq ke b kf ln kj lo kn lp kr lq kv lr kz lj lk ll lm bi translated">记忆子组件。</li></ol><h1 id="1875" class="mv lu iq bd lv mw mx my ly mz na nb mb nc nd ne me nf ng nh mh ni nj nk mk nl bi translated">使用Redux挂钩的利弊</h1><h2 id="8574" class="lt lu iq bd lv lw lx dn ly lz ma dp mb kn mc md me kr mf mg mh kv mi mj mk ml bi translated"><strong class="ak">专业版</strong></h2><ul class=""><li id="0147" class="le lf iq ke b kf mm kj mn kn mo kr mp kv mq kz ls lk ll lm bi translated">我们的组件层次结构中不再有如此少的节点。</li><li id="6b75" class="le lf iq ke b kf ln kj lo kn lp kr lq kv lr kz ls lk ll lm bi translated">可以将我们的选择器抽象为更健壮和可重用的代码。</li><li id="9746" class="le lf iq ke b kf ln kj lo kn lp kr lq kv lr kz ls lk ll lm bi translated">某种意义上更具可读性。</li></ul><p id="5268" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">骗局</strong></p><ul class=""><li id="3d05" class="le lf iq ke b kf kg kj kk kn lg kr lh kv li kz ls lk ll lm bi translated">你失去了很多<code class="fe la lb lc ld b">connect()</code>提供的<strong class="ke ir">自动</strong>参照缓存。</li><li id="4e3e" class="le lf iq ke b kf ln kj lo kn lp kr lq kv lr kz ls lk ll lm bi translated">您无法访问<code class="fe la lb lc ld b">mapStateToProps</code>中的<code class="fe la lb lc ld b">ownProps</code>。要获得ownProps对象，您需要编写自己的逻辑/钩子。</li></ul><h1 id="79a0" class="mv lu iq bd lv mw mx my ly mz na nb mb nc nd ne me nf ng nh mh ni nj nk mk nl bi translated">那么我应该开始使用Redux挂钩吗？</h1><p id="c219" class="pw-post-body-paragraph kc kd iq ke b kf mm kh ki kj mn kl km kn mr kp kq kr ms kt ku kv mt kx ky kz ij bi translated">嗯…那得看情况。当您远离<code class="fe la lb lc ld b">connect</code>时，您会失去它提供的许多性能优势。这意味着在考虑重新渲染和传递来自智能和非智能组件的数据时，您必须更加谨慎。目前我不认为我会离开<code class="fe la lb lc ld b">connect</code>，但和它一起玩肯定很有趣。</p><p id="b19d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我的建议是，当你开始使用这些钩子时，总是问自己:</p><ul class=""><li id="20eb" class="le lf iq ke b kf kg kj kk kn lg kr lh kv li kz ls lk ll lm bi translated">这比使用当前的方法更好吗？</li><li id="a9ed" class="le lf iq ke b kf ln kj lo kn lp kr lq kv lr kz ls lk ll lm bi translated">使用这些挂钩，我失去/得到了什么</li></ul><p id="94f3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">永远记住，这些钩子只是当前方法的一种替代。你可以用HOC或者渲染道具写的任何东西也可以用钩子写，反之亦然。</p><h1 id="7d03" class="mv lu iq bd lv mw mx my ly mz na nb mb nc nd ne me nf ng nh mh ni nj nk mk nl bi translated">感谢阅读！如果你喜欢这篇文章，请随意点击几下那个按钮(👏👏👏👏)帮别人找。</h1><h2 id="6705" class="lt lu iq bd lv lw lx dn ly lz ma dp mb kn mc md me kr mf mg mh kv mi mj mk ml bi translated">可以在此处找到该存储库</h2><p id="b00a" class="pw-post-body-paragraph kc kd iq ke b kf mm kh ki kj mn kl km kn mr kp kq kr ms kt ku kv mt kx ky kz ij bi translated"><a class="ae mu" href="https://github.com/terencejeong/redux-hooks-api-play" rel="noopener ugc nofollow" target="_blank">https://github.com/terencejeong/redux-hooks-api-play</a></p><h2 id="129d" class="lt lu iq bd lv lw lx dn ly lz ma dp mb kn mc md me kr mf mg mh kv mi mj mk ml bi translated">如果有足够的需求，我将使用这些redux挂钩和类似reselect的内存化库来编写第2部分:)</h2><h2 id="0b39" class="lt lu iq bd lv lw lx dn ly lz ma dp mb kn mc md me kr mf mg mh kv mi mj mk ml bi translated">另外，如果你喜欢你所读的，可以随意看看我的另一篇关于如何从重新组合移植到反应钩子的文章<a class="ae mu" href="https://medium.com/stationfive/how-to-migrate-from-recompose-to-react-hooks-89b2981c03d" rel="noopener">这里</a></h2></div></div>    
</body>
</html>