<html>
<head>
<title>Adding OpenTracing support to APIcast API Gateway</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">向APIcast API网关添加OpenTracing支持</h1>
<blockquote>原文：<a href="https://itnext.io/adding-opentracing-support-to-apicast-api-gateway-a8e0a38347d2?source=collection_archive---------6-----------------------#2018-08-07">https://itnext.io/adding-opentracing-support-to-apicast-api-gateway-a8e0a38347d2?source=collection_archive---------6-----------------------#2018-08-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="3d40" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这篇博文中，我将解释最近为API网关APIcast添加OpenTracing和Jaeger支持的经验和成果。这将使APIcast易于集成到使用OpenTracing的环境中，并允许用户获得对其系统的更多可见性。</p><p id="0916" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以前我们只有这样的日志:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/5869b6cb9a478cb95963f8293b7fb6a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BtKOzdBE4MAkL1QXAGeUiA.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">APIcast原始日志</figcaption></figure><p id="1781" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，您可以通过APIcast查看您的API请求:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi lb"><img src="../Images/591f8e2bd880e1aa6d4546907815d2a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*LEFxqU86n9DeACXz"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">Jaeger用户界面显示来自不同服务的多条痕迹</figcaption></figure><p id="c92d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这使得调试问题变得容易，例如，大的延迟峰值，以及理解API请求的整个周期和所有相关的服务。</p><h1 id="f524" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">APIcast和可观测性</h1><p id="9db3" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">API cast(<a class="ae mf" href="https://github.com/3scale/apicast" rel="noopener ugc nofollow" target="_blank">https://github.com/3scale/apicast</a>)是一个开源API网关，其主要关注领域是高性能和可扩展性。它是Redhat 3scale API管理解决方案的一部分，被全球数百家公司用来以安全和可控的方式公开他们的API。</p><p id="ee16" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它基于Openresty，这是一个成熟的web平台，将标准的Nginx核心、LuaJIT和Lua库与第三方Nginx模块集成在一起。因此，我们通过使用LUA，将NGINX的性能和健壮性与扩展/更改其功能的简单方法结合起来。</p><p id="1a92" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">APIcast部署在多种场景中，例如基本和通用部署，其中APIcast是API的入口点，所有请求都要经过它:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mg"><img src="../Images/a7747c01a2bad2fd46e66b26efa18e53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*SjRthxlAqhG5pERz"/></div></div></figure><p id="67ff" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是，我们的用户越来越多地将APIcast部署为大型复杂微服务部署的API网关，无论是在前端还是在特定服务之间。</p><p id="5d4e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">可以想象，我们正在谈论数百个相互交互的微服务，每个外部请求最终都会在服务之间创建几个请求。这提出了新的挑战，其中之一就是“可观察性”</p><ul class=""><li id="e91d" class="mh mi iq jp b jq jr ju jv jy mj kc mk kg ml kk mm mn mo mp bi translated">为什么这个请求这么慢？</li><li id="c11f" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated">哪项服务造成了这些延迟峰值？</li><li id="b33a" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated">当用户点击这个端点时，哪些服务正在交互？</li><li id="d642" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated">为什么请求失败了？</li><li id="2fff" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated">是谁提出这个请求的？</li><li id="6657" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi">…</li></ul><p id="07ae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，回答这些问题既慢又复杂，因为用户开始通过日志调试，并试图关联一切。</p><p id="cbe1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们需要开始研究如何监控微服务，分布式跟踪作为一种模式出现，有助于我们深入了解系统内部的情况。</p><p id="c063" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">向我们的微服务部署添加分布式跟踪需要什么？</p><ul class=""><li id="663a" class="mh mi iq jp b jq jr ju jv jy mj kc mk kg ml kk mm mn mo mp bi translated">每个外部请求都应该附有一个<strong class="jp ir">唯一请求ID </strong>，通常是通过HTTP头</li><li id="5d3d" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated">每个服务应该<strong class="jp ir">将请求ID </strong>转发给其他服务</li><li id="e32b" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated">每个服务应该<strong class="jp ir">在日志</strong>中输出请求ID</li><li id="14e9" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated">每个服务应该<strong class="jp ir">记录附加信息</strong>，比如请求的开始和结束时间。</li><li id="3ff2" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated"><strong class="jp ir">日志需要在某处聚集</strong>，并提供一种通过HTTP请求ID进行解析的方法。</li></ul><p id="a4ef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于APIcast，这很简单，附加一个惟一的ID作为HTTP头，我们就完成了…</p><p id="761e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是，用户需要定义所有服务的日志格式、要存储在日志中的参数、要使用的http头、如何捕获每个请求的开始/结束时间…关联它们，检查如何在第三方应用程序中执行这些操作，尝试修改这些…</p><p id="f315" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以我们问自己，<em class="mv">难道不应该有一个“标准”的方法来做这件事吗？</em></p><p id="1905" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是OpenTracing的用武之地。</p><h1 id="c09f" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">OpenTracing</h1><p id="778f" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">Open tracing(<a class="ae mf" href="http://opentracing.io/" rel="noopener ugc nofollow" target="_blank">http://Open tracing . io</a>)提供了一致的、厂商中立的API、开源库和文档，供开发人员在他们的应用程序中插入和添加不同的跟踪实现。</p><p id="a8a3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">目前，OpenTracing项目提供了以下语言的库:</p><ul class=""><li id="3634" class="mh mi iq jp b jq jr ju jv jy mj kc mk kg ml kk mm mn mo mp bi translated">去</li><li id="e122" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated">计算机编程语言</li><li id="7b84" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated">java描述语言</li><li id="5a30" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated">Java 语言(一种计算机语言，尤用于创建网站)</li><li id="ff77" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated">C#</li><li id="611c" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated">目标-C</li><li id="954b" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated">C++</li><li id="2b1b" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated">红宝石</li><li id="0fb1" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated">服务器端编程语言（Professional Hypertext Preprocessor的缩写）</li></ul><p id="d76b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">而且有一个巨大的社区在推动新的贡献，请看:<a class="ae mf" href="https://github.com/opentracing-contrib" rel="noopener ugc nofollow" target="_blank">https://github.com/opentracing-contrib</a>。</p><p id="49ba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦您通过添加OpenTracing库对您的应用程序进行了检测，您将需要选择跟踪实现，这些是支持的实现:</p><ul class=""><li id="586c" class="mh mi iq jp b jq jr ju jv jy mj kc mk kg ml kk mm mn mo mp bi translated">贼鸥</li><li id="d8ea" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated">Appdash</li><li id="982f" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated">轻盈的步伐</li><li id="90a1" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated">霍克拉尔</li><li id="2c06" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi">(…)</li></ul><p id="0c4f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们决定选择Jaeger，因为它是CNF的一部分，有Openshift-ready部署<a class="ae mf" href="https://github.com/jaegertracing/jaeger-openshift" rel="noopener ugc nofollow" target="_blank">https://github.com/jaegertracing/jaeger-openshift</a>，Red Hat也在为此做出贡献。</p><h1 id="0d32" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">追踪:耶格</h1><p id="6bfc" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">Jaeger是由优步技术公司开发的分布式追踪系统，灵感来自Dapper和Openzipkin。它支持多个存储后端，是OpenTracing原生的，包括一个现代的web UI，它是为性能而设计的。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mw"><img src="../Images/a98290a7d0aac217aa628a821255a227.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1qLrgx7l0W1OECS3"/></div></div></figure><p id="6ff9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如图所示，主要组件包括:</p><ul class=""><li id="49d9" class="mh mi iq jp b jq jr ju jv jy mj kc mk kg ml kk mm mn mo mp bi translated"><strong class="jp ir">积家客户端:</strong>通过UDP向积家代理发送跟踪信息。</li><li id="64d4" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated"><strong class="jp ir">积家代理:</strong>从积家客户端向积家收集器报告踪迹。</li><li id="bfb5" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated"><strong class="jp ir"> Jaeger-collector: </strong>集中jaeger-agents的踪迹，并将它们保存到存储后端。</li><li id="c667" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated"><strong class="jp ir"> Jaeger-query: </strong>从数据存储中检索踪迹</li><li id="8d75" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated"><strong class="jp ir"> Jaeger-ui: </strong> Jaeger UI，使用jaeger-query获取检索痕迹。</li></ul><p id="a945" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Jaeger支持自适应采样，这意味着我们可以通过选择合适的采样器来调整采样的轨迹数量:</p><ul class=""><li id="c66c" class="mh mi iq jp b jq jr ju jv jy mj kc mk kg ml kk mm mn mo mp bi translated"><strong class="jp ir">恒:</strong>一切痕迹。</li><li id="7611" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated"><strong class="jp ir">概率:</strong>可以从0%调整到100%</li><li id="fb8d" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated"><strong class="jp ir">速率限制:</strong>每秒多少道，例如:2.0(每秒只有2道。)</li><li id="95dc" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated"><strong class="jp ir">远程:</strong>与jaeger代理一起检查该服务使用哪个取样器。</li></ul><p id="b5a3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">想了解更多关于Jaeger的信息，请访问:<a class="ae mf" href="https://www.jaegertracing.io/" rel="noopener ugc nofollow" target="_blank">https://www . jaegertracing . io</a></p><h1 id="425b" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">在APIcast中启用OpenTracing和Jaeger</h1><p id="faeb" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">我们打包了所有的OpenTracing库，并将Jaeger Tracer库打包在APIcast的基础容器映像中，<a class="ae mf" href="https://github.com/3scale/s2i-openresty" rel="noopener ugc nofollow" target="_blank"> s2i-openresty </a>。这个图像是<a class="ae mf" href="https://github.com/openshift/source-to-image" rel="noopener ugc nofollow" target="_blank">“源到图像”</a>启用的，所以你可以使用它作为你自己项目的基础。</p><p id="1720" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将使用<a class="ae mf" href="https://www.openshift.com/" rel="noopener ugc nofollow" target="_blank"> OpenShift </a>和APIcast的容器映像(<a class="ae mf" href="https://quay.io/repository/3scale/apicast" rel="noopener ugc nofollow" target="_blank">https://quay.io/repository/3scale/apicast</a>)，因此我们假设您已经在OpenShift上部署了APIcast并创建了您的3scale帐户，如果不是这样，这里有一个惊人的指南来帮助您立即开始运行&amp;:<a class="ae mf" href="https://github.com/3scale/apicast/blob/master/doc/openshift-guide.md" rel="noopener ugc nofollow" target="_blank">在Red Hat OpenShift上使用3scale API网关</a></p><p id="1d95" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用ENV变量启用/禁用APIcast OpenTracing支持:</p><ul class=""><li id="d7b7" class="mh mi iq jp b jq jr ju jv jy mj kc mk kg ml kk mm mn mo mp bi translated"><strong class="jp ir"> OPENTRACING_TRACER </strong>:使用哪个TRACER实现，目前只有Jaeger可用。</li><li id="6326" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated"><strong class="jp ir"> OPENTRACING_CONFIG </strong>:每个tracer都有一个默认的配置文件，这里可以看到一个例子:<a class="ae mf" href="https://github.com/3scale/apicast/blob/master/gateway/conf.d/opentracing/jaeger.example.json" rel="noopener ugc nofollow" target="_blank"> jaeger.example.json </a></li><li id="fbf1" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated"><strong class="jp ir">OPENTRACING _ HEADER _ FORWARD:</strong>默认情况下，使用uber-trace-id，如果你的open tracing有不同的配置，你将需要更改这个值，如果没有，忽略它。</li></ul><p id="3346" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，让我们部署Jager All-In-One模板，这并不真正意味着生产环境，但对于演示目的来说，这就足够了。</p><ul class=""><li id="8b86" class="mh mi iq jp b jq jr ju jv jy mj kc mk kg ml kk mm mn mo mp bi translated">在当前名称空间中安装Jaeger一体机:</li></ul><pre class="km kn ko kp gt mx my mz na aw nb bi"><span id="0459" class="nc ld iq my b gy nd ne l nf ng">oc process -f <a class="ae mf" href="https://raw.githubusercontent.com/jaegertracing/jaeger-openshift/master/all-in-one/jaeger-all-in-one-template.yml" rel="noopener ugc nofollow" target="_blank">https://raw.githubusercontent.com/jaegertracing/jaeger-openshift/master/all-in-one/jaeger-all-in-one-template.yml</a> | oc create -f -</span></pre><p id="53cb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有关在生产环境中部署jaeger的更多信息:<a class="ae mf" href="https://github.com/jaegertracing/jaeger-openshift#production-setup" rel="noopener ugc nofollow" target="_blank">https://github . com/jaegertracing/jaeger-open shift # production-setup</a></p><ul class=""><li id="697e" class="mh mi iq jp b jq jr ju jv jy mj kc mk kg ml kk mm mn mo mp bi translated">访问积家界面:</li></ul><pre class="km kn ko kp gt mx my mz na aw nb bi"><span id="cebb" class="nc ld iq my b gy nd ne l nf ng"><em class="mv">&gt; oc get route</em></span><span id="fb84" class="nc ld iq my b gy nh ne l nf ng"><em class="mv">(…) </em><strong class="my ir"><em class="mv">jaeger-query-myproject.127.0.0.1.nip.io</em></strong></span></pre><p id="4465" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我的例子中，网址是<a class="ae mf" href="https://jaeger-query-myproject.127.0.0.1.nip.io/" rel="noopener ugc nofollow" target="_blank">https://jaeger-query-my project . 127 . 0 . 0 . 1 . nip . io</a></p><p id="d8b3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">迎接你的应该是这只看起来很危险的地鼠:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ni"><img src="../Images/4a18b9a354ab92f6bf419daa7bfcc9ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WQ5lj7lnjJPUVsdW"/></div></div></figure><ul class=""><li id="5cf7" class="mh mi iq jp b jq jr ju jv jy mj kc mk kg ml kk mm mn mo mp bi translated">现在，让我们创建自己的Jaeger配置文件:</li></ul><pre class="km kn ko kp gt mx my mz na aw nb bi"><span id="4690" class="nc ld iq my b gy nd ne l nf ng">cat &lt;&lt;EOF &gt;jaeger_config.json<br/>  {<br/>    "service_name": "apicast",<br/>    "disabled": false,<br/>    "sampler": {<br/>      "type": "const",<br/>      "param": 1<br/>    },<br/>    "reporter": {<br/>      "queueSize": 100,<br/>      "bufferFlushInterval": 10,<br/>      "logSpans": false,<br/>      "localAgentHostPort": "jaeger-agent:6831"<br/>    },<br/>    "headers": {<br/>      "jaegerDebugHeader": "debug-id",<br/>      "jaegerBaggageHeader": "baggage",<br/>      "TraceContextHeaderName": "uber-trace-id",<br/>      "traceBaggageHeaderPrefix": "testctx-"<br/>    },<br/>    "baggage_restrictions": {<br/>        "denyBaggageOnInitializationFailure": false,<br/>        "hostPort": "127.0.0.1:5778",<br/>        "refreshInterval": 60<br/>    }<br/> }<br/>EOF</span></pre><p id="5474" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这将创建一个新文件:<em class="mv"> jaeger_config.json </em></p><ul class=""><li id="ec70" class="mh mi iq jp b jq jr ju jv jy mj kc mk kg ml kk mm mn mo mp bi translated">让我们回顾一下重要的部分:</li></ul><p id="5407" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">取样器配置:</strong></p><pre class="km kn ko kp gt mx my mz na aw nb bi"><span id="a027" class="nc ld iq my b gy nd ne l nf ng">"sampler": {<br/>      "type": "const",<br/>      "param": 1<br/>}</span></pre><p id="db1b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这将采样器定义为[const]ant，参数为“1”，这意味着它将对所有请求进行采样。</p><p id="9a84" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">记者:</strong></p><pre class="km kn ko kp gt mx my mz na aw nb bi"><span id="e548" class="nc ld iq my b gy nd ne l nf ng">"reporter": {<br/>      "queueSize": 100,<br/>      "bufferFlushInterval": 10,<br/>      "logSpans": false,<br/>      "localAgentHostPort": "jaeger-agent:6831"<br/>}</span></pre><p id="e518" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最大队列为100个请求，刷新间隔为10秒，我们不会将跨度输出到日志中，代理主机预计将在“jaeger-agent:6831”上运行。</p><p id="1b95" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您的服务在不到10秒的时间内处理100个以上的请求，那么您需要调整这些值，要么增加queueSize，要么减少bufferFlushInterval。</p><p id="47ad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">标题</strong>:</p><pre class="km kn ko kp gt mx my mz na aw nb bi"><span id="6999" class="nc ld iq my b gy nd ne l nf ng">"headers": {<br/>      "jaegerDebugHeader": "debug-id",<br/>      "jaegerBaggageHeader": "baggage",<br/>      "TraceContextHeaderName": "uber-trace-id",<br/>      "traceBaggageHeaderPrefix": "testctx-"<br/>}</span></pre><p id="d7c4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">目前最重要的是<em class="mv"> TraceContextHeaderName </em>，我们将使用默认值<em class="mv"> uber-trace-id </em>。这是我们需要在所有服务中转发的HTTP头，以传播span信息并能够将它们关联起来。</p><ul class=""><li id="8729" class="mh mi iq jp b jq jr ju jv jy mj kc mk kg ml kk mm mn mo mp bi translated">现在我们应该从jaeger配置文件中创建一个ConfigMap，这样我们就可以在APIcast中挂载它了:</li></ul><pre class="km kn ko kp gt mx my mz na aw nb bi"><span id="bb37" class="nc ld iq my b gy nd ne l nf ng">oc create configmap jaeger-config --from-file=jaeger_config.json</span></pre><ul class=""><li id="5c6d" class="mh mi iq jp b jq jr ju jv jy mj kc mk kg ml kk mm mn mo mp bi translated">将配置映射装入APIcast。</li></ul><pre class="km kn ko kp gt mx my mz na aw nb bi"><span id="72be" class="nc ld iq my b gy nd ne l nf ng">oc volume dc/apicast --add -m /tmp/jaeger/ --configmap-name jaeger-config</span></pre><p id="d3eb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这将触发APIcast的重新部署，现在所有的吊舱都将有我们的新配置，可在/tmp/jaeger/jaeger_config.json获得。</p><ul class=""><li id="16ab" class="mh mi iq jp b jq jr ju jv jy mj kc mk kg ml kk mm mn mo mp bi translated">让我们使用自定义配置启用OpenTracing和Jaeger:</li></ul><pre class="km kn ko kp gt mx my mz na aw nb bi"><span id="c85c" class="nc ld iq my b gy nd ne l nf ng">oc env deploymentConfig/apicast OPENTRACING_TRACER=jaeger OPENTRACING_CONFIG=/tmp/jaeger/jaeger_config.json</span></pre><p id="6782" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这将触发APIcast的重新部署，我们应该会看到新数据被填充到我们的Jaeger UI中:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nj"><img src="../Images/fd101e9136c5d398456ec1704618fbd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ImXExDynvQ9X22xu"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">在jaeger UI中显示的APIcasts轨迹</figcaption></figure><p id="cf30" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不错！现在，您可以看到一些来自Openshift运行状况检查的痕迹，让我们单击其中一个:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nk"><img src="../Images/dfca66098861ee9965f658eff7c42da0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-iSGAykId6h1xCVK"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">APIcast跟踪的详细信息</figcaption></figure><ul class=""><li id="8304" class="mh mi iq jp b jq jr ju jv jy mj kc mk kg ml kk mm mn mo mp bi translated">好了，APIcast现在正在向Jaeger报告踪迹，让我们做一个请求:</li></ul><pre class="km kn ko kp gt mx my mz na aw nb bi"><span id="4839" class="nc ld iq my b gy nd ne l nf ng">curl -kv "<a class="ae mf" href="https://apicast.127.0.0.1.nip.io/?user_key=" rel="noopener ugc nofollow" target="_blank">https://apicast.127.0.0.1.nip.io:443/?user_key=</a>...."</span></pre><p id="4233" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们看看Jaeger用户界面:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nl"><img src="../Images/0b57b4a218817bb6a77e5c7628edb888.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*patt72cGlfCqdn3a"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">jaeger-ui中的APIcast痕迹</figcaption></figure><p id="a6d4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如你所看到的，我们跟踪APIcast的不同动作，但是我们的后端服务“echo-API”(<a class="ae mf" href="https://github.com/3scale/echo-api" rel="noopener ugc nofollow" target="_blank">https://github.com/3scale/echo-api</a>)没有向Jaeger报告任何事情。</p><p id="3fca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们需要给它添加OpenTracing和Jaeger支持，这再简单不过了:<a class="ae mf" href="https://github.com/3scale/echo-api/pull/40/files" rel="noopener ugc nofollow" target="_blank">https://github.com/3scale/echo-api/pull/40/files</a></p><ul class=""><li id="cd49" class="mh mi iq jp b jq jr ju jv jy mj kc mk kg ml kk mm mn mo mp bi translated">现在，让我们重复一下…</li></ul><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nm"><img src="../Images/3a07ca04b4853a4e4b187328cd9d7678.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*TG8glvHRWF5l-w7p"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">APIcast和echo-api跟踪</figcaption></figure><p id="e4a5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如您所见，现在有两个与这些跟踪相关的服务，如果我们单击它…</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi lb"><img src="../Images/55c1059eded6a315daa2692016e0c409.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-PXTf1c-31YSnWR-"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">APIcast和echo-api详细跟踪</figcaption></figure><p id="a1fb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以看到每个服务何时介入以及需要多长时间。</p><h1 id="bbf2" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">当前的限制</h1><p id="3402" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">如你所知，Openresty是Nginx + luaJIT，目前，我们只获得它的“Nginx”部分的OpenTracing信息，没有任何针对lua的OpenTracing库。</p><p id="9830" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们正致力于能够使用OpenTracing C++库，这样我们可以直接从LUA创建跟踪，并获得对APIcast内部的更多可见性。例如，如果您刚刚安装的自定义策略导致速度变慢，这将有助于调试。</p><h1 id="b9b3" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">结论</h1><ul class=""><li id="c7df" class="mh mi iq jp b jq ma ju mb jy nn kc no kg np kk mm mn mo mp bi translated">APIcast现在可以位于启用OpenTracing的服务之前或之间，它将转发现有的或添加额外的跟踪。</li><li id="5c3a" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated">这允许您轻松地识别API中的瓶颈、延迟或错误。</li><li id="2432" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated">OpenTracing和jaeger集成已经在上游项目中可用:<a class="ae mf" href="https://github.com/3scale/apicast" rel="noopener ugc nofollow" target="_blank">https://github.com/3scale/apicast</a></li><li id="037d" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated">这些更改将在未来添加到3scale API管理产品中。</li></ul><h1 id="b446" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">想要帮助/贡献</h1><p id="2c78" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">如果你对此类项目感兴趣，我们一直在寻找新的贡献者！或者更好，新员工，<a class="ae mf" href="https://www.3scale.net/about/jobs/" rel="noopener ugc nofollow" target="_blank">我们正在招聘！</a>:)</p></div></div>    
</body>
</html>