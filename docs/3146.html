<html>
<head>
<title>How to write a Cluster API provider for running Kubernetes cluster on baremetal</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何为在baremetal上运行Kubernetes集群编写一个集群API提供程序</h1>
<blockquote>原文：<a href="https://itnext.io/kubernetes-cluster-creation-on-baremetal-host-using-cluster-api-1c2373230a17?source=collection_archive---------1-----------------------#2019-10-12">https://itnext.io/kubernetes-cluster-creation-on-baremetal-host-using-cluster-api-1c2373230a17?source=collection_archive---------1-----------------------#2019-10-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="6adf" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated"><strong class="jq ir">这篇博文是开源峰会Japan 2019上呈现的</strong> <a class="ae km" href="https://www.slideshare.net/HimaniAgrawal4/using-libvirt-with-cluster-api-to-manage-baremetal-kubernetes" rel="noopener ugc nofollow" target="_blank"> <strong class="jq ir"> talk </strong> </a> <strong class="jq ir">的总结。</strong> <a class="ae km" href="https://events.linuxfoundation.org/wp-content/uploads/2018/07/OSS-Japan-Cluster-API-Himani-Agrawal-Giri-Kuncoro.pdf" rel="noopener ugc nofollow" target="_blank"> <strong class="jq ir">演示链接</strong> </a> <strong class="jq ir">。</strong></p></div><div class="ab cl kn ko hu kp" role="separator"><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks"/></div><div class="ij ik il im in"><p id="92df" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">供应和管理Kubernetes集群一直是一项具有挑战性的任务，尽管从早期开始已经变得容易了。为了使Kubernetes的创建和管理更加容易，<a class="ae km" href="https://github.com/kubernetes/community/tree/master/sig-cluster-lifecycle" rel="noopener ugc nofollow" target="_blank">集群生命周期SIG </a>已经提出了一些工具，如<a class="ae km" href="https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/" rel="noopener ugc nofollow" target="_blank"> kubeadm </a>、<a class="ae km" href="https://github.com/kubernetes/kops" rel="noopener ugc nofollow" target="_blank"> kops </a>等。</p></div><div class="ab cl kn ko hu kp" role="separator"><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks"/></div><div class="ij ik il im in"><p id="2298" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">kubeadm 是一个与云无关的工具，提供Kubernetes集群并处理集群升级，但不涉及基础设施管理领域。</p><p id="e0ae" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated"><strong class="jq ir"> kops </strong>处理云资源的创建，在<a class="ae km" href="https://github.com/kubernetes/kops/blob/master/docs/aws.md" rel="noopener ugc nofollow" target="_blank"> AWS </a>和<a class="ae km" href="https://github.com/kubernetes/kops/blob/master/docs/tutorial/gce.md" rel="noopener ugc nofollow" target="_blank"> GCE </a>上安装依赖项和创建Kubernetes集群。但是它不支持许多其他基础设施提供商。</p><p id="8f9e" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">虽然这两个只是例子，但是有70多种方法可以部署Kubernetes集群。</p><p id="a8df" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">到目前为止缺少的是:</p><ol class=""><li id="2136" class="ku kv iq jq b jr js jv jw jz kw kd kx kh ky kl kz la lb lc bi translated">一个声明性的，<a class="ae km" href="https://kubernetes.io/docs/concepts/overview/kubernetes-api/" rel="noopener ugc nofollow" target="_blank"> Kubernetes风格的API </a>，所以我们可以用我们习惯的方式管理和维护Kubernetes基础设施。</li><li id="df6a" class="ku kv iq jq b jr ld jv le jz lf kd lg kh lh kl kz la lb lc bi translated">与我们已经拥有的工具兼容，例如<a class="ae km" href="https://kubernetes.io/docs/reference/kubectl/overview/" rel="noopener ugc nofollow" target="_blank"> kubectl </a>。</li><li id="499f" class="ku kv iq jq b jr ld jv le jz lf kd lg kh lh kl kz la lb lc bi translated">跨多个云提供商提供和管理Kubernetes集群的一致方式。</li><li id="8217" class="ku kv iq jq b jr ld jv le jz lf kd lg kh lh kl kz la lb lc bi translated">通过单一界面管理基础架构和集群。</li></ol><p id="078c" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">为了解决上述问题，SIG社区启动了一个名为<a class="ae km" href="https://github.com/kubernetes-sigs/cluster-api" rel="noopener ugc nofollow" target="_blank">集群API </a>的新项目。</p><h1 id="db00" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated"><strong class="ak">什么是集群API？</strong></h1><p id="43f9" class="pw-post-body-paragraph jo jp iq jq b jr mg jt ju jv mh jx jy jz mi kb kc kd mj kf kg kh mk kj kk kl ij bi translated">集群API是Kubernetes中集群生命周期SIG项目的一部分，为集群创建、配置和管理带来了声明性的、<a class="ae km" href="https://kubernetes.io/docs/concepts/overview/kubernetes-api/" rel="noopener ugc nofollow" target="_blank"> Kubernetes风格的API</a>。它通过<a class="ae km" href="https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/" rel="noopener ugc nofollow" target="_blank">自定义资源定义(CRD) </a>在核心Kubernetes API之上提供可选的附加功能。</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi ml"><img src="../Images/62fdec798ff6b5d9ae498299d21aea8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bwrbghRAwtf6lEVvoJCbyQ.png"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">集群API功能工作流</figcaption></figure><p id="fca5" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">虽然项目名称中有“API ”,但它不仅仅是一个API。它可以被看作是一个框架。它当然提供了一个API，但也附带了一个协调集群的控制器——创建、更新和删除云中的资源。除了控制器之外，我们还有一个名为<code class="fe nb nc nd ne b">clusterctl</code>的CLI，用于从零开始创建新的集群。</p><p id="1f88" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">用户可以声明性地指定集群规范，比如有多少节点、Kubernetes的版本等等。集群API调用适当的基础设施提供者——AWS、GCP等。—创建实际的基础架构资源，例如虚拟机、VPC、负载平衡器等。最后，它在这些资源的基础上创建了一个Kubernetes集群。</p><blockquote class="nf ng nh"><p id="ce2d" class="jo jp ni jq b jr js jt ju jv jw jx jy nj ka kb kc nk ke kf kg nl ki kj kk kl ij bi translated">在这里，我们将概述集群API提供程序组件，以及如何使用Libvirt为裸机主机编写集群API提供程序。人们可以使用相同的概念为他们选择的基础设施创建新的提供者。</p></blockquote><p id="84d8" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated"><strong class="jq ir">集群API基础知识</strong></p><p id="e60b" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">集群API使用底层的<a class="ae km" href="https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/" rel="noopener ugc nofollow" target="_blank"> CRDs </a>来供应和管理Kubernetes集群。</p><p id="d574" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">它由Kubernetes集群上的五个定制资源组成。</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi nm"><img src="../Images/22b0d3ec76b06fadb937e24d7c3190a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-m678FX2RSxwHy10MaAtIA.png"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">它类似于集群API CRDs和Kubernetes资源</figcaption></figure><p id="dfab" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">一个<strong class="jq ir">集群</strong>资源提供了一种为要部署的Kubernetes集群(也称为目标集群)定义公共配置的方法。如何实际创建集群的实现取决于基础设施提供商。群集定义是在群集资源规范中指定的，它具有一般的群集信息，如网络CIDRs、API端点、服务域等。<br/><br/><strong class="jq ir">机器</strong>资源类似于一个单独的Kubernetes控制平面或Kubernetes工作节点。机器定义在机器资源规范中指定。它由kubelet版本等信息组成。机器资源类似于Kubernetes行话中的<strong class="jq ir"> Pod </strong>。</p><figure class="mm mn mo mp gt mq"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="c92a" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">一个<strong class="jq ir">机器集</strong>资源代表一组机器。MachineSet的概念来自ReplicaSet，但是它不是表示一组pod，而是表示一组机器。</p><p id="dfdb" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">一个<strong class="jq ir"> MachineDeployment </strong>资源代表机器的部署对象。这类似于Kubernetes中的<strong class="jq ir">部署</strong>资源。</p><p id="fb5a" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">一个<strong class="jq ir"> MachineClass </strong>资源有关于应该创建哪种机器的细节。例如，对于GCE提供者，该资源将具有关于机器是否是n1-standard-1、n1-standard-2等的细节。这类似于<strong class="jq ir">存储类</strong>资源。</p><h2 id="dd16" class="np lj iq bd lk nq nr dn lo ns nt dp ls jz nu nv lw kd nw nx ma kh ny nz me oa bi translated">集群API如何工作</h2><p id="f99b" class="pw-post-body-paragraph jo jp iq jq b jr mg jt ju jv mh jx jy jz mi kb kc kd mj kf kg kh mk kj kk kl ij bi translated">让我们来看看这些资源是什么样子的。我们从机器规格开始。</p><p id="90da" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">上面显示的机器规格由集群API组件— <strong class="jq ir">机器控制器</strong>使用。该控制器调用<strong class="jq ir">机器执行器</strong>负责创建/更新/删除机器。致动器由供应商指定。</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi ob"><img src="../Images/f9dfe6019bb8feadd3ca40f31d895a0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GUjAfox1-JKkI9AUIOTltw.png"/></div></div></figure><p id="ae7c" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">类似地，还有一个维护集群范围状态的集群控制器。</p><p id="1d7b" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">群集控制器和机器控制器一起构成提供者控制器管理器。</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi oc"><img src="../Images/6faf1b850a4c10927642ed5edefbdceb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gVrTvZ8y7y3TtuA3lCN0BA.png"/></div></div></figure></div><div class="ab cl kn ko hu kp" role="separator"><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks"/></div><div class="ij ik il im in"><h1 id="773b" class="li lj iq bd lk ll od ln lo lp oe lr ls lt of lv lw lx og lz ma mb oh md me mf bi translated"><strong class="ak">实施</strong></h1><p id="32b5" class="pw-post-body-paragraph jo jp iq jq b jr mg jt ju jv mh jx jy jz mi kb kc kd mj kf kg kh mk kj kk kl ij bi translated">让我们把手弄脏吧。带上你的Linux机器，让我们一起来解决吧！如果你没有，你也可以在一个嵌套的KVM机器上试试，从DigitalOcean或者GCP或者你自己的实验室得到一个。</p><blockquote class="nf ng nh"><p id="c10d" class="jo jp ni jq b jr js jt ju jv jw jx jy nj ka kb kc nk ke kf kg nl ki kj kk kl ij bi translated">到本文结束时，我们已经使用集群API Libvirt提供程序创建了一个Kubernetes控制平面，我们将从头开始编写。</p></blockquote><h2 id="0e80" class="np lj iq bd lk nq nr dn lo ns nt dp ls jz nu nv lw kd nw nx ma kh ny nz me oa bi translated"><strong class="ak">系统要求</strong></h2><p id="5255" class="pw-post-body-paragraph jo jp iq jq b jr mg jt ju jv mh jx jy jz mi kb kc kd mj kf kg kh mk kj kk kl ij bi translated">一台<strong class="jq ir">支持虚拟化的</strong> Ubuntu 18.04机器具有以下依赖关系。</p><ul class=""><li id="beb7" class="ku kv iq jq b jr js jv jw jz kw kd kx kh ky kl oi la lb lc bi translated"><a class="ae km" href="https://golang.org/" rel="noopener ugc nofollow" target="_blank">戈朗v1.12.6 </a></li><li id="0323" class="ku kv iq jq b jr ld jv le jz lf kd lg kh lh kl oi la lb lc bi translated">Libvirt v4.0.0(参考下一节以确保Libvirt配置正确)</li><li id="37ad" class="ku kv iq jq b jr ld jv le jz lf kd lg kh lh kl oi la lb lc bi translated"><a class="ae km" href="https://docs.docker.com/install/linux/docker-ce/ubuntu/" rel="noopener ugc nofollow" target="_blank"> Docker v18.09.7 </a></li><li id="8685" class="ku kv iq jq b jr ld jv le jz lf kd lg kh lh kl oi la lb lc bi translated"><a class="ae km" href="https://book-v1.book.kubebuilder.io/getting_started/installation_and_setup.html" rel="noopener ugc nofollow" target="_blank"> Kubebuilder v1.0.8 </a></li><li id="a51a" class="ku kv iq jq b jr ld jv le jz lf kd lg kh lh kl oi la lb lc bi translated"><a class="ae km" href="https://github.com/kubernetes-sigs/kustomize/releases/tag/v1.0.11" rel="noopener ugc nofollow" target="_blank"> Kustomize v1.0.11 </a></li><li id="4d60" class="ku kv iq jq b jr ld jv le jz lf kd lg kh lh kl oi la lb lc bi translated"><a class="ae km" href="https://kubernetes.io/docs/tasks/tools/install-kubectl/#install-kubectl-on-linux" rel="noopener ugc nofollow" target="_blank"> Kubectl v1.13 </a></li><li id="2868" class="ku kv iq jq b jr ld jv le jz lf kd lg kh lh kl oi la lb lc bi translated"><a class="ae km" href="https://kubernetes.io/docs/tasks/tools/install-minikube/" rel="noopener ugc nofollow" target="_blank">Minikube 1 . 2 . 0版</a></li><li id="ea1b" class="ku kv iq jq b jr ld jv le jz lf kd lg kh lh kl oi la lb lc bi translated"><a class="ae km" href="https://www.virtualbox.org/wiki/Downloads" rel="noopener ugc nofollow" target="_blank"> VirtualBox v6.0.8 </a></li></ul><p id="4d2f" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated"><strong class="jq ir"> Libvirt安装&amp;配置</strong></p><p id="bf42" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">运行下面的命令来安装<code class="fe nb nc nd ne b">libvirt</code>以及其他一些相关的包。</p><pre class="mm mn mo mp gt oj ne ok ol aw om bi"><span id="389e" class="np lj iq ne b gy on oo l op oq">$ sudo apt-get install -y \<br/>   qemu-kvm \<br/>   libvirt-daemon-system \<br/>   libvirt-clients \<br/>   bridge-utils \<br/>   libvirt-bin</span></pre><p id="d2ac" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">将当前用户添加到<code class="fe nb nc nd ne b">libvirt</code>用户组，以便libvirt可以作为非root用户使用。</p><pre class="mm mn mo mp gt oj ne ok ol aw om bi"><span id="bf39" class="np lj iq ne b gy on oo l op oq">$ usermod -a -G libvirt $(whoami)</span></pre><p id="332f" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">注销并重新登录以使用户组更改生效。</p><p id="c062" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">接下来，我们将配置libvirt，使其接受TCP连接。确保<code class="fe nb nc nd ne b">/etc/default/libvirtd</code>文件如下所示。</p><pre class="mm mn mo mp gt oj ne ok ol aw om bi"><span id="1925" class="np lj iq ne b gy on oo l op oq">start_libvirtd="yes"<br/>libvirtd_opts="--listen"</span></pre><p id="8bb4" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">更改<code class="fe nb nc nd ne b">/etc/libvirt/libvirtd.conf</code>文件，使其具有以下配置。</p><pre class="mm mn mo mp gt oj ne ok ol aw om bi"><span id="5531" class="np lj iq ne b gy on oo l op oq"># Disable TLS<br/>listen_tls = 0</span><span id="33b7" class="np lj iq ne b gy or oo l op oq"># Enable TCP port<br/>listen_tcp = 1</span><span id="d95b" class="np lj iq ne b gy or oo l op oq"># Add TCP port<br/>tcp_port = "16509"</span><span id="95c6" class="np lj iq ne b gy or oo l op oq"># Setup libvirt socket group<br/>unix_sock_group = "libvirt"</span><span id="2f28" class="np lj iq ne b gy or oo l op oq"># Setup libvirt socket permissions<br/>unix_sock_ro_perms = "0777"<br/>unix_sock_rw_perms = "0770"</span><span id="895a" class="np lj iq ne b gy or oo l op oq"># Setup libvirt auth<br/>auth_unix_ro = "none"<br/>auth_unix_rw = "none"</span><span id="d422" class="np lj iq ne b gy or oo l op oq"># Disable TCP auth<br/>auth_tcp = "none"</span><span id="10e9" class="np lj iq ne b gy or oo l op oq"># Enable auth log<br/>audit_logging = 1</span></pre><p id="2a89" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">通过运行命令重新启动libvirtd服务</p><pre class="mm mn mo mp gt oj ne ok ol aw om bi"><span id="85f7" class="np lj iq ne b gy on oo l op oq">$ sudo systemctl restart libvirtd</span></pre><h2 id="24f1" class="np lj iq bd lk nq nr dn lo ns nt dp ls jz nu nv lw kd nw nx ma kh ny nz me oa bi translated"><strong class="ak">创建新的存储库</strong></h2><p id="880c" class="pw-post-body-paragraph jo jp iq jq b jr mg jt ju jv mh jx jy jz mi kb kc kd mj kf kg kh mk kj kk kl ij bi translated">现在系统已经配置好了，让我们开始编码吧。我们将首先创建脚手架和样板代码。然后，我们将着手编写业务逻辑。</p><pre class="mm mn mo mp gt oj ne ok ol aw om bi"><span id="e9af" class="np lj iq ne b gy on oo l op oq">$ mkdir -p ${GOPATH}/src/sigs.k8s.io/cluster-api-provider-libvirt<br/>$ cd ${GOPATH}/src/sigs.k8s.io/cluster-api-provider-libvirt</span></pre><p id="bb3f" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">接下来，我们将使用kubebuilder来生成脚手架。</p><p id="eb64" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated"><strong class="jq ir">什么是kubebuilder？</strong></p><p id="f6b2" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">Kubebuilder是一个SDK，用于在Go中快速构建和发布Kubernetes APIs。它建立在用于构建核心Kubernetes APIs的规范技术之上，提供简单的抽象来减少样板文件和繁琐的工作。</p><p id="1414" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated"><strong class="jq ir">生成脚手架</strong></p><p id="fd38" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">在新创建的存储库中运行以下命令。</p><pre class="mm mn mo mp gt oj ne ok ol aw om bi"><span id="c271" class="np lj iq ne b gy on oo l op oq">$ kubebuilder init --domain cluster.k8s.io --license apache2 --owner "GOJEK Tech"</span></pre><p id="9f8f" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">Kubebuilder会请求你的许可来运行<code class="fe nb nc nd ne b">dep ensure</code>。当询问时，输入<code class="fe nb nc nd ne b">y</code>授予许可。</p><pre class="mm mn mo mp gt oj ne ok ol aw om bi"><span id="78ef" class="np lj iq ne b gy on oo l op oq">Run `dep ensure` to fetch dependencies (Recommended) [y/n]?<br/>y</span></pre><p id="c2a3" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">这个命令生成一堆文件。让我们快速看一下它生成的主要文件夹以及它们的用途。</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi os"><img src="../Images/d75f2889667146eededc84ba306fdbc9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xU_CVQpzuKKWTV9vKwZ9UQ.png"/></div></div></figure><p id="e2bd" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated"><strong class="jq ir">为机器生成提供者资源</strong></p><p id="55d8" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">将<code class="fe nb nc nd ne b">cluster-api</code>作为依赖项添加到我们的项目中。</p><pre class="mm mn mo mp gt oj ne ok ol aw om bi"><span id="e65a" class="np lj iq ne b gy on oo l op oq">dep ensure -add sigs.k8s.io/cluster-api@0.1.0</span></pre><p id="0051" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">现在让我们为libvirt提供者定义机器资源。</p><pre class="mm mn mo mp gt oj ne ok ol aw om bi"><span id="cc84" class="np lj iq ne b gy on oo l op oq">kubebuilder create api --group libvirt --version v1alpha1 --kind LibvirtMachineProviderSpec</span></pre><p id="2345" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">Kubebuilder提示我们创建资源和控制器。我们只会创造资源。我们不需要创建新的控制器，因为我们将使用集群API codebas中的控制器。</p><pre class="mm mn mo mp gt oj ne ok ol aw om bi"><span id="1afd" class="np lj iq ne b gy on oo l op oq">Create Resource under pkg/apis [y/n]?<br/>y<br/>Create Controller under pkg/controller [y/n]?<br/>n</span></pre><p id="e700" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated"><strong class="jq ir">寄存器方案</strong></p><p id="2acb" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">kubebuilder生成的管理器只知道我们定义的资源。它不知道公共集群API代码中定义的资源。因此，用下面的代码替换<code class="fe nb nc nd ne b">cmd/manager/main.go</code>中的内容。</p><figure class="mm mn mo mp gt mq"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="a578" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated"><strong class="jq ir">登记控制器</strong></p><p id="2937" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">要注册控制器，将<code class="fe nb nc nd ne b">pkg/controller/add_machine_controller.go</code>中的代码更改如下。</p><figure class="mm mn mo mp gt mq"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="02e3" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">现在我们有了一个新的集群API提供者样板代码。</p><p id="146e" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated"><strong class="jq ir">定义机器规格</strong></p><p id="5699" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">我们将在结构<code class="fe nb nc nd ne b">LibvirtMachineProviderSpecSpec</code>中定义机器创建所需的自定义字段。这些值必须由CRD的用户在使用该提供程序时提供。</p><p id="6203" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">该结构在<code class="fe nb nc nd ne b">pkg/apis/libvirt/v1aplha1/libvirtmachineproviderspec_types.go</code>中定义。</p><figure class="mm mn mo mp gt mq"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="cf14" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">一旦该结构被修改，运行<code class="fe nb nc nd ne b">make</code>重新生成相关代码。</p><p id="3359" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated"><strong class="jq ir"> Libvirt特定代码</strong></p><p id="51c6" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">我们现在将在<code class="fe nb nc nd ne b">pkg/cloud/libvirt/domain.go</code>中添加libvirt特定代码</p><figure class="mm mn mo mp gt mq"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="db2f" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated"><strong class="jq ir">致动器</strong></p><p id="fcd5" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">执行器是集群API的主要组件之一。在<code class="fe nb nc nd ne b">pkg/cloud/libvirt/actuators/machine/actuator.go</code>创建一个新的执行器</p><figure class="mm mn mo mp gt mq"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="80ec" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated"><strong class="jq ir"> Dockerfile </strong></p><p id="cacc" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">我们将在Docker容器上部署我们的提供者。容器应该已经安装了<code class="fe nb nc nd ne b">libvirt-dev</code>，因为它是一个<code class="fe nb nc nd ne b">libvirt-xml</code>依赖项。</p><figure class="mm mn mo mp gt mq"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="f73d" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated"><strong class="jq ir"> Makefile </strong></p><p id="93af" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">在Makefile中更改一些任务。</p><figure class="mm mn mo mp gt mq"><div class="bz fp l di"><div class="nn no l"/></div></figure><h2 id="262a" class="np lj iq bd lk nq nr dn lo ns nt dp ls jz nu nv lw kd nw nx ma kh ny nz me oa bi translated">部署提供程序</h2><p id="4fbb" class="pw-post-body-paragraph jo jp iq jq b jr mg jt ju jv mh jx jy jz mi kb kc kd mj kf kg kh mk kj kk kl ij bi translated">我们将在minikube上部署我们的提供者，我们已经在kvm hypervisor上运行了它。</p><pre class="mm mn mo mp gt oj ne ok ol aw om bi"><span id="7192" class="np lj iq ne b gy on oo l op oq">$ minikube start --vm-driver kvm2<br/>$ export IMG=himani93/cluster-api-provider-libvirt<br/>$ dep ensure -v<br/>$ make docker-build IMG=${IMG}<br/>$ make docker-push IMG=${IMG}<br/>$ make deploy</span></pre><h2 id="6a8c" class="np lj iq bd lk nq nr dn lo ns nt dp ls jz nu nv lw kd nw nx ma kh ny nz me oa bi translated">控制平面图像</h2><p id="768f" class="pw-post-body-paragraph jo jp iq jq b jr mg jt ju jv mh jx jy jz mi kb kc kd mj kf kg kh mk kj kk kl ij bi translated">我们现在将为运行Kubernetes控制平面的机器创建基本映像。</p><p id="6613" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated"><strong class="jq ir">创建启动盘镜像</strong></p><p id="9221" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">我们需要一个安装了Docker和Kubernetes组件的基本Ubuntu映像。这个映像将作为控制面板的引导盘。</p><p id="63eb" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">请按照资源库<a class="ae km" href="https://github.com/himani93/vm-builder" rel="noopener ugc nofollow" target="_blank">https://github.com/himani93/vm-builder</a>中的说明创建此图像或使用您自己的图像。</p><p id="5134" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated"><strong class="jq ir">创建用户数据图像</strong></p><p id="ff6d" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">现在，我们为节点初始化创建一个cloud-init映像。创建一个名为<code class="fe nb nc nd ne b">user-data</code>的文件，内容如下。</p><pre class="mm mn mo mp gt oj ne ok ol aw om bi"><span id="c3e7" class="np lj iq ne b gy on oo l op oq">#cloud-config<br/>password: passw0rd<br/>chpasswd: {expire: False}<br/>ssh_pwauth: True</span><span id="cb6c" class="np lj iq ne b gy or oo l op oq">runcmd:<br/>  - echo "127.0.0.1 kube-cp-01" &gt;&gt; /etc/hosts<br/>  - kubeadm init --pod-network-cidr 10.40.0.0/16</span></pre><p id="73fb" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">下面的文件名为<code class="fe nb nc nd ne b">meta-data</code></p><pre class="mm mn mo mp gt oj ne ok ol aw om bi"><span id="7b92" class="np lj iq ne b gy on oo l op oq">instance-id: kube-cp<br/>local-hostname: kube-cp</span></pre><p id="19bd" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">生成上述cloud-init文件的ISO映像。</p><pre class="mm mn mo mp gt oj ne ok ol aw om bi"><span id="39f1" class="np lj iq ne b gy on oo l op oq">$ genisoimage -output user-data.img -volid cidata -joliet -rock user-data meta-data</span></pre><h2 id="0ccb" class="np lj iq bd lk nq nr dn lo ns nt dp ls jz nu nv lw kd nw nx ma kh ny nz me oa bi translated"><strong class="ak">创建Kubernetes控制平面</strong></h2><p id="a521" class="pw-post-body-paragraph jo jp iq jq b jr mg jt ju jv mh jx jy jz mi kb kc kd mj kf kg kh mk kj kk kl ij bi translated">最后，是时候收获我们努力的成果了。我们现在将使用刚刚编写的自定义提供程序创建一个新的Kubernetes控制平面。</p><p id="6b33" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated"><strong class="jq ir">定义机床CRD </strong></p><p id="0caa" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">创建<code class="fe nb nc nd ne b">create_machine.yaml</code>。我们指定要使用的提供者以及创建它所需的其他机器特定信息，如<code class="fe nb nc nd ne b">imageURI</code>、<code class="fe nb nc nd ne b">userDataURI</code>等。</p><figure class="mm mn mo mp gt mq"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="d524" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">终于跑了</p><pre class="mm mn mo mp gt oj ne ok ol aw om bi"><span id="7384" class="np lj iq ne b gy on oo l op oq">kubectl apply -f create-machine.yaml</span></pre><p id="0f60" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">现在，机器控制器将创建一个名为<code class="fe nb nc nd ne b">kube-cp</code>的机器。</p><p id="a3b7" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">可以使用以下方式访问创建的机器</p><pre class="mm mn mo mp gt oj ne ok ol aw om bi"><span id="0316" class="np lj iq ne b gy on oo l op oq">virsh console kube-cp</span></pre><p id="0ee5" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">机器<code class="fe nb nc nd ne b">kube-cp</code>上运行的kubernetes pods可在登录到机器<code class="fe nb nc nd ne b">kube-cp</code>后访问。</p><pre class="mm mn mo mp gt oj ne ok ol aw om bi"><span id="d2f5" class="np lj iq ne b gy on oo l op oq">kube-cp$ kubectl --kubeconfig /etc/kubernetes/admin.conf get pods -n kube-system</span></pre><p id="40d7" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">集群API libvirt提供程序控制器管理器日志可以使用</p><pre class="mm mn mo mp gt oj ne ok ol aw om bi"><span id="d790" class="np lj iq ne b gy on oo l op oq">kubectl logs -f cluster-api-provider-libvirt-controller-manager-0 -n cluster-api-provider-libvirt-system -c manager</span></pre><h2 id="076e" class="np lj iq bd lk nq nr dn lo ns nt dp ls jz nu nv lw kd nw nx ma kh ny nz me oa bi translated">结论:</h2><p id="795d" class="pw-post-body-paragraph jo jp iq jq b jr mg jt ju jv mh jx jy jz mi kb kc kd mj kf kg kh mk kj kk kl ij bi translated">集群API可以使用声明式API提供基础设施和Kubernetes集群。它可以跨不同的云提供商运行，还可以灵活地定义基础架构和集群的供应。</p><p id="e1df" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">该项目仍处于alpha阶段，没有被广泛采用。</p><h2 id="90f5" class="np lj iq bd lk nq nr dn lo ns nt dp ls jz nu nv lw kd nw nx ma kh ny nz me oa bi translated">参考资料:</h2><p id="dd56" class="pw-post-body-paragraph jo jp iq jq b jr mg jt ju jv mh jx jy jz mi kb kc kd mj kf kg kh mk kj kk kl ij bi translated"><a class="ae km" href="https://blogs.vmware.com/cloudnative/2019/03/14/what-and-why-of-cluster-api/" rel="noopener ugc nofollow" target="_blank">https://blogs . VMware . com/cloud native/2019/03/14/what-and-why-of-cluster-API/</a></p><p id="10c9" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated"><a class="ae km" href="https://blogs.vmware.com/cloudnative/2019/05/14/cluster-api-kubernetes-lifecycle-management/" rel="noopener ugc nofollow" target="_blank">https://blogs . VMware . com/cloud native/2019/05/14/cluster-API-kubernetes-life cycle-management/</a></p><p id="8261" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated"><a class="ae km" href="https://blog.heptio.com/the-kubernetes-cluster-api-de5a1ff870a5" rel="noopener ugc nofollow" target="_blank">https://blog . hep TiO . com/the-kubernetes-cluster-API-de 5a 1 ff 870 a 5</a></p><h2 id="448b" class="np lj iq bd lk nq nr dn lo ns nt dp ls jz nu nv lw kd nw nx ma kh ny nz me oa bi translated">想了解关于集群API的更多信息:</h2><p id="03cb" class="pw-post-body-paragraph jo jp iq jq b jr mg jt ju jv mh jx jy jz mi kb kc kd mj kf kg kh mk kj kk kl ij bi translated">集群API松弛通道:<a class="ae km" href="http://slack.k8s.io/" rel="noopener ugc nofollow" target="_blank"> #cluster-api </a></p><p id="f0ab" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">集群API Github Repo:<a class="ae km" href="https://github.com/kubernetes-sigs/cluster-api" rel="noopener ugc nofollow" target="_blank">https://github.com/kubernetes-sigs/cluster-api</a></p><p id="934e" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">集群API git book:<a class="ae km" href="https://cluster-api.sigs.k8s.io/" rel="noopener ugc nofollow" target="_blank">https://cluster-api.sigs.k8s.io/</a></p></div></div>    
</body>
</html>