<html>
<head>
<title>Gloo: Function Gateway, Service Discovery and Service Routing on Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">gloo:Kubernetes上的功能网关、服务发现和服务路由</h1>
<blockquote>原文：<a href="https://itnext.io/gloo-function-gateway-service-discovery-and-service-routing-on-kubernetes-8d6416af2c95?source=collection_archive---------0-----------------------#2019-07-23">https://itnext.io/gloo-function-gateway-service-discovery-and-service-routing-on-kubernetes-8d6416af2c95?source=collection_archive---------0-----------------------#2019-07-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/480328c968e78cb628bd77f591fb01db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DCT3FiwJMKOYQGOspHgQFw.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">gloo.solo.io</figcaption></figure><div class=""/><p id="deba" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">混合部署由微服务、单片和无服务器功能组成。跨多个平台的服务在技术上需要多个API构造，这就要求API网关模式在客户端和与之通信的后端服务之间提供一个抽象层。</p><p id="229f" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">考虑到微服务，API网关模式主要解决“基于微服务的应用程序的客户端如何访问单个服务？”它处理第一层身份验证，并根据其服务注册中心中的映射将传入的请求(类似于反向代理)路由到相应的服务。认证、监控和流量管理等功能在API Gateway中实现，这样服务就不会知道这些细节，并对消费者隐藏这些细节。</p><p id="c6ad" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">Solo的Gloo是一个建立在<a class="ae la" href="https://www.envoyproxy.io/" rel="noopener ugc nofollow" target="_blank">特使代理</a>之上的功能网关。Envoy在服务或IP级别上路由，并且可以通过编写过滤器来扩展，Gloo使用这些过滤器在功能级别上工作。与所有其他网关一样，Gloo执行类似的功能(发现、路由、功能到功能的转换),在功能级别将传入的请求和事件路由到上游功能。</p><p id="c2fe" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">Gloo为访问所有服务提供了一个统一的/全局的入口点，可以从客户端使用的任何接口翻译到后端使用的任何接口。Gloo添加了与后端服务交互的基础设施，知道服务所期望的特定API，这将Gloo与简单地将API调用路由到服务的其他网关区分开来。</p><p id="74d3" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">Envoy与Gloo一起运行，并通过以平台无关的方式提供通用功能来抽象网络。Gloo聚合了来自客户端的REST APIs和事件调用，将集群内、集群外、跨集群的服务以及任何无服务器功能提供者“粘合”在一起。</p><p id="8707" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">Gloo控制平面组件部署为Kubernetes部署:</p><figure class="lc ld le lf gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi lb"><img src="../Images/5eed796cf22a97b3804d562eed71bd58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*FWdaqFB8TURf0Xu4"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">Kubernetes上的Gloo控制飞机</figcaption></figure><p id="fc22" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">Gloo的功能发现不断地观察功能和功能更新，并创建一个上游。</p><figure class="lc ld le lf gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi lb"><img src="../Images/00655e92faa607c0630db12b37381855.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NA1mVIzaU6VAK9mi"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">Gloo —功能发现</figcaption></figure><p id="047b" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">上游发现轮询主机从Envoy接收和请求的所有上游连接，并返回响应。</p><figure class="lc ld le lf gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi lb"><img src="../Images/e411bd85cd3624509e609e4d8cb9f913.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*d3PyPw8hfiiB7RUO"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">Gloo —上游发现</figcaption></figure><p id="e448" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">Kubernetes Ingress控制器扩展了Gloo配置语言以支持Kubernetes Ingress语言，使Gloo(和Envoy)能够监控和应用<a class="ae la" href="https://kubernetes.io/docs/concepts/services-networking/ingress/" rel="noopener ugc nofollow" target="_blank"> Kubernetes Ingress规则</a>。</p><figure class="lc ld le lf gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi lb"><img src="../Images/5e2da79ea85e56beb219498a2b8e6869.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6eNajLoX8Ufd-5XJ"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">入口控制器</figcaption></figure><figure class="lc ld le lf gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi lb"><img src="../Images/bb7b40af4c7f55368def71493dfc72ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*RVPc3Av0RkwQXm-3"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">Gloo —入口控制器</figcaption></figure><p id="4a3e" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">Envoy容器被部署为application-pod的一部分，并与Gloo的控制器进行交互，以将请求路由到Kubernetes服务以及Gloo的基于用户定义的规则的功能。</p><figure class="lc ld le lf gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi lb"><img src="../Images/5d276b27eb590b2b43045f4c77fa287b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*V3w9DVa-algLRaXa"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">路由请求特使</figcaption></figure><h1 id="3669" class="lg lh jf bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">Kubernetes上Gloo的基本路由(API到服务)</h1><p id="4700" class="pw-post-body-paragraph kc kd jf ke b kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv mi kx ky kz ij bi translated">Gloo方便用户实现基本的服务发现，并将请求路由到创建的服务，实现基于应用规范的可用功能。在本例中，使用Gloo的官方示例实现了一个基本路由。</p><p id="d213" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">petstore部署与指向该部署的服务一起创建。该部署是一个具有API (swagger)端点的应用程序，Gloo将自动识别该应用程序。</p><figure class="lc ld le lf gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mj"><img src="../Images/57fb94a8142b3bfe42e252a2ed5aa942.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UcpXhmHy02Aeec7G"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">示例部署</figcaption></figure><figure class="lc ld le lf gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi lb"><img src="../Images/a30d6a10beb769ef7be6c1ccaa17be66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*JmGxIZvSv7CM2hHO"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">Petstore示例</figcaption></figure><figure class="lc ld le lf gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mk"><img src="../Images/72f2de1a855d4b798b7116091e370be5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gbWbwpTdP70yB_ct"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">Petstore Kubernetes服务</figcaption></figure><p id="24a4" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">发现服务会自动创建一个上游。上游只不过是路由的目的地。在这种情况下，将为上面创建的petstore应用程序创建一个上游。glooctl提供了一个用于查询Gloo对象的CLI。</p><figure class="lc ld le lf gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ml"><img src="../Images/e93774ef1a2078f5d2147b3bc62d6b14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4zXmok94tdmzsDeJ"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">Gloo —上游</figcaption></figure><p id="7535" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如上所示，Gloo的功能发现服务自动识别所有可用的rest端点。应用程序的功能规范已确定，所有端点都在Gloo的功能规范中配置。</p><figure class="lc ld le lf gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mm"><img src="../Images/9ae5d9b2adf56e3f7e97202442e49dc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MoC8yazY-jYUurIO"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">Gloo —端点发现</figcaption></figure><p id="7d1a" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">可以使用glooctl创建一个带有前缀重写标志的路由，使Envoy能够更改上述服务的传出请求的路径:</p><figure class="lc ld le lf gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mn"><img src="../Images/9e6935e77f093bea642d5d97b595c094.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kuWLgyGShiPmpCs6"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">Gloo —路线</figcaption></figure><p id="807e" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">虚拟服务与上面创建的路由一起被创建。</p><figure class="lc ld le lf gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mo"><img src="../Images/b6ce841e138394108962a46127af7dd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ZK2mSYAmgfPjaW_k"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">Gloo —虚拟服务</figcaption></figure><p id="3d79" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如上所示，在这种情况下，上游的单个目的地与请求匹配器“/列表”一起配置。这应该能够使用在虚拟服务配置中创建的特定匹配器路径与上面创建的服务进行通信。</p><figure class="lc ld le lf gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mp"><img src="../Images/dbcb51076abd7d279b3adf0f2d01c750.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*W61722S0GRUOEaeP"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">Gloo —目的地服务</figcaption></figure><p id="2a8b" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如下所示，请求被重定向到petstore应用程序。</p><figure class="lc ld le lf gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi lb"><img src="../Images/27e3938fb33dda0c65ce9b57a573879d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qkaxzgIRCx8LDlHg"/></div></div></figure><p id="99da" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这显示了服务路由的传统API。</p><h1 id="1056" class="lg lh jf bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">Kubernetes上Gloo的功能路由(功能到服务)</h1><p id="aa4a" class="pw-post-body-paragraph kc kd jf ke b kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv mi kx ky kz ij bi translated">Gloo使用户能够传递一个函数，同时创建一个便于函数级路由的路由。</p><p id="3814" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">函数由路由中的名称引用。Gloo的函数规范是google.protobuf.struct类型，由上游插件为上游的类型指定。</p><pre class="lc ld le lf gt mq mr ms mt aw mu bi"><span id="932a" class="mv lh jf mr b gy mw mx l my mz">name: string<br/>spec: {google.protobuf.Struct}</span></pre><p id="cb66" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">用route定义函数:</p><pre class="lc ld le lf gt mq mr ms mt aw mu bi"><span id="da43" class="mv lh jf mr b gy mw mx l my mz"><em class="na">glooctl</em> <em class="na">route</em> <em class="na">create</em> <em class="na">\</em>--<em class="na">path</em>-<em class="na">exact</em> <em class="na">/petstore/findPet</em> <em class="na">\</em>--<em class="na">upstream</em> <em class="na">default</em>-<em class="na">petstore</em>-<em class="na">8080</em> <em class="na">\</em>--<em class="na">function</em> <em class="na">findPetById</em></span></pre><figure class="lc ld le lf gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nb"><img src="../Images/566426071c805321241414a9f82f4dc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cM6M9LsQ4Omy0HBg"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">Gloo创建路线</figcaption></figure><p id="d6ef" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这将创建一个新的匹配器和一个函数参数。现在定义的函数是“findPetById”</p><figure class="lc ld le lf gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nc"><img src="../Images/09ca95333075682f5ab7ebe91975aff9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*SYf6yLeqjzi4z6hO"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">匹配器配置</figcaption></figure><p id="e3cd" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这样，可以使用ID字段进行请求:</p><figure class="lc ld le lf gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi lb"><img src="../Images/e77d3dc21dcf3ad0d30c3cf568a89f28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7nOHANch6p7JL8ZB"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">使用ID的请求</figcaption></figure><p id="531c" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">也可以使用参数来提供基于标题的分类。可以将参数字段添加到现有的路由配置中。</p><figure class="lc ld le lf gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi lb"><img src="../Images/293c9014c4a1e56124e1f7b55e817e96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*j4cCRZ7KeRXu89n0"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">使用标题的请求</figcaption></figure><p id="46d9" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在上面的例子中，请求可以使用一个头字段。</p><p id="686d" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">Gloo将任意数量的后端提供的单个功能聚合到前端的单个API中，使开发人员能够与跨多个平台的服务进行交互，而无需担心平台特定的信息。Gloo有助于复杂的功能级路由、功能级流量分离、功能扇出和功能级鸭翼。</p></div></div>    
</body>
</html>