<html>
<head>
<title>Advanced cross-platform apps using local Swift packages and UIKit/AppKit</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用本地Swift包和UIKit/AppKit的高级跨平台应用</h1>
<blockquote>原文：<a href="https://itnext.io/advanced-cross-platform-apps-using-local-swift-packages-and-uikit-appkit-2a478e8b05cd?source=collection_archive---------1-----------------------#2021-04-19">https://itnext.io/advanced-cross-platform-apps-using-local-swift-packages-and-uikit-appkit-2a478e8b05cd?source=collection_archive---------1-----------------------#2021-04-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="e0c6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在SwiftUI发布和大肆宣传之前，我们必须为iOS使用普通UIKit，为macOS界面使用app kit……即使核心应用程序完全相同。很自然，你的跨平台应用程序会随着时间的推移而不断增长，最终你会将代码重构为模块。</p><p id="b361" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本教程向您展示了如何利用Swift Package Manager (SPM)的强大功能，为您的大规模应用程序创建一个干净、可扩展且特别共享的UI结构。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/0806d6053daf518aa08c14b854118fe7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lyDWHBl-OfR2j3kH0B0edA.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">将Swift文件和XIB界面构建器文件组合成包</figcaption></figure><p id="28b7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">注意:</strong>这是<a class="ae lb" href="https://link.medium.com/S4Rn5ggwofb" rel="noopener">使用本地Swift包</a>模块化Xcode项目的后续教程，并建立在那里提到的主题之上。如果你已经是iOS/macOS/SPM的高级用户，请继续，但是如果你对这个主题相当陌生，我强烈建议你先阅读我的另一篇文章。</p><h1 id="7d30" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">Swift和Xcode中UI构建的背景故事</h1><p id="9d87" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">在撰写本文时，构建用户界面有四种主要选择:</p><ol class=""><li id="c1de" class="mf mg iq jp b jq jr ju jv jy mh kc mi kg mj kk mk ml mm mn bi translated"><strong class="jp ir">明码:</strong> <br/>你完全掌控UI元素，自动布局引擎和连接的逻辑……没有任何隐藏的魔力。<br/>另一方面，它更加冗长，更难迭代，尤其是没有实时预览。</li><li id="bb67" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated"><strong class="jp ir">单视图界面构建器(XIB/NIB): <br/> </strong>可视化构建，完全支持自动布局、IB接口和IB设计，将UI与代码连接起来。它消除了很多痛苦，可以很好地与应用程序连接起来。<br/> <em class="mt">重要旁注</em> : macOS和iOS XIB不一样！</li><li id="0d70" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated"><strong class="jp ir">多视图界面构建器(故事板):</strong> <br/>与界面构建器功能相同，另外允许使用导航片段将多个视图链接在一起。<br/> <em class="mt">重要旁注:</em> macOS和iOS故事板不一样！</li><li id="b73d" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated"><em class="mt"> SwiftUI DSL(我们不会在本文中涉及它，因为它对于具有向后兼容性需求的大规模应用程序来说还不太适合生产)</em></li></ol><p id="d41a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从我个人的经验来看，故事板对于最初的开发非常有用。特别是由于使用segues的简单视图导航，您可以相当快地得到一个运行的原型。随着时间的推移，越来越多的视图被添加进来，最终Xcode开始努力渲染/处理/编译文件。慢慢地，它开始变得越来越难以处理(不要让我开始谈论如何处理那些数千行XML配置的合并冲突)。</p><p id="97bd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当您只想迭代单个视图，但是大的故事板不断改变多个视图时(例如，由于布局更新)，情况会变得更糟。或者当使用IBDesignables时，需要一次又一次地更新每一个视图。</p><p id="a4cc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">哦，你不喜欢导航到一个嵌套很深的子视图。单身。时间？您想在不同的应用程序目标中只使用故事板中的单个视图吗？当然，您总是可以让它出列，但是要确保包含所有必要的资产(甚至是您现在没有使用的资产)，否则它可能无法编译/运行。🙃</p><p id="26bc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么…我们如何改进我们的工作流程呢？我们回到更简单的UI构建！</p><h1 id="1a34" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">创建我们的时钟应用</h1><p id="e829" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">在本教程中，我们将构建一个简单的时钟应用程序，要求如下:</p><ul class=""><li id="8380" class="mf mg iq jp b jq jr ju jv jy mh kc mi kg mj kk mu ml mm mn bi translated">iOS和macOS应用程序</li><li id="1945" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mu ml mm mn bi translated">无SwiftUI(使用UIKit/AppKit)</li><li id="86ee" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mu ml mm mn bi translated">模块化、可扩展的架构</li><li id="28c3" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mu ml mm mn bi translated">在单一视图中显示当前时间</li><li id="a10a" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mu ml mm mn bi translated">当用户与应用程序交互时，时间会手动更新</li></ul><p id="2378" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如你所看到的，这是一个(愚蠢的)简单的应用程序，但是主要的焦点是使用Swift包管理器来构建UI组件，所以这就足够了。</p><p id="4db1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第一步，创建一个<strong class="jp ir">空Xcode项目</strong>作为我们的起点，并将其命名为<strong class="jp ir">时钟</strong>:</p><div class="km kn ko kp gt ab cb"><figure class="mv kq mw mx my mz na paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><img src="../Images/2d91b1b32d244e535d5c570f2a35cc7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*6L0tYZXaidggJYnkTf0gvA.png"/></div></figure><figure class="mv kq mw mx my mz na paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><img src="../Images/a00bd6dabc341767341fddcdd34e84a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*nNutLukkYpZh92rIIqdUPg.png"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk nb di nc nd translated">创建名为Clock的空Xcode项目</figcaption></figure></div><p id="af2e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在你有了一个干净的起点，在项目设置中，你需要通过点击左下角的小<strong class="jp ir">加号</strong>来添加iOS和macOS应用目标:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ne"><img src="../Images/4a02242812c9a6fa8b8044e704bf098e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pqO153yJeYzbXegWqByIsQ.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">向Xcode项目添加新目标可以通过单击加号来完成</figcaption></figure><p id="849c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于iOS目标，使用默认的<strong class="jp ir"> App </strong>模板和<strong class="jp ir">ui kit App Delegate life cycle</strong>，并将其命名为<em class="mt"> Clock_iOS。</em></p><blockquote class="nf ng nh"><p id="01ae" class="jn jo mt jp b jq jr js jt ju jv jw jx ni jz ka kb nj kd ke kf nk kh ki kj kk ij bi translated">对于捆绑包标识符，使用您自己的反向域名，例如，对我来说是<code class="fe nl nm nn no b"><em class="iq">com.techprimate</em></code> <em class="iq"> </em>，因为我的移动应用代理的域名是<a class="ae lb" href="http://techprimate.com" rel="noopener ugc nofollow" target="_blank">techprimate.com</a></p></blockquote><div class="km kn ko kp gt ab cb"><figure class="mv kq mw mx my mz na paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><img src="../Images/4c0bf5f499c5971ac418e89c86311718.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*krhSZUjaNvQ9i52AfrvPSA.png"/></div></figure><figure class="mv kq mw mx my mz na paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><img src="../Images/d4967c4730303d97a7442cc0e6600982.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*PglYpVkqlHTRtXMbkTRDyg.png"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk nb di nc nd translated">使用UIKit应用程序代理生命周期在Xcode中创建iOS应用程序目标</figcaption></figure></div><p id="5159" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">同样，对于macOS应用程序，使用默认的<strong class="jp ir">应用程序</strong>模板和<strong class="jp ir"> AppKit应用程序委托生命周期</strong>，并将其命名为<em class="mt"> Clock_macOS。</em>和以前一样，使用您自己的组织标识符:</p><div class="km kn ko kp gt ab cb"><figure class="mv kq mw mx my mz na paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><img src="../Images/b9745fcf17be74919ca70cb1f7d88784.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*k7W8oEMR8rsNBUEg6YUxdw.png"/></div></figure><figure class="mv kq mw mx my mz na paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><img src="../Images/c180680c98033c734a9b32c2b6e9ae87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*lafZan5r0aTcPqsKxZEvzA.png"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk nb di nc nd translated">使用AppKit应用程序委托生命周期在Xcode中创建macOS应用程序目标</figcaption></figure></div><p id="d2a2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在最后的项目设置步骤中，禁用自动代码签名(我们现在不需要它，通常它会通过创建不需要的预置描述文件和应用程序标识符来扰乱您的Apple开发者帐户)。您应该仍然能够运行macOS应用程序，设置<strong class="jp ir">符号为本地运行</strong>，以及模拟器中的iOS应用程序。</p><div class="km kn ko kp gt ab cb"><figure class="mv kq np mx my mz na paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><img src="../Images/292e4d6c3d9c549aafc1c8ddd66410b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1114/format:webp/1*CMTulrn5C_QJwFdv81kJ7A.png"/></div></figure><figure class="mv kq nq mx my mz na paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><img src="../Images/4632067bfab352d455f671574b5270af.png" data-original-src="https://miro.medium.com/v2/resize:fit:888/format:webp/1*R_LPWJYhrSxR49GACPqBSw.png"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk nr di ns nd translated">禁用代码签名的设置</figcaption></figure></div><p id="866e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">恭喜你创建了你的跨平台应用<em class="mt">时钟</em>！至少运行两个应用程序一次，以确保它们工作正常。别担心，两个屏幕都将是空白的，因为还没有UI显示，但我们接下来会解决这个问题。</p><h1 id="1c7e" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">创建共享用户界面库</h1><p id="9efd" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">由于时钟逻辑必须由两个应用程序共享，我们创建了一个本地Swift包库<code class="fe nl nm nn no b">ClockPackage</code>并将其拖到我们的Xcode项目中。详细的分步说明可以在<a class="ae lb" href="https://link.medium.com/S4Rn5ggwofb" rel="noopener">我之前的文章</a>中找到。</p><pre class="km kn ko kp gt nt no nu nv aw nw bi"><span id="a6a6" class="nx ld iq no b gy ny nz l oa ob">$ cd root/of/my/project<br/>$ mkdir ClockPackage<br/>$ cd ClockPackage<br/>$ swift package init --type library</span></pre><p id="f434" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">之后，您的项目应该如下所示:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi oc"><img src="../Images/866c257977d5d7a56f4490c3495237ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9doVToPPrgjfDmR7V-cT-Q.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">添加Swift包<em class="od"> ClockPackage </em>后的Xcode项目</figcaption></figure><p id="4bc1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了简单起见，通过更改文件夹名和包清单<code class="fe nl nm nn no b">Package.swift</code> <em class="mt">中的声明，将<code class="fe nl nm nn no b">ClockPackage</code> <em class="mt"> </em>目标重命名为<code class="fe nl nm nn no b">ClockUI</code>。另外，我们不会在本教程中使用测试，所以继续删除文件夹<code class="fe nl nm nn no b">Tests</code>和测试目标。</em></p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi oe"><img src="../Images/cbeba61849d68d2bf3b5869743ac4fbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UgzwcX1eV269jou1QpwYcg.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">清理后的包配置</figcaption></figure><h1 id="5611" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">添加XIB资源(错误的方式)</h1><p id="6a55" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">现在我们的UI包已经设置好了，您将创建XIB界面构建器文件。这两个应用程序都应该为用户提供一个按钮来更新当前时间，并显示在一个标签中。</p><p id="3b6e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在wolf vision<a class="ae lb" href="https://wolfvision.com" rel="noopener ugc nofollow" target="_blank">的一个iOS/macOS项目中使用SPM概念时，我意识到macOS和iOS的XIB接口文件是不可互换的。为了将我的经历形象化给你，我们现在将以错误的方式来做，然后再修复它。</a></p><p id="388c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从Swift 5.3开始，可以向Swift包中添加资源。苹果创建了一个<a class="ae lb" href="https://developer.apple.com/documentation/swift_packages/bundling_resources_with_a_swift_package" rel="noopener ugc nofollow" target="_blank">非常详细的文档</a>关于如何处理它们，但是为了教程的缘故，我会给你一个快速的总结:</p><ol class=""><li id="1381" class="mf mg iq jp b jq jr ju jv jy mh kc mi kg mj kk mk ml mm mn bi translated">在<code class="fe nl nm nn no b">Sources/ClockUI</code>中创建一个文件夹<code class="fe nl nm nn no b">Resources</code></li></ol><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi of"><img src="../Images/7ece2c1ec5d9a09a2429997e223af242.png" data-original-src="https://miro.medium.com/v2/resize:fit:1060/format:webp/1*KCmgeU23OwgszWy5SRaC7w.png"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">添加资源文件夹后的文件夹结构</figcaption></figure><p id="6979" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2.创建一个iOS视图<code class="fe nl nm nn no b">ClockViewController_iOS.xib</code></p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi og"><img src="../Images/c1a0ce3ad5479d9d7642165a25f30536.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RKaaIEWTSgSxzC-gJDxwEQ.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">在iOS类别中选择模板“视图”</figcaption></figure><p id="04a1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">3.创建macOS视图<code class="fe nl nm nn no b">ClockViewController_macOS.xib</code></p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi oh"><img src="../Images/0dbed8b9d958381c8940177e172e415e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GejsjhB6xbM6wEv0GAHroQ.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">在macOS类别中选择模板“视图”</figcaption></figure><p id="2656" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">4.将这两个文件作为资源添加到包清单的<em class="mt">目标</em>部分:</p><pre class="km kn ko kp gt nt no nu nv aw nw bi"><span id="6fec" class="nx ld iq no b gy ny nz l oa ob">...<br/>    targets: [<br/>        .target(name: "ClockUI", resources: [<br/>            .process("Resources/ClockViewController_iOS.xib"),<br/>            .process("Resources/ClockViewController_macOS.xib"),<br/>        ])<br/>    ]<br/>...</span></pre><p id="d057" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如您在这里看到的，我们使用<code class="fe nl nm nn no b">process(path: String)</code>在编译时将XIB文件编译成NIB文件，然后在运行时用于加载UI。</p><p id="f902" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要测试包的编译，在Xcode顶部工具栏中选择<code class="fe nl nm nn no b">ClockUI</code>作为运行方案。尝试为任何Mac电脑构建一次，为任何iOS设备构建一次。两次都会失败。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/9f58d1495c66d29a660607be634fd0c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1376/format:webp/1*xp03SLluTJo3PH6TawEloA.png"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">显示ClockUI失败构建的报告导航器</figcaption></figure><p id="075d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<em class="mt">报告导航器</em>中，您可以仔细查看两个失败的构建日志。您将看到macOS构建由于iOS XIB文件而失败，反之亦然。</p><div class="km kn ko kp gt ab cb"><figure class="mv kq oj mx my mz na paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><img src="../Images/5c0d183b88e86bac6cb2fe3109781f8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1132/format:webp/1*KKXGwRfq22ZqrDzMyesemw.png"/></div></figure><figure class="mv kq ok mx my mz na paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><img src="../Images/74b243634b7fb8f2ca4d28f89f797e8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:870/format:webp/1*bB3AyFqg56aJCykPOfPmyQ.png"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk ol di om nd translated">由于平台特定的XIB接口文件导致的构建错误</figcaption></figure></div><p id="a435" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于Swift包不支持条件资源编译，我们不能再使用这种精确的项目结构，必须改变我们的库。</p><h1 id="d512" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">添加XIB资源(正确的方式)</h1><p id="aece" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">创建两个额外的库<code class="fe nl nm nn no b">ClockUI_iOS</code>和<code class="fe nl nm nn no b">ClockUI_macOS</code>，每个库里面都有一个文件夹<code class="fe nl nm nn no b">Resource</code>。然后将<code class="fe nl nm nn no b">*.xib</code>文件移动到它们各自的文件中，并改变<code class="fe nl nm nn no b">Package.swift</code>清单以反映我们的新结构:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi on"><img src="../Images/778f939193cba0b3f08910a4de918abe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1364/format:webp/1*66Uuqyc4xfNrCnIz6eqhwA.png"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">更改为基于平台的包后的Swift包结构</figcaption></figure><pre class="km kn ko kp gt nt no nu nv aw nw bi"><span id="9817" class="nx ld iq no b gy ny nz l oa ob">let package = Package(<br/>    name: "ClockPackage",<br/>    products: [<br/>        .library(name: "ClockUI", targets: ["ClockUI"]),<br/>        .library(name: "ClockUI_iOS", targets: ["ClockUI_iOS"]),<br/>        .library(name: "ClockUI_macOS", targets: ["ClockUI_macOS"]),<br/>    ],<br/>    targets: [<br/>        .target(name: "ClockUI"),<br/>        .target(name: "ClockUI_iOS", resources: [<br/>            .process("Resources/ClockViewController_iOS.xib"),<br/>        ]),<br/>        .target(name: "ClockUI_macOS", resources: [<br/>            .process("Resources/ClockViewController_macOS.xib"),<br/>        ])<br/>    ]<br/>)</span></pre><p id="23a1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在你可以成功地为任何iOS设备<em class="mt">建立方案<code class="fe nl nm nn no b">ClockUI_iOS</code>，为任何Mac设备<em class="mt">建立方案</em>和为两者建立方案<code class="fe nl nm nn no b">ClockUI</code>🎉</em></p><h1 id="0006" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">创建接口</h1><p id="a6cc" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">希望你不要介意我跳过了在我们的iOS/macOS XIB文件中创建UI界面的详细解释(那里有这么多UIKit/AppKit教程),而是专注于构建架构。<br/>当然，你可以在<a class="ae lb" href="https://github.com/philprime/ClockSPMSample" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>中查看全部代码。</p><h2 id="ba0a" class="nx ld iq bd le oo op dn li oq or dp lm jy os ot lq kc ou ov lu kg ow ox ly oy bi translated">iOS界面</h2><p id="ed4c" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">首先在<code class="fe nl nm nn no b">ClockUI_iOS/ClockViewController.swift</code>的一个新文件中创建一个类<code class="fe nl nm nn no b">ClockViewController</code>，用一个IBOutlet访问时间标签，用一个IBAction作为按钮的目标动作。</p><pre class="km kn ko kp gt nt no nu nv aw nw bi"><span id="152d" class="nx ld iq no b gy ny nz l oa ob">import UIKit<br/><br/>public class ClockViewController: UIViewController {<br/><br/>    // MARK: - IB Outlets<br/><br/>    @IBOutlet weak var timeLabel: UILabel!<br/><br/>    // MARK: - IB Actions<br/><br/>    @IBAction func didTapFetchButtonAction() {<br/>        print("did tap fetch")<br/>    }<br/>}</span></pre><p id="28ac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">之后，您需要将<code class="fe nl nm nn no b">File's Owner</code>连接到视图控制器。确保模块<code class="fe nl nm nn no b">ClockUI_iOS</code>被选中，否则它将无法稍后解析该类。这也允许将IBOutlet/I action连接到代码(不要忘记设置<code class="fe nl nm nn no b">view</code> outlet！！)</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi oz"><img src="../Images/6f2b84e035db27d0adfdcbfeb7eb80d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lzBixqXYln_q9US_3Sg4Rg.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">XIB视图控制器类是在文件的所有者设置中设置的</figcaption></figure><p id="1886" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在继续介绍macOS等价物之前，让我们在我们的iOS应用程序中展示这个界面。为此，我们首先需要将<code class="fe nl nm nn no b">ClockUI_iOS</code>模块作为框架添加到我们的iOS目标中:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi pa"><img src="../Images/72993867fe9299a5e37a50b88249d986.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Oey7k0lxpdi5C5Z2D3FE-w.png"/></div></div></figure><p id="f200" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您做得很好，现在您可以在<code class="fe nl nm nn no b">Clock_iOS/ViewController.swift</code>文件中创建<code class="fe nl nm nn no b">import ClockUI_iOS</code>并创建<code class="fe nl nm nn no b">ClockViewController</code>的一个实例:</p><pre class="km kn ko kp gt nt no nu nv aw nw bi"><span id="7980" class="nx ld iq no b gy ny nz l oa ob">import UIKit<br/>import ClockUI_iOS<br/><br/>class ViewController: UIViewController {<br/><br/>    override func viewDidAppear(_ animated: Bool) {<br/>        super.viewDidAppear(animated)<br/><br/>        let clockVC = ClockViewController()<br/>        self.addChild(clockVC)<br/>        // set a debug background color so we can see the view<br/>        clockVC.view.backgroundColor = .orange<br/>        clockVC.view.autoresizingMask = [<br/>           .flexibleWidth, .flexibleHeight<br/>        ]<br/>        self.view.addSubview(clockVC.view)<br/>    }<br/>}</span></pre><p id="3ef5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如你所看到的，整个视图现在是橙色的，但仍然是空的。我们不需要创建一个<code class="fe nl nm nn no b">ClockViewController</code>的实例，而是需要通过修改下面的代码行从XIB文件中加载它</p><pre class="km kn ko kp gt nt no nu nv aw nw bi"><span id="ee22" class="nx ld iq no b gy ny nz l oa ob">...<br/>let clockVC = ClockViewController()<br/>// becomes<br/>let clockVC = ClockViewController.loadFromNib()<br/>...</span></pre><p id="1b0d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">并将<code class="fe nl nm nn no b">loadFromNib()</code>方法添加到<code class="fe nl nm nn no b">ClockViewController</code>中:</p><pre class="km kn ko kp gt nt no nu nv aw nw bi"><span id="497b" class="nx ld iq no b gy ny nz l oa ob">// MARK: - Nib Loading<br/><br/>public static func loadFromNib() -&gt; ClockViewController {<br/>    // Loads the compiled XIB = NIB file from the module <br/>    // resources bundle. Bundle.module includes all resources<br/>    // declared in the Package.swift manifest file<br/>    ClockViewController(nibName: "ClockViewController_iOS", <br/>                        bundle: Bundle.module)<br/>}</span></pre><p id="658c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">再次运行应用程序，你的按钮和标签就会出现🎉</p><h2 id="d558" class="nx ld iq bd le oo op dn li oq or dp lm jy os ot lq kc ou ov lu kg ow ox ly oy bi translated">macOS接口</h2><p id="d1c9" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">幸运的是，macOS实现的工作方式完全相同，但是使用了相应的macOS类和模块等价物:</p><p id="9f9c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">创建<code class="fe nl nm nn no b">ClockPackage/ClockUI_macOS/ClockViewController.swift</code></p><pre class="km kn ko kp gt nt no nu nv aw nw bi"><span id="8120" class="nx ld iq no b gy ny nz l oa ob">public class ClockViewController: NSViewController {<br/><br/>    // MARK: - IB Outlets<br/><br/>    @IBOutlet weak var timeLabel: NSTextField!<br/><br/>    // MARK: - IB Action<br/><br/>    @IBAction func didClickFetchButtonAction(_ sender: Any) {<br/>        print("did click fetch")<br/>    }<br/><br/>    // MARK: - Nib Loading<br/><br/>    public static func loadFromNib() -&gt; ClockViewController {<br/>        ClockViewController(nibName: "ClockViewController_macOS", <br/>                            bundle: Bundle.module)<br/>    }<br/>}</span></pre><p id="4196" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">同样，不要忘记连接<code class="fe nl nm nn no b">view</code>插座，否则它无法实例化笔尖。</p><blockquote class="nf ng nh"><p id="9b18" class="jn jo mt jp b jq jr js jt ju jv jw jx ni jz ka kb nj kd ke kf nk kh ki kj kk ij bi translated">如果Xcode没有向您显示链接<code class="fe nl nm nn no b">view</code>的选项，请将其作为<code class="fe nl nm nn no b">@IBOutlet weak var view: NSView!</code>添加到视图控制器Swift类中，然后它应该会显示在Xcode界面构建器中。链接后，您可以简单地删除line，它仍然可以正常工作，因为NSViewController已经拥有了一个同名的属性。</p></blockquote><ol class=""><li id="f8f9" class="mf mg iq jp b jq jr ju jv jy mh kc mi kg mj kk mk ml mm mn bi translated">将macOS XIB与班级联系起来</li><li id="53fb" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated">将<code class="fe nl nm nn no b">ClockUI_macOS</code>框架添加到<code class="fe nl nm nn no b">Clock_macOS</code>应用目标中</li><li id="1c44" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated">在<code class="fe nl nm nn no b">Clock_macOS/ViewController.swift</code>中增加<code class="fe nl nm nn no b">import ClockUI_macOS</code></li><li id="bb92" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated">将iOS包中的<code class="fe nl nm nn no b">loadFromNib</code>复制到macOS包中</li><li id="1f12" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated">将视图控制器添加到视图层次结构中:</li></ol><pre class="km kn ko kp gt nt no nu nv aw nw bi"><span id="72ba" class="nx ld iq no b gy ny nz l oa ob">import Cocoa<br/>import ClockUI_macOS<br/><br/>class ViewController: NSViewController {<br/><br/>    override func viewDidAppear() {<br/>        super.viewDidAppear()<br/><br/>        let clockVC = ClockViewController.loadFromNib()<br/>        self.addChild(clockVC)<br/>        clockVC.view.autoresizingMask = [.width, .height]<br/>        self.view.addSubview(clockVC.view)<br/>    }<br/>}</span></pre><p id="812f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">干得好！现在，您已经拥有了一个正在运行的iOS和macOS应用程序，使用Swift软件包中的接口资源🚀</p><h1 id="4f52" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">共享UI逻辑</h1><p id="0e2d" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">最后一步，我们想要创建一个在<code class="fe nl nm nn no b">ClockUI_iOS</code>和<code class="fe nl nm nn no b">ClockUI_macOS</code>包之间共享的服务。由于我们从一个<code class="fe nl nm nn no b">ClockUI</code>包开始，它完全符合我们的需求，因此将文件<code class="fe nl nm nn no b">.../ClockUI/UI.swift</code>重命名为<code class="fe nl nm nn no b">.../ClockUI/ClockService.swift</code>，并在其中创建一个同名的类:</p><pre class="km kn ko kp gt nt no nu nv aw nw bi"><span id="d0d7" class="nx ld iq no b gy ny nz l oa ob">import Foundation<br/>import Combine<br/><br/>public class ClockService {<br/><br/>    // subject to subscribe for updates<br/>    public var currentTime = PassthroughSubject&lt;String, Never&gt;()<br/><br/>    public init() {}<br/><br/>    public func updateTime() {<br/>        let formatter = DateFormatter()<br/>        formatter.timeStyle = .full<br/>        currentTime.send(formatter.string(from: Date()))<br/>    }<br/>}</span></pre><p id="c0ff" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如前面的教程中所解释的，将<code class="fe nl nm nn no b">ClockUI</code>作为依赖项添加到包清单中的<code class="fe nl nm nn no b">ClockUI_macOS</code>和<code class="fe nl nm nn no b">ClockUI_iOS</code>库中。</p><p id="41fb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">实现逻辑的快速总结:</p><ol class=""><li id="b87b" class="mf mg iq jp b jq jr ju jv jy mh kc mi kg mj kk mk ml mm mn bi translated">我们的服务可以负责“更新”时间</li><li id="15df" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated">我们使用<code class="fe nl nm nn no b">Combine</code>,因为它是一个现代的反应式框架，用于订阅时间变化和更新我们的UI</li></ol><p id="0787" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要在我们的视图控制器中使用服务，创建一个本地实例并订阅<code class="fe nl nm nn no b">currentTime</code>发布者。例如，这里的最终iOS视图控制器:</p><pre class="km kn ko kp gt nt no nu nv aw nw bi"><span id="a555" class="nx ld iq no b gy ny nz l oa ob">import UIKit<br/>import ClockUI<br/>import Combine<br/><br/>public class ClockViewController: UIViewController {<br/><br/>    // MARK: - Services<br/><br/>    private let service = ClockService()<br/>    private var timeCancellable: AnyCancellable!<br/><br/>    // MARK: - IB Outlets<br/><br/>    @IBOutlet weak var timeLabel: UILabel!<br/><br/>    // MARK: - IB Actions<br/><br/>    @IBAction func didTapFetchButtonAction() {<br/>        service.fetchTime()<br/>    }<br/><br/>    // MARK: - View Life Cycle<br/><br/>    public override func viewDidLoad() {<br/>        super.viewDidLoad()<br/>        timeCancellable = service.currentTime<br/>            .sink(receiveValue: { self.timeLabel.text = $0 })<br/>    }<br/><br/>    // MARK: - Nib Loading<br/><br/>    public static func loadFromNib() -&gt; ClockViewController {<br/>        // Load the compiled XIB = NIB file from the<br/>        // module resources bundle<br/>        ClockViewController(nibName: "ClockViewController_iOS", <br/>                            bundle: Bundle.module)<br/>    }<br/>}</span></pre><p id="fa54" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">运行这两个应用程序，瞧……你可以在每个应用程序中按下按钮时更新时间标签，它们以相同的方式运行！</p><p id="0a83" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可以在<a class="ae lb" href="https://github.com/philprime/ClockSPMSample" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>中找到完整的代码。</p><h1 id="b131" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">结论</h1><p id="c861" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">我们做到了。我们使用具有相同UI逻辑的不兼容接口构建器创建了两个应用程序。</p><p id="a502" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你还在疑惑，为什么要经历将项目分割成如此分散的包的麻烦，让我进一步解释一下:</p><ul class=""><li id="89af" class="mf mg iq jp b jq jr ju jv jy mh kc mi kg mj kk mu ml mm mn bi translated">假设您的应用程序达到了20、50、100甚至更多模块的大规模。使用这种高度模块化的结构，您可以轻松地创建另一个应用程序目标(类似于我们为macOS &amp; iOS所做的)，并简单地导入您正在处理的特定功能。</li><li id="fa5b" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mu ml mm mn bi translated">构建过程应该变得更有性能，因为未更改的包被缓存了(<em class="mt">不幸的是，我现在没有任何可用的统计数据来证明这一点)</em></li><li id="79ac" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mu ml mm mn bi translated">由于Swift包的内置隔离，我们有一个强大的<a class="ae lb" href="https://en.wikipedia.org/wiki/Separation_of_concerns" rel="noopener ugc nofollow" target="_blank">关注点分离</a>，并且可以单独使用我们代码的一个小的子集(例如，用他们自己的单元测试创建共享的实用程序)</li><li id="e1da" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mu ml mm mn bi translated">创建一个干净的架构变得更加容易，比如VIPER，其中UI呈现(视图)和逻辑(呈现者)是使用协议/接口完全抽象的。</li></ul><p id="9191" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你想了解更多，请查看我的其他文章，在<a class="ae lb" href="https://twitter.com/philprimes" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上关注我，并随时给我发短信。你有具体的话题想让我介绍吗？让我知道！😃</p></div></div>    
</body>
</html>