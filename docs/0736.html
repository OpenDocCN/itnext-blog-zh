<html>
<head>
<title>The Perils of Using a Common Redux Anti-Pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用通用Redux反模式的危险</h1>
<blockquote>原文：<a href="https://itnext.io/the-perils-of-using-a-common-redux-anti-pattern-344d778e59da?source=collection_archive---------3-----------------------#2018-05-17">https://itnext.io/the-perils-of-using-a-common-redux-anti-pattern-344d778e59da?source=collection_archive---------3-----------------------#2018-05-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/7dbdd86c7cadf6767c6c234d48424eae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*juZZe0SbI8E_QPd74Ax9uA.jpeg"/></div></div></figure><p id="3f3e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这篇文章中，我将分享与Redux相关的最常见的陷阱之一，以及如何最好地识别和避免它。避免这个常见的陷阱将有助于您更快地生成复杂的、可维护的应用程序。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="ee18" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">视图、动作创建者、缩减者</h1><p id="249c" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">这是Redux最常见的错误之一，尤其是在您刚刚起步的时候。模式是每个容器/视图都有一个相应的动作和缩减器。例如，请看下面的文件夹结构示例:</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="99f8" class="mp le iq ml b gy mq mr l ms mt">src<br/>|--Containers<br/>    |--CartContainer.js<br/>|--actions<br/>    |--cart.js<br/>|--reducers<br/>    |--cart.js</span></pre><p id="7e10" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这个例子中，视图/容器有一组相应的动作和一个缩减器。开发人员真正做的是将视图层绑定到应用程序状态。Redux的整个要点是创建一个应用状态<em class="mu">从视图层中分离出来，你可以在需要的时候访问它。</em></p><h2 id="95a7" class="mp le iq bd lf mv mw dn lj mx my dp ln kj mz na lr kn nb nc lv kr nd ne lz nf bi translated">为什么会这样？</h2><p id="de63" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">我认为发生这种情况的一个重要原因是Redux文档。老实说，我并不想批评这些文档，因为它们是我所见过的最好的开源库；然而，文档中的例子引出了一个思路，这个思路对于现实世界的应用程序来说可能是灾难性的。文档中有两个例子，一个todo列表应用程序和一个Reddit应用程序。这些例子(和大多数例子一样)的问题是它们非常简单。只有一组动作和一个视图。然后，开发人员可以跨越(这不是一个大的跨越)视图需要一组相应的动作和一个缩减器。应用于真实世界应用程序的概念导致应用程序无法利用Redux的优势。</p><h2 id="e995" class="mp le iq bd lf mv mw dn lj mx my dp ln kj mz na lr kn nb nc lv kr nd ne lz nf bi translated">我怎么知道我什么时候陷入了这种模式？</h2><p id="f95f" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">有一些简单的模式会触发你。例如，在您看来，如果您看到:</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="fde7" class="mp le iq ml b gy mq mr l ms mt">// in your view<br/>import * as cartActions from '../actions/cart';</span></pre><p id="2733" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你应该看到这个，看到一面红旗。为什么在这个视图中需要所有的购物车操作？你要么没有反应过来思考，要么没有恰当地分割你的状态。试着重新思考你的行为以及它们是如何组织的。</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="5bf3" class="mp le iq ml b gy mq mr l ms mt">// in your action<br/>const actionTypes = {<br/> ADD_CART_ITEM: 'ADD_CART_ITEM',<br/>  REMOVE_CART_ITEM: 'REMOVE_CART_ITEM',<br/>  CLEAR_CART: 'CLEAR_CART'<br/>};<br/>export { actionTypes };</span><span id="ef40" class="mp le iq ml b gy ng mr l ms mt">// in your reducer<br/>import { actionTypes } from '../actions/cart;</span></pre><p id="1580" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里我们有一个减速器，它可以响应小车的所有动作。这也是另一个常见的误解。动作集不一定要有相应的缩减器，反之亦然。根据<a class="nh ni ep" href="https://medium.com/u/a3a8af6addc1?source=post_page-----344d778e59da--------------------------------" rel="noopener" target="_blank">丹·阿布拉莫夫</a>(消息来源<a class="ae nj" href="https://github.com/pitzcarraldo/reduxible/issues/8" rel="noopener ugc nofollow" target="_blank">https://github.com/pitzcarraldo/reduxible/issues/8</a>)的说明:</p><blockquote class="nk nl nm"><p id="feff" class="jy jz mu ka b kb kc kd ke kf kg kh ki nn kk kl km no ko kp kq np ks kt ku kv ij bi translated">Flux和Redux的重点是让人们很容易在不同的地方突然开始对相同的动作做出反应。你不知道你需要提前在不同的地方处理哪些动作。</p></blockquote><p id="832d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们希望确保我们的reducers是灵活的，能够响应来自许多不同动作创建者集合的动作。当项目的需求发生变化，并且你有了灵活的缩减器，这些变化将突然变得不那么令人畏惧。</p><p id="6e5d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Redux使用的一个常见中间件是redux-thunk。如果你正在使用thunk，并且发现自己经常使用<code class="fe nq nr ns ml b">getState</code>,你可能需要重新考虑你的行为。例如:</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="c370" class="mp le iq ml b gy mq mr l ms mt">const myAction = () =&gt; (dispatch, getState) =&gt; {<br/> const { cart: { cartItems } } = getState();<br/>}</span></pre><p id="3c8b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有时，您的操作确实需要了解您的应用程序状态。例如，如果您需要状态的一部分来发出API请求。然而，以我的经验来看，大多数时候动作要么是为你的reducer计算一个要处理的新状态，要么是你的状态对象没有被正确分割。记住，计算一个新的状态是<strong class="ka ir">减速器</strong>的工作。<strong class="ka ir">动作</strong>应该只提供减速器工作所需的信息。肥胖行为可能是另一个潜在的危险信号。</p><p id="990f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意这些警告信号，并在看到它们的时候采取适当的措施，这将大大有助于确保您的视图和措施不会过多地了解您的应用程序状态。</p><p id="d145" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> <em class="mu">边注:</em> </strong> <em class="mu">请不要曲解。我并不是说你不应该使用上面的模式。我想说的是，他们应该让你停下来想想你在做什么。评估你是否恰当地使用了Redux。</em></p><h2 id="f6b6" class="mp le iq bd lf mv mw dn lj mx my dp ln kj mz na lr kn nb nc lv kr nd ne lz nf bi translated">这会导致什么？</h2><p id="59aa" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">总之，这种模式导致了紧密耦合的UI和应用程序状态。你可以很快进入这样的模式:</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="7df6" class="mp le iq ml b gy mq mr l ms mt">export const cartReducer = (state={}, action) =&gt; {<br/>  switch (action.type) {<br/>    case 'ADD_TO_CART':<br/>    case 'REMOVE_FROM_CART':<br/>    case 'CLEAR_CART':<br/>     return {...state, ...action.payload}<br/>    default:<br/>     return state;<br/>  }<br/>}</span></pre><p id="2415" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这种情况下，我们的动作知道状态对象的一切，因为它们就像设置器一样。我们的观点支配着我们的行动，因此我们的<strong class="ka ir"> <em class="mu">观点必然知道我们状态</em> </strong>的一切。所以让我为您节省一些时间，去掉Redux，只使用<em class="mu"> setState </em>，因为您已经在做了，尽管有很多样板文件。</p><p id="d11f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Redux文档中的注释:</p><blockquote class="nk nl nm"><p id="3c04" class="jy jz mu ka b kb kc kd ke kf kg kh ki nn kk kl km no ko kp kq np ks kt ku kv ij bi translated"><strong class="ka ir"> Reducers </strong>指定应用程序的状态如何改变，以响应发送到商店的<a class="ae nj" href="https://redux.js.org/basics/actions" rel="noopener ugc nofollow" target="_blank">动作</a>。记住动作只描述了<em class="iq">发生了什么</em>，而没有描述应用程序的状态如何变化。</p></blockquote><p id="d478" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以，这些文档都很棒，但是你必须记住这些文档中的例子是什么，简单的例子。</p><h2 id="6f08" class="mp le iq bd lf mv mw dn lj mx my dp ln kj mz na lr kn nb nc lv kr nd ne lz nf bi translated">如何避免这种模式？</h2><p id="b60e" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">同样，要想在React中成功使用React，您也必须开始考虑应用程序状态，以便在Redux中成功使用。这意味着从一开始就要考虑整个应用程序的状态。<strong class="ka ir">超时。</strong>理论上，这听起来不错，但在实践中，需求会发生变化，应用程序会增长，而且有些场景是人类无法100%计划的。那么如何避免这种模式呢？有几件事会有很大帮助:</p><ol class=""><li id="733a" class="nt nu iq ka b kb kc kf kg kj nv kn nw kr nx kv ny nz oa ob bi translated">正常化你的状态。去掉重复数据有助于保持应用程序的灵活性。</li><li id="6e4e" class="nt nu iq ka b kb oc kf od kj oe kn of kr og kv ny nz oa ob bi translated">保持你的状态浅。例如，对于一个电子商务应用程序，除了优惠券代码之外，不要使用带有cartItems的cart reducer，而是使用cartItems reducer来管理应用程序状态的这一部分，使用couponCodes reducer来管理状态的这一部分。</li><li id="206c" class="nt nu iq ka b kb oc kf od kj oe kn of kr og kv ny nz oa ob bi translated">用Redux思考。请记住，Redux是一个强大的工具，可以让您在需要时访问应用程序状态的任何部分。不要认为我的CartContainer只能从状态的cart部分访问动作和状态。保持事情更加灵活。恰当地命名应用程序状态的片段非常重要，可以提醒自己Redux允许您随时随地访问该状态的任何部分。</li><li id="9ffe" class="nt nu iq ka b kb oc kf od kj oe kn of kr og kv ny nz oa ob bi translated">阅读Redux文档(包括常见问题)。我怎么强调这些文件都不为过。问题是你不能只是浏览它们，你实际上必须阅读它们来理解用Redux创建一个应用程序的微妙之处。</li></ol><h2 id="445b" class="mp le iq bd lf mv mw dn lj mx my dp ln kj mz na lr kn nb nc lv kr nd ne lz nf bi translated">结论</h2><p id="9a66" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">这种模式的一个大问题是，在它成为一个大问题之前，你实际上可以使用它并利用它构建很多东西。当需求发生变化，应用程序突然需要分派动作并对打破这种模式的状态片段做出响应时，这种模式会让您的生产率嘎然而止。这就是这种模式如此危险的原因。重要的是要认识到与这种模式相关的危险信号，以免它变成一项令人生畏的任务，重新设计您的应用程序状态。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><p id="9bcf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">无论您是刚刚开始使用Redux，还是经验丰富的Redux开发人员，我希望这篇文章能够帮助您避免我在许多代码库中看到的一个常见问题(我对自己感到内疚😞).我总是喜欢听到对我工作的反馈。如果你有任何问题，请告诉我，我很乐意帮忙。感谢阅读。</p></div></div>    
</body>
</html>