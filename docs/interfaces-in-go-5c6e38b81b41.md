# Go 界面

> 原文：<https://itnext.io/interfaces-in-go-5c6e38b81b41?source=collection_archive---------1----------------------->

## 让我们剖析接口，成为交易高手

![](img/93e68b41a76d77885d411dbda884f163.png)

[丹尼尔·麦卡洛](https://unsplash.com/@d_mccullough?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)在 [Unsplash](https://unsplash.com/s/photos/blueprint?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上拍照

我觉得有必要写一篇关于接口的文章，因为它是 Go 中最让我惊讶的特性之一。我不想说谎，我花了一段时间来适应使用它们，但当我通过学习门槛时，我开始喜欢它们。

这并不是说界面很难或者很复杂，而是学习使用它们的习惯和思维方式似乎让很多人感到困惑。在这篇文章中，我将尝试使用大量的例子，这样我们不仅可以学习如何使用它们，还可以学习何时使用它们。

## 国际——现在怎么办？

让我们从头开始，在继续之前回顾一下基础知识。

接口是方法接收者的**集合。这意味着我们定义了一个规则，任何描述了所有方法的类型都是接口的一部分。提醒人们什么是**方法接收器**也是值得的。当我们将一个方法应用于一个类型时。下面的要点显示了一个例子，这适用于指针和非指针。**

方法接收器举例说明，[在这里试试](https://play.golang.org/p/H4RJa8HEHG7)

声明一个接口只是创建了一个蓝图，告诉我们需要什么方法来成为它的一部分。你不需要描述每个方法做什么，只需要描述它们将如何表现。您声明任何具有输出字符串的名为`String()`的方法的类型都是`Stringer`接口的一部分。但是输出什么字符串的实际实现取决于开发人员。如果使用得当，这将变得非常强大，因为我们可以编写一个接受特定接口的函数，而不是重写许多不同的函数。

如果一个类型在接口中有所有描述的方法，**它自动被认为是接口的一部分，不需要定义它！**

标准库定义了一些可用的接口。我们用其中的一个例子来更好的理解。我们将看看`Error`界面**。如果你从来不知道这个错误是一个接口，不要感到羞愧，我花了很长时间才意识到。**

```
type error interface {
  Error() string
}
```

对于 error，标准库声明**任何具有名为 Error** 的方法、没有输入参数、输出字符串的类型都是 Error 接口的一部分。这意味着如果我们实现了`Error() string`方法，我们可以让我们的任何结构像一个错误一样工作。如果我们想要扩展在错误中发送的信息，这可能是有用的。当人们想要在 HTTP 等中的错误中添加额外的信息时，我经常看到这样做。

在同一个 PrintError 方法中使用 DateError 和 regular error 的展示，[在这里试试](https://play.golang.org/p/VDA22pEqBMk)

在要点中，我创建了一个`DateError`类型，这是一个非常简单的结构，在调用`Error()`方法时会附加当前日期。这个`DateError`可以作为一个`error`传入传出函数，因为它有 Error()字符串方法，使它成为错误接口的一部分。

我想是时候提一下在定义**方法接收方**时**指针**和**非指针**之间的区别了。当声明方法时，我们必须声明它是用于常规结构还是仅仅指向它们的指针将接收该方法。如果我们将`Error`方法更新为只应用于指针，我们应该会看到构建失败。

更新了示例，用指针接收器代替。在这里尝试一下

```
./prog.go:32:12: cannot use de (type DateError) as type error in argument to PrintError:
	DateError does not implement error (Error method has pointer receiver)
```

这是一个常见的事情，我看到是错过了。所以重要的是要记住，你总是要考虑它是否应该适用于指针。通常，当您的方法将直接修改对象而不是返回值时，应该使用指针。它还可以用来避免传递对象的副本，以节省所使用的内存量。

需要记住的一点是，接口总是作为指针传递，即使你的结构不是。我将在一个例子中展示这一点，使它更清楚。

我已经修改了 NewError 来返回一个指针，它仍然可以工作。[试试这里](https://play.golang.org/p/G4w2qEcWpq8)

在上面的要点中，我修改了`NewError`来输出一个指向`DateError`的指针。它仍然可以工作，因为当把我们的`DateError`传递给`PrintError`时，它将作为一个指针被传递。接口总是作为指针传递。

## 为什么有用

当我开始使用 Go 的时候，我已经很长时间没有使用接口了，至少我没有意识到使用它们是一个错误。

自从学会更频繁地使用它们，我已经使我的代码更加模块化，更容易重构和简化测试。这就是为什么我觉得讨论它们为什么有用很重要。我将用例子来说明和加强我的论点。

我想说的第一点是**模块化**。我喜欢能够轻松地切换出我的代码片段。在较小的应用程序中，这通常不意味着大量的重构，但在大型项目中，这可能很苛刻，会破坏很多东西。

接口让我们跳过重构的痛苦，非常顺畅地交换业务逻辑。那么我们来看一个`UserDatabase`的例子。这里我们将创建一个处理用户的小界面。在展示期间，它将使用内存作为存储，并使用一个界面来展示我们如何在不破坏应用程序的情况下轻松替换它。这个例子是下面这个超级简单的命令行工具，它将打印出用户信息。在现实生活中，这可能是一个 HTTP API 等。

例子的基础，一个内存数据库。在这里试试吧。

我将使用上述要点作为我们重构的基础。我们将通过修改它并添加一个`UserDatabase`接口。这将允许我们在稍后阶段轻松地交换整个内存数据库，而不会中断依赖它的其他进程。首先，我们将实现接口，以及一个名为`API`的结构，它将保存一个`UserDatabase`。API 结构的要点是显示事物如何不中断，我们的示例将只打印到 stdout，但是在实际情况下，它可以是服务于 HTTP 端点的 API，或者任何东西。

当创建一个接口时，试着思考什么方法必须是它的一部分是一个好习惯，**有人曾经说过我的接口应该包含最多 5-6 个方法。**使用较小的接口要容易得多，如果它变得太大，就把它分成多个接口。

我们将需要`AddUser`和`GetUser`作为我们创建的界面。

下面的要点说明了我们如何使用一个接口来访问内存数据库。[试试这里](https://play.golang.org/p/pKIY_A3H-7r)

我们现在已经添加了一个 API 使用的接口。让我们试着用别的东西代替数据库，看看我们的例子变得多么模块化。
我将交换到的数据库是一个测试数据库，它总是返回错误，这是因为我想把你引入我的下一个论点，为什么要使用接口。

为了交换整个 API 的逻辑，我只需要将数据库字段更改为测试 DB。[试试这里](https://play.golang.org/p/CcujWp8nANf)

## 测试变得更加容易

接口的另一个真正好的部分是它们可以帮助测试。有些方法很容易测试，但有些方法很难测试，因为它们运行的方法依赖于其他方法和服务。这时接口可以帮助测试。我们可以用我们的结构来替换服务，在测试过程中我们需要它来表现。比方说，如果有一个 HTTP 处理程序，我们想要测试用户不存在时的行为，我们可以应用我们创建的`TestDatabase`。

## 干(不重复)

接口允许我们不重复代码。我们可以使用接口将多个结构传递给同一个函数，在这个函数中我们需要相同的行为。我有一个很好的例子，在我的一个数据处理项目中。

我正在构建一个[数据处理工具](https://github.com/percybolmer/workflow/)，它执行某些操作并在许多处理器之间传输数据，比如读取文件、解析 csv 或记录它。我通过在每个处理器之间传递一个常规的`[]byte`来开始这个项目。这被证明是行不通的，你看，我希望处理器是无缝的。传递一个`[]byte`需要下一个处理器知道如何将`[]byte`分解成可用的数据。

解决方案是接口。我创建了一个名为`Payload`的界面。Payload 是一个简单的接口，包含一个`GetPayload() []byte`方法。乍一看，这似乎没有任何帮助，但是它允许处理器无缝地传递数据，不管是 CsvPayload、JsonPayload 等等。

# 提示和技巧

文章的这一部分将介绍一些可以用于接口的技巧和窍门。我将从最常见的技巧开始，空界面。

## 空界面

在我看来，就界面而言，空界面是迄今为止最强大的工具。那是什么呢？**这是一个接口，应用了 0 个方法，使每个类型都成为它的一部分。**这允许你发送**任何类型到一个方法中。**

这在 Go 代码库中很常见。一个例子是当我们解组 JSON 时。如果我们看一下 [JSON。解组，](https://golang.org/pkg/encoding/json/#Unmarshal)你可以看到它是一个如下定义的方法。

```
func Unmarshal(data [][byte](https://golang.org/pkg/builtin/#byte), v interface{}) [error](https://golang.org/pkg/builtin/#error)
```

看到**界面了吗？这就是你如何使用一个空的界面。我们在那里做的是说“任何有这 0 个方法的类型都可以被传入”。**

这意味着我们可以将任何类型的数据传递给这个方法。

空接口的用途示例。[试试这里](https://play.golang.org/p/92sg7JkPmk1)

在工作和使用空界面时要记住的一件事是

> 能力越大，责任越大

仅仅因为一个方法可以接受每一种类型，并不意味着它可以正确地处理任何类型。

## 类型断言

您可以在接口上执行类型断言。当您希望一个函数接受两种类型的数据，但仍然希望根据输入来区分所做的事情时，这很有用。一个例子是我前面提到的数据处理工具，一些处理器需要网络负载。在那里，我必须接受 payload 接口，因为它有助于框架标准化，但我仍然需要验证正确的输入类型。

所以我的框架将使用`Payload`作为输入(这是一个接口)，但是这些特定的处理器需要将有效载荷转换成`NetworkPayloads`。此时，您可以使用类似下面要点的类型断言。

在网络有效负载中键入断言有效负载。

注意`pay.(*NetworkPayload)`，这就是 Go 中类型断言的样子。

`YourType.(WantedType)`

类型断言将返回两件事，一个是所需类型的类型，另一个是指示是否可以成功转换类型的布尔值。

当您需要访问接口本身没有公开的底层数据时，这非常有用。参见类型切换中的下一个例子我如何使用结果。名称来访问未由空接口公开的数据字段。

## 类型转换

因此，也许我们希望有一个方法，它接受一个空接口，但根据它的类型来决定采用哪种方法。您可以使用类型断言来转换类型，但是类型切换允许您测试多种类型。

它通常用于避免重复代码，比如你的应用程序应该记录不同的事件。我们可以编写一个标准化的日志方法，它接受任何类型，并根据类型进行不同的日志记录。

如何使用类型开关的示例。[试试这里](https://play.golang.org/p/AWQ3BRBweo3)

## 嵌入接口

在 Go 中，你也可以将接口嵌入到其他接口或结构中。将一个接口嵌入另一个接口意味着嵌入另一个接口的接口也需要继承的方法。举个例子可能更简单。我将在我们之前创建的`UserDatabase`界面上展示这一点。嵌入背后的原因(至少对我来说)是我们可以保持代码更简单，同样，模块化。想象一下，我们现在也想通过电子邮件获取用户，所以我们需要添加。

```
type UserDatabase interface {
 GetUser(username string) (*User, error)
 GetUser(email string) (*User, error)
 AddUser(username, email string) error
}
```

现在我们有两个方法做同样的事情，但是在实际应用中，可能会更多。让我们把它分解成自己的接口并嵌入其中。

警告，打起精神，大要点来了。

一个我们现在如何嵌入 UserRetriever 接口的例子。[试试这里](https://play.golang.org/p/Rky8g73GxYa)

不得不提，但是不喜欢。将接口嵌入结构是可能的，但是我不得不**警告**你，这很容易出错。

我将举一个简短的例子，向你们展示它是如何工作的，以及它的危险性。将接口嵌入到结构中会告诉编译器，是的，这个类型满足接口**。即使没有**

要点显示嵌入有多危险。[试试这里](https://play.golang.org/p/2yQ0zP3VUft)

尝试取消操场上第 20 行的注释，看看会发生什么。它会编译，但是由于`User`结构不是`Printer`，它会死机。

可悲的是，我们已经到达了旅程的终点。希望你已经学到了更多关于接口的知识。如果你有什么想讨论的，或者想让我写的，一定要联系我。
如果您想要一些额外的练习，我建议以内存数据库为例，尝试用 PostgreSQL 数据库来代替它进行测试。那可能会是一次很好的训练。
您可以轻松设置 PostgreSQL 以在 Docker 开发中使用，请阅读我关于 Docker 的文章。

[](https://programmingpercy.tech/blog/learn-docker-basics/) [## 学习 Docker 的基础知识

### 大约两年前，我开始听到越来越多关于 Docker 的消息。最终，我…

编程 percy.tech](https://programmingpercy.tech/blog/learn-docker-basics/)