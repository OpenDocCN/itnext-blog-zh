<html>
<head>
<title>Timber: Enhancing your logging experience</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">木材:增强您的伐木体验</h1>
<blockquote>原文：<a href="https://itnext.io/timber-enhancing-your-logging-experience-330e8af97341?source=collection_archive---------0-----------------------#2017-06-12">https://itnext.io/timber-enhancing-your-logging-experience-330e8af97341?source=collection_archive---------0-----------------------#2017-06-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="9ad5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们都听说过日志，知道如何使用它们；我们经常这样做。我们喜欢时不时地使用日志，我们使用日志进行api响应、异常、简单的<em class="kl">if else</em>debug；为了一切。但是，这里是交易:我们应该继续这样做吗？我的意思是，当我们要发布我们的应用程序时，我们必须检查所有的项目，寻找每一个日志，该死的那些日志很难找到！</p><p id="9abd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">假设我们有几个日志，我们想在发布应用程序时使用它们，我们该怎么做呢？当然我们可以用我们的IDE找到所有的<em class="kl">日志</em> <strong class="jp ir"> <em class="kl">。* </em> </strong>行，但最终我们会以过多的行而告终。当发现数百行时，我们将做什么？一个一个删除？评论他们所有人？在我们发布应用程序后，我们想再次检索所有日志，我们该怎么办？我们会删除所有行，编译项目，然后进行git检验吗？听起来有点蹩脚，不是吗？</p><p id="c18f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一个人可以说<em class="kl">“我有解决方案！让我们创建自己的日志方法，并检查它是否是一个调试版本；如果是，我们记录，否则我们不记录！”。</em></p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="kr ks l"/></div></figure><p id="4a89" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">嗯…它会工作，但是如果我们想要记录不同的优先级，我们将不得不创建多个方法或者添加优先级作为参数，这样我们就可以使用正确的日志。</p><p id="ef93" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">尽管我们可以编造出一个像样的解决方案，但我们都知道我们不应该重新发明轮子，而且，正如你可能知道的那样:有一个更简单——可能更好——的解决方案；遇见<a class="ae kt" href="https://github.com/JakeWharton/timber" rel="noopener ugc nofollow" target="_blank">木材</a>。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi ku"><img src="../Images/0a43a48bfeb526f05cfd406c2acb7929.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Kjvk4MvFrv52asXp."/></div></div></figure><p id="3196" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> Timber </strong>是——很少的词Android的<em class="kl"> Log </em>类的API。它基本上增强了来自Android的日志。我们通过种植一棵<strong class="jp ir">树</strong>来做到这一点，并且每次我们记录一些东西时，行为可能会根据哪棵<strong class="jp ir">树</strong>实现最终被调用而改变。</p><h1 id="fcf2" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">[计] 下载</h1><pre class="km kn ko kp gt lz ma mb mc aw md bi"><span id="ac83" class="me lc iq ma b gy mf mg l mh mi">compile 'com.jakewharton.timber:timber:4.5.1'</span></pre><h1 id="1e2d" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">它是如何工作的</h1><p id="3042" class="pw-post-body-paragraph jn jo iq jp b jq mj js jt ju mk jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">1—创建一个<strong class="jp ir">树</strong>实例并尽快种植。(尽快通常意味着我们应该将它添加到<em class="kl"> onCreate </em>中的<em class="kl">应用程序类</em></p><p id="1a06" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2 —使用<strong class="jp ir">木材</strong>的<strong class="jp ir"> </strong>调用而不是<em class="kl">日志开始记录。</em></p><p id="6d5a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">3 —就这样，我们准备好了。</p><p id="8e77" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">说真的，就是这么难。</p><p id="3d1a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不管有多难，我不会只写这三个步骤。让我们更多地了解一下<strong class="jp ir">木材</strong>是如何工作的，以及我们可以用它来做什么。</p><h1 id="1132" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">木材类伐木</h1><p id="e27d" class="pw-post-body-paragraph jn jo iq jp b jq mj js jt ju mk jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">在我们设置好我们的<strong class="jp ir">树</strong>之后，我们应该使用<strong class="jp ir">木材</strong>类开始伐木，这真的很简单。它包含与<em class="kl">日志</em>类相同的日志方法，例如:<em class="kl">。五、。d，。我，。w </em>和<em class="kl">。e </em>。因为它们是相似的，如果我们正在开发一个项目，现在我们想使用<strong class="jp ir">木材</strong>库，我们可以简单地替换所有的<em class="kl">日志</em>。<em class="kl"> </em>谓为<em class="kl"> </em> <strong class="jp ir">木材<em class="kl">。</em> * </strong>来电；但这并不特别，不是吗？</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="kr ks l"/></div></figure><p id="1797" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意到<strong class="jp ir">木材</strong>的叫声不具备<em class="kl">标记</em>吗？那是因为<strong class="jp ir"> Timber </strong>会找出它被调用的是哪个类，并且会添加那个作为它的<em class="kl">标签。</em></p><p id="a095" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">同样，<strong class="jp ir">木材</strong>有<em class="kl">。搞什么鬼</em>著名的<em class="kl">搞什么鬼</em>..我是说，<em class="kl">多么可怕的失败</em>。与<em class="kl">错误</em>不同，顾名思义，它是一个最终可能会发生也可能不会发生的错误，如果是这样，我们知道如何处理它们并找出解决方法。<em class="kl"> WTF </em>通常是一个如此深刻和有问题的错误，我们没有办法从中恢复，通常<em class="kl"> WTF </em>应该——取决于我们的应用程序——<a class="ae kt" href="https://developer.android.com/reference/android/util/Log.html#wtf(java.lang.String,%20java.lang.String)" rel="noopener ugc nofollow" target="_blank">终止你的应用程序，并发送一个错误报告</a>或更重要的东西。</p><h2 id="5c23" class="me lc iq bd ld mo mp dn lh mq mr dp ll jy ms mt lp kc mu mv lt kg mw mx lx my bi translated">Lint规则</h2><p id="b305" class="pw-post-body-paragraph jn jo iq jp b jq mj js jt ju mk jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">木材有一些非常方便的规则。它们分为两组:<em class="kl">错误</em>和<em class="kl">警告</em>。正如你可能想象的那样，<em class="kl">错误</em>使我们的应用程序无法编译，而<em class="kl">警告</em>可以，正如它所说；显示警告，但允许我们的应用程序编译。<br/>如果我们提供了错误数量的参数，在使用字符串插值时使用了不同类型的参数，或者标签的大小超过了<a class="ae kt" href="http://stackoverflow.com/a/28168739/3506842" rel="noopener ugc nofollow" target="_blank"> Android的最大长度</a>，则会触发<em class="kl">错误</em>规则。<br/>如果我们使用<em class="kl"> Log </em>类来记录，一个<em class="kl"> String.format </em>或<em class="kl"> concat </em>或<em class="kl"> Strings </em>在一个<strong class="jp ir"> Timber </strong>调用或记录一个<em class="kl">异常</em>时，会触发一个<em class="kl">警告</em>规则。你可以在这里查看更多规则。</p><h1 id="7708" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">种植我们自己的树</h1><p id="c37c" class="pw-post-body-paragraph jn jo iq jp b jq mj js jt ju mk jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">正如在<em class="kl">步骤1 </em>中所说，我们应该创建一个<strong class="jp ir">树</strong>和<em class="kl">植物</em>的实例，但是，它是什么呢？一个<strong class="jp ir">树</strong>基本上是一个包含我们日志行为的类。要实例化它，我们必须<em class="kl">扩展</em>一个<strong class="jp ir">树</strong>类<em class="kl">并实现log <em class="kl">方法</em>。每次我们使用<strong class="jp ir">木材</strong>伐木时，它都会经过我们实例化的<strong class="jp ir">树</strong>——如果我们种植了多棵<strong class="jp ir">树</strong>，它会经过所有这些树——并且会按照我们想要的方式行动。<br/>例如，假设我们发布应用程序时不想记录任何内容，我们该怎么办？首先，我们创建一个<strong class="jp ir">树</strong>，它在log方法中不做任何事情。</em></p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="kr ks l"/></div></figure><p id="172c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后我们<em class="kl">将</em>植入到<em class="kl"> onCreate </em>方法内的应用程序类中:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="kr ks l"/></div></figure><p id="8a0e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">说完后，没有<strong class="jp ir">木材。* </strong>会记录一些东西，但我们希望只有在发布我们的应用程序时才这样做；为此，我们可以简单地添加一个<em class="kl"> if。</em></p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="kr ks l"/></div></figure><p id="65ec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以走了！来测试一下吧！</p><p id="7634" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你测试我们的应用程序，你会注意到它不会记录任何东西。发生了什么事？嗯，我们用的是<strong class="jp ir">木材。* </strong>当我们没有为调试app种植的<strong class="jp ir">树</strong> <em class="kl">！太可惜了！尽管我们的应用程序发布时工作正常，但在调试时，我们的应用程序没有<strong class="jp ir">树</strong>。我们如何解决这个问题？我必须创建一个<strong class="jp ir">树</strong>仅仅是为了调试的目的吗？嗯… <em class="kl">有点儿的；</em>你不必创建一个，但你必须<em class="kl">种植</em>一个。<br/> <strong class="jp ir">木材</strong>船带着<strong class="jp ir">树</strong>准备调试！认识一下<strong class="jp ir">调试树</strong>。简单的<em class="kl">植物</em>它和我们的应用程序将完美地工作。</em></p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="kr ks l"/></div></figure><p id="1aae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果是<em class="kl">调试app </em>，它会使用<strong class="jp ir">调试树</strong>如果是<em class="kl">发布app </em>，它会使用<strong class="jp ir">非日志树</strong>。我们不仅修复了我们的应用程序，还摆脱了那个讨厌的<em class="kl">，如果不是</em>。但是，嘿，因为我们没有用我们发布的应用程序登录，如果出了问题；我们要做什么？我们把我们的<em class="kl">错误</em>和<em class="kl">警告</em>发送到我们的<em class="kl">崩溃库</em>怎么样？听起来很棒，不是吗？<br/>嗯，那真的很简单！只需抓取您的自定义<strong class="jp ir">树</strong>并添加一个<em class="kl">行为</em>，这样当您记录一个<em class="kl">错误</em>或<em class="kl">警告</em>时，它就会调用您的<em class="kl">崩溃库</em>！</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="kr ks l"/></div></figure><p id="0f8c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就是这样。当应用发布时，<em class="kl">错误</em>和<em class="kl">警告</em>将被发送到我们的<em class="kl">崩溃库</em>，其他所有日志级别将被忽略。当我们发布我们的应用程序时，我们不再需要继续搜索和删除——或评论——日志行。</p><p id="f2f2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是你知道吗？我不喜欢那个<strong class="jp ir"> <em class="kl"> if (BuildConfig。</em>调试)</strong>。你看，这是一种<strong class="jp ir"> <em class="kl"> if production </em> </strong>听起来很奇怪，幸运的是我们可以解决这个问题——可能还有许多其他问题——只需为不同的<em class="kl">构建变体</em>创建类。不知道该怎么做？别担心，我会掩护你的。</p><h1 id="d4e3" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用构建变体</h1><p id="88f4" class="pw-post-body-paragraph jn jo iq jp b jq mj js jt ju mk jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">首先，让我们创建一个类来处理<strong class="jp ir"> Timber </strong>实现，这样我们就可以从我们的<em class="kl">应用程序</em>类中移除逻辑。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="kr ks l"/></div></figure><p id="18df" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，我们仍然拥有这个<em class="kl">如果否则</em>我说过我们将放弃它，因为我们必须在同一个<em class="kl">包</em>中创建两次<em class="kl">TimberLogImplementation</em>类。你没听错:<em class="kl">两次</em>。</p><p id="9f5d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为此，我们必须在<em class="kl"> src </em>中创建两个目录:<em class="kl">发布</em>和<em class="kl">调试</em>。在这个目录中，我们简单地创建另一个名为<em class="kl"> java </em>的目录，并正常地创建<em class="kl">包</em>，就像我们在<em class="kl">主</em>目录中所做的一样。使用<em class="kl">项目</em>视图，我们的目录应该看起来像这样:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi mz"><img src="../Images/4f50115734034bba82754e69cf07eb84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VQoZeGJgaXOHw53mtQVHAQ.png"/></div></div></figure><p id="a94a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦你创建了它，根据你的<em class="kl">构建变体</em>，IDE将编译其中一个目录。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi na"><img src="../Images/f0ee795815dac6fd3a57726e7e986e1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1328/format:webp/1*DodgcXgZbh_5oIhKRncjWw.png"/></div></figure><p id="019d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">创建好这个之后，我们重构我们的<em class="kl">TimberLogImplementation</em>类，这个<em class="kl"> release </em>类应该只有<em class="kl"> release </em>实现。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="kr ks l"/></div></figure><p id="1046" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">而我们的<em class="kl"> debug </em>类将只有<em class="kl"> debug </em>实现——你猜对了。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="kr ks l"/></div></figure><p id="380d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">搞定了。现在，当您将<em class="kl">构建变体</em>更改为<em class="kl">调试</em>时，它将编译<code class="fe nb nc nd ma b">debug/java/.../TimberLogImplementation </code>，当您更改为<em class="kl">版本</em>时，它将编译<code class="fe nb nc nd ma b">release/java/.../TimberLogImplementation</code>。没有更多的讨厌的<strong class="jp ir">如果生产</strong>，一切都很棒！但是等等，还有更多！我还有最后一笔奖金！</p><p id="1012" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">比方说，我们希望在调试中获得更多信息，例如日志的类和行。通常我们会简单地在消息中添加这些，像<code class="fe nb nc nd ma b">Timber.i("MyClass:13-Something happen here!")</code>但是有一个问题——实际上很多，但是让我们保持简单——如果我们添加更多的代码，日志<em class="kl">的行</em>可能会不一样，我们可以在一些<em class="kl">复制&amp;粘贴</em>之间添加错误的类，等等。幸运的是，我们可以简单地做到以下几点。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="kr ks l"/></div></figure><p id="3863" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们正在截取我们的<em class="kl"> DebugTree </em>的日志，添加在开头的<em class="kl">类</em>名称和行号！</p><p id="72f7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你想要一个有木材的项目，你可以检查这个项目<a class="ae kt" href="https://github.com/caueferreira/timber-example" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir"/></a>我已经添加到我的Github。</p><p id="ec20" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我希望你喜欢这篇小文章，我很快会带着更多的东西回来。从现在开始，我希望你在你的项目中总是使用<strong class="jp ir">木材</strong>！</p><p id="3bd9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">保持牛逼:)</p></div></div>    
</body>
</html>