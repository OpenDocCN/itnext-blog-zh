<html>
<head>
<title>Power-efficiency for performance-deficiency</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">针对性能不足的能效</h1>
<blockquote>原文：<a href="https://itnext.io/power-efficiency-for-performance-deficiency-a1ef79d1379b?source=collection_archive---------4-----------------------#2018-10-25">https://itnext.io/power-efficiency-for-performance-deficiency-a1ef79d1379b?source=collection_archive---------4-----------------------#2018-10-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="5ee9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">TL；博士</strong> : CPU节能模式是邪恶的，你应该立即禁用它们(如果你关心性能和延迟的话)。</p></div><div class="ab cl kl km hu kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="ij ik il im in"><p id="9057" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在过去的几个月中，我们的团队一直在调查我们的Kubernetes群集的性能问题，该群集运行在大约26台非常强大的工作服务器上(Dell PowerEdge C6420具有48个内核和192GB RAM)。</p><p id="ddf1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">与具有许多组件(即微服务)的大型分布式平台中的任何性能问题一样，精确描述它是一个相当大的挑战，并且症状不断变化，有时会将我们引向一个方向，然后引向一个完全不同的方向。</p><p id="a618" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们已经将症状缩小到以下几种:</p><ul class=""><li id="eff2" class="ks kt iq jp b jq jr ju jv jy ku kc kv kg kw kk kx ky kz la bi translated">不同节点上的应用程序请求处理时间不一致(抱歉，这里没有图表…你只能相信我的话)。</li><li id="9a35" class="ks kt iq jp b jq lb ju lc jy ld kc le kg lf kk kx ky kz la bi translated">运行在不同节点上的相同应用程序实例的不稳定的CPU使用数字，并为相同数量的请求提供服务(一些使用1个内核，其他使用3个内核)。</li></ul><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi lg"><img src="../Images/68cadb77dd80b1a9d21685ea38e309ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*InH9_p79TKYqXql2e5UZxg.png"/></div></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">为相同数量的请求提供服务的相同应用程序实例的cpu使用量(以核心为单位)</figcaption></figure><ul class=""><li id="6151" class="ks kt iq jp b jq jr ju jv jy ku kc kv kg kw kk kx ky kz la bi translated">通过观察平均负载(即load _ average &gt; count核心数)与大约50%的CPU使用率来衡量CPU饱和度。</li></ul><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi lw"><img src="../Images/f104a8802fbcddd25b7004c3ca224755.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KoY-QpgOQczTyxjv8QitgQ.png"/></div></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">load_avg1占可用内核的百分比(红线= 100%)</figcaption></figure></div><div class="ab cl kl km hu kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="ij ik il im in"><p id="109f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在高峰时段，我们的应用消耗我们集群中大约500个内核，从高水平CPU使用率百分比来看，这就是&lt;50% (not so scary), however the Load averages on these nodes would be close to saturation levels with spikes reaching 300%.</p><p id="fa31" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">We already disabled Hyper-Threading (and perhaps that should be a separate blog post) but we were still quite puzzled by the situation and it was just getting worse.</p></div><div class="ab cl kl km hu kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="ij ik il im in"><p id="6771" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">能效</strong>:现代服务器配备了先进的能效功能，旨在降低服务器的功耗和散热。</p><p id="69b2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这些机制的主要目的是动态控制提供给服务器各种耗电组件的电量，其中最大的用户当然是CPU。</p><p id="8e61" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所有这些模型的基础都是“按需功率扩展”的概念，即随着对CPU周期需求的减少，提供给CPU的功率将减少，反之亦然。</p></div><div class="ab cl kl km hu kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="ij ik il im in"><p id="1efa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在讨论电源效率和性能时，我将重点关注两个重要因素——由处理器<strong class="jp ir"> C状态</strong>控制的CPU空闲延迟，以及由处理器<strong class="jp ir"> P状态</strong>控制的CPU时钟频率。</p><p id="34fb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> C状态</strong> —这些是CPU运行状态(表示为C0、C1、C1E、C2等……)您可以将C0视为一个繁忙的CPU全速工作的状态&amp;，而C1则处于待机/空闲模式，CPU不执行任何活动，但准备切换到C0，几乎没有损失/延迟。</p><p id="de8a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">额外的级别(&gt; C1)是进一步的状态(通常称为“睡眠状态”)，其中CPU将实际关闭其电路的某些部分以减少功率使用，但是当它需要醒来并切换到C0状态时，代价是更高的等待时间。</p><p id="5eee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">结论:</strong>处于C-状态的处理器内核&gt; C1将有更长的时间在需要时唤醒，这<strong class="jp ir">将</strong>影响您的应用响应时间，如果您对延迟和延迟波动敏感，您应该将最大C-状态限制为C1(稍后将详细介绍)。</p><p id="5768" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> P状态</strong> —这些是额外的CPU控制状态，允许CPU降低其时钟频率，在我们的例子中，我们有一个2.1GHz(标称/基本频率)的48核CPU，它可以降低到每核1GHz和2.8GHz(采用睿频加速)。</p><p id="07db" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">结论:</strong>允许动态调整CPU时钟频率将根据CPU内核的整体负载相关指标不断调整有效的CPU时钟，调整是<strong class="jp ir">而不是</strong>实时完成的，因此当需求增加时，在CPU能够全速处理之前会有延迟，对于只使用一小部分CPU内核的应用线程而言？嗯……它可能被认为不够“重要”,不足以保证CPU核心频率的增加。</p></div><div class="ab cl kl km hu kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="ij ik il im in"><p id="8cf1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">记住上面描述的这些机制，考虑在48核服务器上运行的应用实例，该应用实例仅需要整体CPU能力的一小部分，并且其处理线程可能分布在多个CPU核上，从整体利用率的角度来看，这些核实际上可能未被充分利用，因此它们可能切换到更高的C状态和更低的P状态频率，然而我们可怜的“微服务”现在正在挣扎，它更慢并且工作更努力。 它的队列在增加，来自额外请求的反压力在堆积，这实际上导致它消耗更多的CPU。</p><p id="72c9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在检查了这些节能特性后，我们清楚地看到它们并不是性能友好的，因此我主要将应用延迟作为主要的KPI。</p></div><div class="ab cl kl km hu kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="ij ik il im in"><p id="3edc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">禁用C状态</strong></p><p id="1104" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">根据您选择的服务器硬件，您很可能会有一个BIOS选项来禁用C状态，但是在大多数情况下，这不会对您有任何好处，因为大多数现代Linux内核使用<em class="lx"> intel_idle </em>驱动程序来管理C状态转换，并且该驱动程序会忽略您在BIOS中设置的任何内容。</p><p id="ee3f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我如何知道我的Linux是否使用了<em class="lx"> intel_idle </em>？只需检查dmesg:</p><pre class="lh li lj lk gt ly lz ma mb aw mc bi"><span id="3d38" class="md me iq lz b gy mf mg l mh mi">$ dmesg | grep intel_idle<br/>[ 1.368796] intel_idle: MWAIT substates: 0x2020<br/>[ 1.368798] intel_idle: v0.4.1 model 0x55<br/>[ 1.372936] intel_idle: lapic_timer_reliable_states 0xffffffff</span></pre><p id="c471" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，我如何将<em class="lx"> intel_idle </em>带到C1？这部分实际上取决于您选择的Linux发行版，但是通常您需要在您的引导加载程序中添加两个内核参数:<strong class="jp ir"><em class="lx">processor . max _ cstate = 1 Intel _ idle . max _ cstate = 1</em></strong></p><p id="7217" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你使用CoreOS(像我们一样)，在<em class="lx"> /usr/share/oem/grub.cfg </em>中添加下面一行，然后重启:</p><pre class="lh li lj lk gt ly lz ma mb aw mc bi"><span id="e77c" class="md me iq lz b gy mf mg l mh mi">set linux_append="processor.max_cstate=1 intel_idle.max_cstate=1"</span></pre><p id="64ed" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在Debian上，将参数添加到<em class="lx"> /etc/default/grub </em>中的<em class="lx"> GRUB_CMDLINE_LINUX </em>变量，运行<em class="lx"> update-grub </em>，重启:</p><pre class="lh li lj lk gt ly lz ma mb aw mc bi"><span id="cdfb" class="md me iq lz b gy mf mg l mh mi">GRUB_CMDLINE_LINUX="processor.max_cstate=1 intel_idle.max_cstate=1"</span></pre><p id="1f6a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">重启后，您应该在<em class="lx"> dmesg </em>中看到以下内容:</p><pre class="lh li lj lk gt ly lz ma mb aw mc bi"><span id="4c7f" class="md me iq lz b gy mf mg l mh mi">[    3.240473] intel_idle: MWAIT substates: 0x2020<br/>[    3.240474] intel_idle: v0.4.1 model 0x55<br/><strong class="lz ir">[    3.240484] intel_idle: max_cstate 1 reached</strong><br/>[    3.246909] intel_idle: lapic_timer_reliable_states 0xffffffff</span></pre><p id="951d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">或者，读取<em class="lx"> max_cstate </em>的值:</p><pre class="lh li lj lk gt ly lz ma mb aw mc bi"><span id="61fa" class="md me iq lz b gy mf mg l mh mi">$ cat /sys/module/intel_idle/parameters/max_cstate<br/><strong class="lz ir">1</strong></span></pre></div><div class="ab cl kl km hu kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="ij ik il im in"><p id="2a28" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">禁用P状态</strong></p><p id="5354" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">实现这一点有不同的方法，在我们的例子中，我们简单地将服务器BIOS配置中的<strong class="jp ir"> <em class="lx">系统配置文件</em> </strong>切换为<strong class="jp ir"> <em class="lx">性能</em> </strong>。</p><p id="6ea1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">也有一些软件工具可以让你从操作系统内部进行管理，最常用的一个是<em class="lx"> cpufreq </em>(在Debian上，cpufrequtils的一部分)，它摒弃了传统的<em class="lx"> cpupower </em>实用程序。</p></div><div class="ab cl kl km hu kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="ij ik il im in"><p id="73ae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">结果… </strong></p><p id="04a7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我会让图表自己说话:)</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi mj"><img src="../Images/f02ebb8ab8c9e423f84cc9d6fc650276.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OvICHrbeXfvMvkK9qvf53A.png"/></div></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">为相同数量的请求提供服务的相同应用程序实例的cpu使用量(以核心为单位)</figcaption></figure><p id="5564" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">左边的第一个箭头表示所有服务器的C状态都达到C1状态，3台服务器仍然允许P状态转换，正如您所看到的，它们都做得更好，但是启用了P状态的服务器仍然显示出比其他服务器更高的CPU使用率。</p><p id="65bf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第二个箭头是当剩余的3个服务器禁用了P-States时，此时所有应用程序实例都显示出一致和统一的CPU使用情况，同时为相同数量的请求提供服务。</p><p id="b5e7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您会注意到，这个应用程序(它是我们最大的CPU消耗者)的整体CPU使用率现在显著降低了，我向您保证这是在相同的工作负载条件下。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi mk"><img src="../Images/9a2dbfb50114b6415df84a9889e1a887.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*erwLfN18HMFmZoOQ70G-Gw.png"/></div></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">应用程序平均请求处理时间</figcaption></figure><p id="959a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">应用延迟处理时间减少了约50%，从平均<strong class="jp ir">191毫秒</strong>下降到<strong class="jp ir">85毫秒</strong>，此外，当查看百分点时，我们看到. 9和. 99百分点有显著改善，离群值可以忽略不计。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi ml"><img src="../Images/16140f1862f9d733faf6dc50217bb37c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uaT49isvLQV0HRZRjSXp0w.png"/></div></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">集群范围的cpu使用率(核心数)</figcaption></figure><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi mm"><img src="../Images/554d06a62ac8958e3cfcd0e650ff7030.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r4ElXJ4aWgTZUduK2Fa5nA.png"/></div></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">跨所有工作节点的load_avg1(箭头指示C/P状态何时被禁用)</figcaption></figure><p id="fd5d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们集群范围内的CPU使用率和负载指标降低了约50%，这实际上降低了CPU温度，并且似乎略微降低了\_(ツ)_/的功耗</p><p id="207e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">CPU使用情况的最大影响是<em class="lx">系统</em>的利用率(减少了50–70%)，这似乎与处理传入请求的应用程序的总体压力释放相对应，并且它一直传播到同样“阻塞”的内核堆栈。</p></div><div class="ab cl kl km hu kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="ij ik il im in"><p id="3da8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">总结:</strong>能效/省电模式是一项有趣的技术，但在大多数情况下，它们会对应用性能产生严重的负面影响，尤其是在Kubernetes等分布式调度平台上部署微服务时。</p><p id="69d6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我提到Kubernetes(尽管我认为这同样适用于其他分布式平台)是因为工作负载的结构/打包和分布方式——我们应用程序的小部分跨多个计算元素进行部署和重新部署，每个部分(即Kubernetes行话中的Pod)不断移动(在内核之间， 节点之间),并且每个数据块仅限于计算节点整体可用容量的相对较小的一部分，如果它碰巧落在当前处于“睡眠”模式或刚刚降低其时钟频率的CPU核心上，它将受到影响。</p><p id="cf8c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这些技术考虑了一个非常宏观的指标，即CPU内核的总体负载量，当考虑到这些CPU内核上调度的不同工作负载类型和大小时，这并不是一个足够好的指标。</p><p id="6833" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">根据我们的经验，如上所述，在类似的工作负载条件下使用节能模式实际上会产生相反的效果:不节能(实际上还略高)和性能差。</p><p id="d28a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">谢谢收听！:)</strong></p><p id="aeb2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">另外，我还应该注意，现代服务器中还有其他形式的节能，如内存频率扩展、CPU非核心扩展(即降低CPU非核心功能的功耗)、电源和风扇动态控制等，您还应该检查这些对您的应用程序有何影响。</p></div></div>    
</body>
</html>