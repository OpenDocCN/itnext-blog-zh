<html>
<head>
<title>How to untar JSON files with plain native Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用plain native Node.js解包JSON文件</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-untar-json-files-with-plain-native-node-js-2536565707c9?source=collection_archive---------2-----------------------#2019-05-19">https://itnext.io/how-to-untar-json-files-with-plain-native-node-js-2536565707c9?source=collection_archive---------2-----------------------#2019-05-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="6dec" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">解压缩，分裂和解析tarball的内容，没有流，缓冲区，io或依赖。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/14f6723713c65624f66a9469822816dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DQZ1aHChuokubiAcS6TKjw.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated"><a class="ae le" href="https://dribbble.com/shots/6506572-Node-js-Decompression-Article-Cover-Artwork?utm_source=Clipboard_Shot&amp;utm_campaign=szanata&amp;utm_content=Node.js%20Decompression%20-%20Article%20Cover%20Artwork&amp;utm_medium=Social_Share" rel="noopener ugc nofollow" target="_blank">https://dribbble . com/shots/6506572-Node-js-解压-文章-封面-插图</a></figcaption></figure><p id="2c36" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们的故事从一些AWS Lambda和S3铲斗之间的集成开始。这个桶将接收JSON文件，该事件将触发一个lambda来处理该输入。问题？那些JSONs是真的tarballs。</p><p id="5d6b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">那交易是什么？</p><p id="0918" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">处理tarballs总是很糟糕，我讨厌必须创建流，我讨厌添加大量外部依赖来完成一个简单的任务，因为我们在一个具有受控IO的Lambda中，一个simple不能调用<code class="fe lf lg lh li b">tar</code>并将任务委托给操作系统。你几乎注定要使用数百个<strong class="js iu"> npm </strong>库中的一个，这些库最终会完成工作，但也会给你的lambda足迹增加<strong class="js iu"> 10k </strong>行代码。还是你？</p><p id="1ec2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你和我一样，经常使用AWS Lambdas，你就会知道部署一个小的源代码有多好，不仅可以使部署变得更快，还可以更容易地从AWS加载web UI，以便在需要时实时编辑/调试代码。</p><p id="b14a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">客观地说，最紧凑的lib to <em class="lj"> untar </em>文件会给我的lambda增加5k行代码，而我的实际代码只有不到50行。这是一个巨大的差异。</p><p id="f209" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">考虑到这一点，我激励自己实现自己的本机超紧凑解决方案，这有多难呢？</p></div><div class="ab cl lk ll hx lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="im in io ip iq"><p id="150f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，我花了一些时间去理解什么是tarball ( <code class="fe lf lg lh li b">.tar.gz</code>)文件。它实际上非常简单:将一堆文件打包成一个大文件，然后压缩成gzip。发现这一点后，我能够追踪我的使命:</p><ol class=""><li id="b159" class="lr ls it js b jt ju jx jy kb lt kf lu kj lv kn lw lx ly lz bi translated">解压文件。</li><li id="df1e" class="lr ls it js b jt ma jx mb kb mc kf md kj me kn lw lx ly lz bi translated">把他们分开。</li><li id="6af9" class="lr ls it js b jt ma jx mb kb mc kf md kj me kn lw lx ly lz bi translated">将它们解析为JSON。</li></ol><h1 id="00de" class="mf mg it bd mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc bi translated">1.解压文件。</h1><p id="42dd" class="pw-post-body-paragraph jq jr it js b jt nd jv jw jx ne jz ka kb nf kd ke kf ng kh ki kj nh kl km kn im bi translated">这一部分实际上非常简单，只需一行代码:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="8b5f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是因为node已经打包了<code class="fe lf lg lh li b">zlib</code>，它可以进行压缩/解压、充气/放气等操作。简单的东西。</p><h1 id="78c2" class="mf mg it bd mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc bi translated">2.把他们分开</h1><p id="4a67" class="pw-post-body-paragraph jq jr it js b jt nd jv jw jx ne jz ka kb nf kd ke kf ng kh ki kj nh kl km kn im bi translated">现在挑战开始了。tarball将原始文件的内容捆绑在同一个文件中，仅由一些控制字符和原始文件的元信息分隔。</p><p id="c490" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它们看起来像这样(<em class="lj">解压成一个字符串</em>):</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="9994" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">正如你所看到的，在每个文件内容之间有许多许多控制字符和一些元信息，如用户名<strong class="js iu"/>、<strong class="js iu">权限</strong>、原始<strong class="js iu">文件名</strong>等。认识到这一点后，我只需找到一个在每个文件内容之间只重复一次的字符序列，就可以将这些文件分开。</p><p id="5a46" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">经过仔细观察，我发现了<code class="fe lf lg lh li b">\0ustar</code>序列，它总是在用户名元信息之前。答对了。</p><p id="221b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们只需确保在将内容拆分成数组后忽略第一个位置(因为在第一个<code class="fe lf lg lh li b">\0ustar</code>之前没有内容)。</p><h1 id="1c6e" class="mf mg it bd mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc bi translated">3.将它们解析为JSON</h1><p id="3dcd" class="pw-post-body-paragraph jq jr it js b jt nd jv jw jx ne jz ka kb nf kd ke kf ng kh ki kj nh kl km kn im bi translated">现在，我们将文件的内容放在一个数组中，但是内容本身的前面和后面仍然是控制字符和元信息，我们必须在转换为JSON之前对它们进行修整。</p><p id="bcb9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">这是该解决方案开始被定制为仅处理JSON文件的地方。</strong>我们可以反过来，只检查第一次和最后一次出现的<code class="fe lf lg lh li b">{}</code>或<code class="fe lf lg lh li b">[]</code>，每个JSON内容总是以它们开始，而不是试图制作字符在内容前后如何呈现的模式，并创建一些可怕的正则表达式来修整它们。</p><p id="8414" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">split + trim代码如下所示:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ni nj l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">请注意。如果您的。indexOf返回-1。</figcaption></figure><p id="47ed" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">注意</strong> : <em class="lj">为什么使用</em><code class="fe lf lg lh li b"><em class="lj">.indexOf</em></code><em class="lj"/><code class="fe lf lg lh li b"><em class="lj">.lastIndexOf</em></code><em class="lj">并且必须同时测试</em> <code class="fe lf lg lh li b"><em class="lj">{}</em></code> <em class="lj">和</em> <code class="fe lf lg lh li b"><em class="lj">[]</em></code> <em class="lj">时一个简单的RegExp会做同样的事情吗？</em> <strong class="js iu"> <em class="lj">性能</em> </strong> <em class="lj">。这段代码的第一个版本使用的是RegExps，它执行得并不好，这个代码块执行起来花费了很多时间，在某些情况下甚至危及了整个过程。当我切换到普通的字符串方法时，它开始运行良好。</em></p><p id="41ff" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">根据修剪后剩下的内容，我们只需要调用<code class="fe lf lg lh li b">JSON.parse</code>和voilà。</p><p id="fca9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">完整的代码如下所示:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ni nj l"/></div></figure><h1 id="c7fd" class="mf mg it bd mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc bi translated">一些笔记</h1><p id="0c58" class="pw-post-body-paragraph jq jr it js b jt nd jv jw jx ne jz ka kb nf kd ke kf ng kh ki kj nh kl km kn im bi translated">这是一个很小的代码，用来接收一个压缩的tarball(gzip)内容，将其解压缩并解析为JSON。然而，这并不是一个适用于所有情况的好办法，我想指出的是:</p><ol class=""><li id="a19f" class="lr ls it js b jt ju jx jy kb lt kf lu kj lv kn lw lx ly lz bi translated">它处理内存中的一切，这在我的情况下不是问题，因为我知道有效负载的大小，即使我在lambda中，我也确信它永远不会使用所有的RAM。但是你必须记住这一点。</li><li id="68c0" class="lr ls it js b jt ma jx mb kb mc kf md kj me kn lw lx ly lz bi translated">它是原子的，所以它不处理无效的JSONs或其他错误。同样，对于我的场景来说，这并不重要，但也许代码需要更有弹性来处理不可靠的输入。</li><li id="f630" class="lr ls it js b jt ma jx mb kb mc kf md kj me kn lw lx ly lz bi translated">如果由于某种原因，JSON开始/结束字符(<code class="fe lf lg lh li b">{,},[,]</code>)出现在内容之前，这个方法<strong class="js iu">将失败</strong>。<em class="lj">虽然这不太可能发生，因为最容易包含这些字符的序列是文件名，它位于内容之后，因为我们的拆分方式。</em></li></ol><p id="e189" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">尽情享受吧！</p></div></div>    
</body>
</html>