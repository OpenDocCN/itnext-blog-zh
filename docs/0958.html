<html>
<head>
<title>Concurrency and Asynchronous Behavior with RxJS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">RxJS的并发和异步行为</h1>
<blockquote>原文：<a href="https://itnext.io/concurrency-and-asynchronous-behavior-with-rxjs-11b0c4b22597?source=collection_archive---------2-----------------------#2018-06-24">https://itnext.io/concurrency-and-asynchronous-behavior-with-rxjs-11b0c4b22597?source=collection_archive---------2-----------------------#2018-06-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/56ad22116c339e71bc6ea23c24063a7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wPZrYgac0pfVqHUFJ1BAAw.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片来自Pexels上的Bahram Jamalov</figcaption></figure><p id="3e87" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在最近发表的一篇关于<a class="ae la" href="https://medium.com/@abetteroliver/reactive-streams-and-multithreading-efd63b67de9a" rel="noopener">反应式流和多线程</a>的文章中。如果您是一名JavaScript开发人员，您会意识到JavaScript是单线程的，您可能会认为这与您无关。没那么快！那篇文章中讨论的原则也适用于RxJS，您甚至可以在JavaScript中实现并发。所以我来分享一些专家知识。</p><p id="4cbc" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">注:示例使用RxJS ≥ 6</p><h1 id="60a0" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">调度程序</h1><p id="00dd" class="pw-post-body-paragraph kc kd iq ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">在前面提到的文章中，我展示了使用<em class="me">发布</em>和<em class="me">订阅</em>操作符可以让流在不同的线程上运行。那些操作符也存在于RxJS中(publishOn命名为observeOn)。如果你不能用它们来选择一根线，它们是如何工作的？它们影响流执行的时间。他们使用调度程序来完成这项工作。</p><p id="aa86" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">简单地说，调度器控制一个工作单元何时被执行。RxJx内置了五个调度程序，其中三个与异步执行相关:</p><ul class=""><li id="c92f" class="mf mg iq ke b kf kg kj kk kn mh kr mi kv mj kz mk ml mm mn bi translated">Asap:调度微任务队列的执行</li><li id="abc9" class="mf mg iq ke b kf mo kj mp kn mq kr mr kv ms kz mk ml mm mn bi translated">Async:调度宏任务队列的执行</li><li id="5987" class="mf mg iq ke b kf mo kj mp kn mq kr mr kv ms kz mk ml mm mn bi translated">动画帧:调度下一个动画帧的执行</li></ul><p id="8689" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果你想了解更多关于微任务、宏任务和动画帧的知识，我推荐YouTube视频《事件循环的进一步冒险》。</p><figure class="mt mu mv mw gt jr"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="2ee1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在我只想说，使用其中一个调度器会使流异步。要在RxJS的当前版本中使用它们，您可以像这样导入它们:</p><pre class="mt mu mv mw gt mz na nb nc aw nd bi"><span id="ba31" class="ne lc iq na b gy nf ng l nh ni">import {animationFrameScheduler, asapScheduler, asyncScheduler} from 'rxjs';</span></pre><p id="4a3b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在像这样的旧版本中:</p><pre class="mt mu mv mw gt mz na nb nc aw nd bi"><span id="fc06" class="ne lc iq na b gy nf ng l nh ni">import { async } from 'rxjs/scheduler/async';</span><span id="1432" class="ne lc iq na b gy nj ng l nh ni">import { asap } from 'rxjs/scheduler/asap';</span><span id="9272" class="ne lc iq na b gy nj ng l nh ni">import { animationFrame } from 'rxjs/scheduler/animationFrame';</span></pre><p id="1337" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">除了前面提到的操作符，你还可以在其他函数中传递一个调度器，比如:的<em class="me"/></p><pre class="mt mu mv mw gt mz na nb nc aw nd bi"><span id="8ae1" class="ne lc iq na b gy nf ng l nh ni">of(1,2, asyncScheduler)<br/>  .subscribe(console.log);</span><span id="d95c" class="ne lc iq na b gy nj ng l nh ni">console.log("Before or after?")</span><span id="0310" class="ne lc iq na b gy nj ng l nh ni">//Prints<br/>//Before or after?<br/>//1<br/>//2</span></pre><p id="67e3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">没有调度器，“之前还是之后？”最终会被印刷出来。</p><h1 id="f564" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">分叉和连接</h1><p id="0230" class="pw-post-body-paragraph kc kd iq ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">一个常见的任务是从服务器获取数据，通常我们需要不止一个请求。在我们收到响应之前需要一些时间，为了更快，并行地拥有独立的请求是一个好主意。</p><p id="5cbe" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">由于JavaScript中的单线程限制，发送请求和处理响应不能并行进行(或者可以吗？)，我们不必在发送下一个请求之前等待一个响应。</p><p id="c9d1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">但是如果我们在继续之前需要所有请求的响应呢？女士们先生们，我来介绍<em class="me">福克加入:</em></p><pre class="mt mu mv mw gt mz na nb nc aw nd bi"><span id="5f56" class="ne lc iq na b gy nf ng l nh ni">import { forkJoin, from } from 'rxjs';</span><span id="1aea" class="ne lc iq na b gy nj ng l nh ni">forkJoin(<br/>  from(fetch(someUrl)),<br/>  from(fetch(someOtherUrl)),<br/>)<br/>.subscribe(console.log);</span><span id="54c3" class="ne lc iq na b gy nj ng l nh ni">//Prints<br/>//[Response, Response]</span></pre><p id="aa40" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">函数<em class="me"> fetch </em>发出一个(AJAX)请求。来自的函数<em class="me">创建一个发出响应的可观察对象。<em class="me"> forkJoin </em>创建一个可观察对象，等待两个响应都被接收到，并发出一个包含两个响应的数组。</em></p><p id="26cd" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果你对承诺比较熟悉的话，类似于<em class="me"> Promise.all(): </em></p><pre class="mt mu mv mw gt mz na nb nc aw nd bi"><span id="f072" class="ne lc iq na b gy nf ng l nh ni">Promise.all(<br/>  fetch(someUrl),<br/>  fetch(someOtherUrl)<br/>)<br/>.then(console.log)</span></pre><p id="a388" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在我们已经在我们的流中加入了一定程度的并发性，我认为我们已经为真正的并行执行做好了准备。</p><h1 id="8612" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">网络工作者</h1><p id="5aa1" class="pw-post-body-paragraph kc kd iq ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">已经引入了Web workers来允许JavaScript代码在另一个线程中在后台执行。终于多线程了！</p><p id="2f60" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">但是你不能用web workers执行任何代码。为了避免多线程的危险并保持JavaScript的单线程性，web workers与其他代码分开，只能与消息通信。</p><p id="154b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">对于那些从未使用过worker的人来说，worker代码是这样的:</p><pre class="mt mu mv mw gt mz na nb nc aw nd bi"><span id="593f" class="ne lc iq na b gy nf ng l nh ni">onmessage = function(e) {<br/>  //do something<br/>  const result = ...<br/>  postMessage(result);<br/>}</span></pre><p id="ddeb" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">和主脚本:</p><pre class="mt mu mv mw gt mz na nb nc aw nd bi"><span id="d337" class="ne lc iq na b gy nf ng l nh ni">const myWorker = new Worker(‘worker.js’);<br/>myWorker.onmessage = result =&gt; {<br/>  //do something with the result<br/>}</span><span id="a66b" class="ne lc iq na b gy nj ng l nh ni">myWorker.postMessage("foo");</span></pre><p id="bdda" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">主脚本发送消息“foo ”,工人做一些事情，并使用<em class="me"> postMessage </em>将结果返回给主脚本，主脚本通过<em class="me"> onmessage </em>事件处理程序接收该结果。</p><p id="071e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们如何把它用于可观测量呢？最简单的方法是使用<em class="me">平面图/合并图</em>。</p><pre class="mt mu mv mw gt mz na nb nc aw nd bi"><span id="06c2" class="ne lc iq na b gy nf ng l nh ni">function processWithWorker(value) {<br/>  return new Observable(subscriber =&gt; {<br/>    <!-- -->const myWorker = new Worker('worker.js');<br/>    myWorker.onmessage = result =&gt; {<br/>      subscriber.next(result);<br/>      subscriber.complete();<br/>      myWorker.terminate();<br/>    }<br/>    myWorker.postMessage(value);<br/>  });<br/>}</span><span id="45c1" class="ne lc iq na b gy nj ng l nh ni">of(1,2)<br/>.pipe(<br/>  flatMap(processWithWorker<!-- -->)<br/>)<br/>subscribe(console.log);</span><span id="d083" class="ne lc iq na b gy nj ng l nh ni">//prints whatever the workers return</span></pre><p id="95c6" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">为了简单起见，我们为源发出的每个值创建一个工人。</p><p id="fa0c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">发出值，然后创建工作线程。我们向它发送一条消息，并返回一个新的可观测值。工作者一返回一个值，该可观察对象就发出一个值。请注意，我们还发出一个完成信号，并终止工作线程。</p><p id="2917" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">工作代码与主脚本并行运行，但是由于流的性质，值仍然是一个接一个地被处理。如果我们想让它们并行处理呢？如果不混淆代码的含义，那是不可能的。但是如果只有几个固定值，可以使用forkJoin:</p><pre class="mt mu mv mw gt mz na nb nc aw nd bi"><span id="5500" class="ne lc iq na b gy nf ng l nh ni">forkJoin(<br/> processWithWorker(1),<br/> processWithWorker(2),<br/>}<br/>.subscribe(console.log);</span></pre><p id="33fd" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这两个值将独立于主脚本并行处理。</p><h1 id="8a8d" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="d99e" class="pw-post-body-paragraph kc kd iq ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">虽然JavaScript是单线程的，但RxJS遵循与其他反应流库相同的原则。我们可以创建异步流，拥有一定程度的并发性，web workers甚至允许并行性。</p></div></div>    
</body>
</html>