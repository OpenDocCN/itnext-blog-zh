<html>
<head>
<title>There’s No Need To Hate Web Components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">没有必要讨厌Web组件</h1>
<blockquote>原文：<a href="https://itnext.io/theres-no-need-to-hate-web-components-ebf2ec8a998c?source=collection_archive---------3-----------------------#2020-01-22">https://itnext.io/theres-no-need-to-hate-web-components-ebf2ec8a998c?source=collection_archive---------3-----------------------#2020-01-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="70e2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你也不需要放弃你的框架</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/a6acab25f5161f42d424a8776ec9c3d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Tj5MtDfrxAcMMPeN"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">乔恩·泰森在<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="fdb6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">四年前，我在一家国际荷兰银行找到了一份自由职业。最初，我受雇帮助将应用程序从AngularJS迁移到Angular 2，但事情突然变得不同了。</p><p id="f3b3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有一天，我碰到一位经理，他力劝我“看一看聚合物”，因为澳大利亚的一个团队已经用它创造出了一些好东西。聚合物现在是前进的方向，实际上在几周内，我们正在向聚合物迁移。</p><p id="06f1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">事情进行得很快，也出了差错。Polymer的第一个稳定的1.0版本才发布了大约一年，仍然有许多开创性的工作要做。</p><p id="abab" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们在测试、遗留浏览器支持和依赖性管理方面苦苦挣扎。但是现在，四年后，Web组件终于出现了，它们已经准备好了。</p></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><h1 id="6717" class="lm ln it bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">Web组件现在在任何地方都受支持</h1><p id="9287" class="pw-post-body-paragraph jq jr it js b jt mk jv jw jx ml jz ka kb mm kd ke kf mn kh ki kj mo kl km kn im bi translated">1月15日，微软发布了基于Chromium的Edge浏览器，所有主流浏览器最终都获得了对Web组件的本地支持。</p><p id="942b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最初的规范是在2011年推出的，所以它已经被悲观的开发者宣布 <a class="ae le" href="https://dev.to/richharris/why-i-don-t-use-web-components-2cia" rel="noopener ugc nofollow" target="_blank">死亡</a>好几次了。</p><p id="d33c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在铬基Edge发布后，聚合物团队的声明再次遭到了一些质疑:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="3ea5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">那么，为什么对Web组件如此厌恶呢？</p></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><h1 id="8843" class="lm ln it bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">有一段时间了</h1><p id="97dc" class="pw-post-body-paragraph jq jr it js b jt mk jv jw jx ml jz ka kb mm kd ke kf mn kh ki kj mo kl km kn im bi translated">所有主流浏览器都支持Web组件需要相当长的时间，也许太长了。与此同时，前端框架已经接管了世界，许多开发人员似乎不愿意“转换”到Web组件。</p><p id="55da" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">反应还是王道，Vue。JS正在获得牵引力，Web组件的采用仍然相对较低。但在过去的一年半时间里，这种情况似乎正在慢慢改变。</p><p id="8741" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">存在框架疲劳，开发人员想知道框架是否值得麻烦，寻找本地平台作为替代。</p><p id="1d66" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我相信Web组件是一种解决方案，但是Web组件是框架的替代物是围绕它们的许多误解之一。</p><p id="1fcf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们仔细看看。</p></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><h1 id="5ef0" class="lm ln it bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">你可以继续使用你的框架</h1><p id="b0be" class="pw-post-body-paragraph jq jr it js b jt mk jv jw jx ml jz ka kb mm kd ke kf mn kh ki kj mo kl km kn im bi translated">没有必要“转换”和放弃你的前端框架。有人声称<a class="ae le" href="https://blog.usejournal.com/web-components-will-replace-your-frontend-framework-3b17a580831c" rel="noopener ugc nofollow" target="_blank"> Web组件将取代前端框架</a>，这听起来可能很奇怪，但这从来都不是Web组件的<em class="mr">目标</em>。</p><p id="3628" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">是的，我仍然相信Web组件将会进化，使我们所知的这些框架过时，但是它们从来没有打算成为替代品。</p><p id="cace" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Web组件的一个关键特性是它们是框架不可知的，这意味着它们可以集成到任何框架中。这是<em class="mr">与Angular、React和Vue等不可互换的专有组件之间的巨大</em>转变。</p><p id="349d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Web组件最终使我们能够编写一个组件，并在任何地方使用它。三大框架React、Angular和Vue <a class="ae le" href="https://reactjs.org/docs/web-components.html" rel="noopener ugc nofollow" target="_blank">已经</a> <a class="ae le" href="https://angular.io/guide/elements" rel="noopener ugc nofollow" target="_blank">提供</a> <a class="ae le" href="https://github.com/vuejs/vue-web-component-wrapper" rel="noopener ugc nofollow" target="_blank">支持</a>集成Web组件。</p><h1 id="da05" class="lm ln it bd lo lp ms lr ls lt mt lv lw lx mu lz ma mb mv md me mf mw mh mi mj bi translated">“没有人使用Web组件”</h1><p id="15ec" class="pw-post-body-paragraph jq jr it js b jt mk jv jw jx ml jz ka kb mm kd ke kf mn kh ki kj mo kl km kn im bi translated">Web组件的采用仍然相对较低，但它们已经被YouTube、<a class="ae le" href="https://dev.to/ionic/apple-just-shipped-web-components-to-production-and-you-probably-missed-it-57pf" rel="noopener ugc nofollow" target="_blank"> Apple Music </a>和ING Bank(我是其中的一员)用于生产，Github和Twitter也在它们的应用程序的较小部分中使用它们。</p><p id="b143" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">毫不奇怪，在这个框架占主导地位的时代，Web组件可能不会一夜成名，事实上，它们只是最近才得到所有浏览器的完全支持。</p><p id="0b2a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是目前，人们的兴趣正在快速增长，关于Web组件和使用它们的项目的文章数量也在快速增长。一些很好的例子是<a class="ae le" href="https://svelte.dev" rel="noopener ugc nofollow" target="_blank">svelet</a>、<a class="ae le" href="https://webcomponents.dev" rel="noopener ugc nofollow" target="_blank"> Webcomponents.dev </a>和<a class="ae le" href="https://open-wc.org" rel="noopener ugc nofollow" target="_blank"> open-wc </a>。</p><p id="71bd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，尽管Web组件的采用和浏览器支持花了很长时间，但毫无疑问它正在发生。</p><h1 id="ec02" class="lm ln it bd lo lp ms lr ls lt mt lv lw lx mu lz ma mb mv md me mf mw mh mi mj bi translated">“我需要支持IE11”</h1><p id="4d84" class="pw-post-body-paragraph jq jr it js b jt mk jv jw jx ml jz ka kb mm kd ke kf mn kh ki kj mo kl km kn im bi translated">我经历过在尝试使用现代JavaScript特性的同时不得不支持IE11的痛苦。</p><p id="2f9e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但我从未让这妨碍向现代浏览器用户提供最佳体验。仅仅因为我们需要迎合老浏览器的用户，就降低他们的体验是没有意义的。</p><p id="a92d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">给所有用户尽可能最好的体验更有意义，但不一定要给<em class="mr">完全相同的体验</em>。这可能意味着额外的工作，但是这并不是特定于Web组件的，所以也不应该成为不使用它们的理由。</p><p id="72df" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">根据有多少用户仍在使用IE11，你可以决定应该在这上面花费多少资源。通常，这将是一个很小的百分比，因此应该相应地花费资源。</p><p id="eede" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果这一小部分人至少得到了一个可接受的，尽管是降级的体验，那么这应该是好的。</p><p id="29aa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">具体到Web组件，他们有一组可用的<a class="ae le" href="https://github.com/WebComponents/webcomponentsjs" rel="noopener ugc nofollow" target="_blank">poly fill</a>，可以在IE11上提供足够好的体验。</p><p id="a3ea" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">只要确保现代浏览器上的用户不会受到影响，因为您需要支持IE11的一小部分用户。这说不通。</p><h1 id="6c46" class="lm ln it bd lo lp ms lr ls lt mt lv lw lx mu lz ma mb mv md me mf mw mh mi mj bi translated">“没有数据绑定，无法扩展”</h1><p id="be7e" class="pw-post-body-paragraph jq jr it js b jt mk jv jw jx ml jz ka kb mm kd ke kf mn kh ki kj mo kl km kn im bi translated">默认情况下，Web组件的属性只能接受原始值，如字符串、数字和布尔值。这些属性值的变化可以通过<code class="fe mx my mz na b">attributeChangedCallback</code>方法观察和反应。</p><p id="3355" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">属性不能像对象和数组那样接受复杂的值，所以在实践中，数据绑定只能通过带有原语值的<code class="fe mx my mz na b">attributeChangedCallback</code>来完成。</p><p id="1285" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但这并不意味着复杂值的数据绑定在Web组件中是不可能的，它只是需要一些代码。</p><p id="7c5e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我自己实现了一个简单的概念验证。它类似于由Polymer团队创建的<a class="ae le" href="https://github.com/polymer/lit-element" rel="noopener ugc nofollow" target="_blank"> lit-element </a>，它也为自定义元素提供了一个bass类，包含各种方便的方法，使使用Web组件更加容易。</p><p id="851d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">请记住，框架也不会“神奇地”让复杂值的数据绑定成为可能。他们通常提供序列化机制来实现这一点，这在性能方面也不是免费的。</p><p id="6f4b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用Web组件的标准方式是通过属性传递复杂的值。通常，您会为这些属性定义getters和setters来对更改做出反应。您还可以在Web组件上定义可以从外部调用的方法，这样也可以传入复杂的值。</p><h1 id="6d53" class="lm ln it bd lo lp ms lr ls lt mt lv lw lx mu lz ma mb mv md me mf mw mh mi mj bi translated">“没有无状态组件，它不会扩展”</h1><p id="b7f8" class="pw-post-body-paragraph jq jr it js b jt mk jv jw jx ml jz ka kb mm kd ke kf mn kh ki kj mo kl km kn im bi translated">Web组件是基于类的，这是必要的，因为它们需要扩展<code class="fe mx my mz na b">HTMLElement</code>，这是所有HTML元素的bass类。本质上，Web组件是通过扩展HTML本身来工作的。</p><p id="a912" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">就我个人而言，如果能够用一个对象或函数创建一个Web组件，我会很高兴，但是由于上面提到的原因，不幸的是事实并非如此。</p><p id="493a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但这并不意味着当应用程序变得非常大时，Web组件就不能伸缩。</p><p id="803d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">似乎有这样一种误解，即如果不使用前端框架和无状态功能组件，构建可伸缩的应用程序就不再可能。</p><p id="148b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">无状态功能组件很棒，但是它们确实带来了一些额外的复杂性。在React的情况下，API从<code class="fe mx my mz na b">React.createClass</code>到ES6类再到功能组件，这带来了更高阶的组件，现在这些组件被React钩子所取代。</p><p id="5b85" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们应该认识到，这些都是为了解决无状态功能组件引起的问题而创建的变通办法。</p><p id="ff47" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">他们可能会带来更多的麻烦。</p><h1 id="295c" class="lm ln it bd lo lp ms lr ls lt mt lv lw lx mu lz ma mb mv md me mf mw mh mi mj bi translated">“为Web组件设置主题很难”</h1><p id="f33b" class="pw-post-body-paragraph jq jr it js b jt mk jv jw jx ml jz ka kb mm kd ke kf mn kh ki kj mo kl km kn im bi translated">Web组件可以使用影子DOM，它带来了真正有作用域的CSS。这意味着一个组件可以用只适用于组件本身的CSS从内部进行样式化。</p><p id="8bf8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当然，我们仍然希望Web组件的消费者能够对它们进行样式化，这可以通过CSS自定义属性来实现。这确实意味着这些属性中的每一个都需要显式公开。</p><p id="e9f5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在Chrome和Firefox中，<a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/CSS/::part" rel="noopener ugc nofollow" target="_blank"> CSS阴影部分</a>已经被支持以使主题化更容易，并且<a class="ae le" href="https://developers.google.com/web/updates/2019/02/constructable-stylesheets" rel="noopener ugc nofollow" target="_blank">可构造样式表</a>从Chrome 73开始被支持。目前还不清楚其他浏览器何时会提供支持。</p><p id="891f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">主题化Web组件仍有改进的空间，但框架的替代方案，例如<a class="ae le" href="https://styled-components.com/" rel="noopener ugc nofollow" target="_blank"> React styled components </a>，需要另一个库，很复杂，并且将所有CSS都转移到JavaScript。</p><h1 id="fb75" class="lm ln it bd lo lp ms lr ls lt mt lv lw lx mu lz ma mb mv md me mf mw mh mi mj bi translated">“没有服务器端渲染”</h1><p id="626a" class="pw-post-body-paragraph jq jr it js b jt mk jv jw jx ml jz ka kb mm kd ke kf mn kh ki kj mo kl km kn im bi translated">服务器端渲染很难，当使用Shadow DOM或任何其他浏览器专用API时，我想你没有其他选择，只能使用成熟的无头浏览器来进行渲染。</p><p id="dea9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你的应用非常依赖于服务器端的渲染，那么Web组件现在可能不是一个好的选择。但话说回来，你最好的选择可能是完全使用静态HTML，而不是单页应用程序。</p></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><h1 id="8f96" class="lm ln it bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">Web组件是一个健壮的解决方案</h1><p id="6fef" class="pw-post-body-paragraph jq jr it js b jt mk jv jw jx ml jz ka kb mm kd ke kf mn kh ki kj mo kl km kn im bi translated">对于基于组件的前端架构来说，使用Web组件有很多好处。</p><p id="e8ec" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它们扩展了HTML本身，并利用浏览器的HTML解析器来确保最佳性能。</p><p id="e5ea" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可以继续使用您喜欢的框架，因为Web组件可以集成到所有当前的前端框架中，因此真正可以在任何地方重用。</p><p id="adc7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Web组件是基于标准的，不需要外部依赖，而且不太可能被废弃。现在，所有主流浏览器都支持它们，并且会一直支持下去。</p><p id="3a46" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Web组件的API是稳定的，并且保证保持稳定，因为它受到标准的约束。</p><p id="03de" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这些是Web组件的好处:基于标准、经得起未来考验、稳定和真正可重用。</p><p id="57b5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">拥抱他们或憎恨他们，选择权在你。</p></div></div>    
</body>
</html>