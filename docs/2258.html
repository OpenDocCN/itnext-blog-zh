<html>
<head>
<title>React Hooks — designing a simple forms API — part 6 — yup schema validation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">react Hooks——设计简单的表单API——第6部分——模式验证</h1>
<blockquote>原文：<a href="https://itnext.io/react-hooks-designing-a-simple-forms-api-part-6-yup-schema-validation-5a800cb1c330?source=collection_archive---------1-----------------------#2019-04-25">https://itnext.io/react-hooks-designing-a-simple-forms-api-part-6-yup-schema-validation-5a800cb1c330?source=collection_archive---------1-----------------------#2019-04-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="9cd8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本文中，我们将扩展我们的表单API来支持<a class="ae ko" href="https://github.com/jquense/yup" rel="noopener ugc nofollow" target="_blank">基于yup的模式验证</a>。</p><p id="d056" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本系列的第1部分中，我们研究了如何使用React钩子来设计一个React表单库。第1部分介绍了这个库的动机和一些总体设计目标。</p><p id="b83f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本系列的第2部分<a class="ae ko" href="https://medium.com/@shanplourde/react-hooks-designing-a-simple-forms-api-part-2-1fe5d12f23d9" rel="noopener">中，我们创建了一个<code class="fe kp kq kr ks b">useInput</code>钩子，将其集成到我们的<code class="fe kp kq kr ks b">useForm</code>钩子中，回顾了我们的解决方案的状态管理，合并了一些额外的测试，并且更详细地回顾了测试策略。</a></p><p id="f5a1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在第3部分中，我们讨论了验证、异步验证和异步表单提交。它为我们提供了基于React hooks的表单API的关键元素。</p><p id="748b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><a class="ae ko" rel="noopener ugc nofollow" target="_blank" href="/react-hooks-designing-a-simple-forms-api-part-4-scaling-to-other-input-types-e738db0a3fc3">在第4部分</a>中，我们扩展了我们的解决方案，以支持标准HTML输入类型和自定义输入。</p><p id="3399" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在第5部分中，我们扩展了<code class="fe kp kq kr ks b">useForm</code>以支持动态表单。</p><h1 id="b1db" class="kt ku it bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">工作示例</h1><p id="6098" class="pw-post-body-paragraph jq jr it js b jt lr jv jw jx ls jz ka kb lt kd ke kf lu kh ki kj lv kl km kn im bi translated">让我们来看看带有模式验证支持的<code class="fe kp kq kr ks b">useForm</code>钩子的演示:</p><figure class="lw lx ly lz gt ma"><div class="bz fp l di"><div class="mb mc l"/></div><figcaption class="md me gj gh gi mf mg bd b be z dk translated">带有模式验证的useForm演示</figcaption></figure><p id="38f9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><a class="ae ko" href="https://github.com/shanplourde/react-hooks-form-util" rel="noopener ugc nofollow" target="_blank">完整的解决方案可以在我的GitHub </a>中找到。演示中有很多样板文件，但我希望在这一点上有非常明确的例子。请注意，由于CodeSandbox设计决定不支持从<code class="fe kp kq kr ks b">package.json</code>加载<code class="fe kp kq kr ks b">devDependencies</code>，测试此时不会通过CodeSandbox。</p><h1 id="771b" class="kt ku it bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">是的模式验证概述和好处</h1><p id="dd12" class="pw-post-body-paragraph jq jr it js b jt lr jv jw jx ls jz ka kb lt kd ke kf lu kh ki kj lv kl km kn im bi translated">Yup是一个模式验证库。您可以使用它来定义一个JavaScript模式，然后根据该模式验证任意对象。Yup为您提供了一整套标准的模式验证，如required、min length、max length、email等。</p><p id="a656" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有很多模式验证库，yup恰好是其中较大且较活跃的一个。让我们通过查看一个<a class="ae ko" href="https://runkit.com/jquense/yup#" rel="noopener ugc nofollow" target="_blank">代码示例</a>来看看yup验证是什么样子的:</p><pre class="lw lx ly lz gt mh ks mi mj aw mk bi"><span id="a11e" class="ml ku it ks b gy mm mn l mo mp">const { object, string, number, date } = require('yup')</span><span id="b446" class="ml ku it ks b gy mq mn l mo mp">const contactSchema = object({<br/>  name: string()<br/>    .required(),<br/>  age: number()<br/>    .required()<br/>    .positive()<br/>    .integer(),<br/>  email: string()<br/>    .email(),<br/>  website: string()<br/>    .url(),<br/>  createdOn: date()<br/>    .default(() =&gt; new Date())<br/>})</span><span id="ff5f" class="ml ku it ks b gy mq mn l mo mp">let contact = {<br/>  name: 'jimmy',<br/>  age: 24,<br/>  email: '<a class="ae ko" href="mailto:jdog@cool.biz" rel="noopener ugc nofollow" target="_blank">jdog@cool.biz</a>'<br/>}</span><span id="0c5a" class="ml ku it ks b gy mq mn l mo mp">await contactSchema.isValid(contact) // true = valid</span></pre><p id="c2ea" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe kp kq kr ks b">contactSchema</code>是yup模式。<code class="fe kp kq kr ks b">contact</code>是您的数据对象(这可能是来自表单的数据)。最后调用<code class="fe kp kq kr ks b">contactSchema.isValid()</code>根据<code class="fe kp kq kr ks b">contactSchema</code>模式验证<code class="fe kp kq kr ks b">contact</code>对象。Yup提供了一个流畅的API来定义模式。实际上，这可能不是您想要的定义模式的方式。</p><p id="e40b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如，如果您的字段是从数据库中动态创建的，您将如何存储所有这些流畅的API调用？在这些情况下，您可以使用允许您以JSON格式存储模式的库，然后可以将模式序列化并存储在任何数据库中。<a class="ae ko" href="https://github.com/kristianmandrup/schema-to-yup" rel="noopener ugc nofollow" target="_blank"> schema-to-yup </a>就是这样一个库，它允许您在JSON中定义模式，然后将模式转换为yup模式对象。</p><p id="fcd4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">挂钩需要与yup集成。当向<code class="fe kp kq kr ks b">useForm</code>提供yup模式时，<code class="fe kp kq kr ks b">useForm</code>将需要对输入字段应用那些验证。</p><h1 id="59b1" class="kt ku it bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">在任意时间应用模式验证</h1><p id="d88c" class="pw-post-body-paragraph jq jr it js b jt lr jv jw jx ls jz ka kb lt kd ke kf lu kh ki kj lv kl km kn im bi translated">就像我们在之前的文章中创建的<a class="ae ko" rel="noopener ugc nofollow" target="_blank" href="/react-hooks-designing-a-simple-forms-api-part-3-validation-and-a-running-example-18b835a3b817">开箱即用验证一样，模式验证应该能够与开箱即用验证同时运行。我们应该允许表单创建者说“嘿，我想在我的名字字段上运行onBlur和onSubmit的模式验证”，或者“嘿，我想对我的名字字段应用模式验证，同时应用我的</a><a class="ae ko" href="https://medium.com/@shanplourde/inline-form-validations-ux-design-considerations-and-react-examples-c2f53f89bebc" rel="noopener">奖励早期验证晚期设计模式</a>”。</p><h1 id="77a4" class="kt ku it bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">设计公共API以支持模式验证</h1><p id="a9e2" class="pw-post-body-paragraph jq jr it js b jt lr jv jw jx ls jz ka kb lt kd ke kf lu kh ki kj lv kl km kn im bi translated">在我看来，形式是模式的子集。两者之间存在耦合。所以我更喜欢用最初的<code class="fe kp kq kr ks b">useForm</code>钩子调用来传递模式。</p><pre class="lw lx ly lz gt mh ks mi mj aw mk bi"><span id="5fdb" class="ml ku it ks b gy mm mn l mo mp">export const useForm = ({ id, initialState = {}, validationSchema = {} }) =&gt; {<br/>  const inputValues = useRef({<br/>    ...initialState<br/>  });</span></pre><p id="8217" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe kp kq kr ks b">useForm</code>现在接收一个<code class="fe kp kq kr ks b">validationSchema</code>属性，当设置该属性时，它将对表单中最终定义的字段应用模式验证。要使用模式验证，表单创建者需要执行以下操作:</p><pre class="lw lx ly lz gt mh ks mi mj aw mk bi"><span id="235d" class="ml ku it ks b gy mm mn l mo mp">const { required, mustBeTrue, schema } = validators;</span><span id="4bcc" class="ml ku it ks b gy mq mn l mo mp">const contactSchema = object({<br/>    firstName: string()<br/>      .required()<br/>      .min(3),<br/>    lastName: string()<br/>      .required()<br/>      .length(10),<br/>    email: string().email()<br/>  });</span><span id="f30d" class="ml ku it ks b gy mq mn l mo mp">const {<br/>    getFormProps,<br/>    inputValues,<br/>    uiState,<br/>    api,<br/>    formValidity,<br/>    inputUiState<br/>  } = useForm({<br/>    id: "kitchenSinkForm",<br/>    initialState,<br/>    validationSchema: contactSchema<br/>  });</span><span id="e5bd" class="ml ku it ks b gy mq mn l mo mp">const firstNameInput = api.addInput({<br/>    id: "firstName",<br/>    value: inputValues.firstName,<br/>    validators: [<br/>      {<br/>        ...schema,<br/>        when: [<br/>          {<br/>            eventType: onChange,<br/>            evaluateCondition: evaluateConditions.rewardEarlyValidateLate<br/>          },<br/>          onBlur,<br/>          onSubmit<br/>        ]<br/>      }<br/>    ]<br/>  });</span><span id="526a" class="ml ku it ks b gy mq mn l mo mp">const lastNameInput = api.addInput({<br/>    id: "lastName",<br/>    value: inputValues.lastName,<br/>    validators: [{ ...schema, when: [onBlur, onSubmit] }]<br/>  });</span><span id="66d3" class="ml ku it ks b gy mq mn l mo mp">const emailInput = api.addInput({<br/>    id: "email",<br/>    value: inputValues.email,<br/>    validators: [<br/>      { ...schema, when: [onBlur, onSubmit] }<br/>      // {<br/>      //   ...email,<br/>      //   when: [onBlur, onSubmit]<br/>      // }<br/>    ]<br/>  });</span></pre><p id="326a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在上面的示例表单代码中，我们定义了<code class="fe kp kq kr ks b">contactSchema</code>，这是一个yup模式。我们将它传递给<code class="fe kp kq kr ks b">useForm</code>钩子。然后，当我们定义输入时，我们指出我们希望用<code class="fe kp kq kr ks b">validators: [ { ...schema } ]</code>验证器对它们应用模式验证。这种方法的好处在于，我们还可以定义何时应用这些模式验证——onBlur、onSubmit等。</p><p id="8e71" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在<code class="fe kp kq kr ks b">api.addInput</code>中，当我们指定想要使用<code class="fe kp kq kr ks b">schema</code>验证器时，<code class="fe kp kq kr ks b">useForm</code>根据输入<code class="fe kp kq kr ks b">id</code>连接适当的模式字段。</p><h1 id="fe4f" class="kt ku it bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">实施细节</h1><h2 id="b1b8" class="ml ku it bd kv mr ms dn kz mt mu dp ld kb mv mw lh kf mx my ll kj mz na lp nb bi translated">创建模式验证器</h2><p id="2f3c" class="pw-post-body-paragraph jq jr it js b jt lr jv jw jx ls jz ka kb lt kd ke kf lu kh ki kj lv kl km kn im bi translated">在上面的<code class="fe kp kq kr ks b">useForm</code>代码中，我们使用了<code class="fe kp kq kr ks b">schema</code>验证器。下面是validators.js中的<code class="fe kp kq kr ks b">schema</code>验证器代码:</p><pre class="lw lx ly lz gt mh ks mi mj aw mk bi"><span id="c1b3" class="ml ku it ks b gy mm mn l mo mp">validators.schema = createValidator({<br/>  validateFn: async ({ value, validationSchema }) =&gt; {<br/>    if (!validationSchema || !validationSchema.validate) return true;<br/>    try {<br/>      await validationSchema.validate(value);<br/>      return true;<br/>    } catch (e) {<br/>      return false;<br/>    }<br/>  },<br/>  error: "INVALID_SCHEMA"<br/>});</span></pre><p id="a25b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们使用yup <code class="fe kp kq kr ks b">validate</code> API来执行验证。我们遵循其他验证器的相同模式——基于验证成功返回true/false。如果一个yup验证失败，yup将返回许多其他属性，甚至是错误描述，但是我的偏好是不在验证错误中包含内容。因此，如果模式验证失败，它们只会返回<code class="fe kp kq kr ks b">INVALID_SCHEMA</code>错误消息。表单创建者可以决定在这些情况下显示什么样的副本。我相信这可以改进，但我不确定如何改进，因为表单创建者可以访问模式定义，所以如果他们愿意，他们可以查询模式定义来创建错误消息。</p><p id="6287" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe kp kq kr ks b">useForm</code>只会将一个模式字段传递给模式验证。预期是，如果我们验证名字字段，<code class="fe kp kq kr ks b">useForm</code>将只把<code class="fe kp kq kr ks b">firstName</code>字段传递给模式验证器，而不是完整的模式</p><h2 id="19af" class="ml ku it bd kv mr ms dn kz mt mu dp ld kb mv mw lh kf mx my ll kj mz na lp nb bi translated">更新useForm以将架构字段传递给架构验证程序</h2><p id="8cf6" class="pw-post-body-paragraph jq jr it js b jt lr jv jw jx ls jz ka kb lt kd ke kf lu kh ki kj lv kl km kn im bi translated"><code class="fe kp kq kr ks b">useForm</code>需要最小的改动。现在表单创建者可以将<code class="fe kp kq kr ks b">validationSchema</code>传递给<code class="fe kp kq kr ks b">useForm</code>，任何时候需要验证时，<code class="fe kp kq kr ks b">useForm</code>都可以将正确的模式字段传递给验证。validators.js只需要将<code class="fe kp kq kr ks b">validationSchema</code>作为一个参数，并在适当的时候将其传递给模式验证器。</p><pre class="lw lx ly lz gt mh ks mi mj aw mk bi"><span id="270e" class="ml ku it ks b gy mm mn l mo mp"><strong class="ks iu">const getSchemaField = (validationSchema, field) =&gt;<br/>  validationSchema.fields ? validationSchema.fields[field] : null;</strong></span><span id="3ad0" class="ml ku it ks b gy mq mn l mo mp">...</span><span id="7c6e" class="ml ku it ks b gy mq mn l mo mp">const validateAll = async eventType =&gt; {<br/>    const promises = [];<br/>    let newUiState = { ...uiState };</span><span id="42e1" class="ml ku it ks b gy mq mn l mo mp">Object.keys(validators.current).forEach(async field =&gt; {<br/>      promises.push(<br/>        runValidators({<br/>          field,<br/>          validators: validators.current[field],<br/>          eventType,<br/>          value: inputs.current[field].value,<br/>          inputValues: inputValues.current,<br/>  <strong class="ks iu">        validationSchema: getSchemaField(validationSchema, field)</strong><br/>        })<br/>      );<br/>    });</span><span id="c1e0" class="ml ku it ks b gy mq mn l mo mp">...</span><span id="0b59" class="ml ku it ks b gy mq mn l mo mp">const runInputValidations = async ({ id, value, eventType, timeStamp }) =&gt; {<br/>...</span><span id="f93e" class="ml ku it ks b gy mq mn l mo mp">try {<br/>        const validationResults = await runValidators({<br/>          field: id,<br/>          validators: validators.current[id],<br/>          eventType: eventType,<br/>          value,<br/>          runId: timeStamp,<br/>          inputValues: inputValues.current,<br/><strong class="ks iu">          validationSchema: getSchemaField(validationSchema, id)</strong><br/>        });</span></pre><h1 id="0c00" class="kt ku it bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">摘要</h1><p id="f5bb" class="pw-post-body-paragraph jq jr it js b jt lr jv jw jx ls jz ka kb lt kd ke kf lu kh ki kj lv kl km kn im bi translated">在本文中，我们重构了我们的解决方案，以支持基于yup的模式验证。</p><p id="0f09" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在后面的部分中，我们将讨论其他主题，比如减少样板文件、取消承诺、去抖、钩子性能考虑和其他设计优化。</p><p id="64df" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">此时，该库可能已经“足够好”可以用于生产了😃。在开始自己制作表单库之前，请记住制作一个“足够好”的表单库需要付出的努力和思考！</p><p id="2455" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">除非您有一个不需要验证逻辑的极其简单的表单，是的，您可以用React拼凑一个表单，但是它会非常有限。一旦你需要越过简单的表单，使用表单库。否则，你可能没有充分利用你的时间。除非你是出于自己的学习目的，当然，我总是建议通过开发你感兴趣的东西来学习。</p><p id="a8b3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您有任何问题、反馈或建议，或者您希望我介绍本系列中的其他内容，请告诉我。</p></div></div>    
</body>
</html>