<html>
<head>
<title>Consuming GraphQL APIs with Vertx HttpClient/WebClient</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Vertx HttpClient/WebClient使用GraphQL APIs</h1>
<blockquote>原文：<a href="https://itnext.io/consuming-graphql-apis-with-vertx-httpclient-webclient-db410c410aa2?source=collection_archive---------0-----------------------#2021-07-24">https://itnext.io/consuming-graphql-apis-with-vertx-httpclient-webclient-db410c410aa2?source=collection_archive---------0-----------------------#2021-07-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="b91a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<a class="ae kl" href="https://github.com/hantsy/vertx-sandbox/blob/master/docs/client" rel="noopener ugc nofollow" target="_blank">之前的一篇文章</a>中，我们已经介绍了使用Vertx HttpClient和WebClient消费RESTful APIs。在这篇文章中，我们将使用我们在上一篇文章的<a class="ae kl" href="https://github.com/hantsy/vertx-sandbox/blob/master/docs/graphql.md" rel="noopener ugc nofollow" target="_blank">中创建的GraphQL APIs。</a></p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/8166aa811d3c05626ec35cb176650ce5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jVl9u3hRpyj1g8ySAxcD3w.jpeg"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">萨姆·巴耶在<a class="ae kl" href="https://unsplash.com/s/photos/china-mountain?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="0bc7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，让我们回顾一下HttpClient和WebClient之间的区别。</p><ul class=""><li id="b12f" class="lc ld iq jp b jq jr ju jv jy le kc lf kg lg kk lh li lj lk bi translated">HttpClient是一个低级API，它提供了与Http服务器交互的细粒度控制。</li><li id="ca09" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">WebClient是一个高级API，它提供了更方便的方法来简化处理web请求和响应。在大多数情况下，WebClient是首选，但它缺乏WebSocket支持，所以当启动WebSocket连接时，我们必须切换到HttpClient。</li></ul><h2 id="0953" class="lq lr iq bd ls lt lu dn lv lw lx dp ly jy lz ma mb kc mc md me kg mf mg mh mi bi translated">从我的Github 查看<a class="ae kl" href="https://github.com/hantsy/vertx-sandbox/tree/master/graphql-webclient" rel="noopener ugc nofollow" target="_blank">完整的示例代码。</a></h2><p id="e020" class="pw-post-body-paragraph jn jo iq jp b jq mj js jt ju mk jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">假设您已经阅读了<a class="ae kl" href="https://graphql.org/learn/serving-over-http/" rel="noopener ugc nofollow" target="_blank"> GraphQL over HTTP规范</a>和<a class="ae kl" href="https://github.com/jaydenseric/graphql-multipart-request-spec" rel="noopener ugc nofollow" target="_blank"> GraphQL多部分请求规范</a>。</p><p id="5b74" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过<a class="ae kl" href="https://start.vertx.io" rel="noopener ugc nofollow" target="_blank"> Eclipse Vertx Starter </a>创建一个Eclipse Vertx项目。</p><p id="c64e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<code class="fe mo mp mq mr b">MainVerticle</code>类的start方法中，首先创建一个<code class="fe mo mp mq mr b">WebClient</code>对象。</p><pre class="kn ko kp kq gt ms mr mt mu aw mv bi"><span id="a4bf" class="lq lr iq mr b gy mw mx l my mz">var options = new WebClientOptions()<br/>    .setUserAgent(WebClientOptions.loadUserAgent())<br/>    .setDefaultHost("localhost")<br/>    .setDefaultPort(8080);</span><span id="70c4" class="lq lr iq mr b gy na mx l my mz">var client = WebClient.create(vertx, options);</span></pre><p id="b893" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是一个发送GraphQL请求来检索所有帖子的示例。</p><pre class="kn ko kp kq gt ms mr mt mu aw mv bi"><span id="ab4d" class="lq lr iq mr b gy mw mx l my mz">client.post("/graphql")<br/>     .sendJson(Map.of(<br/>         "query", "query posts{ allPosts{ id title content author{ name } comments{ content createdAt} createdAt}}",<br/>         "variables", Map.of()<br/>     ))<br/>     .onSuccess(<br/>         data -&gt; log.info("data of allPosts: {}", data.bodyAsString())<br/>     )<br/>     .onFailure(e -&gt; log.error("error: {}", e));</span></pre><p id="fcd7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请求正文格式如下。</p><pre class="kn ko kp kq gt ms mr mt mu aw mv bi"><span id="d399" class="lq lr iq mr b gy mw mx l my mz">{<br/>  "query": "...",<br/>  "operationName": "...",<br/>  "variables": { "myVariable": "someValue", ... }<br/>}</span></pre><p id="6e07" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mo mp mq mr b">query</code>正在接受字符串形式的<em class="nb">模式定义语言</em>。<em class="nb">操作名称</em>和<em class="nb">变量</em>是可选的。</p><p id="08d4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">响应体是这样的。</p><pre class="kn ko kp kq gt ms mr mt mu aw mv bi"><span id="3d03" class="lq lr iq mr b gy mw mx l my mz">{<br/>  "data": "...",<br/>  "errors": "..."<br/>}</span></pre><p id="b147" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当一个错误发生时，数据是空的，而errors将包含描述错误或异常的错误细节。</p><blockquote class="nc nd ne"><p id="12f3" class="jn jo nb jp b jq jr js jt ju jv jw jx nf jz ka kb ng kd ke kf nh kh ki kj kk ij bi translated">与RESTful APIs不同，在大多数情况下，如果出现错误，并且错误来自我们的应用程序本身，HTTP响应状态代码总是200。</p></blockquote><p id="eb51" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面的例子演示了如何创建一个帖子，然后通过id检索新创建的帖子。</p><pre class="kn ko kp kq gt ms mr mt mu aw mv bi"><span id="34cc" class="lq lr iq mr b gy mw mx l my mz">client.post("/graphql")<br/>     .sendJson(Map.of(<br/>         "query", "mutation newPost($input:CreatePostInput!){ createPost(createPostInput:$input)}",<br/>         "variables", Map.of(<br/>             "input", Map.of("title", "create post from WebClient", "content", "content of the new post")<br/>         )<br/>     ))<br/>     .onSuccess(<br/>         data -&gt; {<br/>             log.info("data of createPost: {}", data.bodyAsString());<br/>             var createdId = data.bodyAsJsonObject().getJsonObject("data").getString("createPost");<br/>             // get the created post.<br/>             getPostById(client, createdId);<br/>             // add comment.<br/>             addComment(client, createdId);<br/>         }<br/>     )<br/>     .onFailure(e -&gt; log.error("error: {}", e));</span><span id="ce05" class="lq lr iq mr b gy na mx l my mz">//getPostById<br/>private void getPostById(WebClient client, String id) {<br/>        client.post("/graphql")<br/>            .sendJson(Map.of(<br/>                "query", "query post($id:String!){ postById(postId:$id){ id title content author{ name } comments{ content createdAt} createdAt}}",<br/>                "variables", Map.of(<br/>                    "id", id<br/>                )<br/>            ))<br/>            .onSuccess(<br/>                data -&gt; log.info("data of postByID: {}", data.bodyAsString())<br/>            )<br/>            .onFailure(e -&gt; log.error("error: {}", e));<br/>    }</span></pre><p id="338e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">添加一个<code class="fe mo mp mq mr b">addComment</code>方法来演示为文章创建评论的过程，同时订阅<code class="fe mo mp mq mr b">commentAdded</code>事件(<em class="nb">订阅</em>)。</p><pre class="kn ko kp kq gt ms mr mt mu aw mv bi"><span id="3c88" class="lq lr iq mr b gy mw mx l my mz">private void addComment(WebClient client, String id) {<br/></span><span id="0e6d" class="lq lr iq mr b gy na mx l my mz">    // switch to HttpClient to handle WebSocket<br/>    var options = new HttpClientOptions()<br/>        .setWebSocketClosingTimeout(7200)<br/>        .setDefaultHost("localhost")<br/>        .setDefaultPort(8080);</span><span id="91ee" class="lq lr iq mr b gy na mx l my mz">    // see: <a class="ae kl" href="https://github.com/vert-x3/vertx-web/blob/master/vertx-web-graphql/src/test/java/io/vertx/ext/web/handler/graphql/ApolloWSHandlerTest.java" rel="noopener ugc nofollow" target="_blank">https://github.com/vert-x3/vertx-web/blob/master/vertx-web-graphql/src/test/java/io/vertx/ext/web/handler/graphql/ApolloWSHandlerTest.java</a><br/>    var httpClient = vertx.createHttpClient(options);<br/>    httpClient.webSocket("/graphql")<br/>        .onSuccess(ws -&gt; {<br/>            ws.closeHandler(v -&gt; log.info("websocket is being closed"));<br/>            ws.endHandler(v -&gt; log.info("websocket is being ended"));<br/>            ws.exceptionHandler(e -&gt; log.info("catching websocket exception: {}", e.getMessage()));</span><span id="7733" class="lq lr iq mr b gy na mx l my mz">            ws.textMessageHandler(text -&gt; {<br/>                //log.info("websocket message handler:{}", text);<br/>                JsonObject obj = new JsonObject(text);<br/>                ApolloWSMessageType type = ApolloWSMessageType.from(obj.getString("type"));<br/>                if (type.equals(CONNECTION_KEEP_ALIVE)) {<br/>                    return;// do nothing when ka.<br/>                } else if (type.equals(DATA)) {<br/>                    // handle the subscription `commentAdded` data.<br/>                    log.info("subscription commentAdded data: {}", obj.getJsonObject("payload").getJsonObject("data").getJsonObject("commentAdded"));<br/>                }<br/>            });</span><span id="40e9" class="lq lr iq mr b gy na mx l my mz">            JsonObject messageInit = new JsonObject()<br/>                .put("type", "connection_init")//this is required to initialize a connection.<br/>                .put("id", "1");</span><span id="77a8" class="lq lr iq mr b gy na mx l my mz">            JsonObject message = new JsonObject()<br/>                .put("payload", new JsonObject()<br/>                     .put("query", "subscription onCommentAdded { commentAdded { id content } }"))<br/>                .put("type", "start")<br/>                .put("id", "1");</span><span id="56b8" class="lq lr iq mr b gy na mx l my mz">            ws.write(messageInit.toBuffer());<br/>            ws.write(message.toBuffer());<br/>        })<br/>        .onFailure(e -&gt; log.error("error: {}", e));</span><span id="043a" class="lq lr iq mr b gy na mx l my mz">    addCommentToPost(client, id);<br/>    addCommentToPost(client, id);<br/>    addCommentToPost(client, id);<br/>}</span></pre><p id="ef8c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上面的<code class="fe mo mp mq mr b">addComment</code>方法中，我们切换到使用<code class="fe mo mp mq mr b">HttpClient</code>来处理WebSocket请求。</p><p id="68e0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，它打开一个到<em class="nb"> /graphql </em> WebSocket端点的WebSocket连接，然后将graphql请求作为消息负载写入，并使用一个<code class="fe mo mp mq mr b">textMessageHandler</code>回调钩子从服务器端获取WebSocket响应。</p><p id="544c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们看看上传的文件。</p><pre class="kn ko kp kq gt ms mr mt mu aw mv bi"><span id="3363" class="lq lr iq mr b gy mw mx l my mz">private void uploadFile(WebClient client) {<br/>    Buffer fileBuf = vertx.fileSystem().readFileBlocking("test.txt");<br/>    MultipartForm form = MultipartForm.create();<br/>    String query = """<br/>        mutation upload($file:Upload!){<br/>        upload(file:$file)<br/>    }<br/>    """;<br/>        var variables = new HashMap&lt;String, Object&gt;();<br/>    variables.put("file", null);<br/>    form.attribute("operations", Json.encode(Map.of("query", query, "variables", variables)));<br/>    form.attribute("map", Json.encode(Map.of("file0", List.of("variables.file"))));<br/>    form.textFileUpload("file0", "test.txt", fileBuf, "text/plain");</span><span id="74f8" class="lq lr iq mr b gy na mx l my mz">    client.post("/graphql")<br/>        .sendMultipartForm(form)<br/>        .onSuccess(<br/>        data -&gt; log.info("data of upload: {}", data.bodyAsString())<br/>    )<br/>    .onFailure(e -&gt; log.error("error: {}", e));<br/>}</span></pre><p id="aa0f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如您所见，使用高级WebClient API创建多部分表单并通过<code class="fe mo mp mq mr b">sendMultipartForm</code>直接发送是非常容易的。</p><p id="3108" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从我的Github 中获取<a class="ae kl" href="https://github.com/hantsy/vertx-sandbox/tree/master/graphql-webclient" rel="noopener ugc nofollow" target="_blank">示例代码。</a></p></div></div>    
</body>
</html>