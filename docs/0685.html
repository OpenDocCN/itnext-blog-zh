<html>
<head>
<title>How Do You Do Your Todos?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你是怎么做的？</h1>
<blockquote>原文：<a href="https://itnext.io/how-do-you-do-your-todos-cc6ece298bb2?source=collection_archive---------1-----------------------#2018-05-07">https://itnext.io/how-do-you-do-your-todos-cc6ece298bb2?source=collection_archive---------1-----------------------#2018-05-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="af85" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">带类型脚本的React 16.3中的状态管理选项</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/5ba8a7b1b18ff3cd1a4be7e90059a7ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YKcGcfLc7R5eRXhw."/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@tonywebster?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">托尼·韦伯斯特</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的“现代几何霓虹灯桥建筑在夜晚的人行道上，高架步道桥”</figcaption></figure><p id="7fbf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">随着Javascript应用程序从简单的脚本或简单的DOM操作发展到成熟的单页面应用程序，出现了几个规模问题。一个是代码组织的问题，经历了各种迭代(gulp、grunt、bower等)，直到<a class="ae kv" href="https://webpack.js.org/" rel="noopener ugc nofollow" target="_blank"> Webpack </a>和<a class="ae kv" href="https://www.npmjs.com/" rel="noopener ugc nofollow" target="_blank"> NPM </a>成为捆绑器和依赖管理器的首选。最终，社区中一些最聪明的人将注意力转向了数据的可伸缩性，状态管理成了热门话题。源自脸书的<a class="ae kv" href="http://www.flux.io/‎" rel="noopener ugc nofollow" target="_blank"> Flux </a>架构以不变性和单向数据流为核心，为各种状态管理解决方案提供了动力。</p><p id="6e87" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一些框架(例如Vue和Vuex)有一个官方的状态管理包。React有redux，这无疑是最受欢迎的解决方案，但是还有其他选择，甚至在redux中，围绕如何对副作用建模也有问题需要解决(将远程数据访问视为一种常见的副作用)。</p><p id="f16a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">随着React 16.3的到来，React Context API从架构中一个没有文档记录和不稳定的部分变成了另一个小型应用程序的潜在替代品。我决定使用6种不同的方法生成一个规范的Todo应用程序，以了解它们之间的不同之处。6个状态管理选项是:</p><ol class=""><li id="22ae" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated"><a class="ae kv" href="https://github.com/dfcook/react-todos" rel="noopener ugc nofollow" target="_blank">本地状态</a> —使用道具周围的设置状态和传递状态</li><li id="58c3" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><a class="ae kv" href="https://github.com/dfcook/react-todos/tree/master/src#redux-thunk" rel="noopener ugc nofollow" target="_blank"> Redux w/ redux-thunk </a></li><li id="43e8" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><a class="ae kv" href="https://github.com/dfcook/react-todos/tree/redux-observable" rel="noopener ugc nofollow" target="_blank">Redux w/Redux-observable</a></li><li id="b750" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><a class="ae kv" href="https://github.com/dfcook/react-todos/tree/redux-saga" rel="noopener ugc nofollow" target="_blank"> Redux w/ redux-saga </a></li><li id="2725" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><a class="ae kv" href="https://github.com/dfcook/react-todos/tree/mobx" rel="noopener ugc nofollow" target="_blank"> Mobx </a></li><li id="8c45" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><a class="ae kv" href="https://github.com/dfcook/react-todos/tree/react-context" rel="noopener ugc nofollow" target="_blank"> React Context </a> —设置状态并使用上下文将数据传递给子组件</li></ol><p id="86d2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里的代码是<a class="ae kv" href="https://github.com/dfcook/react-todos" rel="noopener ugc nofollow" target="_blank"/>。主分支使用本地状态实现基线解决方案，其他每个状态管理选项都是其分支，如自述文件中所述。每个解决方案也使用typescript和<a class="ae kv" href="https://ant.design/docs/react/introduce" rel="noopener ugc nofollow" target="_blank"> antd </a>组件库。</p><p id="8225" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">网上已经有一大堆例子，我认为值得再举一个的原因是我发现其中一些使用了旧版本的状态管理库或typescript，不能像写的那样工作。我希望随着新版本的发布，代码保持最新。希望这将有助于人们了解这些选项。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h2 id="6a60" class="mn mo iq bd mp mq mr dn ms mt mu dp mv lf mw mx my lj mz na nb ln nc nd ne nf bi translated"><a class="ae kv" href="https://github.com/dfcook/react-todos" rel="noopener ugc nofollow" target="_blank">本地状态</a></h2><p id="6308" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">React组件，至少是非功能性组件，都有自己的状态管理API setState。状态是组件的局部状态，用类级别的属性初始化:</p><pre class="kg kh ki kj gt nl nm nn no aw np bi"><span id="76fe" class="mn mo iq nm b gy nq nr l ns nt">interface AppState {<br/>  filter: string;<br/>  todosLoading: boolean;<br/>  todos: Todo[];<br/>}</span><span id="2b1a" class="mn mo iq nm b gy nu nr l ns nt">....</span><span id="0358" class="mn mo iq nm b gy nu nr l ns nt">state: AppState = {<br/>  filter: 'ALL',<br/>  todosLoading: false,<br/>  todos: []<br/>};</span></pre><p id="4559" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，对状态对象的更新不是通过直接改变该类级别的属性来进行的，而是应该调用setState，传入一组将与当前状态合并的状态更改，或者传入一个函数，该函数将组件的当前状态和属性作为参数，并再次返回要合并到组件状态中的更改对象。</p><pre class="kg kh ki kj gt nl nm nn no aw np bi"><span id="abc9" class="mn mo iq nm b gy nq nr l ns nt">addTodo = async (title: string) =&gt; {<br/>  const response = await api.add(title);</span><span id="293e" class="mn mo iq nm b gy nu nr l ns nt">  this.setState({<br/>    todos: [ ...this.state.todos, response.data ]<br/>  });<br/>}</span></pre><p id="1b67" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于状态对于单个组件是局部的，所以它通过props与子组件共享。Props可以是来自状态或函数的数据，这些数据将被调用以通过setState传播状态更新。</p><p id="abff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这已经是一个复杂的状态管理选项，基于不变性和单向数据流的合理原则。的确，正如Redux的创造者自己所说，<a class="ae kv" href="https://medium.com/@dan_abramov/you-might-not-need-redux-be46360cf367" rel="noopener">你可能不需要它</a>。然而，随着应用程序的增长，您可能会发现道具传递变得单调乏味且容易出错，因为应用程序的不同部分试图共享相同的数据，状态在层次结构中被推得越来越高。此时，您可能会决定需要Redux。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h2 id="2b0a" class="mn mo iq bd mp mq mr dn ms mt mu dp mv lf mw mx my lj mz na nb ln nc nd ne nf bi translated"><a class="ae kv" href="https://github.com/dfcook/react-todos/tree/master/src#redux-thunk" rel="noopener ugc nofollow" target="_blank"> Redux w/ redux-thunk </a></h2><p id="0e62" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated"><a class="ae kv" href="https://github.com/reactjs/redux" rel="noopener ugc nofollow" target="_blank"> Redux </a>是一个“JavaScript app的可预测状态容器”。这是一种获取本地状态并将其放入容器(称为存储)的方式，然后可以将它连接到应用程序中的组件，这些组件可以从存储中接收数据作为道具，并将更新作为操作发送到存储。对于来自面向对象背景的开发人员来说，redux的术语(reducers、action creators)可能显得晦涩难懂，但是一旦点击，它们就变得相对简单了，事实上redux本身的核心功能可以在大约20行代码中实现！</p><p id="ce92" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">缩减器是一个接受当前状态和动作对象并返回新状态的函数。</p><pre class="kg kh ki kj gt nl nm nn no aw np bi"><span id="dd2a" class="mn mo iq nm b gy nq nr l ns nt">export default (state: AppState, action: TodoAction): AppState =&gt; {<br/>  switch (action.type) {<br/>    case ActionTypes.ADD_TODO_SUCCESS:<br/>      return {<br/>        ...state,<br/>        todos: [ ...state.todos, (action as AddTodoAction).todo]<br/>      };<br/>  }<br/>}</span></pre><p id="9a97" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">动作是一个普通的javascript对象，带有一个类型属性(字符串)和一个有效负载。</p><pre class="kg kh ki kj gt nl nm nn no aw np bi"><span id="1ff6" class="mn mo iq nm b gy nq nr l ns nt">{<br/>  type: 'ADD_TODO_SUCCESS',<br/>  todo: {<br/>    text: 'Walk the dog',<br/>    completed: false<br/>  }<br/>}</span></pre><p id="edfd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Redux经常与React联系在一起，因为它与React配合得非常好，但是它也可以用于其他JavaScript框架。为了将React组件链接到存储，我们构建了“容器”，这些容器使用React-redux“connect”高阶函数将组件属性链接到状态属性和动作。然后，我们的组件可以很容易地测试功能组件，而不需要了解正在使用的状态管理系统。</p><p id="3f0f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://github.com/gaearon/redux-thunk" rel="noopener ugc nofollow" target="_blank"> Redux </a>通过使用中间件是可扩展的，其中一个是redux-thunk，它通过允许动作创建者返回一个函数而不是动作对象来解决异步动作的问题。这允许副作用(比如调用外部API)融入到我们的存储操作中。</p><pre class="kg kh ki kj gt nl nm nn no aw np bi"><span id="70c4" class="mn mo iq nm b gy nq nr l ns nt">export const addTodo = (title: string) =&gt; {<br/>  return async (dispatch: Dispatch) =&gt; {<br/>    const response = await api.add(title);<br/>    dispatch(addTodoSuccess(response.data));<br/>  };<br/>};</span></pre></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h2 id="a668" class="mn mo iq bd mp mq mr dn ms mt mu dp mv lf mw mx my lj mz na nb ln nc nd ne nf bi translated"><a class="ae kv" href="https://github.com/dfcook/react-todos/tree/redux-observable" rel="noopener ugc nofollow" target="_blank"> Redux w/ redux-observable </a></h2><p id="3c4c" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">Redux-observable是Redux异步操作的另一个中间件，它使用<a class="ae kv" href="http://reactivex.io/rxjs/" rel="noopener ugc nofollow" target="_blank">RxJS</a>observable从另一个方向解决问题。核心概念是“Epic”，一个接收动作流并返回动作流的函数。</p><pre class="kg kh ki kj gt nl nm nn no aw np bi"><span id="c214" class="mn mo iq nm b gy nq nr l ns nt">const fetchTodoEpic = (action$: ActionsObservable&lt;FetchTodosAction&gt;) =&gt;<br/>  action$<br/>    .ofType(ActionTypes.FETCH_TODOS)<br/>    .mergeMap((action: FetchTodosAction) =&gt;<br/>      Observable.ajax({<br/>        url: baseUrl,<br/>        withCredentials: false,<br/>        crossDomain: true<br/>      })<br/>      .map(req =&gt; fetchTodosSuccess(req.response)));</span></pre><p id="237d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">RxJS附带了大量的“操作符”，用于操作流的函数，比如上面例子中的mergeMap。例如，takeUntil操作符允许调度一个取消异步操作的动作，这是redux-observable的一大卖点。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h2 id="77cb" class="mn mo iq bd mp mq mr dn ms mt mu dp mv lf mw mx my lj mz na nb ln nc nd ne nf bi translated"><a class="ae kv" href="https://github.com/dfcook/react-todos/tree/redux-saga" rel="noopener ugc nofollow" target="_blank"> Redux w/ redux-saga </a></h2><p id="122a" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">Redux-saga是Redux的另一个中间件，旨在减轻副作用。它使用ES6生成器，这意味着异步流变得非常容易阅读(假设您理解<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function%2A" rel="noopener ugc nofollow" target="_blank">生成器</a>的语法)。</p><pre class="kg kh ki kj gt nl nm nn no aw np bi"><span id="c8d1" class="mn mo iq nm b gy nq nr l ns nt">export function* fetchTodos() {<br/>  yield put(updateLoading(true));<br/>  const response = yield call(api.fetch);<br/>  yield put(loadTodosSuccess(response.data));<br/>  yield put(updateLoading(false));<br/>}</span></pre><p id="b3ff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在3个redux中间件中，这是我最喜欢使用的一个，我认为故事和动作之间的分离使得最终用户代码非常可读，并且易于理解和测试。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h2 id="b479" class="mn mo iq bd mp mq mr dn ms mt mu dp mv lf mw mx my lj mz na nb ln nc nd ne nf bi translated"><a class="ae kv" href="https://github.com/dfcook/react-todos/tree/mobx" rel="noopener ugc nofollow" target="_blank"> Mobx </a></h2><p id="69a8" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated"><a class="ae kv" href="https://mobx.js.org/" rel="noopener ugc nofollow" target="_blank"> Mobx </a>采用了与Redux截然不同的状态管理方法，这对于来自Vue和Vuex的开发人员来说是非常熟悉的。Mobx存储是“反应式”的，您选择与您的状态一致的数据结构的形状，然后使用注释将其标记为可观察的。然后，您的组件使用一个观察者注释，使它们能够对存储状态的变化做出反应。</p><pre class="kg kh ki kj gt nl nm nn no aw np bi"><span id="5a03" class="mn mo iq nm b gy nq nr l ns nt">@observable todosLoading = false;<br/>@observable todos: Todo[] = [];</span><span id="2a2d" class="mn mo iq nm b gy nu nr l ns nt">async refreshTodos() {<br/>  this.todosLoading = true;<br/>  <br/>  const response = await api.fetch();<br/>  this.todos = response.data;</span><span id="b61c" class="mn mo iq nm b gy nu nr l ns nt">  this.todosLoading = false;<br/>}</span></pre><p id="f434" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">来自Redux和setState，这有点文化冲击，不变性在哪里？它当然非常不同，但是它允许一些很好的抽象，例如computed注释允许将计算属性逻辑放在存储中。</p><pre class="kg kh ki kj gt nl nm nn no aw np bi"><span id="d38c" class="mn mo iq nm b gy nq nr l ns nt">@computed get filteredTodos() {<br/>  switch (this.filter) {<br/>    case 'ACTIVE':<br/>      return this.todos.filter(todo =&gt; !todo.completed);</span><span id="c64d" class="mn mo iq nm b gy nu nr l ns nt">    case 'COMPLETED':<br/>      return this.todos.filter(todo =&gt; todo.completed);</span><span id="cb29" class="mn mo iq nm b gy nu nr l ns nt">    default:<br/>      return this.todos;<br/>  }<br/>}</span></pre></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h2 id="960b" class="mn mo iq bd mp mq mr dn ms mt mu dp mv lf mw mx my lj mz na nb ln nc nd ne nf bi translated"><a class="ae kv" href="https://github.com/dfcook/react-todos/tree/react-context" rel="noopener ugc nofollow" target="_blank">反应上下文</a></h2><p id="024b" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">React的上下文API长期以来一直被标记为实验性的，可能会发生变化，但是它的消费者/提供者模型是Redux的提供者的基础。在16.3版本中，API已经稳定下来，现在是状态管理的另一个选择。</p><p id="82a2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">类似于本地状态选项状态和对其进行操作的功能位于层次结构顶端的组件中。然而，它不是通过props将状态传递给子组件，而是使用createContext函数将状态放在一个上下文中。</p><pre class="kg kh ki kj gt nl nm nn no aw np bi"><span id="56e3" class="mn mo iq nm b gy nq nr l ns nt">export interface AppState {<br/>  filter: string;<br/>  loading: boolean;<br/>  todos: Todo[];<br/>  updateFilter: (filter: string) =&gt; void;<br/>  addTodo: (title: string) =&gt; void;<br/>  toggleTodo: (todo: Todo) =&gt; void;<br/>  deleteTodo: (todo: Todo) =&gt; void;<br/>}</span><span id="6424" class="mn mo iq nm b gy nu nr l ns nt">export const TodoContext = React.createContext&lt;AppState&gt;({<br/>  filter: 'ALL',<br/>  loading: false,<br/>  todos: [],<br/>  updateFilter: (filter: string) =&gt; {},<br/>  addTodo: (title: string) =&gt; {},<br/>  toggleTodo: (todo: Todo) =&gt; {},<br/>  deleteTodo: (todo: Todo) =&gt; {}<br/>});</span></pre><p id="1080" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面代码中的TodoContext是一个具有两个属性的对象，Provider和Consumer，然后可以在我们的组件JSX中使用它们将组件与上下文挂钩。值得注意的是，消费者使用另一种模式，即“render prop ”,以允许在呈现子组件时访问上下文。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><p id="e497" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我希望上面的简要描述，更重要的是，代码对每种状态管理方法都有一个简单的介绍。</p></div></div>    
</body>
</html>