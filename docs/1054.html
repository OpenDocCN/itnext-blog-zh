<html>
<head>
<title>Cratebox.io — State Management</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Cratebox.io —状态管理</h1>
<blockquote>原文：<a href="https://itnext.io/cratebox-io-state-management-c568a8ffe401?source=collection_archive---------3-----------------------#2018-07-12">https://itnext.io/cratebox-io-state-management-c568a8ffe401?source=collection_archive---------3-----------------------#2018-07-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/29fd47d68aec3252e1f53f529260bf11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*PdQSHD73l3g1HdHo"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">“大型档案馆架子上的活页夹和盒子”，作者:塞缪尔·泽勒(T0)在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上发表</figcaption></figure><p id="3070" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">谈到国家管理，这些天你有几个选择；可以选择<a class="ae kc" href="https://github.com/mobxjs/mobx" rel="noopener ugc nofollow" target="_blank"> MobX、</a> <a class="ae kc" href="https://github.com/mobxjs/mobx-state-tree/" rel="noopener ugc nofollow" target="_blank"> MobX状态树</a>或者<a class="ae kc" href="https://github.com/reduxjs/redux" rel="noopener ugc nofollow" target="_blank"> Redux </a>。你选择哪个库并不重要，它们都能完成任务，每一个都有自己的方式，但是它们做的每一件事都像预期的那样。</p><p id="743d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">无论您是将它们与React、Vue或Angular一起使用，还是仅仅与普通的vanila JavaScript一起使用，这些库都设计得很好，可以在任何环境中使用它们自己的UI库/框架绑定。</p><p id="bfaf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">免责声明:我不想在这个话题上挑拨离间，因为这不是我的本意。</em></p><p id="dcce" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">作为上述所有库的替代，来玩一个新的库:<strong class="kf ir"> Cratebox </strong>。</p><figure class="ld le lf lg gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lc"><img src="../Images/76eee4497a3468951799a4cec27b190c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Ld-hIzp44uugJ5Bu"/></div></div></figure></div><div class="ab cl lh li hu lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ij ik il im in"><h1 id="bf0a" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">动机</h1><p id="f58e" class="pw-post-body-paragraph kd ke iq kf b kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated">我开始开发<strong class="kf ir"> Cratebox </strong>来证明自己能够以顶尖开发人员为榜样构建一个强大的状态管理库，这些开发人员包括<a class="ae kc" href="https://github.com/mweststrate" rel="noopener ugc nofollow" target="_blank"><em class="lb">Michel west strate</em></a><a class="ae kc" href="https://github.com/gaearon" rel="noopener ugc nofollow" target="_blank"><em class="lb">Dan abra mov</em></a><a class="ae kc" href="https://github.com/jamiebuilds" rel="noopener ugc nofollow" target="_blank"><em class="lb">Jam</em>es<em class="lb">Kyle</em></a>等等。我想要像<em class="lb"> MobX状态树</em>一样健壮和类型化的东西，但也想要一些清晰和易于使用的东西，这就是为什么我构建了<strong class="kf ir"> Cratebox </strong>，作为<em class="lb"> MobX状态树</em>和<em class="lb"> Redux </em>之间的一个中间点，健壮并带有一个声明性和简单的API，总是能完成工作。</p><h1 id="718e" class="lo lp iq bd lq lr mr lt lu lv ms lx ly lz mt mb mc md mu mf mg mh mv mj mk ml bi translated">特征</h1><p id="3315" class="pw-post-body-paragraph kd ke iq kf b kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated">这些是使<strong class="kf ir"> Cratebox </strong>成为你的好工具的一些关键特征:</p><h2 id="aa7d" class="mw lp iq bd lq mx my dn lu mz na dp ly ko nb nc mc ks nd ne mg kw nf ng mk nh bi translated">简单的</h2><p id="30a8" class="pw-post-body-paragraph kd ke iq kf b kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated">考虑到极简主义，公开的API将为您提供您需要的一切，而不会有任何麻烦。</p><h2 id="cc44" class="mw lp iq bd lq mx my dn lu mz na dp ly ko nb nc mc ks nd ne mg kw nf ng mk nh bi translated">打字</h2><p id="c49e" class="pw-post-body-paragraph kd ke iq kf b kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated">构建时考虑到类型，您将能够通过类型安全检查来创建坚如磐石的模型。</p><h2 id="e08e" class="mw lp iq bd lq mx my dn lu mz na dp ly ko nb nc mc ks nd ne mg kw nf ng mk nh bi translated">固执己见的</h2><p id="9fda" class="pw-post-body-paragraph kd ke iq kf b kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated">你不必担心如何构建和处理复杂的东西，我们已经设置了一些简单的规则和方法，所以我们确保一切都可以开箱即用。</p></div><div class="ab cl lh li hu lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ij ik il im in"><h1 id="b4a2" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">类型系统</h1><p id="8757" class="pw-post-body-paragraph kd ke iq kf b kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated">让我们来谈谈与<strong class="kf ir">弹匣</strong>一起提供的<strong class="kf ir">型系统</strong>。</p><p id="bdc9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">类型系统是为你建立的，以确保一切都应该按照预期工作；例如，如果您声明模型的某个属性是string类型的，并且您试图为它设置一个不同的类型(无论是不是偶然的)(有一个小的例外，我们将在后面解释)，比如说一个数字，它将抱怨收到的类型与预期的不同。</p><p id="90a3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们更深入地了解一下<strong class="kf ir">型系统</strong>。我们现在将解释我们在<strong class="kf ir">盒</strong>中的两种不同类型。</p><h2 id="0657" class="mw lp iq bd lq mx my dn lu mz na dp ly ko nb nc mc ks nd ne mg kw nf ng mk nh bi translated"><strong class="ak">基本类型</strong></h2><p id="3473" class="pw-post-body-paragraph kd ke iq kf b kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated">基本类型是任何(几乎所有)编程语言的核心类型。我们使用这种类型为我们的数据构建一个可靠的结构。这些类型如下:</p><ul class=""><li id="9a8b" class="ni nj iq kf b kg kh kk kl ko nk ks nl kw nm la nn no np nq bi translated"><strong class="kf ir">字符串类型— </strong>此类型可以包含字符串和null类型的任何值。</li><li id="02ed" class="ni nj iq kf b kg nr kk ns ko nt ks nu kw nv la nn no np nq bi translated"><strong class="kf ir">数字类型— </strong>此类型可以包含数字类型的任何值和空值。</li><li id="c28f" class="ni nj iq kf b kg nr kk ns ko nt ks nu kw nv la nn no np nq bi translated"><strong class="kf ir">布尔类型— </strong>该类型可以包含布尔类型的任何值。</li><li id="12d5" class="ni nj iq kf b kg nr kk ns ko nt ks nu kw nv la nn no np nq bi translated"><strong class="kf ir"> Null类型— </strong>此类型可以包含任何Null类型的值。</li><li id="c647" class="ni nj iq kf b kg nr kk ns ko nt ks nu kw nv la nn no np nq bi translated"><strong class="kf ir">未定义类型— </strong>该类型可以包含任何未定义类型的值。</li><li id="1fbe" class="ni nj iq kf b kg nr kk ns ko nt ks nu kw nv la nn no np nq bi translated"><strong class="kf ir">日期类型— </strong>此类型可以包含日期类型的任何值。</li></ul><p id="9191" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有了这些基本类型，您就可以用类型安全检查构建一个简单的数据结构。让我们看看如何在一个最小的例子中使用它:</p><pre class="ld le lf lg gt nw nx ny nz aw oa bi"><span id="64be" class="mw lp iq nx b gy ob oc l od oe">{<br/>    name: types.string,<br/>    lastName: types.string,<br/>    email: types.string,<br/>    age: types.number,<br/>    birthDate: types.date,<br/>    admin: types.boolean,<br/>}</span></pre><p id="66de" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们检查一下前面的结构，你现在看到的这个物体就是我们所说的<strong class="kf ir">模型物体</strong>。一个<strong class="kf ir">模型对象</strong>是一个属性和类型的结构，我们将把它声明为某个商店的结构。</p><p id="e75c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以看到它有几个属性，在这个例子中，有六个，每个都是按照我们想要的方式键入的。</p><p id="9c97" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">姓名</em>、<em class="lb">姓氏</em>和<em class="lb">电子邮件</em>属性必须包含一个字符串或null类型的值。<em class="lb">年龄</em>属性必须包含一个number或null类型的值。<em class="lb">出生日期</em>属性必须包含日期类型的值(不要与格式化的类似日期的字符串混淆，那是无效的)或null。</p><h2 id="ff81" class="mw lp iq bd lq mx my dn lu mz na dp ly ko nb nc mc ks nd ne mg kw nf ng mk nh bi translated"><strong class="ak">高级类型</strong></h2><ul class=""><li id="d298" class="ni nj iq kf b kg mm kk mn ko of ks og kw oh la nn no np nq bi translated"><strong class="kf ir">数组类型— </strong>该类型可以包含一个特定基本类型或高级类型(如冻结)的数组，通过使用最后一个，我们将拥有一个<strong class="kf ir">复杂类型</strong>。</li><li id="fb6a" class="ni nj iq kf b kg nr kk ns ko nt ks nu kw nv la nn no np nq bi translated"><strong class="kf ir">文字类型— </strong>这种类型只能包含一个字符串文字，并且会根据这个文字检查所有内容，以确保它是指定的那个。</li><li id="9c74" class="ni nj iq kf b kg nr kk ns ko nt ks nu kw nv la nn no np nq bi translated"><strong class="kf ir">枚举类型— </strong>该类型可以包含一个文字字符串数组，它将作为您所需目的的枚举(例如，通常用于UI视图路由)。<strong class="kf ir">枚举类型</strong>是<strong class="kf ir">文字类型</strong>的<strong class="kf ir">数组类型</strong>的示例复杂类型。它是为您开箱即用而内置的。</li><li id="40ff" class="ni nj iq kf b kg nr kk ns ko nt ks nu kw nv la nn no np nq bi translated"><strong class="kf ir">冻结类型— </strong>该类型将包含一个<strong class="kf ir">模型对象</strong>结构(就像我们之前展示的那个),该结构将对您在创建该类型时声明的每个属性进行所有类型检查。</li></ul><pre class="ld le lf lg gt nw nx ny nz aw oa bi"><span id="1abf" class="mw lp iq nx b gy ob oc l od oe">// Declare a TODO type<br/>const todo = types.frozen({<br/>  id: types.number,<br/>  title: types.string,<br/>  description: types.string,<br/>  done: types.boolean<br/>});</span><span id="8cef" class="mw lp iq nx b gy oi oc l od oe">// Describe the TODOS store<br/>crate.describeStore({<br/>  identifier: "todoStore",<br/>  model: {<br/>    todos: types.array(todo)<br/>  }<br/>});</span></pre><p id="47c4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如你在上面的例子中看到的，我们已经通过使用<strong class="kf ir">冻结类型</strong>声明了一个<strong class="kf ir"> Todo类型</strong>。之后，我们描述一个商店(如果你不能理解，不要担心，我保证我们一会儿就会看到它，一切都会很清楚)并且模型包含一个名为<em class="lb"> todos </em>的属性，该属性是一个<strong class="kf ir">复杂类型</strong>(正如我们之前所学的)，因为它是一个<strong class="kf ir">冻结类型的<strong class="kf ir">数组类型</strong>。</strong></p></div><div class="ab cl lh li hu lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ij ik il im in"><h1 id="e3c1" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">描述商店</h1><p id="ffd4" class="pw-post-body-paragraph kd ke iq kf b kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated">在<strong class="kf ir"> Cratebox </strong>中，声明你的商店结构的方法是用<strong class="kf ir"> describeStore </strong> exposed方法描述它。</p><p id="bcef" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> describeStore </strong>方法将<strong class="kf ir">商店模型</strong>对象作为具有以下属性的单个参数:</p><ol class=""><li id="0b61" class="ni nj iq kf b kg kh kk kl ko nk ks nl kw nm la oj no np nq bi translated">标识符:你描述的商店的标识符。</li><li id="26e2" class="ni nj iq kf b kg nr kk ns ko nt ks nu kw nv la oj no np nq bi translated">模型:这个商店的描述，它被表示为一个<strong class="kf ir">模型对象</strong>，就像我们上面描述的那个。你不能用一个不包含至少一个类型化属性的<strong class="kf ir">模型对象</strong>来描述一个商店。</li></ol><pre class="ld le lf lg gt nw nx ny nz aw oa bi"><span id="0c90" class="mw lp iq nx b gy ob oc l od oe">const crate = cratebox();</span><span id="c0fb" class="mw lp iq nx b gy oi oc l od oe">crate.describeStore({<br/>  identifier: 'user',<br/>  model: {<br/>    name: types.string,<br/>    lastName: types.string<br/>});</span></pre><p id="c419" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的例子中，我们描述了一个简单的<em class="lb">用户商店。</em>现在，我们可以继续将更改发送到该存储，这样它就会充满您的数据。</p><p id="5c99" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意:不能用相同的标识符描述两个商店。</p><h1 id="87e0" class="lo lp iq bd lq lr mr lt lu lv ms lx ly lz mt mb mc md mu mf mg mh mv mj mk ml bi translated">将更改分派到存储</h1><p id="7ca1" class="pw-post-body-paragraph kd ke iq kf b kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated">在<strong class="kf ir"> Cratebox </strong>中，很容易将变更发送到某个商店。我们已经为你展示了一个简单的方法来处理这个问题，这个方法叫做<strong class="kf ir"> dispatch </strong>(显然……)</p><p id="62a9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">分派</strong>方法将<strong class="kf ir">商店模型</strong>对象作为具有以下属性的单个参数:</p><ol class=""><li id="c6db" class="ni nj iq kf b kg kh kk kl ko nk ks nl kw nm la oj no np nq bi translated">Identifier:要将更改发送到的存储的标识符。</li><li id="0dbd" class="ni nj iq kf b kg nr kk ns ko nt ks nu kw nv la oj no np nq bi translated">Model:您希望在商店中更改的属性值。</li></ol><pre class="ld le lf lg gt nw nx ny nz aw oa bi"><span id="625f" class="mw lp iq nx b gy ob oc l od oe">crate.dispatch({<br/>  identifier: 'user',<br/>  model: {<br/>    name: 'Alex',<br/>    lastName: 'Casillas',<br/>  }<br/>});</span></pre><p id="2da8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的例子将把模型中给定的变更发送到商店。</p><p id="4c74" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请注意，这不会返回任何内容，因为这不是预期的行为。要获得我们刚才所做的更改，您必须获得商店的当前状态。</p><h1 id="833b" class="lo lp iq bd lq lr mr lt lu lv ms lx ly lz mt mb mc md mu mf mg mh mv mj mk ml bi translated">获取商店的状态</h1><p id="ab1d" class="pw-post-body-paragraph kd ke iq kf b kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated">在<strong class="kf ir"> Cratebox </strong>中获取商店的状态是小菜一碟，我们已经为您准备好了，我们已经为您展示了一个简单的方法，它将让您检索特定商店的状态，这个方法被称为<strong class="kf ir"> getState </strong>(显然……)</p><p id="3e1f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> getState </strong>方法将商店标识符作为单个参数，并将返回当前的<strong class="kf ir">模型</strong>状态。</p><pre class="ld le lf lg gt nw nx ny nz aw oa bi"><span id="4436" class="mw lp iq nx b gy ob oc l od oe">const user = crate.getState('user');<br/>console.log(user);<br/>// Outputs { name: 'Alex', lastName: 'Casillas' }</span></pre><p id="534d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果存储中没有数据，它将返回一个空值<strong class="kf ir">。</strong></p><h1 id="498c" class="lo lp iq bd lq lr mr lt lu lv ms lx ly lz mt mb mc md mu mf mg mh mv mj mk ml bi translated">订阅存储更改</h1><p id="1ace" class="pw-post-body-paragraph kd ke iq kf b kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated">从您的存储中自动获取更改的一种方式是订阅它，这样，每次您向存储分派新的更改时，它都会自动为您提供最新的数据模型。</p><pre class="ld le lf lg gt nw nx ny nz aw oa bi"><span id="75d7" class="mw lp iq nx b gy ob oc l od oe">const unsubscribe = crate.subscribe('user', model =&gt; {<br/>  console.log('User Changes: ', model);<br/>  // Outputs at dispatch: { name: 'Alex', lastName: 'Casillas' }<br/>}</span><span id="7211" class="mw lp iq nx b gy oi oc l od oe">crate.dispatch({<br/>  identifier: 'user',<br/>  model: {<br/>    name: 'Alex',<br/>    lastName: 'Casillas',<br/>  }<br/>});</span></pre><h1 id="1fe9" class="lo lp iq bd lq lr mr lt lu lv ms lx ly lz mt mb mc md mu mf mg mh mv mj mk ml bi translated">取消订阅商店更改</h1><p id="f0b3" class="pw-post-body-paragraph kd ke iq kf b kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated">如果您想删除每次调度更改时触发您的订阅的侦听器，您可以通过调用由<strong class="kf ir"> subscribe </strong>方法返回的函数来实现。</p><pre class="ld le lf lg gt nw nx ny nz aw oa bi"><span id="deee" class="mw lp iq nx b gy ob oc l od oe">const unsubscribe = crate.subscribe('user', model =&gt; {<br/>  console.log('User Changes: ', model);<br/>  // Outputs at dispatch: { name: 'Alex', lastName: 'Casillas' }<br/>}</span><span id="ad87" class="mw lp iq nx b gy oi oc l od oe">crate.dispatch({<br/>  identifier: 'user',<br/>  model: {<br/>    name: 'Alex',<br/>    lastName: 'Casillas',<br/>  }<br/>});</span><span id="f5c6" class="mw lp iq nx b gy oi oc l od oe">unsubscribe(); // Calling this will make the subscription stop</span></pre></div><div class="ab cl lh li hu lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ij ik il im in"><h1 id="b252" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">时间旅行</h1><p id="8a6c" class="pw-post-body-paragraph kd ke iq kf b kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated"><strong class="kf ir"> Cratebox </strong>通过两种简单的方法为你的时间旅行提供开箱即用，分别是:<strong class="kf ir">向前旅行</strong>和<strong class="kf ir">向后旅行</strong>。</p><h2 id="b751" class="mw lp iq bd lq mx my dn lu mz na dp ly ko nb nc mc ks nd ne mg kw nf ng mk nh bi translated">向前和向后移动</h2><p id="a417" class="pw-post-body-paragraph kd ke iq kf b kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated">为了及时向前移动，你只需要调用<strong class="kf ir"> travelForwards </strong>方法，它将给定商店的当前状态向前移动一步。</p><p id="24a7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果没有前进的步骤，你就不能向前进行时间旅行。每次调用<strong class="kf ir"> travelForwards </strong>方法时，将会调用您对正在进行时间旅行的商店的所有订阅。</p><p id="c352" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要回到过去，你只需要调用<strong class="kf ir"> travelBackwards </strong>方法，它会将给定商店的当前状态向后移动。</p><p id="a2b1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果没有后退的方法，你就不能回到过去。每次调用<strong class="kf ir">travel backward</strong>方法时，都会调用您对正在进行时间旅行的商店的所有订阅。</p><pre class="ld le lf lg gt nw nx ny nz aw oa bi"><span id="2d2d" class="mw lp iq nx b gy ob oc l od oe">const unsubscribe = crate.subscribe('user', model =&gt; {<br/>  console.log('User Changes: ', model);<br/>  // Outputs at first dispatch<br/>  // { name: 'Alex', lastName: 'Casillas' }<br/>  // Outputs at second dispatch<br/>  // { name: 'Antonio', lastName: 'Cobos' }<br/>  // Outputs at traveling backwards<br/>  // { name: 'Alex', lastName: 'Casillas' }<br/>  // Outputs at traveling forwards<br/>  // { name: 'Antonio', lastName: 'Cobos' }<br/>}</span><span id="b388" class="mw lp iq nx b gy oi oc l od oe">crate.dispatch({<br/>  identifier: 'user',<br/>  model: {<br/>    name: 'Alex',<br/>    lastName: 'Casillas',<br/>  }<br/>});</span><span id="4c26" class="mw lp iq nx b gy oi oc l od oe">crate.dispatch({<br/>  identifier: 'user',<br/>  model: {<br/>    name: 'Antonio',<br/>    lastName: 'Cobos',<br/>  }<br/>});</span><span id="58da" class="mw lp iq nx b gy oi oc l od oe">crate.travelBackwards('user');<br/>crate.travelForwards('user');</span></pre></div><div class="ab cl lh li hu lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ij ik il im in"><h1 id="2e9d" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">演示时间🙌</h1><p id="87f7" class="pw-post-body-paragraph kd ke iq kf b kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated">现在我们要展示一个我们准备好的小演示。这是一个ToDo应用程序(是的，一个ToDo App，另一个，简单但有效的展示)</p><figure class="ld le lf lg gt jr"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="0b65" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个演示使用了<strong class="kf ir">盒反应</strong>，官方<em class="lb">反应</em>绑定<strong class="kf ir">盒反应</strong>。请随意使用演示，尝试新事物，并给我们一些反馈。那真是太感谢了:)</p><p id="0e51" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">希望你喜欢这个阅读，它很好，很有趣，如果你有任何其他问题，你可以在twitter和Github上通过<a class="ae kc" href="https://twitter.com/alexvcasillas" rel="noopener ugc nofollow" target="_blank"> @alexvcasillas </a>联系我:)</p></div></div>    
</body>
</html>