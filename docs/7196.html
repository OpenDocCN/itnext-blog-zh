<html>
<head>
<title>🚀Boost NodeJS Scalability with Multi-Processing Architecture🚀</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">🚀借助多处理架构提升节点的可扩展性🚀</h1>
<blockquote>原文：<a href="https://itnext.io/boost-nodejs-scalability-with-multi-processing-architecture-6d7bd03c892c?source=collection_archive---------1-----------------------#2022-07-12">https://itnext.io/boost-nodejs-scalability-with-multi-processing-architecture-6d7bd03c892c?source=collection_archive---------1-----------------------#2022-07-12</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><figure class="gl gn jp jq jr js gh gi paragraph-image"><div role="button" tabindex="0" class="jt ju di jv bf jw"><div class="gh gi jo"><img src="../Images/b112689753dcd0c8d007bc56f74c83ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V8LC57WgyAi3xKoAcyBF9Q.jpeg"/></div></div></figure><p id="ebc7" class="pw-post-body-paragraph jz ka ir kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ik bi translated">过去几个月，我不得不面对扩展现有NodeJS应用程序后端的挑战。该应用程序通过使用定制的解析器和解释器处理文本来生成巨大的PDF文档。我没有看到很多如何实现这一点的例子，所以我采取了一种务实的方法来解决这个问题。</p><p id="0762" class="pw-post-body-paragraph jz ka ir kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ik bi translated">用户对工作负载的压力越大，吞吐量急剧下降的幅度就越大，延迟从几毫秒增加到几秒。仔细测量应用程序，我们意识到事件循环在很长一段时间内都非常繁忙地使用CPU。这是不可接受的情况，因为后端没有正确扩展。迫切需要对其进行扩展并卸载一些工作。</p><p id="3f55" class="pw-post-body-paragraph jz ka ir kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ik bi translated"><strong class="kb is">症状</strong>🤢：</p><ul class=""><li id="501c" class="ky kz ir kb b kc kd kg kh kk la ko lb ks lc kw ld le lf lg bi translated">在REST端点上，延迟从毫秒增加到秒。☠️</li><li id="6095" class="ky kz ir kb b kc lh kg li kk lj ko lk ks ll kw ld le lf lg bi translated">新用户必须等待才能进入应用程序。😞</li><li id="d3d3" class="ky kz ir kb b kc lh kg li kk lj ko lk ks ll kw ld le lf lg bi translated">指标显示了高CPU利用率和高事件循环延迟(nodejs veterants将凭直觉解决这个问题)。🔥</li></ul></div><div class="ab cl lm ln hu lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="ik il im in io"><h1 id="94c4" class="lt lu ir bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">向外扩展的建筑决策🕵🏻</h1><p id="b1cb" class="pw-post-body-paragraph jz ka ir kb b kc mr ke kf kg ms ki kj kk mt km kn ko mu kq kr ks mv ku kv kw ik bi translated">我们都知道，NodeJS在处理CPU密集型任务时是很糟糕的，因为它让事件循环超级繁忙。它提供了一些本机机制来卸载一些工作，如<strong class="kb is"> <em class="mw"> worker_threads。这可能不是解决长时间运行任务的正确方法，而且每次应用程序必须处理大任务时，它可能会导致创建长时间运行线程的巨大开销。它还强制NodeJS垂直缩放，而不是水平缩放。</em></strong></p><p id="4464" class="pw-post-body-paragraph jz ka ir kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ik bi translated">我选择了一条不同的道路，我决定将有问题的进程卸载到一个专用的<strong class="kb is"> <em class="mw">工作进程</em> </strong>。它是应用程序的一个专用部分，运行在为工作优化的专用资源上。</p><p id="8665" class="pw-post-body-paragraph jz ka ir kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ik bi translated"><strong class="kb is">该方法的用例</strong>:</p><ul class=""><li id="062f" class="ky kz ir kb b kc kd kg kh kk la ko lb ks lc kw ld le lf lg bi translated">卸载CPU密集型任务。🕢</li><li id="b7f3" class="ky kz ir kb b kc lh kg li kk lj ko lk ks ll kw ld le lf lg bi translated">卸载重复性任务或cron作业，如日常ETL作业。⚡</li></ul><p id="20ce" class="pw-post-body-paragraph jz ka ir kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ik bi translated">该过程还需要重用应用程序的一些部分，并访问相同的现有存储库或域服务。这种设计有两种可能性:</p><ol class=""><li id="bdfc" class="ky kz ir kb b kc kd kg kh kk la ko lb ks lc kw mx le lf lg bi translated">使用不同的代码库并创建专门的服务。❌</li><li id="b4f9" class="ky kz ir kb b kc lh kg li kk lj ko lk ks ll kw mx le lf lg bi translated">使用相同的代码库，根据环境以<strong class="kb is"> <em class="mw"> api模式</em> </strong>或<strong class="kb is"> <em class="mw">工作模式</em> </strong>运行应用程序。事实证明，这样做大大减少了向外扩展应用程序的开销，并允许我们重用现有的代码库。✅</li></ol><p id="9506" class="pw-post-body-paragraph jz ka ir kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ik bi translated">在这篇文章里，<strong class="kb is"> <em class="mw">选项2 </em> </strong>已经取了，都是关于它的。如果您认为选项1可能是一种更好的方法，并且您需要更高的隔离级别，或者如果您决定使用另一种适合CPU工作负载的语言(如Golang ),那么它是完全合适的。您可能需要选项2的原因是，您需要共享许多依赖项，并且共享相同的代码库以避免开发开销是有意义的。我将分享在生产中拥有防弹多核单代码库架构的细节。</p><p id="31c3" class="pw-post-body-paragraph jz ka ir kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ik bi translated">此外，让我们提一下这个有趣的模式，微软架构更好地描述了关于<a class="ae kx" href="https://docs.microsoft.com/en-us/azure/architecture/guide/architecture-styles/web-queue-worker" rel="noopener ugc nofollow" target="_blank">网络队列工作者模式</a>。</p><figure class="mz na nb nc gt js gh gi paragraph-image"><div role="button" tabindex="0" class="jt ju di jv bf jw"><div class="gh gi my"><img src="../Images/036ac0bde24b72b682fb42c80a56b6d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EMmJK1PXt6LiX95bLLSqxA.png"/></div></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk translated">微软</figcaption></figure><h1 id="8561" class="lt lu ir bd lv lw nh ly lz ma ni mc md me nj mg mh mi nk mk ml mm nl mo mp mq bi translated">文件夹结构🥪</h1><p id="e89a" class="pw-post-body-paragraph jz ka ir kb b kc mr ke kf kg ms ki kj kk mt km kn ko mu kq kr ks mv ku kv kw ik bi translated">这里您可以看到nodejs项目的结构。这是一个常规的分层REST api。这种文件夹结构在中小型项目中很常见，可能您有类似的东西，或者您可能使用了一种更加<strong class="kb is"><em class="mw"/></strong>或<strong class="kb is"> <em class="mw">干净的架构</em> </strong>方法，在本文中我们将保持它的简单，我们将重点关注创建一个<strong class="kb is"> <em class="mw">单多处理器代码库</em> </strong>的挑战。</p><figure class="mz na nb nc gt js gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/53e103b9c3dd03281c181a9df54dc113.png" data-original-src="https://miro.medium.com/v2/resize:fit:1112/format:webp/1*OifnDpy18koSiJ2M8Q8nyA.png"/></div></figure><p id="3192" class="pw-post-body-paragraph jz ka ir kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ik bi translated">在上面的文件夹结构中，有3个重要文件夹(<strong class="kb is"> <em class="mw"> web、工人和工作</em> </strong>)和1个<strong class="kb is"> <em class="mw">流程调度员</em> </strong>文件:</p><ul class=""><li id="c581" class="ky kz ir kb b kc kd kg kh kk la ko lb ks lc kw ld le lf lg bi translated"><strong class="kb is"> <em class="mw"> Web </em> </strong>文件夹只包含Api相关的东西。</li><li id="1de1" class="ky kz ir kb b kc lh kg li kk lj ko lk ks ll kw ld le lf lg bi translated"><strong class="kb is"> <em class="mw">工作者</em> </strong>将包含不同的工作者，并且那些工作者可能在同一个进程中隔离运行或者进入不同的进程。这种架构将使其更加灵活，这完全取决于您的决定。</li><li id="77eb" class="ky kz ir kb b kc lh kg li kk lj ko lk ks ll kw ld le lf lg bi translated"><strong class="kb is"> <em class="mw">作业</em> </strong>将包含重复性任务，例如ETL流程。对他们来说，有一个隔离的过程可能有意义，也可能没有意义，这是另一个隔离点，但是这个架构让你来决定。</li></ul><p id="fb2e" class="pw-post-body-paragraph jz ka ir kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ik bi translated"><strong class="kb is"> <em class="mw"> index.ts </em> </strong>作为一个调度器，它将决定如何创建流程。</p><h1 id="b0ea" class="lt lu ir bd lv lw nh ly lz ma ni mc md me nj mg mh mi nk mk ml mm nl mo mp mq bi translated">技术栈🕹️</h1><p id="5655" class="pw-post-body-paragraph jz ka ir kb b kc mr ke kf kg ms ki kj kk mt km kn ko mu kq kr ks mv ku kv kw ik bi translated">多核架构需要一些支持技术来实现可扩展性的目标。作为一名架构师，您需要问自己:</p><ul class=""><li id="38b0" class="ky kz ir kb b kc kd kg kh kk la ko lb ks lc kw ld le lf lg bi translated"><strong class="kb is"> <em class="mw">我如何将web上的繁重工作卸载给工作人员？</em>T45】</strong></li><li id="f16b" class="ky kz ir kb b kc lh kg li kk lj ko lk ks ll kw ld le lf lg bi translated">是否有详细记录的方法来实现nodejs？T49】</li><li id="1cf1" class="ky kz ir kb b kc lh kg li kk lj ko lk ks ll kw ld le lf lg bi translated"><strong class="kb is"> <em class="mw">我是否已经从云提供商那里获得了一些服务？</em>T53】</strong></li><li id="132b" class="ky kz ir kb b kc lh kg li kk lj ko lk ks ll kw ld le lf lg bi translated"><strong class="kb is"> <em class="mw">如果我的工作负载出现故障，我该如何处理？应用程序可以自己重试吗？</em>T3】</strong></li><li id="aa27" class="ky kz ir kb b kc lh kg li kk lj ko lk ks ll kw ld le lf lg bi translated"><strong class="kb is"> <em class="mw">如果一切都失败了，我能得到通知以便解决问题吗？解决问题后，我可以再试一次吗？</em> </strong></li><li id="9217" class="ky kz ir kb b kc lh kg li kk lj ko lk ks ll kw ld le lf lg bi translated"><strong class="kb is"> <em class="mw">如何才能衡量工作量？</em>T11】</strong></li></ul><p id="52ae" class="pw-post-body-paragraph jz ka ir kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ik bi translated">让我们来回答这些问题:</p><ul class=""><li id="5de4" class="ky kz ir kb b kc kd kg kh kk la ko lb ks lc kw ld le lf lg bi translated"><strong class="kb is"> <em class="mw">一个好主意是使用已知的消息代理技术将工作负载排队，避免给web api带来压力。</em>T15】</strong></li><li id="0ba9" class="ky kz ir kb b kc lh kg li kk lj ko lk ks ll kw ld le lf lg bi translated"><strong class="kb is"> <em class="mw">一个有据可查的方法是使用redis和bull。</em>T19】</strong></li><li id="0a01" class="ky kz ir kb b kc lh kg li kk lj ko lk ks ll kw ld le lf lg bi translated"><strong class="kb is"> <em class="mw"> SQS对于AWS，Azure Service Bus，RabbitMQ等。</em> </strong></li><li id="4091" class="ky kz ir kb b kc lh kg li kk lj ko lk ks ll kw ld le lf lg bi translated">使用消息代理，我们可以通过配置来保证重试。 </li><li id="277e" class="ky kz ir kb b kc lh kg li kk lj ko lk ks ll kw ld le lf lg bi translated"><strong class="kb is"> <em class="mw">死亡信队列(DLQ)很常见，大多数消息代理会根据您的配置重试多次，然后将失败的消息发送给DLQ进行审查。DLQ通常支持重新发送到源队列(例如SQS)。</em> </strong></li><li id="4445" class="ky kz ir kb b kc lh kg li kk lj ko lk ks ll kw ld le lf lg bi translated"><strong class="kb is"> <em class="mw">使用带有Sentry等通知的集中日志记录，并使用New Relic等第三方工具监控进程。这样，您可以根据需要解决员工或秤的问题。</em> </strong></li></ul><figure class="mz na nb nc gt js gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/5dfe08a5f011b405c2b3fe956a0db4ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1056/format:webp/1*nPFvM-6BVzeLXzsFqixpiA.png"/></div></figure><h1 id="1bbc" class="lt lu ir bd lv lw nh ly lz ma ni mc md me nj mg mh mi nk mk ml mm nl mo mp mq bi translated">调度员💎</h1><p id="4eee" class="pw-post-body-paragraph jz ka ir kb b kc mr ke kf kg ms ki kj kk mt km kn ko mu kq kr ks mv ku kv kw ik bi translated">这是单一代码库中多核架构的核心组件。调度程序将使用一个环境变量来理解哪个上下文/环境在起作用，并在正确的位置启动正确的进程。它还将决定是否可以利用环境处理器，并尝试运行一个进程集群，以便每当环境发生变化时，应用程序都会自动调整其进程，并将每个进程分配给一个处理器内核。</p><p id="3275" class="pw-post-body-paragraph jz ka ir kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ik bi translated">我们将使用以下工具来构建调度程序:</p><ul class=""><li id="1085" class="ky kz ir kb b kc kd kg kh kk la ko lb ks lc kw ld le lf lg bi translated">一个名为<strong class="kb is"> PROCESS_TYPE </strong>的环境变量。</li><li id="f1ba" class="ky kz ir kb b kc lh kg li kk lj ko lk ks ll kw ld le lf lg bi translated">库<strong class="kb is"> <em class="mw">通过</em> </strong>启用模块内启用集群模式。</li></ul><figure class="mz na nb nc gt js"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="d0cf" class="pw-post-body-paragraph jz ka ir kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ik bi translated">这样，在环境中使用不同的env变量，它将在集群模式下启动正确的进程。它将有条件地需要其中一个模块，并且它所符合的条件中的所有内容都将存在于同一个集群中。启用日志并优雅地<strong class="kb is"><em class="mw"/></strong>终止进程以避免内存泄漏是很重要的。在第42行中，您可以设置可用的处理器数量，有些环境(如Heroku)会公开一个环境变量，或者您可以使用<strong class="kb is"> <em class="mw"> os </em> </strong>本机模块来计算。</p><h1 id="2032" class="lt lu ir bd lv lw nh ly lz ma ni mc md me nj mg mh mi nk mk ml mm nl mo mp mq bi translated">卸下问题👾</h1><p id="b204" class="pw-post-body-paragraph jz ka ir kb b kc mr ke kf kg ms ki kj kk mt km kn ko mu kq kr ks mv ku kv kw ik bi translated">我假设您已经研究了情况，测量了应用程序并找到了瓶颈。如果我们达到了向外扩展应用程序的这一点，这意味着您有一个大问题。在第一步中，您想知道是否可以将问题分解成更小的部分。</p><blockquote class="nq nr ns"><p id="b5c7" class="jz ka mw kb b kc kd ke kf kg kh ki kj nt kl km kn nu kp kq kr nv kt ku kv kw ik bi translated">就像孙子说的:势力若合，则分。</p></blockquote><p id="b7dc" class="pw-post-body-paragraph jz ka ir kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ik bi translated">工人处理比整个大流程小很多倍的小部分是值得的。一旦您找到了可以卸载给工作人员的最小部分，我们就通过将消息发布到特定队列来将信息发送给消息代理。我必须解决的一个非常具体的问题是将已处理文档的文本与其文档的系谱树合并，这就是为什么我将工作负载拆分为许多消息，其中一条消息是要成批处理的文档。</p><p id="2d3b" class="pw-post-body-paragraph jz ka ir kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ik bi translated">因此，在web流程中，您通常会执行以下操作，启动并忘记该流程，因此只要工作进程可用，它就会继续从队列中获取消息并处理它们:</p><figure class="mz na nb nc gt js"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="ad0b" class="pw-post-body-paragraph jz ka ir kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ik bi translated">这样，我们通过委派工作并保持api的安全和健康来节省web进程消耗的CPU利用率资源。你必须不惜任何代价保持用户体验的流畅，我们不能奢侈地让这个过程忙碌起来。</p><h1 id="4e5d" class="lt lu ir bd lv lw nh ly lz ma ni mc md me nj mg mh mi nk mk ml mm nl mo mp mq bi translated">工人Process⚙️</h1><p id="1f2a" class="pw-post-body-paragraph jz ka ir kb b kc mr ke kf kg ms ki kj kk mt km kn ko mu kq kr ks mv ku kv kw ik bi translated">工人进程就是那个家伙，那个将要执行所有繁重工作的人。它将连接并监听所选的消息代理，获取消息并逐个处理它们。</p><p id="32aa" class="pw-post-body-paragraph jz ka ir kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ik bi translated">该工人必须具备以下能力:</p><ul class=""><li id="537e" class="ky kz ir kb b kc kd kg kh kk la ko lb ks lc kw ld le lf lg bi translated">在多个cpu内核上运行。🎛</li><li id="b0ef" class="ky kz ir kb b kc lh kg li kk lj ko lk ks ll kw ld le lf lg bi translated">失败后重试。💊</li><li id="17d7" class="ky kz ir kb b kc lh kg li kk lj ko lk ks ll kw ld le lf lg bi translated">经过一段时间的重试后，将失败的消息发送给<strong class="kb is"><em class="mw"/></strong>。📤</li><li id="4c9b" class="ky kz ir kb b kc lh kg li kk lj ko lk ks ll kw ld le lf lg bi translated">如果需要，它还可以在一些数据库表中保存进度跟踪。⏳</li><li id="8365" class="ky kz ir kb b kc lh kg li kk lj ko lk ks ll kw ld le lf lg bi translated">捕捉错误，并在需要时通知工程团队和用户。📨</li></ul><p id="23a0" class="pw-post-body-paragraph jz ka ir kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ik bi translated">workers文件夹结构如下:</p><figure class="mz na nb nc gt js gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/a72ed97607249eaf618588e541b7c75d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1124/format:webp/1*EOkJGMFDIZTDOwyGIDwJ9g.png"/></div></figure><p id="edad" class="pw-post-body-paragraph jz ka ir kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ik bi translated">首先，我们将事件抽象为<strong class="kb is"> <em class="mw">名称</em> </strong>和<strong class="kb is"> <em class="mw">版本。</em> </strong>版本保持复古兼容性很重要。</p><figure class="mz na nb nc gt js"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="1c0d" class="pw-post-body-paragraph jz ka ir kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ik bi translated">然后我们有了<strong class="kb is"><em class="mw">base . listener . ts</em></strong>组件，它连接到队列并触发正确的工作文件，在我的例子中是<strong class="kb is"><em class="mw">document-processor . listener . ts。在我的例子中，默认情况下它使用SQS，但也可以是其他任何东西。</em></strong></p><figure class="mz na nb nc gt js"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="0bd3" class="pw-post-body-paragraph jz ka ir kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ik bi translated">通过实现上面的抽象类，你将拥有一个现成的处理器。正如您所看到的，这个抽象处理了一些事情:</p><ul class=""><li id="cb57" class="ky kz ir kb b kc kd kg kh kk la ko lb ks lc kw ld le lf lg bi translated">连接到SQS。📨</li><li id="bebe" class="ky kz ir kb b kc lh kg li kk lj ko lk ks ll kw ld le lf lg bi translated">使哨兵能够集中日志。📈</li><li id="1aa3" class="ky kz ir kb b kc lh kg li kk lj ko lk ks ll kw ld le lf lg bi translated">启动流程并将消息交付给正确的工人实现。🎠</li></ul><p id="b09d" class="pw-post-body-paragraph jz ka ir kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ik bi translated">我将我的员工的指标发送到<strong class="kb is"><em class="mw">new relic</em></strong><strong class="kb is"><em class="mw">APM</em></strong>以便了解您的流程发生了什么。你可能更喜欢<strong class="kb is"> <em class="mw"> PM2 </em> </strong>，那也没关系。</p><h1 id="acbd" class="lt lu ir bd lv lw nh ly lz ma ni mc md me nj mg mh mi nk mk ml mm nl mo mp mq bi translated">最终的画面🌆</h1><p id="dd4e" class="pw-post-body-paragraph jz ka ir kb b kc mr ke kf kg ms ki kj kk mt km kn ko mu kq kr ks mv ku kv kw ik bi translated">准备好整个多处理架构后，您应该准备好以下工作流。</p><ul class=""><li id="6024" class="ky kz ir kb b kc kd kg kh kk la ko lb ks lc kw ld le lf lg bi translated">web进程将繁重的工作交给了SQS。</li><li id="5178" class="ky kz ir kb b kc lh kg li kk lj ko lk ks ll kw ld le lf lg bi translated">工作进程每隔一定时间轮询一次SQS队列，以搜索新消息。</li><li id="d553" class="ky kz ir kb b kc lh kg li kk lj ko lk ks ll kw ld le lf lg bi translated">工作进程完成这项工作。</li><li id="3607" class="ky kz ir kb b kc lh kg li kk lj ko lk ks ll kw ld le lf lg bi translated">如果失败，至少3次，它将发送一条消息到DLQ进行人工调查。一旦消息可以被处理，一些消息代理支持将那些失败的消息重新发送回队列。如果消息代理不提供这种功能，您可以添加另一个worker来支持重新交付特性。</li></ul><figure class="mz na nb nc gt js gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/7d9f40f26d34a2f5f23edde6051d58b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1172/format:webp/1*hPqCVzj0WgPBjSNvFSFq2w.png"/></div></figure><h1 id="2834" class="lt lu ir bd lv lw nh ly lz ma ni mc md me nj mg mh mi nk mk ml mm nl mo mp mq bi translated">开发工作流程🛸</h1><p id="e85e" class="pw-post-body-paragraph jz ka ir kb b kc mr ke kf kg ms ki kj kk mt km kn ko mu kq kr ks mv ku kv kw ik bi translated">之后，开发流程将被分成几个部分，开发人员将需要一种方法来更好地处理几个部分。因为有很多方法，例如，可以是docker，另一种方法是使用<a class="ae kx" href="https://github.com/strongloop/node-foreman" rel="noopener ugc nofollow" target="_blank"> foreman包</a>，它读取一个<strong class="kb is"> <em class="mw"> Procfile </em> </strong>并自动启动不同的部分。</p><figure class="mz na nb nc gt js gh gi paragraph-image"><div role="button" tabindex="0" class="jt ju di jv bf jw"><div class="gh gi ny"><img src="../Images/0b422354d9d31150d232afa8daa424e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n-48quBmP_PSOzTcPGglrQ.png"/></div></div></figure><p id="9fca" class="pw-post-body-paragraph jz ka ir kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ik bi translated">一些云提供商，如<strong class="kb is"> <em class="mw"> Heroku </em> </strong>读取<strong class="kb is"> <em class="mw"> Procfiles </em> </strong>并自动为他们独立启动基础设施，这就是神奇之处。Heroku的一个优点是，您可以用不同的资源扩展Procfile中的每个进程。</p><figure class="mz na nb nc gt js gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/72a778332638d4cc153b8800adcf6b71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1186/format:webp/1*n5Yks91ywfPXXoEVu-LEvw.png"/></div></figure><figure class="mz na nb nc gt js gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/ca01687f238e272b041fe97faf8bd799.png" data-original-src="https://miro.medium.com/v2/resize:fit:840/format:webp/1*JLJV9uUE8BG4dFNyluo1QQ.png"/></div></figure><p id="044f" class="pw-post-body-paragraph jz ka ir kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ik bi translated">另一件事，如果你使用AWS，你可能想使用<a class="ae kx" href="https://localstack.cloud/" rel="noopener ugc nofollow" target="_blank"> localstack </a>，它有一个docker容器，你可以用它来模拟他们的基础设施，比如SQS、迪纳摩等。</p><h1 id="38a2" class="lt lu ir bd lv lw nh ly lz ma ni mc md me nj mg mh mi nk mk ml mm nl mo mp mq bi translated">嘿，在离开这篇文章之前🙏</h1><p id="dff8" class="pw-post-body-paragraph jz ka ir kb b kc mr ke kf kg ms ki kj kk mt km kn ko mu kq kr ks mv ku kv kw ik bi translated">你喜欢吃吗?👀</p><ul class=""><li id="e8da" class="ky kz ir kb b kc kd kg kh kk la ko lb ks lc kw ld le lf lg bi translated">跟我来🤳</li><li id="d670" class="ky kz ir kb b kc lh kg li kk lj ko lk ks ll kw ld le lf lg bi translated">拍拍我，让我有动力写更多👏👏👏</li></ul><h1 id="9dd8" class="lt lu ir bd lv lw nh ly lz ma ni mc md me nj mg mh mi nk mk ml mm nl mo mp mq bi translated">结论</h1><p id="dbcc" class="pw-post-body-paragraph jz ka ir kb b kc mr ke kf kg ms ki kj kk mt km kn ko mu kq kr ks mv ku kv kw ik bi translated">我希望你喜欢这篇文章。这背后的想法是稍微解释一下如何在NodeJS应用程序中处理多处理。当我不得不开发它时，我没有找到很多可以寻找灵感的地方，这就是我写这篇文章的原因。我真的希望它对你的项目有所帮助，或者至少让你得到一些新的想法。</p><p id="4dcf" class="pw-post-body-paragraph jz ka ir kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ik bi translated">编码快乐！</p><figure class="mz na nb nc gt js gh gi paragraph-image"><div role="button" tabindex="0" class="jt ju di jv bf jw"><div class="gh gi ob"><img src="../Images/038a390e70ead2a97cc3a5396bcc37fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-PqNfSaHMbmu4aIN.gif"/></div></div></figure></div></div>    
</body>
</html>