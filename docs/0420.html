<html>
<head>
<title>Building a Kubernetes deployment pipeline for Microsoft Bot Framework – Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为Microsoft Bot框架构建Kubernetes部署管道—第2部分</h1>
<blockquote>原文：<a href="https://itnext.io/building-a-kubernetes-deployment-pipeline-for-microsoft-bot-framework-part-2-61b176c2bc26?source=collection_archive---------2-----------------------#2018-03-07">https://itnext.io/building-a-kubernetes-deployment-pipeline-for-microsoft-bot-framework-part-2-61b176c2bc26?source=collection_archive---------2-----------------------#2018-03-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/1d244170a9b6b63b352becfc593c2311.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TP76AT0J2Y8mwuZc5_LDlA.jpeg"/></div></div></figure><p id="714f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是本系列的第二篇文章，讨论我如何为聊天机器人建立一个端到端的Kubernetes部署管道。如果你错过了第1部分，你可以点击这里查看。</p><p id="a303" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第2部分详细介绍了主题公园聊天机器人的部署。所有的代码都可以在我的GitHub上找到:<a class="ae kw" href="https://github.com/JonJam/themeparks-bot" rel="noopener ugc nofollow" target="_blank"> themeparks-bot </a>。</p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h1 id="136e" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">工具</h1><p id="ae48" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">在我之前的帖子中，我介绍了我用来创建基础设施的工具；对于机器人，我重用了大部分工具，增加了一些东西:</p><h2 id="4ac2" class="mh lf iq bd lg mi mj dn lk mk ml dp lo kj mm mn ls kn mo mp lw kr mq mr ma ms bi translated">码头枢纽</h2><p id="da67" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated"><a class="ae kw" href="https://hub.docker.com/" rel="noopener ugc nofollow" target="_blank"> Docker Hub </a>是一个云容器映像注册表。这用于存储从每个Travis CI构建中构建的docker映像，然后在Kubernetes中使用。</p><p id="d4cc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我选择了Docker Hub，因为它对公共图像是免费的，并且与Kubernetes集成在一起。</p><h2 id="287e" class="mh lf iq bd lg mi mj dn lk mk ml dp lo kj mm mn ls kn mo mp lw kr mq mr ma ms bi translated">Docker CLI</h2><p id="d126" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">Docker CLI是用于管理Docker容器和图像的命令行工具。我用它来构建聊天机器人docker映像，并将其推送到Docker Hub。</p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h1 id="ce32" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">创建舵图</h1><p id="865c" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">为了使用<a class="ae kw" href="https://helm.sh/" rel="noopener ugc nofollow" target="_blank">舵</a>进行部署，我必须创建一个<a class="ae kw" href="https://docs.helm.sh/developing_charts/#charts" rel="noopener ugc nofollow" target="_blank">图表</a>，这部分详细介绍了我是如何开始的，并显示了组成图表的各个组件。</p><h2 id="f1c9" class="mh lf iq bd lg mi mj dn lk mk ml dp lo kj mm mn ls kn mo mp lw kr mq mr ma ms bi translated">入门指南</h2><p id="7cd4" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">Helm CLI提供了一个<a class="ae kw" href="https://docs.helm.sh/helm/#helm-create" rel="noopener ugc nofollow" target="_blank"> create </a>命令来生成一个包含所需目录结构和文件的框架图。运行如下:</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="7fe4" class="mh lf iq my b gy nc nd l ne nf">helm create themeparks-bot</span></pre><p id="72a6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该命令的输出是这样的文件夹结构:</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="3482" class="mh lf iq my b gy nc nd l ne nf">themeparks-bot/<br/>  |<br/>  |- .helmignore   # Contains patterns to ignore when packaging Helm charts.<br/>  |<br/>  |- Chart.yaml    # Information about your chart<br/>  |<br/>  |- values.yaml   # The default values for your templates<br/>  |<br/>  |- charts/       # Charts that this chart depends on<br/>  |<br/>  |- templates/    # The template files</span></pre><p id="cc2c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">主工作区是templates文件夹，因为这是Kubernetes资源所在的位置。事实上，框架图实际上附带了示例<a class="ae kw" href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/" rel="noopener ugc nofollow" target="_blank">部署</a>、<a class="ae kw" href="https://kubernetes.io/docs/concepts/services-networking/ingress/" rel="noopener ugc nofollow" target="_blank">入口</a>和<a class="ae kw" href="https://kubernetes.io/docs/concepts/services-networking/service/" rel="noopener ugc nofollow" target="_blank">服务</a>模板。</p><h2 id="5e0a" class="mh lf iq bd lg mi mj dn lk mk ml dp lo kj mm mn ls kn mo mp lw kr mq mr ma ms bi translated">创建值文件</h2><p id="0481" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">在创建模板之前，我首先修改了<a class="ae kw" href="https://docs.helm.sh/chart_template_guide/#values-files" rel="noopener ugc nofollow" target="_blank"> values.yaml </a>文件。这包含模板中使用的属性的默认值。</p><figure class="mt mu mv mw gt jr"><div class="bz fp l di"><div class="ng nh l"/></div><figcaption class="ni nj gj gh gi nk nl bd b be z dk translated">价值观念</figcaption></figure><p id="9a23" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我在修改价值观文件时遵循了许多最佳实践(参见<a class="ae kw" href="https://docs.helm.sh/chart_best_practices/#values" rel="noopener ugc nofollow" target="_blank">文档</a>)。一些关键因素是:</p><ul class=""><li id="01c5" class="nm nn iq ka b kb kc kf kg kj no kn np kr nq kv nr ns nt nu bi translated">变量名应该使用大小写。</li><li id="de34" class="nm nn iq ka b kb nv kf nw kj nx kn ny kr nz kv nr ns nt nu bi translated">扁平结构比嵌套结构更好。</li><li id="aef8" class="nm nn iq ka b kb nv kf nw kj nx kn ny kr nz kv nr ns nt nu bi translated">所有财产都应记录在案。</li></ul><p id="e15f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">需要注意的一点是，我还没有为secret属性下的内容指定值；这是因为我在部署时传递它，因为它们是我不想在源代码控制中使用的值。</p><h2 id="c94a" class="mh lf iq bd lg mi mj dn lk mk ml dp lo kj mm mn ls kn mo mp lw kr mq mr ma ms bi translated">定义模板</h2><p id="2182" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">使用骨架模板作为起点，我为聊天机器人修改并创建了额外的模板。</p><p id="4849" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Helm有许多关于开发模板的通用指南，例如:</p><ul class=""><li id="db55" class="nm nn iq ka b kb kc kf kg kj no kn np kr nq kv nr ns nt nu bi translated">模板文件应该遵循[图表名称]-[Kubernetes资源类型]的命名约定。例如主题公园-机器人-部署。</li><li id="e681" class="nm nn iq ka b kb nv kf nw kj nx kn ny kr nz kv nr ns nt nu bi translated">一个模板文件应该只包含一个Kubernetes资源(<a class="ae kw" href="https://docs.helm.sh/chart_best_practices/#structure-of-templates" rel="noopener ugc nofollow" target="_blank">源</a>)。</li><li id="3558" class="nm nn iq ka b kb nv kf nw kj nx kn ny kr nz kv nr ns nt nu bi translated">所有资源都应该有标准的头盔标签(<a class="ae kw" href="https://docs.helm.sh/chart_best_practices/#standard-labels" rel="noopener ugc nofollow" target="_blank">来源</a>)。</li><li id="6191" class="nm nn iq ka b kb nv kf nw kj nx kn ny kr nz kv nr ns nt nu bi translated">include函数应该在template函数之上使用(<a class="ae kw" href="https://docs.helm.sh/chart_template_guide/#the-include-function" rel="noopener ugc nofollow" target="_blank"> source </a>)。</li></ul><p id="f474" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">考虑到这些，这里是单独的模板。</p><p id="517c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">_助手</strong></p><p id="8ddb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kw" href="https://docs.helm.sh/chart_template_guide/#named-templates" rel="noopener ugc nofollow" target="_blank">这是模板片段和助手</a>的默认位置。这些助手在单独的Kubernetes资源模板中使用。</p><p id="ee9a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">关于助手的指导包括:</p><ul class=""><li id="9893" class="nm nn iq ka b kb kc kf kg kj no kn np kr nq kv nr ns nt nu bi translated">为每个功能定义一个文档块(<a class="ae kw" href="https://docs.helm.sh/chart_template_guide/#declaring-and-using-templates-with-define-and-template" rel="noopener ugc nofollow" target="_blank">来源</a>)。</li><li id="970d" class="nm nn iq ka b kb nv kf nw kj nx kn ny kr nz kv nr ns nt nu bi translated">在每个函数前加上图表名称(<a class="ae kw" href="https://docs.helm.sh/chart_template_guide/#declaring-and-using-templates-with-define-and-template" rel="noopener ugc nofollow" target="_blank">源</a>)。</li></ul><figure class="mt mu mv mw gt jr"><div class="bz fp l di"><div class="ng nh l"/></div><figcaption class="ni nj gj gh gi nk nl bd b be z dk translated">助手模板</figcaption></figure><p id="d49b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">秘密</strong></p><p id="25f8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是第一个使用这些辅助函数和值来定义一个<a class="ae kw" href="https://kubernetes.io/docs/concepts/configuration/secret/" rel="noopener ugc nofollow" target="_blank">秘密</a>的例子。</p><figure class="mt mu mv mw gt jr"><div class="bz fp l di"><div class="ng nh l"/></div><figcaption class="ni nj gj gh gi nk nl bd b be z dk translated">秘密模板</figcaption></figure><p id="e5e0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">部署</strong></p><p id="1718" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来是<a class="ae kw" href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/" rel="noopener ugc nofollow" target="_blank">deployment</a>t，它依赖于之前定义的秘密；这就是我在注释部分引用它的原因。</p><p id="7d27" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我这样做的原因是，每当任何秘密值改变时，Kubernetes将重新部署，选择任何新的值(关于这一点的更多信息可以在这里找到<a class="ae kw" href="https://docs.helm.sh/developing_charts/#automatically-roll-deployments-when-configmaps-or-secrets-change" rel="noopener ugc nofollow" target="_blank"/>)。</p><figure class="mt mu mv mw gt jr"><div class="bz fp l di"><div class="ng nh l"/></div><figcaption class="ni nj gj gh gi nk nl bd b be z dk translated">部署模板</figcaption></figure><p id="f14e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">服务</strong></p><p id="49d1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我有了一个部署，我需要在集群中公开它，因此有了<a class="ae kw" href="https://kubernetes.io/docs/concepts/services-networking/service/" rel="noopener ugc nofollow" target="_blank">服务</a>的定义。</p><figure class="mt mu mv mw gt jr"><div class="bz fp l di"><div class="ng nh l"/></div><figcaption class="ni nj gj gh gi nk nl bd b be z dk translated">服务模板</figcaption></figure><p id="25bb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">入口</strong></p><p id="1259" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，最后一部分是Ingres的资源。该服务目前仅在集群内可用，外部不可用。</p><p id="f1f0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是因为由于这个机器人是基于expressjs的，所以建议使用类似NGINX的代理来使它面向互联网。这正是这个入口定义的工作。</p><figure class="mt mu mv mw gt jr"><div class="bz fp l di"><div class="ng nh l"/></div><figcaption class="ni nj gj gh gi nk nl bd b be z dk translated">入口模板</figcaption></figure><h2 id="3a1d" class="mh lf iq bd lg mi mj dn lk mk ml dp lo kj mm mn ls kn mo mp lw kr mq mr ma ms bi translated">指定依赖关系</h2><p id="d5be" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">正如我在定义模板一节中提到的，聊天机器人通过<a class="ae kw" href="https://www.nginx.com/" rel="noopener ugc nofollow" target="_blank"> NGINX </a>向外界公开。此外，机器人使用<a class="ae kw" href="https://redis.io/" rel="noopener ugc nofollow" target="_blank"> Redis </a>缓存主题公园数据。</p><p id="7d3c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Helm不需要自己创建Kubernetes模板来部署NGINX和Redis，它允许你将其他图表定义为与你的图表一起部署的<a class="ae kw" href="https://docs.helm.sh/developing_charts/#chart-dependencies" rel="noopener ugc nofollow" target="_blank">依赖关系</a>。</p><p id="1ab7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">幸运的是，NGINX和Redis已经有图表了。通过创建一个requirements.yaml文件，这些被包含在这个图表中。</p><figure class="mt mu mv mw gt jr"><div class="bz fp l di"><div class="ng nh l"/></div><figcaption class="ni nj gj gh gi nk nl bd b be z dk translated">图表相关性</figcaption></figure><h2 id="e43b" class="mh lf iq bd lg mi mj dn lk mk ml dp lo kj mm mn ls kn mo mp lw kr mq mr ma ms bi translated">Chart.yaml</h2><p id="6b3b" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">最后一个难题是实际的图表定义:</p><figure class="mt mu mv mw gt jr"><div class="bz fp l di"><div class="ng nh l"/></div><figcaption class="ni nj gj gh gi nk nl bd b be z dk translated">图表定义</figcaption></figure><h1 id="160f" class="le lf iq bd lg lh oa lj lk ll ob ln lo lp oc lr ls lt od lv lw lx oe lz ma mb bi translated">构建和部署</h1><p id="e6f1" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">创建了Helm图表后，我使用Travis CI将所有东西放在一起，构建并部署机器人到Kubernetes。</p><p id="4e37" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我的. travis.yml文件如下所示:</p><figure class="mt mu mv mw gt jr"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="d00e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个Travis CI定义利用了<a class="ae kw" href="https://docs.travis-ci.com/user/build-stages/" rel="noopener ugc nofollow" target="_blank">构建阶段</a>(目前处于测试阶段)，它允许您清晰地划分构建/部署管道的各个阶段。您还会注意到，我使用了许多环境变量，这些变量是通过<a class="ae kw" href="https://docs.travis-ci.com/user/environment-variables#Defining-Variables-in-Repository-Settings" rel="noopener ugc nofollow" target="_blank">存储库设置</a>来设置的。</p><p id="3632" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该定义执行以下操作:</p><ul class=""><li id="1974" class="nm nn iq ka b kb kc kf kg kj no kn np kr nq kv nr ns nt nu bi translated">在任何阶段之前，它会安装脚本运行所需的<a class="ae kw" href="https://docs.travis-ci.com/user/installing-dependencies/" rel="noopener ugc nofollow" target="_blank">依赖项</a>，即Azure CLI、kubectl和helm。</li><li id="e0cd" class="nm nn iq ka b kb nv kf nw kj nx kn ny kr nz kv nr ns nt nu bi translated">构建阶段执行以下任务:</li></ul><ol class=""><li id="b2b4" class="nm nn iq ka b kb kc kf kg kj no kn np kr nq kv of ns nt nu bi translated">使用yarn安装依赖项。</li><li id="11de" class="nm nn iq ka b kb nv kf nw kj nx kn ny kr nz kv of ns nt nu bi translated">使用yarn构建机器人。</li><li id="d617" class="nm nn iq ka b kb nv kf nw kj nx kn ny kr nz kv of ns nt nu bi translated">舵轮图定义。</li><li id="7686" class="nm nn iq ka b kb nv kf nw kj nx kn ny kr nz kv of ns nt nu bi translated">如果构建在master上进行并且成功，那么它将构建一个docker映像并将其发布到Docker Hub。</li></ol><ul class=""><li id="cc31" class="nm nn iq ka b kb kc kf kg kj no kn np kr nq kv nr ns nt nu bi translated">如果构建阶段已经过去，并且构建正在主分支之外进行，那么它将运行部署阶段。这个阶段使用实验性的<a class="ae kw" href="https://docs.travis-ci.com/user/deployment/script/" rel="noopener ugc nofollow" target="_blank">脚本部署</a>来运行包装器脚本，以将图表部署到Kubernetes。</li></ul><p id="7d21" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">包装脚本如下所示:</p><figure class="mt mu mv mw gt jr"><div class="bz fp l di"><div class="ng nh l"/></div><figcaption class="ni nj gj gh gi nk nl bd b be z dk translated">用于部署的包装脚本</figcaption></figure></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><p id="d9c6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有了所有这些，主题公园聊天机器人就部署到Kubernetes上，并准备好供用户聊天。</p><p id="3dc7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我希望这篇由两部分组成的文章能够帮助那些希望开始使用Kubernetes/Helm并建立部署管道的人。</p></div></div>    
</body>
</html>