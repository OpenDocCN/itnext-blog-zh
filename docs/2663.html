<html>
<head>
<title>Adding security layers to your App on OpenShift — Part 2: Authentication and Authorization with Keycloak</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在OpenShift上为您的应用程序添加安全层—第2部分:使用Keycloak进行身份验证和授权</h1>
<blockquote>原文：<a href="https://itnext.io/adding-security-layers-to-your-app-on-openshift-part-2-8320018bcdd1?source=collection_archive---------0-----------------------#2019-07-07">https://itnext.io/adding-security-layers-to-your-app-on-openshift-part-2-8320018bcdd1?source=collection_archive---------0-----------------------#2019-07-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="5313" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">今天，保护你的应用程序是必须的，但是如果你没有在一开始就考虑它，那么在不修改代码的情况下引入它是很困难的。幸运的是，像<a class="ae kl" href="http://kubernetes.io" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>这样的容器和平台带来的新的云原生模式提供了简单的方法来解决安全问题，而无需大量接触代码。</p><p id="4dd6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这一部分是关于添加明显的身份验证和授权安全层。为此，我们将使用<a class="ae kl" href="http://www.keycloak.org" rel="noopener ugc nofollow" target="_blank">键盘锁</a>和我们的<code class="fe km kn ko kp b">fruits-catalog</code>。Keycloak提供了这些层，以最少的麻烦保护应用程序的UI部分和API部分。它提供了管理用户和角色的所有基本功能，以及用户联盟、身份代理和社交登录等高级功能。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi kq"><img src="../Images/191f422b79f18616e6064bd19fb31c93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Lc82-mubzoYBsv9-LIGm2A.png"/></div></div><figcaption class="lc ld gj gh gi le lf bd b be z dk translated">第2部分—使用Keycloak进行身份验证和授权</figcaption></figure><p id="5419" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="lg">这篇文章是一个更大的系列文章的一部分，讲述了如何给现有的应用增加安全层。目前公布的其他部分有:</em></p><ul class=""><li id="f3c8" class="lh li iq jp b jq jr ju jv jy lj kc lk kg ll kk lm ln lo lp bi translated"><a class="ae kl" href="https://medium.com/@lbroudoux/adding-security-layers-to-your-app-on-openshift-part-1-deployment-and-tls-ingress-9ef752835599" rel="noopener"> <em class="lg">第1部分—部署和TLS入口</em> </a></li><li id="0a37" class="lh li iq jp b jq lq ju lr jy ls kc lt kg lu kk lm ln lo lp bi translated"><em class="lg">第2部分—使用Keycloak进行身份验证和授权(本文)</em></li><li id="5b40" class="lh li iq jp b jq lq ju lr jy ls kc lt kg lu kk lm ln lo lp bi translated"><a class="ae kl" href="https://medium.com/@lbroudoux/adding-security-layers-to-your-app-on-openshift-part-3-secret-management-with-vault-8efd4ec29ec4" rel="noopener"> <em class="lg">第三部分——金库秘密管理</em> </a></li><li id="bc3f" class="lh li iq jp b jq lq ju lr jy ls kc lt kg lu kk lm ln lo lp bi translated"><a class="ae kl" href="https://medium.com/@lbroudoux/adding-security-layers-to-your-app-on-openshift-part-4-dynamic-secrets-with-vault-b5fe1fc7709b" rel="noopener"> <em class="lg">第四部分——带保险库的动态秘密</em> </a></li><li id="8a71" class="lh li iq jp b jq lq ju lr jy ls kc lt kg lu kk lm ln lo lp bi translated"><a class="ae kl" href="https://medium.com/@lbroudoux/adding-security-layers-to-your-app-on-openshift-part-5-mutual-tls-with-istio-a8800c2e4df4" rel="noopener"> <em class="lg">第5部分——与Istio的相互TLS</em></a></li><li id="3be9" class="lh li iq jp b jq lq ju lr jy ls kc lt kg lu kk lm ln lo lp bi translated"><a class="ae kl" href="https://medium.com/@lbroudoux/adding-security-layers-to-your-app-on-openshift-part-6-pki-as-a-service-with-vault-and-cert-e6dbbe7028c7" rel="noopener"> <em class="lg">第6部分— PKI即服务，带保险库和证书管理器</em> </a></li></ul><h1 id="cca1" class="lv lw iq bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">我们想在这部分实现什么？</h1><p id="7c27" class="pw-post-body-paragraph jn jo iq jp b jq mt js jt ju mu jw jx jy mv ka kb kc mw ke kf kg mx ki kj kk ij bi translated">向应用程序添加适当的身份验证可能很麻烦，因为正确实现标准和可互操作的身份验证流(如OpenId Connect)确实是一项艰巨的任务。奇克洛来拯救我们了！</p><p id="e5f8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这一部分，我们将:</p><ul class=""><li id="1269" class="lh li iq jp b jq jr ju jv jy lj kc lk kg ll kk lm ln lo lp bi translated">在我们的<a class="ae kl" href="http://www.openshift.com/" rel="noopener ugc nofollow" target="_blank"> OpenShift </a> Kubernetes发行版上部署并配置一个Keycloak实例，就在我们在第1部分中部署的<code class="fe km kn ko kp b">fruits-catalog</code>和<code class="fe km kn ko kp b">mongodb</code>pod旁边，</li><li id="2891" class="lh li iq jp b jq lq ju lr jy ls kc lt kg lu kk lm ln lo lp bi translated">通过在客户端强制身份验证以及将安全上下文传播到服务器端来保护我们现有的应用程序。这里我们将配置Keycloak实例和我们的应用程序来实现<a class="ae kl" href="https://openid.net/specs/openid-connect-core-1_0.html#Authentication" rel="noopener ugc nofollow" target="_blank"> OpenId Connect认证流</a>。</li></ul><p id="ed10" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，我们希望获得以下架构，其中身份验证请求在浏览器中的Angular应用程序、Spring Boot后端和Keycloak实例之间流动:</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi my"><img src="../Images/7f871daa986d3b0bf592e41093e56816.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CUCx68o16on6tTmurKAdIw.png"/></div></div></figure><p id="c824" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">配置的身份验证流程的简化视图如下所示:</p><ol class=""><li id="d0de" class="lh li iq jp b jq jr ju jv jy lj kc lk kg ll kk mz ln lo lp bi translated">浏览器加载并访问Angular应用程序，由于当前会话未经认证，用户被重定向到由Keycloak管理的登录表单，</li><li id="0c78" class="lh li iq jp b jq lq ju lr jy ls kc lt kg lu kk mz ln lo lp bi translated">对Keycloak配置的身份提供程序进行身份验证；这可以是本地的(嵌入到Keycloak自己的数据库中)，也可以是远程的，比如社交网络(GitHub，Google等等)，或者来自你的企业环境(LDAP，ADFS女士等等)，</li><li id="0c36" class="lh li iq jp b jq lq ju lr jy ls kc lt kg lu kk mz ln lo lp bi translated">在认证发生并且交换了一些<code class="fe km kn ko kp b">access_code</code>和<code class="fe km kn ko kp b">authorization_code</code>之后，我们浏览器中的Angular应用程序现在有了一个<code class="fe km kn ko kp b">token</code>，当访问API端点时，它应该与对我们应用程序后端的每一个请求相集成。</li><li id="5c5f" class="lh li iq jp b jq lq ju lr jy ls kc lt kg lu kk mz ln lo lp bi translated">当在后端调用API时，配置的Keycloak拦截器将决定何时挑战令牌的真实性。这个挑战是通过使用Keycloak OpenId API实现的。最后，如果应该授予一些特定的角色来访问API，拦截器在让请求流向应用程序之前，会根据这些角色来评估当前用户。</li></ol><h1 id="13b5" class="lv lw iq bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">如何应用？</h1><p id="ab10" class="pw-post-body-paragraph jn jo iq jp b jq mt js jt ju mu jw jx jy mv ka kb kc mw ke kf kg mx ki kj kk ij bi translated">如果您已经阅读了本系列的第一部分，那么您可能已经克隆了包含所有资源和资产的<a class="ae kl" href="https://github.com/lbroudoux/secured-fruits-catalog-k8s" rel="noopener ugc nofollow" target="_blank"> my GitHub repository </a>。如果没有，我敦促你这样做；-)从笔记本电脑上的克隆中，切换到<code class="fe km kn ko kp b">keycloak</code>分支:</p><pre class="kr ks kt ku gt na kp nb nc aw nd bi"><span id="4dbc" class="ne lw iq kp b gy nf ng l nh ni">$ git checkout keycloak</span></pre><p id="591a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，给定您的OpenShift集群和我们在第1部分中创建的<code class="fe km kn ko kp b">fruits-catalog</code>项目，让我们为我们的应用程序部署一个嵌入设置的Keycloak实例。您可以从克隆的根目录使用以下命令轻松完成此操作:</p><pre class="kr ks kt ku gt na kp nb nc aw nd bi"><span id="e2b0" class="ne lw iq kp b gy nf ng l nh ni">$ export ROUTE=$(oc get route/fruits-catalog -n fruits-catalog | grep fruits-catalog | awk '{print $2}')<br/>$ sed -i '' 's=https://fruits-catalog=https://'"$ROUTE"'=' k8s/keycloak-deployment.yml<br/>$ oc apply -f k8s/keycloak-deployment.yml -n fruits-catalog</span></pre><p id="30ee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在Keycloak部署几分钟后，我们可以通过控制项目中运行的pod数量来进行检查:</p><pre class="kr ks kt ku gt na kp nb nc aw nd bi"><span id="408c" class="ne lw iq kp b gy nf ng l nh ni">$ oc get pods -n fruits-catalog                                                                                         NAME                                   READY     STATUS      RESTARTS   AGE<br/>fruits-catalog-1-xx7nd                 1/1       Running     0          2h<br/>fruits-catalog-s2i-1-build             0/1       Completed   0          2h<br/>mongodb-1-t85wm                        1/1       Running     0          2h<br/>keycloak-649b794bf-x9xp9               1/1       Running     0         1h<br/>keycloak-postgresql-865c47755d-2khkv   1/1       Running     0     1h</span></pre><p id="11f4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我们已经在我们的项目中部署了另外两个pod:<code class="fe km kn ko kp b">keycloak-*</code>是运行Keycloak服务的pod，由运行在它自己的pod中的<code class="fe km kn ko kp b">keycloak-postgresql-*</code>数据库支持。我们还应该有一个新的<code class="fe km kn ko kp b">Route</code>，允许我们连接到Keycloak的管理控制台。</p><pre class="kr ks kt ku gt na kp nb nc aw nd bi"><span id="40d8" class="ne lw iq kp b gy nf ng l nh ni">$ oc get route keycloak                                                                                        NAME       HOST/PORT                                          PATH      SERVICES   PORT       TERMINATION   WILDCARD<br/>keycloak   keycloak-fruits-catalog.apps.x.x.x.x.nip.io             keycloak   keycloak   edge          None</span></pre><p id="14de" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从这个控制台，您现在必须配置<code class="fe km kn ko kp b">fruits-catalog</code>安全领域来添加新用户。在现实世界的Keycloak设置中，我们建议设置<a class="ae kl" href="https://www.keycloak.org/docs/latest/server_admin/index.html#_identity_broker" rel="noopener ugc nofollow" target="_blank">身份代理</a>部分，以便您能够重用一些来自身份识别和身份验证的现有资源。由于这是一个演示设置，我们将只为我们的应用程序完成新用户的<a class="ae kl" href="https://www.keycloak.org/docs/latest/server_admin/index.html#_create-new-user" rel="noopener ugc nofollow" target="_blank">创建</a>。确保您创建的用户分配有一个领域角色:<code class="fe km kn ko kp b">user</code>、<code class="fe km kn ko kp b">manager</code>或<code class="fe km kn ko kp b">admin</code>。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi nj"><img src="../Images/603d583a458490bd058f670ec244e524.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9kLsaGcJFsNILrqHj3uBtQ.png"/></div></div></figure><p id="b899" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们已经完成了基础设施部分的设置，我们必须处理应用程序部分。还记得这个博客系列的承诺吗？添加安全层，没有或极少触及源代码！我们在这里处理极简的部分，没有其他部分需要感人的代码。</p><p id="77ea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们必须在应用程序中添加Keycloak依赖项。这在角度前端组件的<code class="fe km kn ko kp b"><a class="ae kl" href="https://github.com/lbroudoux/secured-fruits-catalog-k8s/blob/keycloak/src/main/webapp/package.json#L33" rel="noopener ugc nofollow" target="_blank">package.json</a></code>文件和Spring Boot后端组件的<code class="fe km kn ko kp b"><a class="ae kl" href="https://github.com/lbroudoux/secured-fruits-catalog-k8s/blob/keycloak/pom.xml#L93-L97" rel="noopener ugc nofollow" target="_blank">pom.xml</a></code>文件中完成。这是简单的声明部分。</p><p id="abdc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在前端代码中，我们必须修改应用程序加载逻辑，强制它在启动时加载Keycloak客户端，使用一个关于如何连接到安全领域的配置。如果您正在部署演示，请看一下<code class="fe km kn ko kp b"><a class="ae kl" href="https://github.com/lbroudoux/secured-fruits-catalog-k8s/blob/keycloak/src/main/webapp/src/assets/keycloak-config.json#L4" rel="noopener ugc nofollow" target="_blank">keycloak-config.json</a></code>并使其适应您的环境。下面是你的Angular <code class="fe km kn ko kp b"><a class="ae kl" href="https://github.com/lbroudoux/secured-fruits-catalog-k8s/blob/keycloak/src/main/webapp/src/main.ts" rel="noopener ugc nofollow" target="_blank">main.ts</a></code>文件需要的修改。我们注释掉了引导模块的默认方式，并添加了一个“已验证”的条件。这个逻辑将负责将未经验证的用户重定向到由Keycloak管理的登录屏幕。</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="268f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">既然我们已经在客户端对用户进行了身份验证，那么我们需要一种方法来将每个API调用产生的JWT令牌传播到服务器端。我们将简单地在Angular模块中添加一个Http拦截器。这个拦截器将负责将<code class="fe km kn ko kp b">Authorization: Bearer &lt;jwt_token&gt;</code>添加到每个已处理的请求中，如下面的代码所示:</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="c131" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，在服务器端——在我们的Spring Boot组件中——我们只需为Keycloak Java拦截器配置安全设置。像前面解释的那样添加依赖项自动启用了拦截器，我们只需提供一个<code class="fe km kn ko kp b">application.properties</code>配置文件来配置Keycloak和我们的安全约束的连接细节:</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="0f32" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意，我们将依赖一个名为<code class="fe km kn ko kp b">KEYCLOAK_URL</code>的新环境变量来获得实际的Keycloak端点。现在，我们只需要将我们的应用程序配置并重新部署到OpenShift，以应用所有内容:</p><pre class="kr ks kt ku gt na kp nb nc aw nd bi"><span id="95f8" class="ne lw iq kp b gy nf ng l nh ni">$ export KEYCLOAK_ROUTE=$(oc get route/keycloak -n fruits-catalog | grep keycloak | awk '{print $2}')</span><span id="c2d3" class="ne lw iq kp b gy nm ng l nh ni">$ sed -i '' 's=keycloak-fruits-catalog.apps.144.76.24.92.nip.io='"$KEYCLOAK_ROUTE"'=' src/main/webapp/src/assets/keycloak-config.json</span><span id="3fe5" class="ne lw iq kp b gy nm ng l nh ni">$ mvn clean fabric8:deploy -Popenshift<br/>[...]</span><span id="3519" class="ne lw iq kp b gy nm ng l nh ni">$ oc rollout cancel dc/fruits-catalog<br/>$ oc set env dc/fruits-catalog KEYCLOAK_URL=https://$KEYCLOAK_ROUTE/auth -n fruits-catalog<br/>$ oc rollout latest dc/fruits-catalog</span></pre><p id="0230" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们首先检索Keycloak的入口路径，然后在使用<a class="ae kl" href="https://maven.fabric8.io/" rel="noopener ugc nofollow" target="_blank"> Fabric8 Maven </a>插件重新打包和重新部署所有内容之前，修改客户端配置文件。最后，我们取消正在进行的部署，因为我们必须添加新的环境变量。完成后，我们可以将其恢复到最新版本。</p><blockquote class="nn no np"><p id="c381" class="jn jo lg jp b jq jr js jt ju jv jw jx nq jz ka kb nr kd ke kf ns kh ki kj kk ij bi translated">特别注意将<code class="fe km kn ko kp b">$KEYCLOAK_URL</code>环境变量添加到部署中的最后一步。否则我们的努力将得不到回报；-)</p></blockquote><h1 id="f395" class="lv lw iq bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">检查它是否按预期工作</h1><p id="b937" class="pw-post-body-paragraph jn jo iq jp b jq mt js jt ju mu jw jx jy mv ka kb kc mw ke kf kg mx ki kj kk ij bi translated">使用应用程序路由的URL打开一个浏览器窗口，看到我们被重定向到一个管理身份验证流的Keycloak屏幕。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi nj"><img src="../Images/71e3b191162a0447ad24171b3d4dcbbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gQXcOaskDCgAXEMp_NrbKg.png"/></div></div></figure><p id="5e4f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦我们成功地作为一个已知用户认证到Keycloak身份提供者，我们就被重定向到我们的应用程序，现在可以完全加载了。在客户端，我们现在得到了一个JWT令牌，它可以在每次API调用时与服务器端后端交换。为了检查您是否可以简单地打开您的浏览器开发工具来检查网络跟踪并检查请求中是否存在<code class="fe km kn ko kp b">Authorization</code>报头:</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi nj"><img src="../Images/6ac065de1a84971b04eb30ef59cdc89e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n_WixeIIQsVKkeLQ-ahVaQ.png"/></div></div></figure><p id="6792" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，当检查您的<code class="fe km kn ko kp b">fruits-catalog</code>容器日志时——使用<code class="fe km kn ko kp b">oc logs</code>命令或通过web控制台——您应该看到一些来自Keycloak Java适配器的日志，并解释它正在做的检查。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi nt"><img src="../Images/1b30d2bd67f027e93266a4b9db7962f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3GXyO3x676F0BvrTrxpsVw.png"/></div></div></figure><h1 id="d400" class="lv lw iq bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">结论和下一步</h1><p id="9663" class="pw-post-body-paragraph jn jo iq jp b jq mt js jt ju mu jw jx jy mv ka kb kc mw ke kf kg mx ki kj kk ij bi translated">在第二部分中，我们已经看到了如何通过最少的添加或修改在应用程序中添加身份验证和授权。在部署和配置了Keycloak实例之后，过程非常简单:</p><ul class=""><li id="3111" class="lh li iq jp b jq jr ju jv jy lj kc lk kg ll kk lm ln lo lp bi translated">包括对客户端和服务器端组件的键盘锁依赖性，</li><li id="0d27" class="lh li iq jp b jq lq ju lr jy ls kc lt kg lu kk lm ln lo lp bi translated">在应用程序加载之前，配置客户端Javascript适配器以加载配置和身份验证。然后确保使用拦截器在每个请求中包含身份验证令牌。这些增加不需要改变你的Angular应用程序的代码！</li><li id="8540" class="lh li iq jp b jq lq ju lr jy ls kc lt kg lu kk lm ln lo lp bi translated">配置服务端Java适配器来加载配置，它将自动拦截传入的REST API调用，以信任给定的令牌，并确保用户通过身份验证并有权访问REST资源。</li></ul><p id="8d01" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">相当简单！在保护现有应用或新的微服务时，Keycloak非常有用。它提供了一堆<a class="ae kl" href="https://www.keycloak.org/docs/latest/securing_apps/index.html#supported-platforms" rel="noopener ugc nofollow" target="_blank">支持的平台</a>，可以很容易地配置和扩展，以满足您的需求。</p><p id="b4f5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本系列的这一步是我们进行代码修改最多的一步。在接下来的步骤中，我们将了解如何更改应用程序部署的配置，以增强对数据库凭证机密的管理。</p></div></div>    
</body>
</html>