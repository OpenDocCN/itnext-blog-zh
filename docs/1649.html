<html>
<head>
<title>API-First Programming on the Front End</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">API-前端优先编程</h1>
<blockquote>原文：<a href="https://itnext.io/api-first-programming-on-the-front-end-4364c218ac60?source=collection_archive---------3-----------------------#2018-12-20">https://itnext.io/api-first-programming-on-the-front-end-4364c218ac60?source=collection_archive---------3-----------------------#2018-12-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/d7f92e5fbde91f5d2f8a37f22a717828.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HKLH5WvfmlXOOta1"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@rawpixel?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> rawpixel </a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="161a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">API是程序各部分之间的协议，是某些功能的提供者和消费者之间的协议。典型的API交互是在一个数据服务(比如Google Maps)和一个向它发送一些数据(比如两个地址)并接收返回数据(比如从第一个地址到第二个地址的步骤列表)的网站之间进行的。</p><p id="241b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，API的提供者和消费者不必如此分离。上面描述的交互，其中消费者向提供者发送数据并接收回数据，与<em class="lb">功能</em>的描述相匹配。函数可以彼此非常接近，甚至在同一个文件中。</p><p id="66d9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">API中的I代表“接口”，意思是两个黑盒接触的边缘。把<em class="lb">你的</em>代码想象成一个黑盒可能有点奇怪，但是API提供者除了你发送给它的内容之外，对你的代码没有任何洞察力，就像你除了通过它的响应之外，对服务提供者做什么没有任何洞察力一样。虽然程序员编写依赖于自身外部隐式信息的函数是可能的，也是常见的，但将每个函数视为一个具有自己API的黑盒通常是有用的。</p><h2 id="00e7" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">基本原理</h2><p id="a906" class="pw-post-body-paragraph kd ke iq kf b kg lv ki kj kk lw km kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">为什么要像对待黑盒一样对待代码中的函数和对象，对彼此的内部和上下文一无所知？为什么要关心定义它们的API呢？答案是这样做加强了关注点的分离。正确分割的程序可以安全快速地发展，知道只要部件之间的边界(API)被尊重，部件本身可以改变和改进。这个边界可以通过测试来覆盖，以保证在内部变化时保持一致。</p><h2 id="d9da" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">编写API</h2><p id="4801" class="pw-post-body-paragraph kd ke iq kf b kg lv ki kj kk lw km kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">当一个函数是一个黑盒时，它的API是它与消费者交流的主要方式。(其他方法是通过文档和源代码。)重要的是，这个接口，即函数调用，尽可能地可预测和自文档化。在编写这个API的过程中，您可以做几件事来帮助您。</p><p id="c2e2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你可以<strong class="kf ir">很好地命名事物</strong>。该函数正在检索一个值吗？称之为<code class="fe ma mb mc md b">getValueName</code>。使用<code class="fe ma mb mc md b">set*</code>设定值。用<code class="fe ma mb mc md b">onEvent</code>订阅或回复事件。构式应该是大写的名词(如<code class="fe ma mb mc md b">new Car()</code>)，但大多数功能应该是<strong class="kf ir">动词</strong>，因为它们在主谓宾语句中充当动词(如<code class="fe ma mb mc md b">slideshow = combine(slides);</code>)。</p><p id="9394" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">避免在名称中编码返回类型，而是描述函数将执行的操作。<code class="fe ma mb mc md b">getLocations</code>击败<code class="fe ma mb mc md b">getLocationArray</code>。返回类型可以用IDE将使用的类型系统进行编码。</p><p id="2188" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一般来说，名字要足够长以描述功能，并且要足够短以方便使用。避免使用缩写，保持名字的可读性，以便于讨论。如果您发现自己在为函数命名时遇到困难，这是一个危险信号，表明该函数可能在做不止一件事情，并且可以从分解中受益。</p><p id="0f4c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以<strong class="kf ir">最小化参数长度</strong>。零个或一个参数是最好的，因为参数顺序不会混乱。我喜欢将我的函数限制在三个或更少的参数，如果我需要传入更多的数据，就使用一个对象。使用对象会给函数提供伪命名参数:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="1d89" class="lc ld iq md b gy mm mn l mo mp">// self-documenting function call<br/>new Character({<br/>  magic: true,<br/>  strength: 3,<br/>  movement: 5,<br/>  weapons: ['sword', 'staff'],<br/>  abilities: ['curse', 'stab'],<br/>})</span><span id="9146" class="lc ld iq md b gy mq mn l mo mp">// wtf??<br/>new Character(<br/>  true,<br/>  3,<br/>  5,<br/>  ['sword', 'staff'],<br/>  ['curse', 'stab']<br/>)</span></pre><p id="88a6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一般来说，您的函数应该请求执行其任务所需的最少信息。永远不要要求可以从其他论据中合理推导出的信息。</p><p id="d026" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以<strong class="kf ir">避免布尔参数</strong>，因为它们在阅读时描述性较差。例如<code class="fe ma mb mc md b">increaseSize(false)</code>就令人困惑。是加大尺寸还是不加大？它是否设置了一些可选的尺寸变化？不需要布尔形参，要么需要一个具有布尔属性的对象(<code class="fe ma mb mc md b">increaseSize({ width: false })</code>)，要么将函数一分为二(<code class="fe ma mb mc md b">increaseHeight</code>和<code class="fe ma mb mc md b">increaseSize</code>)，两者都不需要实参。</p><p id="ca6c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以<strong class="kf ir">将不同的行为拆分成单独的功能，而不是拆分单个功能的行为</strong>。与上面的例子类似，基于输入的拆分行为被称为“重载”一个函数。做得好的话，重载函数可以是一种神奇的用户体验。做得不好，功能会陷入混乱的泥潭。无论哪种方式，请注意，您是在为减少API表面而牺牲可预测性。</p><p id="1543" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以<strong class="kf ir">将默认为当前行为的可选参数</strong>添加到函数签名的末尾。面对现实吧，代码会改变。有时候一个函数并没有像它本该写的那样好。有时，当你意识到它依赖于一个可能需要改变的假设时，已经太晚了(在函数被使用之后)。如前所述，您可以编写一个新的函数来处理相同的任务，但是假设发生了变化，<em class="lb">或</em>您可以添加一个可选参数。如果您这样做，请将其默认为之前的假设，这样您就不会强制更改当前的使用。</p><p id="f27c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以<strong class="kf ir">可预测地对参数进行排序</strong>。可选参数放在最后，所以可以省略。不得不写<code class="fe ma mb mc md b">doThing(null, null, 3)</code>令人沮丧，因为前两个参数是可选的。即使在可选参数中，有些参数比其他参数<em class="lb">更</em>可选，例如<code class="fe ma mb mc md b">Array.prototype.slice</code>中的<code class="fe ma mb mc md b">endIndex</code>，所以按可选性升序排列。类似地，如果您将所有可选或配置参数组合成一个<code class="fe ma mb mc md b">options</code>对象参数，它应该放在最后— <code class="fe ma mb mc md b">throttle(fn, 300, { leading: true })</code>。</p><p id="9053" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">可变或“重要”的参数排在前面，比如<code class="fe ma mb mc md b">copy(array, startIndex, endIndex)</code>或<code class="fe ma mb mc md b">merge(toObject, fromObject)</code>。争论的相对“重要性”(我故意含糊其辞)应该继续在一个方向上，比如在<code class="fe ma mb mc md b">pipe(firstFn, secondFn, thirdFn)</code>和<code class="fe ma mb mc md b">compose(thirdFn, secondFn, firstFn)</code>中。我没有一个好的方法来决定这个<em class="lb">应该按照什么顺序</em>出现，但是它应该按照<em class="lb">和</em>的顺序出现，而不是像<code class="fe ma mb mc md b">doStuff(secondFn, firstFn, thirdFn)</code>那样。</p><p id="64fc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">可以<strong class="kf ir">不写函数</strong>。您可以选择保持逻辑内联，而不是放入新的函数中。请记住，将逻辑抽象成一个函数会引入间接性，并且<a class="ae kc" href="https://medium.com/@ntgard/duplication-first-programming-2cc9fc89cffe" rel="noopener">不会减少重复</a>。在引入一个新功能之前，要确保它的好处是值得付出的。</p><p id="0303" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，在程序中不需要的地方暴露更少的函数。将您的助手封装在您需要的地方，并防止从其他地方访问。如果发现该函数在其他地方有用，可以将其提升并作为程序的官方API的一部分公开。否则，将其隐藏在闭包中，或者作为模块中未导出的方法。</p><p id="b919" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">广泛公开功能/逻辑的一个典型借口是这是测试所必需的。测试应该总是蒙着眼睛进行。你应该测试的是公开的接口，而不是内部机制或状态。当一个未公开的助手函数的公开消费者被完全覆盖时，这个函数将在测试中被覆盖。</p><p id="eaec" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你可以从函数中<strong class="kf ir">返回一致的值</strong>。如果函数的一个分支返回一个承诺，那么每个分支都应该返回一个承诺。“快乐之路”返回一个数组吗？让“悲伤路径”返回空数组。避免让函数的消费者检查它返回了什么。与函数输出的交互应该和调用它一样可预测。</p><h2 id="dca8" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">关于滚装的一个注记</h2><p id="d96a" class="pw-post-body-paragraph kd ke iq kf b kg lv ki kj kk lw km kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">RO/RO模式(请求对象/返回对象)很棒，我推荐使用它，但是它引入了一个新的挑战:命名对象的属性。本着保持API一致性的精神，对象应该被很好地命名(参见前面的章节),并且<strong class="kf ir">应该只增长</strong>。取消或重命名这些对象中的一个属性是影响函数使用者的重大更改。</p><h2 id="b803" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">结论</h2><p id="cfcf" class="pw-post-body-paragraph kd ke iq kf b kg lv ki kj kk lw km kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">通过保持函数之间的边界小、可预测且定义明确，可以防止变化在程序中蔓延。不改变API的代码变化将以最小的代价带来改进，因为API的消费者不需要改变。将函数签名视为API使得测试能够轻松地覆盖输入和输出的每一种可能性，而无需操纵或依赖函数的内部或上下文。这就产生了健壮的测试套件，为程序接种疫苗防止程序出错。</p><h2 id="8f2a" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">附加阅读</h2><p id="5888" class="pw-post-body-paragraph kd ke iq kf b kg lv ki kj kk lw km kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated"><a class="ae kc" href="https://emptysqua.re/blog/api-evolution-the-right-way/" rel="noopener ugc nofollow" target="_blank">https://emptysqua.re/blog/api-evolution-the-right-way/</a></p></div></div>    
</body>
</html>