<html>
<head>
<title>AWS CDK for EKS — Kubernetes Manifest Handling</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">EKS的AWS CDK-Kubernetes清单处理</h1>
<blockquote>原文：<a href="https://itnext.io/aws-cdk-for-eks-kubernetes-manifest-handling-ebdec52e7f01?source=collection_archive---------4-----------------------#2021-05-07">https://itnext.io/aws-cdk-for-eks-kubernetes-manifest-handling-ebdec52e7f01?source=collection_archive---------4-----------------------#2021-05-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="fedf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">YAML——构建与解析</p><blockquote class="kl km kn"><p id="30e7" class="jn jo ko jp b jq jr js jt ju jv jw jx kp jz ka kb kq kd ke kf kr kh ki kj kk ij bi translated">…Jimmy Ray跟进了上一篇关于使用AWS CDK在亚马逊EKS上部署一个样本Java应用程序的文章，这篇文章深入探讨了Kubernetes YAML清单。从这些是什么到如何与AWS CDK一起使用它们，这是一个很好的帖子，可以帮助您了解在管理Kubernetes清单以及由此创建的Kubernetes资源时有哪些选择。— <strong class="jp ir"> Ricardo Sueiras，AWS开源新闻和更新#68 </strong></p></blockquote><p id="9181" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<a class="ae ks" href="https://jimmy-ray.medium.com/aws-cdk-where-imperative-meets-declarative-3d23fd4a4dbd" rel="noopener">之前的一篇文章</a>中，我简要介绍了如何使用AWS Cloud Development Kit (CDK)和Java来构建亚马逊EKS集群和相关的AWS资源(VPC、子网等)。)，并将应用程序部署到创建的集群。在这篇文章中，我将看看CDK如何处理库伯内特YAML清单。</p><h1 id="3a4e" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">表明</h1><p id="1745" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">任何与Kubernetes(又名k8s)合作过的人可能也处理过YAML的货物清单文件。以下示例是用于创建k8s命名空间的YAML清单。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="bc6d" class="mf ku iq mb b gy mg mh l mi mj">apiVersion: v1<br/>kind: Namespace<br/>metadata:<br/>  name: read-only<br/>  labels:<br/>    owner: jimmy<br/>    env: dev<br/>    app: read-only</span></pre><p id="5be7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通常，这些文件通过<em class="ko"> kubectl apply </em>命令应用到k8s集群。以这种声明的方式将更改应用到集群被认为是一种最佳实践，而不是使用更强制性的<em class="ko"> kubectl create </em>命令。</p><p id="1e46" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将AWS CDK与Java一起使用时,<a class="ae ks" href="https://docs.aws.amazon.com/cdk/api/latest/java/software/amazon/awscdk/services/eks/KubernetesManifest.Builder.html" rel="noopener ugc nofollow" target="_blank">kubernetasmifest。构建器</a>可以用来创建k8s清单。以下示例使用多个k8s清单对象(命名空间、部署、服务)创建一个k8s清单。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="c88c" class="mf ku iq mb b gy mg mh l mi mj">KubernetesManifest.Builder.<em class="ko">create</em>(this, "read-only")<br/>        .cluster(cluster)<br/>        .manifest((List&lt;? extends Map&lt;String, ? extends Object&gt;&gt;) List.<em class="ko">of</em>(ReadOnlyNamespace.<em class="ko">manifest</em>,<br/>                ReadOnlyDeployment.<em class="ko">manifest</em>, ReadOnlyService.<em class="ko">manifest</em>))<br/>        .overwrite(true)<br/>        .build();</span></pre><p id="932a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如代码所示，<em class="ko">kubernetasmifest</em>对象是地图对象的列表(序列)。这些映射还可以包含表示YAML结构的映射和列表，如下例所示。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="6c77" class="mf ku iq mb b gy mg mh l mi mj">public final class ReadOnlyNamespace {<br/><br/>    public static Map&lt;String, ? extends Object&gt; <em class="ko">manifest</em>;<br/><br/>    // Get properties object<br/>    private static final Properties <em class="ko">properties </em>= Config.<em class="ko">properties</em>;<br/><br/>    static {<br/>        <em class="ko">manifest </em>= Map.<em class="ko">of</em>("apiVersion", "v1",<br/>                "kind", "Namespace",<br/>                "metadata", Map.<em class="ko">of</em>("name", "read-only", "labels",<br/>                        Map.<em class="ko">of</em>("owner", Strings.<em class="ko">getPropertyString</em>("labels.owner", <em class="ko">properties</em>,<br/>                                Constants.<em class="ko">NOT_FOUND</em>.getValue()),<br/>                                "env",<br/>                                Strings.<em class="ko">getPropertyString</em>("labels.env", <em class="ko">properties</em>,<br/>                                        Constants.<em class="ko">NOT_FOUND</em>.getValue()),<br/>                                "app",<br/>                                Strings.<em class="ko">getPropertyString</em>("labels.app", <em class="ko">properties</em>,<br/>                                        Constants.<em class="ko">NOT_FOUND</em>.getValue())))<br/>        );<br/>    }<br/>}</span></pre><p id="4d1e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当CDK为这个栈创建CloudFormation模板时，k8s清单作为JSON定制资源存储在CloudFormation模板中。在下面的示例中，三个k8s配置(名称空间、部署、服务)作为JSON存储在CloudFormation定制资源中。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="d840" class="mf ku iq mb b gy mg mh l mi mj">readonlyB1EB06D3:<br/>  Type: Custom::AWSCDK-EKS-KubernetesResource<br/>  Properties:<br/>    ServiceToken:<br/>      Fn::GetAtt:<br/>        - awscdkawseksKubectlProviderNestedStackawscdkawseksKubectlProviderNestedStackResourceA7AEBA6B<br/>        - Outputs.EksStackawscdkawseksKubectlProviderframeworkonEvent47AB1AD9Arn<br/>    Manifest: '[{"apiVersion":"v1","kind":"Namespace","metadata":{"name":"read-only","labels":{"aws.cdk.eks/prune-c8157df28ab1a464bab539b75e7483fab124b22805":"","owner":"jimmy","env":"dev"}}},{"apiVersion":"apps/v1","kind":"Deployment","metadata":{"name":"read-only","namespace":"read-only","labels":{"aws.cdk.eks/prune-c8157df28ab1a464bab539b75e7483fab124b22805":"","app":"read-only","owner":"jimmy","env":"dev"}},"spec":{"revisionHistoryLimit":3,"selector":{"matchLabels":{"app":"read-only"}},"replicas":3,"strategy":{"type":"RollingUpdate","rollingUpdate":{"maxSurge":10,"maxUnavailable":1}},"template":{"metadata":{"labels":{"app":"read-only","owner":"jimmy","env":"dev"}},"spec":{"securityContext":{"fsGroup":2000},"containers":[{"name":"read-only","image":"public.ecr.aws/r2l1x4g2/go-http-server:v0.1.0-23ffe0a715","imagePullPolicy":"IfNotPresent","securityContext":{"allowPrivilegeEscalation":false,"runAsUser":1000,"readOnlyRootFilesystem":true},"resources":{"limits":{"cpu":"200m","memory":"20Mi"},"requests":{"cpu":"100m","memory":"10Mi"}},"readinessProbe":{"tcpSocket":{"port":8080},"initialDelaySeconds":5,"periodSeconds":10},"livenessProbe":{"tcpSocket":{"port":8080},"initialDelaySeconds":15,"periodSeconds":20},"ports":[{"containerPort":8080}],"volumeMounts":[{"mountPath":"/tmp","name":"tmp"}]}],"volumes":[{"name":"tmp","emptyDir":{}}]}}}},{"kind":"Service","apiVersion":"v1","metadata":{"name":"read-only","namespace":"read-only","labels":{"aws.cdk.eks/prune-c8157df28ab1a464bab539b75e7483fab124b22805":"","app":"read-only","owner":"jimmy","env":"dev"}},"spec":{"ports":[{"port":80,"targetPort":8080,"protocol":"TCP","name":"http"}],"type":"LoadBalancer","selector":{"app":"read-only"}}}]'<br/>    ClusterName:<br/>      Ref: cdkeksDB67CD5C<br/>    RoleArn:<br/>      Fn::GetAtt:<br/>        - cdkeksCreationRole8B89769F<br/>        - Arn<br/>    PruneLabel: aws.cdk.eks/prune-c8157df28ab1a464bab539b75e7483fab124b22805<br/>    Overwrite: true<br/>  DependsOn:<br/>    - cdkeksKubectlReadyBarrierA155E2C2<br/>  UpdateReplacePolicy: Delete<br/>  DeletionPolicy: Delete<br/>  Metadata:<br/>    aws:cdk:path: EksStack/read-only/Resource/Default</span></pre><h1 id="2dd0" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">解析YAML</h1><p id="58be" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">根据k8s对象配置的复杂程度，这些<em class="ko">kubernetasmifest</em>对象在Java中构建起来也可能相当复杂。如果k8s配置已经作为维护的YAML文件存在，那么<a class="ae ks" href="https://bitbucket.org/asomov/snakeyaml/src/master/" rel="noopener ugc nofollow" target="_blank"> SnakeYAML </a>可以用于解析原始YAML，并创建<em class="ko">kubernetsmanifest</em>对象所需的对象的<em class="ko">列表。</em></p><p id="c492" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在下面的例子中，我将原始的YAMLs作为静态的<a class="ae ks" href="https://docs.oracle.com/en/java/javase/15/text-blocks/index.html" rel="noopener ugc nofollow" target="_blank">文本块</a>存储在最终的Java类中。Java文本块是Java中相对较新的内容，类似于Groovy语言中的<a class="ae ks" href="https://groovy-lang.org/syntax.html#_triple_double_quoted_string" rel="noopener ugc nofollow" target="_blank">三双引号字符串。文本块是保留空白的多行文字字符串；它们是储存YAML的理想选择。这些YAMLs也可以存储在外部文件中，并通过Java </a><a class="ae ks" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/FileReader.html" rel="noopener ugc nofollow" target="_blank"> FileReader </a>或<a class="ae ks" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/InputStream.html" rel="noopener ugc nofollow" target="_blank"> InputStream </a>类读取。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="e2f6" class="mf ku iq mb b gy mg mh l mi mj"><em class="ko">/**<br/> * Contains static text blocks of K8s manifest YAMLs<br/> */<br/></em>public final class Yamls {<br/>    public static final String <em class="ko">namespace </em>= """<br/>                                    apiVersion: v1<br/>                                    kind: Namespace<br/>                                    metadata:<br/>                                      name: read-only<br/>                                      labels:<br/>                                        owner: jimmy<br/>                                        env: dev""";<br/><br/>    public static final String <em class="ko">deployment </em>= """<br/>            apiVersion: apps/v1<br/>            kind: Deployment<br/>            metadata:<br/>              name: read-only<br/>              namespace: read-only<br/>              labels:<br/>                app: read-only<br/>                owner: jimmy<br/>                env: dev<br/>            spec:<br/>              revisionHistoryLimit: 3<br/>              selector:<br/>                matchLabels:<br/>                  app: read-only<br/>              replicas: 3<br/>...</span></pre><p id="6938" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了解析YAML，我使用SnakeYAML。在下面的例子中，我编写了一个带有静态方法的实用程序类，使用非线程安全的<em class="ko"> Yaml </em>对象来解析字符串。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="4154" class="mf ku iq mb b gy mg mh l mi mj">package io.jimmyray.utils;<br/><br/>import io.jimmyray.aws.cdk.manifests.Yamls;<br/>import org.yaml.snakeyaml.Yaml;<br/>import java.util.Map;<br/><br/><em class="ko">/**<br/> * Provides helper methods for SnakeYaml parser<br/> */<br/></em>public class YamlParser {<br/>    public static void main(final String[] args) {<br/>        Map&lt;String, Object&gt; out = YamlParser.<em class="ko">parse</em>(Yamls.<em class="ko">namespace</em>);<br/>        System.<em class="ko">out</em>.println(out);<br/><br/>        out = YamlParser.<em class="ko">parse</em>(Yamls.<em class="ko">deployment</em>);<br/>        System.<em class="ko">out</em>.println(out);<br/><br/>        out = YamlParser.<em class="ko">parse</em>(Yamls.<em class="ko">service</em>);<br/>        System.<em class="ko">out</em>.println(out);<br/>    }<br/><br/>    <em class="ko">/**<br/>     * Parses YAML String and returns Map<br/>     * </em><strong class="mb ir"><em class="ko">@param </em></strong><em class="ko">in<br/>     * </em><strong class="mb ir"><em class="ko">@return<br/>     </em></strong><em class="ko">*/<br/>    </em>public static Map&lt;String, Object&gt; parse(final String in) {<br/>        Yaml yaml = new Yaml();<br/>        return yaml.load(in);<br/>    }<br/><br/>    <em class="ko">/**<br/>     * Parses YAML String of multiple objects and returns Iterable<br/>     * </em><strong class="mb ir"><em class="ko">@param </em></strong><em class="ko">in<br/>     * </em><strong class="mb ir"><em class="ko">@return<br/>     </em></strong><em class="ko">*/<br/>    </em>public static Iterable&lt;Object&gt; parseMulti(final String in) {<br/>        Yaml yaml = new Yaml();<br/>        return yaml.loadAll(in);<br/>    }<br/>}</span></pre><p id="755c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过使用<em class="ko"> List.of() </em>方法，从<em class="ko"> parse </em>方法返回的对象可以在<em class="ko">kubernetasmifest</em>列表对象中使用，如下面的代码片段所示。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="e524" class="mf ku iq mb b gy mg mh l mi mj">KubernetesManifest.Builder.create(this, "read-only")<br/>                .cluster(cluster)<br/>                .manifest(List.of(YamlParser.parse(Yamls.namespace),<br/>                        YamlParser.parse(Yamls.deployment),<br/>                        YamlParser.parse(Yamls.service.replace("&lt;REMOTE_ACCESS_CIDRS&gt;",<br/>                              Strings.getPropertyString("remote.access.cidrs", properties, "")))))<br/>                .overwrite(true)<br/>                .build();</span></pre><p id="549a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意，我用一个已解析的属性替换了<em class="ko">&lt;REMOTE _ ACCESS _ CIDRS&gt;</em>字符串。这会将逗号分隔的CIDR范围插入到<em class="ko">service.beta.kubernetes.io/load-balancer-source-ranges</em>注释中。这导致为创建负载平衡器时创建的安全组添加入站IP规则。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="d69a" class="mf ku iq mb b gy mg mh l mi mj">annotations:<br/>                service.beta.kubernetes.io/load-balancer-source-ranges: &lt;REMOTE_ACCESS_CIDRS&gt;</span></pre><figure class="lw lx ly lz gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi mk"><img src="../Images/4c8e0ac5350d3adc302cf30303afba08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W0C5K400O3_2TY5nzh9VEw.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">ELB入境规则</figcaption></figure><p id="a5c0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用前面的<em class="ko">kubernetsmanifest</em>对象<em class="ko"> </em>创建的堆栈使用在<em class="ko"> cdk引导</em>操作期间安装在<em class="ko"> CDKToolkit </em>堆栈中的CDK资产，通过<a class="ae ks" href="https://aws.amazon.com/lambda/" rel="noopener ugc nofollow" target="_blank"> AWS Lambda </a>对目标集群进行<em class="ko"> kubectl </em>调用。结果是在下面的<em class="ko"> kubectl </em>命令中看到的对象。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="eb77" class="mf ku iq mb b gy mg mh l mi mj">kubectl -n read-only get all</span></pre><figure class="lw lx ly lz gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi mw"><img src="../Images/ccad34060dded9b21072b49aa22e58d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e35x1JY8iEk_uvI_WQP39w.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">CDK创作的Kubernetes物品</figcaption></figure><h1 id="675e" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">从托管的Git存储库中提取原始文件</h1><p id="9787" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">另一种获取YAML的方法是直接从托管的Git仓库(比如GitHub)中获取原始文件。下面的<em class="ko"> WebRetriever </em>方法就是这样做的，它使用了<a class="ae ks" href="https://docs.oracle.com/en/java/javase/15/docs/api/java.base/java/net/URLConnection.html" rel="noopener ugc nofollow" target="_blank"> URLConnection </a>和<a class="ae ks" href="https://docs.oracle.com/en/java/javase/15/docs/api/java.base/java/io/BufferedReader.html" rel="noopener ugc nofollow" target="_blank"> BufferedReader </a>对象。文件被下载并存储在Java文本块中。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="f0de" class="mf ku iq mb b gy mg mh l mi mj"><em class="ko">/**<br/> * Get raw file from GitHub<br/> * </em><strong class="mb ir"><em class="ko">@param </em></strong><em class="ko">in<br/> * </em><strong class="mb ir"><em class="ko">@return<br/> </em></strong><em class="ko">* </em><strong class="mb ir"><em class="ko">@throws </em></strong><em class="ko">IOException<br/> */<br/></em>public static String getRaw(final String in) throws IOException {<br/>    URL url;<br/>    String file = """<br/>            """;<br/>    url = new URL(in);<br/>    URLConnection uc;<br/>    uc = url.openConnection();<br/>    uc.setRequestProperty("X-Requested-With", "Curl");<br/><br/>    BufferedReader reader = new BufferedReader(new InputStreamReader(uc.getInputStream()));<br/>    String line = null;<br/>    while ((line = reader.readLine()) != null)<br/>        file = file + line + "\n";<br/><br/>    return file;<br/>}</span></pre><p id="0457" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下载后，<em class="ko"> YamlParser.parseMulti(…) </em>方法解析下载文件中的多个清单。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="2a9d" class="mf ku iq mb b gy mg mh l mi mj"><em class="ko">/**<br/> * Parses YAML String of multiple objects and returns Iterable<br/> * </em><strong class="mb ir"><em class="ko">@param </em></strong><em class="ko">in<br/> * </em><strong class="mb ir"><em class="ko">@return<br/> </em></strong><em class="ko">*/<br/></em>public static Iterable&lt;Object&gt; parseMulti(final String in) {<br/>    Yaml yaml = new Yaml();<br/>    return yaml.loadAll(in);<br/>}</span></pre><p id="7de7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后解析后的YAML作为一个包含每个YAML清单的<a class="ae ks" href="https://docs.oracle.com/en/java/javase/15/docs/api/java.base/java/lang/Iterable.html" rel="noopener ugc nofollow" target="_blank"> Iterable </a>返回，然后可以被迭代并添加到<em class="ko">kubernetsmain。建造者</em>。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="a900" class="mf ku iq mb b gy mg mh l mi mj">/*<br/> * Parse multiple docs in same string<br/> */<br/>String yamlFile = null;<br/><br/>/*<br/> * Try to get the YAML from GitHub<br/> */<br/>try {<br/>    yamlFile = WebRetriever.<em class="ko">getRaw</em>(Strings.<em class="ko">getPropertyString</em>("ssm.agent.installer.url", properties, ""));<br/>} catch (IOException e) {<br/>    e.printStackTrace();<br/>}<br/><br/>if (yamlFile == null) yamlFile = Yamls.<em class="ko">ssmAgent</em>;<br/><br/>if (null != yamlFile &amp;&amp; !yamlFile.isBlank()) {<br/><br/>    Iterable&lt;Object&gt; manifestYamls = YamlParser.<em class="ko">parseMulti</em>(yamlFile);<br/>    List manifestList = new ArrayList();<br/>    for (Object doc : manifestYamls) {<br/>        manifestList.add((Map&lt;String, ? extends Object&gt;) doc);<br/>    }<br/><br/>    KubernetesManifest.Builder.<em class="ko">create</em>(this, "ssm-agent")<br/>            .cluster(cluster)<br/>            .manifest(manifestList)<br/>            .overwrite(true)<br/>            .build();<br/>}</span></pre><p id="b24e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上面的示例中，YAML被检索并用于一个<a class="ae ks" href="https://github.com/aws-samples/ssm-agent-daemonset-installer" rel="noopener ugc nofollow" target="_blank"> AWS Systems Manager (SSM)代理安装程序</a> k8s <a class="ae ks" href="https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/" rel="noopener ugc nofollow" target="_blank"> Daemonset </a>资源，该资源将节点连接到SSM，用于机群管理和其他操作用例。使用SSM代理将不再需要节点的SSH密钥。</p><figure class="lw lx ly lz gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi mx"><img src="../Images/68dd0d506bd763e1ffc47117301aa557.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JvLx_WTSoMbxAthgWosWhg.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">AWS系统经理车队管理控制台</figcaption></figure><h1 id="2259" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">排序配置</h1><p id="d886" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">根据<a class="ae ks" href="https://kubernetes.io/docs/concepts/configuration/overview/" rel="noopener ugc nofollow" target="_blank"> kubernetes.io </a>的说法，在同一个文件(甚至目录)中管理多个相关的配置被认为是最佳实践。在AWS CDK中，多个相关配置应该在同一个<em class="ko">kubernetasmifest中进行管理。构建器</em>对象。使用多个<em class="ko">kubernetasmifest。管理相关k8s资源的构建器</em>对象，比如那些具有依赖关系的对象，会导致不确定的行为(竞争条件),从而导致<em class="ko"> kubectl apply </em>调用失败。配置存储在Java列表中，这些列表是有序的序列，所以让代码来管理操作的依赖关系和顺序。</p><h1 id="5a39" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">摘要</h1><p id="3610" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">使用AWS CDK，有多种方法来处理YAML和用于创建Kubernetes资源的结果对象图。</p><p id="313e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="ko">这个帖子的示例代码可以从这个</em><a class="ae ks" href="https://github.com/jimmyraywv/aws-cdk-eks" rel="noopener ugc nofollow" target="_blank"><em class="ko">GitHub repo</em></a><em class="ko">中得到。</em></p></div></div>    
</body>
</html>