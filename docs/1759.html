<html>
<head>
<title>How to Debug Your Point-Free Code with Ramda</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Ramda调试你的无点代码</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-debug-your-point-free-code-with-ramda-5c46bd743781?source=collection_archive---------2-----------------------#2019-01-21">https://itnext.io/how-to-debug-your-point-free-code-with-ramda-5c46bd743781?source=collection_archive---------2-----------------------#2019-01-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/77d858e3381918ec3971a0d7781bfa0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EYX5IAnXE1PjGu__NE_wrQ.jpeg"/></div></div></figure><p id="6308" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">大约六个月前，我开始在日常生活中使用<a class="ae kw" href="https://ramdajs.com/" rel="noopener ugc nofollow" target="_blank"> Ramda </a>，这是一个用于编写函数式JavaScript的库，总的来说，我认为它帮助我编写了更简单、更容易推理、更不容易出错的代码。这有多种原因，特别是不变性是其设计的核心，它通过功能组合鼓励可重用性。然而，无论你是一个多么优秀的程序员，你都不可避免地会遇到错误，当你遇到错误时，你通常希望这种体验尽可能的顺畅。</p><p id="ab79" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你像我一样，喜欢到处粘贴<code class="fe kx ky kz la b">console.log</code>语句来弄清楚发生了什么(我知道，我知道——我应该使用我的调试器)，那么从命令式编程方式到声明式编程方式的范式转变可能会在一开始让你感到困惑，特别是如果你试图做一些<a class="ae kw" href="http://randycoulman.com/blog/2016/06/21/thinking-in-ramda-pointfree-style/" rel="noopener ugc nofollow" target="_blank">没有要点的事情</a>。今天，我们将学习一个简单的技巧，它允许你窥视你的程序，并观察程序中任何给定步骤的值。</p><h2 id="0a42" class="lb lc iq bd ld le lf dn lg lh li dp lj kj lk ll lm kn ln lo lp kr lq lr ls lt bi translated">把它插在你的烟斗里抽吧</h2><p id="8d64" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">在Ramda中，您会经常发现自己通过管道将一个函数的返回值传递给另一个函数，以便对给定的输入应用一系列转换。Ramda提供了一个方便的<code class="fe kx ky kz la b"><a class="ae kw" href="https://ramdajs.com/docs/#pipe" rel="noopener ugc nofollow" target="_blank">pipe</a></code>函数来完成这个任务。</p><pre class="lz ma mb mc gt md la me mf aw mg bi"><span id="fd26" class="lb lc iq la b gy mh mi l mj mk">const add1AndMultiplyBy2 = R.pipe(<br/>  x =&gt; x + 1,<br/>  x =&gt; x * 2,<br/>);</span><span id="ef94" class="lb lc iq la b gy ml mi l mj mk">add1AndMultiplyBy2(1); // returns 4</span></pre><p id="0296" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们假设这两个lambdas实际上是可重用的，并在我们的管道外部将它们定义为独立的实用程序。</p><pre class="lz ma mb mc gt md la me mf aw mg bi"><span id="587b" class="lb lc iq la b gy mh mi l mj mk">const add1 = x =&gt; x + 1;<br/>const multiplyBy2 = x =&gt; x * 2;</span></pre><p id="419c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后我们可以使我们的<code class="fe kx ky kz la b">add1AndMultiplyBy2</code>函数完全无点。</p><pre class="lz ma mb mc gt md la me mf aw mg bi"><span id="986b" class="lb lc iq la b gy mh mi l mj mk">const add1AndMultiplyBy2 = R.pipe(<br/>  add1,<br/>  multiplyBy2,<br/>);</span></pre><p id="cfbc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">太好了——现在我们有了干净、优雅的代码，它对每一步发生的事情都是透明的。会出什么问题呢？</p><p id="f88a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">那么，如果在我们不知道的情况下，我们的<code class="fe kx ky kz la b">add1AndMultiplyBy2</code>函数被用字符串<code class="fe kx ky kz la b">'1'</code>而不是数字<code class="fe kx ky kz la b">1</code>调用，会怎么样呢？</p><pre class="lz ma mb mc gt md la me mf aw mg bi"><span id="f572" class="lb lc iq la b gy mh mi l mj mk">add1AndMultiplyBy2('1'); // returns 22</span></pre><p id="8bc2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">没错—这将返回数字<code class="fe kx ky kz la b">22</code>。向任何本能地知道这一点的人脱帽致敬。对于其他想知道发生了什么的人，让我们先来看看在没有管道的情况下，如何用普通的JavaScript编写我们的函数。</p><pre class="lz ma mb mc gt md la me mf aw mg bi"><span id="895d" class="lb lc iq la b gy mh mi l mj mk">function add1AndMultiplyBy2 (num) {<br/>  const plus1 = add1(num);<br/>  const plus1Times2 = multiplyBy2(plus1);</span><span id="1b74" class="lb lc iq la b gy ml mi l mj mk">  return plus1Times2;<br/>}</span></pre><p id="11cb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了弄清这个神秘的<code class="fe kx ky kz la b">22</code>的真相，您可能要做的第一件事就是在对<code class="fe kx ky kz la b">add1</code>的调用后贴一个<code class="fe kx ky kz la b">console.log</code>来观察它的返回值。</p><pre class="lz ma mb mc gt md la me mf aw mg bi"><span id="9dbe" class="lb lc iq la b gy mh mi l mj mk">function add1AndMultiplyBy2 (num) {<br/>  const plus1 = add1(num);<br/>  console.log(plus1); // logs '11'<br/>  const plus1Times2 = multiplyBy2(plus1);</span><span id="4dda" class="lb lc iq la b gy ml mi l mj mk">  return plus1Times2;<br/>}</span></pre><p id="c74b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">啊哈！狡猾，狡猾的JavaScript！它将数字<code class="fe kx ky kz la b">1</code>与字符串<code class="fe kx ky kz la b">'1'</code>连接在一起，产生<code class="fe kx ky kz la b">'11'</code>，然后传递给我们的<code class="fe kx ky kz la b">multiplyBy2</code>函数，通过类型强制的魔力，产生我们的最终返回值<code class="fe kx ky kz la b">22</code>。谜团解开了。</p><p id="43ea" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">很好——但是当使用Ramda时，如何得出这个不太明显的结论呢？如果我们使用漂亮的<code class="fe kx ky kz la b">pipe</code>回到更简洁的<code class="fe kx ky kz la b">add1AndMultiplyBy2</code>版本，我们会注意到没有地方可以粘贴<code class="fe kx ky kz la b">console.log</code>。</p><h2 id="d4d6" class="lb lc iq bd ld le lf dn lg lh li dp lj kj lk ll lm kn ln lo lp kr lq lr ls lt bi translated">R.tap()来救援！</h2><p id="8331" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">幸运的是，Ramda提供了一个名为<code class="fe kx ky kz la b"><a class="ae kw" href="https://ramdajs.com/docs/#tap" rel="noopener ugc nofollow" target="_blank">tap</a></code>的函数，它用一个提供的值运行一个给定的函数，然后返回值，不变。</p><p id="6e52" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">可以把它想象成一个<code class="fe kx ky kz la b"><a class="ae kw" href="https://ramdajs.com/docs/#identity" rel="noopener ugc nofollow" target="_blank">identity</a></code>函数(它除了返回提供给它的值之外什么也不做)，但是具有执行一些副作用的能力。</p><p id="7d95" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">那么这有什么用呢？现在，我们可以<code class="fe kx ky kz la b">console.log</code>管道中任何给定步骤的值，以观察出问题时发生了什么。</p><pre class="lz ma mb mc gt md la me mf aw mg bi"><span id="be35" class="lb lc iq la b gy mh mi l mj mk">const add1AndMultiplyBy2 = R.pipe(<br/>  add1,<br/>  R.tap(x =&gt; console.log('WTF', x)), // logs 'WTF' and '11'<br/>  multiplyBy2,<br/>);</span><span id="400f" class="lb lc iq la b gy ml mi l mj mk">add1AndMultiplyBy2('1'); // returns 22</span></pre><p id="169b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这一切，<em class="mm">没有打破我们的管道</em>。</p><p id="1f8d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这最后一点很重要，因为如果我们在调用<code class="fe kx ky kz la b">add1</code>后简单地传递<code class="fe kx ky kz la b">console.log</code>作为<code class="fe kx ky kz la b">pipe</code>中的下一个函数，我们实际上会改变最终结果，因为<code class="fe kx ky kz la b">console.log</code>返回<code class="fe kx ky kz la b">undefined</code>。</p><pre class="lz ma mb mc gt md la me mf aw mg bi"><span id="d99d" class="lb lc iq la b gy mh mi l mj mk">const add1AndMultiplyBy2 = R.pipe(<br/>  add1,<br/>  console.log, // returns undefined<br/>  multiplyBy2, // undefined * 2??<br/>);</span><span id="a2a8" class="lb lc iq la b gy ml mi l mj mk">add1AndMultiplyBy2('1'); // returns NaN, duh</span></pre><p id="2b78" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这可能会导致更多的混乱，特别是因为在管道中间返回<code class="fe kx ky kz la b">undefined</code>经常会抛出一个大错误，这时你可能会忍不住开始拔头发。</p><h2 id="73f7" class="lb lc iq bd ld le lf dn lg lh li dp lj kj lk ll lm kn ln lo lp kr lq lr ls lt bi translated">包装东西</h2><p id="fa23" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">由于使用<code class="fe kx ky kz la b">tap</code>将一些东西记录到控制台对于调试来说非常实用，所以让我们继续为这个特殊的用例创建一个包装器。</p><pre class="lz ma mb mc gt md la me mf aw mg bi"><span id="96aa" class="lb lc iq la b gy mh mi l mj mk">const log = msg =&gt; R.tap(x =&gt; console.log(msg, x));</span></pre><p id="1eca" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们可以在管道函数中的任何地方使用我们方便的<code class="fe kx ky kz la b">log</code>函数，就像我们使用常规的<code class="fe kx ky kz la b">console.log</code>一样，甚至不需要记住<code class="fe kx ky kz la b">tap</code>是如何工作的。</p><pre class="lz ma mb mc gt md la me mf aw mg bi"><span id="2233" class="lb lc iq la b gy mh mi l mj mk">const add1AndMultiplyBy2 = R.pipe(<br/>  add1,<br/>  log('value after add1: '), // logs "value after add1: 11"<br/>  multiplyBy2,<br/>);</span><span id="12a9" class="lb lc iq la b gy ml mi l mj mk">add1AndMultiplyBy2('1');</span></pre><p id="158f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">就这样结束了！😎</p></div><div class="ab cl mn mo hu mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ij ik il im in"><ol class=""><li id="d612" class="mu mv iq ka b kb kc kf kg kj mw kn mx kr my kv mz na nb nc bi translated">关于JavaScript中类型强制的更多信息，请查阅凯尔·辛普森的<a class="ae kw" href="https://github.com/getify/You-Dont-Know-JS/blob/master/types%20&amp;%20grammar/README.md#you-dont-know-js-types--grammar" rel="noopener ugc nofollow" target="_blank">类型和语法</a>一书。</li></ol></div></div>    
</body>
</html>