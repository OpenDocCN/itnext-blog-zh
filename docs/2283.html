<html>
<head>
<title>React: JSX &amp; Rendering</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应:JSX和渲染</h1>
<blockquote>原文：<a href="https://itnext.io/react-jsx-rendering-4405d3a3d6c3?source=collection_archive---------2-----------------------#2019-04-30">https://itnext.io/react-jsx-rendering-4405d3a3d6c3?source=collection_archive---------2-----------------------#2019-04-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/8f4481631a127e1318ab2fa325ed2415.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jJZHFQmhkq_7ohn18KrMhA.png"/></div></div></figure><p id="768c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果您是React新手，您可能听说过JSX，或<em class="kz"> JavaScript XML — </em>它是一种类似XML的元素和组件代码。在本文中，我们将了解什么是JSX&amp;为什么我们应该在React应用程序中使用它。我们还将了解什么是元素，以及如何将它们呈现到DOM中。</p></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><p id="e4f1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">🤓<em class="kz">想与web dev保持同步吗？</em> <br/>🚀<em class="kz">想要将最新消息直接发送到您的收件箱？<br/>🎉加入一个不断壮大的设计师&amp;开发者社区！</em></p><p id="9aa1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">在这里订阅我的简讯→</strong><a class="ae lh" href="https://easeout.eo.page/" rel="noopener ugc nofollow" target="_blank"><strong class="kd iu">https://ease out . EO . page</strong></a></p></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><h1 id="5d8d" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">什么是JSX？</h1><p id="fe59" class="pw-post-body-paragraph kb kc it kd b ke mg kg kh ki mh kk kl km mi ko kp kq mj ks kt ku mk kw kx ky im bi translated">如前所述，JSX是一种类似XML的代码，我们可以在用React编码时使用。它是由脸书团队开发的，旨在提供更简洁的语法，帮助简化开发人员的体验。让我们看看我们的第一个例子:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="94c5" class="mu lj it mq b gy mv mw l mx my">const greeting = &lt;h1&gt;Hello, World!&lt;/h1&gt;;</span></pre><p id="1dd7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">简单吧？</p><p id="0bde" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里我们有的既不是字符串也不是HTML。是JSX！在构建UI元素时，我们可以使用它来充分利用JavaScript的能力。虽然它不是强制性的，但它确实是一个非常有用的工具——当我们在JavaScript代码中使用UI时，它很好地阐明了这一点。</p><h1 id="f46c" class="li lj it bd lk ll mz ln lo lp na lr ls lt nb lv lw lx nc lz ma mb nd md me mf bi translated">使用JSX</h1><p id="c023" class="pw-post-body-paragraph kb kc it kd b ke mg kg kh ki mh kk kl km mi ko kp kq mj ks kt ku mk kw kx ky im bi translated">让我们扩展上面的例子，加入一个嵌入的表达式。</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="91af" class="mu lj it mq b gy mv mw l mx my">const user = 'Bob Burger';<br/>const greeting = &lt;h1&gt;Hello, {user}&lt;/h1&gt;;<br/><br/>ReactDOM.render(<br/>  greeting,<br/>  document.getElementById('root')<br/>);</span></pre><p id="5c47" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们使用花括号<code class="fe ne nf ng mq b">{}</code>将变量嵌入到JSX表达式中。在这些花括号中，我们可以嵌入任何有效的JavaScript表达式。例如<code class="fe ne nf ng mq b">user.firstName</code>或<code class="fe ne nf ng mq b">printName(user)</code>。</p><p id="4fbc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">注意:我们将在文章的后面详细讨论渲染，现在还不要去关心上面的渲染方法！</p><p id="841f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们嵌入一个调用的JavaScript函数的结果:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="0396" class="mu lj it mq b gy mv mw l mx my">function printName(user) {<br/>  return user.firstName + ' ' + user.lastName;<br/>}<br/><br/>const user = {<br/>  firstName: 'Bob',<br/>  lastName: 'Burger'<br/>};<br/><br/>const greeting = (<br/>  &lt;h1&gt;<br/>    Hello, {printName(user)}!<br/>  &lt;/h1&gt;<br/>);<br/><br/>ReactDOM.render(<br/>  greeting,<br/>  document.getElementById('root')<br/>);</span></pre><h1 id="2ed0" class="li lj it bd lk ll mz ln lo lp na lr ls lt nb lv lw lx nc lz ma mb nd md me mf bi translated">引擎盖下的JSX</h1><p id="6786" class="pw-post-body-paragraph kb kc it kd b ke mg kg kh ki mh kk kl km mi ko kp kq mj ks kt ku mk kw kx ky im bi translated">当我们渲染组件时，JSX到底在做什么？</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="a3ee" class="mu lj it mq b gy mv mw l mx my">function Greeting() {<br/>  return &lt;h1&gt;Hello, World!&lt;/h1&gt;<br/>}</span></pre><p id="1fc7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">由<code class="fe ne nf ng mq b">Greeting</code>组件呈现的每个元素都被分解成<code class="fe ne nf ng mq b">React.createElement</code>调用。上述示例将文件传输到:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="4e58" class="mu lj it mq b gy mv mw l mx my">function Greeting() {<br/>  return React.createElement("h1", {}, "Hello, World!")<br/>}</span></pre><h2 id="c391" class="mu lj it bd lk nh ni dn lo nj nk dp ls km nl nm lw kq nn no ma ku np nq me nr bi translated">React.createElement()</h2><p id="8f47" class="pw-post-body-paragraph kb kc it kd b ke mg kg kh ki mh kk kl km mi ko kp kq mj ks kt ku mk kw kx ky im bi translated">让我们看另一个例子:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="4b0a" class="mu lj it mq b gy mv mw l mx my">const greeting = (<br/>  &lt;h1 className="speak"&gt;<br/>    Hello, world!<br/>  &lt;/h1&gt;<br/>);</span></pre><p id="41c5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">编译后，该代码如下所示:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="d4f6" class="mu lj it mq b gy mv mw l mx my">const greeting = React.createElement(<br/>  'h1',<br/>  {className: 'speak'},<br/>  'Hello, world!'<br/>);</span></pre><p id="4c3b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这两个代码块是相同的。本质上，一个对象是这样创建的:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="a895" class="mu lj it mq b gy mv mw l mx my">const greeting= {<br/>  type: 'h1',<br/>  props: {<br/>    className: 'speak',<br/>    children: 'Hello, world!'<br/>  }<br/>};</span></pre><p id="e3ba" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这个对象被称为React元素，它的功能非常类似于对您在屏幕上看到的内容的描述。React使用这些对象构建DOM并保持其最新。</p><p id="1cae" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">从本质上说，JSX只是让<code class="fe ne nf ng mq b">React.createElement(component, props, …children)</code>功能看起来更顺眼。另一个例子:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="900c" class="mu lj it mq b gy mv mw l mx my">&lt;Navbar backgroundColor = "purple" opacity = {0.8}&gt;<br/>  Menu bar<br/>&lt;/Navbar&gt;</span></pre><p id="254a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">将传送到:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="ca66" class="mu lj it mq b gy mv mw l mx my">React.createElement(Navbar, {<br/>  backgroundColor: "purple",<br/>  opacity: 0.8<br/>}, "Menu bar");</span></pre><p id="c670" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在让我们继续看更多的概念…</p><h1 id="0ab8" class="li lj it bd lk ll mz ln lo lp na lr ls lt nb lv lw lx nc lz ma mb nd md me mf bi translated">JSX的道具</h1><p id="a0dd" class="pw-post-body-paragraph kb kc it kd b ke mg kg kh ki mh kk kl km mi ko kp kq mj ks kt ku mk kw kx ky im bi translated">在我的下一篇文章中，我们将深入探讨<strong class="kd iu">道具</strong>！现在最好记住，在构建组件时——它们通常会渲染子组件，这需要数据来正确渲染。我们传入的参数就是我们所说的道具。在JSX，有几种方法可以做到这一点，例如:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="c307" class="mu lj it mq b gy mv mw l mx my">// Defaults to "true" if no value is passed<br/>&lt;MyComponent connected /&gt;</span><span id="a0b7" class="mu lj it mq b gy ns mw l mx my">// String literals passed as props<br/>&lt;MyComponent user= "Bob Burger" /&gt;</span><span id="abaf" class="mu lj it mq b gy ns mw l mx my">// Expressions (below example will evaluate to 10)<br/>&lt;MyComponent total = {1 + 2 + 3 + 4} /&gt;</span><span id="2d6f" class="mu lj it mq b gy ns mw l mx my">// Spread attributes: passes the whole props object<br/>&lt;MyComponent selected = {...this.state} /&gt;</span></pre><p id="ee17" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">注意:<code class="fe ne nf ng mq b">if</code>语句和<code class="fe ne nf ng mq b">for</code>循环不是JavaScript中的表达式，所以不能直接在JSX中使用！相反，您可以这样编码:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="72a7" class="mu lj it mq b gy mv mw l mx my">function NumberType(props) {<br/>  let answer;<br/>  if (props.number % 2 == 0) {<br/>    answer = &lt;strong&gt;even&lt;/strong&gt;;<br/>  } else {<br/>    answer = &lt;i&gt;odd&lt;/i&gt;;<br/>  }<br/>  return &lt;div&gt;{props.number} is an {answer} number&lt;/div&gt;;<br/>}</span></pre><p id="cc9e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到我们的道具被传递到条件中，被评估，然后被返回——所有这些都是通过JSX完成的。</p><h1 id="e246" class="li lj it bd lk ll mz ln lo lp na lr ls lt nb lv lw lx nc lz ma mb nd md me mf bi translated">JSX的儿童</h1><p id="b100" class="pw-post-body-paragraph kb kc it kd b ke mg kg kh ki mh kk kl km mi ko kp kq mj ks kt ku mk kw kx ky im bi translated">随着您的应用程序变得越来越大，您会发现一些组件需要渲染子组件。然后这些子组件还需要渲染更多的子组件，以此类推！有了JSX，我们可以很好地管理这些元素的树状结构。经验法则是——组件返回的任何元素都会成为其子元素。</p><p id="84f8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们快速看一下用JSX渲染子元素的方法:</p><h2 id="479e" class="mu lj it bd lk nh ni dn lo nj nk dp ls km nl nm lw kq nn no ma ku np nq me nr bi translated">字符串文字</h2><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="300f" class="mu lj it mq b gy mv mw l mx my">&lt;MyComponent&gt;I'm a child!&lt;/MyComponent&gt;</span></pre><p id="9672" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这个非常基本的例子中，字符串<code class="fe ne nf ng mq b">I’m a child</code>是<code class="fe ne nf ng mq b">MyComponent</code>的子元素。通过<code class="fe ne nf ng mq b">MyComponent</code>的<code class="fe ne nf ng mq b">props.children</code>可以到达。</p><h2 id="ba1a" class="mu lj it bd lk nh ni dn lo nj nk dp ls km nl nm lw kq nn no ma ku np nq me nr bi translated">小时候的JSX元素</h2><p id="a732" class="pw-post-body-paragraph kb kc it kd b ke mg kg kh ki mh kk kl km mi ko kp kq mj ks kt ku mk kw kx ky im bi translated">假设我们要返回一个HTML子节点<code class="fe ne nf ng mq b">&lt;header&gt;</code>，它有两个自己的子节点:<code class="fe ne nf ng mq b">&lt;Nav /&gt;</code>和<code class="fe ne nf ng mq b">&lt;SearchBox /&gt;</code>。我们可以这样做:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="1b59" class="mu lj it mq b gy mv mw l mx my">function Header(props) {<br/>  return (<br/>    &lt;header&gt;<br/>      &lt;Nav /&gt;<br/>      &lt;SearchBox /&gt;<br/>    &lt;/header&gt;<br/>  )<br/>}</span></pre><h2 id="5608" class="mu lj it bd lk nh ni dn lo nj nk dp ls km nl nm lw kq nn no ma ku np nq me nr bi translated">公式</h2><p id="4828" class="pw-post-body-paragraph kb kc it kd b ke mg kg kh ki mh kk kl km mi ko kp kq mj ks kt ku mk kw kx ky im bi translated">我们还可以将表达式作为子对象传递，以呈现到我们的UI中。这对于待办事项应用程序非常有用，例如:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="d503" class="mu lj it mq b gy mv mw l mx my">function TodoItem(props) {<br/>  return &lt;li&gt;{props.content}&lt;/li&gt;;<br/>}<br/><br/>function TodoList() {<br/>  const todos = ['paint house', 'buy more chips', 'conquer world'];<br/>  return (<br/>    &lt;ul&gt;<br/>      {todos.map((content) =&gt; &lt;TodoItem key={content} content={content} /&gt;)}<br/>    &lt;/ul&gt;<br/>  );<br/>}</span></pre><h2 id="fc99" class="mu lj it bd lk nh ni dn lo nj nk dp ls km nl nm lw kq nn no ma ku np nq me nr bi translated">功能</h2><p id="ebc8" class="pw-post-body-paragraph kb kc it kd b ke mg kg kh ki mh kk kl km mi ko kp kq mj ks kt ku mk kw kx ky im bi translated">函数在处理重复时很有用，比如呈现重复的UI元素。我们可以创建React将自动为我们呈现的结构。</p><p id="2aff" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们看一个例子，我们使用一个<code class="fe ne nf ng mq b">.map()</code>函数在网站上创建新页面:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="e4f5" class="mu lj it mq b gy mv mw l mx my">// Array of current pages</span><span id="9293" class="mu lj it mq b gy ns mw l mx my">const pages = [<br/>  {<br/>    id: 1,<br/>    text: "Home",<br/>    link: "/"<br/>  },<br/>  {<br/>    id: 2,<br/>    text: "About",<br/>    link: "/about"<br/>  },<br/>  {<br/>    id: 3,<br/>    text: "Contact",<br/>    link: "/contact"<br/>  }<br/>];</span><span id="3720" class="mu lj it mq b gy ns mw l mx my">// Renders a &lt;ul&gt; which generates the &lt;li&gt; children</span><span id="1068" class="mu lj it mq b gy ns mw l mx my">function Nav() {<br/>  return (<br/>    &lt;ul&gt;<br/>      {pages.map(page =&gt; {<br/>        return (<br/>          &lt;li key={page.id}&gt;<br/>            &lt;a href={page.link}&gt;{page.text}&lt;/a&gt;<br/>          &lt;/li&gt;<br/>        );<br/>      })}<br/>    &lt;/ul&gt;<br/>  );<br/>}</span></pre><p id="57fd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">要向我们的网站添加一个新页面，我们只需要向数组<code class="fe ne nf ng mq b">pages</code>添加一个新对象&amp;让React处理剩下的事情！</p><h1 id="bf55" class="li lj it bd lk ll mz ln lo lp na lr ls lt nb lv lw lx nc lz ma mb nd md me mf bi translated">渲染元素</h1><p id="dc6a" class="pw-post-body-paragraph kb kc it kd b ke mg kg kh ki mh kk kl km mi ko kp kq mj ks kt ku mk kw kx ky im bi translated">我相信你在这篇文章中已经看到，当使用JSX的时候，我们是在使用元素来渲染我们的页面。一个<em class="kz">元素</em>描述了您在屏幕上看到的内容:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="1421" class="mu lj it mq b gy mv mw l mx my">const element = &lt;h1&gt;Hello!&lt;/h1&gt;;</span></pre><p id="e657" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">诸如此类的多种元素组合在一起将形成组件。在我的下一篇文章中，我们将详细讨论组件！</p><h2 id="b94c" class="mu lj it bd lk nh ni dn lo nj nk dp ls km nl nm lw kq nn no ma ku np nq me nr bi translated">将我们的元素呈现给DOM</h2><p id="b6e0" class="pw-post-body-paragraph kb kc it kd b ke mg kg kh ki mh kk kl km mi ko kp kq mj ks kt ku mk kw kx ky im bi translated">通常，在我们的HTML中会有一个像这样的<code class="fe ne nf ng mq b">&lt;div&gt;</code>:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="588f" class="mu lj it mq b gy mv mw l mx my">&lt;div id="root"&gt;&lt;/div&gt;<!-- --> </span></pre><p id="3448" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这就是我们的DOM节点。它里面的一切都是由React DOM处理的。</p><p id="5b0a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了将React元素呈现到我们的根节点中，我们将两者都传递给<code class="fe ne nf ng mq b">ReactDOM.render(),</code>,如下所示:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="9d75" class="mu lj it mq b gy mv mw l mx my">const element = &lt;h1&gt;Hello!&lt;/h1&gt;;<br/>ReactDOM.render(element, document.getElementById('root'));</span></pre><p id="d654" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe ne nf ng mq b">Hello!</code>将渲染到我们的页面。</p><h2 id="824d" class="mu lj it bd lk nh ni dn lo nj nk dp ls km nl nm lw kq nn no ma ku np nq me nr bi translated">更新渲染元素</h2><p id="29f5" class="pw-post-body-paragraph kb kc it kd b ke mg kg kh ki mh kk kl km mi ko kp kq mj ks kt ku mk kw kx ky im bi translated">注意，React元素是不可变的！一旦创建了元素，就不能更改其子元素或其属性。如果想要更新UI，您需要创建一个新元素并将其传递给<code class="fe ne nf ng mq b">ReactDOM.render()</code>。</p></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><p id="8f2f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"> <em class="kz">你准备好让你的JavaScript技能更上一层楼了吗？</em> </strong> <em class="kz">今天就开始用我的新电子书吧！无论你是想学习你的第一行代码，还是想扩展你的知识面并真正学习基础知识..</em><a class="ae lh" href="https://gum.co/mastering-javascript" rel="noopener ugc nofollow" target="_blank"><em class="kz">JavaScript掌握完全指南</em> </a> <em class="kz">带你从零到英雄！</em></p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nt"><img src="../Images/dde515044536421c6c999650977f80c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1fUokZkbKj-qlRPVN_Txrg.png"/></div></div><figcaption class="nu nv gj gh gi nw nx bd b be z dk translated"><em class="ny">现已上市！👉</em><a class="ae lh" href="https://gum.co/mastering-javascript" rel="noopener ugc nofollow" target="_blank">https://gum.co/mastering-javascript</a></figcaption></figure><h1 id="038b" class="li lj it bd lk ll mz ln lo lp na lr ls lt nb lv lw lx nc lz ma mb nd md me mf bi translated">结论</h1><p id="acd3" class="pw-post-body-paragraph kb kc it kd b ke mg kg kh ki mh kk kl km mi ko kp kq mj ks kt ku mk kw kx ky im bi translated">我们走吧！我们已经介绍了JSX和渲染的基础知识。我希望你开始看到这些概念对我们作为开发人员构建React应用程序是多么有用。</p><p id="9f3e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">通过利用JSX的能力在JavaScript中传递元素，我们正在构建非常可行的代码。JSX的结构与React配合得非常好，尽管JSX不是强制性的——但它提供了一种奇妙的开发体验。</p><p id="2e72" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我希望这篇文章对你有用！你可以<a class="ae lh" href="https://medium.com/@timothyrobards" rel="noopener">跟着我</a>上媒。我也在<a class="ae lh" href="https://twitter.com/easeoutco" rel="noopener ugc nofollow" target="_blank">推特</a>上。欢迎在下面的评论中留下任何问题。我很乐意帮忙！</p><h1 id="c9d1" class="li lj it bd lk ll mz ln lo lp na lr ls lt nb lv lw lx nc lz ma mb nd md me mf bi translated">关于我的一点点..</h1><p id="72d3" class="pw-post-body-paragraph kb kc it kd b ke mg kg kh ki mh kk kl km mi ko kp kq mj ks kt ku mk kw kx ky im bi translated">嘿，我是提姆！👋我是一名开发人员、技术作家和作家。如果你想看我所有的教程，可以在<a class="ae lh" href="http://www.easeout.co" rel="noopener ugc nofollow" target="_blank">我的个人博客</a>上找到。</p><p id="50a2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我目前正在撰写我的<a class="ae lh" href="http://www.easeout.co/freelance" rel="noopener ugc nofollow" target="_blank">自由职业完整指南</a>。坏消息是它还不可用！但是如果这是你可能感兴趣的东西，你可以<a class="ae lh" href="https://easeout.eo.page/news" rel="noopener ugc nofollow" target="_blank">注册，当它可用时会通知你👍</a></p><p id="71dc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">感谢阅读🎉</p></div></div>    
</body>
</html>