<html>
<head>
<title>As We May Kube*</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">正如我们可能Kube*</h1>
<blockquote>原文：<a href="https://itnext.io/as-we-may-kube-293b30c0a365?source=collection_archive---------4-----------------------#2018-11-22">https://itnext.io/as-we-may-kube-293b30c0a365?source=collection_archive---------4-----------------------#2018-11-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/9c996892a27fced3df8242a15138ef4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*80rIRdW86OOqds99tLi6dw.jpeg"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">万尼瓦尔·布什的Memex。</figcaption></figure><div class=""/><p id="6fcb" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们使用不同的编程语言和开发环境来编写应用程序。每种语言都有不同的流程，我们通常会经历不同的阶段，从原型开发到集成级活动，再到在应用程序投入生产后逐步添加功能或修复错误。现在，来自“传统”环境的开发人员对Kubernetes的期望<em class="la">通常是，他们自然的和众所周知的</em>工作流程尽可能少地改变<em class="la">。这篇文章回顾了我们在Kubernetes-land开发应用程序方面的现状，以及我们可能的发展方向。</em></p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><p id="1588" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi li translated"><span class="l lj lk ll bm lm ln lo lp lq di">为了发布特性，我们使用不同的编程语言。有时我们会使用多种语言，这取决于我们所处的阶段，有时我们会针对不同的问题同时使用不同的语言(锤子碰钉子？).不管你使用哪种语言——可能有很多原因让你选择一种语言——你都在以某种方式或风格使用编程语言:如果你是一名Java开发人员，你可能会(直接或间接地)使用Maven或Gradle来构建一个类似JAR的人工制品。您可能习惯于等待，比如说，两分钟，直到您可以启动那个JAR并看到您的最新迭代的源代码变更的效果。另一方面，如果你正在使用Python或Node.js，你会习惯于立即看到代码中更新的行为，就像，在你点击保存按钮之后？</span></p><p id="e132" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我的观点是，无论你使用哪种编程语言，你都有一定的流程。让我稍微扩展一下这一点…</p><h2 id="b609" class="ls lt jf bd lu lv lw dn lx ly lz dp ma kn mb mc md kr me mf mg kv mh mi mj mk bi translated">基线</h2><p id="8fc7" class="pw-post-body-paragraph kc kd jf ke b kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv mp kx ky kz ij bi li translated"><span class="l lj lk ll bm lm ln lo lp lq di">我们</span>通常会花一些时间来设置和定制我们喜欢的编辑器或IDE，从字体大小到像Git这样的源代码控制或首选键盘快捷键集这样的集成。一旦我们对编程环境——编辑器或IDE和编程语言——感到“如鱼得水”,就会出现某种流程。例如，这个流程可能是:1。添加几行代码，2。保存源代码(可能此时单元测试也会自动运行)，3 .所产生的人工制品被重新执行(取决于这里的语言，在解释语言的情况下可能是热重新加载，可能需要杀死并重新启动二进制文件)，4。查看代码更改的结果和/或调试代码。</p><figure class="mr ms mt mu gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mq"><img src="../Images/10a29cf84941d8ed0328fcf983742dd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LGiX9MjvhSFwdj0Dz7fTeA.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated"><strong class="bd lu">左</strong>—我的编辑展示了一个<a class="ae lr" href="https://github.com/mhausenblas/imgn/tree/master/containers" rel="noopener ugc nofollow" target="_blank">集装箱化的围棋app </a>。| <strong class="bd lu">右</strong>—表示在Kubernetes环境下运行的Go app。</figcaption></figure><p id="693d" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">有趣的是，当涉及到流程中的(强制)变更时，开发人员似乎是敏感的生物。这就引出了一个问题…</p><blockquote class="mv mw mx"><p id="8cbf" class="kc kd la ke b kf kg kh ki kj kk kl km my ko kp kq mz ks kt ku na kw kx ky kz ij bi translated">…当你开发一个在Kubernetes上运行的应用程序时，一个既定的开发流程会有什么变化？</p></blockquote><h2 id="e0ba" class="ls lt jf bd lu lv lw dn lx ly lz dp ma kn mb mc md kr me mf mg kv mh mi mj mk bi translated">Kubernetes和开发者体验(DX)</h2><p id="6478" class="pw-post-body-paragraph kc kd jf ke b kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv mp kx ky kz ij bi li translated"><span class="l lj lk ll bm lm ln lo lp lq di"> L </span> et来说说<a class="ae lr" href="https://hackernoon.com/developer-experience-dx-devs-are-people-too-6590d6577afe" rel="noopener ugc nofollow" target="_blank">开发者体验</a> (DX)。令人震惊的是，开发者也是用户。编辑器、构建工具、测试工具等开发工具的用户。—你猜怎么着，DX很重要！现在，Kubernetes作为一个平台来自一个规模很重要的环境，运营问题是DNA的一部分。例如，谷歌创造并拥有<a class="ae lr" href="https://landing.google.com/sre/" rel="noopener ugc nofollow" target="_blank"> SRE </a>迷因是有原因的。</p><blockquote class="mv mw mx"><p id="adb8" class="kc kd la ke b kf kg kh ki kj kk kl km my ko kp kq mz ks kt ku na kw kx ky kz ij bi translated">我尽可能用政治上正确的措辞来表达:开发人员不一定像运营人员那样喜欢Kubernetes的一个原因是，这是建立在相互的基础上的。</p></blockquote></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><figure class="mr ms mt mu gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nb"><img src="../Images/85b7ab62636887d39c60b5624105433b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jqW290BjekhKZ_0PZ0Cmng.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">向jonahbinario致敬。</figcaption></figure><p id="21e1" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">好的，那么Kubernetes的默认DX是多少？很高兴你问了，我们开始吧:</p><ol class=""><li id="1658" class="nc nd jf ke b kf kg kj kk kn ne kr nf kv ng kz nh ni nj nk bi translated">您通常的工作流，如前面的<em class="la">基线</em>部分所建立的，会产生一个或多个组成应用程序的工件:对于基于JVM的系统，可能是一个JAR或WAR文件，对于Python或Node.js，可能是一堆脚本，或者对于Go或Rust二进制文件。</li><li id="0c11" class="nc nd jf ke b kf nl kj nm kn nn kr no kv np kz nh ni nj nk bi translated">为了在Kubernetes上运行任何东西，您必须创建一个包含应用程序的容器映像，打包您的工件(JAR文件、脚本、二进制文件)。构建这样一个应用程序映像可以通过几种不同的方式来实现:<br/> a)通过本地构建，使用一个好的旧的<a class="ae lr" href="https://github.com/mhausenblas/imgn/blob/master/containers/Makefile" rel="noopener ugc nofollow" target="_blank"> Make文件和Docker </a>或者使用更轻量级的替代方法，比如<a class="ae lr" href="https://buildah.io/" rel="noopener ugc nofollow" target="_blank"> buildah </a>。<br/> b)使用远程构建，通过成熟的CI/CD管道，如GitLab 提供的<a class="ae lr" href="https://about.gitlab.com/product/continuous-integration/" rel="noopener ugc nofollow" target="_blank">或更轻量级的东西，如</a><a class="ae lr" href="https://developer.github.com/actions/" rel="noopener ugc nofollow" target="_blank"> GitHub Actions </a>或可能是100%开源的sr.ht环境。<br/>请注意，我们已经浏览了一遍，为了创建应用程序映像，需要首先选择一个基础映像。这可以是像<code class="fe nq nr ns nt b">alpine:3.5</code>或<code class="fe nq nr ns nt b">centos:7</code>这样简单的东西，也可以是像<code class="fe nq nr ns nt b">python:3</code>或<code class="fe nq nr ns nt b">amazon-corretto-8,</code>这样特定于语言的东西，但是无论你选择哪一个，都必须有人负责维护这个东西。</li><li id="fcb2" class="nc nd jf ke b kf nl kj nm kn nn kr no kv np kz nh ni nj nk bi translated">接下来，应用程序容器映像必须放入Kubernetes的<a class="ae lr" href="https://www.slant.co/topics/2436/~best-docker-image-private-registries" rel="noopener ugc nofollow" target="_blank">容器注册表</a>中，或者更准确地说，放入<code class="fe nq nr ns nt b">kubelet</code>容器注册表中，以便从中提取映像并启动应用程序容器，从技术上讲，应用程序容器是在pod的上下文中运行的。请注意，在这一点上，我们还没有考虑更高级别的管理抽象，如<a class="ae lr" href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/" rel="noopener ugc nofollow" target="_blank">部署</a>和<a class="ae lr" href="https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/" rel="noopener ugc nofollow" target="_blank">有状态集</a>或其他通信抽象，如<a class="ae lr" href="https://kubernetes.io/docs/concepts/services-networking/service/" rel="noopener ugc nofollow" target="_blank">服务</a>或存储抽象，例如<a class="ae lr" href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/" rel="noopener ugc nofollow" target="_blank">持久卷</a>。</li></ol><figure class="mr ms mt mu gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nu"><img src="../Images/17fa0100f93bd4959795f572456a0364.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5J9xgztH4ad7uP34Ldw_zA.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated"><strong class="bd lu">左</strong>—<a class="ae lr" href="https://builds.sr.ht/" rel="noopener ugc nofollow" target="_blank">Sr . ht建造</a>系统在运行。| <strong class="bd lu">右</strong>—git lab的CI中我的Go容器化app。</figcaption></figure><p id="3b9c" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">你也许可以想象，从你的编辑器/IDE中的代码改变到Kubernetes在上面概述的流程中部署你的应用程序的新版本的时间比你习惯的要长得多。根据我的经验，这可能需要几分钟的时间，这取决于所使用的CI管道和注册表。现在想象一下，每次你修改一两行代码，你必须等待，比如说，5分钟才能看到结果。不酷。</p><p id="1018" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">那么，如何才能缩短这个周期呢？目前的方法大致可分为以下几类:</p><ul class=""><li id="7a56" class="nc nd jf ke b kf kg kj kk kn ne kr nf kv ng kz nv ni nj nk bi translated">在本地构建的上下文中，您可以简化注册表推送部分，例如，通过直接使用Minikube 中的<a class="ae lr" href="https://abhishek-tiwari.com/local-development-environment-for-kubernetes-using-minikube/" rel="noopener ugc nofollow" target="_blank">容器引擎。</a></li><li id="5e27" class="nc nd jf ke b kf nl kj nm kn nn kr no kv np kz nv ni nj nk bi translated">有一些基于同步的工具可以替换正在运行的容器中的新制品(JAR、脚本、二进制文件),并可能执行热重载，例如<a class="ae lr" href="https://vapor-ware.github.io/ksync/" rel="noopener ugc nofollow" target="_blank"> ksync </a>或<a class="ae lr" href="https://github.com/redhat-developer/odo" rel="noopener ugc nofollow" target="_blank"> Odo </a>。这简化了构建和注册表推送阶段。</li><li id="a2f7" class="nc nd jf ke b kf nl kj nm kn nn kr no kv np kz nv ni nj nk bi translated">您可以使用基于代理的工具，比如<a class="ae lr" href="https://www.telepresence.io/" rel="noopener ugc nofollow" target="_blank"> Telepresence </a>，它将运行在本地机器上的服务公开到(远程)Kubernetes集群中，反之亦然，将运行在集群中的服务带到您的机器上。这在微服务设置中特别有用，在这种设置中，您的应用程序或服务可能是请求路径的一部分，而其他一些请求路径可能取决于您的请求路径，或者您可能正在调用其他请求路径。</li></ul><p id="90df" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">平心而论，人们在野外使用<a class="ae lr" href="https://www.reddit.com/r/golang/comments/9z0vpi/developing_locally_with_docker_vs_deploying_with/" rel="noopener ugc nofollow" target="_blank">还有许多其他方法</a>来缩短从代码更改到更新的应用程序在容器中运行的周转时间:</p><ul class=""><li id="ea7b" class="nc nd jf ke b kf kg kj kk kn ne kr nf kv ng kz nv ni nj nk bi translated">将Docker Compose用于开发，将Kubernetes仅用于集成级/产品级阶段。由于缺乏开发-生产奇偶校验，不建议使用。</li><li id="d268" class="nc nd jf ke b kf nl kj nm kn nn kr no kv np kz nv ni nj nk bi translated">更复杂的混合工具，如<a class="ae lr" href="https://github.com/GoogleContainerTools/skaffold" rel="noopener ugc nofollow" target="_blank"> Skaffold </a>或<a class="ae lr" href="https://draft.sh/" rel="noopener ugc nofollow" target="_blank"> Draft </a>，通常采用多种技术来实现流畅的流程。很好，但是有些学习曲线和固执己见的流程。</li><li id="6418" class="nc nd jf ke b kf nl kj nm kn nn kr no kv np kz nv ni nj nk bi translated">无服务器解决方案，即功能即服务(Function-as-a-Service，FaaS)框架，如Kubeless、OpenFaaS或Apache OpenWhisk，所有的<a class="ae lr" href="https://go-talks.appspot.com/github.com/mhausenblas/2018-state-of-faas-on-kube/main.slide#1" rel="noopener ugc nofollow" target="_blank">都运行在Kubernetes </a>之上。在这个上下文中特别有趣的是<a class="ae lr" href="https://cloud.google.com/knative/" rel="noopener ugc nofollow" target="_blank"> Knative </a>，它为构建和服务提供了原语。此外，有第一次提供，如TriggerMesh，使Knative可访问；或者，您现在可以通过前面提到的FaaS产品越来越多地使用它。</li></ul><figure class="mr ms mt mu gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nw"><img src="../Images/e10ca728c3889745d6bf027b414761a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d1Q7Oke8Wu9agHK2Buhktg.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated"><a class="ae lr" href="https://triggermesh.com/" rel="noopener ugc nofollow" target="_blank"> TriggerMesh </a>，云原生构建和部署平台。可以把它看作是一种“Knative-as-a-Service ”,可以用它来构建容器映像，也可以用它来调用容器的功能即服务(Function-as-a-Service，FaaS)风格。</figcaption></figure><p id="6b26" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">2018年初，我和Weaveworks的Ilya Dmitrichenko仔细研究了在Kubernetes上开发应用的主题，我们在博客文章<a class="ae lr" href="https://kubernetes.io/blog/2018/05/01/developing-on-kubernetes/" rel="noopener ugc nofollow" target="_blank">中写下了在Kubernetes </a>上开发应用的经验教训，包括一些环境的实际操作。</p><p id="dba9" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">考虑到我们正在处理一个分布式系统和远程进程，还有一个有趣的问题是如何<a class="ae lr" rel="noopener ugc nofollow" target="_blank" href="/development-and-debugging-with-kubernetes-296bb60d9549">调试一个在Kubernetes </a>中运行的应用程序。这个领域已经有了一些工具，比如<a class="ae lr" href="https://github.com/solo-io/kubesquash" rel="noopener ugc nofollow" target="_blank"> KubeSquash </a>或者最近由Rookout 推出的<a class="ae lr" href="https://techcrunch.com/2018/11/15/rookout-launches-its-live-kubernetes-debugger/" rel="noopener ugc nofollow" target="_blank">产品，但是总体来说还处于早期阶段。</a></p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h2 id="ba89" class="ls lt jf bd lu lv lw dn lx ly lz dp ma kn mb mc md kr me mf mg kv mh mi mj mk bi translated">从这里去哪里？</h2><p id="bcc7" class="pw-post-body-paragraph kc kd jf ke b kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv mp kx ky kz ij bi li translated">很长一段时间以来，我一直在问自己这个问题:<em class="la">有没有更好的方法？开发人员在Kubernetes有宾至如归的感觉；或者也许是错误的抽象层次，也许开发者<em class="la">不应该</em>直接暴露给Kubernetes？</em></p><p id="351e" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">2018年初，我和<a class="ae lr" href="http://kubed.sh" rel="noopener ugc nofollow" target="_blank"> kubed-sh </a>尝试了一种不同的范式。本质上，这个工具提供了一个交互式的、基于shell的环境，该环境提供了对Kubernetes集群的访问。它允许你启动应用程序，而不需要接触pod、部署或服务。<a class="ae lr" href="https://www.useloom.com/share/441a97fd48ae46da8d786194f93968f6" rel="noopener ugc nofollow" target="_blank">看这个演示</a>(或者<a class="ae lr" href="https://katacoda.com/mhausenblas/scenarios/kubed-sh_hotreload" rel="noopener ugc nofollow" target="_blank">自己试试</a>):</p><figure class="mr ms mt mu gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nx"><img src="../Images/ac22bc269cc927d888ff8fbf3f32b3e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j7BBjUl6jxxK15sOS4eI1Q.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">使用中的<a class="ae lr" href="https://www.useloom.com/share/441a97fd48ae46da8d786194f93968f6" rel="noopener ugc nofollow" target="_blank"> kubed-sh热重装</a>功能。</figcaption></figure><p id="c444" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">有趣的是，<code class="fe nq nr ns nt b">kubed-sh</code>概念验证主要受到那些以前没有或很少使用过Kubernetes，特别是FWIW <code class="fe nq nr ns nt b">kubectl</code>的人的赞赏和欢迎。相反，更熟悉Kubernetes流程的人——构建容器映像，将它推送到容器注册中心，用容器部署pod常常很难看到<code class="fe nq nr ns nt b">kubed-sh</code>的价值。这本身就是一个宝贵的教训。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><blockquote class="mv mw mx"><p id="b002" class="kc kd la ke b kf kg kh ki kj kk kl km my ko kp kq mz ks kt ku na kw kx ky kz ij bi translated">总结一下:我不知道我们要去哪里。我所知道的是，我们在Kubernetes-land面临着DX-wise的挑战，目前我所能做的就是努力提高对我在野外目睹的问题的认识。</p></blockquote><p id="7712" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我可以记录现状，包括良好的实践和工具，<a class="ae lr" href="https://www.youtube.com/watch?v=1otz8iXrq1w" rel="noopener ugc nofollow" target="_blank">探索</a>方法，如<a class="ae lr" href="https://hackernoon.com/the-rise-of-cloud-native-programming-languages-211a5081f1b2" rel="noopener ugc nofollow" target="_blank">云本地编程语言</a>，基于FaaS的方法，如<a class="ae lr" href="https://duct.cloud/" rel="noopener ugc nofollow" target="_blank"> duct.cloud </a>或TriggerMesh，以及集成产品，包括GitHub Actions或<a class="ae lr" href="https://www.gitpod.io/" rel="noopener ugc nofollow" target="_blank"> Gitpod </a>。</p><p id="6f4d" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">你也可以这样做:)</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><p id="8df6" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">热心的读者当然已经意识到这个标题是对1945年的伟大文章 <a class="ae lr" href="https://www.theatlantic.com/magazine/archive/1945/07/as-we-may-think/303881/" rel="noopener ugc nofollow" target="_blank"> <em class="la">的无耻抄袭，正如我们可能认为的那样</em> </a> <em class="la">作者是有远见的万尼瓦尔·布什。</em></p></div></div>    
</body>
</html>