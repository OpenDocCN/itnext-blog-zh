<html>
<head>
<title>Thread Sanitizer in iOS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">iOS中的线程杀毒器</h1>
<blockquote>原文：<a href="https://itnext.io/thread-sanitizer-in-ios-8438ee3c8c76?source=collection_archive---------5-----------------------#2021-05-11">https://itnext.io/thread-sanitizer-in-ios-8438ee3c8c76?source=collection_archive---------5-----------------------#2021-05-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="fa4d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在进入Thread Sanitizer或TSan之前，我们需要了解数据竞争或竞争条件。数据竞争只不过是不同线程同时访问同一个地址。这种情况称为竞态条件，因此可能会发生许多问题，例如神秘的崩溃等。因此，这篇文章将涵盖数据竞争，以及我们在Xcode中如何识别这一点，以及我们如何解决这一问题。</p><h1 id="15f7" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">简介:</h1><p id="0cd7" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">当我们在一个多线程项目中工作时，比方说，从API中提取数据并将其存储在本地数据库中，同时UI需要显示本地数据库或CoreData中的现有数据。在这种情况下，如果我们在从不同的线程访问属性时(写入新获取的数据，从主线程访问数据以显示在UI中)没有正确地管理属性，那么就会发生竞争情况或数据竞争。解决由此产生的问题是耗时的，需要挖掘更多的信息来了解实际发生了什么。</p><h1 id="626f" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">模拟数据竞赛:</h1><p id="608e" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">为了理解“Thread Santizer ”,让我们模拟一个竞争条件，如下图所示。这里我们从一个后台线程和一个主线程访问一个惰性变量，因为它是一个惰性变量，只有在第一次被访问时才会初始化。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi lo"><img src="../Images/a24dcd393fb91eaf0c81e62a4e608e18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3VWlTl6vWjxrGZ95sa3k4Q.jpeg"/></div></div></figure><h2 id="1509" class="ma km iq bd kn mb mc dn kr md me dp kv jy mf mg kz kc mh mi ld kg mj mk lh ml bi translated">识别数据竞争:</h2><p id="e34d" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">幸运的是，在Xcode中，我们有一个名为“线程杀毒器”的工具，它可以帮助我们识别运行时数据竞争发生在哪里。因此，我们可以从编辑方案-&gt;运行时清理中启用它，如下图所示。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi mm"><img src="../Images/bbd5a38d1156134e221d731448771aa9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Lr4YLg0Xi17E20wW-9b-nQ.jpeg"/></div></div></figure><p id="9b34" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦我们实现了这一点，我们需要建立和运行应用程序。Thread Sanitizer将完成它的工作，为我们指出竞争条件出现的界限。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi mn"><img src="../Images/713a49ec6f2dca4e736227b1a1ca8e6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mA6jHLMrgnOpbUd7065rtw.jpeg"/></div></div></figure><h2 id="be7d" class="ma km iq bd kn mb mc dn kr md me dp kv jy mf mg kz kc mh mi ld kg mj mk lh ml bi translated">修复数据竞争:</h2><p id="15ec" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">有许多方法可以解决竞态条件，一个简单的方法是使用一个队列来完全控制这个属性，如下图所示。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi mo"><img src="../Images/03a8fda79eb3fa79be1787fffdb94089.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wriHz403EZn6ST_ygAWTww.jpeg"/></div></div></figure><p id="25cd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">经过这一改变后，如果我们在启用线程杀毒器的情况下运行我们的应用，那么数据竞争将不会出现，因为我们已经通过将它锁定在队列中解决了这一问题。</p><h2 id="6447" class="ma km iq bd kn mb mc dn kr md me dp kv jy mf mg kz kc mh mi ld kg mj mk lh ml bi translated">Swift 5.5更新:</h2><p id="e77a" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">Swift 5.5提出了一些很酷的并发编程概念，如<a class="ae mp" href="https://devcracker.medium.com/swift-actors-e80ff0dc1832" rel="noopener"> swift actor </a>和<a class="ae mp" href="https://devcracker.medium.com/mainactor-in-swift-detailed-walkthrough-94044c83118b" rel="noopener"> swift main actor </a>。请点击<a class="ae mp" href="https://devcracker.medium.com/mainactor-in-swift-detailed-walkthrough-94044c83118b" rel="noopener">链接</a>了解他们的想法。</p><p id="9abb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">希望这篇文章对iOS世界的人有所帮助，编码快乐！！！。</p><h2 id="cdc2" class="ma km iq bd kn mb mc dn kr md me dp kv jy mf mg kz kc mh mi ld kg mj mk lh ml bi translated">中等订阅:</h2><p id="3879" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">从<a class="ae mp" href="https://devcracker.medium.com/membership" rel="noopener">这里</a>升级您的中级会员资格，阅读大量文章并提升您的技能。</p></div></div>    
</body>
</html>