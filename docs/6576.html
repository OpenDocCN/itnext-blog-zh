<html>
<head>
<title>golang 1.18+ generics: The Good, The Bad, The Ugly.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">golang 1.18+仿制药:好的，坏的，丑的。</h1>
<blockquote>原文：<a href="https://itnext.io/golang-1-18-generics-the-good-the-bad-the-ugly-5e9fa2520e76?source=collection_archive---------0-----------------------#2021-12-22">https://itnext.io/golang-1-18-generics-the-good-the-bad-the-ugly-5e9fa2520e76?source=collection_archive---------0-----------------------#2021-12-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/af471866813ac0c831ac90156a33f405.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aAES3oN8i6dJiA5vzqVioA.png"/></div></div></figure><h1 id="d459" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">介绍</h1><p id="a485" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">泛型很棒，golang变得比以前更加方便。但是类似于渠道，这可能非常有用，我们不应该仅仅因为它们的存在就到处使用它们(见<a class="ae lu" href="https://opensource.com/article/17/9/seven-stages-becoming-go-programmer" rel="noopener ugc nofollow" target="_blank">阶段4 </a>)。</p><p id="1b24" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">有<strong class="ky ir">好的</strong>用例，即使不是简单地用在数据结构中。有一些<strong class="ky ir">坏的</strong>用例，比如一般的日志记录器。有一些解决方案可以使用，但是很难看。</p><p id="0215" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">然后就是真的很丑。</p><p id="e4f9" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">让我们来看一个例子！</p><h1 id="05d6" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">好人</h1><p id="ff92" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我真正梦想在golang中做的，也是我认为我现在最终可以做的，是一个CRUD端点的通用提供者:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="b5aa" class="mj jz iq mf b gy mk ml l mm mn">type Model interface{<br/>    ID() string<br/>}</span><span id="1c95" class="mj jz iq mf b gy mo ml l mm mn">type DataProvider[MODEL Model] interface {<br/>    FindByID(id string) (MODEL, error)<br/>    List() ([]MODEL, error)<br/>    Update(id string, model MODEL) error<br/>    Insert(model MODEL) error<br/>    Delete(id string) error<br/>}</span></pre><p id="3ca1" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">这是一个很大的接口，你可以根据你的具体用例来缩短它，但是，为了完整性，它就在这里。</p><p id="c16d" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">现在，您可以定义一个使用DataProvider的HTTP处理程序:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="6eaa" class="mj jz iq mf b gy mk ml l mm mn">type HTTPHandler[MODEL Model] struct {<br/>    dataProvider DataProvider[MODEL]<br/>}</span><span id="07ad" class="mj jz iq mf b gy mo ml l mm mn">func (h HTTPHandler[MODEL]) FindByID(rw http.ResponseWriter, req *http.Request) {<br/>    // validate request here   </span><span id="aa47" class="mj jz iq mf b gy mo ml l mm mn">    id = // extract id here</span><span id="237c" class="mj jz iq mf b gy mo ml l mm mn">model, err := h.dataProvider.FindByID(id)<br/>    if err != nil { <br/>        // error handling here<br/>        return<br/>    }<br/>    err = json.NewEncoder(rw).Encode(model)<br/>    if err != nil { <br/>        // error handling here<br/>        return<br/>    }<br/>}</span></pre><p id="0752" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">如你所见，我们可以为每个方法实现一次，然后就完成了。我们甚至可以在事物的反面创建一个客户端，对于基本方法我们只需要实现一次。</p><p id="7558" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">为什么我们在这里使用泛型，而不仅仅是我们已经定义的模型接口？</p><p id="17d1" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">这里，泛型比使用模型类型本身有一些优势:</p><ol class=""><li id="b330" class="mp mq iq ky b kz lv ld lw lh mr ll ms lp mt lt mu mv mw mx bi translated">使用通用方法，DataProvider根本不需要知道模型，也不需要实现它。它可以简单地提供它的具体类型，这是非常强大的(但仍然可以抽象为简单的用例)</li><li id="60aa" class="mp mq iq ky b kz my ld mz lh na ll nb lp nc lt mu mv mw mx bi translated">我们可以扩展这个解决方案，用具体的类型进行操作。让我们看看插入或更新的验证器是什么样子的。</li></ol><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="24ac" class="mj jz iq mf b gy mk ml l mm mn">type HTTPHandler[MODEL any] struct {<br/>    dataProvider DataProvider[MODEL]<br/>    InsertValidator func(new MODEL) error<br/>    UpdateValidator func(old MODEL, new MODEL) error</span><span id="5b72" class="mj jz iq mf b gy mo ml l mm mn">}</span></pre><p id="882f" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">通用方法的真正优势在于这个验证器。我们将解组HTTP请求，如果定义了一个自定义的InsertValidator，那么我们可以使用它来验证模型是否检查通过，我们可以用一种类型安全的方式来完成它，并使用具体的模型:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="a322" class="mj jz iq mf b gy mk ml l mm mn">type User struct {<br/>    FirstName string<br/>    LastName string<br/>}</span><span id="adb0" class="mj jz iq mf b gy mo ml l mm mn">func InsertValidator(u User) error {<br/>    if u.FirstName == "" { ... } <br/>    if u.LastName == "" { ... }<br/>}</span></pre><p id="7fa9" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">所以我们有一个通用的处理程序，我们可以用定制的回调函数来调整它，这样可以直接得到有效负载。没有类型转换。没有地图。只是结构本身！</p><h1 id="c48a" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">坏事</h1><p id="6c21" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">让我们来看看我在<a class="ae lu" href="https://medium.com/@mier85/self-referencing-interfaces-in-golang-1-18-bcd6b5701992" rel="noopener">上一篇文章</a>中写的通用日志:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="692b" class="mj jz iq mf b gy mk ml l mm mn">type GenericLogger[T any] interface {<br/>    WithField(string, string) T<br/>    Info(string)<br/>}</span></pre><p id="8950" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">这本身还不是很有用。向记录器添加键值字符串对有更简单的方法，并且没有记录器(据我所知)真正实现这个接口。我们也不需要新的日志标准。如果我们想使用例如- <a class="ae lu" href="https://github.com/sirupsen/logrus" rel="noopener ugc nofollow" target="_blank"> logrus </a>我们必须这样做:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="a454" class="mj jz iq mf b gy mk ml l mm mn">type GenericLogger[T any, FIELD map[string]interface{}] interface{<br/>    WithFields(M) T<br/>    Info(string)<br/>}</span></pre><p id="7590" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">如果我们添加自引用部分，这实际上可以由logrus logger实现。但是，让我们考虑在实际的结构中使用它，比如某种处理程序:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="4fde" class="mj jz iq mf b gy mk ml l mm mn">type MessageHandler[T GenericLogger[T], FIELD map[string]interface{}] struct {<br/>    logger GenericLogger[T, FIELD]<br/>}<br/></span></pre><p id="868d" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">正如你所看到的，为了在一个结构中使用这个记录器，我们需要使我们的结构通用，这只是一个记录器。如果MessageHandler本身处理一般消息，那么它将变成第三个类型参数！</p><p id="7d55" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">到目前为止，甚至没有办法用泛型将它赋给变量。因此，尽管我们可以用一个接口来表示这个日志记录器是很棒的，但我还是建议不要这样做。我最喜欢的log lib (zap) ，由于其字段的性质，甚至不能用它来表示。</p><h1 id="c4da" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">丑陋的</h1><p id="506a" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">当我摆弄泛型时，我无意中发现缺少对在方法中引入新的泛型参数的支持。虽然这可能有很好的理由，但它确实需要一些变通办法。让我们想象一下，我们想把一个map简化为一个int。我们理想的做法是使用一个返回新的泛型参数的方法，然后我们可以简单地提供map reduce函数。</p><p id="c724" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">那么，当我们仍然希望以一种通用的方式缩小地图时，我们该怎么做呢？因为没有方法，所以让我们横向创建一个方法:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="fd43" class="mj jz iq mf b gy mk ml l mm mn">type GenericMap[KEY comparable, VALUE any] map[KEY]VALUE</span><span id="f445" class="mj jz iq mf b gy mo ml l mm mn">func (g GenericMap[KEY, VALUE]) Values() []VALUE {<br/> values := make([]VALUE, len(g))<br/> for _, v := range g {<br/>  values = append(values, v)<br/> }<br/> return values<br/>}</span><span id="d92c" class="mj jz iq mf b gy mo ml l mm mn">func Reduce[KEY comparable, VALUE any, RETURN any](g GenericMap[KEY, VALUE], callback func(RETURN, KEY, VALUE) RETURN) RETURN {<br/> var r RETURN<br/> for k, v := range g {<br/>     r = callback(r, k, v)<br/> }<br/> return r<br/>}</span></pre><p id="fbf0" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">如您所见，GenericMap成为我们的Reduce函数的第一个参数。在这种情况下，您可以使用任何类型的map作为第一个参数，而不是GenericMap。然而，我想说的是，如果这个方法本身是泛型映射的一部分，那就太好了。即使它不是，我们仍然可以模仿它的行为。总的来说，我可能仍然会在一些用例中使用这种模式，尽管它实际上很难看。</p><h1 id="2068" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">真正丑陋的</h1><p id="4ac8" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">有时您可能想要利用工厂模式，它为您提供类似于DataProviders的东西。您可能希望在动态注册的端点上获得一个提供者。所以你可以这样做:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="6e1f" class="mj jz iq mf b gy mk ml l mm mn">type DataProviderFactory struct {<br/>    dataProviders map[providerKey]any<br/>}</span><span id="4338" class="mj jz iq mf b gy mo ml l mm mn">func ProviderByName[MODEL Model](factory *DataProviderFactory, name string) (DataProvider[MODEL], bool) {<br/>        var m MODEL<br/>    prov, has := factory.dataProviders[providerKey{name: name, typ: reflect.TypeOf(m)}]<br/>    if !has {<br/>       return nil, false<br/>    }<br/>    return prov.(DataProvider[MODEL]), true <br/>}</span><span id="fb45" class="mj jz iq mf b gy mo ml l mm mn">func RegisterProvider[MODEL Model](factory *DataProviderFactory, name string, p DataProvider[MODEL]) {<br/>    var m MODEL<br/>    factory.dataProviders[providerKey{name: name, typ: reflect.TypeOf(m)}] = p <br/>}</span></pre><p id="7199" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">虽然这种方法可行，而且可能有用，但它很丑陋。首先，它把丑和更丑的东西结合在一起，这就是反射。</p><p id="b498" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">虽然从技术上来说这应该是类型安全的，但是由于我们的名称和反射类型的组合键，它仍然是丑陋的。我会很纠结是否要把它放到生产代码附近。</p><h1 id="2b53" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">结论</h1><p id="8ae1" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">虽然我喜欢泛型，但我认为很难取得平衡，尤其是在开始的时候。所以我们需要确保记住它们为什么存在，在什么情况下我们应该使用它们，以及什么时候我们应该避免它们！</p></div></div>    
</body>
</html>