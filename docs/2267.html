<html>
<head>
<title>Functional Reactive Programming in Scala from Scratch (Part 2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Scala中的函数式反应式编程(第2部分)</h1>
<blockquote>原文：<a href="https://itnext.io/functional-reactive-programming-in-scala-from-scratch-part-2-3d1559a11629?source=collection_archive---------5-----------------------#2019-04-26">https://itnext.io/functional-reactive-programming-in-scala-from-scratch-part-2-3d1559a11629?source=collection_archive---------5-----------------------#2019-04-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="91c1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这一系列的文章中，我们想从头开始为Scala中的函数式反应式编程开发一个小框架。如果你还没有阅读该系列的第一部分，请务必在这里查看<a class="ae ko" rel="noopener ugc nofollow" target="_blank" href="/functional-reactive-programming-in-scala-from-scratch-part-1-9f9db0c47478"/>。第3部分可以在这里找到<a class="ae ko" href="https://medium.com/@timo.stoettner/functional-reactive-programming-in-scala-from-scratch-part-3-d999dca5fa69" rel="noopener">。</a></p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi kp"><img src="../Images/5cf7df4b38a88f4f66b54915f2471454.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*c2FuG-EYNheUU45Q"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">照片由<a class="ae ko" href="https://unsplash.com/@emilep?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">émile Perron</a>在<a class="ae ko" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="81dc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="lf">注:你可以在</em> <a class="ae ko" href="https://github.com/timo-stoettner/frp-scala" rel="noopener ugc nofollow" target="_blank"> <em class="lf">这个GitHub资源库</em> </a> <em class="lf">中找到有完整代码的笔记本。</em></p></div><div class="ab cl lg lh hx li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="im in io ip iq"><p id="173f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在上一篇文章中，我们从Scala中函数式反应式编程的一个小框架的实现开始。我们的目标是为<code class="fe ln lo lp lq b">Signal</code>和<code class="fe ln lo lp lq b">Var</code>编写实现，使我们能够做以下事情:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="ebea" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">调用<code class="fe ln lo lp lq b">total()</code>应该随时返回我们两个<code class="fe ln lo lp lq b">BankAccount</code>的总余额。</p><p id="02fe" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们实现了<code class="fe ln lo lp lq b">BankAccount</code>的实现，它以我们预期的方式工作，但是整合还没有完全完成。原因是我们实现了<code class="fe ln lo lp lq b">Signal</code>和<code class="fe ln lo lp lq b">Var</code>，<code class="fe ln lo lp lq b">consolidated</code>在初始化时计算一次，然后永远保持不变。概括地说，这是我们对<code class="fe ln lo lp lq b">Signal</code>和<code class="fe ln lo lp lq b">Var</code>的实现:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="96e4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们的实现失败的是，当我们将<code class="fe ln lo lp lq b">initVal</code>传递给<code class="fe ln lo lp lq b">Signal</code>的构造函数时，我们立即对其求值。后面的更改无关紧要，因为<code class="fe ln lo lp lq b">Signal</code>的值不会被重新评估。</p><p id="d00b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">那么我们如何解决这个问题呢？让我们使用一些函数式编程的工具。</p><h1 id="c645" class="lt lu it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">利用函数式编程</h1><p id="90bd" class="pw-post-body-paragraph jq jr it js b jt mr jv jw jx ms jz ka kb mt kd ke kf mu kh ki kj mv kl km kn im bi translated">我们想要实现的是，每当其中一个<code class="fe ln lo lp lq b">BankAccount</code>的余额发生变化时，<code class="fe ln lo lp lq b">total</code>都会被重新计算。换句话说，由<code class="fe ln lo lp lq b">consolidated</code>返回的<code class="fe ln lo lp lq b">Signal</code>应该是它所依赖的其他信号的<em class="lf">函数。(如果你略读了这一部分，你可能想再读一遍。)</em></p><p id="c74c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">欢迎来到函数式编程。到目前为止，我们只传递了整数值。现在我们想传递任意的函数。</p><p id="4469" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">那么我们该怎么做呢？首先，我们需要确保我们实际上可以将任意表达式传递给我们的类，并且我们需要停止将自己局限于整数。我们通过将Int类型声明替换为泛型类型来做到这一点。</p><p id="69c6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">其次，我们需要以一种方式存储我们的表达式，确保它不会以按值调用的方式被求值。如果我们改变我们的构造函数参数为call-by-name，它可以在任何改变的时候被重新评估。</p><p id="7381" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">(如果你对按值调用和按名称调用有些模糊，请查看<a class="ae ko" href="https://alvinalexander.com/source-code/scala/simple-scala-call-name-example" rel="noopener ugc nofollow" target="_blank">这个简单明了的解释</a>)。</p><p id="5bc1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们看看这是如何实现的:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="5e75" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们在这里做了一些改动:</p><ol class=""><li id="5090" class="mw mx it js b jt ju jx jy kb my kf mz kj na kn nb nc nd ne bi translated">我们在所有适用的地方用泛型类型替换了整数类型。</li><li id="c5a3" class="mw mx it js b jt nf jx ng kb nh kf ni kj nj kn nb nc nd ne bi translated">我们将<code class="fe ln lo lp lq b">initVal</code>重命名为<code class="fe ln lo lp lq b">expr</code>，以说明我们不再只是传递整数值，而是处理任意表达式。此外，我们将<code class="fe ln lo lp lq b">expr</code>定义为按名称调用(<code class="fe ln lo lp lq b">expr: =&gt; T</code>)，这意味着它不会立即被评估。</li><li id="40b8" class="mw mx it js b jt nf jx ng kb nh kf ni kj nj kn nb nc nd ne bi translated">我们添加了另一个变量<code class="fe ln lo lp lq b">curExpr</code>,它存储我们的表达式而不计算它，并且可以在需要时更新为一个新的表达式。语法<code class="fe ln lo lp lq b">var curExpr: () =&gt; T = () =&gt; expr</code>可能需要浏览几眼才能理解。它定义了一个类型为<code class="fe ln lo lp lq b">() =&gt; T</code>(匿名函数)的<code class="fe ln lo lp lq b">var</code>，其值为<code class="fe ln lo lp lq b">() =&gt; expr</code>。然后我们可以调用<code class="fe ln lo lp lq b">curExpr()</code>来计算表达式。</li><li id="f595" class="mw mx it js b jt nf jx ng kb nh kf ni kj nj kn nb nc nd ne bi translated">我们的<code class="fe ln lo lp lq b">update</code>方法现在更新了<code class="fe ln lo lp lq b">curExpr</code>和<code class="fe ln lo lp lq b">curVal</code></li></ol><p id="c898" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这让我们离第一个工作实现更近了一步。但是你可能已经猜到了，它还没有工作。一旦我们到达<code class="fe ln lo lp lq b">private var curVal = expr</code>，就会对<code class="fe ln lo lp lq b">expr</code>进行评估。所以没有什么真正的改变。(如果您用这些<code class="fe ln lo lp lq b">Signal</code>和<code class="fe ln lo lp lq b">Var</code>的实现运行上一篇文章末尾的代码，您将得到相同的结果。我鼓励你亲自尝试一下。)</p><p id="f582" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">正如我在上面写的，每当我们的一个<code class="fe ln lo lp lq b">BankAccount</code>平衡改变时，<code class="fe ln lo lp lq b">total</code>需要被重新计算。为了确保这一点，我们需要跟踪依赖于(即“观察”)我们个人平衡的<code class="fe ln lo lp lq b">Signal</code>。如果我们不知道哪些<code class="fe ln lo lp lq b">Signal</code>依赖于我们的余额，我们就不知道一旦它们发生变化，我们需要重新计算什么。</p><p id="0b99" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在观察者模式中，我们通过让合并器显式订阅它所依赖的每个主题(即<code class="fe ln lo lp lq b">BankAccount</code>)来解决这个问题。然而，我们希望编写比观察者模式更优雅的代码。观察者模式需要相当多的样板代码，我们想在这里避免。</p><p id="5d1b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">那么我们如何为我们的<code class="fe ln lo lp lq b">Signal</code>和<code class="fe ln lo lp lq b">Var</code>实现解决这个问题呢？让我们看一看。</p><h1 id="eb1f" class="lt lu it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">跟踪依赖性</h1><p id="5d6a" class="pw-post-body-paragraph jq jr it js b jt mr jv jw jx ms jz ka kb mt kd ke kf mu kh ki kj mv kl km kn im bi translated">一旦某个特定的<code class="fe ln lo lp lq b">Signal</code>发生变化，跟踪哪些<code class="fe ln lo lp lq b">Signal</code>需要重新计算的一个直接方法是将它所依赖的“主题”专门传递给它的构造函数。当我们初始化<code class="fe ln lo lp lq b">Signal</code>时，我们需要告诉它两件事:</p><ol class=""><li id="931b" class="mw mx it js b jt ju jx jy kb my kf mz kj na kn nb nc nd ne bi translated">它应该计算的表达式</li><li id="2ad7" class="mw mx it js b jt nf jx ng kb nh kf ni kj nj kn nb nc nd ne bi translated">另一个是它应该观察变化，这样当它们变化时它可以重新计算它的值</li></ol><p id="803e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们看看如何实现这样的东西:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="ca88" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们在这里又改变了一些东西:</p><ol class=""><li id="2bf6" class="mw mx it js b jt ju jx jy kb my kf mz kj na kn nb nc nd ne bi translated">现在有一个可选的构造函数参数<code class="fe ln lo lp lq b">observed: List[Signal[_]] = Nil</code>。它可以用来传递定义的<code class="fe ln lo lp lq b">Signal</code>所依赖的<code class="fe ln lo lp lq b">Signal</code>列表。如你所见，默认为<code class="fe ln lo lp lq b">Nil</code>。所以，如果你不传递任何东西，我们新定义的<code class="fe ln lo lp lq b">Signal</code>不会在其他<code class="fe ln lo lp lq b">Signal</code>改变它们的值时被更新。</li><li id="7781" class="mw mx it js b jt nf jx ng kb nh kf ni kj nj kn nb nc nd ne bi translated">我们添加了一个初始化为空的<code class="fe ln lo lp lq b">Set</code>的<code class="fe ln lo lp lq b">private var observers</code>。当一个新的<code class="fe ln lo lp lq b">Signal</code>被初始化时，它在<code class="fe ln lo lp lq b">observed</code>上迭代，并将其自身添加到所有其观察到的<code class="fe ln lo lp lq b">Signal</code> s: <code class="fe ln lo lp lq b">observed.foreach( obs =&gt; obs.observers += this )</code>的<code class="fe ln lo lp lq b">observers</code></li><li id="e842" class="mw mx it js b jt nf jx ng kb nh kf ni kj nj kn nb nc nd ne bi translated">我们添加了一个方法<code class="fe ln lo lp lq b">computeValue</code>，它通过评估当前表达式来更新<code class="fe ln lo lp lq b">Signal</code>的当前值，并让它的所有观察者也更新它们的值。</li><li id="65d8" class="mw mx it js b jt nf jx ng kb nh kf ni kj nj kn nb nc nd ne bi translated"><code class="fe ln lo lp lq b">update</code>采用了我们的新方法<code class="fe ln lo lp lq b">computeValue</code></li></ol><p id="dd70" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了在我们的银行帐户示例中使用这个实现，我们还需要对我们的函数<code class="fe ln lo lp lq b">consolidated</code>做一点修改——我们需要显式地传递我们的合并器所依赖的<code class="fe ln lo lp lq b">Signal</code>:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="0502" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">好消息是，这是我们想要实现的第一个工作实现！如果您将代码放在一起并运行下面的小测试，您将得到预期的结果:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="f50e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">祝贺你第一次实现了函数式反应式编程！</p><p id="6ddb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然而，坏消息是，我们的代码非常重复并且容易出错。在定义我们的函数<code class="fe ln lo lp lq b">consolidated</code>时，我们需要将它计算的函数(<code class="fe ln lo lp lq b">accts.map(_.balance()).sum</code>)和它依赖的函数(<code class="fe ln lo lp lq b">accts.map(_.balance)</code>)传递给<code class="fe ln lo lp lq b">Signal</code>的构造函数。如您所见，这几乎是两次完全相同的代码——至少在这个简单的例子中是这样。</p><p id="06c5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">(此外，当更新我们在<code class="fe ln lo lp lq b">Var</code>中的表达式时，我们目前不会更新<code class="fe ln lo lp lq b">observed</code>信号。我们或许可以通过调用<code class="fe ln lo lp lq b">update</code>来通过一个新的<code class="fe ln lo lp lq b">observed</code>来解决这个问题，但是这被认为很快会变得很糟糕。)</p></div><div class="ab cl lg lh hx li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="im in io ip iq"><p id="eb80" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">谢谢你一直陪着我，直到这篇代码非常多的文章结束！如果您已经做到了这一步，那么这只是向更好的解决方案迈出的一小步。</p><p id="0907" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在下一篇文章中，我们将会看到我们的<code class="fe ln lo lp lq b">Signal</code>们如何为自己找出他们所依赖的其他<code class="fe ln lo lp lq b">Signal</code>们。我们将提出最终的、更加优雅的实现。</p></div></div>    
</body>
</html>