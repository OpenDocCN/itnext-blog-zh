<html>
<head>
<title>Give your logs more context — Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">给你的日志更多的上下文—第2部分</h1>
<blockquote>原文：<a href="https://itnext.io/give-your-logs-more-context-part-2-c2c952724e04?source=collection_archive---------0-----------------------#2018-08-25">https://itnext.io/give-your-logs-more-context-part-2-c2c952724e04?source=collection_archive---------0-----------------------#2018-08-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="2cb4" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">构建上下文记录器</h2></div><p id="bacf" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是我上一篇关于日志记录上下文的文章的继续。请查看它，以便更好地理解我们将要构建的内容的目的。</p><div class="lb lc gp gr ld le"><a rel="noopener  ugc nofollow" target="_blank" href="/give-your-logs-more-context-7b43ea6b4ae6"><div class="lf ab fo"><div class="lg ab lh cl cj li"><h2 class="bd ir gy z fp lj fr fs lk fu fw ip bi translated">给你的日志更多的上下文</h2><div class="ll l"><h3 class="bd b gy z fp lj fr fs lk fu fw dk translated">如何理解Node.js web应用程序日志</h3></div><div class="lm l"><p class="bd b dl z fp lj fr fs lk fu fw dk translated">itnext.io</p></div></div><div class="ln l"><div class="lo l lp lq lr ln ls lt le"/></div></div></a></div></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><h1 id="466f" class="mb mc iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">TL；速度三角形定位法(dead reckoning)</h1><p id="a94f" class="pw-post-body-paragraph kf kg iq kh b ki mt jr kk kl mu ju kn ko mv kq kr ks mw ku kv kw mx ky kz la ij bi translated">我们将基于这个故事构建的代码在我的<a class="ae my" href="https://github.com/hbarcelos/give-your-logs-more-context" rel="noopener ugc nofollow" target="_blank"> Github </a>上。如果只是想查看最终版本，可以在<code class="fe mz na nb nc b">master</code>分支获取。</p><h1 id="cf8b" class="mb mc iq bd md me nd mg mh mi ne mk ml jw nf jx mn jz ng ka mp kc nh kd mr ms bi translated">介绍</h1><p id="fb5e" class="pw-post-body-paragraph kf kg iq kh b ki mt jr kk kl mu ju kn ko mv kq kr ks mw ku kv kw mx ky kz la ij bi translated">上一次，我们通过使用<code class="fe mz na nb nc b"><a class="ae my" href="https://github.com/pinojs/pino" rel="noopener ugc nofollow" target="_blank">pino</a></code>和<code class="fe mz na nb nc b"><a class="ae my" href="https://github.com/jeff-lewis/cls-hooked]" rel="noopener ugc nofollow" target="_blank">cls-hooked</a></code>通过并发请求来管理上下文。现在让我们围绕<code class="fe mz na nb nc b">pino</code>构建一个包装器，它将自动为我们处理这个问题。</p><figure class="nj nk nl nm gt nn gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/cb6aa760a2ca1771f0ecb34c1ac26fc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*j4gH9OAYGW1TDjmUpID_4g.jpeg"/></div><figcaption class="np nq gj gh gi nr ns bd b be z dk translated">现在，时间到了！</figcaption></figure><h1 id="2a6d" class="mb mc iq bd md me nd mg mh mi ne mk ml jw nf jx mn jz ng ka mp kc nh kd mr ms bi translated">我们想要实现什么？</h1><p id="3eb8" class="pw-post-body-paragraph kf kg iq kh b ki mt jr kk kl mu ju kn ko mv kq kr ks mw ku kv kw mx ky kz la ij bi translated">我们需要构建一个记录器，它将通过<code class="fe mz na nb nc b">cls-hooked</code>拥有基本的“全局”上下文，但也允许我们在实际调用记录器方法时扩充这样的上下文。</p><p id="8fd3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了提高可重用性和互操作性，我们希望保持原来默认的<code class="fe mz na nb nc b">pino</code> <a class="ae my" href="https://github.com/pinojs/pino/blob/master/docs/api.md" rel="noopener ugc nofollow" target="_blank"> API </a>，所以我们已经有了一个很好的测试用例集。此外，我们需要为我们的应用程序提供一种与上下文交互的方式。</p><h1 id="e0e8" class="mb mc iq bd md me nd mg mh mi ne mk ml jw nf jx mn jz ng ka mp kc nh kd mr ms bi translated">我们将如何编写代码？</h1><p id="8d4c" class="pw-post-body-paragraph kf kg iq kh b ki mt jr kk kl mu ju kn ko mv kq kr ks mw ku kv kw mx ky kz la ij bi translated">我们将实现这种包装TDD风格。然而，我们将编写的测试在严格意义上不是“单元”测试，因为它们将包含<code class="fe mz na nb nc b">pino</code>本身，并对生成的日志数据做出断言。这是可能的，因为<code class="fe mz na nb nc b">pino</code>接受一个自定义<code class="fe mz na nb nc b"><a class="ae my" href="https://nodejs.org/api/stream.html#stream_writable_streams" rel="noopener ugc nofollow" target="_blank">WritableStream</a></code>作为它的目的地。</p><p id="061e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">作为测试框架，我们将使用<code class="fe mz na nb nc b"><a class="ae my" href="https://github.com/avajs/ava" rel="noopener ugc nofollow" target="_blank">ava</a></code>。请记住，虽然默认情况下<code class="fe mz na nb nc b">ava</code>trans files测试文件，但如果没有正确设置<code class="fe mz na nb nc b">babel</code>，它不会对实际代码进行测试。为了避免增加该解决方案的复杂性，所有代码(包括测试)都不会使用ES模块或Node.js 10.9.0中不可用的任何功能。</p><p id="744a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您想按照实现进行操作，请查看Github资源库中的说明:</p><div class="lb lc gp gr ld le"><a href="https://github.com/hbarcelos/give-your-logs-more-context" rel="noopener  ugc nofollow" target="_blank"><div class="lf ab fo"><div class="lg ab lh cl cj li"><h2 class="bd ir gy z fp lj fr fs lk fu fw ip bi translated">hbarcelos/give-your-logs-more-context</h2><div class="ll l"><h3 class="bd b gy z fp lj fr fs lk fu fw dk translated">pino上的give-your-logs-more-context-Wrapper提供了与cls-hooked的集成，以在…</h3></div><div class="lm l"><p class="bd b dl z fp lj fr fs lk fu fw dk translated">github.com</p></div></div><div class="ln l"><div class="nt l lp lq lr ln ls lt le"/></div></div></a></div><blockquote class="nu"><p id="ff93" class="nv nw iq bd nx ny nz oa ob oc od la dk translated">我试图让这个序列尽可能自然，只消除一些在常规编码会话中发生的内部循环和斗争。</p></blockquote><h1 id="121d" class="mb mc iq bd md me nd mg mh mi ne mk ml jw oe jx mn jz of ka mp kc og kd mr ms bi translated">实施步骤</h1><h2 id="c97e" class="oh mc iq bd md oi oj dn mh ok ol dp ml ko om on mn ks oo op mp kw oq or mr os bi translated">初始设置</h2><pre class="nj nk nl nm gt ot nc ou ov aw ow bi"><span id="6d5c" class="oh mc iq nc b gy ox oy l oz pa">yarn init -y<br/>yarn add pino cls-hooked<br/>yarn add --dev ava</span></pre><p id="2248" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是可能的，因为<code class="fe mz na nb nc b">pino</code>接受一个自定义<code class="fe mz na nb nc b"><a class="ae my" href="https://nodejs.org/api/stream.html#stream_writable_streams" rel="noopener ugc nofollow" target="_blank">WritableStream</a></code>作为它的目的地</p><h2 id="9b57" class="oh mc iq bd md oi oj dn mh ok ol dp ml ko om on mn ks oo op mp kw oq or mr os bi translated">确保日志级别的方法</h2><p id="ab9f" class="pw-post-body-paragraph kf kg iq kh b ki mt jr kk kl mu ju kn ko mv kq kr ks mw ku kv kw mx ky kz la ij bi translated">为了简单起见，让我们坚持使用<code class="fe mz na nb nc b">pino</code>的默认日志级别:<code class="fe mz na nb nc b">trace</code>、<code class="fe mz na nb nc b">debug</code>、<code class="fe mz na nb nc b">info</code>、<code class="fe mz na nb nc b">warn</code>、<code class="fe mz na nb nc b">error</code>和<code class="fe mz na nb nc b">fatal</code>。</p><p id="35c4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最简单的方法是:</p><figure class="nj nk nl nm gt nn"><div class="bz fp l di"><div class="pb pc l"/></div></figure><p id="557f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mz na nb nc b">logger.js</code>目前只是一个返回普通<code class="fe mz na nb nc b">pino</code>实例工厂函数。<code class="fe mz na nb nc b">logger.test.js</code>文件为每个可用的方法生成一个测试用例，以确保我们以后不会破坏任何东西。</p><p id="4ded" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mz na nb nc b">parse-json-stream.js</code>是一个实用程序，它将解析日志输出流并返回普通的Javascript对象，使针对日志输出运行断言变得更加容易。</p><p id="6fa0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mz na nb nc b">stream-to-generator.js</code>有没有方便:<code class="fe mz na nb nc b">ava</code>和基于流的API玩不好。为了使测试更加简洁，我们将日志流转换为一个<a class="ae my" href="http://2ality.com/2015/03/es6-generators.html" rel="noopener ugc nofollow" target="_blank">生成器</a>，该生成器生成对下一个日志条目的承诺。</p><p id="aa5b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">后两者在我们努力实现的目标中并不重要，它们在此仅作参考。剩余的片段不会包括它们。</p><h2 id="0b5e" class="oh mc iq bd md oi oj dn mh ok ol dp ml ko om on mn ks oo op mp kw oq or mr os bi translated">保留记录器方法调用的上下文</h2><p id="3bcd" class="pw-post-body-paragraph kf kg iq kh b ki mt jr kk kl mu ju kn ko mv kq kr ks mw ku kv kw mx ky kz la ij bi translated">另外，请注意<code class="fe mz na nb nc b">pino</code>允许我们通过在参数列表前添加一个对象来将本地上下文传递给日志条目。这是我们想要保持的行为。</p><p id="c19a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，让我们添加一个测试用例来涵盖这个场景:</p><figure class="nj nk nl nm gt nn"><div class="bz fp l di"><div class="pb pc l"/></div></figure><p id="f06a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为到目前为止我们只是创建了一个<code class="fe mz na nb nc b">pino</code>实例，所以测试将会通过。</p><h2 id="11c9" class="oh mc iq bd md oi oj dn mh ok ol dp ml ko om on mn ks oo op mp kw oq or mr os bi translated">增加CLS意识</h2><p id="4159" class="pw-post-body-paragraph kf kg iq kh b ki mt jr kk kl mu ju kn ko mv kq kr ks mw ku kv kw mx ky kz la ij bi translated">现在我们开始接触CLS。首先，我们需要创建名称空间并将其公开:</p><figure class="nj nk nl nm gt nn"><div class="bz fp l di"><div class="pb pc l"/></div></figure><h2 id="3e28" class="oh mc iq bd md oi oj dn mh ok ol dp ml ko om on mn ks oo op mp kw oq or mr os bi translated">防止实例之间共享CLS上下文</h2><p id="414d" class="pw-post-body-paragraph kf kg iq kh b ki mt jr kk kl mu ju kn ko mv kq kr ks mw ku kv kw mx ky kz la ij bi translated">出于某种原因，我们可能希望在一个给定的应用程序中有多个记录器。这样做时，不要混合两者的名称空间，这一点很重要。然而，我们在上面实现的方法，所有的实例都有相同的名称空间<code class="fe mz na nb nc b">'@@logger'</code>，这可能会导致奇怪的行为。</p><p id="e5be" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">解决这个问题最简单的方法是有一个<code class="fe mz na nb nc b">counter</code>变量，每当我们调用<code class="fe mz na nb nc b">createLogger</code>并将计数器值附加到名称空间名称时，这个变量就会递增。</p><p id="cc6e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">虽然计数器并不是生成唯一名称的最安全的方法，因为它们在应用程序重新启动时被重置，但是在这种情况下它们是有效的，因为当服务器重新启动时，所有的logger实例都会被重新创建。此外，这个值不会暴露在任何地方，它只是为了创建不同的名称空间，所以我们没有问题。</p><blockquote class="nu"><p id="380c" class="nv nw iq bd nx ny pd pe pf pg ph la dk translated">有时候少即是多！</p></blockquote><p id="9936" class="pw-post-body-paragraph kf kg iq kh b ki pi jr kk kl pj ju kn ko pk kq kr ks pl ku kv kw pm ky kz la ij bi translated">变化如下:</p><figure class="nj nk nl nm gt nn"><div class="bz fp l di"><div class="pb pc l"/></div></figure><h2 id="073b" class="oh mc iq bd md oi oj dn mh ok ol dp ml ko om on mn ks oo op mp kw oq or mr os bi translated">将CLS上下文应用于日志</h2><p id="530c" class="pw-post-body-paragraph kf kg iq kh b ki mt jr kk kl mu ju kn ko mv kq kr ks mw ku kv kw mx ky kz la ij bi translated">这是一个很大的飞跃，所以请原谅我。首先，我们来看看代码中的变化，然后我们来讨论一下:</p><figure class="nj nk nl nm gt nn"><div class="bz fp l di"><div class="pb pc l"/></div></figure><figure class="nj nk nl nm gt nn gh gi paragraph-image"><div class="gh gi pn"><img src="../Images/0408c3492c4ee72ef16c9ed809a289b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*B7wp77wTFh4YbrY_5nG2Dw.jpeg"/></div><figcaption class="np nq gj gh gi nr ns bd b be z dk translated">抱歉，我不能把这个分成更小的零钱:/</figcaption></figure><p id="1c79" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">测试代码没有什么特别的，只是注意我们必须在<code class="fe mz na nb nc b">logger.cls.run</code>方法回调中运行我们的日志和断言。</p><p id="1d66" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不过，实际代码开始变得有趣了。我们利用Javascript <a class="ae my" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy" rel="noopener ugc nofollow" target="_blank">代理</a>来拦截日志方法调用并修补它们的参数。</p><p id="a69d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，在<a class="ae my" href="https://gist.github.com/hbarcelos/a351b95fd869240f87cd12d5ad202742#file-logger-js-diff-L52" rel="noopener ugc nofollow" target="_blank">第52行</a>中，我们为我们的logger对象创建了一个代理，其处理程序被命名为<code class="fe mz na nb nc b">loggerObjectHandler</code> — <a class="ae my" href="https://gist.github.com/hbarcelos/a351b95fd869240f87cd12d5ad202742#file-logger-js-diff-L34-L43" rel="noopener ugc nofollow" target="_blank">第34–43行</a>。处理程序定义了一个<code class="fe mz na nb nc b"><a class="ae my" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/get" rel="noopener ugc nofollow" target="_blank">get</a></code> <a class="ae my" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/get" rel="noopener ugc nofollow" target="_blank">陷阱</a>，该陷阱将只拦截对日志方法<code class="fe mz na nb nc b">trace</code>、<code class="fe mz na nb nc b">debug</code>等的调用。它所做的是将这些方法包装到另一个代理中，其处理程序名为<code class="fe mz na nb nc b">logMethodHandler</code>—<a class="ae my" href="https://gist.github.com/hbarcelos/a351b95fd869240f87cd12d5ad202742#file-logger-js-diff-L11-L32" rel="noopener ugc nofollow" target="_blank">lines 11–32</a>。</p><p id="a8a4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mz na nb nc b">loggerMethodHandler</code>收集CLS当前的活动上下文，从中排除一些不相关的属性。然后，基于当前的参数列表，它检查方法调用是否有本地上下文。如果我们不这样做，那么我们只需要将CLS上下文添加到参数列表中—第<a class="ae my" href="https://gist.github.com/hbarcelos/a351b95fd869240f87cd12d5ad202742#file-logger-js-diff-L20-L23" rel="noopener ugc nofollow" target="_blank">20–23</a>行。否则，我们需要将本地上下文合并到CLS上下文中— <a class="ae my" href="https://gist.github.com/hbarcelos/a351b95fd869240f87cd12d5ad202742#file-logger-js-diff-L24-L28" rel="noopener ugc nofollow" target="_blank">第24–28行</a>。最后，我们调用带有适当参数的原始方法— <a class="ae my" href="https://gist.github.com/hbarcelos/a351b95fd869240f87cd12d5ad202742#file-logger-js-diff-L30" rel="noopener ugc nofollow" target="_blank">第30行</a>。</p><h2 id="339d" class="oh mc iq bd md oi oj dn mh ok ol dp ml ko om on mn ks oo op mp kw oq or mr os bi translated">将更改传播到子记录器</h2><p id="2dbe" class="pw-post-body-paragraph kf kg iq kh b ki mt jr kk kl mu ju kn ko mv kq kr ks mw ku kv kw mx ky kz la ij bi translated">来自<code class="fe mz na nb nc b">pino</code>的一个很好的特性是它允许我们通过<code class="fe mz na nb nc b">.child()</code>方法创建子记录器。子记录器维护其父记录器的所有属性，但也可以接受额外的上下文。所以，我们也需要让我们的下一代CLS意识到:</p><figure class="nj nk nl nm gt nn"><div class="bz fp l di"><div class="pb pc l"/></div></figure><p id="f5c3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，新的测试是自我描述的。让我们把重点放在实现上。首先，我们将包装器创建提取到它自己的函数中，命名为<code class="fe mz na nb nc b">createWrapper</code>—lines<a class="ae my" href="https://gist.github.com/hbarcelos/3c0d258329696e306c10ba3d3451d871#file-logger-js-diff-L47-L52" rel="noopener ugc nofollow" target="_blank">47–52</a>。这也允许我们为子记录器创建一个包装器。</p><p id="a49f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们定义一个<code class="fe mz na nb nc b">childMethodHandler</code>，它将拦截对<code class="fe mz na nb nc b">.child()</code> — <a class="ae my" href="https://gist.github.com/hbarcelos/3c0d258329696e306c10ba3d3451d871#file-logger-js-diff-L18-L25" rel="noopener ugc nofollow" target="_blank">行18–25</a>的调用。这个处理程序将在新创建的子记录器上调用<code class="fe mz na nb nc b">createWrapper</code>，将来自父记录器的CLS上下文作为参数传递。这将保证父节点和子节点(以及子节点子节点)都具有相同的上下文。</p><p id="46ad" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们修改了<code class="fe mz na nb nc b">loggerObjectHandler</code>的实现，使其也包含了<code class="fe mz na nb nc b">.child()</code>方法的代理——<a class="ae my" href="https://gist.github.com/hbarcelos/3c0d258329696e306c10ba3d3451d871#file-logger-js-diff-L30-L45" rel="noopener ugc nofollow" target="_blank">第30–45行</a>——包括一些对条件的内部重构。</p><h2 id="08df" class="oh mc iq bd md oi oj dn mh ok ol dp ml ko om on mn ks oo op mp kw oq or mr os bi translated">进一步的改进</h2><p id="d202" class="pw-post-body-paragraph kf kg iq kh b ki mt jr kk kl mu ju kn ko mv kq kr ks mw ku kv kw mx ky kz la ij bi translated">到目前为止，我们的代码似乎工作正常，但它可能不是最佳的。一个容易发现的问题是，我们正在为子方法和日志方法的每个调用动态地创建新的代理。虽然这对于前者来说可能不是问题——因为我们不会经常给<code class="fe mz na nb nc b">.child()</code>打电话——但对于后者来说却不是。</p><p id="2cfe" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了防止这个问题，我们可以在创建logger本身时为所需的方法创建代理，并将它们作为logger对象的属性。当我们调用方法时，<code class="fe mz na nb nc b">loggerObjectHandler</code>会检查当前方法是否有代理集。如果是，则返回代理，否则，返回原始属性:</p><figure class="nj nk nl nm gt nn"><div class="bz fp l di"><div class="pb pc l"/></div></figure><h1 id="e078" class="mb mc iq bd md me nd mg mh mi ne mk ml jw nf jx mn jz ng ka mp kc nh kd mr ms bi translated">与我们的web应用程序集成</h1><p id="7240" class="pw-post-body-paragraph kf kg iq kh b ki mt jr kk kl mu ju kn ko mv kq kr ks mw ku kv kw mx ky kz la ij bi translated">所以现在我们有了自己的伐木工厂。现在我们需要将它集成到我们的应用程序中。从上一篇文章的最后一个例子中，我们可以重构为:</p><figure class="nj nk nl nm gt nn"><div class="bz fp l di"><div class="pb pc l"/></div></figure></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><h1 id="6a87" class="mb mc iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">结尾部分</h1><p id="4995" class="pw-post-body-paragraph kf kg iq kh b ki mt jr kk kl mu ju kn ko mv kq kr ks mw ku kv kw mx ky kz la ij bi translated">上面的代码与我们目前在easy carros<a class="ae my" href="https://easycarros.com/" rel="noopener ugc nofollow" target="_blank">的生产中使用的代码非常相似，到目前为止，它对我们非常有效。如果你有任何可以改进它的建议，我们非常欢迎。</a></p></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><p id="90f4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你喜欢你刚刚读的吗？用<a class="ae my" href="https://tippin.me/@hbarcelos909" rel="noopener ugc nofollow" target="_blank"> tippin.me </a>给我买啤酒。</p></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><figure class="nj nk nl nm gt nn gh gi paragraph-image"><div class="gh gi po"><img src="../Images/fb4d3ddc0f5a5e1695f79fdbd2a0d8d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/1*FLrn96Ud0saQiugN20Qjyg.jpeg"/></div></figure></div></div>    
</body>
</html>