<html>
<head>
<title>Stop wrapping your React components in pointless divs!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">不要在毫无意义的地方包装你的反作用组件！</h1>
<blockquote>原文：<a href="https://itnext.io/stop-wrapping-your-react-components-in-pointless-divs-8b5fd11b5545?source=collection_archive---------2-----------------------#2018-09-04">https://itnext.io/stop-wrapping-your-react-components-in-pointless-divs-8b5fd11b5545?source=collection_archive---------2-----------------------#2018-09-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/a594280b2efdc4630725096a9e0219cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1EHAyKCz28EdSBCrXFPbOw.jpeg"/></div></div></figure><p id="284b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">鉴于图片的特色，你可能已经意识到这将是一篇关于反应16.2 <code class="fe kw kx ky kz b">Fragment</code>功能的帖子。如果你完全了解这个功能，并且对它了如指掌，那么这篇文章就不适合你了。但是如果你不认为你什么都知道，那就继续吧！掌握这个概念的所有内容很简单，并且是一个有价值的工具，可以添加到您的React编程库中。</p><p id="6a41" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我实际上在这里制作了一段关于这个话题的视频。尽管我会在这篇文章中对反应碎片做更详细的描述。</p><h1 id="5bea" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">一个毫无意义的div示例:</h1><p id="40ab" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">为了说明<code class="fe kw kx ky kz b">Fragment</code>的有用性，我们来看看一个简单的无状态功能组件的例子:</p><pre class="me mf mg mh gt mi kz mj mk aw ml bi"><span id="a056" class="mm lc iq kz b gy mn mo l mp mq">import React from 'react';</span><span id="b761" class="mm lc iq kz b gy mr mo l mp mq">const MyComponent = () =&gt; (<br/>  &lt;p&gt;React is going to throw errors at&lt;/p&gt;<br/>  &lt;p&gt;this component because it's not wrapped!&lt;/p&gt;<br/>);</span></pre><p id="ac50" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您已经使用reactor有一段时间了，但是还没有遇到React Fragment特性，那么您会知道当您尝试运行这段代码时，reactor会向您抛出一个错误。这是由于反作用在发动机罩下的工作方式。它要求组件由一个子元素组成。就<code class="fe kw kx ky kz b">MyComponent</code>而言，有两个因素会导致反作用抛出错误。</p><p id="f7a4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">嗯，这很容易修复，对吗？我们就这样把它包起来！</p><pre class="me mf mg mh gt mi kz mj mk aw ml bi"><span id="2747" class="mm lc iq kz b gy mn mo l mp mq">import React from 'react';</span><span id="7f05" class="mm lc iq kz b gy mr mo l mp mq">const MyComponent = () =&gt; (<br/>  &lt;div&gt;<br/>    &lt;p&gt;React is going to throw errors at&lt;/p&gt;<br/>    &lt;p&gt;this component because it's not wrapped!&lt;/p&gt;<br/>  &lt;/div&gt;<br/>);</span></pre><p id="6569" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">酷，这个管用，问题解决了，对吧？嗯，是的，但是你看……这是一种把专业人员和业余人员分开的情况。我认为——如果你有选择的余地——你会选择成为一名职业运动员，而不是业余运动员。</p><blockquote class="ms mt mu"><p id="0863" class="jy jz mv ka b kb kc kd ke kf kg kh ki mw kk kl km mx ko kp kq my ks kt ku kv ij bi translated"><em class="iq">专业人士把工作</em> <strong class="ka ir"> <em class="iq">做对</em> </strong> <em class="iq">，业余人士把工作做好。</em></p><p id="2013" class="jy jz mv ka b kb kc kd ke kf kg kh ki mw kk kl km mx ko kp kq my ks kt ku kv ij bi translated">–John Sonmez(<a class="ae la" href="https://amzn.to/2oItvJj" rel="noopener ugc nofollow" target="_blank">软技能:软件开发人员生活手册</a>)</p></blockquote><h1 id="a54d" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">这有什么错？它的工作，所以我很高兴！</h1><p id="2ef3" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">这个解决方案的问题在于，您的渲染文档对象模型(DOM)现在有一个完全无用的div，它对您毫无用处。乍一看，这还不算太糟。然而，这可能会产生负面影响。想想这两个例子:</p><h2 id="24c9" class="mm lc iq bd ld mz na dn lh nb nc dp ll kj nd ne lp kn nf ng lt kr nh ni lx nj bi translated">数组上的映射</h2><p id="d7e1" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">我会在这里用一个小例子，但你会明白的。想象我们映射到一个数组，对于数组中的每一项，我们打印出一个组件，就像这样包装在一个div中:</p><pre class="me mf mg mh gt mi kz mj mk aw ml bi"><span id="40d2" class="mm lc iq kz b gy mn mo l mp mq">import React from 'react';</span><span id="ecb7" class="mm lc iq kz b gy mr mo l mp mq">const myArray = ["Barry", "Michael", "Doyle"];</span><span id="265d" class="mm lc iq kz b gy mr mo l mp mq">const MyComponent = ({ name }) =&gt; (<br/>  &lt;div&gt;<br/>    &lt;p&gt;Here's a name:&lt;/p&gt;<br/>    &lt;p&gt;{name}&lt;/p&gt;<br/>  &lt;/div&gt;<br/>);</span><span id="134b" class="mm lc iq kz b gy mr mo l mp mq">const renderNames = () =&gt; myArray.map((name, index) =&gt;<br/>  &lt;MyComponent key={index} name={name} /&gt;<br/>);<br/>// You shouldn't really be using index for your key<br/>// but this isn't what I'm trying to illustrate right now.</span></pre><p id="7cdb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以这里我们有一个<code class="fe kw kx ky kz b">renderNames</code>函数，它应该为<code class="fe kw kx ky kz b">myArray</code>中的每个<code class="fe kw kx ky kz b">name</code>渲染一个<code class="fe kw kx ky kz b">MyComponent</code>组件。在这种情况下，它将呈现以下内容:</p><pre class="me mf mg mh gt mi kz mj mk aw ml bi"><span id="94ad" class="mm lc iq kz b gy mn mo l mp mq">&lt;div&gt;<br/>  &lt;p&gt;Here's a name:&lt;/p&gt;<br/>  &lt;p&gt;Barry&lt;/p&gt;<br/>&lt;/div&gt;<br/>&lt;div&gt;<br/>  &lt;p&gt;Here's a name:&lt;/p&gt;<br/>  &lt;p&gt;Michael&lt;/p&gt;<br/>&lt;/div&gt;<br/>&lt;div&gt;<br/>  &lt;p&gt;Here's a name:&lt;/p&gt;<br/>  &lt;p&gt;Doyle&lt;/p&gt;<br/>&lt;/div&gt;</span></pre><p id="c802" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这对于在DOM中呈现的元素来说有点过了。因为没有附加样式或其他数据的<code class="fe kw kx ky kz b">div</code>是完全不必要的。如果我们硬编码的话，我们可以让一些东西看起来完全一样，没有任何无用的<code class="fe kw kx ky kz b">div</code>标签。除了增大我们的DOM和让客户端下载更多无用的HTML代码之外，<code class="fe kw kx ky kz b">div</code>标签没有提供任何好处。我们真正想要渲染的是这个:</p><pre class="me mf mg mh gt mi kz mj mk aw ml bi"><span id="b2be" class="mm lc iq kz b gy mn mo l mp mq">&lt;p&gt;Here's a name:&lt;/p&gt;<br/>&lt;p&gt;Barry&lt;/p&gt;<br/>&lt;p&gt;Here's a name:&lt;/p&gt;<br/>&lt;p&gt;Michael&lt;/p&gt;<br/>&lt;p&gt;Here's a name:&lt;/p&gt;<br/>&lt;p&gt;Doyle&lt;/p&gt;</span></pre><p id="d2fb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">无用的<code class="fe kw kx ky kz b">div</code>标签的问题是那些无意义的div标签越积越多。假设我们的数组由数百个值组成。如果你可以少渲染一些标签，你肯定会很高兴。这些变化最终会对您的应用程序性能产生影响。此外，有无意义的<code class="fe kw kx ky kz b">div</code>标签会让你觉得恶心！</p><h2 id="463c" class="mm lc iq bd ld mz na dn lh nb nc dp ll kj nd ne lp kn nf ng lt kr nh ni lx nj bi translated">弄乱HTML语义</h2><p id="f60c" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">考虑在不应该使用的地方使用一个<code class="fe kw kx ky kz b">div</code>或者其他无用的元素。这是另一个使用无用的<code class="fe kw kx ky kz b">div</code>标签的好例子，这会让你觉得自己是个肮脏的混蛋。看看这个:</p><pre class="me mf mg mh gt mi kz mj mk aw ml bi"><span id="8a2a" class="mm lc iq kz b gy mn mo l mp mq">import React from 'react';</span><span id="6120" class="mm lc iq kz b gy mr mo l mp mq">const MyComponent = () =&gt; (<br/>  &lt;div className="my-app"&gt;<br/>    &lt;ul&gt;<br/>      &lt;ListItems&gt;<br/>    &lt;/ul&gt;<br/>  &lt;/div&gt;<br/>);</span><span id="69aa" class="mm lc iq kz b gy mr mo l mp mq">const ListItems = () =&gt; (<br/>  &lt;div&gt;<br/>    &lt;li&gt;Barry&lt;/li&gt;<br/>    &lt;li&gt;Michael&lt;/li&gt;<br/>    &lt;li&gt;Doyle&lt;/li&gt;<br/>  &lt;/div&gt;<br/>);</span></pre><p id="2044" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">免责声明:</strong>这是一个来自过去的消息，但我知道React Fire正在开发过程中，并且<code class="fe kw kx ky kz b">className</code>可能会在不太遥远的将来某个时候更改为<code class="fe kw kx ky kz b">class</code>。当这种情况发生时，你会看到这个帖子。请评论提醒我把<code class="fe kw kx ky kz b">className</code>改成<code class="fe kw kx ky kz b">class</code>。</p><p id="00ed" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="mv">回帖子……</em></p><p id="5084" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">无论如何，以上是另一个微不足道的例子来证明一点。至少这次我们的带有<code class="fe kw kx ky kz b">className</code>的<code class="fe kw kx ky kz b">div</code>元素实际上是有目的的，不像我们之前提到的数组示例上的<em class="mv">映射。然而，如果我们在这里渲染<code class="fe kw kx ky kz b">MyComponent</code>,我们将向DOM渲染以下不需要的结果:</em></p><pre class="me mf mg mh gt mi kz mj mk aw ml bi"><span id="3f6b" class="mm lc iq kz b gy mn mo l mp mq">&lt;div class="my-app"&gt;<br/>  &lt;ul&gt;<br/>    &lt;div&gt;<br/>      &lt;li&gt;Barry&lt;/li&gt;<br/>      &lt;li&gt;Michael&lt;/li&gt;<br/>      &lt;li&gt;Doyle&lt;/li&gt;<br/>    &lt;/div&gt;<br/>  &lt;/ul&gt;<br/>&lt;/div&gt;</span></pre><p id="ed31" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们首先说，呈现我的名字没有任何问题。这不是我们要解决的问题！我的名字很棒……在这种情况下——正如我已经提到的——作为<code class="fe kw kx ky kz b">MyComponent</code>的包装器的<code class="fe kw kx ky kz b">div</code>很好，因为它实际上服务于一个不仅仅是包装的目的。这是假设已经为分配给包装<code class="fe kw kx ky kz b">div</code>的<code class="fe kw kx ky kz b">my-app</code>类定义了样式。</p><p id="4a27" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">真正的问题是——从语义上来说——在<code class="fe kw kx ky kz b">ul</code>和<code class="fe kw kx ky kz b">li</code>元素之间不应该呈现一个<code class="fe kw kx ky kz b">div</code>!不遵循正确的HTML语义可能会给你带来麻烦。现在对你来说可能不是问题，但是这种东西可能会干扰事情。例如，浏览器内置的辅助功能，如屏幕阅读器等。它也可能有其他不良后果，如负面影响您的网站搜索引擎优化(SEO)。这是由于页面没有遵循最佳实践约定造成的。</p><h1 id="42df" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">在我们继续我们奇妙的解决方案之前，最后一点要注意</h1><p id="0483" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">这些例子非常简单。很容易发现，你可以通过重组你的组件来解决这些问题。编写组件的方式通常不应该导致呈现多个独立的元素。但是嘿！如果你确实有这个问题，而且不知道什么是反应片段，那么你将要学习一个漂亮的小技巧，它将帮助你在这些烦人的情况下摆脱出来。</p><h1 id="e2fc" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">起作用反应片段</h1><p id="d09b" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">2018年初。React开发者得到了React 16.2的新年礼物，它引入了React片段特性。它也介绍了其他很酷的东西，但这篇文章只是在这里的片段。</p><p id="4b2b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">其实真的很简单！你几乎只是用一个<code class="fe kw kx ky kz b">&lt;React.Fragment&gt;</code>代替了你的<code class="fe kw kx ky kz b">&lt;div&gt;</code>。让我们使用无意义的div示例:</p><pre class="me mf mg mh gt mi kz mj mk aw ml bi"><span id="16f7" class="mm lc iq kz b gy mn mo l mp mq">import React from 'react';</span><span id="b5f1" class="mm lc iq kz b gy mr mo l mp mq">const MyComponent = () =&gt; (<br/>  &lt;React.Fragment&gt;<br/>    &lt;p&gt;React is not going to throw errors at&lt;/p&gt;<br/>    &lt;p&gt;this component because it's wrapped!&lt;/p&gt;<br/>  &lt;/React.Fragment&gt;<br/>);</span></pre><p id="a3b3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这太棒了，因为使用这种技术，React不会抛出错误！而且它根本不在DOM中呈现包装器！这是输出:</p><pre class="me mf mg mh gt mi kz mj mk aw ml bi"><span id="f4e3" class="mm lc iq kz b gy mn mo l mp mq">&lt;p&gt;React is not going to throw errors at&lt;/p&gt;<br/>&lt;p&gt;this component because it's wrapped!&lt;/p&gt;</span></pre><h2 id="70b2" class="mm lc iq bd ld mz na dn lh nb nc dp ll kj nd ne lp kn nf ng lt kr nh ni lx nj bi translated">React片段密钥属性</h2><p id="278f" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">映射一个数组，却抱怨没有唯一键？没问题！<code class="fe kw kx ky kz b">React.Fragment</code>标签也可以接受一个<code class="fe kw kx ky kz b">key</code>属性，这样在映射数组时就不会出错。简单地这样写:</p><pre class="me mf mg mh gt mi kz mj mk aw ml bi"><span id="5d25" class="mm lc iq kz b gy mn mo l mp mq">import React from 'react';</span><span id="d4ec" class="mm lc iq kz b gy mr mo l mp mq">const myArray = ['Barry', 'Michael', 'Doyle'];</span><span id="ca53" class="mm lc iq kz b gy mr mo l mp mq">const MyComponent = () =&gt; (<br/>  &lt;React.Fragment&gt;<br/>    &lt;h1&gt;Here are some names:&lt;/h1&gt;<br/>    {myArray.map((name, index) =&gt; (<br/>      &lt;React.Fragment key={index}&gt;<br/>        &lt;p&gt;Name:&lt;/p&gt;<br/>        &lt;p&gt;{name}&lt;/p&gt;<br/>      &lt;/React.Fragment&gt;<br/>    )}<br/>  &lt;/React.Fragment&gt;<br/>);</span></pre><p id="4986" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面的代码将完美地呈现，没有无用的包装元素。此外，React不会抱怨没有包装<code class="fe kw kx ky kz b">React.Fragment</code>标签的唯一键。</p><p id="c94a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">对于实现嵌套的三元语句真的有用</strong></p><p id="fc02" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我谈论下一部分有多棒之前。我非常支持编写干净、可读和可维护的代码。我个人认为，如果需要写嵌套三元的话。那么您可能应该考虑将您的组件拆分成更小的组件。或者考虑添加渲染功能，让其他开发人员更容易阅读你的作品。但是如果您认为——在您的特定情况下——使用嵌套的三元语句是可读的，那么继续！</p><p id="707a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面是一个将<code class="fe kw kx ky kz b">React.Fragment</code>标签用于嵌套三元语句的例子:</p><pre class="me mf mg mh gt mi kz mj mk aw ml bi"><span id="4f4e" class="mm lc iq kz b gy mn mo l mp mq">import React from 'react';<br/>import {<br/>  AdminScreen,<br/>  LoadingScreen,<br/>  UserScreen,<br/>} from './components';</span><span id="ca11" class="mm lc iq kz b gy mr mo l mp mq">const MyApp = ({ isLoading, isAdmin }) =&gt; (<br/>  &lt;div className="my-app"&gt;<br/>    {isLoading ?<br/>      &lt;LoadingScreen /&gt; :<br/>      &lt;React.Fragment&gt;<br/>        {isAdmin ?<br/>          &lt;AdminScreen /&gt; :<br/>          &lt;UserScreen /&gt;<br/>        }<br/>      &lt;/React.Fragment&gt;<br/>    }<br/>  &lt;/div&gt;<br/>);</span></pre><p id="4c49" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如我提到的，肯定有更干净的方式来写这个，如果我看到像这样写的东西，我可能会在代码审查中抱怨。但是，嘿，它的工作和渲染没有无用的<code class="fe kw kx ky kz b">div</code>标签。</p><p id="2842" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">平心而论，看起来没那么糟糕。说到让东西更具可读性，我们就来谈谈这个吧！</p><h1 id="c5b7" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用片段时提高代码可读性</h1><p id="6180" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated"><code class="fe kw kx ky kz b">React.Fragment</code>当你看它的时候，它很脏。而你可能已经猜到了这一点，但这很像<code class="fe kw kx ky kz b">React.Component</code>。如果你和我一样，你可能喜欢破坏和去掉那些点！让我们向你展示如何做到这一点。</p><h2 id="442d" class="mm lc iq bd ld mz na dn lh nb nc dp ll kj nd ne lp kn nf ng lt kr nh ni lx nj bi translated">来自React导入的析构片段</h2><p id="b7dc" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">你可以从React导入中析构<code class="fe kw kx ky kz b">Fragment</code>，就像你处理<code class="fe kw kx ky kz b">Component</code>一样。简单地像这样做:</p><pre class="me mf mg mh gt mi kz mj mk aw ml bi"><span id="2a7d" class="mm lc iq kz b gy mn mo l mp mq">import React, { Fragment } from 'react';</span><span id="75d3" class="mm lc iq kz b gy mr mo l mp mq">const MyComponent = () =&gt; (<br/>  &lt;Fragment&gt;<br/>    &lt;p&gt;Barry&lt;/P&gt;<br/>    &lt;p&gt;Michael&lt;/p&gt;<br/>    &lt;p&gt;Doyle&lt;/p&gt;<br/>  &lt;/Fragment&gt;<br/>);</span></pre><p id="ca68" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这太棒了。看那比<code class="fe kw kx ky kz b">React.Fragment</code>干净多少！干净的代码是好代码，当它工作和执行良好时…</p><p id="1177" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">无论如何，有一种更干净的方法来实现React片段！</p><h2 id="1064" class="mm lc iq bd ld mz na dn lh nb nc dp ll kj nd ne lp kn nf ng lt kr nh ni lx nj bi translated">使用新的花式公认的语法糖</h2><p id="0364" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">实际上，在这篇文章发表前一周，巴别塔7问世了！这带来了以更漂亮的方式编写React片段的能力！看看这个:</p><pre class="me mf mg mh gt mi kz mj mk aw ml bi"><span id="c24a" class="mm lc iq kz b gy mn mo l mp mq">import React from 'react';</span><span id="0d27" class="mm lc iq kz b gy mr mo l mp mq">const MyComponent = () =&gt; (<br/>  &lt;&gt;<br/>    &lt;p&gt;Barry&lt;/p&gt;<br/>    &lt;p&gt;Michael&lt;/p&gt;<br/>    &lt;p&gt;Doyle&lt;/p&gt;<br/>  &lt;/&gt;<br/>);</span></pre><p id="61c7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这太棒了。因为它与React <code class="fe kw kx ky kz b">Fragment</code>的实际工作方式一致。它几乎是“不可见的”,只是用于包装将要渲染的组件，以满足引擎罩下的反应。注意这样做意味着你甚至不需要<code class="fe kw kx ky kz b">import { Fragment } from 'react'</code>！</p><p id="9561" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">PS:这在最新版本的TypeScript中也是可用的，以防你用的是TypeScript而不是Babel。所以我强烈推荐使用这种语法，因为它已经成为实现React片段的公认方式。</p><p id="5358" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个奇特的语法唯一不允许您做的事情是将<code class="fe kw kx ky kz b">key</code>属性添加到<code class="fe kw kx ky kz b">Fragment</code>中。如果你需要使用一个<code class="fe kw kx ky kz b">Fragment</code>来包装一个映射的渲染，那么你应该使用我之前提到的析构方法。然而，这可能是一个很好的指示，您应该通过将映射的渲染提取到它自己的组件来编写更干净的代码。这应该消除了采用析构方法的需要，并允许您使用漂亮的语法方法。因为现在您可以将所需的惟一属性<code class="fe kw kx ky kz b">key</code>分配给提取的组件，并在提取的组件中使用<code class="fe kw kx ky kz b">&lt;&gt;</code>来代替。</p><h1 id="a73b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">碎片比较特殊，需要的时候用，但不是到处都用！</h1><p id="fac1" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">请不要让我写一个“停止到处使用无意义的片段！”博客帖子。我有一个同事，他认为把所有东西都包在一个<code class="fe kw kx ky kz b">&lt;Fragment&gt;</code>里是个好主意。他这样做是因为这样他就不会抱怨他有5%的时间没有用包装元素包装他的元素。不要那样做！</p><p id="f3b7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我友好地把我在React Fragments上的YouTube视频链接给他，试图帮助他理解应该如何使用它们时，他非常生气。很公平，从技术上讲，DOM在那里什么也不渲染，所以它不会影响最终渲染的内容。我甚至想方设法证明他是错的，但一无所获。</p><p id="7fc6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但请记住约翰·桑梅兹在他的书《软技能:软件开发人员的生活手册》中的一句话:专业人士得到工作，完成工作，做好工作。业余者完成工作。仅仅因为它有效，并不意味着它是正确的。在代码库中插入完全没有任何作用东西是不好的做法。</p><p id="b99c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">每当你想用一个<code class="fe kw kx ky kz b">Fragment</code>的时候。在使用应用程序之前，花点时间想想是否可以改进它的结构。有时，但只是有时使用<code class="fe kw kx ky kz b">Fragment</code>很棒，但大多数情况下，这种必要性来自于糟糕的结构代码。</p><p id="1cdf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后一个提示:反应碎片唯一能带的<code class="fe kw kx ky kz b">prop</code>是<code class="fe kw kx ky kz b">key</code>道具。这应该仅在映射时使用。即使这样，也要考虑你的应用程序结构。你应该把你的大组件分成更小的组件吗？如果您的包装器需要样式，您应该使用一个<code class="fe kw kx ky kz b">div</code>(或者其他的标签)。如果有相关的风格，它就不再是无意义的<code class="fe kw kx ky kz b">div</code>。一个<code class="fe kw kx ky kz b">Fragment</code>不能有一个<code class="fe kw kx ky kz b">className</code>或者<code class="fe kw kx ky kz b">data-qa</code>或者除了<code class="fe kw kx ky kz b">key</code>之外的任何东西。所以确保你不会犯那个常见的错误！</p><h1 id="8716" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="cc92" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">React片段是史诗。它们可以用来帮助您编写非常干净、可维护的代码！但是它们不应该到处使用。只有在您清楚地了解了您的组件结构并确定没有更好的替代方案之后，才应该使用它们。</p><p id="6928" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">和往常一样，我的干净代码主题受到了著名书籍<a class="ae la" href="https://amzn.to/2LxtXDo" rel="noopener ugc nofollow" target="_blank">代码完成:软件构造实用手册，第二版</a>的启发。这是一个史诗般的阅读，在帮助你用更结构化的方法思考和编写代码方面肯定是有价值的。</p><p id="b7fe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你喜欢这篇文章，请留言、鼓掌、喜欢并分享。一定要关注我在<a class="ae la" href="https://www.twitter.com/barrymdoyle" rel="noopener ugc nofollow" target="_blank">推特</a>、<a class="ae la" href="https://www.youtube.com/barrymichaeldoyle" rel="noopener ugc nofollow" target="_blank"> YouTube </a>、&amp;T6中发布的新内容！</p></div><div class="ab cl nk nl hu nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="ij ik il im in"><p id="9f83" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="mv">原为2018年9月4日在</em><a class="ae la" href="https://www.barrymichaeldoyle.com/fragment" rel="noopener ugc nofollow" target="_blank"><em class="mv">www.barrymichaeldoyle.com</em></a><em class="mv">发布。</em></p></div></div>    
</body>
</html>