<html>
<head>
<title>Playing a Video with Jetpack Compose</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Jetpack Compose播放视频</h1>
<blockquote>原文：<a href="https://itnext.io/playing-a-video-with-jetpack-compose-10a453ff956?source=collection_archive---------0-----------------------#2020-07-29">https://itnext.io/playing-a-video-with-jetpack-compose-10a453ff956?source=collection_archive---------0-----------------------#2020-07-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/b529b81112b12f6c109546aff0f3d509.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5ISNOFs1sINt-0oNQhNw-A.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">BetterVideoPlayer预览，我早期的项目之一</figcaption></figure><p id="d7ce" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这个帖子是在测试版的Jetpack Compose发布后编辑的。</p><h1 id="5891" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">决定运动员</h1><p id="902a" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">在我们开始讨论如何在可组合视图中播放视频之前，我们需要决定一个播放器类。从头开始培养一名球员是一项相当艰巨的任务。在这个项目中，我们只对UI方面的东西感兴趣。这将我们从传统媒体播放器的单个帧渲染、远程数据获取和状态管理中解放出来。</p><p id="181f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">Android自己的MediaPlayer SDK对于一个简单的视频播放器项目来说是可以的。我甚至在一个名为<a class="ae md" href="https://github.com/halilozercan/BetterVideoPlayer" rel="noopener ugc nofollow" target="_blank"> BetterVideoPlayer </a>的老开源项目中使用过它。然而，当涉及到支持各种编解码器，尤其是来自远程媒体源的编解码器时，它有相当多的问题。我没有处理基本的媒体播放器问题，而是决定选择加入Youtube Android应用程序使用的<a class="ae md" href="http://exoplayer.dev" rel="noopener ugc nofollow" target="_blank"> ExoPlayer2 </a>。它有自己的用户界面模块，使事情变得更容易，但我们将限制我们的使用，只有一个表面(PlayerView)将呈现视频。</p><p id="6922" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">将此添加到对<code class="fe me mf mg mh b">app</code>模块的<code class="fe me mf mg mh b">build.gradle</code>依赖性。在本教程中，我将跳过其他合成依赖项。</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="3b97" class="mq lb iq mh b gy mr ms l mt mu">implementation 'com.google.android.exoplayer:exoplayer:2.11.7'</span></pre><p id="51a7" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">因为我们不想在这个时候关心管理一个播放器，我们可以用一个基本的配置来勉强播放一个视频。</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="f758" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在我们继续之前，让我们给AndroidManifest添加INTERNET权限，因为我们将使用远程资源。</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="c43f" class="mq lb iq mh b gy mr ms l mt mu">&lt;uses-permission android:name="android.permission.INTERNET"/&gt;</span></pre><h1 id="63c8" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">夸大传统观点</h1><p id="328f" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">ExoPlayer需要一个表面来呈现它保存的视频。但是，ExoPlayer目前不支持可组合功能作为合法的Android视图。它可以与TextureView、SurfaceView和ExoPlayer自己的PlayerView配合使用。前两个选择需要关于位置、大小和纵横比的精细纹理细节。我们可以用PlayerView来代替处理这些问题，player view在ExoPlayer上运行得很好。</p><p id="86f6" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">那么大的问题来了。我们如何在一个可组合的视图中呈现一个传统的Android视图。答案是<code class="fe me mf mg mh b"><a class="ae md" href="https://joebirch.co/android/exploring-jetpack-compose-android-view/" rel="noopener ugc nofollow" target="_blank">AndroidView</a></code>。它有一个非常简单的界面，适用于包括我们在内的大多数用例。你可以在谷歌的这个<a class="ae md" href="https://developer.android.com/jetpack/compose/interop#views-in-compose" rel="noopener ugc nofollow" target="_blank">文档</a>中了解更多关于传统Android和Compose之间的<code class="fe me mf mg mh b">AndroidView</code>和其他互操作。</p><p id="9c61" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们可以添加<code class="fe me mf mg mh b">AndroidView</code>,使<code class="fe me mf mg mh b">PlayerView</code>膨胀到我们的组合中，以粘合一个视频播放器。</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="9a47" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">当您运行应用程序时，它应该可以正常播放视频。当然，我们还没有为回放添加任何控件，但我们会谈到这一点。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mx"><img src="../Images/0e07b1dbf1885a8dd04cbcd3b41c818d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-dbhNUUWiN9axrxxcZktmw.png"/></div></div></figure><h1 id="e575" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">将参数作为状态传递</h1><p id="bf94" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">关于玩家的大部分东西都不见了，现在能找到的都是硬编码的。我们可以探索所有可以使用的功能。一种可能的情况是用户可能想要改变视频源。为了实现这一点，我们将假设源代码将通过<code class="fe me mf mg mh b">VideoPlayer</code> composable的参数来提供。</p><p id="261c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">MainActivity内容应该将source声明为一种状态，并定义修改这种状态的方法。此外，当前状态应该传递给视频播放器。</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="aeec" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">VideoPlayer将利用<code class="fe me mf mg mh b">LaunchedEffect</code>捕捉源代码的变化。</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="7a8d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">ExoPlayer不再使用硬编码的源代码创建。相反，每当这个参数改变进入可组合函数时，它利用<code class="fe me mf mg mh b">LaunchedEffect</code>来重置源。如果你在这个时候运行应用程序，你会看到按下按钮立即改变了运行视频的来源，没有任何东西被搞乱。ExoPlayer保留实例以及PlayerView本身。</p><h1 id="2cd5" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">可组合的功能不仅仅是简单的视图</h1><p id="2d8d" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">自从开始以来，我们已经取得了相当大的进步。有了Jetpack Compose，现在我们手中就有了一个功能正常的视频播放器。虽然是基础，但这是很多机会的开始。从现在开始，我们可以充分利用Jetpack Compose为我们提供的功能。然而，在继续之前，有一件事可以解决。</p><p id="ec87" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">可组合的函数不仅仅是视图。他们完全<code class="fe me mf mg mh b">functional</code>。我怎么强调都不为过。它们可以有返回值。他们可以在一个<code class="fe me mf mg mh b">Column</code>定义中运行随机的kotlin代码。因此，可组合函数甚至可以有返回类型，就像<code class="fe me mf mg mh b">remember</code>也是可组合的。这表明<code class="fe me mf mg mh b">VideoPlayer</code>可以将某种控制器返回给调用者函数。假设这个控制器是用于媒体播放的。让我们定义一个简单的回放控制集:</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="5ee5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">从<code class="fe me mf mg mh b">VideoPlayer</code>返回该接口</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="a02b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">最后，向主用户界面添加控件</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="1b0b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">当我们运行应用程序时，我们可以看到控件工作得很好，没有再次干扰整个组合的任何其他状态。</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="my mw l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">应用程序的最终预览</figcaption></figure><h1 id="3e0d" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">然后</h1><ul class=""><li id="d2ad" class="mz na iq ke b kf ly kj lz kn nb kr nc kv nd kz ne nf ng nh bi translated">向播放器添加控件和手势</li><li id="7224" class="mz na iq ke b kf ni kj nj kn nk kr nl kv nm kz ne nf ng nh bi translated">撰写目前缺乏一个搜索栏(滑块)，实现并添加到播放器</li><li id="f53c" class="mz na iq ke b kf ni kj nj kn nk kr nl kv nm kz ne nf ng nh bi translated">一些动画技巧的收尾工作。</li></ul></div></div>    
</body>
</html>