<html>
<head>
<title>How To Architect A Production-Level App In Flutter: Phone Number Authentication - Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Flutter中构建产品级应用程序:电话号码认证-第2部分</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-architect-a-production-level-app-in-flutter-phone-number-sign-in-part-2-63fff0bb79b1?source=collection_archive---------3-----------------------#2021-09-06">https://itnext.io/how-to-architect-a-production-level-app-in-flutter-phone-number-sign-in-part-2-63fff0bb79b1?source=collection_archive---------3-----------------------#2021-09-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/6edd943e7fdefe770110ed8e53839ea6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KZtfhgVtSSeeecX8FiVmNg.png"/></div></div></figure><p id="7f60" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<a class="ae kw" rel="noopener ugc nofollow" target="_blank" href="/how-to-architect-a-production-level-app-in-flutter-phone-number-sign-in-263628e1872c">的前一部分</a>中，我们实现了域和基础设施层。接下来，我们将实现应用层和表示层。应用层是处理状态管理和业务逻辑的地方。我选择的状态管理包是<a class="ae kw" href="https://pub.dev/packages/flutter_bloc" rel="noopener ugc nofollow" target="_blank"> flutter_bloc </a>。</p><p id="321f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">尽管我喜欢Bloc，但它需要大量样板代码来实现。还好有一个轻版的Bloc叫<a class="ae kw" href="https://bloclibrary.dev/#/coreconcepts?id=cubit" rel="noopener ugc nofollow" target="_blank"> Cubit </a>。它是Bloc的一个子集，不依赖于事件，而是使用方法发出新的状态。如果你不需要像<a class="ae kw" href="https://stackoverflow.com/questions/25991367/difference-between-throttling-and-debouncing-a-function" rel="noopener ugc nofollow" target="_blank">去抖</a>、<a class="ae kw" href="https://stackoverflow.com/questions/25991367/difference-between-throttling-and-debouncing-a-function" rel="noopener ugc nofollow" target="_blank">油门</a>、<a class="ae kw" href="https://www.woolha.com/tutorials/rxdart-using-map-operators-examples" rel="noopener ugc nofollow" target="_blank">切换图</a>这样的高级功能，使用cubit进行状态管理就绰绰有余了。</p><p id="a540" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们将实现一个cubit来处理电话号码登录逻辑。它使用域层中的身份验证服务接口与Firebase身份验证服务进行通信。它不会在应用层显式使用Firebase，这意味着我们的cubits将是独立于Firebase的。我们可以无缝地将服务提供商从Firebase切换到任何其他服务。原因是我们依赖于抽象的<code class="fe kx ky kz la b">IAuthService</code>类，而不是特定的服务提供者。</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="383c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当用户使用电话号码登录时，交互如下:</p><p id="060a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">用户:</p><ul class=""><li id="d42f" class="lh li iq ka b kb kc kf kg kj lj kn lk kr ll kv lm ln lo lp bi translated">输入电话号码</li><li id="da72" class="lh li iq ka b kb lq kf lr kj ls kn lt kr lu kv lm ln lo lp bi translated">按下下一步按钮</li><li id="fb9b" class="lh li iq ka b kb lq kf lr kj ls kn lt kr lu kv lm ln lo lp bi translated">看到下一个按钮消失</li><li id="37d7" class="lh li iq ka b kb lq kf lr kj ls kn lt kr lu kv lm ln lo lp bi translated">看到一个加载屏幕</li><li id="7651" class="lh li iq ka b kb lq kf lr kj ls kn lt kr lu kv lm ln lo lp bi translated">接收短信代码</li><li id="566f" class="lh li iq ka b kb lq kf lr kj ls kn lt kr lu kv lm ln lo lp bi translated">输入SMS代码</li><li id="40db" class="lh li iq ka b kb lq kf lr kj ls kn lt kr lu kv lm ln lo lp bi translated">被导航到主页</li><li id="19f6" class="lh li iq ka b kb lq kf lr kj ls kn lt kr lu kv lm ln lo lp bi translated">如果流程中出现任何问题，将收到一条错误消息</li></ul><p id="baa2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面的场景可以帮助我们确定<code class="fe kx ky kz la b">PhoneNumberSignInCubit</code>的方法和状态。我们可以推断出需要以下四种方法:</p><ul class=""><li id="9d62" class="lh li iq ka b kb kc kf kg kj lj kn lk kr ll kv lm ln lo lp bi translated"><code class="fe kx ky kz la b">phoneNumberChanged</code>:保存本州最新电话号码</li><li id="16ad" class="lh li iq ka b kb lq kf lr kj ls kn lt kr lu kv lm ln lo lp bi translated"><code class="fe kx ky kz la b">signInWithPhoneNumber</code>:当用户按下下一步按钮时，开始电话号码登录过程</li><li id="831f" class="lh li iq ka b kb lq kf lr kj ls kn lt kr lu kv lm ln lo lp bi translated"><code class="fe kx ky kz la b">smsCodeChanged</code>:保持最新的短信码状态</li><li id="f00e" class="lh li iq ka b kb lq kf lr kj ls kn lt kr lu kv lm ln lo lp bi translated"><code class="fe kx ky kz la b">verifySmsCode</code>:验证用户输入的短信代码</li></ul><p id="d5b7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当用户通过上面提到的方法与UI进行交互时，cubit的状态会发生变化。用户界面反映了腕关节的状态。考虑到用户交互和方法，state类应该保留以下内容:</p><ul class=""><li id="030b" class="lh li iq ka b kb kc kf kg kj lj kn lk kr ll kv lm ln lo lp bi translated"><code class="fe kx ky kz la b">phoneNumber</code>:用户输入的电话号码</li><li id="e955" class="lh li iq ka b kb lq kf lr kj ls kn lt kr lu kv lm ln lo lp bi translated"><code class="fe kx ky kz la b">verificationIdOption:</code>将用于验证SMS代码的验证id</li><li id="43dd" class="lh li iq ka b kb lq kf lr kj ls kn lt kr lu kv lm ln lo lp bi translated"><code class="fe kx ky kz la b">smsCode</code>:用户输入的短信代码</li><li id="7a2e" class="lh li iq ka b kb lq kf lr kj ls kn lt kr lu kv lm ln lo lp bi translated"><code class="fe kx ky kz la b">isInProgress</code>:加载状态，了解是否有正在进行的过程</li><li id="be55" class="lh li iq ka b kb lq kf lr kj ls kn lt kr lu kv lm ln lo lp bi translated"><code class="fe kx ky kz la b">failureOption</code>:用户在登录过程中出现问题时遇到的故障</li></ul><p id="767f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们已经完成了状态管理中最具挑战性的部分，即构建状态机。冻结类是实现状态类的完美候选，因为它们是不可变的，并且支持值相等。<code class="fe kx ky kz la b">PhoneNumberSignInState</code>类将如下所示:</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="c4b2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意state类中有三个额外的getters。这些getters派生自现有的状态，它们的目的是简化UI中状态的使用。例如，UI不需要知道验证id的存在。这只是一个实现细节。UI唯一关心的是知道什么时候显示next按钮，或者什么时候显示SMS代码输入表单。因此，我们定义的getters极大地简化了UI中的逻辑。</p><p id="572d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">国家级准备好了。我们现在可以跳到有趣的部分，实现业务逻辑。每当用户输入时，我们需要相应地更新状态中的<code class="fe kx ky kz la b">phoneNumber</code>或<code class="fe kx ky kz la b">smsCode</code>:</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="9e99" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当用户按下<strong class="ka ir">下一个</strong>按钮时，<code class="fe kx ky kz la b">signInWithPhoneNumber</code>方法被调用。然后，清除状态中的现有错误，并发出进行中状态。<code class="fe kx ky kz la b">_phoneNumberSignInSubscription</code>将监听认证服务接口中定义的<code class="fe kx ky kz la b">signInWithPhoneNumber</code>流。如果在登录过程中收到失败，我们会相应地发出状态。如果用户成功接收到SMS代码，验证id将被发送到状态，以便稍后在<code class="fe kx ky kz la b">verifySmsCode</code>方法中使用。</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="3da6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">不要忘记取消流订阅:</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="e144" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一旦用户输入SMS代码，就会调用cubit的<code class="fe kx ky kz la b">verifySmsCode</code>。该方法将状态中的<code class="fe kx ky kz la b">verificationId</code>和<code class="fe kx ky kz la b">smsCode</code>传递给认证服务。</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lf lg l"/></div></figure><h1 id="43d0" class="lv lw iq bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">授权肘</h1><p id="68bf" class="pw-post-body-paragraph jy jz iq ka b kb mt kd ke kf mu kh ki kj mv kl km kn mw kp kq kr mx kt ku kv ij bi translated">对<code class="fe kx ky kz la b">AuthCubit</code>的需求源于以下要求:</p><ul class=""><li id="f57c" class="lh li iq ka b kb kc kf kg kj lj kn lk kr ll kv lm ln lo lp bi translated">当用户打开应用程序时，我们需要了解用户是否已经登录</li><li id="030c" class="lh li iq ka b kb lq kf lr kj ls kn lt kr lu kv lm ln lo lp bi translated">如果用户已登录，该用户的电话号码将显示在主页上</li><li id="1930" class="lh li iq ka b kb lq kf lr kj ls kn lt kr lu kv lm ln lo lp bi translated">如果用户未登录，将显示电话号码登录页面</li><li id="87ca" class="lh li iq ka b kb lq kf lr kj ls kn lt kr lu kv lm ln lo lp bi translated">当用户成功完成登录后，我们会将用户重定向到主页</li><li id="ab27" class="lh li iq ka b kb lq kf lr kj ls kn lt kr lu kv lm ln lo lp bi translated">此外，主页上会有一个注销按钮。如果用户退出，我们会将用户导航到电话号码登录页面</li></ul><p id="c6f5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe kx ky kz la b">AuthState</code>类将非常简单。它将保留两个字段:</p><ul class=""><li id="bf7f" class="lh li iq ka b kb kc kf kg kj lj kn lk kr ll kv lm ln lo lp bi translated"><code class="fe kx ky kz la b">userModel</code>:当前登录的用户。如果用户没有登录，将保留一个空的用户模型</li><li id="0fa7" class="lh li iq ka b kb lq kf lr kj ls kn lt kr lu kv lm ln lo lp bi translated"><code class="fe kx ky kz la b">isUserCheckedFromAuthService</code>:一个布尔标志，用于了解我们是否在应用的生命周期中至少检查了一次用户的登录状态。当应用程序第一次打开时，我们的默认状态假设用户没有登录。在从<code class="fe kx ky kz la b">userChanges</code>流接收到实际用户信息后，<code class="fe kx ky kz la b">isUserCheckedFromAuthService</code>被设置为<code class="fe kx ky kz la b">true</code>。</li></ul><p id="401a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe kx ky kz la b">AuthState</code>类如下所示:</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="08df" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe kx ky kz la b">AuthCubit</code>方法也很简单。<code class="fe kx ky kz la b">_authUserSubscription</code>监听<code class="fe kx ky kz la b">authStateChanges</code>流。</p><p id="84f3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe kx ky kz la b">AuthCubit</code>是一个singleton，这意味着它只被创建一次，除非被手动处理，否则它将在整个应用程序生命周期中存在:</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lf lg l"/></div></figure><h1 id="d2ab" class="lv lw iq bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">表示层</h1><p id="25cd" class="pw-post-body-paragraph jy jz iq ka b kb mt kd ke kf mu kh ki kj mv kl km kn mw kp kq kr mx kt ku kv ij bi translated">表示层是我们的小部件所在的地方。它不应该包含业务逻辑或任何基础结构代码。表示层使用cubits中的方法与应用层进行交互，并根据状态变化进行自我更新。</p><p id="c6e8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此外，路由是在表示层内部处理的。对于路由，我使用了<a class="ae kw" href="https://pub.dev/packages/auto_route" rel="noopener ugc nofollow" target="_blank"> auto_route </a>包，这减少了样板文件。包设置已经在<a class="ae kw" href="https://github.com/erkansahin/bare-bones" rel="noopener ugc nofollow" target="_blank">裸机</a>模板中完成。我建议您阅读官方文档以了解该软件包的全部功能。</p><h1 id="5a42" class="lv lw iq bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">提供授权肘</h1><p id="4141" class="pw-post-body-paragraph jy jz iq ka b kb mt kd ke kf mu kh ki kj mv kl km kn mw kp kq kr mx kt ku kv ij bi translated">我们需要知道用户的身份验证状态，而不考虑当前的路由。因此，auth cubit将在<code class="fe kx ky kz la b">MaterialApp</code>之上提供，并贯穿应用程序的整个生命周期。它允许我们在应用程序的任何屏幕上访问身份验证状态:</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="4306" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">app最初的路线是<code class="fe kx ky kz la b">LandingPage</code>。它唯一的职责是确定用户的导航位置。如果用户已经登录，用户将被导航到<code class="fe kx ky kz la b">HomePage</code>。否则，用户被重定向到<code class="fe kx ky kz la b">PhoneNumberSignInPage</code>。</p><p id="d7dc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">创建登录页面时，有两种可能的情况:</p><ul class=""><li id="94a7" class="lh li iq ka b kb kc kf kg kj lj kn lk kr ll kv lm ln lo lp bi translated">在创建<code class="fe kx ky kz la b">LandingPage</code>之前，身份验证状态已就绪</li><li id="fe54" class="lh li iq ka b kb lq kf lr kj ls kn lt kr lu kv lm ln lo lp bi translated">在建立了<code class="fe kx ky kz la b">LandingPage</code>页面之后接收认证状态</li></ul><p id="ac1c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第一种情况在<code class="fe kx ky kz la b">LandingPage</code>的<code class="fe kx ky kz la b">initState</code>中处理。根据<code class="fe kx ky kz la b">AuthCubit</code>的状态，用户被重定向到正确的路线。如果<code class="fe kx ky kz la b">isUserLoggedIn</code>是<code class="fe kx ky kz la b">true</code>，我们可以安全地将用户导航到<code class="fe kx ky kz la b">HomePage</code>。否则，我们需要在将用户导航到<code class="fe kx ky kz la b">SignInPage</code>之前检查一个额外的标志。<code class="fe kx ky kz la b">isUserCheckedFromAuthService</code>告知<code class="fe kx ky kz la b">AuthState</code>中的认证用户信息是否可用。如果调用<code class="fe kx ky kz la b">initState</code>时查询没有结果，此时我们不应该采取行动将用户导航到任何路线。</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="997b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在第二种情况下，当<code class="fe kx ky kz la b">AuthState</code>更新时，我们将用户导航到正确的路线。我们将添加一个<code class="fe kx ky kz la b">BlocListener</code>，当认证的用户信息可用时就会触发。屏幕上会显示一个循环进度指示器，直到<code class="fe kx ky kz la b">isUserCheckedFromAuthService</code>更新:</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="843d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果用户未登录，则显示<code class="fe kx ky kz la b">PhoneNumberSignInPage</code>。它将利用<code class="fe kx ky kz la b">PhoneNumberSignInCubit</code>与外界联系。我们应该使用<code class="fe kx ky kz la b">BlocProvider</code>为<code class="fe kx ky kz la b">PhoneNumberSignInCubit</code>提供能够调用其方法和访问其状态的功能:</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="80e3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">每当<code class="fe kx ky kz la b">PhoneNumberSignInState</code>更新时，我们需要放置一个<code class="fe kx ky kz la b">BlocBuilder</code>来更新UI:</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="cb7f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">每当用户修改电话号码输入时，就会调用<code class="fe kx ky kz la b">phoneNumberChanged</code>方法，以便在状态中保持最新的输入。</p><p id="d166" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果用户按下<strong class="ka ir">下一个</strong>按钮，则<code class="fe kx ky kz la b">signInWithPhoneNumber</code>方法被调用，这将启动登录过程。流程开始后，我们将隐藏“下一步”按钮，并在屏幕中央显示一个加载指示器。</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="c111" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果用户在登录过程中收到一个错误，我们应该在屏幕上显示一个解释失败的祝酒词。我们可以使用<code class="fe kx ky kz la b">BlocListener</code>来捕捉错误。cubit状态被重置，以便用户可以在出错时重试:</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="5bac" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果一切顺利，用户将从Firebase收到一个SMS代码和一个验证id。收到验证id会触发我们的<code class="fe kx ky kz la b">BlocBuilder</code>；因此，SMS代码输入表单将显示在用户界面中。</p><p id="312f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当用户修改<code class="fe kx ky kz la b">smsCode</code>输入时，<code class="fe kx ky kz la b">smsCodeChanged</code>方法被调用，以便我们在状态中保持最新的输入。当输入最后一个代码数字时，会触发<code class="fe kx ky kz la b">verifySmsCode</code>。</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="7f00" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果用户验证成功，我们应该将用户重定向到<code class="fe kx ky kz la b">HomePage</code>。该行为可以通过用户登录状态改变时触发的<code class="fe kx ky kz la b">BlocListener</code>来完成:</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="a832" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<code class="fe kx ky kz la b">HomePage</code>上，显示登录用户的电话号码和<strong class="ka ir">注销</strong>按钮。为了显示用户的电话号码，我们可以在主页的<code class="fe kx ky kz la b">build</code>功能中使用一个<code class="fe kx ky kz la b">BlocBuilder</code>。</p><p id="e67a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">根据经验，将块构建器尽可能深地放在部件树中是很重要的。此外，它们不应该在你的区块/腕尺的每个状态改变时被触发。最好在您的<code class="fe kx ky kz la b">BlocBuilder</code>中使用<code class="fe kx ky kz la b">buildWhen</code>条件，或者使用<code class="fe kx ky kz la b">BlocSelector</code>观察值的变化，以提高您的应用程序的性能。在本教程的范围内，使用<code class="fe kx ky kz la b">buildWhen</code>条件可能不会显著影响性能。但是，您应该在生产级应用程序中使用它们:</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="f3fa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">按下<strong class="ka ir">注销</strong>按钮触发<code class="fe kx ky kz la b">AuthCubit</code>的<code class="fe kx ky kz la b">signOut</code>方法:</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="efeb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当用户成功退出时，我们应该将用户重定向到电话号码登录页面。为了实现这一行为，我们可以放置一个<code class="fe kx ky kz la b">BlocListener</code>，当用户不再登录时触发它:</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lf lg l"/></div></figure></div><div class="ab cl my mz hu na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ij ik il im in"><p id="b73b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">就是这样！您已经看到了电话号码登录功能在生产级应用程序中的实现。我意识到可能很难一下子掌握所有的东西，因为涉及到许多方案和概念。我鼓励你分析每一层都做了什么，并在现有的应用程序中添加一个功能。我相信增加谷歌登录功能对你来说是一个很好的挑战。</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="nf lg l"/></div></figure><p id="fa94" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这与我们在<a class="ae kw" href="https://sponty.app/#/" rel="noopener ugc nofollow" target="_blank"> Sponty </a>中使用的实现相同。这是一个视频驱动的社交媒体应用程序，用于自发的群体聚会。</p><figure class="lb lc ld le gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ng"><img src="../Images/2fcc2ea37f232c87d7fb60838ffe826d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0sbT4FjJPzuQUUfBctR3Dw.png"/></div></div></figure><p id="22b6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我希望这篇教程能帮助你理解如何在产品级应用程序中组织你的代码。欢迎在评论区提问。</p><p id="c93a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">感谢您的阅读，敬请关注！</p></div></div>    
</body>
</html>