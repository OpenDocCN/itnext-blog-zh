<html>
<head>
<title>Kubernetes, Microservices, and Github Actions Deployments</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes、微服务和Github操作部署</h1>
<blockquote>原文：<a href="https://itnext.io/unified-microservices-builds-using-github-actions-3442c4ee175e?source=collection_archive---------1-----------------------#2021-02-26">https://itnext.io/unified-microservices-builds-using-github-actions-3442c4ee175e?source=collection_archive---------1-----------------------#2021-02-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/d028ad0860759b3da685809a2f0987d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dCoBy8gjEX0g2y1xZrFXWQ.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">工作中的微服务；信用:存款照片</figcaption></figure><p id="4ca4" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">欢迎来到微服务的世界，在这里一切皆有可能，您只需要处理小代码库，而不是拥有数千个依赖项的巨型独石。听起来差不多，对吧？</p><p id="31ef" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我不会浪费你的时间来解释什么是微服务，为什么它们有用，以及在开发过程中应该使用什么模式和反模式。我想重点谈谈微服务中经常被忽视的部分，即微服务的部署以及与之相关的问题。</p><p id="4ead" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">每个人都有起点。让我们假设你刚开始这个项目，打算使用微服务来使它稳定、冗余，同时易于扩展。你有两个微服务，所以使用复制粘贴的古老方法，在这里和那里更改几行，相对容易实现CI/CD管道的处理。</p><h1 id="c58d" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">避免微服务CI/CD漂移</h1><p id="eff5" class="pw-post-body-paragraph kf kg it kh b ki mb kk kl km mc ko kp kq md ks kt ku me kw kx ky mf la lb lc im bi translated">开发几个月后，你就有了30种不同的微服务。其中一些有稍微不同的需求和构建参数，您会发现自己在不同的管道管理中挣扎。迟早，你会意识到，你对已经打了补丁的部署代码做了太多手脚，以至于它本身变成了一个项目。</p><p id="3282" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我每天都在与微服务打交道，我需要说，我也经历过这种情况。这就是为什么我决定回到过去，回到我的代码冒险之初，开始使用Makefiles。</p><h1 id="0dc6" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">让你的CI再次伟大</h1><p id="d44d" class="pw-post-body-paragraph kf kg it kh b ki mb kk kl km mc ko kp kq md ks kt ku me kw kx ky mf la lb lc im bi translated">将Makefile视为构建的统一接口——无论您是开发人员还是愿意在本地机器或CI bot上试用它的产品经理——执行任何命令都不需要高深的知识。我通常用Go来写东西，但这并不重要，因为这种想法可以在你想使用的所有语言和技术之间移植。</p><p id="497c" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们将关注的基本命令</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="d263" class="mp le it ml b gy mq mr l ms mt">make         # to build<br/>make test    # to test<br/>make lint    # to lint<br/>make update  # to pull dependencies</span></pre><p id="0983" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">Makefile本身(这里也有<a class="ae mu" href="https://github.com/lukaszraczylo/universal-github-action-pipeline/blob/main/Makefile" rel="noopener ugc nofollow" target="_blank"/>)</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="3ffb" class="mp le it ml b gy mq mr l ms mt">build: all</span><span id="8b87" class="mp le it ml b gy mv mr l ms mt">cur-dir   := $(shell basename `pwd`)<br/>SET_PRIVATE="github.com/telegram-bot-app/*"<br/>MICROSERVICE_NAME?=$(shell basename `git rev-parse --show-toplevel`)<br/>GITHUB_COMMIT_NUMBER?=0<br/>GITHUB_SHA?=$(shell git rev-parse HEAD)</span><span id="df29" class="mp le it ml b gy mv mr l ms mt">all:<br/>  go build -o service.bin -ldflags="-s -w -X main.SVC_RELEASE=6.1.${GITHUB_COMMIT_NUMBER} -X main.SVC_VERSION=`date +\"%Y%m%d%H%M\"`@${GITHUB_SHA} -X main.SVC_NAME=${MICROSERVICE_NAME}" *.go</span><span id="5a6f" class="mp le it ml b gy mv mr l ms mt">test:<br/>  go test ./...</span><span id="e1b4" class="mp le it ml b gy mv mr l ms mt">lint:<br/>  golangci-lint run *.go</span><span id="6459" class="mp le it ml b gy mv mr l ms mt">update:<br/>  GOPRIVATE=$(SET_PRIVATE) go get -u ./...</span><span id="982e" class="mp le it ml b gy mv mr l ms mt">clean:<br/>  rm *.bin</span></pre><p id="fc56" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">解释一下:我创建的所有微服务都应该用适当的版本来标识自己，因此我在构建过程中使用<strong class="kh iu"> LDFLAGS </strong>来设置适当的值。在我的例子中，最终结果是:</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="e779" class="mp le it ml b gy mq mr l ms mt">var SVC_RELEASE 6.1.55<br/>var SVC_VERSION 202102261208@9e77914d<br/>var SVC_NAME ms.image-filter</span></pre><p id="36fd" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">基础工作已经完成，现在您可以发出<strong class="kh iu"> make </strong>命令来完成工作。如果使用您的库，不要忘记更新<strong class="kh iu"> SET_PRIVATE </strong>值。</p><figure class="mg mh mi mj gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mw"><img src="../Images/ccb2221fcaf7e4725c2bf3a51158f812.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*60-wpX3gz4QW5PokjC33qQ.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">使用中的工作流Github操作的图表</figcaption></figure><h1 id="3725" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">工作流主页</h1><p id="2503" class="pw-post-body-paragraph kf kg it kh b ki mb kk kl km mc ko kp kq md ks kt ku me kw kx ky mf la lb lc im bi translated">必需的存储库机密:<br/> <strong class="kh iu"> GHCR_TOKEN </strong> — Github个人访问令牌，对包具有读、写权限。<br/><strong class="kh iu">GKE _访问_密钥— </strong>您的谷歌云Kubernetes引擎凭证</p><p id="6b11" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在文章的这一部分，我将对工作流进行一些解释，让读者了解幕后发生的事情。完整的代码可以在<a class="ae mu" href="https://github.com/lukaszraczylo/universal-github-action-pipeline/blob/main/workflow-push.yaml" rel="noopener ugc nofollow" target="_blank">lukaszraczylo/universal-github-action-pipeline</a>资源库中找到。</p><p id="5380" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu"> jobs.prepare: </strong>这是工作流程中最关键的工作。它会自动为构建的其余部分设置所有变量，无需您的任何输入。</p><ul class=""><li id="5a0f" class="mx my it kh b ki kj km kn kq mz ku na ky nb lc nc nd ne nf bi translated">获取存储库名称(在我的例子中是$ project.ms. $ microservice _ name)并将其用作基础。</li><li id="4924" class="mx my it kh b ki ng km nh kq ni ku nj ky nk lc nc nd ne nf bi translated">清理部署流程中要与kubernetes配置一起使用的存储库名称(用破折号替换点)。</li><li id="6224" class="mx my it kh b ki ng km nh kq ni ku nj ky nk lc nc nd ne nf bi translated">版本约定——在我们的例子中，我们将使用1.x.y，其中<strong class="kh iu"> x </strong>是存储库中提交的数量(因此fetch-depth被设置为零，以便将它们全部取出),而<strong class="kh iu"> y </strong>是Github操作的连续构建号。</li><li id="cd5f" class="mx my it kh b ki ng km nh kq ni ku nj ky nk lc nc nd ne nf bi translated">基本docker映像名称将采用以下格式:` ghcr . io/$ github _ repo _ owner/$ sanitized _ repo _ name '</li><li id="3cd7" class="mx my it kh b ki ng km nh kq ni ku nj ky nk lc nc nd ne nf bi translated">在构建的后期阶段很少使用其他变量。</li></ul><p id="f7e2" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu"> jobs.test: </strong>运行linter(如果工作流顶部的<strong class="kh iu"> ENABLE_CODE_LINT </strong>变量设置为true)并执行<strong class="kh iu"> make test </strong>。在这个阶段，您应该会发现Makefile的美妙之处，它是语言不可知的。如果您有nodejs项目来运行测试，您可以在项目中修改Makefile来反映它，但是命令保持不变。</p><p id="d066" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu"> jobs.code_scans: </strong>对您的代码运行安全扫描，以防止由供应商提供的软件包引入的错误。</p><p id="fccc" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu"> jobs.build: </strong>构建多架构映像(amd64和arm 64[参见我的关于树莓Pi上的<a class="ae mu" href="https://medium.com/swlh/building-your-home-raspberry-pi-kubernetes-cluster-14eeeb3c521e?source=post_stats_page-------------------------------------" rel="noopener"> Kubernetes集群的文章</a>),并将它们推送到Github容器注册表，并适当地进行标记。在这项工作的最后一步中，我们还将扫描输出映像，查找基础映像本身中的任何其他漏洞。</p><figure class="mg mh mi mj gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nl"><img src="../Images/3e1ae001ce59eb4adbe3a90bceddcda8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jLIBqW2gBfSz9Oy18XkoNw.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">使用通用管道推送多架构docker图像。</figcaption></figure><p id="4929" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">查看资源库，找到我为此使用的<a class="ae mu" href="https://github.com/lukaszraczylo/universal-github-action-pipeline/blob/main/Dockerfile" rel="noopener ugc nofollow" target="_blank"> Dockerfile </a>。</p><p id="02bc" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu"> jobs.deploy: </strong>该作业利用初始<code class="fe nm nn no ml b">jobs.prepare</code>作业中设置的版本值来标记成功部署后的发布。</p><figure class="mg mh mi mj gt ju gh gi paragraph-image"><div class="gh gi np"><img src="../Images/f0677204fc7a2e4011026772e9f7c4c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1320/format:webp/1*ebJh_ZdQmWtvt1n1Qjbmgw.png"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">成功运行工作流后，标记发布。</figcaption></figure><h1 id="00fb" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated"><strong class="ak">残局和TL；博士</strong></h1><p id="bc67" class="pw-post-body-paragraph kf kg it kh b ki mb kk kl km mc ko kp kq md ks kt ku me kw kx ky mf la lb lc im bi translated">根据所描述的工作流程，您将拥有:</p><ul class=""><li id="113b" class="mx my it kh b ki kj km kn kq mz ku na ky nb lc nc nd ne nf bi translated">代码安全扫描和检查你的代码</li><li id="5128" class="mx my it kh b ki ng km nh kq ni ku nj ky nk lc nc nd ne nf bi translated">支持amd64和arm64架构的Docker映像</li><li id="11bc" class="mx my it kh b ki ng km nh kq ni ku nj ky nk lc nc nd ne nf bi translated">部署到您的GKE集群的Docker映像</li><li id="4672" class="mx my it kh b ki ng km nh kq ni ku nj ky nk lc nc nd ne nf bi translated">基本图像安全扫描</li><li id="5ef4" class="mx my it kh b ki ng km nh kq ni ku nj ky nk lc nc nd ne nf bi translated">发布的代码将在Github上标记</li></ul></div></div>    
</body>
</html>