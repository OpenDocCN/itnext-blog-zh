<html>
<head>
<title>Explore REST APIs with cURL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用cURL探索REST APIs</h1>
<blockquote>原文：<a href="https://itnext.io/explore-rest-apis-with-curl-e58ebaaabf7a?source=collection_archive---------1-----------------------#2020-10-18">https://itnext.io/explore-rest-apis-with-curl-e58ebaaabf7a?source=collection_archive---------1-----------------------#2020-10-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a5ef" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">对使用Web服务一无所知？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6529222701219c479048c96c135ecb49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cw6Gql7-97AnSCll0z9cMw.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@jordanharrison?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">乔丹·哈里森</a>在<a class="ae ky" href="https://unsplash.com/s/photos/network?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="ea35" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">没有什么比和网络技术公司一起工作更让我感到不自在的了。这是关于如何主要使用cURL Unix命令使用REST APIs的概述，对您和我都有好处。我还将看看如何从一些不同的编程语言中做到这一点。</p><p id="9627" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">阅读更多信息:</p><ul class=""><li id="cf67" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><a class="ae ky" href="https://erik-engheim.medium.com/working-with-the-http-protocol-in-julia-5697d531f0c7" rel="noopener">在Julia中使用HTTP协议和表单</a> —设置HTTP请求，模拟响应。如何传输图像数据？HTML表单呢？如何在请求处理器中处理它们？</li><li id="4bea" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://erik-engheim.medium.com/a-guide-to-different-web-technologies-and-how-they-are-related-a0951c7b43f4" rel="noopener">不同Web技术指南</a>—Web sockets与Unix sockets有何不同。AJAX vs WebSockets，jQuery，React等等，它们是如何联系和重叠的？</li></ul><p id="93c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了避免你不得不到处跳来跳去，我会尽量把所有的关键信息都写在这篇文章里。</p><h2 id="9e2b" class="mj mk it bd ml mm mn dn mo mp mq dp mr li ms mt mu lm mv mw mx lq my mz na nb bi translated">什么是REST API？</h2><p id="559f" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">当你使用C/C++，Python等时，它不像一个编程API。相反，它是作为一组URL公开的API。这意味着除了Web浏览器之外，您可以与REST API进行交互。REST只是使用Web技术(如HTTP协议)与服务器上运行的应用程序进行交互的一种简单方式。</p><p id="ee44" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您主要通过使用以下两种HTTP请求之一来实现这一点:</p><ul class=""><li id="d329" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">当你在网络浏览器中写一个网址时，就会发生这种情况。一个GET请求被发送到web服务器，一些数据被返回，通常是web浏览器显示的HTML格式的网页。</li><li id="8c3d" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe nh ni nj nk b">POST</code>用于发送数据。它还包括指定一个URL，但也包括提供一些要发送的数据。</li></ul><p id="78e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我所说的<em class="nl">请求</em>是指你通过TCP/IP连接向服务器发送一些数据，目的是取回一些特定的数据。</p><p id="99f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，您可以通过在网络浏览器中输入URL地址<code class="fe nh ni nj nk b">http://blog.translusion.com</code>来访问我的主页，或者您可以使用Unix <code class="fe nh ni nj nk b">curl</code>命令来下载HTML页面:</p><pre class="kj kk kl km gt nm nk nn no aw np bi"><span id="25db" class="mj mk it nk b gy nq nr l ns nt">$ curl <a class="ae ky" href="http://blog.translusion.com" rel="noopener ugc nofollow" target="_blank">http://blog.translusion.com</a></span></pre><p id="04c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您也添加了<code class="fe nh ni nj nk b">-i</code>开关，您还会得到类似如下的HTTP报头:</p><pre class="kj kk kl km gt nm nk nn no aw np bi"><span id="f736" class="mj mk it nk b gy nq nr l ns nt">$ curl -i http://blog.translusion.com<br/><br/>HTTP/1.1 200 OK<br/>Content-Type: text/html; charset=utf-8<br/>Server: GitHub.com<br/>Last-Modified: Thu, 15 Oct 2020 22:47:13 GMT<br/>Content-Length: 9879<br/>Accept-Ranges: bytes<br/>Age: 146<br/>Connection: keep-alive<br/>X-Served-By: cache-osl6530-OSL</span></pre><p id="56c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实际上，您可以使用一个更加“原始”的工具NetCat来完成同样的任务，这个工具通过Unix命令<code class="fe nh ni nj nk b">nc</code>来调用。使用这个命令，您基本上只需发送原始数据。好处是您可以更好地理解HTTP协议是如何工作的。</p><pre class="kj kk kl km gt nm nk nn no aw np bi"><span id="9510" class="mj mk it nk b gy nq nr l ns nt">$ nc blog.translusion.com 80<br/>GET / HTTP/1.1<br/>Host: blog.translusion.com</span></pre><p id="9661" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您在命令下面看到的内容不会返回。确切地说，这是我在终端中写的内容。你点击输入一个额外的时间，你会得到与<code class="fe nh ni nj nk b">curl</code>相同的内容。点击<code class="fe nh ni nj nk b">Ctrl+D</code>退出。</p><p id="f4b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要执行一个HTTP请求，应该在<code class="fe nh ni nj nk b">nc</code>中写什么可能并不明显。但是你可以通过在服务器模式下运行<code class="fe nh ni nj nk b">nc</code>并使用<code class="fe nh ni nj nk b">curl</code>连接到它来作弊。然后你就可以知道<code class="fe nh ni nj nk b">curl</code>到底是做什么的了。在单独的窗口中，您可以运行以下命令来侦听端口1234上的连接:</p><pre class="kj kk kl km gt nm nk nn no aw np bi"><span id="b380" class="mj mk it nk b gy nq nr l ns nt">$ nc -l 1234</span></pre><p id="07d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后在您原来的终端窗口中，您可以使用<code class="fe nh ni nj nk b">curl</code>向您的本地<code class="fe nh ni nj nk b">nc</code>服务器发出请求</p><pre class="kj kk kl km gt nm nk nn no aw np bi"><span id="8729" class="mj mk it nk b gy nq nr l ns nt">$ curl -i <a class="ae ky" href="http://localhost:1234/foo/bar.html" rel="noopener ugc nofollow" target="_blank">http://localhost:1234/foo/bar.html</a></span></pre><p id="3be8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在假服务器端，您将看到以下输出:</p><pre class="kj kk kl km gt nm nk nn no aw np bi"><span id="17a1" class="mj mk it nk b gy nq nr l ns nt">$ nc -l 1234<br/>GET /foo/bar.html HTTP/1.1<br/>Host: localhost:1234<br/>User-Agent: curl/7.64.1<br/>Accept: */*</span></pre><p id="00a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于HTTP响应，您可以在头部获得一系列信息。最重要的部分是这样的部分:</p><pre class="kj kk kl km gt nm nk nn no aw np bi"><span id="c147" class="mj mk it nk b gy nq nr l ns nt">HTTP/1.1 200 OK<br/>Content-Type: text/html; charset=UTF-8</span></pre><p id="e31b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它告诉您使用的HTTP协议版本，请求是否成功，您得到的是什么类型的数据以及它是如何格式化的。以下是一些常见的HTTP状态代码，您可能已经在某个时候见过了:</p><ul class=""><li id="30dc" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe nh ni nj nk b">200 OK</code>成功</li><li id="bb81" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe nh ni nj nk b">400 Bad Request</code>请求中的语法错误</li><li id="bb90" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe nh ni nj nk b">401 Unauthorized</code>认证失败</li><li id="e701" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe nh ni nj nk b">402 Not found</code>网页不在那里</li></ul><h2 id="49c7" class="mj mk it bd ml mm mn dn mo mp mq dp mr li ms mt mu lm mv mw mx lq my mz na nb bi translated">贸易工具</h2><p id="b065" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">好的，希望这能给你一个模糊的概念，当我说REST API的时候，我在说什么。稍后我们将会看到更多的例子。了解一些可能用于REST API的工具是很有用的。</p><ul class=""><li id="bfd1" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">使用HTTP协议获取网站或任何其他数据。</li><li id="b2bc" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://pythonhosted.org/curlish/" rel="noopener ugc nofollow" target="_blank"> curlish </a>类似curl但支持<a class="ae ky" href="https://en.wikipedia.org/wiki/OAuth" rel="noopener ugc nofollow" target="_blank"> OAuth认证</a>。例如被脸书使用。</li><li id="83a8" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://stedolan.github.io/jq/" rel="noopener ugc nofollow" target="_blank"> jq </a> Like <em class="nl"> sed </em>为JSON数据</li><li id="b210" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">nc是TCP/IP的“瑞士军刀”。您可以将它用作服务器或客户端。您可以读取和发送原始HTTP请求和回复。</li><li id="70b0" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Ifconfig" rel="noopener ugc nofollow" target="_blank"> ifconfig </a>列出网络接口及其IP地址</li><li id="f019" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://www.charlesproxy.com" rel="noopener ugc nofollow" target="_blank"> Charles Proxy </a>让你看到你和互联网之间的所有流量。<em class="nl">响应</em>和<em class="nl">请求</em>可以被记录和重放。非常通用的工具。</li></ul><h2 id="f5ab" class="mj mk it bd ml mm mn dn mo mp mq dp mr li ms mt mu lm mv mw mx lq my mz na nb bi translated">阅读REST API文档</h2><p id="db9a" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">让我们看看如何使用<code class="fe nh ni nj nk b">curl</code>来探索一个文档化的REST API。这里有一个来自JFrog的例子，是我最近正在做的。JFrog提供了许多服务，其中之一是为二进制文件提供一个存储库，他们称之为Artifactory。</p><h2 id="8890" class="mj mk it bd ml mm mn dn mo mp mq dp mr li ms mt mu lm mv mw mx lq my mz na nb bi translated">文件信息</h2><p id="fd7e" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">其中一个API调用是<a class="ae ky" href="https://www.jfrog.com/confluence/display/JFROG/Artifactory+REST+API#ArtifactoryRESTAPI-FileInfo" rel="noopener ugc nofollow" target="_blank"> File Info </a>，它用于获取存储在您在JFrog artifactory中创建的存储库中的文件的信息。</p><p id="a44a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">文档的重要部分提供了以下信息:</p><ul class=""><li id="d20c" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><strong class="lb iu">用法:</strong>T1】</li><li id="4fb1" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><strong class="lb iu">出产:</strong>T2】</li></ul><p id="c9e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nl">用法</em>告诉我们，我们需要将它指定为一个<code class="fe nh ni nj nk b">GET</code>请求，而<em class="nl">产生的</em>告诉我们，我们得到的响应将是一个JSON数据。</p><p id="49aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">花括号表示占位符。因此,<code class="fe nh ni nj nk b">{repoKey}</code>是您的存储库的名称,<code class="fe nh ni nj nk b">{filePath}</code>是您想要了解的repo中某个文件的路径。</p><p id="d5b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我下面的例子中，我通过将<code class="fe nh ni nj nk b">stuff</code>指定为我的repo的名称并将文件路径指定为<code class="fe nh ni nj nk b">myfile.txt</code>来调用这个API。</p><pre class="kj kk kl km gt nm nk nn no aw np bi"><span id="128a" class="mj mk it nk b gy nq nr l ns nt">$ curl -u erik:qwerty -X GET "https://mickeymouse.jfrog.io/artifactory/api/storage/stuff/myfile.txt"</span></pre><p id="3dee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您将<code class="fe nh ni nj nk b">nc</code>设置为一个服务器，并连接到一个本地<code class="fe nh ni nj nk b">nc</code>服务器，那么这个<code class="fe nh ni nj nk b">curl</code>调用将会导致这个文本被传输到服务器。</p><pre class="kj kk kl km gt nm nk nn no aw np bi"><span id="94fa" class="mj mk it nk b gy nq nr l ns nt">GET /artifactory/api/storage/stuff/myfile.txt HTTPS/1.1<br/>Host: mickeymouse.jfrog.io:80<br/>Authorization: Basic ZXJpazpxd2VydHkK</span></pre><p id="5822" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意添加<code class="fe nh ni nj nk b">-u erik:qwerty</code>来指定登录名和密码是如何导致以下字段被添加到请求中的:</p><pre class="kj kk kl km gt nm nk nn no aw np bi"><span id="5a1a" class="mj mk it nk b gy nq nr l ns nt">Authorization: Basic ZXJpazpxd2VydHkK</span></pre><p id="6c2e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们如何得到它？事实上，您可以自己创建这个字符串。<code class="fe nh ni nj nk b">ZXJpazpxd2VydHkK</code>其实只是<code class="fe nh ni nj nk b">erik:qwerty</code>的一个<a class="ae ky" href="https://en.wikipedia.org/wiki/Base64" rel="noopener ugc nofollow" target="_blank"> Base64编码</a>。编码只是以不同的格式存储一些信息的一种方式。Base64涉及将每个6位集合转换成从0到63的可见字符。</p><p id="3538" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以用<code class="fe nh ni nj nk b">base64</code> Unix命令来执行这个操作:</p><pre class="kj kk kl km gt nm nk nn no aw np bi"><span id="4136" class="mj mk it nk b gy nq nr l ns nt">echo "erik:qwerty" | base64<br/>ZXJpazpxd2VydHkK</span></pre></div><div class="ab cl nu nv hx nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="im in io ip iq"><p id="02b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">进行这个<em class="nl">文件信息</em>调用将给出JSON数据作为反馈。我们通常希望以某种方式解析它。</p><pre class="kj kk kl km gt nm nk nn no aw np bi"><span id="f3be" class="mj mk it nk b gy nq nr l ns nt">{<br/>  "repo" : "stuff",<br/>  "path" : "/myfile.txt",<br/>  "created" : "2020-10-16T12:51:33.916Z",<br/>  "createdBy" : "erik",<br/>  "lastModified" : "2020-10-16T12:51:33.699Z",<br/>  "modifiedBy" : "erik",<br/>  "lastUpdated" : "2020-10-16T12:51:33.917Z",<br/>  "downloadUri" : "https://mickeymouse.jfrog.io/artifactory/stuff/myfile.txt",<br/>  "mimeType" : "text/plain",<br/>  "size" : "42",<br/>  "checksums" : {<br/>    "sha1" : "d0d8980bdbe9622acff4c41614d84b9692dd13be",<br/>    "md5" : "db98b69f101495872bda4805e2803742",<br/>    "sha256" : "3bc6b50993e609908d2946c748b8eee664201c9bbb0a45b9648a6bc9f64c1b15"<br/>  },<br/>  "originalChecksums" : {<br/>    "sha256" : "3bc6b50993e609908d2946c748b8eee664201c9bbb0a45b9648a6bc9f64c1b15"<br/>  },<br/>  "uri" : "https://mickeymouse.jfrog.io/artifactory/api/storage/stuff/myfile.txt"<br/>}</span></pre><p id="a8db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以像这样使用<code class="fe nh ni nj nk b">jq</code>取出MD5校验和:</p><pre class="kj kk kl km gt nm nk nn no aw np bi"><span id="a98b" class="mj mk it nk b gy nq nr l ns nt">$ curl -u erik:qwerty -X GET "https://mickeymouse.jfrog.io/artifactory/api/storage/stuff/myfile.txt" | jq '.["checksums"]["md5"]'<br/>"db98b69f101495872bda4805e2803742"</span></pre><h2 id="e54c" class="mj mk it bd ml mm mn dn mo mp mq dp mr li ms mt mu lm mv mw mx lq my mz na nb bi translated">使用Julia处理REST APIs</h2><p id="723e" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">我们需要一些不同的包来使用Julia和REST APIs。</p><pre class="kj kk kl km gt nm nk nn no aw np bi"><span id="2f26" class="mj mk it nk b gy nq nr l ns nt">(@v1.5) pkg&gt; add HTTP<br/>(@v1.5) pkg&gt; add JSON</span></pre><p id="27a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe nh ni nj nk b">HTTP</code>包，我们可以执行REST请求:</p><pre class="kj kk kl km gt nm nk nn no aw np bi"><span id="bd1a" class="mj mk it nk b gy nq nr l ns nt">julia&gt; using HTTP<br/><br/>julia&gt; r = HTTP.request(:GET, "https://erik:qwerty@mickeymouse.jfrog.io/artifactory/api/storage/stuff/myfile.txt");<br/><br/>julia&gt; julia&gt; fieldnames(typeof(r))<br/>(:version, :status, :headers, :body, :request)</span></pre><p id="f266" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用JSON包，我们可以从请求响应的有效负载体中提取数据:</p><pre class="kj kk kl km gt nm nk nn no aw np bi"><span id="35f7" class="mj mk it nk b gy nq nr l ns nt">julia&gt; using JSON<br/>julia&gt; s = String(r.body);<br/><br/>julia&gt; dict = JSON.parse(s);<br/><br/>julia&gt; dict["checksums"]<br/>Dict{String,Any} with 3 entries:<br/>  "sha256" =&gt; "3bc6b50993e609908d2946c748b8eee664201c9bbb0a45b9648a6bc9f64c1b15"<br/>  "md5"    =&gt; "db98b69f101495872bda4805e2803742"<br/>  "sha1"   =&gt; "d0d8980bdbe9622acff4c41614d84b9692dd13be"<br/><br/>julia&gt; dict["checksums"]["md5"]<br/>"db98b69f101495872bda4805e2803742"</span></pre><h2 id="fe98" class="mj mk it bd ml mm mn dn mo mp mq dp mr li ms mt mu lm mv mw mx lq my mz na nb bi translated">使用Python处理REST APIs</h2><p id="7172" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">使用Julia或<code class="fe nh ni nj nk b">jq</code>来处理REST APIs的问题是，这两个软件通常都不包含在随机的Linux安装中。这有什么关系？你经常在docker容器中运行这些东西。例如，我正在使用位桶管道，这是一种在源代码提交时触发代码运行的方式。</p><p id="256c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我的例子中，我想使用REST API调用将生成的二进制代码从构建发送到JFrog二进制存储库。这意味着通常使用一些标准的docker容器。在这些容器中，通常会安装以下内容:</p><ul class=""><li id="42a4" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe nh ni nj nk b">curl</code></li><li id="0587" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe nh ni nj nk b">python</code> 2.7</li></ul><p id="fa49" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是<code class="fe nh ni nj nk b">jq</code>、<code class="fe nh ni nj nk b">julia</code>、<code class="fe nh ni nj nk b">ruby</code>和许多其他潜在有用的东西将不在那里。其次，你也没有安装很多Python包。因此，我们在这里探索的不是使用某种终极Python包来使用REST，而是使用Python自带的东西。</p><p id="f214" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们通常可以访问python <a class="ae ky" href="https://docs.python.org/3/library/json.html" rel="noopener ugc nofollow" target="_blank"> JSON包</a>。在此阅读用法示例<a class="ae ky" href="https://docs.python.org/3/library/json.html" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="dadb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一个基于标准安装库的Python 2.7解决方案。我们使用<code class="fe nh ni nj nk b">urllib2</code>包来创建一个URL请求。</p><pre class="kj kk kl km gt nm nk nn no aw np bi"><span id="f497" class="mj mk it nk b gy nq nr l ns nt">import urllib2<br/>import base64<br/>import json<br/><br/>url = "https://mickeymouse.jfrog.io/artifactory/api/storage/stuff/myfile.txt"<br/>login = base64.encodestring("erik:qwerty")[:-1]<br/>authheader =  "Basic %s" % login<br/><br/>req = urllib2.Request(url)<br/>req.add_header("Authorization", authheader)<br/>io = urllib2.urlopen(req)<br/><br/>s = io.read()<br/>dict = json.loads(s)<br/>dict[u'checksums'][u'md5']</span></pre><p id="f531" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个解决方案需要一些注释。例如，为什么有一个用于创建<code class="fe nh ni nj nk b">login</code>变量的<code class="fe nh ni nj nk b">[:-1]</code>？因为<code class="fe nh ni nj nk b">base64.encodestring</code>在末尾添加了一个我们不想包含的新行。它不是Base-64编码的一部分</p><p id="3655" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还要注意，用<code class="fe nh ni nj nk b">urllib2</code>你不能写:</p><pre class="kj kk kl km gt nm nk nn no aw np bi"><span id="eed1" class="mj mk it nk b gy nq nr l ns nt">url = "https://erik:qwerty@mickeymouse.jfrog.io"</span></pre><p id="c087" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">软件包会误解，认为你试图提供一个端口号，而不是提供登录名和密码。由于这个原因，我们必须用代码手动构造基本身份验证的头条目:</p><pre class="kj kk kl km gt nm nk nn no aw np bi"><span id="1d36" class="mj mk it nk b gy nq nr l ns nt">login = base64.encodestring("erik:qwerty")[:-1]<br/>authheader =  "Basic %s" % login<br/>req.add_header("Authorization", authheader)</span></pre><h2 id="e809" class="mj mk it bd ml mm mn dn mo mp mq dp mr li ms mt mu lm mv mw mx lq my mz na nb bi translated">结束语</h2><p id="90c7" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">这绝不是一个详尽的处理。我真的刚刚介绍了如何用不同的方式做一个适度复杂的REST调用。</p></div></div>    
</body>
</html>