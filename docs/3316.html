<html>
<head>
<title>Helm2 vs Helm3</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Helm2 vs Helm3</h1>
<blockquote>原文：<a href="https://itnext.io/helm2-vs-helm3-part-1-c76c29106e99?source=collection_archive---------0-----------------------#2019-11-21">https://itnext.io/helm2-vs-helm3-part-1-c76c29106e99?source=collection_archive---------0-----------------------#2019-11-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/40dfe1f5a3a330a898bfb357707f3bbe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pF-ql1YNymlesR8X"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">Syed Hussaini 在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h2 id="b5ec" class="kd ke iq bd kf kg kh dn ki kj kk dp kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">所以Helm3终于发布了。每个人都在和蒂勒说再见，但这并不是《头盔3》的唯一变化。我们来讨论一下还有什么变化。</h2></div><div class="ab cl kz la hu lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="ij ik il im in"><h1 id="b726" class="lg ke iq bd kf lh li lj ki lk ll lm kl ln lo lp kp lq lr ls kt lt lu lv kx lw bi translated"><strong class="ak">再见蒂勒</strong></h1><p id="aeeb" class="pw-post-body-paragraph lx ly iq lz b ma mb mc md me mf mg mh km mi mj mk kq ml mm mn ku mo mp mq mr ij bi translated">是的，蒂勒已经被移除，这是一件好事，但要理解为什么我们需要了解一些背景知识。Tiller是Helm的一个服务器端(运行在Kubernetes集群上)组件，它的主要目的是让多个不同的运营商能够使用同一套版本。Helm 2开发时，Kubernetes还没有基于角色的访问控制(RBAC ),因此要实现上述目标，Helm必须自己解决。它必须跟踪允许谁在哪里安装什么。从Kubernetes 1.6开始，这种复杂性就不再需要了，RBAC是默认启用的，所以没有必要让Helm去做Kubernetes本来就可以做的工作，这就是为什么在Helm 3中舵柄被完全移除了。</p><p id="864d" class="pw-post-body-paragraph lx ly iq lz b ma ms mc md me mt mg mh km mu mj mk kq mv mm mn ku mw mp mq mr ij bi translated">舵柄也被用作舵释放信息和保持舵状态的中心枢纽。在Helm 3中，相同的信息直接从Kubernetes API服务器获取，图表在客户端呈现，这使得Helm 3对Kubernetes来说更加“本地”和简单。</p><p id="242a" class="pw-post-body-paragraph lx ly iq lz b ma ms mc md me mt mg mh km mu mj mk kq mv mm mn ku mw mp mq mr ij bi translated">随着蒂勒的消失，头盔的安全模型也被简化了(RBAC启用锁定蒂勒用于生产场景是很难管理的)。头盔权限现在可以用kubeconfig文件简单评估。因此，集群管理员可以将用户权限限制在他们想要的任何级别，而版本仍然记录在集群中，Helm的其余功能保持不变。</p></div><div class="ab cl kz la hu lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="ij ik il im in"><h1 id="4a32" class="lg ke iq bd kf lh li lj ki lk ll lm kl ln lo lp kp lq lr ls kt lt lu lv kx lw bi translated">好吧，让我们忘记蒂勒。还有什么变化？</h1><p id="4c36" class="pw-post-body-paragraph lx ly iq lz b ma mb mc md me mf mg mh km mi mj mk kq ml mm mn ku mo mp mq mr ij bi translated">正如我在开头提到的——去除分蘖是一件大事，但不是唯一的重大改变。再来看看其他:</p><ul class=""><li id="8c81" class="mx my iq lz b ma ms me mt km mz kq na ku nb mr nc nd ne nf bi translated"><strong class="lz ir">三向战略合并补丁</strong></li></ul><p id="8565" class="pw-post-body-paragraph lx ly iq lz b ma ms mc md me mt mg mh km mu mj mk kq mv mm mn ku mw mp mq mr ij bi translated">头盔2使用了双向战略合并补丁。这意味着当你想要执行任何<em class="ng">掌舵</em>操作时，它会将最新的清单图表与建议的图表清单进行比较。它检查这两个图表之间的差异，以确定需要对Kubernetes中的资源进行哪些更改。听起来很聪明，对吧？问题是，如果更改被“手动”应用到集群中(例如通过<em class="ng"> kubectl edit </em>)，它们就不会被考虑。这导致资源无法回滚到其以前的状态，因为Helm2只检查了最后应用的图表清单作为其当前状态，并且由于图表状态没有变化(我们只更改了集群上的实时状态), Helm认为没有必要执行回滚。</p><p id="6071" class="pw-post-body-paragraph lx ly iq lz b ma ms mc md me mt mg mh km mu mj mk kq mv mm mn ku mw mp mq mr ij bi translated">这就是三向战略合并补丁来拯救。Helm3是怎么做到的？它也简单地考虑了活动状态(因此是3路而不是2路，因为现在我们有旧的清单、它的活动状态和新的清单)。例如，假设您部署了一个应用程序，它具有:</p><pre class="nh ni nj nk gt nl nm nn no aw np bi"><span id="d7cc" class="kd ke iq nm b gy nq nr l ns nt">helm install very_important_app ./very_important_app</span></pre><p id="3fd4" class="pw-post-body-paragraph lx ly iq lz b ma ms mc md me mt mg mh km mu mj mk kq mv mm mn ku mw mp mq mr ij bi translated">例如，此应用程序图表被设置为具有3个副本集。现在，如果有人误将执行<em class="ng"> kubectl编辑</em>或:</p><pre class="nh ni nj nk gt nl nm nn no aw np bi"><span id="23f8" class="kd ke iq nm b gy nq nr l ns nt">kubectl scale -replicas=0 deployment/very_important_app</span></pre><p id="7ae7" class="pw-post-body-paragraph lx ly iq lz b ma ms mc md me mt mg mh km mu mj mk kq mv mm mn ku mw mp mq mr ij bi translated">然后，您团队中的某个人会意识到，由于某种神秘的原因，very_important_app关闭了，并会尝试执行:</p><pre class="nh ni nj nk gt nl nm nn no aw np bi"><span id="ed72" class="kd ke iq nm b gy nq nr l ns nt">helm rollback very_important_app</span></pre><p id="134d" class="pw-post-body-paragraph lx ly iq lz b ma ms mc md me mt mg mh km mu mj mk kq mv mm mn ku mw mp mq mr ij bi translated">在头盔2中，它会生成一个补丁，将旧的清单与新的清单进行比较。因为这是一次回滚，并且某人只更改了实时状态(因此清单没有更改)，所以Helm会确定没有要回滚的内容，因为旧清单和新清单之间没有差异(两者都预期有3个副本)。此时不执行回滚，复制副本数继续保持为零。你现在开始恐慌…</p><p id="50ce" class="pw-post-body-paragraph lx ly iq lz b ma ms mc md me mt mg mh km mu mj mk kq mv mm mn ku mw mp mq mr ij bi translated">另一方面，在Helm 3中，补丁是使用旧的清单、活动状态和新的清单生成的。Helm认识到旧状态是3，活动状态是0，所以它确定新的清单意愿将它改回3，所以它生成一个补丁来修复它。你现在不要恐慌了…</p><p id="1c56" class="pw-post-body-paragraph lx ly iq lz b ma ms mc md me mt mg mh km mu mj mk kq mv mm mn ku mw mp mq mr ij bi translated">Helm 3在执行升级时也会发生类似的过程。因为它现在考虑了活动状态，所以例如，如果一些基于控制器的应用程序(或类似服务网格的东西)向通过Helm部署的kubernetes对象中注入任何东西，它将在使用Helm2的<em class="ng"> helm升级</em>过程中被移除。《头盔3》没有做到这一点——同样，它考虑到了实时状态。假设我们想在集群上安装Istio。Istio将开始在任何部署中注入边车容器，所以假设你用Helm部署了一些东西，你的部署包括:</p><pre class="nh ni nj nk gt nl nm nn no aw np bi"><span id="6a97" class="kd ke iq nm b gy nq nr l ns nt">containers:<br/>- name: server<br/>  image: my_app:2.0.0</span></pre><p id="b1cc" class="pw-post-body-paragraph lx ly iq lz b ma ms mc md me mt mg mh km mu mj mk kq mv mm mn ku mw mp mq mr ij bi translated">然后您安装了Istio，所以您的容器定义现在看起来像这样:</p><pre class="nh ni nj nk gt nl nm nn no aw np bi"><span id="2051" class="kd ke iq nm b gy nq nr l ns nt">containers:<br/>- name: server<br/>  image: my_app:2.0.0<br/>- name: istio-sidecar<br/>  image: istio-sidecar-proxy:1.0.0</span></pre><p id="31d1" class="pw-post-body-paragraph lx ly iq lz b ma ms mc md me mt mg mh km mu mj mk kq mv mm mn ku mw mp mq mr ij bi translated">如果您现在使用Helm2执行升级过程，您将得到以下结果:</p><pre class="nh ni nj nk gt nl nm nn no aw np bi"><span id="369f" class="kd ke iq nm b gy nq nr l ns nt">containers:<br/>- name: server<br/>  image: my_app:2.1.0</span></pre><p id="a06e" class="pw-post-body-paragraph lx ly iq lz b ma ms mc md me mt mg mh km mu mj mk kq mv mm mn ku mw mp mq mr ij bi translated">Istio sidecar被删除，因为它不在图表中。然而，Helm 3在旧清单、活动状态和新清单之间生成容器对象的补丁。它注意到新的清单将image标签更改为2.1.0，但是live state包含一些额外的内容。所以用头盔3升级会如你所料:</p><pre class="nh ni nj nk gt nl nm nn no aw np bi"><span id="0be2" class="kd ke iq nm b gy nq nr l ns nt">containers:<br/>- name: server<br/>  image: my_app:2.1.0<br/>- name: istio-sidecar<br/>  image: istio-sidecar-proxy:1.0.0</span></pre><p id="3a81" class="pw-post-body-paragraph lx ly iq lz b ma ms mc md me mt mg mh km mu mj mk kq mv mm mn ku mw mp mq mr ij bi translated">三路战略合并补丁使掌舵方式更可预测和更安全。你再也不用担心事情会变糟。</p><figure class="nh ni nj nk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nu"><img src="../Images/372496ebe40540e6641e9899286d1b5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dqCruyxXaxe5PZyN"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">乔治·特罗瓦托在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure></div><div class="ab cl kz la hu lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="ij ik il im in"><p id="57b8" class="pw-post-body-paragraph lx ly iq lz b ma ms mc md me mt mg mh km mu mj mk kq mv mm mn ku mw mp mq mr ij bi translated"><strong class="lz ir">秘密作为默认存储驱动</strong></p><p id="d156" class="pw-post-body-paragraph lx ly iq lz b ma ms mc md me mt mg mh km mu mj mk kq mv mm mn ku mw mp mq mr ij bi translated">Helm 2使用配置图来存储发布信息。在《头盔3》中，秘密被用作默认的存储驱动(秘密类型为<em class="ng">helm.sh/release</em>)。这带来了一些好处，极大地简化了Helm的功能。为了获取(并应用)配置，Helm2必须执行相当多的操作，因为配置本身被加密存储并存档在一个密钥或ConfigMap中。Helm3将配置直接存储在秘密中，因此无需执行多个操作来获取它，它可以简单地取出秘密，解密并应用。另一个优点是发布名称在集群中不再是唯一的。包含版本的机密存储在安装版本的名称空间中。因此，只要它们位于不同的名称空间中，您就可以拥有多个同名的版本。</p><p id="692e" class="pw-post-body-paragraph lx ly iq lz b ma ms mc md me mt mg mh km mu mj mk kq mv mm mn ku mw mp mq mr ij bi translated"><strong class="lz ir"> JSON模式图表验证</strong></p><p id="57f1" class="pw-post-body-paragraph lx ly iq lz b ma ms mc md me mt mg mh km mu mj mk kq mv mm mn ku mw mp mq mr ij bi translated">现在可以对图表值强制进行JSON模式验证。使用该功能，您可以确保用户提供的值遵循图表维护者创建的模式。这为OPS和DEV的合作创造了更多的可能性(OPS团队可以给DEV更多的自由),并在用户试图为图表使用一组不正确的值时提供更好的错误报告。</p><p id="5a91" class="pw-post-body-paragraph lx ly iq lz b ma ms mc md me mt mg mh km mu mj mk kq mv mm mn ku mw mp mq mr ij bi translated"><strong class="lz ir">现在需要发布名称</strong></p><p id="53cd" class="pw-post-body-paragraph lx ly iq lz b ma ms mc md me mt mg mh km mu mj mk kq mv mm mn ku mw mp mq mr ij bi translated">在头盔2中，如果没有提供名字，将会产生一个随机的名字。如果helm install没有提供名称，Helm 3将会抛出一个错误(如果您仍然想使用随机名称，最终您可以使用<em class="ng"> — generate-name </em>标志)</p><p id="76f3" class="pw-post-body-paragraph lx ly iq lz b ma ms mc md me mt mg mh km mu mj mk kq mv mm mn ku mw mp mq mr ij bi translated"><strong class="lz ir"> <em class="ng">掌舵发球</em>撤下</strong></p><p id="1036" class="pw-post-body-paragraph lx ly iq lz b ma ms mc md me mt mg mh km mu mj mk kq mv mm mn ku mw mp mq mr ij bi translated">没有多少人使用<em class="ng"> helm serve ( </em>用于<em class="ng"> </em>在你的机器上运行本地图表库用于开发目的<em class="ng"> ) </em>，但是对于那些使用过的人来说——它现在被移除了。尽管你仍然可以把它作为一个插件来使用。</p><p id="9b59" class="pw-post-body-paragraph lx ly iq lz b ma ms mc md me mt mg mh km mu mj mk kq mv mm mn ku mw mp mq mr ij bi translated"><strong class="lz ir">不再自动创建名称空间</strong></p><p id="22fd" class="pw-post-body-paragraph lx ly iq lz b ma ms mc md me mt mg mh km mu mj mk kq mv mm mn ku mw mp mq mr ij bi translated">当在一个不存在的名称空间中创建一个版本时，Helm 2会自动创建它。Helm 3遵循其他Kubernetes工具的行为，如果名称空间不存在，则返回一个错误。</p></div><div class="ab cl kz la hu lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="ij ik il im in"><p id="e670" class="pw-post-body-paragraph lx ly iq lz b ma ms mc md me mt mg mh km mu mj mk kq mv mm mn ku mw mp mq mr ij bi translated">这是掌舵中最重要的变化，还有更多。如果你有兴趣，请查看官方文件。在第2部分中，我将向您展示如何从Helm2迁移到Helm3。</p></div></div>    
</body>
</html>